<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="0dc45828951839d51ed09a34e9ec04114252f1c0" translate="yes" xml:space="preserve">
          <source>SIG_ATOMIC_MAX</source>
          <target state="translated">SIG_ATOMIC_MAX</target>
        </trans-unit>
        <trans-unit id="ed5fe11c179ff72e658bdf95049d44be1deebeae" translate="yes" xml:space="preserve">
          <source>SIG_ATOMIC_MIN</source>
          <target state="translated">SIG_ATOMIC_MIN</target>
        </trans-unit>
        <trans-unit id="11ba97d97359684906853156cac74443ad3705c5" translate="yes" xml:space="preserve">
          <source>SIG_DFL, SIG_IGN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6895a2910b6ef7a004e7772ca3f499a19fa27cde" translate="yes" xml:space="preserve">
          <source>SIG_DFLSIG_IGN</source>
          <target state="translated">SIG_DFLSIG_IGN</target>
        </trans-unit>
        <trans-unit id="acd6ee1f7bbae2aab00eb4fc3df100932eee5d46" translate="yes" xml:space="preserve">
          <source>SIG_ERR</source>
          <target state="translated">SIG_ERR</target>
        </trans-unit>
        <trans-unit id="6a03d61729004eed59186d910c6f0d01251b936b" translate="yes" xml:space="preserve">
          <source>SIG_IGN</source>
          <target state="translated">SIG_IGN</target>
        </trans-unit>
        <trans-unit id="256c9f9a067e633db18da0ec81de7b585e074898" translate="yes" xml:space="preserve">
          <source>SIZE_MAX</source>
          <target state="translated">SIZE_MAX</target>
        </trans-unit>
        <trans-unit id="6b120e14066922d2c95dfb4dc0409090007a4356" translate="yes" xml:space="preserve">
          <source>SOFT HYPHEN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35adac21ea20f23e44a0f9718d8d1c8194e953c8" translate="yes" xml:space="preserve">
          <source>SOO</source>
          <target state="translated">SOO</target>
        </trans-unit>
        <trans-unit id="5fa55a6001cc9852171849c95c4031c7b8464066" translate="yes" xml:space="preserve">
          <source>SSO</source>
          <target state="translated">SSO</target>
        </trans-unit>
        <trans-unit id="d77543daa1a67aba4224a92c3a2e905f4d7d3caf" translate="yes" xml:space="preserve">
          <source>SUPERSCRIPT TWO - MICRO SIGN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecc39ffd33475d94ae9c3663ce19924217f5ad56" translate="yes" xml:space="preserve">
          <source>SYRIAC LETTER BETH - GREEK DASIA</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f9ffea621b762dbfb7be294c8d40ffe49bec187" translate="yes" xml:space="preserve">
          <source>Safely converts pointers and references to classes up, down, and sideways along the inheritance hierarchy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b76aee974c5bb8b37f0f7cb657a1de3a091c77c3" translate="yes" xml:space="preserve">
          <source>Same</source>
          <target state="translated">Same</target>
        </trans-unit>
        <trans-unit id="a744c69a2ecd83490fd88d463f1cfbe827dbb30e" translate="yes" xml:space="preserve">
          <source>Same applies to dot operator following an integer or floating-point user-defined literal:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a5254cea4091f8ebcab7a4aa66c35896845aed" translate="yes" xml:space="preserve">
          <source>Same applies to the lifetime of the object pointed to by the captured &lt;code&gt;this&lt;/code&gt; pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c7b71f021b8cdf1bd6c0b20d7e10412fb74444f" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;p&lt;/code&gt;'s construction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6c01bbf4fe382bbcb4f95f2825434f25228cf1c" translate="yes" xml:space="preserve">
          <source>Same as glvalue (below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84f78fbebf7e3bcf9865660ef89b13869f35e07f" translate="yes" xml:space="preserve">
          <source>Same as rvalue (below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0f78a1b71ae77c728d70862a9e3368568083194" translate="yes" xml:space="preserve">
          <source>Same as swapping the underlying container.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="054e7e20cdfbca536050cb79e89a02a85759a9a9" translate="yes" xml:space="preserve">
          <source>Same as the corresponding operation on the wrapped container.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e1da25a3233f63ae21f226c776372740cc6993a" translate="yes" xml:space="preserve">
          <source>Same as underlying container (typically constant).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7796be95ee97968bc00eac447bfca361f350fb8" translate="yes" xml:space="preserve">
          <source>Sampling distributions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aa4ace930e13f1369da3a2f415ac3d312db56cf" translate="yes" xml:space="preserve">
          <source>Satisfaction of an atomic constraint is checked by substituting the parameter mapping and template arguments into the expression &lt;code&gt;E&lt;/code&gt;. If the substitution results in an invalid type or expression, the constraint is not satisfied. Otherwise, &lt;code&gt;E&lt;/code&gt;, after any lvalue-to-rvalue conversion, shall be a prvalue constant expression of type &lt;code&gt;bool&lt;/code&gt; , and the constraint is satisfied if and only if it evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a79fb659ab4ca153a9d632c0dbfaa99b80dbe0d" translate="yes" xml:space="preserve">
          <source>Satisfies &lt;a href=&quot;nullablepointer&quot;&gt;NullablePointer&lt;/a&gt;, &lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, and &lt;a href=&quot;contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt; (see &lt;a href=&quot;allocator#Fancy_pointers&quot;&gt;fancy pointers&lt;/a&gt; below)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c939f8b440f4e444c93888c7523c6a753295690a" translate="yes" xml:space="preserve">
          <source>Saves a copy of the current pointer &lt;code&gt;old_ptr = current_ptr&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dcd124e9d2652692f02ca05f075f2889be740f0" translate="yes" xml:space="preserve">
          <source>Saves the current execution context into a variable &lt;code&gt;env&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;jmp_buf&quot;&gt;std::jmp_buf&lt;/a&gt;&lt;/code&gt;. This variable can later be used to restore the current execution context by &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; function. That is, when a call to &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; function is made, the execution continues at the particular call site that constructed the &lt;code&gt;&lt;a href=&quot;jmp_buf&quot;&gt;std::jmp_buf&lt;/a&gt;&lt;/code&gt; variable passed to &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt;. In that case &lt;code&gt;setjmp&lt;/code&gt; returns the value passed to &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0e38625398ddd28f177386b7df9d368b87ce9c8" translate="yes" xml:space="preserve">
          <source>Scalar types and arrays of TriviallyCopyable objects are TriviallyCopyable as well, as well as the &lt;a href=&quot;../language/cv&quot;&gt;const&lt;/a&gt;-qualified (but not &lt;a href=&quot;../language/cv&quot;&gt;volatile&lt;/a&gt;-qualified) versions of such types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94a0975d11ee0823098d55f8c5543d8c95757535" translate="yes" xml:space="preserve">
          <source>Scan an array of mailboxes, and process only the ones intended for us, without unnecessary synchronization. This example uses atomic-fence synchronization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39320a9f36bca32338b46a710d9f674ca8c85e52" translate="yes" xml:space="preserve">
          <source>Scans the null-terminated byte string pointed to by &lt;code&gt;dest&lt;/code&gt; for any character from the null-terminated byte string pointed to by &lt;code&gt;breakset&lt;/code&gt;, and returns a pointer to that character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4651a34e4df9619783ad372f905d6d3b84e9d76d" translate="yes" xml:space="preserve">
          <source>Scope</source>
          <target state="translated">Scope</target>
        </trans-unit>
        <trans-unit id="3c0fabcd3460b1386add05b5b912787b96bceeaa" translate="yes" xml:space="preserve">
          <source>Scope begins at the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4317efd965faa4c9e59bd6003e10dbe6e565fc82" translate="yes" xml:space="preserve">
          <source>Scope resolution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="931b2f0203a11cf4f16ccf11a8abc5d164f83cd5" translate="yes" xml:space="preserve">
          <source>Scope-Bound Resource Management</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6144de524b9c3009de80c6ebb469d9da9d780fe8" translate="yes" xml:space="preserve">
          <source>Scoped enumerations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bce06414177f72ab70e6387b6af9f8ceef0d6049" translate="yes" xml:space="preserve">
          <source>Search</source>
          <target state="translated">Search</target>
        </trans-unit>
        <trans-unit id="f2535d6e767f49b8124024bcd11da510f6f782bd" translate="yes" xml:space="preserve">
          <source>Search an array of characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="081570b66f26a6217e51edfae5b2f5f442c3bbc8" translate="yes" xml:space="preserve">
          <source>Searchers</source>
          <target state="translated">Searchers</target>
        </trans-unit>
        <trans-unit id="be80c5d8537a2b3c995d81bdb8d3ae633186fea1" translate="yes" xml:space="preserve">
          <source>Searchers implementing several string searching algorithms are provided and can be used either directly or with &lt;code&gt;&lt;a href=&quot;../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33c71193b71000219f2bd6b9f54cb3bf29a41ddc" translate="yes" xml:space="preserve">
          <source>Searches for character &lt;code&gt;ch&lt;/code&gt; within the first &lt;code&gt;count&lt;/code&gt; characters of the sequence pointed to by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37caebe595bd3a25fdffa0ec8c5c448832c11501" translate="yes" xml:space="preserve">
          <source>Searches for the last occurrence of the sequence &lt;code&gt;[s_first, s_last)&lt;/code&gt; in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="754ce955d614da4c802b64da2e1c3ddc6bee054d" translate="yes" xml:space="preserve">
          <source>Searches the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769049f398e61b7f7ad4e6b14c38a23da9c22170" translate="yes" xml:space="preserve">
          <source>Searches the range &lt;code&gt;[first, last)&lt;/code&gt; for any of the elements in the range &lt;code&gt;[s_first, s_last)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e308cb25d0ed13526c73f64ffe66b93da65e203" translate="yes" xml:space="preserve">
          <source>Searches the range &lt;code&gt;[first, last)&lt;/code&gt; for the first sequence of count identical elements, each equal to the given value value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fa3cd6cb9bf46973989d4709c8226edf99fa4ae" translate="yes" xml:space="preserve">
          <source>Searches the range &lt;code&gt;[first, last)&lt;/code&gt; for two consecutive identical elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c36d1e16b84bc65d65582ef2f66c0a6af5df9a5" translate="yes" xml:space="preserve">
          <source>Second version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b7372ecf5cd839751ecadd7eb6342e697de5920" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../../language/delete&quot;&gt;delete-expression&lt;/a&gt; for exact details on the overload resolution rules between alignment-aware and alignment-unaware overloads of usual (non-placement) deallocation functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae818aabc9d932654ddcaaf489a23a68152adf27" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../../language/implicit_cast#Integral_conversions&quot;&gt;integral conversions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6378dcdb16aa74b2d40b16a1e6ee4135e9695749" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../ios_base/iostate&quot;&gt;&lt;code&gt;ios_base::iostate&lt;/code&gt;&lt;/a&gt; for the list of conditions that set &lt;code&gt;badbit&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dee8fd6f97edfa7a7cf0f34968b55a706acc4284" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../ios_base/iostate&quot;&gt;&lt;code&gt;ios_base::iostate&lt;/code&gt;&lt;/a&gt; for the list of conditions that set &lt;code&gt;eofbit&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9ae9ac7299d29baeec9d43cbba4ba0ce1c9aa6e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../ios_base/iostate&quot;&gt;&lt;code&gt;ios_base::iostate&lt;/code&gt;&lt;/a&gt; for the list of conditions that set &lt;code&gt;failbit&lt;/code&gt; or &lt;code&gt;badbit&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c25f06c677695c66cf5160af1585d19e44dae901" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../ios_base/iostate&quot;&gt;&lt;code&gt;ios_base::iostate&lt;/code&gt;&lt;/a&gt; for the list of conditions that set the stream status bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="174c2342f47ac83dd4dd125d8e0118900b8a0e79" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../language/data_members#Standard_layout&quot;&gt;Standard layout&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e50ce5cb884f5a58dd6c6ce681c3eba7330d42fa" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../language/template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; for the special rules behind forwarding references (&lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; used as a function parameter) and &lt;a href=&quot;../language/reference#Forwarding_references&quot;&gt;forwarding references&lt;/a&gt; for other detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39bd03185bceffe6a43d25662a58dc151998d110" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../memory/shared_ptr/atomic2&quot;&gt;std::atomic&amp;lt;std::shared_ptr&amp;gt;&lt;/a&gt; and &lt;a href=&quot;../memory/weak_ptr/atomic2&quot;&gt;std::atomic&amp;lt;std::weak_ptr&amp;gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e167622e5c42d7bf8a95ec5740e244c7093b646f" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../types/climits#Limits_of_floating_point_types&quot;&gt;Limits of floating point types&lt;/a&gt; and &lt;a href=&quot;../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt; for additional details, limits, and properties of the floating-point types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2274fab11ee4834d5966c40c307e91c5df243ce8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;classes&quot;&gt;classes&lt;/a&gt; for general overview of the syntax. If class-key is &lt;code&gt;union&lt;/code&gt;, the declaration introduces a &lt;a href=&quot;union&quot;&gt;union type&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ba0349c426a2f24e3620c1aa021d44618face46" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;default_comparisons&quot;&gt;default comparisons&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="429a878af958318f5598c06dd5a9dc47b55c4f9e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;derived_class&quot;&gt;derived classes&lt;/a&gt; for the meaning of public, protected, and private inheritance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="914ee0d12625d0d50c9171297ac04778b61de7f4" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ced721a5d7f98361f7017a972c098ee6051d9a7a" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;escape&quot;&gt;escape sequences&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44c333ad00625ae699f2584f163b982fd72ac7a1" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74cdc7b25c3c97c3a8434eb20f61651a5eb87ae3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;fe_round&quot;&gt;floating-point rounding macros&lt;/a&gt; for the effects of rounding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29e4344e032e36ed94ddfee614e0e36909dc87e6" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;function#Return_type_deduction&quot;&gt;function#Return_type_deduction&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8283046607e90210c1c29d8f4f84a8fab2d1ede3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/special_math&quot;&gt;Mathematical special functions&lt;/a&gt; for the ISO/IEC 29124:2010 version of this library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0aae26af8fe26013b5446f34d12625d4c3f4ca0" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;implicit_cast#Integral_conversions&quot;&gt;Integral conversions&lt;/a&gt; for implicit conversions from &lt;code&gt;bool&lt;/code&gt; to other types and &lt;a href=&quot;implicit_cast#Boolean_conversions&quot;&gt;boolean conversions&lt;/a&gt; for the implicit conversions from other types to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d388b1ae038b8ac6156d9085ce7d62388e00ee" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;lambda#Lambda_capture&quot;&gt;below&lt;/a&gt; for the detailed description of captures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cad14c22748843bfa2798b2b209a13ead862881" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;member_template#Conversion_function_templates&quot;&gt;member template&lt;/a&gt; for other rules regarding conversion function templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad0d65393aca93e974d44085f5919bd7839c0d28" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;namespace&quot;&gt;namespace&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="102f8e37106ae040bb5f89e22fa071d096f41648" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;objects#Alignment&quot;&gt;alignment&lt;/a&gt; for the meaning and properties of the value returned by &lt;code&gt;alignof&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55b4bb18224bfdfff99896bdba23ef4d69d413d1" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;operators#Assignment_operator&quot;&gt;assignment operator overloading&lt;/a&gt; for additional detail on the expected behavior of a user-defined copy-assignment operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb67647e0da113c3fbe9fee863f0d9d63fe13a8d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;operators#Assignment_operator&quot;&gt;assignment operator overloading&lt;/a&gt; for additional detail on the expected behavior of a user-defined move-assignment operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5493d4122dd67d4c17caa6d5ef78b487507ea02" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt; for the details of the name lookup for qualified identifiers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24c313aec15f752b8eef19d4f89751a772bc838e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;static&quot;&gt;static data members&lt;/a&gt; for additional rules about inline static members.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="605869828b172cc97a29434e43b6498562b03788" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="283313eb9b1d55b39e9f5d89e00fc3a1bf6de70e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;throw&quot;&gt; throw exceptions&lt;/a&gt; for more information about throw-expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69df8ac605b2aefcade71d4a0331b3b48494c6a9" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;try_catch&quot;&gt; try-catch block&lt;/a&gt; for more information about</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17f682c920cda25dc371eb3bc3ea16fcc0afeebf" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;using_declaration&quot;&gt;using declaration&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7daaa65ada396227e4a622fdcc20e20911f6b1c" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;&lt;a href=&quot;../../atomic/kill_dependency&quot;&gt;std::kill_dependency&lt;/a&gt;&lt;/code&gt; for example usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b8073db41056b2af9125a4b55737d9e0d4b080" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; for the handling of errors that arise during exception handling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf502c77fe0dc9f40d34f9c7f2c4d63957dc4f8b" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;&lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; for further details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd9cdf06a8071ae98a7163dd1f7bbfd07f483e5f" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt; for the description of the semantics of condition variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67373bb92cd7ecbf243edb9d60ad6f00f86a6052" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f79bb58417489ef566fe0f186f5e68a673856c4b" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;../types/integer&quot;&gt;Fixed width integer types&lt;/a&gt;.(since C++11).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="724eeee50828e55ed4fb99b05ec0d10f041d0b32" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;template_argument_deduction#Deduction_from_a_function_call&quot;&gt;template argument deduction&lt;/a&gt; and &lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29bf3e42f6bade0c2ad8b91112d660163e3f9bb3" translate="yes" xml:space="preserve">
          <source>See also &lt;code&gt;&lt;a href=&quot;kill_dependency&quot;&gt;std::kill_dependency&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;[[&lt;a href=&quot;../language/attributes/carries_dependency&quot;&gt;carries_dependency&lt;/a&gt;]]&lt;/code&gt; for fine-grained dependency chain control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a9b1a0ad5fb2550b4eaca7c7ed9743c7009041" translate="yes" xml:space="preserve">
          <source>See also &lt;code&gt;&lt;a href=&quot;numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt; interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fe39f07296abb94820a0213f51053afc2b83f28" translate="yes" xml:space="preserve">
          <source>See also the implementations in &lt;a href=&quot;https://github.com/gcc-mirror/gcc/blob/d9375e490072d1aae73a93949aa158fcd2a27018/libstdc%20%20-v3/include/bits/stl_algo.h#L1125-L1187&quot;&gt;libstdc++&lt;/a&gt; and &lt;a href=&quot;https://github.com/llvm-mirror/libcxx/blob/a12cb9d211019d99b5875b6d8034617cbc24c2cc/include/algorithm#L2259-L2291&quot;&gt;libc++&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abcd5647b5dbfde0bf3b5841d67951f24a735a10" translate="yes" xml:space="preserve">
          <source>See also the implementations in &lt;a href=&quot;https://github.com/gcc-mirror/gcc/blob/d9375e490072d1aae73a93949aa158fcd2a27018/libstdc%20%20-v3/include/bits/stl_algo.h#L1207&quot;&gt;libstdc++&lt;/a&gt; and &lt;a href=&quot;https://github.com/llvm-mirror/libcxx/blob/a12cb9d211019d99b5875b6d8034617cbc24c2cc/include/algorithm#L2298&quot;&gt;libc++&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ad1a04d56e3d6822bfa65c3769d0ddd0aa829c4" translate="yes" xml:space="preserve">
          <source>See also the implementations in &lt;a href=&quot;https://github.com/gcc-mirror/gcc/blob/d9375e490072d1aae73a93949aa158fcd2a27018/libstdc%20%20-v3/include/bits/stl_algo.h#L1249&quot;&gt;libstdc++&lt;/a&gt; and &lt;a href=&quot;https://github.com/llvm-mirror/libcxx/blob/a12cb9d211019d99b5875b6d8034617cbc24c2cc/include/algorithm#L2417&quot;&gt;libc++&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7972791dec6e10e047e38baff6fab2a8513c7838" translate="yes" xml:space="preserve">
          <source>See also the implementations in &lt;a href=&quot;https://github.com/gcc-mirror/gcc/blob/d9375e490072d1aae73a93949aa158fcd2a27018/libstdc%20%20-v3/include/bits/stl_algo.h#L1461&quot;&gt;libstdc++&lt;/a&gt; and &lt;a href=&quot;https://github.com/llvm-mirror/libcxx/blob/a12cb9d211019d99b5875b6d8034617cbc24c2cc/include/algorithm#L2482&quot;&gt;libc++&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10ed34d430c362ea64daf3b6f9f28052ab07af01" translate="yes" xml:space="preserve">
          <source>SeedSequence</source>
          <target state="translated">SeedSequence</target>
        </trans-unit>
        <trans-unit id="3f0cf8e2782befc24fe377038ac19de212006a14" translate="yes" xml:space="preserve">
          <source>Seeds the pseudo-random number generator used by &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;std::rand()&lt;/a&gt;&lt;/code&gt; with the value &lt;code&gt;seed&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e1921a75e80a596c9a940068df630bd1b9feed6" translate="yes" xml:space="preserve">
          <source>Selection statements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29b9ea4555f2e87f0b5e1a8666aa986618f09c19" translate="yes" xml:space="preserve">
          <source>Selection statements choose between one of several flows of control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="776c569a16268c74debac2a7f912b4ace14fe2d5" translate="yes" xml:space="preserve">
          <source>Selects &lt;code&gt;n&lt;/code&gt; elements from the sequence [first; last) such that each possible sample has equal probability of appearance, and writes those selected elements into the output iterator &lt;code&gt;out&lt;/code&gt;. Random numbers are generated using the random number generator &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe03c3515833357d89e7094df960e757cae3bc1d" translate="yes" xml:space="preserve">
          <source>Semantics</source>
          <target state="translated">Semantics</target>
        </trans-unit>
        <trans-unit id="fcb3a84856a9093f8cbfaa3811dd4b157eac0989" translate="yes" xml:space="preserve">
          <source>Semiregular</source>
          <target state="translated">Semiregular</target>
        </trans-unit>
        <trans-unit id="5ab18e1afa30ee21a995753ce9370cb63f6c68b4" translate="yes" xml:space="preserve">
          <source>Semiregular wrapper</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d982da36907626a11a5ba3e814abbe3a393e179" translate="yes" xml:space="preserve">
          <source>Semiregular wrapper (C++20)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="058beef7599ef0fca7a043fe7e6842246cc841f4" translate="yes" xml:space="preserve">
          <source>Sends signal sig to the program. The signal handler (specified using the &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;std::signal()&lt;/a&gt;&lt;/code&gt; function) is invoked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b723f9a0711150c35ac643e01416774bd288ff8" translate="yes" xml:space="preserve">
          <source>Sentinel</source>
          <target state="translated">Sentinel</target>
        </trans-unit>
        <trans-unit id="ade75186a4f45f23ca1cb8f7cad6a1638de0d6e0" translate="yes" xml:space="preserve">
          <source>Separates the thread of execution from the thread object, allowing execution to continue independently. Any allocated resources will be freed once the thread exits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="627861d895f61db64e072c3541f0299ce0be392b" translate="yes" xml:space="preserve">
          <source>Sequence containers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f156be6c395dbb2a3a82e5a5a15edfff2ce72c6" translate="yes" xml:space="preserve">
          <source>Sequence containers implement data structures which can be accessed sequentially.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="586248de4df6f2fb686141acbe275f15919cdcd3" translate="yes" xml:space="preserve">
          <source>Sequence containers in the standard library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dd2a98d87981aeed996e59fae4a850b7b8cce75" translate="yes" xml:space="preserve">
          <source>SequenceContainer</source>
          <target state="translated">SequenceContainer</target>
        </trans-unit>
        <trans-unit id="cb196565d6396245ad6a50208b3e628e5f581b0b" translate="yes" xml:space="preserve">
          <source>Sequenced-before</source>
          <target state="translated">Sequenced-before</target>
        </trans-unit>
        <trans-unit id="64cf851b8491eff8f5a5c736de201846803398a1" translate="yes" xml:space="preserve">
          <source>Sequential ordering may be necessary for multiple producer-multiple consumer situations where all consumers must observe the actions of all producers occurring in the same order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a3c02107bfafa471d5b3be0bbb231a73bba241c" translate="yes" xml:space="preserve">
          <source>Sequentially-consistent ordering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9dd132139144d6bb8d37bb56baaf697a3046e5a" translate="yes" xml:space="preserve">
          <source>Set group ID to file's user group ID on execution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1637e859e4377992588527df8ff19bd1c80c203" translate="yes" xml:space="preserve">
          <source>Set operations (on sorted ranges)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89aff6dc709371a1e75349cff7f89ce318bf48f3" translate="yes" xml:space="preserve">
          <source>Set user ID to file owner user ID on execution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a7c71125a1b285d19cc080c75758da9c81b3646" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;e == E()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5472e26bd7acfe2a9e13b0c0a52960a1f0c432c5" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;e == E(q)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0afe1632304164b54c66cff4a98eb13baed5d65" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;e == E(s)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23d22a46a8394d6e4f18b68e1628cb04aa3fe300" translate="yes" xml:space="preserve">
          <source>Sets all bits to &lt;code&gt;true&lt;/code&gt; or to specified value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43384d288b4c5906f92816e5a1a730f85b8f1fb4" translate="yes" xml:space="preserve">
          <source>Sets bits to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df702a27723655552b5082b9500508a154b9a7a9" translate="yes" xml:space="preserve">
          <source>Sets input position indicator of the current associated &lt;code&gt;streambuf&lt;/code&gt; object. In case of failure, calls &lt;code&gt;setstate(&lt;a href=&quot;../ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="990595a0ab4c45f3eb5d0fcf59aa896be2bd913a" translate="yes" xml:space="preserve">
          <source>Sets the associated locale of the stream to the given one. Before returning, each function, registered by &lt;code&gt;&lt;a href=&quot;register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; is called with &lt;code&gt;imbue_event&lt;/code&gt; as a parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="995344713122a7e40f3d1c41777d1c25df014b44" translate="yes" xml:space="preserve">
          <source>Sets the associated stream buffer to &lt;code&gt;sb&lt;/code&gt; and initializes the internal state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7a3958ed34eda423f1812162bb7ead7f8f7386b" translate="yes" xml:space="preserve">
          <source>Sets the associated stream buffer to &lt;code&gt;sb&lt;/code&gt; without clearing the error state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc84cbf09f54497d82bb5b62d2a2d517c0f640e5" translate="yes" xml:space="preserve">
          <source>Sets the file position indicator and the multibyte parsing state (if any) for the C file stream &lt;code&gt;stream&lt;/code&gt; according to the value pointed to by &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8981596fc41bcb7790694f68d1d762fd8c679d5" translate="yes" xml:space="preserve">
          <source>Sets the file position indicator for the file stream &lt;code&gt;stream&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd531265ea608469a544e2f55635683ca3d4497c" translate="yes" xml:space="preserve">
          <source>Sets the formatting flags to specified settings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79eb6b783a4567ddc5405a0414a0c6ec9ca40fb5" translate="yes" xml:space="preserve">
          <source>Sets the handler for signal &lt;code&gt;sig&lt;/code&gt;. The signal handler can be set so that default handling will occur, signal is ignored, or a user-defined function is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09a2100140edfd67ac8ff2932600ec68a127f06e" translate="yes" xml:space="preserve">
          <source>Sets the initial value of an object to zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1eb3620fe2b05e18c0f858094a88945ee7f3c72" translate="yes" xml:space="preserve">
          <source>Sets the initial values of the &lt;a href=&quot;storage_duration&quot;&gt;static&lt;/a&gt; variables to a compile-time constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1ca0346b3e08f30a6472d9f167a325e8d1e4753" translate="yes" xml:space="preserve">
          <source>Sets the internal buffer to use for I/O operations performed on the C stream &lt;code&gt;stream&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd02608b401728e9aec88e6cbdb388fde515882f" translate="yes" xml:space="preserve">
          <source>Sets the number of buckets to &lt;code&gt;count&lt;/code&gt; and rehashes the container, i.e. puts the elements into appropriate buckets considering that total number of buckets has changed. If the new number of buckets makes load factor more than maximum load factor (&lt;code&gt;count &amp;lt; size() / max_load_factor()&lt;/code&gt;), then the new number of buckets is at least &lt;code&gt;size() / max_load_factor()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44ffba405c63cb8f4ea0d962441828c7289a2a74" translate="yes" xml:space="preserve">
          <source>Sets the number of buckets to the number needed to accomodate at least &lt;code&gt;count&lt;/code&gt; elements without exceeding maximum load factor and rehashes the container, i.e. puts the elements into appropriate buckets considering that total number of buckets has changed. Effectively calls &lt;code&gt;rehash(&lt;a href=&quot;../../numeric/math/ceil&quot;&gt;std::ceil&lt;/a&gt;(count / max_load_factor()))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="872d658af6ea90478845715a23df835aadd67a4f" translate="yes" xml:space="preserve">
          <source>Sets the numeric base of the stream. When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; setbase(base)&lt;/code&gt; or &lt;code&gt;in &amp;gt;&amp;gt; setbase(base)&lt;/code&gt;, changes the &lt;code&gt;basefield&lt;/code&gt; flag of the stream &lt;code&gt;out&lt;/code&gt; or &lt;code&gt;in&lt;/code&gt;, depending on the value of &lt;code&gt;base&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4458ba443567a1698e8223d365c93646c1809952" translate="yes" xml:space="preserve">
          <source>Sets the output position indicator of the current associated &lt;code&gt;streambuf&lt;/code&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f848851d17ce421067d84a2f77e7deaea69e3c90" translate="yes" xml:space="preserve">
          <source>Sets the position indicator of the input and/or output sequence relative to some other position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a8ee43d265a420d1f758efe248a25c59cb316ca" translate="yes" xml:space="preserve">
          <source>Sets the position indicator of the input and/or output sequence to an absolute position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13053efd8b77ed7f7e086552a051ef07d0612487" translate="yes" xml:space="preserve">
          <source>Sets the stream error flags &lt;code&gt;state&lt;/code&gt; in addition to currently set flags. Essentially calls &lt;code&gt;clear(rdstate() | state)&lt;/code&gt;. May throw an exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a6e53a3b1a7551e0adedf2f964d9589e2d7700d" translate="yes" xml:space="preserve">
          <source>Sets the stream error state flags by assigning them the value of &lt;code&gt;state&lt;/code&gt;. By default, assigns &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;std::ios_base::goodbit&lt;/a&gt;&lt;/code&gt; which has the effect of clearing all error state flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31107c4e3971ba07d2b23b105a5b48d627e90338" translate="yes" xml:space="preserve">
          <source>Sets the values of the pointers defining the get area. Specifically, after the call &lt;code&gt;eback() == gbeg&lt;/code&gt;, &lt;code&gt;gptr() == gcurr&lt;/code&gt;, &lt;code&gt;egptr() == gend&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c80d20a12ae08a03e22ce68dd881ce0d84f3b63" translate="yes" xml:space="preserve">
          <source>Sets the values of the pointers defining the put area. Specifically, after the call &lt;code&gt;pbase() == pbeg&lt;/code&gt;, &lt;code&gt;pptr() == pbeg&lt;/code&gt;, &lt;code&gt;epptr() == pend&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5199b18d2d2b0a0af45438d34940fd5e1b006963" translate="yes" xml:space="preserve">
          <source>Sets whether the standard C++ streams are synchronized to the standard C streams after each input/output operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64e31adef7a3933fd26bffedd7b084d8fec7dcc6" translate="yes" xml:space="preserve">
          <source>Setting the result</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="236b5bbbb7e1393bb181a9a22a43242bd679e759" translate="yes" xml:space="preserve">
          <source>Several C++ compilers transform suitable memory-copying loops to &lt;code&gt;std::memcpy&lt;/code&gt; calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20e064cb02a2e6366e9769ca91b6159a518d574a" translate="yes" xml:space="preserve">
          <source>Several alias templates, that perform arithmetic operations on &lt;code&gt;ratio&lt;/code&gt; objects at compile-time are provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8795d93d5e0421a57d6b71c2c710d10c8092b33e" translate="yes" xml:space="preserve">
          <source>Several class templates, that perform comparison operations on &lt;code&gt;ratio&lt;/code&gt; objects at compile-time are provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c26bd0ea0f59b8ae2c73c9e1a142bd1fcfdbf81d" translate="yes" xml:space="preserve">
          <source>Several cleanup steps are performed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2afe923e6efa1a1608806b55078e16f7523db71b" translate="yes" xml:space="preserve">
          <source>Several convenience classes are predefined in the header &lt;code&gt;&amp;lt;stdexcept&amp;gt;&lt;/code&gt; to report particular error conditions. These classes can be divided into two categories:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4648776dcbe754ec199fc020a5d382f56667916" translate="yes" xml:space="preserve">
          <source>Several convenience typedefs that correspond to the SI ratios are provided by the standard library:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="096f451fac0362d4ca2620596aca61e92e355777" translate="yes" xml:space="preserve">
          <source>Several functions and macro constants for signal management are provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0116e99087157300ae52a7a94e87ce089818304c" translate="yes" xml:space="preserve">
          <source>Several specializations for common character sequence types are defined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6d52405699141b6d980e9aac92099ec2171d14c" translate="yes" xml:space="preserve">
          <source>Several specializations for common character sequence types are provided:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e4842d83deb970b14592b06aac5a6de2b59130f" translate="yes" xml:space="preserve">
          <source>Several specializations for common character types are provided:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1a5848f4dd2490f2d5769aac542fd551b4e177f" translate="yes" xml:space="preserve">
          <source>Several specializations of &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; are provided for commonly-used types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ebda6bee6f8e82c2d1bf625330591c499530bd5" translate="yes" xml:space="preserve">
          <source>Several specializations of &lt;code&gt;&lt;a href=&quot;string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; are provided for commonly-used types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9ae4d382f3f173206dd82ede2629eb16f42a22b" translate="yes" xml:space="preserve">
          <source>Several specific popular algorithms are predefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93f03b20c634996625d4716bcc756c52b32b3d54" translate="yes" xml:space="preserve">
          <source>Several standard library functions indicate errors by writing positive integers to &lt;code&gt;errno&lt;/code&gt;. Typically, the value of &lt;code&gt;errno&lt;/code&gt; is set to one of the error codes, listed in &lt;code&gt;&amp;lt;cerrno&amp;gt;&lt;/code&gt; as macro constants that begin with the letter &lt;code&gt;E&lt;/code&gt;, followed by uppercase letters or digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17bd9dc914c33e15ed5ac3d96acb6e3cd62e8b38" translate="yes" xml:space="preserve">
          <source>Several typedefs for common character types are provided:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49157ea525f663890f621bd2ab2c9be20931cd0e" translate="yes" xml:space="preserve">
          <source>Several utilities are provided to create and access raw storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f184e7fb63088309cbd0a9fe3300a64508bc0131" translate="yes" xml:space="preserve">
          <source>Several utilities that provided early functional support are deprecated in C++11 and removed in C++17 (old negators are deprecated in C++17 and removed in C++20):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b6768882a645687cc1622eb5df417b554b27c00" translate="yes" xml:space="preserve">
          <source>Several ways to generate a NaN (the output string is compiler-specific).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a68c6d89cb2cb95ce1d60e96889a9fa5dc8212d4" translate="yes" xml:space="preserve">
          <source>Shared locking</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73451d10ad1723ad84471a2028b592eaced1e7fb" translate="yes" xml:space="preserve">
          <source>Shared mutexes are usually used in situations when multiple readers can access the same resource at the same time without causing data races, but only one writer can do so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eb61d2dff132f2129980e537c9cfdac411b9d16" translate="yes" xml:space="preserve">
          <source>Shared mutexes do not support direct transition from shared to unique ownership mode: the shared lock has to be relinquished with &lt;code&gt;&lt;a href=&quot;unlock_shared&quot;&gt;unlock_shared()&lt;/a&gt;&lt;/code&gt; before exclusive ownership may be obtained with &lt;code&gt;lock()&lt;/code&gt;. &lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/thread/synchronization.html#thread.synchronization.mutex_types.upgrade_mutex&quot;&gt;boost::upgrade_mutex&lt;/a&gt; may be used for this purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37a0431da83771aa22d91f0f6aadf1383e976f46" translate="yes" xml:space="preserve">
          <source>SharedMutex</source>
          <target state="translated">SharedMutex</target>
        </trans-unit>
        <trans-unit id="57a75cc42950df8e7be8033d9c108015544f09cd" translate="yes" xml:space="preserve">
          <source>SharedTimedMutex</source>
          <target state="translated">SharedTimedMutex</target>
        </trans-unit>
        <trans-unit id="f02680b3393117ec07357eb9f1a55eb3ffb43839" translate="yes" xml:space="preserve">
          <source>Shifts the elements in the range &lt;code&gt;[first, last)&lt;/code&gt; by &lt;code&gt;n&lt;/code&gt; positions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aa2fd65f221fb441668eabd3b7d043130d5f61e" translate="yes" xml:space="preserve">
          <source>Shows the given error message and renders the program ill-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="115bd61002d38ae0f96bbafaa3faad3d6f1cd957" translate="yes" xml:space="preserve">
          <source>Sign modifiers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="577457386419e49cc011db96f147d3e3e75e3f09" translate="yes" xml:space="preserve">
          <source>Signal handler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a84a6ab629fde6a64e054e143bd33f5477fde80c" translate="yes" xml:space="preserve">
          <source>Signal handlers are expected to have &lt;a href=&quot;../../language/language_linkage&quot;&gt;C linkage&lt;/a&gt; and, in general, only use the features from the common subset of C and C++. It is implementation-defined if a function with C++ linkage can be used as a signal handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d946cd91c48d2465b1861bb4f63d569ff6618d1" translate="yes" xml:space="preserve">
          <source>Signal types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2346a18ea3002ff04eca3a130c7f40e65c56f0c9" translate="yes" xml:space="preserve">
          <source>Signals</source>
          <target state="translated">Signals</target>
        </trans-unit>
        <trans-unit id="f4ba37e52b5e712f327df4086478be0bb37e10af" translate="yes" xml:space="preserve">
          <source>Signals an erroneous condition and executes an error handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99645a25e106b37349c4a9e5cf923d508621ff34" translate="yes" xml:space="preserve">
          <source>Signed integer arithmetic is defined to use two's complement; there are no undefined results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fc62c21332a22fd75bd285de995cb4fccf6af62" translate="yes" xml:space="preserve">
          <source>Signed integer type (usually &lt;code&gt;&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;std::ptrdiff_t&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83cbfd47b41a4ebb43e27ff9728af42d399bbda3" translate="yes" xml:space="preserve">
          <source>Signed integers : maximum value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46aa2d10272ed1c7e156088e86d214a184422894" translate="yes" xml:space="preserve">
          <source>Signed integers : minimum value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7add2e2fdaaac8a1396e22391085b13ed07cb9bd" translate="yes" xml:space="preserve">
          <source>Signed overflow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="950ab1101b17ae5a4d17079adf2c1a753a563569" translate="yes" xml:space="preserve">
          <source>SignedIntegral</source>
          <target state="translated">SignedIntegral</target>
        </trans-unit>
        <trans-unit id="57623bc18a34da85f689f9b07a9ba0fe9841f116" translate="yes" xml:space="preserve">
          <source>Similar to other cast expressions, the result is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cac5ae9e99757e61c6a90cda939d609dbc62d711" translate="yes" xml:space="preserve">
          <source>Similar to other nested scopes, the name of a template parameter hides the same name from the outer scope for the duration of its own:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab34722f320413e959a59dbf8a947c6022642672" translate="yes" xml:space="preserve">
          <source>Similar to protected inheritance, private inheritance may also be used for controlled polymorphism: within the members of the derived (but not within further-derived classes), derived IS-A base.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65db8c5edde8bf68dee1cacb22bbacf452f01291" translate="yes" xml:space="preserve">
          <source>Similar to the use of &lt;code&gt;swap&lt;/code&gt; (described in &lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;), typical use of the &lt;code&gt;begin&lt;/code&gt; function in generic context is an equivalent of &lt;code&gt;using std::begin; begin(arg);&lt;/code&gt;, which allows both the &lt;a href=&quot;../language/adl&quot;&gt;ADL&lt;/a&gt;-selected overloads for user-defined types and the standard library function templates to appear in the same overload set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="960d524c56dc7eea207997f2fd93dc3344684d27" translate="yes" xml:space="preserve">
          <source>Similar to the use of &lt;code&gt;swap&lt;/code&gt; (described in &lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;), typical use of the &lt;code&gt;end&lt;/code&gt; function in generic context is an equivalent of &lt;code&gt;using std::end; end(arg);&lt;/code&gt;, which lets both the &lt;a href=&quot;../language/adl&quot;&gt;ADL&lt;/a&gt;-selected overloads for user-defined types and the standard library function templates to appear in the same overload set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9a4d7ed9741e60fb0d8c1ef96f19d3ca3529036" translate="yes" xml:space="preserve">
          <source>Similarly, if an object is created in the storage of a class member or array element, the created object is only a subobject (member or element) of the original object's containing object if:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7479f5fc17cb0f2873e10124edd6bb55ddb644e2" translate="yes" xml:space="preserve">
          <source>Similarly, in a template definition, a dependent name that is not a member of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0078135187246fe8bb297259663e248d2026c8e8" translate="yes" xml:space="preserve">
          <source>Similarly, in the case of an ambiguity between a expression statement with a function-style cast expression (3) as its leftmost subexpression and a declaration statement, the ambiguity is resolved by treating it as a declaration. This disambiguation is purely syntactic: it doesn't consider the meaning of names occurring in the statement other than whether they are type names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="482ca159f5a9e05f0355ea23bd2b1dca91576d34" translate="yes" xml:space="preserve">
          <source>Similarly, the decimal value 0.3, which is between 0x1.3333333333333*2-2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c89741be4b5567d1abddb43c7960bf1492274817" translate="yes" xml:space="preserve">
          <source>Similarly, the object on which a member function is being called is prepended to the argument list as the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44c42f7a157d61d5df84ae12ff944cc8a7f796d4" translate="yes" xml:space="preserve">
          <source>Similarly, they should not be directly used with standard algorithms when the iterator's value type is &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;signed char&lt;/code&gt;. Instead, convert the value to &lt;code&gt;unsigned char&lt;/code&gt; first:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="555f4661a1c9474d8436af0119724e3bb946b92e" translate="yes" xml:space="preserve">
          <source>Simple declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e22e3bdd3d9fe2365a2a7c845db318164b219429" translate="yes" xml:space="preserve">
          <source>Simple requirements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a61f6c3644c94b95e9501c6216722561ceaeda20" translate="yes" xml:space="preserve">
          <source>Simply happens-before</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bfece18772a73e9e86bc04ddb99403446d3714b" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt; and unhinted &lt;a href=&quot;insert&quot;&gt;insert&lt;/a&gt; always insert at the upper bound, the order of equivalent elements in the equal range is the order of insertion unless hinted &lt;a href=&quot;insert&quot;&gt;insert&lt;/a&gt; or &lt;a href=&quot;emplace_hint&quot;&gt;emplace_hint&lt;/a&gt; was used to insert an element at a different position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c085f0eb950f92da79964d5ad79765742cef364f" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;U&lt;/code&gt; is not deduced, it must be provided as a template argument when calling this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4fd9ce185a2267e216b09c9fc53119a294a6f13" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;std::size_t&lt;/code&gt; is an unsigned type, an equivalent definition is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="843699963892a9d8456a647280dafa700ecdc937" translate="yes" xml:space="preserve">
          <source>Since C++11, &lt;code&gt;auto&lt;/code&gt; is no longer a storage class specifier; it is used to indicate type deduction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="285604ae9a85be58f4823b4cb9df0815028c2dfd" translate="yes" xml:space="preserve">
          <source>Since C++11, value-initializing a class without a user-provided constructor, which has a member of a class type with a user-provided constructor zeroes out the member before calling its constructor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aabd76632c3d8473aa4688d0b37f3aced9e7b198" translate="yes" xml:space="preserve">
          <source>Since in a call context considers only parameters for which there are explicit call arguments, those function parameter packs, ellipsis parameters, and parameters with default arguments, for which there is no explicit call argument, are ignored:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bce6909434e4eba25b5845a8222d3e359b346452" translate="yes" xml:space="preserve">
          <source>Since its representation may by optimized, &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; does not necessarily meet all &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt; or &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt; requirements. For example, because &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::iterator&lt;/code&gt; is implementation-defined, it may not satisfy the &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; requirement. Use of algorithms such as &lt;code&gt;&lt;a href=&quot;../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; that require &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterators&lt;/a&gt; may result in &lt;a href=&quot;http://www.boost.org/doc/libs/1_52_0/libs/dynamic_bitset/dynamic_bitset.html#rationale&quot;&gt;either compile-time or run-time errors&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59120bf45bf0e3dc09f7ad3363dc1b08094ba734" translate="yes" xml:space="preserve">
          <source>Since language linkage is part of every function type, pointers to functions maintain language linkage as well. Language linkage of function types (which represents calling convention) and language linkage of function names (which represents name mangling) are independent of each other:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00aa71d9edfae3bc000e4211aec722c02ac23c61" translate="yes" xml:space="preserve">
          <source>Since many of regex operations are locale-sensitive (when &lt;code&gt;&lt;a href=&quot;syntax_option_type&quot;&gt;std::regex_constants::collate&lt;/a&gt;&lt;/code&gt; flag is set), the regex_traits class typically holds an instance of a &lt;code&gt;&lt;a href=&quot;../locale/locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; as a private member.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1154928a5e14f8714e9865148a4606da277f324" translate="yes" xml:space="preserve">
          <source>Since message has to be a string literal, it cannot contain dynamic information or even a &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; that is not a string literal itself. In particular, it cannot contain the &lt;a href=&quot;name&quot;&gt;name&lt;/a&gt; of the &lt;a href=&quot;template_parameters&quot;&gt;template type argument&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22c8aa4c1624c1e165427ced739188017b6400e5" translate="yes" xml:space="preserve">
          <source>Since ranking of conversion sequences operates with types and value categories only, a &lt;a href=&quot;bit_field&quot;&gt;bit field&lt;/a&gt; can bind to a reference argument for the purpose of ranking, but if that function gets selected, it will be ill-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4460285e125395b2552b4be6766da2d831503ab6" translate="yes" xml:space="preserve">
          <source>Since reallocation may take place, &lt;code&gt;emplace_back&lt;/code&gt; requires the element type to be &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; for vectors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e40de4f7be410b2629d9d803e2b1896eb7796159" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;shared_ptr&lt;/code&gt; obtains its deleter (a &lt;code&gt;&lt;a href=&quot;../default_delete&quot;&gt;std::default_delete&lt;/a&gt;&amp;lt;T[]&amp;gt;&lt;/code&gt; object) from the &lt;code&gt;unique_ptr&lt;/code&gt;, the array will be correctly deallocated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1620299a964087a7c68a2c6947cce22ccf933751" translate="yes" xml:space="preserve">
          <source>Since the introduction of user-defined literals, the code that uses &lt;a href=&quot;http://en.cppreference.com/w/c/types/integer.html&quot;&gt;format macro constants for fixed-width integer types&lt;/a&gt; with no space after the preceding string literal became invalid: &lt;code&gt;&lt;a href=&quot;../io/c/fprintf&quot;&gt;std::printf&lt;/a&gt;(&quot;%&quot;&lt;a href=&quot;../types/integer&quot;&gt;PRId64&lt;/a&gt;&quot;\n&quot;,&lt;a href=&quot;../types/integer&quot;&gt;INT64_MIN&lt;/a&gt;);&lt;/code&gt; has to be replaced by &lt;code&gt;&lt;a href=&quot;../io/c/fprintf&quot;&gt;std::printf&lt;/a&gt;(&quot;%&quot; &lt;a href=&quot;../types/integer&quot;&gt;PRId64&lt;/a&gt;&quot;\n&quot;,&lt;a href=&quot;../types/integer&quot;&gt;INT64_MIN&lt;/a&gt;);&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6605890e57506cfb54ca1476387e076094c45493" translate="yes" xml:space="preserve">
          <source>Since this meaning of the keyword &lt;code&gt;inline&lt;/code&gt; is non-binding, compilers are free to use inline substitution for any function that's not marked inline, and are free to generate function calls to any function marked inline. Those optimization choices do not change the rules regarding multiple definitions and shared statics listed above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc80190c0d22504d80be6153894b93b31cfb604d" translate="yes" xml:space="preserve">
          <source>Since variant is never permitted to allocate dynamic memory, previous value cannot be retained in these situations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c45f24beb57e38b698d3ce8c5ae37ca439685549" translate="yes" xml:space="preserve">
          <source>Since virtual members are part of the interface component of pImpl, mocking a pImpl implies mocking the interface component alone. A testable pImpl is typically designed to allow full test coverage through the available interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01023f649513952abe496b73748117186e5a306e" translate="yes" xml:space="preserve">
          <source>Single character is preceded by a space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54f240da1d0f429d9b1906f5ac8b6dd8cc37d07d" translate="yes" xml:space="preserve">
          <source>Single digit is preceded by a space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fef55c5b9eaee331f66eae74df02c2af41eafb71" translate="yes" xml:space="preserve">
          <source>Single-object version, &lt;code&gt;unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22d0803f659b9a68120fc2d5a3996d0572f0d784" translate="yes" xml:space="preserve">
          <source>Single-writer/multiple-reader lock can be made with fetch_add. Note that this simplistic implementation is not lockout-free.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef575e12952f61f9bac204b82b00f1839b3ca9e3" translate="yes" xml:space="preserve">
          <source>Singular iterators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b347a3919b8069efdf614137abd1e4d916c644e" translate="yes" xml:space="preserve">
          <source>Six deduction guides are provided for &lt;code&gt;zoned_time&lt;/code&gt;. They normalize &lt;code&gt;Duration&lt;/code&gt; to a minimum resolution of &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::seconds&lt;/a&gt;&lt;/code&gt;, and provide correct handling for time zone names specified using types convertible to &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::string_view&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="381b9cba23adca3666e3c1bed8420bdccab985a9" translate="yes" xml:space="preserve">
          <source>Six global basic_ostream objects are provided by the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7152342a267362add3c0d7f69f720f7a9c76c9e" translate="yes" xml:space="preserve">
          <source>Size</source>
          <target state="translated">Size</target>
        </trans-unit>
        <trans-unit id="1089a09be10396c011527de780e9b49cb3308d4a" translate="yes" xml:space="preserve">
          <source>Size in bits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba8a0e2cd42b491da31e41308e9287bdfe97bf7c" translate="yes" xml:space="preserve">
          <source>Sized deallocation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6ceb63258d717a681c569cf041196fa6b5c1c87" translate="yes" xml:space="preserve">
          <source>SizedRange</source>
          <target state="translated">SizedRange</target>
        </trans-unit>
        <trans-unit id="961842b5d2fd3472c9d52acdca1dc7c3ffb770d1" translate="yes" xml:space="preserve">
          <source>SizedSentinel</source>
          <target state="translated">SizedSentinel</target>
        </trans-unit>
        <trans-unit id="32f8bf96a0bd875194723dd6f7b3b0d18f1291fa" translate="yes" xml:space="preserve">
          <source>Sizes may be rounded to an unspecified granularity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="338622e75d7f5d93bff486ccb15b9f19545a1937" translate="yes" xml:space="preserve">
          <source>Skip directories that would otherwise result in permission denied errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39ce73047a637a26adee194ba2061f2e02dd69d0" translate="yes" xml:space="preserve">
          <source>Skip subdirectories (default behavior)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2460e6fd123cf1efd38917ed660654cd31ec9506" translate="yes" xml:space="preserve">
          <source>Skips &lt;code&gt;count&lt;/code&gt; characters in the get area. This is done by advancing the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="301d79d18fe92372bfd14f52cdb1fb9deb17a4a4" translate="yes" xml:space="preserve">
          <source>Slice/mask/indirect index accesses do not chain: &lt;code&gt;v[v==n][&lt;a href=&quot;slice&quot;&gt;std::slice&lt;/a&gt;(0,5,2)] = x;&lt;/code&gt; is an error because &lt;code&gt;&lt;a href=&quot;mask_array&quot;&gt;std::mask_array&lt;/a&gt;&lt;/code&gt; (the type of &lt;code&gt;v[v==n]&lt;/code&gt;) does not have &lt;code&gt;operator[]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7449b96680387cef7a35514f8b4cc968d87552e7" translate="yes" xml:space="preserve">
          <source>Small Buffer Optimization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dda9285d4bfd3311fa52a7391e1f10b968de46c" translate="yes" xml:space="preserve">
          <source>Small Object Optimization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="657c4b92030f950f98c992a4f6c147e40488cb5d" translate="yes" xml:space="preserve">
          <source>Small String Optimization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5280487b4a39af03996e3bd19a8268c63c1877bd" translate="yes" xml:space="preserve">
          <source>Smart pointer non-member operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf0fcdc3a447c0f10f6f532765bcc76c84847421" translate="yes" xml:space="preserve">
          <source>Smart pointers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81da943626b80ddf7742b25bead2b748e84981fc" translate="yes" xml:space="preserve">
          <source>Smart pointers (e.g. &lt;code&gt;&lt;a href=&quot;memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;), allocators (e.g. &lt;code&gt;&lt;a href=&quot;memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;std::memory_resource&lt;/code&gt;), C-style memory management (e.g. &lt;code&gt;&lt;a href=&quot;memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5237636d1bbbca8bfd0e9212d068f275af782a07" translate="yes" xml:space="preserve">
          <source>Smart pointers enable automatic, exception-safe, object lifetime management.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d962452bf23cfce358191ab2ce40997d4a7521" translate="yes" xml:space="preserve">
          <source>So that all but the first inclusion of the header in any translation unit are excluded from compilation. All modern compilers record the fact that a header file uses an include guard and do not re-parse the file if it is encountered again, as long as the guard is still defined. (see e.g. &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/cpp/Once-Only-Headers.html&quot;&gt;gcc&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10279063fcdbb5e2692d2226f688d7b65ac2fb32" translate="yes" xml:space="preserve">
          <source>Socket is connected</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4db4b6c518a0310c7a9175dae07831f11097843" translate="yes" xml:space="preserve">
          <source>Some I/O functions call &lt;code&gt;width(0)&lt;/code&gt; before returning, see &lt;code&gt;&lt;a href=&quot;../manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; (this results in this field having effect on the next I/O function only, and not on any subsequent I/O).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5adbe247c42621c892c4aa15bf359467135fbfb1" translate="yes" xml:space="preserve">
          <source>Some compilers don't implement instantiation units (also known as &lt;a href=&quot;http://docs.oracle.com/cd/E18659_01/html/821-1383/bkagr.html#scrolltoc&quot;&gt;template repositories&lt;/a&gt; or &lt;a href=&quot;http://www-01.ibm.com/support/knowledgecenter/SSXVZZ_12.1.0/com.ibm.xlcpp121.linux.doc/compiler_ref/fcat_template.html?lang=en&quot;&gt;template registries&lt;/a&gt;) and simply compile each template instantiation at Phase 7, storing the code in the object file where it is implicitly or explicitly requested, and then the linker collapses these compiled instantiations into one at Phase 9.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c54e7b53f7cadf1e6c3559a8ef1472882f98a89" translate="yes" xml:space="preserve">
          <source>Some existing implementations have a bug where they may occasionally return &lt;code&gt;1.0&lt;/code&gt; if &lt;code&gt;RealType&lt;/code&gt; is &lt;code&gt;float&lt;/code&gt;&lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63176&quot;&gt;GCC #63176&lt;/a&gt;&lt;a href=&quot;http://llvm.org/bugs/show_bug.cgi?id=18767&quot;&gt;LLVM #18767&lt;/a&gt;. This is &lt;a href=&quot;http://open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2524&quot;&gt;LWG issue 2524 &lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ec2aada0af03043ccc865c1099f969a15be807a" translate="yes" xml:space="preserve">
          <source>Some existing implementations have a bug where they may occasionally return b if &lt;code&gt;RealType&lt;/code&gt; is &lt;code&gt;float&lt;/code&gt;&lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63176&quot;&gt;GCC #63176&lt;/a&gt;&lt;a href=&quot;http://llvm.org/bugs/show_bug.cgi?id=18767&quot;&gt;LLVM #18767&lt;/a&gt;. This is caused by &lt;a href=&quot;http://open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2524&quot;&gt;LWG issue 2524 &lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ae96e14b066d0ec8a8395d164b310c7927bac50" translate="yes" xml:space="preserve">
          <source>Some file systems do not support hard links regardless of the operating system: the FAT file system used on memory cards and flash drives, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25651c80339ed821602271ae6cf24d89af5e9ee0" translate="yes" xml:space="preserve">
          <source>Some file systems do not support symbolic links regardless of the operating system, for example the FAT system used on some memory cards and flash drives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5842b00ee9574c370ef65e50ea3aa3f71da0f84" translate="yes" xml:space="preserve">
          <source>Some file systems limit the number of links per file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3baebc4d02301b876a42c09dafb12fd777d30fb5" translate="yes" xml:space="preserve">
          <source>Some forms of &lt;code&gt;dynamic_cast&lt;/code&gt; rely on &lt;a href=&quot;https://en.wikipedia.org/wiki/Run-time_type_information&quot;&gt;runtime type identification&lt;/a&gt; (RTTI), that is, information about each polymorphic class in the compiled program. Compilers typically have options to disable the inclusion of this information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f45f2bc9dd0eef9a815d996c8598d556c1d75b2f" translate="yes" xml:space="preserve">
          <source>Some implementations (such as MSVC, IBM, Oracle) produce a human-readable type name. Others, most notably gcc and clang, return the mangled name. The mangled name can be converted to human-readable form using implementation-specific API such as &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/libstdc%20%20/manual/ext_demangling.html&quot;&gt;abi::__cxa_demangle&lt;/a&gt; directly or through &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/core/doc/html/core/demangle.html&quot;&gt;boost::core::demangle&lt;/a&gt;. It can also be piped through the commandline utility &lt;code&gt;c++filt -t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e9f769d3f52ad14152cedf0345bfc21cff89b9b" translate="yes" xml:space="preserve">
          <source>Some implementations also throw &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; when &lt;code&gt;push_back&lt;/code&gt; causes a reallocation that would exceed &lt;code&gt;&lt;a href=&quot;max_size&quot;&gt;max_size&lt;/a&gt;&lt;/code&gt;, due to implicitly calling an equivalent of &lt;code&gt;reserve(size()+1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1211a18140d5c923fb6d564901b0cd227d7c8de1" translate="yes" xml:space="preserve">
          <source>Some implementations are able to delete any facet, including the locale-specific facets with protected destructors. Other implementations require the facet to have a public destructor, similar to the the locale-independent facets from &lt;code&gt;&amp;lt;codecvt&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23bf9c695f08640c97ac98dea8399ad1f810bbb1" translate="yes" xml:space="preserve">
          <source>Some implementations are able to delete any facet, including the locale-specific facets with protected destructors. Other implementations require the facet to have a public destructor, similar to the the locale-independent facets from &lt;code&gt;&amp;lt;codecvt&amp;gt;&lt;/code&gt;. This is &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#721&quot;&gt;LWG issue 721&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba520fb2c503cdc25ec5b9b6f3a0f079c16b72d8" translate="yes" xml:space="preserve">
          <source>Some implementations handle &lt;code&gt;timeptr-&amp;gt;tm_mday==0&lt;/code&gt; as meaning the last day of the preceding month.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6438dffce87e65a616bf990b409e64a0fe8a0484" translate="yes" xml:space="preserve">
          <source>Some implementations may occasionally return infinity if &lt;code&gt;RealType&lt;/code&gt; is &lt;code&gt;float&lt;/code&gt;. This is &lt;a href=&quot;http://open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2524&quot;&gt;LWG issue 2524&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69d9a9a13766d236996c1d2bb4d126a13661dd61" translate="yes" xml:space="preserve">
          <source>Some locales offer additional character classes that detect non-ASCII digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2984dbcf7994a8b794a77e7494406d337036fa6" translate="yes" xml:space="preserve">
          <source>Some member functions are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7d6cdd50583dc42bfdb814089c96c038db55e75" translate="yes" xml:space="preserve">
          <source>Some member functions are special: under certain circumstances they are defined by the compiler even if not defined by the user. They are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="837173a7f0c46c404633f2871fb260cf5e1fc724" translate="yes" xml:space="preserve">
          <source>Some non-standard libraries define a type trait &quot;BitwiseMovable&quot; or &quot;Relocatable&quot;, which describes a type that doesn't have:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be708867f7f47ff2e9f45f6a8f29ccfdd0cce8fd" translate="yes" xml:space="preserve">
          <source>Some of the &lt;a href=&quot;../io&quot;&gt;I/O streams member functions&lt;/a&gt; return and manipulate objects of member typedef &lt;code&gt;pos_type&lt;/code&gt;. For streams, these member typedefs are provided by the template parameter &lt;code&gt;Traits&lt;/code&gt;, which defaults to &lt;code&gt;&lt;a href=&quot;../string/char_traits&quot;&gt;std::char_traits&lt;/a&gt;&lt;/code&gt;, which define their &lt;code&gt;pos_type&lt;/code&gt;s to be specializations of &lt;code&gt;std::fpos&lt;/code&gt;. The behavior of the I/O streams library is implementation-defined when &lt;code&gt;Traits::pos_type&lt;/code&gt; is not &lt;code&gt;std::fpos&amp;lt;&lt;a href=&quot;../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; (aka &lt;code&gt;std::streampos&lt;/code&gt; or &lt;code&gt;std::wstreampos&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42f4721337bfcd1c4414747ff2568f867f2077d7" translate="yes" xml:space="preserve">
          <source>Some of the operators have &lt;a href=&quot;operator_alternative&quot;&gt;alternate spellings&lt;/a&gt; (e.g., &lt;code&gt;and&lt;/code&gt; for &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt; for &lt;code&gt;||&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt; for &lt;code&gt;!&lt;/code&gt;, etc.).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="765e9b729b33e7053ac6c10ee70ba3f6b6995835" translate="yes" xml:space="preserve">
          <source>Some of the standard-required facets, such as the UTF-8/UTF-32 conversion facet &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char32_t, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt;, have no equivalents in the &quot;C&quot; locale, but they are nevertheless present in the locale returned by &lt;code&gt;std::locale::classic()&lt;/code&gt;, as in any other locale constructed in a C++ program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caa174c46ca2ec6d14f7d14a1986d4b238a9d0ec" translate="yes" xml:space="preserve">
          <source>Some of these requirements are being formalized in C++20 using the &lt;a href=&quot;language/constraints&quot;&gt;concepts&lt;/a&gt; language feature. Until then, the burden is on the programmer to ensure that library templates are instantiated with template arguments that satisfy these requirements. Failure to do so may result in very complex compiler diagnostics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfcefe079222e4c23d3487cf53ffb814bc175ca7" translate="yes" xml:space="preserve">
          <source>Some operating systems do not support hard links at all or support them only for regular files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd02034e447f5be2058fe371e17584fad666449c" translate="yes" xml:space="preserve">
          <source>Some operating systems do not support symbolic links at all or support them only for regular files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6d76a7395176458beb737711e50d3138c198101" translate="yes" xml:space="preserve">
          <source>Some operating systems require symlink creation to identify that the link is to a directory. Portable code should use (2) to create directory symlinks rather than (1), even though there is no distinction on POSIX systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb8327d50eb27e2d33c783ff01dfd4bd720a5528" translate="yes" xml:space="preserve">
          <source>Some operations on floating-point numbers are affected by and modify the state of &lt;a href=&quot;../numeric/fenv&quot;&gt;the floating-point environment&lt;/a&gt; (most notably, the rounding direction).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b438936ace997fb03408714f0cc8c0d6e4e62b22" translate="yes" xml:space="preserve">
          <source>Some permission bits may be ignored on some systems, and changing some bits may automatically change others (e.g. on platforms without owner/group/all distinction, setting any of the three write bits set all three).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fc481c89819102012a9d0f89914c46dff389023" translate="yes" xml:space="preserve">
          <source>Some range adaptors wrap their element or function object with the &lt;a href=&quot;ranges/semiregular_wrapper&quot;&gt;semiregular wrapper&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7ab779158c707137836b8aca6e4154cf5a7a3c2" translate="yes" xml:space="preserve">
          <source>Some requirements are optional: the template &lt;code&gt;&lt;a href=&quot;../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&lt;/code&gt; supplies the default implementations for all optional requirements, and all standard library containers and other allocator-aware classes access the allocator through &lt;code&gt;std::allocator_traits&lt;/code&gt;, not directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1edcbd0864e00de6bc3ed666e900623b2628f887" translate="yes" xml:space="preserve">
          <source>Some return types of functions of &lt;a href=&quot;../header/functional&quot;&gt;&lt;code&gt;&amp;lt;functional&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17e1b6b6fdfa075b5d4bcbe52a9b4bcc63b8b045" translate="yes" xml:space="preserve">
          <source>Some standard library function object adaptors, such as &lt;code&gt;&lt;a href=&quot;not1&quot;&gt;std::not1&lt;/a&gt;&lt;/code&gt;, require the function objects they adapt to have certain types defined; &lt;code&gt;&lt;a href=&quot;not1&quot;&gt;std::not1&lt;/a&gt;&lt;/code&gt; requires the function object being adapted to have a type named &lt;code&gt;argument_type&lt;/code&gt;. Deriving function objects that take one argument from &lt;code&gt;unary_function&lt;/code&gt; is an easy way to make them compatible with those adaptors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09b957f5dade6785ca0c00036e5b0d560f353891" translate="yes" xml:space="preserve">
          <source>Some standard library function object adaptors, such as &lt;code&gt;&lt;a href=&quot;not2&quot;&gt;std::not2&lt;/a&gt;&lt;/code&gt;, require the function objects they adapt to have certain types defined; &lt;code&gt;&lt;a href=&quot;not2&quot;&gt;std::not2&lt;/a&gt;&lt;/code&gt; requires the function object being adapted to have two types named &lt;code&gt;first_argument_type&lt;/code&gt; and &lt;code&gt;second_argument_type&lt;/code&gt;. Deriving function objects that take two arguments from &lt;code&gt;binary_function&lt;/code&gt; is an easy way to make them compatible with those adaptors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f250b829207ebe1245ad903482a0b2738133c9e" translate="yes" xml:space="preserve">
          <source>Sometimes it's safe to throw an exception even while &lt;code&gt;std::uncaught_exception() == true&lt;/code&gt;. For example, if &lt;a href=&quot;../../language/throw#Stack_unwinding&quot;&gt;stack unwinding&lt;/a&gt; causes an object to be destructed, the destructor for that object could run code that throws an exception as long as the exception is caught by some catch block before escaping the destructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11110b24bcb6cedda127c754fb50036327560b2e" translate="yes" xml:space="preserve">
          <source>Sortable</source>
          <target state="translated">Sortable</target>
        </trans-unit>
        <trans-unit id="13696f439559b7aa831e1895b1974678571e434f" translate="yes" xml:space="preserve">
          <source>Sorting operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e278b12f4f35189855f7d8b8761299f2cee21cb" translate="yes" xml:space="preserve">
          <source>Sorts some of the elements in the range &lt;code&gt;[first, last)&lt;/code&gt; in ascending order, storing the result in the range &lt;code&gt;[d_first, d_last)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec2affa5e1e0bfa4da3bd5957467157ce4eec8f9" translate="yes" xml:space="preserve">
          <source>Sorts the elements in ascending order. The order of equal elements is preserved. The first version uses &lt;code&gt;operator&amp;lt;&lt;/code&gt; to compare the elements, the second version uses the given comparison function &lt;code&gt;comp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9ee61d95eb7ca033304a6c28affa88aea2875d6" translate="yes" xml:space="preserve">
          <source>Sorts the elements in the range &lt;code&gt;[first, last)&lt;/code&gt; in ascending order. The order of equal elements is not guaranteed to be preserved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7fd2050346980b84ef2af829697dc3f0ed185be" translate="yes" xml:space="preserve">
          <source>Sorts the elements in the range &lt;code&gt;[first, last)&lt;/code&gt; in ascending order. The order of equivalent elements is guaranteed to be preserved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da63b0d03cf0983af48537a59297f919f164f1bd" translate="yes" xml:space="preserve">
          <source>Sorts the given array pointed to by &lt;code&gt;ptr&lt;/code&gt; in ascending order. The array contains &lt;code&gt;count&lt;/code&gt; elements of &lt;code&gt;size&lt;/code&gt; bytes. Function pointed to by &lt;code&gt;comp&lt;/code&gt; is used for object comparison.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1062d4ec3477261e4a029a283ebcf5e673c0c76e" translate="yes" xml:space="preserve">
          <source>Source file inclusion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="737413ce7a08697aa3d4382b04c67b58abda52ab" translate="yes" xml:space="preserve">
          <source>Space overhead: pImpl adds one pointer to the public component and, if any private member needs access to a public member, another pointer is either added to the implementation component or passed as a parameter for each call to the private member that requires it. If stateful custom allocators are supported, the allocator instance also has to be stored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0d61499cc942eb1278687007fde841d4bb2b516" translate="yes" xml:space="preserve">
          <source>Special categories</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ff426b0abd95de6e45376aa10b2853795200f0f" translate="yes" xml:space="preserve">
          <source>Special mathematical functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="827e6674de363a70897b99e51fffefdb810a4c6e" translate="yes" xml:space="preserve">
          <source>Special member functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="471ddcb69cf1017797006b55d79f5f809498401a" translate="yes" xml:space="preserve">
          <source>Special member functions along with the &lt;a href=&quot;default_comparisons&quot;&gt;comparison operators&lt;/a&gt;(since C++20) are the only functions that can be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="288289b7c043a255232197a83ad1c7f6a2f423f4" translate="yes" xml:space="preserve">
          <source>Special operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33035fa15c251880c6ca4666e10791e819d68abe" translate="yes" xml:space="preserve">
          <source>Special rules for &quot;C&quot; linkage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eedd5b116274ae72545327b12c1f13a7daad71f8" translate="yes" xml:space="preserve">
          <source>Special rvalue category, see pending member function call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0f090c0f44aceac36d2c9eb988dd8280d3ee8e3" translate="yes" xml:space="preserve">
          <source>Specialization</source>
          <target state="translated">Specialization</target>
        </trans-unit>
        <trans-unit id="257368682d0c8829b4ef3064212d06ea74f41e65" translate="yes" xml:space="preserve">
          <source>Specialization &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e647f7352410c64aa331edaf62ef052333f79c68" translate="yes" xml:space="preserve">
          <source>Specialization &lt;code&gt;&lt;a href=&quot;../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b0ccfc71697ff533aa930f7710e55cb2073cb26" translate="yes" xml:space="preserve">
          <source>Specialization must be declared before the first use that would cause implicit instantiation, in every translation unit where such use occurs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6e6a1cdf4edea6046f6580c6738f01dd9e2eb68" translate="yes" xml:space="preserve">
          <source>Specializations</source>
          <target state="translated">Specializations</target>
        </trans-unit>
        <trans-unit id="667dbdfed67d185499ee8e7b7611aa3094f35afa" translate="yes" xml:space="preserve">
          <source>Specializations for floating-point types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e564affdb1d23ebeeab32e35cfcdb3ef5d27755" translate="yes" xml:space="preserve">
          <source>Specializations for integral types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81d786495f28b64fb15d8f1b253ae6a120395aae" translate="yes" xml:space="preserve">
          <source>Specializations of &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; for floating point types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52623e5481935e9f4fe12a1d8fde12df3283eaeb" translate="yes" xml:space="preserve">
          <source>Specializations of &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; for integral types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0cad4dac395f6b45cc7974188363bedca342e95" translate="yes" xml:space="preserve">
          <source>Specializations of &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; for pointer types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="377f7d31027e1bb1b02cf7940a0a9917ef71c589" translate="yes" xml:space="preserve">
          <source>Specializations of &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; should define an &lt;code&gt;operator()&lt;/code&gt; that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36c0df18df7950df4493024cd46642126fc345b1" translate="yes" xml:space="preserve">
          <source>Specializations of &lt;code&gt;&lt;a href=&quot;numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt; are provided for all arithmetic types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbea40d88457b94b63f4441c672d628c0bd77376" translate="yes" xml:space="preserve">
          <source>Specializations of &lt;code&gt;std::atomic_ref&lt;/code&gt; for floating-point types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9a3fe8a7a8d6f63e8edd13971f4a8b970846637" translate="yes" xml:space="preserve">
          <source>Specializations of &lt;code&gt;std::atomic_ref&lt;/code&gt; for integral types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea1a6c692ae02c74631a5647ff24a474c733394a" translate="yes" xml:space="preserve">
          <source>Specializations of &lt;code&gt;std::atomic_ref&lt;/code&gt; for pointer types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10c93d4df33d89a3d3b9956b10ec16964e8e76ff" translate="yes" xml:space="preserve">
          <source>Specializations of function templates that use return type deduction must use the same return type placeholders.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fc6d385e979957bd666e908f38acd5a72c6379a" translate="yes" xml:space="preserve">
          <source>Specializations of the class template &lt;code&gt;std::fpos&lt;/code&gt; identify absolute positions in a stream or in a file. Each object of type &lt;code&gt;fpos&lt;/code&gt; holds the byte position in the stream (typically as a private member of type &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt;) and the current shift state, a value of type &lt;code&gt;State&lt;/code&gt; (typically &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcb381e699d0f5d7bab1d45e7515b1ded9af4a69" translate="yes" xml:space="preserve">
          <source>Specialized algorithms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c100660f26a9d1f8adf27e8599e6a7912bf7468b" translate="yes" xml:space="preserve">
          <source>Specialized member functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be5330502c84077d0a164ee3df4702dd3df1710f" translate="yes" xml:space="preserve">
          <source>Specializes &lt;code&gt;&lt;a href=&quot;../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="929faefa4be755f2446f61c5b58a7a6bf54b5e98" translate="yes" xml:space="preserve">
          <source>Specializes &lt;code&gt;&lt;a href=&quot;../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92884ecc4dc1ad9f0b6ada755479b29b96b1923c" translate="yes" xml:space="preserve">
          <source>Specializes &lt;code&gt;&lt;a href=&quot;../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24c368abf6dc5ee77bbd5a19b5d872d8c1b483c8" translate="yes" xml:space="preserve">
          <source>Specializes &lt;code&gt;&lt;a href=&quot;../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::u16string&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::u32string&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::wstring&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1edf31ebee30072fed71727277770c7e7c4dd605" translate="yes" xml:space="preserve">
          <source>Specializes &lt;code&gt;&lt;a href=&quot;../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../thread/thread/id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ad1e738230665a0185ea33fbf613ac5e62f5c47" translate="yes" xml:space="preserve">
          <source>Specializes &lt;code&gt;&lt;a href=&quot;../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../types/type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1ce044002508eef713f870c694c01793be9dab2" translate="yes" xml:space="preserve">
          <source>Specializes &lt;code&gt;&lt;a href=&quot;../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../utility/bitset&quot;&gt;std::bitset&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10203904019075a8eaa7d7a2cf3d7d0f3719dbe4" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a374bafcebddec1398aa41e1afd2fd5ce478d640" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt;. Exchanges the state of &lt;code&gt;lhs&lt;/code&gt; with that of &lt;code&gt;rhs&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14fd4179daf4c10d5aca433c91fb556e4214b53b" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt;. Exchanges the state of &lt;code&gt;lhs&lt;/code&gt; with that of &lt;code&gt;rhs&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c980d649f1c3fd00981e147ecf386dbdc2a6a3e" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt;. Exchanges the state of &lt;code&gt;lhs&lt;/code&gt; with that of &lt;code&gt;rhs&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f09853eb90e71e2ecdcbc85d2086b5e9df32a0b5" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt;. Exchanges the state of &lt;code&gt;lhs&lt;/code&gt; with that of &lt;code&gt;rhs&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="144a7d7a089e07620f9fa29a59e74050d09800b3" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../basic_ostringstream&quot;&gt;std::basic_ostringstream&lt;/a&gt;&lt;/code&gt;. Exchanges the state of &lt;code&gt;lhs&lt;/code&gt; with that of &lt;code&gt;rhs&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d276b1eee4a17a3edc097fb2a067fce5bc607db" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Equivalent to &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11e5d4812028e7a563bd32972648c719eb6f83a0" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt;. Exchanges the state of &lt;code&gt;lhs&lt;/code&gt; with that of &lt;code&gt;rhs&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b38379cc0d135eb904af1e44b19ca4a4a225d92c" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3425e599adf74f2b78d5db4942f7824d31bb0cea" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../forward_list&quot;&gt;std::forward_list&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ec64ededba9da81e174ff8ce23dac9e2f45778" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68611ad0297c8b865b1e69bf87f9494a059b776e" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcbfdb7046d6b717fd839db9eb8989c022e7861d" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt;. Exchanges the contents of &lt;code&gt;x1&lt;/code&gt; with those of &lt;code&gt;x2&lt;/code&gt;. Effectively calls &lt;code&gt;x1.swap(x2)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="348e920b666cb2b95dfb021675885057cfedbfa5" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../multimap&quot;&gt;std::multimap&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a66cdab60bbc874750a1df6ce467f9bf1858001d" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../multiset&quot;&gt;std::multiset&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae0a18b802f0a1c4ce8ee99c449a083dabdc8bee" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt;. Exchanges the state of &lt;code&gt;lhs&lt;/code&gt; with that of &lt;code&gt;rhs&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b01140469becbcad3df73849ca87a41d0e904b5" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../priority_queue&quot;&gt;std::priority_queue&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0ca2b58e0a53194c4a1dc67a48572272d61d66f" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt;. Exchanges the shared state of &lt;code&gt;lhs&lt;/code&gt; with that of &lt;code&gt;rhs&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dc613f89602630345443f1c0041e1fabdefa79d" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../queue&quot;&gt;std::queue&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b0c41f14ec24dff0b21fa6fe23b1d7d8f579137" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16678edb55e165fd3aac9bc1f30b29146586e4a2" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt;. Exchanges the state of &lt;code&gt;lhs&lt;/code&gt; with that of &lt;code&gt;rhs&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b09f2e1442d1482454c8d40093f682389f57dfa" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;. Swaps the pointers of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c702d5c420dc39e28437791aec8f6f4e42699182" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../stack&quot;&gt;std::stack&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ce2db2f2cdd5c943018c47e72511be6601b08af" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt;. Exchanges the state of &lt;code&gt;lhs&lt;/code&gt; with that of &lt;code&gt;rhs&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c3d9c626acc7ec9ede7b418ff9991a65bf9ef4a" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;. Swaps the pointers of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d8e50681a06d76bec134dd34f752390f238bfdb" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53efb070e9c5b714af093163836a104b272133f1" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e76cd152ab11af0238bc62fc1e18423ba39b562a" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e51a278bf9c5106974b28e471705f51023452d39" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17706eccbf62ab82782b8202ae83243d762b0bc9" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="762ba2bac666c73f3f396229a66d00033365c9d3" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;. Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2371af2f2d7914c984098900b4eed95ae1383bbc" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;. Swaps the pointers of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84fd25a7b30671a6417f94003de811a3e983ac78" translate="yes" xml:space="preserve">
          <source>Specializes the &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;std::monostate&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efef95e91be1d84c2538bd2f5d8be0bfb5e24588" translate="yes" xml:space="preserve">
          <source>Specific error categories</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c59c79b4cdd1fc7b8e82868c219069dbfbbe1c" translate="yes" xml:space="preserve">
          <source>Specifically,</source>
          <target state="translated">Specifically,</target>
        </trans-unit>
        <trans-unit id="602bc4c034950f0ade4842b450786dbf7326e87f" translate="yes" xml:space="preserve">
          <source>Specifically, &lt;code&gt;&lt;a href=&quot;convertibleto&quot;&gt;ConvertibleTo&lt;/a&gt;&amp;lt;From, To&amp;gt;&lt;/code&gt; is satisfied only if, given a function &lt;code&gt;fun&lt;/code&gt; of type &lt;code&gt;From ()&lt;/code&gt; such that the expression &lt;code&gt;fun()&lt;/code&gt; is equality-preserving (see below),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db78dbdb71aaa90916530b98b58ced9ba6564cdc" translate="yes" xml:space="preserve">
          <source>Specifically, &lt;code&gt;std::reference_wrapper&lt;/code&gt; is a &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; wrapper around a reference to object or reference to function of type &lt;code&gt;T&lt;/code&gt;. Instances of &lt;code&gt;std::reference_wrapper&lt;/code&gt; are objects (they can be copied or stored in containers) but they are implicitly convertible to &lt;code&gt;T&amp;amp;&lt;/code&gt;, so that they can be used as arguments with the functions that take the underlying type by reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1df412f45187c35d9893c7c5b5cd27a2f6d6a112" translate="yes" xml:space="preserve">
          <source>Specifically, &lt;code&gt;std::rotate&lt;/code&gt; swaps the elements in the range &lt;code&gt;[first, last)&lt;/code&gt; in such a way that the element &lt;code&gt;n_first&lt;/code&gt; becomes the first element of the new range and &lt;code&gt;n_first - 1&lt;/code&gt; becomes the last element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f84f5f4badf21edc006628f5798445653f43f512" translate="yes" xml:space="preserve">
          <source>Specifically, first &lt;code&gt;P&lt;/code&gt; is converted to disjunctive normal form and &lt;code&gt;Q&lt;/code&gt; is converted to conjunctive normal form. &lt;code&gt;P&lt;/code&gt; subsumes &lt;code&gt;Q&lt;/code&gt; if and only if:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cba85f77aa7430cfee47126ca01127a3952aa86" translate="yes" xml:space="preserve">
          <source>Specifically, partial ordering takes place in the following situations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a4be71b2931c171b2d4e3c19119a4720e801cc3" translate="yes" xml:space="preserve">
          <source>Specifically, these functions return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9ff7d39e693899b2fb01c2af7e0b9aad8efd43b" translate="yes" xml:space="preserve">
          <source>Specifically:</source>
          <target state="translated">Specifically:</target>
        </trans-unit>
        <trans-unit id="675adfe3476229cd237b4d2fd189146d41be73b2" translate="yes" xml:space="preserve">
          <source>Specifiers</source>
          <target state="translated">Specifiers</target>
        </trans-unit>
        <trans-unit id="a1caa2edff634e8bec98acd995f893dc449a0d6e" translate="yes" xml:space="preserve">
          <source>Specifies available file open flags. It is a &lt;a href=&quot;../../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt;, the following constants are defined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2850fef006b6b944b6497794aaefb91b462abe2d" translate="yes" xml:space="preserve">
          <source>Specifies available formatting flags. It is a &lt;a href=&quot;../../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt;. The following constants are defined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb779dd079a8d3e459e51752dd5d4816b0f83b35" translate="yes" xml:space="preserve">
          <source>Specifies file seeking direction type. The following constants are defined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3499f44ebeefc016594ac5c37f09b8d9129d27da" translate="yes" xml:space="preserve">
          <source>Specifies preconditions, postconditions, and assertions for functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2143bad35d1f2fbbd47539662a7a179dc7bf47ab" translate="yes" xml:space="preserve">
          <source>Specifies state of a future as returned by &lt;code&gt;wait_for&lt;/code&gt; and &lt;code&gt;wait_until&lt;/code&gt; functions of &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da11e8ee385feb14fbf004b5f791712dc0780517" translate="yes" xml:space="preserve">
          <source>Specifies stream state flags. It is a &lt;a href=&quot;../../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt;, the following constants are defined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71f6b5a60b0b269826814ffa140e352effb52a5e" translate="yes" xml:space="preserve">
          <source>Specifies that &lt;code&gt;&lt;a href=&quot;../errc&quot;&gt;std::errc&lt;/a&gt;&lt;/code&gt; is an error condition enum. This enables implicit conversion to &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40209fd8a369aa7fc6403e72f4b4716656d7082e" translate="yes" xml:space="preserve">
          <source>Specifies that &lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc&lt;/a&gt;&lt;/code&gt; is an error code enum. This enables &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; automatic conversions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="412fe6ca3230fdc26500228eca990cd8bb20c0fb" translate="yes" xml:space="preserve">
          <source>Specifies that &lt;code&gt;^&lt;/code&gt; shall match the beginning of a line and &lt;code&gt;$&lt;/code&gt; shall match the end of a line, if the ECMAScript engine is selected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce22337568229feaeef44935c6a25aeef4047a6f" translate="yes" xml:space="preserve">
          <source>Specifies that a &lt;a href=&quot;virtual&quot;&gt;virtual function&lt;/a&gt; cannot be overridden in a derived class or that a class cannot be &lt;a href=&quot;derived_class&quot;&gt;inherited from&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6652410dc292c5007f2fda79d6e08c4ff46aed4" translate="yes" xml:space="preserve">
          <source>Specifies that a &lt;a href=&quot;virtual&quot;&gt;virtual function&lt;/a&gt; overrides another virtual function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58a189457ac13432965bf5e933104b789fcc04df" translate="yes" xml:space="preserve">
          <source>Specifies that a type is &lt;a href=&quot;../language/data_members#Standard_layout&quot;&gt;standard layout type&lt;/a&gt;. Standard layout types are useful for communicating with code written in other programming languages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97f2db1cf7b23349d1adeebe865a180e6747d323" translate="yes" xml:space="preserve">
          <source>Specifies that a type is a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2ab2c1f43001817230ea7b5da552514bf9545e0" translate="yes" xml:space="preserve">
          <source>Specifies that a type is a trivial type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e72390ff2950300b0856757bee126466769677f" translate="yes" xml:space="preserve">
          <source>Specifies that an instance of the type can be assigned from an &lt;a href=&quot;../language/value_category&quot;&gt;rvalue&lt;/a&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca72e6c27c36bc11e82dd994ddb760bc39ee3df1" translate="yes" xml:space="preserve">
          <source>Specifies that an instance of the type can be constructed from an &lt;a href=&quot;../language/value_category&quot;&gt;rvalue&lt;/a&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fada4cd707b398cb1a5f86f68cfc3038b346c42e" translate="yes" xml:space="preserve">
          <source>Specifies that an instance of the type can be copy-assigned from an &lt;a href=&quot;../language/value_category&quot;&gt;lvalue expression&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd59f96e22ded7e4286f96c96495f1e28b8bb0ff" translate="yes" xml:space="preserve">
          <source>Specifies that an instance of the type can be copy-constructed from an &lt;a href=&quot;../language/value_category&quot;&gt;lvalue expression&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ac12f39fb79216f7e1a02d97e0b63af88a4643a" translate="yes" xml:space="preserve">
          <source>Specifies that an instance of the type can be copy-constructed in-place by a given allocator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03fae4eb0c4ad42c583a672e2e545d274ab592b7" translate="yes" xml:space="preserve">
          <source>Specifies that an instance of the type can be default constructed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b23f9e379358b39515cc638465e5eef9c060039a" translate="yes" xml:space="preserve">
          <source>Specifies that an instance of the type can be default-constructed in-place by a given allocator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50aa7b3d1e4fcbdf2207bccb8a04a767175e6369" translate="yes" xml:space="preserve">
          <source>Specifies that an instance of the type can be destructed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d47e9869a2643d9f79cb28f6a04ee15b388eb74" translate="yes" xml:space="preserve">
          <source>Specifies that an object of the type can be constructed from a given set of arguments in uninitialized storage by a given allocator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f0f9886e068ff9ff576b4c801087069812b4ba9" translate="yes" xml:space="preserve">
          <source>Specifies that an object of the type can be constructed into uninitialized storage from an rvalue of that type by a given allocator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70d20b70339dff5e1ba087d45352207cfaace310" translate="yes" xml:space="preserve">
          <source>Specifies that an object of the type can be destroyed by a given &lt;a href=&quot;allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27c439236dbcdd96b8d9abb6b7e6d97a9cfc0caa" translate="yes" xml:space="preserve">
          <source>Specifies that the type can be used as the template argument of &lt;code&gt;&lt;a href=&quot;../numeric/valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baa189d189bb2fc05ffc4c0f6cb568c1117f8841" translate="yes" xml:space="preserve">
          <source>Specifies that the type is POD (Plain Old Data) type. This means the type is compatible with the types used in the C programming language, that is, can be exchanged with C libraries directly, in its binary form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aae228780e11235e1b16e156a121c9f3fdc04a2" translate="yes" xml:space="preserve">
          <source>Specifies that the type is a pointer-like object which can be compared to &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3541d77f9d2355ee7b5c6624cc3612f9b80fd905" translate="yes" xml:space="preserve">
          <source>Specifies the &lt;a href=&quot;objects#Alignment&quot;&gt;alignment requirement&lt;/a&gt; of a type or an object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b77403e83293931543e74e71906ebdf304265e72" translate="yes" xml:space="preserve">
          <source>Specifies the current rounding direction of floating-point arithmetic operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d379181a80eaa4855639c972b4a9c64ce8af284" translate="yes" xml:space="preserve">
          <source>Specifies the event type which is passed to functions registered by &lt;code&gt;&lt;a href=&quot;register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; on specific events. The following constants are defined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fca0d9d3165620a22e1ca17eeba63839f6f29489" translate="yes" xml:space="preserve">
          <source>Specifies the launch policy for a task executed by the &lt;code&gt;&lt;a href=&quot;async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt; function. &lt;code&gt;std::launch&lt;/code&gt; is an enumeration used as &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48b0001fd2a02fb0f468013a53302aefe8836854" translate="yes" xml:space="preserve">
          <source>Specifies the precision in which all floating-point arithmetic operations other than assignment and cast are done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f50baf895b35222407d8333cfba86a5891605e65" translate="yes" xml:space="preserve">
          <source>Specifies whether a function could throw exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b26298b40d0f4780093d39d638a913d5430e82b" translate="yes" xml:space="preserve">
          <source>Splicing maps and sets (&lt;code&gt;&lt;a href=&quot;container/map/extract&quot;&gt;std::map::extract&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;container/map/merge&quot;&gt;std::map::merge&lt;/a&gt;&lt;/code&gt;, &lt;a href=&quot;container/map/insert&quot;&gt;&lt;code&gt;std::map::insert(node_type)&lt;/code&gt;&lt;/a&gt;, etc)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d128c542a0977a832c33da77100282c39f685850" translate="yes" xml:space="preserve">
          <source>Stack is not unwound: destructors of variables with automatic &lt;a href=&quot;../../language/storage_duration&quot;&gt; storage duration&lt;/a&gt; are not called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4567779bd1675996144b2748fafeb695d8826f97" translate="yes" xml:space="preserve">
          <source>Stack unwinding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7734fcdf94be5e3e0e62cbe34bf10da82bd57664" translate="yes" xml:space="preserve">
          <source>Stage 1: conversion specifier selection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f229abe33b912ba3dfcb35234eca7eda55ea2436" translate="yes" xml:space="preserve">
          <source>Stage 2: character extraction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1af41900429ff41a2249450493e1008b35eef80" translate="yes" xml:space="preserve">
          <source>Stage 2: locale-specific conversion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32f4145279ebf203d787e38ce057d611157577de" translate="yes" xml:space="preserve">
          <source>Stage 3: conversion and storage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4131d11d9a0e8c35b6c408e01ffdce46ef839c7" translate="yes" xml:space="preserve">
          <source>Stage 3: padding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f99aab4a8642dbb54c9c31ed3e6c1b7e1ea21d61" translate="yes" xml:space="preserve">
          <source>Stage 4: output</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dfa66079d9b7229409430972fd5f1567d78a3b6" translate="yes" xml:space="preserve">
          <source>Standard</source>
          <target state="translated">Standard</target>
        </trans-unit>
        <trans-unit id="4f8403e30afda69e5d85ce78b52a98f57c10276f" translate="yes" xml:space="preserve">
          <source>Standard algorithms such as &lt;code&gt;&lt;a href=&quot;../algorithm/sort&quot;&gt;std::sort&lt;/a&gt;&lt;/code&gt; and containers such as &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; expect &lt;code&gt;operator&amp;lt;&lt;/code&gt; to be defined, by default, for the user-provided types, and expect it to implement strict weak ordering (thus satisfying the &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt; requirements). An idiomatic way to implement strict weak ordering for a structure is to use lexicographical comparison provided by &lt;code&gt;&lt;a href=&quot;../utility/tuple/tie&quot;&gt;std::tie&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5328552aac39954649b5d41d7c9d3dceb11e3086" translate="yes" xml:space="preserve">
          <source>Standard approach to preventing multiple inclusion of the same header is by using &lt;a href=&quot;https://en.wikipedia.org/wiki/Include_guard&quot;&gt;include guards&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09a6dcfa27a50519251182ae7d40e7305827e30f" translate="yes" xml:space="preserve">
          <source>Standard attributes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71d764f76d4965fc86057a5939b4a260bac04aff" translate="yes" xml:space="preserve">
          <source>Standard exception objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4699acdfb53b46562b7b56c7205e17320756dba8" translate="yes" xml:space="preserve">
          <source>Standard layout</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24cdc73cf5d5cd6b52d459b131965c7490f35646" translate="yes" xml:space="preserve">
          <source>Standard layout types have the following special properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="360c57caedbd1d1ff38dde144677c893d6ad3792" translate="yes" xml:space="preserve">
          <source>Standard library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78b65c784c24e64adb5fb181fab92370d4eb9c22" translate="yes" xml:space="preserve">
          <source>Standard library concepts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30310cff7697d93c13896a3a67af260d5ac15abe" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;algorithm&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5344d1cec2faadaebd419c796e19f8c028b4dc6c" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;any&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9625d8b6cb5d990c798ad2022e9bdd3dc5447d1" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;array&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a530bd05fce769575e24496fcfdd72538bb4d119" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;atomic&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f10a243ee71eb95d0ac0c027199b1c5806f1c4b5" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;bit&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3db9347fa205973e43295f2a661f44267dfdb525" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;bitset&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa3dbcd5aa2ae89b3545f3ea6c49ddc3c5666f8c" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cassert&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df3cee2bf7a87d57f1feab1408c95b1ec3e6bffd" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;ccomplex&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08d91eea93243071941079aeece2a92fb3bfe82c" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cctype&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c331f5c576ec7ee184ffeabece835d0638a5381d" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cerrno&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="830e9e4da6bf32e8dfee8a84aac3326ded51b59b" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cfenv&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad562de008a9052d500945091f82459b8008e4b2" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cfloat&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d546c38369695420f59e87bf6a807dfe86de89e7" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;charconv&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f756f3f41db8d5458a4516da178bff0063c084a8" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;chrono&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e916a895ce400df95c2636c67692899fd43470cd" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cinttypes&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6597f1b7afbc44e2063e8ac6c6d9660786f3b9c5" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;ciso646&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d666b426218283af2a00e6c438e0180e8a245379" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;climits&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1631ea3f206efa9ef405b40cdbc5a15718f6515a" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;clocale&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92713620a0b61bdd61d2d29e019839c9f2901a7d" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cmath&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="906f1f5f3a4714d9c3d8e2754c1217c810037ed5" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;codecvt&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c276a1d54c8cb82e3e38bf0b647dae253b3bfe8" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;compare&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa1c30a31bd0f54b89b18d77ca14ad7cdbc8ee08" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;complex&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0369b803a0638ae66301a82f5a513d5664dd188" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;concepts&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="233e3073fb8f89c94465d27d51856227467c314f" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;condition_variable&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="351a759a265e3e8e556c5d972856fb61ba8bdc8b" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;contract&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43eaa00ef27cc10c810d1383719652104d09d428" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;csetjmp&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12033a038a7443be07e73859625c633d9bfdff93" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;csignal&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec12d91f53956a9a0af121e45d4189f320f61565" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cstdalign&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea6a5851554b8ff8e984144b36d2d1c13bea0008" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cstdarg&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f80662ebf89f08df7d8af0e8e6a2176995d6f27" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cstdbool&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="079d44f3fc59b40b54b5f8acafa551a74edc2e22" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cstddef&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63e3266e930172336eb078485a75b8919264ca78" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cstdint&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11d5cb8c021822da90fafef999077828ad8ab5a7" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cstdio&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="577206f7a97d3603251f05ecf1edf20e6acf0962" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cstdlib&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a90b5389499364b47d1a36742b91c24b0310d26" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cstring&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="299970c7900bda638ac85a38e14969c15293ee41" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;ctgmath&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff6fbcd4e55e5c106b2c07aa666868d9a3dfb1db" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;ctime&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a271bfc9dada552cf9be719f164a3fd49ea12d" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cuchar&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f9df7f6c4488b01abfd0e614a3f1e92e9212b2b" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cwchar&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c01c30d663c313a1e2a4b054a60a033f651b189b" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;cwctype&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4629e786fd7addb2685516f54f1e8ce49e41b1c" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;deque&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60e438e3415d1f8cbdf62bee12e375ef78c1f51d" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;exception&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ba10e4b6a68932b7c60073bb46b3f5aed140231" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;execution&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faefee713db48bf27967466e82c31d0610246f30" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;filesystem&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d875954e0a2ef650c43a6671a35a6dbc76f36db" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;forward_list&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac325916c78f0414563b9a70f6eb5b7a57c42025" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;fstream&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7b68d46c5e7472cabb6595bb9ce1d93b67ba991" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;functional&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d96aaf61f1d6e7f54dd7956941708c503c0be452" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;future&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a00067ade34a10bd1a45c15e2e0ef910df4114d2" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;initializer_list&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a91d48c0f4a86cd2f4d47246198afd343d656523" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;iomanip&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc322e45cd1fed81b3bab917180b6baf54106d5b" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;ios&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf0dd7c7b613409eda7d05ab59a1390748609d4d" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;iosfwd&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32094c5a92210cb3de27616406d1b148df67a476" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;iostream&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b908fd7d41deb24ead7593991fb25cf90f6502a9" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;istream&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="399fcfa6fe77d3965437ae6534d0e2a7a9bc1026" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;iterator&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96367d7ad1f1162a7e8b08e3a07859319a2699fa" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;limits&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="724dedb2749e1d51c8dc5d7fbe651bbca2f5fa73" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;list&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b992a0581c637592ab75f131008e805ea39ebca" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;locale&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7054a59522cc13caf893f31a9f9cad637811cec" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;map&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f45cf910d7be8b33b2c672801cf7d3369acdf3d3" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;memory&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="719d1944cc64a805fb7c6ce11306559e6f26a70f" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;memory_resource&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="905738ae8c67056cdb44f49cd4526170f8dc668f" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;mutex&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3868c3bf80a77fad928a4182e9475d99185f519e" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;new&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="927c3b2f40db408bdeb32453b1c2c882400a9e67" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;numeric&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03d0b5be06821d285dfcef64f0faaf8b939037c5" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;optional&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25440f88b2737d09c41a26279353c4381e83dd15" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;ostream&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4b011ab900fefd40ff0629146651abfc03db5fb" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;queue&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c6d9f52d447ecd9024e3ca364c76ecb28adc8ba" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;random&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eb3b8e90d58778b73b7097c2a4ad368ba35093b" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;ranges&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd292d1c47c7882b2cf07a12511af1ff4ef92afe" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;ratio&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d31d2b6b6a47547e02d0b141ea0800237510092" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;regex&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb47001f264dcc1c680176fb2843fa65dbb6ecb6" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;scoped_allocator&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8f139b7202096f839805ef1e717c3e2bb313603" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;set&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40e6565c7672a21b3d9bc0d6f36b31b6ea208c94" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;shared_mutex&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8015c2c01a1ae801b223f37fac713ab5b7537d09" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;span&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="111a2709c0e03fd25e235fce2df43647ac8b4ddc" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;sstream&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ce51fe4c6946cc68da2bccc13751e6d3cff9a2" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;stack&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e263b215d26df4051400712c1d1de85fe0e78519" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;stdexcept&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82fa68079e46872ba6371e43ee90f4c324eeed1f" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;streambuf&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8802568376c0ff3f8ebe2167589ad64374bffc42" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;string&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16e8da8e6bf9aa0ee9b3bb707adae835fa5ba169" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;string_view&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9041d59548ad1a70e69dc40c13beb14f42758389" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;strstream&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b78926579795f08a3525c13e9088a103cc9745d" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;syncstream&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05dd2bbc57d39045b9c15efa3feb0a2d5d844556" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;system_error&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75920c437b550c3b1db353e1208e7d540dfb2bf0" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;thread&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86d8f634b2e8d69b06effca9680a02ca8aa34506" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;tuple&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccd913703c6d50f2e44b16e9b267aabab9c224e1" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;type_traits&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56e7fbf2767165dddaca2e7ba21050eeb330c81d" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;typeindex&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2772bbfb508fb75267220342312055d9d30838d1" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;typeinfo&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7030b6512b57104f0b8d85ba95160e019cfe54a3" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;unordered_map&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b18e2c06223adba975bd8ec9c619568c802d1fa0" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;unordered_set&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab8030be3b81a9a57ebdc4f4ee783c00d8db9ddc" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;utility&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f0f7734302859b53edd0f1002e029c78892838a" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;valarray&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e625455d2631c1ace87ec154d71694548b6588b6" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;variant&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a1baf0e66b18f753027746ddac2bc1ed49cc5e4" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;vector&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ffd6a8eb705dc937a7fe0d0e6b35bf87ff1db29" translate="yes" xml:space="preserve">
          <source>Standard library header &amp;lt;version&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="654d328591592d08dc8271315e1ebea904bb6852" translate="yes" xml:space="preserve">
          <source>Standard library headers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3dac9dbde4233c05e9af6bd14d756cda62d81a6" translate="yes" xml:space="preserve">
          <source>Standard library implementations (but not the users) may define additional execution policies as an extension. The semantics of parallel algorithms invoked with an execution policy object of implementation-defined type is implementation-defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f59b13f4443014dd818d6d62e0ca50de93aac7f" translate="yes" xml:space="preserve">
          <source>Standard library specializations of &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; execute &lt;code&gt;&lt;a href=&quot;../../string/char_traits&quot;&gt;std::char_traits&lt;/a&gt;&amp;lt;CharT&amp;gt;::length(p);&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7f11a5bc54d097a97edced7adee37d68edf2a87" translate="yes" xml:space="preserve">
          <source>Standard library specializations of &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; return &lt;code&gt;&lt;a href=&quot;../../locale/use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(getloc()).transform(str.data(), str.data() + str.length())&lt;/code&gt; for some temporary string &lt;code&gt;str&lt;/code&gt; constructed as &lt;code&gt;string_type str(first, last)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54c2e99d8ea2e28058e6a2c145dd8bbb69247703" translate="yes" xml:space="preserve">
          <source>Standard library specializations of &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; return &lt;code&gt;&lt;a href=&quot;../../locale/use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../locale/ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(getloc()).tolower(c)&lt;/code&gt;, that is, convert &lt;code&gt;c&lt;/code&gt; to lowercase, using the currently imbued locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5144e981c6c6484149dff7f4f0beecce8e30139" translate="yes" xml:space="preserve">
          <source>Standard library specializations of &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; return &lt;code&gt;c&lt;/code&gt; unmodified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12d5d651a15ccfe72706786c2855cd1678d884f1" translate="yes" xml:space="preserve">
          <source>Standard practice is to use the result of a call to &lt;code&gt;time(0)&lt;/code&gt; as the seed. However, &lt;code&gt;time()&lt;/code&gt; returns a &lt;code&gt;time_t&lt;/code&gt; value, and &lt;code&gt;time_t&lt;/code&gt; is not guaranteed to be an integral type. In practice, though, every major implementation defines &lt;code&gt;time_t&lt;/code&gt; to be an integral type, and this is also what POSIX requires.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f96278355d7a86fd4872e0419bd210178419944b" translate="yes" xml:space="preserve">
          <source>Standard specializations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50d93a9bc9b3b9d66c4edb7cde0b8c0cb17652e2" translate="yes" xml:space="preserve">
          <source>Standard specializations for basic types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e17d7dcf6519a0eb9d420c2f744d5d6623aba9f6" translate="yes" xml:space="preserve">
          <source>Standard specializations for library types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed6715a35349ec5186a2258a1fc2b8a7e6600fb4" translate="yes" xml:space="preserve">
          <source>Standard-compliant IEEE 754 floating-point implementations are required to detect the floating-point underflow, and have two alternative situations where this can be done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e26cb26c5dd59e71ed80fc7cfcfda7a8c768940d" translate="yes" xml:space="preserve">
          <source>Standard-compliant IEEE 754 floating-point implementations of subnormal numbers are required to detect the loss of accuracy associated with the creation of such number, if it occurs, and may do so in one of the two distinct ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffb57ea5ef3c29b0f002a0ec25815bd661eb3ebf" translate="yes" xml:space="preserve">
          <source>StandardLayoutType</source>
          <target state="translated">StandardLayoutType</target>
        </trans-unit>
        <trans-unit id="f7730d7471c71dacebca7e0efdb78a6fa0cf6783" translate="yes" xml:space="preserve">
          <source>Standing Document 6</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1dd515aa2381f04476ea569b39d96a450fd3318" translate="yes" xml:space="preserve">
          <source>Start and termination</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f9106212988ffb212518950c1b57cd1a214ebec" translate="yes" xml:space="preserve">
          <source>Start of the match sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a72502067518684f9deeec70cf119fd26326cd33" translate="yes" xml:space="preserve">
          <source>State</source>
          <target state="translated">State</target>
        </trans-unit>
        <trans-unit id="8599e6e165d2bcb838c46be096bed576d7097ec1" translate="yes" xml:space="preserve">
          <source>State functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de775277311a1f15adade206c2c728fd44d33fe4" translate="yes" xml:space="preserve">
          <source>State not recoverable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5653cebc057d4791ce07031ad9286e729de6d691" translate="yes" xml:space="preserve">
          <source>Statements</source>
          <target state="translated">Statements</target>
        </trans-unit>
        <trans-unit id="ac9ab88c4da84329c3b27c4e3b5bb1de7c492136" translate="yes" xml:space="preserve">
          <source>Statements are fragments of the C++ program that are executed in sequence. The body of any function is a sequence of statements. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94cc4f19c494bbef2c1d56c06acf5a9829ac16cc" translate="yes" xml:space="preserve">
          <source>Static Assertion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb550afd1ebb32356a77de0371e760348130ef0c" translate="yes" xml:space="preserve">
          <source>Static data member definition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46bd22af5dd67ebd874efc2e0ac50e03cd30c502" translate="yes" xml:space="preserve">
          <source>Static data members</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97afd45f475da08d8c0f908949451f73e1e2051f" translate="yes" xml:space="preserve">
          <source>Static data members and unnamed bit-fields are skipped during aggregate initialization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb38fc7b36b66e06d5bf9efbc0bb09a0026e8e85" translate="yes" xml:space="preserve">
          <source>Static data members are not associated with any object. They exist even if no objects of the class have been defined. There is only one instance of the static data member in the entire program with static &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;, unless the keyword &lt;a href=&quot;../keyword/thread_local&quot;&gt;&lt;code&gt;thread_local&lt;/code&gt;&lt;/a&gt; is used, in which case there is one such object per thread with thread storage duration(since C++11).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a10105f9c5b523dd7b45c238796e10e4690c992" translate="yes" xml:space="preserve">
          <source>Static data members cannot be &lt;code&gt;mutable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="371b57153df1ed513114ab949e27cebd491c8434" translate="yes" xml:space="preserve">
          <source>Static data members of a class in namespace scope have &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt; if the class itself has external linkage (i.e. is not a member of &lt;a href=&quot;namespace#Unnamed_namespaces&quot;&gt;unnamed namespace&lt;/a&gt;). Local classes (classes defined inside functions) and unnamed classes, including member classes of unnamed classes, cannot have static data members.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66c70953f1f5a5d30cc40fb358b4d5f32a610e70" translate="yes" xml:space="preserve">
          <source>Static initialization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f30eb0885bcec4fd1755afedbe57f9601ef1f529" translate="yes" xml:space="preserve">
          <source>Static local variables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1c5547b3f51ba366a4284d49631b8e01791d63a" translate="yes" xml:space="preserve">
          <source>Static member functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2af32f47f8018d9be8b0b47c61a0cc38f2d5c6d1" translate="yes" xml:space="preserve">
          <source>Static member functions are not associated with any object. When called, they have no &lt;code&gt;this&lt;/code&gt; pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6b778cb1881bdfe8ba589dfa1d7e64a8648b347" translate="yes" xml:space="preserve">
          <source>Static member functions cannot be &lt;code&gt;virtual&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt;, or &lt;code&gt;volatile&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc21ad13d962a86f6af81e2532633a2953381105" translate="yes" xml:space="preserve">
          <source>Static members obey the &lt;a href=&quot;access&quot;&gt;class member access rules (private, protected, public)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad5e53a8243d18db544d0e4aef917bd32945122b" translate="yes" xml:space="preserve">
          <source>Static members of a class are not associated with the objects of the class: they are independent variables with &lt;a href=&quot;storage_duration&quot;&gt;static or thread (since C++11) storage duration&lt;/a&gt; or regular functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb3a67571fc5f93c2c2097d93c994d457dbd23db" translate="yes" xml:space="preserve">
          <source>Static non-local initialization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9574eed3a2fa1c67fc0230215243b3da4ecc1747" translate="yes" xml:space="preserve">
          <source>Static type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c45b18c0f0f4b3cf24da66312054a56ccf27d9c5" translate="yes" xml:space="preserve">
          <source>Std</source>
          <target state="translated">Std</target>
        </trans-unit>
        <trans-unit id="d5aa1dfd94faedad10f0a8dc6dfafde4729ce588" translate="yes" xml:space="preserve">
          <source>Storage allocator used by &lt;code&gt;X&lt;/code&gt;, or &lt;code&gt;std::allocator_type&amp;lt;X::value_type&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec15fc4dbb2ee73ac6af794fcba5534c45a6a4be" translate="yes" xml:space="preserve">
          <source>Storage class specifiers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f67686a12828f8c435b9873713c43fb5b2da0449" translate="yes" xml:space="preserve">
          <source>Storage class specifiers are not allowed in friend function declarations. A function that is defined in the friend declaration has external linkage, a function that was previously defined, keeps the linkage it was defined with.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d2e5a537eb298ee43ba92a7262f494050e37b01" translate="yes" xml:space="preserve">
          <source>Storage class specifiers, except for &lt;code&gt;thread_local&lt;/code&gt;, are not allowed on &lt;a href=&quot;template_specialization&quot;&gt;explicit specializations&lt;/a&gt; and &lt;a href=&quot;class_template#Explicit_instantiation&quot;&gt;explicit instantiations&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="054b352055da9aba89fd42abb819a5be6e8dda75" translate="yes" xml:space="preserve">
          <source>Storage duration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee607356de208b84b5b4f1b3aa07ccd66969aa16" translate="yes" xml:space="preserve">
          <source>Storage duration and linkage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab679a7d893805c39464b199136b607026da7bb7" translate="yes" xml:space="preserve">
          <source>Storage occupied by trivially destructible objects &lt;a href=&quot;../language/lifetime#Storage_reuse&quot;&gt;may be reused&lt;/a&gt; without calling the destructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7302554a147c8f1ef58779b6dcfb25b50489faa" translate="yes" xml:space="preserve">
          <source>Storage reuse</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eff65dcae7f41c301872cc53e3deb0f34e8823a" translate="yes" xml:space="preserve">
          <source>Stores information about the type and permissions of a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2da9e099a998176bcb262c98bedcd788bd461bcd" translate="yes" xml:space="preserve">
          <source>Stores the &lt;code&gt;value&lt;/code&gt; into the shared state without making the state ready immediately. The state is made ready when the current thread exits, after all variables with thread-local storage duration have been destroyed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="185739e7299f86de0648cf745f16fe6aa8f259af" translate="yes" xml:space="preserve">
          <source>Stores the exception pointer &lt;code&gt;p&lt;/code&gt; into the shared state without making the state ready immediately. The state is made ready when the current thread exits, after all variables with thread-local storage duration have been destroyed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f4f9fe73fb68dcc407f1e0ef33265a27a253cac" translate="yes" xml:space="preserve">
          <source>Straightforward implementation of &lt;code&gt;std::basic_ios&lt;/code&gt; stores only the following members (which all depend on the template parameters and thus cannot be part of &lt;code&gt;&lt;a href=&quot;ios_base&quot;&gt;std::ios_base&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4da38c43ed7080f8a49dff900d3cff58aefb2a07" translate="yes" xml:space="preserve">
          <source>Stream I/O functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27d49e129b02b87ad3e682b42ebfdf9bf5a57eca" translate="yes" xml:space="preserve">
          <source>Stream Iterators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f92543e2fc6c9b6b0c1348fe72efaf553f416cfd" translate="yes" xml:space="preserve">
          <source>Stream extraction and insertion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4117e115ebe03d0f0cc37b33d0ce1b9feb2ef514" translate="yes" xml:space="preserve">
          <source>Stream insertion/extraction operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4efdedd0ec1a3401856545ce2cc8c17664fa2bf2" translate="yes" xml:space="preserve">
          <source>Stream ioctl() timeout</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4c27387ff9f1b49239b2a3296d0f1c69f4d91d5" translate="yes" xml:space="preserve">
          <source>Stream iterators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c67c540c988e57a5f4befbaef40deda7583ff172" translate="yes" xml:space="preserve">
          <source>Stream repositioning operations &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;std::fseek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;fsetpos&quot;&gt;std::fsetpos&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;rewind&quot;&gt;std::rewind&lt;/a&gt;&lt;/code&gt; discard the effects of &lt;code&gt;ungetc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5dff59c7e8474e86f09f5231350118743b2ca36" translate="yes" xml:space="preserve">
          <source>Stream repositioning operations &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;std::fseek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;fsetpos&quot;&gt;std::fsetpos&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;rewind&quot;&gt;std::rewind&lt;/a&gt;&lt;/code&gt; discard the effects of &lt;code&gt;ungetwc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68075f452f35232e13e6ccd0643d8f58364296fe" translate="yes" xml:space="preserve">
          <source>Stream-based I/O</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5f5e1a47da510fa4386d462c1aa32523fb29a1e" translate="yes" xml:space="preserve">
          <source>Strict aliasing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca0097c41d010531d07269f98771f7552ca6ec4e" translate="yes" xml:space="preserve">
          <source>Strict total ordering relation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a95223de1ad301f6e7666d5804a6b78f32f20dc0" translate="yes" xml:space="preserve">
          <source>StrictTotallyOrderedStrictTotallyOrderedWith</source>
          <target state="translated">StrictTotallyOrderedStrictTotallyOrderedWith</target>
        </trans-unit>
        <trans-unit id="d2cf8bb476d3824fdc86b7f80f14dd73afec32f3" translate="yes" xml:space="preserve">
          <source>StrictWeakOrder</source>
          <target state="translated">StrictWeakOrder</target>
        </trans-unit>
        <trans-unit id="db0a185fa483bab1a27815a0aad3de4ddd23c346" translate="yes" xml:space="preserve">
          <source>String I/O implementation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa36590c2f94b03fb1fdfe69ed29015d079c3c83" translate="yes" xml:space="preserve">
          <source>String and stream conversions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41d8cba12ab83e606dc848af9a593af42eacf80b" translate="yes" xml:space="preserve">
          <source>String containing the substring &lt;code&gt;[pos, pos+count)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28e031acc885a0faad2e48479ddf43e3a5c3bc69" translate="yes" xml:space="preserve">
          <source>String conversions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d26b1bbd9eee2dfd3f5c0a081017d1db1f7dfe02" translate="yes" xml:space="preserve">
          <source>String examination</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f8131be0a54d163595856a74881c0952b86c731" translate="yes" xml:space="preserve">
          <source>String literals can be used to &lt;a href=&quot;aggregate_initialization&quot;&gt;initialize character arrays&lt;/a&gt;. If an array is initialized like &lt;code&gt;char str[] = &quot;foo&quot;;&lt;/code&gt;, &lt;code&gt;str&lt;/code&gt; will contain a copy of the string &lt;code&gt;&quot;foo&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="992ce5d61dd55466d37181c4d6e57b2e90b9eaa5" translate="yes" xml:space="preserve">
          <source>String literals have &lt;a href=&quot;storage_duration&quot;&gt;static storage duration&lt;/a&gt;, and thus exist in memory for the life of the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a8ce38efd037714bf10ba473a6eba0fcb37596d" translate="yes" xml:space="preserve">
          <source>String literals placed side-by-side are concatenated at &lt;a href=&quot;translation_phases&quot;&gt;translation phase 6&lt;/a&gt; (after the preprocessor). That is, &lt;code&gt;&quot;Hello,&quot; &quot; world!&quot;&lt;/code&gt; yields the (single) string &lt;code&gt;&quot;Hello, world!&quot;&lt;/code&gt;. If the two strings have the same encoding prefix (or neither has one), the resulting string will have the same encoding prefix (or no prefix).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="411f94c6ca34e4478bca225615707da562686a1d" translate="yes" xml:space="preserve">
          <source>String manipulation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="766f45c1227c8c7d13e31b3c8218c7c441dc99b1" translate="yes" xml:space="preserve">
          <source>String operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="85aec181db33cf00bdd54f1cb9ce01b7d7ff51de" translate="yes" xml:space="preserve">
          <source>Strings library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c0ec7dd80d15f28024dcdf6ef00a96517fd3337" translate="yes" xml:space="preserve">
          <source>Strong equality</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a2cba0627fce84913a263b1689bcc1a5f52e879" translate="yes" xml:space="preserve">
          <source>Strong exception guarantee</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6e1cc7391bbf33d477f2846d55201bd5dc45d0b" translate="yes" xml:space="preserve">
          <source>Strong ordering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b23ece5c063f8e292de60a2d5bc21311633d6bab" translate="yes" xml:space="preserve">
          <source>Strongly happens-before</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f9dcf8956ae1c0d6f55e5d5d3036df614ef80f7" translate="yes" xml:space="preserve">
          <source>Structure holding a calendar date and time broken down into its components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6829a88eb9844dcc19a2c6962557c4417821a67d" translate="yes" xml:space="preserve">
          <source>Structure holding an interval broken down into seconds and nanoseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="973b2408e7e7197be8a8e1752c113a94b7f7898b" translate="yes" xml:space="preserve">
          <source>Structured binding declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc78a4804f98729f1fc5b2a33b36920a69e741f5" translate="yes" xml:space="preserve">
          <source>Structured binding declaration (since C++17)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d6798b48c01e645bbcf19570110d23f14c8b068" translate="yes" xml:space="preserve">
          <source>Subobjects</source>
          <target state="translated">Subobjects</target>
        </trans-unit>
        <trans-unit id="b1bd6eaaf0ebc0fa2da36cbd85120b995ab0f777" translate="yes" xml:space="preserve">
          <source>Subscript</source>
          <target state="translated">Subscript</target>
        </trans-unit>
        <trans-unit id="c1583fa3ea82816d07fd7988b265e391b3ed9264" translate="yes" xml:space="preserve">
          <source>Subscript operator is overloaded by many standard container classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4355b7045e1b93f4ce4ee9fe614f3e36f42492fe" translate="yes" xml:space="preserve">
          <source>Substitution Failure Is Not An Error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a0ac414a99278539760176a2a901e652944aa12" translate="yes" xml:space="preserve">
          <source>Substitution failure (that is, failure to replace template parameters with the deduced or provided template arguments) of a function template removes the function template from the &lt;a href=&quot;overload_resolution&quot;&gt;overload set&lt;/a&gt;. This allows a number of ways to manipulate overload sets using template metaprogramming: see &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="591c5df87c474f7001b9a4b343441ece26f906a9" translate="yes" xml:space="preserve">
          <source>Substitution occurs in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22318c19ebfcbe8742eb22bc4dd2a56e26bc5ca5" translate="yes" xml:space="preserve">
          <source>Substitution proceeds in lexical order and stops when a failure is encountered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a045f4c6f39f937114f65c98c1c2c42cae38a88" translate="yes" xml:space="preserve">
          <source>Subsumption relationship defines partial order of constraints, which is used to determine:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="444502efceec69003dab264c206c253cf80e3d8d" translate="yes" xml:space="preserve">
          <source>Subviews</source>
          <target state="translated">Subviews</target>
        </trans-unit>
        <trans-unit id="6bcbfb9f1192e212a275dd730eb5425c37042275" translate="yes" xml:space="preserve">
          <source>Successive characters obtained from the input iterator &lt;code&gt;in&lt;/code&gt; are matched against the character sequences obtained from &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).falsename()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt; &amp;gt;(str.getloc()).truename()&lt;/code&gt; only as necessary as to identify the unique match. The input iterator &lt;code&gt;in&lt;/code&gt; is compared to &lt;code&gt;end&lt;/code&gt; only when necessary to obtain a character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02dd1aa421985efb1844e6484a1dadac82aaf55c" translate="yes" xml:space="preserve">
          <source>Such expressions can be used as non-type template arguments, array sizes, and in other contexts that require constant expressions, e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21363a6ad79a6a39e59b2152a0df07dbc463441d" translate="yes" xml:space="preserve">
          <source>Such operator can be defined in the class body, which has the effect of generating a separate non-template &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; for each &lt;code&gt;T&lt;/code&gt; and makes that non-template &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; a friend of its &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b03105f26235b8bb335ef3b1058edc0bbb2150d1" translate="yes" xml:space="preserve">
          <source>Such operator will be deleted if overload resolution over x &amp;lt;=&amp;gt; y (considering also operator&amp;lt;=&amp;gt; with reversed order of parameters) fails, or if this operator@ is not applicable to the result of that x&amp;lt;=&amp;gt;y. Otherwise, the defaulted operator@ calls &lt;code&gt;x &amp;lt;=&amp;gt; y @ 0&lt;/code&gt; if an operator&amp;lt;=&amp;gt; with the original order of parameters was selected by overload resolution, or &lt;code&gt;0 @ y &amp;lt;=&amp;gt; x&lt;/code&gt; otherwise:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f59b30f2283f05ae65b26b5ae58feb0b51a1b44e" translate="yes" xml:space="preserve">
          <source>Such pointer may be used as the right-hand operand of the &lt;a href=&quot;operator_member_access&quot;&gt;pointer-to-member access operators&lt;/a&gt;&lt;code&gt;operator.*&lt;/code&gt; and &lt;code&gt;operator-&amp;gt;*&lt;/code&gt;. The &lt;a href=&quot;value_category#Pending_member_function_call&quot;&gt;resulting expression&lt;/a&gt; can be used only as the left-hand operand of a function-call operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a86835bbedf2d82f06941a7eca5e62c9d3bb06d" translate="yes" xml:space="preserve">
          <source>Such pointer may be used as the right-hand operand of the &lt;a href=&quot;operator_member_access&quot;&gt;pointer-to-member access operators&lt;/a&gt;&lt;code&gt;operator.*&lt;/code&gt; and &lt;code&gt;operator-&amp;gt;*&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="525c748fc518254c41cc517df9846906fa547dd6" translate="yes" xml:space="preserve">
          <source>Such threads can still be guaranteed to make progress by blocking with forward progress guarantee delegation: if a thread P blocks in this manner on the completion of a set of threads S, then at least one thread in S will offer a forward progress guarantee that is same or stronger than P. Once that thread completes, another thread in S will be similarly strengthened. Once the set is empty, P will unblock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="885db975a310a3bb649f91e5771f94988987874d" translate="yes" xml:space="preserve">
          <source>Suffix</source>
          <target state="translated">Suffix</target>
        </trans-unit>
        <trans-unit id="a155b76eeff83c1b360d01d1d9f1a602a79c9a17" translate="yes" xml:space="preserve">
          <source>Suffix/postfix &lt;a href=&quot;operator_incdec&quot;&gt;increment and decrement&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19171fbcdbee77041c634a610bfe878ef0ce0cc9" translate="yes" xml:space="preserve">
          <source>Sun Studio 12 Asm Statements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b6c11b5ace8897cf95dd45dac490e5c600cea0" translate="yes" xml:space="preserve">
          <source>Support for functions that take an arbitrary number of parameters (via e.g. &lt;code&gt;&lt;a href=&quot;utility/variadic/va_start&quot;&gt;va_start&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;utility/variadic/va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;utility/variadic/va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="182a3d18bc1ed1dddb8e31853aeb6af1e8a0f41e" translate="yes" xml:space="preserve">
          <source>Support of subnormal values cannot be determined</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b43556e57ddc8fd912e77789b8be419ca8952ed4" translate="yes" xml:space="preserve">
          <source>Supported facets</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1fa93264c642e6139202201a55bd0e027398ffd" translate="yes" xml:space="preserve">
          <source>Supported operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9f4e1ca1505826ce533842453633c496fbcc06f" translate="yes" xml:space="preserve">
          <source>Suppresses warnings on unused entities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a4cb3f45ae9718b61a344bc44ccbb234548bd2f" translate="yes" xml:space="preserve">
          <source>Swap will replace the allocator only if &lt;code&gt;&lt;a href=&quot;../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::propagate_on_container_swap::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. Specifically, it will exchange the allocator instances through an unqualified call to the non-member function swap, see &lt;a href=&quot;swappable&quot;&gt;Swappable&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d99a0e5c0a9ee8ca98669825be4b7a2c66f5f90" translate="yes" xml:space="preserve">
          <source>Swap, forward and move</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05c1d85c002e28643f01e9daa1e79b8890fdda4c" translate="yes" xml:space="preserve">
          <source>Swappable</source>
          <target state="translated">Swappable</target>
        </trans-unit>
        <trans-unit id="6b34e97f93836d5c33eae87b0dff11e13379be29" translate="yes" xml:space="preserve">
          <source>SwappableSwappableWith</source>
          <target state="translated">SwappableSwappableWith</target>
        </trans-unit>
        <trans-unit id="3129fb81987fb272c265d1cd137eafd6477ca2ca" translate="yes" xml:space="preserve">
          <source>Swaps &lt;code&gt;first&lt;/code&gt; with &lt;code&gt;other.first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt; with &lt;code&gt;other.second&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46949daeb4adb6e15c19a65c88f33a850a883f5f" translate="yes" xml:space="preserve">
          <source>Swaps the content of two &lt;code&gt;any&lt;/code&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe4d8941704ab78369e432742b37c716fb6b94d8" translate="yes" xml:space="preserve">
          <source>Swaps the contents (both native and generic format) of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c66074c19195e8d22fd5cfbc04ba7660d205b20e" translate="yes" xml:space="preserve">
          <source>Swaps the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. Equivalent to &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5b50cb7ed1a1f2555712b311ea6515482f921bc" translate="yes" xml:space="preserve">
          <source>Swaps the contents of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3025dc5a0136ff8b6b3463e082445e487801a56c" translate="yes" xml:space="preserve">
          <source>Swaps the contents of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. Equivalent to &lt;code&gt;x.swap(y)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39a37ca052dbf59922f3df1878e2f1d4dab4556f" translate="yes" xml:space="preserve">
          <source>Swaps the contents with those of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bafd3277089c568f441f3a36e08ea4ed9188dfe6" translate="yes" xml:space="preserve">
          <source>Swaps the managed objects and associated deleters of &lt;code&gt;*this&lt;/code&gt; and another &lt;code&gt;unique_ptr&lt;/code&gt; object &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3d1188493c20906244358c4de7315ef4603ceeb" translate="yes" xml:space="preserve">
          <source>Swaps the state and the contents of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9c2ea3679f877cd2374a4920f575171ae6dca64" translate="yes" xml:space="preserve">
          <source>Swaps the value in the position &lt;code&gt;first&lt;/code&gt; and the value in the position &lt;code&gt;last-1&lt;/code&gt; and makes the subrange &lt;code&gt;[first, last-1)&lt;/code&gt; into a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb09cfe768ac5b78438066756631c25180f3bab3" translate="yes" xml:space="preserve">
          <source>Swaps the values of the elements the given iterators are pointing to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="161bcece44d78f71a4f003092121d67d0ab5d642" translate="yes" xml:space="preserve">
          <source>Swaps two &lt;code&gt;variant&lt;/code&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f6ad43437efe3f1f457bebcc0c6ca88eeeb0171" translate="yes" xml:space="preserve">
          <source>Switch and goto are not allowed to jump into a branch of constexpr if statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84353db6d9e8f7c963a844d9880e97431ba69dd8" translate="yes" xml:space="preserve">
          <source>Symbols declared inside a namespace block are placed in a named scope that prevents them from being mistaken for identically-named symbols in other scopes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1708e8cb2dc2bc2a9736cd2e80f3b93534413b5d" translate="yes" xml:space="preserve">
          <source>Symlinks are not followed: if &lt;code&gt;old_p&lt;/code&gt; is a symlink, it is itself renamed, not its target. If &lt;code&gt;new_p&lt;/code&gt; is an existing symlink, it is itself erased, not its target.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6603020623945d110a59e6535ec15891594b9d9" translate="yes" xml:space="preserve">
          <source>Synchronized blocks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="264cc97c04d4dd288f7b8d52441434b3d6f796e8" translate="yes" xml:space="preserve">
          <source>Synchronized blocks are not transactions (unlike the atomic blocks below) and may call transaction-unsafe functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d4065b4c63a635d07eda74bc4ecf84cec1ab74c" translate="yes" xml:space="preserve">
          <source>Synchronized output</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="678d1aed3562116c3434743edc141fd1affe2688" translate="yes" xml:space="preserve">
          <source>Synchronizes the controlled character sequence (the buffers) with the associated character sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3405f14edc4065f66c994c9d5d69885a3408f74" translate="yes" xml:space="preserve">
          <source>Synchronizes the input buffer with the associated data source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36c0630a340d2960affa1c4d2360b0e2c06793fb" translate="yes" xml:space="preserve">
          <source>Synopsis</source>
          <target state="translated">Synopsis</target>
        </trans-unit>
        <trans-unit id="0b4a6369cc47acd5ca23eef4e71b18705b9a52f1" translate="yes" xml:space="preserve">
          <source>Synospis</source>
          <target state="translated">Synospis</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="c3bad23f83eae7e38e2e9c0816279a52be410261" translate="yes" xml:space="preserve">
          <source>System error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="cc46072906546a69cdff466e38285847984778ab" translate="yes" xml:space="preserve">
          <source>T and U model &lt;code&gt;Common&amp;lt;T, U&amp;gt;&lt;/code&gt; only if, given equality-preserving expressions &lt;code&gt;t1&lt;/code&gt;, &lt;code&gt;t2&lt;/code&gt;, &lt;code&gt;u1&lt;/code&gt; and &lt;code&gt;u2&lt;/code&gt; such that &lt;code&gt;decltype((t1))&lt;/code&gt; and &lt;code&gt;decltype((t2))&lt;/code&gt; are both &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;decltype((u1))&lt;/code&gt; and &lt;code&gt;decltype((u2))&lt;/code&gt; are both &lt;code&gt;U&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6300a60075c19a15c0be3e2d7fca0143ba49de7" translate="yes" xml:space="preserve">
          <source>T and U model &lt;code&gt;CommonReference&amp;lt;T, U&amp;gt;&lt;/code&gt; only if, given equality-preserving expressions &lt;code&gt;t1&lt;/code&gt;, &lt;code&gt;t2&lt;/code&gt;, &lt;code&gt;u1&lt;/code&gt; and &lt;code&gt;u2&lt;/code&gt; such that &lt;code&gt;decltype((t1))&lt;/code&gt; and &lt;code&gt;decltype((t2))&lt;/code&gt; are both &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;decltype((u1))&lt;/code&gt; and &lt;code&gt;decltype((u2))&lt;/code&gt; are both &lt;code&gt;U&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b53c771c25daa8d30e1e76628baca20eb6a18d75" translate="yes" xml:space="preserve">
          <source>T is &lt;a href=&quot;copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; and &lt;a href=&quot;copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="660ec12bc6e5a1e7982309431632c35fe746b923" translate="yes" xml:space="preserve">
          <source>T is a specialization of std::pair</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbf4ff0e53e541effb1e235b11c19303e4bc1591" translate="yes" xml:space="preserve">
          <source>T is not a specialization of std::pair</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a2bbd623250bcdc2f4256f3c667f1311bd1ea45" translate="yes" xml:space="preserve">
          <source>T&amp;amp;</source>
          <target state="translated">T&amp;amp;</target>
        </trans-unit>
        <trans-unit id="6e5fca6c212eb7f30524d15a6dc91bbbc02e869b" translate="yes" xml:space="preserve">
          <source>T1, T2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f43137848b69e68deafd2185ce622e6a39c55145" translate="yes" xml:space="preserve">
          <source>T&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;ref&lt;code&gt;(&lt;/code&gt;object&lt;code&gt;) &lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef9a78c2915f5528e6505eb949b5d58b569182c0" translate="yes" xml:space="preserve">
          <source>T&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;ref&lt;code&gt;=&lt;/code&gt;&lt;code&gt;{ &lt;/code&gt;arg1, arg2, ...&lt;code&gt;};&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58403cefdd9cce7fb1b1abb61fee8f704e81cefc" translate="yes" xml:space="preserve">
          <source>T&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;ref&lt;code&gt;=&lt;/code&gt;object&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">T&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;ref&lt;code&gt;=&lt;/code&gt;object&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9431801b45a6671a5d7b975963f60b42024ed42f" translate="yes" xml:space="preserve">
          <source>T&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;ref&lt;code&gt;{&lt;/code&gt;arg1, arg2, ...&lt;code&gt;} &lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a78744dbead2041514127933b52bd90d2354990" translate="yes" xml:space="preserve">
          <source>T&lt;code&gt;&amp;amp;&lt;/code&gt;ref&lt;code&gt;(&lt;/code&gt;object&lt;code&gt;) &lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a52fff1be29878c152fa370ba2e77e69a8b66be8" translate="yes" xml:space="preserve">
          <source>T&lt;code&gt;&amp;amp;&lt;/code&gt;ref&lt;code&gt;=&lt;/code&gt;&lt;code&gt;{ &lt;/code&gt;arg1, arg2, ...&lt;code&gt;};&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dec3d4801dd098b9864d27b532b2c378206f708e" translate="yes" xml:space="preserve">
          <source>T&lt;code&gt;&amp;amp;&lt;/code&gt;ref&lt;code&gt;=&lt;/code&gt;object&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">T&lt;code&gt;&amp;amp;&lt;/code&gt;ref&lt;code&gt;=&lt;/code&gt;object&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="479a67ea0aebcaef66ddb9c2ab92083a0b606dd2" translate="yes" xml:space="preserve">
          <source>T&lt;code&gt;&amp;amp;&lt;/code&gt;ref&lt;code&gt;{ &lt;/code&gt;arg1, arg2, ...&lt;code&gt;} &lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee407094b576204d3e9ff1a1ef6f03f2f02a76f7" translate="yes" xml:space="preserve">
          <source>T&lt;code&gt;( &lt;/code&gt;arg1, arg2, ...&lt;code&gt;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f501dc40cc73438d58b2dbe4beef5b6d5c77c35b" translate="yes" xml:space="preserve">
          <source>T&lt;code&gt;( &lt;/code&gt;other&lt;code&gt;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="161a744b49ef6011a7ff0e37cc55aabe270180c8" translate="yes" xml:space="preserve">
          <source>T&lt;code&gt;()&lt;/code&gt;</source>
          <target state="translated">T&lt;code&gt;()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee6c63fec9c61b160ec6024c893178ae87a7b869" translate="yes" xml:space="preserve">
          <source>T&lt;code&gt;()&lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">T&lt;code&gt;()&lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="29ee971a37413b2bbd54f8424d9f7659e197f9c2" translate="yes" xml:space="preserve">
          <source>T&lt;code&gt;{ &lt;/code&gt;arg1, arg2, ...&lt;code&gt;}&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fadaca5a938ae44efac53c8c00d48b1226cd5101" translate="yes" xml:space="preserve">
          <source>T&lt;code&gt;{} &lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="704b2797979fc2cf181e0b0022c2c1aa42a47fd9" translate="yes" xml:space="preserve">
          <source>T&lt;code&gt;{}&lt;/code&gt;</source>
          <target state="translated">T&lt;code&gt;{}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f253ae3f8717d2493fc839cb70cdefdfc61ad41" translate="yes" xml:space="preserve">
          <source>TMP</source>
          <target state="translated">TMP</target>
        </trans-unit>
        <trans-unit id="ca5c7a79c25392e9261be4500084c2271c6fc9bc" translate="yes" xml:space="preserve">
          <source>TMP_MAX</source>
          <target state="translated">TMP_MAX</target>
        </trans-unit>
        <trans-unit id="0e6ee3d11aac2536c0d557b99d27e8db4bb8e627" translate="yes" xml:space="preserve">
          <source>Tag type used to identify the destroying delete form of &lt;a href=&quot;operator_delete&quot;&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9d8b8edbb3576235d034b9dc26918683ab8bf3c" translate="yes" xml:space="preserve">
          <source>Tagged tuples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8177f361688582b655f06aa8c611cdca7f6344ce" translate="yes" xml:space="preserve">
          <source>Takes a single argument &lt;code&gt;key&lt;/code&gt; of type &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22c108f2e2290618334ae1bdda09c993c77d2243" translate="yes" xml:space="preserve">
          <source>Takes one template type parameter (additional template parameters are optional and allowed)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8649cc453a7e81b2900bc0a1d7daee7ff8a39513" translate="yes" xml:space="preserve">
          <source>Takes two template type parameters (additional template parameters are optional and allowed)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14ae799bf325e27219d4ab3dc8ddcea9a6895d3c" translate="yes" xml:space="preserve">
          <source>Tangent is an analytical function on the complex plain and has no branch cuts. It is periodic with respect to the real component, with period &amp;pi;i, and has poles of the first order along the real line, at coordinates (&amp;pi;(1/2 + n), 0). However no common floating-point representation is able to represent &amp;pi;/2 exactly, thus there is no value of the argument for which a pole error occurs.  Mathematical definition of the tangent is tan z =</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b891e43fd714701379334fa86fe6cdd601c66db" translate="yes" xml:space="preserve">
          <source>Target access</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a578e2926fd3399f91a9bf9c3cd2f37d9c064719" translate="yes" xml:space="preserve">
          <source>Tarray&lt;code&gt;[&lt;/code&gt;N&lt;code&gt;] = {&lt;/code&gt;other&lt;code&gt;};&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ec1ae061c27325c7ecb543adf91235e22cbc9ed" translate="yes" xml:space="preserve">
          <source>Template</source>
          <target state="translated">Template</target>
        </trans-unit>
        <trans-unit id="df44c520fa404c47fb9c3a2fa460f9f6b5a92d1b" translate="yes" xml:space="preserve">
          <source>Template Meta Programming</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5f5d8926b48548b87471b3b504f71aa41a2c5f9" translate="yes" xml:space="preserve">
          <source>Template Parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45f8ada88f0feca34f6f71100875096825e76c58" translate="yes" xml:space="preserve">
          <source>Template aliases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caca60d6981d2b988a9916fd062c816f7d6cd2ae" translate="yes" xml:space="preserve">
          <source>Template argument deduction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8261e155b7964ea0c5c0dbb05cec222ffaa203b" translate="yes" xml:space="preserve">
          <source>Template argument deduction attempts to determine template arguments (types for type template parameters &lt;code&gt;T&lt;/code&gt;i, templates for template template parameters &lt;code&gt;TT&lt;/code&gt;i, and values for non-type template parameters &lt;code&gt;I&lt;/code&gt;i), which can be substituted into each parameter &lt;code&gt;P&lt;/code&gt; to produce the type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc1107a314a5a9280ec0248d4fdc19f3040c0000" translate="yes" xml:space="preserve">
          <source>Template argument deduction for class templates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1eb3324cb08470182136c50093a4f24735ee4ee" translate="yes" xml:space="preserve">
          <source>Template argument deduction for class templates takes place in declarations and in explicit cast expressions; see &lt;a href=&quot;deduction_guide&quot;&gt;class template argument deduction&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8647f32c4462a684e87c28a515f4f9f8bb64fe31" translate="yes" xml:space="preserve">
          <source>Template argument deduction is also performed when the name of a class template is used as the type of an object being constructed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94ba7965884a8778a58214e334e4b77b327dbbf2" translate="yes" xml:space="preserve">
          <source>Template argument deduction is used during &lt;a href=&quot;function_template&quot;&gt;partial ordering of overloaded function templates&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="021b7fe06e4148b5e0923a0f571d8cfcb6d1d1c9" translate="yes" xml:space="preserve">
          <source>Template argument deduction is used during &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;, when generating specializations from a candidate template function. &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are the same as in a regular function call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7ca94beae95ff3d5d1f84a863c4f4d7d10504e5" translate="yes" xml:space="preserve">
          <source>Template argument deduction is used in &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt; of variables, when deducing the meaning of the &lt;b&gt;&lt;a href=&quot;auto&quot;&gt;auto specifier&lt;/a&gt;&lt;/b&gt; from the variable's initializer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ab922d0c264f2678cc14178cbe3b3a2aaa8b213" translate="yes" xml:space="preserve">
          <source>Template argument deduction is used in &lt;a href=&quot;function_template#Explicit_instantiation&quot;&gt;explicit instantiations&lt;/a&gt;, &lt;a href=&quot;template_specialization&quot;&gt;explicit specializations&lt;/a&gt;, and those &lt;a href=&quot;friend#Template_friends&quot;&gt;friend declarations&lt;/a&gt; where the declarator-id happens to refer to a specialization of a function template (for example, &lt;code&gt;friend ostream&amp;amp; operator&amp;lt;&amp;lt; &amp;lt;&amp;gt; (...)&lt;/code&gt;), if not all template arguments are explicitly specified or defaulted, template argument deduction is used to determine which template's specialization is referred to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3d42493811e1d60b682098b0b94617aea28bfcc" translate="yes" xml:space="preserve">
          <source>Template argument deduction is used in declarations of &lt;a href=&quot;functions&quot;&gt;functions&lt;/a&gt;, when deducing the meaning of the &lt;a href=&quot;auto&quot;&gt;auto&lt;/a&gt; specifier in the function's return type, from the return statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b8140b3f1c13e487f6303e128091147759d3453" translate="yes" xml:space="preserve">
          <source>Template argument deduction is used when determining if a &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;deallocation function&lt;/a&gt; template specialization matches a given placement form of &lt;code&gt;operator new&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b30b6f11850a4b69e5c82442ee4977df7c35d742" translate="yes" xml:space="preserve">
          <source>Template argument deduction is used when selecting &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; template arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="784e859c9570b3743b308b59311190ef5b96f971" translate="yes" xml:space="preserve">
          <source>Template argument deduction is used when taking an &lt;a href=&quot;overloaded_address&quot;&gt;address of a overload set&lt;/a&gt;, which includes function templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d46a2bb0daf61718a14fe7d647244512540a80df" translate="yes" xml:space="preserve">
          <source>Template argument deduction takes place after the function template &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt; (which may involve &lt;a href=&quot;adl&quot;&gt;argument-dependent lookup&lt;/a&gt;) and before &lt;a href=&quot;function_template#Template_argument_substitution&quot;&gt;template argument substitution&lt;/a&gt; (which may involve &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt;) and &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc4c883fb9b243ff19f8109f0263f72db75c7ab" translate="yes" xml:space="preserve">
          <source>Template argument deduction takes place after the function template &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt; (which may involve &lt;a href=&quot;adl&quot;&gt;argument-dependent lookup&lt;/a&gt;) and before &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2066a0f0eb39482438496a80f76796effd02820" translate="yes" xml:space="preserve">
          <source>Template argument lists</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9449cf668b334bd388dd84fab3562fa1c4de76a" translate="yes" xml:space="preserve">
          <source>Template argument substitution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9799ad420934ea9199f67000a327e674f897581" translate="yes" xml:space="preserve">
          <source>Template arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1d3b836e1b1c2984f2611a0dd02d3350041ad2a" translate="yes" xml:space="preserve">
          <source>Template arguments of a function template may be obtained from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a6226598cf2e2ba90359b0f5427dce4a74f9148" translate="yes" xml:space="preserve">
          <source>Template declarations (&lt;a href=&quot;class_template&quot;&gt;class&lt;/a&gt;, &lt;a href=&quot;function_template&quot;&gt;function&lt;/a&gt;, and &lt;a href=&quot;variable_template&quot;&gt;variables&lt;/a&gt;(since C++14)) can appear inside a &lt;a href=&quot;class&quot;&gt;member specification&lt;/a&gt; of any class, struct, or union that aren't &lt;a href=&quot;class#Local_classes&quot;&gt;local classes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d3e4d385a0a47bf71b99c56c3cae38ff61af816" translate="yes" xml:space="preserve">
          <source>Template definition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1123fb8fb4f7d6610d019c3d869ba19bf4e459dc" translate="yes" xml:space="preserve">
          <source>Template friend operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0369ea2ee9ff567354532b828c23169851ad589d" translate="yes" xml:space="preserve">
          <source>Template friends</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="954ab955f2a4e981e2a42027ac3b702c33779a3e" translate="yes" xml:space="preserve">
          <source>Template name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f1c92453a495d014a71c7b055869feba9395bd3" translate="yes" xml:space="preserve">
          <source>Template non-type arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c635002659404447d4c7e2ab8abd988522ff7bb" translate="yes" xml:space="preserve">
          <source>Template parameter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="158f89ebdcef88d4b325fe5c789cce36a70e806b" translate="yes" xml:space="preserve">
          <source>Template parameter list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e20fe4a2857b8358f1ccd8985d9145db81f9591" translate="yes" xml:space="preserve">
          <source>Template parameter pack (appears in &lt;a href=&quot;type_alias&quot;&gt;alias template&lt;/a&gt;, &lt;a href=&quot;class_template&quot;&gt;class template&lt;/a&gt; and &lt;a href=&quot;function_template&quot;&gt;function template&lt;/a&gt; parameter lists).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84344a875baa3f63cc16a697c88ae0a96722df2e" translate="yes" xml:space="preserve">
          <source>Template parameter scope</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="169528213450496bf8081e48bcf48a1c7a41eda9" translate="yes" xml:space="preserve">
          <source>Template parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0edccc1d1dd08de6c12a8dfe9520a49934e55347" translate="yes" xml:space="preserve">
          <source>Template parameters and arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98bc23c9456db71ba2bceaf2673d07299b1c8963" translate="yes" xml:space="preserve">
          <source>Template parameters and template arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e5e58ea037a2428a3329abe77243fae65638428" translate="yes" xml:space="preserve">
          <source>Template specializations of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for the various view classes for hashing views.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ec627c749ee6afdaa31903df6588d3408de6241" translate="yes" xml:space="preserve">
          <source>Template template arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa36d3224fbf7f05abd3bc8b6d198706bc54e99c" translate="yes" xml:space="preserve">
          <source>Template template parameter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e92b938702fb48797a6c0a42d95e30ea695a76f0" translate="yes" xml:space="preserve">
          <source>Template type argument cannot be deduced from the type of a non-type template argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3272d29aacc7e69853e8119de9e0103ff80f8cb" translate="yes" xml:space="preserve">
          <source>Template type arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1147ee04573a7cd067766e4b59abbd08612715a4" translate="yes" xml:space="preserve">
          <source>Templated entity</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f25b700ed9f092123a43acb205a6869342cf9dd6" translate="yes" xml:space="preserve">
          <source>Templates</source>
          <target state="translated">Templates</target>
        </trans-unit>
        <trans-unit id="4037e0f46eaecd5f8b76cb0d91a186ad57a8adf8" translate="yes" xml:space="preserve">
          <source>Templates are parametrized by one or more &lt;a href=&quot;template_parameters&quot;&gt;template parameters&lt;/a&gt;, of three kinds: type template parameters, non-type template parameters, and template template parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dd47d975501c17b1a1ca16d301aae785c1f28b2" translate="yes" xml:space="preserve">
          <source>Temporary materialization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87fdc9da30b92d4a08598b93f4ff2ca23dd3687d" translate="yes" xml:space="preserve">
          <source>Temporary materialization occurs in the following situations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0084b2c9da7ea557315059b130689d4497b1a547" translate="yes" xml:space="preserve">
          <source>Temporary object lifetime</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b266d3f9ca89db726a727b7e50ba573b837fc17" translate="yes" xml:space="preserve">
          <source>Temporary objects are created when a prvalue is &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;materialized&lt;/a&gt; so that it can be used as a glvalue, which occurs(since C++17) in the following situations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b57510c542f5a993e2618bd5690916e7fa2112f8" translate="yes" xml:space="preserve">
          <source>Terminates the current function and returns the specified value (if any) to its caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53cfde24b063bc9582b42597d027b0b8dffcfacd" translate="yes" xml:space="preserve">
          <source>Terminating functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddf71a1eb1ddc085dfce1004387d01a5ff9cc02b" translate="yes" xml:space="preserve">
          <source>Termination (e.g. &lt;code&gt;&lt;a href=&quot;utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;utility/program/atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt;), environment (e.g. &lt;code&gt;&lt;a href=&quot;utility/program/system&quot;&gt;std::system&lt;/a&gt;&lt;/code&gt;), signals (e.g. &lt;code&gt;&lt;a href=&quot;utility/program/raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8c520bcd2f6ebd89c7fb968b08b7787bde36d95" translate="yes" xml:space="preserve">
          <source>Test for the stringstream's setbuf functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22d0fe21a5525b59123ac9716f8c51966f199982" translate="yes" xml:space="preserve">
          <source>Tests two locales for equality. Named locales are considered equal if their names are equal. Unnamed locales are considered equal if they are copies of each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="660f799d669d5b7231f67c281132ba4f5cffb5db" translate="yes" xml:space="preserve">
          <source>Text file busy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ceaad237ce0d960d8aadd10ab31382cc8cdd772" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;../language/operator_member_access#Built-in_member_access_operators&quot;&gt;pseudo destructor call&lt;/a&gt;, all scalar types meet the requirement of Destructible, while array types and reference types do not. Note that &lt;code&gt;&lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_destructible&lt;/a&gt;&lt;/code&gt; allows arrays and reference types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="991c0d6625cff5b8f151f80564a5913700404658" translate="yes" xml:space="preserve">
          <source>That is, depending on whether the destination type is wider or narrower, signed integers are sign-extended&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;implicit_cast#cite_note-1&quot;&gt;[footnote 1]&lt;/a&gt;&lt;/sup&gt; or truncated and unsigned integers are zero-extended or truncated respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="7f99f89abc7064489bc92e58f82cd9a4f80c8567" translate="yes" xml:space="preserve">
          <source>The &quot;unspecified when and how&quot; wording makes it possible to &lt;a href=&quot;../../language/new#Allocation&quot;&gt;combine or optimize away heap allocations&lt;/a&gt; made by the standard library containers, even though such optimizations are disallowed for direct calls to &lt;code&gt;::operator new&lt;/code&gt;. For example, this is implemented by libc++ (&lt;a href=&quot;https://github.com/llvm-mirror/libcxx/blob/master@%7B2017-02-09%7D/include/memory#L1766-L1772&quot;&gt;[1]&lt;/a&gt; and &lt;a href=&quot;https://github.com/llvm-mirror/libcxx/blob/master@%7B2017-02-09%7D/include/new#L211-L217&quot;&gt;[2]&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec8b503e021f77990d950dce6036517b5a03066c" translate="yes" xml:space="preserve">
          <source>The 'c' in the name refers to &quot;character&quot; (&lt;a href=&quot;http://www.stroustrup.com/bs_faq2.html#cout&quot;&gt;stroustrup.com FAQ&lt;/a&gt;); &lt;code&gt;cerr&lt;/code&gt; means &quot;character error (stream)&quot; and &lt;code&gt;wcerr&lt;/code&gt; means &quot;wide character error (stream)&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a8fecf5384bb58f5f1f3c578eb7a6b317ee79fc" translate="yes" xml:space="preserve">
          <source>The 'c' in the name refers to &quot;character&quot; (&lt;a href=&quot;http://www.stroustrup.com/bs_faq2.html#cout&quot;&gt;stroustrup.com FAQ&lt;/a&gt;); &lt;code&gt;cin&lt;/code&gt; means &quot;character input&quot; and &lt;code&gt;wcin&lt;/code&gt; means &quot;wide character input&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f79cbf5556a15f45028f844ce3055e0744314bd" translate="yes" xml:space="preserve">
          <source>The 'c' in the name refers to &quot;character&quot; (&lt;a href=&quot;http://www.stroustrup.com/bs_faq2.html#cout&quot;&gt;stroustrup.com FAQ&lt;/a&gt;); &lt;code&gt;clog&lt;/code&gt; means &quot;character log&quot; and &lt;code&gt;wclog&lt;/code&gt; means &quot;wide character log&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b39ed7ebcf3324b6b14cde3229744c18d31dabe6" translate="yes" xml:space="preserve">
          <source>The 'c' in the name refers to &quot;character&quot; (&lt;a href=&quot;http://www.stroustrup.com/bs_faq2.html#cout&quot;&gt;stroustrup.com FAQ&lt;/a&gt;); &lt;code&gt;cout&lt;/code&gt; means &quot;character output&quot; and &lt;code&gt;wcout&lt;/code&gt; means &quot;wide character output&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eff5189172eae02363633052a355d76231baa69f" translate="yes" xml:space="preserve">
          <source>The (1,3) versions use &lt;code&gt;operator&amp;lt;&lt;/code&gt; to compare the values, the (2,4) versions use the given comparison function &lt;code&gt;comp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dafcf0eaeb756f05d2a7ee64ed4d401cfeaa9f16" translate="yes" xml:space="preserve">
          <source>The (1,3) versions use &lt;code&gt;operator&amp;lt;&lt;/code&gt; to compare the values, whereas the (2,4) versions use the given comparison function &lt;code&gt;comp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72d965e72fed1724b83c60ac53dfc7b1420fc061" translate="yes" xml:space="preserve">
          <source>The 10000th consecutive invocation of a default-constructed &lt;code&gt;std::mt19937&lt;/code&gt; is required to produce the value &lt;code&gt;4123659995&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e984147075a8e19185c784f917a48a1255282c00" translate="yes" xml:space="preserve">
          <source>The 10000th consecutive invocation of a default-constructed &lt;code&gt;std::mt19937_64&lt;/code&gt; is required to produce the value &lt;code&gt;9981545732273789042&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22a2a7106aa748d02361b5b68e6c3538fa1a14a6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../language/implicit_cast&quot;&gt;implicit conversion&lt;/a&gt; from floating-point to integral types also rounds towards zero, but is limited to the values that can be represented by the target type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc7ca13e4dd512b9edc6ada98b8b9e3bb683e777" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../language/operator_comparison#Three-way_comparison&quot;&gt;built-in operator &amp;lt;=&amp;gt;&lt;/a&gt; between floating-point values uses this ordering: the positive zero and the negative zero compare &lt;code&gt;equivalent&lt;/code&gt;, but can be distinguished, and NaN values compare &lt;code&gt;unordered&lt;/code&gt; with any other value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d000eea4291a415d9c69d5748511309341684c13" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd79d33be09689ea727915a9822da9a6d0521504" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../algorithm&quot;&gt;parallel algorithms&lt;/a&gt; from the C++ standard library block with forward progress delegation on the completion of an unspecified set of library-managed threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f384097a3ae4467a606ee3b68db7ca3598cd80c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../basic_istream/sentry&quot;&gt;&lt;code&gt;basic_istream::sentry&lt;/code&gt;&lt;/a&gt; constructor, executed at the beginning of every formatted input function: unless the &lt;code&gt;skipws&lt;/code&gt; bit is unset (e.g. by issuing &lt;code&gt;&lt;a href=&quot;../manip/skipws&quot;&gt;std::noskipws&lt;/a&gt;&lt;/code&gt;), sentry reads and discards the leading whitespace characters. If the end of the input stream is reached during this operation, both &lt;code&gt;eofbit&lt;/code&gt; and &lt;code&gt;failbit&lt;/code&gt; are set, and no input takes place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="199af1ea4bea41c373d1d6f366f0d224e116dc92" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../basic_istream/sentry&quot;&gt;&lt;code&gt;basic_istream::sentry&lt;/code&gt;&lt;/a&gt; constructor, executed at the beginning of every input function, if either &lt;code&gt;eofbit&lt;/code&gt; or &lt;code&gt;badbit&lt;/code&gt; is already set on the stream, or if the end of stream is encountered while consuming leading whitespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d96f80b80220186129523ee520a0da3f49221e7e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../basic_ostream/sentry&quot;&gt;&lt;code&gt;basic_ostream::sentry&lt;/code&gt;&lt;/a&gt; constructor, executed at the beginning of every output function, under implementation-defined conditions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67ebf820ed34aa7b8ca3afede0441918c21cb408" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../language/converting_constructor&quot;&gt;converting constructor&lt;/a&gt; template of &lt;code&gt;std::default_delete&lt;/code&gt; makes possible the implicit conversion from &lt;code&gt;&lt;a href=&quot;unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;Derived&amp;gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;Base&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb78bdf488984400241ded004fa4fc61ae9f25cd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../language/new&quot;&gt;new-expression&lt;/a&gt; is the only way to create an object or an array of objects with dynamic storage duration, that is, with lifetime not restricted to the scope in which it is created. A new-expression obtains storage by calling an allocation function. A &lt;a href=&quot;../language/delete&quot;&gt;delete-expression&lt;/a&gt; destroys a most derived object or an array created by a new-expression and calls the deallocation function. The default allocation and deallocation functions, along with related functions, types, and objects, are declared in the header &lt;code&gt;&amp;lt;new&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="309aca672b29807c4114477b4882bf35957b6215" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../types#Type_modifications&quot;&gt;type modifications and transformations&lt;/a&gt; all satisfy &lt;strong&gt;TransformationTrait&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51a3397d80b8ebe672bc53b120dbbf572747d85e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;alignas&quot;&gt;&lt;code&gt;alignas&lt;/code&gt; specifier&lt;/a&gt; is a part of the attribute specifier sequence, although it has different syntax. It may appear where the &lt;code&gt;[[...]]&lt;/code&gt; attributes appear and may mix with them (provided it is used where &lt;code&gt;alignas&lt;/code&gt; is permitted).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ea1c4abb344140ca1bcb71ac4c71ee678785ca" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;attributes/contract&quot;&gt;contract attributes&lt;/a&gt; use a special attribute syntax. Each contract attribute must be in its own attribute specifier (&lt;code&gt;[[]]&lt;/code&gt;). Multiple contract attribute specifiers can be applied to the same entity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0514e99e818aef28d34a3920ed0faa60a58c9c07" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;break&quot;&gt;break&lt;/a&gt; statement, when encountered in statement exits the switch statement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f7e1b4bfb4e870274e353c9c7a72c2da4c1c7a2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;constraints&quot;&gt;requires-expressions&lt;/a&gt; are also unevaluated expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bd00385fb62722a0d9108affa4f29eb6e8ab044" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;duration/zero&quot;&gt;zero&lt;/a&gt;, &lt;a href=&quot;duration/min&quot;&gt;min&lt;/a&gt;, and &lt;a href=&quot;duration/max&quot;&gt;max&lt;/a&gt; methods in &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; forward their work to these methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f913643a12b0d0e00b4ddb338d2afdcf084e81f8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;explicit&quot;&gt;explicit bool conversion&lt;/a&gt; can also be used to resolve the safe bool problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e2f5aca60ecf6a78733b0021ae9fcf6d42f4b7f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;explicit_cast&quot;&gt;explicit cast&lt;/a&gt; (C-style and function-style) allows casting from a derived lvalue to reference to its private base, or from a pointer to derived to a pointer to its private base.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dbf4257871ad796d81b6aa61568a2a7f80c91ba" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/concurrency&quot;&gt;Concurrency TS&lt;/a&gt; offers atomic smart pointer classes &lt;code&gt;atomic_shared_ptr&lt;/code&gt; and &lt;code&gt;atomic_weak_ptr&lt;/code&gt; as a replacement for the use of these functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08ddf054b9d98118850acc7743563e5e0b4e9519" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/lgamma.html&quot;&gt;POSIX version of lgamma&lt;/a&gt; is not thread-safe: each execution of the function stores the sign of the gamma function of &lt;code&gt;arg&lt;/code&gt; in the static external variable &lt;code&gt;signgam&lt;/code&gt;. Some implementations provide &lt;code&gt;lgamma_r&lt;/code&gt;, which takes a pointer to user-provided storage for singgam as the second parameter, and is thread-safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b9eae232676e01d5fd6170668f3da0c95ea6118" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/boost/intrusive/pointer_traits.html&quot;&gt;Boost.Intrusive library version&lt;/a&gt; of this function returns &lt;code&gt;pointer(&lt;a href=&quot;../addressof&quot;&gt;std::addressof&lt;/a&gt;(r))&lt;/code&gt; if Ptr::pointer_to does not exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010635233092fde8e055bbf80d2c12bb918dcd10" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://en.wikipedia.org/wiki/Pendulum_(mathematics)&quot;&gt;period of a pendulum&lt;/a&gt; of length l, given acceleration due to gravity g, and initial angle &amp;theta; equals 4&amp;radic;l/gK(sin2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c1b8fdbe6f999bd3bde041a408fe4f61954baca" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.boost.org/doc/libs/1_69_0/doc/html/boost/container/vector.html&quot;&gt;Boost.Container version of &lt;code&gt;vector&lt;/code&gt;&lt;/a&gt; does not specialize for &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25b6c7d0f7829048a23706dba4d464728152672c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lifetime&quot;&gt;lifetime&lt;/a&gt; of a union member begins when the member is made active. If another member was active previously, its lifetime ends.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75569aea6242143bafa72b9244654b2f1ffee9b6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;locale&quot;&gt;localizations library&lt;/a&gt; provides support for string conversions (e.g. &lt;code&gt;&lt;a href=&quot;locale/wstring_convert&quot;&gt;std::wstring_convert&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;std::toupper&lt;/code&gt;) as well as functions that classify characters (e.g. &lt;code&gt;std::isspace&lt;/code&gt; or &lt;code&gt;std::isdigit&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6392fcea478e829169e87444fc4c60b8cb4b9864" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;namespace#Using-declarations&quot;&gt;using-declaration&lt;/a&gt; carries over the set of known default arguments, and if more arguments are added later to the function's namespace, those defaults are also visible anywhere the using-declaration is visible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69cb2d817c289d67773a04ab2bae52ceb82957ab" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sizeof...&quot;&gt;sizeof...&lt;/a&gt; operator is classified as a pack expansion as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9047dc8b99e11f74d359b855ae4a29a09c1fbb0c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;this&quot;&gt;this&lt;/a&gt; pointer is not allowed in default arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebb064a9427a1fa7970d44bed331bc5281f03c83" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;types&quot;&gt;types&lt;/a&gt;&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;unsigned char&lt;/code&gt;, and &lt;code&gt;signed char&lt;/code&gt; use one byte for both storage and &lt;a href=&quot;objects&quot;&gt;value representation&lt;/a&gt;. The number of bits in a byte is accessible as &lt;code&gt;&lt;a href=&quot;../types/climits&quot;&gt;CHAR_BIT&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;unsigned char&amp;gt;::digits&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7deaf166831ce5c7a13969ac2e92d63024ee5c2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#define&lt;/code&gt; directives define the identifier as macro, that is instruct the compiler to replace all successive occurrences of identifier with replacement-list, which can be optionally additionally processed. If the identifier is already defined as any type of macro, the program is ill-formed unless the definitions are identical.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="287587d438d07ca409150386008ca217010582fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#undef&lt;/code&gt; directive undefines the identifier, that is cancels previous definition of the identifier by &lt;code&gt;#define&lt;/code&gt; directive. If the identifier does not have associated macro, the directive is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5eee63a87c12a11bb1c8a0a0749af63ec71ad7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/&lt;/code&gt; character is used as the directory separator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ef5aafaaf469702d40ab87247fd921b47e112e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../bitset&quot;&gt;std::bitset&lt;/a&gt;&lt;/code&gt; class includes &lt;code&gt;std::bitset::reference&lt;/code&gt; as a publicly-accessible nested class. This class is used as a proxy object to allow users to interact with individual bits of a bitset, since standard C++ types (like references and pointers) are not built with enough precision to specify individual bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff91fcef49846bb86b26acc3f9bb92f3953489ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../chrono/time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt; type of the clock. C1 and C2 shall refer to the same epoch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af79d3235b89d256527053836a204ade24c05400" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&lt;/code&gt; literal with the real part zero and imaginary part &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2731448977f0cbf91abc6a9042bd867718792a0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; class should be &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;, &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, and &lt;a href=&quot;../../named_req/destructible&quot;&gt;Destructible&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="256311ca8ebf43604948d87d24e1085571bf6f9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../manip/get_money&quot;&gt;std::get_money&lt;/a&gt;&lt;/code&gt; I/O manipulator and &lt;a href=&quot;../../locale/money_get/get&quot;&gt;&lt;code&gt;money_get::get&lt;/code&gt;&lt;/a&gt; function, if the end of the stream is reached before the last character needed to parse the expected monetary value was processed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="855c845c4c3a199f90f14aaf76eca19e27247859" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt; I/O manipulator and any of the &lt;code&gt;&lt;a href=&quot;../../locale/time_get&quot;&gt;std::time_get&lt;/a&gt;&lt;/code&gt; parsing functions: &lt;a href=&quot;../../locale/time_get/get&quot;&gt;&lt;code&gt;time_get::get&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../locale/time_get/get_time&quot;&gt;&lt;code&gt;time_get::get_time&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../locale/time_get/get_date&quot;&gt;&lt;code&gt;time_get::get_date&lt;/code&gt;&lt;/a&gt;, etc., if the end of the stream is reached before the last character needed to parse the expected date/time value was processed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b35cd52c40c238d2e9a4ff26960212d9fbf9298" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../range/bidirectionalrange&quot;&gt;BidirectionalRange&lt;/a&gt;&lt;/code&gt; concept is a refinement of &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; for which &lt;code&gt;ranges::begin&lt;/code&gt; returns a model of &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/BidirectionalIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bf354f8099857c98c4c162bdb943e1320618bc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../range/forwardrange&quot;&gt;ForwardRange&lt;/a&gt;&lt;/code&gt; concept is a refinement of &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; for which &lt;code&gt;ranges::begin&lt;/code&gt; returns a model of &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ForwardIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;ForwardIterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c51d556d7d72ec5f4c07fd94f97a33c4dda222f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../range/inputrange&quot;&gt;InputRange&lt;/a&gt;&lt;/code&gt; concept is a refinement of &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; for which &lt;code&gt;ranges::begin&lt;/code&gt; returns a model of &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/InputIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;InputIterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dea9bfb485f84e3103496966c620db434adb7a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../range/outputrange&quot;&gt;OutputRange&lt;/a&gt;&lt;/code&gt; concept is a refinement of &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; for which &lt;code&gt;ranges::begin&lt;/code&gt; returns a model of &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/OutputIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;OutputIterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="582b57be33c23d5adc91c4522e8fff2b7e87b04d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../range/randomaccessrange&quot;&gt;RandomAccessRange&lt;/a&gt;&lt;/code&gt; concept is a refinement of &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; for which &lt;code&gt;ranges::begin&lt;/code&gt; returns a model of &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/RandomAccessIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f98db1655ef0f271fb435a6239101324463dabb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; specialization defines &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; as a publicly-accessible nested class. &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; proxies the behavior of references to a single bit in &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bea81b9244b70065719191c6c0629d573941f04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4172c516b68500c9770e2bdf9941b5988e6ff32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;sputc&quot;&gt;sputc()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;sputn&quot;&gt;sputn()&lt;/a&gt;&lt;/code&gt; call this function in case of an overflow (&lt;code&gt;pptr() == nullptr&lt;/code&gt; or &lt;code&gt;pptr() &amp;gt;= epptr()&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f6967c213bc2e93fe61b8bd41eb28f5ebb0dfd3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CommonRange&lt;/code&gt; concept is a refinement of &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; for which &lt;code&gt;ranges::begin&lt;/code&gt; and &lt;code&gt;ranges::end&lt;/code&gt; return the same type (e.g. all standard library containers).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0abeef975f9212d53e66b1527efeb888666e8efc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Constructible&lt;/code&gt; concept specifies that a variable of type &lt;code&gt;T&lt;/code&gt; can be initialized with the given set of argument types &lt;code&gt;Args...&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f7de4726e679b44af8c8d284cb95faef91bff36" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ContiguousRange&lt;/code&gt; concept is a refinement of &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; for which &lt;code&gt;ranges::begin&lt;/code&gt; returns a model of &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ContiguousIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;ContiguousIterator&lt;/code&gt;&lt;/a&gt; and the customization point &lt;code&gt;ranges::data&lt;/code&gt; is usable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95ecc9e88401481b0a24b03216493707c334d31f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DefaultConstructible&lt;/code&gt; concept provides a shorthand for the common case when the question is whether a type can be constructed with no arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c0205c222ca9d21e9d05367ef4c2ea7fd533e2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; and &lt;code&gt;EXIT_FAILURE&lt;/code&gt; macros expand into integral expressions that can be used as arguments to the &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; function (and, therefore, as the values to return from the &lt;a href=&quot;../../language/main_function&quot;&gt;main function&lt;/a&gt;), and indicate program execution status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d5615a09c39393c229b9c18967835ce479d5d69" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FP_NORMAL&lt;/code&gt;, &lt;code&gt;FP_SUBNORMAL&lt;/code&gt;, &lt;code&gt;FP_ZERO&lt;/code&gt;, &lt;code&gt;FP_INFINITE&lt;/code&gt;, &lt;code&gt;FP_NAN&lt;/code&gt; macros each represent a distinct category of floating-point numbers. They all expand to an integer constant expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4771d6adfbe4d104e6fadb4ac1ec96d29484beb4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HUGE_VALF&lt;/code&gt;, &lt;code&gt;HUGE_VAL&lt;/code&gt; and &lt;code&gt;HUGE_VALL&lt;/code&gt; macros expand to positive floating point constant expressions which compare equal to the values returned by floating-point functions and operators in case of overflow (see &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b53889e1fa8ec514487167aa966e17170b8cc75a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Hash&lt;/code&gt; and &lt;code&gt;KeyEqual&lt;/code&gt; objects must be &lt;a href=&quot;../../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;, and they are exchanged using unqualified calls to non-member &lt;code&gt;swap&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c876028ed259f9708a4f843ab3d6aab2c902892f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Invocable&lt;/code&gt; concept specifies that a callable type &lt;code&gt;F&lt;/code&gt; can be called with a set of argument types &lt;code&gt;Args...&lt;/code&gt; using the function template &lt;code&gt;&lt;a href=&quot;../utility/functional/invoke&quot;&gt;std::invoke&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8c6d2bb20815cb4086648b5791bd3296ece4645" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pred&lt;/code&gt; objects must be &lt;a href=&quot;../../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;, and they are exchanged using unqualified call to non-member &lt;code&gt;swap&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fdd47f91dc15f27f84bdafb62f28f3485f1e1f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Regular&lt;/code&gt; concept specifies that a type is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ce0e6d69f4d620d6fcae2b4f8fef1abc8b43a5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RegularInvocable&lt;/code&gt; concept adds to the &lt;code&gt;Invocable&lt;/code&gt; concept by requiring the &lt;code&gt;invoke&lt;/code&gt; expression to be equality preserving and not modify either the function object or the arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf8e461967237e596e17c697c486009a5fe11770" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SIG_DFL&lt;/code&gt; and &lt;code&gt;SIG_IGN&lt;/code&gt; macros expand into integral expressions that are not equal to an address of any function. The macros define signal handling strategies for &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;std::signal&lt;/a&gt;()&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6de9aff3c7faf216d8e471183c6456f97bd54cbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Semiregular&lt;/code&gt; concept specifies that a type is both copyable and default constructible. It is satisfied by types that behave similarly to built-in types like &lt;code&gt;int&lt;/code&gt;, except that they need not support comparison with &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37ff8b0ffac4e36092586c172067e58bd7864950" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;std::shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; may be a function type: in this case it manages a pointer to function, rather than an object pointer. This is sometimes used to keep a dynamic library or a plugin loaded as long as any of its functions are referenced:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65eaac4daf1baa4af15a6bc0e49ad6bf3b7e19d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ViewableRange&lt;/code&gt; concept is a refinement of &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; that describes a range that can be safely converted into a &lt;a href=&quot;view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0be369a359e4171939ff31f6da284f95c50dd77d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alignas&lt;/code&gt; specifier may be applied to the declaration of a variable or a non-bitfield class data member, or it can be applied to the declaration or definition of a &lt;a href=&quot;classes&quot;&gt;class/struct/union&lt;/a&gt; or &lt;a href=&quot;enum&quot;&gt;enumeration&lt;/a&gt;. It cannot be applied to a function parameter or to the exception parameter of a catch clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bff8ba6726cb421edc960040f88c5cf3e47f9038" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;allocator_traits&lt;/code&gt; class template provides the standardized way to access various properties of &lt;a href=&quot;../named_req/allocator&quot;&gt;Allocators&lt;/a&gt;. The standard containers and other standard library components access allocators through this template, which makes it possible to use any class type as an allocator, as long as the user-provided specialization of &lt;code&gt;allocator_traits&lt;/code&gt; implements all required functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04038d9c6f5ffb5436ba1d17bbcd6c392bc7d37c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;auto&lt;/code&gt; keyword may also be used in a nested-name-specifier. A nested-name-specifier of the form &lt;code&gt;auto::&lt;/code&gt; is a placeholder that is replaced by a class or enumeration type following the rules for &lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/constraints&quot;&gt;constrained type&lt;/a&gt; placeholder deduction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f01f0aaa02136abf45c219eced918e6c249526ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;auto&lt;/code&gt; specifier may also be used in a &lt;a href=&quot;structured_binding&quot;&gt;structured binding&lt;/a&gt; declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eebf15af9f37cc17089284009c20c5353fc1d4ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;auto&lt;/code&gt; specifier may also be used with a function declarator that is followed by a trailing return type, in which case the declared return type is that trailing return type (which may again be a placeholder type).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da5417a4a1f6900885b530dcd22d3e6b960789b1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;begin&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; data members indicate the range - &lt;code&gt;[begin, end)&lt;/code&gt; - in which the &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;abbrev&lt;/code&gt; are in effect for the time zone associated with this &lt;code&gt;sys_info&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08cdecbd98343fa04c3717e4b9bc77c4fd79a3f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;char_traits&lt;/code&gt; class is a traits class template that abstracts basic character and string operations for a given character type. The defined operation set is such that generic algorithms almost always can be implemented in terms of it. It is thus possible to use such algorithms with almost any possible character or string type, just by supplying a customized &lt;code&gt;char_traits&lt;/code&gt; class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="177963573909d55c891e3520852061007eb9c66e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;char_traits&lt;/code&gt; class template satisfies the requirements of &lt;a href=&quot;../named_req/chartraits&quot;&gt;CharTraits&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44b0b21e5f03504b17b1b60754c40fb0b2f0fa8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;char_traits&lt;/code&gt; class template serves as a basis for explicit instantiations. The user can &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std&quot;&gt;provide a specialization&lt;/a&gt; for any custom character types. Several specializations are defined for the standard character types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b0ebde42f38090479a8212aa43f128f736af213" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chi_squared_distribution&lt;/code&gt; produces random numbers x&amp;gt;0 according to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Chi-squared_distribution&quot;&gt;Chi-squared distribution&lt;/a&gt;:  f(x;n) =</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5102ccf4e38654c4fd4d26ea6f891ab30afa39bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chrono&lt;/code&gt; library defines three main types as well as utility functions and common typedefs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6766d205bb5b455d579d758141a563b95b3d67c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chrono&lt;/code&gt; library, a flexible collection of types that track time with varying degrees of precision (e.g. &lt;code&gt;&lt;a href=&quot;chrono/time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a52f6a677651b00292edc29fa2de13e4ac2f9ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;condition_variable&lt;/code&gt; class is a synchronization primitive that can be used to block a thread, or multiple threads at the same time, until another thread both modifies a shared variable (the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b215c4b6c6a9b5c07215f55013e1367ef3ea0332" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;condition_variable_any&lt;/code&gt; class is a generalization of &lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt;. Whereas &lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt; works only on &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&amp;lt;&lt;a href=&quot;mutex&quot;&gt;std::mutex&lt;/a&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;condition_variable_any&lt;/code&gt; can operate on any lock that meets the &lt;a href=&quot;../named_req/basiclockable&quot;&gt;BasicLockable&lt;/a&gt; requirements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cf2d3a260a3d32021ce59105ae016547705dee9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; overloads that return element sequences create a new &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; object. The non-&lt;code&gt;const&lt;/code&gt; overloads return classes holding references to the array elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd55baa6e491928bab686e3cd64f2e9dfe961be7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; qualifier used on a declaration of a non-local non-volatile non-&lt;a href=&quot;variable_template&quot;&gt;template&lt;/a&gt;(since C++14)non-&lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt;(since C++17) variable that is not declared &lt;code&gt;extern&lt;/code&gt; gives it &lt;a href=&quot;storage_duration#Linkage&quot;&gt;internal linkage&lt;/a&gt;. This is different from C where const file scope variables have external linkage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e69cf0356decd5627b692a11a1d92f42afc3d01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;consteval&lt;/code&gt; specifier declares a function or function template to be an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35815ab767098ba84898163f2b361dc56dd3ae30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;constexpr&lt;/code&gt; specifier declares that it is possible to evaluate the value of the function or variable at compile time. Such variables and functions can then be used where only compile time &lt;a href=&quot;constant_expression&quot;&gt;constant expressions&lt;/a&gt; are allowed (provided that appropriate function arguments are given). A &lt;code&gt;constexpr&lt;/code&gt; specifier used in an object declaration  or non-static member function(until C++14) implies &lt;code&gt;const&lt;/code&gt;. A &lt;code&gt;constexpr&lt;/code&gt; specifier used in a function  or &lt;a href=&quot;static&quot;&gt;static&lt;/a&gt; member variable(since C++17) declaration implies &lt;code&gt;inline&lt;/code&gt;. If any declaration of a function or function template has a &lt;code&gt;constexpr&lt;/code&gt; specifier, then every declaration must contain that specifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de7d028befc7b72b5d7baad4130ff394635f4af2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;continue&lt;/code&gt; statement causes a jump, as if by &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; to the end of the loop body (it may only appear within the loop body of &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt;, &lt;a href=&quot;range-for&quot;&gt;range-for&lt;/a&gt;, &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt;, and &lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt; loops).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dca88435ad03881fbd9b4dc716ca855832c1e5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;double&lt;/code&gt; version of &lt;code&gt;std::round&lt;/code&gt; behaves as if implemented as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05595bba0a787573762c012c73d8da365cd8a32d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error_type&lt;/code&gt; is a type that describes errors that may occur during regular expression parsing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="932d4e1dcebe4a218d1fd9f57208e42aa699239e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extern&lt;/code&gt; keyword can also be used to specify &lt;a href=&quot;language_linkage&quot;&gt;language linkage&lt;/a&gt; and &lt;a href=&quot;class_template&quot;&gt;explicit template instantiation declarations&lt;/a&gt;, but it's not a storage class specifier in those cases (except when a declaration is directly contained in a language linkage specification, in which case the declaration is treated as if it contains the &lt;code&gt;extern&lt;/code&gt; specifier).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52649288e6377fb98d3ed6678b3819788af177ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fill&lt;/code&gt; character is provided for those implementation-defined format specifiers and for the user-defined overrides of &lt;code&gt;do_put()&lt;/code&gt; that use padding and filling logic. Such implementations typically make use of the formatting flags from &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceb8fdf893c64b9bf5b9166ad2341a9ce3a4fc89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; bitmask determines which format specifiers and escape sequences are recognized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60a0827b559dc3609b6079d5a14b629f858e635e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get&lt;/code&gt; method waits until the &lt;code&gt;future&lt;/code&gt; has a valid result and (depending on which template is used) retrieves it. It effectively calls &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; in order to wait for the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa10112d4d243c9e88153a1eadcc7cb485d5a648" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get&lt;/code&gt; method waits until the &lt;code&gt;shared_future&lt;/code&gt; has a valid result and (depending on which template is used) retrieves it. It effectively calls &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; in order to wait for the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2786a7f9bc87460e17c0440169fb55a2685fc146" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;goto&lt;/code&gt; statement cannot transfer control into a &lt;a href=&quot;try_catch&quot;&gt;try-block&lt;/a&gt; or into a catch-clause, but can transfer control out of a try-block or a catch-clause (the rules above regarding automatic variables in scope are followed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="031e15ddd6649548e06689a0db9c2fd9bd1bf8f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;initializer&lt;/code&gt; is not optional if.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f965e1c24153a443cd599dc6dec3772ab145903" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; specifier, when used in a &lt;a href=&quot;declarations#Specifiers&quot;&gt;decl-specifier-seq&lt;/a&gt; of a variable with static storage duration (static class member or namespace-scope variable), declares the variable to be an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bde3e8856747d6351599372bdacbbefb9c1e2210" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; specifier, when used in a function's &lt;a href=&quot;declarations#Specifiers&quot;&gt;decl-specifier-seq&lt;/a&gt;, declares the function to be an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aa05d61d78251587e3d9f7bde2b8eaec9c423a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int&lt;/code&gt; parameter is a dummy parameter used to differentiate between prefix and postfix versions of the operators. When the user-defined postfix operator is called, the value passed in that parameter is always zero, although it may be changed by calling the operator using function call notation (e.g., &lt;code&gt;a.operator++(2)&lt;/code&gt; or &lt;code&gt;operator++(a, 2)&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92968e121e7165e31286647fba30664ab9bc7316" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;local_time&lt;/code&gt; associated with &lt;code&gt;tp&lt;/code&gt; and this time zone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8457b952a5ed2dd70613e9c33c791fd7241a61e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;localeconv&lt;/code&gt; function obtains a pointer to a static object of type &lt;code&gt;&lt;a href=&quot;lconv&quot;&gt;std::lconv&lt;/a&gt;&lt;/code&gt;, which represents numeric and monetary formatting rules of the current C locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="871c1b9d3287d86d418a876a89b0359bd3b24165" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lock_guard&lt;/code&gt; class is non-copyable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b612fa95299520ae1c9eb4dbe4d246807c386150" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main()&lt;/code&gt; function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7373830865d083f56e567e0e35241e9449625781" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function has several special properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43f74c21d245cac408b403b1479529ca4f6979ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function is called at program startup after &lt;a href=&quot;initialization&quot;&gt;initialization&lt;/a&gt; of the non-local objects with static &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;. It is the designated entry point to a program that is executed in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89ff7175fcc410342462f2eea4a20828de71c2e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mutex&lt;/code&gt; class is a synchronization primitive that can be used to protect shared data from being simultaneously accessed by multiple threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4bc2f666b0fcf62423756e2f92296de1749b231" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;n&lt;/code&gt;th predecessor of iterator &lt;code&gt;it&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a315e0d4269377bcca03d5a9cce5ae4498e0c870" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;n&lt;/code&gt;th successor of iterator &lt;code&gt;it&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eea079380ac363ae07705954b7f4d3fea5a10329" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; expression attempts to allocate storage and then attempts to construct and initialize either a single unnamed object, or an unnamed array of objects in the allocated storage. The new-expression returns a prvalue pointer to the constructed object or, if an array of objects was constructed, a pointer to the initial element of the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead8e378038e6652b84ea0044d098289ae5652ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noexcept&lt;/code&gt; operator does not evaluate expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2ca9dcb6d4e088c8b11fa6caa39ac36140cdbf7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noexcept&lt;/code&gt; operator performs a compile-time check that returns true if an expression is declared to not throw any exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50c513953b1f92f60c692964e4a72e25a368f1b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numeric_limits&lt;/code&gt; class template provides a standardized way to query various properties of arithmetic types (e.g. the largest possible value for type &lt;code&gt;int&lt;/code&gt; is &lt;code&gt;std::numeric_limits&amp;lt;int&amp;gt;::max()&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fe11954ad007a4af379951d73b5527c3769ef5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;abbrev&lt;/code&gt; data member indicate the UTC offset and time zone abbreviation, respectively, in effect for the associated time zone and &lt;code&gt;&lt;a href=&quot;time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt;. Note that time zone abbreviations are not unique.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f78f379de0f1937dfed883c08e0f94ce9e47e089" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;openmode&lt;/code&gt; argument, required by the base class function signature, is usually ignored, because &lt;code&gt;std::basic_filebuf&lt;/code&gt; maintains only one file position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7134e77fbf2616c72ce53c638efa5b4083c7a3f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;optional&lt;/code&gt; object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e31417a62218983d2ccade81e8afcf7ba3d979c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pointer_traits&lt;/code&gt; class template provides the standardized way to access certain properties of pointer-like types (&lt;a href=&quot;../named_req/allocator#Fancy_pointers&quot;&gt;fancy pointers&lt;/a&gt;, such as &lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/interprocess/offset_ptr.html&quot;&gt;boost::interprocess::offset_ptr&lt;/a&gt;). The standard template &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&lt;/code&gt; relies on &lt;code&gt;pointer_traits&lt;/code&gt; to determine the defaults for various typedefs required by &lt;a href=&quot;../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aed9526a12ac6c0b94706d8d2d4fea2631766202" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;proj&lt;/code&gt; function helps model the Riemann sphere by mapping all infinities to one (give or take the sign of the imaginary zero), and should be used just before any operation, especially comparisons, that might give spurious results for any of the other infinities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16a8dc17771b5740dbb0cfbe04c9fb979e594017" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recursive_mutex&lt;/code&gt; class is a synchronization primitive that can be used to protect shared data from being simultaneously accessed by multiple threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75793db3b7c87aa4e287a2f638dfc7ae867a0afd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recursive_timed_mutex&lt;/code&gt; class is a synchronization primitive that can be used to protect shared data from being simultaneously accessed by multiple threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="579b829a50621b7a0aafe11e52a8bf5b7d048cfa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recursive_timed_mutex&lt;/code&gt; class satisfies all requirements of &lt;a href=&quot;../named_req/timedmutex&quot;&gt;TimedMutex&lt;/a&gt; and &lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f502cafc006683857dcfb81fd4ded261d5ae887" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reference&lt;/code&gt; type for an input iterator that is not also a &lt;a href=&quot;forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; does not have to be a reference type: dereferencing an input iterator may return a proxy object or &lt;code&gt;value_type&lt;/code&gt; itself by value (as in the case of &lt;a href=&quot;../iterator/istreambuf_iterator&quot;&gt;&lt;code&gt;std::istreambuf_iterator&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c035e01c3dbc28696d2904643638e7f98ef9463" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;save&lt;/code&gt; data member, if nonzero, indicates that the time zone is on daylight saving time at the specified time point. In this case, &lt;code&gt;offset - save&lt;/code&gt; is a suggestion of what offset this time zone might use if it were off daylight saving time. However, this information is not authoritative: the only way to ascertain the actual offset is to query the time zone with a time point that is actually off daylight savings time (i.e. returns a &lt;code&gt;sys_info&lt;/code&gt; such that &lt;code&gt;save == 0min&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b88227d0e2029df0809a94b40cd5604a4dddbed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalbln&lt;/code&gt; function is provided because the factor required to scale from the smallest positive floating-point value to the largest finite one may be greater than 32767, the standard-guaranteed &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt;. In particular, for the 80-bit &lt;code&gt;long double&lt;/code&gt;, the factor is 32828.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1f9bffd993af74895ea24d6e5a6c3c209ca9f45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scoped_lock&lt;/code&gt; class is non-copyable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b60c9e939da9755686b6ae70e02cdd28175c2b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setlocale&lt;/code&gt; function installs the specified system locale or its portion as the new C locale. The modifications remain in effect and influences the execution of all locale-sensitive C library functions until the next call to &lt;code&gt;setlocale&lt;/code&gt;. If &lt;code&gt;locale&lt;/code&gt; is a null pointer, &lt;code&gt;setlocale&lt;/code&gt; queries the current C locale without modifying it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b876cb1d68297596d892c9e79612cc1d718ee4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shared_lock&lt;/code&gt; class is movable, but not copyable -- it meets the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; and &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; but not of &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; or &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ba0072c5cc0f9ffc4d13a71fa58acfb63fc0bd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shared_mutex&lt;/code&gt; class is a synchronization primitive that can be used to protect shared data from being simultaneously accessed by multiple threads. In contrast to other mutex types which facilitate exclusive access, a shared_mutex has two levels of access:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c101aca05b9e44dae7ff87f787fe7276b486c130" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shared_mutex&lt;/code&gt; class satisfies all requirements of &lt;a href=&quot;../named_req/sharedmutex&quot;&gt;SharedMutex&lt;/a&gt; and &lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fd15329728ea18d0504ccf1f956107ca292faec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shared_timed_mutex&lt;/code&gt; class is a synchronization primitive that can be used to protect shared data from being simultaneously accessed by multiple threads. In contrast to other mutex types which facilitate exclusive access, a shared_timed_mutex has two levels of access:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06999549f90a0f72f27c3eb6c97153c19f2420bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shared_timed_mutex&lt;/code&gt; class satisfies all requirements of &lt;a href=&quot;../named_req/sharedtimedmutex&quot;&gt;SharedTimedMutex&lt;/a&gt; and &lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ccaf14b5121e6a6f684cf1f7b72304970279974" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;showbase&lt;/code&gt; flag affects the behavior of integer output (see &lt;code&gt;&lt;a href=&quot;../../locale/num_put/put&quot;&gt;std::num_put::put&lt;/a&gt;&lt;/code&gt;), monetary input (see &lt;code&gt;&lt;a href=&quot;../../locale/money_get/get&quot;&gt;std::money_get::get&lt;/a&gt;&lt;/code&gt;) and monetary output (see &lt;code&gt;&lt;a href=&quot;../../locale/money_put/put&quot;&gt;std::money_put::put&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3362f7e2786e23b0e207bf341b6ffbe082ce3138" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;size_type&lt;/code&gt; parameter type in these guides in an refers to the &lt;code&gt;size_type&lt;/code&gt; member type of the type deduced by the deduction guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e44e77d69bd972e28d8374914d0314649d0b42a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;size_type&lt;/code&gt; parameter type in these guides refers to the &lt;code&gt;size_type&lt;/code&gt; member type of the type deduced by the deduction guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="289689bc83eb06d23eb307703ddcdb7c999caeed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;static&lt;/code&gt; keyword is only used with the declaration of a static member, inside the class definition, but not with the definition of that static member:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="632a2ef4017c7723c54fe2b156317f31d8e22a58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::allocator&lt;/code&gt; class template is the default &lt;a href=&quot;../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; used by all standard library containers if no user-specified allocator is provided. The default allocator is stateless, that is, all instances of the given allocator are interchangeable, compare equal and can deallocate memory allocated by any other instance of the same allocator type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53c26f0250cd0d0e3b6ff2be656663e51a81ff93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::atomic_ref&lt;/code&gt; class template applies atomic operations to the object it references. For the lifetime of the &lt;code&gt;atomic_ref&lt;/code&gt; object, the object it references is considered an atomic object. If one thread writes to an atomic object while another thread reads from it, the behavior is well-defined (see &lt;a href=&quot;../language/memory_model&quot;&gt;memory model&lt;/a&gt; for details on data races). In addition, accesses to atomic objects may establish inter-thread synchronization and order non-atomic memory accesses as specified by &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5be75dfd519b71fc03950ad1704971f2fb7ba4f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::chrono::duration_values&lt;/code&gt; type defines three common durations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75ae7925b8d4cb8867916bcfc4f28fc16e262bc9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::chrono::treat_as_floating_point&lt;/code&gt; trait helps determine if a duration can be converted to another duration with a different tick period.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd5a1bbfb563fd5702d71a237c3bf20e52661268" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::jmp_buf&lt;/code&gt; type is an array type suitable for storing information to restore a calling environment. The stored information is sufficient to restore execution at the correct block of the program and invocation of that block. The state of floating-point status flags, or open files, or any other data is not stored in an object of type &lt;code&gt;jmp_buf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0af3608ab8ca3f6303dbf6dc9f92dd5c3b4f3fcc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::placeholders&lt;/code&gt; namespace contains the placeholder objects &lt;code&gt;[_1, . . . _N]&lt;/code&gt; where &lt;code&gt;N&lt;/code&gt; is an implementation defined maximum number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b4aa4d2a1fe7d3edd392aab09fcc04cba814b1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::puts&lt;/code&gt; function appends the newline character to the output, while &lt;code&gt;&lt;a href=&quot;fputs&quot;&gt;std::fputs&lt;/a&gt;&lt;/code&gt; function does not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e796f41be4761572f822b629753c5a0ac5ee7caa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::queue&lt;/code&gt; class is a container adapter that gives the programmer the functionality of a queue - specifically, a FIFO (first-in, first-out) data structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fab3efadd5cd02efa0b0f9d2cdc38130b916876" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::scoped_allocator_adaptor&lt;/code&gt; class template is an allocator which can be used with multilevel containers (vector of sets of lists of tuples of maps, etc). It is instantiated with one outer allocator type &lt;code&gt;OuterAlloc&lt;/code&gt; and zero or more inner allocator types &lt;code&gt;InnerAlloc...&lt;/code&gt;. A container constructed directly with a &lt;code&gt;scoped_allocator_adaptor&lt;/code&gt; uses &lt;code&gt;OuterAlloc&lt;/code&gt; to allocate its elements, but if an element is itself a container, it uses the first inner allocator. The elements of that container, if they are themselves containers, use the second inner allocator, etc. If there are more levels to the container than there are inner allocators, the last inner allocator is reused for all further nested containers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2eb610baf57f075efa3e1ba10e684713d54343a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::stack&lt;/code&gt; class is a container adapter that gives the programmer the functionality of a stack - specifically, a LIFO (last-in, first-out) data structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7bdef376da392b6b3c44811e911c30119a7b799" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;syntax_option_type&lt;/code&gt; is a &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; that contains options that govern how regular expressions behave.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="000b096316dd940449688aa0c1993b2ce2c2a8aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;template&lt;/code&gt; disambiguator for dependent names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74943ce7057f0fa3f16bc77b4e70a8831747bccd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timed_mutex&lt;/code&gt; class is a synchronization primitive that can be used to protect shared data from being simultaneously accessed by multiple threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf84feefedec698c86998dbbdc5ed07c9f45bea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timed_mutex&lt;/code&gt; class satisfies all requirements of &lt;a href=&quot;../named_req/timedmutex&quot;&gt;TimedMutex&lt;/a&gt; and &lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="774795ace98b96b23eeb2920e059fbc2c4d46159" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type_index&lt;/code&gt; class is a wrapper class around a &lt;code&gt;&lt;a href=&quot;type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; object, that can be used as index in associative and unordered associative containers. The relationship with &lt;code&gt;type_info&lt;/code&gt; object is maintained through a pointer, therefore &lt;code&gt;type_index&lt;/code&gt; is &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="952d7e2cfa91115883813c3249ff4a5bfac5cc7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type_info&lt;/code&gt; class is neither &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; nor &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d3381fa6df6fd99efa7dd2c5d1dc236fc0ae2f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typedef&lt;/code&gt; specifier cannot be combined with any other specifier except for &lt;a href=&quot;declarations#Specifiers&quot;&gt;&lt;i&gt;type-specifier&lt;/i&gt;s&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6309085f92b28987d85457fbc7383fb4c82b825c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typedef&lt;/code&gt; specifier may not appear in a declaration that does not contain a declarator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89830011be47b25898d7960332a69424f3dbd42f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typedef&lt;/code&gt; specifier, when used in a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt;'s decl-specifier-seq, specifies that the declaration is a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e11f7ccd1bfac664d81cc3008efb5f71e47d4090" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typeid&lt;/code&gt; of the contained value if instance is non-empty, otherwise &lt;code&gt;typeid(void)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c59bc69dc7ee8fe3806c4e7b187212bf3d16cc45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typename&lt;/code&gt; disambiguator for dependent names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86e34d32fc0fe693f849b744258e885d6bf62692" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;va_arg&lt;/code&gt; macro expands to an expression of type &lt;code&gt;T&lt;/code&gt; that corresponds to the next parameter from the &lt;code&gt;&lt;a href=&quot;va_list&quot;&gt;va_list&lt;/a&gt;&lt;/code&gt;&lt;code&gt;ap&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d83c342cc7c3f40c89a420acc1bb2923f355ef9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;va_copy&lt;/code&gt; macro copies &lt;code&gt;src&lt;/code&gt; to &lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8119763255f85100db2a7dfb429d2ce19267cc94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;va_end&lt;/code&gt; macro performs cleanup for an &lt;code&gt;ap&lt;/code&gt; object initialized by a call to &lt;code&gt;&lt;a href=&quot;va_start&quot;&gt;va_start&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;va_copy&quot;&gt;va_copy&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;va_end&lt;/code&gt; may modify &lt;code&gt;ap&lt;/code&gt; so that it is no longer usable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c4f81b011c317554f9f6191a3841f50837b79d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;va_start&lt;/code&gt; macro enables access to the variable arguments following the named argument &lt;code&gt;parm_n&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f357e6fe110c67c4ec9157f567fd74f58c85b796" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;virtual&lt;/code&gt; specifier specifies that a non-static &lt;a href=&quot;member_functions&quot;&gt;member function&lt;/a&gt; is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58b83f400e2fad2a7e14fb6d6d89f2b937c6c9ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;weibull_distribution&lt;/code&gt; meets the requirements of a &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt; and produces random numbers according to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Weibull_distribution&quot;&gt;Weibull distribution&lt;/a&gt;:  f(x;a,b) =</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f38041d823902ae4cade7f500eac6fbdeba1f56" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;BasicLockable&lt;/strong&gt; requirements describe the minimal characteristics of types that provide exclusive blocking semantics for execution agents (i.e. threads).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e946edd904bb0f3af81272561d148e4ecfdc9d2" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Clock&lt;/strong&gt; requirements describe a bundle consisting of a &lt;code&gt;&lt;a href=&quot;../chrono/duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;, a &lt;code&gt;&lt;a href=&quot;../chrono/time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt;, and a function &lt;code&gt;now()&lt;/code&gt; to get the current time_point. The origin of the clock's time_point is referred to as the clock's epoch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f03c4da73b60ffd44de23eb92a1a79678e480926" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;LegacyIterator&lt;/strong&gt; requirements describe types that can be used to identify and traverse the elements of a container.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a164898b395f07dac6b82d8a1bd649c3574d083b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Lockable&lt;/strong&gt; requirements extends the &lt;a href=&quot;basiclockable&quot;&gt;BasicLockable&lt;/a&gt; requirements to include attempted locking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c33abb9f01c22e93c4eac57daba63323a35b7582" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Mutex&lt;/strong&gt; requirements extends the &lt;a href=&quot;lockable&quot;&gt;Lockable&lt;/a&gt; requirements to include inter-thread synchronization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1662724e943d6f2753a841debdd483663607ada6" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Predicate&lt;/strong&gt; requirements describe a callable that returns a value testable as a &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5fecdfd42fea2e321d400db45ac6548b84c2b1b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;SharedMutex&lt;/strong&gt; requirements extend the &lt;a href=&quot;mutex&quot;&gt;Mutex&lt;/a&gt; requirements to include shared lock ownership mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e0e4c473412d479e82c7a7bf4efbde3fb2da4c0" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;SharedTimedMutex&lt;/strong&gt; requirements extend the &lt;a href=&quot;timedmutex&quot;&gt;TimedMutex&lt;/a&gt; requirements to include shared lock ownership mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8658ec44f14a999da3cd2aea710a9e937c78300" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;TimedLockable&lt;/strong&gt; requirements describe the characteristics of types that provide timed exclusive blocking semantics for execution agents (threads, processes, tasks).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ffb357ce4e9175f2864be5cc3858dccf9117260" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;TimedMutex&lt;/strong&gt; requirements extend the &lt;a href=&quot;timedlockable&quot;&gt;TimedLockable&lt;/a&gt; requirements to include inter-thread synchronization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93769e4268d3151e381981cd69b445de4cedef94" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;TrivialClock&lt;/strong&gt; requirements describe the requirements satisfied by several clocks in the &lt;a href=&quot;../chrono&quot;&gt;chrono library&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a31fec1fddc9cad437c97dc42d06961059327486" translate="yes" xml:space="preserve">
          <source>The Boolean literals are the keywords &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. They are &lt;a href=&quot;value_category&quot;&gt;prvalues&lt;/a&gt; of type &lt;a href=&quot;types#Boolean_type&quot;&gt;bool&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e489b3933471031f8c94a5f27d0516ca33d62cdd" translate="yes" xml:space="preserve">
          <source>The C I/O subset of the C++ standard library implements C-style stream input/output operations. The &lt;code&gt;&amp;lt;cstdio&amp;gt;&lt;/code&gt; header provides generic file operation support and supplies functions with narrow and multibyte character input/output capabilities, and the &lt;code&gt;&amp;lt;cwchar&amp;gt;&lt;/code&gt; header provides functions with wide character input/output capabilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b13410bf3298c9468849b7b32d1cee8a68202e13" translate="yes" xml:space="preserve">
          <source>The C headers &lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;stdnoreturn.h&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;threads.h&amp;gt;&lt;/code&gt; are not included in C++ and have no &lt;code&gt;cxxx&lt;/code&gt; equivalents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="062aac82d16ecfcd5a5e7ac044aa4b63a6939067" translate="yes" xml:space="preserve">
          <source>The C programming language followed a similar taxonomy, except that the role of assignment was no longer significant: C expressions are categorized between &quot;lvalue expressions&quot; and others (functions and non-object values), where &quot;lvalue&quot; means an expression that identifies an object, a &quot;locator value&quot;&lt;sup id=&quot;cite_ref-4&quot;&gt;&lt;a href=&quot;value_category#cite_note-4&quot;&gt;[4]&lt;/a&gt;&lt;/sup&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9475fc59dfb6f8d18f4972f00f8061f2dab21b5" translate="yes" xml:space="preserve">
          <source>The C++ compiler is permitted to perform any changes to the program as long as the following remains true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e8929f0a5483d1e9f1e0fdc81fb09a71a502e05" translate="yes" xml:space="preserve">
          <source>The C++ implementation provides a default &lt;code&gt;std::terminate_handler&lt;/code&gt; function, which calls &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;()&lt;/code&gt;. If the null pointer value is installed (by means of &lt;code&gt;&lt;a href=&quot;set_terminate&quot;&gt;std::set_terminate&lt;/a&gt;&lt;/code&gt;), the implementation may restore the default handler instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa1c34b3fa85012e15f5ad013556c2b855f951b" translate="yes" xml:space="preserve">
          <source>The C++ implementation provides a default &lt;code&gt;std::unexpected_handler&lt;/code&gt; function, which calls &lt;code&gt;&lt;a href=&quot;../terminate&quot;&gt;std::terminate&lt;/a&gt;()&lt;/code&gt;. If the null pointer value is installed (by means of &lt;code&gt;&lt;a href=&quot;set_unexpected&quot;&gt;std::set_unexpected&lt;/a&gt;&lt;/code&gt;), the implementation may restore the default handler instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33090d97db5d6e6aae4e17a0b2eb1114378b6941" translate="yes" xml:space="preserve">
          <source>The C++ language grammar treats &lt;code&gt;mutable&lt;/code&gt; as a &lt;a href=&quot;storage_duration&quot;&gt;storage-class-specifier&lt;/a&gt;, rather than a type qualifier, but it does not affect storage class or linkage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1ab622145b730130c1f77f830b45791e19e3ac6" translate="yes" xml:space="preserve">
          <source>The C++ library classes that manage their own resources follow RAII: &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt;, and many others acquire their resources in constructors (which throw exceptions on errors), release them in their destructors (which never throw), and don't require explicit cleanup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="357bf595c9a6a420509871477ed4029ae08b6588" translate="yes" xml:space="preserve">
          <source>The C++ numerics library includes common mathematical functions and types, as well as optimized numeric arrays and support for random number generation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c724765aa82fdd5f42d875af648738888f7f085" translate="yes" xml:space="preserve">
          <source>The C++ source file is processed by the compiler as if the following phases take place, in this exact order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="298ffb6c4886717de7bb1fec94eac0b561d05f47" translate="yes" xml:space="preserve">
          <source>The C++ standard defers to the C standard for the semantics of this function. In C11 as published, unlike &lt;code&gt;&lt;a href=&quot;mbrtoc16&quot;&gt;std::mbrtoc16&lt;/a&gt;&lt;/code&gt;, which converts variable-width multibyte (such as UTF-8) to variable-width 16-bit (such as UTF-16) encoding, this function can only convert single-unit 16-bit encoding, meaning it cannot convert UTF-16 to UTF-8 despite that being the original intent of this function. This was corrected by the post-C11 defect report &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2059.htm#dr_488&quot;&gt;DR488&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cbca9c403363a5289791532ec4013a859dd4de1" translate="yes" xml:space="preserve">
          <source>The C++ standard library includes &lt;code&gt;&lt;a href=&quot;../utility/variant&quot;&gt;std::variant&lt;/a&gt;&lt;/code&gt;, which can replace many uses of unions and union-like classes. The example above can be re-written as.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d586f49413d548237bec3d53a25aff6188f757f3" translate="yes" xml:space="preserve">
          <source>The C++ standard precisely defines the &lt;a href=&quot;as_if&quot;&gt;observable behavior&lt;/a&gt; of every C++ program that does not fall into one of the following classes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc703b3909b5ff52efc44a7626f3229d0fbc6ce1" translate="yes" xml:space="preserve">
          <source>The C++ standard recommends (but does not require) that lock-free atomic operations are also address-free, that is, suitable for communication between processes using shared memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f3b3f8c95e8561a2c8123a1e6142d5819b3a1ef" translate="yes" xml:space="preserve">
          <source>The C++ strings library includes support for three general types of strings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b7549dcc2f0a4c113aaccafcc4c4cbed6993461" translate="yes" xml:space="preserve">
          <source>The C++ type system consists of the following types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="119c8be7273e2b09e126a70072ca4bb2e62acf6b" translate="yes" xml:space="preserve">
          <source>The C99 standard suggests that C++ implementations should not define the above limit, constant, or format macros unless the macros &lt;code&gt;__STDC_LIMIT_MACROS&lt;/code&gt;, &lt;code&gt;__STDC_CONSTANT_MACROS&lt;/code&gt; or &lt;code&gt;__STDC_FORMAT_MACROS&lt;/code&gt; (respectively) are defined before including the relevant C header (&lt;code&gt;stdint.h&lt;/code&gt; or &lt;code&gt;inttypes.h&lt;/code&gt;). This recommendation was not adopted by any C++ standard and was removed in C11. However, some implementations (such as glibc 2.17) try to apply this rule, and it may be necessary to define the &lt;code&gt;__STDC&lt;/code&gt; macros; C++ compilers may try to work around this by automatically defining them in some circumstances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1875a6ffd723ddc8488fac7c4fd4bb1c70e58c7" translate="yes" xml:space="preserve">
          <source>The Containers library is a generic collection of class templates and algorithms that allow programmers to easily implement common data structures like queues, lists and stacks. There are three classes of containers -- sequence containers, associative containers, and unordered associative containers -- each of which is designed to support a different set of operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="375fce85970054ab82a9ff1b316f12d60649e4d2" translate="yes" xml:space="preserve">
          <source>The Filesystem library provides facilities for performing operations on file systems and their components, such as paths, regular files, and directories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a686aa5105100888fccb4fa37b5d32b1bb8131e" translate="yes" xml:space="preserve">
          <source>The GCC flag &quot;-fcx-limited-range&quot; (included by &quot;-ffast-math&quot;) changes the behavior of complex multiply/division by removing checks for floating point edge cases. This impacts loop vectorization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8074f7033d870355bda79f918df527e49c8242e" translate="yes" xml:space="preserve">
          <source>The GNU implementation does not set &lt;code&gt;errno&lt;/code&gt; regardless of &lt;code&gt;math_errhandling&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45f5bf99aae73a16cde460248e85a7f247bf09d8" translate="yes" xml:space="preserve">
          <source>The Hermite polynomials are the polynomial solutions of the equation u,,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="092e83a5c399ab499607c9303ca6334373b3d256" translate="yes" xml:space="preserve">
          <source>The I/O manipulator &lt;code&gt;&lt;a href=&quot;../../io/manip/get_money&quot;&gt;std::get_money&lt;/a&gt;&lt;/code&gt; offers a simpler interface to this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9281aeb716927d1d5830d84161987fd2ba2a83b8" translate="yes" xml:space="preserve">
          <source>The I/O manipulator &lt;code&gt;&lt;a href=&quot;../manip/ws&quot;&gt;std::ws&lt;/a&gt;&lt;/code&gt;, if it reaches the end of the stream while consuming whitespace (but, unlike the formatted input sentry, it does not set &lt;code&gt;failbit&lt;/code&gt; in this case)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cae64dc315ceedbcf629806178c5dfee8ef5b63" translate="yes" xml:space="preserve">
          <source>The I/O stream function &lt;a href=&quot;../basic_istream/putback&quot;&gt;&lt;code&gt;basic_istream::putback&lt;/code&gt;&lt;/a&gt; is implemented in terms of this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39d7fe0b74278434911b1c661010e64ceaad4782" translate="yes" xml:space="preserve">
          <source>The I/O stream function &lt;a href=&quot;../basic_istream/unget&quot;&gt;&lt;code&gt;basic_istream::unget&lt;/code&gt;&lt;/a&gt; is implemented in terms of this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="187b46348f3fb61e44d273bc8c245c052215a7b7" translate="yes" xml:space="preserve">
          <source>The I/O stream objects &lt;code&gt;&lt;a href=&quot;basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;, as well as all objects derived from them (&lt;code&gt;&lt;a href=&quot;basic_ofstream&quot;&gt;std::ofstream&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;basic_stringstream&quot;&gt;std::stringstream&lt;/a&gt;&lt;/code&gt;, etc), are implemented entirely in terms of &lt;code&gt;std::basic_streambuf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="234938443728dc9d7125d6292e796aa03d968ac4" translate="yes" xml:space="preserve">
          <source>The IEEE floating-point remainder of the division operation &lt;code&gt;x/y&lt;/code&gt; calculated by this function is exactly the value &lt;code&gt;x - n*y&lt;/code&gt;, where the value &lt;code&gt;n&lt;/code&gt; is the integral value nearest the exact value &lt;code&gt;x/y&lt;/code&gt;. When |n-x/y| = &amp;frac12;, the value &lt;code&gt;n&lt;/code&gt; is chosen to be even.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bd42feee39816a2ee87bbe7649ebf6a7a843b59" translate="yes" xml:space="preserve">
          <source>The ISO C++ language standard does not require the compilers to support any pragmas. However, several non-standard pragmas are supported by multiple implementations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45d880ebb358a8cd4be3fa1496f29c34a4f3baeb" translate="yes" xml:space="preserve">
          <source>The Laguerre polynomials are the polynomial solutions of the equation xy,,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92d3f731dc95a519a499ea6ab412b29f1b0d8f74" translate="yes" xml:space="preserve">
          <source>The Mathematical Special Functions library was originally part of Library TR1 ISO/IEC TR 19768:2007, then published as an independent ISO standard, ISO/IEC 29124:2010, and finally merged to ISO C++ as of C++17.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8ec2b4252a83835e14c1e7646bcf468077a9b9f" translate="yes" xml:space="preserve">
          <source>The POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/clock_getres.html&quot;&gt;clock_gettime(CLOCK_REALTIME, ts)&lt;/a&gt; may also be used to populate a &lt;code&gt;std::timespec&lt;/code&gt; with the time since the Epoch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a9eb1a54a47019935774d069af9e7242497fee5" translate="yes" xml:space="preserve">
          <source>The Promise type is determined by the compiler from the return type of the coroutine using &lt;code&gt;std::coroutine_traits&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82ffea0821c074edc08abd9ba5cab6f4451a0c94" translate="yes" xml:space="preserve">
          <source>The UTC equivalent of &lt;code&gt;tp&lt;/code&gt; according to the rules of this time zone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="193657644c5ee833732a5b060501afa9d523bb28" translate="yes" xml:space="preserve">
          <source>The above definition requires that the result of &lt;code&gt;std::ratio_add&amp;lt;R1, R2&amp;gt;&lt;/code&gt; be already reduced to lowest terms; for example, &lt;code&gt;std::ratio_add&amp;lt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;1, 3&amp;gt;, &lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;1, 6&amp;gt;&amp;gt;&lt;/code&gt; is the same type as &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;1, 2&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23bee8585a3cc592fe0e1d9255e72f13d3dba2ab" translate="yes" xml:space="preserve">
          <source>The above definition requires that the result of &lt;code&gt;std::ratio_divide&amp;lt;R1, R2&amp;gt;&lt;/code&gt; be already reduced to lowest terms; for example, &lt;code&gt;std::ratio_divide&amp;lt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;1, 12&amp;gt;, &lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;1, 6&amp;gt;&amp;gt;&lt;/code&gt; is the same type as &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;1, 2&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7967282b7690ce10ae090be67d8a3935e530adf1" translate="yes" xml:space="preserve">
          <source>The above definition requires that the result of &lt;code&gt;std::ratio_multiply&amp;lt;R1, R2&amp;gt;&lt;/code&gt; be already reduced to lowest terms; for example, &lt;code&gt;std::ratio_multiply&amp;lt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;1, 6&amp;gt;, &lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;4, 5&amp;gt;&amp;gt;&lt;/code&gt; is the same type as &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;2, 15&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9896527cafdbbeacf853f6f95e1e7fc464c2579" translate="yes" xml:space="preserve">
          <source>The above definition requires that the result of &lt;code&gt;std::ratio_subtract&amp;lt;R1, R2&amp;gt;&lt;/code&gt; be already reduced to lowest terms; for example, &lt;code&gt;std::ratio_subtract&amp;lt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;1, 2&amp;gt;, &lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;1, 6&amp;gt;&amp;gt;&lt;/code&gt; is the same type as &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;1, 3&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6568dd4bee0354c7a7d990d9fa61c5ac047fa7c2" translate="yes" xml:space="preserve">
          <source>The above example defines a function similar to &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::printf&lt;/a&gt;&lt;/code&gt;, that replace each occurrence of the character % in the format string with a value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="673689d4371938b6b75dd6a80d2ed08e06191c09" translate="yes" xml:space="preserve">
          <source>The above requirements make it possible to compare &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt;'s iterators and const_iterators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13d09dc3f8ca032e8d2bc9d35592ce1dc3be4e55" translate="yes" xml:space="preserve">
          <source>The above rules apply to pointers as well (binding a reference to virtual base is replaced by implicit conversion to a pointer to virtual base), with two additional rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f952896411170dfd5fc7f72e86070ffe524d617b" translate="yes" xml:space="preserve">
          <source>The above rules imply that LegacyRandomAccessIterator also implements &lt;a href=&quot;lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee13435b654a2d72d3e32f79eb5a6c87ce8ef606" translate="yes" xml:space="preserve">
          <source>The above syntax produces code equivalent to the following (&lt;b&gt;&lt;code&gt;__range&lt;/code&gt;&lt;/b&gt;, &lt;b&gt;&lt;code&gt;__begin&lt;/code&gt;&lt;/b&gt; and &lt;b&gt;&lt;code&gt;__end&lt;/code&gt;&lt;/b&gt; are for exposition only):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b89b4d6624b7e332138a5ba2c5eb8e3386c894a" translate="yes" xml:space="preserve">
          <source>The above syntax produces code equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1488e3e1725ba2ff4aa290f686cae3ecf80e21d5" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;n&lt;/code&gt; (i.e. &lt;code&gt;|n|&lt;/code&gt;), if it is representable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89d1536a638b1783251f3fd22ff06e9dcd2eddad" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;n&lt;/code&gt; must be within the range of representable values of &lt;code&gt;difference_type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68f35b30bcbca2a2334fe59e8dc3c3799211505f" translate="yes" xml:space="preserve">
          <source>The accessor &lt;code&gt;get_allocator()&lt;/code&gt; obtains a copy of the allocator that was used to construct the container or installed by the most recent allocator replacement operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="248f185c6f7dd3faa7f112b79d90246cce8de025" translate="yes" xml:space="preserve">
          <source>The actual address of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ba8439aff56e6d0648a49f1a69361b2accd1241" translate="yes" xml:space="preserve">
          <source>The actual catalog location is implementation-defined: for the catalog &lt;code&gt;&quot;sed&quot;&lt;/code&gt; (message catalogs installed with the Unix utility &lt;code&gt;'sed'&lt;/code&gt;) in German locale, for example, the file opened by this function call may be &lt;code&gt;/usr/lib/nls/msg/de_DE/sed.cat&lt;/code&gt;, &lt;code&gt;/usr/lib/locale/de_DE/LC_MESSAGES/sed.cat&lt;/code&gt;, or &lt;code&gt;/usr/share/locale/de/LC_MESSAGES/sed.mo&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49de6cda744aa686d13f772c6d9cb13603ef64e6" translate="yes" xml:space="preserve">
          <source>The actual hash functions are implementation-dependent and are not required to fulfill any other quality criteria except those specified above. Notably, some implementations use trivial (identity) hash functions which map an integer to itself. In other words, these hash functions are designed to work with unordered associative containers, but not as cryptographic hashes, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a33d76aa419c87cdb7499801f1438c727323ce4c" translate="yes" xml:space="preserve">
          <source>The address of a static member function may be stored in a regular &lt;a href=&quot;pointer#Pointers_to_functions&quot;&gt;pointer to function&lt;/a&gt;, but not in a &lt;a href=&quot;pointer#Pointers_to_member_functions&quot;&gt;pointer to member function&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46a1f41e08509f4ba5888588f4190bd93cace159" translate="yes" xml:space="preserve">
          <source>The address-of operator expressions have the form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07473e470460f5d5bae4943e056fd9640065fcdf" translate="yes" xml:space="preserve">
          <source>The address-of operator, &lt;code&gt;operator&amp;amp;&lt;/code&gt;. If the unary &amp;amp; is applied to an lvalue of incomplete type and the complete type declares an overloaded &lt;code&gt;operator&amp;amp;&lt;/code&gt;, the behavior is undefined(until C++11) it is unspecified whether the operator has the built-in meaning or the operator function is called(since C++11). Because this operator may be overloaded, generic libraries use &lt;code&gt;&lt;a href=&quot;../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;&lt;/code&gt; to obtain addresses of objects of user-defined types. The best known example of a canonical overloaded operator&amp;amp; is the Microsoft class &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/31k6d0k7(v=vs.140).aspx&quot;&gt;CComPtr&lt;/a&gt;. An example of its use in EDSL can be found in &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/spirit/doc/html/spirit/qi/reference/operator/and_predicate.html&quot;&gt;boost.spirit&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e6e05504e8bf834074fc272ad4977ce0312c5b" translate="yes" xml:space="preserve">
          <source>The adjusted value of &lt;code&gt;ptr&lt;/code&gt;, or null pointer value if the space provided is too small.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ba619de076192371e302cacb5d006589d46013e" translate="yes" xml:space="preserve">
          <source>The adjustment flag is obtained as if by &lt;code&gt;std::fmtflags adjustfield = (flags &amp;amp; (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::adjustfield&lt;/a&gt;))&lt;/code&gt; and examined to identify padding location, as follows</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="926f65c8bd0c6d1333036efaf176755bf09a15fc" translate="yes" xml:space="preserve">
          <source>The algorithm is stable (preserves the relative order of the selected elements) only if &lt;code&gt;PopulationIterator&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1563a53b10adbf5f25802b7bd384fbe70e9e0ee" translate="yes" xml:space="preserve">
          <source>The algorithm used is typically &lt;a href=&quot;https://en.wikipedia.org/wiki/Introselect&quot;&gt;introselect&lt;/a&gt; although other &lt;a href=&quot;https://en.wikipedia.org/wiki/Selection_algorithm&quot;&gt;selection algorithms&lt;/a&gt; with suitable average-case complexity are allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae39cc0aa4f0b72a9e3acc6a7ed0ccc5705bbfb5" translate="yes" xml:space="preserve">
          <source>The algorithms library defines functions for a variety of purposes (e.g. searching, sorting, counting, manipulating) that operate on ranges of elements. Note that a range is defined as &lt;code&gt;[first, last)&lt;/code&gt; where &lt;code&gt;last&lt;/code&gt; refers to the element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22069e3480b3c9b1c4947adb5070a312d1235611" translate="yes" xml:space="preserve">
          <source>The alias template &lt;code&gt;std::ratio_add&lt;/code&gt; denotes the result of adding two exact rational fractions represented by the &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; specializations &lt;code&gt;R1&lt;/code&gt; and &lt;code&gt;R2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fc9398a20f036593956ab3dbbede1771345f9e1" translate="yes" xml:space="preserve">
          <source>The alias template &lt;code&gt;std::ratio_divide&lt;/code&gt; denotes the result of dividing two exact rational fractions represented by the &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; specializations &lt;code&gt;R1&lt;/code&gt; and &lt;code&gt;R2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dee97ce6a58d133cf337086f34c62b2e6a147bd9" translate="yes" xml:space="preserve">
          <source>The alias template &lt;code&gt;std::ratio_multiply&lt;/code&gt; denotes the result of multiplying two exact rational fractions represented by the &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; specializations &lt;code&gt;R1&lt;/code&gt; and &lt;code&gt;R2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62bf1af23a1c024978417eae0034999b5ac1bd02" translate="yes" xml:space="preserve">
          <source>The alias template &lt;code&gt;std::ratio_subtract&lt;/code&gt; denotes the result of subtracting two exact rational fractions represented by the &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; specializations &lt;code&gt;R1&lt;/code&gt; and &lt;code&gt;R2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4377573b03e0c1dad62c68a8a05177fc20b8746c" translate="yes" xml:space="preserve">
          <source>The allocator to use by the copy-constructed standard containers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c4781cc2700c28248cc1a31d718fc4fde15e2a7" translate="yes" xml:space="preserve">
          <source>The alternatives to the pImpl idiom are.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b7b590e1cbea82e6b155f3de6c58aad7b88034" translate="yes" xml:space="preserve">
          <source>The amount of 32-bit integers copied by &lt;code&gt;param&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29000d5dd09096c4a0e5e6f79a569175406a28de" translate="yes" xml:space="preserve">
          <source>The amount of time between this &lt;code&gt;time_point&lt;/code&gt; and the &lt;code&gt;clock&lt;/code&gt;'s epoch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="781837e5b78f423a72b4bc7bbfde9fb961de52a5" translate="yes" xml:space="preserve">
          <source>The apparent size of the pushback buffer may be larger if the character that is pushed back equals the character existing at that location in the external character sequence (the implementation may simply decrement the read file position indicator and avoid maintaining a pushback buffer).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="755a5a48206440558fe0aeebdc09b4c90a71a37f" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;n&lt;/code&gt; must be equal to the first argument of the call to &lt;code&gt;&lt;a href=&quot;allocate&quot;&gt;allocate()&lt;/a&gt;&lt;/code&gt; that originally produced &lt;code&gt;p&lt;/code&gt;; otherwise, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed300236670f94b994460867ddba4af778962013" translate="yes" xml:space="preserve">
          <source>The argument is first converted to &lt;code&gt;unsigned char&lt;/code&gt;. If the &lt;b&gt;l&lt;/b&gt; modifier is used, the argument is first converted to a character string as if by &lt;b&gt;%ls&lt;/b&gt; with a &lt;code&gt;wchar_t[2]&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e173a96999867556e8be948298df40ea6171ebef" translate="yes" xml:space="preserve">
          <source>The argument is first converted to &lt;code&gt;wchar_t&lt;/code&gt; as if by calling &lt;code&gt;btowc&lt;/code&gt;. If the &lt;b&gt;l&lt;/b&gt; modifier is used, the &lt;code&gt;wint_t&lt;/code&gt; argument is first converted to &lt;code&gt;wchar_t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21f94c3f9702cceebf7320693c46bd6df0e894dd" translate="yes" xml:space="preserve">
          <source>The argument list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ff8f0382d945790b4abb92eaf3d7bab75f243ba" translate="yes" xml:space="preserve">
          <source>The argument must be a pointer to the initial element of a character array containing a multibyte character sequence beginning in the initial shift state, which is converted to wide character array as if by a call to &lt;code&gt;mbrtowc&lt;/code&gt; with zero-initialized conversion state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a03b5940fa2b2b9a645f3d15e3a9855662e07fb" translate="yes" xml:space="preserve">
          <source>The argument must be a pointer to the initial element of an array of characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="939cc9bc79190c70cc6b243a0d3d41e818910280" translate="yes" xml:space="preserve">
          <source>The argument-parameter implicit conversion sequences considered by overload resolution correspond to &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversions&lt;/a&gt; used in &lt;a href=&quot;copy_initialization&quot;&gt;copy initialization&lt;/a&gt; (for non-reference parameters), except that when considering conversion to the implicit object parameter or to the left-hand side of assignment operator, conversions that create temporary objects are not considered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adaf20221647bf5f016df161d3227931e72c0e0a" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;code&gt;std::bind_front&lt;/code&gt; are copied or moved, and are never passed by reference unless wrapped in &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d29b07ff6f09d0235dd01cb74baba1369ae91983" translate="yes" xml:space="preserve">
          <source>The arguments to bind are copied or moved, and are never passed by reference unless wrapped in &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16183ca09e08051a6a498c1b8e176b39fe04556e" translate="yes" xml:space="preserve">
          <source>The arguments to the thread function are moved or copied by value. If a reference argument needs to be passed to the thread function, it has to be wrapped (e.g. with &lt;code&gt;&lt;a href=&quot;../../utility/functional/ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../utility/functional/ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30dd24a9b07849107ca8c554f4f6d40ca611c92d" translate="yes" xml:space="preserve">
          <source>The array is initialized as in &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate initialization&lt;/a&gt;, except that narrowing conversions are allowed and any elements without an initializer are &lt;a href=&quot;value_initialization&quot;&gt;value-initialized&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52bcb2ba93527988f88f98602d063b00271dc8bb" translate="yes" xml:space="preserve">
          <source>The arrays may overlap: copying takes place as if the wide characters were copied to a temporary wide character array and then copied from the temporary array to &lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1ce22bddbd5afcd8d2b9975482c42ad2a4cf0c6" translate="yes" xml:space="preserve">
          <source>The as-if rule</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d858c67cf82093a6f8fd583515b76052a6e02bc9" translate="yes" xml:space="preserve">
          <source>The assignment operator (&lt;code&gt;operator=&lt;/code&gt;) has special properties: see &lt;a href=&quot;as_operator&quot;&gt;copy assignment&lt;/a&gt; and &lt;a href=&quot;move_operator&quot;&gt;move assignment&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c5d518628da2787a486bdb9a3bf4a44f60ddd55" translate="yes" xml:space="preserve">
          <source>The associated Laguerre polynomials are the polynomial solutions of the equation \(x\ddot{y} + (m+1-x)\dot{y} + ny = 0\)xy,,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc4b473d4edca4fe8545285d21ee1d98e8fe3d3e" translate="yes" xml:space="preserve">
          <source>The associated allocator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9448faeee2cd31ccafe96e60d57e87c5096f2e84" translate="yes" xml:space="preserve">
          <source>The associated file stream or &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; if an error has occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4048a32e4d36e4b4a7b6ceb3bdafa2370c883fb3" translate="yes" xml:space="preserve">
          <source>The associated locale is the value supplied to &lt;code&gt;&lt;a href=&quot;pubimbue&quot;&gt;pubimbue()&lt;/a&gt;&lt;/code&gt; on the last call, or, if that function has not been called, the value of the global locale (&lt;code&gt;&lt;a href=&quot;../../locale/locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt;) at the time of the construction of the streambuf.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02393976fc180c9b25d5d69be609960418d8ef30" translate="yes" xml:space="preserve">
          <source>The associated locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8552825362c8523a19e9943122503974571d213a" translate="yes" xml:space="preserve">
          <source>The associated stream buffer, or a null pointer if there was no associated stream buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0783a046d6d1ff8d52f71c9b805d9b58a80c4a97" translate="yes" xml:space="preserve">
          <source>The atomic library provides components for fine-grained atomic operations allowing for lockless concurrent programming. Each atomic operation is indivisible with regards to any other atomic operation that involves the same object. Atomic objects are &lt;a href=&quot;language/memory_model#Threads_and_data_races&quot;&gt;free of data races&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4adeb68c9c4013712d2aed1000d4e09e476ea64d" translate="yes" xml:space="preserve">
          <source>The attribute &lt;code&gt;[[&lt;a href=&quot;attributes/optimize_for_synchronized&quot;&gt;optimize_for_synchronized&lt;/a&gt;]]&lt;/code&gt; may be applied to a declarator in a function declaration and must appear on the first declaration of the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fd36a46bb2322c1e7d69551538bc1d5955fdf0c" translate="yes" xml:space="preserve">
          <source>The attribute-preserving overload (2) is implicitly invoked by &lt;a href=&quot;copy&quot;&gt;&lt;code&gt;copy()&lt;/code&gt;&lt;/a&gt; when recursively copying directories. Its equivalent in boost.filesystem is &lt;a href=&quot;http://www.boost.org/doc/libs/1_57_0/libs/filesystem/doc/reference.html#copy_directory&quot;&gt;&lt;code&gt;copy_directory&lt;/code&gt;&lt;/a&gt; (with argument order reversed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d41955e8d96bded47f8643f2387d18f9f92f90a5" translate="yes" xml:space="preserve">
          <source>The badbit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1b04e88b5ddc8259deb4bd09406ff0efc4d0c5e" translate="yes" xml:space="preserve">
          <source>The badbit is set by the following standard library functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1951bf526d104734daee9af96f8ae5f5577df89d" translate="yes" xml:space="preserve">
          <source>The base class &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; implements character classification equivalent to the minimal &quot;C&quot; locale. The classification rules can be extended or modified if constructed with a non-default classification table argument, if constructed as &lt;code&gt;&lt;a href=&quot;ctype_byname&quot;&gt;std::ctype_byname&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; or as a user-defined derived facet. All &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; formatted input functions are required to use &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; for character classing during input parsing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23d729a8cc94f8c0414114c9a60e8acd1fc12d06" translate="yes" xml:space="preserve">
          <source>The base class version of the function calls &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; and increments &lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="201321ed2284d9de663a5a09379bb0e53b45a031" translate="yes" xml:space="preserve">
          <source>The base class version of the function does nothing. The derived classes may override this function to allow updates to the get area in the case of exhaustion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5380a7aca03357fb4bf7ea909e5b04af5dad0cc" translate="yes" xml:space="preserve">
          <source>The base class version of the function does nothing. The derived classes may override this function to allow updates to the put area in the case of exhaustion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00b20c8c1673e69db511f9701832d81f1b9b3c9b" translate="yes" xml:space="preserve">
          <source>The base class version of the function returns &lt;code&gt;Traits::eof()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a068b851e69253d7268cdd6863af11c37cbd0d3a" translate="yes" xml:space="preserve">
          <source>The base class version of the function returns &lt;code&gt;traits::eof()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
