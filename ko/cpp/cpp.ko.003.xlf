<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="83e96277b15c59a851a3ca3405a7f46623d32426" translate="yes" xml:space="preserve">
          <source>1) scalar types declared without initializers</source>
          <target state="translated">1) 이니셜 라이저없이 선언 된 스칼라 유형</target>
        </trans-unit>
        <trans-unit id="5fbae28274dd530b6fe0562330d8e1c26a0e7e48" translate="yes" xml:space="preserve">
          <source>1) see &lt;a href=&quot;declarations&quot;&gt;Declarations&lt;/a&gt; and &lt;a href=&quot;initialization&quot;&gt;Initialization&lt;/a&gt; for details.</source>
          <target state="translated">1) 자세한 내용은 &lt;a href=&quot;declarations&quot;&gt;선언&lt;/a&gt; 및 &lt;a href=&quot;initialization&quot;&gt;초기화&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e8c069373920916dd3ee6c31847cff56a5a257c3" translate="yes" xml:space="preserve">
          <source>1) see &lt;a href=&quot;try_catch&quot;&gt;try/catch&lt;/a&gt; for details.</source>
          <target state="translated">1) 자세한 내용은 &lt;a href=&quot;try_catch&quot;&gt;try / catch&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b0de531dc013da0a3431deb5c306eb6732da49c1" translate="yes" xml:space="preserve">
          <source>1) sets the &lt;code&gt;adjustfield&lt;/code&gt; of the stream &lt;code&gt;str&lt;/code&gt; to &lt;code&gt;left&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::left&lt;/a&gt;, &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::adjustfield&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::left&lt;/a&gt;, &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::adjustfield&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: left&lt;/a&gt; , &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: adjustfield&lt;/a&gt; ) 를 호출 하여 스트림 &lt;code&gt;str&lt;/code&gt; 의 &lt;code&gt;adjustfield&lt;/code&gt; 를 &lt;code&gt;left&lt;/code&gt; 으로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="959f06dad13437bf4d815a47356516ee39d6f2ca" translate="yes" xml:space="preserve">
          <source>1) sets the &lt;code&gt;basefield&lt;/code&gt; of the stream &lt;code&gt;str&lt;/code&gt; to &lt;code&gt;dec&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::dec&lt;/a&gt;, &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::basefield&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">1) 설정 &lt;code&gt;basefield&lt;/code&gt; 스트림의 &lt;code&gt;str&lt;/code&gt; 에 &lt;code&gt;dec&lt;/code&gt; 것처럼 호출 &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::dec&lt;/a&gt;, &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::basefield&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d373f785b52f8a1eefd786df68b9bb8172a0848" translate="yes" xml:space="preserve">
          <source>1) sets the input position indicator to absolute (relative to the beginning of the file) value &lt;code&gt;pos&lt;/code&gt;. Specifically, executes &lt;code&gt;rdbuf()-&amp;gt;pubseekpos(pos, &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">1) 입력 위치 표시기를 절대 (파일의 시작과 관련하여) 값 &lt;code&gt;pos&lt;/code&gt; 로 설정 합니다. 특히 &lt;code&gt;rdbuf()-&amp;gt;pubseekpos(pos, &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="7a37e8eae329813693dbb66fb433b1378bbc646f" translate="yes" xml:space="preserve">
          <source>1) sets the output position indicator to absolute (relative to the beginning of the file) value &lt;code&gt;pos&lt;/code&gt; by calling &lt;code&gt;rdbuf()-&amp;gt;pubseekpos(pos, &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;)&lt;/code&gt;. If the call returns &lt;code&gt;(pos_type)-1&lt;/code&gt;, executes &lt;code&gt;setstate(failbit)&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;rdbuf()-&amp;gt;pubseekpos(pos, &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../ios_base/openmode&quot;&gt;std :: ios_base :: out&lt;/a&gt; ) 을 호출 하여 출력 위치 표시기를 절대 (파일 시작에 상대적인) 값 &lt;code&gt;pos&lt;/code&gt; 로 설정 합니다. 호출이 &lt;code&gt;(pos_type)-1&lt;/code&gt; 을 반환 하면 &lt;code&gt;setstate(failbit)&lt;/code&gt; 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="f0075c4e1b7f5724068c79538f84e26e02998c16" translate="yes" xml:space="preserve">
          <source>1) simple attribute, such as &lt;code&gt;[[noreturn]]&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;[[noreturn]]&lt;/code&gt; 과 같은 간단한 속성</target>
        </trans-unit>
        <trans-unit id="4bd12039d920f940200cafbd8fd1456bfeeb7684" translate="yes" xml:space="preserve">
          <source>1) simple by-copy capture</source>
          <target state="translated">1) 간단한 바이 카피 캡처</target>
        </trans-unit>
        <trans-unit id="e01f406b267b9b5466474789fb0b23abba2a2d64" translate="yes" xml:space="preserve">
          <source>1) state information: stream status flags</source>
          <target state="translated">1) 상태 정보 : 스트림 상태 플래그</target>
        </trans-unit>
        <trans-unit id="31e4b1cc63031212773142438400b483d2991696" translate="yes" xml:space="preserve">
          <source>1) string &lt;code&gt;str&lt;/code&gt;;</source>
          <target state="translated">1) 문자열 &lt;code&gt;str&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="0a3fc1d006f0427220c46dd8585fa3eacb4445de" translate="yes" xml:space="preserve">
          <source>1) target for &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;;</source>
          <target state="translated">1) &lt;a href=&quot;goto&quot;&gt;goto의&lt;/a&gt; 목표 ;</target>
        </trans-unit>
        <trans-unit id="f613a348a0dc7711ea752d541e46fbad05ec42f1" translate="yes" xml:space="preserve">
          <source>1) the current underlying byte stream.</source>
          <target state="translated">1) 현재의 기본 바이트 스트림</target>
        </trans-unit>
        <trans-unit id="24fce0f8e5f5ac3309c23b6ab6823b8ed7927bf3" translate="yes" xml:space="preserve">
          <source>1) the current value of the fpos state</source>
          <target state="translated">1) fpos 상태의 현재 값</target>
        </trans-unit>
        <trans-unit id="f3ae2d65368e9909909e1f1a14ff91130a514032" translate="yes" xml:space="preserve">
          <source>1) the dynamic version of the initialization does not change the value of any other object of namespace scope prior to its initialization</source>
          <target state="translated">1) 초기화의 동적 버전은 초기화 전에 네임 스페이스 범위의 다른 객체의 값을 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1dedb5569af9fadbb5bb2f82e3fcb0037d9182db" translate="yes" xml:space="preserve">
          <source>1) the exception thrown by &lt;code&gt;std::unexpected_handler&lt;/code&gt; satisfies the dynamic exception specification that was violated earlier. The new exception is allowed to escape the function and stack unwinding continues.</source>
          <target state="translated">1) &lt;code&gt;std::unexpected_handler&lt;/code&gt; 의해 발생 된 예외는 이전에 위반 된 동적 예외 스펙을 충족시킵니다. 새로운 예외는 함수에서 벗어날 수 있으며 스택 해제가 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="f805e4e11f28575295eb75951779a280c4959dca" translate="yes" xml:space="preserve">
          <source>1) the extracted character or &lt;code&gt;Traits::eof()&lt;/code&gt;</source>
          <target state="translated">1) 추출 된 문자 또는 &lt;code&gt;Traits::eof()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="576040b76aa84b23cfb03d0ffbf1bcda749976fe" translate="yes" xml:space="preserve">
          <source>1) the integral number of hours &lt;code&gt;since_midnight&lt;/code&gt; is after 00:00:00.</source>
          <target state="translated">1) &lt;code&gt;since_midnight&lt;/code&gt; 의 정수 시간 은 00:00:00 이후입니다.</target>
        </trans-unit>
        <trans-unit id="0ea6b5ba02b337404f322be7ccbbc58c10057dfc" translate="yes" xml:space="preserve">
          <source>1) the prefix is a string view (which may be a result of implicit conversion from another &lt;code&gt;std::basic_string&lt;/code&gt;)</source>
          <target state="translated">1) 접두사는 문자열보기입니다 (다른 &lt;code&gt;std::basic_string&lt;/code&gt; 에서 암시 적 변환의 결과 일 수 있음 )</target>
        </trans-unit>
        <trans-unit id="e07b840b01b0ff29800f0ed960b9474783ca7f78" translate="yes" xml:space="preserve">
          <source>1) the prefix is a string view. Effectively returns &lt;code&gt;size() &amp;gt;= x.size() &amp;amp;&amp;amp; compare(0, x.size(), x) == 0&lt;/code&gt;</source>
          <target state="translated">1) 접두사는 문자열보기입니다. 효과적으로 &lt;code&gt;size() &amp;gt;= x.size() &amp;amp;&amp;amp; compare(0, x.size(), x) == 0&lt;/code&gt; 반환합니다.</target>
        </trans-unit>
        <trans-unit id="37a31f5cd88870991c69e0885e96d383853c87b1" translate="yes" xml:space="preserve">
          <source>1) the single total order is consistent with the</source>
          <target state="translated">1) 단일 총 주문은</target>
        </trans-unit>
        <trans-unit id="9d3e1117baa662477e6f6d9a0ccae6ec3275fedd" translate="yes" xml:space="preserve">
          <source>1) the suffix is a string view (which may be a result of implicit conversion from another &lt;code&gt;std::basic_string&lt;/code&gt;)</source>
          <target state="translated">1) 접미사는 문자열보기입니다 (다른 &lt;code&gt;std::basic_string&lt;/code&gt; 에서 암시 적 변환의 결과 일 수 있음 )</target>
        </trans-unit>
        <trans-unit id="1334d1c0669a8b1ed5e85c99f4a1cd5ddba453c3" translate="yes" xml:space="preserve">
          <source>1) the suffix is a string view. Effectively returns &lt;code&gt;size() &amp;gt;= x.size() &amp;amp;&amp;amp; compare(size() - x.size(), npos, x) == 0&lt;/code&gt;</source>
          <target state="translated">1) 접미사는 문자열보기입니다. 효과적으로 &lt;code&gt;size() &amp;gt;= x.size() &amp;amp;&amp;amp; compare(size() - x.size(), npos, x) == 0&lt;/code&gt; 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dd67b4b6b20306ddb91c8104e36ef24037b848ee" translate="yes" xml:space="preserve">
          <source>1) the value of the requested bit.</source>
          <target state="translated">1) 요청 된 비트의 값.</target>
        </trans-unit>
        <trans-unit id="f57efa565ec9f4c7e76e377c0b36cbb693c076ef" translate="yes" xml:space="preserve">
          <source>1) there is at least one argument of F1 whose implicit conversion is</source>
          <target state="translated">1) 암시 적 변환이 F1의 인수가 하나 이상 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b98204244a69b3c9480c35bdf6abc7ae2000f83" translate="yes" xml:space="preserve">
          <source>1) unary plus (promotion).</source>
          <target state="translated">1) 단항 플러스 (프로모션).</target>
        </trans-unit>
        <trans-unit id="9fe85fe12b6ef1d27afcec1e75cd9539938184fd" translate="yes" xml:space="preserve">
          <source>1) unary right fold</source>
          <target state="translated">1) 단항 우중</target>
        </trans-unit>
        <trans-unit id="4171418d80b04350c113c84d7d0732b36d340618" translate="yes" xml:space="preserve">
          <source>1) user-defined conversions cannot be applied to the implicit object parameter</source>
          <target state="translated">1) 암시 적 개체 매개 변수에 사용자 정의 변환을 적용 할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="038138e32ac255c9f236519d04e70e59ffceaaf7" translate="yes" xml:space="preserve">
          <source>1) when a named variable (automatic, static, or thread-local) of a non-reference type &lt;code&gt;T&lt;/code&gt; is declared with the initializer consisting of an equals sign followed by an expression.</source>
          <target state="translated">1) 비 참조 유형 &lt;code&gt;T&lt;/code&gt; 의 명명 된 변수 (자동, 정적 또는 스레드 로컬)가 등호로 구성된 초기화 프로그램과 표현식으로 선언 된 경우.</target>
        </trans-unit>
        <trans-unit id="01e470bd84176cbf057dce6dc845ba7099a0ed13" translate="yes" xml:space="preserve">
          <source>1) when a variable with automatic, static, or thread-local &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; is declared with no initializer;</source>
          <target state="translated">1) 자동, 정적 또는 스레드 로컬 &lt;a href=&quot;storage_duration&quot;&gt;저장 기간을&lt;/a&gt; 갖는 변수가 이니셜 라이저없이 선언 된 경우</target>
        </trans-unit>
        <trans-unit id="513391e651ce5f5a57a36c169e5f5eff42bd64fa" translate="yes" xml:space="preserve">
          <source>1) zero or one</source>
          <target state="translated">1) 0 또는 1</target>
        </trans-unit>
        <trans-unit id="d2523081d9e25d91c42c82f3a92a3b4aa5e30876" translate="yes" xml:space="preserve">
          <source>1)&lt;a href=&quot;../../language/default_constructor&quot;&gt;Default constructor&lt;/a&gt;. Constructs empty container.</source>
          <target state="translated">1) &lt;a href=&quot;../../language/default_constructor&quot;&gt;기본 생성자&lt;/a&gt; . 빈 컨테이너를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="42a31404186c3b45f3d5b2bb2eef550983334a71" translate="yes" xml:space="preserve">
          <source>1)&lt;a href=&quot;break&quot;&gt;break&lt;/a&gt; statement;</source>
          <target state="translated">1) &lt;a href=&quot;break&quot;&gt;중단&lt;/a&gt; 진술;</target>
        </trans-unit>
        <trans-unit id="2ac4a6880eb6311a9d3c9668ae007e1c1720a346" translate="yes" xml:space="preserve">
          <source>1)&lt;a href=&quot;data_members&quot;&gt;data members&lt;/a&gt;</source>
          <target state="translated">1) &lt;a href=&quot;data_members&quot;&gt;데이터 멤버&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3947fcf8ea9e2a59d66a2877ec65979e6c918010" translate="yes" xml:space="preserve">
          <source>1)&lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; statement;</source>
          <target state="translated">1) &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; 문;</target>
        </trans-unit>
        <trans-unit id="123cd5471cc8bba2fc357b9b3069222fb6e6b7d4" translate="yes" xml:space="preserve">
          <source>1)&lt;a href=&quot;initialization&quot;&gt;initializer&lt;/a&gt; in a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; of an object or &lt;a href=&quot;reference_initialization&quot;&gt;reference&lt;/a&gt;</source>
          <target state="translated">1) &lt;a href=&quot;initialization&quot;&gt;초기화&lt;/a&gt; A의 &lt;a href=&quot;declarations&quot;&gt;선언&lt;/a&gt; 객체 또는 &lt;a href=&quot;reference_initialization&quot;&gt;기준&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="62e7e1ba63b94f319c93d7847c75e3ccb6365664" translate="yes" xml:space="preserve">
          <source>1)&lt;a href=&quot;namespace#Namespaces&quot;&gt;Named namespace definition&lt;/a&gt; for the namespace ns_name.</source>
          <target state="translated">1) 네임 스페이스 ns_name에 대한 &lt;a href=&quot;namespace#Namespaces&quot;&gt;명명 된 네임 스페이스 정의&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a0f8ea1a36161dcf690b50367ab188a06b44b0e" translate="yes" xml:space="preserve">
          <source>1)&lt;a href=&quot;namespace#Using-directives&quot;&gt;using-directives&lt;/a&gt; in the associated namespaces are ignored</source>
          <target state="translated">1) 관련 네임 스페이스의 &lt;a href=&quot;namespace#Using-directives&quot;&gt;사용 지시문&lt;/a&gt; 은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="645c2ea3dd089f83fe32c807d57fd2eb1f6f0b03" translate="yes" xml:space="preserve">
          <source>1)&lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; for a call to a function template specialization</source>
          <target state="translated">1) 함수 템플릿 전문화에 대한 호출에 대한 &lt;a href=&quot;overload_resolution&quot;&gt;과부하 해결&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7454f2ffa997b4b175b70b027385cbac9daedf15" translate="yes" xml:space="preserve">
          <source>1)&lt;a href=&quot;transactional_memory#Synchronized_blocks&quot;&gt;synchronized block&lt;/a&gt;, executed in single total order with all synchronized blocks; 2)&lt;a href=&quot;transactional_memory#Atomic_blocks&quot;&gt;atomic block&lt;/a&gt; that aborts on exceptions; 3)&lt;a href=&quot;transactional_memory#Atomic_blocks&quot;&gt;atomic block&lt;/a&gt; that rolls back on exceptions; 4)&lt;a href=&quot;transactional_memory#Atomic_blocks&quot;&gt;atomic block&lt;/a&gt; that commits on exceptions.</source>
          <target state="translated">1) &lt;a href=&quot;transactional_memory#Synchronized_blocks&quot;&gt;동기화 블록&lt;/a&gt; 동기화 된 모든 블록이 단일 전체 위해 실행; 2) 예외로 인해 중단되는 &lt;a href=&quot;transactional_memory#Atomic_blocks&quot;&gt;원자 블록&lt;/a&gt; ; 3) 예외를 롤백하는 &lt;a href=&quot;transactional_memory#Atomic_blocks&quot;&gt;원자 블록&lt;/a&gt; ; 4) 예외를 저지르는 &lt;a href=&quot;transactional_memory#Atomic_blocks&quot;&gt;원자 블록&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="28022ffdd30c2c81a5bf87a640ec8fc4fe17ddeb" translate="yes" xml:space="preserve">
          <source>1)&lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; loop;</source>
          <target state="translated">1) &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; 루프;</target>
        </trans-unit>
        <trans-unit id="fd76e518d01b76f60a69df2e7f190f36f9b7a006" translate="yes" xml:space="preserve">
          <source>1)&lt;b&gt;Exact match&lt;/b&gt;: no conversion required, lvalue-to-rvalue conversion, qualification conversion, function pointer conversion,(since C++17) user-defined conversion of class type to the same class</source>
          <target state="translated">1) &lt;b&gt;정확히 일치&lt;/b&gt; : 변환이 필요하지 않음, lvalue-to-rvalue 변환, 자격 변환, 함수 포인터 변환, (C ++ 17 이후) 클래스 정의를 동일한 클래스로 사용자 정의 변환</target>
        </trans-unit>
        <trans-unit id="3bfd899cee8af06499d241f0635a0876ff5b98b0" translate="yes" xml:space="preserve">
          <source>1)&lt;b&gt;Lvalue reference declarator&lt;/b&gt;: the declaration &lt;code&gt;S&amp;amp; D;&lt;/code&gt; declares &lt;code&gt;D&lt;/code&gt; as an</source>
          <target state="translated">1) &lt;b&gt;Lvalue 참조 선언자&lt;/b&gt; : 선언 &lt;code&gt;S&amp;amp; D;&lt;/code&gt; 선언 &lt;code&gt;D&lt;/code&gt; 는 int로서</target>
        </trans-unit>
        <trans-unit id="432ed2977b1ea7c7670ea5d560118095e03fcd63" translate="yes" xml:space="preserve">
          <source>1)&lt;b&gt;Pointer declarator&lt;/b&gt;: the declaration &lt;code&gt;S* D;&lt;/code&gt; declares &lt;code&gt;D&lt;/code&gt; as a pointer to the type determined by decl-specifier-seq&lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">1) &lt;b&gt;포인터 선언자&lt;/b&gt; : 선언 &lt;code&gt;S* D;&lt;/code&gt; decl-specifier-seq &lt;code&gt;S&lt;/code&gt; 에 의해 결정된 유형에 대한 포인터로 &lt;code&gt;D&lt;/code&gt; 를 선언 합니다 .</target>
        </trans-unit>
        <trans-unit id="eb6b059f4a63a3a9c0949cf5d05d872f69a20d80" translate="yes" xml:space="preserve">
          <source>1)&lt;b&gt;Write-write coherence&lt;/b&gt;: If evaluation A that modifies some atomic M (a write)</source>
          <target state="translated">1) &lt;b&gt;쓰기-쓰기 일관성&lt;/b&gt; : 원자 A를 수정하는 평가 A (쓰기)</target>
        </trans-unit>
        <trans-unit id="03366450e379696d44f0fd7e1a2ae62bc2a73494" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;&quot;C++&quot;&lt;/code&gt;, the default language linkage.</source>
          <target state="translated">1) 기본 언어 연결 인 &lt;code&gt;&quot;C++&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d052f6d426983787c1bfd4e5cd48818c6da5706c" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;&amp;amp;a == &amp;amp;b || a.is_equal(b)&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;&amp;amp;a == &amp;amp;b || a.is_equal(b)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f02a6ce77d778dab546ba04331dc429bf8654a8" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;(a[i] = q, a[i]) == q&lt;/code&gt;  For a non-const &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;(a[i] = q, a[i]) == q&lt;/code&gt; 비 const &lt;code&gt;a&lt;/code&gt; 의 경우 .</target>
        </trans-unit>
        <trans-unit id="09e0cb236fa6aa23d55aa1b83d3887effcc2cc37" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;(void)swap(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(t), &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(u))&lt;/code&gt;, if that expression is valid, where the &lt;a href=&quot;../../language/overload_resolution&quot;&gt;overload resolution&lt;/a&gt; is performed with the following candidates:</source>
          <target state="translated">1) &lt;code&gt;(void)swap(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(t), &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(u))&lt;/code&gt; , 해당 표현식이 유효한 경우 다음 후보로 &lt;a href=&quot;../../language/overload_resolution&quot;&gt;과부하 해결&lt;/a&gt; 이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="01cec9aad6c047e9ce881f6e1454ac3064c14293" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;*get()&lt;/code&gt;.</source>
          <target state="translated">1)&lt;code&gt;*get()&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="e30c397fe6c24167c8f45a27485e823b63a60cbb" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;*lhs.resource() == *rhs.resource()&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;*lhs.resource() == *rhs.resource()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9cdd9a3a66601a334d1bcc2aaf680790aebc28de" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">1)&lt;code&gt;*this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d646ebfcbfaba245f4a4682c81e76557954ac091" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">1)&lt;code&gt;*this&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="cb51f2cc941d4bd601d28a34c18f39cc991cf61d" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;index &amp;gt; size()&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; 경우 &lt;code&gt;index &amp;gt; size()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67053a8b922f09d719582c64626487c54db40ae9" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;&lt;a href=&quot;../c/fputc&quot;&gt;std::fputc&lt;/a&gt;(f, c)&lt;/code&gt; and &lt;code&gt;str.rdbuf()-&amp;gt;sputc(c)&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;../c/fputc&quot;&gt;std::fputc&lt;/a&gt;(f, c)&lt;/code&gt; 및 &lt;code&gt;str.rdbuf()-&amp;gt;sputc(c)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0b53912f339f66d7bcd1a80bf41ba3a30c00a0b5" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;&lt;a href=&quot;../cv_status&quot;&gt;std::cv_status::timeout&lt;/a&gt;&lt;/code&gt; if the absolute timeout specified by &lt;code&gt;timeout_time&lt;/code&gt; was reached, &lt;code&gt;&lt;a href=&quot;../cv_status&quot;&gt;std::cv_status::no_timeout&lt;/a&gt;&lt;/code&gt; overwise.</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;../cv_status&quot;&gt;std::cv_status::timeout&lt;/a&gt;&lt;/code&gt; &lt;code&gt;timeout_time&lt;/code&gt; 으로 지정된 절대 시간 초과 에 도달하면 &lt;code&gt;&lt;a href=&quot;../cv_status&quot;&gt;std::cv_status::no_timeout&lt;/a&gt;&lt;/code&gt; 역 으로 초과합니다 .</target>
        </trans-unit>
        <trans-unit id="84bdd3a16b9f6dc4d0452a9809ae864272b87c51" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;&lt;a href=&quot;../cv_status&quot;&gt;std::cv_status::timeout&lt;/a&gt;&lt;/code&gt; if the relative timeout specified by &lt;code&gt;rel_time&lt;/code&gt; expired, &lt;code&gt;&lt;a href=&quot;../cv_status&quot;&gt;std::cv_status::no_timeout&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;../cv_status&quot;&gt;std::cv_status::timeout&lt;/a&gt;&lt;/code&gt; 에 의해 지정된 기준으로 제한하는 경우 &lt;code&gt;rel_time&lt;/code&gt; 이 만료 &lt;code&gt;&lt;a href=&quot;../cv_status&quot;&gt;std::cv_status::no_timeout&lt;/a&gt;&lt;/code&gt; 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="843f69daa34df943e917c2525e69be7e6a44045c" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;&lt;a href=&quot;../error/runtime_error/runtime_error&quot;&gt;std::runtime_error&lt;/a&gt;&lt;/code&gt; if for any reason a reference to a &lt;code&gt;tzdb_list&lt;/code&gt; containing one or more valid &lt;code&gt;tzdb&lt;/code&gt; cannot be returned.</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;../error/runtime_error/runtime_error&quot;&gt;std::runtime_error&lt;/a&gt;&lt;/code&gt; 어떤 이유로 든 하나 이상의 유효한 &lt;code&gt;tzdb&lt;/code&gt; 를 포함 하는 &lt;code&gt;tzdb_list&lt;/code&gt; 에 대한 참조를 리턴 할 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="c301bbbc078c9c4b38ed6ece52f2548eecd8fc02" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;&lt;a href=&quot;../weekday_indexed&quot;&gt;std::chrono::weekday_indexed&lt;/a&gt;(*this, index)&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;../weekday_indexed&quot;&gt;std::chrono::weekday_indexed&lt;/a&gt;(*this, index)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eeaf3486715962e81379aa244cc38e6af7b76183" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;&lt;a href=&quot;clock_time_conversion&quot;&gt;std::chrono::clock_time_conversion&lt;/a&gt;&amp;lt;Dest, &lt;a href=&quot;system_clock&quot;&gt;std::chrono::system_clock&lt;/a&gt;&amp;gt;{}(&lt;br/&gt; &lt;a href=&quot;clock_time_conversion&quot;&gt;std::chrono::clock_time_conversion&lt;/a&gt;&amp;lt;&lt;a href=&quot;system_clock&quot;&gt;std::chrono::system_clock&lt;/a&gt;, Source&amp;gt;{}(t))&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;clock_time_conversion&quot;&gt;std::chrono::clock_time_conversion&lt;/a&gt;&amp;lt;Dest, &lt;a href=&quot;system_clock&quot;&gt;std::chrono::system_clock&lt;/a&gt;&amp;gt;{}(&lt;br/&gt; &lt;a href=&quot;clock_time_conversion&quot;&gt;std::chrono::clock_time_conversion&lt;/a&gt;&amp;lt;&lt;a href=&quot;system_clock&quot;&gt;std::chrono::system_clock&lt;/a&gt;, Source&amp;gt;{}(t))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bea05ecf394f78313562c28e02dc71dea54c733d" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;&lt;a href=&quot;clock_time_conversion&quot;&gt;std::chrono::clock_time_conversion&lt;/a&gt;&amp;lt;Dest, &lt;a href=&quot;utc_clock&quot;&gt;std::chrono::utc_clock&lt;/a&gt;&amp;gt;{}(&lt;br/&gt; &lt;p&gt;&lt;a href=&quot;clock_time_conversion&quot;&gt;std::chrono::clock_time_conversion&lt;/a&gt;&amp;lt;&lt;a href=&quot;utc_clock&quot;&gt;std::chrono::utc_clock&lt;/a&gt;, &lt;a href=&quot;system_clock&quot;&gt;std::chrono::system_clock&lt;/a&gt;&amp;gt;{}(&lt;br/&gt; &lt;a href=&quot;clock_time_conversion&quot;&gt;std::chrono::clock_time_conversion&lt;/a&gt;.&lt;/p&gt;
&amp;lt;&lt;a href=&quot;system_clock&quot;&gt;std::chrono::system_clock&lt;/a&gt;, Source&amp;gt;{}(t)))&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;clock_time_conversion&quot;&gt;std::chrono::clock_time_conversion&lt;/a&gt;&amp;lt;Dest, &lt;a href=&quot;utc_clock&quot;&gt;std::chrono::utc_clock&lt;/a&gt;&amp;gt;{}(&lt;br/&gt; &lt;p&gt;&lt;a href=&quot;clock_time_conversion&quot;&gt;std::chrono::clock_time_conversion&lt;/a&gt;&amp;lt;&lt;a href=&quot;utc_clock&quot;&gt;std::chrono::utc_clock&lt;/a&gt;, &lt;a href=&quot;system_clock&quot;&gt;std::chrono::system_clock&lt;/a&gt;&amp;gt;{}(&lt;br/&gt; &lt;a href=&quot;clock_time_conversion&quot;&gt;std::chrono::clock_time_conversion&lt;/a&gt;.&lt;/p&gt; &amp;lt;&lt;a href=&quot;system_clock&quot;&gt;std::chrono::system_clock&lt;/a&gt;, Source&amp;gt;{}(t)))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8b4e3f01795d6e4145370d10ac761915e22cd7c9" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;&lt;a href=&quot;get_id&quot;&gt;get_id()&lt;/a&gt;&lt;/code&gt; equal to &lt;code&gt;&lt;a href=&quot;id&quot;&gt;std::thread::id()&lt;/a&gt;&lt;/code&gt; (i.e. &lt;code&gt;&lt;a href=&quot;joinable&quot;&gt;joinable&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;)</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;get_id&quot;&gt;get_id()&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;id&quot;&gt;std::thread::id()&lt;/a&gt;&lt;/code&gt; (즉, &lt;code&gt;&lt;a href=&quot;joinable&quot;&gt;joinable&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;false&lt;/code&gt; 입니다 )</target>
        </trans-unit>
        <trans-unit id="d82370c49112909418c85a7bbce2f2a89acfef4c" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;T&amp;gt;(t)&lt;/code&gt;</source>
          <target state="translated">1)&lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;T&amp;gt;(t)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bc5ab532e7af0346e595eedb5cf5f9e6408fd503" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;&lt;a href=&quot;year_month&quot;&gt;std::chrono::year_month&lt;/a&gt;(y, m)&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;&lt;a href=&quot;year_month&quot;&gt;std::chrono::year_month&lt;/a&gt;(y, m)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="badcce23dab4fcdcef2e8d8dbecc4e624134b4e2" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;CD(CD(lhs).count() + CD(rhs).count())&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;CD(CD(lhs).count() + CD(rhs).count())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b3de7cbbd6b0c0e115c971c72f893fca52085fc3" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;T&lt;/code&gt; has a constructor which takes &lt;code&gt;&lt;a href=&quot;allocator_arg_t&quot;&gt;std::allocator_arg_t&lt;/a&gt;&lt;/code&gt; as the first argument, and &lt;code&gt;Alloc&lt;/code&gt; as the second argument.</source>
          <target state="translated">1) &lt;code&gt;T&lt;/code&gt; 에는 &lt;code&gt;&lt;a href=&quot;allocator_arg_t&quot;&gt;std::allocator_arg_t&lt;/a&gt;&lt;/code&gt; 를 첫 번째 인수로, &lt;code&gt;Alloc&lt;/code&gt; 을 두 번째 인수로 사용 하는 생성자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3816943554f6b87a85656750f477ce019fc7ecec" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;T&lt;/code&gt; satisfies the &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt; requirements</source>
          <target state="translated">1) &lt;code&gt;T&lt;/code&gt; 는 &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt; 요구 사항을 충족합니다</target>
        </trans-unit>
        <trans-unit id="5ba81d7384f3be3d79901ee5ca5e9fae02e27eaf" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;alignas(expression)&lt;/code&gt; must be an &lt;a href=&quot;constant_expression#Integral_constant_expression&quot;&gt;integral constant expression&lt;/a&gt; that evaluates to zero, or to a valid value for an &lt;a href=&quot;objects#Alignment&quot;&gt;alignment&lt;/a&gt; or extended alignment.</source>
          <target state="translated">1) &lt;code&gt;alignas(expression)&lt;/code&gt; 있어야 &lt;a href=&quot;constant_expression#Integral_constant_expression&quot;&gt;적분 상수 식&lt;/a&gt; 제로 평가하는, 또는 유효한 값으로 &lt;a href=&quot;objects#Alignment&quot;&gt;배향&lt;/a&gt; 또는 정렬 확장.</target>
        </trans-unit>
        <trans-unit id="29f78b67ee5bb13b52f91d0edbcdb4f6414d04e1" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;bitset&amp;lt;N&amp;gt;(lhs) &amp;amp;= rhs&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;bitset&amp;lt;N&amp;gt;(lhs) &amp;amp;= rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a349ffe82acf5becd117f06efc49aab25ea2c85c" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;cmp == 0&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;cmp == 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6432a52298130f9cfd18c643a22fc8b131244b62" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;dangling&lt;/code&gt; is trivially default constructible.</source>
          <target state="translated">1) &lt;code&gt;dangling&lt;/code&gt; 것은 사소한 기본 구성 가능합니다.</target>
        </trans-unit>
        <trans-unit id="beda484e792b3a9aa052329e49630e0e1cb4df96" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;f&lt;/code&gt;(until C++11)&lt;code&gt;std::move(f)&lt;/code&gt;(since C++11)</source>
          <target state="translated">1) &lt;code&gt;f&lt;/code&gt; (C ++ 11까지) &lt;code&gt;std::move(f)&lt;/code&gt; (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="d0c2bf794068c423aae04e770c11ac23803696fa" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;find&lt;/code&gt; searches for an element equal to &lt;code&gt;value&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;find&lt;/code&gt; 된 요소에 대한 탐색은 동일한 &lt;code&gt;value&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f188f796e6e4da125f373b9538b062909091f28" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;from_stream(is, fmt.c_str(), tp)&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;from_stream(is, fmt.c_str(), tp)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4036d95cbb69b4bb1c809874f7a7b33dc0b40b36" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;int(x) == int(y)&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;int(x) == int(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="192ed57aedc1fb59d3512844fdf3fe37ff04e837" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;iter&lt;/code&gt; unchanged</source>
          <target state="translated">1) &lt;code&gt;iter&lt;/code&gt; 변경되지 않은</target>
        </trans-unit>
        <trans-unit id="3e4aad118756c2f55e7910f4ed5ebbe5480aede1" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;lhs.base() == rhs.base()&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;lhs.base() == rhs.base()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ad8be4c75f87026417877f5704a96f516404a45" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;lhs.get() == rhs.get()&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;lhs.get() == rhs.get()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fad4d5c5d317e3201aaed83a07de38d00e7b8b15" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;obj-&amp;gt;compare_exchange_weak(*expected, desired)&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;obj-&amp;gt;compare_exchange_weak(*expected, desired)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ddd0fa78d37933f742e18b4a3222ef8ce03545f7" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;obj-&amp;gt;fetch_add(arg)&lt;/code&gt;</source>
          <target state="translated">1)&lt;code&gt;obj-&amp;gt;fetch_add(arg)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="033efc91517ef5e76f7e46074fe4d1ca11f0e4ac" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;obj-&amp;gt;fetch_and(arg)&lt;/code&gt;</source>
          <target state="translated">1)&lt;code&gt;obj-&amp;gt;fetch_and(arg)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7f88e5e85d2025754d42594e532089ecca13fe87" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;obj-&amp;gt;fetch_or(arg)&lt;/code&gt;</source>
          <target state="translated">1)&lt;code&gt;obj-&amp;gt;fetch_or(arg)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee86b20359d1a90e36ad892446781e20a30a0270" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;obj-&amp;gt;fetch_sub(arg)&lt;/code&gt;</source>
          <target state="translated">1)&lt;code&gt;obj-&amp;gt;fetch_sub(arg)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1d9a92886eb8fa21eb413790ca49226ccbdaaec6" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;obj-&amp;gt;fetch_xor(arg)&lt;/code&gt;</source>
          <target state="translated">1)&lt;code&gt;obj-&amp;gt;fetch_xor(arg)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7771b78ebb911a0ffff8cb6b1cbd746b8c60dab7" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;os&lt;/code&gt;</source>
          <target state="translated">1)&lt;code&gt;os&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1436b3bcceb7dd5260f18e572c0cc0fc7ba7fc37" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;ost&lt;/code&gt;</source>
          <target state="translated">1)&lt;code&gt;ost&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f8f2b734b0231b1951d1eaa90bc2d32b2e96f2e9" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;s.begin()&lt;/code&gt;</source>
          <target state="translated">1)&lt;code&gt;s.begin()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0d2279e328d05accd14e50bb63c2d0f8435f8f1a" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;std::vector&lt;/code&gt; is a sequence container that encapsulates dynamic size arrays.</source>
          <target state="translated">1) &lt;code&gt;std::vector&lt;/code&gt; 는 동적 크기 배열을 캡슐화하는 시퀀스 컨테이너입니다.</target>
        </trans-unit>
        <trans-unit id="6764b61929174f88ca70d1afacc7a58041077dc3" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;sv.begin()&lt;/code&gt;</source>
          <target state="translated">1)&lt;code&gt;sv.begin()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="42ce94d62eb003ef5a4bdc0db8a40b7cee88278d" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">1)&lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e0929706233ac9327022b8f82e797a7f08993b46" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; refer to the same object, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">1) &lt;code&gt;*this&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 가 같은 객체를 참조 하면 &lt;code&gt;true&lt;/code&gt; , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2db1d54cb42b651230d9ed4c533301e99a6b8d66" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are equal, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">1) &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 같으면 &lt;code&gt;true&lt;/code&gt; 이고 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="518c9b23c5f802da428f0672a059e45547edf53a" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;c&lt;/code&gt; is classified by &lt;code&gt;m&lt;/code&gt; in &lt;code&gt;table()&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;c&lt;/code&gt; 가 &lt;code&gt;table()&lt;/code&gt; 에서 &lt;code&gt;m&lt;/code&gt; 으로 분류 되면 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="981093f169f80c85d19c9b19637b9b9d758416f3" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">1) &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 가 같으면 &lt;code&gt;true&lt;/code&gt; 이고 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="43e58dfbb9212ca3f24df00edf0633fee53dcc8c" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;lhs&lt;/code&gt; is</source>
          <target state="translated">1) &lt;code&gt;lhs&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 이면</target>
        </trans-unit>
        <trans-unit id="1b55200a487fbaa2ac7e0e9706d79f5a50b80974" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;path() == rhs.path()&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; 하는 경우 &lt;code&gt;path() == rhs.path()&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="bb3c73d3d9660baa9060b11717e91785c4a08686" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;greater&lt;/code&gt; or &lt;code&gt;equivalent&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; 하는 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;greater&lt;/code&gt; 거나 &lt;code&gt;equivalent&lt;/code&gt; 하고, &lt;code&gt;false&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;less&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="057fe278295dee015cda4e798948d888b44db9e5" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;greater&lt;/code&gt; or &lt;code&gt;equivalent&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt; or &lt;code&gt;unordered&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; 하는 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;greater&lt;/code&gt; 거나 &lt;code&gt;equivalent&lt;/code&gt; 하고, &lt;code&gt;false&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;less&lt;/code&gt; 또는 &lt;code&gt;unordered&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1faab4cd5ee0a9499d7eb9940987003cb48cec6c" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;greater&lt;/code&gt;, &lt;code&gt;equivalent&lt;/code&gt;, or &lt;code&gt;equal&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; 하는 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;greater&lt;/code&gt; , &lt;code&gt;equivalent&lt;/code&gt; 또는 &lt;code&gt;equal&lt;/code&gt; 하고, &lt;code&gt;false&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;less&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1d6949d44ab7cfb2445d3daa9e7ad6b7f8e9cd72" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;greater&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt; or &lt;code&gt;equivalent&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; 하는 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;greater&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 이다 &lt;code&gt;less&lt;/code&gt; 또는 &lt;code&gt;equivalent&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22eedc5642e274e31953bd8244a855463b56b9be" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;greater&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt;, &lt;code&gt;equivalent&lt;/code&gt;, or &lt;code&gt;equal&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; 하는 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;greater&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 있다 &lt;code&gt;less&lt;/code&gt; , &lt;code&gt;equivalent&lt;/code&gt; 또는 &lt;code&gt;equal&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e67432e92597c17392ffb90e7c2a792902b331d2" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;greater&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt;, &lt;code&gt;equivalent&lt;/code&gt;, or &lt;code&gt;unordered&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; 하는 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;greater&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 이다 &lt;code&gt;less&lt;/code&gt; , &lt;code&gt;equivalent&lt;/code&gt; 또는 &lt;code&gt;unordered&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b17a58cbb394bf06a3153967e41d54c92e459291" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt; or &lt;code&gt;equivalent&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;greater&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; 하는 경우 &lt;code&gt;v&lt;/code&gt; 이다 &lt;code&gt;less&lt;/code&gt; 또는 &lt;code&gt;equivalent&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 이다 &lt;code&gt;greater&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="00eeee6618f31cffc2199398d71d2a07845ab5a6" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt; or &lt;code&gt;equivalent&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;greater&lt;/code&gt; or &lt;code&gt;unordered&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; 하는 경우 &lt;code&gt;v&lt;/code&gt; 이다 &lt;code&gt;less&lt;/code&gt; 또는 &lt;code&gt;equivalent&lt;/code&gt; 하고, &lt;code&gt;false&lt;/code&gt; 있는 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;greater&lt;/code&gt; 거나 &lt;code&gt;unordered&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c9b2546e8ec7d582f964b0378306c5e9285e8607" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt;, &lt;code&gt;equivalent&lt;/code&gt;, or &lt;code&gt;equal&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;greater&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; 하는 경우 &lt;code&gt;v&lt;/code&gt; 있다 &lt;code&gt;less&lt;/code&gt; , &lt;code&gt;equivalent&lt;/code&gt; 또는 &lt;code&gt;equal&lt;/code&gt; 하고, &lt;code&gt;false&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 이다 &lt;code&gt;greater&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d3b3453f1753720d8a278b17478f536d6c873470" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;greater&lt;/code&gt; or &lt;code&gt;equivalent&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; 하는 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;less&lt;/code&gt; 와 &lt;code&gt;false&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;greater&lt;/code&gt; 거나 &lt;code&gt;equivalent&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="89b89b71eb886c076b063f727e535fbc9d58b57c" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;greater&lt;/code&gt;, &lt;code&gt;equivalent&lt;/code&gt;, or &lt;code&gt;equal&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; 하는 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;less&lt;/code&gt; 와 &lt;code&gt;false&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;greater&lt;/code&gt; , &lt;code&gt;equivalent&lt;/code&gt; 또는 &lt;code&gt;equal&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c1e380e338f1a399252e48d9ecafb6a26eba21f7" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;greater&lt;/code&gt;, &lt;code&gt;equivalent&lt;/code&gt;, or &lt;code&gt;unordered&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; 하는 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;less&lt;/code&gt; 와 &lt;code&gt;false&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;greater&lt;/code&gt; , &lt;code&gt;equivalent&lt;/code&gt; 또는 &lt;code&gt;unordered&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="be7f8becec957b5e248aae298d408849990e044a" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;true&lt;/code&gt; if all bits are set to &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; 하는 모든 비트가 설정되어있는 경우 &lt;code&gt;true&lt;/code&gt; 않으면 &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c5edae3ae3416afd8cac68c825f76b03f91641ab" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;true&lt;/code&gt; if atomic access is implemented using lock-free instructions</source>
          <target state="translated">1) 잠금없는 명령어를 사용하여 원자 적 액세스가 구현 된 경우 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="526c267b2fa915170d8aca231bbf013dba07aa03" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;true&lt;/code&gt; if stack unwinding is currently in progress in this thread.</source>
          <target state="translated">1) 이 스레드에서 스택 해제가 현재 진행 &lt;code&gt;true&lt;/code&gt; 면 true 입니다.</target>
        </trans-unit>
        <trans-unit id="271a5674469eb694e10acb8e5379d1522dac157d" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;true&lt;/code&gt; if the &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; refer to the same time point, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">1) &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 가 같은 시점을 참조 하면 &lt;code&gt;true&lt;/code&gt; , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5caebb09ef2652fecde3560d8b72e7f5e0b4b36" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;true&lt;/code&gt; if the contents of the containers are equal, &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; 용기의 내용물이 같을 경우 &lt;code&gt;false&lt;/code&gt; 그렇지</target>
        </trans-unit>
        <trans-unit id="763b6211bcd953e14f11ade6c9420110256dbf87" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;true&lt;/code&gt; if the engine adaptors are equivalent, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">1) 엔진 어댑터가 같으면 &lt;code&gt;true&lt;/code&gt; 이고, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="27650c355d602e68a7570be0667ad739566a1383" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;true&lt;/code&gt; if the engines are equivalent, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">1) 엔진이 같으면 &lt;code&gt;true&lt;/code&gt; , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="01debb57d912b9651b3f500fad30c92b6438ab05" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;true&lt;/code&gt; if the error category and error value compare equal.</source>
          <target state="translated">1) 오류 범주와 오류 값이 동일한 경우 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="21535050363556a71f1d79661ba6945b51a1bad6" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;true&lt;/code&gt; if the file was deleted, &lt;code&gt;false&lt;/code&gt; if it did not exist. The overload that takes &lt;code&gt;error_code&amp;amp;&lt;/code&gt; argument returns &lt;code&gt;false&lt;/code&gt; on errors.</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; 파일이 삭제 된 경우, &lt;code&gt;false&lt;/code&gt; 이 존재하지 않은 경우. &lt;code&gt;error_code&amp;amp;&lt;/code&gt; 인수를 사용 하는 과부하 는 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="1ef2538fb30201356ec586312790884aa4f76823" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;true&lt;/code&gt; if the path is absolute, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">1) 경로가 절대 &lt;code&gt;true&lt;/code&gt; 이고, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="40683fe4f04c7e1bb34f411171069382b75798fb" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;unsigned(x) == unsigned(y)&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;unsigned(x) == unsigned(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="58fb8f3a262b134e6d1d56306cbf7654d5be6214" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">1)&lt;code&gt;v&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="a3d1031af3b348d409bf98f073def6dfbe8a6d9a" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;x.date() == y.date()&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;x.date() == y.date()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6b0d9303937fc983d65094d1cf6c6bb353f9159c" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;x.get_time_zone() == y.get_time_zone() &amp;amp;&amp;amp; x.get_sys_time() == y.get_sys_time()&lt;/code&gt;, except that the comparisons are performed on the nonstatic data members of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; directly and no copying is performed.</source>
          <target state="translated">1) &lt;code&gt;x.get_time_zone() == y.get_time_zone() &amp;amp;&amp;amp; x.get_sys_time() == y.get_sys_time()&lt;/code&gt; 의 비교는의 비 정적 데이터 멤버에서 수행되는 것을 제외하고는 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 직접 복사 동작이 수행되지 않는다.</target>
        </trans-unit>
        <trans-unit id="75e269c47b1609c7ccd4b90007ef9a5104f85875" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;x.month() == y.month() &amp;amp;&amp;amp; x.day() == y.day()&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;x.month() == y.month() &amp;amp;&amp;amp; x.day() == y.day()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0351be7029f6f6b22ceced0c5c52c6cad1c70560" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;x.month() == y.month() &amp;amp;&amp;amp; x.weekday_indexed() == y.weekday_indexed()&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;x.month() == y.month() &amp;amp;&amp;amp; x.weekday_indexed() == y.weekday_indexed()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="10c23b9d731dca8a445390711528695a64bd057b" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;x.month() == y.month() &amp;amp;&amp;amp; x.weekday_last() == y.weekday_last()&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;x.month() == y.month() &amp;amp;&amp;amp; x.weekday_last() == y.weekday_last()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ac693c8823123fef876426455c2bb65adbf08fd8" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;x.month() == y.month()&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;x.month() == y.month()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0d38460b047e1a3e8a4424a1fc245ca4a79dbddd" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;x.name() == y.name()&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;x.name() == y.name()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5282a137bb464e9b1551a30bc6c933d909188ed" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;x.weekday() != y.weekday()&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;x.weekday() != y.weekday()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf132263ed472a8bde6a8bc1ead34934ec4c2954" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;x.weekday() == y.weekday() &amp;amp;&amp;amp; x.index() == y.index()&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;x.weekday() == y.weekday() &amp;amp;&amp;amp; x.index() == y.index()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71d2b9c7a3e21a79d684805ce4185186e4b2e875" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;x.weekday() == y.weekday()&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;x.weekday() == y.weekday()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2668f0155601d3382f210e39a265be68805db3c9" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;x.year() == y.year() &amp;amp;&amp;amp; x.month() == y.month() &amp;amp;&amp;amp; x.day() == y.day()&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;x.year() == y.year() &amp;amp;&amp;amp; x.month() == y.month() &amp;amp;&amp;amp; x.day() == y.day()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="429102405180cfc563cd2ea456f8a19781039726" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;x.year() == y.year() &amp;amp;&amp;amp; x.month() == y.month() &amp;amp;&amp;amp; x.weekday() == y.weekday()&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;x.year() == y.year() &amp;amp;&amp;amp; x.month() == y.month() &amp;amp;&amp;amp; x.weekday() == y.weekday()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="447cb38966ca6b66304885f4486d7a21b41fd303" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;x.year() == y.year() &amp;amp;&amp;amp; x.month() == y.month() &amp;amp;&amp;amp; x.weekday_indexed() == y.weekday_indexed()&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;x.year() == y.year() &amp;amp;&amp;amp; x.month() == y.month() &amp;amp;&amp;amp; x.weekday_indexed() == y.weekday_indexed()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="74066eec3b1f8deac4f7c18bb81f0debc3d942ab" translate="yes" xml:space="preserve">
          <source>1)&lt;code&gt;x.year() == y.year() &amp;amp;&amp;amp; x.month() == y.month()&lt;/code&gt;</source>
          <target state="translated">1) &lt;code&gt;x.year() == y.year() &amp;amp;&amp;amp; x.month() == y.month()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a5d265f9e01541e5bb608b13484be196c37fcea1" translate="yes" xml:space="preserve">
          <source>1)digit-sequence representing a whole number without a decimal separator, in this case the exponent is not optional: &lt;code&gt;1e10&lt;/code&gt;, &lt;code&gt;1e-5L&lt;/code&gt;</source>
          <target state="translated">1) 소수 구분 기호없이 정수를 나타내는 숫자 순서,이 경우 지수는 선택 사항이 아닙니다 : &lt;code&gt;1e10&lt;/code&gt; , &lt;code&gt;1e-5L&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="730d16b42d40e658811ffd644545e4b7452b3072" translate="yes" xml:space="preserve">
          <source>1)lhs must be an expression of class type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">1) lhs는 클래스 유형 &lt;code&gt;T&lt;/code&gt; 의 표현식이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a8be3dac7b86896b4895ce9eca19db5c822b7705" translate="yes" xml:space="preserve">
          <source>1)root-name (if any)</source>
          <target state="translated">1) 루트 이름 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="5078a9b14a3bd4171b4acd91c483a844c8e662f1" translate="yes" xml:space="preserve">
          <source>1, ..., a</source>
          <target state="translated">1, ...,</target>
        </trans-unit>
        <trans-unit id="c8765d992113b67a81ad6ed2fa6c71a580cdcda2" translate="yes" xml:space="preserve">
          <source>1, ..., b</source>
          <target state="translated">1, ..., b</target>
        </trans-unit>
        <trans-unit id="70d54c422839e2a56a54b29a8714b9538f8154d9" translate="yes" xml:space="preserve">
          <source>1, 3) Any exception thrown by the copy constructor of &lt;code&gt;value&lt;/code&gt;</source>
          <target state="translated">1, 3) &lt;code&gt;value&lt;/code&gt; 의 복사 생성자가 던진 예외</target>
        </trans-unit>
        <trans-unit id="086d686412b1c2b2c0e4a09f5347905ee2ed718d" translate="yes" xml:space="preserve">
          <source>1, cv2</source>
          <target state="translated">1, cv2</target>
        </trans-unit>
        <trans-unit id="77895b1183c5f29d5e0d297eda22902c549e197b" translate="yes" xml:space="preserve">
          <source>1,2) (none)</source>
          <target state="translated">1,2) (없음)</target>
        </trans-unit>
        <trans-unit id="4932235b4136aacf10f033e9b0dac66dc07d0f9a" translate="yes" xml:space="preserve">
          <source>1,2) A reference to the corresponding element</source>
          <target state="translated">1,2) 해당 요소에 대한 참조</target>
        </trans-unit>
        <trans-unit id="6645f44f59abd896dc3a7f87651dffbe09759d10" translate="yes" xml:space="preserve">
          <source>1,2) Average case O(1), worst case O(a.size()).</source>
          <target state="translated">1,2) 평균 사례 O (1), 최악의 경우 O (a.size ()).</target>
        </trans-unit>
        <trans-unit id="b9722393aae46428407e5a1d70469104eff9394a" translate="yes" xml:space="preserve">
          <source>1,2) Compares the keys to &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">1,2)에 키를 비교 &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9746c9a71ddc7819c2234dfab93e532cd0a6fea5" translate="yes" xml:space="preserve">
          <source>1,2) Constructs the underlying &lt;code&gt;&lt;a href=&quot;../strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; by calling &lt;code&gt;strstreambuf(s,0)&lt;/code&gt; and initializes the base class with the address of the strstreambuf. The behavior is undefined if &lt;code&gt;s&lt;/code&gt; is not pointing at an element of a null-terminated array.</source>
          <target state="translated">1,2) &lt;code&gt;strstreambuf(s,0)&lt;/code&gt; 를 호출 하여 기본 &lt;code&gt;&lt;a href=&quot;../strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; 를 구성하고 strstreambuf 의 주소로 기본 클래스를 초기화합니다. &lt;code&gt;s&lt;/code&gt; 가 null로 끝나는 배열의 요소를 가리 키지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fa7204e8a25e58357a84662773ed556dfd820dbd" translate="yes" xml:space="preserve">
          <source>1,2) Creates an instance of &lt;code&gt;std::basic_syncbuf&lt;/code&gt; with emit-on-sync policy set to &lt;code&gt;false&lt;/code&gt;, wrapped streambuffer set to &lt;code&gt;obuf&lt;/code&gt;, and using &lt;code&gt;a&lt;/code&gt; as the allocator for temporary storage.</source>
          <target state="translated">1,2) emit-on-sync 정책을 &lt;code&gt;false&lt;/code&gt; 로 설정하고 , 래핑 된 &lt;code&gt;obuf&lt;/code&gt; 를 obuf로 설정하고 , 임시 저장을위한 할당 자로 &lt;code&gt;a&lt;/code&gt; 를 사용하여 &lt;code&gt;std::basic_syncbuf&lt;/code&gt; 의 인스턴스를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="aab7de3055ee5cc18af741ee6cb05e33e2b884ec" translate="yes" xml:space="preserve">
          <source>1,2) Finds an element with key equivalent to &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">1,2) key와 같은 &lt;code&gt;key&lt;/code&gt; 가진 요소를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="496f5f4ebf371e9578088095bf1d77a0dee6e4d2" translate="yes" xml:space="preserve">
          <source>1,2) Finds an element with key equivalent to &lt;code&gt;key&lt;/code&gt;. If there are several elements with &lt;code&gt;key&lt;/code&gt; in the container, any of them may be returned.</source>
          <target state="translated">1,2) key와 같은 &lt;code&gt;key&lt;/code&gt; 가진 요소를 찾습니다 . 컨테이너에 &lt;code&gt;key&lt;/code&gt; 가있는 여러 요소가 있으면 그 중 하나가 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b488c4d5e4a434a2fbfe28a2e98d88c6125ce3da" translate="yes" xml:space="preserve">
          <source>1,2) Includes source file, identified by filename into the current source file at the line immediately after the directive. In the case the file is not found, program is ill-formed.</source>
          <target state="translated">1,2) 파일 이름으로 식별 된 소스 파일을 지시문 바로 다음 줄의 현재 소스 파일에 포함합니다. 파일을 찾을 수없는 경우 프로그램이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="0e930c3328815e477e6936c58d2b3ae98ff330cd" translate="yes" xml:space="preserve">
          <source>1,2) May throw &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; from the constructor of the internal temporary storage or &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; from the mutex construction.</source>
          <target state="translated">1,2) 내부 임시 저장소 생성자에서 &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 을 던지 거나 뮤텍스 구성에서 &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; 를 던질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9a36e8936e92662180ea3acf2c3df7b18f6e4d3" translate="yes" xml:space="preserve">
          <source>1,2) Number of wide characters written if successful or negative value if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba7795c56f36a7825842df72b9b448a56e987f19" translate="yes" xml:space="preserve">
          <source>1,2) Public member function, calls the protected virtual member function &lt;code&gt;do_narrow&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1,2) 공용 멤버 함수, 가장 파생 된 클래스 의 보호 된 가상 멤버 함수 &lt;code&gt;do_narrow&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="e5548fc8f94a647c234cf211c67fb613cae5beb1" translate="yes" xml:space="preserve">
          <source>1,2) Returns a range containing all elements with key &lt;code&gt;key&lt;/code&gt; in the container. The range is defined by two iterators, the first pointing to the first element of the wanted range and the second pointing past the last element of the range.</source>
          <target state="translated">1,2) 컨테이너에 키 &lt;code&gt;key&lt;/code&gt; 가있는 모든 요소가 포함 된 범위를 반환합니다 . 범위는 두 개의 반복자로 정의되며, 첫 번째는 원하는 범위의 첫 번째 요소를 가리키고 두 번째는 범위의 마지막 요소를지나칩니다.</target>
        </trans-unit>
        <trans-unit id="35c69eeea2a4bb52e8025fa4b63f5889de416b8d" translate="yes" xml:space="preserve">
          <source>1,2) Same as for &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt;</source>
          <target state="translated">1,2) &lt;a href=&quot;emplace&quot;&gt;엠 플레이스&lt;/a&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="6b9b7e37d97a0fd84f29aee9422ff08784564ba5" translate="yes" xml:space="preserve">
          <source>1,2) The bool component is &lt;code&gt;true&lt;/code&gt; if the insertion took place and &lt;code&gt;false&lt;/code&gt; if the assignment took place. The iterator component is pointing at the element that was inserted or updated</source>
          <target state="translated">1,2) 삽입이 발생하면 bool 구성 요소는 &lt;code&gt;true&lt;/code&gt; 이고 할당이 수행되면 &lt;code&gt;false&lt;/code&gt; 입니다. 반복기 구성 요소가 삽입 또는 업데이트 된 요소를 가리키고 있습니다.</target>
        </trans-unit>
        <trans-unit id="8073c06a928ddf71db6529c3b15556e1d8746514" translate="yes" xml:space="preserve">
          <source>1,2) Throws &lt;code&gt;&lt;a href=&quot;bad_variant_access&quot;&gt;std::bad_variant_access&lt;/a&gt;&lt;/code&gt; on errors.</source>
          <target state="translated">1,2) 오류가 발생하면 &lt;code&gt;&lt;a href=&quot;bad_variant_access&quot;&gt;std::bad_variant_access&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6d0cb6ca642ff33fcc67790a2b14d55057020bdc" translate="yes" xml:space="preserve">
          <source>1,2) public member function, calls the protected virtual member function &lt;code&gt;do_is&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1,2) 공개 멤버 함수, 가장 파생 된 클래스 의 보호 된 가상 멤버 함수 &lt;code&gt;do_is&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="d571e8210241a2e3bb7f35c9f8c04ac2f50318f1" translate="yes" xml:space="preserve">
          <source>1,2) public member function, calls the protected virtual member function &lt;code&gt;do_tolower&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1,2) 공개 멤버 함수 는 가장 파생 된 클래스 의 보호 된 가상 멤버 함수 &lt;code&gt;do_tolower&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="7836a5a4dbfa7418fccb0bdf57fd9eedf26b52f7" translate="yes" xml:space="preserve">
          <source>1,2) public member function, calls the protected virtual member function &lt;code&gt;do_toupper&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1,2) 공개 멤버 함수, 가장 파생 된 클래스 의 보호 된 가상 멤버 함수 &lt;code&gt;do_toupper&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="b75405628f9b297bea7809e97035b23462722bf8" translate="yes" xml:space="preserve">
          <source>1,2) public member function, calls the protected virtual member function &lt;code&gt;do_widen&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1,2) 공개 멤버 함수, 가장 파생 된 클래스 의 보호 된 가상 멤버 함수 &lt;code&gt;do_widen&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="acf3434bbfcfd3bf729bf1b99caa65d63cd6a1c9" translate="yes" xml:space="preserve">
          <source>1,2) returns &lt;code&gt;c.data()&lt;/code&gt;</source>
          <target state="translated">1,2)는 &lt;code&gt;c.data()&lt;/code&gt; )를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ba36f3f0652b3f09f0fa39f67c179c3be70244a2" translate="yes" xml:space="preserve">
          <source>1,2,4,5) O(last1 - first1) applications each of &lt;code&gt;binary_op1&lt;/code&gt; and &lt;code&gt;binary_op2&lt;/code&gt;.</source>
          <target state="translated">1,2,4,5) O (last1-first1)는 &lt;code&gt;binary_op1&lt;/code&gt; 및 &lt;code&gt;binary_op2&lt;/code&gt; 각각에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="3f272a1a73d45d053b9890a90710700c99c5769f" translate="yes" xml:space="preserve">
          <source>1,3) At most &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) + &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2) - 1&lt;/code&gt; comparisons.</source>
          <target state="translated">1,3) 최대 &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) + &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2) - 1&lt;/code&gt; 비교.</target>
        </trans-unit>
        <trans-unit id="a0065eab11c8e5e5d008b05ea5c2ee69d044c0f9" translate="yes" xml:space="preserve">
          <source>1,3) At most &lt;code&gt;last1&lt;/code&gt; - &lt;code&gt;first1&lt;/code&gt; applications of the predicate</source>
          <target state="translated">1,3) 대부분에서 &lt;code&gt;last1&lt;/code&gt; - &lt;code&gt;first1&lt;/code&gt; 술어의 응용</target>
        </trans-unit>
        <trans-unit id="3aabaa6b99ed807ee80a53b401b2ac539bfefc7a" translate="yes" xml:space="preserve">
          <source>1,3) Elements are compared using &lt;code&gt;operator==&lt;/code&gt;. The behavior is undefined if it is not an &lt;a href=&quot;https://en.wikipedia.org/wiki/equivalence_relation&quot;&gt;equivalence relation&lt;/a&gt;.</source>
          <target state="translated">1,3) 요소는 &lt;code&gt;operator==&lt;/code&gt; 사용하여 비교됩니다 . &lt;a href=&quot;https://en.wikipedia.org/wiki/equivalence_relation&quot;&gt;동치 관계&lt;/a&gt; 가 아닌 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1ee8ca9ba64bf941e30d6be38651ce629bedf019" translate="yes" xml:space="preserve">
          <source>1,3) Exactly &lt;code&gt;N-1&lt;/code&gt; comparisons if enough additional memory is available. If the memory is insufficient, &lt;code&gt;O(N log N)&lt;/code&gt; comparisons.</source>
          <target state="translated">1,3) 충분한 추가 메모리가 사용 가능한 경우 정확히 &lt;code&gt;N-1&lt;/code&gt; 비교. 메모리가 부족하면 &lt;code&gt;O(N log N)&lt;/code&gt; 비교합니다.</target>
        </trans-unit>
        <trans-unit id="a8f9e77c2013318eb600b56aeb8b8709795c8599" translate="yes" xml:space="preserve">
          <source>1,3) Exactly &lt;code&gt;min((result-first)+1, (last-first)-1)&lt;/code&gt; applications of the predicate where &lt;code&gt;result&lt;/code&gt; is the return value.</source>
          <target state="translated">1,3) &lt;code&gt;result&lt;/code&gt; 가 리턴 값 인 술어의 정확한 &lt;code&gt;min((result-first)+1, (last-first)-1)&lt;/code&gt; 응용 프로그램 .</target>
        </trans-unit>
        <trans-unit id="23e9e6741f1bdd34ef65cb83eccc854fa936d233" translate="yes" xml:space="preserve">
          <source>1,3) First, creates an accumulator &lt;code&gt;acc&lt;/code&gt; whose type is &lt;code&gt;InputIt&lt;/code&gt;'s value type, initializes it with &lt;code&gt;*first&lt;/code&gt;, and assigns the result to &lt;code&gt;*d_first&lt;/code&gt;. Then, for every iterator &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[first + 1, last)&lt;/code&gt; in order, creates an object &lt;code&gt;val&lt;/code&gt; whose type is &lt;code&gt;InputIt&lt;/code&gt;'s value type, initializes it with &lt;code&gt;*i&lt;/code&gt;, computes &lt;code&gt;val - acc&lt;/code&gt;(until C++20)&lt;code&gt;val - std::move(acc)&lt;/code&gt;(since C++20) (overload (1)) or &lt;code&gt;op(val, acc)&lt;/code&gt;(until C++20)&lt;code&gt;op(val, std::move(acc))&lt;/code&gt;(since C++20) (overload (3)), assigns the result to &lt;code&gt;*(d_first + (i - first))&lt;/code&gt;, and move assigns from &lt;code&gt;val&lt;/code&gt; to &lt;code&gt;acc&lt;/code&gt;.</source>
          <target state="translated">1,3) 먼저, 유형이 &lt;code&gt;InputIt&lt;/code&gt; 의 값 유형 인 누산기 &lt;code&gt;acc&lt;/code&gt; 를 작성하고 &lt;code&gt;*first&lt;/code&gt; 로 초기화 한 후 결과를 &lt;code&gt;*d_first&lt;/code&gt; 에 지정합니다 . 그런 다음 순서대로 &lt;code&gt;[first + 1, last)&lt;/code&gt; 모든 반복자 &lt;code&gt;i&lt;/code&gt; 에 대해 유형이 &lt;code&gt;InputIt&lt;/code&gt; 값 유형 인 객체 &lt;code&gt;val&lt;/code&gt; 을 작성하고 &lt;code&gt;*i&lt;/code&gt; 로 초기화하고 &lt;code&gt;val - acc&lt;/code&gt; 계산합니다 (C ++ 20까지) &lt;code&gt;val - std::move(acc)&lt;/code&gt; (C ++ 20부터) (과부하 (1)) 또는 &lt;code&gt;op(val, acc)&lt;/code&gt; (C ++ 20까지) &lt;code&gt;op(val, std::move(acc))&lt;/code&gt; (C ++부터 20) (과부하 (3)), 결과를 &lt;code&gt;*(d_first + (i - first))&lt;/code&gt; 할당할당을 &lt;code&gt;val&lt;/code&gt; 에서 &lt;code&gt;acc&lt;/code&gt; 로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="07dc6823b4029c4cb0d508a5f8855078631f3a51" translate="yes" xml:space="preserve">
          <source>1,3) If a key equivalent to &lt;code&gt;k&lt;/code&gt; already exists in the container, assigns &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;M&amp;gt;(obj)&lt;/code&gt; to the &lt;code&gt;mapped_type&lt;/code&gt; corresponding to the key &lt;code&gt;k&lt;/code&gt;. If the key does not exist, inserts the new value as if by &lt;a href=&quot;insert&quot;&gt;insert&lt;/a&gt;, constructing it from &lt;code&gt;value_type(k, &lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;M&amp;gt;(obj))&lt;/code&gt;</source>
          <target state="translated">1,3) &lt;code&gt;k&lt;/code&gt; 에 해당하는 키 가 컨테이너에 이미 존재하는 경우 &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;M&amp;gt;(obj)&lt;/code&gt; 를 키 &lt;code&gt;k&lt;/code&gt; 에 해당 하는 &lt;code&gt;mapped_type&lt;/code&gt; 할당합니다 . 키가 존재하지 않는 경우에서처럼, 새로운 값을 삽입하는 &lt;a href=&quot;insert&quot;&gt;인서트&lt;/a&gt; 로 구성하여, &lt;code&gt;value_type(k, &lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;M&amp;gt;(obj))&lt;/code&gt; &lt;a href=&quot;../../utility/forward&quot;&gt;표준 : 순방향&lt;/a&gt; &amp;lt;M&amp;gt; (OBJ))</target>
        </trans-unit>
        <trans-unit id="403abb2759ea56504fa8055c3cf76581d4d46dbe" translate="yes" xml:space="preserve">
          <source>1,3) Linear in &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; on average.</source>
          <target state="translated">1,3) &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; 선형 ( 평균 , 첫 번째, 마지막)</target>
        </trans-unit>
        <trans-unit id="9219cb8246128d9e818d226c6469ba9515f51dff" translate="yes" xml:space="preserve">
          <source>1,3) Returns &lt;code&gt;true&lt;/code&gt; if the range &lt;code&gt;[first1, last1)&lt;/code&gt; is equal to the range &lt;code&gt;[first2, first2 + (last1 - first1))&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="translated">1,3)를 반환 &lt;code&gt;true&lt;/code&gt; 범위 경우 &lt;code&gt;[first1, last1)&lt;/code&gt; 범위와 동일하다 &lt;code&gt;[first2, first2 + (last1 - first1))&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 그렇지</target>
        </trans-unit>
        <trans-unit id="14120a9b5de8e85086793777a19e413242503103" translate="yes" xml:space="preserve">
          <source>1,3) The object of type &lt;code&gt;string_type&lt;/code&gt; to use as the representation of &lt;code&gt;true&lt;/code&gt;. The standard specializations of &lt;code&gt;std::numpunct&lt;/code&gt; return &lt;code&gt;&quot;true&quot;&lt;/code&gt; and &lt;code&gt;L&quot;true&quot;&lt;/code&gt;.</source>
          <target state="translated">1,3) &lt;code&gt;string_type&lt;/code&gt; 유형의 객체 는 &lt;code&gt;true&lt;/code&gt; 표시로 사용됩니다 . &lt;code&gt;std::numpunct&lt;/code&gt; 의 표준 특수화는 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 및 &lt;code&gt;L&quot;true&quot;&lt;/code&gt; 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="cdacc381aa3f0d6f6321b80c4004c73ad30c1f28" translate="yes" xml:space="preserve">
          <source>1,3) The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;p&lt;/code&gt; as the first path argument and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">1,3) &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 매개 변수 를 사용하지 않는 오버로드는 기본 OS API 오류에서 &lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다. &lt;code&gt;p&lt;/code&gt; 는 첫 번째 경로 인수로, OS 오류 코드는 오류 코드 인수로 구성됩니다. &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 매개 변수 를 사용하는 과부하 는 OS API 호출이 실패하면이를 OS API 오류 코드로 설정하고 오류가 발생하지 않으면 &lt;code&gt;ec.clear()&lt;/code&gt; 실행 합니다. &lt;code&gt;noexcept&lt;/code&gt; 로 표시되지 않은 과부하 는 메모리 할당에 실패하면 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 발생 시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="736c660fae1432ae472974f5e27a09ded3a56cba" translate="yes" xml:space="preserve">
          <source>1,3) The value of the atomic variable after the modification. Formally, the result of incrementing/decrementing the value immediately preceding the effects of this function in the &lt;a href=&quot;../memory_order#Modification_order&quot;&gt;modification order&lt;/a&gt; of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">1,3) 수정 후 원자 변수의 값. 공식적 / 증분 바로이 함수의 결과를 이전의 값으로 감소시키는 결과 &lt;a href=&quot;../memory_order#Modification_order&quot;&gt;수정 순&lt;/a&gt; 의 &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f39890b1f45d7d93e9cfe7d2793c7aeb70ab538a" translate="yes" xml:space="preserve">
          <source>1,3) The value of the referenced object after the modification.</source>
          <target state="translated">1,3) 수정 후 참조 된 객체의 값.</target>
        </trans-unit>
        <trans-unit id="f6972d61fbd58c3c4ba7800e9ab2240741707a07" translate="yes" xml:space="preserve">
          <source>1,3) Throws &lt;code&gt;bad_alloc&lt;/code&gt; or any exception thrown by the constructor of the contained type. If an exception is thrown, there are no effects (strong exception guarantee).</source>
          <target state="translated">1,3) &lt;code&gt;bad_alloc&lt;/code&gt; 또는 포함 된 유형의 생성자가 던진 예외를 던집니다 . 예외가 발생하면 아무런 영향이 없습니다 (강력한 예외 보장).</target>
        </trans-unit>
        <trans-unit id="8a1d3330619b7df2a0e3d2d57794611948e4a797" translate="yes" xml:space="preserve">
          <source>1,3) a reference to this &lt;code&gt;day&lt;/code&gt; after modification</source>
          <target state="translated">1,3) 수정 후이 &lt;code&gt;day&lt;/code&gt; 대한 참조</target>
        </trans-unit>
        <trans-unit id="e86607cd9ea37653b1df2220ed03a29baaa6cd5c" translate="yes" xml:space="preserve">
          <source>1,3) a reference to this &lt;code&gt;month&lt;/code&gt; after modification</source>
          <target state="translated">1,3) 수정 후이 &lt;code&gt;month&lt;/code&gt; 대한 참조</target>
        </trans-unit>
        <trans-unit id="1333b5046c2da0033bab2c5298c6df0675ec09a8" translate="yes" xml:space="preserve">
          <source>1,3) a reference to this &lt;code&gt;time_point&lt;/code&gt; after modification</source>
          <target state="translated">1,3) 수정 &lt;code&gt;time_point&lt;/code&gt; 대한 참조</target>
        </trans-unit>
        <trans-unit id="58407d91afee88d1a2715ac7e25d6317b15b24fe" translate="yes" xml:space="preserve">
          <source>1,3) a reference to this &lt;code&gt;weekday&lt;/code&gt; after modification</source>
          <target state="translated">1,3) 수정 &lt;code&gt;weekday&lt;/code&gt; 대한 참조</target>
        </trans-unit>
        <trans-unit id="0d68d9faba4f83e79c375b884fe669741f61bc1a" translate="yes" xml:space="preserve">
          <source>1,3) a reference to this &lt;code&gt;year&lt;/code&gt; after modification</source>
          <target state="translated">1,3) 수정 후 &lt;code&gt;year&lt;/code&gt; 참조</target>
        </trans-unit>
        <trans-unit id="a33a2888d7e1f65aa55c5f13aca6903b88825f99" translate="yes" xml:space="preserve">
          <source>1,3) a reference to this duration after modification</source>
          <target state="translated">1,3) 수정 후이 기간에 대한 참조</target>
        </trans-unit>
        <trans-unit id="63380af801fc0d3b65aa3964b1e9414694040738" translate="yes" xml:space="preserve">
          <source>1,3) lower case character or &lt;code&gt;c&lt;/code&gt; if no lower case form is listed by this locale.</source>
          <target state="translated">1,3) 소문자 또는 이 로케일에 소문자 형식이없는 경우 &lt;code&gt;c&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1ea84d797471c330e3c0dc7a18f1f3a94a5940f" translate="yes" xml:space="preserve">
          <source>1,3) narrowed character or &lt;code&gt;dflt&lt;/code&gt; if narrowing fails</source>
          <target state="translated">1,3) 축소 문자 또는 축소 실패시 &lt;code&gt;dflt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7876d2b1573f5f4363b3c2c467ff4c142fe03d9c" translate="yes" xml:space="preserve">
          <source>1,3) new bitset object containing the shifted bits</source>
          <target state="translated">1,3) 쉬프트 된 비트를 포함하는 새로운 비트 세트 객체</target>
        </trans-unit>
        <trans-unit id="bd4b8dc5373640ec28b0c4ccf1794282ef6f9b9a" translate="yes" xml:space="preserve">
          <source>1,3) type is deduced using the rules for &lt;a href=&quot;template_argument_deduction#Other_contexts&quot;&gt;template argument deduction&lt;/a&gt;.</source>
          <target state="translated">1,3) 형식은 &lt;a href=&quot;template_argument_deduction#Other_contexts&quot;&gt;템플릿 인수 추론&lt;/a&gt; 규칙을 사용하여 추론 됩니다 .</target>
        </trans-unit>
        <trans-unit id="d1770588659ee4af014257fcf4bfa47d1c8f4ad0" translate="yes" xml:space="preserve">
          <source>1,3) upper case character or &lt;code&gt;c&lt;/code&gt; if no upper case form is listed by this locale.</source>
          <target state="translated">1,3) 대문자 또는 이 로케일에 대문자가없는 경우 &lt;code&gt;c&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="970648d731511f34194626d5fe4b1049dfd5a17c" translate="yes" xml:space="preserve">
          <source>1,3) widened character</source>
          <target state="translated">1,3) 확장 된 캐릭터</target>
        </trans-unit>
        <trans-unit id="924016d0fe60e34044633daa704eeb20fdc58d76" translate="yes" xml:space="preserve">
          <source>1,3)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;c&lt;/code&gt; is classified by &lt;code&gt;m&lt;/code&gt;</source>
          <target state="translated">1,3) &lt;code&gt;c&lt;/code&gt; 가 &lt;code&gt;m&lt;/code&gt; 으로 분류 되면 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="135c83c74cb097fb3bde5c19fe8572602a7183c6" translate="yes" xml:space="preserve">
          <source>1,3,5) At most &lt;code&gt;last&lt;/code&gt; - &lt;code&gt;first&lt;/code&gt; applications of the predicate</source>
          <target state="translated">1,3,5) 대부분에서 &lt;code&gt;last&lt;/code&gt; - &lt;code&gt;first&lt;/code&gt; 술어의 응용</target>
        </trans-unit>
        <trans-unit id="01ce39aa3795e49f6a122166b9f21f1559a435dc" translate="yes" xml:space="preserve">
          <source>1,5) Adds &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">1,5) &lt;code&gt;*this&lt;/code&gt; 에 &lt;code&gt;other&lt;/code&gt; 를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="2f4cada6d7f28e98e39dd2adffd2635ff53bb7c7" translate="yes" xml:space="preserve">
          <source>1,5) Elements are compared using &lt;code&gt;operator==&lt;/code&gt;.</source>
          <target state="translated">1,5) 요소는 &lt;code&gt;operator==&lt;/code&gt; 사용하여 비교됩니다 .</target>
        </trans-unit>
        <trans-unit id="d6eb7d6e30f7780a1a73a7108b2824a4fb712418" translate="yes" xml:space="preserve">
          <source>1,5) when a nameless temporary object is created with the initializer consisting of an empty pair of parentheses or braces(since C++11);</source>
          <target state="translated">1,5) 빈 괄호 또는 중괄호로 구성된 이니셜 라이저로 이름없는 임시 객체를 생성 한 경우 (C ++ 11부터);</target>
        </trans-unit>
        <trans-unit id="348fe0c3059f16cc104e9060b087790a7c62c5d1" translate="yes" xml:space="preserve">
          <source>1-11)&lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">1-11)&lt;code&gt;*this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="84a07400ce3e3fb90b73541e4a532a0fa15c208a" translate="yes" xml:space="preserve">
          <source>1-2) (none)</source>
          <target state="translated">1-2) (없음)</target>
        </trans-unit>
        <trans-unit id="ae97716dede2ec5443b9d4a6a3d3feddf946fbad" translate="yes" xml:space="preserve">
          <source>1-2) Adds &lt;code&gt;d.count()&lt;/code&gt; days to &lt;code&gt;wd&lt;/code&gt;. The weekday value held in the result is computed by first evaluating &lt;code&gt;static_cast&amp;lt;long long&amp;gt;(unsigned(wd)) + d.count()&lt;/code&gt; and reducing it modulo 7 to an integer in the range [0, 6].</source>
          <target state="translated">1-2) &lt;code&gt;d.count()&lt;/code&gt; 일을 &lt;code&gt;wd&lt;/code&gt; 에 추가합니다 . 결과에 포함 된 요일 값은 먼저 &lt;code&gt;static_cast&amp;lt;long long&amp;gt;(unsigned(wd)) + d.count()&lt;/code&gt; 하고 모듈로 7을 [0, 6] 범위의 정수로 줄임으로써 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="bcc0b05b00cec586609eee573a8e86a2e2de8471" translate="yes" xml:space="preserve">
          <source>1-2) Adds &lt;code&gt;dm.count()&lt;/code&gt; months to the date represented by &lt;code&gt;ymd&lt;/code&gt;. The result has the same &lt;code&gt;day()&lt;/code&gt; as &lt;code&gt;ymd&lt;/code&gt; and the same &lt;code&gt;year()&lt;/code&gt; and &lt;code&gt;month()&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;../year_month&quot;&gt;std::chrono::year_month&lt;/a&gt;(ymd.year(), ymd.month()) + dm&lt;/code&gt;.</source>
          <target state="translated">1-2) &lt;code&gt;ymd&lt;/code&gt; 로 표시된 날짜에 &lt;code&gt;dm.count()&lt;/code&gt; 개월을 추가합니다 . 결과는 같은이 &lt;code&gt;day()&lt;/code&gt; 로 &lt;code&gt;ymd&lt;/code&gt; 와 같은 &lt;code&gt;year()&lt;/code&gt; 와 &lt;code&gt;month()&lt;/code&gt; 등을 &lt;code&gt;&lt;a href=&quot;../year_month&quot;&gt;std::chrono::year_month&lt;/a&gt;(ymd.year(), ymd.month()) + dm&lt;/code&gt; (ymd.year (), ymd.month ()) + DM .</target>
        </trans-unit>
        <trans-unit id="1269552b861fc2cda13ec08604555f3866e7b791" translate="yes" xml:space="preserve">
          <source>1-2) Adds &lt;code&gt;dm.count()&lt;/code&gt; months to the date represented by &lt;code&gt;ymdl&lt;/code&gt;. The result has the same &lt;code&gt;year()&lt;/code&gt; and &lt;code&gt;month()&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;../year_month&quot;&gt;std::chrono::year_month&lt;/a&gt;(ymdl.year(), ymdl.month()) + dm&lt;/code&gt;.</source>
          <target state="translated">1-2)를 추가의 &lt;code&gt;dm.count()&lt;/code&gt; 날짜에 개월로 표현 &lt;code&gt;ymdl&lt;/code&gt; . 결과는 &lt;code&gt;&lt;a href=&quot;../year_month&quot;&gt;std::chrono::year_month&lt;/a&gt;(ymdl.year(), ymdl.month()) + dm&lt;/code&gt; (ymdl.year (), ymdl.month ()) + dm 과 동일한 &lt;code&gt;year()&lt;/code&gt; 및 &lt;code&gt;month()&lt;/code&gt; 를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="162a3fdcd63b0215c94f6705fb6882dbddfcb115" translate="yes" xml:space="preserve">
          <source>1-2) Adds &lt;code&gt;dm.count()&lt;/code&gt; months to the date represented by &lt;code&gt;ymwd&lt;/code&gt;. The result has the same &lt;code&gt;year()&lt;/code&gt; and &lt;code&gt;month()&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;../year_month&quot;&gt;std::chrono::year_month&lt;/a&gt;(ymwd.year(), ymwd.month()) + dm&lt;/code&gt; and the same &lt;code&gt;weekday()&lt;/code&gt; and &lt;code&gt;index()&lt;/code&gt; as &lt;code&gt;ymwd&lt;/code&gt;.</source>
          <target state="translated">1-2)를 추가의 &lt;code&gt;dm.count()&lt;/code&gt; 날짜에 개월로 표현 &lt;code&gt;ymwd&lt;/code&gt; . 결과는 &lt;code&gt;&lt;a href=&quot;../year_month&quot;&gt;std::chrono::year_month&lt;/a&gt;(ymwd.year(), ymwd.month()) + dm&lt;/code&gt; (ymwd.year (), ymwd.month ()) + dm 과 동일한 &lt;code&gt;year()&lt;/code&gt; 및 &lt;code&gt;month()&lt;/code&gt; 를 가지며 ymwd 와 동일한 &lt;code&gt;weekday()&lt;/code&gt; 및 &lt;code&gt;index()&lt;/code&gt; 를 &lt;code&gt;ymwd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad91641a690e3e5b3a00c371bdf3ac5dd3664f4f" translate="yes" xml:space="preserve">
          <source>1-2) Adds &lt;code&gt;dm.count()&lt;/code&gt; months to the date represented by &lt;code&gt;ymwdl&lt;/code&gt;. The result has the same &lt;code&gt;year()&lt;/code&gt; and &lt;code&gt;month()&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;../year_month&quot;&gt;std::chrono::year_month&lt;/a&gt;(ymwdl.year(), ymwdl.month()) + dm&lt;/code&gt; and the same &lt;code&gt;weekday()&lt;/code&gt; as &lt;code&gt;ymwdl&lt;/code&gt;.</source>
          <target state="translated">1-2)를 추가의 &lt;code&gt;dm.count()&lt;/code&gt; 날짜에 개월로 표현 &lt;code&gt;ymwdl&lt;/code&gt; . 결과는 동일이 &lt;code&gt;year()&lt;/code&gt; 와 &lt;code&gt;month()&lt;/code&gt; 와 같은 &lt;code&gt;&lt;a href=&quot;../year_month&quot;&gt;std::chrono::year_month&lt;/a&gt;(ymwdl.year(), ymwdl.month()) + dm&lt;/code&gt; 과 같은 &lt;code&gt;weekday()&lt;/code&gt; 로 &lt;code&gt;ymwdl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f73cd2c48e5b0378af135eef33b34adf60cd9e8" translate="yes" xml:space="preserve">
          <source>1-2) Adds &lt;code&gt;ds.count()&lt;/code&gt; days to &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">1-2) &lt;code&gt;ds.count()&lt;/code&gt; 일을 &lt;code&gt;d&lt;/code&gt; 에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="a045e1f041fc379a0e26a2d2e2c1c82e8b64710c" translate="yes" xml:space="preserve">
          <source>1-2) Adds &lt;code&gt;dy.count()&lt;/code&gt; years to &lt;code&gt;ym&lt;/code&gt;.</source>
          <target state="translated">1-2) &lt;code&gt;dy.count()&lt;/code&gt; 년을 &lt;code&gt;ym&lt;/code&gt; 에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="e014a62ddcac0d2bab53929c476afb95ccdb378c" translate="yes" xml:space="preserve">
          <source>1-2) Adds &lt;code&gt;ms.count()&lt;/code&gt; months to &lt;code&gt;m&lt;/code&gt;. The month value held in the result is computed by first evaluating &lt;code&gt;static_cast&amp;lt;long long&amp;gt;(unsigned(m)) + (ms.count() - 1)&lt;/code&gt;, reducing it modulo 12 to an integer in the range [0, 11], and then adding 1.</source>
          <target state="translated">1-2) &lt;code&gt;ms.count()&lt;/code&gt; 개월을 &lt;code&gt;m&lt;/code&gt; 에 추가합니다 . 결과에서 유지되는 월 값은 먼저 &lt;code&gt;static_cast&amp;lt;long long&amp;gt;(unsigned(m)) + (ms.count() - 1)&lt;/code&gt; 을 평가하여 모듈로 12를 [0, 11] 범위의 정수로 줄임으로써 계산됩니다. 그런 다음 1을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="149c203cc0fb13447ef0c946d21c4519fc03dc4b" translate="yes" xml:space="preserve">
          <source>1-2) Adds &lt;code&gt;ys.count()&lt;/code&gt; years to &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">1-2) &lt;code&gt;ys.count()&lt;/code&gt; 년을 &lt;code&gt;y&lt;/code&gt; 에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="8ad28a59bf3aeaed348ac3a64b954c319a8e81d9" translate="yes" xml:space="preserve">
          <source>1-2) An absolute path that resolves to the same file as &lt;code&gt;&lt;a href=&quot;absolute&quot;&gt;std::filesystem::absolute&lt;/a&gt;(p)&lt;/code&gt;.</source>
          <target state="translated">1-2) &lt;code&gt;&lt;a href=&quot;absolute&quot;&gt;std::filesystem::absolute&lt;/a&gt;(p)&lt;/code&gt; 와 동일한 파일로 해석되는 절대 경로입니다 .</target>
        </trans-unit>
        <trans-unit id="0582db9a6b1e43bc2f855e1d817858716edcbf3a" translate="yes" xml:space="preserve">
          <source>1-2) Any exception thrown by the copy constructor of &lt;code&gt;value&lt;/code&gt;</source>
          <target state="translated">1-2) &lt;code&gt;value&lt;/code&gt; 의 복사 생성자가 던진 예외</target>
        </trans-unit>
        <trans-unit id="aa59f8d3795a4690feef2635d0160f98c4073edd" translate="yes" xml:space="preserve">
          <source>1-2) Applies the offset &lt;code&gt;d&lt;/code&gt; to &lt;code&gt;pt&lt;/code&gt;. Effectively returns &lt;code&gt;CT(pt.time_since_epoch() + d)&lt;/code&gt;, where &lt;code&gt;CT&lt;/code&gt; is the return type.</source>
          <target state="translated">1-2) 오프셋 &lt;code&gt;d&lt;/code&gt; 를 &lt;code&gt;pt&lt;/code&gt; 에 적용합니다 . 효과적으로 반환 &lt;code&gt;CT(pt.time_since_epoch() + d)&lt;/code&gt; , &lt;code&gt;CT&lt;/code&gt; 는 리턴 타입이다.</target>
        </trans-unit>
        <trans-unit id="de9f0e0c97134f6c19bf1e0145ba1c6ea25b6b73" translate="yes" xml:space="preserve">
          <source>1-2) At most &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last) - n&lt;/code&gt; assignments.</source>
          <target state="translated">1-2) 최대 &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last) - n&lt;/code&gt; 할당.</target>
        </trans-unit>
        <trans-unit id="385f603cda235e226aadb2d7d04a39f42b4e7a01" translate="yes" xml:space="preserve">
          <source>1-2) Behaves as a &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;. After constructing and checking the sentry object, if &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;short&lt;/code&gt; or &lt;code&gt;int&lt;/code&gt;, then casts it to &lt;code&gt;unsigned short&lt;/code&gt; or &lt;code&gt;unsigned int&lt;/code&gt; if &lt;code&gt;ios_base::flags() &amp;amp; ios_base::basefield&lt;/code&gt; is &lt;code&gt;ios_base::oct&lt;/code&gt; or &lt;code&gt;ios_base::hex&lt;/code&gt;. After that, casts to &lt;code&gt;long&lt;/code&gt; in any case and outputs as in (3). If &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;unsigned short&lt;/code&gt; or &lt;code&gt;unsigned int&lt;/code&gt;, casts to &lt;code&gt;unsigned long&lt;/code&gt; and outputs as in (3).</source>
          <target state="translated">1-2) &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction으로&lt;/a&gt; 동작합니다 . 센트리 객체를 생성하고 확인한 후 &lt;code&gt;value&lt;/code&gt; 가 &lt;code&gt;short&lt;/code&gt; 또는 &lt;code&gt;int&lt;/code&gt; 인 경우 &lt;code&gt;ios_base::flags() &amp;amp; ios_base::basefield&lt;/code&gt; 가 &lt;code&gt;ios_base::oct&lt;/code&gt; 또는 &lt;code&gt;ios_base::hex&lt;/code&gt; 경우 &lt;code&gt;unsigned int&lt;/code&gt; &lt;code&gt;unsigned short&lt;/code&gt; 또는 unsigned int 로 캐스트합니다 . 그 후, 어떤 경우에도 &lt;code&gt;long&lt;/code&gt; 캐스팅하고 (3)과 같이 출력합니다. 경우 &lt;code&gt;value&lt;/code&gt; 이다 &lt;code&gt;unsigned short&lt;/code&gt; 또는 &lt;code&gt;unsigned int&lt;/code&gt; 에 캐스트 &lt;code&gt;unsigned long&lt;/code&gt; (3)과 같이 출력한다.</target>
        </trans-unit>
        <trans-unit id="ac246672a7fab374fe0384fed40e7b67970e1ea6" translate="yes" xml:space="preserve">
          <source>1-2) Checks if &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal, i.e. the number of ticks for the type common to both durations are equal.</source>
          <target state="translated">1-2) &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 가 같은지 확인합니다 . 즉, 두 기간에 공통적 인 유형의 진드기 수가 같은지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="29225099cfaa798ae84b05361d150f22ef479053" translate="yes" xml:space="preserve">
          <source>1-2) Checks if the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal, that is, they have the same number of elements and each element in &lt;code&gt;lhs&lt;/code&gt; compares equal with the element in &lt;code&gt;rhs&lt;/code&gt; at the same position.</source>
          <target state="translated">1-2) &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 의 내용 이 같은지 확인합니다. 즉, 같은 수의 요소를 가지며 &lt;code&gt;lhs&lt;/code&gt; 의 각 요소 가 같은 위치에 있는 &lt;code&gt;rhs&lt;/code&gt; 의 요소와 동일한 지 비교합니다 .</target>
        </trans-unit>
        <trans-unit id="647458f4e19581a3f6096017d300a740b53e0173" translate="yes" xml:space="preserve">
          <source>1-2) Checks if the contents of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal, that is, whether each element in &lt;code&gt;lhs&lt;/code&gt; compares equal with the element in &lt;code&gt;rhs&lt;/code&gt; at the same position.</source>
          <target state="translated">1-2) &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 의 내용 이 같은지 확인합니다. 즉, &lt;code&gt;lhs&lt;/code&gt; 의 각 요소 가 같은 위치에 있는 &lt;code&gt;rhs&lt;/code&gt; 의 요소와 같은지 여부를 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="3be57b484e717589a60856a3bb6e1783fe66d6d8" translate="yes" xml:space="preserve">
          <source>1-2) Checks if the time points &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; refer to the same time point for the given clock.</source>
          <target state="translated">1-2) 시점 &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 가 주어진 시계에 대해 동일한 시점을 참조 하는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="ed7870e213c9dd9cc2a70c98bf123d8cdc3fd801" translate="yes" xml:space="preserve">
          <source>1-2) Checks whether &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; represent either the same thread, or no thread.</source>
          <target state="translated">1-2) &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 가 같은 스레드인지 또는 스레드가 없는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="5c8927b43af687986b68645d9af638aec5053e6e" translate="yes" xml:space="preserve">
          <source>1-2) Checks whether the underlying &lt;code&gt;&lt;a href=&quot;../type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; objects refer to the same type.</source>
          <target state="translated">1-2) 기본 &lt;code&gt;&lt;a href=&quot;../type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; 객체가 동일한 유형을 참조 하는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="be6b0165d6b1d282b2f783a08ef3727d89b5863f" translate="yes" xml:space="preserve">
          <source>1-2) Compares every element of the tuple &lt;code&gt;lhs&lt;/code&gt; with the corresponding element of the tuple &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">1-2) 튜플 &lt;code&gt;lhs&lt;/code&gt; 의 모든 요소를 튜플 &lt;code&gt;rhs&lt;/code&gt; 의 해당 요소와 비교합니다 .</target>
        </trans-unit>
        <trans-unit id="893b1025589d1be98f98141054b7ba435b59173d" translate="yes" xml:space="preserve">
          <source>1-2) Constant if &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are of different size, otherwise linear in the size of the container</source>
          <target state="translated">1-2) &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 의 크기가 다른 경우 상수 , 그렇지 않으면 컨테이너 크기가 선형</target>
        </trans-unit>
        <trans-unit id="f99d01745dcdda3b2e468004a3c71e04376de329" translate="yes" xml:space="preserve">
          <source>1-2) Constant plus linear in the distance between &lt;code&gt;pos&lt;/code&gt; and end of the container.</source>
          <target state="translated">1-2) 컨테이너의 &lt;code&gt;pos&lt;/code&gt; 와 끝 사이의 거리에서 상수 + 선형 .</target>
        </trans-unit>
        <trans-unit id="3cfbb4c47a90f16a28b1264c7ee75a24d4766332" translate="yes" xml:space="preserve">
          <source>1-2) Constant plus linear in the lesser of the distances between &lt;code&gt;pos&lt;/code&gt; and either of the ends of the container.</source>
          <target state="translated">1-2) &lt;code&gt;pos&lt;/code&gt; 와 컨테이너 끝 사이의 거리가 작을수록 상수 + 선형 .</target>
        </trans-unit>
        <trans-unit id="1f6eb22269560b810ef9b717f27678828a9f8a6b" translate="yes" xml:space="preserve">
          <source>1-2) Constant.</source>
          <target state="translated">1-2) 상수.</target>
        </trans-unit>
        <trans-unit id="638695d7cb012c6de0dd4793c26033a3fff32ddd" translate="yes" xml:space="preserve">
          <source>1-2) Constructs a &lt;code&gt;shared_ptr&lt;/code&gt; with no managed object, i.e. empty &lt;code&gt;shared_ptr&lt;/code&gt;</source>
          <target state="translated">1-2) 관리 객체가없는 &lt;code&gt;shared_ptr&lt;/code&gt; 을 구성합니다 (예 : empty &lt;code&gt;shared_ptr&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7d19a0a93d10f7d17dd99c9fcfd410d90e6d7691" translate="yes" xml:space="preserve">
          <source>1-2) Converts path &lt;code&gt;p&lt;/code&gt; to a canonical absolute path, i.e. an absolute path that has no dot, dot-dot elements or symbolic links in its generic format representation. If &lt;code&gt;p&lt;/code&gt; is not an absolute path, the function behaves as if it is first made absolute by &lt;code&gt;&lt;a href=&quot;absolute&quot;&gt;std::filesystem::absolute&lt;/a&gt;(p)&lt;/code&gt;. The path &lt;code&gt;p&lt;/code&gt; must exist.</source>
          <target state="translated">1-2) 경로 &lt;code&gt;p&lt;/code&gt; 를 정식 절대 경로로 변환합니다 . 즉, 일반 형식으로 도트, 도트 요소 또는 기호 링크가없는 절대 경로로 변환합니다 . &lt;code&gt;p&lt;/code&gt; 가 절대 경로가 아닌 경우 , 함수는 &lt;code&gt;&lt;a href=&quot;absolute&quot;&gt;std::filesystem::absolute&lt;/a&gt;(p)&lt;/code&gt; 의해 처음 절대적인 것처럼 작동 합니다. 경로 &lt;code&gt;p&lt;/code&gt; 가 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="e43dccde26f78320e024b961291d9de2b5afa276" translate="yes" xml:space="preserve">
          <source>1-2) Creates an</source>
          <target state="translated">1-2)</target>
        </trans-unit>
        <trans-unit id="b7d200b85395189e7ca6260005b865f5acca728b" translate="yes" xml:space="preserve">
          <source>1-2) Effectively calls &lt;code&gt;rdbuf()-&amp;gt;open(filename, mode | ios_base::in)&lt;/code&gt;. (see &lt;code&gt;&lt;a href=&quot;../basic_filebuf/open&quot;&gt;std::basic_filebuf::open&lt;/a&gt;&lt;/code&gt; for the details on the effects of that call). Overload (2) is only provided if &lt;code&gt;std::filesystem::path::value_type&lt;/code&gt; is not &lt;code&gt;char&lt;/code&gt;.(since C++17)</source>
          <target state="translated">1-2) &lt;code&gt;rdbuf()-&amp;gt;open(filename, mode | ios_base::in)&lt;/code&gt; )을 효과적으로 호출합니다 . 해당 호출의 영향에 대한 자세한 내용 은 &lt;code&gt;&lt;a href=&quot;../basic_filebuf/open&quot;&gt;std::basic_filebuf::open&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 . 오버로드 (2)는 &lt;code&gt;std::filesystem::path::value_type&lt;/code&gt; 이 &lt;code&gt;char&lt;/code&gt; 이 아닌 경우에만 제공됩니다 (C ++ 17부터)</target>
        </trans-unit>
        <trans-unit id="4fb0a225c672a02310598d2ec771dd646d88195f" translate="yes" xml:space="preserve">
          <source>1-2) Effectively calls &lt;code&gt;rdbuf()-&amp;gt;open(filename, mode | ios_base::out)&lt;/code&gt;. (see &lt;code&gt;&lt;a href=&quot;../basic_filebuf/open&quot;&gt;std::basic_filebuf::open&lt;/a&gt;&lt;/code&gt; for the details on the effects of that call). Overload (2) is only provided if &lt;code&gt;std::filesystem::path::value_type&lt;/code&gt; is not &lt;code&gt;char&lt;/code&gt;.(since C++17)</source>
          <target state="translated">1-2) &lt;code&gt;rdbuf()-&amp;gt;open(filename, mode | ios_base::out)&lt;/code&gt; )을 효과적으로 호출합니다 . 해당 호출의 영향에 대한 자세한 내용 은 &lt;code&gt;&lt;a href=&quot;../basic_filebuf/open&quot;&gt;std::basic_filebuf::open&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 . 오버로드 (2)는 &lt;code&gt;std::filesystem::path::value_type&lt;/code&gt; 이 &lt;code&gt;char&lt;/code&gt; 이 아닌 경우에만 제공됩니다 (C ++ 17부터).</target>
        </trans-unit>
        <trans-unit id="330722813017e009abd7fcbbe279aea07d1d1334" translate="yes" xml:space="preserve">
          <source>1-2) Effectively calls &lt;code&gt;rdbuf()-&amp;gt;open(filename, mode)&lt;/code&gt;. (see &lt;code&gt;&lt;a href=&quot;../basic_filebuf/open&quot;&gt;std::basic_filebuf::open&lt;/a&gt;&lt;/code&gt; for the details on the effects of that call). Overload (2) is only provided if &lt;code&gt;std::filesystem::path::value_type&lt;/code&gt; is not &lt;code&gt;char&lt;/code&gt;.(since C++17)</source>
          <target state="translated">1-2) &lt;code&gt;rdbuf()-&amp;gt;open(filename, mode)&lt;/code&gt; )를 효과적으로 호출 합니다 . 해당 호출의 영향에 대한 자세한 내용 은 &lt;code&gt;&lt;a href=&quot;../basic_filebuf/open&quot;&gt;std::basic_filebuf::open&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 . 오버로드 (2)는 &lt;code&gt;std::filesystem::path::value_type&lt;/code&gt; 이 &lt;code&gt;char&lt;/code&gt; 이 아닌 경우에만 제공됩니다 (C ++ 17부터).</target>
        </trans-unit>
        <trans-unit id="a09a6f5190f999dc28cc0e2c8a73da43426fea0e" translate="yes" xml:space="preserve">
          <source>1-2) Exactly &lt;code&gt;(last - first)&lt;/code&gt; assignments</source>
          <target state="translated">1-2) 정확히 &lt;code&gt;(last - first)&lt;/code&gt; 과제</target>
        </trans-unit>
        <trans-unit id="d658f6029d585f7fb3b7e8ae236a026a1adb88bd" translate="yes" xml:space="preserve">
          <source>1-2) Exactly &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1)&lt;/code&gt; applications of &lt;code&gt;unary_op&lt;/code&gt;</source>
          <target state="translated">1-2) 정확히 &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1)&lt;/code&gt; 의 응용 &lt;code&gt;unary_op&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d7c29703dc52dff052e13256c3ce68aacc9bdd6c" translate="yes" xml:space="preserve">
          <source>1-2) Exactly one comparison</source>
          <target state="translated">1-2) 정확히 하나의 비교</target>
        </trans-unit>
        <trans-unit id="d439c8f67b583ee4c368d89643a7e0f747e4c39d" translate="yes" xml:space="preserve">
          <source>1-2) Inserts &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">1-2) &lt;code&gt;value&lt;/code&gt; 삽입 합니다 .</target>
        </trans-unit>
        <trans-unit id="ef5b99c9a79111d93a3c358bd3c6ec8a0c19dbf5" translate="yes" xml:space="preserve">
          <source>1-2) Inserts &lt;code&gt;value&lt;/code&gt;. If the container has elements with equivalent key, inserts at the upper bound of that range.(since C++11).</source>
          <target state="translated">1-2) &lt;code&gt;value&lt;/code&gt; 삽입 합니다 . 컨테이너에 동등한 키를 가진 요소가있는 경우 해당 범위의 상한에 삽입합니다 (C ++ 11부터).</target>
        </trans-unit>
        <trans-unit id="dedbd5f7a8031073bf192beac0f89406b02d76d1" translate="yes" xml:space="preserve">
          <source>1-2) Inserts &lt;code&gt;value&lt;/code&gt;. The overload (2) is equivalent to &lt;code&gt;emplace(&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;P&amp;gt;(value))&lt;/code&gt; and only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;value_type, P&amp;amp;&amp;amp;&amp;gt;::value == true&lt;/code&gt;.</source>
          <target state="translated">1-2) &lt;code&gt;value&lt;/code&gt; 삽입 합니다 . 과부하 (2)는 &lt;code&gt;emplace(&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;P&amp;gt;(value))&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;value_type, P&amp;amp;&amp;amp;&amp;gt;::value == true&lt;/code&gt; 경우에만 과부하 해결에 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="a7fef73a15863392d3c49069be1004d27772be84" translate="yes" xml:space="preserve">
          <source>1-2) Iterator following the last removed element.</source>
          <target state="translated">1-2) 마지막으로 제거 된 요소 다음의 반복자.</target>
        </trans-unit>
        <trans-unit id="87c273ede43fd7f5f09371d89f430a73ee15f72e" translate="yes" xml:space="preserve">
          <source>1-2) Iterator pointing to the inserted &lt;code&gt;value&lt;/code&gt;</source>
          <target state="translated">1-2) 삽입 된 &lt;code&gt;value&lt;/code&gt; 가리키는 반복자</target>
        </trans-unit>
        <trans-unit id="fab5e7a409efe5e093ac277415b7e37130852337" translate="yes" xml:space="preserve">
          <source>1-2) Iterator to the inserted element.</source>
          <target state="translated">1-2) 삽입 된 요소에 대한 반복자.</target>
        </trans-unit>
        <trans-unit id="e5d0c04a63dab0ccb661872febe15ebc8227eed3" translate="yes" xml:space="preserve">
          <source>1-2) Linear in the size of the container</source>
          <target state="translated">1-2) 컨테이너 크기의 선형</target>
        </trans-unit>
        <trans-unit id="66a437d5d90df9da294c056007b1745ff58c08cb" translate="yes" xml:space="preserve">
          <source>1-2) Logarithmic in the size of the container, &lt;code&gt;O(log(size()))&lt;/code&gt;.</source>
          <target state="translated">1-2) 컨테이너 크기의 &lt;code&gt;O(log(size()))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63cc908d997871f8313696d35a19e1c9a0aac913" translate="yes" xml:space="preserve">
          <source>1-2) Number of characters written if successful or a negative value if an error occurred.</source>
          <target state="translated">1-2) 성공하면 기록 된 문자 수 또는 오류가 발생하면 음수 값.</target>
        </trans-unit>
        <trans-unit id="496eed03a79ef403e4d30a2ae70591b4f07d9584" translate="yes" xml:space="preserve">
          <source>1-2) Performs &lt;code&gt;*this += &lt;a href=&quot;../duration&quot;&gt;std::chrono::days&lt;/a&gt;{1};&lt;/code&gt;</source>
          <target state="translated">1-2) &lt;code&gt;*this += &lt;a href=&quot;../duration&quot;&gt;std::chrono::days&lt;/a&gt;{1};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="870885f4dad23e212213bcee39d167d5d122e4ce" translate="yes" xml:space="preserve">
          <source>1-2) Performs &lt;code&gt;*this += &lt;a href=&quot;../duration&quot;&gt;std::chrono::months&lt;/a&gt;{1};&lt;/code&gt;</source>
          <target state="translated">1-2) &lt;code&gt;*this += &lt;a href=&quot;../duration&quot;&gt;std::chrono::months&lt;/a&gt;{1};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee3a6c57b786f2e1d515c8f9035a3a58bc7544d1" translate="yes" xml:space="preserve">
          <source>1-2) Performs &lt;code&gt;*this += &lt;a href=&quot;../duration&quot;&gt;std::chrono::years&lt;/a&gt;{1};&lt;/code&gt;</source>
          <target state="translated">1-2) &lt;code&gt;*this += &lt;a href=&quot;../duration&quot;&gt;std::chrono::years&lt;/a&gt;{1};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c431c30e913bd8d07140a7246741190456f000e9" translate="yes" xml:space="preserve">
          <source>1-2) Performs binary shift left. The (2) version is destructive, i.e. performs the shift to the current object.</source>
          <target state="translated">1-2) 이진 시프트를 왼쪽으로 수행합니다. (2) 버전은 파괴적입니다. 즉, 현재 객체로의 이동을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="989851ad329753ae61fdbaffaf63f506bd4c5356" translate="yes" xml:space="preserve">
          <source>1-2) Performs character input operations.</source>
          <target state="translated">1-2) 문자 입력 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="20dcec71132721d5eb472a87e6bf895f860f359d" translate="yes" xml:space="preserve">
          <source>1-2) Pre-increments or pre-decrements by one respectively.</source>
          <target state="translated">1-2) 각각 사전 증분 또는 사전 증감.</target>
        </trans-unit>
        <trans-unit id="bbe1f0b228bf4c6b697a8551aa608ec76d0466ae" translate="yes" xml:space="preserve">
          <source>1-2) Public member function, calls the member function &lt;code&gt;do_truename&lt;/code&gt; and &lt;code&gt;do_falsename&lt;/code&gt; of the most derived class respectively.</source>
          <target state="translated">1-2) 공용 멤버 함수, 가장 파생 된 클래스 의 멤버 함수 &lt;code&gt;do_truename&lt;/code&gt; 및 &lt;code&gt;do_falsename&lt;/code&gt; 을 각각 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="2d11044294d8923f4415babac3e0ed29d2fcbf36" translate="yes" xml:space="preserve">
          <source>1-2) Public member functions, call the member function &lt;code&gt;do_get&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1-2) 공개 멤버 함수, 가장 파생 된 클래스 의 멤버 함수 &lt;code&gt;do_get&lt;/code&gt; 을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="7097fc08592150da92619737e1d105eab77c6ce5" translate="yes" xml:space="preserve">
          <source>1-2) Public member functions, call the member function &lt;code&gt;do_put&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1-2) 공개 멤버 함수, 가장 파생 된 클래스 의 멤버 함수 &lt;code&gt;do_put&lt;/code&gt; 을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="3c06168350455217f4de3cb946f2530345de50c9" translate="yes" xml:space="preserve">
          <source>1-2) Returns &lt;code&gt;c.size()&lt;/code&gt;, converted to the return type if necessary.</source>
          <target state="translated">1-2) 필요한 경우 반환 유형으로 변환 된 &lt;code&gt;c.size()&lt;/code&gt; )를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="a80124eec7199178c02bed35d82e669f65b64762" translate="yes" xml:space="preserve">
          <source>1-2) Returns &lt;code&gt;static_cast&amp;lt;T&amp;gt;(*std::any_cast&amp;lt;U&amp;gt;(&amp;amp;operand))&lt;/code&gt;</source>
          <target state="translated">1-2) &lt;code&gt;static_cast&amp;lt;T&amp;gt;(*std::any_cast&amp;lt;U&amp;gt;(&amp;amp;operand))&lt;/code&gt; 반환합니다</target>
        </trans-unit>
        <trans-unit id="f46aa168564faccc13e7683cec8e11bb1bd77a3e" translate="yes" xml:space="preserve">
          <source>1-2) Returns a copy of the output iterator &lt;code&gt;out&lt;/code&gt; after all the insertions.</source>
          <target state="translated">1-2) 출력 반복자의 카피를 돌려줍니다 &lt;code&gt;out&lt;/code&gt; 모든 삽입 후.</target>
        </trans-unit>
        <trans-unit id="c60e0824bdaab94bd250fcc4674400fb0f9e7ef8" translate="yes" xml:space="preserve">
          <source>1-2) Returns a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a &lt;code&gt;bool&lt;/code&gt; denoting whether the insertion took place.</source>
          <target state="translated">1-2) 삽입 된 요소 (또는 삽입을 방해 한 요소)와 삽입이 발생했는지 여부를 나타내는 &lt;code&gt;bool&lt;/code&gt; 에 대한 반복자로 구성된 쌍을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ad285ec68ceb778c24fc32166b05a6cc5d3f0c20" translate="yes" xml:space="preserve">
          <source>1-2) Returns a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a &lt;code&gt;bool&lt;/code&gt; value set to &lt;code&gt;true&lt;/code&gt; if the insertion took place.</source>
          <target state="translated">1-2) 삽입 된 요소 (또는 삽입을 방해 한 요소)와 반복이 발생하면 &lt;code&gt;bool&lt;/code&gt; 값이 &lt;code&gt;true&lt;/code&gt; 로 설정된 반복자로 구성된 쌍을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="331ed2018353fc552a4bce10159d1552a77e1e9a" translate="yes" xml:space="preserve">
          <source>1-2) Returns references to the smaller and the greater of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">1-2) &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 중 작거나 큰 참조를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="b242463e13bb0771c6dc3412fd969dc771061ee2" translate="yes" xml:space="preserve">
          <source>1-2) Returns the absolute path of the current working directory, obtained as if (in native format) by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/getcwd.html&quot;&gt;getcwd&lt;/a&gt;. (2) returns &lt;code&gt;path()&lt;/code&gt; if error occurs.</source>
          <target state="translated">1-2) POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/getcwd.html&quot;&gt;getcwd에&lt;/a&gt; 의해 (기본 형식으로) 얻은 현재 작업 디렉토리의 절대 경로를 리턴합니다 . (2)는 오류가 발생하면 &lt;code&gt;path()&lt;/code&gt; )를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="6e4da42e00020ffbd8ac2b7125cd1a0dbc2ac24f" translate="yes" xml:space="preserve">
          <source>1-2) Returns the current working directory.</source>
          <target state="translated">1-2) 현재 작업 디렉토리를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0a020f83cf4f40efe786313c1e1a737bb8995d20" translate="yes" xml:space="preserve">
          <source>1-2) Returns the greater of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">1-2) &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 중 큰 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="edd8b379a4f6731f986b8f77943eae325e5d3d03" translate="yes" xml:space="preserve">
          <source>1-2) Returns the result of &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;const T&amp;amp;, const T&amp;amp;&amp;gt;(a, b)&lt;/code&gt; if &lt;code&gt;a&amp;lt;b&lt;/code&gt; or if &lt;code&gt;a&lt;/code&gt; is equivalent to &lt;code&gt;b&lt;/code&gt;. Returns the result of &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;const T&amp;amp;, const T&amp;amp;&amp;gt;(b, a)&lt;/code&gt; if &lt;code&gt;b&amp;lt;a&lt;/code&gt;.</source>
          <target state="translated">1-2)의 결과를 반환 &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;const T&amp;amp;, const T&amp;amp;&amp;gt;(a, b)&lt;/code&gt; 의 경우 &lt;code&gt;a&amp;lt;b&lt;/code&gt; 또는 만약 &lt;code&gt;a&lt;/code&gt; 동등 &lt;code&gt;b&lt;/code&gt; . 반환 결과 &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;const T&amp;amp;, const T&amp;amp;&amp;gt;(b, a)&lt;/code&gt; 의 경우 &lt;code&gt;b&amp;lt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="565f986ed9381fbd9401f9ac6206f4ff623cdd9c" translate="yes" xml:space="preserve">
          <source>1-2) Returns the smaller of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">1-2) &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 중 작은 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="71f2c4c4609ddbb2c828cbe5c963a249833bf93f" translate="yes" xml:space="preserve">
          <source>1-2) Sets the</source>
          <target state="translated">1-2) 설정</target>
        </trans-unit>
        <trans-unit id="701829eb696b713ce35031de09f05c22f4f07652" translate="yes" xml:space="preserve">
          <source>1-2) Tests if both elements of lhs and rhs are equal, that is, compares &lt;code&gt;lhs.first&lt;/code&gt; with &lt;code&gt;rhs.first&lt;/code&gt; and &lt;code&gt;lhs.second&lt;/code&gt; with &lt;code&gt;rhs.second&lt;/code&gt;</source>
          <target state="translated">1-2) lhs와 rhs의 요소가 모두 같은지 테스트합니다. 즉, &lt;code&gt;lhs.first&lt;/code&gt; 를 &lt;code&gt;rhs.first&lt;/code&gt; 와 &lt;code&gt;lhs.second&lt;/code&gt; 와 &lt;code&gt;rhs.second&lt;/code&gt; 와 비교합니다.</target>
        </trans-unit>
        <trans-unit id="02628c710208503904199e69623c873a25527910" translate="yes" xml:space="preserve">
          <source>1-2) The behavior is undefined unless &lt;code&gt;static_cast&amp;lt;T*&amp;gt;((U*)nullptr)&lt;/code&gt; is well formed.</source>
          <target state="translated">1-2) &lt;code&gt;static_cast&amp;lt;T*&amp;gt;((U*)nullptr)&lt;/code&gt; 가 제대로 형성 되지 않으면 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="dd9530bbeab55d695f1b09171406b3194a0ce076" translate="yes" xml:space="preserve">
          <source>1-2) The end of the resulting range. If &lt;code&gt;n&lt;/code&gt; is positive and less than &lt;code&gt;last - first&lt;/code&gt;, returns &lt;code&gt;first + (last - first - n)&lt;/code&gt;. Otherwise if &lt;code&gt;n&lt;/code&gt; is positive, returns &lt;code&gt;first&lt;/code&gt;. Otherwise, returns &lt;code&gt;last&lt;/code&gt;.</source>
          <target state="translated">1-2) 결과 범위의 끝. 경우 &lt;code&gt;n&lt;/code&gt; 긍정적 인 미만입니다 &lt;code&gt;last - first&lt;/code&gt; , 반환 &lt;code&gt;first + (last - first - n)&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;n&lt;/code&gt; 이 양수이면 &lt;code&gt;first&lt;/code&gt; 를 반환합니다 . 그렇지 않으면 &lt;code&gt;last&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="dcc4fe100ff6b090d466d216596c515ba86b4576" translate="yes" xml:space="preserve">
          <source>1-2) The greater of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. If they are equivalent, returns &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">1-2) &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 중 큰 것 . 같으면를 반환 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="591a025fcbecc3dd078ee4cf02c3132af9eb840a" translate="yes" xml:space="preserve">
          <source>1-2) The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">1-2) &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 매개 변수 를 사용하지 않는 과부하 는 OS 오류 코드를 오류 코드 인수로 사용하여 기본 OS API 오류에서 &lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다. &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 매개 변수 를 사용하는 과부하 는 OS API 호출이 실패하면이를 OS API 오류 코드로 설정하고 오류가 발생하지 않으면 &lt;code&gt;ec.clear()&lt;/code&gt; 실행 합니다. &lt;code&gt;noexcept&lt;/code&gt; 로 표시되지 않은 과부하 는 메모리 할당에 실패하면 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 발생 시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c9ea8d2b331e2468b1f5c23b90820bd9f1a9c747" translate="yes" xml:space="preserve">
          <source>1-2) The smaller of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. If the values are equivalent, returns &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">1-2) &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 중 작은 것 . 값이 같으면를 반환 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="175dbcf028b5b47b00d80cb62735349b92dddb8d" translate="yes" xml:space="preserve">
          <source>1-2) These overloads only participate in overload resolution if &lt;code&gt;to_stream(&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;amp;&amp;gt;(), fmt, s)&lt;/code&gt; is a valid expression.</source>
          <target state="translated">1-2) &lt;code&gt;to_stream(&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;amp;&amp;gt;(), fmt, s)&lt;/code&gt; 이 유효한 표현식 인 경우 이러한 과부하는 과부하 해결에만 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="40f34a651805261c82589aac7faa2a8077d8951b" translate="yes" xml:space="preserve">
          <source>1-2) inserts &lt;code&gt;value&lt;/code&gt; after the element pointed to by &lt;code&gt;pos&lt;/code&gt;</source>
          <target state="translated">1-2) &lt;code&gt;pos&lt;/code&gt; 가 가리키는 요소 뒤에 &lt;code&gt;value&lt;/code&gt; 을 삽입</target>
        </trans-unit>
        <trans-unit id="e2f13a09374bb315b954eba0990065f1e7fef38d" translate="yes" xml:space="preserve">
          <source>1-2) inserts &lt;code&gt;value&lt;/code&gt; before &lt;code&gt;pos&lt;/code&gt;</source>
          <target state="translated">1-2) &lt;code&gt;pos&lt;/code&gt; 앞에 &lt;code&gt;value&lt;/code&gt; 을 삽입</target>
        </trans-unit>
        <trans-unit id="7768dc5705fde606a28f606814b48bc0d3d95cb9" translate="yes" xml:space="preserve">
          <source>1-2) inserts &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">1-2) &lt;code&gt;value&lt;/code&gt; 삽입 합니다 .</target>
        </trans-unit>
        <trans-unit id="4f610b756b2673935eaec211501b752b5c577cdd" translate="yes" xml:space="preserve">
          <source>1-2) inserts &lt;code&gt;value&lt;/code&gt;. If the container has elements with equivalent key, inserts at the upper bound of that range.(since C++11) The overload (2) is equivalent to &lt;code&gt;emplace(&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;P&amp;gt;(value))&lt;/code&gt; and only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;value_type, P&amp;amp;&amp;amp;&amp;gt;::value == true&lt;/code&gt;.</source>
          <target state="translated">1-2) &lt;code&gt;value&lt;/code&gt; 삽입 합니다 . 컨테이너에 동등한 키를 가진 요소가있는 경우 해당 범위의 상한에 삽입합니다. (C ++ 11부터) 과부하 (2)는 &lt;code&gt;emplace(&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;P&amp;gt;(value))&lt;/code&gt; 와 동일하며 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;value_type, P&amp;amp;&amp;amp;&amp;gt;::value == true&lt;/code&gt; 경우 과부하 해결 .</target>
        </trans-unit>
        <trans-unit id="117fa595f5245c4a08788aca11988d1a0cbdb392" translate="yes" xml:space="preserve">
          <source>1-2) inserts &lt;code&gt;value&lt;/code&gt;. The overload (2) is equivalent to &lt;code&gt;emplace(&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;P&amp;gt;(value))&lt;/code&gt; and only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;value_type, P&amp;amp;&amp;amp;&amp;gt;::value == true&lt;/code&gt;.</source>
          <target state="translated">1-2) &lt;code&gt;value&lt;/code&gt; 삽입 합니다 . 과부하 (2)는 &lt;code&gt;emplace(&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;P&amp;gt;(value))&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;value_type, P&amp;amp;&amp;amp;&amp;gt;::value == true&lt;/code&gt; 경우에만 과부하 해결에 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="7bf413a62218bd7b906cdbf14de99d9de54d8630" translate="yes" xml:space="preserve">
          <source>1-2)&lt;code&gt;!f&lt;/code&gt;</source>
          <target state="translated">1-2)&lt;code&gt;!f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="353736946469e093b0763bc23fd5322bbec2b542" translate="yes" xml:space="preserve">
          <source>1-2)&lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">1-2)&lt;code&gt;*this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9acbdf00394cf2631973047249dad62887713943" translate="yes" xml:space="preserve">
          <source>1-2)&lt;code&gt;&lt;a href=&quot;../day&quot;&gt;std::chrono::day&lt;/a&gt;(unsigned(d) + ds.count())&lt;/code&gt;</source>
          <target state="translated">1-2) &lt;code&gt;&lt;a href=&quot;../day&quot;&gt;std::chrono::day&lt;/a&gt;(unsigned(d) + ds.count())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cc565268feb18c8c44e7eace30022303e53dca7e" translate="yes" xml:space="preserve">
          <source>1-2)&lt;code&gt;&lt;a href=&quot;../year&quot;&gt;std::chrono::year&lt;/a&gt;(int(y) + ys.count())&lt;/code&gt;</source>
          <target state="translated">1-2) &lt;code&gt;&lt;a href=&quot;../year&quot;&gt;std::chrono::year&lt;/a&gt;(int(y) + ys.count())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ffd40125d92b62cf639ab483ce9243fa253c8dc9" translate="yes" xml:space="preserve">
          <source>1-2)&lt;code&gt;&lt;a href=&quot;../year_month&quot;&gt;std::chrono::year_month&lt;/a&gt;(ym.year() + dy, ym.month())&lt;/code&gt;</source>
          <target state="translated">1-2) &lt;code&gt;&lt;a href=&quot;../year_month&quot;&gt;std::chrono::year_month&lt;/a&gt;(ym.year() + dy, ym.month())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="199db59cc5b75eb3d65420bb340b8792af6ea97b" translate="yes" xml:space="preserve">
          <source>1-2)&lt;code&gt;out&lt;/code&gt;</source>
          <target state="translated">1-2)&lt;code&gt;out&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a6a5528ad5c59c5146dbf5445fbe7e4617415ac" translate="yes" xml:space="preserve">
          <source>1-2)&lt;code&gt;static_cast&amp;lt;Y*&amp;gt;(r.get())&lt;/code&gt;.</source>
          <target state="translated">1-2)&lt;code&gt;static_cast&amp;lt;Y*&amp;gt;(r.get())&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="15744be05a6026bd1fb14bfc81fc5f5b3cb0974d" translate="yes" xml:space="preserve">
          <source>1-2)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;../../utility/functional/invoke&quot;&gt;std::invoke&lt;/a&gt;(pred, &lt;a href=&quot;../../utility/functional/invoke&quot;&gt;std::invoke&lt;/a&gt;(proj, *i)) != false&lt;/code&gt; for every iterator &lt;code&gt;i&lt;/code&gt; in the range, &lt;code&gt;false&lt;/code&gt; otherwise. Returns &lt;code&gt;true&lt;/code&gt; if the range is empty.</source>
          <target state="translated">1-2) &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;&lt;a href=&quot;../../utility/functional/invoke&quot;&gt;std::invoke&lt;/a&gt;(pred, &lt;a href=&quot;../../utility/functional/invoke&quot;&gt;std::invoke&lt;/a&gt;(proj, *i)) != false&lt;/code&gt; 모든 반복자에 대한 &lt;code&gt;i&lt;/code&gt; 범위, &lt;code&gt;false&lt;/code&gt; 그렇지 않은 경우는. 범위가 비어 있으면 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="7c0ba7563fb3ea13a9c1cd8a2d984ed91276c192" translate="yes" xml:space="preserve">
          <source>1-2)&lt;code&gt;true&lt;/code&gt; if unary predicate returns &lt;code&gt;true&lt;/code&gt; for all elements in the range, &lt;code&gt;false&lt;/code&gt; otherwise. Returns &lt;code&gt;true&lt;/code&gt; if the range is empty.</source>
          <target state="translated">1-2) 단항 술어가 범위 내의 모든 요소에 대해 &lt;code&gt;true&lt;/code&gt; 를 리턴하면 &lt;code&gt;true&lt;/code&gt; 이고 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다. 범위가 비어 있으면 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="9bee36d7c9c9081378f1cbd43014d80ca8a4ae52" translate="yes" xml:space="preserve">
          <source>1-21-arg</source>
          <target state="translated">1-21-arg</target>
        </trans-unit>
        <trans-unit id="1115e90d5f3a4cef60683ff67168616612ac07b7" translate="yes" xml:space="preserve">
          <source>1-3) A &lt;code&gt;std::chrono::month&lt;/code&gt; holding a month value calculated as described above.</source>
          <target state="translated">1-3) &lt;code&gt;std::chrono::month&lt;/code&gt; 는 위에서 설명한대로 계산 된 월 값을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="82f0f53b908ce6209371179207308b050420b724" translate="yes" xml:space="preserve">
          <source>1-3) A &lt;code&gt;std::chrono::weekday&lt;/code&gt; holding a weekday value calculated as described above.</source>
          <target state="translated">1-3) 위에서 설명한 평일 값을 보유한 &lt;code&gt;std::chrono::weekday&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0d044b179aa515892143c29139d66c58b602099" translate="yes" xml:space="preserve">
          <source>1-3) Atomically stores the &lt;code&gt;value&lt;/code&gt; into the shared state and makes the state ready.</source>
          <target state="translated">1-3) &lt;code&gt;value&lt;/code&gt; 을 공유 상태로 원자 적으로 저장 하고 상태를 준비합니다.</target>
        </trans-unit>
        <trans-unit id="8228d7162166c6ff4da8c2e4c344fa849da5f015" translate="yes" xml:space="preserve">
          <source>1-3) Categorizes floating point value &lt;code&gt;arg&lt;/code&gt; into the following categories: zero, subnormal, normal, infinite, NAN, or implementation-defined category.</source>
          <target state="translated">1-3) 부동 소수점 값 &lt;code&gt;arg&lt;/code&gt; 를 0, subnormal, normal, infinite, NAN 또는 구현 정의 범주로 분류합니다.</target>
        </trans-unit>
        <trans-unit id="dae8c32065b60746849bf2981074f769a7e085b2" translate="yes" xml:space="preserve">
          <source>1-3) Compares &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; for equality.</source>
          <target state="translated">1-3) &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 가 동일한 지 비교 합니다.</target>
        </trans-unit>
        <trans-unit id="0fb3c464483c04558978ff1fe117799e7f6c93e2" translate="yes" xml:space="preserve">
          <source>1-3) Composes a floating point value with the magnitude of &lt;code&gt;x&lt;/code&gt; and the sign of &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be8c18918f715dc0fbe5e5dec1f460e7e8209c0c" translate="yes" xml:space="preserve">
          <source>1-3) Computes 2 raised to the given power &lt;code&gt;n&lt;/code&gt;</source>
          <target state="translated">1-3) 주어진 전력 &lt;code&gt;n&lt;/code&gt; 으로 올린 계산 2</target>
        </trans-unit>
        <trans-unit id="0b10a66a66532d88bb36cf5fe638ed44244ef518" translate="yes" xml:space="preserve">
          <source>1-3) Computes &lt;code&gt;(x*y) + z&lt;/code&gt; as if to infinite precision and rounded only once to fit the result type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec09bb7fce8f096cf07decbf68f79251eef058ba" translate="yes" xml:space="preserve">
          <source>1-3) Computes &lt;code&gt;a+t*(b&amp;minus;a)&lt;/code&gt;, i.e. the linear interpolation between &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for the parameter &lt;code&gt;t&lt;/code&gt; (or extrapolation, when &lt;code&gt;t&lt;/code&gt; is outside the range &lt;code&gt;[0,1]&lt;/code&gt;).</source>
          <target state="translated">1-3) &lt;code&gt;a+t*(b&amp;minus;a)&lt;/code&gt; )를 계산 합니다 . 즉 , 매개 변수 &lt;code&gt;t&lt;/code&gt; 에 대한 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 사이의 선형 보간 (또는 &lt;code&gt;t&lt;/code&gt; 가 &lt;code&gt;[0,1]&lt;/code&gt; 범위를 벗어난 경우 외삽 )을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="cb4e1327f200ae7d7407d29650e99a70248ee6d7" translate="yes" xml:space="preserve">
          <source>1-3) Computes complex &lt;code&gt;x&lt;/code&gt; raised to a complex power &lt;code&gt;y&lt;/code&gt; with a branch cut along the negative real axis for the first argument.</source>
          <target state="translated">1-3) 첫 번째 인수에 대해 음의 실수 축을 따라 분기 컷 으로 복소수 &lt;code&gt;y&lt;/code&gt; 로 올린 복소수 &lt;code&gt;x&lt;/code&gt; 를 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="28ec09da0b6641bd12fea6733e03810bd776a300" translate="yes" xml:space="preserve">
          <source>1-3) Computes the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb6f10d2f6b403145a1a98fbc35f27750ea24259" translate="yes" xml:space="preserve">
          <source>1-3) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Complementary_error_function&quot;&gt;complementary error function&lt;/a&gt; of &lt;code&gt;arg&lt;/code&gt;, that is &lt;code&gt;1.0-erf(arg)&lt;/code&gt;, but without loss of precision for large &lt;code&gt;arg&lt;/code&gt;</source>
          <target state="translated">1-3)을 계산 &lt;a href=&quot;https://en.wikipedia.org/wiki/Complementary_error_function&quot;&gt;상보 오차 함수&lt;/a&gt; 의 &lt;code&gt;arg&lt;/code&gt; 인, &lt;code&gt;1.0-erf(arg)&lt;/code&gt; 하지만, 큰 정밀도의 손실없이 &lt;code&gt;arg&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="97251e58129990d405a20b926849ead40fb0049e" translate="yes" xml:space="preserve">
          <source>1-3) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Error_function&quot;&gt;error function&lt;/a&gt; of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f537c5d69e850d077ca503d3ae6dc365cd7f23e0" translate="yes" xml:space="preserve">
          <source>1-3) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Gamma_function&quot;&gt;gamma function&lt;/a&gt; of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06fb2522f313d7443f8ff5ed057df67c62229bb0" translate="yes" xml:space="preserve">
          <source>1-3) Computes the IEEE remainder of the floating point division operation &lt;code&gt;x/y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c81dd03c2b6fc6f836c4d892752e7e2ab9381fd1" translate="yes" xml:space="preserve">
          <source>1-3) Computes the arc tangent of &lt;code&gt;y/x&lt;/code&gt; using the signs of arguments to determine the correct quadrant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ee042c421e53a946fb989bf545f4021a624bb36" translate="yes" xml:space="preserve">
          <source>1-3) Computes the binary (base-</source>
          <target state="translated">1-3) 이진을 계산합니다 (기본-</target>
        </trans-unit>
        <trans-unit id="5c8f047806cca3758bc70d1feb8b6bd1e2f2df15" translate="yes" xml:space="preserve">
          <source>1-3) Computes the common (base-</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65d8a20bcbf6a9507496a6f8360d5d0ce58b7891" translate="yes" xml:space="preserve">
          <source>1-3) Computes the cosine of &lt;code&gt;arg&lt;/code&gt; (measured in radians).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a04ca7b947ef0432a97ce2c9c9402dd97bf3715" translate="yes" xml:space="preserve">
          <source>1-3) Computes the cubic root of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="952ce6bc11e689242d527f480055719f73d8e7c7" translate="yes" xml:space="preserve">
          <source>1-3) Computes the floating-point remainder of the division operation &lt;code&gt;x/y&lt;/code&gt; as the &lt;code&gt;&lt;a href=&quot;remainder&quot;&gt;std::remainder()&lt;/a&gt;&lt;/code&gt; function does. Additionally, the sign and at least the three of the last bits of &lt;code&gt;x/y&lt;/code&gt; will be stored in &lt;code&gt;quo&lt;/code&gt;, sufficient to determine the octant of the result within a period.</source>
          <target state="translated">1-3) &lt;code&gt;&lt;a href=&quot;remainder&quot;&gt;std::remainder()&lt;/a&gt;&lt;/code&gt; 함수 와 같이 나누기 연산 &lt;code&gt;x/y&lt;/code&gt; 의 부동 소수점 나머지를 계산합니다 . 또한, 기호 및 마지막 비트의 적어도 세 개의 &lt;code&gt;x/y&lt;/code&gt; 저장한다 &lt;code&gt;quo&lt;/code&gt; 이내에 결과의 팔분의를 결정하기에 충분.</target>
        </trans-unit>
        <trans-unit id="da7e6ba39e7925b467e308b04f0b0774e301062b" translate="yes" xml:space="preserve">
          <source>1-3) Computes the floating-point remainder of the division operation &lt;code&gt;x/y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ad95c06bf5dbd5b1f3e61bec2e1edecc0ed988" translate="yes" xml:space="preserve">
          <source>1-3) Computes the hyperbolic cosine of &lt;code&gt;arg&lt;/code&gt;</source>
          <target state="translated">1-3) &lt;code&gt;arg&lt;/code&gt; 의 쌍곡 코사인을 계산합니다</target>
        </trans-unit>
        <trans-unit id="da730591a9e5ab773aabe46364a23f752fb8bdcd" translate="yes" xml:space="preserve">
          <source>1-3) Computes the hyperbolic sine of &lt;code&gt;arg&lt;/code&gt;</source>
          <target state="translated">1-3) &lt;code&gt;arg&lt;/code&gt; 의 쌍곡 사인을 계산합니다</target>
        </trans-unit>
        <trans-unit id="2dbee060d919dd3f86036cbef043a195d5d52b6e" translate="yes" xml:space="preserve">
          <source>1-3) Computes the hyperbolic tangent of &lt;code&gt;arg&lt;/code&gt;</source>
          <target state="translated">1-3) &lt;code&gt;arg&lt;/code&gt; 의 쌍곡 탄젠트 계산</target>
        </trans-unit>
        <trans-unit id="75dd9fa119e02d6efb8298dc297ba4d969160f1d" translate="yes" xml:space="preserve">
          <source>1-3) Computes the inverse hyperbolic cosine of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="834472b18c2a6549ef22068e323b56d7df86c118" translate="yes" xml:space="preserve">
          <source>1-3) Computes the inverse hyperbolic sine of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="061964416b59b2bac46fda851482e538336e320e" translate="yes" xml:space="preserve">
          <source>1-3) Computes the inverse hyperbolic tangent of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ff20a5ce239fd62c651f7088bfbe37c43a76e82" translate="yes" xml:space="preserve">
          <source>1-3) Computes the largest integer value not greater than &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca11cec96c81f740aceb07d08e88e13130955fa0" translate="yes" xml:space="preserve">
          <source>1-3) Computes the natural (base</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b929313778a4ecae33784097ee7ce1d71e1b1108" translate="yes" xml:space="preserve">
          <source>1-3) Computes the natural (base &lt;code&gt;e&lt;/code&gt;) logarithm of &lt;code&gt;1+arg&lt;/code&gt;. This function is more precise than the expression &lt;code&gt;&lt;a href=&quot;log&quot;&gt;std::log&lt;/a&gt;(1+arg)&lt;/code&gt; if &lt;code&gt;arg&lt;/code&gt; is close to zero.</source>
          <target state="translated">1-3) &lt;code&gt;1+arg&lt;/code&gt; 의 자연 (기수 &lt;code&gt;e&lt;/code&gt; ) 로그를 계산합니다 . &lt;code&gt;arg&lt;/code&gt; 가 0에 가까우 면 이 함수는 &lt;code&gt;&lt;a href=&quot;log&quot;&gt;std::log&lt;/a&gt;(1+arg)&lt;/code&gt; (1 + arg) 표현식보다 정확 합니다.</target>
        </trans-unit>
        <trans-unit id="78bc85fc60cecfd077905bc98c8fc75c8b80e9fe" translate="yes" xml:space="preserve">
          <source>1-3) Computes the natural logarithm of the absolute value of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Gamma_function&quot;&gt;gamma function&lt;/a&gt; of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5f87e9d17da829e68c77738b3536c97f08431e1" translate="yes" xml:space="preserve">
          <source>1-3) Computes the nearest integer not greater in magnitude than &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="592c69fdc8890478a9283f23c8d6cc4832e08a4d" translate="yes" xml:space="preserve">
          <source>1-3) Computes the nearest integer value to &lt;code&gt;arg&lt;/code&gt; (in floating-point format), rounding halfway cases away from zero, regardless of the current rounding mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b724fc6b26effea7849a37c77bd9f1fe241356f1" translate="yes" xml:space="preserve">
          <source>1-3) Computes the principal value of the arc cosine of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7165eead21ff1697ec1d99ce13ca1c242fa6732a" translate="yes" xml:space="preserve">
          <source>1-3) Computes the principal value of the arc sine of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;arg&lt;/code&gt; 의 아크 사인의 주요 값을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="6bc1635ef143840a7574d363dcc84ed0ea14723c" translate="yes" xml:space="preserve">
          <source>1-3) Computes the principal value of the arc tangent of &lt;code&gt;arg&lt;/code&gt;</source>
          <target state="translated">1-3) &lt;code&gt;arg&lt;/code&gt; 의 아크 탄젠트의 주요 값을 계산합니다</target>
        </trans-unit>
        <trans-unit id="234a4abe0e39e12e87ad70ddc22021c4aa7f7aa8" translate="yes" xml:space="preserve">
          <source>1-3) Computes the sine of &lt;code&gt;arg&lt;/code&gt; (measured in radians).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38ca1671920427cd5061c6d3d3e1596c6b200aee" translate="yes" xml:space="preserve">
          <source>1-3) Computes the smallest integer value not less than &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0a834c9cd53450a30d6b0161f2b00bd1e0e63cf" translate="yes" xml:space="preserve">
          <source>1-3) Computes the square root of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;arg&lt;/code&gt; 의 제곱근을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="52fe3cd1edb0f6f4d94f1a5135012afcaf3f8eb9" translate="yes" xml:space="preserve">
          <source>1-3) Computes the square root of the sum of the squares of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, without undue overflow or underflow at intermediate stages of the computation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acf8ca598ce6912683ef9734a50ee2d61d8080d8" translate="yes" xml:space="preserve">
          <source>1-3) Computes the tangent of &lt;code&gt;arg&lt;/code&gt; (measured in radians).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aca4a4b258e6aabc7f113cfc0775ccc810da10a1" translate="yes" xml:space="preserve">
          <source>1-3) Decomposes given floating point value &lt;code&gt;arg&lt;/code&gt; into a normalized fraction and an integral power of two.</source>
          <target state="translated">1-3) 주어진 부동 소수점 값 &lt;code&gt;arg&lt;/code&gt; 를 정규화 된 분수와 2의 적분으로 분해 합니다.</target>
        </trans-unit>
        <trans-unit id="93747b2bcd888c6ed09390f9fd29fcdb7d469cb1" translate="yes" xml:space="preserve">
          <source>1-3) Decomposes given floating point value &lt;code&gt;x&lt;/code&gt; into integral and fractional parts, each having the same type and sign as &lt;code&gt;x&lt;/code&gt;. The integral part (in floating-point format) is stored in the object pointed to by &lt;code&gt;iptr&lt;/code&gt;.</source>
          <target state="translated">1-3) 주어진 부동 소수점 값 &lt;code&gt;x&lt;/code&gt; 를 각각 &lt;code&gt;x&lt;/code&gt; 와 동일한 유형과 부호를 갖는 정수 부분과 분수 부분으로 분해 합니다. 정수 부분 (부동 소수점 형식)은 &lt;code&gt;iptr&lt;/code&gt; 이 가리키는 오브젝트에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="50887e00720920f9e693f8cb9153c9ae0396e0c7" translate="yes" xml:space="preserve">
          <source>1-3) Determines if the floating point number &lt;code&gt;x&lt;/code&gt; is greater than or equal to the floating-point number &lt;code&gt;y&lt;/code&gt;, without setting floating-point exceptions.</source>
          <target state="translated">부동 소수점 숫자의 경우 1-3) 결정 &lt;code&gt;x&lt;/code&gt; 보다 큰 또는 부동 소수점 수와 동일한 &lt;code&gt;y&lt;/code&gt; 부동 소수점 예외를 설정하지 않고.</target>
        </trans-unit>
        <trans-unit id="6e5f4b8fb5dd6b0cf7d4e8e912d0ad243f9605fe" translate="yes" xml:space="preserve">
          <source>1-3) Determines if the floating point number &lt;code&gt;x&lt;/code&gt; is greater than the floating-point number &lt;code&gt;y&lt;/code&gt;, without setting floating-point exceptions.</source>
          <target state="translated">1-3) 부동 소수점 예외를 설정하지 않고 부동 소수점 숫자 &lt;code&gt;x&lt;/code&gt; 가 부동 소수점 숫자 &lt;code&gt;y&lt;/code&gt; 보다 큰지를 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="9de0ba75510329ab661bf6b3e1edfc22f338e6a2" translate="yes" xml:space="preserve">
          <source>1-3) Determines if the floating point number &lt;code&gt;x&lt;/code&gt; is less than or equal to the floating-point number &lt;code&gt;y&lt;/code&gt;, without setting floating-point exceptions.</source>
          <target state="translated">부동 소수점 숫자의 경우 1-3) 결정 &lt;code&gt;x&lt;/code&gt; 보다 작거나 부동 소수점 수와 동일한 &lt;code&gt;y&lt;/code&gt; 부동 소수점 예외를 설정하지 않고.</target>
        </trans-unit>
        <trans-unit id="26b3c88d3ddabf54e22399a5e1ce4f57de4eab3d" translate="yes" xml:space="preserve">
          <source>1-3) Determines if the floating point number &lt;code&gt;x&lt;/code&gt; is less than or greater than the floating-point number &lt;code&gt;y&lt;/code&gt;, without setting floating-point exceptions.</source>
          <target state="translated">1-3) 부동 소수점 예외를 설정하지 않고 부동 소수점 숫자 &lt;code&gt;x&lt;/code&gt; 가 부동 소수점 숫자 &lt;code&gt;y&lt;/code&gt; 보다 작거나 큰지를 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="d3fa1153e320b648931a24e366a2286c1fc456df" translate="yes" xml:space="preserve">
          <source>1-3) Determines if the floating point number &lt;code&gt;x&lt;/code&gt; is less than the floating-point number &lt;code&gt;y&lt;/code&gt;, without setting floating-point exceptions.</source>
          <target state="translated">1-3) 부동 소수점 예외를 설정하지 않고 부동 소수점 숫자 &lt;code&gt;x&lt;/code&gt; 가 부동 소수점 숫자 &lt;code&gt;y&lt;/code&gt; 보다 작은 지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="d80e368ad90771e727ba59d7fe07a65e3bcd9b80" translate="yes" xml:space="preserve">
          <source>1-3) Determines if the floating point numbers &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are unordered, that is, one or both are NaN and thus cannot be meaningfully compared with each other.</source>
          <target state="translated">1-3) 부동 소수점 숫자 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 순서가 없는지 , 즉 하나 또는 둘 다 NaN이고 서로 의미있게 비교 될 수 없는지를 판별합니다 .</target>
        </trans-unit>
        <trans-unit id="d9b6852d1f88abbd60a8691bb21dc9b1c4bde430" translate="yes" xml:space="preserve">
          <source>1-3) Determines if the given floating point number &lt;code&gt;arg&lt;/code&gt; has finite value i.e. it is normal, subnormal or zero, but not infinite or NaN.</source>
          <target state="translated">1-3) 주어진 부동 소수점 수 &lt;code&gt;arg&lt;/code&gt; 가 유한 값을 갖는지 여부를 결정합니다. 즉, 정상, 준 정규 또는 0이지만 무한 또는 NaN은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="3926f4095ad92e8df9dc7187f417e212dce2bf2c" translate="yes" xml:space="preserve">
          <source>1-3) Determines if the given floating point number &lt;code&gt;arg&lt;/code&gt; is a not-a-number (NaN) value.</source>
          <target state="translated">1-3) 주어진 부동 소수점 숫자 &lt;code&gt;arg&lt;/code&gt; 가 숫자 가 아닌 (NaN) 값인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="a8e46b1046626d47262aefe9cc8f328f281235e3" translate="yes" xml:space="preserve">
          <source>1-3) Determines if the given floating point number &lt;code&gt;arg&lt;/code&gt; is a positive or negative infinity.</source>
          <target state="translated">1-3) 주어진 부동 소수점 수 &lt;code&gt;arg&lt;/code&gt; 가 양의 무한대인지 음의 무한대인지를 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="d3ffb95a23714caf4d2629fcde710f6e3685912d" translate="yes" xml:space="preserve">
          <source>1-3) Determines if the given floating point number &lt;code&gt;arg&lt;/code&gt; is negative.</source>
          <target state="translated">1-3) 주어진 부동 소수점 수 &lt;code&gt;arg&lt;/code&gt; 가 음수인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="480003dd7313a55363a457c0bbb387ba963d7daa" translate="yes" xml:space="preserve">
          <source>1-3) Determines if the given floating point number &lt;code&gt;arg&lt;/code&gt; is normal, i.e. is neither zero, subnormal, infinite, nor NaN.</source>
          <target state="translated">1-3) 주어진 부동 소수점 수 &lt;code&gt;arg&lt;/code&gt; 가 정상인지, 즉 0, 하위 정규, 무한 또는 NaN이 아닌지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="dd5ddd62caeae15f94884a30ac307c1f69fbee36" translate="yes" xml:space="preserve">
          <source>1-3) Equivalent to &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;(r).swap(*this)&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;(r).swap(*this)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="582c6b5e653a5d4a4058e4cabe9c009bd17e9fb4" translate="yes" xml:space="preserve">
          <source>1-3) Extracts the value of the unbiased exponent from the floating-point argument &lt;code&gt;arg&lt;/code&gt;, and returns it as a signed integer value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e3866612d444afc9e9ee7f5249625e36cd8bec3" translate="yes" xml:space="preserve">
          <source>1-3) Extracts the value of the unbiased radix-independent exponent from the floating-point argument &lt;code&gt;arg&lt;/code&gt;, and returns it as a floating-point value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90645a367fc1519b08c4824e0f9d43f1a503bd68" translate="yes" xml:space="preserve">
          <source>1-3) Identity conversion. Returns &lt;code&gt;t&lt;/code&gt; unchanged.</source>
          <target state="translated">1-3) 신원 전환. 변경되지 않은 &lt;code&gt;t&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4b1a6428fcd1f71a0ec1a202d0b814aa06b222a6" translate="yes" xml:space="preserve">
          <source>1-3) Identity conversion: &lt;code&gt;operator()&lt;/code&gt; returns a copy of the argument.</source>
          <target state="translated">1-3) 아이디 변환 : &lt;code&gt;operator()&lt;/code&gt; 는 인수의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1949ed3d02ea0a633dc911e5662561ba6b4b3903" translate="yes" xml:space="preserve">
          <source>1-3) If &lt;code&gt;from&lt;/code&gt; equals to &lt;code&gt;to&lt;/code&gt;, &lt;code&gt;to&lt;/code&gt; is returned.</source>
          <target state="translated">1-3) 경우 &lt;code&gt;from&lt;/code&gt; 같음에 &lt;code&gt;to&lt;/code&gt; , &lt;code&gt;to&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a393d29adc3fd04df54cba0834c747cef2d5811e" translate="yes" xml:space="preserve">
          <source>1-3) Inserts &lt;code&gt;value&lt;/code&gt;. The overload (2) is equivalent to &lt;code&gt;emplace(&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;P&amp;gt;(value))&lt;/code&gt; and only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;value_type, P&amp;amp;&amp;amp;&amp;gt;::value == true&lt;/code&gt;.</source>
          <target state="translated">1-3) &lt;code&gt;value&lt;/code&gt; 삽입 합니다 . 과부하 (2)는 &lt;code&gt;emplace(&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;P&amp;gt;(value))&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;value_type, P&amp;amp;&amp;amp;&amp;gt;::value == true&lt;/code&gt; 경우에만 과부하 해결에 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="08867d3db4e5398a693b1c2d4cd147441d9e7fb1" translate="yes" xml:space="preserve">
          <source>1-3) Logarithmic in the size of the container, &lt;code&gt;O(log(size()))&lt;/code&gt;.</source>
          <target state="translated">1-3) 컨테이너 크기의 &lt;code&gt;O(log(size()))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b77eaa792ac159e0cded473ec513b27d64ce889" translate="yes" xml:space="preserve">
          <source>1-3) Multiplies a floating point value &lt;code&gt;x&lt;/code&gt; by the number &lt;code&gt;2&lt;/code&gt; raised to the &lt;code&gt;exp&lt;/code&gt; power.</source>
          <target state="translated">1-3) 부동 소수점 곱셈 값 &lt;code&gt;x&lt;/code&gt; 수로 &lt;code&gt;2&lt;/code&gt; 받는 인상 &lt;code&gt;exp&lt;/code&gt; 전원.</target>
        </trans-unit>
        <trans-unit id="e2d10719000b445d6f25b68b873ad0819f51389f" translate="yes" xml:space="preserve">
          <source>1-3) Number of characters written if successful or negative value if an error occurred.</source>
          <target state="translated">1-3) 성공한 경우 쓰여진 문자 수 또는 오류가 발생한 경우 음수 값.</target>
        </trans-unit>
        <trans-unit id="36ce333e0006396c04a89d970181cbd35113e058" translate="yes" xml:space="preserve">
          <source>1-3) Returns a pair consisting of an iterator to the inserted element (or to the element that prevented the insertion) and a &lt;code&gt;bool&lt;/code&gt; denoting whether the insertion took place.</source>
          <target state="translated">1-3) 삽입 된 요소 (또는 삽입을 방해 한 요소)와 삽입이 발생했는지 여부를 나타내는 &lt;code&gt;bool&lt;/code&gt; 에 대한 반복자로 구성된 쌍을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b0fd10f29e5d0c5e2c0ebea9548a80045dc6b8c0" translate="yes" xml:space="preserve">
          <source>1-3) Returns the larger of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen)</source>
          <target state="translated">1-3) NaN을 누락 된 데이터로 취급하여 NaN과 숫자 값 사이에서 숫자 값이 선택되는 두 개의 부동 소수점 인수 중 큰 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aea61ec34824bf54b309b57e957c3428d8a0fa6e" translate="yes" xml:space="preserve">
          <source>1-3) Returns the positive difference between &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, that is, if &lt;code&gt;x&amp;gt;y&lt;/code&gt;, returns &lt;code&gt;x-y&lt;/code&gt;, otherwise (if &lt;code&gt;x&amp;le;y&lt;/code&gt;), returns +0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d9ef3a166fa2a83e4f7c4e245bd13b92274c76f" translate="yes" xml:space="preserve">
          <source>1-3) Returns the smaller of two floating point arguments, treating NaNs as missing data (between a NaN and a numeric value, the numeric value is chosen)</source>
          <target state="translated">1-3) NaN을 누락 된 데이터로 취급하여 NaN과 숫자 값 사이에서 숫자 값이 선택되는 두 개의 부동 소수점 인수 중 작은 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5a73a75ce5f2eb710f6ad7aa47a76e2f8e4a92c1" translate="yes" xml:space="preserve">
          <source>1-3) Returns the sum of its arguments</source>
          <target state="translated">1-3) 인수의 합을 반환</target>
        </trans-unit>
        <trans-unit id="211a58bfb0e8dcbaaf1d22bf39486a8d1a347550" translate="yes" xml:space="preserve">
          <source>1-3) Rounds the floating-point argument &lt;code&gt;arg&lt;/code&gt; to an integer value (in floating-point format), using the &lt;a href=&quot;../fenv/fe_round&quot;&gt;current rounding mode&lt;/a&gt;.</source>
          <target state="translated">1-3) &lt;a href=&quot;../fenv/fe_round&quot;&gt;현재 반올림 모드를&lt;/a&gt; 사용하여 부동 소수점 인수 &lt;code&gt;arg&lt;/code&gt; 를 정수 값 (부동 소수점 형식)으로 반올림합니다 .</target>
        </trans-unit>
        <trans-unit id="abbd4d43d5a4a4562512e8a550b98d9521bfa824" translate="yes" xml:space="preserve">
          <source>1-3) Rounds the floating-point argument &lt;code&gt;arg&lt;/code&gt; to an integer value in floating-point format, using the &lt;a href=&quot;../fenv/fe_round&quot;&gt;current rounding mode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="099dfc85ac82c18b798184aafa6e083883f0d3c9" translate="yes" xml:space="preserve">
          <source>1-3) The time point that resulted from applying the offset &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">1-3) 오프셋을 적용한 시점 &lt;code&gt;d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe5325f3a89c047316dec9cb00d528e144879817" translate="yes" xml:space="preserve">
          <source>1-3) Throws &lt;code&gt;&lt;a href=&quot;bad_any_cast&quot;&gt;std::bad_any_cast&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;typeid&lt;/code&gt; of the requested &lt;code&gt;T&lt;/code&gt; does not match that of the contents of &lt;code&gt;operand&lt;/code&gt;.</source>
          <target state="translated">1-3) 요청 된 &lt;code&gt;T&lt;/code&gt; 의 &lt;code&gt;typeid&lt;/code&gt; 가 &lt;code&gt;operand&lt;/code&gt; 의 내용과 일치하지 않으면 &lt;code&gt;&lt;a href=&quot;bad_any_cast&quot;&gt;std::bad_any_cast&lt;/a&gt;&lt;/code&gt; 던집니다 .</target>
        </trans-unit>
        <trans-unit id="62f78b0af656a88a759d437b4caf434114737fe6" translate="yes" xml:space="preserve">
          <source>1-3) constant</source>
          <target state="translated">1-3) 상수</target>
        </trans-unit>
        <trans-unit id="333b84a5b0c29ae71aa1b013486ac3adc3124aa9" translate="yes" xml:space="preserve">
          <source>1-3)&lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">1-3)&lt;code&gt;*this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1831463ebd755ef355128e58d8cd50e7b7da7448" translate="yes" xml:space="preserve">
          <source>1-3)&lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) += rhs&lt;/code&gt;</source>
          <target state="translated">1-3) &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) += rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5bdd623dd466ba43cabe8efda1054c02a50fcca2" translate="yes" xml:space="preserve">
          <source>1-3)&lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">1-3)&lt;code&gt;t&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="3e1202167561bee3fee3a68edc1b767029806865" translate="yes" xml:space="preserve">
          <source>1-3)&lt;code&gt;true&lt;/code&gt; if respective parts of &lt;code&gt;lhs&lt;/code&gt; are equal to &lt;code&gt;rhs&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">1-3) &lt;code&gt;true&lt;/code&gt; 의 각부 경우 &lt;code&gt;lhs&lt;/code&gt; 동일하다 &lt;code&gt;rhs&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="7242ed87c2fcc388a82b7338b89928ba0d83736d" translate="yes" xml:space="preserve">
          <source>1-3,5-7) Multiplies a floating point value &lt;code&gt;x&lt;/code&gt; by &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; raised to power &lt;code&gt;exp&lt;/code&gt;.</source>
          <target state="translated">1-3,5-7) 곱 부동 소수점 값 &lt;code&gt;x&lt;/code&gt; 에 의해 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; 는 전력을 발생 &lt;code&gt;exp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46cb03231fdfd8209e9f8da9b5af53150ed630c8" translate="yes" xml:space="preserve">
          <source>1-4) Any exception thrown during the initialization of the contained value.</source>
          <target state="translated">1-4) 포함 된 값을 초기화하는 동안 예외가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="b8e6c03d1e0290ef24d34b673b7f52bac4cc4d85" translate="yes" xml:space="preserve">
          <source>1-4) At most &lt;code&gt;S*N&lt;/code&gt; comparisons where &lt;code&gt;S = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(s_first, s_last)&lt;/code&gt; and &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;.</source>
          <target state="translated">1-4) &lt;code&gt;S = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(s_first, s_last)&lt;/code&gt; &lt;a href=&quot;../iterator/distance&quot;&gt;std :: distance&lt;/a&gt; (s_first, s_last) 및 &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; &lt;a href=&quot;../iterator/distance&quot;&gt;std :: distance&lt;/a&gt; (first, last )에서 최대 &lt;code&gt;S*N&lt;/code&gt; 비교 .</target>
        </trans-unit>
        <trans-unit id="0f1eb34f31e0245e1487f9ee09507dc994c81182" translate="yes" xml:space="preserve">
          <source>1-4) At most &lt;code&gt;last1&lt;/code&gt; - &lt;code&gt;first1&lt;/code&gt; applications of &lt;code&gt;operator==&lt;/code&gt; or the predicate &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">1-4) &lt;code&gt;operator==&lt;/code&gt; &lt;code&gt;last1&lt;/code&gt; - &lt;code&gt;first1&lt;/code&gt; 응용 프로그램 == 또는 술어 &lt;code&gt;p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9af3cb4aab5a9d1c0f205339033d720328f15609" translate="yes" xml:space="preserve">
          <source>1-4) Average case: &lt;code&gt;O(1)&lt;/code&gt;, worst case &lt;code&gt;O(size())&lt;/code&gt;</source>
          <target state="translated">1-4) 평균 사례 : &lt;code&gt;O(1)&lt;/code&gt; , 최악의 경우 &lt;code&gt;O(size())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2820e5f171407eefa7ee07bc35fdcbf25f1cb515" translate="yes" xml:space="preserve">
          <source>1-4) Behaves as a &lt;a href=&quot;../../named_req/formattedinputfunction&quot;&gt;FormattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, which may skip leading whitespace, extracts an integer value by calling &lt;a href=&quot;../../locale/num_get/get&quot;&gt;&lt;code&gt;std::num_get::get()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">1-4) &lt;a href=&quot;../../named_req/formattedinputfunction&quot;&gt;FormattedInputFunction으로&lt;/a&gt; 동작합니다 . 선행 공백을 건너 뛸 수있는 센트리 객체를 구성하고 확인한 후 &lt;a href=&quot;../../locale/num_get/get&quot;&gt; &lt;code&gt;std::num_get::get()&lt;/code&gt; &lt;/a&gt; 을 호출하여 정수 값을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="879bfe7f1e0947cfb877e19b80283c466f0ffecf" translate="yes" xml:space="preserve">
          <source>1-4) Constructs a &lt;code&gt;synchronized_pool_resource&lt;/code&gt; using the specified upstream memory resource and tuned according to the specified options. The resulting object holds a copy of &lt;code&gt;upstream&lt;/code&gt; but does not own the resource to which &lt;code&gt;upstream&lt;/code&gt; points.</source>
          <target state="translated">1-4) 지정된 업스트림 메모리 리소스를 사용하여 &lt;code&gt;synchronized_pool_resource&lt;/code&gt; 를 구성하고 지정된 옵션에 따라 조정합니다. 결과 개체는 &lt;code&gt;upstream&lt;/code&gt; 복사본을 보유 하지만 &lt;code&gt;upstream&lt;/code&gt; 가리키는 리소스는 소유하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2aceaacaa8a2f31d1222ef900189bc435fea9bce" translate="yes" xml:space="preserve">
          <source>1-4) Constructs a &lt;code&gt;unsynchronized_pool_resource&lt;/code&gt; using the specified upstream memory resource and tuned according to the specified options. The resulting object holds a copy of &lt;code&gt;upstream&lt;/code&gt; but does not own the resource to which &lt;code&gt;upstream&lt;/code&gt; points.</source>
          <target state="translated">1-4) 지정된 업스트림 메모리 리소스를 사용하여 비 &lt;code&gt;unsynchronized_pool_resource&lt;/code&gt; 를 생성하고 지정된 옵션에 따라 조정합니다. 결과 개체는 &lt;code&gt;upstream&lt;/code&gt; 복사본을 보유 하지만 &lt;code&gt;upstream&lt;/code&gt; 가리키는 리소스는 소유하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c801d3d0d18d101f1459822c8934371420c35366" translate="yes" xml:space="preserve">
          <source>1-4) Extracts the &lt;code&gt;Ith&lt;/code&gt; element from the tuple. &lt;code&gt;I&lt;/code&gt; must be an integer value in &lt;code&gt;[0, sizeof...(Types))&lt;/code&gt;.</source>
          <target state="translated">1-4) 튜플에서 &lt;code&gt;Ith&lt;/code&gt; 요소를 추출합니다 . &lt;code&gt;I&lt;/code&gt; 정수 값이어야합니다 &lt;code&gt;[0, sizeof...(Types))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f02bcbd174f524cedc047da3d0e09e22ca584e2" translate="yes" xml:space="preserve">
          <source>1-4) If an exception is thrown by any operation, the insertion has no effect.</source>
          <target state="translated">1-4) 어떤 조작으로도 예외가 발생하면 삽입은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="44ae935a34d4133cda6268f85e300e92b57fb6ed" translate="yes" xml:space="preserve">
          <source>1-4) If no errors occur, the hypotenuse of a right-angled triangle, &amp;radic;x2</source>
          <target state="translated">1-4) 오류가 발생하지 않으면 직각 삼각형의 빗변, &amp;radic;x2</target>
        </trans-unit>
        <trans-unit id="65322dd6d7e0b03a938bc86ddd78cb2ec98c6e51" translate="yes" xml:space="preserve">
          <source>1-4) Iterator to the beginning of first occurrence of the sequence &lt;code&gt;[s_first, s_last)&lt;/code&gt; in the range &lt;code&gt;[first, last)&lt;/code&gt;. If no such occurrence is found, &lt;code&gt;last&lt;/code&gt; is returned.</source>
          <target state="translated">1-4) &lt;code&gt;[first, last)&lt;/code&gt; 범위에서 시퀀스 &lt;code&gt;[s_first, s_last)&lt;/code&gt; 가 처음 시작될 때까지 반복합니다 . 그러한 발생이 없으면 &lt;code&gt;last&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f1f1d85fb6d51495288aebbc91fd1df9383578b6" translate="yes" xml:space="preserve">
          <source>1-4) Returns a reference to &lt;code&gt;p.first&lt;/code&gt; if &lt;code&gt;I==0&lt;/code&gt; and a reference to &lt;code&gt;p.second&lt;/code&gt; if &lt;code&gt;I==1&lt;/code&gt;.</source>
          <target state="translated">1-4) 참조 돌려 &lt;code&gt;p.first&lt;/code&gt; 을 경우 &lt;code&gt;I==0&lt;/code&gt; 및 참조 &lt;code&gt;p.second&lt;/code&gt; 이 경우 &lt;code&gt;I==1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="224c43d88c347070a527d128e39315b8519299a0" translate="yes" xml:space="preserve">
          <source>1-4) Returns an iterator to the inserted element.</source>
          <target state="translated">1-4) 반복자를 삽입 된 요소로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="49fa3dbbc998313c848c165605f3721cd132e754" translate="yes" xml:space="preserve">
          <source>1-4) Searches for the first occurrence of the sequence of elements &lt;code&gt;[s_first, s_last)&lt;/code&gt; in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">1-4) &lt;code&gt;[first, last)&lt;/code&gt; 범위에서 요소 시퀀스 &lt;code&gt;[s_first, s_last)&lt;/code&gt; 의 첫 항목을 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="4fa1cd54db029a6b8121497d911237fcf38b6ad2" translate="yes" xml:space="preserve">
          <source>1-4) Throws only if a call to the &lt;code&gt;allocate()&lt;/code&gt; function of the upstream resource throws. It is unspecified if or under what conditions such a call takes place.</source>
          <target state="translated">1-4) 업스트림 리소스의 assign &lt;code&gt;allocate()&lt;/code&gt; 함수를 호출 한 경우에만 발생합니다 . 그러한 호출이 발생하는 경우 또는 어떤 조건 하에서 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="78c807aca3c029e3bab9e4cfde85bc167d5e629c" translate="yes" xml:space="preserve">
          <source>1-4) constructs the private member std::basic_syncbuf using the buffer and the allocator provided, and initializes the base class with a pointer to the member std::basic_streambuf.</source>
          <target state="translated">1-4) 제공된 버퍼와 할당자를 사용하여 전용 멤버 std :: basic_syncbuf를 구성하고 std :: basic_streambuf 멤버에 대한 포인터를 사용하여 기본 클래스를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="b000f72a4a8c874fc4a958e9adfa4aef66c1d5ea" translate="yes" xml:space="preserve">
          <source>1-4) non-null pointer to suitably aligned memory of size at least &lt;code&gt;size&lt;/code&gt;</source>
          <target state="translated">1-4) 최소 &lt;code&gt;size&lt;/code&gt; 메모리를 적절히 정렬하기위한 널이 아닌 포인터</target>
        </trans-unit>
        <trans-unit id="3859c91f976dfa493c422a2bb8de23139db117d1" translate="yes" xml:space="preserve">
          <source>1-4) throws &lt;code&gt;&lt;a href=&quot;bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;or another exception derived from &lt;code&gt;&lt;a href=&quot;bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;(since C++11) on failure to allocate memory</source>
          <target state="translated">1-4) 메모리 할당 실패시 &lt;code&gt;&lt;a href=&quot;bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; (C ++ 11부터) 에서 파생 된 다른 예외 가 발생 함</target>
        </trans-unit>
        <trans-unit id="e6fae875ea4f33c9e5f7e361033d55be009eae73" translate="yes" xml:space="preserve">
          <source>1-4) user-defined integer literals, such as &lt;code&gt;12_km&lt;/code&gt;</source>
          <target state="translated">1-4) &lt;code&gt;12_km&lt;/code&gt; 과 같은 사용자 정의 정수 리터럴</target>
        </trans-unit>
        <trans-unit id="59d58381d2bee68701e3547fa8ac7eab9a5c5b45" translate="yes" xml:space="preserve">
          <source>1-4, 10)&lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;index &amp;gt; size()&lt;/code&gt;</source>
          <target state="translated">1-4, 10) &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; 경우 &lt;code&gt;index &amp;gt; size()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34f84c2b98c636d3e0a67b9eaf2d00756e7e1390" translate="yes" xml:space="preserve">
          <source>1-5) (none)</source>
          <target state="translated">1-5) (없음)</target>
        </trans-unit>
        <trans-unit id="3c3169e3cde2d6e4be3b8cb9f5c4b2b76bc720e3" translate="yes" xml:space="preserve">
          <source>1-5,10-11)&lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">1-5,10-11)&lt;code&gt;*this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="35d504fd87835e7e91c6cdd1928826d042fa4ffe" translate="yes" xml:space="preserve">
          <source>1-6) Compares two &lt;code&gt;basic_string&lt;/code&gt; objects.</source>
          <target state="translated">1-6) 두 개의 &lt;code&gt;basic_string&lt;/code&gt; 객체를 비교 합니다.</target>
        </trans-unit>
        <trans-unit id="4fdafc76ae3eaddbd734e9113e94c6f523fe5861" translate="yes" xml:space="preserve">
          <source>1-6) Compares two &lt;code&gt;optional&lt;/code&gt; objects, &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. The contained values are compared (using the corresponding operator of &lt;code&gt;T&lt;/code&gt;) only if both &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; contain values. Otherwise,</source>
          <target state="translated">1-6) 두 개의 &lt;code&gt;optional&lt;/code&gt; 객체 인 &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 를 비교 합니다. 포함 된 값은 &lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; 모두에 값이 포함 된 경우에만 비교됩니다 (해당 &lt;code&gt;T&lt;/code&gt; 연산자 사용 ) . 그렇지 않으면,</target>
        </trans-unit>
        <trans-unit id="08feaa5318e14eb4aedc2c00b6653147c95425d8" translate="yes" xml:space="preserve">
          <source>1-6) Compares two &lt;code&gt;sub_match&lt;/code&gt; directly by comparing their underlying character sequences. Implemented as if by &lt;code&gt;lhs.compare(rhs)&lt;/code&gt;</source>
          <target state="translated">1-6) 기본 문자 순서를 비교하여 두 개의 &lt;code&gt;sub_match&lt;/code&gt; 를 직접 비교합니다. &lt;code&gt;lhs.compare(rhs)&lt;/code&gt; 의해 구현 됨</target>
        </trans-unit>
        <trans-unit id="8937cb23df516b437710dec318f91f061e1022d7" translate="yes" xml:space="preserve">
          <source>1-6) Compares two &lt;code&gt;unique_ptr&lt;/code&gt;s</source>
          <target state="translated">1-6) 두 개의 비교 &lt;code&gt;unique_ptr&lt;/code&gt; 들</target>
        </trans-unit>
        <trans-unit id="d500eef779c83656f47da19526320d2dac039691" translate="yes" xml:space="preserve">
          <source>1-6) Computes the absolute value of a floating point value &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">1-6) 부동 소수점 값 &lt;code&gt;arg&lt;/code&gt; 의 절대 값을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="9787068995efee51d47edee6fdbd2596a8a37e30" translate="yes" xml:space="preserve">
          <source>1-6) Computes the value of &lt;code&gt;base&lt;/code&gt; raised to the power &lt;code&gt;exp&lt;/code&gt; or &lt;code&gt;iexp&lt;/code&gt;.</source>
          <target state="translated">1-6)의 계산 값을 &lt;code&gt;base&lt;/code&gt; 전력으로 상승 &lt;code&gt;exp&lt;/code&gt; 또는 &lt;code&gt;iexp&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="82b1340704efe19e5c4f071397de8a9882090c24" translate="yes" xml:space="preserve">
          <source>1-6) If an exception is thrown by any operation, the insertion has no effect.</source>
          <target state="translated">1-6) 어떤 조작으로도 예외가 발생하면 삽입은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="443763de9ca4469b9ca86ecb357b4f04c21b9528" translate="yes" xml:space="preserve">
          <source>1-6, 19-30) (none)</source>
          <target state="translated">1-6, 19-30) (없음)</target>
        </trans-unit>
        <trans-unit id="6208b49c11a418aab0b5e12b4c5b2a7a44e33a56" translate="yes" xml:space="preserve">
          <source>1-7) Appends &lt;code&gt;path(other).native()&lt;/code&gt; to the pathname stored in &lt;code&gt;*this&lt;/code&gt; in the native format. This directly manipulates the value of &lt;code&gt;native()&lt;/code&gt; and may not be portable between operating systems.</source>
          <target state="translated">1-7) &lt;code&gt;path(other).native()&lt;/code&gt; 를 &lt;code&gt;*this&lt;/code&gt; 에 저장된 경로 이름에 기본 형식으로 추가합니다. 이것은 &lt;code&gt;native()&lt;/code&gt; 의 값을 직접 조작하며 운영 체제간에 이식성이 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2447d179527f4d7abceb2888ae5faeea9133eb5d" translate="yes" xml:space="preserve">
          <source>1-9,11)&lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">1-9,11)&lt;code&gt;*this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a915af4f81574aed4da31bf1df26108eec3c3311" translate="yes" xml:space="preserve">
          <source>1-qualified pointer to ... cv1</source>
          <target state="translated">1 qualified pointer to cv1</target>
        </trans-unit>
        <trans-unit id="f4c968269584365f9fbaf3106e4f9a91217ffa6c" translate="yes" xml:space="preserve">
          <source>1-qualified pointer to ... cv2</source>
          <target state="translated">1 qualified pointer to cv2</target>
        </trans-unit>
        <trans-unit id="5adfa94b3e98669b043c0ea35ad6786f2a6d4fb0" translate="yes" xml:space="preserve">
          <source>1. Accepts a single parameter of type &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="translated">1. &lt;code&gt;Key&lt;/code&gt; 유형의 단일 매개 변수를 승인합니다 .</target>
        </trans-unit>
        <trans-unit id="877e7dbb6078181723cc1c42398a8975ef928818" translate="yes" xml:space="preserve">
          <source>1. If either argument is &lt;code&gt;long double&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;long double&amp;gt;&lt;/code&gt;, then both arguments are cast to &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;long double&amp;gt;&lt;/code&gt;</source>
          <target state="translated">1. 인수 중 하나가 &lt;code&gt;long double&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;long double&amp;gt;&lt;/code&gt; 인 경우 두 인수 모두 &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;long double&amp;gt;&lt;/code&gt; &amp;lt;long double&amp;gt; 로 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="3c515af3a5e0eea3ee77dba04fc3efae7c5d6f17" translate="yes" xml:space="preserve">
          <source>1. Specified explicitly (both scoped and unscoped enumerations).</source>
          <target state="translated">1. 명시 적으로 지정합니다 (범위 및 범위가 지정되지 않은 열거).</target>
        </trans-unit>
        <trans-unit id="3bb0e9ca81b03b005effcb6ea0ddf79de23d2cc9" translate="yes" xml:space="preserve">
          <source>1.1) Either &lt;code&gt;E2&lt;/code&gt; or &lt;code&gt;E3&lt;/code&gt; (but not both) is a (possibly parenthesized) &lt;a href=&quot;throw&quot;&gt;throw-expression&lt;/a&gt;. The result of the conditional operator has the type and the value category of the other expression. If the other expression is a &lt;a href=&quot;bit_field&quot;&gt;bit field&lt;/a&gt;, the result is a bit field. Such conditional operator was commonly used in C++11 &lt;a href=&quot;constexpr&quot;&gt;constexpr programming&lt;/a&gt; prior to C++14.</source>
          <target state="translated">1.1) &lt;code&gt;E2&lt;/code&gt; 또는 &lt;code&gt;E3&lt;/code&gt; (둘다는 아님)은 (괄호로 묶은) &lt;a href=&quot;throw&quot;&gt;던짐 표현&lt;/a&gt; 입니다. 조건부 연산자의 결과에는 다른 표현식의 유형과 값 범주가 있습니다. 다른 표현식이 &lt;a href=&quot;bit_field&quot;&gt;비트 필드&lt;/a&gt; 인 경우 결과는 비트 필드입니다. 이러한 조건부 연산자는 C ++ 14 이전의 C ++ 11 &lt;a href=&quot;constexpr&quot;&gt;constexpr 프로그래밍&lt;/a&gt; 에서 일반적으로 사용되었습니다 .</target>
        </trans-unit>
        <trans-unit id="effe8ab79fe56a7753250184e13a178aeb64428f" translate="yes" xml:space="preserve">
          <source>1.10 Multi-threaded executions and data races (p: 11)</source>
          <target state="translated">1.10 멀티 스레드 실행 및 데이터 레이스 (p : 11)</target>
        </trans-unit>
        <trans-unit id="b00792cfe01dbe514f4c86f5577985fcc489fd09" translate="yes" xml:space="preserve">
          <source>1.2) Both &lt;code&gt;E2&lt;/code&gt; and &lt;code&gt;E3&lt;/code&gt; are of type &lt;code&gt;void&lt;/code&gt; (including the case when they are both throw-expressions). The result is a prvalue of type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">1.2) &lt;code&gt;E2&lt;/code&gt; 와 &lt;code&gt;E3&lt;/code&gt; 은 모두 &lt;code&gt;void&lt;/code&gt; 유형입니다 (둘 다 던져 표현 인 경우 포함). 결과는 &lt;code&gt;void&lt;/code&gt; 유형의 prvalue입니다 .</target>
        </trans-unit>
        <trans-unit id="32773e23b0484b196b2f9b4e3202939062a35a61" translate="yes" xml:space="preserve">
          <source>1.4 Implementation compliance (p: 3)</source>
          <target state="translated">1.4 구현 준수 (p : 3)</target>
        </trans-unit>
        <trans-unit id="103578b210b83ea1bf3b33dd6feac646773b0b0e" translate="yes" xml:space="preserve">
          <source>1.4 Implementation compliance (p: 5)</source>
          <target state="translated">1.4 구현 준수 (p : 5)</target>
        </trans-unit>
        <trans-unit id="b1d5781111d84f7b3fe45a0852e59758cd7a87e5" translate="yes" xml:space="preserve">
          <source>10</source>
          <target state="translated">10</target>
        </trans-unit>
        <trans-unit id="761c7d9564da680efcd56d0447d489c0f65429ab" translate="yes" xml:space="preserve">
          <source>10&amp;ndash;13</source>
          <target state="translated">10&amp;ndash;13</target>
        </trans-unit>
        <trans-unit id="d59099024c16138c9a6bd83c7561d5c5ddabb8f7" translate="yes" xml:space="preserve">
          <source>10(arg) or lg(arg)) is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7f4455f2261e77322f3750505a17ea9463fb860" translate="yes" xml:space="preserve">
          <source>10(radix) and rounded down.</source>
          <target state="translated">10 (기수)로 반올림합니다.</target>
        </trans-unit>
        <trans-unit id="05009a48877f1eee4748d27d553496b6f471aae4" translate="yes" xml:space="preserve">
          <source>10) A pointer to member function can be converted to pointer to a different member function of a different type. Conversion back to the original type yields the original value, otherwise the resulting pointer cannot be used safely.</source>
          <target state="translated">10) 멤버 함수에 대한 포인터는 다른 유형의 다른 멤버 함수에 대한 포인터로 변환 될 수 있습니다. 원래 유형으로 다시 변환하면 원래 값이 생성되며, 그렇지 않으면 결과 포인터를 안전하게 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="95116c2ccac3f41639a2cef46f1cfe0d7e704b20" translate="yes" xml:space="preserve">
          <source>10) A prvalue of type pointer to &lt;code&gt;void&lt;/code&gt; (possibly cv-qualified) can be converted to pointer to any object type. If the original &lt;a href=&quot;pointer#Pointers&quot;&gt;pointer value&lt;/a&gt; represents an address of a byte in memory that does not satisfy the alignment requirement of the target type, then the resulting pointer value is unspecified. Otherwise, if the original pointer value points to an object</source>
          <target state="translated">10) &lt;code&gt;void&lt;/code&gt; 에 대한 포인터 유형의 값 (cv-qualified)은 임의의 객체 유형에 대한 포인터로 변환 될 수 있습니다. 원래 &lt;a href=&quot;pointer#Pointers&quot;&gt;포인터 값&lt;/a&gt; 이 대상 유형의 정렬 요구 사항을 충족하지 않는 메모리의 바이트 주소를 나타내는 경우 결과 포인터 값이 지정되지 않습니다. 그렇지 않으면 원래 포인터 값이 객체를 가리키는 경우</target>
        </trans-unit>
        <trans-unit id="e28fcb54f471c197a53b6d2cc2ed78fc6c95ddc0" translate="yes" xml:space="preserve">
          <source>10) Amortized constant if the insertion happens in the position just</source>
          <target state="translated">10) 삽입이 바로 그 위치에서 발생하면 상각 상수</target>
        </trans-unit>
        <trans-unit id="01feddeede41f29d0cc571ad8d7f973d83f49af4" translate="yes" xml:space="preserve">
          <source>10) Called by the non-throwing array &lt;a href=&quot;../../language/new&quot;&gt;new[]-expressions&lt;/a&gt; if a constructor of any object throws an exception (after executing the destructors of all objects in the array that were successfully constructed). The standard library implementation behaves the same as (2)</source>
          <target state="translated">10) 어떤 객체의 생성자가 예외를 던지면 ( throwing non-throwing) 배열 &lt;a href=&quot;../../language/new&quot;&gt;new []&lt;/a&gt; -expression에 의해 호출됩니다 (배열에서 성공적으로 구성된 모든 객체의 소멸자를 실행 한 후). 표준 라이브러리 구현은 (2)와 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="87d938b9193b59ec73ad576089926b1cc6fb09d1" translate="yes" xml:space="preserve">
          <source>10) Called by the standard array form &lt;a href=&quot;../../language/new&quot;&gt;placement new&lt;/a&gt; expression. The standard library implementation performs no action and returns &lt;code&gt;ptr&lt;/code&gt; unmodified.</source>
          <target state="translated">10) 표준 배열 양식 &lt;a href=&quot;../../language/new&quot;&gt;배치 새&lt;/a&gt; 표현식에 의해 호출됩니다 . 표준 라이브러리 구현은 조치를 수행하지 않고 수정되지 않은 &lt;code&gt;ptr&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="8f9e1a7c68c2bb87d4f23734dca79a0556e2df87" translate="yes" xml:space="preserve">
          <source>10) Compares the shared pointers pointed-to by &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;expected&lt;/code&gt;. If they are equivalent (store the same pointer value, and either share ownership of the same object or are both empty), assigns &lt;code&gt;desired&lt;/code&gt; into &lt;code&gt;*p&lt;/code&gt; using the memory ordering constraints specified by &lt;code&gt;success&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;. If they are not equivalent, assigns &lt;code&gt;*p&lt;/code&gt; into &lt;code&gt;*expected&lt;/code&gt; using the memory ordering constraints specified by &lt;code&gt;failure&lt;/code&gt; and returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">10) &lt;code&gt;p&lt;/code&gt; 가 가리키는 공유 포인터 와 &lt;code&gt;expected&lt;/code&gt; 을 비교합니다 . 이들이 동일하면 (동일한 포인터 값을 저장하고 동일한 객체의 소유권을 공유하거나 둘 다 비어있는 경우) &lt;code&gt;success&lt;/code&gt; 에 의해 지정된 메모리 순서 제한 조건을 사용하여 &lt;code&gt;*p&lt;/code&gt; 에 &lt;code&gt;desired&lt;/code&gt; 을 지정하고 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 동일하지 않은 경우 &lt;code&gt;failure&lt;/code&gt; 로 지정된 메모리 순서 제한 조건을 사용하여 &lt;code&gt;*p&lt;/code&gt; 를 &lt;code&gt;*expected&lt;/code&gt; 에 지정하고 &lt;code&gt;false&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="975976303f9404ddee690836daecdd820457db76" translate="yes" xml:space="preserve">
          <source>10) Constructs the adaptor with the contents of &lt;code&gt;other&lt;/code&gt; using move semantics while utilizing &lt;code&gt;alloc&lt;/code&gt; as allocator, as if by &lt;code&gt;c(std::move(other.c), alloc)&lt;/code&gt;.</source>
          <target state="translated">10) &lt;code&gt;c(std::move(other.c), alloc)&lt;/code&gt; 처럼 &lt;code&gt;alloc&lt;/code&gt; 을 할당 자로 사용하면서 이동 의미를 사용하여 &lt;code&gt;other&lt;/code&gt; 내용으로 어댑터를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="2348cd4f7d5960ec531e7d9b063cc3a383a3b7d5" translate="yes" xml:space="preserve">
          <source>10) Constructs the underlying container with the contents of &lt;code&gt;cont&lt;/code&gt; using move semantics while using &lt;code&gt;alloc&lt;/code&gt; as allocator, as if by &lt;code&gt;c(std::move(cont), alloc)&lt;/code&gt;. Copy-constructs &lt;code&gt;comp&lt;/code&gt; from &lt;code&gt;compare&lt;/code&gt;. Then calls &lt;code&gt;&lt;a href=&quot;../../algorithm/make_heap&quot;&gt;std::make_heap&lt;/a&gt;(c.begin(), c.end(), comp)&lt;/code&gt;.</source>
          <target state="translated">10) &lt;code&gt;c(std::move(cont), alloc)&lt;/code&gt; 처럼 &lt;code&gt;alloc&lt;/code&gt; 을 할당 자로 사용하면서 이동 의미를 사용하여 &lt;code&gt;cont&lt;/code&gt; 의 내용으로 기본 컨테이너를 구성합니다 . &lt;code&gt;compare&lt;/code&gt; 에서 &lt;code&gt;comp&lt;/code&gt; 를 복사합니다 . 그런 다음 &lt;code&gt;&lt;a href=&quot;../../algorithm/make_heap&quot;&gt;std::make_heap&lt;/a&gt;(c.begin(), c.end(), comp)&lt;/code&gt; (c.begin (), c.end (), comp)를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f9af7846d7822c604f4ac3f9567941ad8fd4649" translate="yes" xml:space="preserve">
          <source>10) Defaulted copy constructor copies the size and data pointer; the resulting span has &lt;code&gt;size() == other.size()&lt;/code&gt; and &lt;code&gt;data() == other.data()&lt;/code&gt;.</source>
          <target state="translated">10) 기본 복사 생성자는 크기와 데이터 포인터를 복사합니다. 결과 범위는 &lt;code&gt;size() == other.size()&lt;/code&gt; 및 &lt;code&gt;data() == other.data()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5b823bbbb962d4b8880554bd0d6ee18adeb02c86" translate="yes" xml:space="preserve">
          <source>10) End iterator if &lt;code&gt;nh&lt;/code&gt; was empty, iterator pointing to the inserted element if insertion took place, and iterator pointing to an element with a key equivalent to &lt;code&gt;nh.key()&lt;/code&gt; if it failed.</source>
          <target state="translated">10) &lt;code&gt;nh&lt;/code&gt; 가 비어 있으면 반복자를 종료 하고, 삽입이 발생한 경우 삽입 된 요소를 가리키는 반복자, 실패한 경우 &lt;code&gt;nh.key()&lt;/code&gt; 해당하는 키를 가진 요소를 가리키는 반복자 가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="b7edd2b513fb7e7b710625d6c3c8efaecbdbe19f" translate="yes" xml:space="preserve">
          <source>10) If &lt;code&gt;nh&lt;/code&gt; is an empty &lt;a href=&quot;../node_handle&quot;&gt;node handle&lt;/a&gt;, does nothing and returns the end iterator. Otherwise, inserts the element owned by &lt;code&gt;nh&lt;/code&gt; into the container, if the container doesn't already contain an element with a key equivalent to &lt;code&gt;nh.key()&lt;/code&gt;, and returns the iterator pointing to the element with key equivalent to &lt;code&gt;nh.key()&lt;/code&gt; (regardless of whether the insert succeeded or failed). If the insertion succeeds, &lt;code&gt;nh&lt;/code&gt; is moved from, otherwise it retains ownership of the element. The element is inserted as close as possible to the position just prior to &lt;code&gt;hint&lt;/code&gt;. The behavior is undefined if &lt;code&gt;nh&lt;/code&gt; is not empty and &lt;code&gt;get_allocator() != nh.get_allocator()&lt;/code&gt;.</source>
          <target state="translated">10) 만약 &lt;code&gt;nh&lt;/code&gt; 가 빈 &lt;a href=&quot;../node_handle&quot;&gt;노드 핸들&lt;/a&gt; 이라면 , 아무것도하지 않고 엔드 이터레이터를 반환합니다. 그렇지 않으면, 소유 요소 삽입 &lt;code&gt;nh&lt;/code&gt; 컨테이너가 이미에 해당하는 키를 가진 요소를 포함하지 않는 경우, 컨테이너로를 &lt;code&gt;nh.key()&lt;/code&gt; 에 해당하는 키를 가진 요소에 대한 반복자를 가리키는 반환 &lt;code&gt;nh.key()&lt;/code&gt; (삽입의 성공 여부에 관계없이). 삽입이 성공하면 &lt;code&gt;nh&lt;/code&gt; 가 이동되고, 그렇지 않으면 요소의 소유권이 유지됩니다. 요소는 &lt;code&gt;hint&lt;/code&gt; 직전 위치에 가능한 한 가깝게 삽입됩니다 . &lt;code&gt;nh&lt;/code&gt; 이 비어 있지 않고 &lt;code&gt;get_allocator() != nh.get_allocator()&lt;/code&gt; 경우 동작이 정의되지 않습니다 ..</target>
        </trans-unit>
        <trans-unit id="a69d58647edf7feb16e96ff91c6b26a38b7e85b9" translate="yes" xml:space="preserve">
          <source>10) Implicitly converts &lt;code&gt;t&lt;/code&gt; to a string view &lt;code&gt;sv&lt;/code&gt; as if by &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt;, then initializes the string with the contents of &lt;code&gt;sv&lt;/code&gt;, as if by &lt;code&gt;basic_string(sv.data(), sv.size(), alloc)&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">10) &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt; &amp;lt;CharT, Traits&amp;gt; sv = t에 의해 &lt;code&gt;t&lt;/code&gt; 를 문자열 뷰 &lt;code&gt;sv&lt;/code&gt; 로 암시 적으로 변환합니다 . 그런 다음 &lt;code&gt;basic_string(sv.data(), sv.size(), alloc)&lt;/code&gt; 의해 &lt;code&gt;sv&lt;/code&gt; 의 내용으로 문자열을 초기화합니다 . 이 과부하는 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; &amp;lt;const T &amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std :: basic_string_view&lt;/a&gt; &amp;lt;CharT, Traits &amp;gt;&amp;gt; 가 &lt;code&gt;true&lt;/code&gt; 이고 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; &amp;lt;const T &amp;amp;, const CharT *&amp;gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우에만 과부하 해결에 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="cb2553ddbcefa3d7dcf1fd93319e154edcfd40a0" translate="yes" xml:space="preserve">
          <source>10) Implicitly converts &lt;code&gt;t&lt;/code&gt; to a string view &lt;code&gt;sv&lt;/code&gt; as if by &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt;, then inserts the elements from &lt;code&gt;sv&lt;/code&gt; before the element (if any) pointed by &lt;code&gt;pos&lt;/code&gt;, as if by &lt;code&gt;insert(pos, sv.data(), sv.size())&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">10) &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt; &amp;lt;CharT, Traits&amp;gt; sv = t에 의해 &lt;code&gt;t&lt;/code&gt; 를 문자열 뷰 &lt;code&gt;sv&lt;/code&gt; 로 암시 적으로 변환합니다 . 그런 다음 &lt;code&gt;insert(pos, sv.data(), sv.size())&lt;/code&gt; 처럼 &lt;code&gt;pos&lt;/code&gt; 가 가리키는 요소 (있는 경우) 앞에 &lt;code&gt;sv&lt;/code&gt; 의 요소를 삽입합니다 . 이 과부하는 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; &amp;lt;const T &amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std :: basic_string_view&lt;/a&gt; &amp;lt;CharT, Traits &amp;gt;&amp;gt; 가 &lt;code&gt;true&lt;/code&gt; 이고 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; &amp;lt;const T &amp;amp;, const CharT *&amp;gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우에만 과부하 해결에 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="c12cf6af554137846aca61618deeac9bdb1b93f9" translate="yes" xml:space="preserve">
          <source>10) Implicitly converts &lt;code&gt;t&lt;/code&gt; to a string view &lt;code&gt;sv&lt;/code&gt; as if by &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt;, then replaces the contents with the characters from the subview &lt;code&gt;[pos, pos+count)&lt;/code&gt; of &lt;code&gt;sv&lt;/code&gt;. If the requested subview lasts past the end of &lt;code&gt;sv&lt;/code&gt;, or if &lt;code&gt;count == npos&lt;/code&gt;, the resulting subview is &lt;code&gt;[pos, sv.size())&lt;/code&gt;. If &lt;code&gt;pos &amp;gt; sv.size()&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; is thrown. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">10) &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt; &amp;lt;CharT, Traits&amp;gt; sv = t에 의해 &lt;code&gt;t&lt;/code&gt; 를 문자열 뷰 &lt;code&gt;sv&lt;/code&gt; 로 암시 적으로 변환합니다 . 그런 다음 내용 을 &lt;code&gt;sv&lt;/code&gt; 의 하위보기 &lt;code&gt;[pos, pos+count)&lt;/code&gt; 에 있는 문자로 바꿉니다 . 요청 된 &lt;code&gt;[pos, sv.size())&lt;/code&gt; 뷰가 &lt;code&gt;sv&lt;/code&gt; 의 끝을 지난 경우 또는 &lt;code&gt;count == npos&lt;/code&gt; 인 경우 결과 서브 뷰는 [pos, sv.size ()) 입니다. 경우 &lt;code&gt;pos &amp;gt; sv.size()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; 발생합니다. &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; &amp;lt;const T &amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std :: basic_string_view&lt;/a&gt; &amp;lt;CharT, Traits &amp;gt;&amp;gt; 가 &lt;code&gt;true&lt;/code&gt; 인경우이 과부하는 과부하 해결에만 참여 합니다.및 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; 이다 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dbbd94ef6ef0f5d4df573986b81e96848b2807c9" translate="yes" xml:space="preserve">
          <source>10) Move-constructs a &lt;code&gt;shared_ptr&lt;/code&gt; from &lt;code&gt;r&lt;/code&gt;. After the construction, &lt;code&gt;*this&lt;/code&gt; contains a copy of the previous state of &lt;code&gt;r&lt;/code&gt;, &lt;code&gt;r&lt;/code&gt; is empty and its stored pointer is null. The template overload doesn't participate in overload resolution if &lt;code&gt;Y*&lt;/code&gt; is not implicitly convertible to(until C++17)</source>
          <target state="translated">10) &lt;code&gt;r&lt;/code&gt; 에서 &lt;code&gt;shared_ptr&lt;/code&gt; 을 이동 구성합니다 . 건설, 후에 &lt;code&gt;*this&lt;/code&gt; 의 이전 상태의 사본이 포함되어 &lt;code&gt;r&lt;/code&gt; , &lt;code&gt;r&lt;/code&gt; 비어 있고 그 저장 포인터가 null입니다. &lt;code&gt;Y*&lt;/code&gt; 를 암시 적으로 변환 할 수없는 경우 (C ++ 17까지) 템플릿 과부하가 과부하 해결에 참여하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bff2f7b44b44b2a7f14ccb3ebb28e3ee7f14c9c0" translate="yes" xml:space="preserve">
          <source>10) O(N) comparisons, where N is &lt;code&gt;cont.size()&lt;/code&gt;.</source>
          <target state="translated">10) O (N) 비교, 여기서 N은 &lt;code&gt;cont.size()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="756d16c8aa266b319de61ac0e2b7cf772a0b621a" translate="yes" xml:space="preserve">
          <source>10) a joinable &lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; is destroyed or assigned to</source>
          <target state="translated">10) 결합 가능한 &lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; 가 파괴되거나</target>
        </trans-unit>
        <trans-unit id="bdac980fe18bd2aa0e82dfcbff7b9704702b2021" translate="yes" xml:space="preserve">
          <source>10) in an &lt;a href=&quot;operator_assignment&quot;&gt;assignment expression&lt;/a&gt;, where list-initialization initializes the parameter of the overloaded operator</source>
          <target state="translated">10) &lt;a href=&quot;operator_assignment&quot;&gt;할당 표현식&lt;/a&gt; 에서,리스트 초기화는 오버로드 된 연산자의 매개 변수를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="f210bb4798a397813c077d58fd920563d8a2aae1" translate="yes" xml:space="preserve">
          <source>10) or, if not that, F1 is generated from a &lt;a href=&quot;deduction_guide&quot;&gt;user-defined deduction-guide&lt;/a&gt; and F2 is not 11) or, if not that, F1 is the &lt;a href=&quot;deduction_guide&quot;&gt;copy deduction candidate&lt;/a&gt; and F2 is not 12) or, if not that, F1 is generated from a non-template constructor and F2 is generated from a constructor template</source>
          <target state="translated">10) 또는 그렇지 않은 경우 F1은 &lt;a href=&quot;deduction_guide&quot;&gt;사용자 정의 공제 가이드&lt;/a&gt; 에서 생성 되고 F2는 11이 아님) 그렇지 않은 경우 F1은 &lt;a href=&quot;deduction_guide&quot;&gt;카피 공제 후보&lt;/a&gt; 이며 F2는 12)가 아니거나 그렇지 않은 경우 F1 템플릿이 아닌 생성자에서 생성되고 F2가 생성자 템플릿에서 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="4632d588d3ce8a327b5dfdc03347900593cb119a" translate="yes" xml:space="preserve">
          <source>10)&lt;code&gt;(bool)rhs&lt;/code&gt;</source>
          <target state="translated">10)&lt;code&gt;(bool)rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0024bb9be93d59d87437230fc3d1513cd86fbe14" translate="yes" xml:space="preserve">
          <source>10)&lt;code&gt;func(*this)&lt;/code&gt;</source>
          <target state="translated">10)&lt;code&gt;func(*this)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e4bb7f0e00f70abdd5e843976174b8257da0fec8" translate="yes" xml:space="preserve">
          <source>10)&lt;code&gt;x != y.date()&lt;/code&gt;</source>
          <target state="translated">10) &lt;code&gt;x != y.date()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4183bdaf2aebd0506ba19b427797904c58d29dcc" translate="yes" xml:space="preserve">
          <source>10-12) Calls &lt;code&gt;func(*this)&lt;/code&gt;. These overloads are used to implement output I/O manipulators such as &lt;code&gt;&lt;a href=&quot;../manip/endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">10-12) 전화 &lt;code&gt;func(*this)&lt;/code&gt; 합니다. 이 과부하는 &lt;code&gt;&lt;a href=&quot;../manip/endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; 과 같은 출력 I / O 조작기를 구현하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9b886f64b13a6e2c700360238c85da3d55a0974e" translate="yes" xml:space="preserve">
          <source>10-12) Divides &lt;code&gt;lhs&lt;/code&gt; by &lt;code&gt;rhs&lt;/code&gt;</source>
          <target state="translated">10-12) 나누기 &lt;code&gt;lhs&lt;/code&gt; 를 &lt;code&gt;rhs&lt;/code&gt; 로</target>
        </trans-unit>
        <trans-unit id="e7d0fc9978a5b3f9eede77ada5dee9f76fbf862d" translate="yes" xml:space="preserve">
          <source>10-12)&lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) /= rhs&lt;/code&gt;</source>
          <target state="translated">10-12) &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) /= rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d162056b967200c498f057c1e1554d33c19f3179" translate="yes" xml:space="preserve">
          <source>10-18) Identical to (1-9) except each element is created by &lt;a href=&quot;../../memory/uses_allocator#Uses-allocator_construction&quot;&gt;uses-allocator construction&lt;/a&gt;, that is, the Allocator object &lt;code&gt;a&lt;/code&gt; is passed as an additional argument to the constructor of each element for which &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&amp;lt;Ui, Alloc&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">10-18) 각 요소가 &lt;a href=&quot;../../memory/uses_allocator#Uses-allocator_construction&quot;&gt;uses-allocator&lt;/a&gt; 생성에 의해 생성되는 것을 제외하고는 (1-9)와 동일합니다 . 즉, Allocator 객체 &lt;code&gt;a&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&amp;lt;Ui, Alloc&amp;gt;::value&lt;/code&gt; 있는 각 요소의 생성자에 추가 인수로 전달됩니다. &amp;lt;Ui, Alloc&amp;gt; :: value 는 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="56a65cc1c6fc26d1f3d3ab5a7da63d7431540cd1" translate="yes" xml:space="preserve">
          <source>10.2 Member name lookup [class.member.lookup]</source>
          <target state="translated">10.2 회원 이름 조회 [class.member.lookup]</target>
        </trans-unit>
        <trans-unit id="358e3e257d91345963ad9b9cf5abf2fa4957d9b9" translate="yes" xml:space="preserve">
          <source>103&amp;ndash;122</source>
          <target state="translated">103&amp;ndash;122</target>
        </trans-unit>
        <trans-unit id="17ba0791499db908433b80f37c5fbc89b870084b" translate="yes" xml:space="preserve">
          <source>11</source>
          <target state="translated">11</target>
        </trans-unit>
        <trans-unit id="08985f2b42db1b9f50f226c482bc0714d9288cc6" translate="yes" xml:space="preserve">
          <source>11) &lt;code&gt;&lt;a href=&quot;../../utility/functional/less&quot;&gt;std::less&lt;/a&gt;&amp;lt;unique_ptr&amp;lt;T,D&amp;gt;::pointer&amp;gt;()(x.get(), nullptr)&lt;/code&gt;.</source>
          <target state="translated">11) &lt;code&gt;&lt;a href=&quot;../../utility/functional/less&quot;&gt;std::less&lt;/a&gt;&amp;lt;unique_ptr&amp;lt;T,D&amp;gt;::pointer&amp;gt;()(x.get(), nullptr)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73786445d6e40c49b3b6ddc945a0f0867724b3e9" translate="yes" xml:space="preserve">
          <source>11) A pointer to member object of some class &lt;code&gt;T1&lt;/code&gt; can be converted to a pointer to another member object of another class &lt;code&gt;T2&lt;/code&gt;. If &lt;code&gt;T2&lt;/code&gt;'s alignment is not stricter than &lt;code&gt;T1&lt;/code&gt;'s, conversion back to the original type &lt;code&gt;T1&lt;/code&gt; yields the original value, otherwise the resulting pointer cannot be used safely.</source>
          <target state="translated">11) 어떤 클래스 &lt;code&gt;T1&lt;/code&gt; 의 멤버 오브젝트에 대한 포인터는 다른 클래스 &lt;code&gt;T2&lt;/code&gt; 의 다른 멤버 오브젝트에 대한 포인터로 변환 될 수 있습니다 . 경우 &lt;code&gt;T2&lt;/code&gt; 의 정렬이보다 엄격 &lt;code&gt;T1&lt;/code&gt; 의 &quot;원래 형으로 변환 다시 &lt;code&gt;T1&lt;/code&gt; 은 별도로 생성 된 포인터를 안전하게 사용할 수없고, 원래의 값을 산출한다.</target>
        </trans-unit>
        <trans-unit id="dd1aa92627688c4b172d3a4dee428c675f47e203" translate="yes" xml:space="preserve">
          <source>11) Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, extracts all data from the input stream and stores it to &lt;code&gt;sb&lt;/code&gt;. The extraction stops if one of the following conditions are met:</source>
          <target state="translated">11) &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction으로&lt;/a&gt; 동작합니다 . 센트리 객체를 구성하고 확인한 후 입력 스트림에서 모든 데이터를 추출하여 &lt;code&gt;sb&lt;/code&gt; 에 저장합니다 . 다음 조건 중 하나가 충족되면 추출이 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="f21903216497c138656e9af6551974ee3815d404" translate="yes" xml:space="preserve">
          <source>11) Constructs a &lt;code&gt;shared_ptr&lt;/code&gt; which shares ownership of the object managed by &lt;code&gt;r&lt;/code&gt;. &lt;code&gt;Y*&lt;/code&gt; must be implicitly convertible to &lt;code&gt;T*&lt;/code&gt;.(until C++17)This overload only participates in overload resolution if &lt;code&gt;Y*&lt;/code&gt; is compatible with &lt;code&gt;T*&lt;/code&gt;.(since C++17) Note that &lt;code&gt;r.lock()&lt;/code&gt; may be used for the same purpose: the difference is that this constructor throws an exception if the argument is empty, while &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;::lock()&lt;/code&gt; constructs an empty &lt;code&gt;std::shared_ptr&lt;/code&gt; in that case.</source>
          <target state="translated">11) &lt;code&gt;r&lt;/code&gt; 에 의해 관리되는 객체의 소유권을 공유 하는 &lt;code&gt;shared_ptr&lt;/code&gt; 을 구성합니다 . &lt;code&gt;Y*&lt;/code&gt; 는 &lt;code&gt;T*&lt;/code&gt; 로 암시 적으로 변환 가능해야합니다 . (C ++ 17까지)이 과부하 는 &lt;code&gt;Y*&lt;/code&gt; 가 &lt;code&gt;T*&lt;/code&gt; 와 호환되는 경우에만 과부하 해결에 참여 합니다. (C ++ 17부터) &lt;code&gt;r.lock()&lt;/code&gt; 사용할 수 있습니다. 같은 목적으로 : 차이점은 인수가 비어 있으면이 생성자가 예외를 던지는 반면 &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;::lock()&lt;/code&gt; &amp;lt;T&amp;gt; :: lock () 은 빈을 생성합니다 &lt;code&gt;std::shared_ptr&lt;/code&gt; 을 입니다.</target>
        </trans-unit>
        <trans-unit id="042da3f7f0b381680907fc7956c77a2f60287db1" translate="yes" xml:space="preserve">
          <source>11) Constructs the adaptor with the contents of &lt;code&gt;other.c&lt;/code&gt; and using &lt;code&gt;alloc&lt;/code&gt; as allocator. Effectively calls &lt;code&gt;c(other.c, alloc)&lt;/code&gt;. Copy-constructs &lt;code&gt;comp&lt;/code&gt; from &lt;code&gt;other.comp&lt;/code&gt;.</source>
          <target state="translated">11) &lt;code&gt;other.c&lt;/code&gt; 의 내용으로 &lt;code&gt;alloc&lt;/code&gt; 을 할당 자로 사용하여 어댑터를 구성합니다 . 효과적으로 &lt;code&gt;c(other.c, alloc)&lt;/code&gt; 호출합니다 . 복사-구조는 &lt;code&gt;comp&lt;/code&gt; 에서 &lt;code&gt;other.comp&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="d07477a4003a2a7e28753c7e89d757a1992ccd34" translate="yes" xml:space="preserve">
          <source>11) Constructs the numeric array with the contents of the initializer list &lt;code&gt;il&lt;/code&gt;.</source>
          <target state="translated">11) 초기화 목록의 내용으로 숫자 형 배열을 구성합니다. &lt;code&gt;il&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6339a7daf238a12776337a5616411ddf1ac28056" translate="yes" xml:space="preserve">
          <source>11) If defined, called by the custom single-object &lt;a href=&quot;../../language/new&quot;&gt;placement new&lt;/a&gt; expression with the matching signature. If a class-specific version (19) is defined, it is called in preference to (11). If neither (11) nor (19) is provided by the user, the placement new expression is ill-formed.</source>
          <target state="translated">11) 정의 된 경우 사용자 정의 단일 객체에 의해 호출 &lt;a href=&quot;../../language/new&quot;&gt;&lt;/a&gt; 일치하는 서명을 가진 배치 새 표현식에 . 클래스 특정 버전 (19)이 정의되어 있으면 (11)보다 우선적으로 호출됩니다. 사용자가 (11) 또는 (19)를 제공하지 않으면 게재 위치 새 표현식이 잘못 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="4d46203e9df8b0c69c491a086768fd537d601391" translate="yes" xml:space="preserve">
          <source>11) Implicitly converts &lt;code&gt;t&lt;/code&gt; to a string view &lt;code&gt;sv&lt;/code&gt; as if by &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt;, then initializes the string with the subrange &lt;code&gt;[pos, pos + n)&lt;/code&gt; of &lt;code&gt;sv&lt;/code&gt; as if by &lt;code&gt;basic_string(sv.substr(pos, n), a)&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; .</source>
          <target state="translated">11) &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt; &amp;lt;CharT, Traits&amp;gt; sv = t에 의해 &lt;code&gt;t&lt;/code&gt; 를 문자열 뷰 &lt;code&gt;sv&lt;/code&gt; 로 암시 적으로 변환합니다 . 그런 다음 &lt;code&gt;basic_string(sv.substr(pos, n), a)&lt;/code&gt; 의해 &lt;code&gt;sv&lt;/code&gt; 의 하위 범위 &lt;code&gt;[pos, pos + n)&lt;/code&gt; 로 문자열을 초기화합니다 . 이 과부하는 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; &amp;lt;const T &amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std :: basic_string_view&lt;/a&gt; &amp;lt;CharT, Traits &amp;gt;&amp;gt; 가 다음과 같은 경우에만 과부하 해결에 참여합니다. &lt;code&gt;true&lt;/code&gt; 인 합니다 .</target>
        </trans-unit>
        <trans-unit id="2898b7ac8f6f43a5960951a8d81750e1dec51fc8" translate="yes" xml:space="preserve">
          <source>11) Implicitly converts &lt;code&gt;t&lt;/code&gt; to a string view &lt;code&gt;sv&lt;/code&gt; as if by &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt;, then inserts, before the element (if any) pointed by &lt;code&gt;pos&lt;/code&gt;, the characters from the subview &lt;code&gt;[index_str, index_str+count)&lt;/code&gt; of &lt;code&gt;sv&lt;/code&gt;. If the requested subview lasts past the end of &lt;code&gt;sv&lt;/code&gt;, or if &lt;code&gt;count == npos&lt;/code&gt;, the resulting subview is &lt;code&gt;[index_str, sv.size())&lt;/code&gt;. If &lt;code&gt;index_str &amp;gt; sv.size()&lt;/code&gt;, or if &lt;code&gt;index &amp;gt; size()&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; is thrown. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">11) &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt; sv = t;&lt;/code&gt; &amp;lt;CharT, Traits&amp;gt; sv = t에 의해 &lt;code&gt;t&lt;/code&gt; 를 문자열 뷰 &lt;code&gt;sv&lt;/code&gt; 로 암시 적으로 변환합니다 . 그런 다음 &lt;code&gt;pos&lt;/code&gt; 가 가리키는 요소 (있는 경우) 앞에 &lt;code&gt;sv&lt;/code&gt; 의 &lt;code&gt;[index_str, index_str+count)&lt;/code&gt; 뷰 [index_str, index_str + count) 의 문자를 삽입합니다 . 요청 된 &lt;code&gt;[index_str, sv.size())&lt;/code&gt; 뷰가 &lt;code&gt;sv&lt;/code&gt; 의 끝을 지난 경우 또는 &lt;code&gt;count == npos&lt;/code&gt; 인 경우 결과 서브 뷰는 [index_str, sv.size ()) 입니다. 만약 &lt;code&gt;index_str &amp;gt; sv.size()&lt;/code&gt; , 또는 경우 &lt;code&gt;index &amp;gt; size()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; 발생합니다. 이 과부하는 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, &lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&amp;gt;&lt;/code&gt; 경우에만 과부하 해결에 참여합니다. &amp;lt;CONST &amp;amp; T, &lt;a href=&quot;../basic_string_view&quot;&gt;표준 : basic_string_view&lt;/a&gt; &amp;lt;차트 형질 &amp;gt;&amp;gt; 이고 &lt;code&gt;true&lt;/code&gt; 이고 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const T&amp;amp;, const CharT*&amp;gt;&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8f60a8bb598cf1c234ad741936c0d499baf28c37" translate="yes" xml:space="preserve">
          <source>11) Linear in size of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">11) &lt;code&gt;other&lt;/code&gt; 크기의 선형 .</target>
        </trans-unit>
        <trans-unit id="c24bd216db448fdf606800b4fbf7a631a6c2db28" translate="yes" xml:space="preserve">
          <source>11) Returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">11) &lt;code&gt;false&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="6be7f31d110559c6e2e1395940c3b1642aecd202" translate="yes" xml:space="preserve">
          <source>11) Same as 10), but may fail spuriously.</source>
          <target state="translated">11) 10)과 동일하지만 허위로 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87e831ddc66ef59ab930cf79ba16a9b480e1d175" translate="yes" xml:space="preserve">
          <source>11) Throws &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;index &amp;gt; size()&lt;/code&gt; or if &lt;code&gt;index_str &amp;gt; sv.size()&lt;/code&gt;.</source>
          <target state="translated">11) &lt;code&gt;index &amp;gt; size()&lt;/code&gt; 또는 &lt;code&gt;index_str &amp;gt; sv.size()&lt;/code&gt; 경우 &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="0f8b44fc9fd169778b8bf6deba9467f7a3f2801d" translate="yes" xml:space="preserve">
          <source>11) a function invoked by a &lt;a href=&quot;../algorithm&quot;&gt;parallel algorithm&lt;/a&gt; exits via an uncaught exception and the &lt;a href=&quot;../algorithm/execution_policy_tag_t&quot;&gt;execution policy&lt;/a&gt; specifies termination.</source>
          <target state="translated">11) &lt;a href=&quot;../algorithm&quot;&gt;병렬 알고리즘에&lt;/a&gt; 의해 호출 된 함수 는 포착되지 않은 예외를 통해 종료되고 &lt;a href=&quot;../algorithm/execution_policy_tag_t&quot;&gt;실행 정책&lt;/a&gt; 은 종료를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="0f958c544ebd132dd3442cd782ab40ff6e6aa9a2" translate="yes" xml:space="preserve">
          <source>11)&lt;a href=&quot;explicit_cast&quot;&gt;functional cast expression&lt;/a&gt; or other constructor invocations, where</source>
          <target state="translated">11) &lt;a href=&quot;explicit_cast&quot;&gt;기능적 캐스트 표현식&lt;/a&gt; 또는 기타 생성자 호출</target>
        </trans-unit>
        <trans-unit id="629aa675a334eda6c70326e152710b1b069eee7c" translate="yes" xml:space="preserve">
          <source>11)&lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;pos&lt;/code&gt; is out of range</source>
          <target state="translated">11) &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; 경우 &lt;code&gt;pos&lt;/code&gt; 범위를 벗어</target>
        </trans-unit>
        <trans-unit id="cb08924492a6de9cfec8eb080a5faf5f769e708e" translate="yes" xml:space="preserve">
          <source>11)&lt;code&gt;&lt;a href=&quot;../../utility/functional/less&quot;&gt;std::less&lt;/a&gt;&amp;lt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;::element_type*&amp;gt;()(lhs.get(), nullptr)&lt;/code&gt;</source>
          <target state="translated">11) &lt;code&gt;&lt;a href=&quot;../../utility/functional/less&quot;&gt;std::less&lt;/a&gt;&amp;lt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;::element_type*&amp;gt;()(lhs.get(), nullptr)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db1a92004c902023bc2815cbba3f91033c8e8039" translate="yes" xml:space="preserve">
          <source>11)&lt;code&gt;&lt;a href=&quot;../bad_weak_ptr&quot;&gt;std::bad_weak_ptr&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;r.expired() == true&lt;/code&gt;. The constructor has no effect in this case.</source>
          <target state="translated">11) &lt;code&gt;&lt;a href=&quot;../bad_weak_ptr&quot;&gt;std::bad_weak_ptr&lt;/a&gt;&lt;/code&gt; 경우 &lt;code&gt;r.expired() == true&lt;/code&gt; . 이 경우 생성자는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ed0fb6f34272f71914fd110668ae7bae47ad86f0" translate="yes" xml:space="preserve">
          <source>11)&lt;code&gt;x.date() &amp;lt; y&lt;/code&gt;</source>
          <target state="translated">11) &lt;code&gt;x.date() &amp;lt; y&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3fa6e1f21990f991d00cd434bc476133d889cf60" translate="yes" xml:space="preserve">
          <source>11,12) Same as (9,10), except called if the alignment requirement exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;</source>
          <target state="translated">11,12) 정렬 요구 사항이 &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; 를 초과하는 경우 호출되는 것을 제외하고 (9,10)과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="461f91419f109ee4ea1460201ae6d0c63f3774cd" translate="yes" xml:space="preserve">
          <source>11-22) same as (1-4) if the function does not return on allocation failure, otherwise same as (5-8)</source>
          <target state="translated">11-22) 할당 실패시 함수가 반환하지 않으면 (1-4)와 동일, 그렇지 않으면 (5-8)</target>
        </trans-unit>
        <trans-unit id="698aa6c0fc21596559dce9018e2f78448cd3d79f" translate="yes" xml:space="preserve">
          <source>11.3 Friends [class.friend]</source>
          <target state="translated">11.3 친구 [class.friend]</target>
        </trans-unit>
        <trans-unit id="7b52009b64fd0a2a49e6d8a939753077792b0554" translate="yes" xml:space="preserve">
          <source>12</source>
          <target state="translated">12</target>
        </trans-unit>
        <trans-unit id="74f2f89b26a4915eb4cdf3d7d079eec3e4a513bf" translate="yes" xml:space="preserve">
          <source>12) &lt;code&gt;&lt;a href=&quot;../../utility/functional/less&quot;&gt;std::less&lt;/a&gt;&amp;lt;unique_ptr&amp;lt;T,D&amp;gt;::pointer&amp;gt;()(nullptr, y.get())&lt;/code&gt;.</source>
          <target state="translated">12) &lt;code&gt;&lt;a href=&quot;../../utility/functional/less&quot;&gt;std::less&lt;/a&gt;&amp;lt;unique_ptr&amp;lt;T,D&amp;gt;::pointer&amp;gt;()(nullptr, y.get())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31b759306b4f1eda569ddd18aa9e3854c836380a" translate="yes" xml:space="preserve">
          <source>12) Constant.</source>
          <target state="translated">12) 상수.</target>
        </trans-unit>
        <trans-unit id="2fcb1a0c1acef32f64e5c4652cb41ef031e6fe9e" translate="yes" xml:space="preserve">
          <source>12) Constructs a &lt;code&gt;shared_ptr&lt;/code&gt; that stores and owns the object formerly owned by &lt;code&gt;r&lt;/code&gt;. &lt;code&gt;Y*&lt;/code&gt; must be convertible to &lt;code&gt;T*&lt;/code&gt;. After construction, &lt;code&gt;r&lt;/code&gt; is empty.</source>
          <target state="translated">12) 이전에 &lt;code&gt;r&lt;/code&gt; 소유했던 객체를 저장하고 소유 하는 &lt;code&gt;shared_ptr&lt;/code&gt; 을 구성합니다 . &lt;code&gt;Y*&lt;/code&gt; 는 &lt;code&gt;T*&lt;/code&gt; 로 변환 가능해야합니다 . 시공 후 &lt;code&gt;r&lt;/code&gt; 은 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d118cc01838a52c24c06c4db6304709c29bba0ea" translate="yes" xml:space="preserve">
          <source>12) Constructs the adaptor with the contents of &lt;code&gt;other&lt;/code&gt; using move semantics while utilising &lt;code&gt;alloc&lt;/code&gt; as allocator. Effectively calls &lt;code&gt;c(std::move(other.c), alloc)&lt;/code&gt;. Move-constructs &lt;code&gt;comp&lt;/code&gt; from &lt;code&gt;other.comp&lt;/code&gt;.</source>
          <target state="translated">12) &lt;code&gt;alloc&lt;/code&gt; 을 할당 자로 사용하면서 이동 의미를 사용하여 &lt;code&gt;other&lt;/code&gt; 내용으로 어댑터를 구성합니다 . 효과적으로 &lt;code&gt;c(std::move(other.c), alloc)&lt;/code&gt; 호출합니다 . 입주 구조는 &lt;code&gt;comp&lt;/code&gt; 에서 &lt;code&gt;other.comp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1064d0a6430df49daa239a555f9537549d4a28ec" translate="yes" xml:space="preserve">
          <source>12) If defined, called by the custom array form &lt;a href=&quot;../../language/new&quot;&gt;placement new&lt;/a&gt; expression with the matching signature. If a class-specific version (20) is defined, it is called in preference to (12). If neither (12) nor (20) is provided by the user, the placement new expression is ill-formed.</source>
          <target state="translated">12) 정의 된 경우 사용자 정의 배열 양식 &lt;a href=&quot;../../language/new&quot;&gt;배치에&lt;/a&gt; 의해 호출 일치하는 서명이 표현식에 . 클래스 별 버전 (20)이 정의되어 있으면 (12)보다 우선적으로 호출됩니다. 사용자가 (12) 또는 (20)을 제공하지 않으면 게재 위치 새 표현식이 잘못 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="8924f016ad4339812d437ec63747620c3f29503d" translate="yes" xml:space="preserve">
          <source>12) Returns &lt;code&gt;bool(opt)&lt;/code&gt;.</source>
          <target state="translated">12) &lt;code&gt;bool(opt)&lt;/code&gt; )를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="3df41998ceb06b69a940c73aac09ff4cff4e5fcb" translate="yes" xml:space="preserve">
          <source>12) in a non-static &lt;a href=&quot;data_members#Member_initialization&quot;&gt;data member initializer&lt;/a&gt; that uses the equals sign</source>
          <target state="translated">12) 등호를 사용 하는 비 정적 &lt;a href=&quot;data_members#Member_initialization&quot;&gt;데이터 멤버 이니셜 라이저&lt;/a&gt; 에서</target>
        </trans-unit>
        <trans-unit id="3cda5622fd3f7d56c783bcb614e7665a7eb76138" translate="yes" xml:space="preserve">
          <source>12)&lt;code&gt;&lt;a href=&quot;../../utility/functional/less&quot;&gt;std::less&lt;/a&gt;&amp;lt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;::element_type*&amp;gt;()(nullptr, rhs.get())&lt;/code&gt;</source>
          <target state="translated">12) &lt;code&gt;&lt;a href=&quot;../../utility/functional/less&quot;&gt;std::less&lt;/a&gt;&amp;lt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;::element_type*&amp;gt;()(nullptr, rhs.get())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a92166ee8fd511d7e6ce92f94c807d6b7d9e2e53" translate="yes" xml:space="preserve">
          <source>12)&lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if required additional memory could not be obtained. May throw implementation-defined exception for other errors. This constructor has no effect if an exception occurs.</source>
          <target state="translated">12) &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 필요한 경우 추가 메모리를 확보 할 수 없습니다. 다른 오류에 대해서는 구현 정의 예외가 발생할 수 있습니다. 예외가 발생하면이 생성자는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8bdf8a0495d707e537f24c4c1c1c5125523b5899" translate="yes" xml:space="preserve">
          <source>12)&lt;code&gt;func(*this)&lt;/code&gt;</source>
          <target state="translated">12)&lt;code&gt;func(*this)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65bf588dec63051d372e5e59b6ebfa11ffcc4018" translate="yes" xml:space="preserve">
          <source>12)&lt;code&gt;x &amp;lt; y.date()&lt;/code&gt;</source>
          <target state="translated">12) &lt;code&gt;x &amp;lt; y.date()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ccd48202f2f68591bda1f581677caccf41c8d124" translate="yes" xml:space="preserve">
          <source>12,14)&lt;code&gt;&lt;a href=&quot;month_weekday&quot;&gt;std::chrono::month_weekday&lt;/a&gt;(m, wdi)&lt;/code&gt;</source>
          <target state="translated">12,14) &lt;code&gt;&lt;a href=&quot;month_weekday&quot;&gt;std::chrono::month_weekday&lt;/a&gt;(m, wdi)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="848c41de183c320b85c6f9f9f0e56a4b2d8fff50" translate="yes" xml:space="preserve">
          <source>12-hour format</source>
          <target state="translated">12 시간 형식</target>
        </trans-unit>
        <trans-unit id="bf1a5257caf160010513c5d7718689434327acef" translate="yes" xml:space="preserve">
          <source>12.1 Constructors [class.ctor]</source>
          <target state="translated">12.1 생성자 [class.ctor]</target>
        </trans-unit>
        <trans-unit id="d696bd74570b3523da8cdad8653ad6c0a561e801" translate="yes" xml:space="preserve">
          <source>12.6.2 Initializing bases and members [class.base.init]</source>
          <target state="translated">12.6.2 기본 및 멤버 초기화 [class.base.init]</target>
        </trans-unit>
        <trans-unit id="d57a1b91b05af98b51640f6b9c68c46e24ce46aa" translate="yes" xml:space="preserve">
          <source>123&amp;ndash;126</source>
          <target state="translated">123&amp;ndash;126</target>
        </trans-unit>
        <trans-unit id="a03a38780882f806401e4bb17cea7e924023d58e" translate="yes" xml:space="preserve">
          <source>123&amp;times;10&lt;sup&gt;4&lt;/sup&gt;</source>
          <target state="translated">123&amp;times;10&lt;sup&gt;4&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="008451a05e1e7aa32c75119df950d405265e0904" translate="yes" xml:space="preserve">
          <source>127</source>
          <target state="translated">127</target>
        </trans-unit>
        <trans-unit id="bd307a3ec329e10a2cff8fb87480823da114f8f4" translate="yes" xml:space="preserve">
          <source>13</source>
          <target state="translated">13</target>
        </trans-unit>
        <trans-unit id="d60b9c4be8143594f163cae8af9352ee80c4728a" translate="yes" xml:space="preserve">
          <source>13) &lt;code&gt;!(nullptr &amp;lt; x)&lt;/code&gt;.</source>
          <target state="translated">13) &lt;code&gt;!(nullptr &amp;lt; x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdd47ad8cef2f0d762a68f7f96332bc188c6841c" translate="yes" xml:space="preserve">
          <source>13) Called by the standard single-object &lt;a href=&quot;../../language/new&quot;&gt;placement new&lt;/a&gt; expression if the object's constructor throws an exception. The standard library implementation of this function does nothing.</source>
          <target state="translated">13) 객체의 생성자가 예외를 던지면 표준 단일 객체 &lt;a href=&quot;../../language/new&quot;&gt;배치 새&lt;/a&gt; 표현식에 의해 호출됩니다 . 이 함수의 표준 라이브러리 구현은 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="18afbc8b7e7701f4ca62643eee46017b2bf11879" translate="yes" xml:space="preserve">
          <source>13) Constructs a &lt;code&gt;shared_ptr&lt;/code&gt; which manages the object currently managed by &lt;code&gt;r&lt;/code&gt;. The deleter associated with &lt;code&gt;r&lt;/code&gt; is stored for future deletion of the managed object. &lt;code&gt;r&lt;/code&gt; manages no object after the call.</source>
          <target state="translated">13) &lt;code&gt;r&lt;/code&gt; 에 의해 현재 관리되는 객체를 관리 하는 &lt;code&gt;shared_ptr&lt;/code&gt; 을 구성합니다 . &lt;code&gt;r&lt;/code&gt; 과 연관된 삭제 기는 나중에 관리 대상 객체를 삭제하기 위해 저장됩니다. &lt;code&gt;r&lt;/code&gt; 은 호출 후 오브젝트를 관리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eba9828117c02d17e50e1c06312dba4a0280f0e4" translate="yes" xml:space="preserve">
          <source>13) Copy-constructs &lt;code&gt;c&lt;/code&gt; from &lt;code&gt;cont&lt;/code&gt; and &lt;code&gt;comp&lt;/code&gt; from &lt;code&gt;compare&lt;/code&gt;. Then calls &lt;code&gt;c.insert(c.end(), first, last);&lt;/code&gt;, and then calls &lt;code&gt;&lt;a href=&quot;../../algorithm/make_heap&quot;&gt;std::make_heap&lt;/a&gt;(c.begin(), c.end(), comp);&lt;/code&gt;.</source>
          <target state="translated">13) &lt;code&gt;c&lt;/code&gt; 를 &lt;code&gt;cont&lt;/code&gt; 에서 복사 하고 &lt;code&gt;comp&lt;/code&gt; 를 comp 에서 &lt;code&gt;compare&lt;/code&gt; 합니다. 그런 다음 &lt;code&gt;c.insert(c.end(), first, last);&lt;/code&gt; 호출합니다 . 그런 다음 &lt;code&gt;&lt;a href=&quot;../../algorithm/make_heap&quot;&gt;std::make_heap&lt;/a&gt;(c.begin(), c.end(), comp);&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bff2a80a1cd27f36b61fc22365d2c29d8e83c5c" translate="yes" xml:space="preserve">
          <source>13) If an exception is thrown, the constructor has no effects.</source>
          <target state="translated">13) 예외가 발생하면 생성자는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="534e7c72fa5557c51f4970d2ab8607df8b86b487" translate="yes" xml:space="preserve">
          <source>13) If defined, called by the custom single-object &lt;a href=&quot;../../language/new&quot;&gt;placement new&lt;/a&gt; expression with the matching signature if the object's alignment requirement exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;. If a class-specific version is defined ((15) or (17)), it is called instead. If neither class-specific nor global alignment-aware (this one) placement form is provided, alignment-unaware placement form (11) is looked up instead.</source>
          <target state="translated">13) 정의 된 경우, 객체의 정렬 요구 사항이 &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; 를 초과하는 경우 일치하는 서명 이있는 사용자 지정 단일 객체 &lt;a href=&quot;../../language/new&quot;&gt;배치 새&lt;/a&gt; 표현식에 의해 호출됩니다 . 클래스 별 버전이 정의되어 있으면 ((15) 또는 (17)) 대신 호출됩니다. 클래스 별 정렬 또는 전체 정렬 인식 (이것) 배치 양식이 제공되지 않으면 정렬 인식하지 않은 배치 양식 (11)이 대신 조회됩니다.</target>
        </trans-unit>
        <trans-unit id="662d2a4b3b88fb0d4c26dc14e2b940a9a84be328" translate="yes" xml:space="preserve">
          <source>13) O(N) comparisons, where N is &lt;code&gt;cont.size() + &lt;a href=&quot;../../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;.</source>
          <target state="translated">13) O (N) 비교, 여기서 N은 &lt;code&gt;cont.size() + &lt;a href=&quot;../../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3e3f38bf44bec00d5a2a3cf65ca178bfd638ae9a" translate="yes" xml:space="preserve">
          <source>13) Returns &lt;code&gt;!opt&lt;/code&gt;.</source>
          <target state="translated">13) &lt;code&gt;!opt&lt;/code&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="f6c8c3c64d8a59b915c26bf4758ef77b018bde7e" translate="yes" xml:space="preserve">
          <source>13)&lt;code&gt;nullptr &amp;lt; lhs&lt;/code&gt;</source>
          <target state="translated">13) &lt;code&gt;nullptr &amp;lt; lhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a8affae485196c0afb42b364daef9108d6892c8" translate="yes" xml:space="preserve">
          <source>13)&lt;code&gt;x.date() &amp;gt; y&lt;/code&gt;</source>
          <target state="translated">13) &lt;code&gt;x.date() &amp;gt; y&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17645a4692cca29918060799b2f7ed11d5bda4d9" translate="yes" xml:space="preserve">
          <source>13,15)&lt;code&gt;&lt;a href=&quot;month_weekday&quot;&gt;std::chrono::month_weekday&lt;/a&gt;(&lt;a href=&quot;month&quot;&gt;std::chrono::month&lt;/a&gt;(m), wdi)&lt;/code&gt;</source>
          <target state="translated">13,15) &lt;code&gt;&lt;a href=&quot;month_weekday&quot;&gt;std::chrono::month_weekday&lt;/a&gt;(&lt;a href=&quot;month&quot;&gt;std::chrono::month&lt;/a&gt;(m), wdi)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="de85b2fbc7d80597a0712e2a4e4512f16a1ba526" translate="yes" xml:space="preserve">
          <source>13.3 Overload resolution [over.match]</source>
          <target state="translated">13.3 과부하 해결 [over.match]</target>
        </trans-unit>
        <trans-unit id="583e8b2330a9fc9f60a22da89990bd35f783c462" translate="yes" xml:space="preserve">
          <source>13.4 Address of overloaded function [over.over]</source>
          <target state="translated">13.4 오버로드 된 기능의 주소 [over.over]</target>
        </trans-unit>
        <trans-unit id="fa35e192121eabf3dabf9f5ea6abdbcbc107ac3b" translate="yes" xml:space="preserve">
          <source>14</source>
          <target state="translated">14</target>
        </trans-unit>
        <trans-unit id="2b76195c910d81ae1ae417ba1c3fe23e28cfc96f" translate="yes" xml:space="preserve">
          <source>14&amp;ndash;31</source>
          <target state="translated">14&amp;ndash;31</target>
        </trans-unit>
        <trans-unit id="f3b49970abebd4d2bfb2393fa6c3ba1b6ff9c3d6" translate="yes" xml:space="preserve">
          <source>14) &lt;code&gt;!(y &amp;lt; nullptr)&lt;/code&gt;.</source>
          <target state="translated">14) &lt;code&gt;!(y &amp;lt; nullptr)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="293dc188a8e7a33f7bcc9f8579496715694fb479" translate="yes" xml:space="preserve">
          <source>14) Called by the standard array form of the &lt;a href=&quot;../../language/new&quot;&gt;placement new&lt;/a&gt; expression if any of the objects' constructors throws an exception (after executing the destructors of all objects that were constructed successfully). The standard library implementation of this function does nothing.</source>
          <target state="translated">14) 개체 생성자가 예외를 throw하면 (성공적으로 구성된 모든 개체의 소멸자를 실행 한 후) &lt;a href=&quot;../../language/new&quot;&gt;배치 새&lt;/a&gt; 식 의 표준 배열 형식으로 호출됩니다 . 이 함수의 표준 라이브러리 구현은 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6d0651a7dc3893472591ff5fef327c520df0f60e" translate="yes" xml:space="preserve">
          <source>14) If defined, called by the custom array form &lt;a href=&quot;../../language/new&quot;&gt;placement new&lt;/a&gt; expression with the matching signature if the element's alignment requirement exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;. If a class-specific version ((16) or (18)) is defined, it is called instead. If neither class-specific nor global alignment-aware (this one) placement form is provided, alignment-unaware placement form (12) is looked up instead.</source>
          <target state="translated">14) 정의 된 경우, 요소의 정렬 요구 사항이 &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; 를 초과하는 경우 일치하는 서명 이있는 사용자 정의 배열 양식 &lt;a href=&quot;../../language/new&quot;&gt;배치 새&lt;/a&gt; 표현식에 의해 호출됩니다. . 클래스 별 버전 ((16) 또는 (18))이 정의 된 경우 대신 호출됩니다. 클래스 별 정렬 또는 전체 정렬 인식 (이 하나) 배치 양식이 제공되지 않으면 정렬 비 인식 배치 양식 (12)이 대신 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="44a48597c7be657c1593ec4ac4a4d635f87712a1" translate="yes" xml:space="preserve">
          <source>14) Move-constructs &lt;code&gt;c&lt;/code&gt; from &lt;code&gt;std::move(cont)&lt;/code&gt; and &lt;code&gt;comp&lt;/code&gt; from &lt;code&gt;std::move(compare)&lt;/code&gt;. Then calls &lt;code&gt;c.insert(c.end(), first, last);&lt;/code&gt;, and then calls &lt;code&gt;&lt;a href=&quot;../../algorithm/make_heap&quot;&gt;std::make_heap&lt;/a&gt;(c.begin(), c.end(), comp);&lt;/code&gt;.</source>
          <target state="translated">14) &lt;code&gt;c&lt;/code&gt; 를 &lt;code&gt;std::move(cont)&lt;/code&gt; 에서 &lt;code&gt;std::move(compare)&lt;/code&gt; 하고 &lt;code&gt;comp&lt;/code&gt; 를 std :: move (compare)에서 이동 합니다. 그런 다음 &lt;code&gt;c.insert(c.end(), first, last);&lt;/code&gt; 호출합니다 . 그런 다음 &lt;code&gt;&lt;a href=&quot;../../algorithm/make_heap&quot;&gt;std::make_heap&lt;/a&gt;(c.begin(), c.end(), comp);&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd9b24d783b4cea59ccad76d089bbf5c78330dfa" translate="yes" xml:space="preserve">
          <source>14) O(N) comparisons, where N is &lt;code&gt;cont.size() + &lt;a href=&quot;../../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;.</source>
          <target state="translated">14) O (N) 비교, 여기서 N은 &lt;code&gt;cont.size() + &lt;a href=&quot;../../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5873d4ba6d3e5cb765ef3bb80170db96ad79ce67" translate="yes" xml:space="preserve">
          <source>14) Returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">14) &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="9fb6a8002b4fc55a4ac3fc0b2b1d5b20a9f821db" translate="yes" xml:space="preserve">
          <source>14)&lt;code&gt;rhs &amp;lt; nullptr&lt;/code&gt;</source>
          <target state="translated">14) &lt;code&gt;rhs &amp;lt; nullptr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="816255564a280baf88e507a30c2158e468b74643" translate="yes" xml:space="preserve">
          <source>14)&lt;code&gt;x &amp;gt; y.date()&lt;/code&gt;</source>
          <target state="translated">14) &lt;code&gt;x &amp;gt; y.date()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b8178a6b0649cf0699f4524b9c413aa858baa1ae" translate="yes" xml:space="preserve">
          <source>14.5.3 Friends [temp.friend]</source>
          <target state="translated">14.5.3 친구 [temp.friend]</target>
        </trans-unit>
        <trans-unit id="d4bc56c2432f4fb8fb85c9abf8dc4fd9d6b7520f" translate="yes" xml:space="preserve">
          <source>14.5.4 Friends [temp.friend]</source>
          <target state="translated">14.5.4 친구 [temp.friend]</target>
        </trans-unit>
        <trans-unit id="2200b2e01eff7d7dfd1880b30374972da20cb166" translate="yes" xml:space="preserve">
          <source>14.6 Name resolution [temp.res]</source>
          <target state="translated">14.6 이름 확인 [temp.res]</target>
        </trans-unit>
        <trans-unit id="f1abd670358e036c31296e66b3b66c382ac00812" translate="yes" xml:space="preserve">
          <source>15</source>
          <target state="translated">15</target>
        </trans-unit>
        <trans-unit id="4a189996f20dff97c284a5d32031f0b60074573e" translate="yes" xml:space="preserve">
          <source>15) &lt;code&gt;nullptr &amp;lt; x&lt;/code&gt;.</source>
          <target state="translated">15) &lt;code&gt;nullptr &amp;lt; x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d999e66f7fba583f983ae34b6d5fe10850eb5cd1" translate="yes" xml:space="preserve">
          <source>15) If defined, called by the custom single-object &lt;a href=&quot;../../language/new&quot;&gt;placement new&lt;/a&gt; expression with the matching signature if the object's constructor throws an exception. If a class-specific version (25) is defined, it is called in preference to (9). If neither (25) nor (15) is provided by the user, no deallocation function is called.</source>
          <target state="translated">15) 정의 된 경우, 객체의 생성자가 예외를 throw하면 일치하는 서명을 가진 사용자 정의 단일 객체 &lt;a href=&quot;../../language/new&quot;&gt;배치 새&lt;/a&gt; 표현식에 의해 호출됩니다 . 클래스 별 버전 (25)이 정의되어 있으면 (9)보다 우선적으로 호출됩니다. 사용자가 (25) 또는 (15)를 제공하지 않으면 할당 해제 기능이 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6cb729ce98108c8762d47b314a38f27d93e855ce" translate="yes" xml:space="preserve">
          <source>15) If defined, called by the usual single-object &lt;a href=&quot;../../language/new&quot;&gt;new-expressions&lt;/a&gt; if allocating an object of type T.</source>
          <target state="translated">15) 정의 된 경우, 유형 T의 오브젝트를 할당하는 경우 일반적인 단일 오브젝트 &lt;a href=&quot;../../language/new&quot;&gt;새 표현식에&lt;/a&gt; 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="e5665decf5c8ad58a40b1256672e19b53eb44d41" translate="yes" xml:space="preserve">
          <source>15) Returns &lt;code&gt;bool(opt)&lt;/code&gt;.</source>
          <target state="translated">15) &lt;code&gt;bool(opt)&lt;/code&gt; )를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="ea6bccadca9a024661c19e45109f67c34cf8abd1" translate="yes" xml:space="preserve">
          <source>15)&lt;code&gt;!(nullptr &amp;lt; lhs)&lt;/code&gt;</source>
          <target state="translated">15) &lt;code&gt;!(nullptr &amp;lt; lhs)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="72dc4695f7d6e8425380e8c4c29053d670ff3861" translate="yes" xml:space="preserve">
          <source>15)&lt;code&gt;x.date() &amp;lt;= y&lt;/code&gt;</source>
          <target state="translated">15) &lt;code&gt;x.date() &amp;lt;= y&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1574bddb75c78a6fd2251d61e2993b5146201319" translate="yes" xml:space="preserve">
          <source>16</source>
          <target state="translated">16</target>
        </trans-unit>
        <trans-unit id="90a8416e97b40aed871699e2622d6515bc43c36a" translate="yes" xml:space="preserve">
          <source>16) &lt;code&gt;y &amp;lt; nullptr&lt;/code&gt;.</source>
          <target state="translated">16) &lt;code&gt;y &amp;lt; nullptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="899e291b9e59e2c154ba0ef54563a5bb96c36a8e" translate="yes" xml:space="preserve">
          <source>16) If defined, called by the custom array form of &lt;a href=&quot;../../language/new&quot;&gt;placement new[] &lt;/a&gt; expression with the matching signature if any of the objects' constructors throws an exception (after executing the destructors for all objects that were constructed successfully). If a class-specific version (16) is defined, it is called in preference to (10). If neither (26) nor (16) is provided by the user, no deallocation function is called</source>
          <target state="translated">16) 정의 된 경우, 객체 생성자가 예외를 발생시키는 경우 (성공적으로 구성된 모든 객체에 대해 소멸자를 실행 한 후) 일치하는 서명을 가진 &lt;a href=&quot;../../language/new&quot;&gt;배치 new []&lt;/a&gt; 표현식 의 사용자 정의 배열 형식으로 호출됩니다 . 클래스 별 버전 (16)이 정의되어 있으면 (10)보다 우선적으로 호출됩니다. 사용자가 (26) 또는 (16)을 제공하지 않으면 할당 해제 기능이 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3cf6d3c96c9d390a7269da096642e3704dc07184" translate="yes" xml:space="preserve">
          <source>16) If defined, called by the usual array &lt;a href=&quot;../../language/new&quot;&gt;new[]-expressions&lt;/a&gt; if allocating an array of objects of type T.</source>
          <target state="translated">16) 정의 된 경우, 일반 배열 &lt;a href=&quot;../../language/new&quot;&gt;new []&lt;/a&gt; -expressions에 의해 호출됩니다. 유형 T의 객체 배열을 할당하는 경우.</target>
        </trans-unit>
        <trans-unit id="c81f32688f6ffafdeee5c1c4a7d116d4a87ba175" translate="yes" xml:space="preserve">
          <source>16) Returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">16) &lt;code&gt;false&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="fee79f0f955e146abf554d8e89bc65830d5c1f63" translate="yes" xml:space="preserve">
          <source>16)&lt;code&gt;!(rhs &amp;lt; nullptr)&lt;/code&gt;</source>
          <target state="translated">16) &lt;code&gt;!(rhs &amp;lt; nullptr)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="623d1ad5378b40cdd64335c0434eeb822589c12d" translate="yes" xml:space="preserve">
          <source>16)&lt;code&gt;x &amp;lt;= y.date()&lt;/code&gt;</source>
          <target state="translated">16) &lt;code&gt;x &amp;lt;= y.date()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a182c495dfdea1203d729b81afd10a4efea1113f" translate="yes" xml:space="preserve">
          <source>16,18)&lt;code&gt;&lt;a href=&quot;month_weekday_last&quot;&gt;std::chrono::month_weekday_last&lt;/a&gt;(m, wdl)&lt;/code&gt;</source>
          <target state="translated">16,18) &lt;code&gt;&lt;a href=&quot;month_weekday_last&quot;&gt;std::chrono::month_weekday_last&lt;/a&gt;(m, wdl)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0716d9708d321ffb6a00818614779e779925365c" translate="yes" xml:space="preserve">
          <source>17</source>
          <target state="translated">17</target>
        </trans-unit>
        <trans-unit id="24013436d7abd0a6ddf32084fe8e1b0e21956ca1" translate="yes" xml:space="preserve">
          <source>17) &lt;code&gt;!(x &amp;lt; nullptr)&lt;/code&gt;.</source>
          <target state="translated">17) &lt;code&gt;!(x &amp;lt; nullptr)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3e36c400f7830221661a178783e1ae8c7bb3149" translate="yes" xml:space="preserve">
          <source>17) If defined, called by the usual single-object &lt;a href=&quot;../../language/delete&quot;&gt;delete-expressions&lt;/a&gt; if deallocating an object of type T.</source>
          <target state="translated">17) 정의 된 경우, 유형 T의 오브젝트를 할당 해제하는 경우 일반적인 단일 오브젝트 &lt;a href=&quot;../../language/delete&quot;&gt;삭제 표현식에&lt;/a&gt; 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="50f3cf28321bfb2eb0728ac8ee03fd45feaaeba0" translate="yes" xml:space="preserve">
          <source>17) If defined, called by the usual single-object &lt;a href=&quot;../../language/new&quot;&gt;new-expressions&lt;/a&gt; if allocating an object of type T if its alignment requirement exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;. If this overload is not provided, but allocator-unaware member form (15) is, allocator-unaware member overload is called instead.</source>
          <target state="translated">17) 정의 된 경우, 정렬 요구 사항이 &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; 를 초과하는 경우 T 유형의 오브젝트를 할당하는 경우 일반 단일 오브젝트 &lt;a href=&quot;../../language/new&quot;&gt;새 표현식에&lt;/a&gt; 의해 호출됩니다 . 이 과부하가 제공되지 않지만 할당 자 비 인식 멤버 양식 (15)이 있으면 할당 자 비 인식 멤버 오버로드가 대신 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="24115b8c96a4b4ba5b4b4a5351893f113b43a2d5" translate="yes" xml:space="preserve">
          <source>17) Returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">17) &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="2639fefc905805975f2fe1c7fc3317d12d8bc187" translate="yes" xml:space="preserve">
          <source>17)&lt;code&gt;!(lhs &amp;lt; nullptr)&lt;/code&gt;</source>
          <target state="translated">17) &lt;code&gt;!(lhs &amp;lt; nullptr)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3433669b3fc49571fc487cac041182972d9b18b5" translate="yes" xml:space="preserve">
          <source>17)&lt;code&gt;x.date() &amp;gt;= y&lt;/code&gt;</source>
          <target state="translated">17) &lt;code&gt;x.date() &amp;gt;= y&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="884c499715604418bea828ea9d9e8cf4d46ad164" translate="yes" xml:space="preserve">
          <source>17,19)&lt;code&gt;&lt;a href=&quot;month_weekday_last&quot;&gt;std::chrono::month_weekday_last&lt;/a&gt;(&lt;a href=&quot;month&quot;&gt;std::chrono::month&lt;/a&gt;(m), wdl)&lt;/code&gt;</source>
          <target state="translated">17,19) &lt;code&gt;&lt;a href=&quot;month_weekday_last&quot;&gt;std::chrono::month_weekday_last&lt;/a&gt;(&lt;a href=&quot;month&quot;&gt;std::chrono::month&lt;/a&gt;(m), wdl)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="397fb8bb08af6d4bc58f0eca614f4bd8c1ba0dcf" translate="yes" xml:space="preserve">
          <source>17.4.1.3 Freestanding implementations (p: 326)</source>
          <target state="translated">17.4.1.3 독립 실행 형 구현 (p : 326)</target>
        </trans-unit>
        <trans-unit id="cdfbe791dd2e6e150aa7eb3c2ddda2d4d75f3116" translate="yes" xml:space="preserve">
          <source>17.6.1.3 Freestanding implementations (p: 408)</source>
          <target state="translated">17.6.1.3 독립 실행 형 구현 (p : 408)</target>
        </trans-unit>
        <trans-unit id="4609179a6105e1e7ec0852caf9de2b2b34a71bae" translate="yes" xml:space="preserve">
          <source>17.6.1.3 Freestanding implementations (p: 441)</source>
          <target state="translated">17.6.1.3 독립 실행 형 구현 (p : 441)</target>
        </trans-unit>
        <trans-unit id="5a8cbe4e9d7a2edd1aec0f287598ccb353898502" translate="yes" xml:space="preserve">
          <source>18) &lt;code&gt;!(nullptr &amp;lt; y)&lt;/code&gt;.</source>
          <target state="translated">18) &lt;code&gt;!(nullptr &amp;lt; y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aea7b81c13a2ae2b7ec40e824f773d2ed556621f" translate="yes" xml:space="preserve">
          <source>18) If defined, called by the usual array &lt;a href=&quot;../../language/delete&quot;&gt;delete[]-expressions&lt;/a&gt; if deallocating an array of objects of type T.</source>
          <target state="translated">18) 정의 된 경우, 일반적인 배열 &lt;a href=&quot;../../language/delete&quot;&gt;delete []-식&lt;/a&gt; T 유형의 객체 배열을 할당 해제하는 경우 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="3e15378d1d6a0a56efbda9f2e22243605b00c332" translate="yes" xml:space="preserve">
          <source>18) If defined, called by the usual array &lt;a href=&quot;../../language/new&quot;&gt;new[]-expressions&lt;/a&gt; if allocating an array of objects of type T if its alignment requirement exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;. If this overload is not provided, but allocator-unaware member form (16) is, allocator-unaware member overload is called instead.</source>
          <target state="translated">18) 정의 된 경우 정렬 요구 사항이 &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; 를 초과하는 경우 T 유형의 오브젝트 배열을 할당하는 경우 일반 배열 &lt;a href=&quot;../../language/new&quot;&gt;new [] &lt;/a&gt;-expressions에 의해 호출 됩니다. 이 과부하가 제공되지 않지만 할당 자 비 인식 멤버 형식 (16)이 있으면 할당 자 비 인식 멤버 오버로드가 대신 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3a9c505de87779904e45c63e2b37874c7d191301" translate="yes" xml:space="preserve">
          <source>18) Returns &lt;code&gt;!opt&lt;/code&gt;.</source>
          <target state="translated">18) &lt;code&gt;!opt&lt;/code&gt; 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="3582c759f37c22e9144af694531d3d3157422cce" translate="yes" xml:space="preserve">
          <source>18)&lt;code&gt;!(nullptr &amp;lt; rhs)&lt;/code&gt;</source>
          <target state="translated">18) &lt;code&gt;!(nullptr &amp;lt; rhs)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cbc469d6efea81841e48c3a40e41b44dfb732db5" translate="yes" xml:space="preserve">
          <source>18)&lt;code&gt;x &amp;gt;= y.date()&lt;/code&gt;</source>
          <target state="translated">18) &lt;code&gt;x &amp;gt;= y.date()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="95f753c5bd2585350a4184a16ea0f0ca9f7f1cbe" translate="yes" xml:space="preserve">
          <source>18.6 Dynamic memory management [support.dynamic]</source>
          <target state="translated">18.6 동적 메모리 관리 [support.dynamic]</target>
        </trans-unit>
        <trans-unit id="f1b9a0e0e376edb619ccd7e96dfa0d875cda5d27" translate="yes" xml:space="preserve">
          <source>19) If defined, called by the custom single-object &lt;a href=&quot;../../language/new&quot;&gt;placement new&lt;/a&gt; expression with the matching signature if allocating an object of type T.</source>
          <target state="translated">19) 정의 된 경우, 유형 T의 오브젝트를 할당하는 경우 일치하는 서명을 가진 사용자 정의 단일 오브젝트 &lt;a href=&quot;../../language/new&quot;&gt;배치 새&lt;/a&gt; 표현식에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="bb8fa00af8dbc6e4c5ebf542def3211205bb4d25" translate="yes" xml:space="preserve">
          <source>19) Returns &lt;code&gt;bool(opt) ? *opt == value : false&lt;/code&gt;.</source>
          <target state="translated">19) &lt;code&gt;bool(opt) ? *opt == value : false&lt;/code&gt; 리턴합니다 . * opt == value : false .</target>
        </trans-unit>
        <trans-unit id="2a1546c394ceadae1153ec8b84aefd548d454b70" translate="yes" xml:space="preserve">
          <source>19,20) If defined, called in preference to (17,18) if the alignment requirement exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;.</source>
          <target state="translated">19,20) 정의 된 경우 정렬 요구 사항이 &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; 를 초과하면 (17,18)보다 우선적으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="b51fdb75ba40de3db48af998ff0b74f434875654" translate="yes" xml:space="preserve">
          <source>19-30) Compares &lt;code&gt;opt&lt;/code&gt; with a &lt;code&gt;value&lt;/code&gt;. The values are compared (using the corresponding operator of &lt;code&gt;T&lt;/code&gt;) only if &lt;code&gt;opt&lt;/code&gt; contains a value. Otherwise, &lt;code&gt;opt&lt;/code&gt; is considered</source>
          <target state="translated">19-30) &lt;code&gt;opt&lt;/code&gt; 와 &lt;code&gt;value&lt;/code&gt; 비교 합니다 . &lt;code&gt;opt&lt;/code&gt; 에 값이 포함 된 경우에만 값을 비교합니다 ( &lt;code&gt;T&lt;/code&gt; 의 해당 연산자 사용 ) . 그렇지 않으면 &lt;code&gt;opt&lt;/code&gt; 가 고려됩니다</target>
        </trans-unit>
        <trans-unit id="af127ac160e053b1ca2d2d72cf852c6e20c4222a" translate="yes" xml:space="preserve">
          <source>19-30) Compares a &lt;code&gt;sub_match&lt;/code&gt; with a null-terminated string. Implemented as if by &lt;code&gt;sm.compare(s)&lt;/code&gt;, where &lt;code&gt;sm&lt;/code&gt; is the &lt;code&gt;sub_match&lt;/code&gt; and &lt;code&gt;s&lt;/code&gt; is the pointer to a null-terminated character string.</source>
          <target state="translated">19-30) &lt;code&gt;sub_match&lt;/code&gt; 를 null로 끝나는 문자열과 비교 합니다. &lt;code&gt;sm.compare(s)&lt;/code&gt; 의해 구현되며 , 여기서 &lt;code&gt;sm&lt;/code&gt; 은 &lt;code&gt;sub_match&lt;/code&gt; 이고 &lt;code&gt;s&lt;/code&gt; 는 null로 끝나는 문자열에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="da4b9237bacccdf19c0760cab7aec4a8359010b0" translate="yes" xml:space="preserve">
          <source>2</source>
          <target state="translated">2</target>
        </trans-unit>
        <trans-unit id="f50fb27c336c16e34995bf9a3ec0ee9e9b6df453" translate="yes" xml:space="preserve">
          <source>2 ... cv2</source>
          <target state="translated">2 ... cv2</target>
        </trans-unit>
        <trans-unit id="3291da4f8d1800d38f9930d32e8663c9767fe13a" translate="yes" xml:space="preserve">
          <source>2 R &amp;rceil;) and.</source>
          <target state="translated">2 R &amp;rceil;) 및.</target>
        </trans-unit>
        <trans-unit id="1cc574bcb3d3bb44056960237f112400a49ad5f8" translate="yes" xml:space="preserve">
          <source>2&amp;times;N&amp;times;log(N)</source>
          <target state="translated">2&amp;times;N&amp;times;log(N)</target>
        </trans-unit>
        <trans-unit id="41f83f297c8b1955240b067fc7af38da47a8b281" translate="yes" xml:space="preserve">
          <source>2&amp;times;log(N)</source>
          <target state="translated">2&amp;times;log(N)</target>
        </trans-unit>
        <trans-unit id="22db22f450e69ca5b0810cc1a70e1fc7de838404" translate="yes" xml:space="preserve">
          <source>2(arg) or lb(arg)) is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0111fff1a0688bf6cc5a7913a595fed7464a7492" translate="yes" xml:space="preserve">
          <source>2(last - first) + O(1) comparisons). However, for non-&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterators&lt;/a&gt;, number of iterator increments is linear.</source>
          <target state="translated">2 (마지막-첫 번째) + O (1) 비교). 그러나 &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterators&lt;/a&gt; 가 아닌 경우 반복자 증분 수는 선형입니다.</target>
        </trans-unit>
        <trans-unit id="9a66daffae40e851d21b033f193b3b203530617c" translate="yes" xml:space="preserve">
          <source>2(last - first) + O(1) comparisons). However, for non-&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterators&lt;/a&gt;, the number of iterator increments is linear.</source>
          <target state="translated">2 (마지막-첫 번째) + O (1) 비교). 그러나 &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterators&lt;/a&gt; 가 아닌 경우 반복자 증분 수는 선형입니다.</target>
        </trans-unit>
        <trans-unit id="6c1d5888534d8c8a045ccd088ace2ea6d04f1a0e" translate="yes" xml:space="preserve">
          <source>2(max()+1) (which is equal to &lt;code&gt;&lt;a href=&quot;../../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;unsigned int&amp;gt;::digits&lt;/code&gt;). If the device has n states whose individual probabilities are P</source>
          <target state="translated">2 (max () + 1) ( &lt;code&gt;&lt;a href=&quot;../../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;unsigned int&amp;gt;::digits&lt;/code&gt; ). 기기에 개별 확률이 P 인 n 개의 상태가있는 경우</target>
        </trans-unit>
        <trans-unit id="5be4bcc0d631103a07f52b7f8f710ace6592ba4e" translate="yes" xml:space="preserve">
          <source>2(x)). If &lt;code&gt;x&lt;/code&gt; is zero, returns zero.</source>
          <target state="translated">2 (x)). 경우 &lt;code&gt;x&lt;/code&gt; 는 제로, 반환 제로.</target>
        </trans-unit>
        <trans-unit id="9da8b241aa3a3b2a51af0b83c0f44de5cf33b908" translate="yes" xml:space="preserve">
          <source>2) (deprecated in C++17)&lt;code&gt;result_type&lt;/code&gt; is exactly &lt;code&gt;R&lt;/code&gt;.</source>
          <target state="translated">2) (C ++ 17에서 더 이상 사용되지 않음) &lt;code&gt;result_type&lt;/code&gt; 은 정확히 &lt;code&gt;R&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0d0ea8bb3ac18a7c8b25a1fa2a16c55769d3109c" translate="yes" xml:space="preserve">
          <source>2) (none)</source>
          <target state="translated">2) (없음)</target>
        </trans-unit>
        <trans-unit id="3ea9bf3a65732f5f8d46eb43f1e10300449f2261" translate="yes" xml:space="preserve">
          <source>2) (none).</source>
          <target state="translated">2) (없음).</target>
        </trans-unit>
        <trans-unit id="4fed4dcb8417c9263858e805b0be5603ded2ccb7" translate="yes" xml:space="preserve">
          <source>2) (only allowed in non-&lt;a href=&quot;class#Local_classes&quot;&gt;local&lt;/a&gt; class definitions) Defines a non-member function, and makes it a friend of this class at the same time. Such non-member function is always &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt;.</source>
          <target state="translated">2) ( &lt;a href=&quot;class#Local_classes&quot;&gt;로컬&lt;/a&gt; 클래스 정의 가 아닌 경우에만 허용) 비 멤버 함수를 정의하고 동시에이 클래스의 친구로 만듭니다. 이러한 비 멤버 함수는 항상 &lt;a href=&quot;inline&quot;&gt;인라인&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2ab46850760630705e83f6d962e82236b35ba31b" translate="yes" xml:space="preserve">
          <source>2) &lt;code&gt;!(lhs == rhs)&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;!(lhs == rhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53bd2377b903cd69e8cfaa6e73b091aed02d2d87" translate="yes" xml:space="preserve">
          <source>2) &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; is not &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">2) &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; 는 &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; 이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="75f2fc030e973cb11213cee9eeee5d66bf4e4c3d" translate="yes" xml:space="preserve">
          <source>2) &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="07f719efe4fa3a53f8fa926e6cb1088022032a5f" translate="yes" xml:space="preserve">
          <source>2) &lt;code&gt;U&amp;amp;&lt;/code&gt; if &lt;code&gt;std::decay_t&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt;; &lt;code&gt;std::decay_t&amp;lt;T&amp;gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">2) &lt;code&gt;std::decay_t&amp;lt;T&amp;gt;&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt; &amp;lt;U&amp;gt; 인 경우 &lt;code&gt;U&amp;amp;&lt;/code&gt; ; 그렇지 않으면 &lt;code&gt;std::decay_t&amp;lt;T&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b026b51ac857da994ad46395587d0da356522e10" translate="yes" xml:space="preserve">
          <source>2) &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;other&lt;/code&gt; is a copy of &lt;code&gt;*this&lt;/code&gt; or has an identical name, &lt;code&gt;true&lt;/code&gt; otherwise.</source>
          <target state="translated">2) &lt;code&gt;other&lt;/code&gt; 가 &lt;code&gt;*this&lt;/code&gt; 의 사본 이거나 동일한 이름을 가진 경우 &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;true&lt;/code&gt; 않으면 true</target>
        </trans-unit>
        <trans-unit id="7289b6dff086d047ce51a90bdda1176d7184c27a" translate="yes" xml:space="preserve">
          <source>2) &lt;code&gt;is&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;is&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="625d5c136ba5aa58ff271efe7f3b6f215d5bb4f8" translate="yes" xml:space="preserve">
          <source>2) &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;!(*this == rhs)&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;!(*this == rhs)&lt;/code&gt; ) &lt;code&gt;true&lt;/code&gt; 이고 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3cd13a0e7659eb51689526007c96ef55a41f8434" translate="yes" xml:space="preserve">
          <source>2) &lt;code&gt;true&lt;/code&gt; if the distribution objects are not equal, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">2) &lt;code&gt;true&lt;/code&gt; 분배 개체가 같지 않으면 &lt;code&gt;false&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="7f1246f4bf5716cf53aee139e05d5f80d5975a07" translate="yes" xml:space="preserve">
          <source>2) &lt;code&gt;true&lt;/code&gt; if the underlying &lt;code&gt;&lt;a href=&quot;../type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; objects refer not to the same type, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">2) &lt;code&gt;true&lt;/code&gt; 의 경우 기본 &lt;code&gt;&lt;a href=&quot;../type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; 객체가 같은 종류로하지 참조 &lt;code&gt;false&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="0f4b7d0b435c412a80d3ad4bc44a24850fc6c26b" translate="yes" xml:space="preserve">
          <source>2) &lt;code&gt;x.get() != y.get()&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;x.get() != y.get()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="749e5cc0cdf54d9446ce3a37fac8410f4a5410cc" translate="yes" xml:space="preserve">
          <source>2) A</source>
          <target state="translated">2) A</target>
        </trans-unit>
        <trans-unit id="54d28528f220984bdce5bc00c307edb6e246425c" translate="yes" xml:space="preserve">
          <source>2) A &lt;code&gt;auto_ptr&lt;/code&gt; with a pointer obtained by calling &lt;code&gt;&lt;a href=&quot;release&quot;&gt;release()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;auto_ptr&lt;/code&gt; 은 포인터가 호출함으로써 얻어진 &lt;code&gt;&lt;a href=&quot;release&quot;&gt;release()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2607505aad0e717da2e41c0ab773884a0c88a540" translate="yes" xml:space="preserve">
          <source>2) A &lt;code&gt;file_time&lt;/code&gt; representing the same point in time as the argument.</source>
          <target state="translated">2) 인수와 같은 시점을 나타내는 &lt;code&gt;file_time&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4dbdcff88072d5dd2a29a1f255bb02b84dff5d3d" translate="yes" xml:space="preserve">
          <source>2) A &lt;code&gt;proxy&lt;/code&gt; object holding the current character obtained via &lt;code&gt;operator*()&lt;/code&gt; and the &lt;code&gt;sbuf_&lt;/code&gt; pointer. Dereferencing a &lt;code&gt;proxy&lt;/code&gt; object with &lt;code&gt;operator*&lt;/code&gt; yields the stored character.</source>
          <target state="translated">2) &lt;code&gt;operator*()&lt;/code&gt; 및 &lt;code&gt;sbuf_&lt;/code&gt; 포인터 를 통해 얻은 현재 문자를 보유 하는 &lt;code&gt;proxy&lt;/code&gt; 객체 . &lt;code&gt;operator*&lt;/code&gt; 하여 &lt;code&gt;proxy&lt;/code&gt; 객체를 역 참조 하면 저장된 문자가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a72cdd9b877c814e5cd61b10bb615c6f424e790a" translate="yes" xml:space="preserve">
          <source>2) A &lt;code&gt;std::chrono::local_info&lt;/code&gt; structure containing information about the local time &lt;code&gt;tp&lt;/code&gt; in this time zone.</source>
          <target state="translated">2) 이 시간대 의 현지 시간 &lt;code&gt;tp&lt;/code&gt; 에 대한 정보를 포함 하는 &lt;code&gt;std::chrono::local_info&lt;/code&gt; 구조 .</target>
        </trans-unit>
        <trans-unit id="592f9ade1e3fa08d74c0a0a0f70b41bb3c4edf48" translate="yes" xml:space="preserve">
          <source>2) A call to &lt;code&gt;reserve&lt;/code&gt; with no argument is a non-binding shrink-to-fit request. After this call, &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; has an unspecified value greater than or equal to &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">2) 인수없이 &lt;code&gt;reserve&lt;/code&gt; 하라는 요청은 구속력이없는 수축 요청입니다. 이 호출 후, &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; 이상의 지정되지 않은 값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="130afc3a1c9ff1f743b054be0b491d8de9cb666e" translate="yes" xml:space="preserve">
          <source>2) A declarator that uses a &lt;a href=&quot;name#Qualified_identifiers&quot;&gt;qualified identifier&lt;/a&gt; (qualified-id) defines or redeclares a previously declared &lt;a href=&quot;namespace#Namespaces&quot;&gt;namespace member&lt;/a&gt; or &lt;a href=&quot;classes&quot;&gt;class member&lt;/a&gt;.</source>
          <target state="translated">2) &lt;a href=&quot;name#Qualified_identifiers&quot;&gt;규정 된 식별자&lt;/a&gt; (qualified-id) 를 사용하는 선언자는 이전에 선언 된 &lt;a href=&quot;namespace#Namespaces&quot;&gt;네임 스페이스 멤버&lt;/a&gt; 또는 &lt;a href=&quot;classes&quot;&gt;클래스 멤버를&lt;/a&gt; 정의하거나 다시 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="01c0b2f75a5b5cbc7897ae6192ab1ce06080b723" translate="yes" xml:space="preserve">
          <source>2) A is</source>
          <target state="translated">2) A는</target>
        </trans-unit>
        <trans-unit id="65d4ec18b86e266594952801bfa0b012c21530ee" translate="yes" xml:space="preserve">
          <source>2) A is dependency-ordered before X and X carries a dependency into B.</source>
          <target state="translated">2) A는 X와 X가 B로 종속성을 전달하기 전에 종속성 순서입니다.</target>
        </trans-unit>
        <trans-unit id="44f4fee8e5fa352ef4f9ea9ce03291e2bbecf9bb" translate="yes" xml:space="preserve">
          <source>2) A non-type template parameter with an optional name and a default value.</source>
          <target state="translated">2) 선택적 이름과 기본값을 가진 유형이 아닌 템플릿 매개 변수.</target>
        </trans-unit>
        <trans-unit id="bc2a7c02b9f11b89f5f61ba5ac9e4b57634f8aed" translate="yes" xml:space="preserve">
          <source>2) A partial specialization for array types that uses &lt;code&gt;delete[]&lt;/code&gt; is also provided.</source>
          <target state="translated">2) &lt;code&gt;delete[]&lt;/code&gt; 를 사용하는 배열 유형에 대한 부분 전문화 도 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a51300e0c6d6ccb6a440b03e04d10783f22e4e2f" translate="yes" xml:space="preserve">
          <source>2) A pointer can be converted to any integral type large enough to hold all values of its type (e.g. to &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uintptr_t&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">2) 포인터는 그 타입의 모든 값을 담을 수있을 정도로 큰 일체형으로 변환 될 수 있습니다 (예 : &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uintptr_t&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="7b7fc8c8463c7f1a33eb44d72e625d105bc001bb" translate="yes" xml:space="preserve">
          <source>2) A set of overloads or a function template accepting an argument of any &lt;a href=&quot;../../types/is_integral&quot;&gt;integral type&lt;/a&gt;. Equivalent to (1) after casting the argument to &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">2) 과부하 &lt;a href=&quot;../../types/is_integral&quot;&gt;유형&lt;/a&gt; 또는 일체형 의 인수를 허용하는 함수 템플릿 . 인수를 &lt;code&gt;double&lt;/code&gt; 로 캐스트 한 후 (1)과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="8a6b647a2e78aad27899e0ebfe567634a9806a1a" translate="yes" xml:space="preserve">
          <source>2) A set of overloads or a function template for all combinations of arguments of arithmetic type not covered by (1). If any argument has &lt;a href=&quot;../../types/is_integral&quot;&gt;integral type&lt;/a&gt;, it is cast to &lt;code&gt;double&lt;/code&gt;. If any argument is &lt;code&gt;long double&lt;/code&gt;, then the return type &lt;code&gt;Promoted&lt;/code&gt; is also &lt;code&gt;long double&lt;/code&gt;, otherwise the return type is always &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">2) (1)에 포함되지 않은 모든 산술 유형의 인수 조합에 대한 과부하 세트 또는 함수 템플릿. 인수에 &lt;a href=&quot;../../types/is_integral&quot;&gt;정수 유형&lt;/a&gt; 이 있으면 &lt;code&gt;double&lt;/code&gt; 로 캐스트됩니다 . 인수가 &lt;code&gt;long double&lt;/code&gt; 인 경우 &lt;code&gt;Promoted&lt;/code&gt; 유형 인 리턴 유형 도 &lt;code&gt;long double&lt;/code&gt; 이며, 그렇지 않으면 반환 유형이 항상 &lt;code&gt;double&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f54492e857eda3053a0fb14248ab3c2dbcc8e074" translate="yes" xml:space="preserve">
          <source>2) A span constructed with &lt;code&gt;{reinterpret_cast&amp;lt;&lt;a href=&quot;../../types/byte&quot;&gt;std::byte&lt;/a&gt;*&amp;gt;(s.data()), s.size_bytes()}&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;{reinterpret_cast&amp;lt;&lt;a href=&quot;../../types/byte&quot;&gt;std::byte&lt;/a&gt;*&amp;gt;(s.data()), s.size_bytes()}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c06e7e86c3cb2d7c0301337b236a90b32dab86ed" translate="yes" xml:space="preserve">
          <source>2) A specialization is provided for pointer types, &lt;code&gt;T*&lt;/code&gt;, which declares the following types.</source>
          <target state="translated">2) 포인터 유형 &lt;code&gt;T*&lt;/code&gt; 대한 전문화가 제공되며 다음 유형을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="95dec0360eb8762bae39ec8afd455bb7a95216d6" translate="yes" xml:space="preserve">
          <source>2) A template template parameter with an optional name and a default.</source>
          <target state="translated">2) 선택적 이름과 기본값을 가진 템플리트 템플리트 매개 변수.</target>
        </trans-unit>
        <trans-unit id="ceb4908b8d39ba539fe957ac38035cd2a20d39de" translate="yes" xml:space="preserve">
          <source>2) A type template parameter pack with an optional name</source>
          <target state="translated">2) 선택적인 이름을 가진 타입 템플릿 파라미터 팩</target>
        </trans-unit>
        <trans-unit id="e557c1918a122bf3f911adc743435e0fcc832174" translate="yes" xml:space="preserve">
          <source>2) A type template parameter with a default.</source>
          <target state="translated">2) 기본값이있는 유형 템플리트 매개 변수.</target>
        </trans-unit>
        <trans-unit id="203e84074ea9b00dabdeced5b753bbe26e2f9a82" translate="yes" xml:space="preserve">
          <source>2) A user-defined conversion sequence is always</source>
          <target state="translated">2) 사용자 정의 변환 순서는 항상</target>
        </trans-unit>
        <trans-unit id="edb8dbc11263adc0386684b7ffa1805fe6370191" translate="yes" xml:space="preserve">
          <source>2) A writes to a scalar object M, B reads from M</source>
          <target state="translated">2) A는 스칼라 객체 M에 쓰고 B는 M에서 읽는다</target>
        </trans-unit>
        <trans-unit id="5d172bb7dc71ccfedaa067a22ba178d297e2afa7" translate="yes" xml:space="preserve">
          <source>2) Acquires ownership of the mutex &lt;code&gt;m&lt;/code&gt; without attempting to lock it. The behavior is undefined if the current thread does not own &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">2) mutex &lt;code&gt;m&lt;/code&gt; 을 잠그지 않고 소유권을 얻 습니다. 현재 스레드가 &lt;code&gt;m&lt;/code&gt; 을 소유하지 않으면 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f80724407af17885c83539d2caf469438caf4b80" translate="yes" xml:space="preserve">
          <source>2) Acquires ownership of the mutexes &lt;code&gt;m...&lt;/code&gt; without attempting to lock any of them. The behavior is undefined unless the current thread owns all of the mutexes in &lt;code&gt;m...&lt;/code&gt;.</source>
          <target state="translated">2) 뮤텍스 &lt;code&gt;m...&lt;/code&gt; 소유권 을 확보합니다. 현재 스레드가 &lt;code&gt;m...&lt;/code&gt; 모든 뮤텍스를 소유하지 않으면 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0005ec0b11fb93be1445e24915853b154c492613" translate="yes" xml:space="preserve">
          <source>2) Additional overloads are provided for &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;long double&lt;/code&gt;, and all integer types, which are treated as complex numbers with zero imaginary component.</source>
          <target state="translated">2) &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;long double&lt;/code&gt; 및 모든 정수 유형에 대해 추가 과부하가 제공되며 이는 가상 성분이 0 인 복소수로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="72a72b60d8ab2a6bbc7a1d862f3efec24554af5e" translate="yes" xml:space="preserve">
          <source>2) Additionally passes memory locality hint &lt;code&gt;hint&lt;/code&gt;. Calls &lt;code&gt;a.allocate(n, hint)&lt;/code&gt; if possible. If not possible (e.g. a has no two-argument member function allocate()), calls &lt;code&gt;a.allocate(n)&lt;/code&gt;</source>
          <target state="translated">2) 또한 메모리 위치 힌트 &lt;code&gt;hint&lt;/code&gt; 전달합니다 . 가능한 경우 &lt;code&gt;a.allocate(n, hint)&lt;/code&gt; 호출 합니다. 가능하지 않은 경우 (예를 들어 a에는 2 개의 인수 멤버 함수 &lt;code&gt;a.allocate(n)&lt;/code&gt; 호출합니다.</target>
        </trans-unit>
        <trans-unit id="b82848bbcd69b1141f7757fb78a5b4068b660966" translate="yes" xml:space="preserve">
          <source>2) Additionally provides memory locality hint, by calling &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;OuterAlloc&amp;gt;::allocate(outer_allocator(), n, hint)&lt;/code&gt;</source>
          <target state="translated">2) 또한 &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;OuterAlloc&amp;gt;::allocate(outer_allocator(), n, hint)&lt;/code&gt; &amp;lt;OuterAlloc&amp;gt; :: allocate (outer_allocator (), n, hint) 를 호출하여 메모리 위치 힌트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7f44984da5db1fd60cd2103f4527f0231f2ca221" translate="yes" xml:space="preserve">
          <source>2) Allows</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e967620d4f360a038899d82c3b59b2facb77f93e" translate="yes" xml:space="preserve">
          <source>2) Also changes the current preprocessor file name to filename. Expansions of the macro &lt;code&gt;__FILE__&lt;/code&gt; from this point will produce filename.</source>
          <target state="translated">2) 또한 현재 전 처리기 파일 이름을 filename으로 변경합니다. 이 시점에서 매크로 &lt;code&gt;__FILE__&lt;/code&gt; 을 확장 하면 파일 이름이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ef264534353d6848002c63d6bfdf5b8d637b384e" translate="yes" xml:space="preserve">
          <source>2) An &lt;code&gt;istream_iterator&lt;/code&gt; that holds an unchanged value.</source>
          <target state="translated">2) 변경되지 않은 값을 보유 하는 &lt;code&gt;istream_iterator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a2e2332086ba0e146ba89fe677a918872d6e1a9" translate="yes" xml:space="preserve">
          <source>2) An alias template is a template which, when specialized, is equivalent to the result of substituting the template arguments of the alias template for the template parameters in the type-id</source>
          <target state="translated">2) 별명 템플리트는 특수화 될 때 type-id의 템플리트 매개 변수에 대한 별명 템플리트의 템플리트 인수를 대체 한 결과와 동등한 템플리트입니다.</target>
        </trans-unit>
        <trans-unit id="c1bd8d78a1a9ed7e067b3d014febf8ee127c05c8" translate="yes" xml:space="preserve">
          <source>2) An object of unspecified type, such that given an istreambuf iterator &lt;code&gt;i&lt;/code&gt;, the expressions &lt;code&gt;(*i).m&lt;/code&gt; and &lt;code&gt;i-&amp;gt;m&lt;/code&gt; have the same effect.</source>
          <target state="translated">2) 지정되지 않은 유형의 객체, &lt;code&gt;i&lt;/code&gt; istreambuf iterator i 가 주어지면 식 &lt;code&gt;(*i).m&lt;/code&gt; 및 &lt;code&gt;i-&amp;gt;m&lt;/code&gt; 은 동일한 효과를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="cbe7a14110340a3a4edbd867338a78e37757b601" translate="yes" xml:space="preserve">
          <source>2) Analyzes a null-terminated string pointed to by &lt;code&gt;str&lt;/code&gt;. Match results are returned in &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;str&lt;/code&gt; 이 가리키는 널 종료 문자열을 분석합니다 . 일치 결과는 &lt;code&gt;m&lt;/code&gt; 으로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="54035428828277e9d68d48b1c1e91c73fcc60a59" translate="yes" xml:space="preserve">
          <source>2) Any exception thrown by the move constructor of &lt;code&gt;value&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;value&lt;/code&gt; 의 이동 생성자가 던진 예외</target>
        </trans-unit>
        <trans-unit id="960a28da21f8b741010b69d00f989146fa6e713c" translate="yes" xml:space="preserve">
          <source>2) Any exceptions thrown by copy/move constructor of &lt;code&gt;f&lt;/code&gt; and possiblly &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if the allocation fails.</source>
          <target state="translated">2) 할당이 실패하면 &lt;code&gt;f&lt;/code&gt; 및 가능한 &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 의 복사 / 이동 생성자가 예외를 throw 합니다.</target>
        </trans-unit>
        <trans-unit id="2beed027c6d75e8140d6c555a42b65a307a0d8eb" translate="yes" xml:space="preserve">
          <source>2) Any source file character that cannot be mapped to a character in the basic source character set is replaced by its &lt;a href=&quot;escape&quot;&gt;universal character name&lt;/a&gt; (escaped with &lt;code&gt;\u&lt;/code&gt; or &lt;code&gt;\U&lt;/code&gt;) or by some implementation-defined form that is handled equivalently.</source>
          <target state="translated">2) 기본 소스 문자 세트의 문자로 맵핑 할 수없는 소스 파일 문자는 &lt;a href=&quot;escape&quot;&gt;범용 문자 이름&lt;/a&gt; ( &lt;code&gt;\u&lt;/code&gt; 또는 &lt;code&gt;\U&lt;/code&gt; 이스케이프 됨 ) 또는 동등하게 처리되는 구현 정의 형식 으로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="71a4dd1fea64203a18d438bf58ffed1d309925a4" translate="yes" xml:space="preserve">
          <source>2) Any transformations performed during phases 1 and 2 between the initial and the final double quote of any &lt;a href=&quot;string_literal&quot;&gt;raw string literal&lt;/a&gt; are reverted.</source>
          <target state="translated">2) &lt;a href=&quot;string_literal&quot;&gt;원시 문자열 리터럴&lt;/a&gt; 의 초기 큰 따옴표와 마지막 큰 따옴표 사이의 1 단계와 2 단계에서 수행 된 모든 변환 이 되돌려집니다.</target>
        </trans-unit>
        <trans-unit id="beaf7a2771c5a929a37bf17b3bd50e6ce3fd4098" translate="yes" xml:space="preserve">
          <source>2) Appends string &lt;code&gt;str&lt;/code&gt;</source>
          <target state="translated">2) 문자열 &lt;code&gt;str&lt;/code&gt; 을 추가</target>
        </trans-unit>
        <trans-unit id="3c6576b3740e943f74e64fe3afd5e204e0ffe31f" translate="yes" xml:space="preserve">
          <source>2) Applies &lt;code&gt;binary_op2&lt;/code&gt; to each pair of elements from the ranges &lt;code&gt;[first; last)&lt;/code&gt; and the range starting at &lt;code&gt;first2&lt;/code&gt; and reduces the results (possibly permuted and aggregated in unspecified manner) along with the initial value &lt;code&gt;init&lt;/code&gt; over &lt;code&gt;binary_op1&lt;/code&gt;</source>
          <target state="translated">2) 범위에서 각 요소 쌍에 &lt;code&gt;binary_op2&lt;/code&gt; 를 적용합니다 &lt;code&gt;[first; last)&lt;/code&gt; 및 시작 범위 &lt;code&gt;first2&lt;/code&gt; 초기 값과 함께 결과 (가능한 순열의 불특정하게 응집) 감소 &lt;code&gt;init&lt;/code&gt; 위에 &lt;code&gt;binary_op1&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="00ba2fd7054d063bfd15b19d999b1f3486d510e7" translate="yes" xml:space="preserve">
          <source>2) Applies the given function object &lt;code&gt;f&lt;/code&gt; to the result of dereferencing every iterator in the range &lt;code&gt;[first, first + n)&lt;/code&gt; (not necessarily in order). The algorithm is executed according to &lt;code&gt;policy&lt;/code&gt;. This overload does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; is true.</source>
          <target state="translated">2) 주어진 함수 객체 &lt;code&gt;f&lt;/code&gt; 를 &lt;code&gt;[first, first + n)&lt;/code&gt; 범위 내에서 모든 반복자를 역 참조한 결과에 적용합니다 (필수 순서는 아님). 알고리즘은 &lt;code&gt;policy&lt;/code&gt; 에 따라 실행됩니다 . &lt;code&gt;&lt;a href=&quot;is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; 가 true가 아니면이 과부하는 과부하 해결에 참여하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6793901a644428472617be44b3427dd25dca5649" translate="yes" xml:space="preserve">
          <source>2) Applies the given function object &lt;code&gt;f&lt;/code&gt; to the result of dereferencing every iterator in the range &lt;code&gt;[first, last)&lt;/code&gt; (not necessarily in order). The algorithm is executed according to &lt;code&gt;policy&lt;/code&gt;. This overload does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; is true.</source>
          <target state="translated">2) 주어진 함수 객체 &lt;code&gt;f&lt;/code&gt; 를 &lt;code&gt;[first, last)&lt;/code&gt; 범위 (필수 순서는 아님 ) 의 모든 반복자를 역 참조한 결과에 적용합니다 . 알고리즘은 &lt;code&gt;policy&lt;/code&gt; 에 따라 실행됩니다 . &lt;code&gt;&lt;a href=&quot;is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; 가 true가 아니면이 과부하는 과부하 해결에 참여하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="07ae8d1e075cedd4dda9b9df4a751952248c0934" translate="yes" xml:space="preserve">
          <source>2) Applies the language specification string-literal to a single declaration or definition.</source>
          <target state="translated">2) 언어 사양 문자열 리터럴을 단일 선언 또는 정의에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="c38a6ef06268d3bcafc9546070c51d80072209c6" translate="yes" xml:space="preserve">
          <source>2) Applies the offset &lt;code&gt;d&lt;/code&gt; to &lt;code&gt;pt&lt;/code&gt; in negative direction. Effectively, &lt;code&gt;d&lt;/code&gt; is subtracted from internally stored duration &lt;code&gt;d_&lt;/code&gt; as &lt;code&gt;d_ -= d&lt;/code&gt;.</source>
          <target state="translated">2) 오프셋 &lt;code&gt;d&lt;/code&gt; 를 음의 방향으로 &lt;code&gt;pt&lt;/code&gt; 에 적용합니다 . 효과적으로, &lt;code&gt;d&lt;/code&gt; 내부적으로 저장 기간에서 감산 &lt;code&gt;d_&lt;/code&gt; 같은 &lt;code&gt;d_ -= d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67c0348748f51575155cb250778f774fdef4b767" translate="yes" xml:space="preserve">
          <source>2) Applies to a statement to allow the compiler to optimize for the case where paths of execution including that statement are less likely than any alternative path of execution that does not include such a statement.</source>
          <target state="translated">2) 해당 명령문을 포함하는 실행 경로가 해당 명령문을 포함하지 않는 대체 실행 경로보다 적을 경우 컴파일러가 최적화하도록 명령문에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="cd08b0af3de1a8f1a7f6efbdd240334735c0ca76" translate="yes" xml:space="preserve">
          <source>2) As part of &lt;a href=&quot;value_initialization&quot;&gt;value-initialization&lt;/a&gt; sequence for non-class types and for members of value-initialized class types that have no constructors, including value initialization of elements of &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregates&lt;/a&gt; for which no initializers are provided.</source>
          <target state="translated">2) 클래스가 아닌 유형과 초기화자가 제공되지 않은 &lt;a href=&quot;aggregate_initialization&quot;&gt;집계&lt;/a&gt; 요소의 값 초기화를 포함하여 생성자가없는 값 초기화 클래스 유형의 멤버에 대한 &lt;a href=&quot;value_initialization&quot;&gt;값 초기화&lt;/a&gt; 순서의 일부로 .</target>
        </trans-unit>
        <trans-unit id="6185184b302a8438d8fb37feeb5bb15b8857bcd1" translate="yes" xml:space="preserve">
          <source>2) Assigns &lt;code&gt;other.first&lt;/code&gt; to &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;other.second&lt;/code&gt; to &lt;code&gt;second&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;other.first&lt;/code&gt; 를 &lt;code&gt;first&lt;/code&gt; 에 할당 하고 &lt;code&gt;other.second&lt;/code&gt; 를 &lt;code&gt;second&lt;/code&gt; 할당</target>
        </trans-unit>
        <trans-unit id="ce5f9c298ab65cc8499a37644e88f42d2a7b117b" translate="yes" xml:space="preserve">
          <source>2) Assigns &lt;code&gt;other&lt;/code&gt; to the stored time point. The time zone pointer is unchanged. After this call, &lt;code&gt;get_sys_time() == other&lt;/code&gt;.</source>
          <target state="translated">2) 저장된 시점에 &lt;code&gt;other&lt;/code&gt; 것을 할당 합니다. 시간대 포인터는 변경되지 않습니다. 이 호출 후 &lt;code&gt;get_sys_time() == other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f217a6d7e8f8b60b0c9f500a07b25cde09e0249" translate="yes" xml:space="preserve">
          <source>2) Assigns by moving the state of &lt;code&gt;rhs&lt;/code&gt;, as if by &lt;code&gt;any(std::move(rhs)).swap(*this)&lt;/code&gt;. &lt;code&gt;rhs&lt;/code&gt; is left in a valid but unspecified state after the assignment.</source>
          <target state="translated">2) 마치 &lt;code&gt;any(std::move(rhs)).swap(*this)&lt;/code&gt; 처럼 &lt;code&gt;rhs&lt;/code&gt; 상태를 이동하여 할당합니다 . &lt;code&gt;rhs&lt;/code&gt; 는 할당 후에 유효하지만 지정되지 않은 상태로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="df196f257ed946ec1af592bd77a3b6270ee0e437" translate="yes" xml:space="preserve">
          <source>2) Assigns character &lt;code&gt;a&lt;/code&gt; to each character in &lt;code&gt;count&lt;/code&gt; characters in the character sequence pointed to by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;p&lt;/code&gt; 가 가리키는 문자 순서 에서 문자 &lt;code&gt;a&lt;/code&gt; 를 각 문자에 &lt;code&gt;count&lt;/code&gt; 문자로 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="5fd030668bf88602534ba4169ee1b0a7ebffdab7" translate="yes" xml:space="preserve">
          <source>2) Assigns error condition for enum &lt;code&gt;e&lt;/code&gt;. Effectively calls &lt;code&gt;make_error_condition()&lt;/code&gt;. Does not participate in the overload resolution unless &lt;code&gt;is_error_condition_enum&amp;lt;ErrorConditionEnum&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">2) 열거 형 &lt;code&gt;e&lt;/code&gt; 에 대한 오류 조건을 할당합니다 . 효과적으로 &lt;code&gt;make_error_condition()&lt;/code&gt; 호출합니다 . &lt;code&gt;is_error_condition_enum&amp;lt;ErrorConditionEnum&amp;gt;::value&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 가 아니면 오버로드 해결에 참여하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d0fef0dc9967a2364a080b7655dadb9b14bec8e5" translate="yes" xml:space="preserve">
          <source>2) Assigns the contents of &lt;code&gt;other&lt;/code&gt; using move semantics. &lt;code&gt;&lt;a href=&quot;flags&quot;&gt;flags()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mark_count&quot;&gt;mark_count()&lt;/a&gt;&lt;/code&gt; are equivalent to the values of &lt;code&gt;other.flags()&lt;/code&gt; and &lt;code&gt;other.mark_count()&lt;/code&gt; before the assignment. After the call, &lt;code&gt;other&lt;/code&gt; is in a valid, but unspecified state.</source>
          <target state="translated">2) 이동 의미론을 사용하여 &lt;code&gt;other&lt;/code&gt; 내용을 할당합니다 . &lt;code&gt;&lt;a href=&quot;flags&quot;&gt;flags()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;mark_count&quot;&gt;mark_count()&lt;/a&gt;&lt;/code&gt; 는 할당 전의 &lt;code&gt;other.flags()&lt;/code&gt; 및 &lt;code&gt;other.mark_count()&lt;/code&gt; 의 값 과 같습니다 . 호출 후 &lt;code&gt;other&lt;/code&gt; 것은 유효하지만 지정되지 않은 상태입니다.</target>
        </trans-unit>
        <trans-unit id="7475a82d1f78ce66610e68ba8025ad7a71dd6584" translate="yes" xml:space="preserve">
          <source>2) Assigns the elements of &lt;code&gt;val_arr&lt;/code&gt; to the referred to elements of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;val_arr&lt;/code&gt; 의 요소를 &lt;code&gt;*this&lt;/code&gt; 의 참조 된 요소에 지정 합니다 .</target>
        </trans-unit>
        <trans-unit id="d03ef02e37b6d28ae6b0d25ec0d3a77bd755f3a2" translate="yes" xml:space="preserve">
          <source>2) Assigns the pathname identified by the detected-format character range &lt;code&gt;source&lt;/code&gt;.</source>
          <target state="translated">2) 감지 된 형식 문자 범위 &lt;code&gt;source&lt;/code&gt; 식별되는 경로 이름을 지정 합니다 .</target>
        </trans-unit>
        <trans-unit id="f6253524c2de800da824eafaeaceec495b950b45" translate="yes" xml:space="preserve">
          <source>2) At program termination, data written to files is exactly as if the program was executed as written.</source>
          <target state="translated">2) 프로그램 종료시, 파일에 기록 된 데이터는 프로그램이 기록 된대로 실행 된 것과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="462c713b165df5526147c4d608a47fff5d11bc55" translate="yes" xml:space="preserve">
          <source>2) Atomic read-modify-write operations made to M by any thread</source>
          <target state="translated">2) 모든 스레드에 의해 M에 수행되는 원자 읽기-수정-쓰기 작업</target>
        </trans-unit>
        <trans-unit id="c623c7492e55f2eb810d98f2994062fbe25b476f" translate="yes" xml:space="preserve">
          <source>2) Atomic variables are not &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">2) 원자 변수는 &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; 이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="c9a9a5c9d7f6364fb71a53df33a471856c14b778" translate="yes" xml:space="preserve">
          <source>2) Atomically obtains the value pointed to by &lt;code&gt;obj&lt;/code&gt; as if by &lt;code&gt;obj-&amp;gt;load(order)&lt;/code&gt;</source>
          <target state="translated">2)에 원자 값이 가리키는 획득 &lt;code&gt;obj&lt;/code&gt; 에서처럼 &lt;code&gt;obj-&amp;gt;load(order)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="575fc35b7bef059331bcce9a2e2c5e5756b93a67" translate="yes" xml:space="preserve">
          <source>2) Atomically replaces the value pointed to by &lt;code&gt;obj&lt;/code&gt; with the value of &lt;code&gt;desr&lt;/code&gt; and returns the value &lt;code&gt;obj&lt;/code&gt; held previously, as if by &lt;code&gt;obj-&amp;gt;exchange(desr, order)&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;obj&lt;/code&gt; 가 가리키는 값을 &lt;code&gt;desr&lt;/code&gt; 의 값으로 원자 적으로 대체하고 &lt;code&gt;obj-&amp;gt;exchange(desr, order)&lt;/code&gt; 와 같이 이전에 보유한 &lt;code&gt;obj&lt;/code&gt; 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cac6491dc93aad8b586c9e0ca36e8786b47fc547" translate="yes" xml:space="preserve">
          <source>2) Atomically replaces the value pointed to by &lt;code&gt;obj&lt;/code&gt; with the value of &lt;code&gt;desr&lt;/code&gt; as if by &lt;code&gt;obj-&amp;gt;store(desr, order)&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;obj&lt;/code&gt; 가 가리키는 값을 &lt;code&gt;obj-&amp;gt;store(desr, order)&lt;/code&gt; 처럼 원자 적으로 &lt;code&gt;desr&lt;/code&gt; 값으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="083501d5f7cc6d6983a2c593fdbddfdc67ca236c" translate="yes" xml:space="preserve">
          <source>2) Attempts to copy the full contents of the floating-point exception flags that are listed in &lt;code&gt;excepts&lt;/code&gt; from &lt;code&gt;flagp&lt;/code&gt; into the floating-point environment. Does not raise any exceptions, only modifies the flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af8634f29fe7ea14505a17094baaa88641f3836c" translate="yes" xml:space="preserve">
          <source>2) Attempts to establish the floating-point environment from the object pointed to by &lt;code&gt;envp&lt;/code&gt;. The value of that object must be previously obtained by a call to &lt;code&gt;&lt;a href=&quot;feholdexcept&quot;&gt;std::feholdexcept&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;std::fegetenv&lt;/code&gt; or be a floating-point macro constant. If any of the floating-point status flags are set in &lt;code&gt;envp&lt;/code&gt;, they become set in the environment (and are then testable with &lt;code&gt;&lt;a href=&quot;fetestexcept&quot;&gt;std::fetestexcept&lt;/a&gt;&lt;/code&gt;), but the corresponding floating-point exceptions are not raised (execution continues uninterrupted)</source>
          <target state="translated">2) &lt;code&gt;envp&lt;/code&gt; 가 가리키는 객체에서 부동 소수점 환경을 설정하려고 시도합니다 . 해당 객체의 값은 &lt;code&gt;&lt;a href=&quot;feholdexcept&quot;&gt;std::feholdexcept&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;std::fegetenv&lt;/code&gt; 호출하여 미리 가져 오거나 부동 소수점 매크로 상수 여야합니다. 부동 소수점 상태 플래그가 &lt;code&gt;envp&lt;/code&gt; 에 설정되어 있으면 환경에서 설정되고 &lt;code&gt;&lt;a href=&quot;fetestexcept&quot;&gt;std::fetestexcept&lt;/a&gt;&lt;/code&gt; 로 테스트 할 수 있지만 해당 부동 소수점 예외는 발생하지 않습니다 (실행은 중단되지 않고 계속됨)</target>
        </trans-unit>
        <trans-unit id="94805d52aae9ac4d9241e17a7636eb1ef98ac6af" translate="yes" xml:space="preserve">
          <source>2) Average case: &lt;code&gt;&lt;a href=&quot;../../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;, worst case: &lt;code&gt;c.size()&lt;/code&gt;</source>
          <target state="translated">2) 평균 사례 : &lt;code&gt;&lt;a href=&quot;../../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; , 최악의 경우 : &lt;code&gt;c.size()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a98fa7a138657cc1495aa5bf9831181d4a133a92" translate="yes" xml:space="preserve">
          <source>2) Because &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; is required to be &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;, the returned call wrapper is always &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;, and is &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; if &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; is &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;.</source>
          <target state="translated">2) 때문에 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; 로 할 필요가있다 &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; , 항상 래퍼 반환 전화 &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; 하고있다 &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible (복사 가능 생성자)&lt;/a&gt; 의 경우 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; IS &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible (복사 가능 생성자)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="087379a98f8221b4c7fc7710fd1bdd793b785d9f" translate="yes" xml:space="preserve">
          <source>2) Behaves as (1) above, omitting the match results.</source>
          <target state="translated">2) 위의 (1)과 같이 동작하며 경기 결과는 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="7270c91a5c84f99601cb989344920ef3ddcd3213" translate="yes" xml:space="preserve">
          <source>2) Behaves as a &lt;a href=&quot;../../named_req/formattedinputfunction&quot;&gt;FormattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, which may skip leading whitespace, extracts up to &lt;code&gt;N&lt;/code&gt; characters from &lt;code&gt;is&lt;/code&gt; and stores the characters in the bitset &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">2) &lt;a href=&quot;../../named_req/formattedinputfunction&quot;&gt;FormattedInputFunction으로&lt;/a&gt; 동작합니다 . 앞 공백을 건너 뛸 수있는 센트리 객체를 구성하고 확인한 후 &lt;code&gt;is&lt;/code&gt; 에서 최대 &lt;code&gt;N&lt;/code&gt; 개의 문자를 추출 하여 비트 세트 &lt;code&gt;x&lt;/code&gt; 에 문자를 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="a431f9a97205e2d76bbefd116eb5b6a96b409298" translate="yes" xml:space="preserve">
          <source>2) Behaves as a &lt;a href=&quot;../../named_req/formattedinputfunction&quot;&gt;FormattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, which may skip leading whitespace, first clears &lt;code&gt;str&lt;/code&gt; with &lt;code&gt;str.erase()&lt;/code&gt;, then reads characters from &lt;code&gt;is&lt;/code&gt; and appends them to &lt;code&gt;str&lt;/code&gt; as if by &lt;code&gt;str.append(1, c)&lt;/code&gt;, until one of the following conditions becomes true:</source>
          <target state="translated">2) &lt;a href=&quot;../../named_req/formattedinputfunction&quot;&gt;FormattedInputFunction으로&lt;/a&gt; 동작합니다 . 구성 선도 공백을 건너 뛸 수있다 센트리 객체를 확인한 후, 제 지우고는 &lt;code&gt;str&lt;/code&gt; 에 함께 &lt;code&gt;str.erase()&lt;/code&gt; 다음 문자를 판독 &lt;code&gt;is&lt;/code&gt; 하고이를 추가 &lt;code&gt;str&lt;/code&gt; 에 같은 경우와 &lt;code&gt;str.append(1, c)&lt;/code&gt; 중 하나까지 다음과 같은 조건이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a95af38037dd60483716285451eaa8e8451afeb2" translate="yes" xml:space="preserve">
          <source>2) Behaves as an &lt;a href=&quot;../../named_req/formattedinputfunction&quot;&gt;FormattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, which may skip leading whitespace, extracts successive characters and stores them at successive locations of a character array whose first element is pointed to by(until C++20)&lt;code&gt;s&lt;/code&gt;. The extraction stops if one of the following conditions are met:</source>
          <target state="translated">2) &lt;a href=&quot;../../named_req/formattedinputfunction&quot;&gt;FormattedInputFunction으로&lt;/a&gt; 동작합니다 . 구성 선도 공백을 건너 뛸 수 센트리 객체를 확인한 후, 제 소자 (20 ++ C까지)에 의해 지시되는 문자 배열의 연속적인 위치에서 연속적인 문자 및 그 기억을 추출 &lt;code&gt;s&lt;/code&gt; . 다음 조건 중 하나가 충족되면 추출이 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="a78564bd99e851906a3e4f8cf2c9a556006dfb82" translate="yes" xml:space="preserve">
          <source>2) Behaves as an &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;. After constructing and checking the sentry object, inserts successive characters from the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">2) &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction으로&lt;/a&gt; 작동합니다 . 센트리 객체를 구성하고 확인한 후 첫 번째 요소가 &lt;code&gt;s&lt;/code&gt; 로 가리키는 문자 배열에서 연속 문자를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="f8717c19b4ae542e5d81e104020ec9780491a192" translate="yes" xml:space="preserve">
          <source>2) Behaves as if defined as follows:</source>
          <target state="translated">2) 다음과 같이 정의 된 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="eb668dfa4884c630524ce30e5eaeccfe8b029a78" translate="yes" xml:space="preserve">
          <source>2) Behaves the same as the reset member of the primary template. 3) In the specialization for dynamic arrays, &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T[]&amp;gt;&lt;/code&gt;, this template member is provided to prevent using reset() with a pointer to derived (which would result in undefined behavior with arrays). 4) In the specialization for dynamic arrays, &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T[]&amp;gt;&lt;/code&gt;, this overload is necessary to allow reset to &lt;code&gt;nullptr&lt;/code&gt; (which would otherwise be prohibited by the template overload). Equivalent to &lt;code&gt;reset(pointer())&lt;/code&gt;</source>
          <target state="translated">2) 기본 템플릿의 재설정 멤버와 동일하게 작동합니다. 3) 동적 배열, &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T[]&amp;gt;&lt;/code&gt; 의 전문화 에서이 템플리트 멤버는 파생 된 포인터와 함께 reset () 사용을 방지하기 위해 제공됩니다 (배열에 대해 정의되지 않은 동작이 발생 함). 4) 동적 배열, &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T[]&amp;gt;&lt;/code&gt; 의 전문화 에서이 과부하는 &lt;code&gt;nullptr&lt;/code&gt; (템플릿 과부하에 의해 금지되는)로 재설정하기 위해 필요합니다 . &lt;code&gt;reset(pointer())&lt;/code&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="181d3bead4ed9db1b52288b502d91ebc841cd1d3" translate="yes" xml:space="preserve">
          <source>2) Binds the second argument of &lt;code&gt;f&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;. Effectively calls &lt;code&gt;&lt;a href=&quot;binder12&quot;&gt;std::binder2nd&lt;/a&gt;&amp;lt;F&amp;gt;(f, typename F::second_argument_type(x))&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;f&lt;/code&gt; 의 두 번째 인수 를 &lt;code&gt;x&lt;/code&gt; 에 바인딩합니다 . 효과적으로 &lt;code&gt;&lt;a href=&quot;binder12&quot;&gt;std::binder2nd&lt;/a&gt;&amp;lt;F&amp;gt;(f, typename F::second_argument_type(x))&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="cb28f84d8c76e47897e65f50b0d32a231e247e20" translate="yes" xml:space="preserve">
          <source>2) Binds the second parameter to the value &lt;code&gt;value&lt;/code&gt; given at the construction of the object.</source>
          <target state="translated">2) 값의 두 번째 파라미터 바인딩 &lt;code&gt;value&lt;/code&gt; 객체의 구성에 부여한다.</target>
        </trans-unit>
        <trans-unit id="dc5b38c01f0d2e9890fdc3240aa88a05f30b5277" translate="yes" xml:space="preserve">
          <source>2) Buffering state: unbuffered, line-buffered, fully buffered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9c18eaf0d33a2edb92bc2c640a29f898551c0ab" translate="yes" xml:space="preserve">
          <source>2) Called by &lt;a href=&quot;../../language/delete&quot;&gt;delete[]-expressions&lt;/a&gt; to deallocate storage previously allocated for an array of objects. The behavior of the standard library implementation of this function is undefined unless &lt;code&gt;ptr&lt;/code&gt; is a null pointer or is a pointer previously obtained from the standard library implementation of &lt;code&gt;&lt;a href=&quot;operator_new&quot;&gt;operator new&lt;/a&gt;[](size_t)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;operator_new&quot;&gt;operator new&lt;/a&gt;[](size_t, &lt;a href=&quot;nothrow_t&quot;&gt;std::nothrow_t&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">2) &lt;a href=&quot;../../language/delete&quot;&gt;delete []&lt;/a&gt; -expressions에 의해 호출되어 이전에 객체 배열에 할당 된 스토리지를 할당 해제합니다. 이 함수의 표준 라이브러리 구현의 동작은 &lt;code&gt;ptr&lt;/code&gt; 이 널 포인터이거나 &lt;code&gt;&lt;a href=&quot;operator_new&quot;&gt;operator new&lt;/a&gt;[](size_t)&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;operator_new&quot;&gt;operator new&lt;/a&gt;[](size_t, &lt;a href=&quot;nothrow_t&quot;&gt;std::nothrow_t&lt;/a&gt;)&lt;/code&gt; 의 표준 라이브러리 구현에서 이전에 얻은 포인터가 아니면 정의되지 않습니다. .</target>
        </trans-unit>
        <trans-unit id="79c252a605c412a539c6f6212ced4174730df746" translate="yes" xml:space="preserve">
          <source>2) Called by the array form of &lt;a href=&quot;../../language/new&quot;&gt;new[]-expressions&lt;/a&gt; to allocate all storage required for an array (including possible</source>
          <target state="translated">2) 배열에 필요한 모든 스토리지를 할당하기 위해 &lt;a href=&quot;../../language/new&quot;&gt;new []&lt;/a&gt; -expressions의 배열 형식으로 호출</target>
        </trans-unit>
        <trans-unit id="831f9df849dcedf12c2e65fec0c0ee560791e627" translate="yes" xml:space="preserve">
          <source>2) Calls &lt;code&gt;::new((void *)p) U(&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;</source>
          <target state="translated">2) 호출 &lt;code&gt;::new((void *)p) U(&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b8dbbfd7959e3463086c2882c32e111fc601ed6e" translate="yes" xml:space="preserve">
          <source>2) Calls &lt;code&gt;p-&amp;gt;~U()&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;p-&amp;gt;~U()&lt;/code&gt; 호출</target>
        </trans-unit>
        <trans-unit id="5cab87867e3b97227e8e4402217fa3cfb1abf882" translate="yes" xml:space="preserve">
          <source>2) Calls a function &lt;code&gt;f&lt;/code&gt; with arguments &lt;code&gt;args&lt;/code&gt; according to a specific launch policy &lt;code&gt;policy&lt;/code&gt;:</source>
          <target state="translated">2) 특정 시작 정책 &lt;code&gt;policy&lt;/code&gt; 에 따라 인수 &lt;code&gt;args&lt;/code&gt; 를 사용 하여 함수 &lt;code&gt;f&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="0887c9c8a8a127012629398616aa0f8aceccdacf" translate="yes" xml:space="preserve">
          <source>2) Calls the &lt;code&gt;do_put&lt;/code&gt; member function of the most derived class.</source>
          <target state="translated">2) 가장 파생 된 클래스 의 &lt;code&gt;do_put&lt;/code&gt; 멤버 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="54439828423c06cb9613f1f6d953c1e32fedf42d" translate="yes" xml:space="preserve">
          <source>2) Catch-clause that declares an unnamed parameter</source>
          <target state="translated">2) 명명되지 않은 매개 변수를 선언하는 Catch-clause</target>
        </trans-unit>
        <trans-unit id="d681a88f82adba7fd2df38d6a8d5e0ad35db6952" translate="yes" xml:space="preserve">
          <source>2) Changes the time of the last modification of &lt;code&gt;p&lt;/code&gt;, as if by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/futimens.html&quot;&gt;futimens&lt;/a&gt; (symlinks are followed)</source>
          <target state="translated">2) POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/futimens.html&quot;&gt;futimens&lt;/a&gt; 와 같이 &lt;code&gt;p&lt;/code&gt; 의 마지막 수정 시간을 변경합니다 (심볼릭 링크가 이어짐 )</target>
        </trans-unit>
        <trans-unit id="6a7b23e652f9c0857c34d01dfb03f0ee3e1ff5dd" translate="yes" xml:space="preserve">
          <source>2) Checks if &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are not equal.</source>
          <target state="translated">2) &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 가 같은지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="715287c443f48d59084ab0a3b13bbdda80a1449d" translate="yes" xml:space="preserve">
          <source>2) Checks if any bits are set to &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">2) 비트가 &lt;code&gt;true&lt;/code&gt; 로 설정되어 있는지 확인</target>
        </trans-unit>
        <trans-unit id="9031f351b76ee69d582367bbdd27b0b6a0a18e61" translate="yes" xml:space="preserve">
          <source>2) Checks if there is an element with key that compares</source>
          <target state="translated">2) 키가있는 요소가 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="c7d6512017898d1f3b6ebbacdbf187d7cc9065f9" translate="yes" xml:space="preserve">
          <source>2) Checks whether &lt;a href=&quot;root_name&quot;&gt;&lt;code&gt;root_name()&lt;/code&gt;&lt;/a&gt; is empty.</source>
          <target state="translated">2) &lt;a href=&quot;root_name&quot;&gt; &lt;code&gt;root_name()&lt;/code&gt; &lt;/a&gt; 이 비어 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="f2be628de5cdc9df7b8a5395d43404a0aada2a83" translate="yes" xml:space="preserve">
          <source>2) Checks whether &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; do not refer to the same object.</source>
          <target state="translated">2) &lt;code&gt;*this&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 가 같은 객체를 참조하지 않는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="2df1a6e1ae15c18f35a258ad7e5f5597dd835e0b" translate="yes" xml:space="preserve">
          <source>2) Checks whether &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are not equal.</source>
          <target state="translated">2) &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 가 같은지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="f004f67f7162aca10bbbf802080d161cc29f348c" translate="yes" xml:space="preserve">
          <source>2) Checks whether &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are not equal. Equivalent to &lt;code&gt;!(lhs == rhs)&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 가 같은지 확인합니다 . &lt;code&gt;!(lhs == rhs)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="8af8c91f0dd2f8be1cdb6945494f11f1431c7dd9" translate="yes" xml:space="preserve">
          <source>2) Checks whether &lt;code&gt;lhs&lt;/code&gt; is</source>
          <target state="translated">2) &lt;code&gt;lhs&lt;/code&gt; 가 있는지 확인</target>
        </trans-unit>
        <trans-unit id="35fc4e330c06143257cbf884b81fb6b11d55f4cc" translate="yes" xml:space="preserve">
          <source>2) Clears the formatting flags under &lt;code&gt;mask&lt;/code&gt;, and sets the cleared flags to those specified by &lt;code&gt;flags&lt;/code&gt;. Effectively the following operation is performed &lt;code&gt;fl = (fl &amp;amp; ~mask) | (flags &amp;amp; mask)&lt;/code&gt; where &lt;code&gt;fl&lt;/code&gt; defines the state of internal formatting flags.</source>
          <target state="translated">2) 아래 서식 플래그를 클리어 &lt;code&gt;mask&lt;/code&gt; 및 의해 지정된 행의 삭제 플래그를 설정하는 &lt;code&gt;flags&lt;/code&gt; . 효과적으로 다음 작업이 수행됩니다 &lt;code&gt;fl = (fl &amp;amp; ~mask) | (flags &amp;amp; mask)&lt;/code&gt; &lt;code&gt;fl&lt;/code&gt; 내부 포맷 플래그의 상태를 정의한다.</target>
        </trans-unit>
        <trans-unit id="20861e60a8a2d449f08f37ac06418cd26228f47a" translate="yes" xml:space="preserve">
          <source>2) Compares &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; in such a way that they are totally ordered.</source>
          <target state="translated">2) &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 를 완전히 주문한 방식으로 비교 합니다 .</target>
        </trans-unit>
        <trans-unit id="dfd194f1ae14896597b04967f346d00563b12289" translate="yes" xml:space="preserve">
          <source>2) Compares &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; for equality.</source>
          <target state="translated">2) &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 가 동일한 지 비교 합니다.</target>
        </trans-unit>
        <trans-unit id="590ba8c6efd172308808e15ed26848881337e32d" translate="yes" xml:space="preserve">
          <source>2) Compares a &lt;code&gt;[pos1, pos1+count1)&lt;/code&gt; substring of this string to</source>
          <target state="translated">2) 이 문자열 의 &lt;code&gt;[pos1, pos1+count1)&lt;/code&gt; 하위 문자열을</target>
        </trans-unit>
        <trans-unit id="a38e4ce512d07584280e2590345b152879f4a45b" translate="yes" xml:space="preserve">
          <source>2) Compares a &lt;code&gt;sub_match&lt;/code&gt; with a &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;. Equivalent to &lt;code&gt;str().compare(s)&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;sub_match&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; 과 비교합니다 . 동등 &lt;code&gt;str().compare(s)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64ce8848306053fd3fb6ccb91ea7d2fab7116276" translate="yes" xml:space="preserve">
          <source>2) Compares the character sequence &lt;code&gt;[low1, high1)&lt;/code&gt; to the character sequence &lt;code&gt;[low2, high2)&lt;/code&gt;, using this locale's collation rules, and returns 1 if the first string follows the second, -1 if the first string precedes the second, zero if the two strings are equivalent.</source>
          <target state="translated">2) 문자 시퀀스를 비교 &lt;code&gt;[low1, high1)&lt;/code&gt; 문자 시퀀스 &lt;code&gt;[low2, high2)&lt;/code&gt; 제 문자열 초 뒤에 있다면,이 장소의 조합 규칙 복귀 1을 사용하여, -1 제 문자열 선행 경우 제 제로 만약 두 문자열은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="39d2919d5d882d09b7a0ebb856ead800762a6015" translate="yes" xml:space="preserve">
          <source>2) Compares two distribution objects for inequality.</source>
          <target state="translated">2) 두 분포 개체의 불평등을 비교합니다.</target>
        </trans-unit>
        <trans-unit id="835ceba50d896c4a25b27f149726b4bbfe030ab6" translate="yes" xml:space="preserve">
          <source>2) Computes the</source>
          <target state="translated">2) 계산</target>
        </trans-unit>
        <trans-unit id="115ed006c2a2f1f3bdbbe246ea237b110e0fb53b" translate="yes" xml:space="preserve">
          <source>2) Computes the inverse tangent of &lt;code&gt;vx&lt;/code&gt; and each value in the numeric array &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;vx&lt;/code&gt; 의 역 탄젠트 와 숫자 배열 &lt;code&gt;y&lt;/code&gt; 의 각 값을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="56f07c3ea236f679e8f55ce801e6a101878fe957" translate="yes" xml:space="preserve">
          <source>2) Computes the values of each element in the numeric array &lt;code&gt;base&lt;/code&gt; raised to the power &lt;code&gt;vexp&lt;/code&gt;.</source>
          <target state="translated">2) 숫자 형 배열 &lt;code&gt;base&lt;/code&gt; 에서 각 요소의 값을 power &lt;code&gt;vexp&lt;/code&gt; 로 올립니다 .</target>
        </trans-unit>
        <trans-unit id="a6679f456e856910f933705c2b474683f2e0a5e5" translate="yes" xml:space="preserve">
          <source>2) Constant</source>
          <target state="translated">2) 상수</target>
        </trans-unit>
        <trans-unit id="2ca905bd4b88e5316b0611ac94450466ef9b451f" translate="yes" xml:space="preserve">
          <source>2) Constructs a &lt;code&gt;month_day&lt;/code&gt; that stores the month &lt;code&gt;m&lt;/code&gt; and the day &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">2) 월 &lt;code&gt;m&lt;/code&gt; 과 일 &lt;code&gt;d&lt;/code&gt; 를 저장 하는 &lt;code&gt;month_day&lt;/code&gt; 를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="eaa2f3b253ec9ea4c0e454fdfb3fe095e185a376" translate="yes" xml:space="preserve">
          <source>2) Constructs a &lt;code&gt;regex_iterator&lt;/code&gt; from the sequence of characters &lt;code&gt;[a, b)&lt;/code&gt;, the regular expression &lt;code&gt;re&lt;/code&gt;, and a flag &lt;code&gt;m&lt;/code&gt; that governs matching behavior. This constructor performs an initial call to &lt;code&gt;&lt;a href=&quot;../regex_search&quot;&gt;std::regex_search&lt;/a&gt;&lt;/code&gt; with this data. If the result of this initial call is &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;*this&lt;/code&gt; is set to an end-of-sequence iterator.</source>
          <target state="translated">2) 문자 시퀀스 &lt;code&gt;[a, b)&lt;/code&gt; , 정규 표현식 &lt;code&gt;re&lt;/code&gt; 및 일치 동작을 제어하는 플래그 &lt;code&gt;m&lt;/code&gt; 을 사용 하여 &lt;code&gt;regex_iterator&lt;/code&gt; 를 구성합니다 . 이 생성자 는이 데이터를 사용 하여 &lt;code&gt;&lt;a href=&quot;../regex_search&quot;&gt;std::regex_search&lt;/a&gt;&lt;/code&gt; 대한 초기 호출을 수행합니다 . 이 초기 호출의 결과가 &lt;code&gt;false&lt;/code&gt; 인 경우 &lt;code&gt;*this&lt;/code&gt; 시퀀스 종료 반복기로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f7c03d4dae3238ce4347d6655dccf95cedb35969" translate="yes" xml:space="preserve">
          <source>2) Constructs a &lt;code&gt;std::basic_stringbuf&lt;/code&gt; object: initializes the base class by calling the default constructor of &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt;, initializes the character sequence with an empty string, and sets the mode to &lt;code&gt;which&lt;/code&gt;.</source>
          <target state="translated">2) 구축 &lt;code&gt;std::basic_stringbuf&lt;/code&gt; 객체를 :의 기본 생성자를 호출하여 기본 클래스를 초기화 &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; 빈 문자열로 문자 시퀀스를 초기화하고, 모드로 설정합니다 . &lt;code&gt;which&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="427be259a472b7aca27b70208cdd446acdf04456" translate="yes" xml:space="preserve">
          <source>2) Constructs a &lt;code&gt;std::default_delete&lt;/code&gt; object from another &lt;code&gt;std::default_delete&lt;/code&gt; object. This constructor will only participate in overload resolution if &lt;code&gt;U*&lt;/code&gt; is implicitly convertible to &lt;code&gt;T*&lt;/code&gt;.</source>
          <target state="translated">2) 구축 &lt;code&gt;std::default_delete&lt;/code&gt; 서로 객체 &lt;code&gt;std::default_delete&lt;/code&gt; 개체를. 이 생성자는 &lt;code&gt;U*&lt;/code&gt; 가 암시 적으로 &lt;code&gt;T*&lt;/code&gt; 로 변환 가능한 경우에만 과부하 해결에 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="e16e16e93b9d19ec3f2a9ce9ef3b4271768c3d4c" translate="yes" xml:space="preserve">
          <source>2) Constructs a &lt;code&gt;std::packaged_task&lt;/code&gt; object with a shared state and a copy of the task, initialized with &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt;. This constructor does not participate in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;F&amp;gt;::type&lt;/code&gt; is the same type as &lt;code&gt;&lt;a href=&quot;../packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&amp;lt;R(ArgTypes...)&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">2) 공유 상태와 작업의 복사본을 가진 &lt;code&gt;std::packaged_task&lt;/code&gt; 객체를 구성하고 &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt; 초기화 합니다. &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;F&amp;gt;::type&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;../packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&amp;lt;R(ArgTypes...)&amp;gt;&lt;/code&gt; 와 동일한 유형 인 경우이 생성자는 과부하 해결에 참여하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f400cae2f0c20e20053faba06a2ddbd2ed771d55" translate="yes" xml:space="preserve">
          <source>2) Constructs a &lt;code&gt;std::strstreambuf&lt;/code&gt; object: initializes the base class by calling the default constructor of &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt;, initializes the buffer state to &quot;dynamic&quot; (the buffer will be allocated as needed), initializes allocated size to unspecified value, initializes the allocation function to &lt;code&gt;palloc&lt;/code&gt; and the deallocation function to &lt;code&gt;pfree&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;std::strstreambuf&lt;/code&gt; 객체 생성 : &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; 의 기본 생성자를 호출하여 기본 클래스를 초기화하고 버퍼 상태를 &quot;동적&quot;으로 초기화하고 (버퍼는 필요에 따라 할당 됨) 할당 된 크기를 지정되지 않은 값으로 초기화합니다. 할당 기능을 &lt;code&gt;palloc&lt;/code&gt; 으로 초기화하고 할당 해제 기능을 &lt;code&gt;pfree&lt;/code&gt; 로 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="6c929c7f99749902d23f395ed194b11494dce0fd" translate="yes" xml:space="preserve">
          <source>2) Constructs a &lt;code&gt;std::unique_ptr&lt;/code&gt; which owns p, initializing the stored pointer with p and value-initializing the stored deleter. Requires that &lt;code&gt;Deleter&lt;/code&gt; is &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; and that construction does not throw an exception.</source>
          <target state="translated">2) p를 소유 한 &lt;code&gt;std::unique_ptr&lt;/code&gt; 구성하고, p로 저장된 포인터를 초기화하고 저장된 삭제기를 값으로 초기화합니다. 해야 &lt;code&gt;Deleter&lt;/code&gt; 가가 이다 &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; 그 구조가 예외를 throw하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ca79ffed62826124787009684c270921353c076" translate="yes" xml:space="preserve">
          <source>2) Constructs a &lt;code&gt;time_of_day&lt;/code&gt; object in 24 hour format corresponding to &lt;code&gt;since_midnight&lt;/code&gt; after 00:00:00. As applicable:</source>
          <target state="translated">2) 00:00:00 이후 &lt;code&gt;since_midnight&lt;/code&gt; 에 해당하는 24 시간 형식으로 &lt;code&gt;time_of_day&lt;/code&gt; 객체를 구성합니다 . 해당되는 경우 :</target>
        </trans-unit>
        <trans-unit id="d9087b1e60584a8805d3978a21d626dc16c404ec" translate="yes" xml:space="preserve">
          <source>2) Constructs a &lt;code&gt;time_point&lt;/code&gt; at &lt;code&gt;Clock&lt;/code&gt;'s epoch plus &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;Clock&lt;/code&gt; 에포크에 &lt;code&gt;d&lt;/code&gt; 를 더한 &lt;code&gt;time_point&lt;/code&gt; 를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="cb5b9958304de60401d50545c11fb9581186d92c" translate="yes" xml:space="preserve">
          <source>2) Constructs a &lt;code&gt;weekday&lt;/code&gt; object holding the weekday value &lt;code&gt;wd&lt;/code&gt;. If &lt;code&gt;wd &amp;gt; 255&lt;/code&gt;, the value held is unspecified.</source>
          <target state="translated">2) 요일 값 &lt;code&gt;wd&lt;/code&gt; 를 유지 하는 &lt;code&gt;weekday&lt;/code&gt; 객체를 구성합니다 . 경우 &lt;code&gt;wd &amp;gt; 255&lt;/code&gt; , 유지 된 값을 지정한다.</target>
        </trans-unit>
        <trans-unit id="64c86b537715a6d37e1156e3d090fa041006d2b6" translate="yes" xml:space="preserve">
          <source>2) Constructs a &lt;code&gt;weekday_indexed&lt;/code&gt; storing the weekday &lt;code&gt;wd&lt;/code&gt; and the index &lt;code&gt;index&lt;/code&gt;. The values held are unspecified if &lt;code&gt;!wd.ok() || index == 0 || index &amp;gt; 5&lt;/code&gt;.</source>
          <target state="translated">2) 요일 &lt;code&gt;wd&lt;/code&gt; 및 인덱스 &lt;code&gt;index&lt;/code&gt; 저장 하는 &lt;code&gt;weekday_indexed&lt;/code&gt; 를 구성합니다 . &lt;code&gt;!wd.ok() || index == 0 || index &amp;gt; 5&lt;/code&gt; 경우 보유 된 값은 지정되지 않습니다 . 인덱스 == 0 || 색인&amp;gt; 5 .</target>
        </trans-unit>
        <trans-unit id="7dd65eea94055ab782ef791e82f393220ebc8094" translate="yes" xml:space="preserve">
          <source>2) Constructs a &lt;code&gt;weekday_last&lt;/code&gt; from &lt;code&gt;*this&lt;/code&gt;. The result represents the last weekday in some yet-to-be-specified month.</source>
          <target state="translated">2) &lt;code&gt;*this&lt;/code&gt; 로부터 &lt;code&gt;weekday_last&lt;/code&gt; 를 생성 합니다 . 결과는 아직 지정되지 않은 일부 월의 마지막 요일을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="686bf82f429b2f12fa676b86a84920b3fcd6af7b" translate="yes" xml:space="preserve">
          <source>2) Constructs a &lt;code&gt;year_month&lt;/code&gt; object storing the year &lt;code&gt;y&lt;/code&gt; and the month &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;y&lt;/code&gt; 및 월 &lt;code&gt;m&lt;/code&gt; 을 저장 하는 &lt;code&gt;year_month&lt;/code&gt; 객체를 구축합니다 .</target>
        </trans-unit>
        <trans-unit id="533de5d095ff6a0306d8d557bcf094f8cc716fb7" translate="yes" xml:space="preserve">
          <source>2) Constructs a &lt;code&gt;year_month_day&lt;/code&gt; object that stores the year &lt;code&gt;y&lt;/code&gt;, month &lt;code&gt;m&lt;/code&gt; and day &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">2) 연도 &lt;code&gt;y&lt;/code&gt; , 월 &lt;code&gt;m&lt;/code&gt; 및 일 &lt;code&gt;d&lt;/code&gt; 를 저장 하는 &lt;code&gt;year_month_day&lt;/code&gt; 객체를 구축합니다 .</target>
        </trans-unit>
        <trans-unit id="a169f2907f81f6e759c0f2ab19367ff8c8f8f4b6" translate="yes" xml:space="preserve">
          <source>2) Constructs a &lt;code&gt;year_month_weekday&lt;/code&gt; object storing the year &lt;code&gt;y&lt;/code&gt;, the month &lt;code&gt;m&lt;/code&gt;, the weekday &lt;code&gt;wdi.weekday()&lt;/code&gt; and the weekday index &lt;code&gt;wdi.index()&lt;/code&gt;.</source>
          <target state="translated">2) 연도 &lt;code&gt;y&lt;/code&gt; , 월 &lt;code&gt;m&lt;/code&gt; , 요일 &lt;code&gt;wdi.weekday()&lt;/code&gt; 및 요일 인덱스 &lt;code&gt;wdi.index()&lt;/code&gt; 저장 하는 &lt;code&gt;year_month_weekday&lt;/code&gt; 객체를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="f2f35eac8fdb2f8e8c2d02daa0d2e99575a4d0f7" translate="yes" xml:space="preserve">
          <source>2) Constructs a bitset, initializing the first (rightmost, least significant) &lt;code&gt;M&lt;/code&gt; bit positions to the corresponding bit values of &lt;code&gt;val&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; is the smaller of the number of bits in an &lt;code&gt;unsigned long long&lt;/code&gt; and the number of bits &lt;code&gt;N&lt;/code&gt; in the bitset being constructed. If M is less than N (the bitset is longer than 32(until C++11)64(since C++11) bits, for typical implementations of unsigned long (since C++11)long), the remaining bit positions are initialized to zeroes.</source>
          <target state="translated">2) 첫 번째 (가장 오른쪽, 가장 중요하지 않은) &lt;code&gt;M&lt;/code&gt; 비트 위치를 &lt;code&gt;val&lt;/code&gt; 의 해당 비트 값으로 초기화 하는 비트 세트를 구성합니다 . 여기서 &lt;code&gt;M&lt;/code&gt; 은 &lt;code&gt;unsigned long long&lt;/code&gt; 의 비트 수와 비트 세트의 비트 수 &lt;code&gt;N&lt;/code&gt; 보다 작 습니다. 건설되고 있습니다. M이 N보다 작은 경우 (비트 세트가 32 (C ++ 11 이후) 64 (C ++ 11 이후) 비트보다 길면 부호없는 long (C ++ 11 이후)의 일반적인 구현의 경우 나머지 비트 위치) 0으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="adde620f38bc4fe02f616e032b7622bdf2a0b8c9" translate="yes" xml:space="preserve">
          <source>2) Constructs a copy of &lt;code&gt;rhs&lt;/code&gt;, initializing the six pointers and the locale object with the copies of the values held by &lt;code&gt;rhs&lt;/code&gt;. Note that this is a shallow copy: the pointers of the newly-constructed basic_streambuf are pointing into the same character array as the pointers of &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">2)의 복사본 구축 &lt;code&gt;rhs&lt;/code&gt; 여섯 포인터에 의해 유지 된 값의 사본 로케일 객체 초기화 &lt;code&gt;rhs&lt;/code&gt; . 이것은 얕은 카피입니다. 새롭게 구축 된 basic_streambuf의 포인터는 &lt;code&gt;rhs&lt;/code&gt; 의 포인터와 같은 문자 배열을 가리 킵니다 .</target>
        </trans-unit>
        <trans-unit id="b6460d8bd4bef4b4a119381d98e079bd370305b1" translate="yes" xml:space="preserve">
          <source>2) Constructs a directory iterator that refers to the first directory entry of a directory identified by &lt;code&gt;p&lt;/code&gt;. If &lt;code&gt;p&lt;/code&gt; refers to an non-existing file or not a directory, throws &lt;code&gt;&lt;a href=&quot;../filesystem_error&quot;&gt;std::filesystem::filesystem_error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;p&lt;/code&gt; 로 식별되는 디렉토리의 첫 번째 디렉토리 항목을 참조하는 디렉토리 반복자를 구성합니다 . 경우 &lt;code&gt;p&lt;/code&gt; 는 존재하지 않는 파일이나하지 디렉토리를 참조 슬로우 &lt;code&gt;&lt;a href=&quot;../filesystem_error&quot;&gt;std::filesystem::filesystem_error&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11180312f1bb250ed5f9e37aa49f73ee049070cc" translate="yes" xml:space="preserve">
          <source>2) Constructs a distribution object from iterators over the and interval sequence &lt;code&gt;[first_i, last_i)&lt;/code&gt; and a matching weight sequence starting at &lt;code&gt;first_w&lt;/code&gt;.</source>
          <target state="translated">2) 및 구간 시퀀스 &lt;code&gt;[first_i, last_i)&lt;/code&gt; 및 &lt;code&gt;first_w&lt;/code&gt; 에서 시작하는 일치 가중치 시퀀스에 대해 반복자로부터 분포 객체를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="53243ba971b3f254bdfe46ee6617a09b34a31ffd" translate="yes" xml:space="preserve">
          <source>2) Constructs a distribution object from iterators over the interval sequence &lt;code&gt;[first_i, last_i)&lt;/code&gt; and a matching weight sequence starting at &lt;code&gt;first_w&lt;/code&gt;.</source>
          <target state="translated">2) 구간 시퀀스 &lt;code&gt;[first_i, last_i)&lt;/code&gt; 및 &lt;code&gt;first_w&lt;/code&gt; 에서 시작하는 일치 가중치 시퀀스를 통해 반복자로부터 분포 객체를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="3678cfb165ce5d902a550b6efb428fd66ac2268e" translate="yes" xml:space="preserve">
          <source>2) Constructs a match result with no established result state (&lt;code&gt;ready() != true&lt;/code&gt;) using a copy of &lt;code&gt;a&lt;/code&gt; as the allocator.</source>
          <target state="translated">2) 확립 된 결과 상태 (와 일치하는 결과를 구축 &lt;code&gt;ready() != true&lt;/code&gt; 사본 사용) &lt;code&gt;a&lt;/code&gt; 할당 자한다.</target>
        </trans-unit>
        <trans-unit id="33e4680b40bb5e9de9e76b97223140ad662761d3" translate="yes" xml:space="preserve">
          <source>2) Constructs a new &lt;code&gt;&lt;a href=&quot;../random_device&quot;&gt;std::random_device&lt;/a&gt;&lt;/code&gt; object, making use of the argument &lt;code&gt;token&lt;/code&gt; in an implementation-defined manner.</source>
          <target state="translated">2) 구현 정의 방식으로 인수 &lt;code&gt;token&lt;/code&gt; 을 사용 하여 새로운 &lt;code&gt;&lt;a href=&quot;../random_device&quot;&gt;std::random_device&lt;/a&gt;&lt;/code&gt; 객체를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="e394beb77f39521d1467de2f03b5873af64f0c1b" translate="yes" xml:space="preserve">
          <source>2) Constructs a new &lt;code&gt;auto_ptr&lt;/code&gt; with a pointer obtained by calling &lt;code&gt;&lt;a href=&quot;release&quot;&gt;release()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;&lt;a href=&quot;release&quot;&gt;release()&lt;/a&gt;&lt;/code&gt; 를 호출하여 얻은 포인터 로 새로운 &lt;code&gt;auto_ptr&lt;/code&gt; 을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="de46be5587d898273d127163f0d20c6f4355d1de" translate="yes" xml:space="preserve">
          <source>2) Constructs a new slice with parameters &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;size&lt;/code&gt;, &lt;code&gt;stride&lt;/code&gt;. This slice will refer to &lt;code&gt;size&lt;/code&gt; number of elements, each with the position:</source>
          <target state="translated">2) &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;size&lt;/code&gt; , &lt;code&gt;stride&lt;/code&gt; 매개 변수를 사용하여 새 슬라이스를 구성합니다 . 이 슬라이스는 각각 위치가있는 요소의 &lt;code&gt;size&lt;/code&gt; 수를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="2dbb34bc68da8889f83c4f94b482f96f2b492626" translate="yes" xml:space="preserve">
          <source>2) Constructs a new slice with parameters &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;sizes&lt;/code&gt;, &lt;code&gt;strides&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;sizes&lt;/code&gt; , &lt;code&gt;strides&lt;/code&gt; 매개 변수를 사용하여 새 슬라이스를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="b20f5480726f01f70d7c6335dd60a6a74ba5ce38" translate="yes" xml:space="preserve">
          <source>2) Constructs a numeric array with &lt;code&gt;count&lt;/code&gt; copies of value-initialized elements.</source>
          <target state="translated">2) 값이 초기화 된 요소의 &lt;code&gt;count&lt;/code&gt; 사본으로 숫자 형 배열을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="aed0fb29beecfe2ed99a0141a87e6927445be187" translate="yes" xml:space="preserve">
          <source>2) Constructs a regex from a null-terminated string &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">2) null로 끝나는 문자열 &lt;code&gt;s&lt;/code&gt; 에서 정규 표현식을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="ccc687035c07facd2310e68ab66938e1a135b8b8" translate="yes" xml:space="preserve">
          <source>2) Constructs a shared future that refers to the same shared state, if any, as &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;other&lt;/code&gt; 경우와 동일한 공유 상태를 나타내는 공유 미래를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="423839cf604fdb1fc885352dd17224b0a299fb65" translate="yes" xml:space="preserve">
          <source>2) Constructs a span that is a view over the range &lt;code&gt;[ptr, ptr + count)&lt;/code&gt;; the resulting span has &lt;code&gt;data() == ptr&lt;/code&gt; and &lt;code&gt;size() == count&lt;/code&gt;. The behavior is undefined if &lt;code&gt;[ptr, ptr + count)&lt;/code&gt; is not a valid range or if &lt;code&gt;extent != &lt;a href=&quot;dynamic_extent&quot;&gt;std::dynamic_extent&lt;/a&gt; &amp;amp;&amp;amp; count != extent&lt;/code&gt;.</source>
          <target state="translated">2) 범위 &lt;code&gt;[ptr, ptr + count)&lt;/code&gt; 대한 범위 인 범위를 구성합니다 . 결과 범위는 &lt;code&gt;data() == ptr&lt;/code&gt; 및 &lt;code&gt;size() == count&lt;/code&gt; 입니다. &lt;code&gt;[ptr, ptr + count)&lt;/code&gt; 가 유효한 범위가 아니거나 &lt;code&gt;extent != &lt;a href=&quot;dynamic_extent&quot;&gt;std::dynamic_extent&lt;/a&gt; &amp;amp;&amp;amp; count != extent&lt;/code&gt; 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fb253dd4b1c8b52ab6160c7739958f0a8da428ca" translate="yes" xml:space="preserve">
          <source>2) Constructs a value at the location the iterator points to from &lt;code&gt;std::move(el)&lt;/code&gt;.</source>
          <target state="translated">2) 반복자가 가리키는 위치에 &lt;code&gt;std::move(el)&lt;/code&gt; 에서 값을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="28fba04d4af6016c758ef722de3e54208acbe4aa" translate="yes" xml:space="preserve">
          <source>2) Constructs an &lt;code&gt;atomic_ref&lt;/code&gt; object referencing the object referenced by &lt;code&gt;ref&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;ref&lt;/code&gt; 에 의해 참조 된 객체를 참조 하는 &lt;code&gt;atomic_ref&lt;/code&gt; 객체를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="115ff3a7f42978abd297073a26befada691387b8" translate="yes" xml:space="preserve">
          <source>2) Constructs an array of unknown bound &lt;code&gt;T&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;T&lt;/code&gt; is an array of unknown bound. The function is equivalent to:</source>
          <target state="translated">2) 미지의 경계 &lt;code&gt;T&lt;/code&gt; 의 배열을 구축합니다 . &lt;code&gt;T&lt;/code&gt; 가 알려지지 않은 범위의 배열 인 경우이 과부하는 과부하 해결에만 참여 합니다. 이 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7a86d8ee459208efd91a3899e3cd4c8e0d0891ab" translate="yes" xml:space="preserve">
          <source>2) Constructs error code with &lt;code&gt;ec&lt;/code&gt; as the platform-dependent error code and &lt;code&gt;ecat&lt;/code&gt; as the corresponding error category.</source>
          <target state="translated">2) &lt;code&gt;ec&lt;/code&gt; 를 플랫폼 종속 오류 코드로, &lt;code&gt;ecat&lt;/code&gt; 를 해당 오류 범주로 사용하여 오류 코드를 구성 합니다.</target>
        </trans-unit>
        <trans-unit id="475de68a0bada7aa87d8a7096267debae087fd8d" translate="yes" xml:space="preserve">
          <source>2) Constructs new &lt;code&gt;weak_ptr&lt;/code&gt; which shares an object managed by &lt;code&gt;r&lt;/code&gt;. If &lt;code&gt;r&lt;/code&gt; manages no object, &lt;code&gt;*this&lt;/code&gt; manages no object too. The templated overloads don't participate in the overload resolution unless &lt;code&gt;Y*&lt;/code&gt; is implicitly convertible to &lt;code&gt;T*&lt;/code&gt;, or &lt;code&gt;Y&lt;/code&gt; is the type &quot;array of &lt;code&gt;N&lt;/code&gt;&lt;code&gt;U&lt;/code&gt;&quot; for some type &lt;code&gt;U&lt;/code&gt; and some number &lt;code&gt;N&lt;/code&gt;, and &lt;code&gt;T&lt;/code&gt; is the type &quot;array of unknown bound of (possibly cv-qualified) &lt;code&gt;U&lt;/code&gt;&quot;.(since C++17)</source>
          <target state="translated">2) &lt;code&gt;r&lt;/code&gt; 에 의해 관리되는 객체를 공유하는 새로운 &lt;code&gt;weak_ptr&lt;/code&gt; 을 구성합니다 . &lt;code&gt;r&lt;/code&gt; &lt;code&gt;*this&lt;/code&gt; 오브젝트를 관리하지 않으면 *이 오브젝트도 관리하지 않습니다. 템플릿 기반 오버로드하지 않는 한 오버로드 확인에 참여하지 않는 &lt;code&gt;Y*&lt;/code&gt; 에 암시 적으로 변환이다 &lt;code&gt;T*&lt;/code&gt; , 또는 &lt;code&gt;Y&lt;/code&gt; 는 유형 &quot;의 배열입니다 &lt;code&gt;N&lt;/code&gt; &lt;code&gt;U&lt;/code&gt; 일부 유형에 대한&quot; &lt;code&gt;U&lt;/code&gt; 와 몇 개의 &lt;code&gt;N&lt;/code&gt; , 및 &lt;code&gt;T&lt;/code&gt; 는 알 수없는 유형 &quot;배열입니다 cv-qualified) &lt;code&gt;U&lt;/code&gt; &quot;의 경계 ( C ++ 17부터)</target>
        </trans-unit>
        <trans-unit id="439720e8f692aef5727b81b093548c0de65569a3" translate="yes" xml:space="preserve">
          <source>2) Constructs new underlying string device. The underlying &lt;code&gt;basic_stringbuf&lt;/code&gt; object is constructed as &lt;code&gt;basic_stringbuf&amp;lt;Char,Traits,Allocator&amp;gt;(mode | ios_base::in)&lt;/code&gt;.</source>
          <target state="translated">2) 새로운 기본 문자열 장치를 구성합니다. 기본 &lt;code&gt;basic_stringbuf&lt;/code&gt; 객체는 &lt;code&gt;basic_stringbuf&amp;lt;Char,Traits,Allocator&amp;gt;(mode | ios_base::in)&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="9e578c66a22f3df81282cab5170d7e01dfd07308" translate="yes" xml:space="preserve">
          <source>2) Constructs new underlying string device. The underlying &lt;code&gt;basic_stringbuf&lt;/code&gt; object is constructed as &lt;code&gt;basic_stringbuf&amp;lt;Char,Traits,Allocator&amp;gt;(mode | ios_base::out)&lt;/code&gt;.</source>
          <target state="translated">2) 새로운 기본 문자열 장치를 구성합니다. 기본 &lt;code&gt;basic_stringbuf&lt;/code&gt; 객체는 &lt;code&gt;basic_stringbuf&amp;lt;Char,Traits,Allocator&amp;gt;(mode | ios_base::out)&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="5b26742ba4790c10ea6466b78be887bbfc29236e" translate="yes" xml:space="preserve">
          <source>2) Constructs new underlying string device. The underlying &lt;code&gt;basic_stringbuf&lt;/code&gt; object is constructed as &lt;code&gt;basic_stringbuf&amp;lt;Char,Traits,Allocator&amp;gt;(mode)&lt;/code&gt;.</source>
          <target state="translated">2) 새로운 기본 문자열 장치를 구성합니다. 기본 &lt;code&gt;basic_stringbuf&lt;/code&gt; 객체는 &lt;code&gt;basic_stringbuf&amp;lt;Char,Traits,Allocator&amp;gt;(mode)&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="d626afff2c7547d42103bfe66e164f0a512223dc" translate="yes" xml:space="preserve">
          <source>2) Constructs the &lt;code&gt;auto_ptr&lt;/code&gt; with the pointer held in &lt;code&gt;r&lt;/code&gt;. &lt;code&gt;r.release()&lt;/code&gt; is called to acquire the ownership of the object.</source>
          <target state="translated">2) 포인터를 &lt;code&gt;r&lt;/code&gt; 에 유지 하여 &lt;code&gt;auto_ptr&lt;/code&gt; 을 구성합니다 . &lt;code&gt;r.release()&lt;/code&gt; 는 객체의 소유권을 얻기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3655669398038557616416ef9575f29cb34d6596" translate="yes" xml:space="preserve">
          <source>2) Constructs the &lt;code&gt;wbuffer_convert&lt;/code&gt; object with the specified underlying byte stream, specified &lt;code&gt;codecvt&lt;/code&gt; facet, and specified initial conversion state (all parameters are optional)</source>
          <target state="translated">2) 지정된 기본 바이트 스트림, 지정된 &lt;code&gt;codecvt&lt;/code&gt; 패싯 및 지정된 초기 변환 상태를 사용 하여 &lt;code&gt;wbuffer_convert&lt;/code&gt; 객체를 구성합니다 (모든 매개 변수는 선택 사항 임)</target>
        </trans-unit>
        <trans-unit id="45ed1b243053b7583bf8a91cafc3455dc40aee93" translate="yes" xml:space="preserve">
          <source>2) Constructs the &lt;code&gt;wstring_convert&lt;/code&gt; object with a specified conversion facet, using default-constructed values for the shift state and the error strings</source>
          <target state="translated">2) 이동 상태 및 오류 문자열에 대해 기본값으로 구성된 값을 사용하여 지정된 변환 패싯으로 &lt;code&gt;wstring_convert&lt;/code&gt; 객체를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="607f9438b0811c51749d0b9b629e583834609d11" translate="yes" xml:space="preserve">
          <source>2) Constructs the base class &lt;code&gt;OuterAlloc&lt;/code&gt; from &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;OuterA2&amp;gt;(outerAlloc)&lt;/code&gt;, and the inner allocators with &lt;code&gt;innerAllocs...&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;OuterAlloc, OuterA2&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;OuterA2&amp;gt;(outerAlloc)&lt;/code&gt; &amp;lt;OuterA2&amp;gt; (outerAlloc) 에서 기본 클래스 &lt;code&gt;OuterAlloc&lt;/code&gt; 과 &lt;code&gt;innerAllocs...&lt;/code&gt; 있는 내부 할당자를 구성 합니다. &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;OuterAlloc, OuterA2&amp;gt;::value&lt;/code&gt; &amp;lt;OuterAlloc, OuterA2&amp;gt; :: value 가 &lt;code&gt;true&lt;/code&gt; 인 경우이 과부하는 과부하 해결에만 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="5ca0f39aa50b3fea5b0cb2acefe6c02c1077e0b0" translate="yes" xml:space="preserve">
          <source>2) Constructs the container with &lt;code&gt;count&lt;/code&gt; copies of elements with value &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">2) value &lt;code&gt;value&lt;/code&gt; 가진 요소의 &lt;code&gt;count&lt;/code&gt; 사본으로 컨테이너를 구성 합니다 .</target>
        </trans-unit>
        <trans-unit id="eeae934301b4589f8d38c4d474924f3c8f0c83c0" translate="yes" xml:space="preserve">
          <source>2) Constructs the container with the contents of the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;[first, last)&lt;/code&gt; 범위의 내용으로 컨테이너를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="f5cb633abb87465919c712f1e02783100394a03d" translate="yes" xml:space="preserve">
          <source>2) Constructs the container with the contents of the range &lt;code&gt;[first, last)&lt;/code&gt;. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending &lt;a href=&quot;http://wg21.link/lwg2844&quot;&gt;LWG2844&lt;/a&gt;).</source>
          <target state="translated">2) &lt;code&gt;[first, last)&lt;/code&gt; 범위의 내용으로 컨테이너를 구성합니다 . 범위의 여러 요소에 동등한 키가있는 경우 삽입 할 요소가 지정되지 &lt;a href=&quot;http://wg21.link/lwg2844&quot;&gt;않습니다&lt;/a&gt; ( LWG2844 보류 중 ).</target>
        </trans-unit>
        <trans-unit id="3c1fc1629895b59ee82a632352ae9a19ceb25e91" translate="yes" xml:space="preserve">
          <source>2) Constructs the distribution with weights in the range &lt;code&gt;[first, last)&lt;/code&gt;. If &lt;code&gt;first == last&lt;/code&gt;, the effects are the same as of the default constructor.</source>
          <target state="translated">2) &lt;code&gt;[first, last)&lt;/code&gt; 범위의 가중치를 갖는 분포를 구성합니다 . 경우 &lt;code&gt;first == last&lt;/code&gt; , 효과는 기본 생성자와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="01fe4792a2b66918e47a1070b1bce2e468355051" translate="yes" xml:space="preserve">
          <source>2) Constructs the engine and initializes the state (&lt;code&gt;n&lt;/code&gt; values X</source>
          <target state="translated">2) 엔진을 구성하고 상태를 초기화합니다 ( &lt;code&gt;n&lt;/code&gt; 값 X</target>
        </trans-unit>
        <trans-unit id="cffa68f513cbeedc38972594606a822c5b6fbe71" translate="yes" xml:space="preserve">
          <source>2) Constructs the iterator with &lt;code&gt;stream&lt;/code&gt; as the associated stream and a null pointer as the delimiter.</source>
          <target state="translated">2) &lt;code&gt;stream&lt;/code&gt; 을 연관된 스트림으로, 널 포인터를 분리 문자로 사용하여 반복자를 구성 합니다 .</target>
        </trans-unit>
        <trans-unit id="b2f5bbfe63be94fce164cbf107b5acdbabec07eb" translate="yes" xml:space="preserve">
          <source>2) Constructs the promise with an empty shared state. The shared state is allocated using &lt;code&gt;alloc&lt;/code&gt;. &lt;code&gt;Alloc&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">2) 빈 공유 상태로 약속을 구성합니다. 공유 상태는 &lt;code&gt;alloc&lt;/code&gt; 을 사용하여 할당 됩니다. &lt;code&gt;Alloc&lt;/code&gt; 은 &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; 의 요구 사항을 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="35257bba0638dcf20672225cb23fdc3b21905711" translate="yes" xml:space="preserve">
          <source>2) Constructs the string with &lt;code&gt;count&lt;/code&gt; copies of character &lt;code&gt;ch&lt;/code&gt;. This constructor is not used for &lt;a href=&quot;../../language/deduction_guide&quot;&gt;class template argument deduction&lt;/a&gt; if the &lt;code&gt;Allocator&lt;/code&gt; type that would be deduced does not qualify as an allocator. (since C++17)</source>
          <target state="translated">2) 문자 &lt;code&gt;ch&lt;/code&gt; 의 &lt;code&gt;count&lt;/code&gt; 사본으로 문자열을 구성합니다 . &lt;a href=&quot;../../language/deduction_guide&quot;&gt;추론&lt;/a&gt; 할 &lt;code&gt;Allocator&lt;/code&gt; 유형이 할당 자로 자격 이없는 경우이 생성자는 클래스 템플리트 인수 공제에 사용 되지 않습니다. (C ++ 17부터)</target>
        </trans-unit>
        <trans-unit id="64f8347931ad9e4bd7e8d55732727f3c59c5f28f" translate="yes" xml:space="preserve">
          <source>2) Constructs the underlying engine with &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;s&lt;/code&gt; 로 기본 엔진을 구성 합니다 .</target>
        </trans-unit>
        <trans-unit id="ca4550a4e8fb331e9b2c71664f8f9c51de82052f" translate="yes" xml:space="preserve">
          <source>2) Constructs with error code &lt;code&gt;ec&lt;/code&gt; and explanation string &lt;code&gt;what_arg&lt;/code&gt;. The string returned by &lt;code&gt;&lt;a href=&quot;what&quot;&gt;what()&lt;/a&gt;&lt;/code&gt; is guaranteed to contain &lt;code&gt;what_arg&lt;/code&gt; as a substring.</source>
          <target state="translated">2) 오류 코드 &lt;code&gt;ec&lt;/code&gt; 및 설명 문자열 &lt;code&gt;what_arg&lt;/code&gt; 로 구성 됩니다. &lt;code&gt;&lt;a href=&quot;what&quot;&gt;what()&lt;/a&gt;&lt;/code&gt; 의해 반환 된 문자열 은 &lt;code&gt;what_arg&lt;/code&gt; 를 하위 문자열 로 포함 하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="69f080473a76da5a561f5a4450e22f4d750cca4c" translate="yes" xml:space="preserve">
          <source>2) Conversion that promotes an &lt;a href=&quot;enum&quot;&gt;enumeration&lt;/a&gt; whose underlying type is fixed to its underlying type is better than one that promotes to the promoted underlying type, if the two types are different.</source>
          <target state="translated">2) 기본 유형이 기본 유형으로 고정 된 &lt;a href=&quot;enum&quot;&gt;열거&lt;/a&gt; 를 승격시키는 변환이 두 유형이 다른 경우 승격 된 기본 유형으로 승격하는 것보다 낫습니다.</target>
        </trans-unit>
        <trans-unit id="fba5556b44dbecba6bf370340330d475ff376fa3" translate="yes" xml:space="preserve">
          <source>2) Converts a signed decimal integer to a string with the same content as what &lt;code&gt;&lt;a href=&quot;../../io/c/fprintf&quot;&gt;std::sprintf&lt;/a&gt;(buf, &quot;%ld&quot;, value)&lt;/code&gt; would produce for sufficiently large &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">2) 부호있는 십진 정수를 &lt;code&gt;&lt;a href=&quot;../../io/c/fprintf&quot;&gt;std::sprintf&lt;/a&gt;(buf, &quot;%ld&quot;, value)&lt;/code&gt; 가 충분히 큰 &lt;code&gt;buf&lt;/code&gt; 에 대해 생성하는 내용과 동일한 내용의 문자열로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="5035ba21e28819316ddce23be1b2bcd19cfdb965" translate="yes" xml:space="preserve">
          <source>2) Converts a signed decimal integer to a wide string with the same content as what &lt;code&gt;&lt;a href=&quot;../../io/c/fwprintf&quot;&gt;std::swprintf&lt;/a&gt;(buf, sz, L&quot;%ld&quot;, value)&lt;/code&gt; would produce for sufficiently large &lt;code&gt;buf&lt;/code&gt;..</source>
          <target state="translated">2) 부호있는 십진 정수를 &lt;code&gt;&lt;a href=&quot;../../io/c/fwprintf&quot;&gt;std::swprintf&lt;/a&gt;(buf, sz, L&quot;%ld&quot;, value)&lt;/code&gt; 가 충분히 큰 &lt;code&gt;buf&lt;/code&gt; 에 대해 생성 할 내용과 동일한 내용을 가진 넓은 문자열로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="8e73ce0f3bcf769af0d99a5a088dd4cc0eb6e8fe" translate="yes" xml:space="preserve">
          <source>2) Converts the &lt;code&gt;sys_time&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; to a &lt;code&gt;file_time&lt;/code&gt; representing the same point in time.</source>
          <target state="translated">2) &lt;code&gt;sys_time&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 를 동일한 특정 시점을 나타내는 &lt;code&gt;file_time&lt;/code&gt; 으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="06321ecfd8be592d1419f4b4b9362c2f6615884c" translate="yes" xml:space="preserve">
          <source>2) Converts the &lt;code&gt;utc_time&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; to a &lt;code&gt;file_time&lt;/code&gt; representing the same point in time.</source>
          <target state="translated">2) &lt;code&gt;utc_time&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 를 같은 시점을 나타내는 &lt;code&gt;file_time&lt;/code&gt; 으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="955a1552de2720b1ad5aa50c4b55538a39a2c2a1" translate="yes" xml:space="preserve">
          <source>2) Converts the character sequence &lt;code&gt;[beg, end)&lt;/code&gt; to an integer value that is equal to the hash obtained for all strings that collate equivalent in this locale (&lt;code&gt;&lt;a href=&quot;compare&quot;&gt;compare()&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;​0​&lt;/code&gt;). For two strings that do not collate equivalent, the probability that their hashes are equal should be very small, approaching &lt;code&gt;1.0/&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;unsigned long&amp;gt;::max()&lt;/code&gt;.</source>
          <target state="translated">2) 문자 시퀀스 변환 &lt;code&gt;[beg, end)&lt;/code&gt; 이 로케일에 상응 대조 모든 문자열에 대한 해시 획득에 같은 정수 값을 ( &lt;code&gt;&lt;a href=&quot;compare&quot;&gt;compare()&lt;/a&gt;&lt;/code&gt; 복귀 &lt;code&gt;​0​&lt;/code&gt; ). 동등하게 배열하지 않는 두 문자열의 경우 해시가 같을 확률은 &lt;code&gt;1.0/&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;unsigned long&amp;gt;::max()&lt;/code&gt; 접근 할 때 매우 작아야 합니다.</target>
        </trans-unit>
        <trans-unit id="a150c36ecfb29eaf44ca852ca46ef4f69fee94f5" translate="yes" xml:space="preserve">
          <source>2) Converts the character sequence &lt;code&gt;[low, high)&lt;/code&gt; to a string that, compared lexicographically (e.g. with &lt;code&gt;operator&amp;lt;&lt;/code&gt; for strings) with the result of calling &lt;code&gt;transform()&lt;/code&gt; on another string, produces the same result as calling &lt;code&gt;&lt;a href=&quot;compare&quot;&gt;do_compare()&lt;/a&gt;&lt;/code&gt; on the same two strings.</source>
          <target state="translated">2) 문자 시퀀스 변환 &lt;code&gt;[low, high)&lt;/code&gt; , 사전 식 비교하는 문자열 (예를 함께 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 호출의 결과 문자열) &lt;code&gt;transform()&lt;/code&gt; 을 다른 문자열에 호출하는 것과 같은 결과를 &lt;code&gt;&lt;a href=&quot;compare&quot;&gt;do_compare()&lt;/a&gt;&lt;/code&gt; 동일한 상 두 줄.</target>
        </trans-unit>
        <trans-unit id="3f6e1e410c4b333e6b768ede4eca71f63eddd5d3" translate="yes" xml:space="preserve">
          <source>2) Converts the null-terminated multibyte character sequence beginning at the character pointed to by &lt;code&gt;ptr&lt;/code&gt; to wide_string.</source>
          <target state="translated">2) &lt;code&gt;ptr&lt;/code&gt; 로 가리키는 문자에서 시작하여 널 종료 멀티 바이트 문자 시퀀스 를 wide_string으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="aaeb0704f1c138bb7935b6cf04441eef2b8eb959" translate="yes" xml:space="preserve">
          <source>2) Converts the null-terminated wide character sequence beginning at the wide character pointed to by &lt;code&gt;wptr&lt;/code&gt;, to &lt;code&gt;byte_string&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;wptr&lt;/code&gt; 로 가리키는 와이드 문자에서 시작하여 널 종료 와이드 문자 시퀀스 를 &lt;code&gt;byte_string&lt;/code&gt; 으로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="6d75671e3b13e9b9c7ae26a1acfce4ecba6e2d80" translate="yes" xml:space="preserve">
          <source>2) Converts the two durations to their common type and creates a duration whose tick count is the &lt;code&gt;rhs&lt;/code&gt; number of ticks subtracted from the &lt;code&gt;lhs&lt;/code&gt; number of ticks after conversion.</source>
          <target state="translated">2) 두 지속 시간을 공통 유형으로 변환하고 틱 수가 변환 후 &lt;code&gt;lhs&lt;/code&gt; 틱 수에서 빼는 &lt;code&gt;rhs&lt;/code&gt; 틱 수인 지속 시간을 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="53ca675c66e0fe0b1453b1d0625ca9bb9bed2817" translate="yes" xml:space="preserve">
          <source>2) Copies all member objects from &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt; except for &lt;code&gt;&lt;a href=&quot;rdstate&quot;&gt;rdstate()&lt;/a&gt;&lt;/code&gt;, the exception mask, and &lt;code&gt;&lt;a href=&quot;rdbuf&quot;&gt;rdbuf()&lt;/a&gt;&lt;/code&gt;. In particular, makes copies of the locale, the formatting flags, the contents of the arrays &lt;code&gt;&lt;a href=&quot;../ios_base/iword&quot;&gt;std::ios_base::iword&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../ios_base/pword&quot;&gt;std::ios_base::pword&lt;/a&gt;&lt;/code&gt; (but not the &lt;code&gt;iword&lt;/code&gt; and &lt;code&gt;pword&lt;/code&gt; pointers themselves), the callbacks, and the tied stream.</source>
          <target state="translated">2) &lt;code&gt;&lt;a href=&quot;rdstate&quot;&gt;rdstate()&lt;/a&gt;&lt;/code&gt; , 예외 마스크 및 &lt;code&gt;&lt;a href=&quot;rdbuf&quot;&gt;rdbuf()&lt;/a&gt;&lt;/code&gt; 제외한 모든 멤버 객체를 &lt;code&gt;other&lt;/code&gt; 에서 &lt;code&gt;*this&lt;/code&gt; 로 복사합니다 . 특히 로케일, 형식화 플래그, 배열의 내용 &lt;code&gt;&lt;a href=&quot;../ios_base/iword&quot;&gt;std::ios_base::iword&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../ios_base/pword&quot;&gt;std::ios_base::pword&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;iword&lt;/code&gt; 및 &lt;code&gt;pword&lt;/code&gt; 포인터 자체는 아님), 콜백 및 묶음 의 사본을 만듭니다. 흐름.</target>
        </trans-unit>
        <trans-unit id="cebf3534efa6567c585fdcbca47fbba7a2b867fd" translate="yes" xml:space="preserve">
          <source>2) Copies the file or directory &lt;code&gt;from&lt;/code&gt; to file or directory &lt;code&gt;to&lt;/code&gt;, using the copy options indicated by &lt;code&gt;options&lt;/code&gt;. The behavior is undefined if there is more than one option in any of the &lt;a href=&quot;copy_options&quot;&gt;copy_options&lt;/a&gt; option group present in &lt;code&gt;options&lt;/code&gt; (even in the &lt;code&gt;copy_file&lt;/code&gt; group).</source>
          <target state="translated">2) 복사 파일이나 디렉토리 &lt;code&gt;from&lt;/code&gt; 파일이나 디렉토리 &lt;code&gt;to&lt;/code&gt; 의해 표시 복사 옵션을 사용하여 &lt;code&gt;options&lt;/code&gt; . &lt;a href=&quot;copy_options&quot;&gt;copy_options&lt;/a&gt; 옵션 그룹에 &lt;code&gt;options&lt;/code&gt; ( &lt;code&gt;copy_file&lt;/code&gt; 그룹 에도 있음)에 둘 이상의 옵션이 있으면 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f0d320ff8a27d99bf0ebfc15a02bdd3573384a70" translate="yes" xml:space="preserve">
          <source>2) Copy construction is not allowed.</source>
          <target state="translated">2) 복사 구성은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c26d65805fe75dda11b8b2d6cc957363c04e7dc" translate="yes" xml:space="preserve">
          <source>2) Copy constructor is deleted.</source>
          <target state="translated">2) 복사 생성자가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="20b4fada38bb617fce14ef74a05a666c8d76d0b2" translate="yes" xml:space="preserve">
          <source>2) Copy constructor.</source>
          <target state="translated">2) 복사 생성자.</target>
        </trans-unit>
        <trans-unit id="5c1765c86cf319101e7d743a27d8f3070618f73f" translate="yes" xml:space="preserve">
          <source>2) Copy constructor. Constructs a copy of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">2) 복사 생성자. &lt;code&gt;other&lt;/code&gt; 의 사본을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="043dd5aa5709e159037602abfeb720a302be31af" translate="yes" xml:space="preserve">
          <source>2) Copy constructor. Constructs a path whose pathname, in both native and generic formats, is the same as that of &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">2) 복사 생성자. 기본 및 일반 형식의 경로 이름이 &lt;code&gt;p&lt;/code&gt; 의 경로 이름과 동일한 경로를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="03146b14c60fa2108ce5596dce567087c7029dbe" translate="yes" xml:space="preserve">
          <source>2) Copy constructor. Constructs a view of the same content as &lt;code&gt;other&lt;/code&gt;. After construction, &lt;code&gt;&lt;a href=&quot;data&quot;&gt;data()&lt;/a&gt;&lt;/code&gt; is equal to &lt;code&gt;other.data()&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; is equal to &lt;code&gt;other.size()&lt;/code&gt;.</source>
          <target state="translated">2) 복사 생성자. &lt;code&gt;other&lt;/code&gt; 와 동일한 내용의보기를 구성합니다 . 생성 후 &lt;code&gt;&lt;a href=&quot;data&quot;&gt;data()&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;other.data()&lt;/code&gt; 와 같고 &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;other.size()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d106a094e301bc7081faa83509bbc5bd71fc8b9" translate="yes" xml:space="preserve">
          <source>2) Copy constructor. Constructs the object with the copy of the contents of &lt;code&gt;other&lt;/code&gt;. The copy constructor is implicit in the standard specializations.</source>
          <target state="translated">2) 복사 생성자. &lt;code&gt;other&lt;/code&gt; 의 내용을 복사하여 객체를 구성합니다 . 복사 생성자는 표준 전문 분야에 내재되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="249624bbf2c19055ef0ef8c1f862d66023b79e4d" translate="yes" xml:space="preserve">
          <source>2) Copy constructor. If &lt;code&gt;other&lt;/code&gt; is not &lt;a href=&quot;valueless_by_exception&quot;&gt;valueless_by_exception&lt;/a&gt;, constructs a variant holding the same alternative as &lt;code&gt;other&lt;/code&gt; and &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-initializes&lt;/a&gt; the contained value with &lt;code&gt;std::get&amp;lt;other.index()&amp;gt;(other)&lt;/code&gt;. Otherwise, initializes a valueless_by_exception variant. This constructor is defined as deleted unless &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;T_i&amp;gt;&lt;/code&gt; is true for all &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types...&lt;/code&gt;. It is trivial if &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_trivially_copy_constructible_v&lt;/a&gt;&amp;lt;T_i&amp;gt;&lt;/code&gt; is true for all &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types...&lt;/code&gt;.</source>
          <target state="translated">2) 복사 생성자. 경우 &lt;code&gt;other&lt;/code&gt; 아니다 &lt;a href=&quot;valueless_by_exception&quot;&gt;valueless_by_exception&lt;/a&gt; , 같은 대안 들고 변형 구축 &lt;code&gt;other&lt;/code&gt; 및 &lt;a href=&quot;../../language/direct_initialization&quot;&gt;직접 - 초기화를&lt;/a&gt; 함께 포함 된 값을 &lt;code&gt;std::get&amp;lt;other.index()&amp;gt;(other)&lt;/code&gt; . 그렇지 않으면 valueless_by_exception 변형을 초기화합니다. 이 생성자는 &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;T_i&amp;gt;&lt;/code&gt; 가 &lt;code&gt;Types...&lt;/code&gt; 모든 &lt;code&gt;T_i&lt;/code&gt; 에 대해 true가 아니면 삭제 된 것으로 정의됩니다 . &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_trivially_copy_constructible_v&lt;/a&gt;&amp;lt;T_i&amp;gt;&lt;/code&gt; &amp;lt;T_i&amp;gt; 가 &lt;code&gt;Types...&lt;/code&gt; 모든 &lt;code&gt;T_i&lt;/code&gt; 에 대해 true이면 사소합니다 .</target>
        </trans-unit>
        <trans-unit id="e0e59596af530735e886f19fc5209914456ac64b" translate="yes" xml:space="preserve">
          <source>2) Copy constructor. Initializes the contents with those of &lt;code&gt;other&lt;/code&gt;. If &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; both have dynamic type &lt;code&gt;std::exception&lt;/code&gt; then &lt;code&gt;&lt;a href=&quot;../../string/byte/strcmp&quot;&gt;std::strcmp&lt;/a&gt;(what(), other.what()) == 0&lt;/code&gt;.(since C++11)</source>
          <target state="translated">2) 복사 생성자. 내용을 &lt;code&gt;other&lt;/code&gt; 의 내용으로 초기화합니다 . 만약 &lt;code&gt;*this&lt;/code&gt; 과 &lt;code&gt;other&lt;/code&gt; 두 유형이 동적 &lt;code&gt;std::exception&lt;/code&gt; 다음 &lt;code&gt;&lt;a href=&quot;../../string/byte/strcmp&quot;&gt;std::strcmp&lt;/a&gt;(what(), other.what()) == 0&lt;/code&gt; . (11 보낸 ++ C)</target>
        </trans-unit>
        <trans-unit id="3ecd6fc6e7dc38391c406e29ccedf857a99cde5f" translate="yes" xml:space="preserve">
          <source>2) Copy constructor. Initializes the error condition with the contents of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">2) 복사 생성자. &lt;code&gt;other&lt;/code&gt; 의 내용으로 오류 조건을 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="cc6cd899ffbfa10b6112fbc1b1c9352f5dc89351" translate="yes" xml:space="preserve">
          <source>2) Copy constructor. Initializes the object with the contents of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">2) 복사 생성자. &lt;code&gt;other&lt;/code&gt; 의 내용으로 객체를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="4de701d641e8f3e7bf5c7380e89be87915443459" translate="yes" xml:space="preserve">
          <source>2) Copy constructor. Initializes the object with the exception stored in &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">2) 복사 생성자. &lt;code&gt;other&lt;/code&gt; 에 저장된 예외를 사용하여 객체를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="6c3f0ad45e53ef73917faefff1fcb94f2e557a80" translate="yes" xml:space="preserve">
          <source>2) Copy constructor. Stores a reference to &lt;code&gt;other.get()&lt;/code&gt;.</source>
          <target state="translated">2) 복사 생성자. &lt;code&gt;other.get()&lt;/code&gt; 대한 참조를 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="484e1de63aee35c8659e2d029b63350c78c521b7" translate="yes" xml:space="preserve">
          <source>2) Copy constructor: If &lt;code&gt;other&lt;/code&gt; contains a value, initializes the contained value as if &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-initializing&lt;/a&gt; (but not direct-list-initializing) an object of type &lt;code&gt;T&lt;/code&gt; with the expression &lt;code&gt;*other&lt;/code&gt;. If &lt;code&gt;other&lt;/code&gt; does not contain a value, constructs an object that</source>
          <target state="translated">2) 복사 생성자 : &lt;code&gt;other&lt;/code&gt; 에 값이 포함 된 경우, &lt;code&gt;*other&lt;/code&gt; 표현식을 사용하여 &lt;code&gt;T&lt;/code&gt; 유형의 오브젝트를 직접 &lt;a href=&quot;../../language/direct_initialization&quot;&gt;초기화&lt;/a&gt; (직접 목록 초기화는 아님)하는 것처럼 포함 된 값을 초기화하십시오 . &lt;code&gt;other&lt;/code&gt; 에 값이 포함되어 있지 않은 경우</target>
        </trans-unit>
        <trans-unit id="19742d469c9daf20e1c45d0dbe7dd51a5034b394" translate="yes" xml:space="preserve">
          <source>2) Copy-constructs the comparison functor &lt;code&gt;comp&lt;/code&gt; with the contents of &lt;code&gt;compare&lt;/code&gt;. Value-initializes the underlying container &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">2) 비교 펑터 복사-구축 &lt;code&gt;comp&lt;/code&gt; 의 내용과 &lt;code&gt;compare&lt;/code&gt; . 기본 컨테이너 &lt;code&gt;c&lt;/code&gt; 의 값을 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="fdd17c61d02150caa3a619c0b3b3cdcf528bc434" translate="yes" xml:space="preserve">
          <source>2) Copy-constructs the underlying container &lt;code&gt;c&lt;/code&gt; with the contents of &lt;code&gt;cont&lt;/code&gt;. This is also the default constructor.(until C++11)</source>
          <target state="translated">2) 기본 컨테이너 &lt;code&gt;c&lt;/code&gt; 를 &lt;code&gt;cont&lt;/code&gt; 의 내용으로 복사 구성합니다 . 이것은 또한 기본 생성자입니다. (C ++ 11까지)</target>
        </trans-unit>
        <trans-unit id="6696aaf6b3cae73b4133747c7036adad12754db6" translate="yes" xml:space="preserve">
          <source>2) Creates an optional object constructed in-place from &lt;code&gt;args...&lt;/code&gt;. Equivalent to &lt;code&gt;return &lt;a href=&quot;../optional&quot;&gt;std::optional&lt;/a&gt;&amp;lt;T&amp;gt;(&lt;a href=&quot;../in_place&quot;&gt;std::in_place&lt;/a&gt;, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...);&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;args...&lt;/code&gt; 에서 적절한 위치에 구성된 선택적 객체를 만듭니다 . &lt;code&gt;return &lt;a href=&quot;../optional&quot;&gt;std::optional&lt;/a&gt;&amp;lt;T&amp;gt;(&lt;a href=&quot;../in_place&quot;&gt;std::in_place&lt;/a&gt;, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...);&lt;/code&gt; &amp;lt;T&amp;gt; ( &lt;a href=&quot;../in_place&quot;&gt;std :: in_place&lt;/a&gt; , &lt;a href=&quot;../forward&quot;&gt;std :: forward&lt;/a&gt; &amp;lt;Args&amp;gt; (args) ...); 를 반환하는 것과 같습니다 . .</target>
        </trans-unit>
        <trans-unit id="3d34fff5f103eb4ae43924325d1f9ab08cfc5730" translate="yes" xml:space="preserve">
          <source>2) Declaration of a const lambda: the objects captured by copy are const in the lambda body.</source>
          <target state="translated">2) const 람다 선언 : 복사로 캡처 된 객체는 람다 본문에 const입니다.</target>
        </trans-unit>
        <trans-unit id="3aaeeec942eceb31ee4fb2ecf4ff61e0e77da3e1" translate="yes" xml:space="preserve">
          <source>2) Declares a named (formal) parameter with a &lt;a href=&quot;default_arguments&quot;&gt;default value&lt;/a&gt;.</source>
          <target state="translated">2) 명명 된 (공식) 매개 변수를 &lt;a href=&quot;default_arguments&quot;&gt;기본값으로&lt;/a&gt; 선언 합니다 .</target>
        </trans-unit>
        <trans-unit id="3e4cae66ddd18922ffd6b71c6f36e80380e921cc" translate="yes" xml:space="preserve">
          <source>2) Declares a static member function.</source>
          <target state="translated">2) 정적 멤버 함수를 선언합니다.</target>
        </trans-unit>
        <trans-unit id="b29ac381da19836f9e5730034efee78d89979639" translate="yes" xml:space="preserve">
          <source>2) Declares a user-defined conversion function that participates in &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialization&lt;/a&gt; and &lt;a href=&quot;explicit_cast&quot;&gt;explicit conversions&lt;/a&gt; only.</source>
          <target state="translated">2) &lt;a href=&quot;direct_initialization&quot;&gt;직접 초기화&lt;/a&gt; 및 &lt;a href=&quot;explicit_cast&quot;&gt;명시 적 변환&lt;/a&gt; 에만 참여하는 사용자 정의 변환 함수를 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="aec7794e124a76f3c15b9149d538d78d1235bf04" translate="yes" xml:space="preserve">
          <source>2) Declares an unscoped enumeration type whose underlying type is fixed.</source>
          <target state="translated">2) 기본 유형이 고정 된 범위가없는 열거 유형을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="3be4815134c54cc43b87155d8558a69e3662529e" translate="yes" xml:space="preserve">
          <source>2) Default arguments cannot appear in the argument list</source>
          <target state="translated">2) 기본 인수는 인수 목록에 나타날 수 없습니다</target>
        </trans-unit>
        <trans-unit id="271f10f51930c5092bcc0f94b2b13f809f4c0f3c" translate="yes" xml:space="preserve">
          <source>2) Defaulted copy constructor.</source>
          <target state="translated">2) 기본 복사 생성자.</target>
        </trans-unit>
        <trans-unit id="066c0b2c3a0794ed161cf2b02035d30105994226" translate="yes" xml:space="preserve">
          <source>2) Define a &lt;a href=&quot;../language/friend&quot;&gt;friend function&lt;/a&gt; in-class (this approach hides the class-specific swap from name lookup other than ADL)</source>
          <target state="translated">2) 클래스 내에서 &lt;a href=&quot;../language/friend&quot;&gt;친구 기능&lt;/a&gt; 을 정의하십시오 (이 방법은 ADL 이외의 이름 조회에서 클래스 특정 스왑을 숨 깁니다)</target>
        </trans-unit>
        <trans-unit id="e4bbe8f433d66a446810353bd8d2d2114d9c1de5" translate="yes" xml:space="preserve">
          <source>2) Defines a</source>
          <target state="translated">2) 정의</target>
        </trans-unit>
        <trans-unit id="473da14d9d3e872abf23376b303b9e8665b58538" translate="yes" xml:space="preserve">
          <source>2) Definition of the constructor outside of class definition (the class must contain a declaration (1)). See &lt;a href=&quot;constructor&quot;&gt;constructors and member initializer lists&lt;/a&gt; for details on the constructor body</source>
          <target state="translated">2) 클래스 정의 외부의 생성자 정의 (클래스는 선언 (1)을 포함해야합니다). 생성자 본문에 대한 자세한 내용 은 &lt;a href=&quot;constructor&quot;&gt;생성자 및 멤버 이니셜 라이저 목록&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="57611e0a8a981e871319e2e03657a87443ea63f3" translate="yes" xml:space="preserve">
          <source>2) Deletes the contents of &lt;code&gt;p&lt;/code&gt; (if it is a directory) and the contents of all its subdirectories, recursively, then deletes &lt;code&gt;p&lt;/code&gt; itself as if by repeatedly applying the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/remove.html&quot;&gt;remove&lt;/a&gt;. Symlinks are not followed (symlink is removed, not its target)</source>
          <target state="translated">2) &lt;code&gt;p&lt;/code&gt; 의 내용 (디렉토리 인 경우)과 모든 서브 디렉토리의 내용을 재귀 적으로 삭제 한 후 POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/remove.html&quot;&gt;remove를&lt;/a&gt; 반복적으로 적용하여 &lt;code&gt;p&lt;/code&gt; 자체 를 삭제 합니다 . 심볼릭 링크를 따르지 않음 (symlink는 대상이 아닌 제거됨)</target>
        </trans-unit>
        <trans-unit id="47ebb1df81049e5fe0eb77a55d075750f29e6bd0" translate="yes" xml:space="preserve">
          <source>2) Deletes the entire underlying character sequence of this &lt;code&gt;std::basic_stringbuf&lt;/code&gt; and then configures a new underlying character sequence containing a copy of the contents of &lt;code&gt;s&lt;/code&gt;. The pointers of &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; are initialized as follows:</source>
          <target state="translated">2)이 &lt;code&gt;std::basic_stringbuf&lt;/code&gt; 의 전체 기본 문자 순서를 삭제 한 다음 &lt;code&gt;s&lt;/code&gt; 내용의 사본을 포함하는 새 기본 문자 순서를 구성합니다 . &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; 의 포인터는 다음과 같이 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="12230a986a0d74523c2cb903b00d7cf9534ceabd" translate="yes" xml:space="preserve">
          <source>2) Destroys an array created by a &lt;a href=&quot;new&quot;&gt;new[]-expression&lt;/a&gt;</source>
          <target state="translated">2) &lt;a href=&quot;new&quot;&gt;new []&lt;/a&gt; -expression으로 생성 된 배열을 파기합니다</target>
        </trans-unit>
        <trans-unit id="e59c19d49979ae9467f4fdbf60940972793831a6" translate="yes" xml:space="preserve">
          <source>2) Detects how many exceptions in the current thread have been thrown or rethrown and not yet entered their matching catch clauses.</source>
          <target state="translated">2) 현재 스레드에서 몇 개의 예외가 발생 또는 재발하여 일치하는 catch 절에 아직 입력되지 않았는지 감지합니다.</target>
        </trans-unit>
        <trans-unit id="4d63ed03e2174a6094c31252e7fd055439040e3d" translate="yes" xml:space="preserve">
          <source>2) Determines whether &lt;code&gt;Fn&lt;/code&gt; can be invoked with the arguments &lt;code&gt;ArgTypes...&lt;/code&gt; to yield a result that is convertible to &lt;code&gt;R&lt;/code&gt;. Formally, determines whether &lt;code&gt;INVOKE&amp;lt;R&amp;gt;(declval&amp;lt;Fn&amp;gt;(), declval&amp;lt;ArgTypes&amp;gt;()...)&lt;/code&gt; is well formed when treated as an unevaluated operand, where &lt;code&gt;INVOKE&lt;/code&gt; is the operation defined in &lt;a href=&quot;../named_req/callable&quot;&gt;Callable&lt;/a&gt;</source>
          <target state="translated">2) &lt;code&gt;ArgTypes...&lt;/code&gt; 인수로 &lt;code&gt;Fn&lt;/code&gt; 을 호출 하여 &lt;code&gt;R&lt;/code&gt; 로 변환 가능한 결과를 생성 할 수 있는지 여부를 결정합니다 . 공식적으로, 평가되지 않은 피연산자로 취급 될 때 &lt;code&gt;INVOKE&amp;lt;R&amp;gt;(declval&amp;lt;Fn&amp;gt;(), declval&amp;lt;ArgTypes&amp;gt;()...)&lt;/code&gt; 가 제대로 형성 되는지 판별합니다 . 여기서 &lt;code&gt;INVOKE&lt;/code&gt; 는 &lt;a href=&quot;../named_req/callable&quot;&gt;Callable에&lt;/a&gt; 정의 된 조작입니다.</target>
        </trans-unit>
        <trans-unit id="caf2042005cf166e197e4ed0c7ad1499432046e3" translate="yes" xml:space="preserve">
          <source>2) Direct constructor. Initializes each element of the tuple with the corresponding parameter.</source>
          <target state="translated">2) 직접 생성자. 해당 매개 변수를 사용하여 튜플의 각 요소를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="9743b0f4882dd6bd4ee40f761c033033b27964da" translate="yes" xml:space="preserve">
          <source>2) Disables the &lt;code&gt;boolalpha&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.unsetf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::boolalpha&lt;/a&gt;)&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;str.unsetf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::boolalpha&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: boolalpha&lt;/a&gt; )를 호출 하여 스트림 &lt;code&gt;str&lt;/code&gt; 에서 &lt;code&gt;boolalpha&lt;/code&gt; 플래그를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="cd45b410cf818bbb18ca8dbb4f1f32a3c71e975a" translate="yes" xml:space="preserve">
          <source>2) Each element is assigned value obtained by applying the corresponding operator to the previous value of the element and the value of &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">2) 각 요소에는 해당 연산자를 요소의 이전 값과 &lt;code&gt;val&lt;/code&gt; 값에 적용하여 얻은 값이 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="bef04165f115d32e32dc4b99b87d1f943101dfc4" translate="yes" xml:space="preserve">
          <source>2) Each file introduced with the &lt;a href=&quot;../preprocessor/include&quot;&gt;#include&lt;/a&gt; directive goes through phases 1 through 4, recursively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59a41c839c334fc69ceb4400244142b9c4817d03" translate="yes" xml:space="preserve">
          <source>2) Effectively calls &lt;code&gt;&lt;a href=&quot;mem_fun_ref_t&quot;&gt;std::mem_fun1_ref_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;mem_fun_ref_t&quot;&gt;std::const_mem_fun1_ref_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;&lt;a href=&quot;mem_fun_ref_t&quot;&gt;std::mem_fun1_ref_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;mem_fun_ref_t&quot;&gt;std::const_mem_fun1_ref_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt; )를 효과적으로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="0adb30a250981b499f2bb768160510ae4dada788" translate="yes" xml:space="preserve">
          <source>2) Effectively calls &lt;code&gt;&lt;a href=&quot;mem_fun_t&quot;&gt;std::mem_fun1_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;mem_fun_t&quot;&gt;std::const_mem_fun1_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;&lt;a href=&quot;mem_fun_t&quot;&gt;std::mem_fun1_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;mem_fun_t&quot;&gt;std::const_mem_fun1_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt; )를 효과적으로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="de7b1068aacea50a06af3130fba18a45042aa21a" translate="yes" xml:space="preserve">
          <source>2) Effectively calls &lt;code&gt;&lt;a href=&quot;pointer_to_binary_function&quot;&gt;std::pointer_to_binary_function&lt;/a&gt;&amp;lt;Arg1,Arg2,Result&amp;gt;(f)&lt;/code&gt;.</source>
          <target state="translated">2) 효과적으로 &lt;code&gt;&lt;a href=&quot;pointer_to_binary_function&quot;&gt;std::pointer_to_binary_function&lt;/a&gt;&amp;lt;Arg1,Arg2,Result&amp;gt;(f)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="b8ed0f027f2e1d37b30d5e2628cb11b0c194f3dc" translate="yes" xml:space="preserve">
          <source>2) Effectively calls &lt;code&gt;c.push_back(std::move(value)); &lt;a href=&quot;../../algorithm/push_heap&quot;&gt;std::push_heap&lt;/a&gt;(c.begin(), c.end(), comp);&lt;/code&gt;</source>
          <target state="translated">2) 효과적으로 &lt;code&gt;c.push_back(std::move(value)); &lt;a href=&quot;../../algorithm/push_heap&quot;&gt;std::push_heap&lt;/a&gt;(c.begin(), c.end(), comp);&lt;/code&gt; 호출합니다 . &lt;a href=&quot;../../algorithm/push_heap&quot;&gt;std :: push_heap&lt;/a&gt; (c.begin (), c.end (), comp);</target>
        </trans-unit>
        <trans-unit id="01c2de8997a6ea0de4d692a2887360e303db5a98" translate="yes" xml:space="preserve">
          <source>2) Effectively calls &lt;code&gt;c.push_back(std::move(value))&lt;/code&gt;</source>
          <target state="translated">2) 효과적으로 &lt;code&gt;c.push_back(std::move(value))&lt;/code&gt; 호출</target>
        </trans-unit>
        <trans-unit id="175e59f7a25d1322bb554234bcc6f76cd23fce32" translate="yes" xml:space="preserve">
          <source>2) Effectively calls &lt;code&gt;f(read_symlink(from, ec), to, ec)&lt;/code&gt; where &lt;code&gt;f&lt;/code&gt; is &lt;a href=&quot;create_symlink&quot;&gt;&lt;code&gt;create_symlink&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;create_symlink&quot;&gt;&lt;code&gt;create_directory_symlink&lt;/code&gt;&lt;/a&gt; depending on whether &lt;code&gt;from&lt;/code&gt; resolves to a file or directory.</source>
          <target state="translated">2)를 효과적으로 호출 &lt;code&gt;f(read_symlink(from, ec), to, ec)&lt;/code&gt; 여기서 &lt;code&gt;f&lt;/code&gt; 는 이다 &lt;a href=&quot;create_symlink&quot;&gt; &lt;code&gt;create_symlink&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;create_symlink&quot;&gt; &lt;code&gt;create_directory_symlink&lt;/code&gt; &lt;/a&gt; 여부에 따라 &lt;code&gt;from&lt;/code&gt; 파일이나 디렉토리를 해결한다.</target>
        </trans-unit>
        <trans-unit id="a6241e308e37524055ab06256cfe35c33d4e7af8" translate="yes" xml:space="preserve">
          <source>2) Effectively calls &lt;code&gt;reset(r.release())&lt;/code&gt;. &lt;code&gt;Y*&lt;/code&gt; must be implicitly convertible to &lt;code&gt;T*&lt;/code&gt;.</source>
          <target state="translated">2) 효과적으로 &lt;code&gt;reset(r.release())&lt;/code&gt; 호출합니다 . &lt;code&gt;Y*&lt;/code&gt; 는 암시 적으로 &lt;code&gt;T*&lt;/code&gt; 로 변환 가능해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5a4a2f323e657a21282ee46616336ba1bcf1340e" translate="yes" xml:space="preserve">
          <source>2) Effectively the same as calling &lt;code&gt;reset()&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;reset()&lt;/code&gt; 호출과 사실상 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="43496f513064ff5f8fdeef00066cd9c4afdb751d" translate="yes" xml:space="preserve">
          <source>2) Empties the destination string by calling &lt;code&gt;s.clear()&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;s.clear()&lt;/code&gt; 를 호출하여 대상 문자열을 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="a3e5e93c02a312084ea477f0505a2ce8c10e6bbc" translate="yes" xml:space="preserve">
          <source>2) End iterator (default-constructed &lt;code&gt;directory_iterator&lt;/code&gt;)</source>
          <target state="translated">2) 반복자를 종료하십시오 (기본적으로 생성 된 &lt;code&gt;directory_iterator&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f36009aeb36318777bc062fe370f7e9d7dd9d57e" translate="yes" xml:space="preserve">
          <source>2) End iterator (default-constructed &lt;code&gt;recursive_directory_iterator&lt;/code&gt;)</source>
          <target state="translated">2) 종료 반복자 (기본 구성 &lt;code&gt;recursive_directory_iterator&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="84325355f8bc7d92bd12c7481992da96f1e7b607" translate="yes" xml:space="preserve">
          <source>2) Equivalent to</source>
          <target state="translated">2) 해당</target>
        </trans-unit>
        <trans-unit id="a2f4f82a82ccb4f670b67351a3c9ed9fd9bd3e40" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;a href=&quot;base&quot;&gt;&lt;code&gt;base()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">2) &lt;a href=&quot;base&quot;&gt; &lt;code&gt;base()&lt;/code&gt; &lt;/a&gt; )와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="329a7c297405a0922057570d0e9befab569ac51e" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;!lhs.equal(rhs)&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;!lhs.equal(rhs)&lt;/code&gt; )와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="159f46ff24ff604e16de8088b526590ad93f7a9e" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;*this = *this + dm;&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;*this = *this + dm;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1ac705c61b8eee5e8ac428b3677095e162d962c0" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;*this = *this - d;&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;*this = *this - d;&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="6f5e56c9b2147255b2684c457bba0f29cd747405" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;*this = *this - y;&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;*this = *this - y;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="106ac10c2f47311dcaa5834a565679c7227d2c3c" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;*this == code.category() &amp;amp;&amp;amp; code.value() == condition&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;*this == code.category() &amp;amp;&amp;amp; code.value() == condition&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da4765bf64dcf77c3b830feac70f357ad80bd40b" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;&lt;a href=&quot;../../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(operator*())&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;&lt;a href=&quot;../../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(operator*())&lt;/code&gt; )와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="fe5e9de499355d24c0a4dce54a1aa08412bbde07" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;&lt;a href=&quot;../local_t&quot;&gt;std::chrono::local_days&lt;/a&gt;(year()/month()/day())&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;&lt;a href=&quot;../local_t&quot;&gt;std::chrono::local_days&lt;/a&gt;(year()/month()/day())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5eac3042992bbe17397e4ad081d2686f8e51db8c" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;alignas(alignof(type))&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;alignas(alignof(type))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="25bb9bdd84393b27e61c3576bae9498a51e6fa6c" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;atomic_load_explicit(p, &lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;)&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;atomic_load_explicit(p, &lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="98d2ce3ad09050938190f90f28ae94b56e323cba" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;bool(*this) ? std::move(**this) : static_cast&amp;lt;T&amp;gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(default_value))&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;bool(*this) ? std::move(**this) : static_cast&amp;lt;T&amp;gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(default_value))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a5959c0d34df36fabbd01655d4029ad2f5db513a" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;compare(path(str))&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;compare(path(str))&lt;/code&gt; )와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="0fa1e89cdd958a4c8a28be62ad51a22de9c76921" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;emplace&amp;lt;I&amp;gt;(il, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;, where &lt;code&gt;I&lt;/code&gt; is the zero-based index of &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;Types...&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;std::is_constructible_v&amp;lt;T, std::initializer_list&amp;lt;U&amp;gt;&amp;amp;, Args...&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, and &lt;code&gt;T&lt;/code&gt; occurs exactly once in &lt;code&gt;Types...&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;emplace&amp;lt;I&amp;gt;(il, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt; 와 같습니다. 여기서 &lt;code&gt;I&lt;/code&gt; 은 &lt;code&gt;Types...&lt;/code&gt; 에서 &lt;code&gt;T&lt;/code&gt; 의 0부터 시작하는 인덱스입니다 . &lt;code&gt;std::is_constructible_v&amp;lt;T, std::initializer_list&amp;lt;U&amp;gt;&amp;amp;, Args...&amp;gt;&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 이고 &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;Types...&lt;/code&gt; 에서 정확히 한 번만 발생하는 경우이 과부하는 과부하 해결에만 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="fd58372303231910b96ae1b21ff41b87798ead91" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;find(basic_string_view(&lt;a href=&quot;../../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(ch), 1), pos)&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;find(basic_string_view(&lt;a href=&quot;../../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(ch), 1), pos)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="412507807b99be8430d446c227b13c19ffbcb895" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;find_first_not_of(basic_string_view(&lt;a href=&quot;../../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(c), 1), pos)&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;find_first_not_of(basic_string_view(&lt;a href=&quot;../../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(c), 1), pos)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="538be087c5ee2c2cd44ba6047272082b1cd01bb5" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;find_first_of(basic_string_view(&lt;a href=&quot;../../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(c), 1), pos)&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;find_first_of(basic_string_view(&lt;a href=&quot;../../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(c), 1), pos)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="9674ff0260dd03e18d291dee2c45e380e71e253a" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;find_last_not_of(basic_string_view(&lt;a href=&quot;../../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(c), 1), pos)&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;find_last_not_of(basic_string_view(&lt;a href=&quot;../../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(c), 1), pos)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="82918e0271eb0a8635f88474edd49a31bb54aa2a" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;find_last_of(basic_string_view(&lt;a href=&quot;../../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(c), 1), pos)&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;find_last_of(basic_string_view(&lt;a href=&quot;../../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(c), 1), pos)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="1c350ec367be40f8310e2028486b59c2b8897f14" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;is_block_file(status(p))&lt;/code&gt; or &lt;code&gt;is_block_file(status(p, ec))&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;is_block_file(status(p))&lt;/code&gt; 또는 &lt;code&gt;is_block_file(status(p, ec))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59b41a4e1793e7b5873052e4eaac6f0a25509b7e" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;is_character_file(status(p))&lt;/code&gt; or &lt;code&gt;is_character_file(status(p, ec))&lt;/code&gt; respectively</source>
          <target state="translated">2) &lt;code&gt;is_character_file(status(p))&lt;/code&gt; 또는 &lt;code&gt;is_character_file(status(p, ec))&lt;/code&gt; 각각 동일</target>
        </trans-unit>
        <trans-unit id="2269978d66ed806c999c4747a07a231de8b46510" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;is_directory(status(p))&lt;/code&gt; or &lt;code&gt;is_directory(status(p, ec))&lt;/code&gt;, respectively.</source>
          <target state="translated">2) &lt;code&gt;is_directory(status(p))&lt;/code&gt; 또는 &lt;code&gt;is_directory(status(p, ec))&lt;/code&gt; 와 각각 동일합니다.</target>
        </trans-unit>
        <trans-unit id="0ec9180c62610785cdbeedfdd0e77a0379480905" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;is_fifo(status(p))&lt;/code&gt; or &lt;code&gt;is_fifo(status(p, ec))&lt;/code&gt; respectively</source>
          <target state="translated">2) &lt;code&gt;is_fifo(status(p))&lt;/code&gt; 또는 &lt;code&gt;is_fifo(status(p, ec))&lt;/code&gt; 각각 동일</target>
        </trans-unit>
        <trans-unit id="2a2b5db7ee3fc13869b7df008e84b43b4aefdc5c" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;is_other(status(p))&lt;/code&gt; or &lt;code&gt;is_other(status(p, ec))&lt;/code&gt;, respectively.</source>
          <target state="translated">2) &lt;code&gt;is_other(status(p))&lt;/code&gt; 또는 &lt;code&gt;is_other(status(p, ec))&lt;/code&gt; 와 각각 동일합니다.</target>
        </trans-unit>
        <trans-unit id="ea01ce67a6aedcb12ed9360cb6043100d0c51358" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;is_regular_file(status(p))&lt;/code&gt; or &lt;code&gt;is_regular_file(status(p, ec))&lt;/code&gt; respectively.</source>
          <target state="translated">2) &lt;code&gt;is_regular_file(status(p))&lt;/code&gt; 또는 &lt;code&gt;is_regular_file(status(p, ec))&lt;/code&gt; 각각 동일합니다.</target>
        </trans-unit>
        <trans-unit id="150795f8323774495dbabd2836f2867bfc66fab9" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;is_socket(status(p))&lt;/code&gt; or &lt;code&gt;is_socket(status(p, ec))&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;is_socket(status(p))&lt;/code&gt; 또는 &lt;code&gt;is_socket(status(p, ec))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80bd9b8715730a789ab422e33b30a46d3e375c2f" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;is_symlink(symlink_status(p))&lt;/code&gt; or &lt;code&gt;is_symlink(symlink_status(p, ec))&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;is_symlink(symlink_status(p))&lt;/code&gt; 또는 &lt;code&gt;is_symlink(symlink_status(p, ec))&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="36ea3dfef902d9ef95c1dd016a1dcf23f1728ed3" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;os &amp;lt;&amp;lt; &lt;a href=&quot;../year_month_day&quot;&gt;std::chrono::year_month_day&lt;/a&gt;(tp);&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;os &amp;lt;&amp;lt; &lt;a href=&quot;../year_month_day&quot;&gt;std::chrono::year_month_day&lt;/a&gt;(tp);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1c863db6ebf7aa423dad335d64830b8634022f0b" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;rep_ -= d.count(); return *this;&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;rep_ -= d.count(); return *this;&lt;/code&gt; )와 동일 ; return * this;</target>
        </trans-unit>
        <trans-unit id="d5c4e92e1d7514ad594ca159deeabaa80396b2aa" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;return !&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;(std::move(fd), &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;return !&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;(std::move(fd), &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt; 동일합니다 ! &lt;a href=&quot;invoke&quot;&gt;std :: invoke&lt;/a&gt; (std :: move (fd), &lt;a href=&quot;../forward&quot;&gt;std :: forward&lt;/a&gt; &amp;lt;Args&amp;gt; (args) ...)</target>
        </trans-unit>
        <trans-unit id="ec5d65cffc7a111069a485ec97dbc9dcbf56044a" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;return &lt;a href=&quot;../any&quot;&gt;std::any&lt;/a&gt;(&lt;a href=&quot;../in_place&quot;&gt;std::in_place_type&lt;/a&gt;&amp;lt;T&amp;gt;, il, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...);&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;return &lt;a href=&quot;../any&quot;&gt;std::any&lt;/a&gt;(&lt;a href=&quot;../in_place&quot;&gt;std::in_place_type&lt;/a&gt;&amp;lt;T&amp;gt;, il, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...);&lt;/code&gt; ( &lt;a href=&quot;../in_place&quot;&gt;std :: in_place_type&lt;/a&gt; &amp;lt;T&amp;gt;, il, &lt;a href=&quot;../forward&quot;&gt;std :: forward&lt;/a&gt; &amp;lt;Args&amp;gt; (args) ...) 를 반환하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="2cb9e7bd1380ba36489e3fbf21ce64985c2c1a8c" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;return D(-rep_);&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;return D(-rep_);&lt;/code&gt; 를 반환하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="c800cb0df64e4ddbe3d9ce796799158191218773" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;return duration(rep_++)&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;return duration(rep_++)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0ea4c3707fdc842663caec9034cd4b1cc9a840b2" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;return r.end();&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;return r.end();&lt;/code&gt; 를 반환하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="04d887ed9677e263adde97c662fcc99871d240b8" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;return time_point(d_++)&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;return time_point(d_++)&lt;/code&gt; 동일</target>
        </trans-unit>
        <trans-unit id="75d48d9b42cef790eac1b00f6f6ca6d3abd76957" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;return wait_until(lock, &lt;a href=&quot;../../chrono/steady_clock/now&quot;&gt;std::chrono::steady_clock::now&lt;/a&gt;() + rel_time, std::move(pred));&lt;/code&gt;. This overload may be used to ignore spurious awakenings.</source>
          <target state="translated">2) &lt;code&gt;return wait_until(lock, &lt;a href=&quot;../../chrono/steady_clock/now&quot;&gt;std::chrono::steady_clock::now&lt;/a&gt;() + rel_time, std::move(pred));&lt;/code&gt; 를 반환하는 것과 같습니다 . . 이 과부하는 가짜 각성을 무시하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f50c8cc46d2bc485771f2eaed66c2a454e98395" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;rfind(basic_string_view(&lt;a href=&quot;../../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(c), 1), pos)&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;rfind(basic_string_view(&lt;a href=&quot;../../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(c), 1), pos)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="ce03f4187fbc0ed788125c61b8f643748c60b67c" translate="yes" xml:space="preserve">
          <source>2) Equivalent to &lt;code&gt;substr(pos1, count1).compare(v)&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;substr(pos1, count1).compare(v)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93a2b774ace614a5aede2a093d44a656f7e08511" translate="yes" xml:space="preserve">
          <source>2) Equivalent to: &lt;code&gt;return b = b &amp;gt;&amp;gt; shift;&lt;/code&gt;</source>
          <target state="translated">2) 다음과 같습니다. &lt;code&gt;return b = b &amp;gt;&amp;gt; shift;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf1f91418c792cffc6ed6d6b423627197c8ebe8d" translate="yes" xml:space="preserve">
          <source>2) Equivalent to: &lt;code&gt;return l = l &amp;amp; r;&lt;/code&gt;.</source>
          <target state="translated">2) 다음과 같습니다 : &lt;code&gt;return l = l &amp;amp; r;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2ee65f78b5b07c471b7e2f49287c89558954cbe" translate="yes" xml:space="preserve">
          <source>2) Equivalent to: &lt;code&gt;return std::byte(static_cast&amp;lt;unsigned int&amp;gt;(b) &amp;gt;&amp;gt; shift);&lt;/code&gt;</source>
          <target state="translated">2) 다음과 같습니다. &lt;code&gt;return std::byte(static_cast&amp;lt;unsigned int&amp;gt;(b) &amp;gt;&amp;gt; shift);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="adada79ebec8da25323e9587fea94685b0850238" translate="yes" xml:space="preserve">
          <source>2) Equivalent to: &lt;code&gt;return std::byte(static_cast&amp;lt;unsigned int&amp;gt;(l) &amp;amp; static_cast&amp;lt;unsigned int&amp;gt;(r));&lt;/code&gt;.</source>
          <target state="translated">2) 다음과 같습니다. &lt;code&gt;return std::byte(static_cast&amp;lt;unsigned int&amp;gt;(l) &amp;amp; static_cast&amp;lt;unsigned int&amp;gt;(r));&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2ced019aba366fa49522afc16fd6e2fbf99a0a5" translate="yes" xml:space="preserve">
          <source>2) Erases all elements that satisfy the predicate &lt;code&gt;pred&lt;/code&gt; from the container. Equivalent to &lt;code&gt;c.erase(&lt;a href=&quot;../../algorithm/remove&quot;&gt;std::remove_if&lt;/a&gt;(c.begin(), c.end(), pred), c.end());&lt;/code&gt;</source>
          <target state="translated">2) 술어를 만족하는 모든 요소를 삭제한다 &lt;code&gt;pred&lt;/code&gt; 용기로부터한다. 당량 &lt;code&gt;c.erase(&lt;a href=&quot;../../algorithm/remove&quot;&gt;std::remove_if&lt;/a&gt;(c.begin(), c.end(), pred), c.end());&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe3a3c2b5a606a12c49f9974cad167e990ee4d88" translate="yes" xml:space="preserve">
          <source>2) Erases all elements that satisfy the predicate &lt;code&gt;pred&lt;/code&gt; from the container. Equivalent to &lt;code&gt;c.remove_if(pred);&lt;/code&gt;</source>
          <target state="translated">2) 술어를 만족하는 모든 요소를 삭제한다 &lt;code&gt;pred&lt;/code&gt; 용기로부터한다. &lt;code&gt;c.remove_if(pred);&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="bee0580245b01e8b1fae1719f67bb9a5b057cd63" translate="yes" xml:space="preserve">
          <source>2) Examines the expression expression</source>
          <target state="translated">2) 표현식을 조사</target>
        </trans-unit>
        <trans-unit id="829968da3c4c40a3134c1e03d71baa34165e76bc" translate="yes" xml:space="preserve">
          <source>2) Expands to a value suitable for use as the &lt;code&gt;base&lt;/code&gt; argument of &lt;code&gt;std::timespec_get&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;std::timespec_get&lt;/code&gt; 의 &lt;code&gt;base&lt;/code&gt; 인수 로 사용하기에 적합한 값으로 확장</target>
        </trans-unit>
        <trans-unit id="e471e661d14779c92f0a2da1ad07f5b16151b8eb" translate="yes" xml:space="preserve">
          <source>2) Explicit dynamic exception specification</source>
          <target state="translated">2) 명시 적 동적 예외 사양</target>
        </trans-unit>
        <trans-unit id="0b3ff06c6227e6b4bb394ae0ca75da3a9c05b5c0" translate="yes" xml:space="preserve">
          <source>2) Explicit instantiation declaration</source>
          <target state="translated">2) 명시 적 인스턴스화 선언</target>
        </trans-unit>
        <trans-unit id="7f97d89fd7e0716062279797d50f91a819ed772e" translate="yes" xml:space="preserve">
          <source>2) Explicit instantiation definition with template argument deduction for all parameters</source>
          <target state="translated">2) 모든 매개 변수에 대한 템플릿 인수 공제를 통한 명시 적 인스턴스화 정의</target>
        </trans-unit>
        <trans-unit id="dc43e6e37b67bd2b0ef6be8c095fd86c480ed1f8" translate="yes" xml:space="preserve">
          <source>2) Explicitly defaulted move assignment operator that move assigns the base class (&lt;code&gt;OuterAlloc&lt;/code&gt;, the outer allocator) and all inner allocators.</source>
          <target state="translated">2) 이동하는 기본적으로 지정된 이동 할당 연산자는 기본 클래스 ( &lt;code&gt;OuterAlloc&lt;/code&gt; , 외부 할당 자) 및 모든 내부 할당자를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="70d626e159cd5e68afd9714b689fd7f616a3f88c" translate="yes" xml:space="preserve">
          <source>2) Extracts characters from &lt;code&gt;input&lt;/code&gt; and appends them to &lt;code&gt;str&lt;/code&gt; until one of the following occurs (checked in the order listed)</source>
          <target state="translated">2) &lt;code&gt;input&lt;/code&gt; 에서 문자를 추출 하여 다음 중 하나가 발생할 때까지 &lt;code&gt;str&lt;/code&gt; 에 추가 합니다 (목록에 표시된 순서대로 확인).</target>
        </trans-unit>
        <trans-unit id="cd9c2ed56465291b53270fd9f62d1d84782b34ed" translate="yes" xml:space="preserve">
          <source>2) Finds the first character equal to none of characters in range &lt;code&gt;[s, s+count)&lt;/code&gt;. This range can include null characters.</source>
          <target state="translated">2) &lt;code&gt;[s, s+count)&lt;/code&gt; 범위의 문자가없는 첫 번째 문자를 찾습니다 . 이 범위에는 널 문자가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c58f7bdeb719709274224c5769b670484fc514b1" translate="yes" xml:space="preserve">
          <source>2) Finds the first character equal to one of the characters in the range &lt;code&gt;[s, s+count)&lt;/code&gt;. This range can include null characters.</source>
          <target state="translated">2) &lt;code&gt;[s, s+count)&lt;/code&gt; 범위의 문자 중 하나와 동일한 첫 번째 문자를 찾습니다 . 이 범위에는 널 문자가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95e9054590f6d06def5c92535387a8a08b799685" translate="yes" xml:space="preserve">
          <source>2) Finds the first substring equal to the range &lt;code&gt;[s, s+count)&lt;/code&gt;. This range may contain null characters.</source>
          <target state="translated">2) 범위 &lt;code&gt;[s, s+count)&lt;/code&gt; 동일한 첫 번째 부분 문자열을 찾습니다 . 이 범위에는 널 문자가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1276195c2ff2ebb65c69399fb550b424624d2d6d" translate="yes" xml:space="preserve">
          <source>2) Finds the last character equal to none of characters in the range &lt;code&gt;[s, s+count)&lt;/code&gt;. This range can include null characters.</source>
          <target state="translated">2) &lt;code&gt;[s, s+count)&lt;/code&gt; 범위의 문자가없는 마지막 문자를 찾습니다 . 이 범위에는 널 문자가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8414385ed123f578663d5a70ec1d5e3eaaa088a" translate="yes" xml:space="preserve">
          <source>2) Finds the last character equal to one of characters in range &lt;code&gt;[s, s+count)&lt;/code&gt;. This range can include null characters.</source>
          <target state="translated">2) &lt;code&gt;[s, s+count)&lt;/code&gt; 범위의 문자 중 하나와 동일한 마지막 문자를 찾습니다 . 이 범위에는 널 문자가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fed95888cf1ceba1cc3ad787ecc94c05f84d67b5" translate="yes" xml:space="preserve">
          <source>2) Finds the last substring equal to the range &lt;code&gt;[s, s+count)&lt;/code&gt;. This range can include null characters.</source>
          <target state="translated">2) 범위 &lt;code&gt;[s, s+count)&lt;/code&gt; 동일한 마지막 부분 문자열을 찾습니다 . 이 범위에는 널 문자가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e81924885cfe4bbb2644578e6d55786c6a7753a7" translate="yes" xml:space="preserve">
          <source>2) First, if either &lt;code&gt;T1&lt;/code&gt; or &lt;code&gt;T2&lt;/code&gt; is allocator-aware, modifies the tuples &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; to include &lt;code&gt;this-&amp;gt;resource()&lt;/code&gt;, resulting in the two new tuples &lt;code&gt;xprime&lt;/code&gt; and &lt;code&gt;yprime&lt;/code&gt;, according to the following three rules: 2a) if &lt;code&gt;T1&lt;/code&gt; is not allocator-aware (&lt;code&gt;&lt;a href=&quot;../uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&amp;lt;T1, polymorphic_allocator&amp;gt;::value==false&lt;/code&gt;) and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T1, Args1...&amp;gt;::value==true&lt;/code&gt;, then &lt;code&gt;xprime&lt;/code&gt; is &lt;code&gt;x&lt;/code&gt;, unmodified. 2b) if &lt;code&gt;T1&lt;/code&gt; is allocator-aware (&lt;code&gt;&lt;a href=&quot;../uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&amp;lt;T1, polymorphic_allocator&amp;gt;::value==true&lt;/code&gt;), and its constructor takes an allocator tag (&lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T1, &lt;a href=&quot;../allocator_arg_t&quot;&gt;std::allocator_arg_t&lt;/a&gt;, polymorphic_allocator, Args1...&amp;gt;::value==true&lt;/code&gt;, then &lt;code&gt;xprime&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../utility/tuple/tuple_cat&quot;&gt;std::tuple_cat&lt;/a&gt;(&lt;a href=&quot;../../utility/tuple/make_tuple&quot;&gt;std::make_tuple&lt;/a&gt;(&lt;a href=&quot;../allocator_arg&quot;&gt;std::allocator_arg&lt;/a&gt;, *this), std::move(x))&lt;/code&gt;2c) if &lt;code&gt;T1&lt;/code&gt; is allocator-aware (&lt;code&gt;&lt;a href=&quot;../uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&amp;lt;T1, polymorphic_allocator&amp;gt;::value==true&lt;/code&gt;), and its constructor takes the allocator as the last argument (&lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T1, Args1..., polymorphic_allocator&amp;gt;::value==true&lt;/code&gt;), then &lt;code&gt;xprime&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../utility/tuple/tuple_cat&quot;&gt;std::tuple_cat&lt;/a&gt;(std::move(x), &lt;a href=&quot;../../utility/tuple/make_tuple&quot;&gt;std::make_tuple&lt;/a&gt;(*this))&lt;/code&gt;. 2d) Otherwise, the program is ill-formed.  Same rules apply to &lt;code&gt;T2&lt;/code&gt; and the replacement of &lt;code&gt;y&lt;/code&gt; with &lt;code&gt;yprime&lt;/code&gt;.  Once &lt;code&gt;xprime&lt;/code&gt; and &lt;code&gt;yprime&lt;/code&gt; are constructed, constructs the pair &lt;code&gt;p&lt;/code&gt; in allocated storage as if by &lt;code&gt;::new((void *) p) pair&amp;lt;T1, T2&amp;gt;(&lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std::piecewise_construct&lt;/a&gt;, std::move(xprime), std::move(yprime));&lt;/code&gt;3) Equivalent to &lt;code&gt;construct(p, &lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std::piecewise_construct&lt;/a&gt;, &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;(), &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;())&lt;/code&gt;, that is, passes the memory resource on to the pair's member types if they accept them. 4) Equivalent to</source>
          <target state="translated">2) 먼저 &lt;code&gt;T1&lt;/code&gt; 또는 &lt;code&gt;T2&lt;/code&gt; 가 할당자를 인식하는 경우 튜플 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 를 수정하여 &lt;code&gt;this-&amp;gt;resource()&lt;/code&gt; 를 포함 하여 다음 세 가지 규칙에 따라 두 개의 새 튜플 &lt;code&gt;xprime&lt;/code&gt; 및 &lt;code&gt;yprime&lt;/code&gt; 을 생성합니다. 2a) &lt;code&gt;T1&lt;/code&gt; 인 경우 할당 인식 (아닌 &lt;code&gt;&lt;a href=&quot;../uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&amp;lt;T1, polymorphic_allocator&amp;gt;::value==false&lt;/code&gt; ) 및 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T1, Args1...&amp;gt;::value==true&lt;/code&gt; 다음 &lt;code&gt;xprime&lt;/code&gt; 이 있다 &lt;code&gt;x&lt;/code&gt; , 변성. 2b) &lt;code&gt;T1&lt;/code&gt; 이 할당자를 인식하는 경우 ( &lt;code&gt;&lt;a href=&quot;../uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&amp;lt;T1, polymorphic_allocator&amp;gt;::value==true&lt;/code&gt; ) 생성자는 할당 자 태그를 사용합니다 ( &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T1, &lt;a href=&quot;../allocator_arg_t&quot;&gt;std::allocator_arg_t&lt;/a&gt;, polymorphic_allocator, Args1...&amp;gt;::value==true&lt;/code&gt; 이면 &lt;code&gt;xprime&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;../../utility/tuple/tuple_cat&quot;&gt;std::tuple_cat&lt;/a&gt;(&lt;a href=&quot;../../utility/tuple/make_tuple&quot;&gt;std::make_tuple&lt;/a&gt;(&lt;a href=&quot;../allocator_arg&quot;&gt;std::allocator_arg&lt;/a&gt;, *this), std::move(x))&lt;/code&gt; 2c) &lt;code&gt;T1&lt;/code&gt; 이 할당자를 인식하는 경우 ( &lt;code&gt;&lt;a href=&quot;../uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&amp;lt;T1, polymorphic_allocator&amp;gt;::value==true&lt;/code&gt; ) 및 해당 생성자는 할당자를 마지막 인수 ( &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T1, Args1..., polymorphic_allocator&amp;gt;::value==true&lt;/code&gt; )로 사용합니다. 그러면 &lt;code&gt;xprime&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;../../utility/tuple/tuple_cat&quot;&gt;std::tuple_cat&lt;/a&gt;(std::move(x), &lt;a href=&quot;../../utility/tuple/make_tuple&quot;&gt;std::make_tuple&lt;/a&gt;(*this))&lt;/code&gt; . 2d) 그렇지 않으면 프로그램이 잘못 형성됩니다. 동일한 규칙이 &lt;code&gt;T2&lt;/code&gt; 에 적용되고 &lt;code&gt;y&lt;/code&gt; 를 &lt;code&gt;yprime&lt;/code&gt; 로 대체합니다. &lt;code&gt;xprime&lt;/code&gt; 과 &lt;code&gt;yprime&lt;/code&gt; 이 구성되면 &lt;code&gt;::new((void *) p) pair&amp;lt;T1, T2&amp;gt;(&lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std::piecewise_construct&lt;/a&gt;, std::move(xprime), std::move(yprime));&lt;/code&gt; &lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std :: piecewise_construct&lt;/a&gt; , std :: move (xprime), std :: 처럼 할당 된 저장소에쌍 &lt;code&gt;p&lt;/code&gt; 를구성합니다. 이동 (yprime)); 3) &lt;code&gt;construct(p, &lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std::piecewise_construct&lt;/a&gt;, &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;(), &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;())&lt;/code&gt; &lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std :: piecewise_construct&lt;/a&gt; , &lt;a href=&quot;../../utility/tuple&quot;&gt;std :: tuple&lt;/a&gt; &amp;lt;&amp;gt; (), &lt;a href=&quot;../../utility/tuple&quot;&gt;std :: tuple&lt;/a&gt; &amp;lt;&amp;gt; ())와 동일즉, 메모리 자원이 쌍의 구성원 유형을 승인하면이를 전달합니다. 4) 해당</target>
        </trans-unit>
        <trans-unit id="78f9e1146394243491e573a3a4ca791bc6537cb7" translate="yes" xml:space="preserve">
          <source>2) First, if either &lt;code&gt;T1&lt;/code&gt; or &lt;code&gt;T2&lt;/code&gt; is allocator-aware, modifies the tuples &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; to include the appropriate inner allocator, resulting in the two new tuples &lt;code&gt;xprime&lt;/code&gt; and &lt;code&gt;yprime&lt;/code&gt;, according to the following three rules: 2a) if &lt;code&gt;T1&lt;/code&gt; is not allocator-aware (&lt;code&gt;&lt;a href=&quot;../uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&amp;lt;T1, inner_allocator_type&amp;gt;::value==false&lt;/code&gt;, then &lt;code&gt;xprime&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;Args1&amp;amp;&amp;amp;...&amp;gt;(std::move(x))&lt;/code&gt;. (it is also required that &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T1, Args1...&amp;gt;::value==true&lt;/code&gt;) 2b) if &lt;code&gt;T1&lt;/code&gt; is allocator-aware (&lt;code&gt;&lt;a href=&quot;../uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&amp;lt;T1, inner_allocator_type&amp;gt;::value==true&lt;/code&gt;), and its constructor takes an allocator tag (&lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T1, &lt;a href=&quot;../allocator_arg_t&quot;&gt;std::allocator_arg_t&lt;/a&gt;, inner_allocator_type&amp;amp;, Args1...&amp;gt;::value==true&lt;/code&gt;), then &lt;code&gt;xprime&lt;/code&gt; is</source>
          <target state="translated">2) 먼저 &lt;code&gt;T1&lt;/code&gt; 또는 &lt;code&gt;T2&lt;/code&gt; 가 할당자를 인식 하는 경우 적절한 내부 할당자를 포함 하도록 튜플 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 를 수정 하여 다음 세 가지 규칙에 따라 두 개의 새로운 튜플 &lt;code&gt;xprime&lt;/code&gt; 및 &lt;code&gt;yprime&lt;/code&gt; 을 생성합니다. 2a) &lt;code&gt;T1&lt;/code&gt; 이 아닌 경우 할당 인식 ( &lt;code&gt;&lt;a href=&quot;../uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&amp;lt;T1, inner_allocator_type&amp;gt;::value==false&lt;/code&gt; 다음 &lt;code&gt;xprime&lt;/code&gt; IS &lt;code&gt;&lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;Args1&amp;amp;&amp;amp;...&amp;gt;(std::move(x))&lt;/code&gt; . (또한 필요가있다 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T1, Args1...&amp;gt;::value==true&lt;/code&gt; ) 2b) &lt;code&gt;T1&lt;/code&gt; 이 할당자를 인식하는 경우 ( &lt;code&gt;&lt;a href=&quot;../uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&amp;lt;T1, inner_allocator_type&amp;gt;::value==true&lt;/code&gt; ) 해당 생성자는 할당 자 태그를 사용합니다 ( &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T1, &lt;a href=&quot;../allocator_arg_t&quot;&gt;std::allocator_arg_t&lt;/a&gt;, inner_allocator_type&amp;amp;, Args1...&amp;gt;::value==true&lt;/code&gt; ) 그러면 &lt;code&gt;xprime&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="f750eb09525728be1e2225cbaacb1b8ee5d091be" translate="yes" xml:space="preserve">
          <source>2) Flips the bit at the position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">2) 위치 &lt;code&gt;pos&lt;/code&gt; 에서 비트를 뒤집습니다 .</target>
        </trans-unit>
        <trans-unit id="bc3ac26404449d1037c1c175e97b2ec737599779" translate="yes" xml:space="preserve">
          <source>2) Floating point value identifying the &amp;beta; parameter</source>
          <target state="translated">2) &amp;beta; 파라미터를 식별하는 부동 소수점 값</target>
        </trans-unit>
        <trans-unit id="116daa46583e048d9b1cb92d46f2c433ca1c5eb8" translate="yes" xml:space="preserve">
          <source>2) For all other non-local static and thread-local variables, &lt;a href=&quot;zero_initialization&quot;&gt;Zero initialization&lt;/a&gt; takes place. In practice, variables that are going to be zero-initialized are placed in the &lt;code&gt;.bss&lt;/code&gt; segment of the program image, which occupies no space on disk, and is zeroed out by the OS when loading the program.</source>
          <target state="translated">2) 다른 모든 로컬이 아닌 정적 및 스레드 로컬 변수의 경우 &lt;a href=&quot;zero_initialization&quot;&gt;0으로 초기화&lt;/a&gt; 됩니다. 실제로, 0으로 초기화 될 변수 는 프로그램 이미지 의 &lt;code&gt;.bss&lt;/code&gt; 세그먼트에 배치되며 디스크의 공간을 차지하지 않으며 프로그램을로드 할 때 OS에 의해 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="72ba90edba6dd274b21b2ecc972bd96a147f5405" translate="yes" xml:space="preserve">
          <source>2) For an object of a class &lt;a href=&quot;derived_class&quot;&gt;derived&lt;/a&gt; from X</source>
          <target state="translated">2) X에서 &lt;a href=&quot;derived_class&quot;&gt;파생 된&lt;/a&gt; 클래스의 객체</target>
        </trans-unit>
        <trans-unit id="09458e2fb4cb20ab5b783516479326a549edfe2b" translate="yes" xml:space="preserve">
          <source>2) For any dereferencable object &lt;code&gt;x&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; (that is, any value other than the end iterator), &lt;code&gt;*x&lt;/code&gt; satisfies the &lt;a href=&quot;swappable&quot;&gt;Swappable&lt;/a&gt; requirements.</source>
          <target state="translated">2) 유형 &lt;code&gt;T&lt;/code&gt; 의 역 참조 가능한 오브젝트 &lt;code&gt;x&lt;/code&gt; (즉, 엔드 반복자 이외의 다른 값)의 경우 &lt;code&gt;*x&lt;/code&gt; 는 &lt;a href=&quot;swappable&quot;&gt;스왑 가능&lt;/a&gt; 요구 사항을 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="26c2a9bef1b130ff8c790d0f3f9c59516399b08d" translate="yes" xml:space="preserve">
          <source>2) For arguments of class type (including union), the set consists of</source>
          <target state="translated">2) 클래스 유형의 인수 (조합 포함)의 경우</target>
        </trans-unit>
        <trans-unit id="00070242b0d0d129922583419fab1058114f0fbe" translate="yes" xml:space="preserve">
          <source>2) For every character in the character array &lt;code&gt;[low, high)&lt;/code&gt;, reads its full classification mask from the classification table returned by the member function &lt;code&gt;table()&lt;/code&gt; (that is, evaluates &lt;code&gt;table()[ (unsigned char)*p]&lt;/code&gt; and stores it in the corresponding element of the array pointed to by &lt;code&gt;vec&lt;/code&gt;</source>
          <target state="translated">2) 문자 배열에있는 모든 캐릭터 &lt;code&gt;[low, high)&lt;/code&gt; , 멤버 함수에 의해 리턴 된 분류 테이블의 전체 분류 마스크 판독 &lt;code&gt;table()&lt;/code&gt; (즉, 평가되는 &lt;code&gt;table()[ (unsigned char)*p]&lt;/code&gt; 및 점포 &lt;code&gt;vec&lt;/code&gt; 가 가리키는 배열의 해당 요소에</target>
        </trans-unit>
        <trans-unit id="cd234dc0956821144ff4101dbd00859ca15c8799" translate="yes" xml:space="preserve">
          <source>2) For user-defined floating-point literals,</source>
          <target state="translated">2) 사용자 정의 부동 소수점 리터럴의 경우</target>
        </trans-unit>
        <trans-unit id="7108f5abb0a7e1b90169aa7c6bab74cfacae4041" translate="yes" xml:space="preserve">
          <source>2) Forwards rvalues as rvalues and prohibits forwarding of rvalues as lvalues</source>
          <target state="translated">2) rvalue를 rvalue로 전달하고 rvalue를 lvalue로 전달하는 것을 금지합니다.</target>
        </trans-unit>
        <trans-unit id="9f0a198221ebee87af67a3c9579a0ac45be6424b" translate="yes" xml:space="preserve">
          <source>2) Function definitions, which both declare and define &lt;a href=&quot;member_functions&quot;&gt;member functions&lt;/a&gt; or &lt;a href=&quot;friend&quot;&gt;friend functions&lt;/a&gt;. A semicolon after a member function definition is optional. All functions that are defined inside a class body are automaticaly &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt;.</source>
          <target state="translated">2) 함수 정의- &lt;a href=&quot;member_functions&quot;&gt;멤버 함수&lt;/a&gt; 또는 &lt;a href=&quot;friend&quot;&gt;친구 함수를&lt;/a&gt; 선언하고 정의 합니다 . 멤버 함수 정의 뒤의 세미콜론은 선택 사항입니다. 클래스 본문 안에 정의 된 모든 함수는 자동으로 &lt;a href=&quot;inline&quot;&gt;인라인&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="9e7fd181539059be930917949d22d2453c85d2bd" translate="yes" xml:space="preserve">
          <source>2) Generalized sum of &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;binary_op2(*first,*first2)&lt;/code&gt;, &lt;code&gt;binary_op2(*(first+1),*(first2+1))&lt;/code&gt;, ..., over &lt;code&gt;binary_op1&lt;/code&gt;</source>
          <target state="translated">2) 일반화의 합 &lt;code&gt;init&lt;/code&gt; 하고 &lt;code&gt;binary_op2(*first,*first2)&lt;/code&gt; , &lt;code&gt;binary_op2(*(first+1),*(first2+1))&lt;/code&gt; , ... 위에 &lt;code&gt;binary_op1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26f7ad35e0dd505d5006d9de4d4bf8fd7322404e" translate="yes" xml:space="preserve">
          <source>2) If &lt;code&gt;&lt;a href=&quot;../concepts/assignable&quot;&gt;Assignable&lt;/a&gt;&amp;lt;T&amp;amp;, T&amp;gt;&lt;/code&gt; is not satisfied, the move assignment operator's body is equivalent to &lt;code&gt;if (other) emplace(std::move(*other)); else reset(); return *this;&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;&lt;a href=&quot;../concepts/assignable&quot;&gt;Assignable&lt;/a&gt;&amp;lt;T&amp;amp;, T&amp;gt;&lt;/code&gt; 가 충족되지 않으면 이동 할당 연산자의 본문은 &lt;code&gt;if (other) emplace(std::move(*other)); else reset(); return *this;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4fddc27598677720dcbaaef7b832b7b10c3de84f" translate="yes" xml:space="preserve">
          <source>2) If &lt;code&gt;&lt;a href=&quot;is_constructible&quot;&gt;std::is_trivially_constructible&lt;/a&gt;&amp;lt;T&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal to &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;&lt;a href=&quot;is_constructible&quot;&gt;std::is_trivially_constructible&lt;/a&gt;&amp;lt;T&amp;gt;::value&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우 멤버 상수 &lt;code&gt;value&lt;/code&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 제공 하고 그렇지 않으면 &lt;code&gt;value&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="50c9abfba5f4ae0e05e2bce89b859f19dfc2c7df" translate="yes" xml:space="preserve">
          <source>2) If &lt;code&gt;P&lt;/code&gt; is a cv-qualified type, the top-level cv-qualifiers are ignored for deduction.</source>
          <target state="translated">2) &lt;code&gt;P&lt;/code&gt; 가 cv-qualified 유형 인 경우 최상위 cv-qualifier는 공제를 위해 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="249742b5c5c127079489f078f04cc60784c20c98" translate="yes" xml:space="preserve">
          <source>2) If &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt; for some type &lt;code&gt;U&lt;/code&gt;, ignoring cv-qualification and referenceness, provides a member typedef &lt;code&gt;type&lt;/code&gt; that names &lt;code&gt;U&amp;amp;&lt;/code&gt;; otherwise, provides a member typedef &lt;code&gt;type&lt;/code&gt; that names &lt;code&gt;std::decay_t&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">2) 경우 &lt;code&gt;T&lt;/code&gt; 는 이다 &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt; 어떤 타입 &lt;code&gt;U&lt;/code&gt; , CV-자격 및 referenceness 무시 typedef에 구성원 제공 &lt;code&gt;type&lt;/code&gt; 의 이름을 &lt;code&gt;U&amp;amp;&lt;/code&gt; ; 그렇지 않으면 &lt;code&gt;std::decay_t&amp;lt;T&amp;gt;&lt;/code&gt; 라는 멤버 typedef &lt;code&gt;type&lt;/code&gt; 을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="0b329060b83b7f5b62070990f23a2f23b88d5b8d" translate="yes" xml:space="preserve">
          <source>2) If &lt;code&gt;T&lt;/code&gt; is an object type or a function type that has no cv- or ref- qualifier, provides a member typedef &lt;code&gt;type&lt;/code&gt; which is &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;, otherwise &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;T&lt;/code&gt; 가 cv- 또는 requalifier가없는 오브젝트 유형 또는 함수 유형 인 경우 &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; 인 멤버 typedef &lt;code&gt;type&lt;/code&gt; 을 제공하고 , 그렇지 않으면 &lt;code&gt;type&lt;/code&gt; 은 &lt;code&gt;T&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7d260bfd69b803a3ffe8b24185c696db613ac704" translate="yes" xml:space="preserve">
          <source>2) If &lt;code&gt;T&lt;/code&gt; is not a referenceable type (i.e., possibly cv-qualified &lt;code&gt;void&lt;/code&gt; or a function type with a</source>
          <target state="translated">2) &lt;code&gt;T&lt;/code&gt; 가 참조 가능한 유형이 아닌 경우 (예 : cv-qualified &lt;code&gt;void&lt;/code&gt; 또는</target>
        </trans-unit>
        <trans-unit id="f038a906dced17d49851bc58f532c603fdf940bb" translate="yes" xml:space="preserve">
          <source>2) If &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; point to, respectively, &lt;code&gt;x[i]&lt;/code&gt; and &lt;code&gt;x[j]&lt;/code&gt; of the same array object &lt;code&gt;x&lt;/code&gt; (for the purpose of &lt;a href=&quot;../language/operator_arithmetic#Additive_operators&quot;&gt;pointer arithmetic&lt;/a&gt;), returns a pointer to &lt;code&gt;x[i+(j-i)/2]&lt;/code&gt; where the division rounds towards zero. If &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; do not point to elements of the same array object, the behavior is undefined.</source>
          <target state="translated">2) &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 각각 같은 배열 객체 &lt;code&gt;x&lt;/code&gt; 의 &lt;code&gt;x[i]&lt;/code&gt; 와 &lt;code&gt;x[j]&lt;/code&gt; 를 &lt;a href=&quot;../language/operator_arithmetic#Additive_operators&quot;&gt;가리키는 경우 (포인터 산술&lt;/a&gt; 목적으로 ) &lt;code&gt;x[i+(j-i)/2]&lt;/code&gt; 대한 포인터를 반환 합니다. 나누기는 0으로 반올림합니다. 경우 와 &lt;code&gt;b&lt;/code&gt; 동일한 배열 객체의 요소를 가리 키지 않는 동작이 정의되지 않는다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d6b50a4bb7df4c365c5e3aa617c3984f5d96318d" translate="yes" xml:space="preserve">
          <source>2) If &lt;code&gt;bool(lhs) != bool(rhs)&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;bool(lhs) != bool(rhs)&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; 리턴 합니다</target>
        </trans-unit>
        <trans-unit id="e80fb9aa459abd14e04b2aa4883130d15a760d35" translate="yes" xml:space="preserve">
          <source>2) If &lt;code&gt;d &amp;lt;= 255&lt;/code&gt;, constructs a &lt;code&gt;day&lt;/code&gt; object holding the day value &lt;code&gt;d&lt;/code&gt;. Otherwise the value held is unspecified.</source>
          <target state="translated">2 &lt;code&gt;d &amp;lt;= 255&lt;/code&gt; 인 경우 , 일수 &lt;code&gt;d&lt;/code&gt; 를 보관 유지 하는 &lt;code&gt;day&lt;/code&gt; 객체를 구축합니다 . 그렇지 않으면 보유 된 값이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9422fcfa34ea4939ea33e20ba81dc1bc320276b1" translate="yes" xml:space="preserve">
          <source>2) If &lt;code&gt;decltype(&amp;amp;F::operator())&lt;/code&gt; is of the form &lt;code&gt;R(G::*)(A...)&lt;/code&gt; (optionally cv-qualified, optionally noexcept, optionally lvalue reference qualified) for some class type G, then the deduced type is &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&amp;lt;R(A...)&amp;gt;&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;&amp;amp;F::operator()&lt;/code&gt; is well-formed when treated as an unevaluated operand.</source>
          <target state="translated">2) 일부 클래스 유형 G에 대해 &lt;code&gt;decltype(&amp;amp;F::operator())&lt;/code&gt; 가 &lt;code&gt;R(G::*)(A...)&lt;/code&gt; (선택적으로 cv-qualified, 선택적으로 noexcept, lvalue 참조 규정) 추론 된 유형은 &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&amp;lt;R(A...)&amp;gt;&lt;/code&gt; 입니다. 이 과부하 는 평가되지 않은 피연산자로 취급 될 때 &lt;code&gt;&amp;amp;F::operator()&lt;/code&gt; 이 올바른 경우 에만 과부하 해결에 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="8fdb4460d0929c04fde7030877855f420259df1d" translate="yes" xml:space="preserve">
          <source>2) If &lt;code&gt;e&lt;/code&gt; calls a function implicitly (it's an operator expression and the operator is overloaded, it is a &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt; and the allocation function is overloaded, or it is a full expression and the destructor of a temporary is called), then the set is the set of that function. 3) If &lt;code&gt;e&lt;/code&gt; is a &lt;a href=&quot;throw&quot;&gt;throw-expression&lt;/a&gt;, the set is the exception that would be initialized by its operand, or the set of all types for the re-throwing throw-expression (with no operand) 4) If &lt;code&gt;e&lt;/code&gt; is a &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt; to a reference to a polymorphic type, the set consists of &lt;code&gt;&lt;a href=&quot;../types/bad_cast&quot;&gt;std::bad_cast&lt;/a&gt;&lt;/code&gt;5) If &lt;code&gt;e&lt;/code&gt; is a &lt;a href=&quot;typeid&quot;&gt;typeid&lt;/a&gt; applied to a polymorphic glvalue, the set consists of &lt;code&gt;&lt;a href=&quot;../types/bad_typeid&quot;&gt;std::bad_typeid&lt;/a&gt;&lt;/code&gt;6) If &lt;code&gt;e&lt;/code&gt; is a &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt; with a non-constant size, the set consists of &lt;code&gt;&lt;a href=&quot;../memory/new/bad_array_new_length&quot;&gt;std::bad_array_new_length&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;e&lt;/code&gt; 가 함축적으로 함수를 호출하는 경우 (연산자 표현식이고 연산자에 과부하가 걸리면 &lt;a href=&quot;new&quot;&gt;새로운 표현식&lt;/a&gt; 이고 할당 함수가 과부하되거나 전체 표현식이고 임시 소멸자가 호출 됨) set은 해당 기능의 집합입니다. 경우 3) &lt;code&gt;e&lt;/code&gt; A는 &lt;a href=&quot;throw&quot;&gt;스로인 식&lt;/a&gt; 의 집합 경우 피연산자에 의해 초기화 될 예외, 또는 전혀 피연산자 재 던지는 스로인 발현에 대한 모든 종류의 세트 () 4)이고 &lt;code&gt;e&lt;/code&gt; A는 &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast는이&lt;/a&gt; 하려면 다형성 유형에 대한 참조, 세트는 &lt;code&gt;&lt;a href=&quot;../types/bad_cast&quot;&gt;std::bad_cast&lt;/a&gt;&lt;/code&gt; 로 구성됩니다. 5) &lt;code&gt;e&lt;/code&gt; 가 &lt;a href=&quot;typeid&quot;&gt;typeid 인 경우&lt;/a&gt;다형 glvalue에 적용되는 세트는 &lt;code&gt;&lt;a href=&quot;../types/bad_typeid&quot;&gt;std::bad_typeid&lt;/a&gt;&lt;/code&gt; 로 구성됩니다. 6) &lt;code&gt;e&lt;/code&gt; 가 일정하지 않은 크기 의 &lt;a href=&quot;new&quot;&gt;새로운 표현식 인&lt;/a&gt; 경우, 세트는 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_array_new_length&quot;&gt;std::bad_array_new_length&lt;/a&gt;&lt;/code&gt; 로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="19f4e120bcd0971d9fffcf618329b7c083572f45" translate="yes" xml:space="preserve">
          <source>2) If &lt;code&gt;m &amp;lt;= 255&lt;/code&gt;, constructs a &lt;code&gt;month&lt;/code&gt; object holding the month value &lt;code&gt;m&lt;/code&gt;. Otherwise the value held is unspecified.</source>
          <target state="translated">2 &lt;code&gt;m &amp;lt;= 255&lt;/code&gt; 이면 월 값 &lt;code&gt;m&lt;/code&gt; 을 보유 하는 &lt;code&gt;month&lt;/code&gt; 객체를 구성합니다 . 그렇지 않으면 보유 된 값이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d9538a98a633af4f3486f5beead2a0272152897b" translate="yes" xml:space="preserve">
          <source>2) If &lt;code&gt;noexcept&lt;/code&gt; is used, expression must not be &lt;a href=&quot;noexcept&quot;&gt;potentially throwing&lt;/a&gt;;</source>
          <target state="translated">2) &lt;code&gt;noexcept&lt;/code&gt; 가 사용되면, 표현은 &lt;a href=&quot;noexcept&quot;&gt;잠재적으로 던져&lt;/a&gt; 지지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="1e238f01e4b5ac498c9b5b4a9dd75d416cfc53b1" translate="yes" xml:space="preserve">
          <source>2) If &lt;code&gt;other&lt;/code&gt; is empty, the constructed object is empty. Otherwise, equivalent to &lt;code&gt;any(&lt;a href=&quot;../in_place&quot;&gt;std::in_place_type&lt;/a&gt;&amp;lt;T&amp;gt;, &lt;a href=&quot;any_cast&quot;&gt;std::any_cast&lt;/a&gt;&amp;lt;const T&amp;amp;&amp;gt;(other))&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the type of the object contained in &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;other&lt;/code&gt; 가 비어 있으면 생성 된 개체가 비어 있습니다. 그렇지 않으면 &lt;code&gt;any(&lt;a href=&quot;../in_place&quot;&gt;std::in_place_type&lt;/a&gt;&amp;lt;T&amp;gt;, &lt;a href=&quot;any_cast&quot;&gt;std::any_cast&lt;/a&gt;&amp;lt;const T&amp;amp;&amp;gt;(other))&lt;/code&gt; 와 동일합니다. 여기서 &lt;code&gt;T&lt;/code&gt; 는 &lt;code&gt;other&lt;/code&gt; 에 포함 된 객체의 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="d4efadd5f02ce08a73ace3af184ebf114dc1fb93" translate="yes" xml:space="preserve">
          <source>2) If &lt;code&gt;y&lt;/code&gt; is in the range [-32767, 32767], constructs a &lt;code&gt;year&lt;/code&gt; object holding the year value &lt;code&gt;y&lt;/code&gt;. Otherwise the value held is unspecified.</source>
          <target state="translated">2) &lt;code&gt;y&lt;/code&gt; 가 [-32767, 32767] 범위에 있으면 연도 값 &lt;code&gt;y&lt;/code&gt; 를 보유한 &lt;code&gt;year&lt;/code&gt; 객체를 구성합니다 . 그렇지 않으면 보유 된 값이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="30e3231aae70f4fdd1f06c4da7881e99b8677cd8" translate="yes" xml:space="preserve">
          <source>2) If a &lt;a href=&quot;../language/except_spec&quot;&gt;dynamic exception specification&lt;/a&gt; is violated and &lt;code&gt;&lt;a href=&quot;exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; throws or rethrows an exception that still violates the exception specification, but the exception specification allows &lt;code&gt;std::bad_exception&lt;/code&gt;, &lt;code&gt;std::bad_exception&lt;/code&gt; is thrown.</source>
          <target state="translated">2) &lt;a href=&quot;../language/except_spec&quot;&gt;동적 예외 스펙&lt;/a&gt; 을 위반하고 &lt;code&gt;&lt;a href=&quot;exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; 가 여전히 예외 스펙을 위반하는 예외를 던지거나 다시 던지지 만 예외 스펙은 &lt;code&gt;std::bad_exception&lt;/code&gt; 허용 하고 &lt;code&gt;std::bad_exception&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cfdbd1e09d4899072fb8a33831390f14edbcc08a" translate="yes" xml:space="preserve">
          <source>2) If a key equivalent to &lt;code&gt;k&lt;/code&gt; already exists in the container, does nothing. Otherwise, behaves like &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt; except that the element is constructed as &lt;code&gt;value_type(std::piecewise_construct, std::forward_as_tuple(std::move(k)), std::forward_as_tuple(std::forward&amp;lt;Args&amp;gt;(args)...))&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;k&lt;/code&gt; 에 해당하는 키 가 컨테이너에 이미 존재하면 아무 것도 수행하지 않습니다. 그렇지 않으면 요소가 &lt;code&gt;value_type(std::piecewise_construct, std::forward_as_tuple(std::move(k)), std::forward_as_tuple(std::forward&amp;lt;Args&amp;gt;(args)...))&lt;/code&gt; 로 구성 &lt;a href=&quot;emplace&quot;&gt;된다는&lt;/a&gt; 점을 제외하고는 emplace 처럼 작동 합니다 . .))</target>
        </trans-unit>
        <trans-unit id="4a180f3feb30f29594e27bc81eeedb0853bc9383" translate="yes" xml:space="preserve">
          <source>2) If a non-empty source file does not end with a newline character after this step (whether it had no newline originally, or it ended with a backslash), the behavior is undefined(until C++11)a terminating newline character is added(since C++11).</source>
          <target state="translated">2) 비어 있지 않은 소스 파일이이 단계 이후에 줄 바꿈 문자로 끝나지 않는 경우 (원래 줄 바꿈이 없었거나 백 슬래시로 끝나 든) 동작은 정의되지 않습니다 (C ++ 11까지) 줄 바꿈 문자 C ++ 11부터 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="2c40f616df78cad13d856bc4dea97b5e0554827a" translate="yes" xml:space="preserve">
          <source>2) If an exception is thrown, &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; is called, unless the exception is one of the exceptions uses for transaction cancellation (see below) in which case the transaction is</source>
          <target state="translated">2) 예외가 발생 하면 예외가 트랜잭션 취소에 사용되는 예외 (아래 참조)가 아닌 한 &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5678c9d0032ea624135ad3e16084048ae8b3e28b" translate="yes" xml:space="preserve">
          <source>2) If expression evaluates to &lt;code&gt;true&lt;/code&gt;, the function is declared not to throw any exceptions.</source>
          <target state="translated">2) expression이 &lt;code&gt;true&lt;/code&gt; 로 평가 되면 함수는 예외를 발생시키지 않도록 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="89dd1c979020c5ce55ca94a31c96c2e62cd9ca1b" translate="yes" xml:space="preserve">
          <source>2) If more than one specialization matches, partial order rules are used to determine which specialization is more specialized. The most specialized specialization is used, if it is unique (if it is not unique, the program cannot be compiled)</source>
          <target state="translated">2) 하나 이상의 전문화가 일치하면 부분 화 규칙을 사용하여 어떤 전문화가 더 전문화되어 있는지 결정합니다. 고유 한 경우 가장 전문화 된 전문화가 사용됩니다 (고유하지 않은 경우 프로그램을 컴파일 할 수 없음)</target>
        </trans-unit>
        <trans-unit id="2be9ebdb779cbad013554f77293a96f3fe28bb99" translate="yes" xml:space="preserve">
          <source>2) If new_type is a pointer or reference to some class &lt;code&gt;D&lt;/code&gt; and the type of expression is a pointer or reference to its non-virtual base &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;static_cast&lt;/code&gt; performs a</source>
          <target state="translated">2) new_type이 클래스 &lt;code&gt;D&lt;/code&gt; 에 대한 포인터 또는 참조이고 표현식 유형이 가상이 아닌 기본 &lt;code&gt;B&lt;/code&gt; 에 대한 포인터 또는 참조 인 경우 &lt;code&gt;static_cast&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="c73611d9e6efb8883d936ae77456452121b574d9" translate="yes" xml:space="preserve">
          <source>2) If one operand is a null pointer constant, and the other is a pointer, the composite type is exactly the pointer type</source>
          <target state="translated">2) 한 피연산자가 널 포인터 상수이고 다른 피연산자가 포인터 인 경우 복합 유형은 정확히 포인터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="49d43a064818444b800399749be55cf504131f9e" translate="yes" xml:space="preserve">
          <source>2) If one pointer points to an element of an array, or to a subobject of the element of the array, and another pointer points one past the last element of the array, the latter pointer</source>
          <target state="translated">2) 하나의 포인터가 배열의 요소 또는 배열 요소의 하위 객체를 가리키고 다른 포인터가 배열의 마지막 요소를 지나서 가리키는 경우, 후자의 포인터</target>
        </trans-unit>
        <trans-unit id="1dccc7d167390b48d352c4a7266a53d50f621060" translate="yes" xml:space="preserve">
          <source>2) If the argument is an unparenthesized &lt;a href=&quot;name&quot;&gt;id-expression&lt;/a&gt; naming a &lt;a href=&quot;template_parameters#Non-type_template_parameter&quot;&gt;non-type template parameter&lt;/a&gt;, then decltype yields the type of the template parameter (after performing any necessary type deduction if the template parameter is declared with a placeholder type).</source>
          <target state="translated">2) 인수가 &lt;a href=&quot;template_parameters#Non-type_template_parameter&quot;&gt;유형&lt;/a&gt; 이 아닌 템플릿 매개 변수를 명명 하는 괄호로 묶이지 않은 &lt;a href=&quot;name&quot;&gt;id 식인&lt;/a&gt; 경우 decltype은 템플릿 매개 변수의 유형을 생성합니다 (템플릿 매개 변수가 자리 표시 자 유형으로 선언 된 경우 필요한 유형 공제를 수행 한 후).</target>
        </trans-unit>
        <trans-unit id="69f951d64908e2cc95fd18de23667a13dc411f2a" translate="yes" xml:space="preserve">
          <source>2) If the candidate function has less than &lt;code&gt;M&lt;/code&gt; parameters, but has an &lt;a href=&quot;variadic_arguments&quot;&gt;ellipsis parameter&lt;/a&gt;, it is viable.</source>
          <target state="translated">2) 후보 함수의 매개 변수 가 &lt;code&gt;M&lt;/code&gt; 보다 작지만 &lt;a href=&quot;variadic_arguments&quot;&gt;생략 매개 변수&lt;/a&gt; 가있는 경우 실행 가능합니다.</target>
        </trans-unit>
        <trans-unit id="63ba9a54175a72802a3d1b7c987fd40ef8cc0c6b" translate="yes" xml:space="preserve">
          <source>2) If the container has an element with key equivalent to &lt;code&gt;x&lt;/code&gt;, unlinks the node that contains that element from the container and returns a &lt;a href=&quot;../node_handle&quot;&gt;node handle&lt;/a&gt; that owns it. Otherwise, returns an empty node handle.</source>
          <target state="translated">2) 컨테이너에 &lt;code&gt;x&lt;/code&gt; 와 동등한 키를 가진 요소가있는 경우 컨테이너에서 해당 요소가 포함 된 노드를 연결 해제하고 해당 컨테이너 를 소유 한 &lt;a href=&quot;../node_handle&quot;&gt;노드 핸들&lt;/a&gt; 을 리턴 합니다. 그렇지 않으면 빈 노드 핸들을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fab33644fd685e9969c743288397786748d7b6ec" translate="yes" xml:space="preserve">
          <source>2) If the container has an element with key equivalent to &lt;code&gt;x&lt;/code&gt;, unlinks the node that contains the first such element from the container and returns a &lt;a href=&quot;../node_handle&quot;&gt;node handle&lt;/a&gt; that owns it. Otherwise, returns an empty node handle.</source>
          <target state="translated">2) 컨테이너에 &lt;code&gt;x&lt;/code&gt; 와 동등한 키를 가진 요소가있는 경우 컨테이너 에서 첫 번째 요소가 포함 된 노드를 연결 해제하고 해당 노드 를 소유 한 &lt;a href=&quot;../node_handle&quot;&gt;노드 핸들&lt;/a&gt; 을 리턴 합니다. 그렇지 않으면 빈 노드 핸들을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0fd4348d1ce9844d41201c3d65e45037d15ac5af" translate="yes" xml:space="preserve">
          <source>2) If the current output format is 12-hour, converts to 24-hour time. Otherwise no effects.</source>
          <target state="translated">2) 현재 출력 형식이 12 시간이면 24 시간으로 변환됩니다. 그렇지 않으면 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b70fd64ff36637aca9a567c988e6dad67c62c440" translate="yes" xml:space="preserve">
          <source>2) If the operand is a qualified name of a non-static member, e.g. &lt;code&gt;&amp;amp;C::member&lt;/code&gt;, the result is a prvalue &lt;a href=&quot;pointer#Pointers_to_member_functions&quot;&gt;pointer to member function&lt;/a&gt; or &lt;a href=&quot;pointer#Pointers_to_data_members&quot;&gt;pointer to data member&lt;/a&gt; of type &lt;code&gt;T&lt;/code&gt; in class &lt;code&gt;C&lt;/code&gt;. Note that neither &lt;code&gt;&amp;amp;member&lt;/code&gt; nor &lt;code&gt;C::member&lt;/code&gt; nor even &lt;code&gt;&amp;amp;(C::member)&lt;/code&gt; may be used to initialize a pointer to member.</source>
          <target state="translated">2) 피연산자가 비 정적 멤버의 규정 된 이름 (예 : &lt;code&gt;&amp;amp;C::member&lt;/code&gt; 인 경우 결과는 &lt;a href=&quot;pointer#Pointers_to_member_functions&quot;&gt;멤버 함수에&lt;/a&gt; 대한 prvalue 포인터 또는 클래스 &lt;code&gt;C&lt;/code&gt; 의 &lt;code&gt;T&lt;/code&gt; 유형의 &lt;a href=&quot;pointer#Pointers_to_data_members&quot;&gt;데이터 멤버에&lt;/a&gt; 대한 포인터 입니다. 도 있습니다 &lt;code&gt;&amp;amp;member&lt;/code&gt; 도 &lt;code&gt;C::member&lt;/code&gt; 도도 &lt;code&gt;&amp;amp;(C::member)&lt;/code&gt; 회원에 대한 포인터를 초기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="922aa7e93813ddd36c3b852a55164ae735372b82" translate="yes" xml:space="preserve">
          <source>2) If the pointers are pointers to function and point to the same function, then</source>
          <target state="translated">2) 포인터가 기능을 가리키는 포인터이고 동일한 기능을 가리키는 경우</target>
        </trans-unit>
        <trans-unit id="d4796e8b527ee8dbcc5d127d969657e2a4f68466" translate="yes" xml:space="preserve">
          <source>2) If the type is &quot;array of T&quot; or &quot;array of unknown bound of T&quot;, it is replaced by the type &quot;pointer to T&quot;</source>
          <target state="translated">2) 유형이 &quot;T의 배열&quot;또는 &quot;T의 알려지지 않은 경계의 배열&quot;인 경우 &quot;T에 대한 포인터&quot;유형으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="711e10ac055114101242dd58ed12a7a54416999b" translate="yes" xml:space="preserve">
          <source>2) If the value of expression is the null pointer value, the result is the null pointer value of type new_type.</source>
          <target state="translated">2) expression의 값이 널 포인터 값인 경우 결과는 new_type 유형의 널 포인터 값입니다.</target>
        </trans-unit>
        <trans-unit id="1ec40d7bec7b75de67828be691ab9ca73f6ffd69" translate="yes" xml:space="preserve">
          <source>2) If this &lt;code&gt;codecvt&lt;/code&gt; facet defines a conversion, translates the external characters from the source range &lt;code&gt;[from, from_end)&lt;/code&gt; to internal characters, placing the results in the subsequent locations starting at &lt;code&gt;to&lt;/code&gt;. Converts no more than &lt;code&gt;from_end - from&lt;/code&gt; external characters and writes no more than &lt;code&gt;to_end - to&lt;/code&gt; internal characters. Leaves &lt;code&gt;from_next&lt;/code&gt; and &lt;code&gt;to_next&lt;/code&gt; pointing one beyond the last element successfully converted.</source>
          <target state="translated">이 경우 2) &lt;code&gt;codecvt&lt;/code&gt; 의 면이 전환을 정의하는 소스 범위에서 외부 문자 변환 &lt;code&gt;[from, from_end)&lt;/code&gt; 후속 위치에 결과부터 배치, 내부 문자 &lt;code&gt;to&lt;/code&gt; . 외부 문자 &lt;code&gt;from_end - from&lt;/code&gt; 이하로 변환 하고 &lt;code&gt;to_end - to&lt;/code&gt; 이하 로 내부 문자로 씁니다 . 잎은 &lt;code&gt;from_next&lt;/code&gt; 및 &lt;code&gt;to_next&lt;/code&gt; 마지막 요소를 넘어 하나를 가리키는 성공적으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="b7e3f96d2f01ad2ad6b5d317b6ccff5b6511527b" translate="yes" xml:space="preserve">
          <source>2) If this &lt;code&gt;codecvt&lt;/code&gt; facet defines a conversion, translates the internal characters from the source range &lt;code&gt;[from, from_end)&lt;/code&gt; to external characters, placing the results in the subsequent locations starting at &lt;code&gt;to&lt;/code&gt;. Converts no more than &lt;code&gt;from_end - from&lt;/code&gt; internal characters and writes no more than &lt;code&gt;to_end - to&lt;/code&gt; external characters. Leaves &lt;code&gt;from_next&lt;/code&gt; and &lt;code&gt;to_next&lt;/code&gt; pointing one beyond the last element successfully converted.</source>
          <target state="translated">이 경우 2) &lt;code&gt;codecvt&lt;/code&gt; 의 면이 전환을 정의하는 소스 영역에서, 내부 변환 자 &lt;code&gt;[from, from_end)&lt;/code&gt; 시작되는 다음 위치에 배치 한 결과, 외부 자 &lt;code&gt;to&lt;/code&gt; . 내부 문자 &lt;code&gt;from_end - from&lt;/code&gt; 이하로 변환 &lt;code&gt;to_end - to&lt;/code&gt; 외부 문자로 to_end 이하를 씁니다 . 잎은 &lt;code&gt;from_next&lt;/code&gt; 및 &lt;code&gt;to_next&lt;/code&gt; 마지막 요소를 넘어 하나를 가리키는 성공적으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="f808c76db83092109280765bf870e9717677bb00" translate="yes" xml:space="preserve">
          <source>2) Implements &lt;code&gt;operator&amp;gt;&lt;/code&gt; in terms of &lt;code&gt;operator&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;operator&amp;lt;&lt;/code&gt; 측면에서 &lt;code&gt;operator&amp;gt;&lt;/code&gt; 를 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="08d0bf9a6f4db1f3e127b16b39fc1d2783806ea4" translate="yes" xml:space="preserve">
          <source>2) Implicitly declared copy constructor.</source>
          <target state="translated">2) 암시 적으로 선언 된 복사 생성자.</target>
        </trans-unit>
        <trans-unit id="cb7ba0ab0242f8cc00117f86cbb046ffbe9edf71" translate="yes" xml:space="preserve">
          <source>2) In a member function definition inside a class definition, &lt;code&gt;final&lt;/code&gt; may appear in virt-specifier-seq immediately after the declarator and just before function-body.</source>
          <target state="translated">2) 클래스 정의 내부의 멤버 함수 정의에서 &lt;code&gt;final&lt;/code&gt; 은 선언자 직후와 함수 본문 바로 앞에 virt-specifier-seq에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="798834a071773c066af49779aaf45cab9dda5b41" translate="yes" xml:space="preserve">
          <source>2) In a member function definition inside a class definition, &lt;code&gt;override&lt;/code&gt; may appear in virt-specifier-seq immediately after the declarator and just before function-body.</source>
          <target state="translated">2) 클래스 정의 내에 멤버 함수의 정의에서, &lt;code&gt;override&lt;/code&gt; 곧바로 선언자 후 바로 전에 함수 바디 VIRT 지정자-SEQ에 나타날 수있다.</target>
        </trans-unit>
        <trans-unit id="a80a89b419a3ac19add04cbe6b177d2557758cb6" translate="yes" xml:space="preserve">
          <source>2) Inequality operator for variants:</source>
          <target state="translated">2) 변형에 대한 불평등 연산자 :</target>
        </trans-unit>
        <trans-unit id="6b00a1137e6fb0cb9dcf6ef098c70ed857a43604" translate="yes" xml:space="preserve">
          <source>2) Inexact result: the delivered result differs from what would have been computed were both exponent range and precision unbounded.</source>
          <target state="translated">2) 부정확 한 결과 : 전달 된 결과는 지수 범위와 정밀도에 제한이없는 것으로 계산 된 것과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="7da307dc865c426b6c2b1e769dc4a23c7cb75ea6" translate="yes" xml:space="preserve">
          <source>2) Initialized the base class with the address of the underlying &lt;code&gt;&lt;a href=&quot;../strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; member, which is initialized in one of the two possible ways, both of which use a user-provided fixed-size array:</source>
          <target state="translated">2) 기본 &lt;code&gt;&lt;a href=&quot;../strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; 멤버 의 주소를 사용하여 기본 클래스를 초기화했습니다.이 두 가지 가능한 방법 중 하나로 초기화되며 둘 다 사용자 제공 고정 크기 배열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4dfd504babcd4cbc1b02824371f5edff40aca18e" translate="yes" xml:space="preserve">
          <source>2) Initialized the base class with the address of the underlying &lt;code&gt;&lt;a href=&quot;../strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; member, which is initialized in one of the two possible ways, both of which write to user-provided fixed-size array:</source>
          <target state="translated">2) 기본 &lt;code&gt;&lt;a href=&quot;../strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; 멤버 의 주소를 사용하여 기본 클래스를 초기화했습니다.이 두 가지 가능한 방법 중 하나로 초기화되며 둘 다 사용자 제공 고정 크기 배열에 씁니다.</target>
        </trans-unit>
        <trans-unit id="03895741d43f46318548c8264b2f25232eee364f" translate="yes" xml:space="preserve">
          <source>2) Initializes &lt;code&gt;base_&lt;/code&gt; with &lt;code&gt;std::move(base)&lt;/code&gt; and initializes &lt;code&gt;pred_&lt;/code&gt; with &lt;code&gt;std::move(pred)&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;std::move(base)&lt;/code&gt; &lt;code&gt;base_&lt;/code&gt; 를 초기화 하고 &lt;code&gt;std::move(pred)&lt;/code&gt; &lt;code&gt;pred_&lt;/code&gt; 를 초기화 합니다.</target>
        </trans-unit>
        <trans-unit id="52bf1819fb9220a85186b1c3ab790b490f14242b" translate="yes" xml:space="preserve">
          <source>2) Initializes &lt;code&gt;first&lt;/code&gt; with &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt; with &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">2)를 초기화 &lt;code&gt;first&lt;/code&gt; 와 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;second&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee122a1ff1b38a462c0b0356d5d9a2ecb74a335f" translate="yes" xml:space="preserve">
          <source>2) Initializes &lt;code&gt;r_&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(static_&amp;shy;cast&amp;lt;R&amp;amp;&amp;gt;(&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(t)))&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;&lt;a href=&quot;../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(static_&amp;shy;cast&amp;lt;R&amp;amp;&amp;gt;(&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(t)))&lt;/code&gt; (static_cast &amp;lt;R &amp;amp;&amp;gt; ( &lt;a href=&quot;../utility/forward&quot;&gt;std :: forward&lt;/a&gt; &amp;lt;T&amp;gt; (t)))로 &lt;code&gt;r_&lt;/code&gt; 를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="716e22f886ca6480e2e45e5a403ad50f3b2fcf0a" translate="yes" xml:space="preserve">
          <source>2) Initializes &lt;code&gt;value_&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt; and expects that &lt;code&gt;Bound&lt;/code&gt; is either &lt;code&gt;unreachable_&amp;shy;sentinel_&amp;shy;t&lt;/code&gt; (the default) or &lt;code&gt;Bound()&lt;/code&gt; is reachable from value. This constructor is used to create unbounded iota views, e.g. &lt;code&gt;iota(0)&lt;/code&gt; yields numbers 0,1,2..., infinitely.</source>
          <target state="translated">2)를 초기화는 &lt;code&gt;value_&lt;/code&gt; 으로 &lt;code&gt;value&lt;/code&gt; 있고 예상하는 &lt;code&gt;Bound&lt;/code&gt; 중 하나입니다 &lt;code&gt;unreachable_&amp;shy;sentinel_&amp;shy;t&lt;/code&gt; (기본값) 또는 &lt;code&gt;Bound()&lt;/code&gt; 값에서 도달 할 수있다. 이 생성자는 무한한 iota 뷰를 생성하는 데 사용됩니다. 예를 들어 &lt;code&gt;iota(0)&lt;/code&gt; 은 숫자 0,1,2 ...를 무한대로 산출합니다.</target>
        </trans-unit>
        <trans-unit id="4a3b72322a0da25c6ff2dfab6e8695134bc21d4a" translate="yes" xml:space="preserve">
          <source>2) Initializes the accumulator &lt;code&gt;acc&lt;/code&gt; with the initial value &lt;code&gt;init&lt;/code&gt; and then</source>
          <target state="translated">2) 초기 값 &lt;code&gt;init&lt;/code&gt; 로 누산기 &lt;code&gt;acc&lt;/code&gt; 를 초기화 한 다음</target>
        </trans-unit>
        <trans-unit id="55b08fde80eebdbe62ea1685864202f242e4bea5" translate="yes" xml:space="preserve">
          <source>2) Initializes the base or member named by class-or-identifier using &lt;a href=&quot;list_initialization&quot;&gt;list-initialization&lt;/a&gt; (which becomes &lt;a href=&quot;value_initialization&quot;&gt;value-initialization&lt;/a&gt; if the list is empty and &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate-initialization&lt;/a&gt; when initializing an aggregate)</source>
          <target state="translated">2) &lt;a href=&quot;list_initialization&quot;&gt;목록 초기화를&lt;/a&gt; 사용하여 클래스 또는 식별자로 명명 된 기본 또는 멤버를 초기화합니다 ( 목록이 비어 있으면 &lt;a href=&quot;value_initialization&quot;&gt;값이 초기화&lt;/a&gt; 되고 &lt;a href=&quot;aggregate_initialization&quot;&gt;집계를 초기화&lt;/a&gt; 할 때 집계가 초기화 됩니다)</target>
        </trans-unit>
        <trans-unit id="a292e83b8668fc97cb894176667fb331e5be63e1" translate="yes" xml:space="preserve">
          <source>2) Initializes the contained value by calling its constructor with &lt;code&gt;ilist, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; as parameters. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;U&amp;gt;&amp;amp;, Args&amp;amp;&amp;amp;...&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;ilist, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; 를 매개 변수로 사용 하여 생성자를 호출하여 포함 된 값을 초기화합니다 . &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;U&amp;gt;&amp;amp;, Args&amp;amp;&amp;amp;...&amp;gt;::value&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인경우이 과부하는 과부하 해결에만 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="81e515d730af5d255f0626be0ff08b9fb97308e4" translate="yes" xml:space="preserve">
          <source>2) Initializes the internal state by calling &lt;code&gt;init(sb)&lt;/code&gt;. The associated stream buffer is set to &lt;code&gt;sb&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;init(sb)&lt;/code&gt; 호출하여 내부 상태를 초기화합니다 . 연관된 스트림 버퍼는 &lt;code&gt;sb&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="5bf68ab1799bf7710d7efecb1d3c8b2315be30f3" translate="yes" xml:space="preserve">
          <source>2) Initializes the iterator and stores the value of &lt;code&gt;is.rdbuf()&lt;/code&gt; in a data member. If &lt;code&gt;is.rdbuf()&lt;/code&gt; is null, then end-of-stream iterator is constructed.</source>
          <target state="translated">2) 반복자를 초기화하고 &lt;code&gt;is.rdbuf()&lt;/code&gt; 값을 데이터 멤버에 저장합니다 . 경우 &lt;code&gt;is.rdbuf()&lt;/code&gt; NULL 인 후 엔드 스트림 반복자 구성된다.</target>
        </trans-unit>
        <trans-unit id="a9ecebdef53c47ef0b666ca6a6958c37bc361357" translate="yes" xml:space="preserve">
          <source>2) Initializes the iterator, stores the address of &lt;code&gt;stream&lt;/code&gt; in a data member, and performs the first read from the input stream to initialize the cached value data member.</source>
          <target state="translated">2) 반복자를 초기화하고, &lt;code&gt;stream&lt;/code&gt; 의 주소를 데이터 멤버에 저장하고 , 입력 스트림에서 첫 번째 읽기를 수행하여 캐시 된 값 데이터 멤버를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="0e77165ed4364b7e2ced2b634937f11b57c10c64" translate="yes" xml:space="preserve">
          <source>2) Initializes the underlying &lt;code&gt;shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; to a copy of &lt;code&gt;desired&lt;/code&gt;. As with any &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; type, initialization is not an atomic operation.</source>
          <target state="translated">2) 기본이되는 &lt;code&gt;shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; 를 &lt;code&gt;desired&lt;/code&gt; 복사본으로 초기화합니다 . 다른 &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; 유형 과 마찬가지로 초기화는 원 자성 작업이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="2c1cc42a473d4d618bdcfe2ae32728c9d908f900" translate="yes" xml:space="preserve">
          <source>2) Initializes the underlying &lt;code&gt;weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; to a copy of &lt;code&gt;desired&lt;/code&gt;. As with any &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; type, initialization is not an atomic operation.</source>
          <target state="translated">2) 기본 &lt;code&gt;weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; 를 &lt;code&gt;desired&lt;/code&gt; 복사본으로 초기화합니다 . 다른 &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; 유형 과 마찬가지로 초기화는 원 자성 작업이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e97c26217e45bfa8d71d0a28f335ddc68b0cf572" translate="yes" xml:space="preserve">
          <source>2) Initializes the underlying pointer to the container to &lt;code&gt;std::addressof(c)&lt;/code&gt; and the underlying iterator to &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">2) 컨테이너에 대한 기본 포인터를 &lt;code&gt;std::addressof(c)&lt;/code&gt; )로 초기화하고 기본 반복자를 &lt;code&gt;i&lt;/code&gt; 로 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="d39e9f092946dcab59235ec6fbc4f86f783bbb28" translate="yes" xml:space="preserve">
          <source>2) Initializes the underlying pointer to the container to &lt;code&gt;std::addressof(c)&lt;/code&gt;.</source>
          <target state="translated">2) 컨테이너에 대한 기본 포인터를 &lt;code&gt;std::addressof(c)&lt;/code&gt; )로 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="b19b5bd4d4cff70a487467292f19e4783b155b4b" translate="yes" xml:space="preserve">
          <source>2) Initializes the underlying value with &lt;code&gt;desired&lt;/code&gt;. The initialization is not atomic.</source>
          <target state="translated">2) &lt;code&gt;desired&lt;/code&gt; 기본 값을 초기화합니다 . 초기화는 원자 적이 지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a440afe30725f6b6349fd059c79ebdedfa11c981" translate="yes" xml:space="preserve">
          <source>2) Inserts a &lt;code&gt;value_type&lt;/code&gt; object constructed in-place from &lt;code&gt;&lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std::piecewise_construct&lt;/a&gt;, &lt;a href=&quot;../../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(std::move(key)), &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;()&lt;/code&gt; if the key does not exist.  This function is equivalent to &lt;code&gt;return this-&amp;gt;try_emplace(std::move(key)).first-&amp;gt;second;&lt;/code&gt;.(since C++17)</source>
          <target state="translated">2) 키가 존재하지 않으면 &lt;code&gt;&lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std::piecewise_construct&lt;/a&gt;, &lt;a href=&quot;../../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(std::move(key)), &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;()&lt;/code&gt; , &lt;a href=&quot;../../utility/tuple/forward_as_tuple&quot;&gt;std :: forward_as_tuple&lt;/a&gt; (std :: move (key)), &lt;a href=&quot;../../utility/tuple&quot;&gt;std :: tuple&lt;/a&gt; &amp;lt;&amp;gt; () 에서 제자리에 구성된 &lt;code&gt;value_type&lt;/code&gt; 객체를 삽입 합니다. 이 함수는 &lt;code&gt;return this-&amp;gt;try_emplace(std::move(key)).first-&amp;gt;second;&lt;/code&gt; . (C ++ 17부터)</target>
        </trans-unit>
        <trans-unit id="b293ba3a6ac0e80d16c59eef9bf941d11205808a" translate="yes" xml:space="preserve">
          <source>2) Inserts null-terminated character string pointed to by &lt;code&gt;s&lt;/code&gt; at the position &lt;code&gt;index&lt;/code&gt;. The length of the string is determined by the first null character using &lt;code&gt;Traits::length(s)&lt;/code&gt;.</source>
          <target state="translated">2) 위치 &lt;code&gt;index&lt;/code&gt; 에서 &lt;code&gt;s&lt;/code&gt; 가 가리키는 널 종료 문자열을 삽입합니다 . 문자열의 길이는 &lt;code&gt;Traits::length(s)&lt;/code&gt; 사용하여 첫 번째 널 문자로 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="d76331d640b50c27798e1b49848e274a872aaee2" translate="yes" xml:space="preserve">
          <source>2) It cannot be predefined and cannot be overloaded: effectively, the name &lt;code&gt;main&lt;/code&gt; in the global namespace is reserved for functions (although it can be used to name classes, namespaces, enumerations, and any entity in a non-global namespace, except that a function called &quot;main&quot; cannot be declared with C &lt;a href=&quot;language_linkage&quot;&gt;language linkage&lt;/a&gt; in any namespace(since C++17))</source>
          <target state="translated">2) 사전 정의 할 수 없으며 오버로드 할 수 없습니다. 효과적으로 전역 네임 스페이스의 &lt;code&gt;main&lt;/code&gt; 이름은 함수를 위해 예약되어 있습니다 (비록 네임 스페이스의 클래스, 네임 스페이스, 열거 및 모든 엔티티의 이름을 지정하는 데 사용될 수는 있지만) &quot;main&quot;이라는 함수는 네임 스페이스에서 C &lt;a href=&quot;language_linkage&quot;&gt;언어 연결&lt;/a&gt; 로 선언 할 수 없습니다 (C ++ 17부터).</target>
        </trans-unit>
        <trans-unit id="453f9f705f322b8d733941f50d8ac0ab7f37a7c4" translate="yes" xml:space="preserve">
          <source>2) It has the same address in every translation unit.</source>
          <target state="translated">2) 모든 번역 단위에서 동일한 주소를가집니다.</target>
        </trans-unit>
        <trans-unit id="8784b9bde9adb82c3ab0b17f707ffecbe4bae345" translate="yes" xml:space="preserve">
          <source>2) It may apply to the function declaration as a whole, in which case it indicates that the return value carries dependency to the evaluation of the function call expression.</source>
          <target state="translated">2) 함수 선언 전체에 적용될 수 있으며,이 경우 반환 값이 함수 호출 표현식의 평가에 종속됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="453bb8599f8f300de5f45171bc08268aafbc8e0f" translate="yes" xml:space="preserve">
          <source>2) Iterator one past the end of the path</source>
          <target state="translated">2) 경로 끝을 지나는 반복자</target>
        </trans-unit>
        <trans-unit id="5fe8bb1645ab18890513306f060a45e561ed0294" translate="yes" xml:space="preserve">
          <source>2) Let &lt;code&gt;s&lt;/code&gt; be a &lt;code&gt;&lt;a href=&quot;file_status&quot;&gt;std::filesystem::file_status&lt;/a&gt;&lt;/code&gt; determined as if by &lt;code&gt;status(p)&lt;/code&gt; or &lt;code&gt;status(p, ec)&lt;/code&gt; (symlinks are followed), respectively. Returns &lt;code&gt;exists(s)&lt;/code&gt;. The non-throwing overload calls &lt;code&gt;ec.clear()&lt;/code&gt; if &lt;code&gt;status_known(s)&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;s&lt;/code&gt; 를 각각 &lt;code&gt;status(p)&lt;/code&gt; 또는 &lt;code&gt;status(p, ec)&lt;/code&gt; (기호 링크가 따라 &lt;code&gt;&lt;a href=&quot;file_status&quot;&gt;std::filesystem::file_status&lt;/a&gt;&lt;/code&gt; 따라 결정된 std :: filesystem :: file_status 라고 하자 . &lt;code&gt;exists(s)&lt;/code&gt; 반환 합니다 . 비 투사 과부하는 &lt;code&gt;status_known(s)&lt;/code&gt; 경우 ec.clear ( &lt;code&gt;ec.clear()&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="96afcba02b63be41aa07786332f7c6c7d4224868" translate="yes" xml:space="preserve">
          <source>2) Linear in &lt;code&gt;count&lt;/code&gt;</source>
          <target state="translated">2) 선형 &lt;code&gt;count&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="48b4d7e55d3c0796361bca357803812cedb0482b" translate="yes" xml:space="preserve">
          <source>2) Linear in N</source>
          <target state="translated">2) N의 선형</target>
        </trans-unit>
        <trans-unit id="eece4ef8334aefabe8359de7711250bbb27e76dd" translate="yes" xml:space="preserve">
          <source>2) Linear in distance between &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;first&lt;/code&gt; 와 &lt;code&gt;last&lt;/code&gt; 거리의 선형</target>
        </trans-unit>
        <trans-unit id="a28324697dd064940de4d53cb7e663cab240158e" translate="yes" xml:space="preserve">
          <source>2) Linear in distance between &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;first&lt;/code&gt; 와 &lt;code&gt;last&lt;/code&gt; 사이의 거리가 선형입니다 .</target>
        </trans-unit>
        <trans-unit id="88a091f128a8254476bdcd67268f0b14db622ecc" translate="yes" xml:space="preserve">
          <source>2) Linear in the distance between &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;first&lt;/code&gt; 와 &lt;code&gt;last&lt;/code&gt; 사이의 거리에서 선형 .</target>
        </trans-unit>
        <trans-unit id="6fefdefb473579ecf43dcab71f86a8a80bc3ec10" translate="yes" xml:space="preserve">
          <source>2) Linear in the size of &lt;code&gt;*this&lt;/code&gt; unless the allocators do not compare equal and do not propagate, in which case linear in the size of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;</source>
          <target state="translated">2)의 크기가 선형 &lt;code&gt;*this&lt;/code&gt; 할당 자 동등 비교하지 않고 전파하지 않는 크기의 선형 경우에 &lt;code&gt;*this&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="12050a9529e46b1ec7f9d7a95a9ed49a6436381b" translate="yes" xml:space="preserve">
          <source>2) Literal operators with these parameter lists are the first-choice literal operator for user-defined integer literals</source>
          <target state="translated">2) 이러한 매개 변수 목록이있는 리터럴 연산자는 사용자 정의 정수 리터럴에 대한 첫 번째 리터럴 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="52a6dd8b5be6368f9c7561c71a217340c2c87547" translate="yes" xml:space="preserve">
          <source>2) Locates the first character in the character array &lt;code&gt;[beg, end)&lt;/code&gt; that does not satisfy the classification mask &lt;code&gt;m&lt;/code&gt;, that is, the first character &lt;code&gt;c&lt;/code&gt; such that &lt;code&gt;is(m, c)&lt;/code&gt; would return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">2) 문자 배열의 첫 번째 문자 검색합니다 &lt;code&gt;[beg, end)&lt;/code&gt; , 분류 마스크를 만족하지 않는 &lt;code&gt;m&lt;/code&gt; 이고, 첫 문자 &lt;code&gt;c&lt;/code&gt; 등 &lt;code&gt;is(m, c)&lt;/code&gt; 반환 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c50e21411e70f187df62a51e2b54a64a87c2ace9" translate="yes" xml:space="preserve">
          <source>2) Locates the first character in the character array &lt;code&gt;[beg, end)&lt;/code&gt; that satisfies the classification mask &lt;code&gt;m&lt;/code&gt;, that is, the first character &lt;code&gt;c&lt;/code&gt; such that &lt;code&gt;is(m, c)&lt;/code&gt; would return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">2) 분류 마스크 &lt;code&gt;m&lt;/code&gt; 을 만족 하는 문자 배열 &lt;code&gt;[beg, end)&lt;/code&gt; 에서 첫 번째 문자, 즉 &lt;code&gt;is(m, c)&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하는 첫 번째 문자 &lt;code&gt;c&lt;/code&gt; 를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="20b67c028a4d676a2704eef0589e1f28a2be878b" translate="yes" xml:space="preserve">
          <source>2) Logical AND</source>
          <target state="translated">2) 논리 AND</target>
        </trans-unit>
        <trans-unit id="5a9f16921d0896dac710e727aeb4a288daf7f3a7" translate="yes" xml:space="preserve">
          <source>2) Logical OR (&lt;code&gt;||&lt;/code&gt;). The value for the empty pack is &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">2) 논리 OR ( &lt;code&gt;||&lt;/code&gt; ). 빈 팩의 값이 &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aeaeda976006672396c59dec01999c31a4130850" translate="yes" xml:space="preserve">
          <source>2) Manages a dynamically-allocated array of objects (e.g. allocated with &lt;code&gt;new[]&lt;/code&gt;)</source>
          <target state="translated">2) 동적으로 할당 된 객체 배열을 관리합니다 (예 : &lt;code&gt;new[]&lt;/code&gt; 할당 )</target>
        </trans-unit>
        <trans-unit id="dfbe8129aa9d84d86ff8f9ea3013c9d2649dd3b7" translate="yes" xml:space="preserve">
          <source>2) Maximum size of contiguous memory to promote true sharing. Guaranteed to be at least &lt;code&gt;alignof(&lt;a href=&quot;../types/max_align_t&quot;&gt;std::max_align_t&lt;/a&gt;)&lt;/code&gt;</source>
          <target state="translated">2) 진정한 공유를 촉진하기위한 연속 메모리의 최대 크기. 적어도 &lt;code&gt;alignof(&lt;a href=&quot;../types/max_align_t&quot;&gt;std::max_align_t&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../types/max_align_t&quot;&gt;std :: max_align_t&lt;/a&gt; ) 임을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="7baba2bece2bbaf6ac0a3883d27d506329fd8b46" translate="yes" xml:space="preserve">
          <source>2) May throw &lt;code&gt;std::ios::failure&lt;/code&gt; when setting &lt;code&gt;failbit&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;failbit&lt;/code&gt; 설정 &lt;code&gt;std::ios::failure&lt;/code&gt; 있음</target>
        </trans-unit>
        <trans-unit id="285982f7a887221cb0a424420231372c7ad6247b" translate="yes" xml:space="preserve">
          <source>2) May throw any exception thrown by direct-initializing any T_i in &lt;code&gt;Types...&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;Types...&lt;/code&gt; 에서 T_i를 직접 초기화하여 예외를 throw 할 수 있습니다 ...</target>
        </trans-unit>
        <trans-unit id="972c4b08a2fc5f6737c9043194ec4746115a46e0" translate="yes" xml:space="preserve">
          <source>2) Modifying the past-the-end null terminator stored at &lt;code&gt;data()+size()&lt;/code&gt; to any value other than &lt;code&gt;CharT()&lt;/code&gt; has undefined behavior.</source>
          <target state="translated">2) &lt;code&gt;data()+size()&lt;/code&gt; 에 저장된 과거 널 종료 자를 &lt;code&gt;CharT()&lt;/code&gt; 이외의 다른 값으로 수정하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="da29bc57cff695556534976a51eed3c2f5eadfcd" translate="yes" xml:space="preserve">
          <source>2) Move assignment operator. Assigns the contents of &lt;code&gt;other&lt;/code&gt; using move semantics. &lt;code&gt;other&lt;/code&gt; is in valid, but unspecified state after the operation.</source>
          <target state="translated">2) 할당 연산자를 이동하십시오. 이동 의미론을 사용하여 &lt;code&gt;other&lt;/code&gt; 컨텐츠를 지정 합니다. &lt;code&gt;other&lt;/code&gt; 는 조작 후 유효하지만 지정되지 않은 상태입니다.</target>
        </trans-unit>
        <trans-unit id="e36539bea6a9d6f7080c396b56832bbe033f4967" translate="yes" xml:space="preserve">
          <source>2) Move assignment operator. Assigns the contents of &lt;code&gt;other&lt;/code&gt; using move semantics. &lt;code&gt;other&lt;/code&gt; is in valid, but unspecified state after the operation. Equivalent to &lt;code&gt;assign(other);&lt;/code&gt;.</source>
          <target state="translated">2) 할당 연산자를 이동하십시오. 이동 의미론을 사용하여 &lt;code&gt;other&lt;/code&gt; 컨텐츠를 지정 합니다. &lt;code&gt;other&lt;/code&gt; 는 조작 후 유효하지만 지정되지 않은 상태입니다. 등가 &lt;code&gt;assign(other);&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c960c0a4fae494d4065158c01a201f24ded55054" translate="yes" xml:space="preserve">
          <source>2) Move assignment operator. For all &lt;code&gt;i&lt;/code&gt;, assigns &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Ti&amp;gt;(get&amp;lt;i&amp;gt;(other))&lt;/code&gt; to &lt;code&gt;get&amp;lt;i&amp;gt;(*this)&lt;/code&gt;.</source>
          <target state="translated">2) 할당 연산자를 이동하십시오. 모든 &lt;code&gt;i&lt;/code&gt; 에 대해 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Ti&amp;gt;(get&amp;lt;i&amp;gt;(other))&lt;/code&gt; 를 &lt;code&gt;get&amp;lt;i&amp;gt;(*this)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="8cbded566d394ffc0341c142ce407f3ab4555da9" translate="yes" xml:space="preserve">
          <source>2) Move assignment operator. Replaces the contents of &lt;code&gt;*this&lt;/code&gt; with those of &lt;code&gt;other&lt;/code&gt;. The value of &lt;code&gt;other&lt;/code&gt; is unspecified after this operation. The complexity of this operation may be linear if T has non-trivial destructors, but is usually constant otherwise.</source>
          <target state="translated">2) 할당 연산자를 이동하십시오. &lt;code&gt;*this&lt;/code&gt; 의 내용 을 &lt;code&gt;other&lt;/code&gt; 의 내용으로 바꿉니다 . 이 조작 후에 &lt;code&gt;other&lt;/code&gt; 의 값 은 지정되지 않습니다. T가 중요하지 않은 소멸자를 갖는 경우이 연산의 복잡성은 선형 일 수 있지만, 그렇지 않으면 일반적으로 일정합니다.</target>
        </trans-unit>
        <trans-unit id="79f0837a912429286f2b2466a43a4a29b9d55870" translate="yes" xml:space="preserve">
          <source>2) Move assignment operator. Replaces the contents with those of &lt;code&gt;other&lt;/code&gt; using move semantics (i.e. the data in &lt;code&gt;other&lt;/code&gt; is moved from &lt;code&gt;other&lt;/code&gt; into this container). &lt;code&gt;other&lt;/code&gt; is in a valid but unspecified state afterwards. If &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::propagate_on_container_move_assignment::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the target allocator is replaced by a copy of the source allocator. If it is &lt;code&gt;false&lt;/code&gt; and the source and the target allocators do not compare equal, the target cannot take ownership of the source memory and must move-assign each element individually, allocating additional memory using its own allocator as needed. In any case, all elements originally present in &lt;code&gt;*this&lt;/code&gt; are either destroyed or replaced by elementwise move-assignment.</source>
          <target state="translated">2) 할당 연산자를 이동하십시오. 의 것과 내용 옮겨 &lt;code&gt;other&lt;/code&gt; 사용 이동 의미 (즉, 데이터의 &lt;code&gt;other&lt;/code&gt; 에서 이동 &lt;code&gt;other&lt;/code&gt; 컨테이너로). &lt;code&gt;other&lt;/code&gt; 는 유효하지만 지정되지 않은 상태입니다. 경우 &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::propagate_on_container_move_assignment::value&lt;/code&gt; 이다 &lt;code&gt;true&lt;/code&gt; 목표 할당은 소스 할당의 복사본에 의해 대체된다. 그것이 &lt;code&gt;false&lt;/code&gt; 이라면소스와 대상 할당자가 동일하게 비교되지 않으면, 대상은 소스 메모리의 소유권을 가질 수 없으며 필요에 따라 자체 할당자를 사용하여 추가 메모리를 할당하여 각 요소를 개별적으로 이동 할당해야합니다. 어쨌든 원래 &lt;code&gt;*this&lt;/code&gt; 존재하는 모든 요소 는 파괴되거나 요소 별 이동 할당으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="07e073b80e397dc3e197feadbf58df5cb33ebd11" translate="yes" xml:space="preserve">
          <source>2) Move assignment operator. Replaces the contents with those of &lt;code&gt;other&lt;/code&gt; using move semantics. Effectively calls &lt;code&gt;c = std::move(other.c); comp = std::move(other.comp);&lt;/code&gt;(implicitly declared)</source>
          <target state="translated">2) 할당 연산자를 이동하십시오. 이동 의미론을 사용하여 내용을 &lt;code&gt;other&lt;/code&gt; 내용으로 바꿉니다 . 효과적으로 &lt;code&gt;c = std::move(other.c); comp = std::move(other.comp);&lt;/code&gt; (내재적으로 선언)</target>
        </trans-unit>
        <trans-unit id="4c9626b4dad2b413161e342e57ae23b1463ad6d4" translate="yes" xml:space="preserve">
          <source>2) Move assignment operator. Replaces the contents with those of &lt;code&gt;other&lt;/code&gt; using move semantics. Effectively calls &lt;code&gt;c = std::move(other.c);&lt;/code&gt;(implicitly declared)</source>
          <target state="translated">2) 할당 연산자를 이동하십시오. 이동 의미론을 사용하여 내용을 &lt;code&gt;other&lt;/code&gt; 내용으로 바꿉니다 . 효과적으로 &lt;code&gt;c = std::move(other.c);&lt;/code&gt; (내재적으로 선언)</target>
        </trans-unit>
        <trans-unit id="0cfa13c7641c0314e87b4e1ef7f11ff8a254435f" translate="yes" xml:space="preserve">
          <source>2) Move assigns another stream object. Effectively calls &lt;code&gt;swap(rhs)&lt;/code&gt;. This move assignment operator is protected: it is called by the move assignment operators of the derived stream classes &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; which know how to properly move-assign the associated stream buffers.</source>
          <target state="translated">2) 이동은 다른 스트림 객체를 할당합니다. 효과적으로 &lt;code&gt;swap(rhs)&lt;/code&gt; 호출합니다 . 이 이동 할당 연산자는 보호됩니다. 연결된 스트림 버퍼를 올바르게 이동 할당하는 방법을 알고 있는 파생 스트림 클래스 &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; 의 이동 할당 연산자에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="f4b2463adb1d18c7ad8fb263ebfe028f62d0dc43" translate="yes" xml:space="preserve">
          <source>2) Move constructor. Constructs a &lt;code&gt;std::future&lt;/code&gt; with the shared state of &lt;code&gt;other&lt;/code&gt; using move semantics. After construction, &lt;code&gt;other.valid() == false&lt;/code&gt;.</source>
          <target state="translated">2) 생성자를 이동하십시오. 구축 &lt;code&gt;std::future&lt;/code&gt; 의 공유 상태로 &lt;code&gt;other&lt;/code&gt; 이용하여 이동 의미. 생성 후 &lt;code&gt;other.valid() == false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="deb52fe27d7bc1a27bbf6e9b569cbcef288f8a90" translate="yes" xml:space="preserve">
          <source>2) Move constructor. Constructs the thread object to represent the thread of execution that was represented by &lt;code&gt;other&lt;/code&gt;. After this call &lt;code&gt;other&lt;/code&gt; no longer represents a thread of execution.</source>
          <target state="translated">2) 생성자를 이동하십시오. &lt;code&gt;other&lt;/code&gt; 로 표현 된 실행 스레드를 나타내는 스레드 객체를 구성합니다 . 이 호출 후 &lt;code&gt;other&lt;/code&gt; 더 이상 실행 스레드를 나타내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ad9bacf9221a5f1d7950f5e6428ba4ea918cd891" translate="yes" xml:space="preserve">
          <source>2) Move constructor. Initializes the &lt;code&gt;shared_lock&lt;/code&gt; with the contents of &lt;code&gt;other&lt;/code&gt;. Leaves &lt;code&gt;other&lt;/code&gt; with no associated mutex.</source>
          <target state="translated">2) 생성자를 이동하십시오. 초기화 &lt;code&gt;shared_lock&lt;/code&gt; 의 내용과 &lt;code&gt;other&lt;/code&gt; . 연관된 뮤텍스가없는 &lt;code&gt;other&lt;/code&gt; 잎 .</target>
        </trans-unit>
        <trans-unit id="d3876b001a85ab596d4f0699791002d9d94bdd1f" translate="yes" xml:space="preserve">
          <source>2) Move constructor. Initializes the &lt;code&gt;unique_lock&lt;/code&gt; with the contents of &lt;code&gt;other&lt;/code&gt;. Leaves &lt;code&gt;other&lt;/code&gt; with no associated mutex.</source>
          <target state="translated">2) 생성자를 이동하십시오. &lt;code&gt;other&lt;/code&gt; 의 내용으로 &lt;code&gt;unique_lock&lt;/code&gt; 을 초기화합니다 . 연관된 뮤텍스가없는 &lt;code&gt;other&lt;/code&gt; 잎 .</target>
        </trans-unit>
        <trans-unit id="53e2db776d59faecc3e041d85a2a0120d78c51b5" translate="yes" xml:space="preserve">
          <source>2) Move-assigns a &lt;code&gt;shared_ptr&lt;/code&gt; from &lt;code&gt;r&lt;/code&gt;. After the assignment, &lt;code&gt;*this&lt;/code&gt; contains a copy of the previous state of &lt;code&gt;r&lt;/code&gt;, and &lt;code&gt;r&lt;/code&gt; is empty. Equivalent to &lt;code&gt;shared_ptr&amp;lt;T&amp;gt;(std::move(r)).swap(*this)&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;r&lt;/code&gt; 에서 &lt;code&gt;shared_ptr&lt;/code&gt; 을 이동 할당합니다 . 대입 후 &lt;code&gt;*this&lt;/code&gt; 에는 이전 상태 &lt;code&gt;r&lt;/code&gt; 의 사본 이 포함 되며 &lt;code&gt;r&lt;/code&gt; 은 비어 있습니다. 당량 &lt;code&gt;shared_ptr&amp;lt;T&amp;gt;(std::move(r)).swap(*this)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16b5bb3daa6d8d0f9856f5c5865267fe6555d80d" translate="yes" xml:space="preserve">
          <source>2) Moves the</source>
          <target state="translated">2) 이동</target>
        </trans-unit>
        <trans-unit id="f82fd7ce2efaf08a154edebee39b9cf89cc2824a" translate="yes" xml:space="preserve">
          <source>2) Moves the element pointed to by the iterator following &lt;code&gt;it&lt;/code&gt; from &lt;code&gt;other&lt;/code&gt; into &lt;code&gt;*this&lt;/code&gt;. The element is inserted after the element pointed to by &lt;code&gt;pos&lt;/code&gt;. Has no effect if &lt;code&gt;pos==it&lt;/code&gt; or if &lt;code&gt;pos==++it&lt;/code&gt;.</source>
          <target state="translated">2) 다음 반복기 가리키는 요소 이동 &lt;code&gt;it&lt;/code&gt; 으로부터 &lt;code&gt;other&lt;/code&gt; 에 &lt;code&gt;*this&lt;/code&gt; . 요소는 &lt;code&gt;pos&lt;/code&gt; 가 가리키는 요소 뒤에 삽입됩니다 . &lt;code&gt;pos==it&lt;/code&gt; 또는 &lt;code&gt;pos==++it&lt;/code&gt; 경우 에는 효과가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="369fa202d62b3b601ac2dbc123552078998a2c0e" translate="yes" xml:space="preserve">
          <source>2) N log(N) where &lt;code&gt;N = &lt;a href=&quot;../../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; in general, linear in &lt;code&gt;N&lt;/code&gt; if the range is already sorted by &lt;code&gt;value_comp()&lt;/code&gt;.</source>
          <target state="translated">2) N log (N) 여기서 &lt;code&gt;N = &lt;a href=&quot;../../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; , 범위가 이미 &lt;code&gt;value_comp()&lt;/code&gt; 정렬되어 있으면 &lt;code&gt;N&lt;/code&gt; 에 선형입니다 .</target>
        </trans-unit>
        <trans-unit id="054c9750a31772f9ccd8e986051bf89ae9295be7" translate="yes" xml:space="preserve">
          <source>2) Negates the argument</source>
          <target state="translated">2) 논쟁을 부정한다</target>
        </trans-unit>
        <trans-unit id="63ded3a314f3205efda2212c57ab2817ee510429" translate="yes" xml:space="preserve">
          <source>2) Nothing if &lt;code&gt;R&lt;/code&gt; is (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;; otherwise the value returned by the selected invocation of the visitor, implicitly converted to &lt;code&gt;R&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;R&lt;/code&gt; 이 (cv-cv-qualified) &lt;code&gt;void&lt;/code&gt; 인 경우 아무것도 없습니다 . 그렇지 않으면 방문자의 선택된 호출에 의해 리턴 된 값은 내재적으로 &lt;code&gt;R&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="77530693ab86a694afdaf91f032621eda75d860d" translate="yes" xml:space="preserve">
          <source>2) Number of elements with key that compares equivalent to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;x&lt;/code&gt; 와 동등한 키를 가진 요소의 수 .</target>
        </trans-unit>
        <trans-unit id="d6d4caa30f400df5c605f36f4bd22787892bb28f" translate="yes" xml:space="preserve">
          <source>2) Obtains a message from the open message catalog &lt;code&gt;cat&lt;/code&gt; using the values &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;msgid&lt;/code&gt; and &lt;code&gt;dfault&lt;/code&gt; in implementation-defined manner. If the expected message is not found in the catalog, returns a copy of &lt;code&gt;dfault&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;set&lt;/code&gt; , &lt;code&gt;msgid&lt;/code&gt; 및 &lt;code&gt;dfault&lt;/code&gt; 값 을 구현 정의 방식으로 사용하여 열린 메시지 카탈로그 &lt;code&gt;cat&lt;/code&gt; 에서 메시지를 얻 습니다. 카탈로그에 예상 메시지가 없으면 &lt;code&gt;dfault&lt;/code&gt; 사본을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="c643382694ebd5631200a598631d81ad926eec16" translate="yes" xml:space="preserve">
          <source>2) Obtains a value of type &lt;code&gt;catalog&lt;/code&gt; (inherited from &lt;code&gt;&lt;a href=&quot;../messages_base&quot;&gt;std::messages_base&lt;/a&gt;&lt;/code&gt;), which can be passed to &lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; to retrieve messages from the message catalog named by &lt;code&gt;name&lt;/code&gt;. This value is usable until passed to &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;name&lt;/code&gt; 으로 이름이 지정된 메시지 카탈로그에서 메시지를 검색 하기 &lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; 으로 전달 될 수있는 &lt;code&gt;catalog&lt;/code&gt; 유형 ( &lt;code&gt;&lt;a href=&quot;../messages_base&quot;&gt;std::messages_base&lt;/a&gt;&lt;/code&gt; 에서 상 속됨 )의 값 을 가져옵니다 . 이 값은 &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; 전달 될 때까지 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="479dfeac8ea68fd96d5cd2083b75ed27ceb696b3" translate="yes" xml:space="preserve">
          <source>2) Octal integer literal (base 8, the first digit is the most significant)</source>
          <target state="translated">2) 8 진 정수 리터럴 (기수 8, 첫 번째 숫자가 가장 중요)</target>
        </trans-unit>
        <trans-unit id="14e556c2bbc89528d34020b0e1e9d25e48e71a8f" translate="yes" xml:space="preserve">
          <source>2) Often known as &quot;C++-style&quot; or &quot;single-line&quot; comments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbeb162c2fa8dbbbd6f7c7edc0a767ad0a2ef678" translate="yes" xml:space="preserve">
          <source>2) Otherwise, &lt;code&gt;(void)ranges::swap_ranges(t, u)&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; are lvalue references to array types of equal extent (but possibly different element types) and &lt;code&gt;&lt;a href=&quot;swap&quot;&gt;ranges::swap&lt;/a&gt;(*t, *u)&lt;/code&gt; is a valid expression;</source>
          <target state="translated">2) 그렇지 않으면 &lt;code&gt;(void)ranges::swap_ranges(t, u)&lt;/code&gt; , 만약 &lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;U&lt;/code&gt; 가 같은 범위의 배열 유형에 대한 lvalue 참조 (그러나 다른 요소 유형일 수 있음)이고 &lt;code&gt;&lt;a href=&quot;swap&quot;&gt;ranges::swap&lt;/a&gt;(*t, *u)&lt;/code&gt; 는 유효한 표현;</target>
        </trans-unit>
        <trans-unit id="770074e280f9b2c1ef8e44cc4c033123e3bd0fa0" translate="yes" xml:space="preserve">
          <source>2) Otherwise, if &lt;code&gt;E2&lt;/code&gt; or &lt;code&gt;E3&lt;/code&gt; are glvalue bit-fields of the same value category and of types cv1 T and cv2 T, respectively, the operands are considered to be of type cv T for the remainder of this section, where cv is the union of cv1 and cv2.</source>
          <target state="translated">2) 그렇지 않으면, &lt;code&gt;E2&lt;/code&gt; 또는 &lt;code&gt;E3&lt;/code&gt; 이 각각 동일한 값 범주와 유형 cv1 T 및 cv2 T의 glvalue 비트 필드 인 경우 피연산자는이 섹션의 나머지 부분에 대해 cv T 유형으로 간주됩니다. 여기서 cv는 cv1과 cv2의 결합</target>
        </trans-unit>
        <trans-unit id="248379455fbaf8aac5f7638f2912df17d56128c7" translate="yes" xml:space="preserve">
          <source>2) Otherwise, if &lt;code&gt;pptr() &amp;gt; egptr()&lt;/code&gt; (some characters were inserted into the stream since the last time &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; changed &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;egptr()&lt;/a&gt;&lt;/code&gt;) then extends the end of the get area to include the most recently inserted characters, by changing &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;egptr()&lt;/a&gt;&lt;/code&gt; to equal &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;pptr()&lt;/a&gt;&lt;/code&gt;, and then returns &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt;</source>
          <target state="translated">2) 그렇지 않으면 &lt;code&gt;pptr() &amp;gt; egptr()&lt;/code&gt; (최종 시간 &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;egptr()&lt;/a&gt;&lt;/code&gt; 변경 한 이후 일부 문자가 스트림에 삽입 된 경우 ) 인 경우 변경 하여 가장 최근에 삽입 된 문자를 포함하도록 get 영역의 끝을 확장합니다. &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;egptr()&lt;/a&gt;&lt;/code&gt; 같음 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;pptr()&lt;/a&gt;&lt;/code&gt; , 다음 반환 &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="304dba1f36dea4545c5999bd313e8b585f279ad0" translate="yes" xml:space="preserve">
          <source>2) Otherwise, if only one of two pointers to member is the null member pointer value, they compare unequal.</source>
          <target state="translated">2) 그렇지 않으면 멤버에 대한 두 개의 포인터 중 하나만 널 멤버 포인터 값인 경우 서로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="bd74eeea976354173bf007b70a293f2b1fe0e9fb" translate="yes" xml:space="preserve">
          <source>2) Otherwise, if the put area has a write position available (&lt;code&gt;pptr() &amp;lt; epptr()&lt;/code&gt;), stores the character as if by &lt;code&gt;*pptr()++ = c&lt;/code&gt;</source>
          <target state="translated">2) 그렇지 않으면, 넣기 영역에 사용 가능한 쓰기 위치가있는 경우 ( &lt;code&gt;pptr() &amp;lt; epptr()&lt;/code&gt; ), &lt;code&gt;*pptr()++ = c&lt;/code&gt; 처럼 문자를 저장합니다</target>
        </trans-unit>
        <trans-unit id="47bd6f57ba59386f0cb5dc719701e04235155006" translate="yes" xml:space="preserve">
          <source>2) Otherwise, the new offset &lt;code&gt;newoff&lt;/code&gt; (of type &lt;code&gt;off_type&lt;/code&gt;) is determined by calling &lt;code&gt;sp.offset()&lt;/code&gt;. If &lt;code&gt;newoff&lt;/code&gt; is negative, out of bounds of the buffer, or invalid, the operation fails.</source>
          <target state="translated">2) 그렇지 않으면 &lt;code&gt;sp.offset()&lt;/code&gt; 을 호출 하여 새 오프셋 &lt;code&gt;newoff&lt;/code&gt; ( &lt;code&gt;off_type&lt;/code&gt; 유형 )가 결정됩니다 . 경우 &lt;code&gt;newoff&lt;/code&gt; 이 부정적이며, 버퍼, 또는 무효의 범위에서 작업이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="582620872750251801a26dee497004cb461b4ff3" translate="yes" xml:space="preserve">
          <source>2) Parses one conversion specifier from the input sequence &lt;code&gt;[beg, end)&lt;/code&gt; and updates the &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; structure pointed to by &lt;code&gt;t&lt;/code&gt; accordingly.</source>
          <target state="translated">2) 입력 시퀀스 &lt;code&gt;[beg, end)&lt;/code&gt; 에서 하나의 변환 지정자를 구문 분석 하고 이에 따라 &lt;code&gt;t&lt;/code&gt; 가 가리키는 &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; 구조를 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="e3f7f7a08b37612cad7d06c4a8dcc301ac8dea95" translate="yes" xml:space="preserve">
          <source>2) Partial specializations &lt;code&gt;std::atomic&amp;lt;T*&amp;gt;&lt;/code&gt; for all pointer types. These specializations have standard layout, trivial default constructors, and trivial destructors. Besides the operations provided for all atomic types, these specializations additionally support atomic arithmetic operations appropriate to pointer types, such as &lt;a href=&quot;atomic/fetch_add&quot;&gt;&lt;code&gt;fetch_add&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic/fetch_sub&quot;&gt;&lt;code&gt;fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">2) 모든 포인터 유형에 대한 부분 전문화 &lt;code&gt;std::atomic&amp;lt;T*&amp;gt;&lt;/code&gt; 이러한 전문화에는 표준 레이아웃, 사소한 기본 생성자 및 사소한 소멸자가 있습니다. 모든 원자 유형에 제공되는 연산 외에도 이러한 전문화는 &lt;a href=&quot;atomic/fetch_add&quot;&gt; &lt;code&gt;fetch_add&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;atomic/fetch_sub&quot;&gt; &lt;code&gt;fetch_sub&lt;/code&gt; &lt;/a&gt; 와 같은 포인터 유형에 적합한 원자 산술 연산을 추가로 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="b2cbbe03ea21825f998df511abca6c0a96ac775e" translate="yes" xml:space="preserve">
          <source>2) Performs &lt;code&gt;*this = *this - d;&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;*this = *this - d;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a0dbe329721678e9c229ede24162184d19cc465e" translate="yes" xml:space="preserve">
          <source>2) Performs &lt;code&gt;*this = *this - m;&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;*this = *this - m;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc38edd2e57c04815138bfbe9eae3f282f0a7fb8" translate="yes" xml:space="preserve">
          <source>2) Performs atomic post-increment. Equivalent to &lt;code&gt;fetch_add(1)&lt;/code&gt;.</source>
          <target state="translated">2) 원자 적 후행 증가를 수행합니다. 등가 &lt;code&gt;fetch_add(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54fb42b4b0b51a8af5d718c5e7a0f2d7f8450a82" translate="yes" xml:space="preserve">
          <source>2) Performs atomic post-increment. Equivalent to &lt;code&gt;return fetch_add(1);&lt;/code&gt;.</source>
          <target state="translated">2) 원자 적 후행 증가를 수행합니다. &lt;code&gt;return fetch_add(1);&lt;/code&gt; 을 반환하는 것과 같습니다 . .</target>
        </trans-unit>
        <trans-unit id="781ad83f1b43a943718227baf0e5d9bab592b597" translate="yes" xml:space="preserve">
          <source>2) Performs atomic subtraction. Equivalent to &lt;code&gt;fetch_sub(arg)&lt;/code&gt; - arg.</source>
          <target state="translated">2) 원자 뺄셈을 수행합니다. &lt;code&gt;fetch_sub(arg)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="49cf7dc65ae430fc1cbee009c99df880278e958e" translate="yes" xml:space="preserve">
          <source>2) Performs atomic subtraction. Equivalent to &lt;code&gt;return fetch_sub(arg) - arg;&lt;/code&gt;.</source>
          <target state="translated">2) 원자 뺄셈을 수행합니다. &lt;code&gt;return fetch_sub(arg) - arg;&lt;/code&gt; 를 반환하는 것과 같습니다 . .</target>
        </trans-unit>
        <trans-unit id="26d9bd7248ead493ad68fe92d27bd4d34dc914f3" translate="yes" xml:space="preserve">
          <source>2) Pointer to the &lt;a href=&quot;../directory_entry&quot;&gt;&lt;code&gt;directory_entry&lt;/code&gt;&lt;/a&gt; referred to by this iterator</source>
          <target state="translated">2) 이 반복자가 참조 하는 &lt;a href=&quot;../directory_entry&quot;&gt; &lt;code&gt;directory_entry&lt;/code&gt; 의&lt;/a&gt; 포인터</target>
        </trans-unit>
        <trans-unit id="1aafee59fce3dec7247bdc2be06cbd7f442152ad" translate="yes" xml:space="preserve">
          <source>2) Post-increment. Returns the old value of the iterator.</source>
          <target state="translated">2) 증분 후. 반복자의 이전 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0ef28a366ae720bd63c806de1a4c2b0cac08ff33" translate="yes" xml:space="preserve">
          <source>2) Public member function, calls the member function &lt;code&gt;do_neg_format&lt;/code&gt; of the most derived class.</source>
          <target state="translated">2) 공용 멤버 함수, 가장 파생 된 클래스 의 멤버 함수 &lt;code&gt;do_neg_format&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="ff1f346c8d05de3c2ef41811605010f4cc7f5f05" translate="yes" xml:space="preserve">
          <source>2) Public member function, calls the member function &lt;code&gt;do_negative_sign&lt;/code&gt; of the most derived class.</source>
          <target state="translated">2) 공용 멤버 함수, 가장 파생 된 클래스 의 멤버 함수 &lt;code&gt;do_negative_sign&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="e683421166f5d455119eccfe1ddf017a85dcbc75" translate="yes" xml:space="preserve">
          <source>2) Range constructor. Constructs the container with the contents of the range &lt;code&gt;[first, last)&lt;/code&gt;. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending &lt;a href=&quot;http://wg21.link/lwg2844&quot;&gt;LWG2844&lt;/a&gt;).</source>
          <target state="translated">2) 범위 생성자. &lt;code&gt;[first, last)&lt;/code&gt; 범위의 내용으로 컨테이너를 구성합니다 . 범위의 여러 요소에 동등한 키가있는 경우 삽입 할 요소가 지정되지 &lt;a href=&quot;http://wg21.link/lwg2844&quot;&gt;않습니다&lt;/a&gt; ( LWG2844 보류 중 ).</target>
        </trans-unit>
        <trans-unit id="721f56dab42c2d3bcb0b60289470523ffbcac573" translate="yes" xml:space="preserve">
          <source>2) Raw pointer overload: If &lt;code&gt;T&lt;/code&gt; is a function type, the program is ill-formed. Otherwise, returns &lt;code&gt;p&lt;/code&gt; unmodified.</source>
          <target state="translated">2) 원시 포인터 과부하 : &lt;code&gt;T&lt;/code&gt; 가 함수 유형 인 경우 프로그램이 잘못 구성됩니다. 그렇지 않으면 &lt;code&gt;p&lt;/code&gt; 를 수정하지 않고 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e087e35f91ba7acd326c5d2042594decbb100250" translate="yes" xml:space="preserve">
          <source>2) Reads &lt;code&gt;count&lt;/code&gt; characters from the input sequence and stores them into a character array pointed to by &lt;code&gt;s&lt;/code&gt;. The characters are read as if by repeated calls to &lt;code&gt;&lt;a href=&quot;sbumpc&quot;&gt;sbumpc()&lt;/a&gt;&lt;/code&gt;. That is, if less than &lt;code&gt;count&lt;/code&gt; characters are immediately available, the function calls &lt;code&gt;&lt;a href=&quot;uflow&quot;&gt;uflow()&lt;/a&gt;&lt;/code&gt; to provide more until &lt;code&gt;Traits::eof()&lt;/code&gt; is returned.</source>
          <target state="translated">2) 입력 시퀀스에서 &lt;code&gt;count&lt;/code&gt; 문자를 읽고 &lt;code&gt;s&lt;/code&gt; 가 가리키는 문자 배열에 저장합니다 . &lt;code&gt;&lt;a href=&quot;sbumpc&quot;&gt;sbumpc()&lt;/a&gt;&lt;/code&gt; 를 반복해서 호출하는 것처럼 문자를 읽습니다 . 즉, &lt;code&gt;count&lt;/code&gt; 미만의 문자를 즉시 ​​사용할 수 있으면 이 함수는 &lt;code&gt;Traits::eof()&lt;/code&gt; 가 반환 될 때까지 &lt;code&gt;&lt;a href=&quot;uflow&quot;&gt;uflow()&lt;/a&gt;&lt;/code&gt; 를 호출 하여 더 많은 것을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="a7b6c226717f16f97bbd938ba9fffb7fd873d1ec" translate="yes" xml:space="preserve">
          <source>2) Reads a complex number from &lt;code&gt;is&lt;/code&gt;. The supported formats are</source>
          <target state="translated">2)에서 복소수 읽어 &lt;code&gt;is&lt;/code&gt; . 지원되는 형식은</target>
        </trans-unit>
        <trans-unit id="d402c4de10a78eb7d25fecd1a717c4c366531960" translate="yes" xml:space="preserve">
          <source>2) Reads characters from the input iterator &lt;code&gt;in&lt;/code&gt; and generates the value of the type of &lt;code&gt;v&lt;/code&gt;, taking into account IO stream formatting flags from &lt;code&gt;str.flags()&lt;/code&gt;, character classification rules from &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc())&lt;/code&gt;, and numeric punctuation characters from &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc())&lt;/code&gt;. This function is called by all formatted input stream operators such as &lt;code&gt;&lt;a href=&quot;../../io/cin&quot;&gt;std::cin&lt;/a&gt; &amp;gt;&amp;gt; n;&lt;/code&gt;.</source>
          <target state="translated">2) 입력 반복기에서 문자를 읽습니다. &lt;code&gt;in&lt;/code&gt; &lt;code&gt;str.flags()&lt;/code&gt; IO 스트림 형식화 플래그 , &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc())&lt;/code&gt; &amp;lt; &lt;a href=&quot;../ctype&quot;&gt;std :: ctype&lt;/a&gt; &amp;lt;charT &amp;gt;&amp;gt;의 문자 분류 규칙 을 고려하여 &lt;code&gt;v&lt;/code&gt; 유형의 값을 생성합니다. (str.getloc ()) ,과에서 숫자 문장 부호 문자 &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc())&lt;/code&gt; &amp;lt; &lt;a href=&quot;../numpunct&quot;&gt;표준 : numpunct&lt;/a&gt; &amp;lt;그림 &amp;gt;&amp;gt; (str.getloc ()) . 이 함수는 &lt;code&gt;&lt;a href=&quot;../../io/cin&quot;&gt;std::cin&lt;/a&gt; &amp;gt;&amp;gt; n;&lt;/code&gt; &amp;gt;&amp;gt; n; .</target>
        </trans-unit>
        <trans-unit id="2db989768054b9c231e295a33c4067521c99838b" translate="yes" xml:space="preserve">
          <source>2) Reads one character and stores it to &lt;code&gt;ch&lt;/code&gt; if available. Otherwise, leaves &lt;code&gt;ch&lt;/code&gt; unmodified and sets &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;failbit&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;eofbit&lt;/a&gt;&lt;/code&gt;. Note that this function is not overloaded on the types &lt;code&gt;signed char&lt;/code&gt; and &lt;code&gt;unsigned char&lt;/code&gt;, unlike the formatted character input operator&amp;gt;&amp;gt;.</source>
          <target state="translated">2) 한 문자를 읽고 사용 가능한 경우 &lt;code&gt;ch&lt;/code&gt; 에 저장합니다 . 그렇지 않으면 &lt;code&gt;ch&lt;/code&gt; 를 수정하지 않고 &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;failbit&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;eofbit&lt;/a&gt;&lt;/code&gt; 를 설정 합니다 . 이 함수는 형식이 지정된 문자 입력 연산자 &amp;gt;&amp;gt;와 달리 &lt;code&gt;signed char&lt;/code&gt; 및 &lt;code&gt;unsigned char&lt;/code&gt; 유형에서는 오버로드되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="72f8aaccb51710d10b35db124130c79a825a7c3b" translate="yes" xml:space="preserve">
          <source>2) Reads successive characters from the sequence &lt;code&gt;[beg, end)&lt;/code&gt; and parses out the calendar date value using the default format expected by this locale, which is the same format as</source>
          <target state="translated">2) 시퀀스 &lt;code&gt;[beg, end)&lt;/code&gt; 에서 연속 문자를 읽고이 로케일이 예상하는 기본 형식을 사용하여 달력 날짜 값을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="c3e0932b7ec2ff13e5d5a42d735586e5c41f851a" translate="yes" xml:space="preserve">
          <source>2) Reads successive characters from the sequence &lt;code&gt;[beg, end)&lt;/code&gt; and parses out the month name (possibly abbreviated), using the default format for month names expected by this locale, which is the same format as &lt;code&gt;&quot;%b&quot;&lt;/code&gt; as used by the functions &lt;code&gt;&lt;a href=&quot;../../io/manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt;, &lt;a href=&quot;get&quot;&gt;&lt;code&gt;time_get::get&lt;/code&gt;&lt;/a&gt;, and the POSIX function &lt;code&gt;strptime()&lt;/code&gt;</source>
          <target state="translated">2) 시퀀스 &lt;code&gt;[beg, end)&lt;/code&gt; 에서 연속 문자를 읽고이 로케일에 의해 예상되는 월 이름의 기본 형식을 사용하여 월 이름 (약어)을 구문 분석합니다.이 형식은 &lt;code&gt;&quot;%b&quot;&lt;/code&gt; 와 동일한 형식입니다 . 기능 &lt;code&gt;&lt;a href=&quot;../../io/manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt; , &lt;a href=&quot;get&quot;&gt; &lt;code&gt;time_get::get&lt;/code&gt; &lt;/a&gt; , 그리고 POSIX 기능 &lt;code&gt;strptime()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a0628b1e7b7b859fa29f4583009574f299a9db23" translate="yes" xml:space="preserve">
          <source>2) Reads successive characters from the sequence &lt;code&gt;[beg, end)&lt;/code&gt; and parses out the time value following the same rules as the format specifier</source>
          <target state="translated">2) 시퀀스 &lt;code&gt;[beg, end)&lt;/code&gt; 에서 연속 문자를 읽고 형식 지정자와 동일한 규칙에 따라 시간 값을 구문 분석합니다</target>
        </trans-unit>
        <trans-unit id="d95244465f7ce8d0de17348b376b08df98d08369" translate="yes" xml:space="preserve">
          <source>2) Reads successive characters from the sequence &lt;code&gt;[beg, end)&lt;/code&gt; and parses out the weekday name (possibly abbreviated), using the default format for weekdays expected by this locale, which is the same format as &lt;code&gt;&quot;%a&quot;&lt;/code&gt; as used by the functions &lt;code&gt;&lt;a href=&quot;../../io/manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt;, &lt;a href=&quot;get&quot;&gt;&lt;code&gt;time_get::get&lt;/code&gt;&lt;/a&gt;, and the POSIX function &lt;code&gt;strptime()&lt;/code&gt;</source>
          <target state="translated">2) 시퀀스 &lt;code&gt;[beg, end)&lt;/code&gt; 에서 연속 문자를 읽고이 로케일이 예상하는 주중의 기본 형식을 사용하여 요일 이름 (약어)을 구문 분석합니다.이 형식 은 함수에서 사용 &lt;code&gt;&quot;%a&quot;&lt;/code&gt; 와 동일한 형식입니다. &lt;code&gt;&lt;a href=&quot;../../io/manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt; , &lt;a href=&quot;get&quot;&gt; &lt;code&gt;time_get::get&lt;/code&gt; &lt;/a&gt; 및 POSIX 함수 &lt;code&gt;strptime()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="68c2c84a6b184c405866642ab8ab53a5342acd93" translate="yes" xml:space="preserve">
          <source>2) Reads successive characters from the sequence &lt;code&gt;[beg, end)&lt;/code&gt; and parses out the year using some implementation-defined format. Depending on the locale, two-digit years may be accepted, and it is implementation-defined which century they belong to.</source>
          <target state="translated">2) 시퀀스 &lt;code&gt;[beg, end)&lt;/code&gt; 에서 연속 문자를 읽고 구현 정의 형식을 사용하여 연도를 구문 분석합니다. 로케일에 따라 두 자리 연도를 사용할 수 있으며 해당 연도는 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="ba089e56c0fe260a3393a9b9d292f9ecbfc2dd36" translate="yes" xml:space="preserve">
          <source>2) Reads the data from file stream &lt;code&gt;stream&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d1bc2ff6d34ef1f0cddd654c6245002d15bfb4c" translate="yes" xml:space="preserve">
          <source>2) Reads the data from file stream &lt;code&gt;stream&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e46363fa171130fa1b9e50503f2d51a6b93386a" translate="yes" xml:space="preserve">
          <source>2) Releases any shared state and move-assigns the contents of &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;. After the assignment, &lt;code&gt;other.valid() == false&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;valid&quot;&gt;this-&amp;gt;valid()&lt;/a&gt;&lt;/code&gt; will yield the same value as &lt;code&gt;other.valid()&lt;/code&gt; before the assignment.</source>
          <target state="translated">2) 공유 상태를 해제하고 &lt;code&gt;other&lt;/code&gt; 내용을 이동 할당 을 &lt;code&gt;*this&lt;/code&gt; 에 . 할당 후 &lt;code&gt;other.valid() == false&lt;/code&gt; 이고 &lt;code&gt;&lt;a href=&quot;valid&quot;&gt;this-&amp;gt;valid()&lt;/a&gt;&lt;/code&gt; 는 할당 전에 &lt;code&gt;other.valid()&lt;/code&gt; 와 동일한 값을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="9c7afa54797a39bf2178ea7f58f0934685221794" translate="yes" xml:space="preserve">
          <source>2) Releases the implementation-defined resources associated with an open catalog that is designated by the value &lt;code&gt;c&lt;/code&gt; of type &lt;code&gt;catalog&lt;/code&gt; (inherited from &lt;code&gt;&lt;a href=&quot;../messages_base&quot;&gt;std::messages_base&lt;/a&gt;&lt;/code&gt;), which was obtained from &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">2) 값 &lt;code&gt;c&lt;/code&gt; 로 지정된 공개 카탈로그와 연관된 구현 정의 자원을 해제합니다. &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 에서 얻은 &lt;code&gt;catalog&lt;/code&gt; 유형 ( &lt;code&gt;&lt;a href=&quot;../messages_base&quot;&gt;std::messages_base&lt;/a&gt;&lt;/code&gt; 에서 상 속됨 합니다.</target>
        </trans-unit>
        <trans-unit id="cc0e097e00cb40af76581839ae1503701c89d372" translate="yes" xml:space="preserve">
          <source>2) Releases the shared state, if any, destroys the previously-held task, and moves the shared state and the task owned by &lt;code&gt;rhs&lt;/code&gt; into &lt;code&gt;*this&lt;/code&gt;. &lt;code&gt;rhs&lt;/code&gt; is left without a shared state and with a moved-from task.</source>
          <target state="translated">2) 공유 상태 (있는 경우)를 해제하고 이전에 보유한 태스크를 삭제하고 공유 상태 및 &lt;code&gt;rhs&lt;/code&gt; 가 소유 한 태스크 를 &lt;code&gt;*this&lt;/code&gt; 로 이동 시킵니다. &lt;code&gt;rhs&lt;/code&gt; 는 공유 상태가없고 이동 된 작업으로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcaad03dd7419602c73c5623973bfd35c3b5ee83" translate="yes" xml:space="preserve">
          <source>2) Removes the &lt;code&gt;L&lt;/code&gt; prefix (if any) , the outer quotes, and leading/trailing whitespace from string-literal, replaces each &lt;code&gt;\&quot;&lt;/code&gt; with &lt;code&gt;&quot;&lt;/code&gt; and each &lt;code&gt;\\&lt;/code&gt; with &lt;code&gt;\&lt;/code&gt;, then tokenizes the result (as in &lt;a href=&quot;../language/translation_phases&quot;&gt;translation stage 3&lt;/a&gt;), and then uses the result as if the input to &lt;code&gt;#pragma&lt;/code&gt; in (1)</source>
          <target state="translated">2) 문자열 리터럴에서 &lt;code&gt;L&lt;/code&gt; 접두사 (있는 경우), 외부 인용 부호 및 선행 / 후행 공백을 제거하고 각 &lt;code&gt;\&quot;&lt;/code&gt; 를 &lt;code&gt;&quot;&lt;/code&gt; 와 각 &lt;code&gt;\\&lt;/code&gt; 로 바꿉니다. 를 &lt;code&gt;\&lt;/code&gt; 로 결과를 토큰 화합니다 ( &lt;a href=&quot;../language/translation_phases&quot;&gt;번역 단계 3&lt;/a&gt; 에서와 같이 ). (1)에서 &lt;code&gt;#pragma&lt;/code&gt; 에 입력 한 것처럼 결과를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="402cf1a0dcf69c2ec80a7973fb84f5719fe3cd37" translate="yes" xml:space="preserve">
          <source>2) Removes the character at &lt;code&gt;position&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;position&lt;/code&gt; 에서 문자를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="79693d3dd6dde71c69e2b7bb16ac3743d088527c" translate="yes" xml:space="preserve">
          <source>2) Removes the elements in the range &lt;code&gt;(first; last)&lt;/code&gt;.</source>
          <target state="translated">2) 범위의 요소를 제거합니다 &lt;code&gt;(first; last)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2857f1ea329869fd38508e51a2311be86c2121f0" translate="yes" xml:space="preserve">
          <source>2) Removes the elements in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;[first, last)&lt;/code&gt; 범위의 요소를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="fb2f5d1926df5c65e275450f80fd5c58a4352418" translate="yes" xml:space="preserve">
          <source>2) Removes the elements in the range &lt;code&gt;[first; last)&lt;/code&gt;, which must be a valid range in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;[first; last)&lt;/code&gt; 에 유효한 범위해야하는 &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f9f68edd176c49831371844632b0b6382c38ece" translate="yes" xml:space="preserve">
          <source>2) Replace each directory-separator (which may consist of multiple slashes) with a single &lt;code&gt;path::preferred_separator&lt;/code&gt;.</source>
          <target state="translated">2) 각 디렉토리 분리기 (여러 슬래시로 구성 될 수 있음)를 단일 &lt;code&gt;path::preferred_separator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1479f0b9df94d4bebaf26b47ed280cb0d7b29001" translate="yes" xml:space="preserve">
          <source>2) Replaces the contents of &lt;code&gt;*this&lt;/code&gt; with a pathname whose both native and generic format representations equal those of &lt;code&gt;p&lt;/code&gt;, possibly using move semantics: &lt;code&gt;p&lt;/code&gt; is left in a valid, but unspecified state.</source>
          <target state="translated">2) &lt;code&gt;*this&lt;/code&gt; 의 내용을 기본 형식 표현과 일반 형식 표현이 &lt;code&gt;p&lt;/code&gt; 의 내용 과 동일한 경로 이름으로 바꿉니다. 이동 시맨틱을 사용하여 . &lt;code&gt;p&lt;/code&gt; 는 유효하지만 지정되지 않은 상태로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d0e4ca06a07a5fa7f86a896d49ee84e0502c952" translate="yes" xml:space="preserve">
          <source>2) Replaces the contents of the underlying string as if by calling &lt;code&gt;rdbuf()-&amp;gt;str(new_str)&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;rdbuf()-&amp;gt;str(new_str)&lt;/code&gt; 를 호출하여 마치 기본 문자열의 내용을 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="8391c2c17f2f4f13c610d9f810ea10436298326c" translate="yes" xml:space="preserve">
          <source>2) Replaces the contents with a copy of &lt;code&gt;str&lt;/code&gt;. Equivalent to &lt;code&gt;*this = str;&lt;/code&gt;. In particular, allocator propagation may take place.(since C++11)</source>
          <target state="translated">2) 내용을 &lt;code&gt;str&lt;/code&gt; 사본으로 바꿉니다 . 당량 &lt;code&gt;*this = str;&lt;/code&gt; . 특히 할당 자 전파가 발생할 수 있습니다 (C ++ 11부터).</target>
        </trans-unit>
        <trans-unit id="55f5b0316d675d818ea9ce9e4ccf85ef81a1eb0e" translate="yes" xml:space="preserve">
          <source>2) Replaces the contents with copies of those in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">2) 내용을 &lt;code&gt;[first, last)&lt;/code&gt; 범위의 사본으로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="d972332734e8b5d2c5018aca70fe2138a08cfe8f" translate="yes" xml:space="preserve">
          <source>2) Replaces the contents with those of &lt;code&gt;str&lt;/code&gt; using move semantics. &lt;code&gt;str&lt;/code&gt; is in a valid but unspecified state afterwards. If &lt;code&gt;std::allocator_traits&amp;lt;Allocator&amp;gt;::propagate_on_container_move_assignment()&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the target allocator is replaced by a copy of the source allocator. If it is &lt;code&gt;false&lt;/code&gt; and the source and the target allocators do not compare equal, the target cannot take ownership of the source memory and must assign each character individually, allocating additional memory using its own allocator as needed. Unlike other container move assignments, references, pointers, and iterators to &lt;code&gt;str&lt;/code&gt; may be invalidated.</source>
          <target state="translated">2) 이동 의미를 사용하여 내용을 &lt;code&gt;str&lt;/code&gt; 의 내용으로 바꿉니다 . &lt;code&gt;str&lt;/code&gt; 은 유효하지만 지정되지 않은 상태입니다. 경우 &lt;code&gt;std::allocator_traits&amp;lt;Allocator&amp;gt;::propagate_on_container_move_assignment()&lt;/code&gt; 이고 &lt;code&gt;true&lt;/code&gt; 목표 할당은 소스 할당의 복사본에 의해 대체된다. 그것이 &lt;code&gt;false&lt;/code&gt; 이라면 소스와 대상 할당 자 동일 비교하지 않는 대상은 소스 메모리의 소유권을 할 수없고 필요에 따라 자신의 할당을 사용하여 추가 메모리를 할당, 개별적으로 각 문자를 할당해야합니다. 다른 컨테이너 이동 지정과 달리 &lt;code&gt;str&lt;/code&gt; 에 대한 참조, 포인터 및 반복기 는 무효화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8aa53b7f74bebffc4fbda5847fc2a84f6c97988" translate="yes" xml:space="preserve">
          <source>2) Replaces the file position state with the value of &lt;code&gt;st&lt;/code&gt;.</source>
          <target state="translated">2) 파일 위치 상태를 &lt;code&gt;st&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00c2b558ca04a505b3df69c0f209e5d8c8b87e51" translate="yes" xml:space="preserve">
          <source>2) Resolves ambiguity according to the value of &lt;code&gt;z&lt;/code&gt;:</source>
          <target state="translated">2)의 가치에 따라 모호성을 해결 &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68e2fa5afec319a37b25ba54d39a3436371cf00c" translate="yes" xml:space="preserve">
          <source>2) Restores the distribution parameters and internal state with data read from &lt;code&gt;ist&lt;/code&gt;. The formatting flags of &lt;code&gt;ist&lt;/code&gt; are unchanged. The data must have been written using a stream with the same locale, &lt;code&gt;CharT&lt;/code&gt; and &lt;code&gt;Traits&lt;/code&gt; template parameters, otherwise the behavior is undefined. If bad input is encountered, &lt;code&gt;ist.setstate(std::ios::failbit)&lt;/code&gt; is called, which may throw &lt;code&gt;&lt;a href=&quot;../../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;d&lt;/code&gt; is unchanged in that case.</source>
          <target state="translated">2) &lt;code&gt;ist&lt;/code&gt; 에서 읽은 데이터로 분배 매개 변수 및 내부 상태를 복원합니다 . &lt;code&gt;ist&lt;/code&gt; 의 형식 플래그 는 변경되지 않습니다. 데이터는 동일한 로케일, &lt;code&gt;CharT&lt;/code&gt; 및 &lt;code&gt;Traits&lt;/code&gt; 템플리트 매개 변수 를 가진 스트림을 사용하여 작성되어야합니다 . 그렇지 않으면 동작이 정의되지 않습니다. 입력이 잘못되면 &lt;code&gt;ist.setstate(std::ios::failbit)&lt;/code&gt; 가 호출되어 &lt;code&gt;&lt;a href=&quot;../../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; 있습니다. 이 경우 &lt;code&gt;d&lt;/code&gt; 는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="12ce85ecd6eacf5e22a64dc9082d8c8da89ac681" translate="yes" xml:space="preserve">
          <source>2) Restores the internal state of the pseudo-random number engine &lt;code&gt;e&lt;/code&gt; from the serialized representation, which was created by an earlier call to &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; using a stream with the same imbued locale and the same &lt;code&gt;CharT&lt;/code&gt; and &lt;code&gt;Traits&lt;/code&gt;. If the input cannot be deserialized, &lt;code&gt;e&lt;/code&gt; is left unchanged and &lt;code&gt;failbit&lt;/code&gt; is raised on &lt;code&gt;ist&lt;/code&gt;</source>
          <target state="translated">2) 의사 난수 엔진 &lt;code&gt;e&lt;/code&gt; 의 내부 상태를 직렬화 된 표현에서 복원합니다 . 직렬화 된 표현 은 동일한 마킹 된 로케일과 동일한 &lt;code&gt;CharT&lt;/code&gt; 및 &lt;code&gt;Traits&lt;/code&gt; 를 가진 스트림을 사용하여 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 에 대한 이전 호출에 의해 생성되었습니다 . 입력을 직렬화 해제 할 수없는 경우 &lt;code&gt;e&lt;/code&gt; 는 변경되지 않고 &lt;code&gt;failbit&lt;/code&gt; &lt;code&gt;ist&lt;/code&gt; 에서 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b643562f5497c25a66a27bfb34dea13cd6b925a7" translate="yes" xml:space="preserve">
          <source>2) Restores the internal state of the pseudo-random number engine adaptor &lt;code&gt;e&lt;/code&gt; from the serialized representation, which was created by an earlier call to &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; using a stream with the same imbued locale and the same &lt;code&gt;CharT&lt;/code&gt; and &lt;code&gt;Traits&lt;/code&gt;. If the input cannot be deserialized, &lt;code&gt;e&lt;/code&gt; is left unchanged and &lt;code&gt;failbit&lt;/code&gt; is raised on &lt;code&gt;ist&lt;/code&gt;</source>
          <target state="translated">2) 의사 난수 엔진 어댑터 &lt;code&gt;e&lt;/code&gt; 의 내부 상태를 직렬화 된 표현에서 복원합니다 . 직렬화 된 표현 은 동일한 마킹 된 로케일과 동일한 &lt;code&gt;CharT&lt;/code&gt; 및 &lt;code&gt;Traits&lt;/code&gt; 를 가진 스트림을 사용하여 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 에 대한 이전 호출에 의해 작성되었습니다 . 입력을 직렬화 해제 할 수없는 경우 &lt;code&gt;e&lt;/code&gt; 는 변경되지 않고 &lt;code&gt;ist&lt;/code&gt; 에서 &lt;code&gt;failbit&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
