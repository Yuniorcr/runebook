<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="ef9f8b3950f865685cbd05b3a06b2ed7a7f35f19" translate="yes" xml:space="preserve">
          <source>Normally called by the destructor of the owning &lt;code&gt;std::basic_osyncstream&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e69c1716df1f314f731c86bb9ee456bd2cd42a44" translate="yes" xml:space="preserve">
          <source>Not a STREAM</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="338469a733ebda5aa0e30bb1db80e0e157e51892" translate="yes" xml:space="preserve">
          <source>Not a directory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f854c8a27802b306c89a26cc0a427ae966229d76" translate="yes" xml:space="preserve">
          <source>Not a socket</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a995d52089af1ca1c3e17ca5083742ff6c6d197" translate="yes" xml:space="preserve">
          <source>Not all &lt;code&gt;size&lt;/code&gt; bytes will necessarily be used for buffering: the actual buffer size is usually rounded down to a multiple of 2, a multiple of page size, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dec23dc08cbd63d114548df51b815434bf03e29" translate="yes" xml:space="preserve">
          <source>Not all combinations of parameters may be valid, see the derived versions of &lt;code&gt;seekoff&lt;/code&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4785c5c50f004a02cbc4c83aa38bb038b5fd0498" translate="yes" xml:space="preserve">
          <source>Not enough space</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e635455c1c04acc72cc3cb8b3930fa2002922c7" translate="yes" xml:space="preserve">
          <source>Not supported</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="463ea1aceb837fc90a032c7ce4723b9fe8359f01" translate="yes" xml:space="preserve">
          <source>Not-a-number is converted to &lt;code&gt;nan&lt;/code&gt; or &lt;code&gt;nan(&lt;i&gt;char_sequence&lt;/i&gt;)&lt;/code&gt;. Which one is used is implementation defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3c8f21599c3d53b9c43247949abd19703a28bc5" translate="yes" xml:space="preserve">
          <source>Note that &amp;amp;=, |=, and ^= are only defined for bitsets of the same size &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="224a6acce36ab5f5091b025c008ba8c7cd693dca" translate="yes" xml:space="preserve">
          <source>Note that (2) returns a pointer. When dereferencing a pointer the returned value is an lvalue. This may lead to unintended behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67b02dd7a33f62b08ecc1d17f3f67bf7b130c9f3" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;invocable&quot;&gt;&lt;code&gt;RegularInvocable&lt;/code&gt;&lt;/a&gt; requires the invocation to not modify either the callable object or the arguments and be equality-preserving.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a24815b6729fbb85701c16da4b0a8b977871a834" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;keyword/and&quot;&gt;&lt;code&gt;and&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;keyword/bitor&quot;&gt;&lt;code&gt;bitor&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;keyword/or&quot;&gt;&lt;code&gt;or&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;keyword/xor&quot;&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;keyword/compl&quot;&gt;&lt;code&gt;compl&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;keyword/bitand&quot;&gt;&lt;code&gt;bitand&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;keyword/and_eq&quot;&gt;&lt;code&gt;and_eq&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;keyword/or_eq&quot;&gt;&lt;code&gt;or_eq&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;keyword/xor_eq&quot;&gt;&lt;code&gt;xor_eq&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;keyword/not&quot;&gt;&lt;code&gt;not&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;keyword/not_eq&quot;&gt;&lt;code&gt;not_eq&lt;/code&gt;&lt;/a&gt; (along with the digraphs &lt;code&gt;&amp;lt;%&lt;/code&gt;, &lt;code&gt;%&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;:&lt;/code&gt;, &lt;code&gt;:&amp;gt;&lt;/code&gt;, &lt;code&gt;%:&lt;/code&gt;, and &lt;code&gt;%:%:&lt;/code&gt;) provide an &lt;a href=&quot;language/operator_alternative&quot;&gt;alternative way to represent standard tokens&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9057d63577c54521991aad13fbb3ea96c003165e" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;operator_arithmetic&quot;&gt;bitwise logic operators&lt;/a&gt; do not perform short-circuiting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bda01a2de177323b14bebd3b89bce6b4040ed1ae" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;container/unordered_map/operator_at&quot;&gt;std::unordered_map::operator[]&lt;/a&gt;&lt;/code&gt; also counts, as it may insert an element into the map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="868c9df745254eb4056662b31a6b56822ce32196" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;regex_match&lt;/code&gt; will only successfully match a regular expression to an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="723c5c9eaf48c65da81792d9e6e68bd89b5e1992" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;std::future&lt;/code&gt; references shared state that is not shared with any other asynchronous return objects (as opposed to &lt;code&gt;&lt;a href=&quot;shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c27edaf7edd32942f4f542eed915fc9a16440a8" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;unique_ptr&lt;/code&gt;'s assignment operator only accepts &lt;a href=&quot;../../language/value_category&quot;&gt;rvalues&lt;/a&gt;, which are typically generated by &lt;code&gt;std::move&lt;/code&gt;. (The &lt;code&gt;unique_ptr&lt;/code&gt; class explicitly deletes its &lt;a href=&quot;../../language/value_category&quot;&gt;lvalue&lt;/a&gt; copy constructor and &lt;a href=&quot;../../language/value_category&quot;&gt;lvalue&lt;/a&gt; assignment operator.).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e501464ac3ffea1db2affac6abd20c63ab9b7382" translate="yes" xml:space="preserve">
          <source>Note that a &lt;code&gt;noexcept&lt;/code&gt; specification on a function is not a compile-time check; it is merely a method for a programmer to inform the compiler whether or not a function should throw exceptions. The compiler can use this information to enable certain optimizations on non-throwing functions as well as enable the &lt;a href=&quot;noexcept&quot;&gt;&lt;code&gt;noexcept&lt;/code&gt; operator&lt;/a&gt;, which can check at compile time if a particular expression is declared to throw any exceptions. For example, containers such as &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; will move their elements if the elements' move constructor is &lt;code&gt;noexcept&lt;/code&gt;, and copy otherwise (unless the copy constructor is not accessible, but a potentially throwing move constructor is, in which case the strong exception guarantee is waived).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b2e48af5bfd836222aed630539895a013425c7b" translate="yes" xml:space="preserve">
          <source>Note that a base class can be the current instantiation if a nested class derives from its enclosing class template. Base classes that are dependent types but aren't the current instantiation are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8d23b892b741c8ae00d2e1885bd2873272fce99" translate="yes" xml:space="preserve">
          <source>Note that a new class name may also be introduced by an &lt;a href=&quot;elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt; which appears as part of another declaration, but only if &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt; can't find a previously declared class with the same name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75556b77a1acad49c879b6335c2feeb8b94e072f" translate="yes" xml:space="preserve">
          <source>Note that accessing a variable in a transaction and out of a transaction without other external synchronization is a data race.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee7c6a1b5d9da306b0168b0ac47cccc0554496c9" translate="yes" xml:space="preserve">
          <source>Note that all other conversions are not promotions; for example, &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; chooses &lt;code&gt;char&lt;/code&gt; -&amp;gt; &lt;code&gt;int&lt;/code&gt; (promotion) over &lt;code&gt;char&lt;/code&gt; -&amp;gt; &lt;code&gt;short&lt;/code&gt; (conversion).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc03b0131d5ec695976453012426838efe382c04" translate="yes" xml:space="preserve">
          <source>Note that any init-statement must end with a semicolon &lt;code&gt;;&lt;/code&gt;, which is why it is often described informally as an expression or a declaration followed by a semicolon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="411cf44db091d581d52972ec737cb4511291d855" translate="yes" xml:space="preserve">
          <source>Note that because no definition exists for &lt;code&gt;declval&lt;/code&gt;, it can only be used in &lt;a href=&quot;../language/expressions#Unevaluated_expressions&quot;&gt;unevaluated contexts&lt;/a&gt;; it is an error to evaluate an expression that contains this function. Formally, the program is ill-formed if this function is &lt;a href=&quot;../language/definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81f16c0413cd9342c2b6bd7d4bf137e0c1c48355" translate="yes" xml:space="preserve">
          <source>Note that because the coroutine is fully suspended before entering &lt;code&gt;awaiter.await_suspend()&lt;/code&gt;, that function is free to transfer the coroutine handle across threads, with no additional synchronization. For example, it can put it inside a callback, scheduled to run on a threadpool when async I/O operation completes. This also means the current coroutine may resume and finish on that threadpool, concurrently, while still inside await_suspend(), and so await_suspend() should not expect the awaiter (the &lt;code&gt;*this&lt;/code&gt; object) to be accessible after the handle was published to other threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e419ce8ad7d59785de3678604706b11b55c334c" translate="yes" xml:space="preserve">
          <source>Note that currently (2/2015) no known production compilers track dependency chains: consume operations are lifted to acquire operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f66c78a819db9180052c96cd4c6d9b3c77e76707" translate="yes" xml:space="preserve">
          <source>Note that dereferencing (&lt;code&gt;operator*&lt;/code&gt; or &lt;code&gt;operator-&amp;gt;&lt;/code&gt;) is not required of a NullablePointer type. A minimalistic type that satisfies these requirements is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b51f0459c638e711b4501ca707a31feb0c208caf" translate="yes" xml:space="preserve">
          <source>Note that if some element of the list is not implicitly convertible to the corresponding element of the target tuple, the constructors become explicit:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aa2f5b061af28463a18c8e132bc93995bcf8ef0" translate="yes" xml:space="preserve">
          <source>Note that if the name of an object is parenthesized, it is treated as an ordinary lvalue expression, thus &lt;code&gt;decltype(x)&lt;/code&gt; and &lt;code&gt;decltype((x))&lt;/code&gt; are often different types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e5fa300d603125e8ba59dbcf160d502f0d49a53" translate="yes" xml:space="preserve">
          <source>Note that in nearly all situations, if eofbit is set, the failbit is set as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="888b07f17a12a50f29bed545c47146ee24c4ff8b" translate="yes" xml:space="preserve">
          <source>Note that in the C programming language, const/volatile can be added to the first level only:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c51b4f892d6a23439355c5fb01fedb95e577133" translate="yes" xml:space="preserve">
          <source>Note that it means that a program with endless recursion or endless loop (whether implemented as a &lt;a href=&quot;for&quot;&gt;for-statement&lt;/a&gt; or by looping &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; or otherwise) has &lt;a href=&quot;ub&quot;&gt;undefined behavior&lt;/a&gt;. This allows the compilers to remove all loops that have no observable behavior, without having to prove that they would eventually terminate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dae6ff9ecff3ee7cfd12351cd92961bdf6c32c1c" translate="yes" xml:space="preserve">
          <source>Note that many C++ compilers relax this rule, as a non-standard language extension, to allow wrong-type access through the inactive member of a &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; (such access is not undefined in C).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb945cb71ff06b6a531e87e6c5e255ca5237b346" translate="yes" xml:space="preserve">
          <source>Note that only non-template and primary template overloads participate in overload resolution. The specializations are not overloads and are not considered. Only after the overload resolution selects the best-matching primary function template, its specializations are examined to see if one is a better match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bf81eb99493f77d25dc944f8f002bf4af26572f" translate="yes" xml:space="preserve">
          <source>Note that rvalue references and lvalue references to const extend the lifetimes of temporary objects (see &lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;Reference initialization&lt;/a&gt; for rules and exceptions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06d951d030935e89d579bd86704252ae6ffe2023" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt; parameter is defined such that it returns &lt;code&gt;true&lt;/code&gt; if its first argument comes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d13a7076165dc888732fffb8188e79585dd5dc5d" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;http://mathworld.wolfram.com/Condon-ShortleyPhase.html&quot;&gt;Condon-Shortley phase term &lt;/a&gt; (-1)m</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a4baa98249f1bd6b4b88d25c8b2700156da7762" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;http://mathworld.wolfram.com/Condon-ShortleyPhase.html&quot;&gt;Condon-Shortley phase term &lt;/a&gt; \((-1)^m\)(-1)m</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe1f8412037fd7bb499e8323c8859096929fc25e" translate="yes" xml:space="preserve">
          <source>Note that the base class move assignment swaps all stream state variables (except for &lt;code&gt;rdbuf&lt;/code&gt;) between &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbedf65cbe5840a62b96e379d883a1235d2d7473" translate="yes" xml:space="preserve">
          <source>Note that the behavior of a program that adds a specialization to any other template from &lt;code&gt;&amp;lt;type_traits&amp;gt;&lt;/code&gt; is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01fe218f47fc5a59bae046e8c768495b0c2706f3" translate="yes" xml:space="preserve">
          <source>Note that the comparison operators for &lt;code&gt;shared_ptr&lt;/code&gt; simply compare pointer values; the actual objects pointed to are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6b9f8b44de189bb79f91c0cf3ec08552f9f81af" translate="yes" xml:space="preserve">
          <source>Note that the control block of a shared_ptr is thread-safe: different &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; objects can be accessed using mutable operations, such as operator= or reset, simultaneously by multiple threads, even when these instances are copies, and share the same control block internally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13a108f3e3e9a57f891cf6c2e47a5e026106c407" translate="yes" xml:space="preserve">
          <source>Note that the control block of a shared_ptr is thread-safe: different non-atomic &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; objects can be accessed using mutable operations, such as operator= or reset, simultaneously by multiple threads, even when these instances are copies, and share the same control block internally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7913aa974d513c25a44a2f1fb1803681d24ad4f1" translate="yes" xml:space="preserve">
          <source>Note that the control block used by &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; is thread-safe: different non-atomic &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; objects can be accessed using mutable operations, such as operator= or reset, simultaneously by multiple threads, even when these instances are copies or otherwise share the same control block internally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a44567ed3bffda696fb1f5881fcae3140bb2333" translate="yes" xml:space="preserve">
          <source>Note that the guide protects itself against signed/unsigned mismatch bugs, like &lt;code&gt;view::iota(0, v.size())&lt;/code&gt;, where 0 is a (signed) int and v.size() is an (unsigned) std::size_t.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="298bc781cc66a0a221c8babeba390af0cf68d303" translate="yes" xml:space="preserve">
          <source>Note that the implementation is not dictated by the standard, so even if you use exactly the same &lt;code&gt;RandomFunc&lt;/code&gt; or &lt;code&gt;URBG&lt;/code&gt; you may get different results with different standard library implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62e6a680f423948e4b007d1c2bae71b85386df62" translate="yes" xml:space="preserve">
          <source>Note that the open and closing parentheses are part of the fold expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12d0d0c100bd9356917c578a611d5a9cca10961c" translate="yes" xml:space="preserve">
          <source>Note that the value after such conversion may not necessarily equal any of the named enumerators defined for the enumeration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2413f634f2470d9566b4aa167bc7e3d09f83a7c" translate="yes" xml:space="preserve">
          <source>Note that there is no class template argument deduction from pointer types because it is impossible to distinguish pointers obtained from array and non-array forms of &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88f38130a98d79aa9e1ec9ca77ccdb0dfeca2ff3" translate="yes" xml:space="preserve">
          <source>Note that this behavior may be unexpected</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3db1e7b5f19ce2e232d6140b4921e3cf566b797b" translate="yes" xml:space="preserve">
          <source>Note that this behaviour is different to &lt;code&gt;std::is_base_of&lt;/code&gt; when &lt;code&gt;Base&lt;/code&gt; is a private or protected base of &lt;code&gt;Derived&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7168ae8c8f92dc8cadc5a437b5d711604bcd2fdf" translate="yes" xml:space="preserve">
          <source>Note that this example demonstrates the effect a heterogeneous operator&amp;lt;=&amp;gt; has: it generates heterogeneous comparisons in both directions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb57f59fae57714b535c404fabb2cde0285e2808" translate="yes" xml:space="preserve">
          <source>Note that this implies that any pointer can be compared with &lt;code&gt;void*&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="724173281ae1d1521f2609a2c1a14d6bf54b76fc" translate="yes" xml:space="preserve">
          <source>Note that this means that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4734c5b12780bb88c08ea99de17db51f30ca8059" translate="yes" xml:space="preserve">
          <source>Note that this optimization is only permitted when new-expressions are used, not any other methods to call a replaceable allocation function: &lt;code&gt;delete[] new int[10];&lt;/code&gt; can be optimized out, but &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;(&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;(10));&lt;/code&gt; cannot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37dc7b6915f7df14d2bf41e3acb4bc8f3ed53e5a" translate="yes" xml:space="preserve">
          <source>Note that two pointers that represent the same address may nonetheless have different values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7388512268cec137fbcc4f48b5f5d2f5edc3d4c3" translate="yes" xml:space="preserve">
          <source>Note that when array-to-pointer decay is applied, a multidimensional array is converted to a pointer to its first element (e.g., a pointer to its first row or to its first plane): array-to-pointer decay is applied only once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8e2f9306d2a9590ff1f62edb5a66f5928e72097" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;implicit_cast#Qualification_conversions&quot;&gt; additional restrictions&lt;/a&gt; are imposed on multi-level pointers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e83ec329eb2a4b5e5c2eb2eb8d436942c7ef6f9" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt; category was only formally specified in C++17, but the iterators of &lt;code&gt;&lt;a href=&quot;container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;numeric/valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt;, as well as pointers into C arrays are often treated as a separate category in pre-C++17 code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5166123be3426460855c992d1da6919d6a02ca19" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;#if cond1&lt;/code&gt; ... &lt;code&gt;#elif cond2&lt;/code&gt; is different from &lt;code&gt;#if cond1&lt;/code&gt; ... &lt;code&gt;#else&lt;/code&gt; followed by &lt;code&gt;#if cond3&lt;/code&gt; because if &lt;code&gt;cond1&lt;/code&gt; is true, the second &lt;code&gt;#if&lt;/code&gt; is skipped and &lt;code&gt;cond3&lt;/code&gt; does not need to be well-formed, while #elif's &lt;code&gt;cond2&lt;/code&gt; must be a valid expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9eb77189d459e7f7d85fe84e4db3a51a8c8c426" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; offers similar functionality for one-dimensional dynamic arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e9950ae8bdcfc8a8bbf0bc90b4ea88f0c451178" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Ts (&amp;amp;...)[N]&lt;/code&gt; is not allowed because the C++11 grammar requires the parenthesized ellipsis to have a name: &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1488&quot;&gt;CWG #1488&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="879060fd914bc199f84b1de7c61d063f5ebac1fc" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;[first, last)&lt;/code&gt; refers to the character sequence being matched.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bcf1760f5c79fecf5e2aec0b729a645c107465b" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;comp&lt;/code&gt; induces a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50e18effd07d947f333f5fcf0ad1bda9da8bde25" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;enable_shared_from_this::operator=&lt;/code&gt; is defined as &lt;code&gt;protected&lt;/code&gt; in order to prevent accidental slicing but allow derived classes to have default assignment operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="537a3f37617552b068232363a065c5e3f949e9b7" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;const_iterator&lt;/code&gt; are the same type because string views are views into constant character sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ebf6682f26fc447f340137e2ad6b92ff3dbb4fa" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;iterator&lt;/code&gt; is a mutable iterator if &lt;code&gt;T&lt;/code&gt; is not const-qualified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12419838ebbbe59a0c615d0e1f6247339ada9e52" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;std::atomic_int&lt;i&gt;N&lt;/i&gt;_t&lt;/code&gt;, &lt;code&gt;std::atomic_uint&lt;i&gt;N&lt;/i&gt;_t&lt;/code&gt;, &lt;code&gt;std::atomic_intptr_t&lt;/code&gt;, and &lt;code&gt;atomic_uintptr_t&lt;/code&gt; are defined if and only if &lt;code&gt;std::int&lt;i&gt;N&lt;/i&gt;_t&lt;/code&gt;, &lt;code&gt;std::uint&lt;i&gt;N&lt;/i&gt;_t&lt;/code&gt;, &lt;code&gt;std::intptr_t&lt;/code&gt;, and &lt;code&gt;std::uintptr_t&lt;/code&gt; are defined, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c426395982443d9b12572801c7fd50e45bc9f30" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;tm_isdst&lt;/code&gt; is not written to, and needs to be set explicitly for use with functions such as &lt;code&gt;mktime&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="075bbfd70b108eb5acf0ecdf48f9f6484cfddfa9" translate="yes" xml:space="preserve">
          <source>Note: C++ grammar formally requires Unicode characters to be &lt;a href=&quot;escape&quot;&gt;escaped&lt;/a&gt; with &lt;code&gt;\u&lt;/code&gt; or &lt;code&gt;\U&lt;/code&gt;, but due to &lt;a href=&quot;translation_phases&quot;&gt;translation phase 1&lt;/a&gt;, that is exactly how raw unicode characters from the source code are presented to the compiler. Also note that support of this feature may be limited, e.g. &lt;a href=&quot;https://gcc.gnu.org/wiki/FAQ#What_is_the_status_of_adding_the_UTF-8_support_for_identifier_names_in_GCC.3F&quot;&gt;gcc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb711da710fa8ef71e055fa434fd2745689f086b" translate="yes" xml:space="preserve">
          <source>Note: In the exposition-only definition above, the required expressions &lt;code&gt;ranges::begin(std::forward&amp;lt;T&amp;gt;(t))&lt;/code&gt; and &lt;code&gt;ranges::end(std::forward&amp;lt;T&amp;gt;(t))&lt;/code&gt; do not require &lt;a href=&quot;../concepts/equalitycomparable#Implicit_expression_variations&quot;&gt;implicit expression variations&lt;/a&gt;. 3) The exposition-only concept &lt;code&gt;__ForwardingRange&lt;/code&gt; defines the requirements of a range such that a function can take it by value and return iterators obtained from it without danger of dangling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5de45d2d38d3f46fd73c0fdb868cf22196d5fa4" translate="yes" xml:space="preserve">
          <source>Note: In the pattern &lt;code&gt;Ts (&amp;amp;...arr)[N]&lt;/code&gt;, the ellipsis is the innermost element, not the last element as in all other pack expansions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dc22a9a7ddcb6e88e2649f8f4f1243219e6e309" translate="yes" xml:space="preserve">
          <source>Note: Just being a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aa8ded0c49b8036e4643cc463da2f1da11a8d33" translate="yes" xml:space="preserve">
          <source>Note: These names are only for exposition, they are not part of the interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc9a47b0c29491550e08cc857e7d9833584e54fb" translate="yes" xml:space="preserve">
          <source>Note: Until C++11, if one or both operands to binary operator % were negative, the sign of the remainder was implementation-defined, as it depends on the rounding direction of integer division. The function &lt;code&gt;&lt;a href=&quot;../numeric/math/div&quot;&gt;std::div&lt;/a&gt;&lt;/code&gt; provided well-defined behavior in that case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9875391e3e094abf05e4daefae244d734392f5e7" translate="yes" xml:space="preserve">
          <source>Note: Various features of the language, such as &lt;a href=&quot;reference&quot;&gt;references&lt;/a&gt; and &lt;a href=&quot;virtual&quot;&gt;virtual functions&lt;/a&gt;, might involve additional memory locations that are not accessible to programs but are managed by the implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04f5fecc853855549345b5421d13cffba1ebc25e" translate="yes" xml:space="preserve">
          <source>Note: a &lt;a href=&quot;member_template#Conversion_function_templates&quot;&gt;conversion function template&lt;/a&gt; is not allowed to have a deduced return type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9063589f0c95022fa011b2651f744f7b854b08b9" translate="yes" xml:space="preserve">
          <source>Note: a typedef member of a current instantiation is only dependent when the type it refers to is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7414e30b587a4e15505e0a858ef639e34854a9e" translate="yes" xml:space="preserve">
          <source>Note: actual (as opposed to guaranteed minimal) limits on the values representable by these types are available in &lt;a href=&quot;../types/climits&quot;&gt;&amp;lt;climits&amp;gt;, &amp;lt;cfloat&amp;gt;&lt;/a&gt; and &lt;code&gt;&lt;a href=&quot;../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21934c1ad44ed301b3851f8f07a70693f30a8385" translate="yes" xml:space="preserve">
          <source>Note: additional specializations for &lt;code&gt;std::pair&lt;/code&gt; and the standard container types, as well as utility functions to compose hashes are available in &lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/hash/reference.html&quot;&gt;boost.hash&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9212eec680eb1b573f1dce9f1a899e742c32e8f8" translate="yes" xml:space="preserve">
          <source>Note: an example where the condition remains value-dependent after instantiation is a nested template, e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="788719bc6547706e95a609589491b027a637f021" translate="yes" xml:space="preserve">
          <source>Note: an operator that returns a &lt;a href=&quot;../utility/compare/strong_ordering&quot;&gt;&lt;code&gt;std::strong_ordering&lt;/code&gt;&lt;/a&gt; should compare every member, because if any member is left out, substitutability can be compromised: it becomes possible to distinguish two values that compare equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd92ba3582f1b92874cad067dae19867ad7796a3" translate="yes" xml:space="preserve">
          <source>Note: as with all type specifiers, any order is permitted: &lt;code&gt;unsigned long long int&lt;/code&gt; and &lt;code&gt;long int unsigned long&lt;/code&gt; name the same type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c13c8466c8ce25f60aa85ce07edd1bf30bff1ea5" translate="yes" xml:space="preserve">
          <source>Note: compilers that do not support these pragmas may provide equivalent compile-time options, such as gcc's &lt;code&gt;-fcx-limited-range&lt;/code&gt; and &lt;code&gt;-ffp-contract&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de3cc61212d8fa218175913665504fbb2ef9c6e8" translate="yes" xml:space="preserve">
          <source>Note: each of the predefined duration types up to &lt;code&gt;hours&lt;/code&gt; covers a range of at least &amp;plusmn;292 years.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bf10b9fa8e2a971979237dedae192a363ace044" translate="yes" xml:space="preserve">
          <source>Note: for all jump statements, transfer out of a loop, out of a block, or back past an initialized variable with automatic storage duration involves the destruction of objects with automatic storage duration that are in scope at the point transferred from but not at the point transferred to. If multiple objects were initialized, the order of destruction is the opposite of the order of initialization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87087525904e2423e3acc37977546a24978418ce" translate="yes" xml:space="preserve">
          <source>Note: for floating-point remainder, see &lt;code&gt;&lt;a href=&quot;../numeric/math/remainder&quot;&gt;std::remainder&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../numeric/math/fmod&quot;&gt;std::fmod&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ccb7c10a9b575fadb17f1ebb87f52600e0f4da" translate="yes" xml:space="preserve">
          <source>Note: for implicitly-declared special member functions (constructors, assignment operators, and destructors) and for the inheriting constructors, the set of potential exceptions is a combination of the sets of the potential exceptions of everything they would call: constructors/assignment operators/destructors of non-variant non-static data members, direct bases, and, where appropriate, virtual bases (including default argument expressions, as always).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5379cb2cc0668cdf5890c9bd349a80d2dedd81e6" translate="yes" xml:space="preserve">
          <source>Note: for overloading &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion functions&lt;/a&gt;, &lt;a href=&quot;user_literal&quot;&gt;user-defined literals&lt;/a&gt;, &lt;a href=&quot;../memory/new/operator_new&quot;&gt;allocation&lt;/a&gt; and &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;deallocation&lt;/a&gt; see their respective articles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="953dde18ad70ea45ff7cd760871f10dca19d0656" translate="yes" xml:space="preserve">
          <source>Note: if an argument of a function-like macro includes commas that are not protected by matched pairs of left and right parentheses (most commonly found in template argument lists, as in &lt;code&gt;&lt;a href=&quot;../error/assert&quot;&gt;assert&lt;/a&gt;(&lt;a href=&quot;../types/is_same&quot;&gt;std::is_same_v&lt;/a&gt;&amp;lt;int, int&amp;gt;);&lt;/code&gt; or &lt;code&gt;BOOST_FOREACH(&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;int,int&amp;gt; p, m)&lt;/code&gt;), the comma is interpreted as macro argument separator, causing a compilation failure due to argument count mismatch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9498e07934726f998f7e3df6bdaf44b7e9d48d3" translate="yes" xml:space="preserve">
          <source>Note: in C, there is no program-wide ODR for types, and even extern declarations of the same variable in different translation units may have different types &lt;a href=&quot;http://en.cppreference.com/w/c/language/compatible_type.html#Compatible_types&quot;&gt;as long as they are compatible&lt;/a&gt;. In C++, the source-code tokens used in declarations of the same type must be the same as described above: if one .cpp file defines &lt;code&gt;struct S { int x; };&lt;/code&gt; and the other .cpp file defines &lt;code&gt;struct S { int y; };&lt;/code&gt;, the behavior of the program that links them together is undefined. This is usually resolved with &lt;a href=&quot;namespace&quot;&gt;unnamed namespaces&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="570f5c242f1a5f12b3ad8de85028df03f68cbc8a" translate="yes" xml:space="preserve">
          <source>Note: in Unicode, the ASCII character block is known as &lt;a href=&quot;http://www.unicode.org/charts/PDF/U0000.pdf&quot;&gt;&lt;code&gt;U+0000..U+007F&lt;/code&gt; Basic Latin&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2ae6dc352b077e01118c20f32ddfbca180326a4" translate="yes" xml:space="preserve">
          <source>Note: in arithmetic expressions, the destination type for the implicit conversions on the operands to binary operators is determined by a separate set of rules, &lt;a href=&quot;operator_arithmetic#Conversions&quot;&gt;&lt;i&gt;usual arithmetic conversions&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="760f445f7476d5a97785855992bf87d85a4e53af" translate="yes" xml:space="preserve">
          <source>Note: in the scope of every function body, there is a special function-local predefined variable named &lt;code&gt;__func__&lt;/code&gt;(since C++11), defined as a static character array holding the name of the function in implementation-defined format. It is not a preprocessor macro, but it is used together with &lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt;, e.g. by &lt;code&gt;&lt;a href=&quot;../error/assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="525c5abecffb6dfe1c004818eb27c0bad90d9188" translate="yes" xml:space="preserve">
          <source>Note: informally, if A</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92b9c4857860b761fbd066d1830c346b3104be76" translate="yes" xml:space="preserve">
          <source>Note: initialization requirements are based on the 2002 version of Mersenne Twister, &lt;a href=&quot;http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/CODES/mt19937ar.c&quot;&gt;mt19937ar.c&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef53134c3cebcaaafdb4136521b343492974fcab" translate="yes" xml:space="preserve">
          <source>Note: integer arithmetic is defined differently for the signed and unsigned integer types. See &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt;, in particular &lt;a href=&quot;operator_arithmetic#Overflows&quot;&gt;integer overflows&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2378e1afb1b7e94b6a3323bb4e6c74d6833d525c" translate="yes" xml:space="preserve">
          <source>Note: inter-thread synchronization boils down to preventing data races (by establishing happens-before relationships) and defining which side effects become visible under what conditions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa0da66efb7f1ef6275ddf042cec338ca91e7289" translate="yes" xml:space="preserve">
          <source>Note: limited lookup (but not binding) of dependent names also takes place at template definition time, as needed to distinguish them from non-dependent names and also to determine whether they are members of the current instantiation or members of unknown specialization. The information obtained by this lookup can be used to detect errors, see below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7d6abe9f4b23c0f6ee68eb5a3b0bd1800c72c9d" translate="yes" xml:space="preserve">
          <source>Note: literals, pseudo-destructor calls, &lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt;, &lt;a href=&quot;alignof&quot;&gt;alignof&lt;/a&gt;, &lt;a href=&quot;typeid&quot;&gt;typeid&lt;/a&gt;, &lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt;-expressions, &lt;a href=&quot;throw&quot;&gt;throw&lt;/a&gt;-expressions, and &lt;a href=&quot;noexcept&quot;&gt;noexcept&lt;/a&gt;-expressions are never type-dependent because the types of these expressions cannot be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ffb786099ea0dd35506491992a465a21148a6ba" translate="yes" xml:space="preserve">
          <source>Note: omitting &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; entirely allows &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; to examine both template and non-template overloads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1daf630f755e3eb8bb50ca5996829694a1577c90" translate="yes" xml:space="preserve">
          <source>Note: out-of-order designated initialization, nested designated initialization, mixing of designated initializers and regular initializers, and designated initialization of arrays are all supported in the &lt;a href=&quot;http://en.cppreference.com/w/c/language/struct_initialization.html&quot;&gt;C programming language&lt;/a&gt;, but are not allowed in C++.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7c5e311cc6f0099549928e2195731d087578c9e" translate="yes" xml:space="preserve">
          <source>Note: same applies to &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializer&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30c7612068836be7855824272d37b6c07bb757b8" translate="yes" xml:space="preserve">
          <source>Note: see &lt;a href=&quot;dependent_name#Lookup_rules&quot;&gt;dependent name lookup rules&lt;/a&gt; for the reasoning and implications of this rule.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccfa22fb08cc59d84b074964cc91bb483f47c7a9" translate="yes" xml:space="preserve">
          <source>Note: see Possible Implementation in &lt;code&gt;&lt;a href=&quot;apply&quot;&gt;std::apply&lt;/a&gt;&lt;/code&gt; for another example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2704b534ec209348d9361ad000cba83dc1bc7b8" translate="yes" xml:space="preserve">
          <source>Note: some compilers offer an extension that allows ## to appear after a comma and before __VA_ARGS__, in which case the ## does nothing when the variable arguments are present, but removes the comma when the variable arguments are not present: this makes it possible to define macros such as &lt;code&gt;fprintf (stderr, format, ##__VA_ARGS__)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d49128a6a17f4636bd9e3d5c1392d94419b0370a" translate="yes" xml:space="preserve">
          <source>Note: swapping two containers with unequal allocators if &lt;code&gt;propagate_on_container_swap&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; is undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b10c55492b39f0e810dada02483901773d21ef40" translate="yes" xml:space="preserve">
          <source>Note: the above implementation &lt;a href=&quot;http://stackoverflow.com/a/6495205/273767&quot;&gt;is oversimplified&lt;/a&gt; and is not &lt;code&gt;constexpr&lt;/code&gt; (which requires compiler support).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31c9df72a6851631d4744aa9659e6c401f810388" translate="yes" xml:space="preserve">
          <source>Note: the awaiter object is part of coroutine state (as a temporary whose lifetime crosses a suspension point) and is destroyed before the co_await expression finishes. It can be used to maintain per-operation state as required by some async I/O APIs without resorting to additional heap allocations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d269c6ad9dfee01369750d9386d6ab308b3b4a" translate="yes" xml:space="preserve">
          <source>Note: the conversion performed at this stage can be controlled by command line options in some implementations: gcc and clang use &lt;code&gt;-finput-charset&lt;/code&gt; to specify the encoding of the source character set, &lt;code&gt;-fexec-charset&lt;/code&gt; and &lt;code&gt;-fwide-exec-charset&lt;/code&gt; to specify the encodings of the execution character set in the string and character literals that don't have an encoding prefix(since C++11), while Visual Studio 2015 Update 2 and later uses &lt;code&gt;/source-charset&lt;/code&gt; and &lt;code&gt;/execution-charset&lt;/code&gt; to specify the source character set and execution character set respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cf7377d368d78bc8bdb2d318bc95337ed61cb32" translate="yes" xml:space="preserve">
          <source>Note: the discarded statement can't be ill-formed for every possible specialization:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="598cd12c35f58fd6496e5fa6a119897cae39f870" translate="yes" xml:space="preserve">
          <source>Note: the extent to which the library determines that a type does not satisfy &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; is unspecified, except that as a minimum integral types do not qualify as input iterators. Likewise, the extent to which it determines that a type does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; is unspecified, except that as a minimum the member type &lt;code&gt;Alloc::value_type&lt;/code&gt; must exist and the expression &lt;code&gt;&lt;a href=&quot;../../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;Alloc&amp;amp;&amp;gt;().allocate(&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;{})&lt;/code&gt; must be well-formed when treated as an unevaluated operand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="626f94b60ec5832b6f008b2e74dd4281d115491c" translate="yes" xml:space="preserve">
          <source>Note: the lifetime of the referred object may end before the end of the lifetime of the reference, which makes &lt;a href=&quot;reference#Dangling_references&quot;&gt;dangling references&lt;/a&gt; possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="150fb288e3151c6eea9bfdb1a0e943292b93e6aa" translate="yes" xml:space="preserve">
          <source>Note: the literal suffixes &lt;code&gt;d&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; do not refer to &lt;code&gt;days&lt;/code&gt; and &lt;code&gt;years&lt;/code&gt; but to &lt;a href=&quot;day&quot;&gt;&lt;code&gt;day&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;year&quot;&gt;&lt;code&gt;year&lt;/code&gt;&lt;/a&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b61794f109332096d516bf0d54c1748e9ab77f5e" translate="yes" xml:space="preserve">
          <source>Note: the meaning of &lt;code&gt;decltype(auto)&lt;/code&gt; placeholder in variable and function declarations does not use template argument deduction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d26dd4c9c9388923887066097983b66df01a02a2" translate="yes" xml:space="preserve">
          <source>Note: the rule about specializations allows library versioning: different implementations of a library template may be defined in different inline namespaces, while still allowing the user to extend the parent namespace with an explicit specialization of the primary template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c238f69956bfadd3f5c971b32795161dcb692c7" translate="yes" xml:space="preserve">
          <source>Note: the rule above does not specify an optimization: C++17 core language specification of &lt;a href=&quot;value_category&quot;&gt;prvalues&lt;/a&gt; and &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;temporaries&lt;/a&gt; is fundamentally different from that of the earlier C++ revisions: there is no longer a temporary to copy/move from. Another way to describe C++17 mechanics is &quot;unmaterialized value passing&quot;: prvalues are returned and used without ever materializing a temporary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4850ef974e8537ddfb0ff209fdd310158266beea" translate="yes" xml:space="preserve">
          <source>Note: the standard does not define named requirements with names specified in this subcategory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6691aba41c1bd0853e3a65fbdc646ded8351dfa" translate="yes" xml:space="preserve">
          <source>Note: the standard doesn't define a named requirement with this name. This is a type category defined by the core language. It is included here as a named requirement only for consistency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c80f337186d85a84cb91500fec6dee55939a41d" translate="yes" xml:space="preserve">
          <source>Note: the types of these constants, other than &lt;code&gt;CHAR_BIT&lt;/code&gt; and &lt;code&gt;MB_LEN_MAX&lt;/code&gt;, are required to match the results of the &lt;a href=&quot;../language/implicit_cast#Integral_promotion&quot;&gt;integral promotions&lt;/a&gt; as applied to objects of the types they describe: &lt;code&gt;CHAR_MAX&lt;/code&gt; may have type &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;unsigned int&lt;/code&gt;, but never &lt;code&gt;char&lt;/code&gt;. Similarly &lt;code&gt;USHRT_MAX&lt;/code&gt; may not be of an unsigned type: its type may be &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e53fd79bfcb21f431df2933e62abc3d8109fc8" translate="yes" xml:space="preserve">
          <source>Note: this allows the extreme case in which &lt;a href=&quot;https://en.wikipedia.org/wiki/Byte&quot;&gt;bytes&lt;/a&gt; are sized 64 bits, all types (including &lt;code&gt;char&lt;/code&gt;) are 64 bits wide, and &lt;code&gt;sizeof&lt;/code&gt; returns 1 for every type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d0bb27ce9ac9378f78496610c1e1579fd2ed42" translate="yes" xml:space="preserve">
          <source>Note: this example assumes the fix for the defect report 488 is applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10bc830558d4c21980b423c5e80abd41fce89959" translate="yes" xml:space="preserve">
          <source>Note: this functionality is encapsulated by the member functions of the &lt;a href=&quot;../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4c99bb12c3fe759c628a9c71020a2956856334d" translate="yes" xml:space="preserve">
          <source>Note: this is different from a function &lt;a href=&quot;parameter_pack&quot;&gt;parameter pack&lt;/a&gt; expansion, which is indicated by an ellipsis that is a part of a parameter declarator, rather than an ellipsis that appears after all parameter declarations. Both parameter pack expansion and the &quot;variadic&quot; ellipsis may appear in the declaration of a function template, as in the case of &lt;code&gt;&lt;a href=&quot;../types/is_function&quot;&gt;std::is_function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80e7b887d08d84d1012591f5aa7c42280185541f" translate="yes" xml:space="preserve">
          <source>Note: this rule makes it impractical to overload operators for standard library types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34bc80c6ea073c2eabf0048a5f86eed963a23cd0" translate="yes" xml:space="preserve">
          <source>Note: this taxonomy went through significant changes with past C++ standard revisions, see &lt;a href=&quot;value_category#History&quot;&gt;History&lt;/a&gt; below for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ccbee3198abb6b5d20babd6a5b09195db80d0dc" translate="yes" xml:space="preserve">
          <source>Note: unlike cv-qualification, ref-qualification does not change the properties of the &lt;a href=&quot;this&quot;&gt;this&lt;/a&gt; pointer: within a rvalue ref-qualified function, &lt;code&gt;*this&lt;/code&gt; remains an lvalue expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0358ee560358ee7e2a3e6f77dfcc3f7d746f56a2" translate="yes" xml:space="preserve">
          <source>Note: usual implementations of this feature use variants of the double-checked locking pattern, which reduces runtime overhead for already-initialized local statics to a single non-atomic boolean comparison.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dba6ec16507fb00d5ba5a9371fe90039085e538" translate="yes" xml:space="preserve">
          <source>Note: without consume operations,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d7fb1e9e2617731a6510250601bf3506560e32a" translate="yes" xml:space="preserve">
          <source>Nothrow (or nofail) exception guarantee</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c18f8f255ab9c208f23d0340eb9dff5a84efe311" translate="yes" xml:space="preserve">
          <source>Notification</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2681413eb86cdb4fb0d8b8e64b03fe6e40cf3340" translate="yes" xml:space="preserve">
          <source>Notifying while under the lock may nevertheless be necessary when precise scheduling of events is required, e.g. if the waiting thread would exit the program if the condition is satisfied, causing destruction of the notifying thread's condition_variable. A spurious wakeup after mutex unlock but before notify would result in notify called on a destroyed object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea73056ca8ffa23d466d5eccd6a9fc789b7938b" translate="yes" xml:space="preserve">
          <source>Null &lt;a href=&quot;named_req/forwarditerator&quot;&gt;LegacyForwardIterators&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1f9ecf4738c61169a1ccdb4d8f106c3c4c226a9" translate="yes" xml:space="preserve">
          <source>Null pointer dereference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74a6c19154380d505a46ba69085260f6a4e75ee8" translate="yes" xml:space="preserve">
          <source>Null pointers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="734b33e8414b7484bd2ff14ae7b5614eb947bbb3" translate="yes" xml:space="preserve">
          <source>Null pointers can be used to indicate the absence of an object (e.g. &lt;a href=&quot;../utility/functional/function/target&quot;&gt;&lt;code&gt;function::target()&lt;/code&gt;&lt;/a&gt;), or as other error condition indicators (e.g. &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt;). In general, a function that receives a pointer argument almost always needs to check if the value is null and handle that case differently (for example, the &lt;a href=&quot;delete&quot;&gt;delete expression&lt;/a&gt; does nothing when a null pointer is passed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8bcb3edd15cbd6e6166672877de87f1fab3bda9" translate="yes" xml:space="preserve">
          <source>Null-terminated byte string specifying the name of the error category.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3441a1d943445ee578773b9d59cdc4079e90e21" translate="yes" xml:space="preserve">
          <source>Null-terminated byte strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c161ff436191775822824d9815e2d14bf3d5ef2c" translate="yes" xml:space="preserve">
          <source>Null-terminated multibyte strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6f1ad95e8466de5e84bbca08e4713e68b2aff74" translate="yes" xml:space="preserve">
          <source>Null-terminated strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6819d3908d1c48a856ff9d9168156a39d8cb21db" translate="yes" xml:space="preserve">
          <source>Null-terminated strings - arrays of characters terminated by a special</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e22c8d62d81c353d25eebc2deca903b98ee39524" translate="yes" xml:space="preserve">
          <source>Null-terminated strings are arrays of characters that are terminated by a special</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="276d3b63150e3a49b557ab66f5dd4439a42688b3" translate="yes" xml:space="preserve">
          <source>Null-terminated wide strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6037ac6304093283e2ef7ddfd71b7131a4e4f4b3" translate="yes" xml:space="preserve">
          <source>NullablePointer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef7c5b602d153bcc79e971b62e8a021fd44a09fc" translate="yes" xml:space="preserve">
          <source>Number of arguments successfully read, or &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; if failure occurs before the first receiving argument was assigned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7ee14c49d4c61db6a013a574c7cfce97065d97f" translate="yes" xml:space="preserve">
          <source>Number of arguments successfully read, or &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; if failure occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="330a2e20d9a98f48f3ded7941eabd4b05bc25d4b" translate="yes" xml:space="preserve">
          <source>Number of characters copied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4828cb9d8e7ce319adebb043e6507b83e2a66cec" translate="yes" xml:space="preserve">
          <source>Number of concurrent threads supported. If the value is not well defined or not computable, returns &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cc88b2c95dbd46b721db96697ac264f6f796c6e" translate="yes" xml:space="preserve">
          <source>Number of elements in the valarray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26475ff1080313869de00180b385018931a09387" translate="yes" xml:space="preserve">
          <source>Number of elements with key that compares</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb2d7b79228be3f57fe401384b037bf13631d1bd" translate="yes" xml:space="preserve">
          <source>Number of objects read successfully, which may be less than &lt;code&gt;count&lt;/code&gt; if an error or end-of-file condition occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86cca45d2fcae9671b0048aa28f178ffb7205d99" translate="yes" xml:space="preserve">
          <source>Number of objects written successfully, which may be less than &lt;code&gt;count&lt;/code&gt; if an error occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9aeb17fef541fa9e033ea9acbb4825c99f28d23" translate="yes" xml:space="preserve">
          <source>Number of receiving arguments successfully assigned (which may be zero in case a matching failure occurred before the first receiving argument was assigned), or &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; if input failure occurs before the first receiving argument was assigned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f11e91a011e6a63e995692beaeeb59ccd16ce62" translate="yes" xml:space="preserve">
          <source>Number of wide characters written into the wide character array pointed to by &lt;code&gt;str&lt;/code&gt; not including the terminating &lt;code&gt;L'\0'&lt;/code&gt; on success. If &lt;code&gt;count&lt;/code&gt; was reached before the entire string could be stored, &lt;code&gt;​0​&lt;/code&gt; is returned and the contents are undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b260b6abdc7b3b852ea1fb3eb46025b53fe8d05a" translate="yes" xml:space="preserve">
          <source>Numeric algorithms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdce3587461747ea8e539471f185c10c52c6f51b" translate="yes" xml:space="preserve">
          <source>Numeric arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4409b6728588abb58f4d7de2d1db313ff1f17ea" translate="yes" xml:space="preserve">
          <source>Numeric conversions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cebed1a5c0cf52f77e684fdd8dd009684c0c9849" translate="yes" xml:space="preserve">
          <source>Numeric limits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d462e66d1c7babecab3c2ee81ac5f722b0c56d" translate="yes" xml:space="preserve">
          <source>Numeric operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2df5c380f4b256f85de04b3746566ab12e912822" translate="yes" xml:space="preserve">
          <source>Numeric operations on values in containers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ab02f04278eb772c7270dfe251be86282a05f1" translate="yes" xml:space="preserve">
          <source>Numeric parallel algorithms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13ebc00c39fa2da2a61ed182441549ea9fef0472" translate="yes" xml:space="preserve">
          <source>Numeric promotions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88d5c09346e26f2b2bd630e92f0baf5b8d970025" translate="yes" xml:space="preserve">
          <source>Numeric string conversion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d72ce186cc7de39c403fb19497d24929b54f39ed" translate="yes" xml:space="preserve">
          <source>NumericType</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d591b3b3904bb2a1b443dad3db0e4ae55b2fa358" translate="yes" xml:space="preserve">
          <source>Numerics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3813834df5cc68aa13369281b1eecf6782277ff5" translate="yes" xml:space="preserve">
          <source>Numerics library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0502cae581c8c2adfd167d5e245df29a7165791a" translate="yes" xml:space="preserve">
          <source>O(&lt;code&gt;size()&lt;/code&gt; * &lt;code&gt;v.size()&lt;/code&gt;) at worst.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9ee0ed6edf5e2e70bef9601b76897ef45d6a5ac" translate="yes" xml:space="preserve">
          <source>O(N&amp;middot;log(N)), where &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; comparisons on average.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="462479f73fa6d2da8bbf9adc0634414f8b3a5eff" translate="yes" xml:space="preserve">
          <source>O(N&amp;middot;log(N)), where &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; comparisons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02c44468fb3e233302081193a9b7d74c25fa83d5" translate="yes" xml:space="preserve">
          <source>O(N&amp;middot;log(N)&lt;sup&gt;2&lt;/sup&gt;), where &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; applications of &lt;code&gt;cmp&lt;/code&gt;. If additional memory is available, then the complexity is O(N&amp;middot;log(N)).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be3d0b49cdeda738fd3caf253b107aebd4073ce0" translate="yes" xml:space="preserve">
          <source>O(N&amp;middot;log(min(D,N)), where &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;, &lt;code&gt;D = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(d_first, d_last)&lt;/code&gt; applications of &lt;code&gt;cmp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="973dff30d21d38eeb129ed22c7137c9272599122" translate="yes" xml:space="preserve">
          <source>O(ie-ib)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bafad1d634c3aaf9b606ca34bc8104164807dc5" translate="yes" xml:space="preserve">
          <source>O(last - first) applications of &lt;code&gt;binary_op&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db770727920ab96655409f601e0718ded9d0cf50" translate="yes" xml:space="preserve">
          <source>O(last - first) applications of each of &lt;code&gt;binary_op&lt;/code&gt; and &lt;code&gt;unary_op&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="664d38267563e72356bb25754f52215a670a939d" translate="yes" xml:space="preserve">
          <source>O(last - first) applications of the binary operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a96dd0b6a9e18b76d45e21fc172d9de20a4c69a" translate="yes" xml:space="preserve">
          <source>O(r.size())</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99426b7d765d93ea22de5256b49c47b4aebd1152" translate="yes" xml:space="preserve">
          <source>O(re-rb)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="957fa96685c7d4c05482a30eeced4165e996ebc2" translate="yes" xml:space="preserve">
          <source>ODR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f36adea45204a02abafc415172bb999d9f8703d3" translate="yes" xml:space="preserve">
          <source>ODR-use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3823c4ce8a11ce79cb94ddaffb1edab017dc31d5" translate="yes" xml:space="preserve">
          <source>OGHAM LETTER BEITH - MONGOLIAN FREE VARIATION SELECTOR THREE</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9250b2677adf3b8e25990eff290a25954d1357f4" translate="yes" xml:space="preserve">
          <source>OR, if there was such an A, B may observe the result of some modification on M that is not &lt;code&gt;memory_order_seq_cst&lt;/code&gt; and does not</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38678aa96a7a3d61835226ca06fa7805d88fab6b" translate="yes" xml:space="preserve">
          <source>OR, if there wasn't such an A, B may observe the result of some unrelated modification of M that is not &lt;code&gt;memory_order_seq_cst&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="811e22c411253017bec425a0e0da1618bb36ec40" translate="yes" xml:space="preserve">
          <source>Object concepts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbadc7e81a91938aff49b43a5c2aa4d9c96b134d" translate="yes" xml:space="preserve">
          <source>Object in &lt;code&gt;X&lt;/code&gt; when &lt;code&gt;X&lt;/code&gt; supports multiple equivalent keys</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aa52864cb5dac41e6fbac4565b10e4f0d1a40e4" translate="yes" xml:space="preserve">
          <source>Object in &lt;code&gt;X&lt;/code&gt; when &lt;code&gt;X&lt;/code&gt; supports unique keys</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8713eb77151699db042ddeddf22b2ce0699ae7b4" translate="yes" xml:space="preserve">
          <source>Object of &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;X::value_type&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32822fd6d60578e8a6b661307ac3c2cf14a986fd" translate="yes" xml:space="preserve">
          <source>Object of type &lt;code&gt;A&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="626a675bfb4bd580fb619e05ee0786999059f369" translate="yes" xml:space="preserve">
          <source>Object of type &lt;code&gt;X::key_type&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c4515372c30b07db586a7f6901b88e937d95e93" translate="yes" xml:space="preserve">
          <source>Object of type &lt;code&gt;X::value_type&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ebfe6ad516f88bfd45db9c2e2c4fe652acbcc58" translate="yes" xml:space="preserve">
          <source>Object of type &lt;code&gt;X&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f0ebaceea0a3bb05a862b7d8603c46e6fcd053" translate="yes" xml:space="preserve">
          <source>Object of type &lt;code&gt;X&lt;/code&gt; (lvalue or const rvalue)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7550aeb4e54a7cf07bf4c5eb561017ea80857b00" translate="yes" xml:space="preserve">
          <source>Object of type &lt;code&gt;X&lt;/code&gt; (non-const rvalue)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01be238dbc3a6b7070b84afbbdbc2d72723b9f33" translate="yes" xml:space="preserve">
          <source>Object representation and value representation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd546c805dfba801ad9bca8f668ba26c4e9d94df" translate="yes" xml:space="preserve">
          <source>Object-like macros</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="210908b118295feeac5c2cba3daf5fcbcc2f82a6" translate="yes" xml:space="preserve">
          <source>Object-like macros replace every occurrence of defined identifier with replacement-list. Version (1) of the &lt;code&gt;#define&lt;/code&gt; directive behaves exactly like that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72a83add2c5ede877c10d23f302d3e17accbadab" translate="yes" xml:space="preserve">
          <source>Objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a8e0c93ea6ecc5753de84339467be1fc8dcfd39" translate="yes" xml:space="preserve">
          <source>Objects are created by &lt;a href=&quot;definition&quot;&gt;definitions&lt;/a&gt;, &lt;a href=&quot;new&quot;&gt;new-expressions&lt;/a&gt;, &lt;a href=&quot;throw&quot;&gt;throw-expressions&lt;/a&gt;, when changing the active member of a &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;, and where &lt;a href=&quot;lifetime#Temporary_object_lifetime&quot;&gt;temporary objects&lt;/a&gt; are required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b06cda6a8e82b06107e9df2adb69328bf89394c7" translate="yes" xml:space="preserve">
          <source>Objects of POD types are fully compatible with the C programming language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24aaf3ecb596e0fa939affaa8b0f860eb6809d15" translate="yes" xml:space="preserve">
          <source>Objects of a class type that declares or inherits at least one virtual function are polymorphic objects. Within each polymorphic object, the implementation stores additional information (in every existing implementation, it is one pointer unless optimized out), which is used by &lt;a href=&quot;virtual&quot;&gt;virtual function&lt;/a&gt; calls and by the RTTI features (&lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt; and &lt;a href=&quot;typeid&quot;&gt;typeid&lt;/a&gt;) to determine, at run time, the type with which the object was created, regardless of the expression it is used in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7c99d4433bf03d126d0f2c2bea79eb1f1713158" translate="yes" xml:space="preserve">
          <source>Objects of array type cannot be modified as a whole: even though they are &lt;a href=&quot;value_category&quot;&gt;lvalues&lt;/a&gt; (e.g. an address of array can be taken), they cannot appear on the left hand side of an assignment operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1cb9531c47382b80e38bccbf9a39f7142ef9cee" translate="yes" xml:space="preserve">
          <source>Objects of such type can be accessed after their storage is reallocated even if their copy constructors are not trivial.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c6de0058009753537395a6b4d9e573ea72fa4a0" translate="yes" xml:space="preserve">
          <source>Objects of the type &lt;code&gt;It&lt;/code&gt; provide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6e73e135d54851761d2bc282a301e83f71507d7" translate="yes" xml:space="preserve">
          <source>Objects of trivially-copyable types are the only C++ objects that may be safely copied with &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt; or serialized to/from binary files with &lt;a href=&quot;../io/basic_ostream/write&quot;&gt;&lt;code&gt;std::ofstream::write()&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;../io/basic_istream/read&quot;&gt;&lt;code&gt;std::ifstream::read()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41679686d3c9cbb53f73e69a50bf527de2d4f868" translate="yes" xml:space="preserve">
          <source>Objects of type &lt;code&gt;X&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59667643b8a48ace3f3043d1901eb2d1dd4fb6da" translate="yes" xml:space="preserve">
          <source>Objects of type &lt;code&gt;X&lt;/code&gt; (non-const lvalue)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e558d30a82029914f7a9f7e9a8d0574a2938e82a" translate="yes" xml:space="preserve">
          <source>Objects of type &lt;code&gt;path&lt;/code&gt; represent paths on a filesystem. Only syntactic aspects of paths are handled: the pathname may represent a non-existing path or even one that is not allowed to exist on the current file system or OS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8005179d8805b95a03da3ae014937cd2fdbc4ea0" translate="yes" xml:space="preserve">
          <source>Objects that hold instances of any &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0b16fad2157189ed63704b3fdb706c8521cb2e7" translate="yes" xml:space="preserve">
          <source>Objects that hold instances of any &lt;a href=&quot;named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0618a214d16e39be75c6315a11d086a7dcbea1b6" translate="yes" xml:space="preserve">
          <source>Observers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55f9f6eaf61434eff64a2e49877d431331ead473" translate="yes" xml:space="preserve">
          <source>Obstruction freedom</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93a5ca0b44c9ad0676a41753bc76c29cc473fd54" translate="yes" xml:space="preserve">
          <source>Obtain a value of type &lt;code&gt;To&lt;/code&gt; by reinterpreting the object representation of &lt;code&gt;from&lt;/code&gt;. Every bit in the value representation of the returned &lt;code&gt;To&lt;/code&gt; object is equal to the corresponding bit in the object representation of &lt;code&gt;from&lt;/code&gt;. The values of padding bits in the returned &lt;code&gt;To&lt;/code&gt; object are unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf2ee70f0a4a4f27457cedbbb34f22baba7d9f6" translate="yes" xml:space="preserve">
          <source>Obtain the address represented by &lt;code&gt;p&lt;/code&gt; without forming a reference to the pointee.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a6377ae8da9485d4525c5bf87eb51601ce0ebc8" translate="yes" xml:space="preserve">
          <source>Obtaining a pointer to an object created by placement &lt;code&gt;new&lt;/code&gt; from a pointer to an object providing storage for that object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9182ea7c1960d66685a0bcf0fe236829c468019" translate="yes" xml:space="preserve">
          <source>Obtaining a pointer to an object created in the storage of an existing object of the same type, where pointers to the old object cannot be &lt;a href=&quot;../language/lifetime#Storage_reuse&quot;&gt;reused&lt;/a&gt; because the object has &lt;code&gt;const&lt;/code&gt; or reference data members, or because either object is a base class subobject;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5819ba0dfb7bba1472fc39bc6d1086962bc935da" translate="yes" xml:space="preserve">
          <source>Obtains a &lt;code&gt;&lt;a href=&quot;../../../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;double&amp;gt;&lt;/code&gt; containing the individual probabilities of each integer that is generated by this distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a72393cd0391fba294bd0a2c60efb038982c5f2d" translate="yes" xml:space="preserve">
          <source>Obtains a &lt;code&gt;&lt;a href=&quot;../local_t&quot;&gt;std::chrono::local_time&lt;/a&gt;&amp;lt;duration&amp;gt;&lt;/code&gt; representing the local time in the time zone corresponding to the time point &lt;code&gt;*this&lt;/code&gt; represents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa613ad5379c017ed9fb9d2af84119e3022b53da" translate="yes" xml:space="preserve">
          <source>Obtains a &lt;code&gt;&lt;a href=&quot;../system_clock&quot;&gt;std::chrono::sys_time&lt;/a&gt;&amp;lt;duration&amp;gt;&lt;/code&gt; representing the same point in time as this &lt;code&gt;zoned_time&lt;/code&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78750735b856c43c14f67894c90fec9926bf3939" translate="yes" xml:space="preserve">
          <source>Obtains a pointer to a &lt;code&gt;std::chrono::time_zone&lt;/code&gt; in this database that represents the local time zone of the computer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f66c94d1a21a0e6cf6b0411022a20898fc78890" translate="yes" xml:space="preserve">
          <source>Obtains a pointer to a &lt;code&gt;std::chrono::time_zone&lt;/code&gt; in this database that represents the time zone designated by &lt;code&gt;tz_name&lt;/code&gt;. If &lt;code&gt;p&lt;/code&gt; is the returned pointer, then either &lt;code&gt;p-&amp;gt;name() == tz_name&lt;/code&gt; or that there is a &lt;code&gt;std::chrono::link&lt;/code&gt;&lt;code&gt;l&lt;/code&gt; in this database such that &lt;code&gt;p-&amp;gt;name() == l.target() and l.name() == tz_name&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a199df5aeb140e7ecb7d2bb82f6fbbe6f6f83da" translate="yes" xml:space="preserve">
          <source>Obtains a pointer to the object located at the address represented by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23c0738793997ac078f1770862b136fab15967b5" translate="yes" xml:space="preserve">
          <source>Obtains a reference to a facet implemented by &lt;code&gt;loc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e07f11994cadb52dbab2ac22f2ea1dbc18c1c3d" translate="yes" xml:space="preserve">
          <source>Obtains a reference to the &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; object representing the target sequence between the end of the entire match of the regular expression and the end of the target sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2585c12ba06ee495a72c893296797f36d66de6e" translate="yes" xml:space="preserve">
          <source>Obtains a reference to the &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; object representing the target sequence between the start of the beginning of the target sequence and the start of the entire match of the regular expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0d459ecf9a24d37f25def40024ae99f0de67b18" translate="yes" xml:space="preserve">
          <source>Obtains a reference to the &lt;code&gt;Ith&lt;/code&gt; element of the span &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27ed0770c884f54bc71c1629516d1af6f1d36c82" translate="yes" xml:space="preserve">
          <source>Obtains a reference to the C++ locale that implements the classic &quot;C&quot; locale semantics. This locale, unlike the global locale, cannot be altered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3d666f883ad9b1ce08f2e8bd3c52f2f50374a14" translate="yes" xml:space="preserve">
          <source>Obtains a reference to the first &lt;code&gt;std::chrono::tzdb&lt;/code&gt; in the list. Simultaneous calls to this function and &lt;code&gt;&lt;a href=&quot;../tzdb_functions&quot;&gt;std::chrono::reload_tzdb&lt;/a&gt;()&lt;/code&gt; does not introduce a data race.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b750bd8d0e1f8b95b17dd9c0a1624e233faad36f" translate="yes" xml:space="preserve">
          <source>Obtains a reference to the inner allocator used to declare this &lt;code&gt;scoped_allocator_adaptor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54e957f302399f6ff52bb49f2fc6d33e0987760a" translate="yes" xml:space="preserve">
          <source>Obtains a reference to the outer allocator used to declare this class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e3e94c0128e11e47f63539dd1729a07ed0afb79" translate="yes" xml:space="preserve">
          <source>Obtains a reference to the static error category object for errors reported by the operating system. The object is required to override the virtual function &lt;code&gt;&lt;a href=&quot;error_category/name&quot;&gt;std::error_category::name()&lt;/a&gt;&lt;/code&gt; to return a pointer to the string &lt;code&gt;&quot;system&quot;&lt;/code&gt;. It is also required to override the virtual function &lt;code&gt;&lt;a href=&quot;error_category/default_error_condition&quot;&gt;std::error_category::default_error_condition()&lt;/a&gt;&lt;/code&gt; to map the error codes that match POSIX &lt;code&gt;&lt;a href=&quot;errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; values to &lt;code&gt;&lt;a href=&quot;generic_category&quot;&gt;std::generic_category&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2da9d76d61fb5bb36fd083740c97f42ed0d76322" translate="yes" xml:space="preserve">
          <source>Obtains a reference to the static error category object for generic errors. The object is required to override the virtual function &lt;code&gt;error_category::name()&lt;/code&gt; to return a pointer to the string &lt;code&gt;&quot;generic&quot;&lt;/code&gt;. It is used to identify error conditions that correspond to the POSIX &lt;code&gt;&lt;a href=&quot;errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; codes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c605e5191e81e78868f91e809bfb703b9eddcfc4" translate="yes" xml:space="preserve">
          <source>Obtains a reference to the static error category object for iostream errors. The object is required to override the virtual function &lt;code&gt;error_category::name()&lt;/code&gt; to return a pointer to the string &lt;code&gt;&quot;iostream&quot;&lt;/code&gt;. It is used to identify error codes provided in the exceptions of type &lt;code&gt;&lt;a href=&quot;ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77953ea675597cd9a9e91106e2dee5602a4ddf21" translate="yes" xml:space="preserve">
          <source>Obtains a reference to the static error category object for the errors related to futures and promises. The object is required to override the virtual function &lt;code&gt;error_category::name()&lt;/code&gt; to return a pointer to the string &lt;code&gt;&quot;future&quot;&lt;/code&gt;. It is used to identify error codes provided in the exceptions of type &lt;code&gt;&lt;a href=&quot;../future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cb5c8aa5f1878afa5af80790808a2ffea17ad43" translate="yes" xml:space="preserve">
          <source>Obtains a span that is a view over the &lt;code&gt;Count&lt;/code&gt; elements of this span starting at offset &lt;code&gt;Offset&lt;/code&gt;. If &lt;code&gt;Count&lt;/code&gt; is &lt;code&gt;std::dynamic_extent&lt;/code&gt;, the number of elements in the subspan is &lt;code&gt;size() - offset&lt;/code&gt; (i.e., it ends at the end of &lt;code&gt;*this&lt;/code&gt;.).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11291925caa777c9e96a7fa79813c2860dfa2291" translate="yes" xml:space="preserve">
          <source>Obtains a span that is a view over the first &lt;code&gt;Count&lt;/code&gt; elements of this span. The behavior is undefined if &lt;code&gt;Count &amp;gt; size()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58ff680b8a70f2ae438cf2bfb21c78b690bebe2b" translate="yes" xml:space="preserve">
          <source>Obtains a span that is a view over the last &lt;code&gt;Count&lt;/code&gt; elements of this span. The behavior is undefined if &lt;code&gt;Count &amp;gt; size()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17ff76d692c73deae12a1ce8513cf222cc5b8245" translate="yes" xml:space="preserve">
          <source>Obtains a view to the object representation of the elements of the span &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="741f1158c89220a1208ee147c118f2cefb289de3" translate="yes" xml:space="preserve">
          <source>Obtains an estimate of the random number device entropy, which is a floating-point value between 0 and log</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff96bf9b4f1d702e2d2a5f6a4e57c354a4ade396" translate="yes" xml:space="preserve">
          <source>Obtains information about this time zone at the time point &lt;code&gt;tp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a940a841338e36fb1319155817147e7caf8ae2ee" translate="yes" xml:space="preserve">
          <source>Obtains the &lt;code&gt;std::chrono::sys_info&lt;/code&gt; containing information about the time zone at the time point stored in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75555d6c7e0658687a8809ed2025f906f60c5b0" translate="yes" xml:space="preserve">
          <source>Obtains the comparison key for the character &lt;code&gt;c&lt;/code&gt;, such that all characters that are equivalent to this character in the imbued locale produce the same key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="287fe3f5cb68314c1f92c873e5087f7bd3352438" translate="yes" xml:space="preserve">
          <source>Obtains the comparison key for the character &lt;code&gt;c&lt;/code&gt;, such that all characters that are equivalent to this character in the imbued locale, ignoring the case differences, if any, produce the same key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52d5cf6d91e7696d456bb789b921727fb5af3e1c" translate="yes" xml:space="preserve">
          <source>Obtains the components of the stored &quot;broken down&quot; time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bbe2be2263cdc44de47ac4c7498d43663d94b26" translate="yes" xml:space="preserve">
          <source>Obtains the date and time of the leap second insertion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6d41c6f1facb3d40b9c6d066e94206da754584f" translate="yes" xml:space="preserve">
          <source>Obtains the file position indicator and the current parse state (if any) for the file stream &lt;code&gt;stream&lt;/code&gt; and stores them in the object pointed to by &lt;code&gt;pos&lt;/code&gt;. The value stored is only meaningful as the input to &lt;code&gt;&lt;a href=&quot;fsetpos&quot;&gt;std::fsetpos&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e26d364709b0d5d0f6f9d584fb0c703f0e72e587" translate="yes" xml:space="preserve">
          <source>Obtains the implementation-defined pointer safety model, which is a value of type &lt;code&gt;&lt;a href=&quot;pointer_safety&quot;&gt;std::pointer_safety&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fcca311da5a166a7189f1c57847702d05f6beaa" translate="yes" xml:space="preserve">
          <source>Obtains the name of this time zone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11150f5df9c010974f2d88ef7744e762eb52b676" translate="yes" xml:space="preserve">
          <source>Obtains the sort key for the character sequence &lt;code&gt;[first, last)&lt;/code&gt;, such that if a sort key compares less than another sort key with &lt;code&gt;operator&amp;lt;&lt;/code&gt;, then the character sequence that produced the first sort key comes before the character sequence that produced the second sort key, in the currently imbued locale's collation order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0f80a5203eea5e8ff9c3b959902152bfdf4bc27" translate="yes" xml:space="preserve">
          <source>Octal escape sequences have a limit of three octal digits, but terminate at the first character that is not a valid octal digit if encountered sooner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0bec24e9696d27cf08958354034635bb4aaece6" translate="yes" xml:space="preserve">
          <source>Of the octal escape sequences, &lt;code&gt;\0&lt;/code&gt; is the most useful because it represents the terminating null character in &lt;a href=&quot;../string#Null-terminated_strings&quot;&gt;null-terminated strings&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd3e148e40b10f66f157d96dcabb7e10a90e73ef" translate="yes" xml:space="preserve">
          <source>Old binders and adaptors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25092126616369de84306344473c79f3b40f25ca" translate="yes" xml:space="preserve">
          <source>Old inheriting constructor semantics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96517468346738d15926bb84a828637627a520af" translate="yes" xml:space="preserve">
          <source>Omits copy and move(since C++11) constructors, resulting in zero-copy pass-by-value semantics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2be2d27a9413c57c267219bbe7c19d917e453ba8" translate="yes" xml:space="preserve">
          <source>On POSIX systems, &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; is measured in seconds, and &lt;code&gt;difftime&lt;/code&gt; is equivalent to arithmetic subtraction, but C and C++ allow fractional units for &lt;code&gt;time_t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1c2e2785945c453b7d4fcd0927d9266fd008a9e" translate="yes" xml:space="preserve">
          <source>On POSIX systems, the &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html#tag_08&quot;&gt;environment variables&lt;/a&gt; are also accessible through the global variable &lt;code&gt;environ&lt;/code&gt;, declared as &lt;code&gt;extern char **environ;&lt;/code&gt; in &lt;code&gt;&amp;lt;unistd.h&amp;gt;&lt;/code&gt;, and through the optional third argument, &lt;code&gt;envp&lt;/code&gt;, of &lt;a href=&quot;../../language/main_function&quot;&gt;the main function&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a6213d8e479c8e10ba794901f531bb56c23f23" translate="yes" xml:space="preserve">
          <source>On POSIX systems, the generic format is the native format and there is no need to distinguish or convert between them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ac183701c3b851b7c302643295e573f09b7e8a2" translate="yes" xml:space="preserve">
          <source>On POSIX systems, the path may be the one specified in the environment variables &lt;code&gt;TMPDIR&lt;/code&gt;, &lt;code&gt;TMP&lt;/code&gt;, &lt;code&gt;TEMP&lt;/code&gt;, &lt;code&gt;TEMPDIR&lt;/code&gt;, and, if none of them are specified, the path &lt;code&gt;&quot;/tmp&quot;&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c15eedd26e0a4296a1da805d0e3e7c292000d81" translate="yes" xml:space="preserve">
          <source>On POSIX systems, the return value can be decomposed using &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html&quot;&gt;WEXITSTATUS and WSTOPSIG&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="665d5086b1532ee0356a31704d302a2da59f9bc5" translate="yes" xml:space="preserve">
          <source>On POSIX systems, there is no difference between native and generic format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="387a3ad8371405b5ff22d5b298cf2dcfea40ae46" translate="yes" xml:space="preserve">
          <source>On POSIX systems, this function call usually translates to a call to &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/catclose.html&quot;&gt;catclose()&lt;/a&gt;&lt;/code&gt;. In GNU libstdc++, which is implemented in terms of GNU &lt;code&gt;gettext()&lt;/code&gt;, it does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8c26027d661e64f39fd1db7dc5a1e1c99cf1707" translate="yes" xml:space="preserve">
          <source>On POSIX systems, this function call usually translates to a call to &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/catgets.html&quot;&gt;catgets()&lt;/a&gt;&lt;/code&gt;, and the parameters &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;msgid&lt;/code&gt;, and &lt;code&gt;dfault&lt;/code&gt; are passed to &lt;code&gt;catgets()&lt;/code&gt; as-is. In GNU libstdc++, this function ignores &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;msgid&lt;/code&gt; and simply calls GNU &lt;code&gt;gettext(dfault)&lt;/code&gt; in the required locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7de5bb4c46774c0939e109999ce22671b7d7cf56" translate="yes" xml:space="preserve">
          <source>On POSIX systems, this function call usually translates to a call to &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/catopen.html&quot;&gt;catopen()&lt;/a&gt;&lt;/code&gt;. In GNU libstdc++, it calls &lt;code&gt;&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/libstdc%20%20/manual/facets.html&quot;&gt;textdomain&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a2f78fabe409eee66034b5f2478c5dcdd5e6e58" translate="yes" xml:space="preserve">
          <source>On POSIX systems, this function typically calls &lt;code&gt;unlink&lt;/code&gt; and &lt;code&gt;rmdir&lt;/code&gt; as needed, on Windows &lt;code&gt;RemoveDirectoryW&lt;/code&gt; and &lt;code&gt;DeleteFileW&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98b83dd9352b620facc9e27430b33eed43bac0b0" translate="yes" xml:space="preserve">
          <source>On POSIX-compatible systems, &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/clock_getres.html&quot;&gt;clock_gettime&lt;/a&gt;&lt;/code&gt; with clock id &lt;code&gt;CLOCK_PROCESS_CPUTIME_ID&lt;/code&gt; offers better resolution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f64ca1d35fd7fa8462051c761d36435acc412d6e" translate="yes" xml:space="preserve">
          <source>On Windows OS, no attributes of &lt;code&gt;existing_p&lt;/code&gt; are copied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5e8fa4d3aeb00c9b66d74d815ef83a5f9a145f5" translate="yes" xml:space="preserve">
          <source>On Windows systems, the path is typically the one returned by &lt;code&gt;GetTempPath&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4acdb8f2ddee2220ca922da85e84eeab752fb1f4" translate="yes" xml:space="preserve">
          <source>On Windows, the returned path has backslashes (the preferred separators),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="511afa2193ba5adba8d98f3780b92c82adc015d6" translate="yes" xml:space="preserve">
          <source>On a binary system (where &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;), &lt;code&gt;frexp&lt;/code&gt; may be implemented as.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="925065b863ea73d746978a917ec3660043bee763" translate="yes" xml:space="preserve">
          <source>On a friend function template declaration, default template arguments are allowed only if the declaration is a definition, and no other declarations of this function appear in this translation unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8f51d9c7df6295ff2f4a594fc3b9141d105f282" translate="yes" xml:space="preserve">
          <source>On a non-POSIX system, it is possible that &lt;code&gt;p.stem()+p.extension() != p.filename()&lt;/code&gt; even though generic-format versions are the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce877e2c542fd9b52cb204b343fc97d8d48dd27c" translate="yes" xml:space="preserve">
          <source>On all mainstream CPUs other than DEC Alpha, dependency ordering is automatic, no additional CPU instructions are issued for this synchronization mode, only certain compiler optimizations are affected (e.g. the compiler is prohibited from performing speculative loads on the objects that are involved in the dependency chain).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b05b0d014a061e77483d4c22ffab959e47192e32" translate="yes" xml:space="preserve">
          <source>On binary systems (where &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;), &lt;code&gt;std::ldexp&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;scalbn&quot;&gt;std::scalbn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e5fb1b541a4a88aab9c82c7b427c089d7cbf5d7" translate="yes" xml:space="preserve">
          <source>On binary systems (where &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;), &lt;code&gt;std::scalbn&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;ldexp&quot;&gt;std::ldexp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8708cad68d33790eb6a4bf0ddccb5f0164d4580" translate="yes" xml:space="preserve">
          <source>On construction, and on every increment, it calls &lt;code&gt;&lt;a href=&quot;regex_search&quot;&gt;std::regex_search&lt;/a&gt;&lt;/code&gt; and remembers the result (that is, saves a copy of the value &lt;code&gt;&lt;a href=&quot;match_results&quot;&gt;std::match_results&lt;/a&gt;&amp;lt;BidirIt&amp;gt;&lt;/code&gt;). The first object may be read when the iterator is constructed or when the first dereferencing is done. Otherwise, dereferencing only returns a copy of the most recently obtained regex match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b73ca167e9c9962f0b8c94d731c9108d233235b9" translate="yes" xml:space="preserve">
          <source>On construction, it constructs an &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt; and on every increment it steps through the requested sub-matches from the current match_results, incrementing the underlying &lt;code&gt;regex_iterator&lt;/code&gt; when incrementing away from the last submatch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="087359845b5b67b00ed993f690fa6adf5c0e9eeb" translate="yes" xml:space="preserve">
          <source>On conversion error (if invalid multibyte character was encountered), returns &lt;code&gt;static_cast&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt; (-1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61ad57ff0bc4c1db2e358738f13de35997712946" translate="yes" xml:space="preserve">
          <source>On conversion error (if invalid multibyte character was encountered), returns &lt;code&gt;static_cast&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;(-1)&lt;/code&gt;, stores &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt;, and leaves &lt;code&gt;*ps&lt;/code&gt; in unspecified state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25b5559e308dd2a841b436c80ca7723845ff400b" translate="yes" xml:space="preserve">
          <source>On conversion error (if invalid wide character was encountered), returns &lt;code&gt;static_cast&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;(-1)&lt;/code&gt;, stores &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt;, and leaves &lt;code&gt;*ps&lt;/code&gt; in unspecified state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e7999b033f539dd397fab3a198ec737997e2801" translate="yes" xml:space="preserve">
          <source>On conversion error (if invalid wide character was encountered), returns &lt;code&gt;static_cast&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;(-1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27af2898a4a7fabe09802617c5f4179e50049d1f" translate="yes" xml:space="preserve">
          <source>On entry to the signal handler, the state of the &lt;a href=&quot;../../numeric/fenv&quot;&gt;floating-point environment&lt;/a&gt; and the values of all objects is unspecified, except for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf64fe345becc9748fcf71d684a78039172c25c6" translate="yes" xml:space="preserve">
          <source>On error, returns a null pointer. &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fopen.html&quot;&gt;POSIX requires&lt;/a&gt; that &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; is set in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f894090439f0ad5733e1535dc9cfab616760242" translate="yes" xml:space="preserve">
          <source>On error, returns a value of type &lt;code&gt;to_chars_result&lt;/code&gt; holding &lt;code&gt;&lt;a href=&quot;../error/errc&quot;&gt;std::errc::value_too_large&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;ec&lt;/code&gt;, a copy of the value &lt;code&gt;last&lt;/code&gt; in &lt;code&gt;ptr&lt;/code&gt;, and leaves the contents of the range &lt;code&gt;[first, last)&lt;/code&gt; in unspecified state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67be4bbad4bc7d42350f335f561c5cc7c994e21c" translate="yes" xml:space="preserve">
          <source>On failure (if &lt;code&gt;c16&lt;/code&gt; is not a valid 16-bit character), returns &lt;code&gt;-1&lt;/code&gt;, stores &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt;, and leaves &lt;code&gt;*ps&lt;/code&gt; in unspecified state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2e516929dc5a0ac17642b157f095d35eed936fc" translate="yes" xml:space="preserve">
          <source>On failure (if &lt;code&gt;c32&lt;/code&gt; is not a valid 32-bit character), returns &lt;code&gt;-1&lt;/code&gt;, stores &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt;, and leaves &lt;code&gt;*ps&lt;/code&gt; in unspecified state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55678d405b6fbaacf2e84d0559262bd23bedf5ea" translate="yes" xml:space="preserve">
          <source>On failure (if &lt;code&gt;wc&lt;/code&gt; is not a valid wide character), returns &lt;code&gt;static_cast&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;(-1)&lt;/code&gt;, stores &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt;, and leaves &lt;code&gt;*ps&lt;/code&gt; in unspecified state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="142bfef5c33048366493d43376a7bde55e0f4637" translate="yes" xml:space="preserve">
          <source>On failure &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; is returned and the given stream remains unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b59034111d1fe69518d421a29472104cf3b1d3e3" translate="yes" xml:space="preserve">
          <source>On failure &lt;code&gt;WEOF&lt;/code&gt; is returned and the given stream remains unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f36c4844b99ce462a6865da138b7ee8a696c89b" translate="yes" xml:space="preserve">
          <source>On failure, returns &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; and sets the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcd79a4ce724e0f85bbc5af6b0ba614e86f4c729" translate="yes" xml:space="preserve">
          <source>On failure, returns a null pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="224d44817b74239b9d60b6778faec8205182255f" translate="yes" xml:space="preserve">
          <source>On failure, returns a null pointer. The original pointer &lt;code&gt;ptr&lt;/code&gt; remains valid and may need to be deallocated with &lt;code&gt;&lt;a href=&quot;free&quot;&gt;std::free()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37709412dec80afc97847eb5be24994009a7a6e4" translate="yes" xml:space="preserve">
          <source>On gcc and clang, some of the functionality described here requires linking against &lt;code&gt;-latomic&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1bf711404d47b14c3829dbfe5bbf1b29d1b2ee4" translate="yes" xml:space="preserve">
          <source>On implementations that support floating-point infinities, these macros always expand to the positive infinities of &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;long double&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="816e3d2d9c4d7bcce1004338b43b9958281113ad" translate="yes" xml:space="preserve">
          <source>On many implementations, &lt;code&gt;std::ldexp&lt;/code&gt; is less efficient than multiplication or division by a power of two using arithmetic operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13a6ebd0b3f331800ebab3eb88281db31bb09676" translate="yes" xml:space="preserve">
          <source>On many implementations, line buffering is only available for terminal input streams.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dae6cfb19aec260bc05f2964584fe1ea9c86a969" translate="yes" xml:space="preserve">
          <source>On many platforms, a single CPU instruction obtains both the quotient and the remainder, and this function may leverage that, although compilers are generally able to merge nearby / and % where suitable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99ead43d5ca2046d96df18919f7b22fd1aaa0b5a" translate="yes" xml:space="preserve">
          <source>On most platforms integer division by zero always traps, and &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::traps&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all integer types that support the value 0. The exception is the type &lt;code&gt;bool&lt;/code&gt;: even though division by &lt;code&gt;false&lt;/code&gt; traps due to integral promotion from &lt;code&gt;bool&lt;/code&gt; to &lt;code&gt;int&lt;/code&gt;, it is the zero-valued &lt;code&gt;int&lt;/code&gt; that traps. Zero is not a value of type &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0d642f2cf129be448a7e4461ecf9cebb1166788" translate="yes" xml:space="preserve">
          <source>On most platforms, floating-point exceptions may be turned on and off at run time (e.g. &lt;code&gt;feenableexcept()&lt;/code&gt; on Linux or &lt;code&gt;_controlfp&lt;/code&gt; on Windows), in which case the value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::traps&lt;/code&gt; for floating-point types reflects the state of floating-point trapping facility at the time of program startup, which is &lt;code&gt;false&lt;/code&gt; on most modern systems. An exception would be a DEC Alpha program, where it is &lt;code&gt;true&lt;/code&gt; if compiled without &lt;code&gt;-ieee&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="910cb13c40253742bc1c068635374b5f8b4b88cb" translate="yes" xml:space="preserve">
          <source>On return from a signal handler, the value of any object modified by the signal handler that is not &lt;code&gt;volatile &lt;a href=&quot;sig_atomic_t&quot;&gt;std::sig_atomic_t&lt;/a&gt;&lt;/code&gt; or lock-free &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; is indeterminate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e4f90b334bb36a5d646f35472bd9278b6dd264d" translate="yes" xml:space="preserve">
          <source>On some implementations (e.g. Linux), this function actually creates, opens, and immediately deletes the file from the file system: as long as an open file descriptor to a deleted file is held by a program, the file exists, but since it was deleted, its name does not appear in any directory, so that no other process can open it. Once the file descriptor is closed, the space occupied by the file is reclaimed by the filesystem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dd2c2923877872be297b89c9fea77391101b399" translate="yes" xml:space="preserve">
          <source>On some implementations (e.g. Windows), elevated privileges are required as the function may create the temporary file in a system directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59f0abd0ce648082fea259a7345528a91cff9f99" translate="yes" xml:space="preserve">
          <source>On some platforms this operation is supported by hardware (and, for example, on Intel CPUs, &lt;code&gt;FPREM1&lt;/code&gt; leaves exactly 3 bits of precision in the quotient when complete).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39a8ce59d8dc85c2962717623b86954b6c06d0f6" translate="yes" xml:space="preserve">
          <source>On strongly-ordered systems &amp;mdash; x86, SPARC TSO, IBM mainframe, etc. &amp;mdash; release-acquire ordering is automatic for the majority of operations. No additional CPU instructions are issued for this synchronization mode; only certain compiler optimizations are affected (e.g., the compiler is prohibited from moving non-atomic stores past the atomic store-release or performing non-atomic loads earlier than the atomic load-acquire). On weakly-ordered systems (ARM, Itanium, PowerPC), special CPU load or memory fence instructions are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77b723cf592ca1c577d1c9cb505cf08a127e9073" translate="yes" xml:space="preserve">
          <source>On success &lt;code&gt;ch&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4761c7a6227f38804881200e2df99d7b35533a7" translate="yes" xml:space="preserve">
          <source>On success, returns a non-negative value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eccd88aed68331ce568fa5fbf3710b123b4917f" translate="yes" xml:space="preserve">
          <source>On success, returns a pointer to the beginning of newly allocated memory. To avoid a memory leak, the returned pointer must be deallocated with &lt;code&gt;&lt;a href=&quot;free&quot;&gt;std::free()&lt;/a&gt;&lt;/code&gt;, the original pointer &lt;code&gt;ptr&lt;/code&gt; is invalidated and any access to it is &lt;a href=&quot;../../language/ub&quot;&gt;undefined behavior&lt;/a&gt; (even if reallocation was in-place).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="654dbab2951e8c34d782d1e1b8f012bfe2c220ea" translate="yes" xml:space="preserve">
          <source>On success, returns a value of type &lt;code&gt;from_chars_result&lt;/code&gt; such that &lt;code&gt;ptr&lt;/code&gt; points at the first character not matching the pattern, or has the value equal to &lt;code&gt;last&lt;/code&gt; if all characters match and &lt;code&gt;ec&lt;/code&gt; is value-initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98414481a412cddea0b3a19288007bb595593e8e" translate="yes" xml:space="preserve">
          <source>On success, returns a value of type &lt;code&gt;to_chars_result&lt;/code&gt; such that &lt;code&gt;ec&lt;/code&gt; equals value-initialized &lt;code&gt;&lt;a href=&quot;../error/errc&quot;&gt;std::errc&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;ptr&lt;/code&gt; is the one-past-the-end pointer of the characters written. Note that the string is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d81549f78d66a2cb785195d52fbfccefea065c28" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes (including any shift sequences) written to the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dba1cbf33ab0a48de8403edd177cbc0bf277ec1" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes (including any shift sequences) written to the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;. This value may be &lt;code&gt;​0​&lt;/code&gt;, e.g. when processing the first &lt;code&gt;char16_t&lt;/code&gt; in a surrogate pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f4ad471b8dbea619fc3d1a043ff0b9baa938953" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes (including any shift sequences) written to the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;. This value may be &lt;code&gt;​0​&lt;/code&gt;, e.g. when processing the first &lt;code&gt;char32_t&lt;/code&gt; in multi-&lt;code&gt;char32_t&lt;/code&gt;-character sequence (does not occur in UTF-32).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5777d8d1ea77ffa9ae480cd6b418c58e7daa18f6" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes (including any shift sequences, but excluding the terminating &lt;code&gt;'\0'&lt;/code&gt;) written to the character array whose first element is pointed to by &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9f5a019dc26110145207d886c164b9a925432b9" translate="yes" xml:space="preserve">
          <source>On success, returns the number of bytes (including any shift sequences, but excluding the terminating &lt;code&gt;'\0'&lt;/code&gt;) written to the character array whose first element is pointed to by &lt;code&gt;dst&lt;/code&gt;. If &lt;code&gt;dst==&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, returns the number of bytes that would have been written (again, excluding the terminating null character &lt;code&gt;'\0'&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd561943474439ac1b2c134122634210f1d6080d" translate="yes" xml:space="preserve">
          <source>On success, returns the number of wide characters, excluding the terminating &lt;code&gt;L'\0'&lt;/code&gt;, written to the character array. If &lt;code&gt;dst==&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, returns the number of wide characters that would have been written given unlimited length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc15db7be0c1e650ce9730f8dd13748fd20e66db" translate="yes" xml:space="preserve">
          <source>On success, returns the number of wide characters, excluding the terminating &lt;code&gt;L'\0'&lt;/code&gt;, written to the destination array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fae4a8552a4c5daf69ded009ab3120ad8482b19f" translate="yes" xml:space="preserve">
          <source>On success, returns the pointer to the beginning of newly allocated memory. To avoid a memory leak, the returned pointer must be deallocated with &lt;code&gt;&lt;a href=&quot;free&quot;&gt;std::free()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;std::realloc()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d22776bf531bc73082a0ec726f2851ed0748b9fd" translate="yes" xml:space="preserve">
          <source>On success, returns the pointer to the beginning of newly allocated memory. To avoid a memory leak, the returned pointer must be deallocated with &lt;code&gt;&lt;a href=&quot;free&quot;&gt;std::free()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;std::realloc()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d902746b34d07703c051d8b0c20c3a4f074b9dbd" translate="yes" xml:space="preserve">
          <source>On success, returns the written character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25842231e5f1261393531367ba40379a28b61ec1" translate="yes" xml:space="preserve">
          <source>On systems that support sparse files, increasing the file size does not increase the space it occupies on the file system: space allocation takes place only when non-zero bytes are written to the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbf799df205efb8d682e4cca556b3802bac520e2" translate="yes" xml:space="preserve">
          <source>On systems where native path format differs from the generic path format (neither Windows nor POSIX systems are examples of such OSes), if the argument to this function is using generic format, it will be converted to native.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="654813a474d7f1feaa5498a158649f23b8e604b2" translate="yes" xml:space="preserve">
          <source>On the append file access modes, data is written to the end of the file regardless of the current position of the file position indicator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d488e75f75412837a367decd020fa055b9c98806" translate="yes" xml:space="preserve">
          <source>On the other hand, pImpl classes are move-friendly; refactoring a large class as movable pImpl may improve performance of algorithms that manipulate containers holding such objects, although movable pImpl has an additional source of runtime overhead: any public member function that is permitted on a moved-from object and needs access to private implementation incurs a null pointer check.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55168b0e0480f7d50d40c1e646165c5f05ca9d4f" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;std::cin&lt;/code&gt; is constructed, &lt;code&gt;std::cin.tie()&lt;/code&gt; returns &lt;code&gt;&amp;amp;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt;, and likewise, &lt;code&gt;std::wcin.tie()&lt;/code&gt; returns &lt;code&gt;&amp;amp;&lt;a href=&quot;cout&quot;&gt;std::wcout&lt;/a&gt;&lt;/code&gt;. This means that any formatted input operation on &lt;code&gt;std::cin&lt;/code&gt; forces a call to &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt;.flush()&lt;/code&gt; if any characters are pending for output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8271fc595e4d43c784ea0eeba1fc195911705282" translate="yes" xml:space="preserve">
          <source>Once a return statement has been seen in a function, the return type deduced from that statement can be used in the rest of the function, including in other return statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="487be362503fbdcc1d20b997658e90641cded0b5" translate="yes" xml:space="preserve">
          <source>Once created, &lt;code&gt;link&lt;/code&gt; and &lt;code&gt;target&lt;/code&gt; are two logical names that refer to the same file (they are &lt;a href=&quot;equivalent&quot;&gt;&lt;code&gt;equivalent&lt;/code&gt;&lt;/a&gt;). Even if the original name &lt;code&gt;target&lt;/code&gt; is deleted, the file continues to exist and is accessible as &lt;code&gt;link&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a68d37c7c212d32b98d1089266290c5e643b5f1f" translate="yes" xml:space="preserve">
          <source>Once initialized, &lt;code&gt;(std::cerr.flags() &amp;amp; unitbuf) != 0&lt;/code&gt; (same for &lt;code&gt;wcerr&lt;/code&gt;) meaning that any output sent to these stream objects is immediately flushed to the OS (via &lt;code&gt;&lt;a href=&quot;basic_ostream/sentry&quot;&gt;std::basic_ostream::sentry&lt;/a&gt;&lt;/code&gt;'s destructor).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="364b8f60431dbcac07f3d34ec6cce24b5ce938c8" translate="yes" xml:space="preserve">
          <source>Once initialized, &lt;code&gt;std::cout&lt;/code&gt; is &lt;code&gt;tie()&lt;/code&gt;'d to &lt;code&gt;&lt;a href=&quot;cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;std::wcout&lt;/code&gt; is tie()'d to &lt;code&gt;&lt;a href=&quot;cin&quot;&gt;std::wcin&lt;/a&gt;&lt;/code&gt;, meaning that any input operation on &lt;code&gt;&lt;a href=&quot;cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt; executes &lt;code&gt;std::cout.flush()&lt;/code&gt; (via &lt;code&gt;&lt;a href=&quot;basic_istream/sentry&quot;&gt;std::basic_istream::sentry&lt;/a&gt;&lt;/code&gt;'s constructor).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49de59ffd7c4574c553e8cb5b31bb014070b9c95" translate="yes" xml:space="preserve">
          <source>Once initialized, &lt;code&gt;std::cout&lt;/code&gt; is also &lt;code&gt;tie()&lt;/code&gt;'d to &lt;code&gt;&lt;a href=&quot;cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;std::wcout&lt;/code&gt; is tie()'d to &lt;code&gt;&lt;a href=&quot;cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt;, meaning that any output operation on &lt;code&gt;&lt;a href=&quot;cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; executes &lt;code&gt;std::cout.flush()&lt;/code&gt; (via &lt;code&gt;&lt;a href=&quot;basic_ostream/sentry&quot;&gt;std::basic_ostream::sentry&lt;/a&gt;&lt;/code&gt;'s constructor) (since C++11).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="150dc4dec5bdc7c21e6c28226b531c21891daa37" translate="yes" xml:space="preserve">
          <source>Once registered, a callback cannot be deregistered: it remains a part of the stream object for the rest of its lifetime. If the behavior of a callback needs to change, it may be controlled through &lt;code&gt;&lt;a href=&quot;iword&quot;&gt;iword()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;pword&quot;&gt;pword()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7220e3502e0667bb3db03f122ebc95f853d81e5" translate="yes" xml:space="preserve">
          <source>Once the exception object is constructed, the control flow works backwards (up the call stack) until it reaches the start of a &lt;a href=&quot;try_catch&quot;&gt;try block&lt;/a&gt;, at which point the parameters of all associated &lt;code&gt;catch&lt;/code&gt; blocks are compared, in order of appearance, with the type of the exception object to find a match (see &lt;a href=&quot;try_catch&quot;&gt;try-catch&lt;/a&gt; for details on this process). If no match is found, the control flow continues to unwind the stack until the next &lt;code&gt;try&lt;/code&gt; block, and so on. If a match is found, the control flow jumps to the matching &lt;code&gt;catch&lt;/code&gt; block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36108800d5a1b36044a555a73b1b921ec1b5cc0f" translate="yes" xml:space="preserve">
          <source>One &lt;a href=&quot;../../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for &lt;code&gt;&lt;a href=&quot;../reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; to support deduction of the sole class template parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0209d9e1bbcc40078b75c784003c419a2d61a892" translate="yes" xml:space="preserve">
          <source>One &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for &lt;code&gt;&lt;a href=&quot;../array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; to provide an equivalent of &lt;code&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/make_array&quot;&gt;std::experimental::make_array&lt;/a&gt;&lt;/code&gt; for construction of std::array from a variadic parameter pack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88463128e6f2da0470f59a02821590d0b39b13c3" translate="yes" xml:space="preserve">
          <source>One &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for &lt;code&gt;&lt;a href=&quot;../optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt; to account for the edge cases missed by the implicit deduction guides, in particular, non-copyable arguments and array to pointer conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e408cc038fc978d0469e472c3df5f4f24c09960f" translate="yes" xml:space="preserve">
          <source>One &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for &lt;code&gt;&lt;a href=&quot;../pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; to account for the edge cases missed by the implicit deduction guides.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd3eb78061c6680fd352bea50600b0f0b0c66136" translate="yes" xml:space="preserve">
          <source>One &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for &lt;code&gt;&lt;a href=&quot;../scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&lt;/code&gt; to make it possible to deduce its outer allocator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e51d13c036c7b811ca8b73cbebc8f92d228563d6" translate="yes" xml:space="preserve">
          <source>One &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; to account for the edge case missed by the implicit deduction guides.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cda17a1075ed23e7b49730d40746b579bd70e4d6" translate="yes" xml:space="preserve">
          <source>One Definition Rule</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f229fb26e09bf62724cca3c308dc55e48ba4377a" translate="yes" xml:space="preserve">
          <source>One and only one definition of a class is required to appear in any translation unit where the class is used in a way that requires it to be &lt;a href=&quot;incomplete_type&quot;&gt;complete&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="308fc3805df9c5a8b51d77140bbf4961e49eb536" translate="yes" xml:space="preserve">
          <source>One and only one definition of every non-&lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt; function or variable that is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f8a0d1dc6c54d0dd3d1bfacbdd17859d1609c6" translate="yes" xml:space="preserve">
          <source>One early solution for this can be seen in &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt;, which defines &lt;code&gt;operator!&lt;/code&gt; and &lt;code&gt;operator void*&lt;/code&gt;(until C++11), so that the code such as &lt;code&gt;if(&lt;a href=&quot;../io/cin&quot;&gt;std::cin&lt;/a&gt;) {...}&lt;/code&gt; compiles because &lt;code&gt;void*&lt;/code&gt; is convertible to &lt;code&gt;bool&lt;/code&gt;, but &lt;code&gt;int n = &lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt;;&lt;/code&gt; does not compile because &lt;code&gt;void*&lt;/code&gt; is not convertible to &lt;code&gt;int&lt;/code&gt;. This still allows nonsense code such as &lt;code&gt;delete &lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt;;&lt;/code&gt; to compile, and many pre-C++11 third party libraries were designed with a more elaborate solution, known as the &lt;a href=&quot;http://en.wikibooks.org/wiki/More_C%20%20_Idioms/Safe_bool&quot;&gt;Safe Bool idiom&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ed394631d3f8d4aadd579117b4f6de9705ff1b" translate="yes" xml:space="preserve">
          <source>One exception is when the type of the function parameter is rvalue reference to type template parameter (&quot;forwarding reference&quot; or &quot;universal reference&quot;), in which case &lt;code&gt;&lt;a href=&quot;forward&quot;&gt;std::forward&lt;/a&gt;&lt;/code&gt; is used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01cd8b9a71033cfee6c07469ef7cacf0e158e0ef" translate="yes" xml:space="preserve">
          <source>One notable exception is Visual Studio, where, with default settings, every volatile write has release semantics and every volatile read has acquire semantics (&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/12a04hfd(v=vs.100).aspx&quot;&gt;MSDN&lt;/a&gt;), and thus volatiles may be used for inter-thread synchronization. Standard &lt;code&gt;volatile&lt;/code&gt; semantics are not applicable to multithreaded programming, although they are sufficient for e.g. communication with a &lt;code&gt;&lt;a href=&quot;../utility/program/signal&quot;&gt;std::signal&lt;/a&gt;&lt;/code&gt; handler that runs in the same thread when applied to &lt;code&gt;sig_atomic_t&lt;/code&gt; variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eb713d58049ae96d31ae1ab30234359f9a283f3" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;u8&lt;/code&gt;, &lt;code&gt;u&lt;/code&gt;, &lt;code&gt;U&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b176a8b02968a11548e55a7fdc53518d77a3a5fc" translate="yes" xml:space="preserve">
          <source>One of the following is true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="619eab222261e41d3e97992c89dc1576ccc5b0c6" translate="yes" xml:space="preserve">
          <source>One of the uses of the constant expression is (along with the &lt;a href=&quot;noexcept&quot;&gt;&lt;code&gt;noexcept&lt;/code&gt; operator&lt;/a&gt;) to define function templates that declare &lt;code&gt;noexcept&lt;/code&gt; for some types but not others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7db279cde63f8e18e515054f91f7dc906b5b6271" translate="yes" xml:space="preserve">
          <source>One-past-the-end of the match sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="737b68dded00328bb417ea32c2c776fbc1fd2032" translate="yes" xml:space="preserve">
          <source>Only (possibly cv-qualified) non-POD class types (or arrays thereof) with automatic storage duration were considered to be default-initialized when no initializer is used. Scalars and POD types with dynamic storage duration were considered to be not initialized (since C++11, this situation was reclassified as a form of default initialization).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd34ac27cb2ed53817b28c2b73fcdf5ab6b87ba4" translate="yes" xml:space="preserve">
          <source>Only 1:1 character mapping can be performed by this function, e.g. the Greek uppercase letter '&amp;Sigma;' has two lowercase forms, depending on the position in a word: '&amp;sigma;' and '&amp;sigmaf;'. A call to &lt;code&gt;do_tolower&lt;/code&gt; cannot be used to obtain the correct lowercase form in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d055ef859a1891a53fc0313650d880e8478e7d3" translate="yes" xml:space="preserve">
          <source>Only 1:1 character mapping can be performed by this function, e.g. the Greek uppercase letter '&amp;Sigma;' has two lowercase forms, depending on the position in a word: '&amp;sigma;' and '&amp;sigmaf;'. A call to &lt;code&gt;std::tolower&lt;/code&gt; cannot be used to obtain the correct lowercase form in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="466d5420b19f439ace8bd81c12647c095dd15073" translate="yes" xml:space="preserve">
          <source>Only 1:1 character mapping can be performed by this function, e.g. the Greek uppercase letter '&amp;Sigma;' has two lowercase forms, depending on the position in a word: '&amp;sigma;' and '&amp;sigmaf;'. A call to &lt;code&gt;std::towlower&lt;/code&gt; cannot be used to obtain the correct lowercase form in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ff2ccb84f657ddcebd4e937c70204ced6a16e48" translate="yes" xml:space="preserve">
          <source>Only 1:1 character mapping can be performed by this function, e.g. the uppercase form of '&amp;szlig;' is (with some exceptions) the two-character string &quot;SS&quot;, which cannot be obtained by &lt;code&gt;do_toupper&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde35f20592569c5b1b81600f907f7bb7af42ed8" translate="yes" xml:space="preserve">
          <source>Only 1:1 character mapping can be performed by this function, e.g. the uppercase form of '&amp;szlig;' is (with some exceptions) the two-character string &quot;SS&quot;, which cannot be obtained by &lt;code&gt;std::toupper&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c12ba1955593af4c39e23b24749b2da65bb020b" translate="yes" xml:space="preserve">
          <source>Only 1:1 character mapping can be performed by this function, e.g. the uppercase form of '&amp;szlig;' is (with some exceptions) the two-character string &quot;SS&quot;, which cannot be obtained by &lt;code&gt;std::towupper&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="607527ceabb3d1a0904b5a3250d6585ee9742c8b" translate="yes" xml:space="preserve">
          <source>Only arithmetic, enumeration, pointer, pointer to member, and class type arguments are allowed (except class types with non-trivial copy constructor, non-trivial move constructor, or a non-trivial destructor, which are conditionally-supported with implementation-defined semantics).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08736a3db142d4465ab11afbcfc6d21c5872d6d3" translate="yes" xml:space="preserve">
          <source>Only constant expressions that are used in types (such as array bounds) were required to be treated as SFINAE (and not hard errors) before C++11.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df7f87f165c312cced9d18c34a873a0ab047c4c9" translate="yes" xml:space="preserve">
          <source>Only if both arguments are NaN, NaN is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56896d0f83ceaa9c78caabf142a61ad70903054c" translate="yes" xml:space="preserve">
          <source>Only if causes rehash</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fadc3c4f14514b8568465cc25f90ac9950ee9f18" translate="yes" xml:space="preserve">
          <source>Only lambda-expressions defined at block scope or in a &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializer&lt;/a&gt; may have a capture-default or captures without initializers. For such lambda-expression, the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a858101436593d9deaac72471d777b9fc2b5fec" translate="yes" xml:space="preserve">
          <source>Only literal types may be used as parameters to or returned from &lt;a href=&quot;../language/constexpr&quot;&gt;constexpr functions&lt;/a&gt;. Only literal classes may have constexpr member functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9664c7378a1c8d7cdea0cf25b21d02f05205788" translate="yes" xml:space="preserve">
          <source>Only match a sub-sequence that begins at</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f66d7d03fc6b31093651b5a2e2f045c4a47e58c" translate="yes" xml:space="preserve">
          <source>Only non-const &lt;code&gt;unique_ptr&lt;/code&gt; can transfer the ownership of the managed object to another &lt;code&gt;unique_ptr&lt;/code&gt;. If an object's lifetime is managed by a &lt;code&gt;const std::unique_ptr&lt;/code&gt;, it is limited to the scope in which the pointer was created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b73bfa3f72adafffdf0da68582f64d9a0532c4fa" translate="yes" xml:space="preserve">
          <source>Only one definition of any variable, function, class type, enumeration type, &lt;a href=&quot;constraints&quot;&gt;concept&lt;/a&gt;(since C++20) or template is allowed in any one translation unit (some of these may have multiple declarations, but only one definition is allowed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eabf9530cbef995b5dcb4f673cb51bf696e85624" translate="yes" xml:space="preserve">
          <source>Only one storage class specifier may appear in a declaration except that &lt;code&gt;thread_local&lt;/code&gt; may be combined with &lt;code&gt;static&lt;/code&gt; or with &lt;code&gt;extern&lt;/code&gt;(since C++11).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01794fe3947565d881ce29925429530cc7001695" translate="yes" xml:space="preserve">
          <source>Only pointers to elements of the same array (including the pointer one past the end of the array) may be subtracted from each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a46aa1168e6e9cddb697be4164e5f628ae8c809" translate="yes" xml:space="preserve">
          <source>Only replace the first match in &lt;code&gt;&lt;a href=&quot;regex_replace&quot;&gt;std::regex_replace&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8326fc75f023d2a0e3b3b43c5ba8fed1d24d6556" translate="yes" xml:space="preserve">
          <source>Only safely-derived pointers (pointers to objects allocated with new or subobjects thereof) may be dereferenced or deallocated. Garbage collector may be active.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd82b7402593aae6d81f792ec6ab8f4ea571f6f9" translate="yes" xml:space="preserve">
          <source>Only specialized if &lt;code&gt;&lt;a href=&quot;../types/is_object&quot;&gt;std::is_object_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1654d6337936fd9311214835d3a1ef0951c89d5" translate="yes" xml:space="preserve">
          <source>Only the declaration is required to be visible when explicitly instantiating a function template, a variable template, a member function or static data member of a class template, or a member function template. The complete definition must appear before the explicit instantiation of a class template, a member class of a class template, or a member class template, unless an explicit specialization with the same template arguments appeared before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c02a96acd332b8f147fb372fd53b292443f0fef7" translate="yes" xml:space="preserve">
          <source>Only the default constructor is publicly accessible. Instances of &lt;code&gt;sub_match&lt;/code&gt; are normally constructed and populated as a part of a &lt;code&gt;&lt;a href=&quot;match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt; container during the processing of one of the regex algorithms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0fde2096f2d54f8b0a65ce16d5c25c750380f7f" translate="yes" xml:space="preserve">
          <source>Only the difference between two values returned by different calls to &lt;code&gt;std::clock&lt;/code&gt; is meaningful, as the beginning of the &lt;code&gt;std::clock&lt;/code&gt; era does not have to coincide with the start of the program. &lt;code&gt;std::clock&lt;/code&gt; time may advance faster or slower than the wall clock, depending on the execution resources given to the program by the operating system. For example, if the CPU is shared by other processes, &lt;code&gt;std::clock&lt;/code&gt; time may advance slower than wall clock. On the other hand, if the current process is multithreaded and more than one execution core is available, &lt;code&gt;std::clock&lt;/code&gt; time may advance faster than wall clock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61179af34a1ef93980ea250a5902555e6c969e35" translate="yes" xml:space="preserve">
          <source>Only the failures in the types and expressions in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4f66e23190ef94fa7d137ed8cfb330f9759cee0" translate="yes" xml:space="preserve">
          <source>Only the first array dimension may generate this exception; dimensions other than the first are constant expressions and are checked at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bcd10d4cd83c1fc738b067ddf928202f35a6109" translate="yes" xml:space="preserve">
          <source>Only the first character of the string returned is the character that appears in the &lt;code&gt;&lt;a href=&quot;pos_format&quot;&gt;pos_format()&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;pos_format&quot;&gt;neg_format()&lt;/a&gt;&lt;/code&gt; position indicated by the value &lt;code&gt;sign&lt;/code&gt;. The rest of the characters appear</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="562b41c076433411e05c790e584fb8f5f2abea3f" translate="yes" xml:space="preserve">
          <source>Only the following attributes are defined by the C++ standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9f2bc5576afd3e9a1cad1e7e3207b1b21a2d4d7" translate="yes" xml:space="preserve">
          <source>Only the following conversions can be done with &lt;code&gt;const_cast&lt;/code&gt;. In particular, only &lt;code&gt;const_cast&lt;/code&gt; may be used to cast away (remove) constness or volatility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bcee30de9e9de90e84c5de6ef3fa72963738531" translate="yes" xml:space="preserve">
          <source>Only the following conversions can be done with &lt;code&gt;dynamic_cast&lt;/code&gt;, except when such conversions would cast away</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db66b03add4571e7494c6d25f531615b76c83fd4" translate="yes" xml:space="preserve">
          <source>Only the following conversions can be done with &lt;code&gt;reinterpret_cast&lt;/code&gt;, except when such conversions would cast away</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87d3fcc69182f005c9275ab2df4fef2bfc014fdc" translate="yes" xml:space="preserve">
          <source>Only the following conversions can be done with &lt;code&gt;static_cast&lt;/code&gt;, except when such conversions would cast away</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f3cc2761742bbeb85a9119337c72c1fffa9e2e6" translate="yes" xml:space="preserve">
          <source>Only the following names can refer to the current instantiation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f1b5bc66dd1a422d75a3658e563b5e0d8b2d676" translate="yes" xml:space="preserve">
          <source>Only the following parameter lists are allowed on literal operators :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98ad7639be08d68176aae272ec1c4da3d63a5067" translate="yes" xml:space="preserve">
          <source>Only the innermost enclosing namespace is considered by such friend declaration when deciding whether the name would conflict with a previously declared name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7711fc1d988a7889d23d504ed8b37f9a6e7b0c98" translate="yes" xml:space="preserve">
          <source>Only the name explicitly mentioned in the using-declaration is transferred into the declarative scope: in particular, enumerators are not transferred when the enumeration type name is using-declared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bba08a8a551fc816cffbdb50cf77dc1c8dfe5479" translate="yes" xml:space="preserve">
          <source>Only throws if construction of &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;F&amp;gt;::type&lt;/code&gt; from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt; throws, or any of the constructors for &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;Arg_i&amp;gt;::type&lt;/code&gt; from the corresponding &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Arg_i&amp;gt;(arg_i)&lt;/code&gt; throws where &lt;code&gt;Arg_i&lt;/code&gt; is the ith type and &lt;code&gt;arg_i&lt;/code&gt; is the ith argument in &lt;code&gt;Args... args&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a6e5a9725e6777f63d908891009ad06a5e509e9" translate="yes" xml:space="preserve">
          <source>Only throws if construction of stored function object or any of the bound arguments throws.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04637f8282d20bfde6272d6807ed9db65c5f4d57" translate="yes" xml:space="preserve">
          <source>Only throws if the operations on &lt;code&gt;begin&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; throw.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95bb7aee14019b92f66174058cef3a642e8a59b8" translate="yes" xml:space="preserve">
          <source>Only to the element erased</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30ec03d7a305043d2db2f7a9a950a4a4fa038fdb" translate="yes" xml:space="preserve">
          <source>Only to the element erased and the past-the-end iterator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c557dd26b1fbacbd999d23442d0ea7c5ce38080" translate="yes" xml:space="preserve">
          <source>Only two language linkages are guaranteed to be supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbaf30a1862ab9d1fba3ed59e9bf3e6079ee2a2d" translate="yes" xml:space="preserve">
          <source>Only works for floating-point &lt;code&gt;T&lt;/code&gt; if &lt;code&gt;NaN&lt;/code&gt;s are avoided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="224673beb8d4f0ba5eba8d91a2c4f77d5a45f52d" translate="yes" xml:space="preserve">
          <source>Opaque enum declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="237cef659815822d78b56d19a7c946bfbf74be1f" translate="yes" xml:space="preserve">
          <source>Open a file for read/write</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3186d8ed0fca34a6a2c7ee13f69f2d2feb00ab05" translate="yes" xml:space="preserve">
          <source>Open a file for reading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2814adaeddb6356ec6a721abd08a26c793736a87" translate="yes" xml:space="preserve">
          <source>Opens a file indicated by &lt;code&gt;filename&lt;/code&gt; and returns a file stream associated with that file. &lt;code&gt;mode&lt;/code&gt; is used to determine the file access mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cba5cafcd25d7e44d9b9947551af788a0a10a469" translate="yes" xml:space="preserve">
          <source>Opens and associates the file with name &lt;code&gt;filename&lt;/code&gt; with the file stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3edc46283ae3e649f4749e8ca9a178bcfb75a7aa" translate="yes" xml:space="preserve">
          <source>Opens the file with the given name (&lt;code&gt;s&lt;/code&gt;, &lt;code&gt;p.c_str()&lt;/code&gt;(since C++17) or &lt;code&gt;str.c_str()&lt;/code&gt;, depending on the overload).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2dad54d8bce08503c34abc283c6fe74bd2e9ffc" translate="yes" xml:space="preserve">
          <source>Operation canceled</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bebd2907ca9295d99796ea50ee317a1fc881504c" translate="yes" xml:space="preserve">
          <source>Operation in progress</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ef925607b43bca64c3829868d9989b76540d3a" translate="yes" xml:space="preserve">
          <source>Operation not permitted</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c49e2a256113761881fb1a1fa41d066e27d70d15" translate="yes" xml:space="preserve">
          <source>Operation not supported on socket</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db648ff618df972b87b0f378a6996fcda48575ee" translate="yes" xml:space="preserve">
          <source>Operation would block</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aad80c3935d5d5ecad18b2860064a0c35395b3c6" translate="yes" xml:space="preserve">
          <source>Operational semantics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1fdaa6b2a846c8fcf18d414bf8c61db610eda6a" translate="yes" xml:space="preserve">
          <source>Operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6c85d3a9084d36a05de8cba4e937453b249e0cb" translate="yes" xml:space="preserve">
          <source>Operations on atomic types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="456fb30fb01febdf98b1f26b7ae1bde8ca3ee080" translate="yes" xml:space="preserve">
          <source>Operations on files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47fa820f04ca552ec4ed35543e9476bfabd42fc2" translate="yes" xml:space="preserve">
          <source>Operations on traits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25b21d22e495afeaacb3360487cb6d0bd8e44988" translate="yes" xml:space="preserve">
          <source>Operations on uninitialized memory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab53f8310f5b3d7c33f42f382419ed45034e50e" translate="yes" xml:space="preserve">
          <source>Operator Precedence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20f7836ec6e259271b7f669f114842c024b3bcc5" translate="yes" xml:space="preserve">
          <source>Operator function objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4a9b8c2a6b5cbbd63ba1d94acea6a8712598917" translate="yes" xml:space="preserve">
          <source>Operator functions shall not have default arguments, except for the function call operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="819ccd81b85bc3b38f4cc9446e71367abf393235" translate="yes" xml:space="preserve">
          <source>Operator name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bf7c09224d4e5f03f06eb1166a0d0d5843b1570" translate="yes" xml:space="preserve">
          <source>Operator overloading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="685048571a4f4db99cb190b311def264fc71eb0e" translate="yes" xml:space="preserve">
          <source>Operator precedence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc65d3b81d568d31b16581936246eda5c79f9504" translate="yes" xml:space="preserve">
          <source>Operator precedence is unaffected by &lt;a href=&quot;operators&quot;&gt;operator overloading&lt;/a&gt;. For example, &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; a ? b : c;&lt;/code&gt; parses as &lt;code&gt;(&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; a) ? b : c;&lt;/code&gt; because the precedence of arithmetic left shift is higher than the conditional operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f71b1b50b892d42d414d9d838c5b4edebbee4b6" translate="yes" xml:space="preserve">
          <source>Operators that have the same precedence are bound to their arguments in the direction of their associativity. For example, the expression &lt;code&gt;a = b = c&lt;/code&gt; is parsed as &lt;code&gt;a = (b = c)&lt;/code&gt;, and not as &lt;code&gt;(a = b) = c&lt;/code&gt; because of right-to-left associativity of assignment, but &lt;code&gt;a + b - c&lt;/code&gt; is parsed &lt;code&gt;(a + b) - c&lt;/code&gt; and not &lt;code&gt;a + (b - c)&lt;/code&gt; because of left-to-right associativity of addition and subtraction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bad5323a62aef1bd7dda4fa50f9fc65f2307dd28" translate="yes" xml:space="preserve">
          <source>Optional Member functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e9bde0e36aef16d24f484d92725ec1e8600d3e8" translate="yes" xml:space="preserve">
          <source>Optional sequence of specifiers.The following specifiers are allowed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78b124f382e217ea07fd12a5a1a10b0aa026188e" translate="yes" xml:space="preserve">
          <source>Optional single quotes(&lt;code&gt;'&lt;/code&gt;) can be inserted between the digits as a separator, they are ignored when compiling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03fb8ba5767ba6be97ba025e44a0e037fd575cd6" translate="yes" xml:space="preserve">
          <source>Optional single quotes(&lt;code&gt;'&lt;/code&gt;) may be inserted between the digits as a separator. They are ignored by the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adfec8b2c3956d87a55574de5b2d880bf1eb5af9" translate="yes" xml:space="preserve">
          <source>Optional, variant and any</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22dbe3df9cebc886193148944f2049829d611dce" translate="yes" xml:space="preserve">
          <source>Or, for a more complex example (note: &quot;S::N&quot; would not compile: scope resolution qualifiers are not something that can be deduced):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21ab442b56e6693d449e1b3316a7c72b27f04270" translate="yes" xml:space="preserve">
          <source>Order of evaluation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c51ac972dce9f79628fdc83c6bdd3346dafed6b" translate="yes" xml:space="preserve">
          <source>Order of the conversions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a96c32b4c7b0c17ae2c25cc6af8e7ff3583d1633" translate="yes" xml:space="preserve">
          <source>Ordered dynamic initialization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b3df585822a5aa71af2864093c3784252d8d05a" translate="yes" xml:space="preserve">
          <source>Originally (in C89), support for zero size was added to accommodate code such as.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e6a6f2086bb5fe5dbfd17d8d5f502d48759834b" translate="yes" xml:space="preserve">
          <source>Other</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fa415238a9b66b6553c659b682e9a771c79560b" translate="yes" xml:space="preserve">
          <source>Other contexts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c0e832aaebdbd2463766c9b11e2e90be9a8a71c" translate="yes" xml:space="preserve">
          <source>Other macro constants beginning with &lt;code&gt;TIME_&lt;/code&gt; may be provided by the implementation to indicate additional time bases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53cadf7190b6345bb407e7fc51d1bdd4e62d2ef9" translate="yes" xml:space="preserve">
          <source>Other members as expected of an iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22490909ecb721f0620f7d5b993ac0c5478e639a" translate="yes" xml:space="preserve">
          <source>Other models are very rare. For example, &lt;b&gt;ILP64&lt;/b&gt; (&lt;b&gt;8/8/8&lt;/b&gt;: int, long, and pointer are 64-bit) only appeared in some early 64-bit Unix systems (e.g. Unicos on Cray).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b76fa7f3048e6a48072816b2d8249799561dddee" translate="yes" xml:space="preserve">
          <source>Other operations on sorted ranges</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aecde2c1ff0650ce54e7e724236337f0082c7af4" translate="yes" xml:space="preserve">
          <source>Other operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="074ecef61395fde816b484cba633da0414f1ad4e" translate="yes" xml:space="preserve">
          <source>Other requirements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22882bbd963e5965181dd6ac5f0e32f08e0b65b5" translate="yes" xml:space="preserve">
          <source>Other runtime support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fe8af971c95a161f7416215231bab7f2aee1e58" translate="yes" xml:space="preserve">
          <source>Other than by throwing or rethrowing the exception, the catch-clause after a regular try block (not &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt;) may be exited with a &lt;a href=&quot;return&quot;&gt;return&lt;/a&gt;, &lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;, &lt;a href=&quot;break&quot;&gt;break&lt;/a&gt;, &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;, or by reaching the end of its compound-statement. In any case, this destroys the exception object (unless an instance of &lt;code&gt;&lt;a href=&quot;../error/exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; exists that refers to it).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fa362c57764eecfc4b78da221398dc7e37176cd" translate="yes" xml:space="preserve">
          <source>Other than the restrictions above, literal operators and literal operator templates are normal functions (and function templates), they can be declared inline or constexpr, they may have internal or external linkage, they can be called explicitly, their addresses can be taken, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9c9def660f19f5e2dfb42949584bb83f7489b67" translate="yes" xml:space="preserve">
          <source>Other than the restrictions above, the language puts no other constraints on what the overloaded operators do, or on the return type (it does not participate in overload resolution), but in general, overloaded operators are expected to behave as similar as possible to the built-in operators: &lt;code&gt;operator+&lt;/code&gt; is expected to add, rather than multiply its arguments, &lt;code&gt;operator=&lt;/code&gt; is expected to assign, etc. The related operators are expected to behave similarly (&lt;code&gt;operator+&lt;/code&gt; and &lt;code&gt;operator+=&lt;/code&gt; do the same addition-like operation). The return types are limited by the expressions in which the operator is expected to be used: for example, assignment operators return by reference to make it possible to write &lt;code&gt;a = b = c = d&lt;/code&gt;, because the built-in operators allow that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f36114bde1ef97dac03fc66dc98d4f3a201c1e1" translate="yes" xml:space="preserve">
          <source>Other users have execute/search permission</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f59d7eb3a7340c4a40079493fb96f89382ca1396" translate="yes" xml:space="preserve">
          <source>Other users have read permission</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d99a2bb8f92a2fce0c660eede0edf07671134bc5" translate="yes" xml:space="preserve">
          <source>Other users have read, write, and execute/search permissions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81e28c487731b188a254a0c6063165399fa6a265" translate="yes" xml:space="preserve">
          <source>Other users have write permission</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55538ef3b729291f7a8559a423ae426eadbb7da1" translate="yes" xml:space="preserve">
          <source>Otherwise (for non-UTF-8 narrow character encodings and for non-UTF-16 wchar_t), first converts the UTF-8 character sequence to a temporary UTF-32-encoded string &lt;code&gt;tmp&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::u32string&lt;/a&gt;&lt;/code&gt;, and then the new path is constructed as if by &lt;code&gt;path(tmp)&lt;/code&gt; (this path is taken on a POSIX system with a non-Unicode multibyte or single-byte encoded filesystem)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c78644885980035d5732ab1eff699570371d6fd9" translate="yes" xml:space="preserve">
          <source>Otherwise (if -1 is not in the list of submatches), turns &lt;code&gt;*this&lt;/code&gt; into the end-of-sequence iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d8dfd29fb905134a265d7ac8ecff5409e192a4a" translate="yes" xml:space="preserve">
          <source>Otherwise (if &lt;code&gt;T&lt;/code&gt; is not a class type), if the braced-init-list has only one element and either &lt;code&gt;T&lt;/code&gt; isn't a reference type or is a reference type that is compatible with the type of the element, &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialized&lt;/a&gt; (in direct-list-initialization) or &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialized&lt;/a&gt; (in copy-list-initialization), except that narrowing conversions are not allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="962858afb2628881a16223d5ef1fe009edbeb91e" translate="yes" xml:space="preserve">
          <source>Otherwise (if &lt;code&gt;arg&lt;/code&gt; is not zero), if no errors occur, returns the value &lt;code&gt;x&lt;/code&gt; in the range &lt;code&gt;(-1;-0.5], [0.5; 1)&lt;/code&gt; and stores an integer value in &lt;code&gt;*exp&lt;/code&gt; such that x&amp;times;2(*exp)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4877a579d0634ed999b6da7267e551ea3225cca2" translate="yes" xml:space="preserve">
          <source>Otherwise (if &lt;code&gt;year().ok() &amp;amp;&amp;amp; month().ok()&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;), the return value is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e23da0e159ca34882578c5e1fb972498c32dc655" translate="yes" xml:space="preserve">
          <source>Otherwise (if T is a cv- or ref-qualified function type), provides the member typedef &lt;code&gt;type&lt;/code&gt; which is the type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bc54a386c3a7403b4e4e568932a9ef9a1b15628" translate="yes" xml:space="preserve">
          <source>Otherwise (if every Ti is &lt;a href=&quot;strong_ordering&quot;&gt;&lt;code&gt;std::strong_ordering&lt;/code&gt;&lt;/a&gt;, or if the list is empty), U is &lt;a href=&quot;strong_ordering&quot;&gt;&lt;code&gt;std::strong_ordering&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a5982ab593c5756eb7fa3d22408653aa4b842d4" translate="yes" xml:space="preserve">
          <source>Otherwise (if neither &lt;code&gt;T&lt;/code&gt; nor the type of other are class types), &lt;a href=&quot;implicit_cast&quot;&gt;standard conversions&lt;/a&gt; are used, if necessary, to convert the value of other to the cv-unqualified version of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8b1e7d6939fc131d8f5321733560aac95e1c21b" translate="yes" xml:space="preserve">
          <source>Otherwise (if neither &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; nor &lt;code&gt;a == b&lt;/code&gt; are well-formed), the function is defined as deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1be67c76cd22937dad7aa28c25a83ece1f57ac4" translate="yes" xml:space="preserve">
          <source>Otherwise (if the emit-on-sync policy is &lt;code&gt;false&lt;/code&gt;, which is the default), the flush is suspended until &lt;a href=&quot;emit&quot;&gt;&lt;code&gt;emit()&lt;/code&gt;&lt;/a&gt; is called, such as through &lt;a href=&quot;../basic_osyncstream/emit&quot;&gt;&lt;code&gt;std::basic_osyncstream::emit()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../basic_osyncstream/~basic_osyncstream&quot;&gt;&lt;code&gt;std::basic_osyncstream::~basic_osyncstream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d765ea43f56124dc7f201449473995791be29cd" translate="yes" xml:space="preserve">
          <source>Otherwise (if the member &lt;code&gt;regex_iterator&lt;/code&gt; is an end-of-sequence iterator), but the value &lt;code&gt;-1&lt;/code&gt; is one of the values in &lt;code&gt;submatches&lt;/code&gt;/&lt;code&gt;submatch&lt;/code&gt;, turns &lt;code&gt;*this&lt;/code&gt; into a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6261c7822db9d6599ca29b1216e33aded5b0a63" translate="yes" xml:space="preserve">
          <source>Otherwise (such as if the subobject contains a reference member or a const subobject), the name of the original subobject cannot be used to access the new object without &lt;code&gt;&lt;a href=&quot;../utility/launder&quot;&gt;std::launder&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98392ac79a4607ebcb6f65c7f67baf409719c115" translate="yes" xml:space="preserve">
          <source>Otherwise - all iterators are invalidated (including the past-the-end iterator).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6001603adf1e4ac6322bc1bc6ebb6e214fe2994e" translate="yes" xml:space="preserve">
          <source>Otherwise - none iterators are invalidated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0572ee1a235e86c40330d91d5ba8b005204797d6" translate="yes" xml:space="preserve">
          <source>Otherwise &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; is defined as if by using its name instead of &lt;code&gt;[&lt;/code&gt;identifier-list&lt;code&gt;]&lt;/code&gt; in the declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43f34a783250f550e789597c18a4c8a2f51527ac" translate="yes" xml:space="preserve">
          <source>Otherwise a value &lt;code&gt;f&lt;/code&gt; such that &lt;code&gt;X​::​eq_int_type(f, X​::​eof())&lt;/code&gt; is false</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91cfa0a3ab90e039c72f98dee8402cde70f286a7" translate="yes" xml:space="preserve">
          <source>Otherwise does nothing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30f0c779f084e1d04e86445afcbfff562a459eec" translate="yes" xml:space="preserve">
          <source>Otherwise returns &lt;code&gt;*lhs &amp;gt; *rhs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc623b7e42fa5f7168a6ce9cdaa7652f0d8db2eb" translate="yes" xml:space="preserve">
          <source>Otherwise returns &lt;code&gt;*lhs &amp;gt;= *rhs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7cbc58e399fb790bf7696e2e3548fc378941157" translate="yes" xml:space="preserve">
          <source>Otherwise returns &lt;code&gt;*lhs &amp;lt; *rhs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97e5d1f3c4df1c942182f4c377e75ad9e8f16302" translate="yes" xml:space="preserve">
          <source>Otherwise returns &lt;code&gt;*lhs &amp;lt;= *rhs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="618fc39ddea35e304af4790e3e94a95ae92ea8ac" translate="yes" xml:space="preserve">
          <source>Otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c16a42a412a45b4529dffb91b084d38c1d81dc6" translate="yes" xml:space="preserve">
          <source>Otherwise returns a value less than, equal to or greater than 0 if the relative portion of the path (&lt;a href=&quot;relative_path&quot;&gt;&lt;code&gt;relative_path()&lt;/code&gt;&lt;/a&gt;) is respectively lexicographically less than, equal to or greater than the relative portion of &lt;code&gt;p&lt;/code&gt; (&lt;code&gt;p.relative_path()&lt;/code&gt;). Comparison is performed element-wise, as if by iterating both paths from &lt;a href=&quot;begin&quot;&gt;&lt;code&gt;begin()&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;begin&quot;&gt;&lt;code&gt;end()&lt;/code&gt;&lt;/a&gt; and comparing the result of &lt;a href=&quot;native&quot;&gt;&lt;code&gt;native()&lt;/code&gt;&lt;/a&gt; for each element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca18099a2b5d3ff51a05a0f259cd50e3f53224ac" translate="yes" xml:space="preserve">
          <source>Otherwise the behavior is undefined(until C++17)&lt;code&gt;&lt;a href=&quot;../bad_weak_ptr&quot;&gt;std::bad_weak_ptr&lt;/a&gt;&lt;/code&gt; is thrown (by the shared_ptr constructor from a default-constructed &lt;code&gt;weak_this&lt;/code&gt;)(since C++17).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbd6ff0ecfd2300fc4cce2459c5260f6d53089ec" translate="yes" xml:space="preserve">
          <source>Otherwise the implicitly-declared copy assignment operator is declared as &lt;code&gt;T&amp;amp; T::operator=(T&amp;amp;)&lt;/code&gt;. (Note that due to these rules, the implicitly-declared copy assignment operator cannot bind to a volatile lvalue argument.).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="292522615db91e7f79b2d960d8135abed952e41b" translate="yes" xml:space="preserve">
          <source>Otherwise the operator increments &lt;code&gt;start&lt;/code&gt; and continues as if the most recent match was not a zero-length match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69afcfa9da40a3a14e9e305e85e0ae11ecd8ebca" translate="yes" xml:space="preserve">
          <source>Otherwise the value is unspecified</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d9bc18b21194155ea10d0ea79b6439d4c3e5a90" translate="yes" xml:space="preserve">
          <source>Otherwise,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4f6b7b2fd2da4908eb7913b4aac52d5c9e031f4" translate="yes" xml:space="preserve">
          <source>Otherwise, (if there is no &lt;a href=&quot;weak_equality&quot;&gt;&lt;code&gt;std::weak_equality&lt;/code&gt;&lt;/a&gt; and no &lt;a href=&quot;strong_equality&quot;&gt;&lt;code&gt;std::strong_equality&lt;/code&gt;&lt;/a&gt;) if at least one Ti is &lt;a href=&quot;partial_ordering&quot;&gt;&lt;code&gt;std::partial_ordering&lt;/code&gt;&lt;/a&gt;, U is &lt;a href=&quot;partial_ordering&quot;&gt;&lt;code&gt;std::partial_ordering&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f866666203b9d8169856637ab3b9cd6d1dcf6a1" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;a href=&quot;implicit_cast&quot;&gt;standard conversions&lt;/a&gt; are used, if necessary, to convert the value of other to the cv-unqualified version of &lt;code&gt;T&lt;/code&gt;, and the initial value of the object being initialized is the (possibly converted) value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ce6c5d0d3b6f123d1fc49444a5e641ea724a683" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; is equivalent to &lt;code&gt;f(t1, t2, ..., tN)&lt;/code&gt; (that is, &lt;code&gt;f&lt;/code&gt; is a &lt;a href=&quot;../../named_req/functionobject&quot;&gt;FunctionObject&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="431b8627e944ca2be8baddd1219b14eba39a6bbe" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;code&gt;enable_view&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9434b7702b78cb95bb96871fd7c7e05f08e2c05" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;code&gt;get&amp;lt;i&amp;gt;(e)&lt;/code&gt;, where &lt;code&gt;get&lt;/code&gt; is looked up by &lt;a href=&quot;adl&quot;&gt;argument-dependent lookup&lt;/a&gt; only, ignoring non-ADL lookup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73cd360aa5dd456371d317e234e94d3702581a37" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;code&gt;std::dynamic_extent&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49e2c6203681dec38ad03bfdb7ce36b4fb8a5cd5" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;code&gt;std::ranges::ref_view{E}&lt;/code&gt; if that expression is well-formed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="164010b32ce6d64e07f700641c96932a6012090e" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;code&gt;std::ranges::subrange{E}&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a59640dc14397e200f98a9f46a0ad431f2d1b414" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="606ed1b990a973ca7c8ff7850a61295271a2cdd8" translate="yes" xml:space="preserve">
          <source>Otherwise, If the braced-init-list is empty and &lt;code&gt;T&lt;/code&gt; is a class type with a default constructor, &lt;a href=&quot;value_initialization&quot;&gt;value-initialization&lt;/a&gt; is performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aa2a5d7e93e7e43120f01b638cb5e7b69322f19" translate="yes" xml:space="preserve">
          <source>Otherwise, If the set of potential exceptions is not empty, the implicit exception specification lists every type from the set</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc79704bd23f081821913e586d13442cf87840a1" translate="yes" xml:space="preserve">
          <source>Otherwise, a call to &lt;code&gt;setbuf()&lt;/code&gt; replaces the internal buffer (the controlled character sequence) with the user-supplied character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt; and allows this &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; object to use up to &lt;code&gt;n&lt;/code&gt; bytes in that array for buffering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad38599579c5ea4bdeeac6b21cf3fa58c3a4793d" translate="yes" xml:space="preserve">
          <source>Otherwise, a single invalid preprocessing number token (e.g., &lt;code&gt;1.0_E+2.0&lt;/code&gt; or &lt;code&gt;4s.count&lt;/code&gt;) is formed, which causes compilation to fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acea718d4290aa47c7e60d4de5b064b3e0d254ed" translate="yes" xml:space="preserve">
          <source>Otherwise, a single invalid preprocessing number token is formed, which causes further analysis to fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d073dac151a3fca70156ba30ba0a82a352e230" translate="yes" xml:space="preserve">
          <source>Otherwise, behaves as an &lt;a href=&quot;../../named_req/unformattedoutputfunction&quot;&gt;UnformattedOutputFunction&lt;/a&gt;(since C++11). After constructing and checking the sentry object, calls &lt;code&gt;rdbuf()-&amp;gt;pubsync()&lt;/code&gt;. If the call returns &lt;code&gt;-1&lt;/code&gt;, calls &lt;code&gt;setstate(badbit)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0780a0ffddf1c784ffa3b56f857175d0f7fa5465" translate="yes" xml:space="preserve">
          <source>Otherwise, behaves as if &lt;code&gt;copy_file(from, to, options)&lt;/code&gt; (copies the file)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="627f00f4acc28e4cd8c56248c5f55a7cbecd5ad5" translate="yes" xml:space="preserve">
          <source>Otherwise, both operands are converted to the unsigned counterpart of the signed operand's type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dca46d219b19ec395030ec7cd098250e0815314" translate="yes" xml:space="preserve">
          <source>Otherwise, call_once invokes &lt;code&gt;​std​::​forward&amp;lt;Callable&amp;gt;(f)&lt;/code&gt; with the arguments &lt;code&gt;std​::​forward&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; (as if by &lt;code&gt;&lt;a href=&quot;../utility/functional/invoke&quot;&gt;std::invoke&lt;/a&gt;&lt;/code&gt;). Unlike the &lt;code&gt;&lt;a href=&quot;thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; constructor or &lt;code&gt;&lt;a href=&quot;async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt;, the arguments are not moved or copied because they don't need to be transferred to another thread of execution. (such a call to &lt;code&gt;call_once&lt;/code&gt; is known as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46563ecee190082dcf304e8bc3d35daa41516d59" translate="yes" xml:space="preserve">
          <source>Otherwise, calls &lt;code&gt;pbackfail(Traits::to_int_type(c))&lt;/code&gt; to either back up the get area or to modify both the get area and possibly the associated character sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb7a2130860cfe613ba1d287c1ddedd7b0520d48" translate="yes" xml:space="preserve">
          <source>Otherwise, calls &lt;code&gt;rdbuf()-&amp;gt;pubsync()&lt;/code&gt;. If that function returns &lt;code&gt;-1&lt;/code&gt;, calls &lt;code&gt;setstate(badbit)&lt;/code&gt; and returns &lt;code&gt;-1&lt;/code&gt;. Otherwise, returns &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a378661181063941ec4ab61248ee5b057b2199c" translate="yes" xml:space="preserve">
          <source>Otherwise, does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee71742b1580f5628f5230e4e54460095ea4f45a" translate="yes" xml:space="preserve">
          <source>Otherwise, exactly one of the two expressions is well-formed; the result of that expression is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e95824d0acbc20f5fd327d004eb3c302e514cd24" translate="yes" xml:space="preserve">
          <source>Otherwise, first determines the first mismatched element of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;base&lt;/code&gt; as if by &lt;code&gt;auto [a, b] = mismatch(begin(), end(), base.begin(), base.end())&lt;/code&gt;, then</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4314579dd9b17eec24a8ec618dd219556ec25187" translate="yes" xml:space="preserve">
          <source>Otherwise, for every argument in a function call expression its type is examined to determine the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff984b82c4eed90ea45cba40d983b9e98cee18f5" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;*this&lt;/code&gt; refers to a directory, it is iterated into if the following conditions are met:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee891d06a1d6556519861eb469dcf1302db3fb78" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;pptr()&lt;/a&gt;&lt;/code&gt; is not null and &lt;code&gt;pptr() &amp;gt; egptr()&lt;/code&gt; (there is a put area and it is located after the get area), extends the end of the get area to include the characters that were recently written into the put area by incrementing &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;egptr()&lt;/a&gt;&lt;/code&gt; to some value between &lt;code&gt;gptr()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;pptr()&lt;/a&gt;&lt;/code&gt;, and then returns &lt;code&gt;(unsigned char)(*gptr())&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c73ad42959cce3b6492539ac2ac30a3182e1ebdd" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;&lt;a href=&quot;common_type&quot;&gt;std::common_type_t&lt;/a&gt;&amp;lt;T1, T2&amp;gt;&lt;/code&gt; is a valid type, then the member type &lt;code&gt;type&lt;/code&gt; names that type;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e4f9de74b722651af451b3eaba780572f6f0ec8" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;&lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;decltype(false ? &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;T1&amp;gt;() : &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;T2&amp;gt;())&amp;gt;::type&lt;/code&gt; is a valid type, the member &lt;code&gt;type&lt;/code&gt; denotes that type;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ca943cae26b7e5798434b728f014463dedbe37e" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;&lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;decltype(false ? &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;const T1 &amp;amp;&amp;gt;() : &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;const T2 &amp;amp;&amp;gt;())&amp;gt;::type&lt;/code&gt; is a valid type, the member &lt;code&gt;type&lt;/code&gt; denotes that type;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="428aee88027a575a2c4c07c14e3348529265ef95" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; is zero, &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; is always returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ca5cf3254b90905e374d0524d66cbcfa7c00e84" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;&lt;a href=&quot;uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;T, Alloc&amp;gt;&lt;/code&gt; is true and &lt;code&gt;&lt;a href=&quot;../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;allocator_arg_t&quot;&gt;std::allocator_arg_t&lt;/a&gt;, Alloc, Args...&amp;gt;&lt;/code&gt; is true, returns &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&lt;a href=&quot;allocator_arg_t&quot;&gt;std::allocator_arg_t&lt;/a&gt;, const Alloc&amp;amp;, Args&amp;amp;&amp;amp;...&amp;gt;(&lt;a href=&quot;allocator_arg&quot;&gt;std::allocator_arg&lt;/a&gt;, alloc, &lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59961b1a2dd574228e54fdee30b7f1827c700222" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;&lt;a href=&quot;uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;T, Alloc&amp;gt;&lt;/code&gt; is true and &lt;code&gt;&lt;a href=&quot;../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, Args..., Alloc&amp;gt;&lt;/code&gt; is true, returns &lt;code&gt;&lt;a href=&quot;../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)..., alloc)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d669cbc731b91defd1d774ec43569dbb20b8495b" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;Extent&lt;/code&gt; is not &lt;code&gt;std::dynamic_extent&lt;/code&gt;, &lt;code&gt;Extent - Offset&lt;/code&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d912dde1969d55e1addb4ddea8347d44acfc268b" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;Iter&lt;/code&gt; satisfies the exposition-only concept &lt;a href=&quot;../named_req/inputiterator#Concept&quot;&gt;&lt;code&gt;__LegacyInputIterator&lt;/code&gt;&lt;/a&gt;, the member types are declared as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01bf3bb05ccae2f61e184788c88205363879dafc" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;Iter&lt;/code&gt; satisfies the exposition-only concept &lt;a href=&quot;../named_req/iterator#Concept&quot;&gt;&lt;code&gt;__LegacyIterator&lt;/code&gt;&lt;/a&gt;, the member types are declared as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fc3ca72cc49663199bde80b7516d57859913df3" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;N + 1 &amp;lt; subs.size()&lt;/code&gt;, increments N and sets result to the address of the current match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3f2569f9c7c1597a68a255250b77a0445a9c1c6" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;OutputIt&lt;/code&gt; satisfies &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;, and the value type of &lt;code&gt;InputIt&lt;/code&gt; is the same as that of &lt;code&gt;OutputIt&lt;/code&gt;, this function compare &lt;code&gt;*d_first&lt;/code&gt; to &lt;code&gt;*first&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45466809098eb64a7392fe74b0f3b3e925eeaf8e" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;bool&lt;/code&gt; and the source type is &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;, the value of the initialized object is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06e9f21410b573c477047043334ef631ab49fe1c" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;enum&quot;&gt;enumeration type&lt;/a&gt; that is either scoped or unscoped with fixed underlying type, and if the braced-init-list has only one initializer, and if the conversion from the initializer to the underlying type is non-narrowing, and if the initialization is direct-list-initialization, then the enumeration is initialized with the result of converting the initializer to its underlying type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2b5dd1fd7d7e21fc6b8289ebe3ffad1a2ddc58c" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;T&lt;/code&gt; is a character array and the initializer list has a single element that is an appropriately-typed string literal, the array is &lt;a href=&quot;aggregate_initialization#Character_arrays&quot;&gt;initialized from the string literal as usual&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6cbed09cd7105db2eddbcc3ade8ce69cd103125" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;T&lt;/code&gt; is a function type &lt;code&gt;F&lt;/code&gt; or a reference thereto, the member typedef &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;add_pointer&quot;&gt;std::add_pointer&lt;/a&gt;&amp;lt;F&amp;gt;::type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e52047d97aae8d13486691442f927a59679abb5" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;T&lt;/code&gt; is a non-class type but the source type is a class type, the conversion functions of the source type and its base classes, if any, are examined and the best match is selected by overload resolution. The selected user-defined conversion is then used to convert the initializer expression into the object being initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="218b3de29bc2394788eea0121b0fc117859089c9" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;T&lt;/code&gt; is a reference type that isn't compatible with the type of the element, a temporary of the referenced type is list-initialized, and the reference is bound to that temporary. (this fails if the reference is a non-const lvalue reference)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7064e64444aa8415507aee07d1145bcf082b949d" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;T&lt;/code&gt; is a specialization of &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;T&lt;/code&gt; object is direct-initialized or copy-initialized, depending on context, from a prvalue of the same type initialized from(until C++17) the braced-init-list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="375b8a5600e829089c7812fb913706e02173ee32" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;T&lt;/code&gt; is a specialization of class template &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/multiset&quot;&gt;std::multiset&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../regex/match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;enable_view&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2823382fe120f60f70de7398bfd9f4e5fc5ffa12" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate type&lt;/a&gt;, &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate initialization&lt;/a&gt; is performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbdc4749372a337a02a1c11b4ce7be5224b00d26" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;T&lt;/code&gt; is not an enumeration type, there is no member &lt;code&gt;type&lt;/code&gt;. Otherwise (&lt;code&gt;T&lt;/code&gt; is an incomplete enumeration type), the program is ill-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14d9852dc62b8f797134ce4bf30cc436dd901830" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;bool(lhs) == false&lt;/code&gt; (and so &lt;code&gt;bool(rhs) == false&lt;/code&gt; as well), returns &lt;code&gt;false&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ba32e75658082ae6c341c2fac395dca461c2b1f" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;bool(lhs) == false&lt;/code&gt; (and so &lt;code&gt;bool(rhs) == false&lt;/code&gt; as well), returns &lt;code&gt;true&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df9b0815a00142ba962ac25a2527c7b37bb420c2" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;bool(lhs) == false&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1365d8f8e673e9144deaae7a7c971e0ad8a4d68a" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;bool(lhs) == false&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15f0fe080c391d139facc91802d8554ba4940363" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;bool(rhs) == false&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6492803cf0d14e8df99e227d169459b83926414a" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;bool(rhs) == false&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7a07d2ca4bf1af0e9c50922ca7bbc224615540a" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;copy_options::create_hard_links&lt;/code&gt; is present in &lt;code&gt;options&lt;/code&gt;, creates a hard link to &lt;code&gt;to&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a0ae6a07ff1283c9c3c61cf4171b25e8535cb91" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;copy_options::create_symlinks&lt;/code&gt; is present in &lt;code&gt;options&lt;/code&gt;, creates a symlink to &lt;code&gt;to&lt;/code&gt;. Note: &lt;code&gt;from&lt;/code&gt; must be an absolute path unless &lt;code&gt;to&lt;/code&gt; is in the current directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="166eb719a5083a52c5d2ce526bb2cd220182aad0" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;decltype(false? val&amp;lt;T1&amp;gt;() : val&amp;lt;T2&amp;gt;())&lt;/code&gt;, where &lt;code&gt;val&lt;/code&gt; is a function template &lt;code&gt;template&amp;lt;class T&amp;gt; T val();&lt;/code&gt;, is a valid type, then the member type &lt;code&gt;type&lt;/code&gt; names that type;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53e55772bcf32aaff84af0ec8d56e784e6ba2f29" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;from&lt;/code&gt; is a directory and &lt;code&gt;copy_options::create_symlinks&lt;/code&gt; is set in &lt;code&gt;options&lt;/code&gt;, reports an error with an error code equal to &lt;code&gt;std::make_error_code(&lt;a href=&quot;../error/errc&quot;&gt;std::errc::is_a_directory&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5ad133fd015286ca00659223bb038e3ed6d4037" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;from&lt;/code&gt; is a directory and either &lt;code&gt;options&lt;/code&gt; has &lt;code&gt;copy_options::recursive&lt;/code&gt; or is &lt;code&gt;copy_options::none&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e443ba0276ca97c32379a2a0971dc1568ca12063" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;from&lt;/code&gt; is a regular file, then</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="292b09972db99861126382dff41dbbd44174ca59" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;has_root_directory() != p.has_root_directory()&lt;/code&gt;, returns a value less than zero if &lt;a href=&quot;has_path&quot;&gt;&lt;code&gt;has_root_directory()&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;false&lt;/code&gt; and a value greater than zero otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5ef0f1fcd9f2493ce433aaa42f388c0919a670c" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;path::value_type&lt;/code&gt; is &lt;code&gt;char16_t&lt;/code&gt;, native encoding is UTF-16 and the conversion method is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a9eb8061c7f34f742349db387dfe84a2c08b17a" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;path::value_type&lt;/code&gt; is &lt;code&gt;char32_t&lt;/code&gt;, native encoding is UTF-32 and the conversion method is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="966f0f3054d501042e90941e1eed8c57de80ecf7" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;path::value_type&lt;/code&gt; is &lt;code&gt;char8_t&lt;/code&gt;, native encoding is UTF-8 and the conversion method is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e08a812ff02c541362ccc76c2c1e8a4bc33ebc65" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;path::value_type&lt;/code&gt; is &lt;code&gt;wchar_t&lt;/code&gt; and native encoding is UTF-16 (this is the situation on Windows), or if &lt;code&gt;path::value_type&lt;/code&gt; is &lt;code&gt;char16_t&lt;/code&gt; (native encoding guaranteed UTF-16) or &lt;code&gt;char32_t&lt;/code&gt; (native encoding guaranteed UTF-32), then first converts the UTF-8 character sequence to a temporary string &lt;code&gt;tmp&lt;/code&gt; of type &lt;code&gt;path::string_type&lt;/code&gt; and then the new path is constructed as if by &lt;code&gt;path(tmp)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b432a91dc175a36df7dda7435aec5f57107fe78a" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;path::value_type&lt;/code&gt; is &lt;code&gt;wchar_t&lt;/code&gt;, conversion, if any, is unspecified. This is the case on Windows, where wchar_t is 16 bit and the native encoding is UTF-16.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed6c3b6c58795e044e4bcbe22c1909d8a8c094cf" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;std::basic_common_reference&amp;lt;&lt;a href=&quot;remove_cvref&quot;&gt;std::remove_cvref_t&lt;/a&gt;&amp;lt;T1&amp;gt;, &lt;a href=&quot;remove_cvref&quot;&gt;std::remove_cvref_t&lt;/a&gt;&amp;lt;T2&amp;gt;, T1Q, T2Q&amp;gt;::type&lt;/code&gt; exists, where &lt;code&gt;TiQ&lt;/code&gt; is a unary alias template such that &lt;code&gt;TiQ&amp;lt;U&amp;gt;&lt;/code&gt; is &lt;code&gt;U&lt;/code&gt; with the addition of &lt;code&gt;Ti&lt;/code&gt;'s cv- and reference qualifiers, then the member type &lt;code&gt;type&lt;/code&gt; names that type;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e546103b6283134ef18efd46f4fc7b39f642ac7e" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;str.flags() &amp;amp; str.adjustfield&lt;/code&gt; equals &lt;code&gt;str.left&lt;/code&gt;, the copies of &lt;code&gt;fill&lt;/code&gt; are appended after all other characters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8a52ecf0281d191b4f2da5750d1e68d9bf0afb7" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;to&lt;/code&gt; does not exist and &lt;code&gt;copy_options::copy_symlinks&lt;/code&gt; is present in &lt;code&gt;options&lt;/code&gt;, then behaves as if &lt;code&gt;copy_symlink(from, to)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7279952729b21b5e1aa8d6545baa96b4209cb404" translate="yes" xml:space="preserve">
          <source>Otherwise, if &lt;code&gt;to&lt;/code&gt; is a directory, then behaves as if &lt;code&gt;copy_file(from, to/from.filename(), options)&lt;/code&gt; (creates a copy of &lt;code&gt;from&lt;/code&gt; as a file in the directory &lt;code&gt;to&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed7d0b3117bef8fcb999049ac27b0afd631dcfc7" translate="yes" xml:space="preserve">
          <source>Otherwise, if N == 1 and &lt;code&gt;f&lt;/code&gt; is a &lt;a href=&quot;../../language/pointer#Pointers_to_data_members&quot;&gt;pointer to data member&lt;/a&gt; of class &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab47eff21dc15cd9a480d32ba06683c69dfb919c" translate="yes" xml:space="preserve">
          <source>Otherwise, if T names an object type, a function type that is not cv- or ref-qualified, or a (possibly cv-qualified) void type, provides the member typedef &lt;code&gt;type&lt;/code&gt; which is the type &lt;code&gt;T*&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a9b9b47be1e26bddda6b709708e63df1372093c" translate="yes" xml:space="preserve">
          <source>Otherwise, if any of the values stored in subs is equal to &lt;code&gt;-1&lt;/code&gt; and &lt;code&gt;prev-&amp;gt;suffix().length()&lt;/code&gt; is not &lt;code&gt;​0​&lt;/code&gt; the operator sets &lt;code&gt;*this&lt;/code&gt; to a suffix iterator that points to the range [&lt;code&gt;prev-&amp;gt;suffix().first&lt;/code&gt;, &lt;code&gt;prev-&amp;gt;suffix().second&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cb6a2f20cfd666b24b831fdea6cc912f7649ba1" translate="yes" xml:space="preserve">
          <source>Otherwise, if at least one Ti is &lt;a href=&quot;strong_equality&quot;&gt;&lt;code&gt;std::strong_equality&lt;/code&gt;&lt;/a&gt;, U is &lt;a href=&quot;strong_equality&quot;&gt;&lt;code&gt;std::strong_equality&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78f80d3018a37d70f25351a1cafb4a26f6e8beb2" translate="yes" xml:space="preserve">
          <source>Otherwise, if at least one Ti is &lt;a href=&quot;weak_equality&quot;&gt;&lt;code&gt;std::weak_equality&lt;/code&gt;&lt;/a&gt; or at least one Ti is &lt;a href=&quot;strong_equality&quot;&gt;&lt;code&gt;std::strong_equality&lt;/code&gt;&lt;/a&gt; and at least one Ti is &lt;a href=&quot;partial_ordering&quot;&gt;&lt;code&gt;std::partial_ordering&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;weak_ordering&quot;&gt;&lt;code&gt;std::weak_ordering&lt;/code&gt;&lt;/a&gt;, U is &lt;a href=&quot;weak_equality&quot;&gt;&lt;code&gt;std::weak_equality&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d7cee6d18324d1d7b6701a3e15482bc5a390cb" translate="yes" xml:space="preserve">
          <source>Otherwise, if at least one Ti is &lt;a href=&quot;weak_ordering&quot;&gt;&lt;code&gt;std::weak_ordering&lt;/code&gt;&lt;/a&gt;, U is &lt;a href=&quot;weak_ordering&quot;&gt;&lt;code&gt;std::weak_ordering&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bc1c45d96d4bd4366709f98709a0e548be82adc" translate="yes" xml:space="preserve">
          <source>Otherwise, if at least one of the following two expressions are well-formed, then</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="421050de93db78210e1e7d3a90578c9064e65945" translate="yes" xml:space="preserve">
          <source>Otherwise, if both &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;const T&lt;/code&gt; model &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;iter_reference_t&amp;lt;iterator_t&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; is not the same type as &lt;code&gt;iter_reference_t&amp;lt;iterator_t&amp;lt;const T&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;enable_view&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. (in other words, deep constness implies element ownership, shallow constness implies reference (view) semantics)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b9193ae3a7d9f93f0a829fa9139c8d25c2c9e3b" translate="yes" xml:space="preserve">
          <source>Otherwise, if either operand is &lt;code&gt;double&lt;/code&gt;, the other operand is converted to &lt;code&gt;double&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="162c16457c98275e9a59452ea8201cacb04da1c4" translate="yes" xml:space="preserve">
          <source>Otherwise, if either operand is &lt;code&gt;float&lt;/code&gt;, the other operand is converted to &lt;code&gt;float&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d41d7d9d906ebfff3507da1fa535c8047696edac" translate="yes" xml:space="preserve">
          <source>Otherwise, if either operand is &lt;code&gt;long double&lt;/code&gt;, the other operand is converted to &lt;code&gt;long double&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1af22e4384a2886c24f4f7c58fcd0d33ee03d3ab" translate="yes" xml:space="preserve">
          <source>Otherwise, if the allocation function that would have been called is non-throwing, the new-expression returns the null pointer of the required result type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="171bda235fd0815fb84038a3b382ecdfea488118" translate="yes" xml:space="preserve">
          <source>Otherwise, if the braced-init-list has no elements, &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;value_initialization&quot;&gt;value-initialized&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88fc027200408f134d0438d5d86036f6e481939c" translate="yes" xml:space="preserve">
          <source>Otherwise, if the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is ill-formed, but the expression &lt;code&gt;a == b&lt;/code&gt; is well-formed and convertible to &lt;code&gt;bool&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b2c0112061f9aea9a0263ecf945005f69dcd4ac" translate="yes" xml:space="preserve">
          <source>Otherwise, if the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is ill-formed, but the expressions &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;a &amp;lt; b&lt;/code&gt; are both well-formed and convertible to &lt;code&gt;bool&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecd3584911471078c9fff60b656c04f2559c5d09" translate="yes" xml:space="preserve">
          <source>Otherwise, if the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is well-formed and its result is convertible to &lt;code&gt;std::strong_ordering&lt;/code&gt;, returns that result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2fdefed996a0fa6b0a925928be40e3754ae6870" translate="yes" xml:space="preserve">
          <source>Otherwise, if the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is well-formed, but its result is not convertible to &lt;code&gt;std::partial_ordering&lt;/code&gt;, then the function is defined as deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b8f151329e211fe7210283a987302f2b13a65b8" translate="yes" xml:space="preserve">
          <source>Otherwise, if the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is well-formed, but its result is not convertible to &lt;code&gt;std::strong_equality&lt;/code&gt;, then the function is defined as deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2da65869509d2e97e067d0f350602b2427e12d5b" translate="yes" xml:space="preserve">
          <source>Otherwise, if the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is well-formed, but its result is not convertible to &lt;code&gt;std::strong_ordering&lt;/code&gt;, then the function is defined as deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acaa0cefb0a72d1a5517c1605e3529f2f3c0754f" translate="yes" xml:space="preserve">
          <source>Otherwise, if the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is well-formed, but its result is not convertible to &lt;code&gt;std::weak_equality&lt;/code&gt;, then the function is defined as deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f23ab42f807940f2720ef3dc21fe4b82f2abf2b7" translate="yes" xml:space="preserve">
          <source>Otherwise, if the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is well-formed, but its result is not convertible to &lt;code&gt;std::weak_ordering&lt;/code&gt;, then the function is defined as deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="348c7c1b003a5b881c7e6274f7f160faf6627c4d" translate="yes" xml:space="preserve">
          <source>Otherwise, if the expression &lt;code&gt;a == b&lt;/code&gt; is well-formed and convertible to &lt;code&gt;bool&lt;/code&gt; (but &lt;code&gt;a &amp;lt; b&lt;/code&gt; is not),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61d7ae5ff0fa683b10fdda5117b997c104a5c07e" translate="yes" xml:space="preserve">
          <source>Otherwise, if the expressions &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;a &amp;lt; b&lt;/code&gt; are both well-formed and convertible to &lt;code&gt;bool&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c635864320faff70a6adf97fe4b0d0b0804f9a" translate="yes" xml:space="preserve">
          <source>Otherwise, if the iterator holds a zero-length match the operator invokes the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b82ea0795993978f8bbde09da2af048ebb9b8e5" translate="yes" xml:space="preserve">
          <source>Otherwise, if the operands have integral type, the operator yields a prvalue of type &lt;a href=&quot;../utility/compare/strong_ordering&quot;&gt;&lt;code&gt;std::strong_ordering&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b4f930ed270060721399f787df60231eb4e0a39" translate="yes" xml:space="preserve">
          <source>Otherwise, if the output sequence has a write position available or this function can successfully make a write position available, then calls &lt;code&gt;sputc(c)&lt;/code&gt; and returns &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="822b5dd938efe3d3b360647a8d06db3ace25d6b2" translate="yes" xml:space="preserve">
          <source>Otherwise, if the parameter is a reference, reference initialization rules apply</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8956448bd10246288e60fc4f03534c2e922490f" translate="yes" xml:space="preserve">
          <source>Otherwise, if the parameter type is &quot;array of N T&quot; (this only happens for references to arrays), the initializer list must have N or less elements, and(since C++14) the worst implicit conversion necessary to convert every element of the list (or the empty pair of braces &lt;code&gt;{}&lt;/code&gt; if the list is shorter than N)(since C++14) to &lt;code&gt;T&lt;/code&gt; is the one used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2d5fa930e8959e93ec76606457905f64f84d134" translate="yes" xml:space="preserve">
          <source>Otherwise, if the parameter type is a non-aggregate class type &lt;code&gt;X&lt;/code&gt;, overload resolution picks the constructor C of X to initialize from the argument initializer list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4007141dba4b26eff24b8efacc4dfcb7c61d37a" translate="yes" xml:space="preserve">
          <source>Otherwise, if the parameter type is a reference to character array and the initializer list has a single element that is an appropriately-typed string literal, the implicit conversion sequence is the identity conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7729610e001783f61f3d227da3f02cc1a60a9abb" translate="yes" xml:space="preserve">
          <source>Otherwise, if the parameter type is an aggregate which can be initialized from the initializer list according by &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate initialization&lt;/a&gt;, the implicit conversion sequence is a user-defined conversion sequence with the second standard conversion sequence an identity conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2f992f32f1ddc53a2d6218e3d36465b783b4059" translate="yes" xml:space="preserve">
          <source>Otherwise, if the parameter type is not a class and the initializer list has one element, the implicit conversion sequence is the one required to convert the element to the parameter type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d47727b701dc8f68c56b2a1fee171c162ae0f0d" translate="yes" xml:space="preserve">
          <source>Otherwise, if the parameter type is not a class type and if the initializer list has no elements, the implicit conversion sequence is the identity conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fbafbabfd3ee0a932d53af7c1b8cca593e5c93e" translate="yes" xml:space="preserve">
          <source>Otherwise, if the reference is an lvalue reference:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72b5a789a5600c264a248bc4ee98454d98c68cfc" translate="yes" xml:space="preserve">
          <source>Otherwise, if the reference is lvalue reference to &lt;code&gt;const&lt;/code&gt; or rvalue reference(since C++11):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1185051d0ac7dc3ffa344299aac95815f2789571" translate="yes" xml:space="preserve">
          <source>Otherwise, if the signed operand's type can represent all values of the unsigned operand, the unsigned operand is converted to the signed operand's type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73197b3f1f7f7621f9a8207649fa04d6c4822998" translate="yes" xml:space="preserve">
          <source>Otherwise, if the stored year and month are valid (&lt;code&gt;year().ok() &amp;amp;&amp;amp; month().ok()&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;), then the returned value is &lt;code&gt;sys_days(year()/month()/1d) + (day() - 1d)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b065650a7f84b7c8696ad65179b562d19faa918" translate="yes" xml:space="preserve">
          <source>Otherwise, if the type of object is not same or derived from &lt;code&gt;T&lt;/code&gt;, and object has conversion function to a rvalue or a function lvalue whose type is either &lt;code&gt;T&lt;/code&gt; or derived from &lt;code&gt;T&lt;/code&gt;, equally or less cv-qualified, then the reference is bound to the result of the conversion function or to its base class subobject (after &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;materializing a temporary&lt;/a&gt; if necessary)(since C++17).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1511439576488c1defb8563179fe9eff7ebd961f" translate="yes" xml:space="preserve">
          <source>Otherwise, if the type of object is not same or derived from &lt;code&gt;T&lt;/code&gt;, and object has conversion function to an lvalue whose type is either &lt;code&gt;T&lt;/code&gt; or derived from &lt;code&gt;T&lt;/code&gt;, equally or less cv-qualified, then the reference is bound to the object identified by the lvalue returned by the conversion function (or to its base class subobject).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0739c4e35439d2c443ea379ac4d77c8a7a10c430" translate="yes" xml:space="preserve">
          <source>Otherwise, if the unsigned operand's conversion rank is greater or equal to the conversion rank of the signed operand, the signed operand is converted to the unsigned operand's type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8eec1a8981917d60e3bc1af1579461b31875dba" translate="yes" xml:space="preserve">
          <source>Otherwise, if there is a user specialization for &lt;code&gt;std::common_type&amp;lt;T1, T2&amp;gt;&lt;/code&gt;, that specialization is used;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c99b8902b5835a4eef9c94df18ae5bebf732fb0" translate="yes" xml:space="preserve">
          <source>Otherwise, it is defined as defaulted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c72208243ab32271fd102604a1939412591ab05" translate="yes" xml:space="preserve">
          <source>Otherwise, it is treated as a type-name, and is equivalent to the template-name followed by the template-parameters of the class template enclosed in &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d05d4c59a83d8ffc21fb436aa7d65e96144d0945" translate="yes" xml:space="preserve">
          <source>Otherwise, it is unspecified whether the global size-aware deallocation function (with a parameter of type std::size_t) or the global size-unaware deallocation function (without a parameter of type std::size_t) is selected</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c2e1a77c1cd325559d5878578bf6739c05ad0eb" translate="yes" xml:space="preserve">
          <source>Otherwise, its potential scope ends at the end of the last exception handler of the &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt;, or at the end of the function body if a function try block was not used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45d254093c7870c86f09ccd60501d1e7ca535c6e" translate="yes" xml:space="preserve">
          <source>Otherwise, lookup reached global scope, and:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b39a307f5110cf1b47c6472118df946a906ef893" translate="yes" xml:space="preserve">
          <source>Otherwise, may throw any exception thrown by the move constructors of the alternatives currently held by &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef82505cb47d2e0a2b5d2be9e65d0e27f54534ea" translate="yes" xml:space="preserve">
          <source>Otherwise, moves the file pointer as if by &lt;code&gt;&lt;a href=&quot;../c/fseek&quot;&gt;std::fseek&lt;/a&gt;(file, 0, whence)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7be12bc197efa8902ac09e67048d03785a7806d4" translate="yes" xml:space="preserve">
          <source>Otherwise, object is implicitly converted to &lt;code&gt;T&lt;/code&gt;. The reference is bound to the result of the conversion (after &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;materializing a temporary&lt;/a&gt;)(since C++17). If the object (or, if the conversion is done by user-defined conversion, the result of the conversion function) is of type &lt;code&gt;T&lt;/code&gt; or derived from &lt;code&gt;T&lt;/code&gt;, it must be equally or less cv-qualified than &lt;code&gt;T&lt;/code&gt;, and, if the reference is an rvalue reference, must not be an lvalue(since C++11).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b802130d7e99035be5c2708b9d994b6298638ac2" translate="yes" xml:space="preserve">
          <source>Otherwise, one of the two types must be an lvalue reference type &lt;code&gt;A &amp;amp;&lt;/code&gt; and the other must be an rvalue reference type &lt;code&gt;B &amp;amp;&amp;amp;&lt;/code&gt; (&lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; might be cv-qualified). Let &lt;code&gt;D&lt;/code&gt; denote the simple common reference type of &lt;code&gt;A &amp;amp;&lt;/code&gt; and &lt;code&gt;B const &amp;amp;&lt;/code&gt;, if any. If &lt;code&gt;D&lt;/code&gt; exists and &lt;code&gt;&lt;a href=&quot;is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;B&amp;amp;&amp;amp;, D&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then the simple common reference type is &lt;code&gt;D&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dc94a6480357e96e9438007b18da9cc505155a7" translate="yes" xml:space="preserve">
          <source>Otherwise, performs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3075986968947931dbd223094a53b6ec2458689c" translate="yes" xml:space="preserve">
          <source>Otherwise, reports an error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a29f9962adc145f1f8f106a5ad56d8f85036f0a" translate="yes" xml:space="preserve">
          <source>Otherwise, returns &lt;code&gt;*lhs != *rhs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39f1048e1f55d1a8e2a8d851df7491546e04e41a" translate="yes" xml:space="preserve">
          <source>Otherwise, returns &lt;code&gt;*lhs == *rhs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5964bbdaba906a06c6393f164607c1f2ab3ba16d" translate="yes" xml:space="preserve">
          <source>Otherwise, returns &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; to indicate failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="177adb16a31690e1329d3a716bd11614b59520a5" translate="yes" xml:space="preserve">
          <source>Otherwise, returns &lt;code&gt;Traits::eof()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c7f5a58e7d1a3a5d4c454a043ba449f8e7f4be6" translate="yes" xml:space="preserve">
          <source>Otherwise, returns &lt;code&gt;file_status(file_type::unknown, prms)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2a4d55f43b35f2d2ad3d08cf5c9b51a68bd4105" translate="yes" xml:space="preserve">
          <source>Otherwise, returns a pair of iterators to the first and one past last positions in [first, last) where a subsequence that compares equal to [pat_first, pat_last) as defined by &lt;code&gt;pred&lt;/code&gt; is located, or &lt;code&gt;make_pair(last, last)&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15b572290e34796e3e3d39ffca465e2b3cd792bc" translate="yes" xml:space="preserve">
          <source>Otherwise, returns the next pointer in the put area minus the beginning pointer in the put area, that is &lt;code&gt;pptr() - pbase()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eba6449a38358ea253c921c131878c74dcd1db7" translate="yes" xml:space="preserve">
          <source>Otherwise, see.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f3e74ef726727f91916634721b92986906ef72" translate="yes" xml:space="preserve">
          <source>Otherwise, sets &lt;code&gt;*this&lt;/code&gt; to an end-of-sequence iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eb090040a3a52fe94cc6775c074e1b07b19652a" translate="yes" xml:space="preserve">
          <source>Otherwise, sets &lt;code&gt;N&lt;/code&gt; to &lt;code&gt;​0​&lt;/code&gt; and increments &lt;code&gt;position&lt;/code&gt;. If &lt;code&gt;position&lt;/code&gt; is not an end-of-sequence iterator the operator sets result to the address of the current match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="603c642d35f117d07e9f1498fed39dfcb254ef8d" translate="yes" xml:space="preserve">
          <source>Otherwise, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75580918c4a4ce8615313f57a68acdd1fbcdd251" translate="yes" xml:space="preserve">
          <source>Otherwise, the constructors of &lt;code&gt;T&lt;/code&gt; are considered, in two phases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b146e8fed520382a899fba7bb2c609455fafbaf" translate="yes" xml:space="preserve">
          <source>Otherwise, the copy assignment operator is identical to &lt;a href=&quot;../utility/optional/operator=&quot;&gt;the copy assignment operator of &lt;code&gt;std::optional&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08e68ba0b328f85b5077664f0aaf1dc58f5a4195" translate="yes" xml:space="preserve">
          <source>Otherwise, the default constructor is equivalent to &lt;a href=&quot;../utility/optional/optional&quot;&gt;the default constructor of &lt;code&gt;std::optional&lt;/code&gt;&lt;/a&gt; and constructs a semiregular wrapper which does not contain a value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e527b00977cda2c75895af1adab81d61d8c381cd" translate="yes" xml:space="preserve">
          <source>Otherwise, the effect is implementation-defined: some implementations do nothing, while some implementations clear the &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; member currently used as the buffer and begin using the user-supplied character array of size &lt;code&gt;n&lt;/code&gt;, whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, as the buffer and the input/output character sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b88a725d269a06c715d3d882f5c61226b9016a5" translate="yes" xml:space="preserve">
          <source>Otherwise, the effect is implementation-defined: some implementations do nothing, while some implementations deallocate the dynamic member array used as the buffer and begin using the user-supplied character array of size &lt;code&gt;n&lt;/code&gt;, whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b08a31c53a30a8ea8c7f667136c90442875a718" translate="yes" xml:space="preserve">
          <source>Otherwise, the effects are unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6364ec7a60965cd90463385c3d3b96fcdd26b2cb" translate="yes" xml:space="preserve">
          <source>Otherwise, the fill characters are placed before all other characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da77dfc6d717554377eb96b42871e27352288980" translate="yes" xml:space="preserve">
          <source>Otherwise, the function is defined as deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99b00f40b49def667baa5519a1617bbd8cd63baf" translate="yes" xml:space="preserve">
          <source>Otherwise, the implicit exception specification is &lt;code&gt;noexcept(true)&lt;/code&gt; and the function type is &quot;noexcept function&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee56d1b04f87e0cb718ea57b6239759de41272c4" translate="yes" xml:space="preserve">
          <source>Otherwise, the implicitly-declared copy constructor is &lt;code&gt;T::T(T&amp;amp;)&lt;/code&gt;. (Note that due to these rules, the implicitly-declared copy constructor cannot bind to a volatile lvalue argument.).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaaf3a0a99d29c97f6c99a69097b24a169837ec8" translate="yes" xml:space="preserve">
          <source>Otherwise, the member typedef &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;remove_cv&quot;&gt;std::remove_cv&lt;/a&gt;&amp;lt;&lt;a href=&quot;remove_reference&quot;&gt;std::remove_reference&lt;/a&gt;&amp;lt;T&amp;gt;::type&amp;gt;::type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d21fb9a112ebe7c8f76ed1f9d977c03527b5dd1" translate="yes" xml:space="preserve">
          <source>Otherwise, the move assignment operator is identical to &lt;a href=&quot;../utility/optional/operator=&quot;&gt;the move assignment operator of &lt;code&gt;std::optional&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="268a5555e3a2b6f8563466b7ff399a97f39c313d" translate="yes" xml:space="preserve">
          <source>Otherwise, the new-expression does not call the allocation function, and instead throws an exception of type &lt;code&gt;&lt;a href=&quot;../memory/new/bad_array_new_length&quot;&gt;std::bad_array_new_length&lt;/a&gt;&lt;/code&gt; or derived from it</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dabbffbb3d578b6ddf3330d6b3f9563cb4408ec4" translate="yes" xml:space="preserve">
          <source>Otherwise, the numeric result of the conversion is stored in &lt;code&gt;v&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad22e022ee3aaa9e53829ec2b7d5268a2c1b6c88" translate="yes" xml:space="preserve">
          <source>Otherwise, the object it refers to is not modified;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49764b1deba894e3f663110a316f983b89c28b9b" translate="yes" xml:space="preserve">
          <source>Otherwise, the operand has integer type (because bool, char, char8_t, char16_t, char32_t, wchar_t, and unscoped enumeration were promoted at this point) and &lt;a href=&quot;implicit_cast#Integral_conversions&quot;&gt;integral conversions&lt;/a&gt; are applied to produce the common type, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85b266481ef05ff625c3882e0de511dd411bc52f" translate="yes" xml:space="preserve">
          <source>Otherwise, the operands have floating-point type, and the operator yields a prvalue of type &lt;a href=&quot;../utility/compare/partial_ordering&quot;&gt;&lt;code&gt;std::partial_ordering&lt;/code&gt;&lt;/a&gt;. The expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; yields</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b5796cf9de75ab7d324d20924733451958b20a6" translate="yes" xml:space="preserve">
          <source>Otherwise, the ordinary stored argument &lt;code&gt;arg&lt;/code&gt; is passed to the invokable object as lvalue argument: the argument &lt;code&gt;vn&lt;/code&gt; in the &lt;code&gt;std::invoke&lt;/code&gt; call above is simply &lt;code&gt;arg&lt;/code&gt; and the corresponding type &lt;code&gt;Vn&lt;/code&gt; is &lt;code&gt;T cv &amp;amp;&lt;/code&gt;, where cv is the same cv-qualification as that of &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72843fb466e6bff00d9b64977f4c4467cd1db7f7" translate="yes" xml:space="preserve">
          <source>Otherwise, the program is ill-formed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac4821bc33c3d5874373f8e12240ea1ef1f35dbd" translate="yes" xml:space="preserve">
          <source>Otherwise, the return type must be one of the five comparison types (see above), and is ill-formed if the expression m1 &amp;lt;=&amp;gt; m2 for any base or member subobject or member array element is not implicitly convertible to the chosen return type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4433b0ce3a3f69852460b7ea531ef403f515fe6" translate="yes" xml:space="preserve">
          <source>Otherwise, the returned value is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba06e83e4d527f4991b183137c90aea90945daf1" translate="yes" xml:space="preserve">
          <source>Otherwise, the set is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f62e52f45229383e57319ca8ae4f5f6e868850c" translate="yes" xml:space="preserve">
          <source>Otherwise, the single-byte representation of &lt;code&gt;c&lt;/code&gt; as &lt;code&gt;unsigned char&lt;/code&gt; converted to &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="092639dcc3f6d11483d381b83de98ae2d3e39f86" translate="yes" xml:space="preserve">
          <source>Otherwise, the type of the expression is the same as the type of the entity named.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db6440fe450c2576e2f611e71a4cb805906e452b" translate="yes" xml:space="preserve">
          <source>Otherwise, there is no member &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9ac3726d4f53a6ed712484172cefcd3f08ca7ee" translate="yes" xml:space="preserve">
          <source>Otherwise, there's no simple common reference type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d771f005a88af7017d67ab04a552e1d51b58d6fa" translate="yes" xml:space="preserve">
          <source>Otherwise, these manipulators have no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b324c484c8c3beaaabfba39ca505b85f883015cb" translate="yes" xml:space="preserve">
          <source>Otherwise, this function allocates a new buffer by calling &lt;code&gt;upstream_resource()-&amp;gt;allocate(n, m)&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is not less than the greater of &lt;code&gt;bytes&lt;/code&gt; and the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="198cd87fe8dc1106806f4d522f62b18847f11f34" translate="yes" xml:space="preserve">
          <source>Otherwise, this function compares &lt;code&gt;*first&lt;/code&gt; to a local element copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fb35c3a3ac94ab129420546fa882e14ea2e9eca" translate="yes" xml:space="preserve">
          <source>Otherwise, this function does not participate in overload resolution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eae70dd4f0ae341ab32e124822762f016607d6f" translate="yes" xml:space="preserve">
          <source>Otherwise, this function fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbc6e6c08da9a70d96a1c49f8b8d04a0e1ea2b16" translate="yes" xml:space="preserve">
          <source>Otherwise, this template has no members by any of those names (&lt;code&gt;std::iterator_traits&lt;/code&gt; is SFINAE-friendly).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a5e04928dbe8080434585e14263a5883426ffaf" translate="yes" xml:space="preserve">
          <source>Otherwise, throws &lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(t)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2effd199ec38aff61628c908392627d382dea0e0" translate="yes" xml:space="preserve">
          <source>Otherwise, throws a &lt;code&gt;&lt;a href=&quot;bad_optional_access&quot;&gt;std::bad_optional_access&lt;/a&gt;&lt;/code&gt; exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04eb2eab63b452d7f8963769d9d3616294bbe198" translate="yes" xml:space="preserve">
          <source>Otherwise, yields false if one of &lt;code&gt;e&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; is a copy of &lt;code&gt;X​::​eof()&lt;/code&gt; and the other is not</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e16c6ccebe51ae03c3b3a48b23ea9afb4079385" translate="yes" xml:space="preserve">
          <source>Otherwise, yields true if &lt;code&gt;e&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; are both copies of &lt;code&gt;X​::​eof()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b90fa4fb7ed0a01ce83c29890910edf5b3a8cfb" translate="yes" xml:space="preserve">
          <source>Out-of-class definitions of the members of a nested class appear in the namespace of the enclosing class:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80d8df44c2a03e432a93b533defaee2001d2c8cd" translate="yes" xml:space="preserve">
          <source>Out-of-namespace definitions and redeclarations are only allowed after the point of declaration, only at namespace scope, and only in namespaces that enclose the original namespace (including the global namespace) and they must use qualified-id syntax(since C++14).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80ffa590bb433e0fb73dfbec835394f17873ae79" translate="yes" xml:space="preserve">
          <source>Output a number using the facet directly, and demonstrate user-defined facet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8674e4c2ea3004ade7765374b6035eb763594a2" translate="yes" xml:space="preserve">
          <source>Output iterator to the element in the destination range, one past the last element copied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1926d932ea490dfe3aec1c9755343baeb433d56b" translate="yes" xml:space="preserve">
          <source>Output iterator to the element past the last element copied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1133cfdcda93f42884a2e61670eac66f1cfef789" translate="yes" xml:space="preserve">
          <source>Output iterator to the element past the last element moved (&lt;code&gt;d_first + (last - first)&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57b5e1e01e474d96180245856b715bf82c9be66f" translate="yes" xml:space="preserve">
          <source>Output iterator to the element past the last element transformed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d793ab913559b714b9b3b83c6bbadbb5d57c069" translate="yes" xml:space="preserve">
          <source>Output iterator to the element past the last written element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bbd4c3f0496ce319e5aa7026016466c9e915bf7" translate="yes" xml:space="preserve">
          <source>OutputIterator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14fc49ffcaaa350d2b0204b264920b273583a302" translate="yes" xml:space="preserve">
          <source>OutputRange</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e44537874c22c547125ae8b14024e39686f87da" translate="yes" xml:space="preserve">
          <source>Outputs &lt;code&gt;d&lt;/code&gt; (interpreted as a time of day since midnight) to the stream &lt;code&gt;os&lt;/code&gt;, formatted according to the null-terminated format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a99d5991383880bc71135d580c5375b4975a6ed" translate="yes" xml:space="preserve">
          <source>Outputs &lt;code&gt;d&lt;/code&gt; to the stream &lt;code&gt;os&lt;/code&gt;, formatted according to the null-terminated format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f775fd64c4f49f715e00071aaad12d048bfcc24f" translate="yes" xml:space="preserve">
          <source>Outputs &lt;code&gt;m&lt;/code&gt; to the stream &lt;code&gt;os&lt;/code&gt;, formatted according to the null-terminated format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69ef24dea25d77df87d4c84f650130f1af5aa2ff" translate="yes" xml:space="preserve">
          <source>Outputs &lt;code&gt;md&lt;/code&gt; to the stream &lt;code&gt;os&lt;/code&gt;, formatted according to the null-terminated format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48e2ecb60ff8c0ac5d9dc43901e210fa1093913a" translate="yes" xml:space="preserve">
          <source>Outputs &lt;code&gt;t&lt;/code&gt; into the stream &lt;code&gt;os&lt;/code&gt;, according to the format string specified by the table below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52b0f411e19a555cc1118da7917d49db6373cb33" translate="yes" xml:space="preserve">
          <source>Outputs &lt;code&gt;tp&lt;/code&gt; into the stream &lt;code&gt;os&lt;/code&gt;, as if by &lt;code&gt;os &amp;lt;&amp;lt; &lt;a href=&quot;../system_clock&quot;&gt;std::chrono::sys_time&lt;/a&gt;&amp;lt;Duration&amp;gt;(tp.time_since_epoch());&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43c189ce6819ad378bb378f32ce09702e652d607" translate="yes" xml:space="preserve">
          <source>Outputs &lt;code&gt;tp&lt;/code&gt; into the stream &lt;code&gt;os&lt;/code&gt;, as if by &lt;code&gt;std::chrono::to_stream(os, fmt, tp)&lt;/code&gt;, where &lt;code&gt;fmt&lt;/code&gt; is a string containing &lt;code&gt;&quot;%F %T&quot;&lt;/code&gt; widened to &lt;code&gt;CharT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd01482fd01010284466510d5b0f7153f7af602a" translate="yes" xml:space="preserve">
          <source>Outputs &lt;code&gt;tp&lt;/code&gt; into the stream &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="874ef341ee39bf6ca37a48e723e93ecd6207b6c2" translate="yes" xml:space="preserve">
          <source>Outputs &lt;code&gt;tp&lt;/code&gt; to the stream &lt;code&gt;os&lt;/code&gt;, as if by &lt;code&gt;std::chrono::to_stream(os, fmt, tp)&lt;/code&gt;, where &lt;code&gt;fmt&lt;/code&gt; is &lt;code&gt;&quot;%F %T %Z&quot;&lt;/code&gt; widened to &lt;code&gt;CharT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15b42247bceba0de8ed0074888c44235ac80940f" translate="yes" xml:space="preserve">
          <source>Outputs &lt;code&gt;tp&lt;/code&gt; to the stream &lt;code&gt;os&lt;/code&gt;, formatted according to the null-terminated format string &lt;code&gt;fmt&lt;/code&gt;. Equivalent to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e67234f5d7eea0ab8e0263206341fa62210158f" translate="yes" xml:space="preserve">
          <source>Outputs &lt;code&gt;tp&lt;/code&gt; to the stream &lt;code&gt;os&lt;/code&gt;, formatted according to the null-terminated format string &lt;code&gt;fmt&lt;/code&gt;. If &lt;code&gt;%Z&lt;/code&gt; is used, it is replaced with &lt;code&gt;&quot;GPS&quot;&lt;/code&gt; widened to &lt;code&gt;CharT&lt;/code&gt;. If &lt;code&gt;%z&lt;/code&gt; or a modified variant thereof is used, an offset of &lt;code&gt;0min&lt;/code&gt; will be formatted. The date and time formatted are equivalent to that formatted for a &lt;code&gt;std::chrono::sys_time&lt;/code&gt; initialized with &lt;code&gt;&lt;a href=&quot;../system_clock&quot;&gt;std::chrono::sys_time&lt;/a&gt;&amp;lt;Duration&amp;gt;(tp.time_since_epoch()) + &lt;a href=&quot;../duration&quot;&gt;std::chrono::days&lt;/a&gt;(3657)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58034ea9d3d70c0140caabb15d87fd231b9ca67d" translate="yes" xml:space="preserve">
          <source>Outputs &lt;code&gt;tp&lt;/code&gt; to the stream &lt;code&gt;os&lt;/code&gt;, formatted according to the null-terminated format string &lt;code&gt;fmt&lt;/code&gt;. If &lt;code&gt;%Z&lt;/code&gt; is used, it is replaced with &lt;code&gt;&quot;TAI&quot;&lt;/code&gt; widened to &lt;code&gt;CharT&lt;/code&gt;. If &lt;code&gt;%z&lt;/code&gt; or a modified variant thereof is used, an offset of &lt;code&gt;0min&lt;/code&gt; will be formatted. The date and time formatted are equivalent to that formatted for a &lt;code&gt;std::chrono::sys_time&lt;/code&gt; initialized with &lt;code&gt;&lt;a href=&quot;../system_clock&quot;&gt;std::chrono::sys_time&lt;/a&gt;&amp;lt;Duration&amp;gt;(tp.time_since_epoch()) - &lt;a href=&quot;../duration&quot;&gt;std::chrono::days&lt;/a&gt;(4383)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="428c786d1f9869ea658306f2cdbb3d68b071ae9f" translate="yes" xml:space="preserve">
          <source>Outputs &lt;code&gt;tp&lt;/code&gt; to the stream &lt;code&gt;os&lt;/code&gt;, formatted according to the null-terminated format string &lt;code&gt;fmt&lt;/code&gt;. If &lt;code&gt;%Z&lt;/code&gt; is used, it is replaced with &lt;code&gt;&quot;UTC&quot;&lt;/code&gt; widened to &lt;code&gt;CharT&lt;/code&gt;. If &lt;code&gt;%z&lt;/code&gt; or a modified variant thereof is used, an offset of &lt;code&gt;0min&lt;/code&gt; will be formatted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c72017c426f3712063f18aec84cd7d64ff7babc5" translate="yes" xml:space="preserve">
          <source>Outputs &lt;code&gt;tp&lt;/code&gt; to the stream &lt;code&gt;os&lt;/code&gt;, formatted according to the null-terminated format string &lt;code&gt;fmt&lt;/code&gt;. If &lt;code&gt;%Z&lt;/code&gt; is used, it is replaced with &lt;code&gt;&quot;UTC&quot;&lt;/code&gt; widened to &lt;code&gt;CharT&lt;/code&gt;. If &lt;code&gt;%z&lt;/code&gt; or a modified variant thereof is used, an offset of &lt;code&gt;0min&lt;/code&gt; will be formatted. If &lt;code&gt;tp&lt;/code&gt; represents a time during a leap second insertion and a seconds field is formatted, the integral portion of the field is &lt;code&gt;&quot;60&quot;&lt;/code&gt; widened to &lt;code&gt;CharT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f9bc1bf3428419e3b05937fb1eaacb1c0b53ee7" translate="yes" xml:space="preserve">
          <source>Outputs &lt;code&gt;tp&lt;/code&gt; to the stream &lt;code&gt;os&lt;/code&gt;, formatted according to the null-terminated format string &lt;code&gt;fmt&lt;/code&gt;. If &lt;code&gt;%Z&lt;/code&gt; is used, it is replaced with &lt;code&gt;&quot;UTC&quot;&lt;/code&gt; widened to &lt;code&gt;CharT&lt;/code&gt;. If &lt;code&gt;%z&lt;/code&gt; or a modified variant thereof is used, an offset of &lt;code&gt;0min&lt;/code&gt; will be formatted. The date and time formatted are equivalent to that formatted for &lt;code&gt;&lt;a href=&quot;../clock_cast&quot;&gt;std::chrono::clock_cast&lt;/a&gt;&amp;lt;&lt;a href=&quot;../system_clock&quot;&gt;std::chrono::system_clock&lt;/a&gt;&amp;gt;(tp)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../clock_cast&quot;&gt;std::chrono::clock_cast&lt;/a&gt;&amp;lt;&lt;a href=&quot;../utc_clock&quot;&gt;std::chrono::utc_clock&lt;/a&gt;&amp;gt;(tp)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea7b56d3f09958fa2717222fa926744b83d46482" translate="yes" xml:space="preserve">
          <source>Outputs &lt;code&gt;tp&lt;/code&gt; to the stream &lt;code&gt;os&lt;/code&gt;, formatted according to the null-terminated format string &lt;code&gt;fmt&lt;/code&gt;. If &lt;code&gt;%Z&lt;/code&gt; is used, it is replaced with &lt;code&gt;*abbrev&lt;/code&gt; widened to &lt;code&gt;CharT&lt;/code&gt; if &lt;code&gt;abbrev&lt;/code&gt; is not null; otherwise &lt;code&gt;os.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called. If &lt;code&gt;%z&lt;/code&gt; or a modified variant thereof is used, an offset of &lt;code&gt;*offset_sec&lt;/code&gt; will be formatted if &lt;code&gt;offset_sec&lt;/code&gt; is not null; otherwise &lt;code&gt;os.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="873537eb45c7a5d0f3c1a05064d4745b21a70282" translate="yes" xml:space="preserve">
          <source>Outputs &lt;code&gt;wd&lt;/code&gt; to the stream &lt;code&gt;os&lt;/code&gt;, formatted according to the null-terminated format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6723d1351bc308e3a68868adb08004a23ff912e9" translate="yes" xml:space="preserve">
          <source>Outputs &lt;code&gt;y&lt;/code&gt; to the stream &lt;code&gt;os&lt;/code&gt;, formatted according to the null-terminated format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91cd47c40812f32a7e5e0396652a850c604ec9c0" translate="yes" xml:space="preserve">
          <source>Outputs &lt;code&gt;ym&lt;/code&gt; to the stream &lt;code&gt;os&lt;/code&gt;, formatted according to the null-terminated format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7031f41e0f085d4f868ac2299a3930366000884" translate="yes" xml:space="preserve">
          <source>Outputs &lt;code&gt;ymd&lt;/code&gt; to the stream &lt;code&gt;os&lt;/code&gt;, formatted according to the null-terminated format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f08aaf397a9a09f0d44468374cde9ef2d3ded000" translate="yes" xml:space="preserve">
          <source>Outputs a textual representation of &lt;code&gt;md&lt;/code&gt; into the stream &lt;code&gt;os&lt;/code&gt;, as if by &lt;code&gt;os &amp;lt;&amp;lt; md.month() &amp;lt;&amp;lt; '/' &amp;lt;&amp;lt; md.day()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9acf45125762bd3c9b0bc29490a720e7af80eac2" translate="yes" xml:space="preserve">
          <source>Outputs a textual representation of &lt;code&gt;mdl&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;, as if by &lt;code&gt;os &amp;lt;&amp;lt; mdl.month() &amp;lt;&amp;lt; &quot;/last&quot;;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ffca1c7664c3d72d474951792fd1ba7f24be1cb" translate="yes" xml:space="preserve">
          <source>Outputs a textual representation of &lt;code&gt;mwd&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;, as if by &lt;code&gt;os &amp;lt;&amp;lt; mwd.month() &amp;lt;&amp;lt; '/' &amp;lt;&amp;lt; mwd.weekday_indexed();&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75551e8ddd1872ab7826ab17e18bedfd153a9607" translate="yes" xml:space="preserve">
          <source>Outputs a textual representation of &lt;code&gt;mwdl&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;, as if by &lt;code&gt;os &amp;lt;&amp;lt; mwdl.month() &amp;lt;&amp;lt; '/' &amp;lt;&amp;lt; mwdl.weekday_last();&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caa505470f325fd5cbb0a938dcfeb82a271ff11c" translate="yes" xml:space="preserve">
          <source>Outputs a textual representation of &lt;code&gt;wdi&lt;/code&gt; into the stream &lt;code&gt;os&lt;/code&gt;, as if by:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed20d256b1138136e27b3b24f545cd931ca12f04" translate="yes" xml:space="preserve">
          <source>Outputs a textual representation of &lt;code&gt;wdl&lt;/code&gt; into the stream &lt;code&gt;os&lt;/code&gt;, as if by &lt;code&gt;os &amp;lt;&amp;lt; wdl.weekday() &amp;lt;&amp;lt; &quot;[last]&quot;;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d0c45a80754fb338bcea897b299d2bcfd38e01a" translate="yes" xml:space="preserve">
          <source>Outputs a textual representation of &lt;code&gt;ym&lt;/code&gt; into the stream &lt;code&gt;os&lt;/code&gt;, as if by &lt;code&gt;os &amp;lt;&amp;lt; ym.year() &amp;lt;&amp;lt; '/' &amp;lt;&amp;lt; ym.month()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="587fb5dcc38ace0c9d533652b0ba3d0d9e5c959d" translate="yes" xml:space="preserve">
          <source>Outputs a textual representation of &lt;code&gt;ymd&lt;/code&gt; into the stream &lt;code&gt;os&lt;/code&gt;. This first forms a &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&amp;lt;CharT&amp;gt; s&lt;/code&gt; consisting of a textual representation of the date in the format &lt;code&gt;yyyy-mm-dd&lt;/code&gt; (same as the one output by &lt;a href=&quot;to_stream&quot;&gt;&lt;code&gt;to_stream&lt;/code&gt;&lt;/a&gt; with the %F specifier), and inserts it into &lt;code&gt;os&lt;/code&gt;. Then, if &lt;code&gt;!ymd.ok()&lt;/code&gt;, inserts &lt;code&gt;&quot; is not a valid date&quot;&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="707cb44faedeebc1ff17fe5b69260d36c754cb8c" translate="yes" xml:space="preserve">
          <source>Outputs a textual representation of &lt;code&gt;ymdl&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;, as if by &lt;code&gt;os &amp;lt;&amp;lt; ymdl.year() &amp;lt;&amp;lt; '/' &amp;lt;&amp;lt; ymdl.month_day_last();&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2157718155240cf0ee28067e499ccdda60050243" translate="yes" xml:space="preserve">
          <source>Outputs a textual representation of &lt;code&gt;ymwd&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;, as if by &lt;code&gt;os &amp;lt;&amp;lt; ymwd.year() &amp;lt;&amp;lt; '/' &amp;lt;&amp;lt; ymwd.month() &amp;lt;&amp;lt; '/' &amp;lt;&amp;lt; ymwdl.weekday_indexed();&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6b9335b90d7fead209b47cf48ba5e62d40ea1c6" translate="yes" xml:space="preserve">
          <source>Outputs a textual representation of &lt;code&gt;ymwdl&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;, as if by &lt;code&gt;os &amp;lt;&amp;lt; ymwdl.year() &amp;lt;&amp;lt; '/' &amp;lt;&amp;lt; ymwdl.month() &amp;lt;&amp;lt; '/' &amp;lt;&amp;lt; ymwdl.weekday_last();&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22b27e6ecf01e0f7edc4518fefbccb07b49dfac5" translate="yes" xml:space="preserve">
          <source>Outputs the initial seed sequence that's stored in the &lt;code&gt;std::seed_seq&lt;/code&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32c6288df94ec2f0f20a3ee01767d01fc924cb7d" translate="yes" xml:space="preserve">
          <source>Outside a class definition, it has a different meaning: see &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8add6e292c0ac9ab1b1cdb813b4382efdced99f7" translate="yes" xml:space="preserve">
          <source>Outside a template, a discarded statement is fully checked. &lt;code&gt;if constexpr&lt;/code&gt; is not a substitute for the &lt;a href=&quot;../preprocessor/conditional&quot;&gt;&lt;code&gt; #if&lt;/code&gt;&lt;/a&gt; preprocessing directive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48f9ed2305ed6770ea5c8757801cc42cfd4e8f46" translate="yes" xml:space="preserve">
          <source>Outside class definition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad1d5f9e730056d327074f1f71eb3c3ffee6ddcf" translate="yes" xml:space="preserve">
          <source>Outside the special case for copying vs. wrapping, the strong preference for initializer-list constructors in list-initialization remains intact.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8d5cf51177cbd61e9ad52eaa044095be31080c7" translate="yes" xml:space="preserve">
          <source>Overflows</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="956dd88f1ad8136a4b114799d6b5f0b99e153192" translate="yes" xml:space="preserve">
          <source>Overload</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="259384c9dbef4760700019ec5f52a4a0a0b841c0" translate="yes" xml:space="preserve">
          <source>Overload (2) is defined as deleted unless &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_copy_assignable&quot;&gt;std::is_copy_assignable_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;. It is trivial if &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_trivially_copy_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/is_copy_assignable&quot;&gt;std::is_trivially_copy_assignable_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; are all &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aafbb607a8998beee9cd44489804d6e830a23d9" translate="yes" xml:space="preserve">
          <source>Overload (2) is executed according to &lt;code&gt;policy&lt;/code&gt;, and does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f75a53a0c72ecf34e5872e7f823ce7189652277" translate="yes" xml:space="preserve">
          <source>Overload (3) does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_move_assignable&quot;&gt;std::is_move_assignable_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;. It is trivial if &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_trivially_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/is_move_assignable&quot;&gt;std::is_trivially_move_assignable_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; are all &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71324d05748e342e5443727cd9ce25e92f71f84c" translate="yes" xml:space="preserve">
          <source>Overload (3) in LLVM libc++ implements &lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#1203&quot;&gt;LWG#1203&lt;/a&gt; and returns a stream of the same type as the argument, so that code such as &lt;code&gt;(&lt;a href=&quot;../basic_ostringstream&quot;&gt;std::ostringstream&lt;/a&gt;() &amp;lt;&amp;lt; 1.2).str()&lt;/code&gt; compiles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="795fedb92392cb32533b361e5f5494bfe5162c21" translate="yes" xml:space="preserve">
          <source>Overload (4) is only provided if &lt;code&gt;std::filesystem::path::value_type&lt;/code&gt; is not &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a181f0abadc6a36d35481e99aadff71deab65a6e" translate="yes" xml:space="preserve">
          <source>Overload 7 is typically called with its second argument, &lt;code&gt;f&lt;/code&gt;, obtained directly from a new-expression: the locale is responsible for calling the matching &lt;code&gt;delete&lt;/code&gt; from its own destructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d51c265487097985743735a65214f5fc78530f2" translate="yes" xml:space="preserve">
          <source>Overload resolution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9827dcb8ed5f6e771d5237d5c7b7c94446630fd5" translate="yes" xml:space="preserve">
          <source>Overload resolution in this case has a final tiebreaker preferring non-rewritten candidates to rewritten candidates, and preferring non-synthesized rewritten candidates to synthesized rewritten candidates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ebfd83fa3c18fb85cb8b8ea8882ca6492017169" translate="yes" xml:space="preserve">
          <source>Overloaded operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c103f591199450f5ebc7abacb0d6ea1ea15aab92" translate="yes" xml:space="preserve">
          <source>Overloaded operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0384bd5bd878f4242ab921cc0022d2be9c4270c3" translate="yes" xml:space="preserve">
          <source>Overloaded operators (but not the built-in operators) can be called using function notation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bdb8bd2ef69fac45c3a993a2abaeebf53a0aa93" translate="yes" xml:space="preserve">
          <source>Overloaded operators are &lt;a href=&quot;functions&quot;&gt;functions&lt;/a&gt; with special function names:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec5878dd8d899636943fffee6342d476f6713cb3" translate="yes" xml:space="preserve">
          <source>Overloads</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a2b322288003a010e923b77110ef5b71022fee6" translate="yes" xml:space="preserve">
          <source>Overloads (2, 4) are executed according to &lt;code&gt;policy&lt;/code&gt;, and do not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="222def97a38edf629a6bcf12ebef128b0d2d376f" translate="yes" xml:space="preserve">
          <source>Overloads (2,4) are executed according to &lt;code&gt;policy&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b49739ab03a90cdb267b283f5956f66da9626a0f" translate="yes" xml:space="preserve">
          <source>Overloads (2,4,6) are executed according to &lt;code&gt;policy&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67e23e637e38658e283000cd535b455afa296ce4" translate="yes" xml:space="preserve">
          <source>Overloads 1-7 of &lt;a href=&quot;../basic_ostream/operator_ltlt&quot;&gt;&lt;code&gt;basic_ostream::operator&amp;lt;&amp;lt;()&lt;/code&gt;&lt;/a&gt; (at Stage 3 of &lt;a href=&quot;../../locale/num_put/put&quot;&gt;&lt;code&gt;num_put::put()&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11eaee190a7efd61370fdb288e72070a227d5eaf" translate="yes" xml:space="preserve">
          <source>Overloads of &lt;code&gt;operator delete&lt;/code&gt; and &lt;code&gt;operator delete[]&lt;/code&gt; with additional user-defined parameters (&quot;placement forms&quot;, (15,16)) may be declared at global scope as usual, and are called by the matching placement forms of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e36ddac16322317a2b4aed9439e1c550e63f8907" translate="yes" xml:space="preserve">
          <source>Overloads of &lt;code&gt;operator delete&lt;/code&gt; and &lt;code&gt;operator delete[]&lt;/code&gt; with additional user-defined parameters (&quot;placement forms&quot;, (25,26)) may also be defined as class members. When the failed placement new expression looks for the corresponding placement delete function to call, it begins lookup at class scope before examining the global scope, and looks for the function with the signature matching the placement new:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e87bdef13aa697c71d23a2d7468b3c4d73626ef5" translate="yes" xml:space="preserve">
          <source>Overloads of &lt;code&gt;operator new&lt;/code&gt; and &lt;code&gt;operator new[]&lt;/code&gt; with additional user-defined parameters (&quot;placement forms&quot;), may also be defined as class members (19-22)). When the placement new expression with the matching signature looks for the corresponding allocation function to call, it begins at class scope before examining the global scope, and if the class-specific placement new is provided, it is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86d5fbf9f236a5a97bf79c6de9ddc77dcf7fb9fb" translate="yes" xml:space="preserve">
          <source>Overloads of &lt;code&gt;operator new&lt;/code&gt; and &lt;code&gt;operator new[]&lt;/code&gt; with additional user-defined parameters (&quot;placement forms&quot;, versions (11-14)) may be declared at global scope as usual, and are called by the matching placement forms of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5ef66641047e782ad959fa23e7175f6500bf9e0" translate="yes" xml:space="preserve">
          <source>Overloads the &lt;code&gt;&lt;a href=&quot;../../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt;. Exchanges the state of &lt;code&gt;lhs&lt;/code&gt; with that of &lt;code&gt;rhs&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4a79f0b0e988b58b6011ed44270cf696ae27cec" translate="yes" xml:space="preserve">
          <source>Overloads the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../any&quot;&gt;std::any&lt;/a&gt;&lt;/code&gt;. Swaps the content of two &lt;code&gt;any&lt;/code&gt; objects by calling &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbb14f708c237141ced4513ad7e6aef1336436ee" translate="yes" xml:space="preserve">
          <source>Overloads the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt;. Exchanges the state of &lt;code&gt;lhs&lt;/code&gt; with that of &lt;code&gt;rhs&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e8e7bc267d9373c9c4f8d75720fb039616c790e" translate="yes" xml:space="preserve">
          <source>Overloads the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt;. Exchanges the state of &lt;code&gt;lhs&lt;/code&gt; with that of &lt;code&gt;rhs&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a65926ea8bdf8998081970f3661c897cbec42ed" translate="yes" xml:space="preserve">
          <source>Overloads the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt;. Exchanges the state of &lt;code&gt;lhs&lt;/code&gt; with that of &lt;code&gt;rhs&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6960031e2bd04c61a04bbc7e505524aa0a11135a" translate="yes" xml:space="preserve">
          <source>Overloads the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt;. Exchanges the state of &lt;code&gt;lhs&lt;/code&gt; with that of &lt;code&gt;rhs&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19c793b42526d11d9fba9ba492817bd012131663" translate="yes" xml:space="preserve">
          <source>Overloads the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt;. Exchanges the state of &lt;code&gt;lhs&lt;/code&gt; with that of &lt;code&gt;rhs&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd06ba1f692980b72e587b813835c343d0d76c79" translate="yes" xml:space="preserve">
          <source>Overloads the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;&lt;a href=&quot;../variant&quot;&gt;std::variant&lt;/a&gt;&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d5487ceb2a229a1cfede3475d49b39fffe6ea56" translate="yes" xml:space="preserve">
          <source>Overloads the &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; algorithm for &lt;code&gt;std::basic_syncbuf&lt;/code&gt;. Exchanges the state of &lt;code&gt;lhs&lt;/code&gt; with that of &lt;code&gt;rhs&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96c6199819a0d6bfedf051209a3a06dac60814e1" translate="yes" xml:space="preserve">
          <source>Overwrites the current pointer with the argument &lt;code&gt;current_ptr = ptr&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db011a378e10d85de899e2cd381fba83201c7174" translate="yes" xml:space="preserve">
          <source>Over​load​able</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e2d257bed8e9f2ce936888c6ddc450d63c74cdd" translate="yes" xml:space="preserve">
          <source>Ownership of the previously acquired lock &lt;code&gt;lk&lt;/code&gt; is transferred to internal storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="511993d3c99719e38a6779073019dacd7178ddb9" translate="yes" xml:space="preserve">
          <source>P</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1a324fa062c9e26e00c18e22544ad0506e15306" translate="yes" xml:space="preserve">
          <source>P &amp;gt; X &amp;ge; &amp;minus;4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83d009599b4e30148a6c333642990ba0b9350d9a" translate="yes" xml:space="preserve">
          <source>P &amp;minus; 1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0314c3d6e90b3565b95808c2051a435d624960e" translate="yes" xml:space="preserve">
          <source>P &amp;minus; 1 &amp;minus; X</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8c3a915c86caed6ba7c3f5b43d945fd53ed4841" translate="yes" xml:space="preserve">
          <source>P0136R1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c091f2982c8d701b0542a09dfc39c19ecc4d52c" translate="yes" xml:space="preserve">
          <source>P0475R1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="180cc074f85fb06c41dd8640446d673c8de11c4e" translate="yes" xml:space="preserve">
          <source>P0558R1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="431e5cea17e1bf663cdf64414c0cab36991a5d42" translate="yes" xml:space="preserve">
          <source>P0602R4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="742a2a31b42a4f3ccb6d7b40782cc8c99397bc8c" translate="yes" xml:space="preserve">
          <source>P0608R3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ef3f6067e8f0c97a32b87f533e0cb07b835211a" translate="yes" xml:space="preserve">
          <source>P0702R1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f4a4b16778729c3afbc13336d570943ef5641e6" translate="yes" xml:space="preserve">
          <source>P0738R2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1420d2af8fbac7b93b53c44cc77652ab02ea9e64" translate="yes" xml:space="preserve">
          <source>P0739R0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32bd781a23eba5870d3ea629503f89fcc39a9713" translate="yes" xml:space="preserve">
          <source>P0759R1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0a476da9f61efd4482ad03c3f6aa3d9da3973ae" translate="yes" xml:space="preserve">
          <source>P0935R0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05830e351e8164b4a68c720acc3398a3514d4172" translate="yes" xml:space="preserve">
          <source>P0961R1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d58644db3eb2b21ab0dc37251bceb2768106d61" translate="yes" xml:space="preserve">
          <source>P0962R1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e087ab05039eeed7b3a1d110c7c8a35d596bb687" translate="yes" xml:space="preserve">
          <source>P0969R0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aed2345aeaebbc289660c8fc2f5cf3f8c5f5d2ab" translate="yes" xml:space="preserve">
          <source>P1009R2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fca6bfd713ae6236d0c908b7c867ffaab8bfc759" translate="yes" xml:space="preserve">
          <source>P1148R0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e307df684ee437ad55048ef5abae21e73f66f95" translate="yes" xml:space="preserve">
          <source>P1164R1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f616d012fed77610b84bce5893218bd1089cbbd" translate="yes" xml:space="preserve">
          <source>PIMPL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9110e35dcc0fd1f526f32258ab320a6ae2b04b5c" translate="yes" xml:space="preserve">
          <source>PImpl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02973ce224a371cd57d01c169dcdbd8da0d90558" translate="yes" xml:space="preserve">
          <source>POD (Plain Old Data) structure, compatible with C &lt;code&gt;struct&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd1395a6a776b1b9805d9663f05918d2179372c6" translate="yes" xml:space="preserve">
          <source>PODType</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c0c0a1c20866f175fd10b2aef4d095e149b6f0d" translate="yes" xml:space="preserve">
          <source>POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/abort.html&quot;&gt;specifies&lt;/a&gt; that the abort() function overrides blocking or ignoring the SIGABRT signal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cc98020fce8b9e7debb8956dfde324137689cc7" translate="yes" xml:space="preserve">
          <source>POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fflush.html&quot;&gt;extends the specification of fflush&lt;/a&gt; by defining its effects on an input stream, as long as that stream represents a file or another seekable device: in that case the POSIX file pointer is repositioned to match the C stream pointer (which effectively undoes any read buffering) and the effects of any &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;std::ungetc&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ungetwc&quot;&gt;std::ungetwc&lt;/a&gt;&lt;/code&gt; that weren't yet read back from the stream are discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="417bd6e66e13b5cf5b7787df74da03ed895b117e" translate="yes" xml:space="preserve">
          <source>POSIX allows seeking beyond the existing end of file. If an output is performed after this seek, any read from the gap will return zero bytes. Where supported by the filesystem, this creates a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ca50ebb591b6d07b87a0ee2add3e84ece52f6b7" translate="yes" xml:space="preserve">
          <source>POSIX also defines a locale named &quot;POSIX&quot;, which is always accessible and is exactly equivalent to the default minimal &quot;C&quot; locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5c99d90ac31157dc0791fbf617b9f4d8a8fb0f3" translate="yes" xml:space="preserve">
          <source>POSIX also requires that fseek first performs &lt;code&gt;fflush&lt;/code&gt; if there are any unwritten data (but whether the shift state is restored is implementation-defined). The standard C++ file streams guarantee both flushing and unshifting: &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekoff&quot;&gt;std::basic_filebuf::seekoff&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be16d006c16b3a9cd701f5b1c06b599965dc5727" translate="yes" xml:space="preserve">
          <source>POSIX also requires that, on XSI-conformant systems, the value returned when the correct result is greater than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; and the value returned when the correct result is less than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df9013b0fb54c48f8c3398535564a8c9fb6d5c1b" translate="yes" xml:space="preserve">
          <source>POSIX also specifies that in case of underflow, &lt;code&gt;arg&lt;/code&gt; is returned unmodified, and if that is not supported, an implementation-defined value no greater than DBL_MIN, FLT_MIN, and LDBL_MIN is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="335c1690cc5b65b3646d4724816b44c455691178" translate="yes" xml:space="preserve">
          <source>POSIX also specifies that the returned pointer, not just the contents of the pointed-to string, may be invalidated by subsequent calls to setlocale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7256451e69c117e322fee42c240d220beaf0323" translate="yes" xml:space="preserve">
          <source>POSIX defines &lt;code&gt;CLOCKS_PER_SEC&lt;/code&gt; as one million, regardless of the actual precision of &lt;code&gt;&lt;a href=&quot;clock&quot;&gt;std::clock()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="772bebdbba24c17112a1c0df673e3d065c42330b" translate="yes" xml:space="preserve">
          <source>POSIX equivalent</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f9897e2a366ea005d44ffdc34adfd993a15fa8e" translate="yes" xml:space="preserve">
          <source>POSIX implementations do not distinguish between text and binary streams (there is no special mapping for \n or any other characters).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8856b5eaf0d4bc59c7900e57d597384a95e21ed" translate="yes" xml:space="preserve">
          <source>POSIX limits undefined behaviors only to when the output string would be longer than 25 characters, when &lt;code&gt;timeptr-&amp;gt;tm_wday&lt;/code&gt; or &lt;code&gt;timeptr-&amp;gt;tm_mon&lt;/code&gt; are not within the expected ranges, or when &lt;code&gt;timeptr-&amp;gt;tm_year&lt;/code&gt; exceeds &lt;code&gt;INT_MAX-1990&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c567b9031ff51fb9b1ea5a64cf6d5a57e9f563c1" translate="yes" xml:space="preserve">
          <source>POSIX requires that &lt;code&gt;signal&lt;/code&gt; is thread-safe, and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_04&quot;&gt;specifies a list of async-signal-safe library functions&lt;/a&gt; that may be called from any signal handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="903095d57d9e8d5d7ba86327be4b6118ef517305" translate="yes" xml:space="preserve">
          <source>POSIX requires that the LC_CTYPE facet of the currently installed C locale is stored within the stream object the moment its orientation becomes wide, and is used for all future I/O on this stream until the orientation is changed, regardless of any subsequent calls to &lt;code&gt;&lt;a href=&quot;../locale/setlocale&quot;&gt;std::setlocale&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48bc329336aeacdedd08a49b5dc507c08099629f" translate="yes" xml:space="preserve">
          <source>POSIX requires that this function sets &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EOVERFLOW&lt;/a&gt;&lt;/code&gt; if it fails because the argument is too large.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8b30a676c41f80a5f706703b6d07cc60f882fc2" translate="yes" xml:space="preserve">
          <source>POSIX specifies a common extension: if &lt;code&gt;dst&lt;/code&gt; is a null pointer, this function returns the number of bytes that would be written to &lt;code&gt;dst&lt;/code&gt;, if converted. Similar behavior is standard for &lt;code&gt;&lt;a href=&quot;wcsrtombs&quot;&gt;std::wcsrtombs&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c86973f4703a4c901af0c811412fae73ee39f9b" translate="yes" xml:space="preserve">
          <source>POSIX specifies a common extension: if &lt;code&gt;dst&lt;/code&gt; is a null pointer, this function returns the number of wide characters that would be written to &lt;code&gt;dst&lt;/code&gt;, if converted. Similar behavior is standard for &lt;code&gt;&lt;a href=&quot;mbsrtowcs&quot;&gt;std::mbsrtowcs&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f640ef44ff8aceca9d40819362503cdf028c703d" translate="yes" xml:space="preserve">
          <source>POSIX systems additionally define the similarly named function &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/tempnam.html&quot;&gt;tempnam()&lt;/a&gt;&lt;/code&gt;, which offers the choice of a directory (which defaults to the optionally defined macro &lt;code&gt;&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stdio.h.html&quot;&gt;P_tmpdir&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa7f23440c5e010aad2d2ccafe47dbb355777115" translate="yes" xml:space="preserve">
          <source>PRESENTATION FORM FOR VERTICAL LEFT SQUARE BRACKET - REPLACEMENT CHARACTER</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9038209047a71e4b1367742bc39b28d75cfc8e64" translate="yes" xml:space="preserve">
          <source>PRESENTATION FORM FOR VERTICAL RIGHT WHITE CORNER BRACKET</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e32c86e68f0c3abd2b6849b7710c5767864e34c" translate="yes" xml:space="preserve">
          <source>PRIX8PRIX16PRIX32PRIX64PRIXLEAST8PRIXLEAST16PRIXLEAST32PRIXLEAST64PRIXFAST8PRIXFAST16PRIXFAST32PRIXFAST64PRIXMAXPRIXPTR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8f7145f57c3449a8db7e8e0c0eb5442612d6d1a" translate="yes" xml:space="preserve">
          <source>PRIX&lt;b&gt;x&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a64e120776de9fbefa5418d4d43b3ba89d70837" translate="yes" xml:space="preserve">
          <source>PRIXFAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ddbba6bf4dafbb2a873648eda5d9098a39a0f38" translate="yes" xml:space="preserve">
          <source>PRIXLEAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18e1b5b3da1f5696ee1b5d766902e3bdf9a229ea" translate="yes" xml:space="preserve">
          <source>PRIXMAX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="781c2eb6dafec442ebfc72f8b7ebae2317fe378f" translate="yes" xml:space="preserve">
          <source>PRIXPTR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b40b5bb9283b3b71cd88f48d52e9c33509ce0acb" translate="yes" xml:space="preserve">
          <source>PRId8PRId16PRId32PRId64PRIdLEAST8PRIdLEAST16PRIdLEAST32PRIdLEAST64PRIdFAST8PRIdFAST16PRIdFAST32PRIdFAST64PRIdMAXPRIdPTR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7d33bb5db43e551d35c482fd09131ad46207a8d" translate="yes" xml:space="preserve">
          <source>PRId&lt;b&gt;x&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b3f9185242ed4fd4aa7fe79711cff60ca67e2f7" translate="yes" xml:space="preserve">
          <source>PRIdFAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8d0c46ca6bb30380b59f4f101705eefd6490015" translate="yes" xml:space="preserve">
          <source>PRIdLEAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc53f81c479d6b89c4ff776e1934d8e02814c41f" translate="yes" xml:space="preserve">
          <source>PRIdMAX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a17d0b9784580f9889085e64178ec0165b48f47c" translate="yes" xml:space="preserve">
          <source>PRIdPTR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51c6c07bd6952cee11453f9e037b2eb9dc59f813" translate="yes" xml:space="preserve">
          <source>PRIi8PRIi16PRIi32PRIi64PRIiLEAST8PRIiLEAST16PRIiLEAST32PRIiLEAST64PRIiFAST8PRIiFAST16PRIiFAST32PRIiFAST64PRIiMAXPRIiPTR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="714fc0bc0af7a9749d04748234fc179ac576a244" translate="yes" xml:space="preserve">
          <source>PRIi&lt;b&gt;x&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea09c5b25c9c93bc85281625a00cd1a3f3cb84b3" translate="yes" xml:space="preserve">
          <source>PRIiFAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2bc784563d7725f115131118c7018a222c378c5" translate="yes" xml:space="preserve">
          <source>PRIiLEAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6358aee55979a62f99273506f52e4e38200b3ace" translate="yes" xml:space="preserve">
          <source>PRIiMAX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="032e31e8a0c90d21725ebd9b9787dd714fdc2aad" translate="yes" xml:space="preserve">
          <source>PRIiPTR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d908c20b988abbf1aa5b371eee7faa067fd36fd1" translate="yes" xml:space="preserve">
          <source>PRIo8PRIo16PRIo32PRIo64PRIoLEAST8PRIoLEAST16PRIoLEAST32PRIoLEAST64PRIoFAST8PRIoFAST16PRIoFAST32PRIoFAST64PRIoMAXPRIoPTR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d58f3f7ece61a2a7733019776f7e3739fcf290b4" translate="yes" xml:space="preserve">
          <source>PRIo&lt;b&gt;x&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bb1f0b366d2a11133856c82c60391c095a82cda" translate="yes" xml:space="preserve">
          <source>PRIoFAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e51125962ffd20d71e1b64e858f7cd2fc64c083" translate="yes" xml:space="preserve">
          <source>PRIoLEAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="804d9608ba0996c9a1dbcdbe7dc4ff6089c2c1be" translate="yes" xml:space="preserve">
          <source>PRIoMAX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c416df2e883d4710bb2459e89d0cecd848a9c16f" translate="yes" xml:space="preserve">
          <source>PRIoPTR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff7440c50ec984568aa7911c491f18a07214f394" translate="yes" xml:space="preserve">
          <source>PRIu8PRIu16PRIu32PRIu64PRIuLEAST8PRIuLEAST16PRIuLEAST32PRIuLEAST64PRIuFAST8PRIuFAST16PRIuFAST32PRIuFAST64PRIuMAXPRIuPTR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cef6a59a75eb0c565c5c285d0bd5628314f68c33" translate="yes" xml:space="preserve">
          <source>PRIu&lt;b&gt;x&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60e1df3d0d76c883177df0c85e11dc9f4782c343" translate="yes" xml:space="preserve">
          <source>PRIuFAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7de01de7367eabf2a6cbb0005c1ee9b3e0ff536" translate="yes" xml:space="preserve">
          <source>PRIuLEAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d19cc5e39483d2b638c9747d236b9f98cf2ba6" translate="yes" xml:space="preserve">
          <source>PRIuMAX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a53e86b08e7c119ae3fe44531c7aaf0301532d48" translate="yes" xml:space="preserve">
          <source>PRIuPTR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02ed8f75fb17245160368a668639aec2b40ba381" translate="yes" xml:space="preserve">
          <source>PRIx8PRIx16PRIx32PRIx64PRIxLEAST8PRIxLEAST16PRIxLEAST32PRIxLEAST64PRIxFAST8PRIxFAST16PRIxFAST32PRIxFAST64PRIxMAXPRIxPTR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d4d67b6d521f879ad2c3fae70c27987e0b2b365" translate="yes" xml:space="preserve">
          <source>PRIx&lt;b&gt;x&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac79b02c9366823911f81b644baaade6a66b7127" translate="yes" xml:space="preserve">
          <source>PRIxFAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efcc600b2091877d2742f8fc3653c4b5f63f4a12" translate="yes" xml:space="preserve">
          <source>PRIxLEAST&lt;b&gt;x&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdaafdc9843631b79c26045d58fabfb0fc7c9663" translate="yes" xml:space="preserve">
          <source>PRIxMAX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29216749819cc7374de90e9b38698676527b3a0a" translate="yes" xml:space="preserve">
          <source>PRIxPTR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d341dab357c92fea1cc61d3e72cb6281d41c97" translate="yes" xml:space="preserve">
          <source>PTRDIFF_MAX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68e5106036965c9d086871ec56706e8f44965f32" translate="yes" xml:space="preserve">
          <source>PTRDIFF_MIN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b6081a6f0f13755285d07d3d8463cd8898985ee" translate="yes" xml:space="preserve">
          <source>Pack expansion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bb34df49903d68db123475b27c8f3c3f1c36782" translate="yes" xml:space="preserve">
          <source>Pack expansion may appear in a template parameter list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32cba7e04aa6991dbe5968cd75f20769bb947ec5" translate="yes" xml:space="preserve">
          <source>Pack expansions are allowed in both the lists of types and the lists of expressions used by the keyword &lt;a href=&quot;alignas&quot;&gt;alignas&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e30292830e68f620761531e9df741302b3e6c46" translate="yes" xml:space="preserve">
          <source>Pack expansions are allowed in the lists of &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt;, as in &lt;code&gt;[[attributes...]]&lt;/code&gt;. For example: &lt;code&gt;void [[attributes...]] function()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b73376026cace29b20975bb97767ba34f50689e6" translate="yes" xml:space="preserve">
          <source>Pack expansions can be used anywhere in a template argument list, provided the template has the parameters to match the expansion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac9445aab9e049aa1712ba92597d2990b9da4d31" translate="yes" xml:space="preserve">
          <source>Pack expansions in &lt;a href=&quot;language/using_declaration&quot;&gt;&lt;code&gt;using&lt;/code&gt;-declarations&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f97b357770a609bfac0a6f1e54f52ca1182cbc3" translate="yes" xml:space="preserve">
          <source>Padding bits that never participate in an object's value representation are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d130b25258ad078df3bcbf095b9cd09ba45dbd3" translate="yes" xml:space="preserve">
          <source>Pairs and tuples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98d1e6a43e96f3d9e0a4f702dd391c1fb040a6a3" translate="yes" xml:space="preserve">
          <source>Parallel exceptions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="521ca95f4bf7606cd77ec3e16d75e8bd5b0bfa8a" translate="yes" xml:space="preserve">
          <source>Parallel forward progress</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19179ec3453b86e6c73d427e151e6d2b42933392" translate="yes" xml:space="preserve">
          <source>Parallelism TS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77a66c430eb423e00b3fb0017ac40d5b9bab8863" translate="yes" xml:space="preserve">
          <source>Parameter list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78e1bafebed14f7e8ea9c1a0798383f387144678" translate="yes" xml:space="preserve">
          <source>Parameter list determines the arguments that can be specified when the function is called. It is a comma-separated list of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ce13956e8bbf2186530157eaf31f6efdc385e25" translate="yes" xml:space="preserve">
          <source>Parameter names declared in function declarations are usually for only self-documenting purposes. They are used (but remain optional) in function definitions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b943666e90d5be6ba89486d6fd81854889e2d6" translate="yes" xml:space="preserve">
          <source>Parameter pack expansion (appears in a body of a variadic template).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56259615894ffce758a54a6d1cab4ed77f280b66" translate="yes" xml:space="preserve">
          <source>Parameter pack(since C++11)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="101abc0f00f96e749bda6b5c9ed0f622337e304e" translate="yes" xml:space="preserve">
          <source>Parameter type cannot be a type that includes a reference or a pointer to array of unknown bound, including a multi-level pointers/arrays of such types, or a pointer to functions whose parameters are such types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcc4303a9da5dbeb48c205e1731a5df97fc09795" translate="yes" xml:space="preserve">
          <source>Parameters with dependent types in which no template-parameters participate in template argument deduction, and parameters that became non-dependent due to substitution of explicitly-specified template arguments will be checked during overload resolution:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1721db6938b3e4e87d6a50edc62881e29a12be98" translate="yes" xml:space="preserve">
          <source>Parenthesized initializers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2960fe29fd2b915b126cab00326690bd5d95cdba" translate="yes" xml:space="preserve">
          <source>Parses monetary value from an input iterator and writes the result to a &lt;code&gt;long double&lt;/code&gt; or string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbccee632d086c93c07fba35e5f388c3b80df7a1" translate="yes" xml:space="preserve">
          <source>Parses the ISO 8601 week of the year as a decimal number. The width</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ba57ea8084a289cba4c0a7e99cff1c198319cc" translate="yes" xml:space="preserve">
          <source>Parses the ISO 8601 week-based year as a decimal number. The width</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="395d643e661e43d4fcabf734907ac9eb65758479" translate="yes" xml:space="preserve">
          <source>Parses the ISO weekday as a decimal number (1-7), where Monday is &lt;code&gt;1&lt;/code&gt;. The width</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c5ca32563d6b2d004c6752fed665ca688585f82" translate="yes" xml:space="preserve">
          <source>Parses the century as a decimal number. The width</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f68456899e2a091127949527a497cb1345e7765" translate="yes" xml:space="preserve">
          <source>Parses the day of month as a decimal number. The width</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="291bdd40d8ccf86bc8dbd800b41e7578962c4249" translate="yes" xml:space="preserve">
          <source>Parses the day of the year as a decimal number (January 1 is &lt;code&gt;1&lt;/code&gt;). The width</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52877a5eb4400c34ebe6bbb5f0c6681593be16f0" translate="yes" xml:space="preserve">
          <source>Parses the hour (12-hour clock) as a decimal number. The width</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04e2c41287bc88bc974edbb7eb22af3d5c2baecd" translate="yes" xml:space="preserve">
          <source>Parses the hour (24-hour clock) as a decimal number. The width</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23fef8471fcc3851b556caa9fc767615d26ffe80" translate="yes" xml:space="preserve">
          <source>Parses the last two decimal digits of the ISO 8601 week-based year. The width</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ab0b9d67419f7ebcb84e6cfe3796b8cf422e7fa" translate="yes" xml:space="preserve">
          <source>Parses the last two decimal digits of the year. If the century is not otherwise specified (e.g. with %C), values in the range [69, 99] are presumed to refer to the years 1969 to 1999, and values in the range [00, 68] are presumed to refer to the years 2000 to 2068. The width</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8465df73c69b4807aab87472f77e8662306bee7e" translate="yes" xml:space="preserve">
          <source>Parses the locale's 12-hour clock time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="580208b8bb1f0528afc2b345f83301d1a4b1f77c" translate="yes" xml:space="preserve">
          <source>Parses the locale's date and time representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c222505888c9e62bebda4c67cdbe6ae2355f30e" translate="yes" xml:space="preserve">
          <source>Parses the locale's date representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be598b6afdf65e704bb248ff32a6099d90cf538a" translate="yes" xml:space="preserve">
          <source>Parses the locale's equivalent of the AM/PM designations associated with a 12-hour clock. The command &lt;code&gt;%I&lt;/code&gt; must precede &lt;code&gt;%p&lt;/code&gt; in the format string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf01e9043018d9557cabd2d072ce9c4d66ec59d4" translate="yes" xml:space="preserve">
          <source>Parses the locale's full or abbreviated case-insensitive month name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db6c34a3065a85a370856813055e1a821ed4ce0a" translate="yes" xml:space="preserve">
          <source>Parses the locale's full or abbreviated case-insensitive weekday name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d76e921b04269dcc9eec721d8cca099e56a2cf8" translate="yes" xml:space="preserve">
          <source>Parses the locale's time representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd641a9992df36816f97e05fd95dfa3eb83a1c3" translate="yes" xml:space="preserve">
          <source>Parses the minute as a decimal number. The width</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4c74f673789fd3e6a5d5b74d3b5da004137b2ee" translate="yes" xml:space="preserve">
          <source>Parses the month as a decimal number (January is &lt;code&gt;1&lt;/code&gt;). The width</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6b40ebcbed9d4dc1e0b0c9da7f486736d235f09" translate="yes" xml:space="preserve">
          <source>Parses the offset from UTC in the format &lt;code&gt;[+|-]hh[mm]&lt;/code&gt;. For example &lt;code&gt;-0430&lt;/code&gt; refers to 4 hours 30 minutes behind UTC and &lt;code&gt;04&lt;/code&gt; refers to 4 hours ahead of UTC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="585e1beb811a618fc195a0236e605b1836e64693" translate="yes" xml:space="preserve">
          <source>Parses the second as a decimal number. The width</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a9279faac389290039ad0de9b89b8412acfd228" translate="yes" xml:space="preserve">
          <source>Parses the time zone abbreviation or name, taken as the longest sequence of characters that only contains the characters &lt;code&gt;A&lt;/code&gt; through &lt;code&gt;Z&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;z&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;9&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;_&lt;/code&gt;, and &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7caca66d1e432353334d9929e16fddeefa9c5775" translate="yes" xml:space="preserve">
          <source>Parses the week number of the year as a decimal number. The first Monday of the year is the first day of week 01. Days of the same year prior to that are in week 00. The width</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2f84cca567ea874d519044289dcf913a33a6c65" translate="yes" xml:space="preserve">
          <source>Parses the week number of the year as a decimal number. The first Sunday of the year is the first day of week 01. Days of the same year prior to that are in week 00. The width</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="467e909a99f5ef65faa8f88b79a713dfa8aaa29f" translate="yes" xml:space="preserve">
          <source>Parses the weekday as a decimal number (0-6), where Sunday is &lt;code&gt;0&lt;/code&gt;. The width</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5e8ff1b8408b13ca8581079c73346de22d52579" translate="yes" xml:space="preserve">
          <source>Parses the year as a decimal number. The width</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74795b31d322abe281db13d0689fd2777945a03a" translate="yes" xml:space="preserve">
          <source>Partial function application</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78eeb1245b7c3a2283b63fb5c4390d67fa03447f" translate="yes" xml:space="preserve">
          <source>Partial function application (e.g. &lt;code&gt;&lt;a href=&quot;utility/functional/bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt;) and related utilities: utilities for binding such as &lt;code&gt;&lt;a href=&quot;utility/functional/ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;utility/functional/placeholders&quot;&gt;std::placeholders&lt;/a&gt;&lt;/code&gt;, polymorphic function wrappers: &lt;code&gt;&lt;a href=&quot;utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt;, predefined functors (e.g. &lt;code&gt;&lt;a href=&quot;utility/functional/plus&quot;&gt;std::plus&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;utility/functional/equal_to&quot;&gt;std::equal_to&lt;/a&gt;&lt;/code&gt;), method to function converters &lt;code&gt;&lt;a href=&quot;utility/functional/mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71e6689764a9b13201b0466b88cbd7ce140c9c0f" translate="yes" xml:space="preserve">
          <source>Partial ordering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce93f4147e6d4909935138213789b01d1b253553" translate="yes" xml:space="preserve">
          <source>Partial ordering is an ordering that allows incomparable (unordered) values, such as NaN values in floating-point ordering, or, in this example, persons that are not related:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f53ffcf15c11c573f5545e79649b66a2431858f" translate="yes" xml:space="preserve">
          <source>Partial ordering of constraints</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb05875c075b3e705445a0dc4e3b991c1c97e57f" translate="yes" xml:space="preserve">
          <source>Partial ordering of function templates containing template parameter packs is independent of the number of deduced arguments for those template parameter packs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44db9e9f209585392738e63d10d43e1ea4ad7a6a" translate="yes" xml:space="preserve">
          <source>Partial specialization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b88bd82c6f81346a2011676ec77b7501943f1a65" translate="yes" xml:space="preserve">
          <source>Partial specialization for pointer types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c4c0e106da62acaf653ca92c911aafda27751b0" translate="yes" xml:space="preserve">
          <source>Partial specializations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c1bdb4a72a34c45c6e85959311eeeb701d51447" translate="yes" xml:space="preserve">
          <source>Partial specializations of member template may appear both at class scope and at enclosing namespace scope, but explicit specializations may only appear at enclosing namespace scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bd8e8e770457f7fbd269ed17713881c6d27a25f" translate="yes" xml:space="preserve">
          <source>Partial template specializations are not found by name lookup. Only if the primary template is found by name lookup, its partial specializations are considered. In particular, a using declaration that makes a primary template visible, makes partial specializations visible as well:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de3c82918ea9acb57f3a0f8280207e5e45f43198" translate="yes" xml:space="preserve">
          <source>Partial-date types (&lt;a href=&quot;year_month&quot;&gt;&lt;code&gt;year_month&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;month_day&quot;&gt;&lt;code&gt;month_day&lt;/code&gt;&lt;/a&gt;, etc.) can be created by not applying the second &lt;code&gt;operator/&lt;/code&gt; in any of the three orders.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ef374455771d741fc71e955e9d9af3de8a1ad90" translate="yes" xml:space="preserve">
          <source>Partially-ordered dynamic initialization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edcbb405d359c267c6b18a9a215e4dfe12ea385c" translate="yes" xml:space="preserve">
          <source>Partitioning operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5b3d7490f772f9dbcabf630ff06cd2a767a7576" translate="yes" xml:space="preserve">
          <source>Passing a &lt;code&gt;size&lt;/code&gt; which is not an integral multiple of &lt;code&gt;alignment&lt;/code&gt; or an &lt;code&gt;alignment&lt;/code&gt; which is not valid or not supported by the implementation causes the function to fail and return a null pointer (C11, as published, specified undefined behavior in this case, this was corrected by DR 460).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b52c936cd02e21570c17b12d06c04d0b4944cf3f" translate="yes" xml:space="preserve">
          <source>Passing a non-const reference to the string to any standard library function, or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53a0a261ebfc0f1a7a7170e67bdddcdb68c6dea0" translate="yes" xml:space="preserve">
          <source>Past-the-end iterator for the new range of values (if this is not &lt;code&gt;end&lt;/code&gt;, then it points to an unspecified value, and so do iterators to any values between this iterator and &lt;code&gt;end&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="209fb9ddb37807d60128b4f0a2c9c342ca9bef9b" translate="yes" xml:space="preserve">
          <source>Path equality and equivalence have different semantics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="278d3d482f0154f969d1faa7956e1e7b204c6b2d" translate="yes" xml:space="preserve">
          <source>Path relative to the &lt;a href=&quot;root_path&quot;&gt;root path&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71f0d391ca957b663b2fb89ac2b56a4d1147c830" translate="yes" xml:space="preserve">
          <source>Paths are implicitly convertible to and from &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;s, which makes it possible to use them with over files APIs, e.g. as an argument to &lt;code&gt;&lt;a href=&quot;../io/basic_ifstream/open&quot;&gt;std::ifstream::open&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9f0ad8924eee8effc5bbce4372099bdeb2cbc64" translate="yes" xml:space="preserve">
          <source>Pending member function call</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51cda9fe8367c873831b2031532f7adce59a1197" translate="yes" xml:space="preserve">
          <source>Performing a class member access that designates a non-static data member or a non-static member function on a glvalue that does not actually designate an object of the appropriate type - such as one obtained through a &lt;code&gt;reinterpret_cast&lt;/code&gt; - results in undefined behavior:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1f063c0cd01d1aaabfb88b1af15e0d0b6e911c8" translate="yes" xml:space="preserve">
          <source>Performs add and subtract operations involving a &lt;code&gt;time_point&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10d483c2205a4a757d085232bdad93f21f3b166f" translate="yes" xml:space="preserve">
          <source>Performs atomic addition. Atomically adds &lt;code&gt;arg&lt;/code&gt; to the value pointed to by &lt;code&gt;obj&lt;/code&gt; and returns the value &lt;code&gt;obj&lt;/code&gt; held previously. The operation is performed as if the following was executed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30b1dae446c5b7593254ad6366e3cf470d031678" translate="yes" xml:space="preserve">
          <source>Performs atomic subtraction. Atomically subtracts &lt;code&gt;arg&lt;/code&gt; from the value pointed to by &lt;code&gt;obj&lt;/code&gt; and returns the value &lt;code&gt;obj&lt;/code&gt; held previously. The operation is performed as if the following was executed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c52f7e90e59de80b9706a14d188069c7698f7d6b" translate="yes" xml:space="preserve">
          <source>Performs basic arithmetic operations between two durations or between a duration and a tick count.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="183d374bebe439e7db4be5cb95a45d69282a57dc" translate="yes" xml:space="preserve">
          <source>Performs binary AND, OR, XOR and NOT.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4f3500d257a3eb02de3f4efaee8bd335bde376c" translate="yes" xml:space="preserve">
          <source>Performs binary AND, OR, and XOR between two bitsets, &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7431f30f7f2b881484e6560e6c12827ac30edbb1" translate="yes" xml:space="preserve">
          <source>Performs binary shift left and binary shift right. Zeroes are shifted in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8916b3c66a5cb60067c0fd61d02517a0fb71dbe0" translate="yes" xml:space="preserve">
          <source>Performs comparison operations on &lt;code&gt;optional&lt;/code&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1c4ee1e6775de840bbf5cc899c2d9dd79702fe7" translate="yes" xml:space="preserve">
          <source>Performs compile-time assertion checking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24de277139e866d975315e41db4e0959f0e8333e" translate="yes" xml:space="preserve">
          <source>Performs compound assignments between two durations with the same period or between a duration and a tick count value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3363c88d9d999d25f7a5bb4ab9d7c71c3d168234" translate="yes" xml:space="preserve">
          <source>Performs correctly even if the copied character ranges overlap, i.e. &lt;code&gt;src&lt;/code&gt; is in [&lt;code&gt;dest&lt;/code&gt;, &lt;code&gt;dest + count&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ba5ff18809f625dffd211b201477809172431a" translate="yes" xml:space="preserve">
          <source>Performs multibyte to wide conversion, using the codecvt facet supplied at construction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74d714da572d85fb7e69a3edc8d391e566c083bd" translate="yes" xml:space="preserve">
          <source>Performs stream input and output operations on pseudo-random number distribution &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1145a97020306298786de6ec24b63e040c489199" translate="yes" xml:space="preserve">
          <source>Performs stream input or output on the path &lt;code&gt;p&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;../../io/manip/quoted&quot;&gt;std::quoted&lt;/a&gt;&lt;/code&gt; is used so that spaces do not cause truncation when later read by stream input operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b29cb631b9b97715e5de6f40a6f5200ff9f3e56" translate="yes" xml:space="preserve">
          <source>Performs stream output operation on error code &lt;code&gt;ec&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40064c133ea9e590f48b22c9dd2c24a2261fb25e" translate="yes" xml:space="preserve">
          <source>Performs type-safe access to the contained object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c066ce90c79eb22454994d74956cbecc73c7e86" translate="yes" xml:space="preserve">
          <source>Performs wide to multibyte conversion, using the &lt;code&gt;codecvt&lt;/code&gt; facet supplied at construction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d016004473e0e58d7682856755147e33256bb813" translate="yes" xml:space="preserve">
          <source>Permission denied</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff9458c2e9f1b3bd919c8ba7cde8f2a7dd4b60f3" translate="yes" xml:space="preserve">
          <source>Permissions may not necessarily be implemented as bits, but they are treated that way conceptually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2f24d32c584ac1cc0ae3793f8787ed50c35e122" translate="yes" xml:space="preserve">
          <source>Permissions will be completely replaced by the argument to &lt;code&gt;permissions()&lt;/code&gt; (default behavior)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cf092a603c8bf7fae552d6e038782dc15099c62" translate="yes" xml:space="preserve">
          <source>Permutable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d01f3bdcebf331d17384d9e5c22991b46b8a2544" translate="yes" xml:space="preserve">
          <source>Permutation operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e086fa3837f92effda2f189c65d872aaf2923d5" translate="yes" xml:space="preserve">
          <source>Phase 1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="330708acff87bb6907139071d5b459ded3e2d04a" translate="yes" xml:space="preserve">
          <source>Phase 2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="681032fd51c92a246ce412b39048b4ee77dca634" translate="yes" xml:space="preserve">
          <source>Phase 3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78d44d36dd0ef3c8fc841ed57f6811ad23d3444a" translate="yes" xml:space="preserve">
          <source>Phase 4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53f56e33fd048af3ea5f5836a9ebc4271647e4f2" translate="yes" xml:space="preserve">
          <source>Phase 5</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d95c8c6e048db1b43f633d810e6911867dafdf1a" translate="yes" xml:space="preserve">
          <source>Phase 6</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35a6e111a7e2e8fab957c5ce32c74294af54929f" translate="yes" xml:space="preserve">
          <source>Phase 7</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f992983641f78a8c013798273706bbac409bc020" translate="yes" xml:space="preserve">
          <source>Phase 8</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="156e180c3c9ca1d335879d8d7ee2a51f0db9cf21" translate="yes" xml:space="preserve">
          <source>Phase 9</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dec91782cf447c62f887433fae8bdce01c3fe91" translate="yes" xml:space="preserve">
          <source>Phases of translation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07e464f5998fa85728fa5e1a1bb5e63f3853d71d" translate="yes" xml:space="preserve">
          <source>Placement new</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60e6d239b2483569229a169894d525b0cecf1c39" translate="yes" xml:space="preserve">
          <source>Plot of binomial distribution with probability of success of each trial exactly 0.5, illustrating the relationship with the pascal triangle (the probabilities that none, 1, 2, 3, or all four of the 4 trials will be successful in this case are 1:4:6:4:1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1415dc522d7779649a6456c9f3b3c3feccd7270" translate="yes" xml:space="preserve">
          <source>Pm</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be0813d9bb5496f0d5533fee53776e91237df8de" translate="yes" xml:space="preserve">
          <source>Point of declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc5de071a8adc9ea913c6f9e5f0005a2d40cc14d" translate="yes" xml:space="preserve">
          <source>Pointer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="401cef63156459953ba9ecc39b378d92a1c4df85" translate="yes" xml:space="preserve">
          <source>Pointer categories</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e949a9338620645eea4d2a45d6573a07fea1a3c1" translate="yes" xml:space="preserve">
          <source>Pointer comparison operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dad7ddcfc4dd1845430d750452929c090145667" translate="yes" xml:space="preserve">
          <source>Pointer conversions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="220f1fd327711e96e3028b6709d46b742350f010" translate="yes" xml:space="preserve">
          <source>Pointer declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="507370d4d891ec50b13734e460fa7676dd112d1c" translate="yes" xml:space="preserve">
          <source>Pointer or reference to the contained value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="502927a57f75427d5d0348f3db625a5715c26063" translate="yes" xml:space="preserve">
          <source>Pointer to &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1efdcae629601a80fc4240acbeecbc12f77bb6f" translate="yes" xml:space="preserve">
          <source>Pointer to IMPLementation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="106def4670ec0827470f489e115609f14aba4d97" translate="yes" xml:space="preserve">
          <source>Pointer to a narrow null-terminated string identifying the C locale after applying the changes, if any, or null pointer on failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e051b01b4a3b676d8d937ba8eeb414966a415c5" translate="yes" xml:space="preserve">
          <source>Pointer to a null-terminated byte string corresponding to the &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; error code &lt;code&gt;errnum&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e79c93dcbbccb192a990f531993ec6357402c9d" translate="yes" xml:space="preserve">
          <source>Pointer to a null-terminated string with explanatory information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05eeb6466674025812c06718c64857711547c9fd" translate="yes" xml:space="preserve">
          <source>Pointer to a null-terminated string with explanatory information. The pointer is guaranteed to be valid at least until the exception object from which it is obtained is destroyed, or until a non-const member function on the exception object is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df62f1ab5417a7f0ff9ed3e2f220fb5e603072d1" translate="yes" xml:space="preserve">
          <source>Pointer to a static internal &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; object on success, or null pointer otherwise. The structure may be shared between &lt;code&gt;std::gmtime&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;std::localtime&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ctime&quot;&gt;std::ctime&lt;/a&gt;&lt;/code&gt; and may be overwritten on each invocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="741241b75fe5a199c0ab0dd397fe61cdd3f55460" translate="yes" xml:space="preserve">
          <source>Pointer to a static null-terminated character string holding the textual representation of date and time. The string may be shared between &lt;code&gt;std::asctime&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ctime&quot;&gt;std::ctime&lt;/a&gt;&lt;/code&gt;, and may be overwritten on each invocation of any of those functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a7b4726f6fc99f23b9e14868b5b1c846eaaf3b6" translate="yes" xml:space="preserve">
          <source>Pointer to a static null-terminated character string holding the textual representation of date and time. The string may be shared between &lt;code&gt;std::asctime&lt;/code&gt; and &lt;code&gt;std::ctime&lt;/code&gt;, and may be overwritten on each invocation of any of those functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17f25ceb95e972356eab5499d3f8f0ef814efd37" translate="yes" xml:space="preserve">
          <source>Pointer to data member of an accessible unambiguous non-virtual base class can be &lt;a href=&quot;implicit_cast&quot;&gt;implicitly converted&lt;/a&gt; to pointer to the same data member of a derived class:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae030652318897b4b4780b15cd8c3cb1c33c2ea6" translate="yes" xml:space="preserve">
          <source>Pointer to member function of a base class can be &lt;a href=&quot;implicit_cast&quot;&gt;implicitly converted&lt;/a&gt; to pointer to the same member function of a derived class:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d771ea67f2c2f9e746f144dec854fc3e63934c8" translate="yes" xml:space="preserve">
          <source>Pointer to object of any type can be &lt;a href=&quot;implicit_cast&quot;&gt;implicitly converted&lt;/a&gt; to pointer to &lt;code&gt;void&lt;/code&gt; (optionally &lt;a href=&quot;cv&quot;&gt;cv-qualified&lt;/a&gt;); the pointer value is unchanged. The reverse conversion, which requires &lt;a href=&quot;static_cast&quot;&gt;static_cast&lt;/a&gt; or &lt;a href=&quot;explicit_cast&quot;&gt;explicit cast&lt;/a&gt;, yields the original pointer value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ea44b54c22457c3498224bce9d6c3df4e5f7f8e" translate="yes" xml:space="preserve">
          <source>Pointer to the associated &lt;code&gt;std::strsteambuf&lt;/code&gt;, with constness cast away.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d72222d72010255cb609e9d2a6a19d72b7a6fd1" translate="yes" xml:space="preserve">
          <source>Pointer to the associated mutex or &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; if there was no associated mutex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fd0d9c2fb1a501a4d096e7e7c81a3fa102fb353" translate="yes" xml:space="preserve">
          <source>Pointer to the associated mutex or a null pointer if there is no associated mutex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb739690cf069bb92d8977a1b39e0650fd730f57" translate="yes" xml:space="preserve">
          <source>Pointer to the beginning of the buffer in the associated &lt;code&gt;std::strsteambuf&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; if no buffer is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3c9d2b8760066cd06193590fdb96c90b14ef460" translate="yes" xml:space="preserve">
          <source>Pointer to the beginning of the next token or &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; if there are no more tokens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bff190117aa548f41e1c46c1d9a87485d2bb232b" translate="yes" xml:space="preserve">
          <source>Pointer to the beginning of the next token or null pointer if there are no more tokens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5c9f035f457196c057c82d7390795936f5d502d" translate="yes" xml:space="preserve">
          <source>Pointer to the current &lt;code&gt;&lt;a href=&quot;lconv&quot;&gt;std::lconv&lt;/a&gt;&lt;/code&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e104cb5d7009c23ea923d1d221d79faf2d495206" translate="yes" xml:space="preserve">
          <source>Pointer to the first byte of a memory block suitably aligned and sufficient to hold an array of &lt;code&gt;n&lt;/code&gt; objects of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac77b36fb18de28499e5f8deffcf36f34c5eaf4b" translate="yes" xml:space="preserve">
          <source>Pointer to the first character in &lt;code&gt;[beg, end)&lt;/code&gt; that does not satisfy the mask, or &lt;code&gt;end&lt;/code&gt; if no such character was found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dae36e2355fa38c1c60579edf9133cfbb61b1b8" translate="yes" xml:space="preserve">
          <source>Pointer to the first character in &lt;code&gt;[beg, end)&lt;/code&gt; that doesn't satisfy the mask, or &lt;code&gt;end&lt;/code&gt; if no such character was found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f45940b623df5f14b6f86f6ea0be9eb450298c1" translate="yes" xml:space="preserve">
          <source>Pointer to the first character in &lt;code&gt;[beg, end)&lt;/code&gt; that satisfies the mask, or &lt;code&gt;end&lt;/code&gt; if no such character was found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc73e3cdae64ac7123b31602d1b60bce60462fac" translate="yes" xml:space="preserve">
          <source>Pointer to the first character in &lt;code&gt;dest&lt;/code&gt;, that is also in &lt;code&gt;breakset&lt;/code&gt;, or null pointer if no such character exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ebaf2a6a20f7b6c7586e0484fcb32649bd4a5f5" translate="yes" xml:space="preserve">
          <source>Pointer to the first character in &lt;code&gt;dest&lt;/code&gt;, that is also in &lt;code&gt;str&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; if no such character exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe9e35434f828d3a11ae11da261d3e71214675f" translate="yes" xml:space="preserve">
          <source>Pointer to the first character of the found substring in &lt;code&gt;dest&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; if no such substring is found. If &lt;code&gt;src&lt;/code&gt; points to an empty string, &lt;code&gt;dest&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21046068df7df1393a0867547b1fe1121d3fa933" translate="yes" xml:space="preserve">
          <source>Pointer to the first character of the found substring in &lt;code&gt;str&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; if no such character is found. If &lt;code&gt;target&lt;/code&gt; points to an empty string, &lt;code&gt;str&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d213221626fcc9a52e9468236f49e1462f46457" translate="yes" xml:space="preserve">
          <source>Pointer to the first element of an array of &lt;code&gt;argc + 1&lt;/code&gt; pointers, of which the last one is null and the previous ones, if any, point to &lt;a href=&quot;../string/multibyte&quot;&gt;null-terminated multibyte strings&lt;/a&gt; that represent the arguments passed to the program from the execution environment. If &lt;code&gt;argv[0]&lt;/code&gt; is not a null pointer (or, equivalently, if &lt;code&gt;argc&lt;/code&gt; &amp;gt; 0), it points to a string that represents the name used to invoke the program, or to an empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="405e5d4054459c9f481d32fb4025569549fc54c2" translate="yes" xml:space="preserve">
          <source>Pointer to the found character in &lt;code&gt;str&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; if no such character is found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8636ad44b682f9d39f8b49ddb2c33563cc416821" translate="yes" xml:space="preserve">
          <source>Pointer to the found character in &lt;code&gt;str&lt;/code&gt;, or a null pointer if no such character is found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c4f765e2320d24e28834fd57258bdf60d616f3d" translate="yes" xml:space="preserve">
          <source>Pointer to the found character in &lt;code&gt;str&lt;/code&gt;, or null pointer if no such character is found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eb2d90a2241298d211bf11c5eba0e1de683f4a8" translate="yes" xml:space="preserve">
          <source>Pointer to the found element or null pointer if the element has not been found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e8c4f8ecb8e493cc67d3b4ab6c8ee17ceb8a9d" translate="yes" xml:space="preserve">
          <source>Pointer to the location of the character, or &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; if no such character is found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21825601c681d15ea8978fbec39c4ef272eee665" translate="yes" xml:space="preserve">
          <source>Pointer to the location of the wide character, or a null pointer if no such character is found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f2d455ab9fda4d538794a886137505c44c33676" translate="yes" xml:space="preserve">
          <source>Pointer to the managed object or &lt;code&gt;nullptr&lt;/code&gt; if no object is owned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e417a6cc34557591c16fa3e0b6f964f03e642eb" translate="yes" xml:space="preserve">
          <source>Pointer to the managed object or &lt;code&gt;nullptr&lt;/code&gt; if there was no managed object, i.e. the value which would be returned by &lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; before the call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d669cee12e866ccbdc5f883c29bb6d1ae60a22d" translate="yes" xml:space="preserve">
          <source>Pointer to the newly-created object of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1007a66b7ed24271d8dae695470699ebb3d90623" translate="yes" xml:space="preserve">
          <source>Pointer to the underlying character storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb998ae306d857b07235d60d52ea2604f7849467" translate="yes" xml:space="preserve">
          <source>Pointer to the underlying element storage. For non-empty containers, the returned pointer compares equal to the address of the first element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43b7ef925b00e3b3c5b65aa2f44518ac04b67235" translate="yes" xml:space="preserve">
          <source>Pointer to the underlying raw file device.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6288fb6475a348852c9329d26259a5d291d0784a" translate="yes" xml:space="preserve">
          <source>Pointer to the underlying raw string device.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b4fc7eea0b85cedd66733caf9832ba1e1ccb12f" translate="yes" xml:space="preserve">
          <source>Pointer to the value stored in the pointed-to variant or null pointer on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6a38e0ced31a70dd505d085d69e083b8e83b46a" translate="yes" xml:space="preserve">
          <source>Pointer traits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d959136208a22120a2769984e2738fb200d3839c" translate="yes" xml:space="preserve">
          <source>Pointer-to-member</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b201b2e51331914c7c6d9d0a9f7efd62f7338a7" translate="yes" xml:space="preserve">
          <source>Pointer-to-member conversions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5b722fc5ad9faac57dfe90f51b7e6e51ad5a968" translate="yes" xml:space="preserve">
          <source>Pointers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e0102ec9f49bbfbd11df50c78b20aed752d493f" translate="yes" xml:space="preserve">
          <source>Pointers and references to an abstract class can be declared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b747222dad01bb7496378552c66f09a51682d7ce" translate="yes" xml:space="preserve">
          <source>Pointers may appear as operands to the built-in indirection operator (unary &lt;code&gt;operator*&lt;/code&gt;), which returns the &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt; identifying the pointed-to object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7324a9c3bb73a069fd86296c2d3c8eff5bf1e09e" translate="yes" xml:space="preserve">
          <source>Pointers of every type have a special value known as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eadf97520961ba4bce4e3272957d3d88b76ad695" translate="yes" xml:space="preserve">
          <source>Pointers returned by allocation functions such as &lt;code&gt;&lt;a href=&quot;../memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; are suitably aligned for any object, which means they are aligned at least as strictly as &lt;code&gt;std::max_align_t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89ce73c84ed030f8becc3c2f0d29d4123b20c1f9" translate="yes" xml:space="preserve">
          <source>Pointers to arrays of unknown bound cannot participate in &lt;a href=&quot;operator_arithmetic#Additive_operators&quot;&gt;pointer arithmetic&lt;/a&gt; and cannot be used on the left of the &lt;a href=&quot;operator_member_access#Built-in_subscript_operator&quot;&gt;subscript operator&lt;/a&gt;, but can be dereferenced. Pointers and references to arrays of unknown bound cannot be used in &lt;a href=&quot;function#Parameter_list&quot;&gt;function parameters&lt;/a&gt;(until C++14).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8997b3a58418ca35d08322acca258398b3551d8f" translate="yes" xml:space="preserve">
          <source>Pointers to class objects may also appear as the left-hand operands of the member access operators &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;operator-&amp;gt;&lt;/a&gt; and &lt;a href=&quot;operator_member_access#Built-in_pointer-to-member_access_operators&quot;&gt;operator-&amp;gt;*&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9610e9c523b3b30a4feffab978ca5f56b5bd2f7" translate="yes" xml:space="preserve">
          <source>Pointers to data members</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b82bc7e72d8d51c0188462e092d842450c228f3d" translate="yes" xml:space="preserve">
          <source>Pointers to functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd9440e65c03eec8586c193595d8efd5d1435bc4" translate="yes" xml:space="preserve">
          <source>Pointers to functions and pointers to member functions are not subject to &lt;code&gt;const_cast&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1c198366ed3f18c43f829eacc744c35cb919409" translate="yes" xml:space="preserve">
          <source>Pointers to member functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f14911c46acdfa1438c9db71d7719c27603ad66" translate="yes" xml:space="preserve">
          <source>Pointers to member functions may be used as callbacks or as function objects, often after applying &lt;code&gt;&lt;a href=&quot;../utility/functional/mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../utility/functional/bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="883144f9b49fc07a095e4294d84c214853439c3a" translate="yes" xml:space="preserve">
          <source>Pointers to members</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c422669e276a985567791cf3a6c9c3667be56c4" translate="yes" xml:space="preserve">
          <source>Pointers to non-throwing functions are &lt;a href=&quot;implicit_cast#Function_pointer_conversions&quot;&gt;implicitly convertible&lt;/a&gt;(since C++17)can be assigned(until C++17) to pointers to potentially-throwing functions, but not the other way around.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00b7228167bc78f725c1aa6170713523c3e87add" translate="yes" xml:space="preserve">
          <source>Pointers to objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef8f0afc3f73a99fbae90bff8831647b6c3782f4" translate="yes" xml:space="preserve">
          <source>Pointers to storage without an object that were cast to possibly cv-qualified &lt;code&gt;void*&lt;/code&gt; can only be &lt;a href=&quot;static_cast&quot;&gt;&lt;code&gt;static_cast&lt;/code&gt;&lt;/a&gt; to pointers to possibly cv-qualified &lt;code&gt;char&lt;/code&gt;, possibly cv-qualified &lt;code&gt;unsigned char&lt;/code&gt;, or possibly cv-qualified &lt;a href=&quot;../types/byte&quot;&gt;&lt;code&gt;std::byte&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2fba1862b8c837cec195a93f7f91b200ee05d3d" translate="yes" xml:space="preserve">
          <source>Pointers to transaction-safe functions and pointers to transaction-safe member functions are implicitly convertible to pointers to functions and pointers to member functions respectively. It is unspecified if the resulting pointer compares equal to the original.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee25cfd40679ceda92c701097a34e138aa84fe43" translate="yes" xml:space="preserve">
          <source>Pointers to void</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6073ce8abb343010670eb5f6310d7d502bbeac8c" translate="yes" xml:space="preserve">
          <source>Pointers to void are used to pass objects of unknown type, which is common in C interfaces: &lt;code&gt;&lt;a href=&quot;../memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;void*&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../algorithm/qsort&quot;&gt;std::qsort&lt;/a&gt;&lt;/code&gt; expects a user-provided callback that accepts two &lt;code&gt;const void*&lt;/code&gt; arguments. &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_create.html&quot;&gt;pthread_create&lt;/a&gt; expects a user-provided callback that accepts and returns &lt;code&gt;void*&lt;/code&gt;. In all cases, it is the caller's responsibility to cast the pointer to the correct type before use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d354f7564de295656ca72e55dc6f7cffeb82a2db" translate="yes" xml:space="preserve">
          <source>Poisson distributions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1f8e7db6309cddc0c5732e9a9ba58aaec05d533" translate="yes" xml:space="preserve">
          <source>Pole error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d042fd98c607a113e1de0917255c86503669b3" translate="yes" xml:space="preserve">
          <source>Pole error may occur if &lt;code&gt;arg&lt;/code&gt; is -1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b17e2690e7349805c990c7c5df9303f661668615" translate="yes" xml:space="preserve">
          <source>Pole error may occur if &lt;code&gt;arg&lt;/code&gt; is zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="122adbd5a657cad5a4eda6aa2024033436d6f138" translate="yes" xml:space="preserve">
          <source>Polymorphic allocators and memory resources</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a410bf5a1cec8abcb9037eb08c4da9a189234456" translate="yes" xml:space="preserve">
          <source>Polymorphic objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0507350e1ff0be2d293357a2de17b15f12a2e1a9" translate="yes" xml:space="preserve">
          <source>Populates and returns an object of type &lt;a href=&quot;space_info&quot;&gt;space_info&lt;/a&gt;, set from the members of the POSIX &lt;code&gt;struct statvfs&lt;/code&gt; as follows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1e9e23d9c9279a97defda521d3d276a672ebcc3" translate="yes" xml:space="preserve">
          <source>Position of the first character not equal to any of the characters in the given string, or &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; if no such character is found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8b3946c1066221ab59f803f680ae44b71d07b3c" translate="yes" xml:space="preserve">
          <source>Position of the first character of the found substring or &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; if no such substring is found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e9234e1e1ae2d680755936cbf92bb210b08eac5" translate="yes" xml:space="preserve">
          <source>Position of the first character of the found substring or &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; if no such substring is found. Note that this is an offset from the start of the string, not the end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82926c5ed89ca7ef042104a3dd17caf0de0bf0c9" translate="yes" xml:space="preserve">
          <source>Position of the first character of the found substring, or &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; if no such substring is found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58c2e322e5856c0cb8077b012578950a1a05d1a0" translate="yes" xml:space="preserve">
          <source>Position of the first occurrence of any character of the substring, or &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; if no such character is found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f89f214ac11a3751b70ccb18260b1080b9592c31" translate="yes" xml:space="preserve">
          <source>Position of the found character or &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; if no such character is found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c04e15937d1a51aa382dd521ed1eb52b92a5c774" translate="yes" xml:space="preserve">
          <source>Position of the last character not equal to any of the characters in the given string, or &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; if no such character is found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbb7430040ceecb3978fef4dd073148ef77466ad" translate="yes" xml:space="preserve">
          <source>Position of the last occurrence of any character of the substring, or &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; if no such character is found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86ba514122e17b32a635c456e65393d5e7dd0078" translate="yes" xml:space="preserve">
          <source>Positioning</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da9ebb96d6456e6e0214a89210dd04cd1b71df2c" translate="yes" xml:space="preserve">
          <source>Positive value if &lt;code&gt;lhs&lt;/code&gt; appears after &lt;code&gt;rhs&lt;/code&gt; in lexicographical order.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
