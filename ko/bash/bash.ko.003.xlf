<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="bash">
    <body>
      <group id="bash">
        <trans-unit id="e8e92a165d03aa131d9708cb7b1c7f471a2ab809" translate="yes" xml:space="preserve">
          <source>Re-execute the last keyboard macro defined, by making the characters in the macro appear as if typed at the keyboard.</source>
          <target state="translated">매크로의 문자를 키보드에서 입력 한 것처럼 보이게하여 정의 된 마지막 키보드 매크로를 다시 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="effb4933fa2e63251b68ec5d7c1e666532352f06" translate="yes" xml:space="preserve">
          <source>Read and execute commands from the &lt;var&gt;filename&lt;/var&gt; argument in the current shell context. If &lt;var&gt;filename&lt;/var&gt; does not contain a slash, the &lt;code&gt;PATH&lt;/code&gt; variable is used to find &lt;var&gt;filename&lt;/var&gt;. When Bash is not in &lt;small&gt;POSIX&lt;/small&gt; mode, the current directory is searched if &lt;var&gt;filename&lt;/var&gt; is not found in &lt;code&gt;$PATH&lt;/code&gt;. If any &lt;var&gt;arguments&lt;/var&gt; are supplied, they become the positional parameters when &lt;var&gt;filename&lt;/var&gt; is executed. Otherwise the positional parameters are unchanged. If the</source>
          <target state="translated">현재 쉘 컨텍스트 의 &lt;var&gt;filename&lt;/var&gt; 인수에서 명령을 읽고 실행하십시오 . 경우 &lt;var&gt;filename&lt;/var&gt; 슬래시를 포함하지 않는의 &lt;code&gt;PATH&lt;/code&gt; 의 변수를 찾는 데 사용되는 &lt;var&gt;filename&lt;/var&gt; . Bash가 &lt;small&gt;POSIX&lt;/small&gt; 모드 가 아닌 경우 &lt;code&gt;$PATH&lt;/code&gt; 에 &lt;var&gt;filename&lt;/var&gt; 이 없으면 현재 디렉토리가 검색됩니다 . 어떤 경우 &lt;var&gt;arguments&lt;/var&gt; 공급되고, 그들은 때 위치 매개 변수가 될 &lt;var&gt;filename&lt;/var&gt; 실행됩니다. 그렇지 않으면 위치 매개 변수가 변경되지 않습니다. 만약</target>
        </trans-unit>
        <trans-unit id="2eff02ab161dba3b794244a0b2a0bc9292837ec4" translate="yes" xml:space="preserve">
          <source>Read and execute commands from the first non-option argument &lt;var&gt;command_string&lt;/var&gt;, then exit. If there are arguments after the &lt;var&gt;command_string&lt;/var&gt;, the first argument is assigned to &lt;code&gt;$0&lt;/code&gt; and any remaining arguments are assigned to the positional parameters. The assignment to &lt;code&gt;$0&lt;/code&gt; sets the name of the shell, which is used in warning and error messages.</source>
          <target state="translated">첫 번째 비 옵션 인수 &lt;var&gt;command_string&lt;/var&gt; 에서 명령을 읽고 실행 한 다음 종료하십시오. &lt;var&gt;command_string&lt;/var&gt; 뒤에 인수가 있으면 첫 번째 인수는 &lt;code&gt;$0&lt;/code&gt; 지정되고 나머지 인수는 위치 매개 변수에 지정됩니다. &lt;code&gt;$0&lt;/code&gt; 할당하면 경고 및 오류 메시지에 사용되는 쉘 이름이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="064334f8adba9fdde25b49ab67f4bcb15b2119a9" translate="yes" xml:space="preserve">
          <source>Read commands but do not execute them. This may be used to check a script for syntax errors. This option is ignored by interactive shells.</source>
          <target state="translated">명령을 읽지 만 실행하지는 마십시오. 스크립트에서 구문 오류를 확인하는 데 사용될 수 있습니다. 이 옵션은 대화식 쉘에서 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9e73a2935bf6fb41cc58a84fc8cf51a963e7d201" translate="yes" xml:space="preserve">
          <source>Read enough characters to consume a multi-key sequence such as those defined for keys like Home and End. Such sequences begin with a Control Sequence Indicator (CSI), usually ESC-[. If this sequence is bound to &quot;\e[&quot;, keys producing such sequences will have no effect unless explicitly bound to a readline command, instead of inserting stray characters into the editing buffer. This is unbound by default, but usually bound to ESC-[.</source>
          <target state="translated">Home 및 End와 같은 키에 대해 정의 된 것과 같은 다중 키 시퀀스를 사용하기에 충분한 문자를 읽으십시오. 이러한 시퀀스는 제어 시퀀스 표시기 (CSI), 일반적으로 ESC- [로 시작합니다. 이 시퀀스가 ​​&quot;\ e [&quot;에 바인딩 된 경우 이러한 시퀀스를 생성하는 키는 편집 버퍼에 스트레이 문자를 삽입하는 대신 readline 명령에 명시 적으로 바인딩하지 않는 한 효과가 없습니다. 이것은 기본적으로 제한이 없지만 일반적으로 ESC- [에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="d34d335e5bc252cd69cecf72f39700bbaeb2dc41" translate="yes" xml:space="preserve">
          <source>Read in the contents of the &lt;var&gt;inputrc&lt;/var&gt; file, and incorporate any bindings or variable assignments found there.</source>
          <target state="translated">&lt;var&gt;inputrc&lt;/var&gt; 의 내용을 읽으십시오 파일 거기에있는 바인딩 또는 변수 지정을 통합하십시오.</target>
        </trans-unit>
        <trans-unit id="6081c7addda7dc2289b87dbc3e34e9c332c8561a" translate="yes" xml:space="preserve">
          <source>Read input from file descriptor &lt;var&gt;fd&lt;/var&gt;.</source>
          <target state="translated">파일 디스크립터 &lt;var&gt;fd&lt;/var&gt; 에서 입력 읽기 .</target>
        </trans-unit>
        <trans-unit id="53dd130d1ca5c7f7d16fcfff718d3381664c95a2" translate="yes" xml:space="preserve">
          <source>Read key bindings from &lt;var&gt;filename&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;filename&lt;/var&gt; 에서 키 바인딩 읽기 .</target>
        </trans-unit>
        <trans-unit id="677d8e8943ea53986371b81b8f47e29921cf16bd" translate="yes" xml:space="preserve">
          <source>Read lines from file descriptor &lt;var&gt;fd&lt;/var&gt; instead of the standard input.</source>
          <target state="translated">파일 디스크립터 &lt;var&gt;fd&lt;/var&gt; 에서 행을 읽습니다.표준 입력 대신 .</target>
        </trans-unit>
        <trans-unit id="af2bcc27cab2e2e77b3992f61038ebbb6898f003" translate="yes" xml:space="preserve">
          <source>Read lines from the standard input into the indexed array variable &lt;var&gt;array&lt;/var&gt;, or from file descriptor &lt;var&gt;fd&lt;/var&gt; if the</source>
          <target state="translated">표준 입력에서 색인 배열 변수 &lt;var&gt;array&lt;/var&gt; 또는 파일 설명자 &lt;var&gt;fd&lt;/var&gt; 에서 행을 읽습니다. 습니다.</target>
        </trans-unit>
        <trans-unit id="e2c476854ed7896dda238661313fba6c31a993cf" translate="yes" xml:space="preserve">
          <source>Read the history file and append its contents to the history list.</source>
          <target state="translated">히스토리 파일을 읽고 그 내용을 히스토리 목록에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="8cac7cbc61675da18b7360c1c19859cf8f5a1347" translate="yes" xml:space="preserve">
          <source>Readline (see &lt;a href=&quot;command-line-editing#Command-Line-Editing&quot;&gt;Command Line Editing&lt;/a&gt;) is used to obtain the line. Readline uses the current (or default, if line editing was not previously active) editing settings, but uses Readline&amp;rsquo;s default filename completion.</source>
          <target state="translated">리드 &lt;a href=&quot;command-line-editing#Command-Line-Editing&quot;&gt;라인&lt;/a&gt; ( 명령 행 편집 참조 )은 행을 얻는 데 사용됩니다. Readline은 현재 (또는 라인 편집이 이전에 활성화되지 않은 경우 기본값) 편집 설정을 사용하지만 Readline의 기본 파일 이름 완성을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d9261d989954c7b7046d8d5da35a3d9f72189977" translate="yes" xml:space="preserve">
          <source>Readline (see &lt;a href=&quot;command-line-editing#Command-Line-Editing&quot;&gt;Command Line Editing&lt;/a&gt;) is used to read commands from the user&amp;rsquo;s terminal.</source>
          <target state="translated">리드 &lt;a href=&quot;command-line-editing#Command-Line-Editing&quot;&gt;라인&lt;/a&gt; ( 명령 행 편집 참조 )은 사용자 터미널에서 명령을 읽는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5256cf04581ccfb8e3e4bad7821c27f7a316efeb" translate="yes" xml:space="preserve">
          <source>Readline Arguments</source>
          <target state="translated">리드 라인 인수</target>
        </trans-unit>
        <trans-unit id="5a0701dc1691b7daac3ceb46b2c6261b38565130" translate="yes" xml:space="preserve">
          <source>Readline Bare Essentials</source>
          <target state="translated">Readline Bare Essentials</target>
        </trans-unit>
        <trans-unit id="aa539124a0b26985cf24459007eb176e1472b9ce" translate="yes" xml:space="preserve">
          <source>Readline Init File</source>
          <target state="translated">Readline Init 파일</target>
        </trans-unit>
        <trans-unit id="8eeafb8ffd3a28e649f315c515c556710224b974" translate="yes" xml:space="preserve">
          <source>Readline Init File Syntax</source>
          <target state="translated">Readline Init 파일 구문</target>
        </trans-unit>
        <trans-unit id="2b4635fa3d81a11b04ec5366f497bc2cbc272a80" translate="yes" xml:space="preserve">
          <source>Readline Interaction</source>
          <target state="translated">리드 라인 상호 작용</target>
        </trans-unit>
        <trans-unit id="f45f73f8a5a1231bda11292c25f939251f409e63" translate="yes" xml:space="preserve">
          <source>Readline Killing Commands</source>
          <target state="translated">readline killing 명령</target>
        </trans-unit>
        <trans-unit id="1e74a61d5c8b53ac10a08e8ad8f34d3d84624c96" translate="yes" xml:space="preserve">
          <source>Readline Movement Commands</source>
          <target state="translated">리드 라인 이동 명령</target>
        </trans-unit>
        <trans-unit id="8fb986ce2f2603aea51cd70ffa80dc262027988b" translate="yes" xml:space="preserve">
          <source>Readline implements a facility similar in spirit to the conditional compilation features of the C preprocessor which allows key bindings and variable settings to be performed as the result of tests. There are four parser directives used.</source>
          <target state="translated">Readline은 테스트 결과 키 바인딩 및 변수 설정을 수행 할 수있는 C 프리 프로세서의 조건부 컴파일 기능과 유사한 기능을 구현합니다. 사용되는 4 개의 파서 지시문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4ea0f277c4a16a18a17b56da2260a8684cbe982" translate="yes" xml:space="preserve">
          <source>Readline key binding names (see &lt;a href=&quot;bindable-readline-commands#Bindable-Readline-Commands&quot;&gt;Bindable Readline Commands&lt;/a&gt;).</source>
          <target state="translated">리드 라인 키 바인딩 이름 (바인드 가능한 &lt;a href=&quot;bindable-readline-commands#Bindable-Readline-Commands&quot;&gt;리드 라인 명령&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="0bbd615dfe7e04b424bd2e094a3fc6fe1a8238ed" translate="yes" xml:space="preserve">
          <source>Readline provides commands for searching through the command history (see &lt;a href=&quot;bash-history-facilities#Bash-History-Facilities&quot;&gt;Bash History Facilities&lt;/a&gt;) for lines containing a specified string. There are two search modes: &lt;em&gt;incremental&lt;/em&gt; and &lt;em&gt;non-incremental&lt;/em&gt;.</source>
          <target state="translated">Readline은 지정된 문자열을 포함하는 행에 대한 명령 히스토리 ( &lt;a href=&quot;bash-history-facilities#Bash-History-Facilities&quot;&gt;Bash History Facilities&lt;/a&gt; 참조)를 검색하기위한 명령을 제공합니다 . &lt;em&gt;증분&lt;/em&gt; 및 &lt;em&gt;비 &lt;/em&gt;&lt;em&gt;증분의&lt;/em&gt; 두 가지 검색 모드 &lt;em&gt;가 있습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="de240eae3d73af3cde958b9f23e7a378c2e5841b" translate="yes" xml:space="preserve">
          <source>Readline remembers the last incremental search string. If two</source>
          <target state="translated">Readline은 마지막 증분 검색 문자열을 기억합니다. 두 경우</target>
        </trans-unit>
        <trans-unit id="07f0bfef392ca730e68c1908956fddd731cb50a7" translate="yes" xml:space="preserve">
          <source>Readline vi Mode</source>
          <target state="translated">리드 라인 vi 모드</target>
        </trans-unit>
        <trans-unit id="3752072696d882155f26b4d67d9627d3bdf33693" translate="yes" xml:space="preserve">
          <source>Readline, how to use</source>
          <target state="translated">readline, 사용법</target>
        </trans-unit>
        <trans-unit id="e0399196285befb6961f97dc8e05d687771fd0e2" translate="yes" xml:space="preserve">
          <source>Reads its input from a file (see &lt;a href=&quot;shell-scripts#Shell-Scripts&quot;&gt;Shell Scripts&lt;/a&gt;), from a string supplied as an argument to the</source>
          <target state="translated">파일에서 입력을 읽습니다 ( &lt;a href=&quot;shell-scripts#Shell-Scripts&quot;&gt;쉘 스크립트&lt;/a&gt; 참조). 대한 인수로 제공된 문자열에서 .</target>
        </trans-unit>
        <trans-unit id="4f8751f53633e52277195e714b19451446ec5bc1" translate="yes" xml:space="preserve">
          <source>Redirecting output using the &amp;lsquo;</source>
          <target state="translated">'를 사용하여 출력 리디렉션</target>
        </trans-unit>
        <trans-unit id="4714516211847184828940ea5aa0b0281a73b459" translate="yes" xml:space="preserve">
          <source>Redirection errors encountered by shell builtins will not cause the shell to exit.</source>
          <target state="translated">쉘 내장에서 발생하는 리디렉션 오류로 인해 쉘이 종료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a97abc05a1f8c3a95d64f1aa933a6ea087152d90" translate="yes" xml:space="preserve">
          <source>Redirection of input causes the file whose name results from the expansion of &lt;var&gt;word&lt;/var&gt; to be opened for reading on file descriptor &lt;code&gt;n&lt;/code&gt;, or the standard input (file descriptor 0) if &lt;code&gt;n&lt;/code&gt; is not specified.</source>
          <target state="translated">입력 경로 재 지정은 &lt;var&gt;word&lt;/var&gt; 의 확장으로 인해 이름이 지정된 파일이 파일 디스크립터 &lt;code&gt;n&lt;/code&gt; 에서 읽기 위해 열리 거나, &lt;code&gt;n&lt;/code&gt; 이 지정되지 않은 경우 표준 입력 (파일 디스크립터 0) 으로 열립니다 .</target>
        </trans-unit>
        <trans-unit id="1888da0c57abce25aae902bc7690d5fcfd42f9e1" translate="yes" xml:space="preserve">
          <source>Redirection of output causes the file whose name results from the expansion of &lt;var&gt;word&lt;/var&gt; to be opened for writing on file descriptor &lt;var&gt;n&lt;/var&gt;, or the standard output (file descriptor 1) if &lt;var&gt;n&lt;/var&gt; is not specified. If the file does not exist it is created; if it does exist it is truncated to zero size.</source>
          <target state="translated">출력 경로 재 지정은 &lt;var&gt;word&lt;/var&gt; 의 확장으로 인해 이름이 지정된 파일이 파일 디스크립터 &lt;var&gt;n&lt;/var&gt; 에 쓰기 위해 열리 거나 &lt;var&gt;n&lt;/var&gt; 이 지정되지 않은 경우 표준 출력 (파일 디스크립터 1) 이됩니다. 파일이 존재하지 않으면 파일이 작성됩니다. 존재하는 경우 크기가 0으로 잘립니다.</target>
        </trans-unit>
        <trans-unit id="70506ee7736a10f272144c7972d31203d933474f" translate="yes" xml:space="preserve">
          <source>Redirection of output in this fashion causes the file whose name results from the expansion of &lt;var&gt;word&lt;/var&gt; to be opened for appending on file descriptor &lt;var&gt;n&lt;/var&gt;, or the standard output (file descriptor 1) if &lt;var&gt;n&lt;/var&gt; is not specified. If the file does not exist it is created.</source>
          <target state="translated">이러한 방식으로 출력 리디렉션 이름이 검색 결과의 확장 파일에서 발생 &lt;var&gt;word&lt;/var&gt; 파일 디스크립터에 대한 부가 개방되는 &lt;var&gt;n&lt;/var&gt; 않거나 표준 출력 (파일 기술자 1) &lt;var&gt;n&lt;/var&gt; 이 지정되지 않은 . 파일이 존재하지 않으면 파일이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="b2cd63f3529b2ec870e10b83e39ae7da2d214f2b" translate="yes" xml:space="preserve">
          <source>Redirection operators do not perform filename expansion on the word in the redirection unless the shell is interactive.</source>
          <target state="translated">쉘이 대화식이 아닌 경우 리디렉션 연산자는 리디렉션의 단어에 대한 파일 이름 확장을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="28f5cd3fdb8f3c1b9abaeb65984763e80aa7f7da" translate="yes" xml:space="preserve">
          <source>Redirection operators do not perform word splitting on the word in the redirection.</source>
          <target state="translated">리디렉션 연산자는 리디렉션의 단어에 대해 단어 분할을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eeb9caefdf646c7a0ccceccdf48dd3a42d43224b" translate="yes" xml:space="preserve">
          <source>Redirections</source>
          <target state="translated">Redirections</target>
        </trans-unit>
        <trans-unit id="4aa44ee6aeb72be5ddb71e07f126819a3878fd98" translate="yes" xml:space="preserve">
          <source>Redirections are performed as described above (see &lt;a href=&quot;redirections#Redirections&quot;&gt;Redirections&lt;/a&gt;).</source>
          <target state="translated">리디렉션은 위에서 설명한대로 수행됩니다 ( &lt;a href=&quot;redirections#Redirections&quot;&gt;리디렉션&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c18100e01c567db13f752a8411fbfcc9aeebe693" translate="yes" xml:space="preserve">
          <source>Redirections using file descriptors greater than 9 should be used with care, as they may conflict with file descriptors the shell uses internally.</source>
          <target state="translated">셸이 내부적으로 사용하는 파일 설명자와 충돌 할 수 있으므로 9보다 큰 파일 설명자를 사용하는 리디렉션은주의해서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d16003ddb633decec2e4971aa00d7a9af5ba2448" translate="yes" xml:space="preserve">
          <source>Refer to command line &lt;var&gt;n&lt;/var&gt;.</source>
          <target state="translated">명령 행 &lt;var&gt;n&lt;/var&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d7eb48619843d8706724f441e19a5095c0cc1b6a" translate="yes" xml:space="preserve">
          <source>Refer to the command &lt;var&gt;n&lt;/var&gt; lines back.</source>
          <target state="translated">명령 &lt;var&gt;n&lt;/var&gt; 을 참조하십시오 줄 뒤로 .</target>
        </trans-unit>
        <trans-unit id="2aa3616c6da8583a1f02d0d9ba47b165a77f526d" translate="yes" xml:space="preserve">
          <source>Refer to the most recent command preceding the current position in the history list containing &lt;var&gt;string&lt;/var&gt;. The trailing &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;string&lt;/var&gt; 이 포함 된 히스토리 목록에서 현재 위치 앞에있는 가장 최근 명령을 참조하십시오 . 후행 '</target>
        </trans-unit>
        <trans-unit id="16208c720f2db06422fdf9c5951c63032cad11a1" translate="yes" xml:space="preserve">
          <source>Refer to the most recent command preceding the current position in the history list starting with &lt;var&gt;string&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;string&lt;/var&gt; 시작하는 히스토리 목록에서 현재 위치 앞에있는 가장 최근의 명령을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="046dacff2c15b17795af0e5d04466d7bf47e6cda" translate="yes" xml:space="preserve">
          <source>Refer to the previous command. This is a synonym for &amp;lsquo;</source>
          <target state="translated">이전 명령을 참조하십시오. 이것은 '의 동의어입니다</target>
        </trans-unit>
        <trans-unit id="0b1502e5f9fd5dcd73ddd5f922923085b3036407" translate="yes" xml:space="preserve">
          <source>Referencing an array variable without a subscript is equivalent to referencing with a subscript of 0. Any reference to a variable using a valid subscript is legal, and &lt;code&gt;bash&lt;/code&gt; will create an array if necessary.</source>
          <target state="translated">첨자없이 배열 변수를 참조하는 것은 첨자를 0으로 참조하는 것과 같습니다. 유효한 첨자를 사용하는 변수에 대한 참조는 합법적이며 &lt;code&gt;bash&lt;/code&gt; 는 필요한 경우 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5c932b92f7806ab6d803bf39c56e47e37a994413" translate="yes" xml:space="preserve">
          <source>Refresh the current line. By default, this is unbound.</source>
          <target state="translated">현재 줄을 새로 고칩니다. 기본적으로 이것은 바인딩되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="860c204be46c57a29c194bbb65ffdad59c1c581d" translate="yes" xml:space="preserve">
          <source>Remove a trailing &lt;var&gt;delim&lt;/var&gt; (default newline) from each line read.</source>
          <target state="translated">읽은 각 줄에서 후행 &lt;var&gt;delim&lt;/var&gt; (기본 줄 바꿈)을 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="a9478db503eeccf18f70a4a14b0996462ead0709" translate="yes" xml:space="preserve">
          <source>Remove a trailing pathname component, leaving only the head.</source>
          <target state="translated">머리 만 남기고 후행 경로 이름 구성 요소를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="fc955bb32973eef8359561e3d145c53e70c8c87b" translate="yes" xml:space="preserve">
          <source>Remove a trailing suffix of the form &amp;lsquo;</source>
          <target state="translated">'형식의 후행 접미사를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="1b70d0756c6980763db819cb7a052a3af2fadd8d" translate="yes" xml:space="preserve">
          <source>Remove all but the trailing suffix.</source>
          <target state="translated">후행 접미사를 제외한 모든 것을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="6da97f2000768b9dcaf83944cc4c3866a1548dfa" translate="yes" xml:space="preserve">
          <source>Remove all leading pathname components, leaving the tail.</source>
          <target state="translated">꼬리를 남기고 모든 선행 경로 이름 구성 요소를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="ee72df8453df43c975dacbf691189f1b70579bb2" translate="yes" xml:space="preserve">
          <source>Remove any current binding for &lt;var&gt;keyseq&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;keyseq&lt;/var&gt; 에 대한 현재 바인딩을 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="6cbf3b66c3e4d65dc70c82ec371087b8bb8e9f2f" translate="yes" xml:space="preserve">
          <source>Remove each &lt;var&gt;name&lt;/var&gt; from the list of aliases. If</source>
          <target state="translated">별명 목록에서 각 &lt;var&gt;name&lt;/var&gt; 을 제거하십시오 . 만약</target>
        </trans-unit>
        <trans-unit id="ee68761e723d44ae7a9fd53a286a1c2dce32369b" translate="yes" xml:space="preserve">
          <source>Remove each variable or function &lt;var&gt;name&lt;/var&gt;. If the</source>
          <target state="translated">각 변수 또는 함수 &lt;var&gt;name&lt;/var&gt; 제거하십시오 . 만약</target>
        </trans-unit>
        <trans-unit id="f0c8ed56a1ecd4f3ed5d202e9e22b0f8de3e53b0" translate="yes" xml:space="preserve">
          <source>Removes the &lt;var&gt;N&lt;/var&gt;th directory (counting from the left of the list printed by &lt;code&gt;dirs&lt;/code&gt;), starting with zero.</source>
          <target state="translated">0부터 시작 하여 &lt;var&gt;N&lt;/var&gt; 번째 디렉토리 ( &lt;code&gt;dirs&lt;/code&gt; 로 인쇄 된 목록의 왼쪽부터 계산)를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="7f50017f0d792110983ddddb0ef627fd6522f225" translate="yes" xml:space="preserve">
          <source>Removes the &lt;var&gt;N&lt;/var&gt;th directory (counting from the right of the list printed by &lt;code&gt;dirs&lt;/code&gt;), starting with zero.</source>
          <target state="translated">0부터 시작 하여 &lt;var&gt;N&lt;/var&gt; 번째 디렉토리 ( &lt;code&gt;dirs&lt;/code&gt; 로 인쇄 된 목록의 오른쪽부터 계산)를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="45d2c8acc1031935891dda3df6634f1f148128ed" translate="yes" xml:space="preserve">
          <source>Repeat the previous substitution.</source>
          <target state="translated">이전 대체를 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="2c54bc0da768d4c877c77485784187863c28ad3c" translate="yes" xml:space="preserve">
          <source>Reporting Bugs</source>
          <target state="translated">버그보고</target>
        </trans-unit>
        <trans-unit id="483cb6b1daaf74d912f74ee51792fd3c177c2af4" translate="yes" xml:space="preserve">
          <source>Reserved Word Index</source>
          <target state="translated">예약어 색인</target>
        </trans-unit>
        <trans-unit id="f87a1cebc20c29e56cc868e0e0eb834f0c5e41d1" translate="yes" xml:space="preserve">
          <source>Reserved words appearing in a context where reserved words are recognized do not undergo alias expansion.</source>
          <target state="translated">예약어가 인식되는 컨텍스트에 나타나는 예약어는 별칭 확장을 거치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4115b00edc8af2b3025a7285db77faa63020b194" translate="yes" xml:space="preserve">
          <source>Restricts the values of &lt;var&gt;optname&lt;/var&gt; to be those defined for the</source>
          <target state="translated">&lt;var&gt;optname&lt;/var&gt; 의 값을 다음에 대해 정의 된 값으로 제한합니다 .</target>
        </trans-unit>
        <trans-unit id="ac46b11f6eb237f8c3706bbff228fe76426f1b07" translate="yes" xml:space="preserve">
          <source>Resume each suspended job &lt;var&gt;jobspec&lt;/var&gt; in the background, as if it had been started with &amp;lsquo;</source>
          <target state="translated">'로 시작된 것처럼 백그라운드에서 일시 중지 된 작업 &lt;var&gt;jobspec&lt;/var&gt; 을 다시 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="3046b872f8310fc13f53f5bf211b7a32c2b5f997" translate="yes" xml:space="preserve">
          <source>Resume the job &lt;var&gt;jobspec&lt;/var&gt; in the foreground and make it the current job. If &lt;var&gt;jobspec&lt;/var&gt; is not supplied, the current job is used. The return status is that of the command placed into the foreground, or non-zero if run when job control is disabled or, when run with job control enabled, &lt;var&gt;jobspec&lt;/var&gt; does not specify a valid job or &lt;var&gt;jobspec&lt;/var&gt; specifies a job that was started without job control.</source>
          <target state="translated">포 그라운드에서 작업 &lt;var&gt;jobspec&lt;/var&gt; 을 재개하고 현재 작업으로 만드십시오. 경우 &lt;var&gt;jobspec&lt;/var&gt; 가 제공되지 않으면 현재 작업이 사용됩니다. 반환 상태는 전경에 배치 명령, 또는 비 제로의 실행이 작업 제어를 사용할 경우 또는, 작업 제어 활성화 실행할 때, 경우이다 &lt;var&gt;jobspec&lt;/var&gt; 이 유효한 작업 또는 지정하지 않는 &lt;var&gt;jobspec&lt;/var&gt; 지정 작업없이 시작한 일을 제어.</target>
        </trans-unit>
        <trans-unit id="676adec87b4051fd49b759b211042980592fa78e" translate="yes" xml:space="preserve">
          <source>Resume the next iteration of an enclosing &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;until&lt;/code&gt;, or &lt;code&gt;select&lt;/code&gt; loop. If &lt;var&gt;n&lt;/var&gt; is supplied, the execution of the &lt;var&gt;n&lt;/var&gt;th enclosing loop is resumed. &lt;var&gt;n&lt;/var&gt; must be greater than or equal to 1. The return status is zero unless &lt;var&gt;n&lt;/var&gt; is not greater than or equal to 1.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;until&lt;/code&gt; 또는 &lt;code&gt;select&lt;/code&gt; 루프 의 다음 반복을 재개하십시오 . 경우 &lt;var&gt;n&lt;/var&gt; 공급되면, 실행 &lt;var&gt;n&lt;/var&gt; 루프를 둘러싸 일이 재개된다. &lt;var&gt;n&lt;/var&gt; 은 1보다 크거나 같아야합니다. &lt;var&gt;n&lt;/var&gt; 이 1보다 크거나 같지 않으면 반환 상태는 0 입니다.</target>
        </trans-unit>
        <trans-unit id="3eef89ab48bc9bfe471b676f36b1e1244a457ab1" translate="yes" xml:space="preserve">
          <source>Return a status of 0 or 1 depending on the evaluation of the conditional expression &lt;var&gt;expression&lt;/var&gt;. Expressions are composed of the primaries described below in &lt;a href=&quot;bash-conditional-expressions#Bash-Conditional-Expressions&quot;&gt;Bash Conditional Expressions&lt;/a&gt;. Word splitting and filename expansion are not performed on the words between the &lt;code&gt;[[&lt;/code&gt; and &lt;code&gt;]]&lt;/code&gt;; tilde expansion, parameter and variable expansion, arithmetic expansion, command substitution, process substitution, and quote removal are performed. Conditional operators such as &amp;lsquo;</source>
          <target state="translated">조건식 &lt;var&gt;expression&lt;/var&gt; 의 평가에 따라 0 또는 1의 상태를 리턴합니다 . 표현식은 아래 &lt;a href=&quot;bash-conditional-expressions#Bash-Conditional-Expressions&quot;&gt;Bash 조건식에&lt;/a&gt; 설명 된 기본으로 구성 됩니다. &lt;code&gt;[[&lt;/code&gt; 와 &lt;code&gt;]]&lt;/code&gt; 사이의 단어에 대해서는 단어 분리 및 파일 이름 확장이 수행되지 않습니다 . 물결표 확장, 매개 변수 및 변수 확장, 산술 확장, 명령 대체, 프로세스 대체 및 따옴표 제거가 수행됩니다. '와 같은 조건부 연산자</target>
        </trans-unit>
        <trans-unit id="0aa88c2274c8dc26f3465f2bb4b15c16743bacc2" translate="yes" xml:space="preserve">
          <source>Returns the context of any active subroutine call (a shell function or a script executed with the &lt;code&gt;.&lt;/code&gt; or &lt;code&gt;source&lt;/code&gt; builtins).</source>
          <target state="translated">활성 서브 루틴 호출의 컨텍스트 (쉘 함수 또는 &lt;code&gt;.&lt;/code&gt; 또는 &lt;code&gt;source&lt;/code&gt; 내장으로 실행 된 스크립트)를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="be51d39042db6bcb9d633e2e6f84cbf5123bada0" translate="yes" xml:space="preserve">
          <source>Returns the value of &lt;var&gt;expr&lt;/var&gt;. This may be used to override the normal precedence of operators.</source>
          <target state="translated">&lt;var&gt;expr&lt;/var&gt; 값을 반환합니다 . 이것은 연산자의 일반적인 우선 순위를 대체하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="810cbc33ccdb39eb9cc8a3cff984488980adbc63" translate="yes" xml:space="preserve">
          <source>Returns the value of &lt;var&gt;expression&lt;/var&gt;. This may be used to override the normal precedence of operators.</source>
          <target state="translated">&lt;var&gt;expression&lt;/var&gt; 값을 반환합니다 . 이것은 연산자의 일반적인 우선 순위를 대체하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="410dea9704c23780fcca673e74ac4a6dd4731199" translate="yes" xml:space="preserve">
          <source>Rotate the kill-ring, and yank the new top. You can only do this if the prior command is</source>
          <target state="translated">킬링을 돌리고 새로운 상단을 잡아 당깁니다. 이전 명령이 다음과 같은 경우에만이 작업을 수행 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="58386e4dcc5ee51a6e6d3fbd5b21f1e20edcd769" translate="yes" xml:space="preserve">
          <source>Rotate the kill-ring, and yank the new top. You can only do this if the prior command is &lt;code&gt;yank&lt;/code&gt; or &lt;code&gt;yank-pop&lt;/code&gt;.</source>
          <target state="translated">킬링을 돌리고 새로운 상단을 잡아 당깁니다. 이전 명령이 &lt;code&gt;yank&lt;/code&gt; 또는 &lt;code&gt;yank-pop&lt;/code&gt; 인 경우에만이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9024935a09a4d4bd92973f39af6b051bf96e60bc" translate="yes" xml:space="preserve">
          <source>Run a shell builtin, passing it &lt;var&gt;args&lt;/var&gt;, and return its exit status. This is useful when defining a shell function with the same name as a shell builtin, retaining the functionality of the builtin within the function. The return status is non-zero if &lt;var&gt;shell-builtin&lt;/var&gt; is not a shell builtin command.</source>
          <target state="translated">쉘 내장을 실행하여 &lt;var&gt;args&lt;/var&gt; 를 전달 하고 종료 상태를 리턴하십시오. 이것은 쉘 내장과 동일한 이름으로 쉘 기능을 정의 할 때 유용하며, 기능 내에서 내장 기능을 유지합니다. 경우 반환 상태가 제로가 아닌 &lt;var&gt;shell-builtin&lt;/var&gt; 명령 내장 쉘이 아니다.</target>
        </trans-unit>
        <trans-unit id="cca65886555cc0be1beb30a279c4d1f19a91313e" translate="yes" xml:space="preserve">
          <source>Running &lt;code&gt;configure&lt;/code&gt; takes some time. While running, it prints messages telling which features it is checking for.</source>
          <target state="translated">&lt;code&gt;configure&lt;/code&gt; 를 실행하는 데 시간이 걸립니다. 실행하는 동안 검사중인 기능을 알려주는 메시지를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="5507775221e4c8b561f63d6cdbb40a52336b7272" translate="yes" xml:space="preserve">
          <source>Running commands in parallel.</source>
          <target state="translated">병렬로 명령을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="21434a0bb117aa8f39475e4ca02569853a7e063f" translate="yes" xml:space="preserve">
          <source>Runs &lt;var&gt;command&lt;/var&gt; with &lt;var&gt;arguments&lt;/var&gt; ignoring any shell function named &lt;var&gt;command&lt;/var&gt;. Only shell builtin commands or commands found by searching the &lt;code&gt;PATH&lt;/code&gt; are executed. If there is a shell function named &lt;code&gt;ls&lt;/code&gt;, running &amp;lsquo;</source>
          <target state="translated">실행은 &lt;var&gt;command&lt;/var&gt; 과 &lt;var&gt;arguments&lt;/var&gt; 라는 이름의 쉘 기능을 무시하는 &lt;var&gt;command&lt;/var&gt; . 쉘 내장 명령 또는 &lt;code&gt;PATH&lt;/code&gt; 를 검색하여 찾은 명령 만 실행됩니다. &lt;code&gt;ls&lt;/code&gt; 라는 쉘 함수가 있다면 '</target>
        </trans-unit>
        <trans-unit id="02aa629c8b16cd17a44f3a0efec2feed43937642" translate="yes" xml:space="preserve">
          <source>S</source>
          <target state="translated">S</target>
        </trans-unit>
        <trans-unit id="4b9079dcb3b5d1ef1e40482f9c01179073a53f17" translate="yes" xml:space="preserve">
          <source>SGML</source>
          <target state="translated">SGML</target>
        </trans-unit>
        <trans-unit id="a0d2ebea0767c4e8b2e83448e1dcf6419bde82a8" translate="yes" xml:space="preserve">
          <source>SIG</source>
          <target state="translated">SIG</target>
        </trans-unit>
        <trans-unit id="b3ab5acc6715019d9c52459321ac5f00d86ca1b8" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;-B&lt;/code&gt;.</source>
          <target state="translated">동일 &lt;code&gt;-B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5fd9f421ed9570ba368f14078658dbedd6dfc555" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;-C&lt;/code&gt;.</source>
          <target state="translated">동일 &lt;code&gt;-C&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0232a89a4b3851f4e0b354c82f58a4d95943a2d1" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;-E&lt;/code&gt;.</source>
          <target state="translated">동일 &lt;code&gt;-E&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2049c4889e3333cef7e7109245f43f1a1d802877" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;-H&lt;/code&gt;.</source>
          <target state="translated">동일 &lt;code&gt;-H&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="757972fa08fdc139d28c1a51467d4de06f96c00d" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;-P&lt;/code&gt;.</source>
          <target state="translated">동일 &lt;code&gt;-P&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dde9c7dd75e4ee090f37d665fd1fdca2661acf25" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;-T&lt;/code&gt;.</source>
          <target state="translated">동일 &lt;code&gt;-T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b315111db2826cf2356ada0ba7961e18a19c815e" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;-a&lt;/code&gt;.</source>
          <target state="translated">동일 &lt;code&gt;-a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01e560b23cc59f45a4682fa6b151603bb3d367f4" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;-b&lt;/code&gt;.</source>
          <target state="translated">동일 &lt;code&gt;-b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c37bed9a8ed5dab44b198cfc76e6ac656c62e77" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;-e&lt;/code&gt;.</source>
          <target state="translated">동일 &lt;code&gt;-e&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8c58540557e76ce8260d1c51f33f659860f0f13" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;-f&lt;/code&gt;.</source>
          <target state="translated">동일 &lt;code&gt;-f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26641d53e86431f10075c80818bd041945c4ec38" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;-h&lt;/code&gt;.</source>
          <target state="translated">동일 &lt;code&gt;-h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e52b3a85a93d869920f19ea207a67316d34852b" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;-k&lt;/code&gt;.</source>
          <target state="translated">동일 &lt;code&gt;-k&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="738edda884bb4b94a224ad7b453757b45d605c9e" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;-m&lt;/code&gt;.</source>
          <target state="translated">동일 &lt;code&gt;-m&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="761d3a02fbd3a29330aca112651cad7cf08002da" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;-n&lt;/code&gt;.</source>
          <target state="translated">동일 &lt;code&gt;-n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5aac532927e50a060e3662ee8a8977f49b71ae40" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;-p&lt;/code&gt;.</source>
          <target state="translated">동일 &lt;code&gt;-p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="863d84f86032a577dce55f1bab093d93252c582f" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;-t&lt;/code&gt;.</source>
          <target state="translated">동일 &lt;code&gt;-t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7850441383deedb684ab489f5083ae2fd2df590" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;-u&lt;/code&gt;.</source>
          <target state="translated">동일 &lt;code&gt;-u&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e11ac3a74a137de9fde7b45ae0edfd2e826c598" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;-v&lt;/code&gt;.</source>
          <target state="translated">동일 &lt;code&gt;-v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b477a6eadf53257d7fef0d736d8021f4c2176cf7" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;-x&lt;/code&gt;.</source>
          <target state="translated">동일 &lt;code&gt;-x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4548da94adeb1a7d6113196038156c166f3aae4" translate="yes" xml:space="preserve">
          <source>Sample Init File</source>
          <target state="translated">샘플 초기화 파일</target>
        </trans-unit>
        <trans-unit id="888c4957ecb057292736a385608f1df8e8b90bbb" translate="yes" xml:space="preserve">
          <source>Save the current directory on the top of the directory stack and then &lt;code&gt;cd&lt;/code&gt; to &lt;var&gt;dir&lt;/var&gt;. With no arguments, &lt;code&gt;pushd&lt;/code&gt; exchanges the top two directories and makes the new top the current directory.</source>
          <target state="translated">디렉토리 스택의 맨 위에 현재 디렉토리를 저장 한 다음 &lt;code&gt;cd&lt;/code&gt; to &lt;var&gt;dir&lt;/var&gt; . 인수없이 &lt;code&gt;pushd&lt;/code&gt; 는 최상위 두 디렉토리를 교환하고 새 디렉토리를 현재 디렉토리로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2966717ae5722f36e02c5c0e62baf8845b2f51e2" translate="yes" xml:space="preserve">
          <source>Saving and re-executing typed characters</source>
          <target state="translated">입력 한 문자 저장 및 재실행</target>
        </trans-unit>
        <trans-unit id="c3556c32b02a75d63ea3da2f5d625217db6941ba" translate="yes" xml:space="preserve">
          <source>Search backward starting at the current line and moving &amp;lsquo;up&amp;rsquo; through the history as necessary using a non-incremental search for a string supplied by the user. The search string may match anywhere in a history line.</source>
          <target state="translated">사용자가 제공 한 문자열에 대한 비 증분 검색을 사용하여 필요에 따라 현재 행에서 시작하여 히스토리를 통해 '위로'이동합니다. 검색 문자열은 히스토리 라인의 어느 곳에서나 일치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="117e75f683cb900c37e9ae76a96a2f8501b04e56" translate="yes" xml:space="preserve">
          <source>Search backward starting at the current line and moving &amp;lsquo;up&amp;rsquo; through the history as necessary. This is an incremental search.</source>
          <target state="translated">현재 행에서 시작하여 필요에 따라 히스토리를 통해 '위'로 이동하십시오. 이것은 증분 검색입니다.</target>
        </trans-unit>
        <trans-unit id="a9ce28fb2d502b0d327785c6f30402130753e8fa" translate="yes" xml:space="preserve">
          <source>Search backward through the history for the string of characters between the start of the current line and the point. The search string may match anywhere in a history line. This is a non-incremental search. By default, this command is unbound.</source>
          <target state="translated">현재 줄의 시작과 지점 사이의 문자열을 기록에서 뒤로 검색합니다. 검색 문자열은 히스토리 라인의 어느 곳에서나 일치 할 수 있습니다. 이것은 비 증분 검색입니다. 기본적으로이 명령은 바인드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9ec9d621fe65e16d2bef7f0415702a3637234cae" translate="yes" xml:space="preserve">
          <source>Search backward through the history for the string of characters between the start of the current line and the point. The search string must match at the beginning of a history line. This is a non-incremental search. By default, this command is unbound.</source>
          <target state="translated">현재 줄의 시작과 지점 사이의 문자열을 기록에서 뒤로 검색합니다. 검색 문자열은 히스토리 라인의 시작 부분에서 일치해야합니다. 이것은 비 증분 검색입니다. 기본적으로이 명령은 바인드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="60ebb12ddc40ec59ceaf9ecb8d6717f9bec0816d" translate="yes" xml:space="preserve">
          <source>Search forward starting at the current line and moving &amp;lsquo;down&amp;rsquo; through the history as necessary using a non-incremental search for a string supplied by the user. The search string may match anywhere in a history line.</source>
          <target state="translated">현재 행에서 시작하여 사용자가 제공 한 문자열에 대한 비 증분 검색을 사용하여 필요에 따라 히스토리를 통해 '아래로'이동합니다. 검색 문자열은 히스토리 라인의 어느 곳에서나 일치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f65d9472a1d1f7b69d8d9e5da57e1bda91bc29f" translate="yes" xml:space="preserve">
          <source>Search forward starting at the current line and moving &amp;lsquo;down&amp;rsquo; through the history as necessary. This is an incremental search.</source>
          <target state="translated">현재 라인에서 시작하여 필요에 따라 히스토리를 통해 '아래로'이동하십시오. 이것은 증분 검색입니다.</target>
        </trans-unit>
        <trans-unit id="b441d650d985dfd99c3d02b61c908328eee98df2" translate="yes" xml:space="preserve">
          <source>Search forward through the history for the string of characters between the start of the current line and the point. The search string may match anywhere in a history line. This is a non-incremental search. By default, this command is unbound.</source>
          <target state="translated">현재 줄의 시작과 지점 사이의 문자열을 기록에서 앞으로 검색합니다. 검색 문자열은 히스토리 라인의 어느 곳에서나 일치 할 수 있습니다. 이것은 비 증분 검색입니다. 기본적으로이 명령은 바인드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d1911c5b41c13e6230f95afe0d1b7280bbfa8cde" translate="yes" xml:space="preserve">
          <source>Search forward through the history for the string of characters between the start of the current line and the point. The search string must match at the beginning of a history line. This is a non-incremental search. By default, this command is unbound.</source>
          <target state="translated">현재 줄의 시작과 지점 사이의 문자열을 기록에서 앞으로 검색합니다. 검색 문자열은 히스토리 라인의 시작 부분에서 일치해야합니다. 이것은 비 증분 검색입니다. 기본적으로이 명령은 바인드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="98cc363c0119e35d1c8070755fc4d4c2387aad71" translate="yes" xml:space="preserve">
          <source>Searching</source>
          <target state="translated">Searching</target>
        </trans-unit>
        <trans-unit id="31ddec33c025f4ab1e3daab9a943baf4160525a6" translate="yes" xml:space="preserve">
          <source>Searching for Commands in the History</source>
          <target state="translated">히스토리에서 명령 검색</target>
        </trans-unit>
        <trans-unit id="49384eb7f7095924fbccb6a68c9a90f7b31ef5d7" translate="yes" xml:space="preserve">
          <source>Searching through previous lines.</source>
          <target state="translated">이전 줄을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="f2c6b564bd8119e16a3e573a6f9e7c6d1ac7820f" translate="yes" xml:space="preserve">
          <source>Section</source>
          <target state="translated">Section</target>
        </trans-unit>
        <trans-unit id="87cfa83506f3b68a4318453594eb5887e1ca439c" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;bash-builtins#Bash-Builtins&quot;&gt;Bash Builtins&lt;/a&gt;, for a full description of the &lt;code&gt;let&lt;/code&gt; builtin.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 내장에 대한 자세한 설명은 &lt;a href=&quot;bash-builtins#Bash-Builtins&quot;&gt;Bash Builtins를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b7bc74822663d5560f560421a6f191d05df95ff3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;compiling-for-multiple-architectures#Compiling-For-Multiple-Architectures&quot;&gt;Compiling For Multiple Architectures&lt;/a&gt; for more information about building in a directory separate from the source.</source>
          <target state="translated">소스와 다른 디렉토리에 빌드하는 방법에 대한 자세한 내용은 &lt;a href=&quot;compiling-for-multiple-architectures#Compiling-For-Multiple-Architectures&quot;&gt;다중 아키텍처 컴파일을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1b0306acf5ea03fde6185f177668bb4080eeed40" translate="yes" xml:space="preserve">
          <source>See the description of &lt;code&gt;shopt&lt;/code&gt; in &lt;a href=&quot;the-shopt-builtin#The-Shopt-Builtin&quot;&gt;The Shopt Builtin&lt;/a&gt;, for a description of the &lt;code&gt;nocaseglob&lt;/code&gt;, &lt;code&gt;nullglob&lt;/code&gt;, &lt;code&gt;failglob&lt;/code&gt;, and &lt;code&gt;dotglob&lt;/code&gt; options.</source>
          <target state="translated">의 설명을 참조하십시오 &lt;code&gt;shopt&lt;/code&gt; 내부 에서 &lt;a href=&quot;the-shopt-builtin#The-Shopt-Builtin&quot;&gt;shopt 내부 기본 제공된을&lt;/a&gt; 의 설명은, &lt;code&gt;nocaseglob&lt;/code&gt; , &lt;code&gt;nullglob&lt;/code&gt; , &lt;code&gt;failglob&lt;/code&gt; 및 &lt;code&gt;dotglob&lt;/code&gt; 의 옵션을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6142ee968e835bf0e6a4b4bc0768ee08a0e5da77" translate="yes" xml:space="preserve">
          <source>See the file</source>
          <target state="translated">파일보기</target>
        </trans-unit>
        <trans-unit id="213feed9a5539378750d4ed404b169c593d3075b" translate="yes" xml:space="preserve">
          <source>Send a signal specified by &lt;var&gt;sigspec&lt;/var&gt; or &lt;var&gt;signum&lt;/var&gt; to the process named by job specification &lt;var&gt;jobspec&lt;/var&gt; or process &lt;small&gt;ID&lt;/small&gt;&lt;var&gt;pid&lt;/var&gt;. &lt;var&gt;sigspec&lt;/var&gt; is either a case-insensitive signal name such as &lt;code&gt;SIGINT&lt;/code&gt; (with or without the &lt;code&gt;SIG&lt;/code&gt; prefix) or a signal number; &lt;var&gt;signum&lt;/var&gt; is a signal number. If &lt;var&gt;sigspec&lt;/var&gt; and &lt;var&gt;signum&lt;/var&gt; are not present, &lt;code&gt;SIGTERM&lt;/code&gt; is used. The</source>
          <target state="translated">&lt;var&gt;sigspec&lt;/var&gt; 또는 &lt;var&gt;signum&lt;/var&gt; 으로 지정된 신호 를 작업 스펙 &lt;var&gt;jobspec&lt;/var&gt; 또는 프로세스 &lt;small&gt;ID &lt;/small&gt; &lt;var&gt;pid&lt;/var&gt; 로 이름 지정된 프로세스로 전송 &lt;small&gt;하십시오&lt;/small&gt; . &lt;var&gt;sigspec&lt;/var&gt; 은 &lt;code&gt;SIGINT&lt;/code&gt; ( &lt;code&gt;SIG&lt;/code&gt; 접두사 가 있거나없는 ) 또는 신호 번호 와 같이 대소 문자를 구분하지 않는 신호 이름입니다 . &lt;var&gt;signum&lt;/var&gt; 는 신호 번호입니다. 경우 &lt;var&gt;sigspec&lt;/var&gt; 및 &lt;var&gt;signum&lt;/var&gt; 존재하지 않는, &lt;code&gt;SIGTERM&lt;/code&gt; 이 사용됩니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="d7ebc2337356f977470f1293ce806fbc27c820bd" translate="yes" xml:space="preserve">
          <source>Service names. May also be specified as</source>
          <target state="translated">서비스 이름. 다음과 같이 지정할 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="2a4a6177f02a6837f4d19a306e1ef899aba4374e" translate="yes" xml:space="preserve">
          <source>Set the default value of the &lt;var&gt;extglob&lt;/var&gt; shell option described above under &lt;a href=&quot;the-shopt-builtin#The-Shopt-Builtin&quot;&gt;The Shopt Builtin&lt;/a&gt; to be enabled.</source>
          <target state="translated">위에서 &lt;a href=&quot;the-shopt-builtin#The-Shopt-Builtin&quot;&gt;Shopt Builtin&lt;/a&gt; 아래에 설명 된 &lt;var&gt;extglob&lt;/var&gt; 쉘 옵션 의 기본값 을 사용으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="5953a2a30aa9094635153f1d20167ff20f8f4849" translate="yes" xml:space="preserve">
          <source>Set the default value of the &lt;var&gt;globasciiranges&lt;/var&gt; shell option described above under &lt;a href=&quot;the-shopt-builtin#The-Shopt-Builtin&quot;&gt;The Shopt Builtin&lt;/a&gt; to be enabled. This controls the behavior of character ranges when used in pattern matching bracket expressions.</source>
          <target state="translated">&lt;a href=&quot;the-shopt-builtin#The-Shopt-Builtin&quot;&gt;Shopt Builtin&lt;/a&gt; 아래에 설명 된 &lt;var&gt;globasciiranges&lt;/var&gt; 쉘 옵션 의 기본값 을 사용으로 설정하십시오. 패턴 일치 괄호 표현식에서 사용될 때 문자 범위의 동작을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="65764090fe51055dc669a69959887bb482289cf7" translate="yes" xml:space="preserve">
          <source>Set the mark to the point. If a numeric argument is supplied, the mark is set to that position.</source>
          <target state="translated">마크를 포인트로 설정하십시오. 숫자 인수가 제공되면 마크가 해당 위치로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="10e74191c8c7903aff2770d9578ed971047a5e5e" translate="yes" xml:space="preserve">
          <source>Set the maximum number of history entries saved in the history list. If set to zero, any existing history entries are deleted and no new entries are saved. If set to a value less than zero, the number of history entries is not limited. By default, the number of history entries is not limited. If an attempt is made to set &lt;var&gt;history-size&lt;/var&gt; to a non-numeric value, the maximum number of history entries will be set to 500.</source>
          <target state="translated">히스토리 목록에 저장된 최대 히스토리 항목 수를 설정하십시오. 0으로 설정하면 기존 기록 항목이 삭제되고 새 항목이 저장되지 않습니다. 0보다 작은 값으로 설정하면 히스토리 항목 수는 제한되지 않습니다. 기본적으로 히스토리 항목 수는 제한되지 않습니다. &lt;var&gt;history-size&lt;/var&gt; 를 숫자가 아닌 값 으로 설정하려고 하면 최대 히스토리 항목 수가 500으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="3e5975e0679cfa2d728932004cab0f48fefaa4f3" translate="yes" xml:space="preserve">
          <source>Set the number of exited child status values for the shell to remember. Bash will not allow this value to be decreased below a &lt;small&gt;POSIX&lt;/small&gt;-mandated minimum, and there is a maximum value (currently 8192) that this may not exceed. The minimum value is system-dependent.</source>
          <target state="translated">쉘이 기억할 종료 된 하위 상태 값 수를 설정하십시오. Bash는이 값을 &lt;small&gt;POSIX&lt;/small&gt; 필수 최소값 미만으로 줄일 수 없으며이를 초과 할 수없는 최대 값 (현재 8192)이 있습니다. 최소값은 시스템에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="360fc5e6fe6d2343da6d35c3bd114dd8d892db85" translate="yes" xml:space="preserve">
          <source>Set the option corresponding to &lt;var&gt;option-name&lt;/var&gt;:</source>
          <target state="translated">&lt;var&gt;option-name&lt;/var&gt; 에 해당하는 옵션을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="624a9ff66d2843464d7c52bb5534a1e3c2a4c038" translate="yes" xml:space="preserve">
          <source>Set the shell process&amp;rsquo;s file creation mask to &lt;var&gt;mode&lt;/var&gt;. If &lt;var&gt;mode&lt;/var&gt; begins with a digit, it is interpreted as an octal number; if not, it is interpreted as a symbolic mode mask similar to that accepted by the &lt;code&gt;chmod&lt;/code&gt; command. If &lt;var&gt;mode&lt;/var&gt; is omitted, the current value of the mask is printed. If the</source>
          <target state="translated">쉘 프로세스의 파일 작성 마스크를 &lt;var&gt;mode&lt;/var&gt; 로 설정하십시오 . 경우 &lt;var&gt;mode&lt;/var&gt; 숫자로 시작, 그것은 8 진수로 해석됩니다; 그렇지 않은 경우 &lt;code&gt;chmod&lt;/code&gt; 명령에서 허용하는 것과 유사한 기호 모드 마스크로 해석됩니다 . 경우 &lt;var&gt;mode&lt;/var&gt; 생략되고, 상기 마스크의 현재 값이 출력된다. 만약</target>
        </trans-unit>
        <trans-unit id="3bb143a50004ce599167ea86df628e6282520c74" translate="yes" xml:space="preserve">
          <source>Set to an integer value corresponding to the type of completion attempted that caused a completion function to be called: &lt;var&gt;TAB&lt;/var&gt;, for normal completion, &amp;lsquo;</source>
          <target state="translated">완료 함수를 호출 한 완료 유형에 해당하는 정수 값으로 설정하십시오. &lt;var&gt;TAB&lt;/var&gt; , 정상 완료의 경우 '</target>
        </trans-unit>
        <trans-unit id="c93bfbd7235bc543f9714580197e9efae6cd8c8b" translate="yes" xml:space="preserve">
          <source>Sets Readline&amp;rsquo;s idea of the current keymap for key binding commands. Built-in &lt;code&gt;keymap&lt;/code&gt; names are &lt;code&gt;emacs&lt;/code&gt;, &lt;code&gt;emacs-standard&lt;/code&gt;, &lt;code&gt;emacs-meta&lt;/code&gt;, &lt;code&gt;emacs-ctlx&lt;/code&gt;, &lt;code&gt;vi&lt;/code&gt;, &lt;code&gt;vi-move&lt;/code&gt;, &lt;code&gt;vi-command&lt;/code&gt;, and &lt;code&gt;vi-insert&lt;/code&gt;. &lt;code&gt;vi&lt;/code&gt; is equivalent to &lt;code&gt;vi-command&lt;/code&gt; (&lt;code&gt;vi-move&lt;/code&gt; is also a synonym); &lt;code&gt;emacs&lt;/code&gt; is equivalent to &lt;code&gt;emacs-standard&lt;/code&gt;. Applications may add additional names. The default value is &lt;code&gt;emacs&lt;/code&gt;. The value of the &lt;code&gt;editing-mode&lt;/code&gt; variable also affects the default keymap.</source>
          <target state="translated">키 바인딩 명령에 대한 현재 키맵에 대한 Readline의 아이디어를 설정합니다. 내장 된 &lt;code&gt;keymap&lt;/code&gt; 이름은 &lt;code&gt;emacs&lt;/code&gt; , &lt;code&gt;emacs-standard&lt;/code&gt; , &lt;code&gt;emacs-meta&lt;/code&gt; , &lt;code&gt;emacs-ctlx&lt;/code&gt; , &lt;code&gt;vi&lt;/code&gt; , &lt;code&gt;vi-move&lt;/code&gt; , &lt;code&gt;vi-command&lt;/code&gt; 및 &lt;code&gt;vi-insert&lt;/code&gt; 입니다. &lt;code&gt;vi&lt;/code&gt; 는 &lt;code&gt;vi-command&lt;/code&gt; 과 같습니다 ( &lt;code&gt;vi-move&lt;/code&gt; 는 동의어입니다). &lt;code&gt;emacs&lt;/code&gt; 는 &lt;code&gt;emacs-standard&lt;/code&gt; 와 같습니다 . 응용 프로그램은 추가 이름을 추가 할 수 있습니다. 기본값은 &lt;code&gt;emacs&lt;/code&gt; 입니다. &lt;code&gt;editing-mode&lt;/code&gt; 변수 의 값은 기본 키맵에도 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="3a49ccc2576232caa2dd95f8bdd38a2ca972c0d1" translate="yes" xml:space="preserve">
          <source>Setting or unsetting the values of the &lt;code&gt;SHELL&lt;/code&gt;, &lt;code&gt;PATH&lt;/code&gt;, &lt;code&gt;ENV&lt;/code&gt;, or &lt;code&gt;BASH_ENV&lt;/code&gt; variables.</source>
          <target state="translated">&lt;code&gt;SHELL&lt;/code&gt; , &lt;code&gt;PATH&lt;/code&gt; , &lt;code&gt;ENV&lt;/code&gt; 또는 &lt;code&gt;BASH_ENV&lt;/code&gt; 변수 의 값을 설정 또는 설정 해제합니다 .</target>
        </trans-unit>
        <trans-unit id="4feab33520e06128900166b2ea328a5a06d249a6" translate="yes" xml:space="preserve">
          <source>Several builtin commands are described in other chapters: builtin commands which provide the Bash interface to the job control facilities (see &lt;a href=&quot;job-control-builtins#Job-Control-Builtins&quot;&gt;Job Control Builtins&lt;/a&gt;), the directory stack (see &lt;a href=&quot;directory-stack-builtins#Directory-Stack-Builtins&quot;&gt;Directory Stack Builtins&lt;/a&gt;), the command history (see &lt;a href=&quot;bash-history-builtins#Bash-History-Builtins&quot;&gt;Bash History Builtins&lt;/a&gt;), and the programmable completion facilities (see &lt;a href=&quot;programmable-completion-builtins#Programmable-Completion-Builtins&quot;&gt;Programmable Completion Builtins&lt;/a&gt;).</source>
          <target state="translated">몇 가지 기본 제공 명령이 다른 장에 설명되어 있습니다. Bash 인터페이스를 작업 제어 기능 ( &lt;a href=&quot;job-control-builtins#Job-Control-Builtins&quot;&gt;작업 제어 내장&lt;/a&gt; 참조)에 제공하는 내장 명령 , 디렉토리 스택 ( &lt;a href=&quot;directory-stack-builtins#Directory-Stack-Builtins&quot;&gt;디렉토리 스택 내장&lt;/a&gt; 참조 ), 명령 히스토리 ( &lt;a href=&quot;bash-history-builtins#Bash-History-Builtins&quot;&gt;Bash History Builtins&lt;/a&gt; 참조 ) 및 프로그래밍 가능한 완성 기능 ( &lt;a href=&quot;programmable-completion-builtins#Programmable-Completion-Builtins&quot;&gt;Programmable Completion Builtins&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="7f10c9851eb8c4895108b5f89c564b7586ae422f" translate="yes" xml:space="preserve">
          <source>Several shell options settable with the &lt;code&gt;shopt&lt;/code&gt; builtin (see &lt;a href=&quot;the-shopt-builtin#The-Shopt-Builtin&quot;&gt;The Shopt Builtin&lt;/a&gt;) may be used to tailor the behavior of history expansion. If the &lt;code&gt;histverify&lt;/code&gt; shell option is enabled, and Readline is being used, history substitutions are not immediately passed to the shell parser. Instead, the expanded line is reloaded into the Readline editing buffer for further modification. If Readline is being used, and the &lt;code&gt;histreedit&lt;/code&gt; shell option is enabled, a failed history expansion will be reloaded into the Readline editing buffer for correction. The</source>
          <target state="translated">&lt;code&gt;shopt&lt;/code&gt; 내장 ( &lt;a href=&quot;the-shopt-builtin#The-Shopt-Builtin&quot;&gt;Shopt Builtin&lt;/a&gt; 참조)으로 설정 가능한 여러 쉘 옵션을 사용하여 히스토리 확장 동작을 조정할 수 있습니다. 는 IF &lt;code&gt;histverify&lt;/code&gt; 쉘 옵션이 활성화되고, Readline와를 사용하고, 역사 치환 즉시 쉘 파서에 전달되지 않습니다. 대신, 확장 된 라인은 추가 수정을 위해 Readline 편집 버퍼로 다시로드됩니다. Readline을 사용 &lt;code&gt;histreedit&lt;/code&gt; 쉘 옵션을 사용하면 실패한 히스토리 확장이 Readline 편집 버퍼에 다시로드되어 수정됩니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="e2d196d455c3fa9fd2a98bfab753b999179a09de" translate="yes" xml:space="preserve">
          <source>Sharing Defaults</source>
          <target state="translated">기본값 공유</target>
        </trans-unit>
        <trans-unit id="08ae113086eb582aa819b1629e571e4bac303741" translate="yes" xml:space="preserve">
          <source>Shell Arithmetic</source>
          <target state="translated">쉘 산술</target>
        </trans-unit>
        <trans-unit id="3224c1f995277e3c5557a97bdc2386d6237e62c4" translate="yes" xml:space="preserve">
          <source>Shell Builtin Commands</source>
          <target state="translated">쉘 내장 명령</target>
        </trans-unit>
        <trans-unit id="92d91c0e9c2e10b3624ca467a6cfec024511dd3e" translate="yes" xml:space="preserve">
          <source>Shell Commands</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbe15e4425ec82a0d5b21173bc91dfd0998f4cbd" translate="yes" xml:space="preserve">
          <source>Shell Expansions</source>
          <target state="translated">쉘 확장</target>
        </trans-unit>
        <trans-unit id="6ee3b593f4af7c77fae3f3aa378ffe91031089fd" translate="yes" xml:space="preserve">
          <source>Shell Functions</source>
          <target state="translated">쉘 기능</target>
        </trans-unit>
        <trans-unit id="69452b908f6302de0fb97a5d52497b5b2c1174e8" translate="yes" xml:space="preserve">
          <source>Shell Operation</source>
          <target state="translated">쉘 조작</target>
        </trans-unit>
        <trans-unit id="04402536b9c3739d5f7e3de00b61d4f8d562e461" translate="yes" xml:space="preserve">
          <source>Shell Parameter Expansion</source>
          <target state="translated">쉘 파라미터 확장</target>
        </trans-unit>
        <trans-unit id="3d7a4b323b9101d60b9ab2b3abaf3e64499891d9" translate="yes" xml:space="preserve">
          <source>Shell Parameters</source>
          <target state="translated">쉘 매개 변수</target>
        </trans-unit>
        <trans-unit id="aa50f0db9287be939f20144d6840f9c4545e702e" translate="yes" xml:space="preserve">
          <source>Shell Scripts</source>
          <target state="translated">쉘 스크립트</target>
        </trans-unit>
        <trans-unit id="26b79140b03b1947a70c3de9ec506cf7e3c5b954" translate="yes" xml:space="preserve">
          <source>Shell Syntax</source>
          <target state="translated">쉘 구문</target>
        </trans-unit>
        <trans-unit id="93162630dd0aff4c4e1939514e8d48e6a8c32d57" translate="yes" xml:space="preserve">
          <source>Shell Variables</source>
          <target state="translated">쉘 변수</target>
        </trans-unit>
        <trans-unit id="3476c67124b4d34d36fc37118f2caf069faea78a" translate="yes" xml:space="preserve">
          <source>Shell commands for conditional execution.</source>
          <target state="translated">조건부 실행을위한 셸 명령</target>
        </trans-unit>
        <trans-unit id="5b04a421bc8120876e6ffda28fbbc5b6264ff922" translate="yes" xml:space="preserve">
          <source>Shell commands for control flow.</source>
          <target state="translated">제어 흐름을위한 셸 명령</target>
        </trans-unit>
        <trans-unit id="ae94644c817dfa4f668bdcc23cbcfe14256b26f2" translate="yes" xml:space="preserve">
          <source>Shell commands for iterative action.</source>
          <target state="translated">반복 조치를위한 쉘 명령.</target>
        </trans-unit>
        <trans-unit id="20426ce9c81cc681dd8f42b3df3e80340a6bbcd9" translate="yes" xml:space="preserve">
          <source>Shell functions are a way to group commands for later execution using a single name for the group. They are executed just like a &quot;regular&quot; command. When the name of a shell function is used as a simple command name, the list of commands associated with that function name is executed. Shell functions are executed in the current shell context; no new process is created to interpret them.</source>
          <target state="translated">셸 함수는 그룹의 단일 이름을 사용하여 나중에 실행하기 위해 명령을 그룹화하는 방법입니다. &quot;일반&quot;명령처럼 실행됩니다. 쉘 함수 이름이 간단한 명령 이름으로 사용되면 해당 기능 이름과 관련된 명령 목록이 실행됩니다. 쉘 함수는 현재 쉘 컨텍스트에서 실행됩니다. 이를 해석하기 위해 새로운 프로세스가 작성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="27f0f8dc63fc5e0d5dfae93ddd52b0f79445f1fc" translate="yes" xml:space="preserve">
          <source>Shell functions may be exported to children via the environment using &lt;code&gt;export -f&lt;/code&gt; (see &lt;a href=&quot;shell-functions#Shell-Functions&quot;&gt;Shell Functions&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;export -f&lt;/code&gt; 를 사용하여 환경을 통해 셸 함수를 자식으로 내보낼 수 있습니다 ( &lt;a href=&quot;shell-functions#Shell-Functions&quot;&gt;Shell 함수&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7f1a591344ef38c27c0c7dc56e92d5db90adbf72" translate="yes" xml:space="preserve">
          <source>Shell option names as accepted by the &lt;code&gt;shopt&lt;/code&gt; builtin (see &lt;a href=&quot;bash-builtins#Bash-Builtins&quot;&gt;Bash Builtins&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;shopt&lt;/code&gt; 내장에서 허용하는 쉘 옵션 이름 ( &lt;a href=&quot;bash-builtins#Bash-Builtins&quot;&gt;Bash Builtins&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="0781bf8a9c56e345f59cfe1818bdacc0bf126a89" translate="yes" xml:space="preserve">
          <source>Shell reserved words. May also be specified as</source>
          <target state="translated">쉘 예약어. 다음과 같이 지정할 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="1d7ee07fe38a4b232bddcfd2444ad9556dc0b6c5" translate="yes" xml:space="preserve">
          <source>Shell variables are allowed as operands; parameter expansion is performed before the expression is evaluated. Within an expression, shell variables may also be referenced by name without using the parameter expansion syntax. A shell variable that is null or unset evaluates to 0 when referenced by name without using the parameter expansion syntax. The value of a variable is evaluated as an arithmetic expression when it is referenced, or when a variable which has been given the &lt;var&gt;integer&lt;/var&gt; attribute using &amp;lsquo;</source>
          <target state="translated">쉘 변수는 피연산자로 허용됩니다. 표현식이 평가되기 전에 매개 변수 확장이 수행됩니다. 표현식 내에서 매개 변수 확장 구문을 사용하지 않고 쉘 변수를 이름으로 참조 할 수도 있습니다. 널 또는 설정되지 않은 쉘 변수는 매개 변수 확장 구문을 사용하지 않고 이름으로 참조 될 때 0으로 평가됩니다. 변수의 값은 참조 될 때 또는 '를 사용하여 &lt;var&gt;integer&lt;/var&gt; 속성 이 제공된 변수 인 경우 산술 표현식으로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="8d4c0d2e6f6557fb9359dc74d3bd7455c33e50d6" translate="yes" xml:space="preserve">
          <source>Shells also provide a small set of built-in commands (&lt;em&gt;builtins&lt;/em&gt;) implementing functionality impossible or inconvenient to obtain via separate utilities. For example, &lt;code&gt;cd&lt;/code&gt;, &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt;, and &lt;code&gt;exec&lt;/code&gt; cannot be implemented outside of the shell because they directly manipulate the shell itself. The &lt;code&gt;history&lt;/code&gt;, &lt;code&gt;getopts&lt;/code&gt;, &lt;code&gt;kill&lt;/code&gt;, or &lt;code&gt;pwd&lt;/code&gt; builtins, among others, could be implemented in separate utilities, but they are more convenient to use as builtin commands. All of the shell builtins are described in subsequent sections.</source>
          <target state="translated">쉘은 또한 별도의 유틸리티를 통해 얻을 수 없거나 불편한 기능을 구현 하는 작은 내장 명령 세트 ( &lt;em&gt;builtins&lt;/em&gt; )를 제공합니다. 예를 들어 &lt;code&gt;cd&lt;/code&gt; , &lt;code&gt;break&lt;/code&gt; , &lt;code&gt;continue&lt;/code&gt; 및 &lt;code&gt;exec&lt;/code&gt; 는 셸 자체를 직접 조작하기 때문에 셸 외부에서 구현할 수 없습니다. &lt;code&gt;history&lt;/code&gt; , &lt;code&gt;getopts&lt;/code&gt; 가 , &lt;code&gt;kill&lt;/code&gt; , 또는 &lt;code&gt;pwd&lt;/code&gt; 내장 매크로는, 다른 사람의 사이에서, 별도의 유틸리티에서 구현 될 수 있지만, 그들은 명령 내장으로 사용하는 것이 더 편리합니다. 모든 쉘 내장은 다음 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="a433a104039438ebe5b989ec494978c370eccb94" translate="yes" xml:space="preserve">
          <source>Shells may be used interactively or non-interactively. In interactive mode, they accept input typed from the keyboard. When executing non-interactively, shells execute commands read from a file.</source>
          <target state="translated">쉘은 대화식 또는 비 대화식으로 사용될 수 있습니다. 대화식 모드에서는 키보드에서 입력 된 입력을 수락합니다. 비 대화식으로 실행할 때, 쉘은 파일에서 읽은 명령을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="9eb81eefcb76608f374cbcb2b07579d3e8b060c1" translate="yes" xml:space="preserve">
          <source>Shells offer features geared specifically for interactive use rather than to augment the programming language. These interactive features include job control, command line editing, command history and aliases. Each of these features is described in this manual.</source>
          <target state="translated">쉘은 프로그래밍 언어를 향상시키기보다는 대화식으로 사용하도록 특별히 설계된 기능을 제공합니다. 이러한 대화식 기능에는 작업 제어, 명령 행 편집, 명령 히스토리 및 별명이 포함됩니다. 이 기능들 각각은이 매뉴얼에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ac8dead1aeafe4ea6bf7399a5dda03f74e006e5" translate="yes" xml:space="preserve">
          <source>Shift the positional parameters to the left by &lt;var&gt;n&lt;/var&gt;. The positional parameters from &lt;var&gt;n&lt;/var&gt;+1 &amp;hellip; &lt;code&gt;$#&lt;/code&gt; are renamed to &lt;code&gt;$1&lt;/code&gt; &amp;hellip; &lt;code&gt;$#&lt;/code&gt;-&lt;var&gt;n&lt;/var&gt;. Parameters represented by the numbers &lt;code&gt;$#&lt;/code&gt; to &lt;code&gt;$#&lt;/code&gt;-&lt;var&gt;n&lt;/var&gt;+1 are unset. &lt;var&gt;n&lt;/var&gt; must be a non-negative number less than or equal to &lt;code&gt;$#&lt;/code&gt;. If &lt;var&gt;n&lt;/var&gt; is zero or greater than &lt;code&gt;$#&lt;/code&gt;, the positional parameters are not changed. If &lt;var&gt;n&lt;/var&gt; is not supplied, it is assumed to be 1. The return status is zero unless &lt;var&gt;n&lt;/var&gt; is greater than &lt;code&gt;$#&lt;/code&gt; or less than zero, non-zero otherwise.</source>
          <target state="translated">위치 매개 변수를 왼쪽으로 &lt;var&gt;n&lt;/var&gt; 만큼 이동합니다 . 에서 위치 매개 변수 &lt;var&gt;n&lt;/var&gt; +1은 ... &lt;code&gt;$#&lt;/code&gt; 로 이름이 변경 &lt;code&gt;$1&lt;/code&gt; ... &lt;code&gt;$#&lt;/code&gt; - &lt;var&gt;n&lt;/var&gt; 은 . 숫자로 표현 매개 변수 &lt;code&gt;$#&lt;/code&gt; 에 &lt;code&gt;$#&lt;/code&gt; - &lt;var&gt;n&lt;/var&gt; 은 +1이 해제됩니다. &lt;var&gt;n&lt;/var&gt; 은 &lt;code&gt;$#&lt;/code&gt; 보다 작거나 같은 음수가 아닌 숫자 여야합니다 . 경우 &lt;var&gt;n&lt;/var&gt; 이 제로 또는보다 큰 &lt;code&gt;$#&lt;/code&gt; , 위치 매개 변수를 변경하지 않는다. 경우 &lt;var&gt;n&lt;/var&gt; 을 제공하지, 반환 상태가 않는 제로 1로 가정 &lt;var&gt;n&lt;/var&gt; 보다 큰 &lt;code&gt;$#&lt;/code&gt; 0보다 작거나 그렇지 않으면 0이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c822bc3bd77ace807b4d33002b28e7e24a820c4c" translate="yes" xml:space="preserve">
          <source>Show version information for this instance of Bash on the standard output and exit successfully.</source>
          <target state="translated">이 Bash 인스턴스에 대한 버전 정보를 표준 출력에 표시하고 성공적으로 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="3b8326ef8c6a0e70f9e778423fc49c4cc27d863c" translate="yes" xml:space="preserve">
          <source>Signal names.</source>
          <target state="translated">신호 이름.</target>
        </trans-unit>
        <trans-unit id="f3efc39c953e54d1c56df25af3905e60709e6ca2" translate="yes" xml:space="preserve">
          <source>Signal the end of options, cause all remaining &lt;var&gt;arguments&lt;/var&gt; to be assigned to the positional parameters. The</source>
          <target state="translated">옵션의 끝을 알리면 나머지 모든 &lt;var&gt;arguments&lt;/var&gt; 가 위치 매개 변수에 지정됩니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="2346a18ea3002ff04eca3a130c7f40e65c56f0c9" translate="yes" xml:space="preserve">
          <source>Signals</source>
          <target state="translated">Signals</target>
        </trans-unit>
        <trans-unit id="2fc184e8aaf7e52a21146d63435b11b1c0addca6" translate="yes" xml:space="preserve">
          <source>Signals ignored upon entry to the shell cannot be trapped or reset. Trapped signals that are not being ignored are reset to their original values in a subshell or subshell environment when one is created.</source>
          <target state="translated">쉘에 진입 할 때 무시 된 신호는 트랩하거나 재설정 할 수 없습니다. 무시되지 않은 트랩 된 신호는 생성 될 때 서브 쉘 또는 서브 쉘 환경에서 원래 값으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="3bf57e58b2ac73a2a1b3bd6d9abbcbb52433e971" translate="yes" xml:space="preserve">
          <source>Silent mode. If input is coming from a terminal, characters are not echoed.</source>
          <target state="translated">무음 모드. 터미널에서 입력이 오는 경우 문자가 에코되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="827cbc5ae32bef8bfd180b3a0a6e2b45bc72ccfe" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;BASH_ENV&lt;/code&gt;; used when the shell is invoked in &lt;small&gt;POSIX&lt;/small&gt; Mode (see &lt;a href=&quot;bash-posix-mode#Bash-POSIX-Mode&quot;&gt;Bash POSIX Mode&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;BASH_ENV&lt;/code&gt; 와 유사 ; &lt;small&gt;POSIX&lt;/small&gt; 모드 에서 쉘이 호출 될 때 사용됩니다 ( &lt;a href=&quot;bash-posix-mode#Bash-POSIX-Mode&quot;&gt;Bash POSIX 모드&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7b21cfb73a5a6159cb20592afcfddec78da0d021" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;complete&lt;/code&gt;, but replaces the word to be completed with a single match from the list of possible completions. Repeated execution of &lt;code&gt;menu-complete&lt;/code&gt; steps through the list of possible completions, inserting each match in turn. At the end of the list of completions, the bell is rung (subject to the setting of &lt;code&gt;bell-style&lt;/code&gt;) and the original text is restored. An argument of &lt;var&gt;n&lt;/var&gt; moves &lt;var&gt;n&lt;/var&gt; positions forward in the list of matches; a negative argument may be used to move backward through the list. This command is intended to be bound to &lt;code&gt;TAB&lt;/code&gt;, but is unbound by default.</source>
          <target state="translated">유사합니다 &lt;code&gt;complete&lt;/code&gt; ,하지만 가능한 완성 목록에서 하나의 경기를 완료 할 수있는 단어를 대체합니다. 가능한 완료 목록을 통해 &lt;code&gt;menu-complete&lt;/code&gt; 단계를 반복 실행하여 각 일치 항목을 차례로 삽입합니다. 완료 목록이 끝나면 벨이 울리고 ( &lt;code&gt;bell-style&lt;/code&gt; 설정에 따라) 원본 텍스트가 복원됩니다. &lt;var&gt;n&lt;/var&gt; 의 인수는 일치 목록에서 &lt;var&gt;n&lt;/var&gt; 개의 위치를 앞으로 이동 시킵니다. 음수 인수를 사용하여 목록을 뒤로 이동할 수 있습니다. 이 명령은 &lt;code&gt;TAB&lt;/code&gt; 에 바인드되지만 기본적으로 바인드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3000175f72eb6a81cd8830b24f1026a1d89430a8" translate="yes" xml:space="preserve">
          <source>Similarly, the redirection operator</source>
          <target state="translated">마찬가지로 리디렉션 연산자</target>
        </trans-unit>
        <trans-unit id="82afd67b5cde7618bc8aa8b2d1f2d648d44ad831" translate="yes" xml:space="preserve">
          <source>Simple Command Expansion</source>
          <target state="translated">간단한 명령 확장</target>
        </trans-unit>
        <trans-unit id="9191ec290d05a1dc1998165d8ee7fc38f7fa3794" translate="yes" xml:space="preserve">
          <source>Simple Commands</source>
          <target state="translated">간단한 명령</target>
        </trans-unit>
        <trans-unit id="f9e6f993a188b102cab4f8eaef586eb697aced4b" translate="yes" xml:space="preserve">
          <source>Simple spelling correction for directory arguments to the &lt;code&gt;cd&lt;/code&gt; builtin is enabled by default (see the description of the &lt;code&gt;cdspell&lt;/code&gt; option to the &lt;code&gt;shopt&lt;/code&gt; builtin in &lt;a href=&quot;the-shopt-builtin#The-Shopt-Builtin&quot;&gt;The Shopt Builtin&lt;/a&gt;).</source>
          <target state="translated">받는 디렉토리 인수에 대한 간단한 맞춤법 교정 &lt;code&gt;cd&lt;/code&gt; 내장은 기본적으로 활성화되어 있습니다 (의 설명을 참조 &lt;code&gt;cdspell&lt;/code&gt; 를 받는 옵션 &lt;code&gt;shopt&lt;/code&gt; 내부에 있는 내장 &lt;a href=&quot;the-shopt-builtin#The-Shopt-Builtin&quot;&gt;shopt 내부 기본 제공된을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="672df289de5efa46029d357bc59ba26f8c054eac" translate="yes" xml:space="preserve">
          <source>Simply naming a job can be used to bring it into the foreground: &amp;lsquo;</source>
          <target state="translated">작업의 이름을 지정하면 포 그라운드로 가져올 수 있습니다. '</target>
        </trans-unit>
        <trans-unit id="70347df7e7ad67ef6a730c9cfd8ac885732b89de" translate="yes" xml:space="preserve">
          <source>Since Bash is a completely new implementation, it does not suffer from many of the limitations of the SVR4.2 shell. For instance:</source>
          <target state="translated">Bash는 완전히 새로운 구현이므로 SVR4.2 셸의 많은 제한이 없습니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="d5b5a1f4cdfaad0dc2b531593f9148d474721fa5" translate="yes" xml:space="preserve">
          <source>Since the coprocess is created as an asynchronous command, the &lt;code&gt;coproc&lt;/code&gt; command always returns success. The return status of a coprocess is the exit status of &lt;var&gt;command&lt;/var&gt;.</source>
          <target state="translated">coprocess는 비동기 명령으로 작성되므로 &lt;code&gt;coproc&lt;/code&gt; 명령은 항상 성공을 리턴합니다. 코 프로세스의 리턴 상태는 &lt;var&gt;command&lt;/var&gt; 의 종료 상태입니다 .</target>
        </trans-unit>
        <trans-unit id="2b154d88740e8eb4c99d20b375f601490b0c626f" translate="yes" xml:space="preserve">
          <source>Since we&amp;rsquo;d like Bash and Readline to take care of some of the other details for us, we use several other options to tell Bash and Readline what to do. The</source>
          <target state="translated">우리는 Bash와 Readline이 우리를 위해 다른 세부 사항을 처리하기를 원하기 때문에 Bash와 Readline에게 무엇을해야하는지 알리기 위해 몇 가지 다른 옵션을 사용합니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="4530f93a4bcf9d5873d117244d6fb7434ad7291d" translate="yes" xml:space="preserve">
          <source>Single Quotes</source>
          <target state="translated">작은 따옴표</target>
        </trans-unit>
        <trans-unit id="4f71fcec716bd20f7ae00979dd112873b9d2c16e" translate="yes" xml:space="preserve">
          <source>So, typically, your</source>
          <target state="translated">일반적으로</target>
        </trans-unit>
        <trans-unit id="cdd3761332b5cb397c5d157377cce62bdeeab667" translate="yes" xml:space="preserve">
          <source>Some Miscellaneous Commands</source>
          <target state="translated">기타 명령</target>
        </trans-unit>
        <trans-unit id="267255a4c12ab1f2e8f5254abfd3c1a6926bc3b9" translate="yes" xml:space="preserve">
          <source>Some definitions used in the rest of this manual.</source>
          <target state="translated">이 매뉴얼의 나머지 부분에서 사용 된 일부 정의.</target>
        </trans-unit>
        <trans-unit id="716642fefc8eff532c604a56df422b943cbe20a8" translate="yes" xml:space="preserve">
          <source>Some systems require unusual options for compilation or linking that the &lt;code&gt;configure&lt;/code&gt; script does not know about. You can give &lt;code&gt;configure&lt;/code&gt; initial values for variables by setting them in the environment. Using a Bourne-compatible shell, you can do that on the command line like this:</source>
          <target state="translated">일부 시스템에는 &lt;code&gt;configure&lt;/code&gt; 스크립트가 모르는 컴파일 또는 링크를위한 특별한 옵션이 필요합니다 . 환경에서 변수를 설정하여 변수의 초기 값을 &lt;code&gt;configure&lt;/code&gt; 할 수 있습니다 . Bourne 호환 쉘을 사용하면 다음과 같이 명령 행에서 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5610d9d90508da204eed446c5792bcb2dab655d" translate="yes" xml:space="preserve">
          <source>Some systems use the message catalog selected by the &lt;code&gt;LC_MESSAGES&lt;/code&gt; shell variable. Others create the name of the message catalog from the value of the &lt;code&gt;TEXTDOMAIN&lt;/code&gt; shell variable, possibly adding a suffix of &amp;lsquo;</source>
          <target state="translated">일부 시스템은 &lt;code&gt;LC_MESSAGES&lt;/code&gt; 쉘 변수로 선택된 메시지 카탈로그를 사용합니다 . 다른 사용자는 &lt;code&gt;TEXTDOMAIN&lt;/code&gt; 쉘 변수 의 값에서 메시지 카탈로그의 이름을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="4cc19e38022491397d40ea19863a5ab7f9c89402" translate="yes" xml:space="preserve">
          <source>Sometimes you may mistype a character, and not notice the error until you have typed several other characters. In that case, you can type</source>
          <target state="translated">경우에 따라 문자를 잘못 입력하고 다른 문자를 여러 번 입력 할 때까지 오류가 표시되지 않을 수 있습니다. 이 경우 다음을 입력 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6d8dca75d136f56c64bea5f7cdbda0676f01bd06" translate="yes" xml:space="preserve">
          <source>Special Builtins</source>
          <target state="translated">특별 내장</target>
        </trans-unit>
        <trans-unit id="9b2524eba27fcc9c2fa282010d1fdf784e31bdd6" translate="yes" xml:space="preserve">
          <source>Special Parameters</source>
          <target state="translated">특수 매개 변수</target>
        </trans-unit>
        <trans-unit id="b4284bcd219d11a9324304d2338552970cf17fdf" translate="yes" xml:space="preserve">
          <source>Special builtins are found before shell functions during command lookup.</source>
          <target state="translated">명령 조회 중에 쉘 기능 앞에 특수 내장이 있습니다.</target>
        </trans-unit>
        <trans-unit id="23821f0285b46591429dc6a8cfaba4bb07cad8c4" translate="yes" xml:space="preserve">
          <source>Specifies the duration Readline will wait for a character when reading an ambiguous key sequence (one that can form a complete key sequence using the input read so far, or can take additional input to complete a longer key sequence). If no input is received within the timeout, Readline will use the shorter but complete key sequence. Readline uses this value to determine whether or not input is available on the current input source (&lt;code&gt;rl_instream&lt;/code&gt; by default). The value is specified in milliseconds, so a value of 1000 means that Readline will wait one second for additional input. If this variable is set to a value less than or equal to zero, or to a non-numeric value, Readline will wait until another key is pressed to decide which key sequence to complete. The default value is &lt;code&gt;500&lt;/code&gt;.</source>
          <target state="translated">모호한 키 시퀀스를 읽을 때 Readline이 문자를 기다리는 기간 (지금까지 입력 읽기를 사용하여 완전한 키 시퀀스를 형성하거나 더 긴 키 시퀀스를 완료하기 위해 추가 입력을받을 수있는 기간)을 지정합니다. 제한 시간 내에 입력이 수신되지 않으면 Readline은 더 짧지 만 완전한 키 시퀀스를 사용합니다. Readline은이 값을 사용하여 현재 입력 소스에서 입력을 사용할 수 있는지 여부를 결정합니다 ( 기본적으로 &lt;code&gt;rl_instream&lt;/code&gt; ). 값은 밀리 초 단위로 지정되므로 값 1000은 Readline이 추가 입력을 1 초 동안 대기 함을 의미합니다. 이 변수가 0보다 작거나 같은 값 또는 숫자가 아닌 값으로 설정되면 Readline은 다른 키를 누를 때까지 기다렸다가 어떤 키 시퀀스를 완료할지 결정합니다. 기본값은 &lt;code&gt;500&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5222a18a9654c60789ddc0da9128a40060e89f2f" translate="yes" xml:space="preserve">
          <source>Specify how arguments to each &lt;var&gt;name&lt;/var&gt; should be completed. If the</source>
          <target state="translated">각 &lt;var&gt;name&lt;/var&gt; 대한 인수를 완료 하는 방법을 지정하십시오 . 만약</target>
        </trans-unit>
        <trans-unit id="c112a66ed12a55f4331917a809dd1767c302bf43" translate="yes" xml:space="preserve">
          <source>Specify the number of lines read between each call to &lt;var&gt;callback&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;callback&lt;/var&gt; 각 호출 사이에서 읽을 행 수를 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3fa6d950b2d286308afe1a5c75d3e0f8691903d" translate="yes" xml:space="preserve">
          <source>Specifying Numeric Arguments</source>
          <target state="translated">숫자 인수 지정</target>
        </trans-unit>
        <trans-unit id="0c0999f4fe5537ea61c523c861300c027d97cd8c" translate="yes" xml:space="preserve">
          <source>Specifying a filename containing a slash as an argument to the</source>
          <target state="translated">슬래시를 포함하는 파일 이름을</target>
        </trans-unit>
        <trans-unit id="f0c26cd33355ad993229d0f3ea4e5d2347edeb06" translate="yes" xml:space="preserve">
          <source>Specifying a filename containing a slash as an argument to the &lt;code&gt;.&lt;/code&gt; builtin command.</source>
          <target state="translated">슬래시가 포함 된 파일 이름을에 대한 인수로 지정합니다 &lt;code&gt;.&lt;/code&gt; 내장 명령.</target>
        </trans-unit>
        <trans-unit id="ca7980bd6666882557454c12c082d31e19357b8d" translate="yes" xml:space="preserve">
          <source>Specifying command names containing slashes.</source>
          <target state="translated">슬래시를 포함하는 명령 이름 지정</target>
        </trans-unit>
        <trans-unit id="b0614b1458f29370837997f3884f2f67eef6b3a2" translate="yes" xml:space="preserve">
          <source>Specifying numeric arguments, repeat counts.</source>
          <target state="translated">숫자 인수, 반복 횟수를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="4ee9cc1aa83bf2a8aaa7d549089eae697b9df2fe" translate="yes" xml:space="preserve">
          <source>Specifying the</source>
          <target state="translated">지정</target>
        </trans-unit>
        <trans-unit id="ccd867e0b6c84b172f4591340d20683e753516a5" translate="yes" xml:space="preserve">
          <source>Specifying the System Type</source>
          <target state="translated">시스템 유형 지정</target>
        </trans-unit>
        <trans-unit id="1ddd6c68b69ac72e74b7c6dd880d33038a2c0fd9" translate="yes" xml:space="preserve">
          <source>Specifying which words are of interest.</source>
          <target state="translated">관심있는 단어를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="4aeb0df67539cf0c420761a22a693cfaa12ff150" translate="yes" xml:space="preserve">
          <source>Start a history substitution, except when followed by a space, tab, the end of the line, &amp;lsquo;</source>
          <target state="translated">공백, 탭, 줄 끝, '을 제외한 기록 대체를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="567c88b266168afafca473cddd7cbcbcb2b323e9" translate="yes" xml:space="preserve">
          <source>Starting Bash with the</source>
          <target state="translated">와 Bash 시작</target>
        </trans-unit>
        <trans-unit id="e0c034a3aae5a5676d844a90819757e63cb5a133" translate="yes" xml:space="preserve">
          <source>Startup files are read and executed as described in &lt;a href=&quot;bash-startup-files#Bash-Startup-Files&quot;&gt;Bash Startup Files&lt;/a&gt;.</source>
          <target state="translated">시작 파일은 &lt;a href=&quot;bash-startup-files#Bash-Startup-Files&quot;&gt;Bash 시작 파일에&lt;/a&gt; 설명 된대로 읽고 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="febcaae4d914201f022c687fa2f0ffb7282a9b2a" translate="yes" xml:space="preserve">
          <source>State on the Title page the name of the publisher of the Modified Version, as the publisher.</source>
          <target state="translated">제목 페이지에 수정 된 버전의 게시자 이름을 게시자로 명시하십시오.</target>
        </trans-unit>
        <trans-unit id="dd125f9995ef5b864e6f1a55c7cdd9d9fb571ec7" translate="yes" xml:space="preserve">
          <source>Stop saving the characters typed into the current keyboard macro and save the definition.</source>
          <target state="translated">현재 키보드 매크로에 입력 한 문자 저장을 중지하고 정의를 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="3cbdce06be5b0cd21c7f995d5df1c2cade5fc4fb" translate="yes" xml:space="preserve">
          <source>Store the text displayed by the &lt;code&gt;help&lt;/code&gt; builtin as a single string for each help topic. This aids in translating the text to different languages. You may need to disable this if your compiler cannot handle very long string literals.</source>
          <target state="translated">&lt;code&gt;help&lt;/code&gt; 내장에 의해 표시되는 텍스트 를 각 도움말 주제에 대한 단일 문자열로 저장하십시오 . 텍스트를 다른 언어로 번역하는 데 도움이됩니다. 컴파일러가 매우 긴 문자열 리터럴을 처리 할 수없는 경우이를 비활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="26c2392593f2a16bfab44fa86459133e28013fc5" translate="yes" xml:space="preserve">
          <source>Storing the regular expression in a shell variable is often a useful way to avoid problems with quoting characters that are special to the shell. It is sometimes difficult to specify a regular expression literally without using quotes, or to keep track of the quoting used by regular expressions while paying attention to the shell&amp;rsquo;s quote removal. Using a shell variable to store the pattern decreases these problems. For example, the following is equivalent to the above:</source>
          <target state="translated">쉘 변수에 정규식을 저장하는 것은 쉘에 특수한 문자를 인용 할 때 문제를 피하는 데 유용한 방법입니다. 따옴표를 사용하지 않고 문자 그대로 정규식을 지정하거나 쉘의 따옴표 제거에주의하면서 정규식에 사용 된 인용을 추적하기가 어려운 경우가 있습니다. 쉘 변수를 사용하여 패턴을 저장하면 이러한 문제가 줄어 듭니다. 예를 들어 다음은 위와 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b155d5700514743f0c7f7adc1a55dc38f1ba951" translate="yes" xml:space="preserve">
          <source>Subshells spawned to execute command substitutions inherit the value of the</source>
          <target state="translated">명령 대체를 실행하기 위해 생성 된 서브 쉘은</target>
        </trans-unit>
        <trans-unit id="44b23aa091715e507faf023e66179c120e087995" translate="yes" xml:space="preserve">
          <source>Substitute &lt;var&gt;new&lt;/var&gt; for the first occurrence of &lt;var&gt;old&lt;/var&gt; in the event line. Any delimiter may be used in place of &amp;lsquo;</source>
          <target state="translated">대체 &lt;var&gt;new&lt;/var&gt; 의 첫 번째 항목에 대한 &lt;var&gt;old&lt;/var&gt; 이벤트 라인이다. '대신에 모든 구분 기호를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="386957cc04a842e19b9a0a5cfba54b5a1d529693" translate="yes" xml:space="preserve">
          <source>Substituting one command for another.</source>
          <target state="translated">한 명령을 다른 명령으로 대체.</target>
        </trans-unit>
        <trans-unit id="1a08ebe654dec2de8af5a599fe1989fd48d21d08" translate="yes" xml:space="preserve">
          <source>Substring expansion applied to an associative array produces undefined results.</source>
          <target state="translated">연관 배열에 적용된 부분 문자열 확장은 정의되지 않은 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="467037fc7b3205138457b59ccf0f9883df1d6797" translate="yes" xml:space="preserve">
          <source>Substring indexing is zero-based unless the positional parameters are used, in which case the indexing starts at 1 by default. If &lt;var&gt;offset&lt;/var&gt; is 0, and the positional parameters are used, &lt;code&gt;$@&lt;/code&gt; is prefixed to the list.</source>
          <target state="translated">위치 매개 변수가 사용되지 않는 경우 서브 스트링 인덱싱은 0부터 시작합니다.이 경우 인덱싱은 기본적으로 1에서 시작합니다. 경우 &lt;var&gt;offset&lt;/var&gt; 0이고, 위치 매개 변수가 사용되는, &lt;code&gt;$@&lt;/code&gt; 목록에 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="bf0fe992457159cf8f5e272dc0000e0e754ad9fd" translate="yes" xml:space="preserve">
          <source>Suppresses normal output; the return status indicates whether the &lt;var&gt;optname&lt;/var&gt; is set or unset. If multiple &lt;var&gt;optname&lt;/var&gt; arguments are given with</source>
          <target state="translated">정상 출력을 억제합니다. 반환 상태는 &lt;var&gt;optname&lt;/var&gt; 설정 여부를 나타냅니다 . 여러 개의 &lt;var&gt;optname&lt;/var&gt; 인수가 함께 제공된 경우</target>
        </trans-unit>
        <trans-unit id="a01a5b1fe63cc9365811d0495d3e40c1e73353ee" translate="yes" xml:space="preserve">
          <source>Suppresses the normal change of directory when removing directories from the stack, so that only the stack is manipulated.</source>
          <target state="translated">스택에서 디렉토리를 제거 할 때 일반적인 디렉토리 변경을 억제하여 스택 만 조작합니다.</target>
        </trans-unit>
        <trans-unit id="4b17845f92bf55cf0cf988dc6770d9124a4f4f4c" translate="yes" xml:space="preserve">
          <source>Suppresses the normal change of directory when rotating or adding directories to the stack, so that only the stack is manipulated.</source>
          <target state="translated">디렉토리를 회전하거나 스택에 추가 할 때 디렉토리 만 정상적으로 변경되도록 디렉토리의 정상적인 변경을 억제합니다.</target>
        </trans-unit>
        <trans-unit id="cc48ae9442f6fae353775185195b5b1399d37158" translate="yes" xml:space="preserve">
          <source>Suspend the execution of this shell until it receives a &lt;code&gt;SIGCONT&lt;/code&gt; signal. A login shell cannot be suspended; the</source>
          <target state="translated">&lt;code&gt;SIGCONT&lt;/code&gt; 신호를 받을 때까지이 쉘의 실행을 일시 중단하십시오 . 로그인 쉘은 일시 중단 될 수 없습니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="fbb7520495f229a0ffbc71b6ad31860cc65abc60" translate="yes" xml:space="preserve">
          <source>Swap the point with the mark. The current cursor position is set to the saved position, and the old cursor position is saved as the mark.</source>
          <target state="translated">포인트를 마크로 바꿉니다. 현재 커서 위치가 저장된 위치로 설정되고 이전 커서 위치가 마크로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="d3f544332c62b864dd7b6240ba9664e2648c85ba" translate="yes" xml:space="preserve">
          <source>Syntax for the commands in the inputrc file.</source>
          <target state="translated">inputrc 파일의 명령 구문</target>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="9f84fa056f6a083c24eaf10179bc22047265f97e" translate="yes" xml:space="preserve">
          <source>TERMINATION</source>
          <target state="translated">TERMINATION</target>
        </trans-unit>
        <trans-unit id="aff96a9ee1ea524018a0228411aa61f76f5c6271" translate="yes" xml:space="preserve">
          <source>TRANSLATION</source>
          <target state="translated">TRANSLATION</target>
        </trans-unit>
        <trans-unit id="6e9816a8e9d0388eecdb52866188c04e75e4b1b3" translate="yes" xml:space="preserve">
          <source>TYPE</source>
          <target state="translated">TYPE</target>
        </trans-unit>
        <trans-unit id="9730d4326a7b8a0d13c2be3b7fe29b80ad152bf6" translate="yes" xml:space="preserve">
          <source>Table of Contents</source>
          <target state="translated">목차</target>
        </trans-unit>
        <trans-unit id="81564e07e400e4e597011d16dfe88e3b2bf43edf" translate="yes" xml:space="preserve">
          <source>Table of builtins specific to Bash.</source>
          <target state="translated">배쉬 고유의 내장 테이블.</target>
        </trans-unit>
        <trans-unit id="471c1d8144fc9eaa397efa454b398a2d8db71f60" translate="yes" xml:space="preserve">
          <source>Tell Readline not to append a space (the default) to words completed at the end of the line.</source>
          <target state="translated">줄 끝에서 완성 된 단어에 공백 (기본값)을 추가하지 않도록 Readline에 지시하십시오.</target>
        </trans-unit>
        <trans-unit id="cc2ce318d138529c8dc713b497f699dedc67e45b" translate="yes" xml:space="preserve">
          <source>Tell Readline not to quote the completed words if they are filenames (quoting filenames is the default).</source>
          <target state="translated">완료된 단어가 파일 이름 인 경우 Readline에 인용하도록 지시하십시오 (파일 이름을 인용하는 것이 기본값 임).</target>
        </trans-unit>
        <trans-unit id="69dda040673a42d26dadb05f865e2228a44f6cd7" translate="yes" xml:space="preserve">
          <source>Tell Readline not to sort the list of possible completions alphabetically.</source>
          <target state="translated">가능한 완성 목록을 알파벳순으로 정렬하지 않도록 Readline에 지시하십시오.</target>
        </trans-unit>
        <trans-unit id="4869f39f9060d203e4cbaa1a98e21e6d178c0158" translate="yes" xml:space="preserve">
          <source>Tell Readline that the compspec generates filenames, so it can perform any filename-specific processing (like adding a slash to directory names, quoting special characters, or suppressing trailing spaces). This option is intended to be used with shell functions specified with</source>
          <target state="translated">readspec에 compspec이 파일 이름을 생성하므로 디렉토리 이름에 슬래시 추가, 특수 문자 인용 또는 후행 공백 억제와 같은 파일 이름 별 처리를 수행 할 수 있습니다. 이 옵션은 다음과 같이 지정된 쉘 기능과 함께 사용됩니다</target>
        </trans-unit>
        <trans-unit id="ed3f7375b4bf296ac0f885cd8b3c24c61985590e" translate="yes" xml:space="preserve">
          <source>Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, receipt of a copy of some or all of the same material does not give you any rights to use it.</source>
          <target state="translated">이 섹션에 따른 귀하의 권리가 종료 되어도이 라이센스에 따라 귀하로부터 사본 또는 권리를받은 당사자의 라이센스는 종료되지 않습니다. 귀하의 권리가 종료되어 영구적으로 복원되지 않은 경우, 동일한 자료의 일부 또는 전부의 사본을 수령한다고해서 사용할 권리가있는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c89eeee04d008f3b37ba348ef52a9ad774ba5589" translate="yes" xml:space="preserve">
          <source>That means values like &amp;lsquo;</source>
          <target state="translated">이는 '</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="1d9c6994ab0b74e2cfb2452521c9ea5fec830157" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;Cover Texts&amp;rdquo; are certain short passages of text that are listed, as Front-Cover Texts or Back-Cover Texts, in the notice that says that the Document is released under this License. A Front-Cover Text may be at most 5 words, and a Back-Cover Text may be at most 25 words.</source>
          <target state="translated">&quot;표지 텍스트&quot;는 문서가이 라이센스에 따라 릴리스되었다는 통지서에 앞 표지 텍스트 또는 뒤 표지 텍스트로 나열된 짧은 텍스트 구절입니다. 앞 표지 텍스트는 최대 5 워드 일 수 있으며 뒷 표지 텍스트는 최대 25 워드 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="789ab3cde0b22bbf74ff6949fbb28bfb30926e1b" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;Invariant Sections&amp;rdquo; are certain Secondary Sections whose titles are designated, as being those of Invariant Sections, in the notice that says that the Document is released under this License. If a section does not fit the above definition of Secondary then it is not allowed to be designated as Invariant. The Document may contain zero Invariant Sections. If the Document does not identify any Invariant Sections then there are none.</source>
          <target state="translated">&quot;불변 섹션&quot;은 문서가이 라이센스에 따라 릴리스되었다는 통지에 따라 제목이 불변 섹션의 타이틀로 지정된 특정 보조 섹션입니다. 섹션이 위의 Secondary 정의에 맞지 않으면 불변으로 지정할 수 없습니다. 문서에는 불변 섹션이 없을 수 있습니다. 문서가 불변 섹션을 식별하지 않으면 아무것도 없습니다.</target>
        </trans-unit>
        <trans-unit id="b79523892138877b2ffe5a4fab07cfff7aeeb1cd" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;Title Page&amp;rdquo; means, for a printed book, the title page itself, plus such following pages as are needed to hold, legibly, the material this License requires to appear in the title page. For works in formats which do not have any title page as such, &amp;ldquo;Title Page&amp;rdquo; means the text near the most prominent appearance of the work&amp;rsquo;s title, preceding the beginning of the body of the text.</source>
          <target state="translated">&quot;제목 페이지&quot;는 인쇄 된 책의 경우 제목 페이지 자체와이 라이센스가 제목 페이지에 나타나기 위해 필요한 자료를 읽을 수있는 다음 페이지를 의미합니다. 제목 페이지가없는 형식의 작품의 경우, &quot;제목 페이지&quot;는 본문의 시작 부분보다 먼저 작품 제목의 가장 두드러진 모양에 가까운 텍스트를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6d149b60373c6d3ba54f2d3a637bcfc7248c9681" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;publisher&amp;rdquo; means any person or entity that distributes copies of the Document to the public.</source>
          <target state="translated">&quot;출판인&quot;은 문서의 사본을 대중에게 배포하는 개인 또는 단체를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0ed4c9f9933dd9e4b8da3ca824145866c18f6a63" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;</source>
          <target state="translated">'</target>
        </trans-unit>
        <trans-unit id="c2151d1d870a888c352ddb39e67b95151e100a7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$'&amp;hellip;'&lt;/code&gt; quoting syntax, which expands ANSI-C backslash-escaped characters in the text between the single quotes, is supported (see &lt;a href=&quot;ansi_002dc-quoting#ANSI_002dC-Quoting&quot;&gt;ANSI-C Quoting&lt;/a&gt;).</source>
          <target state="translated">작은 따옴표 사이의 텍스트에서 ANSI-C 백 슬래시 이스케이프 문자를 확장 하는 &lt;code&gt;$'&amp;hellip;'&lt;/code&gt; 인용 구문이 지원됩니다 ( &lt;a href=&quot;ansi_002dc-quoting#ANSI_002dC-Quoting&quot;&gt;ANSI-C Quoting&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="318b7357e94166d63b447fdc8e5ff79e62ef635d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$if&lt;/code&gt; construct allows bindings to be made based on the editing mode, the terminal being used, or the application using Readline. The text of the test, after any comparison operator, extends to the end of the line; unless otherwise noted, no characters are required to isolate it.</source>
          <target state="translated">&lt;code&gt;$if&lt;/code&gt; 구조체가 바인딩이 편집 모드에 기초 할 수 있도록, 단말 존재 사용 또는 애플리케이션의 Readline을 사용. 비교 연산자 후에 테스트 텍스트는 줄 끝까지 확장됩니다. 달리 명시되지 않는 한, 분리 할 문자가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="81222032b8591add75e57b7abb203d434ebf5f2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; operators do not evaluate &lt;var&gt;expression2&lt;/var&gt; if the value of &lt;var&gt;expression1&lt;/var&gt; is sufficient to determine the return value of the entire conditional expression.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 와 &lt;code&gt;||&lt;/code&gt; 운영자는 평가하지 않는 &lt;var&gt;expression2&lt;/var&gt; 값 경우 &lt;var&gt;expression1&lt;/var&gt; 이 전체 조건식의 반환 값을 결정하기에 충분하다.</target>
        </trans-unit>
        <trans-unit id="bbe31a7cdd193d8b76017034e64a464eb64bc0cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;source&lt;/code&gt; builtins do not search the current directory for the filename argument if it is not found by searching &lt;code&gt;PATH&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.&lt;/code&gt; 그리고 &lt;code&gt;source&lt;/code&gt; 가 검색하여 찾을 수없는 경우 내장 명령은 파일 이름 인수에 대한 현재 디렉토리를 검색하지 않습니다 &lt;code&gt;PATH&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="1cafec1cb7fa980227fa5ce2bc2995563155c35c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;0&lt;/code&gt;th word. For many applications, this is the command word.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 번째 단어. 많은 응용 프로그램에서 이것은 명령 단어입니다.</target>
        </trans-unit>
        <trans-unit id="7e63fd7beea76870a573e92fdcb443a2069a1947" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FUNCNEST&lt;/code&gt; variable, if set to a numeric value greater than 0, defines a maximum function nesting level. Function invocations that exceed the limit cause the entire command to abort.</source>
          <target state="translated">&lt;code&gt;FUNCNEST&lt;/code&gt; 의 변수는 0보다 큰 수치로 설정이 최대 함수 중첩 레벨을 정의하는 경우. 한계를 초과하는 함수 호출로 인해 전체 명령이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="4a25b3adaefea8cd99b5dfd6064cb103a0833644" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GLOBIGNORE&lt;/code&gt; shell variable may be used to restrict the set of file names matching a pattern. If &lt;code&gt;GLOBIGNORE&lt;/code&gt; is set, each matching file name that also matches one of the patterns in &lt;code&gt;GLOBIGNORE&lt;/code&gt; is removed from the list of matches. If the &lt;code&gt;nocaseglob&lt;/code&gt; option is set, the matching against the patterns in &lt;code&gt;GLOBIGNORE&lt;/code&gt; is performed without regard to case. The filenames</source>
          <target state="translated">&lt;code&gt;GLOBIGNORE&lt;/code&gt; 의 쉘 변수 패턴 매칭 파일 이름의 세트를 제한 할 수있다. 경우 &lt;code&gt;GLOBIGNORE&lt;/code&gt; 가 설정되어,도에있는 패턴 중 하나와 일치하는 각 일치하는 파일 이름 &lt;code&gt;GLOBIGNORE&lt;/code&gt; 는 경기의 목록에서 제거됩니다. 경우] &lt;code&gt;nocaseglob&lt;/code&gt; 의 옵션이 설정되어있는 패턴에 대해 매칭 &lt;code&gt;GLOBIGNORE&lt;/code&gt; 이 경우에 관계없이 수행된다. 파일 이름</target>
        </trans-unit>
        <trans-unit id="ea0276161bd566005688dbc574abf6de66616b40" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IFS&lt;/code&gt; variable is used to split only the results of expansion, not all words (see &lt;a href=&quot;word-splitting#Word-Splitting&quot;&gt;Word Splitting&lt;/a&gt;). This closes a longstanding shell security hole.</source>
          <target state="translated">&lt;code&gt;IFS&lt;/code&gt; 의 변수가 확장의 결과, 모든 단어를 분할하는 데 사용된다 ( &lt;a href=&quot;word-splitting#Word-Splitting&quot;&gt;워드 분할을&lt;/a&gt; ). 이것은 오래된 쉘 보안 구멍을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="445d09811150616e91ec749f82226d5fb7f15c8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bg&lt;/code&gt; builtin uses the required format to describe each job placed in the background, which does not include an indication of whether the job is the current or previous job.</source>
          <target state="translated">&lt;code&gt;bg&lt;/code&gt; 편입 작업이 현재 또는 이전의 작업인지의 여부의 표시를 포함하지 않는 배경에서 각 작업 위치를 기술하기 위해 요구되는 포맷을 사용한다.</target>
        </trans-unit>
        <trans-unit id="adb7b384d494115dd83fc455d6726d7c50d65070" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&amp;nbsp;-V&lt;/code&gt; command lists the current Readline variable names and values. See &lt;a href=&quot;bash-builtins#Bash-Builtins&quot;&gt;Bash Builtins&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;bind&amp;nbsp;-V&lt;/code&gt; 명령 목록 현재의 Readline 변수의 이름과 값을. &lt;a href=&quot;bash-builtins#Bash-Builtins&quot;&gt;Bash Builtins&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="805be08c5acd292bb95deafad8c931b8091ba6d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&amp;nbsp;-p&lt;/code&gt; command displays Readline function names and bindings in a format that can put directly into an initialization file. See &lt;a href=&quot;bash-builtins#Bash-Builtins&quot;&gt;Bash Builtins&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;bind&amp;nbsp;-p&lt;/code&gt; 명령은 초기화 파일에 직접 넣을 수있는 형식으로 Readline와 함수 이름과 바인딩. &lt;a href=&quot;bash-builtins#Bash-Builtins&quot;&gt;Bash Builtins&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b4ebc4b6853938afb3e6f9a3d3d933c606fc6d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; builtins (see &lt;a href=&quot;bourne-shell-builtins#Bourne-Shell-Builtins&quot;&gt;Bourne Shell Builtins&lt;/a&gt;) may be used to control loop execution.</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 과 &lt;code&gt;continue&lt;/code&gt; 내장 명령은 (참조 &lt;a href=&quot;bourne-shell-builtins#Bourne-Shell-Builtins&quot;&gt;Bourne 쉘 내장 명령을&lt;/a&gt; ) 제어 루프 실행에 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="2d150bd895a2175703486fddb6477b44bc9cd086" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;command&lt;/code&gt; builtin allows selective disabling of functions when command lookup is performed (see &lt;a href=&quot;bash-builtins#Bash-Builtins&quot;&gt;Bash Builtins&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;command&lt;/code&gt; 내장 명령 룩업을 행하는 기능을 선택적으로 디스 에이블 (참조있게 &lt;a href=&quot;bash-builtins#Bash-Builtins&quot;&gt;배시를 내장 매크로&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fec54dd1e28cd56804463fd7a5d7e0f53a262a35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;command&lt;/code&gt; builtin does not prevent builtins that take assignment statements as arguments from expanding them as assignment statements; when not in &lt;small&gt;POSIX&lt;/small&gt; mode, assignment builtins lose their assignment statement expansion properties when preceded by &lt;code&gt;command&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;command&lt;/code&gt; 내장은 할당 문로 확대에서 인수로 할당 문을 내장 명령을 방지하지 않는다; &lt;small&gt;POSIX&lt;/small&gt; 모드 가 아닌 경우 , 할당 내장은 &lt;code&gt;command&lt;/code&gt; 앞에있을 때 할당 명령문 확장 특성을 잃습니다 .</target>
        </trans-unit>
        <trans-unit id="4b7d033377a39f9c87a2d7ec0ee7e65df00c5412" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;configure&lt;/code&gt; shell script attempts to guess correct values for various system-dependent variables used during compilation. It uses those values to create a</source>
          <target state="translated">&lt;code&gt;configure&lt;/code&gt; 쉘 스크립트 시도를 컴파일하는 동안 사용되는 다양한 시스템 종속 변수에 대한 올바른 값을 추측합니다. 이 값을 사용하여</target>
        </trans-unit>
        <trans-unit id="b00f66e494fabde35dd4a8862e424396e9794a64" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;declare&lt;/code&gt;, &lt;code&gt;local&lt;/code&gt;, and &lt;code&gt;readonly&lt;/code&gt; builtins each accept a</source>
          <target state="translated">&lt;code&gt;declare&lt;/code&gt; , &lt;code&gt;local&lt;/code&gt; 및 &lt;code&gt;readonly&lt;/code&gt; 각각을 받아 내장 명령</target>
        </trans-unit>
        <trans-unit id="b2680ef721f951f99511fde4337291e0355e443f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;disown&lt;/code&gt; builtin can remove a job from the internal shell job table (see &lt;a href=&quot;job-control-builtins#Job-Control-Builtins&quot;&gt;Job Control Builtins&lt;/a&gt;) or suppress the sending of &lt;code&gt;SIGHUP&lt;/code&gt; to a job when the shell exits as the result of a &lt;code&gt;SIGHUP&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;disown&lt;/code&gt; 내장 내부 쉘 작업 테이블에서 작업을 제거 할 수 있습니다 ( &lt;a href=&quot;job-control-builtins#Job-Control-Builtins&quot;&gt;작업 제어 내장 명령을&lt;/a&gt; ) 또는 보내는 억제 &lt;code&gt;SIGHUP&lt;/code&gt; 을 작업에 때의 결과로 쉘 종료 &lt;code&gt;SIGHUP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f23967f9d07b09ced14380eb4fe57d7706bf541" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;editing-mode&lt;/code&gt; variable controls which default set of key bindings is used. By default, Readline starts up in Emacs editing mode, where the keystrokes are most similar to Emacs. This variable can be set to either &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;editing-mode&lt;/code&gt; 키 바인딩 세트 기본 변수 컨트롤이 사용됩니다. 기본적으로 Readline은 키 입력이 Emacs와 가장 유사한 Emacs 편집 모드에서 시작됩니다. 이 변수는 '</target>
        </trans-unit>
        <trans-unit id="1e6d32818f3b1d2f5f2232a651e3ca70d24c6998" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;export&lt;/code&gt; and &lt;code&gt;readonly&lt;/code&gt; builtin commands display their output in the format required by &lt;small&gt;POSIX&lt;/small&gt;.</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt; 및 &lt;code&gt;readonly&lt;/code&gt; 명령 내장이 필요로하는 형식으로 자신의 출력을 표시 &lt;small&gt;POSIX&lt;/small&gt; .</target>
        </trans-unit>
        <trans-unit id="41de6dcf35f30bb96146e4f54a60530e578609e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fc&lt;/code&gt; builtin checks &lt;code&gt;$EDITOR&lt;/code&gt; as a program to edit history entries if &lt;code&gt;FCEDIT&lt;/code&gt; is unset, rather than defaulting directly to &lt;code&gt;ed&lt;/code&gt;. &lt;code&gt;fc&lt;/code&gt; uses &lt;code&gt;ed&lt;/code&gt; if &lt;code&gt;EDITOR&lt;/code&gt; is unset.</source>
          <target state="translated">&lt;code&gt;fc&lt;/code&gt; 검사 내장 &lt;code&gt;$EDITOR&lt;/code&gt; 경우 편집 기록 항목에 대한 프로그램으로 &lt;code&gt;FCEDIT&lt;/code&gt; 가 아니라 직접 디폴트보다, 설정되지 &lt;code&gt;ed&lt;/code&gt; . &lt;code&gt;EDITOR&lt;/code&gt; 가 설정되지 않은 경우 &lt;code&gt;fc&lt;/code&gt; 는 &lt;code&gt;ed&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="3b31f152204e4ec71b0864ffc2d625d20f06364f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;kill&lt;/code&gt; builtin does not accept signal names with a &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;kill&lt;/code&gt; 내장은 '으로 신호 이름을 허용하지 않습니다</target>
        </trans-unit>
        <trans-unit id="e6a221ff533de5c2c42163aa08df69ba88bd590b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; builtin allows arithmetic to be performed on shell variables. Each &lt;var&gt;expression&lt;/var&gt; is evaluated according to the rules given below in &lt;a href=&quot;shell-arithmetic#Shell-Arithmetic&quot;&gt;Shell Arithmetic&lt;/a&gt;. If the last &lt;var&gt;expression&lt;/var&gt; evaluates to 0, &lt;code&gt;let&lt;/code&gt; returns 1; otherwise 0 is returned.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 내장 쉘 변수에서 수행 될 산술 수있다. 각 &lt;var&gt;expression&lt;/var&gt; 은 아래의 &lt;a href=&quot;shell-arithmetic#Shell-Arithmetic&quot;&gt;Shell Arithmetic&lt;/a&gt; 규칙에 따라 평가됩니다 . 마지막 &lt;var&gt;expression&lt;/var&gt; 이 0으로 평가되면 &lt;code&gt;let&lt;/code&gt; 은 1을 리턴합니다. 그렇지 않으면 0이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1ccc0c33fd80bc03158c408477f545ccd528cd3e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mkclone&lt;/code&gt; script requires Bash, so you must have already built Bash for at least one architecture before you can create build directories for other architectures.</source>
          <target state="translated">&lt;code&gt;mkclone&lt;/code&gt; 의 스크립트는 다른 아키텍처에 대한 빌드 디렉토리를 작성하기 전에 이미 적어도 하나의 아키텍처 배쉬를 구축해야합니다, 그래서 배쉬가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="79186754fc861af86678e7e71417ba006dc66a6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mode=&lt;/code&gt; form of the &lt;code&gt;$if&lt;/code&gt; directive is used to test whether Readline is in &lt;code&gt;emacs&lt;/code&gt; or &lt;code&gt;vi&lt;/code&gt; mode. This may be used in conjunction with the &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;$if&lt;/code&gt; 지시문 의 &lt;code&gt;mode=&lt;/code&gt; 형식은 Readline이 &lt;code&gt;emacs&lt;/code&gt; 인지 &lt;code&gt;vi&lt;/code&gt; 모드 인지 테스트하는 데 사용 됩니다. 이것은 '</target>
        </trans-unit>
        <trans-unit id="f7a5c495825e4ab9be3107dd1eb8144e2f27817e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noclobber&lt;/code&gt; option is available to avoid overwriting existing files with output redirection (see &lt;a href=&quot;the-set-builtin#The-Set-Builtin&quot;&gt;The Set Builtin&lt;/a&gt;). The &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;noclobber&lt;/code&gt; 옵션 (참조 출력 재 지정으로 기존 파일을 덮어 쓰지 않도록 할 수 있습니다 &lt;a href=&quot;the-set-builtin#The-Set-Builtin&quot;&gt;set 내부를&lt;/a&gt; ). '</target>
        </trans-unit>
        <trans-unit id="71024e24201f40b668438cc9414469b6ac68a493" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;printf&lt;/code&gt; builtin is available to display formatted output (see &lt;a href=&quot;bash-builtins#Bash-Builtins&quot;&gt;Bash Builtins&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;printf&lt;/code&gt; 내장 포맷 출력을 표시 할 수있다 (참조 &lt;a href=&quot;bash-builtins#Bash-Builtins&quot;&gt;배시를 내장 매크로&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="61dd86bae1e8e40040881413babc94342a7b0b03" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pwd&lt;/code&gt; builtin verifies that the value it prints is the same as the current directory, even if it is not asked to check the file system with the</source>
          <target state="translated">내장 된 &lt;code&gt;pwd&lt;/code&gt; 는 파일 시스템을 검사하여 파일 시스템을 확인하도록 요청받지 않더라도 인쇄하는 값이 현재 디렉토리와 동일한 지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="b74c81aeacd11c0aac0772dfd6279123fef0e5a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read&lt;/code&gt; builtin may be interrupted by a signal for which a trap has been set. If Bash receives a trapped signal while executing &lt;code&gt;read&lt;/code&gt;, the trap handler executes and &lt;code&gt;read&lt;/code&gt; returns an exit status greater than 128.</source>
          <target state="translated">&lt;code&gt;read&lt;/code&gt; 내장은 트랩 설정된 해당하는 신호에 의해 중단 될 수있다. &lt;code&gt;read&lt;/code&gt; 를 실행하는 동안 Bash가 트랩 된 신호를 수신 하면 트랩 핸들러가 실행되고 &lt;code&gt;read&lt;/code&gt; 는 128보다 큰 종료 상태를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2a939ead081da617261684b32e11698ddf0b302f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;return&lt;/code&gt; builtin may be used to abort execution of scripts executed with the &lt;code&gt;.&lt;/code&gt; or &lt;code&gt;source&lt;/code&gt; builtins (see &lt;a href=&quot;bourne-shell-builtins#Bourne-Shell-Builtins&quot;&gt;Bourne Shell Builtins&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; 내장은으로 실행 스크립트의 중단 실행을 사용할 수 있습니다 &lt;code&gt;.&lt;/code&gt; 또는 &lt;code&gt;source&lt;/code&gt; 내장 ( &lt;a href=&quot;bourne-shell-builtins#Bourne-Shell-Builtins&quot;&gt;Bourne Shell 내장&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="83298a3607cb05d1448dc0cb7e8179483b47e74d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;select&lt;/code&gt; construct allows the easy generation of menus. It has almost the same syntax as the &lt;code&gt;for&lt;/code&gt; command:</source>
          <target state="translated">&lt;code&gt;select&lt;/code&gt; 구조는 메뉴를 쉽게 생성 할 수 있습니다. &lt;code&gt;for&lt;/code&gt; 명령 과 구문이 거의 같습니다.</target>
        </trans-unit>
        <trans-unit id="a109c32979a5a1982a1fca3d8dd1078f6fc87ca1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;term=&lt;/code&gt; form may be used to include terminal-specific key bindings, perhaps to bind the key sequences output by the terminal&amp;rsquo;s function keys. The word on the right side of the &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;term=&lt;/code&gt; 폼 아마 단말기의 기능 키에 키 시퀀스 출력을 결합하기 위해, 단말 고유 키 바인딩을 포함하는 데 이용 될 수있다. 오른쪽에있는 단어</target>
        </trans-unit>
        <trans-unit id="18c20fa9908a74dde5b5deda1de799593d557c55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;test&lt;/code&gt; and &lt;code&gt;[&lt;/code&gt; builtins evaluate conditional expressions using a set of rules based on the number of arguments.</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; 및 &lt;code&gt;[&lt;/code&gt; 내장 매크로는 인수의 수에 따라 일련의 규칙을 사용하여 조건식을 평가한다.</target>
        </trans-unit>
        <trans-unit id="7609c8398944d20d0b73184e68b20bd594e494c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;test&lt;/code&gt; builtin (see &lt;a href=&quot;bourne-shell-builtins#Bourne-Shell-Builtins&quot;&gt;Bourne Shell Builtins&lt;/a&gt;) is slightly different, as it implements the &lt;small&gt;POSIX&lt;/small&gt; algorithm, which specifies the behavior based on the number of arguments.</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; 내장 (참조 : &lt;a href=&quot;bourne-shell-builtins#Bourne-Shell-Builtins&quot;&gt;본 셸을 내장 매크로&lt;/a&gt; 는 구현으로) 약간 다른 &lt;small&gt;POSIX&lt;/small&gt; 인수의 수에 기초하여 동작을 지정 알고리즘.</target>
        </trans-unit>
        <trans-unit id="2b025dcd96c1d77974596085efac9e34c7171c2b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;time&lt;/code&gt; reserved word may be used by itself as a command. When used in this way, it displays timing statistics for the shell and its completed children. The &lt;code&gt;TIMEFORMAT&lt;/code&gt; variable controls the format of the timing information.</source>
          <target state="translated">&lt;code&gt;time&lt;/code&gt; 예약 된 단어는 명령으로 그 자체로 사용할 수있다. 이 방법으로 사용하면 쉘 및 완료된 하위에 대한 타이밍 통계가 표시됩니다. &lt;code&gt;TIMEFORMAT&lt;/code&gt; 의 변수는 타이밍 정보의 포맷을 제어한다.</target>
        </trans-unit>
        <trans-unit id="ca11ce6dfccf18d7ae5455235edc8005c94707aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;trap&lt;/code&gt; builtin (see &lt;a href=&quot;bourne-shell-builtins#Bourne-Shell-Builtins&quot;&gt;Bourne Shell Builtins&lt;/a&gt;) allows a &lt;code&gt;DEBUG&lt;/code&gt; pseudo-signal specification, similar to &lt;code&gt;EXIT&lt;/code&gt;. Commands specified with a &lt;code&gt;DEBUG&lt;/code&gt; trap are executed before every simple command, &lt;code&gt;for&lt;/code&gt; command, &lt;code&gt;case&lt;/code&gt; command, &lt;code&gt;select&lt;/code&gt; command, every arithmetic &lt;code&gt;for&lt;/code&gt; command, and before the first command executes in a shell function. The &lt;code&gt;DEBUG&lt;/code&gt; trap is not inherited by shell functions unless the function has been given the &lt;code&gt;trace&lt;/code&gt; attribute or the &lt;code&gt;functrace&lt;/code&gt; option has been enabled using the &lt;code&gt;shopt&lt;/code&gt; builtin. The &lt;code&gt;extdebug&lt;/code&gt; shell option has additional effects on the &lt;code&gt;DEBUG&lt;/code&gt; trap.</source>
          <target state="translated">&lt;code&gt;trap&lt;/code&gt; 내장 (참조 : &lt;a href=&quot;bourne-shell-builtins#Bourne-Shell-Builtins&quot;&gt;본 셸을 내장 명령&lt;/a&gt; )을 허용 &lt;code&gt;DEBUG&lt;/code&gt; 유사한 의사 신호 규격 &lt;code&gt;EXIT&lt;/code&gt; 를 . 지정된 명령 &lt;code&gt;DEBUG&lt;/code&gt; 의 트랩마다 간단한 명령 전에 실행 &lt;code&gt;for&lt;/code&gt; 명령 &lt;code&gt;case&lt;/code&gt; 명령 &lt;code&gt;select&lt;/code&gt; 각 연산 명령 &lt;code&gt;for&lt;/code&gt; 명령 및 쉘 함수의 첫 번째 명령이 실행 전에. &lt;code&gt;DEBUG&lt;/code&gt; 함수가 지정하지 않는 한 트랩 쉘 기능에 의해 상속되지 &lt;code&gt;trace&lt;/code&gt; 특성 또는 &lt;code&gt;functrace&lt;/code&gt; 의 사용하여 활성화 된 옵션 &lt;code&gt;shopt&lt;/code&gt; 내부의 내장을. 그만큼 &lt;code&gt;extdebug&lt;/code&gt; 쉘 옵션은 &lt;code&gt;DEBUG&lt;/code&gt; 트랩 에 추가 영향을 미칩니다 .</target>
        </trans-unit>
        <trans-unit id="3d6ce37dbd1878ed225dec119b3b12f838688477" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;trap&lt;/code&gt; builtin (see &lt;a href=&quot;bourne-shell-builtins#Bourne-Shell-Builtins&quot;&gt;Bourne Shell Builtins&lt;/a&gt;) allows a &lt;code&gt;RETURN&lt;/code&gt; pseudo-signal specification, similar to &lt;code&gt;EXIT&lt;/code&gt; and &lt;code&gt;DEBUG&lt;/code&gt;. Commands specified with an &lt;code&gt;RETURN&lt;/code&gt; trap are executed before execution resumes after a shell function or a shell script executed with &lt;code&gt;.&lt;/code&gt; or &lt;code&gt;source&lt;/code&gt; returns. The &lt;code&gt;RETURN&lt;/code&gt; trap is not inherited by shell functions unless the function has been given the &lt;code&gt;trace&lt;/code&gt; attribute or the &lt;code&gt;functrace&lt;/code&gt; option has been enabled using the &lt;code&gt;shopt&lt;/code&gt; builtin.</source>
          <target state="translated">&lt;code&gt;trap&lt;/code&gt; 내장 (참조 : &lt;a href=&quot;bourne-shell-builtins#Bourne-Shell-Builtins&quot;&gt;본 셸을 내장 명령&lt;/a&gt; )을 허용 &lt;code&gt;RETURN&lt;/code&gt; 유사한 의사 신호 규격 &lt;code&gt;EXIT&lt;/code&gt; 및 &lt;code&gt;DEBUG&lt;/code&gt; 를 . &lt;code&gt;RETURN&lt;/code&gt; 트랩으로 지정된 명령 은 쉘 함수 또는로 실행 된 쉘 스크립트 후에 실행이 재개되기 전에 실행됩니다 &lt;code&gt;.&lt;/code&gt; 또는 &lt;code&gt;source&lt;/code&gt; 반환. &lt;code&gt;RETURN&lt;/code&gt; 함수가 지정하지 않는 한 트랩 쉘 기능에 의해 상속되지 &lt;code&gt;trace&lt;/code&gt; 특성 또는 &lt;code&gt;functrace&lt;/code&gt; 의 사용하여 활성화 된 옵션 &lt;code&gt;shopt&lt;/code&gt; 내부의 내장을.</target>
        </trans-unit>
        <trans-unit id="3fdabd768ad127a391fc72e79dc320cecf2c0dfd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;trap&lt;/code&gt; builtin (see &lt;a href=&quot;bourne-shell-builtins#Bourne-Shell-Builtins&quot;&gt;Bourne Shell Builtins&lt;/a&gt;) allows an &lt;code&gt;ERR&lt;/code&gt; pseudo-signal specification, similar to &lt;code&gt;EXIT&lt;/code&gt; and &lt;code&gt;DEBUG&lt;/code&gt;. Commands specified with an &lt;code&gt;ERR&lt;/code&gt; trap are executed after a simple command fails, with a few exceptions. The &lt;code&gt;ERR&lt;/code&gt; trap is not inherited by shell functions unless the &lt;code&gt;-o errtrace&lt;/code&gt; option to the &lt;code&gt;set&lt;/code&gt; builtin is enabled.</source>
          <target state="translated">&lt;code&gt;trap&lt;/code&gt; 내장 (참조 : &lt;a href=&quot;bourne-shell-builtins#Bourne-Shell-Builtins&quot;&gt;본 셸을 내장 매크로&lt;/a&gt; )는 허용 &lt;code&gt;ERR&lt;/code&gt; 유사한 의사 신호 규격 &lt;code&gt;EXIT&lt;/code&gt; 및 &lt;code&gt;DEBUG&lt;/code&gt; 를 . &lt;code&gt;ERR&lt;/code&gt; 트랩으로 지정된 명령은 몇 가지 예외를 제외하고 간단한 명령이 실패한 후에 실행됩니다. &lt;code&gt;ERR&lt;/code&gt; 의 하지 않는 한 트랩 쉘 기능에 의해 상속되지 &lt;code&gt;-o errtrace&lt;/code&gt; 를 받는 옵션 &lt;code&gt;set&lt;/code&gt; 내장이 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="831b45af189787ceb18a9fd01008bdf4c959220e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;trap&lt;/code&gt; builtin displays signal names without the leading &lt;code&gt;SIG&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;trap&lt;/code&gt; 디스플레이 내장은 최고의 않고 이름을 신호 &lt;code&gt;SIG&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec21f73f10dc0c33fb8fc0ed4b8a3ae27c1ef5c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;trap&lt;/code&gt; builtin doesn&amp;rsquo;t check the first argument for a possible signal specification and revert the signal handling to the original disposition if it is, unless that argument consists solely of digits and is a valid signal number. If users want to reset the handler for a given signal to the original disposition, they should use &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;trap&lt;/code&gt; 내장이 가능한 신호 사양 첫번째 인자를 확인하고 그 인수 단독 숫자로 구성하고, 유효 신호의 개수는 않는이면 원래 처분 처리 신호를 되 돌리지 않는다. 사용자가 지정된 신호에 대한 핸들러를 원래 처리로 재설정하려면 '</target>
        </trans-unit>
        <trans-unit id="db7cc09f1546ca9f5cf92492777f27e4b1a5ee7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;command&lt;/code&gt; builtins will not report a non-executable file as having been found, though the shell will attempt to execute such a file if it is the only so-named file found in &lt;code&gt;$PATH&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 및 &lt;code&gt;command&lt;/code&gt; 이 유일한 소위라는 이름의 파일이 발견되면 쉘이 이러한 파일을 실행하려고 시도하지만 내장 명령은 발견 된 같은 비 실행 파일을보고하지 않습니다 &lt;code&gt;$PATH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce0e6ce72d613f9309353713f7270dccf84960f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typeset&lt;/code&gt; command is supplied for compatibility with the Korn shell. It is a synonym for the &lt;code&gt;declare&lt;/code&gt; builtin command.</source>
          <target state="translated">&lt;code&gt;typeset&lt;/code&gt; 명령은 Korn 쉘과의 호환성을 위해 제공됩니다. &lt;code&gt;declare&lt;/code&gt; 내장 명령 의 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="b9be17c095f6d632873df3847bdf9b08ba6bf9f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ulimit&lt;/code&gt; builtin uses a block size of 512 bytes for the</source>
          <target state="translated">내장 된 &lt;code&gt;ulimit&lt;/code&gt; 는 512 바이트의 블록 크기를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="968cfb042d33fc3e485a2e1f5aa8e0f8a9d24bf7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unset&lt;/code&gt; builtin also acts using the same dynamic scope: if a variable is local to the current scope, &lt;code&gt;unset&lt;/code&gt; will unset it; otherwise the unset will refer to the variable found in any calling scope as described above. If a variable at the current local scope is unset, it will remain so until it is reset in that scope or until the function returns. Once the function returns, any instance of the variable at a previous scope will become visible. If the unset acts on a variable at a previous scope, any instance of a variable with that name that had been shadowed will become visible.</source>
          <target state="translated">&lt;code&gt;unset&lt;/code&gt; 내장은 동일한 동적 범위를 이용하여 작용한다 : 변수가 현재 범위에 로컬 인 경우, &lt;code&gt;unset&lt;/code&gt; 그 설정을 해제한다; 그렇지 않으면 설정 해제는 위에서 설명한대로 호출 범위에서 찾은 변수를 참조합니다. 현재 로컬 범위에서 변수가 설정되어 있지 않으면 해당 범위에서 재설정되거나 함수가 반환 될 때까지 그대로 유지됩니다. 함수가 반환되면 이전 범위의 변수 인스턴스가 표시됩니다. 설정되지 않은 변수가 이전 범위의 변수에 작용하면 해당 이름을 가진 변수의 인스턴스가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a0e245a89a701f9b3eb55eaa8fd7e1e476137a4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unset&lt;/code&gt; builtin is used to destroy arrays. &lt;code&gt;unset &lt;var&gt;name&lt;/var&gt;[&lt;var&gt;subscript&lt;/var&gt;]&lt;/code&gt; destroys the array element at index &lt;var&gt;subscript&lt;/var&gt;. Negative subscripts to indexed arrays are interpreted as described above. Unsetting the last element of an array variable does not unset the variable. &lt;code&gt;unset &lt;var&gt;name&lt;/var&gt;&lt;/code&gt;, where &lt;var&gt;name&lt;/var&gt; is an array, removes the entire array. A subscript of &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;unset&lt;/code&gt; 내장 배열을 파괴하는 데 사용됩니다. &lt;code&gt;unset &lt;var&gt;name&lt;/var&gt;[&lt;var&gt;subscript&lt;/var&gt;]&lt;/code&gt; 는 인덱스 &lt;var&gt;subscript&lt;/var&gt; 에서 배열 요소를 파괴합니다 . 인덱스 배열에 대한 음의 아래 첨자는 위에서 설명한대로 해석됩니다. 배열 변수의 마지막 요소를 설정 해제해도 변수는 설정 해제되지 않습니다. &lt;code&gt;unset &lt;var&gt;name&lt;/var&gt;&lt;/code&gt; (여기서 &lt;var&gt;name&lt;/var&gt; 은 배열 임)은 전체 배열을 제거합니다. '의 첨자</target>
        </trans-unit>
        <trans-unit id="480cdaa025b86102c4705881ab585ad9216d728b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;version&lt;/code&gt; test may be used to perform comparisons against specific Readline versions. The &lt;code&gt;version&lt;/code&gt; expands to the current Readline version. The set of comparison operators includes &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;version&lt;/code&gt; 테스트는 특정 Readline와 버전에 대한 비교를 수행하는 데 사용할 수 있습니다. &lt;code&gt;version&lt;/code&gt; 현재의 readline 버전으로 확장합니다. 비교 연산자 세트에는 '</target>
        </trans-unit>
        <trans-unit id="26b1d9d47459a4e083106d792ba76effe9e2b00c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vi&lt;/code&gt; editing mode will invoke the &lt;code&gt;vi&lt;/code&gt; editor directly when the &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;vi&lt;/code&gt; 편집 모드를 호출합니다 &lt;code&gt;vi&lt;/code&gt; 직접 편집기를 할 때 '</target>
        </trans-unit>
        <trans-unit id="6fe1fcebdd17b99aca9e067d295a5e1c42538ce0" translate="yes" xml:space="preserve">
          <source>The &lt;small&gt;POSIX&lt;/small&gt; startup files are executed (&lt;code&gt;$ENV&lt;/code&gt;) rather than the normal Bash files.</source>
          <target state="translated">&lt;small&gt;POSIX&lt;/small&gt; 시작 파일 (실행 &lt;code&gt;$ENV&lt;/code&gt; )이 아닌 일반 배쉬 파일.</target>
        </trans-unit>
        <trans-unit id="255367174b7a8740a41f05bdf2ba1953e1186831" translate="yes" xml:space="preserve">
          <source>The &lt;small&gt;POSIX&lt;/small&gt;&lt;code&gt;$()&lt;/code&gt; form of command substitution is implemented (see &lt;a href=&quot;command-substitution#Command-Substitution&quot;&gt;Command Substitution&lt;/a&gt;), and preferred to the Bourne shell&amp;rsquo;s &lt;code&gt;``&lt;/code&gt; (which is also implemented for backwards compatibility).</source>
          <target state="translated">&lt;small&gt;POSIX &lt;/small&gt; &lt;code&gt;$()&lt;/code&gt; 명령 치환의 형태는 (참조 구현 &lt;a href=&quot;command-substitution#Command-Substitution&quot;&gt;명령 대체를&lt;/a&gt; )하고, 선호하는 Bourne 쉘의에 &lt;code&gt;``&lt;/code&gt; (또한 이전 버전과의 호환성을 위해 구현된다).</target>
        </trans-unit>
        <trans-unit id="75dad2d7beea5fc3a3a1b5f45d608890f0cd459c" translate="yes" xml:space="preserve">
          <source>The &lt;small&gt;POSIX&lt;/small&gt;&lt;code&gt;PS1&lt;/code&gt; and &lt;code&gt;PS2&lt;/code&gt; expansions of &amp;lsquo;</source>
          <target state="translated">'의 &lt;small&gt;POSIX &lt;/small&gt; &lt;code&gt;PS1&lt;/code&gt; 및 &lt;code&gt;PS2&lt;/code&gt; 확장</target>
        </trans-unit>
        <trans-unit id="c67d0f094fc3f04fab9a06d3dc2f965fac327bab" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;action&lt;/var&gt; may be one of the following to generate a list of possible completions:</source>
          <target state="translated">&lt;var&gt;action&lt;/var&gt; 가능한 완성의 목록을 생성하려면 다음 중 하나가 될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="e6a003a6373d4273213b4025450dc71aa5388392" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;application&lt;/var&gt; construct is used to include application-specific settings. Each program using the Readline library sets the &lt;var&gt;application name&lt;/var&gt;, and you can test for a particular value. This could be used to bind key sequences to functions useful for a specific program. For instance, the following command adds a key sequence that quotes the current or previous word in Bash:</source>
          <target state="translated">&lt;var&gt;application&lt;/var&gt; 구조는 애플리케이션 별 설정을 포함하는 데 사용됩니다. Readline 라이브러리를 사용하는 각 프로그램은 &lt;var&gt;application name&lt;/var&gt; 설정 하며 특정 값을 테스트 할 수 있습니다. 키 시퀀스를 특정 프로그램에 유용한 함수에 바인딩하는 데 사용할 수 있습니다. 예를 들어 다음 명령은 Bash에서 현재 또는 이전 단어를 인용하는 키 시퀀스를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="f88fbdc6e650a38683e16bcfad100b046ee4ee38" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;arg&lt;/var&gt;s are added to the end of the history list as a single entry.</source>
          <target state="translated">&lt;var&gt;arg&lt;/var&gt; s는 하나의 항목으로 기록 목록의 끝에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="9ec90f709e5f9c505b88251232d3a1c76288dd87" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;commands&lt;/var&gt; are executed after each selection until a &lt;code&gt;break&lt;/code&gt; command is executed, at which point the &lt;code&gt;select&lt;/code&gt; command completes.</source>
          <target state="translated">&lt;var&gt;commands&lt;/var&gt; 까지 각각의 선택 후에 수행되는 &lt;code&gt;break&lt;/code&gt; 명령이 실행되는 시점, &lt;code&gt;select&lt;/code&gt; 명령이 완료한다.</target>
        </trans-unit>
        <trans-unit id="48898c98eee784fb5f6ea18295358a30f4b7f905" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;comp-option&lt;/var&gt; controls several aspects of the compspec&amp;rsquo;s behavior beyond the simple generation of completions. &lt;var&gt;comp-option&lt;/var&gt; may be one of:</source>
          <target state="translated">&lt;var&gt;comp-option&lt;/var&gt; 완성의 간단한 세대를 넘어 compspec의 행동의 여러 측면을 제어합니다. &lt;var&gt;comp-option&lt;/var&gt; 은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="181c58c500b060dc3f6a4c1f3074539c076322df" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;format&lt;/var&gt; is a character string which contains three types of objects: plain characters, which are simply copied to standard output, character escape sequences, which are converted and copied to the standard output, and format specifications, each of which causes printing of the next successive &lt;var&gt;argument&lt;/var&gt;. In addition to the standard &lt;code&gt;printf(1)&lt;/code&gt; formats, &lt;code&gt;printf&lt;/code&gt; interprets the following extensions:</source>
          <target state="translated">&lt;var&gt;format&lt;/var&gt; 다음의 인쇄 원인, 각각의 표준 출력으로 변환 복사됩니다 단순히 표준 출력에 복사됩니다 일반 문자, 문자 이스케이프 시퀀스, 및 형식 스펙, 세 개체의 유형을 포함하는 문자열입니다 연속적인 &lt;var&gt;argument&lt;/var&gt; . 표준 &lt;code&gt;printf(1)&lt;/code&gt; 형식 외에도 &lt;code&gt;printf&lt;/code&gt; 는 다음 확장자를 해석합니다.</target>
        </trans-unit>
        <trans-unit id="c5630a0384e3462ded4442078517cde64969373c" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;format&lt;/var&gt; is passed to &lt;code&gt;strftime&lt;/code&gt;(3) and the result is inserted into the prompt string; an empty &lt;var&gt;format&lt;/var&gt; results in a locale-specific time representation. The braces are required.</source>
          <target state="translated">&lt;var&gt;format&lt;/var&gt; 으로 전달 &lt;code&gt;strftime&lt;/code&gt; (3) 그 결과는 메시지 문자열 삽입되고 &lt;var&gt;format&lt;/var&gt; 이 비어 있으면 로케일 별 시간이 표시됩니다. 괄호가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="41d883678477e207f935094a81d886b1383d76fb" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;format&lt;/var&gt; is reused as necessary to consume all of the &lt;var&gt;arguments&lt;/var&gt;. If the &lt;var&gt;format&lt;/var&gt; requires more &lt;var&gt;arguments&lt;/var&gt; than are supplied, the extra format specifications behave as if a zero value or null string, as appropriate, had been supplied. The return value is zero on success, non-zero on failure.</source>
          <target state="translated">&lt;var&gt;format&lt;/var&gt; 의 모든 소비 할 필요에 따라 재사용 &lt;var&gt;arguments&lt;/var&gt; . &lt;var&gt;format&lt;/var&gt; 에 제공된 것보다 많은 &lt;var&gt;arguments&lt;/var&gt; 가 필요한 경우 추가 형식 스펙은 0 값 또는 널 문자열이 적절하게 제공된 것처럼 작동합니다. 성공하면 반환 값은 0이고 실패하면 0이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f19eb0371bb44451127e86d4065067ea29a989db" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;n&lt;/var&gt;th word.</source>
          <target state="translated">&lt;var&gt;n&lt;/var&gt; 번째 워드.</target>
        </trans-unit>
        <trans-unit id="68266abd43ed860a6e725494095fa23f51bfd85e" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;pattern&lt;/var&gt; is expanded to produce a pattern just as in filename expansion. &lt;var&gt;Parameter&lt;/var&gt; is expanded and the longest match of &lt;var&gt;pattern&lt;/var&gt; against its value is replaced with &lt;var&gt;string&lt;/var&gt;. The match is performed according to the rules described below (see &lt;a href=&quot;pattern-matching#Pattern-Matching&quot;&gt;Pattern Matching&lt;/a&gt;). If &lt;var&gt;pattern&lt;/var&gt; begins with &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;pattern&lt;/var&gt; 단지 파일 이름 확장에서 같은 패턴을 생성하기 위해 확장된다. &lt;var&gt;Parameter&lt;/var&gt; 가 확장되고 해당 값에 대한 가장 긴 &lt;var&gt;pattern&lt;/var&gt; 일치 가 &lt;var&gt;string&lt;/var&gt; 으로 대체됩니다 . 일치는 아래 설명 된 규칙에 따라 수행됩니다 ( &lt;a href=&quot;pattern-matching#Pattern-Matching&quot;&gt;패턴 일치&lt;/a&gt; 참조 ). &lt;var&gt;pattern&lt;/var&gt; 이 '로 시작 하면</target>
        </trans-unit>
        <trans-unit id="87155350f1ca968163aa9c46ea25ff13d667cec6" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;subscript&lt;/var&gt; is treated as an arithmetic expression that must evaluate to a number. To explicitly declare an array, use</source>
          <target state="translated">아래 &lt;var&gt;subscript&lt;/var&gt; 는 숫자로 평가되어야하는 산술 연산 식으로 취급됩니다. 명시 적으로 배열을 선언하려면</target>
        </trans-unit>
        <trans-unit id="594378cbebeda6287d644d836547f914f6e8931f" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;test-commands&lt;/var&gt; list is executed, and if its return status is zero, the &lt;var&gt;consequent-commands&lt;/var&gt; list is executed. If &lt;var&gt;test-commands&lt;/var&gt; returns a non-zero status, each &lt;code&gt;elif&lt;/code&gt; list is executed in turn, and if its exit status is zero, the corresponding &lt;var&gt;more-consequents&lt;/var&gt; is executed and the command completes. If &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;test-commands&lt;/var&gt; 목록이 실행되고, 그것의 반환 상태가 0 인 경우는 &lt;var&gt;consequent-commands&lt;/var&gt; 목록이 실행된다. 경우 &lt;var&gt;test-commands&lt;/var&gt; 아닌 제로 상태를 반환, 각 &lt;code&gt;elif&lt;/code&gt; 목록이 차례로 실행되고, 종료 상태가 0 인 경우, 해당 &lt;var&gt;more-consequents&lt;/var&gt; 실행되고 명령이 완료됩니다. 만약 '</target>
        </trans-unit>
        <trans-unit id="58cdf4c83fe89d3f7c6ad4c0802efe2f974717b7" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;variable&lt;/var&gt; construct provides simple equality tests for Readline variables and values. The permitted comparison operators are &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;variable&lt;/var&gt; 구조물은의 readline 변수 값 단순한 항등 테스트를 제공한다. 허용 된 비교 연산자는 '</target>
        </trans-unit>
        <trans-unit id="7e03f1d2cb21a846c6525ed5ee9d4ad6e035f30c" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;word&lt;/var&gt; is expanded to produce a pattern and matched according to the rules described below (see &lt;a href=&quot;pattern-matching#Pattern-Matching&quot;&gt;Pattern Matching&lt;/a&gt;). If the pattern matches a trailing portion of the expanded value of &lt;var&gt;parameter&lt;/var&gt;, then the result of the expansion is the value of &lt;var&gt;parameter&lt;/var&gt; with the shortest matching pattern (the &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;word&lt;/var&gt; 후술하는 규칙 (참조에 의한 패턴을 생성하기 위하여 팽창 매칭 &lt;a href=&quot;pattern-matching#Pattern-Matching&quot;&gt;패턴 매칭&lt;/a&gt; ). 패턴이 확장 된 &lt;var&gt;parameter&lt;/var&gt; 값의 후미 부분과 일치하면 확장 결과는 일치 패턴이 가장 짧은 &lt;var&gt;parameter&lt;/var&gt; 의 값 ( '</target>
        </trans-unit>
        <trans-unit id="135d508445236cf079307a09a2a6c555b234eef9" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;word&lt;/var&gt; is expanded to produce a pattern and matched according to the rules described below (see &lt;a href=&quot;pattern-matching#Pattern-Matching&quot;&gt;Pattern Matching&lt;/a&gt;). If the pattern matches the beginning of the expanded value of &lt;var&gt;parameter&lt;/var&gt;, then the result of the expansion is the expanded value of &lt;var&gt;parameter&lt;/var&gt; with the shortest matching pattern (the &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;word&lt;/var&gt; 후술하는 규칙 (참조에 의한 패턴을 생성하기 위하여 팽창 매칭 &lt;a href=&quot;pattern-matching#Pattern-Matching&quot;&gt;패턴 매칭&lt;/a&gt; ). 패턴의 확장 값의 시작과 일치하는 경우 &lt;var&gt;parameter&lt;/var&gt; 다음 확장의 결과의 확장 값 &lt;var&gt;parameter&lt;/var&gt; 최단 매칭 패턴합니다 ( '</target>
        </trans-unit>
        <trans-unit id="8db7640dae201f17ece7a4ce378f29ac781e303c" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;word&lt;/var&gt; undergoes tilde expansion, parameter and variable expansion, command substitution, arithmetic expansion, and quote removal. Pathname expansion and word splitting are not performed. The result is supplied as a single string, with a newline appended, to the command on its standard input (or file descriptor &lt;var&gt;n&lt;/var&gt; if &lt;var&gt;n&lt;/var&gt; is specified).</source>
          <target state="translated">이 &lt;var&gt;word&lt;/var&gt; 물결표 확장, 매개 변수 및 변수 확장, 명령 대체, 산술 확장 및 따옴표 제거가 적용됩니다. 경로 이름 확장 및 단어 분리가 수행되지 않습니다. 결과는 표준 입력 (또는 &lt;var&gt;n&lt;/var&gt; 이 지정된 경우 파일 설명자 &lt;var&gt;n&lt;/var&gt; ) 의 명령에 개행이 추가 된 단일 문자열로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="7dd5a5d55c8f27dde11f3baeaa1f434c5c884f2a" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;wordlist&lt;/var&gt; is split using the characters in the &lt;code&gt;IFS&lt;/code&gt; special variable as delimiters, and each resultant word is expanded. The possible completions are the members of the resultant list which match the word being completed.</source>
          <target state="translated">&lt;var&gt;wordlist&lt;/var&gt; (가)의 문자를 사용하여 분할 &lt;code&gt;IFS&lt;/code&gt; 구분 기호와 같은 특수 변수를 각 결과 단어가 확장됩니다. 가능한 완성은 완성 된 단어와 일치하는 결과 목록의 구성원입니다.</target>
        </trans-unit>
        <trans-unit id="d32dbbafffce1fc4e5112663803f67f698e0313b" translate="yes" xml:space="preserve">
          <source>The Bash &lt;code&gt;cd&lt;/code&gt; and &lt;code&gt;pwd&lt;/code&gt; builtins (see &lt;a href=&quot;bourne-shell-builtins#Bourne-Shell-Builtins&quot;&gt;Bourne Shell Builtins&lt;/a&gt;) each take</source>
          <target state="translated">Bash &lt;code&gt;cd&lt;/code&gt; 및 &lt;code&gt;pwd&lt;/code&gt; 내장 ( &lt;a href=&quot;bourne-shell-builtins#Bourne-Shell-Builtins&quot;&gt;Bourne Shell 내장&lt;/a&gt; 참조 )은 각각</target>
        </trans-unit>
        <trans-unit id="8a995895aaf4f7fd7c7fa7ac037a9f805e6b0cb2" translate="yes" xml:space="preserve">
          <source>The Bash &lt;code&gt;configure&lt;/code&gt; has a number of</source>
          <target state="translated">Bash &lt;code&gt;configure&lt;/code&gt; 에는</target>
        </trans-unit>
        <trans-unit id="5ca648070e218ac90e898929bafc1ebebbc4dc3d" translate="yes" xml:space="preserve">
          <source>The Bash &lt;code&gt;exec&lt;/code&gt; builtin takes additional options that allow users to control the contents of the environment passed to the executed command, and what the zeroth argument to the command is to be (see &lt;a href=&quot;bourne-shell-builtins#Bourne-Shell-Builtins&quot;&gt;Bourne Shell Builtins&lt;/a&gt;).</source>
          <target state="translated">Bash &lt;code&gt;exec&lt;/code&gt; 내장은 사용자가 실행 된 명령에 전달 된 환경의 내용과 명령의 0 번째 인수를 제어 할 수있는 추가 옵션을 취합니다 ( &lt;a href=&quot;bourne-shell-builtins#Bourne-Shell-Builtins&quot;&gt;Bourne Shell Builtins&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9e3e61e392870587087c878ec441b6110999e7a2" translate="yes" xml:space="preserve">
          <source>The Bash &lt;code&gt;export&lt;/code&gt;, &lt;code&gt;readonly&lt;/code&gt;, and &lt;code&gt;declare&lt;/code&gt; builtins can take a</source>
          <target state="translated">Bash &lt;code&gt;export&lt;/code&gt; , &lt;code&gt;readonly&lt;/code&gt; 및 내장 &lt;code&gt;declare&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="e84f3de2b05bb82f105adb422f91a0235e33ed21" translate="yes" xml:space="preserve">
          <source>The Bash &lt;code&gt;hash&lt;/code&gt; builtin allows a name to be associated with an arbitrary filename, even when that filename cannot be found by searching the &lt;code&gt;$PATH&lt;/code&gt;, using &amp;lsquo;</source>
          <target state="translated">Bash &lt;code&gt;hash&lt;/code&gt; 내장 기능을 사용하면 ' &lt;code&gt;$PATH&lt;/code&gt; 를 사용하여 $ PATH 를 검색하여 해당 파일 이름을 찾을 수없는 경우에도 임의의 파일 이름과 이름을 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f1a29c23ab47c096c80d29d1f28c871afdbf2f9" translate="yes" xml:space="preserve">
          <source>The Bash &lt;code&gt;read&lt;/code&gt; builtin (see &lt;a href=&quot;bash-builtins#Bash-Builtins&quot;&gt;Bash Builtins&lt;/a&gt;) will read a line ending in &amp;lsquo;</source>
          <target state="translated">Bash &lt;code&gt;read&lt;/code&gt; builtin ( &lt;a href=&quot;bash-builtins#Bash-Builtins&quot;&gt;Bash Builtins&lt;/a&gt; 참조 )은 '로 끝나는 줄을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="9560f04958ba9662309d7c9ca30a5452558e8734" translate="yes" xml:space="preserve">
          <source>The Bash &lt;code&gt;type&lt;/code&gt; builtin is more extensive and gives more information about the names it finds (see &lt;a href=&quot;bash-builtins#Bash-Builtins&quot;&gt;Bash Builtins&lt;/a&gt;).</source>
          <target state="translated">Bash &lt;code&gt;type&lt;/code&gt; 내장은 더 광범위하며 찾은 이름에 대한 자세한 정보를 제공합니다 ( &lt;a href=&quot;bash-builtins#Bash-Builtins&quot;&gt;Bash 내장&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="011f68718a3bf7ddfcc10c8f4d4974853dd058fa" translate="yes" xml:space="preserve">
          <source>The Bash &lt;code&gt;umask&lt;/code&gt; builtin permits a</source>
          <target state="translated">Bash &lt;code&gt;umask&lt;/code&gt; 내장은</target>
        </trans-unit>
        <trans-unit id="88a134a32d506c251b6b9f4f2024b15b176c6d2c" translate="yes" xml:space="preserve">
          <source>The Bash builtin commands that manipulate the command history.</source>
          <target state="translated">명령 히스토리를 조작하는 Bash 내장 명령.</target>
        </trans-unit>
        <trans-unit id="dfad86bb10df133daef7e9361ebf45d501606d4f" translate="yes" xml:space="preserve">
          <source>The Bash restricted mode is more useful (see &lt;a href=&quot;the-restricted-shell#The-Restricted-Shell&quot;&gt;The Restricted Shell&lt;/a&gt;); the SVR4.2 shell restricted mode is too limited.</source>
          <target state="translated">Bash 제한 모드가 더 유용합니다 ( &lt;a href=&quot;the-restricted-shell#The-Restricted-Shell&quot;&gt;Restricted Shell&lt;/a&gt; 참조 ). SVR4.2 쉘 제한 모드가 너무 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="f350d3ce6f3b2d6288fc07ca3f4336ba164ab29c" translate="yes" xml:space="preserve">
          <source>The CPU percentage, computed as (%U + %S) / %R.</source>
          <target state="translated">(% U + % S) / % R로 계산 된 CPU 백분율입니다.</target>
        </trans-unit>
        <trans-unit id="8101e8043dfcb405fba00536d729164e8202e22c" translate="yes" xml:space="preserve">
          <source>The Directory Stack</source>
          <target state="translated">디렉토리 스택</target>
        </trans-unit>
        <trans-unit id="44da4a00c73cebc1904bc729c930599744fcdb80" translate="yes" xml:space="preserve">
          <source>The Document may include Warranty Disclaimers next to the notice which states that this License applies to the Document. These Warranty Disclaimers are considered to be included by reference in this License, but only as regards disclaiming warranties: any other implication that these Warranty Disclaimers may have is void and has no effect on the meaning of this License.</source>
          <target state="translated">문서에는이 라이센스가 문서에 적용된다는 통지 옆에 보증 고지 사항이 포함될 수 있습니다. 본 보증 면책 조항은 본 라이센스에 참조로 포함 된 것으로 간주되지만, 보증 면책 조항과 관련해서 만 : 본 보증 면책 조항이 가질 수있는 기타 영향은 무효이며 본 라이센스의 의미에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc4e1b1f3573db339f8f310e945685b221d8f7f8" translate="yes" xml:space="preserve">
          <source>The Free Software Foundation may publish new, revised versions of the GNU Free Documentation License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. See &lt;a href=&quot;http://www.gnu.org/copyleft/&quot;&gt;http://www.gnu.org/copyleft/&lt;/a&gt;.</source>
          <target state="translated">자유 소프트웨어 재단은 때때로 개정 된 GNU 자유 문서 라이센스 버전을 게시 할 수 있습니다. 이러한 새 버전은 현재 버전과 비슷하지만 새로운 문제 나 문제를 해결하기 위해 세부적으로 다를 수 있습니다. &lt;a href=&quot;http://www.gnu.org/copyleft/&quot;&gt;http://www.gnu.org/copyleft/를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9fa1d9aab0e3b835f4051ce83b125ccb3ca8221c" translate="yes" xml:space="preserve">
          <source>The GNU Bash Reference Manual</source>
          <target state="translated">GNU Bash 참조 매뉴얼</target>
        </trans-unit>
        <trans-unit id="7e3dcb60799ee16ce758c52d568981c6f3a3fed7" translate="yes" xml:space="preserve">
          <source>The History library provides a history expansion feature that is similar to the history expansion provided by &lt;code&gt;csh&lt;/code&gt;. This section describes the syntax used to manipulate the history information.</source>
          <target state="translated">히스토리 라이브러리는 &lt;code&gt;csh&lt;/code&gt; 에서 제공하는 히스토리 확장과 유사한 히스토리 확장 기능을 제공합니다 . 이 섹션에서는 기록 정보를 조작하는 데 사용되는 구문에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d1ed7400ec115a9dfc3fddebdd8a40128c4ded56" translate="yes" xml:space="preserve">
          <source>The Restricted Shell</source>
          <target state="translated">제한된 껍질</target>
        </trans-unit>
        <trans-unit id="0221900f3cc15a1c298860102bf64524308b81de" translate="yes" xml:space="preserve">
          <source>The SVR4.2 &lt;code&gt;sh&lt;/code&gt; uses a &lt;code&gt;TIMEOUT&lt;/code&gt; variable like Bash uses &lt;code&gt;TMOUT&lt;/code&gt;.</source>
          <target state="translated">SVR4.2의 &lt;code&gt;sh&lt;/code&gt; 사용 &lt;code&gt;TIMEOUT&lt;/code&gt; 배쉬 같은 변수가 사용 &lt;code&gt;TMOUT&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="f86158c9c8608385c777b3354e666f7607899302" translate="yes" xml:space="preserve">
          <source>The SVR4.2 shell behaves differently when invoked as &lt;code&gt;jsh&lt;/code&gt; (it turns on job control).</source>
          <target state="translated">SVR4.2 쉘은 &lt;code&gt;jsh&lt;/code&gt; 로 호출 될 때 다르게 작동합니다 (작업 제어를 켭니다).</target>
        </trans-unit>
        <trans-unit id="51dd1dec0e8631e54d29f98cee86e1486aa8c7c7" translate="yes" xml:space="preserve">
          <source>The SVR4.2 shell does not allow the &lt;code&gt;IFS&lt;/code&gt;, &lt;code&gt;MAILCHECK&lt;/code&gt;, &lt;code&gt;PATH&lt;/code&gt;, &lt;code&gt;PS1&lt;/code&gt;, or &lt;code&gt;PS2&lt;/code&gt; variables to be unset.</source>
          <target state="translated">SVR4.2 쉘은 &lt;code&gt;IFS&lt;/code&gt; , &lt;code&gt;MAILCHECK&lt;/code&gt; , &lt;code&gt;PATH&lt;/code&gt; , &lt;code&gt;PS1&lt;/code&gt; 또는 &lt;code&gt;PS2&lt;/code&gt; 변수를 설정 해제 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7dc3e76e4a7a71a2c5c68736369778200d4a068b" translate="yes" xml:space="preserve">
          <source>The SVR4.2 shell does not allow users to trap &lt;code&gt;SIGSEGV&lt;/code&gt;, &lt;code&gt;SIGALRM&lt;/code&gt;, or &lt;code&gt;SIGCHLD&lt;/code&gt;.</source>
          <target state="translated">SVR4.2 쉘에서는 사용자가 &lt;code&gt;SIGSEGV&lt;/code&gt; , &lt;code&gt;SIGALRM&lt;/code&gt; 또는 &lt;code&gt;SIGCHLD&lt;/code&gt; 를 트랩 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7c8cec60eaa81d287be6036d5b3330155d2aaee0" translate="yes" xml:space="preserve">
          <source>The SVR4.2 shell exits a script if any builtin fails; Bash exits a script only if one of the &lt;small&gt;POSIX&lt;/small&gt; special builtins fails, and only for certain failures, as enumerated in the &lt;small&gt;POSIX&lt;/small&gt; standard.</source>
          <target state="translated">내장에 실패하면 SVR4.2 쉘이 스크립트를 종료합니다. &lt;small&gt;POSIX&lt;/small&gt; 표준에 열거 된 &lt;small&gt;POSIX&lt;/small&gt; 특수 내장 중 하나가 실패하고 특정 실패에 대해서만 Bash가 스크립트를 종료합니다 .&lt;small&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="e9e65fac50588f06f337b446e689d06b9fa1fcdd" translate="yes" xml:space="preserve">
          <source>The SVR4.2 shell has two privilege-related builtins (&lt;code&gt;mldmode&lt;/code&gt; and &lt;code&gt;priv&lt;/code&gt;) not present in Bash.</source>
          <target state="translated">SVR4.2 쉘에는 Bash에없는 두 가지 권한 관련 내장 ( &lt;code&gt;mldmode&lt;/code&gt; 및 &lt;code&gt;priv&lt;/code&gt; )이 있습니다.</target>
        </trans-unit>
        <trans-unit id="abfe42a73378f192636c416081ee0ba75c921dbd" translate="yes" xml:space="preserve">
          <source>The SVR4.2 shell treats &amp;lsquo;</source>
          <target state="translated">SVR4.2 쉘은</target>
        </trans-unit>
        <trans-unit id="32da5124ce290e06f5df4021e5c9e58a2ec68fca" translate="yes" xml:space="preserve">
          <source>The SVR4.2 shell uses a baroque memory management scheme based on trapping &lt;code&gt;SIGSEGV&lt;/code&gt;. If the shell is started from a process with &lt;code&gt;SIGSEGV&lt;/code&gt; blocked (e.g., by using the &lt;code&gt;system()&lt;/code&gt; C library function call), it misbehaves badly.</source>
          <target state="translated">SVR4.2 쉘은 &lt;code&gt;SIGSEGV&lt;/code&gt; 트래핑에 기반한 바로크 메모리 관리 체계를 사용합니다 . &lt;code&gt;SIGSEGV&lt;/code&gt; 가 차단 된 프로세스 (예 : &lt;code&gt;system()&lt;/code&gt; C 라이브러리 함수 호출 사용) 에서 쉘을 시작 하면 잘못 작동합니다.</target>
        </trans-unit>
        <trans-unit id="9d078170d9ac1a24a65b855ed322285b43c4a1f9" translate="yes" xml:space="preserve">
          <source>The Set Builtin</source>
          <target state="translated">내장 세트</target>
        </trans-unit>
        <trans-unit id="a178a5fcf936f299e161d13787958b2688f0a3bd" translate="yes" xml:space="preserve">
          <source>The Shopt Builtin</source>
          <target state="translated">Shopt Builtin</target>
        </trans-unit>
        <trans-unit id="c44b3bbabdeb1666eb94cab66694e7ce4fb1c065" translate="yes" xml:space="preserve">
          <source>The above table describes the most basic keystrokes that you need in order to do editing of the input line. For your convenience, many other commands have been added in addition to</source>
          <target state="translated">위의 표는 입력 라인을 편집하는 데 필요한 가장 기본적인 키 입력을 설명합니다. 편의를 위해 많은 다른 명령이 추가되었습니다</target>
        </trans-unit>
        <trans-unit id="bfb30ed55cffda59921fb41c9a88599aba518ba6" translate="yes" xml:space="preserve">
          <source>The arguments are concatenated together into a single command, which is then read and executed, and its exit status returned as the exit status of &lt;code&gt;eval&lt;/code&gt;. If there are no arguments or only empty arguments, the return status is zero.</source>
          <target state="translated">인수는 단일 명령으로 함께 연결되어 읽히고 실행되며 종료 상태는 &lt;code&gt;eval&lt;/code&gt; 의 종료 상태로 리턴됩니다 . 인수가 없거나 빈 인수 만있는 경우 반환 상태는 0입니다.</target>
        </trans-unit>
        <trans-unit id="80f8ba932268350e49c3ab1b42a0ce68722c6824" translate="yes" xml:space="preserve">
          <source>The arguments to the interpreter consist of a single optional argument following the interpreter name on the first line of the script file, followed by the name of the script file, followed by the rest of the arguments. Bash will perform this action on operating systems that do not handle it themselves. Note that some older versions of Unix limit the interpreter name and argument to a maximum of 32 characters.</source>
          <target state="translated">인터프리터에 대한 인수는 스크립트 파일의 첫 번째 행에있는 인터프리터 이름 다음에 스크립트 파일 이름과 나머지 인수가 오는 단일 선택적 인수로 구성됩니다. Bash는 스스로 처리하지 않는 운영 체제에서이 작업을 수행합니다. 일부 이전 버전의 Unix는 인터프리터 이름과 인수를 최대 32 자로 제한합니다.</target>
        </trans-unit>
        <trans-unit id="544b33d9a56fea5e12b312c1fecdfd3f4e00c12c" translate="yes" xml:space="preserve">
          <source>The arithmetic &lt;var&gt;expression&lt;/var&gt; is evaluated according to the rules described below (see &lt;a href=&quot;shell-arithmetic#Shell-Arithmetic&quot;&gt;Shell Arithmetic&lt;/a&gt;). If the value of the expression is non-zero, the return status is 0; otherwise the return status is 1. This is exactly equivalent to</source>
          <target state="translated">산술 &lt;var&gt;expression&lt;/var&gt; 은 아래에 설명 된 규칙에 따라 평가됩니다 ( &lt;a href=&quot;shell-arithmetic#Shell-Arithmetic&quot;&gt;쉘 산술&lt;/a&gt; 참조 ). 표현식의 값이 0이 아닌 경우 리턴 상태는 0입니다. 그렇지 않으면 반환 상태는 1입니다. 이것은 정확히</target>
        </trans-unit>
        <trans-unit id="d20a2ea71a62e80042fe4b221f62bbc7d9ad9534" translate="yes" xml:space="preserve">
          <source>The arrival of &lt;code&gt;SIGCHLD&lt;/code&gt; when a trap is set on &lt;code&gt;SIGCHLD&lt;/code&gt; does not interrupt the &lt;code&gt;wait&lt;/code&gt; builtin and cause it to return immediately. The trap command is run once for each child that exits.</source>
          <target state="translated">트랩이 &lt;code&gt;SIGCHLD&lt;/code&gt; 에 설정 될 때 &lt;code&gt;SIGCHLD&lt;/code&gt; 의 도착은 내장 &lt;code&gt;wait&lt;/code&gt; 방해하지 않으며 즉시 리턴합니다. 트랩 명령은 종료되는 각 하위에 대해 한 번씩 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="3c942f1235d6aa99590aadaf6d144fb8e66aa7a8" translate="yes" xml:space="preserve">
          <source>The author(s) and publisher(s) of the Document do not by this License give permission to use their names for publicity for or to assert or imply endorsement of any Modified Version.</source>
          <target state="translated">이 사용권 계약에 의해 문서의 저자 및 발행인은 자신의 이름을 수정 버전의 홍보 또는 주장 또는 암시를 암시 할 수있는 권한을 부여하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0719d70a53ccc4d8b1222bf02f06761ac07d2e30" translate="yes" xml:space="preserve">
          <source>The basename of &lt;code&gt;$PWD&lt;/code&gt;, with &lt;code&gt;$HOME&lt;/code&gt; abbreviated with a tilde.</source>
          <target state="translated">의 기본 이름 &lt;code&gt;$PWD&lt;/code&gt; 와, &lt;code&gt;$HOME&lt;/code&gt; 물결표 약자.</target>
        </trans-unit>
        <trans-unit id="4e3b8521e9991cf592635840f88cab8b001d472f" translate="yes" xml:space="preserve">
          <source>The basename of the shell&amp;rsquo;s terminal device name.</source>
          <target state="translated">쉘 터미널 장치 이름의 기본 이름입니다.</target>
        </trans-unit>
        <trans-unit id="22b08de91689f1b108df56372625d3addb0d1e32" translate="yes" xml:space="preserve">
          <source>The basic form of parameter expansion is ${&lt;var&gt;parameter&lt;/var&gt;}. The value of &lt;var&gt;parameter&lt;/var&gt; is substituted. The &lt;var&gt;parameter&lt;/var&gt; is a shell parameter as described above (see &lt;a href=&quot;shell-parameters#Shell-Parameters&quot;&gt;Shell Parameters&lt;/a&gt;) or an array reference (see &lt;a href=&quot;arrays#Arrays&quot;&gt;Arrays&lt;/a&gt;). The braces are required when &lt;var&gt;parameter&lt;/var&gt; is a positional parameter with more than one digit, or when &lt;var&gt;parameter&lt;/var&gt; is followed by a character that is not to be interpreted as part of its name.</source>
          <target state="translated">매개 변수 확장의 기본 형식은 $ { &lt;var&gt;parameter&lt;/var&gt; }입니다. &lt;var&gt;parameter&lt;/var&gt; 값 이 대체됩니다. &lt;var&gt;parameter&lt;/var&gt; 전술 한 바와 같이 쉘 파라미터이다 ( &lt;a href=&quot;shell-parameters#Shell-Parameters&quot;&gt;셸 파라미터&lt;/a&gt; ) 또는 배열 기준 (참고 &lt;a href=&quot;arrays#Arrays&quot;&gt;배열&lt;/a&gt; ). &lt;var&gt;parameter&lt;/var&gt; 가 두 자리 이상의 위치 매개 변수이거나 &lt;var&gt;parameter&lt;/var&gt; 뒤에 이름의 일부로 해석되지 않는 문자가 오는 경우 중괄호가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="522497e12cce3a24573239f8f443b81d58f1c108" translate="yes" xml:space="preserve">
          <source>The basic operation of the shell.</source>
          <target state="translated">쉘의 기본 조작.</target>
        </trans-unit>
        <trans-unit id="547b737e157ebce4950fd4c3ba0807ea7f813f59" translate="yes" xml:space="preserve">
          <source>The build version.</source>
          <target state="translated">빌드 버전.</target>
        </trans-unit>
        <trans-unit id="e1031c39f1533ef620fa929abb5b80eb7ef4e303" translate="yes" xml:space="preserve">
          <source>The builtin command &lt;code&gt;fc&lt;/code&gt; may be used to list or edit and re-execute a portion of the history list. The &lt;code&gt;history&lt;/code&gt; builtin may be used to display or modify the history list and manipulate the history file. When using command-line editing, search commands are available in each editing mode that provide access to the history list (see &lt;a href=&quot;commands-for-history#Commands-For-History&quot;&gt;Commands For History&lt;/a&gt;).</source>
          <target state="translated">내장 명령 &lt;code&gt;fc&lt;/code&gt; 를 사용하여 히스토리 목록의 일부를 나열하거나 편집하고 다시 실행할 수 있습니다. &lt;code&gt;history&lt;/code&gt; 내장은 표시하거나 기록 목록을 수정하고 기록 파일을 조작하는 데 사용할 수 있습니다. 명령 행 편집을 사용하는 경우 히스토리 목록에 대한 액세스를 제공하는 각 편집 모드에서 검색 명령을 사용할 수 있습니다 (히스토리 &lt;a href=&quot;commands-for-history#Commands-For-History&quot;&gt;명령&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5681c7eb98f8f62f9691a67a1aa7dc98ddf16666" translate="yes" xml:space="preserve">
          <source>The character indicating end-of-file as set, for example, by &lt;code&gt;stty&lt;/code&gt;. If this character is read when there are no characters on the line, and point is at the beginning of the line, Readline interprets it as the end of input and returns &lt;small&gt;EOF&lt;/small&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;stty&lt;/code&gt; 에 의해 설정된 파일 끝을 나타내는 문자 입니다. 행에 문자가없고 포인트가 행의 시작 부분에있을 때이 문자를 읽으면 Readline은 입력의 끝으로 해석하여 &lt;small&gt;EOF를&lt;/small&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="a1f43e37d7e0145f9475ffaf82e4a308daf0898d" translate="yes" xml:space="preserve">
          <source>The character whose ASCII code is the octal value &lt;var&gt;nnn&lt;/var&gt;.</source>
          <target state="translated">ASCII 코드가 8 진수 값 &lt;var&gt;nnn&lt;/var&gt; 인 문자입니다 .</target>
        </trans-unit>
        <trans-unit id="57a7ee957bc5a71d3cbf9326e9008389a7ca4437" translate="yes" xml:space="preserve">
          <source>The combined work need only contain one copy of this License, and multiple identical Invariant Sections may be replaced with a single copy. If there are multiple Invariant Sections with the same name but different contents, make the title of each such section unique by adding at the end of it, in parentheses, the name of the original author or publisher of that section if known, or else a unique number. Make the same adjustment to the section titles in the list of Invariant Sections in the license notice of the combined work.</source>
          <target state="translated">결합 된 저작물에는이 라이센스의 사본이 하나만 있으면되며 여러 개의 동일한 고정 섹션이 단일 사본으로 대체 될 수 있습니다. 이름은 같지만 내용이 다른 불변 섹션이 여러 개있는 경우 섹션 끝 (해당 섹션의 원래 작성자 또는 발행자 이름을 괄호로 묶음)을 추가하여 각 섹션의 제목을 고유하게 만드십시오. 고유 번호. 결합 된 저작물의 라이센스 고지에있는 불변 섹션 목록에서 섹션 제목을 동일하게 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="363f698c08628d02c4804195d4308c0880e37d96" translate="yes" xml:space="preserve">
          <source>The command argument to the</source>
          <target state="translated">에 대한 명령 인수</target>
        </trans-unit>
        <trans-unit id="db438ba0a9d98063be92c5c7fdf602e0c569af2c" translate="yes" xml:space="preserve">
          <source>The command currently being executed or about to be executed, unless the shell is executing a command as the result of a trap, in which case it is the command executing at the time of the trap.</source>
          <target state="translated">쉘이 트랩의 결과로 명령을 실행하지 않는 한, 현재 실행 중이거나 실행 되려는 명령.이 경우에는 트랩시 명령이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="d298dac4bb7f8b8b84ac852a5deae9875edb6e39" translate="yes" xml:space="preserve">
          <source>The command number and the history number are usually different: the history number of a command is its position in the history list, which may include commands restored from the history file (see &lt;a href=&quot;bash-history-facilities#Bash-History-Facilities&quot;&gt;Bash History Facilities&lt;/a&gt;), while the command number is the position in the sequence of commands executed during the current shell session.</source>
          <target state="translated">명령 번호와 히스토리 번호는 일반적으로 다릅니다. 명령의 히스토리 번호는 히스토리 목록에서 위치이며, 히스토리 파일에서 복원 된 명령을 포함 할 수 있습니다 ( &lt;a href=&quot;bash-history-facilities#Bash-History-Facilities&quot;&gt;Bash 히스토리 기능&lt;/a&gt; 참조 ). 현재 쉘 세션 동안 실행 된 명령 순서</target>
        </trans-unit>
        <trans-unit id="68c083513e7077cde36063ca622b3fe84c369a12" translate="yes" xml:space="preserve">
          <source>The command number of this command.</source>
          <target state="translated">이 명령의 명령 번호</target>
        </trans-unit>
        <trans-unit id="444edec36d62dad4eb01d33ce460ea3f967b5e7b" translate="yes" xml:space="preserve">
          <source>The commands in &lt;var&gt;arg&lt;/var&gt; are to be read and executed when the shell receives signal &lt;var&gt;sigspec&lt;/var&gt;. If &lt;var&gt;arg&lt;/var&gt; is absent (and there is a single &lt;var&gt;sigspec&lt;/var&gt;) or equal to &amp;lsquo;</source>
          <target state="translated">쉘이 &lt;var&gt;sigspec&lt;/var&gt; 신호를 수신 할 때 &lt;var&gt;arg&lt;/var&gt; 의 명령을 읽고 실행 해야 합니다. 경우 &lt;var&gt;arg&lt;/var&gt; (단일 부재가 &lt;var&gt;sigspec&lt;/var&gt; ) 또는 '동등</target>
        </trans-unit>
        <trans-unit id="aaf7f9b1349e0e7e1616c5e20edba33e1e828af3" translate="yes" xml:space="preserve">
          <source>The compiler used to compile Bash.</source>
          <target state="translated">컴파일러는 Bash를 컴파일하는 데 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="eb5c3e35ed67e42305d577a701f3bbae6dd338b1" translate="yes" xml:space="preserve">
          <source>The configuration process uses GCC to build Bash if it is available.</source>
          <target state="translated">구성 프로세스는 사용 가능한 경우 GCC를 사용하여 Bash를 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="1c7411b2494a8d31cf91d750fc8ee6f3169c04af" translate="yes" xml:space="preserve">
          <source>The contents of the Readline line buffer, for use with &amp;lsquo;</source>
          <target state="translated">'와 함께 사용하기위한 Readline 라인 버퍼의 내용</target>
        </trans-unit>
        <trans-unit id="2c45336942920b7170007cc831424a324196685a" translate="yes" xml:space="preserve">
          <source>The contents of the directory stack are also visible as the value of the &lt;code&gt;DIRSTACK&lt;/code&gt; shell variable.</source>
          <target state="translated">디렉토리 스택의 내용은 &lt;code&gt;DIRSTACK&lt;/code&gt; 쉘 변수 의 값으로도 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="272cfe39d051b3b6acdf30eb9e7ff41d5210caa6" translate="yes" xml:space="preserve">
          <source>The current command line. This variable is available only in shell functions and external commands invoked by the programmable completion facilities (see &lt;a href=&quot;programmable-completion#Programmable-Completion&quot;&gt;Programmable Completion&lt;/a&gt;).</source>
          <target state="translated">현재 명령 행 이 변수는 프로그램 가능 완료 기능에 의해 호출 된 쉘 기능 및 외부 명령에서만 사용 가능합니다 ( &lt;a href=&quot;programmable-completion#Programmable-Completion&quot;&gt;프로그램 가능 완료&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="85b7d3b88d190b91804d29fb6c79b02596242b66" translate="yes" xml:space="preserve">
          <source>The current user&amp;rsquo;s home directory; the default for the &lt;code&gt;cd&lt;/code&gt; builtin command. The value of this variable is also used by tilde expansion (see &lt;a href=&quot;tilde-expansion#Tilde-Expansion&quot;&gt;Tilde Expansion&lt;/a&gt;).</source>
          <target state="translated">현재 사용자의 홈 디렉토리 &lt;code&gt;cd&lt;/code&gt; 내장 명령 의 기본값 이 변수의 값은 또한 물결 팽창에 의해 사용된다 ( &lt;a href=&quot;tilde-expansion#Tilde-Expansion&quot;&gt;틸드 확장&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="756252819c489eccf2d6dfd7220af85cbf39741e" translate="yes" xml:space="preserve">
          <source>The current working directory as set by the &lt;code&gt;cd&lt;/code&gt; builtin.</source>
          <target state="translated">&lt;code&gt;cd&lt;/code&gt; 내장에서 설정 한 현재 작업 디렉토리 .</target>
        </trans-unit>
        <trans-unit id="2d977a91df3c6d96d531d4699803ccb23120defa" translate="yes" xml:space="preserve">
          <source>The current working directory, with &lt;code&gt;$HOME&lt;/code&gt; abbreviated with a tilde (uses the &lt;code&gt;$PROMPT_DIRTRIM&lt;/code&gt; variable).</source>
          <target state="translated">&lt;code&gt;$HOME&lt;/code&gt; 이 물결표로 축약 된 현재 작업 디렉토리 ( &lt;code&gt;$PROMPT_DIRTRIM&lt;/code&gt; 변수 사용).</target>
        </trans-unit>
        <trans-unit id="2e40e2943bfc29c4e8f571c2cc18658ade7b2675" translate="yes" xml:space="preserve">
          <source>The date, in &quot;Weekday Month Date&quot; format (e.g., &quot;Tue May 26&quot;).</source>
          <target state="translated">&quot;평일 월 날짜&quot;형식의 날짜 (예 : &quot;화 5 월 26 일&quot;).</target>
        </trans-unit>
        <trans-unit id="76cdb31f5e7b4f5eff9ab47dfb6bfbb2699ca5bd" translate="yes" xml:space="preserve">
          <source>The default editor used by &lt;code&gt;fc&lt;/code&gt; is &lt;code&gt;ed&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fc&lt;/code&gt; 가 사용하는 기본 편집기 는 &lt;code&gt;ed&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c83865772580a561b300828e97c67e2bb4129e60" translate="yes" xml:space="preserve">
          <source>The default history file is</source>
          <target state="translated">기본 기록 파일은</target>
        </trans-unit>
        <trans-unit id="cf2b50ab45069e3e4b7917ea14c9ab9c0c14b0e2" translate="yes" xml:space="preserve">
          <source>The default variable for the &lt;code&gt;read&lt;/code&gt; builtin.</source>
          <target state="translated">&lt;code&gt;read&lt;/code&gt; 내장 의 기본 변수입니다 .</target>
        </trans-unit>
        <trans-unit id="0422c738d422db971a344fd93c76843bfddb16dd" translate="yes" xml:space="preserve">
          <source>The directory stack is a list of recently-visited directories. The &lt;code&gt;pushd&lt;/code&gt; builtin adds directories to the stack as it changes the current directory, and the &lt;code&gt;popd&lt;/code&gt; builtin removes specified directories from the stack and changes the current directory to the directory removed. The &lt;code&gt;dirs&lt;/code&gt; builtin displays the contents of the directory stack. The current directory is always the &quot;top&quot; of the directory stack.</source>
          <target state="translated">디렉토리 스택은 최근에 방문한 디렉토리의 목록입니다. &lt;code&gt;pushd&lt;/code&gt; 현재 디렉토리를 변경하고 같은 내장은 스택에 디렉토리를 추가 &lt;code&gt;popd&lt;/code&gt; 를 제거합니다 내장이 스택에서 디렉토리를 지정 제거 디렉토리로 현재 디렉토리를 변경합니다. 내장 된 &lt;code&gt;dirs&lt;/code&gt; 는 디렉토리 스택의 내용을 표시합니다. 현재 디렉토리는 항상 디렉토리 스택의 &quot;맨 위&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="f84fe1217141a60f1acea263424777b99143ff80" translate="yes" xml:space="preserve">
          <source>The editor used as a default by the</source>
          <target state="translated">에 의해 기본값으로 사용되는 편집기</target>
        </trans-unit>
        <trans-unit id="8f8ac00d44812804b6698dc01288babfb57f1868" translate="yes" xml:space="preserve">
          <source>The elapsed time in seconds.</source>
          <target state="translated">경과 시간 (초)</target>
        </trans-unit>
        <trans-unit id="1be6a1113e30606692a67477f4097f43bbe26e72" translate="yes" xml:space="preserve">
          <source>The entire command line typed so far.</source>
          <target state="translated">지금까지 전체 명령 줄이 입력되었습니다.</target>
        </trans-unit>
        <trans-unit id="004ef2973c3fe380792b41ec8640618bf36ae5ec" translate="yes" xml:space="preserve">
          <source>The environment for any simple command or function may be augmented temporarily by prefixing it with parameter assignments, as described in &lt;a href=&quot;shell-parameters#Shell-Parameters&quot;&gt;Shell Parameters&lt;/a&gt;. These assignment statements affect only the environment seen by that command.</source>
          <target state="translated">&lt;a href=&quot;shell-parameters#Shell-Parameters&quot;&gt;쉘 매개 변수에&lt;/a&gt; 설명 된대로 간단한 명령 또는 기능의 환경은 매개 변수 지정으로 접 두부로 임시로 기능을 보강 할 수 있습니다 . 이러한 할당 문은 해당 명령으로 보이는 환경에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="c806edb5a9a33cdfe28359bafdacfa8e20ef36ad" translate="yes" xml:space="preserve">
          <source>The environment given to a command.</source>
          <target state="translated">명령에 주어진 환경.</target>
        </trans-unit>
        <trans-unit id="8c97a4fcc116c7260ddba34ab30efe6d48cd3904" translate="yes" xml:space="preserve">
          <source>The environment in which Bash executes commands that are not shell builtins.</source>
          <target state="translated">Bash가 쉘 내장이 아닌 명령을 실행하는 환경.</target>
        </trans-unit>
        <trans-unit id="3d48bf4fbf249bff3c7227d31993cd69d77fc772" translate="yes" xml:space="preserve">
          <source>The evaluation is performed according to the rules listed below (see &lt;a href=&quot;shell-arithmetic#Shell-Arithmetic&quot;&gt;Shell Arithmetic&lt;/a&gt;). If the expression is invalid, Bash prints a message indicating failure to the standard error and no substitution occurs.</source>
          <target state="translated">평가는 아래 나열된 규칙에 따라 수행됩니다 ( &lt;a href=&quot;shell-arithmetic#Shell-Arithmetic&quot;&gt;쉘 산술&lt;/a&gt; 참조 ). 표현식이 유효하지 않으면 Bash는 표준 오류 실패를 나타내는 메시지를 인쇄하고 대체가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b2a3bcd8de06d432811148b511088b8c490fa8cc" translate="yes" xml:space="preserve">
          <source>The exit status is used by the Bash conditional commands (see &lt;a href=&quot;conditional-constructs#Conditional-Constructs&quot;&gt;Conditional Constructs&lt;/a&gt;) and some of the list constructs (see &lt;a href=&quot;lists#Lists&quot;&gt;Lists&lt;/a&gt;).</source>
          <target state="translated">종료 상태가 Bash는 조건 명령으로 사용된다 ( &lt;a href=&quot;conditional-constructs#Conditional-Constructs&quot;&gt;조건부 구축해를&lt;/a&gt; )하고 목록 구조의 일부 (참조 &lt;a href=&quot;lists#Lists&quot;&gt;목록을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="cde7e4cab4ce1918b0e4eaf2989a1e2a03f95939" translate="yes" xml:space="preserve">
          <source>The exit status of a function definition is zero unless a syntax error occurs or a readonly function with the same name already exists. When executed, the exit status of a function is the exit status of the last command executed in the body.</source>
          <target state="translated">구문 오류가 발생하거나 동일한 이름의 읽기 전용 함수가 이미 존재하지 않는 한 함수 정의의 종료 상태는 0입니다. 실행될 때 함수의 종료 상태는 본문에서 마지막으로 실행 된 명령의 종료 상태입니다.</target>
        </trans-unit>
        <trans-unit id="882874af5c1883e6795fc355502741713e443883" translate="yes" xml:space="preserve">
          <source>The exit status of a pipeline is the exit status of the last command in the pipeline, unless the &lt;code&gt;pipefail&lt;/code&gt; option is enabled (see &lt;a href=&quot;the-set-builtin#The-Set-Builtin&quot;&gt;The Set Builtin&lt;/a&gt;). If &lt;code&gt;pipefail&lt;/code&gt; is enabled, the pipeline&amp;rsquo;s return status is the value of the last (rightmost) command to exit with a non-zero status, or zero if all commands exit successfully. If the reserved word &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;pipefail&lt;/code&gt; 옵션이 활성화되어 있지 않으면 파이프 라인의 종료 상태는 파이프 라인에서 마지막 명령의 종료 상태입니다 ( &lt;a href=&quot;the-set-builtin#The-Set-Builtin&quot;&gt;내장 설정&lt;/a&gt; 참조 ). &lt;code&gt;pipefail&lt;/code&gt; 이 사용 가능한 경우 파이프 라인의 리턴 상태는 0이 아닌 상태로 종료하는 마지막 (가장 오른쪽) 명령의 값이거나 모든 명령이 성공적으로 종료되면 0입니다. 예약어가 '</target>
        </trans-unit>
        <trans-unit id="93521ff5f845f7a673cd2da3229c4bb2d0df9a9a" translate="yes" xml:space="preserve">
          <source>The exit status of an executed command is the value returned by the &lt;var&gt;waitpid&lt;/var&gt; system call or equivalent function. Exit statuses fall between 0 and 255, though, as explained below, the shell may use values above 125 specially. Exit statuses from shell builtins and compound commands are also limited to this range. Under certain circumstances, the shell will use special values to indicate specific failure modes.</source>
          <target state="translated">실행 된 명령의 종료 상태는 &lt;var&gt;waitpid&lt;/var&gt; 시스템 호출 또는 동등한 기능에 의해 리턴되는 값 입니다. 종료 상태는 0에서 255 사이입니다. 아래에서 설명 하듯이 쉘은 특별히 125 이상의 값을 사용할 수 있습니다. 쉘 내장 및 복합 명령의 종료 상태도이 범위로 제한됩니다. 특정 상황에서 쉘은 특정 실패 모드를 표시하기 위해 특수 값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f56e5df71600b99dbbc7e4e5772c796cf78e239d" translate="yes" xml:space="preserve">
          <source>The exit status of both of these constructs is the exit status of &lt;var&gt;list&lt;/var&gt;.</source>
          <target state="translated">이 두 구성의 종료 상태는 &lt;var&gt;list&lt;/var&gt; 의 종료 상태입니다 .</target>
        </trans-unit>
        <trans-unit id="af302677a0ba24ac769ec8978131a3baa418945c" translate="yes" xml:space="preserve">
          <source>The expanded result is single-quoted, as if the dollar sign had not been present.</source>
          <target state="translated">확장 된 결과는 달러 기호가없는 것처럼 작은 따옴표로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="4add03abbcaa883b33fdc2478513c8ec4d7883da" translate="yes" xml:space="preserve">
          <source>The expansion &lt;code&gt;${!&lt;var&gt;prefix&lt;/var&gt;*}&lt;/code&gt; expansion, which expands to the names of all shell variables whose names begin with &lt;var&gt;prefix&lt;/var&gt;, is available (see &lt;a href=&quot;shell-parameter-expansion#Shell-Parameter-Expansion&quot;&gt;Shell Parameter Expansion&lt;/a&gt;).</source>
          <target state="translated">확장 &lt;code&gt;${!&lt;var&gt;prefix&lt;/var&gt;*}&lt;/code&gt; 확장은 이름이 &lt;var&gt;prefix&lt;/var&gt; 로 시작하는 모든 쉘 변수의 이름으로 &lt;a href=&quot;shell-parameter-expansion#Shell-Parameter-Expansion&quot;&gt;확장&lt;/a&gt; 됩니다 ( 쉘 매개 변수 확장 참조 ).</target>
        </trans-unit>
        <trans-unit id="a5a18b5072df5f51be72b242a3328e3ffaff7861" translate="yes" xml:space="preserve">
          <source>The expansion &lt;code&gt;${#xx}&lt;/code&gt;, which returns the length of &lt;code&gt;${xx}&lt;/code&gt;, is supported (see &lt;a href=&quot;shell-parameter-expansion#Shell-Parameter-Expansion&quot;&gt;Shell Parameter Expansion&lt;/a&gt;).</source>
          <target state="translated">팽창 &lt;code&gt;${#xx}&lt;/code&gt; 의 길이 반환 &lt;code&gt;${xx}&lt;/code&gt; 지원된다 ( &lt;a href=&quot;shell-parameter-expansion#Shell-Parameter-Expansion&quot;&gt;쉘 매개 변수 확장을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="96f8b8e01f75d796ba1a1ef795676f19fc71a1e2" translate="yes" xml:space="preserve">
          <source>The expansion &lt;code&gt;${var/[/]&lt;/code&gt;&lt;var&gt;pattern&lt;/var&gt;&lt;code&gt;[/&lt;/code&gt;&lt;var&gt;replacement&lt;/var&gt;&lt;code&gt;]}&lt;/code&gt;, which matches &lt;var&gt;pattern&lt;/var&gt; and replaces it with &lt;var&gt;replacement&lt;/var&gt; in the value of &lt;code&gt;var&lt;/code&gt;, is available (see &lt;a href=&quot;shell-parameter-expansion#Shell-Parameter-Expansion&quot;&gt;Shell Parameter Expansion&lt;/a&gt;).</source>
          <target state="translated">팽창 &lt;code&gt;${var/[/]&lt;/code&gt; &lt;var&gt;pattern&lt;/var&gt; &lt;code&gt;[/&lt;/code&gt; &lt;var&gt;replacement&lt;/var&gt; &lt;code&gt;]}&lt;/code&gt; 일치 &lt;var&gt;pattern&lt;/var&gt; 으로 대체합니다를 &lt;var&gt;replacement&lt;/var&gt; 의 값 &lt;code&gt;var&lt;/code&gt; (참조 가능 &lt;a href=&quot;shell-parameter-expansion#Shell-Parameter-Expansion&quot;&gt;셸 파라미터 확장&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ff195a9615788b7570de20653f069dfee0752945" translate="yes" xml:space="preserve">
          <source>The expansion &lt;code&gt;${var:&lt;/code&gt;&lt;var&gt;offset&lt;/var&gt;&lt;code&gt;[:&lt;/code&gt;&lt;var&gt;length&lt;/var&gt;&lt;code&gt;]}&lt;/code&gt;, which expands to the substring of &lt;code&gt;var&lt;/code&gt;&amp;rsquo;s value of length &lt;var&gt;length&lt;/var&gt;, beginning at &lt;var&gt;offset&lt;/var&gt;, is present (see &lt;a href=&quot;shell-parameter-expansion#Shell-Parameter-Expansion&quot;&gt;Shell Parameter Expansion&lt;/a&gt;).</source>
          <target state="translated">팽창 &lt;code&gt;${var:&lt;/code&gt; &lt;var&gt;offset&lt;/var&gt; &lt;code&gt;[:&lt;/code&gt; &lt;var&gt;length&lt;/var&gt; &lt;code&gt;]}&lt;/code&gt; 의 문자열로 확장 &lt;code&gt;var&lt;/code&gt; 길이의 값의 &lt;var&gt;length&lt;/var&gt; 에서 시작 &lt;var&gt;offset&lt;/var&gt; (참조 존재 &lt;a href=&quot;shell-parameter-expansion#Shell-Parameter-Expansion&quot;&gt;셸 파라미터 확장&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c42697b02e8d21ef0011f21334b20db388215922" translate="yes" xml:space="preserve">
          <source>The expansion is a string consisting of flag values representing &lt;var&gt;parameter&lt;/var&gt;&amp;rsquo;s attributes.</source>
          <target state="translated">확장은 &lt;var&gt;parameter&lt;/var&gt; 의 속성을 나타내는 플래그 값으로 구성된 문자열 입니다.</target>
        </trans-unit>
        <trans-unit id="afab0e853d9367c4e25802117ca6694fb42e958d" translate="yes" xml:space="preserve">
          <source>The expansion is a string in the form of an assignment statement or &lt;code&gt;declare&lt;/code&gt; command that, if evaluated, will recreate &lt;var&gt;parameter&lt;/var&gt; with its attributes and value.</source>
          <target state="translated">확장은 평가의 경우 속성 및 값을 사용하여 &lt;var&gt;parameter&lt;/var&gt; 를 다시 작성 하는 지정 문 또는 &lt;code&gt;declare&lt;/code&gt; 명령 양식의 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="d6be86a3848bcf91893ed7d3309235866c74397b" translate="yes" xml:space="preserve">
          <source>The expansion is a string that is the result of expanding the value of &lt;var&gt;parameter&lt;/var&gt; as if it were a prompt string (see &lt;a href=&quot;controlling-the-prompt#Controlling-the-Prompt&quot;&gt;Controlling the Prompt&lt;/a&gt;).</source>
          <target state="translated">확장은 &lt;var&gt;parameter&lt;/var&gt; 값을 프롬프트 문자열 인 것처럼 확장 한 결과 인 문자열입니다 ( &lt;a href=&quot;controlling-the-prompt#Controlling-the-Prompt&quot;&gt;프롬프트 제어&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="718e5782e0ebb46109a132b8422a56fd0c862fe8" translate="yes" xml:space="preserve">
          <source>The expansion is a string that is the value of &lt;var&gt;parameter&lt;/var&gt; quoted in a format that can be reused as input.</source>
          <target state="translated">확장은 입력으로 재사용 할 수있는 형식으로 인용 된 &lt;var&gt;parameter&lt;/var&gt; 의 값인 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="49011b37d553b27a53f468c55ddd26aef836c36e" translate="yes" xml:space="preserve">
          <source>The expansion is a string that is the value of &lt;var&gt;parameter&lt;/var&gt; with backslash escape sequences expanded as with the &lt;code&gt;$'&amp;hellip;'&lt;/code&gt; quoting mechanism.</source>
          <target state="translated">확장은 &lt;code&gt;$'&amp;hellip;'&lt;/code&gt; 인용 메커니즘 과 같이 확장 된 백 슬래시 이스케이프 시퀀스 가있는 &lt;var&gt;parameter&lt;/var&gt; 의 값인 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="89719bd636e28ecb9ebeb938ed5ebd39231ef58f" translate="yes" xml:space="preserve">
          <source>The expansion is either a transformation of the value of &lt;var&gt;parameter&lt;/var&gt; or information about &lt;var&gt;parameter&lt;/var&gt; itself, depending on the value of &lt;var&gt;operator&lt;/var&gt;. Each &lt;var&gt;operator&lt;/var&gt; is a single letter:</source>
          <target state="translated">확장은 &lt;var&gt;operator&lt;/var&gt; 값에 따라 &lt;var&gt;parameter&lt;/var&gt; &lt;var&gt;parameter&lt;/var&gt; 값의 변환 이거나 매개 변수 자체 에 대한 정보 입니다. 각 &lt;var&gt;operator&lt;/var&gt; 는 단일 문자입니다.</target>
        </trans-unit>
        <trans-unit id="df069b9637dead763765488d713656a0c16cb85d" translate="yes" xml:space="preserve">
          <source>The expression is false.</source>
          <target state="translated">표현이 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="917a28ba64b958eccd04b25a0853ab60f14fd25a" translate="yes" xml:space="preserve">
          <source>The expression is parsed and evaluated according to precedence using the rules listed above.</source>
          <target state="translated">위에 나열된 규칙을 사용하여 우선 순위에 따라 표현식을 구문 분석하고 평가합니다.</target>
        </trans-unit>
        <trans-unit id="765283e36a1fd1dbb9b7969584d0849fec8d65c2" translate="yes" xml:space="preserve">
          <source>The expression is treated as if it were within double quotes, but a double quote inside the parentheses is not treated specially. All tokens in the expression undergo parameter and variable expansion, command substitution, and quote removal. The result is treated as the arithmetic expression to be evaluated. Arithmetic expansions may be nested.</source>
          <target state="translated">표현식은 큰 따옴표 안에있는 것처럼 처리되지만 괄호 안의 큰 따옴표는 특별히 처리되지 않습니다. 표현식의 모든 토큰에는 매개 변수 및 변수 확장, 명령 대체 및 따옴표 제거가 적용됩니다. 결과는 평가할 산술 식으로 취급됩니다. 산술 확장이 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5648f53f152d5e29fc3812849ec1b8d658e77938" translate="yes" xml:space="preserve">
          <source>The expression is true if, and only if, the argument is not null.</source>
          <target state="translated">인수가 널이 아닌 경우에만 표현식이 참입니다.</target>
        </trans-unit>
        <trans-unit id="04fbc7508d5d457aedc840547581d13fb785d13c" translate="yes" xml:space="preserve">
          <source>The file</source>
          <target state="translated">파일</target>
        </trans-unit>
        <trans-unit id="5a1f23a6e05b417744f95f7b69c2d488fda88b55" translate="yes" xml:space="preserve">
          <source>The filename expansion bracket expression code uses &amp;lsquo;</source>
          <target state="translated">파일 이름 확장 괄호 표현식 코드는 '</target>
        </trans-unit>
        <trans-unit id="aaacebebc80f60660c7ad0d231556561a01ad1ae" translate="yes" xml:space="preserve">
          <source>The filename expansion pattern &lt;var&gt;globpat&lt;/var&gt; is expanded to generate the possible completions.</source>
          <target state="translated">파일 이름 확장 패턴 &lt;var&gt;globpat&lt;/var&gt; 가 확장되어 가능한 완성을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5edef30a2af12324677eae56bf83124a0130e459" translate="yes" xml:space="preserve">
          <source>The first argument; that is, word 1.</source>
          <target state="translated">첫 번째 주장; 즉, 단어 1입니다.</target>
        </trans-unit>
        <trans-unit id="9b8dec4b71ba6807789b61a734fa23b8fd78022f" translate="yes" xml:space="preserve">
          <source>The first character of &lt;var&gt;delim&lt;/var&gt; is used to terminate each input line, rather than newline. If &lt;var&gt;delim&lt;/var&gt; is the empty string, &lt;code&gt;mapfile&lt;/code&gt; will terminate a line when it reads a NUL character.</source>
          <target state="translated">&lt;var&gt;delim&lt;/var&gt; 의 첫 문자는 개행 문자가 아닌 각 입력 행을 종료하는 데 사용됩니다. 경우 &lt;var&gt;delim&lt;/var&gt; 빈 문자열이며, &lt;code&gt;mapfile&lt;/code&gt; 그것이 NUL 문자를 읽을 때 줄을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="05fedeb99a9947ee2d22eae659bc2114dd328c91" translate="yes" xml:space="preserve">
          <source>The first character of &lt;var&gt;delim&lt;/var&gt; is used to terminate the input line, rather than newline. If &lt;var&gt;delim&lt;/var&gt; is the empty string, &lt;code&gt;read&lt;/code&gt; will terminate a line when it reads a NUL character.</source>
          <target state="translated">&lt;var&gt;delim&lt;/var&gt; 의 첫 문자는 개행 문자가 아닌 입력 행을 종료하는 데 사용됩니다. 경우 &lt;var&gt;delim&lt;/var&gt; 빈 문자열이며, &lt;code&gt;read&lt;/code&gt; 그것은 NUL 문자를 읽을 때 줄을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="5acdf0f4c865ba4046fb45d377dc9d2cfc30f085" translate="yes" xml:space="preserve">
          <source>The first form lists the active jobs. The options have the following meanings:</source>
          <target state="translated">첫 번째 양식에는 활성 작업이 나열되어 있습니다. 옵션의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c070d0f8863df81437dc35015ed66e6c8a423b39" translate="yes" xml:space="preserve">
          <source>The first form selects a range of commands from &lt;var&gt;first&lt;/var&gt; to &lt;var&gt;last&lt;/var&gt; from the history list and displays or edits and re-executes them. Both &lt;var&gt;first&lt;/var&gt; and &lt;var&gt;last&lt;/var&gt; may be specified as a string (to locate the most recent command beginning with that string) or as a number (an index into the history list, where a negative number is used as an offset from the current command number). If &lt;var&gt;last&lt;/var&gt; is not specified, it is set to &lt;var&gt;first&lt;/var&gt;. If &lt;var&gt;first&lt;/var&gt; is not specified, it is set to the previous command for editing and -16 for listing. If the</source>
          <target state="translated">첫 번째 양식 은 히스토리 목록 에서 &lt;var&gt;first&lt;/var&gt; 부터 &lt;var&gt;last&lt;/var&gt; 까지 의 명령 범위를 선택하고 명령을 표시 또는 편집하고 다시 실행합니다. &lt;var&gt;first&lt;/var&gt; 와 &lt;var&gt;last&lt;/var&gt; 는 모두 문자열 (해당 문자열로 시작하는 가장 최근의 명령을 찾기 위해) 또는 숫자 (히스토리 목록의 색인으로 지정 될 수 있으며 음수는 현재 명령 번호의 오프셋으로 사용됨)로 지정할 수 있습니다. 경우 &lt;var&gt;last&lt;/var&gt; 지정되지 않은, 그것은으로 설정되어 &lt;var&gt;first&lt;/var&gt; . 경우 &lt;var&gt;first&lt;/var&gt; 지정되지 않은, 그것은 목록에 대한 편집 및 -16에 대한 이전 명령으로 설정됩니다. 만약</target>
        </trans-unit>
        <trans-unit id="c8c2e770fa8a575b94054f403e628e1a41d9b2d7" translate="yes" xml:space="preserve">
          <source>The first two matches will succeed, but the second two will not, because in the second two the backslash will be part of the pattern to be matched. In the first two examples, the backslash removes the special meaning from &amp;lsquo;</source>
          <target state="translated">첫 번째 두 경기는 성공하지만 두 번째 경기는 성공하지 못합니다. 두 번째 경기에서는 백 슬래시가 일치시킬 패턴의 일부이기 때문입니다. 처음 두 예제에서 백 슬래시는 '에서 특별한 의미를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="653797fdb45594c050bc255e0eccba33ff16f76d" translate="yes" xml:space="preserve">
          <source>The first word of each simple command, if unquoted, is checked to see if it has an alias. If so, that word is replaced by the text of the alias. The characters &amp;lsquo;</source>
          <target state="translated">인용되지 않은 경우 각 간단한 명령의 첫 단어는 별칭이 있는지 확인합니다. 그렇다면 해당 단어가 별칭의 텍스트로 바뀝니다. 문자 '</target>
        </trans-unit>
        <trans-unit id="f05f3215d7b20148c8c62f31469f98550a932678" translate="yes" xml:space="preserve">
          <source>The following &lt;small&gt;GNU&lt;/small&gt; Emacs style escape sequences are available when specifying key sequences:</source>
          <target state="translated">키 시퀀스를 지정할 때 다음 &lt;small&gt;GNU&lt;/small&gt; Emacs 스타일 이스케이프 시퀀스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24ddb0f7f45aa8e7da0193822322df7608a8a1de" translate="yes" xml:space="preserve">
          <source>The following conditions are applied in the order listed.</source>
          <target state="translated">다음 조건은 나열된 순서대로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="19be275d9d4da579c940b470f6bd0e28acdc4d18" translate="yes" xml:space="preserve">
          <source>The following examples illustrate substring expansion using positional parameters:</source>
          <target state="translated">다음 예제는 위치 매개 변수를 사용한 부분 문자열 확장을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="3264a3c2fce96954f61e856f6cb6a203854296df" translate="yes" xml:space="preserve">
          <source>The following function provides completions for the &lt;code&gt;cd&lt;/code&gt; builtin. It is a reasonably good example of what shell functions must do when used for completion. This function uses the word passed as &lt;code&gt;$2&lt;/code&gt; to determine the directory name to complete. You can also use the &lt;code&gt;COMP_WORDS&lt;/code&gt; array variable; the current word is indexed by the &lt;code&gt;COMP_CWORD&lt;/code&gt; variable.</source>
          <target state="translated">다음 기능은 &lt;code&gt;cd&lt;/code&gt; 내장에 대한 완성 기능을 제공합니다 . 완성에 사용될 때 쉘 기능이 수행해야하는 작업에 대한 합리적으로 좋은 예입니다. 이 함수는 &lt;code&gt;$2&lt;/code&gt; 로 전달 된 단어를 사용하여 완료 할 디렉토리 이름을 결정합니다. &lt;code&gt;COMP_WORDS&lt;/code&gt; 배열 변수를 사용할 수도 있습니다 . 현재 단어는 &lt;code&gt;COMP_CWORD&lt;/code&gt; 변수에 의해 색인됩니다 .</target>
        </trans-unit>
        <trans-unit id="1973674b141605d49022a34798172dc015ebae3d" translate="yes" xml:space="preserve">
          <source>The following is a brief description of the shell&amp;rsquo;s operation when it reads and executes a command. Basically, the shell does the following:</source>
          <target state="translated">다음은 명령을 읽고 실행할 때 쉘의 작동에 대한 간략한 설명입니다. 기본적으로 쉘은 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e6e56424b5edaef5f8b22992ca94c1e28fccfbfb" translate="yes" xml:space="preserve">
          <source>The following list is what&amp;rsquo;s changed when &amp;lsquo;&lt;small&gt;POSIX&lt;/small&gt; mode&amp;rsquo; is in effect:</source>
          <target state="translated">다음 목록은 ' &lt;small&gt;POSIX&lt;/small&gt; 모드'가 &lt;small&gt;적용될&lt;/small&gt; 때 변경된 내용입니다 .</target>
        </trans-unit>
        <trans-unit id="eb0c3b0e34e323551707bf5e0633877075c8b092" translate="yes" xml:space="preserve">
          <source>The following options can be used to restrict output to variables with the specified attributes or to give variables attributes:</source>
          <target state="translated">다음 옵션을 사용하여 출력을 지정된 속성을 가진 변수로 제한하거나 변수 속성을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e475c1ef3ba8861c03c9c0474a01c3785e4b8b69" translate="yes" xml:space="preserve">
          <source>The following paragraphs describe the notation used to represent keystrokes.</source>
          <target state="translated">다음 단락은 키 입력을 나타내는 데 사용되는 표기법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="cf56dd8b6034696a2255946a3c1711fd0c0fdad5" translate="yes" xml:space="preserve">
          <source>The following script demonstrates this behavior. When executed, the script displays</source>
          <target state="translated">다음 스크립트는이 동작을 보여줍니다. 실행되면 스크립트가 표시됩니다</target>
        </trans-unit>
        <trans-unit id="40fac25ff0d0f9207380149b6506832e8dd34742" translate="yes" xml:space="preserve">
          <source>The following shell builtin commands are inherited from the Bourne Shell. These commands are implemented as specified by the &lt;small&gt;POSIX&lt;/small&gt; standard.</source>
          <target state="translated">다음 쉘 내장 명령은 Bourne 쉘에서 상속됩니다. 이러한 명령은 &lt;small&gt;POSIX&lt;/small&gt; 표준에 지정된대로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="afe6bd1402238d50ca5f09a2bbfeddb70b66dbf0" translate="yes" xml:space="preserve">
          <source>The following table shows how Bash treats unquoted tilde-prefixes:</source>
          <target state="translated">다음 표는 Bash가 인용되지 않은 물결표 접두사를 처리하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="824f8c58a50e27f3e689bc87d7807d7e4b1386ae" translate="yes" xml:space="preserve">
          <source>The format for a coprocess is:</source>
          <target state="translated">코 프로세스의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="008bd0975bad329b905e1c1101a0523476226ee8" translate="yes" xml:space="preserve">
          <source>The format for a pipeline is</source>
          <target state="translated">파이프 라인의 형식은</target>
        </trans-unit>
        <trans-unit id="02b3a48c9b9344fc8d6b2324781aac0f808840e9" translate="yes" xml:space="preserve">
          <source>The format for appending standard output and standard error is:</source>
          <target state="translated">표준 출력 및 표준 오류를 추가하는 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7d5ed4051a7f541831398ffdbf9b3784483cda4e" translate="yes" xml:space="preserve">
          <source>The format of here-documents is:</source>
          <target state="translated">여기 문서의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8888845c75667610ca68745649c9bc19049d0a19" translate="yes" xml:space="preserve">
          <source>The full pathname to the shell is kept in this environment variable. If it is not set when the shell starts, Bash assigns to it the full pathname of the current user&amp;rsquo;s login shell.</source>
          <target state="translated">쉘의 전체 경로 이름은이 환경 변수에 유지됩니다. 쉘이 시작될 때 설정되지 않으면 Bash는 현재 사용자 로그인 쉘의 전체 경로 이름을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="75aae69f918b3c92e6508a81e7d55526d6fc838f" translate="yes" xml:space="preserve">
          <source>The full pathname used to execute the current instance of Bash.</source>
          <target state="translated">Bash의 현재 인스턴스를 실행하는 데 사용되는 전체 경로 이름입니다.</target>
        </trans-unit>
        <trans-unit id="e3f587f0d4243df9d4928e7ce1617551920b7c10" translate="yes" xml:space="preserve">
          <source>The function relies on the &lt;code&gt;complete&lt;/code&gt; and &lt;code&gt;compgen&lt;/code&gt; builtins to do much of the work, adding only the things that the Bash &lt;code&gt;cd&lt;/code&gt; does beyond accepting basic directory names: tilde expansion (see &lt;a href=&quot;tilde-expansion#Tilde-Expansion&quot;&gt;Tilde Expansion&lt;/a&gt;), searching directories in &lt;var&gt;$CDPATH&lt;/var&gt;, which is described above (see &lt;a href=&quot;bourne-shell-builtins#Bourne-Shell-Builtins&quot;&gt;Bourne Shell Builtins&lt;/a&gt;), and basic support for the &lt;code&gt;cdable_vars&lt;/code&gt; shell option (see &lt;a href=&quot;the-shopt-builtin#The-Shopt-Builtin&quot;&gt;The Shopt Builtin&lt;/a&gt;). &lt;code&gt;_comp_cd&lt;/code&gt; modifies the value of &lt;var&gt;IFS&lt;/var&gt; so that it contains only a newline to accommodate file names containing spaces and tabs &amp;ndash; &lt;code&gt;compgen&lt;/code&gt; prints the possible completions it generates one per line.</source>
          <target state="translated">이 기능은에 의존 &lt;code&gt;complete&lt;/code&gt; 하고 &lt;code&gt;compgen&lt;/code&gt; 배쉬 만 일 추가, 대부분의 작업을 수행하는 내장 명령 &lt;code&gt;cd&lt;/code&gt; 기본 디렉토리 이름 받아들이 이상을 수행합니다 틸드 확장 (참조 &lt;a href=&quot;tilde-expansion#Tilde-Expansion&quot;&gt;물결표 확장을&lt;/a&gt; 에서 디렉토리를 검색) &lt;var&gt;$CDPATH&lt;/var&gt; 위의 설명, ( &lt;a href=&quot;bourne-shell-builtins#Bourne-Shell-Builtins&quot;&gt;Bourne Shell Builtins&lt;/a&gt; 참조 ) 및 &lt;code&gt;cdable_vars&lt;/code&gt; 쉘 옵션에 대한 기본 지원 ( &lt;a href=&quot;the-shopt-builtin#The-Shopt-Builtin&quot;&gt;Shopt Builtin&lt;/a&gt; 참조 ). &lt;code&gt;_comp_cd&lt;/code&gt; 는 공백과 탭을 포함하는 파일 이름을 수용하기 위해 줄 바꾸기 만 포함하도록 &lt;var&gt;IFS&lt;/var&gt; 의 값을 수정합니다. &lt;code&gt;compgen&lt;/code&gt; 은 줄당 하나씩 생성 할 수있는 완료를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="13611c4c0ecb29cf7f14a3ed944a012d009ef2c3" translate="yes" xml:space="preserve">
          <source>The general format for appending output is:</source>
          <target state="translated">출력을 추가하는 일반적인 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ffa6a9428796413da955f4cd2a055baf37da0878" translate="yes" xml:space="preserve">
          <source>The general format for redirecting input is:</source>
          <target state="translated">입력 리디렉션의 일반적인 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c61d67487ed929fce6191ab3f2cecff60115cb2b" translate="yes" xml:space="preserve">
          <source>The general format for redirecting output is:</source>
          <target state="translated">출력 리디렉션의 일반적인 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a47fc4b4c39ae1e37cb5da5d7d7220e4cd957885" translate="yes" xml:space="preserve">
          <source>The general way to pass numeric arguments to a command is to type meta digits before the command. If the first &amp;lsquo;digit&amp;rsquo; typed is a minus sign (&amp;lsquo;</source>
          <target state="translated">숫자 인수를 명령에 전달하는 일반적인 방법은 명령 앞에 메타 숫자를 입력하는 것입니다. 입력 한 첫 번째 '숫자'가 빼기 부호 ( '</target>
        </trans-unit>
        <trans-unit id="b782a125111561adab68b848b80ff8b06af5cdea" translate="yes" xml:space="preserve">
          <source>The hardware and operating system.</source>
          <target state="translated">하드웨어 및 운영 체제</target>
        </trans-unit>
        <trans-unit id="e9ed18f3234de7da5850c7fe21e8086c2e69760a" translate="yes" xml:space="preserve">
          <source>The history number of this command.</source>
          <target state="translated">이 명령의 히스토리 번호.</target>
        </trans-unit>
        <trans-unit id="a65ee602f62d7df3888e4f9382eab7dbcb1dafb7" translate="yes" xml:space="preserve">
          <source>The history number, or index in the history list, of the current command. If &lt;code&gt;HISTCMD&lt;/code&gt; is unset, it loses its special properties, even if it is subsequently reset.</source>
          <target state="translated">현재 명령의 기록 번호 또는 기록 목록의 색인. 경우 &lt;code&gt;HISTCMD&lt;/code&gt; 가 설정되지, 그것은 나중에 다시 경우에도 특별한 속성을 잃게된다.</target>
        </trans-unit>
        <trans-unit id="13a95f3a85c30ffe4471233d330866926e2d5a35" translate="yes" xml:space="preserve">
          <source>The hostname, up to the first &amp;lsquo;.&amp;rsquo;.</source>
          <target state="translated">첫 번째 '.'까지의 호스트 이름입니다.</target>
        </trans-unit>
        <trans-unit id="7c751fdbb38c77c9e0a00c4631f7273f61e129b7" translate="yes" xml:space="preserve">
          <source>The hostname.</source>
          <target state="translated">호스트 이름</target>
        </trans-unit>
        <trans-unit id="f6db584b78ec2e82b3cad14450e10249038b0f5c" translate="yes" xml:space="preserve">
          <source>The index of the current cursor position relative to the beginning of the current command. If the current cursor position is at the end of the current command, the value of this variable is equal to &lt;code&gt;${#COMP_LINE}&lt;/code&gt;. This variable is available only in shell functions and external commands invoked by the programmable completion facilities (see &lt;a href=&quot;programmable-completion#Programmable-Completion&quot;&gt;Programmable Completion&lt;/a&gt;).</source>
          <target state="translated">현재 명령의 시작을 기준으로 현재 커서 위치의 인덱스입니다. 현재 커서 위치가 현재 명령의 끝에있는 경우이 변수의 값은 &lt;code&gt;${#COMP_LINE}&lt;/code&gt; 과 같습니다 . 이 변수는 프로그램 가능 완료 기능에 의해 호출 된 쉘 기능 및 외부 명령에서만 사용 가능합니다 ( &lt;a href=&quot;programmable-completion#Programmable-Completion&quot;&gt;프로그램 가능 완료&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="473130ec203865ee4c843e203a83ba055936c269" translate="yes" xml:space="preserve">
          <source>The index of the last option argument processed by the &lt;code&gt;getopts&lt;/code&gt; builtin.</source>
          <target state="translated">&lt;code&gt;getopts&lt;/code&gt; 내장에서 처리 한 마지막 옵션 인수의 색인입니다 .</target>
        </trans-unit>
        <trans-unit id="1f2f60edca49496dae0d28870137a50af5de6b5a" translate="yes" xml:space="preserve">
          <source>The key (or final key of a key sequence) used to invoke the current completion function.</source>
          <target state="translated">현재 완료 기능을 호출하는 데 사용되는 키 (또는 키 시퀀스의 최종 키)입니다.</target>
        </trans-unit>
        <trans-unit id="686f59b319a273c3ab44e2c15cbea72c6654a855" translate="yes" xml:space="preserve">
          <source>The last argument.</source>
          <target state="translated">마지막 논쟁.</target>
        </trans-unit>
        <trans-unit id="f15a79a13792b2daaecff6a8e0207b36bfaaae0e" translate="yes" xml:space="preserve">
          <source>The least you need to know about Readline.</source>
          <target state="translated">최소한 Readline에 대해 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="479bc0213f8e2c9635f1484f22020efc023ed13a" translate="yes" xml:space="preserve">
          <source>The length in characters of the common prefix of a list of possible completions that is displayed without modification. When set to a value greater than zero, common prefixes longer than this value are replaced with an ellipsis when displaying possible completions.</source>
          <target state="translated">수정없이 표시되는 가능한 완료 목록의 공통 접 두부의 문자 길이입니다. 0보다 큰 값으로 설정하면 가능한 값을 표시 할 때이 값보다 긴 공통 접두사가 줄임표로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="17ae5c6e81e59d0e2b66f91f9368d1f88f1eb5c5" translate="yes" xml:space="preserve">
          <source>The length in characters of the expanded value of &lt;var&gt;parameter&lt;/var&gt; is substituted. If &lt;var&gt;parameter&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">확장 된 &lt;var&gt;parameter&lt;/var&gt; 값의 문자 길이 가 대체됩니다. 만약 &lt;var&gt;parameter&lt;/var&gt; '입니다</target>
        </trans-unit>
        <trans-unit id="eb11c557d4404e21d134d7ea32d161578e702837" translate="yes" xml:space="preserve">
          <source>The line number in the script or shell function currently executing.</source>
          <target state="translated">현재 실행중인 스크립트 또는 셸 함수의 줄 번호입니다.</target>
        </trans-unit>
        <trans-unit id="61cd279aec85f8f1f1b7130c687f985f6fa6efe6" translate="yes" xml:space="preserve">
          <source>The list of &lt;code&gt;shopt&lt;/code&gt; options is:</source>
          <target state="translated">&lt;code&gt;shopt&lt;/code&gt; 옵션 목록 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="65320a04aac95e184bf875acc72fa1b7f9897605" translate="yes" xml:space="preserve">
          <source>The list of expansions that would have been generated by &lt;code&gt;glob-expand-word&lt;/code&gt; is displayed, and the line is redrawn. If a numeric argument is supplied, a &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;glob-expand-word&lt;/code&gt; 로 생성 된 확장 목록 이 표시되고 선이 다시 그려집니다. 숫자 인수가 제공되면 '</target>
        </trans-unit>
        <trans-unit id="2019a589f4c2bf28aba032c82e704730984150cd" translate="yes" xml:space="preserve">
          <source>The list of words following &lt;code&gt;in&lt;/code&gt; is expanded, generating a list of items. The set of expanded words is printed on the standard error output stream, each preceded by a number. If the &amp;lsquo;</source>
          <target state="translated">다음 &lt;code&gt;in&lt;/code&gt; 나오는 단어 목록 이 확장되어 항목 목록이 생성됩니다. 확장 된 단어 세트는 표준 오류 출력 스트림에 인쇄되며 각각 앞에 숫자가 붙습니다. '</target>
        </trans-unit>
        <trans-unit id="aa39d9bca29b56b174fa694ebf1be4f907420565" translate="yes" xml:space="preserve">
          <source>The major version number (the &lt;var&gt;release&lt;/var&gt;).</source>
          <target state="translated">메이저 버젼 번호 ( &lt;var&gt;release&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="ad629efae3b908eab3fc335f7c6b1514e76455a0" translate="yes" xml:space="preserve">
          <source>The matches will be generated in the same way as if the programmable completion code had generated them directly from a completion specification with the same flags. If &lt;var&gt;word&lt;/var&gt; is specified, only those completions matching &lt;var&gt;word&lt;/var&gt; will be displayed.</source>
          <target state="translated">프로그램 가능 완료 코드가 동일한 플래그를 사용하여 완료 스펙에서 직접 생성 한 것과 동일한 방식으로 일치가 생성됩니다. 경우 &lt;var&gt;word&lt;/var&gt; 지정되고, 일치 만 완료 &lt;var&gt;word&lt;/var&gt; 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7a37f69e87b146cfcdc4f0321e25da8ec8def7a7" translate="yes" xml:space="preserve">
          <source>The maximum amount of cpu time in seconds.</source>
          <target state="translated">최대 CPU 시간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="bc5acea89c45f6c1a1ee8563532e340fc0af5dff" translate="yes" xml:space="preserve">
          <source>The maximum amount of virtual memory available to the shell, and, on some systems, to its children.</source>
          <target state="translated">셸 및 일부 시스템에서 사용 가능한 최대 가상 메모리 양입니다.</target>
        </trans-unit>
        <trans-unit id="e612ee42927bf27d5122f8658f402d131625097b" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes in POSIX message queues.</source>
          <target state="translated">POSIX 메시지 큐의 최대 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="60e2e72c62b84d4520681d3312ecc71d64ac18c1" translate="yes" xml:space="preserve">
          <source>The maximum number of commands to remember on the history list. If the value is 0, commands are not saved in the history list. Numeric values less than zero result in every command being saved on the history list (there is no limit). The shell sets the default value to 500 after reading any startup files.</source>
          <target state="translated">히스토리 목록에서 기억할 최대 명령 수입니다. 값이 0이면 명령이 기록 목록에 저장되지 않습니다. 0보다 작은 숫자 값은 모든 명령이 기록 목록에 저장됩니다 (제한 없음). 셸은 시작 파일을 읽은 후 기본값을 500으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="eccb1f861be87bad932c6e08746f3c0f3321d602" translate="yes" xml:space="preserve">
          <source>The maximum number of file locks.</source>
          <target state="translated">최대 파일 잠금 수</target>
        </trans-unit>
        <trans-unit id="49d2af9b6317e720f9864618927f092d866ec43a" translate="yes" xml:space="preserve">
          <source>The maximum number of kqueues that may be allocated.</source>
          <target state="translated">할당 될 수있는 최대 큐 수입니다.</target>
        </trans-unit>
        <trans-unit id="89e64b1e3b19576f52f300b05c74d81f04a457d5" translate="yes" xml:space="preserve">
          <source>The maximum number of lines contained in the history file. When this variable is assigned a value, the history file is truncated, if necessary, to contain no more than that number of lines by removing the oldest entries. The history file is also truncated to this size after writing it when a shell exits. If the value is 0, the history file is truncated to zero size. Non-numeric values and numeric values less than zero inhibit truncation. The shell sets the default value to the value of &lt;code&gt;HISTSIZE&lt;/code&gt; after reading any startup files.</source>
          <target state="translated">히스토리 파일에 포함 된 최대 행 수입니다. 이 변수에 값이 지정되면, 가장 오래된 항목을 제거하여 히스토리 파일이 필요한 경우 잘려서 해당 행 수를 포함하지 않습니다. 쉘이 종료 될 때 기록 파일도이 크기로 잘립니다. 값이 0이면 히스토리 파일이 0으로 잘립니다. 숫자가 아닌 값과 0보다 작은 숫자 값은 잘림을 금지합니다. 쉘은 시작 파일을 읽은 후 기본값을 &lt;code&gt;HISTSIZE&lt;/code&gt; 값으로 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="2c3213f5627b1c2c18181db54a40fc7d44020c89" translate="yes" xml:space="preserve">
          <source>The maximum number of open file descriptors (most systems do not allow this value to be set).</source>
          <target state="translated">열린 파일 디스크립터의 최대 수입니다 (대부분의 시스템에서는이 값을 설정할 수 없습니다).</target>
        </trans-unit>
        <trans-unit id="6f3371a6b70457453e618d4aa234c6805eb07e71" translate="yes" xml:space="preserve">
          <source>The maximum number of pending signals.</source>
          <target state="translated">보류중인 최대 신호 수입니다.</target>
        </trans-unit>
        <trans-unit id="cb06ca1269dc6deb79b3d3dd22e2cf6959660122" translate="yes" xml:space="preserve">
          <source>The maximum number of processes available to a single user.</source>
          <target state="translated">단일 사용자가 사용할 수있는 최대 프로세스 수입니다.</target>
        </trans-unit>
        <trans-unit id="021bd63455221bb20e66653acd17297499bc8ef3" translate="yes" xml:space="preserve">
          <source>The maximum number of pseudoterminals.</source>
          <target state="translated">최대 의사 터미널 수입니다.</target>
        </trans-unit>
        <trans-unit id="491d1e5adda3b14899bb2173f42ad3472a20aeea" translate="yes" xml:space="preserve">
          <source>The maximum number of threads.</source>
          <target state="translated">최대 스레드 수입니다.</target>
        </trans-unit>
        <trans-unit id="f8ba3c38db08c2bd096841949b0d0265a592bf92" translate="yes" xml:space="preserve">
          <source>The maximum real-time scheduling priority.</source>
          <target state="translated">최대 실시간 예약 우선 순위.</target>
        </trans-unit>
        <trans-unit id="b64acd82e9522cf0d0f4eee81f4c41b783ba89de" translate="yes" xml:space="preserve">
          <source>The maximum resident set size (many systems do not honor this limit).</source>
          <target state="translated">최대 상주 세트 크기 (많은 시스템은이 한계를 따르지 않습니다).</target>
        </trans-unit>
        <trans-unit id="0da354b3da817bda1f8e533def312ff9c1eb8fac" translate="yes" xml:space="preserve">
          <source>The maximum scheduling priority (&quot;nice&quot;).</source>
          <target state="translated">최대 예약 우선 순위 ( &quot;nice&quot;).</target>
        </trans-unit>
        <trans-unit id="271ec27888b79c99e459f384254c3c0335d491b9" translate="yes" xml:space="preserve">
          <source>The maximum size of a process&amp;rsquo;s data segment.</source>
          <target state="translated">프로세스 데이터 세그먼트의 최대 크기</target>
        </trans-unit>
        <trans-unit id="2e56b4fe4f74677d789c73cbaaeb3c1edfc5fd45" translate="yes" xml:space="preserve">
          <source>The maximum size of core files created.</source>
          <target state="translated">작성된 코어 파일의 최대 크기입니다.</target>
        </trans-unit>
        <trans-unit id="5ce142917de9109aacebbfe4f26e2b49432d0d54" translate="yes" xml:space="preserve">
          <source>The maximum size of files written by the shell and its children.</source>
          <target state="translated">쉘과 그 자식이 쓴 파일의 최대 크기.</target>
        </trans-unit>
        <trans-unit id="be670a1e4867c1cdff3b42c75d7c1065b739dc5f" translate="yes" xml:space="preserve">
          <source>The maximum size that may be locked into memory.</source>
          <target state="translated">메모리에 잠겨있을 수있는 최대 크기입니다.</target>
        </trans-unit>
        <trans-unit id="660d7cf7ea5978addf0941e67e0af36d68983daa" translate="yes" xml:space="preserve">
          <source>The maximum socket buffer size.</source>
          <target state="translated">최대 소켓 버퍼 크기입니다.</target>
        </trans-unit>
        <trans-unit id="16647a836b2f81787f8dcff2ae1a4fe51ee726d8" translate="yes" xml:space="preserve">
          <source>The maximum stack size.</source>
          <target state="translated">최대 스택 크기입니다.</target>
        </trans-unit>
        <trans-unit id="8a867609caa0696ab2352f776f8abdb45b60a63e" translate="yes" xml:space="preserve">
          <source>The message printed by the job control code and builtins when a job exits with a non-zero status is &amp;lsquo;Done(status)&amp;rsquo;.</source>
          <target state="translated">작업이 0이 아닌 상태로 종료 될 때 작업 제어 코드 및 내장으로 인쇄되는 메시지는 '완료 (상태)'입니다.</target>
        </trans-unit>
        <trans-unit id="71dc135bf9c56dc46672123474c6b426e1cdd315" translate="yes" xml:space="preserve">
          <source>The message printed by the job control code and builtins when a job is stopped is &amp;lsquo;Stopped(&lt;var&gt;signame&lt;/var&gt;)&amp;rsquo;, where &lt;var&gt;signame&lt;/var&gt; is, for example, &lt;code&gt;SIGTSTP&lt;/code&gt;.</source>
          <target state="translated">작업이 중지 될 때 작업 제어 코드 및 내장으로 인쇄 된 메시지는 'Stopped ( &lt;var&gt;signame&lt;/var&gt; )'입니다. 여기서 &lt;var&gt;signame&lt;/var&gt; 은 &lt;code&gt;SIGTSTP&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0536298fd15b9d1ff52d797ef8c0e31c2062bfa1" translate="yes" xml:space="preserve">
          <source>The minimum set of commands for editing a line.</source>
          <target state="translated">라인을 편집하기위한 최소 명령 세트.</target>
        </trans-unit>
        <trans-unit id="acfc35388c1d2def9ecf3524b014ac228ea40342" translate="yes" xml:space="preserve">
          <source>The minor version number (the &lt;var&gt;version&lt;/var&gt;).</source>
          <target state="translated">부 버전 번호 ( &lt;var&gt;version&lt;/var&gt; ).</target>
        </trans-unit>
        <trans-unit id="6783142c35942058e1c609e274cfc80a41e75089" translate="yes" xml:space="preserve">
          <source>The most common type of command.</source>
          <target state="translated">가장 일반적인 유형의 명령입니다.</target>
        </trans-unit>
        <trans-unit id="138d9f5e08c2a06b2507bb7c4b82f8e1fe3734c8" translate="yes" xml:space="preserve">
          <source>The most common way to obtain additional completion functionality beyond the default actions &lt;code&gt;complete&lt;/code&gt; and &lt;code&gt;compgen&lt;/code&gt; provide is to use a shell function and bind it to a particular command using &lt;code&gt;complete -F&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;complete&lt;/code&gt; 및 &lt;code&gt;compgen&lt;/code&gt; 이 제공 하는 기본 조치 이외의 추가 완료 기능을 얻는 가장 일반적인 방법 은 쉘 함수를 사용하고 &lt;code&gt;complete -F&lt;/code&gt; 를 사용하여 특정 명령에 바인딩하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="22a2b765809e319a2304221eeb084e8e9cdfc39d" translate="yes" xml:space="preserve">
          <source>The name of the Readline initialization file, overriding the default of</source>
          <target state="translated">Readline 초기화 파일의 이름으로 기본값 인</target>
        </trans-unit>
        <trans-unit id="fb009d0232ac976858b27feed0246f646da7d244" translate="yes" xml:space="preserve">
          <source>The name of the current host.</source>
          <target state="translated">현재 호스트의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="66d01fa534ec35d1d9cf4793403b9ee6bc2445fc" translate="yes" xml:space="preserve">
          <source>The name of the file to which the command history is saved. The default value is</source>
          <target state="translated">명령 히스토리가 저장된 파일의 이름입니다. 기본값은</target>
        </trans-unit>
        <trans-unit id="1e58eb13b0f3d9ef8278b27b915cf92fb8fb2e65" translate="yes" xml:space="preserve">
          <source>The name of the shell, the basename of &lt;code&gt;$0&lt;/code&gt; (the portion following the final slash).</source>
          <target state="translated">쉘 이름, 기본 이름 &lt;code&gt;$0&lt;/code&gt; (마지막 슬래시 다음 부분).</target>
        </trans-unit>
        <trans-unit id="ce55092ecb8d0e944542f108143836a76b13fbcc" translate="yes" xml:space="preserve">
          <source>The number of CPU seconds spent in system mode.</source>
          <target state="translated">시스템 모드에서 소요 된 CPU 시간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="52ab86da1c8fe970c41c94a163626bb9b036dfca" translate="yes" xml:space="preserve">
          <source>The number of CPU seconds spent in user mode.</source>
          <target state="translated">사용자 모드에서 소요 된 CPU 시간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="7303a5b046e1771b35c3116551ce4956386bee5a" translate="yes" xml:space="preserve">
          <source>The number of jobs currently managed by the shell.</source>
          <target state="translated">현재 셸에서 관리하는 작업 수</target>
        </trans-unit>
        <trans-unit id="46880f98e07dea2b5ce8b2895ddbfcd1d50aeb0e" translate="yes" xml:space="preserve">
          <source>The number of possible completions that determines when the user is asked whether the list of possibilities should be displayed. If the number of possible completions is greater than this value, Readline will ask the user whether or not he wishes to view them; otherwise, they are simply listed. This variable must be set to an integer value greater than or equal to 0. A negative value means Readline should never ask. The default limit is &lt;code&gt;100&lt;/code&gt;.</source>
          <target state="translated">가능한 목록을 표시해야하는지 여부를 사용자에게 묻는시기를 결정하는 가능한 완료 수입니다. 가능한 완료 횟수가이 값보다 큰 경우 Readline은 사용자에게이를보고 싶은지 여부를 묻습니다. 그렇지 않으면 간단히 나열됩니다. 이 변수는 0 이상의 정수 값으로 설정해야합니다. 음수 값은 Readline이 요청하지 않아야 함을 의미합니다. 기본 제한은 &lt;code&gt;100&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="96b4cb1b0a4beb8cd8b3ce13835f3d64ad580e27" translate="yes" xml:space="preserve">
          <source>The number of screen columns used to display possible matches when performing completion. The value is ignored if it is less than 0 or greater than the terminal screen width. A value of 0 will cause matches to be displayed one per line. The default value is -1.</source>
          <target state="translated">완료를 수행 할 때 가능한 일치 항목을 표시하는 데 사용되는 화면 열 수입니다. 값이 0보다 작거나 터미널 화면 너비보다 크면 값이 무시됩니다. 값이 0이면 일치 항목이 한 줄에 하나씩 표시됩니다. 기본값은 -1입니다.</target>
        </trans-unit>
        <trans-unit id="1d5d823f152e786ac9b5aee994ab43d1a7bb51da" translate="yes" xml:space="preserve">
          <source>The numeric effective user id of the current user. This variable is readonly.</source>
          <target state="translated">현재 사용자의 숫자 유효 사용자 ID입니다. 이 변수는 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="0bbb696997781134cb812ad201a40047736b898f" translate="yes" xml:space="preserve">
          <source>The numeric real user id of the current user. This variable is readonly.</source>
          <target state="translated">현재 사용자의 숫자 실제 사용자 ID입니다. 이 변수는 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="63d45cc307ddcc325aa8619a61638def1cc4192e" translate="yes" xml:space="preserve">
          <source>The operator</source>
          <target state="translated">운영자</target>
        </trans-unit>
        <trans-unit id="b1a65e11a6dbbf1eca29abd652b467c14efe692f" translate="yes" xml:space="preserve">
          <source>The operator of an MMC Site may republish an MMC contained in the site under CC-BY-SA on the same site at any time before August 1, 2009, provided the MMC is eligible for relicensing.</source>
          <target state="translated">MMC 사이트의 운영자는 MMC가 재 라이센스를받을 자격이있는 경우 2009 년 8 월 1 일 이전에 언제든지 같은 사이트에서 CC-BY-SA에 따라 사이트에 포함 된 MMC를 다시 게시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75a4caa554203fe5c2eee034e1659633a67b2e13" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;l&lt;/code&gt; specifies a longer format, including minutes, of the form &lt;var&gt;MM&lt;/var&gt;m&lt;var&gt;SS&lt;/var&gt;.&lt;var&gt;FF&lt;/var&gt;s. The value of &lt;var&gt;p&lt;/var&gt; determines whether or not the fraction is included.</source>
          <target state="translated">선택적인 &lt;code&gt;l&lt;/code&gt; 은 분을 포함하여 &lt;var&gt;MM&lt;/var&gt; m &lt;var&gt;SS&lt;/var&gt; 형식의 더 긴 형식을 지정합니다 . &lt;var&gt;FF&lt;/var&gt; 의. &lt;var&gt;p&lt;/var&gt; 의 값은 분수가 포함되는지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="7be00dbf7d289b2eb0bf4fce81bce6631920f3f4" translate="yes" xml:space="preserve">
          <source>The optional &lt;var&gt;p&lt;/var&gt; is a digit specifying the precision, the number of fractional digits after a decimal point. A value of 0 causes no decimal point or fraction to be output. At most three places after the decimal point may be specified; values of &lt;var&gt;p&lt;/var&gt; greater than 3 are changed to 3. If &lt;var&gt;p&lt;/var&gt; is not specified, the value 3 is used.</source>
          <target state="translated">선택적인 &lt;var&gt;p&lt;/var&gt; 는 소수점 이하의 소수 자릿수 인 정밀도를 지정하는 숫자입니다. 값이 0이면 소수점이나 분수가 출력되지 않습니다. 소수점 다음 최대 3 자리를 지정할 수 있습니다. &lt;var&gt;p&lt;/var&gt; 가 3보다 큰 p의 값은 3으로 변경됩니다. &lt;var&gt;p&lt;/var&gt; 를 지정하지 않으면 값 3이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="26f0bd933b7b9d8f84f5462c4298e97f7c296d19" translate="yes" xml:space="preserve">
          <source>The order of expansions is: brace expansion; tilde expansion, parameter and variable expansion, arithmetic expansion, and command substitution (done in a left-to-right fashion); word splitting; and filename expansion.</source>
          <target state="translated">확장 순서는 다음과 같습니다. 괄호 확장; 물결표 확장, 매개 변수 및 변수 확장, 산술 확장 및 명령 대체 (왼쪽에서 오른쪽으로 수행); 단어 분할; 파일 이름 확장.</target>
        </trans-unit>
        <trans-unit id="50d838a94b4bc043bd855b513349ceb7802c1610" translate="yes" xml:space="preserve">
          <source>The output of &amp;lsquo;</source>
          <target state="translated">'의 출력</target>
        </trans-unit>
        <trans-unit id="3a2c151866f3b6bd5ce6fe6924ba9eb6adb99c4c" translate="yes" xml:space="preserve">
          <source>The output of each command in the pipeline is connected via a pipe to the input of the next command. That is, each command reads the previous command&amp;rsquo;s output. This connection is performed before any redirections specified by the command.</source>
          <target state="translated">파이프 라인의 각 명령 출력은 파이프를 통해 다음 명령의 입력에 연결됩니다. 즉, 각 명령은 이전 명령의 출력을 읽습니다. 이 연결은 명령으로 지정된 리디렉션 전에 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="fa65e023b8ce44d4e8e7824b211da8ffeb1e7b50" translate="yes" xml:space="preserve">
          <source>The parser does not recognize &lt;code&gt;time&lt;/code&gt; as a reserved word if the next token begins with a &amp;lsquo;</source>
          <target state="translated">다음 토큰이 '로 시작하면 구문 분석기가 &lt;code&gt;time&lt;/code&gt; 을 예약어로 인식하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06bac09ccee4d705fea241688c64200c84c5f1ba" translate="yes" xml:space="preserve">
          <source>The patch level.</source>
          <target state="translated">패치 레벨.</target>
        </trans-unit>
        <trans-unit id="82bcc4b7792df97617e5fd3e84922c7ba5bfbd72" translate="yes" xml:space="preserve">
          <source>The pipe buffer size.</source>
          <target state="translated">파이프 버퍼 크기.</target>
        </trans-unit>
        <trans-unit id="878cfb678aa1398c62c2c7bcababcbf34f64ba20" translate="yes" xml:space="preserve">
          <source>The position of the insertion point in the Readline line buffer, for use with &amp;lsquo;</source>
          <target state="translated">'와 함께 사용하기 위해 Readline 라인 버퍼에서 삽입 점의 위치</target>
        </trans-unit>
        <trans-unit id="dd2ced6057af76085ad3486eb77baba77e87710a" translate="yes" xml:space="preserve">
          <source>The previous working directory as set by the &lt;code&gt;cd&lt;/code&gt; builtin.</source>
          <target state="translated">&lt;code&gt;cd&lt;/code&gt; 내장에서 설정 한 이전 작업 디렉토리 .</target>
        </trans-unit>
        <trans-unit id="f0b9ceb8168c844e484377cfcb903e440bb39715" translate="yes" xml:space="preserve">
          <source>The primary prompt string. The default value is &amp;lsquo;</source>
          <target state="translated">기본 프롬프트 문자열 기본값은 '</target>
        </trans-unit>
        <trans-unit id="0b276991abb43db5060a47d03f39ac7bd61622bc" translate="yes" xml:space="preserve">
          <source>The process &lt;small&gt;ID&lt;/small&gt; of the shell&amp;rsquo;s parent process. This variable is readonly.</source>
          <target state="translated">쉘 상위 프로세스의 프로세스 &lt;small&gt;ID &lt;/small&gt;이 변수는 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="2d70ba186fbf6d79117746e61da83c9945506776" translate="yes" xml:space="preserve">
          <source>The process &lt;var&gt;list&lt;/var&gt; is run asynchronously, and its input or output appears as a filename. This filename is passed as an argument to the current command as the result of the expansion. If the &lt;code&gt;&amp;gt;(&lt;var&gt;list&lt;/var&gt;)&lt;/code&gt; form is used, writing to the file will provide input for &lt;var&gt;list&lt;/var&gt;. If the &lt;code&gt;&amp;lt;(&lt;var&gt;list&lt;/var&gt;)&lt;/code&gt; form is used, the file passed as an argument should be read to obtain the output of &lt;var&gt;list&lt;/var&gt;. Note that no space may appear between the &lt;code&gt;&amp;lt;&lt;/code&gt; or &lt;code&gt;&amp;gt;&lt;/code&gt; and the left parenthesis, otherwise the construct would be interpreted as a redirection. Process substitution is supported on systems that support named pipes (&lt;small&gt;FIFO&lt;/small&gt;s) or the</source>
          <target state="translated">프로세스 &lt;var&gt;list&lt;/var&gt; 은 비동기 적으로 실행되며 입력 또는 출력은 파일 이름으로 나타납니다. 이 파일 이름은 확장 결과로 현재 명령에 인수로 전달됩니다. 경우] &lt;code&gt;&amp;gt;(&lt;var&gt;list&lt;/var&gt;)&lt;/code&gt; 형태가 사용되는 파일에 기록하기위한 입력을 제공 할 &lt;var&gt;list&lt;/var&gt; . 경우] &lt;code&gt;&amp;lt;(&lt;var&gt;list&lt;/var&gt;)&lt;/code&gt; 형태가 사용되는 인수로 전달되는 파일의 출력을 얻기 위해 읽어야 &lt;var&gt;list&lt;/var&gt; . &lt;code&gt;&amp;lt;&lt;/code&gt; 또는 &lt;code&gt;&amp;gt;&lt;/code&gt; 와 왼쪽 괄호 사이에 공백이 없을 수 있습니다 . 그렇지 않으면 구문이 리디렉션으로 해석됩니다. 프로세스 대체는 명명 된 파이프 ( &lt;small&gt;FIFO&lt;/small&gt; )를 지원하는 시스템 또는</target>
        </trans-unit>
        <trans-unit id="a476b7cbb60009ff5f1c82648823f099258ff9c3" translate="yes" xml:space="preserve">
          <source>The process ID of the shell spawned to execute the coprocess is available as the value of the variable &lt;code&gt;NAME&lt;/code&gt;_PID. The &lt;code&gt;wait&lt;/code&gt; builtin command may be used to wait for the coprocess to terminate.</source>
          <target state="translated">코 프로세스를 실행하기 위해 생성 된 쉘의 프로세스 ID는 변수 &lt;code&gt;NAME&lt;/code&gt; _PID 의 값으로 사용 가능합니다 . &lt;code&gt;wait&lt;/code&gt; coprocess 종료하는 명령 내장 기다려야하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ab6c26bdbf0356755b4a57ca47b4bd143ceea98" translate="yes" xml:space="preserve">
          <source>The process of applying these completion specifications when word completion is attempted is described above (see &lt;a href=&quot;programmable-completion#Programmable-Completion&quot;&gt;Programmable Completion&lt;/a&gt;).</source>
          <target state="translated">단어 완성을 시도 할 때 이러한 완성 사양을 적용하는 프로세스는 위에서 설명했습니다 ( &lt;a href=&quot;programmable-completion#Programmable-Completion&quot;&gt;프로그램 가능 완료&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="4716eb77c0dd878dd02c08b86405054f2b50e5af" translate="yes" xml:space="preserve">
          <source>The purpose of this License is to make a manual, textbook, or other functional and useful document &lt;em&gt;free&lt;/em&gt; in the sense of freedom: to assure everyone the effective freedom to copy and redistribute it, with or without modifying it, either commercially or noncommercially. Secondarily, this License preserves for the author and publisher a way to get credit for their work, while not being considered responsible for modifications made by others.</source>
          <target state="translated">이 라이센스의 목적은 매뉴얼, 교과서 또는 기타 기능적이고 유용한 문서를 &lt;em&gt;자유&lt;/em&gt; 의 의미에서 자유롭게 만드는 것 입니다. 모든 사람이 상업적 또는 비영리적으로 문서를 수정하거나 수정하지 않고 복사 및 재배포 할 수있는 모든 자유를 보장합니다. 두 번째로,이 라이센스는 저작자와 출판사가 자신의 저작물에 대한 크레딧을 얻을 수있는 방법을 유지하면서 다른 사람이 수정 한 것에 대해 책임을지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8678459bfb33be477b57cf23b48d632857722d94" translate="yes" xml:space="preserve">
          <source>The redirection operator</source>
          <target state="translated">리디렉션 연산자</target>
        </trans-unit>
        <trans-unit id="27f8c2af21d6229f2c8dde6af4005922bca465da" translate="yes" xml:space="preserve">
          <source>The release of Bash, version + patchlevel (e.g., 2.00.0)</source>
          <target state="translated">Bash 릴리스, 버전 + 패치 수준 (예 : 2.00.0)</target>
        </trans-unit>
        <trans-unit id="ec3d24986546d409613e59dd2c1b015c3ef7a627" translate="yes" xml:space="preserve">
          <source>The release status (e.g., &lt;var&gt;beta1&lt;/var&gt;).</source>
          <target state="translated">릴리스 상태 (예 : &lt;var&gt;beta1&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="0c5530f0669af8db7b780b20e4169689af02c4bf" translate="yes" xml:space="preserve">
          <source>The remaining N &lt;var&gt;arguments&lt;/var&gt; are positional parameters and are assigned, in order, to &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, &amp;hellip; &lt;code&gt;$N&lt;/code&gt;. The special parameter &lt;code&gt;#&lt;/code&gt; is set to N.</source>
          <target state="translated">나머지 N &lt;var&gt;arguments&lt;/var&gt; 는 위치 매개 변수이며 순서대로 &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; ,&amp;hellip; &lt;code&gt;$N&lt;/code&gt; 됩니다. 특수 매개 변수 &lt;code&gt;#&lt;/code&gt; 는 N으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c406d85fc6d1876c9ab35d2f29d5708542f39727" translate="yes" xml:space="preserve">
          <source>The reserved word &lt;code&gt;time&lt;/code&gt; causes timing statistics to be printed for the pipeline once it finishes. The statistics currently consist of elapsed (wall-clock) time and user and system time consumed by the command&amp;rsquo;s execution. The</source>
          <target state="translated">예약어 &lt;code&gt;time&lt;/code&gt; 은 파이프 라인이 완료되면 타이밍 통계가 인쇄되도록합니다. 통계는 현재 경과 된 (벽 시계) 시간과 명령 실행에 소비 된 사용자 및 시스템 시간으로 구성됩니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="f70377bc4bcdfe0357b29757b411a170e51fb3c0" translate="yes" xml:space="preserve">
          <source>The restricted shell mode is only one component of a useful restricted environment. It should be accompanied by setting &lt;code&gt;PATH&lt;/code&gt; to a value that allows execution of only a few verified commands (commands that allow shell escapes are particularly vulnerable), leaving the user in a non-writable directory other than his home directory after login, not allowing the restricted shell to execute shell scripts, and cleaning the environment of variables that cause some commands to modify their behavior (e.g., &lt;code&gt;VISUAL&lt;/code&gt; or &lt;code&gt;PAGER&lt;/code&gt;).</source>
          <target state="translated">제한된 쉘 모드는 유용한 제한된 환경의 구성 요소 중 하나 일뿐입니다. &lt;code&gt;PATH&lt;/code&gt; 는 몇 가지 확인 된 명령 (쉘 이스케이프를 허용하는 명령이 특히 취약 함) 만 실행할 수있는 값 으로 설정해야하며 , 로그인 후 홈 디렉토리 이외의 쓰기 불가능한 디렉토리에 사용자를 남겨 두어야합니다 . 제한된 쉘은 쉘 스크립트를 실행하고 일부 명령이 동작을 수정하게하는 변수 환경을 정리합니다 (예 : &lt;code&gt;VISUAL&lt;/code&gt; 또는 &lt;code&gt;PAGER&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f5788bd5b869c4f2f3b0a6a16acf04e0ef52e086" translate="yes" xml:space="preserve">
          <source>The result of the expansion is subject to word splitting and pathname expansion as described below.</source>
          <target state="translated">확장 결과는 아래 설명과 같이 단어 분할 및 경로 이름 확장의 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="4afc22fd875e16ab7009fb8b2656518be216471f" translate="yes" xml:space="preserve">
          <source>The return status (see &lt;a href=&quot;exit-status#Exit-Status&quot;&gt;Exit Status&lt;/a&gt;) of a simple command is its exit status as provided by the &lt;small&gt;POSIX&lt;/small&gt; 1003.1 &lt;code&gt;waitpid&lt;/code&gt; function, or 128+&lt;var&gt;n&lt;/var&gt; if the command was terminated by signal &lt;var&gt;n&lt;/var&gt;.</source>
          <target state="translated">단순 명령 의 리턴 상태 ( &lt;a href=&quot;exit-status#Exit-Status&quot;&gt;종료 상태&lt;/a&gt; 참조 )는 &lt;small&gt;POSIX&lt;/small&gt; 1003.1 &lt;code&gt;waitpid&lt;/code&gt; 함수에서 제공 한 종료 상태 이거나 명령이 신호 &lt;var&gt;n&lt;/var&gt; 에 의해 종료 된 경우 128 &lt;var&gt;n&lt;/var&gt; n 입니다.</target>
        </trans-unit>
        <trans-unit id="d4c16feae2ec17c1b766055b73ef372158cc5577" translate="yes" xml:space="preserve">
          <source>The return status is always zero unless an invalid option is supplied.</source>
          <target state="translated">유효하지 않은 옵션을 제공하지 않으면 반환 상태는 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="edf5b2fc810067ae8bd5d1a116f1b988711b4726" translate="yes" xml:space="preserve">
          <source>The return status is the exit status of the last command that executes. If there are no items in the expansion of &lt;var&gt;words&lt;/var&gt;, no commands are executed, and the return status is zero.</source>
          <target state="translated">리턴 상태는 마지막으로 실행 된 명령의 종료 상태입니다. &lt;var&gt;words&lt;/var&gt; 확장에 항목이 없으면 명령이 실행되지 않으며 반환 상태는 0입니다.</target>
        </trans-unit>
        <trans-unit id="139ea59902aacb9b462b237611bb180dededca16" translate="yes" xml:space="preserve">
          <source>The return status is zero if all of the &lt;var&gt;names&lt;/var&gt; are found, non-zero if any are not found.</source>
          <target state="translated">모든 &lt;var&gt;names&lt;/var&gt; 이 발견 되면 리턴 상태는 0이고, 이름 이 없으면 0이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="3e2e10afbf0eb8cd947b719e65752d296e25acdf" translate="yes" xml:space="preserve">
          <source>The return status is zero if no &lt;var&gt;pattern&lt;/var&gt; is matched. Otherwise, the return status is the exit status of the &lt;var&gt;command-list&lt;/var&gt; executed.</source>
          <target state="translated">일치하는 &lt;var&gt;pattern&lt;/var&gt; 이 없으면 리턴 상태는 0 입니다. 그렇지 않으면, 리턴 상태는 실행 된 &lt;var&gt;command-list&lt;/var&gt; 의 종료 상태입니다 .</target>
        </trans-unit>
        <trans-unit id="fd37bef165d1c2b13e0b9c03f77edc8dca883363" translate="yes" xml:space="preserve">
          <source>The return status is zero if the directory is successfully changed, non-zero otherwise.</source>
          <target state="translated">디렉토리가 성공적으로 변경되면 리턴 상태는 0이고, 그렇지 않으면 0이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="980ed86ff499fbca6bf880e390688e559e87fee4" translate="yes" xml:space="preserve">
          <source>The return status is zero unless a &lt;var&gt;name&lt;/var&gt; is not a shell builtin or there is an error loading a new builtin from a shared object.</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt; 이 쉘 내장이 아니거나 공유 객체에서 새 내장을로드하는 동안 오류가 없으면 반환 상태는 0 입니다.</target>
        </trans-unit>
        <trans-unit id="d7361147afb0905e0d597ba8f358f5fa3e4789f7" translate="yes" xml:space="preserve">
          <source>The return status is zero unless a &lt;var&gt;sigspec&lt;/var&gt; does not specify a valid signal.</source>
          <target state="translated">&lt;var&gt;sigspec&lt;/var&gt; 이 유효한 신호를 지정하지 않으면 반환 상태는 0 입니다.</target>
        </trans-unit>
        <trans-unit id="b9520c176239454e40ab970a76500acf0a2a9708" translate="yes" xml:space="preserve">
          <source>The return status is zero unless an invalid option is encountered, an attempt is made to define a function using &amp;lsquo;</source>
          <target state="translated">유효하지 않은 옵션이 발견되지 않으면 리턴 상태는 0입니다. '를 사용하여 함수를 정의하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="d977247bb00ecbeefc2342eb94e26ab0b25dfde9" translate="yes" xml:space="preserve">
          <source>The return status is zero unless an invalid option is supplied or an error occurs.</source>
          <target state="translated">유효하지 않은 옵션이 제공되거나 오류가 발생하지 않으면 리턴 상태는 0입니다.</target>
        </trans-unit>
        <trans-unit id="2d84c34844e5928e34eb45fc62a6fa465da1eed8" translate="yes" xml:space="preserve">
          <source>The return status is zero unless an invalid option is supplied, one of the names is not a valid shell variable name, or</source>
          <target state="translated">유효하지 않은 옵션이 제공되지 않거나 이름 중 하나가 유효한 쉘 변수 이름이 아닌 경우 리턴 상태는 0입니다.</target>
        </trans-unit>
        <trans-unit id="cb9bb3db604d40c52d6a0ed4be85c8d7e3588d80" translate="yes" xml:space="preserve">
          <source>The return status is zero unless an invalid option or argument is supplied, or an error occurs while setting a new limit.</source>
          <target state="translated">유효하지 않은 옵션이나 인수가 제공되지 않거나 새 한계를 설정하는 동안 오류가 발생하지 않으면 리턴 상태는 0입니다.</target>
        </trans-unit>
        <trans-unit id="0f2412a1102b7277323c4cc092cbf40530c3672f" translate="yes" xml:space="preserve">
          <source>The return status is zero unless no command matches &lt;var&gt;pattern&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;pattern&lt;/var&gt; 과 일치하는 명령이 없으면 리턴 상태는 0 입니다 .</target>
        </trans-unit>
        <trans-unit id="f3c05430accfd44314e843b73808550a84df168e" translate="yes" xml:space="preserve">
          <source>The return status of &lt;small&gt;AND&lt;/small&gt; and &lt;small&gt;OR&lt;/small&gt; lists is the exit status of the last command executed in the list.</source>
          <target state="translated">&lt;small&gt;AND&lt;/small&gt; 및 &lt;small&gt;OR&lt;/small&gt; 리스트 의 리턴 상태는 리스트에서 마지막으로 실행 된 명령의 종료 상태입니다.</target>
        </trans-unit>
        <trans-unit id="444c7ff858fdf7094cf753409e8f19e0840ab92b" translate="yes" xml:space="preserve">
          <source>The return status when listing options is zero if all &lt;var&gt;optnames&lt;/var&gt; are enabled, non-zero otherwise. When setting or unsetting options, the return status is zero unless an &lt;var&gt;optname&lt;/var&gt; is not a valid shell option.</source>
          <target state="translated">모든 &lt;var&gt;optnames&lt;/var&gt; 이 사용 가능한 경우 옵션을 나열 할 때 리턴 상태는 0이고 , 그렇지 않으면 0이 아닙니다. 옵션을 설정 또는 설정 해제 할 때 &lt;var&gt;optname&lt;/var&gt; 이 유효한 쉘 옵션 이 아닌 경우 리턴 상태는 0 입니다.</target>
        </trans-unit>
        <trans-unit id="29c786e126af22d614c9083278320ac7fc5eefe1" translate="yes" xml:space="preserve">
          <source>The return value is 0 unless the shell is not executing a subroutine call or &lt;var&gt;expr&lt;/var&gt; does not correspond to a valid position in the call stack.</source>
          <target state="translated">쉘이 서브 루틴 호출을 실행 하지 않거나 &lt;var&gt;expr&lt;/var&gt; 이 호출 스택의 유효한 위치에 해당하지 않는 한 리턴 값은 0 입니다.</target>
        </trans-unit>
        <trans-unit id="d86714d75d70f053c6711f08829d0c808f136b26" translate="yes" xml:space="preserve">
          <source>The return value is true unless an invalid option is supplied, an attempt is made to modify the options for a &lt;var&gt;name&lt;/var&gt; for which no completion specification exists, or an output error occurs.</source>
          <target state="translated">유효하지 않은 옵션이 제공 되지 않거나 완료 스펙이 존재하지 않는 &lt;var&gt;name&lt;/var&gt; 의 옵션을 수정하려고 시도 하거나 출력 오류가 발생 하지 않으면 리턴 값은 true 입니다.</target>
        </trans-unit>
        <trans-unit id="87c85924056c36528995c9b7ba4ed62a82614420" translate="yes" xml:space="preserve">
          <source>The return value is true unless an invalid option is supplied, an option other than</source>
          <target state="translated">유효하지 않은 옵션이 제공되지 않으면 리턴 값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="15a822235281678e7fa50e449a6c26717df07938" translate="yes" xml:space="preserve">
          <source>The return value is true unless an invalid option is supplied, or no matches were generated.</source>
          <target state="translated">유효하지 않은 옵션이 제공되거나 일치 항목이 생성되지 않으면 리턴 값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="fc11c48cfe742a595ccb253defc457d792dc1ec9" translate="yes" xml:space="preserve">
          <source>The rules concerning the definition and use of aliases are somewhat confusing. Bash always reads at least one complete line of input, and all lines that make up a compound command, before executing any of the commands on that line or the compound command. Aliases are expanded when a command is read, not when it is executed. Therefore, an alias definition appearing on the same line as another command does not take effect until the next line of input is read. The commands following the alias definition on that line are not affected by the new alias. This behavior is also an issue when functions are executed. Aliases are expanded when a function definition is read, not when the function is executed, because a function definition is itself a command. As a consequence, aliases defined in a function are not available until after that function is executed. To be safe, always put alias definitions on a separate line, and do not use &lt;code&gt;alias&lt;/code&gt; in compound commands.</source>
          <target state="translated">별명 정의 및 사용에 관한 규칙은 다소 혼동됩니다. Bash는 항상 하나 이상의 완전한 입력 행과 복합 명령을 구성하는 모든 행을 읽습니다. 해당 행의 명령 또는 복합 명령을 실행하기 전에. 명령이 실행될 때가 아니라 명령을 읽을 때 별칭이 확장됩니다. 따라서 다른 명령과 동일한 행에 나타나는 별명 정의는 다음 입력 행을 읽을 때까지 적용되지 않습니다. 해당 행에서 별명 정의 뒤에 오는 명령은 새 별명의 영향을받지 않습니다. 이 동작은 기능이 실행될 때도 문제가됩니다. 함수 정의 자체가 명령이기 때문에 함수가 실행될 때가 아니라 함수 정의를 읽을 때 별칭이 확장됩니다. 결과로서,함수에 정의 된 별칭은 해당 함수가 실행될 때까지 사용할 수 없습니다. 안전을 위해 항상 별칭 정의를 별도의 줄에 배치하고 사용하지 마십시오 &lt;code&gt;alias&lt;/code&gt; 복합 명령의 별명 .</target>
        </trans-unit>
        <trans-unit id="7c69f91a4b82b2298fab3319d89e9bff24ee39ea" translate="yes" xml:space="preserve">
          <source>The secondary prompt string. The default value is &amp;lsquo;</source>
          <target state="translated">보조 프롬프트 문자열 기본값은 '</target>
        </trans-unit>
        <trans-unit id="f3e658ab4121249a4adecc41b2997df149afa25c" translate="yes" xml:space="preserve">
          <source>The set of characters that the Readline library treats as word separators when performing word completion. If &lt;code&gt;COMP_WORDBREAKS&lt;/code&gt; is unset, it loses its special properties, even if it is subsequently reset.</source>
          <target state="translated">Readline 라이브러리가 단어 완성을 수행 할 때 단어 구분 기호로 취급하는 문자 세트입니다. 경우 &lt;code&gt;COMP_WORDBREAKS&lt;/code&gt; 가 설정되지, 그것은 나중에 다시 경우에도 특별한 속성을 잃게된다.</target>
        </trans-unit>
        <trans-unit id="a9227631f6e16c78b2307840c22265ee938df1e2" translate="yes" xml:space="preserve">
          <source>The shell &quot;building blocks&quot;.</source>
          <target state="translated">쉘 &quot;빌딩 블록&quot;.</target>
        </trans-unit>
        <trans-unit id="e56b5b448656c7590aab2b5146242bdd0df94454" translate="yes" xml:space="preserve">
          <source>The shell allows arithmetic expressions to be evaluated, as one of the shell expansions or by using the &lt;code&gt;((&lt;/code&gt; compound command, the &lt;code&gt;let&lt;/code&gt; builtin, or the</source>
          <target state="translated">쉘은 쉘 확장 중 하나로서 또는 &lt;code&gt;((&lt;/code&gt; 복합 명령, &lt;code&gt;let&lt;/code&gt; 내장 또는</target>
        </trans-unit>
        <trans-unit id="de6f5329a04c76e3eb0db5c92b0698630793acca" translate="yes" xml:space="preserve">
          <source>The shell allows control of the various characters used by the history expansion mechanism with the &lt;code&gt;histchars&lt;/code&gt; variable, as explained above (see &lt;a href=&quot;bash-variables#Bash-Variables&quot;&gt;Bash Variables&lt;/a&gt;). The shell uses the history comment character to mark history timestamps when writing the history file.</source>
          <target state="translated">쉘은 위에서 설명한대로 &lt;code&gt;histchars&lt;/code&gt; 변수를 사용하여 히스토리 확장 메커니즘에서 사용하는 다양한 문자를 제어 할 수 있습니다 ( &lt;a href=&quot;bash-variables#Bash-Variables&quot;&gt;Bash 변수&lt;/a&gt; 참조 ). 쉘은 히스토리 주석 문자를 사용하여 히스토리 파일을 작성할 때 히스토리 시간 소인을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="0362e466df6eb864c38d9b0e66a2024579878737" translate="yes" xml:space="preserve">
          <source>The shell allows control over which commands are saved on the history list. The &lt;code&gt;HISTCONTROL&lt;/code&gt; and &lt;code&gt;HISTIGNORE&lt;/code&gt; variables may be set to cause the shell to save only a subset of the commands entered. The &lt;code&gt;cmdhist&lt;/code&gt; shell option, if enabled, causes the shell to attempt to save each line of a multi-line command in the same history entry, adding semicolons where necessary to preserve syntactic correctness. The &lt;code&gt;lithist&lt;/code&gt; shell option causes the shell to save the command with embedded newlines instead of semicolons. The &lt;code&gt;shopt&lt;/code&gt; builtin is used to set these options. See &lt;a href=&quot;the-shopt-builtin#The-Shopt-Builtin&quot;&gt;The Shopt Builtin&lt;/a&gt;, for a description of &lt;code&gt;shopt&lt;/code&gt;.</source>
          <target state="translated">셸을 사용하면 기록 목록에 저장할 명령을 제어 할 수 있습니다. &lt;code&gt;HISTCONTROL&lt;/code&gt; 및 &lt;code&gt;HISTIGNORE&lt;/code&gt; 변수는 입력 된 명령의 하위 집합을 저장 쉘의 원인이 설정 될 수있다. &lt;code&gt;cmdhist&lt;/code&gt; 의 쉘 옵션이 활성화 된 경우, 구문 정확성을 유지하기 위해 필요한 세미콜론을 추가, 같은 역사 항목에 여러 줄의 명령의 각 라인을 저장하려고하는 쉘됩니다. &lt;code&gt;lithist&lt;/code&gt; 의 쉘 옵션이 포함 된 줄 바꿈 대신 세미콜론으로 명령을 저장하려면 쉘을 발생합니다. &lt;code&gt;shopt&lt;/code&gt; 내부의 내장은 이러한 옵션을 설정하는 데 사용됩니다. &lt;code&gt;shopt&lt;/code&gt; 에 대한 설명은 &lt;a href=&quot;the-shopt-builtin#The-Shopt-Builtin&quot;&gt;Shopt Builtin을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5e2d6d8d979b9089bc7dbd323e0fcd7060ebed5" translate="yes" xml:space="preserve">
          <source>The shell associates a &lt;var&gt;job&lt;/var&gt; with each pipeline. It keeps a table of currently executing jobs, which may be listed with the &lt;code&gt;jobs&lt;/code&gt; command. When Bash starts a job asynchronously, it prints a line that looks like:</source>
          <target state="translated">셸은 &lt;var&gt;job&lt;/var&gt; 을 각 파이프 라인과 연결합니다 . 현재 실행중인 작업 테이블을 유지하며 &lt;code&gt;jobs&lt;/code&gt; 명령 과 함께 나열 될 수 있습니다 . Bash는 비동기 적으로 작업을 시작하면 다음과 같은 행을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="9cf7a6dea08a855c9acf206522d804a0254a3f0c" translate="yes" xml:space="preserve">
          <source>The shell exits by default upon receipt of a &lt;code&gt;SIGHUP&lt;/code&gt;. Before exiting, an interactive shell resends the &lt;code&gt;SIGHUP&lt;/code&gt; to all jobs, running or stopped. Stopped jobs are sent &lt;code&gt;SIGCONT&lt;/code&gt; to ensure that they receive the &lt;code&gt;SIGHUP&lt;/code&gt;. To prevent the shell from sending the &lt;code&gt;SIGHUP&lt;/code&gt; signal to a particular job, it should be removed from the jobs table with the &lt;code&gt;disown&lt;/code&gt; builtin (see &lt;a href=&quot;job-control-builtins#Job-Control-Builtins&quot;&gt;Job Control Builtins&lt;/a&gt;) or marked to not receive &lt;code&gt;SIGHUP&lt;/code&gt; using &lt;code&gt;disown -h&lt;/code&gt;.</source>
          <target state="translated">쉘은 &lt;code&gt;SIGHUP&lt;/code&gt; 을 받으면 기본적으로 종료됩니다 . 종료하기 전에 대화식 쉘은 &lt;code&gt;SIGHUP&lt;/code&gt; 을 실행 또는 중지 된 모든 작업으로 다시 보냅니다 . 중지 된 작업은 &lt;code&gt;SIGHUP&lt;/code&gt; 을 수신 할 수 있도록 &lt;code&gt;SIGCONT&lt;/code&gt; 로 전송 됩니다 . 쉘이 &lt;code&gt;SIGHUP&lt;/code&gt; 신호를 특정 작업으로 전송하지 못하게하려면 &lt;code&gt;disown&lt;/code&gt; 내장 ( &lt;a href=&quot;job-control-builtins#Job-Control-Builtins&quot;&gt;작업 제어 내장&lt;/a&gt; 참조)이 있는 작업 테이블에서이를 제거 하거나 &lt;code&gt;disown -h&lt;/code&gt; 를 사용하여 &lt;code&gt;SIGHUP&lt;/code&gt; 을 수신하지 않도록 표시해야 합니다.</target>
        </trans-unit>
        <trans-unit id="6da304625649da7647ca4753c774c91abbcbb1aa" translate="yes" xml:space="preserve">
          <source>The shell function &lt;var&gt;function&lt;/var&gt; is executed in the current shell environment. When it is executed, $1 is the name of the command whose arguments are being completed, $2 is the word being completed, and $3 is the word preceding the word being completed, as described above (see &lt;a href=&quot;programmable-completion#Programmable-Completion&quot;&gt;Programmable Completion&lt;/a&gt;). When it finishes, the possible completions are retrieved from the value of the &lt;code&gt;COMPREPLY&lt;/code&gt; array variable.</source>
          <target state="translated">쉘 기능 &lt;var&gt;function&lt;/var&gt; 은 현재 쉘 환경에서 실행됩니다. 실행될 때 $ 1은 인수가 완료되는 명령의 이름이고, $ 2는 완료되는 단어이며, $ 3은 위에서 설명한대로 완료되는 단어 앞에있는 단어입니다 ( &lt;a href=&quot;programmable-completion#Programmable-Completion&quot;&gt;프로그램 완료&lt;/a&gt; 참조 ). 완료되면 &lt;code&gt;COMPREPLY&lt;/code&gt; 배열 변수 의 값에서 가능한 완료를 검색 합니다.</target>
        </trans-unit>
        <trans-unit id="9265d28258a9f15465eb26e5f672576598c224b2" translate="yes" xml:space="preserve">
          <source>The shell has an &lt;var&gt;execution environment&lt;/var&gt;, which consists of the following:</source>
          <target state="translated">셸에는 다음과 같이 구성된 &lt;var&gt;execution environment&lt;/var&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc18292b655a353a6d0db19b5f5c669e2707cbcc" translate="yes" xml:space="preserve">
          <source>The shell learns immediately whenever a job changes state. Normally, Bash waits until it is about to print a prompt before reporting changes in a job&amp;rsquo;s status so as to not interrupt any other output. If the</source>
          <target state="translated">쉘은 작업 상태가 변경 될 때마다 즉시 학습합니다. 일반적으로 Bash는 다른 출력을 방해하지 않도록 작업 상태 변경을보고하기 전에 프롬프트를 인쇄 할 때까지 기다립니다. 만약</target>
        </trans-unit>
        <trans-unit id="b848180ca0000ad79ae324e1c3a900dedfdaa10a" translate="yes" xml:space="preserve">
          <source>The shell scans the results of parameter expansion, command substitution, and arithmetic expansion that did not occur within double quotes for word splitting.</source>
          <target state="translated">쉘은 단어 분리를 위해 큰 따옴표 안에없는 매개 변수 확장, 명령 대체 및 산술 확장의 결과를 스캔합니다.</target>
        </trans-unit>
        <trans-unit id="eefc3401f6dd1bb6691c9bebf0d6d5fb898f599b" translate="yes" xml:space="preserve">
          <source>The shell sets this option if it is started as a login shell (see &lt;a href=&quot;invoking-bash#Invoking-Bash&quot;&gt;Invoking Bash&lt;/a&gt;). The value may not be changed.</source>
          <target state="translated">쉘은 로그인 쉘로 시작된 경우이 옵션을 설정합니다 ( &lt;a href=&quot;invoking-bash#Invoking-Bash&quot;&gt;Bash 호출&lt;/a&gt; 참조 ). 값이 변경되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51c0ca18fa53fc79a29905727290b49d2ebb6a65" translate="yes" xml:space="preserve">
          <source>The shell sets this option if it is started in restricted mode (see &lt;a href=&quot;the-restricted-shell#The-Restricted-Shell&quot;&gt;The Restricted Shell&lt;/a&gt;). The value may not be changed. This is not reset when the startup files are executed, allowing the startup files to discover whether or not a shell is restricted.</source>
          <target state="translated">쉘은 제한 모드에서 시작된 경우이 옵션을 설정합니다 ( &lt;a href=&quot;the-restricted-shell#The-Restricted-Shell&quot;&gt;제한 쉘&lt;/a&gt; 참조 ). 값이 변경되지 않을 수 있습니다. 시작 파일이 실행될 때 재설정되지 않으므로 시작 파일이 쉘 제한 여부를 발견 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d77b348c667c262a723d3137596851cfdbb00e0" translate="yes" xml:space="preserve">
          <source>The shell then parses these tokens into commands and other constructs, removes the special meaning of certain words or characters, expands others, redirects input and output as needed, executes the specified command, waits for the command&amp;rsquo;s exit status, and makes that exit status available for further inspection or processing.</source>
          <target state="translated">쉘은 이러한 토큰을 명령 및 기타 구문으로 구문 분석하고 특정 단어 또는 문자의 특수 의미를 제거하고 다른 단어를 확장하고 필요에 따라 입력 및 출력을 리디렉션하고 지정된 명령을 실행하며 명령의 종료 상태를 기다린 후 종료 상태를 사용 가능하게 만듭니다. 추가 검사 또는 처리를 위해.</target>
        </trans-unit>
        <trans-unit id="9ba4037ea0906aeaaf517aff4e32cf5f4a49049a" translate="yes" xml:space="preserve">
          <source>The shell treats each character of &lt;code&gt;$IFS&lt;/code&gt; as a delimiter, and splits the results of the other expansions into words using these characters as field terminators. If &lt;code&gt;IFS&lt;/code&gt; is unset, or its value is exactly &lt;code&gt;&amp;lt;space&amp;gt;&amp;lt;tab&amp;gt;&amp;lt;newline&amp;gt;&lt;/code&gt;, the default, then sequences of &lt;code&gt; &amp;lt;space&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;tab&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;newline&amp;gt;&lt;/code&gt; at the beginning and end of the results of the previous expansions are ignored, and any sequence of &lt;code&gt;IFS&lt;/code&gt; characters not at the beginning or end serves to delimit words. If &lt;code&gt;IFS&lt;/code&gt; has a value other than the default, then sequences of the whitespace characters &lt;code&gt;space&lt;/code&gt;, &lt;code&gt;tab&lt;/code&gt;, and &lt;code&gt;newline&lt;/code&gt; are ignored at the beginning and end of the word, as long as the whitespace character is in the value of &lt;code&gt;IFS&lt;/code&gt; (an &lt;code&gt;IFS&lt;/code&gt; whitespace character). Any character in &lt;code&gt;IFS&lt;/code&gt; that is not &lt;code&gt;IFS&lt;/code&gt; whitespace, along with any adjacent &lt;code&gt;IFS&lt;/code&gt; whitespace characters, delimits a field. A sequence of &lt;code&gt;IFS&lt;/code&gt; whitespace characters is also treated as a delimiter. If the value of &lt;code&gt;IFS&lt;/code&gt; is null, no word splitting occurs.</source>
          <target state="translated">쉘은 &lt;code&gt;$IFS&lt;/code&gt; 의 각 문자를 분리 문자로 취급 하고이 확장 문자를 필드 종결 자로 사용하여 다른 확장 결과를 단어로 나눕니다. 경우 &lt;code&gt;IFS&lt;/code&gt; 가 설정되지 않은 경우, 또는 그 값이 정확히 &lt;code&gt;&amp;lt;space&amp;gt;&amp;lt;tab&amp;gt;&amp;lt;newline&amp;gt;&lt;/code&gt; , 기본의 다음 순서 &lt;code&gt; &amp;lt;space&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;tab&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;newline&amp;gt;&lt;/code&gt; 시작과 이전 확장의 결과의 끝 무시 되고 시작 또는 끝에없는 &lt;code&gt;IFS&lt;/code&gt; 문자 시퀀스는 단어를 구분하는 역할을합니다. &lt;code&gt;IFS&lt;/code&gt; 에 기본값 이외의 값이있는 경우 공백 문자 &lt;code&gt;space&lt;/code&gt; , &lt;code&gt;tab&lt;/code&gt; 및 &lt;code&gt;newline&lt;/code&gt; 공백 문자가 &lt;code&gt;IFS&lt;/code&gt; ( &lt;code&gt;IFS&lt;/code&gt; 공백 문자) 값에있는 한 단어의 시작과 끝에서 무시됩니다 . 의 모든 문자 &lt;code&gt;IFS&lt;/code&gt; 아닌 &lt;code&gt;IFS&lt;/code&gt; 인접한과 함께 공백을 &lt;code&gt;IFS&lt;/code&gt; , 필드을 구분 공백 문자. 일련의 &lt;code&gt;IFS&lt;/code&gt; 공백 문자도 분리 문자로 처리됩니다. &lt;code&gt;IFS&lt;/code&gt; 의 값 이 널이면 단어 분할이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="07cc547bede40d0cae5e40f5f4a99569ccd0c4b4" translate="yes" xml:space="preserve">
          <source>The shell treats several parameters specially. These parameters may only be referenced; assignment to them is not allowed.</source>
          <target state="translated">쉘은 여러 매개 변수를 특별히 처리합니다. 이 매개 변수는 참조 만 가능합니다. 그들에게 할당은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b2ad0c7d7487f4ea0379a55a58abfa1a4e0befb" translate="yes" xml:space="preserve">
          <source>The shell uses &lt;var&gt;dynamic scoping&lt;/var&gt; to control a variable&amp;rsquo;s visibility within functions. With dynamic scoping, visible variables and their values are a result of the sequence of function calls that caused execution to reach the current function. The value of a variable that a function sees depends on its value within its caller, if any, whether that caller is the &quot;global&quot; scope or another shell function. This is also the value that a local variable declaration &quot;shadows&quot;, and the value that is restored when the function returns.</source>
          <target state="translated">쉘은 &lt;var&gt;dynamic scoping&lt;/var&gt; 을 사용하여 함수 내에서 변수의 가시성을 제어합니다. 동적 범위 지정을 사용하면 보이는 변수 및 해당 값은 실행이 현재 함수에 도달하게 한 함수 호출 시퀀스의 결과입니다. 함수가 보는 변수의 값은 호출자가 &quot;전역&quot;범위인지 다른 쉘 함수인지에 따라 호출자 내의 값에 따라 다릅니다. 이것은 또한 지역 변수 선언이 &quot;그림자&quot;값이며, 함수가 반환 될 때 복원되는 값입니다.</target>
        </trans-unit>
        <trans-unit id="86b20ce8aab434c014aaddb88f0788ead16beb6d" translate="yes" xml:space="preserve">
          <source>The shell will check the value of the &lt;code&gt;TMOUT&lt;/code&gt; variable and exit if a command is not read within the specified number of seconds after printing &lt;code&gt;$PS1&lt;/code&gt; (see &lt;a href=&quot;bash-variables#Bash-Variables&quot;&gt;Bash Variables&lt;/a&gt;).</source>
          <target state="translated">쉘은 &lt;code&gt;$PS1&lt;/code&gt; 인쇄 후 지정된 시간 (초) 내에 명령을 읽지 않으면 &lt;code&gt;TMOUT&lt;/code&gt; 변수 의 값을 확인 하고 종료합니다 ( &lt;a href=&quot;bash-variables#Bash-Variables&quot;&gt;Bash 변수&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="02d8f9c91b575ef17dfa7f7dbf1c624fb566f7b4" translate="yes" xml:space="preserve">
          <source>The shell will not exit on expansion errors caused by &lt;var&gt;var&lt;/var&gt; being unset or null in &lt;code&gt;${&lt;var&gt;var&lt;/var&gt;:?&lt;var&gt;word&lt;/var&gt;}&lt;/code&gt; expansions (see &lt;a href=&quot;shell-parameter-expansion#Shell-Parameter-Expansion&quot;&gt;Shell Parameter Expansion&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;${&lt;var&gt;var&lt;/var&gt;:?&lt;var&gt;word&lt;/var&gt;}&lt;/code&gt; &lt;var&gt;var&lt;/var&gt; : var 에서 &lt;var&gt;var&lt;/var&gt; 가 설정되지 않았거나 null로 인해 확장 오류로 인해 쉘이 종료되지 않습니다 . &lt;var&gt;word&lt;/var&gt; } expansions ( &lt;a href=&quot;shell-parameter-expansion#Shell-Parameter-Expansion&quot;&gt;쉘 매개 변수 확장&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="0f85b03a392455895011cb39b0e69ae7d461f563" translate="yes" xml:space="preserve">
          <source>The shell will perform brace expansion (see &lt;a href=&quot;brace-expansion#Brace-Expansion&quot;&gt;Brace Expansion&lt;/a&gt;). This option is on by default.</source>
          <target state="translated">쉘은 중괄호 확장 (참조 수행 &lt;a href=&quot;brace-expansion#Brace-Expansion&quot;&gt;브레이스 확장&lt;/a&gt; ). 이 옵션은 기본적으로 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="929e9d23bb121f55558c95f11d362127b9b29dfc" translate="yes" xml:space="preserve">
          <source>The shell&amp;rsquo;s command-line arguments.</source>
          <target state="translated">쉘의 명령 행 인수.</target>
        </trans-unit>
        <trans-unit id="2eaa3191638c3167e75792e2c32188b7558fa5c1" translate="yes" xml:space="preserve">
          <source>The simplest way to compile Bash is:</source>
          <target state="translated">Bash를 컴파일하는 가장 간단한 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c6d492ae475f3eb0b64cc0410b3e288c4efe8d31" translate="yes" xml:space="preserve">
          <source>The special parameters &amp;lsquo;</source>
          <target state="translated">특수 매개 변수 '</target>
        </trans-unit>
        <trans-unit id="78ac93ea4c7d589a16f423e51aa82d328440771b" translate="yes" xml:space="preserve">
          <source>The special pattern characters have the following meanings:</source>
          <target state="translated">특수 패턴 문자는 다음과 같은 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="ab52fbd0480da10f00829294cf610456cf0473ff" translate="yes" xml:space="preserve">
          <source>The status returned by commands and how Bash interprets it.</source>
          <target state="translated">명령이 리턴 한 상태 및 Bash가이를 해석하는 방법.</target>
        </trans-unit>
        <trans-unit id="c96d3826ce6fa7fa67cd9e6a57d44dbfee981c12" translate="yes" xml:space="preserve">
          <source>The string of characters that should terminate an incremental search without subsequently executing the character as a command (see &lt;a href=&quot;searching#Searching&quot;&gt;Searching&lt;/a&gt;). If this variable has not been given a value, the characters &lt;code&gt;ESC&lt;/code&gt; and</source>
          <target state="translated">이후에 문자를 명령으로 실행하지 않고 증분 검색을 종료해야하는 문자열입니다 ( &lt;a href=&quot;searching#Searching&quot;&gt;검색&lt;/a&gt; 참조 ). 이 변수에 값이 없으면 문자 &lt;code&gt;ESC&lt;/code&gt; 및</target>
        </trans-unit>
        <trans-unit id="651d0c97af7e902b9750faea2a0b1c833b2440b5" translate="yes" xml:space="preserve">
          <source>The string that would be displayed by &amp;lsquo;</source>
          <target state="translated">'로 표시되는 문자열</target>
        </trans-unit>
        <trans-unit id="7776d244b6bbd7d504afa9689c3cb612100b5e61" translate="yes" xml:space="preserve">
          <source>The string to insert at the beginning of the line when the &lt;code&gt;insert-comment&lt;/code&gt; command is executed. The default value is &lt;code&gt;&quot;#&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;insert-comment&lt;/code&gt; 명령이 실행될 때 행의 시작 부분에 삽입 할 문자열 입니다. 기본값은 &lt;code&gt;&quot;#&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="557cad528fdbd6bd6acf00aaccdee22ebcbd8c35" translate="yes" xml:space="preserve">
          <source>The subdirectory &lt;code&gt;foo&lt;/code&gt; of the home directory of the user &lt;code&gt;fred&lt;/code&gt;</source>
          <target state="translated">사용자 &lt;code&gt;fred&lt;/code&gt; 의 홈 디렉토리의 서브 디렉토리 &lt;code&gt;foo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f8f8b505ce05315e1a17e36787d4eec3e6ea7c76" translate="yes" xml:space="preserve">
          <source>The syntax</source>
          <target state="translated">문법</target>
        </trans-unit>
        <trans-unit id="83864cb09377d92aa6ef6b10369692847d068dfa" translate="yes" xml:space="preserve">
          <source>The syntax for controlling key bindings in the init file is simple. First you need to find the name of the command that you want to change. The following sections contain tables of the command name, the default keybinding, if any, and a short description of what the command does.</source>
          <target state="translated">init 파일에서 키 바인딩을 제어하는 ​​구문은 간단합니다. 먼저 변경하려는 명령의 이름을 찾아야합니다. 다음 섹션에는 명령 이름, 기본 키 바인딩 (있는 경우) 및 명령의 간략한 설명이 들어 있습니다.</target>
        </trans-unit>
        <trans-unit id="397e51c7f8e3aa386b3ed248ec72a1a9aefbb131" translate="yes" xml:space="preserve">
          <source>The syntax of the &lt;code&gt;case&lt;/code&gt; command is:</source>
          <target state="translated">&lt;code&gt;case&lt;/code&gt; 명령 의 구문 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e89589fa0086f9e4f68229bce7a4fb55ef7e7312" translate="yes" xml:space="preserve">
          <source>The syntax of the &lt;code&gt;for&lt;/code&gt; command is:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 명령 의 구문은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="94ec1dcd0351776c8525baf65f5936a95fd39414" translate="yes" xml:space="preserve">
          <source>The syntax of the &lt;code&gt;if&lt;/code&gt; command is:</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 명령 의 구문 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1ca84b4cf40aa870bc7a9434cdbbcf620bc46e31" translate="yes" xml:space="preserve">
          <source>The syntax of the &lt;code&gt;until&lt;/code&gt; command is:</source>
          <target state="translated">&lt;code&gt;until&lt;/code&gt; 명령 의 구문 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5997dd0fe5383486f475a01e977e6d7562319f43" translate="yes" xml:space="preserve">
          <source>The syntax of the &lt;code&gt;while&lt;/code&gt; command is:</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 명령 의 구문 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4cb5a4878d4824a6e3cc97693f13a3d7af45ba70" translate="yes" xml:space="preserve">
          <source>The text</source>
          <target state="translated">텍스트</target>
        </trans-unit>
        <trans-unit id="b2677043af3f5a768ae74d245381c283718fb041" translate="yes" xml:space="preserve">
          <source>The text after the &amp;lsquo;</source>
          <target state="translated">'다음의 텍스트</target>
        </trans-unit>
        <trans-unit id="039ba39464b2a648b548e0b817d33ee8e5ee39a0" translate="yes" xml:space="preserve">
          <source>The time, in 12-hour HH:MM:SS format.</source>
          <target state="translated">12 시간 HH : MM : SS 형식의 시간입니다.</target>
        </trans-unit>
        <trans-unit id="2947cf4592e14132541d8fa3e6d64c9f4e395f81" translate="yes" xml:space="preserve">
          <source>The time, in 12-hour am/pm format.</source>
          <target state="translated">오전 12시 / 오후 형식의 시간입니다.</target>
        </trans-unit>
        <trans-unit id="8fa95493f6e19849ab7227b92efebe0c1e71c5b9" translate="yes" xml:space="preserve">
          <source>The time, in 24-hour HH:MM format.</source>
          <target state="translated">24 시간 HH : MM 형식의 시간입니다.</target>
        </trans-unit>
        <trans-unit id="c3d065f007cd9dd11288efaacb92822ea86c8464" translate="yes" xml:space="preserve">
          <source>The time, in 24-hour HH:MM:SS format.</source>
          <target state="translated">24 시간 HH : MM : SS 형식의 시간입니다.</target>
        </trans-unit>
        <trans-unit id="546c59017480fec7e5615dbe0528ae2a9afeb0a3" translate="yes" xml:space="preserve">
          <source>The types of commands you can use.</source>
          <target state="translated">사용할 수있는 명령 유형.</target>
        </trans-unit>
        <trans-unit id="ff955a1de3f03a21fca8ad8b7504d2f3da2a59f4" translate="yes" xml:space="preserve">
          <source>The username of the current user.</source>
          <target state="translated">현재 사용자의 사용자 이름</target>
        </trans-unit>
        <trans-unit id="44f04f240cded95f75a32464630957f4300c35e8" translate="yes" xml:space="preserve">
          <source>The value is used to set the shell&amp;rsquo;s compatibility level. See &lt;a href=&quot;the-shopt-builtin#The-Shopt-Builtin&quot;&gt;The Shopt Builtin&lt;/a&gt;, for a description of the various compatibility levels and their effects. The value may be a decimal number (e.g., 4.2) or an integer (e.g., 42) corresponding to the desired compatibility level. If &lt;code&gt;BASH_COMPAT&lt;/code&gt; is unset or set to the empty string, the compatibility level is set to the default for the current version. If &lt;code&gt;BASH_COMPAT&lt;/code&gt; is set to a value that is not one of the valid compatibility levels, the shell prints an error message and sets the compatibility level to the default for the current version. The valid compatibility levels correspond to the compatibility options accepted by the &lt;code&gt;shopt&lt;/code&gt; builtin described above (for example, &lt;var&gt;compat42&lt;/var&gt; means that 4.2 and 42 are valid values). The current version is also a valid value.</source>
          <target state="translated">이 값은 쉘의 호환성 수준을 설정하는 데 사용됩니다. 다양한 호환성 수준과 그 효과에 대한 설명은 &lt;a href=&quot;the-shopt-builtin#The-Shopt-Builtin&quot;&gt;Shopt Builtin을&lt;/a&gt; 참조하십시오 . 값은 원하는 호환성 레벨에 대응하는 10 진수 (예를 들어, 4.2) 또는 정수 (예를 들어, 42) 일 수있다. 경우 &lt;code&gt;BASH_COMPAT&lt;/code&gt; 이 빈 문자열로 설정 해제 또는 설정되어 호환성 수준은 현재 버전의 기본값으로 설정됩니다. 경우 &lt;code&gt;BASH_COMPAT&lt;/code&gt; 가 유효한 호환성 수준 중 하나가 아닌 값으로 설정되고, 쉘은 에러 메시지를 출력하고 현재 버전의 기본에 호환성 수준을 설정합니다. 유효한 호환성 수준 은 위에서 설명한 &lt;code&gt;shopt&lt;/code&gt; 내장 (예 : &lt;var&gt;compat42&lt;/var&gt; )에서 허용하는 호환성 옵션에 해당합니다.4.2와 42가 유효한 값임을 의미합니다). 현재 버전도 유효한 값입니다.</target>
        </trans-unit>
        <trans-unit id="fd85921f250378d8ae629c564190aa36eee3643f" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$HOME&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$HOME&lt;/code&gt; 의 가치</target>
        </trans-unit>
        <trans-unit id="0f98eb18117382268ac2fdda01b7fb5e78dc5a17" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;MACHTYPE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MACHTYPE&lt;/code&gt; 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="f0bd6195d8ca24500579dfc5b25501a8dbcc48b7" translate="yes" xml:space="preserve">
          <source>The value of the last option argument processed by the &lt;code&gt;getopts&lt;/code&gt; builtin.</source>
          <target state="translated">&lt;code&gt;getopts&lt;/code&gt; 내장에서 처리 한 마지막 옵션 인수의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="1c799dffdb48e568cebb24d89b06c4c19963f103" translate="yes" xml:space="preserve">
          <source>The value of the variable &lt;code&gt;PROMPT_COMMAND&lt;/code&gt; is examined just before Bash prints each primary prompt. If &lt;code&gt;PROMPT_COMMAND&lt;/code&gt; is set and has a non-null value, then the value is executed just as if it had been typed on the command line.</source>
          <target state="translated">변수 &lt;code&gt;PROMPT_COMMAND&lt;/code&gt; 의 값은 Bash가 각 기본 프롬프트를 인쇄하기 직전에 검사됩니다. 경우 &lt;code&gt;PROMPT_COMMAND&lt;/code&gt; 가 설정하고 null이 아닌 값을 가지고있다가 명령 행에 입력했던 것처럼, 그 값이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="df0402efd8dde69c4d2f33edcea256ddb23b3c45" translate="yes" xml:space="preserve">
          <source>The value of this parameter is expanded like &lt;var&gt;PS1&lt;/var&gt; and displayed by interactive shells after reading a command and before the command is executed.</source>
          <target state="translated">이 매개 변수의 값은 &lt;var&gt;PS1&lt;/var&gt; 처럼 확장되고 명령을 읽은 후 명령이 실행되기 전에 대화식 쉘에 의해 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="25d045943c08d9fa184f14d59e811d5662ab8e94" translate="yes" xml:space="preserve">
          <source>The value of this parameter is expanded like &lt;var&gt;PS1&lt;/var&gt; and the expanded value is the prompt printed before the command line is echoed when the</source>
          <target state="translated">이 매개 변수의 값은 &lt;var&gt;PS1&lt;/var&gt; 과 같이 확장되며 확장 된 값은 명령 행이 에코 될 때 인쇄 된 프롬프트입니다.</target>
        </trans-unit>
        <trans-unit id="c2069a853e7e4c352256c651bc9711895ad4aea0" translate="yes" xml:space="preserve">
          <source>The value of this parameter is used as a format string specifying how the timing information for pipelines prefixed with the &lt;code&gt;time&lt;/code&gt; reserved word should be displayed. The &amp;lsquo;</source>
          <target state="translated">이 매개 변수의 값은 &lt;code&gt;time&lt;/code&gt; 예약어가 접두어로 붙은 파이프 라인의 타이밍 정보가 표시되는 방법을 지정하는 형식 문자열로 사용 됩니다. '</target>
        </trans-unit>
        <trans-unit id="3d1c9f8bb4dfddf7179168d82d2de258443de2eb" translate="yes" xml:space="preserve">
          <source>The value of this variable is used as the prompt for the &lt;code&gt;select&lt;/code&gt; command. If this variable is not set, the &lt;code&gt;select&lt;/code&gt; command prompts with &amp;lsquo;</source>
          <target state="translated">이 변수의 값은 &lt;code&gt;select&lt;/code&gt; 명령 의 프롬프트로 사용됩니다 . 이 변수를 설정하지 않으면 &lt;code&gt;select&lt;/code&gt; 명령에 '</target>
        </trans-unit>
        <trans-unit id="a6d1661055dab5ddd2b22885205d0882c08bf298" translate="yes" xml:space="preserve">
          <source>The value returned by a command to its caller. The value is restricted to eight bits, so the maximum value is 255.</source>
          <target state="translated">명령이 호출자에게 리턴 한 값. 값은 8 비트로 제한되므로 최대 값은 255입니다.</target>
        </trans-unit>
        <trans-unit id="148bb77806c5b1ec4dfcfb34ad15d87996bd4d0d" translate="yes" xml:space="preserve">
          <source>The variable is to be treated as an integer; arithmetic evaluation (see &lt;a href=&quot;shell-arithmetic#Shell-Arithmetic&quot;&gt;Shell Arithmetic&lt;/a&gt;) is performed when the variable is assigned a value.</source>
          <target state="translated">변수는 정수로 취급됩니다. 변수에 값이 할당되면 산술 평가 ( &lt;a href=&quot;shell-arithmetic#Shell-Arithmetic&quot;&gt;쉘 산술&lt;/a&gt; 참조 )가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b39bf8e1552fff49229a38ab03b9c35eb7c5fe33" translate="yes" xml:space="preserve">
          <source>The version number of Bash.</source>
          <target state="translated">Bash의 버전 번호입니다.</target>
        </trans-unit>
        <trans-unit id="a11b6fbf8320b54f58c60bf5fbc2ab78318d291f" translate="yes" xml:space="preserve">
          <source>The version number of the current instance of Bash.</source>
          <target state="translated">현재 Bash 인스턴스의 버전 번호입니다.</target>
        </trans-unit>
        <trans-unit id="f30c7f23d4e6f3d476f2e127031ef6f4ed2a1b01" translate="yes" xml:space="preserve">
          <source>The version of Bash (e.g., 2.00)</source>
          <target state="translated">배쉬 버전 (예 : 2.00)</target>
        </trans-unit>
        <trans-unit id="027d950e271c78503f04d5e7dffcabc091968d50" translate="yes" xml:space="preserve">
          <source>The word before point is treated as a pattern for pathname expansion, and the list of matching file names is inserted, replacing the word. If a numeric argument is supplied, a &amp;lsquo;</source>
          <target state="translated">포인트 앞의 단어는 경로 이름 확장을위한 패턴으로 취급되며 일치하는 파일 이름 목록이 삽입되어 단어를 대체합니다. 숫자 인수가 제공되면 '</target>
        </trans-unit>
        <trans-unit id="222c4b4554c8b6901e2325416221a577860ca250" translate="yes" xml:space="preserve">
          <source>The word before point is treated as a pattern for pathname expansion, with an asterisk implicitly appended. This pattern is used to generate a list of matching file names for possible completions.</source>
          <target state="translated">포인트 이전의 단어는 별표가 암시 적으로 추가 된 경로 이름 확장 패턴으로 취급됩니다. 이 패턴은 가능한 완료를 위해 일치하는 파일 이름 목록을 생성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0c65ac33cabff828f2aa8f1e90a8750474ac6d6c" translate="yes" xml:space="preserve">
          <source>The word following the redirection operator in the following descriptions, unless otherwise noted, is subjected to brace expansion, tilde expansion, parameter expansion, command substitution, arithmetic expansion, quote removal, filename expansion, and word splitting. If it expands to more than one word, Bash reports an error.</source>
          <target state="translated">달리 언급되지 않는 한, 이하의 설명에서 리디렉션 연산자 다음의 단어는 중괄호 확장, 틸드 확장, 파라미터 확장, 명령 대체, 산술 확장, 따옴표 제거, 파일 이름 확장 및 단어 분할이 적용된다. 둘 이상의 단어로 확장되면 Bash는 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="346079daa02f2cb31ed65b06f1366a24cd782ecd" translate="yes" xml:space="preserve">
          <source>The word matched by the most recent &amp;lsquo;</source>
          <target state="translated">가장 최근의 단어와 일치하는 단어</target>
        </trans-unit>
        <trans-unit id="10e9087ca60e5e8a54425de161a2d02c0f440cfc" translate="yes" xml:space="preserve">
          <source>The words are assigned to sequential indices of the array variable &lt;var&gt;aname&lt;/var&gt;, starting at 0. All elements are removed from &lt;var&gt;aname&lt;/var&gt; before the assignment. Other &lt;var&gt;name&lt;/var&gt; arguments are ignored.</source>
          <target state="translated">단어는 0부터 시작 하여 배열 변수 &lt;var&gt;aname&lt;/var&gt; 의 순차적 인덱스에 할당됩니다. 할당 전에 모든 요소가 &lt;var&gt;aname&lt;/var&gt; 에서 제거됩니다 . 다른 &lt;var&gt;name&lt;/var&gt; 인수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="40868cb137c232e64b231908d1d301657c99868c" translate="yes" xml:space="preserve">
          <source>The words that are not variable assignments or redirections are expanded (see &lt;a href=&quot;shell-expansions#Shell-Expansions&quot;&gt;Shell Expansions&lt;/a&gt;). If any words remain after expansion, the first word is taken to be the name of the command and the remaining words are the arguments.</source>
          <target state="translated">변수 할당 또는 방향 전환이 아닌 단어가 확장됩니다 ( &lt;a href=&quot;shell-expansions#Shell-Expansions&quot;&gt;쉘 확장&lt;/a&gt; 참조 ). 확장 후에도 단어가 남아 있으면 첫 번째 단어는 명령의 이름으로 간주되고 나머지 단어는 인수입니다.</target>
        </trans-unit>
        <trans-unit id="1115f35bbb1c2198812247bacb427d5941c313a5" translate="yes" xml:space="preserve">
          <source>The words that the parser has marked as variable assignments (those preceding the command name) and redirections are saved for later processing.</source>
          <target state="translated">파서가 변수 할당 (명령 이름 앞에 오는 것)으로 표시 한 단어와 리디렉션은 나중에 처리하기 위해 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="34835e8862f137b6b67b76e845cf0916c66a7d74" translate="yes" xml:space="preserve">
          <source>There are a number of ways to refer to a job in the shell. The character &amp;lsquo;</source>
          <target state="translated">쉘에서 작업을 참조하는 방법에는 여러 가지가 있습니다. 캐릭터 '</target>
        </trans-unit>
        <trans-unit id="5380837a8dc4b937f8c653fd992daf4e5508db28" translate="yes" xml:space="preserve">
          <source>There are only a few basic constructs allowed in the Readline init file. Blank lines are ignored. Lines beginning with a &amp;lsquo;</source>
          <target state="translated">Readline init 파일에는 몇 가지 기본 구성 만 허용됩니다. 빈 줄은 무시됩니다. '로 시작하는 줄</target>
        </trans-unit>
        <trans-unit id="8422d6b3111c08b7087bda621a6b140c5d376882" translate="yes" xml:space="preserve">
          <source>There are several</source>
          <target state="translated">몇 가지가 있습니다</target>
        </trans-unit>
        <trans-unit id="355ae59a61b832450204db67a5d845ba171bf393" translate="yes" xml:space="preserve">
          <source>There are several single-character options that may be supplied at invocation which are not available with the &lt;code&gt;set&lt;/code&gt; builtin.</source>
          <target state="translated">호출시 제공 될 수있는 단일 문자 옵션이 여러 개 있으며 내장 된 &lt;code&gt;set&lt;/code&gt; 에서는 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="da410ea10b5c65b982eecff9f69deb78b7882c49" translate="yes" xml:space="preserve">
          <source>There are three quoting mechanisms: the &lt;var&gt;escape character&lt;/var&gt;, single quotes, and double quotes.</source>
          <target state="translated">&lt;var&gt;escape character&lt;/var&gt; , 작은 따옴표 및 큰 따옴표 등 세 가지 인용 메커니즘이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="57dcc9600ee50cb4594d545bc4b2e3f3a34a4fa9" translate="yes" xml:space="preserve">
          <source>There are two formats for redirecting standard output and standard error:</source>
          <target state="translated">표준 출력 및 표준 오류를 재 지정하기위한 두 가지 형식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4cc96780f245ab386ceb829f056c264700d3183" translate="yes" xml:space="preserve">
          <source>There are ways to run commands in parallel that are not built into Bash. GNU Parallel is a tool to do just that.</source>
          <target state="translated">Bash에 내장되지 않은 명령을 병렬로 실행하는 방법이 있습니다. GNU Parallel은 바로이를위한 도구입니다.</target>
        </trans-unit>
        <trans-unit id="f5777c1669d42cb1acb2551be9d5476e2c723421" translate="yes" xml:space="preserve">
          <source>There is no mechanism for using arguments in the replacement text, as in &lt;code&gt;csh&lt;/code&gt;. If arguments are needed, a shell function should be used (see &lt;a href=&quot;shell-functions#Shell-Functions&quot;&gt;Shell Functions&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;csh&lt;/code&gt; 에서와 같이 대체 텍스트에서 인수를 사용하는 메커니즘은 없습니다 . 인수가 필요한 경우 쉘 함수를 사용해야합니다 ( &lt;a href=&quot;shell-functions#Shell-Functions&quot;&gt;쉘 함수&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c5f46df76fa16611d124197c9368dfd67cc3688c" translate="yes" xml:space="preserve">
          <source>There is other &lt;small&gt;POSIX&lt;/small&gt; behavior that Bash does not implement by default even when in &lt;small&gt;POSIX&lt;/small&gt; mode. Specifically:</source>
          <target state="translated">&lt;small&gt;POSIX&lt;/small&gt; 모드 에서도 Bash가 기본적으로 구현하지 않는 다른 &lt;small&gt;POSIX&lt;/small&gt; 동작이 있습니다. 구체적으로 특별히:&lt;small&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="e9ac2201cee1badcd944531174bf1efb539f9461" translate="yes" xml:space="preserve">
          <source>There is some support for dynamically modifying completions. This is most useful when used in combination with a default completion specified with</source>
          <target state="translated">완료를 동적으로 수정하기위한 일부 지원이 있습니다. 이 옵션은 지정된 기본 완료와 함께 사용할 때 가장 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a5be4ef90f6dd62a6f8fcf59741822b9b02eb595" translate="yes" xml:space="preserve">
          <source>There may be an arbitrary number of &lt;code&gt;case&lt;/code&gt; clauses, each terminated by a &amp;lsquo;</source>
          <target state="translated">임의의 수의 &lt;code&gt;case&lt;/code&gt; 절이 있을 수 있으며 각 절은 '</target>
        </trans-unit>
        <trans-unit id="e81c82a23500da34f5f3f9852232cef329cf49a0" translate="yes" xml:space="preserve">
          <source>There may be some features &lt;code&gt;configure&lt;/code&gt; can not figure out automatically, but need to determine by the type of host Bash will run on. Usually &lt;code&gt;configure&lt;/code&gt; can figure that out, but if it prints a message saying it can not guess the host type, give it the</source>
          <target state="translated">&lt;code&gt;configure&lt;/code&gt; 가 자동으로 파악할 수없는 일부 기능이있을 수 있지만 Bash가 실행될 호스트 유형에 따라 결정해야합니다. 일반적으로 &lt;code&gt;configure&lt;/code&gt; 는이를 알아낼 수 있지만 호스트 유형을 추측 할 수 없다는 메시지를 인쇄하면</target>
        </trans-unit>
        <trans-unit id="9015989b924a2ac88a0ae4fbf68f6592b8c17a42" translate="yes" xml:space="preserve">
          <source>These are installation instructions for Bash.</source>
          <target state="translated">다음은 Bash 설치 지침입니다.</target>
        </trans-unit>
        <trans-unit id="7aedb4b233a7d36f1ed706bd4fe3eb06a42c78b4" translate="yes" xml:space="preserve">
          <source>These are the &lt;small&gt;POSIX&lt;/small&gt; special builtins:</source>
          <target state="translated">&lt;small&gt;POSIX&lt;/small&gt; 특수 내장 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a64944b0b14b546d025ea7cbc1a0ffafc5f3a745" translate="yes" xml:space="preserve">
          <source>These definitions are used throughout the remainder of this manual.</source>
          <target state="translated">이 정의는이 설명서의 나머지 부분에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="52445fd9af51159ab52902e33535ffe11eaa99ca" translate="yes" xml:space="preserve">
          <source>These examples show how you can use substring expansion with indexed arrays:</source>
          <target state="translated">이 예제는 인덱스 배열에서 하위 문자열 확장을 사용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="36d357d109541ac67ed9625400ae8662ccbda188" translate="yes" xml:space="preserve">
          <source>These restrictions are enforced after any startup files are read.</source>
          <target state="translated">이러한 제한은 시작 파일을 읽은 후에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="7d6cba66425428991d68cbdaa44f3c3bf5b58d81" translate="yes" xml:space="preserve">
          <source>These variables are set or used by Bash, but other shells do not normally treat them specially.</source>
          <target state="translated">이러한 변수는 Bash에서 설정하거나 사용하지만 다른 쉘은 일반적으로 특수하게 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1156fdd4019160ed61ec17c8bdc9f4ed741b6727" translate="yes" xml:space="preserve">
          <source>This License applies to any manual or other work, in any medium, that contains a notice placed by the copyright holder saying it can be distributed under the terms of this License. Such a notice grants a world-wide, royalty-free license, unlimited in duration, to use that work under the conditions stated herein. The &amp;ldquo;Document&amp;rdquo;, below, refers to any such manual or work. Any member of the public is a licensee, and is addressed as &amp;ldquo;you&amp;rdquo;. You accept the license if you copy, modify or distribute the work in a way requiring permission under copyright law.</source>
          <target state="translated">이 라이센스는 본 라이센스 조건에 따라 배포 될 수 있다는 저작권 소유자의 고지가 포함 된 모든 매체의 모든 매뉴얼 또는 기타 작업에 적용됩니다. 이러한 통지는 여기에 명시된 조건 하에서 해당 저작물을 사용할 수있는 기간에 제한이없는 전 세계 로열티가없는 라이센스를 부여합니다. 아래의 &quot;문서&quot;는 그러한 매뉴얼 또는 작업을 나타냅니다. 일반인은 라이센스 사용자이며 &quot;귀하&quot;로 처리됩니다. 저작권법에 따라 허가가 필요한 방식으로 저작물을 복사, 수정 또는 배포하는 경우 라이센스에 동의합니다.</target>
        </trans-unit>
        <trans-unit id="d7172d540090de5c8986abd8471f45ad42900b54" translate="yes" xml:space="preserve">
          <source>This License is a kind of &amp;ldquo;copyleft&amp;rdquo;, which means that derivative works of the document must themselves be free in the same sense. It complements the GNU General Public License, which is a copyleft license designed for free software.</source>
          <target state="translated">이 라이센스는 일종의 &quot;카피 레프트 (copyleft)&quot;입니다. 즉, 문서의 파생 작품 자체도 같은 의미에서 자유로 워야합니다. 자유 소프트웨어 용으로 설계된 카피 레프트 라이센스 인 GNU General Public License를 보완합니다.</target>
        </trans-unit>
        <trans-unit id="9774638f742e8e76ad20a90b73b698f411ba8820" translate="yes" xml:space="preserve">
          <source>This alters the default behavior of the completion functions in a fashion similar to &lt;var&gt;show-all-if-ambiguous&lt;/var&gt;. If set to &amp;lsquo;</source>
          <target state="translated">이는 &lt;var&gt;show-all-if-ambiguous&lt;/var&gt; 와 유사한 방식으로 완료 함수의 기본 동작을 변경 합니다 . '로 설정하면</target>
        </trans-unit>
        <trans-unit id="8332763d55887221896b817cdc3faab9f19c83f2" translate="yes" xml:space="preserve">
          <source>This alters the default behavior of the completion functions. If set to &amp;lsquo;</source>
          <target state="translated">완료 기능의 기본 동작이 변경됩니다. '로 설정하면</target>
        </trans-unit>
        <trans-unit id="3e34f2d1e6f278b2c604c84a983d396b66ab2ed0" translate="yes" xml:space="preserve">
          <source>This builds a Bash binary that produces profiling information to be processed by &lt;code&gt;gprof&lt;/code&gt; each time it is executed.</source>
          <target state="translated">이것은 &lt;code&gt;gprof&lt;/code&gt; 가 실행될 때마다 처리 할 프로파일 링 정보를 생성하는 Bash 바이너리를 빌드합니다 .</target>
        </trans-unit>
        <trans-unit id="c3cd4b02660da5e86fd9458a00db29bf6ba4c32f" translate="yes" xml:space="preserve">
          <source>This builtin allows you to change additional shell optional behavior.</source>
          <target state="translated">이 내장 기능을 사용하면 추가 쉘 선택적 동작을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51c09c163709e0806212e0c4d85c59c0e76dee4c" translate="yes" xml:space="preserve">
          <source>This builtin is so complicated that it deserves its own section. &lt;code&gt;set&lt;/code&gt; allows you to change the values of shell options and set the positional parameters, or to display the names and values of shell variables.</source>
          <target state="translated">이 내장은 너무 복잡하여 자체 섹션이 필요합니다. &lt;code&gt;set&lt;/code&gt; 을 사용하면 쉘 옵션의 값을 변경하고 위치 매개 변수를 설정하거나 쉘 변수의 이름과 값을 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aec1f6282f72efc73514af3bcef7701cafdc1347" translate="yes" xml:space="preserve">
          <source>This causes Bash to be linked statically, if &lt;code&gt;gcc&lt;/code&gt; is being used. This could be used to build a version to use as root&amp;rsquo;s shell.</source>
          <target state="translated">&lt;code&gt;gcc&lt;/code&gt; 를 사용하는 경우 Bash가 정적으로 링크 됩니다. 루트 셸로 사용할 버전을 빌드하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b444cedd05507c2879b16fcc79445c70923c1a2" translate="yes" xml:space="preserve">
          <source>This chapter briefly summarizes the shell&amp;rsquo;s &amp;lsquo;building blocks&amp;rsquo;: commands, control structures, shell functions, shell</source>
          <target state="translated">이 장에서는 쉘의 '빌딩 블록'(명령, 제어 구조, 쉘 기능, 쉘)을 간략하게 요약합니다.</target>
        </trans-unit>
        <trans-unit id="5550e13176089ed86a46ffd518b0119005cc3ed7" translate="yes" xml:space="preserve">
          <source>This chapter describes features unique to Bash.</source>
          <target state="translated">이 장에서는 Bash 고유의 기능에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1b26127352667f52293bc4f0daa266336d9c3761" translate="yes" xml:space="preserve">
          <source>This chapter describes how to use the &lt;small&gt;GNU&lt;/small&gt; History Library interactively, from a user&amp;rsquo;s standpoint. It should be considered a user&amp;rsquo;s guide. For information on using the &lt;small&gt;GNU&lt;/small&gt; History Library in other programs, see the &lt;small&gt;GNU&lt;/small&gt; Readline Library Manual.</source>
          <target state="translated">이 장에서는 사용자 관점에서 대화 형으로 &lt;small&gt;GNU&lt;/small&gt; History Library 를 사용하는 방법에 대해 설명합니다 . 사용자 안내서로 간주해야합니다. 다른 프로그램에서 &lt;small&gt;GNU&lt;/small&gt; History Library 를 사용하는 것에 대한 정보 는 &lt;small&gt;GNU&lt;/small&gt; Readline Library Manual을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="de15b35f7c50f67a3ef7e4a47233594367c7e8b4" translate="yes" xml:space="preserve">
          <source>This chapter describes the basic features of the &lt;small&gt;GNU&lt;/small&gt; command line editing interface. Command line editing is provided by the Readline library, which is used by several different programs, including Bash. Command line editing is enabled by default when using an interactive shell, unless the</source>
          <target state="translated">이 장에서는 &lt;small&gt;GNU&lt;/small&gt; 명령 줄 편집 인터페이스 의 기본 기능에 대해 설명합니다 . 명령 줄 편집은 Bash를 포함한 여러 다른 프로그램에서 사용되는 Readline 라이브러리에서 제공됩니다. 대화식 쉘을 사용하는 경우 기본적으로 명령 행 편집이 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="03ef6306676cfcd40ae8b20738ea19d430016d4e" translate="yes" xml:space="preserve">
          <source>This chapter describes the shell variables that Bash uses. Bash automatically assigns default values to a number of variables.</source>
          <target state="translated">이 장에서는 Bash가 사용하는 쉘 변수에 대해 설명합니다. Bash는 자동으로 여러 변수에 기본값을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="c09354d1984a5765dc8136f0cec8a9d7bd70fd4d" translate="yes" xml:space="preserve">
          <source>This chapter discusses what job control is, how it works, and how Bash allows you to access its facilities.</source>
          <target state="translated">이 장에서는 작업 제어 기능, 작동 방식 및 Bash를 사용하여 시설에 액세스하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f2e3b64c94896242bb0f5f8bf5c5ae3d1ee830d8" translate="yes" xml:space="preserve">
          <source>This chapter provides basic instructions for installing Bash on the various supported platforms. The distribution supports the &lt;small&gt;GNU&lt;/small&gt; operating systems, nearly every version of Unix, and several non-Unix systems such as BeOS and Interix. Other independent ports exist for &lt;small&gt;MS-DOS&lt;/small&gt;, &lt;small&gt;OS/2&lt;/small&gt;, and Windows platforms.</source>
          <target state="translated">이 장에서는 다양한 지원 플랫폼에 Bash를 설치하기위한 기본 지침을 제공합니다. 이 배포판은 &lt;small&gt;GNU&lt;/small&gt; 운영 체제, 거의 모든 Unix 버전 및 BeOS 및 Interix와 같은 여러 비 유닉스 시스템을 지원합니다. &lt;small&gt;MS-DOS&lt;/small&gt; , &lt;small&gt;OS / 2&lt;/small&gt; 및 Windows 플랫폼에 대한 다른 독립 포트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="49e1d439d827302ed752f66204ca921eb96c58f6" translate="yes" xml:space="preserve">
          <source>This command, as seen in the previous example, terminates an &lt;code&gt;$if&lt;/code&gt; command.</source>
          <target state="translated">이전 예에서 볼 수 있듯이이 명령은 &lt;code&gt;$if&lt;/code&gt; 명령을 종료합니다 .</target>
        </trans-unit>
        <trans-unit id="fb0f85630397c158a20c2fa4d3ef1c1973ec8dcb" translate="yes" xml:space="preserve">
          <source>This construct allows both the standard output (file descriptor 1) and the standard error output (file descriptor 2) to be appended to the file whose name is the expansion of &lt;var&gt;word&lt;/var&gt;.</source>
          <target state="translated">이 구문을 사용하면 표준 출력 (파일 설명자 1)과 표준 오류 출력 (파일 설명자 2)을 모두 이름이 &lt;var&gt;word&lt;/var&gt; 확장 인 파일에 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="56799de86f1e6d6fa96e1e930b36c93db6384595" translate="yes" xml:space="preserve">
          <source>This construct allows both the standard output (file descriptor 1) and the standard error output (file descriptor 2) to be redirected to the file whose name is the expansion of &lt;var&gt;word&lt;/var&gt;.</source>
          <target state="translated">이 구문을 사용하면 표준 출력 (파일 설명자 1)과 표준 오류 출력 (파일 설명자 2)을 모두 이름이 &lt;var&gt;word&lt;/var&gt; 확장 인 파일로 리디렉션 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="098091aa94ef2f9c52549d501cc96335db2b9a80" translate="yes" xml:space="preserve">
          <source>This construct is typically used as shorthand when the common prefix of the strings to be generated is longer than in the above example:</source>
          <target state="translated">이 구문은 일반적으로 생성 될 문자열의 공통 접두어가 위의 예보다 길면 속기로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="904303c6dcba829a9fb6ebeeb4ed82e34d87e5b5" translate="yes" xml:space="preserve">
          <source>This creates a coprocess named &lt;var&gt;NAME&lt;/var&gt;. If &lt;var&gt;NAME&lt;/var&gt; is not supplied, the default name is &lt;var&gt;COPROC&lt;/var&gt;. &lt;var&gt;NAME&lt;/var&gt; must not be supplied if &lt;var&gt;command&lt;/var&gt; is a simple command (see &lt;a href=&quot;simple-commands#Simple-Commands&quot;&gt;Simple Commands&lt;/a&gt;); otherwise, it is interpreted as the first word of the simple command.</source>
          <target state="translated">&lt;var&gt;NAME&lt;/var&gt; 이라는 공동 프로세스가 작성 됩니다. 경우 &lt;var&gt;NAME&lt;/var&gt; 제공되지 않으면 기본 이름입니다 &lt;var&gt;COPROC&lt;/var&gt; . &lt;var&gt;command&lt;/var&gt; 가 간단한 명령 인 경우 &lt;var&gt;NAME&lt;/var&gt; 을 제공하면 안됩니다 ( &lt;a href=&quot;simple-commands#Simple-Commands&quot;&gt;Simple Commands&lt;/a&gt; 참조 ). 그렇지 않으면 간단한 명령의 첫 단어로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="26a80e893b74901379cada236187c32722dce1a2" translate="yes" xml:space="preserve">
          <source>This defines a shell function named &lt;var&gt;name&lt;/var&gt;. The reserved word &lt;code&gt;function&lt;/code&gt; is optional. If the &lt;code&gt;function&lt;/code&gt; reserved word is supplied, the parentheses are optional. The &lt;var&gt;body&lt;/var&gt; of the function is the compound command &lt;var&gt;compound-command&lt;/var&gt; (see &lt;a href=&quot;compound-commands#Compound-Commands&quot;&gt;Compound Commands&lt;/a&gt;). That command is usually a &lt;var&gt;list&lt;/var&gt; enclosed between { and }, but may be any compound command listed above, with one exception: If the &lt;code&gt;function&lt;/code&gt; reserved word is used, but the parentheses are not supplied, the braces are required. &lt;var&gt;compound-command&lt;/var&gt; is executed whenever &lt;var&gt;name&lt;/var&gt; is specified as the name of a command. When the shell is in &lt;small&gt;POSIX&lt;/small&gt; mode (see &lt;a href=&quot;bash-posix-mode#Bash-POSIX-Mode&quot;&gt;Bash POSIX Mode&lt;/a&gt;), &lt;var&gt;name&lt;/var&gt; may not be the same as one of the special builtins (see &lt;a href=&quot;special-builtins#Special-Builtins&quot;&gt;Special Builtins&lt;/a&gt;). Any redirections (see &lt;a href=&quot;redirections#Redirections&quot;&gt;Redirections&lt;/a&gt;) associated with the shell function are performed when the function is executed.</source>
          <target state="translated">이것은 &lt;var&gt;name&lt;/var&gt; 이라는 쉘 함수를 정의합니다 . 예약어 &lt;code&gt;function&lt;/code&gt; 은 선택 사항입니다. 는 IF &lt;code&gt;function&lt;/code&gt; 예약 된 단어가 공급되고, 괄호는 선택 사항입니다. 함수 의 &lt;var&gt;body&lt;/var&gt; 은 복합 명령 &lt;var&gt;compound-command&lt;/var&gt; ( &lt;a href=&quot;compound-commands#Compound-Commands&quot;&gt;복합 명령&lt;/a&gt; 참조 ). 이 명령은 일반적으로 {와}로 묶인 &lt;var&gt;list&lt;/var&gt; 이지만 위에 나열된 복합 명령 일 수 있지만 한 가지 예외가 있습니다. &lt;code&gt;function&lt;/code&gt; 예약어를 사용하지만 괄호를 제공하지 않으면 중괄호가 필요합니다. &lt;var&gt;compound-command&lt;/var&gt; 은 &lt;var&gt;name&lt;/var&gt; 이 명령 이름 으로 지정 될 때마다 실행 됩니다. 껍질이 들어있을 때&lt;small&gt;POSIX의&lt;/small&gt; 모드 (참조 &lt;a href=&quot;bash-posix-mode#Bash-POSIX-Mode&quot;&gt;배쉬 POSIX 모드&lt;/a&gt; ), &lt;var&gt;name&lt;/var&gt; 특별 내장 매크로 중 하나 (볼과 다를 수 있습니다 &lt;a href=&quot;special-builtins#Special-Builtins&quot;&gt;특수 내장 명령을&lt;/a&gt; ). 상관 리디렉션 (참조 &lt;a href=&quot;redirections#Redirections&quot;&gt;리디렉션&lt;/a&gt; 함수가 실행될 때, 쉘과 연관된 기능)을 수행한다.</target>
        </trans-unit>
        <trans-unit id="72f7f5b4da998ab8df0644c5d407c25a95acfdf5" translate="yes" xml:space="preserve">
          <source>This directive takes a single filename as an argument and reads commands and bindings from that file. For example, the following directive reads from</source>
          <target state="translated">이 지시문은 단일 파일 이름을 인수로 사용하여 해당 파일에서 명령 및 바인딩을 읽습니다. 예를 들어 다음 지시문은</target>
        </trans-unit>
        <trans-unit id="a5118d015d00e4a360925cba156e434ce747bdac" translate="yes" xml:space="preserve">
          <source>This enables process substitution (see &lt;a href=&quot;process-substitution#Process-Substitution&quot;&gt;Process Substitution&lt;/a&gt;) if the operating system provides the necessary support.</source>
          <target state="translated">이 프로세스 치환 (참조 수 있도록 &lt;a href=&quot;process-substitution#Process-Substitution&quot;&gt;프로세스 대체를&lt;/a&gt; 운영 체제가 필요한 지원을 제공하는 경우).</target>
        </trans-unit>
        <trans-unit id="70ec920a9b1ef0bd197e2d02cb16baed84fbb992" translate="yes" xml:space="preserve">
          <source>This enables support for multibyte characters if the operating system provides the necessary support.</source>
          <target state="translated">운영 체제가 필요한 지원을 제공 할 경우 멀티 바이트 문자를 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="509f335377188e421365bec5bd4d4686ab18e530" translate="yes" xml:space="preserve">
          <source>This enables the job control features (see &lt;a href=&quot;job-control#Job-Control&quot;&gt;Job Control&lt;/a&gt;), if the operating system supports them.</source>
          <target state="translated">운영 체제에서 지원하는 경우 작업 제어 기능 ( &lt;a href=&quot;job-control#Job-Control&quot;&gt;작업 제어&lt;/a&gt; 참조)을 사용 가능하게 합니다.</target>
        </trans-unit>
        <trans-unit id="b69be3ac71af5df7545cc8a700149c2d3ee31783" translate="yes" xml:space="preserve">
          <source>This enables the special handling of filenames of the form &lt;code&gt;/dev/tcp/&lt;var&gt;host&lt;/var&gt;/&lt;var&gt;port&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;/dev/udp/&lt;var&gt;host&lt;/var&gt;/&lt;var&gt;port&lt;/var&gt;&lt;/code&gt; when used in redirections (see &lt;a href=&quot;redirections#Redirections&quot;&gt;Redirections&lt;/a&gt;).</source>
          <target state="translated">이 형식의 파일 이름의 특수 처리 수 &lt;code&gt;/dev/tcp/&lt;var&gt;host&lt;/var&gt;/&lt;var&gt;port&lt;/var&gt;&lt;/code&gt; 와 &lt;code&gt;/dev/udp/&lt;var&gt;host&lt;/var&gt;/&lt;var&gt;port&lt;/var&gt;&lt;/code&gt; 리디렉션 (참조에 사용하는 경우 &lt;a href=&quot;redirections#Redirections&quot;&gt;리디렉션을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="40a07c8bd3f0229d20c7c2f39de9b4875eb9f8a8" translate="yes" xml:space="preserve">
          <source>This expansion modifies the case of alphabetic characters in &lt;var&gt;parameter&lt;/var&gt;. The &lt;var&gt;pattern&lt;/var&gt; is expanded to produce a pattern just as in filename expansion. Each character in the expanded value of &lt;var&gt;parameter&lt;/var&gt; is tested against &lt;var&gt;pattern&lt;/var&gt;, and, if it matches the pattern, its case is converted. The pattern should not attempt to match more than one character. The &amp;lsquo;</source>
          <target state="translated">이 확장은 &lt;var&gt;parameter&lt;/var&gt; 의 알파벳 문자를 수정합니다 . &lt;var&gt;pattern&lt;/var&gt; 단지 파일 이름 확장에서 같은 패턴을 생성하기 위해 확장된다. 확장 된 &lt;var&gt;parameter&lt;/var&gt; 값의 각 문자는 &lt;var&gt;pattern&lt;/var&gt; 에 대해 테스트 되며 패턴과 일치하면 대소 문자가 변환됩니다. 패턴은 둘 이상의 문자와 일치하지 않아야합니다. '</target>
        </trans-unit>
        <trans-unit id="d61b2efd68e98c23f7678f3c3ce3e351db3fa92a" translate="yes" xml:space="preserve">
          <source>This function is intended to be bound to the &quot;bracketed paste&quot; escape sequence sent by some terminals, and such a binding is assigned by default. It allows Readline to insert the pasted text as a single unit without treating each character as if it had been read from the keyboard. The characters are inserted as if each one was bound to &lt;code&gt;self-insert&lt;/code&gt; instead of executing any editing commands.</source>
          <target state="translated">이 기능은 일부 터미널에서 전송 한 &quot;브래킷 붙여 넣기&quot;이스케이프 시퀀스에 바인딩되며 이러한 바인딩은 기본적으로 할당됩니다. Readline은 각 문자를 키보드에서 읽은 것처럼 취급하지 않고 붙여 넣은 텍스트를 단일 단위로 삽입 할 수 있습니다. 문자는 편집 명령을 실행하는 대신 각 문자가 자동 ​​삽입되는 것처럼 &lt;code&gt;self-insert&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="9e4672748e5ecd3cd3638310ccff2c686865681f" translate="yes" xml:space="preserve">
          <source>This is Edition 5.0, last updated 12 May 2019, of</source>
          <target state="translated">2019 년 5 월 12 일에 마지막으로 업데이트 된 Edition 5.0입니다.</target>
        </trans-unit>
        <trans-unit id="7a06df83bbef351306679950f41296c41140880a" translate="yes" xml:space="preserve">
          <source>This is another way to specify an argument. If this command is followed by one or more digits, optionally with a leading minus sign, those digits define the argument. If the command is followed by digits, executing &lt;code&gt;universal-argument&lt;/code&gt; again ends the numeric argument, but is otherwise ignored. As a special case, if this command is immediately followed by a character that is neither a digit nor minus sign, the argument count for the next command is multiplied by four. The argument count is initially one, so executing this function the first time makes the argument count four, a second time makes the argument count sixteen, and so on. By default, this is not bound to a key.</source>
          <target state="translated">이것은 인수를 지정하는 또 다른 방법입니다. 이 명령 다음에 선택적으로 선행 빼기 부호가있는 하나 이상의 숫자가 오는 경우 해당 숫자는 인수를 정의합니다. 명령 뒤에 숫자가 오는 경우, &lt;code&gt;universal-argument&lt;/code&gt; 다시 실행 하면 숫자 인수가 종료되지만 그렇지 않으면 무시됩니다. 특별한 경우로,이 명령 바로 뒤에 숫자 나 빼기 부호가 아닌 문자가 오는 경우 다음 명령의 인수 수에 4가 곱해집니다. 인수 개수는 처음에는 1이므로이 함수를 처음 실행하면 인수가 4 개가되고, 두 번째로 인수가 16 개가됩니다. 기본적으로 이것은 키에 바인딩되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="73605a5a3bbb20b86fcc0402bec934934a54ffb5" translate="yes" xml:space="preserve">
          <source>This is referred to as Substring Expansion. It expands to up to &lt;var&gt;length&lt;/var&gt; characters of the value of &lt;var&gt;parameter&lt;/var&gt; starting at the character specified by &lt;var&gt;offset&lt;/var&gt;. If &lt;var&gt;parameter&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">이것을 서브 스트링 확장이라고합니다. &lt;var&gt;offset&lt;/var&gt; 에 의해 지정된 문자에서 시작하여 &lt;var&gt;parameter&lt;/var&gt; 값의 최대 &lt;var&gt;length&lt;/var&gt; 문자 까지 확장됩니다 . 만약 &lt;var&gt;parameter&lt;/var&gt; '입니다</target>
        </trans-unit>
        <trans-unit id="151979d05e7240d88bf171daba8f2b58717bcf5a" translate="yes" xml:space="preserve">
          <source>This is semantically equivalent to</source>
          <target state="translated">이것은 의미 상으로</target>
        </trans-unit>
        <trans-unit id="0dbd560b0b0395be077529e37601cdce32273f75" translate="yes" xml:space="preserve">
          <source>This manual is meant as a brief introduction to features found in Bash. The Bash manual page should be used as the definitive reference on shell behavior.</source>
          <target state="translated">이 매뉴얼은 Bash의 기능에 대한 간략한 소개입니다. Bash 매뉴얼 페이지는 쉘 동작에 대한 결정적인 참조로 사용되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c093e6825af417675783ce091d281a9a95a59153" translate="yes" xml:space="preserve">
          <source>This option applies to the shell environment and each subshell environment separately (see &lt;a href=&quot;command-execution-environment#Command-Execution-Environment&quot;&gt;Command Execution Environment&lt;/a&gt;), and may cause subshells to exit before executing all the commands in the subshell.</source>
          <target state="translated">이 옵션은 쉘 환경과 각 서브 쉘 환경에 별도로 적용되며 ( &lt;a href=&quot;command-execution-environment#Command-Execution-Environment&quot;&gt;명령 실행 환경&lt;/a&gt; 참조 ) 서브 쉘에서 모든 명령을 실행하기 전에 서브 쉘이 종료 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42eafa62609fe5b37b24cded2464d5b80027b3dc" translate="yes" xml:space="preserve">
          <source>This produces a shell with minimal features, close to the historical Bourne shell.</source>
          <target state="translated">이것은 역사적인 Bourne 쉘에 가까운 최소한의 기능을 가진 쉘을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5b7e79b98ec0db3f559f5c9043a8f3f79dc69673" translate="yes" xml:space="preserve">
          <source>This section briefly describes the builtins which Bash inherits from the Bourne Shell, as well as the builtin commands which are unique to or have been extended in Bash.</source>
          <target state="translated">이 섹션에서는 Bash가 Bourne Shell에서 상속 한 내장 기능과 Bash에서 고유하거나 확장 된 내장 명령에 대해 간략하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f6d4766cf4327e831915497c7a2b7779015e37ea" translate="yes" xml:space="preserve">
          <source>This section describes Readline commands that may be bound to key sequences. You can list your key bindings by executing &lt;code&gt;bind&amp;nbsp;-P&lt;/code&gt; or, for a more terse format, suitable for an &lt;var&gt;inputrc&lt;/var&gt; file, &lt;code&gt;bind&amp;nbsp;-p&lt;/code&gt;. (See &lt;a href=&quot;bash-builtins#Bash-Builtins&quot;&gt;Bash Builtins&lt;/a&gt;.) Command names without an accompanying key sequence are unbound by default.</source>
          <target state="translated">이 섹션에서는 키 시퀀스에 바인딩 될 수있는 Readline 명령에 대해 설명합니다. &lt;code&gt;bind&amp;nbsp;-P&lt;/code&gt; 또는보다 간결한 형식의 경우 &lt;var&gt;inputrc&lt;/var&gt; 파일에 적합한 &lt;code&gt;bind&amp;nbsp;-p&lt;/code&gt; 를 실행하여 키 바인딩을 나열 할 수 있습니다 . ( &lt;a href=&quot;bash-builtins#Bash-Builtins&quot;&gt;Bash Builtins&lt;/a&gt; 참조 ) 키 시퀀스가없는 명령 이름은 기본적으로 바인딩되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05c2933a9fb91b2574d1896fdb5a5d064ade83dc" translate="yes" xml:space="preserve">
          <source>This section describes builtin commands which are unique to or have been extended in Bash. Some of these commands are specified in the &lt;small&gt;POSIX&lt;/small&gt; standard.</source>
          <target state="translated">이 섹션에서는 Bash에 고유하거나 확장 된 내장 명령에 대해 설명합니다. 이러한 명령 중 일부는 &lt;small&gt;POSIX&lt;/small&gt; 표준에 지정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="021d6317bb52d7c98080712da2ab2b13bfecd196" translate="yes" xml:space="preserve">
          <source>This section describes how Bash executes its startup files. If any of the files exist but cannot be read, Bash reports an error. Tildes are expanded in filenames as described above under Tilde Expansion (see &lt;a href=&quot;tilde-expansion#Tilde-Expansion&quot;&gt;Tilde Expansion&lt;/a&gt;).</source>
          <target state="translated">이 섹션에서는 Bash가 시작 파일을 실행하는 방법에 대해 설명합니다. 파일이 있지만 읽을 수없는 경우 Bash는 오류를보고합니다. 물결표는 위에서 물결표 확장에 설명 된대로 파일 이름으로 확장됩니다 ( &lt;a href=&quot;tilde-expansion#Tilde-Expansion&quot;&gt;물결표 확장&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3f151c5c21237c924798b84115f0053c53cfacfd" translate="yes" xml:space="preserve">
          <source>This syntax is also accepted by the &lt;code&gt;declare&lt;/code&gt; builtin. Individual array elements may be assigned to using the &lt;code&gt;&lt;var&gt;name&lt;/var&gt;[&lt;var&gt;subscript&lt;/var&gt;]=&lt;var&gt;value&lt;/var&gt;&lt;/code&gt; syntax introduced above.</source>
          <target state="translated">이 구문은 &lt;code&gt;declare&lt;/code&gt; 내장 선언 에서도 허용됩니다 . 개별 배열 요소는 위에서 소개 된 &lt;code&gt;&lt;var&gt;name&lt;/var&gt;[&lt;var&gt;subscript&lt;/var&gt;]=&lt;var&gt;value&lt;/var&gt;&lt;/code&gt; 구문 을 사용하여 할당 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8200736ff62022947594a20000da454c1425bb2e" translate="yes" xml:space="preserve">
          <source>This text is a brief description of the features that are present in the Bash shell (version 5.0, 12 May 2019). The Bash home page is &lt;a href=&quot;http://www.gnu.org/software/bash/&quot;&gt;http://www.gnu.org/software/bash/&lt;/a&gt;.</source>
          <target state="translated">이 텍스트는 Bash 셸 (버전 5.0, 2019 년 5 월 12 일)에있는 기능에 대한 간략한 설명입니다. Bash 홈페이지는 &lt;a href=&quot;http://www.gnu.org/software/bash/&quot;&gt;http://www.gnu.org/software/bash/&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6aa36388e8270005983d3c3a89d175634cb9d6d6" translate="yes" xml:space="preserve">
          <source>This type of redirection instructs the shell to read input from the current source until a line containing only &lt;var&gt;word&lt;/var&gt; (with no trailing blanks) is seen. All of the lines read up to that point are then used as the standard input (or file descriptor &lt;var&gt;n&lt;/var&gt; if &lt;var&gt;n&lt;/var&gt; is specified) for a command.</source>
          <target state="translated">이 유형의 방향 재 지정은 &lt;var&gt;word&lt;/var&gt; 만 포함하는 행 (후행 공백 없음)이 표시 될 때까지 쉘이 현재 소스에서 입력을 읽도록 지시합니다 . 해당 지점까지 읽은 모든 행 은 명령 의 표준 입력 (또는 &lt;var&gt;n&lt;/var&gt; 이 지정된 경우 파일 설명자 &lt;var&gt;n&lt;/var&gt; )으로 사용 됩니다 .</target>
        </trans-unit>
        <trans-unit id="48f6e17e8da6cd0eb6bf7fce31b9c51712841200" translate="yes" xml:space="preserve">
          <source>This variable can be set to either &amp;lsquo;</source>
          <target state="translated">이 변수는 '</target>
        </trans-unit>
        <trans-unit id="b898e323bf42516d42d2884eb9c4d9d2c8ecc146" translate="yes" xml:space="preserve">
          <source>This variable can be used with &lt;code&gt;BASH_LINENO&lt;/code&gt; and &lt;code&gt;BASH_SOURCE&lt;/code&gt;. Each element of &lt;code&gt;FUNCNAME&lt;/code&gt; has corresponding elements in &lt;code&gt;BASH_LINENO&lt;/code&gt; and &lt;code&gt;BASH_SOURCE&lt;/code&gt; to describe the call stack. For instance, &lt;code&gt;${FUNCNAME[$i]}&lt;/code&gt; was called from the file &lt;code&gt;${BASH_SOURCE[$i+1]}&lt;/code&gt; at line number &lt;code&gt;${BASH_LINENO[$i]}&lt;/code&gt;. The &lt;code&gt;caller&lt;/code&gt; builtin displays the current call stack using this information.</source>
          <target state="translated">이 변수는 &lt;code&gt;BASH_LINENO&lt;/code&gt; 및 &lt;code&gt;BASH_SOURCE&lt;/code&gt; 와 함께 사용할 수 있습니다 . &lt;code&gt;FUNCNAME&lt;/code&gt; 의 각 요소 에는 호출 스택을 설명하기 위해 &lt;code&gt;BASH_LINENO&lt;/code&gt; 및 &lt;code&gt;BASH_SOURCE&lt;/code&gt; 에 해당 요소가 있습니다. 예를 들어 &lt;code&gt;${FUNCNAME[$i]}&lt;/code&gt; 은 ( 는) 행 번호 &lt;code&gt;${BASH_LINENO[$i]}&lt;/code&gt; &lt;code&gt;${BASH_SOURCE[$i+1]}&lt;/code&gt; 파일에서 호출되었습니다 . &lt;code&gt;caller&lt;/code&gt; 표시 내장이 정보를 사용하여 현재 호출 스택.</target>
        </trans-unit>
        <trans-unit id="8f621ed80bd0b1d46bf87d748900234c7ee9eaa0" translate="yes" xml:space="preserve">
          <source>This variable controls how the shell interacts with the user and job control. If this variable exists then single word simple commands without redirections are treated as candidates for resumption of an existing job. There is no ambiguity allowed; if there is more than one job beginning with the string typed, then the most recently accessed job will be selected. The name of a stopped job, in this context, is the command line used to start it. If this variable is set to the value &amp;lsquo;</source>
          <target state="translated">이 변수는 쉘이 사용자 및 작업 제어와 상호 작용하는 방법을 제어합니다. 이 변수가 존재하면 경로 재 지정이없는 단일 단어 단순 명령이 기존 작업의 재개 후보로 처리됩니다. 모호성이 허용되지 않습니다. 문자열 유형으로 시작하는 작업이 둘 이상 있으면 가장 최근에 액세스 한 작업이 선택됩니다. 이 컨텍스트에서 중지 된 작업의 이름은 작업을 시작하는 데 사용되는 명령 줄입니다. 이 변수가 '</target>
        </trans-unit>
        <trans-unit id="322c0f55723ec893e9cb7bfc5a0c27101a72d2f9" translate="yes" xml:space="preserve">
          <source>This variable determines the collation order used when sorting the results of filename expansion, and determines the behavior of range expressions, equivalence classes, and collating sequences within filename expansion and pattern matching (see &lt;a href=&quot;filename-expansion#Filename-Expansion&quot;&gt;Filename Expansion&lt;/a&gt;).</source>
          <target state="translated">이 변수는 파일 이름 확장 결과를 정렬 할 때 사용되는 데이터 정렬 순서를 결정하고 파일 이름 확장 및 패턴 일치 내에서 범위 표현식, 동등 클래스 및 데이터 정렬 시퀀스의 동작을 결정합니다 ( &lt;a href=&quot;filename-expansion#Filename-Expansion&quot;&gt;파일 이름 확장&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7d0ca062754111dbbfd7e5739986fb58b4a986cd" translate="yes" xml:space="preserve">
          <source>This variable determines the interpretation of characters and the behavior of character classes within filename expansion and pattern matching (see &lt;a href=&quot;filename-expansion#Filename-Expansion&quot;&gt;Filename Expansion&lt;/a&gt;).</source>
          <target state="translated">이 변수는 파일 이름 확장 및 패턴 일치 내에서 문자의 해석 및 문자 클래스의 동작을 결정합니다 ( &lt;a href=&quot;filename-expansion#Filename-Expansion&quot;&gt;파일 이름 확장&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="acbe98e6bd7b514b31e99a907e5f0b6515c9aab6" translate="yes" xml:space="preserve">
          <source>This variable determines the locale category used for data and time formatting.</source>
          <target state="translated">이 변수는 데이터 및 시간 형식에 사용되는 로캘 범주를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="3bb0dafe7e2142258af9b9c7fdf74c8aebee47d7" translate="yes" xml:space="preserve">
          <source>This variable determines the locale category used for number formatting.</source>
          <target state="translated">이 변수는 숫자 형식에 사용되는 로캘 범주를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="e8a56010968910b59ed93e8bc10f374429422c2c" translate="yes" xml:space="preserve">
          <source>This variable determines the locale used to translate double-quoted strings preceded by a &amp;lsquo;</source>
          <target state="translated">이 변수는 큰 따옴표로 묶은 문자열 앞에 '</target>
        </trans-unit>
        <trans-unit id="86ab35dc0367a2aaa05d2986dc008b4f6d6c1c34" translate="yes" xml:space="preserve">
          <source>This variable expands to the number of seconds since the shell was started. Assignment to this variable resets the count to the value assigned, and the expanded value becomes the value assigned plus the number of seconds since the assignment.</source>
          <target state="translated">이 변수는 쉘이 시작된 이후의 시간 (초)으로 확장됩니다. 이 변수에 할당하면 카운트가 할당 된 값으로 재설정되고 확장 된 값은 할당 된 값에 할당 이후의 초 수를 더한 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="d2d0578e878088aefbfca4ced87f5d6f4c523b5a" translate="yes" xml:space="preserve">
          <source>This variable overrides the value of &lt;code&gt;LANG&lt;/code&gt; and any other &lt;code&gt;LC_&lt;/code&gt; variable specifying a locale category.</source>
          <target state="translated">이 변수는 &lt;code&gt;LANG&lt;/code&gt; 및 로케일 범주를 지정하는 다른 &lt;code&gt;LC_&lt;/code&gt; 변수 의 값을 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="e3c7c3129c1796756c2de28b0ac178af8b1d5551" translate="yes" xml:space="preserve">
          <source>This variable, when set to &amp;lsquo;</source>
          <target state="translated">이 변수는 '</target>
        </trans-unit>
        <trans-unit id="8c0a82cc0c0acb81621c0e8a8ea0c1b101cf2241" translate="yes" xml:space="preserve">
          <source>This will recompress all files in the current directory with names ending in .gz using bzip2, running one job per CPU (-j+0) in parallel. (We use &lt;code&gt;ls&lt;/code&gt; for brevity here; using &lt;code&gt;find&lt;/code&gt; as above is more robust in the face of filenames containing unexpected characters.) Parallel can take arguments from the command line; the above can also be written as</source>
          <target state="translated">이것은 bzip2를 사용하여 .gz로 끝나는 현재 디렉토리의 모든 파일을 CPU 당 하나의 작업 (-j + 0)으로 병렬로 다시 압축합니다. ( 여기에서는 간결성을 위해 &lt;code&gt;ls&lt;/code&gt; 를 사용 합니다. 예기치 않은 문자가 포함 된 파일 이름의 경우 위와 같이 &lt;code&gt;find&lt;/code&gt; 를 사용하는 것이 더 강력합니다.) Parallel은 명령 줄에서 인수를 사용할 수 있습니다. 위와 같이 쓸 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="8ad4bbea3750b4693e3ab30e9e81cb36dd009c76" translate="yes" xml:space="preserve">
          <source>This will run as many &lt;code&gt;mv&lt;/code&gt; commands as there are files in the current directory. You can emulate a parallel &lt;code&gt;xargs&lt;/code&gt; by adding the</source>
          <target state="translated">현재 디렉토리에 파일이있는만큼 &lt;code&gt;mv&lt;/code&gt; 명령 이 실행됩니다 . 다음 을 추가하여 병렬 &lt;code&gt;xargs&lt;/code&gt; 를 에뮬레이션 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="73fa1b98e98d236ed8d9007a8b27f06db355f7c3" translate="yes" xml:space="preserve">
          <source>Three builtin commands are available to manipulate the programmable completion facilities: one to specify how the arguments to a particular command are to be completed, and two to modify the completion as it is happening.</source>
          <target state="translated">프로그램 가능 완료 기능을 조작하기 위해 세 가지 기본 제공 명령을 사용할 수 있습니다. 하나는 특정 명령에 대한 인수를 완료하는 방법을 지정하고, 하나는 완료 될 때 완료를 수정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5d1f96e557614b0a690090f9dca6f209f6c0274d" translate="yes" xml:space="preserve">
          <source>Tilde Expansion</source>
          <target state="translated">물결 확장</target>
        </trans-unit>
        <trans-unit id="29a0154a26a0aa025c65e57ccd5615d5132587a5" translate="yes" xml:space="preserve">
          <source>Tilde expansion is only performed on assignments preceding a command name, rather than on all assignment statements on the line.</source>
          <target state="translated">틸드 확장은 라인의 모든 할당 문이 아닌 명령 이름 앞에있는 할당에서만 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="8ccacd4d99966dea93ed7cd2d116b2ebac5faf9f" translate="yes" xml:space="preserve">
          <source>To determine within a startup script whether or not Bash is running interactively, test the value of the &amp;lsquo;</source>
          <target state="translated">시작 스크립트 내에서 Bash가 대화식으로 실행 중인지 여부를 판별하려면 '</target>
        </trans-unit>
        <trans-unit id="c06441f5639bd713ff8f6ee1faf86ceaf5fadf3d" translate="yes" xml:space="preserve">
          <source>To facilitate the implementation of the user interface to job control, the operating system maintains the notion of a current terminal process group &lt;small&gt;ID&lt;/small&gt;. Members of this process group (processes whose process group &lt;small&gt;ID&lt;/small&gt; is equal to the current terminal process group &lt;small&gt;ID&lt;/small&gt;) receive keyboard-generated signals such as &lt;code&gt;SIGINT&lt;/code&gt;. These processes are said to be in the foreground. Background processes are those whose process group &lt;small&gt;ID&lt;/small&gt; differs from the terminal&amp;rsquo;s; such processes are immune to keyboard-generated signals. Only foreground processes are allowed to read from or, if the user so specifies with &lt;code&gt;stty tostop&lt;/code&gt;, write to the terminal. Background processes which attempt to read from (write to when &lt;code&gt;stty tostop&lt;/code&gt; is in effect) the terminal are sent a &lt;code&gt;SIGTTIN&lt;/code&gt; (&lt;code&gt;SIGTTOU&lt;/code&gt;) signal by the kernel&amp;rsquo;s terminal driver, which, unless caught, suspends the process.</source>
          <target state="translated">작업 제어에 대한 사용자 인터페이스 구현을 용이하게하기 위해 운영 체제는 현재 터미널 프로세스 그룹 &lt;small&gt;ID&lt;/small&gt; 개념을 유지합니다 . 이 프로세스 그룹의 멤버 (프로세스 그룹 &lt;small&gt;ID&lt;/small&gt; 가 현재 터미널 프로세스 그룹 &lt;small&gt;ID와&lt;/small&gt; 동일한 프로세스 )는 &lt;code&gt;SIGINT&lt;/code&gt; 와 같은 키보드 생성 신호를 수신 합니다. 이러한 프로세스는 포 그라운드에 있다고합니다. 백그라운드 프로세스는 프로세스 그룹 &lt;small&gt;ID&lt;/small&gt; 가 터미널과 다른 프로세스입니다 . 이러한 프로세스는 키보드 생성 신호에 영향을받지 않습니다. 사용자가 &lt;code&gt;stty tostop&lt;/code&gt; 으로 지정한 경우 포 그라운드 프로세스 만 읽을 수 있습니다.터미널에 씁니다. &lt;code&gt;stty tostop&lt;/code&gt; 이 유효 할 때 쓰기를 시도하는 백그라운드 프로세스 는 커널의 터미널 드라이버에 의해 &lt;code&gt;SIGTTIN&lt;/code&gt; ( &lt;code&gt;SIGTTOU&lt;/code&gt; ) 신호를 보내며 ,이 프로세스는 잡히지 않으면 프로세스를 일시 중단합니다.</target>
        </trans-unit>
        <trans-unit id="7461bebceaba8e9786a438f43be22c208daad744" translate="yes" xml:space="preserve">
          <source>To find other matching entries in the history list, type</source>
          <target state="translated">기록 목록에서 일치하는 다른 항목을 찾으려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="30be0318ce7f5e48f6f8aebb72ff5f9a498e339c" translate="yes" xml:space="preserve">
          <source>To find out more about the options and arguments that the &lt;code&gt;configure&lt;/code&gt; script understands, type</source>
          <target state="translated">&lt;code&gt;configure&lt;/code&gt; 스크립트가 이해 하는 옵션 및 인수에 대한 자세한 내용을 보려면</target>
        </trans-unit>
        <trans-unit id="234871e08b6f492490e17c79f3e3c9f389f0019c" translate="yes" xml:space="preserve">
          <source>To use this License in a document you have written, include a copy of the License in the document and put the following copyright and license notices just after the title page:</source>
          <target state="translated">귀하가 작성한 문서에서이 라이센스를 사용하려면 문서에 라이센스의 사본을 포함시키고 제목 페이지 바로 뒤에 다음 저작권 및 라이센스 고지를 두십시오.</target>
        </trans-unit>
        <trans-unit id="1c79fb4cfb10162b75bfbf4f221b1bd3dea706fd" translate="yes" xml:space="preserve">
          <source>Toggle overwrite mode. With an explicit positive numeric argument, switches to overwrite mode. With an explicit non-positive numeric argument, switches to insert mode. This command affects only &lt;code&gt;emacs&lt;/code&gt; mode; &lt;code&gt;vi&lt;/code&gt; mode does overwrite differently. Each call to &lt;code&gt;readline()&lt;/code&gt; starts in insert mode.</source>
          <target state="translated">덮어 쓰기 모드를 전환합니다. 명시적인 양수 인수를 사용하면 덮어 쓰기 모드로 전환됩니다. 명시적인 비양의 숫자 인수를 사용하여 삽입 모드로 전환합니다. 이 명령은 &lt;code&gt;emacs&lt;/code&gt; 모드 에만 영향을줍니다 . &lt;code&gt;vi&lt;/code&gt; 모드는 다르게 덮어 씁니다. &lt;code&gt;readline()&lt;/code&gt; 각 호출 은 삽입 모드에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="64173d2188c9be0ec9ff6bb79881f697e1bff5ed" translate="yes" xml:space="preserve">
          <source>Toggle the values of settings controlling optional shell behavior. The settings can be either those listed below, or, if the</source>
          <target state="translated">선택적 쉘 동작을 제어하는 ​​설정 값을 토글합니다. 설정은 아래에 나열된 설정이거나</target>
        </trans-unit>
        <trans-unit id="db14d824e8eb47798dded3ebab911e7aba6462ac" translate="yes" xml:space="preserve">
          <source>Translation is considered a kind of modification, so you may distribute translations of the Document under the terms of section 4. Replacing Invariant Sections with translations requires special permission from their copyright holders, but you may include translations of some or all Invariant Sections in addition to the original versions of these Invariant Sections. You may include a translation of this License, and all the license notices in the Document, and any Warranty Disclaimers, provided that you also include the original English version of this License and the original versions of those notices and disclaimers. In case of a disagreement between the translation and the original version of this License or a notice or disclaimer, the original version will prevail.</source>
          <target state="translated">번역은 일종의 수정으로 간주되므로 섹션 4의 조항에 따라 문서의 번역을 배포 할 수 있습니다. 변하지 않는 섹션을 번역으로 바꾸려면 저작권 보유자의 특별한 허가가 필요하지만 일부 또는 모든 불변 섹션의 번역을 포함 할 수 있습니다 이 고정 섹션의 원래 버전. 본 라이센스의 원본 영어 버전과 해당 통지 및 책임의 원래 버전도 포함하는 경우,이 라이센스의 번역, 문서의 모든 라이센스 공지 및 모든 보증 부인을 포함 할 수 있습니다. 번역과 본 라이센스의 원본 버전 또는 통지 또는 고지 사항간에 의견이 일치하지 않을 경우 원본 버전이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="25b56e8610a80aa4c358553af9d469a2389a0d0b" translate="yes" xml:space="preserve">
          <source>Treat unset variables and parameters other than the special parameters &amp;lsquo;</source>
          <target state="translated">특수 매개 변수 이외의 설정되지 않은 변수 및 매개 변수 처리</target>
        </trans-unit>
        <trans-unit id="c576040022ef2d3ed4c5cfb729ef747257d3d0c6" translate="yes" xml:space="preserve">
          <source>True if &lt;var&gt;expr&lt;/var&gt; is false.</source>
          <target state="translated">진정한 경우 &lt;var&gt;expr&lt;/var&gt; false입니다.</target>
        </trans-unit>
        <trans-unit id="c1e09b47a41f17423a47403dc34af583d967ced8" translate="yes" xml:space="preserve">
          <source>True if &lt;var&gt;expression&lt;/var&gt; is false.</source>
          <target state="translated">&lt;var&gt;expression&lt;/var&gt; 거짓 이면 참 입니다.</target>
        </trans-unit>
        <trans-unit id="1dfe2b86c7856ed0672b49f8031ca7598cd2e53a" translate="yes" xml:space="preserve">
          <source>True if &lt;var&gt;file1&lt;/var&gt; and &lt;var&gt;file2&lt;/var&gt; refer to the same device and inode numbers.</source>
          <target state="translated">&lt;var&gt;file1&lt;/var&gt; 과 &lt;var&gt;file2&lt;/var&gt; 가 동일한 장치 및 inode 번호를 참조 하면 true 입니다.</target>
        </trans-unit>
        <trans-unit id="1931c6818bb80999d31b4895be8e1032a0090a5a" translate="yes" xml:space="preserve">
          <source>True if &lt;var&gt;file1&lt;/var&gt; is newer (according to modification date) than &lt;var&gt;file2&lt;/var&gt;, or if &lt;var&gt;file1&lt;/var&gt; exists and &lt;var&gt;file2&lt;/var&gt; does not.</source>
          <target state="translated">&lt;var&gt;file1&lt;/var&gt; 이 &lt;var&gt;file2&lt;/var&gt; 보다 최신 이거나 ( 수정 날짜에 따라) &lt;var&gt;file1&lt;/var&gt; 이 있고 &lt;var&gt;file2&lt;/var&gt; 가없는 경우 참 입니다.</target>
        </trans-unit>
        <trans-unit id="32482cdb8a0a8c00990d2254409eb0064fa456e0" translate="yes" xml:space="preserve">
          <source>True if &lt;var&gt;file1&lt;/var&gt; is older than &lt;var&gt;file2&lt;/var&gt;, or if &lt;var&gt;file2&lt;/var&gt; exists and &lt;var&gt;file1&lt;/var&gt; does not.</source>
          <target state="translated">&lt;var&gt;file1&lt;/var&gt; 이 &lt;var&gt;file2&lt;/var&gt; 보다 오래된 경우 또는 &lt;var&gt;file2&lt;/var&gt; 가 존재하고 &lt;var&gt;file1&lt;/var&gt; 이없는 경우 참 입니다.</target>
        </trans-unit>
        <trans-unit id="4f29d31c4b26c9c972f26d19960ae09b504edcc2" translate="yes" xml:space="preserve">
          <source>True if &lt;var&gt;file&lt;/var&gt; exists and has a size greater than zero.</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 이 존재하고 크기가 0보다 크면 True 입니다.</target>
        </trans-unit>
        <trans-unit id="a58e629fec5bb0f7399ff14c07ac493c7af547e4" translate="yes" xml:space="preserve">
          <source>True if &lt;var&gt;file&lt;/var&gt; exists and has been modified since it was last read.</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 이 존재하고 마지막으로 읽은 이후 수정 된 경우 참 입니다.</target>
        </trans-unit>
        <trans-unit id="ff555302ffe9977d7e774f403778a2b43ca9e6fb" translate="yes" xml:space="preserve">
          <source>True if &lt;var&gt;file&lt;/var&gt; exists and is a block special file.</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 이 존재하고 블록 특수 파일 인 경우 참 입니다.</target>
        </trans-unit>
        <trans-unit id="785fff67e549edee63f87e13610d25e06e563134" translate="yes" xml:space="preserve">
          <source>True if &lt;var&gt;file&lt;/var&gt; exists and is a character special file.</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 이 존재하고 문자 특수 파일 인 경우 참 입니다.</target>
        </trans-unit>
        <trans-unit id="32250a9f0fb33fa74e350624e933c3af0031a469" translate="yes" xml:space="preserve">
          <source>True if &lt;var&gt;file&lt;/var&gt; exists and is a directory.</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 이 존재하고 디렉토리 이면 참 입니다.</target>
        </trans-unit>
        <trans-unit id="672fc8348e4d811dca287144bf4afc66b5779262" translate="yes" xml:space="preserve">
          <source>True if &lt;var&gt;file&lt;/var&gt; exists and is a named pipe (FIFO).</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 이 존재하고 명명 된 파이프 (FIFO) 인 경우 참 입니다.</target>
        </trans-unit>
        <trans-unit id="398d1fa760f00f29d01a407c21ca50fafe5950e2" translate="yes" xml:space="preserve">
          <source>True if &lt;var&gt;file&lt;/var&gt; exists and is a regular file.</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 이 존재하고 일반 파일 인 경우 참 입니다.</target>
        </trans-unit>
        <trans-unit id="915744ff671beed3f722bd4d5fc6716b115eef67" translate="yes" xml:space="preserve">
          <source>True if &lt;var&gt;file&lt;/var&gt; exists and is a socket.</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 이 존재하고 소켓 인 경우에 해당 됩니다 .</target>
        </trans-unit>
        <trans-unit id="017980389fddb5aadceb3bc6336ea0d3b25f926b" translate="yes" xml:space="preserve">
          <source>True if &lt;var&gt;file&lt;/var&gt; exists and is a symbolic link.</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 이 존재하고 기호 링크 인 경우에 해당 됩니다 .</target>
        </trans-unit>
        <trans-unit id="303e1abad6194c1fd1d818c1476426963f0229e4" translate="yes" xml:space="preserve">
          <source>True if &lt;var&gt;file&lt;/var&gt; exists and is executable.</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 이 존재하고 실행 가능한 경우 참 입니다.</target>
        </trans-unit>
        <trans-unit id="cdb2fca38caf968e64be89bc93da5ca5dbbab94c" translate="yes" xml:space="preserve">
          <source>True if &lt;var&gt;file&lt;/var&gt; exists and is owned by the effective group id.</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 이 존재하고 유효 그룹 ID가 소유 한 경우 true 입니다.</target>
        </trans-unit>
        <trans-unit id="536aa1f6ed6018a92c953af3d3892c3285094b46" translate="yes" xml:space="preserve">
          <source>True if &lt;var&gt;file&lt;/var&gt; exists and is owned by the effective user id.</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 이 존재하고 유효 사용자 ID가 소유 한 경우 true 입니다.</target>
        </trans-unit>
        <trans-unit id="86d461baa0cc35b80042a133d8520dbb853cdc36" translate="yes" xml:space="preserve">
          <source>True if &lt;var&gt;file&lt;/var&gt; exists and is readable.</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 이 존재하고 읽을 수 있으면 true 입니다.</target>
        </trans-unit>
        <trans-unit id="f7aaebd5416f1b8c71b2067cff350417cc28cd41" translate="yes" xml:space="preserve">
          <source>True if &lt;var&gt;file&lt;/var&gt; exists and is writable.</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 이 존재하고 쓰기 가능한 경우 true 입니다.</target>
        </trans-unit>
        <trans-unit id="f35727abb72a043fc58a69af5b10c3bdcdce008a" translate="yes" xml:space="preserve">
          <source>True if &lt;var&gt;file&lt;/var&gt; exists and its &quot;sticky&quot; bit is set.</source>
          <target state="translated">진정한 경우 &lt;var&gt;file&lt;/var&gt; 존재 해, &quot;끈적 끈적한&quot;비트가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7401f1886dca5f7578d9880d8abf714b6e397264" translate="yes" xml:space="preserve">
          <source>True if &lt;var&gt;file&lt;/var&gt; exists and its set-group-id bit is set.</source>
          <target state="translated">true의 경우 &lt;var&gt;file&lt;/var&gt; 존재 해, 그 설정 그룹-ID 비트가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="64cb08c3d3b10e3c1f58c6df08810878e2be1bac" translate="yes" xml:space="preserve">
          <source>True if &lt;var&gt;file&lt;/var&gt; exists and its set-user-id bit is set.</source>
          <target state="translated">진정한 경우 &lt;var&gt;file&lt;/var&gt; 존재 해, 그 설정 사용자-ID 비트가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="0ad8ede1f5901af4ead70e5e4f5ffea0dff96af3" translate="yes" xml:space="preserve">
          <source>True if &lt;var&gt;file&lt;/var&gt; exists.</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 이 존재 하면 true 입니다.</target>
        </trans-unit>
        <trans-unit id="a694844e564143deec0005453edfce994f46f41f" translate="yes" xml:space="preserve">
          <source>True if &lt;var&gt;string1&lt;/var&gt; sorts after &lt;var&gt;string2&lt;/var&gt; lexicographically.</source>
          <target state="translated">&lt;var&gt;string1&lt;/var&gt; 이 사전 순으로 &lt;var&gt;string2&lt;/var&gt; 다음에 정렬 되면 true 입니다.</target>
        </trans-unit>
        <trans-unit id="2eaf782c48f4f232fd972b24507c8090e33acfd0" translate="yes" xml:space="preserve">
          <source>True if &lt;var&gt;string1&lt;/var&gt; sorts before &lt;var&gt;string2&lt;/var&gt; lexicographically.</source>
          <target state="translated">&lt;var&gt;string1&lt;/var&gt; 이 사전 순으로 &lt;var&gt;string2&lt;/var&gt; 보다 먼저 정렬 되면 true 입니다.</target>
        </trans-unit>
        <trans-unit id="dfd0ae4f41de5a24984c76e4ec506bbf5ead35fe" translate="yes" xml:space="preserve">
          <source>True if both &lt;var&gt;expr1&lt;/var&gt; and &lt;var&gt;expr2&lt;/var&gt; are true.</source>
          <target state="translated">사실 두 경우 &lt;var&gt;expr1&lt;/var&gt; 을 하고 &lt;var&gt;expr2&lt;/var&gt; 이이 사실이다.</target>
        </trans-unit>
        <trans-unit id="8f65766fae75b0ca98aa32ef28e4297c6e10769f" translate="yes" xml:space="preserve">
          <source>True if both &lt;var&gt;expression1&lt;/var&gt; and &lt;var&gt;expression2&lt;/var&gt; are true.</source>
          <target state="translated">사실 두 경우 &lt;var&gt;expression1&lt;/var&gt; 및 &lt;var&gt;expression2&lt;/var&gt; 가 해당.</target>
        </trans-unit>
        <trans-unit id="9ca4bbaac189fe4ef1c7494e1ad83de3cf6af5b6" translate="yes" xml:space="preserve">
          <source>True if either &lt;var&gt;expr1&lt;/var&gt; or &lt;var&gt;expr2&lt;/var&gt; is true.</source>
          <target state="translated">사실 어느 경우 &lt;var&gt;expr1&lt;/var&gt; 을 또는 &lt;var&gt;expr2&lt;/var&gt; 이는 사실이다.</target>
        </trans-unit>
        <trans-unit id="db68e589c03d9400814cc445d96c1dc4310f307f" translate="yes" xml:space="preserve">
          <source>True if either &lt;var&gt;expression1&lt;/var&gt; or &lt;var&gt;expression2&lt;/var&gt; is true.</source>
          <target state="translated">사실 어느 경우 &lt;var&gt;expression1&lt;/var&gt; 또는 &lt;var&gt;expression2&lt;/var&gt; 를는 사실이다.</target>
        </trans-unit>
        <trans-unit id="5c8258be0a5a3c372a9f45bc293f8b281921f601" translate="yes" xml:space="preserve">
          <source>True if file descriptor &lt;var&gt;fd&lt;/var&gt; is open and refers to a terminal.</source>
          <target state="translated">파일 디스크립터 &lt;var&gt;fd&lt;/var&gt; 가 열려 있고 터미널을 참조 하면 true 입니다.</target>
        </trans-unit>
        <trans-unit id="dac97a4e44b66a08100ff32dd6db743cd8d30e14" translate="yes" xml:space="preserve">
          <source>True if the length of &lt;var&gt;string&lt;/var&gt; is non-zero.</source>
          <target state="translated">&lt;var&gt;string&lt;/var&gt; 길이가 0이 아닌 경우 참 입니다.</target>
        </trans-unit>
        <trans-unit id="3f209d388a9f63e0cf9fc44924f1c6cc1fcf816a" translate="yes" xml:space="preserve">
          <source>True if the length of &lt;var&gt;string&lt;/var&gt; is zero.</source>
          <target state="translated">&lt;var&gt;string&lt;/var&gt; 길이 가 0 이면 true 입니다.</target>
        </trans-unit>
        <trans-unit id="9755b366b236842b5acd5a1bb0f3c4e786f2da82" translate="yes" xml:space="preserve">
          <source>True if the shell option &lt;var&gt;optname&lt;/var&gt; is enabled. The list of options appears in the description of the</source>
          <target state="translated">쉘 옵션 &lt;var&gt;optname&lt;/var&gt; 이 사용 가능한 경우 true 입니다. 옵션 목록이</target>
        </trans-unit>
        <trans-unit id="095ba591e289192519c99cde5accd02885f7161e" translate="yes" xml:space="preserve">
          <source>True if the shell variable &lt;var&gt;varname&lt;/var&gt; is set (has been assigned a value).</source>
          <target state="translated">쉘 변수 &lt;var&gt;varname&lt;/var&gt; 이 설정되어 있으면 (값이 할당 된 경우) true 입니다.</target>
        </trans-unit>
        <trans-unit id="98cfa3f65eadea23036a451a78c852c151c553c7" translate="yes" xml:space="preserve">
          <source>True if the shell variable &lt;var&gt;varname&lt;/var&gt; is set and is a name reference.</source>
          <target state="translated">쉘 변수 &lt;var&gt;varname&lt;/var&gt; 이 설정되어 있고 이름 참조 인 경우 참입니다.</target>
        </trans-unit>
        <trans-unit id="87550cc27a4d851c58589edab9351918b2c6e70e" translate="yes" xml:space="preserve">
          <source>True if the strings are equal. When used with the &lt;code&gt;[[&lt;/code&gt; command, this performs pattern matching as described above (see &lt;a href=&quot;conditional-constructs#Conditional-Constructs&quot;&gt;Conditional Constructs&lt;/a&gt;).</source>
          <target state="translated">문자열이 같으면 참입니다. &lt;code&gt;[[&lt;/code&gt; 명령 과 함께 사용하면 위에서 설명한대로 패턴 일치를 수행합니다 ( &lt;a href=&quot;conditional-constructs#Conditional-Constructs&quot;&gt;조건부 구성&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="901d788cb9c954e0e3bc5acc54c4b07a8234d973" translate="yes" xml:space="preserve">
          <source>True if the strings are not equal.</source>
          <target state="translated">문자열이 같지 않으면 참입니다.</target>
        </trans-unit>
        <trans-unit id="7ba597c4ba706a33ba89181ef140d5de6ce00b1f" translate="yes" xml:space="preserve">
          <source>Turn on privileged mode. In this mode, the &lt;code&gt;$BASH_ENV&lt;/code&gt; and &lt;code&gt;$ENV&lt;/code&gt; files are not processed, shell functions are not inherited from the environment, and the &lt;code&gt;SHELLOPTS&lt;/code&gt;, &lt;code&gt;BASHOPTS&lt;/code&gt;, &lt;code&gt;CDPATH&lt;/code&gt; and &lt;code&gt;GLOBIGNORE&lt;/code&gt; variables, if they appear in the environment, are ignored. If the shell is started with the effective user (group) id not equal to the real user (group) id, and the</source>
          <target state="translated">권한 모드를 켜십시오. 이 모드에서는 &lt;code&gt;$BASH_ENV&lt;/code&gt; 및 &lt;code&gt;$ENV&lt;/code&gt; 파일이 처리되지 않고 셸 함수가 환경에서 상속되지 않으며 &lt;code&gt;SHELLOPTS&lt;/code&gt; , &lt;code&gt;BASHOPTS&lt;/code&gt; , &lt;code&gt;CDPATH&lt;/code&gt; 및 &lt;code&gt;GLOBIGNORE&lt;/code&gt; 변수가 환경에 나타나는 경우 무시됩니다. 유효 사용자 (그룹) ID가 실제 사용자 (그룹) ID와 같지 않은 상태로 쉘이 시작된 경우</target>
        </trans-unit>
        <trans-unit id="529cc456a0b2e03b61877af15a727605fcc2878b" translate="yes" xml:space="preserve">
          <source>Turn on the interpretation of a number of backslash-escaped characters in the &lt;code&gt;$PS0&lt;/code&gt;, &lt;code&gt;$PS1&lt;/code&gt;, &lt;code&gt;$PS2&lt;/code&gt;, and &lt;code&gt;$PS4&lt;/code&gt; prompt strings. See &lt;a href=&quot;controlling-the-prompt#Controlling-the-Prompt&quot;&gt;Controlling the Prompt&lt;/a&gt;, for a complete list of prompt string escape sequences.</source>
          <target state="translated">&lt;code&gt;$PS0&lt;/code&gt; , &lt;code&gt;$PS1&lt;/code&gt; , &lt;code&gt;$PS2&lt;/code&gt; 및 &lt;code&gt;$PS4&lt;/code&gt; 프롬프트 문자열 에서 다수의 백 슬래시 이스케이프 문자 해석을 설정하십시오 . 프롬프트 문자열 이스케이프 시퀀스의 전체 목록은 프롬프트 &lt;a href=&quot;controlling-the-prompt#Controlling-the-Prompt&quot;&gt;제어를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3795902d765dfd462c8684fb196a720749ac4df0" translate="yes" xml:space="preserve">
          <source>Turning off restricted mode with &amp;lsquo;</source>
          <target state="translated">'를 사용하여 제한 모드 끄기</target>
        </trans-unit>
        <trans-unit id="c1d93843f852e85798d20eeb3cdc905a4fa50479" translate="yes" xml:space="preserve">
          <source>Two-way communication between commands.</source>
          <target state="translated">명령 간 양방향 통신</target>
        </trans-unit>
        <trans-unit id="4b4d91bc73387f9d4d807d8dd6507627174593ea" translate="yes" xml:space="preserve">
          <source>Type &amp;lsquo;</source>
          <target state="translated">'</target>
        </trans-unit>
        <trans-unit id="b2c7c0caa10a0cca5ea7d69e54018ae0c0389dd6" translate="yes" xml:space="preserve">
          <source>U</source>
          <target state="translated">U</target>
        </trans-unit>
        <trans-unit id="d3ec7720c14cebb138c6a1ef57a0eb2ea1e40a65" translate="yes" xml:space="preserve">
          <source>Unbind all keys bound to the named &lt;var&gt;function&lt;/var&gt;.</source>
          <target state="translated">명명 된 &lt;var&gt;function&lt;/var&gt; 바인딩 된 모든 키를 바인딩 해제합니다 .</target>
        </trans-unit>
        <trans-unit id="a09912a5a17af809447f38efa5d4c0b6c0ec7c06" translate="yes" xml:space="preserve">
          <source>Undo all changes made to this line. This is like executing the &lt;code&gt;undo&lt;/code&gt; command enough times to get back to the beginning.</source>
          <target state="translated">이 줄의 모든 변경 사항을 취소하십시오. 이것은 처음으로 돌아 가기 위해 충분한 시간 동안 &lt;code&gt;undo&lt;/code&gt; 명령을 실행하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6012c0f2d0e2bd7f7010ec2b337685770c24679e" translate="yes" xml:space="preserve">
          <source>Undo the last editing command. You can undo all the way back to an empty line.</source>
          <target state="translated">마지막 편집 명령을 취소하십시오. 빈 줄로 되돌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c7021edb2aa70f462455b960f49f5a5410323a4" translate="yes" xml:space="preserve">
          <source>Unless otherwise noted, each builtin command documented as accepting options preceded by &amp;lsquo;</source>
          <target state="translated">별도의 언급이없는 한, 각 내장 명령은 옵션 앞에 '</target>
        </trans-unit>
        <trans-unit id="d754bbd613ae92596fbe8c352f9060939b1fa5db" translate="yes" xml:space="preserve">
          <source>Unless otherwise noted, the &lt;code&gt;shopt&lt;/code&gt; options are disabled (off) by default.</source>
          <target state="translated">달리 명시되지 않는 한, &lt;code&gt;shopt&lt;/code&gt; 옵션은 기본적으로 비활성화되어 있습니다 (꺼짐).</target>
        </trans-unit>
        <trans-unit id="ac9ca0e57a5feba07a2f16b1b29d2a12e00b69b2" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified, primaries that operate on files follow symbolic links and operate on the target of the link, rather than the link itself.</source>
          <target state="translated">달리 지정하지 않는 한 파일에서 작동하는 기본은 링크 자체가 아닌 심볼릭 링크를 따라 링크의 대상에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="bf5bef4f6cefc24fd54a3710a491f1aee7ad8db0" translate="yes" xml:space="preserve">
          <source>Up to three characters which control history expansion, quick substitution, and tokenization (see &lt;a href=&quot;history-interaction#History-Interaction&quot;&gt;History Interaction&lt;/a&gt;). The first character is the &lt;var&gt;history expansion&lt;/var&gt; character, that is, the character which signifies the start of a history expansion, normally &amp;lsquo;</source>
          <target state="translated">히스토리 확장, 빠른 대체 및 토큰 화를 제어하는 ​​최대 3 자 ( &lt;a href=&quot;history-interaction#History-Interaction&quot;&gt;히스토리 상호 작용&lt;/a&gt; 참조 ). 첫 번째 문자는 &lt;var&gt;history expansion&lt;/var&gt; 문자입니다. 즉, 히스토리 확장 의 시작을 나타내는 문자입니다. 일반적으로 '</target>
        </trans-unit>
        <trans-unit id="1467b55bf83d8f146d9cbd0dbde2ea1dffe5d0ca" translate="yes" xml:space="preserve">
          <source>Uppercase the current (or following) word. With a negative argument, uppercase the previous word, but do not move the cursor.</source>
          <target state="translated">현재 (또는 다음) 단어를 대문자로 바꿉니다. 음수 인수를 사용하면 이전 단어는 대문자이지만 커서를 움직이지 마십시오.</target>
        </trans-unit>
        <trans-unit id="9e5d9a89497ab86de574d743d1c130d84137f4f1" translate="yes" xml:space="preserve">
          <source>Use &lt;var&gt;keymap&lt;/var&gt; as the keymap to be affected by the subsequent bindings. Acceptable &lt;var&gt;keymap&lt;/var&gt; names are &lt;code&gt;emacs&lt;/code&gt;, &lt;code&gt;emacs-standard&lt;/code&gt;, &lt;code&gt;emacs-meta&lt;/code&gt;, &lt;code&gt;emacs-ctlx&lt;/code&gt;, &lt;code&gt;vi&lt;/code&gt;, &lt;code&gt;vi-move&lt;/code&gt;, &lt;code&gt;vi-command&lt;/code&gt;, and &lt;code&gt;vi-insert&lt;/code&gt;. &lt;code&gt;vi&lt;/code&gt; is equivalent to &lt;code&gt;vi-command&lt;/code&gt; (&lt;code&gt;vi-move&lt;/code&gt; is also a synonym); &lt;code&gt;emacs&lt;/code&gt; is equivalent to &lt;code&gt;emacs-standard&lt;/code&gt;.</source>
          <target state="translated">후속 바인딩에 의해 영향을받을 키맵을 &lt;var&gt;keymap&lt;/var&gt; 으로 사용하십시오 . 허용되는 &lt;var&gt;keymap&lt;/var&gt; 이름은 &lt;code&gt;emacs&lt;/code&gt; , &lt;code&gt;emacs-standard&lt;/code&gt; , &lt;code&gt;emacs-meta&lt;/code&gt; , &lt;code&gt;emacs-ctlx&lt;/code&gt; , &lt;code&gt;vi&lt;/code&gt; , &lt;code&gt;vi-move&lt;/code&gt; , &lt;code&gt;vi-command&lt;/code&gt; 및 &lt;code&gt;vi-insert&lt;/code&gt; 입니다. &lt;code&gt;vi&lt;/code&gt; 는 &lt;code&gt;vi-command&lt;/code&gt; 과 같습니다 ( &lt;code&gt;vi-move&lt;/code&gt; 는 동의어입니다). &lt;code&gt;emacs&lt;/code&gt; 는 &lt;code&gt;emacs-standard&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="7e07f77c9239bf54a759e369906e3a404f76bbe3" translate="yes" xml:space="preserve">
          <source>Use Readline&amp;rsquo;s default filename completion if the compspec generates no matches.</source>
          <target state="translated">compspec이 일치 항목을 생성하지 않으면 Readline의 기본 파일 이름 완성을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e13efcca92d8c2088b064f9a0d824489242298ce" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;vi&lt;/code&gt;-style line editing interface. This also affects the editing interface used for &lt;code&gt;read -e&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;vi&lt;/code&gt; 스타일 라인 편집 인터페이스를 사용하십시오 . 이것은 &lt;code&gt;read -e&lt;/code&gt; 사용되는 편집 인터페이스에도 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="6bd846b5b9947fcf59f1ab1e64ccb1efb4c70bfd" translate="yes" xml:space="preserve">
          <source>Use an &lt;code&gt;emacs&lt;/code&gt;-style line editing interface (see &lt;a href=&quot;command-line-editing#Command-Line-Editing&quot;&gt;Command Line Editing&lt;/a&gt;). This also affects the editing interface used for &lt;code&gt;read -e&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;emacs&lt;/code&gt; 스타일 라인 편집 인터페이스를 사용 하십시오 ( &lt;a href=&quot;command-line-editing#Command-Line-Editing&quot;&gt;명령 행 편집&lt;/a&gt; 참조 ). 이것은 &lt;code&gt;read -e&lt;/code&gt; 사용되는 편집 인터페이스에도 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="63e0786d5f5bb4e3503ea612859fa534484cfee9" translate="yes" xml:space="preserve">
          <source>Use and save the results of the tests in &lt;var&gt;file&lt;/var&gt; instead of</source>
          <target state="translated">테스트 결과를 &lt;var&gt;file&lt;/var&gt; 대신 파일로 사용 및 저장</target>
        </trans-unit>
        <trans-unit id="086fc1b30c6b83fd872491602730a60589b516d8" translate="yes" xml:space="preserve">
          <source>Use external files for the documentation displayed by the &lt;code&gt;help&lt;/code&gt; builtin instead of storing the text internally.</source>
          <target state="translated">텍스트를 내부적으로 저장하는 대신 &lt;code&gt;help&lt;/code&gt; 내장으로 표시되는 문서에 외부 파일을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="26b03b9d40d67e9e1aca335ea3a530a2b06427e8" translate="yes" xml:space="preserve">
          <source>Use function names only.</source>
          <target state="translated">기능 이름 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3939cfddf95079bf3c70d7f2c89621e7c5e8cb7d" translate="yes" xml:space="preserve">
          <source>Use in the Title Page (and on the covers, if any) a title distinct from that of the Document, and from those of previous versions (which should, if there were any, be listed in the History section of the Document). You may use the same title as a previous version if the original publisher of that version gives permission.</source>
          <target state="translated">제목 페이지 (및 표지가있는 경우)와 문서의 제목 및 이전 버전의 제목 (있는 경우 문서의 기록 섹션에 나열되어있는 제목)과는 다른 제목을 사용하십시오. 해당 버전의 원래 게시자가 권한을 부여한 경우 이전 버전과 동일한 제목을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e64a382a8d8334301f5273038636975edc03ca65" translate="yes" xml:space="preserve">
          <source>Use the Bash version of &lt;code&gt;malloc&lt;/code&gt; in the directory</source>
          <target state="translated">디렉토리에서 &lt;code&gt;malloc&lt;/code&gt; 의 Bash 버전을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d1791f137f37d4095496337401553258787738e6" translate="yes" xml:space="preserve">
          <source>Use the curses library instead of the termcap library. This should be supplied if your system has an inadequate or incomplete termcap database.</source>
          <target state="translated">termcap 라이브러리 대신 curses 라이브러리를 사용하십시오. 시스템에 불충분하거나 불완전한 termcap 데이터베이스가있는 경우 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="df5c8fd73ad894a813ccaad7a4925ed0c52f8123" translate="yes" xml:space="preserve">
          <source>Used by the &lt;code&gt;select&lt;/code&gt; command to determine the column length for printing selection lists. Automatically set if the &lt;code&gt;checkwinsize&lt;/code&gt; option is enabled (see &lt;a href=&quot;the-shopt-builtin#The-Shopt-Builtin&quot;&gt;The Shopt Builtin&lt;/a&gt;), or in an interactive shell upon receipt of a &lt;code&gt;SIGWINCH&lt;/code&gt;.</source>
          <target state="translated">에 의해 사용 &lt;code&gt;select&lt;/code&gt; 명령은 선택 목록을 인쇄에 필요한 열의 길이를 결정합니다. &lt;code&gt;checkwinsize&lt;/code&gt; 옵션이 활성화 된 경우 ( &lt;a href=&quot;the-shopt-builtin#The-Shopt-Builtin&quot;&gt;Shopt Builtin&lt;/a&gt; 참조 ) 또는 &lt;code&gt;SIGWINCH&lt;/code&gt; 를 받으면 대화식 쉘로 자동 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="41c569bca6c6eea434c09da3f820b58ed45456a1" translate="yes" xml:space="preserve">
          <source>Used by the &lt;code&gt;select&lt;/code&gt; command to determine the terminal width when printing selection lists. Automatically set if the &lt;code&gt;checkwinsize&lt;/code&gt; option is enabled (see &lt;a href=&quot;the-shopt-builtin#The-Shopt-Builtin&quot;&gt;The Shopt Builtin&lt;/a&gt;), or in an interactive shell upon receipt of a &lt;code&gt;SIGWINCH&lt;/code&gt;.</source>
          <target state="translated">에 의해 사용 &lt;code&gt;select&lt;/code&gt; 선택 목록을 인쇄 할 때 명령은 터미널 폭을 결정합니다. &lt;code&gt;checkwinsize&lt;/code&gt; 옵션이 활성화 된 경우 ( &lt;a href=&quot;the-shopt-builtin#The-Shopt-Builtin&quot;&gt;Shopt Builtin&lt;/a&gt; 참조 ) 또는 &lt;code&gt;SIGWINCH&lt;/code&gt; 를 받으면 대화식 쉘로 자동 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="40fdd5093c6c050a6b063cf37a4191fb09c2631e" translate="yes" xml:space="preserve">
          <source>Used to determine the locale category for any category not specifically selected with a variable starting with &lt;code&gt;LC_&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LC_&lt;/code&gt; 로 시작하는 변수로 특별히 선택되지 않은 범주의 로케일 범주를 결정하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="af0b7ad9a5bfd4d63654d75f68eb17698307be01" translate="yes" xml:space="preserve">
          <source>User names. May also be specified as</source>
          <target state="translated">사용자 이름 다음과 같이 지정할 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="af3138cc282360a8600ef75867abc1b680f535c7" translate="yes" xml:space="preserve">
          <source>Using &amp;lsquo;</source>
          <target state="translated">사용하여</target>
        </trans-unit>
        <trans-unit id="b6eae4c33c5f87493e2b1cc3498d3d490ac90534" translate="yes" xml:space="preserve">
          <source>Using History Interactively</source>
          <target state="translated">대화식으로 기록 사용</target>
        </trans-unit>
        <trans-unit id="da7ccfcc8a9a926b0b1350dc297a1e2c7cda35d9" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;enable&lt;/code&gt; builtin command to enable disabled shell builtins.</source>
          <target state="translated">사용은 &lt;code&gt;enable&lt;/code&gt; 장애인 쉘 내장 명령을 사용하려면 명령 내장.</target>
        </trans-unit>
        <trans-unit id="03b9ca37ed1619de24a56f058a1fe56ab343e43b" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;exec&lt;/code&gt; builtin to replace the shell with another command.</source>
          <target state="translated">&lt;code&gt;exec&lt;/code&gt; 내장을 사용하여 쉘을 다른 명령으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="8a6ac30a861e1619cd84db145124298ba539ad1f" translate="yes" xml:space="preserve">
          <source>Using the output of a command as an argument.</source>
          <target state="translated">명령의 출력을 인수로 사용</target>
        </trans-unit>
        <trans-unit id="c9ee5681d3c59f7541c27a38b67edf46259e187b" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>
        </trans-unit>
        <trans-unit id="a3984eeedbd717d8d0ec28ed3e564994273bb19d" translate="yes" xml:space="preserve">
          <source>VERBATIM COPYING</source>
          <target state="translated">완전 복사</target>
        </trans-unit>
        <trans-unit id="078318c4267a2eb76a7671446bb3b6cb23544b8c" translate="yes" xml:space="preserve">
          <source>Valid arguments for the</source>
          <target state="translated">에 대한 유효한 인수</target>
        </trans-unit>
        <trans-unit id="1fd56c936990b710865dc57bc3ae92376b9660a0" translate="yes" xml:space="preserve">
          <source>Variable Index</source>
          <target state="translated">변수 인덱스</target>
        </trans-unit>
        <trans-unit id="79e9eab118c299f006f827a6c037c20d995dac29" translate="yes" xml:space="preserve">
          <source>Variable Settings</source>
          <target state="translated">변수 설정</target>
        </trans-unit>
        <trans-unit id="8e276969864d32d41ccd66d053703a5cafa514c3" translate="yes" xml:space="preserve">
          <source>Variable assignments preceding commands affect only that command, even builtins and functions (see &lt;a href=&quot;environment#Environment&quot;&gt;Environment&lt;/a&gt;). In &lt;code&gt;sh&lt;/code&gt;, all variable assignments preceding commands are global unless the command is executed from the file system.</source>
          <target state="translated">명령 앞의 변수 할당은 해당 명령에만 영향을 미치며 내장 및 기능까지도 포함됩니다 ( &lt;a href=&quot;environment#Environment&quot;&gt;환경&lt;/a&gt; 참조 ). 에서 &lt;code&gt;sh&lt;/code&gt; 명령이 파일 시스템에서 실행되지 않는 한, 명령 앞에 모든 변수 할당은 글로벌 있습니다.</target>
        </trans-unit>
        <trans-unit id="51f507187d0a5a4031dcd2315875af72542c33c5" translate="yes" xml:space="preserve">
          <source>Variable names and values, where appropriate, are recognized without regard to case. Unrecognized variable names are ignored.</source>
          <target state="translated">적절한 경우 변수 이름과 값은 대소 문자에 관계없이 인식됩니다. 인식 할 수없는 변수 이름은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="8044f944dffdadb90c7080fe842ff08f4fe443ca" translate="yes" xml:space="preserve">
          <source>Variables Bash uses to customize job control.</source>
          <target state="translated">변수 Bash는 작업 제어를 사용자 정의하는 데 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fbf032cb2a8460171d364812c7ddfd295003fca8" translate="yes" xml:space="preserve">
          <source>Variables local to the function may be declared with the &lt;code&gt;local&lt;/code&gt; builtin. These variables are visible only to the function and the commands it invokes. This is particularly important when a shell function calls other functions.</source>
          <target state="translated">함수의 로컬 변수는 &lt;code&gt;local&lt;/code&gt; 내장 으로 선언 될 수 있습니다 . 이러한 변수는 함수와 함수가 호출하는 명령에만 표시됩니다. 쉘 함수가 다른 함수를 호출 할 때 특히 중요합니다.</target>
        </trans-unit>
        <trans-unit id="430be416ee1a6bde3f265a913e16640caf6ace5a" translate="yes" xml:space="preserve">
          <source>Variables present in the shell&amp;rsquo;s initial environment are automatically exported to child processes. The Bourne shell does not normally do this unless the variables are explicitly marked using the &lt;code&gt;export&lt;/code&gt; command.</source>
          <target state="translated">쉘의 초기 환경에 존재하는 변수는 자동으로 자식 프로세스로 내보내집니다. &lt;code&gt;export&lt;/code&gt; 명령을 사용하여 변수를 명시 적으로 표시하지 않으면 Bourne 쉘은 일반적으로이를 수행하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b841eae11bf9319d8d92ec0331d39213387a9de3" translate="yes" xml:space="preserve">
          <source>Variables used or set by Bash.</source>
          <target state="translated">Bash에 의해 사용되거나 설정된 변수.</target>
        </trans-unit>
        <trans-unit id="d5c2d85fcc8296c85c27d685fb685a43e5518049" translate="yes" xml:space="preserve">
          <source>Variables which Bash uses in the same way as the Bourne Shell.</source>
          <target state="translated">Bash가 Bourne Shell과 같은 방식으로 사용하는 변수.</target>
        </trans-unit>
        <trans-unit id="d10056db9d3e6245371ac5fd190b495d652b6fc2" translate="yes" xml:space="preserve">
          <source>Various indexes for this manual.</source>
          <target state="translated">이 매뉴얼에 대한 다양한 색인.</target>
        </trans-unit>
        <trans-unit id="850a1309ea27542661d46dd46aedeab66fe7f368" translate="yes" xml:space="preserve">
          <source>Version 1.3, 3 November 2008</source>
          <target state="translated">버전 1.3, 2008 년 11 월 3 일</target>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="0a5b141eb4ada1d94bec5095e760c2e909d3a511" translate="yes" xml:space="preserve">
          <source>Wait until the child process specified by each process &lt;small&gt;ID&lt;/small&gt;&lt;var&gt;pid&lt;/var&gt; or job specification &lt;var&gt;jobspec&lt;/var&gt; exits and return the exit status of the last command waited for. If a job spec is given, all processes in the job are waited for. If no arguments are given, all currently active child processes are waited for, and the return status is zero. If the</source>
          <target state="translated">각 프로세스 &lt;small&gt;ID &lt;/small&gt; &lt;var&gt;pid&lt;/var&gt; 또는 작업 스펙 &lt;var&gt;jobspec&lt;/var&gt; 에 의해 지정된 하위 프로세스가 종료 될 때까지 기다렸다가 마지막으로 대기 한 명령의 종료 상태를 리턴하십시오. 작업 스펙이 제공되면 작업의 모든 프로세스가 대기합니다. 인수가 제공되지 않으면 현재 활성화 된 모든 하위 프로세스가 대기되고 리턴 상태는 0입니다. 만약</target>
        </trans-unit>
        <trans-unit id="8b90f212f669732e5904ca7248796b2889df8819" translate="yes" xml:space="preserve">
          <source>Ways to group commands.</source>
          <target state="translated">명령을 그룹화하는 방법.</target>
        </trans-unit>
        <trans-unit id="852d4faf737a59961ad578b84ea1222167e054b1" translate="yes" xml:space="preserve">
          <source>We have designed this License in order to use it for manuals for free software, because free software needs free documentation: a free program should come with manuals providing the same freedoms that the software does. But this License is not limited to software manuals; it can be used for any textual work, regardless of subject matter or whether it is published as a printed book. We recommend this License principally for works whose purpose is instruction or reference.</source>
          <target state="translated">자유 소프트웨어에는 무료 문서가 필요하기 때문에 자유 소프트웨어의 매뉴얼에 사용하기 위해이 라이센스를 설계했습니다. 무료 프로그램에는 소프트웨어와 동일한 자유를 제공하는 매뉴얼이 제공되어야합니다. 그러나이 라이센스는 소프트웨어 매뉴얼에만 국한되지 않습니다. 주제 나 인쇄물로 출판되는지 여부에 관계없이 모든 텍스트 작업에 사용할 수 있습니다. 이 라이센스는 주로 지시 또는 참조 목적의 저작물에 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="29091257776e242dd78eb6e74a92f65c4271204f" translate="yes" xml:space="preserve">
          <source>We install the completion function using the</source>
          <target state="translated">우리는 완성 기능을 사용하여 설치합니다</target>
        </trans-unit>
        <trans-unit id="4b0b496aead232019c2e10fd95a82098e897c42d" translate="yes" xml:space="preserve">
          <source>What an interactive shell is.</source>
          <target state="translated">대화식 쉘이 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="ab1d5198de366563da43601f5c69be678890beff" translate="yes" xml:space="preserve">
          <source>What changes in a interactive shell?</source>
          <target state="translated">대화식 쉘에서 어떤 변화가 있습니까?</target>
        </trans-unit>
        <trans-unit id="dd12fe3d72f2be333642d248e003627799a52910" translate="yes" xml:space="preserve">
          <source>What determines whether a shell is Interactive.</source>
          <target state="translated">쉘이 대화식인지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="d8b792b93ede4848c41e5ef18bf5b05c6f2202b7" translate="yes" xml:space="preserve">
          <source>What happens when Bash or a command it runs receives a signal.</source>
          <target state="translated">Bash 또는 명령이 실행되면 어떤 일이 발생합니까?</target>
        </trans-unit>
        <trans-unit id="cc61a16a9f07eba1d18f3025bdb8bae3ec152b43" translate="yes" xml:space="preserve">
          <source>What happens when you run a command.</source>
          <target state="translated">명령을 실행하면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="39753cb75cb0c5b74594822c0841eb7267bb71f1" translate="yes" xml:space="preserve">
          <source>What is Bash?</source>
          <target state="translated">배쉬 란?</target>
        </trans-unit>
        <trans-unit id="90d69a46587495539e22be234f38996aeb0a37a8" translate="yes" xml:space="preserve">
          <source>What is a shell?</source>
          <target state="translated">껍질이란?</target>
        </trans-unit>
        <trans-unit id="b879b4c80058832d18ae19e85070d872239273ac" translate="yes" xml:space="preserve">
          <source>What is an Interactive Shell?</source>
          <target state="translated">대화식 쉘이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="1fae4b61a51c5003ef635ba37d077edfd5a02985" translate="yes" xml:space="preserve">
          <source>What it feels like using History as a user.</source>
          <target state="translated">History를 사용자로 사용하는 느낌</target>
        </trans-unit>
        <trans-unit id="8718a1b15e428da49ae66e23ad7a8d7458d79675" translate="yes" xml:space="preserve">
          <source>What job control is and how Bash allows you to use it.</source>
          <target state="translated">작업 제어 란 무엇이며 Bash를 사용하는 방법.</target>
        </trans-unit>
        <trans-unit id="a32696e6dfe2c38566b0745c6133dc7f5f2f730e" translate="yes" xml:space="preserve">
          <source>What your input means to the shell.</source>
          <target state="translated">쉘에 입력 한 내용</target>
        </trans-unit>
        <trans-unit id="769bb19e615b7f8e2809e5882e2d05a18f57a531" translate="yes" xml:space="preserve">
          <source>When</source>
          <target state="translated">When</target>
        </trans-unit>
        <trans-unit id="939eb0fb342f62f76ac14f8030ccea8867055342" translate="yes" xml:space="preserve">
          <source>When Bash invokes an external command, the variable &amp;lsquo;</source>
          <target state="translated">Bash가 외부 명령을 호출하면 변수 '</target>
        </trans-unit>
        <trans-unit id="0890f61347bbf1ac979377a2c90aa96f3d70fe3f" translate="yes" xml:space="preserve">
          <source>When Bash is interactive, in the absence of any traps, it ignores &lt;code&gt;SIGTERM&lt;/code&gt; (so that &amp;lsquo;</source>
          <target state="translated">Bash가 대화식 일 때 트랩이 없으면 &lt;code&gt;SIGTERM&lt;/code&gt; 을 무시합니다 ( '</target>
        </trans-unit>
        <trans-unit id="343e2279b1b41bc9544bf20f1acd36ea8c90f0ca" translate="yes" xml:space="preserve">
          <source>When Bash is invoked as an interactive login shell, or as a non-interactive shell with the</source>
          <target state="translated">Bash가 대화 형 로그인 셸로 또는 비 대화식 셸로 호출 된 경우</target>
        </trans-unit>
        <trans-unit id="ba9c71060dccd3fa7de0b7ad1f41d0d3299654e9" translate="yes" xml:space="preserve">
          <source>When Bash is not executing in &lt;small&gt;POSIX&lt;/small&gt; mode, these builtins behave no differently than the rest of the Bash builtin commands. The Bash &lt;small&gt;POSIX&lt;/small&gt; mode is described in &lt;a href=&quot;bash-posix-mode#Bash-POSIX-Mode&quot;&gt;Bash POSIX Mode&lt;/a&gt;.</source>
          <target state="translated">Bash가 &lt;small&gt;POSIX&lt;/small&gt; 모드 에서 실행되지 않는 경우 이러한 내장 기능은 나머지 Bash 내장 명령과 다르게 작동하지 않습니다. 배시 &lt;small&gt;POSIX의&lt;/small&gt; 모드가 설명되어 &lt;a href=&quot;bash-posix-mode#Bash-POSIX-Mode&quot;&gt;배시 POSIX 모드&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a2bbe73ce70477a17845633ac0643ee9f742681a" translate="yes" xml:space="preserve">
          <source>When Bash is started in &lt;small&gt;POSIX&lt;/small&gt; mode, as with the</source>
          <target state="translated">&lt;small&gt;POSIX&lt;/small&gt; 모드 에서 Bash가 시작될 때</target>
        </trans-unit>
        <trans-unit id="635f7b7cfca984f782445c48ff197663304bc7a7" translate="yes" xml:space="preserve">
          <source>When Bash is started non-interactively, to run a shell script, for example, it looks for the variable &lt;code&gt;BASH_ENV&lt;/code&gt; in the environment, expands its value if it appears there, and uses the expanded value as the name of a file to read and execute. Bash behaves as if the following command were executed:</source>
          <target state="translated">Bash가 비 대화식으로 시작될 때, 예를 들어, 쉘 스크립트를 실행하기 위해 환경에서 변수 &lt;code&gt;BASH_ENV&lt;/code&gt; 를 찾고 , 거기에 표시되면 값을 확장하고, 확장 된 값을 읽고 실행할 파일 이름으로 사용합니다. . Bash는 다음 명령이 실행 된 것처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="3fe565d734cceecb3fe936c7e6c90c5086f2c931" translate="yes" xml:space="preserve">
          <source>When Bash runs a shell script, it sets the special parameter &lt;code&gt;0&lt;/code&gt; to the name of the file, rather than the name of the shell, and the positional parameters are set to the remaining arguments, if any are given. If no additional arguments are supplied, the positional parameters are unset.</source>
          <target state="translated">Bash는 쉘 스크립트를 실행할 때 특수 매개 변수 &lt;code&gt;0&lt;/code&gt; 을 쉘 이름이 아닌 파일 이름으로 설정하고 위치 매개 변수는 나머지 인수로 설정됩니다 (있는 경우). 추가 인수가 제공되지 않으면 위치 매개 변수가 설정 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="9e58abd297c6a4133cd5d738bac34e27741aabae" translate="yes" xml:space="preserve">
          <source>When a command in the hash table no longer exists, Bash will re-search &lt;code&gt;$PATH&lt;/code&gt; to find the new location. This is also available with &amp;lsquo;</source>
          <target state="translated">해시 테이블에 명령이 더 이상 존재하지 않으면 Bash는 &lt;code&gt;$PATH&lt;/code&gt; 를 다시 검색 하여 새 위치를 찾습니다. 이것은 '</target>
        </trans-unit>
        <trans-unit id="57adcc6112f09b93153336f00fc3a43b19f963c4" translate="yes" xml:space="preserve">
          <source>When a command that is found to be a shell script is executed (see &lt;a href=&quot;shell-scripts#Shell-Scripts&quot;&gt;Shell Scripts&lt;/a&gt;), &lt;code&gt;rbash&lt;/code&gt; turns off any restrictions in the shell spawned to execute the script.</source>
          <target state="translated">발견 명령이 쉘 스크립트가 실행 될 때 (참조 &lt;a href=&quot;shell-scripts#Shell-Scripts&quot;&gt;쉘 스크립트&lt;/a&gt; ), &lt;code&gt;rbash&lt;/code&gt; 셸에서 어떤 제한 해제 회전 스크립트를 실행하기 위해 양산.</target>
        </trans-unit>
        <trans-unit id="ba8875efd01dda7b5b4b30097c6e56268320958f" translate="yes" xml:space="preserve">
          <source>When a compspec indicates that directory name completion is desired, the programmable completion functions force Readline to append a slash to completed names which are symbolic links to directories, subject to the value of the &lt;var&gt;mark-directories&lt;/var&gt; Readline variable, regardless of the setting of the &lt;var&gt;mark-symlinked-directories&lt;/var&gt; Readline variable.</source>
          <target state="translated">compspec이 디렉토리 이름 완성을 원한다고 표시하면 프로그램 가능 완료 기능은 Readline이 &lt;var&gt;mark-directories&lt;/var&gt; 설정에 관계없이 mark-directories Readline 변수 의 값에 따라 디렉토리에 대한 심볼릭 링크 인 완성 된 이름에 슬래시를 추가 하도록 &lt;var&gt;mark-symlinked-directories&lt;/var&gt; Readline 변수.</target>
        </trans-unit>
        <trans-unit id="d12530caddaa309fd835ff8499a285072c87b11d" translate="yes" xml:space="preserve">
          <source>When a function is executed, the arguments to the function become the positional parameters during its execution (see &lt;a href=&quot;positional-parameters#Positional-Parameters&quot;&gt;Positional Parameters&lt;/a&gt;). The special parameter &amp;lsquo;</source>
          <target state="translated">함수가 실행될 때 함수에 대한 인수는 실행 중에 위치 매개 변수가됩니다 ( &lt;a href=&quot;positional-parameters#Positional-Parameters&quot;&gt;위치 매개 변수&lt;/a&gt; 참조 ). 특수 매개 변수 '</target>
        </trans-unit>
        <trans-unit id="d37f53584df0fca3f86fc274012236330d7d58b4" translate="yes" xml:space="preserve">
          <source>When a pattern is used for filename expansion, the character &amp;lsquo;</source>
          <target state="translated">파일 이름 확장에 패턴을 사용하면 '</target>
        </trans-unit>
        <trans-unit id="39b62095a08bd7b0216aa1ae612e33d7154823e0" translate="yes" xml:space="preserve">
          <source>When a positional parameter consisting of more than a single digit is expanded, it must be enclosed in braces.</source>
          <target state="translated">두 자리 이상의 숫자로 구성된 위치 매개 변수가 확장되면 중괄호로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="fa4f52edd6f757831ec88733a19fa50ef12a0318" translate="yes" xml:space="preserve">
          <source>When a program is invoked it is given an array of strings called the &lt;var&gt;environment&lt;/var&gt;. This is a list of name-value pairs, of the form &lt;code&gt;name=value&lt;/code&gt;.</source>
          <target state="translated">프로그램이 호출되면 &lt;var&gt;environment&lt;/var&gt; 라는 문자열 배열이 제공 됩니다 . 이것은 &lt;code&gt;name=value&lt;/code&gt; 형식의 이름-값 쌍 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="2bda9944164cf112452d8f8b52615725cfd5de8c" translate="yes" xml:space="preserve">
          <source>When a program which uses the Readline library starts up, the init file is read, and the key bindings are set.</source>
          <target state="translated">Readline 라이브러리를 사용하는 프로그램이 시작되면 init 파일이 읽히고 키 바인딩이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="2a80ca567de1dd1b14b3ed0a6268811838e44d22" translate="yes" xml:space="preserve">
          <source>When a simple command is executed, the shell performs the following expansions, assignments, and redirections, from left to right.</source>
          <target state="translated">간단한 명령이 실행되면 셸은 왼쪽에서 오른쪽으로 다음과 같은 확장, 할당 및 리디렉션을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="232e66604a9df4ec85b78e97b1ef5290dc8d67f1" translate="yes" xml:space="preserve">
          <source>When a simple command other than a builtin or shell function is to be executed, it is invoked in a separate execution environment that consists of the following. Unless otherwise noted, the values are inherited from the shell.</source>
          <target state="translated">내장 또는 쉘 함수 이외의 간단한 명령을 실행하려면 다음으로 구성된 별도의 실행 환경에서 호출됩니다. 다른 언급이 없으면 값은 셸에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="ccdb235821ba3486822d12a838408ae1ed87a59e" translate="yes" xml:space="preserve">
          <source>When an interactive login shell exits, or a non-interactive login shell executes the &lt;code&gt;exit&lt;/code&gt; builtin command, Bash reads and executes commands from the file</source>
          <target state="translated">대화식 로그인 쉘이 종료되거나 비 대화식 로그인 쉘이 &lt;code&gt;exit&lt;/code&gt; 내장 명령을 실행하면 Bash는 파일에서 명령을 읽고 실행합니다.</target>
        </trans-unit>
        <trans-unit id="007b34e03af0dd54d201a22183121ea255813af1" translate="yes" xml:space="preserve">
          <source>When an interactive shell that is not a login shell is started, Bash reads and executes commands from</source>
          <target state="translated">로그인 쉘이 아닌 대화식 쉘이 시작되면 Bash는 다음 명령을 읽고 실행합니다.</target>
        </trans-unit>
        <trans-unit id="1a6fb1716bf550e6d2fd9e84ef26357c744a0df8" translate="yes" xml:space="preserve">
          <source>When and how Bash executes scripts.</source>
          <target state="translated">Bash가 스크립트를 언제 어떻게 실행하는지.</target>
        </trans-unit>
        <trans-unit id="4be03dfe6149d22e64c1dcd3fbf25bf1461e8f4c" translate="yes" xml:space="preserve">
          <source>When any of the</source>
          <target state="translated">때 중 하나</target>
        </trans-unit>
        <trans-unit id="8c7f4665380351078a4b92b8f13ce1c59aee44b4" translate="yes" xml:space="preserve">
          <source>When assigning to an associative array, the subscript is required.</source>
          <target state="translated">연관 배열에 할당 할 때는 아래 첨자가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="dde5b5c589a1e1bd4e9b27320e42bdff38c97b2f" translate="yes" xml:space="preserve">
          <source>When assigning to an indexed array, if &lt;var&gt;name&lt;/var&gt; is subscripted by a negative number, that number is interpreted as relative to one greater than the maximum index of &lt;var&gt;name&lt;/var&gt;, so negative indices count back from the end of the array, and an index of -1 references the last element.</source>
          <target state="translated">인덱스 배열에 할당 할 때 &lt;var&gt;name&lt;/var&gt; 이 음수로 첨자 화 된 경우 해당 숫자는 &lt;var&gt;name&lt;/var&gt; 의 최대 인덱스보다 1이 큰 것으로 해석 되므로 음수 인덱스는 배열의 끝에서 다시 카운트되며 인덱스는 -1입니다. 마지막 요소를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="7d3d6c790567d2b34fc873d9fa4fe748f8ccf81a" translate="yes" xml:space="preserve">
          <source>When available, process substitution is performed simultaneously with parameter and variable expansion, command substitution, and arithmetic expansion.</source>
          <target state="translated">사용 가능한 경우 프로세스 대체는 매개 변수 및 변수 확장, 명령 대체 및 산술 확장과 동시에 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="538a71ef848f2a6c380b3706ed7f7e699e1a41b2" translate="yes" xml:space="preserve">
          <source>When braces are used, the matching ending brace is the first &amp;lsquo;</source>
          <target state="translated">중괄호를 사용하면 일치하는 끝 중괄호가 첫 번째 '</target>
        </trans-unit>
        <trans-unit id="3c096d63a7ffed613b88cf6e90a5e52589593c53" translate="yes" xml:space="preserve">
          <source>When entering the text of a macro, single or double quotes must be used to indicate a macro definition. Unquoted text is assumed to be a function name. In the macro body, the backslash escapes described above are expanded. Backslash will quote any other character in the macro text, including &amp;lsquo;</source>
          <target state="translated">매크로 텍스트를 입력 할 때 매크로 정의를 나타내려면 작은 따옴표 나 큰 따옴표를 사용해야합니다. 인용되지 않은 텍스트는 함수 이름으로 간주됩니다. 매크로 본문에서 위에서 설명한 백 슬래시 이스케이프가 확장됩니다. 백 슬래시는 매크로 텍스트에 '</target>
        </trans-unit>
        <trans-unit id="9fd112b30cf6c4d2c65ca00e38b79431df23dbb8" translate="yes" xml:space="preserve">
          <source>When expanding the &amp;lsquo;</source>
          <target state="translated">'</target>
        </trans-unit>
        <trans-unit id="41bb4f6e6938705bf7fc6b9c00d3541469a830b9" translate="yes" xml:space="preserve">
          <source>When invoked as &lt;code&gt;sh&lt;/code&gt;, Bash enters &lt;small&gt;POSIX&lt;/small&gt; mode after reading the startup files.</source>
          <target state="translated">&lt;code&gt;sh&lt;/code&gt; 로 호출되면 Bash는 시작 파일을 읽은 후 &lt;small&gt;POSIX&lt;/small&gt; 모드 로 들어갑니다 .</target>
        </trans-unit>
        <trans-unit id="add21ed4442cf9a2dd8325bddafd1fb2bfefad0a" translate="yes" xml:space="preserve">
          <source>When invoked as &lt;code&gt;sh&lt;/code&gt;, Bash enters &lt;small&gt;POSIX&lt;/small&gt; mode after the startup files are read.</source>
          <target state="translated">&lt;code&gt;sh&lt;/code&gt; 로 호출되면 시작 파일을 읽은 후 Bash가 &lt;small&gt;POSIX&lt;/small&gt; 모드 로 들어갑니다 .</target>
        </trans-unit>
        <trans-unit id="8e8a7270151e34910804cc9c116cd8f1097bd0d4" translate="yes" xml:space="preserve">
          <source>When invoked as an interactive login shell, or as a non-interactive shell with the</source>
          <target state="translated">대화식 로그인 셸 또는을 사용하여 비 대화식 셸로 호출 된 경우</target>
        </trans-unit>
        <trans-unit id="7953fce75850b2edb7b98ee9a7e7bfd7be5cbdf7" translate="yes" xml:space="preserve">
          <source>When job control is not active, the &lt;code&gt;kill&lt;/code&gt; and &lt;code&gt;wait&lt;/code&gt; builtins do not accept &lt;var&gt;jobspec&lt;/var&gt; arguments. They must be supplied process &lt;small&gt;ID&lt;/small&gt;s.</source>
          <target state="translated">작업 제어가 활성화되지 않은 경우, &lt;code&gt;kill&lt;/code&gt; 및 &lt;code&gt;wait&lt;/code&gt; 내장은 &lt;var&gt;jobspec&lt;/var&gt; 인수를 허용하지 않습니다 . 프로세스 &lt;small&gt;ID를&lt;/small&gt; 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0a281c916b9b7bd87cb943e319b56cec58fcf88e" translate="yes" xml:space="preserve">
          <source>When listing the history, the &lt;code&gt;fc&lt;/code&gt; builtin does not include an indication of whether or not a history entry has been modified.</source>
          <target state="translated">히스토리를 나열 할 때 &lt;code&gt;fc&lt;/code&gt; 내장은 히스토리 항목이 수정되었는지 여부에 대한 표시를 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="80ce90571990e51b3a376a35bfbe9d5d0aab248f" translate="yes" xml:space="preserve">
          <source>When matching a filename, the slash character must always be matched explicitly by a slash in the pattern, but in other matching contexts it can be matched by a special pattern character as described below (see &lt;a href=&quot;pattern-matching#Pattern-Matching&quot;&gt;Pattern Matching&lt;/a&gt;).</source>
          <target state="translated">파일 이름을 일치시킬 때 슬래시 문자는 항상 패턴에서 슬래시와 명시 적으로 일치해야하지만 다른 일치하는 컨텍스트에서는 아래 설명 된대로 특수 패턴 문자와 일치 할 수 있습니다 ( &lt;a href=&quot;pattern-matching#Pattern-Matching&quot;&gt;패턴 일치&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="94526a55da849b0bce77ccd1dca347592dcac65f" translate="yes" xml:space="preserve">
          <source>When no arguments are given, &lt;code&gt;popd&lt;/code&gt; removes the top directory from the stack and performs a &lt;code&gt;cd&lt;/code&gt; to the new top directory. The elements are numbered from 0 starting at the first directory listed with &lt;code&gt;dirs&lt;/code&gt;; that is, &lt;code&gt;popd&lt;/code&gt; is equivalent to &lt;code&gt;popd +0&lt;/code&gt;.</source>
          <target state="translated">인수를 지정하지 않으면 &lt;code&gt;popd&lt;/code&gt; 는 스택에서 최상위 디렉토리를 제거 하고 새 최상위 디렉토리로 &lt;code&gt;cd&lt;/code&gt; 를 수행합니다 . 요소는 &lt;code&gt;dirs&lt;/code&gt; 로 나열된 첫 번째 디렉토리에서 시작하여 0부터 번호가 매겨집니다 . 즉, &lt;code&gt;popd&lt;/code&gt; 는 &lt;code&gt;popd +0&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f35704d27cbab8942f6e0f842f935547c255c02b" translate="yes" xml:space="preserve">
          <source>When not performing substring expansion, using the form described below (e.g., &amp;lsquo;</source>
          <target state="translated">하위 문자열 확장을 수행하지 않는 경우 아래 설명 된 형식을 사용하십시오 (예 : '</target>
        </trans-unit>
        <trans-unit id="15e33c9da97e268b5d63a9391a2bce0492152a19" translate="yes" xml:space="preserve">
          <source>When options are supplied, they set or unset shell attributes. Options, if specified, have the following meanings:</source>
          <target state="translated">옵션이 제공되면 쉘 속성을 설정하거나 설정 해제합니다. 지정된 경우 옵션의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a6580a4e014bfeccd6ef9a819a5f70cd8425c69c" translate="yes" xml:space="preserve">
          <source>When parsing and expanding a ${&amp;hellip;} expansion that appears within double quotes, single quotes are no longer special and cannot be used to quote a closing brace or other special character, unless the operator is one of those defined to perform pattern removal. In this case, they do not have to appear as matched pairs.</source>
          <target state="translated">큰 따옴표 안에있는 $ {&amp;hellip;} 확장을 구문 분석하고 확장 할 때, 작은 따옴표는 더 이상 특별하지 않으며 연산자가 패턴 제거를 수행하도록 정의 된 문자 중 하나가 아닌 한 닫는 중괄호 나 다른 특수 문자를 인용하는 데 사용할 수 없습니다. 이 경우 일치하는 쌍으로 표시 될 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6971c57a17fffc05a32d0d3f7c561163f04ec7c2" translate="yes" xml:space="preserve">
          <source>When printing shell function definitions (e.g., by &lt;code&gt;type&lt;/code&gt;), Bash does not print the &lt;code&gt;function&lt;/code&gt; keyword.</source>
          <target state="translated">쉘 함수 정의를 인쇄 할 때 (예 : &lt;code&gt;type&lt;/code&gt; ) Bash는 &lt;code&gt;function&lt;/code&gt; 키워드를 인쇄하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="150c68ccee034162950161be62a4f805a5ef9435" translate="yes" xml:space="preserve">
          <source>When referenced, this variable expands to the name of the shell or shell script (identical to &lt;code&gt;$0&lt;/code&gt;; See &lt;a href=&quot;special-parameters#Special-Parameters&quot;&gt;Special Parameters&lt;/a&gt;, for the description of special parameter 0). Assignment to &lt;code&gt;BASH_ARGV0&lt;/code&gt; causes the value assigned to also be assigned to &lt;code&gt;$0&lt;/code&gt;. If &lt;code&gt;BASH_ARGV0&lt;/code&gt; is unset, it loses its special properties, even if it is subsequently reset.</source>
          <target state="translated">참조하면, 쉘이나 쉘 스크립트의 이름이 변수가 확장 (동일 &lt;code&gt;$0&lt;/code&gt; ; 참조 &lt;a href=&quot;special-parameters#Special-Parameters&quot;&gt;특수 매개 변수&lt;/a&gt; , 특수 매개 변수 0의 설명). &lt;code&gt;BASH_ARGV0&lt;/code&gt; 에 지정 하면 지정된 값도 &lt;code&gt;$0&lt;/code&gt; 지정됩니다 . 경우 &lt;code&gt;BASH_ARGV0&lt;/code&gt; 가 설정되지, 그것은 나중에 다시 경우에도 특별한 속성을 잃게된다.</target>
        </trans-unit>
        <trans-unit id="086cf6906dc04f0765087bbc691ace44014c43a1" translate="yes" xml:space="preserve">
          <source>When running in &lt;small&gt;POSIX&lt;/small&gt; mode, a special builtin returning an error status will not cause the shell to exit (see &lt;a href=&quot;bash-posix-mode#Bash-POSIX-Mode&quot;&gt;Bash POSIX Mode&lt;/a&gt;).</source>
          <target state="translated">&lt;small&gt;POSIX&lt;/small&gt; 모드 에서 실행할 때 오류 상태를 리턴하는 특수 내장 기능은 쉘을 종료하지 않습니다 ( &lt;a href=&quot;bash-posix-mode#Bash-POSIX-Mode&quot;&gt;Bash POSIX 모드&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7b8317d3aa6cbfb795fe137ca454414725d9ebe3" translate="yes" xml:space="preserve">
          <source>When set to &amp;lsquo;</source>
          <target state="translated">'로 설정하면</target>
        </trans-unit>
        <trans-unit id="55f3e3f1e06a97818ce0ffb33865599309fb29ae" translate="yes" xml:space="preserve">
          <source>When the</source>
          <target state="translated">때</target>
        </trans-unit>
        <trans-unit id="ed6f6132d172440c1347341297e43687516fbe0f" translate="yes" xml:space="preserve">
          <source>When the &amp;lsquo;</source>
          <target state="translated">때 '</target>
        </trans-unit>
        <trans-unit id="753d257bf6ee3cd6f44fec11ebbaeca478a30867" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;[&lt;/code&gt; form is used, the last argument to the command must be a &lt;code&gt;]&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;[&lt;/code&gt; 형태가 사용되는 명령의 마지막 인자는이어야 &lt;code&gt;]&lt;/code&gt; 가 .</target>
        </trans-unit>
        <trans-unit id="bd8fbc4c3ab7b1cc80a0533e910af5b054950285" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;alias&lt;/code&gt; builtin displays alias definitions, it does not display them with a leading &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;alias&lt;/code&gt; 내장이 별명 정의를 표시 할 때 앞에 '</target>
        </trans-unit>
        <trans-unit id="ede03a75a00c40b7521d02f5b9c764a1fc9ff744" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;cd&lt;/code&gt; builtin cannot change a directory because the length of the pathname constructed from &lt;code&gt;$PWD&lt;/code&gt; and the directory name supplied as an argument exceeds &lt;var&gt;PATH_MAX&lt;/var&gt; when all symbolic links are expanded, &lt;code&gt;cd&lt;/code&gt; will fail instead of attempting to use only the supplied directory name.</source>
          <target state="translated">모든 기호 링크가 확장 될 때 &lt;code&gt;$PWD&lt;/code&gt; 에서 생성 된 경로 이름의 길이 와 인수로 제공된 디렉토리 이름이 &lt;var&gt;PATH_MAX&lt;/var&gt; 를 초과 하여 &lt;code&gt;cd&lt;/code&gt; 내장에서 디렉토리를 변경할 수없는 경우, 제공된 디렉토리 이름 만 사용하는 대신 &lt;code&gt;cd&lt;/code&gt; 가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="e03d0b8eac300db42ea692af51322d2345246227" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;cd&lt;/code&gt; builtin is invoked in &lt;var&gt;logical&lt;/var&gt; mode, and the pathname constructed from &lt;code&gt;$PWD&lt;/code&gt; and the directory name supplied as an argument does not refer to an existing directory, &lt;code&gt;cd&lt;/code&gt; will fail instead of falling back to &lt;var&gt;physical&lt;/var&gt; mode.</source>
          <target state="translated">때 &lt;code&gt;cd&lt;/code&gt; 내장이에 호출 &lt;var&gt;logical&lt;/var&gt; 모드,로 구성 경로 이름 &lt;code&gt;$PWD&lt;/code&gt; 인수가 기존의 디렉토리를 참조하지 않는 및 디렉토리 이름 공급, &lt;code&gt;cd&lt;/code&gt; 대신 다시 떨어지는 실패 &lt;var&gt;physical&lt;/var&gt; 모드.</target>
        </trans-unit>
        <trans-unit id="70b34d9bc91438d8df4f544558ff765251e270cf" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;set&lt;/code&gt; builtin is invoked without options, it displays variable values without quotes, unless they contain shell metacharacters, even if the result contains nonprinting characters.</source>
          <target state="translated">때 &lt;code&gt;set&lt;/code&gt; 내장이 옵션없이 호출 그들은 결과가 인쇄되지 않는 문자가 포함 된 경우에도, 쉘 메타 문자를 포함하지 않는 한, 그것은 따옴표없이 변수 값을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="e3b23cbca44922a690aeaf426ca126c4c99bf9c1" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;set&lt;/code&gt; builtin is invoked without options, it does not display shell function names and definitions.</source>
          <target state="translated">때 &lt;code&gt;set&lt;/code&gt; 내장이 옵션없이 호출, 그것을 쉘 함수 이름과 정의를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="17d27a57c44a0c7b3e09cf75676ad49580258f1e" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;xpg_echo&lt;/code&gt; option is enabled, Bash does not attempt to interpret any arguments to &lt;code&gt;echo&lt;/code&gt; as options. Each argument is displayed, after escape characters are converted.</source>
          <target state="translated">때 &lt;code&gt;xpg_echo&lt;/code&gt; 의 옵션이 활성화되어, 배쉬는 어떤 인수를 해석하려고 시도하지 않습니다 &lt;code&gt;echo&lt;/code&gt; 옵션으로. 이스케이프 문자가 변환 된 후 각 인수가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="199243eb479e5f8d4ee5c53671c20467621f2580" translate="yes" xml:space="preserve">
          <source>When the coprocess is executed, the shell creates an array variable (see &lt;a href=&quot;arrays#Arrays&quot;&gt;Arrays&lt;/a&gt;) named &lt;code&gt;NAME&lt;/code&gt; in the context of the executing shell. The standard output of &lt;var&gt;command&lt;/var&gt; is connected via a pipe to a file descriptor in the executing shell, and that file descriptor is assigned to &lt;code&gt;NAME&lt;/code&gt;[0]. The standard input of &lt;var&gt;command&lt;/var&gt; is connected via a pipe to a file descriptor in the executing shell, and that file descriptor is assigned to &lt;code&gt;NAME&lt;/code&gt;[1]. This pipe is established before any redirections specified by the command (see &lt;a href=&quot;redirections#Redirections&quot;&gt;Redirections&lt;/a&gt;). The file descriptors can be utilized as arguments to shell commands and redirections using standard word expansions. Other than those created to execute command and process substitutions, the file descriptors are not available in subshells.</source>
          <target state="translated">코 프로세스가 실행될 때, 쉘은 실행중인 쉘의 컨텍스트에서 &lt;code&gt;NAME&lt;/code&gt; 이라는 배열 변수 ( &lt;a href=&quot;arrays#Arrays&quot;&gt;배열&lt;/a&gt; 참조 )를 작성합니다 . &lt;var&gt;command&lt;/var&gt; 의 표준 출력은 파이프를 통해 실행 쉘의 파일 디스크립터에 연결되며 해당 파일 디스크립터는 &lt;code&gt;NAME&lt;/code&gt; [0]에 지정됩니다 . &lt;var&gt;command&lt;/var&gt; 의 표준 입력은 파이프를 통해 실행 쉘의 파일 디스크립터에 연결되며 해당 파일 디스크립터는 &lt;code&gt;NAME&lt;/code&gt; [1]에 지정됩니다 . 이 파이프는 명령으로 지정된 리디렉션 전에 설정됩니다 ( &lt;a href=&quot;redirections#Redirections&quot;&gt;리디렉션&lt;/a&gt; 참조).). 파일 디스크립터는 표준 단어 확장을 사용하여 쉘 명령 및 경로 재 지정에 대한 인수로 사용될 수 있습니다. 명령 및 프로세스 대체를 실행하기 위해 작성된 것 이외의 파일 디스크립터는 서브 쉘에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="272fd40115d9a135d8797ba275f3cd6b25337922" translate="yes" xml:space="preserve">
          <source>When the end of options is encountered, &lt;code&gt;getopts&lt;/code&gt; exits with a return value greater than zero. &lt;code&gt;OPTIND&lt;/code&gt; is set to the index of the first non-option argument, and &lt;var&gt;name&lt;/var&gt; is set to &amp;lsquo;</source>
          <target state="translated">옵션의 끝이 발생하면 &lt;code&gt;getopts&lt;/code&gt; 는 리턴 값이 0보다 큰 엑시트를 종료합니다. &lt;code&gt;OPTIND&lt;/code&gt; 는 옵션이 아닌 첫 번째 인수의 색인으로 설정 되고 &lt;var&gt;name&lt;/var&gt; 은 '</target>
        </trans-unit>
        <trans-unit id="d2ed536c18161a096582f70b1168f7b1216c7832" translate="yes" xml:space="preserve">
          <source>When the old-style backquote form of substitution is used, backslash retains its literal meaning except when followed by &amp;lsquo;</source>
          <target state="translated">이전 스타일의 역 따옴표 대체 형식을 사용하는 경우 백 슬래시는 뒤에 '</target>
        </trans-unit>
        <trans-unit id="96a9041d224ded50f6d61046286100832281d2e7" translate="yes" xml:space="preserve">
          <source>When the shell is in &lt;small&gt;POSIX&lt;/small&gt; mode (see &lt;a href=&quot;bash-posix-mode#Bash-POSIX-Mode&quot;&gt;Bash POSIX Mode&lt;/a&gt;), &lt;code&gt;time&lt;/code&gt; may be followed by a newline. In this case, the shell displays the total user and system time consumed by the shell and its children. The &lt;code&gt;TIMEFORMAT&lt;/code&gt; variable may be used to specify the format of the time information.</source>
          <target state="translated">쉘이 &lt;small&gt;POSIX&lt;/small&gt; 모드 인 경우 ( &lt;a href=&quot;bash-posix-mode#Bash-POSIX-Mode&quot;&gt;Bash POSIX 모드&lt;/a&gt; 참조 ) &lt;code&gt;time&lt;/code&gt; 뒤에 줄 바꿈이 올 수 있습니다. 이 경우 셸에는 셸과 해당 자식에서 소비 한 총 사용자 및 시스템 시간이 표시됩니다. &lt;code&gt;TIMEFORMAT&lt;/code&gt; 의 변수는 시간 정보의 포맷을 지정하기 위해 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="d4ec193a539c22ac5eca91a72f81d7adf6025612" translate="yes" xml:space="preserve">
          <source>When the shell is running interactively, it changes its behavior in several ways.</source>
          <target state="translated">쉘이 대화식으로 실행되면 여러 가지 방식으로 동작이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="e42b85a148a076bbc7a895300855a32abf142653" translate="yes" xml:space="preserve">
          <source>When the shell is waiting for a job or process using the &lt;code&gt;wait&lt;/code&gt; builtin, and job control is enabled, &lt;code&gt;wait&lt;/code&gt; will return when the job changes state. The</source>
          <target state="translated">쉘이 대기 내장 기능을 사용하여 작업 또는 프로세스를 &lt;code&gt;wait&lt;/code&gt; 하고 작업 제어가 사용 가능 하면 작업 상태가 변경 될 때 &lt;code&gt;wait&lt;/code&gt; 가 리턴됩니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="fbfddd034699ddbb19853b5cffd539e5eaa98dc8" translate="yes" xml:space="preserve">
          <source>When the shell reads input, it proceeds through a sequence of operations. If the input indicates the beginning of a comment, the shell ignores the comment symbol (&amp;lsquo;</source>
          <target state="translated">쉘이 입력을 읽을 때 일련의 작업을 진행합니다. 입력이 주석의 시작을 나타내는 경우 쉘은 주석 기호 ( '</target>
        </trans-unit>
        <trans-unit id="ef506d9dc11fa9109da8ad65cf883d89c9449053" translate="yes" xml:space="preserve">
          <source>When the shell starts up, the history is initialized from the file named by the &lt;code&gt;HISTFILE&lt;/code&gt; variable (default</source>
          <target state="translated">쉘이 시작될 때 히스토리는 &lt;code&gt;HISTFILE&lt;/code&gt; 변수에 의해 명명 된 파일에서 초기화됩니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="77a6e1e727c8b8d46a90e5211c2564f5b4e07e74" translate="yes" xml:space="preserve">
          <source>When the variable is assigned a value, all lower-case characters are converted to upper-case. The lower-case attribute is disabled.</source>
          <target state="translated">변수에 값이 지정되면 모든 소문자가 대문자로 변환됩니다. 소문자 속성이 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b92815e90e22bfc43ea3604f269b538b0461773" translate="yes" xml:space="preserve">
          <source>When the variable is assigned a value, all upper-case characters are converted to lower-case. The upper-case attribute is disabled.</source>
          <target state="translated">변수에 값이 지정되면 모든 대문자가 소문자로 변환됩니다. 대문자 속성이 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c63a351bbb0b692e0a20f094808827f822d8d96" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;[[&lt;/code&gt;, the &amp;lsquo;</source>
          <target state="translated">함께 사용되는 경우 &lt;code&gt;[[&lt;/code&gt; 상기 '</target>
        </trans-unit>
        <trans-unit id="ea37a64e15d28ed7a20c1b6d5cdabe5ba6012c12" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;test&lt;/code&gt; or &amp;lsquo;</source>
          <target state="translated">함께 사용하면 &lt;code&gt;test&lt;/code&gt; '또는</target>
        </trans-unit>
        <trans-unit id="f7ee732871c7b8b43fe2973d514b7807acd539cd" translate="yes" xml:space="preserve">
          <source>When using</source>
          <target state="translated">사용할 때</target>
        </trans-unit>
        <trans-unit id="c61dcfadd37db50e68e58cb8326397e6ca93fc37" translate="yes" xml:space="preserve">
          <source>When using a variable name with a subscript as an argument to a command, such as with &lt;code&gt;unset&lt;/code&gt;, without using the word expansion syntax described above, the argument is subject to the shell&amp;rsquo;s filename expansion. If filename expansion is not desired, the argument should be quoted.</source>
          <target state="translated">위에 설명 된 단어 확장 구문을 사용하지 않고 &lt;code&gt;unset&lt;/code&gt; 과 같은 명령에 대한 인수로 아래 첨자를 갖는 변수 이름을 사용하는 경우 인수는 셸의 파일 이름 확장을 따릅니다. 파일 이름 확장을 원하지 않으면 인수를 인용해야합니다.</target>
        </trans-unit>
        <trans-unit id="81da930d4106f4d1e85e5be34715b2306e8ddcdf" translate="yes" xml:space="preserve">
          <source>When using the second form, &lt;var&gt;word&lt;/var&gt; may not expand to a number or &amp;lsquo;</source>
          <target state="translated">두 번째 양식을 사용할 때 &lt;var&gt;word&lt;/var&gt; 가 숫자 나 '</target>
        </trans-unit>
        <trans-unit id="668069609747d6c224ed20a0f608411c874e3e6a" translate="yes" xml:space="preserve">
          <source>When using the shell, only &amp;lsquo;</source>
          <target state="translated">쉘을 사용할 때 '</target>
        </trans-unit>
        <trans-unit id="56abe9ecf09f2b7691653e7729606d38408ddd54" translate="yes" xml:space="preserve">
          <source>When word completion is attempted for an argument to a command for which a completion specification (a &lt;var&gt;compspec&lt;/var&gt;) has been defined using the &lt;code&gt;complete&lt;/code&gt; builtin (see &lt;a href=&quot;programmable-completion-builtins#Programmable-Completion-Builtins&quot;&gt;Programmable Completion Builtins&lt;/a&gt;), the programmable completion facilities are invoked.</source>
          <target state="translated">완료 스펙을 사용하여 완료 스펙 ( &lt;var&gt;compspec&lt;/var&gt; )이 정의 된 명령에 대한 인수에 대해 단어 완료가 시도 &lt;code&gt;complete&lt;/code&gt; ( &lt;a href=&quot;programmable-completion-builtins#Programmable-Completion-Builtins&quot;&gt;프로그램 가능 완료 내장&lt;/a&gt; 참조 ) 프로그램 가능 완료 기능이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="38e6cf49bb0a8ee6e58a3e620a573fc3ad9d522f" translate="yes" xml:space="preserve">
          <source>When you add text in the middle of a line, you will notice that characters to the right of the cursor are &amp;lsquo;pushed over&amp;rsquo; to make room for the text that you have inserted. Likewise, when you delete text behind the cursor, characters to the right of the cursor are &amp;lsquo;pulled back&amp;rsquo; to fill in the blank space created by the removal of the text. A list of the bare essentials for editing the text of an input line follows.</source>
          <target state="translated">줄 중간에 텍스트를 추가하면 커서 오른쪽에있는 문자가 '밀어 져'삽입 된 텍스트를위한 공간이 만들어집니다. 마찬가지로 커서 뒤의 텍스트를 삭제하면 커서 오른쪽에있는 문자가 '뒤로 밀려'텍스트를 제거하여 생성 된 빈 공간을 채 웁니다. 입력 줄의 텍스트를 편집하는 데 필요한 기본 사항 목록이 이어집니다.</target>
        </trans-unit>
        <trans-unit id="cec74b15fc6bfefba022a119fb96c3cec23af155" translate="yes" xml:space="preserve">
          <source>When you enter a line in &lt;code&gt;vi&lt;/code&gt; mode, you are already placed in &amp;lsquo;insertion&amp;rsquo; mode, as if you had typed an &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;vi&lt;/code&gt; 모드 에서 라인을 입력하면 '삽입'모드에 이미 '</target>
        </trans-unit>
        <trans-unit id="39bab91fb8c5856e90231b9523fc1c7ec513fdd3" translate="yes" xml:space="preserve">
          <source>When you use a kill command, the text is saved in a &lt;em&gt;kill-ring&lt;/em&gt;. Any number of consecutive kills save all of the killed text together, so that when you yank it back, you get it all. The kill ring is not line specific; the text that you killed on a previously typed line is available to be yanked back later, when you are typing another line.</source>
          <target state="translated">kill 명령을 사용하면 텍스트가 &lt;em&gt;kill-ring에&lt;/em&gt; 저장됩니다 . 연속으로 여러 번 죽이면 죽여 진 텍스트를 모두 함께 저장하므로 다시 잡아 당길 때 모든 텍스트를 얻을 수 있습니다. 킬 링은 특정 라인이 아닙니다. 이전에 입력 한 줄에서 죽인 텍스트는 다른 줄을 입력 할 때 나중에 다시 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="255774c5e880fecd728cc58e02263e9d32d2416a" translate="yes" xml:space="preserve">
          <source>While executing commands is essential, most of the power (and complexity) of shells is due to their embedded programming languages. Like any high-level language, the shell provides variables, flow control constructs, quoting, and functions.</source>
          <target state="translated">명령을 실행하는 것이 필수적이지만 쉘의 강력한 기능 (및 복잡성)은 내장 된 프로그래밍 언어로 인한 것입니다. 다른 고급 언어와 마찬가지로 쉘은 변수, 흐름 제어 구문, 인용 및 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9180ec4d813a7436e99939ed2d81f4dcd696a248" translate="yes" xml:space="preserve">
          <source>While the &lt;small&gt;GNU&lt;/small&gt; operating system provides other shells, including a version of &lt;code&gt;csh&lt;/code&gt;, Bash is the default shell. Like other &lt;small&gt;GNU&lt;/small&gt; software, Bash is quite portable. It currently runs on nearly every version of Unix and a few other operating systems - independently-supported ports exist for &lt;small&gt;MS-DOS&lt;/small&gt;, &lt;small&gt;OS/2&lt;/small&gt;, and Windows platforms.</source>
          <target state="translated">&lt;small&gt;GNU&lt;/small&gt; 운영 체제는 &lt;code&gt;csh&lt;/code&gt; 버전을 포함한 다른 쉘을 제공 하지만 Bash는 기본 쉘입니다. 다른 &lt;small&gt;GNU&lt;/small&gt; 소프트웨어 와 마찬가지로 Bash는 이식성이 뛰어납니다. 현재 거의 모든 버전의 Unix와 몇 가지 다른 운영 체제에서 실행되며 &lt;small&gt;MS-DOS&lt;/small&gt; , &lt;small&gt;OS / 2&lt;/small&gt; 및 Windows 플랫폼에 대해 독립적으로 지원되는 포트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d296b77a725bd6de00e8492f649e38826354e5c" translate="yes" xml:space="preserve">
          <source>While the Readline library does not have a full set of &lt;code&gt;vi&lt;/code&gt; editing functions, it does contain enough to allow simple editing of the line. The Readline &lt;code&gt;vi&lt;/code&gt; mode behaves as specified in the &lt;small&gt;POSIX&lt;/small&gt; standard.</source>
          <target state="translated">Readline 라이브러리에는 전체 &lt;code&gt;vi&lt;/code&gt; 편집 기능 세트가 없지만 간단한 행 편집을 허용하기에 충분합니다. Readline &lt;code&gt;vi&lt;/code&gt; 모드는 &lt;small&gt;POSIX&lt;/small&gt; 표준에 지정된대로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="9612b10a6e0a4d6d0c625743851547327018b8f1" translate="yes" xml:space="preserve">
          <source>While variable indirection is available, it may not be applied to the &amp;lsquo;</source>
          <target state="translated">변수 간접 지정을 사용할 수 있지만 '</target>
        </trans-unit>
        <trans-unit id="b19351b493bff1c5e2ef8080582e54b0ee55dac4" translate="yes" xml:space="preserve">
          <source>With no options, display the history list with line numbers. Lines prefixed with a &amp;lsquo;</source>
          <target state="translated">옵션이 없으면 행 번호와 함께 히스토리 목록을 표시하십시오. 접두사 '</target>
        </trans-unit>
        <trans-unit id="55ad82d118f5a65694a7b6a3104ba8e1f5d0dc63" translate="yes" xml:space="preserve">
          <source>Within &amp;lsquo;</source>
          <target state="translated">내</target>
        </trans-unit>
        <trans-unit id="655cc82cd533f06957e505ed15d00ab247320e6c" translate="yes" xml:space="preserve">
          <source>Without &lt;var&gt;expr&lt;/var&gt;, &lt;code&gt;caller&lt;/code&gt; displays the line number and source filename of the current subroutine call. If a non-negative integer is supplied as &lt;var&gt;expr&lt;/var&gt;, &lt;code&gt;caller&lt;/code&gt; displays the line number, subroutine name, and source file corresponding to that position in the current execution call stack. This extra information may be used, for example, to print a stack trace. The current frame is frame 0.</source>
          <target state="translated">없이 &lt;var&gt;expr&lt;/var&gt; , &lt;code&gt;caller&lt;/code&gt; 현재 서브 루틴 호출의 행 번호와 소스 파일 이름을 표시합니다. 음수가 아닌 정수가 &lt;var&gt;expr&lt;/var&gt; 로 제공 되면 &lt;code&gt;caller&lt;/code&gt; 는 현재 실행 호출 스택에서 해당 위치에 해당하는 행 번호, 서브 루틴 이름 및 소스 파일을 표시합니다. 이 추가 정보는 예를 들어 스택 추적을 인쇄하는 데 사용될 수 있습니다. 현재 프레임은 프레임 0입니다.</target>
        </trans-unit>
        <trans-unit id="f3bccb568d2083ce3cc3fd5d484aeb7a4fa665e1" translate="yes" xml:space="preserve">
          <source>Without a numeric argument, the value of the &lt;code&gt;comment-begin&lt;/code&gt; variable is inserted at the beginning of the current line. If a numeric argument is supplied, this command acts as a toggle: if the characters at the beginning of the line do not match the value of &lt;code&gt;comment-begin&lt;/code&gt;, the value is inserted, otherwise the characters in &lt;code&gt;comment-begin&lt;/code&gt; are deleted from the beginning of the line. In either case, the line is accepted as if a newline had been typed. The default value of &lt;code&gt;comment-begin&lt;/code&gt; causes this command to make the current line a shell comment. If a numeric argument causes the comment character to be removed, the line will be executed by the shell.</source>
          <target state="translated">숫자 인수가 없으면 &lt;code&gt;comment-begin&lt;/code&gt; 변수 의 값 이 현재 행의 시작 부분에 삽입됩니다. 숫자 인수가 제공되면이 명령은 토글 역할을합니다. 줄의 시작 부분에있는 문자가 &lt;code&gt;comment-begin&lt;/code&gt; 값과 일치하지 않으면 값이 삽입되고, 그렇지 않으면 &lt;code&gt;comment-begin&lt;/code&gt; 에있는 문자 가 처음부터 삭제됩니다 라인의. 두 경우 모두 줄 바꿈이 입력 된 것처럼 줄이 수락됩니다. &lt;code&gt;comment-begin&lt;/code&gt; 의 기본값 은이 명령으로 현재 행을 쉘 주석으로 만듭니다. 숫자 인수가 주석 문자를 제거하면 쉘이 행을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="653ebf73bebeedbc12797f58a606efdf49f60d81" translate="yes" xml:space="preserve">
          <source>Without arguments or with the</source>
          <target state="translated">인수없이 또는</target>
        </trans-unit>
        <trans-unit id="96926cabf14560d2972e553541566c921210f5d0" translate="yes" xml:space="preserve">
          <source>Without options, remove each &lt;var&gt;jobspec&lt;/var&gt; from the table of active jobs. If the</source>
          <target state="translated">옵션이 없으면 활성 작업 테이블에서 각 &lt;var&gt;jobspec&lt;/var&gt; 을 제거하십시오 . 만약</target>
        </trans-unit>
        <trans-unit id="c759d7dc3468dfe86f9cbaed5a1c36016677768d" translate="yes" xml:space="preserve">
          <source>Word Designators</source>
          <target state="translated">단어 지정자</target>
        </trans-unit>
        <trans-unit id="1a1b902933d8ac04cec7026f7cceaa9d893a7476" translate="yes" xml:space="preserve">
          <source>Word Splitting</source>
          <target state="translated">단어 분리</target>
        </trans-unit>
        <trans-unit id="f2778c7e426e39bc29879fdf4ac05b63428e4861" translate="yes" xml:space="preserve">
          <source>Word designators are used to select desired words from the event. A &amp;lsquo;</source>
          <target state="translated">단어 지정자는 이벤트에서 원하는 단어를 선택하는 데 사용됩니다. ㅏ '</target>
        </trans-unit>
        <trans-unit id="848f48edf34a4bd78eb9d02f18c5a46103ddc968" translate="yes" xml:space="preserve">
          <source>Words of the form &lt;code&gt;$'&lt;var&gt;string&lt;/var&gt;'&lt;/code&gt; are treated specially. The word expands to &lt;var&gt;string&lt;/var&gt;, with backslash-escaped characters replaced as specified by the ANSI C standard. Backslash escape sequences, if present, are decoded as follows:</source>
          <target state="translated">&lt;code&gt;$'&lt;var&gt;string&lt;/var&gt;'&lt;/code&gt; 형식의 단어는 특별히 취급됩니다. ANSI C 표준에 지정된대로 백 슬래시 이스케이프 문자가 바뀐 상태로 단어가 &lt;var&gt;string&lt;/var&gt; 으로 확장됩니다 . 백 슬래시 이스케이프 시퀀스가있는 경우 다음과 같이 디코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="84c51356b071f1d521a4f1f299fba8c8301acb7a" translate="yes" xml:space="preserve">
          <source>Write out the current history list to the history file.</source>
          <target state="translated">현재 히스토리 목록을 히스토리 파일에 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="9842f6fa4c1dbb866338c2ef7fc96fca552c238e" translate="yes" xml:space="preserve">
          <source>Write the formatted &lt;var&gt;arguments&lt;/var&gt; to the standard output under the control of the &lt;var&gt;format&lt;/var&gt;. The</source>
          <target state="translated">&lt;var&gt;format&lt;/var&gt; 제어를 통해 형식화 된 &lt;var&gt;arguments&lt;/var&gt; 를 표준 출력에 기록하십시오 . 그만큼</target>
        </trans-unit>
        <trans-unit id="f0ce36eaf7d15e3950e3e94f7e814a43c3aff0ef" translate="yes" xml:space="preserve">
          <source>XCF</source>
          <target state="translated">XCF</target>
        </trans-unit>
        <trans-unit id="c0aa9ef764d832b80428d756a731a94251b0e3a1" translate="yes" xml:space="preserve">
          <source>XML</source>
          <target state="translated">XML</target>
        </trans-unit>
        <trans-unit id="23eb4d3f4155395a74e9d534f97ff4c1908f5aac" translate="yes" xml:space="preserve">
          <source>Y</source>
          <target state="translated">Y</target>
        </trans-unit>
        <trans-unit id="c6522577101d4c974000a04d4aa197b0b181fc24" translate="yes" xml:space="preserve">
          <source>Yank the most recently killed text back into the buffer at the cursor.</source>
          <target state="translated">가장 최근에 죽인 텍스트를 커서의 버퍼로 다시 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="677dc7bd7602fa2437c898d54e1ab14378d52ff9" translate="yes" xml:space="preserve">
          <source>Yank the top of the kill ring into the buffer at point.</source>
          <target state="translated">킬링 (Kill) 링의 상단을 버퍼에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="25c737fe9782668677465bb13c81366f7005ee3e" translate="yes" xml:space="preserve">
          <source>You can compile Bash for more than one kind of computer at the same time, by placing the object files for each architecture in their own directory. To do this, you must use a version of &lt;code&gt;make&lt;/code&gt; that supports the &lt;code&gt;VPATH&lt;/code&gt; variable, such as GNU &lt;code&gt;make&lt;/code&gt;. &lt;code&gt;cd&lt;/code&gt; to the directory where you want the object files and executables to go and run the &lt;code&gt;configure&lt;/code&gt; script from the source directory (see &lt;a href=&quot;basic-installation#Basic-Installation&quot;&gt;Basic Installation&lt;/a&gt;). You may need to supply the</source>
          <target state="translated">각 아키텍처에 대한 오브젝트 파일을 자체 디렉토리에 배치하여 둘 이상의 컴퓨터에 대해 Bash를 동시에 컴파일 할 수 있습니다. 이렇게하려면 GNU &lt;code&gt;make&lt;/code&gt; 와 같은 &lt;code&gt;VPATH&lt;/code&gt; 변수 를 지원하는 &lt;code&gt;make&lt;/code&gt; 버전을 사용해야합니다 . 오브젝트 파일 및 실행 파일을 이동하려는 디렉토리로 &lt;code&gt;cd&lt;/code&gt; 하고 소스 디렉토리에서 &lt;code&gt;configure&lt;/code&gt; 스크립트를 실행 하십시오 ( &lt;a href=&quot;basic-installation#Basic-Installation&quot;&gt;기본 설치&lt;/a&gt; 참조 ). 당신은 공급해야 할 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="966292c34949d5d341081c06091f7aeabaaf5055" translate="yes" xml:space="preserve">
          <source>You can modify the run-time behavior of Readline by altering the values of variables in Readline using the &lt;code&gt;set&lt;/code&gt; command within the init file. The syntax is simple:</source>
          <target state="translated">init 파일 내의 &lt;code&gt;set&lt;/code&gt; 명령을 사용하여 Readline의 변수 값을 변경하여 Readline의 런타임 동작을 수정할 수 있습니다 . 구문은 간단합니다.</target>
        </trans-unit>
        <trans-unit id="fa7bf613e3295ed9f0a8fb5ca0672b3c5eab07e1" translate="yes" xml:space="preserve">
          <source>You can pass numeric arguments to Readline commands. Sometimes the argument acts as a repeat count, other times it is the</source>
          <target state="translated">숫자 인수를 Readline 명령에 전달할 수 있습니다. 때로는 인수가 반복 횟수로 작동하고 다른 경우에는</target>
        </trans-unit>
        <trans-unit id="5be9cf180a0c9b7e18ecc3038ece719ad6ce745a" translate="yes" xml:space="preserve">
          <source>You can remove the program binaries and object files from the source code directory by typing &amp;lsquo;</source>
          <target state="translated">'를 입력하여 소스 코드 디렉토리에서 프로그램 바이너리 및 오브젝트 파일을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8809b83e96c416d37503bf077e1953492b50d356" translate="yes" xml:space="preserve">
          <source>You can specify separate installation prefixes for architecture-specific files and architecture-independent files. If you give &lt;code&gt;configure&lt;/code&gt; the option</source>
          <target state="translated">아키텍처 별 파일과 아키텍처 독립적 인 파일에 대해 별도의 설치 접두사를 지정할 수 있습니다. 당신은주는 경우에 &lt;code&gt;configure&lt;/code&gt; 옵션을</target>
        </trans-unit>
        <trans-unit id="3d549afa7c81de4bec2647a208873a198d6763c6" translate="yes" xml:space="preserve">
          <source>You can use Parallel to move files from the current directory when the number of files is too large to process with one &lt;code&gt;mv&lt;/code&gt; invocation:</source>
          <target state="translated">파일 수가 너무 많아서 하나의 &lt;code&gt;mv&lt;/code&gt; 호출 로 처리 할 수없는 경우 병렬을 사용하여 현재 디렉토리에서 파일을 이동할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ff1274999d5897a967880e9602c53686869c7832" translate="yes" xml:space="preserve">
          <source>You may add a passage of up to five words as a Front-Cover Text, and a passage of up to 25 words as a Back-Cover Text, to the end of the list of Cover Texts in the Modified Version. Only one passage of Front-Cover Text and one of Back-Cover Text may be added by (or through arrangements made by) any one entity. If the Document already includes a cover text for the same cover, previously added by you or by arrangement made by the same entity you are acting on behalf of, you may not add another; but you may replace the old one, on explicit permission from the previous publisher that added the old one.</source>
          <target state="translated">수정 된 버전의 표지 텍스트 목록 끝에 최대 5 개의 단어를 앞 표지 텍스트로, 최대 25 개의 단어를 뒤 표지 텍스트로 추가 할 수 있습니다. 하나의 엔터티에 의해 하나의 프론트 커버 텍스트와 하나의 백 커버 텍스트 만 추가 될 수 있습니다. 문서에 이미 귀하가 추가 한 동일한 표지에 대한 표지 텍스트가 포함되어 있거나 귀하를 대리하고있는 동일한 단체에 의해 작성된 약정이 포함 된 경우 귀하는 다른 표지를 추가 할 수 없습니다. 그러나 이전 게시자를 추가 한 이전 게시자의 명시 적 허가에 따라 이전 것을 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e661e3a96416898648db44bb6ce0eb56887ee1c9" translate="yes" xml:space="preserve">
          <source>You may add a section Entitled &amp;ldquo;Endorsements&amp;rdquo;, provided it contains nothing but endorsements of your Modified Version by various parties&amp;mdash;for example, statements of peer review or that the text has been approved by an organization as the authoritative definition of a standard.</source>
          <target state="translated">피어 리뷰 진술서 또는 텍스트가 표준에 대한 권위있는 정의로 텍스트에 의해 승인 된 것과 같이 다양한 당사자에 의해 수정 된 버전에 대한 보증이 포함 된 경우에는 &quot;승인&quot;이라는 제목의 섹션을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="282bb9dfed04c9fa638e3ac9a73c1f5ecd474d79" translate="yes" xml:space="preserve">
          <source>You may also lend copies, under the same conditions stated above, and you may publicly display copies.</source>
          <target state="translated">위에서 언급 한 것과 동일한 조건에서 사본을 빌려줄 수도 있으며 공개적으로 사본을 표시 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c6f537b19345a1f28e1581319a0a7d12ff3a575" translate="yes" xml:space="preserve">
          <source>You may combine the Document with other documents released under this License, under the terms defined in section 4 above for modified versions, provided that you include in the combination all of the Invariant Sections of all of the original documents, unmodified, and list them all as Invariant Sections of your combined work in its license notice, and that you preserve all their Warranty Disclaimers.</source>
          <target state="translated">귀하는 원본 문서의 모든 고정 섹션을 수정하지 않은 상태로 모두 포함하고 수정하지 않은 경우, 본 버전에 따라이 라이센스에 따라 릴리스 된 다른 문서와 수정 버전에 대해 위의 섹션 4에 정의 된 조건에 따라 문서를 결합 할 수 있습니다. 사용권 계약에 결합 된 작업의 고정 섹션으로 사용되며 모든 보증 면책 사항을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="412203d0de70d3e44d37e7ecda18aa73505e5c31" translate="yes" xml:space="preserve">
          <source>You may copy and distribute a Modified Version of the Document under the conditions of sections 2 and 3 above, provided that you release the Modified Version under precisely this License, with the Modified Version filling the role of the Document, thus licensing distribution and modification of the Modified Version to whoever possesses a copy of it. In addition, you must do these things in the Modified Version:</source>
          <target state="translated">귀하는이 라이센스에 따라 수정 된 버전을 문서의 역할로 채우고 수정 된 버전을 문서의 역할로 채우는 경우 위의 2 및 3 조의 조건에 따라 수정 된 버전의 문서를 복사 및 배포 할 수 있습니다. 사본을 소유 한 사람에게 수정 된 버전. 또한 수정 된 버전에서 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="d30168039ed590d15bcce8ea918cbf6e6bb07cae" translate="yes" xml:space="preserve">
          <source>You may copy and distribute the Document in any medium, either commercially or noncommercially, provided that this License, the copyright notices, and the license notice saying this License applies to the Document are reproduced in all copies, and that you add no other conditions whatsoever to those of this License. You may not use technical measures to obstruct or control the reading or further copying of the copies you make or distribute. However, you may accept compensation in exchange for copies. If you distribute a large enough number of copies you must also follow the conditions in section 3.</source>
          <target state="translated">이 라이센스, 저작권 고지 및이 라이센스가 해당 문서에 적용된다는 라이센스 고지가 모든 사본으로 재생산되고 다른 조건을 추가하지 않는 한, 상업적 또는 비영리적으로 어떤 매체로도 문서를 복사하고 배포 할 수 있습니다. 이 라이센스의 사람들에게. 귀하는 귀하가 작성 또는 배포 한 사본의 읽기 또는 추가 복사를 방해하거나 통제하기 위해 기술적 조치를 사용할 수 없습니다. 그러나 사본과 교환하여 보상을받을 수 있습니다. 충분한 수의 사본을 배포하는 경우 섹션 3의 조건도 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="56e62f961ec3ed13a2f798469affbc27b69bd976" translate="yes" xml:space="preserve">
          <source>You may extract a single document from such a collection, and distribute it individually under this License, provided you insert a copy of this License into the extracted document, and follow this License in all other respects regarding verbatim copying of that document.</source>
          <target state="translated">추출 된 문서에이 라이센스의 사본을 삽입하고 해당 문서의 완전 복사와 관련하여 다른 모든 측면에서이 라이센스를 따르는 경우, 해당 콜렉션에서 단일 문서를 추출하여이 라이센스에 따라 개별적으로 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e8e1827e6f8675e9dd0669377a6e4bd993e83f2" translate="yes" xml:space="preserve">
          <source>You may make a collection consisting of the Document and other documents released under this License, and replace the individual copies of this License in the various documents with a single copy that is included in the collection, provided that you follow the rules of this License for verbatim copying of each of the documents in all other respects.</source>
          <target state="translated">귀하는 본 라이센스에 따라이 라이센스의 규칙을 준수하는 경우,이 라이센스에 따라 공개 된 문서 및 기타 문서로 구성된 콜렉션을 작성하고이 라이센스의 개별 사본을 콜렉션에 포함 된 단일 사본으로 대체 할 수 있습니다. 다른 모든 측면에서 각 문서의 완전 복사.</target>
        </trans-unit>
        <trans-unit id="51d02e802fce41287d4c0388192a7d2945190088" translate="yes" xml:space="preserve">
          <source>You may not copy, modify, sublicense, or distribute the Document except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense, or distribute it is void, and will automatically terminate your rights under this License.</source>
          <target state="translated">이 라이센스에 따라 명시 적으로 제공된 경우를 제외하고 문서를 복사, 수정, 하위 라이센스 또는 배포 할 수 없습니다. 달리 복사, 수정, 하위 라이센스 또는 배포하려는 시도는 무효이며이 라이센스에 따른 귀하의 권리는 자동으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="d224d8bd579e022a3152adc3ac6ec5ffac7b3367" translate="yes" xml:space="preserve">
          <source>[ ]*</source>
          <target state="translated">[ ]*</target>
        </trans-unit>
        <trans-unit id="edd74dd5fd077a5baf2dd832b6fcd2516c38db54" translate="yes" xml:space="preserve">
          <source>[a-dx-z]</source>
          <target state="translated">[a-dx-z]</target>
        </trans-unit>
        <trans-unit id="e9f16a01f274397b0c8315286f1929d05b06c0ef" translate="yes" xml:space="preserve">
          <source>[aBbCcDdxXyYz]</source>
          <target state="translated">[aBbCcDdxXyYz]</target>
        </trans-unit>
        <trans-unit id="fadabc351d4f25299435d015d6cfd06136703b5e" translate="yes" xml:space="preserve">
          <source>[abcdxyz]</source>
          <target state="translated">[abcdxyz]</target>
        </trans-unit>
        <trans-unit id="41899536e2ac4b7391727782d5a1adbdf3f35125" translate="yes" xml:space="preserve">
          <source>[n]&amp;gt;&amp;amp;&lt;var&gt;word&lt;/var&gt;</source>
          <target state="translated">[n]&amp;gt;&amp;amp;&lt;var&gt;word&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="780fa0ff9e751654e40fe8a1a68d0f2a62d159e8" translate="yes" xml:space="preserve">
          <source>[n]&amp;lt;&amp;amp;&lt;var&gt;word&lt;/var&gt;</source>
          <target state="translated">[n]&amp;lt;&amp;amp;&lt;var&gt;word&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="08534f33c201a45017b502e90a800f1b708ebcb3" translate="yes" xml:space="preserve">
          <source>\</source>
          <target state="translated">\</target>
        </trans-unit>
        <trans-unit id="2de673b7fa2e0a0e52326460a59d3f726ea66d02" translate="yes" xml:space="preserve">
          <source>\1</source>
          <target state="translated">\1</target>
        </trans-unit>
        <trans-unit id="c016fb3c2d71f02e58827dbbb11225ca77cbae92" translate="yes" xml:space="preserve">
          <source>\2</source>
          <target state="translated">\2</target>
        </trans-unit>
        <trans-unit id="d2e4c64b58fc62c43b5d838f83539aed0c4da1a8" translate="yes" xml:space="preserve">
          <source>\s-\v\$</source>
          <target state="translated">\s-\v\$</target>
        </trans-unit>
        <trans-unit id="5bc50612646fc47ce021d3fa7fba6af78c0a8cca" translate="yes" xml:space="preserve">
          <source>^Y</source>
          <target state="translated">^Y</target>
        </trans-unit>
        <trans-unit id="702bf963d5f4436227c3776678b3e175902e762a" translate="yes" xml:space="preserve">
          <source>^Z</source>
          <target state="translated">^Z</target>
        </trans-unit>
        <trans-unit id="7e15bb5c01e7dd56499e37c634cf791d3a519aee" translate="yes" xml:space="preserve">
          <source>`</source>
          <target state="translated">`</target>
        </trans-unit>
        <trans-unit id="86f7e437faa5a7fce15d1ddcb9eaeaea377667b8" translate="yes" xml:space="preserve">
          <source>a</source>
          <target state="translated">a</target>
        </trans-unit>
        <trans-unit id="90c73bacbd21841707ae60d5bcc1160e5dc4e4c3" translate="yes" xml:space="preserve">
          <source>a control-&lt;var&gt;x&lt;/var&gt; character</source>
          <target state="translated">제어 &lt;var&gt;x&lt;/var&gt; 문자</target>
        </trans-unit>
        <trans-unit id="d536b1baf37bf343aa892b44bcab569176c3a795" translate="yes" xml:space="preserve">
          <source>aaaaaab</source>
          <target state="translated">aaaaaab</target>
        </trans-unit>
        <trans-unit id="40b904fd8852297daeaeb426b1bca46fd2454aa3" translate="yes" xml:space="preserve">
          <source>aab</source>
          <target state="translated">aab</target>
        </trans-unit>
        <trans-unit id="9118866496dfbc2e597505390a41e74349ab5152" translate="yes" xml:space="preserve">
          <source>addition, subtraction</source>
          <target state="translated">더하기, 빼기</target>
        </trans-unit>
        <trans-unit id="07f3659ec271eee920b5269f5364d0ab8433728c" translate="yes" xml:space="preserve">
          <source>after (or before) any login-specific initializations.</source>
          <target state="translated">로그인 별 초기화 후 (또는 이전)</target>
        </trans-unit>
        <trans-unit id="f50433605f8f400a57a74b70284fb69b0627cf01" translate="yes" xml:space="preserve">
          <source>alert (bell)</source>
          <target state="translated">경고 (종)</target>
        </trans-unit>
        <trans-unit id="cdb6fdbe91faa53a7c573c80b7c18108c73c0480" translate="yes" xml:space="preserve">
          <source>alias</source>
          <target state="translated">alias</target>
        </trans-unit>
        <trans-unit id="c81ac90ad154e582701af8147aa7541b041f5a84" translate="yes" xml:space="preserve">
          <source>alias expansion</source>
          <target state="translated">별칭 확장</target>
        </trans-unit>
        <trans-unit id="7208b011d04e4840597133487f3e0cdb3e7339a6" translate="yes" xml:space="preserve">
          <source>an escape character</source>
          <target state="translated">탈출 캐릭터</target>
        </trans-unit>
        <trans-unit id="e12e6046a92734bfd31cc6d381fc395fb569cedf" translate="yes" xml:space="preserve">
          <source>an escape character (not ANSI C)</source>
          <target state="translated">이스케이프 문자 (ANSI C 아님)</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="f9585e116f42fc80bfcc117654868617655b8df3" translate="yes" xml:space="preserve">
          <source>and its successor,</source>
          <target state="translated">그리고 그 후계자</target>
        </trans-unit>
        <trans-unit id="fee01b359832af6797c78f83ce4d97efd54f80c3" translate="yes" xml:space="preserve">
          <source>and the compound assignment syntax to create array variables, additional attributes do not take effect until subsequent assignments.</source>
          <target state="translated">배열 변수를 작성하기위한 복합 지정 구문을 사용하면 추가 지정이 후속 지정까지 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="68d82c662f6eac816c0e3353d7ed4a723e965282" translate="yes" xml:space="preserve">
          <source>and the current working directory cannot be successfully determined after a successful directory change, &lt;code&gt;cd&lt;/code&gt; will return an unsuccessful status.</source>
          <target state="translated">디렉토리 변경에 성공한 후 현재 작업 디렉토리를 판별 할 수 없으면 &lt;code&gt;cd&lt;/code&gt; 는 실패한 상태를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d69b217d0e88de30853dbce706c9849430de03f5" translate="yes" xml:space="preserve">
          <source>and/or processing tools are not generally available, and the machine-generated</source>
          <target state="translated">및 / 또는 가공 도구는 일반적으로 이용 가능하지 않으며, 기계 생성</target>
        </trans-unit>
        <trans-unit id="1268a4c533db781c38527c7c5f444ef72884fba8" translate="yes" xml:space="preserve">
          <source>are always ignored when &lt;code&gt;GLOBIGNORE&lt;/code&gt; is set and not null. However, setting &lt;code&gt;GLOBIGNORE&lt;/code&gt; to a non-null value has the effect of enabling the &lt;code&gt;dotglob&lt;/code&gt; shell option, so all other filenames beginning with a &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;GLOBIGNORE&lt;/code&gt; 가 설정되고 null이 아닌 경우 항상 무시됩니다 . 그러나 &lt;code&gt;GLOBIGNORE&lt;/code&gt; 를 널이 아닌 값으로 설정하면 &lt;code&gt;dotglob&lt;/code&gt; 쉘 옵션을 사용 하는 효과가 있으므로 다른 모든 파일 이름은 '</target>
        </trans-unit>
        <trans-unit id="4e268dbb80edc51c8246863d7e7bac755c465aec" translate="yes" xml:space="preserve">
          <source>are supplied, any other &lt;var&gt;name&lt;/var&gt; arguments are ignored; these completions only apply to the case specified by the option.</source>
          <target state="translated">다른 &lt;var&gt;name&lt;/var&gt; 인수는 무시됩니다. 이러한 완료는 옵션으로 지정된 경우에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="aa3ecd9e4f4771afd3546fe76a43487532ad61af" translate="yes" xml:space="preserve">
          <source>argument to tell &lt;code&gt;configure&lt;/code&gt; where the source files are. &lt;code&gt;configure&lt;/code&gt; automatically checks for the source code in the directory that &lt;code&gt;configure&lt;/code&gt; is in and in &amp;lsquo;..&amp;rsquo;.</source>
          <target state="translated">인수는 말할 &lt;code&gt;configure&lt;/code&gt; 소스 파일은 다음과 같습니다. &lt;code&gt;configure&lt;/code&gt; 는 &lt;code&gt;configure&lt;/code&gt; 가 있는 디렉토리 와 '..' 에있는 소스 코드를 자동으로 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="6c684d3782e2decbf824cf0a5a0eacdf61c00566" translate="yes" xml:space="preserve">
          <source>arithmetic evaluation</source>
          <target state="translated">산술 평가</target>
        </trans-unit>
        <trans-unit id="7c7839f4094eb3f2bf8846547e825bee4d667fbf" translate="yes" xml:space="preserve">
          <source>arithmetic expansion</source>
          <target state="translated">산술 확장</target>
        </trans-unit>
        <trans-unit id="7afe4fda2816bf2d3746dfe1513abfccf9d8c133" translate="yes" xml:space="preserve">
          <source>arithmetic, shell</source>
          <target state="translated">산술, 쉘</target>
        </trans-unit>
        <trans-unit id="fcc9016d1aa6a646348df69e14d31e955d51da60" translate="yes" xml:space="preserve">
          <source>arrays</source>
          <target state="translated">arrays</target>
        </trans-unit>
        <trans-unit id="e43188efd03e628b87dcc57a46a0003265638044" translate="yes" xml:space="preserve">
          <source>as alluded to above.</source>
          <target state="translated">위에서 언급 한 바와 같이.</target>
        </trans-unit>
        <trans-unit id="ce69e0a4b543276e16b7547ba7f8363b2db902c8" translate="yes" xml:space="preserve">
          <source>as appropriate. This will search backward or forward in the history for the next entry matching the search string typed so far. Any other key sequence bound to a Readline command will terminate the search and execute that command. For instance, a &lt;code&gt;RET&lt;/code&gt; will terminate the search and accept the line, thereby executing the command from the history list. A movement command will terminate the search, make the last line found the current line, and begin editing.</source>
          <target state="translated">적절한. 그러면 지금까지 입력 한 검색 문자열과 일치하는 다음 항목이 기록에서 앞뒤로 검색됩니다. Readline 명령에 바인딩 된 다른 키 시퀀스는 검색을 종료하고 해당 명령을 실행합니다. 예를 들어, &lt;code&gt;RET&lt;/code&gt; 은 검색을 종료하고 라인을 승인하여 히스토리 목록에서 명령을 실행합니다. 이동 명령은 검색을 종료하고 마지막 줄을 현재 줄로 찾은 다음 편집을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="b697dfce9fa378f19687d2d74caa1b51c0c89796" translate="yes" xml:space="preserve">
          <source>as signifying the end of options.</source>
          <target state="translated">옵션의 끝을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f26b63d628c9b5679c54e6f8f5ee244932da2d7d" translate="yes" xml:space="preserve">
          <source>assignment</source>
          <target state="translated">assignment</target>
        </trans-unit>
        <trans-unit id="117f1628e507334ac1452a1400e6522fce67256c" translate="yes" xml:space="preserve">
          <source>at the Bash prompt in your Bash source directory.</source>
          <target state="translated">Bash 소스 디렉토리의 Bash 프롬프트에서.</target>
        </trans-unit>
        <trans-unit id="ee36e383db46fe87f1937cbbd00df8ef37bd94a1" translate="yes" xml:space="preserve">
          <source>attribute itself, are performed on the variable referenced by &lt;var&gt;name&lt;/var&gt;&amp;rsquo;s value. The nameref attribute cannot be applied to array variables.</source>
          <target state="translated">속성 자체는 &lt;var&gt;name&lt;/var&gt; 값으로 참조되는 변수에서 수행됩니다 . nameref 속성은 배열 변수에 적용 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c9072eb987d0905a72c46fd2f6e922e36e93c239" translate="yes" xml:space="preserve">
          <source>audible</source>
          <target state="translated">audible</target>
        </trans-unit>
        <trans-unit id="e9d71f5ee7c92d6dc9e92ffdad17b8bd49418f98" translate="yes" xml:space="preserve">
          <source>b</source>
          <target state="translated">b</target>
        </trans-unit>
        <trans-unit id="248a20b62efba8f4303c75830c83230f1b088f1e" translate="yes" xml:space="preserve">
          <source>background</source>
          <target state="translated">background</target>
        </trans-unit>
        <trans-unit id="3853072116a861ff4c871d3e96a9cac7da78b7d2" translate="yes" xml:space="preserve">
          <source>backslash</source>
          <target state="translated">backslash</target>
        </trans-unit>
        <trans-unit id="4930eb3f60df3a6a61e8d44178feb2b8f820a153" translate="yes" xml:space="preserve">
          <source>backspace</source>
          <target state="translated">backspace</target>
        </trans-unit>
        <trans-unit id="ab28712d143d8f15faca7745bd40669636f4c2a4" translate="yes" xml:space="preserve">
          <source>bash-malloc</source>
          <target state="translated">bash-malloc</target>
        </trans-unit>
        <trans-unit id="4e859a10308ef3e53cba4c29d868095126753fa8" translate="yes" xml:space="preserve">
          <source>because the word boundaries differ.</source>
          <target state="translated">단어의 경계가 다르기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="f415ec1d9821f06dedec21eea5790ab8d8e21305" translate="yes" xml:space="preserve">
          <source>bg %1</source>
          <target state="translated">bg % 1</target>
        </trans-unit>
        <trans-unit id="602e9530b4ae1beff22d544afefc90f5d036efa6" translate="yes" xml:space="preserve">
          <source>bind -x</source>
          <target state="translated">바인드 -x</target>
        </trans-unit>
        <trans-unit id="4ba5b46e332d373dfdfa248036598eb70f831d32" translate="yes" xml:space="preserve">
          <source>bitwise AND</source>
          <target state="translated">비트 AND</target>
        </trans-unit>
        <trans-unit id="7d5bb4d1e43ddd2b7554d5d7d0b44fa8e15c9b68" translate="yes" xml:space="preserve">
          <source>bitwise OR</source>
          <target state="translated">비트 OR</target>
        </trans-unit>
        <trans-unit id="5f0f8466323f4b1566846afa9c8d4b65fab80825" translate="yes" xml:space="preserve">
          <source>bitwise exclusive OR</source>
          <target state="translated">비트 배타적 OR</target>
        </trans-unit>
        <trans-unit id="5fc1df04ede4371bf68283b29ac654f74bc5bb92" translate="yes" xml:space="preserve">
          <source>brace expansion</source>
          <target state="translated">버팀대 확장</target>
        </trans-unit>
        <trans-unit id="748a336cc88c03ccb07ed5f5073d18624731b8b5" translate="yes" xml:space="preserve">
          <source>builtin</source>
          <target state="translated">builtin</target>
        </trans-unit>
        <trans-unit id="fccae45c20eb86351df553c5112826c1e2b0dde7" translate="yes" xml:space="preserve">
          <source>builtin xxx</source>
          <target state="translated">내장 xxx</target>
        </trans-unit>
        <trans-unit id="bd1dc6f71297c711fd62c63df1bdbc3f49918cb3" translate="yes" xml:space="preserve">
          <source>builtins</source>
          <target state="translated">builtins</target>
        </trans-unit>
        <trans-unit id="67088e8d86fead569a6b737f9775499b48ae14a4" translate="yes" xml:space="preserve">
          <source>but the value of the &lt;code&gt;PATH&lt;/code&gt; variable is not used to search for the filename.</source>
          <target state="translated">그러나 &lt;code&gt;PATH&lt;/code&gt; 변수 의 값은 파일 이름을 검색하는 데 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b135c91c22da20c5bf6a8140fd6629d0393e898" translate="yes" xml:space="preserve">
          <source>by giving &lt;code&gt;configure&lt;/code&gt; the option</source>
          <target state="translated">옵션 을 &lt;code&gt;configure&lt;/code&gt; 하여</target>
        </trans-unit>
        <trans-unit id="6e9f192b79a14968d26f70ab1aa8e21b65e3df64" translate="yes" xml:space="preserve">
          <source>carriage return</source>
          <target state="translated">캐리지 리턴</target>
        </trans-unit>
        <trans-unit id="b3597e3ba40838313efca5d16876aec7434a322f" translate="yes" xml:space="preserve">
          <source>cat file | bash</source>
          <target state="translated">고양이 파일 | 세게 때리다</target>
        </trans-unit>
        <trans-unit id="70c98830b8e294055184b1eb485a9ad71bd5052c" translate="yes" xml:space="preserve">
          <source>causes the file whose name is the expansion of &lt;var&gt;word&lt;/var&gt; to be opened for both reading and writing on file descriptor &lt;var&gt;n&lt;/var&gt;, or on file descriptor 0 if &lt;var&gt;n&lt;/var&gt; is not specified. If the file does not exist, it is created.</source>
          <target state="translated">파일 디스크립터 &lt;var&gt;n&lt;/var&gt; 에서 읽기 및 쓰기를 위해 또는 &lt;var&gt;n&lt;/var&gt; 이 지정되지 않은 경우 파일 디스크립터 0 에서 파일의 이름이 확장 된 &lt;var&gt;word&lt;/var&gt; 의 파일이 열리도록 합니다. 파일이 없으면 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="b452d6b23b3c28f85872fffd99bdaf90ce0ad44a" translate="yes" xml:space="preserve">
          <source>ce</source>
          <target state="translated">ce</target>
        </trans-unit>
        <trans-unit id="dc89efc56b3571e3abc91cb195241a7489437a83" translate="yes" xml:space="preserve">
          <source>characters will terminate an incremental search.</source>
          <target state="translated">문자는 증분 검색을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="6806f9cdb5c86b97d792597c92a2fbb73aad545c" translate="yes" xml:space="preserve">
          <source>comma</source>
          <target state="translated">comma</target>
        </trans-unit>
        <trans-unit id="077c890397bea2056341829848e85570a1fe69d1" translate="yes" xml:space="preserve">
          <source>command an argument of 10, you could type &amp;lsquo;</source>
          <target state="translated">10의 인수를 명령하면 '</target>
        </trans-unit>
        <trans-unit id="9eed55da1f298f022a2075483e35465f5e08f841" translate="yes" xml:space="preserve">
          <source>command editing</source>
          <target state="translated">명령 편집</target>
        </trans-unit>
        <trans-unit id="402ed957b23d3eaa92467b21cec4500025aa15aa" translate="yes" xml:space="preserve">
          <source>command execution</source>
          <target state="translated">명령 실행</target>
        </trans-unit>
        <trans-unit id="454756230d5364d24466bddafd2da935b6419e25" translate="yes" xml:space="preserve">
          <source>command expansion</source>
          <target state="translated">명령 확장</target>
        </trans-unit>
        <trans-unit id="4d1d77e25cd35356cde10ef63fc85f8a802d39fc" translate="yes" xml:space="preserve">
          <source>command history</source>
          <target state="translated">명령 기록</target>
        </trans-unit>
        <trans-unit id="b05e1cd716adf3f3e010054dd33cbc26546ba5cb" translate="yes" xml:space="preserve">
          <source>command line option, it follows the &lt;small&gt;POSIX&lt;/small&gt; standard for startup files. In this mode, interactive shells expand the &lt;code&gt;ENV&lt;/code&gt; variable and commands are read and executed from the file whose name is the expanded value. No other startup files are read.</source>
          <target state="translated">명령 행 옵션 은 시작 파일 의 &lt;small&gt;POSIX&lt;/small&gt; 표준을 따릅니다 . 이 모드에서 대화식 쉘은 &lt;code&gt;ENV&lt;/code&gt; 변수를 확장하고 이름이 확장 값인 파일에서 명령을 읽고 실행합니다. 다른 시작 파일을 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8a4be2d3930670c6d53b12e2f7d099be05b3eaca" translate="yes" xml:space="preserve">
          <source>command ls</source>
          <target state="translated">명령 ls</target>
        </trans-unit>
        <trans-unit id="428ab79c2b21a0ed2b6307161ddb8954b3df4542" translate="yes" xml:space="preserve">
          <source>command search</source>
          <target state="translated">명령 검색</target>
        </trans-unit>
        <trans-unit id="7ccd7eb1cd01381dd3073d46f1920ad418c69933" translate="yes" xml:space="preserve">
          <source>command substitution</source>
          <target state="translated">명령 대체</target>
        </trans-unit>
        <trans-unit id="a02c684aed3888815022d9330c1e1941a5a41dc9" translate="yes" xml:space="preserve">
          <source>command timing</source>
          <target state="translated">명령 타이밍</target>
        </trans-unit>
        <trans-unit id="09f7bb7a173d6082e979e94516f77977dd9559c9" translate="yes" xml:space="preserve">
          <source>command-line option or executing &amp;lsquo;</source>
          <target state="translated">명령 행 옵션 또는 '</target>
        </trans-unit>
        <trans-unit id="5b27cc7e22d1843c0482b877a83b3267c5ae7f2c" translate="yes" xml:space="preserve">
          <source>commands, compound</source>
          <target state="translated">명령, 복합</target>
        </trans-unit>
        <trans-unit id="06600b23932bc3e5e48fb2a1bde1b3811a68a80f" translate="yes" xml:space="preserve">
          <source>commands, conditional</source>
          <target state="translated">조건부 명령</target>
        </trans-unit>
        <trans-unit id="07245602a4027800213f178c6efe3048d5a286a5" translate="yes" xml:space="preserve">
          <source>commands, grouping</source>
          <target state="translated">명령, 그룹화</target>
        </trans-unit>
        <trans-unit id="964f17fac13390aa0191140375d2c0ae486dc079" translate="yes" xml:space="preserve">
          <source>commands, lists</source>
          <target state="translated">명령, 목록</target>
        </trans-unit>
        <trans-unit id="750b18cc74949c31c4817ce883fb1832a12cc61c" translate="yes" xml:space="preserve">
          <source>commands, looping</source>
          <target state="translated">명령, 반복</target>
        </trans-unit>
        <trans-unit id="e4858f65bbe715a3d4278901c913f7941a4f4e24" translate="yes" xml:space="preserve">
          <source>commands, pipelines</source>
          <target state="translated">명령, 파이프 라인</target>
        </trans-unit>
        <trans-unit id="991cb53bce6bfb337958a683762ecaf7304a4cf8" translate="yes" xml:space="preserve">
          <source>commands, shell</source>
          <target state="translated">명령, 쉘</target>
        </trans-unit>
        <trans-unit id="7e324281b3847e22c6cfc4a3621a0441c9125ab8" translate="yes" xml:space="preserve">
          <source>commands, simple</source>
          <target state="translated">간단한 명령</target>
        </trans-unit>
        <trans-unit id="843e2d09948add183056420948ba9afa2b24674c" translate="yes" xml:space="preserve">
          <source>comments, shell</source>
          <target state="translated">주석, 쉘</target>
        </trans-unit>
        <trans-unit id="a6b8d8f62e216ac25f3e5a24c05cd51dabb64e7d" translate="yes" xml:space="preserve">
          <source>commonly is, see above for the effects.</source>
          <target state="translated">일반적으로 효과는 위를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4d04521b659a980378ebb5bda98bc5d6300c89c8" translate="yes" xml:space="preserve">
          <source>comparison</source>
          <target state="translated">comparison</target>
        </trans-unit>
        <trans-unit id="a94ce5f6178f8dd5bd9b17199af4e12fcc69e9ce" translate="yes" xml:space="preserve">
          <source>completion builtins</source>
          <target state="translated">완성 내장</target>
        </trans-unit>
        <trans-unit id="fb996269eff67c0452e0538cc0f31775fb604799" translate="yes" xml:space="preserve">
          <source>conditional operator</source>
          <target state="translated">조건부 연산자</target>
        </trans-unit>
        <trans-unit id="aa221629d4166f269241614e022eba93f564a0c6" translate="yes" xml:space="preserve">
          <source>config-top.h</source>
          <target state="translated">config-top.h</target>
        </trans-unit>
        <trans-unit id="dd609cee42b96ae5a3197f92c6518ac41d9daf9d" translate="yes" xml:space="preserve">
          <source>config.cache</source>
          <target state="translated">config.cache</target>
        </trans-unit>
        <trans-unit id="03461db87a24c8a99f7e61a96ba5df4ef9e79d47" translate="yes" xml:space="preserve">
          <source>config.h</source>
          <target state="translated">config.h</target>
        </trans-unit>
        <trans-unit id="0a382cdcbcea7fc88d5b1dc00bbdad14a0624e14" translate="yes" xml:space="preserve">
          <source>config.log</source>
          <target state="translated">config.log</target>
        </trans-unit>
        <trans-unit id="0652e436f42d75f5672a8bd9ae2f398a55115d51" translate="yes" xml:space="preserve">
          <source>configuration</source>
          <target state="translated">configuration</target>
        </trans-unit>
        <trans-unit id="c4a709fa17ee62ed5b65e54177f2236a55318e5f" translate="yes" xml:space="preserve">
          <source>configure --help</source>
          <target state="translated">--help 구성</target>
        </trans-unit>
        <trans-unit id="87db583be5c13c1f7b3c958b10e03d67b6a2ca06" translate="yes" xml:space="preserve">
          <source>configure.ac</source>
          <target state="translated">configure.ac</target>
        </trans-unit>
        <trans-unit id="e79b46b13be5b5b4cb85f6ba62a192b4ac7a974c" translate="yes" xml:space="preserve">
          <source>containing compiler output (useful mainly for debugging &lt;code&gt;configure&lt;/code&gt;). If at some point</source>
          <target state="translated">컴파일러 출력을 포함합니다 (주로 &lt;code&gt;configure&lt;/code&gt; 디버깅에 유용 ). 어느 시점에</target>
        </trans-unit>
        <trans-unit id="a6f9c6ce275bbea9bac06ee3e4d1ed05a515d5f1" translate="yes" xml:space="preserve">
          <source>contains C Preprocessor &amp;lsquo;</source>
          <target state="translated">C 전 처리기 포함</target>
        </trans-unit>
        <trans-unit id="a298c0466afc46788b8c481fc945c74dc4e89bc7" translate="yes" xml:space="preserve">
          <source>contains a list of shell commands, one per line,</source>
          <target state="translated">쉘 명령 목록을 포함합니다 (한 줄에 하나씩).</target>
        </trans-unit>
        <trans-unit id="bfa1161684a7ffad5a5a9d245155a916a5f65324" translate="yes" xml:space="preserve">
          <source>contains results you don&amp;rsquo;t want to keep, you may remove or edit it.</source>
          <target state="translated">유지하고 싶지 않은 결과가 포함되어 있으면 삭제하거나 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4d69ec69f2661f0723d3eeba3e9d09b5fc1a7e4" translate="yes" xml:space="preserve">
          <source>contains the line</source>
          <target state="translated">라인을 포함</target>
        </trans-unit>
        <trans-unit id="5cbd49312e540274d99e98a86f39b6e2059f247c" translate="yes" xml:space="preserve">
          <source>control operator</source>
          <target state="translated">제어 연산자</target>
        </trans-unit>
        <trans-unit id="06bc848cd0de71c656b6e4faea36ba73e368f27b" translate="yes" xml:space="preserve">
          <source>control prefix</source>
          <target state="translated">제어 접두사</target>
        </trans-unit>
        <trans-unit id="a9132a9fdf23af1213879350ff511bbd1d538895" translate="yes" xml:space="preserve">
          <source>coprocess</source>
          <target state="translated">coprocess</target>
        </trans-unit>
        <trans-unit id="9145a3ad32249e3a113e52d2384b4bf1bb0f3b0f" translate="yes" xml:space="preserve">
          <source>csh</source>
          <target state="translated">csh</target>
        </trans-unit>
        <trans-unit id="75d4b00a1049122ad067c62b8a1d12b1fc774726" translate="yes" xml:space="preserve">
          <source>current traps set by &lt;code&gt;trap&lt;/code&gt;</source>
          <target state="translated">에 의해 설정된 현재의 트랩 &lt;code&gt;trap&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="935418780523b8666627e7503dffbdca3152b785" translate="yes" xml:space="preserve">
          <source>declare -i</source>
          <target state="translated">선언 -i</target>
        </trans-unit>
        <trans-unit id="d581e7e3785c1029634135fed966140a7767e034" translate="yes" xml:space="preserve">
          <source>declare -x</source>
          <target state="translated">선언 -x</target>
        </trans-unit>
        <trans-unit id="9485989ff514b5106b7738850fd73c23e8c1e3f7" translate="yes" xml:space="preserve">
          <source>delete</source>
          <target state="translated">delete</target>
        </trans-unit>
        <trans-unit id="04ede91cc7b184ec1d5c9237f2a5e61141d8fc63" translate="yes" xml:space="preserve">
          <source>designates the last argument of the preceding command. This may be shortened to &lt;code&gt;!$&lt;/code&gt;.</source>
          <target state="translated">이전 명령의 마지막 인수를 지정합니다. &lt;code&gt;!$&lt;/code&gt; 로 단축 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4b612cb76c7d2ce13fca9100dbed308987d47df3" translate="yes" xml:space="preserve">
          <source>designates the preceding command. When you type this, the preceding command is repeated in toto.</source>
          <target state="translated">이전 명령을 지정합니다. 이것을 입력하면 이전 명령이 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="50051d6d9aefc6de1b14b7d66f7bc3faf424831f" translate="yes" xml:space="preserve">
          <source>designates the second argument of the most recent command starting with the letters &lt;code&gt;fi&lt;/code&gt;.</source>
          <target state="translated">문자 &lt;code&gt;fi&lt;/code&gt; 로 시작하는 가장 최근 명령의 두 번째 인수를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="4918151e941e8e1cdd88f2fec4cd995c9b7fbfe0" translate="yes" xml:space="preserve">
          <source>designed for human modification. Examples of transparent image formats include</source>
          <target state="translated">인간 수정을 위해 설계되었습니다. 투명한 이미지 형식의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4559b9a75a27e2112213399116a91ccc02b2b8d1" translate="yes" xml:space="preserve">
          <source>directories, each directory under</source>
          <target state="translated">디렉토리, 각 디렉토리 아래</target>
        </trans-unit>
        <trans-unit id="73d18221870155650a2a5df22f1db22d18fbd895" translate="yes" xml:space="preserve">
          <source>directory stack</source>
          <target state="translated">디렉토리 스택</target>
        </trans-unit>
        <trans-unit id="832a6c915c30481f1aecc9b9ec5600f7288a555e" translate="yes" xml:space="preserve">
          <source>directs both standard output (file descriptor 1) and standard error (file descriptor 2) to the file &lt;var&gt;dirlist&lt;/var&gt;, while the command</source>
          <target state="translated">파일을 모두 표준 출력 (파일 기술자 1)과 표준 오차 (파일 기술자 2) 지시 &lt;var&gt;dirlist&lt;/var&gt; 을 명령하는 동안,</target>
        </trans-unit>
        <trans-unit id="382d3f7938d955f423af4f34a33261241e45c9b2" translate="yes" xml:space="preserve">
          <source>directs only the standard output to file &lt;var&gt;dirlist&lt;/var&gt;, because the standard error was made a copy of the standard output before the standard output was redirected to &lt;var&gt;dirlist&lt;/var&gt;.</source>
          <target state="translated">표준 출력이 &lt;var&gt;dirlist&lt;/var&gt; 로 경로 재 지정되기 전에 표준 오류가 표준 출력의 사본이 되었기 때문에 표준 출력 만 파일 &lt;var&gt;dirlist&lt;/var&gt; 로 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="3904c3fa5235bded78ba13f24e0690a907f04e90" translate="yes" xml:space="preserve">
          <source>direxpand-default</source>
          <target state="translated">direxpand-default</target>
        </trans-unit>
        <trans-unit id="fbab444ca8de7b9af1966fe25bbfd9b1ffd1efdb" translate="yes" xml:space="preserve">
          <source>dirs +&lt;var&gt;N&lt;/var&gt;</source>
          <target state="translated">dirs + &lt;var&gt;N&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="9cf2faf360544bc3c530d7005a5e750d4ded5738" translate="yes" xml:space="preserve">
          <source>dirs -&lt;var&gt;N&lt;/var&gt;</source>
          <target state="translated">dirs- &lt;var&gt;N&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="9d0f44a9c56f780e55732c15d00549586d34d7b8" translate="yes" xml:space="preserve">
          <source>disabled-builtins</source>
          <target state="translated">disabled-builtins</target>
        </trans-unit>
        <trans-unit id="f7f029ecb98abe979074a3ab45b74dbd9af02d42" translate="yes" xml:space="preserve">
          <source>doc</source>
          <target state="translated">doc</target>
        </trans-unit>
        <trans-unit id="5554bff0e540b930596ca569f631433f1f953645" translate="yes" xml:space="preserve">
          <source>double quote</source>
          <target state="translated">큰 따옴표</target>
        </trans-unit>
        <trans-unit id="58e6b3a414a1e090dfc6029add0f3555ccba127f" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">e</target>
        </trans-unit>
        <trans-unit id="a4820ba31c47bcf6ac4b6d5af46eba5ffc4fe15b" translate="yes" xml:space="preserve">
          <source>editing command lines</source>
          <target state="translated">명령 행 편집</target>
        </trans-unit>
        <trans-unit id="802c59623ae48a66b2de310fa2d5a01babe1b993" translate="yes" xml:space="preserve">
          <source>else &lt;var&gt;alternate-consequents&lt;/var&gt;</source>
          <target state="translated">다른 &lt;var&gt;alternate-consequents&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="4bb0566de8ca4848075d64ca6dd14fea11761eb1" translate="yes" xml:space="preserve">
          <source>emacs</source>
          <target state="translated">emacs</target>
        </trans-unit>
        <trans-unit id="8f0986a2abfcb06779c186c5be49d67461de0fa6" translate="yes" xml:space="preserve">
          <source>enable -n test</source>
          <target state="translated">-n 테스트 활성화</target>
        </trans-unit>
        <trans-unit id="dec2b5965becfeec0ac8e7c5fb835124ad73557d" translate="yes" xml:space="preserve">
          <source>enable -n xxx</source>
          <target state="translated">-n xxx 활성화</target>
        </trans-unit>
        <trans-unit id="30fdd0b8498d29a0f29849648fbaa394f44ad7d2" translate="yes" xml:space="preserve">
          <source>enable-&lt;var&gt;feature&lt;/var&gt;</source>
          <target state="translated">enable-&lt;var&gt;feature&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="c6e454d960df4845f9d69eb11377c8b23882715b" translate="yes" xml:space="preserve">
          <source>environment</source>
          <target state="translated">environment</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
