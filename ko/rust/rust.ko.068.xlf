<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="2170c54e7e7e211e3d0e2c65e377ae8bcaea7ac1" translate="yes" xml:space="preserve">
          <source>This method will ensure that any current waiters on the condition variable are awoken. Calls to &lt;code&gt;notify_all()&lt;/code&gt; are not buffered in any way.</source>
          <target state="translated">이 방법을 사용하면 조건 변수의 현재 웨이터가 해제됩니다. &lt;code&gt;notify_all()&lt;/code&gt; 대한 호출 은 어떤 식으로도 버퍼링되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="149968b75a735130b9e849f252f39d4aeeb3370e" translate="yes" xml:space="preserve">
          <source>This method will evaluate the iterator until it returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. While doing so, it keeps track of the current element. After &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned, &lt;code&gt;last()&lt;/code&gt; will then return the last element it saw.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이 리턴 될 때까지 반복자를 평가합니다 . 그렇게하는 동안 현재 요소를 추적합니다. &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이 반환 된 후 &lt;code&gt;last()&lt;/code&gt; 는 마지막으로 본 요소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="60132e29639954faf0b02a7c1a61ca490fca81f1" translate="yes" xml:space="preserve">
          <source>This method will evaluate the iterator until its &lt;a href=&quot;#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. Once &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is encountered, &lt;code&gt;count()&lt;/code&gt; returns the number of times it called &lt;a href=&quot;#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 이&lt;/a&gt; 리턴 될 때까지 반복자를 평가합니다 . 일단 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 발생되지 않으며, &lt;code&gt;count()&lt;/code&gt; 의 수를 반환이라는 시간 &lt;a href=&quot;#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="430231e1c82b4b198abc958a7fd105f7b17a6eb0" translate="yes" xml:space="preserve">
          <source>This method will fail if the socket is not connected. The &lt;code&gt;connect&lt;/code&gt; method will connect this socket to a remote address.</source>
          <target state="translated">소켓이 연결되어 있지 않으면이 방법이 실패합니다. &lt;code&gt;connect&lt;/code&gt; 방법은 리모트 주소에 소켓을 연결합니다.</target>
        </trans-unit>
        <trans-unit id="99d3a71bbe68b832fc3370a5188434c797f36ae5" translate="yes" xml:space="preserve">
          <source>This method will never block the caller in order to wait for data to become available. Instead, this will always return immediately with a possible option of pending data on the channel.</source>
          <target state="translated">이 메소드는 데이터가 사용 가능할 때까지 호출자를 차단하지 않습니다. 대신 채널에서 보류중인 데이터의 가능한 옵션과 함께 항상 즉시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cbdaac7e9262e1ca34c4fe476a690d8dd791b78c" translate="yes" xml:space="preserve">
          <source>This method will never block the current thread.</source>
          <target state="translated">이 메소드는 현재 스레드를 차단하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="46d2c9fdd8f22af9ddb09186941e568038365eb2" translate="yes" xml:space="preserve">
          <source>This method will panic if result is not finite, negative or overflows &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">결과가 유한, 음수 또는 오버플로 &lt;code&gt;Duration&lt;/code&gt; 이 아닌 경우이 메서드는 패닉 상태가됩니다 .</target>
        </trans-unit>
        <trans-unit id="361fc3f209ee1e7f236b4d7adeffb54823eee70f" translate="yes" xml:space="preserve">
          <source>This method will take care to not copy the vector, for efficiency's sake.</source>
          <target state="translated">이 방법은 효율성을 위해 벡터를 복사하지 않도록주의합니다.</target>
        </trans-unit>
        <trans-unit id="15bda4a4da4275b96ba5bd1843478dd37908d7e9" translate="yes" xml:space="preserve">
          <source>This module also provides an implementation of thread-local storage for Rust programs. Thread-local storage is a method of storing data into a global variable that each thread in the program will have its own copy of. Threads do not share this data, so accesses do not need to be synchronized.</source>
          <target state="translated">이 모듈은 Rust 프로그램을위한 스레드 로컬 스토리지의 구현도 제공합니다. 스레드 로컬 저장소는 프로그램의 각 스레드가 고유 한 복사본을 갖는 전역 변수에 데이터를 저장하는 방법입니다. 스레드는이 데이터를 공유하지 않으므로 액세스를 동기화 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a618e47bcd778e6fbdbebc05ca474e36092d34bf" translate="yes" xml:space="preserve">
          <source>This module contains basic methods to manipulate the contents of the local filesystem. All methods in this module represent cross-platform filesystem operations. Extra platform-specific functionality can be found in the extension traits of &lt;code&gt;std::os::$platform&lt;/code&gt;.</source>
          <target state="translated">이 모듈에는 로컬 파일 시스템의 내용을 조작하는 기본 방법이 포함되어 있습니다. 이 모듈의 모든 메소드는 크로스 플랫폼 파일 시스템 조작을 나타냅니다. 추가 플랫폼 별 기능은 &lt;code&gt;std::os::$platform&lt;/code&gt; 의 확장 특성에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="facf45454888eb2d77ede3ccdd2076d5cf487a0e" translate="yes" xml:space="preserve">
          <source>This module contains functions for querying the size and alignment of types, initializing and manipulating memory.</source>
          <target state="translated">이 모듈에는 유형의 크기와 정렬을 쿼리하고 메모리를 초기화하고 조작하는 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2408b577206af618721c013114d9c06e429f800a" translate="yes" xml:space="preserve">
          <source>This module contains functions to inspect various aspects such as environment variables, process arguments, the current directory, and various other important directories.</source>
          <target state="translated">이 모듈에는 환경 변수, 프로세스 인수, 현재 디렉토리 및 기타 중요한 디렉토리와 같은 다양한 측면을 검사하는 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="493f5d09dd437f62e48924cee92d925e5c7d2ef1" translate="yes" xml:space="preserve">
          <source>This module contains the &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; type, a trait for converting &lt;a href=&quot;trait.tostring&quot;&gt;&lt;code&gt;ToString&lt;/code&gt;&lt;/a&gt;s, and several error types that may result from working with &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">이 모듈에는 &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 유형, &lt;a href=&quot;trait.tostring&quot;&gt; &lt;code&gt;ToString&lt;/code&gt; &lt;/a&gt; 변환에 대한 특성 및 &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 작업으로 인해 발생할 수있는 몇 가지 오류 유형이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="a15bad5d969fcb97693f6f0bc38018fba7343164" translate="yes" xml:space="preserve">
          <source>This module contains the runtime support for the &lt;a href=&quot;../macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; syntax extension. This macro is implemented in the compiler to emit calls to this module in order to format arguments at runtime into strings.</source>
          <target state="translated">이 모듈에는 &lt;a href=&quot;../macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt; 대한 런타임 지원이 포함되어 있습니다 ! 구문 확장. 이 매크로는 컴파일러에서 구현되어 런타임시 인수를 문자열로 형식화하기 위해이 모듈에 대한 호출을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="fe75678b9da36500f1155d5a63660783d7b96c49" translate="yes" xml:space="preserve">
          <source>This module contains various tools for ordering and comparing values. In summary:</source>
          <target state="translated">이 모듈에는 값을 정렬하고 비교하기위한 다양한 도구가 포함되어 있습니다. 요약해서 말하자면:</target>
        </trans-unit>
        <trans-unit id="5526cfdf674b75dda2276399dbf95bab9061f815" translate="yes" xml:space="preserve">
          <source>This module defines atomic versions of a select number of primitive types, including &lt;a href=&quot;struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.atomicisize&quot;&gt;&lt;code&gt;AtomicIsize&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.atomicusize&quot;&gt;&lt;code&gt;AtomicUsize&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.atomici8&quot;&gt;&lt;code&gt;AtomicI8&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.atomicu16&quot;&gt;&lt;code&gt;AtomicU16&lt;/code&gt;&lt;/a&gt;, etc. Atomic types present operations that, when used correctly, synchronize updates between threads.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;struct.atomicbool&quot;&gt; &lt;code&gt;AtomicBool&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.atomicisize&quot;&gt; &lt;code&gt;AtomicIsize&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.atomicusize&quot;&gt; &lt;code&gt;AtomicUsize&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.atomici8&quot;&gt; &lt;code&gt;AtomicI8&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.atomicu16&quot;&gt; &lt;code&gt;AtomicU16&lt;/code&gt; &lt;/a&gt; 등을 포함하여 선택된 수의 기본 유형의 원자 버전을 정의합니다 . 원자 유형은 올바르게 사용될 때 스레드 간 업데이트를 동기화하는 조작을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="69b6d67047755d0189ccf8e0dd69886ba1af9f48" translate="yes" xml:space="preserve">
          <source>This module exists for technical reasons, the primary documentation for &lt;code&gt;char&lt;/code&gt; is directly on &lt;a href=&quot;../primitive.char&quot;&gt;the &lt;code&gt;char&lt;/code&gt; primitive type&lt;/a&gt; itself.</source>
          <target state="translated">이 모듈에 대한 기본 문서, 기술적 인 이유로 존재 &lt;code&gt;char&lt;/code&gt; 에 바로 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 원시 형 자체.</target>
        </trans-unit>
        <trans-unit id="0c05c40f88eef085aa06e135cdea7a637a633c60" translate="yes" xml:space="preserve">
          <source>This module implements the &lt;code&gt;Any&lt;/code&gt; trait, which enables dynamic typing of any &lt;code&gt;'static&lt;/code&gt; type through runtime reflection.</source>
          <target state="translated">이 모듈은 &lt;code&gt;Any&lt;/code&gt; 특성을 구현하여 런타임 반영을 통해 모든 &lt;code&gt;'static&lt;/code&gt; 유형을 동적으로 입력 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a2779c978566f8d66cd98dfb5457c45d53a57fb6" translate="yes" xml:space="preserve">
          <source>This module is largely organized by type:</source>
          <target state="translated">이 모듈은 크게 유형별로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="5be07f93f33ed08d424575dcac18854b8631d380" translate="yes" xml:space="preserve">
          <source>This module is mostly concerned with spawning and interacting with child processes, but it also provides &lt;a href=&quot;fn.abort&quot;&gt;&lt;code&gt;abort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.exit&quot;&gt;&lt;code&gt;exit&lt;/code&gt;&lt;/a&gt; for terminating the current process.</source>
          <target state="translated">이 모듈은 주로 자식 프로세스의 생성 및 상호 작용과 관련이 있지만 현재 프로세스를 종료하기위한 &lt;a href=&quot;fn.abort&quot;&gt; &lt;code&gt;abort&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;fn.exit&quot;&gt; &lt;code&gt;exit&lt;/code&gt; &lt;/a&gt; 도 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="288daae4ba933c2cf1c52332e7aec01da8baaf15" translate="yes" xml:space="preserve">
          <source>This module is the home of the iterator implementations for the iterators implemented on &lt;code&gt;char&lt;/code&gt;, as well as some useful constants and conversion functions that convert various types to &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 &lt;code&gt;char&lt;/code&gt; 에 구현 된 반복자에 대한 반복자 구현 과 다양한 유형을 &lt;code&gt;char&lt;/code&gt; 로 변환하는 유용한 상수 및 변환 함수의 홈입니다 .</target>
        </trans-unit>
        <trans-unit id="16223be8f664aa8af7792fdf4f8c15d5b579360d" translate="yes" xml:space="preserve">
          <source>This module only currently provides one bit of information, &lt;a href=&quot;struct.permissions#method.readonly&quot;&gt;&lt;code&gt;readonly&lt;/code&gt;&lt;/a&gt;, which is exposed on all currently supported platforms. Unix-specific functionality, such as mode bits, is available through the &lt;a href=&quot;../os/unix/fs/trait.permissionsext&quot;&gt;&lt;code&gt;PermissionsExt&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">이 모듈은 현재 현재 지원되는 모든 플랫폼에서 공개되는 1 비트의 정보 인 &lt;a href=&quot;struct.permissions#method.readonly&quot;&gt; &lt;code&gt;readonly&lt;/code&gt; &lt;/a&gt; 만 제공 합니다. 모드 비트와 같은 유닉스 관련 기능은 &lt;a href=&quot;../os/unix/fs/trait.permissionsext&quot;&gt; &lt;code&gt;PermissionsExt&lt;/code&gt; &lt;/a&gt; 특성을 통해 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="72abc30b878e9efe98c4c560589176b50cfcfb02" translate="yes" xml:space="preserve">
          <source>This module provides a generic way to compute the hash of a value. The simplest way to make a type hashable is to use &lt;code&gt;#[derive(Hash)]&lt;/code&gt;:</source>
          <target state="translated">이 모듈은 값의 해시를 계산하는 일반적인 방법을 제공합니다. 형식을 해시 가능하게 만드는 가장 간단한 방법은 &lt;code&gt;#[derive(Hash)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f6357e74fc7527ed8e55102f82ccb8843f20d51" translate="yes" xml:space="preserve">
          <source>This module provides constants which are specific to the implementation of the &lt;code&gt;f32&lt;/code&gt; floating point data type.</source>
          <target state="translated">이 모듈은 &lt;code&gt;f32&lt;/code&gt; 부동 소수점 데이터 유형 의 구현에 고유 한 상수를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="87f0d2ad3a049e2ea757e82944e2e6b1d2f310c4" translate="yes" xml:space="preserve">
          <source>This module provides constants which are specific to the implementation of the &lt;code&gt;f64&lt;/code&gt; floating point data type.</source>
          <target state="translated">이 모듈은 &lt;code&gt;f64&lt;/code&gt; 부동 소수점 데이터 유형 의 구현에 고유 한 상수를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="4dd1d432064e6f3e28ac8c1d81caf06446f388ba" translate="yes" xml:space="preserve">
          <source>This module provides message-based communication over channels, concretely defined among three types:</source>
          <target state="translated">이 모듈은 세 가지 유형으로 구체적으로 정의 된 채널을 통한 메시지 기반 통신을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bfedf6f4f14d905a894526b273dfe17f7e7c03dc" translate="yes" xml:space="preserve">
          <source>This module provides networking functionality for the Transmission Control and User Datagram Protocols, as well as types for IP and socket addresses.</source>
          <target state="translated">이 모듈은 IP 및 소켓 주소 유형뿐만 아니라 전송 제어 및 사용자 데이터 그램 프로토콜에 대한 네트워킹 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fcfa8dfe7aed9682173752b15b6103829ea655a1" translate="yes" xml:space="preserve">
          <source>This module provides some extra types that are useful when doing numerical work. See the individual documentation for each piece for more information.</source>
          <target state="translated">이 모듈은 수치 작업을 할 때 유용한 추가 유형을 제공합니다. 자세한 내용은 각 부분에 대한 개별 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b42dc453d74574a22f838766ed6a6210b7719f9b" translate="yes" xml:space="preserve">
          <source>This module provides two types, &lt;a href=&quot;struct.pathbuf&quot;&gt;&lt;code&gt;PathBuf&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; (akin to &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;), for working with paths abstractly. These types are thin wrappers around &lt;a href=&quot;../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; respectively, meaning that they work directly on strings according to the local platform's path syntax.</source>
          <target state="translated">이 모듈은 경로를 추상적으로 사용하기 위해 &lt;a href=&quot;struct.pathbuf&quot;&gt; &lt;code&gt;PathBuf&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; (akin to &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; )의 두 가지 유형을 제공합니다 . 이러한 유형은 각각 &lt;a href=&quot;../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt; 주위의 얇은 래퍼 입니다. 즉, 로컬 플랫폼의 경로 구문에 따라 문자열에서 직접 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f2fe72f6bcf1faf654e10546253a992773369d18" translate="yes" xml:space="preserve">
          <source>This module provides utilities to handle data across non-Rust interfaces, like other programming languages and the underlying operating system. It is mainly of use for FFI (Foreign Function Interface) bindings and code that needs to exchange C-like strings with other languages.</source>
          <target state="translated">이 모듈은 다른 프로그래밍 언어 및 기본 운영 체제와 같이 비 Rust 인터페이스에서 데이터를 처리하는 유틸리티를 제공합니다. C 유사 문자열을 다른 언어와 교환해야하는 FFI (Foreign Function Interface) 바인딩 및 코드에 주로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2bfbd1c67f1485adce8aa9ca96b08fda6c8d21af" translate="yes" xml:space="preserve">
          <source>This mutex will block threads waiting for the lock to become available. The mutex can also be statically initialized or created via a &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; constructor. Each mutex has a type parameter which represents the data that it is protecting. The data can only be accessed through the RAII guards returned from &lt;a href=&quot;#method.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt;, which guarantees that the data is only ever accessed when the mutex is locked.</source>
          <target state="translated">이 뮤텍스는 잠금을 사용할 수있게되기를 기다리는 스레드를 차단합니다. 뮤텍스는 정적으로 초기화되거나 &lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 생성자 를 통해 생성 될 수도 있습니다 . 각 뮤텍스에는 보호하고있는 데이터를 나타내는 유형 매개 변수가 있습니다. 데이터는 &lt;a href=&quot;#method.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#method.try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt; 에서 반환 된 RAII 가드를 통해서만 액세스 할 수 있으며, 뮤텍스가 잠겨있을 때만 데이터에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56f3b065f3863bd74d78c00a2522270062418669" translate="yes" xml:space="preserve">
          <source>This never needs to re-allocate, but does need to do O(n) data movement if the circular buffer doesn't happen to be at the beginning of the allocation.</source>
          <target state="translated">이것은 다시 할당 할 필요는 없지만 순환 버퍼가 할당의 시작 부분에 있지 않으면 O (n) 데이터 이동을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="d28b87d734ed0d5315fcb74f17b2994ec84a38d2" translate="yes" xml:space="preserve">
          <source>This new slice goes from &lt;code&gt;begin&lt;/code&gt; to &lt;code&gt;end&lt;/code&gt;, including &lt;code&gt;begin&lt;/code&gt; but excluding &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">이 새로운 슬라이스는 &lt;code&gt;begin&lt;/code&gt; 을 제외한 &lt;code&gt;end&lt;/code&gt; 를 포함하여 &lt;code&gt;begin&lt;/code&gt; 부터 &lt;code&gt;end&lt;/code&gt; 진행됩니다 .</target>
        </trans-unit>
        <trans-unit id="c5e5d3eaf75778ffc4640687e8cefa2e10e75497" translate="yes" xml:space="preserve">
          <source>This next example calls a supertrait method on a generic parameter.</source>
          <target state="translated">다음 예제는 일반 매개 변수에서 수퍼 특성 메소드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="9f7ad17f03d80b97ecff41fe1815f8dca0918d1f" translate="yes" xml:space="preserve">
          <source>This next example gives &lt;code&gt;radius&lt;/code&gt; a default implementation using the &lt;code&gt;area&lt;/code&gt; function from &lt;code&gt;Shape&lt;/code&gt;.</source>
          <target state="translated">다음 예제 에서는 &lt;code&gt;Shape&lt;/code&gt; 의 &lt;code&gt;area&lt;/code&gt; 함수를 사용하여 &lt;code&gt;radius&lt;/code&gt; 에 기본 구현을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="50d4d7072a1ea5b824d1df9626f273fc9c52a75a" translate="yes" xml:space="preserve">
          <source>This number is a lower bound; the &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; might be able to hold more, but is guaranteed to be able to hold at least this many.</source>
          <target state="translated">이 숫자는 하한입니다. &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; 더 보유 할 수있을 수도 있지만, 적어도이 많이 보유 할 수 있도록 보장한다.</target>
        </trans-unit>
        <trans-unit id="75625b78a6cc53054a38dc48c604ece0622bfe30" translate="yes" xml:space="preserve">
          <source>This number is simply useful for passing to other methods, like &lt;a href=&quot;struct.osstring#method.with_capacity&quot;&gt;&lt;code&gt;OsString::with_capacity&lt;/code&gt;&lt;/a&gt; to avoid reallocations.</source>
          <target state="translated">이 숫자는 재 할당을 피하기 위해 &lt;a href=&quot;struct.osstring#method.with_capacity&quot;&gt; &lt;code&gt;OsString::with_capacity&lt;/code&gt; &lt;/a&gt; 와 같은 다른 메소드로 전달하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="1f022d625542e31d83b61a7cfb496898fc698f8a" translate="yes" xml:space="preserve">
          <source>This only differs from the previous &lt;code&gt;impl&lt;/code&gt; in that the parameters &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;MyType&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;code&gt;ForeignTrait2&lt;/code&gt; have been swapped. This example does &lt;em&gt;not&lt;/em&gt; violate the orphan rule; it is permitted.</source>
          <target state="translated">&lt;code&gt;ForeignTrait2&lt;/code&gt; 에 대한 매개 변수 &lt;code&gt;T&lt;/code&gt; 및 &lt;code&gt;MyType&amp;lt;T&amp;gt;&lt;/code&gt; 이 바뀌 었다는 점에서 이것은 이전 &lt;code&gt;impl&lt;/code&gt; 과 다릅니다 . 이 예제는 고아 규칙을 위반 하지 &lt;em&gt;않습니다&lt;/em&gt; . 허용됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="123296246acbbeb137b9c0c76f971008749a56bb" translate="yes" xml:space="preserve">
          <source>This operation does &lt;strong&gt;not&lt;/strong&gt; modify the filesystem. To modify the filesystem use the &lt;a href=&quot;fn.set_permissions&quot;&gt;&lt;code&gt;fs::set_permissions&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">이 작업은 파일 시스템을 수정 하지 &lt;strong&gt;않습니다&lt;/strong&gt; . 파일 시스템을 수정하려면 &lt;a href=&quot;fn.set_permissions&quot;&gt; &lt;code&gt;fs::set_permissions&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c0bbc4d892938033fbacd4684ea2a287c924f8c" translate="yes" xml:space="preserve">
          <source>This operation is &lt;code&gt;O(1)&lt;/code&gt;.</source>
          <target state="translated">이 작업은 &lt;code&gt;O(1)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1fdec81639aa08f036b813714ac253cba45f17ed" translate="yes" xml:space="preserve">
          <source>This operation is sometimes called 'reduce' or 'inject'.</source>
          <target state="translated">이 작업을 때때로 '감소'또는 '주입'이라고합니다.</target>
        </trans-unit>
        <trans-unit id="e2fd1d86e77ef341cc160d32009392653fd89ec1" translate="yes" xml:space="preserve">
          <source>This operation rounds towards zero, truncating any fractional part of the exact result.</source>
          <target state="translated">이 연산은 0으로 반올림하여 정확한 결과의 일부를 잘라냅니다.</target>
        </trans-unit>
        <trans-unit id="77029037758bda804fd792f27ba1f29cea457a7e" translate="yes" xml:space="preserve">
          <source>This operation satisfies &lt;code&gt;n % d == n - (n / d) * d&lt;/code&gt;. The result has the same sign as the left operand.</source>
          <target state="translated">이 연산은 &lt;code&gt;n % d == n - (n / d) * d&lt;/code&gt; 충족시킵니다 . 결과는 왼쪽 피연산자와 같은 부호를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="48c9bdd59dbbaca42da37bc9d33eec68b2af8961" translate="yes" xml:space="preserve">
          <source>This operation should compute in O(1) time and O(1) memory.</source>
          <target state="translated">이 작업은 O (1) 시간과 O (1) 메모리로 계산해야합니다.</target>
        </trans-unit>
        <trans-unit id="fc7c0f50f52c35ea7e364b7e26d103277ce95b38" translate="yes" xml:space="preserve">
          <source>This operation should compute in O(1) time.</source>
          <target state="translated">이 작업은 O (1) 시간으로 계산되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a13a41f53da524732e21aa1da4b3958def62f00f" translate="yes" xml:space="preserve">
          <source>This operation should compute in O(n) time.</source>
          <target state="translated">이 작업은 O (n) 시간으로 계산해야합니다.</target>
        </trans-unit>
        <trans-unit id="4da5d428cc5f4bb1f1eadb7b45f2669f2c6be87e" translate="yes" xml:space="preserve">
          <source>This operation was interrupted.</source>
          <target state="translated">이 작업이 중단되었습니다.</target>
        </trans-unit>
        <trans-unit id="e5b25bf34db3082fbebf881dd2f3b63132ce24a9" translate="yes" xml:space="preserve">
          <source>This operation wraps around on overflow.</source>
          <target state="translated">이 작업은 오버플로로 래핑됩니다.</target>
        </trans-unit>
        <trans-unit id="513292ffc7d15c4c6459299bf349f4e8ef41bcc6" translate="yes" xml:space="preserve">
          <source>This option defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 옵션의 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="07732c105324f285891b421be7b1897cf45eb1a8" translate="yes" xml:space="preserve">
          <source>This option indicates whether a new file will be created if the file does not yet already exist.</source>
          <target state="translated">이 옵션은 파일이 아직없는 경우 새 파일을 만들지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2ab719a36168121ae6911773d2659e3887ae7b87" translate="yes" xml:space="preserve">
          <source>This option indicates whether a new file will be created. No file is allowed to exist at the target location, also no (dangling) symlink.</source>
          <target state="translated">이 옵션은 새 파일을 만들지 여부를 나타냅니다. 대상 위치에 파일이 존재하지 않으며 (댕글 링) 심볼릭 링크도 없습니다.</target>
        </trans-unit>
        <trans-unit id="1997355865e9c95bba24957f07adb48aa7900b34" translate="yes" xml:space="preserve">
          <source>This option is useful because it is atomic. Otherwise between checking whether a file exists and creating a new one, the file may have been created by another process (a TOCTOU race condition / attack).</source>
          <target state="translated">이 옵션은 원자 적이기 때문에 유용합니다. 그렇지 않으면 파일이 존재하는지 확인하고 새 파일을 작성하는 사이에 다른 프로세스 (TOCTOU 경쟁 조건 / 공격)에 의해 파일이 작성되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d1d1f446736eda75bb94ad6c4911fc032b1110f" translate="yes" xml:space="preserve">
          <source>This option, when true, means that writes will append to a file instead of overwriting previous contents. Note that setting &lt;code&gt;.write(true).append(true)&lt;/code&gt; has the same effect as setting only &lt;code&gt;.append(true)&lt;/code&gt;.</source>
          <target state="translated">이 옵션이 true이면 쓰기가 이전 내용을 덮어 쓰지 않고 파일에 추가됨을 의미합니다. 설정주의 &lt;code&gt;.write(true).append(true)&lt;/code&gt; 만을 설정하는 것과 같은 효과가있다 &lt;code&gt;.append(true)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="279fd5d225ffc9cf4a6694f03d2272dc1973056a" translate="yes" xml:space="preserve">
          <source>This option, when true, will indicate that the file should be &lt;code&gt;read&lt;/code&gt;-able if opened.</source>
          <target state="translated">이 옵션이 true 인 경우 파일을 열면 파일을 &lt;code&gt;read&lt;/code&gt; 수 있어야 함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="2aa691cde7b75893eb561d3865c9d79612f73f71" translate="yes" xml:space="preserve">
          <source>This option, when true, will indicate that the file should be &lt;code&gt;write&lt;/code&gt;-able if opened.</source>
          <target state="translated">이 옵션은 true 인 경우 파일을 열면 &lt;code&gt;write&lt;/code&gt; 해야 함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="42af0ae9cc5372b7ccd519ad313f0abe9e0cfe15" translate="yes" xml:space="preserve">
          <source>This ordering is only applicable for operations that can perform a load.</source>
          <target state="translated">이 순서는로드를 수행 할 수있는 작업에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="20a3da5b9e12d0ccdf3e64c2e589466b4721fced" translate="yes" xml:space="preserve">
          <source>This ordering is only applicable for operations that can perform a store.</source>
          <target state="translated">이 주문은 상점을 수행 할 수있는 조작에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ea76b31c997f4d8a61f17e8560093311b945344f" translate="yes" xml:space="preserve">
          <source>This ordering is only applicable for operations that combine both loads and stores.</source>
          <target state="translated">이 주문은로드와 저장을 모두 결합하는 조작에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a87804f30fcdf78425015d26ec12efca3e1a08c7" translate="yes" xml:space="preserve">
          <source>This output is better: we now have a reasonable error message. However, we also have extraneous information we don&amp;rsquo;t want to give to our users. Perhaps using the technique we used in Listing 9-10 isn&amp;rsquo;t the best to use here: a call to &lt;code&gt;panic!&lt;/code&gt; is more appropriate for a programming problem than a usage problem, &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#guidelines-for-error-handling&quot;&gt;as discussed in Chapter 9&lt;/a&gt;. Instead, we can use the other technique you learned about in Chapter 9&amp;mdash;&lt;a href=&quot;ch09-02-recoverable-errors-with-result&quot;&gt;returning a &lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; that indicates either success or an error.</source>
          <target state="translated">이 출력이 더 좋습니다 : 이제 합리적인 오류 메시지가 나타납니다. 그러나 사용자에게 제공하고 싶지 않은 정보도 있습니다. 아마도 우리가 Listing 9-10에서 사용한 기술을 사용하는 것이 여기에 사용하기에 가장 좋은 것은 아닙니다 &lt;code&gt;panic!&lt;/code&gt; &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#guidelines-for-error-handling&quot;&gt;9 장에서 논의 된 것처럼&lt;/a&gt; 사용 문제보다 프로그래밍 문제에 더 적합합니다 . 대신 9 장에서 배운 다른 기술인 성공 또는 오류를 나타내는 &lt;a href=&quot;ch09-02-recoverable-errors-with-result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 를 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="04051f730c7eeba40e7dd9250f9fd3ae55f310b9" translate="yes" xml:space="preserve">
          <source>This output isn&amp;rsquo;t what we wanted. We want to call the &lt;code&gt;baby_name&lt;/code&gt; function that is part of the &lt;code&gt;Animal&lt;/code&gt; trait that we implemented on &lt;code&gt;Dog&lt;/code&gt; so the code prints &lt;code&gt;A baby dog is called a puppy&lt;/code&gt;. The technique of specifying the trait name that we used in Listing 19-18 doesn&amp;rsquo;t help here; if we change &lt;code&gt;main&lt;/code&gt; to the code in Listing 19-20, we&amp;rsquo;ll get a compilation error.</source>
          <target state="translated">이 결과는 우리가 원하는 것이 아닙니다. 우리는 &lt;code&gt;Dog&lt;/code&gt; 에 구현 한 &lt;code&gt;Animal&lt;/code&gt; 특성의 일부인 &lt;code&gt;baby_name&lt;/code&gt; 함수 를 호출하여 코드를 인쇄 &lt;code&gt;A baby dog is called a puppy&lt;/code&gt; 합니다 . baby dog는 강아지라고합니다 . Listing 19-18에서 사용한 특성 이름을 지정하는 기술은 여기서 도움이되지 않습니다. Listing 19-20의 코드로 &lt;code&gt;main&lt;/code&gt; 을 변경 하면 컴파일 오류가 발생한다.</target>
        </trans-unit>
        <trans-unit id="66b4788ea5425d4692dd1ffafd058fec8508d60c" translate="yes" xml:space="preserve">
          <source>This output shows &lt;code&gt;cargo test&lt;/code&gt; only ran the tests for the &lt;code&gt;add-one&lt;/code&gt; crate and didn&amp;rsquo;t run the &lt;code&gt;adder&lt;/code&gt; crate tests.</source>
          <target state="translated">이 출력은 &lt;code&gt;cargo test&lt;/code&gt; 에서 &lt;code&gt;add-one&lt;/code&gt; 크레이트에 대한 테스트 만 실행했으며 &lt;code&gt;adder&lt;/code&gt; 크레이트 테스트 는 실행하지 않았 음을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="f91d4073e1806ac4e46d9be9407b7439ade530c5" translate="yes" xml:space="preserve">
          <source>This outputs:</source>
          <target state="translated">이 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="220a338b4d08066eba2a22fb127e73c40665ebcb" translate="yes" xml:space="preserve">
          <source>This overwrites pinned data, but that is okay: its destructor gets run before being overwritten, so no pinning guarantee is violated.</source>
          <target state="translated">이것은 고정 된 데이터를 덮어 쓰지만 괜찮습니다. 소멸자가 덮어 쓰기 전에 실행되므로 고정 보장이 위반되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05caefb888af241727a56b286e8ae483a7d9633f" translate="yes" xml:space="preserve">
          <source>This page documents the formal specification of the follow rules for &lt;a href=&quot;macros-by-example&quot;&gt;Macros By Example&lt;/a&gt;. They were originally specified in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.html&quot;&gt;RFC 550&lt;/a&gt;, from which the bulk of this text is copied, and expanded upon in subsequent RFCs.</source>
          <target state="translated">이 페이지는 &lt;a href=&quot;macros-by-example&quot;&gt;Macros By Example에&lt;/a&gt; 대한 다음 규칙의 공식 사양을 설명합니다 . 그것들은 원래 &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.html&quot;&gt;RFC 550에&lt;/a&gt; 지정되었으며 ,이 텍스트의 대부분이 복사되고 후속 RFC에서 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="f87b1d9607de86149c082e3d8de19453e0048df2" translate="yes" xml:space="preserve">
          <source>This pattern has a profound impact on the way Rust code is written. It may seem simple right now, but the behavior of code can be unexpected in more complicated situations when we want to have multiple variables use the data we&amp;rsquo;ve allocated on the heap. Let&amp;rsquo;s explore some of those situations now.</source>
          <target state="translated">이 패턴은 Rust 코드 작성 방식에 중대한 영향을 미칩니다. 지금은 단순 해 보일 수 있지만 더 복잡한 상황에서는 여러 변수가 힙에 할당 한 데이터를 사용하도록하려는 경우 코드 동작이 예상치 못한 것일 수 있습니다. 이러한 상황 중 일부를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="ebae1cd81adce77daea1f3e37e663633c554fab5" translate="yes" xml:space="preserve">
          <source>This pattern is about separating concerns: &lt;em&gt;main.rs&lt;/em&gt; handles running the program, and &lt;em&gt;lib.rs&lt;/em&gt; handles all the logic of the task at hand. Because you can&amp;rsquo;t test the &lt;code&gt;main&lt;/code&gt; function directly, this structure lets you test all of your program&amp;rsquo;s logic by moving it into functions in &lt;em&gt;lib.rs&lt;/em&gt;. The only code that remains in &lt;em&gt;main.rs&lt;/em&gt; will be small enough to verify its correctness by reading it. Let&amp;rsquo;s rework our program by following this process.</source>
          <target state="translated">이 패턴은 우려를 분리하는 것에 관한 것입니다 : &lt;em&gt;main.rs&lt;/em&gt; 는 프로그램 실행을 처리하고 &lt;em&gt;lib.rs&lt;/em&gt; 는 작업의 모든 논리를 처리합니다. 당신이 테스트 할 수 없기 때문에 &lt;code&gt;main&lt;/code&gt; 직접 기능을,이 구조는 당신이 함수로 이동하여 프로그램의 로직을 모두 테스트 할 수 있습니다 &lt;em&gt;lib.rs&lt;/em&gt; . &lt;em&gt;main.rs에&lt;/em&gt; 남아있는 유일한 코드는 코드를 읽고 정확성을 확인할 수있을 정도로 작습니다. 이 과정에 따라 프로그램을 재 작업하겠습니다.</target>
        </trans-unit>
        <trans-unit id="4f7fef1aec609824d9a98cbd4986f806fb8112f5" translate="yes" xml:space="preserve">
          <source>This pattern is refutable when one of its subpatterns is refutable.</source>
          <target state="translated">이 패턴은 하위 패턴 중 하나가 반박 가능한 경우 반박 가능합니다.</target>
        </trans-unit>
        <trans-unit id="8e7824ffc5e192a74a0014b97fd199a69a9bbad1" translate="yes" xml:space="preserve">
          <source>This pattern of propagating errors is so common in Rust that Rust provides the question mark operator &lt;code&gt;?&lt;/code&gt; to make this easier.</source>
          <target state="translated">이러한 전파 오류 패턴은 Rust에서 매우 일반적이므로 Rust는 물음표 연산자를 제공 &lt;code&gt;?&lt;/code&gt; 이것을 쉽게하기 위해.</target>
        </trans-unit>
        <trans-unit id="be8e420bedd2fafb3e2ace598d4c2a4fc61a219a" translate="yes" xml:space="preserve">
          <source>This performs complex unconditional mappings with no tailoring: it maps one Unicode character to its lowercase equivalent according to the &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt&quot;&gt;Unicode database&lt;/a&gt; and the additional complex mappings &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt&quot;&gt;&lt;code&gt;SpecialCasing.txt&lt;/code&gt;&lt;/a&gt;. Conditional mappings (based on context or language) are not considered here.</source>
          <target state="translated">이는 조정없이 복잡한 무조건 맵핑을 수행합니다. 이는 &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt&quot;&gt;유니 코드 데이터베이스&lt;/a&gt; 및 추가 복합 맵핑 &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt&quot;&gt; &lt;code&gt;SpecialCasing.txt&lt;/code&gt; &lt;/a&gt; 에 따라 하나의 유니 코드 문자를 소문자로 맵핑합니다 . 여기에서는 문맥 또는 언어를 기반으로하는 조건부 매핑을 고려하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2bedef26ecd391020afcece167562372d74e3b11" translate="yes" xml:space="preserve">
          <source>This performs complex unconditional mappings with no tailoring: it maps one Unicode character to its uppercase equivalent according to the &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt&quot;&gt;Unicode database&lt;/a&gt; and the additional complex mappings &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt&quot;&gt;&lt;code&gt;SpecialCasing.txt&lt;/code&gt;&lt;/a&gt;. Conditional mappings (based on context or language) are not considered here.</source>
          <target state="translated">이는 조정없이 복잡한 무조건 맵핑을 수행합니다. 이는 &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt&quot;&gt;유니 코드 데이터베이스&lt;/a&gt; 및 추가 복합 맵핑 &lt;a href=&quot;ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt&quot;&gt; &lt;code&gt;SpecialCasing.txt&lt;/code&gt; &lt;/a&gt; 에 따라 하나의 유니 코드 문자를 대문자로 맵핑합니다 . 여기에서는 문맥 또는 언어를 기반으로하는 조건부 매핑을 고려하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="367fd59cc7a5ce52d6910a709b90bfcbe81a7ab5" translate="yes" xml:space="preserve">
          <source>This piece of Rust history is relevant because it&amp;rsquo;s possible that more deterministic patterns will emerge and be added to the compiler. In the future, even fewer lifetime annotations might be required.</source>
          <target state="translated">이 Rust 히스토리는 더 결정적인 패턴이 나타나고 컴파일러에 추가 될 수 있기 때문에 관련이 있습니다. 앞으로는 더 적은 수명의 주석이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce7cedc5fc51216f120f0eb8fae3379dc963620e" translate="yes" xml:space="preserve">
          <source>This prints output like:</source>
          <target state="translated">다음과 같은 출력을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="ff9f7a5e1d4525cd7d8438461ac9c53da48b455e" translate="yes" xml:space="preserve">
          <source>This prints to &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)&quot;&gt;stderr&lt;/a&gt;:</source>
          <target state="translated">이것은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)&quot;&gt;stderr에&lt;/a&gt; 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="3c9f3b33a54ec1f8657331a04066cc462bed4e33" translate="yes" xml:space="preserve">
          <source>This problem can be solved by specifying from which trait we want to use the &lt;code&gt;Bar&lt;/code&gt; type:</source>
          <target state="translated">이 유형 은 &lt;code&gt;Bar&lt;/code&gt; 유형 을 사용하려는 특성을 지정하여 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc4e53a566f64cd7b3bd5c8e48b6dab0075560d7" translate="yes" xml:space="preserve">
          <source>This process does not take into account the mutability or lifetime of the receiver, or whether a method is &lt;code&gt;unsafe&lt;/code&gt;. Once a method is looked up, if it can't be called for one (or more) of those reasons, the result is a compiler error.</source>
          <target state="translated">이 프로세스는 수신자의 가변성 또는 수명 또는 메소드가 &lt;code&gt;unsafe&lt;/code&gt; 않은지 여부를 고려하지 않습니다 . 메소드를 찾은 후 이러한 이유 중 하나 이상으로 호출 할 수없는 경우 결과는 컴파일러 오류입니다.</target>
        </trans-unit>
        <trans-unit id="1ff3edc7107794fccb9370413ce9f2edb3d33555" translate="yes" xml:space="preserve">
          <source>This process is just one of many ways to write software, but TDD can help drive code design as well. Writing the test before you write the code that makes the test pass helps to maintain high test coverage throughout the process.</source>
          <target state="translated">이 프로세스는 소프트웨어를 작성하는 여러 가지 방법 중 하나 일 뿐이지 만 TDD는 코드 설계를 지원할 수 있습니다. 테스트를 통과시키는 코드를 작성하기 전에 테스트를 작성하면 프로세스 전체에서 높은 테스트 범위를 유지하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="2a5870cc6149419aa4b701948d1d720f8c2eb21c" translate="yes" xml:space="preserve">
          <source>This program compiles without any errors and would also do so if we used &lt;code&gt;word&lt;/code&gt; after calling &lt;code&gt;s.clear()&lt;/code&gt;. Because &lt;code&gt;word&lt;/code&gt; isn&amp;rsquo;t connected to the state of &lt;code&gt;s&lt;/code&gt; at all, &lt;code&gt;word&lt;/code&gt; still contains the value &lt;code&gt;5&lt;/code&gt;. We could use that value &lt;code&gt;5&lt;/code&gt; with the variable &lt;code&gt;s&lt;/code&gt; to try to extract the first word out, but this would be a bug because the contents of &lt;code&gt;s&lt;/code&gt; have changed since we saved &lt;code&gt;5&lt;/code&gt; in &lt;code&gt;word&lt;/code&gt;.</source>
          <target state="translated">이 프로그램은 오류없이 컴파일되며 &lt;code&gt;s.clear()&lt;/code&gt; 호출 한 후 &lt;code&gt;word&lt;/code&gt; 를 사용하면 컴파일됩니다 . 때문에 &lt;code&gt;word&lt;/code&gt; 의 상태에 연결되어 있지 &lt;code&gt;s&lt;/code&gt; 모든에서, &lt;code&gt;word&lt;/code&gt; 여전히 값 포함 &lt;code&gt;5&lt;/code&gt; . 우리는 그 값을 사용할 수 있습니다 &lt;code&gt;5&lt;/code&gt; 변수와 &lt;code&gt;s&lt;/code&gt; 첫 번째 단어를 추출하려고하지만, 내용 때문에 버그 것 &lt;code&gt;s&lt;/code&gt; 변경되었습니다 우리가 구원 이후 &lt;code&gt;5&lt;/code&gt; 에 &lt;code&gt;word&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1a216c5bb2240db271ccf5242339067640e2983" translate="yes" xml:space="preserve">
          <source>This program creates a tuple, &lt;code&gt;x&lt;/code&gt;, and then makes new variables for each element by using their index. As with most programming languages, the first index in a tuple is 0.</source>
          <target state="translated">이 프로그램은 튜플 &lt;code&gt;x&lt;/code&gt; 를 만든 다음 색인을 사용하여 각 요소에 대해 새 변수를 만듭니다. 대부분의 프로그래밍 언어와 마찬가지로 튜플의 첫 번째 인덱스는 0입니다.</target>
        </trans-unit>
        <trans-unit id="052f0899e565e8d2644e743be0e56bf26e6e1767" translate="yes" xml:space="preserve">
          <source>This program first binds &lt;code&gt;x&lt;/code&gt; to a value of &lt;code&gt;5&lt;/code&gt;. Then it shadows &lt;code&gt;x&lt;/code&gt; by repeating &lt;code&gt;let x =&lt;/code&gt;, taking the original value and adding &lt;code&gt;1&lt;/code&gt; so the value of &lt;code&gt;x&lt;/code&gt; is then &lt;code&gt;6&lt;/code&gt;. The third &lt;code&gt;let&lt;/code&gt; statement also shadows &lt;code&gt;x&lt;/code&gt;, multiplying the previous value by &lt;code&gt;2&lt;/code&gt; to give &lt;code&gt;x&lt;/code&gt; a final value of &lt;code&gt;12&lt;/code&gt;. When we run this program, it will output the following:</source>
          <target state="translated">이 프로그램은 먼저 &lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;5&lt;/code&gt; 값에 바인딩 합니다. 그런 다음 &lt;code&gt;let x =&lt;/code&gt; 를 반복 하여 원래 값을 취하고 &lt;code&gt;1&lt;/code&gt; 을 추가하여 &lt;code&gt;x&lt;/code&gt; 의 값이 &lt;code&gt;6&lt;/code&gt; 이 되도록하여 &lt;code&gt;x&lt;/code&gt; 를 음영 처리 합니다. 세 번째 &lt;code&gt;let&lt;/code&gt; 문은 &lt;code&gt;x&lt;/code&gt; 를 음영 처리 하여 이전 값에 &lt;code&gt;2&lt;/code&gt; 를 곱하여 &lt;code&gt;x&lt;/code&gt; 에 최종 값 &lt;code&gt;12&lt;/code&gt; 를 제공 합니다. 이 프로그램을 실행하면 다음이 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="e37eff19d0df592c13224ef2e32fd74387b55f9e" translate="yes" xml:space="preserve">
          <source>This program first creates a tuple and binds it to the variable &lt;code&gt;tup&lt;/code&gt;. It then uses a pattern with &lt;code&gt;let&lt;/code&gt; to take &lt;code&gt;tup&lt;/code&gt; and turn it into three separate variables, &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;. This is called &lt;em&gt;destructuring&lt;/em&gt;, because it breaks the single tuple into three parts. Finally, the program prints the value of &lt;code&gt;y&lt;/code&gt;, which is &lt;code&gt;6.4&lt;/code&gt;.</source>
          <target state="translated">이 프로그램은 먼저 튜플을 만들어 변수 &lt;code&gt;tup&lt;/code&gt; 에 바인딩합니다 . 그런 다음 &lt;code&gt;let&lt;/code&gt; 을 사용하여 &lt;code&gt;tup&lt;/code&gt; 패턴을 사용하여 세 개의 개별 변수 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 로 바꿉니다 . 이것은 단일 터플을 세 부분으로 나누기 때문에 &lt;em&gt;destructuring&lt;/em&gt; 이라고 합니다. 마지막으로,이 프로그램의 출력 값 &lt;code&gt;y&lt;/code&gt; 이며, &lt;code&gt;6.4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e68e59981686f4d6d9628e4a0f06c39a18431f20" translate="yes" xml:space="preserve">
          <source>This program has four possible paths it can take. After running it, you should see the following output:</source>
          <target state="translated">이 프로그램에는 가능한 4 가지 경로가 있습니다. 실행 한 후 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="c268368ea9194ea4e99d8e793596c3443d5a9397" translate="yes" xml:space="preserve">
          <source>This project was a hands-on way to introduce you to many new Rust concepts: &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;match&lt;/code&gt;, methods, associated functions, the use of external crates, and more. In the next few chapters, you&amp;rsquo;ll learn about these concepts in more detail. Chapter 3 covers concepts that most programming languages have, such as variables, data types, and functions, and shows how to use them in Rust. Chapter 4 explores ownership, a feature that makes Rust different from other languages. Chapter 5 discusses structs and method syntax, and Chapter 6 explains how enums work.</source>
          <target state="translated">이 프로젝트는 &lt;code&gt;let&lt;/code&gt; , &lt;code&gt;match&lt;/code&gt; , 메소드, 관련 함수, 외부 상자 사용 등과 같은 많은 새로운 Rust 개념을 소개하는 실제 방법이었습니다. 다음 몇 장에서는 이러한 개념에 대해 자세히 설명합니다. 3 장에서는 변수, 데이터 유형 및 함수와 같은 대부분의 프로그래밍 언어가 갖고있는 개념을 다루고 Rust에서이를 사용하는 방법을 보여줍니다. 4 장에서는 Rust를 다른 언어와 차별화하는 기능인 소유권에 대해 설명합니다. 5 장에서는 구조체와 메서드 구문에 대해 설명하고 6 장에서는 열거 형 작동 방식에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ab41f4f49ac9b596f3ff341e670c3c513d2c2a1e" translate="yes" xml:space="preserve">
          <source>This property cannot be checked by the compiler, and therefore &lt;code&gt;Eq&lt;/code&gt; implies &lt;code&gt;PartialEq&lt;/code&gt;, and has no extra methods.</source>
          <target state="translated">이 속성은 컴파일러에서 확인할 수 없으므로 &lt;code&gt;Eq&lt;/code&gt; 는 &lt;code&gt;PartialEq&lt;/code&gt; 를 암시 하며 추가 메서드는 없습니다.</target>
        </trans-unit>
        <trans-unit id="1608442363fd58986072b46f4e6a650827d3385c" translate="yes" xml:space="preserve">
          <source>This property is defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc1122&quot;&gt;IETF RFC 1122&lt;/a&gt;.</source>
          <target state="translated">이 속성은 &lt;a href=&quot;https://tools.ietf.org/html/rfc1122&quot;&gt;IETF RFC 1122에&lt;/a&gt; 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="25a4736ccf9a4ba3c3e3dac30177800bc1f743c9" translate="yes" xml:space="preserve">
          <source>This property is defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc3927&quot;&gt;IETF RFC 3927&lt;/a&gt;.</source>
          <target state="translated">이 속성은 &lt;a href=&quot;https://tools.ietf.org/html/rfc3927&quot;&gt;IETF RFC 3927에&lt;/a&gt; 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="2cdf66b6082611e25a822825249d22e6f28f1917" translate="yes" xml:space="preserve">
          <source>This property is defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt;.</source>
          <target state="translated">이 특성은 &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291에&lt;/a&gt; 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="93af0d07e68cafd035375823424d1e725ddb07d1" translate="yes" xml:space="preserve">
          <source>This property is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3849&quot;&gt;IETF RFC 3849&lt;/a&gt;.</source>
          <target state="translated">이 속성은 &lt;a href=&quot;https://tools.ietf.org/html/rfc3849&quot;&gt;IETF RFC 3849에&lt;/a&gt; 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="85df454e96ffa6c63ed8ab37d8086b690c9dba86" translate="yes" xml:space="preserve">
          <source>This property is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4193&quot;&gt;IETF RFC 4193&lt;/a&gt;.</source>
          <target state="translated">이 속성은 &lt;a href=&quot;https://tools.ietf.org/html/rfc4193&quot;&gt;IETF RFC 4193에&lt;/a&gt; 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d5a4dec1164aed352e96ad9af690b1a3591dc76" translate="yes" xml:space="preserve">
          <source>This property is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt;.</source>
          <target state="translated">이 속성은 &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291에&lt;/a&gt; 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c731a3c6e670f4842c76f756fa1e0f4c4f1cfae6" translate="yes" xml:space="preserve">
          <source>This property is defined in &lt;em&gt;UNIX Network Programming, Second Edition&lt;/em&gt;, W. Richard Stevens, p. 891; see also &lt;a href=&quot;http://man7.org/linux/man-pages/man7/ip.7.html&quot;&gt;ip7&lt;/a&gt;.</source>
          <target state="translated">이 속성은 &lt;em&gt;UNIX 네트워크 프로그래밍, 제 2 판&lt;/em&gt; , W. Richard Stevens, p. 891; &lt;a href=&quot;http://man7.org/linux/man-pages/man7/ip.7.html&quot;&gt;ip7&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="19926d7df32802514fef095810b287a92fa4b874" translate="yes" xml:space="preserve">
          <source>This queue has &lt;code&gt;O(1)&lt;/code&gt; amortized inserts and removals from both ends of the container. It also has &lt;code&gt;O(1)&lt;/code&gt; indexing like a vector. The contained elements are not required to be copyable, and the queue will be sendable if the contained type is sendable.</source>
          <target state="translated">이 대기열에는 컨테이너의 양쪽 끝에서 &lt;code&gt;O(1)&lt;/code&gt; 상각 삽입 및 제거가 있습니다. 또한 벡터처럼 &lt;code&gt;O(1)&lt;/code&gt; 인덱싱이 있습니다. 포함 된 요소는 복사 할 필요가 없으며 포함 된 유형을 보낼 수있는 경우 큐를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae16a9ff1b9b0bb4dc2773f7faab160bd7347257" translate="yes" xml:space="preserve">
          <source>This reader has reached its &quot;end of file&quot; and will likely no longer be able to produce bytes. Note that this does not mean that the reader will &lt;em&gt;always&lt;/em&gt; no longer be able to produce bytes.</source>
          <target state="translated">이 독자는 &quot;파일 끝&quot;에 도달하여 더 이상 바이트를 생성 할 수 없습니다. 참고이 독자는 것을 의미하지 않는다는 것을 &lt;em&gt;항상&lt;/em&gt; 더 이상 바이트를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eabbe1cac74b5970cf00777c8a04a9b08b503051" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt; using the comparator function. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;code&gt;O(n)&lt;/code&gt; worst-case. This function is also known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index, using the provided comparator function.</source>
          <target state="translated">이 재정렬에는 비교 함수를 사용하여 위치 &lt;code&gt;i &amp;lt; index&lt;/code&gt; 모든 값이 위치 &lt;code&gt;j &amp;gt; index&lt;/code&gt; 임의의 값보다 작거나 같다는 추가 특성 이 있습니다 . 또한,이 재정렬은 불안정합니다 (즉, 동일한 수의 동일한 요소가 위치 &lt;code&gt;index&lt;/code&gt; 에서 끝날 수 있음 ), 적절한 위치 (즉, 할당되지 않음) 및 &lt;code&gt;O(n)&lt;/code&gt; 최악의 경우. 이 기능은 다른 라이브러리에서 &quot;kth element&quot;라고도합니다. 제공된 비교기 함수를 사용하여 지정된 색인의 값보다 작은 모든 요소, 지정된 색인의 값 및 주어진 색인의 값보다 큰 모든 요소의 트리플렛을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="58333e6fd2204efb6d059b5e0ebaa3ad2ae11cea" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt; using the key extraction function. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;code&gt;O(n)&lt;/code&gt; worst-case. This function is also known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index, using the provided key extraction function.</source>
          <target state="translated">이 재정렬에는 키 추출 기능을 사용하여 위치 &lt;code&gt;i &amp;lt; index&lt;/code&gt; 모든 값이 위치 &lt;code&gt;j &amp;gt; index&lt;/code&gt; 임의의 값보다 작거나 같은 추가 속성 이 있습니다 . 또한,이 재정렬은 불안정합니다 (즉, 동일한 수의 동일한 요소가 위치 &lt;code&gt;index&lt;/code&gt; 에서 끝날 수 있음 ), 적절한 위치 (즉, 할당되지 않음) 및 &lt;code&gt;O(n)&lt;/code&gt; 최악의 경우. 이 기능은 다른 라이브러리에서 &quot;kth element&quot;라고도합니다. 제공된 키 추출 함수를 사용하여 지정된 색인의 값보다 작은 모든 요소, 지정된 색인의 값 및 주어진 색인의 값보다 큰 모든 요소의 트리플렛을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="18b0ecb2451beab6446b7792a5f32ac5b93e64f7" translate="yes" xml:space="preserve">
          <source>This reordering has the additional property that any value at position &lt;code&gt;i &amp;lt; index&lt;/code&gt; will be less than or equal to any value at a position &lt;code&gt;j &amp;gt; index&lt;/code&gt;. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position &lt;code&gt;index&lt;/code&gt;), in-place (i.e. does not allocate), and &lt;code&gt;O(n)&lt;/code&gt; worst-case. This function is also/ known as &quot;kth element&quot; in other libraries. It returns a triplet of the following values: all elements less than the one at the given index, the value at the given index, and all elements greater than the one at the given index.</source>
          <target state="translated">이 재정렬에는 위치 &lt;code&gt;i &amp;lt; index&lt;/code&gt; 값이 위치 &lt;code&gt;j &amp;gt; index&lt;/code&gt; 값보다 작거나 같은 추가 속성 이 있습니다 . 또한,이 재정렬은 불안정합니다 (즉, 동일한 수의 동일한 요소가 위치 &lt;code&gt;index&lt;/code&gt; 에서 끝날 수 있음 ), 적절한 위치 (즉, 할당되지 않음) 및 &lt;code&gt;O(n)&lt;/code&gt; 최악의 경우. 이 기능은 다른 라이브러리에서 &quot;kth element&quot;라고도합니다. 지정된 인덱스의 값보다 작은 모든 요소, 지정된 인덱스의 값 및 지정된 인덱스의 값보다 큰 모든 요소의 트리플렛을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6a44d46360998129b78ed15d687f727979c543e5" translate="yes" xml:space="preserve">
          <source>This representation can be applied to structs, unions, and enums.</source>
          <target state="translated">이 표현은 구조체, 공용체 및 열거 형에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54d003da75e5c18c6d78ec752d4c5ea2c1005e03" translate="yes" xml:space="preserve">
          <source>This requires that the data inside this &lt;code&gt;Pin&lt;/code&gt; is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; so that we can ignore the pinning invariants when unwrapping it.</source>
          <target state="translated">&lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; 위해서는이 &lt;code&gt;Pin&lt;/code&gt; 내부의 데이터 가 언핀 이어야합니다.</target>
        </trans-unit>
        <trans-unit id="84a024e08861a138f89bc49f72665722f5345893" translate="yes" xml:space="preserve">
          <source>This requires that the data inside this &lt;code&gt;Pin&lt;/code&gt; is &lt;code&gt;Unpin&lt;/code&gt;.</source>
          <target state="translated">이를 위해서는이 &lt;code&gt;Pin&lt;/code&gt; 내부의 데이터 가 &lt;code&gt;Unpin&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="bb8049ba5b3a969809828fb6b20b4c6f803c243a" translate="yes" xml:space="preserve">
          <source>This restriction allows for mutation but in a very controlled fashion. It&amp;rsquo;s something that new Rustaceans struggle with, because most languages let you mutate whenever you&amp;rsquo;d like.</source>
          <target state="translated">이 제한은 돌연변이를 허용하지만 매우 통제 된 방식으로 이루어집니다. 대부분의 언어로 원할 때마다 변경할 수 있기 때문에 새로운 Rustaceans가 어려움을 겪고 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9005ee922bd85c1b8cdd5bf9e647bc71bc7e1d1" translate="yes" xml:space="preserve">
          <source>This restricts us to a &lt;code&gt;Screen&lt;/code&gt; instance that has a list of components all of type &lt;code&gt;Button&lt;/code&gt; or all of type &lt;code&gt;TextField&lt;/code&gt;. If you&amp;rsquo;ll only ever have homogeneous collections, using generics and trait bounds is preferable because the definitions will be monomorphized at compile time to use the concrete types.</source>
          <target state="translated">이렇게하면 &lt;code&gt;Button&lt;/code&gt; 유형 또는 &lt;code&gt;TextField&lt;/code&gt; 유형의 구성 요소 목록이 있는 &lt;code&gt;Screen&lt;/code&gt; 인스턴스로 제한 됩니다. 동종 컬렉션 만있는 경우에는 정의가 콘크리트 유형을 사용하기 위해 컴파일 타임에 단일화되므로 제네릭 및 특성 경계를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fef61557094c53c94d8f4b9c87d239c1c4ddf6a3" translate="yes" xml:space="preserve">
          <source>This result just indicates that the assertion failed and which line the assertion is on. A more useful failure message in this case would print the value we got from the &lt;code&gt;greeting&lt;/code&gt; function. Let&amp;rsquo;s change the test function, giving it a custom failure message made from a format string with a placeholder filled in with the actual value we got from the &lt;code&gt;greeting&lt;/code&gt; function:</source>
          <target state="translated">이 결과는 어설 션이 실패했으며 어설 션이 어느 행에 있는지 나타냅니다. 이 경우 더 유용한 실패 메시지는 &lt;code&gt;greeting&lt;/code&gt; 기능 에서 얻은 값을 인쇄합니다 . 테스트 함수를 변경하여 &lt;code&gt;greeting&lt;/code&gt; 함수 에서 얻은 실제 값으로 자리 표시자가 채워진 형식 문자열로 작성된 사용자 지정 실패 메시지를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="0886cd5bf439fbbc8be3535b3d5401de7c87877b" translate="yes" xml:space="preserve">
          <source>This return type means the call to &lt;code&gt;File::open&lt;/code&gt; might succeed and return a file handle that we can read from or write to. The function call also might fail: for example, the file might not exist, or we might not have permission to access the file. The &lt;code&gt;File::open&lt;/code&gt; function needs to have a way to tell us whether it succeeded or failed and at the same time give us either the file handle or error information. This information is exactly what the &lt;code&gt;Result&lt;/code&gt; enum conveys.</source>
          <target state="translated">이 반환 유형은 &lt;code&gt;File::open&lt;/code&gt; 대한 호출 이 성공하고 읽거나 쓸 수있는 파일 핸들을 반환 할 수 있음을 의미합니다 . 함수 호출도 실패 할 수 있습니다. 예를 들어 파일이 없거나 파일에 액세스 할 수있는 권한이 없을 수 있습니다. &lt;code&gt;File::open&lt;/code&gt; 기능 요구는 성공 또는 실패와 동시에 우리에게 파일 핸들 또는 오류 정보 중 하나를 제공하는지 여부를 알려 수있는 방법이 있습니다. 이 정보는 &lt;code&gt;Result&lt;/code&gt; 열거 형이 전달 하는 것과 정확히 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="368beec57f1181b8799a91ee73ada8b4184da78e" translate="yes" xml:space="preserve">
          <source>This reuses all the nodes from &lt;code&gt;other&lt;/code&gt; and moves them into &lt;code&gt;self&lt;/code&gt;. After this operation, &lt;code&gt;other&lt;/code&gt; becomes empty.</source>
          <target state="translated">이것은 &lt;code&gt;other&lt;/code&gt; 노드의 모든 노드를 재사용하고 &lt;code&gt;self&lt;/code&gt; 로 옮깁니다 . 이 작업 후에 &lt;code&gt;other&lt;/code&gt; 은 비게됩니다.</target>
        </trans-unit>
        <trans-unit id="7730271090bac7f074841851b1b821f9fc7fca43" translate="yes" xml:space="preserve">
          <source>This rework may seem like overkill for our small program, but we&amp;rsquo;re refactoring in small, incremental steps. After making this change, run the program again to verify that the argument parsing still works. It&amp;rsquo;s good to check your progress often, to help identify the cause of problems when they occur.</source>
          <target state="translated">이 재 작업은 우리의 작은 프로그램에 대해 과도한 것처럼 보일 수 있지만, 우리는 작은 단계적으로 리팩토링하고 있습니다. 이 변경을 수행 한 후 프로그램을 다시 실행하여 인수 구문 분석이 여전히 작동하는지 확인하십시오. 문제가 발생할 때 원인을 식별하는 데 도움이되도록 진행 상황을 자주 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c68a9d1019f31cc86d07a97f90c903ea86167b11" translate="yes" xml:space="preserve">
          <source>This rule also applies to type parameters of impl blocks that contain const methods</source>
          <target state="translated">이 규칙은 const 메소드를 포함하는 impl 블록의 유형 매개 변수에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c9e400474c407c09b7fb37164368bcd30fbe8830" translate="yes" xml:space="preserve">
          <source>This runs the code in &lt;em&gt;adder/src/main.rs&lt;/em&gt;, which depends on the &lt;code&gt;add-one&lt;/code&gt; crate.</source>
          <target state="translated">이 코드는 &lt;em&gt;adder / src / main.rs&lt;/em&gt; 코드를 실행하며 &lt;code&gt;add-one&lt;/code&gt; 상자 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="e6b2224800e73c42ee25267c2896a776ab41e710" translate="yes" xml:space="preserve">
          <source>This section documents features that affect the ABI of the compiled output of a crate.</source>
          <target state="translated">이 섹션에서는 상자의 컴파일 된 출력의 ABI에 영향을주는 기능에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7dc2765b02ef149354a7a9ee16a696edf0827240" translate="yes" xml:space="preserve">
          <source>This section documents features that define some aspects of the Rust runtime.</source>
          <target state="translated">이 섹션에서는 Rust 런타임의 일부 측면을 정의하는 기능에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f7c12226b9e0c0ca24fa6bdd6239b023bf8ef3a4" translate="yes" xml:space="preserve">
          <source>This should only ever be called with a pointer that was earlier obtained by calling &lt;a href=&quot;#method.into_raw&quot;&gt;&lt;code&gt;into_raw&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;CString&lt;/code&gt;. Other usage (e.g., trying to take ownership of a string that was allocated by foreign code) is likely to lead to undefined behavior or allocator corruption.</source>
          <target state="translated">&lt;code&gt;CString&lt;/code&gt; 에서&lt;a href=&quot;#method.into_raw&quot;&gt; &lt;code&gt;into_raw&lt;/code&gt; &lt;/a&gt; 를 호출하여 이전에 얻은 포인터로만 호출해야합니다 . 다른 사용법 (예 : 외래 코드에 의해 할당 된 문자열의 소유권을 얻으려고 시도)은 정의되지 않은 동작 또는 할당 자 손상을 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6de4781e84fd1ffb8326c915806ff4604cbf7406" translate="yes" xml:space="preserve">
          <source>This shows the source code file with the &lt;em&gt;.rs&lt;/em&gt; extension, the executable file (&lt;em&gt;main.exe&lt;/em&gt; on Windows, but &lt;em&gt;main&lt;/em&gt; on all other platforms), and, when using Windows, a file containing debugging information with the &lt;em&gt;.pdb&lt;/em&gt; extension. From here, you run the &lt;em&gt;main&lt;/em&gt; or &lt;em&gt;main.exe&lt;/em&gt; file, like this:</source>
          <target state="translated">확장명 이 &lt;em&gt;.rs 인&lt;/em&gt; 소스 코드 파일 , 실행 파일 ( Windows에서는 &lt;em&gt;main.exe&lt;/em&gt; , 다른 모든 플랫폼 에서는 &lt;em&gt;main&lt;/em&gt; ) 및 Windows를 사용할 경우 확장자 가 &lt;em&gt;.pdb 인&lt;/em&gt; 디버깅 정보가 들어있는 파일이 표시 됩니다. 여기에서 &lt;em&gt;main&lt;/em&gt; 또는 &lt;em&gt;main.exe&lt;/em&gt; 파일을 다음과 같이 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="9575f8046ce99c60fbe347fdb162c3debc44c697" translate="yes" xml:space="preserve">
          <source>This slice has the type &lt;code&gt;&amp;amp;[i32]&lt;/code&gt;. It works the same way as string slices do, by storing a reference to the first element and a length. You&amp;rsquo;ll use this kind of slice for all sorts of other collections. We&amp;rsquo;ll discuss these collections in detail when we talk about vectors in Chapter 8.</source>
          <target state="translated">이 슬라이스는 &lt;code&gt;&amp;amp;[i32]&lt;/code&gt; 유형 입니다. 첫 번째 요소에 대한 참조와 길이를 저장하여 문자열 슬라이스와 같은 방식으로 작동합니다. 모든 종류의 다른 컬렉션에이 종류의 슬라이스를 사용합니다. 8 장에서 벡터에 대해 이야기 할 때 이러한 컬렉션에 대해 자세히 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="b3fe498c20a11bda205dc93f4390f850884c310c" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(m n + n log n)&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="translated">이 정렬은 안정적이며 (즉, 동일한 요소를 재정렬하지 않음) &lt;code&gt;O(m n + n log n)&lt;/code&gt; 최악의 경우 키 함수는 &lt;code&gt;O(m)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="04ff5f9e434224075f07c47221408f586ed69430" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(m n log(m n))&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="translated">이 정렬은 안정적이며 (즉, 동일한 요소를 재정렬하지 않음) &lt;code&gt;O(m n log(m n))&lt;/code&gt; 최악의 경우 키 함수는 &lt;code&gt;O(m)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="29bb618262e9818d4542507320a836e4faf4b56f" translate="yes" xml:space="preserve">
          <source>This sort is stable (i.e., does not reorder equal elements) and &lt;code&gt;O(n log n)&lt;/code&gt; worst-case.</source>
          <target state="translated">이 정렬은 안정적이며 (즉, 동일한 요소를 재정렬하지 않음) &lt;code&gt;O(n log n)&lt;/code&gt; 최악의 경우입니다.</target>
        </trans-unit>
        <trans-unit id="f8094b9acbcdfe817a2beca8fbbfd03d36adf019" translate="yes" xml:space="preserve">
          <source>This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and &lt;code&gt;O(m n log(m n))&lt;/code&gt; worst-case, where the key function is &lt;code&gt;O(m)&lt;/code&gt;.</source>
          <target state="translated">이런 종류의 (즉, 동일한 요소의 순서를 변경 할 수 있습니다)에 장소 (즉, 할당하지 않습니다) 불안정하고, &lt;code&gt;O(m n log(m n))&lt;/code&gt; 의 핵심 기능은 최악의 경우, &lt;code&gt;O(m)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e852a79da20e649bf213cb6826ee95c589ae984" translate="yes" xml:space="preserve">
          <source>This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and &lt;code&gt;O(n log n)&lt;/code&gt; worst-case.</source>
          <target state="translated">이 정렬은 불안정하며 (즉, 동일한 요소를 재정렬 할 수 있음), 내부 (즉, 할당하지 않음) 및 &lt;code&gt;O(n log n)&lt;/code&gt; 최악의 경우입니다.</target>
        </trans-unit>
        <trans-unit id="7b9136d07194a4e8e43750309da02e688255bd47" translate="yes" xml:space="preserve">
          <source>This sort of behavior has been known to &lt;a href=&quot;https://securityvulns.com/Wdocument183.html&quot;&gt;lead to privilege escalation&lt;/a&gt; when used incorrectly.</source>
          <target state="translated">이러한 종류의 동작은 잘못 사용될 경우 &lt;a href=&quot;https://securityvulns.com/Wdocument183.html&quot;&gt;권한 상승&lt;/a&gt; 으로 이어지는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="4609a563600ff8952232a98685a394486b72fb56" translate="yes" xml:space="preserve">
          <source>This state indicates that a generator has been suspended, and typically corresponds to a &lt;code&gt;yield&lt;/code&gt; statement. The value provided in this variant corresponds to the expression passed to &lt;code&gt;yield&lt;/code&gt; and allows generators to provide a value each time they yield.</source>
          <target state="translated">이 상태는 생성기가 일시 중지되었음을 나타내며 일반적으로 &lt;code&gt;yield&lt;/code&gt; 문에 해당 합니다. 이 변형에 제공된 값은 &lt;code&gt;yield&lt;/code&gt; 전달 된 표현에 해당하며 생성자가 생성 할 때마다 값을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90c88a5ca708244c3219f050c7309e58bf365755" translate="yes" xml:space="preserve">
          <source>This state indicates that a generator has finished execution with the provided value. Once a generator has returned &lt;code&gt;Complete&lt;/code&gt; it is considered a programmer error to call &lt;code&gt;resume&lt;/code&gt; again.</source>
          <target state="translated">이 상태는 생성기가 제공된 값으로 실행을 완료했음을 나타냅니다. 생성기가 &lt;code&gt;Complete&lt;/code&gt; 를 반환하면 다시 &lt;code&gt;resume&lt;/code&gt; 다시 호출하는 프로그래머 오류로 간주 됩니다.</target>
        </trans-unit>
        <trans-unit id="7be578f8354e75e786ae7f8a72194e570efdeae6" translate="yes" xml:space="preserve">
          <source>This stream will be ignored. This is the equivalent of attaching the stream to &lt;code&gt;/dev/null&lt;/code&gt;</source>
          <target state="translated">이 스트림은 무시됩니다. 이것은 스트림을 &lt;code&gt;/dev/null&lt;/code&gt; 에 첨부하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="047e86b07f343619951ab342d709e9864cc54c3d" translate="yes" xml:space="preserve">
          <source>This struct has one field, &lt;code&gt;part&lt;/code&gt;, that holds a string slice, which is a reference. As with generic data types, we declare the name of the generic lifetime parameter inside angle brackets after the name of the struct so we can use the lifetime parameter in the body of the struct definition. This annotation means an instance of &lt;code&gt;ImportantExcerpt&lt;/code&gt; can&amp;rsquo;t outlive the reference it holds in its &lt;code&gt;part&lt;/code&gt; field.</source>
          <target state="translated">이 구조체에는 문자열 슬라이스를 보유하는 하나의 필드 &lt;code&gt;part&lt;/code&gt; 가 있으며 이는 참조입니다. 일반 데이터 유형과 마찬가지로 구조체 이름 뒤에 꺾쇠 괄호 안에 일반 수명 매개 변수의 이름을 선언하므로 구조체 정의 본문에서 수명 매개 변수를 사용할 수 있습니다. 이 주석은 &lt;code&gt;ImportantExcerpt&lt;/code&gt; 인스턴스가 &lt;code&gt;part&lt;/code&gt; 필드 에서 보유한 참조보다 오래 지속될 수 없음을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="035a190c93ffcb98a162f4a1c124850fba76f70b" translate="yes" xml:space="preserve">
          <source>This struct has the same layout as types like &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; and &lt;code&gt;Box&amp;lt;dyn AnotherTrait&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 구조체는 &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; 및 &lt;code&gt;Box&amp;lt;dyn AnotherTrait&amp;gt;&lt;/code&gt; 와 같은 형식과 레이아웃이 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="698bb1f1506a6aa8b90b6f64dc7e32c0c5091a12" translate="yes" xml:space="preserve">
          <source>This struct is a helper to be used with functions like &lt;code&gt;Vec::sort_by_key&lt;/code&gt; and can be used to reverse order a part of a key.</source>
          <target state="translated">이 구조체는 &lt;code&gt;Vec::sort_by_key&lt;/code&gt; 와 같은 함수와 함께 사용할 수있는 도우미 이며 키의 일부를 역순으로 만드는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b94fdb25d3a1999fbb00df483466c3f3ad93974" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../iter/trait.intoiterator#tymethod.into_iter&quot;&gt;&lt;code&gt;into_iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; (provided by the &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; trait).</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt; 특성에 의해 제공되는 &lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../iter/trait.intoiterator#tymethod.into_iter&quot;&gt; &lt;code&gt;into_iter&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="1dd8330957d499a2a2bc9ec6116864588108859d" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.chunks&quot;&gt;&lt;code&gt;chunks&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.chunks&quot;&gt; &lt;code&gt;chunks&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="4f546acf131aa1e22a602b9ef3fb82d4387eee8e" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.chunks_exact&quot;&gt;&lt;code&gt;chunks_exact&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.chunks_exact&quot;&gt; &lt;code&gt;chunks_exact&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="e45db796c91b4ce48eb20085844caa57f6053703" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.chunks_exact_mut&quot;&gt;&lt;code&gt;chunks_exact_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.chunks_exact_mut&quot;&gt; &lt;code&gt;chunks_exact_mut&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="4164f449a467d7ed1b48f5a88a1f8a74fb26a190" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.chunks_mut&quot;&gt;&lt;code&gt;chunks_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.chunks_mut&quot;&gt; &lt;code&gt;chunks_mut&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="76b48770dc5ec192ca6962e1d7faa3bd68e942ab" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="7681a887be4ac8a42d7f0ef28706aee3c6323619" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.iter_mut&quot;&gt;&lt;code&gt;iter_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.iter_mut&quot;&gt; &lt;code&gt;iter_mut&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="523facc9e10029a951175d54b1f37f2671749ed6" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rchunks&quot;&gt;&lt;code&gt;rchunks&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.rchunks&quot;&gt; &lt;code&gt;rchunks&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="7743c6e4ca6fc913a9f4d37b6de12a320056fa8b" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rchunks_exact&quot;&gt;&lt;code&gt;rchunks_exact&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.rchunks_exact&quot;&gt; &lt;code&gt;rchunks_exact&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="82404af50a38a848751818c48976a9a56b795818" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rchunks_exact_mut&quot;&gt;&lt;code&gt;rchunks_exact_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.rchunks_exact_mut&quot;&gt; &lt;code&gt;rchunks_exact_mut&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="711c0f689f1d3a75f7b5a1b1833bc925f8986127" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rchunks_mut&quot;&gt;&lt;code&gt;rchunks_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.rchunks_mut&quot;&gt; &lt;code&gt;rchunks_mut&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="5ffea197c31595a869becf274e9c9ef3509b405a" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.rsplit&quot;&gt; &lt;code&gt;rsplit&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="a28e12c215b6246a69d2f856da858d720de99619" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rsplit_mut&quot;&gt;&lt;code&gt;rsplit_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.rsplit_mut&quot;&gt; &lt;code&gt;rsplit_mut&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="e1ddb16a3352ab0f837d4fac934c98e22db158e5" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.rsplitn&quot;&gt; &lt;code&gt;rsplitn&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="2305be064f2e36144fd442bf726fd4dd5a160216" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.rsplitn_mut&quot;&gt;&lt;code&gt;rsplitn_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.rsplitn_mut&quot;&gt; &lt;code&gt;rsplitn_mut&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="9d2c4405dee882e98a94c3681ae8ce615cfcc3f7" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.split&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.split&quot;&gt; &lt;code&gt;split&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="abdc8d3421db5241b7ca4544a7b51d6159d67e49" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.split_mut&quot;&gt;&lt;code&gt;split_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.split_mut&quot;&gt; &lt;code&gt;split_mut&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="b850789ebec6b616db674ca7582ef014921e3e50" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.splitn&quot;&gt;&lt;code&gt;splitn&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.splitn&quot;&gt; &lt;code&gt;splitn&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="fcbac1aabe82a2c466b31106e57bd4691b6a4588" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.splitn_mut&quot;&gt;&lt;code&gt;splitn_mut&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.splitn_mut&quot;&gt; &lt;code&gt;splitn_mut&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="4faa0b9911c89c4588e753ca1891a11cb9aac5c2" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.slice#method.windows&quot;&gt;&lt;code&gt;windows&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.slice&quot;&gt;slices&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.slice&quot;&gt;슬라이스&lt;/a&gt; 의 &lt;a href=&quot;../primitive.slice#method.windows&quot;&gt; &lt;code&gt;windows&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="972c0f2531dd3e046ad902a7f6f569ef9de9571e" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../primitive.str#method.bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9dc716c653425077e3bf50725d3ddc775e25fe94" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.char_indices&quot;&gt;&lt;code&gt;char_indices&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../primitive.str#method.char_indices&quot;&gt; &lt;code&gt;char_indices&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="607ded9325aedcb5c140c227e32c8ad28d5439d9" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.chars&quot;&gt;&lt;code&gt;chars&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../primitive.str#method.chars&quot;&gt; &lt;code&gt;chars&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="eb31472d0cae7541e173fe527a7087a142820c04" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.encode_utf16&quot;&gt;&lt;code&gt;encode_utf16&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../primitive.str#method.encode_utf16&quot;&gt; &lt;code&gt;encode_utf16&lt;/code&gt; &lt;/a&gt; 메소드로 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e7c273a10bb61ef5da70d27b34dc57f12929254d" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.split_ascii_whitespace&quot;&gt;&lt;code&gt;split_ascii_whitespace&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../primitive.str#method.split_ascii_whitespace&quot;&gt; &lt;code&gt;split_ascii_whitespace&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e335f4d066241eacb01d34cbc9797fdfc696dc6b" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;../primitive.str#method.split_whitespace&quot;&gt;&lt;code&gt;split_whitespace&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../primitive.str#method.split_whitespace&quot;&gt; &lt;code&gt;split_whitespace&lt;/code&gt; &lt;/a&gt; 메소드로 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f9cd50ffb5bf76be59d59fc2f81ddf738ff0464b" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;fn.args&quot;&gt;&lt;code&gt;std::env::args&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;fn.args&quot;&gt; &lt;code&gt;std::env::args&lt;/code&gt; &lt;/a&gt; 함수에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0ec39f7b0daa2776e166f7fac0653e5c7c5e4333" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;fn.args_os&quot;&gt;&lt;code&gt;std::env::args_os&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;fn.args_os&quot;&gt; &lt;code&gt;std::env::args_os&lt;/code&gt; &lt;/a&gt; 함수에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d49df01529faa1803ee9ac5934efa956bfb59ca5" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;struct.string#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.string#method.drain&quot;&gt; &lt;code&gt;drain&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7821d89ece3dc45805333802521c4ece28a6ec77" translate="yes" xml:space="preserve">
          <source>This struct is created by the &lt;a href=&quot;struct.vec#method.splice&quot;&gt;&lt;code&gt;splice()&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.vec#method.splice&quot;&gt; &lt;code&gt;splice()&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="df074a53b5359b4dd926d5ab8c21cb3fdb8391e4" translate="yes" xml:space="preserve">
          <source>This struct is created with the &lt;a href=&quot;../primitive.str#method.lines&quot;&gt;&lt;code&gt;lines&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. See its documentation for more.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../primitive.str#method.lines&quot;&gt; &lt;code&gt;lines&lt;/code&gt; &lt;/a&gt; 메소드로 생성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8df7525ac9b1331bb51b51ca2c5df8a11c0a1c0e" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty&lt;/code&gt;&lt;/a&gt;. Please see the documentation of &lt;a href=&quot;fn.empty&quot;&gt;&lt;code&gt;empty()&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">이 구조체는 일반적으로 &lt;a href=&quot;fn.empty&quot;&gt; &lt;code&gt;empty&lt;/code&gt; &lt;/a&gt; 호출하여 생성됩니다 . 자세한 내용은 &lt;a href=&quot;fn.empty&quot;&gt; &lt;code&gt;empty()&lt;/code&gt; &lt;/a&gt; 설명서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4d0cc773f4b725ed1f190beeb33e3f1817949265" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt;. Please see the documentation of &lt;code&gt;repeat()&lt;/code&gt; for more details.</source>
          <target state="translated">이 구조체는 일반적으로 &lt;a href=&quot;fn.repeat&quot;&gt; &lt;code&gt;repeat&lt;/code&gt; &lt;/a&gt; 호출을 통해 생성됩니다 . 자세한 내용은 &lt;code&gt;repeat()&lt;/code&gt; 설명서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dc05dce26bdc09f8fc488132c92d5215b0e0bb48" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;fn.sink&quot;&gt;&lt;code&gt;sink&lt;/code&gt;&lt;/a&gt;. Please see the documentation of &lt;code&gt;sink()&lt;/code&gt; for more details.</source>
          <target state="translated">이 구조체는 일반적으로 &lt;a href=&quot;fn.sink&quot;&gt; &lt;code&gt;sink&lt;/code&gt; &lt;/a&gt; 를 호출하여 생성됩니다 . 자세한 내용은 &lt;code&gt;sink()&lt;/code&gt; 설명서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5a732d552fb11922cbdd232738709d5ceaab3ab0" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.bufread#method.lines&quot;&gt;&lt;code&gt;lines&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;BufRead&lt;/code&gt;. Please see the documentation of &lt;code&gt;lines()&lt;/code&gt; for more details.</source>
          <target state="translated">이 구조체는 일반적으로 &lt;code&gt;BufRead&lt;/code&gt; 에서&lt;a href=&quot;trait.bufread#method.lines&quot;&gt; &lt;code&gt;lines&lt;/code&gt; &lt;/a&gt; 을 호출하여 생성됩니다 . 자세한 내용은 &lt;code&gt;lines()&lt;/code&gt; 설명서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="57521da9d072a5a75b7ef81a11e1941632c07769" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.bufread#method.split&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;BufRead&lt;/code&gt;. Please see the documentation of &lt;code&gt;split()&lt;/code&gt; for more details.</source>
          <target state="translated">이 구조체는 일반적으로 &lt;code&gt;BufRead&lt;/code&gt; 에서&lt;a href=&quot;trait.bufread#method.split&quot;&gt; &lt;code&gt;split&lt;/code&gt; &lt;/a&gt; 을 호출하여 생성됩니다 . 자세한 내용은 &lt;code&gt;split()&lt;/code&gt; 설명서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e1deb8df82a06cf7e25723eca2d9b3c3500c212f" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.read#method.bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; on a reader. Please see the documentation of &lt;a href=&quot;trait.read#method.bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">이 구조체는 일반적으로 리더에서 &lt;a href=&quot;trait.read#method.bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 를 호출하여 생성됩니다 . 자세한 내용은 &lt;a href=&quot;trait.read#method.bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 설명서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="137e3be8282a7112c63c8d5b6052cbdcefad663e" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.read#method.chain&quot;&gt;&lt;code&gt;chain&lt;/code&gt;&lt;/a&gt; on a reader. Please see the documentation of &lt;a href=&quot;trait.read#method.chain&quot;&gt;&lt;code&gt;chain&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">이 구조체는 일반적으로 리더에서 &lt;a href=&quot;trait.read#method.chain&quot;&gt; &lt;code&gt;chain&lt;/code&gt; &lt;/a&gt; 을 호출하여 생성됩니다 . 자세한 내용은 &lt;a href=&quot;trait.read#method.chain&quot;&gt; &lt;code&gt;chain&lt;/code&gt; &lt;/a&gt; 설명서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="047a4ebdecfd5e2897b79c73996497448f62e8a9" translate="yes" xml:space="preserve">
          <source>This struct is generally created by calling &lt;a href=&quot;trait.read#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; on a reader. Please see the documentation of &lt;a href=&quot;trait.read#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">이 구조체는 일반적으로 &lt;a href=&quot;trait.read#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; on reader를 호출하여 생성됩니다 . 자세한 내용은 &lt;a href=&quot;trait.read#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; 의 설명서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a7395af01bd4a50c6dfb48da98c0430b70139ec6" translate="yes" xml:space="preserve">
          <source>This struct is used in the &lt;a href=&quot;struct.child#structfield.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; field on &lt;a href=&quot;struct.child&quot;&gt;&lt;code&gt;Child&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;struct.child&quot;&gt; &lt;code&gt;Child&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.child#structfield.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt; 필드에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="45d9e2d1a8753395175acd043fb98b742fa0c7b1" translate="yes" xml:space="preserve">
          <source>This struct is used in the &lt;a href=&quot;struct.child#structfield.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt; field on &lt;a href=&quot;struct.child&quot;&gt;&lt;code&gt;Child&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;struct.child&quot;&gt; &lt;code&gt;Child&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.child#structfield.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt; 필드에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a0e77c1cd6c1d6c1011116ad5fd2720b269732ff" translate="yes" xml:space="preserve">
          <source>This struct is used in the &lt;a href=&quot;struct.child#structfield.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; field on &lt;a href=&quot;struct.child&quot;&gt;&lt;code&gt;Child&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;struct.child&quot;&gt; &lt;code&gt;Child&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.child#structfield.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; 필드에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5c3b3caed2d7f9ef42e3b6090d38c4f7a8f595c9" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;fn.split_paths&quot;&gt;&lt;code&gt;std::env::split_paths&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">이 구조는 &lt;a href=&quot;fn.split_paths&quot;&gt; &lt;code&gt;std::env::split_paths&lt;/code&gt; &lt;/a&gt; 함수에 의해 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="763fd05613c0342afc387ef243d7b2fcab0e70ec" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;fn.vars&quot;&gt;&lt;code&gt;std::env::vars&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">이 구조는 &lt;a href=&quot;fn.vars&quot;&gt; &lt;code&gt;std::env::vars&lt;/code&gt; &lt;/a&gt; 함수에 의해 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="aeb9c6eb7e34424ffff3b1a0d353cc1e7da71bbe" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;fn.vars_os&quot;&gt;&lt;code&gt;std::env::vars_os&lt;/code&gt;&lt;/a&gt; function. See its documentation for more.</source>
          <target state="translated">이 구조는 &lt;a href=&quot;fn.vars_os&quot;&gt; &lt;code&gt;std::env::vars_os&lt;/code&gt; &lt;/a&gt; 함수에 의해 작성됩니다 . 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="49ca05175d2c16657b8d4f1e47558a6913b20cd1" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;struct.mutex#method.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.mutex#method.try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt; methods on &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 구조는 &lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.mutex#method.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.mutex#method.try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt; 메소드 로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a6f95cf45a5bcc128684cebfbd05d3880902f8d" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;struct.panicinfo#method.location&quot;&gt;&lt;code&gt;location&lt;/code&gt;&lt;/a&gt; method of &lt;a href=&quot;struct.panicinfo&quot;&gt;&lt;code&gt;PanicInfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 구조는 &lt;a href=&quot;struct.panicinfo&quot;&gt; &lt;code&gt;PanicInfo&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.panicinfo#method.location&quot;&gt; &lt;code&gt;location&lt;/code&gt; &lt;/a&gt; 메소드로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="0ba43b358d72c0f70633e8ff8edbb3820ba26ae8" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;struct.rwlock#method.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.rwlock#method.try_read&quot;&gt;&lt;code&gt;try_read&lt;/code&gt;&lt;/a&gt; methods on &lt;a href=&quot;struct.rwlock&quot;&gt;&lt;code&gt;RwLock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 구조는 &lt;a href=&quot;struct.rwlock#method.try_read&quot;&gt; &lt;code&gt;try_read&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.rwlock#method.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 및 try_read 메소드로 &lt;a href=&quot;struct.rwlock&quot;&gt; &lt;code&gt;RwLock&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="37c48c912f9cb67a5286393a48bcb5981e2a346b" translate="yes" xml:space="preserve">
          <source>This structure is created by the &lt;a href=&quot;struct.rwlock#method.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.rwlock#method.try_write&quot;&gt;&lt;code&gt;try_write&lt;/code&gt;&lt;/a&gt; methods on &lt;a href=&quot;struct.rwlock&quot;&gt;&lt;code&gt;RwLock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 구조는 &lt;a href=&quot;struct.rwlock#method.try_write&quot;&gt; &lt;code&gt;try_write&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.rwlock#method.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 및 try_write 메소드로 &lt;a href=&quot;struct.rwlock&quot;&gt; &lt;code&gt;RwLock&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="e1b64e1281a00cf103b0dc5f24e83df69f16eb4c" translate="yes" xml:space="preserve">
          <source>This structure is returned from the &lt;a href=&quot;fn.metadata&quot;&gt;&lt;code&gt;metadata&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;fn.symlink_metadata&quot;&gt;&lt;code&gt;symlink_metadata&lt;/code&gt;&lt;/a&gt; function or method and represents known metadata about a file such as its permissions, size, modification times, etc.</source>
          <target state="translated">이 구조는 &lt;a href=&quot;fn.metadata&quot;&gt; &lt;code&gt;metadata&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;fn.symlink_metadata&quot;&gt; &lt;code&gt;symlink_metadata&lt;/code&gt; &lt;/a&gt; 함수 또는 메소드 에서 리턴되며 파일의 권한, 크기, 수정 시간 등과 같은 알려진 메타 데이터를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a90c6bba494b412af840afa94f3d4327e4e6ac5c" translate="yes" xml:space="preserve">
          <source>This structure is used to represent and manage child processes. A child process is created via the &lt;a href=&quot;struct.command&quot;&gt;&lt;code&gt;Command&lt;/code&gt;&lt;/a&gt; struct, which configures the spawning process and can itself be constructed using a builder-style interface.</source>
          <target state="translated">이 구조는 자식 프로세스를 나타내고 관리하는 데 사용됩니다. 자식 프로세스는 &lt;a href=&quot;struct.command&quot;&gt; &lt;code&gt;Command&lt;/code&gt; &lt;/a&gt; 구조체 를 통해 생성되며, 생성 프로세스는 스폰 프로세스를 구성하며 빌더 스타일의 인터페이스를 사용하여 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21f163fe5401a35062783545bd12a7fe23e7c94b" translate="yes" xml:space="preserve">
          <source>This structure represents a safely precompiled version of a format string and its arguments. This cannot be generated at runtime because it cannot safely be done, so no constructors are given and the fields are private to prevent modification.</source>
          <target state="translated">이 구조는 안전하게 사전 컴파일 된 형식 문자열 및 인수를 나타냅니다. 안전하게 수행 할 수 없기 때문에 런타임에 생성 할 수 없으므로 생성자가 제공되지 않으며 수정을 막기 위해 필드가 비공개입니다.</target>
        </trans-unit>
        <trans-unit id="0adc11971ab38c810ebf2248ed011aa51008e125" translate="yes" xml:space="preserve">
          <source>This suffers the same restrictions and reasoning as implementing &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;, see there for details.</source>
          <target state="translated">이것은 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; 구현과 동일한 제한 및 추론을 겪습니다 . 자세한 내용은 거기를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6f2d7a21c40fec745cf07aea5a678e00b27d1d6d" translate="yes" xml:space="preserve">
          <source>This sums up every integer in a vector, rejecting the sum if a negative element is encountered:</source>
          <target state="translated">이것은 벡터의 모든 정수를 합산하여 음수 요소가 발생하면 합계를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="3b38ed7b25f08579fef293fd7b9ae8fd73fe03b3" translate="yes" xml:space="preserve">
          <source>This sums up the position of the character 'a' in a vector of strings, if a word did not have the character 'a' the operation returns &lt;code&gt;None&lt;/code&gt;:</source>
          <target state="translated">문자열 벡터에서 문자 'a'의 위치를 ​​합산합니다. 단어에 문자 'a'가 없으면 연산은 &lt;code&gt;None&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b7b5e0845ef8959eb8d683ea0316747264243c8d" translate="yes" xml:space="preserve">
          <source>This syntax seems comparable to that of generics. So why not just define the &lt;code&gt;Iterator&lt;/code&gt; trait with generics, as shown in Listing 19-13?</source>
          <target state="translated">이 구문은 제네릭의 구문과 비슷합니다. 그렇다면 Listing 19-13에 나와있는 것처럼 제네릭으로 &lt;code&gt;Iterator&lt;/code&gt; 특성을 정의하지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="2e389d45d6848629d7d0a8141a0d2eefc943d3d3" translate="yes" xml:space="preserve">
          <source>This syntax should look familiar from our discussions on how to define traits in Chapter 10. Next comes some new syntax: Listing 17-4 defines a struct named &lt;code&gt;Screen&lt;/code&gt; that holds a vector named &lt;code&gt;components&lt;/code&gt;. This vector is of type &lt;code&gt;Box&amp;lt;dyn Draw&amp;gt;&lt;/code&gt;, which is a trait object; it&amp;rsquo;s a stand-in for any type inside a &lt;code&gt;Box&lt;/code&gt; that implements the &lt;code&gt;Draw&lt;/code&gt; trait.</source>
          <target state="translated">이 문법은 10 장에서 특성을 정의하는 방법에 대한 논의에서 친숙해 보일 것입니다. 다음은 새로운 구문입니다. Listing 17-4는 &lt;code&gt;components&lt;/code&gt; 라는 벡터를 보유하는 &lt;code&gt;Screen&lt;/code&gt; 이라는 구조체를 정의합니다 . 이 벡터는 &lt;code&gt;Box&amp;lt;dyn Draw&amp;gt;&lt;/code&gt; 유형 이며 특성 객체입니다. &lt;code&gt;Draw&lt;/code&gt; 특성 을 구현 하는 &lt;code&gt;Box&lt;/code&gt; 내부의 모든 유형에 대한 스탠드 인입니다.</target>
        </trans-unit>
        <trans-unit id="157ddb41dd66b7335f1aa23c99d8dc3500848966" translate="yes" xml:space="preserve">
          <source>This syntax specifies that we want the X type from MyTrait, as made concrete in MyStruct. The reason that we cannot simply use &lt;code&gt;MyStruct::X&lt;/code&gt; is that MyStruct might implement two different traits with identically-named associated types. This syntax allows disambiguation between the two.</source>
          <target state="translated">이 구문은 MyStruct에서 구체적으로 만든 것처럼 MyTrait에서 X 유형을 원한다는 것을 지정합니다. &lt;code&gt;MyStruct::X&lt;/code&gt; 단순히 사용할 수없는 이유 는 MyStruct가 동일한 이름의 연관된 유형으로 두 가지 특성을 구현할 수 있기 때문입니다 . 이 구문은 둘 사이의 명확성을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="6be1eead3ada3953477a6dbe51c912612a272761" translate="yes" xml:space="preserve">
          <source>This technique is just one of many ways to improve the throughput of a web server. Other options you might explore are the fork/join model and the single-threaded async I/O model. If you&amp;rsquo;re interested in this topic, you can read more about other solutions and try to implement them in Rust; with a low-level language like Rust, all of these options are possible.</source>
          <target state="translated">이 기술은 웹 서버의 처리량을 향상시키는 여러 가지 방법 중 하나 일뿐입니다. 탐색 할 수있는 다른 옵션은 포크 / 조인 모델 및 단일 스레드 비동기 I / O 모델입니다. 이 주제에 관심이 있다면 다른 솔루션에 대해 자세히 읽고 Rust에서 구현해보십시오. Rust와 같은 저수준 언어로 이러한 모든 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="731e8ea356524b34210881afc68de295a0e37bff" translate="yes" xml:space="preserve">
          <source>This technique is pretty neat! By using &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, we have an outwardly immutable &lt;code&gt;List&lt;/code&gt; value. But we can use the methods on &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; that provide access to its interior mutability so we can modify our data when we need to. The runtime checks of the borrowing rules protect us from data races, and it&amp;rsquo;s sometimes worth trading a bit of speed for this flexibility in our data structures.</source>
          <target state="translated">이 기술은 매우 깔끔합니다! &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용 하면 외부 적으로 변경할 수없는 &lt;code&gt;List&lt;/code&gt; 값이 있습니다. 그러나 내부 변경 가능성에 대한 액세스를 제공 하는 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 의 메소드를 사용하여 필요할 때 데이터를 수정할 수 있습니다. 차용 규칙의 런타임 검사는 데이터 경쟁으로부터 우리를 보호하며, 데이터 구조에서 이러한 유연성을 위해 약간의 속도로 거래 할 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9283a8a2efae9e1f40a1d640e7fbf1f6c7025c52" translate="yes" xml:space="preserve">
          <source>This tells us the return type of the &lt;code&gt;File::open&lt;/code&gt; function is a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;. The generic parameter &lt;code&gt;T&lt;/code&gt; has been filled in here with the type of the success value, &lt;code&gt;std::fs::File&lt;/code&gt;, which is a file handle. The type of &lt;code&gt;E&lt;/code&gt; used in the error value is &lt;code&gt;std::io::Error&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;File::open&lt;/code&gt; 함수 의 반환 유형은 &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; 입니다. 일반 매개 변수 &lt;code&gt;T&lt;/code&gt; 는 여기 에서 파일 핸들 인 성공 값의 유형 &lt;code&gt;std::fs::File&lt;/code&gt; 로 채워졌습니다 . 오류 값에 사용 된 &lt;code&gt;E&lt;/code&gt; 의 유형 은 &lt;code&gt;std::io::Error&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1369ebc6a80c7328fbe0b2bd897392d17a8945de" translate="yes" xml:space="preserve">
          <source>This test code defines a &lt;code&gt;MockMessenger&lt;/code&gt; struct that has a &lt;code&gt;sent_messages&lt;/code&gt; field with a &lt;code&gt;Vec&lt;/code&gt; of &lt;code&gt;String&lt;/code&gt; values to keep track of the messages it&amp;rsquo;s told to send. We also define an associated function &lt;code&gt;new&lt;/code&gt; to make it convenient to create new &lt;code&gt;MockMessenger&lt;/code&gt; values that start with an empty list of messages. We then implement the &lt;code&gt;Messenger&lt;/code&gt; trait for &lt;code&gt;MockMessenger&lt;/code&gt; so we can give a &lt;code&gt;MockMessenger&lt;/code&gt; to a &lt;code&gt;LimitTracker&lt;/code&gt;. In the definition of the &lt;code&gt;send&lt;/code&gt; method, we take the message passed in as a parameter and store it in the &lt;code&gt;MockMessenger&lt;/code&gt; list of &lt;code&gt;sent_messages&lt;/code&gt;.</source>
          <target state="translated">이 테스트 코드는 &lt;code&gt;Vec&lt;/code&gt; of &lt;code&gt;String&lt;/code&gt; 값을 가진 &lt;code&gt;sent_messages&lt;/code&gt; 필드 가 있는 &lt;code&gt;MockMessenger&lt;/code&gt; 구조체를 정의하여 보낸 메시지를 추적합니다. 또한 빈 메시지 목록으로 시작하는 새로운 &lt;code&gt;MockMessenger&lt;/code&gt; 값을 편리하게 만들 수 있도록 관련 함수를 &lt;code&gt;new&lt;/code&gt; 정의했습니다 . 우리는 다음 구현 &lt;code&gt;Messenger&lt;/code&gt; 에 대한 특성 &lt;code&gt;MockMessenger&lt;/code&gt; 을 우리가 제공 할 수 있도록 &lt;code&gt;MockMessenger&lt;/code&gt; 을 A와 &lt;code&gt;LimitTracker&lt;/code&gt; . &lt;code&gt;send&lt;/code&gt; 메소드 의 정의에서 전달 된 메시지를 매개 변수로 가져 &lt;code&gt;MockMessenger&lt;/code&gt; 목록에 저장합니다. &lt;code&gt;sent_messages&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf7bdfe2c080bcfbd294561ba32984ed7b6655c2" translate="yes" xml:space="preserve">
          <source>This test creates a new &lt;code&gt;Cacher&lt;/code&gt; instance with a closure that returns the value passed into it. We call the &lt;code&gt;value&lt;/code&gt; method on this &lt;code&gt;Cacher&lt;/code&gt; instance with an &lt;code&gt;arg&lt;/code&gt; value of 1 and then an &lt;code&gt;arg&lt;/code&gt; value of 2, and we expect the call to &lt;code&gt;value&lt;/code&gt; with the &lt;code&gt;arg&lt;/code&gt; value of 2 to return 2.</source>
          <target state="translated">이 테스트 는 전달 된 값을 반환하는 클로저를 사용하여 새로운 &lt;code&gt;Cacher&lt;/code&gt; 인스턴스를 만듭니다 . 우리는 전화 &lt;code&gt;value&lt;/code&gt; 이에 대한 방법 &lt;code&gt;Cacher&lt;/code&gt; 의 와 인스턴스를 &lt;code&gt;arg&lt;/code&gt; 1의 값과 다음 &lt;code&gt;arg&lt;/code&gt; 2의 값, 우리는 호출 기대 &lt;code&gt;value&lt;/code&gt; 과 &lt;code&gt;arg&lt;/code&gt; 2를 반환 2의 값입니다.</target>
        </trans-unit>
        <trans-unit id="72299afca54f19e85015cb228f6cdc67fc73f999" translate="yes" xml:space="preserve">
          <source>This test creates a new &lt;code&gt;Counter&lt;/code&gt; instance in the &lt;code&gt;counter&lt;/code&gt; variable and then calls &lt;code&gt;next&lt;/code&gt; repeatedly, verifying that we have implemented the behavior we want this iterator to have: returning the values from 1 to 5.</source>
          <target state="translated">이 테스트에서는 &lt;code&gt;counter&lt;/code&gt; 변수 에 새 &lt;code&gt;Counter&lt;/code&gt; 인스턴스를 만든 &lt;code&gt;next&lt;/code&gt; 반복적으로 호출 하여이 반복자가 원하는 동작을 구현했는지 확인합니다. 값을 1에서 5로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="05dea38628c56d1ac2dee0da9506b8c1998c15fa" translate="yes" xml:space="preserve">
          <source>This test searches for the string &lt;code&gt;&quot;duct&quot;&lt;/code&gt;. The text we&amp;rsquo;re searching is three lines, only one of which contains &lt;code&gt;&quot;duct&quot;&lt;/code&gt;. We assert that the value returned from the &lt;code&gt;search&lt;/code&gt; function contains only the line we expect.</source>
          <target state="translated">이 테스트는 &lt;code&gt;&quot;duct&quot;&lt;/code&gt; 문자열을 검색합니다 . 우리가 검색하는 텍스트는 세 줄이며 그중 하나에 만 &lt;code&gt;&quot;duct&quot;&lt;/code&gt; 가 포함 됩니다. &lt;code&gt;search&lt;/code&gt; 함수 에서 반환 된 값에 예상 한 줄만 포함되어 있다고 주장합니다 .</target>
        </trans-unit>
        <trans-unit id="ddca2fdf5e68d60216a77aaaba507a1415303561" translate="yes" xml:space="preserve">
          <source>This test will pass because the value we put in the &lt;code&gt;should_panic&lt;/code&gt; attribute&amp;rsquo;s &lt;code&gt;expected&lt;/code&gt; parameter is a substring of the message that the &lt;code&gt;Guess::new&lt;/code&gt; function panics with. We could have specified the entire panic message that we expect, which in this case would be &lt;code&gt;Guess value must be less than or equal to 100, got 200.&lt;/code&gt; What you choose to specify in the expected parameter for &lt;code&gt;should_panic&lt;/code&gt; depends on how much of the panic message is unique or dynamic and how precise you want your test to be. In this case, a substring of the panic message is enough to ensure that the code in the test function executes the &lt;code&gt;else if value &amp;gt; 100&lt;/code&gt; case.</source>
          <target state="translated">&lt;code&gt;should_panic&lt;/code&gt; 속성의 &lt;code&gt;expected&lt;/code&gt; 매개 변수에 넣은 값 이 &lt;code&gt;Guess::new&lt;/code&gt; 함수가 패닉 하는 메시지의 하위 문자열 이기 때문에이 테스트는 통과합니다 . 예상되는 전체 패닉 메시지를 지정할 수 있습니다.이 경우 &lt;code&gt;Guess value must be less than or equal to 100, got 200.&lt;/code&gt; 을 &lt;code&gt;should_panic&lt;/code&gt; 합니다. should_panic 에 대해 예상되는 매개 변수에서 지정 하는 것은 패닉의 양에 따라 다릅니다. 메시지는 독특하거나 역동적이며 테스트의 정확성을 원합니다. 이 경우 패닉 메시지의 하위 문자열로 테스트 함수의 코드가 &lt;code&gt;else if value &amp;gt; 100&lt;/code&gt; 경우 else를 실행하기에 충분합니다 .</target>
        </trans-unit>
        <trans-unit id="bbe227be9e7db744874fde49a6fb7f9f9cde2ed8" translate="yes" xml:space="preserve">
          <source>This text is available in &lt;a href=&quot;https://nostarch.com/rust&quot;&gt;paperback and ebook format from No Starch Press&lt;/a&gt;.</source>
          <target state="translated">이 텍스트는 &lt;a href=&quot;https://nostarch.com/rust&quot;&gt;No Starch Press의 페이퍼 백 및 전자 책 형식으로 제공됩니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="abaa655d972948c0991360be1b3331d77edb5df2" translate="yes" xml:space="preserve">
          <source>This time when we compile the code, we get a different set of errors:</source>
          <target state="translated">이번에는 코드를 컴파일 할 때 다른 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ef45f877ddb3c6c79878e62a645c0f1bb5d754ab" translate="yes" xml:space="preserve">
          <source>This time when we run the &lt;code&gt;should_panic&lt;/code&gt; test, it will fail:</source>
          <target state="translated">이번에는 &lt;code&gt;should_panic&lt;/code&gt; 테스트를 실행 하면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="927ffba8c6b861ab1b3ffedb0e60fa4989110409" translate="yes" xml:space="preserve">
          <source>This time, before we create the first spawned thread, we call &lt;code&gt;clone&lt;/code&gt; on the sending end of the channel. This will give us a new sending handle we can pass to the first spawned thread. We pass the original sending end of the channel to a second spawned thread. This gives us two threads, each sending different messages to the receiving end of the channel.</source>
          <target state="translated">이번에는 첫 번째 생성 된 스레드를 만들기 전에 채널의 전송 끝에서 &lt;code&gt;clone&lt;/code&gt; 을 호출 합니다. 그러면 생성 된 첫 번째 스레드에 전달할 수있는 새로운 전송 핸들이 제공됩니다. 채널의 원래 전송 끝을 두 번째 생성 스레드로 전달합니다. 이것은 우리에게 두 개의 쓰레드를 제공하는데, 각각의 쓰레드는 서로 다른 메시지를 채널의 수신단에 보냅니다.</target>
        </trans-unit>
        <trans-unit id="03b02e99d0c7b36f56fe77cf1bc6781836989a07" translate="yes" xml:space="preserve">
          <source>This time, the spawned thread has a vector of strings that we want to send to the main thread. We iterate over them, sending each individually, and pause between each by calling the &lt;code&gt;thread::sleep&lt;/code&gt; function with a &lt;code&gt;Duration&lt;/code&gt; value of 1 second.</source>
          <target state="translated">이번에는 스폰 된 쓰레드에 메인 쓰레드로 보내려는 문자열 벡터가 있습니다. 우리는 그것들을 반복하여 각각 개별적으로 보내고 , &lt;code&gt;Duration&lt;/code&gt; 값을 1 초로 &lt;code&gt;thread::sleep&lt;/code&gt; 함수를 호출하여 각각을 일시 중지 합니다.</target>
        </trans-unit>
        <trans-unit id="704e60202fcb30892563c7bc7f66fbb6decda49f" translate="yes" xml:space="preserve">
          <source>This trait allows constructing network objects like &lt;a href=&quot;struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.udpsocket&quot;&gt;&lt;code&gt;UdpSocket&lt;/code&gt;&lt;/a&gt; easily with values of various types for the bind/connection address. It is needed because sometimes one type is more appropriate than the other: for simple uses a string like &lt;code&gt;&quot;localhost:12345&quot;&lt;/code&gt; is much nicer than manual construction of the corresponding &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt;, but sometimes &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; value is &lt;em&gt;the&lt;/em&gt; main source of the address, and converting it to some other type (e.g., a string) just for it to be converted back to &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; in constructor methods is pointless.</source>
          <target state="translated">이 특성은 바인드 / 연결 주소에 대한 다양한 유형의 값으로 &lt;a href=&quot;struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;struct.udpsocket&quot;&gt; &lt;code&gt;UdpSocket&lt;/code&gt; &lt;/a&gt; 과 같은 네트워크 오브젝트를 쉽게 구성 할 수있게 합니다. 때로는 하나의 유형이 다른 유형보다 더 적합하기 때문에 필요합니다. 단순 사용의 경우 &lt;code&gt;&quot;localhost:12345&quot;&lt;/code&gt; 와 같은 문자열 이 해당 &lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; 의 수동 구성보다 훨씬 좋지만 때로는 &lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; 값이 주소 &lt;em&gt;의&lt;/em&gt; 주요 소스이며 변환 생성자 메소드에서 &lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; 로 다시 변환하기 위해 다른 유형 (예 : 문자열)으로 쓸모 가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1802ac1cfe1536c265ef2f2bdbe3a05ea51c03f9" translate="yes" xml:space="preserve">
          <source>This trait allows for partial equality, for types that do not have a full equivalence relation. For example, in floating point numbers &lt;code&gt;NaN != NaN&lt;/code&gt;, so floating point types implement &lt;code&gt;PartialEq&lt;/code&gt; but not &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="translated">이 특성은 완전한 등가 관계가없는 유형에 대해 부분적 평등을 허용합니다. 예를 들어 부동 소수점 숫자 &lt;code&gt;NaN != NaN&lt;/code&gt; 에서 부동 소수점 형식은 &lt;code&gt;PartialEq&lt;/code&gt; 를 구현 하지만 &lt;code&gt;Eq&lt;/code&gt; 는 구현 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7bebce9a7c84fca1499f5aca86035aeb53d64365" translate="yes" xml:space="preserve">
          <source>This trait can be used to implement other traits on fixed-size arrays without causing much metadata bloat.</source>
          <target state="translated">이 특성을 사용하면 메타 데이터가 크게 증가하지 않으면 서 고정 크기 배열에서 다른 특성을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5800007da2c584795de3c7fc5ff71b96b272866c" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt; if all fields are &lt;code&gt;Clone&lt;/code&gt;. The &lt;code&gt;derive&lt;/code&gt;d implementation of &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; calls &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on each field.</source>
          <target state="translated">모든 필드가 &lt;code&gt;Clone&lt;/code&gt; 인 경우이 특성을 &lt;code&gt;#[derive]&lt;/code&gt; 와 함께 사용할 수 있습니다 . &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 호출 의 &lt;code&gt;derive&lt;/code&gt; 구현은 각 필드에서 &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="e6a77474d17602cdca329051113afe871aed6794" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt; if all fields implement &lt;code&gt;Debug&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d for structs, it will use the name of the &lt;code&gt;struct&lt;/code&gt;, then &lt;code&gt;{&lt;/code&gt;, then a comma-separated list of each field's name and &lt;code&gt;Debug&lt;/code&gt; value, then &lt;code&gt;}&lt;/code&gt;. For &lt;code&gt;enum&lt;/code&gt;s, it will use the name of the variant and, if applicable, &lt;code&gt;(&lt;/code&gt;, then the &lt;code&gt;Debug&lt;/code&gt; values of the fields, then &lt;code&gt;)&lt;/code&gt;.</source>
          <target state="translated">모든 필드가 &lt;code&gt;Debug&lt;/code&gt; 를 구현 하는 경우이 특성을 &lt;code&gt;#[derive]&lt;/code&gt; 와 함께 사용할 수 있습니다 . 경우 &lt;code&gt;derive&lt;/code&gt; D는 구조체에 대해, 그것의 이름을 사용하는 &lt;code&gt;struct&lt;/code&gt; 후 &lt;code&gt;{&lt;/code&gt; 각 필드의 이름 다음의 쉼표로 구분 &lt;code&gt;Debug&lt;/code&gt; 값 다음 &lt;code&gt;}&lt;/code&gt; . 들어 &lt;code&gt;enum&lt;/code&gt; 의,이 경우, 적용, 변형의 이름을 사용하는 것 &lt;code&gt;(&lt;/code&gt; 다음 &lt;code&gt;Debug&lt;/code&gt; 필드의 값을, 다음 &lt;code&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1a45e25757830b253d95a2bc878b147cc25a79e" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt; if all of the type's fields implement &lt;code&gt;Default&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d, it will use the default value for each field's type.</source>
          <target state="translated">모든 유형의 필드가 &lt;code&gt;Default&lt;/code&gt; 를 구현하는 경우이 특성을 &lt;code&gt;#[derive]&lt;/code&gt; 와 함께 사용할 수 있습니다 . 언제 &lt;code&gt;derive&lt;/code&gt; d를 파생 각 필드 유형에 대한 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f09d6ff7ae1d14cf4065033999ff08ecaa8a87ff" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d on structs, it will produce a lexicographic ordering based on the top-to-bottom declaration order of the struct's members. When &lt;code&gt;derive&lt;/code&gt;d on enums, variants are ordered by their top-to-bottom declaration order.</source>
          <target state="translated">이 특성은 &lt;code&gt;#[derive]&lt;/code&gt; 와 함께 사용할 수 있습니다 . 때 &lt;code&gt;derive&lt;/code&gt; 구조체에 d를,이 구조체의 멤버의 위에서 아래로 선언 순서에 따라 사전 식 순서를 생성합니다. 열거 형에서 d를 &lt;code&gt;derive&lt;/code&gt; 때 변형은 위에서 아래로 선언 된 순서대로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="86c69254ea90ce1d6926208560c4e9d29d5a8ded" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d on structs, two instances are equal if all fields are equal, and not equal if any fields are not equal. When &lt;code&gt;derive&lt;/code&gt;d on enums, each variant is equal to itself and not equal to the other variants.</source>
          <target state="translated">이 특성은 &lt;code&gt;#[derive]&lt;/code&gt; 와 함께 사용할 수 있습니다 . 구조체에서 d를 &lt;code&gt;derive&lt;/code&gt; 때 모든 필드가 같으면 두 인스턴스가 같고 필드가 같지 않으면 같지 않습니다. 열거 형에서 d를 &lt;code&gt;derive&lt;/code&gt; 때 각 변형은 다른 변형과 같지 않고 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d52b5ae617172e107648185da3f817960014bc61" translate="yes" xml:space="preserve">
          <source>This trait can be used with &lt;code&gt;#[derive]&lt;/code&gt;. When &lt;code&gt;derive&lt;/code&gt;d, because &lt;code&gt;Eq&lt;/code&gt; has no extra methods, it is only informing the compiler that this is an equivalence relation rather than a partial equivalence relation. Note that the &lt;code&gt;derive&lt;/code&gt; strategy requires all fields are &lt;code&gt;Eq&lt;/code&gt;, which isn't always desired.</source>
          <target state="translated">이 특성은 &lt;code&gt;#[derive]&lt;/code&gt; 와 함께 사용할 수 있습니다 . d를 &lt;code&gt;derive&lt;/code&gt; 할 때 , &lt;code&gt;Eq&lt;/code&gt; 는 추가적인 방법이 없기 때문에 컴파일러에게 이것이 부분적 동등성 관계가 아니라 동등성 관계임을 알리는 것입니다. 점을 유의 &lt;code&gt;derive&lt;/code&gt; 전략은 모든 필드가 필요 &lt;code&gt;Eq&lt;/code&gt; 항상 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0b8679bc430feac142d06128a89f1af63473e460" translate="yes" xml:space="preserve">
          <source>This trait is automatically implemented for almost every type.</source>
          <target state="translated">이 특성은 거의 모든 유형에 대해 자동으로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="ce8cc586f2666a5f5f3d6650a18ec09e61d24a39" translate="yes" xml:space="preserve">
          <source>This trait is automatically implemented for any type which implements the &lt;a href=&quot;../fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; trait. As such, &lt;code&gt;ToString&lt;/code&gt; shouldn't be implemented directly: &lt;a href=&quot;../fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; should be implemented instead, and you get the &lt;code&gt;ToString&lt;/code&gt; implementation for free.</source>
          <target state="translated">이 특성은 &lt;a href=&quot;../fmt/trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt; 특성 을 구현하는 모든 유형에 대해 자동으로 구현됩니다 . 따라서 &lt;code&gt;ToString&lt;/code&gt; 은 직접 구현하면 안됩니다. 대신 &lt;a href=&quot;../fmt/trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt; 를 구현해야합니다. &lt;code&gt;ToString&lt;/code&gt; 구현은 무료로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="5e3b32607a26276b7eeb2dc3f257150496699a30" translate="yes" xml:space="preserve">
          <source>This trait is automatically implemented when the compiler determines it's appropriate.</source>
          <target state="translated">이 특성은 컴파일러가 적절하다고 판단 할 때 자동으로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="494ae62c6025e3f79bcb3a8e54a1efc9a121264f" translate="yes" xml:space="preserve">
          <source>This trait is implemented by default for many types and behaves similarly in terms of inference of implementation to the &lt;a href=&quot;../marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; traits. The purpose of this trait is to encode what types are safe to cross a &lt;a href=&quot;fn.catch_unwind&quot;&gt;&lt;code&gt;catch_unwind&lt;/code&gt;&lt;/a&gt; boundary with no fear of unwind safety.</source>
          <target state="translated">이 특성은 기본적으로 여러 유형에 대해 구현되며 &lt;a href=&quot;../marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; 특성 에 대한 구현 유추 측면에서 유사하게 작동 합니다. 이 특성의 목적은 &lt;a href=&quot;fn.catch_unwind&quot;&gt; &lt;code&gt;catch_unwind&lt;/code&gt; &lt;/a&gt; 와인드 안전성에 대한 두려움없이 catch_unwind 경계 를 넘어 안전한 유형을 인코딩하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="6fb1b7be6434ef1f997fff7cbfd045083e8560fe" translate="yes" xml:space="preserve">
          <source>This trait is namely not implemented by &lt;a href=&quot;../cell/struct.unsafecell&quot;&gt;&lt;code&gt;UnsafeCell&lt;/code&gt;&lt;/a&gt;, the root of all interior mutability.</source>
          <target state="translated">이 특성은 모든 내부 변경의 근본 인 &lt;a href=&quot;../cell/struct.unsafecell&quot;&gt; &lt;code&gt;UnsafeCell&lt;/code&gt; &lt;/a&gt; 에 의해 구현되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1d0c0de184f4ceb6563275bbcba7c14bd0a8edcc" translate="yes" xml:space="preserve">
          <source>This trait is similar to &lt;a href=&quot;trait.asmut&quot;&gt;&lt;code&gt;AsMut&lt;/code&gt;&lt;/a&gt; which is used for converting between mutable references. If you need to do a costly conversion it is better to implement &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; with type &lt;code&gt;&amp;amp;T&lt;/code&gt; or write a custom function.</source>
          <target state="translated">이 특성은 변경 가능한 참조 간 변환에 사용되는 &lt;a href=&quot;trait.asmut&quot;&gt; &lt;code&gt;AsMut&lt;/code&gt; &lt;/a&gt; 과 유사합니다 . 비용이 많이 드는 변환이 필요한 경우 &lt;code&gt;&amp;amp;T&lt;/code&gt; 유형으로 &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; 을 구현 하거나 사용자 정의 함수를 작성하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="72c951714ee4a3342d70f41b91f0921e7e49ebf0" translate="yes" xml:space="preserve">
          <source>This trait is similar to &lt;a href=&quot;trait.asref&quot;&gt;&lt;code&gt;AsRef&lt;/code&gt;&lt;/a&gt; but used for converting between mutable references. If you need to do a costly conversion it is better to implement &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; with type &lt;code&gt;&amp;amp;mut T&lt;/code&gt; or write a custom function.</source>
          <target state="translated">이 특성은 &lt;a href=&quot;trait.asref&quot;&gt; &lt;code&gt;AsRef&lt;/code&gt; &lt;/a&gt; 와 유사 하지만 변경 가능한 참조 간 변환에 사용됩니다. 비용이 많이 드는 변환이 필요한 경우 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 유형으로 &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; 을 구현하는 것이 좋습니다. 하거나 사용자 정의 함수를 작성하는 .</target>
        </trans-unit>
        <trans-unit id="1a731da3b36000bb0e86dfbd3105e49bf55c952e" translate="yes" xml:space="preserve">
          <source>This trait is the type which this modules requires when formatting information. This is similar to the standard library's &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;io::Write&lt;/code&gt;&lt;/a&gt; trait, but it is only intended for use in libcore.</source>
          <target state="translated">이 특성은 정보를 형식화 할 때이 모듈에 필요한 유형입니다. 이것은 표준 라이브러리의 &lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;io::Write&lt;/code&gt; &lt;/a&gt; 특성 과 유사 하지만 libcore에서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0b733d2267c635d65e2675dc57b25279df45e854" translate="yes" xml:space="preserve">
          <source>This trait is used for generic address resolution when constructing network objects. By default it is implemented for the following types:</source>
          <target state="translated">이 특성은 네트워크 개체를 구성 할 때 일반 주소 확인에 사용됩니다. 기본적으로 다음 유형에 대해 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="d670e5f44288c65ae601422a01219d930136f211" translate="yes" xml:space="preserve">
          <source>This trait is used to implement the &lt;a href=&quot;trait.product#tymethod.product&quot;&gt;&lt;code&gt;product&lt;/code&gt;&lt;/a&gt; method on iterators. Types which implement the trait can be generated by the &lt;a href=&quot;trait.product#tymethod.product&quot;&gt;&lt;code&gt;product&lt;/code&gt;&lt;/a&gt; method. Like &lt;a href=&quot;trait.fromiterator&quot;&gt;&lt;code&gt;FromIterator&lt;/code&gt;&lt;/a&gt; this trait should rarely be called directly and instead interacted with through &lt;a href=&quot;trait.iterator#method.product&quot;&gt;&lt;code&gt;Iterator::product&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 특성은 반복자 에서 &lt;a href=&quot;trait.product#tymethod.product&quot;&gt; &lt;code&gt;product&lt;/code&gt; &lt;/a&gt; 메소드 를 구현하는 데 사용됩니다 . 특성을 구현하는 유형은 &lt;a href=&quot;trait.product#tymethod.product&quot;&gt; &lt;code&gt;product&lt;/code&gt; &lt;/a&gt; 방법 으로 생성 할 수 있습니다 . &lt;a href=&quot;trait.fromiterator&quot;&gt; &lt;code&gt;FromIterator&lt;/code&gt; &lt;/a&gt; 와 같이이 특성은 거의 직접 호출되지 않고 &lt;a href=&quot;trait.iterator#method.product&quot;&gt; &lt;code&gt;Iterator::product&lt;/code&gt; &lt;/a&gt; 를 통해 상호 작용하지 않아야합니다. .</target>
        </trans-unit>
        <trans-unit id="f91608e2b2b005f5d3b20c487cd2efcf273838ce" translate="yes" xml:space="preserve">
          <source>This trait is used to implement the &lt;a href=&quot;trait.sum#tymethod.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; method on iterators. Types which implement the trait can be generated by the &lt;a href=&quot;trait.sum#tymethod.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; method. Like &lt;a href=&quot;trait.fromiterator&quot;&gt;&lt;code&gt;FromIterator&lt;/code&gt;&lt;/a&gt; this trait should rarely be called directly and instead interacted with through &lt;a href=&quot;trait.iterator#method.sum&quot;&gt;&lt;code&gt;Iterator::sum&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 특성은 반복자 에서 &lt;a href=&quot;trait.sum#tymethod.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; 메소드 를 구현하는 데 사용됩니다 . 특성을 구현하는 유형은 &lt;a href=&quot;trait.sum#tymethod.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; 메소드 로 생성 할 수 있습니다 . &lt;a href=&quot;trait.fromiterator&quot;&gt; &lt;code&gt;FromIterator&lt;/code&gt; &lt;/a&gt; 와 같이이 특성은 직접 호출되지 않고 &lt;a href=&quot;trait.iterator#method.sum&quot;&gt; &lt;code&gt;Iterator::sum&lt;/code&gt; &lt;/a&gt; 을 통해 상호 작용하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="b392534a7b8b5e656825847e787994b0e838f382" translate="yes" xml:space="preserve">
          <source>This trait must only be implemented when the contract is upheld. Consumers of this trait must inspect &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;.size_hint&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s upper bound.</source>
          <target state="translated">이 특성은 계약이 체결 된 경우에만 구현해야합니다. 이 특성의 소비자는 &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;.size_hint&lt;/code&gt; &lt;/a&gt; 의 상한을 검사해야합니다 .</target>
        </trans-unit>
        <trans-unit id="92b09db877c076776794822e006bb3f0094cf13d" translate="yes" xml:space="preserve">
          <source>This trait provides methods for searching for non-overlapping matches of a pattern starting from the back (right) of a string.</source>
          <target state="translated">이 특성은 문자열의 뒷면 (오른쪽)에서 시작하여 패턴이 겹치지 않는 일치 항목을 검색하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="581e031865e09ba379141c2883157c1d8acecf2b" translate="yes" xml:space="preserve">
          <source>This trait provides methods for searching for non-overlapping matches of a pattern starting from the front (left) of a string.</source>
          <target state="translated">이 특성은 문자열의 앞 (왼쪽)에서 시작하여 패턴의 겹치지 않는 일치를 검색하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7d02b91849e023371b70419d209ec71d8ae7432d" translate="yes" xml:space="preserve">
          <source>This trait should generally not be implemented by consumers of the standard library. The &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macro accepts an instance of &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;io::Write&lt;/code&gt;&lt;/a&gt;, and the &lt;a href=&quot;../io/trait.write&quot;&gt;&lt;code&gt;io::Write&lt;/code&gt;&lt;/a&gt; trait is favored over implementing this trait.</source>
          <target state="translated">이 특성은 일반적으로 표준 라이브러리 소비자가 구현해서는 안됩니다. &lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;매크로의 인스턴스 받아 &lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;io::Write&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../io/trait.write&quot;&gt; &lt;code&gt;io::Write&lt;/code&gt; &lt;/a&gt; 특성이 특성을 구현을 통해 선호한다.</target>
        </trans-unit>
        <trans-unit id="6159bc779b64f1381d56daf00e89fd123440f35d" translate="yes" xml:space="preserve">
          <source>This tree shows how some of the modules nest inside one another (for example, &lt;code&gt;hosting&lt;/code&gt; nests inside &lt;code&gt;front_of_house&lt;/code&gt;). The tree also shows that some modules are &lt;em&gt;siblings&lt;/em&gt; to each other, meaning they&amp;rsquo;re defined in the same module (&lt;code&gt;hosting&lt;/code&gt; and &lt;code&gt;serving&lt;/code&gt; are defined within &lt;code&gt;front_of_house&lt;/code&gt;). To continue the family metaphor, if module A is contained inside module B, we say that module A is the &lt;em&gt;child&lt;/em&gt; of module B and that module B is the &lt;em&gt;parent&lt;/em&gt; of module A. Notice that the entire module tree is rooted under the implicit module named &lt;code&gt;crate&lt;/code&gt;.</source>
          <target state="translated">이 트리는 일부 모듈이 서로 중첩되는 방법을 보여줍니다 (예 : &lt;code&gt;front_of_house&lt;/code&gt; 내부의 중첩 &lt;code&gt;hosting&lt;/code&gt; ). 트리는 또한 일부 모듈이 서로 &lt;em&gt;형제&lt;/em&gt; 임을 보여줍니다. 즉 , 동일한 모듈에 정의되어 있습니다 ( &lt;code&gt;hosting&lt;/code&gt; 및 &lt;code&gt;serving&lt;/code&gt; 는 &lt;code&gt;front_of_house&lt;/code&gt; 내에 정의 됨 ). 패밀리 비유를 계속하기 위해 모듈 A가 모듈 B에 포함 된 경우 모듈 A는 모듈 B의 &lt;em&gt;자식&lt;/em&gt; 이고 모듈 B 는 모듈 A 의 &lt;em&gt;부모&lt;/em&gt; 라고합니다. 전체 모듈 트리는 암시 적 모듈이라는 이름 아래에 있습니다. &lt;code&gt;crate&lt;/code&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6a2a59de8ad5e3abf90b08ea27feb4c5c9564363" translate="yes" xml:space="preserve">
          <source>This trick is very sneaky and complicated. Don&amp;rsquo;t worry if it doesn&amp;rsquo;t make perfect sense; someday, it will be completely unnecessary.</source>
          <target state="translated">이 트릭은 매우 교묘하고 복잡합니다. 그것이 완벽하지 않다고 걱정하지 마십시오. 언젠가는 완전히 불필요합니다.</target>
        </trans-unit>
        <trans-unit id="b151d516c842037f13cd18d29f046aea06e0121e" translate="yes" xml:space="preserve">
          <source>This type cannot have a well-defined size, because it needs to be arbitrarily large (since we would be able to nest &lt;code&gt;ListNode&lt;/code&gt;s to any depth). Specifically,</source>
          <target state="translated">이 유형은 임의로 커야하므로 크기를 잘 정의 할 수 없습니다 ( &lt;code&gt;ListNode&lt;/code&gt; 를 깊이 에 중첩시킬 수 있기 때문에 ). 구체적으로 특별히,</target>
        </trans-unit>
        <trans-unit id="84f5f45f7092418ba53ffa588ed49cf6c55b3005" translate="yes" xml:space="preserve">
          <source>This type does not support transmission of an error other than that an error occurred. Any extra information must be arranged to be transmitted through some other means.</source>
          <target state="translated">이 유형은 오류가 발생한 것 이외의 오류 전송을 지원하지 않습니다. 추가 정보는 다른 수단을 통해 전송되도록 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="ca06708cb31886f20e9999f83e4a96bd88513b09" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as a &lt;a href=&quot;../../primitive.bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 유형은 &lt;a href=&quot;../../primitive.bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; 과 동일한 메모리 내 표현을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="7ed5168f106b9ae49d6a5ac8c4fbf062da809a4c" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as a &lt;code&gt;*mut T&lt;/code&gt;.</source>
          <target state="translated">이 유형은 &lt;code&gt;*mut T&lt;/code&gt; 와 동일한 메모리 내 표현을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="bde0ba16d9d2a17d2da79db3c616fd2db5d4b738" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.i16&quot;&gt;&lt;code&gt;i16&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">이 유형은 기본 정수 유형 &lt;a href=&quot;../../primitive.i16&quot;&gt; &lt;code&gt;i16&lt;/code&gt; &lt;/a&gt; 과 동일한 메모리 내 표현을 갖습니다 . 원자 유형과 비 원자 유형의 차이점과이 유형의 이식성에 대한 정보는 &lt;a href=&quot;index&quot;&gt;모듈 레벨 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="11fe8d9ef82cc58363e607b1900488902f96b062" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">이 유형은 기본 정수 유형 &lt;a href=&quot;../../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; 와 동일한 메모리 내 표현을 갖습니다 . 원자 유형과 비 원자 유형의 차이점과이 유형의 이식성에 대한 정보는 &lt;a href=&quot;index&quot;&gt;모듈 레벨 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae2c41e53be3c451cd7fe9d715ded32f7f324930" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">이 유형은 기본 정수 유형 &lt;a href=&quot;../../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt; 와 동일한 메모리 내 표현을 갖습니다 . 원자 유형과 비 원자 유형의 차이점과이 유형의 이식성에 대한 정보는 &lt;a href=&quot;index&quot;&gt;모듈 레벨 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8709735902527f53136366bbc4da81e059b1cf29" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.i8&quot;&gt;&lt;code&gt;i8&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">이 유형은 기본 정수 유형 &lt;a href=&quot;../../primitive.i8&quot;&gt; &lt;code&gt;i8&lt;/code&gt; &lt;/a&gt; 과 동일한 메모리 내 표현을 갖습니다 . 원자 유형과 비 원자 유형의 차이점과이 유형의 이식성에 대한 정보는 &lt;a href=&quot;index&quot;&gt;모듈 레벨 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="22a2662795b52aff8d9d5db4f32fbfd5a6eae45b" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.isize&quot;&gt;&lt;code&gt;isize&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">이 유형은 기본 정수 유형 인 &lt;a href=&quot;../../primitive.isize&quot;&gt; &lt;code&gt;isize&lt;/code&gt; &lt;/a&gt; 와 동일한 메모리 내 표현을 갖습니다 . 원자 유형과 비 원자 유형의 차이점과이 유형의 이식성에 대한 정보는 &lt;a href=&quot;index&quot;&gt;모듈 레벨 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b0e9d5aecbbcb90f5394cd93afd041c8660e20d3" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">이 유형은 기본 정수 유형 &lt;a href=&quot;../../primitive.u16&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt; 과 동일한 메모리 내 표현을 갖습니다 . 원자 유형과 비 원자 유형의 차이점과이 유형의 이식성에 대한 정보는 &lt;a href=&quot;index&quot;&gt;모듈 레벨 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2b9ce184354cce38ff31805f5b9e99cf85271c3" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">이 유형은 기본 정수 유형 &lt;a href=&quot;../../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; 와 동일한 메모리 내 표현을 갖습니다 . 원자 유형과 비 원자 유형의 차이점과이 유형의 이식성에 대한 정보는 &lt;a href=&quot;index&quot;&gt;모듈 레벨 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f3b430d11ed80e34dede1d2fe612c5e93a3e75e" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.u64&quot;&gt;&lt;code&gt;u64&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">이 유형은 기본 정수 유형 &lt;a href=&quot;../../primitive.u64&quot;&gt; &lt;code&gt;u64&lt;/code&gt; &lt;/a&gt; 와 동일한 메모리 내 표현을 갖습니다 . 원자 유형과 비 원자 유형의 차이점과이 유형의 이식성에 대한 정보는 &lt;a href=&quot;index&quot;&gt;모듈 레벨 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="da5885bb51df1018c63942e6cd581107a9d67b99" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">이 유형은 기본 정수 유형 &lt;a href=&quot;../../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; 과 동일한 메모리 내 표현을 갖습니다 . 원자 유형과 비 원자 유형의 차이점과이 유형의 이식성에 대한 정보는 &lt;a href=&quot;index&quot;&gt;모듈 레벨 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1494d8fbdc9903b4f7f4ce3473fbf110556d56ce" translate="yes" xml:space="preserve">
          <source>This type has the same in-memory representation as the underlying integer type, &lt;a href=&quot;../../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;. For more about the differences between atomic types and non-atomic types as well as information about the portability of this type, please see the &lt;a href=&quot;index&quot;&gt;module-level documentation&lt;/a&gt;.</source>
          <target state="translated">이 유형은 기본 정수 유형 인 &lt;a href=&quot;../../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; 와 동일한 메모리 내 표현을 갖습니다 . 원자 유형과 비 원자 유형의 차이점과이 유형의 이식성에 대한 정보는 &lt;a href=&quot;index&quot;&gt;모듈 레벨 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd773ba06290a2ef0eb43046e43b15b9753a1b01" translate="yes" xml:space="preserve">
          <source>This type implements the &lt;a href=&quot;trait.alloc&quot;&gt;&lt;code&gt;Alloc&lt;/code&gt;&lt;/a&gt; trait by forwarding calls to the allocator registered with the &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute if there is one, or the &lt;code&gt;std&lt;/code&gt; crate&amp;rsquo;s default.</source>
          <target state="translated">이 유형 은 &lt;code&gt;#[global_allocator]&lt;/code&gt; 속성으로 등록 된 할당 자 또는 &lt;code&gt;std&lt;/code&gt; 크레이트의 기본값으로 호출을 전달 하여 &lt;a href=&quot;trait.alloc&quot;&gt; &lt;code&gt;Alloc&lt;/code&gt; &lt;/a&gt; 특성을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="1acd93eca07f0189a95b444e7590b0d811f50e31" translate="yes" xml:space="preserve">
          <source>This type implements the &lt;code&gt;GlobalAlloc&lt;/code&gt; trait and Rust programs by default work as if they had this definition:</source>
          <target state="translated">이 유형은 &lt;code&gt;GlobalAlloc&lt;/code&gt; 특성 및 Rust 프로그램을 기본적으로 다음 정의를 가진 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="466a15ddbbbf930acad97c2c30afa51f3b95564c" translate="yes" xml:space="preserve">
          <source>This type is broadly used across &lt;a href=&quot;index&quot;&gt;&lt;code&gt;std::io&lt;/code&gt;&lt;/a&gt; for any operation which may produce an error.</source>
          <target state="translated">이 유형은 오류가 발생할 수있는 모든 작업에 &lt;a href=&quot;index&quot;&gt; &lt;code&gt;std::io&lt;/code&gt; &lt;/a&gt; 에서 광범위하게 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="37345f83ba0c67385672d5daf1593634da8686e6" translate="yes" xml:space="preserve">
          <source>This type is the error type for the &lt;a href=&quot;struct.string#method.from_utf16&quot;&gt;&lt;code&gt;from_utf16&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 유형은 &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.string#method.from_utf16&quot;&gt; &lt;code&gt;from_utf16&lt;/code&gt; &lt;/a&gt; 메소드에 대한 오류 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="8498c071c2463be5580b4f49150396661778b8bc" translate="yes" xml:space="preserve">
          <source>This type is the error type for the &lt;a href=&quot;struct.string#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;. It is designed in such a way to carefully avoid reallocations: the &lt;a href=&quot;struct.fromutf8error#method.into_bytes&quot;&gt;&lt;code&gt;into_bytes&lt;/code&gt;&lt;/a&gt; method will give back the byte vector that was used in the conversion attempt.</source>
          <target state="translated">이 유형은 &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.string#method.from_utf8&quot;&gt; &lt;code&gt;from_utf8&lt;/code&gt; &lt;/a&gt; 메소드에 대한 오류 유형입니다 . &lt;a href=&quot;struct.fromutf8error#method.into_bytes&quot;&gt; &lt;code&gt;into_bytes&lt;/code&gt; &lt;/a&gt; 메소드는 변환 시도에 사용 된 바이트 벡터를 다시 제공 하여 재 할당을 신중하게 피할 수 있도록 설계되었습니다 .</target>
        </trans-unit>
        <trans-unit id="63b84d2000b910b8457b4220e8938add88b701b5" translate="yes" xml:space="preserve">
          <source>This type of lock allows a number of readers or at most one writer at any point in time. The write portion of this lock typically allows modification of the underlying data (exclusive access) and the read portion of this lock typically allows for read-only access (shared access).</source>
          <target state="translated">이 유형의 잠금은 특정 시점에 여러 독자 또는 최대 한 명의 작성자를 허용합니다. 이 잠금의 쓰기 부분은 일반적으로 기본 데이터 (독점 액세스)의 수정을 허용하고이 잠금의 읽기 부분은 일반적으로 읽기 전용 액세스 (공유 액세스)를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="c6101d6dc5e2fd547d5ca4f8075c490b739700a9" translate="yes" xml:space="preserve">
          <source>This type provides methods like &lt;a href=&quot;struct.pathbuf#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.pathbuf#method.set_extension&quot;&gt;&lt;code&gt;set_extension&lt;/code&gt;&lt;/a&gt; that mutate the path in place. It also implements &lt;a href=&quot;../ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;, meaning that all methods on &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; slices are available on &lt;code&gt;PathBuf&lt;/code&gt; values as well.</source>
          <target state="translated">이 유형은 경로를 변경하는 &lt;a href=&quot;struct.pathbuf#method.push&quot;&gt; &lt;code&gt;push&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.pathbuf#method.set_extension&quot;&gt; &lt;code&gt;set_extension&lt;/code&gt; &lt;/a&gt; 과 같은 메소드를 제공합니다 . 또한 &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; 에 대한&lt;/a&gt;&lt;a href=&quot;../ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; 를 구현 하므로 &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; 슬라이스의 모든 메소드 를 &lt;code&gt;PathBuf&lt;/code&gt; 값에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5c0f0dd2b187cb6784df147ee7001123c8936c0" translate="yes" xml:space="preserve">
          <source>This type represents a borrowed reference to a nul-terminated array of bytes. It can be constructed safely from a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice, or unsafely from a raw &lt;code&gt;*const c_char&lt;/code&gt;. It can then be converted to a Rust &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; by performing UTF-8 validation, or into an owned &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 유형은 널 종료 바이트 배열에 대한 빌린 참조를 나타냅니다. &lt;code&gt;&amp;amp;[&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;]&lt;/code&gt; 슬라이스에서 안전하게 또는 raw &lt;code&gt;*const c_char&lt;/code&gt; 에서 안전하지 않게 구성 할 수 있습니다 . 그런 다음 UTF-8 유효성 검사를 수행하거나 소유 한 &lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt; 으로 Rust &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1e18df5bb8ad819c600cd4afb1d82afc59b7f998" translate="yes" xml:space="preserve">
          <source>This type represents a borrowed reference to a string in the operating system's preferred representation.</source>
          <target state="translated">이 유형은 운영 체제의 선호 표현에서 문자열에 대한 빌린 참조를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6b774085d693678b6b309fbc90af8e885fb4742c" translate="yes" xml:space="preserve">
          <source>This type represents the status code a process can return to its parent under normal termination.</source>
          <target state="translated">이 유형은 정상적인 종료 상태에서 프로세스가 부모에게 반환 할 수있는 상태 코드를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8b966cfbeebcefe7f0330e7e9f54f7098bf1152f" translate="yes" xml:space="preserve">
          <source>This type serves the purpose of being able to safely generate a C-compatible string from a Rust byte slice or vector. An instance of this type is a static guarantee that the underlying bytes contain no interior 0 bytes (&quot;nul characters&quot;) and that the final byte is 0 (&quot;nul terminator&quot;).</source>
          <target state="translated">이 유형은 Rust 바이트 슬라이스 또는 벡터에서 C 호환 문자열을 안전하게 생성 할 수 있도록합니다. 이 유형의 인스턴스는 기본 바이트에 내부 0 바이트 ( &quot;널 문자&quot;)가없고 마지막 바이트가 0 ( &quot;널 종결 자&quot;)임을 정적으로 보장합니다.</target>
        </trans-unit>
        <trans-unit id="7d87337ad285058ac7367e471ff8622a41dfdd71" translate="yes" xml:space="preserve">
          <source>This type supports a number of operations for inspecting a path, including breaking the path into its components (separated by &lt;code&gt;/&lt;/code&gt; on Unix and by either &lt;code&gt;/&lt;/code&gt; or  on Windows), extracting the file name, determining whether the path is absolute, and so on.</source>
          <target state="translated">이 유형은 경로를 구성 요소로 나누는 것을 포함하여 경로를 검사하기위한 여러 작업을 지원합니다 ( 유닉스에서 &lt;code&gt;/&lt;/code&gt; 로 구분하고 &lt;code&gt;/&lt;/code&gt; 또는 Windows로 구분), 파일 이름 추출, 절대 경로 판별 .</target>
        </trans-unit>
        <trans-unit id="f22ec26e83b1f093f0fa10a8ffd75ef588107911" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.f32&quot;&gt;&lt;code&gt;f32&lt;/code&gt;&lt;/a&gt;, which is guaranteed to be an &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE-754 single-precision float&lt;/a&gt; in Rust. That said, the standard technically only guarantees that it be a floating-point number, and it may have less precision than &lt;code&gt;f32&lt;/code&gt; or not follow the IEEE-754 standard at all.</source>
          <target state="translated">이 유형은 거의 항상 &lt;a href=&quot;../../primitive.f32&quot;&gt; &lt;code&gt;f32&lt;/code&gt; &lt;/a&gt; 이며 Rust 에서는 &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE-754 단 정밀도 부동 소수점&lt;/a&gt; 으로 보장됩니다 . 즉, 표준은 기술적으로 부동 소수점 수임을 보장하며 정밀도보다 정확도가 떨어질 수 있습니다 &lt;code&gt;f32&lt;/code&gt; 떨어지 거나 IEEE-754 표준을 전혀 따르지 않을 .</target>
        </trans-unit>
        <trans-unit id="b34eb94d33cfcd2b81be054dc12a48e0b5f8dc2f" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.f64&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt;, which is guaranteed to be an &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE-754 double-precision float&lt;/a&gt; in Rust. That said, the standard technically only guarantees that it be a floating-point number with at least the precision of a &lt;a href=&quot;type.c_float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;, and it may be &lt;code&gt;f32&lt;/code&gt; or something entirely different from the IEEE-754 standard.</source>
          <target state="translated">이 유형은 거의 항상 &lt;a href=&quot;../../primitive.f64&quot;&gt; &lt;code&gt;f64&lt;/code&gt; &lt;/a&gt; 이며 Rust 에서는 &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE-754 배정 밀도 부동 소수점&lt;/a&gt; 으로 보장됩니다 . 즉, 표준은 기술적으로 그것이 적어도 &lt;a href=&quot;type.c_float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; 의 정밀도를 가진 부동 소수점 숫자임을 보증하며 , &lt;code&gt;f32&lt;/code&gt; 또는 IEEE-754 표준과 완전히 다른 .</target>
        </trans-unit>
        <trans-unit id="2713919b8810fb3f44c86782b09415ed3b59cda3" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.i16&quot;&gt;&lt;code&gt;i16&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be a signed integer with at least 16 bits; some systems may define it as &lt;code&gt;i32&lt;/code&gt;, for example.</source>
          <target state="translated">이 유형은 거의 항상 &lt;a href=&quot;../../primitive.i16&quot;&gt; &lt;code&gt;i16&lt;/code&gt; &lt;/a&gt; 이지만 일부 난해한 시스템에서는 다를 수 있습니다. C 표준에서는 기술적으로이 유형은 16 비트 이상의 부호있는 정수 여야합니다. 일부 시스템은 다음과 같이 정의 할 수 있습니다. &lt;code&gt;i32&lt;/code&gt; 예를 들어 i32 .</target>
        </trans-unit>
        <trans-unit id="c0d84326d8675408ac530de354cda2d1a8ac7eb3" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be a signed integer that is at least the size of a &lt;a href=&quot;type.c_short&quot;&gt;&lt;code&gt;short&lt;/code&gt;&lt;/a&gt;; some systems define it as an &lt;a href=&quot;../../primitive.i16&quot;&gt;&lt;code&gt;i16&lt;/code&gt;&lt;/a&gt;, for example.</source>
          <target state="translated">이 유형은 거의 항상 &lt;a href=&quot;../../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; 이지만 일부 난해한 시스템에서는 다를 수 있습니다. C 표준에서는 기술적으로이 유형은 적어도 &lt;a href=&quot;type.c_short&quot;&gt; &lt;code&gt;short&lt;/code&gt; &lt;/a&gt; 크기의 부호있는 정수 여야합니다 . 예를 들어 일부 시스템에서는이를 &lt;a href=&quot;../../primitive.i16&quot;&gt; &lt;code&gt;i16&lt;/code&gt; &lt;/a&gt; 으로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="ab581f0ea98e052030c778602ef0ca98c399648d" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;, but may differ on some systems. The C standard technically only requires that this type be a signed integer that is at least 64 bits and at least the size of a &lt;a href=&quot;type.c_int&quot;&gt;&lt;code&gt;long&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;long long&lt;/code&gt; that is not an &lt;code&gt;i64&lt;/code&gt;, as most systems do not have a standardised &lt;a href=&quot;../../primitive.i128&quot;&gt;&lt;code&gt;i128&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">이 유형은 거의 항상 &lt;a href=&quot;../../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt; 이지만 일부 시스템에서는 다를 수 있습니다. C 표준은 기술적 으로이 유형이 64 비트 이상 및 &lt;a href=&quot;type.c_int&quot;&gt; &lt;code&gt;long&lt;/code&gt; &lt;/a&gt; 크기 이상의 부호있는 정수 만 요구 하지만 실제로 는 대부분의 시스템이 그렇지 않기 때문에 시스템이 &lt;code&gt;i64&lt;/code&gt; 가 아닌 &lt;code&gt;long long&lt;/code&gt; 을 갖지는 않습니다. 표준화 된 &lt;a href=&quot;../../primitive.i128&quot;&gt; &lt;code&gt;i128&lt;/code&gt; &lt;/a&gt; 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="15b5edcf451c79ce2991144552b8f569664ab769" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be an unsigned integer with the same size as a &lt;a href=&quot;type.c_short&quot;&gt;&lt;code&gt;short&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 유형은 거의 항상 &lt;a href=&quot;../../primitive.u16&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt; 이지만 일부 난해한 시스템에서는 다를 수 있습니다. C 표준에서는 기술적으로이 유형은 &lt;a href=&quot;type.c_short&quot;&gt; &lt;code&gt;short&lt;/code&gt; &lt;/a&gt; 와 동일한 크기의 부호없는 정수 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="8ba1b7005ffb5ad84714cb0adcd9cce8dfd29a44" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;, but may differ on some esoteric systems. The C standard technically only requires that this type be an unsigned integer with the same size as an &lt;a href=&quot;type.c_int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;; some systems define it as a &lt;a href=&quot;../../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt;, for example.</source>
          <target state="translated">이 유형은 거의 항상 &lt;a href=&quot;../../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; 이지만 일부 난해한 시스템에서는 다를 수 있습니다. C 표준에서는 기술적으로이 유형은 &lt;a href=&quot;type.c_int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 와 동일한 크기의 부호없는 정수 여야합니다 . 일부 시스템은이를 &lt;a href=&quot;../../primitive.u16&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt; 으로 정의합니다예를 들어 .</target>
        </trans-unit>
        <trans-unit id="10f7763a2c07ba8b71ea9cbe73fe235f098f6f03" translate="yes" xml:space="preserve">
          <source>This type will almost always be &lt;a href=&quot;../../primitive.u64&quot;&gt;&lt;code&gt;u64&lt;/code&gt;&lt;/a&gt;, but may differ on some systems. The C standard technically only requires that this type be an unsigned integer with the size of a &lt;a href=&quot;type.c_longlong&quot;&gt;&lt;code&gt;long long&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;long long&lt;/code&gt; that is not a &lt;code&gt;u64&lt;/code&gt;, as most systems do not have a standardised &lt;a href=&quot;../../primitive.u128&quot;&gt;&lt;code&gt;u128&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">이 유형은 거의 항상 &lt;a href=&quot;../../primitive.u64&quot;&gt; &lt;code&gt;u64&lt;/code&gt; &lt;/a&gt; 이지만 일부 시스템에서는 다를 수 있습니다. C 표준은 기술적 으로이 유형이 &lt;a href=&quot;type.c_longlong&quot;&gt; &lt;code&gt;long long&lt;/code&gt; &lt;/a&gt; 크기의 부호없는 정수 일 것을 요구 하지만 실제로 는 대부분의 시스템에 표준화 된 &lt;a href=&quot;../../primitive.u128&quot;&gt; &lt;code&gt;u128&lt;/code&gt; &lt;/a&gt; 유형 이 없으므로 실제로 &lt;code&gt;long long&lt;/code&gt; 이 &lt;code&gt;u64&lt;/code&gt; 가 아닌 시스템은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="cf97ad06e74edf68697dac1b4dcee83cfa2a22b5" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;../../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../primitive.i64&quot;&gt;&lt;code&gt;i64&lt;/code&gt;&lt;/a&gt;. Most notably, many Linux-based systems assume an &lt;code&gt;i64&lt;/code&gt;, but Windows assumes &lt;code&gt;i32&lt;/code&gt;. The C standard technically only requires that this type be a signed integer that is at least 32 bits and at least the size of an &lt;a href=&quot;type.c_int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;long&lt;/code&gt; that is neither an &lt;code&gt;i32&lt;/code&gt; nor &lt;code&gt;i64&lt;/code&gt;.</source>
          <target state="translated">이 유형은 항상 &lt;a href=&quot;../../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../primitive.i64&quot;&gt; &lt;code&gt;i64&lt;/code&gt; &lt;/a&gt; 입니다. 대부분의 Linux 기반 시스템은 &lt;code&gt;i64&lt;/code&gt; 를 가정 하지만 Windows는 &lt;code&gt;i32&lt;/code&gt; 를 가정합니다 . C 표준은 기술적 으로이 유형이 32 비트 이상이고 &lt;a href=&quot;type.c_int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 크기 이상인 부호있는 정수 만 요구 하지만 실제로는 시스템이 &lt;code&gt;i32&lt;/code&gt; 나 &lt;code&gt;i64&lt;/code&gt; 가 아닌 &lt;code&gt;long&lt;/code&gt; 을 갖지 는 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7164487891e0a7833d4edf15c16beda44c3572d5" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;../../primitive.i8&quot;&gt;&lt;code&gt;i8&lt;/code&gt;&lt;/a&gt;, but is included for completeness. It is defined as being a signed integer the same size as a C &lt;a href=&quot;type.c_char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 유형은 항상 &lt;a href=&quot;../../primitive.i8&quot;&gt; &lt;code&gt;i8&lt;/code&gt; &lt;/a&gt; 이지만 완전성을 위해 포함됩니다. C &lt;a href=&quot;type.c_char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 와 같은 크기의 부호있는 정수로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="9ffb84596c9e59eea63cf919456fbd81bc2d5347" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;../../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../primitive.u64&quot;&gt;&lt;code&gt;u64&lt;/code&gt;&lt;/a&gt;. Most notably, many Linux-based systems assume an &lt;code&gt;u64&lt;/code&gt;, but Windows assumes &lt;code&gt;u32&lt;/code&gt;. The C standard technically only requires that this type be an unsigned integer with the size of a &lt;a href=&quot;type.c_long&quot;&gt;&lt;code&gt;long&lt;/code&gt;&lt;/a&gt;, although in practice, no system would have a &lt;code&gt;ulong&lt;/code&gt; that is neither a &lt;code&gt;u32&lt;/code&gt; nor &lt;code&gt;u64&lt;/code&gt;.</source>
          <target state="translated">이 유형은 항상 &lt;a href=&quot;../../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../primitive.u64&quot;&gt; &lt;code&gt;u64&lt;/code&gt; &lt;/a&gt; 입니다. 대부분의 Linux 기반 시스템은 &lt;code&gt;u64&lt;/code&gt; 를 가정 하지만 Windows는 &lt;code&gt;u32&lt;/code&gt; 를 가정합니다 . C 표준은 기술적 으로이 유형이 &lt;a href=&quot;type.c_long&quot;&gt; &lt;code&gt;long&lt;/code&gt; &lt;/a&gt; 크기의 부호없는 정수 일 것을 요구 하지만 실제로는 시스템이 &lt;code&gt;u32&lt;/code&gt; 가 아닌 &lt;code&gt;ulong&lt;/code&gt; 을 갖지 않습니다. &lt;code&gt;u64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="702c3c35c3eb36099eb087128d0090cf4cdc5cb9" translate="yes" xml:space="preserve">
          <source>This type will always be &lt;a href=&quot;../../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;, but is included for completeness. It is defined as being an unsigned integer the same size as a C &lt;a href=&quot;type.c_char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 유형은 항상 &lt;a href=&quot;../../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; 이지만 완전성을 위해 포함됩니다. C &lt;a href=&quot;type.c_char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 와 동일한 크기의 부호없는 정수로 정의됩니다. .</target>
        </trans-unit>
        <trans-unit id="4424cbb3fbb90751454ec3bf9577dceb9d9a320d" translate="yes" xml:space="preserve">
          <source>This typedef is generally used to avoid writing out &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;io::Error&lt;/code&gt;&lt;/a&gt; directly and is otherwise a direct mapping to &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 typedef는 일반적으로 &lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;io::Error&lt;/code&gt; &lt;/a&gt; 직접 쓰지 않고 &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; 에&lt;/a&gt; 직접 매핑하는 데 사용됩니다. .</target>
        </trans-unit>
        <trans-unit id="9571d5615d4085a615ed7c5ad4cadc1ded956713" translate="yes" xml:space="preserve">
          <source>This typically means that an operation could only succeed if it read a particular number of bytes but only a smaller number of bytes could be read.</source>
          <target state="translated">이는 일반적으로 특정 바이트 수를 읽는 경우에만 작업이 성공하지만 더 적은 수의 바이트 만 읽을 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="692f047748f56fd7b6dd085f2d1ee90a117e619a" translate="yes" xml:space="preserve">
          <source>This typically means that an operation could only succeed if it wrote a particular number of bytes but only a smaller number of bytes could be written.</source>
          <target state="translated">이는 일반적으로 특정 수의 바이트를 쓴 경우에만 작업이 성공하지만 더 적은 수의 바이트 만 쓸 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="066666922981580e3c6ec7b57246e05ce6d242d4" translate="yes" xml:space="preserve">
          <source>This usage of &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; to create safe nullable pointers is so common that Rust does special optimizations to make the representation of &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; a single pointer. Optional pointers in Rust are stored as efficiently as any other pointer type.</source>
          <target state="translated">이 사용 &lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; 안전 널 (NULL) 포인터를 만들 수는 녹 표현하기 위해 특별한 최적화 않도록 일반적인 &lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 하나의 포인터. Rust의 선택적 포인터는 다른 포인터 유형만큼 효율적으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="3473dac5d293883be110e74db63b95a407d1ea5c" translate="yes" xml:space="preserve">
          <source>This usage of &lt;code&gt;extern&lt;/code&gt; does not require &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">이러한 &lt;code&gt;extern&lt;/code&gt; 사용은 &lt;code&gt;unsafe&lt;/code&gt; 하지 않아도 됩니다.</target>
        </trans-unit>
        <trans-unit id="d52ccca3efa09c9ce1760baf0a04fa97e3aed552" translate="yes" xml:space="preserve">
          <source>This use of a &lt;code&gt;where&lt;/code&gt; clause is strange - a more common usage would look something like the following:</source>
          <target state="translated">이 사용하는 &lt;code&gt;where&lt;/code&gt; 절을 것은 이상합니다.보다 일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ededb49250daf0db79bbb927c06d879d238521da" translate="yes" xml:space="preserve">
          <source>This value sets the time-to-live field that is used in every packet sent from this socket.</source>
          <target state="translated">이 값은이 소켓에서 전송 된 모든 패킷에 사용되는 TTL 필드를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="413d9b4dc5521012c4ffcf2dbef4c140f61e2a52" translate="yes" xml:space="preserve">
          <source>This variant is the most common one, it represents references to files or directories.</source>
          <target state="translated">이 변형은 가장 일반적인 변형이며 파일 또는 디렉토리에 대한 참조를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8ad9c1ff17fcdcd8bc09eee76d183971a27c0cfe" translate="yes" xml:space="preserve">
          <source>This variant will be emitted when the parsing string has a value of zero, which would be illegal for non-zero types.</source>
          <target state="translated">이 변형은 구문 분석 문자열의 값이 0 일 때 생성되며 이는 0이 아닌 유형에는 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0051a5a0c2153685b22e3e481253428438ae9b0d" translate="yes" xml:space="preserve">
          <source>This way, the lifetime of the &lt;code&gt;CString&lt;/code&gt; in &lt;code&gt;hello&lt;/code&gt; encompasses the lifetime of &lt;code&gt;ptr&lt;/code&gt; and the &lt;code&gt;unsafe&lt;/code&gt; block.</source>
          <target state="translated">이 방법의 수명 &lt;code&gt;CString&lt;/code&gt; 을 에 &lt;code&gt;hello&lt;/code&gt; 의 수명 포함 &lt;code&gt;ptr&lt;/code&gt; 과 &lt;code&gt;unsafe&lt;/code&gt; 블록.</target>
        </trans-unit>
        <trans-unit id="c87576c37932e7e920719c7c3053295204953101" translate="yes" xml:space="preserve">
          <source>This will always &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이것은 항상 &lt;a href=&quot;macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1c37af121800fff05f23ea7195ec86eae7b112d6" translate="yes" xml:space="preserve">
          <source>This will always &lt;a href=&quot;macro.panic&quot;&gt;panic!&lt;/a&gt;</source>
          <target state="translated">이것은 항상 &lt;a href=&quot;macro.panic&quot;&gt;공황 상태입니다!&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ca9dc67930c6219a678b4690efb3c9a2b4b3cc3e" translate="yes" xml:space="preserve">
          <source>This will be a max-heap.</source>
          <target state="translated">이것은 최대 힙이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="4fffbe8e22b797d8b6890d54d873414453d3490a" translate="yes" xml:space="preserve">
          <source>This will cause an error:</source>
          <target state="translated">오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5b06471f77c7403c58187c73c7a664a50663e032" translate="yes" xml:space="preserve">
          <source>This will commonly, but not always, be a &lt;code&gt;&amp;amp;'static str&lt;/code&gt; or &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적으로 항상 그런 것은 아니며 &lt;code&gt;&amp;amp;'static str&lt;/code&gt; 또는 &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1a8b17614cf7c240a7a1eb116da8eea5f59c7b71" translate="yes" xml:space="preserve">
          <source>This will compile, because it has the constraint on the type parameter:</source>
          <target state="translated">type 매개 변수에 제약이 있기 때문에 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="3520fed49c822ab60288ef2f8f669d15b4a41e6f" translate="yes" xml:space="preserve">
          <source>This will compile:</source>
          <target state="translated">이것은 컴파일됩니다 :</target>
        </trans-unit>
        <trans-unit id="49cc821a81b4f339dbb259efc2d82e6ee470759f" translate="yes" xml:space="preserve">
          <source>This will create a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; from the &lt;code&gt;String&lt;/code&gt; and pass it in. This conversion is very inexpensive, and so generally, functions will accept &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;s as arguments unless they need a &lt;code&gt;String&lt;/code&gt; for some specific reason.</source>
          <target state="translated">이렇게하면 &lt;code&gt;String&lt;/code&gt; 에서 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 이 생성 되어 전달됩니다.이 변환은 매우 저렴하므로 일반적으로 함수는 특정한 이유로 &lt;code&gt;String&lt;/code&gt; 필요하지 않은 경우 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 을 인수로 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="1b5cc9b9f228f1bae8ee73a71afeed4d549dd793" translate="yes" xml:space="preserve">
          <source>This will create a thread using default parameters of &lt;a href=&quot;struct.builder&quot;&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;/a&gt;, if you want to specify the stack size or the name of the thread, use this API instead.</source>
          <target state="translated">이렇게하면 기본 매개 변수 인 &lt;a href=&quot;struct.builder&quot;&gt; &lt;code&gt;Builder&lt;/code&gt; 를&lt;/a&gt; 사용하여 스레드가 생성됩니다 . 스택 크기 또는 스레드 이름을 지정하려면이 API를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e391cc107c46641450ffa0654fcfb8cbca70a73b" translate="yes" xml:space="preserve">
          <source>This will decrement the strong reference count. If the strong reference count reaches zero then the only other references (if any) are &lt;a href=&quot;../rc/struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt;, so we &lt;code&gt;drop&lt;/code&gt; the inner value.</source>
          <target state="translated">강한 참조 카운트가 감소합니다. 강한 참조 카운트가 0에 도달하면 다른 참조 (있는 경우) 만 &lt;a href=&quot;../rc/struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 것이므로 &lt;code&gt;drop&lt;/code&gt; 내부 값을 합니다.</target>
        </trans-unit>
        <trans-unit id="97b7f84f70f9d3f5d6303968924e2733780bc78b" translate="yes" xml:space="preserve">
          <source>This will decrement the strong reference count. If the strong reference count reaches zero then the only other references (if any) are &lt;a href=&quot;../sync/struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt;, so we &lt;code&gt;drop&lt;/code&gt; the inner value.</source>
          <target state="translated">강한 참조 카운트가 감소합니다. 강한 참조 카운트가 0에 도달하면 다른 참조 (있는 경우) 만 &lt;a href=&quot;../sync/struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 것이므로 &lt;code&gt;drop&lt;/code&gt; 내부 값을 합니다.</target>
        </trans-unit>
        <trans-unit id="b917396cbcb63b72ec008aadc499d642c7abbf61" translate="yes" xml:space="preserve">
          <source>This will decrement the strong reference count. If the strong reference count reaches zero then the only other references (if any) are &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt;, so we &lt;code&gt;drop&lt;/code&gt; the inner value.</source>
          <target state="translated">강한 참조 카운트가 감소합니다. 강한 참조 카운트가 0에 도달하면 다른 참조 (있는 경우) 만 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 것이므로 &lt;code&gt;drop&lt;/code&gt; 내부 값을 합니다.</target>
        </trans-unit>
        <trans-unit id="0e9819c7b2177172935ef1092ecc4f74eaf1578f" translate="yes" xml:space="preserve">
          <source>This will drop any excess capacity.</source>
          <target state="translated">초과 용량이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="354a015dbdb2ab35ae4e0b061d1f50f5025f7cbe" translate="yes" xml:space="preserve">
          <source>This will escape characters with the Rust syntax of the form &lt;code&gt;\u{NNNNNN}&lt;/code&gt; where &lt;code&gt;NNNNNN&lt;/code&gt; is a hexadecimal representation.</source>
          <target state="translated">이것은 &lt;code&gt;\u{NNNNNN}&lt;/code&gt; 형식의 Rust 구문으로 문자를 이스케이프합니다. 여기서 &lt;code&gt;NNNNNN&lt;/code&gt; 은 16 진 표현입니다.</target>
        </trans-unit>
        <trans-unit id="c51882eef9b6927fb20dc2b079d5f33d822ffcef" translate="yes" xml:space="preserve">
          <source>This will escape the characters similar to the &lt;code&gt;Debug&lt;/code&gt; implementations of &lt;code&gt;str&lt;/code&gt; or &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 또는 &lt;code&gt;char&lt;/code&gt; 의 &lt;code&gt;Debug&lt;/code&gt; 구현 과 유사한 문자를 이스케이프합니다 .</target>
        </trans-unit>
        <trans-unit id="7463a3fbad059d7822b7a64865f64ec71f56ca6c" translate="yes" xml:space="preserve">
          <source>This will fail because the compiler does not know which instance of &lt;code&gt;Foo&lt;/code&gt; to call &lt;code&gt;bar&lt;/code&gt; on. Change &lt;code&gt;Foo::bar()&lt;/code&gt; to &lt;code&gt;Foo::&amp;lt;T&amp;gt;::bar()&lt;/code&gt; to resolve the error.</source>
          <target state="translated">컴파일러는 어떤 예를 모르기 때문에이 실패합니다 &lt;code&gt;Foo&lt;/code&gt; 통화로 &lt;code&gt;bar&lt;/code&gt; 에 있습니다. 변경 &lt;code&gt;Foo::bar()&lt;/code&gt; 에 &lt;code&gt;Foo::&amp;lt;T&amp;gt;::bar()&lt;/code&gt; 오류를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="b95565727f175f666e1822f4733ae91ef6a1780e" translate="yes" xml:space="preserve">
          <source>This will fail to compile because we cannot implement a trait for a type if both the trait and the type are not defined by the current crate. This is due to Rust's orphaning rules. To bypass this, you can implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; directly:</source>
          <target state="translated">특성과 유형이 현재 상자에 의해 정의되지 않은 경우 유형에 대한 특성을 구현할 수 없으므로 컴파일에 실패합니다. 이것은 Rust의 고아 규칙 때문입니다. 이를 우회하기 위해 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; 를&lt;/a&gt; 직접 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c41f14d1e2c5310aaa0b927129f701a7031c03a" translate="yes" xml:space="preserve">
          <source>This will invoke the &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; macro if the provided expression cannot be evaluated to &lt;code&gt;true&lt;/code&gt; at runtime.</source>
          <target state="translated">이것은 &lt;a href=&quot;macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt; 을 불러 일으킬 것입니다! 제공된 표현식을 &lt;code&gt;true&lt;/code&gt; 로 평가할 수없는 경우 매크로 을 런타임 .</target>
        </trans-unit>
        <trans-unit id="2deb5f847f234caa59a2e70f4ab65edaeb2fdead" translate="yes" xml:space="preserve">
          <source>This will lazily initialize the value if this thread has not referenced this key yet.</source>
          <target state="translated">이 스레드가이 키를 아직 참조하지 않은 경우 값을 느리게 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="2be746d77ee47101c5a961aeebfbec50b6101d49" translate="yes" xml:space="preserve">
          <source>This will lazily initialize the value if this thread has not referenced this key yet. If the key has been destroyed (which may happen if this is called in a destructor), this function will return an &lt;a href=&quot;struct.accesserror&quot;&gt;&lt;code&gt;AccessError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 스레드가이 키를 아직 참조하지 않은 경우 값을 느리게 초기화합니다. 키가 소멸 된 경우 (소멸자에서 호출 된 경우 발생할 수 있음)이 함수는 &lt;a href=&quot;struct.accesserror&quot;&gt; &lt;code&gt;AccessError&lt;/code&gt; &lt;/a&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4b457d7ac05dde73ffae7dfa5283d452dba90a68" translate="yes" xml:space="preserve">
          <source>This will not print any values, as we only created an iterator, rather than using it. The compiler will warn us about this kind of behavior:</source>
          <target state="translated">이터레이터를 사용하는 대신 생성기 만 만들었으므로 값이 인쇄되지 않습니다. 컴파일러는 이러한 종류의 동작에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="7884f03c74d608aa53fe96a0fe19b6f01fc64a4e" translate="yes" xml:space="preserve">
          <source>This will not work if the new name is on a different mount point.</source>
          <target state="translated">새 이름이 다른 마운트 지점에있는 경우 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="29502fa64160996ff78f02e55cbb4b83b39e3b0d" translate="yes" xml:space="preserve">
          <source>This will not:</source>
          <target state="translated">이것은하지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="b5b85ab1e962bdcb10ff35cb96c42d807c436122" translate="yes" xml:space="preserve">
          <source>This will output the following:</source>
          <target state="translated">이것은 다음을 출력합니다 :</target>
        </trans-unit>
        <trans-unit id="01e646d50274ee113a75cb82fc9f837874518988" translate="yes" xml:space="preserve">
          <source>This will override the &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, and &lt;code&gt;append&lt;/code&gt; flags on the &lt;code&gt;OpenOptions&lt;/code&gt; structure. This method provides fine-grained control over the permissions to read, write and append data, attributes (like hidden and system), and extended attributes.</source>
          <target state="translated">&lt;code&gt;OpenOptions&lt;/code&gt; 구조 의 &lt;code&gt;read&lt;/code&gt; , &lt;code&gt;write&lt;/code&gt; 및 &lt;code&gt;append&lt;/code&gt; 플래그를 재정의합니다 . 이 방법은 데이터 읽기, 쓰기 및 추가 권한, 숨겨진 속성 및 시스템 속성 및 확장 속성에 대한 세밀한 제어를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="475997c398cd5b2921c0cb8cd3f062a1e5e787e7" translate="yes" xml:space="preserve">
          <source>This will print &quot;('a', 1), ('b', 2), ('c', 3)&quot;.</source>
          <target state="translated">&quot;( 'a', 1), ( 'b', 2), ( 'c', 3)&quot;이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="3a5f8c78def77453ab00074a3cd30ff4dd27218b" translate="yes" xml:space="preserve">
          <source>This will print &lt;code&gt;1&lt;/code&gt; through &lt;code&gt;5&lt;/code&gt;, each on their own line.</source>
          <target state="translated">이것은 각각 자신의 라인에 &lt;code&gt;1&lt;/code&gt; 에서 &lt;code&gt;5&lt;/code&gt; 까지 인쇄 합니다.</target>
        </trans-unit>
        <trans-unit id="45cc5d4168a6948db8686b2c0a8d37fbb64175cc" translate="yes" xml:space="preserve">
          <source>This will print &lt;code&gt;Cons(1, Cons(2, Nil))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Cons(1, Cons(2, Nil))&lt;/code&gt; 이 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="fa3cd6bbcdf4b75c4bbd0f80ed7b9518ac88ecb8" translate="yes" xml:space="preserve">
          <source>This will print the numbers &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;4&lt;/code&gt;, each on their own line.</source>
          <target state="translated">이것은 각각 자신의 줄에 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;4&lt;/code&gt; 까지 의 숫자를 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="a40fac0ea22a56e98579c9cc97554e4f4a65b5bb" translate="yes" xml:space="preserve">
          <source>This will print the numbers one through five, each on their own line. But you'll notice something here: we never called anything on our vector to produce an iterator. What gives?</source>
          <target state="translated">이것은 각각의 줄에 1부터 5까지의 숫자를 인쇄합니다. 그러나 여기서 알 수 있듯이 반복기 생성을 위해 벡터에 아무것도 호출하지 않았습니다. 무엇을 제공합니까?</target>
        </trans-unit>
        <trans-unit id="6e363eb5c9d1e189e7877f05521713cb961f9afe" translate="yes" xml:space="preserve">
          <source>This will print:</source>
          <target state="translated">인쇄됩니다 :</target>
        </trans-unit>
        <trans-unit id="e3f9d6eebc7d0a9c3006485e1bf2fe9250c18991" translate="yes" xml:space="preserve">
          <source>This will result in &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;recv&lt;/code&gt; and &lt;code&gt;send&lt;/code&gt; operations becoming nonblocking, i.e., immediately returning from their calls. If the IO operation is successful, &lt;code&gt;Ok&lt;/code&gt; is returned and no further action is required. If the IO operation could not be completed and needs to be retried, an error with kind &lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt;&lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">이로 인해 &lt;code&gt;read&lt;/code&gt; , &lt;code&gt;write&lt;/code&gt; , &lt;code&gt;recv&lt;/code&gt; 및 &lt;code&gt;send&lt;/code&gt; 작업이 차단되지 않게됩니다. 즉, 해당 호출에서 즉시 반환됩니다. IO 작업이 성공하면 &lt;code&gt;Ok&lt;/code&gt; 가 반환되고 추가 작업이 필요하지 않습니다. IO 작업을 완료 할 수없고 재 시도 &lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt; &lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt; &lt;/a&gt; 종류의 오류 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4b3da21af1f8f50bfb5fb08b425cfbfeb0c3196a" translate="yes" xml:space="preserve">
          <source>This will result in &lt;code&gt;recv&lt;/code&gt;, &lt;code&gt;recv_from&lt;/code&gt;, &lt;code&gt;send&lt;/code&gt;, and &lt;code&gt;send_to&lt;/code&gt; operations becoming nonblocking, i.e., immediately returning from their calls. If the IO operation is successful, &lt;code&gt;Ok&lt;/code&gt; is returned and no further action is required. If the IO operation could not be completed and needs to be retried, an error with kind &lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt;&lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">이로 인해 &lt;code&gt;recv&lt;/code&gt; , &lt;code&gt;recv_from&lt;/code&gt; , &lt;code&gt;send&lt;/code&gt; 및 &lt;code&gt;send_to&lt;/code&gt; 작업이 차단되지 않게 됩니다. 즉, 해당 호출에서 즉시 반환됩니다. IO 작업이 성공하면 &lt;code&gt;Ok&lt;/code&gt; 가 반환되고 추가 작업이 필요하지 않습니다. IO 작업을 완료 할 수없고 재 시도해야하는 경우 종류 오류&lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt; &lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt; &lt;/a&gt;가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="62e7ab507f523fe704d7f615781e7105b958a139" translate="yes" xml:space="preserve">
          <source>This will result in the &lt;code&gt;accept&lt;/code&gt; operation becoming nonblocking, i.e., immediately returning from their calls. If the IO operation is successful, &lt;code&gt;Ok&lt;/code&gt; is returned and no further action is required. If the IO operation could not be completed and needs to be retried, an error with kind &lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt;&lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">이로 인해 &lt;code&gt;accept&lt;/code&gt; 작업이 비 차단 상태가되어 즉, 해당 호출에서 즉시 돌아옵니다. IO 작업이 성공하면 &lt;code&gt;Ok&lt;/code&gt; 가 반환되고 추가 작업이 필요하지 않습니다. IO 작업을 완료 할 수없고 재 시도해야하는 경우 종류 오류&lt;a href=&quot;../io/enum.errorkind#variant.WouldBlock&quot;&gt; &lt;code&gt;io::ErrorKind::WouldBlock&lt;/code&gt; &lt;/a&gt;가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b55e73be7a2382bca6297d35304f77d90844f6fa" translate="yes" xml:space="preserve">
          <source>This will retrieve the stored error in the underlying socket, clearing the field in the process. This can be useful for checking errors between calls.</source>
          <target state="translated">그러면 프로세스에서 필드를 지우고 기본 소켓에 저장된 오류가 검색됩니다. 통화 간 오류를 확인하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f194e7c7453fbebb97c4d612baa72decde0dd60" translate="yes" xml:space="preserve">
          <source>This will return an error when the IP version of the local socket does not match that returned from &lt;a href=&quot;trait.tosocketaddrs&quot;&gt;&lt;code&gt;ToSocketAddrs&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">로컬 소켓의 IP 버전이 &lt;a href=&quot;trait.tosocketaddrs&quot;&gt; &lt;code&gt;ToSocketAddrs&lt;/code&gt; &lt;/a&gt; 에서 반환 된 것과 일치하지 않으면 오류가 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="fc0cdcc30572aec7d1df1cbb47d079cf5a14ac66" translate="yes" xml:space="preserve">
          <source>This will succeed even if there are outstanding weak references.</source>
          <target state="translated">뛰어난 약한 참조가 있어도 성공합니다.</target>
        </trans-unit>
        <trans-unit id="2bd1f4c0ae47dc79d8ec8c7bba4ba6b5d8664eba" translate="yes" xml:space="preserve">
          <source>This will use &lt;code&gt;clone&lt;/code&gt; to duplicate an expression, so one should be careful using this with types having a nonstandard &lt;code&gt;Clone&lt;/code&gt; implementation. For example, &lt;code&gt;vec![Rc::new(1); 5]&lt;/code&gt; will create a vector of five references to the same boxed integer value, not five references pointing to independently boxed integers.</source>
          <target state="translated">이것은 &lt;code&gt;clone&lt;/code&gt; 을 사용 하여 표현식을 복제하므로 비표준 &lt;code&gt;Clone&lt;/code&gt; 구현 이있는 유형에 이것을 사용해야합니다 . 예를 들어, &lt;code&gt;vec![Rc::new(1); 5]&lt;/code&gt; 는 독립적 인 박스형 정수를 가리키는 5 개의 기준이 아니라 동일한 박스형 정수 값에 대한 5 개의 기준으로 구성된 벡터를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1af0f8715542d97c1e40ad188906242d9ebb10f7" translate="yes" xml:space="preserve">
          <source>This works because &lt;code&gt;Box&lt;/code&gt; is a pointer, so its size is well-known.</source>
          <target state="translated">이것은 &lt;code&gt;Box&lt;/code&gt; 가 포인터 이기 때문에 작동하므로 크기가 잘 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6ae7145b95212826784b081e816d005693796fd" translate="yes" xml:space="preserve">
          <source>This works differently from defining a struct that uses a generic type parameter with trait bounds. A generic type parameter can only be substituted with one concrete type at a time, whereas trait objects allow for multiple concrete types to fill in for the trait object at runtime. For example, we could have defined the &lt;code&gt;Screen&lt;/code&gt; struct using a generic type and a trait bound as in Listing 17-6:</source>
          <target state="translated">이것은 특성 범위와 함께 제네릭 형식 매개 변수를 사용하는 구조체를 정의하는 것과 다르게 작동합니다. 일반 유형 매개 변수는 한 번에 하나의 콘크리트 유형으로 만 대체 할 수있는 반면, 특성 오브젝트는 런타임에 특성 오브젝트에 여러 콘크리트 유형을 채울 수 있습니다. 예를 들어, Listing 17-6에서와 같이 제네릭 형식과 특성 바인딩을 사용하여 &lt;code&gt;Screen&lt;/code&gt; 구조체를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a99f3af5ecd17821d147ce27f764af7ca400396e" translate="yes" xml:space="preserve">
          <source>This works fine, but when the method gains generic parameters, we can have a problem.</source>
          <target state="translated">이것은 잘 작동하지만 메서드가 일반 매개 변수를 얻으면 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d71531129bdd4b29a09ed683d862d9540e2e5d1c" translate="yes" xml:space="preserve">
          <source>This works just fine and explicitly produces the behavior shown in Figure 4-3, where the heap data &lt;em&gt;does&lt;/em&gt; get copied.</source>
          <target state="translated">이것은 잘 작동하며 그림 4-3에 표시된 것처럼 힙 데이터 &lt;em&gt;가&lt;/em&gt; 복사 되는 동작을 명시 적으로 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="bfbfb994099b13008a48f4d00df577d26e30661c" translate="yes" xml:space="preserve">
          <source>This works without any problems. Ownership is moved out, and nothing is deallocated.</source>
          <target state="translated">이것은 아무런 문제없이 작동합니다. 소유권이 철회되고 할당이 취소되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c438e4eca96ad10f658e6fd464bdd00bbab9e0b" translate="yes" xml:space="preserve">
          <source>This wrapper helps with explicitly documenting the drop order dependencies between fields of the type:</source>
          <target state="translated">이 랩퍼는 유형의 필드 사이의 삭제 순서 종속성을 명시 적으로 문서화하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="77c94458816b78e926120564c533b185a38f9981" translate="yes" xml:space="preserve">
          <source>This wrapper is 0-cost.</source>
          <target state="translated">이 포장지는 0 비용입니다.</target>
        </trans-unit>
        <trans-unit id="8adf6fbbeb84fc23d69997d38f588cc8535a0a6a" translate="yes" xml:space="preserve">
          <source>Though they both have scary names, &lt;code&gt;PhantomData&lt;/code&gt; and 'phantom types' are related, but not identical. A phantom type parameter is simply a type parameter which is never used. In Rust, this often causes the compiler to complain, and the solution is to add a &quot;dummy&quot; use by way of &lt;code&gt;PhantomData&lt;/code&gt;.</source>
          <target state="translated">둘 다 무서운 이름을 가지고 있지만 &lt;code&gt;PhantomData&lt;/code&gt; 와 'phantom 유형'은 관련되어 있지만 동일하지는 않습니다. 팬텀 유형 매개 변수는 결코 사용되지 않는 유형 매개 변수입니다. Rust에서 이것은 종종 컴파일러가 불평하게하며, 해결책은 &lt;code&gt;PhantomData&lt;/code&gt; 를 통해 &quot;더미&quot;사용을 추가하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="394004c26aaecc036ffcf91c8fc18935b18646a0" translate="yes" xml:space="preserve">
          <source>Though this example seems innocuous and easy to solve, the problem becomes clear when it encounters functions which consume the value:</source>
          <target state="translated">이 예제는 무해하고 해결하기 쉬운 것처럼 보이지만 값을 소비하는 함수가 발생하면 문제가 분명해집니다.</target>
        </trans-unit>
        <trans-unit id="68fc8c5fcce31dacdf37236f648493191d2504be" translate="yes" xml:space="preserve">
          <source>Though this method is safe for any two pointers, note that its result will be mostly useless if the two pointers aren't into the same allocated object, for example if they point to two different local variables.</source>
          <target state="translated">이 방법은 두 포인터에 대해 안전하지만 두 포인터가 동일한 할당 된 객체에 있지 않은 경우 (예 : 두 개의 다른 로컬 변수를 가리키는 경우) 결과는 대부분 쓸모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7863f7503e5377891a3b7452c7d6cc377d443fe7" translate="yes" xml:space="preserve">
          <source>Thread</source>
          <target state="translated">Thread</target>
        </trans-unit>
        <trans-unit id="b66b6cbe04365929e922b75680e179e46127f3a3" translate="yes" xml:space="preserve">
          <source>Thread Safety</source>
          <target state="translated">스레드 안전</target>
        </trans-unit>
        <trans-unit id="8acbe8abc881f5530528aa5ba52eb0a3d5f4e21c" translate="yes" xml:space="preserve">
          <source>Thread factory, which can be used in order to configure the properties of a new thread.</source>
          <target state="translated">새 스레드의 속성을 구성하기 위해 사용할 수있는 스레드 팩토리.</target>
        </trans-unit>
        <trans-unit id="3f259cba637903dc7da0506c4d921b66c4b2c1d2" translate="yes" xml:space="preserve">
          <source>Thread with a specified name:</source>
          <target state="translated">지정된 이름의 스레드 :</target>
        </trans-unit>
        <trans-unit id="ccd9cecfbe050ef8f7199536919145c98a9ee01e" translate="yes" xml:space="preserve">
          <source>Thread-local storage</source>
          <target state="translated">스레드 로컬 스토리지</target>
        </trans-unit>
        <trans-unit id="031ccc205829651d22cb916d91b65f0a8f208375" translate="yes" xml:space="preserve">
          <source>Thread::borrow</source>
          <target state="translated">Thread::borrow</target>
        </trans-unit>
        <trans-unit id="c95c792ba6b184afddca7a8e36aefd1fbf1d6ade" translate="yes" xml:space="preserve">
          <source>Thread::borrow_mut</source>
          <target state="translated">Thread::borrow_mut</target>
        </trans-unit>
        <trans-unit id="dbb6daabaec761c7c46cdca4426de7d2af20b09f" translate="yes" xml:space="preserve">
          <source>Thread::clone</source>
          <target state="translated">Thread::clone</target>
        </trans-unit>
        <trans-unit id="e27a758e7d203684411b93372f7af767f3888a92" translate="yes" xml:space="preserve">
          <source>Thread::clone_from</source>
          <target state="translated">Thread::clone_from</target>
        </trans-unit>
        <trans-unit id="21aa2dd81c0fa05128232b310f0bc9892cddef0b" translate="yes" xml:space="preserve">
          <source>Thread::clone_into</source>
          <target state="translated">Thread::clone_into</target>
        </trans-unit>
        <trans-unit id="070b95410e1e4362fb02748c2208a536c3a47c62" translate="yes" xml:space="preserve">
          <source>Thread::fmt</source>
          <target state="translated">Thread::fmt</target>
        </trans-unit>
        <trans-unit id="15bec62911f03b003cb69d406b3848ca01770f8f" translate="yes" xml:space="preserve">
          <source>Thread::from</source>
          <target state="translated">Thread::from</target>
        </trans-unit>
        <trans-unit id="4a91eeba81f613beaaf6029aae0e32dad80d38b8" translate="yes" xml:space="preserve">
          <source>Thread::id</source>
          <target state="translated">Thread::id</target>
        </trans-unit>
        <trans-unit id="b2a4ffaaac236ade773000faaa7bef3c1f0cc8f6" translate="yes" xml:space="preserve">
          <source>Thread::into</source>
          <target state="translated">Thread::into</target>
        </trans-unit>
        <trans-unit id="344f7d7a1faf3f99cb05399e695391adc35f7d18" translate="yes" xml:space="preserve">
          <source>Thread::name</source>
          <target state="translated">Thread::name</target>
        </trans-unit>
        <trans-unit id="2dcbcae4f337ba144bfa61f602dbf53a215ffbaa" translate="yes" xml:space="preserve">
          <source>Thread::to_owned</source>
          <target state="translated">Thread::to_owned</target>
        </trans-unit>
        <trans-unit id="08e8a562777dded639d27f7f44cfadcf3bf00a5e" translate="yes" xml:space="preserve">
          <source>Thread::try_from</source>
          <target state="translated">Thread::try_from</target>
        </trans-unit>
        <trans-unit id="ea003eda575d811cf577619ef02836592885180a" translate="yes" xml:space="preserve">
          <source>Thread::try_into</source>
          <target state="translated">Thread::try_into</target>
        </trans-unit>
        <trans-unit id="ee3875fc112ad5bc121f3e391fcecb3da4daa377" translate="yes" xml:space="preserve">
          <source>Thread::type_id</source>
          <target state="translated">Thread::type_id</target>
        </trans-unit>
        <trans-unit id="a2b67a0f80271fce8e8b3bd5ec25f2445ebea8c7" translate="yes" xml:space="preserve">
          <source>Thread::unpark</source>
          <target state="translated">Thread::unpark</target>
        </trans-unit>
        <trans-unit id="cd1b87b64abdd5b00fbed5a0cf0c46e8cabde3e0" translate="yes" xml:space="preserve">
          <source>ThreadId</source>
          <target state="translated">ThreadId</target>
        </trans-unit>
        <trans-unit id="e1f6247a7eef6633e4e5d83608be9b3187e0c969" translate="yes" xml:space="preserve">
          <source>ThreadId::borrow</source>
          <target state="translated">ThreadId::borrow</target>
        </trans-unit>
        <trans-unit id="22f5c0c99a3c51f5db8e51f093d172c44439f9bc" translate="yes" xml:space="preserve">
          <source>ThreadId::borrow_mut</source>
          <target state="translated">ThreadId::borrow_mut</target>
        </trans-unit>
        <trans-unit id="f272ac73f50e66007497d727840b4334ee1f128b" translate="yes" xml:space="preserve">
          <source>ThreadId::clone</source>
          <target state="translated">ThreadId::clone</target>
        </trans-unit>
        <trans-unit id="6c35d53945f00e081a8257913c3ad292495b0c89" translate="yes" xml:space="preserve">
          <source>ThreadId::clone_from</source>
          <target state="translated">ThreadId::clone_from</target>
        </trans-unit>
        <trans-unit id="9abe12a7685c82abc8d5bcbb6509a690fccefb0b" translate="yes" xml:space="preserve">
          <source>ThreadId::clone_into</source>
          <target state="translated">ThreadId::clone_into</target>
        </trans-unit>
        <trans-unit id="1fcd1d752fe2d53f1b3acff5f74fcaa56fbea5a4" translate="yes" xml:space="preserve">
          <source>ThreadId::eq</source>
          <target state="translated">ThreadId::eq</target>
        </trans-unit>
        <trans-unit id="02c70e2223708a5777dae53420e0c974498720e0" translate="yes" xml:space="preserve">
          <source>ThreadId::fmt</source>
          <target state="translated">ThreadId::fmt</target>
        </trans-unit>
        <trans-unit id="b838b903c39a24240409358be89ed6329a9df09a" translate="yes" xml:space="preserve">
          <source>ThreadId::from</source>
          <target state="translated">ThreadId::from</target>
        </trans-unit>
        <trans-unit id="ddc023441f52408bece6bf2ff774b50209750066" translate="yes" xml:space="preserve">
          <source>ThreadId::hash</source>
          <target state="translated">ThreadId::hash</target>
        </trans-unit>
        <trans-unit id="8244a05f09ebefd9016fbce0f8394db6f762584b" translate="yes" xml:space="preserve">
          <source>ThreadId::hash_slice</source>
          <target state="translated">ThreadId::hash_slice</target>
        </trans-unit>
        <trans-unit id="fd5bfcfa29d7d00b83774a3201acbc0e51fa4872" translate="yes" xml:space="preserve">
          <source>ThreadId::into</source>
          <target state="translated">ThreadId::into</target>
        </trans-unit>
        <trans-unit id="a87f4470467c3e753de867438c3b5d2edf68e527" translate="yes" xml:space="preserve">
          <source>ThreadId::ne</source>
          <target state="translated">ThreadId::ne</target>
        </trans-unit>
        <trans-unit id="3cd41ae993fc3fddaa9fb843d50a8938bb01dd02" translate="yes" xml:space="preserve">
          <source>ThreadId::to_owned</source>
          <target state="translated">ThreadId::to_owned</target>
        </trans-unit>
        <trans-unit id="c7ce06f7b4875caccd8b2ef7310bb3589387aaa7" translate="yes" xml:space="preserve">
          <source>ThreadId::try_from</source>
          <target state="translated">ThreadId::try_from</target>
        </trans-unit>
        <trans-unit id="1723d15638b0712b0610f447b496de925bf9fce1" translate="yes" xml:space="preserve">
          <source>ThreadId::try_into</source>
          <target state="translated">ThreadId::try_into</target>
        </trans-unit>
        <trans-unit id="586fd641683540c80a212ba3dd698b0a2d8e64c3" translate="yes" xml:space="preserve">
          <source>ThreadId::type_id</source>
          <target state="translated">ThreadId::type_id</target>
        </trans-unit>
        <trans-unit id="c8f829eec28b00e160b939476f6112a322b89854" translate="yes" xml:space="preserve">
          <source>Threads are able to have associated names for identification purposes. By default, spawned threads are unnamed. To specify a name for a thread, build the thread with &lt;a href=&quot;struct.builder&quot;&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;/a&gt; and pass the desired thread name to &lt;a href=&quot;struct.builder#method.name&quot;&gt;&lt;code&gt;Builder::name&lt;/code&gt;&lt;/a&gt;. To retrieve the thread name from within the thread, use &lt;a href=&quot;struct.thread#method.name&quot;&gt;&lt;code&gt;Thread::name&lt;/code&gt;&lt;/a&gt;. A couple examples of where the name of a thread gets used:</source>
          <target state="translated">스레드는 식별을 위해 연관된 이름을 가질 수 있습니다. 기본적으로 생성 된 스레드는 이름이 없습니다. 스레드의 이름을 지정하려면 &lt;a href=&quot;struct.builder&quot;&gt; &lt;code&gt;Builder&lt;/code&gt; &lt;/a&gt; 로 스레드를 빌드 하고 원하는 스레드 이름을 &lt;a href=&quot;struct.builder#method.name&quot;&gt; &lt;code&gt;Builder::name&lt;/code&gt; &lt;/a&gt; 전달하십시오 . 스레드 내에서 스레드 이름을 검색하려면 &lt;a href=&quot;struct.thread#method.name&quot;&gt; &lt;code&gt;Thread::name&lt;/code&gt; &lt;/a&gt; . 스레드 이름이 사용되는 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="fac19ffa706cd7f7c61cd4298da14db7d3225341" translate="yes" xml:space="preserve">
          <source>Threads are represented via the &lt;a href=&quot;struct.thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt; type, which you can get in one of two ways:</source>
          <target state="translated">스레드는 &lt;a href=&quot;struct.thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt; 유형을 통해 표시되며 두 가지 방법 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfac2e4a30b24c7a0b51fc7ce730d2b041ad7fac" translate="yes" xml:space="preserve">
          <source>Threads are represented via the &lt;code&gt;Thread&lt;/code&gt; type, which you can get in one of two ways:</source>
          <target state="translated">스레드는 &lt;code&gt;Thread&lt;/code&gt; 유형을 통해 표시되며 두 가지 방법 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61ca9f4a8a357e814dec07995e4960f9fb1789c1" translate="yes" xml:space="preserve">
          <source>Threads by default have no name specified:</source>
          <target state="translated">스레드에는 기본적으로 이름이 지정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="968a06f03211a8e28589507e83ecbad68bacd321" translate="yes" xml:space="preserve">
          <source>Three examples of &lt;code&gt;extern crate&lt;/code&gt; declarations:</source>
          <target state="translated">&lt;code&gt;extern crate&lt;/code&gt; 선언 의 세 가지 예 :</target>
        </trans-unit>
        <trans-unit id="adf3f084c350f9e4e1af9b596fea76609465c5c2" translate="yes" xml:space="preserve">
          <source>Throughout the book, you&amp;rsquo;ve seen examples of many kinds of patterns. In this section, we gather all the syntax valid in patterns and discuss why you might want to use each one.</source>
          <target state="translated">이 책 전체에서 여러 가지 패턴의 예를 보았습니다. 이 섹션에서는 패턴에 유효한 모든 구문을 수집하고 각 구문을 사용하려는 이유에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="60bf7601d61de03ae0783bd8d23bcd9c972360eb" translate="yes" xml:space="preserve">
          <source>Throughout the documentation, we will follow a few conventions. For all operations, the collection's size is denoted by n. If another collection is involved in the operation, it contains m elements. Operations which have an &lt;em&gt;amortized&lt;/em&gt; cost are suffixed with a &lt;code&gt;*&lt;/code&gt;. Operations with an &lt;em&gt;expected&lt;/em&gt; cost are suffixed with a &lt;code&gt;~&lt;/code&gt;.</source>
          <target state="translated">문서 전체에서 몇 가지 규칙을 따릅니다. 모든 작업에서 컬렉션의 크기는 n으로 표시됩니다. 작업에 다른 컬렉션이 포함 된 경우 m 개의 요소가 포함됩니다. &lt;em&gt;상각 후원&lt;/em&gt; 이있는 작업 에는 &lt;code&gt;*&lt;/code&gt; 가 붙습니다 . &lt;em&gt;예상&lt;/em&gt; 비용이 포함 된 작업 에는 &lt;code&gt;~&lt;/code&gt; 가 붙습니다 .</target>
        </trans-unit>
        <trans-unit id="238f30330684e8f9c133d5faa32478b32bb7092d" translate="yes" xml:space="preserve">
          <source>Throughout this book, we&amp;rsquo;ve used &lt;code&gt;let&lt;/code&gt; like this hundreds of times, and although you might not have realized it, you were using patterns! More formally, a &lt;code&gt;let&lt;/code&gt; statement looks like this:</source>
          <target state="translated">이 책 전반에 걸쳐, 우리는 사용했습니다 &lt;code&gt;let&lt;/code&gt; 시간의 수백처럼, 당신이 그것을 실현하지 않을 수도 있지만, 당신은 패턴을 사용했다! 보다 공식적으로 &lt;code&gt;let&lt;/code&gt; 문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3b79edbe5b3429757c6a6c5658f9e500a2a9f5f8" translate="yes" xml:space="preserve">
          <source>Thus the pattern of &lt;code&gt;yield&lt;/code&gt;ing after a failed poll is rather common when implementing low-level shared resources or synchronization primitives.</source>
          <target state="translated">따라서 폴링 실패 후의 &lt;code&gt;yield&lt;/code&gt; 패턴은 저수준 공유 자원 또는 동기화 프리미티브를 구현할 때 다소 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="821dfcf79b1432754988865d9447fbfdba546e04" translate="yes" xml:space="preserve">
          <source>Thus, &lt;code&gt;ref&lt;/code&gt; is not something that is being matched against. Its objective is exclusively to make the matched binding a reference, instead of potentially copying or moving what was matched.</source>
          <target state="translated">따라서 &lt;code&gt;ref&lt;/code&gt; 은 상대가되는 것이 아닙니다. 일치하는 내용을 복사하거나 이동하는 대신 일치하는 바인딩을 참조로 만드는 것이 배타적입니다.</target>
        </trans-unit>
        <trans-unit id="bbe716d48d812e780f5d0c025cd7d8e8d137e139" translate="yes" xml:space="preserve">
          <source>Thus:</source>
          <target state="translated">Thus:</target>
        </trans-unit>
        <trans-unit id="667c88e4323d998577ae614b3d0f0d63105deed4" translate="yes" xml:space="preserve">
          <source>Time complexity</source>
          <target state="translated">시간 복잡성</target>
        </trans-unit>
        <trans-unit id="87e54a385b9de69cf35ac4ab359d69ed9aa1950a" translate="yes" xml:space="preserve">
          <source>To &lt;code id=&quot;to-panic-or-not-to-panic&quot;&gt;panic!&lt;/code&gt; or Not to &lt;code&gt;panic!&lt;/code&gt;</source>
          <target state="translated">하려면 &lt;code id=&quot;to-panic-or-not-to-panic&quot;&gt;panic!&lt;/code&gt; 또는 &lt;code&gt;panic!&lt;/code&gt; 하지 마십시오!</target>
        </trans-unit>
        <trans-unit id="6c0ba38264d0a297ae9df50179b24027837bbba6" translate="yes" xml:space="preserve">
          <source>To add &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt;, we specify &lt;code&gt;impl Add&amp;lt;Meters&amp;gt;&lt;/code&gt; to set the value of the &lt;code&gt;RHS&lt;/code&gt; type parameter instead of using the default of &lt;code&gt;Self&lt;/code&gt;.</source>
          <target state="translated">추가하려면 &lt;code&gt;Millimeters&lt;/code&gt; 및 &lt;code&gt;Meters&lt;/code&gt; , 우리는 지정 &lt;code&gt;impl Add&amp;lt;Meters&amp;gt;&lt;/code&gt; 의 값을 설정하는 &lt;code&gt;RHS&lt;/code&gt; 의 형식 매개 변수를 대신 기본 사용 &lt;code&gt;Self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48e27f28761495c993b1d146a55214b33393a503" translate="yes" xml:space="preserve">
          <source>To allow customization in specific cases most users won&amp;rsquo;t need</source>
          <target state="translated">특정 경우에 사용자 정의를 허용하기 위해 대부분의 사용자는 필요하지 않습니다</target>
        </trans-unit>
        <trans-unit id="b1d5c30e2acf4bd68628daf0a08fcdb7d03b4380" translate="yes" xml:space="preserve">
          <source>To assist with proper design, the following scenarios are explicitly declared legal for single-threaded code:</source>
          <target state="translated">적절한 설계를 지원하기 위해 다음 시나리오는 단일 스레드 코드에 대해 합법적으로 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="3ff5f80d30f1f493faf134bdcac7192bc4fe0c89" translate="yes" xml:space="preserve">
          <source>To avoid a memory leak the pointer must be converted back to an &lt;code&gt;Arc&lt;/code&gt; using &lt;a href=&quot;struct.arc#method.from_raw&quot;&gt;&lt;code&gt;Arc::from_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">메모리 누수를 피하려면 &lt;a href=&quot;struct.arc#method.from_raw&quot;&gt; &lt;code&gt;Arc::from_raw&lt;/code&gt; &lt;/a&gt; 사용하여 포인터를 다시 &lt;code&gt;Arc&lt;/code&gt; 로 변환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c1e40b418899dc58e251a0e3e3662f5034b84fa8" translate="yes" xml:space="preserve">
          <source>To avoid a memory leak the pointer must be converted back to an &lt;code&gt;Rc&lt;/code&gt; using &lt;a href=&quot;struct.rc#method.from_raw&quot;&gt;&lt;code&gt;Rc::from_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">메모리 누수를 방지하기 위해 포인터가로 변환 다시해야 &lt;code&gt;Rc&lt;/code&gt; 를 사용하여 &lt;a href=&quot;struct.rc#method.from_raw&quot;&gt; &lt;code&gt;Rc::from_raw&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a5ee855a608ecd864fa2e7b73853f23dfbb067b" translate="yes" xml:space="preserve">
          <source>To avoid creating &lt;code&gt;&amp;amp;mut [T]&lt;/code&gt; references that alias, the returned slice borrows its lifetime from the iterator the method is applied on.</source>
          <target state="translated">&lt;code&gt;&amp;amp;mut [T]&lt;/code&gt; 참조가 해당 별명을 작성하지 않도록하기 위해 리턴 된 슬라이스는 메소드가 적용된 반복자에서 수명을 차용합니다.</target>
        </trans-unit>
        <trans-unit id="ffa0cd99296c4663ce93793ddad7c9407847a5e2" translate="yes" xml:space="preserve">
          <source>To avoid creating &lt;code&gt;&amp;amp;mut&lt;/code&gt; references that alias, this is forced to consume the iterator.</source>
          <target state="translated">별명에 대한 &lt;code&gt;&amp;amp;mut&lt;/code&gt; 참조를 작성하지 않으려면 반복자를 소비해야합니다.</target>
        </trans-unit>
        <trans-unit id="1aefc821eaa401be8625ea8100fecfc992fdeed8" translate="yes" xml:space="preserve">
          <source>To avoid having &lt;code&gt;common&lt;/code&gt; appear in the test output, instead of creating &lt;em&gt;tests/common.rs&lt;/em&gt;, we&amp;rsquo;ll create &lt;em&gt;tests/common/mod.rs&lt;/em&gt;. This is an alternate naming convention that Rust also understands. Naming the file this way tells Rust not to treat the &lt;code&gt;common&lt;/code&gt; module as an integration test file. When we move the &lt;code&gt;setup&lt;/code&gt; function code into &lt;em&gt;tests/common/mod.rs&lt;/em&gt; and delete the &lt;em&gt;tests/common.rs&lt;/em&gt; file, the section in the test output will no longer appear. Files in subdirectories of the &lt;em&gt;tests&lt;/em&gt; directory don&amp;rsquo;t get compiled as separate crates or have sections in the test output.</source>
          <target state="translated">않도록하려면 &lt;code&gt;common&lt;/code&gt; 대신 작성하는 테스트 출력에 표시 &lt;em&gt;테스트 / common.rs을&lt;/em&gt; , 우리가 만듭니다 &lt;em&gt;시험 / 일반 / mod.rs을&lt;/em&gt; . 이것은 Rust도 이해하는 대체 명명 규칙입니다. 이 방법으로 파일 이름을 지정하면 Rust는 &lt;code&gt;common&lt;/code&gt; 모듈을 통합 테스트 파일로 취급하지 않습니다 . &lt;code&gt;setup&lt;/code&gt; 기능 코드를 &lt;em&gt;tests / common / mod.rs&lt;/em&gt; 로 이동하고 &lt;em&gt;tests / common.rs&lt;/em&gt; 파일을 삭제 하면 테스트 출력의 섹션이 더 이상 나타나지 않습니다. &lt;em&gt;tests&lt;/em&gt; 디렉토리의 서브 디렉토리에있는 파일은 별도의 상자로 컴파일되거나 테스트 출력에 섹션이 없습니다.</target>
        </trans-unit>
        <trans-unit id="97ceede3cc5738536ea015edb67ed85c3d3dcd2e" translate="yes" xml:space="preserve">
          <source>To avoid this error, you have to keep only one of them and remove the others. So let's take our example and fix it:</source>
          <target state="translated">이 오류를 피하려면 그 중 하나만 유지하고 다른 것을 제거해야합니다. 예를 들어서 고쳐 봅시다 :</target>
        </trans-unit>
        <trans-unit id="a30b99a191595831b8cb7e0383bc895012a3666a" translate="yes" xml:space="preserve">
          <source>To avoid this kind of error, ensure that at least one local type is referenced by the &lt;code&gt;impl&lt;/code&gt;:</source>
          <target state="translated">이러한 종류의 오류를 피하려면 &lt;code&gt;impl&lt;/code&gt; 에서 하나 이상의 로컬 유형을 참조해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a83579bf275c61511e259b0f6a5393712638d88c" translate="yes" xml:space="preserve">
          <source>To avoid those issues, you have to make the types match correctly. So we can fix the previous examples like this:</source>
          <target state="translated">이러한 문제를 피하려면 유형이 올바르게 일치해야합니다. 따라서 이전 예제를 다음과 같이 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cca79e59af2d0e450f9f7893d8b74973a17a0c1" translate="yes" xml:space="preserve">
          <source>To be able to index into a type it needs to implement the &lt;code&gt;std::ops::Index&lt;/code&gt; trait. Example:</source>
          <target state="translated">유형으로 색인을 생성하려면 &lt;code&gt;std::ops::Index&lt;/code&gt; 특성 을 구현해야합니다 . 예:</target>
        </trans-unit>
        <trans-unit id="e0c4569eca23f12e74ce8e43ea0b16ae30221104" translate="yes" xml:space="preserve">
          <source>To be clear: most features will be available on all editions. Developers using any Rust edition will continue to see improvements as new stable releases are made. However, in some cases, mainly when new keywords are added, some new features might only be available in later editions. You will need to switch editions if you want to take advantage of such features.</source>
          <target state="translated">명확하게 : 대부분의 기능은 모든 버전에서 사용할 수 있습니다. Rust 에디션을 사용하는 개발자는 새로운 안정 버전이 출시됨에 따라 계속 개선 될 것입니다. 그러나 경우에 따라 주로 새 키워드가 추가 될 때 일부 새로운 기능은 이후 버전에서만 사용할 수 있습니다. 이러한 기능을 이용하려면 에디션을 전환해야합니다.</target>
        </trans-unit>
        <trans-unit id="28519d7825ab9ef768276a220fcc5248c6cfd08d" translate="yes" xml:space="preserve">
          <source>To be valid, a matcher must meet the following three invariants. The definitions of FIRST and FOLLOW are described later.</source>
          <target state="translated">유효하려면 매 처가 다음 세 가지 불변량을 충족해야합니다. FIRST 및 FOLLOW의 정의는 나중에 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d27f02149ea4da378573490ec467ba6b8b5c842f" translate="yes" xml:space="preserve">
          <source>To better understand why we need two separate loops, imagine a scenario with two workers. If we used a single loop to iterate through each worker, on the first iteration a terminate message would be sent down the channel and &lt;code&gt;join&lt;/code&gt; called on the first worker&amp;rsquo;s thread. If that first worker was busy processing a request at that moment, the second worker would pick up the terminate message from the channel and shut down. We would be left waiting on the first worker to shut down, but it never would because the second thread picked up the terminate message. Deadlock!</source>
          <target state="translated">왜 두 개의 개별 루프가 필요한지 더 잘 이해하려면 두 명의 작업자가있는 시나리오를 상상하십시오. 우리가 첫 번째 반복에 각 직원을 반복하는 하나의 루프를 사용하면 종료 메시지가 채널 아래로 전송되는 및 &lt;code&gt;join&lt;/code&gt; 최초의 노동자의 스레드에서 호출. 첫 번째 작업자가 그 순간에 요청을 처리하는 중이라면 두 번째 작업자는 채널에서 종료 메시지를 가져 와서 종료합니다. 첫 번째 작업자가 종료되기를 기다리지 만 두 번째 스레드가 종료 메시지를 선택했기 때문에 절대 종료되지 않습니다. 이중 자물쇠!</target>
        </trans-unit>
        <trans-unit id="a92bd1b796549d070a95e516f74d8da028284983" translate="yes" xml:space="preserve">
          <source>To bind the matched value of a pattern to a variable, use the syntax &lt;code&gt;variable @ subpattern&lt;/code&gt;. For example, the following binds the value 2 to &lt;code&gt;e&lt;/code&gt; (not the entire range: the range here is a range subpattern).</source>
          <target state="translated">패턴의 일치하는 값을 변수에 바인딩하려면 구문 &lt;code&gt;variable @ subpattern&lt;/code&gt; 사용하십시오 . 예를 들어, 다음은 값 2를 &lt;code&gt;e&lt;/code&gt; 에 바인딩합니다 (전체 범위가 아님 : 여기서 범위는 범위 하위 패턴 임).</target>
        </trans-unit>
        <trans-unit id="b830c9413c38579d4ef7795bcf7bbde269208939" translate="yes" xml:space="preserve">
          <source>To build or modify paths, use &lt;a href=&quot;struct.pathbuf&quot;&gt;&lt;code&gt;PathBuf&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">경로를 작성하거나 수정하려면 &lt;a href=&quot;struct.pathbuf&quot;&gt; &lt;code&gt;PathBuf&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a716f5c06d1b56904d9c9ecdfaef8a89e71a7435" translate="yes" xml:space="preserve">
          <source>To calculate the value of &lt;code&gt;prediction&lt;/code&gt;, this code iterates through each of the 12 values in &lt;code&gt;coefficients&lt;/code&gt; and uses the &lt;code&gt;zip&lt;/code&gt; method to pair the coefficient values with the previous 12 values in &lt;code&gt;buffer&lt;/code&gt;. Then, for each pair, we multiply the values together, sum all the results, and shift the bits in the sum &lt;code&gt;qlp_shift&lt;/code&gt; bits to the right.</source>
          <target state="translated">&lt;code&gt;prediction&lt;/code&gt; 값을 계산하기 위해이 코드는 &lt;code&gt;coefficients&lt;/code&gt; 의 12 개 값 각각을 반복 하고 &lt;code&gt;zip&lt;/code&gt; 방법을 사용 하여 계수 값을 &lt;code&gt;buffer&lt;/code&gt; 의 이전 12 개 값과 쌍을 이룹니다 . 그런 다음 각 쌍에 대해 값을 곱하고 모든 결과를 합산하고 합계 &lt;code&gt;qlp_shift&lt;/code&gt; 비트의 비트를 오른쪽으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="e1e36c60ac0b0cf3c0b11863470e32d28a059d98" translate="yes" xml:space="preserve">
          <source>To call the &lt;code&gt;fly&lt;/code&gt; methods from either the &lt;code&gt;Pilot&lt;/code&gt; trait or the &lt;code&gt;Wizard&lt;/code&gt; trait, we need to use more explicit syntax to specify which &lt;code&gt;fly&lt;/code&gt; method we mean. Listing 19-18 demonstrates this syntax.</source>
          <target state="translated">&lt;code&gt;Pilot&lt;/code&gt; 특성 또는 &lt;code&gt;Wizard&lt;/code&gt; 특성 에서 &lt;code&gt;fly&lt;/code&gt; 메소드 를 호출하려면 더 명확한 구문을 사용하여 의미 하는 &lt;code&gt;fly&lt;/code&gt; 메소드 를 지정해야 합니다. Listing 19-18은이 구문을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5c07c5eaca75954c044b220e0d9378c6ce45b1a4" translate="yes" xml:space="preserve">
          <source>To call this associated function, we use the &lt;code&gt;::&lt;/code&gt; syntax with the struct name; &lt;code&gt;let sq = Rectangle::square(3);&lt;/code&gt; is an example. This function is namespaced by the struct: the &lt;code&gt;::&lt;/code&gt; syntax is used for both associated functions and namespaces created by modules. We&amp;rsquo;ll discuss modules in Chapter 7.</source>
          <target state="translated">이와 관련된 함수를 호출하기 위해 구조체 이름과 함께 &lt;code&gt;::&lt;/code&gt; 구문을 사용합니다 . &lt;code&gt;let sq = Rectangle::square(3);&lt;/code&gt; 예입니다. 이 함수는 구조체에 의해 네임 스페이스가 지정됩니다. &lt;code&gt;::&lt;/code&gt; 구문은 관련 함수와 모듈에 의해 생성 된 네임 스페이스 모두에 사용됩니다. 7 장에서 모듈에 대해 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="191c93d8beeacd6897f106d1c47af3f257c7dd5f" translate="yes" xml:space="preserve">
          <source>To call this code with only those types that implement the &lt;code&gt;Copy&lt;/code&gt; trait, we can add &lt;code&gt;Copy&lt;/code&gt; to the trait bounds of &lt;code&gt;T&lt;/code&gt;! Listing 10-15 shows the complete code of a generic &lt;code&gt;largest&lt;/code&gt; function that will compile as long as the types of the values in the slice that we pass into the function implement the &lt;code&gt;PartialOrd&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;Copy&lt;/code&gt; traits, like &lt;code&gt;i32&lt;/code&gt; and &lt;code&gt;char&lt;/code&gt; do.</source>
          <target state="translated">&lt;code&gt;Copy&lt;/code&gt; 특성 을 구현하는 유형으로 만이 코드를 호출 하기 위해 &lt;code&gt;T&lt;/code&gt; 의 특성 범위에 &lt;code&gt;Copy&lt;/code&gt; 를 추가 할 수 있습니다 ! 코드 10-15는 함수에 전달하는 슬라이스의 값 유형이 &lt;code&gt;i32&lt;/code&gt; 및 &lt;code&gt;char&lt;/code&gt; 처럼 &lt;code&gt;PartialOrd&lt;/code&gt; &lt;em&gt;및 &lt;/em&gt; &lt;code&gt;Copy&lt;/code&gt; 특성을 구현하는 한 컴파일되는 &lt;code&gt;largest&lt;/code&gt; 일반 함수 의 전체 코드를 보여줍니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2ae7caef9479d77c77a3d3a0a7f430defd27a454" translate="yes" xml:space="preserve">
          <source>To change the value that the mutable reference refers to, we have to use the dereference operator (&lt;code&gt;*&lt;/code&gt;) to get to the value in &lt;code&gt;i&lt;/code&gt; before we can use the &lt;code&gt;+=&lt;/code&gt; operator. We&amp;rsquo;ll talk more about the dereference operator in the &lt;a href=&quot;ch15-02-deref#following-the-pointer-to-the-value-with-the-dereference-operator&quot;&gt;&amp;ldquo;Following the Pointer to the Value with the Dereference Operator&amp;rdquo;&lt;/a&gt; section of Chapter 15.</source>
          <target state="translated">변경 가능한 참조가 참조하는 값을 변경하려면 &lt;code&gt;+=&lt;/code&gt; 연산자를 사용하기 전에 역 참조 연산자 ( &lt;code&gt;*&lt;/code&gt; )를 사용하여 &lt;code&gt;i&lt;/code&gt; 의 값을 가져와야합니다. 15 장의 &lt;a href=&quot;ch15-02-deref#following-the-pointer-to-the-value-with-the-dereference-operator&quot;&gt;&quot;역 참조 연산자를 사용하여 포인터를 값에 따라 가기&quot;&lt;/a&gt; 섹션 에서 역 참조 연산자에 대해 자세히 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="ff93ea5d521caed491ca6edf931b71effa3ca726" translate="yes" xml:space="preserve">
          <source>To check whether you have Rust installed correctly, open a shell and enter this line:</source>
          <target state="translated">Rust가 올바르게 설치되었는지 확인하려면 쉘을 열고 다음 줄을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="b81a5a29868dab97f44f48c2bd716ec3edc16d7e" translate="yes" xml:space="preserve">
          <source>To combine &lt;code&gt;repr(transparent)&lt;/code&gt; with type parameters, &lt;code&gt;PhantomData&lt;/code&gt; may be useful:</source>
          <target state="translated">&lt;code&gt;repr(transparent)&lt;/code&gt; 을 형식 매개 변수와 결합하려면 &lt;code&gt;PhantomData&lt;/code&gt; 가 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac3f03b22205947cc54e2019b2f0993969841a80" translate="yes" xml:space="preserve">
          <source>To confuse things further, &lt;a href=&quot;https://encoding.spec.whatwg.org/&quot;&gt;on the Web&lt;/a&gt;&lt;code&gt;ascii&lt;/code&gt;, &lt;code&gt;iso-8859-1&lt;/code&gt;, and &lt;code&gt;windows-1252&lt;/code&gt; are all aliases for a superset of Windows-1252 that fills the remaining blanks with corresponding C0 and C1 control codes.</source>
          <target state="translated">더 자세한 내용을 혼동하기 위해 &lt;a href=&quot;https://encoding.spec.whatwg.org/&quot;&gt;웹 &lt;/a&gt; &lt;code&gt;ascii&lt;/code&gt; , &lt;code&gt;iso-8859-1&lt;/code&gt; 및 &lt;code&gt;windows-1252&lt;/code&gt; 는 나머지 공백을 해당 C0 및 C1 제어 코드로 채우는 Windows-1252의 상위 집합에 대한 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="9e961e97b1bab5bb4d05da5fe7c2fc74357a8b93" translate="yes" xml:space="preserve">
          <source>To consume the old state, the &lt;code&gt;request_review&lt;/code&gt; method needs to take ownership of the state value. This is where the &lt;code&gt;Option&lt;/code&gt; in the &lt;code&gt;state&lt;/code&gt; field of &lt;code&gt;Post&lt;/code&gt; comes in: we call the &lt;code&gt;take&lt;/code&gt; method to take the &lt;code&gt;Some&lt;/code&gt; value out of the &lt;code&gt;state&lt;/code&gt; field and leave a &lt;code&gt;None&lt;/code&gt; in its place, because Rust doesn&amp;rsquo;t let us have unpopulated fields in structs. This lets us move the &lt;code&gt;state&lt;/code&gt; value out of &lt;code&gt;Post&lt;/code&gt; rather than borrowing it. Then we&amp;rsquo;ll set the post&amp;rsquo;s &lt;code&gt;state&lt;/code&gt; value to the result of this operation.</source>
          <target state="translated">이전 상태를 사용하려면 &lt;code&gt;request_review&lt;/code&gt; 메소드가 상태 값의 소유권을 가져와야 합니다. 여기 에서 &lt;code&gt;Post&lt;/code&gt; 의 &lt;code&gt;state&lt;/code&gt; 필드에 &lt;code&gt;Option&lt;/code&gt; 이 나온다 : 우리는 &lt;code&gt;take&lt;/code&gt; 메소드를 호출 하여 &lt;code&gt;state&lt;/code&gt; 필드 에서 &lt;code&gt;Some&lt;/code&gt; 값을 빼고 &lt;code&gt;None&lt;/code&gt; 을 그 자리에 남겨둔다 . 이를 통해 &lt;code&gt;state&lt;/code&gt; 값을 빌리지 않고 &lt;code&gt;Post&lt;/code&gt; 밖으로 옮길 수 있습니다 . 그런 다음 게시물의 &lt;code&gt;state&lt;/code&gt; 값을이 작업의 결과로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="f337e083c37a19b6c9f78383e9d486a4274f1380" translate="yes" xml:space="preserve">
          <source>To control whether interfaces can be used across modules, Rust checks each use of an item to see whether it should be allowed or not. This is where privacy warnings are generated, or otherwise &quot;you used a private item of another module and weren't allowed to.&quot;</source>
          <target state="translated">Rust는 모듈에서 인터페이스를 사용할 수 있는지 여부를 제어하기 위해 항목의 각 사용을 검사하여 허용 여부를 확인합니다. 개인 정보 보호 경고가 생성되는 곳입니다. 그렇지 않으면 &quot;다른 모듈의 개인 항목을 사용했지만 허용되지 않았습니다.&quot;</target>
        </trans-unit>
        <trans-unit id="ba21f5abea5c571067a1a7d57de3d3aa5bc54641" translate="yes" xml:space="preserve">
          <source>To convert a single value to a string, use the &lt;a href=&quot;../string/trait.tostring&quot;&gt;&lt;code&gt;to_string&lt;/code&gt;&lt;/a&gt; method. This will use the &lt;a href=&quot;trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; formatting trait.</source>
          <target state="translated">단일 값을 문자열로 변환하려면 &lt;a href=&quot;../string/trait.tostring&quot;&gt; &lt;code&gt;to_string&lt;/code&gt; &lt;/a&gt; 메소드를 사용하십시오 . &lt;a href=&quot;trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt; 형식 특성을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="3cb338cb9ed195af952f18624a8d65c1ca64787f" translate="yes" xml:space="preserve">
          <source>To convert a single value to a string, use the &lt;a href=&quot;string/trait.tostring&quot;&gt;&lt;code&gt;to_string&lt;/code&gt;&lt;/a&gt; method. This will use the &lt;a href=&quot;fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; formatting trait.</source>
          <target state="translated">단일 값을 문자열로 변환하려면 &lt;a href=&quot;string/trait.tostring&quot;&gt; &lt;code&gt;to_string&lt;/code&gt; &lt;/a&gt; 메소드를 사용하십시오 . &lt;a href=&quot;fmt/trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt; 형식 특성을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="015234ea3f6220712aedf5ea26711d734042f76e" translate="yes" xml:space="preserve">
          <source>To create a &lt;code&gt;match&lt;/code&gt; expression that compares the values of the outer &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, rather than introducing a shadowed variable, we would need to use a match guard conditional instead. We&amp;rsquo;ll talk about match guards later in the &lt;a href=&quot;#extra-conditionals-with-match-guards&quot;&gt;&amp;ldquo;Extra Conditionals with Match Guards&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">음영 처리 된 변수를 도입하지 않고 외부 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 값을 비교 하는 &lt;code&gt;match&lt;/code&gt; 표현식 을 작성하려면 대신 일치 가드 조건을 사용해야합니다. 나중에 &lt;a href=&quot;#extra-conditionals-with-match-guards&quot;&gt;&amp;ldquo;&lt;/a&gt; 경비대가있는 추가 조건부&amp;rdquo; 섹션 에서 성냥 대에 대해 이야기하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="d6a361bf034a44065bf4d983adf9bd5159e505a7" translate="yes" xml:space="preserve">
          <source>To create a new thread, we call the &lt;code&gt;thread::spawn&lt;/code&gt; function and pass it a closure (we talked about closures in Chapter 13) containing the code we want to run in the new thread. The example in Listing 16-1 prints some text from a main thread and other text from a new thread:</source>
          <target state="translated">새 스레드를 만들려면 &lt;code&gt;thread::spawn&lt;/code&gt; 함수를 호출 하고 새 스레드에서 실행할 코드가 포함 된 클로저 (제 13 장에서 클로저에 대해 이야기했습니다)를 전달합니다. Listing 16-1의 예제는 메인 스레드에서 일부 텍스트를 인쇄하고 새 스레드에서 다른 텍스트를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="aa89b2295fcdc6f9c080aa3a4a8e8468c77980e1" translate="yes" xml:space="preserve">
          <source>To create a new, empty vector, we can call the &lt;code&gt;Vec::new&lt;/code&gt; function, as shown in Listing 8-1.</source>
          <target state="translated">비어있는 새 벡터를 만들려면 목록 8-1에 표시된 것처럼 &lt;code&gt;Vec::new&lt;/code&gt; 함수를 호출하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="1a88aa76c7ad4f90214c55053637e980f11dd3a9" translate="yes" xml:space="preserve">
          <source>To create a vector and then add elements to it, we can use the &lt;code&gt;push&lt;/code&gt; method, as shown in Listing 8-3.</source>
          <target state="translated">벡터를 생성 한 다음 벡터를 추가하기 위해 &lt;code&gt;push&lt;/code&gt; 방법을 사용할 수 있습니다 ( Listing 8-3 참조).</target>
        </trans-unit>
        <trans-unit id="00c0015adacecd8350d6133979871ae1b1edfe94" translate="yes" xml:space="preserve">
          <source>To define a &lt;code&gt;Point&lt;/code&gt; struct where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both generics but could have different types, we can use multiple generic type parameters. For example, in Listing 10-8, we can change the definition of &lt;code&gt;Point&lt;/code&gt; to be generic over types &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; is of type &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is of type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 모두 제네릭이지만 다른 유형을 가질 수 있는 &lt;code&gt;Point&lt;/code&gt; 구조체 를 정의하기 위해 여러 제네릭 형식 매개 변수를 사용할 수 있습니다. 예를 들어, 목록 10-8에서 &lt;code&gt;Point&lt;/code&gt; 의 정의를 유형 &lt;code&gt;T&lt;/code&gt; 및 &lt;code&gt;U&lt;/code&gt; 에서 일반으로 변경하고 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;T&lt;/code&gt; 유형 이고 &lt;code&gt;y&lt;/code&gt; 는 &lt;code&gt;U&lt;/code&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="48e3d6adfbf70e45f3b29de0115bced82f45c8ba" translate="yes" xml:space="preserve">
          <source>To define a macro, you use the &lt;code&gt;macro_rules!&lt;/code&gt; construct. Let&amp;rsquo;s explore how to use &lt;code&gt;macro_rules!&lt;/code&gt; by looking at how the &lt;code&gt;vec!&lt;/code&gt; macro is defined. Chapter 8 covered how we can use the &lt;code&gt;vec!&lt;/code&gt; macro to create a new vector with particular values. For example, the following macro creates a new vector containing three integers:</source>
          <target state="translated">매크로를 정의하려면 &lt;code&gt;macro_rules!&lt;/code&gt; 구성합니다. &lt;code&gt;macro_rules!&lt;/code&gt; 사용법을 살펴 보자 ! &lt;code&gt;vec!&lt;/code&gt; 가 어떻게 보이는지보고 ! 매크로가 정의됩니다. 8 장에서는 &lt;code&gt;vec!&lt;/code&gt; 어떻게 사용할 수 있는지 설명했습니다 ! 매크로를 사용하여 특정 값으로 새 벡터를 만듭니다. 예를 들어 다음 매크로는 세 개의 정수를 포함하는 새 벡터를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0305c11d131bdcb2f62d25c1e047d31c7b279a29" translate="yes" xml:space="preserve">
          <source>To define a struct, we enter the keyword &lt;code&gt;struct&lt;/code&gt; and name the entire struct. A struct&amp;rsquo;s name should describe the significance of the pieces of data being grouped together. Then, inside curly brackets, we define the names and types of the pieces of data, which we call &lt;em&gt;fields&lt;/em&gt;. For example, Listing 5-1 shows a struct that stores information about a user account.</source>
          <target state="translated">구조체를 정의하기 위해 키워드 &lt;code&gt;struct&lt;/code&gt; 입력 하고 전체 구조체의 이름을 지정합니다. 구조체의 이름은 함께 그룹화되는 데이터 조각의 중요성을 설명해야합니다. 그런 다음 중괄호 안에 &lt;em&gt;필드&lt;/em&gt; 라고하는 데이터의 이름과 유형을 정의 &lt;em&gt;합니다&lt;/em&gt; . 예를 들어, 목록 5-1은 사용자 계정에 대한 정보를 저장하는 구조체를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="8f9b83d2cc8d6fc88b967504ac913c99c3032360" translate="yes" xml:space="preserve">
          <source>To define a tuple struct, start with the &lt;code&gt;struct&lt;/code&gt; keyword and the struct name followed by the types in the tuple. For example, here are definitions and usages of two tuple structs named &lt;code&gt;Color&lt;/code&gt; and &lt;code&gt;Point&lt;/code&gt;:</source>
          <target state="translated">튜플 구조체를 정의하려면 &lt;code&gt;struct&lt;/code&gt; 키워드와 구조체 이름으로 시작하고 튜플의 유형이 뒤 따릅니다. 예를 들어, &lt;code&gt;Color&lt;/code&gt; 와 &lt;code&gt;Point&lt;/code&gt; 라는 두 튜플 구조체의 정의와 사용법은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf22e9ab26d9ba6ee6b2e46fe0b19d5124fc0343" translate="yes" xml:space="preserve">
          <source>To define the function within the context of &lt;code&gt;Rectangle&lt;/code&gt;, we start an &lt;code&gt;impl&lt;/code&gt; (implementation) block. Then we move the &lt;code&gt;area&lt;/code&gt; function within the &lt;code&gt;impl&lt;/code&gt; curly brackets and change the first (and in this case, only) parameter to be &lt;code&gt;self&lt;/code&gt; in the signature and everywhere within the body. In &lt;code&gt;main&lt;/code&gt;, where we called the &lt;code&gt;area&lt;/code&gt; function and passed &lt;code&gt;rect1&lt;/code&gt; as an argument, we can instead use &lt;em&gt;method syntax&lt;/em&gt; to call the &lt;code&gt;area&lt;/code&gt; method on our &lt;code&gt;Rectangle&lt;/code&gt; instance. The method syntax goes after an instance: we add a dot followed by the method name, parentheses, and any arguments.</source>
          <target state="translated">&lt;code&gt;Rectangle&lt;/code&gt; 컨텍스트 내에서 함수를 정의 하기 위해 &lt;code&gt;impl&lt;/code&gt; (구현) 블록을 시작합니다 . 그런 다음 &lt;code&gt;area&lt;/code&gt; 함수를 &lt;code&gt;impl&lt;/code&gt; 중괄호 내에서 이동하고 첫 번째 (이 경우에만) 매개 변수를 서명 &lt;code&gt;self&lt;/code&gt; 와 본문 내 임의의 위치로 변경합니다. 에서 &lt;code&gt;main&lt;/code&gt; 우리가 호출 된 경우, &lt;code&gt;area&lt;/code&gt; 기능과 통과 &lt;code&gt;rect1&lt;/code&gt; 인수로를, 우리는 대신 사용할 수있는 &lt;em&gt;방법 구문을&lt;/em&gt; 부르는하기 위해 &lt;code&gt;area&lt;/code&gt; 우리의 방법을 &lt;code&gt;Rectangle&lt;/code&gt; 인스턴스입니다. 메소드 구문은 인스턴스를 따릅니다. 점 뒤에 메소드 이름, 괄호 및 인수를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="2de6b544c44b76668f6d2936d8d501f7f9f3abad" translate="yes" xml:space="preserve">
          <source>To demonstrate how to run a subset of tests, we&amp;rsquo;ll create three tests for our &lt;code&gt;add_two&lt;/code&gt; function, as shown in Listing 11-11, and choose which ones to run.</source>
          <target state="translated">테스트 서브 세트를 실행하는 방법을 보여주기 위해 Listing 11-11에 표시된 것처럼 &lt;code&gt;add_two&lt;/code&gt; 함수에 대해 세 가지 테스트를 작성하고 실행할 테스트를 선택한다.</target>
        </trans-unit>
        <trans-unit id="e75dc3dfe6b153a0ceea282766b5c4d1615452e1" translate="yes" xml:space="preserve">
          <source>To demonstrate, let&amp;rsquo;s create an iterator that will only ever count from 1 to 5. First, we&amp;rsquo;ll create a struct to hold some values. Then we&amp;rsquo;ll make this struct into an iterator by implementing the &lt;code&gt;Iterator&lt;/code&gt; trait and using the values in that implementation.</source>
          <target state="translated">시연을 위해 1에서 5까지만 계산되는 반복자를 만들어 봅시다. 먼저, 일부 값을 보유하는 구조체를 만듭니다. 그런 다음 &lt;code&gt;Iterator&lt;/code&gt; 특성을 구현하고 해당 구현의 값을 사용 하여이 구조체를 반복자로 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="b6b548838142d67d34f12bfbc64f7cdb12a47cc6" translate="yes" xml:space="preserve">
          <source>To determine how much space to allocate for a &lt;code&gt;Message&lt;/code&gt; value, Rust goes through each of the variants to see which variant needs the most space. Rust sees that &lt;code&gt;Message::Quit&lt;/code&gt; doesn&amp;rsquo;t need any space, &lt;code&gt;Message::Move&lt;/code&gt; needs enough space to store two &lt;code&gt;i32&lt;/code&gt; values, and so forth. Because only one variant will be used, the most space a &lt;code&gt;Message&lt;/code&gt; value will need is the space it would take to store the largest of its variants.</source>
          <target state="translated">&lt;code&gt;Message&lt;/code&gt; 값 에 할당 할 공간의 양을 결정하기 위해 Rust는 각 변형을 검토하여 가장 많은 공간이 필요한 변형을 확인합니다. Rust는 &lt;code&gt;Message::Quit&lt;/code&gt; 공간이 필요하지 않고 &lt;code&gt;Message::Move&lt;/code&gt; 두 개의 &lt;code&gt;i32&lt;/code&gt; 값 등 을 저장하기에 충분한 공간이 필요하다는 것을 알았습니다 . 하나의 변형 만 사용되므로 &lt;code&gt;Message&lt;/code&gt; 값에 가장 필요한 공간은 가장 큰 변형을 저장하는 데 필요한 공간입니다.</target>
        </trans-unit>
        <trans-unit id="375df8edff8c14a24952e9e1d54e255a42b357a9" translate="yes" xml:space="preserve">
          <source>To determine if a &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Foo&lt;/code&gt;, we need to check if &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;Foo&lt;/code&gt;. However, to do this check, we need to determine that &lt;code&gt;Bar&amp;lt;Bar&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;Foo&lt;/code&gt;. To determine this, we check if &lt;code&gt;Bar&amp;lt;Bar&amp;lt;Bar&amp;lt;T&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;Foo&lt;/code&gt;, and so on. This is clearly a recursive requirement that can't be resolved directly.</source>
          <target state="translated">있는지 확인하려면 &lt;code&gt;T&lt;/code&gt; 가 있다 &lt;code&gt;Foo&lt;/code&gt; , 우리는 있는지 확인해야 할 &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; 입니다 &lt;code&gt;Foo&lt;/code&gt; . 그러나이 검사를 수행하려면 &lt;code&gt;Bar&amp;lt;Bar&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 가 &lt;code&gt;Foo&lt;/code&gt; 인지 확인해야합니다 . 이를 결정하기 위해 &lt;code&gt;Bar&amp;lt;Bar&amp;lt;Bar&amp;lt;T&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 가 &lt;code&gt;Foo&lt;/code&gt; 등 인지 확인합니다 . 이것은 직접적으로 해결할 수없는 재귀 요구 사항입니다.</target>
        </trans-unit>
        <trans-unit id="b8666f35753eb530d957bee0ef54848c41571aca" translate="yes" xml:space="preserve">
          <source>To determine the total number of seconds represented by the &lt;code&gt;Duration&lt;/code&gt;, use &lt;code&gt;as_secs&lt;/code&gt; in combination with &lt;a href=&quot;#method.subsec_nanos&quot;&gt;&lt;code&gt;subsec_nanos&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">에 의해 표현되는 초 총 수를 확인하려면 &lt;code&gt;Duration&lt;/code&gt; , 사용 &lt;code&gt;as_secs&lt;/code&gt; 와 함께 &lt;a href=&quot;#method.subsec_nanos&quot;&gt; &lt;code&gt;subsec_nanos&lt;/code&gt; 를&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="1c73fc588227a5e5b304d8e85115a9b2d547b13e" translate="yes" xml:space="preserve">
          <source>To determine whether to use loops or iterators, you need to know which version of our &lt;code&gt;search&lt;/code&gt; functions is faster: the version with an explicit &lt;code&gt;for&lt;/code&gt; loop or the version with iterators.</source>
          <target state="translated">루프 또는 반복자를 사용할지 여부를 판별하려면 명시적인 &lt;code&gt;for&lt;/code&gt; 루프 가 있는 버전 또는 반복자가있는 버전 인 &lt;code&gt;search&lt;/code&gt; 기능의 버전이 더 빠른지 알아야 합니다.</target>
        </trans-unit>
        <trans-unit id="235f6ddc8fb93b9bc27bd450e93516c6f056381f" translate="yes" xml:space="preserve">
          <source>To disambiguate and tell Rust that we want to use the implementation of &lt;code&gt;Animal&lt;/code&gt; for &lt;code&gt;Dog&lt;/code&gt;, we need to use fully qualified syntax. Listing 19-21 demonstrates how to use fully qualified syntax.</source>
          <target state="translated">Rust에게 우리가 &lt;code&gt;Animal&lt;/code&gt; for &lt;code&gt;Dog&lt;/code&gt; 구현을 사용하고 싶다고 명확하게 말하려면 정규화 된 구문을 사용해야합니다. Listing 19-21은 정규화 된 구문을 사용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="f6bc5e83e5f978fc7521ec1ad0ec48fc0bc1e6d4" translate="yes" xml:space="preserve">
          <source>To do this in a language with inheritance, we might define a class named &lt;code&gt;Component&lt;/code&gt; that has a method named &lt;code&gt;draw&lt;/code&gt; on it. The other classes, such as &lt;code&gt;Button&lt;/code&gt;, &lt;code&gt;Image&lt;/code&gt;, and &lt;code&gt;SelectBox&lt;/code&gt;, would inherit from &lt;code&gt;Component&lt;/code&gt; and thus inherit the &lt;code&gt;draw&lt;/code&gt; method. They could each override the &lt;code&gt;draw&lt;/code&gt; method to define their custom behavior, but the framework could treat all of the types as if they were &lt;code&gt;Component&lt;/code&gt; instances and call &lt;code&gt;draw&lt;/code&gt; on them. But because Rust doesn&amp;rsquo;t have inheritance, we need another way to structure the &lt;code&gt;gui&lt;/code&gt; library to allow users to extend it with new types.</source>
          <target state="translated">상속 된 언어로이를 수행하기 위해 &lt;code&gt;draw&lt;/code&gt; 라는 메서드가있는 &lt;code&gt;Component&lt;/code&gt; 라는 클래스를 정의 할 수 있습니다 . &lt;code&gt;Button&lt;/code&gt; , &lt;code&gt;Image&lt;/code&gt; 및 &lt;code&gt;SelectBox&lt;/code&gt; 와 같은 다른 클래스 는 &lt;code&gt;Component&lt;/code&gt; 에서 상속하므로 &lt;code&gt;draw&lt;/code&gt; 메서드 를 상속합니다 . 이들은 각각 &lt;code&gt;draw&lt;/code&gt; 메소드를 재정 의하여 사용자 정의 동작을 정의 할 수 있지만 프레임 워크는 모든 유형을 마치 &lt;code&gt;Component&lt;/code&gt; 인스턴스 처럼 취급하고 &lt;code&gt;draw&lt;/code&gt; 를 호출 할 수 있습니다. 그러나 Rust에는 상속이 없으므로 사용자가 새로운 유형으로 확장 할 수 있도록 &lt;code&gt;gui&lt;/code&gt; 라이브러리를 구성하는 다른 방법이 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="4978131923d35532be220aa91636f57efe0f7f12" translate="yes" xml:space="preserve">
          <source>To easily implement the Clone trait, you can also use &lt;code&gt;#[derive(Clone)]&lt;/code&gt;. Example:</source>
          <target state="translated">복제 특성을 쉽게 구현하기 위해 &lt;code&gt;#[derive(Clone)]&lt;/code&gt; 사용할 수도 있습니다 . 예:</target>
        </trans-unit>
        <trans-unit id="d0cd2dd965d6ad9f646e83059dd95c728c0a97cf" translate="yes" xml:space="preserve">
          <source>To eliminate this duplication, we can create an abstraction by defining a function that operates on any list of integers given to it in a parameter. This solution makes our code clearer and lets us express the concept of finding the largest number in a list abstractly.</source>
          <target state="translated">이 중복을 제거하기 위해 매개 변수에 지정된 정수 목록에서 작동하는 함수를 정의하여 추상화를 작성할 수 있습니다. 이 솔루션을 사용하면 코드가 명확 해지고 목록에서 가장 큰 숫자를 찾는 개념을 추상적으로 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29cf48fa5d156f2e83366c6a4eab852452303d3f" translate="yes" xml:space="preserve">
          <source>To enable &lt;code&gt;minigrep&lt;/code&gt; to read the values of command line arguments we pass to it, we&amp;rsquo;ll need a function provided in Rust&amp;rsquo;s standard library, which is &lt;code&gt;std::env::args&lt;/code&gt;. This function returns an iterator of the command line arguments that were given to &lt;code&gt;minigrep&lt;/code&gt;. We&amp;rsquo;ll cover iterators fully in &lt;a href=&quot;ch13-00-functional-features&quot;&gt;Chapter 13&lt;/a&gt;. For now, you only need to know two details about iterators: iterators produce a series of values, and we can call the &lt;code&gt;collect&lt;/code&gt; method on an iterator to turn it into a collection, such as a vector, containing all the elements the iterator produces.</source>
          <target state="translated">&lt;code&gt;minigrep&lt;/code&gt; 이 전달하는 명령 행 인수의 값을 읽을 수있게하려면 Rust의 표준 라이브러리에 제공되는 함수 인 &lt;code&gt;std::env::args&lt;/code&gt; 합니다. 이 함수는 &lt;code&gt;minigrep&lt;/code&gt; 에 제공된 명령 행 인수의 반복자를 리턴합니다 . &lt;a href=&quot;ch13-00-functional-features&quot;&gt;13 장&lt;/a&gt; 에서 반복자를 완전히 다룰 것 입니다. 지금은 반복자에 대한 두 가지 세부 사항 만 알아야합니다. 반복자는 일련의 값을 생성하며 반복자에서 &lt;code&gt;collect&lt;/code&gt; 메소드를 호출 하여 반복자가 생성하는 모든 요소를 ​​포함하는 벡터와 같은 콜렉션으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad43deb7c3d4847ed4f9b3c47149e285bd2d149c" translate="yes" xml:space="preserve">
          <source>To enable multiple ownership, Rust has a type called &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;, which is an abbreviation for &lt;em&gt;reference counting&lt;/em&gt;. The &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; type keeps track of the number of references to a value which determines whether or not a value is still in use. If there are zero references to a value, the value can be cleaned up without any references becoming invalid.</source>
          <target state="translated">다중 소유권을 가능하게하기 위해 Rust에는 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 라는 유형 이 있으며 이는 &lt;em&gt;참조 횟수 계산&lt;/em&gt; 의 약어입니다 . &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 유형 값이 아직 사용 여부를 결정하는 값에 대한 참조 수를 추적한다. 값에 대한 참조가없는 경우 참조가 유효하지 않게 값을 정리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e59e1050701d5494b23014e46f9317fad2eac0b0" translate="yes" xml:space="preserve">
          <source>To enable this feature on a nightly version of rustc, add the &lt;code&gt;const_fn&lt;/code&gt; feature flag:</source>
          <target state="translated">야간 버전의 rustc에서이 기능을 사용하려면 &lt;code&gt;const_fn&lt;/code&gt; 기능 플래그를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="d24a8c41c8e51812d2f6a3d4df4d4bc30f42fd94" translate="yes" xml:space="preserve">
          <source>To ensure memory safety, there&amp;rsquo;s one more detail to what happens in this situation in Rust. Instead of trying to copy the allocated memory, Rust considers &lt;code&gt;s1&lt;/code&gt; to no longer be valid and, therefore, Rust doesn&amp;rsquo;t need to free anything when &lt;code&gt;s1&lt;/code&gt; goes out of scope. Check out what happens when you try to use &lt;code&gt;s1&lt;/code&gt; after &lt;code&gt;s2&lt;/code&gt; is created; it won&amp;rsquo;t work:</source>
          <target state="translated">메모리 안전을 보장하기 위해 Rust에서이 상황에서 발생하는 일에 대해 더 자세히 설명합니다. Rust는 할당 된 메모리를 복사하는 대신 &lt;code&gt;s1&lt;/code&gt; 이 더 이상 유효하지 않다고 간주 하므로 &lt;code&gt;s1&lt;/code&gt; 이 범위를 벗어날 때 아무것도 해제 할 필요가 없습니다 . &lt;code&gt;s2&lt;/code&gt; 가 작성된 후 &lt;code&gt;s1&lt;/code&gt; 을 사용하려고 할 때 어떤 일이 발생하는지 확인하십시오 . 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ccd9133d33f00e1b04fd5409b4bd62ab4182d4d" translate="yes" xml:space="preserve">
          <source>To extend a type without breaking existing code</source>
          <target state="translated">기존 코드를 손상시키지 않고 유형을 확장하려면</target>
        </trans-unit>
        <trans-unit id="986aa5a06f6c7eab4fbf8758ab21e34c28998b7b" translate="yes" xml:space="preserve">
          <source>To find the largest number in two different lists of numbers, we can duplicate the code in Listing 10-1 and use the same logic at two different places in the program, as shown in Listing 10-2.</source>
          <target state="translated">두 개의 서로 다른 숫자 목록에서 가장 큰 숫자를 찾으려면 목록 10-1에서 코드를 복제하고 목록 10-2에 표시된 것처럼 프로그램의 서로 다른 두 위치에서 동일한 논리를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05412e512ad05fb982373163c001384a6dc6dc41" translate="yes" xml:space="preserve">
          <source>To fix such code, put them in an extern &quot;C&quot; block:</source>
          <target state="translated">이러한 코드를 수정하려면 extern &quot;C&quot;블록에 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="3f641101a15aa5663f425af7eca864860358c2b4" translate="yes" xml:space="preserve">
          <source>To fix the compiler error in Listing 16-3, we can use the error message&amp;rsquo;s advice:</source>
          <target state="translated">Listing 16-3에서 컴파일러 오류를 수정하기 위해 오류 메시지의 조언을 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="9a70249adaf4eb50343b8e3cb8c112aee0c4394d" translate="yes" xml:space="preserve">
          <source>To fix the problem where we have a refutable pattern where an irrefutable pattern is needed, we can change the code that uses the pattern: instead of using &lt;code&gt;let&lt;/code&gt;, we can use &lt;code&gt;if let&lt;/code&gt;. Then if the pattern doesn&amp;rsquo;t match, the code will just skip the code in the curly brackets, giving it a way to continue validly. Listing 18-9 shows how to fix the code in Listing 18-8.</source>
          <target state="translated">우리가 반박 할 수없는 패턴이 필요로하는 논박 패턴이 문제를 해결하려면, 우리는 패턴을 사용하는 코드를 변경할 수 있습니다 대신에 사용하는 &lt;code&gt;let&lt;/code&gt; , 우리가 사용할 수있는 &lt;code&gt;if let&lt;/code&gt; . 그런 다음 패턴이 일치하지 않으면 코드는 중괄호 안에있는 코드를 건너 뛰어 계속 진행할 수있는 방법을 제공합니다. 코드 18-9는 코드 18-8에서 코드를 수정하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="3d38f12fb6a882b38564fce2f1f7c9cb9d1796dd" translate="yes" xml:space="preserve">
          <source>To fix the problem, either remove the unknown meta item, or rename it if you provided the wrong name.</source>
          <target state="translated">문제를 해결하려면 알 수없는 메타 항목을 제거하거나 이름이 잘못된 경우 이름을 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="ff15ef440d8fd65fc53847fcd7d27134b37684e0" translate="yes" xml:space="preserve">
          <source>To fix the problem, remove all but one of the meta items with the same key.</source>
          <target state="translated">문제를 해결하려면 동일한 키를 가진 메타 항목 중 하나를 제외한 모든 항목을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="ea6969ed4bf2de9ff5e1987bde2a5974361798c0" translate="yes" xml:space="preserve">
          <source>To fix this and consume the iterator, we&amp;rsquo;ll use the &lt;code&gt;collect&lt;/code&gt; method, which we used in Chapter 12 with &lt;code&gt;env::args&lt;/code&gt; in Listing 12-1. This method consumes the iterator and collects the resulting values into a collection data type.</source>
          <target state="translated">이 문제를 해결하고 반복자를 사용하기 &lt;code&gt;collect&lt;/code&gt; 12 장에서 &lt;code&gt;env::args&lt;/code&gt; 와 함께 사용하는 collect 메소드를 사용합니다 ( 목록 12-1). 이 메소드는 반복자를 사용하고 결과 값을 콜렉션 데이터 유형으로 수집합니다.</target>
        </trans-unit>
        <trans-unit id="14bc23db223a3a7adb6fd2ea01135a7a51e21b23" translate="yes" xml:space="preserve">
          <source>To fix this error, check that you didn't misspell the field's name or that the field actually exists. Example:</source>
          <target state="translated">이 오류를 해결하려면 필드 이름의 철자가 틀리지 않았거나 필드가 실제로 존재하는지 확인하십시오. 예:</target>
        </trans-unit>
        <trans-unit id="ec4c03a79b5dd9aa983287afa6ca9be17b72579d" translate="yes" xml:space="preserve">
          <source>To fix this error, don't try to cast directly between thin and fat pointers.</source>
          <target state="translated">이 오류를 해결하려면 얇은 포인터와 뚱뚱한 포인터 사이에 직접 캐스트하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="2cf449e499fd02815621561773f0782493f1f5ff" translate="yes" xml:space="preserve">
          <source>To fix this error, either split into multiple match arms:</source>
          <target state="translated">이 오류를 해결하려면 여러 개의 일치 암으로 분할하십시오.</target>
        </trans-unit>
        <trans-unit id="59d5e036d18215af29bf5d6026ec79c924cc4630" translate="yes" xml:space="preserve">
          <source>To fix this error, ensure that you don't have any other references to the variable before trying to access it mutably:</source>
          <target state="translated">이 오류를 해결하려면 변수에 변경하기 전에 변수에 대한 다른 참조가 없는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c41c6753158354db97000bee3e6d1e71d162a5c2" translate="yes" xml:space="preserve">
          <source>To fix this error, ensure the match arm kind is the same as the expression matched.</source>
          <target state="translated">이 오류를 해결하려면 일치 팔 종류가 일치하는 표현식과 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="0e0f8c883662f36aaeadf872304efd94871b85a2" translate="yes" xml:space="preserve">
          <source>To fix this error, just change the binding's name in order to avoid shadowing one of the following:</source>
          <target state="translated">이 오류를 해결하려면 다음 중 하나를 가리지 않도록 바인딩 이름을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="547cd595fdb912c2692881e0fc69f7e09c4e06b4" translate="yes" xml:space="preserve">
          <source>To fix this error, just specify the type of the variable. Example:</source>
          <target state="translated">이 오류를 해결하려면 변수 유형을 지정하십시오. 예:</target>
        </trans-unit>
        <trans-unit id="ac9826f4a5f0aca5be2cbd8435bee957e2a23961" translate="yes" xml:space="preserve">
          <source>To fix this error, just use the same mode in both cases. Generally using &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;ref mut&lt;/code&gt; where not already used will fix this:</source>
          <target state="translated">이 오류를 해결하려면 두 경우 모두 동일한 모드를 사용하십시오. 일반적으로 아직 사용되지 않은 &lt;code&gt;ref&lt;/code&gt; 또는 &lt;code&gt;ref mut&lt;/code&gt; 를 사용하면이 문제가 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="130e6cb76ab8ba2e39f9316003d15648f16e824e" translate="yes" xml:space="preserve">
          <source>To fix this error, please check that this type implements this binary operation. Example:</source>
          <target state="translated">이 오류를 해결하려면이 유형이 이진 연산을 구현하는지 확인하십시오. 예:</target>
        </trans-unit>
        <trans-unit id="5f8bccc6c37b14540562ff31ba77c03a4a691b62" translate="yes" xml:space="preserve">
          <source>To fix this error, please ensure that all the fields of the struct are public, or implement a function for easy instantiation. Examples:</source>
          <target state="translated">이 오류를 해결하려면 구조체의 모든 필드가 공용인지 확인하거나 쉽게 인스턴스화 할 수있는 기능을 구현하십시오. 예 :</target>
        </trans-unit>
        <trans-unit id="342e8c2f7a1ada9b484baabdc9d06d406ca80a54" translate="yes" xml:space="preserve">
          <source>To fix this error, please implement a trait on the type or wrap it in a struct. Example:</source>
          <target state="translated">이 오류를 해결하려면 유형에 특성을 구현하거나 구조체로 감싸십시오. 예:</target>
        </trans-unit>
        <trans-unit id="befadb1ed4ec4a8c074944e9002910bb635c2bda" translate="yes" xml:space="preserve">
          <source>To fix this error, please remove the visibility qualifier when it is not required. Example:</source>
          <target state="translated">이 오류를 해결하려면 필요하지 않은 가시성 한정자를 제거하십시오. 예:</target>
        </trans-unit>
        <trans-unit id="dd5bba6de2aa5f4e39e98433e92b409c0d3ccac5" translate="yes" xml:space="preserve">
          <source>To fix this error, please replace the value with a constant. Example:</source>
          <target state="translated">이 오류를 해결하려면 값을 상수로 바꾸십시오. 예:</target>
        </trans-unit>
        <trans-unit id="29332719480b2d3d455368380fd1815d30eebf29" translate="yes" xml:space="preserve">
          <source>To fix this error, please verify that the method name wasn't misspelled and verify that you are indeed implementing the correct trait items. Example:</source>
          <target state="translated">이 오류를 해결하려면 메소드 이름의 철자가 틀리지 않았는지 확인하고 올바른 특성 항목을 실제로 구현했는지 확인하십시오. 예:</target>
        </trans-unit>
        <trans-unit id="d6526d13f1c406efebc4022cedccc7bfc1d5dbc7" translate="yes" xml:space="preserve">
          <source>To fix this error, please verify you didn't misspell the type name, you did declare it or imported it into the scope. Examples:</source>
          <target state="translated">이 오류를 해결하려면 형식 이름의 철자가 틀리지 않았는지 확인하고 선언하거나 범위로 가져 오십시오. 예 :</target>
        </trans-unit>
        <trans-unit id="6da3993819cb20099d5b634dd66120eb7048a481" translate="yes" xml:space="preserve">
          <source>To fix this error, you can finish using the closure before using the captured variable:</source>
          <target state="translated">이 오류를 해결하려면 캡처 된 변수를 사용하기 전에 클로저 사용을 완료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d18371bc4c07ba0c41f6206f4861a5d76f0f6e55" translate="yes" xml:space="preserve">
          <source>To fix this error, you need to mark all the parent implementations as default. Example:</source>
          <target state="translated">이 오류를 해결하려면 모든 상위 구현을 기본값으로 표시해야합니다. 예:</target>
        </trans-unit>
        <trans-unit id="cf4fd1eefb95ff6d8562a2c0c639ea77e8a69e6e" translate="yes" xml:space="preserve">
          <source>To fix this issue, either use the lifetime in the arguments, or use &lt;code&gt;'static&lt;/code&gt;. Example:</source>
          <target state="translated">이 문제를 해결하려면 인수에서 수명을 사용하거나 &lt;code&gt;'static&lt;/code&gt; 을 사용하십시오 . 예:</target>
        </trans-unit>
        <trans-unit id="bb2e9d61c37258f8ed9cce9fe2929803d6d2313b" translate="yes" xml:space="preserve">
          <source>To fix this issue, either use the lifetime in the inputs, or use &lt;code&gt;'static&lt;/code&gt;. Example:</source>
          <target state="translated">이 문제를 해결하려면 입력에서 수명을 사용하거나 &lt;code&gt;'static&lt;/code&gt; 을 사용하십시오 . 예:</target>
        </trans-unit>
        <trans-unit id="47d656f4427ec08945a130e9ab24f44d356e73c6" translate="yes" xml:space="preserve">
          <source>To fix this issue, just remove the return keyword or move the expression into a function. Example:</source>
          <target state="translated">이 문제를 해결하려면 return 키워드를 제거하거나 표현식을 함수로 옮기십시오. 예:</target>
        </trans-unit>
        <trans-unit id="9924221c408a112fe763d167c1b4a29e5c450e04" translate="yes" xml:space="preserve">
          <source>To fix this issue, you have to rename at least one of the two imports. Example:</source>
          <target state="translated">이 문제를 해결하려면 두 가져 오기 중 적어도 하나의 이름을 바꿔야합니다. 예:</target>
        </trans-unit>
        <trans-unit id="8b92f6f0312b161fc6e42dd1de00eb946169f081" translate="yes" xml:space="preserve">
          <source>To fix this problem, we&amp;rsquo;ll modify the threads so they listen for either a &lt;code&gt;Job&lt;/code&gt; to run or a signal that they should stop listening and exit the infinite loop. Instead of &lt;code&gt;Job&lt;/code&gt; instances, our channel will send one of these two enum variants.</source>
          <target state="translated">이 문제를 해결하기 위해 스레드가 &lt;code&gt;Job&lt;/code&gt; 실행 을 수신 대기하거나 수신 대기를 중지하고 무한 루프를 종료해야한다는 신호를 수신하도록 스레드를 수정합니다 . &lt;code&gt;Job&lt;/code&gt; 인스턴스 대신 채널에서이 두 가지 열거 형 변형 중 하나를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="c3ddf887a4b5f979d5c4754fbe5d3842c28e8398" translate="yes" xml:space="preserve">
          <source>To fix this problem, you can do either of these things:</source>
          <target state="translated">이 문제를 해결하려면 다음 중 하나를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d1040dc78ad7b42b1b39bcb93179f38486776a0b" translate="yes" xml:space="preserve">
          <source>To fix this problem, you need to create a local variable to store the value in rather than relying on a temporary. For example, you might change the original program to the following:</source>
          <target state="translated">이 문제를 해결하려면 임시에 의존하지 않고 값을 저장할 로컬 변수를 작성해야합니다. 예를 들어, 원래 프로그램을 다음과 같이 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="360a9b00506f1addbb3267f917ea23dd8584e790" translate="yes" xml:space="preserve">
          <source>To fix this, add a label specifying which loop is being broken out of:</source>
          <target state="translated">이 문제를 해결하려면 어떤 루프가 끊어 졌는지 지정하는 레이블을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="4f4f5291163064ff6fda56abd889a7618c40d282" translate="yes" xml:space="preserve">
          <source>To fix this, add an implementation for each default method from the trait:</source>
          <target state="translated">이 문제를 해결하려면 특성에서 각 기본 메소드에 대한 구현을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="56a92651d517e6a1850a1ad3d4745e7b392eba21" translate="yes" xml:space="preserve">
          <source>To fix this, edit the &lt;em&gt;Cargo.toml&lt;/em&gt; file for the &lt;code&gt;adder&lt;/code&gt; crate and indicate that &lt;code&gt;rand&lt;/code&gt; is a dependency for that crate as well. Building the &lt;code&gt;adder&lt;/code&gt; crate will add &lt;code&gt;rand&lt;/code&gt; to the list of dependencies for &lt;code&gt;adder&lt;/code&gt; in &lt;em&gt;Cargo.lock&lt;/em&gt;, but no additional copies of &lt;code&gt;rand&lt;/code&gt; will be downloaded. Cargo has ensured that every crate in the workspace using the &lt;code&gt;rand&lt;/code&gt; crate will be using the same version. Using the same version of &lt;code&gt;rand&lt;/code&gt; across the workspace saves space because we won&amp;rsquo;t have multiple copies and ensures that the crates in the workspace will be compatible with each other.</source>
          <target state="translated">이 문제를 해결하려면 &lt;code&gt;adder&lt;/code&gt; 상자에 대한 &lt;em&gt;Cargo.toml&lt;/em&gt; 파일을 편집하고 &lt;code&gt;rand&lt;/code&gt; 도 해당 상자에 대한 종속성 임을 나타냅니다 . 건물 &lt;code&gt;adder&lt;/code&gt; 상자이 부가됩니다 &lt;code&gt;rand&lt;/code&gt; 에 대한 종속성 목록에 &lt;code&gt;adder&lt;/code&gt; 에 &lt;em&gt;Cargo.lock&lt;/em&gt; 만의 추가 사본 &lt;code&gt;rand&lt;/code&gt; 다운로드되지 않습니다. 화물은 &lt;code&gt;rand&lt;/code&gt; 크레이트를 사용하는 작업 공간의 모든 크레이트 가 동일한 버전을 사용하도록 보장했습니다 . 작업 공간 에서 동일한 버전의 &lt;code&gt;rand&lt;/code&gt; 를 사용하면 사본이 여러 개 없기 때문에 작업 공간의 상자가 서로 호환되므로 공간이 절약됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9dd753bd45e01fa10b5929e59eda068f06c82e05" translate="yes" xml:space="preserve">
          <source>To fix this, either remove the outer reference:</source>
          <target state="translated">이 문제를 해결하려면 외부 참조를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="cb0074c2565e11e981fa6efe9e6d5af9f075e607" translate="yes" xml:space="preserve">
          <source>To fix this, ensure that any declared variables are initialized before being used. Example:</source>
          <target state="translated">이 문제를 해결하려면 선언 된 변수를 사용하기 전에 초기화해야합니다. 예:</target>
        </trans-unit>
        <trans-unit id="437601cd4925a7106ff21615c74bc484d85aef14" translate="yes" xml:space="preserve">
          <source>To fix this, ensure that the name was correctly spelled, and that the correct form of initializer was used.</source>
          <target state="translated">이 문제를 해결하려면 이름의 철자가 정확하고 올바른 형식의 이니셜 라이저가 사용되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="890f488bd89f18960203be014ab27fb39dfc6d22" translate="yes" xml:space="preserve">
          <source>To fix this, it is suggested to use a &lt;code&gt;where Self: Sized&lt;/code&gt; bound similar to the fix for the sub-error above if you do not intend to call the method with type parameters:</source>
          <target state="translated">이 문제를 해결하려면 type 매개 변수를 사용하여 메서드를 호출하지 않으려는 경우 위의 하위 오류에 대한 수정과 비슷한 &lt;code&gt;where Self: Sized&lt;/code&gt; bound 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="c7b0cc36b1cf18605167b9e261109b879dd0c485" translate="yes" xml:space="preserve">
          <source>To fix this, please set manually the next enum value or put the enum variant with the maximum value at the end of the enum. Examples:</source>
          <target state="translated">이 문제를 해결하려면 다음 열거 형 값을 수동으로 설정하거나 열거 형 끝 부분에 열거 형 변형을 최대 값으로 설정하십시오. 예 :</target>
        </trans-unit>
        <trans-unit id="fa4bb08fcba49cd98aef8848abbf20a6a3f3bfcb" translate="yes" xml:space="preserve">
          <source>To fix this, replace the generic parameter with the specializations that you need:</source>
          <target state="translated">이 문제를 해결하려면 일반 매개 변수를 필요한 특수화로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="0f9e6f402abcaecb02615cbeb4f9eaf1b18503a7" translate="yes" xml:space="preserve">
          <source>To fix this, the value can be extracted as a const and then used:</source>
          <target state="translated">이 문제를 해결하기 위해 값을 const로 추출한 다음 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34e96f574d6d4b3f0139f4794453e1b644fdb7fa" translate="yes" xml:space="preserve">
          <source>To fix this, we implement &lt;code&gt;Display&lt;/code&gt; on &lt;code&gt;Point&lt;/code&gt; and satisfy the constraint that &lt;code&gt;OutlinePrint&lt;/code&gt; requires, like so:</source>
          <target state="translated">이 문제를 해결하기 위해 &lt;code&gt;Display&lt;/code&gt; on &lt;code&gt;Point&lt;/code&gt; 를 구현 하고 다음과 같이 &lt;code&gt;OutlinePrint&lt;/code&gt; 에 필요한 제약 조건을 충족합니다 .</target>
        </trans-unit>
        <trans-unit id="1afba8b0958bf7d54c00a1e357d6112f94820fbc" translate="yes" xml:space="preserve">
          <source>To fix this, you must reference the lifetime &lt;code&gt;'x&lt;/code&gt; from the return type. For example, changing the return type to &lt;code&gt;impl Trait&amp;lt;'y&amp;gt; + 'x&lt;/code&gt; would work:</source>
          <target state="translated">이 문제를 해결하려면 반환 유형에서 수명 &lt;code&gt;'x&lt;/code&gt; 를 참조해야합니다 . 예를 들어 반환 유형을 &lt;code&gt;impl Trait&amp;lt;'y&amp;gt; + 'x&lt;/code&gt; 하면 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b2c5b5034aa90905612a009b913793af12d3e3ac" translate="yes" xml:space="preserve">
          <source>To further refine the game&amp;rsquo;s behavior, rather than crashing the program when the user inputs a non-number, let&amp;rsquo;s make the game ignore a non-number so the user can continue guessing. We can do that by altering the line where &lt;code&gt;guess&lt;/code&gt; is converted from a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;u32&lt;/code&gt;, as shown in Listing 2-5.</source>
          <target state="translated">사용자가 숫자가 아닌 숫자를 입력 할 때 프로그램을 중단시키지 않고 게임의 동작을 더 세분화하기 위해, 숫자가 아닌 숫자를 무시하고 게임을 계속해서 추측 할 수 있습니다. Listing 2-5와 같이 &lt;code&gt;guess&lt;/code&gt; 이 &lt;code&gt;String&lt;/code&gt; 에서 &lt;code&gt;u32&lt;/code&gt; 로 변환되는 행을 변경하여이를 수행 할 수있다 .</target>
        </trans-unit>
        <trans-unit id="bea9207f63bde7916694d159ff6b4254f0892dc5" translate="yes" xml:space="preserve">
          <source>To get a mutable string slice instead, see the &lt;a href=&quot;#method.slice_mut_unchecked&quot;&gt;&lt;code&gt;slice_mut_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">대신 가변 문자열 슬라이스를 얻으려면 &lt;a href=&quot;#method.slice_mut_unchecked&quot;&gt; &lt;code&gt;slice_mut_unchecked&lt;/code&gt; &lt;/a&gt; 메소드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0238d96367a691acb632dbf4d73cc5fd2a706ad9" translate="yes" xml:space="preserve">
          <source>To get a pointer to a boxed value, dereference the box:</source>
          <target state="translated">상자 값에 대한 포인터를 얻으려면 상자를 역 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8f1e8a2f8899e777c3546c1b586cd81156849069" translate="yes" xml:space="preserve">
          <source>To get a specific value from a struct, we can use dot notation. If we wanted just this user&amp;rsquo;s email address, we could use &lt;code&gt;user1.email&lt;/code&gt; wherever we wanted to use this value. If the instance is mutable, we can change a value by using the dot notation and assigning into a particular field. Listing 5-3 shows how to change the value in the &lt;code&gt;email&lt;/code&gt; field of a mutable &lt;code&gt;User&lt;/code&gt; instance.</source>
          <target state="translated">구조체에서 특정 값을 얻으려면 점 표기법을 사용할 수 있습니다. 이 사용자의 전자 메일 주소 만 원하면이 값을 사용 &lt;code&gt;user1.email&lt;/code&gt; 모든 위치에서 user1.email을 사용할 수 있습니다 . 인스턴스가 변경 가능한 경우 점 표기법을 사용하고 특정 필드에 할당하여 값을 변경할 수 있습니다. Listing 5-3은 변경 가능한 &lt;code&gt;User&lt;/code&gt; 인스턴스 의 &lt;code&gt;email&lt;/code&gt; 필드 에서 값을 변경하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="ffd19be588eb8df1e329d2bc1905f6d517e8c370" translate="yes" xml:space="preserve">
          <source>To get an immutable string slice instead, see the &lt;a href=&quot;#method.slice_unchecked&quot;&gt;&lt;code&gt;slice_unchecked&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">대신 불변 문자열 슬라이스를 얻으려면 &lt;a href=&quot;#method.slice_unchecked&quot;&gt; &lt;code&gt;slice_unchecked&lt;/code&gt; &lt;/a&gt; 메소드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="29270bb604499679be31005db9630fdff3a329f3" translate="yes" xml:space="preserve">
          <source>To get immutable string slices instead, see the &lt;a href=&quot;#method.split_at&quot;&gt;&lt;code&gt;split_at&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">대신 불변 문자열 슬라이스를 얻으려면 &lt;a href=&quot;#method.split_at&quot;&gt; &lt;code&gt;split_at&lt;/code&gt; &lt;/a&gt; 메소드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d6bbcb0bb220df37e8c688ef821b8733765b09b5" translate="yes" xml:space="preserve">
          <source>To get mutable string slices instead, see the &lt;a href=&quot;#method.split_at_mut&quot;&gt;&lt;code&gt;split_at_mut&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">대신 가변 문자열 슬라이스를 얻으려면 &lt;a href=&quot;#method.split_at_mut&quot;&gt; &lt;code&gt;split_at_mut&lt;/code&gt; &lt;/a&gt; 메소드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2a0349cd0d37a5287741f4237e8c49df43c4e0c6" translate="yes" xml:space="preserve">
          <source>To get this out of the way: you should probably just use &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt;. These two collections cover most use cases for generic data storage and processing. They are exceptionally good at doing what they do. All the other collections in the standard library have specific use cases where they are the optimal choice, but these cases are borderline &lt;em&gt;niche&lt;/em&gt; in comparison. Even when &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;HashMap&lt;/code&gt; are technically suboptimal, they're probably a good enough choice to get started.</source>
          <target state="translated">이것을 &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; 을&lt;/a&gt; 사용해야 합니다. 이 두 컬렉션은 일반적인 데이터 저장 및 처리에 대한 대부분의 사용 사례를 다룹니다. 그들은 그들이하는 일을 매우 잘합니다. 표준 라이브러리의 다른 모든 컬렉션에는 최적의 선택 인 특정 사용 사례가 있지만 이러한 경우는 경계선의 &lt;em&gt;틈새&lt;/em&gt; 입니다. &lt;code&gt;Vec&lt;/code&gt; 과 &lt;code&gt;HashMap&lt;/code&gt; 이 기술적으로 차선책 일지라도 시작하기에 충분한 선택 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="18773042303056fd8c79476f3616f355ff443a51" translate="yes" xml:space="preserve">
          <source>To handle the error case and print a user-friendly message, we need to update &lt;code&gt;main&lt;/code&gt; to handle the &lt;code&gt;Result&lt;/code&gt; being returned by &lt;code&gt;Config::new&lt;/code&gt;, as shown in Listing 12-10. We&amp;rsquo;ll also take the responsibility of exiting the command line tool with a nonzero error code from &lt;code&gt;panic!&lt;/code&gt; and implement it by hand. A nonzero exit status is a convention to signal to the process that called our program that the program exited with an error state.</source>
          <target state="translated">오류 사례를 처리하고 사용자에게 친숙한 메시지를 인쇄하려면 목록 12-10에 표시된대로 &lt;code&gt;Config::new&lt;/code&gt; 에서 반환되는 &lt;code&gt;Result&lt;/code&gt; 를 처리하도록 &lt;code&gt;main&lt;/code&gt; 을 업데이트해야합니다 . 또한 &lt;code&gt;panic!&lt;/code&gt; 에서 0이 아닌 오류 코드로 명령 행 도구를 종료해야 할 책임이 있습니다 ! 손으로 구현하십시오. 0이 아닌 종료 상태는 프로그램이 오류 상태로 종료되었음을 프로그램이라고하는 프로세스에 알리는 규칙입니다.</target>
        </trans-unit>
        <trans-unit id="482ebf3be5fe8298225b2e8f09ccc5e7f7c51bf1" translate="yes" xml:space="preserve">
          <source>To help IDE integration, the Rust project distributes the &lt;em&gt;Rust Language Server&lt;/em&gt; (&lt;code&gt;rls&lt;/code&gt;). This tool speaks the &lt;a href=&quot;http://langserver.org/&quot;&gt;Language Server Protocol&lt;/a&gt;, which is a specification for IDEs and programming languages to communicate with each other. Different clients can use the &lt;code&gt;rls&lt;/code&gt;, such as &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=rust-lang.rust&quot;&gt;the Rust plug-in for Visual Studio Code&lt;/a&gt;.</source>
          <target state="translated">IDE 통합을 돕기 위해 Rust 프로젝트는 &lt;em&gt;Rust Language Server&lt;/em&gt; ( &lt;code&gt;rls&lt;/code&gt; )를 배포합니다 . 이 도구는 IDE와 프로그래밍 언어가 서로 통신하기위한 사양 인 &lt;a href=&quot;http://langserver.org/&quot;&gt;Language Server Protocol을&lt;/a&gt; 말합니다 . 다른 클라이언트는 &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=rust-lang.rust&quot;&gt;Visual Studio Code 용 Rust 플러그인&lt;/a&gt; 과 같은 &lt;code&gt;rls&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="20b8f11e3eb504aaf128f283d04500f6915052b5" translate="yes" xml:space="preserve">
          <source>To illustrate situations where closures that can capture their environment are useful as function parameters, let&amp;rsquo;s move on to our next topic: iterators.</source>
          <target state="translated">환경을 캡처 할 수있는 클로저가 함수 매개 변수로 유용한 상황을 설명하기 위해 다음 주제 인 반복자 (iterator)로 넘어가겠습니다.</target>
        </trans-unit>
        <trans-unit id="6bb8bf87527987f23e438b1c1bc78391e818826e" translate="yes" xml:space="preserve">
          <source>To illustrate the rules of ownership, we need a data type that is more complex than the ones we covered in the &lt;a href=&quot;ch03-02-data-types#data-types&quot;&gt;&amp;ldquo;Data Types&amp;rdquo;&lt;/a&gt; section of Chapter 3. The types covered previously are all stored on the stack and popped off the stack when their scope is over, but we want to look at data that is stored on the heap and explore how Rust knows when to clean up that data.</source>
          <target state="translated">소유권 규칙을 설명하기 위해, 우리는 3 장의 &lt;a href=&quot;ch03-02-data-types#data-types&quot;&gt;&quot;데이터 유형&quot;&lt;/a&gt; 섹션 에서 다루었던 것보다 복잡한 데이터 유형이 필요합니다. 이전에 다룬 유형은 모두 스택에 저장되고 해당 범위에서 스택에서 튀어 나옵니다. 끝났지 만 힙에 저장된 데이터를보고 Rust가 해당 데이터를 정리할시기를 어떻게 알고 있는지 조사하려고합니다.</target>
        </trans-unit>
        <trans-unit id="60712450a97e23097bf6dbe8ed26e2265884e8b7" translate="yes" xml:space="preserve">
          <source>To implement the behavior we want &lt;code&gt;gui&lt;/code&gt; to have, we&amp;rsquo;ll define a trait named &lt;code&gt;Draw&lt;/code&gt; that will have one method named &lt;code&gt;draw&lt;/code&gt;. Then we can define a vector that takes a &lt;em&gt;trait object&lt;/em&gt;. A trait object points to both an instance of a type implementing our specified trait as well as a table used to look up trait methods on that type at runtime. We create a trait object by specifying some sort of pointer, such as a &lt;code&gt;&amp;amp;&lt;/code&gt; reference or a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; smart pointer, then the &lt;code&gt;dyn&lt;/code&gt; keyword, and then specifying the relevant trait. (We&amp;rsquo;ll talk about the reason trait objects must use a pointer in Chapter 19 in the section &lt;a href=&quot;ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;&amp;ldquo;Dynamically Sized Types and the &lt;code&gt;Sized&lt;/code&gt; Trait.&amp;rdquo;&lt;/a&gt;) We can use trait objects in place of a generic or concrete type. Wherever we use a trait object, Rust&amp;rsquo;s type system will ensure at compile time that any value used in that context will implement the trait object&amp;rsquo;s trait. Consequently, we don&amp;rsquo;t need to know all the possible types at compile time.</source>
          <target state="translated">&lt;code&gt;gui&lt;/code&gt; 에 원하는 동작을 구현하기 위해 &lt;code&gt;draw&lt;/code&gt; 라는 메소드가있는 &lt;code&gt;Draw&lt;/code&gt; 라는 특성을 정의합니다 . 그런 다음 &lt;em&gt;특성 객체&lt;/em&gt; 를 취하는 벡터를 정의 할 수 있습니다 . 특성 객체는 지정된 특성을 구현하는 유형의 인스턴스와 런타임시 해당 유형의 특성 메소드를 찾는 데 사용되는 테이블을 모두 가리 킵니다. &lt;code&gt;&amp;amp;&lt;/code&gt; reference 또는 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 스마트 포인터 와 같은 일종의 포인터 를 지정하고 &lt;code&gt;dyn&lt;/code&gt; 키워드를 지정한 다음 관련 특성을 지정하여 특성 개체를 만듭니다 . (특징 객체가 &lt;a href=&quot;ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;&quot;동적 크기의 유형과&lt;/a&gt; &quot; 섹션의 19 장에서 포인터를 사용해야하는 이유에 대해 설명합니다&lt;em&gt;&lt;/em&gt; &lt;code&gt;Sized&lt;/code&gt; 특성.&quot; ) 일반 또는 콘크리트 유형 대신 특성 객체를 사용할 수 있습니다. 우리가 형질 오브젝트를 사용하는 곳마다 Rust의 타입 시스템은 컴파일시에 해당 컨텍스트에 사용 된 모든 값이 형질 오브젝트의 특성을 구현하도록 보장합니다. 결과적으로 컴파일 타임에 가능한 모든 유형을 알 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="f5e8a5c28a454d1f90112a6c60c0f8aea2b5196d" translate="yes" xml:space="preserve">
          <source>To improve our program, we&amp;rsquo;ll fix four problems that have to do with the program&amp;rsquo;s structure and how it&amp;rsquo;s handling potential errors.</source>
          <target state="translated">프로그램을 개선하기 위해 프로그램 구조와 관련된 네 가지 문제와 잠재적 오류를 처리하는 방법을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="bf9b4462d1a02f4d70e5d13cf8540c79a5e14d1a" translate="yes" xml:space="preserve">
          <source>To incorporate the &lt;code&gt;Message&lt;/code&gt; enum, we need to change &lt;code&gt;Job&lt;/code&gt; to &lt;code&gt;Message&lt;/code&gt; in two places: the definition of &lt;code&gt;ThreadPool&lt;/code&gt; and the signature of &lt;code&gt;Worker::new&lt;/code&gt;. The &lt;code&gt;execute&lt;/code&gt; method of &lt;code&gt;ThreadPool&lt;/code&gt; needs to send jobs wrapped in the &lt;code&gt;Message::NewJob&lt;/code&gt; variant. Then, in &lt;code&gt;Worker::new&lt;/code&gt; where a &lt;code&gt;Message&lt;/code&gt; is received from the channel, the job will be processed if the &lt;code&gt;NewJob&lt;/code&gt; variant is received, and the thread will break out of the loop if the &lt;code&gt;Terminate&lt;/code&gt; variant is received.</source>
          <target state="translated">&lt;code&gt;Message&lt;/code&gt; 열거 형 을 통합하려면 &lt;code&gt;ThreadPool&lt;/code&gt; 정의 와 &lt;code&gt;Worker::new&lt;/code&gt; 서명 두 위치에서 &lt;code&gt;Job&lt;/code&gt; to &lt;code&gt;Message&lt;/code&gt; 를 변경해야합니다 . &lt;code&gt;ThreadPool&lt;/code&gt; 의 &lt;code&gt;execute&lt;/code&gt; 메소드 는 &lt;code&gt;Message::NewJob&lt;/code&gt; 변형으로 랩핑 된 작업을 보내야 합니다. 그런 다음에 &lt;code&gt;Worker::new&lt;/code&gt; 여기서 &lt;code&gt;Message&lt;/code&gt; 경우 생성 채널로부터 수신되고, 작업을 처리한다 &lt;code&gt;NewJob&lt;/code&gt; 의 변이체를 수신하고, 만약 쓰레드가 루프를 탈출한다 &lt;code&gt;Terminate&lt;/code&gt; 변이체가 수신된다.</target>
        </trans-unit>
        <trans-unit id="0f9206704ddf29e2ebea715304ccfd9e3f3ba5f3" translate="yes" xml:space="preserve">
          <source>To install &lt;code&gt;rustfmt&lt;/code&gt;, enter the following:</source>
          <target state="translated">&lt;code&gt;rustfmt&lt;/code&gt; 를 설치하려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="35fe5fa9574aed79cc4c533785f5e0d142e0e320" translate="yes" xml:space="preserve">
          <source>To install Clippy, enter the following:</source>
          <target state="translated">Clippy를 설치하려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="44d584ca391c2045c83ab8a58e67b2e401ab33be" translate="yes" xml:space="preserve">
          <source>To install the &lt;code&gt;rls&lt;/code&gt;, enter the following:</source>
          <target state="translated">&lt;code&gt;rls&lt;/code&gt; 를 설치하려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="71a54c2518d0f86ead8ba016e32755cf1ca226ed" translate="yes" xml:space="preserve">
          <source>To interact with a &lt;code&gt;Formatter&lt;/code&gt;, you'll call various methods to change the various options related to formatting. For examples, please see the documentation of the methods defined on &lt;code&gt;Formatter&lt;/code&gt; below.</source>
          <target state="translated">&lt;code&gt;Formatter&lt;/code&gt; 와 상호 작용 하기 위해 다양한 메서드를 호출하여 형식과 관련된 다양한 옵션을 변경합니다. 예를 들어, 아래의 &lt;code&gt;Formatter&lt;/code&gt; 정의 된 메소드의 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b498caa788bb95865cf7ae29f319574a69dd854b" translate="yes" xml:space="preserve">
          <source>To isolate unsafe code as much as possible, it&amp;rsquo;s best to enclose unsafe code within a safe abstraction and provide a safe API, which we&amp;rsquo;ll discuss later in the chapter when we examine unsafe functions and methods. Parts of the standard library are implemented as safe abstractions over unsafe code that has been audited. Wrapping unsafe code in a safe abstraction prevents uses of &lt;code&gt;unsafe&lt;/code&gt; from leaking out into all the places that you or your users might want to use the functionality implemented with &lt;code&gt;unsafe&lt;/code&gt; code, because using a safe abstraction is safe.</source>
          <target state="translated">안전하지 않은 코드를 가능한 많이 격리하려면 안전하지 않은 코드를 안전한 추상화 내에 포함하고 안전한 API를 제공하는 것이 가장 좋습니다. 안전하지 않은 기능 및 방법을 검사 할 때이 장의 뒷부분에서 설명합니다. 표준 라이브러리의 일부는 감사 된 안전하지 않은 코드에 대한 안전한 추상화로 구현됩니다. 안전하지 않은 코드를 안전한 추상화로 감싸면 안전한 추상화 를 사용하는 것이 안전하기 때문에 &lt;code&gt;unsafe&lt;/code&gt; 코드 사용으로 안전 하지 않은 코드로 구현 된 기능을 사용하려는 모든 위치로 &lt;code&gt;unsafe&lt;/code&gt; 사용이 유출되는 것을 방지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a6753382b748af96b119a035edd05c7a836b948d" translate="yes" xml:space="preserve">
          <source>To learn about the other kinds of collections provided by the standard library, see &lt;a href=&quot;../std/collections/index&quot;&gt;the documentation&lt;/a&gt;.</source>
          <target state="translated">표준 라이브러리에서 제공하는 다른 종류의 컬렉션에 대한 자세한 내용 &lt;a href=&quot;../std/collections/index&quot;&gt;은 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2736d1e6ef2a3faad24038e53f6bde645f76d87" translate="yes" xml:space="preserve">
          <source>To lowercase ASCII characters in addition to non-ASCII characters, use &lt;a href=&quot;#method.to_lowercase&quot;&gt;&lt;code&gt;to_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비 ASCII 문자 외에 ASCII 문자를 소문자로 &lt;a href=&quot;#method.to_lowercase&quot;&gt; &lt;code&gt;to_lowercase&lt;/code&gt; &lt;/a&gt; 려면 to_lowercase를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="e94e0d4cfd63a504442f11c93df0afa614a2f0d4" translate="yes" xml:space="preserve">
          <source>To lowercase ASCII characters in addition to non-ASCII characters, use &lt;a href=&quot;../primitive.str#method.to_lowercase&quot;&gt;&lt;code&gt;str::to_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비 ASCII 문자 외에 ASCII 문자를 소문자로 만들려면 &lt;a href=&quot;../primitive.str#method.to_lowercase&quot;&gt; &lt;code&gt;str::to_lowercase&lt;/code&gt; &lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ab2513e3de2d60d109900818fb2429fd91b99d2" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">적절한 위치에 값을 소문자로 만들려면 &lt;a href=&quot;#method.make_ascii_lowercase&quot;&gt; &lt;code&gt;make_ascii_lowercase&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef146744579c27e21ed699daf39b3a3250767c77" translate="yes" xml:space="preserve">
          <source>To lowercase the value in-place, use &lt;a href=&quot;#tymethod.make_ascii_lowercase&quot;&gt;&lt;code&gt;make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">적절한 위치에 값을 소문자로 만들려면 &lt;a href=&quot;#tymethod.make_ascii_lowercase&quot;&gt; &lt;code&gt;make_ascii_lowercase&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="21e4a3f169edf0cfb32c3841ee2bea7479d1a5e1" translate="yes" xml:space="preserve">
          <source>To make a struct that holds a closure, we need to specify the type of the closure, because a struct definition needs to know the types of each of its fields. Each closure instance has its own unique anonymous type: that is, even if two closures have the same signature, their types are still considered different. To define structs, enums, or function parameters that use closures, we use generics and trait bounds, as we discussed in Chapter 10.</source>
          <target state="translated">클로저를 보유한 구조체를 만들려면 구조체 정의가 각 필드의 타입을 알아야하기 때문에 클로저의 타입을 지정해야합니다. 각 클로저 인스턴스에는 고유 한 익명 유형이 있습니다. 즉, 두 클로저의 서명이 동일하더라도 해당 유형은 여전히 ​​다른 것으로 간주됩니다. 클로저를 사용하는 구조체, 열거 형 또는 함수 매개 변수를 정의하기 위해 10 장에서 설명한 것처럼 제네릭과 특성 경계를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f551bbd5751f05a17c69a727dd31a7a20561b4f8" translate="yes" xml:space="preserve">
          <source>To make it valid, write the following:</source>
          <target state="translated">유효하게하려면 다음을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="11b284dcb2ba4ceac9f02b253f7b17b9698ddf3b" translate="yes" xml:space="preserve">
          <source>To make struct &lt;code&gt;Bar&lt;/code&gt; only visible in module &lt;code&gt;foo&lt;/code&gt; the &lt;code&gt;in&lt;/code&gt; keyword should be used:</source>
          <target state="translated">struct &lt;code&gt;Bar&lt;/code&gt; 만 모듈 &lt;code&gt;foo&lt;/code&gt; 에서만 보이게 하려면 &lt;code&gt;in&lt;/code&gt; 키워드를 사용해야합니다 :</target>
        </trans-unit>
        <trans-unit id="fc2021393a94974377e271f291f7d97ada3aa985" translate="yes" xml:space="preserve">
          <source>To make the child node aware of its parent, we need to add a &lt;code&gt;parent&lt;/code&gt; field to our &lt;code&gt;Node&lt;/code&gt; struct definition. The trouble is in deciding what the type of &lt;code&gt;parent&lt;/code&gt; should be. We know it can&amp;rsquo;t contain an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;, because that would create a reference cycle with &lt;code&gt;leaf.parent&lt;/code&gt; pointing to &lt;code&gt;branch&lt;/code&gt; and &lt;code&gt;branch.children&lt;/code&gt; pointing to &lt;code&gt;leaf&lt;/code&gt;, which would cause their &lt;code&gt;strong_count&lt;/code&gt; values to never be 0.</source>
          <target state="translated">자식 노드가 부모를 인식하게하려면 &lt;code&gt;Node&lt;/code&gt; 구조체 정의에 &lt;code&gt;parent&lt;/code&gt; 필드를 추가해야합니다 . 문제는 &lt;code&gt;parent&lt;/code&gt; 의 유형을 결정하는 데 있습니다. 우리는 그것이 포함 할 수 없습니다 알고 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 그와 참조주기 만들 것이기 때문에, &lt;code&gt;leaf.parent&lt;/code&gt; 가리키는 &lt;code&gt;branch&lt;/code&gt; 및 &lt;code&gt;branch.children&lt;/code&gt; 가리키는 &lt;code&gt;leaf&lt;/code&gt; 그 원인이, &lt;code&gt;strong_count&lt;/code&gt; 의 값을 결코 0이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b7b483d37995579653b3a66a999867efa81ab8f9" translate="yes" xml:space="preserve">
          <source>To make this work, every element has pointers to its predecessor and successor in the list. Elements can only be added when they are pinned, because moving the elements around would invalidate the pointers. Moreover, the &lt;code&gt;Drop&lt;/code&gt; implementation of a linked list element will patch the pointers of its predecessor and successor to remove itself from the list.</source>
          <target state="translated">이 작업을 수행하기 위해 모든 요소에는 목록의 선행 작업 및 후속 작업에 대한 포인터가 있습니다. 요소를 이동하면 포인터가 무효화되므로 요소를 고정 할 때만 요소를 추가 할 수 있습니다. 또한, 연결된 목록 요소 의 &lt;code&gt;Drop&lt;/code&gt; 구현은 이전 및 후속 작업의 포인터를 패치하여 목록에서 자신을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="addd7b5a3eab2bcc498269d4b5030ddd2652429e" translate="yes" xml:space="preserve">
          <source>To many people, polymorphism is synonymous with inheritance. But it&amp;rsquo;s actually a more general concept that refers to code that can work with data of multiple types. For inheritance, those types are generally subclasses.</source>
          <target state="translated">많은 사람들에게 다형성은 상속과 동의어입니다. 그러나 실제로는 여러 유형의 데이터를 처리 할 수있는 코드를 나타내는보다 일반적인 개념입니다. 상속을 위해 이러한 유형은 일반적으로 서브 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="c1808ba5fbc9308fb8282df842ce731348ff5abf" translate="yes" xml:space="preserve">
          <source>To model pointers to opaque types in FFI, until &lt;code&gt;extern type&lt;/code&gt; is stabilized, it is recommended to use a newtype wrapper around an empty byte array. See the &lt;a href=&quot;https://doc.rust-lang.org/nomicon/ffi.html#representing-opaque-structs&quot;&gt;Nomicon&lt;/a&gt; for details.</source>
          <target state="translated">FFI에서 불투명 한 유형에 대한 포인터를 모델링하려면 &lt;code&gt;extern type&lt;/code&gt; 이 안정화 될 때까지 빈 바이트 배열 주위에 newtype 래퍼를 사용하는 것이 좋습니다. 자세한 내용은 &lt;a href=&quot;https://doc.rust-lang.org/nomicon/ffi.html#representing-opaque-structs&quot;&gt;Nomicon&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="92f1c0826630a6e44e7c7249d92c4a26d91785e3" translate="yes" xml:space="preserve">
          <source>To obtain error description as a string, use &lt;code&gt;to_string()&lt;/code&gt;.</source>
          <target state="translated">문자열로 오류 설명을 얻으려면 &lt;code&gt;to_string()&lt;/code&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0354419a51c55b7a4f425ab3291d7b635b1d30c9" translate="yes" xml:space="preserve">
          <source>To parameterize the types in the new function we&amp;rsquo;ll define, we need to name the type parameter, just as we do for the value parameters to a function. You can use any identifier as a type parameter name. But we&amp;rsquo;ll use &lt;code&gt;T&lt;/code&gt; because, by convention, parameter names in Rust are short, often just a letter, and Rust&amp;rsquo;s type-naming convention is CamelCase. Short for &amp;ldquo;type,&amp;rdquo; &lt;code&gt;T&lt;/code&gt; is the default choice of most Rust programmers.</source>
          <target state="translated">정의 할 새 함수에서 유형을 매개 변수화하려면 값 매개 변수를 함수에 지정하는 것처럼 유형 매개 변수의 이름을 지정해야합니다. 식별자를 형식 매개 변수 이름으로 사용할 수 있습니다. 그러나 우리는 Rust의 매개 변수 이름이 짧고 종종 문자 일 뿐이며 Rust의 형식 명명 규칙이 CamelCase이기 때문에 &lt;code&gt;T&lt;/code&gt; 를 사용 합니다. &quot;type&quot;의 &lt;code&gt;T&lt;/code&gt; 는 대부분의 Rust 프로그래머가 선택하는 기본입니다.</target>
        </trans-unit>
        <trans-unit id="075fa626d389c13dd84df398e2b600267ba414fd" translate="yes" xml:space="preserve">
          <source>To parse a path, you can create a &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; slice from a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; slice and start asking questions:</source>
          <target state="translated">경로를 파싱하기 위해 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 슬라이스 에서 &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; 슬라이스를 생성하고 질문을 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f7f45d830d337ce8a4f493ea8b6014f97c0fb6eb" translate="yes" xml:space="preserve">
          <source>To pass a single argument see &lt;a href=&quot;#method.arg&quot;&gt;&lt;code&gt;arg&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">단일 인수를 전달하려면 &lt;a href=&quot;#method.arg&quot;&gt; &lt;code&gt;arg&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2f3d970a69fb7cac0396fffe3d7483eb856d59e9" translate="yes" xml:space="preserve">
          <source>To pass multiple arguments see &lt;a href=&quot;#method.args&quot;&gt;&lt;code&gt;args&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">여러 인수를 전달하려면 &lt;a href=&quot;#method.args&quot;&gt; &lt;code&gt;args&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="af6d76d570505ba666bcda7baecd5871dcf2d3a2" translate="yes" xml:space="preserve">
          <source>To prevent this scenario, we first put all of our &lt;code&gt;Terminate&lt;/code&gt; messages on the channel in one loop; then we join on all the threads in another loop. Each worker will stop receiving requests on the channel once it gets a terminate message. So, we can be sure that if we send the same number of terminate messages as there are workers, each worker will receive a terminate message before &lt;code&gt;join&lt;/code&gt; is called on its thread.</source>
          <target state="translated">이 시나리오를 방지하기 위해 먼저 모든 &lt;code&gt;Terminate&lt;/code&gt; 메시지를 채널의 루프에 넣습니다 . 그런 다음 다른 루프의 모든 스레드를 결합합니다. 각 작업자는 종료 메시지를 받으면 채널에서 요청 수신을 중지합니다. 따라서 워커와 동일한 수의 종료 메시지를 보내면 스레드에서 &lt;code&gt;join&lt;/code&gt; 이 호출 되기 전에 각 워커가 종료 메시지를 받게됩니다 .</target>
        </trans-unit>
        <trans-unit id="add5b6cf5a307a5e6af227f8cc2b7b101db763e7" translate="yes" xml:space="preserve">
          <source>To protect your program from this sort of vulnerability, if you try to read an element at an index that doesn&amp;rsquo;t exist, Rust will stop execution and refuse to continue. Let&amp;rsquo;s try it and see:</source>
          <target state="translated">이런 종류의 취약점으로부터 프로그램을 보호하기 위해 존재하지 않는 인덱스에서 요소를 읽으려고하면 Rust는 실행을 중지하고 계속을 거부합니다. 시도해 보자.</target>
        </trans-unit>
        <trans-unit id="fb3ab9d085bae205d404a7ba202d1b27f55784c2" translate="yes" xml:space="preserve">
          <source>To recover from a poisoned mutex:</source>
          <target state="translated">중독 된 뮤텍스를 복구하려면 :</target>
        </trans-unit>
        <trans-unit id="e0f842e4093b64f03623cd49c1c17718cfbe95dc" translate="yes" xml:space="preserve">
          <source>To remove the internal organization from the public API, we can modify the &lt;code&gt;art&lt;/code&gt; crate code in Listing 14-3 to add &lt;code&gt;pub use&lt;/code&gt; statements to re-export the items at the top level, as shown in Listing 14-5:</source>
          <target state="translated">공개 API에서 내부 조직을 제거하기 위해 Listing 14-5에서와 같이 &lt;code&gt;pub use&lt;/code&gt; 문을 추가 하여 항목을 최상위 레벨로 다시 내보내도록 Listing 14-3 의 &lt;code&gt;art&lt;/code&gt; 크레이트 코드를 수정할 수있다 .</target>
        </trans-unit>
        <trans-unit id="5b0280b8819ec3479f9646e558c6310c8632f058" translate="yes" xml:space="preserve">
          <source>To resolve the ambiguity, the programmer may refer to their desired method or function using more specific paths, types, or traits.</source>
          <target state="translated">모호성을 해결하기 위해 프로그래머는보다 구체적인 경로, 유형 또는 특성을 사용하여 원하는 방법 또는 기능을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40806bdac66961c97f14caf3bdb5bd4161107da4" translate="yes" xml:space="preserve">
          <source>To resolve this error use the concrete type:</source>
          <target state="translated">이 오류를 해결하려면 구체적 유형을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bba50911f39e97c448e79f8065cbe76ff37d962c" translate="yes" xml:space="preserve">
          <source>To resolve this error, use a concrete type for the intermediate expression:</source>
          <target state="translated">이 오류를 해결하려면 중간 표현식에 구체적 유형을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="336222d4e74857a65248fce76ba73fa02fe1c00a" translate="yes" xml:space="preserve">
          <source>To return a new lowercased value without modifying the existing one, use &lt;a href=&quot;#method.to_ascii_lowercase&quot;&gt;&lt;code&gt;to_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기존 값을 수정하지 않고 새로운 소문자 값을 반환하려면 &lt;a href=&quot;#method.to_ascii_lowercase&quot;&gt; &lt;code&gt;to_ascii_lowercase&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c6eff45b987ef30ba84b5033a569d4671d667c28" translate="yes" xml:space="preserve">
          <source>To return a new lowercased value without modifying the existing one, use &lt;a href=&quot;#tymethod.to_ascii_lowercase&quot;&gt;&lt;code&gt;to_ascii_lowercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기존 값을 수정하지 않고 새로운 소문자 값을 반환하려면 &lt;a href=&quot;#tymethod.to_ascii_lowercase&quot;&gt; &lt;code&gt;to_ascii_lowercase&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4fc2431e450771dead21af33dda64aadfaf2de37" translate="yes" xml:space="preserve">
          <source>To return a new uppercased value without modifying the existing one, use &lt;a href=&quot;#method.to_ascii_uppercase&quot;&gt;&lt;code&gt;to_ascii_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기존 값을 수정하지 않고 새로운 대문자 값을 반환하려면 &lt;a href=&quot;#method.to_ascii_uppercase&quot;&gt; &lt;code&gt;to_ascii_uppercase&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f98861983753d9167b54a4036b6c14ee7465a79" translate="yes" xml:space="preserve">
          <source>To return a new uppercased value without modifying the existing one, use &lt;a href=&quot;#tymethod.to_ascii_uppercase&quot;&gt;&lt;code&gt;to_ascii_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기존 값을 수정하지 않고 새로운 대문자 값을 반환하려면 &lt;a href=&quot;#tymethod.to_ascii_uppercase&quot;&gt; &lt;code&gt;to_ascii_uppercase&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3eb99467dbfaa372dd0858f79acae31153782c2" translate="yes" xml:space="preserve">
          <source>To round out this project, we&amp;rsquo;ll briefly demonstrate how to work with environment variables and how to print to standard error, both of which are useful when you&amp;rsquo;re writing command line programs.</source>
          <target state="translated">이 프로젝트를 마무리하기 위해 환경 변수 작업 방법과 표준 오류로 인쇄하는 방법에 대해 간략하게 설명합니다.이 두 가지 방법은 명령 줄 프로그램을 작성할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1d354bd55577a0ae6fc2f95a62753d1f62548897" translate="yes" xml:space="preserve">
          <source>To run Clippy&amp;rsquo;s lints on any Cargo project, enter the following:</source>
          <target state="translated">Cargo 프로젝트에서 Clippy의 보푸라기를 실행하려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="d744134b2344eca07ba0f4cf9819619cc570948e" translate="yes" xml:space="preserve">
          <source>To run the binary crate from the &lt;em&gt;add&lt;/em&gt; directory, we need to specify which package in the workspace we want to use by using the &lt;code&gt;-p&lt;/code&gt; argument and the package name with &lt;code&gt;cargo run&lt;/code&gt;:</source>
          <target state="translated">&lt;em&gt;add&lt;/em&gt; 디렉토리 에서 바이너리 상자를 실행하려면 &lt;code&gt;-p&lt;/code&gt; 인수와 &lt;code&gt;cargo run&lt;/code&gt; 과 함께 패키지 이름 을 사용하여 작업 공간에서 사용할 패키지를 지정해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="8bc4f6782a835ae358ae31b6f96421e46fc704f9" translate="yes" xml:space="preserve">
          <source>To see deref coercion in action, let&amp;rsquo;s use the &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; type we defined in Listing 15-8 as well as the implementation of &lt;code&gt;Deref&lt;/code&gt; that we added in Listing 15-10. Listing 15-11 shows the definition of a function that has a string slice parameter:</source>
          <target state="translated">deref 강제 변환이 실제로 작동 &lt;code&gt;Deref&lt;/code&gt; 확인하기 위해 Listing 15-8에서 정의한 &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; 유형 과 Listing 15-10에서 추가 한 Deref 의 구현을 사용 하자 . 코드 15-11은 문자열 슬라이스 매개 변수가있는 함수의 정의를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="46d871d99b751923bfc8199196805ccdb06df1da" translate="yes" xml:space="preserve">
          <source>To see the pattern matching aspect of &lt;code&gt;let&lt;/code&gt; more clearly, consider Listing 18-4, which uses a pattern with &lt;code&gt;let&lt;/code&gt; to destructure a tuple.</source>
          <target state="translated">의 패턴 매칭 측면 보려면 &lt;code&gt;let&lt;/code&gt; 가있는 패턴을 사용 18-4, 목록을 고려, 더 명확하게 &lt;code&gt;let&lt;/code&gt; 튜플을 destructure 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be7f1edd4187697ed5c2e4f6dc220a6d712ca92f" translate="yes" xml:space="preserve">
          <source>To see this code in action, let&amp;rsquo;s modify &lt;code&gt;main&lt;/code&gt; to accept only two requests before gracefully shutting down the server, as shown in Listing 20-26.</source>
          <target state="translated">이 코드가 실제로 작동 하는지 확인하려면 Listing 20-26에 표시된대로 서버를 정상적으로 종료하기 전에 &lt;code&gt;main&lt;/code&gt; 을 수정 하여 두 개의 요청 만 수락 하도록하자 .</target>
        </trans-unit>
        <trans-unit id="a7940de3192aef0247f83e244b60b2d3b6e58939" translate="yes" xml:space="preserve">
          <source>To see what happens when a &lt;code&gt;should_panic&lt;/code&gt; test with an &lt;code&gt;expected&lt;/code&gt; message fails, let&amp;rsquo;s again introduce a bug into our code by swapping the bodies of the &lt;code&gt;if value &amp;lt; 1&lt;/code&gt; and the &lt;code&gt;else if value &amp;gt; 100&lt;/code&gt; blocks:</source>
          <target state="translated">&lt;code&gt;expected&lt;/code&gt; 메시지가 있는 &lt;code&gt;should_panic&lt;/code&gt; 테스트가 실패 할 때 발생하는 상황을 확인하려면 &lt;code&gt;if value &amp;lt; 1&lt;/code&gt; 과 &lt;code&gt;else if value &amp;gt; 100&lt;/code&gt; 블록 의 본문을 교체하여 코드에 버그를 다시 도입 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="8576f35029f2c29efb15d99933a9de10a34dcb7b" translate="yes" xml:space="preserve">
          <source>To see why that last example was allowed, you need to understand the general rule. Unfortunately this rule is a bit tricky to state. Consider an &lt;code&gt;impl&lt;/code&gt;:</source>
          <target state="translated">마지막 예가 허용 된 이유를 보려면 일반 규칙을 이해해야합니다. 불행히도이 규칙은 설명하기가 약간 까다 롭습니다. &lt;code&gt;impl&lt;/code&gt; 을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="a14fdfe6208af1cb452de86927ad706e8201fb30" translate="yes" xml:space="preserve">
          <source>To seek without discarding the internal buffer, use &lt;a href=&quot;struct.bufreader#method.seek_relative&quot;&gt;&lt;code&gt;BufReader::seek_relative&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">내부 버퍼를 &lt;a href=&quot;struct.bufreader#method.seek_relative&quot;&gt; &lt;code&gt;BufReader::seek_relative&lt;/code&gt; &lt;/a&gt; 않고 찾으려면 BufReader :: seek_relative를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d7ebdd071ebe03ef9670cc1129fd6804ce04dfa" translate="yes" xml:space="preserve">
          <source>To service better ergonomics, patterns operate in different &lt;em&gt;binding modes&lt;/em&gt; in order to make it easier to bind references to values. When a reference value is matched by a non-reference pattern, it will be automatically treated as a &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;ref mut&lt;/code&gt; binding. Example:</source>
          <target state="translated">보다 나은 인체 공학적 서비스를 제공 하기 위해 패턴은 참조를 값에 쉽게 바인딩하기 위해 서로 다른 &lt;em&gt;바인딩 모드&lt;/em&gt; 에서 작동 합니다. 참조 값이 비 참조 패턴과 일치하면 &lt;code&gt;ref&lt;/code&gt; 또는 &lt;code&gt;ref mut&lt;/code&gt; 바인딩 으로 자동 처리됩니다 . 예:</target>
        </trans-unit>
        <trans-unit id="a3d0badb6b5b316657f5cb3fda3963d136213146" translate="yes" xml:space="preserve">
          <source>To set up a new project, go to the &lt;em&gt;projects&lt;/em&gt; directory that you created in Chapter 1 and make a new project using Cargo, like so:</source>
          <target state="translated">새 프로젝트를 설정하려면 1 장에서 생성 한 &lt;em&gt;프로젝트&lt;/em&gt; 디렉토리 로 이동하여 다음 과 같이 Cargo를 사용하여 새 프로젝트를 만드십시오.</target>
        </trans-unit>
        <trans-unit id="58b49ff05dd6fb8ece812d318c3efc42db98cdbb" translate="yes" xml:space="preserve">
          <source>To show Rust where to find an item in a module tree, we use a path in the same way we use a path when navigating a filesystem. If we want to call a function, we need to know its path.</source>
          <target state="translated">Rust가 모듈 트리에서 아이템을 찾을 위치를 보여주기 위해 파일 시스템을 탐색 할 때 경로를 사용하는 것과 같은 방식으로 경로를 사용합니다. 함수를 호출하려면 경로를 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="da1e1e9f2dd7b1c40ddec9ecef1f4d928ddb4f25" translate="yes" xml:space="preserve">
          <source>To silence this warning, edit your code to use an explicit bound. Most of the time, this means that you will want to change the signature of a function that you are calling. For example, if the error is reported on a call like &lt;code&gt;foo(x)&lt;/code&gt;, and &lt;code&gt;foo&lt;/code&gt; is defined as follows:</source>
          <target state="translated">이 경고를 끄려면 명시 적 범위를 사용하도록 코드를 편집하십시오. 대부분의 경우 이것은 호출하는 함수의 서명을 변경하려고 함을 의미합니다. 예를 들어, &lt;code&gt;foo(x)&lt;/code&gt; 와 같은 호출에서 오류가보고 되고 &lt;code&gt;foo&lt;/code&gt; 는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="0ae8db76a02a996f64985b9fc49d037c6c1ea0c5" translate="yes" xml:space="preserve">
          <source>To solve this error you can use conditional compilation:</source>
          <target state="translated">이 오류를 해결하려면 조건부 컴파일을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="384aa431a554e0c72ecb63fe411f4d1d9ac5425c" translate="yes" xml:space="preserve">
          <source>To solve this error, please ensure that the trait is also public. The trait can be made inaccessible if necessary by placing it into a private inner module, but it still has to be marked with &lt;code&gt;pub&lt;/code&gt;. Example:</source>
          <target state="translated">이 오류를 해결하려면 특성도 공개해야합니다. 필요한 경우 특성을 전용 내부 모듈에 배치하여 특성에 액세스 할 수 없지만 여전히 &lt;code&gt;pub&lt;/code&gt; 로 표시해야합니다 . 예:</target>
        </trans-unit>
        <trans-unit id="e8fd0f72a971d26cc1bbb2830412854500357f79" translate="yes" xml:space="preserve">
          <source>To solve this error, please ensure that the type is also public. The type can be made inaccessible if necessary by placing it into a private inner module, but it still has to be marked with &lt;code&gt;pub&lt;/code&gt;. Example:</source>
          <target state="translated">이 오류를 해결하려면 형식도 공용인지 확인하십시오. 필요한 경우 개인 내부 모듈에 배치하여 유형에 액세스 할 수 없게 만들 수 있지만 여전히 &lt;code&gt;pub&lt;/code&gt; 로 표시해야합니다 . 예:</target>
        </trans-unit>
        <trans-unit id="3cffb477b8b527a4ad5d6a5090b9a2b24adc51f1" translate="yes" xml:space="preserve">
          <source>To solve this error, please move the type bindings in the type parameter declaration:</source>
          <target state="translated">이 오류를 해결하려면 형식 매개 변수 선언에서 형식 바인딩을 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="4a77dd198bd76ba335ad5b87d56789f39f1b6b5e" translate="yes" xml:space="preserve">
          <source>To solve this error, the best solution is generally to keep the path before the item when using it. Example:</source>
          <target state="translated">이 오류를 해결하려면 가장 좋은 해결책은 일반적으로 항목을 사용할 때 경로를 유지하는 것입니다. 예:</target>
        </trans-unit>
        <trans-unit id="d8595d9620d15e23dd7e60f0c946808adb0c94b9" translate="yes" xml:space="preserve">
          <source>To split by Unicode &lt;code&gt;Whitespace&lt;/code&gt; instead, use &lt;a href=&quot;#method.split_whitespace&quot;&gt;&lt;code&gt;split_whitespace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">대신 유니 코드 &lt;code&gt;Whitespace&lt;/code&gt; 분할하려면 &lt;a href=&quot;#method.split_whitespace&quot;&gt; &lt;code&gt;split_whitespace&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="39efc8d301c98f5b54ae3dfd338106520f5157d1" translate="yes" xml:space="preserve">
          <source>To start defining the procedural macro, place the code in Listing 19-31 into your &lt;em&gt;src/lib.rs&lt;/em&gt; file for the &lt;code&gt;hello_macro_derive&lt;/code&gt; crate. Note that this code won&amp;rsquo;t compile until we add a definition for the &lt;code&gt;impl_hello_macro&lt;/code&gt; function.</source>
          <target state="translated">절차 적 매크로 정의를 시작하려면 Listing 19-31의 코드를 &lt;code&gt;hello_macro_derive&lt;/code&gt; 상자 의 &lt;em&gt;src / lib.rs&lt;/em&gt; 파일에 넣으십시오 . 이 코드는 &lt;code&gt;impl_hello_macro&lt;/code&gt; 함수에 대한 정의를 추가 할 때까지 컴파일되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4cd7a51fb6e1263e5fbdd69b060072fe94d9dc2f" translate="yes" xml:space="preserve">
          <source>To start, we&amp;rsquo;ll build a tree with nodes that know about their child nodes. We&amp;rsquo;ll create a struct named &lt;code&gt;Node&lt;/code&gt; that holds its own &lt;code&gt;i32&lt;/code&gt; value as well as references to its children &lt;code&gt;Node&lt;/code&gt; values:</source>
          <target state="translated">먼저 자식 노드에 대해 알고있는 노드가있는 트리를 만듭니다. 자체 &lt;code&gt;Node&lt;/code&gt; 값에 대한 참조뿐만 아니라 자체 &lt;code&gt;i32&lt;/code&gt; 값 을 보유하는 &lt;code&gt;Node&lt;/code&gt; 라는 이름의 구조체를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="e88b248a81f262510bb36c205a0d4dc2d7d064a2" translate="yes" xml:space="preserve">
          <source>To structure our crate in the same way that a real restaurant works, we can organize the functions into nested modules. Create a new library named &lt;code&gt;restaurant&lt;/code&gt; by running &lt;code&gt;cargo new --lib restaurant&lt;/code&gt;; then put the code in Listing 7-1 into &lt;em&gt;src/lib.rs&lt;/em&gt; to define some modules and function signatures.</source>
          <target state="translated">실제 식당과 같은 방식으로 상자를 구성하기 위해 함수를 중첩 모듈로 구성 할 수 있습니다. &lt;code&gt;cargo new --lib restaurant&lt;/code&gt; 을 실행하여 &lt;code&gt;restaurant&lt;/code&gt; 이라는 이름의 새로운 라이브러리를 만듭니다 . 그런 다음 Listing 7-1의 코드를 &lt;em&gt;src / lib.rs&lt;/em&gt; 에 넣어 일부 모듈과 함수 시그니처를 정의하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9f66b79eaf886d6c72a892191c1e18c1c1df90d3" translate="yes" xml:space="preserve">
          <source>To summarize, strings are complicated. Different programming languages make different choices about how to present this complexity to the programmer. Rust has chosen to make the correct handling of &lt;code&gt;String&lt;/code&gt; data the default behavior for all Rust programs, which means programmers have to put more thought into handling UTF-8 data upfront. This trade-off exposes more of the complexity of strings than is apparent in other programming languages, but it prevents you from having to handle errors involving non-ASCII characters later in your development life cycle.</source>
          <target state="translated">요약하면 문자열이 복잡합니다. 다른 프로그래밍 언어는 이러한 복잡성을 프로그래머에게 제시하는 방법에 대해 다른 선택을합니다. Rust는 모든 Rust 프로그램에서 &lt;code&gt;String&lt;/code&gt; 데이터를 올바르게 처리하는 것을 기본 동작으로 선택했습니다. 이는 프로그래머가 UTF-8 데이터를 미리 처리하는 데 더 많은 생각을해야한다는 것을 의미합니다. 이 절충은 다른 프로그래밍 언어에서 볼 수있는 것보다 더 복잡한 문자열을 노출하지만 나중에 개발 라이프 사이클에서 비 ASCII 문자와 관련된 오류를 처리하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="de7e750f454d2e6ac7a8ffdfb7a0160a0d2868ee" translate="yes" xml:space="preserve">
          <source>To summarize, the &lt;code&gt;let mut guess = String::new();&lt;/code&gt; line has created a mutable variable that is currently bound to a new, empty instance of a &lt;code&gt;String&lt;/code&gt;. Whew!</source>
          <target state="translated">요약하면, &lt;code&gt;let mut guess = String::new();&lt;/code&gt; line은 현재 비어있는 새로운 &lt;code&gt;String&lt;/code&gt; 인스턴스에 바인딩 된 가변 변수를 작성했습니다 . 아휴!</target>
        </trans-unit>
        <trans-unit id="f43e14ce7587570f1bef4bdb30b6cbaa4b75f17f" translate="yes" xml:space="preserve">
          <source>To switch to unsafe Rust, use the &lt;code&gt;unsafe&lt;/code&gt; keyword and then start a new block that holds the unsafe code. You can take four actions in unsafe Rust, called &lt;em&gt;unsafe superpowers&lt;/em&gt;, that you can&amp;rsquo;t in safe Rust. Those superpowers include the ability to:</source>
          <target state="translated">안전하지 않은 Rust로 전환하려면 &lt;code&gt;unsafe&lt;/code&gt; 키워드를 사용한 다음 안전하지 않은 코드를 보유한 새 블록을 시작하십시오. &lt;em&gt;unsafe superpowers&lt;/em&gt; 라는 &lt;em&gt;안전&lt;/em&gt; 하지 않은 Rust에서 안전하지 않은 Rust에서는 수행 할 수없는 네 가지 작업을 수행 할 수 있습니다. 이러한 초능력에는 다음과 같은 기능이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="31217910df272b1f25ece09faa304c39aefdc3a5" translate="yes" xml:space="preserve">
          <source>To this:</source>
          <target state="translated">이에:</target>
        </trans-unit>
        <trans-unit id="057adfa85ddef458f115bd296031094452f5b4a0" translate="yes" xml:space="preserve">
          <source>To understand better how closures work in Rust, read: https://doc.rust-lang.org/book/ch13-01-closures.html</source>
          <target state="translated">Rust에서 클로저가 어떻게 작동하는지 더 잘 이해하려면 https://doc.rust-lang.org/book/ch13-01-closures.html을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="c87f629cfb96af20696ef3d804bdc670ac7c36a2" translate="yes" xml:space="preserve">
          <source>To understand when we might want to use structs, let&amp;rsquo;s write a program that calculates the area of a rectangle. We&amp;rsquo;ll start with single variables, and then refactor the program until we&amp;rsquo;re using structs instead.</source>
          <target state="translated">구조체를 언제 사용하고 싶을 지 이해하기 위해 사각형의 면적을 계산하는 프로그램을 작성해 봅시다. 단일 변수로 시작한 다음 대신 구조체를 사용할 때까지 프로그램을 리팩터링합니다.</target>
        </trans-unit>
        <trans-unit id="f3887dc1ab813c2423acfe9d57d029c4502fb78e" translate="yes" xml:space="preserve">
          <source>To uninstall Rust and &lt;code&gt;rustup&lt;/code&gt;, run the following uninstall script from your shell:</source>
          <target state="translated">Rust and &lt;code&gt;rustup&lt;/code&gt; 을 제거하려면 셸에서 다음 제거 스크립트를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="662f41af8eb574e21b57913c6f9a0bd1516cbc7a" translate="yes" xml:space="preserve">
          <source>To uppercase ASCII characters in addition to non-ASCII characters, use &lt;a href=&quot;#method.to_uppercase&quot;&gt;&lt;code&gt;to_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비 ASCII 문자 외에 ASCII 문자를 대문자로하려면 &lt;a href=&quot;#method.to_uppercase&quot;&gt; &lt;code&gt;to_uppercase&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="bae7e9e1be3baf0aecb5ead601705215f7341743" translate="yes" xml:space="preserve">
          <source>To uppercase ASCII characters in addition to non-ASCII characters, use &lt;a href=&quot;../primitive.str#method.to_uppercase&quot;&gt;&lt;code&gt;str::to_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비 ASCII 문자 외에 ASCII 문자를 대문자로 만들려면 &lt;a href=&quot;../primitive.str#method.to_uppercase&quot;&gt; &lt;code&gt;str::to_uppercase&lt;/code&gt; &lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="00c3dbee0cfe96289d27fa6bc805ddc167d97ef8" translate="yes" xml:space="preserve">
          <source>To uppercase the value in-place, use &lt;a href=&quot;#method.make_ascii_uppercase&quot;&gt;&lt;code&gt;make_ascii_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 위치의 대문자를 &lt;a href=&quot;#method.make_ascii_uppercase&quot;&gt; &lt;code&gt;make_ascii_uppercase&lt;/code&gt; &lt;/a&gt; 려면 make_ascii_uppercase를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f0fee41197e5788cb8d5e92ad9fa5f070d016314" translate="yes" xml:space="preserve">
          <source>To uppercase the value in-place, use &lt;a href=&quot;#tymethod.make_ascii_uppercase&quot;&gt;&lt;code&gt;make_ascii_uppercase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 위치의 대문자를 &lt;a href=&quot;#tymethod.make_ascii_uppercase&quot;&gt; &lt;code&gt;make_ascii_uppercase&lt;/code&gt; &lt;/a&gt; 려면 make_ascii_uppercase를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="2a0a581c19fda5f34a2ecc353cab28485839d3f8" translate="yes" xml:space="preserve">
          <source>To use a default implementation to summarize instances of &lt;code&gt;NewsArticle&lt;/code&gt; instead of defining a custom implementation, we specify an empty &lt;code&gt;impl&lt;/code&gt; block with &lt;code&gt;impl Summary for NewsArticle {}&lt;/code&gt;.</source>
          <target state="translated">사용자 지정 구현을 정의하는 대신 기본 구현을 사용하여 &lt;code&gt;NewsArticle&lt;/code&gt; 인스턴스를 요약하려면 &lt;code&gt;impl Summary for NewsArticle {}&lt;/code&gt; 사용하여 빈 &lt;code&gt;impl&lt;/code&gt; 블록을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="adbf67a283306a6366d793a3b3158fdc68b8ad73" translate="yes" xml:space="preserve">
          <source>To use a namespace itself in addition to some of its members, &lt;code&gt;self&lt;/code&gt; may appear as part of a brace-enclosed list of imports:</source>
          <target state="translated">일부 멤버 외에 네임 스페이스 자체를 사용하기 위해 &lt;code&gt;self&lt;/code&gt; 는 중괄호로 묶은 가져 오기 목록의 일부로 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b03ec43b2895de636748b67704c685a1fa98427" translate="yes" xml:space="preserve">
          <source>To use a pattern, we compare it to some value. If the pattern matches the value, we use the value parts in our code. Recall the &lt;code&gt;match&lt;/code&gt; expressions in Chapter 6 that used patterns, such as the coin-sorting machine example. If the value fits the shape of the pattern, we can use the named pieces. If it doesn&amp;rsquo;t, the code associated with the pattern won&amp;rsquo;t run.</source>
          <target state="translated">패턴을 사용하기 위해 어떤 값과 비교합니다. 패턴이 값과 일치하면 코드에서 값 부분을 사용합니다. 6 장에서 동전 분류 기계 예제와 같은 패턴을 사용한 &lt;code&gt;match&lt;/code&gt; 표현식을 상기하십시오 . 값이 패턴의 모양에 맞는 경우 명명 된 조각을 사용할 수 있습니다. 그렇지 않으면 패턴과 관련된 코드가 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6cd526c3f5cdfb3e49b95a57c88c2fc1245de535" translate="yes" xml:space="preserve">
          <source>To use a slice type it generally has to be used behind a pointer for example as:</source>
          <target state="translated">슬라이스 유형을 사용하려면 일반적으로 다음과 같이 포인터 뒤에 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="1d9510373e7fd3a8d97cc9744e3544cf1ebe365c" translate="yes" xml:space="preserve">
          <source>To use a struct after we&amp;rsquo;ve defined it, we create an &lt;em&gt;instance&lt;/em&gt; of that struct by specifying concrete values for each of the fields. We create an instance by stating the name of the struct and then add curly brackets containing &lt;code&gt;key: value&lt;/code&gt; pairs, where the keys are the names of the fields and the values are the data we want to store in those fields. We don&amp;rsquo;t have to specify the fields in the same order in which we declared them in the struct. In other words, the struct definition is like a general template for the type, and instances fill in that template with particular data to create values of the type. For example, we can declare a particular user as shown in Listing 5-2.</source>
          <target state="translated">구조체를 정의한 후 사용하려면 각 필드에 구체적인 값을 지정하여 해당 구조체 의 &lt;em&gt;인스턴스&lt;/em&gt; 를 만듭니다 . 구조체의 이름을 지정하여 인스턴스를 생성 한 다음 &lt;code&gt;key: value&lt;/code&gt; 쌍을 포함하는 중괄호를 추가 합니다. 여기서 키는 필드 이름이고 값은 해당 필드에 저장하려는 데이터입니다. 구조체에서 선언 한 순서대로 필드를 지정할 필요는 없습니다. 즉, 구조체 정의는 형식에 대한 일반적인 템플릿과 같으며 인스턴스는 형식에 대한 값을 만들기 위해 특정 데이터로 해당 템플릿을 채 웁니다. 예를 들어, 목록 5-2와 같이 특정 사용자를 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27989b6610882b719a5ea410b5f71f23c1e34efa" translate="yes" xml:space="preserve">
          <source>To use this feature locally, you typically will use the &lt;code&gt;RUSTFLAGS&lt;/code&gt; environment variable to specify flags to the compiler through Cargo. For example to compile a statically linked binary on MSVC you would execute:</source>
          <target state="translated">이 기능을 로컬로 사용하려면 일반적으로 &lt;code&gt;RUSTFLAGS&lt;/code&gt; 환경 변수를 사용하여 Cargo를 통해 컴파일러에 플래그를 지정합니다. 예를 들어 MSVC에서 정적으로 링크 된 바이너리를 컴파일하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="aa8b8effb94e7abcaae16085a72643f10b8227aa" translate="yes" xml:space="preserve">
          <source>To use this version of &lt;code&gt;Summary&lt;/code&gt;, we only need to define &lt;code&gt;summarize_author&lt;/code&gt; when we implement the trait on a type:</source>
          <target state="translated">이 버전의 &lt;code&gt;Summary&lt;/code&gt; 를 사용하려면 유형에 특성을 구현할 때 summary_author 만 정의 &lt;code&gt;summarize_author&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="bc4c76af44cf81aae5a3bedd1a4fabcaf591ba2f" translate="yes" xml:space="preserve">
          <source>To wake up all threads, see &lt;a href=&quot;#method.notify_all&quot;&gt;&lt;code&gt;notify_all&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모든 스레드를 깨우려면 &lt;a href=&quot;#method.notify_all&quot;&gt; &lt;code&gt;notify_all&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="43d932c297a4d2b73e1f772e97d55db4b8e0dc93" translate="yes" xml:space="preserve">
          <source>To wake up only one thread, see &lt;a href=&quot;#method.notify_one&quot;&gt;&lt;code&gt;notify_one&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">하나의 스레드 만 깨우려면 &lt;a href=&quot;#method.notify_one&quot;&gt; &lt;code&gt;notify_one&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c88cf3ca8e9feae5d3beb7bbd55b97e74623d342" translate="yes" xml:space="preserve">
          <source>To work around this restriction, consider &quot;hiding&quot; the value behind a reference: either &lt;code&gt;&amp;amp;x&lt;/code&gt; or &lt;code&gt;&amp;amp;mut x&lt;/code&gt;. Since a reference has a fixed size, this lets you move it around as usual. Example:</source>
          <target state="translated">이 제한 사항을 해결하려면 &lt;code&gt;&amp;amp;x&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut x&lt;/code&gt; 참조의 값 뒤에 &quot;숨김&quot;을 고려하십시오 . 참조의 크기는 고정되어 있기 때문에 평소대로 이동할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="6500c202f483ded49d90dd12d80754b82fdf0dff" translate="yes" xml:space="preserve">
          <source>To work around this, it can be covered with a local type, &lt;code&gt;MyType&lt;/code&gt;:</source>
          <target state="translated">이 문제를 해결하려면 로컬 유형 &lt;code&gt;MyType&lt;/code&gt; 으로 덮을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="36dd8bd129ed7bbb15977196b4ec891eb2cbcdbb" translate="yes" xml:space="preserve">
          <source>To work around this, we can use &lt;a href=&quot;#method.split_at_mut&quot;&gt;&lt;code&gt;split_at_mut&lt;/code&gt;&lt;/a&gt; to create two distinct mutable sub-slices from a slice:</source>
          <target state="translated">이 문제를 해결하기 위해 &lt;a href=&quot;#method.split_at_mut&quot;&gt; &lt;code&gt;split_at_mut&lt;/code&gt; &lt;/a&gt; 를 사용하여 슬라이스에서 두 개의 서로 다른 가변 하위 슬라이스를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="24f7e027af97b0bcea482e03195ef7fce8ba5648" translate="yes" xml:space="preserve">
          <source>To work around this, we can use &lt;a href=&quot;#method.split_at_mut&quot;&gt;&lt;code&gt;split_at_mut&lt;/code&gt;&lt;/a&gt; to create two distinct sub-slices from a slice:</source>
          <target state="translated">이 문제를 해결하기 위해 &lt;a href=&quot;#method.split_at_mut&quot;&gt; &lt;code&gt;split_at_mut&lt;/code&gt; &lt;/a&gt; 를 사용하여 슬라이스에서 두 개의 별개의 하위 슬라이스를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88426551199f60d0c53bc995bbba2a8ae94e26e1" translate="yes" xml:space="preserve">
          <source>To work with DSTs, Rust has a particular trait called the &lt;code&gt;Sized&lt;/code&gt; trait to determine whether or not a type&amp;rsquo;s size is known at compile time. This trait is automatically implemented for everything whose size is known at compile time. In addition, Rust implicitly adds a bound on &lt;code&gt;Sized&lt;/code&gt; to every generic function. That is, a generic function definition like this:</source>
          <target state="translated">DST와 함께 작업하기 위해 Rust에는 &lt;code&gt;Sized&lt;/code&gt; 특성 이라는 특수 특성이있어 컴파일시 유형의 크기를 알 수 있는지 여부를 결정합니다. 이 특성은 컴파일 타임에 크기가 알려진 모든 항목에 대해 자동으로 구현됩니다. 또한 Rust는 모든 일반 함수 에 &lt;code&gt;Sized&lt;/code&gt; 에 대한 바운드를 암시 적으로 추가 합니다. 즉, 다음과 같은 일반적인 함수 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb14220cb77cbb7e4cc1fc269b18360bfeb61f7b" translate="yes" xml:space="preserve">
          <source>To yank a version of a crate, run &lt;code&gt;cargo yank&lt;/code&gt; and specify which version you want to yank:</source>
          <target state="translated">상자의 버전을 잡아 당기려면 &lt;code&gt;cargo yank&lt;/code&gt; 를 실행 하고 잡아 당길 버전을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="358ef599a863a7317d7b73949a61a65e9c8b5929" translate="yes" xml:space="preserve">
          <source>ToLowercase</source>
          <target state="translated">ToLowercase</target>
        </trans-unit>
        <trans-unit id="df38106c5dbe8437c114ca2d685149a2779acb46" translate="yes" xml:space="preserve">
          <source>ToLowercase::all</source>
          <target state="translated">ToLowercase::all</target>
        </trans-unit>
        <trans-unit id="bbeaa264c1c37f2bac007b1544ec3f5ad9fa247a" translate="yes" xml:space="preserve">
          <source>ToLowercase::any</source>
          <target state="translated">ToLowercase::any</target>
        </trans-unit>
        <trans-unit id="0a141811b0b02a8a6bc1f88e69b931b80579b5c2" translate="yes" xml:space="preserve">
          <source>ToLowercase::borrow</source>
          <target state="translated">ToLowercase::borrow</target>
        </trans-unit>
        <trans-unit id="cdeca1abdbe65f3026e21a79b8f904e797c979d8" translate="yes" xml:space="preserve">
          <source>ToLowercase::borrow_mut</source>
          <target state="translated">ToLowercase::borrow_mut</target>
        </trans-unit>
        <trans-unit id="04089a7fe4a382bdeab885ef9891fb5765277adf" translate="yes" xml:space="preserve">
          <source>ToLowercase::by_ref</source>
          <target state="translated">ToLowercase::by_ref</target>
        </trans-unit>
        <trans-unit id="a079ce9b966f7512985cc3db6325af88008cc5f5" translate="yes" xml:space="preserve">
          <source>ToLowercase::chain</source>
          <target state="translated">ToLowercase::chain</target>
        </trans-unit>
        <trans-unit id="34f89547554d65a0175fa66474bd90120ecce7b1" translate="yes" xml:space="preserve">
          <source>ToLowercase::clone</source>
          <target state="translated">ToLowercase::clone</target>
        </trans-unit>
        <trans-unit id="0a39078458104a1579ea1ffbefc1eff627ca4db9" translate="yes" xml:space="preserve">
          <source>ToLowercase::clone_from</source>
          <target state="translated">ToLowercase::clone_from</target>
        </trans-unit>
        <trans-unit id="69987693fa5c572002cf4a8687ae06044830821a" translate="yes" xml:space="preserve">
          <source>ToLowercase::clone_into</source>
          <target state="translated">ToLowercase::clone_into</target>
        </trans-unit>
        <trans-unit id="121cb5982b6d466308c6295488de685c5924188f" translate="yes" xml:space="preserve">
          <source>ToLowercase::cloned</source>
          <target state="translated">ToLowercase::cloned</target>
        </trans-unit>
        <trans-unit id="2a56c21b2935dd999e82afb8be288b273e7d2e4e" translate="yes" xml:space="preserve">
          <source>ToLowercase::cmp</source>
          <target state="translated">ToLowercase::cmp</target>
        </trans-unit>
        <trans-unit id="9a83c4a51b2449ab4001a1ea57020189f34eb86e" translate="yes" xml:space="preserve">
          <source>ToLowercase::collect</source>
          <target state="translated">ToLowercase::collect</target>
        </trans-unit>
        <trans-unit id="fc76b0e4ac6af8ee61de5ea6000b4e90b61281f6" translate="yes" xml:space="preserve">
          <source>ToLowercase::copied</source>
          <target state="translated">ToLowercase::copied</target>
        </trans-unit>
        <trans-unit id="ebd8500418acdbe357cc1847a2d0349da2ad6802" translate="yes" xml:space="preserve">
          <source>ToLowercase::count</source>
          <target state="translated">ToLowercase::count</target>
        </trans-unit>
        <trans-unit id="46c2bfc1c56cb3945b434e3354e83dfe8b8c506d" translate="yes" xml:space="preserve">
          <source>ToLowercase::cycle</source>
          <target state="translated">ToLowercase::cycle</target>
        </trans-unit>
        <trans-unit id="17c64b13d578e62f4865fa3a426a453511fad16f" translate="yes" xml:space="preserve">
          <source>ToLowercase::enumerate</source>
          <target state="translated">ToLowercase::enumerate</target>
        </trans-unit>
        <trans-unit id="22c6e7593fef2063b7782e7156f48b60a1a13824" translate="yes" xml:space="preserve">
          <source>ToLowercase::eq</source>
          <target state="translated">ToLowercase::eq</target>
        </trans-unit>
        <trans-unit id="a97a62afe9c15bee17e74d16036987e2c4a3f22a" translate="yes" xml:space="preserve">
          <source>ToLowercase::filter</source>
          <target state="translated">ToLowercase::filter</target>
        </trans-unit>
        <trans-unit id="282e7712aa0755dc3cee721bbb60ae3056ffd1b8" translate="yes" xml:space="preserve">
          <source>ToLowercase::filter_map</source>
          <target state="translated">ToLowercase::filter_map</target>
        </trans-unit>
        <trans-unit id="5e623530b92901b135346a206054ea74de34c74b" translate="yes" xml:space="preserve">
          <source>ToLowercase::find</source>
          <target state="translated">ToLowercase::find</target>
        </trans-unit>
        <trans-unit id="8199273d20714ffb35f8bf63fc8de1aeeb62aaaf" translate="yes" xml:space="preserve">
          <source>ToLowercase::find_map</source>
          <target state="translated">ToLowercase::find_map</target>
        </trans-unit>
        <trans-unit id="4ed7f75d1d13393082ea7b8eeecf7e820cecc331" translate="yes" xml:space="preserve">
          <source>ToLowercase::flat_map</source>
          <target state="translated">ToLowercase::flat_map</target>
        </trans-unit>
        <trans-unit id="8faef9a1d718b76295200253966c7806e7cdc59c" translate="yes" xml:space="preserve">
          <source>ToLowercase::flatten</source>
          <target state="translated">ToLowercase::flatten</target>
        </trans-unit>
        <trans-unit id="d060a84d6f235fd2215550273860f38eeab5eccf" translate="yes" xml:space="preserve">
          <source>ToLowercase::fmt</source>
          <target state="translated">ToLowercase::fmt</target>
        </trans-unit>
        <trans-unit id="8131b5a5bcf84d17a43fb10e483ba9ff1d8d359c" translate="yes" xml:space="preserve">
          <source>ToLowercase::fold</source>
          <target state="translated">ToLowercase::fold</target>
        </trans-unit>
        <trans-unit id="327b78b92e355c99705bbf603c2bb143fa92d2e9" translate="yes" xml:space="preserve">
          <source>ToLowercase::for_each</source>
          <target state="translated">ToLowercase::for_each</target>
        </trans-unit>
        <trans-unit id="c1d00ad3539f24458681e04a1741cd54badd39cf" translate="yes" xml:space="preserve">
          <source>ToLowercase::from</source>
          <target state="translated">ToLowercase::from</target>
        </trans-unit>
        <trans-unit id="7d595874443f42a9e344ead1449f7c72a2522b74" translate="yes" xml:space="preserve">
          <source>ToLowercase::fuse</source>
          <target state="translated">ToLowercase::fuse</target>
        </trans-unit>
        <trans-unit id="5f012ebb8814c9cf77a450ef55b693640b7421e7" translate="yes" xml:space="preserve">
          <source>ToLowercase::ge</source>
          <target state="translated">ToLowercase::ge</target>
        </trans-unit>
        <trans-unit id="a451e0c1969a73439fef2468147038b278d489fd" translate="yes" xml:space="preserve">
          <source>ToLowercase::gt</source>
          <target state="translated">ToLowercase::gt</target>
        </trans-unit>
        <trans-unit id="642b22a76015cab4922545ce0b1b8fce9e09e5ed" translate="yes" xml:space="preserve">
          <source>ToLowercase::inspect</source>
          <target state="translated">ToLowercase::inspect</target>
        </trans-unit>
        <trans-unit id="7ca3893f4299d51675bc4e51e48ab78b6e95e7ae" translate="yes" xml:space="preserve">
          <source>ToLowercase::into</source>
          <target state="translated">ToLowercase::into</target>
        </trans-unit>
        <trans-unit id="9baa58c23f7e0d689b278ecfab3e39c8efae52c3" translate="yes" xml:space="preserve">
          <source>ToLowercase::into_iter</source>
          <target state="translated">ToLowercase::into_iter</target>
        </trans-unit>
        <trans-unit id="41740e63b2346c1e13490d8bb5f5d3524774e936" translate="yes" xml:space="preserve">
          <source>ToLowercase::is_empty</source>
          <target state="translated">ToLowercase::is_empty</target>
        </trans-unit>
        <trans-unit id="0a3555fc3fa048af9c1a10c2d056047061c3acad" translate="yes" xml:space="preserve">
          <source>ToLowercase::is_sorted</source>
          <target state="translated">ToLowercase::is_sorted</target>
        </trans-unit>
        <trans-unit id="d1e0425d483ec70bb6984df2a767d8b9e4f434c4" translate="yes" xml:space="preserve">
          <source>ToLowercase::is_sorted_by</source>
          <target state="translated">ToLowercase::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="a66c5bf8964eab56ac90671d7ee744d61569a85f" translate="yes" xml:space="preserve">
          <source>ToLowercase::is_sorted_by_key</source>
          <target state="translated">ToLowercase::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="f9ef704f171d5f967ad9a902b9e6c885aa657d95" translate="yes" xml:space="preserve">
          <source>ToLowercase::last</source>
          <target state="translated">ToLowercase::last</target>
        </trans-unit>
        <trans-unit id="d3f98dd839d26ad724880104a40c7e70d33d18c3" translate="yes" xml:space="preserve">
          <source>ToLowercase::le</source>
          <target state="translated">ToLowercase::le</target>
        </trans-unit>
        <trans-unit id="e1ba36fd3934ba511b5d0af5c6f135a35664771b" translate="yes" xml:space="preserve">
          <source>ToLowercase::len</source>
          <target state="translated">ToLowercase::len</target>
        </trans-unit>
        <trans-unit id="2eed1cdf88b1cb0a9fa1233f81e8f43967248498" translate="yes" xml:space="preserve">
          <source>ToLowercase::lt</source>
          <target state="translated">ToLowercase::lt</target>
        </trans-unit>
        <trans-unit id="e43226c948078b9cc9aebaa496f80af6656f0917" translate="yes" xml:space="preserve">
          <source>ToLowercase::map</source>
          <target state="translated">ToLowercase::map</target>
        </trans-unit>
        <trans-unit id="e0c53789432635e282bac9afc1520196b7c560e8" translate="yes" xml:space="preserve">
          <source>ToLowercase::max</source>
          <target state="translated">ToLowercase::max</target>
        </trans-unit>
        <trans-unit id="903a830f2d66f982a4644a703e0e8e4957273461" translate="yes" xml:space="preserve">
          <source>ToLowercase::max_by</source>
          <target state="translated">ToLowercase::max_by</target>
        </trans-unit>
        <trans-unit id="18bae373fc9373515a693f2601a3ad81cbde3459" translate="yes" xml:space="preserve">
          <source>ToLowercase::max_by_key</source>
          <target state="translated">ToLowercase::max_by_key</target>
        </trans-unit>
        <trans-unit id="bb9afa7050228536bbc7504f5c5dfc47a13e78c0" translate="yes" xml:space="preserve">
          <source>ToLowercase::min</source>
          <target state="translated">ToLowercase::min</target>
        </trans-unit>
        <trans-unit id="77c4813b999aa04010a0f28c8553bcc6214e1616" translate="yes" xml:space="preserve">
          <source>ToLowercase::min_by</source>
          <target state="translated">ToLowercase::min_by</target>
        </trans-unit>
        <trans-unit id="423a7c3614737a7cb7033368fb85813297ba5915" translate="yes" xml:space="preserve">
          <source>ToLowercase::min_by_key</source>
          <target state="translated">ToLowercase::min_by_key</target>
        </trans-unit>
        <trans-unit id="45cf81c6356fb6305106b81d4e38e7f435f86cc1" translate="yes" xml:space="preserve">
          <source>ToLowercase::ne</source>
          <target state="translated">ToLowercase::ne</target>
        </trans-unit>
        <trans-unit id="a71fc3ee26e013ac8645c417796e09cd264a122e" translate="yes" xml:space="preserve">
          <source>ToLowercase::next</source>
          <target state="translated">ToLowercase::next</target>
        </trans-unit>
        <trans-unit id="1911198040fb257baaa909fbd9e0ff4bd63738b2" translate="yes" xml:space="preserve">
          <source>ToLowercase::nth</source>
          <target state="translated">ToLowercase::nth</target>
        </trans-unit>
        <trans-unit id="8e0ec3fa9f7c6b4e02f5cdbcceafdedd84b428e3" translate="yes" xml:space="preserve">
          <source>ToLowercase::partial_cmp</source>
          <target state="translated">ToLowercase::partial_cmp</target>
        </trans-unit>
        <trans-unit id="47c77ae9e15794fc333d6ed8815d4414bb103610" translate="yes" xml:space="preserve">
          <source>ToLowercase::partition</source>
          <target state="translated">ToLowercase::partition</target>
        </trans-unit>
        <trans-unit id="75ec1c2334a1ca3250b6d8818285245c4e4389b7" translate="yes" xml:space="preserve">
          <source>ToLowercase::peekable</source>
          <target state="translated">ToLowercase::peekable</target>
        </trans-unit>
        <trans-unit id="5bd4eb545154844db83963b7bf6e24d4160c4184" translate="yes" xml:space="preserve">
          <source>ToLowercase::position</source>
          <target state="translated">ToLowercase::position</target>
        </trans-unit>
        <trans-unit id="da1c2a6ce254ef365fc893f21ebcfb9884ec4d92" translate="yes" xml:space="preserve">
          <source>ToLowercase::product</source>
          <target state="translated">ToLowercase::product</target>
        </trans-unit>
        <trans-unit id="7513906fb803029e9d762eb5a94c745eb5662524" translate="yes" xml:space="preserve">
          <source>ToLowercase::rev</source>
          <target state="translated">ToLowercase::rev</target>
        </trans-unit>
        <trans-unit id="418774bd5cf3162562c6090441d234e9d61a03d7" translate="yes" xml:space="preserve">
          <source>ToLowercase::rposition</source>
          <target state="translated">ToLowercase::rposition</target>
        </trans-unit>
        <trans-unit id="9b317c9f2c5a4d58ea3427624437ce70f6752c98" translate="yes" xml:space="preserve">
          <source>ToLowercase::scan</source>
          <target state="translated">ToLowercase::scan</target>
        </trans-unit>
        <trans-unit id="2347172afd0d4f896ed7b4c55d0f9d8e2916251b" translate="yes" xml:space="preserve">
          <source>ToLowercase::size_hint</source>
          <target state="translated">ToLowercase::size_hint</target>
        </trans-unit>
        <trans-unit id="418c2ea2c35afdc50dcf9a90930d3ce62e8f3999" translate="yes" xml:space="preserve">
          <source>ToLowercase::skip</source>
          <target state="translated">ToLowercase::skip</target>
        </trans-unit>
        <trans-unit id="95df49075bec9d23f70a04c44f6a727846e429e6" translate="yes" xml:space="preserve">
          <source>ToLowercase::skip_while</source>
          <target state="translated">ToLowercase::skip_while</target>
        </trans-unit>
        <trans-unit id="b9d44057d9ed2703572ffed49f6eca5288b3d100" translate="yes" xml:space="preserve">
          <source>ToLowercase::step_by</source>
          <target state="translated">ToLowercase::step_by</target>
        </trans-unit>
        <trans-unit id="12fc6d57d9454f947a272a38199873e4fabe30e6" translate="yes" xml:space="preserve">
          <source>ToLowercase::sum</source>
          <target state="translated">ToLowercase::sum</target>
        </trans-unit>
        <trans-unit id="0f151b1e0bb55576903eeeb5a1d3d1df40fa455c" translate="yes" xml:space="preserve">
          <source>ToLowercase::take</source>
          <target state="translated">ToLowercase::take</target>
        </trans-unit>
        <trans-unit id="bb7ec83ca1b296882f68aab3b80d313fe4becdda" translate="yes" xml:space="preserve">
          <source>ToLowercase::take_while</source>
          <target state="translated">ToLowercase::take_while</target>
        </trans-unit>
        <trans-unit id="4ee080cf3eb36fa9ffb413ea40781d5206121d04" translate="yes" xml:space="preserve">
          <source>ToLowercase::to_owned</source>
          <target state="translated">ToLowercase::to_owned</target>
        </trans-unit>
        <trans-unit id="89719f79b975bafdc49f6c2bf1b53c77dd82479f" translate="yes" xml:space="preserve">
          <source>ToLowercase::to_string</source>
          <target state="translated">ToLowercase::to_string</target>
        </trans-unit>
        <trans-unit id="02fb5f5e1e24ebbf9a57d55d395e203de6f1bb79" translate="yes" xml:space="preserve">
          <source>ToLowercase::try_fold</source>
          <target state="translated">ToLowercase::try_fold</target>
        </trans-unit>
        <trans-unit id="24adb2676fd932bafa66d72575c91291c6415cb3" translate="yes" xml:space="preserve">
          <source>ToLowercase::try_for_each</source>
          <target state="translated">ToLowercase::try_for_each</target>
        </trans-unit>
        <trans-unit id="ca18cfcbad0e84fa95fbec8b5bfb913cdebdfd50" translate="yes" xml:space="preserve">
          <source>ToLowercase::try_from</source>
          <target state="translated">ToLowercase::try_from</target>
        </trans-unit>
        <trans-unit id="e06d04b43ebaa98937e8ae299a145ab53f8f8401" translate="yes" xml:space="preserve">
          <source>ToLowercase::try_into</source>
          <target state="translated">ToLowercase::try_into</target>
        </trans-unit>
        <trans-unit id="37b6363c64db2b818bf5770928eeb9cb5799b27c" translate="yes" xml:space="preserve">
          <source>ToLowercase::type_id</source>
          <target state="translated">ToLowercase::type_id</target>
        </trans-unit>
        <trans-unit id="5dab7a97b855d1005e423aac5a301136ccbfbda8" translate="yes" xml:space="preserve">
          <source>ToLowercase::unzip</source>
          <target state="translated">ToLowercase::unzip</target>
        </trans-unit>
        <trans-unit id="8c6300316ee7d9e235cf97abcd7ffe7ee60f526a" translate="yes" xml:space="preserve">
          <source>ToLowercase::zip</source>
          <target state="translated">ToLowercase::zip</target>
        </trans-unit>
        <trans-unit id="6a954abfe9e5f07fb766f0356ed1234d8f9b2362" translate="yes" xml:space="preserve">
          <source>ToOwned</source>
          <target state="translated">ToOwned</target>
        </trans-unit>
        <trans-unit id="88395f188f7e1627b5813c10232224a853eb2ce1" translate="yes" xml:space="preserve">
          <source>ToOwned::clone_into</source>
          <target state="translated">ToOwned::clone_into</target>
        </trans-unit>
        <trans-unit id="b54aeb29a238430e61c4864d679de09e146fc8bd" translate="yes" xml:space="preserve">
          <source>ToOwned::to_owned</source>
          <target state="translated">ToOwned::to_owned</target>
        </trans-unit>
        <trans-unit id="db76836dc2d12f75bc694c079718628342759cd3" translate="yes" xml:space="preserve">
          <source>ToSocketAddrs</source>
          <target state="translated">ToSocketAddrs</target>
        </trans-unit>
        <trans-unit id="0fed83f8d392d8ac77157990f089f9649d9b7750" translate="yes" xml:space="preserve">
          <source>ToSocketAddrs::to_socket_addrs</source>
          <target state="translated">ToSocketAddrs::to_socket_addrs</target>
        </trans-unit>
        <trans-unit id="1dbc7385badbfda548fb27e2160a33cf32c0f545" translate="yes" xml:space="preserve">
          <source>ToString</source>
          <target state="translated">ToString</target>
        </trans-unit>
        <trans-unit id="44b9808561fdc5221237b58497f052b0ab411690" translate="yes" xml:space="preserve">
          <source>ToString::to_string</source>
          <target state="translated">ToString::to_string</target>
        </trans-unit>
        <trans-unit id="0e33b561569f62cb10ee567c1f64d4f901389c05" translate="yes" xml:space="preserve">
          <source>ToUppercase</source>
          <target state="translated">ToUppercase</target>
        </trans-unit>
        <trans-unit id="9ff9a36e95ac5564578763dcb0e10b5a089787be" translate="yes" xml:space="preserve">
          <source>ToUppercase::all</source>
          <target state="translated">ToUppercase::all</target>
        </trans-unit>
        <trans-unit id="65730a9e88411b06193ba55e82da8ee1907a8064" translate="yes" xml:space="preserve">
          <source>ToUppercase::any</source>
          <target state="translated">ToUppercase::any</target>
        </trans-unit>
        <trans-unit id="7bbc3824337aaeab2c429030633a1af5ed905e80" translate="yes" xml:space="preserve">
          <source>ToUppercase::borrow</source>
          <target state="translated">ToUppercase::borrow</target>
        </trans-unit>
        <trans-unit id="054e212cd833cb188e6198592b3d47a12224a8d7" translate="yes" xml:space="preserve">
          <source>ToUppercase::borrow_mut</source>
          <target state="translated">ToUppercase::borrow_mut</target>
        </trans-unit>
        <trans-unit id="6cb0a8be2d9bacab3bc53f929148bf74eddc427a" translate="yes" xml:space="preserve">
          <source>ToUppercase::by_ref</source>
          <target state="translated">ToUppercase::by_ref</target>
        </trans-unit>
        <trans-unit id="f6523db9347a61697b6b9197bca2d6fba8a42d3c" translate="yes" xml:space="preserve">
          <source>ToUppercase::chain</source>
          <target state="translated">ToUppercase::chain</target>
        </trans-unit>
        <trans-unit id="c0aca2868b888310176cab83baeec3b2d775557f" translate="yes" xml:space="preserve">
          <source>ToUppercase::clone</source>
          <target state="translated">ToUppercase::clone</target>
        </trans-unit>
        <trans-unit id="67fd93e201a873e97c66908ead7ceae8bc1e8a92" translate="yes" xml:space="preserve">
          <source>ToUppercase::clone_from</source>
          <target state="translated">ToUppercase::clone_from</target>
        </trans-unit>
        <trans-unit id="b84ef7303ff66cf2803f532b77195b1cf5d457a1" translate="yes" xml:space="preserve">
          <source>ToUppercase::clone_into</source>
          <target state="translated">ToUppercase::clone_into</target>
        </trans-unit>
        <trans-unit id="5ccbf12c4818e31f1595aa777831465b36f69a51" translate="yes" xml:space="preserve">
          <source>ToUppercase::cloned</source>
          <target state="translated">ToUppercase::cloned</target>
        </trans-unit>
        <trans-unit id="a8f2e905cd5750074d352d368e76df6b39f96427" translate="yes" xml:space="preserve">
          <source>ToUppercase::cmp</source>
          <target state="translated">ToUppercase::cmp</target>
        </trans-unit>
        <trans-unit id="1dc5a2f9004fb521903e5e5a3fd364dc11757205" translate="yes" xml:space="preserve">
          <source>ToUppercase::collect</source>
          <target state="translated">ToUppercase::collect</target>
        </trans-unit>
        <trans-unit id="af8f9ceea80fc5e950363e9318dd158d01a4d040" translate="yes" xml:space="preserve">
          <source>ToUppercase::copied</source>
          <target state="translated">ToUppercase::copied</target>
        </trans-unit>
        <trans-unit id="1366fc011a472ff5d53cde6f1ac86461228351e7" translate="yes" xml:space="preserve">
          <source>ToUppercase::count</source>
          <target state="translated">ToUppercase::count</target>
        </trans-unit>
        <trans-unit id="1184c3c693dff48405ca7548cca0ed458ff29830" translate="yes" xml:space="preserve">
          <source>ToUppercase::cycle</source>
          <target state="translated">ToUppercase::cycle</target>
        </trans-unit>
        <trans-unit id="4e91911466f6b5af4078b70e11c4d24775fe742f" translate="yes" xml:space="preserve">
          <source>ToUppercase::enumerate</source>
          <target state="translated">ToUppercase::enumerate</target>
        </trans-unit>
        <trans-unit id="7840d75ecceac6bb8014df3896750d9d72c6c4f4" translate="yes" xml:space="preserve">
          <source>ToUppercase::eq</source>
          <target state="translated">ToUppercase::eq</target>
        </trans-unit>
        <trans-unit id="2a9bfa9a45635d09ff4f0e7dbad7c78cf4865a99" translate="yes" xml:space="preserve">
          <source>ToUppercase::filter</source>
          <target state="translated">ToUppercase::filter</target>
        </trans-unit>
        <trans-unit id="a2ce94b0c7944e165ba6c67b1e1d6438853b3133" translate="yes" xml:space="preserve">
          <source>ToUppercase::filter_map</source>
          <target state="translated">ToUppercase::filter_map</target>
        </trans-unit>
        <trans-unit id="33b7908aaa91c2cca1edd3fbd1eb5ed2b7161ab8" translate="yes" xml:space="preserve">
          <source>ToUppercase::find</source>
          <target state="translated">ToUppercase::find</target>
        </trans-unit>
        <trans-unit id="26582c132713274fb6090fc39fe168d493ee012a" translate="yes" xml:space="preserve">
          <source>ToUppercase::find_map</source>
          <target state="translated">ToUppercase::find_map</target>
        </trans-unit>
        <trans-unit id="d2233ee6bb72d979bc01f41100247c5902cf0607" translate="yes" xml:space="preserve">
          <source>ToUppercase::flat_map</source>
          <target state="translated">ToUppercase::flat_map</target>
        </trans-unit>
        <trans-unit id="bc467f30c7752c24841765febf75cc9fdc574574" translate="yes" xml:space="preserve">
          <source>ToUppercase::flatten</source>
          <target state="translated">ToUppercase::flatten</target>
        </trans-unit>
        <trans-unit id="da04bbd5685fac2d5a4df3c9db6cca8ac3ddfa78" translate="yes" xml:space="preserve">
          <source>ToUppercase::fmt</source>
          <target state="translated">ToUppercase::fmt</target>
        </trans-unit>
        <trans-unit id="dab772b50aae344c74f698ba5170622c5f015ee3" translate="yes" xml:space="preserve">
          <source>ToUppercase::fold</source>
          <target state="translated">ToUppercase::fold</target>
        </trans-unit>
        <trans-unit id="771853b6cd0b3a3d225b473ef9703bb5e4303729" translate="yes" xml:space="preserve">
          <source>ToUppercase::for_each</source>
          <target state="translated">ToUppercase::for_each</target>
        </trans-unit>
        <trans-unit id="8ce8c4bb893f0605c572e1569c0a3c898fc706ea" translate="yes" xml:space="preserve">
          <source>ToUppercase::from</source>
          <target state="translated">ToUppercase::from</target>
        </trans-unit>
        <trans-unit id="e5bc2c74a5fd665c9a82c2a33e80270730f97b12" translate="yes" xml:space="preserve">
          <source>ToUppercase::fuse</source>
          <target state="translated">ToUppercase::fuse</target>
        </trans-unit>
        <trans-unit id="20067e8f8574346c33f6af0deb21cc95edf75430" translate="yes" xml:space="preserve">
          <source>ToUppercase::ge</source>
          <target state="translated">ToUppercase::ge</target>
        </trans-unit>
        <trans-unit id="d691aa9e30d434c7acd37842ea89626858043c5a" translate="yes" xml:space="preserve">
          <source>ToUppercase::gt</source>
          <target state="translated">ToUppercase::gt</target>
        </trans-unit>
        <trans-unit id="2c07bcd9aa88f2987da2c05609b8b051fbd0bd49" translate="yes" xml:space="preserve">
          <source>ToUppercase::inspect</source>
          <target state="translated">ToUppercase::inspect</target>
        </trans-unit>
        <trans-unit id="fdebac9771e781ff415a919dcfc0e2e2f813f95f" translate="yes" xml:space="preserve">
          <source>ToUppercase::into</source>
          <target state="translated">ToUppercase::into</target>
        </trans-unit>
        <trans-unit id="28c925e3769d53d774548da83c53adf049d9614e" translate="yes" xml:space="preserve">
          <source>ToUppercase::into_iter</source>
          <target state="translated">ToUppercase::into_iter</target>
        </trans-unit>
        <trans-unit id="bf3856a1c7cdbe8a6b0b5d5447d4f1dda66c5b87" translate="yes" xml:space="preserve">
          <source>ToUppercase::is_empty</source>
          <target state="translated">ToUppercase::is_empty</target>
        </trans-unit>
        <trans-unit id="e56ebe838b86d90990ba23ebb8e7d7b475bfba70" translate="yes" xml:space="preserve">
          <source>ToUppercase::is_sorted</source>
          <target state="translated">ToUppercase::is_sorted</target>
        </trans-unit>
        <trans-unit id="e213f890c3567bf89ebbd96dd28396c3c8369989" translate="yes" xml:space="preserve">
          <source>ToUppercase::is_sorted_by</source>
          <target state="translated">ToUppercase::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="4214e06077f37c115583c69ea8457f9ca4ca03c8" translate="yes" xml:space="preserve">
          <source>ToUppercase::is_sorted_by_key</source>
          <target state="translated">ToUppercase::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="43c20634324c1e57c53610dd095c7b85f97be6a8" translate="yes" xml:space="preserve">
          <source>ToUppercase::last</source>
          <target state="translated">ToUppercase::last</target>
        </trans-unit>
        <trans-unit id="e15b9289846aa62aa7c399eec130546dddf92570" translate="yes" xml:space="preserve">
          <source>ToUppercase::le</source>
          <target state="translated">ToUppercase::le</target>
        </trans-unit>
        <trans-unit id="bf4ae1725f8c939f34b0f3698672e2eca8d46e36" translate="yes" xml:space="preserve">
          <source>ToUppercase::len</source>
          <target state="translated">ToUppercase::len</target>
        </trans-unit>
        <trans-unit id="6ef86484cb6e83aca67edc255bfe91855fddeaee" translate="yes" xml:space="preserve">
          <source>ToUppercase::lt</source>
          <target state="translated">ToUppercase::lt</target>
        </trans-unit>
        <trans-unit id="36fb30f84e7d12187cc3a5d20674f0ffa2e7e434" translate="yes" xml:space="preserve">
          <source>ToUppercase::map</source>
          <target state="translated">ToUppercase::map</target>
        </trans-unit>
        <trans-unit id="a5794f06c8f621ebfd36483cb2bdfba69962a46b" translate="yes" xml:space="preserve">
          <source>ToUppercase::max</source>
          <target state="translated">ToUppercase::max</target>
        </trans-unit>
        <trans-unit id="54ed5ffb42b174875a2cfcdf299aa03324e7d8e8" translate="yes" xml:space="preserve">
          <source>ToUppercase::max_by</source>
          <target state="translated">ToUppercase::max_by</target>
        </trans-unit>
        <trans-unit id="82140a942c03457466b33d70a38f8b426ee443a8" translate="yes" xml:space="preserve">
          <source>ToUppercase::max_by_key</source>
          <target state="translated">ToUppercase::max_by_key</target>
        </trans-unit>
        <trans-unit id="8c46ff457e70dbefd5377da1fe14a1d716feed69" translate="yes" xml:space="preserve">
          <source>ToUppercase::min</source>
          <target state="translated">ToUppercase::min</target>
        </trans-unit>
        <trans-unit id="1f4f06fa647a15bfd6777e3ad80989539da952c2" translate="yes" xml:space="preserve">
          <source>ToUppercase::min_by</source>
          <target state="translated">ToUppercase::min_by</target>
        </trans-unit>
        <trans-unit id="d2ca7b43662db6e83751c9781321c5f447b69b54" translate="yes" xml:space="preserve">
          <source>ToUppercase::min_by_key</source>
          <target state="translated">ToUppercase::min_by_key</target>
        </trans-unit>
        <trans-unit id="a2c10d642735dd01dd2230f6eb42d2d15de01ca4" translate="yes" xml:space="preserve">
          <source>ToUppercase::ne</source>
          <target state="translated">ToUppercase::ne</target>
        </trans-unit>
        <trans-unit id="bdcf8b574275972312b79411fc90c298fec5c707" translate="yes" xml:space="preserve">
          <source>ToUppercase::next</source>
          <target state="translated">ToUppercase::next</target>
        </trans-unit>
        <trans-unit id="d3b98223ff39c0cf8bc6901176a913dbb5af5a3f" translate="yes" xml:space="preserve">
          <source>ToUppercase::nth</source>
          <target state="translated">ToUppercase::nth</target>
        </trans-unit>
        <trans-unit id="ac55c59ffb3d1b90b5281f1cdb8221031a9f3d86" translate="yes" xml:space="preserve">
          <source>ToUppercase::partial_cmp</source>
          <target state="translated">ToUppercase::partial_cmp</target>
        </trans-unit>
        <trans-unit id="43ba4010531c56c76a71cac5c7783bb9326c06ff" translate="yes" xml:space="preserve">
          <source>ToUppercase::partition</source>
          <target state="translated">ToUppercase::partition</target>
        </trans-unit>
        <trans-unit id="8a67cd96d9e9df3939b7f6b2d037a84acda5915a" translate="yes" xml:space="preserve">
          <source>ToUppercase::peekable</source>
          <target state="translated">ToUppercase::peekable</target>
        </trans-unit>
        <trans-unit id="c5de4cd05b5eea91f6372ea13496d89698a886d9" translate="yes" xml:space="preserve">
          <source>ToUppercase::position</source>
          <target state="translated">ToUppercase::position</target>
        </trans-unit>
        <trans-unit id="3276e7acdf8a52ca46452466df5445f95d4c42ce" translate="yes" xml:space="preserve">
          <source>ToUppercase::product</source>
          <target state="translated">ToUppercase::product</target>
        </trans-unit>
        <trans-unit id="2ec3aca6fa0998e131a8dbb7e0429f53b8e20e3a" translate="yes" xml:space="preserve">
          <source>ToUppercase::rev</source>
          <target state="translated">ToUppercase::rev</target>
        </trans-unit>
        <trans-unit id="1f5b04931231d64a89f93330632ae0491d9a8306" translate="yes" xml:space="preserve">
          <source>ToUppercase::rposition</source>
          <target state="translated">ToUppercase::rposition</target>
        </trans-unit>
        <trans-unit id="bd0bd16a7f62be84e2b4f57e866e556615bf5f51" translate="yes" xml:space="preserve">
          <source>ToUppercase::scan</source>
          <target state="translated">ToUppercase::scan</target>
        </trans-unit>
        <trans-unit id="c12a079f9acc9eb022d00c3c9e691984df24e3dd" translate="yes" xml:space="preserve">
          <source>ToUppercase::size_hint</source>
          <target state="translated">ToUppercase::size_hint</target>
        </trans-unit>
        <trans-unit id="36cc8342ae3ebfcc66e29de8713ad4b5d25ed1ec" translate="yes" xml:space="preserve">
          <source>ToUppercase::skip</source>
          <target state="translated">ToUppercase::skip</target>
        </trans-unit>
        <trans-unit id="bc763b46d6ffe3cde30022e6b310b987fb4690fc" translate="yes" xml:space="preserve">
          <source>ToUppercase::skip_while</source>
          <target state="translated">ToUppercase::skip_while</target>
        </trans-unit>
        <trans-unit id="bdd73144830ccf5acc66a08a0eb4055b58dd100c" translate="yes" xml:space="preserve">
          <source>ToUppercase::step_by</source>
          <target state="translated">ToUppercase::step_by</target>
        </trans-unit>
        <trans-unit id="355510b3a2c94feee0516eb6236e6b26c520c86f" translate="yes" xml:space="preserve">
          <source>ToUppercase::sum</source>
          <target state="translated">ToUppercase::sum</target>
        </trans-unit>
        <trans-unit id="5f1bfaa41ae891ff2a87080b765b405813dfaf1e" translate="yes" xml:space="preserve">
          <source>ToUppercase::take</source>
          <target state="translated">ToUppercase::take</target>
        </trans-unit>
        <trans-unit id="ace4eaaac22836c883eb26f26b69083a1e81c44a" translate="yes" xml:space="preserve">
          <source>ToUppercase::take_while</source>
          <target state="translated">ToUppercase::take_while</target>
        </trans-unit>
        <trans-unit id="aeac81822411ec59962d593c1135903013fb64dd" translate="yes" xml:space="preserve">
          <source>ToUppercase::to_owned</source>
          <target state="translated">ToUppercase::to_owned</target>
        </trans-unit>
        <trans-unit id="c254c93eabb3947af47ca116107ff60db0f65f9f" translate="yes" xml:space="preserve">
          <source>ToUppercase::to_string</source>
          <target state="translated">ToUppercase::to_string</target>
        </trans-unit>
        <trans-unit id="9586835b3ffa68bc81bff272ded62df7bfd896a5" translate="yes" xml:space="preserve">
          <source>ToUppercase::try_fold</source>
          <target state="translated">ToUppercase::try_fold</target>
        </trans-unit>
        <trans-unit id="3285dc30d7466785bb24e349a2a90f48ee1105df" translate="yes" xml:space="preserve">
          <source>ToUppercase::try_for_each</source>
          <target state="translated">ToUppercase::try_for_each</target>
        </trans-unit>
        <trans-unit id="f78675d80da0fb2dc076781338842ee7388e6bbb" translate="yes" xml:space="preserve">
          <source>ToUppercase::try_from</source>
          <target state="translated">ToUppercase::try_from</target>
        </trans-unit>
        <trans-unit id="bbc85f420c55ff506706c343e3d016f559155d33" translate="yes" xml:space="preserve">
          <source>ToUppercase::try_into</source>
          <target state="translated">ToUppercase::try_into</target>
        </trans-unit>
        <trans-unit id="67c5523cb2fdea348c069bcedcae5b194e0fa100" translate="yes" xml:space="preserve">
          <source>ToUppercase::type_id</source>
          <target state="translated">ToUppercase::type_id</target>
        </trans-unit>
        <trans-unit id="59512192fd21e6e15883e4c5f16fa785a7ae4b9e" translate="yes" xml:space="preserve">
          <source>ToUppercase::unzip</source>
          <target state="translated">ToUppercase::unzip</target>
        </trans-unit>
        <trans-unit id="71c5320853e9bf97d3c8e47e587d200e6ab7e991" translate="yes" xml:space="preserve">
          <source>ToUppercase::zip</source>
          <target state="translated">ToUppercase::zip</target>
        </trans-unit>
        <trans-unit id="c38c6c1f3a2743f8626703abb302e403d20ff81c" translate="yes" xml:space="preserve">
          <source>Tokens</source>
          <target state="translated">Tokens</target>
        </trans-unit>
        <trans-unit id="23b07a92f99f26864b1d4cab09dbe7e6ffc01402" translate="yes" xml:space="preserve">
          <source>Tokens are primitive productions in the grammar defined by regular (non-recursive) languages. Rust source input can be broken down into the following kinds of tokens:</source>
          <target state="translated">토큰은 일반 (재귀 적이 지 않은) 언어로 정의 된 문법의 기본 프로덕션입니다. 녹 소스 입력은 다음과 같은 종류의 토큰으로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3997b5b9595479642fa6a353b8f62de4c85bdb4" translate="yes" xml:space="preserve">
          <source>Too few type arguments were supplied for a function. For example:</source>
          <target state="translated">함수에 제공되는 형식 인수가 너무 적습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b64cc80b4d048074e951f53af2266c9b980ecc1d" translate="yes" xml:space="preserve">
          <source>Too many type arguments were supplied for a function. For example:</source>
          <target state="translated">함수에 너무 많은 유형 인수가 제공되었습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3becdad8640a8a7664cb1587373bbed530e9eaef" translate="yes" xml:space="preserve">
          <source>Tool attributes</source>
          <target state="translated">도구 속성</target>
        </trans-unit>
        <trans-unit id="298b5435880f729f28b40fb8cb4d6d358f7d7bda" translate="yes" xml:space="preserve">
          <source>Tool attributes are not available if the &lt;a href=&quot;items/modules#prelude-items&quot;&gt;&lt;code&gt;no_implicit_prelude&lt;/code&gt;&lt;/a&gt; attribute is used.</source>
          <target state="translated">&lt;a href=&quot;items/modules#prelude-items&quot;&gt; &lt;code&gt;no_implicit_prelude&lt;/code&gt; &lt;/a&gt; 속성을 사용 하면 도구 속성을 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="04ecf72079460c624f56de2aec19167e9b592e5f" translate="yes" xml:space="preserve">
          <source>Tool lint attributes</source>
          <target state="translated">도구 보푸라기 속성</target>
        </trans-unit>
        <trans-unit id="9e4ff695f8d7f54d10234c8c693febf11bceeb0a" translate="yes" xml:space="preserve">
          <source>Tool lints allows using scoped lints, to &lt;code&gt;allow&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt;, &lt;code&gt;deny&lt;/code&gt; or &lt;code&gt;forbid&lt;/code&gt; lints of certain tools.</source>
          <target state="translated">도구 보푸라기 보푸라기를 사용하여 특정 도구의 보푸라기 를 &lt;code&gt;allow&lt;/code&gt; , &lt;code&gt;warn&lt;/code&gt; , &lt;code&gt;deny&lt;/code&gt; 또는 &lt;code&gt;forbid&lt;/code&gt; 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0cfacecf587078db6db43488caa6d580978c4bb" translate="yes" xml:space="preserve">
          <source>Tool lints only get checked when the associated tool is active. If a lint attribute, such as &lt;code&gt;allow&lt;/code&gt;, references a nonexistent tool lint, the compiler will not warn about the nonexistent lint until you use the tool.</source>
          <target state="translated">도구 보풀은 연결된 도구가 활성화 된 경우에만 확인됩니다. &lt;code&gt;allow&lt;/code&gt; 와 같은 lint 속성 이 존재하지 않는 도구 보푸라기를 참조하는 경우 도구를 사용할 때까지 컴파일러는 존재하지 않는 보푸라기에 대해 경고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2b3bf7074f1000742128073f003a13e0d75375fa" translate="yes" xml:space="preserve">
          <source>Tracking the inebriation of customers at a bar</source>
          <target state="translated">술집에서 고객의 식욕 추적</target>
        </trans-unit>
        <trans-unit id="8a6c5b14d85fb7777855348d57172119a05a9066" translate="yes" xml:space="preserve">
          <source>Trade-offs of the State Pattern</source>
          <target state="translated">국가 패턴의 절충</target>
        </trans-unit>
        <trans-unit id="b36366d44b437b0f859e29f4614b0107cecfe355" translate="yes" xml:space="preserve">
          <source>Trait</source>
          <target state="translated">Trait</target>
        </trans-unit>
        <trans-unit id="7418cda1dddd9f707baf2b1acabeb7297ddae8f4" translate="yes" xml:space="preserve">
          <source>Trait Bound Syntax</source>
          <target state="translated">특성 바인딩 구문</target>
        </trans-unit>
        <trans-unit id="79d040a039f209d4b088e4414045e49f19a318f9" translate="yes" xml:space="preserve">
          <source>Trait Implementation Coherence</source>
          <target state="translated">특성 구현 일관성</target>
        </trans-unit>
        <trans-unit id="26b898f7f42ac0607067211907cfe144baef2099" translate="yes" xml:space="preserve">
          <source>Trait Implementations</source>
          <target state="translated">특성 구현</target>
        </trans-unit>
        <trans-unit id="29c33623e3eecc134b62bfbdf8421daa25449235" translate="yes" xml:space="preserve">
          <source>Trait Object Layout</source>
          <target state="translated">특성 개체 레이아웃</target>
        </trans-unit>
        <trans-unit id="1d17f32f109df2cae8776e118c0cd08d010484eb" translate="yes" xml:space="preserve">
          <source>Trait Object Lifetime Bounds</source>
          <target state="translated">특성 개체 수명 한계</target>
        </trans-unit>
        <trans-unit id="0f2fa6f9f52d26ee86cd56ce4895853eea3665a6" translate="yes" xml:space="preserve">
          <source>Trait Objects Perform Dynamic Dispatch</source>
          <target state="translated">특성 객체가 동적 디스패치를 ​​수행</target>
        </trans-unit>
        <trans-unit id="a75e14ab76ff0ab816d5d3c2937abd862e423b2f" translate="yes" xml:space="preserve">
          <source>Trait and lifetime bounds</source>
          <target state="translated">특성과 수명 한계</target>
        </trans-unit>
        <trans-unit id="41af368f93d8a39d7122b161977ffe16f6a12e35" translate="yes" xml:space="preserve">
          <source>Trait and lifetime bounds are also used to name &lt;a href=&quot;types/trait-object&quot;&gt;trait objects&lt;/a&gt;.</source>
          <target state="translated">특성 및 수명 한계는 &lt;a href=&quot;types/trait-object&quot;&gt;특성 오브젝트의&lt;/a&gt; 이름을 지정하는 데에도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="941497474640686e1a5e201b7a0add49b752830f" translate="yes" xml:space="preserve">
          <source>Trait bounds</source>
          <target state="translated">특성 범위</target>
        </trans-unit>
        <trans-unit id="4fcf62d60d13dd717001ca9dd0618f2bf25f60fb" translate="yes" xml:space="preserve">
          <source>Trait for equality comparisons which are &lt;a href=&quot;http://en.wikipedia.org/wiki/Partial_equivalence_relation&quot;&gt;partial equivalence relations&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Partial_equivalence_relation&quot;&gt;부분 동등 관계인&lt;/a&gt; 동등 비교를위한 특성 .</target>
        </trans-unit>
        <trans-unit id="ef0a7e79d3d4953fe69d9a8d5ee6294c86326bfd" translate="yes" xml:space="preserve">
          <source>Trait for equality comparisons which are &lt;a href=&quot;https://en.wikipedia.org/wiki/Equivalence_relation&quot;&gt;equivalence relations&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Equivalence_relation&quot;&gt;동등성 관계인&lt;/a&gt; 평등 비교를위한 특성 .</target>
        </trans-unit>
        <trans-unit id="8cec9bd7b654341aff1af9f8d64c24f966f7b024" translate="yes" xml:space="preserve">
          <source>Trait for types that form a &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order&quot;&gt;total order&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order&quot;&gt;전체 주문&lt;/a&gt; 을 구성하는 유형의 장점 .</target>
        </trans-unit>
        <trans-unit id="eda5d9fc229c855a2ef6aa3c2bfb5731468bf0cc" translate="yes" xml:space="preserve">
          <source>Trait for values that can be compared for a sort-order.</source>
          <target state="translated">정렬 순서와 비교할 수있는 값을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="64186133cfc350eebda0888af60b096eb938c6a7" translate="yes" xml:space="preserve">
          <source>Trait implementations</source>
          <target state="translated">특성 구현</target>
        </trans-unit>
        <trans-unit id="1a2ed29df58a98467df7b65482664c061f2e57d4" translate="yes" xml:space="preserve">
          <source>Trait implementations can only implement associated constants that are members of the trait in question. This error indicates that you attempted to implement an associated constant whose name does not match the name of any associated constant in the trait.</source>
          <target state="translated">특성 구현은 해당 특성의 멤버 인 관련 상수 만 구현할 수 있습니다. 이 오류는 이름이 특성의 연관된 상수 이름과 일치하지 않는 연관된 상수를 구현하려고 시도했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="dc82d5ecd28dae290ae968b51be9ef3018535288" translate="yes" xml:space="preserve">
          <source>Trait implementations can only implement associated types that are members of the trait in question. This error indicates that you attempted to implement an associated type whose name does not match the name of any associated type in the trait.</source>
          <target state="translated">특성 구현은 해당 특성의 구성원 인 연관된 유형 만 구현할 수 있습니다. 이 오류는 이름이 특성에서 연관된 유형의 이름과 일치하지 않는 연관된 유형을 구현하려고 시도했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="93dc7d0661c7c1cf56a871254e1715d367179182" translate="yes" xml:space="preserve">
          <source>Trait methods cannot be declared &lt;code&gt;const&lt;/code&gt; by design. For more information, see &lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/911&quot;&gt;RFC 911&lt;/a&gt;.</source>
          <target state="translated">특성 메서드는 의도적으로 &lt;code&gt;const&lt;/code&gt; 로 선언 될 수 없습니다 . 자세한 정보는 &lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/911&quot;&gt;RFC 911을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3a51226ce6186ef57bc4f8d39074c6398e097981" translate="yes" xml:space="preserve">
          <source>Trait methods currently cannot take patterns as arguments.</source>
          <target state="translated">특성 메소드는 현재 패턴을 인수로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2484ce752e551a673766cb07f53076cdd0470999" translate="yes" xml:space="preserve">
          <source>Trait objects</source>
          <target state="translated">특성 개체</target>
        </trans-unit>
        <trans-unit id="d0ff67bb0a0ee2576fc48fed596bc8092c7aa725" translate="yes" xml:space="preserve">
          <source>Trait objects are a form of dynamic dispatch and use a dynamically sized type for the inner type. So, for a given trait &lt;code&gt;Trait&lt;/code&gt;, when &lt;code&gt;Trait&lt;/code&gt; is treated as a type, as in &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt;, the inner type is 'unsized'. In such cases the boxed pointer is a 'fat pointer' that contains an extra pointer to a table of methods (among other things) for dynamic dispatch. This design mandates some restrictions on the types of traits that are allowed to be used in trait objects, which are collectively termed as 'object safety' rules.</source>
          <target state="translated">특성 객체는 동적 디스패치의 한 형태이며 내부 유형에 대해 동적 크기의 유형을 사용합니다. 따라서 지정된 특성 &lt;code&gt;Trait&lt;/code&gt; 의 경우 &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; 에서와 같이 &lt;code&gt;Trait&lt;/code&gt; 이 유형으로 처리 되면 내부 유형은 '크기 조정되지 않습니다'. 이러한 경우 박스형 포인터는 동적 디스패치에 대한 메소드 테이블에 대한 추가 포인터를 포함하는 '지방 포인터'입니다. 이 설계는 집합 적 객체 안전 규칙으로 불리는 형질 개체에 사용될 수있는 형질 유형에 대한 일부 제한을 요구합니다.</target>
        </trans-unit>
        <trans-unit id="5ea53f21fe7d48d8c36beccecda99fd8c1606afe" translate="yes" xml:space="preserve">
          <source>Trait objects are written as the optional keyword &lt;code&gt;dyn&lt;/code&gt; followed by a set of trait bounds, but with the following restrictions on the trait bounds. All traits except the first trait must be auto traits, there may not be more than one lifetime, and opt-out bounds (e.g. &lt;code&gt;?Sized&lt;/code&gt;) are not allowed. Furthermore, paths to traits may be parenthesized.</source>
          <target state="translated">특성 개체는 선택적 키워드 &lt;code&gt;dyn&lt;/code&gt; 다음에 특성 범위가 설정되지만 특성 범위에 대해 다음과 같은 제한이 있습니다. 첫 번째 특성을 제외한 모든 특성은 자동 특성이어야하며 수명이 1 회를 초과 할 수 없으며 옵트 아웃 범위 (예 : &lt;code&gt;?Sized&lt;/code&gt; )는 허용되지 않습니다. 또한 특성의 경로는 괄호로 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59817a6fb01d811236061d6945ce61c60bbb6a8e" translate="yes" xml:space="preserve">
          <source>Trait objects have the same layout as the value the trait object is of.</source>
          <target state="translated">특성 개체는 특성 개체의 값과 동일한 레이아웃을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="1bbbb43369cd1da1e54ccdae8b4bbe0c9a735c31" translate="yes" xml:space="preserve">
          <source>Trait objects implement the base trait, its auto traits, and any &lt;a href=&quot;../items/traits#supertraits&quot;&gt;supertraits&lt;/a&gt; of the base trait.</source>
          <target state="translated">특성은 기본 특성, 자사의 자동차 특성, 및 구현합니다 &lt;a href=&quot;../items/traits#supertraits&quot;&gt;supertraits&lt;/a&gt; 기본 특성의를.</target>
        </trans-unit>
        <trans-unit id="d4f37b1632bc74808bbd4522d9d582acfc5a118f" translate="yes" xml:space="preserve">
          <source>Trait objects like &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; can only be constructed when certain requirements are satisfied by the trait in question.</source>
          <target state="translated">&lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; 과 같은 특성 개체 는 해당 특성이 특정 요구 사항을 충족하는 경우에만 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="046dc44c748313b6f776a3acf8abdd3d74f9acc5" translate="yes" xml:space="preserve">
          <source>Trait objects need to have all associated types specified. Erroneous code example:</source>
          <target state="translated">특성 개체는 모든 관련 유형을 지정해야합니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="ad068a7a9dcf8a835215d9d2bd6df82d37ea9f8e" translate="yes" xml:space="preserve">
          <source>Trait std::alloc::Alloc</source>
          <target state="translated">특성 std :: alloc :: Alloc</target>
        </trans-unit>
        <trans-unit id="863608218cf19a899841e79768deb9add49e00f3" translate="yes" xml:space="preserve">
          <source>Trait std::alloc::GlobalAlloc</source>
          <target state="translated">특성 std :: alloc :: GlobalAlloc</target>
        </trans-unit>
        <trans-unit id="392d8121c387b6100e7dca67e7c52d32a16a3def" translate="yes" xml:space="preserve">
          <source>Trait std::any::Any</source>
          <target state="translated">특성 std :: any :: Any</target>
        </trans-unit>
        <trans-unit id="0bdbfe0deda36628eacc51abdb83fdbfcea6cc11" translate="yes" xml:space="preserve">
          <source>Trait std::array::FixedSizeArray</source>
          <target state="translated">특성 std :: array :: FixedSizeArray</target>
        </trans-unit>
        <trans-unit id="1eb8a5154ce5a680a452312a74723021b34c3aaa" translate="yes" xml:space="preserve">
          <source>Trait std::ascii::AsciiExt</source>
          <target state="translated">특성 std :: ascii :: AsciiExt</target>
        </trans-unit>
        <trans-unit id="5de77502b5980be7c3473a72d6105527f1215243" translate="yes" xml:space="preserve">
          <source>Trait std::borrow::Borrow</source>
          <target state="translated">특성 std :: borrow :: Borrow</target>
        </trans-unit>
        <trans-unit id="70f054dd274fb96a8db0596d418507c91adce6b6" translate="yes" xml:space="preserve">
          <source>Trait std::borrow::BorrowMut</source>
          <target state="translated">특성 std :: borrow :: BorrowMut</target>
        </trans-unit>
        <trans-unit id="bbcce0cbc4cb2a4bf5264b04d903d25c0a192013" translate="yes" xml:space="preserve">
          <source>Trait std::borrow::ToOwned</source>
          <target state="translated">특성 std :: borrow :: ToOwned</target>
        </trans-unit>
        <trans-unit id="f2b9f8276056ca658e39ee7a72fdcb03a7c37efb" translate="yes" xml:space="preserve">
          <source>Trait std::clone::Clone</source>
          <target state="translated">특성 std :: clone :: Clone</target>
        </trans-unit>
        <trans-unit id="7cd5d0fd30409561bc6e76fd837e1f62470836a8" translate="yes" xml:space="preserve">
          <source>Trait std::cmp::Eq</source>
          <target state="translated">특성 std :: cmp :: Eq</target>
        </trans-unit>
        <trans-unit id="246cf166657201c68115fb66fd9221b8ffeb9ec4" translate="yes" xml:space="preserve">
          <source>Trait std::cmp::Ord</source>
          <target state="translated">특성 std :: cmp :: Ord</target>
        </trans-unit>
        <trans-unit id="72ff4c9778d08578e0f03c27d9d6272685274d91" translate="yes" xml:space="preserve">
          <source>Trait std::cmp::PartialEq</source>
          <target state="translated">특성 std :: cmp :: PartialEq</target>
        </trans-unit>
        <trans-unit id="4fde07025ebb4afc05e6897ef74b43fe5347e982" translate="yes" xml:space="preserve">
          <source>Trait std::cmp::PartialOrd</source>
          <target state="translated">특성 std :: cmp :: PartialOrd</target>
        </trans-unit>
        <trans-unit id="d870aa7cb7664d7c10835889d14c6b391cb4500e" translate="yes" xml:space="preserve">
          <source>Trait std::convert::AsMut</source>
          <target state="translated">특성 std :: convert :: AsMut</target>
        </trans-unit>
        <trans-unit id="d445d52fad68586ece567104043e8c242d2c7a73" translate="yes" xml:space="preserve">
          <source>Trait std::convert::AsRef</source>
          <target state="translated">특성 std :: convert :: AsRef</target>
        </trans-unit>
        <trans-unit id="1da7f8aa53cf47c39294631d860061958af42da6" translate="yes" xml:space="preserve">
          <source>Trait std::convert::From</source>
          <target state="translated">특성 std :: convert :: From</target>
        </trans-unit>
        <trans-unit id="b6ffd418e0a0b6d0cb5548ea09febb34aa5a1ba4" translate="yes" xml:space="preserve">
          <source>Trait std::convert::Into</source>
          <target state="translated">특성 std :: convert :: Into</target>
        </trans-unit>
        <trans-unit id="4d1380373e375c0e4553b789733d1a89b1fb0101" translate="yes" xml:space="preserve">
          <source>Trait std::convert::TryFrom</source>
          <target state="translated">특성 std :: convert :: TryFrom</target>
        </trans-unit>
        <trans-unit id="052f060bad402d8a2cd358057bd4871783c01ba4" translate="yes" xml:space="preserve">
          <source>Trait std::convert::TryInto</source>
          <target state="translated">특성 std :: convert :: TryInto</target>
        </trans-unit>
        <trans-unit id="36871446454b625eddb2f384614252a30a76670d" translate="yes" xml:space="preserve">
          <source>Trait std::default::Default</source>
          <target state="translated">특성 std :: default :: Default</target>
        </trans-unit>
        <trans-unit id="adf0d0f8b00918a2c28aba66b14f04f6c4e0fded" translate="yes" xml:space="preserve">
          <source>Trait std::error::Error</source>
          <target state="translated">특성 std :: error :: Error</target>
        </trans-unit>
        <trans-unit id="c2d288fe88fdd80f7dd81a3a1f2aeef5dc8ba7dc" translate="yes" xml:space="preserve">
          <source>Trait std::fmt::Binary</source>
          <target state="translated">특성 std :: fmt :: 바이너리</target>
        </trans-unit>
        <trans-unit id="33f44cc3a6de7dd1507041a00c8faf2775c0c8df" translate="yes" xml:space="preserve">
          <source>Trait std::fmt::Debug</source>
          <target state="translated">특성 std :: fmt :: Debug</target>
        </trans-unit>
        <trans-unit id="245d17885bbc5448412416b59b0f51c9d9b68eac" translate="yes" xml:space="preserve">
          <source>Trait std::fmt::Display</source>
          <target state="translated">특성 std :: fmt :: Display</target>
        </trans-unit>
        <trans-unit id="c8de6a747580fa084cc85d42225e02c2e93e67d5" translate="yes" xml:space="preserve">
          <source>Trait std::fmt::LowerExp</source>
          <target state="translated">특성 std :: fmt :: LowerExp</target>
        </trans-unit>
        <trans-unit id="e725d6041bd9bc4d83fca5b07971b62d421e6e64" translate="yes" xml:space="preserve">
          <source>Trait std::fmt::LowerHex</source>
          <target state="translated">특성 std :: fmt :: LowerHex</target>
        </trans-unit>
        <trans-unit id="194006985569f163bb35c90c3abcdbc7deec0e4a" translate="yes" xml:space="preserve">
          <source>Trait std::fmt::Octal</source>
          <target state="translated">특성 std :: fmt :: Octal</target>
        </trans-unit>
        <trans-unit id="8a32cd848a50f19a4618eac36d5bd1b3a315cf4d" translate="yes" xml:space="preserve">
          <source>Trait std::fmt::Pointer</source>
          <target state="translated">특성 std :: fmt :: 포인터</target>
        </trans-unit>
        <trans-unit id="8718228edc98337e120714c5797ad6fa1124ce31" translate="yes" xml:space="preserve">
          <source>Trait std::fmt::UpperExp</source>
          <target state="translated">특성 std :: fmt :: UpperExp</target>
        </trans-unit>
        <trans-unit id="26a977a1233b688edd74d1ce605bed2138e89350" translate="yes" xml:space="preserve">
          <source>Trait std::fmt::UpperHex</source>
          <target state="translated">특성 std :: fmt :: UpperHex</target>
        </trans-unit>
        <trans-unit id="0e6b8aa3448ea0d1e3124dcc61d87f01fb6bfd66" translate="yes" xml:space="preserve">
          <source>Trait std::fmt::Write</source>
          <target state="translated">특성 std :: fmt :: Write</target>
        </trans-unit>
        <trans-unit id="e8d3634caaf52ad6c8639c87d834bc299c37f7d5" translate="yes" xml:space="preserve">
          <source>Trait std::future::Future</source>
          <target state="translated">특성 std :: future :: Future</target>
        </trans-unit>
        <trans-unit id="e9cb7ef33fdeeee2adf1be409e245554e4935f7b" translate="yes" xml:space="preserve">
          <source>Trait std::hash::BuildHasher</source>
          <target state="translated">특성 std :: hash :: BuildHasher</target>
        </trans-unit>
        <trans-unit id="c7747499a3fe2fcc70735dec924c847206626023" translate="yes" xml:space="preserve">
          <source>Trait std::hash::Hash</source>
          <target state="translated">특성 std :: hash :: 해시</target>
        </trans-unit>
        <trans-unit id="2254c3bc605b18ffc7e9aa4bd6f57a17e5b13944" translate="yes" xml:space="preserve">
          <source>Trait std::hash::Hasher</source>
          <target state="translated">특성 std :: hash :: Hasher</target>
        </trans-unit>
        <trans-unit id="fd3fa6f5ef1435b1cb913f92dfb4fe0a0ac0248a" translate="yes" xml:space="preserve">
          <source>Trait std::io::BufRead</source>
          <target state="translated">특성 std :: io :: BufRead</target>
        </trans-unit>
        <trans-unit id="4c4e965bc67dd33a7c09b8db70c86024088aa45b" translate="yes" xml:space="preserve">
          <source>Trait std::io::Read</source>
          <target state="translated">특성 std :: io :: Read</target>
        </trans-unit>
        <trans-unit id="5d0aac0ef2620914932ce91ac2b555eba9c75b6a" translate="yes" xml:space="preserve">
          <source>Trait std::io::Seek</source>
          <target state="translated">특성 std :: io :: Seek</target>
        </trans-unit>
        <trans-unit id="23c37542e0343a876f9566d6681875d507142219" translate="yes" xml:space="preserve">
          <source>Trait std::io::Write</source>
          <target state="translated">특성 std :: io :: Write</target>
        </trans-unit>
        <trans-unit id="557d86b90451662a5be206878fb6037c4adc186c" translate="yes" xml:space="preserve">
          <source>Trait std::iter::DoubleEndedIterator</source>
          <target state="translated">특성 std :: iter :: DoubleEndedIterator</target>
        </trans-unit>
        <trans-unit id="f1b39cf8be9a057d9577992deaebe45e596b1a85" translate="yes" xml:space="preserve">
          <source>Trait std::iter::ExactSizeIterator</source>
          <target state="translated">특성 std :: iter :: ExactSizeIterator</target>
        </trans-unit>
        <trans-unit id="993ad040e2e34adc2956488f0eb4db104a067cbf" translate="yes" xml:space="preserve">
          <source>Trait std::iter::Extend</source>
          <target state="translated">특성 std :: iter :: Extend</target>
        </trans-unit>
        <trans-unit id="5d994406c4beb394a68ed1206fddfd385bea8323" translate="yes" xml:space="preserve">
          <source>Trait std::iter::FromIterator</source>
          <target state="translated">특성 std :: iter :: FromIterator</target>
        </trans-unit>
        <trans-unit id="2fce9eb181dd3ce47112a06174082d5e79cf74c2" translate="yes" xml:space="preserve">
          <source>Trait std::iter::FusedIterator</source>
          <target state="translated">특성 std :: iter :: FusedIterator</target>
        </trans-unit>
        <trans-unit id="e86b71b89c47a871b78ca20df617b375a62e7185" translate="yes" xml:space="preserve">
          <source>Trait std::iter::IntoIterator</source>
          <target state="translated">특성 std :: iter :: IntoIterator</target>
        </trans-unit>
        <trans-unit id="2da3e674c34b9eab7bfc5aeebb0e4f54178e88c3" translate="yes" xml:space="preserve">
          <source>Trait std::iter::Iterator</source>
          <target state="translated">특성 std :: iter :: Iterator</target>
        </trans-unit>
        <trans-unit id="28c48f7585e0c72c08462070ebcfc21850b855dd" translate="yes" xml:space="preserve">
          <source>Trait std::iter::Product</source>
          <target state="translated">특성 std :: iter :: 제품</target>
        </trans-unit>
        <trans-unit id="4cd139b55d183603c0136ea95dadb637efaf38a2" translate="yes" xml:space="preserve">
          <source>Trait std::iter::Step</source>
          <target state="translated">특성 std :: iter :: Step</target>
        </trans-unit>
        <trans-unit id="5db41fec6d94d07ed5a8c95c380992ba4e70704b" translate="yes" xml:space="preserve">
          <source>Trait std::iter::Sum</source>
          <target state="translated">특성 std :: iter :: Sum</target>
        </trans-unit>
        <trans-unit id="d2c14fdb677cf9e40834e0c15272aef7a318414f" translate="yes" xml:space="preserve">
          <source>Trait std::iter::TrustedLen</source>
          <target state="translated">특성 std :: iter :: TrustedLen</target>
        </trans-unit>
        <trans-unit id="97864c14469b7b4a0942294bc953528cb554eb45" translate="yes" xml:space="preserve">
          <source>Trait std::marker::Copy</source>
          <target state="translated">특성 std :: marker :: Copy</target>
        </trans-unit>
        <trans-unit id="d7b568be22b28c92ca0e71ed060c7b03cf03fb4f" translate="yes" xml:space="preserve">
          <source>Trait std::marker::Send</source>
          <target state="translated">특성 std :: marker :: Send</target>
        </trans-unit>
        <trans-unit id="00852f537576ef249f511a14cf0e0d88604a985c" translate="yes" xml:space="preserve">
          <source>Trait std::marker::Sized</source>
          <target state="translated">특성 std :: marker :: Sized</target>
        </trans-unit>
        <trans-unit id="259bdec063434c0a27f0691a2488a4567088a5e0" translate="yes" xml:space="preserve">
          <source>Trait std::marker::Sync</source>
          <target state="translated">특성 std :: marker :: Sync</target>
        </trans-unit>
        <trans-unit id="3f94365e96f98d2913bb838b56a6cb437e2a3543" translate="yes" xml:space="preserve">
          <source>Trait std::marker::Unpin</source>
          <target state="translated">특성 std :: marker :: Unpin</target>
        </trans-unit>
        <trans-unit id="311396699adc0c66b758dcec6485921335dcacf8" translate="yes" xml:space="preserve">
          <source>Trait std::marker::Unsize</source>
          <target state="translated">특성 std :: marker :: Unsize</target>
        </trans-unit>
        <trans-unit id="56b1f3f0f786678bf876540fb69232e234007e31" translate="yes" xml:space="preserve">
          <source>Trait std::net::ToSocketAddrs</source>
          <target state="translated">특성 std :: net :: ToSocketAddrs</target>
        </trans-unit>
        <trans-unit id="37966fc5ec2acafba273f997b504b3bf34ed922b" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Add</source>
          <target state="translated">특성 std :: ops :: Add</target>
        </trans-unit>
        <trans-unit id="eb2302d36fa57d1adc4a45dc1d240d27866b69da" translate="yes" xml:space="preserve">
          <source>Trait std::ops::AddAssign</source>
          <target state="translated">특성 std :: ops :: AddAssign</target>
        </trans-unit>
        <trans-unit id="b5f5f47beac59c26ee424be54e3b7e3d95164b94" translate="yes" xml:space="preserve">
          <source>Trait std::ops::BitAnd</source>
          <target state="translated">특성 std :: ops :: BitAnd</target>
        </trans-unit>
        <trans-unit id="fb181e8cea7de0ad56c4c91c6a0777e1d53fd765" translate="yes" xml:space="preserve">
          <source>Trait std::ops::BitAndAssign</source>
          <target state="translated">특성 std :: ops :: BitAndAssign</target>
        </trans-unit>
        <trans-unit id="b888f514c1fa78a8e8fe84b58a6fbc1d25aaf2c1" translate="yes" xml:space="preserve">
          <source>Trait std::ops::BitOr</source>
          <target state="translated">특성 std :: ops :: BitOr</target>
        </trans-unit>
        <trans-unit id="ca3ae8400b524007a326d21b18e44fb657bdb697" translate="yes" xml:space="preserve">
          <source>Trait std::ops::BitOrAssign</source>
          <target state="translated">특성 std :: ops :: BitOrAssign</target>
        </trans-unit>
        <trans-unit id="8d18eaa27370f1eb1f6ce036dc60c1aa5493c417" translate="yes" xml:space="preserve">
          <source>Trait std::ops::BitXor</source>
          <target state="translated">특성 std :: ops :: BitXor</target>
        </trans-unit>
        <trans-unit id="5961f53888aa07cd5cd15ed30fa1971a719c8b25" translate="yes" xml:space="preserve">
          <source>Trait std::ops::BitXorAssign</source>
          <target state="translated">특성 std :: ops :: BitXorAssign</target>
        </trans-unit>
        <trans-unit id="5e9158651355d13bfdd0cc23ab8ae22e93570742" translate="yes" xml:space="preserve">
          <source>Trait std::ops::CoerceUnsized</source>
          <target state="translated">특성 std :: ops :: CoerceUnsized</target>
        </trans-unit>
        <trans-unit id="e2225eef9926066643795abab6cb04cea79ce68b" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Deref</source>
          <target state="translated">특성 std :: ops :: Deref</target>
        </trans-unit>
        <trans-unit id="8071035f23a5d586519a8248517d2e29e7adcb51" translate="yes" xml:space="preserve">
          <source>Trait std::ops::DerefMut</source>
          <target state="translated">특성 std :: ops :: DerefMut</target>
        </trans-unit>
        <trans-unit id="1bdb82d5309eaed70f5481f05b19a4d41b5808d7" translate="yes" xml:space="preserve">
          <source>Trait std::ops::DispatchFromDyn</source>
          <target state="translated">특성 std :: ops :: DispatchFromDyn</target>
        </trans-unit>
        <trans-unit id="9119f5359ef3817ec9f0b7e45b3f1ecbc08a66ae" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Div</source>
          <target state="translated">특성 std :: ops :: Div</target>
        </trans-unit>
        <trans-unit id="f65e4311dbd340efad891a4945558b2592826b48" translate="yes" xml:space="preserve">
          <source>Trait std::ops::DivAssign</source>
          <target state="translated">특성 std :: ops :: DivAssign</target>
        </trans-unit>
        <trans-unit id="ead9d9ba97193a4d1ac24f05c905c8b13350ed9c" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Drop</source>
          <target state="translated">특성 std :: ops :: Drop</target>
        </trans-unit>
        <trans-unit id="516e4c37897e1d20a60743aea36782c56e8156a9" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Fn</source>
          <target state="translated">특성 std :: ops :: Fn</target>
        </trans-unit>
        <trans-unit id="77005c859f62996c3f249d5673d1b2c4d6da6a8e" translate="yes" xml:space="preserve">
          <source>Trait std::ops::FnMut</source>
          <target state="translated">특성 std :: ops :: FnMut</target>
        </trans-unit>
        <trans-unit id="b435f6c3c75102c4c8177872a25a996a1ff95c72" translate="yes" xml:space="preserve">
          <source>Trait std::ops::FnOnce</source>
          <target state="translated">특성 std :: ops :: FnOnce</target>
        </trans-unit>
        <trans-unit id="9aa827be880a5bea9bb3024a041653fb3a60ff06" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Generator</source>
          <target state="translated">특성 std :: ops :: Generator</target>
        </trans-unit>
        <trans-unit id="59811c59bb31cbb96886cf966994463b72ad700c" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Index</source>
          <target state="translated">특성 std :: ops :: Index</target>
        </trans-unit>
        <trans-unit id="1b08e9090daf7ede77089f8107e6507872bde2ab" translate="yes" xml:space="preserve">
          <source>Trait std::ops::IndexMut</source>
          <target state="translated">특성 std :: ops :: IndexMut</target>
        </trans-unit>
        <trans-unit id="10babff383e103d1471a771d922a28289586b73a" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Mul</source>
          <target state="translated">특성 std :: ops :: Mul</target>
        </trans-unit>
        <trans-unit id="b32e6664a7b4d68e303b33188cda08fc977bd7b7" translate="yes" xml:space="preserve">
          <source>Trait std::ops::MulAssign</source>
          <target state="translated">특성 std :: ops :: MulAssign</target>
        </trans-unit>
        <trans-unit id="7244a7be2c4624654c9b462b1947447297e505fd" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Neg</source>
          <target state="translated">특성 std :: ops :: Neg</target>
        </trans-unit>
        <trans-unit id="598dee8649518d42201f87386801464e34102c60" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Not</source>
          <target state="translated">특성 std :: ops :: Not</target>
        </trans-unit>
        <trans-unit id="bc51ccaddf33118323d7fc1d905d959ce650d2fc" translate="yes" xml:space="preserve">
          <source>Trait std::ops::RangeBounds</source>
          <target state="translated">특성 std :: ops :: RangeBounds</target>
        </trans-unit>
        <trans-unit id="4ee55841b26a89cf9d805e3a28fb34dc38ab767a" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Rem</source>
          <target state="translated">특성 std :: ops :: 램</target>
        </trans-unit>
        <trans-unit id="a0e35ffe757b24704f0ad197b4f1a2195f4a4f69" translate="yes" xml:space="preserve">
          <source>Trait std::ops::RemAssign</source>
          <target state="translated">특성 std :: ops :: RemAssign</target>
        </trans-unit>
        <trans-unit id="5922247946e4630b62a74e89d87c15ed9dbf8321" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Shl</source>
          <target state="translated">특성 std :: ops :: Shl</target>
        </trans-unit>
        <trans-unit id="f84eeb046dfef53ab5217181c0fe9161eb7133b2" translate="yes" xml:space="preserve">
          <source>Trait std::ops::ShlAssign</source>
          <target state="translated">특성 std :: ops :: ShlAssign</target>
        </trans-unit>
        <trans-unit id="55d865e44b6599da1d5b41d269ec7455a02e4d75" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Shr</source>
          <target state="translated">특성 std :: ops :: Shr</target>
        </trans-unit>
        <trans-unit id="e7c92d6f8a50e1ae3b29a226a8335aff1fecf601" translate="yes" xml:space="preserve">
          <source>Trait std::ops::ShrAssign</source>
          <target state="translated">특성 std :: ops :: ShrAssign</target>
        </trans-unit>
        <trans-unit id="cbaeb43954d65c4471777365a4ccdaf3b98314da" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Sub</source>
          <target state="translated">특성 std :: ops :: Sub</target>
        </trans-unit>
        <trans-unit id="60e6a61f8c88f9e6239b7053de7f86d23a70926d" translate="yes" xml:space="preserve">
          <source>Trait std::ops::SubAssign</source>
          <target state="translated">특성 std :: ops :: SubAssign</target>
        </trans-unit>
        <trans-unit id="1e84214c3e8570e12d3f9ef3b558be6c152516f7" translate="yes" xml:space="preserve">
          <source>Trait std::ops::Try</source>
          <target state="translated">특성 std :: ops :: Try</target>
        </trans-unit>
        <trans-unit id="aee85e47c1ef28a026ccdb2b42dd67004cf6d92b" translate="yes" xml:space="preserve">
          <source>Trait std::os::linux::fs::MetadataExt</source>
          <target state="translated">특성 std :: os :: linux :: fs :: MetadataExt</target>
        </trans-unit>
        <trans-unit id="ce6f693798415e4676d8d1ff10beb4360e2b88ea" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::ffi::OsStrExt</source>
          <target state="translated">특성 std :: os :: unix :: ffi :: OsStrExt</target>
        </trans-unit>
        <trans-unit id="ccee631397fcdd7aa7a9f0bce0da5d850063085b" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::ffi::OsStringExt</source>
          <target state="translated">특성 std :: os :: unix :: ffi :: OsStringExt</target>
        </trans-unit>
        <trans-unit id="e621c9f13dd9d62e26bc7432de51e95d4d92457d" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::fs::DirBuilderExt</source>
          <target state="translated">특성 std :: os :: unix :: fs :: DirBuilderExt</target>
        </trans-unit>
        <trans-unit id="0709fdc0b13d2f0cb5f5c17d0f41b133a5719e30" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::fs::DirEntryExt</source>
          <target state="translated">특성 std :: os :: unix :: fs :: DirEntryExt</target>
        </trans-unit>
        <trans-unit id="030f7ec1f295cca2c02129cf381f726caf5a30ca" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::fs::FileExt</source>
          <target state="translated">특성 std :: os :: unix :: fs :: FileExt</target>
        </trans-unit>
        <trans-unit id="f955ea7fe9356c94c24f7600e345d8c1f23ecc81" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::fs::FileTypeExt</source>
          <target state="translated">특성 std :: os :: unix :: fs :: FileTypeExt</target>
        </trans-unit>
        <trans-unit id="062f7bd7816b0a1187ddcd41fdc03811ea335026" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::fs::MetadataExt</source>
          <target state="translated">특성 std :: os :: unix :: fs :: MetadataExt</target>
        </trans-unit>
        <trans-unit id="5cc7126ad859e04f63e6bf507db0f3f32c1e3609" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::fs::OpenOptionsExt</source>
          <target state="translated">특성 std :: os :: unix :: fs :: OpenOptionsExt</target>
        </trans-unit>
        <trans-unit id="7b61dfb2986a0864a907b937d464ff43d30cc28a" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::fs::PermissionsExt</source>
          <target state="translated">특성 std :: os :: unix :: fs :: PermissionsExt</target>
        </trans-unit>
        <trans-unit id="029585bd86a69a9cb4ab7c864e7dc9b2373a14b3" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::io::AsRawFd</source>
          <target state="translated">특성 std :: os :: unix :: io :: AsRawFd</target>
        </trans-unit>
        <trans-unit id="e4e4a27468811544480dddf3c4047ee3d4694a0c" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::io::FromRawFd</source>
          <target state="translated">특성 std :: os :: unix :: io :: FromRawFd</target>
        </trans-unit>
        <trans-unit id="ad731bff461d938e10c799939e10ae14e837a1d4" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::io::IntoRawFd</source>
          <target state="translated">특성 std :: os :: unix :: io :: IntoRawFd</target>
        </trans-unit>
        <trans-unit id="e0e834bab744daaedf71c0c8937cc0857c11c815" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::process::CommandExt</source>
          <target state="translated">특성 std :: os :: unix :: process :: CommandExt</target>
        </trans-unit>
        <trans-unit id="3fdb072f5381c741536b73b80e58115bb5f3dc4d" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::process::ExitStatusExt</source>
          <target state="translated">특성 std :: os :: unix :: process :: ExitStatusExt</target>
        </trans-unit>
        <trans-unit id="398944c7337c4aa8b95b799fcb3bb79124d70d16" translate="yes" xml:space="preserve">
          <source>Trait std::os::unix::thread::JoinHandleExt</source>
          <target state="translated">특성 std :: os :: unix :: thread :: JoinHandleExt</target>
        </trans-unit>
        <trans-unit id="775a7a0c3bd36d7ff6360e6cd0ef765ee978cd67" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::ffi::OsStrExt</source>
          <target state="translated">특성 std :: os :: windows :: ffi :: OsStrExt</target>
        </trans-unit>
        <trans-unit id="fef545ee7fe66334043f38cfbfbf352be492c487" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::ffi::OsStringExt</source>
          <target state="translated">특성 std :: os :: windows :: ffi :: OsStringExt</target>
        </trans-unit>
        <trans-unit id="ecb052e97ecce0a67db913c47f009bfcbacc3af0" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::fs::FileExt</source>
          <target state="translated">특성 std :: os :: windows :: fs :: FileExt</target>
        </trans-unit>
        <trans-unit id="91c8fb448f57a608a43c2c6a50e10bec34d5ab25" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::fs::FileTypeExt</source>
          <target state="translated">특성 std :: os :: windows :: fs :: FileTypeExt</target>
        </trans-unit>
        <trans-unit id="48eaa197d2777c5eb543ac927807cb3bcfa429bf" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::fs::MetadataExt</source>
          <target state="translated">특성 std :: os :: windows :: fs :: MetadataExt</target>
        </trans-unit>
        <trans-unit id="adfee6aa3be6cbe6237011186a8914e73584ae0c" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::fs::OpenOptionsExt</source>
          <target state="translated">특성 std :: os :: windows :: fs :: OpenOptionsExt</target>
        </trans-unit>
        <trans-unit id="2cdd2fa8158633908c8d054d4d1297a0e8730a45" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::io::AsRawHandle</source>
          <target state="translated">특성 std :: os :: windows :: io :: AsRawHandle</target>
        </trans-unit>
        <trans-unit id="0d00fd25b06cb924c3fdd7f42d54ec1498a98e1b" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::io::AsRawSocket</source>
          <target state="translated">특성 std :: os :: windows :: io :: AsRawSocket</target>
        </trans-unit>
        <trans-unit id="61063f360cb8b5295929ae6072d8fe4c6d6e69db" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::io::FromRawHandle</source>
          <target state="translated">특성 std :: os :: windows :: io :: FromRawHandle</target>
        </trans-unit>
        <trans-unit id="7942dc2954f8548cc31aadda78e4bf28314f92d8" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::io::FromRawSocket</source>
          <target state="translated">특성 std :: os :: windows :: io :: FromRawSocket</target>
        </trans-unit>
        <trans-unit id="bb1fb08e33748cf05582377cef8603a0b7d61ea6" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::io::IntoRawHandle</source>
          <target state="translated">특성 std :: os :: windows :: io :: IntoRawHandle</target>
        </trans-unit>
        <trans-unit id="1fe8126ee24f29a74bcdb4233344f05c1aaeb804" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::io::IntoRawSocket</source>
          <target state="translated">특성 std :: os :: windows :: io :: IntoRawSocket</target>
        </trans-unit>
        <trans-unit id="03f13d9ed2758f8306f48846a3b40b6e4ee6fb67" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::process::CommandExt</source>
          <target state="translated">특성 std :: os :: windows :: process :: CommandExt</target>
        </trans-unit>
        <trans-unit id="5474211db770299d01cd13e53280d9a32e0a6eb8" translate="yes" xml:space="preserve">
          <source>Trait std::os::windows::process::ExitStatusExt</source>
          <target state="translated">특성 std :: os :: windows :: process :: ExitStatusExt</target>
        </trans-unit>
        <trans-unit id="f12279b49645006e0e35a65e657e45472c813936" translate="yes" xml:space="preserve">
          <source>Trait std::panic::RefUnwindSafe</source>
          <target state="translated">특성 std :: panic :: RefUnwindSafe</target>
        </trans-unit>
        <trans-unit id="94584086fc586a7b81f5ac90f21ac1115c03a3ce" translate="yes" xml:space="preserve">
          <source>Trait std::panic::UnwindSafe</source>
          <target state="translated">특성 std :: panic :: UnwindSafe</target>
        </trans-unit>
        <trans-unit id="adb81f6851cec81b5352770932f85397129ab8a4" translate="yes" xml:space="preserve">
          <source>Trait std::process::Termination</source>
          <target state="translated">특성 std :: process :: Termination</target>
        </trans-unit>
        <trans-unit id="7640946c865124bdea836774595f3568b91b7998" translate="yes" xml:space="preserve">
          <source>Trait std::slice::SliceConcatExt</source>
          <target state="translated">특성 std :: slice :: SliceConcatExt</target>
        </trans-unit>
        <trans-unit id="f46e5f5628a346f08367c4e254d503cf40a8e630" translate="yes" xml:space="preserve">
          <source>Trait std::slice::SliceIndex</source>
          <target state="translated">특성 std :: slice :: SliceIndex</target>
        </trans-unit>
        <trans-unit id="376de5fab14024883dddc8825294275d1ab087fe" translate="yes" xml:space="preserve">
          <source>Trait std::str::FromStr</source>
          <target state="translated">특성 std :: str :: FromStr</target>
        </trans-unit>
        <trans-unit id="44dfa41c6566ca84e623c4ad35fe85e2a3871106" translate="yes" xml:space="preserve">
          <source>Trait std::str::pattern::DoubleEndedSearcher</source>
          <target state="translated">특성 std :: str :: pattern :: DoubleEndedSearcher</target>
        </trans-unit>
        <trans-unit id="60d7ae5ae877268eee71ef1b870695c55f5799dd" translate="yes" xml:space="preserve">
          <source>Trait std::str::pattern::Pattern</source>
          <target state="translated">특성 std :: str :: pattern :: Pattern</target>
        </trans-unit>
        <trans-unit id="57c9157b22b76a9e5814b9b5b2e9d0438b5d56c6" translate="yes" xml:space="preserve">
          <source>Trait std::str::pattern::ReverseSearcher</source>
          <target state="translated">특성 std :: str :: pattern :: ReverseSearcher</target>
        </trans-unit>
        <trans-unit id="c47b1d5d24f300a29158b5903ba66de94f2261c7" translate="yes" xml:space="preserve">
          <source>Trait std::str::pattern::Searcher</source>
          <target state="translated">특성 std :: str :: pattern :: Searcher</target>
        </trans-unit>
        <trans-unit id="44bc0cc22a45fc90a102d47cbd5cd3c88d279925" translate="yes" xml:space="preserve">
          <source>Trait std::string::ToString</source>
          <target state="translated">특성 std :: string :: ToString</target>
        </trans-unit>
        <trans-unit id="902e019f3fc71a92236203a22158a6e688676cd4" translate="yes" xml:space="preserve">
          <source>Trait that indicates that this is a pointer or a wrapper for one, where unsizing can be performed on the pointee.</source>
          <target state="translated">포인트가 크기 조정을 수행 할 수있는 포인터 또는 래퍼임을 나타내는 특성입니다.</target>
        </trans-unit>
        <trans-unit id="914213ad374b434003e30cd9d7bcaca26d295c77" translate="yes" xml:space="preserve">
          <source>Trait to represent types that can be created by multiplying elements of an iterator.</source>
          <target state="translated">반복자의 요소를 곱하여 작성할 수있는 유형을 나타내는 특성입니다.</target>
        </trans-unit>
        <trans-unit id="badf961de53295edcdb207c7619b3c8c3ea8ab3f" translate="yes" xml:space="preserve">
          <source>Trait to represent types that can be created by summing up an iterator.</source>
          <target state="translated">반복자를 합산하여 만들 수있는 유형을 나타내는 특성입니다.</target>
        </trans-unit>
        <trans-unit id="d881d840fb21638a45b7fe784d4a5eb2d495d58e" translate="yes" xml:space="preserve">
          <source>Trait types:</source>
          <target state="translated">특성 유형 :</target>
        </trans-unit>
        <trans-unit id="602d794344a5274058fe843b2cdf8ec0429dd8a0" translate="yes" xml:space="preserve">
          <source>Trait types: &lt;a href=&quot;types/trait-object&quot;&gt;Trait objects&lt;/a&gt; and &lt;a href=&quot;types/impl-trait&quot;&gt;impl trait&lt;/a&gt;.</source>
          <target state="translated">특성 유형 : &lt;a href=&quot;types/trait-object&quot;&gt;특성 개체&lt;/a&gt; 및 &lt;a href=&quot;types/impl-trait&quot;&gt;특성&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9bb3c78c542b9f8ec90ade6e9ec8d9a3209bf67e" translate="yes" xml:space="preserve">
          <source>TraitObject</source>
          <target state="translated">TraitObject</target>
        </trans-unit>
        <trans-unit id="6dafbe61d09e60652f6bbad6957562daf88836c1" translate="yes" xml:space="preserve">
          <source>TraitObject::borrow</source>
          <target state="translated">TraitObject::borrow</target>
        </trans-unit>
        <trans-unit id="d4a155778d83f0c6e0941f69c58ed350bc406da6" translate="yes" xml:space="preserve">
          <source>TraitObject::borrow_mut</source>
          <target state="translated">TraitObject::borrow_mut</target>
        </trans-unit>
        <trans-unit id="1ad27b39ed4c34288ce66526e3c4d0c6cfa27a49" translate="yes" xml:space="preserve">
          <source>TraitObject::clone</source>
          <target state="translated">TraitObject::clone</target>
        </trans-unit>
        <trans-unit id="f7e5bbc88cb023be138b61515a8a95359d090a5c" translate="yes" xml:space="preserve">
          <source>TraitObject::clone_from</source>
          <target state="translated">TraitObject::clone_from</target>
        </trans-unit>
        <trans-unit id="fdf0c70ef2387158d4df2cba6555b292ed39d46d" translate="yes" xml:space="preserve">
          <source>TraitObject::clone_into</source>
          <target state="translated">TraitObject::clone_into</target>
        </trans-unit>
        <trans-unit id="743885aa5243b74deebe5c3d51ac4806100e3c4f" translate="yes" xml:space="preserve">
          <source>TraitObject::from</source>
          <target state="translated">TraitObject::from</target>
        </trans-unit>
        <trans-unit id="83e65850a79cb15fc900dff422e0637ecd287f18" translate="yes" xml:space="preserve">
          <source>TraitObject::into</source>
          <target state="translated">TraitObject::into</target>
        </trans-unit>
        <trans-unit id="4d10ca4ab3471cdb18500652e2706f1af91011a7" translate="yes" xml:space="preserve">
          <source>TraitObject::to_owned</source>
          <target state="translated">TraitObject::to_owned</target>
        </trans-unit>
        <trans-unit id="cb08794c131e1ac1a49313ec36f386568341f2c9" translate="yes" xml:space="preserve">
          <source>TraitObject::try_from</source>
          <target state="translated">TraitObject::try_from</target>
        </trans-unit>
        <trans-unit id="368b837c4e44612f1f89ff1a01dc94c771822d93" translate="yes" xml:space="preserve">
          <source>TraitObject::try_into</source>
          <target state="translated">TraitObject::try_into</target>
        </trans-unit>
        <trans-unit id="74e84d6c289e114766c37bd05fe2729da4981e80" translate="yes" xml:space="preserve">
          <source>TraitObject::type_id</source>
          <target state="translated">TraitObject::type_id</target>
        </trans-unit>
        <trans-unit id="d1a616085a1a99a58e14bafaa350abc6783a3160" translate="yes" xml:space="preserve">
          <source>Traits</source>
          <target state="translated">Traits</target>
        </trans-unit>
        <trans-unit id="9c97df5331a0dd1cf9d7e4754c7f28e534496f46" translate="yes" xml:space="preserve">
          <source>Traits and trait bounds let us write code that uses generic type parameters to reduce duplication but also specify to the compiler that we want the generic type to have particular behavior. The compiler can then use the trait bound information to check that all the concrete types used with our code provide the correct behavior. In dynamically typed languages, we would get an error at runtime if we called a method on a type that the type didn&amp;rsquo;t implement. But Rust moves these errors to compile time so we&amp;rsquo;re forced to fix the problems before our code is even able to run. Additionally, we don&amp;rsquo;t have to write code that checks for behavior at runtime because we&amp;rsquo;ve already checked at compile time. Doing so improves performance without having to give up the flexibility of generics.</source>
          <target state="translated">특성과 특성 범위를 통해 일반 형식 매개 변수를 사용하여 중복을 줄이면서 일반 형식에 특정 동작을 수행하도록 컴파일러에 지정하는 코드를 작성할 수 있습니다. 그런 다음 컴파일러는 특성 바인딩 정보를 사용하여 코드와 함께 사용 된 모든 구체적인 유형이 올바른 동작을 제공하는지 확인할 수 있습니다. 동적으로 유형이 지정된 언어에서는 유형이 구현하지 않은 유형에 대해 메소드를 호출하면 런타임시 오류가 발생합니다. 그러나 Rust는 이러한 오류를 컴파일 시간으로 이동하므로 코드를 실행하기 전에 문제를 해결해야합니다. 또한 컴파일 타임에 이미 확인 했으므로 런타임시 동작을 확인하는 코드를 작성할 필요가 없습니다. 이렇게하면 제네릭의 유연성을 포기하지 않고도 성능이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="30d92be1538d577b3a476ce5c89b01f7242bf547" translate="yes" xml:space="preserve">
          <source>Traits are also compared by their implementation:</source>
          <target state="translated">특성도 구현에 의해 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="66685be42641df1c5c014df0db7fb2681f6517c0" translate="yes" xml:space="preserve">
          <source>Traits are implemented for specific types through separate &lt;a href=&quot;implementations&quot;&gt;implementations&lt;/a&gt;.</source>
          <target state="translated">특성은 별도의 &lt;a href=&quot;implementations&quot;&gt;구현을&lt;/a&gt; 통해 특정 유형에 대해 구현 됩니다.</target>
        </trans-unit>
        <trans-unit id="68c3dbb43f5798e7691ebd93a6d889062ce5c80e" translate="yes" xml:space="preserve">
          <source>Traits as Parameters</source>
          <target state="translated">매개 변수로서의 특성</target>
        </trans-unit>
        <trans-unit id="f1779dfd4e53a302206ca9f432ac589991148919" translate="yes" xml:space="preserve">
          <source>Traits for conversions between types.</source>
          <target state="translated">유형 간 변환을위한 특성.</target>
        </trans-unit>
        <trans-unit id="5129fe11a670c9d54f51f82654cb88d2c5359dd3" translate="yes" xml:space="preserve">
          <source>Traits for working with Errors.</source>
          <target state="translated">오류 작업을위한 특성.</target>
        </trans-unit>
        <trans-unit id="e714d1e850bbb5cbfe4cbf81d9f96ff676eaae8d" translate="yes" xml:space="preserve">
          <source>Traits items that begin with the &lt;code&gt;unsafe&lt;/code&gt; keyword indicate that &lt;em&gt;implementing&lt;/em&gt; the trait may be &lt;a href=&quot;../unsafety&quot;&gt;unsafe&lt;/a&gt;. It is safe to use a correctly implemented unsafe trait. The &lt;a href=&quot;implementations#trait-implementations&quot;&gt;trait implementation&lt;/a&gt; must also begin with the &lt;code&gt;unsafe&lt;/code&gt; keyword.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; 키워드로 시작하는 특성 항목 은 특성 을 &lt;em&gt;구현&lt;/em&gt; 하는 것이 &lt;a href=&quot;../unsafety&quot;&gt;안전하지&lt;/a&gt; 않을 수 있음을 나타냅니다 . 올바르게 구현 된 안전하지 않은 특성을 사용하는 것이 안전합니다. &lt;a href=&quot;implementations#trait-implementations&quot;&gt;특성 구현&lt;/a&gt; 도 시작해야 &lt;code&gt;unsafe&lt;/code&gt; 키워드.</target>
        </trans-unit>
        <trans-unit id="7b45c49a33c4022855bfa5d2a686751214a7126a" translate="yes" xml:space="preserve">
          <source>Traits may be implemented for</source>
          <target state="translated">특성은</target>
        </trans-unit>
        <trans-unit id="986fcbb6a73e7cc26d2d8b2b6164011d8bab7460" translate="yes" xml:space="preserve">
          <source>Traits, helpers, and type definitions for core I/O functionality.</source>
          <target state="translated">핵심 I / O 기능에 대한 특성, 도우미 및 유형 정의</target>
        </trans-unit>
        <trans-unit id="9aa77953b92e4e6c565758326d541910014cfd21" translate="yes" xml:space="preserve">
          <source>Traits: Defining Shared Behavior</source>
          <target state="translated">특성 : 공유 된 행동 정의</target>
        </trans-unit>
        <trans-unit id="d8a8f61d9f0fd714531d17d414abcb212572f131" translate="yes" xml:space="preserve">
          <source>Transcribing</source>
          <target state="translated">Transcribing</target>
        </trans-unit>
        <trans-unit id="2df1d93dea4e259eb26edde2c26eb9c20992b104" translate="yes" xml:space="preserve">
          <source>Transforms an iterator into a collection.</source>
          <target state="translated">이터레이터를 컬렉션으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="81c1484a18bb69461dc41663b8ca61aba770c66a" translate="yes" xml:space="preserve">
          <source>Transforms an iterator into a collection. &lt;a href=&quot;../../../iter/trait.iterator#method.collect&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이터레이터를 컬렉션으로 변환합니다. &lt;a href=&quot;../../../iter/trait.iterator#method.collect&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0fe9703c09ae5aff473aa850cc9ea84e177f2a25" translate="yes" xml:space="preserve">
          <source>Transforms an iterator into a collection. &lt;a href=&quot;../../iter/trait.iterator#method.collect&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이터레이터를 컬렉션으로 변환합니다. &lt;a href=&quot;../../iter/trait.iterator#method.collect&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d95c53779cc93ec00cbab50bc8d1d781ee0140b9" translate="yes" xml:space="preserve">
          <source>Transforms an iterator into a collection. &lt;a href=&quot;../iter/trait.iterator#method.collect&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이터레이터를 컬렉션으로 변환합니다. &lt;a href=&quot;../iter/trait.iterator#method.collect&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8f6c7d5e9d128d42f6100c26dc454bf0231e3a05" translate="yes" xml:space="preserve">
          <source>Transforms an iterator into a collection. &lt;a href=&quot;iter/trait.iterator#method.collect&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이터레이터를 컬렉션으로 변환합니다. &lt;a href=&quot;iter/trait.iterator#method.collect&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6f3c54bd44a2ac346c25bc4bf8dc990a7215290b" translate="yes" xml:space="preserve">
          <source>Transforms an iterator into a collection. &lt;a href=&quot;trait.iterator#method.collect&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이터레이터를 컬렉션으로 변환합니다. &lt;a href=&quot;trait.iterator#method.collect&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6d04afdfe20a5d1e30c5697c258379dba1dfdd82" translate="yes" xml:space="preserve">
          <source>Transforms the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; into a &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;, mapping &lt;a href=&quot;#variant.Some&quot;&gt;&lt;code&gt;Some(v)&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(v)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err(err())&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">변환하는 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 에 &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt; , 매핑 &lt;a href=&quot;#variant.Some&quot;&gt; &lt;code&gt;Some(v)&lt;/code&gt; &lt;/a&gt; 로 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(v)&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 에 &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err(err())&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a32b0b090c9474f23fede28872bd2f862d58ca7" translate="yes" xml:space="preserve">
          <source>Transforms the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; into a &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;, mapping &lt;a href=&quot;#variant.Some&quot;&gt;&lt;code&gt;Some(v)&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(v)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err(err)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">변환하는 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 에 대한 &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt; , 매핑 &lt;a href=&quot;#variant.Some&quot;&gt; &lt;code&gt;Some(v)&lt;/code&gt; &lt;/a&gt; 로 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(v)&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 에 &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err(err)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b4eb95563ead3e77457aefa3ae80b465ed16f04e" translate="yes" xml:space="preserve">
          <source>Transforms this &lt;code&gt;Read&lt;/code&gt; instance to an &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; over its bytes.</source>
          <target state="translated">이 &lt;code&gt;Read&lt;/code&gt; 인스턴스를 바이트 단위 의 &lt;a href=&quot;../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; 로&lt;/a&gt; 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="03c96526be3584d2d000005b6f01d7d3341c8987" translate="yes" xml:space="preserve">
          <source>Transforms this &lt;code&gt;Read&lt;/code&gt; instance to an [&lt;code&gt;Iterator&lt;/code&gt;] over its bytes. &lt;a href=&quot;../../../io/trait.read#method.bytes&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 &lt;code&gt;Read&lt;/code&gt; 인스턴스를 바이트 단위 의 [ &lt;code&gt;Iterator&lt;/code&gt; ] 로 변환 합니다. &lt;a href=&quot;../../../io/trait.read#method.bytes&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="12fec74288b63220271ad545369927ef8290a081" translate="yes" xml:space="preserve">
          <source>Transforms this &lt;code&gt;Read&lt;/code&gt; instance to an [&lt;code&gt;Iterator&lt;/code&gt;] over its bytes. &lt;a href=&quot;../io/trait.read#method.bytes&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 &lt;code&gt;Read&lt;/code&gt; 인스턴스를 바이트 단위 의 [ &lt;code&gt;Iterator&lt;/code&gt; ] 로 변환 합니다. &lt;a href=&quot;../io/trait.read#method.bytes&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="caf9cf05351d52e3be9282ae06933a14488056d3" translate="yes" xml:space="preserve">
          <source>Transforms this &lt;code&gt;Read&lt;/code&gt; instance to an [&lt;code&gt;Iterator&lt;/code&gt;] over its bytes. &lt;a href=&quot;io/trait.read#method.bytes&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 &lt;code&gt;Read&lt;/code&gt; 인스턴스를 바이트 단위 의 [ &lt;code&gt;Iterator&lt;/code&gt; ] 로 변환 합니다. &lt;a href=&quot;io/trait.read#method.bytes&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="971992e8ed9d30a3c4193fa3cfd51e0926ac6cae" translate="yes" xml:space="preserve">
          <source>Transforms this &lt;code&gt;Read&lt;/code&gt; instance to an [&lt;code&gt;Iterator&lt;/code&gt;] over its bytes. &lt;a href=&quot;trait.read#method.bytes&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 &lt;code&gt;Read&lt;/code&gt; 인스턴스를 바이트 단위 의 [ &lt;code&gt;Iterator&lt;/code&gt; ] 로 변환 합니다. &lt;a href=&quot;trait.read#method.bytes&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a3526b9261f151b08efa12a2cb227e4ab668a50" translate="yes" xml:space="preserve">
          <source>Transmute the slice to a slice of another type, ensuring alignment of the types is maintained.</source>
          <target state="translated">슬라이스를 다른 유형의 슬라이스로 변환하여 유형의 정렬이 유지되도록합니다.</target>
        </trans-unit>
        <trans-unit id="f952303e87a91f8044520d869ced49cf3453271e" translate="yes" xml:space="preserve">
          <source>Transmute with two differently sized types was attempted. Erroneous code example:</source>
          <target state="translated">크기가 다른 두 가지 유형의 변환이 시도되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="b4634eab766a7c67f4a788882ed6708930ac7723" translate="yes" xml:space="preserve">
          <source>Transposes a &lt;code&gt;Result&lt;/code&gt; of an &lt;code&gt;Option&lt;/code&gt; into an &lt;code&gt;Option&lt;/code&gt; of a &lt;code&gt;Result&lt;/code&gt;.</source>
          <target state="translated">조바꿈 &lt;code&gt;Result&lt;/code&gt; 의 &lt;code&gt;Option&lt;/code&gt; 에 &lt;code&gt;Option&lt;/code&gt; (A)의 &lt;code&gt;Result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86f3938f31467da551894d5bc312a73ba5dfa379" translate="yes" xml:space="preserve">
          <source>Transposes an &lt;code&gt;Option&lt;/code&gt; of a &lt;code&gt;Result&lt;/code&gt; into a &lt;code&gt;Result&lt;/code&gt; of an &lt;code&gt;Option&lt;/code&gt;.</source>
          <target state="translated">조바꿈 &lt;code&gt;Option&lt;/code&gt; (A)의 &lt;code&gt;Result&lt;/code&gt; 에 &lt;code&gt;Result&lt;/code&gt; 의 &lt;code&gt;Option&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9ccf92c436ad92e69f629d1e0488d9928d7d7e6" translate="yes" xml:space="preserve">
          <source>Treating Smart Pointers Like Regular References with the &lt;code id=&quot;treating-smart-pointers-like-regular-references-with-the-deref-trait&quot;&gt;Deref&lt;/code&gt; Trait</source>
          <target state="translated">&lt;code id=&quot;treating-smart-pointers-like-regular-references-with-the-deref-trait&quot;&gt;Deref&lt;/code&gt; Trait을 사용하여 스마트 포인터를 일반 참조처럼 취급</target>
        </trans-unit>
        <trans-unit id="453a0f8e23093d2d468470224b84f666ef425b17" translate="yes" xml:space="preserve">
          <source>Treating a Type Like a Reference by Implementing the &lt;code id=&quot;treating-a-type-like-a-reference-by-implementing-the-deref-trait&quot;&gt;Deref&lt;/code&gt; Trait</source>
          <target state="translated">이행하여 참조처럼 타입을 치료 &lt;code id=&quot;treating-a-type-like-a-reference-by-implementing-the-deref-trait&quot;&gt;Deref&lt;/code&gt; 형질을</target>
        </trans-unit>
        <trans-unit id="dc5f05aecd7821404c68147034c8c8b762c94716" translate="yes" xml:space="preserve">
          <source>Treating each integration test file as its own crate is useful to create separate scopes that are more like the way end users will be using your crate. However, this means files in the &lt;em&gt;tests&lt;/em&gt; directory don&amp;rsquo;t share the same behavior as files in &lt;em&gt;src&lt;/em&gt; do, as you learned in Chapter 7 regarding how to separate code into modules and files.</source>
          <target state="translated">각 통합 테스트 파일을 자체 크레이트로 처리하면 최종 사용자가 크레이트를 사용하는 방식과 유사한 별도의 범위를 만드는 데 유용합니다. 그러나 7 장에서 코드를 모듈과 파일로 분리하는 방법에 대해 배운 것처럼 &lt;em&gt;tests&lt;/em&gt; 디렉토리의 파일은 &lt;em&gt;src의&lt;/em&gt; 파일과 동일한 동작을 공유하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7569cb1679e0c3aa7540702f13a5f8dd4a1739a0" translate="yes" xml:space="preserve">
          <source>Tries to reserve capacity for at least &lt;code&gt;additional&lt;/code&gt; more elements to be inserted in the given &lt;code&gt;HashMap&amp;lt;K,V&amp;gt;&lt;/code&gt;. The collection may reserve more space to avoid frequent reallocations.</source>
          <target state="translated">주어진 &lt;code&gt;HashMap&amp;lt;K,V&amp;gt;&lt;/code&gt; 삽입 할 요소를 &lt;code&gt;additional&lt;/code&gt; 로 확보하려고합니다 . 컬렉션은 빈번한 재 할당을 피하기 위해 더 많은 공간을 예약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44298809e4f1f115c9f5ba28f46ae5a8d609bfc3" translate="yes" xml:space="preserve">
          <source>Tries to reserve capacity for at least &lt;code&gt;additional&lt;/code&gt; more elements to be inserted in the given &lt;code&gt;HashSet&amp;lt;K,V&amp;gt;&lt;/code&gt;. The collection may reserve more space to avoid frequent reallocations.</source>
          <target state="translated">주어진 &lt;code&gt;HashSet&amp;lt;K,V&amp;gt;&lt;/code&gt; 삽입 할 요소를 &lt;code&gt;additional&lt;/code&gt; 로 확보하려고합니다 . 컬렉션은 빈번한 재 할당을 피하기 위해 더 많은 공간을 예약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57b7ed7bcbd15d35b279a1bce9bfd658efd71b2a" translate="yes" xml:space="preserve">
          <source>Tries to reserve capacity for at least &lt;code&gt;additional&lt;/code&gt; more elements to be inserted in the given &lt;code&gt;String&lt;/code&gt;. The collection may reserve more space to avoid frequent reallocations. After calling &lt;code&gt;reserve&lt;/code&gt;, capacity will be greater than or equal to &lt;code&gt;self.len() + additional&lt;/code&gt;. Does nothing if capacity is already sufficient.</source>
          <target state="translated">주어진 &lt;code&gt;String&lt;/code&gt; 삽입 할 요소를 &lt;code&gt;additional&lt;/code&gt; 로 확보하려고합니다 . 컬렉션은 빈번한 재 할당을 피하기 위해 더 많은 공간을 예약 할 수 있습니다. &lt;code&gt;reserve&lt;/code&gt; 를 호출 한 후 용량은 &lt;code&gt;self.len() + additional&lt;/code&gt; 보다 크거나 같습니다 . 용량이 이미 충분한 경우 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1cd7b987cbc0791bfb1324cfd6464263751dd7d3" translate="yes" xml:space="preserve">
          <source>Tries to reserve capacity for at least &lt;code&gt;additional&lt;/code&gt; more elements to be inserted in the given &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. The collection may reserve more space to avoid frequent reallocations. After calling &lt;code&gt;reserve&lt;/code&gt;, capacity will be greater than or equal to &lt;code&gt;self.len() + additional&lt;/code&gt;. Does nothing if capacity is already sufficient.</source>
          <target state="translated">주어진 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 삽입 할 요소를 &lt;code&gt;additional&lt;/code&gt; 로 확보하려고합니다 . 컬렉션은 빈번한 재 할당을 피하기 위해 더 많은 공간을 예약 할 수 있습니다. &lt;code&gt;reserve&lt;/code&gt; 를 호출 한 후 용량은 &lt;code&gt;self.len() + additional&lt;/code&gt; 보다 크거나 같습니다 . 용량이 이미 충분한 경우 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ddb2f7e963d7384fcd84f59781aafbcb1eefd0c" translate="yes" xml:space="preserve">
          <source>Tries to reserve capacity for at least &lt;code&gt;additional&lt;/code&gt; more elements to be inserted in the given &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;. The collection may reserve more space to avoid frequent reallocations. After calling &lt;code&gt;reserve&lt;/code&gt;, capacity will be greater than or equal to &lt;code&gt;self.len() + additional&lt;/code&gt;. Does nothing if capacity is already sufficient.</source>
          <target state="translated">주어진 &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; 삽입 할 요소를 &lt;code&gt;additional&lt;/code&gt; 로 확보하려고합니다 . 컬렉션은 빈번한 재 할당을 피하기 위해 더 많은 공간을 예약 할 수 있습니다. &lt;code&gt;reserve&lt;/code&gt; 를 호출 한 후 용량은 &lt;code&gt;self.len() + additional&lt;/code&gt; 보다 크거나 같습니다 . 용량이 이미 충분한 경우 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ea826f973c60e61f52c1a1545b1dfe84c909b71b" translate="yes" xml:space="preserve">
          <source>Tries to reserves the minimum capacity for exactly &lt;code&gt;additional&lt;/code&gt; more elements to be inserted in the given &lt;code&gt;String&lt;/code&gt;. After calling &lt;code&gt;reserve_exact&lt;/code&gt;, capacity will be greater than or equal to &lt;code&gt;self.len() + additional&lt;/code&gt;. Does nothing if the capacity is already sufficient.</source>
          <target state="translated">주어진 &lt;code&gt;String&lt;/code&gt; 에 정확히 &lt;code&gt;additional&lt;/code&gt; 많은 요소를 삽입 할 수 있는 최소 용량을 확보하려고합니다 . &lt;code&gt;reserve_exact&lt;/code&gt; 를 호출 한 후 용량은 &lt;code&gt;self.len() + additional&lt;/code&gt; 보다 크거나 같습니다 . 용량이 이미 충분한 경우 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c6bd5db90f8cb9540fd3f35c2883f8b8a881d37a" translate="yes" xml:space="preserve">
          <source>Tries to reserves the minimum capacity for exactly &lt;code&gt;additional&lt;/code&gt; more elements to be inserted in the given &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. After calling &lt;code&gt;reserve_exact&lt;/code&gt;, capacity will be greater than or equal to &lt;code&gt;self.len() + additional&lt;/code&gt;. Does nothing if the capacity is already sufficient.</source>
          <target state="translated">주어진 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 에 정확히 &lt;code&gt;additional&lt;/code&gt; 많은 요소를 삽입 할 수 있는 최소 용량을 확보하려고합니다 . &lt;code&gt;reserve_exact&lt;/code&gt; 를 호출 한 후 용량은 &lt;code&gt;self.len() + additional&lt;/code&gt; 보다 크거나 같습니다 . 용량이 이미 충분한 경우 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="90bd1ab7f76bd67110646c064057b5e26a376cef" translate="yes" xml:space="preserve">
          <source>Tries to reserves the minimum capacity for exactly &lt;code&gt;additional&lt;/code&gt; more elements to be inserted in the given &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt;. After calling &lt;code&gt;reserve_exact&lt;/code&gt;, capacity will be greater than or equal to &lt;code&gt;self.len() + additional&lt;/code&gt;. Does nothing if the capacity is already sufficient.</source>
          <target state="translated">주어진 &lt;code&gt;VecDeque&amp;lt;T&amp;gt;&lt;/code&gt; 에 정확히 &lt;code&gt;additional&lt;/code&gt; 많은 요소를 삽입 할 수 있는 최소 용량을 확보하려고합니다 . &lt;code&gt;reserve_exact&lt;/code&gt; 를 호출 한 후 용량은 &lt;code&gt;self.len() + additional&lt;/code&gt; 보다 크거나 같습니다 . 용량이 이미 충분한 경우 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6547ac01541509cbac431ef7568ec956f10079ba" translate="yes" xml:space="preserve">
          <source>Triggers a panic without invoking the panic hook.</source>
          <target state="translated">패닉 후크를 호출하지 않고 패닉을 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="adb95599ef56aa13caaac1499a3644565e8b6049" translate="yes" xml:space="preserve">
          <source>Truncates &lt;code&gt;self&lt;/code&gt; to &lt;a href=&quot;struct.pathbuf#method.parent&quot;&gt;&lt;code&gt;self.parent&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자릅니다의 &lt;code&gt;self&lt;/code&gt; 에 &lt;a href=&quot;struct.pathbuf#method.parent&quot;&gt; &lt;code&gt;self.parent&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5927f0d5ac8801b4254d8379327d991a701a80da" translate="yes" xml:space="preserve">
          <source>Truncates or extends the underlying file, updating the size of this file to become &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">기본 파일을 자르거나 확장하여이 파일의 크기를 &lt;code&gt;size&lt;/code&gt; 가되도록 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="2702cfbf0e58f8f82fb23e8d650e499d7cc927c5" translate="yes" xml:space="preserve">
          <source>Truncates the &lt;code&gt;OsString&lt;/code&gt; to zero length.</source>
          <target state="translated">&lt;code&gt;OsString&lt;/code&gt; 을 0 길이로 자릅니다 .</target>
        </trans-unit>
        <trans-unit id="ed28d8bdecc758ddcef76eed8b86ffa1d4ea3181" translate="yes" xml:space="preserve">
          <source>Truncates this &lt;code&gt;String&lt;/code&gt;, removing all contents.</source>
          <target state="translated">이 &lt;code&gt;String&lt;/code&gt; 을 잘라내어 모든 내용을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="5474aa5946c713a1f6e7a033ad591db623edd6d3" translate="yes" xml:space="preserve">
          <source>Truncating a five element vector to two elements:</source>
          <target state="translated">다섯 요소 벡터를 두 요소로 자르기 :</target>
        </trans-unit>
        <trans-unit id="743f01c9ef69fe480785553858265deba678132e" translate="yes" xml:space="preserve">
          <source>Truncating when &lt;code&gt;len == 0&lt;/code&gt; is equivalent to calling the &lt;a href=&quot;#method.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;code&gt;len == 0&lt;/code&gt; 때 잘리는 것은 &lt;a href=&quot;#method.clear&quot;&gt; &lt;code&gt;clear&lt;/code&gt; &lt;/a&gt; 메서드 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="63908c3dcfc457f07a333b89f52c763024b846da" translate="yes" xml:space="preserve">
          <source>TrustedLen</source>
          <target state="translated">TrustedLen</target>
        </trans-unit>
        <trans-unit id="72677028b4d0d41af475041fdbe030f7c7146d2c" translate="yes" xml:space="preserve">
          <source>Try</source>
          <target state="translated">Try</target>
        </trans-unit>
        <trans-unit id="93cacc9f6a162523f52bc4401526c741faac95a0" translate="yes" xml:space="preserve">
          <source>Try designing more experiments that vary the values and lifetimes of the references passed in to the &lt;code&gt;longest&lt;/code&gt; function and how the returned reference is used. Make hypotheses about whether or not your experiments will pass the borrow checker before you compile; then check to see if you&amp;rsquo;re right!</source>
          <target state="translated">&lt;code&gt;longest&lt;/code&gt; 함수에 전달 된 참조의 값과 수명 및 반환 된 참조가 사용되는 방법 을 변화시키는 더 많은 실험을 설계하십시오 . 컴파일하기 전에 실험이 차용 검사기를 통과할지 여부에 대한 가설을 세우십시오. 그런 다음 당신이 옳은지 확인하십시오!</target>
        </trans-unit>
        <trans-unit id="b25651affa48a09fef804a246293a9441327deef" translate="yes" xml:space="preserve">
          <source>Try making a request from a different browser or asking for a different address, such as &lt;em&gt;127.0.0.1:7878/test&lt;/em&gt;, to see how the request data changes.</source>
          <target state="translated">다른 브라우저에서 요청하거나 &lt;em&gt;127.0.0.1:7878/test&lt;/em&gt; 와 같은 다른 주소를 요청하여 요청 데이터가 어떻게 변경되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="3cdedf03df7f2d7ff7f62a3fe4c0233e49c2605a" translate="yes" xml:space="preserve">
          <source>Try modifying &lt;code&gt;Cacher&lt;/code&gt; to hold a hash map rather than a single value. The keys of the hash map will be the &lt;code&gt;arg&lt;/code&gt; values that are passed in, and the values of the hash map will be the result of calling the closure on that key. Instead of looking at whether &lt;code&gt;self.value&lt;/code&gt; directly has a &lt;code&gt;Some&lt;/code&gt; or a &lt;code&gt;None&lt;/code&gt; value, the &lt;code&gt;value&lt;/code&gt; function will look up the &lt;code&gt;arg&lt;/code&gt; in the hash map and return the value if it&amp;rsquo;s present. If it&amp;rsquo;s not present, the &lt;code&gt;Cacher&lt;/code&gt; will call the closure and save the resulting value in the hash map associated with its &lt;code&gt;arg&lt;/code&gt; value.</source>
          <target state="translated">단일 값이 아닌 해시 맵을 보유 하도록 &lt;code&gt;Cacher&lt;/code&gt; 를 수정하십시오 . 해시 맵의 키 는 전달 된 &lt;code&gt;arg&lt;/code&gt; 값이되고 해시 맵의 값은 해당 키에서 클로저를 호출 한 결과가됩니다. &lt;code&gt;self.value&lt;/code&gt; 에 &lt;code&gt;Some&lt;/code&gt; 또는 &lt;code&gt;None&lt;/code&gt; 값 이 직접 있는지 확인하는 대신 &lt;code&gt;value&lt;/code&gt; 함수는 해시 맵에서 &lt;code&gt;arg&lt;/code&gt; 를 조회하고 존재하는 경우 값을 리턴합니다. 존재하지 않는 경우, &lt;code&gt;Cacher&lt;/code&gt; 는 클로저를 호출하고 결과 값을 &lt;code&gt;arg&lt;/code&gt; 값 과 관련된 해시 맵에 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="746db25e46725d2a25a5be38541b8fd90c0e318e" translate="yes" xml:space="preserve">
          <source>Try running the program a few times:</source>
          <target state="translated">프로그램을 몇 번 실행 해보십시오.</target>
        </trans-unit>
        <trans-unit id="40db21ca976b20c4f1a37614a766d7e0fedff356" translate="yes" xml:space="preserve">
          <source>Try running this code; you should see the following output:</source>
          <target state="translated">이 코드를 실행 해보십시오. 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="0c704dff8c8947b24bdb19d42ed1933021fa9b51" translate="yes" xml:space="preserve">
          <source>Try running this program with the &lt;code&gt;main&lt;/code&gt; function from Listing 13-2. Change the values in the &lt;code&gt;simulated_user_specified_value&lt;/code&gt; and &lt;code&gt;simulated_random_number&lt;/code&gt; variables to verify that in all the cases in the various &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks, &lt;code&gt;calculating slowly...&lt;/code&gt; appears only once and only when needed. The &lt;code&gt;Cacher&lt;/code&gt; takes care of the logic necessary to ensure we aren&amp;rsquo;t calling the expensive calculation more than we need to so &lt;code&gt;generate_workout&lt;/code&gt; can focus on the business logic.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 으로이 프로그램을 실행 해보십시오목록 13-2 기능 . 다양한 &lt;code&gt;if&lt;/code&gt; 및 &lt;code&gt;else&lt;/code&gt; 블록 의 모든 경우에 &lt;code&gt;calculating slowly...&lt;/code&gt; 것이 필요한 경우에만 한 번만 나타나는지 확인 하려면 &lt;code&gt;simulated_user_specified_value&lt;/code&gt; 및 &lt;code&gt;simulated_random_number&lt;/code&gt; 변수 의 값을 변경하십시오 . &lt;code&gt;Cacher&lt;/code&gt; 는 우리가 우리가 필요보다 더 비싼 계산을 호출되지 않도록하는 데 필요한 로직을 담당 &lt;code&gt;generate_workout&lt;/code&gt; 는 비즈니스 로직에 집중할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f64954535b22680cee23c59284f0821d313912c5" translate="yes" xml:space="preserve">
          <source>Try running this program; you should get the following output:</source>
          <target state="translated">이 프로그램을 실행 해보십시오. 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="4e2f79e768da3d333677b7768aba6698b9473abe" translate="yes" xml:space="preserve">
          <source>Try the tasks suggested for additional requirements that we mentioned at the start of this section on the &lt;code&gt;blog&lt;/code&gt; crate as it is after Listing 17-20 to see what you think about the design of this version of the code. Note that some of the tasks might be completed already in this design.</source>
          <target state="translated">Listing 17-20 이후로 &lt;code&gt;blog&lt;/code&gt; 상자 에서이 섹션의 시작 부분에서 언급 한 추가 요구 사항에 대해 제안 된 태스크를 시도하여이 코드 버전의 디자인에 대해 어떻게 생각하는지보십시오. 이 작업에서 일부 작업이 이미 완료되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bea7aa5241bc934fb93d73fbe72c3c92fd9cb391" translate="yes" xml:space="preserve">
          <source>Try this instead:</source>
          <target state="translated">대신 이것을 시도하십시오 :</target>
        </trans-unit>
        <trans-unit id="cf4dffd1f17e87d4131fe9dbd6ed3566366e3295" translate="yes" xml:space="preserve">
          <source>Try to avoid moving the variable.</source>
          <target state="translated">변수 이동을 피하십시오.</target>
        </trans-unit>
        <trans-unit id="708f496ce718cad5f2bfb9c2203cb73e375d06e0" translate="yes" xml:space="preserve">
          <source>Try to create the target number type from a source number type. This returns an error if the source value is outside of the range of the target type.</source>
          <target state="translated">소스 번호 유형에서 대상 번호 유형을 작성하십시오. 소스 값이 목표 유형의 범위를 벗어나면 오류를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d7bb54d91c5813615d6b6445e2ebf488e82cdc0c" translate="yes" xml:space="preserve">
          <source>Try using &lt;code&gt;{}&lt;/code&gt; instead:</source>
          <target state="translated">대신 &lt;code&gt;{}&lt;/code&gt; 를 사용해보십시오 .</target>
        </trans-unit>
        <trans-unit id="b8a1eb6a4114d62537aa281f5d03abf55ba6e9e3" translate="yes" xml:space="preserve">
          <source>Try using type inference instead. Example:</source>
          <target state="translated">대신 형식 유추를 사용해보십시오. 예:</target>
        </trans-unit>
        <trans-unit id="ea0079401a89dd04fe8291c0c734d4aa5a8c7177" translate="yes" xml:space="preserve">
          <source>Try::from_error</source>
          <target state="translated">Try::from_error</target>
        </trans-unit>
        <trans-unit id="bde6f44b7e04bd6491a07ffb037c4fa48b882a33" translate="yes" xml:space="preserve">
          <source>Try::from_ok</source>
          <target state="translated">Try::from_ok</target>
        </trans-unit>
        <trans-unit id="809111dd75695d75905fa1c8b4bad5d14691a30e" translate="yes" xml:space="preserve">
          <source>Try::into_result</source>
          <target state="translated">Try::into_result</target>
        </trans-unit>
        <trans-unit id="18e77d4b44ff639060d9a2fa2960f190781f7859" translate="yes" xml:space="preserve">
          <source>TryFrom</source>
          <target state="translated">TryFrom</target>
        </trans-unit>
        <trans-unit id="4acc1ac1c58ab4ae6724001d461baf2c8b8dbc3a" translate="yes" xml:space="preserve">
          <source>TryFrom::try_from</source>
          <target state="translated">TryFrom::try_from</target>
        </trans-unit>
        <trans-unit id="ad96c601815ad5f050e0b6351dd0b189e48a31a9" translate="yes" xml:space="preserve">
          <source>TryFromIntError</source>
          <target state="translated">TryFromIntError</target>
        </trans-unit>
        <trans-unit id="f81061adcf59a4b18f6432dc500e16b9a793d0e6" translate="yes" xml:space="preserve">
          <source>TryFromIntError::borrow</source>
          <target state="translated">TryFromIntError::borrow</target>
        </trans-unit>
        <trans-unit id="4d5e6ded3e6e6a7b69de27e74b52df8d33085625" translate="yes" xml:space="preserve">
          <source>TryFromIntError::borrow_mut</source>
          <target state="translated">TryFromIntError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="8c6ac7bc7b08a0164c28c84e181d07ac7264caa1" translate="yes" xml:space="preserve">
          <source>TryFromIntError::cause</source>
          <target state="translated">TryFromIntError::cause</target>
        </trans-unit>
        <trans-unit id="f0da83cb703ff9ab478400076f17fb3b6df58453" translate="yes" xml:space="preserve">
          <source>TryFromIntError::clone</source>
          <target state="translated">TryFromIntError::clone</target>
        </trans-unit>
        <trans-unit id="21c991dfc7c9f46d0f223e9ada6bbb1b3ddc0419" translate="yes" xml:space="preserve">
          <source>TryFromIntError::clone_from</source>
          <target state="translated">TryFromIntError::clone_from</target>
        </trans-unit>
        <trans-unit id="611f56282230f313fea840ae9d1b4022b318faec" translate="yes" xml:space="preserve">
          <source>TryFromIntError::clone_into</source>
          <target state="translated">TryFromIntError::clone_into</target>
        </trans-unit>
        <trans-unit id="05df18eb5e5e51ad418c603a8c9e45f939b7afa0" translate="yes" xml:space="preserve">
          <source>TryFromIntError::description</source>
          <target state="translated">TryFromIntError::description</target>
        </trans-unit>
        <trans-unit id="cffa72c79f028d8b2b67ac3b5a88fa8e893445f1" translate="yes" xml:space="preserve">
          <source>TryFromIntError::eq</source>
          <target state="translated">TryFromIntError::eq</target>
        </trans-unit>
        <trans-unit id="7ec29ac29b26af4ad4e22c908d20f04e34123009" translate="yes" xml:space="preserve">
          <source>TryFromIntError::fmt</source>
          <target state="translated">TryFromIntError::fmt</target>
        </trans-unit>
        <trans-unit id="27af3cbe1fc043a4ba2263a1ddb04f43ed3341d8" translate="yes" xml:space="preserve">
          <source>TryFromIntError::from</source>
          <target state="translated">TryFromIntError::from</target>
        </trans-unit>
        <trans-unit id="88b0ca4bd6e97295df88042c17da3bc4ad1d1e49" translate="yes" xml:space="preserve">
          <source>TryFromIntError::into</source>
          <target state="translated">TryFromIntError::into</target>
        </trans-unit>
        <trans-unit id="b590493dab8454ef91bc8263edc4d90474ae7585" translate="yes" xml:space="preserve">
          <source>TryFromIntError::ne</source>
          <target state="translated">TryFromIntError::ne</target>
        </trans-unit>
        <trans-unit id="34bc40cbf452f309c77160c0bc046a559d512c4c" translate="yes" xml:space="preserve">
          <source>TryFromIntError::source</source>
          <target state="translated">TryFromIntError::source</target>
        </trans-unit>
        <trans-unit id="4650111711913011245aed1cfd4e401bf80b92bd" translate="yes" xml:space="preserve">
          <source>TryFromIntError::to_owned</source>
          <target state="translated">TryFromIntError::to_owned</target>
        </trans-unit>
        <trans-unit id="145d38c6294ea7b0b18a9beaf5c2ba62d71c6d31" translate="yes" xml:space="preserve">
          <source>TryFromIntError::to_string</source>
          <target state="translated">TryFromIntError::to_string</target>
        </trans-unit>
        <trans-unit id="3bd074fd7b824eb16d5c009603fefee21d967354" translate="yes" xml:space="preserve">
          <source>TryFromIntError::try_from</source>
          <target state="translated">TryFromIntError::try_from</target>
        </trans-unit>
        <trans-unit id="2a66975e8a4a9df97b01eea79b97edba1ce4fc13" translate="yes" xml:space="preserve">
          <source>TryFromIntError::try_into</source>
          <target state="translated">TryFromIntError::try_into</target>
        </trans-unit>
        <trans-unit id="853b95e029b9b10b04426ea41bce22a33cadfde3" translate="yes" xml:space="preserve">
          <source>TryFromIntError::type_id</source>
          <target state="translated">TryFromIntError::type_id</target>
        </trans-unit>
        <trans-unit id="f7ae979f3e3e5c6883cf562acec4a3d8911ff6b7" translate="yes" xml:space="preserve">
          <source>TryFromSliceError</source>
          <target state="translated">TryFromSliceError</target>
        </trans-unit>
        <trans-unit id="08abda7dda4132c13ad2de215a8116ad1c512693" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::borrow</source>
          <target state="translated">TryFromSliceError::borrow</target>
        </trans-unit>
        <trans-unit id="a42a16b656b3e78ad3c1fba788c25cca8562aa04" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::borrow_mut</source>
          <target state="translated">TryFromSliceError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="6b154dc43d23a695abe3c26c810c9600a10bbfc7" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::cause</source>
          <target state="translated">TryFromSliceError::cause</target>
        </trans-unit>
        <trans-unit id="06c3cdee5b115341587a81b7640e380fd15333ea" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::clone</source>
          <target state="translated">TryFromSliceError::clone</target>
        </trans-unit>
        <trans-unit id="a4d48a9b9f7dd5e07e2bb398d2d1029a5b1eb76b" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::clone_from</source>
          <target state="translated">TryFromSliceError::clone_from</target>
        </trans-unit>
        <trans-unit id="faf3d5f757e37a47d1e58275eb48efaa726218ad" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::clone_into</source>
          <target state="translated">TryFromSliceError::clone_into</target>
        </trans-unit>
        <trans-unit id="49619f8bf5df143f7d9e552904f6a84fca8093ea" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::description</source>
          <target state="translated">TryFromSliceError::description</target>
        </trans-unit>
        <trans-unit id="fc484006f6aa38bffa40eb517d8b4b32091a5671" translate="yes" xml:space="preserve">
          <source>TryFromSliceError::fmt</source>
          <target state="translated">TryFromSliceError::fmt</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
