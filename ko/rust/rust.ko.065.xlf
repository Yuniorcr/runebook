<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="acb6b7853c64a87ed86c6559ce0018845dbe735d" translate="yes" xml:space="preserve">
          <source>System::clone_from</source>
          <target state="translated">System::clone_from</target>
        </trans-unit>
        <trans-unit id="9f2214d86a1d870030f3cf722563ad7ca29aca35" translate="yes" xml:space="preserve">
          <source>System::clone_into</source>
          <target state="translated">System::clone_into</target>
        </trans-unit>
        <trans-unit id="fc1063d279e7c46582d7c4bf68cae7e266a26371" translate="yes" xml:space="preserve">
          <source>System::dealloc</source>
          <target state="translated">System::dealloc</target>
        </trans-unit>
        <trans-unit id="bfd2f54111f0bac9ba29a94cac444aa143f60b6d" translate="yes" xml:space="preserve">
          <source>System::dealloc_array</source>
          <target state="translated">System::dealloc_array</target>
        </trans-unit>
        <trans-unit id="74ad656983c908a3ebe0f98c614210f296bd1983" translate="yes" xml:space="preserve">
          <source>System::dealloc_one</source>
          <target state="translated">System::dealloc_one</target>
        </trans-unit>
        <trans-unit id="4fc3847c34aedea5258f4be144ec84ec1c395c81" translate="yes" xml:space="preserve">
          <source>System::default</source>
          <target state="translated">System::default</target>
        </trans-unit>
        <trans-unit id="faa9c7496c12529bc5030d129aa4abc0b1360ddf" translate="yes" xml:space="preserve">
          <source>System::fmt</source>
          <target state="translated">System::fmt</target>
        </trans-unit>
        <trans-unit id="2f9be0649f5627da66556ad4451342e18e6a839f" translate="yes" xml:space="preserve">
          <source>System::from</source>
          <target state="translated">System::from</target>
        </trans-unit>
        <trans-unit id="b1814bf067e1159aa0fbbbc5030c7bc803107618" translate="yes" xml:space="preserve">
          <source>System::grow_in_place</source>
          <target state="translated">System::grow_in_place</target>
        </trans-unit>
        <trans-unit id="67ea11fad484444d367b11f4dedf8659f527a43e" translate="yes" xml:space="preserve">
          <source>System::into</source>
          <target state="translated">System::into</target>
        </trans-unit>
        <trans-unit id="a3e701d278cc112d3cb7bad071e23913c72e29c5" translate="yes" xml:space="preserve">
          <source>System::realloc</source>
          <target state="translated">System::realloc</target>
        </trans-unit>
        <trans-unit id="de720799ebcfbbbc1c0cf105f4790e63b36c02ce" translate="yes" xml:space="preserve">
          <source>System::realloc_array</source>
          <target state="translated">System::realloc_array</target>
        </trans-unit>
        <trans-unit id="6d0361de5a3221f570b6ce17b3529919617bb827" translate="yes" xml:space="preserve">
          <source>System::realloc_excess</source>
          <target state="translated">System::realloc_excess</target>
        </trans-unit>
        <trans-unit id="6b6a830aee020e970b08bde51ae376893f7e4f63" translate="yes" xml:space="preserve">
          <source>System::shrink_in_place</source>
          <target state="translated">System::shrink_in_place</target>
        </trans-unit>
        <trans-unit id="19835154048921e40c04a195f21e2286f35f8332" translate="yes" xml:space="preserve">
          <source>System::to_owned</source>
          <target state="translated">System::to_owned</target>
        </trans-unit>
        <trans-unit id="32589a0ce565ea8bea9adf09415022dfe4622ef8" translate="yes" xml:space="preserve">
          <source>System::try_from</source>
          <target state="translated">System::try_from</target>
        </trans-unit>
        <trans-unit id="40d1da99e82a9fc567be0b189b54a1d346521b5d" translate="yes" xml:space="preserve">
          <source>System::try_into</source>
          <target state="translated">System::try_into</target>
        </trans-unit>
        <trans-unit id="2e5d3c93be7b6c0d01693b2fad7e0d06199fc24e" translate="yes" xml:space="preserve">
          <source>System::type_id</source>
          <target state="translated">System::type_id</target>
        </trans-unit>
        <trans-unit id="0ae4fd3d17652f62ba6d39cc3bc8c7b046ffa89a" translate="yes" xml:space="preserve">
          <source>System::usable_size</source>
          <target state="translated">System::usable_size</target>
        </trans-unit>
        <trans-unit id="cf2a95ca758b8bdeeb2ecf600f0df3a984af4e8f" translate="yes" xml:space="preserve">
          <source>SystemTime</source>
          <target state="translated">SystemTime</target>
        </trans-unit>
        <trans-unit id="6de28e70cd048e60438b7fb2fb2d338c28cc9d28" translate="yes" xml:space="preserve">
          <source>SystemTime::add</source>
          <target state="translated">SystemTime::add</target>
        </trans-unit>
        <trans-unit id="f53054c84083c87dad7a16797134a10dc05ad366" translate="yes" xml:space="preserve">
          <source>SystemTime::add_assign</source>
          <target state="translated">SystemTime::add_assign</target>
        </trans-unit>
        <trans-unit id="8b843630c6cc0a310c609322bf3aeedd203fc456" translate="yes" xml:space="preserve">
          <source>SystemTime::borrow</source>
          <target state="translated">SystemTime::borrow</target>
        </trans-unit>
        <trans-unit id="bcf2dbc4fa00587096c65fd909de305e779e3435" translate="yes" xml:space="preserve">
          <source>SystemTime::borrow_mut</source>
          <target state="translated">SystemTime::borrow_mut</target>
        </trans-unit>
        <trans-unit id="8911750515d5acee11f078578620e9d7b76b4907" translate="yes" xml:space="preserve">
          <source>SystemTime::checked_add</source>
          <target state="translated">SystemTime::checked_add</target>
        </trans-unit>
        <trans-unit id="6a74a25628c082c1f0211d7733d08444207c51c6" translate="yes" xml:space="preserve">
          <source>SystemTime::checked_sub</source>
          <target state="translated">SystemTime::checked_sub</target>
        </trans-unit>
        <trans-unit id="d25f5b3127de07dc72e4f4b5b76eec8c9afa7cd5" translate="yes" xml:space="preserve">
          <source>SystemTime::clamp</source>
          <target state="translated">SystemTime::clamp</target>
        </trans-unit>
        <trans-unit id="85d12e17b2a3e0886623c9a9330551e0e2dda827" translate="yes" xml:space="preserve">
          <source>SystemTime::clone</source>
          <target state="translated">SystemTime::clone</target>
        </trans-unit>
        <trans-unit id="d1812be2207dc89ec7492655f9534f26a47885ca" translate="yes" xml:space="preserve">
          <source>SystemTime::clone_from</source>
          <target state="translated">SystemTime::clone_from</target>
        </trans-unit>
        <trans-unit id="fefad6c61f3507df53f0c4d6729c6131b1ee31a0" translate="yes" xml:space="preserve">
          <source>SystemTime::clone_into</source>
          <target state="translated">SystemTime::clone_into</target>
        </trans-unit>
        <trans-unit id="d0735d903813fce7136f980ed8f9f5f0497d29d4" translate="yes" xml:space="preserve">
          <source>SystemTime::cmp</source>
          <target state="translated">SystemTime::cmp</target>
        </trans-unit>
        <trans-unit id="3ddfb12982d076992356eb84716fef9dac4e0b3f" translate="yes" xml:space="preserve">
          <source>SystemTime::duration_since</source>
          <target state="translated">SystemTime::duration_since</target>
        </trans-unit>
        <trans-unit id="50add06ac79a784bac330ff0b76948992a00ee87" translate="yes" xml:space="preserve">
          <source>SystemTime::elapsed</source>
          <target state="translated">SystemTime::elapsed</target>
        </trans-unit>
        <trans-unit id="de3695b0eb5e89b7df24005edb3f42fac52f9aa1" translate="yes" xml:space="preserve">
          <source>SystemTime::eq</source>
          <target state="translated">SystemTime::eq</target>
        </trans-unit>
        <trans-unit id="3313a47e892c0420901e9c43e13b9d4c90e978a8" translate="yes" xml:space="preserve">
          <source>SystemTime::fmt</source>
          <target state="translated">SystemTime::fmt</target>
        </trans-unit>
        <trans-unit id="d01f5ea82664e6cd13e4de055b6806c7e3492363" translate="yes" xml:space="preserve">
          <source>SystemTime::from</source>
          <target state="translated">SystemTime::from</target>
        </trans-unit>
        <trans-unit id="7a80f500b3f020bcc97e0ea02099d499bde9df33" translate="yes" xml:space="preserve">
          <source>SystemTime::ge</source>
          <target state="translated">SystemTime::ge</target>
        </trans-unit>
        <trans-unit id="cab608574690880943110e23fcdfff81353e2cec" translate="yes" xml:space="preserve">
          <source>SystemTime::gt</source>
          <target state="translated">SystemTime::gt</target>
        </trans-unit>
        <trans-unit id="eda842dc324de7b47a2da98fd6823f243fae85d5" translate="yes" xml:space="preserve">
          <source>SystemTime::hash</source>
          <target state="translated">SystemTime::hash</target>
        </trans-unit>
        <trans-unit id="270720e92dae3778dfad2c21f9b819c6ee14eb88" translate="yes" xml:space="preserve">
          <source>SystemTime::hash_slice</source>
          <target state="translated">SystemTime::hash_slice</target>
        </trans-unit>
        <trans-unit id="add4af9e8c4fcabc19c271d2e26044698ce5233c" translate="yes" xml:space="preserve">
          <source>SystemTime::into</source>
          <target state="translated">SystemTime::into</target>
        </trans-unit>
        <trans-unit id="c79d07b39045bf59844643181fe1a66d2d6a2a3c" translate="yes" xml:space="preserve">
          <source>SystemTime::le</source>
          <target state="translated">SystemTime::le</target>
        </trans-unit>
        <trans-unit id="e906ae906fd4fb8fed270fd61a1d1d891b0b09a5" translate="yes" xml:space="preserve">
          <source>SystemTime::lt</source>
          <target state="translated">SystemTime::lt</target>
        </trans-unit>
        <trans-unit id="c452a38b50fd3735966a65940a5b3e685a3822a7" translate="yes" xml:space="preserve">
          <source>SystemTime::max</source>
          <target state="translated">SystemTime::max</target>
        </trans-unit>
        <trans-unit id="0c8ffa986d1e91e73752403105c705d5b9cacee9" translate="yes" xml:space="preserve">
          <source>SystemTime::min</source>
          <target state="translated">SystemTime::min</target>
        </trans-unit>
        <trans-unit id="bf2e616661da6943d4186c4d8e0ce7bee8eaf123" translate="yes" xml:space="preserve">
          <source>SystemTime::ne</source>
          <target state="translated">SystemTime::ne</target>
        </trans-unit>
        <trans-unit id="e359e33ea2cab4f8cd9992e7068fda592729977b" translate="yes" xml:space="preserve">
          <source>SystemTime::now</source>
          <target state="translated">SystemTime::now</target>
        </trans-unit>
        <trans-unit id="d6d05eb8a7b681a7cbe7919a0b011648dedd4fff" translate="yes" xml:space="preserve">
          <source>SystemTime::partial_cmp</source>
          <target state="translated">SystemTime::partial_cmp</target>
        </trans-unit>
        <trans-unit id="2397159d232aa6e61bc7724148707096e3340707" translate="yes" xml:space="preserve">
          <source>SystemTime::sub</source>
          <target state="translated">SystemTime::sub</target>
        </trans-unit>
        <trans-unit id="0fa2a60f2bb6f2d53567ed62c2ed6f3f550c4259" translate="yes" xml:space="preserve">
          <source>SystemTime::sub_assign</source>
          <target state="translated">SystemTime::sub_assign</target>
        </trans-unit>
        <trans-unit id="4b4c217aaa63a449fd593dd51267f7acffd508ef" translate="yes" xml:space="preserve">
          <source>SystemTime::to_owned</source>
          <target state="translated">SystemTime::to_owned</target>
        </trans-unit>
        <trans-unit id="368655d42c3ebfa01a858407607efad9fe233b09" translate="yes" xml:space="preserve">
          <source>SystemTime::try_from</source>
          <target state="translated">SystemTime::try_from</target>
        </trans-unit>
        <trans-unit id="f5163a5b006f998cc68db71b6f8ed95122bf520b" translate="yes" xml:space="preserve">
          <source>SystemTime::try_into</source>
          <target state="translated">SystemTime::try_into</target>
        </trans-unit>
        <trans-unit id="75245c644ae203caa21b10140a838e8a354386c9" translate="yes" xml:space="preserve">
          <source>SystemTime::type_id</source>
          <target state="translated">SystemTime::type_id</target>
        </trans-unit>
        <trans-unit id="61843a9a7b438088df18e55acbfb813f2cb634cb" translate="yes" xml:space="preserve">
          <source>SystemTimeError</source>
          <target state="translated">SystemTimeError</target>
        </trans-unit>
        <trans-unit id="3c327bfb95e20921e2c45a7df2359d9e78fa0774" translate="yes" xml:space="preserve">
          <source>SystemTimeError::borrow</source>
          <target state="translated">SystemTimeError::borrow</target>
        </trans-unit>
        <trans-unit id="756ba79ba44d291fdc4d72af5ab65a63682b977f" translate="yes" xml:space="preserve">
          <source>SystemTimeError::borrow_mut</source>
          <target state="translated">SystemTimeError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a445192e48cb91b7ddcdc9fe5e6bbb748f5f824e" translate="yes" xml:space="preserve">
          <source>SystemTimeError::cause</source>
          <target state="translated">SystemTimeError::cause</target>
        </trans-unit>
        <trans-unit id="90af7cb006ad2ae95b0532ef83122e10317df3fa" translate="yes" xml:space="preserve">
          <source>SystemTimeError::clone</source>
          <target state="translated">SystemTimeError::clone</target>
        </trans-unit>
        <trans-unit id="62aa2086202093058f48c5a904b065728c5acf76" translate="yes" xml:space="preserve">
          <source>SystemTimeError::clone_from</source>
          <target state="translated">SystemTimeError::clone_from</target>
        </trans-unit>
        <trans-unit id="771c02c2b1582cbdf8239bab48068b44ea9ec4a5" translate="yes" xml:space="preserve">
          <source>SystemTimeError::clone_into</source>
          <target state="translated">SystemTimeError::clone_into</target>
        </trans-unit>
        <trans-unit id="a8d6a1c474bf33cfa63f362d5b1ab619524ba8fc" translate="yes" xml:space="preserve">
          <source>SystemTimeError::description</source>
          <target state="translated">SystemTimeError::description</target>
        </trans-unit>
        <trans-unit id="bfb8c3a3ded511c45ee591217758ae832873d576" translate="yes" xml:space="preserve">
          <source>SystemTimeError::duration</source>
          <target state="translated">SystemTimeError::duration</target>
        </trans-unit>
        <trans-unit id="141093a4af53e65aaae4bcb9a0e2551ee5a21d8e" translate="yes" xml:space="preserve">
          <source>SystemTimeError::fmt</source>
          <target state="translated">SystemTimeError::fmt</target>
        </trans-unit>
        <trans-unit id="064a1b4e4b4c9839707d55ca04bbb064105729ba" translate="yes" xml:space="preserve">
          <source>SystemTimeError::from</source>
          <target state="translated">SystemTimeError::from</target>
        </trans-unit>
        <trans-unit id="92137c5d1227debe366b2e935decfb37de6bca7a" translate="yes" xml:space="preserve">
          <source>SystemTimeError::into</source>
          <target state="translated">SystemTimeError::into</target>
        </trans-unit>
        <trans-unit id="f9fbd0e1ac763bcc77716e27807a2eb29e9ef379" translate="yes" xml:space="preserve">
          <source>SystemTimeError::source</source>
          <target state="translated">SystemTimeError::source</target>
        </trans-unit>
        <trans-unit id="6189ffe8d0f502e8dd110590a68f1b92c042b2a7" translate="yes" xml:space="preserve">
          <source>SystemTimeError::to_owned</source>
          <target state="translated">SystemTimeError::to_owned</target>
        </trans-unit>
        <trans-unit id="99c8707df39c678417307d659d8ec2643cf34c87" translate="yes" xml:space="preserve">
          <source>SystemTimeError::to_string</source>
          <target state="translated">SystemTimeError::to_string</target>
        </trans-unit>
        <trans-unit id="a571ff794b6e5e5a7042e4b35d8887fccecf1def" translate="yes" xml:space="preserve">
          <source>SystemTimeError::try_from</source>
          <target state="translated">SystemTimeError::try_from</target>
        </trans-unit>
        <trans-unit id="b43b4ddef54880135386b20279b4008857ba58fa" translate="yes" xml:space="preserve">
          <source>SystemTimeError::try_into</source>
          <target state="translated">SystemTimeError::try_into</target>
        </trans-unit>
        <trans-unit id="4dfc0af75d7c2e669650e816b66c9b168077cb71" translate="yes" xml:space="preserve">
          <source>SystemTimeError::type_id</source>
          <target state="translated">SystemTimeError::type_id</target>
        </trans-unit>
        <trans-unit id="62982af0908758670580c6edb499fa164bf62391" translate="yes" xml:space="preserve">
          <source>T is not part of the type of any other fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88dab723a8048ac1748c6ac3ed61f66cca384674" translate="yes" xml:space="preserve">
          <source>TCP is the lower-level protocol that describes the details of how information gets from one server to another but doesn&amp;rsquo;t specify what that information is. HTTP builds on top of TCP by defining the contents of the requests and responses. It&amp;rsquo;s technically possible to use HTTP with other protocols, but in the vast majority of cases, HTTP sends its data over TCP. We&amp;rsquo;ll work with the raw bytes of TCP and HTTP requests and responses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0e5af479d5d88b028bc8e426d2bad5fff91dfe1" translate="yes" xml:space="preserve">
          <source>TUPLE_INDEX :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe06eb6459c87f0e497ce1805f076f104bfecf78" translate="yes" xml:space="preserve">
          <source>Tab</source>
          <target state="translated">Tab</target>
        </trans-unit>
        <trans-unit id="97b2dba627c5c69cbbe9e799ce7053600010979c" translate="yes" xml:space="preserve">
          <source>Tab is escaped as &lt;code&gt;\t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="107444e567e76aaf287da86db379437d4bca58d1" translate="yes" xml:space="preserve">
          <source>Table 3-1: Integer Types in Rust</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4841690bbbdfc16291049fbdf02eba44c26f1fe3" translate="yes" xml:space="preserve">
          <source>Table 3-2: Integer Literals in Rust</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c33f4867f17a5b96d7adebb6f5399b966869690d" translate="yes" xml:space="preserve">
          <source>Table B-1 contains the operators in Rust, an example of how the operator would appear in context, a short explanation, and whether that operator is overloadable. If an operator is overloadable, the relevant trait to use to overload that operator is listed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06657d411733886ad4815d321e743fbac25fa35c" translate="yes" xml:space="preserve">
          <source>Table B-10 shows the contexts in which square brackets are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0f55c131cec44e5644b700fd417c85f06fb616d" translate="yes" xml:space="preserve">
          <source>Table B-10: Square Brackets</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b8d696460a4a9fcc0bd9b82117a316b957d6d92" translate="yes" xml:space="preserve">
          <source>Table B-1: Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="187573d7e017058a9ed2e4719fa7cf609635a69f" translate="yes" xml:space="preserve">
          <source>Table B-2 shows symbols that appear on their own and are valid in a variety of locations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bcaa2d7409319767bd64f24bc2f5b698c31c2f6" translate="yes" xml:space="preserve">
          <source>Table B-2: Stand-Alone Syntax</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d22f653aed1ed7601d671714f6ac72dc411879ec" translate="yes" xml:space="preserve">
          <source>Table B-3 shows symbols that appear in the context of a path through the module hierarchy to an item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34ed3a50a31cc3bf2f8772b274e52fb1fba8bb0f" translate="yes" xml:space="preserve">
          <source>Table B-3: Path-Related Syntax</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f98443da31b276f343d03920ba370b5752a0e12" translate="yes" xml:space="preserve">
          <source>Table B-4 shows symbols that appear in the context of using generic type parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a51bd646b6783d008d91206bd058642e25ccb613" translate="yes" xml:space="preserve">
          <source>Table B-4: Generics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7be53f4de27dd3e027a433732b5361994e8acf33" translate="yes" xml:space="preserve">
          <source>Table B-5 shows symbols that appear in the context of constraining generic type parameters with trait bounds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74d088e0d5105a150c11cd8201418a2cdf68ce02" translate="yes" xml:space="preserve">
          <source>Table B-5: Trait Bound Constraints</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95a6989f46d2e1b6666effc627f0dfb8369e7126" translate="yes" xml:space="preserve">
          <source>Table B-6 shows symbols that appear in the context of calling or defining macros and specifying attributes on an item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="081245a408b8db11b7241a9aa12d47acc57ebbb1" translate="yes" xml:space="preserve">
          <source>Table B-6: Macros and Attributes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e0b9a29b00c6ee030b6432a864eb033a65415cb" translate="yes" xml:space="preserve">
          <source>Table B-7 shows symbols that create comments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ad0c419652bff27ff5c043b41e87164cc0fcd90" translate="yes" xml:space="preserve">
          <source>Table B-7: Comments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e5041a9e3d4b92058040d4987d932b95e99c2a0" translate="yes" xml:space="preserve">
          <source>Table B-8 shows symbols that appear in the context of using tuples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85c2ab407771f36e7df3b07094f3794d116c3d8c" translate="yes" xml:space="preserve">
          <source>Table B-8: Tuples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb21f94ac7beb7e92db89eb376b6ab77aa7aee3c" translate="yes" xml:space="preserve">
          <source>Table B-9 shows the contexts in which curly braces are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5280511084907e7b3e0d40b5400f356c93c4f07d" translate="yes" xml:space="preserve">
          <source>Table B-9: Curly Brackets</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68ddd91d0b9671a791224a07e7c4440e749e446a" translate="yes" xml:space="preserve">
          <source>Tagalog</source>
          <target state="translated">Tagalog</target>
        </trans-unit>
        <trans-unit id="56806a1ffdde7ef9980b8850997e6a7523aaf863" translate="yes" xml:space="preserve">
          <source>Take</source>
          <target state="translated">Take</target>
        </trans-unit>
        <trans-unit id="a6dbbbc65cd30f41925d4cc9cbaafbee7d6567d1" translate="yes" xml:space="preserve">
          <source>Take a look at Figure 4-1 to see what is happening to &lt;code&gt;String&lt;/code&gt; under the covers. A &lt;code&gt;String&lt;/code&gt; is made up of three parts, shown on the left: a pointer to the memory that holds the contents of the string, a length, and a capacity. This group of data is stored on the stack. On the right is the memory on the heap that holds the contents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36ec6cfef38f0db91a02b56f380c5dd23fbcdec5" translate="yes" xml:space="preserve">
          <source>Take ownership of the key and value from the map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c8c2173493e131ee8b48a42e8147c3b750d2630" translate="yes" xml:space="preserve">
          <source>Take ownership of the key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da858ac7b477063b0ec9d1c06ffff8c75387904" translate="yes" xml:space="preserve">
          <source>Take the ownership of the key and value from the map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91d6dcfa01041153b7bffd73aa778c1ee9bded5c" translate="yes" xml:space="preserve">
          <source>Take, for example, &amp;ldquo;systems-level&amp;rdquo; work that deals with low-level details of memory management, data representation, and concurrency. Traditionally, this realm of programming is seen as arcane, accessible only to a select few who have devoted the necessary years learning to avoid its infamous pitfalls. And even those who practice it do so with caution, lest their code be open to exploits, crashes, or corruption.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f99659fc4357133905ac14735172ddd9f26ff12" translate="yes" xml:space="preserve">
          <source>Take::all</source>
          <target state="translated">Take::all</target>
        </trans-unit>
        <trans-unit id="fa84b4e334e8ffb11b0185b5d5b2059bbc588e04" translate="yes" xml:space="preserve">
          <source>Take::any</source>
          <target state="translated">Take::any</target>
        </trans-unit>
        <trans-unit id="644344a1bc287157a7afa8cd3d4802d748031cd9" translate="yes" xml:space="preserve">
          <source>Take::borrow</source>
          <target state="translated">Take::borrow</target>
        </trans-unit>
        <trans-unit id="df6979cefffdd2f4d3bbcfb1e822adc7a9293218" translate="yes" xml:space="preserve">
          <source>Take::borrow_mut</source>
          <target state="translated">Take::borrow_mut</target>
        </trans-unit>
        <trans-unit id="16ba68b0f6fff291bfa7e11d1289142f85246928" translate="yes" xml:space="preserve">
          <source>Take::by_ref</source>
          <target state="translated">Take::by_ref</target>
        </trans-unit>
        <trans-unit id="d66ca6caaca1439674289fd4eb15dc4bbef0041f" translate="yes" xml:space="preserve">
          <source>Take::bytes</source>
          <target state="translated">Take::bytes</target>
        </trans-unit>
        <trans-unit id="e098d2332710277d6884726c0b37aebcf6d05b6f" translate="yes" xml:space="preserve">
          <source>Take::chain</source>
          <target state="translated">Take::chain</target>
        </trans-unit>
        <trans-unit id="037f5b7d00803bd3613a8ff1175f4342224e6fce" translate="yes" xml:space="preserve">
          <source>Take::clone</source>
          <target state="translated">Take::clone</target>
        </trans-unit>
        <trans-unit id="8b7cdd4a2155c68828e3a6a4fd4c4d0e1bd38505" translate="yes" xml:space="preserve">
          <source>Take::clone_from</source>
          <target state="translated">Take::clone_from</target>
        </trans-unit>
        <trans-unit id="ef8c5a2dcf3ef6f62ca826010931a6cbb6acf63d" translate="yes" xml:space="preserve">
          <source>Take::clone_into</source>
          <target state="translated">Take::clone_into</target>
        </trans-unit>
        <trans-unit id="db1521c9f2ad232d30267c01d79b04b67738fe0a" translate="yes" xml:space="preserve">
          <source>Take::cloned</source>
          <target state="translated">Take::cloned</target>
        </trans-unit>
        <trans-unit id="0fbfdfb2676db7d0821ba964fab927f35118b020" translate="yes" xml:space="preserve">
          <source>Take::cmp</source>
          <target state="translated">Take::cmp</target>
        </trans-unit>
        <trans-unit id="28e3db5d351b7f10d2f5207128813ee23866b741" translate="yes" xml:space="preserve">
          <source>Take::collect</source>
          <target state="translated">Take::collect</target>
        </trans-unit>
        <trans-unit id="f9f7d91e6f8aebe8e972bb3877708579e50f8c53" translate="yes" xml:space="preserve">
          <source>Take::consume</source>
          <target state="translated">Take::consume</target>
        </trans-unit>
        <trans-unit id="d7d20739d10574a082d2d8dc9de0eeb531a7d6ea" translate="yes" xml:space="preserve">
          <source>Take::copied</source>
          <target state="translated">Take::copied</target>
        </trans-unit>
        <trans-unit id="41d79118de7924a2b1057bc724f6ab41ede2825d" translate="yes" xml:space="preserve">
          <source>Take::count</source>
          <target state="translated">Take::count</target>
        </trans-unit>
        <trans-unit id="fb8d89cf93235cb2f0ede4a3db0b188ba7471c01" translate="yes" xml:space="preserve">
          <source>Take::cycle</source>
          <target state="translated">Take::cycle</target>
        </trans-unit>
        <trans-unit id="f26504381e65bb5a0e296dc05009f75523a60b01" translate="yes" xml:space="preserve">
          <source>Take::enumerate</source>
          <target state="translated">Take::enumerate</target>
        </trans-unit>
        <trans-unit id="71758c4c9e5d6f9859af3d5deed53f3dffa8a29d" translate="yes" xml:space="preserve">
          <source>Take::eq</source>
          <target state="translated">Take::eq</target>
        </trans-unit>
        <trans-unit id="7c0673ce2b72d7f8075b3efeb2ef59721311ecd0" translate="yes" xml:space="preserve">
          <source>Take::fill_buf</source>
          <target state="translated">Take::fill_buf</target>
        </trans-unit>
        <trans-unit id="5a30e1ea16981cd11992bb422804463117bbe42b" translate="yes" xml:space="preserve">
          <source>Take::filter</source>
          <target state="translated">Take::filter</target>
        </trans-unit>
        <trans-unit id="56daf2a72739de2ab4afd0e7b888708d0e3be8d7" translate="yes" xml:space="preserve">
          <source>Take::filter_map</source>
          <target state="translated">Take::filter_map</target>
        </trans-unit>
        <trans-unit id="83bf9a26031e83bfd0ea4ad4c350aaabe753bc29" translate="yes" xml:space="preserve">
          <source>Take::find</source>
          <target state="translated">Take::find</target>
        </trans-unit>
        <trans-unit id="ee9337dc81980858c879c7427fc9ca8e985271cc" translate="yes" xml:space="preserve">
          <source>Take::find_map</source>
          <target state="translated">Take::find_map</target>
        </trans-unit>
        <trans-unit id="8f74d147cac58616dad76838f3006b54215628e5" translate="yes" xml:space="preserve">
          <source>Take::flat_map</source>
          <target state="translated">Take::flat_map</target>
        </trans-unit>
        <trans-unit id="a2c15a7a9022588f7d053abc05f4895da17e39cb" translate="yes" xml:space="preserve">
          <source>Take::flatten</source>
          <target state="translated">Take::flatten</target>
        </trans-unit>
        <trans-unit id="37752c3cd660a6c9fad3428f62425fb10e186654" translate="yes" xml:space="preserve">
          <source>Take::fmt</source>
          <target state="translated">Take::fmt</target>
        </trans-unit>
        <trans-unit id="8e6e0eb2c7ed378e0c0b67d5078ead14f6404c20" translate="yes" xml:space="preserve">
          <source>Take::fold</source>
          <target state="translated">Take::fold</target>
        </trans-unit>
        <trans-unit id="d69c2e1032d9ca8cdfdc032308452e43f66f1ab3" translate="yes" xml:space="preserve">
          <source>Take::for_each</source>
          <target state="translated">Take::for_each</target>
        </trans-unit>
        <trans-unit id="d062f90c8152829b635db5dfaf4a1c017b8fec1b" translate="yes" xml:space="preserve">
          <source>Take::from</source>
          <target state="translated">Take::from</target>
        </trans-unit>
        <trans-unit id="57d36e3553ba4f35423108a0c6d1dc12d3c118e8" translate="yes" xml:space="preserve">
          <source>Take::fuse</source>
          <target state="translated">Take::fuse</target>
        </trans-unit>
        <trans-unit id="14ce017aacc567616dcd221124371d517961806b" translate="yes" xml:space="preserve">
          <source>Take::ge</source>
          <target state="translated">Take::ge</target>
        </trans-unit>
        <trans-unit id="94602f9c049e55b20749048774a8ad063b1faacd" translate="yes" xml:space="preserve">
          <source>Take::get_mut</source>
          <target state="translated">Take::get_mut</target>
        </trans-unit>
        <trans-unit id="b0126421c3a15b8b1bc3fef86ac31fe40ea52cb1" translate="yes" xml:space="preserve">
          <source>Take::get_ref</source>
          <target state="translated">Take::get_ref</target>
        </trans-unit>
        <trans-unit id="350cb4e285cbb6b93ed77fcc25ffae4734065900" translate="yes" xml:space="preserve">
          <source>Take::gt</source>
          <target state="translated">Take::gt</target>
        </trans-unit>
        <trans-unit id="4fef59a0580d6449755183decfb5bdc6c6fd1a87" translate="yes" xml:space="preserve">
          <source>Take::initializer</source>
          <target state="translated">Take::initializer</target>
        </trans-unit>
        <trans-unit id="a17dc185152481cfa6d254124bbaca68590e36d6" translate="yes" xml:space="preserve">
          <source>Take::inspect</source>
          <target state="translated">Take::inspect</target>
        </trans-unit>
        <trans-unit id="b551aa5bf180dc9a42a570626bbad41ce58cbf4c" translate="yes" xml:space="preserve">
          <source>Take::into</source>
          <target state="translated">Take::into</target>
        </trans-unit>
        <trans-unit id="9c81e25d9cb4a6ea231d1730fef036851d62da4a" translate="yes" xml:space="preserve">
          <source>Take::into_inner</source>
          <target state="translated">Take::into_inner</target>
        </trans-unit>
        <trans-unit id="690d8211e27b2209f6443c61ba9f5d6b82f0ab0a" translate="yes" xml:space="preserve">
          <source>Take::into_iter</source>
          <target state="translated">Take::into_iter</target>
        </trans-unit>
        <trans-unit id="c3db51a2d5c6cf3a50237a92eeebd34087efbf9c" translate="yes" xml:space="preserve">
          <source>Take::is_empty</source>
          <target state="translated">Take::is_empty</target>
        </trans-unit>
        <trans-unit id="d5aa3b35319c3cfabee5112598ae4d95bd4760b8" translate="yes" xml:space="preserve">
          <source>Take::is_sorted</source>
          <target state="translated">Take::is_sorted</target>
        </trans-unit>
        <trans-unit id="c7a7a901a7f4b96f52a0ee09502f9fa86f52dd57" translate="yes" xml:space="preserve">
          <source>Take::is_sorted_by</source>
          <target state="translated">Take::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="d3b453542d922907484f0f0c04a0606e267e6675" translate="yes" xml:space="preserve">
          <source>Take::is_sorted_by_key</source>
          <target state="translated">Take::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="7a17b7815f75cfb59aeb5f6a46161e13fbfefa9f" translate="yes" xml:space="preserve">
          <source>Take::last</source>
          <target state="translated">Take::last</target>
        </trans-unit>
        <trans-unit id="a62fdfcb0b86b54a24ed75e1fcc56ea1febc28f3" translate="yes" xml:space="preserve">
          <source>Take::le</source>
          <target state="translated">Take::le</target>
        </trans-unit>
        <trans-unit id="c52c9e5c349d73ff44b03fe16ae20ce603c072bd" translate="yes" xml:space="preserve">
          <source>Take::len</source>
          <target state="translated">Take::len</target>
        </trans-unit>
        <trans-unit id="fc419e9744486960e9425d394adc0b9dcf90dca1" translate="yes" xml:space="preserve">
          <source>Take::limit</source>
          <target state="translated">Take::limit</target>
        </trans-unit>
        <trans-unit id="4b9fe90f6bdde3dc4f4c3a5813a4fc0481be0eda" translate="yes" xml:space="preserve">
          <source>Take::lines</source>
          <target state="translated">Take::lines</target>
        </trans-unit>
        <trans-unit id="914ef0291f7ced6860f526294681ef88bf528863" translate="yes" xml:space="preserve">
          <source>Take::lt</source>
          <target state="translated">Take::lt</target>
        </trans-unit>
        <trans-unit id="0ea12f56c3ca6b07e354de2ec3b9e270ee5e6d7a" translate="yes" xml:space="preserve">
          <source>Take::map</source>
          <target state="translated">Take::map</target>
        </trans-unit>
        <trans-unit id="289e06809e773f2407814cea93a4164a31b49e69" translate="yes" xml:space="preserve">
          <source>Take::max</source>
          <target state="translated">Take::max</target>
        </trans-unit>
        <trans-unit id="e70e720dfe58c7174ec8fb8d75433ae57bdeb88c" translate="yes" xml:space="preserve">
          <source>Take::max_by</source>
          <target state="translated">Take::max_by</target>
        </trans-unit>
        <trans-unit id="efceb7b8269a34401e398dbf818a37a7f5800afd" translate="yes" xml:space="preserve">
          <source>Take::max_by_key</source>
          <target state="translated">Take::max_by_key</target>
        </trans-unit>
        <trans-unit id="8cad337e79b36c57e83bdc9838a2cfd220fbbace" translate="yes" xml:space="preserve">
          <source>Take::min</source>
          <target state="translated">Take::min</target>
        </trans-unit>
        <trans-unit id="dcb496cce4ae794019de1ea001cf9e9be343b53a" translate="yes" xml:space="preserve">
          <source>Take::min_by</source>
          <target state="translated">Take::min_by</target>
        </trans-unit>
        <trans-unit id="ad7db3a0faaf142da3d12f9011d00fb703802c71" translate="yes" xml:space="preserve">
          <source>Take::min_by_key</source>
          <target state="translated">Take::min_by_key</target>
        </trans-unit>
        <trans-unit id="66ccdd13544d7c0426b8f5fad3c110a5cc85429d" translate="yes" xml:space="preserve">
          <source>Take::ne</source>
          <target state="translated">Take::ne</target>
        </trans-unit>
        <trans-unit id="5c311a3cbde242d60a470e5589b0a29485562e36" translate="yes" xml:space="preserve">
          <source>Take::next</source>
          <target state="translated">Take::next</target>
        </trans-unit>
        <trans-unit id="3362a9d47dbf6991be694a111b5fca7503b30eaf" translate="yes" xml:space="preserve">
          <source>Take::nth</source>
          <target state="translated">Take::nth</target>
        </trans-unit>
        <trans-unit id="ab21ae8f0fc4ae208887a6fdd7b3943ef10aaaf8" translate="yes" xml:space="preserve">
          <source>Take::partial_cmp</source>
          <target state="translated">Take::partial_cmp</target>
        </trans-unit>
        <trans-unit id="dcf4022c567f080c26833b94beefa427d3f92455" translate="yes" xml:space="preserve">
          <source>Take::partition</source>
          <target state="translated">Take::partition</target>
        </trans-unit>
        <trans-unit id="026dc2483c1a09268da4198b6ba9cc8ee678bd06" translate="yes" xml:space="preserve">
          <source>Take::peekable</source>
          <target state="translated">Take::peekable</target>
        </trans-unit>
        <trans-unit id="6964940d4ec09f8784e088cb3dc7a85e1f65676f" translate="yes" xml:space="preserve">
          <source>Take::position</source>
          <target state="translated">Take::position</target>
        </trans-unit>
        <trans-unit id="29e46e62c421c9f70ffb9b2d45050d1c695cd69f" translate="yes" xml:space="preserve">
          <source>Take::product</source>
          <target state="translated">Take::product</target>
        </trans-unit>
        <trans-unit id="b7159b9057e0d08a530082588bafac49c81b16bf" translate="yes" xml:space="preserve">
          <source>Take::read</source>
          <target state="translated">Take::read</target>
        </trans-unit>
        <trans-unit id="951c68a2ad2c7b6c8c47567bc558ad1eb9671a15" translate="yes" xml:space="preserve">
          <source>Take::read_exact</source>
          <target state="translated">Take::read_exact</target>
        </trans-unit>
        <trans-unit id="b79c4273727b2109fedb574f82ffa048030cb006" translate="yes" xml:space="preserve">
          <source>Take::read_line</source>
          <target state="translated">Take::read_line</target>
        </trans-unit>
        <trans-unit id="ead68e8fb88620a865b0b80676ca602341977ee4" translate="yes" xml:space="preserve">
          <source>Take::read_to_end</source>
          <target state="translated">Take::read_to_end</target>
        </trans-unit>
        <trans-unit id="8ad0fb8860aee4596cb4d19117f9339b3e96719c" translate="yes" xml:space="preserve">
          <source>Take::read_to_string</source>
          <target state="translated">Take::read_to_string</target>
        </trans-unit>
        <trans-unit id="ff7920e868c6efa0c1c63b311588c20d61a7f2d1" translate="yes" xml:space="preserve">
          <source>Take::read_until</source>
          <target state="translated">Take::read_until</target>
        </trans-unit>
        <trans-unit id="1c02379757cc2a474d5159acc562ebc53dbcc6e8" translate="yes" xml:space="preserve">
          <source>Take::read_vectored</source>
          <target state="translated">Take::read_vectored</target>
        </trans-unit>
        <trans-unit id="5be381a9d13a427bb958e06b2f91d8ac597dcaca" translate="yes" xml:space="preserve">
          <source>Take::rev</source>
          <target state="translated">Take::rev</target>
        </trans-unit>
        <trans-unit id="e18f2e0078c87ddca019d0df50c9be909eec7c73" translate="yes" xml:space="preserve">
          <source>Take::rposition</source>
          <target state="translated">Take::rposition</target>
        </trans-unit>
        <trans-unit id="a4ae23e28ee6482c4f37bfaf8961b5d3e6eaf38a" translate="yes" xml:space="preserve">
          <source>Take::scan</source>
          <target state="translated">Take::scan</target>
        </trans-unit>
        <trans-unit id="a861f4075d807611dc6e73d40237e1213bacd0eb" translate="yes" xml:space="preserve">
          <source>Take::set_limit</source>
          <target state="translated">Take::set_limit</target>
        </trans-unit>
        <trans-unit id="f818ff36e7ad711103d2ba4c077a8d734edde56f" translate="yes" xml:space="preserve">
          <source>Take::size_hint</source>
          <target state="translated">Take::size_hint</target>
        </trans-unit>
        <trans-unit id="a69293c506a3e6d03748938ad98a57cab2de68b6" translate="yes" xml:space="preserve">
          <source>Take::skip</source>
          <target state="translated">Take::skip</target>
        </trans-unit>
        <trans-unit id="24442e01a50200993c27435ef3f59852a0195fbc" translate="yes" xml:space="preserve">
          <source>Take::skip_while</source>
          <target state="translated">Take::skip_while</target>
        </trans-unit>
        <trans-unit id="786dff3f5c97ff2517eb703cddc2c48b45ce68d2" translate="yes" xml:space="preserve">
          <source>Take::split</source>
          <target state="translated">Take::split</target>
        </trans-unit>
        <trans-unit id="d02c36ab44977423b720fae9b8128bd7c9a17130" translate="yes" xml:space="preserve">
          <source>Take::step_by</source>
          <target state="translated">Take::step_by</target>
        </trans-unit>
        <trans-unit id="6cba5fe4e4d8782236905d48f50c0c8cf0b35ea1" translate="yes" xml:space="preserve">
          <source>Take::sum</source>
          <target state="translated">Take::sum</target>
        </trans-unit>
        <trans-unit id="68624d3ea1461494615761875eaee084707013a8" translate="yes" xml:space="preserve">
          <source>Take::take</source>
          <target state="translated">Take::take</target>
        </trans-unit>
        <trans-unit id="4d763cfe13619d7589c43fa8771dc666435ceb25" translate="yes" xml:space="preserve">
          <source>Take::take_while</source>
          <target state="translated">Take::take_while</target>
        </trans-unit>
        <trans-unit id="85075c5e0bed76afcc06d4d606cca841b62fafda" translate="yes" xml:space="preserve">
          <source>Take::to_owned</source>
          <target state="translated">Take::to_owned</target>
        </trans-unit>
        <trans-unit id="22b958c31c6c8794a04f72cf2eea76ceb4261bea" translate="yes" xml:space="preserve">
          <source>Take::try_fold</source>
          <target state="translated">Take::try_fold</target>
        </trans-unit>
        <trans-unit id="85671f0c2f90b03f64ac901cd58b292819f1adbc" translate="yes" xml:space="preserve">
          <source>Take::try_for_each</source>
          <target state="translated">Take::try_for_each</target>
        </trans-unit>
        <trans-unit id="3d0cc67e823487286711ff60f4a8af5c169b439c" translate="yes" xml:space="preserve">
          <source>Take::try_from</source>
          <target state="translated">Take::try_from</target>
        </trans-unit>
        <trans-unit id="0af1ec1e453882ae4eac152d32b6efc53464c4f6" translate="yes" xml:space="preserve">
          <source>Take::try_into</source>
          <target state="translated">Take::try_into</target>
        </trans-unit>
        <trans-unit id="030493ab8d39a3d39b2efaf8bc970f0ab4c107f4" translate="yes" xml:space="preserve">
          <source>Take::type_id</source>
          <target state="translated">Take::type_id</target>
        </trans-unit>
        <trans-unit id="835853dd1bc504d3a63584777f07d0b4864b121b" translate="yes" xml:space="preserve">
          <source>Take::unzip</source>
          <target state="translated">Take::unzip</target>
        </trans-unit>
        <trans-unit id="79bb484f90441904a0b701d7c5bb877e2e57a7f3" translate="yes" xml:space="preserve">
          <source>Take::zip</source>
          <target state="translated">Take::zip</target>
        </trans-unit>
        <trans-unit id="3a51f26ad628e90629aea4f7cb0d24e3af6895e3" translate="yes" xml:space="preserve">
          <source>TakeWhile</source>
          <target state="translated">TakeWhile</target>
        </trans-unit>
        <trans-unit id="5a4ee79ed44129d250af7f398ee902fbe44562d2" translate="yes" xml:space="preserve">
          <source>TakeWhile::all</source>
          <target state="translated">TakeWhile::all</target>
        </trans-unit>
        <trans-unit id="7e504c2bb32700532ccb00ad21b4a4f96ba4b32d" translate="yes" xml:space="preserve">
          <source>TakeWhile::any</source>
          <target state="translated">TakeWhile::any</target>
        </trans-unit>
        <trans-unit id="61e920f04bf2913ea28c4be57374db5b67bc882b" translate="yes" xml:space="preserve">
          <source>TakeWhile::borrow</source>
          <target state="translated">TakeWhile::borrow</target>
        </trans-unit>
        <trans-unit id="6889e05cc39c39dbd344c208d8ddf999af12f733" translate="yes" xml:space="preserve">
          <source>TakeWhile::borrow_mut</source>
          <target state="translated">TakeWhile::borrow_mut</target>
        </trans-unit>
        <trans-unit id="109fef7db94ab58206b2e6230cdfecdbc77a4097" translate="yes" xml:space="preserve">
          <source>TakeWhile::by_ref</source>
          <target state="translated">TakeWhile::by_ref</target>
        </trans-unit>
        <trans-unit id="a01c4cf198db99a56662a21b9ebe5a4c46c182e7" translate="yes" xml:space="preserve">
          <source>TakeWhile::chain</source>
          <target state="translated">TakeWhile::chain</target>
        </trans-unit>
        <trans-unit id="d76cb77b5bc08817a97e53dbe6ef2ae7b860ac16" translate="yes" xml:space="preserve">
          <source>TakeWhile::clone</source>
          <target state="translated">TakeWhile::clone</target>
        </trans-unit>
        <trans-unit id="1c3173ef6044b5c8977046cd5f0bf86ead851ada" translate="yes" xml:space="preserve">
          <source>TakeWhile::clone_from</source>
          <target state="translated">TakeWhile::clone_from</target>
        </trans-unit>
        <trans-unit id="40bcff411c1ac10064ef6c9a30082c6e1301cb18" translate="yes" xml:space="preserve">
          <source>TakeWhile::clone_into</source>
          <target state="translated">TakeWhile::clone_into</target>
        </trans-unit>
        <trans-unit id="e71eeceaa483aa4ac6954a174b4acff80b41e0bb" translate="yes" xml:space="preserve">
          <source>TakeWhile::cloned</source>
          <target state="translated">TakeWhile::cloned</target>
        </trans-unit>
        <trans-unit id="af006151b53d47e3e77126b4cb02c5ef2128101f" translate="yes" xml:space="preserve">
          <source>TakeWhile::cmp</source>
          <target state="translated">TakeWhile::cmp</target>
        </trans-unit>
        <trans-unit id="449927b87ae5776ce947f2b26362f6c5d21d8b41" translate="yes" xml:space="preserve">
          <source>TakeWhile::collect</source>
          <target state="translated">TakeWhile::collect</target>
        </trans-unit>
        <trans-unit id="6bb099291f07df9c2f7dbd50ff586598af6af625" translate="yes" xml:space="preserve">
          <source>TakeWhile::copied</source>
          <target state="translated">TakeWhile::copied</target>
        </trans-unit>
        <trans-unit id="81d7f945ac8fcd4d12fe33e652717c1fde6563b2" translate="yes" xml:space="preserve">
          <source>TakeWhile::count</source>
          <target state="translated">TakeWhile::count</target>
        </trans-unit>
        <trans-unit id="0943dffe36757c6679e098fc93d6c8597c886c1b" translate="yes" xml:space="preserve">
          <source>TakeWhile::cycle</source>
          <target state="translated">TakeWhile::cycle</target>
        </trans-unit>
        <trans-unit id="981c89ae8a1b88a1d6ef722f5febb04e9305d379" translate="yes" xml:space="preserve">
          <source>TakeWhile::enumerate</source>
          <target state="translated">TakeWhile::enumerate</target>
        </trans-unit>
        <trans-unit id="051ad73b3f1c122d17eba268840da57f91d9155b" translate="yes" xml:space="preserve">
          <source>TakeWhile::eq</source>
          <target state="translated">TakeWhile::eq</target>
        </trans-unit>
        <trans-unit id="cf7aa97e22c869c2aa178c4b74e98d507f377949" translate="yes" xml:space="preserve">
          <source>TakeWhile::filter</source>
          <target state="translated">TakeWhile::filter</target>
        </trans-unit>
        <trans-unit id="781d39f35a596d0d04db63ba8f23ab5a28e7f786" translate="yes" xml:space="preserve">
          <source>TakeWhile::filter_map</source>
          <target state="translated">TakeWhile::filter_map</target>
        </trans-unit>
        <trans-unit id="bb46578db058cb4085702b41a8ac2a3bd8e0e0e6" translate="yes" xml:space="preserve">
          <source>TakeWhile::find</source>
          <target state="translated">TakeWhile::find</target>
        </trans-unit>
        <trans-unit id="1836ae4e27d1d0a7611ca1a7a8e730e4b2ff7ba5" translate="yes" xml:space="preserve">
          <source>TakeWhile::find_map</source>
          <target state="translated">TakeWhile::find_map</target>
        </trans-unit>
        <trans-unit id="d6c2713acc857d51506ab063d1197dac1b94d74f" translate="yes" xml:space="preserve">
          <source>TakeWhile::flat_map</source>
          <target state="translated">TakeWhile::flat_map</target>
        </trans-unit>
        <trans-unit id="8fa786f386ff376f9d586e7e2603367b24f4309e" translate="yes" xml:space="preserve">
          <source>TakeWhile::flatten</source>
          <target state="translated">TakeWhile::flatten</target>
        </trans-unit>
        <trans-unit id="54dbb49e3694ba24da0862dc1394d925c2ec2e76" translate="yes" xml:space="preserve">
          <source>TakeWhile::fmt</source>
          <target state="translated">TakeWhile::fmt</target>
        </trans-unit>
        <trans-unit id="3b604659899acaa4c4fa880c65eaf60bdf338fb0" translate="yes" xml:space="preserve">
          <source>TakeWhile::fold</source>
          <target state="translated">TakeWhile::fold</target>
        </trans-unit>
        <trans-unit id="f857cfc8e4fffae22b25aa1af0746a8c07453739" translate="yes" xml:space="preserve">
          <source>TakeWhile::for_each</source>
          <target state="translated">TakeWhile::for_each</target>
        </trans-unit>
        <trans-unit id="10cc7ec12849fb8be521212b71c97f69b0e8be4d" translate="yes" xml:space="preserve">
          <source>TakeWhile::from</source>
          <target state="translated">TakeWhile::from</target>
        </trans-unit>
        <trans-unit id="b14ce3c49c60281107d8ff85cf5a45151d78c02b" translate="yes" xml:space="preserve">
          <source>TakeWhile::fuse</source>
          <target state="translated">TakeWhile::fuse</target>
        </trans-unit>
        <trans-unit id="5b533b69ce5d1b5fcca2290183f6ab3ff6f3bbe7" translate="yes" xml:space="preserve">
          <source>TakeWhile::ge</source>
          <target state="translated">TakeWhile::ge</target>
        </trans-unit>
        <trans-unit id="e41efbbd4b16c01a2406465143571ff38ddcc729" translate="yes" xml:space="preserve">
          <source>TakeWhile::gt</source>
          <target state="translated">TakeWhile::gt</target>
        </trans-unit>
        <trans-unit id="e82ad72130971476625180d15f9095a631008482" translate="yes" xml:space="preserve">
          <source>TakeWhile::inspect</source>
          <target state="translated">TakeWhile::inspect</target>
        </trans-unit>
        <trans-unit id="5bd8c51c1aaafd737286d930bac9c87c81fd2da0" translate="yes" xml:space="preserve">
          <source>TakeWhile::into</source>
          <target state="translated">TakeWhile::into</target>
        </trans-unit>
        <trans-unit id="9c41377ecc43d8e8e2038b8c95e46e6dc6672f6a" translate="yes" xml:space="preserve">
          <source>TakeWhile::into_iter</source>
          <target state="translated">TakeWhile::into_iter</target>
        </trans-unit>
        <trans-unit id="af8584c071284d9a15ed6e55178e48dac000af50" translate="yes" xml:space="preserve">
          <source>TakeWhile::is_sorted</source>
          <target state="translated">TakeWhile::is_sorted</target>
        </trans-unit>
        <trans-unit id="f9d98bc06d7cfd35aa276ac03a4bfb4fb9bcfdb9" translate="yes" xml:space="preserve">
          <source>TakeWhile::is_sorted_by</source>
          <target state="translated">TakeWhile::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="fdf72e0e188e7dabd3daf8f3e7aea8af3f66d06c" translate="yes" xml:space="preserve">
          <source>TakeWhile::is_sorted_by_key</source>
          <target state="translated">TakeWhile::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="e34b73af766b9c594c897565557e9397f6c161eb" translate="yes" xml:space="preserve">
          <source>TakeWhile::last</source>
          <target state="translated">TakeWhile::last</target>
        </trans-unit>
        <trans-unit id="b6dd1bba8f0ed8bafd55a7d850ca2eb0b195f34d" translate="yes" xml:space="preserve">
          <source>TakeWhile::le</source>
          <target state="translated">TakeWhile::le</target>
        </trans-unit>
        <trans-unit id="da5a93a2f06ebcd1f9f118d719a7e667df14e6d9" translate="yes" xml:space="preserve">
          <source>TakeWhile::lt</source>
          <target state="translated">TakeWhile::lt</target>
        </trans-unit>
        <trans-unit id="edb1877164deea21c7f4f55f4488b34d338728b1" translate="yes" xml:space="preserve">
          <source>TakeWhile::map</source>
          <target state="translated">TakeWhile::map</target>
        </trans-unit>
        <trans-unit id="6630ff71f282b1c99f5e6466ff97baa34cb4b2a6" translate="yes" xml:space="preserve">
          <source>TakeWhile::max</source>
          <target state="translated">TakeWhile::max</target>
        </trans-unit>
        <trans-unit id="fbc594d608402509f7e6a7fee20d755f4627aefe" translate="yes" xml:space="preserve">
          <source>TakeWhile::max_by</source>
          <target state="translated">TakeWhile::max_by</target>
        </trans-unit>
        <trans-unit id="a9cee1d9e0d49985b497cda56371f3884fe1400a" translate="yes" xml:space="preserve">
          <source>TakeWhile::max_by_key</source>
          <target state="translated">TakeWhile::max_by_key</target>
        </trans-unit>
        <trans-unit id="41c6ffd60ed5abd0718b176912c5901fdabb4c03" translate="yes" xml:space="preserve">
          <source>TakeWhile::min</source>
          <target state="translated">TakeWhile::min</target>
        </trans-unit>
        <trans-unit id="5ed99857707d76b683d55914ca131503d1ae98d5" translate="yes" xml:space="preserve">
          <source>TakeWhile::min_by</source>
          <target state="translated">TakeWhile::min_by</target>
        </trans-unit>
        <trans-unit id="70d6053ccb8872d131b60b10e6b3cfb7aa2feb7a" translate="yes" xml:space="preserve">
          <source>TakeWhile::min_by_key</source>
          <target state="translated">TakeWhile::min_by_key</target>
        </trans-unit>
        <trans-unit id="68db9e21593ec104a29ab24c04ba6067a7ba188c" translate="yes" xml:space="preserve">
          <source>TakeWhile::ne</source>
          <target state="translated">TakeWhile::ne</target>
        </trans-unit>
        <trans-unit id="dba525b0a0f3de0fbfdde5b19b4061145544bbf6" translate="yes" xml:space="preserve">
          <source>TakeWhile::next</source>
          <target state="translated">TakeWhile::next</target>
        </trans-unit>
        <trans-unit id="abe6f9c891ddb24679b3b68d9ffc6564f2011102" translate="yes" xml:space="preserve">
          <source>TakeWhile::nth</source>
          <target state="translated">TakeWhile::nth</target>
        </trans-unit>
        <trans-unit id="800e827a6bd80027fcc168148b39b2bc4798dafa" translate="yes" xml:space="preserve">
          <source>TakeWhile::partial_cmp</source>
          <target state="translated">TakeWhile::partial_cmp</target>
        </trans-unit>
        <trans-unit id="756f2fd59afc727df9fab561f13734ed10cc1035" translate="yes" xml:space="preserve">
          <source>TakeWhile::partition</source>
          <target state="translated">TakeWhile::partition</target>
        </trans-unit>
        <trans-unit id="b3708fa6ef243ab03b8f0e01148054537baba7c2" translate="yes" xml:space="preserve">
          <source>TakeWhile::peekable</source>
          <target state="translated">TakeWhile::peekable</target>
        </trans-unit>
        <trans-unit id="3ddf00384fd53b19d286b7ce9f31e5c8e130add2" translate="yes" xml:space="preserve">
          <source>TakeWhile::position</source>
          <target state="translated">TakeWhile::position</target>
        </trans-unit>
        <trans-unit id="103103944a1d96c94fd7efea8dc3417e1dcec47e" translate="yes" xml:space="preserve">
          <source>TakeWhile::product</source>
          <target state="translated">TakeWhile::product</target>
        </trans-unit>
        <trans-unit id="9db7de0140db3938f59bf212e7c6b8c4ab1a5b22" translate="yes" xml:space="preserve">
          <source>TakeWhile::rev</source>
          <target state="translated">TakeWhile::rev</target>
        </trans-unit>
        <trans-unit id="aa7afa9cbae96b3a55ad383eb829e62995e9d3b0" translate="yes" xml:space="preserve">
          <source>TakeWhile::rposition</source>
          <target state="translated">TakeWhile::rposition</target>
        </trans-unit>
        <trans-unit id="aad375a583a0085240c857eb42a8dfb87e2e4e1c" translate="yes" xml:space="preserve">
          <source>TakeWhile::scan</source>
          <target state="translated">TakeWhile::scan</target>
        </trans-unit>
        <trans-unit id="cd86cfe53884486177c23f0ff823be46500dc9e1" translate="yes" xml:space="preserve">
          <source>TakeWhile::size_hint</source>
          <target state="translated">TakeWhile::size_hint</target>
        </trans-unit>
        <trans-unit id="5e176c9b3bf37b02aef10f7907a61a6ac9a47da8" translate="yes" xml:space="preserve">
          <source>TakeWhile::skip</source>
          <target state="translated">TakeWhile::skip</target>
        </trans-unit>
        <trans-unit id="64e54491abe005b30c8d866999d58ab787b271b2" translate="yes" xml:space="preserve">
          <source>TakeWhile::skip_while</source>
          <target state="translated">TakeWhile::skip_while</target>
        </trans-unit>
        <trans-unit id="ba9f9f10db1b73ab0c564edb9c28453e72ee8d7c" translate="yes" xml:space="preserve">
          <source>TakeWhile::step_by</source>
          <target state="translated">TakeWhile::step_by</target>
        </trans-unit>
        <trans-unit id="9d9273a97581b55606d39ff31ae4fc4bd97d0343" translate="yes" xml:space="preserve">
          <source>TakeWhile::sum</source>
          <target state="translated">TakeWhile::sum</target>
        </trans-unit>
        <trans-unit id="c679b6dec55380d66c68043added100d9b1e3e12" translate="yes" xml:space="preserve">
          <source>TakeWhile::take</source>
          <target state="translated">TakeWhile::take</target>
        </trans-unit>
        <trans-unit id="98bc022ab936f48f4c132862157a433b58b1ed1d" translate="yes" xml:space="preserve">
          <source>TakeWhile::take_while</source>
          <target state="translated">TakeWhile::take_while</target>
        </trans-unit>
        <trans-unit id="b57cfb71237e7ec5ab624251b87030d240a46226" translate="yes" xml:space="preserve">
          <source>TakeWhile::to_owned</source>
          <target state="translated">TakeWhile::to_owned</target>
        </trans-unit>
        <trans-unit id="37e399f48eff7903115e7d86661abdf8e05fd4b1" translate="yes" xml:space="preserve">
          <source>TakeWhile::try_fold</source>
          <target state="translated">TakeWhile::try_fold</target>
        </trans-unit>
        <trans-unit id="759bc51854e6a28a5380a5f6b7a415cd0f555f0f" translate="yes" xml:space="preserve">
          <source>TakeWhile::try_for_each</source>
          <target state="translated">TakeWhile::try_for_each</target>
        </trans-unit>
        <trans-unit id="7fb911b85cc860ff38f3b721f59503e01735b148" translate="yes" xml:space="preserve">
          <source>TakeWhile::try_from</source>
          <target state="translated">TakeWhile::try_from</target>
        </trans-unit>
        <trans-unit id="5de7c55a9b68a872ef23f0276b88d1c9ecf0fc8a" translate="yes" xml:space="preserve">
          <source>TakeWhile::try_into</source>
          <target state="translated">TakeWhile::try_into</target>
        </trans-unit>
        <trans-unit id="87c136784211d463521272370803a4f358f45d54" translate="yes" xml:space="preserve">
          <source>TakeWhile::type_id</source>
          <target state="translated">TakeWhile::type_id</target>
        </trans-unit>
        <trans-unit id="2c32f5c719493f4a777e4c32b66c95f758c27273" translate="yes" xml:space="preserve">
          <source>TakeWhile::unzip</source>
          <target state="translated">TakeWhile::unzip</target>
        </trans-unit>
        <trans-unit id="d4376e438d96018f64f5876aa47fe4d14ae53315" translate="yes" xml:space="preserve">
          <source>TakeWhile::zip</source>
          <target state="translated">TakeWhile::zip</target>
        </trans-unit>
        <trans-unit id="c4a3fbbd6670f1404e88f845d8e70bb6e1310ad2" translate="yes" xml:space="preserve">
          <source>Takes &lt;code&gt;O(min(k, len() - k))&lt;/code&gt; time and no extra space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2675fff809feea07b6b8e81b85ffeea6cb2ff42a" translate="yes" xml:space="preserve">
          <source>Takes &lt;code&gt;O(min(mid, len() - mid))&lt;/code&gt; time and no extra space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd9e4e1ce47cfbb22bdd9618d61401a9a4bbe1ab" translate="yes" xml:space="preserve">
          <source>Takes a closure and creates an iterator which calls that closure on each element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d3b7aa7666b1bb97d700268dbfed96edd954290" translate="yes" xml:space="preserve">
          <source>Takes a closure and creates an iterator which calls that closure on each element. &lt;a href=&quot;../../../iter/trait.iterator#method.map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15197bb083d7273e4a694b7c5e032b5e1c0781f3" translate="yes" xml:space="preserve">
          <source>Takes a closure and creates an iterator which calls that closure on each element. &lt;a href=&quot;../../iter/trait.iterator#method.map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4434c8dd599ef23b0c9ba44e32c1fa55b943ae82" translate="yes" xml:space="preserve">
          <source>Takes a closure and creates an iterator which calls that closure on each element. &lt;a href=&quot;../iter/trait.iterator#method.map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6257eea37e0de73bcadd8777f056a323db82c336" translate="yes" xml:space="preserve">
          <source>Takes a closure and creates an iterator which calls that closure on each element. &lt;a href=&quot;iter/trait.iterator#method.map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1ad1d9466847f0b48f38483a158304137e697a6" translate="yes" xml:space="preserve">
          <source>Takes a closure and creates an iterator which calls that closure on each element. &lt;a href=&quot;trait.iterator#method.map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b67dad0714b16a4867cfc86c2882827f4a196a85" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is &lt;a href=&quot;enum.option#None.v&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;enum.option#None.v&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;enum.option#None.v&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; occur, a container with the values of each &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e929c2f84b980189b0ca395f9fd1ebf18d6a9b2" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;: if it is &lt;a href=&quot;../option/enum.option#None.v&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, no further elements are taken, and the &lt;a href=&quot;../option/enum.option#None.v&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned. Should no &lt;a href=&quot;../option/enum.option#None.v&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; occur, a container with the values of each &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="217627f67f88406b5f9f17a93f1493e04a1a8227" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;code&gt;Iterator&lt;/code&gt;: if it is a &lt;code&gt;None&lt;/code&gt;, no further elements are taken, and the &lt;code&gt;None&lt;/code&gt; is returned. Should no &lt;code&gt;None&lt;/code&gt; occur, the product of all elements is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4aa0fd801953cd40a086ec1d2ff51bb44eb736e" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;code&gt;Iterator&lt;/code&gt;: if it is a &lt;code&gt;None&lt;/code&gt;, no further elements are taken, and the &lt;code&gt;None&lt;/code&gt; is returned. Should no &lt;code&gt;None&lt;/code&gt; occur, the sum of all elements is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1fb0a7041f8cb3602712be575a96b71a9c34edb" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;code&gt;Iterator&lt;/code&gt;: if it is an &lt;code&gt;Err&lt;/code&gt;, no further elements are taken, and the &lt;code&gt;Err&lt;/code&gt; is returned. Should no &lt;code&gt;Err&lt;/code&gt; occur, a container with the values of each &lt;code&gt;Result&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42c26fa2ecac3de7729494a9359458db2460cecc" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;code&gt;Iterator&lt;/code&gt;: if it is an &lt;code&gt;Err&lt;/code&gt;, no further elements are taken, and the &lt;code&gt;Err&lt;/code&gt; is returned. Should no &lt;code&gt;Err&lt;/code&gt; occur, the product of all elements is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c82330496098a00243d3f411105f0f70776be883" translate="yes" xml:space="preserve">
          <source>Takes each element in the &lt;code&gt;Iterator&lt;/code&gt;: if it is an &lt;code&gt;Err&lt;/code&gt;, no further elements are taken, and the &lt;code&gt;Err&lt;/code&gt; is returned. Should no &lt;code&gt;Err&lt;/code&gt; occur, the sum of all elements is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d5fda76710ca0641abcbb3e4cbb1bb6e17f736" translate="yes" xml:space="preserve">
          <source>Takes each element, adds them together, and returns the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6776e27751852b377b68c46a8017d15dd715c595" translate="yes" xml:space="preserve">
          <source>Takes linear (in &lt;code&gt;self.len()&lt;/code&gt;) time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdca1895a18c3a298f6533b4c2e334951c66b62c" translate="yes" xml:space="preserve">
          <source>Takes ownership and &quot;forgets&quot; about the value &lt;strong&gt;without running its destructor&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8fa769819072fbe610e5e9c85934d3a05171939" translate="yes" xml:space="preserve">
          <source>Takes the contained value out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aec823974aa072f464dcb5cc764f9240e0f60dd" translate="yes" xml:space="preserve">
          <source>Takes the cubic root of a number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f045194d706e7e41fabb862c8032ea26f5f950f2" translate="yes" xml:space="preserve">
          <source>Takes the reciprocal (inverse) of a number, &lt;code&gt;1/x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a48b57259f94b360feec04d91e3f646f9cba125" translate="yes" xml:space="preserve">
          <source>Takes the square root of a number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc799efc0b882851473c22ca2ca5ccf94ddabfe1" translate="yes" xml:space="preserve">
          <source>Takes the value of the cell, leaving &lt;code&gt;Default::default()&lt;/code&gt; in its place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21859ca86840d9216ef1aca0008b5877f29f5e68" translate="yes" xml:space="preserve">
          <source>Takes the value of the entry out of the map, and returns it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e353877ad2ec8473ab467885d9861796b98bdada" translate="yes" xml:space="preserve">
          <source>Takes the value out of the entry, and returns it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="761daab64ee172552a57dae50c6f8a92c4d9c366" translate="yes" xml:space="preserve">
          <source>Takes the value out of the option, leaving a &lt;a href=&quot;#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; in its place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f95b9cdf9802bc6e9feca2c7b307fe24034be8d" translate="yes" xml:space="preserve">
          <source>Takes two iterators and creates a new iterator over both in sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="787908ffef98464dc332707d755e2c4f129a3015" translate="yes" xml:space="preserve">
          <source>Takes two iterators and creates a new iterator over both in sequence. &lt;a href=&quot;../../../iter/trait.iterator#method.chain&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96c4c94db35b0a5de2fc876c74307d69f4d1f941" translate="yes" xml:space="preserve">
          <source>Takes two iterators and creates a new iterator over both in sequence. &lt;a href=&quot;../../iter/trait.iterator#method.chain&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09c1398fa07d7872f8f96945eceb77ea195aaf9f" translate="yes" xml:space="preserve">
          <source>Takes two iterators and creates a new iterator over both in sequence. &lt;a href=&quot;../iter/trait.iterator#method.chain&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e8033a8a0d88d9c00564885e5bd3facaba3011b" translate="yes" xml:space="preserve">
          <source>Takes two iterators and creates a new iterator over both in sequence. &lt;a href=&quot;iter/trait.iterator#method.chain&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="772b77fdfc8e9968126bb233f7891ef8441c5352" translate="yes" xml:space="preserve">
          <source>Takes two iterators and creates a new iterator over both in sequence. &lt;a href=&quot;trait.iterator#method.chain&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e48610b94d0c8b865914c76042a0dd63c8ace3fb" translate="yes" xml:space="preserve">
          <source>Taking a &lt;a href=&quot;trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; as a parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f62d9e379567856d558f8df128e53e7eeda59a9" translate="yes" xml:space="preserve">
          <source>Taking a &lt;a href=&quot;trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt; as a parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acf17a2c9691dbabd08f8be26e62792363680f2f" translate="yes" xml:space="preserve">
          <source>Taking a &lt;a href=&quot;trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt; as a parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b593af3c7f2108f31456b5ab2cb3574e71f3b6e" translate="yes" xml:space="preserve">
          <source>Taking ownership and then returning ownership with every function is a bit tedious. What if we want to let a function use a value but not take ownership? It&amp;rsquo;s quite annoying that anything we pass in also needs to be passed back if we want to use it again, in addition to any data resulting from the body of the function that we might want to return as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aa5a6c5b61f9a1ca73ba483f7a4a44ead615a2c" translate="yes" xml:space="preserve">
          <source>Targets which do not support switching between linkage of the C runtime will ignore this flag. It's recommended to inspect the resulting binary to ensure that it's linked as you would expect after the compiler succeeds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ad8024a2c7b1265fb5e22250fc7a31283cdbd36" translate="yes" xml:space="preserve">
          <source>TcpListener</source>
          <target state="translated">TcpListener</target>
        </trans-unit>
        <trans-unit id="ece7cdbc23c076f1d64f752343ef7aec8eec539f" translate="yes" xml:space="preserve">
          <source>TcpListener::accept</source>
          <target state="translated">TcpListener::accept</target>
        </trans-unit>
        <trans-unit id="a2a291bb7ab19718d31f7478d18104e4158a939c" translate="yes" xml:space="preserve">
          <source>TcpListener::as_raw_fd</source>
          <target state="translated">TcpListener::as_raw_fd</target>
        </trans-unit>
        <trans-unit id="49f5fe2427c190a7f8a472e06e6d569a7ff427c4" translate="yes" xml:space="preserve">
          <source>TcpListener::as_raw_socket</source>
          <target state="translated">TcpListener::as_raw_socket</target>
        </trans-unit>
        <trans-unit id="2e2338f796fa51dd367f2f2c91e316fe98afe3a0" translate="yes" xml:space="preserve">
          <source>TcpListener::bind</source>
          <target state="translated">TcpListener::bind</target>
        </trans-unit>
        <trans-unit id="bc75d22ad0ef01f38f6f564c0448b514f01f2b1e" translate="yes" xml:space="preserve">
          <source>TcpListener::borrow</source>
          <target state="translated">TcpListener::borrow</target>
        </trans-unit>
        <trans-unit id="b7bf89d05dc43863ce7b237f1c9339841b44d828" translate="yes" xml:space="preserve">
          <source>TcpListener::borrow_mut</source>
          <target state="translated">TcpListener::borrow_mut</target>
        </trans-unit>
        <trans-unit id="67148bab8cc6c3ad3159fa098deca2df5084c5bc" translate="yes" xml:space="preserve">
          <source>TcpListener::fmt</source>
          <target state="translated">TcpListener::fmt</target>
        </trans-unit>
        <trans-unit id="e2222d5e97ec906a2d58760a4b094c72e792239f" translate="yes" xml:space="preserve">
          <source>TcpListener::from</source>
          <target state="translated">TcpListener::from</target>
        </trans-unit>
        <trans-unit id="965dc7a632243e984a2b9e894788c6c21d7eb5d8" translate="yes" xml:space="preserve">
          <source>TcpListener::from_raw_fd</source>
          <target state="translated">TcpListener::from_raw_fd</target>
        </trans-unit>
        <trans-unit id="482dc849c70cec776e4f8a473271ccf0cb6cf277" translate="yes" xml:space="preserve">
          <source>TcpListener::from_raw_socket</source>
          <target state="translated">TcpListener::from_raw_socket</target>
        </trans-unit>
        <trans-unit id="1934b5e7d2fb2d8224b23b4ad0d2399a5cb3b873" translate="yes" xml:space="preserve">
          <source>TcpListener::incoming</source>
          <target state="translated">TcpListener::incoming</target>
        </trans-unit>
        <trans-unit id="428c642a4eaf5906beb8fe4edf0ac026bb70054c" translate="yes" xml:space="preserve">
          <source>TcpListener::into</source>
          <target state="translated">TcpListener::into</target>
        </trans-unit>
        <trans-unit id="ecf165a93c2c3a51f657446508db4792cbb31eef" translate="yes" xml:space="preserve">
          <source>TcpListener::into_raw_fd</source>
          <target state="translated">TcpListener::into_raw_fd</target>
        </trans-unit>
        <trans-unit id="171dba66a0881e83fbf754117718cae198277962" translate="yes" xml:space="preserve">
          <source>TcpListener::into_raw_socket</source>
          <target state="translated">TcpListener::into_raw_socket</target>
        </trans-unit>
        <trans-unit id="2275a3d2aa672ca4311b697b11d81ca54319cd4f" translate="yes" xml:space="preserve">
          <source>TcpListener::local_addr</source>
          <target state="translated">TcpListener::local_addr</target>
        </trans-unit>
        <trans-unit id="ec11714ec8bf6a942994646bb7ec40f6ec987004" translate="yes" xml:space="preserve">
          <source>TcpListener::only_v6</source>
          <target state="translated">TcpListener::only_v6</target>
        </trans-unit>
        <trans-unit id="8f9762884937dfa70d1e7429478f09a0cb47d310" translate="yes" xml:space="preserve">
          <source>TcpListener::set_nonblocking</source>
          <target state="translated">TcpListener::set_nonblocking</target>
        </trans-unit>
        <trans-unit id="226f648e250e40bcc471fd5a673bff010846e472" translate="yes" xml:space="preserve">
          <source>TcpListener::set_only_v6</source>
          <target state="translated">TcpListener::set_only_v6</target>
        </trans-unit>
        <trans-unit id="4715bf3aa73135001a12ace3fe29f1f7e2fa4701" translate="yes" xml:space="preserve">
          <source>TcpListener::set_ttl</source>
          <target state="translated">TcpListener::set_ttl</target>
        </trans-unit>
        <trans-unit id="52dd134154d36dce171d232dad1f997d4a86ef76" translate="yes" xml:space="preserve">
          <source>TcpListener::take_error</source>
          <target state="translated">TcpListener::take_error</target>
        </trans-unit>
        <trans-unit id="346a3319242ccfb5f2d382bc3687dc41f26c3692" translate="yes" xml:space="preserve">
          <source>TcpListener::try_clone</source>
          <target state="translated">TcpListener::try_clone</target>
        </trans-unit>
        <trans-unit id="8774def23dc815607fb5f6d621a655e6351d76ed" translate="yes" xml:space="preserve">
          <source>TcpListener::try_from</source>
          <target state="translated">TcpListener::try_from</target>
        </trans-unit>
        <trans-unit id="4d964782d52d7cadd1d535988a4c17142f01c956" translate="yes" xml:space="preserve">
          <source>TcpListener::try_into</source>
          <target state="translated">TcpListener::try_into</target>
        </trans-unit>
        <trans-unit id="720c95f141c0826fd5fca57448ce533672b87275" translate="yes" xml:space="preserve">
          <source>TcpListener::ttl</source>
          <target state="translated">TcpListener::ttl</target>
        </trans-unit>
        <trans-unit id="8b5ab82dcc35d3a2cd49204d3a4a7a3449b42f85" translate="yes" xml:space="preserve">
          <source>TcpListener::type_id</source>
          <target state="translated">TcpListener::type_id</target>
        </trans-unit>
        <trans-unit id="35342d32149945519f7e31daff4e30855fbeba49" translate="yes" xml:space="preserve">
          <source>TcpStream</source>
          <target state="translated">TcpStream</target>
        </trans-unit>
        <trans-unit id="9eafc6b129d5efa5c4b0a83e50a95e30344816f3" translate="yes" xml:space="preserve">
          <source>TcpStream::as_raw_fd</source>
          <target state="translated">TcpStream::as_raw_fd</target>
        </trans-unit>
        <trans-unit id="09ec2aef24015b31ab23113ac683d2f8346c1f39" translate="yes" xml:space="preserve">
          <source>TcpStream::as_raw_socket</source>
          <target state="translated">TcpStream::as_raw_socket</target>
        </trans-unit>
        <trans-unit id="12e762e3cfe2aa9d71a2a757abb3507e964d1881" translate="yes" xml:space="preserve">
          <source>TcpStream::borrow</source>
          <target state="translated">TcpStream::borrow</target>
        </trans-unit>
        <trans-unit id="d91a58f6ef21ac04bf7fb8b19bbc87b6dbe9fb4c" translate="yes" xml:space="preserve">
          <source>TcpStream::borrow_mut</source>
          <target state="translated">TcpStream::borrow_mut</target>
        </trans-unit>
        <trans-unit id="11f8dcda0e1ccab974f38cf496de4e39b14b25cb" translate="yes" xml:space="preserve">
          <source>TcpStream::by_ref</source>
          <target state="translated">TcpStream::by_ref</target>
        </trans-unit>
        <trans-unit id="bfbef109c2e4f33f2aedd0c714f14f49404d152c" translate="yes" xml:space="preserve">
          <source>TcpStream::bytes</source>
          <target state="translated">TcpStream::bytes</target>
        </trans-unit>
        <trans-unit id="e1fe899d60189a16135ede51a667e0fdef40fd00" translate="yes" xml:space="preserve">
          <source>TcpStream::chain</source>
          <target state="translated">TcpStream::chain</target>
        </trans-unit>
        <trans-unit id="9b075e5500b6c35efe89a7d4bf0762c653e6221c" translate="yes" xml:space="preserve">
          <source>TcpStream::connect</source>
          <target state="translated">TcpStream::connect</target>
        </trans-unit>
        <trans-unit id="7c9bc4cc7e00f6a9f012c5c2f74296bd08fb3cd9" translate="yes" xml:space="preserve">
          <source>TcpStream::connect_timeout</source>
          <target state="translated">TcpStream::connect_timeout</target>
        </trans-unit>
        <trans-unit id="7e82ba30a964300fd5401b21bdde38ef8892a264" translate="yes" xml:space="preserve">
          <source>TcpStream::flush</source>
          <target state="translated">TcpStream::flush</target>
        </trans-unit>
        <trans-unit id="5e2f83b6ef3a2fd9f5722070fe250aef910cb0f5" translate="yes" xml:space="preserve">
          <source>TcpStream::fmt</source>
          <target state="translated">TcpStream::fmt</target>
        </trans-unit>
        <trans-unit id="3a3304a1471ecd9e54075022592709e4164425d3" translate="yes" xml:space="preserve">
          <source>TcpStream::from</source>
          <target state="translated">TcpStream::from</target>
        </trans-unit>
        <trans-unit id="0c544151d800149c130a2b4e5fa0242d2c6c5fe2" translate="yes" xml:space="preserve">
          <source>TcpStream::from_raw_fd</source>
          <target state="translated">TcpStream::from_raw_fd</target>
        </trans-unit>
        <trans-unit id="f33ab52a5f61c4e532d24e2b9d448a864ab588ef" translate="yes" xml:space="preserve">
          <source>TcpStream::from_raw_socket</source>
          <target state="translated">TcpStream::from_raw_socket</target>
        </trans-unit>
        <trans-unit id="ac8cf31a8273795291384f9b9a189065f0e4ddda" translate="yes" xml:space="preserve">
          <source>TcpStream::initializer</source>
          <target state="translated">TcpStream::initializer</target>
        </trans-unit>
        <trans-unit id="bb02adb8fb5756c502d5d11c517f31b37848f5b3" translate="yes" xml:space="preserve">
          <source>TcpStream::into</source>
          <target state="translated">TcpStream::into</target>
        </trans-unit>
        <trans-unit id="8b62d5f9b1506a6417ce6b1e7abc2fe81f1a512b" translate="yes" xml:space="preserve">
          <source>TcpStream::into_raw_fd</source>
          <target state="translated">TcpStream::into_raw_fd</target>
        </trans-unit>
        <trans-unit id="2d62e49030fac395488f03a44bc65385d791c4a1" translate="yes" xml:space="preserve">
          <source>TcpStream::into_raw_socket</source>
          <target state="translated">TcpStream::into_raw_socket</target>
        </trans-unit>
        <trans-unit id="2f15c295f6cbee27e4704ba77400c3f9cdb74347" translate="yes" xml:space="preserve">
          <source>TcpStream::local_addr</source>
          <target state="translated">TcpStream::local_addr</target>
        </trans-unit>
        <trans-unit id="3e41769cd3c7bc5fe0ffd071decfac8538fce3c8" translate="yes" xml:space="preserve">
          <source>TcpStream::nodelay</source>
          <target state="translated">TcpStream::nodelay</target>
        </trans-unit>
        <trans-unit id="b1c4ef3a856c377290ba0effe22fa456b4c5d618" translate="yes" xml:space="preserve">
          <source>TcpStream::peek</source>
          <target state="translated">TcpStream::peek</target>
        </trans-unit>
        <trans-unit id="02b5be94fe4bd3a77f45294ce309a022defb0142" translate="yes" xml:space="preserve">
          <source>TcpStream::peer_addr</source>
          <target state="translated">TcpStream::peer_addr</target>
        </trans-unit>
        <trans-unit id="168308bcf15754b94b3cd0ff91dc84d727c89085" translate="yes" xml:space="preserve">
          <source>TcpStream::read</source>
          <target state="translated">TcpStream::read</target>
        </trans-unit>
        <trans-unit id="a51f803ec2bc3d6b94f3630947f31e7b2bee3ed5" translate="yes" xml:space="preserve">
          <source>TcpStream::read_exact</source>
          <target state="translated">TcpStream::read_exact</target>
        </trans-unit>
        <trans-unit id="cddced3b85b2ead651c93e97a2f622b9f49035db" translate="yes" xml:space="preserve">
          <source>TcpStream::read_timeout</source>
          <target state="translated">TcpStream::read_timeout</target>
        </trans-unit>
        <trans-unit id="1957796c8b2bd9a577cc9018f30d0a2d1c2fe241" translate="yes" xml:space="preserve">
          <source>TcpStream::read_to_end</source>
          <target state="translated">TcpStream::read_to_end</target>
        </trans-unit>
        <trans-unit id="9f494c5d56be921420520740cf0cbafa75a20b7b" translate="yes" xml:space="preserve">
          <source>TcpStream::read_to_string</source>
          <target state="translated">TcpStream::read_to_string</target>
        </trans-unit>
        <trans-unit id="c6fa288859680339e04670a33f1a14f57af1e652" translate="yes" xml:space="preserve">
          <source>TcpStream::read_vectored</source>
          <target state="translated">TcpStream::read_vectored</target>
        </trans-unit>
        <trans-unit id="e83138e7f219d526516674b5550a795c09cf97fa" translate="yes" xml:space="preserve">
          <source>TcpStream::set_nodelay</source>
          <target state="translated">TcpStream::set_nodelay</target>
        </trans-unit>
        <trans-unit id="6f3db10df76b321eadb9c9c65b440fd1e62d4157" translate="yes" xml:space="preserve">
          <source>TcpStream::set_nonblocking</source>
          <target state="translated">TcpStream::set_nonblocking</target>
        </trans-unit>
        <trans-unit id="0ef1754192987fd2a71c4d09d1363328c40af9e8" translate="yes" xml:space="preserve">
          <source>TcpStream::set_read_timeout</source>
          <target state="translated">TcpStream::set_read_timeout</target>
        </trans-unit>
        <trans-unit id="1c0d37734b35b5aaae88202ef8744780ebadf163" translate="yes" xml:space="preserve">
          <source>TcpStream::set_ttl</source>
          <target state="translated">TcpStream::set_ttl</target>
        </trans-unit>
        <trans-unit id="cf06a99e15825f5af0170343a971d82291a1bb70" translate="yes" xml:space="preserve">
          <source>TcpStream::set_write_timeout</source>
          <target state="translated">TcpStream::set_write_timeout</target>
        </trans-unit>
        <trans-unit id="de9f03e4aaf65b0dacf8a1a510098378140fbad7" translate="yes" xml:space="preserve">
          <source>TcpStream::shutdown</source>
          <target state="translated">TcpStream::shutdown</target>
        </trans-unit>
        <trans-unit id="f729ec43f0af2f4768020c3c186531540aa6fe75" translate="yes" xml:space="preserve">
          <source>TcpStream::take</source>
          <target state="translated">TcpStream::take</target>
        </trans-unit>
        <trans-unit id="07ca37092d4865ff34b3da8842e6f13eb4a33726" translate="yes" xml:space="preserve">
          <source>TcpStream::take_error</source>
          <target state="translated">TcpStream::take_error</target>
        </trans-unit>
        <trans-unit id="3f33672645be4d6e5bd0541f33a42009a106b1ad" translate="yes" xml:space="preserve">
          <source>TcpStream::try_clone</source>
          <target state="translated">TcpStream::try_clone</target>
        </trans-unit>
        <trans-unit id="0e120d19ada990068a0b20ff52db32daba2c74d5" translate="yes" xml:space="preserve">
          <source>TcpStream::try_from</source>
          <target state="translated">TcpStream::try_from</target>
        </trans-unit>
        <trans-unit id="0b039d724a73bfa4d009fb758a03fb779a56b987" translate="yes" xml:space="preserve">
          <source>TcpStream::try_into</source>
          <target state="translated">TcpStream::try_into</target>
        </trans-unit>
        <trans-unit id="833adb6a3443ef8c2bc774bcc30192c98f27094a" translate="yes" xml:space="preserve">
          <source>TcpStream::ttl</source>
          <target state="translated">TcpStream::ttl</target>
        </trans-unit>
        <trans-unit id="ad00f68ee2a21774a182c99f9b2a83cd6f6f89e9" translate="yes" xml:space="preserve">
          <source>TcpStream::type_id</source>
          <target state="translated">TcpStream::type_id</target>
        </trans-unit>
        <trans-unit id="accd5bacb0184a5ab554a0ca248574c5b5ddbbcb" translate="yes" xml:space="preserve">
          <source>TcpStream::write</source>
          <target state="translated">TcpStream::write</target>
        </trans-unit>
        <trans-unit id="0058eeee13c9051b5e0a752af3087b29d7b02d7b" translate="yes" xml:space="preserve">
          <source>TcpStream::write_all</source>
          <target state="translated">TcpStream::write_all</target>
        </trans-unit>
        <trans-unit id="cb06fd9c7d1d55fc4b3f3e15dc0163521ac1465b" translate="yes" xml:space="preserve">
          <source>TcpStream::write_fmt</source>
          <target state="translated">TcpStream::write_fmt</target>
        </trans-unit>
        <trans-unit id="a5e3f17e3264af59b558a0fdcba770ba3c28fa37" translate="yes" xml:space="preserve">
          <source>TcpStream::write_timeout</source>
          <target state="translated">TcpStream::write_timeout</target>
        </trans-unit>
        <trans-unit id="6e74581726f107bfc541797c5b9030282bc56e97" translate="yes" xml:space="preserve">
          <source>TcpStream::write_vectored</source>
          <target state="translated">TcpStream::write_vectored</target>
        </trans-unit>
        <trans-unit id="b6eac90e1928ad9ea4411f97ebcf59a5c7e10ed0" translate="yes" xml:space="preserve">
          <source>Teams of Developers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="260e040b381f220359095e13ffb45be2fbc63287" translate="yes" xml:space="preserve">
          <source>Tells LLVM that this point in the code is not reachable, enabling further optimizations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a946abf59c33631dd9c09fe026f5fda52ecefd51" translate="yes" xml:space="preserve">
          <source>Tells this buffer that &lt;code&gt;amt&lt;/code&gt; bytes have been consumed from the buffer, so they should no longer be returned in calls to &lt;code&gt;read&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="092a16374b222f88ad28cf25d43d7648234ed176" translate="yes" xml:space="preserve">
          <source>Tells this buffer that &lt;code&gt;amt&lt;/code&gt; bytes have been consumed from the buffer, so they should no longer be returned in calls to &lt;code&gt;read&lt;/code&gt;. &lt;a href=&quot;../io/trait.bufread#tymethod.consume&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="027be37242a148e84d0572e0cc986124d9c751bc" translate="yes" xml:space="preserve">
          <source>Tells this buffer that &lt;code&gt;amt&lt;/code&gt; bytes have been consumed from the buffer, so they should no longer be returned in calls to &lt;code&gt;read&lt;/code&gt;. &lt;a href=&quot;io/trait.bufread#tymethod.consume&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea3b911565206879ae5d6cb4146bc834dfb6a7f3" translate="yes" xml:space="preserve">
          <source>Tells this buffer that &lt;code&gt;amt&lt;/code&gt; bytes have been consumed from the buffer, so they should no longer be returned in calls to &lt;code&gt;read&lt;/code&gt;. &lt;a href=&quot;trait.bufread#tymethod.consume&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68f4c5ea285ef679416734518ea1144f7f9f2cf1" translate="yes" xml:space="preserve">
          <source>Temporal quantification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6121a6beed14a5f45c5406020e211d50eaf732ff" translate="yes" xml:space="preserve">
          <source>Temporaries are not always dropped at the end of the enclosing statement. In simple cases where the &lt;code&gt;&amp;amp;&lt;/code&gt; expression is immediately stored into a variable, the compiler will automatically extend the lifetime of the temporary until the end of the enclosing block. Therefore, an alternative way to fix the original program is to write &lt;code&gt;let tmp = &amp;amp;foo()&lt;/code&gt; and not &lt;code&gt;let tmp = foo()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a237179150c9f45b00df9097591b1d7f10ef2038" translate="yes" xml:space="preserve">
          <source>Temporary lifetimes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfc9ea018278b216d5b6d6db9b73a7c2a6e7a8c8" translate="yes" xml:space="preserve">
          <source>Terminates the current process with the specified exit code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4abcdd83ee3f3bce743cbed96b2ad9f965bea36e" translate="yes" xml:space="preserve">
          <source>Terminates the process in an abnormal fashion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ee85218866a19e0d9f6c52c176e4eaf9d0877b2" translate="yes" xml:space="preserve">
          <source>Termination</source>
          <target state="translated">Termination</target>
        </trans-unit>
        <trans-unit id="4d00170cd71cecfb46cdbb7ebdf05a4a02fee721" translate="yes" xml:space="preserve">
          <source>Termination::report</source>
          <target state="translated">Termination::report</target>
        </trans-unit>
        <trans-unit id="00f441aa04210533cf8168c3d0baeda960edac55" translate="yes" xml:space="preserve">
          <source>Terminator for various items and statements, &lt;a href=&quot;types/array&quot;&gt;Array types&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94aaabf5a007f6525e86dbe783c284fccc74a25c" translate="yes" xml:space="preserve">
          <source>Test Organization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="da7894cbcc38e877e01ccb02e3c5e98f656c5624" translate="yes" xml:space="preserve">
          <source>Testing Equality with the &lt;code id=&quot;testing-equality-with-the-assert_eq-and-assert_ne-macros&quot;&gt;assert_eq!&lt;/code&gt; and &lt;code&gt;assert_ne!&lt;/code&gt; Macros</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="117ea1d14f7b6fbe5fa90955d52644403f513522" translate="yes" xml:space="preserve">
          <source>Testing Private Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="932c5d1d0f6f5178e61a3f6e97a669a7ad5fc25b" translate="yes" xml:space="preserve">
          <source>Testing attributes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6966e45073f574893b66ceb3ad6d45bb2ced06e0" translate="yes" xml:space="preserve">
          <source>Testing is a complex skill: although we can&amp;rsquo;t cover every detail about how to write good tests in one chapter, we&amp;rsquo;ll discuss the mechanics of Rust&amp;rsquo;s testing facilities. We&amp;rsquo;ll talk about the annotations and macros available to you when writing your tests, the default behavior and options provided for running your tests, and how to organize tests into unit tests and integration tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7c988b9b3e507c053615421186791199dc1b08e" translate="yes" xml:space="preserve">
          <source>Testing the First Part</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="833858d67cb9edd86a232319e147507d73e766ab" translate="yes" xml:space="preserve">
          <source>Tests are Rust functions that verify that the non-test code is functioning in the expected manner. The bodies of test functions typically perform these three actions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9557b92aa71fea3ff4e10ad5c651a01d327198f2" translate="yes" xml:space="preserve">
          <source>Tests if &lt;code&gt;person&lt;/code&gt; has the &lt;code&gt;car&lt;/code&gt; field filled with something.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21b62ab2004ca1232d413d8d665d134b12791482" translate="yes" xml:space="preserve">
          <source>Tests if any element of the iterator matches a predicate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10d2dce236b59fb61d9321a2651527964d17f562" translate="yes" xml:space="preserve">
          <source>Tests if any element of the iterator matches a predicate. &lt;a href=&quot;../../../iter/trait.iterator#method.any&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="209ac04cb187d92f123ce6700c9444025e5580b3" translate="yes" xml:space="preserve">
          <source>Tests if any element of the iterator matches a predicate. &lt;a href=&quot;../../iter/trait.iterator#method.any&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80ec10f423a5beaec1ab62efd9e4031e5aaa4a11" translate="yes" xml:space="preserve">
          <source>Tests if any element of the iterator matches a predicate. &lt;a href=&quot;../iter/trait.iterator#method.any&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="760ae5105c89912ab7a036138a76c59ddfecc44b" translate="yes" xml:space="preserve">
          <source>Tests if any element of the iterator matches a predicate. &lt;a href=&quot;iter/trait.iterator#method.any&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df440409ef320551129c77bcadb79c6c4ba84e37" translate="yes" xml:space="preserve">
          <source>Tests if any element of the iterator matches a predicate. &lt;a href=&quot;trait.iterator#method.any&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42f540ef5575b87eda1bc58cc8c893cf2e3e2964" translate="yes" xml:space="preserve">
          <source>Tests if every element of the iterator matches a predicate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52e69927724e46dd631e47a69a4f2cdc74a668ca" translate="yes" xml:space="preserve">
          <source>Tests if every element of the iterator matches a predicate. &lt;a href=&quot;../../../iter/trait.iterator#method.all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c572c6f114e3b7b0e63531ab8e78116f0d5ac5de" translate="yes" xml:space="preserve">
          <source>Tests if every element of the iterator matches a predicate. &lt;a href=&quot;../../iter/trait.iterator#method.all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a987e1ebbc5dd44d57ed09974bfdcc0f02c47b55" translate="yes" xml:space="preserve">
          <source>Tests if every element of the iterator matches a predicate. &lt;a href=&quot;../iter/trait.iterator#method.all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74b456b0054dd24ca1a515d72ae7f4e5367d4633" translate="yes" xml:space="preserve">
          <source>Tests if every element of the iterator matches a predicate. &lt;a href=&quot;iter/trait.iterator#method.all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92be4e62f1c703e57b0a705c84b8aca1511558d2" translate="yes" xml:space="preserve">
          <source>Tests if every element of the iterator matches a predicate. &lt;a href=&quot;trait.iterator#method.all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ebc400fe5bb7d000d0d73f12e63cdedd3140090" translate="yes" xml:space="preserve">
          <source>Tests if the person's &lt;code&gt;age&lt;/code&gt; field is between 13 and 19, and binds its value to the &lt;code&gt;person_age&lt;/code&gt; variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13e062493861ff1e884762affb6f292d7aaa95d6" translate="yes" xml:space="preserve">
          <source>Tests that return &lt;code&gt;()&lt;/code&gt; pass as long as they terminate and do not panic. Tests that return a &lt;code&gt;Result&amp;lt;(), E&amp;gt;&lt;/code&gt; pass as long as they return &lt;code&gt;Ok(())&lt;/code&gt;. Tests that do not terminate neither pass nor fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="240e8d8b35fd6dbae3889295d03396f4179097df" translate="yes" xml:space="preserve">
          <source>Tests that use &lt;code&gt;should_panic&lt;/code&gt; can be imprecise because they only indicate that the code has caused some panic. A &lt;code&gt;should_panic&lt;/code&gt; test would pass even if the test panics for a different reason from the one we were expecting to happen. To make &lt;code&gt;should_panic&lt;/code&gt; tests more precise, we can add an optional &lt;code&gt;expected&lt;/code&gt; parameter to the &lt;code&gt;should_panic&lt;/code&gt; attribute. The test harness will make sure that the failure message contains the provided text. For example, consider the modified code for &lt;code&gt;Guess&lt;/code&gt; in Listing 11-9 where the &lt;code&gt;new&lt;/code&gt; function panics with different messages depending on whether the value is too small or too large.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bb384831446531aa67968092446024f5dcdae5e" translate="yes" xml:space="preserve">
          <source>Tests whether this file type represents a directory. The result is mutually exclusive to the results of &lt;a href=&quot;struct.filetype#method.is_file&quot;&gt;&lt;code&gt;is_file&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.filetype#method.is_symlink&quot;&gt;&lt;code&gt;is_symlink&lt;/code&gt;&lt;/a&gt;; only zero or one of these tests may pass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47c7f108fa56b78dae837cfbc2c1b6e6d82a8892" translate="yes" xml:space="preserve">
          <source>Tests whether this file type represents a regular file. The result is mutually exclusive to the results of &lt;a href=&quot;struct.filetype#method.is_dir&quot;&gt;&lt;code&gt;is_dir&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.filetype#method.is_symlink&quot;&gt;&lt;code&gt;is_symlink&lt;/code&gt;&lt;/a&gt;; only zero or one of these tests may pass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e2618283b789dcbc952fac3457682ad9646a29b" translate="yes" xml:space="preserve">
          <source>Tests whether this file type represents a symbolic link. The result is mutually exclusive to the results of &lt;a href=&quot;struct.filetype#method.is_dir&quot;&gt;&lt;code&gt;is_dir&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.filetype#method.is_file&quot;&gt;&lt;code&gt;is_file&lt;/code&gt;&lt;/a&gt;; only zero or one of these tests may pass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24e8ed91cce37f2bfddb7d0a6e1b5b5dd3e13c8b" translate="yes" xml:space="preserve">
          <source>Text directionality</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ece7c96ceb6b3c2888b8a50e4cc0084fdd3cc5ad" translate="yes" xml:space="preserve">
          <source>Textual Scope</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f351ed281e01f153c5130339693bdde4a4318e5b" translate="yes" xml:space="preserve">
          <source>Textual representation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50a53707975aa4e011ef0d8fc19d6a0815b5a0af" translate="yes" xml:space="preserve">
          <source>Textual scope is based largely on the order that things appear in source files, and works similarly to the scope of local variables declared with &lt;code&gt;let&lt;/code&gt; except it also applies at the module level. When &lt;code&gt;macro_rules!&lt;/code&gt; is used to define a macro, the macro enters the scope after the definition (note that it can still be used recursively, since names are looked up from the invocation site), up until its surrounding scope, typically a module, is closed. This can enter child modules and even span across multiple files:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3250cb346f89521461c9526f4b4c9e22ab7dec1d" translate="yes" xml:space="preserve">
          <source>Textual types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43b22d6c26a5be334da039abbdd3a863691ba7f8" translate="yes" xml:space="preserve">
          <source>Thankfully, you won't need to worry about upholding this property when deriving both &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;Hash&lt;/code&gt; with &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d87603b9cd3744161580179aa52163b0ef139449" translate="yes" xml:space="preserve">
          <source>Thanks to static lifetime elision, you usually don't have to explicitly use 'static:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bdae0de8a5a5798d4caf783e96f237ed5528f2b" translate="yes" xml:space="preserve">
          <source>Thanks to this process, you can always check out the next build of Rust and verify for yourself that it&amp;rsquo;s easy to upgrade to: if a beta release doesn&amp;rsquo;t work as expected, you can report it to the team and get it fixed before the next stable release happens! Breakage in a beta release is relatively rare, but &lt;code&gt;rustc&lt;/code&gt; is still a piece of software, and bugs do exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93b38f3306b86b6513f0666ee48835c2b21219b2" translate="yes" xml:space="preserve">
          <source>That first part is done by us: when we call &lt;code&gt;String::from&lt;/code&gt;, its implementation requests the memory it needs. This is pretty much universal in programming languages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1348e5b21c821f227473000afcbce413f66d2f49" translate="yes" xml:space="preserve">
          <source>That is, for each element &lt;code&gt;a&lt;/code&gt; and its following element &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;a &amp;lt;= b&lt;/code&gt; must hold. If the iterator yields exactly zero or one element, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf20cf0a5a4308c50df24aa720ae0a415bab9777" translate="yes" xml:space="preserve">
          <source>That is, for each element &lt;code&gt;a&lt;/code&gt; and its following element &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;a &amp;lt;= b&lt;/code&gt; must hold. If the slice yields exactly zero or one element, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6141d9d942518cd742366c4e9a373eaeca5ba99a" translate="yes" xml:space="preserve">
          <source>That number of bytes is always between 1 and 4, inclusive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5636ef2e6fa0c7ceabc2956a6a83de732290f283" translate="yes" xml:space="preserve">
          <source>That said, leaking resources such as memory or I/O objects is usually undesirable, so &lt;code&gt;forget&lt;/code&gt; is only recommended for specialized use cases like those shown below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44e204c683273a7064bf611cb21bf25b6a58ab5e" translate="yes" xml:space="preserve">
          <source>That said, the implementation should provide a correct estimation, because otherwise it would be a violation of the trait's protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bf3790580feeb3b9968c1d5ee569f07fe6dc889" translate="yes" xml:space="preserve">
          <source>That said, there is no wrong way to read this book. Read it however you feel helps you best.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="947746e61ef4047bc2347841bf565d094e7bdec0" translate="yes" xml:space="preserve">
          <source>That solves our problem! With only &lt;code&gt;s2&lt;/code&gt; valid, when it goes out of scope, it alone will free the memory, and we&amp;rsquo;re done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ce801650086879dbc3fc82fa6315949a2552c96" translate="yes" xml:space="preserve">
          <source>That was a bit of a whirlwind tour of unwind safety, but for more information about unwind safety and how it applies to Rust, see an &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md&quot;&gt;associated RFC&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92b56514bc3604cf70d965940d81ed28035240b2" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s 18 bytes and is how computers ultimately store this data. If we look at them as Unicode scalar values, which are what Rust&amp;rsquo;s &lt;code&gt;char&lt;/code&gt; type is, those bytes look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fac4c3e9f71b06878dbbb47f3ce2814227f227f" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s a lot of &lt;code&gt;match&lt;/code&gt;! The &lt;code&gt;match&lt;/code&gt; expression is very useful but also very much a primitive. In Chapter 13, you&amp;rsquo;ll learn about closures; the &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; type has many methods that accept a closure and are implemented using &lt;code&gt;match&lt;/code&gt; expressions. Using those methods will make your code more concise. A more seasoned Rustacean might write this code instead of Listing 9-5:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef238338d4e12acdba68729fda27f2648f9a373c" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s a lot of output! The exact output you see might be different depending on your operating system and Rust version. In order to get backtraces with this information, debug symbols must be enabled. Debug symbols are enabled by default when using &lt;code&gt;cargo build&lt;/code&gt; or &lt;code&gt;cargo run&lt;/code&gt; without the &lt;code&gt;--release&lt;/code&gt; flag, as we have here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b9244a451d65d27f90f013b616e273e2c23a8a2" translate="yes" xml:space="preserve">
          <source>That's it! Let's dig into iterators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="061168032f743f39ddf71cf9c7a9d9f5d6f181f3" translate="yes" xml:space="preserve">
          <source>The &quot;default&quot; usage of this type as a queue is to use &lt;a href=&quot;#method.push_back&quot;&gt;&lt;code&gt;push_back&lt;/code&gt;&lt;/a&gt; to add to the queue, and &lt;a href=&quot;#method.pop_front&quot;&gt;&lt;code&gt;pop_front&lt;/code&gt;&lt;/a&gt; to remove from the queue. &lt;a href=&quot;#method.extend&quot;&gt;&lt;code&gt;extend&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.append&quot;&gt;&lt;code&gt;append&lt;/code&gt;&lt;/a&gt; push onto the back in this manner, and iterating over &lt;code&gt;VecDeque&lt;/code&gt; goes front to back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36f389fc23a4edc2c2a963efce47f9899bcc8519" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;Advanced Lifetimes&amp;rdquo; section of Chapter 19 was removed because compiler improvements have made the constructs in that section even rarer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f99557dc0a8fdf7a63f0792d647f548b4ff6f7ab" translate="yes" xml:space="preserve">
          <source>The 128-bit signed integer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ecb830f3b64176d279185c7c171382698dc346b" translate="yes" xml:space="preserve">
          <source>The 128-bit unsigned integer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="024e734140c83218cfd913643692a04c708db5ec" translate="yes" xml:space="preserve">
          <source>The 16-bit signed integer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c45d15aa8a84f450baba97f342935672e6fa7c43" translate="yes" xml:space="preserve">
          <source>The 16-bit unsigned integer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fca5433f25a52ee7287767b1930704d918391065" translate="yes" xml:space="preserve">
          <source>The 2015 edition does not allow use declarations to reference the &lt;a href=&quot;extern-crates#extern-prelude&quot;&gt;extern prelude&lt;/a&gt;. Thus &lt;a href=&quot;extern-crates&quot;&gt;&lt;code&gt;extern crate&lt;/code&gt;&lt;/a&gt; declarations are still required in 2015 to reference an external crate in a use declaration. Beginning with the 2018 edition, use declarations can specify an external crate dependency the same way &lt;code&gt;extern crate&lt;/code&gt; can.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26b6de1c048ad3b08c5d50eb1e62ebf661747fc3" translate="yes" xml:space="preserve">
          <source>The 2018 Edition of the Rust language includes a number of improvements that make Rust more ergonomic and easier to learn. This printing of the book contains a number of changes to reflect those improvements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c35b45536addab0f127b7ef2a73381bf5aab740" translate="yes" xml:space="preserve">
          <source>The 32-bit floating point type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ede6acb001e744d94e80e43f20515bed53288286" translate="yes" xml:space="preserve">
          <source>The 32-bit signed integer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e99a82ec2d26441031e5f8781a5ebb65a83e0e" translate="yes" xml:space="preserve">
          <source>The 32-bit unsigned integer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13cb697c6b75c7757e9c51749eb9c614ddc9a70f" translate="yes" xml:space="preserve">
          <source>The 64-bit floating point type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="748e7d28f53e7a36937bb25af3f1a76e6a491ad6" translate="yes" xml:space="preserve">
          <source>The 64-bit signed integer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25aeddd62dc36790a2166200538648d83779c0d0" translate="yes" xml:space="preserve">
          <source>The 64-bit unsigned integer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0825a8c90a6add467ca53950b645a26af9033007" translate="yes" xml:space="preserve">
          <source>The 8-bit signed integer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d1f46b751b47e95357a0c40c6e78729c3531e1e" translate="yes" xml:space="preserve">
          <source>The 8-bit unsigned integer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b568b58db2fe5b477d28998d21858de250eecb32" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.clone&quot;&gt;&lt;code&gt;Arc::clone(&amp;amp;from)&lt;/code&gt;&lt;/a&gt; syntax is the most idiomatic because it conveys more explicitly the meaning of the code. In the example above, this syntax makes it easier to see that this code is creating a new reference rather than copying the whole content of foo.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd0354b8e891bd703f8ef8a8ce8547a17dc2e4cc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt; method will connect the socket to a peer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de66ae551d77056e5d10cff2c3fd9dbcc9b63e6e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt; method will connect this socket to a remote address. This method will fail if the socket is not connected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3822ea1855bf914e5a814986732fc459619fc61c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.drain&quot;&gt;&lt;code&gt;drain&lt;/code&gt;&lt;/a&gt; method can emulate &lt;code&gt;truncate&lt;/code&gt;, but causes the excess elements to be returned instead of dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9d6dbd0eeefdb718b7113fea8088d62bd58b0d7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; method has a default implementation, so you usually shouldn't implement it. However, you may be able to provide a more performant implementation than the default, so overriding it in this case makes sense.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dade93dc3cf6b97db5474305c3207f7c692d153c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; adapter is very useful, but only when the closure argument produces values. If it produces an iterator instead, there's an extra layer of indirection. &lt;code&gt;flat_map()&lt;/code&gt; will remove this extra layer on its own.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a52c1262c15b7898ef7ba52e5c11aa28470cc03" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; method will actually check that the provided &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; does not have 0 bytes in the middle, and return an error if it finds one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="156348d96d775ff156fee076f0f98b0084e3469d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; method may be used to send data to the specified address. &lt;a href=&quot;#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.recv_from&quot;&gt;&lt;code&gt;recv_from&lt;/code&gt;&lt;/a&gt; will only receive data from that address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed6b3d78fe45feec8a5741e2a3ac93f1ed3a19d8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#tymethod.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; method is useful for adaptors and explicit buffers themselves for ensuring that all buffered data has been pushed out to the 'true sink'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a62cb575b08d38c732e1bba9328976a264fdb19" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; method will attempt to write some data into the object, returning how many bytes were successfully written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c78f52a30365dea52628c4ade488db0345ffa3ac" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../macro.eprint&quot;&gt;&lt;code&gt;eprint!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../macro.eprintln&quot;&gt;&lt;code&gt;eprintln!&lt;/code&gt;&lt;/a&gt; macros are identical to &lt;a href=&quot;../macro.print&quot;&gt;&lt;code&gt;print!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../macro.println&quot;&gt;&lt;code&gt;println!&lt;/code&gt;&lt;/a&gt;, respectively, except they emit their output to stderr.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15b30e899910805c24344f039598ed4f0cfd76f0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; macro is intended to be familiar to those coming from C's &lt;code&gt;printf&lt;/code&gt;/&lt;code&gt;fprintf&lt;/code&gt; functions or Python's &lt;code&gt;str.format&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1da9aedd3913426ccb3cbeae460a449f6f18fc2d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro will safely create an instance of this structure. The macro validates the format string at compile-time so usage of the &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.format&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; functions can be safely performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6220f58fc37e6b8b0afc01735948c86469d85de" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../macro.vec&quot;&gt;&lt;code&gt;vec!&lt;/code&gt;&lt;/a&gt; macro is provided to make initialization more convenient:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6015eed300b7de406449e79cfdc1aa2f387182e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../macros-by-example#the-macro_use-attribute&quot;&gt;&lt;code&gt;macro_use&lt;/code&gt; attribute&lt;/a&gt; works as usual and import the macro names into the macro-use prelude.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ee79a0bb859db06f06e2ddc850e161230b3ef29" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; constraint is because the closure will need to be passed &lt;em&gt;by value&lt;/em&gt; from the thread where it is spawned to the new thread. Its return value will need to be passed from the new thread to the thread where it is &lt;code&gt;join&lt;/code&gt;ed. As a reminder, the &lt;a href=&quot;../marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; marker trait expresses that it is safe to be passed from thread to thread. &lt;a href=&quot;../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; expresses that it is safe to have a reference be passed from thread to thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c69caf5cbc6ae5668ac370ea6aa28c0348ce679" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt; to an associated item is any path to the implementing type, followed by the associated item's identifier as the final path component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4c6d762c492370e5bdcdefde3e4fc5cf31a9b6e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/items/unions&quot;&gt;Rust equivalent of a C-style union&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb6f479476a4a73b474dd9bb423ce981f3c3f329" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; variant of this result indicates that the primitive was not poisoned, and the &lt;code&gt;Guard&lt;/code&gt; is contained within. The &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; variant indicates that the primitive was poisoned. Note that the &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; variant &lt;em&gt;also&lt;/em&gt; carries the associated guard, and it can be acquired through the &lt;a href=&quot;struct.poisonerror#method.into_inner&quot;&gt;&lt;code&gt;into_inner&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79df059e358a4241ab821f0fe6e918cdbba9f208" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; trait is a supertrait of &lt;code&gt;Copy&lt;/code&gt;, so it also needs compiler generated implementations. It is implemented by the compiler for the following types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeefbcb93aa9d7429fc3ba4a3a1ce956f75d5cfc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; trait changes the semantics of a type implementing it. Values whose type implements &lt;code&gt;Copy&lt;/code&gt; are copied rather than moved upon assignment. &lt;code&gt;Copy&lt;/code&gt; cannot be implemented for types which implement &lt;code&gt;Drop&lt;/code&gt;, or which have fields that are not &lt;code&gt;Copy&lt;/code&gt;. &lt;code&gt;Copy&lt;/code&gt; is implemented by the compiler for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e14c3a80117b6ea49358dfdccbdf20f1c51a89c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; trait indicates that a value of this type is safe to send from one thread to another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bd79bdd63f1cb15136ac63579db2daa51f56797" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../std/marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../std/panic/trait.unwindsafe&quot;&gt;&lt;code&gt;UnwindSafe&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/panic/trait.refunwindsafe&quot;&gt;&lt;code&gt;RefUnwindSafe&lt;/code&gt;&lt;/a&gt; traits are &lt;em&gt;auto traits&lt;/em&gt;. Auto traits have special properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="292a56639a943e7a95497bb0cf72fbedd7460764" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt; trait indicates that the size of this type is known at compile-time; that is, it's not a &lt;a href=&quot;dynamically-sized-types&quot;&gt;dynamically sized type&lt;/a&gt;. &lt;a href=&quot;types/parameters&quot;&gt;Type parameters&lt;/a&gt; are &lt;code&gt;Sized&lt;/code&gt; by default. &lt;code&gt;Sized&lt;/code&gt; is always implemented automatically by the compiler, not by &lt;a href=&quot;items/implementations&quot;&gt;implementation items&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbed2a3ef9298a62094e0bee99c5f47d5609e39c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; trait indicates that a value of this type is safe to share between multiple threads. This trait must be implemented for all types used in immutable &lt;a href=&quot;items/static-items&quot;&gt;&lt;code&gt;static&lt;/code&gt; items&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bd4f0026aa17cd077440ff412c90263cb35c5bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; trait provides a &lt;a href=&quot;destructors&quot;&gt;destructor&lt;/a&gt;, to be run whenever a value of this type is to be destroyed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="767089bdc12afceff4b8eaec0f0a325f5d336e5b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../std/primitive.str#method.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt; method on strings&lt;/a&gt; parses a string into some kind of number. Because this method can parse a variety of number types, we need to tell Rust the exact number type we want by using &lt;code&gt;let guess: u32&lt;/code&gt;. The colon (&lt;code&gt;:&lt;/code&gt;) after &lt;code&gt;guess&lt;/code&gt; tells Rust we&amp;rsquo;ll annotate the variable&amp;rsquo;s type. Rust has a few built-in number types; the &lt;code&gt;u32&lt;/code&gt; seen here is an unsigned, 32-bit integer. It&amp;rsquo;s a good default choice for a small positive number. You&amp;rsquo;ll learn about other number types in Chapter 3. Additionally, the &lt;code&gt;u32&lt;/code&gt; annotation in this example program and the comparison with &lt;code&gt;secret_number&lt;/code&gt; means that Rust will infer that &lt;code&gt;secret_number&lt;/code&gt; should be a &lt;code&gt;u32&lt;/code&gt; as well. So now the comparison will be between two values of the same type!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac19fe7126085cad17eb0b418fa395ae25fa16f2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../str/struct.utf8error&quot;&gt;&lt;code&gt;Utf8Error&lt;/code&gt;&lt;/a&gt; type provided by &lt;a href=&quot;../str/index&quot;&gt;&lt;code&gt;std::str&lt;/code&gt;&lt;/a&gt; represents an error that may occur when converting a slice of &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;s to a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. In this sense, it's an analogue to &lt;code&gt;FromUtf8Error&lt;/code&gt;, and you can get one from a &lt;code&gt;FromUtf8Error&lt;/code&gt; through the &lt;a href=&quot;#method.utf8_error&quot;&gt;&lt;code&gt;utf8_error&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fb67cacdd201c958a0c7d558837d2a8082fe699" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../str/struct.utf8error&quot;&gt;&lt;code&gt;Utf8Error&lt;/code&gt;&lt;/a&gt; type provided by &lt;a href=&quot;../str/index&quot;&gt;&lt;code&gt;std::str&lt;/code&gt;&lt;/a&gt; represents an error that may occur when converting a slice of &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;s to a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. In this sense, it's an analogue to &lt;code&gt;FromUtf8Error&lt;/code&gt;. See its documentation for more details on using it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddda8120a353c19c1143b9fe623d73b4dcc57ac8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;boxed/struct.box#method.into_raw&quot;&gt;&lt;code&gt;into_raw&lt;/code&gt;&lt;/a&gt; function consumes a box and returns the raw pointer. It doesn't destroy &lt;code&gt;T&lt;/code&gt; or deallocate any memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8812873ebf26389aa2891235cb5791e408b7568" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;collections/index&quot;&gt;&lt;code&gt;collections&lt;/code&gt;&lt;/a&gt; module defines maps, sets, linked lists and other typical collection types, including the common &lt;a href=&quot;collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a000df2416eeaceaee8b63bcc4f4d96683535efe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;conditional-compilation#the-cfg-attribute&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;conditional-compilation#the-cfg_attr-attribute&quot;&gt;&lt;code&gt;cfg_attr&lt;/code&gt;&lt;/a&gt; attributes are active. The &lt;a href=&quot;attributes/testing#the-test-attribute&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt; attribute is inert when compiling for tests and active otherwise. &lt;a href=&quot;procedural-macros#attribute-macros&quot;&gt;Attribute macros&lt;/a&gt; are active. All other attributes are inert.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a453b12ad8603a837d27104bf0cf09312a2b66" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereference operator&lt;/a&gt; for &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; produces a place which can be moved from. This means that the &lt;code&gt;*&lt;/code&gt; operator and the destructor of &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; are built-in to the language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69b248ba9e2f044518c42fe197df63cfa4b2abff" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereference operator&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecbb9300a5b716ea6923d97c4a33bcc05beabca8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fn.current&quot;&gt;&lt;code&gt;thread::current&lt;/code&gt;&lt;/a&gt; function is available even for threads not spawned by the APIs of this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83c879af00d7b8c642fb06e560ce31570f391a07" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fn.escape_default&quot;&gt;&lt;code&gt;escape_default&lt;/code&gt;&lt;/a&gt; function provides an iterator over the bytes of an escaped version of the character given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04034ef7d1f4bac81675e414f3f0f4340588ab73" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fn.park&quot;&gt;&lt;code&gt;thread::park&lt;/code&gt;&lt;/a&gt; function blocks the current thread unless or until the token is available for its thread handle, at which point it atomically consumes the token. It may also return &lt;em&gt;spuriously&lt;/em&gt;, without consuming the token. &lt;a href=&quot;fn.park_timeout&quot;&gt;&lt;code&gt;thread::park_timeout&lt;/code&gt;&lt;/a&gt; does the same, but allows specifying a maximum time to block the thread for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010183e81cf43fb24dc3ff708d62a66ab46d9a21" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;thread::spawn&lt;/code&gt;&lt;/a&gt; free function uses a &lt;code&gt;Builder&lt;/code&gt; with default configuration and &lt;a href=&quot;../result/enum.result#method.unwrap&quot;&gt;&lt;code&gt;unwrap&lt;/code&gt;&lt;/a&gt;s its return value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d631316da22e8f49a59e622d46e415aca63cb44" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; of an &lt;a href=&quot;expressions/if-expr#if-let-expressions&quot;&gt;&lt;code&gt;if let&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;expressions/match-expr&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;expressions/loop-expr#predicate-pattern-loops&quot;&gt;&lt;code&gt;while let&lt;/code&gt;&lt;/a&gt; expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f60d04280a375c73571ef4d8073dd6fd2b866e51" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://doc.rust-lang.org/nomicon/transmutes.html&quot;&gt;nomicon&lt;/a&gt; has additional documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="234fa73a8f6dcc88ca3eeed24db16797666a2694" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1270-deprecation.md&quot;&gt;RFC&lt;/a&gt; contains motivations and more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a13e231d1887805079fed3345d62d70fa98ffc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;modules#prelude-items&quot;&gt;&lt;code&gt;no_implicit_prelude&lt;/code&gt;&lt;/a&gt; attribute can be used on a module to disable prelude lookups within that module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d090eed4aa4b11f0c7d0fffa892207e5f74b95a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;option/index&quot;&gt;&lt;code&gt;option&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;result/index&quot;&gt;&lt;code&gt;result&lt;/code&gt;&lt;/a&gt; modules define optional and error-handling types, &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;iter/index&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; module defines Rust's iterator trait, &lt;a href=&quot;iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, which works with the &lt;a href=&quot;../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loop to access collections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bee548c1faeb9c0868a59d1b0359e0916d54967" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.arc#method.downgrade&quot;&gt;&lt;code&gt;downgrade&lt;/code&gt;&lt;/a&gt; method can be used to create a non-owning &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer. A &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer can be &lt;a href=&quot;struct.weak#method.upgrade&quot;&gt;&lt;code&gt;upgrade&lt;/code&gt;&lt;/a&gt;d to an &lt;code&gt;Arc&lt;/code&gt;, but this will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the value has already been dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94c3ecdf0be1261908d0f10ca942b75ee9286aef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.arguments&quot;&gt;&lt;code&gt;Arguments&lt;/code&gt;&lt;/a&gt; instance can be created with the &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa75ef55ee98f7d19f2ace1042e87faf9ee8ae65" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.bufwriter&quot;&gt;&lt;code&gt;BufWriter&lt;/code&gt;&lt;/a&gt; struct wraps a writer and buffers its output. But it only does this batched write when it goes out of scope, or when the internal buffer is full. Sometimes, you'd prefer to write each line as it's completed, rather than the entire buffer at once. Enter &lt;code&gt;LineWriter&lt;/code&gt;. It does exactly that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a07405d582facf4ae9638d6c46ccf83d378ca9a4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.builder#method.spawn&quot;&gt;&lt;code&gt;spawn&lt;/code&gt;&lt;/a&gt; method will take ownership of the builder and create an &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt; to the thread handle with the given configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8461a34249fb23d4197f5b2441105518f99e167b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.command&quot;&gt;&lt;code&gt;Command&lt;/code&gt;&lt;/a&gt; struct is used to configure and spawn processes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0f682c8845fc1182cef69275c8073a32be2d0f3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.command#method.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.command#method.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;struct.command#method.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; of a child process can be configured by passing an &lt;a href=&quot;struct.stdio&quot;&gt;&lt;code&gt;Stdio&lt;/code&gt;&lt;/a&gt; to the corresponding method on &lt;a href=&quot;struct.command&quot;&gt;&lt;code&gt;Command&lt;/code&gt;&lt;/a&gt;. Once spawned, they can be accessed from the &lt;a href=&quot;struct.child&quot;&gt;&lt;code&gt;Child&lt;/code&gt;&lt;/a&gt;. For example, piping output from one command into another command can be done like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="979c5c1602643a6a3cebe7ffbfac71410fb43889" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; method returns a &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;thread::Result&lt;/code&gt;&lt;/a&gt; containing &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; of the final value produced by the child thread, or &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; of the value given to a call to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; if the child panicked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d70df5ac1306fbf7451739c8b7b5cbb316412dcd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.localkey#method.with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; method yields a reference to the contained value which cannot be sent across threads or escape the given closure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cdf73c1055626ea58f2e6c5956631d7c37626c9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.rc#method.downgrade&quot;&gt;&lt;code&gt;downgrade&lt;/code&gt;&lt;/a&gt; method can be used to create a non-owning &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer. A &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointer can be &lt;a href=&quot;struct.weak#method.upgrade&quot;&gt;&lt;code&gt;upgrade&lt;/code&gt;&lt;/a&gt;d to an &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;, but this will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the value has already been dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="673675ebe57e0604b8f52dd76cd89f3cf84af682" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; operation can only fail if the sending half of a &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt;) is disconnected, implying that no further messages will ever be received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2096b737ddfebc05d46f568e296a81f0a3d0197e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt; can be cloned to &lt;a href=&quot;struct.sender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; to the same channel multiple times, but only one &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; is supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d38fd997ec90eab994427a1fbc1ca66e988ed96b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.syncsender&quot;&gt;&lt;code&gt;SyncSender&lt;/code&gt;&lt;/a&gt; can be cloned to &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; to the same channel multiple times, but only one &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; is supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7001293def1e95a9d6c40ad63bf180d03eb64fd9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;struct.thread#method.unpark&quot;&gt;&lt;code&gt;unpark&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;struct.thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt; atomically makes the token available if it wasn't already. Because the token is initially absent, &lt;a href=&quot;struct.thread#method.unpark&quot;&gt;&lt;code&gt;unpark&lt;/code&gt;&lt;/a&gt; followed by &lt;a href=&quot;fn.park&quot;&gt;&lt;code&gt;park&lt;/code&gt;&lt;/a&gt; will result in the second call returning immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea6d0b5a4d7abf2551cbce00a21d08c3b9b0ea9b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;thread/index&quot;&gt;&lt;code&gt;thread&lt;/code&gt;&lt;/a&gt; module contains Rust's threading abstractions. &lt;a href=&quot;sync/index&quot;&gt;&lt;code&gt;sync&lt;/code&gt;&lt;/a&gt; contains further primitive shared memory types, including &lt;a href=&quot;sync/atomic/index&quot;&gt;&lt;code&gt;atomic&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;sync/mpsc/index&quot;&gt;&lt;code&gt;mpsc&lt;/code&gt;&lt;/a&gt;, which contains the channel types for message passing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49a461a4d2bf3262db6f2402e2172259bf56947f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.asciiext&quot;&gt;&lt;code&gt;AsciiExt&lt;/code&gt;&lt;/a&gt; trait provides methods that allow for character operations that only act on the ASCII subset and leave non-ASCII characters alone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a4c8cc0a085c3df1289a22cd8aaec879c0c1b9f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.doubleendediterator&quot;&gt;trait-level&lt;/a&gt; docs contain more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9baa3ad4d7314655f1af4e53b409fbc088f4b8e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.error#method.source&quot;&gt;&lt;code&gt;source&lt;/code&gt;&lt;/a&gt; method is generally used when errors cross &quot;abstraction boundaries&quot;. If one module must report an error that is caused by an error from a lower-level module, it can allow access to that error via the &lt;a href=&quot;trait.error#method.source&quot;&gt;&lt;code&gt;source&lt;/code&gt;&lt;/a&gt; method. This makes it possible for the high-level module to provide its own errors while also revealing some of the implementation for debugging via &lt;a href=&quot;trait.error#method.source&quot;&gt;&lt;code&gt;source&lt;/code&gt;&lt;/a&gt; chains.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8960e05e681fd3c863585eb072cff67079ae758" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt; traits are implemented by types that can be invoked like functions. Note that &lt;a href=&quot;trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt; takes &lt;code&gt;&amp;amp;self&lt;/code&gt;, &lt;a href=&quot;trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt; takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt; and &lt;a href=&quot;trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt; takes &lt;code&gt;self&lt;/code&gt;. These correspond to the three kinds of methods that can be invoked on an instance: call-by-reference, call-by-mutable-reference, and call-by-value. The most common use of these traits is to act as bounds to higher-level functions that take functions or closures as arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af84d72464a620d276e568d18222de12da4b2fde" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; iterator implements &lt;a href=&quot;trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt;, meaning that you can also &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; backwards:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0672d71e250ee0ec8fcc8dfa66640aade0f2d7e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; traits behave like &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;, but should be implemented when the conversion can fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75436aa22cb5f73032a0aa74018fe133c992dee0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;type-layout#primitive-representations&quot;&gt;primitive representations&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76a754ff1ade7a85d17901c16d28f4fc1a0ec281" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;types/inferred&quot;&gt;inferred type&lt;/a&gt; which asks the compiler to determine the type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbc904b6676167d928a315d71b571002efe99186" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;types/never&quot;&gt;never&lt;/a&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86dac89caf1fb6bb25d3f0271f01c85dae090eff" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the--operator-can-only-be-used-in-functions-that-return-result&quot;&gt;?&lt;/code&gt; Operator Can Only Be Used in Functions That Return &lt;code&gt;Result&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf416e54f0f3d3a2ee8340cdce3195c04f0662bc" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-_-placeholder&quot;&gt;_&lt;/code&gt; Placeholder</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d36ad4c51a4dc937d643fbbbf54439f451168f2" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-args-function-and-invalid-unicode&quot;&gt;args&lt;/code&gt; Function and Invalid Unicode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46f91b9733dfb285998974fd7a3ed63a6997485d" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-iterator-trait-and-the-next-method&quot;&gt;Iterator&lt;/code&gt; Trait and the &lt;code&gt;next&lt;/code&gt; Method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="479b4a692bc6c43f38d4737f51dec06b4e143a16" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-match-control-flow-operator&quot;&gt;match&lt;/code&gt; Control Flow Operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5417fc07a4925f25ebbeb5f618a1275243378ced" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-option-enum-and-its-advantages-over-null-values&quot;&gt;Option&lt;/code&gt; Enum and Its Advantages Over Null Values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93213a38ad3b67a68894b916ca83c68efaaa5823" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;the-string-type&quot;&gt;String&lt;/code&gt; Type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="844971eb58988950f234035bf3b738d18df15983" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!&lt;/code&gt; type, also called &quot;never&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1959101a4f878a742e6d622df58125da3c9ee8ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#![feature]&lt;/code&gt; attribute specified an unknown feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6772d2ae0b060a250746d33cd174746c466f1400" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[cfg(test)]&lt;/code&gt; annotation on the tests module tells Rust to compile and run the test code only when you run &lt;code&gt;cargo test&lt;/code&gt;, not when you run &lt;code&gt;cargo build&lt;/code&gt;. This saves compile time when you only want to build the library and saves space in the resulting compiled artifact because the tests are not included. You&amp;rsquo;ll see that because integration tests go in a different directory, they don&amp;rsquo;t need the &lt;code&gt;#[cfg(test)]&lt;/code&gt; annotation. However, because unit tests go in the same files as the code, you&amp;rsquo;ll use &lt;code&gt;#[cfg(test)]&lt;/code&gt; to specify that they shouldn&amp;rsquo;t be included in the compiled result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="519f31417527ab16777c33990a8b19270d90ed97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[global_allocator]&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e73c0e75e8ab048b307c0488b5dbff0af69bd767" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[global_allocator]&lt;/code&gt; can only be used once in a crate or its recursive dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="672159bbb94aa0ec135859c99523eca0ebc397f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[macro_export]&lt;/code&gt; annotation indicates that this macro should be made available whenever the crate in which the macro is defined is brought into scope. Without this annotation, the macro can&amp;rsquo;t be brought into scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="859ec264725730980afa9483dd83d3f313613cc7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[repr(C)]&lt;/code&gt; attribute can only be placed on structs and enums.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20ce08781d178cc7ecc1d0ee2405f13954a27792" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[repr(packed)]&lt;/code&gt; and &lt;code&gt;#[repr(simd)]&lt;/code&gt; attributes only work on structs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e64d7cdeff0fe84feb89e7cacb8aa07bcc4dd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[repr(u8)]&lt;/code&gt;, &lt;code&gt;#[repr(i16)]&lt;/code&gt;, etc attributes only work on enums.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9b512964c382c5f5d5e0080e7203c876528ceb6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[rustc_on_unimplemented]&lt;/code&gt; attribute lets you specify a custom error message for when a particular trait isn't implemented on a type placed in a position that needs that trait. For example, when the following code is compiled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="910d7829ddf09eb2fc4a2ff115280a7e351c19be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[simd]&lt;/code&gt; attribute can only be applied to non empty tuple structs, because it doesn't make sense to try to use SIMD operations when there are no values to operate on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a3879322df478a4cc556128e471d1c66adae12" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#[unwind]&lt;/code&gt; attribute should be used as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e0afa92240bade4867a8d2b0fc7bc387cff228f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; (shared borrow) and &lt;code&gt;&amp;amp;mut&lt;/code&gt; (mutable borrow) operators are unary prefix operators. When applied to a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt;, this expressions produces a reference (pointer) to the location that the value refers to. The memory location is also placed into a borrowed state for the duration of the reference. For a shared borrow (&lt;code&gt;&amp;amp;&lt;/code&gt;), this implies that the place may not be mutated, but it may be read or shared again. For a mutable borrow (&lt;code&gt;&amp;amp;mut&lt;/code&gt;), the place may not be accessed in any way until the borrow expires. &lt;code&gt;&amp;amp;mut&lt;/code&gt; evaluates its operand in a mutable place expression context. If the &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut&lt;/code&gt; operators are applied to a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression&lt;/a&gt;, then a &lt;a href=&quot;../expressions#temporary-lifetimes&quot;&gt;temporary value&lt;/a&gt; is created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="289f7ac6e65862e6021cefdfd8637885846add32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; indicates that this argument is a &lt;em&gt;reference&lt;/em&gt;, which gives you a way to let multiple parts of your code access one piece of data without needing to copy that data into memory multiple times. References are a complex feature, and one of Rust&amp;rsquo;s major advantages is how safe and easy it is to use references. You don&amp;rsquo;t need to know a lot of those details to finish this program. For now, all you need to know is that like variables, references are immutable by default. Hence, you need to write &lt;code&gt;&amp;amp;mut guess&lt;/code&gt; rather than &lt;code&gt;&amp;amp;guess&lt;/code&gt; to make it mutable. (Chapter 4 will explain references more thoroughly.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ba71ec6a87d61177d25877a820fc83d9405b11e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;s1&lt;/code&gt; syntax lets us create a reference that &lt;em&gt;refers&lt;/em&gt; to the value of &lt;code&gt;s1&lt;/code&gt; but does not own it. Because it does not own it, the value it points to will not be dropped when the reference goes out of scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac2092b7195c0e20492c6630d5e4fa162bb49bf5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;str&lt;/code&gt; type guarantees that its contents are UTF-8, and so we can compare the length it would take if each code point was represented as a &lt;code&gt;char&lt;/code&gt; vs in the &lt;code&gt;&amp;amp;str&lt;/code&gt; itself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9573f9c210e855e348b2b66cefde61b52fa3eea1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;str&lt;/code&gt; type is one of the two main string types, the other being &lt;code&gt;String&lt;/code&gt;. Unlike its &lt;code&gt;String&lt;/code&gt; counterpart, its contents are borrowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dd45416e37868ecd085972d08ce3b564e5e5995" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;&lt;/code&gt; syntax tells the shell to write the contents of standard output to &lt;em&gt;output.txt&lt;/em&gt; instead of the screen. We didn&amp;rsquo;t see the error message we were expecting printed to the screen, so that means it must have ended up in the file. This is what &lt;em&gt;output.txt&lt;/em&gt; contains:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b005addd17171fe396053ec0c62812c2c97cade4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; syntax is a feature of Rust we haven&amp;rsquo;t talked about yet. It&amp;rsquo;s a generic type parameter, and we&amp;rsquo;ll cover generics in more detail in Chapter 10. For now, all you need to know is that &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; means the &lt;code&gt;Some&lt;/code&gt; variant of the &lt;code&gt;Option&lt;/code&gt; enum can hold one piece of data of any type. Here are some examples of using &lt;code&gt;Option&lt;/code&gt; values to hold number types and string types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e8f2a70b6f25c55e2febf941fcc1166aa49e75b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'static&lt;/code&gt; constraint means that the closure and its return value must have a lifetime of the whole program execution. The reason for this is that threads can &lt;code&gt;detach&lt;/code&gt; and outlive the lifetime they have been created in. Indeed if the thread, and by extension its return value, can outlive their caller, we need to make sure that they will be valid afterwards, and since we &lt;em&gt;can't&lt;/em&gt; know when it will return we need to have them valid as long as possible, that is until the end of the program, hence the &lt;code&gt;'static&lt;/code&gt; lifetime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d507c32a06112cec989a75204d96602b968865dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;()&lt;/code&gt; type has exactly one value &lt;code&gt;()&lt;/code&gt;, and is used when there is no other meaningful value that could be returned. &lt;code&gt;()&lt;/code&gt; is most commonly seen implicitly: functions without a &lt;code&gt;-&amp;gt; ...&lt;/code&gt; implicitly have return type &lt;code&gt;()&lt;/code&gt;, that is, these are equivalent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad7f39bcbd9c29a0b11698eda466dd66f20fff6f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;()&lt;/code&gt; type, sometimes called &quot;unit&quot; or &quot;nil&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="918cd095e0c314aaf612bef93955c593d22df666" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;(*m)&lt;/code&gt; dereferences the &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; into a &lt;code&gt;String&lt;/code&gt;. Then the &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;[..]&lt;/code&gt; take a string slice of the &lt;code&gt;String&lt;/code&gt; that is equal to the whole string to match the signature of &lt;code&gt;hello&lt;/code&gt;. The code without deref coercions is harder to read, write, and understand with all of these symbols involved. Deref coercion allows Rust to handle these conversions for us automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dceab58b2710b9293ff102afe19580771458da84" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*&lt;/code&gt; (dereference) operator is also a unary prefix operator. When applied to a &lt;a href=&quot;../types/pointer&quot;&gt;pointer&lt;/a&gt; it denotes the pointed-to location. If the expression is of type &lt;code&gt;&amp;amp;mut T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;, and is either a local variable, a (nested) field of a local variable or is a mutable &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt;, then the resulting memory location can be assigned to. Dereferencing a raw pointer requires &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9081a0fc77deca2ae1677facd10e7e74970f88a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; syntax is also valid with trait bounds on generic types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf7d56124b7814800cfa939450d0c6d38a399da8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; operators may be composed with the &lt;code&gt;=&lt;/code&gt; operator. The expression &lt;code&gt;place_exp OP= value&lt;/code&gt; is equivalent to &lt;code&gt;place_expr = place_expr OP val&lt;/code&gt;. For example, &lt;code&gt;x = x + 1&lt;/code&gt; may be written as &lt;code&gt;x += 1&lt;/code&gt;. Any such expression always has the &lt;a href=&quot;../types/tuple&quot;&gt;&lt;code&gt;unit&lt;/code&gt; type&lt;/a&gt;. These operators can all be overloaded using the trait with the same name as for the normal operation followed by 'Assign', for example, &lt;code&gt;std::ops::AddAssign&lt;/code&gt; is used to overload &lt;code&gt;+=&lt;/code&gt;. As with &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;place_expr&lt;/code&gt; must be a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8565fcc01087bd00c830a709f76c89a8bec0ee11" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;...&lt;/code&gt; syntax allows us to match to an inclusive range of values. In the following code, when a pattern matches any of the values within the range, that arm will execute:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4afeb6b704f2eeee4511dc907c8b58744889e53" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;...&lt;/code&gt; syntax is kept for backwards compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2e1f03ffc70a6a254885658fe3c94afc796ca12" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..&lt;/code&gt; and &lt;code&gt;..=&lt;/code&gt; operators will construct an object of one of the &lt;code&gt;std::ops::Range&lt;/code&gt; (or &lt;code&gt;core::ops::Range&lt;/code&gt;) variants, according to the following table:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92e96dedbdbf92f3e2e6464ed4a171437558a608" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..&lt;/code&gt; syntax is a &lt;code&gt;RangeFull&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc028c330bc0f9500e9f59b98e8ba94a546679b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..=end&lt;/code&gt; syntax is a &lt;code&gt;RangeToInclusive&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06bff2e76574f65224a2d8263399ed02a85a5a5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..end&lt;/code&gt; syntax is a &lt;code&gt;RangeTo&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2942c55d614162c6590171ee52a6786d9039b19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;0 measured&lt;/code&gt; statistic is for benchmark tests that measure performance. Benchmark tests are, as of this writing, only available in nightly Rust. See &lt;a href=&quot;https://doc.rust-lang.org/unstable-book/library-features/test.html&quot;&gt;the documentation about benchmark tests&lt;/a&gt; to learn more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79584c510d0bdac6b79741ca275d743c77143fc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;3&lt;/code&gt; is no longer there, because it was consumed in order to see if the iteration should stop, but wasn't placed back into the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e721998eb3ac8ff36164c3da054ad164e33f55c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;5&lt;/code&gt; in &lt;code&gt;five&lt;/code&gt; is the function&amp;rsquo;s return value, which is why the return type is &lt;code&gt;i32&lt;/code&gt;. Let&amp;rsquo;s examine this in more detail. There are two important bits: first, the line &lt;code&gt;let x = five();&lt;/code&gt; shows that we&amp;rsquo;re using the return value of a function to initialize a variable. Because the function &lt;code&gt;five&lt;/code&gt; returns a &lt;code&gt;5&lt;/code&gt;, that line is the same as the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f64d85c43f38ffb1d9f69e7f8ec2961df3c8d6da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;::&lt;/code&gt; syntax in the &lt;code&gt;::new&lt;/code&gt; line indicates that &lt;code&gt;new&lt;/code&gt; is an &lt;em&gt;associated function&lt;/em&gt; of the &lt;code&gt;String&lt;/code&gt; type. An associated function is implemented on a type, in this case &lt;code&gt;String&lt;/code&gt;, rather than on a particular instance of a &lt;code&gt;String&lt;/code&gt;. Some languages call this a &lt;em&gt;static method&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c666ec2c7e67dbab00bbae26838dd52620a7c41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;::&lt;/code&gt; token is required before the opening &lt;code&gt;&amp;lt;&lt;/code&gt; for generic arguments to avoid ambiguity with the less-than operator. This is colloquially known as &quot;turbofish&quot; syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ec4c0c2491bd5a54898bf44aa756701f4e9b5fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?&lt;/code&gt; operator can only be used in functions that have a return type of &lt;code&gt;Result&lt;/code&gt;, because it is defined to work in the same way as the &lt;code&gt;match&lt;/code&gt; expression we defined in Listing 9-6. The part of the &lt;code&gt;match&lt;/code&gt; that requires a return type of &lt;code&gt;Result&lt;/code&gt; is &lt;code&gt;return Err(e)&lt;/code&gt;, so the return type of the function must be a &lt;code&gt;Result&lt;/code&gt; to be compatible with this &lt;code&gt;return&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd74ffef5a8c90c3fd4d6d76e29ea8086760c062" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?&lt;/code&gt; operator eliminates a lot of boilerplate and makes this function&amp;rsquo;s implementation simpler. We could even shorten this code further by chaining method calls immediately after the &lt;code&gt;?&lt;/code&gt;, as shown in Listing 9-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69d45072228b4f483bc2426682521ed37346faf8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?&lt;/code&gt; operator was added to replace &lt;code&gt;try!&lt;/code&gt; and should be used instead. Furthermore, &lt;code&gt;try&lt;/code&gt; is a reserved word in Rust 2018, so if you must use it, you will need to use the &lt;a href=&quot;https://doc.rust-lang.org/nightly/rust-by-example/compatibility/raw_identifiers.html&quot;&gt;raw-identifier syntax&lt;/a&gt;: &lt;code&gt;r#try&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c02b9d3c4349fb0a9b0da69a54ee8f956959e334" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?&lt;/code&gt; placed after a &lt;code&gt;Result&lt;/code&gt; value is defined to work in almost the same way as the &lt;code&gt;match&lt;/code&gt; expressions we defined to handle the &lt;code&gt;Result&lt;/code&gt; values in Listing 9-6. If the value of the &lt;code&gt;Result&lt;/code&gt; is an &lt;code&gt;Ok&lt;/code&gt;, the value inside the &lt;code&gt;Ok&lt;/code&gt; will get returned from this expression, and the program will continue. If the value is an &lt;code&gt;Err&lt;/code&gt;, the &lt;code&gt;Err&lt;/code&gt; will be returned from the whole function as if we had used the &lt;code&gt;return&lt;/code&gt; keyword so the error value gets propagated to the calling code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dcf74da2de6e2e77e988e297d47588fe8eb0ad5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Alloc&lt;/code&gt; trait is an &lt;code&gt;unsafe&lt;/code&gt; trait for a number of reasons, and implementors must ensure that they adhere to these contracts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98e48446e54082f0c926a4f9b0d797094660f773" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AllocErr&lt;/code&gt; error indicates an allocation failure that may be due to resource exhaustion or to something wrong when combining the given input arguments with this allocator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a15f84d510941143cdca2ea70c5b85337d8cfce7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Binary&lt;/code&gt; trait should format its output as a number in binary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6e3077926ddb39580746ea9c9fb509f4ede0db3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; type is a smart pointer because it implements the &lt;code&gt;Deref&lt;/code&gt; trait, which allows &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; values to be treated like references. When a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; value goes out of scope, the heap data that the box is pointing to is cleaned up as well because of the &lt;code&gt;Drop&lt;/code&gt; trait implementation. Let&amp;rsquo;s explore these two traits in more detail. These two traits will be even more important to the functionality provided by the other smart pointer types we&amp;rsquo;ll discuss in the rest of this chapter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66f94ad31e24eabd73aee0f8f7b4d3256d1ad7c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; type is ultimately defined as a tuple struct with one element, so Listing 15-8 defines a &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; type in the same way. We&amp;rsquo;ll also define a &lt;code&gt;new&lt;/code&gt; function to match the &lt;code&gt;new&lt;/code&gt; function defined on &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf6505b6927d963f13c67732403dd5931ac1ed9c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; type is called a &lt;em&gt;trait object&lt;/em&gt;, which we&amp;rsquo;ll talk about in the &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;Using Trait Objects that Allow for Values of Different Types&amp;rdquo;&lt;/a&gt; section in Chapter 17. For now, you can read &lt;code&gt;Box&amp;lt;dyn Error&amp;gt;&lt;/code&gt; to mean &amp;ldquo;any kind of error.&amp;rdquo; Using &lt;code&gt;?&lt;/code&gt; in a &lt;code&gt;main&lt;/code&gt; function with this return type is allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1691172593fd486c5eabaf315f65ace8dbf6dcde" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BufReader&lt;/code&gt; struct adds buffering to any reader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="258a1854757eccfe175a683df1ba477ca28eb2bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;C&lt;/code&gt; Representation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13bde6b705c6f0c548e0105a8252725ac6ce4d78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;C&lt;/code&gt; representation for items has a defined layout. With this layout, the size of items is also stable as long as all fields have a stable size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51da5ab6258546c0e07e79893a79989cd376412d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;C&lt;/code&gt; representation is designed for dual purposes. One purpose is for creating types that are interoperable with the C Language. The second purpose is to create types that you can soundly perform operations on that rely on data layout such as reinterpreting values as a different type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3b29c11032bb6739237ad8f95e6e66861078b0e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cacher::new&lt;/code&gt; function takes a generic parameter &lt;code&gt;T&lt;/code&gt;, which we&amp;rsquo;ve defined as having the same trait bound as the &lt;code&gt;Cacher&lt;/code&gt; struct. Then &lt;code&gt;Cacher::new&lt;/code&gt; returns a &lt;code&gt;Cacher&lt;/code&gt; instance that holds the closure specified in the &lt;code&gt;calculation&lt;/code&gt; field and a &lt;code&gt;None&lt;/code&gt; value in the &lt;code&gt;value&lt;/code&gt; field, because we haven&amp;rsquo;t executed the closure yet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4813a8ce2e935eef24c8392e81d63c3906c4494" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cacher&lt;/code&gt; struct has a &lt;code&gt;calculation&lt;/code&gt; field of the generic type &lt;code&gt;T&lt;/code&gt;. The trait bounds on &lt;code&gt;T&lt;/code&gt; specify that it&amp;rsquo;s a closure by using the &lt;code&gt;Fn&lt;/code&gt; trait. Any closure we want to store in the &lt;code&gt;calculation&lt;/code&gt; field must have one &lt;code&gt;u32&lt;/code&gt; parameter (specified within the parentheses after &lt;code&gt;Fn&lt;/code&gt;) and must return a &lt;code&gt;u32&lt;/code&gt; (specified after the &lt;code&gt;-&amp;gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2611487755ed0f487d8741cbb5ae43a528fa050" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CannotReallocInPlace&lt;/code&gt; error is used when &lt;code&gt;grow_in_place&lt;/code&gt; or &lt;code&gt;shrink_in_place&lt;/code&gt; were unable to reuse the given memory block for a requested layout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66ff318ae517f73cd3f13be64857852133418c2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Clone&lt;/code&gt; trait allows you to explicitly create a deep copy of a value, and the duplication process might involve running arbitrary code and copying heap data. See the &lt;a href=&quot;ch04-01-what-is-ownership#ways-variables-and-data-interact-clone&quot;&gt;&amp;ldquo;Ways Variables and Data Interact: Clone&amp;rdquo;&lt;/a&gt; section in Chapter 4 for more information on &lt;code&gt;Clone&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad03569cf96b66590827b19ede2029d2fc0e960d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Clone&lt;/code&gt; trait for types that cannot be 'implicitly copied'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18eff9d7482bec9f52eb9a085d95c11254b36933" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CoerceUnsized&lt;/code&gt; trait takes a struct type. Make sure the type you are providing to &lt;code&gt;CoerceUnsized&lt;/code&gt; is a struct with only the last field containing an unsized type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e548ae9701e88686017ab152887ae716380c763e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Config::new&lt;/code&gt; function definition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="501a0b9d21e10f396777e5d2959bafbe25f146ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cons&lt;/code&gt; variant will need the size of an &lt;code&gt;i32&lt;/code&gt; plus the space to store the box&amp;rsquo;s pointer data. The &lt;code&gt;Nil&lt;/code&gt; variant stores no values, so it needs less space than the &lt;code&gt;Cons&lt;/code&gt; variant. We now know that any &lt;code&gt;List&lt;/code&gt; value will take up the size of an &lt;code&gt;i32&lt;/code&gt; plus the size of a box&amp;rsquo;s pointer data. By using a box, we&amp;rsquo;ve broken the infinite, recursive chain, so the compiler can figure out the size it needs to store a &lt;code&gt;List&lt;/code&gt; value. Figure 15-2 shows what the &lt;code&gt;Cons&lt;/code&gt; variant looks like now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a626d0216123ae4ac45161a1bdf7e2c4de5ee23a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cons&lt;/code&gt; variants own the data they hold, so when we create the &lt;code&gt;b&lt;/code&gt; list, &lt;code&gt;a&lt;/code&gt; is moved into &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; owns &lt;code&gt;a&lt;/code&gt;. Then, when we try to use &lt;code&gt;a&lt;/code&gt; again when creating &lt;code&gt;c&lt;/code&gt;, we&amp;rsquo;re not allowed to because &lt;code&gt;a&lt;/code&gt; has been moved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ddcf60586798598b647a102cf947282e0f109f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Context&lt;/code&gt; of an asynchronous task.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2f260e119bb2a2221aaead7149c78bb8d75b87a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait allows you to duplicate a value by only copying bits stored on the stack; no arbitrary code is necessary. See the &lt;a href=&quot;ch04-01-what-is-ownership#stack-only-data-copy&quot;&gt;&amp;ldquo;Stack-Only Data: Copy&amp;rdquo;&lt;/a&gt; section in Chapter 4 for more information on &lt;code&gt;Copy&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6af89e2c9cf5d947b4b736850c9a97076811fab2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait doesn&amp;rsquo;t define any methods to prevent programmers from overloading those methods and violating the assumption that no arbitrary code is being run. That way, all programmers can assume that copying a value will be very fast.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c62b63ef24786f929500cd4f0e354183f51728d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Copy&lt;/code&gt; trait is rarely required; types that implement &lt;code&gt;Copy&lt;/code&gt; have optimizations available, meaning you don&amp;rsquo;t have to call &lt;code&gt;clone&lt;/code&gt;, which makes the code more concise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a2c2f0333db2747594fc8c5736d8f8e947ab10e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Counter&lt;/code&gt; struct has one field named &lt;code&gt;count&lt;/code&gt;. This field holds a &lt;code&gt;u32&lt;/code&gt; value that will keep track of where we are in the process of iterating from 1 to 5. The &lt;code&gt;count&lt;/code&gt; field is private because we want the implementation of &lt;code&gt;Counter&lt;/code&gt; to manage its value. The &lt;code&gt;new&lt;/code&gt; function enforces the behavior of always starting new instances with a value of 0 in the &lt;code&gt;count&lt;/code&gt; field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e402bbce82e84dd539cf1e138daa2856a0613786" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Debug&lt;/code&gt; trait allows you to print instances of a type for debugging purposes, so you and other programmers using your type can inspect an instance at a particular point in a program&amp;rsquo;s execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="853b42f22ba0be46a6e5cd03ba34756814292e76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Debug&lt;/code&gt; trait enables debug formatting in format strings, which you indicate by adding &lt;code&gt;:?&lt;/code&gt; within &lt;code&gt;{}&lt;/code&gt; placeholders.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6967ae462b0a2a18036d993e8418edd4a969bd40" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Debug&lt;/code&gt; trait is required, for example, in use of the &lt;code&gt;assert_eq!&lt;/code&gt; macro. This macro prints the values of instances given as arguments if the equality assertion fails so programmers can see why the two instances weren&amp;rsquo;t equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aba43f90e22e0dfd98100913cb543e02752ca675" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default::default&lt;/code&gt; function is commonly used in combination with the struct update syntax discussed in the &lt;a href=&quot;ch05-01-defining-structs#creating-instances-from-other-instances-with-struct-update-syntax&quot;&gt;&amp;ldquo;Creating Instances From Other Instances With Struct Update Syntax&amp;rdquo;&lt;/a&gt; section in Chapter 5. You can customize a few fields of a struct and then set and use a default value for the rest of the fields by using &lt;code&gt;..Default::default()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="155c03f436324748d5a47629042098342e63a6ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait allows you to create a default value for a type. Deriving &lt;code&gt;Default&lt;/code&gt; implements the &lt;code&gt;default&lt;/code&gt; function. The derived implementation of the &lt;code&gt;default&lt;/code&gt; function calls the &lt;code&gt;default&lt;/code&gt; function on each part of the type, meaning all fields or values in the type must also implement &lt;code&gt;Default&lt;/code&gt; to derive &lt;code&gt;Default&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="417d240e17ea189069372338520fb02d077b097b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait for types which may have meaningful default values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9ffe8630d56067e177ef382279c1fa4ad4f3ea3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Default&lt;/code&gt; trait is required when you use the method &lt;code&gt;unwrap_or_default&lt;/code&gt; on &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; instances, for example. If the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, the method &lt;code&gt;unwrap_or_default&lt;/code&gt; will return the result of &lt;code&gt;Default::default&lt;/code&gt; for the type &lt;code&gt;T&lt;/code&gt; stored in the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bac5d0a36fa049d2b9d797796c56dde34fe6945" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DispatchFromDyn&lt;/code&gt; trait currently can only be implemented for builtin pointer types and structs that are newtype wrappers around them &amp;mdash; that is, the struct must have only one field (except for&lt;code&gt;PhantomData&lt;/code&gt;), and that field must itself implement &lt;code&gt;DispatchFromDyn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6986e696b5a0b081bb4012a05eb9e1b65dcc35b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DraftPost&lt;/code&gt; struct has an &lt;code&gt;add_text&lt;/code&gt; method, so we can add text to &lt;code&gt;content&lt;/code&gt; as before, but note that &lt;code&gt;DraftPost&lt;/code&gt; does not have a &lt;code&gt;content&lt;/code&gt; method defined! So now the program ensures all posts start as draft posts, and draft posts don&amp;rsquo;t have their content available for display. Any attempt to get around these constraints will result in a compiler error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1de117663cb2f27f8306ea33629038001aac2df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Drop&lt;/code&gt; trait is included in the prelude, so we don&amp;rsquo;t need to bring it into scope. We implement the &lt;code&gt;Drop&lt;/code&gt; trait on &lt;code&gt;CustomSmartPointer&lt;/code&gt; and provide an implementation for the &lt;code&gt;drop&lt;/code&gt; method that calls &lt;code&gt;println!&lt;/code&gt;. The body of the &lt;code&gt;drop&lt;/code&gt; function is where you would place any logic that you wanted to run when an instance of your type goes out of scope. We&amp;rsquo;re printing some text here to demonstrate when Rust will call &lt;code&gt;drop&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a67a7efec93a37792cb31993e146b2f7a5f7bc09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Eq&lt;/code&gt; trait has no methods. Its purpose is to signal that for every value of the annotated type, the value is equal to itself. The &lt;code&gt;Eq&lt;/code&gt; trait can only be applied to types that also implement &lt;code&gt;PartialEq&lt;/code&gt;, although not all types that implement &lt;code&gt;PartialEq&lt;/code&gt; can implement &lt;code&gt;Eq&lt;/code&gt;. One example of this is floating point number types: the implementation of floating point numbers states that two instances of the not-a-number (&lt;code&gt;NaN&lt;/code&gt;) value are not equal to each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="339e508d8f9f4467a3c3de396b4c7c19141c661f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;F&lt;/code&gt; type parameter also has the trait bound &lt;code&gt;Send&lt;/code&gt; and the lifetime bound &lt;code&gt;'static&lt;/code&gt;, which are useful in our situation: we need &lt;code&gt;Send&lt;/code&gt; to transfer the closure from one thread to another and &lt;code&gt;'static&lt;/code&gt; because we don&amp;rsquo;t know how long the thread will take to execute. Let&amp;rsquo;s create an &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt; that will take a generic parameter of type &lt;code&gt;F&lt;/code&gt; with these bounds:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44f286163600e21778b5e8ddc538f3f66c2c5215" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;F&lt;/code&gt; type parameter is the one we&amp;rsquo;re concerned with here; the &lt;code&gt;T&lt;/code&gt; type parameter is related to the return value, and we&amp;rsquo;re not concerned with that. We can see that &lt;code&gt;spawn&lt;/code&gt; uses &lt;code&gt;FnOnce&lt;/code&gt; as the trait bound on &lt;code&gt;F&lt;/code&gt;. This is probably what we want as well, because we&amp;rsquo;ll eventually pass the argument we get in &lt;code&gt;execute&lt;/code&gt; to &lt;code&gt;spawn&lt;/code&gt;. We can be further confident that &lt;code&gt;FnOnce&lt;/code&gt; is the trait we want to use because the thread for running a request will only execute that request&amp;rsquo;s closure one time, which matches the &lt;code&gt;Once&lt;/code&gt; in &lt;code&gt;FnOnce&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cc0c55739bb91f91d10f706c9cab70e100723e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Fn&lt;/code&gt; traits are provided by the standard library. All closures implement at least one of the traits: &lt;code&gt;Fn&lt;/code&gt;, &lt;code&gt;FnMut&lt;/code&gt;, or &lt;code&gt;FnOnce&lt;/code&gt;. We&amp;rsquo;ll discuss the difference between these traits in the &lt;a href=&quot;#capturing-the-environment-with-closures&quot;&gt;&amp;ldquo;Capturing the Environment with Closures&amp;rdquo;&lt;/a&gt; section; in this example, we can use the &lt;code&gt;Fn&lt;/code&gt; trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="851722264534e1910cdc1ef4f424b4a4414f9688" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;From&lt;/code&gt; is also very useful when performing error handling. When constructing a function that is capable of failing, the return type will generally be of the form &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;. The &lt;code&gt;From&lt;/code&gt; trait simplifies error handling by allowing a function to return a single error type that encapsulate multiple error types. See the &quot;Examples&quot; section and &lt;a href=&quot;../../book/ch09-00-error-handling&quot;&gt;the book&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="924c96483cec1214b829647e918270a4c12cbe49" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GeneratorState&lt;/code&gt; enum returned from this function indicates what state the generator is in upon returning. If the &lt;code&gt;Yielded&lt;/code&gt; variant is returned then the generator has reached a suspension point and a value has been yielded out. Generators in this state are available for resumption at a later point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93144a0b07feb0dfc814fce370a7ec1878fc8518" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GlobalAlloc&lt;/code&gt; trait is an &lt;code&gt;unsafe&lt;/code&gt; trait for a number of reasons, and implementors must ensure that they adhere to these contracts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac746bf118e800d6204d1b9be35a781fccfa8fc0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Hash&lt;/code&gt; trait allows you to take an instance of a type of arbitrary size and map that instance to a value of fixed size using a hash function. Deriving &lt;code&gt;Hash&lt;/code&gt; implements the &lt;code&gt;hash&lt;/code&gt; method. The derived implementation of the &lt;code&gt;hash&lt;/code&gt; method combines the result of calling &lt;code&gt;hash&lt;/code&gt; on each of the parts of the type, meaning all fields or values must also implement &lt;code&gt;Hash&lt;/code&gt; to derive &lt;code&gt;Hash&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc2c322c74118357f702bcbb43acd3519194cb4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Iterator&lt;/code&gt; trait has a number of different methods with default implementations provided by the standard library; you can find out about these methods by looking in the standard library API documentation for the &lt;code&gt;Iterator&lt;/code&gt; trait. Some of these methods call the &lt;code&gt;next&lt;/code&gt; method in their definition, which is why you&amp;rsquo;re required to implement the &lt;code&gt;next&lt;/code&gt; method when implementing the &lt;code&gt;Iterator&lt;/code&gt; trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7674b68a4f6af8a05d48508e05e8b51cf5d1646" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Iterator&lt;/code&gt; trait only requires implementors to define one method: the &lt;code&gt;next&lt;/code&gt; method, which returns one item of the iterator at a time wrapped in &lt;code&gt;Some&lt;/code&gt; and, when iteration is over, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9025083930c31cf7871ed20937306b52f26761a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LinkedList&lt;/code&gt; allows pushing and popping elements at either end in constant time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4baf38aed9bf1ffe36a931bbfb0cb77e6aa0a43b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LowerExp&lt;/code&gt; trait should format its output in scientific notation with a lower-case &lt;code&gt;e&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc66d9062a365376bc4e9ff4cb202550c7cc32a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LowerHex&lt;/code&gt; trait should format its output as a number in hexadecimal, with &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt; in lower case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b321c2a56af633f328bf4b8ba254ce361d7a954" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Octal&lt;/code&gt; trait should format its output as a number in base-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb10a578affd8a62e12f3ef265b344e167e3dcf6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum is so useful that it&amp;rsquo;s even included in the prelude; you don&amp;rsquo;t need to bring it into scope explicitly. In addition, so are its variants: you can use &lt;code&gt;Some&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; directly without the &lt;code&gt;Option::&lt;/code&gt; prefix. The &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum is still just a regular enum, and &lt;code&gt;Some(T)&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; are still variants of type &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="757a8b38147115f7267a95ffaa6fac00dcad6a55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Option&lt;/code&gt; type. See &lt;a href=&quot;index&quot;&gt;the module level documentation&lt;/a&gt; for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ec87aec96d36200bb49beb7ba67c5c626bb7aad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ord&lt;/code&gt; trait allows you to know that for any two values of the annotated type, a valid ordering will exist. The &lt;code&gt;Ord&lt;/code&gt; trait implements the &lt;code&gt;cmp&lt;/code&gt; method, which returns an &lt;code&gt;Ordering&lt;/code&gt; rather than an &lt;code&gt;Option&amp;lt;Ordering&amp;gt;&lt;/code&gt; because a valid ordering will always be possible. You can only apply the &lt;code&gt;Ord&lt;/code&gt; trait to types that also implement &lt;code&gt;PartialOrd&lt;/code&gt; and &lt;code&gt;Eq&lt;/code&gt; (and &lt;code&gt;Eq&lt;/code&gt; requires &lt;code&gt;PartialEq&lt;/code&gt;). When derived on structs and enums, &lt;code&gt;cmp&lt;/code&gt; behaves the same way as the derived implementation for &lt;code&gt;partial_cmp&lt;/code&gt; does with &lt;code&gt;PartialOrd&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="711a8eb9ad73721345ff8b7d5d49057eb05ba2c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Orphan Check&lt;/code&gt; states that every trait implementation must meet either of the following conditions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c00d178bf6b2317cc12ea4871792b476ee2d6ac7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialEq&lt;/code&gt; trait allows you to compare instances of a type to check for equality and enables use of the &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43e89dc3eb492904f3da074b02b2cf97b105430c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialEq&lt;/code&gt; trait is required, for example, with the use of the &lt;code&gt;assert_eq!&lt;/code&gt; macro, which needs to be able to compare two instances of a type for equality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3b5763e3772b503d126748c966660daf7b02e86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialOrd&lt;/code&gt; trait allows you to compare instances of a type for sorting purposes. A type that implements &lt;code&gt;PartialOrd&lt;/code&gt; can be used with the &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;=&lt;/code&gt; operators. You can only apply the &lt;code&gt;PartialOrd&lt;/code&gt; trait to types that also implement &lt;code&gt;PartialEq&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d44604638bc3e14fe0790aae9645322a35831c38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PartialOrd&lt;/code&gt; trait is required, for example, for the &lt;code&gt;gen_range&lt;/code&gt; method from the &lt;code&gt;rand&lt;/code&gt; crate that generates a random value in the range specified by a low value and a high value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa9b33d349ddf99a4aba8a405103bf7fb4c6e253" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pointer&lt;/code&gt; trait should format its output as a memory location. This is commonly presented as hexadecimal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab8bbad2b08fc48ec0e5ed2730d22da62501a267" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Range&lt;/code&gt;&lt;code&gt;start..end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;gt;= start&lt;/code&gt; and &lt;code&gt;x &amp;lt; end&lt;/code&gt;. It is empty unless &lt;code&gt;start &amp;lt; end&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2aa0761be84214baf72bdc665e4aaa54d88ab96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeFrom&lt;/code&gt;&lt;code&gt;start..&lt;/code&gt; contains all values with &lt;code&gt;x &amp;gt;= start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73c149dd90366bce823890f694cf867f1bb0a225" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeInclusive&lt;/code&gt;&lt;code&gt;start..=end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;gt;= start&lt;/code&gt; and &lt;code&gt;x &amp;lt;= end&lt;/code&gt;. It is empty unless &lt;code&gt;start &amp;lt;= end&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cec61b7c44a745e689ab10fff029089cd54c5d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeTo&lt;/code&gt;&lt;code&gt;..end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt; end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e2d4326e8450b1f620c09e80702de680708776b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RangeToInclusive&lt;/code&gt;&lt;code&gt;..=end&lt;/code&gt; contains all values with &lt;code&gt;x &amp;lt;= end&lt;/code&gt;. It cannot serve as an &lt;a href=&quot;../iter/trait.intoiterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; because it doesn't have a starting point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebdc80637c460a3fe51040149db057ee546f653a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Rc::clone(&amp;amp;from)&lt;/code&gt; syntax is the most idiomatic because it conveys more explicitly the meaning of the code. In the example above, this syntax makes it easier to see that this code is creating a new reference rather than copying the whole content of foo.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18566a4555f118c35b2f7296c41294a80e62f05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Read&lt;/code&gt; trait allows for reading bytes from a source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="167de79249a0cb690644cc2f30f26fd674ac84c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; keeps track of how many &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; smart pointers are currently active. Every time we call &lt;code&gt;borrow&lt;/code&gt;, the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; increases its count of how many immutable borrows are active. When a &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; value goes out of scope, the count of immutable borrows goes down by one. Just like the compile-time borrowing rules, &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; lets us have many immutable borrows or one mutable borrow at any point in time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e6771afd6b14e03fc38f6d16106ee1f97bd4cbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RefCell&lt;/code&gt; is already immutably borrowed, so this cannot fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c305974ea6149ae71e2c43fcd219e993594dd96e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RefCell&lt;/code&gt; is already mutably borrowed, so this cannot fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52b1edfc20b8e3433cc429a2a34dab08626e2ce2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Result&amp;lt;..., Error&amp;gt;&lt;/code&gt; is repeated a lot. As such, &lt;code&gt;std::io&lt;/code&gt; has this type of alias declaration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e71572578c618ddeccc701e84d14574b4552896" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Result&lt;/code&gt; enum is generic over two types, &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt;, and has two variants: &lt;code&gt;Ok&lt;/code&gt;, which holds a value of type &lt;code&gt;T&lt;/code&gt;, and &lt;code&gt;Err&lt;/code&gt;, which holds a value of type &lt;code&gt;E&lt;/code&gt;. This definition makes it convenient to use the &lt;code&gt;Result&lt;/code&gt; enum anywhere we have an operation that might succeed (return a value of some type &lt;code&gt;T&lt;/code&gt;) or fail (return an error of some type &lt;code&gt;E&lt;/code&gt;). In fact, this is what we used to open a file in Listing 9-3, where &lt;code&gt;T&lt;/code&gt; was filled in with the type &lt;code&gt;std::fs::File&lt;/code&gt; when the file was opened successfully and &lt;code&gt;E&lt;/code&gt; was filled in with the type &lt;code&gt;std::io::Error&lt;/code&gt; when there were problems opening the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67d17ec2155cc71f4cbd159b4631b04d17855080" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Result&lt;/code&gt; types are &lt;a href=&quot;ch06-00-enums&quot;&gt;&lt;em&gt;enumerations&lt;/em&gt;&lt;/a&gt;, often referred to as &lt;em&gt;enums&lt;/em&gt;. An enumeration is a type that can have a fixed set of values, and those values are called the enum&amp;rsquo;s &lt;em&gt;variants&lt;/em&gt;. Chapter 6 will cover enums in more detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64d4c779a9a53da0609d26369514238e751f0a8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Seek&lt;/code&gt; trait provides a cursor which can be moved within a stream of bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45132395a8da1a9af17f15db9b29d073d0c74c5d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; keyword is an alias for the type we&amp;rsquo;re implementing the traits or methods on. Trait objects must be object safe because once you&amp;rsquo;ve used a trait object, Rust no longer knows the concrete type that&amp;rsquo;s implementing that trait. If a trait method returns the concrete &lt;code&gt;Self&lt;/code&gt; type, but a trait object forgets the exact type that &lt;code&gt;Self&lt;/code&gt; is, there is no way the method can use the original concrete type. The same is true of generic type parameters that are filled in with concrete type parameters when the trait is used: the concrete types become part of the type that implements the trait. When the type is forgotten through the use of a trait object, there is no way to know what types to fill in the generic type parameters with.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90a76b71efb75f391d26231783f81feb6c797a7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; keyword represents the current type, which explains why it can only be used inside an impl, trait, or type definition. It gives access to the associated items of a type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a02332e854d71300403fa93482ff8605d97eadb6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; keyword was used outside an impl, trait, or type definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a3c6ecd1deb9539342b4b667c8f7da5207114d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Self&lt;/code&gt; term can be replaced with the type being implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d50619fe26b234beecf764a55ec164440b77b3f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Send&lt;/code&gt; marker trait indicates that ownership of the type implementing &lt;code&gt;Send&lt;/code&gt; can be transferred between threads. Almost every Rust type is &lt;code&gt;Send&lt;/code&gt;, but there are some exceptions, including &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;: this cannot be &lt;code&gt;Send&lt;/code&gt; because if you cloned an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value and tried to transfer ownership of the clone to another thread, both threads might update the reference count at the same time. For this reason, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is implemented for use in single-threaded situations where you don&amp;rsquo;t want to pay the thread-safe performance penalty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da7504f8cf4ba12a9f166abe295fe49d0cc29f7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sized&lt;/code&gt; trait is a special trait built-in to the compiler for types with a constant size known at compile-time. This trait is automatically implemented for types as needed by the compiler, and it is currently disallowed to explicitly implement it for a type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57ed07b6ec3a8248f3dbedbfe819f564dab9a89c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Some(5)&lt;/code&gt; value doesn&amp;rsquo;t match the pattern &lt;code&gt;None&lt;/code&gt;, so we continue to the next arm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cf7d1bcd1b02d8684f384aeb150bd3c1fada36f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;State&lt;/code&gt; trait defines the behavior shared by different post states, and the &lt;code&gt;Draft&lt;/code&gt;, &lt;code&gt;PendingReview&lt;/code&gt;, and &lt;code&gt;Published&lt;/code&gt; states will all implement the &lt;code&gt;State&lt;/code&gt; trait. For now, the trait doesn&amp;rsquo;t have any methods, and we&amp;rsquo;ll start by defining just the &lt;code&gt;Draft&lt;/code&gt; state because that is the state we want a post to start in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a99c80ac2ff235e2978574f670cbd4660bb61703" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type implements the &lt;code&gt;Clone&lt;/code&gt; trait, and when we call the &lt;code&gt;clone&lt;/code&gt; method on an instance of &lt;code&gt;String&lt;/code&gt; we get back an instance of &lt;code&gt;String&lt;/code&gt;. Similarly, if we call &lt;code&gt;clone&lt;/code&gt; on an instance of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, we get back an instance of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. The signature of &lt;code&gt;clone&lt;/code&gt; needs to know what type will stand in for &lt;code&gt;Self&lt;/code&gt;, because that&amp;rsquo;s the return type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce3a0f98cdb5c97fe7ff53bab286ef96b0a0614f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type is the most common string type that has ownership over the contents of the string. It has a close relationship with its borrowed counterpart, the primitive &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75cb7ba1e6deab5f4a0c4ef1dddcb7ea6d8d2520" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type, which is provided by Rust&amp;rsquo;s standard library rather than coded into the core language, is a growable, mutable, owned, UTF-8 encoded string type. When Rustaceans refer to &amp;ldquo;strings&amp;rdquo; in Rust, they usually mean the &lt;code&gt;String&lt;/code&gt; and the string slice &lt;code&gt;&amp;amp;str&lt;/code&gt; types, not just one of those types. Although this section is largely about &lt;code&gt;String&lt;/code&gt;, both types are used heavily in Rust&amp;rsquo;s standard library, and both &lt;code&gt;String&lt;/code&gt; and string slices are UTF-8 encoded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2f29f1c300ba36b21c6a01062d991f47ee83fd6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt; traits, which extend Rust&amp;rsquo;s concurrency guarantees to user-defined types as well as types provided by the standard library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="546dfd59f5dde2a2d3bad5396a6d76cbe9696aee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sync&lt;/code&gt; marker trait indicates that it is safe for the type implementing &lt;code&gt;Sync&lt;/code&gt; to be referenced from multiple threads. In other words, any type &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; if &lt;code&gt;&amp;amp;T&lt;/code&gt; (a reference to &lt;code&gt;T&lt;/code&gt;) is &lt;code&gt;Send&lt;/code&gt;, meaning the reference can be sent safely to another thread. Similar to &lt;code&gt;Send&lt;/code&gt;, primitive types are &lt;code&gt;Sync&lt;/code&gt;, and types composed entirely of types that are &lt;code&gt;Sync&lt;/code&gt; are also &lt;code&gt;Sync&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="646e9a46a3198e5aae6cea0647712ac157d7125f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt; are generic type parameters: we&amp;rsquo;ll discuss generics in more detail in Chapter 10. What you need to know right now is that &lt;code&gt;T&lt;/code&gt; represents the type of the value that will be returned in a success case within the &lt;code&gt;Ok&lt;/code&gt; variant, and &lt;code&gt;E&lt;/code&gt; represents the type of the error that will be returned in a failure case within the &lt;code&gt;Err&lt;/code&gt; variant. Because &lt;code&gt;Result&lt;/code&gt; has these generic type parameters, we can use the &lt;code&gt;Result&lt;/code&gt; type and the functions that the standard library has defined on it in many different situations where the successful value and error value we want to return may differ.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb756122c49feafba4692e36792c9ec503818ac1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Thread&lt;/code&gt; type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fadb7c71117e778367444a0d18f0442e8249124b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ThreadPool&lt;/code&gt; will create a channel and hold on to the sending side of the channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a5cd0207b32d758dbbf9a6159c66155c77acce0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UnsafeCell&lt;/code&gt; API itself is technically very simple: it gives you a raw pointer &lt;code&gt;*mut T&lt;/code&gt; to its contents. It is up to &lt;em&gt;you&lt;/em&gt; as the abstraction designer to use that raw pointer correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a41c6aadefabb63fa74ac6fccd4136ec47ca08f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UpperExp&lt;/code&gt; trait should format its output in scientific notation with an upper-case &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c532f0150ba601cb070b0fc006c6b873d809aeda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UpperHex&lt;/code&gt; trait should format its output as a number in hexadecimal, with &lt;code&gt;A&lt;/code&gt; through &lt;code&gt;F&lt;/code&gt; in upper case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1692dc51a2dd0859a66b3a15d1e8df4859265ffa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vec&lt;/code&gt; type allows to access values by index, because it implements the &lt;a href=&quot;../ops/trait.index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; trait. An example will be more explicit:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdf15f1d79f5be8a81ff6d7d469c446ffbe09215" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_&lt;/code&gt; pattern will match any value. By putting it after our other arms, the &lt;code&gt;_&lt;/code&gt; will match all the possible cases that aren&amp;rsquo;t specified before it. The &lt;code&gt;()&lt;/code&gt; is just the unit value, so nothing will happen in the &lt;code&gt;_&lt;/code&gt; case. As a result, we can say that we want to do nothing for all the possible values that we don&amp;rsquo;t list before the &lt;code&gt;_&lt;/code&gt; placeholder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4f623218e4e907b6db896a6ba8ba2e0737f6051" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;abort&lt;/code&gt; function terminates the process, so the destructor will not get run on the example below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1da31d2d7b88dbadae1ea02224cc02bf279c6b4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;add&lt;/code&gt; method adds the &lt;code&gt;x&lt;/code&gt; values of two &lt;code&gt;Point&lt;/code&gt; instances and the &lt;code&gt;y&lt;/code&gt; values of two &lt;code&gt;Point&lt;/code&gt; instances to create a new &lt;code&gt;Point&lt;/code&gt;. The &lt;code&gt;Add&lt;/code&gt; trait has an associated type named &lt;code&gt;Output&lt;/code&gt; that determines the type returned from the &lt;code&gt;add&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b4f66cfe4d8578da648c05ce2a1d295046eb19d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;add_text&lt;/code&gt; method takes a mutable reference to &lt;code&gt;self&lt;/code&gt;, because we&amp;rsquo;re changing the &lt;code&gt;Post&lt;/code&gt; instance that we&amp;rsquo;re calling &lt;code&gt;add_text&lt;/code&gt; on. We then call &lt;code&gt;push_str&lt;/code&gt; on the &lt;code&gt;String&lt;/code&gt; in &lt;code&gt;content&lt;/code&gt; and pass the &lt;code&gt;text&lt;/code&gt; argument to add to the saved &lt;code&gt;content&lt;/code&gt;. This behavior doesn&amp;rsquo;t depend on the state the post is in, so it&amp;rsquo;s not part of the state pattern. The &lt;code&gt;add_text&lt;/code&gt; method doesn&amp;rsquo;t interact with the &lt;code&gt;state&lt;/code&gt; field at all, but it is part of the behavior we want to support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c3ad15ad6826ff34548cd3374a6a4eed3efc204" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers can be used to respectively raise or lower the alignment of &lt;code&gt;struct&lt;/code&gt;s and &lt;code&gt;union&lt;/code&gt;s. &lt;code&gt;packed&lt;/code&gt; may also alter the padding between fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba365c1b081658cee386344e9e2a04962a51bb04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers cannot be applied on the same type and a &lt;code&gt;packed&lt;/code&gt; type cannot transitively contain another &lt;code&gt;align&lt;/code&gt;ed type. &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; may only be applied to the &lt;a href=&quot;type-layout#the-default-representation&quot;&gt;default&lt;/a&gt; and &lt;a href=&quot;type-layout#the-c-representation&quot;&gt;&lt;code&gt;C&lt;/code&gt;&lt;/a&gt; representations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53e65577e1cfa4684ae0b49bee71e8da03a67fa1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; modifier can also be applied on an &lt;code&gt;enum&lt;/code&gt;. When it is, the effect on the &lt;code&gt;enum&lt;/code&gt;'s alignment is the same as if the &lt;code&gt;enum&lt;/code&gt; was wrapped in a newtype &lt;code&gt;struct&lt;/code&gt; with the same &lt;code&gt;align&lt;/code&gt; modifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ad8df46a380899eaf26791f29aae33e2b0b76bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amt&lt;/code&gt; must be &lt;code&gt;&amp;lt;=&lt;/code&gt; the number of bytes in the buffer returned by &lt;a href=&quot;#tymethod.fill_buf&quot;&gt;&lt;code&gt;fill_buf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45b714d09b6da61ea117e3601d5d1e5fd89a8774" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;approve&lt;/code&gt; method will be similar to the &lt;code&gt;request_review&lt;/code&gt; method: it will set &lt;code&gt;state&lt;/code&gt; to the value that the current state says it should have when that state is approved, as shown in Listing 17-16:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d99e2697c98f4ee00d53c8602d75f85424ebe1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;area&lt;/code&gt; function accesses the &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; fields of the &lt;code&gt;Rectangle&lt;/code&gt; instance. Our function signature for &lt;code&gt;area&lt;/code&gt; now says exactly what we mean: calculate the area of &lt;code&gt;Rectangle&lt;/code&gt;, using its &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; fields. This conveys that the width and height are related to each other, and it gives descriptive names to the values rather than using the tuple index values of &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;. This is a win for clarity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0f4d5c245d843fc107cb0d995f1cc0cbaafe380" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;area&lt;/code&gt; function is supposed to calculate the area of one rectangle, but the function we wrote has two parameters. The parameters are related, but that&amp;rsquo;s not expressed anywhere in our program. It would be more readable and more manageable to group width and height together. We&amp;rsquo;ve already discussed one way we might do that in &lt;a href=&quot;ch03-02-data-types#the-tuple-type&quot;&gt;&amp;ldquo;The Tuple Type&amp;rdquo;&lt;/a&gt; section of Chapter 3: by using tuples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03663b761515431ad66c10f38033078682c6e595" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;art&lt;/code&gt; crate users can still see and use the internal structure from Listing 14-3 as demonstrated in Listing 14-4, or they can use the more convenient structure in Listing 14-5, as shown in Listing 14-6:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e825da57c4a60047ea61533b7c1bd5bca8251591" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt; keyword can be used to change what the crate is referred to as in your project. If a crate name includes a dash, it is implicitly imported with the dashes replaced by underscores.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dd2463e89570fe4f3bb6f6203a6c56b03267f94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;assert!&lt;/code&gt; macro, provided by the standard library, is useful when you want to ensure that some condition in a test evaluates to &lt;code&gt;true&lt;/code&gt;. We give the &lt;code&gt;assert!&lt;/code&gt; macro an argument that evaluates to a Boolean. If the value is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;assert!&lt;/code&gt; does nothing and the test passes. If the value is &lt;code&gt;false&lt;/code&gt;, the &lt;code&gt;assert!&lt;/code&gt; macro calls the &lt;code&gt;panic!&lt;/code&gt; macro, which causes the test to fail. Using the &lt;code&gt;assert!&lt;/code&gt; macro helps us check that our code is functioning in the way we intend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95f1355f51c209910ea66191ec2fc57f92344bfc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;assert_ne!&lt;/code&gt; macro will pass if the two values we give it are not equal and fail if they&amp;rsquo;re equal. This macro is most useful for cases when we&amp;rsquo;re not sure what a value &lt;em&gt;will&lt;/em&gt; be, but we know what the value definitely &lt;em&gt;won&amp;rsquo;t&lt;/em&gt; be if our code is functioning as we intend. For example, if we&amp;rsquo;re testing a function that is guaranteed to change its input in some way, but the way in which the input is changed depends on the day of the week that we run our tests, the best thing to assert might be that the output of the function is not equal to the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf35e012d7004404479ddec49cb6abc4ee90bc1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&lt;/code&gt; function in this scenario works like the &lt;code&gt;new&lt;/code&gt; function in that it will return a new &lt;code&gt;TcpListener&lt;/code&gt; instance. The reason the function is called &lt;code&gt;bind&lt;/code&gt; is that in networking, connecting to a port to listen to is known as &amp;ldquo;binding to a port.&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a9db4154e7cfc914c7af74a70f78787dc149e27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&lt;/code&gt; function returns a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, which indicates that binding might fail. For example, connecting to port 80 requires administrator privileges (nonadministrators can listen only on ports higher than 1024), so if we tried to connect to port 80 without being an administrator, binding wouldn&amp;rsquo;t work. As another example, binding wouldn&amp;rsquo;t work if we ran two instances of our program and so had two programs listening to the same port. Because we&amp;rsquo;re writing a basic server just for learning purposes, we won&amp;rsquo;t worry about handling these kinds of errors; instead, we use &lt;code&gt;unwrap&lt;/code&gt; to stop the program if errors happen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86e869ec27553a2645d530ee9b57e980ad085326" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool&lt;/code&gt; represents a value, which could only be either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. If you cast a &lt;code&gt;bool&lt;/code&gt; into an integer, &lt;code&gt;true&lt;/code&gt; will be 1 and &lt;code&gt;false&lt;/code&gt; will be 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4311662fb8a13303491e364af26bcbe8200bef8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool&lt;/code&gt; type is a datatype which can be either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. The boolean type uses one byte of memory. It is used in comparisons and bitwise operations like &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, and &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71b45beaeed4f4e8bb8cb42d1eee7255c7dfda23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;break&lt;/code&gt; statement can take an argument (which will be the value of the loop expression if the &lt;code&gt;break&lt;/code&gt; statement is executed) in &lt;code&gt;loop&lt;/code&gt; loops, but not &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, or &lt;code&gt;while let&lt;/code&gt; loops.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4fc4821431bbe2f5d7ca950ef58b031fb001379" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bytes&lt;/code&gt; method returns each raw byte, which might be appropriate for your domain:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c67d48bb9bf16df95a3dc50a92dbdfe313c2a09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;can_hold&lt;/code&gt; method returns a Boolean, which means it&amp;rsquo;s a perfect use case for the &lt;code&gt;assert!&lt;/code&gt; macro. In Listing 11-6, we write a test that exercises the &lt;code&gt;can_hold&lt;/code&gt; method by creating a &lt;code&gt;Rectangle&lt;/code&gt; instance that has a width of 8 and a height of 7 and asserting that it can hold another &lt;code&gt;Rectangle&lt;/code&gt; instance that has a width of 5 and a height of 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a25b55443c783de850a8f716e7e98dd68745de2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cargo install&lt;/code&gt; command allows you to install and use binary crates locally. This isn&amp;rsquo;t intended to replace system packages; it&amp;rsquo;s meant to be a convenient way for Rust developers to install tools that others have shared on &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;. Note that you can only install packages that have binary targets. A &lt;em&gt;binary target&lt;/em&gt; is the runnable program that is created if the crate has a &lt;em&gt;src/main.rs&lt;/em&gt; file or another file specified as a binary, as opposed to a library target that isn&amp;rsquo;t runnable on its own but is suitable for including within other programs. Usually, crates have information in the &lt;em&gt;README&lt;/em&gt; file about whether a crate is a library, has a binary target, or both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2664dcbe5273c6722a5b153d876b9b792f2ada2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cargo test&lt;/code&gt; command runs all tests in our project, as shown in Listing 11-2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="375baaee400dee61b2707b887bd9af56fe2bc128" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c6c79dbe0366f164760e8fbd149ca95e0429eec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; attribute is allowed anywhere attributes are allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1be4a466f7709a98c138b8664fae5693d56dd2b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; attribute supports only three kinds of predicates:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28422790bd7081a79bb025fb9d66e378219a525d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt; macro</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fde18a15c12045ccc5f862ad4d07ffff9bb790a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; conditionally includes the thing it is attached to based on a configuration predicate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2223835f7d8034d74bbb5846af6ec97de49a67f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg_attr&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76546526e7489be649c0d74ada78ee80e5e85965" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg_attr&lt;/code&gt; attribute is allowed anywhere attributes are allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="548a83f876de36acae9e81967a808fe451cf7938" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cfg_attr&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; conditionally includes &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt; based on a configuration predicate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85a19bbf37eb56f0525c8c2436505adedd691250" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;char&lt;/code&gt; type represents a single character. More specifically, since 'character' isn't a well-defined concept in Unicode, &lt;code&gt;char&lt;/code&gt; is a '&lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt;', which is similar to, but not the same as, a '&lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;Unicode code point&lt;/a&gt;'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b73bedd4705331ddde92b218ee42ae14fd783b1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cold&lt;/code&gt; and &lt;code&gt;inline&lt;/code&gt;&lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; give suggestions to generate code in a way that may be faster than what it would do without the hint. The attributes are only hints, and may be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e443e8933fc7022a9fff52a5391c70d8fc736a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cold&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c647cbb39e778e9b3fee3b9f221a846f5e10198a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; keyword is also used in raw pointers in combination with &lt;code&gt;mut&lt;/code&gt;, as seen in &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;. More about that can be read at the &lt;a href=&quot;primitive.pointer&quot;&gt;pointer&lt;/a&gt; primitive part of the Rust docs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90ef70a34f1bf7aa0febc79627f67bbce0e1d9d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;core&lt;/code&gt; crate is always added to the extern prelude. The &lt;code&gt;std&lt;/code&gt; crate is added as long as the &lt;a href=&quot;../crates-and-source-files#preludes-and-no_std&quot;&gt;&lt;code&gt;no_std&lt;/code&gt;&lt;/a&gt; attribute is not specified in the crate root.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38acae0d6ab176e191a45e1f1b54faccd4c7f448" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crate_name&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef2c8badee302cb0baefa21db745a07eb79b3acf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; pointer can be used to store arbitrary data as required by the executor. This could be e.g. a type-erased pointer to an &lt;code&gt;Arc&lt;/code&gt; that is associated with the task. The value of this poiner will get passed to all functions that are part of the &lt;code&gt;vtable&lt;/code&gt; as the first parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7af61314557c2255ce30f13387bf574343b8476" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg!(..)&lt;/code&gt; macro moves the input:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7a4dd4c094bb75a82ed633489f0ec96c82a6296" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dbg!&lt;/code&gt; macro works exactly the same in release builds. This is useful when debugging issues that only occur in release builds or when debugging in release mode is significantly faster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a03c825d089a243f66f60fd9869adfb4b5c6857" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c348bd3f38f8d7b286030ed2d1f972d4a02706b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute has several forms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1d23eb4050e4bb4bd6008dd3e0216cd81ba2cd1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute may be applied to any &lt;a href=&quot;../items&quot;&gt;item&lt;/a&gt;, &lt;a href=&quot;../items/traits&quot;&gt;trait item&lt;/a&gt;, &lt;a href=&quot;../items/enumerations&quot;&gt;enum variant&lt;/a&gt;, &lt;a href=&quot;../items/structs&quot;&gt;struct field&lt;/a&gt;, or &lt;a href=&quot;../items/external-blocks&quot;&gt;external block item&lt;/a&gt;. It cannot be applied to &lt;a href=&quot;../items/implementations#trait-implementations&quot;&gt;trait implementation items&lt;/a&gt;. When applied to an item containing other items, such as a &lt;a href=&quot;../items/modules&quot;&gt;module&lt;/a&gt; or &lt;a href=&quot;../items/implementations&quot;&gt;implementation&lt;/a&gt;, all child items inherit the deprecation attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e7f4030e080734f98683be5c8344d101d0992db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dev&lt;/code&gt; and &lt;code&gt;release&lt;/code&gt; shown in this build output indicate that the compiler is using different profiles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bcbec4aff44a7472a393bc8eca9c7c00034401d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;drop&lt;/code&gt; method is called when &lt;code&gt;_x&lt;/code&gt; goes out of scope, and therefore &lt;code&gt;main&lt;/code&gt; prints &lt;code&gt;Dropping!&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa3edbdb8ad85c4d37e55b2e809f2f18d6f4e045" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a directory symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8ab040b8a001ca82f66534b2d20a3b8892fd2dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a file symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0ecd1a2ccd0de8765e1ce7cbb8fab53800f6ce6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a link pointing to the &lt;code&gt;src&lt;/code&gt; path. Note that systems often require these two paths to both be located on the same filesystem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0f3651131fc6e4c0e98108eb60e32485bb1899b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c07e52fcb5c94a3c499bbc6e95804ccd5a8bfc6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dst&lt;/code&gt; path will be a symbolic link pointing to the &lt;code&gt;src&lt;/code&gt; path. On Windows, this will be a file symlink, not a directory symlink; for this reason, the platform-specific &lt;a href=&quot;../os/unix/fs/fn.symlink&quot;&gt;&lt;code&gt;std::os::unix::fs::symlink&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../os/windows/fs/fn.symlink_file&quot;&gt;&lt;code&gt;std::os::windows::fs::symlink_file&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../os/windows/fs/fn.symlink_dir&quot;&gt;&lt;code&gt;symlink_dir&lt;/code&gt;&lt;/a&gt; should be used instead to make the intent explicit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f31eeeb70d8a71f4b93bd89156c38bf0e5709ff2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;edition&lt;/code&gt; key in &lt;em&gt;Cargo.toml&lt;/em&gt; indicates which edition the compiler should use for your code. If the key doesn&amp;rsquo;t exist, Rust uses &lt;code&gt;2015&lt;/code&gt; as the edition value for backward compatibility reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25d57c60dcf697c3f5bb61f1ff343393baeeb72f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;entry&lt;/code&gt; API is intended to provide an efficient mechanism for manipulating the contents of a map conditionally on the presence of a key or not. The primary motivating use case for this is to provide efficient accumulator maps. For instance, if one wishes to maintain a count of the number of times each key has been seen, they will have to perform some conditional logic on whether this is the first time the key has been seen or not. Normally, this would require a &lt;code&gt;find&lt;/code&gt; followed by an &lt;code&gt;insert&lt;/code&gt;, effectively duplicating the search effort on each insertion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f625c5b9aa8efa15984a630e2609a8460845d869" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;enum&lt;/code&gt; type is analogous to a &lt;code&gt;data&lt;/code&gt; constructor declaration in ML, or a &lt;em&gt;pick ADT&lt;/em&gt; in Limbo.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4c06e2ed2dc5ac68975592625d2fc4a6fa31065" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;env::args&lt;/code&gt; function returns an iterator! Rather than collecting the iterator values into a vector and then passing a slice to &lt;code&gt;Config::new&lt;/code&gt;, now we&amp;rsquo;re passing ownership of the iterator returned from &lt;code&gt;env::args&lt;/code&gt; to &lt;code&gt;Config::new&lt;/code&gt; directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c4edba08b3e0cbdebf585d9d18019162245f0c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;execute&lt;/code&gt; method will send the job it wants to execute down the sending side of the channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f04efaa242b2b0657b1281616eed7892b34b84f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expensive_test&lt;/code&gt; function is listed as &lt;code&gt;ignored&lt;/code&gt;. If we want to run only the ignored tests, we can use &lt;code&gt;cargo test -- --ignored&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f7670e25e83de589c198657dfe09fdc1e175dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;export_name&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40efbff38e084ea29f3140f45238b8f3a1480902" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extern&lt;/code&gt; keyword is used in two places in Rust. One is in conjunction with the &lt;a href=&quot;index&quot;&gt;&lt;code&gt;crate&lt;/code&gt;&lt;/a&gt; keyword to make your Rust code aware of other Rust crates in your project, i.e., &lt;code&gt;extern crate lazy_static;&lt;/code&gt;. The other use is in foreign function interfaces (FFI).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e96870e73ec5eb32cc1bdf8256711d63dccde7e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fix_incorrect_order&lt;/code&gt; function is in the &lt;code&gt;back_of_house&lt;/code&gt; module, so we can use &lt;code&gt;super&lt;/code&gt; to go to the parent module of &lt;code&gt;back_of_house&lt;/code&gt;, which in this case is &lt;code&gt;crate&lt;/code&gt;, the root. From there, we look for &lt;code&gt;serve_order&lt;/code&gt; and find it. Success! We think the &lt;code&gt;back_of_house&lt;/code&gt; module and the &lt;code&gt;serve_order&lt;/code&gt; function are likely to stay in the same relationship to each other and get moved together should we decide to reorganize the crate&amp;rsquo;s module tree. Therefore, we used &lt;code&gt;super&lt;/code&gt; so we&amp;rsquo;ll have fewer places to update code in the future if this code gets moved to a different module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8941a23b194692ed51f3b950de07285880e660a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fn&lt;/code&gt; syntax declares a new function, the parentheses, &lt;code&gt;()&lt;/code&gt;, indicate there are no parameters, and the curly bracket, &lt;code&gt;{&lt;/code&gt;, starts the body of the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec5406eba98b65177f08bb6b301125802a344f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; keyword is used in many syntactic locations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f09d76fe1ac31bb0c6ea4013cf20271ea27e1d4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; loop variable is now named &lt;code&gt;_i&lt;/code&gt;, and the warning no longer appears.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05236db55a3c27bea79ddd94d4c11b4238339e3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;forbid&lt;/code&gt; lint setting, like &lt;code&gt;deny&lt;/code&gt;, turns the corresponding compiler warning into a hard error. Unlike &lt;code&gt;deny&lt;/code&gt;, &lt;code&gt;forbid&lt;/code&gt; prevents itself from being overridden by inner attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4235fdb48267c248121e84a51ecfc4901ad84de8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format&lt;/code&gt; function takes an &lt;a href=&quot;struct.arguments&quot;&gt;&lt;code&gt;Arguments&lt;/code&gt;&lt;/a&gt; struct and returns the resulting formatted string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0e2c1abc11834d5ec0f9413abedb6a8d1f2b1d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; file does not exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c95afec6a5645bced705f13162ada21e2af597c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; path is not a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6acb8d35118f04b02cccbeee4ae943f064bc37b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;global_allocator&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35c9498a5a0a48423b3c0138b12569234cd1c61" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hello_macro_derive&lt;/code&gt; function first converts the &lt;code&gt;input&lt;/code&gt; from a &lt;code&gt;TokenStream&lt;/code&gt; to a data structure that we can then interpret and perform operations on. This is where &lt;code&gt;syn&lt;/code&gt; comes into play. The &lt;code&gt;parse&lt;/code&gt; function in &lt;code&gt;syn&lt;/code&gt; takes a &lt;code&gt;TokenStream&lt;/code&gt; and returns a &lt;code&gt;DeriveInput&lt;/code&gt; struct representing the parsed Rust code. Listing 19-32 shows the relevant parts of the &lt;code&gt;DeriveInput&lt;/code&gt; struct we get from parsing the &lt;code&gt;struct Pancakes;&lt;/code&gt; string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="004c835aa77c1c8e124a5716a58b7a6bffdd04f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hello_macro_derive&lt;/code&gt; function will be called when a user of our library specifies &lt;code&gt;#[derive(HelloMacro)]&lt;/code&gt; on a type. This is possible because we&amp;rsquo;ve annotated the &lt;code&gt;hello_macro_derive&lt;/code&gt; function here with &lt;code&gt;proc_macro_derive&lt;/code&gt; and specified the name, &lt;code&gt;HelloMacro&lt;/code&gt;, which matches our trait name; this is the convention most procedural macros follow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6187e2c81223b9029c3a44a9c821bc39754afaa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if let&lt;/code&gt; syntax lets you combine &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; into a less verbose way to handle values that match one pattern while ignoring the rest. Consider the program in Listing 6-6 that matches on an &lt;code&gt;Option&amp;lt;u8&amp;gt;&lt;/code&gt; value but only wants to execute code if the value is 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dd0a50c18a24fd3e6c3d1653fdf8d2add1e5c54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; condition evaluates to a value of &lt;code&gt;3&lt;/code&gt; this time, and Rust throws an error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b97788abf2717f652bd87cae2841d2689fe301c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; expression checks whether our value is out of range, tells the user about the problem, and calls &lt;code&gt;continue&lt;/code&gt; to start the next iteration of the loop and ask for another guess. After the &lt;code&gt;if&lt;/code&gt; expression, we can proceed with the comparisons between &lt;code&gt;guess&lt;/code&gt; and the secret number knowing that &lt;code&gt;guess&lt;/code&gt; is between 1 and 100.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21d4200f741c0e5d495167ba918e66c0fa127463" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; keyword is used in one other place in Rust, namely as a part of pattern matching itself, allowing patterns such as &lt;code&gt;Some(x) if x &amp;gt; 200&lt;/code&gt; to be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60fa964e136b0f0fd7616e520f7abaf2ebfa7111" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ignore&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f363aa597e809eee39b1326a49009f8ed22190d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ignore&lt;/code&gt; attribute may optionally be written with the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify a reason why the test is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db8fdc6685b8fc701d318f4f3dec52f0b9a4e868" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl Trait&lt;/code&gt; return type captures lifetime parameters that do not appear within the &lt;code&gt;impl Trait&lt;/code&gt; itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9150ca2fdc92a2e0f4ccf4f986d692afa5493d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl Trait&lt;/code&gt; syntax is convenient and makes for more concise code in simple cases. The trait bound syntax can express more complexity in other cases. For example, we can have two parameters that implement &lt;code&gt;Summary&lt;/code&gt;. Using the &lt;code&gt;impl Trait&lt;/code&gt; syntax looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="778ea7a6b81f5bfa7d87e34cfb75fde414639934" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl Trait&lt;/code&gt; syntax works for straightforward cases but is actually syntax sugar for a longer form, which is called a &lt;em&gt;trait bound&lt;/em&gt;; it looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ffdcc0f4b373da2777f00eb0b778b9205836471" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;impl&lt;/code&gt; keyword is primarily used to define implementations on types. Inherent implementations are standalone, while trait implementations are used to implement traits for types, or other traits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49b529510ff41b8ce0e4f03d01af2d0795d82946" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;incoming&lt;/code&gt; method on &lt;code&gt;TcpListener&lt;/code&gt; returns an iterator that gives us a sequence of streams (more specifically, streams of type &lt;code&gt;TcpStream&lt;/code&gt;). A single &lt;em&gt;stream&lt;/em&gt; represents an open connection between the client and the server. A &lt;em&gt;connection&lt;/em&gt; is the name for the full request and response process in which a client connects to the server, the server generates a response, and the server closes the connection. As such, &lt;code&gt;TcpStream&lt;/code&gt; will read from itself to see what the client sent and then allow us to write our response to the stream. Overall, this &lt;code&gt;for&lt;/code&gt; loop will process each connection in turn and produce a series of streams for us to handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ae3f99054fefa43fcfe679af5b3d84ea2c62ac1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0d784eef56974f3daef0d597995f18b5e5f8afb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; attribute only supports two arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc1a141c850728d98b956fd0716ebc10f9ffb6e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inline&lt;/code&gt; attribute was malformed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4788ad11ac891125e5295255c9d02cd7b36750e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isize&lt;/code&gt; type is a signed integer type with the same number of bits as the platform's pointer type. The theoretical upper bound on object and array size is the maximum &lt;code&gt;isize&lt;/code&gt; value. This ensures that &lt;code&gt;isize&lt;/code&gt; can be used to calculate differences between pointers into an object or array and can address every byte within an object along with one byte past the end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d599bd6c4aa9e941662680b3c4cf55e952c7777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;it_works&lt;/code&gt; function now has a return type, &lt;code&gt;Result&amp;lt;(), String&amp;gt;&lt;/code&gt;. In the body of the function, rather than calling the &lt;code&gt;assert_eq!&lt;/code&gt; macro, we return &lt;code&gt;Ok(())&lt;/code&gt; when the test passes and an &lt;code&gt;Err&lt;/code&gt; with a &lt;code&gt;String&lt;/code&gt; inside when the test fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7cf351f8d0a069e43102c73f4dd09e2f7958bd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;largest&lt;/code&gt; function has a parameter called &lt;code&gt;list&lt;/code&gt;, which represents any concrete slice of &lt;code&gt;i32&lt;/code&gt; values that we might pass into the function. As a result, when we call the function, the code runs on the specific values that we pass in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29c272390da5b69d23c340bb06b514ca355b63f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;largest_i32&lt;/code&gt; function is the one we extracted in Listing 10-3 that finds the largest &lt;code&gt;i32&lt;/code&gt; in a slice. The &lt;code&gt;largest_char&lt;/code&gt; function finds the largest &lt;code&gt;char&lt;/code&gt; in a slice. The function bodies have the same code, so let&amp;rsquo;s eliminate the duplication by introducing a generic type parameter in a single function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1c6673a10646101d9e252f3f63c9d87dc9cd482" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;len&lt;/code&gt; argument is the number of &lt;strong&gt;elements&lt;/strong&gt;, not the number of bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eabd24b648d02186aedafa8c6e64a26cd4789b21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let y = 6&lt;/code&gt; statement does not return a value, so there isn&amp;rsquo;t anything for &lt;code&gt;x&lt;/code&gt; to bind to. This is different from what happens in other languages, such as C and Ruby, where the assignment returns the value of the assignment. In those languages, you can write &lt;code&gt;x = y = 6&lt;/code&gt; and have both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; have the value &lt;code&gt;6&lt;/code&gt;; that is not the case in Rust.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb368f642161e00040244b9fcf42bf09c020466c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lines&lt;/code&gt; method returns an iterator. We&amp;rsquo;ll talk about iterators in depth in [Chapter 13][ch13], but recall that you saw this way of using an iterator in &lt;a href=&quot;ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;Listing 3-5&lt;/a&gt;, where we used a &lt;code&gt;for&lt;/code&gt; loop with an iterator to run some code on each item in a collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb1d841506acd030675c6922085c83e81e995a8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49ce3813b3cc29f6621eed5040dfcafe494f7af6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link_name&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="affa85dfaaac9c19595e178102133ab86d473f6f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link_name&lt;/code&gt; attribute may be specified on declarations inside an &lt;code&gt;extern&lt;/code&gt; block to indicate the symbol to import for the given function or static. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the name of the symbol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76e0be66315f639652150dfe37a31422ede56b88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link_section&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d3ac97ce0e51b7500958397678a0747500d6a86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locality&lt;/code&gt; argument must be a constant integer and is a temporal locality specifier ranging from (0) - no locality, to (3) - extremely local keep in cache</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef1c91d4a25bd321565ee99def8880c9e7e661ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loop&lt;/code&gt; keyword creates an infinite loop. We&amp;rsquo;ll add that now to give users more chances at guessing the number:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebe9e1bcc2f0843b5208a2b5109915be71857732" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loop&lt;/code&gt; keyword tells Rust to execute a block of code over and over again forever or until you explicitly tell it to stop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9910971bdcb643aec0b768364519db2f99d5aff4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;macro_use&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c25fb9655125d01a5a1e9d67f7f0780bc361281a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function here creates an instance of the &lt;code&gt;ImportantExcerpt&lt;/code&gt; struct that holds a reference to the first sentence of the &lt;code&gt;String&lt;/code&gt; owned by the variable &lt;code&gt;novel&lt;/code&gt;. The data in &lt;code&gt;novel&lt;/code&gt; exists before the &lt;code&gt;ImportantExcerpt&lt;/code&gt; instance is created. In addition, &lt;code&gt;novel&lt;/code&gt; doesn&amp;rsquo;t go out of scope until after the &lt;code&gt;ImportantExcerpt&lt;/code&gt; goes out of scope, so the reference in the &lt;code&gt;ImportantExcerpt&lt;/code&gt; instance is valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db5fe1609c8c74f709a4f1880a24bb8f27550e1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function is special, and there are restrictions on what its return type must be. One valid return type for main is &lt;code&gt;()&lt;/code&gt;, and conveniently, another valid return type is &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, as shown here:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df8be9695315286ea699a84bc57bf274e0dcbb5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function prototype should never take arguments. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b77f7c754f9c38d3041a1e299a31ef7eeecfa144" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;main&lt;/code&gt; function was incorrectly declared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43e2fa6b27c55d262177050d71a4a20b71217bb8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;move&lt;/code&gt; closure is often used alongside &lt;code&gt;thread::spawn&lt;/code&gt; because it allows you to use data from one thread in another thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="619f2d182d04cd2437b9280f0034a655e725227f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mpsc::channel&lt;/code&gt; function returns a tuple, the first element of which is the sending end and the second element is the receiving end. The abbreviations &lt;code&gt;tx&lt;/code&gt; and &lt;code&gt;rx&lt;/code&gt; are traditionally used in many fields for &lt;em&gt;transmitter&lt;/em&gt; and &lt;em&gt;receiver&lt;/em&gt; respectively, so we name our variables as such to indicate each end. We&amp;rsquo;re using a &lt;code&gt;let&lt;/code&gt; statement with a pattern that destructures the tuples; we&amp;rsquo;ll discuss the use of patterns in &lt;code&gt;let&lt;/code&gt; statements and destructuring in Chapter 18. Using a &lt;code&gt;let&lt;/code&gt; statement this way is a convenient approach to extract the pieces of the tuple returned by &lt;code&gt;mpsc::channel&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a5adaf35abd6fb52abc875dfd1ff8ace4487057" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;must_use&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dc21fbdabdadeb25794ca5fcb0a8eb690cc55f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;must_use&lt;/code&gt; attribute may include a message by using the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax such as &lt;code&gt;#[must_use = &quot;example message&quot;]&lt;/code&gt;. The message will be given alongside the warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa08dd7bde9ed9336c6bf68b835c76ace5a2b281" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; key must be included if &lt;code&gt;kind&lt;/code&gt; is specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f5d61c5238b80d1372117cdc9301f7c5a015909" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_builtins&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e25b9ca8aa17342df965438e7d8b3912387ac96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_link&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c0b9a2602cdb8c2f59fe6476a9d0299ede88a3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_main&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63ed748c3f1f47aec501358b0494a62e8e33119a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_mangle&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6746e3c0ec6ce06b907e0392a7e5f26c1647e02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;not&lt;/code&gt; cfg-predicate was malformed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="522f2fe5c8ca134ded384cd8e598baad904cbb06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;not&lt;/code&gt; predicate expects one cfg-pattern. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b32d84af66b0734455999894598a8249aed66fbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;number&lt;/code&gt; variable will be bound to a value based on the outcome of the &lt;code&gt;if&lt;/code&gt; expression. Run this code to see what happens:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60fb1fa966c95caff6ec3f67558fb81ff746c1d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;op_string_ref&lt;/code&gt; binding has type &lt;code&gt;&amp;amp;Option&amp;lt;&amp;amp;String&amp;gt;&lt;/code&gt; in both cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d0c9a8f467995322cb26a15b43a2ed10bd928bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;opt-level&lt;/code&gt; setting controls the number of optimizations Rust will apply to your code, with a range of 0 to 3. Applying more optimizations extends compiling time, so if you&amp;rsquo;re in development and compiling your code often, you&amp;rsquo;ll want faster compiling even if the resulting code runs slower. That is the reason the default &lt;code&gt;opt-level&lt;/code&gt; for &lt;code&gt;dev&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;. When you&amp;rsquo;re ready to release your code, it&amp;rsquo;s best to spend more time compiling. You&amp;rsquo;ll only compile in release mode once, but you&amp;rsquo;ll run the compiled program many times, so release mode trades longer compile time for code that runs faster. That is why the default &lt;code&gt;opt-level&lt;/code&gt; for the &lt;code&gt;release&lt;/code&gt; profile is &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a0e04095b896f42634e32e5783ee8a2f1b36521" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;or_insert&lt;/code&gt; method on &lt;code&gt;Entry&lt;/code&gt; is defined to return a mutable reference to the value for the corresponding &lt;code&gt;Entry&lt;/code&gt; key if that key exists, and if not, inserts the parameter as the new value for this key and returns a mutable reference to the new value. This technique is much cleaner than writing the logic ourselves and, in addition, plays more nicely with the borrow checker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6774c9469b6011fbcb32c16aad7d03e8b6f6c4d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;panic_handler&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6291890b4261d452b074ebd1ea09861364cf569" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eca9cdb5a96c8de323e434d012e339f61d08ae9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; points at a non-directory file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34ed0df01305ce0f75ec5fd43922003af97a525e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;poll&lt;/code&gt; function is not called repeatedly in a tight loop -- instead, it should only be called when the future indicates that it is ready to make progress (by calling &lt;code&gt;wake()&lt;/code&gt;). If you're familiar with the &lt;code&gt;poll(2)&lt;/code&gt; or &lt;code&gt;select(2)&lt;/code&gt; syscalls on Unix it's worth noting that futures typically do &lt;em&gt;not&lt;/em&gt; suffer the same problems of &quot;all wakeups must poll all events&quot;; they are more like &lt;code&gt;epoll(4)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4cdf57409266ff4ceaefa41a5aa6a9d06ca0f60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;poll&lt;/code&gt; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f69f8390bb6f3d4deb2545de4fdfa29877369556" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prefetch&lt;/code&gt; intrinsic is a hint to the code generator to insert a prefetch instruction if supported; otherwise, it is a no-op. Prefetches have no effect on the behavior of the program but can change its performance characteristics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa7fa9cd2241a28cad4fa12a2f135f7ef3c12daf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;println!&lt;/code&gt; function is only capable of printing to standard output, so we have to use something else to print to standard error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f554c0d8cd003f0dac64077248339772aef74465" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;println!&lt;/code&gt; macro can do many kinds of formatting, and by default, the curly brackets tell &lt;code&gt;println!&lt;/code&gt; to use formatting known as &lt;code&gt;Display&lt;/code&gt;: output intended for direct end user consumption. The primitive types we&amp;rsquo;ve seen so far implement &lt;code&gt;Display&lt;/code&gt; by default, because there&amp;rsquo;s only one way you&amp;rsquo;d want to show a &lt;code&gt;1&lt;/code&gt; or any other primitive type to a user. But with structs, the way &lt;code&gt;println!&lt;/code&gt; should format the output is less clear because there are more display possibilities: Do you want commas or not? Do you want to print the curly brackets? Should all the fields be shown? Due to this ambiguity, Rust doesn&amp;rsquo;t try to guess what we want, and structs don&amp;rsquo;t have a provided implementation of &lt;code&gt;Display&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df3a7253c874e9c54aed370b97b0410e823ccbd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;proc_macro&lt;/code&gt; crate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4aeb159d9e69df04b16b32d0a540b4e48d1c2ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a function. Erroneous code example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d36ebedc5c61f3368fb308364706ea53f77e634b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pub&lt;/code&gt; keyword was used inside a public enum. Erroneous code example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="855c30613293c5803da1be19530bcff46d089f73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;push&lt;/code&gt; method takes a single character as a parameter and adds it to the &lt;code&gt;String&lt;/code&gt;. Listing 8-17 shows code that adds the letter &lt;em&gt;l&lt;/em&gt; to a &lt;code&gt;String&lt;/code&gt; using the &lt;code&gt;push&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c0b086ee3b65e9ef7299c70cf8f6fd0c56999e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;quote!&lt;/code&gt; macro also provides some very cool templating mechanics: we can enter &lt;code&gt;#name&lt;/code&gt;, and &lt;code&gt;quote!&lt;/code&gt; will replace it with the value in the variable &lt;code&gt;name&lt;/code&gt;. You can even do some repetition similar to the way regular macros work. Check out &lt;a href=&quot;https://docs.rs/quote&quot;&gt;the &lt;code&gt;quote&lt;/code&gt; crate&amp;rsquo;s docs&lt;/a&gt; for a thorough introduction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62ab310a7862369bfdb3998e805adaae0cd4f2e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;quote!&lt;/code&gt; macro lets us define the Rust code that we want to return. The compiler expects something different to the direct result of the &lt;code&gt;quote!&lt;/code&gt; macro&amp;rsquo;s execution, so we need to convert it to a &lt;code&gt;TokenStream&lt;/code&gt;. We do this by calling the &lt;code&gt;into&lt;/code&gt; method, which consumes this intermediate representation and returns a value of the required &lt;code&gt;TokenStream&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b83941e960f12671a681a1df28d6d59cb442a02e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recursion_limit&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fd3ec074e9dd99ae0db784fdf399ea43dd43516" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ref&lt;/code&gt; and/or &lt;code&gt;mut&lt;/code&gt;&lt;em&gt;IDENTIFIER&lt;/em&gt; syntax matches any value and binds it to a variable with the same name as the given field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a07e646920bfd0169ef8462620bb6bf857e50545" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;repeat()&lt;/code&gt; function repeats a single value over and over again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca6b7fab269378f975039696a9d029f43743fe55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;repeat_with()&lt;/code&gt; function calls the repeater over and over again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="203b4d4e0f959a4e516770bf1c8acd411f9645d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;request_review&lt;/code&gt; and &lt;code&gt;approve&lt;/code&gt; methods take ownership of &lt;code&gt;self&lt;/code&gt;, thus consuming the &lt;code&gt;DraftPost&lt;/code&gt; and &lt;code&gt;PendingReviewPost&lt;/code&gt; instances and transforming them into a &lt;code&gt;PendingReviewPost&lt;/code&gt; and a published &lt;code&gt;Post&lt;/code&gt;, respectively. This way, we won&amp;rsquo;t have any lingering &lt;code&gt;DraftPost&lt;/code&gt; instances after we&amp;rsquo;ve called &lt;code&gt;request_review&lt;/code&gt; on them, and so forth. The &lt;code&gt;PendingReviewPost&lt;/code&gt; struct doesn&amp;rsquo;t have a &lt;code&gt;content&lt;/code&gt; method defined on it, so attempting to read its content results in a compiler error, as with &lt;code&gt;DraftPost&lt;/code&gt;. Because the only way to get a published &lt;code&gt;Post&lt;/code&gt; instance that does have a &lt;code&gt;content&lt;/code&gt; method defined is to call the &lt;code&gt;approve&lt;/code&gt; method on a &lt;code&gt;PendingReviewPost&lt;/code&gt;, and the only way to get a &lt;code&gt;PendingReviewPost&lt;/code&gt; is to call the &lt;code&gt;request_review&lt;/code&gt; method on a &lt;code&gt;DraftPost&lt;/code&gt;, we&amp;rsquo;ve now encoded the blog post workflow into the type system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14e654a0e6edb832d7ec2e9f01e2cec2e8fc8293" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;request_review&lt;/code&gt; method on &lt;code&gt;Draft&lt;/code&gt; needs to return a new, boxed instance of a new &lt;code&gt;PendingReview&lt;/code&gt; struct, which represents the state when a post is waiting for a review. The &lt;code&gt;PendingReview&lt;/code&gt; struct also implements the &lt;code&gt;request_review&lt;/code&gt; method but doesn&amp;rsquo;t do any transformations. Rather, it returns itself, because when we request a review on a post already in the &lt;code&gt;PendingReview&lt;/code&gt; state, it should stay in the &lt;code&gt;PendingReview&lt;/code&gt; state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e74e1506742074d3eac6be2b7d8e21235520da47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; command comes in handy when you need to rapidly iterate on a project, as we&amp;rsquo;ll do in this game, quickly testing each iteration before moving on to the next one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e85b1a08cc19eee77379933feec0b53082268f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; function definition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e5f409e03a8829700c6b7a5a46ab61b65379877" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; function now contains all the remaining logic from &lt;code&gt;main&lt;/code&gt;, starting from reading the file. The &lt;code&gt;run&lt;/code&gt; function takes the &lt;code&gt;Config&lt;/code&gt; instance as an argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fc1541b8f6585c0ffe5cd745827dfb79f574e45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rustfmt&lt;/code&gt; tool reformats your code according to the community code style. Many collaborative projects use &lt;code&gt;rustfmt&lt;/code&gt; to prevent arguments about which style to use when writing Rust: everyone formats their code using the tool.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f41fbdae4087d677734daccb36bd68168ac22c54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;same_bucket&lt;/code&gt; function is passed references to two elements from the slice and must determine if the elements compare equal. The elements are passed in opposite order from their order in the slice, so if &lt;code&gt;same_bucket(a, b)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is moved at the end of the slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51106981f7e1a09193991d8a2ebd9672888c0e0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;same_bucket&lt;/code&gt; function is passed references to two elements from the vector and must determine if the elements compare equal. The elements are passed in opposite order from their order in the slice, so if &lt;code&gt;same_bucket(a, b)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a14ee345d1496dff6fbc5e218ae3b33c17f09dd5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;search_case_insensitive&lt;/code&gt; function, shown in Listing 12-21, will be almost the same as the &lt;code&gt;search&lt;/code&gt; function. The only difference is that we&amp;rsquo;ll lowercase the &lt;code&gt;query&lt;/code&gt; and each &lt;code&gt;line&lt;/code&gt; so whatever the case of the input arguments, they&amp;rsquo;ll be the same case when we check whether the line contains the query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbcc387564e51cca06178b88f2766991af78a4d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; crate may be imported which creates a binding to the current crate. In this case the &lt;code&gt;as&lt;/code&gt; clause must be used to specify the name to bind it to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5df3512b09c8677b58f509f70a4092543dbb8630" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; import appears more than once in the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca20974e52a0607307348bb19d0d894eb2389060" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword cannot appear alone as the last segment in a &lt;code&gt;use&lt;/code&gt; declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3baa95a2b4735c8ad9eb06f47e895376f593ffa3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; keyword was used in a static method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71e55d8484323ba680a4d79f359c6a8e4726809e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sent_messages&lt;/code&gt; field is now of type &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; instead of &lt;code&gt;Vec&amp;lt;String&amp;gt;&lt;/code&gt;. In the &lt;code&gt;new&lt;/code&gt; function, we create a new &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; instance around the empty vector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="337c62942744e545dcf717c6319edbedc18f313b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shoes_in_my_size&lt;/code&gt; function takes ownership of a vector of shoes and a shoe size as parameters. It returns a vector containing only shoes of the specified size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16a60caa064b42a78f27eb4d74ff02e2b3b32b36" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;should_panic&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="639f1b128b2e8340c54ba2df925fcc505b0aa67b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;should_panic&lt;/code&gt; attribute may optionally take an input string that must appear within the panic message. If the string is not found in the message, then the test will fail. The string may be passed using the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax or the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; syntax with an &lt;code&gt;expected&lt;/code&gt; field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47db49dacc0e9fe0c5ab4b84de0a525fbcc167ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;simd_shuffle&lt;/code&gt; function needs the length of the array passed as last parameter in its name. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1728894948cd279e5a554b1af44ad631d3c73ca8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;spawn&lt;/code&gt; function returns a &lt;code&gt;JoinHandle&amp;lt;T&amp;gt;&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the type that the closure returns. Let&amp;rsquo;s try using &lt;code&gt;JoinHandle&lt;/code&gt; too and see what happens. In our case, the closures we&amp;rsquo;re passing to the thread pool will handle the connection and not return anything, so &lt;code&gt;T&lt;/code&gt; will be the unit type &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="566807adf1a1b2e0676b75e750b724f0403f4cce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;src&lt;/code&gt; path is not a file or doesn't exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a73480c4afd7847e00e31fe3aafec20a20c54b25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;static&lt;/code&gt; keyword, on the other hand, guarantees a fixed location in memory. This does not always mean that the value is constant. For example, a global mutex can be declared &lt;code&gt;static&lt;/code&gt; as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d33afa111381148e1c91bd2523fbea89118180e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::env&lt;/code&gt; module contains many more useful features for dealing with environment variables: check out its documentation to see what is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcaf28a16adceb8447193d5235bef5d8bd3335ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::io&lt;/code&gt; module contains a number of common things you'll need when doing input and output. The most core part of this module is the &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt; traits, which provide the most general interface for reading and writing input and output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a54af6bd4d1bf95ed93c13cd61787ff3a49ae58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std::mem::drop&lt;/code&gt; function is different from the &lt;code&gt;drop&lt;/code&gt; method in the &lt;code&gt;Drop&lt;/code&gt; trait. We call it by passing the value we want to force to be dropped early as an argument. The function is in the prelude, so we can modify &lt;code&gt;main&lt;/code&gt; in Listing 15-15 to call the &lt;code&gt;drop&lt;/code&gt; function, as shown in Listing 15-16:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="964c58feb2d7a0e4b6c63c315388a37636bb2ffa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;steps_between&lt;/code&gt; function provides a way to efficiently compare two &lt;code&gt;Step&lt;/code&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d6948e046aa3d769d70c7d7f5831db7b61d283e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;str&lt;/code&gt; type, also called a 'string slice', is the most primitive string type. It is usually seen in its borrowed form, &lt;code&gt;&amp;amp;str&lt;/code&gt;. It is also the type of string literals, &lt;code&gt;&amp;amp;'static str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ea4c33d08beaf7c17c84c4930138d5a7a1f80fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stringify!&lt;/code&gt; macro used here is built into Rust. It takes a Rust expression, such as &lt;code&gt;1 + 2&lt;/code&gt;, and at compile time turns the expression into a string literal, such as &lt;code&gt;&quot;1 + 2&quot;&lt;/code&gt;. This is different than &lt;code&gt;format!&lt;/code&gt; or &lt;code&gt;println!&lt;/code&gt;, macros which evaluate the expression and then turn the result into a &lt;code&gt;String&lt;/code&gt;. There is a possibility that the &lt;code&gt;#name&lt;/code&gt; input might be an expression to print literally, so we use &lt;code&gt;stringify!&lt;/code&gt;. Using &lt;code&gt;stringify!&lt;/code&gt; also saves an allocation by converting &lt;code&gt;#name&lt;/code&gt; to a string literal at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e2bbf89c9d53502f02966909193300b8b8e39a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;syn&lt;/code&gt; crate parses Rust code from a string into a data structure that we can perform operations on. The &lt;code&gt;quote&lt;/code&gt; crate turns &lt;code&gt;syn&lt;/code&gt; data structures back into Rust code. These crates make it much simpler to parse any sort of Rust code we might want to handle: writing a full parser for Rust code is no simple task.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c2f6cfbefda1dc3521b2af3bf1923ea6ba12d89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;take&lt;/code&gt; method is defined in the &lt;code&gt;Iterator&lt;/code&gt; trait and limits the iteration to the first two items at most. The &lt;code&gt;ThreadPool&lt;/code&gt; will go out of scope at the end of &lt;code&gt;main&lt;/code&gt;, and the &lt;code&gt;drop&lt;/code&gt; implementation will run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4261b148ae0a22c8791698e09a2d9939e795de1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target_feature&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bfa2ee4e02addd4c71ab19bd1f7c85cc21dadfe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;test&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbbce8f10ed8de46d53a88134091400a4cad8f24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transparent&lt;/code&gt; Representation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16cfac7d668a26094fafdea930dd55dadb7672de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transparent&lt;/code&gt; representation can only be used on &lt;code&gt;struct&lt;/code&gt;s that have a single non-zero sized field and any number of zero-sized fields, including &lt;a href=&quot;special-types-and-traits#phantomdatat&quot;&gt;&lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d7d7afaf943b9e9b10757db03a01818240c2c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try_recv&lt;/code&gt; method doesn&amp;rsquo;t block, but will instead return a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; immediately: an &lt;code&gt;Ok&lt;/code&gt; value holding a message if one is available and an &lt;code&gt;Err&lt;/code&gt; value if there aren&amp;rsquo;t any messages this time. Using &lt;code&gt;try_recv&lt;/code&gt; is useful if this thread has other work to do while waiting for messages: we could write a loop that calls &lt;code&gt;try_recv&lt;/code&gt; every so often, handles a message if one is available, and otherwise does other work for a little while until checking again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c06a34327e19720b6fdb343c408e7c55dd84e16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type Target = T;&lt;/code&gt; syntax defines an associated type for the &lt;code&gt;Deref&lt;/code&gt; trait to use. Associated types are a slightly different way of declaring a generic parameter, but you don&amp;rsquo;t need to worry about them for now; we&amp;rsquo;ll cover them in more detail in Chapter 19.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed8f6c9e0893fd91a5e6d611722172ed9ef6f6c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type_length_limit&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7495ddf8e7dd908218ee8fe0115f879a8fb5ec94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typeof&lt;/code&gt; keyword is currently reserved but unimplemented. Erroneous code example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="994e471fd3da940319d1417edcfca60d6a3db828" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; qualifier indicates that the type's value is an &lt;a href=&quot;../unsafe-functions&quot;&gt;unsafe function&lt;/a&gt;, and the &lt;code&gt;extern&lt;/code&gt; qualifier indicates it is an &lt;a href=&quot;../items/functions#extern-functions&quot;&gt;extern function&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78ba9e0cc65cc7840eaadd16f98f7cca440cd4f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unwind&lt;/code&gt; attribute was malformed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a60fd78a94b551f1746c4a391dd52899994edd99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;used&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="762cbbe7d454d7148fa1b85ecdd6dd222c5646ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;usize&lt;/code&gt; type is an unsigned integer type with the same number of bits as the platform's pointer type. It can represent every memory address in the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca7074c2679596c96e2d40f1a9e7060f1f83b71a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; field is of type &lt;code&gt;Option&amp;lt;u32&amp;gt;&lt;/code&gt;. Before we execute the closure, &lt;code&gt;value&lt;/code&gt; will be &lt;code&gt;None&lt;/code&gt;. When code using a &lt;code&gt;Cacher&lt;/code&gt; asks for the &lt;em&gt;result&lt;/em&gt; of the closure, the &lt;code&gt;Cacher&lt;/code&gt; will execute the closure at that time and store the result within a &lt;code&gt;Some&lt;/code&gt; variant in the &lt;code&gt;value&lt;/code&gt; field. Then if the code asks for the result of the closure again, instead of executing the closure again, the &lt;code&gt;Cacher&lt;/code&gt; will return the result held in the &lt;code&gt;Some&lt;/code&gt; variant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5defa2a7e24b93d29be444c6bce3655062b73aee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vtable&lt;/code&gt; customizes the behavior of a &lt;code&gt;Waker&lt;/code&gt; which gets created from a &lt;code&gt;RawWaker&lt;/code&gt;. For each operation on the &lt;code&gt;Waker&lt;/code&gt;, the associated function in the &lt;code&gt;vtable&lt;/code&gt; of the underlying &lt;code&gt;RawWaker&lt;/code&gt; will be called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58deddf572f1c05716c0aff255109ee68c618f77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;wasm_import_module&lt;/code&gt; key may be used to specify the &lt;a href=&quot;https://webassembly.github.io/spec/core/syntax/modules.html&quot;&gt;WebAssembly module&lt;/a&gt; name for the items within an &lt;code&gt;extern&lt;/code&gt; block when importing symbols from the host environment. The default module name is &lt;code&gt;env&lt;/code&gt; if &lt;code&gt;wasm_import_module&lt;/code&gt; is not specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03b2e1ae71fdcbd9ffac8eca408ab8d4e8472f94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, and &lt;code&gt;label&lt;/code&gt; fields on &lt;code&gt;Button&lt;/code&gt; will differ from the fields on other components, such as a &lt;code&gt;TextField&lt;/code&gt; type, that might have those fields plus a &lt;code&gt;placeholder&lt;/code&gt; field instead. Each of the types we want to draw on the screen will implement the &lt;code&gt;Draw&lt;/code&gt; trait but will use different code in the &lt;code&gt;draw&lt;/code&gt; method to define how to draw that particular type, as &lt;code&gt;Button&lt;/code&gt; has here (without the actual GUI code, which is beyond the scope of this chapter). The &lt;code&gt;Button&lt;/code&gt; type, for instance, might have an additional &lt;code&gt;impl&lt;/code&gt; block containing methods related to what happens when a user clicks the button. These kinds of methods won&amp;rsquo;t apply to types like &lt;code&gt;TextField&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49fef96b0756f10c5fd5c7fedcccb9ee963b501d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;windows_subsystem&lt;/code&gt; attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe674a5495eedc22d7ae598194abec96fa238a33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;write&lt;/code&gt; function takes an output stream, and an &lt;code&gt;Arguments&lt;/code&gt; struct that can be precompiled with the &lt;code&gt;format_args!&lt;/code&gt; macro.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5644d7245fdec36266e15ee66f56202b01bc587d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;x&lt;/code&gt; part is a pattern! As we did with &lt;code&gt;let&lt;/code&gt;, we could match a tuple in a function&amp;rsquo;s arguments to the pattern. Listing 18-7 splits the values in a tuple as we pass it to a function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90c7cb6860c6df5927660a73f110e2f9166750a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;x&lt;/code&gt; value is moved into the closure when the closure is defined, because we added the &lt;code&gt;move&lt;/code&gt; keyword. The closure then has ownership of &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;main&lt;/code&gt; isn&amp;rsquo;t allowed to use &lt;code&gt;x&lt;/code&gt; anymore in the &lt;code&gt;println!&lt;/code&gt; statement. Removing &lt;code&gt;println!&lt;/code&gt; will fix this example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="693d3b957625a8e3df8f4384a832c7be5cfa15d0" translate="yes" xml:space="preserve">
          <source>The &lt;em id=&quot;the-tests-directory&quot;&gt;tests&lt;/em&gt; Directory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d372f8b0a676dc2ae354b920b56c31e1ed0230f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;cold&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; suggests that the attributed function is unlikely to be called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8dd94fd6bb692bd54e04ee95744533de367bad8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;crate_name&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied at the crate level to specify the name of the crate with the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2db8e6439808a243c5fa24e648c2e0fab8ef4d83" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;deprecated&lt;/code&gt; attribute&lt;/em&gt; marks an item as deprecated. &lt;code&gt;rustc&lt;/code&gt; will issue warnings on usage of &lt;code&gt;#[deprecated]&lt;/code&gt; items. &lt;code&gt;rustdoc&lt;/code&gt; will show item deprecation, including the &lt;code&gt;since&lt;/code&gt; version and &lt;code&gt;note&lt;/code&gt;, if available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa15bab6a083f19d9ae9cd7eaa338e697eaf4832" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;derive&lt;/code&gt; attribute&lt;/em&gt; allows new &lt;a href=&quot;../items&quot;&gt;items&lt;/a&gt; to be automatically generated for data structures. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt; syntax to specify a list of traits to implement or paths to &lt;a href=&quot;../procedural-macros#derive-macros&quot;&gt;derive macros&lt;/a&gt; to process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a97c3213ab817ab892d8f6e5c3157736e74b3b32" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;export_name&lt;/code&gt; attribute&lt;/em&gt; specifies the name of the symbol that will be exported on a &lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; or &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt;. It uses the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the symbol name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d1fbcf19af41adeefc0b92335ae4b007c4dadfa" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;global_allocator&lt;/code&gt; attribute&lt;/em&gt; is used on a &lt;a href=&quot;items/static-items&quot;&gt;static item&lt;/a&gt; implementing the &lt;a href=&quot;https://doc.rust-lang.org/alloc/alloc/trait.GlobalAlloc.html&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt; trait to set the global allocator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb4af8649334dd85e9ba7979a0a444e3961c900a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;inline&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; suggests that a copy of the attributed function should be placed in the caller, rather than generating code to call the function where it is defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d9a7b1456b98dca1d8fed53edde3318db90e4c5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;link&lt;/code&gt; attribute&lt;/em&gt; specifies the name of a native library that the compiler should link with for the items within an &lt;code&gt;extern&lt;/code&gt; block. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify its inputs. The &lt;code&gt;name&lt;/code&gt; key is the name of the native library to link. The &lt;code&gt;kind&lt;/code&gt; key is an optional value which specifies the kind of library with the following possible values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6603167a8a5aa9df2deb989c68e33b760144ac17" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;link_section&lt;/code&gt; attribute&lt;/em&gt; specifies the section of the object file that a &lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; or &lt;a href=&quot;items/static-items&quot;&gt;static&lt;/a&gt;'s content will be placed into. It uses the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the section name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="806935dfacd2a07be8b57f073dcdf39509c2b1f7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;macro_use&lt;/code&gt; attribute&lt;/em&gt; has two purposes. First, it can be used to make a module's macro scope not end when the module is closed, by applying it to a module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05f0042fe91a37001bd65ea0d74fd9143e55659c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;must_use&lt;/code&gt; attribute&lt;/em&gt; is used to issue a diagnostic warning when a value is not &quot;used&quot;. It can be applied to user-defined composite types (&lt;a href=&quot;../items/structs&quot;&gt;&lt;code&gt;struct&lt;/code&gt;s&lt;/a&gt;, &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt;s&lt;/a&gt;, and &lt;a href=&quot;../items/unions&quot;&gt;&lt;code&gt;union&lt;/code&gt;s&lt;/a&gt;), &lt;a href=&quot;../items/functions&quot;&gt;functions&lt;/a&gt;, and &lt;a href=&quot;../items/traits&quot;&gt;traits&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df0d5b935c63e0d5d09ad34649237d79db006af9" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_builtins&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied at the crate level to disable optimizing certain code patterns to invocations of library functions that are assumed to exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c5fb5c17e1ae5e93c491f3ff3864f7cf3700a82" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_link&lt;/code&gt; attribute&lt;/em&gt; may be specified on an &lt;code&gt;extern crate&lt;/code&gt; item to prevent linking the crate into the output. This is commonly used to load a crate to access only its macros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a894d89850015842793e60fc8f351c2309ee5ef4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_main&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied at the crate level to disable emitting the &lt;code&gt;main&lt;/code&gt; symbol for an executable binary. This is useful when some other object being linked to defines &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3bcfb88f5c979d523b3f1a38c5f5b56a611b895" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;no_mangle&lt;/code&gt; attribute&lt;/em&gt; may be used on any &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; to disable standard symbol name mangling. The symbol for the item will be the identifier of the item's name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53a982d72d2f0894ccb0ac1653ff149a9b51224c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;panic_handler&lt;/code&gt; attribute&lt;/em&gt; can only be applied to a function with signature &lt;code&gt;fn(&amp;amp;PanicInfo) -&amp;gt; !&lt;/code&gt;. The function marked with this &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; defines the behavior of panics. The &lt;a href=&quot;https://doc.rust-lang.org/core/panic/struct.PanicInfo.html&quot;&gt;&lt;code&gt;PanicInfo&lt;/code&gt;&lt;/a&gt; struct contains information about the location of the panic. There must be a single &lt;code&gt;panic_handler&lt;/code&gt; function in the dependency graph of a binary, dylib or cdylib crate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12cdf01a779d8c77135d5a609c4b4e6849f40d6f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;recursion_limit&lt;/code&gt; attribute&lt;/em&gt; may be applied at the &lt;a href=&quot;../crates-and-source-files&quot;&gt;crate&lt;/a&gt; level to set the maximum depth for potentially infinitely-recursive compile-time operations like macro expansion or auto-dereference. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the recursion depth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c71f7f4ce5a08ecec5e3cb423add9b9986d9b2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;target_feature&lt;/code&gt; &lt;a href=&quot;../attributes&quot;&gt;attribute&lt;/a&gt;&lt;/em&gt; may be applied to an &lt;a href=&quot;../unsafe-functions&quot;&gt;unsafe function&lt;/a&gt; to enable code generation of that function for specific platform architecture features. It uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListNameValueStr&lt;/em&gt;&lt;/a&gt; syntax with a single key of &lt;code&gt;enable&lt;/code&gt; whose value is a string of comma-separated feature names to enable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aa1c2ce8a0a269a928c5414e9b6749a40da4909" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;test&lt;/code&gt; attribute&lt;/em&gt; marks a function to be executed as a test. These functions are only compiled when in test mode. Test functions must be free, monomorphic functions that take no arguments, and the return type must be one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e32e2a7306abe757340b9bbe77da987dbdce7fd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;type_length_limit&lt;/code&gt; attribute&lt;/em&gt; limits the maximum number of type substitutions made when constructing a concrete type during monomorphization. It is applied at the &lt;a href=&quot;../crates-and-source-files&quot;&gt;crate&lt;/a&gt; level, and uses the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to set the limit based on the number of type substitutions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9f3929d821839852e44df6684413a39c02b618f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;used&lt;/code&gt; attribute&lt;/em&gt; can only be applied to &lt;a href=&quot;items/static-items&quot;&gt;&lt;code&gt;static&lt;/code&gt; items&lt;/a&gt;. This &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; forces the compiler to keep the variable in the output object file (.o, .rlib, etc.) even if the variable is not used, or referenced, by any other item in the crate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cabd9dd1fe1f065b8657354c25edb014ad53f468" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&lt;code&gt;windows_subsystem&lt;/code&gt; attribute&lt;/em&gt; may be applied at the crate level to set the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/fcc1zstk.aspx&quot;&gt;subsystem&lt;/a&gt; when linking on a Windows target. It uses the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaNameValueStr&lt;/em&gt;&lt;/a&gt; syntax to specify the subsystem with a value of either &lt;code&gt;console&lt;/code&gt; or &lt;code&gt;windows&lt;/code&gt;. This attribute is ignored on non-Windows targets, and for non-&lt;code&gt;bin&lt;/code&gt;&lt;a href=&quot;linkage&quot;&gt;crate types&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="637d9dddc1ad4617a0c58ddffc3922ae87e9baab" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;alignment&lt;/em&gt; of a value specifies what addresses are valid to store the value at. A value of alignment &lt;code&gt;n&lt;/code&gt; must only be stored at an address that is a multiple of n. For example, a value with an alignment of 2 must be stored at an even address, while a value with an alignment of 1 can be stored at any address. Alignment is measured in bytes, and must be at least 1, and always a power of 2. The alignment of a value can be checked with the &lt;a href=&quot;../std/mem/fn.align_of_val&quot;&gt;&lt;code&gt;align_of_val&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caa4287ee2eae29f4b7097731528e2f984499328" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;at&lt;/em&gt; operator (&lt;code&gt;@&lt;/code&gt;) lets us create a variable that holds a value at the same time we&amp;rsquo;re testing that value to see whether it matches a pattern. Listing 18-29 shows an example where we want to test that a &lt;code&gt;Message::Hello&lt;/code&gt;&lt;code&gt;id&lt;/code&gt; field is within the range &lt;code&gt;3...7&lt;/code&gt;. But we also want to bind the value to the variable &lt;code&gt;id_variable&lt;/code&gt; so we can use it in the code associated with the arm. We could name this variable &lt;code&gt;id&lt;/code&gt;, the same as the field, but for this example we&amp;rsquo;ll use a different name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="491e011fde2c63e7287e5968a958f99a0e0608ea" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;backslash escape&lt;/em&gt; is the character &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) which must be escaped in order to denote its ASCII encoding &lt;code&gt;0x5C&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e78bebf05e1ce9e264a960c4a634448ed6a163c1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;backslash escape&lt;/em&gt; is the character &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) which must be escaped in order to denote itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="863e56925d2ff8675a4dd9c4a460d825a809b69e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;heap&lt;/em&gt; is a general term that describes boxes. The lifetime of an allocation in the heap depends on the lifetime of the box values pointing to it. Since box values may themselves be passed in and out of frames, or stored in the heap, heap allocations may outlive the frame they are allocated within. An allocation in the heap is guaranteed to reside at a single location in the heap for the whole lifetime of the allocation - it will never be relocated as a result of moving a box value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21ffe4f08baa3ee5d8fcae0ac2b2640039bc170b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;items&lt;/em&gt; of a program are those functions, modules and types that have their value calculated at compile-time and stored uniquely in the memory image of the rust process. Items are neither dynamically allocated nor freed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="867bacda5c963969dd78331f878c031b22f73cbb" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;null escape&lt;/em&gt; is the character &lt;code&gt;U+0030&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt;) and denotes the Unicode value &lt;code&gt;U+0000&lt;/code&gt; (NUL).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0460a3f4832868522908bad2876d5f8fef36d49" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;null escape&lt;/em&gt; is the character &lt;code&gt;U+0030&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt;) and denotes the byte value &lt;code&gt;0x00&lt;/code&gt; (ASCII NUL).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4b356718e399f8a05dc4012731a26a28084f252" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;prelude&lt;/em&gt; is the list of things that Rust automatically imports into every Rust program. It's kept as small as possible, and is focused on things, particularly traits, which are used in almost every single Rust program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5fc79bf9688aa8e786959c2742e411818e5d89a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;primitive representations&lt;/em&gt; are the representations with the same names as the primitive integer types. That is: &lt;code&gt;u8&lt;/code&gt;, &lt;code&gt;u16&lt;/code&gt;, &lt;code&gt;u32&lt;/code&gt;, &lt;code&gt;u64&lt;/code&gt;, &lt;code&gt;u128&lt;/code&gt;, &lt;code&gt;usize&lt;/code&gt;, &lt;code&gt;i8&lt;/code&gt;, &lt;code&gt;i16&lt;/code&gt;, &lt;code&gt;i32&lt;/code&gt;, &lt;code&gt;i64&lt;/code&gt;, &lt;code&gt;i128&lt;/code&gt;, and &lt;code&gt;isize&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4971362f3b5f40470a74c81b64c44c61022c0ae5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;size&lt;/em&gt; of a value is the offset in bytes between successive elements in an array with that item type including alignment padding. The size of a value is always a multiple of its alignment. The size of a value can be checked with the &lt;a href=&quot;../std/mem/fn.size_of_val&quot;&gt;&lt;code&gt;size_of_val&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="608607007d0795edd59e30f51aeabc80ca46b5f6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;state pattern&lt;/em&gt; is an object-oriented design pattern. The crux of the pattern is that a value has some internal state, which is represented by a set of &lt;em&gt;state objects&lt;/em&gt;, and the value&amp;rsquo;s behavior changes based on the internal state. The state objects share functionality: in Rust, of course, we use structs and traits rather than objects and inheritance. Each state object is responsible for its own behavior and for governing when it should change into another state. The value that holds a state object knows nothing about the different behavior of the states or when to transition between states.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c707e6c38639fd82e39cc81120827bce74e177e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;wildcard pattern&lt;/em&gt; matches any value. It is used to ignore values when they don't matter. Inside other patterns it matches a single data field (as opposed to the &lt;code&gt;..&lt;/code&gt; which matches the remaining fields). Unlike identifier patterns, it does not copy, move or borrow the value it matches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75f0595163c83b48141e476739787cd1006a8d33" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;channel&lt;/strong&gt;'s sending half has become disconnected, and there will never be any more data received on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d020769b0b6d90680db8e09c6dc6e9b663dc909" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;compiler&lt;/strong&gt; reordering instructions: If the compiler can issue an instruction at an earlier point, it will try to do so. For example, it might hoist memory loads at the top of a code block, so that the CPU can start &lt;a href=&quot;https://en.wikipedia.org/wiki/Cache_prefetching&quot;&gt;prefetching&lt;/a&gt; the values from memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="314b68cd7b660a21edb44d2117cd4a156ae245a5" translate="yes" xml:space="preserve">
          <source>The API documentation that &lt;code&gt;cargo doc&lt;/code&gt; generates for this crate will now list and link re-exports on the front page, as shown in Figure 14-4, making the &lt;code&gt;PrimaryColor&lt;/code&gt; and &lt;code&gt;SecondaryColor&lt;/code&gt; types and the &lt;code&gt;mix&lt;/code&gt; function easier to find.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe97d53a4341ff985473c7759453c7f0b6f51809" translate="yes" xml:space="preserve">
          <source>The API is typically used by acquiring a handle to the current thread, placing that handle in a shared data structure so that other threads can find it, and then &lt;code&gt;park&lt;/code&gt;ing in a loop. When some desired condition is met, another thread calls &lt;a href=&quot;struct.thread#method.unpark&quot;&gt;&lt;code&gt;unpark&lt;/code&gt;&lt;/a&gt; on the handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdef16eb0aad1c8443510daaf0eaf64f22da449f" translate="yes" xml:space="preserve">
          <source>The API of &lt;code id=&quot;the-api-of-mutext&quot;&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da2fca5419425bb1dfeff3a19e5e6b522b71b9f7" translate="yes" xml:space="preserve">
          <source>The Anatomy of a Test Function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ff9dd46af7ebe72f506f56aea2ffd15b7f82cfe" translate="yes" xml:space="preserve">
          <source>The Array Type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c7fdb8a442bced7fcc6b743d86e4b178b1bc140" translate="yes" xml:space="preserve">
          <source>The Boolean Type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a47e0b8b6b1bfa40f74993b9ed02984c335782d" translate="yes" xml:space="preserve">
          <source>The Boolean type, &lt;code&gt;bool&lt;/code&gt;, with values &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d554fe4c508301c7dd79586706f031038650a679" translate="yes" xml:space="preserve">
          <source>The Borrow Checker</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86641abf85c69d8c4f7c9c71c79144e3a2832005" translate="yes" xml:space="preserve">
          <source>The Character Type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35e39875eebfabcb5b0b8cd30288767fc0b6add8" translate="yes" xml:space="preserve">
          <source>The Clippy tool is a collection of lints to analyze your code so you can catch common mistakes and improve your Rust code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb08bad287d0caba2752b58d322b62f2942d38e6" translate="yes" xml:space="preserve">
          <source>The Default Representation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9e1a59444e395f067802b105261ac31a11eac66" translate="yes" xml:space="preserve">
          <source>The Difference Between Macros and Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47f6987535ee435e225cb875fe024ba6f3b75e49" translate="yes" xml:space="preserve">
          <source>The Glob Operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0a1aaf98c3bce57246183f1baadfe83da9b49cd" translate="yes" xml:space="preserve">
          <source>The HTML format is available online at &lt;a href=&quot;https://doc.rust-lang.org/stable/book/index.html&quot;&gt;https://doc.rust-lang.org/stable/book/&lt;/a&gt; and offline with installations of Rust made with &lt;code&gt;rustup&lt;/code&gt;; run &lt;code&gt;rustup docs --book&lt;/code&gt; to open.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00df77514c97d921fca4a972435309219a163a06" translate="yes" xml:space="preserve">
          <source>The I/O Prelude</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6979c051972c7d2da3658847fabbf6a31d84bdb5" translate="yes" xml:space="preserve">
          <source>The I/O operation's timeout expired, causing it to be canceled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc9c14a7eb4854c512e7ed69d5ba6a43f9c253aa" translate="yes" xml:space="preserve">
          <source>The IEEE 754-2008 &quot;binary32&quot; and &quot;binary64&quot; floating-point types are &lt;code&gt;f32&lt;/code&gt; and &lt;code&gt;f64&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a46bc695392f8c742f4e678a79ed2375790074cb" translate="yes" xml:space="preserve">
          <source>The Matcher Invariants</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eece4981b24083c68ecabd071b66fe17ba1ce62" translate="yes" xml:space="preserve">
          <source>The Never Type that Never Returns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba8021c95f458659340856b34b5ce555bddda300" translate="yes" xml:space="preserve">
          <source>The RFC Process and Teams</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="667bd8e20b1ba8153f27c9ff6c220024562a73c6" translate="yes" xml:space="preserve">
          <source>The Rules of References</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="161ef3f14aee5229baf3e48cdbbdab5a784349b3" translate="yes" xml:space="preserve">
          <source>The Rust Language Server powers Integrated Development Environment (IDE) integration for code completion and inline error messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efbadde43b4ea2876af269fef5bbeff660435dad" translate="yes" xml:space="preserve">
          <source>The Rust Prelude</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e47c327d13b68cc315d8c0718500294854d4bd4" translate="yes" xml:space="preserve">
          <source>The Rust Prelude.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64d4853b323b63d9ca56f4771bf913212d9ace7a" translate="yes" xml:space="preserve">
          <source>The Rust Programming Language</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb645ae646711df91105c5e5d03daf9c88ee91b" translate="yes" xml:space="preserve">
          <source>The Rust Standard Library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c789ddc154274d796ddc2e963326017f63c2958" translate="yes" xml:space="preserve">
          <source>The Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the &lt;a href=&quot;https://crates.io&quot;&gt;broader Rust ecosystem&lt;/a&gt;. It offers core types, like &lt;a href=&quot;vec/index&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, library-defined &lt;a href=&quot;#primitives&quot;&gt;operations on language primitives&lt;/a&gt;, &lt;a href=&quot;#macros&quot;&gt;standard macros&lt;/a&gt;, &lt;a href=&quot;io/index&quot;&gt;I/O&lt;/a&gt; and &lt;a href=&quot;thread/index&quot;&gt;multithreading&lt;/a&gt;, among &lt;a href=&quot;#what-is-in-the-standard-library-documentation&quot;&gt;many other things&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c3853d774e4956749b7c91653db336f2eec58d4" translate="yes" xml:space="preserve">
          <source>The Rust compiler does not consider the following behaviors &lt;em&gt;unsafe&lt;/em&gt;, though a programmer may (should) find them undesirable, unexpected, or erroneous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21b3dd0203ec587beb1963c1f4feb0c5c3e73b91" translate="yes" xml:space="preserve">
          <source>The Rust compiler has a &lt;em&gt;borrow checker&lt;/em&gt; that compares scopes to determine whether all borrows are valid. Listing 10-18 shows the same code as Listing 10-17 but with annotations showing the lifetimes of the variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bac79421ac7e7f4a69670a43a87279fa1ea360c9" translate="yes" xml:space="preserve">
          <source>The Rust compiler is always invoked with a single source file as input, and always produces a single output crate. The processing of that source file may result in other source files being loaded as modules. Source files have the extension &lt;code&gt;.rs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edecdb50208b6b73bf12c25a96c41ebd3a559a66" translate="yes" xml:space="preserve">
          <source>The Rust language and compiler have a six-week release cycle, meaning users get a constant stream of new features. Other programming languages release larger changes less often; Rust releases smaller updates more frequently. After a while, all of these tiny changes add up. But from release to release, it can be difficult to look back and say, &amp;ldquo;Wow, between Rust 1.10 and Rust 1.31, Rust has changed a lot!&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4db8a730c896d57ac8ae13218ced391891bc4c9e" translate="yes" xml:space="preserve">
          <source>The Rust language has a set of &lt;em&gt;keywords&lt;/em&gt; that are reserved for use by the language only, much as in other languages. Keep in mind that you cannot use these words as names of variables or functions. Most of the keywords have special meanings, and you&amp;rsquo;ll be using them to do various tasks in your Rust programs; a few have no current functionality associated with them but have been reserved for functionality that might be added to Rust in the future. You can find a list of the keywords in Appendix A.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c421a36adf32e1316c136776ce05dd83536c6c8" translate="yes" xml:space="preserve">
          <source>The Rust language hopes to support many other users as well; those mentioned here are merely some of the biggest stakeholders. Overall, Rust&amp;rsquo;s greatest ambition is to eliminate the trade-offs that programmers have accepted for decades by providing safety &lt;em&gt;and&lt;/em&gt; productivity, speed &lt;em&gt;and&lt;/em&gt; ergonomics. Give Rust a try and see if its choices work for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="596e2b7dbc791cd3cfc77236ae00a927665967e2" translate="yes" xml:space="preserve">
          <source>The Rust runtime</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6be65bd73ad861e62f3888e1cc3672c017c1636b" translate="yes" xml:space="preserve">
          <source>The Rust standard library provides channels for message passing and smart pointer types, such as &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;, that are safe to use in concurrent contexts. The type system and the borrow checker ensure that the code using these solutions won&amp;rsquo;t end up with data races or invalid references. Once you get your code to compile, you can rest assured that it will happily run on multiple threads without the kinds of hard-to-track-down bugs common in other languages. Concurrent programming is no longer a concept to be afraid of: go forth and make your programs concurrent, fearlessly!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca0e948d58962dbdfe194b991ab15a2f509a074c" translate="yes" xml:space="preserve">
          <source>The Rust type system has some features that we&amp;rsquo;ve mentioned in this book but haven&amp;rsquo;t yet discussed. We&amp;rsquo;ll start by discussing newtypes in general as we examine why newtypes are useful as types. Then we&amp;rsquo;ll move on to type aliases, a feature similar to newtypes but with slightly different semantics. We&amp;rsquo;ll also discuss the &lt;code&gt;!&lt;/code&gt; type and dynamically sized types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e24d83679bf4a662ce93151d4c79beb7bc3d976" translate="yes" xml:space="preserve">
          <source>The Slice Type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b60a9b411326be4b7b78e74a3c2736078d2cb936" translate="yes" xml:space="preserve">
          <source>The Stack and the Heap</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea9187c27f13ce2d0fda228c7804b1eacb2a7df4" translate="yes" xml:space="preserve">
          <source>The Static Lifetime</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcc1bdcf64d9ba08b8c546b48a03373f9d896f1a" translate="yes" xml:space="preserve">
          <source>The Tests Module and &lt;code id=&quot;the-tests-module-and-cfgtest&quot;&gt;#[cfg(test)]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43d375d205a43568d44e006351aba054a3a6df0e" translate="yes" xml:space="preserve">
          <source>The Trade-Offs of Using &lt;code id=&quot;the-trade-offs-of-using-clone&quot;&gt;clone&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="874f680f597dff734725c0edb8d1cdbdc1c687fb" translate="yes" xml:space="preserve">
          <source>The Transmission Control Protocol is specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d2bc0207cf3386e89a8ff90f2a45c74d008dd6b" translate="yes" xml:space="preserve">
          <source>The Tuple Type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="720acae72ae852d88680bc6199aaf2a3185402bd" translate="yes" xml:space="preserve">
          <source>The Unsize trait should not be implemented directly. All implementations of Unsize are provided automatically by the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8c2343fd3b49fd50014f949ed7698cf46aba4f" translate="yes" xml:space="preserve">
          <source>The ability to return a type that is only specified by the trait it implements is especially useful in the context of closures and iterators, which we cover in Chapter 13. Closures and iterators create types that only the compiler knows or types that are very long to specify. The &lt;code&gt;impl Trait&lt;/code&gt; syntax lets you concisely specify that a function returns some type that implements the &lt;code&gt;Iterator&lt;/code&gt; trait without needing to write out a very long type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ff7b2880604f74445f905b71fdee96836fc628" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i128::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i128&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i128::min_value()&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6634b50eb0aa3afe906f4e13b4800cc26454c92" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i16::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i16&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i16::min_value()&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91a991a9b7dce7a35eefa5dff81ee4a280a7e4f1" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i32::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i32&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i32::min_value()&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c50c4d71fa72eabc1e0818c0a858ae1903c1c3c" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i64::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i64&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i64::min_value()&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5adbbbaac9cedf98e39759b8920bdb3431d04107" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;i8::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;i8&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;i8::min_value()&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fa62dd0a50bd4c5554cb57272ae5164c2e1f601" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;isize::min_value()&lt;/code&gt; cannot be represented as an &lt;code&gt;isize&lt;/code&gt;, and attempting to calculate it will cause an overflow. This means that code in debug mode will trigger a panic on this case and optimized code will return &lt;code&gt;isize::min_value()&lt;/code&gt; without a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88133b615f1381b0a02c487a3edbc253bc8ee09f" translate="yes" xml:space="preserve">
          <source>The actual stack size may be greater than this value if the platform specifies a minimal stack size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e09eb4195a6425d3d0a7b968cb406d8968af9926" translate="yes" xml:space="preserve">
          <source>The addition assignment operator &lt;code&gt;+=&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="097ca9dd7ade97007d85b522a25e6d04cefa5c67" translate="yes" xml:space="preserve">
          <source>The addition operator &lt;code&gt;+&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67b3b3b11425c46c946b0ed067dfaec63ac739cb" translate="yes" xml:space="preserve">
          <source>The address type can be any implementor of &lt;a href=&quot;trait.tosocketaddrs&quot;&gt;&lt;code&gt;ToSocketAddrs&lt;/code&gt;&lt;/a&gt; trait. See its documentation for concrete examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="554a0871d5bd274c4e9a4646e480108243a7e12e" translate="yes" xml:space="preserve">
          <source>The advantage of checking the borrowing rules at runtime instead is that certain memory-safe scenarios are then allowed, whereas they are disallowed by the compile-time checks. Static analysis, like the Rust compiler, is inherently conservative. Some properties of code are impossible to detect by analyzing the code: the most famous example is the Halting Problem, which is beyond the scope of this book but is an interesting topic to research.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf97cfec24f32bdc09751ee8bbb19e7117656381" translate="yes" xml:space="preserve">
          <source>The advantage of using trait objects and Rust&amp;rsquo;s type system to write code similar to code using duck typing is that we never have to check whether a value implements a particular method at runtime or worry about getting errors if a value doesn&amp;rsquo;t implement a method but we call it anyway. Rust won&amp;rsquo;t compile our code if the values don&amp;rsquo;t implement the traits that the trait objects need.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f36aabbacdf9ecb5c08c91a08fabb8510a201b8" translate="yes" xml:space="preserve">
          <source>The advantages of checking the borrowing rules at compile time are that errors will be caught sooner in the development process, and there is no impact on runtime performance because all the analysis is completed beforehand. For those reasons, checking the borrowing rules at compile time is the best choice in the majority of cases, which is why this is Rust&amp;rsquo;s default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="802cd88adc867c6ed95af7c7632a5b9312da114b" translate="yes" xml:space="preserve">
          <source>The alignment is specified as an integer parameter in the form of &lt;code&gt;#[repr(align(x))]&lt;/code&gt; or &lt;code&gt;#[repr(packed(x))]&lt;/code&gt;. The alignment value must be a power of two from 1 up to 2&lt;sup&gt;29&lt;/sup&gt;. For &lt;code&gt;packed&lt;/code&gt;, if no value is given, as in &lt;code&gt;#[repr(packed)]&lt;/code&gt;, then the value is 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4210b5f1c3a4d7626a8282b8b0091e3127367f26" translate="yes" xml:space="preserve">
          <source>The alignment may be raised or lowered with the &lt;code&gt;align&lt;/code&gt; and &lt;code&gt;packed&lt;/code&gt; modifiers respectively. They alter the representation specified in the attribute. If no representation is specified, the default one is altered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bbd4814e74e1731ea096a3e29eb0e49a6112a9b" translate="yes" xml:space="preserve">
          <source>The alignment modifiers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a801ec59d9d78b1342286bf3c47cdf72d8754c9" translate="yes" xml:space="preserve">
          <source>The alignment of a value specifies what addresses values are preferred to start at. Always a power of two. References to a value must be aligned. &lt;a href=&quot;type-layout#size-and-alignment&quot;&gt;More&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7d8131883a9466d9495401638572f0f7002cb80" translate="yes" xml:space="preserve">
          <source>The alignment of the struct is the alignment of the most-aligned field in it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb2d786ce814f96269971824a7ca8c85b85a4a91" translate="yes" xml:space="preserve">
          <source>The allocated block of memory may or may not be initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a853460caf9660ad50bba38269de71834329efaf" translate="yes" xml:space="preserve">
          <source>The allocation error hook is a global resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd622480c0a0d020ad0c83e155629929c531f8bd" translate="yes" xml:space="preserve">
          <source>The allocation error hook is invoked when an infallible memory allocation fails, before the runtime aborts. The default hook prints a message to standard error, but this behavior can be customized with the &lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt;&lt;code&gt;set_alloc_error_hook&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt;&lt;code&gt;take_alloc_error_hook&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="460b0be997a504bd93f9a5f2102be17a4fe4f237" translate="yes" xml:space="preserve">
          <source>The alternate flag, &lt;code&gt;#&lt;/code&gt;, adds a &lt;code&gt;0b&lt;/code&gt; in front of the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b053ed1e6052a16bbf0f4a89d40e16ee9bf6a88d" translate="yes" xml:space="preserve">
          <source>The alternate flag, &lt;code&gt;#&lt;/code&gt;, adds a &lt;code&gt;0o&lt;/code&gt; in front of the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a67677d2b4895bdc1fb6847161bf39c61cb99f4" translate="yes" xml:space="preserve">
          <source>The alternate flag, &lt;code&gt;#&lt;/code&gt;, adds a &lt;code&gt;0x&lt;/code&gt; in front of the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11ba8acfe40883baf3a25418d4023d5eeae6eb43" translate="yes" xml:space="preserve">
          <source>The answer to this problem is the &lt;em&gt;Cargo.lock&lt;/em&gt; file, which was created the first time you ran &lt;code&gt;cargo build&lt;/code&gt; and is now in your &lt;em&gt;guessing_game&lt;/em&gt; directory. When you build a project for the first time, Cargo figures out all the versions of the dependencies that fit the criteria and then writes them to the &lt;em&gt;Cargo.lock&lt;/em&gt; file. When you build your project in the future, Cargo will see that the &lt;em&gt;Cargo.lock&lt;/em&gt; file exists and use the versions specified there rather than doing all the work of figuring out versions again. This lets you have a reproducible build automatically. In other words, your project will remain at &lt;code&gt;0.3.14&lt;/code&gt; until you explicitly upgrade, thanks to the &lt;em&gt;Cargo.lock&lt;/em&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d5e37bb48121061d7a9d1253e50cf299206b8ed" translate="yes" xml:space="preserve">
          <source>The argument, &lt;code&gt;mid&lt;/code&gt;, should be a byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="843c167795952476fd4949d773d09e67f37bae5c" translate="yes" xml:space="preserve">
          <source>The arguments will be formatted according to the specified format string into the output stream provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47d8ae2e6d2ad4b4b9256e9f4136431f5f0ee17f" translate="yes" xml:space="preserve">
          <source>The array index expression can be implemented for types other than arrays and slices by implementing the &lt;a href=&quot;../../std/ops/trait.index&quot;&gt;Index&lt;/a&gt; and &lt;a href=&quot;../../std/ops/trait.indexmut&quot;&gt;IndexMut&lt;/a&gt; traits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43b42b264d53f00eb4d50d966bdebfe503d9e502" translate="yes" xml:space="preserve">
          <source>The array named &lt;code&gt;a&lt;/code&gt; will contain &lt;code&gt;5&lt;/code&gt; elements that will all be set to the value &lt;code&gt;3&lt;/code&gt; initially. This is the same as writing &lt;code&gt;let a = [3, 3, 3, 3, 3];&lt;/code&gt; but in a more concise way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bda6f38466d2f9f90243514e2e1d1d622e872f82" translate="yes" xml:space="preserve">
          <source>The associated error which can be returned from parsing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95b071fe52a22a379b9072dba9b8116f1e91d5e0" translate="yes" xml:space="preserve">
          <source>The assumed lifetime of references held by a &lt;a href=&quot;types/trait-object&quot;&gt;trait object&lt;/a&gt; is called its &lt;em&gt;default object lifetime bound&lt;/em&gt;. These were defined in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md&quot;&gt;RFC 599&lt;/a&gt; and amended in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a633a670846190d4e317682018f539e771650d4" translate="yes" xml:space="preserve">
          <source>The atomic intrinsics provide common atomic operations on machine words, with multiple possible memory orderings. They obey the same semantics as C++11. See the LLVM documentation on [&lt;a href=&quot;http://llvm.org/docs/Atomics.html&quot;&gt;atomics&lt;/a&gt;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eacfc8c255cb1ef132a6a65b58c2019ebea9baf" translate="yes" xml:space="preserve">
          <source>The atomic types in this module may not be available on all platforms. The atomic types here are all widely available, however, and can generally be relied upon existing. Some notable exceptions are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5f89ad9ce66636388cf7509f930392e52eeb867" translate="yes" xml:space="preserve">
          <source>The attribute consists of a path to the attribute, followed by an optional delimited token tree whose interpretation is defined by the attribute. Attributes other than macro attributes also allow the input to be an equals sign (&lt;code&gt;=&lt;/code&gt;) followed by a literal expression. See the &lt;a href=&quot;attributes#meta-item-attribute-syntax&quot;&gt;meta item syntax&lt;/a&gt; below for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b79be106b3314bbccaaacf6171952db704c5419b" translate="yes" xml:space="preserve">
          <source>The attribute is used on a &lt;code&gt;static&lt;/code&gt; item whose type implements the &lt;a href=&quot;https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html&quot;&gt;&lt;code&gt;GlobalAlloc&lt;/code&gt;&lt;/a&gt; trait. This type can be provided by an external library:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07001b94d9ec08710a57474a9ab6a5a7c57ed031" translate="yes" xml:space="preserve">
          <source>The attributes that have meaning on a block expression are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db84623389bc5fe968094b478ac6446a9f7cd32b" translate="yes" xml:space="preserve">
          <source>The attributes that have meaning on a function are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-export_name-attribute&quot;&gt;&lt;code&gt;export_name&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-link_section-attribute&quot;&gt;&lt;code&gt;link_section&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../abi#the-no_mangle-attribute&quot;&gt;&lt;code&gt;no_mangle&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-must_use-attribute&quot;&gt;&lt;code&gt;must_use&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../procedural-macros&quot;&gt;the procedural macro attributes&lt;/a&gt;, &lt;a href=&quot;../attributes/testing&quot;&gt;the testing attributes&lt;/a&gt;, and &lt;a href=&quot;../attributes/codegen#optimization-hints&quot;&gt;the optimization hint attributes&lt;/a&gt;. Functions also accept attributes macros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9286c2061446f78d1eb0dacb8ad2bed2198b3a3" translate="yes" xml:space="preserve">
          <source>The author of the code in Listing 14-4, which uses the &lt;code&gt;art&lt;/code&gt; crate, had to figure out that &lt;code&gt;PrimaryColor&lt;/code&gt; is in the &lt;code&gt;kinds&lt;/code&gt; module and &lt;code&gt;mix&lt;/code&gt; is in the &lt;code&gt;utils&lt;/code&gt; module. The module structure of the &lt;code&gt;art&lt;/code&gt; crate is more relevant to developers working on the &lt;code&gt;art&lt;/code&gt; crate than to developers using the &lt;code&gt;art&lt;/code&gt; crate. The internal structure that organizes parts of the crate into the &lt;code&gt;kinds&lt;/code&gt; module and the &lt;code&gt;utils&lt;/code&gt; module doesn&amp;rsquo;t contain any useful information for someone trying to understand how to use the &lt;code&gt;art&lt;/code&gt; crate. Instead, the &lt;code&gt;art&lt;/code&gt; crate&amp;rsquo;s module structure causes confusion because developers have to figure out where to look, and the structure is inconvenient because developers must specify the module names in the &lt;code&gt;use&lt;/code&gt; statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8ebf8e3de6c2376fc1a32c2614c0e8023f7f60e" translate="yes" xml:space="preserve">
          <source>The author of this code probably wants &lt;code&gt;collect()&lt;/code&gt; to return a &lt;code&gt;Result&amp;lt;Vec&amp;lt;bool&amp;gt;, ()&amp;gt;&lt;/code&gt;, but the compiler can't be sure that there isn't another type &lt;code&gt;T&lt;/code&gt; implementing both &lt;code&gt;Try&lt;/code&gt; and &lt;code&gt;FromIterator&amp;lt;Result&amp;lt;bool, ()&amp;gt;&amp;gt;&lt;/code&gt; in scope such that &lt;code&gt;T::Ok == Vec&amp;lt;bool&amp;gt;&lt;/code&gt;. Hence, this code is ambiguous and an error is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="442e142fa9a496c6c2ff3a02ee78aa50e228d6e4" translate="yes" xml:space="preserve">
          <source>The bad state is not something that&amp;rsquo;s &lt;em&gt;expected&lt;/em&gt; to happen occasionally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1030d03bed1910f08091eb456180338b656dc0aa" translate="yes" xml:space="preserve">
          <source>The base of a &lt;a href=&quot;expressions/struct-expr#functional-update-syntax&quot;&gt;functional update&lt;/a&gt; struct expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1da424ed8fd790e722f71cc50f820022f89f696b" translate="yes" xml:space="preserve">
          <source>The behavior of the returned &lt;code&gt;Waker&lt;/code&gt; is undefined if the contract defined in &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;'s and &lt;a href=&quot;struct.rawwakervtable&quot;&gt;&lt;code&gt;RawWakerVTable&lt;/code&gt;&lt;/a&gt;'s documentation is not upheld. Therefore this method is unsafe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7f5bfcda53c0f0ccac4fbf04091f03de55bc719" translate="yes" xml:space="preserve">
          <source>The behavior of this method must be independent of the state of the &lt;code&gt;Read&lt;/code&gt;er - the method only takes &lt;code&gt;&amp;amp;self&lt;/code&gt; so that it can be used through trait objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92a385c5078364ae9300fa907e25a19462c00810" translate="yes" xml:space="preserve">
          <source>The benefit of having this restriction is that Rust can prevent data races at compile time. A &lt;em&gt;data race&lt;/em&gt; is similar to a race condition and happens when these three behaviors occur:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94345eda8bccf9faca124acc23e9dfc7f68245ec" translate="yes" xml:space="preserve">
          <source>The bits that define the access mode are masked out with &lt;code&gt;O_ACCMODE&lt;/code&gt;, to ensure they do not interfere with the access mode set by Rusts options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaa8e0a3053148a58d441c5d948ef0afd09016e9" translate="yes" xml:space="preserve">
          <source>The bitwise AND assignment operator &lt;code&gt;&amp;amp;=&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dd8ef8a8d73fdf98095248d6c0b2047cb203cf0" translate="yes" xml:space="preserve">
          <source>The bitwise AND operator &lt;code&gt;&amp;amp;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bfdab4f43dd337afc8fc0552897bf0d88f4fb0e" translate="yes" xml:space="preserve">
          <source>The bitwise OR assignment operator &lt;code&gt;|=&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a78ed80e19856e33ead5257328ef19e1b110eb08" translate="yes" xml:space="preserve">
          <source>The bitwise OR operator &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eafeed4a6ad02f43abd1d07f62b4dea554b3a79c" translate="yes" xml:space="preserve">
          <source>The bitwise XOR assignment operator &lt;code&gt;^=&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e805a1bbc089611af418b7bd9e638939dac553c5" translate="yes" xml:space="preserve">
          <source>The bitwise XOR operator &lt;code&gt;^&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="423b8775203e06b0ca354c4f4e97825a7d00a713" translate="yes" xml:space="preserve">
          <source>The block of a function is conceptually wrapped in a block that binds the argument patterns and then &lt;code&gt;return&lt;/code&gt;s the value of the function's block. This means that the tail expression of the block, if evaluated, ends up being returned to the caller. As usual, an explicit return expression within the body of the function will short-cut that implicit return, if reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="761ca0a326eb25085e5f1ebfbcef3b94f323b7c7" translate="yes" xml:space="preserve">
          <source>The block's size must fall in the range &lt;code&gt;[use_min, use_max]&lt;/code&gt;, where:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d55dd5d42feb75840d81a2ee396cf125ff6a36f" translate="yes" xml:space="preserve">
          <source>The block's starting address must be aligned to &lt;code&gt;layout.align()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fb5efe10f486c51a18bce4f54350dd31c9d18ad" translate="yes" xml:space="preserve">
          <source>The bodies of the &lt;code&gt;if let&lt;/code&gt; and the &lt;code&gt;unwrap_or_else&lt;/code&gt; functions are the same in both cases: we print the error and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d22837f9a0a24391528e1a0b3b2365c1d2579bc" translate="yes" xml:space="preserve">
          <source>The body of the function starts by calling the &lt;code&gt;File::open&lt;/code&gt; function. Then we handle the &lt;code&gt;Result&lt;/code&gt; value returned with a &lt;code&gt;match&lt;/code&gt; similar to the &lt;code&gt;match&lt;/code&gt; in Listing 9-4, only instead of calling &lt;code&gt;panic!&lt;/code&gt; in the &lt;code&gt;Err&lt;/code&gt; case, we return early from this function and pass the error value from &lt;code&gt;File::open&lt;/code&gt; back to the calling code as this function&amp;rsquo;s error value. If &lt;code&gt;File::open&lt;/code&gt; succeeds, we store the file handle in the variable &lt;code&gt;f&lt;/code&gt; and continue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba4d0e4523a23a56b57272682f48b03a790c657" translate="yes" xml:space="preserve">
          <source>The body of the method would use &lt;code&gt;self&lt;/code&gt; to get the value that we called the method on. In this example, we&amp;rsquo;ve created a variable &lt;code&gt;m&lt;/code&gt; that has the value &lt;code&gt;Message::Write(String::from(&quot;hello&quot;))&lt;/code&gt;, and that is what &lt;code&gt;self&lt;/code&gt; will be in the body of the &lt;code&gt;call&lt;/code&gt; method when &lt;code&gt;m.call()&lt;/code&gt; runs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c00fd6128e2bdd1cc90bd415df84de85499f4fb" translate="yes" xml:space="preserve">
          <source>The book &lt;em&gt;Design Patterns: Elements of Reusable Object-Oriented Software&lt;/em&gt; by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (Addison-Wesley Professional, 1994) colloquially referred to as &lt;em&gt;The Gang of Four&lt;/em&gt; book, is a catalog of object-oriented design patterns. It defines OOP this way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ab81c05a8d6cbaec3e9dfb9c8caa2a16dab19bf" translate="yes" xml:space="preserve">
          <source>The boolean type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06283747a377154700dbba912c9e77d60011a87e" translate="yes" xml:space="preserve">
          <source>The borrow lasts until the returned &lt;code&gt;Ref&lt;/code&gt; exits scope. Multiple immutable borrows can be taken out at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45376451530857b96a10ec4a5e20bb51cfc0ed12" translate="yes" xml:space="preserve">
          <source>The borrow lasts until the returned &lt;code&gt;RefMut&lt;/code&gt; or all &lt;code&gt;RefMut&lt;/code&gt;s derived from it exit scope. The value cannot be borrowed while this borrow is active.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f968733bf846dacfb002493e18e27a27864a5d95" translate="yes" xml:space="preserve">
          <source>The buffer is written out before returning the writer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d2f5c9c4df44bd26200b02c526dd9675a0b62ea" translate="yes" xml:space="preserve">
          <source>The buffer specified was 0 bytes in length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aac2e47b3535d051db39f7a14fa1dba18fc6a121" translate="yes" xml:space="preserve">
          <source>The built-in &lt;code&gt;cfg&lt;/code&gt; macro takes in a single configuration predicate and evaluates to the &lt;code&gt;true&lt;/code&gt; literal when the predicate is true and the &lt;code&gt;false&lt;/code&gt; literal when it is false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87ae881f172e3eab463a1dba119d942ed8deaed7" translate="yes" xml:space="preserve">
          <source>The built-in attributes that have meaning on a function are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;, &lt;code&gt;path&lt;/code&gt;, and &lt;code&gt;no_implicit_prelude&lt;/code&gt;. Modules also accept macro attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7917b1e20d5567c345241cec71cc654edebdd434" translate="yes" xml:space="preserve">
          <source>The built-in function traits are generic over a tuple of the function arguments. If one uses angle-bracket notation (&lt;code&gt;Fn&amp;lt;(T,), Output=U&amp;gt;&lt;/code&gt;) instead of parentheses (&lt;code&gt;Fn(T) -&amp;gt; U&lt;/code&gt;) to denote the function trait, the type parameter should be a tuple. Otherwise function call notation cannot be used and the trait will not be implemented by closures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e1ef14ad9c5016cccb06e0dae0b41ca0441837" translate="yes" xml:space="preserve">
          <source>The c-main function only supports to return integers as return type. So, every type implementing the &lt;code&gt;Termination&lt;/code&gt; trait has to be converted to an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98a1e057ef0866ad400391fbf23a2daa11b28012" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;lock&lt;/code&gt; would fail if another thread holding the lock panicked. In that case, no one would ever be able to get the lock, so we&amp;rsquo;ve chosen to &lt;code&gt;unwrap&lt;/code&gt; and have this thread panic if we&amp;rsquo;re in that situation.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
