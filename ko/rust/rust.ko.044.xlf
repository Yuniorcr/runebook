<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="ee713135dbae7e11e49962ea65b30c33678861ed" translate="yes" xml:space="preserve">
          <source>An entity already exists, often a file.</source>
          <target state="translated">엔티티가 이미 존재하며 종종 파일입니다.</target>
        </trans-unit>
        <trans-unit id="2db4e2025a972767c9444bca8e88e9a77524203e" translate="yes" xml:space="preserve">
          <source>An entity was not found, often a file.</source>
          <target state="translated">엔티티는 발견되지 않았으며 종종 파일이었습니다.</target>
        </trans-unit>
        <trans-unit id="c5a4a196ff419cb4ace58ac8718f985652b454f9" translate="yes" xml:space="preserve">
          <source>An enum with the representation hint &lt;code&gt;repr(transparent)&lt;/code&gt; had zero or more than one variants.</source>
          <target state="translated">표현 힌트 &lt;code&gt;repr(transparent)&lt;/code&gt; 가 있는 열거 형 에는 0 개 이상의 변형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3dc999ff5594fd4673ff8dbd7678f9024bdecf27" translate="yes" xml:space="preserve">
          <source>An enumeration of possible errors associated with a &lt;a href=&quot;type.trylockresult&quot;&gt;&lt;code&gt;TryLockResult&lt;/code&gt;&lt;/a&gt; which can occur while trying to acquire a lock, from the &lt;a href=&quot;struct.mutex#method.try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;struct.rwlock#method.try_read&quot;&gt;&lt;code&gt;try_read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.rwlock#method.try_write&quot;&gt;&lt;code&gt;try_write&lt;/code&gt;&lt;/a&gt; methods on an &lt;a href=&quot;struct.rwlock&quot;&gt;&lt;code&gt;RwLock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">과 관련된 잠재적 인 오류의리스트 &lt;a href=&quot;type.trylockresult&quot;&gt; &lt;code&gt;TryLockResult&lt;/code&gt; &lt;/a&gt; 로부터, 잠금을 획득하려고 시도하는 동안 발생할 수 &lt;a href=&quot;struct.mutex#method.try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; 의&lt;/a&gt; A의 방법 &lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;struct.rwlock#method.try_read&quot;&gt; &lt;code&gt;try_read&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.rwlock#method.try_write&quot;&gt; &lt;code&gt;try_write&lt;/code&gt; &lt;/a&gt; 온 방법 &lt;a href=&quot;struct.rwlock&quot;&gt; &lt;code&gt;RwLock&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="09fd334e73fd76483600e0a3e0818465278a8c4f" translate="yes" xml:space="preserve">
          <source>An error indicating invalid UTF-8 when converting a &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; &lt;/a&gt; 을 &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 으로 변환 할 때 유효하지 않은 UTF-8을 나타내는 오류가 발생했습니다 .</target>
        </trans-unit>
        <trans-unit id="7e00442ed63dafefaa24c2855dc12cc641d5d806" translate="yes" xml:space="preserve">
          <source>An error indicating that a nul byte was not in the expected position.</source>
          <target state="translated">널 바이트가 예상 위치에 없었 음을 나타내는 오류.</target>
        </trans-unit>
        <trans-unit id="607c0a59f40344c6d402da3d92f1e4d75c5c8d03" translate="yes" xml:space="preserve">
          <source>An error indicating that an interior nul byte was found.</source>
          <target state="translated">내부 널 바이트를 찾았 음을 나타내는 오류.</target>
        </trans-unit>
        <trans-unit id="2239ba3f9f1a9c04aabf258d44bc7c635e911959" translate="yes" xml:space="preserve">
          <source>An error of the &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is non-fatal and the read operation should be retried if there is nothing else to do.</source>
          <target state="translated">&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류 의 오류는 치명적이지 않으며 다른 작업이 없으면 읽기 작업을 다시 시도해야합니다.</target>
        </trans-unit>
        <trans-unit id="ff800591cb202807f317ec28fbc572d02357615d" translate="yes" xml:space="preserve">
          <source>An error of the &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind is non-fatal and the write operation should be retried if there is nothing else to do.</source>
          <target state="translated">&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류 의 오류는 치명적이지 않으며 다른 작업이 없으면 쓰기 작업을 다시 시도해야합니다.</target>
        </trans-unit>
        <trans-unit id="b6ad7c556d901c0beffc94b348b6d4d9e1e99f53" translate="yes" xml:space="preserve">
          <source>An error returned by &lt;a href=&quot;struct.localkey#method.try_with&quot;&gt;&lt;code&gt;LocalKey::try_with&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.localkey#method.try_with&quot;&gt; &lt;code&gt;LocalKey::try_with&lt;/code&gt; &lt;/a&gt; 오류를 반환했습니다 .</target>
        </trans-unit>
        <trans-unit id="4a2bb23cc4bff912e225e8d82c808ebe1116d273" translate="yes" xml:space="preserve">
          <source>An error returned by &lt;a href=&quot;struct.refcell#method.try_borrow&quot;&gt;&lt;code&gt;RefCell::try_borrow&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.refcell#method.try_borrow&quot;&gt; &lt;code&gt;RefCell::try_borrow&lt;/code&gt; &lt;/a&gt; 오류를 반환했습니다 .</target>
        </trans-unit>
        <trans-unit id="49b49c608a0a48a5c64a8db743785c3d4f2cbc87" translate="yes" xml:space="preserve">
          <source>An error returned by &lt;a href=&quot;struct.refcell#method.try_borrow_mut&quot;&gt;&lt;code&gt;RefCell::try_borrow_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.refcell#method.try_borrow_mut&quot;&gt; &lt;code&gt;RefCell::try_borrow_mut&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 오류 .</target>
        </trans-unit>
        <trans-unit id="6a9d323634dc21ac2ba61947c9f4ada5b0523975" translate="yes" xml:space="preserve">
          <source>An error returned by &lt;code&gt;into_inner&lt;/code&gt; which combines an error that happened while writing out the buffer, and the buffered writer object which may be used to recover from the condition.</source>
          <target state="translated">버퍼를 쓰는 동안 발생한 오류와 조건에서 복구하는 데 사용할 수있는 버퍼 된 기록기 개체를 결합한 &lt;code&gt;into_inner&lt;/code&gt; 에서 반환 된 오류입니다.</target>
        </trans-unit>
        <trans-unit id="408e9c71ed3bc2aa80ae9ddbf31a37ecbe128d0c" translate="yes" xml:space="preserve">
          <source>An error returned from &lt;a href=&quot;struct.path#method.strip_prefix&quot;&gt;&lt;code&gt;Path::strip_prefix&lt;/code&gt;&lt;/a&gt; if the prefix was not found.</source>
          <target state="translated">접두사가없는 경우 &lt;a href=&quot;struct.path#method.strip_prefix&quot;&gt; &lt;code&gt;Path::strip_prefix&lt;/code&gt; &lt;/a&gt; 에서 오류가 리턴 되었습니다.</target>
        </trans-unit>
        <trans-unit id="788504f3aa85eadb6d0636b88bca37c397dba8e3" translate="yes" xml:space="preserve">
          <source>An error returned from the &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; function on a &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt; 함수 에서 오류가 리턴되었습니다 .</target>
        </trans-unit>
        <trans-unit id="9fec5ed88196e94f3e7939be6668b9ce8dfe54d0" translate="yes" xml:space="preserve">
          <source>An error returned from the &lt;a href=&quot;struct.sender#method.send&quot;&gt;&lt;code&gt;Sender::send&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.syncsender#method.send&quot;&gt;&lt;code&gt;SyncSender::send&lt;/code&gt;&lt;/a&gt; function on &lt;strong&gt;channel&lt;/strong&gt;s.</source>
          <target state="translated">&lt;strong&gt;채널&lt;/strong&gt; s 의 &lt;a href=&quot;struct.sender#method.send&quot;&gt; &lt;code&gt;Sender::send&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;struct.syncsender#method.send&quot;&gt; &lt;code&gt;SyncSender::send&lt;/code&gt; &lt;/a&gt; 함수에서 오류가 리턴되었습니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b947bf8292263975edc2c833eac5521f6b3d5e94" translate="yes" xml:space="preserve">
          <source>An error returned from the &lt;code&gt;duration_since&lt;/code&gt; and &lt;code&gt;elapsed&lt;/code&gt; methods on &lt;code&gt;SystemTime&lt;/code&gt;, used to learn how far in the opposite direction a system time lies.</source>
          <target state="translated">&lt;code&gt;SystemTime&lt;/code&gt; 의 &lt;code&gt;duration_since&lt;/code&gt; 및 &lt;code&gt;elapsed&lt;/code&gt; 메소드에서 리턴 된 오류로 , 시스템 시간이 반대 방향으로 얼마나 멀리 있는지 알아 내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f51f86543e577fd1d558ef170de94a1b52743f0b" translate="yes" xml:space="preserve">
          <source>An error returned when an operation could not be completed because a call to &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; returned &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 호출이 &lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;Ok(0)&lt;/code&gt; &lt;/a&gt; 리턴 하여 조작을 완료 할 수없는 경우 오류가 리턴되었습니다 .</target>
        </trans-unit>
        <trans-unit id="b05482ca3068a6de89ef72655084867c49191841" translate="yes" xml:space="preserve">
          <source>An error returned when an operation could not be completed because an &quot;end of file&quot; was reached prematurely.</source>
          <target state="translated">&quot;파일 끝&quot;에 일찍 도달하여 작업을 완료 할 수 없을 때 오류가 반환되었습니다.</target>
        </trans-unit>
        <trans-unit id="9c4fdb1f9f1ace5ab60797b01c282f3c5da7046e" translate="yes" xml:space="preserve">
          <source>An error returned when parsing a &lt;code&gt;bool&lt;/code&gt; using &lt;a href=&quot;../primitive.bool#method.from_str&quot;&gt;&lt;code&gt;from_str&lt;/code&gt;&lt;/a&gt; fails</source>
          <target state="translated">파싱 할 때 오류가 반환 &lt;code&gt;bool&lt;/code&gt; 사용하여 &lt;a href=&quot;../primitive.bool#method.from_str&quot;&gt; &lt;code&gt;from_str&lt;/code&gt; 가&lt;/a&gt; 실패</target>
        </trans-unit>
        <trans-unit id="01956aad1d91d0a3eaa910ec372ba76608859bfc" translate="yes" xml:space="preserve">
          <source>An error that can be returned when decoding UTF-16 code points.</source>
          <target state="translated">UTF-16 코드 포인트를 디코딩 할 때 리턴 될 수있는 오류입니다.</target>
        </trans-unit>
        <trans-unit id="3533bcb297f1b2a750fb10891e22e5dd49940449" translate="yes" xml:space="preserve">
          <source>An error when parsing a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 구문 분석시 오류가 발생했습니다 .</target>
        </trans-unit>
        <trans-unit id="a8c4d17e195207f5a989ac26b5a78606dcbba09d" translate="yes" xml:space="preserve">
          <source>An error which can be returned when parsing a char.</source>
          <target state="translated">문자를 구문 분석 할 때 리턴 될 수있는 오류입니다.</target>
        </trans-unit>
        <trans-unit id="6080f2ccd647721dacbdd21e9d94b2a3bec77e1f" translate="yes" xml:space="preserve">
          <source>An error which can be returned when parsing a float.</source>
          <target state="translated">float를 구문 분석 할 때 리턴 될 수있는 오류입니다.</target>
        </trans-unit>
        <trans-unit id="8d76e3522dda33b8ed78bf99a4c5562182d54f08" translate="yes" xml:space="preserve">
          <source>An error which can be returned when parsing an IP address or a socket address.</source>
          <target state="translated">IP 주소 또는 소켓 주소를 구문 분석 할 때 리턴 될 수있는 오류입니다.</target>
        </trans-unit>
        <trans-unit id="c7b106b5fd117686f0aceb67097fd3cef2a189bf" translate="yes" xml:space="preserve">
          <source>An error which can be returned when parsing an integer.</source>
          <target state="translated">정수를 구문 분석 할 때 리턴 될 수있는 오류입니다.</target>
        </trans-unit>
        <trans-unit id="1d7c5a9fd1d469b89a9d56899ca1f50026a1dd32" translate="yes" xml:space="preserve">
          <source>An example implementation for a domain in which two books are considered the same book if their ISBN matches, even if the formats differ:</source>
          <target state="translated">형식이 다르더라도 ISBN이 일치하면 두 권의 책이 동일한 책으로 간주되는 도메인의 구현 예 :</target>
        </trans-unit>
        <trans-unit id="68ff7c567c0520a3da56cf3b0e9741fe24004f8f" translate="yes" xml:space="preserve">
          <source>An example implementation of the trait:</source>
          <target state="translated">특성의 구현 예 :</target>
        </trans-unit>
        <trans-unit id="28b14342433cafd1cb0863789fedb01f7530bff9" translate="yes" xml:space="preserve">
          <source>An example is a generic struct holding a function pointer. In this case, the implementation of &lt;code&gt;Clone&lt;/code&gt; cannot be &lt;code&gt;derive&lt;/code&gt;d, but can be implemented as:</source>
          <target state="translated">함수 포인터를 보유한 일반 구조체가 그 예입니다. 이 경우 &lt;code&gt;Clone&lt;/code&gt; 구현을 &lt;code&gt;derive&lt;/code&gt; 시킬 수 없지만 다음 과 같이 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da1a4e43cf80966a8d5beb99e7207867287f3da9" translate="yes" xml:space="preserve">
          <source>An example of &lt;code&gt;use&lt;/code&gt; declarations:</source>
          <target state="translated">&lt;code&gt;use&lt;/code&gt; 선언 의 예 :</target>
        </trans-unit>
        <trans-unit id="f512d81d83647ae47cd90bcb76d95f7b8768001b" translate="yes" xml:space="preserve">
          <source>An example of a &lt;code&gt;for&lt;/code&gt; loop over the contents of an array:</source>
          <target state="translated">배열의 내용에 &lt;code&gt;for&lt;/code&gt; 루프 의 예 :</target>
        </trans-unit>
        <trans-unit id="fee9699f2c385a5203b6e01e13cf6011f2fcd8a4" translate="yes" xml:space="preserve">
          <source>An example of a &lt;code&gt;match&lt;/code&gt; expression:</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 표현식 의 예 :</target>
        </trans-unit>
        <trans-unit id="cfd1afa80d53786d32ba47458c2ed4379f4003bf" translate="yes" xml:space="preserve">
          <source>An example of a &lt;code&gt;return&lt;/code&gt; expression:</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; 표현식 의 예 :</target>
        </trans-unit>
        <trans-unit id="9c5bf1e5202001a02f36098e504bd7cb0fe28030" translate="yes" xml:space="preserve">
          <source>An example of a &lt;code&gt;struct&lt;/code&gt; item and its use:</source>
          <target state="translated">(A)의 예 &lt;code&gt;struct&lt;/code&gt; 항목의 사용 :</target>
        </trans-unit>
        <trans-unit id="3c2199ab0dce170bc0714704fc232fd68c69b281" translate="yes" xml:space="preserve">
          <source>An example of a &lt;em&gt;recursive&lt;/em&gt; type and its use:</source>
          <target state="translated">(A)의 예 &lt;em&gt;재귀&lt;/em&gt; 유형과 사용 :</target>
        </trans-unit>
        <trans-unit id="0f62525fdcd99f7d466515d9585c0c13357e1b2b" translate="yes" xml:space="preserve">
          <source>An example of a common associated function is a &lt;code&gt;new&lt;/code&gt; function that returns a value of the type the associated function is associated with.</source>
          <target state="translated">공통 연관된 함수의 예는 연관된 함수 와 연관된 유형의 값을 리턴하는 &lt;code&gt;new&lt;/code&gt; 함수입니다.</target>
        </trans-unit>
        <trans-unit id="6a351aa1ff4672ddb51a26e9d5f1e845614b350b" translate="yes" xml:space="preserve">
          <source>An example of a for loop over a series of integers:</source>
          <target state="translated">일련의 정수에 대한 for 루프의 예 :</target>
        </trans-unit>
        <trans-unit id="9bcd2ce89adc17fbe7648c05a09884aa0d701978" translate="yes" xml:space="preserve">
          <source>An example of a module:</source>
          <target state="translated">모듈의 예 :</target>
        </trans-unit>
        <trans-unit id="8e8435c013addb39ce3eb498c3c558d414e6f6ad" translate="yes" xml:space="preserve">
          <source>An example of a necessary use of parentheses is when calling a function pointer that is a member of a struct:</source>
          <target state="translated">필요한 괄호 사용 예는 구조체의 멤버 인 함수 포인터를 호출 할 때입니다.</target>
        </trans-unit>
        <trans-unit id="056ff1cdb43a917deab8c9dc0f118b2d9dd496e8" translate="yes" xml:space="preserve">
          <source>An example of a non-&lt;code&gt;Send&lt;/code&gt; type is the reference-counting pointer &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;rc::Rc&lt;/code&gt;&lt;/a&gt;. If two threads attempt to clone &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;s that point to the same reference-counted value, they might try to update the reference count at the same time, which is &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; because &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; doesn't use atomic operations. Its cousin &lt;a href=&quot;../sync/struct.arc&quot;&gt;&lt;code&gt;sync::Arc&lt;/code&gt;&lt;/a&gt; does use atomic operations (incurring some overhead) and thus is &lt;code&gt;Send&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Send&lt;/code&gt; 유형이 아닌 예는 참조 카운팅 포인터 &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;rc::Rc&lt;/code&gt; &lt;/a&gt; 입니다. 두 개의 스레드 가 동일한 참조 횟수 값을 가리키는 &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 를 복제하려고 하면 동시에 참조 횟수를 업데이트하려고 시도 할 수 있습니다. 이는 &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 가 원자 연산을 사용하지 않기 때문에 &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;정의되지 않은 동작&lt;/a&gt; 입니다. 사촌 &lt;a href=&quot;../sync/struct.arc&quot;&gt; &lt;code&gt;sync::Arc&lt;/code&gt; &lt;/a&gt; 는 원자 적 연산 (일부 오버 헤드가 발생 함)을 사용하므로 &lt;code&gt;Send&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e38ec369f62f9a0e9cf71faa19b5cb843376b06e" translate="yes" xml:space="preserve">
          <source>An example of a parenthesized expression:</source>
          <target state="translated">괄호로 묶은 표현식의 예 :</target>
        </trans-unit>
        <trans-unit id="f06523b9f614521a822acb49c6502314b5223a29" translate="yes" xml:space="preserve">
          <source>An example of a trait object:</source>
          <target state="translated">특성 오브젝트의 예 :</target>
        </trans-unit>
        <trans-unit id="f97a42d4af253ea16c2f098f9cd1358538ff9ccc" translate="yes" xml:space="preserve">
          <source>An example of a trait that can&amp;rsquo;t be derived is &lt;code&gt;Display&lt;/code&gt;, which handles formatting for end users. You should always consider the appropriate way to display a type to an end user. What parts of the type should an end user be allowed to see? What parts would they find relevant? What format of the data would be most relevant to them? The Rust compiler doesn&amp;rsquo;t have this insight, so it can&amp;rsquo;t provide appropriate default behavior for you.</source>
          <target state="translated">파생 될 수없는 특성의 예는 최종 사용자의 형식을 처리하는 &lt;code&gt;Display&lt;/code&gt; 입니다. 최종 사용자에게 유형을 표시하는 적절한 방법을 항상 고려해야합니다. 최종 사용자는 어떤 유형의 부분을 볼 수 있어야합니까? 어떤 부분이 관련이 있습니까? 어떤 형식의 데이터가 가장 관련이 있습니까? Rust 컴파일러는 이러한 통찰력을 가지고 있지 않으므로 적절한 기본 동작을 제공 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b2a6dc626aff375aa4d434c66ea264d4dc08b800" translate="yes" xml:space="preserve">
          <source>An example of a trait whose methods are not object safe is the standard library&amp;rsquo;s &lt;code&gt;Clone&lt;/code&gt; trait. The signature for the &lt;code&gt;clone&lt;/code&gt; method in the &lt;code&gt;Clone&lt;/code&gt; trait looks like this:</source>
          <target state="translated">메소드가 객체 안전하지 않은 특성의 예는 표준 라이브러리의 &lt;code&gt;Clone&lt;/code&gt; 특성입니다. &lt;code&gt;Clone&lt;/code&gt; 특성 에서 &lt;code&gt;clone&lt;/code&gt; 방법 의 서명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5e81f6611106899f0be7f5a0792978a45ad55dd8" translate="yes" xml:space="preserve">
          <source>An example of a tuple type and its use:</source>
          <target state="translated">튜플 유형 및 사용 예 :</target>
        </trans-unit>
        <trans-unit id="363c341cbe13044b212571253c8a33caae78cd45" translate="yes" xml:space="preserve">
          <source>An example of an &lt;code&gt;as&lt;/code&gt; expression:</source>
          <target state="translated">&lt;code&gt;as&lt;/code&gt; 표현식 의 예 :</target>
        </trans-unit>
        <trans-unit id="a2db905e306fb4833044bdd9885bb27ab8f76d7f" translate="yes" xml:space="preserve">
          <source>An example of an &lt;code&gt;enum&lt;/code&gt; item and its use:</source>
          <target state="translated">의 예를 &lt;code&gt;enum&lt;/code&gt; 항목의 사용 :</target>
        </trans-unit>
        <trans-unit id="9260a714aba6105dd14cba9d58f3d41f31de6503" translate="yes" xml:space="preserve">
          <source>An example of an empty type is &lt;code&gt;enum Empty { }&lt;/code&gt;. So, the following will work:</source>
          <target state="translated">빈 유형의 예는 &lt;code&gt;enum Empty { }&lt;/code&gt; 입니다. 따라서 다음이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ff969b10a01ab50464488192aa66638be2ebf171" translate="yes" xml:space="preserve">
          <source>An example of combining the above rules of &lt;code&gt;path&lt;/code&gt; attributes on inline modules and nested modules within (applies to both mod-rs and non-mod-rs files):</source>
          <target state="translated">인라인 모듈과 중첩 된 모듈에서 위의 &lt;code&gt;path&lt;/code&gt; 속성 규칙을 결합하는 예 (mod-rs 및 non-mod-rs 파일 모두에 적용) :</target>
        </trans-unit>
        <trans-unit id="6e09c1385fee93fd5fa2b4010458a4fc489b7a97" translate="yes" xml:space="preserve">
          <source>An example of implementing the formatting traits would look like:</source>
          <target state="translated">서식 특성을 구현하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fa098562087edb062353d3aa89708207a19b395b" translate="yes" xml:space="preserve">
          <source>An example of matching non-exhaustively on the above enum is provided below:</source>
          <target state="translated">위 열거 형에서 철저하게 일치하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7ef19768d994b2224d1f41bd49faef1709c5e7ef" translate="yes" xml:space="preserve">
          <source>An example of panic:</source>
          <target state="translated">공황의 예 :</target>
        </trans-unit>
        <trans-unit id="884b0dfdd5d082bb94960ecce28dc9f3e6d384f8" translate="yes" xml:space="preserve">
          <source>An example of re-exporting:</source>
          <target state="translated">다시 내보내기의 예 :</target>
        </trans-unit>
        <trans-unit id="708c005211a8b1e93ec9aac2ad4a16e9c3bc2bc3" translate="yes" xml:space="preserve">
          <source>An example of this error:</source>
          <target state="translated">이 오류의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="64eb812bfe0819a20f7b7755d2742025cd360a65" translate="yes" xml:space="preserve">
          <source>An example of what will and will not work for &lt;code&gt;use&lt;/code&gt; items:</source>
          <target state="translated">&lt;code&gt;use&lt;/code&gt; 항목에 대해 작동 하거나 작동하지 않는 예 :</target>
        </trans-unit>
        <trans-unit id="8365f135946b3f7b044d8cfd3fa7997f776027f4" translate="yes" xml:space="preserve">
          <source>An example of when &lt;code&gt;Clone&lt;/code&gt; is required is when calling the &lt;code&gt;to_vec&lt;/code&gt; method on a slice. The slice doesn&amp;rsquo;t own the type instances it contains, but the vector returned from &lt;code&gt;to_vec&lt;/code&gt; will need to own its instances, so &lt;code&gt;to_vec&lt;/code&gt; calls &lt;code&gt;clone&lt;/code&gt; on each item. Thus, the type stored in the slice must implement &lt;code&gt;Clone&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Clone&lt;/code&gt; 가 필요한 경우의 예 는 슬라이스 에서 &lt;code&gt;to_vec&lt;/code&gt; 메소드를 호출 할 때 입니다. 슬라이스는 포함 된 형식 인스턴스를 소유하지 않지만 &lt;code&gt;to_vec&lt;/code&gt; 에서 반환 된 벡터는 해당 인스턴스를 소유해야하므로 &lt;code&gt;to_vec&lt;/code&gt; 호출 은 각 항목에서 &lt;code&gt;clone&lt;/code&gt; 을 호출합니다 . 따라서 슬라이스에 저장된 유형은 &lt;code&gt;Clone&lt;/code&gt; 을 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="aaf3c4aa1a7d59f2304836782308596d0ae75f64" translate="yes" xml:space="preserve">
          <source>An example of when &lt;code&gt;Eq&lt;/code&gt; is required is for keys in a &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; so the &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; can tell whether two keys are the same.</source>
          <target state="translated">&lt;code&gt;Eq&lt;/code&gt; 가 필요한 경우의 예는 &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; 키에 대한 것이므로 &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; 는 두 키가 동일한 지 여부를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e410ff694a089e824c24843049bae108ce880220" translate="yes" xml:space="preserve">
          <source>An example of when &lt;code&gt;Hash&lt;/code&gt; is required is in storing keys in a &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; to store data efficiently.</source>
          <target state="translated">&lt;code&gt;Hash&lt;/code&gt; 가 필요한 경우의 예는 데이터를 효율적으로 저장하기 위해 &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; 를 저장하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="13874d9be8af151d397c4923d18c3e3bb505d451" translate="yes" xml:space="preserve">
          <source>An example of when &lt;code&gt;Ord&lt;/code&gt; is required is when storing values in a &lt;code&gt;BTreeSet&amp;lt;T&amp;gt;&lt;/code&gt;, a data structure that stores data based on the sort order of the values.</source>
          <target state="translated">&lt;code&gt;Ord&lt;/code&gt; 가 필요한 경우의 예는 값 의 정렬 순서에 따라 데이터를 저장하는 데이터 구조 인 &lt;code&gt;BTreeSet&amp;lt;T&amp;gt;&lt;/code&gt; 값을 저장하는 경우 입니다.</target>
        </trans-unit>
        <trans-unit id="f42b2c8e58eff03a7089947fa8ffae92137b9b5f" translate="yes" xml:space="preserve">
          <source>An example of when you might want to use an array rather than a vector is in a program that needs to know the names of the months of the year. It&amp;rsquo;s very unlikely that such a program will need to add or remove months, so you can use an array because you know it will always contain 12 items:</source>
          <target state="translated">벡터 대신 배열을 사용하려는 경우의 예는 연도의 이름을 알아야하는 프로그램에 있습니다. 그러한 프로그램이 몇 달을 추가하거나 제거해야 할 가능성은 거의 없으므로 항상 12 개의 항목을 포함한다는 것을 알고 있기 때문에 배열을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd0712d619a2d60e4c146e231ccdfbad8aba4743" translate="yes" xml:space="preserve">
          <source>An example of where you would want to only accept &lt;code&gt;fn&lt;/code&gt; and not closures is when interfacing with external code that doesn&amp;rsquo;t have closures: C functions can accept functions as arguments, but C doesn&amp;rsquo;t have closures.</source>
          <target state="translated">클로저가 아닌 &lt;code&gt;fn&lt;/code&gt; 만 허용하려는 위치의 예는 클로저가없는 외부 코드와 인터페이스 할 때입니다. C 함수는 함수를 인수로 받아 들일 수 있지만 C에는 클로저가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e73f9f6c8b4fbcf9f4fd470408b5fff3f081d3b9" translate="yes" xml:space="preserve">
          <source>An example using a closure:</source>
          <target state="translated">클로저를 사용하는 예 :</target>
        </trans-unit>
        <trans-unit id="6d3969065ec2f88aef65174e1f6ffa620b0c83f2" translate="yes" xml:space="preserve">
          <source>An example where &lt;code&gt;Binop&lt;/code&gt; is defined as a function pointer type:</source>
          <target state="translated">&lt;code&gt;Binop&lt;/code&gt; 이 함수 포인터 유형으로 정의 된 예 :</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">예를 들면 :</target>
        </trans-unit>
        <trans-unit id="9b338a4ae7f343a1618fa43d10bfc2df436ea62d" translate="yes" xml:space="preserve">
          <source>An exclusive bound.</source>
          <target state="translated">독점적 인 범위.</target>
        </trans-unit>
        <trans-unit id="0a0f5c759335e3ef134a90149eb082ea59cf661b" translate="yes" xml:space="preserve">
          <source>An executing Rust program consists of a collection of native OS threads, each with their own stack and local state. Threads can be named, and provide some built-in support for low-level synchronization.</source>
          <target state="translated">실행중인 Rust 프로그램은 각각 고유 한 스택 및 로컬 상태를 가진 기본 OS 스레드 모음으로 구성됩니다. 스레드의 이름을 지정할 수 있으며 저수준 동기화를위한 기본 지원 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="12c993ee363617797c480ae0e7fa61fa88f7540e" translate="yes" xml:space="preserve">
          <source>An explicit conversion from a &lt;code&gt;&amp;amp;str&lt;/code&gt; to a String is done as follows:</source>
          <target state="translated">&lt;code&gt;&amp;amp;str&lt;/code&gt; 에서 문자열로 의 명시 적 변환은 다음과 같이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="9863ad7a484538312614b219ee23d089bab88f2a" translate="yes" xml:space="preserve">
          <source>An expression enclosed in parentheses evaluates to the result of the enclosed expression. Parentheses can be used to explicitly specify evaluation order within an expression.</source>
          <target state="translated">괄호로 묶인 표현식은 포함 된 표현식의 결과로 평가됩니다. 괄호를 사용하여 표현식 내에서 평가 순서를 명시 적으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0b2d07f6ff343f37bbb2da0dbd07ed7ea53cb5d" translate="yes" xml:space="preserve">
          <source>An expression is a combination of values, constants, variables, operators and functions that evaluate to a single value, with or without side-effects.</source>
          <target state="translated">표현식은 부작용이 있거나없는 단일 값으로 평가되는 값, 상수, 변수, 연산자 및 함수의 조합입니다.</target>
        </trans-unit>
        <trans-unit id="8a470e20ec20f9f17fbbac4266c615aa43cc21c3" translate="yes" xml:space="preserve">
          <source>An expression may have two roles: it always produces a &lt;em&gt;value&lt;/em&gt;, and it may have &lt;em&gt;effects&lt;/em&gt; (otherwise known as &quot;side effects&quot;). An expression &lt;em&gt;evaluates to&lt;/em&gt; a value, and has effects during &lt;em&gt;evaluation&lt;/em&gt;. Many expressions contain sub-expressions (operands). The meaning of each kind of expression dictates several things:</source>
          <target state="translated">표현식에는 두 가지 역할이있을 수 있습니다. 항상 &lt;em&gt;값을&lt;/em&gt; 생성하고 &lt;em&gt;효과&lt;/em&gt; ( &quot;부작용&quot;이라고도 함) 가있을 수 있습니다 . 표현식 은 값으로 &lt;em&gt;평가되며 &lt;/em&gt;&lt;em&gt;평가&lt;/em&gt; 중에 영향을 미칩니다 . 많은 표현식에 하위 표현식 (피연산자)이 있습니다. 각 종류의 표현의 의미는 여러 가지를 지시합니다.</target>
        </trans-unit>
        <trans-unit id="894873bc5f587b4733b17f7dfb18b0f3059d2176" translate="yes" xml:space="preserve">
          <source>An expression that consists of only a &lt;a href=&quot;expressions/block-expr&quot;&gt;block expression&lt;/a&gt; or control flow expression, if used in a context where a statement is permitted, can omit the trailing semicolon. This can cause an ambiguity between it being parsed as a standalone statement and as a part of another expression; in this case, it is parsed as a statement. The type of &lt;a href=&quot;expressions&quot;&gt;&lt;em&gt;ExpressionWithBlock&lt;/em&gt;&lt;/a&gt; expressions when used as statements must be the unit type.</source>
          <target state="translated">명령문이 허용되는 컨텍스트에서 사용되는 경우 &lt;a href=&quot;expressions/block-expr&quot;&gt;블록 표현식&lt;/a&gt; 또는 제어 플로우 표현식 으로 만 구성된 표현식은 후미 세미콜론을 생략 할 수 있습니다. 이로 인해 독립형 명령문으로 구문 분석되고 다른 표현식의 일부로 모호해질 수 있습니다. 이 경우 설명으로 구문 분석됩니다. 명령문으로 사용될 때 &lt;a href=&quot;expressions&quot;&gt;&lt;em&gt;ExpressionWithBlock&lt;/em&gt;&lt;/a&gt; 표현식 의 유형은 단위 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="3db9b6e5300ec2a35e045cae789d7d65bc1644c2" translate="yes" xml:space="preserve">
          <source>An extension trait for concatenating slices</source>
          <target state="translated">슬라이스를 연결하기위한 확장 특성</target>
        </trans-unit>
        <trans-unit id="12147a5a52fb5c2a1b9d7472abd1e716e6699134" translate="yes" xml:space="preserve">
          <source>An external crate dependency can be declared without binding its name in scope by using an underscore with the form &lt;code&gt;extern crate foo as _&lt;/code&gt;. This may be useful for crates that only need to be linked, but are never referenced, and will avoid being reported as unused.</source>
          <target state="translated">&lt;code&gt;extern crate foo as _&lt;/code&gt; 형식의 밑줄을 _로 사용하여 이름을 범위에 바인딩하지 않고 외부 상자 종속성을 선언 할 수 있습니다 . 이것은 연결이 필요하지만 참조되지 않은 상자에 유용하며 미사용으로보고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="af0969299b70206aefe5265b359a29ba784a7b81" translate="yes" xml:space="preserve">
          <source>An feature unstable in &lt;code&gt;const&lt;/code&gt; contexts was used.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 컨텍스트 에서 불안정한 기능 이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="67fba469014e18ca2e89e6de19c923fe7de4bee7" translate="yes" xml:space="preserve">
          <source>An identifier is any nonempty ASCII string of the following form:</source>
          <target state="translated">식별자는 다음 형식의 비어 있지 않은 ASCII 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="c175628788a43110a89b193ae816462d4cf2d2a4" translate="yes" xml:space="preserve">
          <source>An identifier is bound more than once in a pattern.</source>
          <target state="translated">식별자는 패턴에서 두 번 이상 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="804d52ee70392ba486d9daf55c4a0571322cd6a0" translate="yes" xml:space="preserve">
          <source>An identifier was used like a function name or a value was expected and the identifier exists but it belongs to a different namespace.</source>
          <target state="translated">식별자는 함수 이름처럼 사용되었거나 값이 예상되었으며 식별자는 존재하지만 다른 네임 스페이스에 속합니다.</target>
        </trans-unit>
        <trans-unit id="a9dd54d260c1e67a0aa0b597f6cdb8722318da30" translate="yes" xml:space="preserve">
          <source>An identity function.</source>
          <target state="translated">신원 기능.</target>
        </trans-unit>
        <trans-unit id="f4072cccbc13fd032256ab05516201c0d8df3e68" translate="yes" xml:space="preserve">
          <source>An if-let pattern attempts to match the pattern, and enters the body if the match was successful. If the match is irrefutable (when it cannot fail to match), use a regular &lt;code&gt;let&lt;/code&gt;-binding instead. For instance:</source>
          <target state="translated">if-let 패턴은 패턴과 일치를 시도하고 일치하면 본문에 들어갑니다. 일치 할 수없는 경우 (일치 할 수없는 경우) 대신 일반 &lt;code&gt;let&lt;/code&gt; - binding을 사용하십시오. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="4ba45e243c916e58a2890a2d541b968fddd22dd8" translate="yes" xml:space="preserve">
          <source>An implementation can take type and lifetime parameters, which can be used in the rest of the implementation. Type parameters declared for an implementation must be used at least once in either the trait or the implementing type of an implementation. Implementation parameters are written directly after the &lt;code&gt;impl&lt;/code&gt; keyword.</source>
          <target state="translated">구현은 유형 및 수명 매개 변수를 취할 수 있으며, 나머지 매개 변수에서 사용될 수 있습니다. 구현에 선언 된 형식 매개 변수는 특성 또는 구현의 구현 형식에서 한 번 이상 사용해야합니다. 구현 매개 변수는 &lt;code&gt;impl&lt;/code&gt; 키워드 바로 뒤에 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="5c1c04198ba70d5ee214d020749cca1de7fc7d00" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;Alloc&lt;/code&gt; can allocate, reallocate, and deallocate arbitrary blocks of data described via &lt;code&gt;Layout&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Alloc&lt;/code&gt; 의 구현은 &lt;code&gt;Layout&lt;/code&gt; 을 통해 설명 된 임의의 데이터 블록을 할당, 재 할당 및 할당 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="99623634884bf4add6cdc497873712ce416c8fd4" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;BitAnd&lt;/code&gt; for a wrapper around &lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt; 주위의 래퍼에 대한 &lt;code&gt;BitAnd&lt;/code&gt; 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="0e2ff6912f2ce30546aa9104a9c9d196708332bf" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;BitAnd&lt;/code&gt; for a wrapper around &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 주위의 래퍼에 대한 &lt;code&gt;BitAnd&lt;/code&gt; 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="5f6dfa411cba86305e5e9cd742f9f63d63776e67" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;BitAndAssign&lt;/code&gt; that lifts the &lt;code&gt;&amp;amp;=&lt;/code&gt; operator to a wrapper around &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;=&lt;/code&gt; 연산자를 &lt;code&gt;bool&lt;/code&gt; 주위의 래퍼로 올리는 &lt;code&gt;BitAndAssign&lt;/code&gt; 구현 .</target>
        </trans-unit>
        <trans-unit id="b3e86b6af5dd68737dcc690c4ff3a487a1934868" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;BitOr&lt;/code&gt; for a wrapper around &lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt; 주위의 래퍼에 대한 &lt;code&gt;BitOr&lt;/code&gt; 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="e8149ba6d1631c707939091192745b37494deb7b" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;BitOr&lt;/code&gt; for a wrapper around &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 주위 래퍼에 대한 &lt;code&gt;BitOr&lt;/code&gt; 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="ce43f6aba41bb7af32e0d6e55432c6b3ca8d7e1a" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;BitXor&lt;/code&gt; that lifts &lt;code&gt;^&lt;/code&gt; to a wrapper around &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; 를 &lt;code&gt;bool&lt;/code&gt; 주위의 래퍼로 들어 올리는 &lt;code&gt;BitXor&lt;/code&gt; 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="65cb4db18d08218407844613de42d9029080f521" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;BitXor&lt;/code&gt; trait for a wrapper around &lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt; 주위의 래퍼에 대한 &lt;code&gt;BitXor&lt;/code&gt; 특성 의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="b5b904d460aff616075d9ff33295d995d4012b99" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;Neg&lt;/code&gt; for &lt;code&gt;Sign&lt;/code&gt;, which allows the use of &lt;code&gt;-&lt;/code&gt; to negate its value.</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; 를 사용 하여 값을 무효화 할 수있는 &lt;code&gt;Neg&lt;/code&gt; for &lt;code&gt;Sign&lt;/code&gt; 구현 .</target>
        </trans-unit>
        <trans-unit id="873b42d4cd981f821fbfc718a707b146669b45da" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;Not&lt;/code&gt; for &lt;code&gt;Answer&lt;/code&gt;, which enables the use of &lt;code&gt;!&lt;/code&gt; to invert its value.</source>
          <target state="translated">&lt;code&gt;Not&lt;/code&gt; for &lt;code&gt;Answer&lt;/code&gt; 의 구현 으로 &lt;code&gt;!&lt;/code&gt; 값을 반전시킵니다.</target>
        </trans-unit>
        <trans-unit id="b6ef2365698efd5099fd68eb5d996513953b40b7" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;Shl&lt;/code&gt; that lifts the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; operation on integers to a wrapper around &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">정수 의 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 연산을 &lt;code&gt;usize&lt;/code&gt; 주위의 래퍼로 올리는 &lt;code&gt;Shl&lt;/code&gt; 의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="8e679f132f9bdc673ab7525c566b308cef626454" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;Shl&lt;/code&gt; that spins a vector leftward by a given amount.</source>
          <target state="translated">주어진 양만큼 벡터를 왼쪽으로 회전시키는 &lt;code&gt;Shl&lt;/code&gt; 의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="4b9ea2f9d110fb7b7d2e508e8eb895f2a6c76af4" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;ShlAssign&lt;/code&gt; for a wrapper around &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">의 구현 &lt;code&gt;ShlAssign&lt;/code&gt; 래퍼에 대한 &lt;code&gt;usize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdc99f650e402a714069613aef9bb0ab1a03fe00" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;Shr&lt;/code&gt; that lifts the &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; operation on integers to a wrapper around &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">정수에 대한 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 연산을 &lt;code&gt;usize&lt;/code&gt; 주위의 래퍼로 올리는 &lt;code&gt;Shr&lt;/code&gt; 의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="00b6c1f0f935bcc3f078a1d4c1fb779815701d8c" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;Shr&lt;/code&gt; that spins a vector rightward by a given amount.</source>
          <target state="translated">주어진 양만큼 벡터를 오른쪽으로 회전시키는 &lt;code&gt;Shr&lt;/code&gt; 의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="fef3f9c26a074ccf18bb7e56e8695a2a73f26459" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;ShrAssign&lt;/code&gt; for a wrapper around &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">의 구현 &lt;code&gt;ShrAssign&lt;/code&gt; 래퍼에 대한 &lt;code&gt;usize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0109084bf6e2896150bb542f8a8637f2cff32f1" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;poll&lt;/code&gt; should strive to return quickly, and should not block. Returning quickly prevents unnecessarily clogging up threads or event loops. If it is known ahead of time that a call to &lt;code&gt;poll&lt;/code&gt; may end up taking awhile, the work should be offloaded to a thread pool (or something similar) to ensure that &lt;code&gt;poll&lt;/code&gt; can return quickly.</source>
          <target state="translated">&lt;code&gt;poll&lt;/code&gt; 구현은 신속하게 복귀하기 위해 노력해야하며 차단해서는 안됩니다. 리턴하면 스레드 또는 이벤트 루프가 불필요하게 막히지 않습니다. &lt;code&gt;poll&lt;/code&gt; 호출에 시간이 오래 걸릴 수 있다고 미리 알려진 경우 작업이 스레드 풀 (또는 이와 유사한 것)로 오프로드되어 &lt;code&gt;poll&lt;/code&gt; 이 빠르게 리턴 될 수 있도록해야합니다 .</target>
        </trans-unit>
        <trans-unit id="350059cec8495b6fd084c91dd06a8c1a8c6277a2" translate="yes" xml:space="preserve">
          <source>An implementation of SipHash 2-4.</source>
          <target state="translated">SipHash의 구현 2-4.</target>
        </trans-unit>
        <trans-unit id="a7c410f2271131f6e26f4c1a6c01fb2def54994c" translate="yes" xml:space="preserve">
          <source>An import was unresolved.</source>
          <target state="translated">가져 오기가 해결되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="29610251a6990ca267c18a3b17be65ef65d80c1f" translate="yes" xml:space="preserve">
          <source>An important part of the process of learning Rust is learning how to read the error messages the compiler displays: these will guide you toward working code. As such, we&amp;rsquo;ll provide many examples that don&amp;rsquo;t compile along with the error message the compiler will show you in each situation. Know that if you enter and run a random example, it may not compile! Make sure you read the surrounding text to see whether the example you&amp;rsquo;re trying to run is meant to error. Ferris will also help you distinguish code that isn&amp;rsquo;t meant to work:</source>
          <target state="translated">Rust를 배우는 과정에서 중요한 부분은 컴파일러가 표시하는 오류 메시지를 읽는 방법을 배우는 것입니다. 이들은 작동 코드로 안내합니다. 따라서 컴파일러는 각 상황에서 표시되는 오류 메시지와 함께 컴파일되지 않는 많은 예제를 제공합니다. 임의의 예제를 입력하고 실행하면 컴파일되지 않을 수 있습니다! 실행하려는 예제가 오류인지 확인하려면 주변 텍스트를 읽으십시오. Ferris는 또한 작동하지 않는 코드를 구별하는 데 도움을줍니다.</target>
        </trans-unit>
        <trans-unit id="9068331ccd5e98287382db124205efdfb79f7cfb" translate="yes" xml:space="preserve">
          <source>An important thing to remember is that the type &lt;code&gt;fmt::Error&lt;/code&gt; should not be confused with &lt;a href=&quot;../io/struct.error&quot;&gt;&lt;code&gt;std::io::Error&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../error/trait.error&quot;&gt;&lt;code&gt;std::error::Error&lt;/code&gt;&lt;/a&gt;, which you may also have in scope.</source>
          <target state="translated">기억해야 할 중요한 것은 &lt;code&gt;fmt::Error&lt;/code&gt; 유형 을 &lt;a href=&quot;../io/struct.error&quot;&gt; &lt;code&gt;std::io::Error&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../error/trait.error&quot;&gt; &lt;code&gt;std::error::Error&lt;/code&gt; &lt;/a&gt; 와 혼동해서는 안된다는 것입니다 . 범위는 범위 내에있을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f9e81cf6c354fdfd3e66804e1f412009da97856" translate="yes" xml:space="preserve">
          <source>An inclusive bound.</source>
          <target state="translated">포괄적 인 한계.</target>
        </trans-unit>
        <trans-unit id="192433a73b5ee226652b56c2bf60e3939daf0558" translate="yes" xml:space="preserve">
          <source>An inclusive range needs an end in order to &lt;em&gt;include&lt;/em&gt; it. If you just need a start and no end, use a non-inclusive range (with &lt;code&gt;..&lt;/code&gt;):</source>
          <target state="translated">포함 범위를 &lt;em&gt;포함&lt;/em&gt; 하려면 끝이 필요 합니다. 시작이 필요하고 끝이 없으면 비 포함 범위 ( &lt;code&gt;..&lt;/code&gt; 포함 )를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="50920c083a024a331ce9d74584285d9788301b90" translate="yes" xml:space="preserve">
          <source>An inclusive range was used with no end.</source>
          <target state="translated">포괄적 인 범위가 끝없이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="387b0473c559329b38860546da1e2cce85651e8f" translate="yes" xml:space="preserve">
          <source>An incompatible cast was attempted.</source>
          <target state="translated">호환되지 않는 캐스트가 시도되었습니다.</target>
        </trans-unit>
        <trans-unit id="c9900f693c2e1b5744366ed3318b36a718fcf770" translate="yes" xml:space="preserve">
          <source>An infinite endpoint. Indicates that there is no bound in this direction.</source>
          <target state="translated">무한한 끝점. 이 방향으로 바운드가 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f2f7f4bb84396a832ec236ff6b02e7c811f6141c" translate="yes" xml:space="preserve">
          <source>An inherent implementation is defined as the sequence of the &lt;code&gt;impl&lt;/code&gt; keyword, generic type declarations, a path to a nominal type, a where clause, and a bracketed set of associable items.</source>
          <target state="translated">고유 구현은 &lt;code&gt;impl&lt;/code&gt; 키워드 순서 , 일반 유형 선언, 명목 유형에 대한 경로, where 절 및 연관 가능한 항목의 괄호 세트로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="eaca7587ab66134ebcc5c9d98dddc7a6d1b623fb" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;DirEntry&lt;/code&gt; represents an entry inside of a directory on the filesystem. Each entry can be inspected via methods to learn about the full path or possibly other metadata through per-platform extension traits.</source>
          <target state="translated">&lt;code&gt;DirEntry&lt;/code&gt; 의 인스턴스 는 파일 시스템의 디렉토리 내부에있는 항목을 나타냅니다. 각 항목은 방법을 통해 검사하여 전체 경로 또는 플랫폼 별 확장 특성을 통해 다른 메타 데이터에 대해 배울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fbc585e6de8e6bcaf356cf9f8023d57041f924e" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;Layout&lt;/code&gt; describes a particular layout of memory. You build a &lt;code&gt;Layout&lt;/code&gt; up as an input to give to an allocator.</source>
          <target state="translated">&lt;code&gt;Layout&lt;/code&gt; 인스턴스는 특정 메모리 레이아웃을 설명합니다. 할당 자에게 제공 할 입력으로 &lt;code&gt;Layout&lt;/code&gt; 을 빌드합니다 .</target>
        </trans-unit>
        <trans-unit id="b190fdcf2cbfcbc1313cacaba62570eb78c828a4" translate="yes" xml:space="preserve">
          <source>An instance of a &lt;code&gt;File&lt;/code&gt; can be read and/or written depending on what options it was opened with. Files also implement &lt;a href=&quot;../io/trait.seek&quot;&gt;&lt;code&gt;Seek&lt;/code&gt;&lt;/a&gt; to alter the logical cursor that the file contains internally.</source>
          <target state="translated">&lt;code&gt;File&lt;/code&gt; 의 인스턴스는 파일 을 연 옵션에 따라 읽거나 쓸 수 있습니다. 파일 은 파일에 내부적으로 포함 된 논리적 커서를 변경하기 위해 &lt;a href=&quot;../io/trait.seek&quot;&gt; &lt;code&gt;Seek&lt;/code&gt; &lt;/a&gt; 를 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="f4459da0411b29eac8078029351bbb76f00d3282" translate="yes" xml:space="preserve">
          <source>An integer &lt;code&gt;.N&lt;/code&gt;:</source>
          <target state="translated">정수 &lt;code&gt;.N&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="908da2eafc06fe6ced0bd1b3ca560bd9a2e72aa4" translate="yes" xml:space="preserve">
          <source>An integer or name followed by dollar sign &lt;code&gt;.N$&lt;/code&gt;:</source>
          <target state="translated">정수 또는 이름 뒤에 달러 기호 &lt;code&gt;.N$&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d652b1aec455b9a1399356989d1b6e7890b6c2cf" translate="yes" xml:space="preserve">
          <source>An integer that is known not to equal zero.</source>
          <target state="translated">0이 아닌 것으로 알려진 정수입니다.</target>
        </trans-unit>
        <trans-unit id="23e972eabcd349c601672f385dadf7a600ee560a" translate="yes" xml:space="preserve">
          <source>An integer type which can be safely shared between threads.</source>
          <target state="translated">스레드간에 안전하게 공유 할 수있는 정수 유형입니다.</target>
        </trans-unit>
        <trans-unit id="7738cea88357f8684a294b13f985119f27bc796a" translate="yes" xml:space="preserve">
          <source>An intensity number from the user, which is specified when they request a workout to indicate whether they want a low-intensity workout or a high-intensity workout</source>
          <target state="translated">사용자의 저 강도 운동 또는 고강도 운동을 원하는지 여부를 나타 내기 위해 운동을 요청할 때 지정되는 강도 번호</target>
        </trans-unit>
        <trans-unit id="ff8d693a0bfcced7e1e8e51c1bf01052178e048b" translate="yes" xml:space="preserve">
          <source>An interface for dealing with iterators.</source>
          <target state="translated">반복자를 처리하기위한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="22e5648e52f9b0472e117269511bde8fb3cbbf6f" translate="yes" xml:space="preserve">
          <source>An internet socket address, either IPv4 or IPv6.</source>
          <target state="translated">인터넷 소켓 주소 (IPv4 또는 IPv6)</target>
        </trans-unit>
        <trans-unit id="854d43a414a4b60a4e76077619d9f002787508df" translate="yes" xml:space="preserve">
          <source>An intrinsic is a function available for use in a given programming language whose implementation is handled specially by the compiler. In order to fix this error, just declare a function.</source>
          <target state="translated">내장 함수는 특정 프로그래밍 언어에서 사용할 수있는 함수로, 해당 구현은 컴파일러에서 특별히 처리됩니다. 이 오류를 해결하려면 함수를 선언하십시오.</target>
        </trans-unit>
        <trans-unit id="d4ed3f185066b7aaf4eec2eeca59086039ee692c" translate="yes" xml:space="preserve">
          <source>An intrinsic was declared without being a function.</source>
          <target state="translated">내장 함수는 함수가 아닌 것으로 선언되었습니다.</target>
        </trans-unit>
        <trans-unit id="4c83eebd7c224b0a142aede3c5ec04a66d472405" translate="yes" xml:space="preserve">
          <source>An invalid &lt;code&gt;self&lt;/code&gt; import was made.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 가져 오기가 잘못 되었습니다.</target>
        </trans-unit>
        <trans-unit id="82555301e5ea450f3a2a3340087105706f32de3a" translate="yes" xml:space="preserve">
          <source>An invalid cast was attempted.</source>
          <target state="translated">잘못된 캐스트가 시도되었습니다.</target>
        </trans-unit>
        <trans-unit id="b45ca9e360736d39967051ef73e9a974697dc538" translate="yes" xml:space="preserve">
          <source>An invalid lint attribute has been given. Erroneous code example:</source>
          <target state="translated">유효하지 않은 보풀 속성이 제공되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="a410192aae8c1c9efe2c778af8302870ee71f57b" translate="yes" xml:space="preserve">
          <source>An item usage is ambiguous.</source>
          <target state="translated">항목 사용법이 모호합니다.</target>
        </trans-unit>
        <trans-unit id="b44509fac7828279e76e0b5a94ab5171cb157956" translate="yes" xml:space="preserve">
          <source>An iterator able to yield elements from both ends.</source>
          <target state="translated">양쪽 끝에서 요소를 생성 할 수있는 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="a79f20c0e35d15b48bb2797970d35b63c3629a31" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to &lt;a href=&quot;#method.fold&quot;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; that holds internal state and produces a new iterator.</source>
          <target state="translated">내부 상태를 유지하고 새 반복자를 생성하는 &lt;a href=&quot;#method.fold&quot;&gt; &lt;code&gt;fold&lt;/code&gt; &lt;/a&gt; 와 유사한 반복기 어댑터 .</target>
        </trans-unit>
        <trans-unit id="4f7d60e521538ea62f876d5c70c545dc3addec69" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to [&lt;code&gt;fold&lt;/code&gt;] that holds internal state and produces a new iterator. &lt;a href=&quot;../../../iter/trait.iterator#method.scan&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">내부 상태를 유지하고 새 반복기를 생성하는 [ &lt;code&gt;fold&lt;/code&gt; ] 와 유사한 반복기 어댑터 . &lt;a href=&quot;../../../iter/trait.iterator#method.scan&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7a650dc159a2fda49c7766be96685d0f790f13a0" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to [&lt;code&gt;fold&lt;/code&gt;] that holds internal state and produces a new iterator. &lt;a href=&quot;../../iter/trait.iterator#method.scan&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">내부 상태를 유지하고 새 반복기를 생성하는 [ &lt;code&gt;fold&lt;/code&gt; ] 와 유사한 반복기 어댑터 . &lt;a href=&quot;../../iter/trait.iterator#method.scan&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e898bdaf274bb7754df65ccfb97b6bd04568d2d" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to [&lt;code&gt;fold&lt;/code&gt;] that holds internal state and produces a new iterator. &lt;a href=&quot;../iter/trait.iterator#method.scan&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">내부 상태를 유지하고 새 반복기를 생성하는 [ &lt;code&gt;fold&lt;/code&gt; ] 와 유사한 반복기 어댑터 . &lt;a href=&quot;../iter/trait.iterator#method.scan&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e2996431c0507a4a842fe331c88d08e4bb45dcce" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to [&lt;code&gt;fold&lt;/code&gt;] that holds internal state and produces a new iterator. &lt;a href=&quot;iter/trait.iterator#method.scan&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">내부 상태를 유지하고 새 반복기를 생성하는 [ &lt;code&gt;fold&lt;/code&gt; ] 와 유사한 반복기 어댑터 . &lt;a href=&quot;iter/trait.iterator#method.scan&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ae7a2ef58596a8f574790d9946d5c7b0d3e0427f" translate="yes" xml:space="preserve">
          <source>An iterator adaptor similar to [&lt;code&gt;fold&lt;/code&gt;] that holds internal state and produces a new iterator. &lt;a href=&quot;trait.iterator#method.scan&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">내부 상태를 유지하고 새 반복기를 생성하는 [ &lt;code&gt;fold&lt;/code&gt; ] 와 유사한 반복기 어댑터 . &lt;a href=&quot;trait.iterator#method.scan&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9ad9db34c1f6ac7b97514886d275ac1277b33c65" translate="yes" xml:space="preserve">
          <source>An iterator for stepping iterators by a custom amount.</source>
          <target state="translated">사용자 지정 금액만큼 반복기를 스테핑하는 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="fb45f260d1289d4ddcd0c03f93e3cf026ce37b59" translate="yes" xml:space="preserve">
          <source>An iterator has a method, &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt;, which when called, returns an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;Item&amp;gt;&lt;/code&gt;. &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;Some(Item)&lt;/code&gt; as long as there are elements, and once they've all been exhausted, will return &lt;code&gt;None&lt;/code&gt; to indicate that iteration is finished. Individual iterators may choose to resume iteration, and so calling &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; again may or may not eventually start returning &lt;code&gt;Some(Item)&lt;/code&gt; again at some point.</source>
          <target state="translated">이터레이터에는 &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; 메소드가 있는데, 호출하면 &lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;Item&amp;gt;&lt;/code&gt; 을 리턴합니다 . &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; 반환 &lt;code&gt;Some(Item)&lt;/code&gt; 요소가있는만큼, 그들이 모두 소진 한 후에는 반환하지 않습니다 &lt;code&gt;None&lt;/code&gt; 반복이 완료되었음을 나타냅니다. 개별 반복자는 반복을 재개하도록 선택할 수 있으므로 &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; 다시 호출하면 특정 시점에서 &lt;code&gt;Some(Item)&lt;/code&gt; 다시 반환하거나 시작하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e31522f53dadc02b86f505f8fd01b611f6643e8b" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a fallible function to each item in the iterator, stopping at the first error and returning that error.</source>
          <target state="translated">반복자의 각 항목에 오류 가능한 함수를 적용하여 첫 번째 오류에서 중지하고 해당 오류를 리턴하는 반복자 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="eacb362cba384eacfe624626c78db089eba4406f" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a fallible function to each item in the iterator, stopping at the first error and returning that error. &lt;a href=&quot;../../../iter/trait.iterator#method.try_for_each&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자의 각 항목에 오류 가능한 함수를 적용하여 첫 번째 오류에서 중지하고 해당 오류를 리턴하는 반복자 메소드입니다. &lt;a href=&quot;../../../iter/trait.iterator#method.try_for_each&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ca00c28d4b5a3134e86a3f660b2fa54093267401" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a fallible function to each item in the iterator, stopping at the first error and returning that error. &lt;a href=&quot;../../iter/trait.iterator#method.try_for_each&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자의 각 항목에 오류 가능한 함수를 적용하여 첫 번째 오류에서 중지하고 해당 오류를 리턴하는 반복자 메소드입니다. &lt;a href=&quot;../../iter/trait.iterator#method.try_for_each&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e1489bd41c8525121e45484ed737c4171e974de0" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a fallible function to each item in the iterator, stopping at the first error and returning that error. &lt;a href=&quot;../iter/trait.iterator#method.try_for_each&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자의 각 항목에 오류 가능한 함수를 적용하여 첫 번째 오류에서 중지하고 해당 오류를 리턴하는 반복자 메소드입니다. &lt;a href=&quot;../iter/trait.iterator#method.try_for_each&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="33c934134cacb66bd994968f86b620a631318b91" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a fallible function to each item in the iterator, stopping at the first error and returning that error. &lt;a href=&quot;iter/trait.iterator#method.try_for_each&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자의 각 항목에 오류 가능한 함수를 적용하여 첫 번째 오류에서 중지하고 해당 오류를 리턴하는 반복자 메소드입니다. &lt;a href=&quot;iter/trait.iterator#method.try_for_each&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="19bfdbf913f10e6bc3776600b92d9135c032b4bf" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a fallible function to each item in the iterator, stopping at the first error and returning that error. &lt;a href=&quot;trait.iterator#method.try_for_each&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자의 각 항목에 오류 가능한 함수를 적용하여 첫 번째 오류에서 중지하고 해당 오류를 리턴하는 반복자 메소드입니다. &lt;a href=&quot;trait.iterator#method.try_for_each&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3b59c2e3f2042ddc5a53ef66ef4d7b79f1fb5301" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function as long as it returns successfully, producing a single, final value.</source>
          <target state="translated">성공적으로 반환되는 한 함수를 적용하여 단일 최종 값을 생성하는 반복자 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="117fd8070a23ba82f744d90c448b1e5813b4d282" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function as long as it returns successfully, producing a single, final value. &lt;a href=&quot;../../../iter/trait.iterator#method.try_fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">성공적으로 반환되는 한 함수를 적용하여 단일 최종 값을 생성하는 반복자 메서드입니다. &lt;a href=&quot;../../../iter/trait.iterator#method.try_fold&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7ee1c8bd3a25e2ebef94ba8c0d6405c27ca7226b" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function as long as it returns successfully, producing a single, final value. &lt;a href=&quot;../../iter/trait.iterator#method.try_fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">성공적으로 반환되는 한 함수를 적용하여 단일 최종 값을 생성하는 반복자 메서드입니다. &lt;a href=&quot;../../iter/trait.iterator#method.try_fold&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c658b3e624db269551bf93242408ef5c42e5fea9" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function as long as it returns successfully, producing a single, final value. &lt;a href=&quot;../iter/trait.iterator#method.try_fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">성공적으로 반환되는 한 함수를 적용하여 단일 최종 값을 생성하는 반복자 메서드입니다. &lt;a href=&quot;../iter/trait.iterator#method.try_fold&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9a5362af3855236bb52258529c3514119a249eab" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function as long as it returns successfully, producing a single, final value. &lt;a href=&quot;iter/trait.iterator#method.try_fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">성공적으로 반환되는 한 함수를 적용하여 단일 최종 값을 생성하는 반복자 메서드입니다. &lt;a href=&quot;iter/trait.iterator#method.try_fold&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="22eb23eabd6f5888b0f6233654a7d6b3279d1ac7" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function as long as it returns successfully, producing a single, final value. &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">성공적으로 반환되는 한 함수를 적용하여 단일 최종 값을 생성하는 반복자 메서드입니다. &lt;a href=&quot;trait.iterator#method.try_fold&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9d551693bdcaedeac0547d596669a3c5c5179447" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function, producing a single, final value.</source>
          <target state="translated">함수를 적용하여 단일 최종 값을 생성하는 반복자 방법입니다.</target>
        </trans-unit>
        <trans-unit id="31400216ecaba12666aff645bec4ca26c5ba43ea" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function, producing a single, final value. &lt;a href=&quot;../../../iter/trait.iterator#method.fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">함수를 적용하여 단일 최종 값을 생성하는 반복자 방법입니다. &lt;a href=&quot;../../../iter/trait.iterator#method.fold&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="958c160388552a918125f55bba9e086f54f71484" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function, producing a single, final value. &lt;a href=&quot;../../iter/trait.iterator#method.fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">함수를 적용하여 단일 최종 값을 생성하는 반복자 방법입니다. &lt;a href=&quot;../../iter/trait.iterator#method.fold&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5eddc2fc826e92b735803187068d19d4e441542e" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function, producing a single, final value. &lt;a href=&quot;../iter/trait.iterator#method.fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">함수를 적용하여 단일 최종 값을 생성하는 반복자 방법입니다. &lt;a href=&quot;../iter/trait.iterator#method.fold&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="062b8bbee99bc123d00bd6ddb37a2091ecaee57f" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function, producing a single, final value. &lt;a href=&quot;iter/trait.iterator#method.fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">함수를 적용하여 단일 최종 값을 생성하는 반복자 방법입니다. &lt;a href=&quot;iter/trait.iterator#method.fold&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="760ff7a591ac95e16cd7be5b9667ba1c820bc96e" translate="yes" xml:space="preserve">
          <source>An iterator method that applies a function, producing a single, final value. &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">함수를 적용하여 단일 최종 값을 생성하는 반복자 방법입니다. &lt;a href=&quot;trait.iterator#method.fold&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e4cfaa2271cf9f33fe50ead23cff9cf9b29c2c97" translate="yes" xml:space="preserve">
          <source>An iterator method that reduces the iterator's elements to a single, final value, starting from the back.</source>
          <target state="translated">반복자의 요소를 뒤에서 시작하여 하나의 최종 값으로 줄이는 반복자 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="c9c712bf49f750f238c96785e7e704d976a72f0e" translate="yes" xml:space="preserve">
          <source>An iterator method that reduces the iterator's elements to a single, final value, starting from the back. &lt;a href=&quot;../../iter/trait.doubleendediterator#method.rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자의 요소를 뒤에서 시작하여 하나의 최종 값으로 줄이는 반복자 메소드입니다. &lt;a href=&quot;../../iter/trait.doubleendediterator#method.rfold&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b44201682fdbcad5c8da77522b47e4b7fc4a3dc1" translate="yes" xml:space="preserve">
          <source>An iterator method that reduces the iterator's elements to a single, final value, starting from the back. &lt;a href=&quot;../iter/trait.doubleendediterator#method.rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자의 요소를 뒤에서 시작하여 하나의 최종 값으로 줄이는 반복자 메소드입니다. &lt;a href=&quot;../iter/trait.doubleendediterator#method.rfold&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fc53bae551d78289c9703ed2a397d1c3b35f285e" translate="yes" xml:space="preserve">
          <source>An iterator method that reduces the iterator's elements to a single, final value, starting from the back. &lt;a href=&quot;iter/trait.doubleendediterator#method.rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자의 요소를 뒤에서 시작하여 하나의 최종 값으로 줄이는 반복자 메소드입니다. &lt;a href=&quot;iter/trait.doubleendediterator#method.rfold&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="836f4f2e3fffc61e14c382d8890f27b7a367beeb" translate="yes" xml:space="preserve">
          <source>An iterator method that reduces the iterator's elements to a single, final value, starting from the back. &lt;a href=&quot;trait.doubleendediterator#method.rfold&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자의 요소를 뒤에서 시작하여 하나의 최종 값으로 줄이는 반복자 메소드입니다. &lt;a href=&quot;trait.doubleendediterator#method.rfold&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b2acafc012d5ccce6e7696757b55337a6d4029a3" translate="yes" xml:space="preserve">
          <source>An iterator of &lt;a href=&quot;../primitive.u16&quot;&gt;&lt;code&gt;u16&lt;/code&gt;&lt;/a&gt; over the string encoded as UTF-16.</source>
          <target state="translated">&lt;a href=&quot;../primitive.u16&quot;&gt; &lt;code&gt;u16&lt;/code&gt; &lt;/a&gt; 의 반복자UTF-16으로 인코딩 된 문자열 .</target>
        </trans-unit>
        <trans-unit id="143fd7db785baccd8bb8346c04f451192a09006a" translate="yes" xml:space="preserve">
          <source>An iterator over &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; and its ancestors.</source>
          <target state="translated">&lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; 와 그 조상 의 반복자 .</target>
        </trans-unit>
        <trans-unit id="554dfaab9d83066a6b95354b7620556448cb3449" translate="yes" xml:space="preserve">
          <source>An iterator over &lt;a href=&quot;trait.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;trait.error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 대한 반복자</target>
        </trans-unit>
        <trans-unit id="aef63e9607a8ec1f5f596fca15621080fd76af72" translate="yes" xml:space="preserve">
          <source>An iterator over &lt;code&gt;u8&lt;/code&gt; values of a reader.</source>
          <target state="translated">리더의 &lt;code&gt;u8&lt;/code&gt; 값에 대한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="34e3362281b15b977d0a61ac8c5fcd00a6511c9c" translate="yes" xml:space="preserve">
          <source>An iterator over a mutable reference to the &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt; variant of an &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt; 변형에 대한 변경 가능한 참조에 대한 반복자 .</target>
        </trans-unit>
        <trans-unit id="c74c624cf35ae570735e4b7f11b57db582409878" translate="yes" xml:space="preserve">
          <source>An iterator over a mutable reference to the &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; variant of a &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; 변형에 대한 변경 가능한 참조에 대한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="f4de84f3b1b68ec9fb8cadcc939ec573f412a94a" translate="yes" xml:space="preserve">
          <source>An iterator over a reference to the &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt; variant of an &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt; 변형에 대한 참조에 대한 반복자 .</target>
        </trans-unit>
        <trans-unit id="8cd69f81931caab64a8dceae843c42a8b1faa3e1" translate="yes" xml:space="preserve">
          <source>An iterator over a reference to the &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; variant of a &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; 변형에 대한 참조에 대한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="6d2aa423fb037ba3e42490b4a4869e7a989a8b38" translate="yes" xml:space="preserve">
          <source>An iterator over a slice in (non-overlapping) chunks (&lt;code&gt;chunk_size&lt;/code&gt; elements at a time), starting at the beginning of the slice.</source>
          <target state="translated">(겹치지 않는) 청크에서 슬라이스에 대한 반복자 ( &lt;code&gt;chunk_size&lt;/code&gt; 의 시작 부분부터 시작하여 한 번에 요소 입니다.</target>
        </trans-unit>
        <trans-unit id="51ba4c3e078709e91115e94720e3b32e5a3519a2" translate="yes" xml:space="preserve">
          <source>An iterator over a slice in (non-overlapping) chunks (&lt;code&gt;chunk_size&lt;/code&gt; elements at a time), starting at the end of the slice.</source>
          <target state="translated">슬라이스 끝에서 시작하여 (겹치지 않는) 청크 ( 한 번에 &lt;code&gt;chunk_size&lt;/code&gt; 요소 )에서 슬라이스에 대한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="b727a794715c05c6c1c0cd0cd6149d40bd7c3a04" translate="yes" xml:space="preserve">
          <source>An iterator over a slice in (non-overlapping) mutable chunks (&lt;code&gt;chunk_size&lt;/code&gt; elements at a time), starting at the beginning of the slice.</source>
          <target state="translated">슬라이스 의 시작 부분부터 시작하여 (겹치지 않는) 변경 가능한 청크 ( 한 번에 &lt;code&gt;chunk_size&lt;/code&gt; 요소 )에서 슬라이스에 대한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="590e04be01e914183b27d18dc8eff4e3ae5668f0" translate="yes" xml:space="preserve">
          <source>An iterator over a slice in (non-overlapping) mutable chunks (&lt;code&gt;chunk_size&lt;/code&gt; elements at a time), starting at the end of the slice.</source>
          <target state="translated">슬라이스 끝에서 시작하여 (겹치지 않는) 변경 가능한 청크 ( 한 번에 &lt;code&gt;chunk_size&lt;/code&gt; 요소 )에서 슬라이스에 대한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="68ad6606a48079fe489aab3faf8c6e3a26b992ca" translate="yes" xml:space="preserve">
          <source>An iterator over a snapshot of the environment variables of this process.</source>
          <target state="translated">이 프로세스의 환경 변수 스냅 샷에 대한 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="a94e3f24bb1eb1ba2fd58ebddc9b4d9dba8309a8" translate="yes" xml:space="preserve">
          <source>An iterator over a sub-range of entries in a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; 의 하위 범위 항목에 대한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="d03569c5a9963027ad22996c9e0b70fb1554a87f" translate="yes" xml:space="preserve">
          <source>An iterator over a sub-range of items in a &lt;code&gt;BTreeSet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; 의 하위 범위 항목에 대한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="f19c5dd669fe6f36f81a65798f7219d0079a694d" translate="yes" xml:space="preserve">
          <source>An iterator over incoming connections to a &lt;a href=&quot;struct.unixlistener&quot;&gt;&lt;code&gt;UnixListener&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.unixlistener&quot;&gt; &lt;code&gt;UnixListener&lt;/code&gt; 로&lt;/a&gt; 들어오는 연결을 반복하는 사람 .</target>
        </trans-unit>
        <trans-unit id="4d7488e2fccb6b43b42e67c9ea07cad9428b393b" translate="yes" xml:space="preserve">
          <source>An iterator over messages on a &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt;, created by &lt;a href=&quot;struct.receiver#method.iter&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.receiver#method.iter&quot;&gt; &lt;code&gt;iter&lt;/code&gt; 가&lt;/a&gt; 만든 &lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt; 메시지에 대한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="034a20701e995ae32aa63104e2d5dff0ab5db4e6" translate="yes" xml:space="preserve">
          <source>An iterator over overlapping subslices of length &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">길이의 subslices 중복 반복자 &lt;code&gt;size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba3bd9fb0e96735ece0b2069d478b585f0d8e7fe" translate="yes" xml:space="preserve">
          <source>An iterator over subslices separated by elements that match a predicate function, limited to a given number of splits, starting from the end of the slice.</source>
          <target state="translated">술어 함수와 일치하는 요소로 분리 된 서브 슬라이스에 대한 반복자는 슬라이스의 끝에서 시작하여 지정된 분할 수로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="24b57b67d67808582aa0647134f85aea733abfd0" translate="yes" xml:space="preserve">
          <source>An iterator over subslices separated by elements that match a predicate function, limited to a given number of splits.</source>
          <target state="translated">술어 함수와 일치하는 요소로 분리 된 서브 슬라이스에 대한 반복자는 주어진 분할 수로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="7f751853b227571562b0215c1381b97b30029d0a" translate="yes" xml:space="preserve">
          <source>An iterator over subslices separated by elements that match a predicate function, starting from the end of the slice.</source>
          <target state="translated">슬라이스의 끝에서 시작하여 조건 자 함수와 일치하는 요소로 구분 된 하위 슬라이스의 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="6a41aa74d34fd0ce2985da917544c4f35cf020f9" translate="yes" xml:space="preserve">
          <source>An iterator over subslices separated by elements that match a predicate function.</source>
          <target state="translated">술어 함수와 일치하는 요소로 구분 된 서브 슬라이스의 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="e1f02e8fb3b3f7adf4ed8a711ed0b9c2ca4cda3e" translate="yes" xml:space="preserve">
          <source>An iterator over substrings of &lt;code&gt;self&lt;/code&gt;, separated by characters matched by a pattern and yielded in reverse order.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 하위 문자열에 대한 반복자 이며 패턴과 일치하는 문자로 구분되며 역순으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="61c715ce9520941f9108744caef70fb9d86c6529" translate="yes" xml:space="preserve">
          <source>An iterator over substrings of the given string slice, separated by a pattern, restricted to returning at most &lt;code&gt;n&lt;/code&gt; items.</source>
          <target state="translated">주어진 문자열 슬라이스의 하위 문자열에 대한 반복자는 패턴으로 구분되어 최대 &lt;code&gt;n&lt;/code&gt; 개의 항목 을 반환하도록 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="44ffc34ab178359db4b3169f249d963fd153689b" translate="yes" xml:space="preserve">
          <source>An iterator over substrings of the given string slice, separated by characters matched by a pattern and yielded in reverse order.</source>
          <target state="translated">주어진 문자열 슬라이스의 하위 문자열에 대한 반복자로서 패턴과 일치하는 문자로 구분되며 역순으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="f65e61a07278abe6a5b629cd21c031c73243b0de" translate="yes" xml:space="preserve">
          <source>An iterator over substrings of the given string slice, separated by characters matched by a pattern.</source>
          <target state="translated">주어진 문자열 슬라이스의 하위 문자열에 대한 반복자이며 패턴과 일치하는 문자로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="537813cfc78da0abdca4b435c9341ecf42939302" translate="yes" xml:space="preserve">
          <source>An iterator over substrings of this string slice, separated by a pattern, starting from the end of the string, restricted to returning at most &lt;code&gt;n&lt;/code&gt; items.</source>
          <target state="translated">문자열 끝에서 시작하여 패턴으로 구분 된이 문자열 슬라이스의 하위 문자열에 대한 반복자는 최대 &lt;code&gt;n&lt;/code&gt; 개의 항목 을 반환하도록 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="02d9a6b83a0665db88c523e6eaff227f1f6e5ae9" translate="yes" xml:space="preserve">
          <source>An iterator over substrings of this string slice, separated by characters matched by a pattern.</source>
          <target state="translated">패턴과 일치하는 문자로 구분 된이 문자열 슬라이스의 하위 문자열에 대한 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="0ef8a4c9f98576b84451f0afffc7c456b9562b40" translate="yes" xml:space="preserve">
          <source>An iterator over the &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s of a string slice, and their positions.</source>
          <target state="translated">문자열 슬라이스 의 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 와 그 위치에 대한 반복자 .</target>
        </trans-unit>
        <trans-unit id="6dbafa08f3b2b12e80351b71ca200a8528053590" translate="yes" xml:space="preserve">
          <source>An iterator over the &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s of a string slice.</source>
          <target state="translated">문자열 슬라이스 의 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 대한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="94f1d147d9aa55e9343a89220481dd294b3c1ca7" translate="yes" xml:space="preserve">
          <source>An iterator over the &lt;a href=&quot;enum.component&quot;&gt;&lt;code&gt;Component&lt;/code&gt;&lt;/a&gt;s of a &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;, as &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; slices.</source>
          <target state="translated">오버 반복자 &lt;a href=&quot;enum.component&quot;&gt; &lt;code&gt;Component&lt;/code&gt; &lt;/a&gt; (A)의이야 &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; 로, &lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; 의&lt;/a&gt; 조각.</target>
        </trans-unit>
        <trans-unit id="81b7c7eac770fb32d5f49a8fa6788046e188a635" translate="yes" xml:space="preserve">
          <source>An iterator over the &lt;a href=&quot;enum.component&quot;&gt;&lt;code&gt;Component&lt;/code&gt;&lt;/a&gt;s of a &lt;a href=&quot;struct.path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">오버 반복자 &lt;a href=&quot;enum.component&quot;&gt; &lt;code&gt;Component&lt;/code&gt; &lt;/a&gt; (A)의이야 &lt;a href=&quot;struct.path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0046da9ead2fd2c36a6a2fa82a2d2ece3e53ebf5" translate="yes" xml:space="preserve">
          <source>An iterator over the arguments of a process, yielding a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; value for each argument.</source>
          <target state="translated">프로세스의 인수를 반복하여 각 인수에 대한 &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 값을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="ebb5d1c5d63504b0108ad325cad0bf7d2676c9ed" translate="yes" xml:space="preserve">
          <source>An iterator over the arguments of a process, yielding an &lt;a href=&quot;../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; value for each argument.</source>
          <target state="translated">프로세스의 인수를 반복하여 각 인수에 대해 &lt;a href=&quot;../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; 값을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="db156c74a7f7733ec8d2fb32dcfb0fa41d392992" translate="yes" xml:space="preserve">
          <source>An iterator over the bytes of a string slice.</source>
          <target state="translated">문자열 슬라이스의 바이트에 대한 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="e870ff1a2a9d31100b2ac9cb6ffbae140349bbde" translate="yes" xml:space="preserve">
          <source>An iterator over the contents of an instance of &lt;code&gt;BufRead&lt;/code&gt; split on a particular byte.</source>
          <target state="translated">특정 바이트에서 &lt;code&gt;BufRead&lt;/code&gt; 분할 인스턴스의 내용에 대한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="df77d35e2c4e122e560661a4bc012ddb30bf89c7" translate="yes" xml:space="preserve">
          <source>An iterator over the disjoint matches of a pattern within &lt;code&gt;self&lt;/code&gt;, yielded in reverse order along with the index of the match.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 내에서 패턴의 분리 된 일치에 대한 반복자 는 일치 색인과 함께 역순으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="f7d549ea470a7ac3f5b7f05549ca71296a3cf479" translate="yes" xml:space="preserve">
          <source>An iterator over the disjoint matches of a pattern within the given string slice.</source>
          <target state="translated">주어진 문자열 슬라이스 내에서 패턴의 분리 된 일치에 대한 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="4e8c4e320605a2ab4ab8ef1e11e40919b14ac665" translate="yes" xml:space="preserve">
          <source>An iterator over the disjoint matches of a pattern within this string slice as well as the index that the match starts at.</source>
          <target state="translated">이 문자열 슬라이스 내에서 패턴의 분리 된 일치와 일치가 시작되는 인덱스에 대한 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="bf644211cc86eb9babefe771489adf416b34d943" translate="yes" xml:space="preserve">
          <source>An iterator over the disjoint matches of a pattern within this string slice, yielded in reverse order.</source>
          <target state="translated">이 문자열 슬라이스 내에서 패턴의 분리 된 일치에 대한 반복자가 역순으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="a4b7288e219c65d73a3e6a54b4428c628926ca26" translate="yes" xml:space="preserve">
          <source>An iterator over the elements of a &lt;code&gt;BinaryHeap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BinaryHeap&lt;/code&gt; 요소의 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="60a4b99de7b2aa615fb862b4ef6662bf265a07b3" translate="yes" xml:space="preserve">
          <source>An iterator over the elements of a &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; 의 요소에 대한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="2f97f18a1c5aa5746176c6f51c4eafd84be2fce3" translate="yes" xml:space="preserve">
          <source>An iterator over the elements of a &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;VecDeque&lt;/code&gt; 요소의 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="91db6e4ce90dbed18c33044e96c535db60789527" translate="yes" xml:space="preserve">
          <source>An iterator over the entries of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; 항목에 대한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="89075f098d105168914ad089684eab6ab82bd15c" translate="yes" xml:space="preserve">
          <source>An iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 항목에 대한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="6598ccbf021650c51246c68845640e9702eed23d" translate="yes" xml:space="preserve">
          <source>An iterator over the escaped version of a byte.</source>
          <target state="translated">이스케이프 된 바이트 버전의 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="56eb86799cc14570dbdb72543cfaf21c05c1abe2" translate="yes" xml:space="preserve">
          <source>An iterator over the items of a &lt;code&gt;BTreeSet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; 항목에 대한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="d5fd2e8685f9eef9092473bf82703d995770cb96" translate="yes" xml:space="preserve">
          <source>An iterator over the items of a &lt;code&gt;HashSet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; 항목에 대한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="c8ce67dcd74b8165190d1c5586f09c2e5112934e" translate="yes" xml:space="preserve">
          <source>An iterator over the keys of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; 의 키에 대한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="6ab13d3c24ccbf1b667994220cf1ff47151b518f" translate="yes" xml:space="preserve">
          <source>An iterator over the keys of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 의 키에 대한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="bdb3c68f21440272514f422ef05c2d524b30604a" translate="yes" xml:space="preserve">
          <source>An iterator over the lines of a string, as string slices.</source>
          <target state="translated">문자열의 줄에 대한 반복자로서 문자열 조각입니다.</target>
        </trans-unit>
        <trans-unit id="47a35066a39c1ed7b30ce9f4878b660c0a1e7474" translate="yes" xml:space="preserve">
          <source>An iterator over the lines of a string.</source>
          <target state="translated">문자열의 줄에 대한 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="4cce7f5b74c3be64996357d548c448d7d2f4462a" translate="yes" xml:space="preserve">
          <source>An iterator over the lines of an instance of &lt;code&gt;BufRead&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BufRead&lt;/code&gt; 인스턴스의 라인에 대한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="a3ce41435c2e05d485713b80e3d67f84041531ab" translate="yes" xml:space="preserve">
          <source>An iterator over the non-ASCII-whitespace substrings of a string, separated by any amount of ASCII whitespace.</source>
          <target state="translated">ASCII ASCII 공백이 아닌 문자열의 비 ASCII 공백 공백 문자열에 대한 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="98639edcf075ef0bbd56694e6fd8f3ab5801fa3b" translate="yes" xml:space="preserve">
          <source>An iterator over the non-whitespace substrings of a string, separated by any amount of whitespace.</source>
          <target state="translated">공백이 아닌 문자열로 구분 된 문자열의 비 공백 부분 문자열에 대한 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="f6d3a015ca8e0813b9d2a570221365ce0bb7b9f3" translate="yes" xml:space="preserve">
          <source>An iterator over the subslices of the vector which are separated by elements that match &lt;code&gt;pred&lt;/code&gt;, starting from the end of the slice.</source>
          <target state="translated">&lt;code&gt;pred&lt;/code&gt; 와 일치하는 요소로 구분 된 벡터의 하위 슬라이스에 대한 반복자슬라이스의 끝에서 시작하여 입니다.</target>
        </trans-unit>
        <trans-unit id="82456e1206b372bf7ea9d2f45cb440546d002943" translate="yes" xml:space="preserve">
          <source>An iterator over the subslices of the vector which are separated by elements that match &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pred&lt;/code&gt; 와 일치하는 요소로 구분되는 벡터의 하위 슬라이스에 대한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="551626c835c28af1e23d1b77fa736e5fca587fd5" translate="yes" xml:space="preserve">
          <source>An iterator over the value in &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt; variant of an &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; 의&lt;/a&gt;&lt;a href=&quot;enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt; 변형에있는 값에 대한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="2ad0a62fd20b029d94f3ea06e170d6042fc65d39" translate="yes" xml:space="preserve">
          <source>An iterator over the value in a &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; variant of a &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; 변형 &lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 의 값에 대한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="06914df7e2feff75ffe46782ed50136c93cfaa1b" translate="yes" xml:space="preserve">
          <source>An iterator over the values of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; 의 값에 대한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="25879aa8de242e212254e6f312a25f5c0bfcd32b" translate="yes" xml:space="preserve">
          <source>An iterator over the values of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 값에 대한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="28ebf2a599d5ab4a921fbe241809a3d3600be3e5" translate="yes" xml:space="preserve">
          <source>An iterator produced by &lt;code&gt;repeat_with()&lt;/code&gt; is not a &lt;code&gt;DoubleEndedIterator&lt;/code&gt;. If you need &lt;code&gt;repeat_with()&lt;/code&gt; to return a &lt;code&gt;DoubleEndedIterator&lt;/code&gt;, please open a GitHub issue explaining your use case.</source>
          <target state="translated">제조 반복기 &lt;code&gt;repeat_with()&lt;/code&gt; 하지 않은 것이다 &lt;code&gt;DoubleEndedIterator&lt;/code&gt; . 당신이 필요로하는 경우 &lt;code&gt;repeat_with()&lt;/code&gt; 돌아 &lt;code&gt;DoubleEndedIterator&lt;/code&gt; 를 , 사용 사례를 설명하는 GitHub의 문제를여십시오.</target>
        </trans-unit>
        <trans-unit id="c51b3a9a86a32de916b3441f5cc928b34139d94d" translate="yes" xml:space="preserve">
          <source>An iterator produced by calling &lt;code&gt;drain_filter&lt;/code&gt; on LinkedList.</source>
          <target state="translated">LinkedList에서 &lt;code&gt;drain_filter&lt;/code&gt; 를 호출하여 생성 된 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="d90f64072c9b86fb5e160826e11d54a35519d306" translate="yes" xml:space="preserve">
          <source>An iterator produced by calling &lt;code&gt;drain_filter&lt;/code&gt; on Vec.</source>
          <target state="translated">Vec에서 &lt;code&gt;drain_filter&lt;/code&gt; 를 호출하여 생성 된 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="e2f38bdab7ee3f88662413a8d0762d07987cc9e4" translate="yes" xml:space="preserve">
          <source>An iterator that always continues to yield &lt;code&gt;None&lt;/code&gt; when exhausted.</source>
          <target state="translated">소진 될 때 항상 &lt;code&gt;None&lt;/code&gt; 을 계속 생성하는 반복자입니다 .</target>
        </trans-unit>
        <trans-unit id="d75b48632d15091a831b75304f768ce72229865c" translate="yes" xml:space="preserve">
          <source>An iterator that attempts to yield all pending values for a &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt;, created by &lt;a href=&quot;struct.receiver#method.try_iter&quot;&gt;&lt;code&gt;try_iter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.receiver#method.try_iter&quot;&gt; &lt;code&gt;try_iter&lt;/code&gt; 에&lt;/a&gt; 의해 생성 된 &lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; 에&lt;/a&gt; 대해 모든 보류중인 값을 생성하려고 시도하는 반복자입니다 .</target>
        </trans-unit>
        <trans-unit id="0c0e45d489e23ad54f254e3c451b03c3ad3633b8" translate="yes" xml:space="preserve">
          <source>An iterator that calls a function with a reference to each element before yielding it.</source>
          <target state="translated">각 요소를 참조하기 전에 함수를 호출하기 전에 함수를 호출하는 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="51a9a929e3e766e1bc15473a2edf034711e9603a" translate="yes" xml:space="preserve">
          <source>An iterator that clones the elements of an underlying iterator.</source>
          <target state="translated">기본 이터레이터의 요소를 복제하는 이터레이터입니다.</target>
        </trans-unit>
        <trans-unit id="d2287777325ba0f8a82eefc9f82886c5e6c0375c" translate="yes" xml:space="preserve">
          <source>An iterator that copies the elements of an underlying iterator.</source>
          <target state="translated">기본 이터레이터의 요소를 복사하는 이터레이터입니다.</target>
        </trans-unit>
        <trans-unit id="11b5eb68a058f133076c97a53287f7350b19b4ed" translate="yes" xml:space="preserve">
          <source>An iterator that decodes UTF-16 encoded code points from an iterator of &lt;code&gt;u16&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;u16&lt;/code&gt; 반복자에서 UTF-16 인코딩 코드 포인트를 디코딩하는 반복자입니다 .</target>
        </trans-unit>
        <trans-unit id="a7c2f22f759edefd0c02e7989a0830d2b9927824" translate="yes" xml:space="preserve">
          <source>An iterator that filters the elements of &lt;code&gt;iter&lt;/code&gt; with &lt;code&gt;predicate&lt;/code&gt;.</source>
          <target state="translated">의 요소 필터 반복자 &lt;code&gt;iter&lt;/code&gt; 와 &lt;code&gt;predicate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="538c0bdbb5f2579b6454154f638e3b2235b91db1" translate="yes" xml:space="preserve">
          <source>An iterator that flattens one level of nesting in an iterator of things that can be turned into iterators.</source>
          <target state="translated">반복자로 바뀔 수있는 것들의 반복자에서 한 수준의 중첩을 평평하게하는 반복자.</target>
        </trans-unit>
        <trans-unit id="9dbf52f6fb3a5236b83ac424b9036cbd60fd5a39" translate="yes" xml:space="preserve">
          <source>An iterator that infinitely &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt;s connections on a &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.tcplistener&quot;&gt; &lt;code&gt;TcpListener&lt;/code&gt; 에서&lt;/a&gt; 연결 을 무한정 &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt; 하는 반복자입니다 .</target>
        </trans-unit>
        <trans-unit id="81a5d4ccf76ade25979b7f90350112e1ade77257" translate="yes" xml:space="preserve">
          <source>An iterator that iterates two other iterators simultaneously.</source>
          <target state="translated">두 개의 다른 반복기를 동시에 반복하는 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="ca3c41a43b14bf4c961d798c07db548fe5c4306e" translate="yes" xml:space="preserve">
          <source>An iterator that knows its exact length.</source>
          <target state="translated">정확한 길이를 알고있는 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="fd413348f096597213f95708520a2a2ee8e8c6ff" translate="yes" xml:space="preserve">
          <source>An iterator that maps each element to an iterator, and yields the elements of the produced iterators.</source>
          <target state="translated">각 요소를 반복자에 매핑하고 생성 된 반복자의 요소를 생성하는 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="e00fb1707b378038f217f0122cb5c2c693a99ce9" translate="yes" xml:space="preserve">
          <source>An iterator that maps the values of &lt;code&gt;iter&lt;/code&gt; with &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">의 값을 매핑하는 반복자 &lt;code&gt;iter&lt;/code&gt; 와 &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c89c4d0277ad0dbe70fcef9f7526e1d26306d3c4" translate="yes" xml:space="preserve">
          <source>An iterator that moves out of a vector.</source>
          <target state="translated">벡터 밖으로 이동하는 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="5d780c4556be41e5ade58ccb90a4cb9745c8a4a0" translate="yes" xml:space="preserve">
          <source>An iterator that only accepts elements while &lt;code&gt;predicate&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;predicate&lt;/code&gt; 는 요소 만 허용하고 술어 는 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="ca756e17e11dd720fde75ad3acbb4dc61da5a0b9" translate="yes" xml:space="preserve">
          <source>An iterator that only iterates over the first &lt;code&gt;n&lt;/code&gt; iterations of &lt;code&gt;iter&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iter&lt;/code&gt; 의 첫 &lt;code&gt;n&lt;/code&gt; 번 반복 만 반복하는 반복자입니다 .</target>
        </trans-unit>
        <trans-unit id="473994edf3f2b12636ecfbae9c0cf95e9976442a" translate="yes" xml:space="preserve">
          <source>An iterator that rejects elements while &lt;code&gt;predicate&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;predicate&lt;/code&gt; 가 요소를 거부하는 반복자 는 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="0464de53ba73fee454800ae2dd5fef9380113b90" translate="yes" xml:space="preserve">
          <source>An iterator that repeats an element endlessly.</source>
          <target state="translated">요소를 끝없이 반복하는 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="7f0331c06c1f3247687712e4a8fa91faa255da79" translate="yes" xml:space="preserve">
          <source>An iterator that repeats elements of type &lt;code&gt;A&lt;/code&gt; endlessly by applying the provided closure &lt;code&gt;F: FnMut() -&amp;gt; A&lt;/code&gt;.</source>
          <target state="translated">제공된 클로저 &lt;code&gt;F: FnMut() -&amp;gt; A&lt;/code&gt; 를 적용하여 &lt;code&gt;A&lt;/code&gt; 유형 의 요소를 끝없이 반복하는 반복자입니다 .</target>
        </trans-unit>
        <trans-unit id="4f71391fe387efdecec312046c6dd55bbf198321" translate="yes" xml:space="preserve">
          <source>An iterator that repeats endlessly.</source>
          <target state="translated">끝없이 반복되는 반복자.</target>
        </trans-unit>
        <trans-unit id="905426af2dba7f51c454090a12d4200524fdd44c" translate="yes" xml:space="preserve">
          <source>An iterator that reports an accurate length using size_hint.</source>
          <target state="translated">size_hint를 사용하여 정확한 길이를보고하는 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="6e8e68927103c8756bd8e724310ac62f637e383b" translate="yes" xml:space="preserve">
          <source>An iterator that skips over &lt;code&gt;n&lt;/code&gt; elements of &lt;code&gt;iter&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iter&lt;/code&gt; 의 &lt;code&gt;n&lt;/code&gt; 개 요소 를 건너 뛰는 반복자입니다 .</target>
        </trans-unit>
        <trans-unit id="cc8fdbf15929bf39a9148cd3ad1f02b7e2f3e8e1" translate="yes" xml:space="preserve">
          <source>An iterator that splits an environment variable into paths according to platform-specific conventions.</source>
          <target state="translated">플랫폼 별 규칙에 따라 환경 변수를 경로로 분할하는 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="57ccd12f7079988974d92028c7ca992c2e3dc8d6" translate="yes" xml:space="preserve">
          <source>An iterator that strings two iterators together.</source>
          <target state="translated">두 개의 반복자를 묶는 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="277e34f21de2c1bcf08658ea7180ea41a724c7da" translate="yes" xml:space="preserve">
          <source>An iterator that uses &lt;code&gt;f&lt;/code&gt; to both filter and map elements from &lt;code&gt;iter&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 를 사용 하여 &lt;code&gt;iter&lt;/code&gt; 의 요소를 필터링하고 맵핑 하는 반복자입니다 .</target>
        </trans-unit>
        <trans-unit id="290a4df52520d8c2cd218b2c5a66207c17bd76b5" translate="yes" xml:space="preserve">
          <source>An iterator that yields &lt;code&gt;None&lt;/code&gt; forever after the underlying iterator yields &lt;code&gt;None&lt;/code&gt; once.</source>
          <target state="translated">기본 이터레이터가 &lt;code&gt;None&lt;/code&gt; 을 한 번 생성 한 후 &lt;code&gt;None&lt;/code&gt; 을 영원히 생성하는 이터레이터입니다 .</target>
        </trans-unit>
        <trans-unit id="8077f46e4926a9ba2fe0c3a0111f99b3bfd0cee7" translate="yes" xml:space="preserve">
          <source>An iterator that yields a single element of type &lt;code&gt;A&lt;/code&gt; by applying the provided closure &lt;code&gt;F: FnOnce() -&amp;gt; A&lt;/code&gt;.</source>
          <target state="translated">제공된 클로저 &lt;code&gt;F: FnOnce() -&amp;gt; A&lt;/code&gt; 를 적용하여 &lt;code&gt;A&lt;/code&gt; 유형 의 단일 요소를 생성하는 반복자입니다 .</target>
        </trans-unit>
        <trans-unit id="f74ed23fee03be7f9726d86e04759a8cdc7c98f8" translate="yes" xml:space="preserve">
          <source>An iterator that yields an element exactly once.</source>
          <target state="translated">요소를 정확히 한 번만 생성하는 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="d839e72a6966bc49a09991c75f6ebb8c0f577f86" translate="yes" xml:space="preserve">
          <source>An iterator that yields nothing.</source>
          <target state="translated">아무것도 생성하지 않는 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="5c4e0833b181576427135eb9c8df2d3b1200509f" translate="yes" xml:space="preserve">
          <source>An iterator that yields the current count and the element during iteration.</source>
          <target state="translated">반복하는 동안 현재 카운트와 요소를 산출하는 반복자.</target>
        </trans-unit>
        <trans-unit id="13cc9cc84ea0ac8db6860e2d362f3768df8c56c8" translate="yes" xml:space="preserve">
          <source>An iterator that yields the literal escape code of a &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 의 리터럴 이스케이프 코드를 생성하는 반복자입니다 .</target>
        </trans-unit>
        <trans-unit id="f37b0b305dd49cedb47e6f8dfa5f3a2bdad3bf67" translate="yes" xml:space="preserve">
          <source>An iterator to maintain state while iterating another iterator.</source>
          <target state="translated">다른 반복자를 반복하면서 상태를 유지하는 반복자.</target>
        </trans-unit>
        <trans-unit id="47ba4cac2215dd1a04b338eb0e4a94df69cf3c0f" translate="yes" xml:space="preserve">
          <source>An iterator visiting all elements in arbitrary order. The iterator element type is &lt;code&gt;&amp;amp;'a T&lt;/code&gt;.</source>
          <target state="translated">모든 요소를 ​​임의의 순서로 방문하는 반복자. 반복자 요소 유형은 &lt;code&gt;&amp;amp;'a T&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7550894b7d1bb85e45b801eaeed48efa989854c0" translate="yes" xml:space="preserve">
          <source>An iterator visiting all key-value pairs in arbitrary order, with mutable references to the values. The iterator element type is &lt;code&gt;(&amp;amp;'a K, &amp;amp;'a mut V)&lt;/code&gt;.</source>
          <target state="translated">모든 키-값 쌍을 임의의 순서로 방문하고 값을 변경할 수있는 반복자가 반복자입니다. 반복자 요소 유형은 &lt;code&gt;(&amp;amp;'a K, &amp;amp;'a mut V)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1b08b2653f7dcb8dc940ed24069740a24ab5b76a" translate="yes" xml:space="preserve">
          <source>An iterator visiting all key-value pairs in arbitrary order. The iterator element type is &lt;code&gt;(&amp;amp;'a K, &amp;amp;'a V)&lt;/code&gt;.</source>
          <target state="translated">모든 키-값 쌍을 임의의 순서로 방문하는 반복자입니다. 반복자 요소 유형은 &lt;code&gt;(&amp;amp;'a K, &amp;amp;'a V)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a52b26a20f6e5a2edebe10f6f90cf9507490a85c" translate="yes" xml:space="preserve">
          <source>An iterator visiting all keys in arbitrary order. The iterator element type is &lt;code&gt;&amp;amp;'a K&lt;/code&gt;.</source>
          <target state="translated">모든 키를 임의의 순서로 방문하는 반복자입니다. 반복자 요소 유형은 &lt;code&gt;&amp;amp;'a K&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cee3468b8b5e0fdd5a440c2d5df35c4c2db2ae90" translate="yes" xml:space="preserve">
          <source>An iterator visiting all values in arbitrary order. The iterator element type is &lt;code&gt;&amp;amp;'a V&lt;/code&gt;.</source>
          <target state="translated">모든 값을 임의의 순서로 방문하는 반복자입니다. 반복자 요소 유형은 &lt;code&gt;&amp;amp;'a V&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7ae307f212519994d8b694a5d942377f4aec4823" translate="yes" xml:space="preserve">
          <source>An iterator visiting all values mutably in arbitrary order. The iterator element type is &lt;code&gt;&amp;amp;'a mut V&lt;/code&gt;.</source>
          <target state="translated">모든 값을 임의로 순서대로 방문하는 반복자입니다. 반복자 요소 유형은 &lt;code&gt;&amp;amp;'a mut V&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="211d7c1adc8a12b57341be994e857003e54c6bbd" translate="yes" xml:space="preserve">
          <source>An iterator where each iteration calls the provided closure &lt;code&gt;F: FnMut() -&amp;gt; Option&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">각 반복이 제공된 클로저 &lt;code&gt;F: FnMut() -&amp;gt; Option&amp;lt;T&amp;gt;&lt;/code&gt; 호출하는 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="c53ddbd1d3e296430ed20afa68efda72ca0ded32" translate="yes" xml:space="preserve">
          <source>An iterator with a &lt;code&gt;peek()&lt;/code&gt; that returns an optional reference to the next element.</source>
          <target state="translated">다음 요소에 대한 선택적 참조를 반환하는 &lt;code&gt;peek()&lt;/code&gt; 가 있는 반복자입니다 .</target>
        </trans-unit>
        <trans-unit id="c9cd5154a20293338cfe2c0c0c884bc897a9a0cb" translate="yes" xml:space="preserve">
          <source>An new iterator where each successive item is computed based on the preceding one.</source>
          <target state="translated">각 연속 항목이 이전 항목을 기반으로 계산되는 새 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="767a832ec64e700730e273e825321e36a3ef86e1" translate="yes" xml:space="preserve">
          <source>An occupied entry.</source>
          <target state="translated">점유 된 항목입니다.</target>
        </trans-unit>
        <trans-unit id="678664bfa424da9fc0ca21e4760f29b4b952648d" translate="yes" xml:space="preserve">
          <source>An optional item</source>
          <target state="translated">선택 품목</target>
        </trans-unit>
        <trans-unit id="d7f5308e6f605cdab4dbb8b387f9c93de98d0922" translate="yes" xml:space="preserve">
          <source>An order is a total order if it is (for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;):</source>
          <target state="translated">주문은 다음과 같은 경우 총 주문입니다 (모든 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;c&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e7c75396d6933448cc7456d6beaf9cf648ea0ef5" translate="yes" xml:space="preserve">
          <source>An ordering where a compared value is equal to another.</source>
          <target state="translated">비교 값이 다른 값과 동일한 순서입니다.</target>
        </trans-unit>
        <trans-unit id="09dba8210b3d0ce590a3a5f065b62a6a8ab493fb" translate="yes" xml:space="preserve">
          <source>An ordering where a compared value is greater than another.</source>
          <target state="translated">비교 값이 다른 값보다 큰 순서입니다.</target>
        </trans-unit>
        <trans-unit id="a2c8ca4c96fc50eebfe4b351916be57d1bf56d8c" translate="yes" xml:space="preserve">
          <source>An ordering where a compared value is less than another.</source>
          <target state="translated">비교 값이 다른 값보다 작은 순서.</target>
        </trans-unit>
        <trans-unit id="38792f39e0fa160ba176220b302fc6518c1e2555" translate="yes" xml:space="preserve">
          <source>An owned permission to join on a thread (block on its termination).</source>
          <target state="translated">스레드에 참여할 수있는 소유 권한 (종료시 차단).</target>
        </trans-unit>
        <trans-unit id="8c3512dc7441f7c48feb0adfb2813ca8cbecd465" translate="yes" xml:space="preserve">
          <source>An owned, mutable path (akin to &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">소유하고 변경할 수있는 경로 (akin to &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e84205a36cc39374bcb7d05c1b1547f37b9b5189" translate="yes" xml:space="preserve">
          <source>An owning iterator over messages on a &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt;, created by &lt;strong&gt;Receiver::into_iter&lt;/strong&gt;.</source>
          <target state="translated">A의 메시지를 통해 소유 반복자 &lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt; 에 의해 만들어진, &lt;strong&gt;수신기 :: into_iter&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="83bd664b01b4716a8aced24a8192a6358972a99f" translate="yes" xml:space="preserve">
          <source>An owning iterator over the elements of a &lt;code&gt;BinaryHeap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BinaryHeap&lt;/code&gt; 요소를 소유하는 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="34718a674d09c2eb637513ac6f89289f300970ef" translate="yes" xml:space="preserve">
          <source>An owning iterator over the elements of a &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; 의 요소에 대한 소유의 이터레이터 입니다.</target>
        </trans-unit>
        <trans-unit id="f6f353b2a400a09971f91285403f6b780ae991c4" translate="yes" xml:space="preserve">
          <source>An owning iterator over the elements of a &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;VecDeque&lt;/code&gt; 요소를 소유 한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="77a86a6c2dd3031f17c5e8abfe6100f81887dd42" translate="yes" xml:space="preserve">
          <source>An owning iterator over the entries of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; 의 항목을 소유 한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="209ab8cbe2152f0b0d82c7256751114f7cd068b9" translate="yes" xml:space="preserve">
          <source>An owning iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 의 항목을 소유 한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="ef6f78f2a2dbde9b33ceeac921bd77fbb502b5bc" translate="yes" xml:space="preserve">
          <source>An owning iterator over the items of a &lt;code&gt;BTreeSet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; 항목을 소유 한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="427fdeccedc75e2673269080f0ce6c0924e6c1bd" translate="yes" xml:space="preserve">
          <source>An owning iterator over the items of a &lt;code&gt;HashSet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; 항목을 소유 한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="b9b2d7fe27e12071feb7334cad3f7f83e9e84aa2" translate="yes" xml:space="preserve">
          <source>An unary operator was used on a type which doesn't implement it.</source>
          <target state="translated">단항 연산자는이를 구현하지 않는 유형에 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="dcb71e1bf306a3b27e4be98207d51ae66d320fdd" translate="yes" xml:space="preserve">
          <source>An unbounded range (&lt;code&gt;..&lt;/code&gt;).</source>
          <target state="translated">무한 범위 ( &lt;code&gt;..&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="3caad6b327abced5bae6f8ff205241ca33ed53ab" translate="yes" xml:space="preserve">
          <source>An unchecked assertion allows a program in an inconsistent state to keep running, which might have unexpected consequences but does not introduce unsafety as long as this only happens in safe code. The performance cost of assertions, is however, not measurable in general. Replacing &lt;a href=&quot;macro.assert&quot;&gt;&lt;code&gt;assert!&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;debug_assert!&lt;/code&gt; is thus only encouraged after thorough profiling, and more importantly, only in safe code!</source>
          <target state="translated">확인되지 않은 어설 션을 사용하면 일관성이없는 상태의 프로그램을 계속 실행할 수 있습니다. 이로 인해 예기치 않은 결과가 발생할 수 있지만 안전 코드에서만 발생하는 한 안전하지 않습니다. 그러나 어설 션의 성능 비용은 일반적으로 측정 할 수 없습니다. &lt;a href=&quot;macro.assert&quot;&gt; &lt;code&gt;assert!&lt;/code&gt; &lt;/a&gt; 교체하십시오 ! &lt;code&gt;debug_assert!&lt;/code&gt; 와 함께 ! 따라서 철저한 프로파일 링 후에 만, 더 중요한 것은 안전한 코드에서만 권장됩니다!</target>
        </trans-unit>
        <trans-unit id="490b1d248ac38d604233cacff667b31a463976df" translate="yes" xml:space="preserve">
          <source>An undeclared label was used.</source>
          <target state="translated">신고되지 않은 라벨이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="fc0bdd57bc131e7f23a48af9227bf2c7b9e2b4dd" translate="yes" xml:space="preserve">
          <source>An undeclared type or module was used.</source>
          <target state="translated">선언되지 않은 유형 또는 모듈이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="2dbef161c3305374da24ca6e3ae9cdc7bdefe6b4" translate="yes" xml:space="preserve">
          <source>An unknown &quot;kind&quot; was specified for a link attribute. Erroneous code example:</source>
          <target state="translated">링크 속성에 알 수없는 &quot;종류&quot;가 지정되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="a5956e957dc8b784f0e077b9955dd790db201d80" translate="yes" xml:space="preserve">
          <source>An unknown argument was given to the &lt;code&gt;inline&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; 속성에 알 수없는 인수가 제공되었습니다 .</target>
        </trans-unit>
        <trans-unit id="9a99f6d07dc4d8ba35aa89128cc34d06dd11ce0f" translate="yes" xml:space="preserve">
          <source>An unknown external lang item was used. Erroneous code example:</source>
          <target state="translated">알 수없는 외부 언어 항목이 사용되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="1356f6d3a3c2ce1216defe8b6863fd5e9393d5fa" translate="yes" xml:space="preserve">
          <source>An unknown field was specified into a structure.</source>
          <target state="translated">알 수없는 필드가 구조에 지정되었습니다.</target>
        </trans-unit>
        <trans-unit id="672bd73128faa09c7f440466e9f29739ad4de42d" translate="yes" xml:space="preserve">
          <source>An unknown field was specified into an enum's structure variant.</source>
          <target state="translated">알 수없는 필드가 열거 형의 구조 변형에 지정되었습니다.</target>
        </trans-unit>
        <trans-unit id="e8a840a4e189fb8e18f90b5fe877d384d51d1d3c" translate="yes" xml:space="preserve">
          <source>An unknown lint was used on the command line.</source>
          <target state="translated">알 수없는 보풀이 명령 행에 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="d472ec49c42739263d3ec941f6cf5b5468a2d3b2" translate="yes" xml:space="preserve">
          <source>An unknown meta item was used.</source>
          <target state="translated">알 수없는 메타 항목이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="a940cccd136dc43c95bcfd2c10667fe77e672634" translate="yes" xml:space="preserve">
          <source>An unknown predicate was used inside the &lt;code&gt;cfg&lt;/code&gt; attribute.</source>
          <target state="translated">알 수없는 술어가 &lt;code&gt;cfg&lt;/code&gt; 속성 내에 사용되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c12ae2fbe23adbaee9a27dcd9a18b88d8f9167df" translate="yes" xml:space="preserve">
          <source>An unnamed address:</source>
          <target state="translated">이름없는 주소 :</target>
        </trans-unit>
        <trans-unit id="3386e5166859dc07663dec10855432efda42e389" translate="yes" xml:space="preserve">
          <source>An unpoisoned &lt;code&gt;Once&lt;/code&gt;:</source>
          <target state="translated">unpoisoned &lt;code&gt;Once&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9a03f5a8f224f5f2ce3d5df647878dfe5aac207b" translate="yes" xml:space="preserve">
          <source>An unresolved name was used.</source>
          <target state="translated">확인되지 않은 이름이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="c801b4c85f18e94f7cb6ce228ae449c345e89b49" translate="yes" xml:space="preserve">
          <source>An unstable feature was used.</source>
          <target state="translated">불안정한 기능이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="ad604b2507c78bd47c93ad249e197a918e7208ca" translate="yes" xml:space="preserve">
          <source>An unsupported representation was attempted on a zero-variant enum.</source>
          <target state="translated">변형이없는 열거 형에서 지원되지 않는 표현이 시도되었습니다.</target>
        </trans-unit>
        <trans-unit id="999140d65b2dddb09bc1533f2a2a2de632081b87" translate="yes" xml:space="preserve">
          <source>Anatomy of a Rust Program</source>
          <target state="translated">녹 프로그램의 해부</target>
        </trans-unit>
        <trans-unit id="f96afdd93db8b2e4f4aa8b97a7ac6e4f106649a9" translate="yes" xml:space="preserve">
          <source>Ancestors</source>
          <target state="translated">Ancestors</target>
        </trans-unit>
        <trans-unit id="a69185f73b3266ea2ea0196235a7920d98b23569" translate="yes" xml:space="preserve">
          <source>Ancestors::all</source>
          <target state="translated">Ancestors::all</target>
        </trans-unit>
        <trans-unit id="5d0f93422db0f668490adf089654ecece89c57a9" translate="yes" xml:space="preserve">
          <source>Ancestors::any</source>
          <target state="translated">Ancestors::any</target>
        </trans-unit>
        <trans-unit id="c4d070344a11e561f295e6e7e6205f761d5798b6" translate="yes" xml:space="preserve">
          <source>Ancestors::borrow</source>
          <target state="translated">Ancestors::borrow</target>
        </trans-unit>
        <trans-unit id="a84c8539090bc4c2974d99b05a787e636ebe0acb" translate="yes" xml:space="preserve">
          <source>Ancestors::borrow_mut</source>
          <target state="translated">Ancestors::borrow_mut</target>
        </trans-unit>
        <trans-unit id="334238f85474f459cc0ffaef3421caf90b07c6e6" translate="yes" xml:space="preserve">
          <source>Ancestors::by_ref</source>
          <target state="translated">Ancestors::by_ref</target>
        </trans-unit>
        <trans-unit id="6fdc4e3375706d83d8aecc92a22ee70bff5dfab4" translate="yes" xml:space="preserve">
          <source>Ancestors::chain</source>
          <target state="translated">Ancestors::chain</target>
        </trans-unit>
        <trans-unit id="dce0f9cae4b8d7222a0b11c873b249cd98da26b3" translate="yes" xml:space="preserve">
          <source>Ancestors::clone</source>
          <target state="translated">Ancestors::clone</target>
        </trans-unit>
        <trans-unit id="31848f144e07d27fc7390a8c92d56ab88474c213" translate="yes" xml:space="preserve">
          <source>Ancestors::clone_from</source>
          <target state="translated">Ancestors::clone_from</target>
        </trans-unit>
        <trans-unit id="35f7611233faafb5be9d7d385104097f21e72511" translate="yes" xml:space="preserve">
          <source>Ancestors::clone_into</source>
          <target state="translated">Ancestors::clone_into</target>
        </trans-unit>
        <trans-unit id="0d02f4a4459ad43a2bc9f83a20b48ce81eb5eefc" translate="yes" xml:space="preserve">
          <source>Ancestors::cloned</source>
          <target state="translated">Ancestors::cloned</target>
        </trans-unit>
        <trans-unit id="67ff55ec2d9537e58736a03fd50c337049b761f0" translate="yes" xml:space="preserve">
          <source>Ancestors::cmp</source>
          <target state="translated">Ancestors::cmp</target>
        </trans-unit>
        <trans-unit id="0d35d199d39196de0523350cd24a1241424fa231" translate="yes" xml:space="preserve">
          <source>Ancestors::collect</source>
          <target state="translated">Ancestors::collect</target>
        </trans-unit>
        <trans-unit id="4865b6ff2a1901685d10435c12cf071b254d3a62" translate="yes" xml:space="preserve">
          <source>Ancestors::copied</source>
          <target state="translated">Ancestors::copied</target>
        </trans-unit>
        <trans-unit id="f28d6b4a44e14f0d15c4f132d556116c210c1c84" translate="yes" xml:space="preserve">
          <source>Ancestors::count</source>
          <target state="translated">Ancestors::count</target>
        </trans-unit>
        <trans-unit id="a6a740680e9008614345c582b8e1985861829875" translate="yes" xml:space="preserve">
          <source>Ancestors::cycle</source>
          <target state="translated">Ancestors::cycle</target>
        </trans-unit>
        <trans-unit id="0810bcf20fe4de2312f283ad13e930eaa61b0c30" translate="yes" xml:space="preserve">
          <source>Ancestors::enumerate</source>
          <target state="translated">Ancestors::enumerate</target>
        </trans-unit>
        <trans-unit id="f443387bf4a86a6cc1330d9f2c4d3b913b1c1dd0" translate="yes" xml:space="preserve">
          <source>Ancestors::eq</source>
          <target state="translated">Ancestors::eq</target>
        </trans-unit>
        <trans-unit id="796eb87c3af9fac554be5d4ec57ca702d510701f" translate="yes" xml:space="preserve">
          <source>Ancestors::filter</source>
          <target state="translated">Ancestors::filter</target>
        </trans-unit>
        <trans-unit id="d1822e4ea409150f5e23e24201bc84ef25560137" translate="yes" xml:space="preserve">
          <source>Ancestors::filter_map</source>
          <target state="translated">Ancestors::filter_map</target>
        </trans-unit>
        <trans-unit id="1e6cc0ef677409077aa639becd452ada01ece8d8" translate="yes" xml:space="preserve">
          <source>Ancestors::find</source>
          <target state="translated">Ancestors::find</target>
        </trans-unit>
        <trans-unit id="657aafc8bbaf8304573fbc00e24419ba040782a9" translate="yes" xml:space="preserve">
          <source>Ancestors::find_map</source>
          <target state="translated">Ancestors::find_map</target>
        </trans-unit>
        <trans-unit id="beeb7e3fb0fbc04618a5300c980c6f59ed075dcd" translate="yes" xml:space="preserve">
          <source>Ancestors::flat_map</source>
          <target state="translated">Ancestors::flat_map</target>
        </trans-unit>
        <trans-unit id="47bd10eda5c1ca25f0cc303ef197cbc1220d1b53" translate="yes" xml:space="preserve">
          <source>Ancestors::flatten</source>
          <target state="translated">Ancestors::flatten</target>
        </trans-unit>
        <trans-unit id="a456cec1879b2b70a77233841a841755191a8a86" translate="yes" xml:space="preserve">
          <source>Ancestors::fmt</source>
          <target state="translated">Ancestors::fmt</target>
        </trans-unit>
        <trans-unit id="1f02f420430d3894ec9ecddf11dd94365e77ac19" translate="yes" xml:space="preserve">
          <source>Ancestors::fold</source>
          <target state="translated">Ancestors::fold</target>
        </trans-unit>
        <trans-unit id="3ca5818636166fd5b398f8e40a922c894b0abbb6" translate="yes" xml:space="preserve">
          <source>Ancestors::for_each</source>
          <target state="translated">Ancestors::for_each</target>
        </trans-unit>
        <trans-unit id="4264a030cb324bfbad2fa80a46e42c679803a0c3" translate="yes" xml:space="preserve">
          <source>Ancestors::from</source>
          <target state="translated">Ancestors::from</target>
        </trans-unit>
        <trans-unit id="32047f73315575a8e50a462155406bb910ceed17" translate="yes" xml:space="preserve">
          <source>Ancestors::fuse</source>
          <target state="translated">Ancestors::fuse</target>
        </trans-unit>
        <trans-unit id="41f1796019df27f1dc523c24819d1254f099c660" translate="yes" xml:space="preserve">
          <source>Ancestors::ge</source>
          <target state="translated">Ancestors::ge</target>
        </trans-unit>
        <trans-unit id="f1594f0c385b82f3427f45ed26a50d1dac4fa05e" translate="yes" xml:space="preserve">
          <source>Ancestors::gt</source>
          <target state="translated">Ancestors::gt</target>
        </trans-unit>
        <trans-unit id="dd54e2ff77b477361ff6376d5b04afaad6a7ef21" translate="yes" xml:space="preserve">
          <source>Ancestors::inspect</source>
          <target state="translated">Ancestors::inspect</target>
        </trans-unit>
        <trans-unit id="1bc8d1bb95f4aedebacf2a84051d097086c1cc75" translate="yes" xml:space="preserve">
          <source>Ancestors::into</source>
          <target state="translated">Ancestors::into</target>
        </trans-unit>
        <trans-unit id="6f7bdf57cf985a0498067e483576359d43c33000" translate="yes" xml:space="preserve">
          <source>Ancestors::into_iter</source>
          <target state="translated">Ancestors::into_iter</target>
        </trans-unit>
        <trans-unit id="e4f570f8f86838a0b2f0996de24967465582d845" translate="yes" xml:space="preserve">
          <source>Ancestors::is_sorted</source>
          <target state="translated">Ancestors::is_sorted</target>
        </trans-unit>
        <trans-unit id="8fa7773f21437bd02461103d0f128fe2f328180a" translate="yes" xml:space="preserve">
          <source>Ancestors::is_sorted_by</source>
          <target state="translated">Ancestors::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="da156b45c81720439526b87f492a4b80dde53f7a" translate="yes" xml:space="preserve">
          <source>Ancestors::is_sorted_by_key</source>
          <target state="translated">Ancestors::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="6bf6d1d6ec433eb2498f88c1821e2e8d204490c9" translate="yes" xml:space="preserve">
          <source>Ancestors::last</source>
          <target state="translated">Ancestors::last</target>
        </trans-unit>
        <trans-unit id="6182ceed3235394e0830f635f2568ba50e3e7bb2" translate="yes" xml:space="preserve">
          <source>Ancestors::le</source>
          <target state="translated">Ancestors::le</target>
        </trans-unit>
        <trans-unit id="ba00a013a0f8fd57e29b01f66afccf088e1d0023" translate="yes" xml:space="preserve">
          <source>Ancestors::lt</source>
          <target state="translated">Ancestors::lt</target>
        </trans-unit>
        <trans-unit id="b588193780984cc7ebdb2f28a2c09aad1660160a" translate="yes" xml:space="preserve">
          <source>Ancestors::map</source>
          <target state="translated">Ancestors::map</target>
        </trans-unit>
        <trans-unit id="aa73ed60029c8667bd3541a6cd43b17d298a34bc" translate="yes" xml:space="preserve">
          <source>Ancestors::max</source>
          <target state="translated">Ancestors::max</target>
        </trans-unit>
        <trans-unit id="ab6d430bbae01a6904e8639546e74aa743ec4546" translate="yes" xml:space="preserve">
          <source>Ancestors::max_by</source>
          <target state="translated">Ancestors::max_by</target>
        </trans-unit>
        <trans-unit id="3f9a117ba2cfb9ce3093457ddf5a2896b25c3699" translate="yes" xml:space="preserve">
          <source>Ancestors::max_by_key</source>
          <target state="translated">Ancestors::max_by_key</target>
        </trans-unit>
        <trans-unit id="d86ac9020bc2e94f4de10dd0521bc6648555300a" translate="yes" xml:space="preserve">
          <source>Ancestors::min</source>
          <target state="translated">Ancestors::min</target>
        </trans-unit>
        <trans-unit id="d1a3237b0f7d1400e70026876d1a9e1edfd954fb" translate="yes" xml:space="preserve">
          <source>Ancestors::min_by</source>
          <target state="translated">Ancestors::min_by</target>
        </trans-unit>
        <trans-unit id="4a76ef60a157a414e53965e7b20bdb80a42a93c5" translate="yes" xml:space="preserve">
          <source>Ancestors::min_by_key</source>
          <target state="translated">Ancestors::min_by_key</target>
        </trans-unit>
        <trans-unit id="5d2760f02e37aabc523ea5766e6897c5ccc56a0b" translate="yes" xml:space="preserve">
          <source>Ancestors::ne</source>
          <target state="translated">Ancestors::ne</target>
        </trans-unit>
        <trans-unit id="94b5fbd4a6186842bbae09888725d74af29ff76c" translate="yes" xml:space="preserve">
          <source>Ancestors::next</source>
          <target state="translated">Ancestors::next</target>
        </trans-unit>
        <trans-unit id="061044f738cb0378794d00307372b84bda535007" translate="yes" xml:space="preserve">
          <source>Ancestors::nth</source>
          <target state="translated">Ancestors::nth</target>
        </trans-unit>
        <trans-unit id="104a8aab4cf5a11201b887398168f2f5e1f87087" translate="yes" xml:space="preserve">
          <source>Ancestors::partial_cmp</source>
          <target state="translated">Ancestors::partial_cmp</target>
        </trans-unit>
        <trans-unit id="bed7abfd1f96e21405eb173c4d15c03b456d92a5" translate="yes" xml:space="preserve">
          <source>Ancestors::partition</source>
          <target state="translated">Ancestors::partition</target>
        </trans-unit>
        <trans-unit id="84cd0d32c4daeda367ba0a2ae2e2b6a7ff4841da" translate="yes" xml:space="preserve">
          <source>Ancestors::peekable</source>
          <target state="translated">Ancestors::peekable</target>
        </trans-unit>
        <trans-unit id="b4ddc60ef630227f7ade5b8c560fef259500316e" translate="yes" xml:space="preserve">
          <source>Ancestors::position</source>
          <target state="translated">Ancestors::position</target>
        </trans-unit>
        <trans-unit id="7a31ee815f86cdd427869f86ea4e16e837ac74a5" translate="yes" xml:space="preserve">
          <source>Ancestors::product</source>
          <target state="translated">Ancestors::product</target>
        </trans-unit>
        <trans-unit id="b560f4cdd9c918e68c647f28819fc526f4443425" translate="yes" xml:space="preserve">
          <source>Ancestors::rev</source>
          <target state="translated">Ancestors::rev</target>
        </trans-unit>
        <trans-unit id="2d6150b963da3a5f8bb4fbcf3bede9ac1d149eac" translate="yes" xml:space="preserve">
          <source>Ancestors::rposition</source>
          <target state="translated">Ancestors::rposition</target>
        </trans-unit>
        <trans-unit id="33695d4fc7bd02cc81076a7f065f59ae331ce9d8" translate="yes" xml:space="preserve">
          <source>Ancestors::scan</source>
          <target state="translated">Ancestors::scan</target>
        </trans-unit>
        <trans-unit id="a71e116d1152775af982054ee8766888b8c17bf5" translate="yes" xml:space="preserve">
          <source>Ancestors::size_hint</source>
          <target state="translated">Ancestors::size_hint</target>
        </trans-unit>
        <trans-unit id="1492747daf21eb6d17932ae78e4e1bb6900ec817" translate="yes" xml:space="preserve">
          <source>Ancestors::skip</source>
          <target state="translated">Ancestors::skip</target>
        </trans-unit>
        <trans-unit id="7ccb1c50d003cbcf82f746c7c89b476d0db40ef9" translate="yes" xml:space="preserve">
          <source>Ancestors::skip_while</source>
          <target state="translated">Ancestors::skip_while</target>
        </trans-unit>
        <trans-unit id="2d680c75e7e0a20bba67113ba634c0b9819ec275" translate="yes" xml:space="preserve">
          <source>Ancestors::step_by</source>
          <target state="translated">Ancestors::step_by</target>
        </trans-unit>
        <trans-unit id="bb4081cc4c0735468e080f3f00abdd7bfc4c7b73" translate="yes" xml:space="preserve">
          <source>Ancestors::sum</source>
          <target state="translated">Ancestors::sum</target>
        </trans-unit>
        <trans-unit id="b184ac7bf98e724a647631566c8e7b44261ba11d" translate="yes" xml:space="preserve">
          <source>Ancestors::take</source>
          <target state="translated">Ancestors::take</target>
        </trans-unit>
        <trans-unit id="551d6d8baae9a0ead4f49097f5951591191f29fd" translate="yes" xml:space="preserve">
          <source>Ancestors::take_while</source>
          <target state="translated">Ancestors::take_while</target>
        </trans-unit>
        <trans-unit id="f38b2d2e57427d6c5d34e24a9e37978f181043c7" translate="yes" xml:space="preserve">
          <source>Ancestors::to_owned</source>
          <target state="translated">Ancestors::to_owned</target>
        </trans-unit>
        <trans-unit id="bd8e948ee34c84cdc8f1385bf9b2d83abdbf9fb4" translate="yes" xml:space="preserve">
          <source>Ancestors::try_fold</source>
          <target state="translated">Ancestors::try_fold</target>
        </trans-unit>
        <trans-unit id="46ad3f23b6a14805c5bb02a0abccbaa9ad1f0c58" translate="yes" xml:space="preserve">
          <source>Ancestors::try_for_each</source>
          <target state="translated">Ancestors::try_for_each</target>
        </trans-unit>
        <trans-unit id="f18ea48cefb527612333927e42f98b5493e80a96" translate="yes" xml:space="preserve">
          <source>Ancestors::try_from</source>
          <target state="translated">Ancestors::try_from</target>
        </trans-unit>
        <trans-unit id="f07951de2fcfeba585ae159316c166c38d8606b4" translate="yes" xml:space="preserve">
          <source>Ancestors::try_into</source>
          <target state="translated">Ancestors::try_into</target>
        </trans-unit>
        <trans-unit id="0008829b37e7881a29a429bd8ff5a7a5ef753374" translate="yes" xml:space="preserve">
          <source>Ancestors::type_id</source>
          <target state="translated">Ancestors::type_id</target>
        </trans-unit>
        <trans-unit id="04f137aff1969f866b7d2666a9252de9e0efa21b" translate="yes" xml:space="preserve">
          <source>Ancestors::unzip</source>
          <target state="translated">Ancestors::unzip</target>
        </trans-unit>
        <trans-unit id="55dbfc2c3d770eaac08b3c73d87bccce57c4f78d" translate="yes" xml:space="preserve">
          <source>Ancestors::zip</source>
          <target state="translated">Ancestors::zip</target>
        </trans-unit>
        <trans-unit id="a01e33f4dcdb6ba1ae9f34a97cf8f6deeedf1a8d" translate="yes" xml:space="preserve">
          <source>And</source>
          <target state="translated">And</target>
        </trans-unit>
        <trans-unit id="42b71964be13234f4cbc3e386af8045e5f37b66e" translate="yes" xml:space="preserve">
          <source>And &lt;em&gt;src/front_of_house.rs&lt;/em&gt; gets the definitions from the body of the &lt;code&gt;front_of_house&lt;/code&gt; module, as shown in Listing 7-22.</source>
          <target state="translated">그리고 &lt;em&gt;SRC는 / front_of_house.rs이&lt;/em&gt; 의 몸에서 정의를 얻을 수 &lt;code&gt;front_of_house&lt;/code&gt; 의 목록 7-22에서와 같이 모듈.</target>
        </trans-unit>
        <trans-unit id="a66dda047400c5c52222e76fafe04295868d79a8" translate="yes" xml:space="preserve">
          <source>And a very common source of output is standard output:</source>
          <target state="translated">그리고 매우 일반적인 출력 소스는 표준 출력입니다.</target>
        </trans-unit>
        <trans-unit id="b91a984e8eba980f8ed5afc44476d8d32720a1d5" translate="yes" xml:space="preserve">
          <source>And finally, let&amp;rsquo;s make sure that we don&amp;rsquo;t get any lines when we search for a word that isn&amp;rsquo;t anywhere in the poem, such as &amp;ldquo;monomorphization&amp;rdquo;:</source>
          <target state="translated">그리고 마지막으로,&amp;ldquo;모노 모르 파이 제이션 (monomorphization)&amp;rdquo;과 같이시의 어느 곳에도없는 단어를 검색 할 때 어떤 줄도 갖지 않도록하십시오 :</target>
        </trans-unit>
        <trans-unit id="8ddbbced7930dcaf198948383ed803d74e9323cf" translate="yes" xml:space="preserve">
          <source>And finally, the standard library exports a number of standard macros, and &lt;a href=&quot;#macros&quot;&gt;lists them on this page&lt;/a&gt; (technically, not all of the standard macros are defined by the standard library - some are defined by the compiler - but they are documented here the same). Like the prelude, the standard macros are imported by default into all crates.</source>
          <target state="translated">마지막으로 표준 라이브러리는 여러 표준 매크로를 내보내고이 &lt;a href=&quot;#macros&quot;&gt;페이지에 나열합니다&lt;/a&gt; (기술적으로 모든 표준 매크로가 표준 라이브러리에 의해 정의 된 것은 아니며 일부는 컴파일러에 의해 정의되지만 여기서는 동일하게 문서화 됨) . 전주곡과 마찬가지로 표준 매크로는 기본적으로 모든 상자에 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="01c604c6cbed200d9271efd93c6961cdbaa99ebc" translate="yes" xml:space="preserve">
          <source>And now let's give working examples:</source>
          <target state="translated">그리고 이제 작업 예제를 보자.</target>
        </trans-unit>
        <trans-unit id="076add01b447af4a01e4ff6b95c8cd6d23f8bbbe" translate="yes" xml:space="preserve">
          <source>And now some working examples:</source>
          <target state="translated">그리고 이제 몇 가지 실례 :</target>
        </trans-unit>
        <trans-unit id="965c5135f65b1edbef655afbf975cd109690bf20" translate="yes" xml:space="preserve">
          <source>And so, our final result, &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">그리고 우리의 최종 결과는 &lt;code&gt;6&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8576d009cd19a7310431c770ccd6d0477a9a38f5" translate="yes" xml:space="preserve">
          <source>And the expected output would look like the following, because both dimensions of &lt;code&gt;rect2&lt;/code&gt; are smaller than the dimensions of &lt;code&gt;rect1&lt;/code&gt; but &lt;code&gt;rect3&lt;/code&gt; is wider than &lt;code&gt;rect1&lt;/code&gt;:</source>
          <target state="translated">모두 크기 때문에 예상 출력은 다음과 같을 것이다 &lt;code&gt;rect2&lt;/code&gt; 이 의 크기보다 작은 &lt;code&gt;rect1&lt;/code&gt; 하지만 &lt;code&gt;rect3&lt;/code&gt; 는 보다 넓은 &lt;code&gt;rect1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="304a9abb7c8dbb46b1cac5f34e7d81eb70527d19" translate="yes" xml:space="preserve">
          <source>And the following is the same example, except using &lt;a href=&quot;generics#where-clauses&quot;&gt;where clauses&lt;/a&gt;.</source>
          <target state="translated">다음은 &lt;a href=&quot;generics#where-clauses&quot;&gt;where 절을&lt;/a&gt; 사용 하는 것을 제외하고는 동일한 예 입니다.</target>
        </trans-unit>
        <trans-unit id="913d407459e0226b150e7a70e74b4001bb096c87" translate="yes" xml:space="preserve">
          <source>And then usage on the derive macro on a struct:</source>
          <target state="translated">그런 다음 구조체의 파생 매크로에서 사용법 :</target>
        </trans-unit>
        <trans-unit id="16869e8d4badcf1212b889f654db64e52cba8e49" translate="yes" xml:space="preserve">
          <source>And then using said derive macro:</source>
          <target state="translated">그런 다음 상기 파생 매크로를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fde456d658fb04a2082b8789148df9b0dd8dabdb" translate="yes" xml:space="preserve">
          <source>And then we use it a binary crate to print &quot;42&quot; to standard output.</source>
          <target state="translated">그런 다음 이진 상자를 사용하여 &quot;42&quot;를 표준 출력으로 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="843c5d94071a4fae0f20d3e75ea70e29673c03d4" translate="yes" xml:space="preserve">
          <source>And we can call this function with either variant:</source>
          <target state="translated">그리고이 함수를 변형으로 호출 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="406aea8920a159db743c7e055df50170c501f68e" translate="yes" xml:space="preserve">
          <source>And we&amp;rsquo;re done&amp;mdash;all of Listing 17-11 now works! We&amp;rsquo;ve implemented the state pattern with the rules of the blog post workflow. The logic related to the rules lives in the state objects rather than being scattered throughout &lt;code&gt;Post&lt;/code&gt;.</source>
          <target state="translated">이제 끝났습니다. 이제 목록 17-11이 모두 작동합니다! 블로그 게시물 워크 플로의 규칙으로 상태 패턴을 구현했습니다. 규칙과 관련된 논리는 &lt;code&gt;Post&lt;/code&gt; 전체에 흩어져 있지 않고 상태 객체에 있습니다.</target>
        </trans-unit>
        <trans-unit id="d71a2256704824ddf84d5c0504e7d9d40555e056" translate="yes" xml:space="preserve">
          <source>And you make a hard link of the program:</source>
          <target state="translated">그리고 당신은 프로그램의 하드 링크를 만듭니다 :</target>
        </trans-unit>
        <trans-unit id="1a652f499d8171d97dc8db68df0dbf0a99d7c3f2" translate="yes" xml:space="preserve">
          <source>AndAnd</source>
          <target state="translated">AndAnd</target>
        </trans-unit>
        <trans-unit id="bcffbb2710fb4ff9f2236988e5b2ed04ecff3723" translate="yes" xml:space="preserve">
          <source>AndEq</source>
          <target state="translated">AndEq</target>
        </trans-unit>
        <trans-unit id="c4af9f801ba386b4d95b5962fd0aee793823a0c6" translate="yes" xml:space="preserve">
          <source>Anonymous type parameters</source>
          <target state="translated">익명 유형 매개 변수</target>
        </trans-unit>
        <trans-unit id="f739dc0ff02bf7ebdbbaf543c53bc8d5f32aa9b9" translate="yes" xml:space="preserve">
          <source>Another aspect commonly associated with OOP is the idea of &lt;em&gt;encapsulation&lt;/em&gt;, which means that the implementation details of an object aren&amp;rsquo;t accessible to code using that object. Therefore, the only way to interact with an object is through its public API; code using the object shouldn&amp;rsquo;t be able to reach into the object&amp;rsquo;s internals and change data or behavior directly. This enables the programmer to change and refactor an object&amp;rsquo;s internals without needing to change the code that uses the object.</source>
          <target state="translated">OOP와 일반적으로 관련된 또 다른 측면은 &lt;em&gt;encapsulation&lt;/em&gt; 이라는 아이디어인데 , 이는 객체의 구현 세부 사항이 해당 객체를 사용하여 코딩 할 수 없음을 의미합니다. 따라서 객체와 상호 작용하는 유일한 방법은 공개 API를 사용하는 것입니다. 객체를 사용하는 코드는 객체의 내부에 닿아 데이터 나 동작을 직접 변경할 수 없어야합니다. 이를 통해 프로그래머는 객체를 사용하는 코드를 변경할 필요없이 객체의 내부를 변경하고 리팩토링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3244c196f26eb3ebda5753ab0aa6df5308b053cc" translate="yes" xml:space="preserve">
          <source>Another case that causes this error is when a type is imported into a parent module. To fix this, you can follow the suggestion and use File directly or &lt;code&gt;use super::File;&lt;/code&gt; which will import the types from the parent namespace. An example that causes this error is below:</source>
          <target state="translated">이 오류를 발생시키는 다른 경우는 유형을 상위 모듈로 가져 오는 경우입니다. 이 문제를 해결하려면 제안을 따르고 File을 직접 &lt;code&gt;use super::File;&lt;/code&gt; 하거나 super :: File을 사용하십시오. 부모 네임 스페이스에서 형식을 가져옵니다. 이 오류를 일으키는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f5177285c1540f1a230a9212d6ad08c740059bb0" translate="yes" xml:space="preserve">
          <source>Another case where this error is emitted is when a value is expected, but something else is found:</source>
          <target state="translated">이 오류가 발생하는 또 다른 경우는 값이 예상되지만 다른 것이 발견 된 경우입니다.</target>
        </trans-unit>
        <trans-unit id="583bae5ce904e4cf097b6105871c304a4243a347" translate="yes" xml:space="preserve">
          <source>Another common use case for hash maps is to look up a key&amp;rsquo;s value and then update it based on the old value. For instance, Listing 8-26 shows code that counts how many times each word appears in some text. We use a hash map with the words as keys and increment the value to keep track of how many times we&amp;rsquo;ve seen that word. If it&amp;rsquo;s the first time we&amp;rsquo;ve seen a word, we&amp;rsquo;ll first insert the value 0.</source>
          <target state="translated">해시 맵의 또 다른 일반적인 사용 사례는 키 값을 찾은 다음 이전 값을 기반으로 업데이트하는 것입니다. 예를 들어, 목록 8-26은 각 단어가 일부 텍스트에 나타나는 횟수를 세는 코드를 보여줍니다. 단어와 함께 해시 맵을 키로 사용하고 값을 증가시켜 해당 단어를 본 횟수를 추적합니다. 단어를 처음 본 경우에는 먼저 값 0을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="dc4154c9de58b2e0fcab49a95a24b663a485fc7b" translate="yes" xml:space="preserve">
          <source>Another crate that depends on this library would need &lt;code&gt;use&lt;/code&gt; statements that bring the items from &lt;code&gt;art&lt;/code&gt; into scope, specifying the module structure that&amp;rsquo;s currently defined. Listing 14-4 shows an example of a crate that uses the &lt;code&gt;PrimaryColor&lt;/code&gt; and &lt;code&gt;mix&lt;/code&gt; items from the &lt;code&gt;art&lt;/code&gt; crate:</source>
          <target state="translated">이 라이브러리에 의존하는 또 다른 상자에는 현재 정의 된 모듈 구조를 지정하여 &lt;code&gt;art&lt;/code&gt; 의 항목 을 범위로 가져 오는 &lt;code&gt;use&lt;/code&gt; 문 이 필요 합니다 . 14-4 보여줍니다 사용하는 상자의 예를 나열 &lt;code&gt;PrimaryColor&lt;/code&gt; 을 하고 &lt;code&gt;mix&lt;/code&gt; 로부터 항목 &lt;code&gt;art&lt;/code&gt; 상자를 :</target>
        </trans-unit>
        <trans-unit id="36e9fb79f8131b77a6b5deaea1a5127794ef21b6" translate="yes" xml:space="preserve">
          <source>Another data type that does not have ownership is the &lt;em&gt;slice&lt;/em&gt;. Slices let you reference a contiguous sequence of elements in a collection rather than the whole collection.</source>
          <target state="translated">소유권이없는 다른 데이터 형식은 &lt;em&gt;슬라이스&lt;/em&gt; 입니다. 슬라이스를 사용하면 전체 컬렉션이 아닌 컬렉션에서 연속 된 요소 시퀀스를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2188fdee49af653aee0e28e4ac63dee8849194f0" translate="yes" xml:space="preserve">
          <source>Another detail to note is that Rust can&amp;rsquo;t protect you from all kinds of logic errors when you use &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;. Recall in Chapter 15 that using &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; came with the risk of creating reference cycles, where two &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; values refer to each other, causing memory leaks. Similarly, &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; comes with the risk of creating &lt;em&gt;deadlocks&lt;/em&gt;. These occur when an operation needs to lock two resources and two threads have each acquired one of the locks, causing them to wait for each other forever. If you&amp;rsquo;re interested in deadlocks, try creating a Rust program that has a deadlock; then research deadlock mitigation strategies for mutexes in any language and have a go at implementing them in Rust. The standard library API documentation for &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;MutexGuard&lt;/code&gt; offers useful information.</source>
          <target state="translated">주의해야 할 또 다른 세부 사항은 Rust가 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용할 때 모든 종류의 논리 오류로부터 보호 할 수 없다는 것입니다 . 15 장에서 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용 하면 두 개의 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 값이 서로를 참조하여 메모리 누수가 발생 하는 참조주기가 생성 될 위험이 있음을 상기 하십시오. 마찬가지로 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 는 &lt;em&gt;교착 상태&lt;/em&gt; 가 발생할 위험이 있습니다.&lt;em&gt;&lt;/em&gt;. 작업이 두 개의 리소스를 잠글 필요가 있고 두 개의 스레드가 각각 잠금 중 하나를 획득하여 서로를 영원히 기다릴 때 발생합니다. 교착 상태에 관심이있는 경우 교착 상태가있는 Rust 프로그램을 작성하십시오. 그런 다음 어떤 언어로든 뮤텍스에 대한 교착 상태 완화 전략을 연구하고 Rust에서 구현하십시오. &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 및 &lt;code&gt;MutexGuard&lt;/code&gt; 에 대한 표준 라이브러리 API 설명서 는 유용한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a89f510396bf7e7d6ce47105d5094f9ffdc43c0a" translate="yes" xml:space="preserve">
          <source>Another difference between constants and static variables is that static variables can be mutable. Accessing and modifying mutable static variables is &lt;em&gt;unsafe&lt;/em&gt;. Listing 19-10 shows how to declare, access, and modify a mutable static variable named &lt;code&gt;COUNTER&lt;/code&gt;.</source>
          <target state="translated">상수와 정적 변수의 또 다른 차이점은 정적 변수를 변경할 수 있다는 것입니다. 변경 가능한 정적 변수에 액세스하고 수정하는 것은 &lt;em&gt;안전하지 않습니다&lt;/em&gt; . Listing 19-10은 이름이 &lt;code&gt;COUNTER&lt;/code&gt; 인 가변 정적 변수를 선언, 액세스 및 수정하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="7e6b390982d432e5d51ecddfefa741ac598bed4a" translate="yes" xml:space="preserve">
          <source>Another downside is that we&amp;rsquo;ve duplicated some logic. To eliminate some of the duplication, we might try to make default implementations for the &lt;code&gt;request_review&lt;/code&gt; and &lt;code&gt;approve&lt;/code&gt; methods on the &lt;code&gt;State&lt;/code&gt; trait that return &lt;code&gt;self&lt;/code&gt;; however, this would violate object safety, because the trait doesn&amp;rsquo;t know what the concrete &lt;code&gt;self&lt;/code&gt; will be exactly. We want to be able to use &lt;code&gt;State&lt;/code&gt; as a trait object, so we need its methods to be object safe.</source>
          <target state="translated">또 다른 단점은 우리가 논리를 복제했다는 것입니다. 중복의 일부를 제거하기 위해, 우리는 디폴트 구현하기 위해 시도 할 수 있습니다 &lt;code&gt;request_review&lt;/code&gt; 을 하고 &lt;code&gt;approve&lt;/code&gt; 온 방법 &lt;code&gt;State&lt;/code&gt; 특성이 반환 &lt;code&gt;self&lt;/code&gt; ; 그러나 이것은 특성이 구체적인 &lt;code&gt;self&lt;/code&gt; 가 정확히 무엇인지 알지 못하기 때문에 물체 안전에 위배 됩니다. &lt;code&gt;State&lt;/code&gt; 를 특성 객체로 사용할 수 있기를 원 하므로 객체 안전을위한 메소드가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0b90ca84780d33c44fc3e74f14be69eb7fd048f1" translate="yes" xml:space="preserve">
          <source>Another erroneous code example:</source>
          <target state="translated">다른 잘못된 코드 예제 :</target>
        </trans-unit>
        <trans-unit id="b9c6fc1e93014c21a06c17d750322f830024d1b0" translate="yes" xml:space="preserve">
          <source>Another example of a complex NT is &lt;code&gt;$(hi $e:expr ;)+&lt;/code&gt;, which matches any fragment of the form &lt;code&gt;hi &amp;lt;expr&amp;gt;; hi &amp;lt;expr&amp;gt;; ...&lt;/code&gt; where &lt;code&gt;hi &amp;lt;expr&amp;gt;;&lt;/code&gt; occurs at least once. Note that this complex NT does not have a dedicated separator token.</source>
          <target state="translated">복잡한 NT의 다른 예는 &lt;code&gt;$(hi $e:expr ;)+&lt;/code&gt; 이며, 이는 &lt;code&gt;hi &amp;lt;expr&amp;gt;; hi &amp;lt;expr&amp;gt;; ...&lt;/code&gt; 형식의 모든 조각과 일치합니다 . 안녕 &amp;lt;expr&amp;gt;; ... 여기서 &lt;code&gt;hi &amp;lt;expr&amp;gt;;&lt;/code&gt; 적어도 한 번 발생합니다. 이 복잡한 NT에는 전용 구분 기호 토큰이 없습니다.</target>
        </trans-unit>
        <trans-unit id="93c5ab10f51e34387707bf7df6173ca28d162973" translate="yes" xml:space="preserve">
          <source>Another example of a non-&lt;code&gt;Sync&lt;/code&gt; type is the reference-counting pointer &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;rc::Rc&lt;/code&gt;&lt;/a&gt;. Given any reference &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;&amp;amp;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, you can clone a new &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, modifying the reference counts in a non-atomic way.</source>
          <target state="translated">&lt;code&gt;Sync&lt;/code&gt; 이외의 타입 의 다른 예는 참조 카운트 포인터 &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;rc::Rc&lt;/code&gt; &lt;/a&gt; 입니다. &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;&amp;amp;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 참조가 주어지면 , 새로운 &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 복제 하여 비원 자적 방식으로 참조 카운트를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="5d9b32be0b7923daf9aadae8867f04bd738917c6" translate="yes" xml:space="preserve">
          <source>Another example showing how to keep &lt;code&gt;Cow&lt;/code&gt; in a struct:</source>
          <target state="translated">구조체에 &lt;code&gt;Cow&lt;/code&gt; 를 유지하는 방법을 보여주는 또 다른 예 :</target>
        </trans-unit>
        <trans-unit id="73dbef5057ac390e03a6e177bceb38dfa0e2cca7" translate="yes" xml:space="preserve">
          <source>Another implication of the 4-byte fixed size of a &lt;code&gt;char&lt;/code&gt; is that per-&lt;code&gt;char&lt;/code&gt; processing can end up using a lot more memory:</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 의 4 바이트 고정 크기의 또 다른 의미는 per- &lt;code&gt;char&lt;/code&gt; 처리가 더 많은 메모리를 사용하여 종료 될 수 있다는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="8ab43d76c6773436cfee7acbc8b6406943d7ca07" translate="yes" xml:space="preserve">
          <source>Another important difference between macros and functions is that you must define macros or bring them into scope &lt;em&gt;before&lt;/em&gt; you call them in a file, as opposed to functions you can define anywhere and call anywhere.</source>
          <target state="translated">매크로와 함수의 또 다른 중요한 차이점은 파일을 호출 &lt;em&gt;하기 전에&lt;/em&gt; 매크로를 정의하거나 범위 내로 가져와야한다는 것입니다. 함수는 어디에서나 정의하고 어디에서나 호출 할 수있는 기능 과는 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="6f8bbe73702fb41924bac262bfb8595f3c660f2c" translate="yes" xml:space="preserve">
          <source>Another indicator that shows there&amp;rsquo;s room for improvement is the &lt;code&gt;config&lt;/code&gt; part of &lt;code&gt;parse_config&lt;/code&gt;, which implies that the two values we return are related and are both part of one configuration value. We&amp;rsquo;re not currently conveying this meaning in the structure of the data other than by grouping the two values into a tuple; we could put the two values into one struct and give each of the struct fields a meaningful name. Doing so will make it easier for future maintainers of this code to understand how the different values relate to each other and what their purpose is.</source>
          <target state="translated">개선의 여지가 있음을 보여주는 또 다른 지표 는 &lt;code&gt;parse_config&lt;/code&gt; 의 &lt;code&gt;config&lt;/code&gt; 부분입니다 . 이는 반환하는 두 값이 관련되어 있고 둘 다 하나의 구성 값의 일부임을 의미합니다. 우리는 현재 두 가지 값을 튜플로 그룹화하는 것 이외의 데이터 구조에서이 의미를 전달하지 않습니다. 두 값을 하나의 구조체에 넣고 각 구조체 필드에 의미있는 이름을 지정할 수 있습니다. 그렇게하면이 코드의 미래 관리자가 서로 다른 값이 서로 어떻게 관련되어 있고 그 목적이 무엇인지 더 쉽게 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00e0685682ab1fea96a488f384eaf2fdca89f82c" translate="yes" xml:space="preserve">
          <source>Another kind of generic that we&amp;rsquo;ve already been using is called &lt;em&gt;lifetimes&lt;/em&gt;. Rather than ensuring that a type has the behavior we want, lifetimes ensure that references are valid as long as we need them to be. Let&amp;rsquo;s look at how lifetimes do that.</source>
          <target state="translated">우리가 이미 사용하고있는 또 다른 종류의 제네릭을 &lt;em&gt;lifetimes&lt;/em&gt; 라고 합니다. 수명은 유형에 원하는 동작이 있는지 확인하는 것이 아니라 필요한만큼 참조가 유효한지 확인합니다. 평생 어떻게 그렇게하는지 보자.</target>
        </trans-unit>
        <trans-unit id="310cbb5c9fbbbdff4450ff99ffebe8e97470ef1e" translate="yes" xml:space="preserve">
          <source>Another method, &lt;code&gt;expect&lt;/code&gt;, which is similar to &lt;code&gt;unwrap&lt;/code&gt;, lets us also choose the &lt;code&gt;panic!&lt;/code&gt; error message. Using &lt;code&gt;expect&lt;/code&gt; instead of &lt;code&gt;unwrap&lt;/code&gt; and providing good error messages can convey your intent and make tracking down the source of a panic easier. The syntax of &lt;code&gt;expect&lt;/code&gt; looks like this:</source>
          <target state="translated">&lt;code&gt;unwrap&lt;/code&gt; 과 비슷한 또 다른 방법 인 &lt;code&gt;expect&lt;/code&gt; 는 &lt;code&gt;panic!&lt;/code&gt; 선택할 수있게합니다 ! 에러 메시지. &lt;code&gt;unwrap&lt;/code&gt; 대신 &lt;code&gt;expect&lt;/code&gt; 를 사용 하고 좋은 오류 메시지를 제공 하면 의도를 전달하고 공황의 원인을 쉽게 추적 할 수 있습니다. &lt;code&gt;expect&lt;/code&gt; 의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f5499cba2c47a56c76648e5bfb00e8274cd4700a" translate="yes" xml:space="preserve">
          <source>Another point about UTF-8 is that there are actually three relevant ways to look at strings from Rust&amp;rsquo;s perspective: as bytes, scalar values, and grapheme clusters (the closest thing to what we would call &lt;em&gt;letters&lt;/em&gt;).</source>
          <target state="translated">UTF-8에 대한 또 다른 요점은 Rust의 관점에서 문자열을 보는 세 가지 관련 방법, 즉 바이트, 스칼라 값 및 grapheme 클러스터 ( &lt;em&gt;문자&lt;/em&gt; 라고 부르는 것에 가장 가까운 것)가 있다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="81bb35319cfe55cae7a1b6f8b640c268f984543f" translate="yes" xml:space="preserve">
          <source>Another problem you might be facing is this: suppose you've overloaded the &lt;code&gt;+&lt;/code&gt; operator for some type &lt;code&gt;Foo&lt;/code&gt; by implementing the &lt;code&gt;std::ops::Add&lt;/code&gt; trait for &lt;code&gt;Foo&lt;/code&gt;, but you find that using &lt;code&gt;+=&lt;/code&gt; does not work, as in this example:</source>
          <target state="translated">또 다른 문제는 다음과 같습니다. &lt;code&gt;std::ops::Add&lt;/code&gt; trait for &lt;code&gt;Foo&lt;/code&gt; 구현하여 &lt;code&gt;Foo&lt;/code&gt; 유형에 대해 &lt;code&gt;+&lt;/code&gt; 연산자를 오버로드했다고 가정 하지만 이 예제에서와 같이 &lt;code&gt;+=&lt;/code&gt; 를 사용하면 작동하지 않습니다. :</target>
        </trans-unit>
        <trans-unit id="aac5c18dffed07c8f0aa7695dfba8d6c18e4b19b" translate="yes" xml:space="preserve">
          <source>Another reason Rust has an unsafe alter ego is that the underlying computer hardware is inherently unsafe. If Rust didn&amp;rsquo;t let you do unsafe operations, you couldn&amp;rsquo;t do certain tasks. Rust needs to allow you to do low-level systems programming, such as directly interacting with the operating system or even writing your own operating system. Working with low-level systems programming is one of the goals of the language. Let&amp;rsquo;s explore what we can do with unsafe Rust and how to do it.</source>
          <target state="translated">Rust가 안전하지 않은 대체 자아를 갖는 또 다른 이유는 기본 컴퓨터 하드웨어가 본질적으로 안전하지 않기 때문입니다. Rust가 안전하지 않은 작업을 수행하지 못하게 한 경우 특정 작업을 수행 할 수 없습니다. Rust는 운영 체제와 직접 상호 작용하거나 자체 운영 체제 작성과 같은 저수준 시스템 프로그래밍을 수행 할 수 있어야합니다. 저수준 시스템 프로그래밍 작업은 언어의 목표 중 하나입니다. 안전하지 않은 Rust로 수행 할 수있는 작업과 수행 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="ea0e4d862c74d436d68a36a2f5a91a9f7ba71ea8" translate="yes" xml:space="preserve">
          <source>Another shortcut for struct instantiation is available, used when you need to make a new struct that has the same values as most of a previous struct of the same type, called struct update syntax:</source>
          <target state="translated">구조체 인스턴스화에 대한 또 다른 단축키를 사용할 수 있습니다. 구조체 업데이트 구문이라는 동일한 유형의 이전 구조체 대부분과 동일한 값을 가진 새 구조체를 만들어야 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f3ef4925d92f67dd0f9c6ef4b106d217ff19945f" translate="yes" xml:space="preserve">
          <source>Another situation where this might be encountered is when spawning threads:</source>
          <target state="translated">스레드가 발생할 때 또 다른 상황이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34208ffcc5dda542066ff03ecbdd472bf7d5f1c2" translate="yes" xml:space="preserve">
          <source>Another solution for avoiding reference cycles is reorganizing your data structures so that some references express ownership and some references don&amp;rsquo;t. As a result, you can have cycles made up of some ownership relationships and some non-ownership relationships, and only the ownership relationships affect whether or not a value can be dropped. In Listing 15-25, we always want &lt;code&gt;Cons&lt;/code&gt; variants to own their list, so reorganizing the data structure isn&amp;rsquo;t possible. Let&amp;rsquo;s look at an example using graphs made up of parent nodes and child nodes to see when non-ownership relationships are an appropriate way to prevent reference cycles.</source>
          <target state="translated">참조주기를 피하는 또 다른 솔루션은 데이터 구조를 재구성하여 일부 참조가 소유권을 나타내고 일부 참조가 그렇지 않도록하는 것입니다. 결과적으로 일부 소유권 관계와 일부 비 소유 관계로 구성된주기를 가질 수 있으며 소유권 관계 만 값을 삭제할 수 있는지 여부에 영향을줍니다. Listing 15-25에서 우리는 항상 &lt;code&gt;Cons&lt;/code&gt; 변형이 자신의 목록을 소유하기를 원하므로 데이터 구조를 재구성 할 수 없다. 비 소유 관계가 참조주기를 방지하는 적절한 방법인지 확인하기 위해 부모 노드와 자식 노드로 구성된 그래프를 사용하는 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="561d97b6164c78f724fabd7e84d16f2ca6a5f05e" translate="yes" xml:space="preserve">
          <source>Another style of doc comment, &lt;code&gt;//!&lt;/code&gt;, adds documentation to the item that contains the comments rather than adding documentation to the items following the comments. We typically use these doc comments inside the crate root file (&lt;em&gt;src/lib.rs&lt;/em&gt; by convention) or inside a module to document the crate or the module as a whole.</source>
          <target state="translated">&lt;code&gt;//!&lt;/code&gt; 또 다른 스타일의 doc comment, //! , 주석 다음에 항목에 문서를 추가하지 않고 주석이 포함 된 항목에 문서를 추가합니다. 우리는 일반적으로 크레이트 루트 파일 ( 컨벤션에 따라 &lt;em&gt;src / lib.rs&lt;/em&gt; ) 또는 크레이트 또는 모듈 전체를 문서화하기 위해 모듈 내에서 이러한 문서 주석을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="bfe5186a552091b0c590be070139e735a13d8759" translate="yes" xml:space="preserve">
          <source>Another use of the newtype pattern is in abstracting away some implementation details of a type: the new type can expose a public API that is different from the API of the private inner type if we used the new type directly to restrict the available functionality, for example.</source>
          <target state="translated">newtype 패턴의 또 다른 사용은 유형의 구현 세부 사항을 추상화하는 것입니다. 새로운 유형을 사용하여 사용 가능한 기능을 직접 제한하는 경우 새 유형은 개인 내부 유형의 API와 다른 공용 API를 노출시킬 수 있습니다. 예.</target>
        </trans-unit>
        <trans-unit id="5796386c80b53dfd4fee86ac2eb96a8dcc028b10" translate="yes" xml:space="preserve">
          <source>Another useful feature of &lt;code&gt;impl&lt;/code&gt; blocks is that we&amp;rsquo;re allowed to define functions within &lt;code&gt;impl&lt;/code&gt; blocks that &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; take &lt;code&gt;self&lt;/code&gt; as a parameter. These are called &lt;em&gt;associated functions&lt;/em&gt; because they&amp;rsquo;re associated with the struct. They&amp;rsquo;re still functions, not methods, because they don&amp;rsquo;t have an instance of the struct to work with. You&amp;rsquo;ve already used the &lt;code&gt;String::from&lt;/code&gt; associated function.</source>
          <target state="translated">또 다른 유용한 기능 &lt;code&gt;impl&lt;/code&gt; 블록은 우리가 내 함수를 정의 할 수있는 것입니다 &lt;code&gt;impl&lt;/code&gt; 블록 &lt;em&gt;하지 않는&lt;/em&gt; 걸릴 &lt;code&gt;self&lt;/code&gt; 매개 변수로. 그것들은 구조체와 관련되어 있기 때문에 &lt;em&gt;관련 함수&lt;/em&gt; 라고 합니다. 그것들은 작업 할 구조체의 인스턴스가 없기 때문에 메소드가 아닌 함수입니다. 이미 연결된 함수 &lt;code&gt;String::from&lt;/code&gt; 사용했습니다 .</target>
        </trans-unit>
        <trans-unit id="30235cc37ef7579d4a5373609eca2f1e91e01f9f" translate="yes" xml:space="preserve">
          <source>Another useful feature of match arms is that they can bind to the parts of the values that match the pattern. This is how we can extract values out of enum variants.</source>
          <target state="translated">일치 암의 또 다른 유용한 기능은 패턴과 일치하는 값의 일부에 바인딩 할 수 있다는 것입니다. 이것이 열거 형 변형에서 값을 추출하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="03644769062de97f25c38104b0372355c4a77983" translate="yes" xml:space="preserve">
          <source>Another way is to do away with the associated type in &lt;code&gt;Maker&lt;/code&gt; and use an input type parameter instead:</source>
          <target state="translated">또 다른 방법은 &lt;code&gt;Maker&lt;/code&gt; 에서 관련 유형을 제거 하고 대신 입력 유형 매개 변수를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ccc69aa411fffd31870708506663671f3a6766b5" translate="yes" xml:space="preserve">
          <source>Another way of constructing a hash map is by using the &lt;code&gt;collect&lt;/code&gt; method on a vector of tuples, where each tuple consists of a key and its value. The &lt;code&gt;collect&lt;/code&gt; method gathers data into a number of collection types, including &lt;code&gt;HashMap&lt;/code&gt;. For example, if we had the team names and initial scores in two separate vectors, we could use the &lt;code&gt;zip&lt;/code&gt; method to create a vector of tuples where &amp;ldquo;Blue&amp;rdquo; is paired with 10, and so forth. Then we could use the &lt;code&gt;collect&lt;/code&gt; method to turn that vector of tuples into a hash map, as shown in Listing 8-21.</source>
          <target state="translated">해시 맵을 구성하는 또 다른 방법은 튜플의 벡터 에서 &lt;code&gt;collect&lt;/code&gt; 메소드를 사용하는 것입니다 . 각 튜플은 키와 해당 값으로 구성됩니다. &lt;code&gt;collect&lt;/code&gt; 방법을 포함 컬렉션 종류의 번호로 데이터 수집 &lt;code&gt;HashMap&lt;/code&gt; . 예를 들어 두 개의 별도 벡터에 팀 이름과 초기 점수가있는 경우 &lt;code&gt;zip&lt;/code&gt; 방법을 사용하여 &quot;Blue&quot;가 10과 쌍을 이루는 튜플의 벡터를 만들 수 있습니다 . 그런 다음 &lt;code&gt;collect&lt;/code&gt; 메소드를 사용하여 튜플의 벡터를 해시 맵으로 변환 할 수 있습니다 ( 목록 8-21 참조).</target>
        </trans-unit>
        <trans-unit id="56bc825abe2ef1255ee87da2e4f261c23258e491" translate="yes" xml:space="preserve">
          <source>Another way of thinking about &lt;code&gt;flat_map()&lt;/code&gt;: &lt;a href=&quot;#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;'s closure returns one item for each element, and &lt;code&gt;flat_map()&lt;/code&gt;'s closure returns an iterator for each element.</source>
          <target state="translated">&lt;code&gt;flat_map()&lt;/code&gt; 에 대한 다른 생각 방법 : &lt;a href=&quot;#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; 의 클로저는 각 요소에 대해 하나의 항목을 반환하고 &lt;code&gt;flat_map()&lt;/code&gt; 의 클로저는 각 요소에 대한 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="590fe2daae703b4f29d9d514cb7fe9863489ba23" translate="yes" xml:space="preserve">
          <source>Another way to access union fields is to use pattern matching. Pattern matching on union fields uses the same syntax as struct patterns, except that the pattern must specify exactly one field. Since pattern matching is like reading the union with a particular field, it has to be placed in &lt;code&gt;unsafe&lt;/code&gt; blocks as well.</source>
          <target state="translated">통합 필드에 액세스하는 다른 방법은 패턴 일치를 사용하는 것입니다. 공용체 필드의 패턴 일치는 패턴이 정확히 하나의 필드를 지정해야한다는 점을 제외하고 구조체 패턴과 동일한 구문을 사용합니다. 패턴 일치는 특정 필드와의 결합을 읽는 것과 같으므로 &lt;code&gt;unsafe&lt;/code&gt; 블록 에도 배치 해야합니다.</target>
        </trans-unit>
        <trans-unit id="1b9e5f7972ceab35649387701cac506db165c92f" translate="yes" xml:space="preserve">
          <source>Another way to have a collection of multiple values is with an &lt;em&gt;array&lt;/em&gt;. Unlike a tuple, every element of an array must have the same type. Arrays in Rust are different from arrays in some other languages because arrays in Rust have a fixed length, like tuples.</source>
          <target state="translated">여러 값을 수집하는 또 다른 방법은 &lt;em&gt;배열을&lt;/em&gt; 사용하는 것 입니다. 튜플과 달리 배열의 모든 요소는 동일한 유형을 가져야합니다. Rust의 배열은 튜플과 같이 고정 길이를 가지기 때문에 Rust의 배열은 다른 언어의 배열과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6b16dbbf7d35ba29c07c44408e5ca0fc777803bb" translate="yes" xml:space="preserve">
          <source>Another way to provide the compiler with enough information, is to specify the generic type parameter:</source>
          <target state="translated">컴파일러에 충분한 정보를 제공하는 또 다른 방법은 일반 유형 매개 변수를 지정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9b14c4635b7e156ee560ca02ddafb5c338efe01a" translate="yes" xml:space="preserve">
          <source>Another way we could implement &lt;code&gt;largest&lt;/code&gt; is for the function to return a reference to a &lt;code&gt;T&lt;/code&gt; value in the slice. If we change the return type to &lt;code&gt;&amp;amp;T&lt;/code&gt; instead of &lt;code&gt;T&lt;/code&gt;, thereby changing the body of the function to return a reference, we wouldn&amp;rsquo;t need the &lt;code&gt;Clone&lt;/code&gt; or &lt;code&gt;Copy&lt;/code&gt; trait bounds and we could avoid heap allocations. Try implementing these alternate solutions on your own!</source>
          <target state="translated">우리가 &lt;code&gt;largest&lt;/code&gt; 구현할 수있는 또 다른 방법 은 함수가 슬라이스 의 &lt;code&gt;T&lt;/code&gt; 값에 대한 참조를 반환하는 것 입니다. 우리가 반환 형식을 변경하는 경우 &lt;code&gt;&amp;amp;T&lt;/code&gt; 대신 &lt;code&gt;T&lt;/code&gt; 하여 참조를 반환하는 함수의 본문을 변경, 우리는 필요하지 않을 &lt;code&gt;Clone&lt;/code&gt; 또는 &lt;code&gt;Copy&lt;/code&gt; 범위를 특징 부 (trait)과 우리가 힙 할당을 피할 수 있습니다. 이 대체 솔루션을 직접 구현해보십시오!</target>
        </trans-unit>
        <trans-unit id="322444d3bb52c341f429ca0454f292dc242f315b" translate="yes" xml:space="preserve">
          <source>Any</source>
          <target state="translated">Any</target>
        </trans-unit>
        <trans-unit id="28a9dd9802c2f2d457b2df1a706228a0fe1e9650" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;BuildHasherDefault&lt;/code&gt; is &lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;zero-sized&lt;/a&gt;. It can be created with &lt;a href=&quot;#method.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;. When using &lt;code&gt;BuildHasherDefault&lt;/code&gt; with &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../collections/struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt;, this doesn't need to be done, since they implement appropriate &lt;a href=&quot;../default/trait.default&quot;&gt;&lt;code&gt;Default&lt;/code&gt;&lt;/a&gt; instances themselves.</source>
          <target state="translated">모든 &lt;code&gt;BuildHasherDefault&lt;/code&gt; 는 &lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;크기&lt;/a&gt; 가 0 입니다. &lt;a href=&quot;#method.default&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; 로 만들 수 있습니다 . &lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../collections/struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; &lt;/a&gt; 과 함께 &lt;code&gt;BuildHasherDefault&lt;/code&gt; 를 사용 하는 경우 적절한 &lt;a href=&quot;../default/trait.default&quot;&gt; &lt;code&gt;Default&lt;/code&gt; &lt;/a&gt; 인스턴스 자체를 구현하므로이를 수행 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="61c0cc711bc6806236220ae14adf5485763a3373" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;enum&lt;/code&gt; value consumes as much memory as the largest variant for its corresponding &lt;code&gt;enum&lt;/code&gt; type, as well as the size needed to store a discriminant.</source>
          <target state="translated">모든 &lt;code&gt;enum&lt;/code&gt; 값은 해당 &lt;code&gt;enum&lt;/code&gt; 형에 대한 가장 큰 변형 뿐만 아니라 판별자를 저장하는 데 필요한 크기 만큼 많은 메모리를 소비 합니다.</target>
        </trans-unit>
        <trans-unit id="6ab54097a9523b84f57f773009ba255a131e3917" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;with_capacity&lt;/code&gt; constructor will instruct the collection to allocate enough space for the specified number of elements. Ideally this will be for exactly that many elements, but some implementation details may prevent this. See collection-specific documentation for details. In general, use &lt;code&gt;with_capacity&lt;/code&gt; when you know exactly how many elements will be inserted, or at least have a reasonable upper-bound on that number.</source>
          <target state="translated">모든 &lt;code&gt;with_capacity&lt;/code&gt; 의 생성자는 지정된 수의 요소에 대한 충분한 공간을 할당 컬렉션을 지시합니다. 이상적으로 이것은 많은 요소에 대한 것이지만 일부 구현 세부 사항은 이것을 막을 수 있습니다. 자세한 내용은 컬렉션 별 설명서를 참조하십시오. 일반적으로 삽입 할 요소 수를 정확히 알거나 최소한 그 수에 대한 상한선이있는 경우 &lt;code&gt;with_capacity&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b673eb46a7f5984769da2ecfe123198574739d4" translate="yes" xml:space="preserve">
          <source>Any I/O error not part of this list.</source>
          <target state="translated">이 목록에 포함되지 않은 모든 I / O 오류.</target>
        </trans-unit>
        <trans-unit id="6867ac894a456ea99c7c6870f309c422acaaf4df" translate="yes" xml:space="preserve">
          <source>Any IP address can be either a version four or a version six address, but not both at the same time. That property of IP addresses makes the enum data structure appropriate, because enum values can only be one of the variants. Both version four and version six addresses are still fundamentally IP addresses, so they should be treated as the same type when the code is handling situations that apply to any kind of IP address.</source>
          <target state="translated">모든 IP 주소는 버전 4 또는 버전 6 주소 일 수 있지만 동시에 둘 다일 수는 없습니다. 열거 형 값은 변형 중 하나 일 수 있으므로 IP 주소의 속성으로 인해 열거 형 데이터 구조가 적합합니다. 버전 4와 버전 6 주소는 여전히 기본적으로 IP 주소이므로 코드가 모든 종류의 IP 주소에 적용되는 상황을 처리 할 때 동일한 유형으로 취급해야합니다.</target>
        </trans-unit>
        <trans-unit id="771cc11d8125e00769bce8eb3a9472fcb3c21cb2" translate="yes" xml:space="preserve">
          <source>Any character in the 'printable ASCII' range &lt;code&gt;0x20&lt;/code&gt; .. &lt;code&gt;0x7e&lt;/code&gt; inclusive is not escaped.</source>
          <target state="translated">'인쇄 가능한 ASCII'범위 &lt;code&gt;0x20&lt;/code&gt; .. &lt;code&gt;0x7e&lt;/code&gt; 의 모든 문자는 이스케이프되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3e6eb82cfd1ccce10703d68820085fb1a0e36401" translate="yes" xml:space="preserve">
          <source>Any characters, except this sequence</source>
          <target state="translated">이 순서를 제외한 모든 문자</target>
        </trans-unit>
        <trans-unit id="4cd23fb2001ef303a1bdb9cc4bb51ec0898b0bb8" translate="yes" xml:space="preserve">
          <source>Any characters, except those listed</source>
          <target state="translated">나열된 문자를 제외한 모든 문자</target>
        </trans-unit>
        <trans-unit id="de99d379f5705cbf09c5d5e30200a62d7427ee91" translate="yes" xml:space="preserve">
          <source>Any excess capacity is removed:</source>
          <target state="translated">초과 용량이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="4eba9dcc5c9c9c3a4fc6d9f7d5233af8a7847a24" translate="yes" xml:space="preserve">
          <source>Any kind of aggregate constructor (array, &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, tuple, ...)</source>
          <target state="translated">모든 종류의 집계 생성자 (배열, &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;enum&lt;/code&gt; , 튜플, ...)</target>
        </trans-unit>
        <trans-unit id="a2d418110b6f755d1311536fe4acdfee5af1facd" translate="yes" xml:space="preserve">
          <source>Any kind of literal (string, integer, etc) with any suffix is valid as a token, and can be passed to a macro without producing an error.</source>
          <target state="translated">접미사가있는 모든 종류의 리터럴 (문자열, 정수 등)은 토큰으로 유효하며 오류없이 매크로에 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cbac428240bad16fb03767cc5cca3e5e71622e2" translate="yes" xml:space="preserve">
          <source>Any non-Unicode sequences are replaced with &lt;a href=&quot;../char/constant.replacement_character&quot;&gt;&lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비 유니 코드 시퀀스는 &lt;a href=&quot;../char/constant.replacement_character&quot;&gt; &lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt; &lt;/a&gt; 로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="3df46fe98310c858bb458ed2bc6017d791596b12" translate="yes" xml:space="preserve">
          <source>Any of the characters in the range</source>
          <target state="translated">범위 내의 모든 문자</target>
        </trans-unit>
        <trans-unit id="df4bb3c1fbc6102d5b31f44ab7298372090f0684" translate="yes" xml:space="preserve">
          <source>Any of the characters listed</source>
          <target state="translated">나열된 모든 문자</target>
        </trans-unit>
        <trans-unit id="e1fe17e124adf671f41a6bcdb30bc09a9767a019" translate="yes" xml:space="preserve">
          <source>Any of the methods provided by a &lt;a href=&quot;../visibility-and-privacy&quot;&gt;visible&lt;/a&gt; trait implemented by &lt;code&gt;T&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is a type parameter, methods provided by trait bounds on &lt;code&gt;T&lt;/code&gt; are looked up first. Then all remaining methods in scope are looked up.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 구현 한 &lt;a href=&quot;../visibility-and-privacy&quot;&gt;가시적&lt;/a&gt; 특성에 의해 제공되는 모든 방법 . 경우 &lt;code&gt;T&lt;/code&gt; 는 타입 파라미터에 형질 경계에서 제공 방법 &lt;code&gt;T&lt;/code&gt; 는 먼저 조회한다. 그런 다음 범위의 나머지 모든 메소드가 조회됩니다.</target>
        </trans-unit>
        <trans-unit id="e19f15fb75a4bf5f47bda7e931808400dd6bf097" translate="yes" xml:space="preserve">
          <source>Any other changes attempted on a post should have no effect. For example, if we try to approve a draft blog post before we&amp;rsquo;ve requested a review, the post should remain an unpublished draft.</source>
          <target state="translated">게시물에서 시도한 다른 변경 사항은 적용되지 않습니다. 예를 들어, 검토를 요청하기 전에 초안 블로그 게시물을 승인하려고하면 게시물이 게시되지 않은 초안으로 남아 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d6894150447e47d12e66ba741e1dc8f000de5b10" translate="yes" xml:space="preserve">
          <source>Any other chars are given hex escapes of the form '\xNN'.</source>
          <target state="translated">다른 문자에는 '\ xNN'형식의 16 진수 이스케이프가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c7e7ce7ad0344363614031d689f8048423505a67" translate="yes" xml:space="preserve">
          <source>Any resources the value manages, such as heap memory or a file handle, will linger forever in an unreachable state. However, it does not guarantee that pointers to this memory will remain valid.</source>
          <target state="translated">힙 메모리 또는 파일 핸들과 같이 값이 관리하는 모든 리소스는 도달 할 수없는 상태로 영원히 유지됩니다. 그러나이 메모리에 대한 포인터가 계속 유효하다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="4582f1278b61140a4c03b6946eaab9c9e43377c3" translate="yes" xml:space="preserve">
          <source>Any suffixes are rejected on non-numeric literal tokens, and numeric literal tokens are accepted only with suffixes from the list below.</source>
          <target state="translated">숫자가 아닌 리터럴 토큰에서는 접미사가 거부되고 숫자 리터럴 토큰은 아래 목록의 접미사 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="972a6afc1089fd19efd410e0369cd9e91a4ef0f3" translate="yes" xml:space="preserve">
          <source>Any time a type or function is provided by the standard library and you&amp;rsquo;re not sure what it does or how to use it, use the application programming interface (API) documentation to find out!</source>
          <target state="translated">표준 라이브러리에서 유형 또는 함수를 제공 할 때마다 그 기능 또는 사용법을 잘 모를 경우 API (Application Programming Interface) 문서를 사용하여 찾으십시오!</target>
        </trans-unit>
        <trans-unit id="76deb7250dd43b06f05ef65522ed5c978849b0e5" translate="yes" xml:space="preserve">
          <source>Any type composed entirely of &lt;code&gt;Send&lt;/code&gt; types is automatically marked as &lt;code&gt;Send&lt;/code&gt; as well. Almost all primitive types are &lt;code&gt;Send&lt;/code&gt;, aside from raw pointers, which we&amp;rsquo;ll discuss in Chapter 19.</source>
          <target state="translated">&lt;code&gt;Send&lt;/code&gt; 유형 으로 만 구성된 모든 유형은 자동으로 &lt;code&gt;Send&lt;/code&gt; 로 표시됩니다 . 거의 모든 프리미티브 유형은 원시 포인터를 제외하고 &lt;code&gt;Send&lt;/code&gt; 이며 19 장에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="af69a2cb47235b6ee090b2e8285120ce18b240b2" translate="yes" xml:space="preserve">
          <source>Any type parameter or lifetime parameter of an &lt;code&gt;impl&lt;/code&gt; must meet at least one of the following criteria:</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; 의 모든 유형 매개 변수 또는 수명 매개 변수 는 다음 기준 중 하나 이상을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="07027ef0df88ca520ae158040613bfcdb04fbd90" translate="yes" xml:space="preserve">
          <source>Any types with interior mutability must also use the &lt;a href=&quot;../cell/struct.unsafecell&quot;&gt;&lt;code&gt;cell::UnsafeCell&lt;/code&gt;&lt;/a&gt; wrapper around the value(s) which can be mutated through a shared reference. Failing to doing this is &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt;. For example, &lt;a href=&quot;../mem/fn.transmute&quot;&gt;&lt;code&gt;transmute&lt;/code&gt;&lt;/a&gt;-ing from &lt;code&gt;&amp;amp;T&lt;/code&gt; to &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is invalid.</source>
          <target state="translated">내부 변경이 가능한 모든 유형 은 공유 참조를 통해 변경 될 수있는 값 주위의 &lt;a href=&quot;../cell/struct.unsafecell&quot;&gt; &lt;code&gt;cell::UnsafeCell&lt;/code&gt; &lt;/a&gt; 래퍼 도 사용해야합니다 . 이 작업에 실패하면 &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;정의되지 않은 동작&lt;/a&gt; 입니다. 예를 들어, &lt;a href=&quot;../mem/fn.transmute&quot;&gt; &lt;code&gt;transmute&lt;/code&gt; &lt;/a&gt; 에서 -ing &lt;code&gt;&amp;amp;T&lt;/code&gt; 에 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4098bab2016a26a2da921c6a4c090c6509eb5934" translate="yes" xml:space="preserve">
          <source>Any use other than with &lt;code&gt;if&lt;/code&gt; statements will probably not have an effect.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 문 이외의 다른 용도로 는 효과가 없을 것입니다.</target>
        </trans-unit>
        <trans-unit id="910dd93279c47bcced2d261d2b21071bc5cf465a" translate="yes" xml:space="preserve">
          <source>Any::downcast_mut</source>
          <target state="translated">Any::downcast_mut</target>
        </trans-unit>
        <trans-unit id="3142933cd2ff31b31d3f631fe20ea508e96ad05b" translate="yes" xml:space="preserve">
          <source>Any::downcast_ref</source>
          <target state="translated">Any::downcast_ref</target>
        </trans-unit>
        <trans-unit id="47853f41e226da1c34d9eedcdb8b975ed79ec7bc" translate="yes" xml:space="preserve">
          <source>Any::fmt</source>
          <target state="translated">Any::fmt</target>
        </trans-unit>
        <trans-unit id="63f0fc770b243d87075e5d22567fc12df96b560f" translate="yes" xml:space="preserve">
          <source>Any::is</source>
          <target state="translated">Any::is</target>
        </trans-unit>
        <trans-unit id="153b1345e60af7ce7872d3438b64b0f7f8addb2c" translate="yes" xml:space="preserve">
          <source>Any::type_id</source>
          <target state="translated">Any::type_id</target>
        </trans-unit>
        <trans-unit id="4cde3fadbf976f0b359d3c2a1968c555ccde759f" translate="yes" xml:space="preserve">
          <source>Anyone can write RFCs to improve Rust, and the proposals are reviewed and discussed by the Rust team, which is comprised of many topic subteams. There&amp;rsquo;s a full list of the teams &lt;a href=&quot;https://www.rust-lang.org/governance&quot;&gt;on Rust&amp;rsquo;s website&lt;/a&gt;, which includes teams for each area of the project: language design, compiler implementation, infrastructure, documentation, and more. The appropriate team reads the proposal and the comments, writes some comments of their own, and eventually, there&amp;rsquo;s consensus to accept or reject the feature.</source>
          <target state="translated">누구나 Rust를 개선하기 위해 RFC를 작성할 수 있으며, 제안은 여러 주제 서브 팀으로 구성된 Rust 팀에 의해 검토되고 논의됩니다. &lt;a href=&quot;https://www.rust-lang.org/governance&quot;&gt;Rust의 웹 사이트&lt;/a&gt; 에는 언어 디자인, 컴파일러 구현, 인프라, 문서 등 프로젝트의 각 영역에 대한 팀이 포함 된 전체 팀 목록이 있습니다. 해당 팀은 제안서와 의견을 읽고 자신의 의견을 작성하며 결국 기능을 수락하거나 거부 할 합의가 있습니다.</target>
        </trans-unit>
        <trans-unit id="53fc70bfdc4b06ea1c2fe17e53fbb9c43726838e" translate="yes" xml:space="preserve">
          <source>Apart from a method or function with a generic type parameter, this error can occur when a type parameter of a struct or trait cannot be inferred. In that case it is not always possible to use a type annotation, because all candidates have the same return type. For instance:</source>
          <target state="translated">제네릭 형식 매개 변수가있는 메서드 나 함수 외에도 구조체 또는 특성의 형식 매개 변수를 유추 할 수없는 경우이 오류가 발생할 수 있습니다. 이 경우 모든 후보가 동일한 리턴 유형을 가지므로 항상 유형 어노테이션을 사용할 수있는 것은 아닙니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="73973cfd168d40bb8277e2f6044ecdb605409c4e" translate="yes" xml:space="preserve">
          <source>Appendices</source>
          <target state="translated">Appendices</target>
        </trans-unit>
        <trans-unit id="56e2c591df0fef929570597dca64284006730141" translate="yes" xml:space="preserve">
          <source>Appending to a String with &lt;code id=&quot;appending-to-a-string-with-push_str-and-push&quot;&gt;push_str&lt;/code&gt; and &lt;code&gt;push&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;appending-to-a-string-with-push_str-and-push&quot;&gt;push_str&lt;/code&gt; 및 &lt;code&gt;push&lt;/code&gt; 를 사용하여 문자열에 추가</target>
        </trans-unit>
        <trans-unit id="f3f60044b06335eb6c4230e3c39f5e0218445878" translate="yes" xml:space="preserve">
          <source>Appendix</source>
          <target state="translated">Appendix</target>
        </trans-unit>
        <trans-unit id="4c40c194c9cdc4d680691d4aa8fa1913dc98b2c3" translate="yes" xml:space="preserve">
          <source>Appendix A, &amp;ldquo;Keywords,&amp;rdquo; also explains the new raw identifiers feature that enables code written in the 2015 Edition and the 2018 Edition to interoperate.</source>
          <target state="translated">부록 A,&amp;ldquo;키워드&amp;rdquo;에는 2015 년판과 2018 년판으로 작성된 코드가 상호 운용 될 수있는 새로운 원시 식별자 기능도 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8415247b515164394b09f1335fc5dabc83b9e17a" translate="yes" xml:space="preserve">
          <source>Appendix A: Keywords</source>
          <target state="translated">부록 A : 키워드</target>
        </trans-unit>
        <trans-unit id="540243de89d6ff78feccd1151f1eeb23d45eae75" translate="yes" xml:space="preserve">
          <source>Appendix B: Operators and Symbols</source>
          <target state="translated">부록 B : 연산자 및 기호</target>
        </trans-unit>
        <trans-unit id="e440a4e5c41dd9d1d57a9a1afc26c19786ef345a" translate="yes" xml:space="preserve">
          <source>Appendix C: Derivable Traits</source>
          <target state="translated">부록 C : 파생 특성</target>
        </trans-unit>
        <trans-unit id="41116b5529dd9b48afe443e282c8edc6aed9a707" translate="yes" xml:space="preserve">
          <source>Appendix D - Useful Development Tools</source>
          <target state="translated">부록 D-유용한 개발 도구</target>
        </trans-unit>
        <trans-unit id="707523bd94a1c061f370a00dc35452edc4f5ca2b" translate="yes" xml:space="preserve">
          <source>Appendix D is now titled &amp;ldquo;Useful Development Tools&amp;rdquo; and covers recently released tools that help you write Rust code.</source>
          <target state="translated">부록 D의 제목은&amp;ldquo;유용한 개발 도구&amp;rdquo;이며 Rust 코드 작성에 도움이되는 최근에 출시 된 도구를 다룹니다.</target>
        </trans-unit>
        <trans-unit id="e50a67316708bcdc8cd3a1c83a15ee617b6e1717" translate="yes" xml:space="preserve">
          <source>Appendix E - Editions</source>
          <target state="translated">부록 E-에디션</target>
        </trans-unit>
        <trans-unit id="db95e2a46f6e17f889e1ec8cb84b232b2ac6a554" translate="yes" xml:space="preserve">
          <source>Appendix F: Translations of the Book</source>
          <target state="translated">부록 F : 책의 번역</target>
        </trans-unit>
        <trans-unit id="cd9cd2e1d4c917e818f77ba2a0d93ffcdf7874d2" translate="yes" xml:space="preserve">
          <source>Appendix G - How Rust is Made and &amp;ldquo;Nightly Rust&amp;rdquo;</source>
          <target state="translated">부록 G-녹이 발생하는 방식과&amp;ldquo;밤에 녹이 슬다&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="7ea8d3526ea6b8af40ac97da94b0ad40d6cea127" translate="yes" xml:space="preserve">
          <source>Appendix chapters providing rationale and references to languages that influenced the design.</source>
          <target state="translated">설계에 영향을 미치는 언어에 대한 이론적 근거와 참조를 제공하는 부록 장.</target>
        </trans-unit>
        <trans-unit id="0d6a0bfa8816321ae3291d75b6bf84f8077fe48b" translate="yes" xml:space="preserve">
          <source>Appendix: Macro Follow-Set Ambiguity Formal Specification</source>
          <target state="translated">부록 : 매크로 후속 설정 모호성 공식 사양</target>
        </trans-unit>
        <trans-unit id="54e814d184dccc0b7473b24d35812b283adff9c0" translate="yes" xml:space="preserve">
          <source>Appends a given string slice onto the end of this &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">지정된 문자열 슬라이스를이 &lt;code&gt;String&lt;/code&gt; 의 끝에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="bd5ef47a12f2696c33dc462f202e22f6e229647a" translate="yes" xml:space="preserve">
          <source>Appends an element to the back of a collection.</source>
          <target state="translated">컬렉션 뒤에 요소를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="ddf4cf8edbc5fa033e85502f0a84bfe8b2914aec" translate="yes" xml:space="preserve">
          <source>Appends an element to the back of a list.</source>
          <target state="translated">목록 뒤에 요소를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9427717eceb820f7ae4720310e1343f09df153f2" translate="yes" xml:space="preserve">
          <source>Appends an element to the back of the &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;VecDeque&lt;/code&gt; 뒷면에 요소를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="373311f9bb46882cd119d03cfc2b6fa19fdf5ba3" translate="yes" xml:space="preserve">
          <source>Appends the given &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; to the end of this &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 를이 &lt;code&gt;String&lt;/code&gt; 의 끝에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="f88d43733a3d3b030bf7286e9ed4c303cc3a7d2b" translate="yes" xml:space="preserve">
          <source>Application Binary Interface (ABI)</source>
          <target state="translated">응용 프로그램 이진 인터페이스 (ABI)</target>
        </trans-unit>
        <trans-unit id="bed8e79e380caf3902110314a704f53a22b3ecbe" translate="yes" xml:space="preserve">
          <source>Applies a function to the contained value (if any), or computes a default (if not).</source>
          <target state="translated">포함 된 값에 함수를 적용하거나 (있는 경우) 기본값을 계산합니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="ef8795473614177b83e201e3db900beeef41c1e2" translate="yes" xml:space="preserve">
          <source>Applies a function to the contained value (if any), or returns the provided default (if not).</source>
          <target state="translated">포함 된 값에 함수를 적용하거나 (있는 경우) 제공된 기본값을 반환합니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="a6be2123eb22e6f1506885d0c1439a3655475eac" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result.</source>
          <target state="translated">반복자의 요소에 함수를 적용하고 첫 번째가 아닌 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2f579750efee0b6f5e959f71ab15df216a9fb1b9" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result. &lt;a href=&quot;../../../iter/trait.iterator#method.find_map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자의 요소에 함수를 적용하고 첫 번째가 아닌 결과를 반환합니다. &lt;a href=&quot;../../../iter/trait.iterator#method.find_map&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7da1899028718ec8a07b6c08455d63f4e3489b90" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result. &lt;a href=&quot;../../iter/trait.iterator#method.find_map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자의 요소에 함수를 적용하고 첫 번째가 아닌 결과를 반환합니다. &lt;a href=&quot;../../iter/trait.iterator#method.find_map&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0f3002a1274a5209b380bd8bf18387ed22cf040f" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result. &lt;a href=&quot;../iter/trait.iterator#method.find_map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자의 요소에 함수를 적용하고 첫 번째가 아닌 결과를 반환합니다. &lt;a href=&quot;../iter/trait.iterator#method.find_map&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="67cbbc3631a3803076e70ec9a10a8358879f6e02" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result. &lt;a href=&quot;iter/trait.iterator#method.find_map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자의 요소에 함수를 적용하고 첫 번째가 아닌 결과를 반환합니다. &lt;a href=&quot;iter/trait.iterator#method.find_map&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8819d96feaef2f02cd8965c68d9eb2580ebfc977" translate="yes" xml:space="preserve">
          <source>Applies function to the elements of iterator and returns the first non-none result. &lt;a href=&quot;trait.iterator#method.find_map&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자의 요소에 함수를 적용하고 첫 번째가 아닌 결과를 반환합니다. &lt;a href=&quot;trait.iterator#method.find_map&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1ff8e99aa0f8295d1776562bee993cb0a364606b" translate="yes" xml:space="preserve">
          <source>Applies the &quot;?&quot; operator. A return of &lt;code&gt;Ok(t)&lt;/code&gt; means that the execution should continue normally, and the result of &lt;code&gt;?&lt;/code&gt; is the value &lt;code&gt;t&lt;/code&gt;. A return of &lt;code&gt;Err(e)&lt;/code&gt; means that execution should branch to the innermost enclosing &lt;code&gt;catch&lt;/code&gt;, or return from the function.</source>
          <target state="translated">&quot;?&quot;를 적용합니다 운영자. &lt;code&gt;Ok(t)&lt;/code&gt; 의 반환은 실행이 정상적으로 계속되어야한다는 것을 의미하며 &lt;code&gt;?&lt;/code&gt; 값 &lt;code&gt;t&lt;/code&gt; 입니다. &lt;code&gt;Err(e)&lt;/code&gt; 의 반환은 실행이 가장 안쪽에있는 &lt;code&gt;catch&lt;/code&gt; 로 분기 되거나 함수에서 반환 되어야 함을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="d771dbfeb7c050dea75fe4d6749833e3ae20e4ae" translate="yes" xml:space="preserve">
          <source>Applies the &quot;?&quot; operator. A return of &lt;code&gt;Ok(t)&lt;/code&gt; means that the execution should continue normally, and the result of &lt;code&gt;?&lt;/code&gt; is the value &lt;code&gt;t&lt;/code&gt;. A return of &lt;code&gt;Err(e)&lt;/code&gt; means that execution should branch to the innermost enclosing &lt;code&gt;catch&lt;/code&gt;, or return from the function. &lt;a href=&quot;../ops/trait.try#tymethod.into_result&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&quot;?&quot;를 적용합니다 운영자. &lt;code&gt;Ok(t)&lt;/code&gt; 의 반환은 실행이 정상적으로 계속되어야한다는 것을 의미하며 &lt;code&gt;?&lt;/code&gt; 값 &lt;code&gt;t&lt;/code&gt; 입니다. &lt;code&gt;Err(e)&lt;/code&gt; 의 반환은 실행이 가장 안쪽에있는 &lt;code&gt;catch&lt;/code&gt; 로 분기 되거나 함수에서 반환 되어야 함을 의미 합니다. &lt;a href=&quot;../ops/trait.try#tymethod.into_result&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7e15c6fd69af4acca9c9f459c798f3ae0c37890f" translate="yes" xml:space="preserve">
          <source>Approximate number of significant digits in base 10.</source>
          <target state="translated">기수 10의 대략적인 유효 자릿수입니다.</target>
        </trans-unit>
        <trans-unit id="853a983f6b8abdb9ecba43da2ceda1641c9d519f" translate="yes" xml:space="preserve">
          <source>Arc</source>
          <target state="translated">Arc</target>
        </trans-unit>
        <trans-unit id="59cfa485c658b8f9969a88c2eb92540fdf722cfd" translate="yes" xml:space="preserve">
          <source>Arc::as_ref</source>
          <target state="translated">Arc::as_ref</target>
        </trans-unit>
        <trans-unit id="2f1c5ec3613e810179b1dde9e1ff629a07f45de3" translate="yes" xml:space="preserve">
          <source>Arc::borrow</source>
          <target state="translated">Arc::borrow</target>
        </trans-unit>
        <trans-unit id="e6381920a9fbe9f6076603c436d6eef9b74e1f24" translate="yes" xml:space="preserve">
          <source>Arc::borrow_mut</source>
          <target state="translated">Arc::borrow_mut</target>
        </trans-unit>
        <trans-unit id="de0c16869f1a3fad5d726dc3e3fba2293f156861" translate="yes" xml:space="preserve">
          <source>Arc::clamp</source>
          <target state="translated">Arc::clamp</target>
        </trans-unit>
        <trans-unit id="9fa492e8fa6e20e1b52a4de7403dbe55ec1b79bf" translate="yes" xml:space="preserve">
          <source>Arc::clone</source>
          <target state="translated">Arc::clone</target>
        </trans-unit>
        <trans-unit id="39cf0d205cd739521ce28938f9a2250155c1bac4" translate="yes" xml:space="preserve">
          <source>Arc::clone_from</source>
          <target state="translated">Arc::clone_from</target>
        </trans-unit>
        <trans-unit id="773d06cfd159d4606ff3014fee5f9931067cf220" translate="yes" xml:space="preserve">
          <source>Arc::clone_into</source>
          <target state="translated">Arc::clone_into</target>
        </trans-unit>
        <trans-unit id="7561059135cbd0c5fbb5238091fd429a9e1b09c1" translate="yes" xml:space="preserve">
          <source>Arc::cmp</source>
          <target state="translated">Arc::cmp</target>
        </trans-unit>
        <trans-unit id="b73ea8e602ed4ab4007a418f3f6cee6a05a73996" translate="yes" xml:space="preserve">
          <source>Arc::default</source>
          <target state="translated">Arc::default</target>
        </trans-unit>
        <trans-unit id="cdd18aaa5e1ccdcb1656e6b3c539ea6dd22d2613" translate="yes" xml:space="preserve">
          <source>Arc::deref</source>
          <target state="translated">Arc::deref</target>
        </trans-unit>
        <trans-unit id="3d5ef1d21d6636272bbb1c82a7af354e776cadde" translate="yes" xml:space="preserve">
          <source>Arc::downcast</source>
          <target state="translated">Arc::downcast</target>
        </trans-unit>
        <trans-unit id="8f4a9849100a7720ad47a02d98c3cc428143986f" translate="yes" xml:space="preserve">
          <source>Arc::downgrade</source>
          <target state="translated">Arc::downgrade</target>
        </trans-unit>
        <trans-unit id="4d05d06001426353e874710f4e01911168266628" translate="yes" xml:space="preserve">
          <source>Arc::drop</source>
          <target state="translated">Arc::drop</target>
        </trans-unit>
        <trans-unit id="d616628ce7e2e600feb8196c85f5e01fa37ae824" translate="yes" xml:space="preserve">
          <source>Arc::eq</source>
          <target state="translated">Arc::eq</target>
        </trans-unit>
        <trans-unit id="541daae394114016fc018c7425373988b033cde5" translate="yes" xml:space="preserve">
          <source>Arc::fmt</source>
          <target state="translated">Arc::fmt</target>
        </trans-unit>
        <trans-unit id="c5939b1aa685e46bfb67eeb83668be8ab9a5dab1" translate="yes" xml:space="preserve">
          <source>Arc::from</source>
          <target state="translated">Arc::from</target>
        </trans-unit>
        <trans-unit id="dea799f19377ba936fa669465a1dea313ae3aa7a" translate="yes" xml:space="preserve">
          <source>Arc::from_raw</source>
          <target state="translated">Arc::from_raw</target>
        </trans-unit>
        <trans-unit id="6910e0ecb20317c068e1ba9e8ebf007d417f95a2" translate="yes" xml:space="preserve">
          <source>Arc::ge</source>
          <target state="translated">Arc::ge</target>
        </trans-unit>
        <trans-unit id="7e24d2d9f75e2ea02439ac0bd0d3b07ceaa736e4" translate="yes" xml:space="preserve">
          <source>Arc::get_mut</source>
          <target state="translated">Arc::get_mut</target>
        </trans-unit>
        <trans-unit id="e94b486a276abc7bcb5888a4d6fc97a6fa8eebaa" translate="yes" xml:space="preserve">
          <source>Arc::gt</source>
          <target state="translated">Arc::gt</target>
        </trans-unit>
        <trans-unit id="f233cce03a62c687a1d4be5e670e3be37d179359" translate="yes" xml:space="preserve">
          <source>Arc::hash</source>
          <target state="translated">Arc::hash</target>
        </trans-unit>
        <trans-unit id="963937d635066d272a6f67596279f6b16956abdb" translate="yes" xml:space="preserve">
          <source>Arc::hash_slice</source>
          <target state="translated">Arc::hash_slice</target>
        </trans-unit>
        <trans-unit id="2b8954f29938fa3429d664d59b2922996301d34a" translate="yes" xml:space="preserve">
          <source>Arc::into</source>
          <target state="translated">Arc::into</target>
        </trans-unit>
        <trans-unit id="24e83cc9b0b264818fc7b3695d912fc8e4d9e845" translate="yes" xml:space="preserve">
          <source>Arc::into_raw</source>
          <target state="translated">Arc::into_raw</target>
        </trans-unit>
        <trans-unit id="921d5aa53e181c2612da9bf23381db35c63bd321" translate="yes" xml:space="preserve">
          <source>Arc::into_raw_non_null</source>
          <target state="translated">Arc::into_raw_non_null</target>
        </trans-unit>
        <trans-unit id="f3473006930ab6b55f7aef32c93c0af0f87e7790" translate="yes" xml:space="preserve">
          <source>Arc::le</source>
          <target state="translated">Arc::le</target>
        </trans-unit>
        <trans-unit id="34b95793d03cc8c6cef222cea98c6e99dc74e9e2" translate="yes" xml:space="preserve">
          <source>Arc::lt</source>
          <target state="translated">Arc::lt</target>
        </trans-unit>
        <trans-unit id="eab1ca96353cac811bc765a502fbbe1723278950" translate="yes" xml:space="preserve">
          <source>Arc::make_mut</source>
          <target state="translated">Arc::make_mut</target>
        </trans-unit>
        <trans-unit id="0a9a2e87881627fae4b58af4ea1e4cdaa0c36395" translate="yes" xml:space="preserve">
          <source>Arc::max</source>
          <target state="translated">Arc::max</target>
        </trans-unit>
        <trans-unit id="431ba8a8a73b16f867d8367c027605d9a9f25a4e" translate="yes" xml:space="preserve">
          <source>Arc::min</source>
          <target state="translated">Arc::min</target>
        </trans-unit>
        <trans-unit id="a700586ffae96fc24dca7f29fd88b64a47bae03d" translate="yes" xml:space="preserve">
          <source>Arc::ne</source>
          <target state="translated">Arc::ne</target>
        </trans-unit>
        <trans-unit id="1311cfe952a5208cf9ab108dab2eb693395bbca1" translate="yes" xml:space="preserve">
          <source>Arc::new</source>
          <target state="translated">Arc::new</target>
        </trans-unit>
        <trans-unit id="2c2d4efc7b27aae2edec462666037bcaf500cae7" translate="yes" xml:space="preserve">
          <source>Arc::partial_cmp</source>
          <target state="translated">Arc::partial_cmp</target>
        </trans-unit>
        <trans-unit id="41a523a445899356c297537c4b72fff018176305" translate="yes" xml:space="preserve">
          <source>Arc::pin</source>
          <target state="translated">Arc::pin</target>
        </trans-unit>
        <trans-unit id="1d09dbe8f647daf2ca429c9d36141d61d7d2799f" translate="yes" xml:space="preserve">
          <source>Arc::ptr_eq</source>
          <target state="translated">Arc::ptr_eq</target>
        </trans-unit>
        <trans-unit id="ec8427607c6875d57c1cbb7ae116c8a1b2bc9f8b" translate="yes" xml:space="preserve">
          <source>Arc::strong_count</source>
          <target state="translated">Arc::strong_count</target>
        </trans-unit>
        <trans-unit id="12f7dc5817d10cbbabc6ff3c697a1ca67ff339d5" translate="yes" xml:space="preserve">
          <source>Arc::to_owned</source>
          <target state="translated">Arc::to_owned</target>
        </trans-unit>
        <trans-unit id="dd1da4e8925e8953dfb4aef0354dd388c867af08" translate="yes" xml:space="preserve">
          <source>Arc::to_string</source>
          <target state="translated">Arc::to_string</target>
        </trans-unit>
        <trans-unit id="b36b4607ae74c4708612a87739b787ab550df768" translate="yes" xml:space="preserve">
          <source>Arc::try_from</source>
          <target state="translated">Arc::try_from</target>
        </trans-unit>
        <trans-unit id="450b59e4892b86614294b44b39674630d4067a1f" translate="yes" xml:space="preserve">
          <source>Arc::try_into</source>
          <target state="translated">Arc::try_into</target>
        </trans-unit>
        <trans-unit id="8cc0a8e7a4fa3ddf0be44f0e2f8210b7538bff4d" translate="yes" xml:space="preserve">
          <source>Arc::try_unwrap</source>
          <target state="translated">Arc::try_unwrap</target>
        </trans-unit>
        <trans-unit id="e60b417105d1b796fbb9108c579b5a5a3f60ab78" translate="yes" xml:space="preserve">
          <source>Arc::type_id</source>
          <target state="translated">Arc::type_id</target>
        </trans-unit>
        <trans-unit id="6623270e41b383306513b26dd0972d02a62dabdc" translate="yes" xml:space="preserve">
          <source>Arc::weak_count</source>
          <target state="translated">Arc::weak_count</target>
        </trans-unit>
        <trans-unit id="bcef6163f2366764b97712c1e02d4e8de8728060" translate="yes" xml:space="preserve">
          <source>Archimedes' constant (&amp;pi;)</source>
          <target state="translated">아르키메데스 상수 (&amp;pi;)</target>
        </trans-unit>
        <trans-unit id="02d36a6ada7ba4a678771b24dc19a1d26e06d584" translate="yes" xml:space="preserve">
          <source>Are allowed to be null</source>
          <target state="translated">널이 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="7bcd778277bf4c00f69bda3256c3718425635b4a" translate="yes" xml:space="preserve">
          <source>Are allowed to ignore the borrowing rules by having both immutable and mutable pointers or multiple mutable pointers to the same location</source>
          <target state="translated">불변 및 가변 포인터 또는 동일한 위치에 대한 다중 가변 포인터를 사용하여 차용 규칙을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79232b3ded8b7d0b1c86ea5d989ec5b302602c26" translate="yes" xml:space="preserve">
          <source>Aren&amp;rsquo;t guaranteed to point to valid memory</source>
          <target state="translated">유효한 메모리를 가리킬 수는 없습니다</target>
        </trans-unit>
        <trans-unit id="4bf0024c4bc943f998126635e2b2826496ec8582" translate="yes" xml:space="preserve">
          <source>Args</source>
          <target state="translated">Args</target>
        </trans-unit>
        <trans-unit id="11997e344b54f51ca26eed6c34abb35c17719846" translate="yes" xml:space="preserve">
          <source>Args::all</source>
          <target state="translated">Args::all</target>
        </trans-unit>
        <trans-unit id="834e48f2681bde9c6de2a1d6fe4ea459480940da" translate="yes" xml:space="preserve">
          <source>Args::any</source>
          <target state="translated">Args::any</target>
        </trans-unit>
        <trans-unit id="852de3f0c6270398ac654986a4377df5f50c393c" translate="yes" xml:space="preserve">
          <source>Args::borrow</source>
          <target state="translated">Args::borrow</target>
        </trans-unit>
        <trans-unit id="8aa2c84655d80e6196471b5bce3e6eb8f9d79f61" translate="yes" xml:space="preserve">
          <source>Args::borrow_mut</source>
          <target state="translated">Args::borrow_mut</target>
        </trans-unit>
        <trans-unit id="6235293cd6910b3c74977e8687ec90afadb03077" translate="yes" xml:space="preserve">
          <source>Args::by_ref</source>
          <target state="translated">Args::by_ref</target>
        </trans-unit>
        <trans-unit id="4438640d50dfd08974f7aac6bf0d2aecb461c3f5" translate="yes" xml:space="preserve">
          <source>Args::chain</source>
          <target state="translated">Args::chain</target>
        </trans-unit>
        <trans-unit id="fd443c43e63db2a659b5f263c42823b6b670bd44" translate="yes" xml:space="preserve">
          <source>Args::cloned</source>
          <target state="translated">Args::cloned</target>
        </trans-unit>
        <trans-unit id="46277936c8445a042e94cc3a26942468f91253e9" translate="yes" xml:space="preserve">
          <source>Args::cmp</source>
          <target state="translated">Args::cmp</target>
        </trans-unit>
        <trans-unit id="48dd95fc8d6a07728f5a1cf7809d55524bf20034" translate="yes" xml:space="preserve">
          <source>Args::collect</source>
          <target state="translated">Args::collect</target>
        </trans-unit>
        <trans-unit id="9d0c9a3a72db97b3f6cab2b952f231796f20a50c" translate="yes" xml:space="preserve">
          <source>Args::copied</source>
          <target state="translated">Args::copied</target>
        </trans-unit>
        <trans-unit id="4fbeb4376f2e8b5f2155e6dbdec8f0740c8c04c9" translate="yes" xml:space="preserve">
          <source>Args::count</source>
          <target state="translated">Args::count</target>
        </trans-unit>
        <trans-unit id="4a06de4989ebe4016d146a0bb3c59a627e816965" translate="yes" xml:space="preserve">
          <source>Args::cycle</source>
          <target state="translated">Args::cycle</target>
        </trans-unit>
        <trans-unit id="dbd2a1eb1e566bd90b7919caa38a19ccb4685bdf" translate="yes" xml:space="preserve">
          <source>Args::enumerate</source>
          <target state="translated">Args::enumerate</target>
        </trans-unit>
        <trans-unit id="d22f2ebcc4f66631a8b99dffd5e42317b95a23c3" translate="yes" xml:space="preserve">
          <source>Args::eq</source>
          <target state="translated">Args::eq</target>
        </trans-unit>
        <trans-unit id="825fef0560348f1a6b9c4b27b6c58018c4f453ef" translate="yes" xml:space="preserve">
          <source>Args::filter</source>
          <target state="translated">Args::filter</target>
        </trans-unit>
        <trans-unit id="ab08ac4972fbd0c43add6cedcff53d5b9d40bc35" translate="yes" xml:space="preserve">
          <source>Args::filter_map</source>
          <target state="translated">Args::filter_map</target>
        </trans-unit>
        <trans-unit id="86056472eedb8eee7dbef63077919c7204cfa67b" translate="yes" xml:space="preserve">
          <source>Args::find</source>
          <target state="translated">Args::find</target>
        </trans-unit>
        <trans-unit id="e877bf0f63fb53fe48a38a7b49bdba91724d4dc9" translate="yes" xml:space="preserve">
          <source>Args::find_map</source>
          <target state="translated">Args::find_map</target>
        </trans-unit>
        <trans-unit id="09774b60a814c8b4104b1538a3d2232fe023f569" translate="yes" xml:space="preserve">
          <source>Args::flat_map</source>
          <target state="translated">Args::flat_map</target>
        </trans-unit>
        <trans-unit id="5eeb63d240af1b2ec0ce621fdcebe38dd652ee35" translate="yes" xml:space="preserve">
          <source>Args::flatten</source>
          <target state="translated">Args::flatten</target>
        </trans-unit>
        <trans-unit id="2824f41303961ce133138bbb9cdb7c73c49c034e" translate="yes" xml:space="preserve">
          <source>Args::fmt</source>
          <target state="translated">Args::fmt</target>
        </trans-unit>
        <trans-unit id="bdc321df53c7563363bb091073cc745371fec866" translate="yes" xml:space="preserve">
          <source>Args::fold</source>
          <target state="translated">Args::fold</target>
        </trans-unit>
        <trans-unit id="0bfb713bd78f482e7b1b8ccad2fb85c3059b45d0" translate="yes" xml:space="preserve">
          <source>Args::for_each</source>
          <target state="translated">Args::for_each</target>
        </trans-unit>
        <trans-unit id="bf62c774de1d7877320ea0fd8f640a1da6f668ae" translate="yes" xml:space="preserve">
          <source>Args::from</source>
          <target state="translated">Args::from</target>
        </trans-unit>
        <trans-unit id="4b2d02be4c99f1b285f809b3bada4d6e1d5de2c4" translate="yes" xml:space="preserve">
          <source>Args::fuse</source>
          <target state="translated">Args::fuse</target>
        </trans-unit>
        <trans-unit id="e9d47e65f07958eb4c539e9aa4794d4c91301d74" translate="yes" xml:space="preserve">
          <source>Args::ge</source>
          <target state="translated">Args::ge</target>
        </trans-unit>
        <trans-unit id="41716a498dc92ecead97571d6a7701faab3446af" translate="yes" xml:space="preserve">
          <source>Args::gt</source>
          <target state="translated">Args::gt</target>
        </trans-unit>
        <trans-unit id="ffe407b598fd64603f4cdfacf4c22332227c8373" translate="yes" xml:space="preserve">
          <source>Args::inspect</source>
          <target state="translated">Args::inspect</target>
        </trans-unit>
        <trans-unit id="4982b89e7bce55b901b94270e4e00a5ac09ba3e0" translate="yes" xml:space="preserve">
          <source>Args::into</source>
          <target state="translated">Args::into</target>
        </trans-unit>
        <trans-unit id="2fc7d02ccfe30c7d6decfb090f0a5dcabb2e0c43" translate="yes" xml:space="preserve">
          <source>Args::into_iter</source>
          <target state="translated">Args::into_iter</target>
        </trans-unit>
        <trans-unit id="0cc324954d5e5cfc9f0640a45fd39c06463171c8" translate="yes" xml:space="preserve">
          <source>Args::is_empty</source>
          <target state="translated">Args::is_empty</target>
        </trans-unit>
        <trans-unit id="9320ccfba6fb85da2cd8f4ea07146d9e90d55e69" translate="yes" xml:space="preserve">
          <source>Args::is_sorted</source>
          <target state="translated">Args::is_sorted</target>
        </trans-unit>
        <trans-unit id="18a7ac322b2479e407afbb8da7a0d6e559099523" translate="yes" xml:space="preserve">
          <source>Args::is_sorted_by</source>
          <target state="translated">Args::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="8d806d23a84355aca10dbfd0171313e44075d284" translate="yes" xml:space="preserve">
          <source>Args::is_sorted_by_key</source>
          <target state="translated">Args::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="c6efefb9b080afb608e934c39e299c62aaaa6fc0" translate="yes" xml:space="preserve">
          <source>Args::last</source>
          <target state="translated">Args::last</target>
        </trans-unit>
        <trans-unit id="04a547ce59955db8d408e3c98a9edc55fc1c82e5" translate="yes" xml:space="preserve">
          <source>Args::le</source>
          <target state="translated">Args::le</target>
        </trans-unit>
        <trans-unit id="f88c3621988f7c3fdb34fd16f1e9ea82cfbcea71" translate="yes" xml:space="preserve">
          <source>Args::len</source>
          <target state="translated">Args::len</target>
        </trans-unit>
        <trans-unit id="01c7bcbbd63e3d113fbbd64d77442cb638b835d1" translate="yes" xml:space="preserve">
          <source>Args::lt</source>
          <target state="translated">Args::lt</target>
        </trans-unit>
        <trans-unit id="039581be23b84f6e55f8a2add1bc6bfa811639f2" translate="yes" xml:space="preserve">
          <source>Args::map</source>
          <target state="translated">Args::map</target>
        </trans-unit>
        <trans-unit id="994f671b6e95e4ae34dd6e2c082281ea8ea61313" translate="yes" xml:space="preserve">
          <source>Args::max</source>
          <target state="translated">Args::max</target>
        </trans-unit>
        <trans-unit id="74a4e2d3f00af26f6a0ad2245e073d3b5a0cd3d2" translate="yes" xml:space="preserve">
          <source>Args::max_by</source>
          <target state="translated">Args::max_by</target>
        </trans-unit>
        <trans-unit id="deb310f6f85b56ebc7fe38e266f44493563fc6cf" translate="yes" xml:space="preserve">
          <source>Args::max_by_key</source>
          <target state="translated">Args::max_by_key</target>
        </trans-unit>
        <trans-unit id="dde4047d67a5b16733c51e9703c57fbdf575a4e4" translate="yes" xml:space="preserve">
          <source>Args::min</source>
          <target state="translated">Args::min</target>
        </trans-unit>
        <trans-unit id="403ed2480b700e9a65c715919e29b948e24f4b97" translate="yes" xml:space="preserve">
          <source>Args::min_by</source>
          <target state="translated">Args::min_by</target>
        </trans-unit>
        <trans-unit id="61041884b34bb5182aa5504e5448d5bac7a830ec" translate="yes" xml:space="preserve">
          <source>Args::min_by_key</source>
          <target state="translated">Args::min_by_key</target>
        </trans-unit>
        <trans-unit id="254900be5bd6dab1a3e1e8f2d8135ce517862048" translate="yes" xml:space="preserve">
          <source>Args::ne</source>
          <target state="translated">Args::ne</target>
        </trans-unit>
        <trans-unit id="d7cb929a8cedef153a932b274a4aba45b153fd66" translate="yes" xml:space="preserve">
          <source>Args::next</source>
          <target state="translated">Args::next</target>
        </trans-unit>
        <trans-unit id="2dcb9f5424d93dea8b755e44bed8488448308f48" translate="yes" xml:space="preserve">
          <source>Args::next_back</source>
          <target state="translated">Args::next_back</target>
        </trans-unit>
        <trans-unit id="7117eeb7949ae721ac3782d5eedc483a09ccac61" translate="yes" xml:space="preserve">
          <source>Args::nth</source>
          <target state="translated">Args::nth</target>
        </trans-unit>
        <trans-unit id="920bfede689288166976e1de3db01783fca343a2" translate="yes" xml:space="preserve">
          <source>Args::nth_back</source>
          <target state="translated">Args::nth_back</target>
        </trans-unit>
        <trans-unit id="827560f3761313e8fff14e1e90ac372f2bcfaccc" translate="yes" xml:space="preserve">
          <source>Args::partial_cmp</source>
          <target state="translated">Args::partial_cmp</target>
        </trans-unit>
        <trans-unit id="7fd69506fed5f2e3f675c8f01ed77c7a8573ed9f" translate="yes" xml:space="preserve">
          <source>Args::partition</source>
          <target state="translated">Args::partition</target>
        </trans-unit>
        <trans-unit id="0f80b2cd77c5343960cc6f37513564b206a6f770" translate="yes" xml:space="preserve">
          <source>Args::peekable</source>
          <target state="translated">Args::peekable</target>
        </trans-unit>
        <trans-unit id="d35d46b1d259e3d81a7c87e03f05934ae588d4a7" translate="yes" xml:space="preserve">
          <source>Args::position</source>
          <target state="translated">Args::position</target>
        </trans-unit>
        <trans-unit id="4ed9e8e605899d2c4c96340af8f07ac7b263210f" translate="yes" xml:space="preserve">
          <source>Args::product</source>
          <target state="translated">Args::product</target>
        </trans-unit>
        <trans-unit id="eb295f32cccde70f35d8df7df01c50708f27bd93" translate="yes" xml:space="preserve">
          <source>Args::rev</source>
          <target state="translated">Args::rev</target>
        </trans-unit>
        <trans-unit id="98d2de96a420de7658219d3f9bda5b24ca2443f7" translate="yes" xml:space="preserve">
          <source>Args::rfind</source>
          <target state="translated">Args::rfind</target>
        </trans-unit>
        <trans-unit id="3cc34e3e8eb1da327b82585d5a13fd8b2bb5890e" translate="yes" xml:space="preserve">
          <source>Args::rfold</source>
          <target state="translated">Args::rfold</target>
        </trans-unit>
        <trans-unit id="3a7a7236e75fdfae5572db48f2aad6e6378da2eb" translate="yes" xml:space="preserve">
          <source>Args::rposition</source>
          <target state="translated">Args::rposition</target>
        </trans-unit>
        <trans-unit id="9fc0f79d5cd6405747d8f5be32af5064749f81b9" translate="yes" xml:space="preserve">
          <source>Args::scan</source>
          <target state="translated">Args::scan</target>
        </trans-unit>
        <trans-unit id="12148001c865165a5de07ba3c727c97aab92c761" translate="yes" xml:space="preserve">
          <source>Args::size_hint</source>
          <target state="translated">Args::size_hint</target>
        </trans-unit>
        <trans-unit id="1189df09a529d4be32c97dfca9793d84611fd824" translate="yes" xml:space="preserve">
          <source>Args::skip</source>
          <target state="translated">Args::skip</target>
        </trans-unit>
        <trans-unit id="764acccc052619da2c47813fd259dab289d9bd67" translate="yes" xml:space="preserve">
          <source>Args::skip_while</source>
          <target state="translated">Args::skip_while</target>
        </trans-unit>
        <trans-unit id="904035ea6ead93ad6bd21ffe6010b797797cfccb" translate="yes" xml:space="preserve">
          <source>Args::step_by</source>
          <target state="translated">Args::step_by</target>
        </trans-unit>
        <trans-unit id="d5a7f219c1fc0a0f719ef62e5e91b056ae17a132" translate="yes" xml:space="preserve">
          <source>Args::sum</source>
          <target state="translated">Args::sum</target>
        </trans-unit>
        <trans-unit id="27af1223e3252d8316e5510ef65c11dd18e7e048" translate="yes" xml:space="preserve">
          <source>Args::take</source>
          <target state="translated">Args::take</target>
        </trans-unit>
        <trans-unit id="70510b85e050ccfd0ca156b8552398d830c8ca29" translate="yes" xml:space="preserve">
          <source>Args::take_while</source>
          <target state="translated">Args::take_while</target>
        </trans-unit>
        <trans-unit id="29671ebf88bfe467b330af20810dd95f14bee716" translate="yes" xml:space="preserve">
          <source>Args::try_fold</source>
          <target state="translated">Args::try_fold</target>
        </trans-unit>
        <trans-unit id="11314668861a5fe3812661a0778a42dd4d60ecc6" translate="yes" xml:space="preserve">
          <source>Args::try_for_each</source>
          <target state="translated">Args::try_for_each</target>
        </trans-unit>
        <trans-unit id="a3e7a43251306d98977b3648cb61a36b6b67f71f" translate="yes" xml:space="preserve">
          <source>Args::try_from</source>
          <target state="translated">Args::try_from</target>
        </trans-unit>
        <trans-unit id="ea7b4151424c750739941030cbfa813500f83861" translate="yes" xml:space="preserve">
          <source>Args::try_into</source>
          <target state="translated">Args::try_into</target>
        </trans-unit>
        <trans-unit id="a09bc59807578d3bfcb3f5e6f7f7b11ca71a5fda" translate="yes" xml:space="preserve">
          <source>Args::try_rfold</source>
          <target state="translated">Args::try_rfold</target>
        </trans-unit>
        <trans-unit id="ef5ea75da51804787206df18b378f5490fe6418b" translate="yes" xml:space="preserve">
          <source>Args::type_id</source>
          <target state="translated">Args::type_id</target>
        </trans-unit>
        <trans-unit id="3e828aa1b5449d683bef869c26ce0986ec45e670" translate="yes" xml:space="preserve">
          <source>Args::unzip</source>
          <target state="translated">Args::unzip</target>
        </trans-unit>
        <trans-unit id="468f2b4280fd073d79df60860923a06807813556" translate="yes" xml:space="preserve">
          <source>Args::zip</source>
          <target state="translated">Args::zip</target>
        </trans-unit>
        <trans-unit id="08a635e24e7197ec936245f74886d0fae256f6f3" translate="yes" xml:space="preserve">
          <source>ArgsOs</source>
          <target state="translated">ArgsOs</target>
        </trans-unit>
        <trans-unit id="1699d7288d57eee287607a5a8cf4daa06cbf36b5" translate="yes" xml:space="preserve">
          <source>ArgsOs::all</source>
          <target state="translated">ArgsOs::all</target>
        </trans-unit>
        <trans-unit id="1845d364695de9046a1a2e308d836950518c8379" translate="yes" xml:space="preserve">
          <source>ArgsOs::any</source>
          <target state="translated">ArgsOs::any</target>
        </trans-unit>
        <trans-unit id="b88db8b95877207b42c5e88cfc5b222b32d38f42" translate="yes" xml:space="preserve">
          <source>ArgsOs::borrow</source>
          <target state="translated">ArgsOs::borrow</target>
        </trans-unit>
        <trans-unit id="6883c744eb4014b5c2b448f2adc1b25a04e5fc9e" translate="yes" xml:space="preserve">
          <source>ArgsOs::borrow_mut</source>
          <target state="translated">ArgsOs::borrow_mut</target>
        </trans-unit>
        <trans-unit id="54a7160bba6f31fb20a2a3b6f79944613335629e" translate="yes" xml:space="preserve">
          <source>ArgsOs::by_ref</source>
          <target state="translated">ArgsOs::by_ref</target>
        </trans-unit>
        <trans-unit id="45e9d062b28c81d2586823abf5265cf79f0f53c3" translate="yes" xml:space="preserve">
          <source>ArgsOs::chain</source>
          <target state="translated">ArgsOs::chain</target>
        </trans-unit>
        <trans-unit id="06a86328c3295b9577a55fd6532e3d512a4376ad" translate="yes" xml:space="preserve">
          <source>ArgsOs::cloned</source>
          <target state="translated">ArgsOs::cloned</target>
        </trans-unit>
        <trans-unit id="aa33a26c7a85d39e633ece2b7ab215364fa8c21f" translate="yes" xml:space="preserve">
          <source>ArgsOs::cmp</source>
          <target state="translated">ArgsOs::cmp</target>
        </trans-unit>
        <trans-unit id="4444bf776c1fcbbef6e3005b548a29289b32ecc4" translate="yes" xml:space="preserve">
          <source>ArgsOs::collect</source>
          <target state="translated">ArgsOs::collect</target>
        </trans-unit>
        <trans-unit id="efa527796ad53e7b95c87dfbab81f527bd59777a" translate="yes" xml:space="preserve">
          <source>ArgsOs::copied</source>
          <target state="translated">ArgsOs::copied</target>
        </trans-unit>
        <trans-unit id="cf8617f607b90e848c8eda2dcecf733646bd740b" translate="yes" xml:space="preserve">
          <source>ArgsOs::count</source>
          <target state="translated">ArgsOs::count</target>
        </trans-unit>
        <trans-unit id="9774f0ee5373559d8ebaf6e270d32276c2460f0f" translate="yes" xml:space="preserve">
          <source>ArgsOs::cycle</source>
          <target state="translated">ArgsOs::cycle</target>
        </trans-unit>
        <trans-unit id="0c42cc7e9e0e5f5dcbc76f351e7fb1817634bb40" translate="yes" xml:space="preserve">
          <source>ArgsOs::enumerate</source>
          <target state="translated">ArgsOs::enumerate</target>
        </trans-unit>
        <trans-unit id="d5b0b5b450101b6daed6089615021285ab2aa9bc" translate="yes" xml:space="preserve">
          <source>ArgsOs::eq</source>
          <target state="translated">ArgsOs::eq</target>
        </trans-unit>
        <trans-unit id="22ebb6f40c3d512ac39613bf4969beaa463bb89c" translate="yes" xml:space="preserve">
          <source>ArgsOs::filter</source>
          <target state="translated">ArgsOs::filter</target>
        </trans-unit>
        <trans-unit id="ec9b19d64b96da14ed417d0d212d3d54ea4a4759" translate="yes" xml:space="preserve">
          <source>ArgsOs::filter_map</source>
          <target state="translated">ArgsOs::filter_map</target>
        </trans-unit>
        <trans-unit id="f90d91bcb86730d9c77f4746181813b55b242a5f" translate="yes" xml:space="preserve">
          <source>ArgsOs::find</source>
          <target state="translated">ArgsOs::find</target>
        </trans-unit>
        <trans-unit id="8c42c2da49296751bd09d90e62d79798dd8f5449" translate="yes" xml:space="preserve">
          <source>ArgsOs::find_map</source>
          <target state="translated">ArgsOs::find_map</target>
        </trans-unit>
        <trans-unit id="8ae8230900a56717520df737b9d2946aa58958f4" translate="yes" xml:space="preserve">
          <source>ArgsOs::flat_map</source>
          <target state="translated">ArgsOs::flat_map</target>
        </trans-unit>
        <trans-unit id="582b0a8882844e707b1b16686981fe8a3215c0f7" translate="yes" xml:space="preserve">
          <source>ArgsOs::flatten</source>
          <target state="translated">ArgsOs::flatten</target>
        </trans-unit>
        <trans-unit id="42a3165a3645e00a5c082e56522288eb3545955a" translate="yes" xml:space="preserve">
          <source>ArgsOs::fmt</source>
          <target state="translated">ArgsOs::fmt</target>
        </trans-unit>
        <trans-unit id="c973a490f8d75776d7cc21ebc26d8640412d8da5" translate="yes" xml:space="preserve">
          <source>ArgsOs::fold</source>
          <target state="translated">ArgsOs::fold</target>
        </trans-unit>
        <trans-unit id="521243a10a5ee6932b3c00a38bb64a1066346423" translate="yes" xml:space="preserve">
          <source>ArgsOs::for_each</source>
          <target state="translated">ArgsOs::for_each</target>
        </trans-unit>
        <trans-unit id="b3beb1c32ac134bd58a5525cb75b6818caadc2e7" translate="yes" xml:space="preserve">
          <source>ArgsOs::from</source>
          <target state="translated">ArgsOs::from</target>
        </trans-unit>
        <trans-unit id="0467b6e7a5907960746adb88f1797855273e5e38" translate="yes" xml:space="preserve">
          <source>ArgsOs::fuse</source>
          <target state="translated">ArgsOs::fuse</target>
        </trans-unit>
        <trans-unit id="8d918573a70aed631b8ef7e464f6978aeac45512" translate="yes" xml:space="preserve">
          <source>ArgsOs::ge</source>
          <target state="translated">ArgsOs::ge</target>
        </trans-unit>
        <trans-unit id="ed7bd18154ad5939e8306b095fe2d6551d9c5960" translate="yes" xml:space="preserve">
          <source>ArgsOs::gt</source>
          <target state="translated">ArgsOs::gt</target>
        </trans-unit>
        <trans-unit id="f6ab996f18c666c657723e3d6b826e9d4f34afa4" translate="yes" xml:space="preserve">
          <source>ArgsOs::inspect</source>
          <target state="translated">ArgsOs::inspect</target>
        </trans-unit>
        <trans-unit id="118a0e4c62985069de5d564f7e5aeaefdb4f3eee" translate="yes" xml:space="preserve">
          <source>ArgsOs::into</source>
          <target state="translated">ArgsOs::into</target>
        </trans-unit>
        <trans-unit id="6fe469f351f3d71c45f5b8b8a01a85ba417f2962" translate="yes" xml:space="preserve">
          <source>ArgsOs::into_iter</source>
          <target state="translated">ArgsOs::into_iter</target>
        </trans-unit>
        <trans-unit id="52e21117a73746309084ded1b85082f14e2f4f3c" translate="yes" xml:space="preserve">
          <source>ArgsOs::is_empty</source>
          <target state="translated">ArgsOs::is_empty</target>
        </trans-unit>
        <trans-unit id="bc22f51d728c32072e58dab02dc3f74a273221da" translate="yes" xml:space="preserve">
          <source>ArgsOs::is_sorted</source>
          <target state="translated">ArgsOs::is_sorted</target>
        </trans-unit>
        <trans-unit id="6ce480c601285e3d630fdd46e557dfb3c792fc47" translate="yes" xml:space="preserve">
          <source>ArgsOs::is_sorted_by</source>
          <target state="translated">ArgsOs::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="1bd6484be8e79119af4f357c6727e9cce127bfb7" translate="yes" xml:space="preserve">
          <source>ArgsOs::is_sorted_by_key</source>
          <target state="translated">ArgsOs::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="2960d55410634dcaa01ebfd4efb87d3210b4b30b" translate="yes" xml:space="preserve">
          <source>ArgsOs::last</source>
          <target state="translated">ArgsOs::last</target>
        </trans-unit>
        <trans-unit id="49cd1005a59ab868a13fc3b698fa037af9e3cc25" translate="yes" xml:space="preserve">
          <source>ArgsOs::le</source>
          <target state="translated">ArgsOs::le</target>
        </trans-unit>
        <trans-unit id="9662bed516b84aec77303964e4aba365d517a6ce" translate="yes" xml:space="preserve">
          <source>ArgsOs::len</source>
          <target state="translated">ArgsOs::len</target>
        </trans-unit>
        <trans-unit id="a4fd3a509313cc726b4eb5e364e66dd0311cbccc" translate="yes" xml:space="preserve">
          <source>ArgsOs::lt</source>
          <target state="translated">ArgsOs::lt</target>
        </trans-unit>
        <trans-unit id="b4ee6f488be886ab0828730edfa187e1158ffbf4" translate="yes" xml:space="preserve">
          <source>ArgsOs::map</source>
          <target state="translated">ArgsOs::map</target>
        </trans-unit>
        <trans-unit id="ae8b8dee55299bdeb6e240152d7d260302e580f0" translate="yes" xml:space="preserve">
          <source>ArgsOs::max</source>
          <target state="translated">ArgsOs::max</target>
        </trans-unit>
        <trans-unit id="f393dc70d5755703ad87bcd703e01acde42fd52e" translate="yes" xml:space="preserve">
          <source>ArgsOs::max_by</source>
          <target state="translated">ArgsOs::max_by</target>
        </trans-unit>
        <trans-unit id="c3d12b23ad084b94bc1bb5877f3a0e669b6dcbe5" translate="yes" xml:space="preserve">
          <source>ArgsOs::max_by_key</source>
          <target state="translated">ArgsOs::max_by_key</target>
        </trans-unit>
        <trans-unit id="1877909fb92070e732d578d5a61015d6567d1c05" translate="yes" xml:space="preserve">
          <source>ArgsOs::min</source>
          <target state="translated">ArgsOs::min</target>
        </trans-unit>
        <trans-unit id="1b9560ee3684ef678a7f2060396e14192ebd977a" translate="yes" xml:space="preserve">
          <source>ArgsOs::min_by</source>
          <target state="translated">ArgsOs::min_by</target>
        </trans-unit>
        <trans-unit id="ce07e6453a52864ecbf5f176d284c9622c84c927" translate="yes" xml:space="preserve">
          <source>ArgsOs::min_by_key</source>
          <target state="translated">ArgsOs::min_by_key</target>
        </trans-unit>
        <trans-unit id="77abc8099c1b361ea642538729c1cfa9c4ad2af8" translate="yes" xml:space="preserve">
          <source>ArgsOs::ne</source>
          <target state="translated">ArgsOs::ne</target>
        </trans-unit>
        <trans-unit id="94df206ce16974feea2fee745eeb9bededb98233" translate="yes" xml:space="preserve">
          <source>ArgsOs::next</source>
          <target state="translated">ArgsOs::next</target>
        </trans-unit>
        <trans-unit id="0b4bd6a54c1bdb1cb1c37909c4bbdf8ee8eedba4" translate="yes" xml:space="preserve">
          <source>ArgsOs::next_back</source>
          <target state="translated">ArgsOs::next_back</target>
        </trans-unit>
        <trans-unit id="32001a37fe7fa6c38a9dab6e3ccac83215a6af0b" translate="yes" xml:space="preserve">
          <source>ArgsOs::nth</source>
          <target state="translated">ArgsOs::nth</target>
        </trans-unit>
        <trans-unit id="eed0fe5e0346646ed8f493e45f87707e6ef665d0" translate="yes" xml:space="preserve">
          <source>ArgsOs::nth_back</source>
          <target state="translated">ArgsOs::nth_back</target>
        </trans-unit>
        <trans-unit id="76d2262b3586a0b114f133d396c15e36cdbd64ee" translate="yes" xml:space="preserve">
          <source>ArgsOs::partial_cmp</source>
          <target state="translated">ArgsOs::partial_cmp</target>
        </trans-unit>
        <trans-unit id="c88ee3f44d1aaf87a7e7075664272abea7e57c22" translate="yes" xml:space="preserve">
          <source>ArgsOs::partition</source>
          <target state="translated">ArgsOs::partition</target>
        </trans-unit>
        <trans-unit id="b772163bfba047ed1ad9679588037cc0b2a982a9" translate="yes" xml:space="preserve">
          <source>ArgsOs::peekable</source>
          <target state="translated">ArgsOs::peekable</target>
        </trans-unit>
        <trans-unit id="28f42c15452e45ff29cd38077309d81cd1bf23ef" translate="yes" xml:space="preserve">
          <source>ArgsOs::position</source>
          <target state="translated">ArgsOs::position</target>
        </trans-unit>
        <trans-unit id="9c54799fe9d66e9fe809d53c0ad35f91d0345b2d" translate="yes" xml:space="preserve">
          <source>ArgsOs::product</source>
          <target state="translated">ArgsOs::product</target>
        </trans-unit>
        <trans-unit id="24d0c67c7635532e04027af92577d329d52e0d8d" translate="yes" xml:space="preserve">
          <source>ArgsOs::rev</source>
          <target state="translated">ArgsOs::rev</target>
        </trans-unit>
        <trans-unit id="9a893fd65a1fd7e4f90c4c16dad18ae09e1e6440" translate="yes" xml:space="preserve">
          <source>ArgsOs::rfind</source>
          <target state="translated">ArgsOs::rfind</target>
        </trans-unit>
        <trans-unit id="2473c6d05109d83b7921dc7c8d9e3fd3e1540366" translate="yes" xml:space="preserve">
          <source>ArgsOs::rfold</source>
          <target state="translated">ArgsOs::rfold</target>
        </trans-unit>
        <trans-unit id="61e2d2493b8b480b1c184877bc7c4508f85f3e68" translate="yes" xml:space="preserve">
          <source>ArgsOs::rposition</source>
          <target state="translated">ArgsOs::rposition</target>
        </trans-unit>
        <trans-unit id="f7c9d7d4183c0e1185d8f756359b7aa52e99dec6" translate="yes" xml:space="preserve">
          <source>ArgsOs::scan</source>
          <target state="translated">ArgsOs::scan</target>
        </trans-unit>
        <trans-unit id="be9f72e6896d64043f92118bf0351dd06875451e" translate="yes" xml:space="preserve">
          <source>ArgsOs::size_hint</source>
          <target state="translated">ArgsOs::size_hint</target>
        </trans-unit>
        <trans-unit id="dfcbf514097e12c73f97a48d644499d52e01f449" translate="yes" xml:space="preserve">
          <source>ArgsOs::skip</source>
          <target state="translated">ArgsOs::skip</target>
        </trans-unit>
        <trans-unit id="b5cea38564a840936b5adf617a54cb9e1705e9a4" translate="yes" xml:space="preserve">
          <source>ArgsOs::skip_while</source>
          <target state="translated">ArgsOs::skip_while</target>
        </trans-unit>
        <trans-unit id="bd31eff15f1513280f3660b278f44b8403fe5bb7" translate="yes" xml:space="preserve">
          <source>ArgsOs::step_by</source>
          <target state="translated">ArgsOs::step_by</target>
        </trans-unit>
        <trans-unit id="b896b50f4e9946df9f811558add55e6c7f4d9c0e" translate="yes" xml:space="preserve">
          <source>ArgsOs::sum</source>
          <target state="translated">ArgsOs::sum</target>
        </trans-unit>
        <trans-unit id="55f7ee9ef7a277d1da50d3847c5267d10c02f3d6" translate="yes" xml:space="preserve">
          <source>ArgsOs::take</source>
          <target state="translated">ArgsOs::take</target>
        </trans-unit>
        <trans-unit id="67ae1d83993d54c201cebc7e961a4745875403a9" translate="yes" xml:space="preserve">
          <source>ArgsOs::take_while</source>
          <target state="translated">ArgsOs::take_while</target>
        </trans-unit>
        <trans-unit id="6feaa7bb16a2f86b2de35c4152c898840e5c73a7" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_fold</source>
          <target state="translated">ArgsOs::try_fold</target>
        </trans-unit>
        <trans-unit id="4de4927e12902d929342841a0f0a05adc02a2b88" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_for_each</source>
          <target state="translated">ArgsOs::try_for_each</target>
        </trans-unit>
        <trans-unit id="ef2e8777c2c6780af369e18d8923c4a5b07b73cc" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_from</source>
          <target state="translated">ArgsOs::try_from</target>
        </trans-unit>
        <trans-unit id="dde21f1986a82cfe6d32ebda71aaf8cffb865725" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_into</source>
          <target state="translated">ArgsOs::try_into</target>
        </trans-unit>
        <trans-unit id="752061f583e2a023f82e25f293fbc12638874e24" translate="yes" xml:space="preserve">
          <source>ArgsOs::try_rfold</source>
          <target state="translated">ArgsOs::try_rfold</target>
        </trans-unit>
        <trans-unit id="9cea18d9f52cf4e66c35caae6f3a3d7426f8ebf1" translate="yes" xml:space="preserve">
          <source>ArgsOs::type_id</source>
          <target state="translated">ArgsOs::type_id</target>
        </trans-unit>
        <trans-unit id="dcc7a51ed1d3dac6d37f7b6f7415fe425b54aac1" translate="yes" xml:space="preserve">
          <source>ArgsOs::unzip</source>
          <target state="translated">ArgsOs::unzip</target>
        </trans-unit>
        <trans-unit id="0477d6e4f174e07114d3143d029569031152c407" translate="yes" xml:space="preserve">
          <source>ArgsOs::zip</source>
          <target state="translated">ArgsOs::zip</target>
        </trans-unit>
        <trans-unit id="bd7faaad666e01c1bc85c0559542193db97f87bb" translate="yes" xml:space="preserve">
          <source>Argument and element separator</source>
          <target state="translated">인수와 요소 구분자</target>
        </trans-unit>
        <trans-unit id="0e653d9296c0f3183cfcfa59576a82649ae7862d" translate="yes" xml:space="preserve">
          <source>Argument types</source>
          <target state="translated">인수 유형</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="a3115a849e9a8fd08f66c020b31248aefac3bb62" translate="yes" xml:space="preserve">
          <source>Arguments for function calls</source>
          <target state="translated">함수 호출에 대한 인수</target>
        </trans-unit>
        <trans-unit id="60b48e4141151169e113485ecab80a4bb3c30bdc" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;ok_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;#method.ok_or_else&quot;&gt;&lt;code&gt;ok_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">&lt;code&gt;ok_or&lt;/code&gt; 에 전달 된 인수 는 간절히 평가됩니다. 함수 호출 결과를 전달하는 경우 지연 평가되는 &lt;a href=&quot;#method.ok_or_else&quot;&gt; &lt;code&gt;ok_or_else&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="b34ba4a25e5cb9253c52e9c96f12b4a3b5b442c1" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;#method.or_else&quot;&gt;&lt;code&gt;or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">인수 &lt;code&gt;or&lt;/code&gt; 전달 된 인수 는 간절히 평가됩니다. 함수 호출 결과를 전달하는 경우 지연 평가되는 &lt;a href=&quot;#method.or_else&quot;&gt; &lt;code&gt;or_else&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="81e7e0f40306bc29fb2793ce221652d077995d0b" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;unwrap_or&lt;/code&gt; are eagerly evaluated; if you are passing the result of a function call, it is recommended to use &lt;a href=&quot;#method.unwrap_or_else&quot;&gt;&lt;code&gt;unwrap_or_else&lt;/code&gt;&lt;/a&gt;, which is lazily evaluated.</source>
          <target state="translated">&lt;code&gt;unwrap_or&lt;/code&gt; 에 전달 된 인수 는 열성적으로 평가됩니다. 함수 호출 결과를 전달하는 경우 지연 평가되는 &lt;a href=&quot;#method.unwrap_or_else&quot;&gt; &lt;code&gt;unwrap_or_else&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="ca682bb604cd951faf7e687e9dc577ccfb4ccbcc" translate="yes" xml:space="preserve">
          <source>Arguments::borrow</source>
          <target state="translated">Arguments::borrow</target>
        </trans-unit>
        <trans-unit id="02b0d59380fa1adbbfa0a4e488839d014c6a84b9" translate="yes" xml:space="preserve">
          <source>Arguments::borrow_mut</source>
          <target state="translated">Arguments::borrow_mut</target>
        </trans-unit>
        <trans-unit id="beee63977406683694c63c877a281368e8498185" translate="yes" xml:space="preserve">
          <source>Arguments::clone</source>
          <target state="translated">Arguments::clone</target>
        </trans-unit>
        <trans-unit id="9b4336ed72fcc8790d465ff622f1ee33ef64dd5f" translate="yes" xml:space="preserve">
          <source>Arguments::clone_from</source>
          <target state="translated">Arguments::clone_from</target>
        </trans-unit>
        <trans-unit id="9f534ce31b28796358e33f058c8f30771441c413" translate="yes" xml:space="preserve">
          <source>Arguments::clone_into</source>
          <target state="translated">Arguments::clone_into</target>
        </trans-unit>
        <trans-unit id="e2264984672013569ff3cb5667d1fb059d3a9aff" translate="yes" xml:space="preserve">
          <source>Arguments::fmt</source>
          <target state="translated">Arguments::fmt</target>
        </trans-unit>
        <trans-unit id="e6967e42010df585387f1e1ee0a1ddd2861644a6" translate="yes" xml:space="preserve">
          <source>Arguments::from</source>
          <target state="translated">Arguments::from</target>
        </trans-unit>
        <trans-unit id="f7110cbfaa9d19f7a1a5d2f96c337419907bb156" translate="yes" xml:space="preserve">
          <source>Arguments::into</source>
          <target state="translated">Arguments::into</target>
        </trans-unit>
        <trans-unit id="f71fad745c8ecba4adbbf940ce0a934c1bbb9409" translate="yes" xml:space="preserve">
          <source>Arguments::to_owned</source>
          <target state="translated">Arguments::to_owned</target>
        </trans-unit>
        <trans-unit id="2f1106daf75575ebf9ff5096d88d4bd32bee8e3a" translate="yes" xml:space="preserve">
          <source>Arguments::to_string</source>
          <target state="translated">Arguments::to_string</target>
        </trans-unit>
        <trans-unit id="44514fad8f521c67acba588fe00d7592016a908f" translate="yes" xml:space="preserve">
          <source>Arguments::try_from</source>
          <target state="translated">Arguments::try_from</target>
        </trans-unit>
        <trans-unit id="8bb902c723ba932ded5aa3da8d68330e0bd8dfdd" translate="yes" xml:space="preserve">
          <source>Arguments::try_into</source>
          <target state="translated">Arguments::try_into</target>
        </trans-unit>
        <trans-unit id="93c384146f511c59251c10079f21618fcc345340" translate="yes" xml:space="preserve">
          <source>Arguments::type_id</source>
          <target state="translated">Arguments::type_id</target>
        </trans-unit>
        <trans-unit id="52ed5399cec328eed1c4d10b234f6d54945d8379" translate="yes" xml:space="preserve">
          <source>Arithmetic addition</source>
          <target state="translated">산술 덧셈</target>
        </trans-unit>
        <trans-unit id="b6a2b173c28c2d32e0f07c5865706f1a0af1dc82" translate="yes" xml:space="preserve">
          <source>Arithmetic addition and assignment</source>
          <target state="translated">산술 덧셈과 대입</target>
        </trans-unit>
        <trans-unit id="481206dd7e4055d67971a43266f17dd6c8acf74d" translate="yes" xml:space="preserve">
          <source>Arithmetic and Logical Binary Operators</source>
          <target state="translated">산술 및 논리 이진 연산자</target>
        </trans-unit>
        <trans-unit id="ba8c163933eb964b78854dfa7b1e1313a4ece109" translate="yes" xml:space="preserve">
          <source>Arithmetic and comparison operators on integers</source>
          <target state="translated">정수의 산술 및 비교 연산자</target>
        </trans-unit>
        <trans-unit id="3a2ccea0b8aef06fcf5a90ab7c705782be897b40" translate="yes" xml:space="preserve">
          <source>Arithmetic division</source>
          <target state="translated">산술 부서</target>
        </trans-unit>
        <trans-unit id="dfc8f592565726eb9a5251995ebe9c35af2683f2" translate="yes" xml:space="preserve">
          <source>Arithmetic division and assignment</source>
          <target state="translated">산술 나누기와 할당</target>
        </trans-unit>
        <trans-unit id="5e0f6d1b7afc18895e08ec06673e25445eca9bd9" translate="yes" xml:space="preserve">
          <source>Arithmetic multiplication</source>
          <target state="translated">산술 곱셈</target>
        </trans-unit>
        <trans-unit id="aed641007b737ba787b84c11db1a76f81a7265ec" translate="yes" xml:space="preserve">
          <source>Arithmetic multiplication and assignment</source>
          <target state="translated">산술 곱셈과 대입</target>
        </trans-unit>
        <trans-unit id="9501694b83625ba1c4c32e0300c7e3ef0ea5895a" translate="yes" xml:space="preserve">
          <source>Arithmetic negation</source>
          <target state="translated">산술 부정</target>
        </trans-unit>
        <trans-unit id="4b7e345ffd8cb02b4c25248f3c2916dd526e2269" translate="yes" xml:space="preserve">
          <source>Arithmetic remainder</source>
          <target state="translated">산술 나머지</target>
        </trans-unit>
        <trans-unit id="4af14fe332c2fec7e550537a659d27f7672cf52b" translate="yes" xml:space="preserve">
          <source>Arithmetic remainder and assignment</source>
          <target state="translated">산술 나머지 및 할당</target>
        </trans-unit>
        <trans-unit id="54604a8945847efcfbb8925458787851115f9296" translate="yes" xml:space="preserve">
          <source>Arithmetic subtraction</source>
          <target state="translated">산술 빼기</target>
        </trans-unit>
        <trans-unit id="40c2d180ceb1daebfda27a7dc052bf6e18437123" translate="yes" xml:space="preserve">
          <source>Arithmetic subtraction and assignment</source>
          <target state="translated">산술 빼기와 대입</target>
        </trans-unit>
        <trans-unit id="9d9b31e17e60151ad825cdde7693ca0fcca238c9" translate="yes" xml:space="preserve">
          <source>Arity</source>
          <target state="translated">Arity</target>
        </trans-unit>
        <trans-unit id="1fd516c87a7c389dccca9649a7b656d2f047d85d" translate="yes" xml:space="preserve">
          <source>Arity refers to the number of arguments a function or operator takes. For some examples, &lt;code&gt;f(2, 3)&lt;/code&gt; and &lt;code&gt;g(4, 6)&lt;/code&gt; have arity 2, while &lt;code&gt;h(8, 2, 6)&lt;/code&gt; has arity 3. The &lt;code&gt;!&lt;/code&gt; operator has arity 1.</source>
          <target state="translated">Arity는 함수 또는 연산자가 취하는 인수 수를 나타냅니다. 일부 예에서, &lt;code&gt;f(2, 3)&lt;/code&gt; 및 &lt;code&gt;g(4, 6)&lt;/code&gt; 은 arity 2를 갖는 반면 &lt;code&gt;h(8, 2, 6)&lt;/code&gt; 은 arity 3을 갖습니다. &lt;code&gt;!&lt;/code&gt; 연산자는 arity 1이 있습니다</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="e88a1d916bd09fa0781281dd0639410541b1c200" translate="yes" xml:space="preserve">
          <source>Array Layout</source>
          <target state="translated">배열 레이아웃</target>
        </trans-unit>
        <trans-unit id="811e7deb41b753134a124c771bc129d2aad4f69f" translate="yes" xml:space="preserve">
          <source>Array and array index expressions</source>
          <target state="translated">배열 및 배열 인덱스 표현식</target>
        </trans-unit>
        <trans-unit id="0844515b5a634fa1753332ae502ec5bc059c9bf4" translate="yes" xml:space="preserve">
          <source>Array and slice indexing expressions</source>
          <target state="translated">배열 및 슬라이스 인덱싱 표현식</target>
        </trans-unit>
        <trans-unit id="1c901b7185d5b71317418dac8afa7a9edb10a639" translate="yes" xml:space="preserve">
          <source>Array expression attributes</source>
          <target state="translated">배열 표현식 속성</target>
        </trans-unit>
        <trans-unit id="ff659441b84e2964045ca09a8c18a08d44b84a61" translate="yes" xml:space="preserve">
          <source>Array expressions</source>
          <target state="translated">배열 표현식</target>
        </trans-unit>
        <trans-unit id="b4a857fc21bf592938e9dd2ec1d467878b6cf83e" translate="yes" xml:space="preserve">
          <source>Array literal</source>
          <target state="translated">배열 리터럴</target>
        </trans-unit>
        <trans-unit id="4935b8502c9911035c4038af29553fcfde8b5706" translate="yes" xml:space="preserve">
          <source>Array literal containing &lt;code&gt;len&lt;/code&gt; copies of &lt;code&gt;expr&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt; 의 &lt;code&gt;len&lt;/code&gt; 사본을 포함하는 배열 리터럴</target>
        </trans-unit>
        <trans-unit id="235f924c7c3818aed78845bd2de8791d4d3ba101" translate="yes" xml:space="preserve">
          <source>Array literals with repeating syntax, where the array has type &lt;code&gt;[U; n]&lt;/code&gt;. The repeated sub-expression is a coercion site for coercion to type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">반복 구문이있는 배열 리터럴. 여기서 배열의 유형은 &lt;code&gt;[U; n]&lt;/code&gt; . 반복 된 하위-발현은 유형 &lt;code&gt;U&lt;/code&gt; 에 대한 강제에 대한 강제 사이트 이다.</target>
        </trans-unit>
        <trans-unit id="41d08ca772cf664e0e365d09949f5835931ea185" translate="yes" xml:space="preserve">
          <source>Array literals, where the array has type &lt;code&gt;[U; n]&lt;/code&gt;. Each sub-expression in the array literal is a coercion site for coercion to type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">배열이 &lt;code&gt;[U; n]&lt;/code&gt; . 배열 리터럴의 각 하위 표현식은 &lt;code&gt;U&lt;/code&gt; 형을 강제로 변환하는 강제 사이트입니다 .</target>
        </trans-unit>
        <trans-unit id="ea9dbd560327931c17a47c31880f0fcea2d052f4" translate="yes" xml:space="preserve">
          <source>Array to pointer cast</source>
          <target state="translated">포인터 캐스트에 대한 배열</target>
        </trans-unit>
        <trans-unit id="45de270a590c4d4b0320d8105310eb72bc4364df" translate="yes" xml:space="preserve">
          <source>Array type containing &lt;code&gt;len&lt;/code&gt; instances of &lt;code&gt;type&lt;/code&gt;</source>
          <target state="translated">유형의 &lt;code&gt;len&lt;/code&gt; 인스턴스를 포함하는 배열 &lt;code&gt;type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="51a7c3ed1d5f017cc725067fca3064cb604b7344" translate="yes" xml:space="preserve">
          <source>Array type length expressions</source>
          <target state="translated">배열 유형 길이 표현식</target>
        </trans-unit>
        <trans-unit id="ee988191e1f320445ced1a772858430505143153" translate="yes" xml:space="preserve">
          <source>Array types</source>
          <target state="translated">배열 유형</target>
        </trans-unit>
        <trans-unit id="51fa61d38d898a29b7f71e858ac412133bb4aa78" translate="yes" xml:space="preserve">
          <source>Array types, for all sizes, if the item type also implements &lt;code&gt;Clone&lt;/code&gt; (e.g., &lt;code&gt;[i32; 123456]&lt;/code&gt;)</source>
          <target state="translated">항목 유형이 &lt;code&gt;Clone&lt;/code&gt; 를 구현하는 경우 모든 크기에 대한 배열 유형 (예 : &lt;code&gt;[i32; 123456]&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c11c5b2f8cc2056c662bde9d8e7265077775fda2" translate="yes" xml:space="preserve">
          <source>Array types, for all sizes, if the item type also implements &lt;code&gt;Copy&lt;/code&gt; (e.g., &lt;code&gt;[i32; 123456]&lt;/code&gt;)</source>
          <target state="translated">항목 유형이 &lt;code&gt;Copy&lt;/code&gt; 를 구현하는 경우 모든 크기에 대한 배열 유형 (예 : &lt;code&gt;[i32; 123456]&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="aa557f1be66399eaf12f2be07d75660861cacf56" translate="yes" xml:space="preserve">
          <source>Arrays are laid out so that the &lt;code&gt;nth&lt;/code&gt; element of the array is offset from the start of the array by &lt;code&gt;n * the size of the type&lt;/code&gt; bytes. An array of &lt;code&gt;[T; n]&lt;/code&gt; has a size of &lt;code&gt;size_of::&amp;lt;T&amp;gt;() * n&lt;/code&gt; and the same alignment of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">배열의 &lt;code&gt;nth&lt;/code&gt; 요소가 배열의 시작에서 &lt;code&gt;n * the size of the type&lt;/code&gt; 바이트 의 크기 만큼 오프셋 되도록 배열이 배치됩니다 . 배열 &lt;code&gt;[T; n]&lt;/code&gt; 의 크기를 갖는 &lt;code&gt;size_of::&amp;lt;T&amp;gt;() * n&lt;/code&gt; 과 동일한 배향 &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02fe2a892020ef77103f56bebff06ee9353b3385" translate="yes" xml:space="preserve">
          <source>Arrays are useful when you want your data allocated on the stack rather than the heap (we will discuss the stack and the heap more in Chapter 4) or when you want to ensure you always have a fixed number of elements. An array isn&amp;rsquo;t as flexible as the vector type, though. A vector is a similar collection type provided by the standard library that &lt;em&gt;is&lt;/em&gt; allowed to grow or shrink in size. If you&amp;rsquo;re unsure whether to use an array or a vector, you should probably use a vector. Chapter 8 discusses vectors in more detail.</source>
          <target state="translated">배열은 힙이 아닌 스택에 데이터를 할당하려는 경우 (4 장에서 스택 및 힙에 대해 자세히 설명 할 것임) 또는 항상 고정 된 수의 요소가 있는지 확인하려는 경우에 유용합니다. 그러나 배열은 벡터 유형만큼 유연하지 않습니다. 벡터는 표준 라이브러리에서 제공하는 유사한 수집 유형 &lt;em&gt;입니다&lt;/em&gt; 성장 또는 크기 축소 할 수있었습니다. 배열을 사용할지 벡터를 사용할지 확실하지 않으면 벡터를 사용해야합니다. 8 장에서는 벡터에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="3b3785f54b6fb9b400ea9ab57c87c42e59186241" translate="yes" xml:space="preserve">
          <source>Arrays coerce to &lt;a href=&quot;primitive.slice&quot;&gt;slices (&lt;code&gt;[T]&lt;/code&gt;)&lt;/a&gt;, so a slice method may be called on an array. Indeed, this provides most of the API for working with arrays. Slices have a dynamic size and do not coerce to arrays.</source>
          <target state="translated">배열은 &lt;a href=&quot;primitive.slice&quot;&gt;슬라이스 ( &lt;code&gt;[T]&lt;/code&gt; )로&lt;/a&gt; 강제 변환 되므로 슬라이스에서 슬라이스 메소드를 호출 할 수 있습니다. 실제로 이것은 배열 작업을위한 대부분의 API를 제공합니다. 슬라이스는 동적 크기를 가지며 배열로 강제하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a5463b6c378c5a1ce536679177693788d8a488ef" translate="yes" xml:space="preserve">
          <source>Arrays of &lt;em&gt;any&lt;/em&gt; size are &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; if the element type is &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; if the element type is &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;. This works because &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; traits are specially known to the compiler.</source>
          <target state="translated">의 배열 &lt;em&gt;어떤&lt;/em&gt; 크기는 &lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 요소의 형태 인 경우 &lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 요소의 형태 인 경우 &lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; . 이것은 &lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 특성이 컴파일러에 특별히 알려져 있기 때문에 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="e22eb391f81362ae0eac8c4cd60b81a4562599d8" translate="yes" xml:space="preserve">
          <source>Arrays of sizes from 0 to 32 (inclusive) implement the following traits if the element type allows it:</source>
          <target state="translated">0에서 32까지의 크기의 배열 (포함)은 요소 유형이 허용하는 경우 다음 특성을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="2be2422a9ce4d7fe654319fa259c94897e3e7b46" translate="yes" xml:space="preserve">
          <source>As IANA assigns new addresses, this method will be updated. This may result in non-reserved addresses being treated as reserved in code that relies on an outdated version of this method.</source>
          <target state="translated">IANA가 새 주소를 할당하면이 방법이 업데이트됩니다. 이로 인해 예약되지 않은 주소가이 방법의 오래된 버전에 의존하는 코드에서 예약 된 것으로 취급 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e9f144fd6603397ae748bc2c2b95fde2038ac9c" translate="yes" xml:space="preserve">
          <source>As a companion to &lt;a href=&quot;trait.borrow&quot;&gt;&lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; this trait allows a type to borrow as an underlying type by providing a mutable reference. See &lt;a href=&quot;trait.borrow&quot;&gt;&lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; for more information on borrowing as another type.</source>
          <target state="translated">&lt;a href=&quot;trait.borrow&quot;&gt; &lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 의 동반자 로서이 특성은 유형이 변경 가능한 참조를 제공하여 기본 유형으로 빌릴 수 있도록합니다. 다른 유형으로 대출에 대한 자세한 내용 은 &lt;a href=&quot;trait.borrow&quot;&gt; &lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f044338e83e2522cd461ee6d84f7c5ea2e52e486" translate="yes" xml:space="preserve">
          <source>As a consequence, the hash map breaks if a &lt;code&gt;K&lt;/code&gt; wrapping a &lt;code&gt;Q&lt;/code&gt; value produces a different hash than &lt;code&gt;Q&lt;/code&gt;. For instance, imagine you have a type that wraps a string but compares ASCII letters ignoring their case:</source>
          <target state="translated">결과로서, 만약 해시 맵 나누기 &lt;code&gt;K&lt;/code&gt; 랩핑 &lt;code&gt;Q&lt;/code&gt; 의 값은 상이한 해시 생성 &lt;code&gt;Q&lt;/code&gt; 를 . 예를 들어, 문자열을 감싸지 만 대소 문자를 무시하고 ASCII 문자를 비교하는 유형이 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="21e6ec20b4bccf73414453b9c7ceac9ffa2614a2" translate="yes" xml:space="preserve">
          <source>As a data collection, &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt;&lt;/a&gt; owns both keys and values. If the key&amp;rsquo;s actual data is wrapped in a managing type of some kind, it should, however, still be possible to search for a value using a reference to the key&amp;rsquo;s data. For instance, if the key is a string, then it is likely stored with the hash map as a &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;, while it should be possible to search using a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;. Thus, &lt;code&gt;insert&lt;/code&gt; needs to operate on a &lt;code&gt;String&lt;/code&gt; while &lt;code&gt;get&lt;/code&gt; needs to be able to use a &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">데이터 수집으로서 &lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; &lt;/a&gt; 는 키와 값을 모두 소유합니다. 그러나 키의 실제 데이터가 일종의 관리 유형으로 래핑 된 경우 키 데이터에 대한 참조를 사용하여 값을 검색 할 수 있어야합니다. 예를 들어, 키가 문자열 인 경우 해시 맵과 함께 &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 으로 저장 될 가능성이 높으며 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 사용하여 검색 할 수 있습니다 . 따라서 &lt;code&gt;insert&lt;/code&gt; 는 &lt;code&gt;String&lt;/code&gt; 에서 작동해야 하지만 &lt;code&gt;get&lt;/code&gt; 은 &lt;code&gt;&amp;amp;str&lt;/code&gt; 을 사용할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="72b018e0e36049ad8edb2d9275fa43ffbd253ac2" translate="yes" xml:space="preserve">
          <source>As a first example of ownership, we&amp;rsquo;ll look at the &lt;em&gt;scope&lt;/em&gt; of some variables. A scope is the range within a program for which an item is valid. Let&amp;rsquo;s say we have a variable that looks like this:</source>
          <target state="translated">소유권의 첫 번째 예로, 일부 변수 의 &lt;em&gt;범위&lt;/em&gt; 를 살펴 보겠습니다 . 범위는 항목이 유효한 프로그램 내의 범위입니다. 다음과 같은 변수가 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="0024a0a24aed0a7ac58334f18eea8263ecf48ec1" translate="yes" xml:space="preserve">
          <source>As a language, Rust cares a &lt;em&gt;lot&lt;/em&gt; about the stability of your code. We want Rust to be a rock-solid foundation you can build on, and if things were constantly changing, that would be impossible. At the same time, if we can&amp;rsquo;t experiment with new features, we may not find out important flaws until after their release, when we can no longer change things.</source>
          <target state="translated">언어로서 Rust는 &lt;em&gt; 많은&lt;/em&gt; 코드의 안정성에 대한합니다. 우리는 Rust이 여러분이 지을 수있는 견고한 기반이되기를 원하며, 끊임없이 변화하고 있다면 불가능할 것입니다. 동시에, 새로운 기능을 시험해 볼 수 없다면, 출시 이후까지, 더 이상 변경할 수없는 중요한 결함을 찾지 못할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7163ba6f2bf3417c3c81c5ac8d3af7e28902510" translate="yes" xml:space="preserve">
          <source>As a library author, you should always prefer implementing &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; rather than &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/a&gt;, as &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.tryfrom&quot;&gt;&lt;code&gt;TryFrom&lt;/code&gt;&lt;/a&gt; provide greater flexibility and offer equivalent &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; implementations for free, thanks to a blanket implementation in the standard library. Only implement &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;trait.tryinto&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; when a conversion to a type outside the current crate is required.</source>
          <target state="translated">라이브러리 작성자 는 &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&lt;/code&gt; 이&lt;/a&gt; 더 큰 유연성을 제공하고 동등한 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; &lt;/a&gt; 구현을 무료로 제공하므로 항상 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&amp;lt;U&amp;gt;&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;trait.tryfrom&quot;&gt; &lt;code&gt;TryFrom&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 구현을 선호해야 합니다. 표준 라이브러리에서 담요 구현. 현재 상자 이외의 유형으로 변환해야 할 경우 에만 &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;trait.tryinto&quot;&gt; &lt;code&gt;TryInto&lt;/code&gt; 를&lt;/a&gt; 구현하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff562238e6519efc127fd0f82f8c3d4cbe94172e" translate="yes" xml:space="preserve">
          <source>As a more concise alternative, you can use a &lt;code&gt;for&lt;/code&gt; loop and execute some code for each item in a collection. A &lt;code&gt;for&lt;/code&gt; loop looks like the code in Listing 3-5.</source>
          <target state="translated">더 간결한 대안으로 &lt;code&gt;for&lt;/code&gt; 루프를 사용 하고 컬렉션의 각 항목에 대해 일부 코드를 실행할 수 있습니다 . &lt;code&gt;for&lt;/code&gt; 목록 3-5의 코드와 같은 루프 보인다.</target>
        </trans-unit>
        <trans-unit id="4b5b050c97f5fa423f8a999dca4b012b9c78134c" translate="yes" xml:space="preserve">
          <source>As a result of this code, &lt;code&gt;s&lt;/code&gt; will contain &lt;code&gt;lol&lt;/code&gt;.</source>
          <target state="translated">이 코드의 결과로 &lt;code&gt;s&lt;/code&gt; &lt;code&gt;lol&lt;/code&gt; 이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="0f98a89f1abd2dd1d5bfe499fd5b56372a5800c2" translate="yes" xml:space="preserve">
          <source>As a result, this method consider addresses such as &lt;code&gt;fe80:0:0:1::&lt;/code&gt; or &lt;code&gt;fe81::&lt;/code&gt; to be unicast link-local addresses, whereas &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt;&lt;code&gt;is_unicast_link_local_strict()&lt;/code&gt;&lt;/a&gt; does not. If you need a strict validation fully compliant with the RFC, use &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt;&lt;code&gt;is_unicast_link_local_strict()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">결과적으로이 방법은 &lt;code&gt;fe80:0:0:1::&lt;/code&gt; 또는 &lt;code&gt;fe81::&lt;/code&gt; 와 같은 주소 를 유니 캐스트 링크 로컬 주소로 &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt; &lt;code&gt;is_unicast_link_local_strict()&lt;/code&gt; &lt;/a&gt; 하지만 is_unicast_link_local_strict () 는 그렇지 않습니다. RFC를 완전히 준수하는 엄격한 유효성 검증이 필요한 경우 &lt;a href=&quot;struct.ipv6addr#method.is_unicast_link_local_strict&quot;&gt; &lt;code&gt;is_unicast_link_local_strict()&lt;/code&gt; &lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="486c7c23286a7b0e1299ccac2ee0a869b3e82ee5" translate="yes" xml:space="preserve">
          <source>As a string slice consists of a sequence of bytes, we can iterate through a string slice by byte. This method returns such an iterator.</source>
          <target state="translated">문자열 슬라이스는 일련의 바이트로 구성되므로 문자열 슬라이스를 바이트 단위로 반복 할 수 있습니다. 이 메소드는 그러한 반복자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="13230333554cf4f41cab6ad4fc5190eeee2538f2" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns an iterator of both these &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, as well as their byte positions.</source>
          <target state="translated">문자열 슬라이스는 유효한 UTF-8로 구성되므로 &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 별로 문자열 슬라이스를 반복 할 수 있습니다 . 이 메소드는이 &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 와 바이트 위치 의 반복자를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="437cfa80202d923ee25f6cf5ad0fd2f02cfb01ea" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns such an iterator.</source>
          <target state="translated">문자열 슬라이스는 유효한 UTF-8로 구성되므로 &lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 별로 문자열 슬라이스를 반복 할 수 있습니다 . 이 메소드는 그러한 반복자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="fb40adb4e231d6bdd9f0bd0f9320f4357a2e82ae" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns an iterator of both these &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s, as well as their byte positions.</source>
          <target state="translated">문자열 슬라이스는 유효한 UTF-8로 구성되므로 &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 별로 문자열 슬라이스를 반복 할 수 있습니다 . 이 메소드는이 &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 와 바이트 위치 의 반복자를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="bf66f1c269d4394c9cb4445fd4fd600e640f2992" translate="yes" xml:space="preserve">
          <source>As a string slice consists of valid UTF-8, we can iterate through a string slice by &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;. This method returns such an iterator.</source>
          <target state="translated">문자열 슬라이스는 유효한 UTF-8로 구성되므로 &lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 별로 문자열 슬라이스를 반복 할 수 있습니다 . 이 메소드는 그러한 반복자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b4d78aa978dc16456ba4fafe0a526ad6183e3881" translate="yes" xml:space="preserve">
          <source>As always, remember that a human intuition for 'character' may not map to Unicode's definitions. For example, despite looking similar, the '&amp;eacute;' character is one Unicode code point while 'é' is two Unicode code points:</source>
          <target state="translated">항상 그렇듯이 '문자'에 대한 인간의 직감은 유니 코드의 정의에 매핑되지 않을 수 있습니다. 예를 들어, 비슷한 모양에도 불구하고 '&amp;eacute;'문자는 하나의 유니 코드 코드 포인트이고 '&amp;eacute;'는 두 개의 유니 코드 코드 포인트입니다.</target>
        </trans-unit>
        <trans-unit id="8d82369403176e5c690373478594ff76e764a9ef" translate="yes" xml:space="preserve">
          <source>As always, we can use curly brackets to create a new scope, allowing for multiple mutable references, just not &lt;em&gt;simultaneous&lt;/em&gt; ones:</source>
          <target state="translated">언제나처럼 중괄호를 사용하여 새 범위를 만들어 &lt;em&gt;동시&lt;/em&gt; 참조가 아닌 여러 개의 가변 참조를 허용 할 &lt;em&gt;수&lt;/em&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5be02ef05f525885a914931855842d0bd0941ea" translate="yes" xml:space="preserve">
          <source>As an example of how to use a mutex, let&amp;rsquo;s start by using a mutex in a single-threaded context, as shown in Listing 16-12:</source>
          <target state="translated">뮤텍스를 사용하는 방법의 예로써, Listing 16-12와 같이 단일 스레드 컨텍스트에서 뮤텍스를 사용하여 시작해 보자.</target>
        </trans-unit>
        <trans-unit id="0a2b1532710f708a62d9bd14aa059c7176218c09" translate="yes" xml:space="preserve">
          <source>As an example of methods on a trait, consider the following:</source>
          <target state="translated">특성에 대한 방법의 예로 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="46ce22c9bcccaee92580f06aedfeeb7db04850fe" translate="yes" xml:space="preserve">
          <source>As an example of where you could use either a closure defined inline or a named function, let&amp;rsquo;s look at a use of &lt;code&gt;map&lt;/code&gt;. To use the &lt;code&gt;map&lt;/code&gt; function to turn a vector of numbers into a vector of strings, we could use a closure, like this:</source>
          <target state="translated">인라인으로 정의 된 클로저 또는 명명 된 함수를 사용할 수있는 위치의 예로 &lt;code&gt;map&lt;/code&gt; 사용을 살펴 보겠습니다 . &lt;code&gt;map&lt;/code&gt; 함수 를 사용하여 숫자 벡터를 문자열 벡터로 바꾸려면 다음과 같이 클로저를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37540a09808abda7d1579f892bfd40fb102faf8d" translate="yes" xml:space="preserve">
          <source>As an example, Listing 11-10 has a silly function that prints the value of its parameter and returns 10, as well as a test that passes and a test that fails.</source>
          <target state="translated">예를 들어, 목록 11-10에는 매개 변수의 값을 인쇄하고 10을 반환하는 바보 함수와 통과 테스트 및 실패 테스트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="53691b327422875e6972393627946b878398498e" translate="yes" xml:space="preserve">
          <source>As an example, a macro matcher like &lt;code&gt;$i:expr [ , ]&lt;/code&gt; could in theory be accepted in Rust today, since &lt;code&gt;[,]&lt;/code&gt; cannot be part of a legal expression and therefore the parse would always be unambiguous. However, because &lt;code&gt;[&lt;/code&gt; can start trailing expressions, &lt;code&gt;[&lt;/code&gt; is not a character which can safely be ruled out as coming after an expression. If &lt;code&gt;[,]&lt;/code&gt; were accepted in a later version of Rust, this matcher would become ambiguous or would misparse, breaking working code. Matchers like &lt;code&gt;$i:expr,&lt;/code&gt; or &lt;code&gt;$i:expr;&lt;/code&gt; would be legal, however, because &lt;code&gt;,&lt;/code&gt; and &lt;code&gt;;&lt;/code&gt; are legal expression separators. The specific rules are:</source>
          <target state="translated">예를 들어, &lt;code&gt;$i:expr [ , ]&lt;/code&gt; 와 같은 매크로 매처 는 이론적으로 Rust에서 받아 들일 수 있습니다. &lt;code&gt;[,]&lt;/code&gt; 는 합법적 인 표현의 일부가 될 수 없기 때문에 구문 분석은 항상 모호하지 않습니다. 때문에, &lt;code&gt;[&lt;/code&gt; 이 표현을 후행 시작할 수 있습니다, &lt;code&gt;[&lt;/code&gt; 안전 식 후에 들어오는 배제 할 수있는 문자가 아닙니다. 경우 &lt;code&gt;[,]&lt;/code&gt; 녹 이후 버전에서 사용 가능하고,이 정규 모호한 될 것 또는 작동 코드를 깨는, misparse 것입니다. &lt;code&gt;$i:expr,&lt;/code&gt; 또는 &lt;code&gt;$i:expr;&lt;/code&gt; 과 같은 매처 ; 법적 것이다, 그러나 때문에 &lt;code&gt;,&lt;/code&gt; 그리고 &lt;code&gt;;&lt;/code&gt; 합법적 인 구분 기호입니다. 구체적인 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3c5226f2d8790540dbbe88f9ad68f2409b55a32e" translate="yes" xml:space="preserve">
          <source>As an example, change the &lt;em&gt;src/main.rs&lt;/em&gt; file in your &lt;em&gt;loops&lt;/em&gt; directory to look like this:</source>
          <target state="translated">예를 들어, &lt;em&gt;loops&lt;/em&gt; 디렉토리 에서 &lt;em&gt;src / main.rs&lt;/em&gt; 파일 을 다음과 같이 변경하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7f0fd43eedc8fb375dd6813798e9b7e3996a0f09" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s change one of our enum variants to hold data inside it. From 1999 through 2008, the United States minted quarters with different designs for each of the 50 states on one side. No other coins got state designs, so only quarters have this extra value. We can add this information to our &lt;code&gt;enum&lt;/code&gt; by changing the &lt;code&gt;Quarter&lt;/code&gt; variant to include a &lt;code&gt;UsState&lt;/code&gt; value stored inside it, which we&amp;rsquo;ve done here in Listing 6-4.</source>
          <target state="translated">예를 들어, 열거 형 변형 중 하나를 변경하여 내부에 데이터를 보유합시다. 1999 년부터 2008 년까지 미국은 한쪽에 50 개 주마다 각기 다른 디자인으로 분기를 기록했습니다. 다른 동전은 국가 디자인을 얻지 못 했으므로 1/4만이 추가 가치를 갖습니다. 우리는 &lt;code&gt;Quarter&lt;/code&gt; 변형을 수정하여 &lt;code&gt;UsState&lt;/code&gt; 안에 저장된 UsState 값 을 포함 시킴으로써이 정보를 &lt;code&gt;enum&lt;/code&gt; 에 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d430493784bb7c38b9bfd2132c640f18ef8a2cfc" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s say we want to implement &lt;code&gt;Display&lt;/code&gt; on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, which the orphan rule prevents us from doing directly because the &lt;code&gt;Display&lt;/code&gt; trait and the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type are defined outside our crate. We can make a &lt;code&gt;Wrapper&lt;/code&gt; struct that holds an instance of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;; then we can implement &lt;code&gt;Display&lt;/code&gt; on &lt;code&gt;Wrapper&lt;/code&gt; and use the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; value, as shown in Listing 19-23.</source>
          <target state="translated">예를 들어, &lt;code&gt;Display&lt;/code&gt; 특성과 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 유형이 상자 외부에 정의되어 있기 때문에 고아 규칙으로 인해 직접 수행 할 수없는 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 에 &lt;code&gt;Display&lt;/code&gt; 를 구현하려고한다고 가정하겠습니다 . &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 인스턴스를 보유하는 &lt;code&gt;Wrapper&lt;/code&gt; 구조체를 만들 수 있습니다 . 그런 다음 &lt;code&gt;Display&lt;/code&gt; on &lt;code&gt;Wrapper&lt;/code&gt; 를 구현 하고 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 값을 사용할 수 있습니다 ( Listing 19-23).</target>
        </trans-unit>
        <trans-unit id="0a293358ddd19b42df03eeb78c691469d4c0e122" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s write a library crate that provides the functionality of a restaurant. We&amp;rsquo;ll define the signatures of functions but leave their bodies empty to concentrate on the organization of the code, rather than actually implement a restaurant in code.</source>
          <target state="translated">예를 들어 식당의 기능을 제공하는 라이브러리 상자를 작성해 봅시다. 함수의 시그니처를 정의하지만 실제로 코드로 레스토랑을 구현하는 대신 코드 구성에 집중하기 위해 본문을 비워 두십시오.</target>
        </trans-unit>
        <trans-unit id="5e1d4bdb076d3e495d340c82a90a7bc9edd4704c" translate="yes" xml:space="preserve">
          <source>As an example, rather than using a list whose items know only about the next item, we&amp;rsquo;ll create a tree whose items know about their children items &lt;em&gt;and&lt;/em&gt; their parent items.</source>
          <target state="translated">예를 들어 다음 항목에 대해서만 항목을 알고있는 목록을 사용하는 대신 하위 항목 &lt;em&gt;과&lt;/em&gt; 부모 항목에 대해 항목을 알고있는 트리를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="84057f7bc04baf2d73dfbd111ea89a20d0d17089" translate="yes" xml:space="preserve">
          <source>As an example, recall the &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt; marker traits we discussed in the &lt;a href=&quot;ch16-04-extensible-concurrency-sync-and-send#extensible-concurrency-with-the-sync-and-send-traits&quot;&gt;&amp;ldquo;Extensible Concurrency with the &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt; Traits&amp;rdquo;&lt;/a&gt; section in Chapter 16: the compiler implements these traits automatically if our types are composed entirely of &lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; types. If we implement a type that contains a type that is not &lt;code&gt;Send&lt;/code&gt; or &lt;code&gt;Sync&lt;/code&gt;, such as raw pointers, and we want to mark that type as &lt;code&gt;Send&lt;/code&gt; or &lt;code&gt;Sync&lt;/code&gt;, we must use &lt;code&gt;unsafe&lt;/code&gt;. Rust can&amp;rsquo;t verify that our type upholds the guarantees that it can be safely sent across threads or accessed from multiple threads; therefore, we need to do those checks manually and indicate as such with &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 16 장의 &lt;a href=&quot;ch16-04-extensible-concurrency-sync-and-send#extensible-concurrency-with-the-sync-and-send-traits&quot;&gt;&quot; &lt;/a&gt; &lt;code&gt;Sync&lt;/code&gt; 및 &lt;code&gt;Send&lt;/code&gt; 특성 과의 확장 성 동시성 &quot; 섹션에서 논의한 &lt;code&gt;Sync&lt;/code&gt; 및 &lt;code&gt;Send&lt;/code&gt; 마커 특성을 기억하십시오 . 유형이 전체적으로 &lt;code&gt;Send&lt;/code&gt; 및 &lt;code&gt;Sync&lt;/code&gt; 유형 으로 구성된 경우 컴파일러는 이러한 특성을 자동으로 구현 합니다. 원시 포인터와 같이 &lt;code&gt;Send&lt;/code&gt; 또는 &lt;code&gt;Sync&lt;/code&gt; 가 아닌 유형을 포함하는 유형을 구현하고 해당 유형을 &lt;code&gt;Send&lt;/code&gt; 또는 &lt;code&gt;Sync&lt;/code&gt; 로 표시 하려면 &lt;code&gt;unsafe&lt;/code&gt; 것을 사용해야합니다. Rust는 우리 유형이 스레드간에 안전하게 전송되거나 여러 스레드에서 액세스 될 수 있음을 보증하는지 확인할 수 없습니다. 따라서 이러한 검사를 수동으로 수행하고 &lt;code&gt;unsafe&lt;/code&gt; 로 표시해야합니다 .</target>
        </trans-unit>
        <trans-unit id="38a88a1bad47211ae1a10e5bfcee84726e1f325e" translate="yes" xml:space="preserve">
          <source>As an example, say we write a function called &lt;code&gt;add_two&lt;/code&gt; that adds 2 to whatever number is passed to it. This function&amp;rsquo;s signature accepts an integer as a parameter and returns an integer as a result. When we implement and compile that function, Rust does all the type checking and borrow checking that you&amp;rsquo;ve learned so far to ensure that, for instance, we aren&amp;rsquo;t passing a &lt;code&gt;String&lt;/code&gt; value or an invalid reference to this function. But Rust &lt;em&gt;can&amp;rsquo;t&lt;/em&gt; check that this function will do precisely what we intend, which is return the parameter plus 2 rather than, say, the parameter plus 10 or the parameter minus 50! That&amp;rsquo;s where tests come in.</source>
          <target state="translated">예를 들어, 전달 된 숫자에 2를 더하는 &lt;code&gt;add_two&lt;/code&gt; 라는 함수를 작성한다고 가정 하십시오. 이 함수의 서명은 정수를 매개 변수로 승인하고 결과로 정수를 리턴합니다. 해당 함수를 구현하고 컴파일 할 때 Rust는 예를 들어이 함수에 대한 &lt;code&gt;String&lt;/code&gt; 값이나 잘못된 참조를 전달하지 않도록하기 위해 지금까지 배운 모든 유형 검사 및 대출 검사를 수행합니다. 그러나 Rust &lt;em&gt;는&lt;/em&gt; 이 함수가 우리가 의도 한대로 정확하게 수행하는지 확인할 &lt;em&gt;수 없습니다&lt;/em&gt; . 즉, 매개 변수 더하기 10 또는 매개 변수 빼기 50 대신 매개 변수 더하기 2를 반환합니다! 그곳에서 테스트가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="0c46b40f3e5f774d5bd6d946904f04146f347849" translate="yes" xml:space="preserve">
          <source>As an example, the pattern &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; and the haystack &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; might produce the stream &lt;code&gt;[Reject(0, 1), Reject(1, 2), Match(2, 5), Reject(5, 8)]&lt;/code&gt;</source>
          <target state="translated">예를 들어, 패턴 &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; 및 건초 더미 &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; 는 스트림 &lt;code&gt;[Reject(0, 1), Reject(1, 2), Match(2, 5), Reject(5, 8)]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f6b604f8510907ca9fe9178dfcf2a6874e95e6b5" translate="yes" xml:space="preserve">
          <source>As an example, the pattern &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; and the haystack &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; might produce the stream &lt;code&gt;[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]&lt;/code&gt;</source>
          <target state="translated">예를 들어, 패턴 &lt;code&gt;&quot;aaa&quot;&lt;/code&gt; 및 건초 더미 &lt;code&gt;&quot;cbaaaaab&quot;&lt;/code&gt; 는 스트림 &lt;code&gt;[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="877bff60769fbc36114e44fb0843def0fdaa302f" translate="yes" xml:space="preserve">
          <source>As an iterator:</source>
          <target state="translated">반복자로서 :</target>
        </trans-unit>
        <trans-unit id="04b8526b20e002ad597cb978c8868c4ab1a90f67" translate="yes" xml:space="preserve">
          <source>As another example, suppose we have a &lt;code&gt;Maker&lt;/code&gt; trait and want to establish a type &lt;code&gt;FooMaker&lt;/code&gt; that makes &lt;code&gt;Foo&lt;/code&gt;s:</source>
          <target state="translated">또 다른 예로, &lt;code&gt;Maker&lt;/code&gt; 특성이 있고 &lt;code&gt;Foo&lt;/code&gt; 를 만드는 &lt;code&gt;FooMaker&lt;/code&gt; 유형을 설정하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="5213c1c4f3b10c9c56042b19c8c0157b715adba7" translate="yes" xml:space="preserve">
          <source>As another example, the following code is taken from an audio decoder. The decoding algorithm uses the linear prediction mathematical operation to estimate future values based on a linear function of the previous samples. This code uses an iterator chain to do some math on three variables in scope: a &lt;code&gt;buffer&lt;/code&gt; slice of data, an array of 12 &lt;code&gt;coefficients&lt;/code&gt;, and an amount by which to shift data in &lt;code&gt;qlp_shift&lt;/code&gt;. We&amp;rsquo;ve declared the variables within this example but not given them any values; although this code doesn&amp;rsquo;t have much meaning outside of its context, it&amp;rsquo;s still a concise, real-world example of how Rust translates high-level ideas to low-level code.</source>
          <target state="translated">다른 예로서, 다음 코드는 오디오 디코더로부터 취해진 다. 디코딩 알고리즘은 선형 예측 수학 연산을 사용하여 이전 샘플의 선형 함수에 기초하여 미래 값을 추정한다. 이 코드는 반복자 체인을 사용하여 데이터 의 &lt;code&gt;buffer&lt;/code&gt; 슬라이스, 12 개의 &lt;code&gt;coefficients&lt;/code&gt; 배열 및 &lt;code&gt;qlp_shift&lt;/code&gt; 에서 데이터를 이동시키는 양의 세 가지 변수에 대해 수학을 수행 합니다. 이 예제에서 변수를 선언했지만 값을 지정하지 않았습니다. 이 코드는 컨텍스트 외부에서 별 의미가 없지만 Rust가 높은 수준의 아이디어를 낮은 수준의 코드로 변환하는 방법에 대한 간결하고 실제적인 예입니다.</target>
        </trans-unit>
        <trans-unit id="ceca2c634722fa77d0d672657c5578a7251142a0" translate="yes" xml:space="preserve">
          <source>As described, &lt;a href=&quot;../i32/index&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; implements &lt;code&gt;TryFrom&amp;lt;i64&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">설명한대로 &lt;a href=&quot;../i32/index&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;TryFrom&amp;lt;i64&amp;gt;&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="0958482afe9fd3c8317c6c0d343e311be75015c7" translate="yes" xml:space="preserve">
          <source>As discussed in Chapter 10, to implement a trait, we need to provide implementations for the trait&amp;rsquo;s required methods. The &lt;code&gt;Deref&lt;/code&gt; trait, provided by the standard library, requires us to implement one method named &lt;code&gt;deref&lt;/code&gt; that borrows &lt;code&gt;self&lt;/code&gt; and returns a reference to the inner data. Listing 15-10 contains an implementation of &lt;code&gt;Deref&lt;/code&gt; to add to the definition of &lt;code&gt;MyBox&lt;/code&gt;:</source>
          <target state="translated">10 장에서 논의한 것처럼 특성을 구현하려면 특성의 필수 메소드에 대한 구현을 제공해야합니다. &lt;code&gt;Deref&lt;/code&gt; 특성, 표준 라이브러리에서 제공하는이라는 하나의 방법 구현하기 위해 우리를 필요로 &lt;code&gt;deref&lt;/code&gt; 그 차용의 &lt;code&gt;self&lt;/code&gt; 반환 내부 데이터에 대한 참조를. Listing 15-10에는 &lt;code&gt;MyBox&lt;/code&gt; 정의에 추가하기위한 &lt;code&gt;Deref&lt;/code&gt; 구현이 포함되어있다 .</target>
        </trans-unit>
        <trans-unit id="d5f5ed3e00ea3332f0559aed11908528d1ba499a" translate="yes" xml:space="preserve">
          <source>As discussed in Chapter 17, the &lt;code&gt;take&lt;/code&gt; method on &lt;code&gt;Option&lt;/code&gt; takes the &lt;code&gt;Some&lt;/code&gt; variant out and leaves &lt;code&gt;None&lt;/code&gt; in its place. We&amp;rsquo;re using &lt;code&gt;if let&lt;/code&gt; to destructure the &lt;code&gt;Some&lt;/code&gt; and get the thread; then we call &lt;code&gt;join&lt;/code&gt; on the thread. If a worker&amp;rsquo;s thread is already &lt;code&gt;None&lt;/code&gt;, we know that worker has already had its thread cleaned up, so nothing happens in that case.</source>
          <target state="translated">17 장에서 논의한 것처럼 &lt;code&gt;Option&lt;/code&gt; 의 &lt;code&gt;take&lt;/code&gt; 메소드 는 &lt;code&gt;Some&lt;/code&gt; 변형을 제거하고 대신 &lt;code&gt;None&lt;/code&gt; 을 남겨 둡니다 . 우리가 사용하고있는 &lt;code&gt;if let&lt;/code&gt; destructure하기 위해 &lt;code&gt;Some&lt;/code&gt; 및 스레드를 얻을; 그런 다음 스레드에서 &lt;code&gt;join&lt;/code&gt; 을 호출 합니다. 워커의 스레드가 이미 &lt;code&gt;None&lt;/code&gt; 이면 워커가 이미 스레드를 정리했음을 알 수 있으므로이 경우 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9fd5d9a215556134ab45028a161d57190ff678d3" translate="yes" xml:space="preserve">
          <source>As discussed in Chapter 6, we use patterns in the arms of &lt;code&gt;match&lt;/code&gt; expressions. Formally, &lt;code&gt;match&lt;/code&gt; expressions are defined as the keyword &lt;code&gt;match&lt;/code&gt;, a value to match on, and one or more match arms that consist of a pattern and an expression to run if the value matches that arm&amp;rsquo;s pattern, like this:</source>
          <target state="translated">6 장에서 논의한 바와 같이, 우리는 &lt;code&gt;match&lt;/code&gt; 표현에 패턴을 사용 합니다. 공식적으로 &lt;code&gt;match&lt;/code&gt; 표현식은 키워드 &lt;code&gt;match&lt;/code&gt; , 일치 할 값 및 패턴으로 구성된 하나 이상의 일치 암 및 값이 해당 팔의 패턴과 일치하는 경우 실행할 식으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="b597a68d9b285f7d308e42a0c9a8b37ad1bf7193" translate="yes" xml:space="preserve">
          <source>As for what happens behind the scenes, when optimizations are enabled the final generated machine code might look very different from the code:</source>
          <target state="translated">배후에서 일어나는 일에 대해 최적화가 활성화되면 최종 생성 된 기계 코드가 코드와 매우 다르게 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7061cd66862cc7d4e84cb20891d413f4dbad19d" translate="yes" xml:space="preserve">
          <source>As functions, they must either return syntax, panic, or loop endlessly. Returned syntax either replaces or adds the syntax depending on the kind of procedural macro. Panics are caught by the compiler and are turned into a compiler error. Endless loops are not caught by the compiler which hangs the compiler.</source>
          <target state="translated">함수로서, 구문, 패닉 또는 루프를 끝없이 리턴해야합니다. 반환 된 구문은 절차 적 매크로의 종류에 따라 구문을 대체하거나 추가합니다. 패닉은 컴파일러에 의해 포착되어 컴파일러 오류로 바뀝니다. 컴파일러를 중단시키는 컴파일러는 무한 루프를 포착하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fd8f9685a0be8d16b4d260e66976648f0f435f12" translate="yes" xml:space="preserve">
          <source>As humans, we can look at this code and see that &lt;code&gt;string1&lt;/code&gt; is longer than &lt;code&gt;string2&lt;/code&gt; and therefore &lt;code&gt;result&lt;/code&gt; will contain a reference to &lt;code&gt;string1&lt;/code&gt;. Because &lt;code&gt;string1&lt;/code&gt; has not gone out of scope yet, a reference to &lt;code&gt;string1&lt;/code&gt; will still be valid for the &lt;code&gt;println!&lt;/code&gt; statement. However, the compiler can&amp;rsquo;t see that the reference is valid in this case. We&amp;rsquo;ve told Rust that the lifetime of the reference returned by the &lt;code&gt;longest&lt;/code&gt; function is the same as the smaller of the lifetimes of the references passed in. Therefore, the borrow checker disallows the code in Listing 10-24 as possibly having an invalid reference.</source>
          <target state="translated">인간으로서 우리는이 코드를보고 &lt;code&gt;string1&lt;/code&gt; 이 &lt;code&gt;string2&lt;/code&gt; 보다 길 므로 &lt;code&gt;result&lt;/code&gt; 에 &lt;code&gt;string1&lt;/code&gt; 에 대한 참조가 포함된다는 것을 알 수 있습니다 . 때문에 &lt;code&gt;string1&lt;/code&gt; 아직 범위 밖으로 사라하지 않았에 대한 참조 &lt;code&gt;string1&lt;/code&gt; 여전히 유효합니다 &lt;code&gt;println!&lt;/code&gt; 성명서. 그러나 컴파일러는이 경우 참조가 유효한지 확인할 수 없습니다. 우리는 Rust에게 &lt;code&gt;longest&lt;/code&gt; 함수에 의해 리턴 된 참조 의 수명은 전달 된 참조의 수명보다 작은 것과 동일 하다고 이야기 했다. 따라서 빌림 검사기는 Listing 10-24의 코드가 유효하지 않은 참조를 갖는 것을 허용하지 않는다 .</target>
        </trans-unit>
        <trans-unit id="6d9f4910be4026effcf198634df42e1c4041dff1" translate="yes" xml:space="preserve">
          <source>As in most other programming languages, a Boolean type in Rust has two possible values: &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. Booleans are one byte in size. The Boolean type in Rust is specified using &lt;code&gt;bool&lt;/code&gt;. For example:</source>
          <target state="translated">대부분의 다른 프로그래밍 언어와 마찬가지로 Rust의 부울 형식에는 &lt;code&gt;true&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 의 두 가지 가능한 값이 있습니다. 부울의 크기는 1 바이트입니다. Rust의 부울 유형은 &lt;code&gt;bool&lt;/code&gt; 을 사용하여 지정됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a025b290deb94845050bfa62909fd15fe5ae74be" translate="yes" xml:space="preserve">
          <source>As long as your command line parsing logic is small, it can remain in &lt;em&gt;main.rs&lt;/em&gt;.</source>
          <target state="translated">명령 줄 구문 분석 논리가 작 으면 &lt;em&gt;main.rs에&lt;/em&gt; 남아있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8323a3696731d93f0a84dafc08f2d32df5ef0903" translate="yes" xml:space="preserve">
          <source>As mentioned at the start of the chapter, testing is a complex discipline, and different people use different terminology and organization. The Rust community thinks about tests in terms of two main categories: &lt;em&gt;unit tests&lt;/em&gt; and &lt;em&gt;integration tests&lt;/em&gt;. Unit tests are small and more focused, testing one module in isolation at a time, and can test private interfaces. Integration tests are entirely external to your library and use your code in the same way any other external code would, using only the public interface and potentially exercising multiple modules per test.</source>
          <target state="translated">이 장의 시작 부분에서 언급했듯이 테스트는 복잡한 학문이며 다른 사람들은 다른 용어와 조직을 사용합니다. Rust 커뮤니티는 두 가지 주요 범주 인 &lt;em&gt;단위 테스트&lt;/em&gt; 와 &lt;em&gt;통합 테스트&lt;/em&gt; 측면에서 테스트에 대해 생각 &lt;em&gt;합니다&lt;/em&gt; . 단위 테스트는 작고 집중적이며 한 번에 하나의 모듈을 개별적으로 테스트하며 개인 인터페이스를 테스트 할 수 있습니다. 통합 테스트는 전적으로 라이브러리 외부에 있으며 공용 인터페이스 만 사용하고 테스트 당 여러 모듈을 사용하는 다른 외부 코드와 같은 방식으로 코드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="10eda87545057c2aa683c0bbfe8990122953ece6" translate="yes" xml:space="preserve">
          <source>As mentioned before, trait objects contain pointers to method tables. So, if we have:</source>
          <target state="translated">앞에서 언급했듯이 특성 오브젝트에는 메소드 테이블에 대한 포인터가 포함되어 있습니다. 우리가 가지고 있다면 :</target>
        </trans-unit>
        <trans-unit id="4761017ad6dee318134842b138bc05d35199a594" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, &lt;code&gt;read_line&lt;/code&gt; puts what the user types into the string we&amp;rsquo;re passing it, but it also returns a value&amp;mdash;in this case, an &lt;a href=&quot;../std/io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;. Rust has a number of types named &lt;code&gt;Result&lt;/code&gt; in its standard library: a generic &lt;a href=&quot;../std/result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; as well as specific versions for submodules, such as &lt;code&gt;io::Result&lt;/code&gt;.</source>
          <target state="translated">앞에서 언급했듯이 &lt;code&gt;read_line&lt;/code&gt; 은 사용자가 입력 한 내용을 전달하는 문자열에 넣지 만 값 (이 경우 &lt;a href=&quot;../std/io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; 반환합니다 . 녹 명명 된 유형의 수 있습니다 &lt;code&gt;Result&lt;/code&gt; 일반 : 표준 라이브러리의 &lt;a href=&quot;../std/result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 뿐만 아니라 다음과 같은 하위 모듈에 대한 특정 버전, &lt;code&gt;io::Result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f7435a393907a8b1c4a2fc1b69a43772076a5c5" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, because very little of how Rust handles concurrency is part of the language, many concurrency solutions are implemented as crates. These evolve more quickly than the standard library, so be sure to search online for the current, state-of-the-art crates to use in multithreaded situations.</source>
          <target state="translated">앞에서 언급했듯이 Rust가 동시성을 처리하는 방법은 거의 없기 때문에 많은 동시성 솔루션이 상자로 구현됩니다. 이들은 표준 라이브러리보다 더 빠르게 발전하므로 멀티 스레드 상황에서 사용할 최신의 최신 상자를 온라인으로 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="a6f8e14141b394aeafb54cb0af5563e56c04e70c" translate="yes" xml:space="preserve">
          <source>As mentioned in Chapter 2, by default variables are immutable. This is one of many nudges Rust gives you to write your code in a way that takes advantage of the safety and easy concurrency that Rust offers. However, you still have the option to make your variables mutable. Let&amp;rsquo;s explore how and why Rust encourages you to favor immutability and why sometimes you might want to opt out.</source>
          <target state="translated">2 장에서 언급했듯이 기본적으로 변수는 변경할 수 없습니다. 이것은 Rust가 제공하는 안전하고 쉬운 동시성을 활용하는 방식으로 코드를 작성하기 위해 Rust가 제공하는 많은 넛지 중 하나입니다. 그러나 변수를 변경할 수있는 옵션이 여전히 있습니다. Rust가 불변성을 선호하는 방법과 이유, 왜 선택하지 않는지를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="7641c8a38df92f9203220e805ba01b7f30732a0c" translate="yes" xml:space="preserve">
          <source>As mentioned in the module documentation, threads are usually made to communicate using &lt;a href=&quot;../sync/mpsc/index&quot;&gt;&lt;code&gt;channels&lt;/code&gt;&lt;/a&gt;, here is how it usually looks.</source>
          <target state="translated">모듈 문서에서 언급했듯이 스레드는 일반적으로 &lt;a href=&quot;../sync/mpsc/index&quot;&gt; &lt;code&gt;channels&lt;/code&gt; &lt;/a&gt; 사용하여 통신하기 위해 만들어집니다 .</target>
        </trans-unit>
        <trans-unit id="fad7d9a9d62e3d2756844c471849a76502954355" translate="yes" xml:space="preserve">
          <source>As non-Rust calling conventions do not support unwinding, unwinding past the end of an extern function will cause the process to abort. In LLVM, this is implemented by executing an illegal instruction.</source>
          <target state="translated">비 녹음 호출 규칙은 해제를 지원하지 않으므로 extern 함수 끝을 지나서 해제하면 프로세스가 중단됩니다. LLVM에서는 잘못된 명령을 실행하여 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="10482a83c62e485259adbe51b49060ecef064cde" translate="yes" xml:space="preserve">
          <source>As noted above, coercions mean that most code doesn't have to be concerned with this distinction. However, you can tell the difference when using &lt;strong&gt;transmute&lt;/strong&gt; to convert a fn item into a fn pointer.</source>
          <target state="translated">위에서 언급했듯이 강제는 대부분의 코드가이 구별에 관심을 가질 필요가 없음을 의미합니다. 그러나 &lt;strong&gt;변환식&lt;/strong&gt; 을 사용하여 fn 항목을 fn 포인터로 변환 할 때 차이점을 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78cffef75c7264e29f3831c1d70df7b7db90b085" translate="yes" xml:space="preserve">
          <source>As one would expect, primitive types like &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.f64&quot;&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/a&gt; are all &lt;code&gt;Sync&lt;/code&gt;, and so are simple aggregate types containing them, like tuples, structs and enums. More examples of basic &lt;code&gt;Sync&lt;/code&gt; types include &quot;immutable&quot; types like &lt;code&gt;&amp;amp;T&lt;/code&gt;, and those with simple inherited mutability, such as &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and most other collection types. (Generic parameters need to be &lt;code&gt;Sync&lt;/code&gt; for their container to be &lt;code&gt;Sync&lt;/code&gt;.)</source>
          <target state="translated">예상대로 &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../primitive.f64&quot;&gt; &lt;code&gt;f64&lt;/code&gt; &lt;/a&gt; 와 같은 기본 유형 은 모두 &lt;code&gt;Sync&lt;/code&gt; 이므로 튜플, 구조체 및 열거 형과 같은 유형을 포함하는 간단한 집계 유형입니다. 기본 &lt;code&gt;Sync&lt;/code&gt; 유형 의 더 많은 예 에는 &lt;code&gt;&amp;amp;T&lt;/code&gt; 와 같은 &quot;불변&quot;유형과 &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 대부분의 다른 콜렉션 유형 과 같이 단순하게 상속 된 변경이 가능한 유형이 있습니다. 컨테이너 가 &lt;code&gt;Sync&lt;/code&gt; 가되도록하려면 일반 매개 변수가 Sync 이어야 &lt;code&gt;Sync&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3262fa97dd64c6174eeff7f6dc1bf92e0938ab9" translate="yes" xml:space="preserve">
          <source>As per &lt;a href=&quot;https://tools.ietf.org/html/rfc3879&quot;&gt;RFC 3879&lt;/a&gt;, the whole &lt;code&gt;FEC0::/10&lt;/code&gt; prefix is deprecated. New software must not support site-local addresses.</source>
          <target state="translated">당으로 &lt;a href=&quot;https://tools.ietf.org/html/rfc3879&quot;&gt;RFC 3879&lt;/a&gt; , 전체 &lt;code&gt;FEC0::/10&lt;/code&gt; 접두사는 사용되지 않습니다. 새 소프트웨어는 사이트 로컬 주소를 지원하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="51aa8d67495f62b66ef894735fcf63e6606dac28" translate="yes" xml:space="preserve">
          <source>As shown in the example above, &lt;code&gt;for&lt;/code&gt; loops (along with all other loops) can be tagged, using similar syntax to lifetimes (only visually similar, entirely distinct in practice). Giving the same tag to &lt;code&gt;break&lt;/code&gt; breaks the tagged loop, which is useful for inner loops. It is definitely not a goto.</source>
          <target state="translated">위의 예에서 볼 수 있듯이 &lt;code&gt;for&lt;/code&gt; 루프 (다른 모든 루프와 함께)는 수명과 유사한 구문을 사용하여 태그를 지정할 수 있습니다 (시각적으로는 시각적으로 유사하며 실제로는 완전히 다릅니다). 동일한 태그를 &lt;code&gt;break&lt;/code&gt; 태그가 지정된 루프 가 끊어 지므로 내부 루프에 유용합니다. 확실히 goto가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c276f971f322ddf36b0d0a39caeff0e860e6ee88" translate="yes" xml:space="preserve">
          <source>As stated in the User Datagram Protocol's specification in &lt;a href=&quot;https://tools.ietf.org/html/rfc768&quot;&gt;IETF RFC 768&lt;/a&gt;, UDP is an unordered, unreliable protocol; refer to &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; for TCP primitives.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc768&quot;&gt;IETF RFC 768&lt;/a&gt; 의 사용자 데이터 그램 프로토콜 사양에 명시된 바와 같이 UDP는 순서가없고 신뢰할 수없는 프로토콜입니다. TCP 프리미티브에 대해서는 &lt;a href=&quot;struct.tcplistener&quot;&gt; &lt;code&gt;TcpListener&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="54d4fd727ce2657161522c6ae3a06633673c9cbd" translate="yes" xml:space="preserve">
          <source>As string slices are a slice of bytes, the raw pointer points to a &lt;a href=&quot;primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;. This pointer will be pointing to the first byte of the string slice.</source>
          <target state="translated">문자열 슬라이스가 바이트 슬라이스이므로 원시 포인터는 &lt;a href=&quot;primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; 을&lt;/a&gt; 가리 킵니다 . 이 포인터는 문자열 슬라이스의 첫 번째 바이트를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="b757bf93c530db10fdab40d9aeca4c3f17d50ad1" translate="yes" xml:space="preserve">
          <source>As such, the &lt;code&gt;from_utf8&lt;/code&gt; family of functions and methods for both &lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;s and &lt;a href=&quot;fn.from_utf8&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;s make use of this error, for example.</source>
          <target state="translated">따라서 &lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;fn.from_utf8&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 대한 &lt;code&gt;from_utf8&lt;/code&gt; 함수 및 메소드 계열은 예를 들어이 오류를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a7bae3aa148344b33c64086da16dba6a42474602" translate="yes" xml:space="preserve">
          <source>As the author of a data structure you get to decide for each field whether pinning &quot;propagates&quot; to this field or not. Pinning that propagates is also called &quot;structural&quot;, because it follows the structure of the type. In the following subsections, we describe the considerations that have to be made for either choice.</source>
          <target state="translated">데이터 구조의 작성자는 각 필드에 대해 고정이이 필드에 &quot;전파&quot;되는지 여부를 결정하게됩니다. 전파되는 고정은 유형의 구조를 따르기 때문에 &quot;구조적&quot;이라고도합니다. 다음 하위 섹션에서는 두 가지 선택을 위해 고려해야 할 사항에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="0b86e5cf0a558c007bb8a3eed83a07619a169108" translate="yes" xml:space="preserve">
          <source>As the error message indicates, only &lt;code&gt;u8&lt;/code&gt; can be cast into &lt;code&gt;char&lt;/code&gt;. Example:</source>
          <target state="translated">오류 메시지에서 알 수 있듯이 &lt;code&gt;u8&lt;/code&gt; 만 &lt;code&gt;char&lt;/code&gt; 로 캐스트 할 수 있습니다 . 예:</target>
        </trans-unit>
        <trans-unit id="6c037f01ab1e44c1b49068f96530e00f210988e8" translate="yes" xml:space="preserve">
          <source>As the target platform's native endianness is used, portable code likely wants to use &lt;a href=&quot;#method.from_be_bytes&quot;&gt;&lt;code&gt;from_be_bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.from_le_bytes&quot;&gt;&lt;code&gt;from_le_bytes&lt;/code&gt;&lt;/a&gt;, as appropriate instead.</source>
          <target state="translated">대상 플랫폼의 고유 엔디안이 사용됨에 따라 이식 가능한 코드는 대신 &lt;a href=&quot;#method.from_be_bytes&quot;&gt; &lt;code&gt;from_be_bytes&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#method.from_le_bytes&quot;&gt; &lt;code&gt;from_le_bytes&lt;/code&gt; &lt;/a&gt; 를 사용 하려고 합니다.</target>
        </trans-unit>
        <trans-unit id="1c8bfefec8dafcbb055c2ea433ad31a56feecccd" translate="yes" xml:space="preserve">
          <source>As the target platform's native endianness is used, portable code should use &lt;a href=&quot;#method.to_be_bytes&quot;&gt;&lt;code&gt;to_be_bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.to_le_bytes&quot;&gt;&lt;code&gt;to_le_bytes&lt;/code&gt;&lt;/a&gt;, as appropriate, instead.</source>
          <target state="translated">대상 플랫폼의 고유 엔디안이 사용되므로 이식 가능한 코드는 대신 &lt;a href=&quot;#method.to_be_bytes&quot;&gt; &lt;code&gt;to_be_bytes&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#method.to_le_bytes&quot;&gt; &lt;code&gt;to_le_bytes&lt;/code&gt; 를&lt;/a&gt; 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c2aae14d23e6b4a7f032b38d8e95a4d1b336b019" translate="yes" xml:space="preserve">
          <source>As this is the only method for this trait, the &lt;a href=&quot;trait.extend&quot;&gt;trait-level&lt;/a&gt; docs contain more details.</source>
          <target state="translated">이것이이 특성에 대한 유일한 방법이므로 &lt;a href=&quot;trait.extend&quot;&gt;특성 수준&lt;/a&gt; 문서에는 자세한 내용이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f292830332806677ad0b0527bf74ceadc350e53c" translate="yes" xml:space="preserve">
          <source>As usual, this output tells us exactly what has gone wrong.</source>
          <target state="translated">평소와 같이,이 결과는 무엇이 잘못되었는지 정확하게 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="6d6b5c58bde3c21428520a679924eb54e0901d4d" translate="yes" xml:space="preserve">
          <source>As we did with structs, we can define enums to hold generic data types in their variants. Let&amp;rsquo;s take another look at the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; enum that the standard library provides, which we used in Chapter 6:</source>
          <target state="translated">구조체와 마찬가지로 일반적인 데이터 형식을 변형으로 보유하도록 열거 형을 정의 할 수 있습니다. 6 장에서 사용한 표준 라이브러리가 제공 하는 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 열거 형에 대해 다시 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="c9b62e53d822366f9040eaf9632aa096cd8d407c" translate="yes" xml:space="preserve">
          <source>As we saw when we printed the vector, the program&amp;rsquo;s name takes up the first value in the vector at &lt;code&gt;args[0]&lt;/code&gt;, so we&amp;rsquo;re starting at index &lt;code&gt;1&lt;/code&gt;. The first argument &lt;code&gt;minigrep&lt;/code&gt; takes is the string we&amp;rsquo;re searching for, so we put a reference to the first argument in the variable &lt;code&gt;query&lt;/code&gt;. The second argument will be the filename, so we put a reference to the second argument in the variable &lt;code&gt;filename&lt;/code&gt;.</source>
          <target state="translated">벡터를 인쇄 할 때 보았 듯이 프로그램 이름은 &lt;code&gt;args[0]&lt;/code&gt; 의 벡터에서 첫 번째 값을 차지 하므로 인덱스 &lt;code&gt;1&lt;/code&gt; 에서 시작 합니다. &lt;code&gt;minigrep&lt;/code&gt; 이받는 첫 번째 인수 는 검색하는 문자열이므로 변수 &lt;code&gt;query&lt;/code&gt; 의 첫 번째 인수에 대한 참조를 넣습니다 . 두 번째 인수는 파일 이름이되므로 변수 &lt;code&gt;filename&lt;/code&gt; 에 두 번째 인수에 대한 참조를 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="387526bcd86a3d932ce8d276666fe3de9ea36fb2" translate="yes" xml:space="preserve">
          <source>As well as overloading the unary &lt;code&gt;*&lt;/code&gt; operator, &lt;a href=&quot;../std/ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/ops/trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; are also used in &lt;a href=&quot;expressions/method-call-expr&quot;&gt;method resolution&lt;/a&gt; and &lt;a href=&quot;type-coercions#coercion-types&quot;&gt;deref coercions&lt;/a&gt;.</source>
          <target state="translated">단항 &lt;code&gt;*&lt;/code&gt; 연산자에 과부하가 걸리는 것 &lt;a href=&quot;../std/ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../std/ops/trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;expressions/method-call-expr&quot;&gt;메소드 해석&lt;/a&gt; 및 &lt;a href=&quot;type-coercions#coercion-types&quot;&gt;deref 강제&lt;/a&gt; 에도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="00f0078e7027bdd5fb06a3cdb9f947f1a54e08c1" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;#method.as_ref&quot;&gt;&lt;code&gt;as_ref&lt;/code&gt;&lt;/a&gt;, this is unsafe because it cannot verify the validity of the returned pointer, nor can it ensure that the lifetime &lt;code&gt;'a&lt;/code&gt; returned is indeed a valid lifetime for the contained data.</source>
          <target state="translated">와 마찬가지로 &lt;a href=&quot;#method.as_ref&quot;&gt; &lt;code&gt;as_ref&lt;/code&gt; &lt;/a&gt; 가 반환 된 포인터의 유효성을 검증 할 수 없으며이 수명 보장 할 수 있기 때문에, 이것은 안전하지 않은 &lt;code&gt;'a&lt;/code&gt; 반환이 실제로 포함 된 데이터의 유효 수명이다.</target>
        </trans-unit>
        <trans-unit id="e824f1a2f05ba862631703f190681d4c2dd2b70b" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;use-declarations#underscore-imports&quot;&gt;underscore imports&lt;/a&gt;, macros may safely emit the same unnamed constant in the same scope more than once. For example, the following should not produce an error:</source>
          <target state="translated">&lt;a href=&quot;use-declarations#underscore-imports&quot;&gt;밑줄 가져 오기&lt;/a&gt; 와 마찬가지로 매크로는 동일한 범위에서 동일한 명명되지 않은 상수를 두 번 이상 안전하게 방출 할 수 있습니다. 예를 들어, 다음은 오류가 발생하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="4c083e9f314596dd1da24d21de9af221cdf99253" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;let&lt;/code&gt; bindings, function arguments are irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt;, so any pattern that is valid in a let binding is also valid as an argument:</source>
          <target state="translated">와 같은 &lt;code&gt;let&lt;/code&gt; 바인딩 함수 인수는 반박 할 수없는 &lt;a href=&quot;../patterns&quot;&gt;패턴&lt;/a&gt; 이므로 let 바인딩에 유효한 모든 패턴도 인수로 유효합니다.</target>
        </trans-unit>
        <trans-unit id="021860f0b9c701b01e24f471ef9064ff787c7fc6" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;split()&lt;/code&gt;, if the first or last element is matched, an empty slice will be the first (or last) item returned by the iterator.</source>
          <target state="translated">&lt;code&gt;split()&lt;/code&gt; 과 마찬가지로 첫 번째 또는 마지막 요소가 일치하면 빈 슬라이스는 반복자가 반환 한 첫 번째 (또는 마지막) 항목이됩니다.</target>
        </trans-unit>
        <trans-unit id="a311c5a68716dfa8ec04c201fd72e1f6bf20977d" translate="yes" xml:space="preserve">
          <source>As with any variable, if we want to be able to change its value, we need to make it mutable using the &lt;code&gt;mut&lt;/code&gt; keyword, as discussed in Chapter 3. The numbers we place inside are all of type &lt;code&gt;i32&lt;/code&gt;, and Rust infers this from the data, so we don&amp;rsquo;t need the &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; annotation.</source>
          <target state="translated">변수와 마찬가지로 값을 변경하려면 3 장에서 설명한대로 &lt;code&gt;mut&lt;/code&gt; 키워드를 사용하여 변수를 변경 가능하게 만들어야합니다. &lt;code&gt;i32&lt;/code&gt; 이며 Rust는 &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; 주석이 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4275e8a23f25e311b7879f2ca06bcf06be2ae3c3" translate="yes" xml:space="preserve">
          <source>As with many types, we create a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; using the associated function &lt;code&gt;new&lt;/code&gt;. To access the data inside the mutex, we use the &lt;code&gt;lock&lt;/code&gt; method to acquire the lock. This call will block the current thread so it can&amp;rsquo;t do any work until it&amp;rsquo;s our turn to have the lock.</source>
          <target state="translated">많은 종류와 마찬가지로, 우리는 만들 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 관련 기능을 사용하여 &lt;code&gt;new&lt;/code&gt; . 뮤텍스 내부의 데이터에 액세스하기 위해 &lt;code&gt;lock&lt;/code&gt; 메소드를 사용하여 잠금 을 획득합니다. 이 호출은 현재 스레드를 차단하므로 잠금을 설정해야 할 때까지 아무 작업도 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="35a5907e5dda02884b0d94275e42a50fca56e187" translate="yes" xml:space="preserve">
          <source>As with regular variables, we specify mutability using the &lt;code&gt;mut&lt;/code&gt; keyword. Any code that reads or writes from &lt;code&gt;COUNTER&lt;/code&gt; must be within an &lt;code&gt;unsafe&lt;/code&gt; block. This code compiles and prints &lt;code&gt;COUNTER: 3&lt;/code&gt; as we would expect because it&amp;rsquo;s single threaded. Having multiple threads access &lt;code&gt;COUNTER&lt;/code&gt; would likely result in data races.</source>
          <target state="translated">일반 변수와 마찬가지로 &lt;code&gt;mut&lt;/code&gt; 키워드를 사용하여 변경 가능성을 지정 합니다. &lt;code&gt;COUNTER&lt;/code&gt; 에서 읽거나 쓰는 코드 는 &lt;code&gt;unsafe&lt;/code&gt; 블록 내에 있어야합니다 . 이 코드는 &lt;code&gt;COUNTER: 3&lt;/code&gt; 컴파일하고 인쇄합니다 . 는 단일 스레드이기 때문에 을 . 여러 스레드가 &lt;code&gt;COUNTER&lt;/code&gt; 에 액세스 하면 데이터 경쟁이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fb7b19ef9483e218deb8b0d1a3f5269874b86ed" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; type, a &lt;code&gt;HashSet&lt;/code&gt; requires that the elements implement the &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits. This can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="translated">와 마찬가지로 &lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; 의&lt;/a&gt; 형, &lt;code&gt;HashSet&lt;/code&gt; 의이 요소를 구현하도록 요구&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 형질. &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; 를 사용하여 자주 수행 할 수 있습니다. 이를 직접 구현하는 경우 다음 속성이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c568bda8aab01e836f5470185110a68fb4739aa1" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; type, a &lt;code&gt;HashSet&lt;/code&gt; requires that the elements implement the &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; traits. This can frequently be achieved by using &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt;. If you implement these yourself, it is important that the following property holds:</source>
          <target state="translated">와 마찬가지로 &lt;a href=&quot;struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; 의&lt;/a&gt; 형, &lt;code&gt;HashSet&lt;/code&gt; 의이 요소를 구현하도록 요구&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; 형질. &lt;code&gt;#[derive(PartialEq, Eq, Hash)]&lt;/code&gt; 를 사용하여 자주 수행 할 수 있습니다. 이를 직접 구현하는 경우 다음 속성이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ae28ea4c57639b6218be246b12eabdfb50b7b74a" translate="yes" xml:space="preserve">
          <source>As with variables, we can add type annotations if we want to increase explicitness and clarity at the cost of being more verbose than is strictly necessary. Annotating the types for the closure we defined in Listing 13-5 would look like the definition shown in Listing 13-7.</source>
          <target state="translated">변수와 마찬가지로 엄격하게 필요한 것보다 더 장황한 비용으로 명시 성과 선명도를 높이려면 유형 주석을 추가 할 수 있습니다. Listing 13-5에서 정의한 클로저의 타입에 주석을 달면 Listing 13-7에 나온 정의와 같다.</target>
        </trans-unit>
        <trans-unit id="96c2069203f702eae6427926792a296cebb74618" translate="yes" xml:space="preserve">
          <source>As you add more integration tests, you might want to make more than one file in the &lt;em&gt;tests&lt;/em&gt; directory to help organize them; for example, you can group the test functions by the functionality they&amp;rsquo;re testing. As mentioned earlier, each file in the &lt;em&gt;tests&lt;/em&gt; directory is compiled as its own separate crate.</source>
          <target state="translated">더 많은 통합 테스트를 추가 할 때 &lt;em&gt;tests&lt;/em&gt; 디렉토리 에 둘 이상의 파일을 만들어 구성하는 데 도움이 될 수 있습니다. 예를 들어 테스트중인 기능별로 테스트 기능을 그룹화 할 수 있습니다. 앞에서 언급했듯이 &lt;em&gt;테스트의&lt;/em&gt; 각 파일&lt;em&gt;&lt;/em&gt; 디렉토리의 별도의 상자로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="064638b9138d50bf7a76d4f1fb8907e6d00d4af4" translate="yes" xml:space="preserve">
          <source>As you also learned in Chapter 1, &lt;code&gt;println!&lt;/code&gt; is a macro that prints a string to the screen:</source>
          <target state="translated">1 장에서도 배웠 듯이 &lt;code&gt;println!&lt;/code&gt; 화면에 문자열을 인쇄하는 매크로입니다.</target>
        </trans-unit>
        <trans-unit id="cfbf1a7efc3caed67bc7e41bd453d7589ffb22d8" translate="yes" xml:space="preserve">
          <source>As you can see in the signature of &lt;code&gt;spawn&lt;/code&gt; there are two constraints on both the closure given to &lt;code&gt;spawn&lt;/code&gt; and its return value, let's explain them:</source>
          <target state="translated">당신의 서명에서 볼 수 있듯이 &lt;code&gt;spawn&lt;/code&gt; 에 주어진 폐쇄 양쪽에 두 제약이 있습니다 &lt;code&gt;spawn&lt;/code&gt; 및 반환 값은,의 그들을 설명 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="0420fe0c9530d1e1d147961f14b139b3fe83e9e2" translate="yes" xml:space="preserve">
          <source>As you can see, the stable toolchain is the default. Most Rust users use stable most of the time. You might want to use stable most of the time, but use nightly on a specific project, because you care about a cutting-edge feature. To do so, you can use &lt;code&gt;rustup override&lt;/code&gt; in that project&amp;rsquo;s directory to set the nightly toolchain as the one &lt;code&gt;rustup&lt;/code&gt; should use when you&amp;rsquo;re in that directory:</source>
          <target state="translated">보시다시피 안정적인 툴체인이 기본값입니다. 대부분의 Rust 사용자는 대부분 안정적인 시간을 사용합니다. 최첨단 기능을 염두에두고 대부분의 시간을 안정적으로 사용하고 싶지만 특정 프로젝트에서 야간에 사용하는 것이 좋습니다. 그렇게하려면 &lt;code&gt;rustup override&lt;/code&gt; 해당 프로젝트 디렉토리에서 rustup override 를 하여 야간 툴체인을 하나의 &lt;code&gt;rustup&lt;/code&gt; 으로 설정할 수 있습니다. 사용하여 해당 디렉토리에있을 때 이 사용해야 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d87736b18e618ced4be36c042766a61a7024b14" translate="yes" xml:space="preserve">
          <source>As you can see, this will return the expected, valid items.</source>
          <target state="translated">보시다시피 예상 유효 항목을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2afcd0df9449bfb1b32a67c779124a1b65363260" translate="yes" xml:space="preserve">
          <source>As you can see, using the parent modules distinguishes the two &lt;code&gt;Result&lt;/code&gt; types. If instead we specified &lt;code&gt;use std::fmt::Result&lt;/code&gt; and &lt;code&gt;use std::io::Result&lt;/code&gt;, we&amp;rsquo;d have two &lt;code&gt;Result&lt;/code&gt; types in the same scope and Rust wouldn&amp;rsquo;t know which one we meant when we used &lt;code&gt;Result&lt;/code&gt;.</source>
          <target state="translated">보시다시피 부모 모듈을 사용하면 두 가지 &lt;code&gt;Result&lt;/code&gt; 유형이 구분 됩니다. 대신 &lt;code&gt;use std::fmt::Result&lt;/code&gt; 를 &lt;code&gt;use std::io::Result&lt;/code&gt; 하면 두 개가됩니다 &lt;code&gt;Result&lt;/code&gt; 하면 동일한 범위에 Result 유형이 있고 Rust는 &lt;code&gt;Result&lt;/code&gt; 를 사용할 때 어떤 결과 유형을 알지 못합니다 .</target>
        </trans-unit>
        <trans-unit id="20722bacbfbb971e3e58847f05a0049adb3a009e" translate="yes" xml:space="preserve">
          <source>As you can see, we&amp;rsquo;ve moved everything into a loop from the guess input prompt onward. Be sure to indent the lines inside the loop another four spaces each and run the program again. Notice that there is a new problem because the program is doing exactly what we told it to do: ask for another guess forever! It doesn&amp;rsquo;t seem like the user can quit!</source>
          <target state="translated">보시다시피, 우리는 추측 입력 프롬프트에서 모든 것을 루프로 옮겼습니다. 루프 내부의 라인을 각각 다른 4 칸씩 들여 쓰기하고 프로그램을 다시 실행하십시오. 프로그램이 우리가 지시 한대로 정확하게 수행하고 있기 때문에 새로운 문제가 있음을 주목하십시오 : 또 다른 추측을 영원히 요청하십시오! 사용자가 종료 할 수없는 것 같습니다!</target>
        </trans-unit>
        <trans-unit id="ac1ee84193bb1d8e87992969494a2311a45eebb9" translate="yes" xml:space="preserve">
          <source>As you can see, you can specify type parameters in curly braces for substitution with the actual types (using the regular format string syntax) in a given situation. Furthermore, &lt;code&gt;{Self}&lt;/code&gt; will substitute to the type (in this case, &lt;code&gt;bool&lt;/code&gt;) that we tried to use.</source>
          <target state="translated">보시다시피, 주어진 상황에서 실제 형식으로 대체하기 위해 중괄호로 형식 매개 변수를 지정할 수 있습니다 (일반 형식 문자열 구문 사용). 또한 &lt;code&gt;{Self}&lt;/code&gt; 는 유형을 대신합니다 (이 경우 &lt;code&gt;bool&lt;/code&gt; 사용하려고 시도한 bool )을 합니다.</target>
        </trans-unit>
        <trans-unit id="b2e9ae4479b0983efbf6a5f5ed8ba7b27ba6777d" translate="yes" xml:space="preserve">
          <source>As you could see, in many aspects (except for layouts, safety and ownership) unions behave exactly like structs, largely as a consequence of inheriting their syntactic shape from structs. This is also true for many unmentioned aspects of Rust language (such as privacy, name resolution, type inference, generics, trait implementations, inherent implementations, coherence, pattern checking, etc etc etc).</source>
          <target state="translated">보시다시피, 많은 측면에서 (레이아웃, 안전 및 소유권 제외) 노조는 구조체에서 구문 형태를 상속 한 결과 구조체와 똑같이 동작합니다. 이는 Rust 언어의 언급되지 않은 많은 측면 (예 : 프라이버시, 이름 확인, 형식 유추, 제네릭, 특성 구현, 고유 구현, 일관성, 패턴 확인 등)에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b701fb6519447ef85d48d0e79a042ed086034a11" translate="yes" xml:space="preserve">
          <source>As you learned in Chapter 16, &lt;code&gt;thread::spawn&lt;/code&gt; will create a new thread and then run the code in the closure in the new thread. If you run this code and load &lt;em&gt;/sleep&lt;/em&gt; in your browser, then &lt;em&gt;/&lt;/em&gt; in two more browser tabs, you&amp;rsquo;ll indeed see that the requests to &lt;em&gt;/&lt;/em&gt; don&amp;rsquo;t have to wait for &lt;em&gt;/sleep&lt;/em&gt; to finish. But as we mentioned, this will eventually overwhelm the system because you&amp;rsquo;d be making new threads without any limit.</source>
          <target state="translated">16 장에서 배운 것처럼 &lt;code&gt;thread::spawn&lt;/code&gt; 은 새 스레드를 생성 한 다음 새 스레드의 클로저에서 코드를 실행합니다. 이 코드 및로드 실행하면 &lt;em&gt;/ 절전&lt;/em&gt; 브라우저에서를 다음 &lt;em&gt;/&lt;/em&gt; 두 개 더 브라우저 탭, 당신은 참으로 요청 것을 볼 수 있습니다 &lt;em&gt;/이&lt;/em&gt; 기다릴 필요가 없습니다&lt;em&gt; / 절전&lt;/em&gt; 마무리. 그러나 우리가 언급했듯이, 제한없이 새로운 스레드를 만들 수 있기 때문에 결국 시스템을 압도합니다.</target>
        </trans-unit>
        <trans-unit id="f4d2e2ae7d1d7339cbe38cf89981448ff9804651" translate="yes" xml:space="preserve">
          <source>As you might have guessed, &lt;code&gt;continue&lt;/code&gt; has a &lt;code&gt;!&lt;/code&gt; value. That is, when Rust computes the type of &lt;code&gt;guess&lt;/code&gt;, it looks at both match arms, the former with a value of &lt;code&gt;u32&lt;/code&gt; and the latter with a &lt;code&gt;!&lt;/code&gt; value. Because &lt;code&gt;!&lt;/code&gt; can never have a value, Rust decides that the type of &lt;code&gt;guess&lt;/code&gt; is &lt;code&gt;u32&lt;/code&gt;.</source>
          <target state="translated">당신이 짐작할 수 있듯이 &lt;code&gt;continue&lt;/code&gt; 하십시오 &lt;code&gt;!&lt;/code&gt; 값. 즉, Rust가 &lt;code&gt;guess&lt;/code&gt; 유형을 계산할 때 일치 팔은 &lt;code&gt;u32&lt;/code&gt; 값이고 다른 하나는 &lt;code&gt;!&lt;/code&gt; 값. 왜냐하면 &lt;code&gt;!&lt;/code&gt; Rust는 &lt;code&gt;guess&lt;/code&gt; 의 유형 이 &lt;code&gt;u32&lt;/code&gt; 라고 결정합니다. .</target>
        </trans-unit>
        <trans-unit id="467cfe4dd8e4d010791398ae5c6bd0fbee6d53ca" translate="yes" xml:space="preserve">
          <source>As you might suspect, &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; is a smart pointer. More accurately, the call to &lt;code&gt;lock&lt;/code&gt;&lt;em&gt;returns&lt;/em&gt; a smart pointer called &lt;code&gt;MutexGuard&lt;/code&gt;, wrapped in a &lt;code&gt;LockResult&lt;/code&gt; that we handled with the call to &lt;code&gt;unwrap&lt;/code&gt;. The &lt;code&gt;MutexGuard&lt;/code&gt; smart pointer implements &lt;code&gt;Deref&lt;/code&gt; to point at our inner data; the smart pointer also has a &lt;code&gt;Drop&lt;/code&gt; implementation that releases the lock automatically when a &lt;code&gt;MutexGuard&lt;/code&gt; goes out of scope, which happens at the end of the inner scope in Listing 16-12. As a result, we don&amp;rsquo;t risk forgetting to release the lock and blocking the mutex from being used by other threads because the lock release happens automatically.</source>
          <target state="translated">의심 할 수 있듯이 &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; 는 스마트 포인터입니다. 더 정확하게, 호출 &lt;code&gt;lock&lt;/code&gt; &lt;em&gt;반환&lt;/em&gt; 라는 스마트 포인터 &lt;code&gt;MutexGuard&lt;/code&gt; A의 포장, &lt;code&gt;LockResult&lt;/code&gt; 우리를 호출하여 처리하는 것을 &lt;code&gt;unwrap&lt;/code&gt; . &lt;code&gt;MutexGuard&lt;/code&gt; 스마트 포인터 구현 &lt;code&gt;Deref&lt;/code&gt; 우리의 내면 데이터에서 포인트; 스마트 포인터에는 또한 범위를 벗어날 때 자동으로 잠금을 해제 하는 &lt;code&gt;Drop&lt;/code&gt; 구현이 있습니다. &lt;code&gt;MutexGuard&lt;/code&gt; 가이는 목록 16-12의 내부 범위 끝에서 발생합니다. 결과적으로 잠금 해제가 자동으로 이루어지기 때문에 잠금 해제를 잊어 버리고 뮤텍스가 다른 스레드에서 사용되는 것을 차단할 위험이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e4e495363e711b35cf1aef444d4c023b03ec561b" translate="yes" xml:space="preserve">
          <source>As you saw in Chapter 1, &lt;code&gt;cargo new&lt;/code&gt; generates a &amp;ldquo;Hello, world!&amp;rdquo; program for you. Check out the &lt;em&gt;src/main.rs&lt;/em&gt; file:</source>
          <target state="translated">1 장에서 보았 듯이 &lt;code&gt;cargo new&lt;/code&gt; 는 &quot;Hello, world!&quot;를 생성합니다. 당신을 위해 프로그램. &lt;em&gt;src / main.rs&lt;/em&gt; 파일을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="acce671b7472bf5e5eaabe31a3ccfe6aca667c9d" translate="yes" xml:space="preserve">
          <source>As you saw in Chapter 1, the &lt;code&gt;main&lt;/code&gt; function is the entry point into the program:</source>
          <target state="translated">1 장에서 보았 듯이 &lt;code&gt;main&lt;/code&gt; 기능은 프로그램의 진입 점입니다.</target>
        </trans-unit>
        <trans-unit id="1b995f5c38439d41d9506c07ed8d2188c4fc0f99" translate="yes" xml:space="preserve">
          <source>As you saw in Chapter 6, you can match patterns against literals directly. The following code gives some examples:</source>
          <target state="translated">6 장에서 보았 듯이 패턴을 리터럴과 직접 일치시킬 수 있습니다. 다음 코드는 몇 가지 예를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fa0b472a10784179b99aa6fee609e3cfddb9cc55" translate="yes" xml:space="preserve">
          <source>As you saw in Listing 17-15, we can write methods that use the syntax &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt;, which allows the method to take ownership of a &lt;code&gt;Self&lt;/code&gt; value stored in a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;. That&amp;rsquo;s exactly what we want to do here, but unfortunately Rust won&amp;rsquo;t let us: the part of Rust that implements behavior when a closure is called isn&amp;rsquo;t implemented using &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt;. So Rust doesn&amp;rsquo;t yet understand that it could use &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; in this situation to take ownership of the closure and move the closure out of the &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Listing 17-15에서 보듯이 &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; 구문을 사용하는 메소드를 작성할 수있다 . 이를 통해 메소드 는 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 저장된 &lt;code&gt;Self&lt;/code&gt; 값의 소유권을 가질 수있다 . 이것이 바로 우리가 여기서하고 싶은 일이지만 불행히도 Rust는 우리를 허락하지 않을 것입니다. 클로저가 호출 될 때 동작을 구현하는 Rust의 일부는 &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; 사용하여 구현되지 않습니다 . 따라서 Rust는 이 상황에서 &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; 를 사용하여 클로저의 소유권을 가져와 클로저를 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 밖으로 옮길 수 있다는 것을 아직 이해하지 못합니다 .</target>
        </trans-unit>
        <trans-unit id="5d8ebbcc7fc2cf4e602d0e1985852befad2da85e" translate="yes" xml:space="preserve">
          <source>As you saw in the guessing game tutorial in the &lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;&amp;ldquo;Comparing the Guess to the Secret Number&amp;rdquo;&lt;/a&gt; section in Chapter 2, you can declare a new variable with the same name as a previous variable, and the new variable shadows the previous variable. Rustaceans say that the first variable is &lt;em&gt;shadowed&lt;/em&gt; by the second, which means that the second variable&amp;rsquo;s value is what appears when the variable is used. We can shadow a variable by using the same variable&amp;rsquo;s name and repeating the use of the &lt;code&gt;let&lt;/code&gt; keyword as follows:</source>
          <target state="translated">2 장의 &lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;&quot;비밀번호에 맞춰 추측하기&quot;&lt;/a&gt; 섹션 의 추측 게임 튜토리얼에서 보았 듯이 이전 변수와 동일한 이름을 가진 새 변수를 선언하고 새 변수는 이전 변수를 가리게 할 수 있습니다. Rustaceans는 첫 번째 변수가 두 번째 변수에 의해 &lt;em&gt;음영 처리&lt;/em&gt; 된다고 말하는데 , 이는 두 번째 변수의 값이 변수가 사용될 때 나타나는 값임을 의미합니다. 동일한 변수 이름을 사용 하고 다음과 같이 &lt;code&gt;let&lt;/code&gt; 키워드 사용을 반복하여 변수를 음영 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="c47b398566173be1e06632198f7039025f10ae00" translate="yes" xml:space="preserve">
          <source>As you write large programs, organizing your code will be important because keeping track of your entire program in your head will become impossible. By grouping related functionality and separating code with distinct features, you&amp;rsquo;ll clarify where to find code that implements a particular feature and where to go to change how a feature works.</source>
          <target state="translated">큰 프로그램을 작성할 때는 전체 프로그램을 추적하는 것이 불가능하기 때문에 코드를 구성하는 것이 중요합니다. 관련 기능을 그룹화하고 고유 한 기능으로 코드를 분리하면 특정 기능을 구현하는 코드를 찾는 위치와 기능 작동 방식을 변경할 위치를 명확하게 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a48835105e35976d30850d6478e3e8cb37ac0bc5" translate="yes" xml:space="preserve">
          <source>As your project grows, consider using a workspace: it&amp;rsquo;s easier to understand smaller, individual components than one big blob of code. Furthermore, keeping the crates in a workspace can make coordination between them easier if they are often changed at the same time.</source>
          <target state="translated">프로젝트가 성장함에 따라 작업 영역 사용을 고려하십시오. 하나의 큰 코드 덩어리보다 작은 개별 구성 요소를 이해하는 것이 더 쉽습니다. 또한, 상자를 작업 공간에 보관하면 종종 종종 변경되는 경우 더 쉽게 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db2e27ecee3ef7df382d73da5185cf2c81a313eb" translate="yes" xml:space="preserve">
          <source>AsMut</source>
          <target state="translated">AsMut</target>
        </trans-unit>
        <trans-unit id="9dee5144fa49d1023659054cfeb7b935d110f729" translate="yes" xml:space="preserve">
          <source>AsMut::as_mut</source>
          <target state="translated">AsMut::as_mut</target>
        </trans-unit>
        <trans-unit id="fa6cbff29c8fee2a75af18139d6ec5d8bb30e951" translate="yes" xml:space="preserve">
          <source>AsRawFd</source>
          <target state="translated">AsRawFd</target>
        </trans-unit>
        <trans-unit id="bf4b7b3bd11f76d54ac78e508bf69a1df97a73ab" translate="yes" xml:space="preserve">
          <source>AsRawHandle</source>
          <target state="translated">AsRawHandle</target>
        </trans-unit>
        <trans-unit id="bcb7263b347977861cfead462a0183ddbacb93a0" translate="yes" xml:space="preserve">
          <source>AsRawSocket</source>
          <target state="translated">AsRawSocket</target>
        </trans-unit>
        <trans-unit id="ecb4ad32c0bbcb0030bdba05dd0126fda307a2ef" translate="yes" xml:space="preserve">
          <source>AsRef</source>
          <target state="translated">AsRef</target>
        </trans-unit>
        <trans-unit id="ce713a708d26f349ef9d3da2c64c32c52ede1f28" translate="yes" xml:space="preserve">
          <source>AsRef::as_ref</source>
          <target state="translated">AsRef::as_ref</target>
        </trans-unit>
        <trans-unit id="a4ef661b82f652f581223b25a6824dec40ae544d" translate="yes" xml:space="preserve">
          <source>AsciiExt</source>
          <target state="translated">AsciiExt</target>
        </trans-unit>
        <trans-unit id="46e0dda46ad92722f1539fd012c3778f39c3b187" translate="yes" xml:space="preserve">
          <source>AsciiExt::eq_ignore_ascii_case</source>
          <target state="translated">AsciiExt::eq_ignore_ascii_case</target>
        </trans-unit>
        <trans-unit id="afaf433bc6efc0517fc1bdeb6f7c5eafce3e74d4" translate="yes" xml:space="preserve">
          <source>AsciiExt::is_ascii</source>
          <target state="translated">AsciiExt::is_ascii</target>
        </trans-unit>
        <trans-unit id="a117348e90cbeb6580ea282ea76b737d649c0ce2" translate="yes" xml:space="preserve">
          <source>AsciiExt::make_ascii_lowercase</source>
          <target state="translated">AsciiExt::make_ascii_lowercase</target>
        </trans-unit>
        <trans-unit id="014f8e9aa886e527dbae3bd8a29a0232814779eb" translate="yes" xml:space="preserve">
          <source>AsciiExt::make_ascii_uppercase</source>
          <target state="translated">AsciiExt::make_ascii_uppercase</target>
        </trans-unit>
        <trans-unit id="ac47518e69af0774bb76855d1ba4fd45ba076dbb" translate="yes" xml:space="preserve">
          <source>AsciiExt::to_ascii_lowercase</source>
          <target state="translated">AsciiExt::to_ascii_lowercase</target>
        </trans-unit>
        <trans-unit id="e04741744413a75fb42c855cb8f9068dc93b7a29" translate="yes" xml:space="preserve">
          <source>AsciiExt::to_ascii_uppercase</source>
          <target state="translated">AsciiExt::to_ascii_uppercase</target>
        </trans-unit>
        <trans-unit id="f99c599e0e3924b919cda05ade321af8f7909739" translate="yes" xml:space="preserve">
          <source>Aside from the closing curly brackets, there&amp;rsquo;s only one more line to discuss in the code added so far, which is the following:</source>
          <target state="translated">닫는 중괄호 외에도 지금까지 추가 된 코드에서 논의 할 줄이 하나 더 있습니다. 이는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ccfa1ea33000ed1fdc5e32d6d85a1f23b351c53c" translate="yes" xml:space="preserve">
          <source>Asked how long the string is, you might say 12. However, Rust&amp;rsquo;s answer is 24: that&amp;rsquo;s the number of bytes it takes to encode &amp;ldquo;Здравствуйте&amp;rdquo; in UTF-8, because each Unicode scalar value in that string takes 2 bytes of storage. Therefore, an index into the string&amp;rsquo;s bytes will not always correlate to a valid Unicode scalar value. To demonstrate, consider this invalid Rust code:</source>
          <target state="translated">문자열의 길이를 물으면 12라고 말할 수 있습니다. 그러나 Rust의 대답은 24입니다. 이는 문자열의 각 유니 코드 스칼라 값이 2 바이트의 저장 공간을 차지하기 때문에 UTF-8로 &quot;Здравствуйте&quot;를 인코딩하는 데 필요한 바이트 수입니다. 따라서 문자열 바이트에 대한 인덱스가 항상 유효한 유니 코드 스칼라 값과 상관되지는 않습니다. 시연하려면이 잘못된 녹 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e7689cb162bee3d282a7b39ef7b90263d73428fa" translate="yes" xml:space="preserve">
          <source>Assert the results are what you expect.</source>
          <target state="translated">결과가 당신이 기대하는 것이라고 주장하십시오.</target>
        </trans-unit>
        <trans-unit id="14ec22b40bdfb6faadf461156fa13c1003c498f7" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe</source>
          <target state="translated">AssertUnwindSafe</target>
        </trans-unit>
        <trans-unit id="b22e5cc4bce8496592970be5b25d370d67581697" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::borrow</source>
          <target state="translated">AssertUnwindSafe::borrow</target>
        </trans-unit>
        <trans-unit id="e9b2629172195580950a107f4837fef269c6587e" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::borrow_mut</source>
          <target state="translated">AssertUnwindSafe::borrow_mut</target>
        </trans-unit>
        <trans-unit id="65951f8f36689c68821ae0439274d4a0186d7055" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::call_once</source>
          <target state="translated">AssertUnwindSafe::call_once</target>
        </trans-unit>
        <trans-unit id="846bd763b3f520ae6051ff0597c886f310c2c6ea" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::deref</source>
          <target state="translated">AssertUnwindSafe::deref</target>
        </trans-unit>
        <trans-unit id="0f7f2436811897e328934158a966a543668732f9" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::deref_mut</source>
          <target state="translated">AssertUnwindSafe::deref_mut</target>
        </trans-unit>
        <trans-unit id="df50057fe584f587876a9e064fa1ae0b0acfbda2" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::fmt</source>
          <target state="translated">AssertUnwindSafe::fmt</target>
        </trans-unit>
        <trans-unit id="d34a0fd3c126015a7f7ea1d7a1780f16da8c0c7f" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::from</source>
          <target state="translated">AssertUnwindSafe::from</target>
        </trans-unit>
        <trans-unit id="bc1f4df4473c05cd44c2d50adf3e2f9062513d4c" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::into</source>
          <target state="translated">AssertUnwindSafe::into</target>
        </trans-unit>
        <trans-unit id="3b850d0a322410d738f80adc8cf728ee8170ee1d" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::poll</source>
          <target state="translated">AssertUnwindSafe::poll</target>
        </trans-unit>
        <trans-unit id="daed5606c5d5daf7eeeb4806493948f969bf4f99" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::try_from</source>
          <target state="translated">AssertUnwindSafe::try_from</target>
        </trans-unit>
        <trans-unit id="eb82a427dc920b4169ca7e00269601d2ac319ce2" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::try_into</source>
          <target state="translated">AssertUnwindSafe::try_into</target>
        </trans-unit>
        <trans-unit id="9f7d994301cc07488a1ff2b7d4c3da5dab748286" translate="yes" xml:space="preserve">
          <source>AssertUnwindSafe::type_id</source>
          <target state="translated">AssertUnwindSafe::type_id</target>
        </trans-unit>
        <trans-unit id="caf84242142f24165f73b39c5c6b3d3bc20e5c26" translate="yes" xml:space="preserve">
          <source>Assertions are always checked in both debug and release builds, and cannot be disabled. See &lt;a href=&quot;macro.debug_assert&quot;&gt;&lt;code&gt;debug_assert!&lt;/code&gt;&lt;/a&gt; for assertions that are not enabled in release builds by default.</source>
          <target state="translated">어설 션은 항상 디버그 및 릴리스 빌드 모두에서 확인되며 비활성화 할 수 없습니다. &lt;a href=&quot;macro.debug_assert&quot;&gt; &lt;code&gt;debug_assert!&lt;/code&gt; &lt;/a&gt; 참조하십시오 !릴리스 빌드에서 기본적으로 사용되지 않는 어설 션의 경우</target>
        </trans-unit>
        <trans-unit id="e17cdfab7869a902dcf07cf1a4cdf602ea080d95" translate="yes" xml:space="preserve">
          <source>Asserts that a boolean expression is &lt;code&gt;true&lt;/code&gt; at runtime.</source>
          <target state="translated">부울 표현식이 &lt;code&gt;true&lt;/code&gt; 임을 주장 합니다. 런타임에 .</target>
        </trans-unit>
        <trans-unit id="2cab5457990719d367e9e18b69d1f9cf567a9ba6" translate="yes" xml:space="preserve">
          <source>Asserts that two expressions are equal to each other (using &lt;a href=&quot;cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; 서로 동일하다고 주장합니다 ( PartialEq 사용) . 합니다.</target>
        </trans-unit>
        <trans-unit id="ebf68c5dd99f7adc415f813d7cd9a9965b251c70" translate="yes" xml:space="preserve">
          <source>Asserts that two expressions are equal to each other.</source>
          <target state="translated">두 표현식이 서로 같다고 주장합니다.</target>
        </trans-unit>
        <trans-unit id="c856365534a0e73e93b9d798530cb553f48e1b9c" translate="yes" xml:space="preserve">
          <source>Asserts that two expressions are not equal to each other (using &lt;a href=&quot;cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">두 표현식이 서로 같지 &lt;a href=&quot;cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt; ( PartialEq 사용 ).</target>
        </trans-unit>
        <trans-unit id="4b3283be054a95811542a229062df29f52cd4b0a" translate="yes" xml:space="preserve">
          <source>Asserts that two expressions are not equal to each other.</source>
          <target state="translated">두 표현식이 서로 같지 않다고 주장합니다.</target>
        </trans-unit>
        <trans-unit id="6a70c6eb716321451f69851e0a0b3e6de46cfe0a" translate="yes" xml:space="preserve">
          <source>Assignment expressions</source>
          <target state="translated">대입 식</target>
        </trans-unit>
        <trans-unit id="db7b4a247e0cd4b439f9a236f4dd17ca687d0c37" translate="yes" xml:space="preserve">
          <source>Assignment of &lt;code&gt;A + B&lt;/code&gt; to &lt;code&gt;A&lt;/code&gt; might be removed, since the sum can be stored in a temporary location until it gets printed, with the global variable never getting updated.</source>
          <target state="translated">할당 &lt;code&gt;A + B&lt;/code&gt; 에 &lt;code&gt;A&lt;/code&gt; 그것을 인쇄 할 때까지 합계가 결코 업데이트되지 점점 글로벌 변수, 임시 위치에 저장 될 수 있기 때문에, 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb5a2f19ac5c2fbe53a27d32c54a5315d8390b9c" translate="yes" xml:space="preserve">
          <source>Assignment/equivalence</source>
          <target state="translated">Assignment/equivalence</target>
        </trans-unit>
        <trans-unit id="1ec71ff0ba20c7a0026ccba467326b673793511e" translate="yes" xml:space="preserve">
          <source>Assignments are not allowed in pattern guards, because matching cannot have side effects. Side effects could alter the matched object or the environment on which the match depends in such a way, that the match would not be exhaustive. For instance, the following would not match any arm if assignments were allowed:</source>
          <target state="translated">일치는 부작용을 가질 수 없으므로 패턴 가드에는 지정이 허용되지 않습니다. 부작용으로 인해 일치하는 개체 또는 일치하는 환경이 변경되어 일치하는 항목이 완전하지 않을 수 있습니다. 예를 들어, 할당이 허용 된 경우 다음은 팔과 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="681eeaa9b3a793bf0806817da80c3be3c3a0567b" translate="yes" xml:space="preserve">
          <source>Assigns a new value to the memory behind the pinned reference.</source>
          <target state="translated">고정 된 참조 뒤의 메모리에 새로운 값을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="b443e8292f53b80a70f9ceabc76037bb4e254686" translate="yes" xml:space="preserve">
          <source>Associated Constants</source>
          <target state="translated">관련 상수</target>
        </trans-unit>
        <trans-unit id="aea3ba1170590168c2a8d38c0934f41a1081bd96" translate="yes" xml:space="preserve">
          <source>Associated Constants Examples</source>
          <target state="translated">관련 상수 예</target>
        </trans-unit>
        <trans-unit id="eb724e00631164f5e2c7a1805aa66c501706a7b7" translate="yes" xml:space="preserve">
          <source>Associated Functions</source>
          <target state="translated">관련 기능</target>
        </trans-unit>
        <trans-unit id="b9d6b786d3dce88371ca3fec1b3f0f5dcc494947" translate="yes" xml:space="preserve">
          <source>Associated Items</source>
          <target state="translated">관련 아이템</target>
        </trans-unit>
        <trans-unit id="26904b659cb34afa59632d8007e5d7c3c1f7672c" translate="yes" xml:space="preserve">
          <source>Associated Types</source>
          <target state="translated">관련 유형</target>
        </trans-unit>
        <trans-unit id="d854ee9b0fbbb41a1a8293a522b3a7fd759f3935" translate="yes" xml:space="preserve">
          <source>Associated Types Container Example</source>
          <target state="translated">연관된 유형 컨테이너 예제</target>
        </trans-unit>
        <trans-unit id="6176d44495c67b15b26948f8a03f37c611fcd9c1" translate="yes" xml:space="preserve">
          <source>Associated constants, functions, and types</source>
          <target state="translated">관련 상수, 함수 및 유형</target>
        </trans-unit>
        <trans-unit id="bf8fe32d8bff33aaf1adf4d6ce640603da967659" translate="yes" xml:space="preserve">
          <source>Associated functions and methods</source>
          <target state="translated">관련 기능 및 방법</target>
        </trans-unit>
        <trans-unit id="ca7658fbd81144f975e114c63e67d2067128142d" translate="yes" xml:space="preserve">
          <source>Associated functions are often used for constructors that will return a new instance of the struct. For example, we could provide an associated function that would have one dimension parameter and use that as both width and height, thus making it easier to create a square &lt;code&gt;Rectangle&lt;/code&gt; rather than having to specify the same value twice:</source>
          <target state="translated">연관된 함수는 종종 구조체의 새 인스턴스를 반환하는 생성자에 사용됩니다. 예를 들어, 하나의 차원 매개 변수를 가진 관련 함수를 제공하고이를 너비와 높이 로 사용하여 동일한 값을 두 번 지정하지 않고 사각형 &lt;code&gt;Rectangle&lt;/code&gt; 쉽게 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d8027bfb0422adf6fa755c7366da969f12a3f99" translate="yes" xml:space="preserve">
          <source>Associated functions whose first parameter is named &lt;code&gt;self&lt;/code&gt; are called &lt;em&gt;methods&lt;/em&gt; and may be invoked using the &lt;a href=&quot;../expressions/method-call-expr&quot;&gt;method call operator&lt;/a&gt;, for example, &lt;code&gt;x.foo()&lt;/code&gt;, as well as the usual function call notation.</source>
          <target state="translated">첫 번째 매개 변수 이름이 &lt;code&gt;self&lt;/code&gt; 인 연관된 함수를 &lt;em&gt;메소드&lt;/em&gt; 라고하며 , &lt;a href=&quot;../expressions/method-call-expr&quot;&gt;메소드 호출 연산자 &lt;/a&gt; &lt;code&gt;x.foo()&lt;/code&gt; 예 : x.foo () 및 일반 함수 호출 표기법 ) 를 사용하여 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="50f4dee25317e303fd0eeee4d556e246ef57db0b" translate="yes" xml:space="preserve">
          <source>Associated item</source>
          <target state="translated">관련 아이템</target>
        </trans-unit>
        <trans-unit id="4627f0f1df7ed7ad7efce2d0583317bf3d8df511" translate="yes" xml:space="preserve">
          <source>Associated item for a type that cannot be directly named (e.g., &lt;code&gt;&amp;lt;&amp;amp;T&amp;gt;::...&lt;/code&gt;, &lt;code&gt;&amp;lt;[T]&amp;gt;::...&lt;/code&gt;, etc.)</source>
          <target state="translated">직접 이름을 지정할 수없는 유형의 관련 항목 (예 : &lt;code&gt;&amp;lt;&amp;amp;T&amp;gt;::...&lt;/code&gt; , &lt;code&gt;&amp;lt;[T]&amp;gt;::...&lt;/code&gt; 등)</target>
        </trans-unit>
        <trans-unit id="f0dda5ab7ff2aba410ad872aa8c289173200dd02" translate="yes" xml:space="preserve">
          <source>Associated items are useful when the associated item logically is related to the associating item. For example, the &lt;code&gt;is_some&lt;/code&gt; method on &lt;code&gt;Option&lt;/code&gt; is intrinsically related to Options, so should be associated.</source>
          <target state="translated">관련 항목은 관련 항목이 논리적으로 관련 항목과 관련이있을 때 유용합니다. 예를 들어, &lt;code&gt;Option&lt;/code&gt; 의 &lt;code&gt;is_some&lt;/code&gt; 메소드 는 본질적으로 옵션과 관련되어 있으므로 연관되어야합니다.</target>
        </trans-unit>
        <trans-unit id="13ba4a748e2d8dab765ce941e0df6910e63030e1" translate="yes" xml:space="preserve">
          <source>Associated searcher for this pattern</source>
          <target state="translated">이 패턴과 관련된 검색 자</target>
        </trans-unit>
        <trans-unit id="ce35cedae86fe81ca2cf2bcb725660816d309811" translate="yes" xml:space="preserve">
          <source>Associated type for &lt;code&gt;&amp;lt;&amp;amp;[char] as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;amp;[char] as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt; 대한 연관된 ​​유형 .</target>
        </trans-unit>
        <trans-unit id="e195d76e814dc3f6b09416fe019701da4141e61f" translate="yes" xml:space="preserve">
          <source>Associated type for &lt;code&gt;&amp;lt;&amp;amp;str as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;amp;str as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt; 대한 관련 유형 .</target>
        </trans-unit>
        <trans-unit id="da9f3600b580da18821fb0932aa55c1e82dc8484" translate="yes" xml:space="preserve">
          <source>Associated type for &lt;code&gt;&amp;lt;F as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;F as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt; 연관된 유형 .</target>
        </trans-unit>
        <trans-unit id="470b87bc44e9aa3c27db7ff27c851ded51a493f4" translate="yes" xml:space="preserve">
          <source>Associated type for &lt;code&gt;&amp;lt;char as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;char as Pattern&amp;lt;'a&amp;gt;&amp;gt;::Searcher&lt;/code&gt; 대한 연관된 ​​유형 .</target>
        </trans-unit>
        <trans-unit id="4b2aeb71be1e33f6aef873e1957563d04f8d17e0" translate="yes" xml:space="preserve">
          <source>Associated types from &lt;code&gt;Trait&lt;/code&gt; can be used.</source>
          <target state="translated">&lt;code&gt;Trait&lt;/code&gt; 의 관련 유형을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b94fe8e8235a5eac0ea7986a3bc24833e5f55164" translate="yes" xml:space="preserve">
          <source>Associated types might seem like a similar concept to generics, in that the latter allow us to define a function without specifying what types it can handle. So why use associated types?</source>
          <target state="translated">연관된 유형은 제네릭과 유사한 개념으로 보일 수 있는데, 후자는 처리 할 수있는 유형을 지정하지 않고 함수를 정의 할 수 있다는 점에서 다릅니다. 왜 관련 유형을 사용합니까?</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="434de15a9f2e5951652f37ae43c858535ba0b678" translate="yes" xml:space="preserve">
          <source>Assume there are two files in the same directory with the following contents:</source>
          <target state="translated">동일한 디렉토리에 다음 내용을 가진 두 개의 파일이 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="9c07290f30084dee9d612cccf40372822beeda08" translate="yes" xml:space="preserve">
          <source>Assumes that the slice is sorted by the key, for instance with &lt;a href=&quot;#method.sort_by_key&quot;&gt;&lt;code&gt;sort_by_key&lt;/code&gt;&lt;/a&gt; using the same key extraction function.</source>
          <target state="translated">슬라이스가 키를 기준으로 정렬되어 있다고 가정합니다 (예 : 동일한 키 추출 기능을 사용하는 &lt;a href=&quot;#method.sort_by_key&quot;&gt; &lt;code&gt;sort_by_key&lt;/code&gt; &lt;/a&gt; 사용).</target>
        </trans-unit>
        <trans-unit id="c924c9518b3ab961e095e1c3fb8fc583399ec253" translate="yes" xml:space="preserve">
          <source>Assuming there&amp;rsquo;s a file named &lt;code&gt;foo.txt&lt;/code&gt; with contents &lt;code&gt;abcdef\n&lt;/code&gt;, create two handles, seek one of them, and read the remaining bytes from the other handle:</source>
          <target state="translated">내용이 &lt;code&gt;abcdef\n&lt;/code&gt; 인 &lt;code&gt;foo.txt&lt;/code&gt; 라는 파일이 있다고 가정하고 두 개의 핸들을 작성하고 그 중 하나를 찾고 다른 핸들에서 나머지 바이트를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="31936e0a0d8572ee4060f19296edebc34a7f6f8c" translate="yes" xml:space="preserve">
          <source>Asterisk glob imports will import items imported with &lt;code&gt;_&lt;/code&gt; in their unnameable form.</source>
          <target state="translated">별표 글로브 가져 오기는 &lt;code&gt;_&lt;/code&gt; 로 가져온 항목을 가져옵니다. 는 이름이없는 형태 로 .</target>
        </trans-unit>
        <trans-unit id="c318095156a540e68b8cc7d9ad9ab72fce83a154" translate="yes" xml:space="preserve">
          <source>Asynchronous values.</source>
          <target state="translated">비동기 값.</target>
        </trans-unit>
        <trans-unit id="0855009c46728a5c8cb9aa53860e3b38d932c17a" translate="yes" xml:space="preserve">
          <source>At</source>
          <target state="translated">At</target>
        </trans-unit>
        <trans-unit id="d9cacf1832e8829a2c65089757588eeeacfc9330" translate="yes" xml:space="preserve">
          <source>At all times, you must avoid data races. If multiple threads have access to the same &lt;code&gt;UnsafeCell&lt;/code&gt;, then any writes must have a proper happens-before relation to all other accesses (or use atomics).</source>
          <target state="translated">항상 데이터 경쟁을 피해야합니다. 여러 스레드가 동일한 &lt;code&gt;UnsafeCell&lt;/code&gt; 에 액세스 할 수있는 경우 다른 모든 액세스 (또는 원자 사용)와 관련하여 쓰기 작업이 올바르게 수행되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c68169e0fac1472856a75bc093cd4e904a65d3b5" translate="yes" xml:space="preserve">
          <source>At any given time, you can have &lt;em&gt;either&lt;/em&gt; (but not both of) one mutable reference or any number of immutable references.</source>
          <target state="translated">주어진 시간에, 당신은 할 수 있습니다 &lt;em&gt;중 하나&lt;/em&gt; (모두는 아니지만) 하나 변경 가능한 참조 또는 불변의 참조의 수입니다.</target>
        </trans-unit>
        <trans-unit id="97c27bc0fbd95b57400fcf731e3e7a7d89c5cf2f" translate="yes" xml:space="preserve">
          <source>At any given time, you can have &lt;em&gt;either&lt;/em&gt; one mutable reference &lt;em&gt;or&lt;/em&gt; any number of immutable references.</source>
          <target state="translated">주어진 시간에, 당신은 할 수 있습니다 &lt;em&gt;중&lt;/em&gt; 하나 변경 가능한 참조 &lt;em&gt;또는&lt;/em&gt; 불변의 참조의 수입니다.</target>
        </trans-unit>
        <trans-unit id="b790d9edc1873ab13071956060a912cd284deda5" translate="yes" xml:space="preserve">
          <source>At compile time each implementation of &lt;code&gt;Trait&lt;/code&gt; will produce a table containing the various methods (and other items) related to the implementation.</source>
          <target state="translated">컴파일 타임에 &lt;code&gt;Trait&lt;/code&gt; 의 각 구현은 구현 과 관련된 다양한 메소드 (및 기타 항목)를 포함하는 테이블을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="26e37b1b35b52ad10610ea1ef12403fe61f658c6" translate="yes" xml:space="preserve">
          <source>At compile time, Rust needs to know how much space a type takes up. One type whose size can&amp;rsquo;t be known at compile time is a &lt;em&gt;recursive type&lt;/em&gt;, where a value can have as part of itself another value of the same type. Because this nesting of values could theoretically continue infinitely, Rust doesn&amp;rsquo;t know how much space a value of a recursive type needs. However, boxes have a known size, so by inserting a box in a recursive type definition, you can have recursive types.</source>
          <target state="translated">컴파일 타임에 Rust는 타입이 차지하는 공간을 알아야합니다. 컴파일 타임에 크기를 알 수없는 유형 중 하나는 &lt;em&gt;재귀 유형입니다&lt;/em&gt; 이며 값은 자체 유형의 일부로 동일한 유형의 다른 값을 가질 수 있습니다. 이 값 중첩은 이론적으로 무한대로 계속 될 수 있기 때문에 Rust는 재귀 유형의 값에 필요한 공간의 양을 모릅니다. 그러나 상자의 크기는 알려진 것이므로 재귀 유형 정의에 상자를 삽입하면 재귀 유형을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2f9b5afe99b75e0f39f01ec88be93443b074a9d" translate="yes" xml:space="preserve">
          <source>At each point in the program where the reference count changes, we print the reference count, which we can get by calling the &lt;code&gt;Rc::strong_count&lt;/code&gt; function. This function is named &lt;code&gt;strong_count&lt;/code&gt; rather than &lt;code&gt;count&lt;/code&gt; because the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; type also has a &lt;code&gt;weak_count&lt;/code&gt;; we&amp;rsquo;ll see what &lt;code&gt;weak_count&lt;/code&gt; is used for in the &lt;a href=&quot;ch15-06-reference-cycles#preventing-reference-cycles-turning-an-rct-into-a-weakt&quot;&gt;&amp;ldquo;Preventing Reference Cycles: Turning an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; into a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt;&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">참조 카운트가 변경되는 프로그램의 각 지점에서 &lt;code&gt;Rc::strong_count&lt;/code&gt; 함수를 호출하여 얻을 수있는 참조 카운트를 인쇄합니다 . 이 함수라는 &lt;code&gt;strong_count&lt;/code&gt; 아닌 &lt;code&gt;count&lt;/code&gt; 때문에 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 또한 A 형 갖는다 &lt;code&gt;weak_count&lt;/code&gt; 을 ; &lt;a href=&quot;ch15-06-reference-cycles#preventing-reference-cycles-turning-an-rct-into-a-weakt&quot;&gt;&quot;참조 사이클 방지 : &lt;/a&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 를 &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; &quot; 섹션 에서 &lt;code&gt;weak_count&lt;/code&gt; 가 사용되는 것을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f2afe7e487c0f1c732676abe97c30fdb7bfd5600" translate="yes" xml:space="preserve">
          <source>At first, we have no memory allocated at all, but as we append to the string, it increases its capacity appropriately. If we instead use the &lt;a href=&quot;#method.with_capacity&quot;&gt;&lt;code&gt;with_capacity&lt;/code&gt;&lt;/a&gt; method to allocate the correct capacity initially:</source>
          <target state="translated">처음에는 메모리가 전혀 할당되어 있지 않지만 문자열에 추가하면 용량이 적절하게 증가합니다. &lt;a href=&quot;#method.with_capacity&quot;&gt; &lt;code&gt;with_capacity&lt;/code&gt; &lt;/a&gt; 메소드를 대신 사용하여 처음에 올바른 용량을 할당하는 경우 :</target>
        </trans-unit>
        <trans-unit id="0295e56a89c227419234a744fcdff39f54bbbd31" translate="yes" xml:space="preserve">
          <source>At its simplest, a test in Rust is a function that&amp;rsquo;s annotated with the &lt;code&gt;test&lt;/code&gt; attribute. Attributes are metadata about pieces of Rust code; one example is the &lt;code&gt;derive&lt;/code&gt; attribute we used with structs in Chapter 5. To change a function into a test function, add &lt;code&gt;#[test]&lt;/code&gt; on the line before &lt;code&gt;fn&lt;/code&gt;. When you run your tests with the &lt;code&gt;cargo test&lt;/code&gt; command, Rust builds a test runner binary that runs the functions annotated with the &lt;code&gt;test&lt;/code&gt; attribute and reports on whether each test function passes or fails.</source>
          <target state="translated">가장 간단하게 Rust의 &lt;code&gt;test&lt;/code&gt; 는 테스트 속성으로 주석이 달린 함수입니다 . 속성은 Rust 코드에 대한 메타 데이터입니다. 한 가지 예는 5 장의 구조체와 함께 사용 하는 &lt;code&gt;derive&lt;/code&gt; 속성입니다. 함수를 테스트 함수로 변경하려면 &lt;code&gt;fn&lt;/code&gt; 앞에 줄에 &lt;code&gt;#[test]&lt;/code&gt; 를 추가하십시오 . &lt;code&gt;cargo test&lt;/code&gt; 명령으로 테스트를 실행할 때 Rust는 &lt;code&gt;test&lt;/code&gt; 속성으로 주석이 달린 함수를 실행하고 각 테스트 함수의 통과 여부를보고 하는 테스트 러너 바이너리를 빌드 합니다.</target>
        </trans-unit>
        <trans-unit id="37583ea386b39553438667ee1326a11884d8ac4d" translate="yes" xml:space="preserve">
          <source>At least one of either &lt;code&gt;Self&lt;/code&gt; or a generic type parameter of the trait must meet the following grammar, where &lt;code&gt;C&lt;/code&gt; is a nominal type defined within the containing crate:</source>
          <target state="translated">&lt;code&gt;Self&lt;/code&gt; 또는 특성의 일반 유형 매개 변수 중 하나 이상 이 다음 문법을 충족해야합니다. 여기서 &lt;code&gt;C&lt;/code&gt; 는 포함하는 상자 내에 정의 된 공칭 유형입니다.</target>
        </trans-unit>
        <trans-unit id="6340eab1a988a949757faf0b3ab2c9f1d577f929" translate="yes" xml:space="preserve">
          <source>At least one of the pointers is being used to write to the data.</source>
          <target state="translated">포인터 중 하나 이상이 데이터 쓰기에 사용되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2c9357843faff292144d5026ce32c57e9298ff6" translate="yes" xml:space="preserve">
          <source>At present, it is not permitted to have a yield that occurs while a borrow is still in scope. To resolve this error, the borrow must either be &quot;contained&quot; to a smaller scope that does not overlap the yield or else eliminated in another way. So, for example, we might resolve the previous example by removing the borrow and just storing the integer by value:</source>
          <target state="translated">현재, 대출이 여전히 범위 내에있는 동안 발생하는 수익률을 갖는 것은 허용되지 않습니다. 이 오류를 해결하려면 대출금이 수익률과 겹치지 않는 더 작은 범위로 &quot;포함&quot;되거나 다른 방법으로 제거되어야합니다. 예를 들어, 차용을 제거하고 정수를 값으로 저장하여 이전 예를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="880cb1d1611d41944fc45c1105942f35a2cea331" translate="yes" xml:space="preserve">
          <source>At the beginning of this chapter, we said that vectors can only store values that are the same type. This can be inconvenient; there are definitely use cases for needing to store a list of items of different types. Fortunately, the variants of an enum are defined under the same enum type, so when we need to store elements of a different type in a vector, we can define and use an enum!</source>
          <target state="translated">이 장의 시작 부분에서 벡터는 동일한 유형의 값만 저장할 수 있다고 말했습니다. 불편할 수 있습니다. 다른 유형의 항목 목록을 저장 해야하는 유스 케이스가 있습니다. 다행히 열거 형의 변형은 동일한 열거 형으로 정의되므로 벡터에 다른 유형의 요소를 저장해야 할 때 열거 형을 정의하고 사용할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="b0f9f410d4d3f041a8bbac0598dae49519ac5a0f" translate="yes" xml:space="preserve">
          <source>At the moment the &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks have a lot of repetition: they&amp;rsquo;re both reading files and writing the contents of the files to the stream. The only differences are the status line and the filename. Let&amp;rsquo;s make the code more concise by pulling out those differences into separate &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; lines that will assign the values of the status line and the filename to variables; we can then use those variables unconditionally in the code to read the file and write the response. Listing 20-9 shows the resulting code after replacing the large &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks.</source>
          <target state="translated">시점의 &lt;code&gt;if&lt;/code&gt; 와 &lt;code&gt;else&lt;/code&gt; 블록 반복을 많이 가지고 : 그들은 두 파일을 읽고 스트림에 파일의 내용을 작성하고 있습니다. 유일한 차이점은 상태 줄과 파일 이름입니다. 상태 라인의 값과 파일 이름을 변수에 할당하는 별도의 &lt;code&gt;if&lt;/code&gt; 및 &lt;code&gt;else&lt;/code&gt; 라인 으로 이러한 차이를 끌어내어 코드를 더 간결하게 만들어 봅시다 . 그런 다음 코드에서 변수를 무조건 사용하여 파일을 읽고 응답을 작성할 수 있습니다. Listing 20-9는 큰 &lt;code&gt;if&lt;/code&gt; 및 &lt;code&gt;else&lt;/code&gt; 블록을 교체 한 후의 결과 코드를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="1f16df13b8f4c863b823dc86f56453377891952c" translate="yes" xml:space="preserve">
          <source>At the moment, we&amp;rsquo;re writing all of our output to the terminal using the &lt;code&gt;println!&lt;/code&gt; function. Most terminals provide two kinds of output: &lt;em&gt;standard output&lt;/em&gt; (&lt;code&gt;stdout&lt;/code&gt;) for general information and &lt;em&gt;standard error&lt;/em&gt; (&lt;code&gt;stderr&lt;/code&gt;) for error messages. This distinction enables users to choose to direct the successful output of a program to a file but still print error messages to the screen.</source>
          <target state="translated">현재 &lt;code&gt;println!&lt;/code&gt; 사용하여 모든 출력을 터미널에 쓰고 있습니다 ! 함수. 대부분의 터미널은 일반 정보의 경우 &lt;em&gt;표준 출력&lt;/em&gt; ( &lt;code&gt;stdout&lt;/code&gt; )과 오류 메시지의 경우 &lt;em&gt;표준 오류&lt;/em&gt; ( &lt;code&gt;stderr&lt;/code&gt; )의 두 가지 출력을 제공 합니다. 이 구별을 통해 사용자는 프로그램의 성공적인 출력을 파일로 보내지 만 여전히 오류 메시지를 화면에 인쇄하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3818ff95eb637709816bb6cd777c917a43bae444" translate="yes" xml:space="preserve">
          <source>At the time of this writing, an automatic formatter tool called &lt;code&gt;rustfmt&lt;/code&gt; is under development. If you want to stick to a standard style across Rust projects, &lt;code&gt;rustfmt&lt;/code&gt; will format your code in a particular style. The Rust team plans to eventually include this tool with the standard Rust distribution, like &lt;code&gt;rustc&lt;/code&gt;. So depending on when you read this book, it might already be installed on your computer! Check the online documentation for more details.</source>
          <target state="translated">이 글을 쓰는 시점에서 &lt;code&gt;rustfmt&lt;/code&gt; 라는 자동 포맷터 도구 가 개발 중입니다. Rust 프로젝트에서 표준 스타일을 고수하려면 &lt;code&gt;rustfmt&lt;/code&gt; 가 특정 스타일로 코드를 포맷합니다. Rust 팀은 결국이 도구를 &lt;code&gt;rustc&lt;/code&gt; 와 같은 표준 Rust 배포판에 포함시킬 계획 입니다. 따라서이 책을 읽는 시점에 따라 컴퓨터에 이미 설치되어있을 수 있습니다! 자세한 내용은 온라인 설명서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="1eca2e64861fbf60436be0df95a81ecf4dd4db51" translate="yes" xml:space="preserve">
          <source>At the time of this writing, two Rust editions are available: Rust 2015 and Rust 2018. This book is written using Rust 2018 edition idioms.</source>
          <target state="translated">이 글을 쓰는 시점에서 Rust 2015와 Rust 2018의 두 가지 Rust 에디션을 사용할 수 있습니다.이 책은 Rust 2018 에디션 관용구를 사용하여 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="d0b83ac2e98214df1ca34576f6616d27aede53ff" translate="yes" xml:space="preserve">
          <source>At the time, we said not to worry about the inefficient &lt;code&gt;clone&lt;/code&gt; calls because we would remove them in the future. Well, that time is now!</source>
          <target state="translated">당시 우리는 비효율적 인 &lt;code&gt;clone&lt;/code&gt; 호출 에 대해서는 걱정하지 않겠다고 말했습니다 . 글쎄, 그 시간은 지금이다!</target>
        </trans-unit>
        <trans-unit id="bf023d508177d86413d3379134e446a32a09142c" translate="yes" xml:space="preserve">
          <source>At the time, we skipped over some details in this code. In Chapter 6 in &lt;a href=&quot;ch06-02-match#the-match-control-flow-operator&quot;&gt;&amp;ldquo;The &lt;code&gt;match&lt;/code&gt; Control Flow Operator&amp;rdquo;&lt;/a&gt; section, we discussed that &lt;code&gt;match&lt;/code&gt; arms must all return the same type. So, for example, the following code doesn&amp;rsquo;t work:</source>
          <target state="translated">당시에는이 코드에서 몇 가지 세부 사항을 건너 뛰었습니다. 6 장 &lt;a href=&quot;ch06-02-match#the-match-control-flow-operator&quot;&gt;&quot; &lt;code&gt;match&lt;/code&gt; 제어 흐름 연산자&quot;&lt;/a&gt; 섹션에서 &lt;code&gt;match&lt;/code&gt; 암이 모두 동일한 유형을 반환해야 한다고 논의했습니다 . 예를 들어 다음 코드는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7ade322c88e63df6a4a8c865c0fa8c7d63812d90" translate="yes" xml:space="preserve">
          <source>At this point, &lt;code&gt;cargo build&lt;/code&gt; should complete successfully in both &lt;code&gt;hello_macro&lt;/code&gt; and &lt;code&gt;hello_macro_derive&lt;/code&gt;. Let&amp;rsquo;s hook up these crates to the code in Listing 19-30 to see the procedural macro in action! Create a new binary project in your &lt;em&gt;projects&lt;/em&gt; directory using &lt;code&gt;cargo new pancakes&lt;/code&gt;. We need to add &lt;code&gt;hello_macro&lt;/code&gt; and &lt;code&gt;hello_macro_derive&lt;/code&gt; as dependencies in the &lt;code&gt;pancakes&lt;/code&gt; crate&amp;rsquo;s &lt;em&gt;Cargo.toml&lt;/em&gt;. If you&amp;rsquo;re publishing your versions of &lt;code&gt;hello_macro&lt;/code&gt; and &lt;code&gt;hello_macro_derive&lt;/code&gt; to &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;, they would be regular dependencies; if not, you can specify them as &lt;code&gt;path&lt;/code&gt; dependencies as follows:</source>
          <target state="translated">이 시점 에서 &lt;code&gt;hello_macro&lt;/code&gt; 및 &lt;code&gt;hello_macro_derive&lt;/code&gt; 모두에서 &lt;code&gt;cargo build&lt;/code&gt; 가 성공적으로 완료되어야합니다 . 절차 적 매크로가 실제로 작동하는지 확인하려면이 상자를 Listing 19-30의 코드에 연결해 보자! &lt;code&gt;cargo new pancakes&lt;/code&gt; 를 사용 하여 &lt;em&gt;프로젝트&lt;/em&gt; 디렉토리 에 새 바이너리 프로젝트를 작성하십시오 . &lt;code&gt;pancakes&lt;/code&gt; 상자의 &lt;em&gt;Cargo.toml에&lt;/em&gt; 종속 &lt;code&gt;hello_macro_derive&lt;/code&gt; 으로 &lt;code&gt;hello_macro&lt;/code&gt; 및 hello_macro_derive 를 추가해야합니다 . 다음과 같이 &lt;code&gt;hello_macro&lt;/code&gt; 및 &lt;code&gt;hello_macro_derive&lt;/code&gt; 버전 을 &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io &lt;/a&gt; &lt;code&gt;path&lt;/code&gt; 종속성에 게시하는 경우 :&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt; , 그들은 정기적으로 종속 될 것이다; 그렇지 않은 경우 다음과 같이 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b945ef4a755c9f52a155f619e7f39f1e0b11da63" translate="yes" xml:space="preserve">
          <source>At this point, &lt;code&gt;s&lt;/code&gt; will be &lt;code&gt;tic-tac-toe&lt;/code&gt;. With all of the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;&quot;&lt;/code&gt; characters, it&amp;rsquo;s difficult to see what&amp;rsquo;s going on. For more complicated string combining, we can use the &lt;code&gt;format!&lt;/code&gt; macro:</source>
          <target state="translated">이 시점에서 &lt;code&gt;s&lt;/code&gt; 는 &lt;code&gt;tic-tac-toe&lt;/code&gt; 가 됩니다. 모든 &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;&quot;&lt;/code&gt; 문자를 사용하면 현재 상황을 파악하기가 어렵습니다.보다 복잡한 문자열 결합을 위해서는 &lt;code&gt;format!&lt;/code&gt; 사용할 수 있습니다 ! 매크로 :</target>
        </trans-unit>
        <trans-unit id="bad906bb2d4d513518792ef63a17dbb628e284cd" translate="yes" xml:space="preserve">
          <source>At this point, the first part of the game is done: we&amp;rsquo;re getting input from the keyboard and then printing it.</source>
          <target state="translated">이제 게임의 첫 부분이 완료되었습니다. 키보드에서 입력을받은 다음 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="645fa0bc97b2e92b8b41b6c72b5e6804e2731419" translate="yes" xml:space="preserve">
          <source>At this point, the relationship between scopes and when variables are valid is similar to that in other programming languages. Now we&amp;rsquo;ll build on top of this understanding by introducing the &lt;code&gt;String&lt;/code&gt; type.</source>
          <target state="translated">이 시점에서 범위와 변수가 유효한시기의 관계는 다른 프로그래밍 언어의 관계와 유사합니다. 이제 우리는 &lt;code&gt;String&lt;/code&gt; 타입 을 소개함으로써 이러한 이해를 바탕으로 구축 할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="440b2812ba3e248d39262c445df6cb473f1a4cf8" translate="yes" xml:space="preserve">
          <source>At this point, we can build the workspace by running &lt;code&gt;cargo build&lt;/code&gt;. The files in your &lt;em&gt;add&lt;/em&gt; directory should look like this:</source>
          <target state="translated">이제 &lt;code&gt;cargo build&lt;/code&gt; 를 실행하여 작업 공간을 빌드 할 수 있습니다 . &lt;em&gt;add&lt;/em&gt; 디렉토리 의 파일 은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="7be13e6f2293ee19341faecbce38cbce6581638c" translate="yes" xml:space="preserve">
          <source>At this point, we could consider opportunities for refactoring the implementation of the search function while keeping the tests passing to maintain the same functionality. The code in the search function isn&amp;rsquo;t too bad, but it doesn&amp;rsquo;t take advantage of some useful features of iterators. We&amp;rsquo;ll return to this example in [Chapter 13][ch13], where we&amp;rsquo;ll explore iterators in detail, and look at how to improve it.</source>
          <target state="translated">이 시점에서 우리는 동일한 기능을 유지하기 위해 테스트를 통과하면서 검색 기능의 구현을 리팩토링 할 수있는 기회를 고려할 수있었습니다. 검색 기능의 코드는 나쁘지 않지만 반복자의 유용한 기능을 활용하지는 않습니다. 이 예제로 돌아가서 [Chapter 13] [ch13]에서 반복자를 자세히 살펴보고 개선 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="12d2e7392939d54c75dd7be38b3f433458f57624" translate="yes" xml:space="preserve">
          <source>At this point, when we call &lt;code&gt;content&lt;/code&gt; on the &lt;code&gt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&lt;/code&gt;, deref coercion will take effect on the &lt;code&gt;&amp;amp;&lt;/code&gt; and the &lt;code&gt;Box&lt;/code&gt; so the &lt;code&gt;content&lt;/code&gt; method will ultimately be called on the type that implements the &lt;code&gt;State&lt;/code&gt; trait. That means we need to add &lt;code&gt;content&lt;/code&gt; to the &lt;code&gt;State&lt;/code&gt; trait definition, and that is where we&amp;rsquo;ll put the logic for what content to return depending on which state we have, as shown in Listing 17-18:</source>
          <target state="translated">이 시점 에서 &lt;code&gt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&lt;/code&gt; 에서 &lt;code&gt;content&lt;/code&gt; 를 호출 할 때 , deref 강제가 &lt;code&gt;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;Box&lt;/code&gt; 에 영향을 미치 므로 궁극적으로 &lt;code&gt;State&lt;/code&gt; 특성 을 구현하는 유형 에서 &lt;code&gt;content&lt;/code&gt; 메소드가 호출됩니다 . 즉 , &lt;code&gt;State&lt;/code&gt; 특성 정의 에 &lt;code&gt;content&lt;/code&gt; 를 추가해야하며 , 여기서는 상태 17-18에 표시된대로 상태에 따라 리턴 할 컨텐츠에 대한 논리를 배치합니다.</target>
        </trans-unit>
        <trans-unit id="41d03c60eead1f80179e902c1b4d9814280d6245" translate="yes" xml:space="preserve">
          <source>At this point, when we try to get a reference to the parent of &lt;code&gt;leaf&lt;/code&gt; by using the &lt;code&gt;upgrade&lt;/code&gt; method, we get a &lt;code&gt;None&lt;/code&gt; value. We see this in the output from the first &lt;code&gt;println!&lt;/code&gt; statement:</source>
          <target state="translated">이 시점 에서 &lt;code&gt;upgrade&lt;/code&gt; 메소드 를 사용하여 &lt;code&gt;leaf&lt;/code&gt; 의 부모에 대한 참조를 얻으려고하면 &lt;code&gt;None&lt;/code&gt; 값을 얻습니다 . 우리는 이것을 첫 번째 &lt;code&gt;println!&lt;/code&gt; 의 출력에서 ​​볼 수 있습니다 ! 성명서:</target>
        </trans-unit>
        <trans-unit id="3822c3ca41678f3e73f1513ee4103e0d10a48e3d" translate="yes" xml:space="preserve">
          <source>At this point, you would also notice a change in your &lt;em&gt;Cargo.lock&lt;/em&gt; file noting that the version of the &lt;code&gt;rand&lt;/code&gt; crate you are now using is &lt;code&gt;0.3.15&lt;/code&gt;.</source>
          <target state="translated">이 시점에서 현재 사용중인 &lt;code&gt;rand&lt;/code&gt; 크레이트 의 버전이 &lt;em&gt;0.3.15임을 나타내는 Cargo.lock&lt;/em&gt; 파일 이 변경 &lt;code&gt;0.3.15&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="ace63d2aec4c0fa2eb5be485664adddc5d8c8911" translate="yes" xml:space="preserve">
          <source>At this point, you&amp;rsquo;ve seen several ways of using patterns, but patterns don&amp;rsquo;t work the same in every place we can use them. In some places, the patterns must be irrefutable; in other circumstances, they can be refutable. We&amp;rsquo;ll discuss these two concepts next.</source>
          <target state="translated">이 시점에서 패턴을 사용하는 몇 가지 방법을 보았지만 패턴을 사용할 수있는 모든 곳에서 패턴이 동일하게 작동하지는 않습니다. 어떤 곳에서는 패턴을 반박 할 수 없어야합니다. 다른 상황에서는 반박 할 수 있습니다. 다음에이 두 가지 개념에 대해 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="e19eb30ab901969b293ab5f50d80d0816b9dd309" translate="yes" xml:space="preserve">
          <source>At this point, you&amp;rsquo;ve successfully built the guessing game. Congratulations!</source>
          <target state="translated">이제 추측 게임을 성공적으로 구축했습니다. 축하합니다!</target>
        </trans-unit>
        <trans-unit id="632731832807bd949f8afaff185b846c11bff1a6" translate="yes" xml:space="preserve">
          <source>Atomic Reference Counting with &lt;code id=&quot;atomic-reference-counting-with-arct&quot;&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;atomic-reference-counting-with-arct&quot;&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; 사용한 원자 기준 카운팅</target>
        </trans-unit>
        <trans-unit id="81578fbf1ea44596108fd645f27e6431bf82318a" translate="yes" xml:space="preserve">
          <source>Atomic memory orderings</source>
          <target state="translated">원자 메모리 주문</target>
        </trans-unit>
        <trans-unit id="7d5338021e809e34d20a6b06646a458b5152b9dc" translate="yes" xml:space="preserve">
          <source>Atomic operations may be implemented at the instruction layer with larger-size atomics. For example some platforms use 4-byte atomic instructions to implement &lt;code&gt;AtomicI8&lt;/code&gt;. Note that this emulation should not have an impact on correctness of code, it's just something to be aware of.</source>
          <target state="translated">원자 연산은 더 큰 크기의 원자를 갖는 명령 계층에서 구현 될 수있다. 예를 들어, 일부 플랫폼은 4 바이트 원자 명령어를 사용하여 &lt;code&gt;AtomicI8&lt;/code&gt; 을 구현 합니다 . 이 에뮬레이션은 코드의 정확성에 영향을 미치지 않아야한다는 점에 유의해야합니다.</target>
        </trans-unit>
        <trans-unit id="8e24008909c0fc6f23ca4f4f874bb53512815caa" translate="yes" xml:space="preserve">
          <source>Atomic operations with &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; semantics can also synchronize with a fence.</source>
          <target state="translated">&lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; 시맨틱을 사용한 원자 작업 은 펜스와 동기화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bd53298c2672a3d3501c1b3d668970f3f55e051" translate="yes" xml:space="preserve">
          <source>Atomic types</source>
          <target state="translated">원자 유형</target>
        </trans-unit>
        <trans-unit id="bd540eaa28be66ef79bdb0e6dc9e7f21a135c077" translate="yes" xml:space="preserve">
          <source>Atomic types may be stored in static variables, initialized using the constant initializers like &lt;a href=&quot;struct.atomicbool#method.new&quot;&gt;&lt;code&gt;AtomicBool::new&lt;/code&gt;&lt;/a&gt;. Atomic statics are often used for lazy global initialization.</source>
          <target state="translated">원자 유형은 정적 변수에 저장 될 수 있으며 &lt;a href=&quot;struct.atomicbool#method.new&quot;&gt; &lt;code&gt;AtomicBool::new&lt;/code&gt; &lt;/a&gt; 와 같은 상수 이니셜 라이저를 사용하여 초기화 됩니다. 원자 정적은 종종 게으른 전역 초기화에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="af8191cce263e5511ffa70b9167ccc44038ee579" translate="yes" xml:space="preserve">
          <source>Atomic types provide primitive shared-memory communication between threads, and are the building blocks of other concurrent types.</source>
          <target state="translated">원자 유형은 스레드간에 기본 공유 메모리 통신을 제공하며 다른 동시 유형의 빌딩 블록입니다.</target>
        </trans-unit>
        <trans-unit id="bdcc7b682e49710ce243d11d666d0605dd24412a" translate="yes" xml:space="preserve">
          <source>Atomic variables are safe to share between threads (they implement &lt;a href=&quot;../../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;) but they do not themselves provide the mechanism for sharing and follow the &lt;a href=&quot;../../thread/index#the-threading-model&quot;&gt;threading model&lt;/a&gt; of rust. The most common way to share an atomic variable is to put it into an &lt;a href=&quot;../struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; (an atomically-reference-counted shared pointer).</source>
          <target state="translated">원자 변수는 스레드간에 공유하기에 안전 하지만 ( &lt;a href=&quot;../../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; 구현 ) 스레드 자체 의 녹 &lt;a href=&quot;../../thread/index#the-threading-model&quot;&gt;모델&lt;/a&gt; 을 공유하고 따르는 메커니즘을 제공하지는 않습니다 . 원자 변수를 공유하는 가장 일반적인 방법은에 넣어하는 &lt;a href=&quot;../struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; (극히 미세 - 참조 카운트 공유 포인터).</target>
        </trans-unit>
        <trans-unit id="6674d00db7a2e69964175c1325e3eccae698e4d3" translate="yes" xml:space="preserve">
          <source>AtomicBool</source>
          <target state="translated">AtomicBool</target>
        </trans-unit>
        <trans-unit id="c3f581e842f52532b7b151cdbc4ce7233b954e8c" translate="yes" xml:space="preserve">
          <source>AtomicI16</source>
          <target state="translated">AtomicI16</target>
        </trans-unit>
        <trans-unit id="29b774c369d481cc7134a7a13427afa21b7fc9cd" translate="yes" xml:space="preserve">
          <source>AtomicI32</source>
          <target state="translated">AtomicI32</target>
        </trans-unit>
        <trans-unit id="d734b8bd0031516fdc53fb6831e8dec9b067b165" translate="yes" xml:space="preserve">
          <source>AtomicI64</source>
          <target state="translated">AtomicI64</target>
        </trans-unit>
        <trans-unit id="e94562e900680db9e18fda42ce322ce7a5e558bf" translate="yes" xml:space="preserve">
          <source>AtomicI8</source>
          <target state="translated">AtomicI8</target>
        </trans-unit>
        <trans-unit id="c2cc2ca63393294d4014028c732f15eca926e7a2" translate="yes" xml:space="preserve">
          <source>AtomicIsize</source>
          <target state="translated">AtomicIsize</target>
        </trans-unit>
        <trans-unit id="7bc45caa3c8c7a6bbad87dd4b67403e414361ce1" translate="yes" xml:space="preserve">
          <source>AtomicPtr</source>
          <target state="translated">AtomicPtr</target>
        </trans-unit>
        <trans-unit id="17a70c0c14e8b2c47d91d2253122896320428148" translate="yes" xml:space="preserve">
          <source>AtomicU16</source>
          <target state="translated">AtomicU16</target>
        </trans-unit>
        <trans-unit id="8840103173e424948e002b5ffec50c44e404d250" translate="yes" xml:space="preserve">
          <source>AtomicU32</source>
          <target state="translated">AtomicU32</target>
        </trans-unit>
        <trans-unit id="32ac2d92ec899ed90a2638fc480a4297cef99b45" translate="yes" xml:space="preserve">
          <source>AtomicU64</source>
          <target state="translated">AtomicU64</target>
        </trans-unit>
        <trans-unit id="a496370705e1f84302673bc11932128de26a2fea" translate="yes" xml:space="preserve">
          <source>AtomicU8</source>
          <target state="translated">AtomicU8</target>
        </trans-unit>
        <trans-unit id="9d9469a55330492f15842defa35b0f1ef07cac12" translate="yes" xml:space="preserve">
          <source>AtomicUsize</source>
          <target state="translated">AtomicUsize</target>
        </trans-unit>
        <trans-unit id="48c5fb201c75414dd3666a318d954dd873099b2d" translate="yes" xml:space="preserve">
          <source>Atomically makes the handle's token available if it is not already.</source>
          <target state="translated">핸들의 토큰을 아직 사용할 수없는 경우 원자 적으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="22cd0cbd81dee9dcd227285a4fb456261af24ea4" translate="yes" xml:space="preserve">
          <source>Atomics</source>
          <target state="translated">Atomics</target>
        </trans-unit>
        <trans-unit id="fe4c2e56ace1dd5cd16118bb6ad5e5256c61db83" translate="yes" xml:space="preserve">
          <source>Attempt to downcast the &lt;code&gt;Arc&amp;lt;dyn Any + Send + Sync&amp;gt;&lt;/code&gt; to a concrete type.</source>
          <target state="translated">&lt;code&gt;Arc&amp;lt;dyn Any + Send + Sync&amp;gt;&lt;/code&gt; 를 콘크리트 유형 으로 다운 캐스트하십시오 .</target>
        </trans-unit>
        <trans-unit id="92df3d44a91e7d67c064d6d725fec8b2e940cc64" translate="yes" xml:space="preserve">
          <source>Attempt to downcast the &lt;code&gt;Rc&amp;lt;dyn Any&amp;gt;&lt;/code&gt; to a concrete type.</source>
          <target state="translated">&lt;code&gt;Rc&amp;lt;dyn Any&amp;gt;&lt;/code&gt; 를 콘크리트 유형 으로 다운 캐스트하십시오 .</target>
        </trans-unit>
        <trans-unit id="886d23c3fa7b51635fa7bbdd282f2babcd6cb45c" translate="yes" xml:space="preserve">
          <source>Attempt to downcast the box to a concrete type.</source>
          <target state="translated">상자를 콘크리트 유형으로 다운 캐스트하십시오.</target>
        </trans-unit>
        <trans-unit id="175cf296f94bed8278b4e811c5245f622f67f97c" translate="yes" xml:space="preserve">
          <source>Attempt to resolve the future to a final value, registering the current task for wakeup if the value is not yet available.</source>
          <target state="translated">값을 아직 사용할 수없는 경우 현재 작업을 깨우기 위해 현재 작업을 등록하여 미래를 최종 값으로 해결하려고합니다.</target>
        </trans-unit>
        <trans-unit id="0b1794f780a4845e82f1aa618849777a9e5b6e42" translate="yes" xml:space="preserve">
          <source>Attempt to resolve the future to a final value, registering the current task for wakeup if the value is not yet available. &lt;a href=&quot;../future/trait.future#tymethod.poll&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">값을 아직 사용할 수없는 경우 현재 작업을 깨우기 위해 현재 작업을 등록하여 미래를 최종 값으로 해결하려고합니다. &lt;a href=&quot;../future/trait.future#tymethod.poll&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="55136df45140cab2915451715291fdde1ced9b25" translate="yes" xml:space="preserve">
          <source>Attempt to resolve the future to a final value, registering the current task for wakeup if the value is not yet available. &lt;a href=&quot;future/trait.future#tymethod.poll&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">값을 아직 사용할 수없는 경우 현재 작업을 깨우기 위해 현재 작업을 등록하여 미래를 최종 값으로 해결하려고합니다. &lt;a href=&quot;future/trait.future#tymethod.poll&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="856e8b63203e04805b09dd95b9d3481ff3097c22" translate="yes" xml:space="preserve">
          <source>Attempt was made to import an item whereas an extern crate with this name has already been imported.</source>
          <target state="translated">아이템을 가져 오려고 시도했지만이 이름의 외계 상자가 이미 가져 왔습니다.</target>
        </trans-unit>
        <trans-unit id="5fc738aa7f6254311ae3614b150f4fe1cec8fe27" translate="yes" xml:space="preserve">
          <source>Attempt was made to import an unimportable value. This can happen when trying to import a method from a trait.</source>
          <target state="translated">가져올 수없는 값을 가져 오려고했습니다. 이것은 특성에서 메소드를 가져 오려고 할 때 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c61d256e7903ca5ede61e01fd8467962bbb349b" translate="yes" xml:space="preserve">
          <source>Attempted to access a field on a primitive type.</source>
          <target state="translated">기본 유형의 필드에 액세스하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="a54332e7df630f85a467d7ec89246d77c007b643" translate="yes" xml:space="preserve">
          <source>Attempted to access a method like a field.</source>
          <target state="translated">필드와 같은 메소드에 액세스하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="48f28400d9c83d5af115ff62dc11ba5e26ca8457" translate="yes" xml:space="preserve">
          <source>Attempted to access a non-existent field in a struct.</source>
          <target state="translated">구조체에서 존재하지 않는 필드에 액세스하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="03b41486da885815831596a9c99e4264efdf5d06" translate="yes" xml:space="preserve">
          <source>Attempted to access a private field on a struct.</source>
          <target state="translated">구조체의 개인 필드에 액세스하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="a1ad3c1a31bd1ae534677401ea798535b99a38e5" translate="yes" xml:space="preserve">
          <source>Attempted to call something which isn't a function nor a method.</source>
          <target state="translated">함수 나 메소드가 아닌 것을 호출하려고 시도했습니다.</target>
        </trans-unit>
        <trans-unit id="eef4156ee856f3204829c854633733e0594d2319" translate="yes" xml:space="preserve">
          <source>Attempted to dereference a variable which cannot be dereferenced.</source>
          <target state="translated">역 참조 할 수없는 변수를 역 참조하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="1372db0ea32a319cb23e92d2e2d51b6cd2d1a4fb" translate="yes" xml:space="preserve">
          <source>Attempted to pass an invalid type of variable into a variadic function.</source>
          <target state="translated">변수 유형이 잘못된 변수에 변수를 전달하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="7adfef6b18f86865559fc727494e616e0b3f7f80" translate="yes" xml:space="preserve">
          <source>Attempting to compile now gives us the following output:</source>
          <target state="translated">컴파일을 시도하면 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="e83036683d0914f18e7de7ebbb8a14c9db8b6c5c" translate="yes" xml:space="preserve">
          <source>Attempting to compile this code results in this type error:</source>
          <target state="translated">이 코드를 컴파일하려고하면 다음과 같은 유형의 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="71aec9a6c07f86af18ab65ed514253e4a11e1117" translate="yes" xml:space="preserve">
          <source>Attempting to create a &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; iterator from an improperly formatted socket address &lt;code&gt;&amp;amp;str&lt;/code&gt; (missing the port):</source>
          <target state="translated">형식이 잘못된 소켓 주소 &lt;code&gt;&amp;amp;str&lt;/code&gt; (포트 누락) 에서 &lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; 반복자 를 작성하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="baf8e0e513c1e7d75d1c56986d1f69437e36903e" translate="yes" xml:space="preserve">
          <source>Attempting to create a trait object for a non object-safe trait will trigger this error.</source>
          <target state="translated">객체 안전이 아닌 형질에 대한 형질 개체를 만들려고하면이 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fcaf285fe223ac76c6b6f3a248ca791f9480d826" translate="yes" xml:space="preserve">
          <source>Attempts to acquire this lock.</source>
          <target state="translated">이 잠금을 얻으려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="ed9809bcb2ab4f39482ae3c8ecc3990c35b19e02" translate="yes" xml:space="preserve">
          <source>Attempts to acquire this rwlock with shared read access.</source>
          <target state="translated">공유 읽기 액세스 권한으로이 rwlock을 확보하려고합니다.</target>
        </trans-unit>
        <trans-unit id="aa06f6d37e15f994598953d5d55e85873c353cbb" translate="yes" xml:space="preserve">
          <source>Attempts to collect the exit status of the child if it has already exited.</source>
          <target state="translated">이미 종료 된 하위의 종료 상태를 수집하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="2067ade47b4e19fcd748b5622bcd5a578000fa70" translate="yes" xml:space="preserve">
          <source>Attempts to extend the allocation referenced by &lt;code&gt;ptr&lt;/code&gt; to fit &lt;code&gt;new_size&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; 이 참조하는 할당 을 &lt;code&gt;new_size&lt;/code&gt; 에 맞게 확장하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="1f0524b8bf45261cb2e5192b808b5a4a85102e03" translate="yes" xml:space="preserve">
          <source>Attempts to extend the allocation referenced by &lt;code&gt;ptr&lt;/code&gt; to fit &lt;code&gt;new_size&lt;/code&gt;. &lt;a href=&quot;trait.alloc#method.grow_in_place&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; 이 참조하는 할당 을 &lt;code&gt;new_size&lt;/code&gt; 에 맞게 확장하려고 시도합니다 . &lt;a href=&quot;trait.alloc#method.grow_in_place&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="14aa482507a26cdd1d3724ec04b0d14909b4ce76" translate="yes" xml:space="preserve">
          <source>Attempts to lock this rwlock with exclusive write access.</source>
          <target state="translated">독점적 인 쓰기 액세스 권한으로이 rwlock을 잠그려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="3e149a02e4c5943a78110a9fe37e7dfdc1377a23" translate="yes" xml:space="preserve">
          <source>Attempts to open a file in read-only mode.</source>
          <target state="translated">파일을 읽기 전용 모드로 열려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="ce00391cd1170f4f9f1ed2dc7adb3e45ca14e46a" translate="yes" xml:space="preserve">
          <source>Attempts to return a pending value on this receiver without blocking.</source>
          <target state="translated">차단하지 않고이 수신자에서 보류중인 값을 리턴하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="88500c10aaa3c7978ed8857be5643440673d4380" translate="yes" xml:space="preserve">
          <source>Attempts to send a value on this channel without blocking.</source>
          <target state="translated">차단하지 않고이 채널에서 값을 보내려고합니다.</target>
        </trans-unit>
        <trans-unit id="44fed3b4d1c2db46234c4d30a1056c0ccd124c87" translate="yes" xml:space="preserve">
          <source>Attempts to send a value on this channel, returning it back if it could not be sent.</source>
          <target state="translated">이 채널에서 값을 보내려고 시도하여 보낼 수없는 경우 되돌립니다.</target>
        </trans-unit>
        <trans-unit id="6da3e262b2372fb386666634b5d39f9d3f7bb80a" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the allocation referenced by &lt;code&gt;ptr&lt;/code&gt; to fit &lt;code&gt;new_size&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new_size&lt;/code&gt; 에 맞게 &lt;code&gt;ptr&lt;/code&gt; 이 참조하는 할당을 축소하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="d9dd72c543bd49d83f78f0fdf1367b07147238f9" translate="yes" xml:space="preserve">
          <source>Attempts to shrink the allocation referenced by &lt;code&gt;ptr&lt;/code&gt; to fit &lt;code&gt;new_size&lt;/code&gt;. &lt;a href=&quot;trait.alloc#method.shrink_in_place&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;new_size&lt;/code&gt; 에 맞게 &lt;code&gt;ptr&lt;/code&gt; 이 참조하는 할당을 축소하려고 시도합니다 . &lt;a href=&quot;trait.alloc#method.shrink_in_place&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d431ee47732f5fda5d822308d953fb6c4ab546af" translate="yes" xml:space="preserve">
          <source>Attempts to sync all OS-internal metadata to disk.</source>
          <target state="translated">모든 OS 내부 메타 데이터를 디스크에 동기화하려고합니다.</target>
        </trans-unit>
        <trans-unit id="e1a28bf0ca8943d3102fb17a5f930dbd42c32e93" translate="yes" xml:space="preserve">
          <source>Attempts to upgrade the &lt;code&gt;Weak&lt;/code&gt; pointer to an &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt;, extending the lifetime of the value if successful.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; 포인터를 &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; 로 업그레이드하여 성공하면 값의 수명을 연장합니다.</target>
        </trans-unit>
        <trans-unit id="c10f653d6058260dd8df6597f6fc625f0e90a7a2" translate="yes" xml:space="preserve">
          <source>Attempts to upgrade the &lt;code&gt;Weak&lt;/code&gt; pointer to an &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt;, extending the lifetime of the value if successful.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; 포인터를 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 로 업그레이드하여 성공하면 값의 수명을 연장합니다.</target>
        </trans-unit>
        <trans-unit id="4ed9981b4c97d4946f7cc66f3d69625251a285c0" translate="yes" xml:space="preserve">
          <source>Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up, or if &lt;code&gt;deadline&lt;/code&gt; is reached.</source>
          <target state="translated">이 수신기에서 값을 기다리려고 시도하여 해당 채널이 끊어 지거나 &lt;code&gt;deadline&lt;/code&gt; 에 도달 하면 오류를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="eea7708f089d17a724b4fe150c8a5b22b7b7cd15" translate="yes" xml:space="preserve">
          <source>Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up, or if it waits more than &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">이 수신기에서 값을 기다리려고 시도하여 해당 채널이 중단되었거나 &lt;code&gt;timeout&lt;/code&gt; 이상 대기하면 오류를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c5624ed9b3f4c32e9214ed479d11bee18fe54f2a" translate="yes" xml:space="preserve">
          <source>Attempts to wait for a value on this receiver, returning an error if the corresponding channel has hung up.</source>
          <target state="translated">이 수신기에서 값을 기다리려고 시도하여 해당 채널이 끊어지면 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="66681ba198baa628940b6e0e8d1d21d555ae1a8d" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer.</source>
          <target state="translated">이 기록기에 전체 버퍼를 쓰려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="50c44c33216c75388385c7158cbb2db3b18cd276" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer. &lt;a href=&quot;../../../io/trait.write#method.write_all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 기록기에 전체 버퍼를 쓰려고 시도합니다. &lt;a href=&quot;../../../io/trait.write#method.write_all&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cb65a661c9940f60efcdfd42e570120d00134516" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer. &lt;a href=&quot;../io/trait.write#method.write_all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 기록기에 전체 버퍼를 쓰려고 시도합니다. &lt;a href=&quot;../io/trait.write#method.write_all&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7537ca8f100350d628ddd2455b7d2b9261e91786" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer. &lt;a href=&quot;io/trait.write#method.write_all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 기록기에 전체 버퍼를 쓰려고 시도합니다. &lt;a href=&quot;io/trait.write#method.write_all&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c4a079954569cfca76bb04671c6eef0de6f2845b" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer into this writer. &lt;a href=&quot;trait.write#method.write_all&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">이 기록기에 전체 버퍼를 쓰려고 시도합니다. &lt;a href=&quot;trait.write#method.write_all&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3a4550331cd75411aa797d05589ea44d59948931" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer starting from a given offset.</source>
          <target state="translated">주어진 오프셋에서 시작하여 전체 버퍼를 쓰려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="bd08d9b38e39a23845ecac7733a7135e68b5844b" translate="yes" xml:space="preserve">
          <source>Attempts to write an entire buffer starting from a given offset. &lt;a href=&quot;../os/unix/fs/trait.fileext#method.write_all_at&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">주어진 오프셋에서 시작하여 전체 버퍼를 쓰려고 시도합니다. &lt;a href=&quot;../os/unix/fs/trait.fileext#method.write_all_at&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="63578c033690b22f88448dc9020fc65119c91cf5" translate="yes" xml:space="preserve">
          <source>Attribute contains same meta item more than once.</source>
          <target state="translated">속성에 동일한 메타 항목이 두 번 이상 포함되어 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
