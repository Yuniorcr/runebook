<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="bb85096bf6f841f9bc42b20ab21fbdaddee5e86c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;RawWaker&lt;/code&gt; allows the implementor of a task executor to create a &lt;a href=&quot;struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; which provides customized wakeup behavior.</source>
          <target state="translated">&lt;code&gt;RawWaker&lt;/code&gt; 는 만들기 위해 작업 실행의 구현을 허용 &lt;a href=&quot;struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt; 사용자 정의 웨이크 업 동작을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1193137c297d5cbd26cbbc2bf90d52838e50813a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; can grow in size and its contents can change, just like the contents of a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, if you push more data into it. In addition, you can conveniently use the &lt;code&gt;+&lt;/code&gt; operator or the &lt;code&gt;format!&lt;/code&gt; macro to concatenate &lt;code&gt;String&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 단지의 내용처럼, 크기가 증가 할 수 있으며 그 내용을 변경할 수 있습니다 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; , 당신은 더 많은 데이터를 밀어 경우에. 또한 &lt;code&gt;+&lt;/code&gt; 연산자 또는 &lt;code&gt;format!&lt;/code&gt; 편리하게 사용할 수 있습니다 ! &lt;code&gt;String&lt;/code&gt; 값 을 연결하는 매크로 입니다.</target>
        </trans-unit>
        <trans-unit id="ad2a4c35b866459c9366f5bbd3c6f621ece58985" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; is a wrapper over a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;. Let&amp;rsquo;s look at some of our properly encoded UTF-8 example strings from Listing 8-14. First, this one:</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 이상 래퍼입니다 &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; . Listing 8-14에서 올바르게 인코딩 된 UTF-8 예제 문자열 중 일부를 살펴 보자. 첫째, 이것은 :</target>
        </trans-unit>
        <trans-unit id="dcd60f52764dfb12603585382f304c29b3d891eb" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;String&lt;/code&gt; is made up of three components: a pointer to some bytes, a length, and a capacity. The pointer points to an internal buffer &lt;code&gt;String&lt;/code&gt; uses to store its data. The length is the number of bytes currently stored in the buffer, and the capacity is the size of the buffer in bytes. As such, the length will always be less than or equal to the capacity.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 일부 바이트 길이 및 용량에 대한 포인터 : 세 가지 구성 요소로 구성되어 있습니다. 포인터 는 &lt;code&gt;String&lt;/code&gt; 이 데이터를 저장하는 데 사용 하는 내부 버퍼를 가리 킵니다 . 길이는 현재 버퍼에 저장된 바이트 수이고 용량은 버퍼 크기 (바이트)입니다. 따라서 길이는 항상 용량보다 작거나 같습니다.</target>
        </trans-unit>
        <trans-unit id="2815fef167ebe8b526c9b5e3287501b1039ea114" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SystemTimeError&lt;/code&gt; is returned from the &lt;a href=&quot;struct.systemtime#method.duration_since&quot;&gt;&lt;code&gt;duration_since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.systemtime#method.elapsed&quot;&gt;&lt;code&gt;elapsed&lt;/code&gt;&lt;/a&gt; methods of &lt;a href=&quot;struct.systemtime&quot;&gt;&lt;code&gt;SystemTime&lt;/code&gt;&lt;/a&gt; whenever the second system time represents a point later in time than the &lt;code&gt;self&lt;/code&gt; of the method call.</source>
          <target state="translated">&lt;code&gt;SystemTimeError&lt;/code&gt; 는 로부터 반환 &lt;a href=&quot;struct.systemtime#method.duration_since&quot;&gt; &lt;code&gt;duration_since&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;struct.systemtime#method.elapsed&quot;&gt; &lt;code&gt;elapsed&lt;/code&gt; &lt;/a&gt; 방법 &lt;a href=&quot;struct.systemtime&quot;&gt; &lt;code&gt;SystemTime&lt;/code&gt; &lt;/a&gt; 번째 시스템보다 시간이 시간 이후 지점을 나타내고마다 &lt;code&gt;self&lt;/code&gt; 메소드 호출한다.</target>
        </trans-unit>
        <trans-unit id="f0e9bc60c4e3276e60ae09f7f961f64e01c5bfbd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ThreadId&lt;/code&gt; is an opaque object that has a unique value for each thread that creates one. &lt;code&gt;ThreadId&lt;/code&gt;s are not guaranteed to correspond to a thread's system-designated identifier. A &lt;code&gt;ThreadId&lt;/code&gt; can be retrieved from the &lt;a href=&quot;struct.thread#method.id&quot;&gt;&lt;code&gt;id&lt;/code&gt;&lt;/a&gt; method on a &lt;a href=&quot;struct.thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ThreadId&lt;/code&gt; 는 하나를 생성 스레드마다 고유 한 값을 갖는 불투명 한 객체이다. &lt;code&gt;ThreadId&lt;/code&gt; 는 스레드의 시스템 지정 식별자에 해당하는 것은 아닙니다. &lt;code&gt;ThreadId&lt;/code&gt; 는 으로부터 검색 할 수있는 &lt;a href=&quot;struct.thread#method.id&quot;&gt; &lt;code&gt;id&lt;/code&gt; &lt;/a&gt; A의 방법 &lt;a href=&quot;struct.thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b1818d010b7b29b87c4502d46870a6345ca3ee68" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TypeId&lt;/code&gt; is currently only available for types which ascribe to &lt;code&gt;'static&lt;/code&gt;, but this limitation may be removed in the future.</source>
          <target state="translated">&lt;code&gt;TypeId&lt;/code&gt; 현재에있는 돌리다 유형에만 사용할 수 있습니다 &lt;code&gt;'static&lt;/code&gt; 하지만,이 제한은 미래에 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b2832f9ef1617c1a164688031f12174b8e5931d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TypeId&lt;/code&gt; represents a globally unique identifier for a type.</source>
          <target state="translated">&lt;code&gt;TypeId&lt;/code&gt; 유형에 대한 글로벌 고유 식별자를 나타낸다.</target>
        </trans-unit>
        <trans-unit id="345e82ed2183b66aaf325e8ad24887f5dd3ff3ad" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Vec&lt;/code&gt; can be mutable. Slices, on the other hand, are read-only objects. To get a slice, use &lt;code&gt;&amp;amp;&lt;/code&gt;. Example:</source>
          <target state="translated">&lt;code&gt;Vec&lt;/code&gt; 변경할 수 있습니다. 반면에 슬라이스는 읽기 전용 개체입니다. 슬라이스를 얻으려면 &lt;code&gt;&amp;amp;&lt;/code&gt; 를 사용하십시오 . 예:</target>
        </trans-unit>
        <trans-unit id="84a3e0757f03c2cf35d8f4ee02786937e5e0845a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Waker&lt;/code&gt; is a handle for waking up a task by notifying its executor that it is ready to be run.</source>
          <target state="translated">&lt;code&gt;Waker&lt;/code&gt; 은 그것을 실행할 준비가되었음을 그 집행을 통지하여 작업을 깨어위한 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="92c5425b2664515a7d6b0bd3279f583d1e16c172" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the value within &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; without extending its lifetime. It is also used to prevent circular references between &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; 포인터 내의 값으로 임시 기준 유지에 유용 &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; 수명을 연장하지 않고. 또한 상호 소유하는 참조는 어느 한 쪽의 &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; 도 삭제할 수 없으므로 &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; 포인터 사이의 순환 참조를 방지하는 데 사용됩니다 . 예를 들어, 나무는 부모 노드에서 자식으로 강한 &lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt; 포인터를, 자식에서 부모로 &lt;code&gt;Weak&lt;/code&gt; 포인터를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c317832e61e5046de4792c85bcf63089c251292c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Weak&lt;/code&gt; pointer is useful for keeping a temporary reference to the value within &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; without extending its lifetime. It is also used to prevent circular references between &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers, since mutual owning references would never allow either &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; to be dropped. For example, a tree could have strong &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;code&gt;Weak&lt;/code&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; 포인터 내의 값으로 임시 기준 유지에 유용 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; 를가&lt;/a&gt; 수명 연장없이. 또한 상호 소유 참조가 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 를 삭제할 수 없기 때문에 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 포인터 사이의 순환 참조를 방지하는 데에도 사용됩니다 . 예를 들어, 나무는 부모 노드에서 자식으로 강력한 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 포인터를, 자식에서 부모로 &lt;code&gt;Weak&lt;/code&gt; 포인터를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4bf74475c310d76b2da5f50f50fec722f68f826f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is normally associated with the innermost &lt;code&gt;loop&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; loop enclosing the &lt;code&gt;break&lt;/code&gt; expression, but a &lt;a href=&quot;loop-expr#loop-labels&quot;&gt;label&lt;/a&gt; can be used to specify which enclosing loop is affected. Example:</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 표현은 일반적으로 내측과 연관된 &lt;code&gt;loop&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; 또는 &lt;code&gt;while&lt;/code&gt; 루프가 클로징 &lt;code&gt;break&lt;/code&gt; 발현하지만 &lt;a href=&quot;loop-expr#loop-labels&quot;&gt;라벨&lt;/a&gt; 영향을 둘러싸고있는 루프를 지정하기 위해 사용될 수있다. 예:</target>
        </trans-unit>
        <trans-unit id="1929ca3782f20314772673eb1b3076f6e73f81b3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; expression is only permitted in the body of a loop, and has one of the forms &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;break 'label&lt;/code&gt; or (&lt;a href=&quot;loop-expr#break-and-loop-values&quot;&gt;see below&lt;/a&gt;) &lt;code&gt;break EXPR&lt;/code&gt; or &lt;code&gt;break 'label EXPR&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 발현은 루프 본체에서 허용하고, 폼의 한 갖는다 &lt;code&gt;break&lt;/code&gt; , &lt;code&gt;break 'label&lt;/code&gt; 또는 ( &lt;a href=&quot;loop-expr#break-and-loop-values&quot;&gt;아래 참조&lt;/a&gt; ) &lt;code&gt;break EXPR&lt;/code&gt; 또는 &lt;code&gt;break 'label EXPR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f212565caf5ca5d26733a24ecd450094943708a5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; statement with an argument appeared in a non-&lt;code&gt;loop&lt;/code&gt; loop.</source>
          <target state="translated">인수가 있는 &lt;code&gt;break&lt;/code&gt; 문은 비 &lt;code&gt;loop&lt;/code&gt; 루프에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="0719aea9e00a3f18488e8dec397e352b5e69370a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;break&lt;/code&gt; statement without a label appeared inside a labeled block.</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 레이블이없는 문은 레이블 블록 내부 나타났다.</target>
        </trans-unit>
        <trans-unit id="6de9c91a3e0c1eb1015d4865a476f244ccddf52f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;const&lt;/code&gt; represents a constant value that should never change. If one takes a &lt;code&gt;&amp;amp;&lt;/code&gt; reference to the constant, then one is taking a pointer to some memory location containing the value. Normally this is perfectly fine: most values can't be changed via a shared &lt;code&gt;&amp;amp;&lt;/code&gt; pointer, but interior mutability would allow it. That is, a constant value could be mutated. On the other hand, a &lt;code&gt;static&lt;/code&gt; is explicitly a single memory location, which can be mutated at will.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 변경해서는 안 상수 값을 나타냅니다. 상수에 대한 &lt;code&gt;&amp;amp;&lt;/code&gt; 참조를 취하면 값을 포함하는 일부 메모리 위치에 대한 포인터를 가져옵니다. 일반적으로 이것은 완벽하게 좋습니다 : 대부분의 값은 공유 &lt;code&gt;&amp;amp;&lt;/code&gt; 포인터 를 통해 변경할 수 없지만 내부 변경은 허용합니다. 즉, 상수 값이 변경 될 수 있습니다. 반면에 &lt;code&gt;static&lt;/code&gt; 은 명시 적으로 단일 메모리 위치이며 마음대로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcf892710236415af0f5e027b5569143cb3933af" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; expression is a syntactic construct for looping over elements provided by an implementation of &lt;code&gt;std::iter::IntoIterator&lt;/code&gt;. If the iterator yields a value, that value is given the specified name and the body of the loop is executed, then control returns to the head of the &lt;code&gt;for&lt;/code&gt; loop. If the iterator is empty, the &lt;code&gt;for&lt;/code&gt; expression completes.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 표현식의 구현에 의해 제공되는 요소를 반복하는 구문 론적 구조 인 &lt;code&gt;std::iter::IntoIterator&lt;/code&gt; . 반복자가 값을 생성하면 해당 값에 지정된 이름이 지정되고 루프 본문이 실행 된 후 제어가 &lt;code&gt;for&lt;/code&gt; 루프 의 헤드로 돌아갑니다 . 반복자가 비어 있으면 &lt;code&gt;for&lt;/code&gt; 표현식이 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="d73920ce8bc8796a34637626ebd1ee2bfe7e1d77" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; loop expands as shown:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 루프 팽창 같이 :</target>
        </trans-unit>
        <trans-unit id="0dcdc530771d15a6a0db69b3817439a78d80a1af" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;loop&lt;/code&gt; expression repeats execution of its body continuously: &lt;code&gt;loop { println!(&quot;I live.&quot;); }&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; 표현은 지속적으로 신체의 실행을 반복 : &lt;code&gt;loop { println!(&quot;I live.&quot;); }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e36c323c7511710c9caa566121cf59ed62c95bef" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;loop&lt;/code&gt; expression without an associated &lt;code&gt;break&lt;/code&gt; expression is diverging and has type &lt;a href=&quot;../types/never&quot;&gt;&lt;code&gt;!&lt;/code&gt;&lt;/a&gt;. A &lt;code&gt;loop&lt;/code&gt; expression containing associated &lt;a href=&quot;loop-expr#break-expressions&quot;&gt;&lt;code&gt;break&lt;/code&gt; expression(s)&lt;/a&gt; may terminate, and must have type compatible with the value of the &lt;code&gt;break&lt;/code&gt; expression(s).</source>
          <target state="translated">&lt;code&gt;loop&lt;/code&gt; 관련이없는 표현 &lt;code&gt;break&lt;/code&gt; 표현 분기와 종류를 가지고있다 &lt;a href=&quot;../types/never&quot;&gt; &lt;code&gt;!&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;loop&lt;/code&gt; 연관된 함유 식 &lt;a href=&quot;loop-expr#break-expressions&quot;&gt; &lt;code&gt;break&lt;/code&gt; 표현식 (들)을&lt;/a&gt; 종료 할 수 있으며,의 값에 대응 한 입력해야 &lt;code&gt;break&lt;/code&gt; 식 (S).</target>
        </trans-unit>
        <trans-unit id="27cdf38632ff8742feaafa6612389bb67003ed19" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;match&lt;/code&gt; behaves differently depending on whether or not the scrutinee expression is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression or value expression&lt;/a&gt;. If the scrutinee expression is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression&lt;/a&gt;, it is first evaluated into a temporary location, and the resulting value is sequentially compared to the patterns in the arms until a match is found. The first arm with a matching pattern is chosen as the branch target of the &lt;code&gt;match&lt;/code&gt;, any variables bound by the pattern are assigned to local variables in the arm's block, and control enters the block.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 동작합니다 다르게 scrutinee 표현이 있는지 여부에 따라 &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;장소 발현 또는 값 표현&lt;/a&gt; . scrutinee 표현식이 &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression&lt;/a&gt; 인 경우 먼저 임시 위치로 평가되고 결과 값은 일치하는 것을 찾을 때까지 팔의 패턴과 순차적으로 비교됩니다. 일치하는 패턴이있는 첫 번째 팔이 &lt;code&gt;match&lt;/code&gt; 의 분기 대상으로 선택되고 패턴에 의해 바인딩 된 모든 변수가 팔 블록의 로컬 변수에 할당되고 제어가 블록으로 들어갑니다.</target>
        </trans-unit>
        <trans-unit id="9d65cf4e1e473919c3773c077a67170ac8398876" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;match&lt;/code&gt; expression is made up of &lt;em&gt;arms&lt;/em&gt;. An arm consists of a &lt;em&gt;pattern&lt;/em&gt; and the code that should be run if the value given to the beginning of the &lt;code&gt;match&lt;/code&gt; expression fits that arm&amp;rsquo;s pattern. Rust takes the value given to &lt;code&gt;match&lt;/code&gt; and looks through each arm&amp;rsquo;s pattern in turn. The &lt;code&gt;match&lt;/code&gt; construct and patterns are powerful features in Rust that let you express a variety of situations your code might encounter and make sure that you handle them all. These features will be covered in detail in Chapter 6 and Chapter 18, respectively.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 표현으로 구성되어 &lt;em&gt;팔&lt;/em&gt; . 팔은 &lt;em&gt;패턴&lt;/em&gt; 과 &lt;code&gt;match&lt;/code&gt; 표현식 의 시작 부분에 제공된 값이 해당 팔의 패턴에 맞는 경우 실행해야하는 코드 로 구성됩니다 . Rust는 주어진 값을 &lt;code&gt;match&lt;/code&gt; 각 팔의 패턴을 차례로 살펴 봅니다. &lt;code&gt;match&lt;/code&gt; 구조와 패턴을 사용하면 코드가 발생하고 당신이 그들 모두를 처리 할 것을 만들 수있는 다양한 상황을 표현하자 녹 강력한 기능입니다. 이러한 기능에 대해서는 6 장과 18 장에 각각 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2653905e02c1a5978b97c0dfd21c1d160c036b3e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;repr(transparent)&lt;/code&gt; type was also annotated with other, incompatible representation hints.</source>
          <target state="translated">&lt;code&gt;repr(transparent)&lt;/code&gt; 타입은 다른 호환 표현 힌트로 주석했다.</target>
        </trans-unit>
        <trans-unit id="e983e7b3d7471c078bb152c54f1d0e490ae64bff" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;struct&lt;/code&gt;&lt;em&gt;type&lt;/em&gt; is a heterogeneous product of other types, called the &lt;em&gt;fields&lt;/em&gt; of the type.&lt;sup&gt;&lt;a href=&quot;struct#structtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; &lt;em&gt;타입&lt;/em&gt; 착신 다른 종류의 이종 제품 &lt;em&gt;필드&lt;/em&gt; 유형. &lt;sup&gt;&lt;a href=&quot;struct#structtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="31174f5a2be478aaee87f1f4ce26d9142eeb339c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while let&lt;/code&gt; loop is equivalent to a &lt;code&gt;loop&lt;/code&gt; expression containing a &lt;a href=&quot;match-expr&quot;&gt;&lt;code&gt;match&lt;/code&gt; expression&lt;/a&gt; as follows.</source>
          <target state="translated">&lt;code&gt;while let&lt;/code&gt; 루프가에 해당 &lt;code&gt;loop&lt;/code&gt; 포함하는 발현 &lt;a href=&quot;match-expr&quot;&gt; &lt;code&gt;match&lt;/code&gt; 식을&lt;/a&gt; 다음과 같이.</target>
        </trans-unit>
        <trans-unit id="132dd0b4198a0332783e039cb830e80e3a95c535" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while let&lt;/code&gt; loop is semantically similar to a &lt;code&gt;while&lt;/code&gt; loop but in place of a condition expression it expects the keyword &lt;code&gt;let&lt;/code&gt; followed by a pattern, an &lt;code&gt;=&lt;/code&gt;, a &lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; expression and a block expression. If the value of the scrutinee matches the pattern, the loop body block executes then control returns to the pattern matching statement. Otherwise, the while expression completes.</source>
          <target state="translated">&lt;code&gt;while let&lt;/code&gt; 루프는 의미 상 유사하다 &lt;code&gt;while&lt;/code&gt; 루프는 조건식 대신는 키워드가 예상되지만 &lt;code&gt;let&lt;/code&gt; 패턴, 다음 &lt;code&gt;=&lt;/code&gt; 하는 &lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee의&lt;/a&gt; 발현 및 블록 식. scrutinee의 값이 패턴과 일치하면 루프 본문 블록이 실행 된 다음 제어가 패턴 일치 명령문으로 돌아갑니다. 그렇지 않으면 while 표현식이 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="283fcf53585988268a7d68d52030cb117688b529" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while&lt;/code&gt; loop begins by evaluating the boolean loop conditional expression. If the loop conditional expression evaluates to &lt;code&gt;true&lt;/code&gt;, the loop body block executes, then control returns to the loop conditional expression. If the loop conditional expression evaluates to &lt;code&gt;false&lt;/code&gt;, the &lt;code&gt;while&lt;/code&gt; expression completes.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 루프는 부울 루프 조건식을 평가하여 시작합니다. 루프 조건식이 &lt;code&gt;true&lt;/code&gt; 로 평가 되면 루프 본문 블록이 실행 된 다음 제어가 루프 조건식으로 돌아갑니다. 에 루프 조건식 평가되면 &lt;code&gt;false&lt;/code&gt; 의 &lt;code&gt;while&lt;/code&gt; 표현이 완료.</target>
        </trans-unit>
        <trans-unit id="9a98030fcb71c42d6137c8ff5fae0192e67a25d8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;24-bit code point escape&lt;/em&gt; starts with &lt;code&gt;U+0075&lt;/code&gt; (&lt;code&gt;u&lt;/code&gt;) and is followed by up to six &lt;em&gt;hex digits&lt;/em&gt; surrounded by braces &lt;code&gt;U+007B&lt;/code&gt; (&lt;code&gt;{&lt;/code&gt;) and &lt;code&gt;U+007D&lt;/code&gt; (&lt;code&gt;}&lt;/code&gt;). It denotes the Unicode code point equal to the provided hex value.</source>
          <target state="translated">&lt;em&gt;24 비트 코드 포인트 탈출&lt;/em&gt; 로 시작 &lt;code&gt;U+0075&lt;/code&gt; ( &lt;code&gt;u&lt;/code&gt; ) 및 여섯까지 이어진다 &lt;em&gt;16 진수&lt;/em&gt; 중괄호 &lt;code&gt;U+007B&lt;/code&gt; ( &lt;code&gt;{&lt;/code&gt; ) 및 &lt;code&gt;U+007D&lt;/code&gt; ( &lt;code&gt;}&lt;/code&gt; ). 제공된 16 진수 값과 동일한 유니 코드 코드 포인트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="869073214f1b9edb093744ef355f142778b07763" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;7-bit code point escape&lt;/em&gt; starts with &lt;code&gt;U+0078&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt;) and is followed by exactly two &lt;em&gt;hex digits&lt;/em&gt; with value up to &lt;code&gt;0x7F&lt;/code&gt;. It denotes the ASCII character with value equal to the provided hex value. Higher values are not permitted because it is ambiguous whether they mean Unicode code points or byte values.</source>
          <target state="translated">&lt;em&gt;7 비트 코드 포인트 탈출&lt;/em&gt; 시작 &lt;code&gt;U+0078&lt;/code&gt; ( &lt;code&gt;x&lt;/code&gt; )과 정확히 두 뒤에 &lt;em&gt;16 진수&lt;/em&gt; 로 값쪽으로 &lt;code&gt;0x7F&lt;/code&gt; 의 . 제공된 16 진 값과 동일한 값을 갖는 ASCII 문자를 나타냅니다. 유니 코드 코드 포인트 또는 바이트 값을 의미하는지 여부가 모호하므로 더 큰 값은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ba5e9b49178a0e6b5d252044b97fef65592fc293" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;&lt;code&gt;let&lt;/code&gt; statement&lt;/em&gt; introduces a new set of &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt;, given by a &lt;a href=&quot;patterns&quot;&gt;pattern&lt;/a&gt;. The pattern is followed optionally by a type annotation and then optionally by an initializer expression. When no type annotation is given, the compiler will infer the type, or signal an error if insufficient type information is available for definite inference. Any variables introduced by a variable declaration are visible from the point of declaration until the end of the enclosing block scope.</source>
          <target state="translated">A는 &lt;em&gt; &lt;code&gt;let&lt;/code&gt; 문&lt;/em&gt; 을 소개합니다에게의 새로운 &lt;a href=&quot;variables&quot;&gt;변수&lt;/a&gt; a로 주어진 &lt;a href=&quot;patterns&quot;&gt;패턴을&lt;/a&gt; . 패턴 다음에는 선택적으로 형식 주석이 있고 초기화식이 있습니다. 형식 주석이 제공되지 않으면 컴파일러는 형식을 유추하거나 불충분 한 형식 정보가 명확한 추론에 사용 가능한 경우 오류를 알립니다. 변수 선언에 의해 도입 된 모든 변수는 선언 지점에서 둘러싸는 블록 범위의 끝까지 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4965d161e4fa0b76aa8e253a8b735c3ef6585135" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;&lt;code&gt;match&lt;/code&gt; expression&lt;/em&gt; branches on a pattern. The exact form of matching that occurs depends on the &lt;a href=&quot;../patterns&quot;&gt;pattern&lt;/a&gt;. A &lt;code&gt;match&lt;/code&gt; expression has a &lt;em&gt;&lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; expression&lt;/em&gt;, which is the value to compare to the patterns. The scrutinee expression and the patterns must have the same type.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;match&lt;/code&gt; 발현&lt;/em&gt; 패턴에 분기합니다. 일치하는 정확한 형태는 &lt;a href=&quot;../patterns&quot;&gt;패턴에&lt;/a&gt; 따라 다릅니다 . &lt;code&gt;match&lt;/code&gt; 표현식은이 &lt;em&gt;&lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee의&lt;/a&gt; 표현&lt;/em&gt; , 패턴을 비교하는 값입니다. 스크 루틴 표현과 패턴은 같은 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="58385518472acdb41b644cab1601f90a746d55aa" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;binary literal&lt;/em&gt; starts with the character sequence &lt;code&gt;U+0030&lt;/code&gt;&lt;code&gt;U+0062&lt;/code&gt; (&lt;code&gt;0b&lt;/code&gt;) and continues as any mixture (with at least one digit) of binary digits and underscores.</source>
          <target state="translated">&lt;em&gt;이진 리터럴&lt;/em&gt; 문자 시퀀스로 시작하는 &lt;code&gt;U+0030&lt;/code&gt; &lt;code&gt;U+0062&lt;/code&gt; ( &lt;code&gt;0b&lt;/code&gt; ) 및 이진수 및 밑줄 (적어도 한 디지트를 가진) 임의의 혼합물로 계속된다.</target>
        </trans-unit>
        <trans-unit id="e1bc1112f211249d5a018412bd10ed929678eeda" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;block expression&lt;/em&gt;, or &lt;em&gt;block&lt;/em&gt;, is a control flow expression and anonymous namespace scope for items and variable declarations. As a control flow expression, a block sequentially executes its component non-item declaration statements and then its final optional expression. As an anonymous namespace scope, item declarations are only in scope inside the block itself and variables declared by &lt;code&gt;let&lt;/code&gt; statements are in scope from the next statement until the end of the block.</source>
          <target state="translated">&lt;em&gt;블록 식&lt;/em&gt; 또는 &lt;em&gt;블록&lt;/em&gt; , 항목 변수 선언하기위한 제어 흐름 식 익명 공간 범위이다. 제어 흐름 표현식으로서 블록은 구성 요소 비 항목 선언문을 순차적으로 실행 한 다음 최종 선택적 표현식을 실행합니다. 익명의 네임 스페이스 범위 인 항목 선언은 블록 자체의 범위에만 있고 &lt;code&gt;let&lt;/code&gt; 문으로 선언 된 변수는 다음 명령문에서 블록 끝까지 범위에 있습니다.</target>
        </trans-unit>
        <trans-unit id="d959096d425f9582c596a1eece69230b21ea3b75" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;byte escape&lt;/em&gt; escape starts with &lt;code&gt;U+0078&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt;) and is followed by exactly two &lt;em&gt;hex digits&lt;/em&gt;. It denotes the byte equal to the provided hex value.</source>
          <target state="translated">&lt;em&gt;바이트 이스케이프&lt;/em&gt; 탈출 시작 &lt;code&gt;U+0078&lt;/code&gt; ( &lt;code&gt;x&lt;/code&gt; )과 정확히 두 뒤에 &lt;em&gt;16 진수&lt;/em&gt; . 제공된 16 진 값과 동일한 바이트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="08d56300cad1166d8bb2fb927ceda10d77863d64" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;byte literal&lt;/em&gt; is a single ASCII character (in the &lt;code&gt;U+0000&lt;/code&gt; to &lt;code&gt;U+007F&lt;/code&gt; range) or a single &lt;em&gt;escape&lt;/em&gt; preceded by the characters &lt;code&gt;U+0062&lt;/code&gt; (&lt;code&gt;b&lt;/code&gt;) and &lt;code&gt;U+0027&lt;/code&gt; (single-quote), and followed by the character &lt;code&gt;U+0027&lt;/code&gt;. If the character &lt;code&gt;U+0027&lt;/code&gt; is present within the literal, it must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) character. It is equivalent to a &lt;code&gt;u8&lt;/code&gt; unsigned 8-bit integer &lt;em&gt;number literal&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;바이트 리터럴&lt;/em&gt; 합니다 (단일 ASCII 문자 인 &lt;code&gt;U+0000&lt;/code&gt; 에 &lt;code&gt;U+007F&lt;/code&gt; 의 범위) 또는 단일 &lt;em&gt;이스케이프&lt;/em&gt; 문자 앞에 &lt;code&gt;U+0062&lt;/code&gt; ( &lt;code&gt;b&lt;/code&gt; ) 및 &lt;code&gt;U+0027&lt;/code&gt; 문자 그래피 (따옴표)을 따라 &lt;code&gt;U+0027&lt;/code&gt; . 문자 &lt;code&gt;U+0027&lt;/code&gt; 이 리터럴 내에 있으면 선행 &lt;code&gt;U+005C&lt;/code&gt; ( &lt;code&gt;\&lt;/code&gt; ) 문자 로 &lt;em&gt;이스케이프&lt;/em&gt; 해야합니다 . 그것은 동등 &lt;code&gt;u8&lt;/code&gt; 부호없는 8 비트 정수 &lt;em&gt;번호 리터럴&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="82cbcd824290282b86dc09637a06221aa40fcffe" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;call expression&lt;/em&gt; consists of an expression followed by a parenthesized expression-list. It invokes a function, providing zero or more input variables. If the function eventually returns, then the expression completes. For &lt;a href=&quot;../types/function-item&quot;&gt;non-function types&lt;/a&gt;, the expression f(...) uses the method on one of the &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;std::ops::Fn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;std::ops::FnMut&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../std/ops/trait.fnonce&quot;&gt;&lt;code&gt;std::ops::FnOnce&lt;/code&gt;&lt;/a&gt; traits, which differ in whether they take the type by reference, mutable reference, or take ownership respectively. An automatic borrow will be taken if needed. Rust will also automatically dereference &lt;code&gt;f&lt;/code&gt; as required. Some examples of call expressions:</source>
          <target state="translated">&lt;em&gt;전화 식은&lt;/em&gt; 괄호 표현 목록 다음 식으로 구성되어 있습니다. 0 개 이상의 입력 변수를 제공하는 함수를 호출합니다. 함수가 결국 리턴하면 표현식이 완료됩니다. 들면 &lt;a href=&quot;../types/function-item&quot;&gt;비 기능 유형&lt;/a&gt; , 식 (F)는 (...) 중 하나의 방법을 사용한다 &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt; &lt;code&gt;std::ops::Fn&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt; &lt;code&gt;std::ops::FnMut&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../std/ops/trait.fnonce&quot;&gt; &lt;code&gt;std::ops::FnOnce&lt;/code&gt; &lt;/a&gt; 특성이든 상이한 이들은 참조, 변경 가능한 참조 또는 유형별로 각각 유형을 취합니다. 필요한 경우 자동 대출이 이루어집니다. Rust는 필요에 따라 자동으로 &lt;code&gt;f&lt;/code&gt; 를 역 참조 합니다. 호출 표현식의 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="30fdc766ea9fe7cd1ba45798e3f6d282c53ef441" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;character literal&lt;/em&gt; is a single Unicode character enclosed within two &lt;code&gt;U+0027&lt;/code&gt; (single-quote) characters, with the exception of &lt;code&gt;U+0027&lt;/code&gt; itself, which must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; character (&lt;code&gt;\&lt;/code&gt;).</source>
          <target state="translated">&lt;em&gt;문자 리터럴은&lt;/em&gt; 두 가지로 둘러싸인 하나의 유니 코드 문자 &lt;code&gt;U+0027&lt;/code&gt; 를 제외하고 (따옴표) 문자 &lt;code&gt;U+0027&lt;/code&gt; 해야 자체 &lt;em&gt;탈출&lt;/em&gt; 선행에 의해 &lt;code&gt;U+005C&lt;/code&gt; 문자 ( &lt;code&gt;\&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3c6b198e97c9744354ac6c754b38292587c4fb26" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;closure expression&lt;/em&gt; defines a closure and denotes it as a value, in a single expression. A closure expression is a pipe-symbol-delimited (&lt;code&gt;|&lt;/code&gt;) list of irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt; followed by an expression. Type annotations may optionally be added for the type of the parameters or for the return type. If there is a return type, the expression used for the body of the closure must be a normal &lt;a href=&quot;block-expr&quot;&gt;block&lt;/a&gt;. A closure expression also may begin with the &lt;code&gt;move&lt;/code&gt; keyword before the initial &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;폐쇄 식&lt;/em&gt; 클로저를 정의하고, 하나의 식에 값으로 나타낸다. (A 밀폐 식 파이프 심볼 구분이다 &lt;code&gt;|&lt;/code&gt; ) 반박에서 &lt;a href=&quot;../patterns&quot;&gt;패턴을&lt;/a&gt; 표현 하였다. 매개 변수 유형 또는 리턴 유형에 대해 유형 어노테이션을 선택적으로 추가 할 수 있습니다. 리턴 유형이있는 경우 클로저 본문에 사용 된 표현식은 일반 &lt;a href=&quot;block-expr&quot;&gt;블록&lt;/a&gt; 이어야합니다 . 클로저 표현도 함께 시작할 수 있습니다 &lt;code&gt;move&lt;/code&gt; 초기 전에 키워드 &lt;code&gt;|&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12a150efcf9ffb345d5ef3ddd2a2876cc8ac7c18" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;cons list&lt;/em&gt; is a data structure that comes from the Lisp programming language and its dialects. In Lisp, the &lt;code&gt;cons&lt;/code&gt; function (short for &amp;ldquo;construct function&amp;rdquo;) constructs a new pair from its two arguments, which usually are a single value and another pair. These pairs containing pairs form a list.</source>
          <target state="translated">&lt;em&gt;단점리스트는&lt;/em&gt; 리스프 프로그래밍 언어와 방언에서 제공되는 데이터 구조입니다. Lisp에서 &lt;code&gt;cons&lt;/code&gt; 함수 ( &quot;construct 함수&quot;의 줄임말)는 일반적으로 단일 값과 다른 쌍인 두 인수에서 새 쌍을 구성합니다. 쌍을 포함하는이 쌍은 목록을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="cfba0b21b720ac42e28e2be5d6bab07c901fa318" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;const context&lt;/em&gt; is one of the following:</source>
          <target state="translated">&lt;em&gt;CONST 컨텍스트는&lt;/em&gt; 다음 중 하나입니다 :</target>
        </trans-unit>
        <trans-unit id="c36e88175514c7e87236cec6eff5e35e2ff35de3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constant item&lt;/em&gt; is an optionally named &lt;em&gt;&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant value&lt;/a&gt;&lt;/em&gt; which is not associated with a specific memory location in the program. Constants are essentially inlined wherever they are used, meaning that they are copied directly into the relevant context when used. References to the same constant are not necessarily guaranteed to refer to the same memory address.</source>
          <target state="translated">&lt;em&gt;상수 항목&lt;/em&gt; 임의로라는 &lt;em&gt;&lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;일정한 값으로&lt;/a&gt;&lt;/em&gt; 프로그램 내의 특정 메모리 위치에 연관되지 않는다. 상수는 기본적으로 사용되는 곳마다 인라인되어 있으므로 사용시 관련 컨텍스트에 직접 복사됩니다. 동일한 상수에 대한 참조가 반드시 동일한 메모리 주소를 나타내는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f7145ab5c52684eb21ecb032f3560fae33132c02" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;crate&lt;/em&gt; is a unit of compilation and linking, as well as versioning, distribution and runtime loading. A crate contains a &lt;em&gt;tree&lt;/em&gt; of nested &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt; scopes. The top level of this tree is a module that is anonymous (from the point of view of paths within the module) and any item within a crate has a canonical &lt;a href=&quot;paths&quot;&gt;module path&lt;/a&gt; denoting its location within the crate's module tree.</source>
          <target state="translated">&lt;em&gt;상자는&lt;/em&gt; 컴파일 및 링크뿐만 아니라 버전 관리, 유통 및 런타임로드의 단위이다. 상자에는 중첩 된 &lt;a href=&quot;items/modules&quot;&gt;모듈&lt;/a&gt; 범위 의 &lt;em&gt;트리&lt;/em&gt; 가 있습니다 . 이 트리의 최상위 레벨은 (모듈 내의 경로 관점에서 볼 때 익명의) 모듈이며, 상자 안의 모든 항목 에는 상자의 모듈 트리 내에서 해당 위치를 나타내는 표준 &lt;a href=&quot;paths&quot;&gt;모듈 경로&lt;/a&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2299b04cb26521f6ac83c838a00ce161fe3ebdb6" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;decimal literal&lt;/em&gt; followed by a period character &lt;code&gt;U+002E&lt;/code&gt; (&lt;code&gt;.&lt;/code&gt;). This is optionally followed by another decimal literal, with an optional &lt;em&gt;exponent&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;소수점 리터럴&lt;/em&gt; 마침표 다음에 &lt;code&gt;U+002E&lt;/code&gt; ( &lt;code&gt;.&lt;/code&gt; ). 선택적으로 &lt;em&gt;exponent&lt;/em&gt; 가있는 또 다른 10 진 리터럴이 뒤에옵니다 .</target>
        </trans-unit>
        <trans-unit id="8945005fcfd339455451ef03bfa95bfaaedef426" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;decimal literal&lt;/em&gt; starts with a &lt;em&gt;decimal digit&lt;/em&gt; and continues with any mixture of &lt;em&gt;decimal digits&lt;/em&gt; and &lt;em&gt;underscores&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;진수 문자&lt;/em&gt; 로 시작 &lt;em&gt;소수점 자리수&lt;/em&gt; 와의 임의의 혼합물로 계속 &lt;em&gt;십진수&lt;/em&gt; 와 &lt;em&gt;밑줄&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="766049e827df03480f975a74379f283f50ff3914" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;declaration statement&lt;/em&gt; is one that introduces one or more &lt;em&gt;names&lt;/em&gt; into the enclosing statement block. The declared names may denote new variables or new &lt;a href=&quot;items&quot;&gt;items&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;선언문은&lt;/em&gt; 하나 또는 그 이상의 도입 하나 &lt;em&gt;이름을&lt;/em&gt; 둘러싸는 문 블록에. 선언 된 이름은 새 변수 또는 새 &lt;a href=&quot;items&quot;&gt;항목을&lt;/a&gt; 나타낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="50530b588ed49ed96a8c5783ad73ba3e37c6ea25" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;field expression&lt;/em&gt; consists of an expression followed by a single dot and an &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt;, when not immediately followed by a parenthesized expression-list (the latter is always a &lt;a href=&quot;method-call-expr&quot;&gt;method call expression&lt;/a&gt;). A field expression denotes a field of a &lt;a href=&quot;../items/structs&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;../items/unions&quot;&gt;union&lt;/a&gt;. To call a function stored in a struct, parentheses are needed around the field expression.</source>
          <target state="translated">&lt;em&gt;필드 식은&lt;/em&gt; 단일 점 및 다음 식으로 구성 &lt;a href=&quot;../identifiers&quot;&gt;식별자&lt;/a&gt; 즉시 괄호 표현리스트 다음하지 않을 때, (후자는 항상 인 &lt;a href=&quot;method-call-expr&quot;&gt;메소드 호출의 표현&lt;/a&gt; ). 필드 표현식은 &lt;a href=&quot;../items/structs&quot;&gt;구조체&lt;/a&gt; 또는 &lt;a href=&quot;../items/unions&quot;&gt;공용체&lt;/a&gt; 의 필드를 나타냅니다 . 구조체에 저장된 함수를 호출하려면 필드 표현식 주위에 괄호가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="cf5014cd7ac2068f18f118543ff07241eda10fbd" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;floating-point literal&lt;/em&gt; has one of two forms:</source>
          <target state="translated">&lt;em&gt;부동 소수점 리터럴&lt;/em&gt; 두 가지 형태 중 하나가 :</target>
        </trans-unit>
        <trans-unit id="4f4b1ebbfdc25acf10623629374f684851ce4095" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;function&lt;/em&gt; consists of a &lt;a href=&quot;../expressions/block-expr&quot;&gt;block&lt;/a&gt;, along with a name and a set of parameters. Other than a name, all these are optional. Functions are declared with the keyword &lt;code&gt;fn&lt;/code&gt;. Functions may declare a set of &lt;em&gt;input&lt;/em&gt;&lt;a href=&quot;../variables&quot;&gt;&lt;em&gt;variables&lt;/em&gt;&lt;/a&gt; as parameters, through which the caller passes arguments into the function, and the &lt;em&gt;output&lt;/em&gt;&lt;a href=&quot;../types#type-expressions&quot;&gt;&lt;em&gt;type&lt;/em&gt;&lt;/a&gt; of the value the function will return to its caller on completion.</source>
          <target state="translated">&lt;em&gt;기능은&lt;/em&gt; 구성&lt;a href=&quot;../expressions/block-expr&quot;&gt; 블록&lt;/a&gt; 의 이름 및 파라미터들의 세트와 함께,. 이름 이외의 모든 옵션은 선택 사항입니다. 함수는 키워드 &lt;code&gt;fn&lt;/code&gt; 으로 선언됩니다 . 함수는 &lt;em&gt;입력 &lt;/em&gt;&lt;a href=&quot;../variables&quot;&gt;&lt;em&gt;변수&lt;/em&gt;&lt;/a&gt; 세트를 매개 &lt;em&gt;변수&lt;/em&gt; 로 선언 할 수 있으며 ,이를 통해 호출자가 인수를 함수에 전달하고, 완료시 함수가 호출자에게 리턴 할 값의 &lt;em&gt;출력 &lt;/em&gt;&lt;a href=&quot;../types#type-expressions&quot;&gt;&lt;em&gt;유형&lt;/em&gt;&lt;/a&gt; 을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f85371a9c250b84e230a898102f42e92fb5ad83" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;generic function&lt;/em&gt; allows one or more &lt;em&gt;parameterized types&lt;/em&gt; to appear in its signature. Each type parameter must be explicitly declared in an angle-bracket-enclosed and comma-separated list, following the function name.</source>
          <target state="translated">&lt;em&gt;일반적인 기능은&lt;/em&gt; 하나 또는 그 이상의 수 &lt;em&gt;매개 변수 유형&lt;/em&gt; 의 서명에 나타납니다. 각 유형 매개 변수는 함수 이름 뒤에 꺾쇠 괄호로 묶고 쉼표로 구분 된 목록으로 명시 적으로 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="e5b0c06878c29b647a5cee7cefa81c23fca43579" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;hash map&lt;/em&gt; allows you to associate a value with a particular key. It&amp;rsquo;s a particular implementation of the more general data structure called a &lt;em&gt;map&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;해시 맵은&lt;/em&gt; 특정 키 값을 연결할 수 있습니다. &lt;em&gt;map&lt;/em&gt; 이라는보다 일반적인 데이터 구조의 특정 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="d2dddac086e471872aa5bba992c51dee8e784e1c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;hex literal&lt;/em&gt; starts with the character sequence &lt;code&gt;U+0030&lt;/code&gt;&lt;code&gt;U+0078&lt;/code&gt; (&lt;code&gt;0x&lt;/code&gt;) and continues as any mixture (with at least one digit) of hex digits and underscores.</source>
          <target state="translated">ㅏ &lt;em&gt;헥스 리터럴&lt;/em&gt; 문자 시퀀스로 시작하는 &lt;code&gt;U+0030&lt;/code&gt; &lt;code&gt;U+0078&lt;/code&gt; ( &lt;code&gt;0x&lt;/code&gt; )과 16 진수 밑줄의 임의의 혼합물 (상기 적어도 하나 명의 숫자로)로 계속된다.</target>
        </trans-unit>
        <trans-unit id="9e38a4ee6fc96f56c22e46e8162db6bbee2c0881" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;literal expression&lt;/em&gt; consists of one of the &lt;a href=&quot;../tokens#literals&quot;&gt;literal&lt;/a&gt; forms described earlier. It directly describes a number, character, string, or boolean value.</source>
          <target state="translated">&lt;em&gt;문자 표현&lt;/em&gt; 의 한 구성 &lt;a href=&quot;../tokens#literals&quot;&gt;문자&lt;/a&gt; 앞에서 설명한 형태. 숫자, 문자, 문자열 또는 부울 값을 직접 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ad9efa9913447a56224684e0aa75e5aeea6b8381" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;local variable&lt;/em&gt; (or &lt;em&gt;stack-local&lt;/em&gt; allocation) holds a value directly, allocated within the stack's memory. The value is a part of the stack frame.</source>
          <target state="translated">&lt;em&gt;로컬 변수&lt;/em&gt; (또는 &lt;em&gt;스택 로컬&lt;/em&gt; 할당) 스택의 메모리 내에 할당 직접 값을 보유하고있다. 값은 스택 프레임의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="5494ba7068df28e0c7f4a4e2a11fa8f85cf97050" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;match guard&lt;/em&gt; is an additional &lt;code&gt;if&lt;/code&gt; condition specified after the pattern in a &lt;code&gt;match&lt;/code&gt; arm that must also match, along with the pattern matching, for that arm to be chosen. Match guards are useful for expressing more complex ideas than a pattern alone allows.</source>
          <target state="translated">ㅏ &lt;em&gt;매치 가드&lt;/em&gt; 부가 인 &lt;code&gt;if&lt;/code&gt; 조건 A의 패턴 후 지정된 &lt;code&gt;match&lt;/code&gt; 이 아암 선택 될 수 있도록, 패턴 정합과 함께도 일치해야 아암. 매치 가드는 패턴만으로 허용되는 것보다 복잡한 아이디어를 표현하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="99824c60f6f2f15272aa4440e52b0f6ee9405ef8" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;method call&lt;/em&gt; consists of an expression (the &lt;em&gt;receiver&lt;/em&gt;) followed by a single dot, an expression path segment, and a parenthesized expression-list. Method calls are resolved to associated &lt;a href=&quot;../items/associated-items#methods&quot;&gt;methods&lt;/a&gt; on specific traits, either statically dispatching to a method if the exact &lt;code&gt;self&lt;/code&gt;-type of the left-hand-side is known, or dynamically dispatching if the left-hand-side expression is an indirect &lt;a href=&quot;../types/trait-object&quot;&gt;trait object&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;메소드 호출은&lt;/em&gt; 식 (이루어져의 &lt;em&gt;수신기&lt;/em&gt; 는 단일 도트 발현 경로 세그먼트, 및 괄호 표현리스트 하였다). 메소드 호출은 연관된 것으로 해석됩니다.&lt;a href=&quot;../items/associated-items#methods&quot;&gt;&lt;/a&gt;왼쪽 의 정확한 &lt;code&gt;self&lt;/code&gt; 유형을 알고있는 경우 메소드에 정적으로 디스패치 하거나 왼쪽 표현식이 간접 &lt;a href=&quot;../types/trait-object&quot;&gt;특성 오브젝트 인&lt;/a&gt; 경우 동적으로 디스패치하는 특정 특성의 메소드 .</target>
        </trans-unit>
        <trans-unit id="4326f6a26736f9868551af52753b80b0248e3c0e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;module item&lt;/em&gt; is a module, surrounded in braces, named, and prefixed with the keyword &lt;code&gt;mod&lt;/code&gt;. A module item introduces a new, named module into the tree of modules making up a crate. Modules can nest arbitrarily.</source>
          <target state="translated">&lt;em&gt;모듈 항목은&lt;/em&gt; 모듈, 괄호로 둘러싸인이라는 이름을 키워드로 시작입니다 &lt;code&gt;mod&lt;/code&gt; . 모듈 아이템은 상자를 구성하는 모듈 트리에 새로운 이름의 모듈을 도입합니다. 모듈은 임의로 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4782354728434eca4d6ed0db530842093ebdfbdf" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;number literal&lt;/em&gt; is either an &lt;em&gt;integer literal&lt;/em&gt; or a &lt;em&gt;floating-point literal&lt;/em&gt;. The grammar for recognizing the two kinds of literals is mixed.</source>
          <target state="translated">&lt;em&gt;숫자 리터럴은&lt;/em&gt; 어느 쪽이다&lt;em&gt; 정수 리터럴&lt;/em&gt; 또는 &lt;em&gt;부동 소수점 리터럴&lt;/em&gt; . 두 종류의 리터럴을 인식하는 문법이 혼합되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a1aa14aba61f76729922fa97eab5dfb14fd43e6" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;path&lt;/em&gt; is a sequence of one or more path segments &lt;em&gt;logically&lt;/em&gt; separated by a namespace qualifier (&lt;code&gt;::&lt;/code&gt;). If a path consists of only one segment, it refers to either an &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; or a &lt;a href=&quot;variables&quot;&gt;variable&lt;/a&gt; in a local control scope. If a path has multiple segments, it always refers to an item.</source>
          <target state="translated">&lt;em&gt;경로는&lt;/em&gt; 하나 개 이상의 경로 세그먼트의 서열이다 &lt;em&gt;논리적&lt;/em&gt; 이름 공간 한정자 (의해 분리 &lt;code&gt;::&lt;/code&gt; ). 경로가 하나의 세그먼트로만 구성된 경우 경로는&lt;a href=&quot;items&quot;&gt;&lt;/a&gt; 로컬 제어 범위 항목 또는 &lt;a href=&quot;variables&quot;&gt;변수&lt;/a&gt; 를 . 경로에 여러 세그먼트가 있으면 항상 항목을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bb92d4c241b315859972fd645fc7612b4dfc9464" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;place expression&lt;/em&gt; is an expression that represents a memory location. These expressions are &lt;a href=&quot;expressions/path-expr&quot;&gt;paths&lt;/a&gt; which refer to local variables, &lt;a href=&quot;items/static-items&quot;&gt;static variables&lt;/a&gt;, &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereferences&lt;/a&gt; (&lt;code&gt;*expr&lt;/code&gt;), &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;array indexing&lt;/a&gt; expressions (&lt;code&gt;expr[expr]&lt;/code&gt;), &lt;a href=&quot;expressions/field-expr&quot;&gt;field&lt;/a&gt; references (&lt;code&gt;expr.f&lt;/code&gt;) and parenthesized place expressions. All other expressions are value expressions.</source>
          <target state="translated">&lt;em&gt;장소 식&lt;/em&gt; 메모리 위치를 나타내는 식이다. 이 표현식은 로컬 변수, &lt;a href=&quot;items/static-items&quot;&gt;정적 변수&lt;/a&gt; , &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;역 참조&lt;/a&gt; ( &lt;code&gt;*expr&lt;/code&gt; ), &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;배열 인덱싱&lt;/a&gt; 표현식 ( &lt;code&gt;expr[expr]&lt;/code&gt; ), &lt;a href=&quot;expressions/field-expr&quot;&gt;필드&lt;/a&gt; 를 참조하는 &lt;a href=&quot;expressions/path-expr&quot;&gt;경로 &lt;/a&gt;입니다. 레퍼런스 ( &lt;code&gt;expr.f&lt;/code&gt; ) 및 괄호 장소 식. 다른 모든 표현식은 값 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="53e179d5349063cc7a43deec2333f4a66dd27469" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;pointer&lt;/em&gt; is a general concept for a variable that contains an address in memory. This address refers to, or &amp;ldquo;points at,&amp;rdquo; some other data. The most common kind of pointer in Rust is a reference, which you learned about in Chapter 4. References are indicated by the &lt;code&gt;&amp;amp;&lt;/code&gt; symbol and borrow the value they point to. They don&amp;rsquo;t have any special capabilities other than referring to data. Also, they don&amp;rsquo;t have any overhead and are the kind of pointer we use most often.</source>
          <target state="translated">&lt;em&gt;포인터&lt;/em&gt; 메모리에 주소를 포함하는 변수에 대한 일반적인 개념이다. 이 주소는 다른 데이터를 가리 킵니다. Rust에서 가장 일반적인 종류의 포인터는 4 장에서 배운 참조입니다. 참조는 &lt;code&gt;&amp;amp;&lt;/code&gt; 기호 로 표시되며 그들이 가리키는 값을 빌립니다. 그들은 데이터를 언급하는 것 외에 특별한 기능이 없습니다. 또한 오버 헤드가 없으며 가장 자주 사용하는 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="7fe098911943171d28affe53c0c7d6311adf867c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;relative path&lt;/em&gt; starts from the current module and uses &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;super&lt;/code&gt;, or an identifier in the current module.</source>
          <target state="translated">&lt;em&gt;상대 경로는&lt;/em&gt; 현재 모듈 및 용법에서 시작 &lt;code&gt;self&lt;/code&gt; , &lt;code&gt;super&lt;/code&gt; 또는 현재 모듈 식별자.</target>
        </trans-unit>
        <trans-unit id="b7be095308c163f67b48127967466163200c85dc" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;scalar&lt;/em&gt; type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters. You may recognize these from other programming languages. Let&amp;rsquo;s jump into how they work in Rust.</source>
          <target state="translated">ㅏ &lt;em&gt;스칼라&lt;/em&gt; 타입은 하나의 값을 나타낸다. Rust에는 정수, 부동 소수점 숫자, 부울 및 문자의 네 가지 기본 스칼라 유형이 있습니다. 다른 프로그래밍 언어에서이를 인식 할 수 있습니다. 그들이 Rust에서 어떻게 작동하는지 살펴 봅시다.</target>
        </trans-unit>
        <trans-unit id="5e00452619a2cd4e10d7a42ab9898d401215bca3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;statement&lt;/em&gt; is a component of a &lt;a href=&quot;expressions/block-expr&quot;&gt;block&lt;/a&gt;, which is in turn a component of an outer &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; or &lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;문&lt;/em&gt; (A)의 구성 요소 인 &lt;a href=&quot;expressions/block-expr&quot;&gt;블록&lt;/a&gt; 차례로 외부의 구성 요소, &lt;a href=&quot;expressions&quot;&gt;표현&lt;/a&gt; 또는 &lt;a href=&quot;items/functions&quot;&gt;함수&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9cd3832cf111028f53f6cad959deb6ad53f56ca0" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;static item&lt;/em&gt; is similar to a &lt;a href=&quot;constant-items&quot;&gt;constant&lt;/a&gt;, except that it represents a precise memory location in the program. All references to the static refer to the same memory location. Static items have the &lt;code&gt;static&lt;/code&gt; lifetime, which outlives all other lifetimes in a Rust program. Non-&lt;code&gt;mut&lt;/code&gt; static items that contain a type that is not &lt;a href=&quot;../interior-mutability&quot;&gt;interior mutable&lt;/a&gt; may be placed in read-only memory. Static items do not call &lt;a href=&quot;../destructors&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; at the end of the program.</source>
          <target state="translated">&lt;em&gt;정적 항목&lt;/em&gt; A와 비슷 &lt;a href=&quot;constant-items&quot;&gt;상수&lt;/a&gt; 가 프로그램의 정확한 메모리 위치를 나타내는 것을 제외. 정적에 대한 모든 참조는 동일한 메모리 위치를 나타냅니다. 정적 아이템은 &lt;code&gt;static&lt;/code&gt; 수명을 가지며 , 이는 Rust 프로그램에서 다른 모든 수명보다 오래 지속됩니다. &lt;a href=&quot;../interior-mutability&quot;&gt;내부에서 변경할&lt;/a&gt; 수 없는 유형이 포함 된 비 &lt;code&gt;mut&lt;/code&gt; 정적 항목 은 읽기 전용 메모리에 배치 될 수 있습니다. 정적 아이템은 &lt;a href=&quot;../destructors&quot;&gt; &lt;code&gt;drop&lt;/code&gt; &lt;/a&gt; 호출하지 않습니다 프로그램 끝에서 을 .</target>
        </trans-unit>
        <trans-unit id="045ded2942d599b289c8f6860ad989b955a99d7c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string literal&lt;/em&gt; is a sequence of any Unicode characters enclosed within two &lt;code&gt;U+0022&lt;/code&gt; (double-quote) characters, with the exception of &lt;code&gt;U+0022&lt;/code&gt; itself, which must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; character (&lt;code&gt;\&lt;/code&gt;).</source>
          <target state="translated">&lt;em&gt;문자열 리터럴&lt;/em&gt; 이 묶여 유니 코드 문자의 순서입니다 &lt;code&gt;U+0022&lt;/code&gt; 를 제외하고, (큰 따옴표) 문자 &lt;code&gt;U+0022&lt;/code&gt; 해야 자체 &lt;em&gt;탈출&lt;/em&gt; 선행에 의해 &lt;code&gt;U+005C&lt;/code&gt; 문자 ( &lt;code&gt;\&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f12122f88fa635dd2b58aa377fdb09d19aba988d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string slice&lt;/em&gt; is a reference to part of a &lt;code&gt;String&lt;/code&gt;, and it looks like this:</source>
          <target state="translated">&lt;em&gt;문자열 슬라이스&lt;/em&gt; (A)의 일부에 대한 참조입니다 &lt;code&gt;String&lt;/code&gt; , 그것은 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="691e369dd4289704604ecf4cd7dd7181b87971ad" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;string&lt;/em&gt; is a collection of characters. We&amp;rsquo;ve mentioned the &lt;code&gt;String&lt;/code&gt; type previously, but in this chapter we&amp;rsquo;ll talk about it in depth.</source>
          <target state="translated">&lt;em&gt;문자열은&lt;/em&gt; 문자의 모음입니다. 우리는 &lt;code&gt;String&lt;/code&gt; 언급했습니다 유형에 했지만이 장에서는 이에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ac2f7e212f4d47b7d6ba3c1b79c057cc109911ff" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;struct expression&lt;/em&gt; creates a struct or union value. It consists of a path to a &lt;a href=&quot;../items/structs&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;../items/unions&quot;&gt;union&lt;/a&gt; item followed by the values for the fields of the item. There are three forms of struct expressions: struct, tuple, and unit.</source>
          <target state="translated">&lt;em&gt;구조체 식&lt;/em&gt; 구조체 또는 조합 값을 생성합니다. &lt;a href=&quot;../items/structs&quot;&gt;구조체&lt;/a&gt; 또는 &lt;a href=&quot;../items/unions&quot;&gt;공용체&lt;/a&gt; 에 대한 경로로 구성됩니다. 아이템 아이템 필드의 값으로 구성됩니다. 구조체 표현에는 구조체, 튜플 및 단위의 세 가지 형태가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d65205e4e512b884279b051d3f883110c3677542" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;struct&lt;/em&gt; is a nominal &lt;a href=&quot;../types/struct&quot;&gt;struct type&lt;/a&gt; defined with the keyword &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;구조체는&lt;/em&gt; 공칭입니다 &lt;a href=&quot;../types/struct&quot;&gt;구조체 형식&lt;/a&gt; 키워드로 정의 &lt;code&gt;struct&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b38ad3b7538f97629f5686d68a34da8981cf5d0" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;struct&lt;/em&gt;, or &lt;em&gt;structure&lt;/em&gt;, is a custom data type that lets you name and package together multiple related values that make up a meaningful group. If you&amp;rsquo;re familiar with an object-oriented language, a &lt;em&gt;struct&lt;/em&gt; is like an object&amp;rsquo;s data attributes. In this chapter, we&amp;rsquo;ll compare and contrast tuples with structs, demonstrate how to use structs, and discuss how to define methods and associated functions to specify behavior associated with a struct&amp;rsquo;s data. Structs and enums (discussed in Chapter 6) are the building blocks for creating new types in your program&amp;rsquo;s domain to take full advantage of Rust&amp;rsquo;s compile time type checking.</source>
          <target state="translated">&lt;em&gt;구조체&lt;/em&gt; , 또는 &lt;em&gt;구조&lt;/em&gt; , 당신은 이름을 지정하고 의미있는 그룹을 만들어 함께 여러 관련 값을 패키징 할 수있는 사용자 정의 데이터 유형입니다. 객체 지향 언어에 익숙하다면 &lt;em&gt;구조체&lt;/em&gt; 는 객체의 데이터 속성과 같습니다. 이 장에서는 튜플을 구조체와 비교 및 ​​대조하고, 구조체를 사용하는 방법을 보여 주며, 구조체의 데이터와 관련된 동작을 지정하는 메서드 및 관련 함수를 정의하는 방법에 대해 설명합니다. Structs와 enum (6 장에서 논의)은 Rust의 컴파일 타임 타입 검사를 최대한 활용하기 위해 프로그램 도메인에서 새로운 타입을 생성하기위한 빌딩 블록입니다.</target>
        </trans-unit>
        <trans-unit id="c2b858ff2e5a4ed485b3e5e4a18471183d07402f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;test double&lt;/em&gt; is the general programming concept for a type used in place of another type during testing. &lt;em&gt;Mock objects&lt;/em&gt; are specific types of test doubles that record what happens during a test so you can assert that the correct actions took place.</source>
          <target state="translated">&lt;em&gt;시험은 두 번&lt;/em&gt; 테스트 중에 다른 유형의 장소에서 사용되는 유형에 대한 일반 프로그래밍 개념이다. &lt;em&gt;모의 객체&lt;/em&gt; 는 테스트 중에 발생하는 상황을 기록하는 특정 유형의 테스트 복식으로 올바른 동작이 발생했는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a0e24d887e877ac9c41e5667ab7a119a4c29456" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;thread pool&lt;/em&gt; is a group of spawned threads that are waiting and ready to handle a task. When the program receives a new task, it assigns one of the threads in the pool to the task, and that thread will process the task. The remaining threads in the pool are available to handle any other tasks that come in while the first thread is processing. When the first thread is done processing its task, it&amp;rsquo;s returned to the pool of idle threads, ready to handle a new task. A thread pool allows you to process connections concurrently, increasing the throughput of your server.</source>
          <target state="translated">&lt;em&gt;스레드 풀&lt;/em&gt; 기다리고 작업을 처리 할 준비가되어 산란 스레드 그룹입니다. 프로그램이 새 작업을 받으면 풀의 스레드 중 하나를 작업에 할당하면 해당 스레드가 작업을 처리합니다. 풀의 나머지 스레드는 첫 번째 스레드가 처리되는 동안 들어오는 다른 작업을 처리하는 데 사용할 수 있습니다. 첫 번째 스레드가 작업 처리를 완료하면 유휴 스레드 풀로 반환되어 새 작업을 처리 할 수 ​​있습니다. 스레드 풀을 사용하면 연결을 동시에 처리하여 서버의 처리량을 높일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="313b18e83bc534426ba5a3363e3ef30c68738ffe" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait implementation&lt;/em&gt; is defined like an inherent implementation except that the optional generic type declarations is followed by a &lt;a href=&quot;traits&quot;&gt;trait&lt;/a&gt; followed by the keyword &lt;code&gt;for&lt;/code&gt;. Followed by a path to a nominal type.</source>
          <target state="translated">&lt;em&gt;특성 구현은&lt;/em&gt; 선택 사양 제네릭 형식 선언이 뒤에 것을 제외하고 고유의 구현과 같이 정의 &lt;a href=&quot;traits&quot;&gt;특성&lt;/a&gt; 키워드 다음 &lt;code&gt;for&lt;/code&gt; . 공칭 유형에 대한 경로가 뒤 따릅니다.</target>
        </trans-unit>
        <trans-unit id="2ba7bca2e53443f2e59cd9b7a5cdc8e34241ae48" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait object&lt;/em&gt; is an opaque value of another type that implements a set of traits. The set of traits is made up of an &lt;a href=&quot;../items/traits#object-safety&quot;&gt;object safe&lt;/a&gt;&lt;em&gt;base trait&lt;/em&gt; plus any number of &lt;a href=&quot;../special-types-and-traits#auto-traits&quot;&gt;auto traits&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;특성 객체는&lt;/em&gt; 다른 종류의 특성을 구현하는 일련의 불투명 한 값이다. 특성 세트는 &lt;a href=&quot;../items/traits#object-safety&quot;&gt;객체 안전 &lt;/a&gt;&lt;em&gt;기본 특성&lt;/em&gt; 과 여러 &lt;a href=&quot;../special-types-and-traits#auto-traits&quot;&gt;자동 특성으로 구성&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="5df129cc6b630156d556e5813378ed108b2ab443" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait&lt;/em&gt; describes an abstract interface that types can implement. This interface consists of &lt;a href=&quot;associated-items&quot;&gt;associated items&lt;/a&gt;, which come in three varieties:</source>
          <target state="translated">&lt;em&gt;특성은&lt;/em&gt; 유형을 구현할 수 있다는 추상적 인 인터페이스를 설명합니다. 이 인터페이스는 &lt;a href=&quot;associated-items&quot;&gt;관련 항목으로&lt;/a&gt; 구성 되며 세 가지 유형으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a413d8d80703ed47836b183924cabc19246e5f7c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;trait&lt;/em&gt; tells the Rust compiler about functionality a particular type has and can share with other types. We can use traits to define shared behavior in an abstract way. We can use trait bounds to specify that a generic can be any type that has certain behavior.</source>
          <target state="translated">&lt;em&gt;특성은&lt;/em&gt; 특정 유형이 다른 유형과 공유 할 수있는 기능에 대해 녹 컴파일러를 알려줍니다. 특성을 사용하여 추상적 인 방식으로 공유 동작을 정의 할 수 있습니다. 특성 경계를 사용하여 제네릭이 특정 동작이있는 모든 유형이 될 수 있음을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9018c5e20d838075d5b138f7d86d8d8c684fb244" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tuple index&lt;/em&gt; is either &lt;code&gt;0&lt;/code&gt;, or starts with a &lt;em&gt;non-zero decimal digit&lt;/em&gt; and continues with zero or more decimal digits. Tuple indexes are used to refer to the fields of &lt;a href=&quot;types/tuple&quot;&gt;tuples&lt;/a&gt;, &lt;a href=&quot;items/structs&quot;&gt;tuple structs&lt;/a&gt; and &lt;a href=&quot;items/enumerations&quot;&gt;tuple variants&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;튜플 인덱스&lt;/em&gt; 하나이고 &lt;code&gt;0&lt;/code&gt; 또는로 시작 &lt;em&gt;비제 소수점 자리수&lt;/em&gt; 와 0 개 이상의 십진수로 계속된다. 튜플 인덱스는 &lt;a href=&quot;types/tuple&quot;&gt;튜플&lt;/a&gt; , &lt;a href=&quot;items/structs&quot;&gt;튜플 구조체&lt;/a&gt; 및 &lt;a href=&quot;items/enumerations&quot;&gt;튜플 변형&lt;/a&gt; 의 필드를 나타내는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c47a882c5415e255f49931b3989ce3cbb03e65f7" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tuple struct&lt;/em&gt; is a nominal &lt;a href=&quot;../types/tuple&quot;&gt;tuple type&lt;/a&gt;, also defined with the keyword &lt;code&gt;struct&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;em&gt;튜플 구조체는&lt;/em&gt; 공칭입니다 &lt;a href=&quot;../types/tuple&quot;&gt;튜플 형식&lt;/a&gt; 또한 키워드를 사용하여 정의, &lt;code&gt;struct&lt;/code&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e97b14c685e031728ecd4469c910a8f3603e601d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tuple struct&lt;/em&gt; type is just like a struct type, except that the fields are anonymous.</source>
          <target state="translated">&lt;em&gt;튜플 구조체의&lt;/em&gt; 유형은 필드가 익명 것을 제외하고, 단지 구조체 형과 같다.</target>
        </trans-unit>
        <trans-unit id="57b75c1dd6681cfbd15ca11a1f0f5681b515a0f3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;type alias&lt;/em&gt; defines a new name for an existing &lt;a href=&quot;../types&quot;&gt;type&lt;/a&gt;. Type aliases are declared with the keyword &lt;code&gt;type&lt;/code&gt;. Every value has a single, specific type, but may implement several different traits, or be compatible with several different type constraints.</source>
          <target state="translated">&lt;em&gt;타입 별칭은&lt;/em&gt; 기존의 새 이름을 정의하는 &lt;a href=&quot;../types&quot;&gt;유형&lt;/a&gt; . 유형 별명은 키워드 &lt;code&gt;type&lt;/code&gt; 으로 선언됩니다 . 모든 값에는 하나의 특정 유형이 있지만 여러 가지 특성을 구현하거나 여러 가지 유형 제한 조건과 호환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64ff4b8d7e3ee42067c7072aacfc14cd027c093c" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;type expression&lt;/em&gt; as defined in the &lt;em&gt;Type&lt;/em&gt; grammar rule above is the syntax for referring to a type. It may refer to:</source>
          <target state="translated">&lt;em&gt;형 표현&lt;/em&gt; 에 정의로 &lt;em&gt;입력&lt;/em&gt; 문법 규칙은 전술 한 유형을 참조하는 구문이다. 다음을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50c0af6b4bb64ca1523e3b2abba8e82a69abff5a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;union type&lt;/em&gt; is a nominal, heterogeneous C-like union, denoted by the name of a &lt;a href=&quot;../items/unions&quot;&gt;&lt;code&gt;union&lt;/code&gt; item&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;유니온 타입&lt;/em&gt; (A)의 이름 붙이고 공칭 이종 C 형상의 조합 인 &lt;a href=&quot;../items/unions&quot;&gt; &lt;code&gt;union&lt;/code&gt; 아이템&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="96e68805af9609cb7109b9bd3ef8c3be60b740ca" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;unit-like struct&lt;/em&gt; is a struct without any fields, defined by leaving off the list of fields entirely. Such a struct implicitly defines a constant of its type with the same name. For example:</source>
          <target state="translated">&lt;em&gt;유닛 형 구조체&lt;/em&gt; 전체 필드 목록을 남김으로써 정의 된 필드가없는 구조체이다. 이러한 구조체는 동일한 이름을 가진 유형의 상수를 암시 적으로 정의합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6075d4cd12c28e60ac874060f12974e3762a509a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;unit-like struct&lt;/em&gt; type is like a struct type, except that it has no fields. The one value constructed by the associated &lt;a href=&quot;../expressions/struct-expr&quot;&gt;struct expression&lt;/a&gt; is the only value that inhabits such a type.</source>
          <target state="translated">&lt;em&gt;구조체 부 형상&lt;/em&gt; 타입은 어떤 필드가 없다는 것을 제외하고, 구조체의 형태와 같다. 연관된 &lt;a href=&quot;../expressions/struct-expr&quot;&gt;구조체 표현식으로&lt;/a&gt; 구성된 하나의 값 은 이러한 유형에있는 유일한 값입니다.</target>
        </trans-unit>
        <trans-unit id="ed7d45b3f3a4f92438f32980c894150a8a0dee9d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;use declaration&lt;/em&gt; creates one or more local name bindings synonymous with some other &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt;. Usually a &lt;code&gt;use&lt;/code&gt; declaration is used to shorten the path required to refer to a module item. These declarations may appear in &lt;a href=&quot;modules&quot;&gt;modules&lt;/a&gt; and &lt;a href=&quot;../expressions/block-expr&quot;&gt;blocks&lt;/a&gt;, usually at the top.</source>
          <target state="translated">&lt;em&gt;사용 선언은&lt;/em&gt; 다른과 동의어 하나 이상의 로컬 이름 바인딩 생성 &lt;a href=&quot;../paths&quot;&gt;경로를&lt;/a&gt; . 일반적으로 &lt;code&gt;use&lt;/code&gt; 선언은 모듈 항목을 참조하는 데 필요한 경로를 단축하는 데 사용됩니다. 이러한 선언은 일반적으로 맨 위에 &lt;a href=&quot;modules&quot;&gt;모듈&lt;/a&gt; 과 &lt;a href=&quot;../expressions/block-expr&quot;&gt;블록에&lt;/a&gt; 나타날 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2d8a654904db4cbe04f06da827ae2d7d450774ec" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;value expression&lt;/em&gt; is an expression that represents an actual value.</source>
          <target state="translated">&lt;em&gt;값 식은&lt;/em&gt; 실제의 값을 나타내는 식이다.</target>
        </trans-unit>
        <trans-unit id="729fdc3c2a54819bca891fd0485aedb791a49cea" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;variable&lt;/em&gt; is a component of a stack frame, either a named function parameter, an anonymous &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;temporary&lt;/a&gt;, or a named local variable.</source>
          <target state="translated">&lt;em&gt;변수는&lt;/em&gt; 스택 프레임의 구성 요소 중 하나라는 함수 파라미터 익명 인 &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;임시&lt;/a&gt; 또는 로컬 변수의 이름.</target>
        </trans-unit>
        <trans-unit id="81028e39252e1de4d0939b21f1ccc9432b693d6d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;vector&lt;/em&gt; allows you to store a variable number of values next to each other.</source>
          <target state="translated">&lt;em&gt;벡터&lt;/em&gt; 는 서로 옆에 값의 변수 번호를 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbf31b3f11b4472e6a3c452469774ef2fe901798" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;whitespace escape&lt;/em&gt; is one of the characters &lt;code&gt;U+006E&lt;/code&gt; (&lt;code&gt;n&lt;/code&gt;), &lt;code&gt;U+0072&lt;/code&gt; (&lt;code&gt;r&lt;/code&gt;), or &lt;code&gt;U+0074&lt;/code&gt; (&lt;code&gt;t&lt;/code&gt;), denoting the Unicode values &lt;code&gt;U+000A&lt;/code&gt; (LF), &lt;code&gt;U+000D&lt;/code&gt; (CR) or &lt;code&gt;U+0009&lt;/code&gt; (HT) respectively.</source>
          <target state="translated">&lt;em&gt;공백 탈출&lt;/em&gt; 문자 중 하나이며 &lt;code&gt;U+006E&lt;/code&gt; ( &lt;code&gt;n&lt;/code&gt; ), &lt;code&gt;U+0072&lt;/code&gt; ( &lt;code&gt;r&lt;/code&gt; ) 또는 &lt;code&gt;U+0074&lt;/code&gt; ( &lt;code&gt;t&lt;/code&gt; 유니 값들 나타내는) &lt;code&gt;U+000A&lt;/code&gt; (LF), &lt;code&gt;U+000D&lt;/code&gt; (CR) 또는 &lt;code&gt;U+0009&lt;/code&gt; (HT).</target>
        </trans-unit>
        <trans-unit id="733e62321cc2dbb502882e64ee8c595f1cf223e3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;whitespace escape&lt;/em&gt; is one of the characters &lt;code&gt;U+006E&lt;/code&gt; (&lt;code&gt;n&lt;/code&gt;), &lt;code&gt;U+0072&lt;/code&gt; (&lt;code&gt;r&lt;/code&gt;), or &lt;code&gt;U+0074&lt;/code&gt; (&lt;code&gt;t&lt;/code&gt;), denoting the bytes values &lt;code&gt;0x0A&lt;/code&gt; (ASCII LF), &lt;code&gt;0x0D&lt;/code&gt; (ASCII CR) or &lt;code&gt;0x09&lt;/code&gt; (ASCII HT) respectively.</source>
          <target state="translated">&lt;em&gt;공백 탈출&lt;/em&gt; 문자 중 하나이며 &lt;code&gt;U+006E&lt;/code&gt; ( &lt;code&gt;n&lt;/code&gt; ), &lt;code&gt;U+0072&lt;/code&gt; ( &lt;code&gt;r&lt;/code&gt; ) 또는 &lt;code&gt;U+0074&lt;/code&gt; ( &lt;code&gt;t&lt;/code&gt; (가) 값 바이트를 나타내는) &lt;code&gt;0x0A&lt;/code&gt; (ASCII의 LF) &lt;code&gt;0x0D&lt;/code&gt; (ASCII CR) 또는 &lt;code&gt;0x09&lt;/code&gt; (ASCII HT ).</target>
        </trans-unit>
        <trans-unit id="17736723b13336b3d27ceb298ec5fb02952febad" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;workspace&lt;/em&gt; is a set of packages that share the same &lt;em&gt;Cargo.lock&lt;/em&gt; and output directory. Let&amp;rsquo;s make a project using a workspace&amp;mdash;we&amp;rsquo;ll use trivial code so we can concentrate on the structure of the workspace. There are multiple ways to structure a workspace; we&amp;rsquo;re going to show one common way. We&amp;rsquo;ll have a workspace containing a binary and two libraries. The binary, which will provide the main functionality, will depend on the two libraries. One library will provide an &lt;code&gt;add_one&lt;/code&gt; function, and a second library an &lt;code&gt;add_two&lt;/code&gt; function. These three crates will be part of the same workspace. We&amp;rsquo;ll start by creating a new directory for the workspace:</source>
          <target state="translated">&lt;em&gt;작업 공간은&lt;/em&gt; 같은 공유 패키지 세트입니다 &lt;em&gt;Cargo.lock&lt;/em&gt; 출력 디렉토리를. 작업 공간을 사용하여 프로젝트를 만들어 봅시다. 간단한 코드를 사용하여 작업 공간의 구조에 집중할 수 있습니다. 작업 공간을 구성하는 방법에는 여러 가지가 있습니다. 우리는 하나의 일반적인 방법을 보여줄 것입니다. 바이너리와 두 개의 라이브러리가 포함 된 작업 공간이 있습니다. 주요 기능을 제공 할 바이너리는 두 라이브러리에 따라 다릅니다. 하나의 라이브러리가 제공됩니다 &lt;code&gt;add_one&lt;/code&gt; 의 기능, 두 번째 라이브러리 &lt;code&gt;add_two&lt;/code&gt; 기능을. 이 3 개의 상자는 동일한 작업 공간의 일부가됩니다. 작업 공간을위한 새로운 디렉토리를 생성하는 것으로 시작하겠습니다 :</target>
        </trans-unit>
        <trans-unit id="57b97a971f9a5924055674cfb5ecccdeda84f005" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;multiprocessor&lt;/strong&gt; system executing multiple hardware threads at the same time: In multi-threaded scenarios, you can use two kinds of primitives to deal with synchronization:</source>
          <target state="translated">다중 하드웨어 스레드를 동시에 실행 하는 &lt;strong&gt;다중 프로세서&lt;/strong&gt; 시스템 : 다중 스레드 시나리오에서는 두 가지 유형의 기본 요소를 사용하여 동기화를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="9915cb86be4513e2479c88bd6630c4bace88619c" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;send&lt;/strong&gt; operation can only fail if the receiving end of a channel is disconnected, implying that the data could never be received. The error contains the data being sent as a payload so it can be recovered.</source>
          <target state="translated">&lt;strong&gt;전송&lt;/strong&gt; 채널의 수신 측이 데이터가 수신되지 않을 수 있음을 암시 분리되면 조작은 실패 할 수 있습니다. 오류는 복구 할 수 있도록 페이로드로 전송되는 데이터를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="45d6b0e56e209127760ab52ba9ab193c0dce03db" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;single processor&lt;/strong&gt; executing instructions &lt;a href=&quot;https://en.wikipedia.org/wiki/Out-of-order_execution&quot;&gt;out-of-order&lt;/a&gt;: Modern CPUs are capable of &lt;a href=&quot;https://en.wikipedia.org/wiki/Superscalar_processor&quot;&gt;superscalar&lt;/a&gt; execution, i.e., multiple instructions might be executing at the same time, even though the machine code describes a sequential process.</source>
          <target state="translated">&lt;strong&gt;단일 프로세서&lt;/strong&gt; 명령어 실행 &lt;a href=&quot;https://en.wikipedia.org/wiki/Out-of-order_execution&quot;&gt;밖으로의 순서를&lt;/a&gt; : 현대 CPU는 할 수있는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Superscalar_processor&quot;&gt;슈퍼 스칼라&lt;/a&gt; , 여러 지침은 기계 코드가 순차적 인 프로세스를 설명에도 불구하고, 동시에 실행 될 수있다 즉 실행.</target>
        </trans-unit>
        <trans-unit id="f80e6281478ac21b10d3f64a5db5116d11300661" translate="yes" xml:space="preserve">
          <source>A B-Tree instead makes each node contain B-1 to 2B-1 elements in a contiguous array. By doing this, we reduce the number of allocations by a factor of B, and improve cache efficiency in searches. However, this does mean that searches will have to do &lt;em&gt;more&lt;/em&gt; comparisons on average. The precise number of comparisons depends on the node search strategy used. For optimal cache efficiency, one could search the nodes linearly. For optimal comparisons, one could search the node using binary search. As a compromise, one could also perform a linear search that initially only checks every i&lt;sup&gt;th&lt;/sup&gt; element for some choice of i.</source>
          <target state="translated">대신 B- 트리는 각 노드에 연속 배열의 B-1 ~ 2B-1 요소를 포함시킵니다. 이를 통해 B 수만큼 할당 수를 줄이고 검색시 캐시 효율성을 향상시킵니다. 그러나 이것은 검색이 평균적으로 &lt;em&gt;더 많은&lt;/em&gt; 비교 를 수행해야 함을 의미합니다 . 정확한 비교 수는 사용 된 노드 검색 전략에 따라 다릅니다. 최적의 캐시 효율성을 위해 노드를 선형으로 검색 할 수 있습니다. 최적의 비교를 위해 이진 검색을 사용하여 노드를 검색 할 수 있습니다. 타협으로, 처음에는 모든 i &lt;sup&gt;번째&lt;/sup&gt; 요소 만 i의 선택을 확인하는 선형 검색을 수행 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c719a71ad064f07814cb183dc83cacff56d42170" translate="yes" xml:space="preserve">
          <source>A Closer Look at an HTTP Request</source>
          <target state="translated">HTTP 요청 자세히 살펴보기</target>
        </trans-unit>
        <trans-unit id="225f2cd7742ef94df62bae5174a9097b85507248" translate="yes" xml:space="preserve">
          <source>A Condition Variable</source>
          <target state="translated">조건 변수</target>
        </trans-unit>
        <trans-unit id="e89d14f838ea1a71651772640c4009592aced676" translate="yes" xml:space="preserve">
          <source>A Rust binary or library.</source>
          <target state="translated">Rust 바이너리 또는 라이브러리.</target>
        </trans-unit>
        <trans-unit id="16eac1f550799edbb7e48476dda921af52e9a679" translate="yes" xml:space="preserve">
          <source>A Rust program has identical meaning if each whitespace element is replaced with any other legal whitespace element, such as a single space character.</source>
          <target state="translated">각 공백 요소가 단일 공백 ​​문자와 같은 다른 유효한 공백 요소로 대체되는 경우 Rust 프로그램은 동일한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="3436eb9d1ac524996565fc93c80cf6376e000505" translate="yes" xml:space="preserve">
          <source>A Rust source file describes a module, the name and location of which &amp;mdash; in the module tree of the current crate &amp;mdash; are defined from outside the source file: either by an explicit &lt;a href=&quot;items/modules&quot;&gt;&lt;em&gt;Module&lt;/em&gt;&lt;/a&gt; item in a referencing source file, or by the name of the crate itself. Every source file is a module, but not every module needs its own source file: &lt;a href=&quot;items/modules&quot;&gt;module definitions&lt;/a&gt; can be nested within one file.</source>
          <target state="translated">Rust 소스 파일은 현재 상자의 모듈 트리에서 모듈의 이름과 위치를 소스 파일 외부에서 정의 합니다 (참조 소스 파일 의 명시 적 &lt;a href=&quot;items/modules&quot;&gt;&lt;em&gt;모듈&lt;/em&gt;&lt;/a&gt; 항목 또는 상자 자체. 모든 소스 파일은 모듈이지만 모든 모듈에 고유 한 소스 파일이 필요한 것은 아닙니다. &lt;a href=&quot;items/modules&quot;&gt;모듈 정의&lt;/a&gt; 는 하나의 파일 내에 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e4ee862d170940577240b6a363de9c90118288a" translate="yes" xml:space="preserve">
          <source>A Shortcut for Propagating Errors: the &lt;code id=&quot;a-shortcut-for-propagating-errors-the--operator&quot;&gt;?&lt;/code&gt; Operator</source>
          <target state="translated">오류 전파를위한 지름길 : &lt;code id=&quot;a-shortcut-for-propagating-errors-the--operator&quot;&gt;?&lt;/code&gt; 운영자</target>
        </trans-unit>
        <trans-unit id="e0701ba8496c6c0ce0663c50dfed3d1742ffe428" translate="yes" xml:space="preserve">
          <source>A TCP socket server, listening for connections.</source>
          <target state="translated">연결을 청취하는 TCP 소켓 서버.</target>
        </trans-unit>
        <trans-unit id="18b391c1b0a22ff1e173b47c159e749d6face6b8" translate="yes" xml:space="preserve">
          <source>A TCP stream between a local and a remote socket.</source>
          <target state="translated">로컬 소켓과 원격 소켓 사이의 TCP 스트림.</target>
        </trans-unit>
        <trans-unit id="14cd46b40ffb5428999e053c5d3b3c28ef9b4547" translate="yes" xml:space="preserve">
          <source>A Touch of Refactoring</source>
          <target state="translated">리팩토링의 손길</target>
        </trans-unit>
        <trans-unit id="f8b80e8d44eb439e0e6a949110529d41c8e00ad6" translate="yes" xml:space="preserve">
          <source>A Tour of The Rust Standard Library</source>
          <target state="translated">녹 표준 도서관 둘러보기</target>
        </trans-unit>
        <trans-unit id="816b40a1a34bc0276678819c021264566903408c" translate="yes" xml:space="preserve">
          <source>A UDP socket.</source>
          <target state="translated">UDP 소켓.</target>
        </trans-unit>
        <trans-unit id="276e8a17fbe2956e663b37ba194fe05fa5a8f2c4" translate="yes" xml:space="preserve">
          <source>A UTF-8 encoded, growable string.</source>
          <target state="translated">UTF-8로 인코딩되고 확장 가능한 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="bb20973ca0b74c01c90760f89fd1e1ce6ddd0490" translate="yes" xml:space="preserve">
          <source>A Unix datagram socket.</source>
          <target state="translated">유닉스 데이터 그램 소켓.</target>
        </trans-unit>
        <trans-unit id="a23c9f511bfc020ca8a27e2556501e3c327d1d73" translate="yes" xml:space="preserve">
          <source>A Unix stream socket.</source>
          <target state="translated">유닉스 스트림 소켓.</target>
        </trans-unit>
        <trans-unit id="3ad52f3aeb1d324427854f3ea2a73655c8ec06e9" translate="yes" xml:space="preserve">
          <source>A Use Case for Interior Mutability: Mock Objects</source>
          <target state="translated">내부 돌연변이 성을위한 유스 케이스 : 모의 객체</target>
        </trans-unit>
        <trans-unit id="37a911d0c1b6b4316ddb2ac619c44257424a4bb3" translate="yes" xml:space="preserve">
          <source>A Windows path prefix, e.g., &lt;code&gt;C:&lt;/code&gt; or &lt;code&gt;\server\share&lt;/code&gt;.</source>
          <target state="translated">윈도우 경로 접두어, 예를 들어, &lt;code&gt;C:&lt;/code&gt; 또는 &lt;code&gt;\server\share&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff93a614690d1d51c188c5129e768aec7cd0c763" translate="yes" xml:space="preserve">
          <source>A barrier enables multiple threads to synchronize the beginning of some computation.</source>
          <target state="translated">장벽은 여러 스레드가 일부 계산의 시작을 동기화 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="c1ac9e66093aa4ca440868ee501f91a3a0e906b0" translate="yes" xml:space="preserve">
          <source>A barrier will block &lt;code&gt;n&lt;/code&gt;-1 threads which call &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; and then wake up all threads at once when the &lt;code&gt;n&lt;/code&gt;th thread calls &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">장벽은 &lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 를 호출 한 &lt;code&gt;n&lt;/code&gt; -1 스레드를 차단 한 다음 &lt;code&gt;n&lt;/code&gt; 번째 스레드 호출이 &lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 할 때 모든 스레드를 한 번에 깨 웁니다 .</target>
        </trans-unit>
        <trans-unit id="58cdbd4e4749375a003884d9f4eb272538b31a8e" translate="yes" xml:space="preserve">
          <source>A basic example:</source>
          <target state="translated">기본 예 :</target>
        </trans-unit>
        <trans-unit id="b427e17a0965dfac7d96b4ee22a549d95854674d" translate="yes" xml:space="preserve">
          <source>A basic string declaration of &lt;code&gt;&amp;amp;str&lt;/code&gt; type:</source>
          <target state="translated">&lt;code&gt;&amp;amp;str&lt;/code&gt; 유형 의 기본 문자열 선언 :</target>
        </trans-unit>
        <trans-unit id="5f95a7b46c7703730f6563de2663542b39249317" translate="yes" xml:space="preserve">
          <source>A binary can only have one entry point, and by default that entry point is the function &lt;code&gt;main()&lt;/code&gt;. If there are multiple such functions, please rename one.</source>
          <target state="translated">바이너리는 하나의 진입 점 만 가질 수 있으며 기본적으로 진입 점은 함수 &lt;code&gt;main()&lt;/code&gt; 입니다. 이러한 기능이 여러 개인 경우 이름을 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="b38f665f61e73d6f968e8571206665e15cc36346" translate="yes" xml:space="preserve">
          <source>A binary operation was attempted on a type which doesn't support it. Erroneous code example:</source>
          <target state="translated">지원하지 않는 유형에서 이진 연산을 시도했습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="aa172e5751306c59c090e9db789e410971427e9e" translate="yes" xml:space="preserve">
          <source>A binding shadowed something it shouldn't.</source>
          <target state="translated">바인딩은해서는 안되는 것을 숨겼습니다.</target>
        </trans-unit>
        <trans-unit id="2196fa2a21cb36f1296a2eab8560f7f044fc56a6" translate="yes" xml:space="preserve">
          <source>A block expression as the tail expression of another block expression.</source>
          <target state="translated">다른 블록 표현식의 테일 표현식 인 블록 표현식.</target>
        </trans-unit>
        <trans-unit id="a693c9a42f3c8985b5be041d70547d78d1d2e744" translate="yes" xml:space="preserve">
          <source>A block of code can be prefixed with the &lt;code&gt;unsafe&lt;/code&gt; keyword to permit &lt;a href=&quot;../unsafety&quot;&gt;unsafe operations&lt;/a&gt;. Examples:</source>
          <target state="translated">&lt;a href=&quot;../unsafety&quot;&gt;안전하지 않은 작업&lt;/a&gt; 을 허용하기 위해 &lt;code&gt;unsafe&lt;/code&gt; 키워드를 코드 블록 앞에 붙일 수 있습니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="3f1de3ecbc17ea9a1f67c2ee7ad38362f83951f6" translate="yes" xml:space="preserve">
          <source>A block of code can be prefixed with the &lt;code&gt;unsafe&lt;/code&gt; keyword, to permit calling &lt;code&gt;unsafe&lt;/code&gt; functions or dereferencing raw pointers within a safe function.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; 함수를 호출 하거나 안전 함수 내에서 원시 포인터를 역 참조 할 수 있도록 &lt;code&gt;unsafe&lt;/code&gt; 키워드 를 코드 블록 앞에 붙일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e2aaacb371035dfa3169004d8d112f1e5b1ca71a" translate="yes" xml:space="preserve">
          <source>A blog post starts as an empty draft.</source>
          <target state="translated">블로그 게시물은 빈 초안으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="beb16f573b8715d8a98aa06e002398f8060629f2" translate="yes" xml:space="preserve">
          <source>A boolean type which can be safely shared between threads.</source>
          <target state="translated">스레드간에 안전하게 공유 할 수있는 부울 유형입니다.</target>
        </trans-unit>
        <trans-unit id="3d64914b686b3e740569b7a037982d02419990a4" translate="yes" xml:space="preserve">
          <source>A borrow of a constant containing interior mutability was attempted. Erroneous code example:</source>
          <target state="translated">내부 변이성을 포함하는 상수를 빌리려고 시도했습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="c83fc1310c1c04b54cc7e1f86e92066f4da726ab" translate="yes" xml:space="preserve">
          <source>A borrowed variable was used by a closure. Example of erroneous code:</source>
          <target state="translated">빌린 변수가 빌린 변수를 사용했습니다. 잘못된 코드의 예 :</target>
        </trans-unit>
        <trans-unit id="4584a71b04a4125f9586dd4d0599984c41f8d406" translate="yes" xml:space="preserve">
          <source>A broadcast address has all octets set to 255 as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc919&quot;&gt;IETF RFC 919&lt;/a&gt;.</source>
          <target state="translated">브로드 캐스트 주소는 &lt;a href=&quot;https://tools.ietf.org/html/rfc919&quot;&gt;IETF RFC 919에&lt;/a&gt; 정의 된대로 모든 옥텟이 255로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5ed95e144c4e88ac8aa93a227c762654f2cb478" translate="yes" xml:space="preserve">
          <source>A buffer that's too small:</source>
          <target state="translated">너무 작은 버퍼 :</target>
        </trans-unit>
        <trans-unit id="4b481eff295b8689efc0884b27cfb033e7e5efe6" translate="yes" xml:space="preserve">
          <source>A buffer type used with &lt;code&gt;Read::read_vectored&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Read::read_vectored&lt;/code&gt; 와 함께 사용되는 버퍼 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="bc33ba1a0c8fc7e0d6803cc242c896b07605dc58" translate="yes" xml:space="preserve">
          <source>A buffer type used with &lt;code&gt;Write::write_vectored&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Write::write_vectored&lt;/code&gt; 와 함께 사용되는 버퍼 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="9634bddc5eaddedf795f81dbe84a65e742c0b750" translate="yes" xml:space="preserve">
          <source>A builder for computing where in a HashMap a key-value pair would be stored.</source>
          <target state="translated">HashMap에서 키-값 쌍이 저장되는 위치를 계산하기위한 빌더.</target>
        </trans-unit>
        <trans-unit id="164e9f9ed41b273049862041cd75d7cccf4e70e8" translate="yes" xml:space="preserve">
          <source>A builder used to create directories in various manners.</source>
          <target state="translated">다양한 방법으로 디렉토리를 작성하는 데 사용되는 빌더.</target>
        </trans-unit>
        <trans-unit id="6f6bbc745c6c0811da9c03d5975cfda20a1ec075" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;park&lt;/code&gt; does not guarantee that the thread will remain parked forever, and callers should be prepared for this possibility.</source>
          <target state="translated">를 호출 &lt;code&gt;park&lt;/code&gt; 스레드가 영원히 주차 유지하는 것을 보증하지 않으며, 호출자는이 가능성에 대비해야한다.</target>
        </trans-unit>
        <trans-unit id="87031d3ddac7dc2da2592a12784d3310334c67dd" translate="yes" xml:space="preserve">
          <source>A cast between a thin and a fat pointer was attempted.</source>
          <target state="translated">얇고 뚱뚱한 포인터 사이의 캐스트가 시도되었습니다.</target>
        </trans-unit>
        <trans-unit id="fa8c8681d28baf8dc8f1366a76e05505996e07da" translate="yes" xml:space="preserve">
          <source>A cast to &lt;code&gt;char&lt;/code&gt; was attempted on a type other than &lt;code&gt;u8&lt;/code&gt;.</source>
          <target state="translated">에 대한 캐스트 &lt;code&gt;char&lt;/code&gt; 아닌 다른 유형에 시도되었습니다 &lt;code&gt;u8&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d806d6a4232967c179bddb0726f09f0a0c1cae9" translate="yes" xml:space="preserve">
          <source>A cast to an unsized type was attempted.</source>
          <target state="translated">크기가 조정되지 않은 유형으로 캐스트를 시도했습니다.</target>
        </trans-unit>
        <trans-unit id="7ab45f97583623706555b717305df511d6d6755b" translate="yes" xml:space="preserve">
          <source>A channel in programming has two halves: a transmitter and a receiver. The transmitter half is the upstream location where you put rubber ducks into the river, and the receiver half is where the rubber duck ends up downstream. One part of your code calls methods on the transmitter with the data you want to send, and another part checks the receiving end for arriving messages. A channel is said to be &lt;em&gt;closed&lt;/em&gt; if either the transmitter or receiver half is dropped.</source>
          <target state="translated">프로그래밍 채널에는 송신기와 수신기의 두 부분이 있습니다. 송신기 반은 고무 오리를 강에 넣는 업스트림 위치이고 수신기 반은 고무 오리가 다운 스트림에서 끝나는 곳입니다. 코드의 한 부분은 전송하려는 데이터를 사용하여 송신기에서 메서드를 호출하고 다른 부분은 수신 쪽에서 도착 메시지를 확인합니다. 채널이 &lt;em&gt;폐쇄&lt;/em&gt; 되었다고합니다&lt;em&gt;&lt;/em&gt;송신기 또는 수신기 절반이 떨어지면 있다고합니다.</target>
        </trans-unit>
        <trans-unit id="730c231d230d4d65e9a1cdedca314d8b69b7866c" translate="yes" xml:space="preserve">
          <source>A character type.</source>
          <target state="translated">문자 유형.</target>
        </trans-unit>
        <trans-unit id="195b8c50281f62fd27ad7158cd7ae79ac4f9afca" translate="yes" xml:space="preserve">
          <source>A classification of floating point numbers.</source>
          <target state="translated">부동 소수점 숫자의 분류.</target>
        </trans-unit>
        <trans-unit id="52397aa21f3cbabb1bcadcab29fd5a79bd3be6ee" translate="yes" xml:space="preserve">
          <source>A clone-on-write smart pointer.</source>
          <target state="translated">복제시 쓰기 스마트 포인터.</target>
        </trans-unit>
        <trans-unit id="17d70d4cf5c4adf5f0753809fb9cb729a2f8379d" translate="yes" xml:space="preserve">
          <source>A closure expression denotes a function that maps a list of parameters onto the expression that follows the parameters. Just like a &lt;a href=&quot;../statements#let-statements&quot;&gt;&lt;code&gt;let&lt;/code&gt; binding&lt;/a&gt;, the parameters are irrefutable &lt;a href=&quot;../patterns&quot;&gt;patterns&lt;/a&gt;, whose type annotation is optional and will be inferred from context if not given. Each closure expression has a unique, anonymous type.</source>
          <target state="translated">클로저 식은 매개 변수 목록을 매개 변수 다음에 오는 식에 매핑하는 함수를 나타냅니다. &lt;a href=&quot;../statements#let-statements&quot;&gt; &lt;code&gt;let&lt;/code&gt; 바인딩&lt;/a&gt; 처럼 매개 변수는 반박 할 수없는 &lt;a href=&quot;../patterns&quot;&gt;패턴입니다&lt;/a&gt; 유형이 주석 선택 사항이며 지정하지 않을 경우 문맥에서 추론됩니다. 각 클로저 표현식에는 고유 한 익명 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9e518044a28e364a6d5caf649a49a37d36a9e44" translate="yes" xml:space="preserve">
          <source>A closure is &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; if it does not capture any values by unique immutable or mutable reference, and if all values it captures by copy or move are &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, respectively.</source>
          <target state="translated">고유 한 불변 또는 변경 가능한 참조로 값을 캡처하지 않고 복사 또는 이동으로 캡처하는 모든 값 이 &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 경우 클로저는 &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="f47eb76e99123d39021af1de1b77a6fbf1ed2931" translate="yes" xml:space="preserve">
          <source>A closure is &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; if all variables captured by non-unique immutable reference are &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;, and all values captured by unique immutable or mutable reference, copy, or move are &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">고유하지 않은 불변의 참조로 캡처 된 모든 변수가 &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; 이고 고유 한 불변의 또는 변경 가능한 참조, 복사 또는 이동으로 캡처 된 모든 값 이 &lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; 인&lt;/a&gt; 경우 클로저는 &lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; 입니다.&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0d261d9dcf84a04b55a505f635cb5d6d0068277d" translate="yes" xml:space="preserve">
          <source>A closure is &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; if all captured variables are &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">캡처 된 모든 변수 가 &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; 인&lt;/a&gt; 경우 클로저는 &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f3dcf856d438dee9833c1d37d61c6e01baf7766e" translate="yes" xml:space="preserve">
          <source>A closure or generator was constructed that references its own type.</source>
          <target state="translated">자체 유형을 참조하는 클로저 또는 생성기가 구성되었습니다.</target>
        </trans-unit>
        <trans-unit id="3bcd57420ec9a5b5481261d30eb81ca537f99421" translate="yes" xml:space="preserve">
          <source>A closure was used but didn't implement the expected trait.</source>
          <target state="translated">클로저가 사용되었지만 예상되는 특성을 구현하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="c9d5fcd074a946b081167d5c176a725de44ced3d" translate="yes" xml:space="preserve">
          <source>A closure which does not move out of any captured variables implements &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, indicating that it can be called by mutable reference.</source>
          <target state="translated">캡처 된 변수에서 &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt; 않는 클로저는 FnMut을 구현 하여 변경 가능한 참조로 호출 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cd4b51e9607f8ce4ec972f070cc5a727f780aa02" translate="yes" xml:space="preserve">
          <source>A closure which does not mutate or move out of any captured variables implements &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;, indicating that it can be called by shared reference.</source>
          <target state="translated">캡처 된 변수를 변경하거나 벗어나지 않는 클로저는 &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; 을&lt;/a&gt; 구현 하여 공유 참조에 의해 호출 될 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e935c8f48fd175281f69484ea6d8e34c3df1f772" translate="yes" xml:space="preserve">
          <source>A coercion can only occur at certain coercion sites in a program; these are typically places where the desired type is explicit or can be derived by propagation from explicit types (without type inference). Possible coercion sites are:</source>
          <target state="translated">강요는 프로그램의 특정 강요 사이트에서만 발생할 수 있습니다. 이들은 일반적으로 원하는 유형이 명시 적이거나 명시 적 유형 (유형 유추없이)에서 전파되어 파생 될 수있는 장소입니다. 가능한 강제 사이트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3d399a6fb5b1366dacbcbc3c485166cb44a8fe4f" translate="yes" xml:space="preserve">
          <source>A collection of methods that are required to format a message into a stream.</source>
          <target state="translated">메시지를 스트림으로 형식화하는 데 필요한 메소드 콜렉션.</target>
        </trans-unit>
        <trans-unit id="2a7f703e336c6bdb6cbae32714276165fd6dcc43" translate="yes" xml:space="preserve">
          <source>A common example is the &lt;code&gt;collect&lt;/code&gt; method on &lt;code&gt;Iterator&lt;/code&gt;. It has a generic type parameter with a &lt;code&gt;FromIterator&lt;/code&gt; bound, which for a &lt;code&gt;char&lt;/code&gt; iterator is implemented by &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; among others. Consider the following snippet that reverses the characters of a string:</source>
          <target state="translated">일반적인 예는 &lt;code&gt;Iterator&lt;/code&gt; 의 &lt;code&gt;collect&lt;/code&gt; 메소드입니다 . &lt;code&gt;FromIterator&lt;/code&gt; 바운드 가있는 제네릭 형식 매개 변수가 있으며 , &lt;code&gt;char&lt;/code&gt; 반복기의 경우 &lt;code&gt;Vec&lt;/code&gt; 및 &lt;code&gt;String&lt;/code&gt; 으로 구현됩니다 . 문자열의 문자를 뒤집는 다음 스 니펫을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e2236ceee783d907728a27d889b17b89679caa37" translate="yes" xml:space="preserve">
          <source>A common interface for a class of types.</source>
          <target state="translated">유형 클래스에 대한 공통 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="23bb5a3938b6b7101f14bfe5b204b2401bdf9250" translate="yes" xml:space="preserve">
          <source>A common mis-conception is to think that &quot;unicast link-local addresses start with &lt;code&gt;fe80::&lt;/code&gt;&quot;, but the &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt; actually defines a stricter format for these addresses:</source>
          <target state="translated">일반적인 오해는 &quot;유니 캐스트 링크 로컬 주소는 &lt;code&gt;fe80::&lt;/code&gt; &quot;으로 시작 하지만 &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt; 이라고 생각하는 것입니다. 실제로 다음 주소에 대해보다 엄격한 형식을 정의 .</target>
        </trans-unit>
        <trans-unit id="4615ae2634801f990b77ad209e23e9d53e5c0d34" translate="yes" xml:space="preserve">
          <source>A common problem with using return values to indicate errors is that it is easy to ignore the return value, thus failing to handle the error. &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; is annotated with the &lt;code&gt;#[must_use]&lt;/code&gt; attribute, which will cause the compiler to issue a warning when a Result value is ignored. This makes &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; especially useful with functions that may encounter errors but don't otherwise return a useful value.</source>
          <target state="translated">리턴 값을 사용하여 오류를 표시 할 때 일반적으로 발생하는 문제점은 리턴 값을 무시하기 쉽고 오류를 처리하지 못한다는 것입니다. &lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 에 &lt;code&gt;#[must_use]&lt;/code&gt; 속성 이 주석으로 표시되어 결과 값이 무시 될 때 컴파일러가 경고를 발행합니다. 이 차종은 &lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 오류가 발생할 수 있지만, 그렇지 않으면 유용한 값을 반환하지 않는 기능이 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9e6af95ab7d6f1c50d97f5f2eb1a6e3eebe549bf" translate="yes" xml:space="preserve">
          <source>A common trait for the ability to explicitly duplicate an object.</source>
          <target state="translated">객체를 명시 적으로 복제 할 수있는 능력에 대한 일반적인 특징.</target>
        </trans-unit>
        <trans-unit id="3e2c1919c7a821f5f3bf3a38d0ef8acb4190a932" translate="yes" xml:space="preserve">
          <source>A common use for &lt;code&gt;format!&lt;/code&gt; is concatenation and interpolation of strings. The same convention is used with &lt;a href=&quot;macro.print&quot;&gt;&lt;code&gt;print!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macros, depending on the intended destination of the string.</source>
          <target state="translated">&lt;code&gt;format!&lt;/code&gt; 의 일반적인 사용 ! 문자열의 연결 및 보간입니다. &lt;a href=&quot;macro.print&quot;&gt; &lt;code&gt;print!&lt;/code&gt; &lt;/a&gt; 동일한 규칙이 사용됩니다 ! 그리고 &lt;a href=&quot;macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt;문자열의 대상에 따라 매크로</target>
        </trans-unit>
        <trans-unit id="44fea0684e72cef1ddaf4be0010340215dffbec7" translate="yes" xml:space="preserve">
          <source>A common use of this feature is to poison shared resources when writing unsafe code, by checking &lt;code&gt;panicking&lt;/code&gt; when the &lt;code&gt;drop&lt;/code&gt; is called.</source>
          <target state="translated">이 기능은 일반적으로 &lt;code&gt;drop&lt;/code&gt; 이 호출 될 때 &lt;code&gt;panicking&lt;/code&gt; 을 확인하여 안전하지 않은 코드를 작성할 때 공유 리소스를 독살하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="3016e8bc4b1ae0cb5dbf3daaacd9d48f6d65eed5" translate="yes" xml:space="preserve">
          <source>A common way to test functionality is to compare the result of the code under test to the value you expect the code to return to make sure they&amp;rsquo;re equal. You could do this using the &lt;code&gt;assert!&lt;/code&gt; macro and passing it an expression using the &lt;code&gt;==&lt;/code&gt; operator. However, this is such a common test that the standard library provides a pair of macros&amp;mdash;&lt;code&gt;assert_eq!&lt;/code&gt; and &lt;code&gt;assert_ne!&lt;/code&gt;&amp;mdash;to perform this test more conveniently. These macros compare two arguments for equality or inequality, respectively. They&amp;rsquo;ll also print the two values if the assertion fails, which makes it easier to see &lt;em&gt;why&lt;/em&gt; the test failed; conversely, the &lt;code&gt;assert!&lt;/code&gt; macro only indicates that it got a &lt;code&gt;false&lt;/code&gt; value for the &lt;code&gt;==&lt;/code&gt; expression, not the values that lead to the &lt;code&gt;false&lt;/code&gt; value.</source>
          <target state="translated">기능을 테스트하는 일반적인 방법은 테스트중인 코드의 결과를 코드가 동일한 지 확인하기 위해 반환 할 것으로 예상되는 값과 비교하는 것입니다. 당신은 &lt;code&gt;assert!&lt;/code&gt; 사용하여 이것을 할 수 있습니다 ! &lt;code&gt;==&lt;/code&gt; 연산자를 사용하여 표현식을 전달하십시오 . 그러나 이것은 표준 라이브러리가 매크로 쌍인 &lt;code&gt;assert_eq!&lt;/code&gt; 제공하는 일반적인 테스트입니다 . 그리고 &lt;code&gt;assert_ne!&lt;/code&gt; &amp;mdash;이 테스트를보다 편리하게 수행합니다. 이 매크로는 두 가지 인수가 동일한 지 또는 불평등인지를 각각 비교합니다. 또한 어설 션이 실패하면 두 값을 인쇄 하여 테스트가 실패한 &lt;em&gt;이유를&lt;/em&gt; 더 쉽게 확인할 수 있습니다 . 반대로, &lt;code&gt;assert!&lt;/code&gt; 매크로는 &lt;code&gt;false&lt;/code&gt; 나타냅니다. &lt;code&gt;==&lt;/code&gt; 의 값 &lt;code&gt;false&lt;/code&gt; 이끄는 값이 아닌 표현 값.</target>
        </trans-unit>
        <trans-unit id="6f72785cb8deaf70098be764432ad287d8764020" translate="yes" xml:space="preserve">
          <source>A common way to use &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; is in combination with &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;. Recall that &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; lets you have multiple owners of some data, but it only gives immutable access to that data. If you have an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; that holds a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, you can get a value that can have multiple owners &lt;em&gt;and&lt;/em&gt; that you can mutate!</source>
          <target state="translated">&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 을 사용하는 일반적인 방법 은 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 와 함께 사용하는 것 입니다. 리콜 그 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 일부 데이터의 여러 소유자를 할 수 있지만, 해당 데이터에 대한 불변의 액세스를 제공합니다. 당신이있는 경우 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 보유 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 여러 소유자를 가질 수있는 값 얻을 수 있습니다 &lt;em&gt;그리고&lt;/em&gt; 당신은 돌연변이 수를!</target>
        </trans-unit>
        <trans-unit id="1b20c9de094581b8f84861af4164c5552e60a2ee" translate="yes" xml:space="preserve">
          <source>A compile time error is never emitted when using this macro regardless of whether the environment variable is present or not.</source>
          <target state="translated">환경 변수의 존재 여부에 관계없이이 매크로를 사용할 때 컴파일 시간 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="378954a8b28d0b17cfcc628e2457199a86abdd79" translate="yes" xml:space="preserve">
          <source>A compiler memory fence.</source>
          <target state="translated">컴파일러 메모리 펜스</target>
        </trans-unit>
        <trans-unit id="592fedd9ba4ca1ae2681effb1b9b42a165b45c38" translate="yes" xml:space="preserve">
          <source>A compiler-only memory barrier.</source>
          <target state="translated">컴파일러 전용 메모리 장벽.</target>
        </trans-unit>
        <trans-unit id="5af9d265d7cc350d6c8dd5eca2e52c0984df494d" translate="yes" xml:space="preserve">
          <source>A configuration option. It is true if the option is set and false if it is unset.</source>
          <target state="translated">구성 옵션. 옵션이 설정되어 있으면 true이고 설정되어 있지 않으면 false입니다.</target>
        </trans-unit>
        <trans-unit id="3457f182555f50a2c7cffa76112cf04e013ed4c3" translate="yes" xml:space="preserve">
          <source>A consequence of the borrowing rules is that when you have an immutable value, you can&amp;rsquo;t borrow it mutably. For example, this code won&amp;rsquo;t compile:</source>
          <target state="translated">차용 규칙의 결과는 불변의 가치가있을 때 변경할 수 없다는 것입니다. 예를 들어이 코드는 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2574c153f328b1e202d9e64649cb65b6702dbcde" translate="yes" xml:space="preserve">
          <source>A contiguous growable array type with heap-allocated contents, written &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">힙 할당 내용이 있고 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 작성된 연속 확장 가능 배열 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="ceaa636b8440544799d1a505ee00079d04849fb0" translate="yes" xml:space="preserve">
          <source>A contiguous growable array type, written &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; but pronounced 'vector'.</source>
          <target state="translated">연속 가능한 확장 가능 배열 유형으로 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 작성 되었지만 'vector'로 발음됩니다.</target>
        </trans-unit>
        <trans-unit id="0490b6e232133e0013be8f4fef9d50c9926445a5" translate="yes" xml:space="preserve">
          <source>A convenience function that bubbles an &lt;code&gt;io::Result&lt;/code&gt; to its caller:</source>
          <target state="translated">&lt;code&gt;io::Result&lt;/code&gt; 를 호출자에게 버블 링하는 편리한 함수 :</target>
        </trans-unit>
        <trans-unit id="16d79d851ab24be5a7dea27948897afa80e31902" translate="yes" xml:space="preserve">
          <source>A convenience impl that delegates to the impl for &lt;code&gt;&amp;amp;str&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;amp;str&lt;/code&gt; 대한 impl을 위임하는 편리한 impl</target>
        </trans-unit>
        <trans-unit id="0847e6a8b80cb99079b74075a954fd750b19a38b" translate="yes" xml:space="preserve">
          <source>A crate is somewhat analogous to an &lt;em&gt;assembly&lt;/em&gt; in the ECMA-335 CLI model, a &lt;em&gt;library&lt;/em&gt; in the SML/NJ Compilation Manager, a &lt;em&gt;unit&lt;/em&gt; in the Owens and Flatt module system, or a &lt;em&gt;configuration&lt;/em&gt; in Mesa.</source>
          <target state="translated">상자는 ECMA-335 CLI 모델 의 &lt;em&gt;어셈블리&lt;/em&gt; , SML / NJ Compilation Manager 의 &lt;em&gt;라이브러리&lt;/em&gt; , Owens and Flatt 모듈 시스템 의 &lt;em&gt;단위&lt;/em&gt; 또는 Mesa 의 &lt;em&gt;구성&lt;/em&gt; 과 다소 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="6436f7757ac841fe0b93278e071a64e419b3a404" translate="yes" xml:space="preserve">
          <source>A crate needs a global available &quot;helper module&quot; to itself, but it doesn't want to expose the helper module as a public API. To accomplish this, the root of the crate's hierarchy would have a private module which then internally has a &quot;public API&quot;. Because the entire crate is a descendant of the root, then the entire local crate can access this private module through the second case.</source>
          <target state="translated">상자에는 자체적으로 사용할 수있는 전역 &quot;도우미 모듈&quot;이 필요하지만, 도우미 모듈을 공개 API로 노출하고 싶지는 않습니다. 이를 달성하기 위해 크레이트 계층의 루트는 내부적으로 &quot;공용 API&quot;를 갖는 개인 모듈을 갖게됩니다. 전체 상자는 루트의 자손이므로 전체 로컬 상자는 두 번째 경우를 통해이 개인 모듈에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc65255cb2d6b61579af61c12db502f3b72ad815" translate="yes" xml:space="preserve">
          <source>A crate that contains a &lt;code&gt;main&lt;/code&gt;&lt;a href=&quot;items/functions&quot;&gt;function&lt;/a&gt; can be compiled to an executable. If a &lt;code&gt;main&lt;/code&gt; function is present, it must take no arguments, must not declare any &lt;a href=&quot;trait-bounds&quot;&gt;trait or lifetime bounds&lt;/a&gt;, must not have any &lt;a href=&quot;items/generics#where-clauses&quot;&gt;where clauses&lt;/a&gt;, and its return type must be one of the following:</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; &lt;a href=&quot;items/functions&quot;&gt;기능&lt;/a&gt; 이 포함 된 상자 는 실행 파일로 컴파일 할 수 있습니다. &lt;code&gt;main&lt;/code&gt; 함수가 존재 한다면, 인수를 취하지 않아야하며, &lt;a href=&quot;trait-bounds&quot;&gt;특성이나 수명 한계를&lt;/a&gt; 선언 해서는 안되며 &lt;a href=&quot;items/generics#where-clauses&quot;&gt;where 절이&lt;/a&gt; 없어야 합니다. , 리턴 유형은 다음 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="1dd52734851cf6f3cf436dc5839dcfddfdcaf815" translate="yes" xml:space="preserve">
          <source>A crate will group related functionality together in a scope so the functionality is easy to share between multiple projects. For example, the &lt;code&gt;rand&lt;/code&gt; crate we used in &lt;a href=&quot;ch02-00-guessing-game-tutorial#generating-a-random-number&quot;&gt;Chapter 2&lt;/a&gt; provides functionality that generates random numbers. We can use that functionality in our own projects by bringing the &lt;code&gt;rand&lt;/code&gt; crate into our project&amp;rsquo;s scope. All the functionality provided by the &lt;code&gt;rand&lt;/code&gt; crate is accessible through the crate&amp;rsquo;s name, &lt;code&gt;rand&lt;/code&gt;.</source>
          <target state="translated">크레이트는 관련 기능을 범위 내에서 그룹화하여 여러 프로젝트간에 기능을 쉽게 공유 할 수 있습니다. 예를 들어, &lt;a href=&quot;ch02-00-guessing-game-tutorial#generating-a-random-number&quot;&gt;2 장&lt;/a&gt; 에서 사용한 &lt;code&gt;rand&lt;/code&gt; 상자는 난수를 생성하는 기능을 제공합니다. &lt;code&gt;rand&lt;/code&gt; 크레이트를 프로젝트 범위로 가져 와서 자체 프로젝트에서 해당 기능을 사용할 수 있습니다 . &lt;code&gt;rand&lt;/code&gt; 상자에서 제공하는 모든 기능 은 상자의 이름 인 &lt;code&gt;rand&lt;/code&gt; 를 통해 액세스 할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="00851a5c172b45fa5d81433f76656b498876dd4d" translate="yes" xml:space="preserve">
          <source>A cross-crate opt-out trait was implemented on something which wasn't a struct or enum type. Erroneous code example:</source>
          <target state="translated">교차 상자 옵트 아웃 특성은 구조체 또는 열거 형이 아닌 것으로 구현되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="36316fe5916fd156e2a88a749ac433147a8da4cc" translate="yes" xml:space="preserve">
          <source>A cycle between &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers will never be deallocated. For this reason, &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; is used to break cycles. For example, a tree could have strong &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointers from parent nodes to children, and &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 포인터 사이의 사이클은 할당 해제되지 않습니다. 이러한 이유로 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 을 사용하여 사이클을 중단합니다. 예를 들어, 나무는 부모 노드에서 자식으로 강력한 &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 포인터를, 자식에서 부모로 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 포인터를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b90e3c2a1d2a35888ed9e0be0c1ef31680e920a" translate="yes" xml:space="preserve">
          <source>A cycle between &lt;code&gt;Arc&lt;/code&gt; pointers will never be deallocated. For this reason, &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; is used to break cycles. For example, a tree could have strong &lt;code&gt;Arc&lt;/code&gt; pointers from parent nodes to children, and &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers from children back to their parents.</source>
          <target state="translated">&lt;code&gt;Arc&lt;/code&gt; 포인터 사이의 사이클은 할당 해제되지 않습니다. 이러한 이유로 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 을 사용하여 사이클을 중단합니다. 예를 들어, 나무는 부모 노드에서 자식으로 강한 &lt;code&gt;Arc&lt;/code&gt; 포인터를, 자식에서 부모로 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 포인터를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cd0e6a515d806f28a3a9117a215e0567225d9f11" translate="yes" xml:space="preserve">
          <source>A data structure is in a temporarily invalid state when the thread panics.</source>
          <target state="translated">스레드 패닉시 데이터 구조가 일시적으로 유효하지 않은 상태입니다.</target>
        </trans-unit>
        <trans-unit id="590870896f27fcf4f2a0264dabbc0794e9042402" translate="yes" xml:space="preserve">
          <source>A default configuration can be generated using &lt;code&gt;Command::new(program)&lt;/code&gt;, where &lt;code&gt;program&lt;/code&gt; gives a path to the program to be executed. Additional builder methods allow the configuration to be changed (for example, by adding arguments) prior to spawning:</source>
          <target state="translated">기본 구성은 &lt;code&gt;Command::new(program)&lt;/code&gt; 사용하여 생성 할 수 있습니다 . 여기서 &lt;code&gt;program&lt;/code&gt; 은 실행할 프로그램의 경로를 제공합니다. 추가 빌더 메소드를 사용하면 생성 전에 구성을 변경할 수 있습니다 (예 : 인수 추가).</target>
        </trans-unit>
        <trans-unit id="cc1e47ebf18eca6629966fd3d1126236437b08eb" translate="yes" xml:space="preserve">
          <source>A definition of a method not in the implemented trait was given in a trait implementation.</source>
          <target state="translated">구현 된 특성에없는 방법의 정의는 특성 구현에서 제공되었습니다.</target>
        </trans-unit>
        <trans-unit id="74bdee4c01f0e2a5b888cedf761fad306ec9d91d" translate="yes" xml:space="preserve">
          <source>A discriminant in an &lt;code&gt;enum&lt;/code&gt; not included in the type definition.</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 의 판별 자는 유형 정의에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="449c61354d124e018f4ac7cc6a32776bf259e4bc" translate="yes" xml:space="preserve">
          <source>A documentation comment that doesn't document anything was found.</source>
          <target state="translated">아무것도 문서화하지 않은 문서 주석이 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="844fc94f2ec6c20bbd8c3c61aa63bf0f8f4c60a0" translate="yes" xml:space="preserve">
          <source>A double-ended iterator with the direction inverted.</source>
          <target state="translated">방향이 반전 된 이중 종단 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="9e374237ea1be12ca52873f6b8cd4c6757ef72d7" translate="yes" xml:space="preserve">
          <source>A double-ended queue implemented with a growable ring buffer.</source>
          <target state="translated">확장 가능한 링 버퍼로 구현 된 이중 엔드 큐입니다.</target>
        </trans-unit>
        <trans-unit id="28050b20d2fb7eccf5c8a8ecb22f1b2923430db5" translate="yes" xml:space="preserve">
          <source>A doubly-linked list with owned nodes.</source>
          <target state="translated">소유 한 노드가있는 이중 연결 목록입니다.</target>
        </trans-unit>
        <trans-unit id="7fb38950784a1933e77430becd7b735f7149cba0" translate="yes" xml:space="preserve">
          <source>A draining iterator for &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 의 배수 반복기 .</target>
        </trans-unit>
        <trans-unit id="4c37906477f09b5f321b2effe6bce9b886812638" translate="yes" xml:space="preserve">
          <source>A draining iterator for &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 의 배수 반복기 .</target>
        </trans-unit>
        <trans-unit id="429ad4a5f6fa96f2bca9279ba7532d1e6d671a36" translate="yes" xml:space="preserve">
          <source>A draining iterator over the elements of a &lt;code&gt;BinaryHeap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BinaryHeap&lt;/code&gt; 요소의 배수 반복기 .</target>
        </trans-unit>
        <trans-unit id="91b15bef979787193522a6fe820b65bca6b71b6d" translate="yes" xml:space="preserve">
          <source>A draining iterator over the elements of a &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;VecDeque&lt;/code&gt; 요소의 배수 반복기 .</target>
        </trans-unit>
        <trans-unit id="6e8fa0dd341d84cbc1afdb686f6037ff7ef3d24c" translate="yes" xml:space="preserve">
          <source>A draining iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 의 항목에 대한 배수 반복기 .</target>
        </trans-unit>
        <trans-unit id="3f3d65aa6b0bc2c1da1319190787588eadcf2d84" translate="yes" xml:space="preserve">
          <source>A draining iterator over the items of a &lt;code&gt;HashSet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; 항목의 배수 반복기 입니다.</target>
        </trans-unit>
        <trans-unit id="cc90bdb96c97b6e432d2ff036bf4b852213faf58" translate="yes" xml:space="preserve">
          <source>A dynamically sized type (DST) is a type without a statically known size or alignment.</source>
          <target state="translated">DST (Dynamic Sized Type)는 정적으로 알려진 크기 나 정렬이없는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="211aeaeaf569d6a37ba4f9e761ab58dda09c15a6" translate="yes" xml:space="preserve">
          <source>A dynamically-sized view into a contiguous sequence, &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="translated">연속적인 순서로 동적으로 크기보기 &lt;code&gt;[T]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31f05f23c58b03a01fb9e427108a188fcf6b07f3" translate="yes" xml:space="preserve">
          <source>A feature attribute named a feature that has been removed.</source>
          <target state="translated">제거 된 기능이라는 기능 속성입니다.</target>
        </trans-unit>
        <trans-unit id="dd28c7fe46ecde36f6e0a91f768af6503a5d1816" translate="yes" xml:space="preserve">
          <source>A feature attribute named a feature that was disallowed in the compiler command line flags.</source>
          <target state="translated">컴파일러 명령 행 플래그에서 허용되지 않은 기능이라는 기능 속성입니다.</target>
        </trans-unit>
        <trans-unit id="80c1f2d8465e2f0474908b699c574231c3f93ea8" translate="yes" xml:space="preserve">
          <source>A fence 'A' which has (at least) &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; ordering semantics, synchronizes with a fence 'B' with (at least) &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; semantics, if and only if there exist operations X and Y, both operating on some atomic object 'M' such that A is sequenced before X, Y is synchronized before B and Y observes the change to M. This provides a happens-before dependence between A and B.</source>
          <target state="translated">최소 &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; 시맨틱을 갖는 펜스 'A'는 적어도 원자 적 객체 'M'에서 작동하는 X 및 Y 오퍼레이션이 존재하는 경우에만 시맨틱을 &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; 최소 '시맨틱'을 갖는 펜스 'B'와 동기화됩니다. A는 X보다 먼저 시퀀싱되고, Y는 B보다 먼저 동기화되고 Y는 M에 대한 변화를 관찰합니다. 이는 A와 B 사이의 사전 의존성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="55e68042fec783cba9aad8dce1b35e99ef85dbdf" translate="yes" xml:space="preserve">
          <source>A fence which has &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt; ordering, in addition to having both &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; semantics, participates in the global program order of the other &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt; operations and/or fences.</source>
          <target state="translated">보유 울타리 &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;SeqCst&lt;/code&gt; 를&lt;/a&gt; 모두 갖는 외에, 순서를 &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; 다른 프로그램의 글로벌 순서 시멘틱스가 참여를 &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;SeqCst&lt;/code&gt; 의&lt;/a&gt; 동작 및 / 또는 울타리.</target>
        </trans-unit>
        <trans-unit id="1cb36d0ee361d78dbe2fa3dcfcac72e9a2dee2b5" translate="yes" xml:space="preserve">
          <source>A field access is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt; referring to the location of that field. When the subexpression is &lt;a href=&quot;../expressions#mutability&quot;&gt;mutable&lt;/a&gt;, the field expression is also mutable.</source>
          <target state="translated">필드 액세스는 해당 필드의 위치를 ​​나타내는 &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;장소 표현&lt;/a&gt; 입니다. 하위 표현식이 &lt;a href=&quot;../expressions#mutability&quot;&gt;변경 가능&lt;/a&gt; 하면 필드 표현식도 변경 가능합니다.</target>
        </trans-unit>
        <trans-unit id="f7e446184b876f98fd13cf13bfdf4f57607ba15b" translate="yes" xml:space="preserve">
          <source>A file wasn't found for an out-of-line module.</source>
          <target state="translated">라인 외부 모듈에 대한 파일을 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="730142c15726a49fe7ebbd5c1ceae068d1e76798" translate="yes" xml:space="preserve">
          <source>A final reason Rust doesn&amp;rsquo;t allow us to index into a &lt;code&gt;String&lt;/code&gt; to get a character is that indexing operations are expected to always take constant time (O(1)). But it isn&amp;rsquo;t possible to guarantee that performance with a &lt;code&gt;String&lt;/code&gt;, because Rust would have to walk through the contents from the beginning to the index to determine how many valid characters there were.</source>
          <target state="translated">Rust가 문자를 얻기 위해 &lt;code&gt;String&lt;/code&gt; 로 색인을 생성 할 수없는 마지막 이유 는 색인 작업이 항상 일정한 시간 (O (1))이 걸리기 때문입니다. 그러나 Rust는 유효한 문자 수를 결정하기 위해 처음부터 색인까지 내용을 탐색해야하기 때문에 &lt;code&gt;String&lt;/code&gt; 성능을 보장 할 수는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0106151a82df636bbbb97134363a6aef4336540d" translate="yes" xml:space="preserve">
          <source>A finite heterogeneous sequence, &lt;code&gt;(T, U, ..)&lt;/code&gt;.</source>
          <target state="translated">유한 이종 시퀀스 &lt;code&gt;(T, U, ..)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="405c2e4c1352a9dd275d0dcf43af6465cfa06fc2" translate="yes" xml:space="preserve">
          <source>A fixed-size array, denoted &lt;code&gt;[T; N]&lt;/code&gt;, for the element type, &lt;code&gt;T&lt;/code&gt;, and the non-negative compile-time constant size, &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">표시 고정 크기 어레이, &lt;code&gt;[T; N]&lt;/code&gt; , 요소 유형에 대한 &lt;code&gt;T&lt;/code&gt; 및 음이 아닌 컴파일 시간 상수 크기 &lt;code&gt;N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01e8ae155635ffa00df108a976552eb0550b9e9b" translate="yes" xml:space="preserve">
          <source>A for loop is equivalent to the following block expression.</source>
          <target state="translated">for 루프는 다음 블록 표현식과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b694a59d19302341ecbd00f4fa0cb3b358a2f81b" translate="yes" xml:space="preserve">
          <source>A format string is required to use all of its arguments, otherwise it is a compile-time error. You may refer to the same argument more than once in the format string.</source>
          <target state="translated">모든 인수를 사용하려면 형식 문자열이 필요합니다. 그렇지 않으면 컴파일 타임 오류입니다. 형식 문자열에서 동일한 인수를 두 번 이상 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01b7129399ded6b05b30578334c78e0c28495f39" translate="yes" xml:space="preserve">
          <source>A function annotated with the &lt;code&gt;test&lt;/code&gt; attribute can also be annotated with the &lt;code&gt;ignore&lt;/code&gt; attribute. The &lt;em&gt;&lt;code&gt;ignore&lt;/code&gt; attribute&lt;/em&gt; tells the test harness to not execute that function as a test. It will still be compiled when in test mode.</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; 속성으로 주석이 달린 함수 는 &lt;code&gt;ignore&lt;/code&gt; 속성 으로 주석을 달 수도 있습니다 . 는 &lt;em&gt; &lt;code&gt;ignore&lt;/code&gt; 속성&lt;/em&gt; 테스트로서 그 기능을 실행하지 않는 테스트 장치를 말한다. 테스트 모드에있을 때는 여전히 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="05308286e6d20f1bc15a1d74d19f5246b35ba29f" translate="yes" xml:space="preserve">
          <source>A function annotated with the &lt;code&gt;test&lt;/code&gt; attribute that returns &lt;code&gt;()&lt;/code&gt; can also be annotated with the &lt;code&gt;should_panic&lt;/code&gt; attribute. The &lt;em&gt;&lt;code&gt;should_panic&lt;/code&gt; attribute&lt;/em&gt; makes the test only pass if it actually panics.</source>
          <target state="translated">&lt;code&gt;()&lt;/code&gt; 를 반환 하는 &lt;code&gt;test&lt;/code&gt; 속성으로 주석이 달린 함수 는 &lt;code&gt;should_panic&lt;/code&gt; 속성 으로 주석을 달 수 있습니다 . &lt;em&gt; &lt;code&gt;should_panic&lt;/code&gt; &lt;/em&gt;&lt;em&gt; 속성은&lt;/em&gt; 테스트 만하면 실제로 패닉을 통과한다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d9fe742a8fa7d8036e041c35d1e5b1052fe5c884" translate="yes" xml:space="preserve">
          <source>A function call isn't allowed in the const's initialization expression because the expression's value must be known at compile-time. Erroneous code example:</source>
          <target state="translated">표현식의 값을 컴파일 타임에 알아야하기 때문에 const의 초기화 표현식에서는 함수 호출이 허용되지 않습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="cdbab3b7a45160aa6bbfe85128d0bf7bac272328" translate="yes" xml:space="preserve">
          <source>A function declared in an extern block is implicitly &lt;code&gt;unsafe&lt;/code&gt;. When coerced to a function pointer, a function declared in an extern block has type &lt;code&gt;unsafe extern &quot;abi&quot; for&amp;lt;'l1, ..., 'lm&amp;gt; fn(A1, ..., An) -&amp;gt; R&lt;/code&gt;, where &lt;code&gt;'l1&lt;/code&gt;, ... &lt;code&gt;'lm&lt;/code&gt; are its lifetime parameters, &lt;code&gt;A1&lt;/code&gt;, ..., &lt;code&gt;An&lt;/code&gt; are the declared types of its parameters and &lt;code&gt;R&lt;/code&gt; is the declared return type.</source>
          <target state="translated">extern 블록에 선언 된 함수는 암시 적으로 &lt;code&gt;unsafe&lt;/code&gt; . 함수 포인터로 강제 변환되면, extern 블록에 선언 된 함수는 &lt;code&gt;unsafe extern &quot;abi&quot; for&amp;lt;'l1, ..., 'lm&amp;gt; fn(A1, ..., An) -&amp;gt; R&lt;/code&gt; 유형을 갖습니다 . 여기서 &lt;code&gt;'l1&lt;/code&gt; , ... &lt;code&gt;'lm&lt;/code&gt; 은 수명 매개 변수, &lt;code&gt;A1&lt;/code&gt; , ..., &lt;code&gt;An&lt;/code&gt; 은 매개 변수의 선언 된 유형이고 &lt;code&gt;R&lt;/code&gt; 은 선언 된 리턴 유형입니다.</target>
        </trans-unit>
        <trans-unit id="0055fb8a733d1b0d5afb4ae44802bb8e5a0c86da" translate="yes" xml:space="preserve">
          <source>A function or function pointer.</source>
          <target state="translated">함수 또는 함수 포인터.</target>
        </trans-unit>
        <trans-unit id="b5bfe20067693f41e9be24910b3f1d1c865c4b39" translate="yes" xml:space="preserve">
          <source>A function signature must declare the number and type of parameters the function has. Macros, on the other hand, can take a variable number of parameters: we can call &lt;code&gt;println!(&quot;hello&quot;)&lt;/code&gt; with one argument or &lt;code&gt;println!(&quot;hello {}&quot;, name)&lt;/code&gt; with two arguments. Also, macros are expanded before the compiler interprets the meaning of the code, so a macro can, for example, implement a trait on a given type. A function can&amp;rsquo;t, because it gets called at runtime and a trait needs to be implemented at compile time.</source>
          <target state="translated">함수 시그니처는 함수가 가진 매개 변수의 수와 유형을 선언해야합니다. 반면에 매크로는 가변 개수의 매개 변수를 사용할 수 있습니다 &lt;code&gt;println!(&quot;hello&quot;)&lt;/code&gt; 하나의 인수로 println! ( &quot;hello&quot;) 또는 두 개의 인수로 &lt;code&gt;println!(&quot;hello {}&quot;, name)&lt;/code&gt; 을 호출 할 수 있습니다. 또한 매크로는 컴파일러가 코드의 의미를 해석하기 전에 확장되므로 매크로는 예를 들어 지정된 유형에 특성을 구현할 수 있습니다. 함수는 런타임에 호출되고 특성은 컴파일 타임에 구현되어야하기 때문에 함수를 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cfea53bdada8b3687c10319a4dd10194cef976b7" translate="yes" xml:space="preserve">
          <source>A function that has a parameter or returns only numbers between 1 and 100 could then declare in its signature that it takes or returns a &lt;code&gt;Guess&lt;/code&gt; rather than an &lt;code&gt;i32&lt;/code&gt; and wouldn&amp;rsquo;t need to do any additional checks in its body.</source>
          <target state="translated">매개 변수가 있거나 1에서 100 사이의 숫자 만 반환하는 함수는 서명 에서 &lt;code&gt;i32&lt;/code&gt; 가 아닌 &lt;code&gt;Guess&lt;/code&gt; 를 가져 오거나 반환한다고 선언 할 수 있으며 본문에서 추가 검사를 수행 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="330c21e7bd84509b137caeeff4bed7a7da24e5b7" translate="yes" xml:space="preserve">
          <source>A function that is opaque to the optimizer, to allow benchmarks to pretend to use outputs to assist in avoiding dead-code elimination.</source>
          <target state="translated">옵티 마이저에 대해 불투명 한 기능으로, 벤치 마크에서 출력을 사용하는 척하여 데드 코드 제거를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2ed9af48e681bbf5a9216d3deb00de57795222b" translate="yes" xml:space="preserve">
          <source>A function with the &lt;code&gt;start&lt;/code&gt; attribute was declared with type parameters.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 속성을 가진 함수가 유형 매개 변수로 선언되었습니다.</target>
        </trans-unit>
        <trans-unit id="b104136e74bd26ea4949e609270e7bafb60abae9" translate="yes" xml:space="preserve">
          <source>A future is a value that may not have finished computing yet. This kind of &quot;asynchronous value&quot; makes it possible for a thread to continue doing useful work while it waits for the value to become available.</source>
          <target state="translated">미래는 아직 컴퓨팅을 마치지 못한 가치입니다. 이런 종류의 &quot;비동기 값&quot;은 값을 사용할 수있을 때까지 스레드가 유용한 작업을 계속 수행 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="7c377e6c372ce66665ebea21944588366ee85648" translate="yes" xml:space="preserve">
          <source>A future represents an asynchronous computation.</source>
          <target state="translated">미래는 비동기 계산을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c1da397a075afa74abc70c7bb33c6bfaa50fd933" translate="yes" xml:space="preserve">
          <source>A generalization of &lt;code&gt;Clone&lt;/code&gt; to borrowed data.</source>
          <target state="translated">빌린 데이터에 대한 &lt;code&gt;Clone&lt;/code&gt; 의 일반화 .</target>
        </trans-unit>
        <trans-unit id="851d3775359dee45f6fc12b7c593dac300677e98" translate="yes" xml:space="preserve">
          <source>A generic function must be treated similarly:</source>
          <target state="translated">일반 함수는 다음과 유사하게 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="b9e2cdc9d185c52c49734ce26b1038e50519630f" translate="yes" xml:space="preserve">
          <source>A generic type was described using parentheses rather than angle brackets. For example:</source>
          <target state="translated">괄호 대신 괄호를 사용하여 일반 유형을 설명했습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d667559155454841982582189ab274f14a49b2bf" translate="yes" xml:space="preserve">
          <source>A generic type where one or more associated types have specific assignments (e.g., &lt;code&gt;Iterator&amp;lt;Item=T&amp;gt;&lt;/code&gt;)</source>
          <target state="translated">하나 이상의 연관된 유형에 특정 지정이있는 일반 유형 (예 : &lt;code&gt;Iterator&amp;lt;Item=T&amp;gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6f0496f55807a095b66d7d51e944864622ad78d2" translate="yes" xml:space="preserve">
          <source>A ghastly note 👻👻👻</source>
          <target state="translated">대단한 메모 👻👻👻</target>
        </trans-unit>
        <trans-unit id="91fcac820244ae988bc857941377bad5a84fac8d" translate="yes" xml:space="preserve">
          <source>A given matcher M maps to three sets: FIRST(M), LAST(M) and FOLLOW(M).</source>
          <target state="translated">주어진 매처 M은 FIRST (M), LAST (M) 및 FOLLOW (M)의 세 세트에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="ce503e49f8d95cbc61a21e14a3b1dd613e9d99ae" translate="yes" xml:space="preserve">
          <source>A great example of a situation where this technique is useful is with operator overloading. &lt;em&gt;Operator overloading&lt;/em&gt; is customizing the behavior of an operator (such as &lt;code&gt;+&lt;/code&gt;) in particular situations.</source>
          <target state="translated">이 기술이 유용한 상황의 좋은 예는 운영자 과부하입니다. &lt;em&gt;연산자 과부하&lt;/em&gt; 는 특정 상황에서 연산자의 동작 (예 : &lt;code&gt;+&lt;/code&gt; )을 사용자 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="e24815403ad3a79092fe51890734de71f5057ede" translate="yes" xml:space="preserve">
          <source>A guard for unsafe functions that cannot ever be executed if &lt;code&gt;T&lt;/code&gt; is uninhabited: This will statically either panic, or do nothing.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 무인 상태 일 때 실행할 수없는 안전하지 않은 기능에 대한 보호 : 정적으로 패닉 상태이거나 아무 것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a319cd7f43cac10207753e127b6908e7ad723f6" translate="yes" xml:space="preserve">
          <source>A handle to a child process's standard input (stdin).</source>
          <target state="translated">자식 프로세스의 표준 입력 (stdin)에 대한 핸들.</target>
        </trans-unit>
        <trans-unit id="1c0c017d7e2d5d79869d31d54d7aed18a0e39b40" translate="yes" xml:space="preserve">
          <source>A handle to a child process's standard output (stdout).</source>
          <target state="translated">자식 프로세스의 표준 출력 (stdout)에 대한 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="36463654df6f05a2c5f7eb7e4b2efec9b5402d6f" translate="yes" xml:space="preserve">
          <source>A handle to a child process's stderr.</source>
          <target state="translated">자식 프로세스의 stderr에 대한 핸들.</target>
        </trans-unit>
        <trans-unit id="539b8b33fb86eae0a19eb8338bbb41567108f8bd" translate="yes" xml:space="preserve">
          <source>A handle to a thread.</source>
          <target state="translated">스레드 핸들.</target>
        </trans-unit>
        <trans-unit id="e4354965858e59daba47e025f6bf432587785439" translate="yes" xml:space="preserve">
          <source>A handle to the global standard output stream of the current process.</source>
          <target state="translated">현재 프로세스의 글로벌 표준 출력 스트림에 대한 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="4e5458b43a1ef2ac995209fb2fb9a0f1f086d8ff" translate="yes" xml:space="preserve">
          <source>A handle to the standard error stream of a process.</source>
          <target state="translated">프로세스의 표준 오류 스트림에 대한 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="c04e6d93f5332bb8558883edf3c0666a1ead6820" translate="yes" xml:space="preserve">
          <source>A handle to the standard input stream of a process.</source>
          <target state="translated">프로세스의 표준 입력 스트림에 대한 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="52f29960ee00cd31852f436ce3c064a63d21c4a9" translate="yes" xml:space="preserve">
          <source>A hash map implemented with linear probing and Robin Hood bucket stealing.</source>
          <target state="translated">선형 프로빙 및 Robin Hood 버킷 스틸 링으로 구현 된 해시 맵입니다.</target>
        </trans-unit>
        <trans-unit id="1b24fb3ba32189304beb3027b487b7bde1af7301" translate="yes" xml:space="preserve">
          <source>A hash map implemented with quadratic probing and SIMD lookup.</source>
          <target state="translated">2 차 프로빙 및 SIMD 조회로 구현 된 해시 맵입니다.</target>
        </trans-unit>
        <trans-unit id="3236fb9d674df64208b5e1cf2d78d481f577b4f2" translate="yes" xml:space="preserve">
          <source>A hash set implemented as a &lt;code&gt;HashMap&lt;/code&gt; where the value is &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;()&lt;/code&gt; 인 &lt;code&gt;HashMap&lt;/code&gt; 으로 구현 된 해시 세트 입니다.</target>
        </trans-unit>
        <trans-unit id="4944fd02934cfc33b70591237170d7c0599ffebd" translate="yes" xml:space="preserve">
          <source>A hashable type.</source>
          <target state="translated">해시 가능 유형</target>
        </trans-unit>
        <trans-unit id="4d0ef9738cd0ca2c9edcc6b3b923fd916c2b5807" translate="yes" xml:space="preserve">
          <source>A helper struct for reverse ordering.</source>
          <target state="translated">역순 정렬을위한 도우미 구조체</target>
        </trans-unit>
        <trans-unit id="2fcfddbae21727b9845f52dbf5c24515e281ef8f" translate="yes" xml:space="preserve">
          <source>A helper trait used for indexing operations.</source>
          <target state="translated">인덱싱 작업에 사용되는 도우미 특성입니다.</target>
        </trans-unit>
        <trans-unit id="2e3f1a456a73954f3da04455c2ebc9a53acd9daf" translate="yes" xml:space="preserve">
          <source>A lang item was redefined.</source>
          <target state="translated">랭 아이템이 재정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="6ffd27d3b6539a3465361b45b3e5461748a1b187" translate="yes" xml:space="preserve">
          <source>A large number of the structures provided by &lt;code&gt;std::io&lt;/code&gt; are for various ways of iterating over I/O. For example, &lt;a href=&quot;struct.lines&quot;&gt;&lt;code&gt;Lines&lt;/code&gt;&lt;/a&gt; is used to split over lines:</source>
          <target state="translated">&lt;code&gt;std::io&lt;/code&gt; 가 제공하는 많은 구조는 I / O를 반복하는 다양한 방법을위한 것입니다. 예를 들어 &lt;a href=&quot;struct.lines&quot;&gt; &lt;code&gt;Lines&lt;/code&gt; &lt;/a&gt; 은 선 을 분할하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="662b6a3ff994171dfffca1e061e7e8ce70b26c02" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the difference of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; 의 차이에서 요소를 생성하는 게으른 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="78a980f05e3a46c3d69eb02390416d427839b9ce" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the difference of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; 의 차이에서 요소를 생성하는 게으른 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="b8f2ea928876732f6cdd8b20aeb46e1a07becd11" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the intersection of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; 의 교차점에서 요소를 생성하는 게으른 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="298c27c033e43f06428f6ee3aa3dd406f79bfc1d" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the intersection of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; 의 교차점에서 요소를 생성하는 게으른 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="5e5f0a0d812adca265e03240d1f5f96e6f3c302c" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the symmetric difference of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; 의 대칭 적 차이에서 요소를 생성하는 지연 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="5248d39b20b8a278703de3ef71e840882448f153" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the symmetric difference of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; 의 대칭 적 차이에서 요소를 생성하는 게으른 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="0f9f2f9fdddb7747ea07bd3f3640c23d49782e5c" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the union of &lt;code&gt;BTreeSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; 조합에서 요소를 생성하는 게으른 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="fc9bf6d7c1e4850a63411aee9c08fbc8782aa61a" translate="yes" xml:space="preserve">
          <source>A lazy iterator producing elements in the union of &lt;code&gt;HashSet&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;HashSet&lt;/code&gt; 통합에서 요소를 생성하는 게으른 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="32415c91edd2506ae578a648363d87b8a79c9954" translate="yes" xml:space="preserve">
          <source>A library developer needs to expose functionality to crates which link against their library. As a consequence of the first case, this means that anything which is usable externally must be &lt;code&gt;pub&lt;/code&gt; from the root down to the destination item. Any private item in the chain will disallow external accesses.</source>
          <target state="translated">라이브러리 개발자는 라이브러리와 링크되는 크레이트에 기능을 노출해야합니다. 첫 번째 경우의 결과로 외부에서 사용할 수있는 것은 루트에서 대상 항목까지 &lt;code&gt;pub&lt;/code&gt; 이어야합니다 . 체인의 모든 개인 품목은 외부 액세스를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ffc7aa510e5357070634b59c577ca85e2c2292b" translate="yes" xml:space="preserve">
          <source>A lifetime appears only in an associated-type binding, and not in the input types to the trait.</source>
          <target state="translated">수명은 특성에 대한 입력 유형이 아니라 연관된 유형 바인딩에만 나타납니다.</target>
        </trans-unit>
        <trans-unit id="7c38295bdcc0eafcba2929a676ec6ceb8e9304c9" translate="yes" xml:space="preserve">
          <source>A lifetime bound was not satisfied.</source>
          <target state="translated">수명 한계가 충족되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="7b0bc06cbbd42c2c42f3c7edb056daf04c8c1022" translate="yes" xml:space="preserve">
          <source>A lifetime name cannot be declared more than once in the same scope. For example:</source>
          <target state="translated">수명 범위 이름은 동일한 범위에서 두 번 이상 선언 될 수 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="24a3a2bd418c09a4c4c2d74fd258bdb9f00cd151" translate="yes" xml:space="preserve">
          <source>A lifetime name is shadowing another lifetime name. Erroneous code example:</source>
          <target state="translated">평생 이름이 다른 평생 이름을 가리고 있습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="e76bb7dad8b82c5bd8c5e995749d2ddcac1434e4" translate="yes" xml:space="preserve">
          <source>A link name was given with an empty name. Erroneous code example:</source>
          <target state="translated">빈 이름으로 링크 이름이 지정되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="916890e2e829b39ca74b6c85b7ab19a70dff37fc" translate="yes" xml:space="preserve">
          <source>A link was used without a name parameter. Erroneous code example:</source>
          <target state="translated">이름 매개 변수없이 링크가 사용되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="ac64cfd6177747480c1f0a80dd27bc3c2253949c" translate="yes" xml:space="preserve">
          <source>A lint check attribute was overruled by a &lt;code&gt;forbid&lt;/code&gt; directive set as an attribute on an enclosing scope, or on the command line with the &lt;code&gt;-F&lt;/code&gt; option.</source>
          <target state="translated">보푸라기 검사 속성이 묶는 범위 또는 &lt;code&gt;-F&lt;/code&gt; 옵션 을 사용하여 명령 줄에서 속성으로 설정된 &lt;code&gt;forbid&lt;/code&gt; 지시문 으로 인해 무효화되었습니다 .</target>
        </trans-unit>
        <trans-unit id="4ec2e82a43ec2456c074c084d9bde606ea9ab3b3" translate="yes" xml:space="preserve">
          <source>A lint check names a potentially undesirable coding pattern, such as unreachable code or omitted documentation. The lint attributes &lt;code&gt;allow&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt;, &lt;code&gt;deny&lt;/code&gt;, and &lt;code&gt;forbid&lt;/code&gt; use the &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt; syntax to specify a list of lint names to change the lint level for the entity to which the attribute applies.</source>
          <target state="translated">린트 검사는 도달 할 수없는 코드 또는 생략 된 문서와 같이 잠재적으로 바람직하지 않은 코딩 패턴의 이름을 지정합니다. 린트 속성은 &lt;code&gt;allow&lt;/code&gt; , &lt;code&gt;warn&lt;/code&gt; , &lt;code&gt;deny&lt;/code&gt; 및 &lt;code&gt;forbid&lt;/code&gt; 를 사용 &lt;a href=&quot;../attributes#meta-item-attribute-syntax&quot;&gt;&lt;em&gt;MetaListPaths&lt;/em&gt;&lt;/a&gt; 속성이 적용되는 개체에 대한 보풀 수준을 변경 보풀 이름의 목록을 지정하는 구문을.</target>
        </trans-unit>
        <trans-unit id="2f470d70068148b9c3f60f9da5c6e02f3a36f8a9" translate="yes" xml:space="preserve">
          <source>A list of available external lang items is available in &lt;code&gt;src/librustc/middle/weak_lang_items.rs&lt;/code&gt;. Example:</source>
          <target state="translated">사용 가능한 외부 랭 항목 목록은 &lt;code&gt;src/librustc/middle/weak_lang_items.rs&lt;/code&gt; 에서 사용할 수 있습니다 . 예:</target>
        </trans-unit>
        <trans-unit id="508df8833b23d4b6921f12bfae0871fdb8efa7ce" translate="yes" xml:space="preserve">
          <source>A list specifying general categories of I/O error.</source>
          <target state="translated">일반적인 I / O 오류 범주를 지정하는 목록입니다.</target>
        </trans-unit>
        <trans-unit id="6afbc1cd2e7b35cec4d1c86812f59ca981f43d9f" translate="yes" xml:space="preserve">
          <source>A list with each element, i.e., &lt;code&gt;[x, y, z]&lt;/code&gt;.</source>
          <target state="translated">각 요소, 즉, 함께 목록 &lt;code&gt;[x, y, z]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15c8d2d5a110eff4a4e3eff0337b45af3836ff58" translate="yes" xml:space="preserve">
          <source>A literal is an expression consisting of a single token, rather than a sequence of tokens, that immediately and directly denotes the value it evaluates to, rather than referring to it by name or some other evaluation rule. A literal is a form of &lt;a href=&quot;const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt;, so is evaluated (primarily) at compile time.</source>
          <target state="translated">리터럴은 일련의 토큰이 아닌 단일 토큰으로 구성되는 표현식으로, 이름이나 다른 평가 규칙으로 참조하지 않고 평가하는 값을 즉시 직접 나타냅니다. 리터럴은 &lt;a href=&quot;const_eval#constant-expressions&quot;&gt;상수 표현식&lt;/a&gt; 의 형태 이므로 컴파일 타임에 (주로) 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="7acc2bbca8147fd009370161f8e9ac4665c257d0" translate="yes" xml:space="preserve">
          <source>A literal was used in a built-in attribute that doesn't support literals.</source>
          <target state="translated">리터럴은 리터럴을 지원하지 않는 내장 속성에 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="8c7298eaf33d5d7b34d2bf261698fdf05d319588" translate="yes" xml:space="preserve">
          <source>A locked reference to the &lt;code&gt;Stderr&lt;/code&gt; handle.</source>
          <target state="translated">&lt;code&gt;Stderr&lt;/code&gt; 핸들에 대한 잠긴 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="e64008e4cbb40a24042f57f0ba8206541604d8ca" translate="yes" xml:space="preserve">
          <source>A locked reference to the &lt;code&gt;Stdin&lt;/code&gt; handle.</source>
          <target state="translated">&lt;code&gt;Stdin&lt;/code&gt; 핸들에 대한 잠긴 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="27f936b73151ca7329818fe3daa46cf14b38bc95" translate="yes" xml:space="preserve">
          <source>A locked reference to the &lt;code&gt;Stdout&lt;/code&gt; handle.</source>
          <target state="translated">&lt;code&gt;Stdout&lt;/code&gt; 핸들에 대한 잠긴 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="209614c8cbb6478d39bb33efacb63355ac82d199" translate="yes" xml:space="preserve">
          <source>A locked standard input implements &lt;code&gt;BufRead&lt;/code&gt;:</source>
          <target state="translated">잠긴 표준 입력은 &lt;code&gt;BufRead&lt;/code&gt; 를 구현 합니다 .</target>
        </trans-unit>
        <trans-unit id="3748fe7789bb3fdcadf97f48b577f7242f80249c" translate="yes" xml:space="preserve">
          <source>A loop expression may optionally have a &lt;em&gt;label&lt;/em&gt;. The label is written as a lifetime preceding the loop expression, as in &lt;code&gt;'foo: loop { break 'foo; }&lt;/code&gt;, &lt;code&gt;'bar: while false {}&lt;/code&gt;, &lt;code&gt;'humbug: for _ in 0..0 {}&lt;/code&gt;. If a label is present, then labeled &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; expressions nested within this loop may exit out of this loop or return control to its head. See &lt;a href=&quot;loop-expr#break-expressions&quot;&gt;break expressions&lt;/a&gt; and &lt;a href=&quot;loop-expr#continue-expressions&quot;&gt;continue expressions&lt;/a&gt;.</source>
          <target state="translated">루프 표현식은 선택적으로 &lt;em&gt;label을&lt;/em&gt; 가질 수 있습니다 . 레이블은 &lt;code&gt;'foo: loop { break 'foo; }&lt;/code&gt; 에서와 같이 루프 표현식 앞에 수명으로 기록됩니다 . } , &lt;code&gt;'bar: while false {}&lt;/code&gt; , &lt;code&gt;'humbug: for _ in 0..0 {}&lt;/code&gt; . 레이블이 있으면 이 루프 내에 중첩 된 &lt;code&gt;break&lt;/code&gt; 된 break 및 &lt;code&gt;continue&lt;/code&gt; 표현식이이 루프를 종료하거나 제어를 헤드로 리턴 할 수 있습니다. &lt;a href=&quot;loop-expr#break-expressions&quot;&gt;구분 표현식&lt;/a&gt; 및 &lt;a href=&quot;loop-expr#continue-expressions&quot;&gt;계속 표현식을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="511e4a1a5b552d0daef468f2387fb6edd0e92546" translate="yes" xml:space="preserve">
          <source>A lossy decoder can be obtained by replacing &lt;code&gt;Err&lt;/code&gt; results with the replacement character:</source>
          <target state="translated">&lt;code&gt;Err&lt;/code&gt; 결과를 대체 문자 로 바꾸면 손실이있는 디코더를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d97f1261b9b58d3e3fe4caf6b3ed4e3d57f050f7" translate="yes" xml:space="preserve">
          <source>A macro invocation executes a macro at compile time and replaces the invocation with the result of the macro. Macros may be invoked in the following situations:</source>
          <target state="translated">매크로 호출은 컴파일 타임에 매크로를 실행하고 호출을 매크로 결과로 대체합니다. 다음과 같은 상황에서 매크로가 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="604f17220a435dfda6ce25b3286e96cae9c124f4" translate="yes" xml:space="preserve">
          <source>A macro listed for import was not found.</source>
          <target state="translated">가져 오기 위해 나열된 매크로를 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2e0526607109d7012469029a56fd3ee785be2e0d" translate="yes" xml:space="preserve">
          <source>A macro to test at &lt;em&gt;runtime&lt;/em&gt; whether a CPU feature is available on x86/x86-64 platforms.</source>
          <target state="translated">x86 / x86-64 플랫폼에서 CPU 기능을 사용할 수 있는지 여부 를 &lt;em&gt;런타임&lt;/em&gt; 에 테스트하는 매크로 입니다.</target>
        </trans-unit>
        <trans-unit id="5b9ba25200988be7523c79ceef0a08b5dbf3a289" translate="yes" xml:space="preserve">
          <source>A major goal of the compiler is to ensure that a library never appears more than once in any artifact. For example, if dynamic libraries B and C were each statically linked to library A, then a crate could not link to B and C together because there would be two copies of A. The compiler allows mixing the rlib and dylib formats, but this restriction must be satisfied.</source>
          <target state="translated">컴파일러의 주요 목표는 라이브러리가 아티팩트에 두 번 이상 나타나지 않도록하는 것입니다. 예를 들어, 동적 라이브러리 B와 C가 각각 라이브러리 A에 정적으로 링크 된 경우, 두 개의 사본이 있으므로 상자가 B와 C에 연결할 수 없습니다. 컴파일러는 rlib와 dylib 형식을 혼합 할 수 있지만이 제한은 만족해야합니다.</target>
        </trans-unit>
        <trans-unit id="416ce06261874aaff012fa6c737cea866a967092" translate="yes" xml:space="preserve">
          <source>A map based on a B-Tree.</source>
          <target state="translated">B- 트리를 기반으로하는지도.</target>
        </trans-unit>
        <trans-unit id="f2df32e1b651fa8937f10fb914a69befa91dcf32" translate="yes" xml:space="preserve">
          <source>A marker trait representing types where a shared reference is considered unwind safe.</source>
          <target state="translated">공유 참조가 안전하지 않은 것으로 간주되는 유형을 나타내는 마커 특성.</target>
        </trans-unit>
        <trans-unit id="ba67e3276d83805bffe74ea0a7a327593cf9467b" translate="yes" xml:space="preserve">
          <source>A marker trait to express that a &lt;code&gt;ReverseSearcher&lt;/code&gt; can be used for a &lt;code&gt;DoubleEndedIterator&lt;/code&gt; implementation.</source>
          <target state="translated">&lt;code&gt;DoubleEndedIterator&lt;/code&gt; 구현에 &lt;code&gt;ReverseSearcher&lt;/code&gt; 를 사용할 수 있음 을 나타내는 마커 특성 .</target>
        </trans-unit>
        <trans-unit id="2f67969c6f12d96330ceaae49a9df5d58837b264" translate="yes" xml:space="preserve">
          <source>A marker trait which represents &quot;panic safe&quot; types in Rust.</source>
          <target state="translated">Rust에서 &quot;panic safe&quot;유형을 나타내는 마커 특성.</target>
        </trans-unit>
        <trans-unit id="7c9160659faee9d41f691cb8f88f2f8a49c219c0" translate="yes" xml:space="preserve">
          <source>A marker type which does not implement &lt;code&gt;Unpin&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Unpin&lt;/code&gt; 을 구현하지 않는 마커 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="2cd086d02e989df16ae8561bd2410188577f706c" translate="yes" xml:space="preserve">
          <source>A measurement of a monotonically nondecreasing clock. Opaque and useful only with &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">단조 비 감소 클록의 측정치입니다. 불투명하고 &lt;code&gt;Duration&lt;/code&gt; 에서만 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="f1b2d1acc7998286a04c3bbe416b5e64b3d2a408" translate="yes" xml:space="preserve">
          <source>A measurement of the system clock, useful for talking to external entities like the file system or other processes.</source>
          <target state="translated">파일 시스템이나 다른 프로세스와 같은 외부 엔터티와 통신하는 데 유용한 시스템 클록 측정입니다.</target>
        </trans-unit>
        <trans-unit id="ab0a8ccacb7225c2d2eaa3d61513ce8be0301515" translate="yes" xml:space="preserve">
          <source>A memory allocator that can be registered as the standard library&amp;rsquo;s default though the &lt;code&gt;#[global_allocator]&lt;/code&gt; attributes.</source>
          <target state="translated">&lt;code&gt;#[global_allocator]&lt;/code&gt; 속성 을 통해 표준 라이브러리의 기본값으로 등록 할 수있는 메모리 할당 자 .</target>
        </trans-unit>
        <trans-unit id="f52897b7b1a254a773b596ff34aeb774856f7c04" translate="yes" xml:space="preserve">
          <source>A metavariable must appear in exactly the same number, kind, and nesting order of repetitions in the transcriber as it did in the matcher. So for the matcher &lt;code&gt;$( $i:ident ),*&lt;/code&gt;, the transcribers &lt;code&gt;=&amp;gt; { $i }&lt;/code&gt;, &lt;code&gt;=&amp;gt; { $( $( $i)* )* }&lt;/code&gt;, and &lt;code&gt;=&amp;gt; { $( $i )+ }&lt;/code&gt; are all illegal, but &lt;code&gt;=&amp;gt; { $( $i );* }&lt;/code&gt; is correct and replaces a comma-separated list of identifiers with a semicolon-separated list.</source>
          <target state="translated">메타 변수는 매처에서와 마찬가지로 전 사기에서 정확히 동일한 수, 종류 및 반복 순서로 나타나야합니다. 따라서 매처 &lt;code&gt;$( $i:ident ),*&lt;/code&gt; 의 경우 전사자는 &lt;code&gt;=&amp;gt; { $i }&lt;/code&gt; , &lt;code&gt;=&amp;gt; { $( $( $i)* )* }&lt;/code&gt; 및 &lt;code&gt;=&amp;gt; { $( $i )+ }&lt;/code&gt; 입니다. 모두 불법이지만 &lt;code&gt;=&amp;gt; { $( $i );* }&lt;/code&gt; 는 정확하며 쉼표로 구분 된 식별자 목록을 세미콜론으로 구분 된 목록으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="801757bf4a897de3dc38db9dc1b65e4429ae7c96" translate="yes" xml:space="preserve">
          <source>A method was called on a raw pointer whose inner type wasn't completely known.</source>
          <target state="translated">내부 유형이 완전히 알려지지 않은 원시 포인터에서 메소드가 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="0b9ba16b85d0fa75f6c2790fe89555c2da2a5ee8" translate="yes" xml:space="preserve">
          <source>A method was implemented when another trait item was expected. Erroneous code example:</source>
          <target state="translated">다른 특성 항목이 예상 될 때 방법이 구현되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="30d915c6907e57ec215e0d955c2fea0a426c859a" translate="yes" xml:space="preserve">
          <source>A module can import both &lt;code&gt;std::fmt::Write&lt;/code&gt; and &lt;code&gt;std::io::Write&lt;/code&gt; and call &lt;code&gt;write!&lt;/code&gt; on objects implementing either, as objects do not typically implement both. However, the module must import the traits qualified so their names do not conflict:</source>
          <target state="translated">모듈은 &lt;code&gt;std::fmt::Write&lt;/code&gt; 와 &lt;code&gt;std::io::Write&lt;/code&gt; 와 call &lt;code&gt;write!&lt;/code&gt; 모두 가져올 수 있습니다 ! 객체는 일반적으로 둘 다를 구현하지 않으므로 객체를 구현합니다. 그러나 모듈은 이름이 충돌하지 않도록 규정 된 특성을 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="9b81303b4be9b1fd6a4b7a6468837e80d06c4579" translate="yes" xml:space="preserve">
          <source>A module for working with borrowed data.</source>
          <target state="translated">빌린 데이터 작업을위한 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="279721754abe896ed73051fc4e21afc678f9887f" translate="yes" xml:space="preserve">
          <source>A module for working with processes.</source>
          <target state="translated">프로세스 작업을위한 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="6a05a78578f1dbd0078ba611f8fe4d06c249f5a6" translate="yes" xml:space="preserve">
          <source>A module is a container for zero or more &lt;a href=&quot;../items&quot;&gt;items&lt;/a&gt;.</source>
          <target state="translated">모듈은 0 개 이상의 &lt;a href=&quot;../items&quot;&gt;항목을&lt;/a&gt; 위한 컨테이너입니다 .</target>
        </trans-unit>
        <trans-unit id="c04981413bae044ff3db488edfd9ac3f31ccdfa7" translate="yes" xml:space="preserve">
          <source>A module without a body is loaded from an external file. When the module does not have a &lt;code&gt;path&lt;/code&gt; attribute, the path to the file mirrors the logical &lt;a href=&quot;../paths&quot;&gt;module path&lt;/a&gt;. Ancestor module path components are directories, and the module's contents are in a file with the name of the module plus the &lt;code&gt;.rs&lt;/code&gt; extension. For example, the following module structure can have this corresponding filesystem structure:</source>
          <target state="translated">본문이없는 모듈은 외부 파일에서로드됩니다. 모듈에 &lt;code&gt;path&lt;/code&gt; 속성 이없는 경우 파일 &lt;a href=&quot;../paths&quot;&gt;경로&lt;/a&gt; 는 논리 모듈 경로를 미러링합니다 . 조상 모듈 경로 구성 요소는 디렉토리이며 모듈의 내용은 모듈 이름과 &lt;code&gt;.rs&lt;/code&gt; 확장자를 가진 파일에 있습니다. 예를 들어, 다음 모듈 구조는 해당 파일 시스템 구조를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29558e1ce9256ba552f6d5cea0ac0d8f0b314326" translate="yes" xml:space="preserve">
          <source>A more complex example:</source>
          <target state="translated">더 복잡한 예 :</target>
        </trans-unit>
        <trans-unit id="d3b971a729c5c72b8be0c4aea17fd6538988f22d" translate="yes" xml:space="preserve">
          <source>A more complex pattern, using a closure:</source>
          <target state="translated">클로저를 사용하는 더 복잡한 패턴 :</target>
        </trans-unit>
        <trans-unit id="3dd589b621cc1adc060715bf9a9ed158d11abe3d" translate="yes" xml:space="preserve">
          <source>A more experienced Rustacean would write the signature shown in Listing 4-9 instead because it allows us to use the same function on both &lt;code&gt;&amp;amp;String&lt;/code&gt; values and &lt;code&gt;&amp;amp;str&lt;/code&gt; values.</source>
          <target state="translated">보다 숙련 된 Rustacean은 대신 &lt;code&gt;&amp;amp;String&lt;/code&gt; 값과 &lt;code&gt;&amp;amp;str&lt;/code&gt; 값 모두에 동일한 함수를 사용할 수 있기 때문에 Listing 4-9에 표시된 서명을 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="e13722d1be852ba526aeffb3cbbf03d8cad62a98" translate="yes" xml:space="preserve">
          <source>A more realistic usage of &lt;code&gt;!&lt;/code&gt; is in this code:</source>
          <target state="translated">보다 현실적인 사용법 &lt;code&gt;!&lt;/code&gt; 이 코드에 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a85c20eab8c8f59bbb7b3375434e1c4c2a5fba1b" translate="yes" xml:space="preserve">
          <source>A mutable binding, reference, or pointer.</source>
          <target state="translated">변경 가능한 바인딩, 참조 또는 포인터</target>
        </trans-unit>
        <trans-unit id="8cd7d09d26092ca44a3f65ffe3c3325410d6931b" translate="yes" xml:space="preserve">
          <source>A mutable iterator over a sub-range of entries in a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; 의 하위 범위 항목에 대해 변경 가능한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="0adc791ed0f0c19141af510a4b25898187d82ab6" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the elements of a &lt;code&gt;LinkedList&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinkedList&lt;/code&gt; 의 요소에 대한 변경 가능한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="ad89e0aaae2a988478ed905cd86eb0dc9435d0ff" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the elements of a &lt;code&gt;VecDeque&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;VecDeque&lt;/code&gt; 요소에 대한 변경 가능한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="79c92db5fb2c00374466341575412a72b346b96d" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the entries of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; 의 항목에 대한 변경 가능한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="82c043e3bfeb960195491db7d3d334e90cb7714f" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the entries of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 의 항목에 대한 변경 가능한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="d985ac327f38804e748201a497e2781eda7b7dde" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the values of a &lt;code&gt;BTreeMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BTreeMap&lt;/code&gt; 값에 대한 변경 가능한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="3180573575f9ee53aeac5bbb0709534becff511d" translate="yes" xml:space="preserve">
          <source>A mutable iterator over the values of a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HashMap&lt;/code&gt; 값에 대한 변경 가능한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="8b90716d837b7248d5e9906c50d0a99bd6595870" translate="yes" xml:space="preserve">
          <source>A mutable memory location with dynamically checked borrow rules</source>
          <target state="translated">동적으로 확인 된 대여 규칙이있는 변경 가능한 메모리 위치</target>
        </trans-unit>
        <trans-unit id="c91e5fa32d436ead641cd9a3940ea6b760cc8d42" translate="yes" xml:space="preserve">
          <source>A mutable memory location.</source>
          <target state="translated">변경 가능한 메모리 위치.</target>
        </trans-unit>
        <trans-unit id="0b14b941c806b921d8ab056b2552003af1435118" translate="yes" xml:space="preserve">
          <source>A mutable reference can be created with &lt;code&gt;&amp;amp;mut&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;mut&lt;/code&gt; 하여 변경 가능한 참조를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0f8c1096d067dc232cad356da19d2cbebed307a4" translate="yes" xml:space="preserve">
          <source>A mutual exclusion primitive useful for protecting shared data</source>
          <target state="translated">공유 데이터 보호에 유용한 상호 배제 기본 요소</target>
        </trans-unit>
        <trans-unit id="342f794408fe251ce7add66c87de4ca58808181b" translate="yes" xml:space="preserve">
          <source>A named address:</source>
          <target state="translated">지명 된 주소 :</target>
        </trans-unit>
        <trans-unit id="da1879858ed2ef626482e4f36f37eea0d652d696" translate="yes" xml:space="preserve">
          <source>A negative implementation is one that excludes a type from implementing a particular trait. Not being able to use a trait is always a safe operation, so negative implementations are always safe and never need to be marked as unsafe.</source>
          <target state="translated">부정적인 구현은 유형이 특정 특성을 구현하지 못하게하는 것입니다. 특성을 사용할 수없는 것은 항상 안전한 작업이므로 부정적인 구현은 항상 안전하며 안전하지 않은 것으로 표시 될 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4ca3ab38594dcb0b01232bdbb9c6f42b411e7856" translate="yes" xml:space="preserve">
          <source>A new pipe should be arranged to connect the parent and child processes.</source>
          <target state="translated">부모와 자식 프로세스를 연결하기 위해 새로운 파이프를 배치해야합니다.</target>
        </trans-unit>
        <trans-unit id="9ef1ea249a1150bef2505217b3c43c59ac961084" translate="yes" xml:space="preserve">
          <source>A new thread can be configured before it is spawned via the &lt;a href=&quot;struct.builder&quot;&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;/a&gt; type, which currently allows you to set the name and stack size for the child thread:</source>
          <target state="translated">&lt;a href=&quot;struct.builder&quot;&gt; &lt;code&gt;Builder&lt;/code&gt; &lt;/a&gt; 유형을 통해 스폰하기 전에 새 스레드를 구성 할 수 있으며 현재 하위 스레드의 이름과 스택 크기를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e4ae553ae5846b13d461bd059795986a05e550e" translate="yes" xml:space="preserve">
          <source>A new thread can be spawned using the &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;thread::spawn&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">&lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;thread::spawn&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 새로운 스레드를 생성 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="012e80e619e9a75c91e5b48d3d4ff0741fba078e" translate="yes" xml:space="preserve">
          <source>A node will be able to refer to its parent node but doesn&amp;rsquo;t own its parent. In Listing 15-28, we update &lt;code&gt;main&lt;/code&gt; to use this new definition so the &lt;code&gt;leaf&lt;/code&gt; node will have a way to refer to its parent, &lt;code&gt;branch&lt;/code&gt;:</source>
          <target state="translated">노드는 부모 노드를 참조 할 수 있지만 부모를 소유하지는 않습니다. Listing 15-28 에서이 새로운 정의를 사용하도록 &lt;code&gt;main&lt;/code&gt; 을 업데이트 하여 &lt;code&gt;leaf&lt;/code&gt; 노드가 부모 인 &lt;code&gt;branch&lt;/code&gt; 를 참조하는 방법을 갖도록한다 .</target>
        </trans-unit>
        <trans-unit id="1c1956450560b920c7d29f562d8c785a2a837c6c" translate="yes" xml:space="preserve">
          <source>A non-constant value was used in a constant expression.</source>
          <target state="translated">상수 표현식에 상수가 아닌 값이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="f749bb15fde0e4ed5d6ca2223f09a3999408a077" translate="yes" xml:space="preserve">
          <source>A non-default implementation was already made on this type so it cannot be specialized further. Erroneous code example:</source>
          <target state="translated">기본이 아닌 구현이이 유형에서 이미 만들어 졌으므로 더 이상 전문화 할 수 없습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="945520bcba1761f9fc7afafe8dcc369bff6ec8f2" translate="yes" xml:space="preserve">
          <source>A non-final component in path is not a directory.</source>
          <target state="translated">경로의 최종 구성 요소가 아닌 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="6d5a3ee2105e8888d79910fc840ffa44f6ec8258" translate="yes" xml:space="preserve">
          <source>A non-raw &lt;em&gt;byte string literal&lt;/em&gt; is a sequence of ASCII characters and &lt;em&gt;escapes&lt;/em&gt;, preceded by the characters &lt;code&gt;U+0062&lt;/code&gt; (&lt;code&gt;b&lt;/code&gt;) and &lt;code&gt;U+0022&lt;/code&gt; (double-quote), and followed by the character &lt;code&gt;U+0022&lt;/code&gt;. If the character &lt;code&gt;U+0022&lt;/code&gt; is present within the literal, it must be &lt;em&gt;escaped&lt;/em&gt; by a preceding &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) character. Alternatively, a byte string literal can be a &lt;em&gt;raw byte string literal&lt;/em&gt;, defined below. The type of a byte string literal of length &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;&amp;amp;'static [u8; n]&lt;/code&gt;.</source>
          <target state="translated">비원시 &lt;em&gt;바이트 문자열 리터럴&lt;/em&gt; 은 ASCII 문자 및 &lt;em&gt;이스케이프&lt;/em&gt; 시퀀스이며 앞에 &lt;code&gt;U+0062&lt;/code&gt; ( &lt;code&gt;b&lt;/code&gt; ) 및 &lt;code&gt;U+0022&lt;/code&gt; (큰 따옴표) 문자가오고 그 뒤에 &lt;code&gt;U+0022&lt;/code&gt; 문자가옵니다 . 문자 &lt;code&gt;U+0022&lt;/code&gt; 가 리터럴 내에있는 경우 선행 &lt;code&gt;U+005C&lt;/code&gt; ( &lt;code&gt;\&lt;/code&gt; ) 문자 로 &lt;em&gt;이스케이프&lt;/em&gt; 해야합니다 . 또는 바이트 문자열 리터럴은 아래에 정의 된 &lt;em&gt;원시 바이트 문자열 리터럴&lt;/em&gt; 일 수 있습니다. 길이가 &lt;code&gt;n&lt;/code&gt; 인 바이트 문자열 리터럴의 유형 은 &lt;code&gt;&amp;amp;'static [u8; n]&lt;/code&gt; n] .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5c51fee9eaaa31ddc4415e9556f81e14c7ecfe88" translate="yes" xml:space="preserve">
          <source>A non-root module attempts to import macros from another crate.</source>
          <target state="translated">비 루트 모듈은 다른 상자에서 매크로를 가져 오려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="2fa1a2ea6af29cff8cb26708218d5730128ed29d" translate="yes" xml:space="preserve">
          <source>A nonexistent interface was requested or the requested address was not local.</source>
          <target state="translated">존재하지 않는 인터페이스가 요청되었거나 요청 된 주소가 로컬이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="96ce721c887ff14a23c8684eb9a885bd0450c6a3" translate="yes" xml:space="preserve">
          <source>A normal component, e.g., &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;a/b&lt;/code&gt;.</source>
          <target state="translated">정상 성분, 예 및 &lt;code&gt;b&lt;/code&gt; 에서 &lt;code&gt;a/b&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5782d98ce3a8ef05d6f0d54e23bbea53e593ec4e" translate="yes" xml:space="preserve">
          <source>A note regarding zero-sized types and zero-sized layouts: many methods in the &lt;code&gt;Alloc&lt;/code&gt; trait state that allocation requests must be non-zero size, or else undefined behavior can result.</source>
          <target state="translated">크기가 0이 아닌 유형과 크기가 0 인 레이아웃에 대한 참고 사항 : &lt;code&gt;Alloc&lt;/code&gt; 특성의 많은 메서드는 할당 요청의 크기가 0이 아니어야합니다. 그렇지 않으면 정의되지 않은 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79055d577bd4470f262c27ac3d7f2c814ba28782" translate="yes" xml:space="preserve">
          <source>A panic upon overflow:</source>
          <target state="translated">오버플로시 패닉 :</target>
        </trans-unit>
        <trans-unit id="bd0627aebae59febc951bf56bcbbb5c77e2a3cca" translate="yes" xml:space="preserve">
          <source>A parameter was incorrect.</source>
          <target state="translated">매개 변수가 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="8faec6289671e90add0a6793ff7c83244ee9ad52" translate="yes" xml:space="preserve">
          <source>A parent of the given path doesn't exist. (To create a directory and all its missing parents at the same time, use the &lt;a href=&quot;fn.create_dir_all&quot;&gt;&lt;code&gt;create_dir_all&lt;/code&gt;&lt;/a&gt; function.)</source>
          <target state="translated">주어진 경로의 부모가 존재하지 않습니다. (디렉토리와 누락 된 모든 부모를 동시에 작성하려면 &lt;a href=&quot;fn.create_dir_all&quot;&gt; &lt;code&gt;create_dir_all&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 .)</target>
        </trans-unit>
        <trans-unit id="3c44a59945c31a15632dad83502ad5c534fa6460" translate="yes" xml:space="preserve">
          <source>A particular instance &lt;code&gt;RandomState&lt;/code&gt; will create the same instances of &lt;a href=&quot;../../hash/trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;, but the hashers created by two different &lt;code&gt;RandomState&lt;/code&gt; instances are unlikely to produce the same result for the same values.</source>
          <target state="translated">특정 인스턴스 &lt;code&gt;RandomState&lt;/code&gt; 는 동일한 인스턴스 생성한다 &lt;a href=&quot;../../hash/trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt; 하지만, 두 가지에 의해 생성 hashers &lt;code&gt;RandomState&lt;/code&gt; 의 인스턴스는 동일한 값에 대해 동일한 결과를 생성 할 가능성이있다.</target>
        </trans-unit>
        <trans-unit id="83b0cbf0a90bcfe2367c6fdcc070513f6d4d75f8" translate="yes" xml:space="preserve">
          <source>A particular pattern &lt;code&gt;_&lt;/code&gt; will match anything, but it never binds to a variable, so it&amp;rsquo;s often used in the last match arm. The &lt;code&gt;_&lt;/code&gt; pattern can be useful when you want to ignore any value not specified, for example. We&amp;rsquo;ll cover the &lt;code&gt;_&lt;/code&gt; pattern in more detail in the &lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;&amp;ldquo;Ignoring Values in a Pattern&amp;rdquo;&lt;/a&gt; section later in this chapter.</source>
          <target state="translated">특정 패턴 &lt;code&gt;_&lt;/code&gt; 는 어떤 것과도 일치하지만 변수에 바인딩되지 않으므로 마지막 매치 암에서 종종 사용됩니다. &lt;code&gt;_&lt;/code&gt; 당신은 예를 들어, 지정되지 않은 값을 무시하고자 할 때 패턴이 유용 할 수 있습니다. 우리는 다룰 &lt;code&gt;_&lt;/code&gt; 에서 더 자세히 패턴 &lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;&quot;패턴으로 무시 값&quot;&lt;/a&gt; 섹션이 장 뒷부분을.</target>
        </trans-unit>
        <trans-unit id="1f72278829757d575931ca8a320129aa5f0521b4" translate="yes" xml:space="preserve">
          <source>A path can take two forms:</source>
          <target state="translated">경로는 두 가지 형태를 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7908f4aa852c1de2737ef7d2b9796ba4b3783229" translate="yes" xml:space="preserve">
          <source>A pattern a &lt;code&gt;..=&lt;/code&gt; b must always have a &amp;le; b. It is an error to have a range pattern &lt;code&gt;10..=0&lt;/code&gt;, for example.</source>
          <target state="translated">패턴 a &lt;code&gt;..=&lt;/code&gt; b에는 항상 &amp;le; b가 있어야합니다. 예를 들어 범위 패턴 &lt;code&gt;10..=0&lt;/code&gt; 을 갖는 것은 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="bf85ec7c19381f75fc673dab8bb0b15ce1a79c9a" translate="yes" xml:space="preserve">
          <source>A pattern is said to be &lt;em&gt;refutable&lt;/em&gt; when it has the possibility of not being matched by the value it is being matched against. &lt;em&gt;Irrefutable&lt;/em&gt; patterns, on the other hand, always match the value they are being matched against. Examples:</source>
          <target state="translated">패턴은 것으로 알려져 &lt;em&gt;논파&lt;/em&gt; 그것이 대해 매칭되는 값에 일치하지 않을 가능성이있는 경우. 반면 &lt;em&gt;반박 할 수없는&lt;/em&gt; 패턴은 항상 일치하는 값과 일치합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="bf12d88e1623c0c22171573d10a1573941789f14" translate="yes" xml:space="preserve">
          <source>A pattern used to match against an enum variant must provide a sub-pattern for each field of the enum variant. This error indicates that a pattern attempted to extract an incorrect number of fields from a variant.</source>
          <target state="translated">열거 형 변형과 일치시키는 데 사용되는 패턴은 열거 형 변형의 각 필드에 대한 하위 패턴을 제공해야합니다. 이 오류는 패턴이 변형에서 잘못된 수의 필드를 추출하려고 시도했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d00f0437e6924080d1afab40ce4328811dd1cc4e" translate="yes" xml:space="preserve">
          <source>A pinned pointer.</source>
          <target state="translated">고정 된 포인터.</target>
        </trans-unit>
        <trans-unit id="a57ac3109ff2b056cae1f3bd5a56c84d66c44184" translate="yes" xml:space="preserve">
          <source>A place that is valid for the duration of a program.</source>
          <target state="translated">프로그램 기간 동안 유효한 장소.</target>
        </trans-unit>
        <trans-unit id="de1781b485888ee330b207b934e4f4c6b09830cf" translate="yes" xml:space="preserve">
          <source>A plugin/crate was declared but cannot be found. Erroneous code example:</source>
          <target state="translated">플러그인 / 상자가 선언되었지만 찾을 수 없습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="34017de9c0f653b0f37f4a6965f6e339b6e3eb8f" translate="yes" xml:space="preserve">
          <source>A pointer type for heap allocation.</source>
          <target state="translated">힙 할당을위한 포인터 유형.</target>
        </trans-unit>
        <trans-unit id="a8f3faefa5c5d4137483f566406d69333a9e2fb7" translate="yes" xml:space="preserve">
          <source>A poisoned &lt;code&gt;Once&lt;/code&gt;:</source>
          <target state="translated">A는 중독 &lt;code&gt;Once&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="929b0eef10b3144f1332f3b71eafbab8eba71fe6" translate="yes" xml:space="preserve">
          <source>A poisoned mutex, however, does not prevent all access to the underlying data. The &lt;a href=&quot;struct.poisonerror&quot;&gt;&lt;code&gt;PoisonError&lt;/code&gt;&lt;/a&gt; type has an &lt;a href=&quot;struct.poisonerror#method.into_inner&quot;&gt;&lt;code&gt;into_inner&lt;/code&gt;&lt;/a&gt; method which will return the guard that would have otherwise been returned on a successful lock. This allows access to the data, despite the lock being poisoned.</source>
          <target state="translated">그러나 중독 된 뮤텍스가 기본 데이터에 대한 모든 액세스를 막지는 못합니다. &lt;a href=&quot;struct.poisonerror&quot;&gt; &lt;code&gt;PoisonError&lt;/code&gt; 의&lt;/a&gt; 유형은이 &lt;a href=&quot;struct.poisonerror#method.into_inner&quot;&gt; &lt;code&gt;into_inner&lt;/code&gt; 의&lt;/a&gt; 그렇지 않으면 성공적인 잠금에 반환 된 것이다 가드를 반환하는 방법을. 이렇게하면 잠금 장치가 감염 되더라도 데이터에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73fd6c45e77753ba09fc6ae1f1a84a2bc4c2f7fb" translate="yes" xml:space="preserve">
          <source>A possible error value when converting a &lt;code&gt;String&lt;/code&gt; from a UTF-16 byte slice.</source>
          <target state="translated">UTF-16 바이트 슬라이스에서 &lt;code&gt;String&lt;/code&gt; 을 변환 할 때 가능한 오류 값 입니다.</target>
        </trans-unit>
        <trans-unit id="ffac94ea92c56dd95950816abb00c940a0255f3a" translate="yes" xml:space="preserve">
          <source>A possible error value when converting a &lt;code&gt;String&lt;/code&gt; from a UTF-8 byte vector.</source>
          <target state="translated">UTF-8 바이트 벡터에서 &lt;code&gt;String&lt;/code&gt; 을 변환 할 때 가능한 오류 값 입니다.</target>
        </trans-unit>
        <trans-unit id="de325cfd40d79951f0c1e349c34b7cd70df1fbf9" translate="yes" xml:space="preserve">
          <source>A prelude for conveniently writing platform-specific code.</source>
          <target state="translated">플랫폼 별 코드를 편리하게 작성하기위한 서문입니다.</target>
        </trans-unit>
        <trans-unit id="c5e33e24aca6a074f404567a2953c71b3f5c603f" translate="yes" xml:space="preserve">
          <source>A priority queue implemented with a binary heap.</source>
          <target state="translated">이진 힙으로 구현 된 우선 순위 큐.</target>
        </trans-unit>
        <trans-unit id="839f5fda33c60277611f831c62b151f9e603547e" translate="yes" xml:space="preserve">
          <source>A private item was used outside its scope.</source>
          <target state="translated">개인 항목이 범위 밖에서 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="519be8a210afc21029c91c0c6f7917299f8dedbe" translate="yes" xml:space="preserve">
          <source>A private item was used outside of its scope.</source>
          <target state="translated">개인 항목이 범위 밖에서 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="94c921f0636467349880453e7613dadeb16d5d80" translate="yes" xml:space="preserve">
          <source>A private trait was used on a public type parameter bound. Erroneous code examples:</source>
          <target state="translated">개인 특성은 공용 유형 매개 변수 바운드에서 사용되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="5e925db174af759a11ddedae27575f0f853ed111" translate="yes" xml:space="preserve">
          <source>A private type was used in a public type signature. Erroneous code example:</source>
          <target state="translated">개인 유형은 공용 유형 서명에 사용되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="c311fafb046b4454c158177c3e7c9d9343861f7d" translate="yes" xml:space="preserve">
          <source>A process builder, providing fine-grained control over how a new process should be spawned.</source>
          <target state="translated">새로운 프로세스 생성 방법을 세밀하게 제어 할 수있는 프로세스 빌더.</target>
        </trans-unit>
        <trans-unit id="b012d3c393a9f2ccaba1d026e4a05fd4cbe591b1" translate="yes" xml:space="preserve">
          <source>A quick refresher on memory ordering:</source>
          <target state="translated">메모리 주문에 대한 빠른 정보 :</target>
        </trans-unit>
        <trans-unit id="63343f59c96578fe01a096392dc2051b122408d3" translate="yes" xml:space="preserve">
          <source>A random number that will generate some variety in the workout plans</source>
          <target state="translated">다양한 운동 계획을 생성하는 난수</target>
        </trans-unit>
        <trans-unit id="72b92a764b3becb3cc5dd577eea9f2e87d42d804" translate="yes" xml:space="preserve">
          <source>A range bounded inclusively below and above (&lt;code&gt;start..=end&lt;/code&gt;).</source>
          <target state="translated">아래 및 위에 포함 된 범위 ( &lt;code&gt;start..=end&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="79fc3105ea5313c5378041705247103257830779" translate="yes" xml:space="preserve">
          <source>A range only bounded exclusively above (&lt;code&gt;..end&lt;/code&gt;).</source>
          <target state="translated">( &lt;code&gt;..end&lt;/code&gt; ) 위에 만 한정된 범위 입니다.</target>
        </trans-unit>
        <trans-unit id="e19446803edcf89ddaf7319d7c6427759416990d" translate="yes" xml:space="preserve">
          <source>A range only bounded inclusively above (&lt;code&gt;..=end&lt;/code&gt;).</source>
          <target state="translated">범위는 ( &lt;code&gt;..=end&lt;/code&gt; ) 에만 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="74324727cee50500895944c74cdd394c1b31fc07" translate="yes" xml:space="preserve">
          <source>A range only bounded inclusively below (&lt;code&gt;start..&lt;/code&gt;).</source>
          <target state="translated">범위는 ( &lt;code&gt;start..&lt;/code&gt; ) 이하로만 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="4f00d04637794ce3f904922bdb42fa3ce7f3d5fe" translate="yes" xml:space="preserve">
          <source>A raw identifier is like a normal identifier, but prefixed by &lt;code&gt;r#&lt;/code&gt;. (Note that the &lt;code&gt;r#&lt;/code&gt; prefix is not included as part of the actual identifier.) Unlike a normal identifier, a raw identifier may be any strict or reserved keyword except the ones listed above for &lt;code&gt;RAW_IDENTIFIER&lt;/code&gt;.</source>
          <target state="translated">원시 식별자는 일반 식별자와 비슷하지만 접두사가 &lt;code&gt;r#&lt;/code&gt; 입니다. 합니다 (참고 &lt;code&gt;r#&lt;/code&gt; 프리픽스는 실제 식별자의 일부분으로서 포함되지 않는다.) 일반 식별자는 달리, 생 식별자에 대해 상기 열거 된 것들을 제외한 모든 엄격한 또는 예약어 수있다 &lt;code&gt;RAW_IDENTIFIER&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffc636325c67605fadec2b68ebb55669b2cd9c34" translate="yes" xml:space="preserve">
          <source>A raw pointer type which can be safely shared between threads.</source>
          <target state="translated">스레드간에 안전하게 공유 할 수있는 원시 포인터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="20341b33140e6b08a4b41c1574d7c2c86bdc7608" translate="yes" xml:space="preserve">
          <source>A reader which is always at EOF.</source>
          <target state="translated">항상 EOF에있는 독자.</target>
        </trans-unit>
        <trans-unit id="5c0eac8aa6da425e06c685e18fd91d499e3c16f1" translate="yes" xml:space="preserve">
          <source>A reader which yields one byte over and over and over and over and over and...</source>
          <target state="translated">1 바이트 이상 반복해서 반복해서 읽는 독자</target>
        </trans-unit>
        <trans-unit id="0187c58d40ebb5aaa0b543a6b1bda48ead05f016" translate="yes" xml:space="preserve">
          <source>A reader-writer lock</source>
          <target state="translated">리더 라이터 락</target>
        </trans-unit>
        <trans-unit id="414e2acfb8956698eab95c0efb754ad454841ffa" translate="yes" xml:space="preserve">
          <source>A reference has a longer lifetime than the data it references.</source>
          <target state="translated">참조는 참조하는 데이터보다 수명이 길다.</target>
        </trans-unit>
        <trans-unit id="9108b5b496b508ef46e829906b2e7b5524691e8f" translate="yes" xml:space="preserve">
          <source>A reference represents a borrow of some owned value. You can get one by using the &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut&lt;/code&gt; operators on a value, or by using a &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;ref mut&lt;/code&gt; pattern.</source>
          <target state="translated">참조는 일부 소유 가치의 대출을 나타냅니다. 값에 &lt;code&gt;&amp;amp;&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut&lt;/code&gt; 연산자를 사용하거나 &lt;code&gt;ref&lt;/code&gt; 또는 &lt;code&gt;ref mut&lt;/code&gt; 패턴 을 사용하여 값을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9b45e7cfae560003198e2ac81c9a7e5c60325d0a" translate="yes" xml:space="preserve">
          <source>A reference to an open file on the filesystem.</source>
          <target state="translated">파일 시스템에서 열린 파일에 대한 참조</target>
        </trans-unit>
        <trans-unit id="cbf7d17da7f9b8415b894a96d3c62639060d8148" translate="yes" xml:space="preserve">
          <source>A reference to the current directory, i.e., &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">즉, 현재 디렉토리에의 참조 &lt;code&gt;.&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54c4ba3b0f946cb73000b704747ed0cc043ef985" translate="yes" xml:space="preserve">
          <source>A reference to the parent directory, i.e., &lt;code&gt;..&lt;/code&gt;.</source>
          <target state="translated">상위 디렉토리에 대한 참조, 즉, &lt;code&gt;..&lt;/code&gt; . .</target>
        </trans-unit>
        <trans-unit id="771deb0451fb407b0fb913d5488c53c42558785c" translate="yes" xml:space="preserve">
          <source>A regular floating point number.</source>
          <target state="translated">정규 부동 소수점 숫자</target>
        </trans-unit>
        <trans-unit id="cd85c1b05128e75e217b61f7154c9636692d1cea" translate="yes" xml:space="preserve">
          <source>A regular reference is a type of pointer, and one way to think of a pointer is as an arrow to a value stored somewhere else. In Listing 15-6, we create a reference to an &lt;code&gt;i32&lt;/code&gt; value and then use the dereference operator to follow the reference to the data:</source>
          <target state="translated">일반 참조는 포인터의 한 유형이며 포인터를 생각하는 한 가지 방법은 다른 곳에 저장된 값에 대한 화살표입니다. Listing 15-6에서 &lt;code&gt;i32&lt;/code&gt; 값에 대한 참조를 작성한 후 역 참조 연산자를 사용하여 데이터에 대한 참조를 따른다.</target>
        </trans-unit>
        <trans-unit id="461658f899b03c712ef32df7b204d3908a10ea3a" translate="yes" xml:space="preserve">
          <source>A related concept is scope: the nested context in which code is written has a set of names that are defined as &amp;ldquo;in scope.&amp;rdquo; When reading, writing, and compiling code, programmers and compilers need to know whether a particular name at a particular spot refers to a variable, function, struct, enum, module, constant, or other item and what that item means. You can create scopes and change which names are in or out of scope. You can&amp;rsquo;t have two items with the same name in the same scope; tools are available to resolve name conflicts.</source>
          <target state="translated">관련 개념은 범위입니다. 코드가 작성되는 중첩 컨텍스트에는 &quot;범위 내&quot;로 정의 된 일련의 이름이 있습니다. 코드를 읽고, 쓰고, 컴파일 할 때 프로그래머와 컴파일러는 특정 지점의 특정 이름이 변수, 함수, 구조체, 열거 형, 모듈, 상수 또는 기타 항목을 나타내는 지 여부와 해당 항목의 의미를 알아야합니다. 범위를 만들고 범위에 있거나 범위를 벗어난 이름을 변경할 수 있습니다. 같은 범위에서 같은 이름을 가진 두 항목을 가질 수 없습니다. 이름 충돌을 해결하는 도구를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4629afc869292537f9c628724559e37eef9a2cb2" translate="yes" xml:space="preserve">
          <source>A repeat expression &lt;code&gt;[x; N]&lt;/code&gt;, which produces an array with &lt;code&gt;N&lt;/code&gt; copies of &lt;code&gt;x&lt;/code&gt;. The type of &lt;code&gt;x&lt;/code&gt; must be &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반복 표현 &lt;code&gt;[x; N]&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; 의 &lt;code&gt;N&lt;/code&gt; 복사본을 가진 배열을 생성합니다 . &lt;code&gt;x&lt;/code&gt; 의 유형은 &lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="6bdd3de922c246975bfd1cbfd244a2a660fcbad2" translate="yes" xml:space="preserve">
          <source>A return statement was found outside of a function body.</source>
          <target state="translated">함수 본문 외부에서 return 문이 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="80cb47a4163ef3f70e5ddff5f65587e6f1ef80e1" translate="yes" xml:space="preserve">
          <source>A reverse searcher for a string pattern.</source>
          <target state="translated">문자열 패턴에 대한 역방향 검색 자.</target>
        </trans-unit>
        <trans-unit id="4d45eae920f51ae4fa809b8359142e43a5dccbee" translate="yes" xml:space="preserve">
          <source>A scrutinee is the expression that is matched on in &lt;code&gt;match&lt;/code&gt; expressions and similar pattern matching constructs. For example, in &lt;code&gt;match x { A =&amp;gt; 1, B =&amp;gt; 2 }&lt;/code&gt;, the expression &lt;code&gt;x&lt;/code&gt; is the scrutinee.</source>
          <target state="translated">스크루 티네는 &lt;code&gt;match&lt;/code&gt; 표현식 및 유사한 패턴 일치 구문 에서 일치하는 표현식입니다. 예를 들어, &lt;code&gt;match x { A =&amp;gt; 1, B =&amp;gt; 2 }&lt;/code&gt; 에서 식 &lt;code&gt;x&lt;/code&gt; 는 스크 루틴입니다.</target>
        </trans-unit>
        <trans-unit id="090be4c47ade9f54015d614891f57e36867218e4" translate="yes" xml:space="preserve">
          <source>A searcher for a string pattern.</source>
          <target state="translated">문자열 패턴을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="805b0de6f894d8345c096cc31db6d9d15c14c18a" translate="yes" xml:space="preserve">
          <source>A seek beyond the end of a stream is allowed, but behavior is defined by the implementation.</source>
          <target state="translated">스트림 끝을 넘어서는 탐색이 허용되지만 동작은 구현에 의해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="187cb85d876dbb3e8278047d50cee3e8447cafbc" translate="yes" xml:space="preserve">
          <source>A set based on a B-Tree.</source>
          <target state="translated">B- 트리를 기반으로 한 세트.</target>
        </trans-unit>
        <trans-unit id="89f39617bf1d1e8280f2895b2baeee66b493c8f3" translate="yes" xml:space="preserve">
          <source>A similar error is E0201. The difference is whether there is one declaration block or not. To avoid this error, you must give each &lt;code&gt;fn&lt;/code&gt; a unique name.</source>
          <target state="translated">비슷한 오류는 E0201입니다. 차이점은 하나의 선언 블록이 있는지 여부입니다. 이 오류를 피하려면 각 &lt;code&gt;fn&lt;/code&gt; 에 고유 한 이름을 지정 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6f6761295ae70019a0d2d6374dca4eaf6df07696" translate="yes" xml:space="preserve">
          <source>A similar rule exists for combining mutable and immutable references. This code results in an error:</source>
          <target state="translated">변경 가능한 참조와 변경 불가능한 참조를 결합하는 비슷한 규칙이 있습니다. 이 코드는 오류가 발생합니다 :</target>
        </trans-unit>
        <trans-unit id="8e839688e01ba01e9dfe145feb09335f1aa963d0" translate="yes" xml:space="preserve">
          <source>A simple example:</source>
          <target state="translated">간단한 예 :</target>
        </trans-unit>
        <trans-unit id="823d579a067f8a96f5626154ea604d86f19d68ef" translate="yes" xml:space="preserve">
          <source>A simple function returning &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; might be defined and used like so:</source>
          <target state="translated">&lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 반환하는 간단한 함수 는 다음과 같이 정의되고 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d53eef6dd046b01cc7902a1c3902a172dad006e2" translate="yes" xml:space="preserve">
          <source>A simple spinlock:</source>
          <target state="translated">간단한 스핀 락 :</target>
        </trans-unit>
        <trans-unit id="a2f952715a286d980e4f33b8e4525dcb3eac03bb" translate="yes" xml:space="preserve">
          <source>A simple workaround is to use a helper method instead:</source>
          <target state="translated">간단한 해결 방법은 도우미 메서드를 대신 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="054dbf6f392fa38162c0d62e6ead09a79999e53b" translate="yes" xml:space="preserve">
          <source>A simple wrapper around a type to assert that it is unwind safe.</source>
          <target state="translated">타입을 둘러싼 간단한 래퍼로 안전합니다.</target>
        </trans-unit>
        <trans-unit id="cd3fd0649d54745c9dde4e2f256bda95babba9f6" translate="yes" xml:space="preserve">
          <source>A single (arbitrary) thread will receive a &lt;a href=&quot;struct.barrierwaitresult&quot;&gt;&lt;code&gt;BarrierWaitResult&lt;/code&gt;&lt;/a&gt; that returns &lt;code&gt;true&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;is_leader&lt;/code&gt;&lt;/a&gt; when returning from this function, and all other threads will receive a result that will return &lt;code&gt;false&lt;/code&gt; from &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt;&lt;code&gt;is_leader&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">단일 (임의의) 스레드는 이 함수 에서 &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt; &lt;code&gt;is_leader&lt;/code&gt; &lt;/a&gt; 때 is_leader 에서 &lt;code&gt;true&lt;/code&gt; 를 리턴 하는 &lt;a href=&quot;struct.barrierwaitresult&quot;&gt; &lt;code&gt;BarrierWaitResult&lt;/code&gt; &lt;/a&gt; 를 수신하고 다른 모든 스레드는 &lt;a href=&quot;struct.barrierwaitresult#method.is_leader&quot;&gt; &lt;code&gt;is_leader&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;false&lt;/code&gt; 를 리턴하는 결과를 수신합니다 .</target>
        </trans-unit>
        <trans-unit id="0e774847b8b17cfc775f96b4b6ba3419133c2ae2" translate="yes" xml:space="preserve">
          <source>A single &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; may be encoded as more than one byte. This method can only succeed if the entire byte sequence was successfully written, and this method will not return until all data has been written or an error occurs.</source>
          <target state="translated">단일 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 는 둘 이상의 바이트로 인코딩 될 수 있습니다. 이 방법은 전체 바이트 시퀀스가 ​​성공적으로 기록 된 경우에만 성공할 수 있으며 모든 데이터가 기록되거나 오류가 발생할 때까지 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a7ad66dadfa2951ac2cd349b4d260c6f6b28c527" translate="yes" xml:space="preserve">
          <source>A single &lt;em&gt;decimal literal&lt;/em&gt; followed by an &lt;em&gt;exponent&lt;/em&gt;.</source>
          <target state="translated">단일 &lt;em&gt;10 진수 리터럴&lt;/em&gt; 다음에 &lt;em&gt;지수가&lt;/em&gt; 옵니다 .</target>
        </trans-unit>
        <trans-unit id="538d82224c466a3fa46957bd1dad7926fc97c926" translate="yes" xml:space="preserve">
          <source>A single component of a path.</source>
          <target state="translated">경로의 단일 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="2286204503218f0f2c8d94ba2bb110e020e0bc00" translate="yes" xml:space="preserve">
          <source>A single-threaded reference-counting pointer. 'Rc' stands for 'Reference Counted'.</source>
          <target state="translated">단일 스레드 참조 계산 포인터 'Rc'는 'Reference Counted'를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5b101d21362e496b89adfac2fbb37a58e0757a7e" translate="yes" xml:space="preserve">
          <source>A slice is a &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized type&lt;/a&gt; representing a 'view' into a sequence of elements of type &lt;code&gt;T&lt;/code&gt;. The slice type is written as &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="translated">슬라이스는 &lt;code&gt;T&lt;/code&gt; 유형의 요소 시퀀스에 대한 '보기'를 나타내는 &lt;a href=&quot;../dynamically-sized-types&quot;&gt;동적 크기&lt;/a&gt; 의 유형 입니다. 슬라이스 유형은 &lt;code&gt;[T]&lt;/code&gt; 로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="aba616073ac3de8beab95ccfac7bd633d599946d" translate="yes" xml:space="preserve">
          <source>A slice is dynamically-sized view into a contiguous sequence, written as &lt;code&gt;[T]&lt;/code&gt;.</source>
          <target state="translated">슬라이스는 &lt;code&gt;[T]&lt;/code&gt; 로 작성된 연속적인 시퀀스로 동적 크기 뷰를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="fe635e064516decbfbc3e3d9ce043f9d25e8ca9f" translate="yes" xml:space="preserve">
          <source>A slice of a path (akin to &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">경로의 슬라이스 ( &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; 에 영향&lt;/a&gt; 을 미침 ).</target>
        </trans-unit>
        <trans-unit id="11824dd936b3023e24b3affd0ef64f49ba6ed2c9" translate="yes" xml:space="preserve">
          <source>A slightly sad example of not reading anything into a buffer:</source>
          <target state="translated">버퍼로 아무것도 읽지 않는 약간 슬픈 예 :</target>
        </trans-unit>
        <trans-unit id="45dafb0f63eaca5bfb7f56b27e11fa2b7d396e89" translate="yes" xml:space="preserve">
          <source>A socket address could not be bound because the address is already in use elsewhere.</source>
          <target state="translated">주소가 이미 다른 곳에서 사용 중이므로 소켓 주소를 바인딩 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ac2b051bc6a92539c672158c6142e1d18c98d73f" translate="yes" xml:space="preserve">
          <source>A somewhat surprising consequence of the definition is that &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; (if &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt;) even though it seems like that might provide unsynchronized mutation. The trick is that a mutable reference behind a shared reference (that is, &lt;code&gt;&amp;amp; &amp;amp;mut T&lt;/code&gt;) becomes read-only, as if it were a &lt;code&gt;&amp;amp; &amp;amp;T&lt;/code&gt;. Hence there is no risk of a data race.</source>
          <target state="translated">정의의 다소 놀라운 결과 는 &lt;code&gt;Sync&lt;/code&gt; 되지 않은 돌연변이를 제공 할 수있는 것처럼 보이지만 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 가 &lt;code&gt;Sync&lt;/code&gt; ( &lt;code&gt;T&lt;/code&gt; 가 Sync 인 경우 )입니다. 트릭은 공유 참조 뒤에있는 가변 참조 ( &lt;code&gt;&amp;amp; &amp;amp;mut T&lt;/code&gt; )가 &lt;code&gt;&amp;amp; &amp;amp;T&lt;/code&gt; 인 것처럼 읽기 전용이되는 것 입니다. 따라서 데이터 경쟁의 위험이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2194c015edca7318deaf09554d0cad9263a5128b" translate="yes" xml:space="preserve">
          <source>A source file can have a &lt;a href=&quot;https://en.wikipedia.org/wiki/Shebang_(Unix)&quot;&gt;&lt;em&gt;shebang&lt;/em&gt;&lt;/a&gt; (SHEBANG production), which indicates to the operating system what program to use to execute this file. It serves essentially to treat the source file as an executable script. The shebang can only occur at the beginning of the file (but after the optional &lt;em&gt;UTF8BOM&lt;/em&gt;). It is ignored by the compiler. For example:</source>
          <target state="translated">소스 파일에는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Shebang_(Unix)&quot;&gt;&lt;em&gt;shebang&lt;/em&gt;&lt;/a&gt; (SHEBANG 프로덕션) 이있을 수 있으며 운영 체제에이 파일을 실행하는 데 사용할 프로그램을 나타냅니다. 기본적으로 소스 파일을 실행 가능한 스크립트로 취급합니다. shebang은 파일의 시작 부분 (옵션 &lt;em&gt;UTF8BOM&lt;/em&gt; 이후)에서만 발생할 수 있습니다 . 컴파일러는이를 무시합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3a13e4ab897112a5bbfa779986c13ffc8249c723" translate="yes" xml:space="preserve">
          <source>A specialized &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type for I/O operations.</source>
          <target state="translated">I / O 작업에 대한 특수 &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 유형입니다.</target>
        </trans-unit>
        <trans-unit id="29c08563a92ed84161c48f32442e9c55ea57c60e" translate="yes" xml:space="preserve">
          <source>A specialized &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type for threads.</source>
          <target state="translated">스레드에 대한 특수 &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 유형입니다.</target>
        </trans-unit>
        <trans-unit id="c3d479aee422ab65a96675342bd98a8476bf0c50" translate="yes" xml:space="preserve">
          <source>A splicing iterator for &lt;code&gt;Vec&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Vec&lt;/code&gt; 의 스 플라이 싱 반복자 .</target>
        </trans-unit>
        <trans-unit id="7208bc1e59d67cb800b9b249868cce02c7e08ab0" translate="yes" xml:space="preserve">
          <source>A stability attribute was used outside of the standard library. Erroneous code example:</source>
          <target state="translated">안정성 속성은 표준 라이브러리 외부에서 사용되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="c28a8a30c83d119da8eeb5ad945a45667f90aa8f" translate="yes" xml:space="preserve">
          <source>A statement is the smallest standalone element of a programming language that commands a computer to perform an action.</source>
          <target state="translated">명령문은 컴퓨터가 동작을 수행하도록 명령하는 프로그래밍 언어의 가장 작은 독립형 요소입니다.</target>
        </trans-unit>
        <trans-unit id="d8b0000fb42f01e7695f858d20347ce505d823eb" translate="yes" xml:space="preserve">
          <source>A string describing the architecture of the CPU that is currently in use.</source>
          <target state="translated">현재 사용중인 CPU 아키텍처를 설명하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="5df1b3a45cf6eb695745e50e624d24676a48e8a7" translate="yes" xml:space="preserve">
          <source>A string describing the specific operating system in use. Example value is &lt;code&gt;linux&lt;/code&gt;.</source>
          <target state="translated">사용중인 특정 운영 체제를 설명하는 문자열입니다. 예제 값은 &lt;code&gt;linux&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8947468201a55a4ba9cd06d3d0a2f1ff1271df73" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. 'Left' in this context means the first position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the &lt;em&gt;right&lt;/em&gt; side, not the left.</source>
          <target state="translated">문자열은 일련의 바이트입니다. 이 문맥에서 '왼쪽'은 해당 바이트 문자열의 첫 번째 위치를 의미합니다. '오른쪽에서 왼쪽으로'가 아니라보다 아랍어 또는 히브리어와 같은 언어에 대해 '왼쪽에서 오른쪽으로', 이것은있을 것이다 &lt;em&gt;우측&lt;/em&gt; 측면이 아닌 왼쪽.</target>
        </trans-unit>
        <trans-unit id="0bc83c493a049c765d2dfbebad0f09d82d1b6fde" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. 'Right' in this context means the last position of that byte string; for a language like Arabic or Hebrew which are 'right to left' rather than 'left to right', this will be the &lt;em&gt;left&lt;/em&gt; side, not the right.</source>
          <target state="translated">문자열은 일련의 바이트입니다. 이 문맥에서 '오른쪽'은 해당 바이트 문자열의 마지막 위치를 의미합니다. '오른쪽에서 왼쪽으로'가 아니라보다 아랍어 또는 히브리어와 같은 언어에 대해 '왼쪽에서 오른쪽으로', 이것은있을 것입니다 &lt;em&gt;왼쪽&lt;/em&gt; 측면하지 않을 권리.</target>
        </trans-unit>
        <trans-unit id="fd472172ba3e393c6a98b65077b0a65554fdb8e3" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;end&lt;/code&gt; in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like like Arabic or Hebrew, this will be the left side.</source>
          <target state="translated">문자열은 일련의 바이트입니다. 이 문맥에서 &lt;code&gt;end&lt;/code&gt; 은 해당 바이트 문자열의 마지막 위치를 의미합니다. 영어 나 러시아어와 같이 왼쪽에서 오른쪽으로 쓰는 언어의 경우 오른쪽이되고 아랍어 나 히브리어와 같은 오른쪽에서 왼쪽으로 쓰는 언어의 경우 왼쪽이됩니다.</target>
        </trans-unit>
        <trans-unit id="b8e69c41862936bd74ab07a7db3ea33fabc1421d" translate="yes" xml:space="preserve">
          <source>A string is a sequence of bytes. &lt;code&gt;start&lt;/code&gt; in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like like Arabic or Hebrew, this will be the right side.</source>
          <target state="translated">문자열은 일련의 바이트입니다. 이 문맥에서 &lt;code&gt;start&lt;/code&gt; 은 해당 바이트 문자열의 첫 번째 위치를 의미합니다. 영어 나 러시아어와 같은 왼쪽에서 오른쪽으로 쓰는 언어의 경우 왼쪽이되고 아랍어 나 히브리어와 같은 오른쪽에서 왼쪽으로 쓰는 언어의 경우 오른쪽이됩니다.</target>
        </trans-unit>
        <trans-unit id="3af90a5c6860195d31687a2b123d3690f30cc3df" translate="yes" xml:space="preserve">
          <source>A string literal is a string stored directly in the final binary, and so will be valid for the &lt;code&gt;'static&lt;/code&gt; duration.</source>
          <target state="translated">문자열 리터럴은 최종 바이너리에 직접 저장된 문자열이므로 &lt;code&gt;'static&lt;/code&gt; 지속 기간 동안 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="72d1187b478d157904cca7877538ced2b416e35f" translate="yes" xml:space="preserve">
          <source>A string pattern.</source>
          <target state="translated">문자열 패턴.</target>
        </trans-unit>
        <trans-unit id="067ff927875044f01fc32c9a4450dd787608c362" translate="yes" xml:space="preserve">
          <source>A string slice (&lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;) is made of bytes (&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;), and a byte slice (&lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;&lt;/a&gt;) is made of bytes, so this function converts between the two. Not all byte slices are valid string slices, however: &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; requires that it is valid UTF-8. &lt;code&gt;from_utf8()&lt;/code&gt; checks to ensure that the bytes are valid UTF-8, and then does the conversion.</source>
          <target state="translated">문자열 슬라이스 ( &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; )는 바이트 ( &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; )로 구성되고 바이트 슬라이스 ( &lt;a href=&quot;../primitive.slice&quot;&gt; &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; &lt;/a&gt; )는 바이트로 구성 되므로이 함수는 둘 사이를 변환합니다. 모든 바이트 슬라이스가 유효한 문자열 슬라이스는 아니지만 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 하려면 유효한 UTF-8 이어야 합니다. &lt;code&gt;from_utf8()&lt;/code&gt; 은 바이트가 유효한 UTF-8인지 확인한 다음 변환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e7464828dc4f92a12dd0ad9693849275688a2fde" translate="yes" xml:space="preserve">
          <source>A string slice (&lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;) is made of bytes (&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;), and a vector of bytes (&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;&lt;/a&gt;) is made of bytes, so this function converts between the two. Not all byte slices are valid &lt;code&gt;String&lt;/code&gt;s, however: &lt;code&gt;String&lt;/code&gt; requires that it is valid UTF-8. &lt;code&gt;from_utf8()&lt;/code&gt; checks to ensure that the bytes are valid UTF-8, and then does the conversion.</source>
          <target state="translated">문자열 슬라이스 ( &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; )는 바이트 ( &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; ) 로 만들어지고 바이트 벡터 ( &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; &lt;/a&gt; )는 바이트로 만들어 지므로이 함수는 둘 사이를 변환합니다. 그러나 모든 바이트 슬라이스가 유효한 &lt;code&gt;String&lt;/code&gt; 은 아닙니다 . &lt;code&gt;String&lt;/code&gt; 은 유효한 UTF-8이어야합니다. &lt;code&gt;from_utf8()&lt;/code&gt; 은 바이트가 유효한 UTF-8인지 확인한 다음 변환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="185b4c50dbb326aeb04eb1f2bab9a2d41dd7280a" translate="yes" xml:space="preserve">
          <source>A string slice is the most primitive string type in Rust, written as &lt;code&gt;str&lt;/code&gt;. It is often seen in its borrowed forms, either mutable or shared. The shared string slice type is &lt;code&gt;&amp;amp;str&lt;/code&gt;, while the mutable string slice type is &lt;code&gt;&amp;amp;mut str&lt;/code&gt;.</source>
          <target state="translated">문자열 슬라이스는 Rust에서 가장 원시적 인 문자열 유형으로 &lt;code&gt;str&lt;/code&gt; 로 작성됩니다 . 종종 빌린 형태로 변경 가능하거나 공유됩니다. 공유 문자열 슬라이스 유형은 &lt;code&gt;&amp;amp;str&lt;/code&gt; 이고 변경 가능한 문자열 슬라이스 유형은 &lt;code&gt;&amp;amp;mut str&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="696c15b61497eb0b1cb08d222cb16dce5b4582da" translate="yes" xml:space="preserve">
          <source>A struct can be &lt;code&gt;Copy&lt;/code&gt;, and &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;Copy&lt;/code&gt;, therefore &lt;code&gt;Point&lt;/code&gt; is eligible to be &lt;code&gt;Copy&lt;/code&gt;. By contrast, consider</source>
          <target state="translated">구조체가 될 수 있습니다 &lt;code&gt;Copy&lt;/code&gt; 하고, &lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt; 이다 &lt;code&gt;Copy&lt;/code&gt; 따라서 &lt;code&gt;Point&lt;/code&gt; 가 될 자격이 &lt;code&gt;Copy&lt;/code&gt; . 대조적으로, 고려</target>
        </trans-unit>
        <trans-unit id="f5d13af10075668c4266bfa2af5c2d787c33d9d3" translate="yes" xml:space="preserve">
          <source>A struct constructor with private fields was invoked. Erroneous code example:</source>
          <target state="translated">개인 필드가있는 구조체 생성자가 호출되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="d5d8cb072da62f16419c7934c8ea02767949e9d6" translate="yes" xml:space="preserve">
          <source>A struct containing information about the location of a panic.</source>
          <target state="translated">공황의 위치에 대한 정보를 포함하는 구조체.</target>
        </trans-unit>
        <trans-unit id="4cbc7f2982657f6ecdc97f40e8df1ad547c2b1e9" translate="yes" xml:space="preserve">
          <source>A struct expression can terminate with the syntax &lt;code&gt;..&lt;/code&gt; followed by an expression to denote a functional update. The expression following &lt;code&gt;..&lt;/code&gt; (the base) must have the same struct type as the new struct type being formed.</source>
          <target state="translated">구조체 식은 구문 &lt;code&gt;..&lt;/code&gt; 으로 끝나고 기능 업데이트를 나타내는식이 뒤따를 수 있습니다 . &lt;code&gt;..&lt;/code&gt; (기본) 다음에 나오는 표현식 은 새로운 struct 유형과 동일한 struct 유형을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="86c4b8e1d72da61f04333be84148a5de11fccd79" translate="yes" xml:space="preserve">
          <source>A struct expression with fields enclosed in curly braces allows you to specify the value for each individual field in any order. The field name is separated from its value with a colon.</source>
          <target state="translated">중괄호로 묶인 필드가있는 구조체 표현식을 사용하면 각 개별 필드의 값을 임의의 순서로 지정할 수 있습니다. 필드 이름은 콜론으로 값과 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="89ddcc2481a3b96d64219755d7c1825c0ff65c03" translate="yes" xml:space="preserve">
          <source>A struct expression with fields enclosed in parentheses constructs a tuple struct. Though it is listed here as a specific expression for completeness, it is equivalent to a &lt;a href=&quot;call-expr&quot;&gt;call expression&lt;/a&gt; to the tuple struct's constructor. For example:</source>
          <target state="translated">괄호로 묶인 필드가있는 구조체 표현식은 튜플 구조체를 구성합니다. 여기에는 완전성을위한 특정 표현식으로 나열되어 있지만 튜플 구조체의 생성자 에 대한 &lt;a href=&quot;call-expr&quot;&gt;호출 표현식&lt;/a&gt; 과 동일합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fed041bebb665ccd5885e8c57eed09e9404a7bab" translate="yes" xml:space="preserve">
          <source>A struct pattern is refutable when one of its subpatterns is refutable.</source>
          <target state="translated">하위 패턴 중 하나가 반박 가능한 경우 구조체 패턴은 반박 가능합니다.</target>
        </trans-unit>
        <trans-unit id="7845438dcb42a82b5f335b8afeff28c09f01fb02" translate="yes" xml:space="preserve">
          <source>A struct providing information about a panic.</source>
          <target state="translated">공황에 관한 정보를 제공하는 구조체.</target>
        </trans-unit>
        <trans-unit id="2e74ee410a88a7bd4dc9ec3e4439e1be7c03f52f" translate="yes" xml:space="preserve">
          <source>A struct to help with &lt;a href=&quot;trait.debug&quot;&gt;&lt;code&gt;fmt::Debug&lt;/code&gt;&lt;/a&gt; implementations.</source>
          <target state="translated">&lt;a href=&quot;trait.debug&quot;&gt; &lt;code&gt;fmt::Debug&lt;/code&gt; &lt;/a&gt; 구현 을 돕는 구조체 입니다.</target>
        </trans-unit>
        <trans-unit id="5cc6e14f7d3ffa0d43917de969f7811f2b833f5b" translate="yes" xml:space="preserve">
          <source>A struct with a single field which is accessible by dereferencing the struct.</source>
          <target state="translated">구조체를 역 참조함으로써 접근 가능한 단일 필드를 가진 구조체.</target>
        </trans-unit>
        <trans-unit id="804d90713791042aa7ae7163ec47b488d14fba5e" translate="yes" xml:space="preserve">
          <source>A struct with a single field which is modifiable by dereferencing the struct.</source>
          <target state="translated">구조체를 역 참조함으로써 수정 가능한 단일 필드를 가진 구조체.</target>
        </trans-unit>
        <trans-unit id="0888572f00b05df1f9ff3f22503c0dc7eb90c709" translate="yes" xml:space="preserve">
          <source>A struct with more than one field containing an unsized type cannot implement &lt;code&gt;CoerceUnsized&lt;/code&gt;. This only occurs when you are trying to coerce one of the types in your struct to another type in the struct. In this case we try to impl &lt;code&gt;CoerceUnsized&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;U&lt;/code&gt; which are both types that the struct takes. An &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;unsized type&lt;/a&gt; is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</source>
          <target state="translated">크기가 조정되지 않은 유형을 포함하는 필드가 둘 이상인 구조체는 &lt;code&gt;CoerceUnsized&lt;/code&gt; 를 구현할 수 없습니다 . 구조체의 형식 중 하나를 구조체의 다른 형식으로 강제 변환하려는 경우에만 발생합니다. 이 경우 구조체가 취하는 두 가지 유형 인 &lt;code&gt;CoerceUnsized&lt;/code&gt; 를 &lt;code&gt;T&lt;/code&gt; 에서 &lt;code&gt;U&lt;/code&gt; 로묵시 하려고합니다 . &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;크기를 지정하지 않은 타입은&lt;/a&gt; 컴파일러가 컴파일시에 길이 또는 정렬을 알고하지 않습니다 어떤 유형입니다. 크기가 조정되지 않은 유형을 포함하는 모든 구조체도 크기가 조정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fd90f531eb1d0ac938c6ffc13d21933bccfecc8d" translate="yes" xml:space="preserve">
          <source>A struct with the representation hint &lt;code&gt;repr(transparent)&lt;/code&gt; had zero or more than one fields that were not guaranteed to be zero-sized.</source>
          <target state="translated">표현 힌트 &lt;code&gt;repr(transparent)&lt;/code&gt; 가 있는 구조체 는 0 또는 두 개 이상의 필드를 갖지만 크기가 0이 아님을 보증하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b1c33e6a538a3d99ccd128f7c3f5572cd613b66b" translate="yes" xml:space="preserve">
          <source>A struct without a field containing an unsized type cannot implement &lt;code&gt;CoerceUnsized&lt;/code&gt;. An &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;unsized type&lt;/a&gt; is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</source>
          <target state="translated">크기가 지정되지 않은 유형을 포함하는 필드가없는 구조체는 &lt;code&gt;CoerceUnsized&lt;/code&gt; 를 구현할 수 없습니다 . &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;크기를 지정하지 않은 타입은&lt;/a&gt; 컴파일러가 컴파일시에 길이 또는 정렬을 알고하지 않습니다 어떤 유형입니다. 크기가 조정되지 않은 유형을 포함하는 모든 구조체도 크기가 조정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d312c16b162889c1bce1669ed072c5b476d65baa" translate="yes" xml:space="preserve">
          <source>A struct, enum, or union with the &lt;code&gt;repr(transparent)&lt;/code&gt; representation hint contains a zero-sized field that requires non-trivial alignment.</source>
          <target state="translated">&lt;code&gt;repr(transparent)&lt;/code&gt; 표현 힌트 와 구조체, 열거 또는 공용체는 사소한 정렬이 필요한 크기가 0 인 필드를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="87c6cf95d3e0451e702dc377209e4618399b1fa6" translate="yes" xml:space="preserve">
          <source>A structure representing a Unix domain socket server.</source>
          <target state="translated">유닉스 도메인 소켓 서버를 나타내는 구조.</target>
        </trans-unit>
        <trans-unit id="369143bfa607c6bacd39b080c8d08420dc95dcbd" translate="yes" xml:space="preserve">
          <source>A structure representing a type of file with accessors for each file type. It is returned by &lt;a href=&quot;struct.metadata#method.file_type&quot;&gt;&lt;code&gt;Metadata::file_type&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">각 파일 형식에 대한 접근자가있는 파일 형식을 나타내는 구조입니다. &lt;a href=&quot;struct.metadata#method.file_type&quot;&gt; &lt;code&gt;Metadata::file_type&lt;/code&gt; &lt;/a&gt; 메소드에 의해 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="2859b7dadbca8f1bc62c1ff5e0e2a9f89b18f533" translate="yes" xml:space="preserve">
          <source>A structure wrapping a Windows path prefix as well as its unparsed string representation.</source>
          <target state="translated">구문 분석되지 않은 문자열 표현뿐만 아니라 Windows 경로 접두사를 래핑하는 구조입니다.</target>
        </trans-unit>
        <trans-unit id="d24a2a657ceada76d6bbbb3c74ce41c5696fa9c3" translate="yes" xml:space="preserve">
          <source>A successful send occurs when it is determined that the other end of the channel has not hung up already. An unsuccessful send would be one where the corresponding receiver has already been deallocated. Note that a return value of &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; means that the data will never be received, but a return value of &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; does &lt;em&gt;not&lt;/em&gt; mean that the data will be received. It is possible for the corresponding receiver to hang up immediately after this function returns &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">채널의 다른 쪽 끝이 이미 끊지 않았다고 판단되면 성공적으로 전송됩니다. 실패한 송신은 해당 수신자가 이미 할당 해제 된 것입니다. &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 의 반환 값은 데이터가 수신 되지 &lt;em&gt;않음을&lt;/em&gt; 의미 하지만 &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; 의 반환 값이 데이터가 수신됨을 의미 하지는 &lt;em&gt;않습니다&lt;/em&gt; . 이 함수가 &lt;a href=&quot;../../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; 를&lt;/a&gt; 반환 한 직후에 해당 수신기가 끊어 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74d74f5ba0d4e61c19c1486af3bde440292622e8" translate="yes" xml:space="preserve">
          <source>A suffix is a non-raw identifier immediately (without whitespace) following the primary part of a literal.</source>
          <target state="translated">접미사는 리터럴의 주요 부분 바로 뒤에 나오는 공백이 아닌 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="a56a331926b2603c064792db84cd20c38dc32bf0" translate="yes" xml:space="preserve">
          <source>A synchronization primitive which can be used to run a one-time global initialization. Useful for one-time initialization for FFI or related functionality. This type can only be constructed with the &lt;a href=&quot;constant.once_init&quot;&gt;&lt;code&gt;ONCE_INIT&lt;/code&gt;&lt;/a&gt; value or the equivalent &lt;a href=&quot;struct.once#method.new&quot;&gt;&lt;code&gt;Once::new&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">일회성 글로벌 초기화를 실행하는 데 사용할 수있는 동기화 기본 요소. FFI 또는 관련 기능의 일회성 초기화에 유용합니다. 이 유형은 &lt;a href=&quot;constant.once_init&quot;&gt; &lt;code&gt;ONCE_INIT&lt;/code&gt; &lt;/a&gt; 값 또는 동등한 &lt;a href=&quot;struct.once#method.new&quot;&gt; &lt;code&gt;Once::new&lt;/code&gt; &lt;/a&gt; 생성자 로만 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ec350722ecdc068b18a23660d975deaef83608f5" translate="yes" xml:space="preserve">
          <source>A synchronous, bounded channel. The &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt; function will return a &lt;code&gt;(SyncSender, Receiver)&lt;/code&gt; tuple where the storage for pending messages is a pre-allocated buffer of a fixed size. All sends will be &lt;strong&gt;synchronous&lt;/strong&gt; by blocking until there is buffer space available. Note that a bound of 0 is allowed, causing the channel to become a &quot;rendezvous&quot; channel where each sender atomically hands off a message to a receiver.</source>
          <target state="translated">동기적이고 제한된 채널. &lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; 의&lt;/a&gt; 함수 반환 &lt;code&gt;(SyncSender, Receiver)&lt;/code&gt; 보류 된 메시지의 저장이 고정 된 크기의 사전 - 할당 된 버퍼이다 튜플. 사용 가능한 버퍼 공간이 확보 될 때까지 차단하여 모든 송신이 &lt;strong&gt;동기&lt;/strong&gt; 됩니다. 0의 경계가 허용되므로 채널은 각 발신자가 원자 적으로 수신자에게 메시지를 전달하는 &quot;랑데부&quot;채널이됩니다.</target>
        </trans-unit>
        <trans-unit id="cba628809f9496f1476d8b33de698410511ed6a9" translate="yes" xml:space="preserve">
          <source>A syntactical production</source>
          <target state="translated">구문 생산</target>
        </trans-unit>
        <trans-unit id="96826c24c299b2bf43fb19f0b4fbba10405e86b7" translate="yes" xml:space="preserve">
          <source>A thread can also return a value through its &lt;a href=&quot;struct.joinhandle&quot;&gt;&lt;code&gt;JoinHandle&lt;/code&gt;&lt;/a&gt;, you can use this to make asynchronous computations (futures might be more appropriate though).</source>
          <target state="translated">스레드는 &lt;a href=&quot;struct.joinhandle&quot;&gt; &lt;code&gt;JoinHandle&lt;/code&gt; 을&lt;/a&gt; 통해 값을 반환 할 수도 있습니다.이를 사용하여 비동기 계산을 수행 할 수 있습니다 (미래가 더 적합 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="ca6a08446cfa59c90fd402f951ed8784aa3d5f4c" translate="yes" xml:space="preserve">
          <source>A thread local storage key which owns its contents.</source>
          <target state="translated">내용을 소유하는 스레드 로컬 스토리지 키.</target>
        </trans-unit>
        <trans-unit id="a566c05b188249907018616799317e8f6688426e" translate="yes" xml:space="preserve">
          <source>A thread that completes without panicking is considered to exit successfully.</source>
          <target state="translated">당황하지 않고 완료된 스레드는 성공적으로 종료 된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="cd2f16a831072bb59e0c5fa9974e56f23c534e74" translate="yes" xml:space="preserve">
          <source>A thread-local key owns the value it contains and will destroy the value when the thread exits. It is created with the &lt;a href=&quot;../macro.thread_local&quot;&gt;&lt;code&gt;thread_local!&lt;/code&gt;&lt;/a&gt; macro and can contain any value that is &lt;code&gt;'static&lt;/code&gt; (no borrowed pointers). It provides an accessor function, &lt;a href=&quot;struct.localkey#method.with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt;, that yields a shared reference to the value to the specified closure. Thread-local keys allow only shared access to values, as there would be no way to guarantee uniqueness if mutable borrows were allowed. Most values will want to make use of some form of &lt;strong&gt;interior mutability&lt;/strong&gt; through the &lt;a href=&quot;../cell/struct.cell&quot;&gt;&lt;code&gt;Cell&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&lt;/code&gt;&lt;/a&gt; types.</source>
          <target state="translated">스레드 로컬 키는 포함 된 값을 소유하며 스레드가 종료되면 값을 삭제합니다. &lt;a href=&quot;../macro.thread_local&quot;&gt; &lt;code&gt;thread_local!&lt;/code&gt; &lt;/a&gt; 로 작성됩니다 ! 매크로이며 &lt;code&gt;'static&lt;/code&gt; (임대 된 포인터 없음) 인 값을 포함 할 수 있습니다 . &lt;a href=&quot;struct.localkey#method.with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 접근 자 함수를 제공 하여 지정된 클로저에 대한 값에 대한 공유 참조를 생성합니다. 스레드 로컬 키는 변경 가능한 차용이 허용 된 경우 고유성을 보장 할 방법이 없으므로 값에 대한 공유 액세스 만 허용합니다. 대부분의 값은 &lt;a href=&quot;../cell/struct.cell&quot;&gt; &lt;code&gt;Cell&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&lt;/code&gt; &lt;/a&gt; 유형을 통해 어떤 형태의 &lt;strong&gt;내부 변이성&lt;/strong&gt; 을 사용 하려고 합니다.</target>
        </trans-unit>
        <trans-unit id="7c1b3e385815bb55356e10c862b54219c0c9bb61" translate="yes" xml:space="preserve">
          <source>A thread-safe reference-counting pointer. 'Arc' stands for 'Atomically Reference Counted'.</source>
          <target state="translated">스레드 안전 레퍼런스 카운팅 포인터. 'Arc'는 'Atomically Reference Counted'를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c20fcb5862a17955d3c9171cc540c5db72364cad" translate="yes" xml:space="preserve">
          <source>A token produced by the lexer</source>
          <target state="translated">어휘 분석기에서 생산 한 토큰</target>
        </trans-unit>
        <trans-unit id="507266de8c913e006a522a90feaa72cf485f935b" translate="yes" xml:space="preserve">
          <source>A trailing slash is normalized away, &lt;code&gt;/a/b&lt;/code&gt; and &lt;code&gt;/a/b/&lt;/code&gt; are equivalent.</source>
          <target state="translated">후행 슬래시는 &lt;code&gt;/a/b&lt;/code&gt; 및 &lt;code&gt;/a/b/&lt;/code&gt; 정규화됩니다. 는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4ac633f47782fcea3e3cdbd2b28541d42f49cb1e" translate="yes" xml:space="preserve">
          <source>A trait bound on &lt;code&gt;?Sized&lt;/code&gt; is the opposite of a trait bound on &lt;code&gt;Sized&lt;/code&gt;: we would read this as &amp;ldquo;&lt;code&gt;T&lt;/code&gt; may or may not be &lt;code&gt;Sized&lt;/code&gt;.&amp;rdquo; This syntax is only available for &lt;code&gt;Sized&lt;/code&gt;, not any other traits.</source>
          <target state="translated">&quot; &lt;code&gt;?Sized&lt;/code&gt; 에있는 특성은 &lt;code&gt;Sized&lt;/code&gt; 에 대한 특성과 반대입니다 . 우리는 이것을 &quot; &lt;code&gt;T&lt;/code&gt; 는 &lt;code&gt;Sized&lt;/code&gt; 가 될 수도 있고 그렇지 않을 수도 있습니다 &quot;라고 읽습니다 . 이 구문은 &lt;code&gt;Sized&lt;/code&gt; 다른 특성이 아닌 Sized .</target>
        </trans-unit>
        <trans-unit id="a7f257ac376cb00e120748ca01c24ce026b8963b" translate="yes" xml:space="preserve">
          <source>A trait can have multiple methods in its body: the method signatures are listed one per line and each line ends in a semicolon.</source>
          <target state="translated">특성은 본문에 여러 메소드를 가질 수 있습니다. 메소드 서명은 한 줄에 하나씩 나열되고 각 줄은 세미콜론으로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="9262128bd94142a9efd03c6641a2bff3a39b5b73" translate="yes" xml:space="preserve">
          <source>A trait for borrowing data.</source>
          <target state="translated">데이터를 빌리는 특성.</target>
        </trans-unit>
        <trans-unit id="7529a2277a29d3ff854565242eed7e5e7895a272" translate="yes" xml:space="preserve">
          <source>A trait for converting a value to a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">값을로 변환하는 특성 &lt;code&gt;String&lt;/code&gt; 으로 .</target>
        </trans-unit>
        <trans-unit id="1e3010340eda1a0df2c156c88d0e99044a3b58ec" translate="yes" xml:space="preserve">
          <source>A trait for creating instances of &lt;a href=&quot;trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt; 인스턴스를 만들기위한 특성 .</target>
        </trans-unit>
        <trans-unit id="c6d9b8a4582a6d812cf132a7f8cdac8ff53fc3aa" translate="yes" xml:space="preserve">
          <source>A trait for customizing the behavior of the &lt;code&gt;?&lt;/code&gt; operator.</source>
          <target state="translated">의 행동을 사용자 정의하기위한 특성 &lt;code&gt;?&lt;/code&gt; 운영자.</target>
        </trans-unit>
        <trans-unit id="976dcd2549faab554b8e6bbecaabfc30542917fd" translate="yes" xml:space="preserve">
          <source>A trait for giving a type a useful default value.</source>
          <target state="translated">유형에 유용한 기본값을 제공하는 특성입니다.</target>
        </trans-unit>
        <trans-unit id="e18827eba48f91a1c885aefb421b9657624cb210" translate="yes" xml:space="preserve">
          <source>A trait for hashing an arbitrary stream of bytes.</source>
          <target state="translated">임의의 바이트 스트림을 해시하는 특성.</target>
        </trans-unit>
        <trans-unit id="bdee9213c6e4170b3110b9dd5eaa365239c9d83d" translate="yes" xml:space="preserve">
          <source>A trait for implementing arbitrary return types in the &lt;code&gt;main&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 함수 에서 임의의 리턴 유형을 구현하기위한 특성 .</target>
        </trans-unit>
        <trans-unit id="20b8f1b86976a3452526ed169982978b3d0e907f" translate="yes" xml:space="preserve">
          <source>A trait for mutably borrowing data.</source>
          <target state="translated">데이터를 변경 가능하게 빌리는 특성.</target>
        </trans-unit>
        <trans-unit id="d1ed2c9d8583af1348e3be7781420c71c940ca4b" translate="yes" xml:space="preserve">
          <source>A trait for objects which are byte-oriented sinks.</source>
          <target state="translated">바이트 지향 싱크 인 객체의 특성.</target>
        </trans-unit>
        <trans-unit id="754c048641e5a68c7fd81cc8028cfbaf095e1cb7" translate="yes" xml:space="preserve">
          <source>A trait for objects which can be converted or resolved to one or more &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; values.</source>
          <target state="translated">하나 이상의 &lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt; 값 으로 변환되거나 해석 될 수있는 객체의 특성입니다 .</target>
        </trans-unit>
        <trans-unit id="bc29685de3e170d55184516a7b3d199864139684" translate="yes" xml:space="preserve">
          <source>A trait implementation is considered incoherent if either the orphan check fails or there are overlapping implementation instances.</source>
          <target state="translated">고아 검사가 실패하거나 구현 인스턴스가 겹치는 경우 특성 구현이 일관성이없는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="bb0a26a692dfe7bee9af7137b27b0e076260ccbc" translate="yes" xml:space="preserve">
          <source>A trait implementation must define all non-default associated items declared by the implemented trait, may redefine default associated items defined by the implemented trait, and cannot define any other items.</source>
          <target state="translated">특성 구현은 구현 된 특성에 의해 선언 된 모든 비 기본 연관 항목을 정의해야하며 구현 된 특성에 의해 정의 된 기본 연관 항목을 재정의 할 수 있으며 다른 항목을 정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1951065ab3447cdfa4016a3198b5e5dd606d4a6b" translate="yes" xml:space="preserve">
          <source>A trait is a language item that is used for describing the functionalities a type must provide. It allows a type to make certain promises about its behavior.</source>
          <target state="translated">특성은 유형이 제공해야하는 기능을 설명하는 데 사용되는 언어 항목입니다. 형식이 동작에 대해 특정 약속을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9de8e0634dfdc7f3f2e02723351cb17b73aefe4" translate="yes" xml:space="preserve">
          <source>A trait may be implemented for &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; in the same crate as &lt;code&gt;T&lt;/code&gt;, which the &lt;a href=&quot;items/implementations#trait-implementation-coherence&quot;&gt;orphan rules&lt;/a&gt; prevent for other generic types.</source>
          <target state="translated">&lt;a href=&quot;items/implementations#trait-implementation-coherence&quot;&gt;고아 규칙&lt;/a&gt; 이 다른 일반 유형에 대해 방지 하는 &lt;code&gt;T&lt;/code&gt; 와 동일한 상자에서 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; 에 대해 특성이 구현 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c934c2073046ff60e5d7154f42129a33305f83af" translate="yes" xml:space="preserve">
          <source>A trait object is defined over a single, fully-defined trait. With a regular default parameter, this parameter can just be substituted in. However, if the default parameter is &lt;code&gt;Self&lt;/code&gt;, the trait changes for each concrete type; i.e. &lt;code&gt;i32&lt;/code&gt; will be expected to implement &lt;code&gt;A&amp;lt;i32&amp;gt;&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt; will be expected to implement &lt;code&gt;A&amp;lt;bool&amp;gt;&lt;/code&gt;, etc... These types will not share an implementation of a fully-defined trait; instead they share implementations of a trait with different parameters substituted in for each implementation. This is irreconcilable with what we need to make a trait object work, and is thus disallowed. Making the trait concrete by explicitly specifying the value of the defaulted parameter will fix this issue. Fixed example:</source>
          <target state="translated">형질 개체는 완전히 정의 된 단일 특성에 대해 정의됩니다. 일반 기본 매개 변수를 사용하면이 매개 변수를 대체 할 수 있습니다. 그러나 기본 매개 변수가 &lt;code&gt;Self&lt;/code&gt; 인 경우 각 콘크리트 유형에 따라 특성이 변경됩니다. 즉,이 &lt;code&gt;i32&lt;/code&gt; 구현 할 것으로 예상됩니다 &lt;code&gt;A&amp;lt;i32&amp;gt;&lt;/code&gt; , &lt;code&gt;bool&lt;/code&gt; 구현 할 것으로 예상됩니다 &lt;code&gt;A&amp;lt;bool&amp;gt;&lt;/code&gt; 등 ...이 유형은 완전히 정의 된 특성의 구현을 공유하지 않습니다. 대신 각 구현에 대해 다른 매개 변수로 대체 된 특성의 구현을 공유합니다. 이것은 특질 대상을 작동시키는 데 필요한 것과 양립 할 수 없으므로 허용되지 않습니다. 기본 매개 변수의 값을 명시 적으로 지정하여 특성을 구체적으로 만들면이 문제가 해결됩니다. 고정 된 예 :</target>
        </trans-unit>
        <trans-unit id="2977e50a37e0d1dad52d9fd5a6a043035b25bd2b" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to construct an object from a raw file descriptor.</source>
          <target state="translated">원시 파일 디스크립터에서 오브젝트를 구성하는 기능을 표현하는 특성입니다.</target>
        </trans-unit>
        <trans-unit id="d60c5c028a11d7b4ae9ad91367b8c4ed38349307" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to consume an object and acquire ownership of its raw &lt;code&gt;HANDLE&lt;/code&gt;.</source>
          <target state="translated">객체를 소비하고 원시 &lt;code&gt;HANDLE&lt;/code&gt; 소유권을 얻는 능력을 표현하는 특성 .</target>
        </trans-unit>
        <trans-unit id="c1f9b5c774891d37ad148a2229500ad192b8b52c" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to consume an object and acquire ownership of its raw &lt;code&gt;SOCKET&lt;/code&gt;.</source>
          <target state="translated">객체를 소비하고 원시 &lt;code&gt;SOCKET&lt;/code&gt; 의 소유권을 얻는 능력을 표현하는 특성 .</target>
        </trans-unit>
        <trans-unit id="a98e8ff575c7077546911de64edefa1e0d617067" translate="yes" xml:space="preserve">
          <source>A trait to express the ability to consume an object and acquire ownership of its raw file descriptor.</source>
          <target state="translated">객체를 소비하고 원시 파일 디스크립터의 소유권을 얻는 기능을 표현하는 특성.</target>
        </trans-unit>
        <trans-unit id="25a11a87d2f4adf0083235ec32efcdd357ad1b14" translate="yes" xml:space="preserve">
          <source>A trait to extract the raw unix file descriptor from an underlying object.</source>
          <target state="translated">기본 개체에서 원시 unix 파일 설명자를 추출하는 특성입니다.</target>
        </trans-unit>
        <trans-unit id="1af6d624d68ca3ca313d81ebc03c7ca717454c50" translate="yes" xml:space="preserve">
          <source>A transparent struct, enum, or union is supposed to be represented exactly like the piece of data it contains. Zero-sized fields with different alignment requirements potentially conflict with this property. In the example above, &lt;code&gt;Wrapper&lt;/code&gt; would have to be aligned to 32 bytes even though &lt;code&gt;f32&lt;/code&gt; has a smaller alignment requirement.</source>
          <target state="translated">투명한 구조체, 열거 형 또는 공용체는 포함 된 데이터와 똑같이 표현되어야합니다. 다른 정렬 요구 사항을 가진 크기가 0 인 필드는이 속성과 충돌 할 가능성이 있습니다. 위의 예에서, &lt;code&gt;f32&lt;/code&gt; 는 더 작은 정렬 요구 사항을 갖 더라도 &lt;code&gt;Wrapper&lt;/code&gt; 는 32 바이트로 정렬되어야합니다.</target>
        </trans-unit>
        <trans-unit id="490336a5e305f2d2e8d1363f03a6314c497a78fa" translate="yes" xml:space="preserve">
          <source>A tricky example, with sigma:</source>
          <target state="translated">시그마를 사용한 까다로운 예 :</target>
        </trans-unit>
        <trans-unit id="2d6e480d45ae2d8d8e393f568dbe81e3240a2b6b" translate="yes" xml:space="preserve">
          <source>A trivial example of the usage of &lt;code&gt;bool&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 사용법의 간단한 예 ,</target>
        </trans-unit>
        <trans-unit id="26204199326019f143410da0c8e1f31498a99258" translate="yes" xml:space="preserve">
          <source>A tuple &lt;em&gt;type&lt;/em&gt; is a heterogeneous product of other types, called the &lt;em&gt;elements&lt;/em&gt; of the tuple. It has no nominal name and is instead structurally typed.</source>
          <target state="translated">튜플 &lt;em&gt;유형&lt;/em&gt; 은 튜플 의 &lt;em&gt;요소&lt;/em&gt; 라고하는 다른 유형의 이기종 곱입니다 . 명목 이름이 없으며 구조적으로 형식이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="402bd39bb6c42541595f5aba7871ff88c655396e" translate="yes" xml:space="preserve">
          <source>A tuple is a general way of grouping together some number of other values with a variety of types into one compound type. Tuples have a fixed length: once declared, they cannot grow or shrink in size.</source>
          <target state="translated">튜플은 다양한 유형의 여러 다른 값을 하나의 복합 유형으로 그룹화하는 일반적인 방법입니다. 튜플의 길이는 고정되어 있습니다. 일단 선언하면 크기를 늘리거나 줄일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1696a724c358dd0091f73a52db83c7a8082d2750" translate="yes" xml:space="preserve">
          <source>A tuple struct pattern is refutable when one of its subpatterns is refutable.</source>
          <target state="translated">튜플 구조체 패턴은 하위 패턴 중 하나가 반박 가능할 때 반박 가능합니다.</target>
        </trans-unit>
        <trans-unit id="1009527a15bba1ad137f4f63c037795bd4a2bfe2" translate="yes" xml:space="preserve">
          <source>A type alias for the result of a lock method which can be poisoned.</source>
          <target state="translated">중독 될 수있는 잠금 방법의 결과에 대한 유형 별명입니다.</target>
        </trans-unit>
        <trans-unit id="aae3cf8f6eb9071486813bec542109175b1464e5" translate="yes" xml:space="preserve">
          <source>A type alias for the result of a nonblocking locking method.</source>
          <target state="translated">비 블로킹 잠금 방법의 결과에 대한 유형 별명입니다.</target>
        </trans-unit>
        <trans-unit id="811e3fb59c28acd0a23a2498fc25dd5079b4be0d" translate="yes" xml:space="preserve">
          <source>A type alias makes this code more manageable by reducing the repetition. In Listing 19-25, we&amp;rsquo;ve introduced an alias named &lt;code&gt;Thunk&lt;/code&gt; for the verbose type and can replace all uses of the type with the shorter alias &lt;code&gt;Thunk&lt;/code&gt;.</source>
          <target state="translated">타입 별칭은 반복을 줄임으로써이 코드를보다 관리하기 쉽게 만듭니다. Listing 19-25에서는 상세 유형에 &lt;code&gt;Thunk&lt;/code&gt; 라는 별명을 도입 했으며이 유형의 모든 사용을 더 짧은 별명 &lt;code&gt;Thunk&lt;/code&gt; 로 대체 할 수있다 .</target>
        </trans-unit>
        <trans-unit id="872091a52699e1a821b52be55e9443115016332c" translate="yes" xml:space="preserve">
          <source>A type alias to an enum type cannot be used to qualify the constructors:</source>
          <target state="translated">열거 형에 대한 유형 별칭은 생성자를 한정하는 데 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9e407e83d82ec15858c1c29f981a47a04ebb8636" translate="yes" xml:space="preserve">
          <source>A type annotated as &lt;code&gt;repr(transparent)&lt;/code&gt; delegates all representation concerns to another type, so adding more representation hints is contradictory. Remove either the &lt;code&gt;transparent&lt;/code&gt; hint or the other hints, like this:</source>
          <target state="translated">&lt;code&gt;repr(transparent)&lt;/code&gt; 로 주석이 달린 유형 은 모든 표현 문제를 다른 유형으로 위임하므로 더 많은 표현 힌트를 추가하는 것은 모순됩니다. 다음과 같이 &lt;code&gt;transparent&lt;/code&gt; 힌트 또는 다른 힌트를 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb5e8aa2faa836eb0e6e33148484b741b2f52f31" translate="yes" xml:space="preserve">
          <source>A type can also have multiple inherent implementations. An implementing type must be defined within the same crate as the original type definition.</source>
          <target state="translated">유형에는 여러 고유 구현이있을 수도 있습니다. 구현 유형은 원래 유형 정의와 동일한 상자 내에 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="ec397cd955b41db47c056843b89f1c979b1499b9" translate="yes" xml:space="preserve">
          <source>A type can implement &lt;code&gt;Copy&lt;/code&gt; if all of its components implement &lt;code&gt;Copy&lt;/code&gt;. For example, this struct can be &lt;code&gt;Copy&lt;/code&gt;:</source>
          <target state="translated">모든 구성 요소가 &lt;code&gt;Copy&lt;/code&gt; 를 구현하는 경우 형식은 &lt;code&gt;Copy&lt;/code&gt; 를 구현할 수 있습니다 . 예를 들어이 구조체는 &lt;code&gt;Copy&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a1e5e79c85877ceec782fbfaa18c2c4e5b9b2282" translate="yes" xml:space="preserve">
          <source>A type cast expression is denoted with the binary operator &lt;code&gt;as&lt;/code&gt;.</source>
          <target state="translated">유형 캐스트 ​​표현식은 이항 연산자 &lt;code&gt;as&lt;/code&gt; 로 표시 됩니다 .</target>
        </trans-unit>
        <trans-unit id="995f457de088e34d1af6ab0e7cbed95033f1f938" translate="yes" xml:space="preserve">
          <source>A type implementing &lt;code&gt;Try&lt;/code&gt; is one that has a canonical way to view it in terms of a success/failure dichotomy. This trait allows both extracting those success or failure values from an existing instance and creating a new instance from a success or failure value.</source>
          <target state="translated">&lt;code&gt;Try&lt;/code&gt; 를 구현하는 형식 은 성공 / 실패 이분법으로 볼 수있는 정식 방법이있는 유형 입니다. 이 특성을 통해 기존 인스턴스에서 해당 성공 또는 실패 값을 추출하고 성공 또는 실패 값에서 새 인스턴스를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5199d6683f66f6377d3e5c541ab1e1a45f0a440" translate="yes" xml:space="preserve">
          <source>A type indicating whether a timed wait on a condition variable returned due to a time out or not.</source>
          <target state="translated">시간 종료로 인해 조건 변수에 대한 시간 종료 대기가 리턴되는지 여부를 표시하는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="195d3e2324eafc4b95d0787028892dc2ce75ef57" translate="yes" xml:space="preserve">
          <source>A type of error which can be returned whenever a lock is acquired.</source>
          <target state="translated">잠금을 획득 할 때마다 리턴 될 수있는 오류 유형입니다.</target>
        </trans-unit>
        <trans-unit id="c7fb190bd9cd84e642f9c437ffcc3a0470b68cd6" translate="yes" xml:space="preserve">
          <source>A type or module has been defined more than once.</source>
          <target state="translated">유형 또는 모듈이 두 번 이상 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="7a60e8550db7fb8bf181c3c2af427df857c9bf7d" translate="yes" xml:space="preserve">
          <source>A type parameter was declared which shadows an existing one. An example of this error:</source>
          <target state="translated">기존 매개 변수를 음영 처리하는 유형 매개 변수가 선언되었습니다. 이 오류의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="25fe9cd48afec311fa3f403a24aafba6272aeca5" translate="yes" xml:space="preserve">
          <source>A type parameter which references &lt;code&gt;Self&lt;/code&gt; in its default value was not specified. Example of erroneous code:</source>
          <target state="translated">기본값에서 &lt;code&gt;Self&lt;/code&gt; 를 참조하는 유형 매개 변수가 지정되지 않았습니다. 잘못된 코드의 예 :</target>
        </trans-unit>
        <trans-unit id="7d790d10f882d09d23c776016863815c5b3e2b81" translate="yes" xml:space="preserve">
          <source>A type representing an owned, C-compatible, nul-terminated string with no nul bytes in the middle.</source>
          <target state="translated">중간에 널 바이트가없는 고유 한 C 호환 널 종료 문자열을 나타내는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="b3b99d63ae795914f8001d38731a170b595e6b2b" translate="yes" xml:space="preserve">
          <source>A type that can be any one of several variants.</source>
          <target state="translated">여러 변형 중 하나 일 수있는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="090b303bdd4057540547275158d9e42939d01cec" translate="yes" xml:space="preserve">
          <source>A type that can represent owned, mutable platform-native strings, but is cheaply inter-convertible with Rust strings.</source>
          <target state="translated">소유하고 변경 가능한 플랫폼 네이티브 문자열을 나타낼 수 있지만 Rust 문자열과 저렴하게 상호 변환 할 수있는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="220ecc56d2012059c1d8cd78943adf0ed8ed7d8e" translate="yes" xml:space="preserve">
          <source>A type that is composed of other types.</source>
          <target state="translated">다른 유형으로 구성된 유형입니다.</target>
        </trans-unit>
        <trans-unit id="48dabc713e66c06bf48c0ba95cf5b1b2867095db" translate="yes" xml:space="preserve">
          <source>A type to emulate dynamic typing.</source>
          <target state="translated">동적 타이핑을 에뮬레이트하는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="18995bad7092858c6b32d35a26167b88faf2e216" translate="yes" xml:space="preserve">
          <source>A type used to conditionally initialize buffers passed to &lt;code&gt;Read&lt;/code&gt; methods.</source>
          <target state="translated">&lt;code&gt;Read&lt;/code&gt; 메서드에 전달 된 버퍼를 조건부로 초기화하는 데 사용되는 형식 입니다.</target>
        </trans-unit>
        <trans-unit id="f40b2b31a159196f4517607c9d76ab5a80f0274d" translate="yes" xml:space="preserve">
          <source>A type&amp;rsquo;s behavior consists of the methods we can call on that type. Different types share the same behavior if we can call the same methods on all of those types. Trait definitions are a way to group method signatures together to define a set of behaviors necessary to accomplish some purpose.</source>
          <target state="translated">유형의 동작은 해당 유형을 호출 할 수있는 메소드로 구성됩니다. 모든 유형에서 동일한 메소드를 호출 할 수 있으면 다른 유형이 동일한 동작을 공유합니다. 특성 정의는 몇 가지 목적을 달성하는 데 필요한 일련의 동작을 정의하기 위해 메소드 서명을 그룹화하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="3b6ddcc149faf5698a16d1a853b87785df3d76f9" translate="yes" xml:space="preserve">
          <source>A union access transmutes the content of the union to the type of the accessed field. Since transmutes can cause unexpected or undefined behaviour, &lt;code&gt;unsafe&lt;/code&gt; is required to read from a union field or to write to a field that doesn't implement &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">공용체 액세스는 공용체의 내용을 액세스 된 필드의 유형으로 변환합니다. 변환은 예기치 않은 동작이나 정의되지 않은 동작을 유발할 수 있으므로 공용 필드에서 읽거나 &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; 를&lt;/a&gt; 구현하지 않는 필드에 쓰려면 &lt;code&gt;unsafe&lt;/code&gt; 것이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="5466b2051b7ddfaa4d58e8a7c5e165f16f139371" translate="yes" xml:space="preserve">
          <source>A union declaration uses the same syntax as a struct declaration, except with &lt;code&gt;union&lt;/code&gt; in place of &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">유니온 선언 제외하고, 구조체 선언과 같은 구문을 사용하여 &lt;code&gt;union&lt;/code&gt; 대신 &lt;code&gt;struct&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca484ccd859cf11dbaf1461b26fb4e6e0c1155bd" translate="yes" xml:space="preserve">
          <source>A union declared with &lt;code&gt;#[repr(C)]&lt;/code&gt; will have the same size and alignment as an equivalent C union declaration in the C language for the target platform. The union will have a size of the maximum size of all of its fields rounded to its alignment, and an alignment of the maximum alignment of all of its fields. These maximums may come from different fields.</source>
          <target state="translated">노조는 선언 &lt;code&gt;#[repr(C)]&lt;/code&gt; 타겟 플랫폼에 대한 C 언어의 등가 C 조합 선언 같은 것 같은 크기와 정렬. 공용체는 모든 필드의 최대 크기를 정렬로 반올림하고 모든 필드의 최대 정렬을 정렬합니다. 이 최대 값은 다른 필드에서 나올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5f776fff8bd64de524df1b33719d9e03226007b" translate="yes" xml:space="preserve">
          <source>A unique identifier for a running thread.</source>
          <target state="translated">실행중인 스레드의 고유 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="10b778820b33fd4a7dd6fe5ae783d38d25f8f4be" translate="yes" xml:space="preserve">
          <source>A unit struct expression is just the path to a unit struct item. This refers to the unit struct's implicit constant of its value. The unit struct value can also be constructed with a fieldless struct expression. For example:</source>
          <target state="translated">유닛 구조체 표현식은 유닛 구조체 아이템의 경로 일뿐입니다. 이것은 단위 구조체의 값의 암시 적 상수를 나타냅니다. 단위 구조체 값은 필드없는 구조체 식으로 구성 할 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e1ccfef1f9d17695dcb29cad8794e8d363ce8a2b" translate="yes" xml:space="preserve">
          <source>A unrecognized representation attribute was used.</source>
          <target state="translated">인식 할 수없는 표현 속성이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="bb363e92161ec8a647cc462201572019f30fe79b" translate="yes" xml:space="preserve">
          <source>A vacant entry.</source>
          <target state="translated">비어있는 항목.</target>
        </trans-unit>
        <trans-unit id="ac311baab6584071250fc9bbbfdd8d2bebd0c9e9" translate="yes" xml:space="preserve">
          <source>A value in a &lt;code&gt;char&lt;/code&gt; which is a surrogate or above &lt;code&gt;char::MAX&lt;/code&gt;.</source>
          <target state="translated">A의 값 &lt;code&gt;char&lt;/code&gt; 대리 또는 이상 &lt;code&gt;char::MAX&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cd18e9d0df56f2d91218b99bcfa24832cc2e846" translate="yes" xml:space="preserve">
          <source>A value of a &lt;a href=&quot;../items/unions&quot;&gt;union&lt;/a&gt; type can also be created using this syntax, except that it must specify exactly one field.</source>
          <target state="translated">정확히 하나의 필드를 지정해야한다는 점을 제외하고이 구문을 사용하여 &lt;a href=&quot;../items/unions&quot;&gt;공용체&lt;/a&gt; 유형 의 값을 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f77849f445f82a7dac2f95551cd7b942f343391" translate="yes" xml:space="preserve">
          <source>A value of a union type can be created using the same syntax that is used for struct types, except that it must specify exactly one field:</source>
          <target state="translated">구조체 유형에 사용되는 것과 동일한 구문을 사용하여 유니온 유형의 값을 만들 수 있습니다. 단 하나의 필드 만 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="c8dd18f78fe47645f4c465046226e5bceaa87924" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;primitive.bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">논리적 &lt;strong&gt;false를&lt;/strong&gt; 나타내는 &lt;a href=&quot;primitive.bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; 유형의 값입니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5f389328467f7ba3f2c3abda8662442b712ffb60" translate="yes" xml:space="preserve">
          <source>A value of type &lt;a href=&quot;primitive.bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; representing logical &lt;strong&gt;true&lt;/strong&gt;.</source>
          <target state="translated">논리적 &lt;strong&gt;true를&lt;/strong&gt; 나타내는 &lt;a href=&quot;primitive.bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; 유형의 값입니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b855bdd2c1132135fcde425660863334401f8ec6" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;char&lt;/code&gt; is a &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;Unicode scalar value&lt;/a&gt; (i.e. a code point that is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to 0xD7FF or 0xE000 to 0x10FFFF range. A &lt;code&gt;[char]&lt;/code&gt; is effectively a UCS-4 / UTF-32 string.</source>
          <target state="translated">입력 값 &lt;code&gt;char&lt;/code&gt; A는 &lt;a href=&quot;http://www.unicode.org/glossary/#unicode_scalar_value&quot;&gt;유니 스칼라 값&lt;/a&gt; 0x10FFFF 범위 0xD7FF 또는 0xE000 행 0000의 32 비트 부호 워드로 표현 (대리없는 즉 코드 포인트). &lt;code&gt;[char]&lt;/code&gt; 효과적으로 UCS-4 / UTF-32 문자열이다.</target>
        </trans-unit>
        <trans-unit id="59d76a5d3d80327c3f37cdc56ddfd9ab850292ae" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;str&lt;/code&gt; is a Unicode string, represented as an array of 8-bit unsigned bytes holding a sequence of UTF-8 code points. Since &lt;code&gt;str&lt;/code&gt; is a &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized type&lt;/a&gt;, it is not a &lt;em&gt;first-class&lt;/em&gt; type, but can only be instantiated through a pointer type, such as &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 유형의 값은 UTF-8 코드 포인트 시퀀스를 보유하는 8 비트 부호없는 바이트의 배열로 표시되는 유니 코드 문자열입니다. 이후 &lt;code&gt;str&lt;/code&gt; A는 &lt;a href=&quot;../dynamically-sized-types&quot;&gt;동적으로 크기 유형&lt;/a&gt; , 그것은 아닙니다 &lt;em&gt;일류&lt;/em&gt; 유형,하지만 같은 포인터 타입을 통해 인스턴스화 할 수 &lt;code&gt;&amp;amp;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a63b20136e367659035b6e689b2afe4c29bd6017" translate="yes" xml:space="preserve">
          <source>A value other than &lt;code&gt;false&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt;) or &lt;code&gt;true&lt;/code&gt; (&lt;code&gt;1&lt;/code&gt;) in a &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 에서 &lt;code&gt;false&lt;/code&gt; ( &lt;code&gt;0&lt;/code&gt; ) 또는 &lt;code&gt;true&lt;/code&gt; ( &lt;code&gt;1&lt;/code&gt; ) 이외의 값 입니다.</target>
        </trans-unit>
        <trans-unit id="b4cba545fd19cda1128ffaf1d3286b9b7d56cde6" translate="yes" xml:space="preserve">
          <source>A value was moved out of a non-copy fixed-size array.</source>
          <target state="translated">복사가 아닌 고정 크기 배열에서 값이 이동되었습니다.</target>
        </trans-unit>
        <trans-unit id="b42cffab7e9c15b342f66d8f5259941653a63c96" translate="yes" xml:space="preserve">
          <source>A value was moved out while it was still borrowed.</source>
          <target state="translated">아직 빌린 동안 가치가 옮겨졌습니다.</target>
        </trans-unit>
        <trans-unit id="9706341e2da60c066ce6e7cf05178b38f120d103" translate="yes" xml:space="preserve">
          <source>A value was moved. However, its size was not known at compile time, and only values of a known size can be moved.</source>
          <target state="translated">값이 이동되었습니다. 그러나 크기는 컴파일 타임에 알려지지 않았으며 알려진 크기의 값만 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44837e659d57e9e8963db42f2a8ff432184c868b" translate="yes" xml:space="preserve">
          <source>A value was used after it was mutably borrowed.</source>
          <target state="translated">변경 가능하게 빌린 후에 값이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="ce9baf105eb065b4e2e707a1c70964d52846271c" translate="yes" xml:space="preserve">
          <source>A value, once pinned, must remain pinned forever (unless its type implements &lt;code&gt;Unpin&lt;/code&gt;).</source>
          <target state="translated">고정 된 값은 해당 유형이 &lt;code&gt;Unpin&lt;/code&gt; 을 구현하지 않는 한 영구적으로 고정 된 상태를 유지해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f834afc88c6404de279c7c8f515cfb4300b16ac9" translate="yes" xml:space="preserve">
          <source>A value-to-value conversion that consumes the input value. The opposite of &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">입력 값을 사용하는 값-값 변환입니다. &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="e13d6f0eba74b4bdfc6f5572578b32920b145941" translate="yes" xml:space="preserve">
          <source>A variable is initialized if it has been assigned a value and hasn't since been moved from. All other memory locations are assumed to be uninitialized. Only unsafe Rust can create such a memory without initializing it.</source>
          <target state="translated">변수에 값이 할당되었고 그 이후로 이동하지 않은 경우 변수가 초기화됩니다. 다른 모든 메모리 위치는 초기화되지 않은 것으로 가정합니다. 안전하지 않은 Rust만이 메모리를 초기화하지 않고 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d671f0302da4834f34c2a582f5308578a61da28e" translate="yes" xml:space="preserve">
          <source>A variable was borrowed as mutable more than once. Erroneous code example:</source>
          <target state="translated">변수가 두 번 이상 변경 가능하도록 빌 렸습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="179ae2668e7ec007982c4f5de54552aaba759982" translate="yes" xml:space="preserve">
          <source>A very common source of input is standard input:</source>
          <target state="translated">매우 일반적인 입력 소스는 표준 입력입니다.</target>
        </trans-unit>
        <trans-unit id="8fd033d78acbcd4754d1027990e8d5a9b9826bd0" translate="yes" xml:space="preserve">
          <source>A very simple implementation of a &lt;code&gt;Balance&lt;/code&gt; struct that has two sides, where each can be indexed mutably and immutably.</source>
          <target state="translated">두 개의 측면을 갖는 &lt;code&gt;Balance&lt;/code&gt; 구조체 의 매우 간단한 구현으로, 각면은 변경 가능하고 불변으로 인덱싱 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97a780f793593419e0ff592febcf6977a93355f0" translate="yes" xml:space="preserve">
          <source>A view into a single entry in a map, which may either be vacant or occupied.</source>
          <target state="translated">비어 있거나 점유 될 수있는 맵의 단일 항목에 대한 뷰입니다.</target>
        </trans-unit>
        <trans-unit id="8b25993b294c4224a4cf2b72c86b09f4a1df51e2" translate="yes" xml:space="preserve">
          <source>A view into a vacant entry in a &lt;code&gt;BTreeMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">A의 빈 항목에 대한 전망 &lt;code&gt;BTreeMap&lt;/code&gt; . &lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt; 열거 형의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="7403429e7fd780dc27d8a13d9952581d4b4e445e" translate="yes" xml:space="preserve">
          <source>A view into a vacant entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">A의 빈 항목에 대한 전망 &lt;code&gt;HashMap&lt;/code&gt; . &lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt; 열거 형의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="e122826d4e223005f70614b786e8ddc75140b027" translate="yes" xml:space="preserve">
          <source>A view into a vacant entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.rawentrymut&quot;&gt;&lt;code&gt;RawEntryMut&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">A의 빈 항목에 대한 전망 &lt;code&gt;HashMap&lt;/code&gt; . &lt;a href=&quot;enum.rawentrymut&quot;&gt; &lt;code&gt;RawEntryMut&lt;/code&gt; &lt;/a&gt; 열거 형의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="ce99b5e5cd3ea34b7d4c0f89a8831922c382a6d4" translate="yes" xml:space="preserve">
          <source>A view into an occupied entry in a &lt;code&gt;BTreeMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">A의 점령 항목에 대한 전망 &lt;code&gt;BTreeMap&lt;/code&gt; . &lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt; 열거 형의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="be269036f18f5f092608a130f8ea68df4394d390" translate="yes" xml:space="preserve">
          <source>A view into an occupied entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.entry&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">A의 점령 항목에 대한 전망 &lt;code&gt;HashMap&lt;/code&gt; . &lt;a href=&quot;enum.entry&quot;&gt; &lt;code&gt;Entry&lt;/code&gt; &lt;/a&gt; 열거 형의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="097a52eaa6538170318bb496b2404a2534b2fc4c" translate="yes" xml:space="preserve">
          <source>A view into an occupied entry in a &lt;code&gt;HashMap&lt;/code&gt;. It is part of the &lt;a href=&quot;enum.rawentrymut&quot;&gt;&lt;code&gt;RawEntryMut&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="translated">A의 점령 항목에 대한 전망 &lt;code&gt;HashMap&lt;/code&gt; . &lt;a href=&quot;enum.rawentrymut&quot;&gt; &lt;code&gt;RawEntryMut&lt;/code&gt; &lt;/a&gt; 열거 형의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="1dcb56819c21811e53111728b70cf9c4d536f34f" translate="yes" xml:space="preserve">
          <source>A virtual function pointer table (vtable) that specifies the behavior of a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt; 의 동작을 지정하는 가상 함수 포인터 테이블 (vtable)입니다 .</target>
        </trans-unit>
        <trans-unit id="ac7d35f82dab2d813057ea592ffddd469b64e834" translate="yes" xml:space="preserve">
          <source>A visibility qualifier was used when it was unnecessary. Erroneous code examples:</source>
          <target state="translated">불필요 할 때 가시성 한정자가 사용되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="b3fc7b3827a6fcc8a59a000c786e3c02a55a53ac" translate="yes" xml:space="preserve">
          <source>A while-let pattern attempts to match the pattern, and enters the body if the match was successful. If the match is irrefutable (when it cannot fail to match), use a regular &lt;code&gt;let&lt;/code&gt;-binding inside a &lt;code&gt;loop&lt;/code&gt; instead. For instance:</source>
          <target state="translated">while-let 패턴은 패턴과 일치하려고 시도하고 일치하면 본문에 들어갑니다. 일치 할 수없는 경우 (일치 할 수없는 경우) 대신 &lt;code&gt;loop&lt;/code&gt; 내에서 규칙적인 &lt;code&gt;let&lt;/code&gt; - binding을 사용하십시오. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="fc142166b026c4503335a66425ed02745d313757" translate="yes" xml:space="preserve">
          <source>A workaround for this problem is to wrap the trait up in a struct, and implement Drop on that. An example is shown below:</source>
          <target state="translated">이 문제에 대한 해결 방법은 구조체에서 특성을 마무리하고 Drop을 구현하는 것입니다. 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2126e0b1e41989d782fb5cb045faec8bb5419d59" translate="yes" xml:space="preserve">
          <source>A working version would be:</source>
          <target state="translated">작동하는 버전은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0d662f80f6ce134ee94f8241854c8eb7d0a73167" translate="yes" xml:space="preserve">
          <source>A wrapper for a &lt;code&gt;va_list&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;va_list&lt;/code&gt; 의 래퍼</target>
        </trans-unit>
        <trans-unit id="b7d2953f481ad207e80e2b4f3ea38a3fc7fdbf37" translate="yes" xml:space="preserve">
          <source>A wrapper to inhibit compiler from automatically calling &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s destructor.</source>
          <target state="translated">컴파일러가 &lt;code&gt;T&lt;/code&gt; 의 소멸자 를 자동으로 호출하지 못하게하는 래퍼 입니다.</target>
        </trans-unit>
        <trans-unit id="27e603a9954cbc24a31a5ec5bf12ad7cbfb65091" translate="yes" xml:space="preserve">
          <source>A wrapper type for a mutably borrowed value from a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 에서 차용 한 값의 래퍼 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="76e573ae156cec07995313b0af472777485c1ac4" translate="yes" xml:space="preserve">
          <source>A wrapper type to construct uninitialized instances of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">초기화되지 않은 &lt;code&gt;T&lt;/code&gt; 인스턴스를 생성하는 래퍼 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="4e4e6894ffe01981313c8a0bdd641986bcbb13e0" translate="yes" xml:space="preserve">
          <source>A writer which will move data into the void.</source>
          <target state="translated">데이터를 빈 공간으로 이동시키는 라이터.</target>
        </trans-unit>
        <trans-unit id="3c1aa63d0f65966b349901d79576dfb3a03d713a" translate="yes" xml:space="preserve">
          <source>A yank &lt;em&gt;does not&lt;/em&gt; delete any code. For example, the yank feature is not intended for deleting accidentally uploaded secrets. If that happens, you must reset those secrets immediately.</source>
          <target state="translated">yank &lt;em&gt;는&lt;/em&gt; 코드를 삭제 &lt;em&gt;하지 않습니다&lt;/em&gt; . 예를 들어, yank 기능은 실수로 업로드 한 비밀을 삭제하기위한 것이 아닙니다. 이 경우 해당 비밀을 즉시 재설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="441d954d4dd0146ecde4bbe0bfe1d8d54e840f8a" translate="yes" xml:space="preserve">
          <source>ABI</source>
          <target state="translated">ABI</target>
        </trans-unit>
        <trans-unit id="f7f4dbec39b0ff3d85b8eb96500c85b0c6447c9c" translate="yes" xml:space="preserve">
          <source>ABI, linking, symbols, and FFI</source>
          <target state="translated">ABI, 링크, 심볼 및 FFI</target>
        </trans-unit>
        <trans-unit id="623cb147c595ee00f55c9bfbece2fd89256c0ca0" translate="yes" xml:space="preserve">
          <source>ARCH</source>
          <target state="translated">ARCH</target>
        </trans-unit>
        <trans-unit id="ebb42dcc0b64c9c253b3563c217764b64d93cc3b" translate="yes" xml:space="preserve">
          <source>ARM platforms like &lt;code&gt;armv5te&lt;/code&gt; that aren't for Linux do not have any atomics at all.</source>
          <target state="translated">Linux 용이 아닌 &lt;code&gt;armv5te&lt;/code&gt; 와 같은 ARM 플랫폼에는 원자가 전혀 없습니다.</target>
        </trans-unit>
        <trans-unit id="5d8a36ef8e4b107d52ef5f736828e510925b8177" translate="yes" xml:space="preserve">
          <source>ARM targets with &lt;code&gt;thumbv6m&lt;/code&gt; do not have atomic operations at all.</source>
          <target state="translated">&lt;code&gt;thumbv6m&lt;/code&gt; 이있는 ARM 대상에는 전혀 원자 연산이 없습니다.</target>
        </trans-unit>
        <trans-unit id="bb0279d84c9ab08002a8ea7634cd21f2283a6099" translate="yes" xml:space="preserve">
          <source>ASCII :</source>
          <target state="translated">ASCII :</target>
        </trans-unit>
        <trans-unit id="317e8901215d42ccc7940d34b4ce9490884463f7" translate="yes" xml:space="preserve">
          <source>ASCII byte literal</source>
          <target state="translated">ASCII 바이트 리터럴</target>
        </trans-unit>
        <trans-unit id="4d8ae89e872f4c2b2dd8feb9252c9a119be50b1e" translate="yes" xml:space="preserve">
          <source>ASCII escapes</source>
          <target state="translated">ASCII 이스케이프</target>
        </trans-unit>
        <trans-unit id="ca370d4b69baa6a205bc27d7c92d683f7ec62f70" translate="yes" xml:space="preserve">
          <source>ASCII letters 'A' to 'Z' are mapped to 'a' to 'z', but non-ASCII letters are unchanged.</source>
          <target state="translated">ASCII 문자 'A'~ 'Z'는 'a'~ 'z'에 매핑되지만 비 ASCII 문자는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2e3db4ca30bac04610a9ba330ec0d3d5c61cf4d8" translate="yes" xml:space="preserve">
          <source>ASCII letters 'a' to 'z' are mapped to 'A' to 'Z', but non-ASCII letters are unchanged.</source>
          <target state="translated">ASCII 문자 'a'에서 'z'는 'A'에서 'Z'로 매핑되지만 ASCII가 아닌 문자는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="958cc1148f8aff5543459cc62e998e9d661990e7" translate="yes" xml:space="preserve">
          <source>ASCII_ESCAPE :</source>
          <target state="translated">ASCII_ESCAPE :</target>
        </trans-unit>
        <trans-unit id="8d6c4817508ef1c56c15761069329bc78c08e97c" translate="yes" xml:space="preserve">
          <source>ASCII_FOR_CHAR :</source>
          <target state="translated">ASCII_FOR_CHAR :</target>
        </trans-unit>
        <trans-unit id="1e976fbca3f1cd1471746ec2b3ff6a7a5d15936f" translate="yes" xml:space="preserve">
          <source>ASCII_FOR_STRING :</source>
          <target state="translated">ASCII_FOR_STRING :</target>
        </trans-unit>
        <trans-unit id="b6453d9f657d21e7c289076ce98028e47dc7282d" translate="yes" xml:space="preserve">
          <source>ATOMIC_BOOL_INIT</source>
          <target state="translated">ATOMIC_BOOL_INIT</target>
        </trans-unit>
        <trans-unit id="2b9c513ccbb146434eeb5bd6802254d3e9319214" translate="yes" xml:space="preserve">
          <source>ATOMIC_I16_INIT</source>
          <target state="translated">ATOMIC_I16_INIT</target>
        </trans-unit>
        <trans-unit id="6eacbfe2c8c788ffc6b7a2bdbffc94fa45c82d1a" translate="yes" xml:space="preserve">
          <source>ATOMIC_I32_INIT</source>
          <target state="translated">ATOMIC_I32_INIT</target>
        </trans-unit>
        <trans-unit id="66f562d6648e128b70300462dcad7b8fc4608b4d" translate="yes" xml:space="preserve">
          <source>ATOMIC_I64_INIT</source>
          <target state="translated">ATOMIC_I64_INIT</target>
        </trans-unit>
        <trans-unit id="3fed299eb934560d34d135ac41857a8fb36ef0bf" translate="yes" xml:space="preserve">
          <source>ATOMIC_I8_INIT</source>
          <target state="translated">ATOMIC_I8_INIT</target>
        </trans-unit>
        <trans-unit id="bdb0440ba3e33135f2c764f4348aac2801df19e3" translate="yes" xml:space="preserve">
          <source>ATOMIC_ISIZE_INIT</source>
          <target state="translated">ATOMIC_ISIZE_INIT</target>
        </trans-unit>
        <trans-unit id="8666b79dcee9e5c85aa6e1517921389330c7bb56" translate="yes" xml:space="preserve">
          <source>ATOMIC_U16_INIT</source>
          <target state="translated">ATOMIC_U16_INIT</target>
        </trans-unit>
        <trans-unit id="5463cfe71666bd3cbb7e7bd93e1dea5283405daf" translate="yes" xml:space="preserve">
          <source>ATOMIC_U32_INIT</source>
          <target state="translated">ATOMIC_U32_INIT</target>
        </trans-unit>
        <trans-unit id="fee37bb8c4ae8ff95ead7263aeefbf92f4fb076f" translate="yes" xml:space="preserve">
          <source>ATOMIC_U64_INIT</source>
          <target state="translated">ATOMIC_U64_INIT</target>
        </trans-unit>
        <trans-unit id="b5fd0a39697ab3a5f13871b24404fa76ef7723d2" translate="yes" xml:space="preserve">
          <source>ATOMIC_U8_INIT</source>
          <target state="translated">ATOMIC_U8_INIT</target>
        </trans-unit>
        <trans-unit id="b775de59887a198b8bb80812de87ea9a271a97f2" translate="yes" xml:space="preserve">
          <source>ATOMIC_USIZE_INIT</source>
          <target state="translated">ATOMIC_USIZE_INIT</target>
        </trans-unit>
        <trans-unit id="931aa76f7d621b2bd9a484f56b5e9a93cf07c3f7" translate="yes" xml:space="preserve">
          <source>Abort on memory allocation error or failure.</source>
          <target state="translated">메모리 할당 오류 또는 실패시 중단하십시오.</target>
        </trans-unit>
        <trans-unit id="df06ef34b8240a09fa9f161ea99137607ac00a56" translate="yes" xml:space="preserve">
          <source>Aborts the execution of the process.</source>
          <target state="translated">프로세스 실행을 중단합니다.</target>
        </trans-unit>
        <trans-unit id="b619665e057a59c1a1dbdf52957bcc9212748104" translate="yes" xml:space="preserve">
          <source>Abstract return types</source>
          <target state="translated">추상 반환 유형</target>
        </trans-unit>
        <trans-unit id="db7472b4d6bc69237c01f48a8b625cef374de6c1" translate="yes" xml:space="preserve">
          <source>Abstract return types (written &lt;code&gt;impl Trait&lt;/code&gt; for some trait &lt;code&gt;Trait&lt;/code&gt;) are only allowed as function and inherent impl return types.</source>
          <target state="translated">(작성 추상 반환 형식 &lt;code&gt;impl Trait&lt;/code&gt; 일부 특성에 대한 &lt;code&gt;Trait&lt;/code&gt; ) 단지 기능과 고유 IMPL 반환 유형으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdd7aedb4bc31655563e1852b48c298d5ec5570e" translate="yes" xml:space="preserve">
          <source>Abstract syntax tree</source>
          <target state="translated">추상 구문 트리</target>
        </trans-unit>
        <trans-unit id="8a308b160b478c6d80c833cea5942381a0eb8138" translate="yes" xml:space="preserve">
          <source>Accept a new incoming connection from this listener.</source>
          <target state="translated">이 리스너로부터 새로운 수신 연결을 수락하십시오.</target>
        </trans-unit>
        <trans-unit id="9d161ad935c554382c0d645c53e65dd6566a4bb5" translate="yes" xml:space="preserve">
          <source>Accepting Command Line Arguments</source>
          <target state="translated">명령 줄 인수 수락</target>
        </trans-unit>
        <trans-unit id="5c44c9a8bf41c1458082624764926e9e452b0f9a" translate="yes" xml:space="preserve">
          <source>Accepts &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;enum.ordering#variant.AcqRel&quot;&gt;&lt;code&gt;AcqRel&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt;&lt;code&gt;SeqCst&lt;/code&gt;&lt;/a&gt; orderings.</source>
          <target state="translated">&lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;enum.ordering#variant.AcqRel&quot;&gt; &lt;code&gt;AcqRel&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;enum.ordering#variant.SeqCst&quot;&gt; &lt;code&gt;SeqCst&lt;/code&gt; &lt;/a&gt; 주문을 수락합니다 .</target>
        </trans-unit>
        <trans-unit id="a053fb66cacbf9febf839206d8e07b27aeeb3488" translate="yes" xml:space="preserve">
          <source>Accepts a new incoming connection to this listener.</source>
          <target state="translated">이 리스너에 대한 새로운 수신 연결을 승인합니다.</target>
        </trans-unit>
        <trans-unit id="41aadfd41c1a6581a617dbde4d22fdb01baa3e91" translate="yes" xml:space="preserve">
          <source>Access an entry by a key and its hash.</source>
          <target state="translated">키와 해시로 항목에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="51a3abe326b3c0792015c0e4fe719586def474a7" translate="yes" xml:space="preserve">
          <source>Access an entry by hash.</source>
          <target state="translated">해시로 항목에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="fab65c5f7333ea79c15d33939860036f46df2b02" translate="yes" xml:space="preserve">
          <source>Access an entry by key.</source>
          <target state="translated">키로 항목에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="f8d8572e08e06ee9c752f760cd0d14aa8e2826f1" translate="yes" xml:space="preserve">
          <source>Access fields in a packed struct:</source>
          <target state="translated">패킹 된 구조체의 필드에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="9ea16fa6ced966020c4bffbd61fb4353757d0cf8" translate="yes" xml:space="preserve">
          <source>Access members of a packed struct by reference:</source>
          <target state="translated">패킹 된 구조체의 멤버에 참조로 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="8b8e97faa7739e19473f47e07608526221b515e7" translate="yes" xml:space="preserve">
          <source>Access or modify a mutable static variable</source>
          <target state="translated">변경 가능한 정적 변수 액세스 또는 수정</target>
        </trans-unit>
        <trans-unit id="cd54de93b3358e522ad1a3c574f8befd63e8ca75" translate="yes" xml:space="preserve">
          <source>Access the underlying UTF-8 error that was the cause of this error.</source>
          <target state="translated">이 오류의 원인이 된 기본 UTF-8 오류에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="46164e9a717820065d93ac43f40d916b0e4e7553" translate="yes" xml:space="preserve">
          <source>AccessError</source>
          <target state="translated">AccessError</target>
        </trans-unit>
        <trans-unit id="ce24154072e2c91b2d63af9c452a4cc41adea723" translate="yes" xml:space="preserve">
          <source>AccessError::borrow</source>
          <target state="translated">AccessError::borrow</target>
        </trans-unit>
        <trans-unit id="0cc742fcaecb2fa19742b5bc67e762feaa6f37c0" translate="yes" xml:space="preserve">
          <source>AccessError::borrow_mut</source>
          <target state="translated">AccessError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="a94e2b3363d2d1a8ced8c51a5e15ff4f96e5bb39" translate="yes" xml:space="preserve">
          <source>AccessError::fmt</source>
          <target state="translated">AccessError::fmt</target>
        </trans-unit>
        <trans-unit id="2c2380ad9f60011344ab503262723a632ed3c1d2" translate="yes" xml:space="preserve">
          <source>AccessError::from</source>
          <target state="translated">AccessError::from</target>
        </trans-unit>
        <trans-unit id="7621469337a4b2f74d2a377616bccd38326a7edd" translate="yes" xml:space="preserve">
          <source>AccessError::into</source>
          <target state="translated">AccessError::into</target>
        </trans-unit>
        <trans-unit id="57d0ff4e6d1785ba4d9a1781d3047ed655772b49" translate="yes" xml:space="preserve">
          <source>AccessError::to_string</source>
          <target state="translated">AccessError::to_string</target>
        </trans-unit>
        <trans-unit id="c9ce68542ae4f2f8f818a2b5731ce826d35da932" translate="yes" xml:space="preserve">
          <source>AccessError::try_from</source>
          <target state="translated">AccessError::try_from</target>
        </trans-unit>
        <trans-unit id="cbc880d00714a36a28ddfefa1107fb401f040376" translate="yes" xml:space="preserve">
          <source>AccessError::try_into</source>
          <target state="translated">AccessError::try_into</target>
        </trans-unit>
        <trans-unit id="f18106e890f07e143593c942859c5df6ac97bdb0" translate="yes" xml:space="preserve">
          <source>AccessError::type_id</source>
          <target state="translated">AccessError::type_id</target>
        </trans-unit>
        <trans-unit id="6260b03bb183bb1a54da2dc8ffad6ed6483c869e" translate="yes" xml:space="preserve">
          <source>Accessing Array Elements</source>
          <target state="translated">배열 요소에 액세스</target>
        </trans-unit>
        <trans-unit id="6a8c72aa13ec7be5fc27578400a1a226881f478c" translate="yes" xml:space="preserve">
          <source>Accessing Values in a Hash Map</source>
          <target state="translated">해시 맵에서 값에 액세스</target>
        </trans-unit>
        <trans-unit id="b06fec963d87626314583ae2b00b8c48fde3efce" translate="yes" xml:space="preserve">
          <source>Accessing a field of a &lt;a href=&quot;items/unions&quot;&gt;&lt;code&gt;union&lt;/code&gt;&lt;/a&gt;, other than to assign to it.</source>
          <target state="translated">할당 이외 의 &lt;a href=&quot;items/unions&quot;&gt; &lt;code&gt;union&lt;/code&gt; &lt;/a&gt; 필드 액세스</target>
        </trans-unit>
        <trans-unit id="a0cd0bd48f335ea136bd217d77f1a368ccbcee58" translate="yes" xml:space="preserve">
          <source>Accessing adjacent &lt;code&gt;u8&lt;/code&gt; as &lt;code&gt;u16&lt;/code&gt;</source>
          <target state="translated">인접 액세스 &lt;code&gt;u8&lt;/code&gt; 같은 &lt;code&gt;u16&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f91f22939adae86de60c33d3fdb16972e0fb724" translate="yes" xml:space="preserve">
          <source>Accessing data in the heap is slower than accessing data on the stack because you have to follow a pointer to get there. Contemporary processors are faster if they jump around less in memory. Continuing the analogy, consider a server at a restaurant taking orders from many tables. It&amp;rsquo;s most efficient to get all the orders at one table before moving on to the next table. Taking an order from table A, then an order from table B, then one from A again, and then one from B again would be a much slower process. By the same token, a processor can do its job better if it works on data that&amp;rsquo;s close to other data (as it is on the stack) rather than farther away (as it can be on the heap). Allocating a large amount of space on the heap can also take time.</source>
          <target state="translated">힙에있는 데이터에 액세스하려면 포인터를 따라 가야하므로 스택의 데이터에 액세스하는 것보다 속도가 느립니다. 메모리가 적을수록 최신 프로세서가 더 빠릅니다. 유추를 계속하면서 식당의 서버에서 많은 테이블의 주문을 고려하십시오. 다음 테이블로 넘어 가기 전에 한 테이블에서 모든 주문을받는 것이 가장 효율적입니다. 테이블 A에서 주문을 가져온 다음 테이블 B에서 주문을 가져온 다음 A에서 다시 한 번 주문한 다음 B에서 다시 한 번 주문하면 훨씬 느려집니다. 같은 방식으로 프로세서는 스택에있는 것처럼 다른 데이터에 가까운 데이터 (더 많은 힙에있을 수 있음)가 아닌 다른 데이터에 대해 작동하는 경우 더 잘 작업 할 수 있습니다. 힙에 많은 공간을 할당하는 데에도 시간이 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c20e5fc2ccd1b37aea7b882c463d596e55833b83" translate="yes" xml:space="preserve">
          <source>Accessing or Modifying a Mutable Static Variable</source>
          <target state="translated">가변 정적 변수 액세스 또는 수정</target>
        </trans-unit>
        <trans-unit id="12a3a4f498b28cbec01c44aacf0dc5e3a1b828ef" translate="yes" xml:space="preserve">
          <source>Accuracy</source>
          <target state="translated">Accuracy</target>
        </trans-unit>
        <trans-unit id="edc1ea5ed2dafd896f3493beb6ccad4cc0bfdeb7" translate="yes" xml:space="preserve">
          <source>Accurately documenting your packages will help other users know how and when to use them, so it&amp;rsquo;s worth investing the time to write documentation. In Chapter 3, we discussed how to comment Rust code using two slashes, &lt;code&gt;//&lt;/code&gt;. Rust also has a particular kind of comment for documentation, known conveniently as a &lt;em&gt;documentation comment&lt;/em&gt;, that will generate HTML documentation. The HTML displays the contents of documentation comments for public API items intended for programmers interested in knowing how to &lt;em&gt;use&lt;/em&gt; your crate as opposed to how your crate is &lt;em&gt;implemented&lt;/em&gt;.</source>
          <target state="translated">패키지를 정확하게 문서화하면 다른 사용자가 언제 어떻게 사용해야하는지 알 수 있으므로 문서를 작성하는 데 시간을 투자하는 것이 좋습니다. 3 장에서 두 개의 슬래시 ( &lt;code&gt;//&lt;/code&gt; 사용하여 Rust 코드를 주석 처리하는 방법에 대해 설명했습니다 . Rust는 HTML 문서를 생성 하는 &lt;em&gt;문서 주석&lt;/em&gt; 으로 편리하게 알려진 문서에 대한 특정 종류의 주석도 가지고 있습니다. HTML 은 크레이트가 &lt;em&gt;구현&lt;/em&gt; 되는 방식과 달리 크레이트 를 &lt;em&gt;사용&lt;/em&gt; 하는 방법을 알고 자하는 프로그래머를위한 공개 API 항목에 대한 문서 주석의 내용을 표시합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6568c1be017add88e3d012e02f41ac58f3e66045" translate="yes" xml:space="preserve">
          <source>Acquire - a barrier for acquiring a lock. Subsequent reads and writes take place after the barrier.</source>
          <target state="translated">획득-잠금 획득 장벽. 후속 읽기 및 쓰기는 장벽 이후에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="af0f8ed1129c9ddf2134ed1c81b67a9bcb444f5a" translate="yes" xml:space="preserve">
          <source>Acquires a mutable reference to the owned form of the data.</source>
          <target state="translated">소유 한 데이터 형식에 대한 변경 가능한 참조를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="ff3bc67bc303cd10ada41c07bb7edfd939dc9318" translate="yes" xml:space="preserve">
          <source>Acquires a mutex, blocking the current thread until it is able to do so.</source>
          <target state="translated">현재 스레드를 차단할 수있을 때까지 뮤텍스를 획득합니다.</target>
        </trans-unit>
        <trans-unit id="220a887115abad65ad7317817bfb97307bde3f84" translate="yes" xml:space="preserve">
          <source>Acquires a reference to the value in this TLS key.</source>
          <target state="translated">이 TLS 키의 값에 대한 참조를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="b36ce9a1808b77b91f2783ae64622ebad2a9cac9" translate="yes" xml:space="preserve">
          <source>Acquires the underlying &lt;code&gt;*mut&lt;/code&gt; pointer.</source>
          <target state="translated">기본 &lt;code&gt;*mut&lt;/code&gt; 포인터를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="d4158950a66bbaeb08dff05a2933261e57fba1be" translate="yes" xml:space="preserve">
          <source>Acquiring the path of the current executable is a platform-specific operation that can fail for a good number of reasons. Some errors can include, but not be limited to, filesystem operations failing or general syscall failures.</source>
          <target state="translated">현재 실행 파일의 경로를 얻는 것은 여러 가지 이유로 실패 할 수있는 플랫폼 별 작업입니다. 일부 오류에는 파일 시스템 조작 실패 또는 일반 syscall 실패가 포함되지만 이에 국한되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="6d8f12c840c97a885d954c4ab3f89cfe39b2655d" translate="yes" xml:space="preserve">
          <source>Active and inert attributes</source>
          <target state="translated">활성 및 비활성 속성</target>
        </trans-unit>
        <trans-unit id="e07a4acdd5cdd3ab645fd0d90270662d13ac1718" translate="yes" xml:space="preserve">
          <source>Adapters</source>
          <target state="translated">Adapters</target>
        </trans-unit>
        <trans-unit id="876182ad9012a6c08f789f1f68ad82ee5e8c99b7" translate="yes" xml:space="preserve">
          <source>Adaptor to chain together two readers.</source>
          <target state="translated">두 리더를 연결하는 어댑터.</target>
        </trans-unit>
        <trans-unit id="61cc55aa0453184734c3fa0b621eda6fa874bd83" translate="yes" xml:space="preserve">
          <source>Add</source>
          <target state="translated">Add</target>
        </trans-unit>
        <trans-unit id="ca240252f7070cde72a7b776f50be32f04f2fc0d" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;reject&lt;/code&gt; method that changes the post&amp;rsquo;s state from &lt;code&gt;PendingReview&lt;/code&gt; back to &lt;code&gt;Draft&lt;/code&gt;.</source>
          <target state="translated">게시물 상태를 &lt;code&gt;PendingReview&lt;/code&gt; 에서 &lt;code&gt;Draft&lt;/code&gt; 로 다시 변경 하는 &lt;code&gt;reject&lt;/code&gt; 메소드를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="a0a1e3ef1e8493d789dbbf3d73ecb2a795cba8db" translate="yes" xml:space="preserve">
          <source>Add a description that is just a sentence or two, because it will appear with your crate in search results. For the &lt;code&gt;license&lt;/code&gt; field, you need to give a &lt;em&gt;license identifier value&lt;/em&gt;. The &lt;a href=&quot;http://spdx.org/licenses/&quot;&gt;Linux Foundation&amp;rsquo;s Software Package Data Exchange (SPDX)&lt;/a&gt; lists the identifiers you can use for this value. For example, to specify that you&amp;rsquo;ve licensed your crate using the MIT License, add the &lt;code&gt;MIT&lt;/code&gt; identifier:</source>
          <target state="translated">검색 결과에 상자와 함께 표시되므로 한두 문장으로 된 설명을 추가하십시오. 를 들어 &lt;code&gt;license&lt;/code&gt; 필드, 당신은 줄 필요가 &lt;em&gt;라이센스 식별자 값을&lt;/em&gt; . &lt;a href=&quot;http://spdx.org/licenses/&quot;&gt;리눅스 재단의 소프트웨어 패키지 데이터 교환 (SPDX)는&lt;/a&gt; 이 값에 사용할 수있는 식별자를 나열합니다. 예를 들어, MIT 라이센스를 사용하여 상자에 라이센스를 부여하도록 지정하려면 &lt;code&gt;MIT&lt;/code&gt; 식별자를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="c8594387539a0f2f7158c8875d4643cbc796d8e9" translate="yes" xml:space="preserve">
          <source>Add a getter function:</source>
          <target state="translated">게터 함수를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="c563aa838f46cc2ef90bbf765435b526485acbf0" translate="yes" xml:space="preserve">
          <source>Add constraints that must be upheld to use an item.</source>
          <target state="translated">아이템을 사용하기 위해 지켜야하는 제약 조건을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="32aaebe9976898d3881c1a85d7d471c975e08486" translate="yes" xml:space="preserve">
          <source>Add more documentation to &lt;code&gt;ThreadPool&lt;/code&gt; and its public methods.</source>
          <target state="translated">&lt;code&gt;ThreadPool&lt;/code&gt; 및 공용 메소드에 더 많은 문서를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="eac54db7026ed63754bb1e0481266ad4560b6f6c" translate="yes" xml:space="preserve">
          <source>Add tests of the library&amp;rsquo;s functionality.</source>
          <target state="translated">라이브러리 기능 테스트를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="584510db3cf556aee671c49783907c6c03f2abe4" translate="yes" xml:space="preserve">
          <source>Add the size of the field.</source>
          <target state="translated">필드의 크기를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="e0ef2ba9581371a273c725b4584816d08df6e970" translate="yes" xml:space="preserve">
          <source>Add::add</source>
          <target state="translated">Add::add</target>
        </trans-unit>
        <trans-unit id="bd166591010a18220168b51497b0b5e84b157433" translate="yes" xml:space="preserve">
          <source>AddAssign</source>
          <target state="translated">AddAssign</target>
        </trans-unit>
        <trans-unit id="6eecef84103332763bac0f11d9776217926be6a9" translate="yes" xml:space="preserve">
          <source>AddAssign::add_assign</source>
          <target state="translated">AddAssign::add_assign</target>
        </trans-unit>
        <trans-unit id="47bc308a358cb72c871f66d0703a1751fa8c3e13" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;rand&lt;/code&gt; as a dependency in &lt;em&gt;Cargo.toml&lt;/em&gt; tells Cargo to download the &lt;code&gt;rand&lt;/code&gt; package and any dependencies from &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; and make &lt;code&gt;rand&lt;/code&gt; available to our project.</source>
          <target state="translated">추가 &lt;code&gt;rand&lt;/code&gt; 에서 종속성으로 &lt;em&gt;Cargo.toml가&lt;/em&gt; 다운로드하는화물을 말한다 &lt;code&gt;rand&lt;/code&gt; 패키지에서 종속성 &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io을&lt;/a&gt; 하고 만들 &lt;code&gt;rand&lt;/code&gt; 우리의 프로젝트에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6951b086bf1e29a4acfdba85666aa713fe81534c" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;use&lt;/code&gt; and a path in a scope is similar to creating a symbolic link in the filesystem. By adding &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; in the crate root, &lt;code&gt;hosting&lt;/code&gt; is now a valid name in that scope, just as though the &lt;code&gt;hosting&lt;/code&gt; module had been defined in the crate root. Paths brought into scope with &lt;code&gt;use&lt;/code&gt; also check privacy, like any other paths.</source>
          <target state="translated">범위에 &lt;code&gt;use&lt;/code&gt; 및 경로를 추가 하는 것은 파일 시스템에서 심볼릭 링크를 만드는 것과 유사합니다. 추가함으로써 &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; , 나무 상자 루트에 &lt;code&gt;hosting&lt;/code&gt; 유효한 이름은 단지 것처럼, 그 범위에 지금 &lt;code&gt;hosting&lt;/code&gt; 모듈이 상자 루트에 정의되었다. &lt;code&gt;use&lt;/code&gt; 범위에 포함 된 경로는 다른 경로와 마찬가지로 개인 정보를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="311633e0da4d8767a76b5d94813ce0272b9cb8a9" translate="yes" xml:space="preserve">
          <source>Adding Custom Failure Messages</source>
          <target state="translated">사용자 정의 실패 메시지 추가</target>
        </trans-unit>
        <trans-unit id="eb99698d7e26927ef9425258511b7fbda34cd647" translate="yes" xml:space="preserve">
          <source>Adding Metadata to a New Crate</source>
          <target state="translated">새 상자에 메타 데이터 추가</target>
        </trans-unit>
        <trans-unit id="6ff96d15a4dfd75cd1b39329a2970688120a37e4" translate="yes" xml:space="preserve">
          <source>Adding Useful Functionality with Derived Traits</source>
          <target state="translated">파생 속성으로 유용한 기능 추가</target>
        </trans-unit>
        <trans-unit id="b2524eeb321c4f1026793239c00d8c1b31c32e31" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; field to your type tells the compiler that your type acts as though it stores a value of type &lt;code&gt;T&lt;/code&gt;, even though it doesn't really. This information is used when computing certain safety properties.</source>
          <target state="translated">&lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; 필드를 형식에 추가하면 형식 이 실제로는 아니지만 형식이 &lt;code&gt;T&lt;/code&gt; 형식의 값을 저장하는 것처럼 작동한다고 컴파일러에 알립니다 . 이 정보는 특정 안전 속성을 계산할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b87a48eb56569132271d6219a87c7a5229e982a0" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;Self: Sized&lt;/code&gt; bound to these methods will generally make this compile.</source>
          <target state="translated">&lt;code&gt;Self: Sized&lt;/code&gt; 추가 : 이러한 메소드에 바인딩 된 크기 는 일반적으로이 컴파일을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="88b9f27e251e16ee893bec092535b944c26b4aa9" translate="yes" xml:space="preserve">
          <source>Adding a Reference from a Child to Its Parent</source>
          <target state="translated">자식에서 부모로 참조 추가</target>
        </trans-unit>
        <trans-unit id="23ab42376e070f08194bffa94071c8449a58479a" translate="yes" xml:space="preserve">
          <source>Adding a Test to a Workspace</source>
          <target state="translated">작업 공간에 테스트 추가</target>
        </trans-unit>
        <trans-unit id="fd0c9f4d15902bc297e9dbf8af8d2743194e970b" translate="yes" xml:space="preserve">
          <source>Adding a field of type &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; indicates that your type owns data of type &lt;code&gt;T&lt;/code&gt;. This in turn implies that when your type is dropped, it may drop one or more instances of the type &lt;code&gt;T&lt;/code&gt;. This has bearing on the Rust compiler's &lt;a href=&quot;https://doc.rust-lang.org/nomicon/dropck.html&quot;&gt;drop check&lt;/a&gt; analysis.</source>
          <target state="translated">&lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; 유형의 필드를 추가하면 유형에 &lt;code&gt;T&lt;/code&gt; 유형의 데이터가 있음을 나타냅니다 . 이는 유형이 삭제되면 유형 &lt;code&gt;T&lt;/code&gt; 의 하나 이상의 인스턴스가 삭제 될 수 있음을 의미합니다 . 이것은 Rust 컴파일러의 &lt;a href=&quot;https://doc.rust-lang.org/nomicon/dropck.html&quot;&gt;드롭 체크&lt;/a&gt; 분석과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e98bb73927df33c08944823ebcc88b767156500" translate="yes" xml:space="preserve">
          <source>Adding example code blocks in your documentation comments can help demonstrate how to use your library, and doing so has an additional bonus: running &lt;code&gt;cargo test&lt;/code&gt; will run the code examples in your documentation as tests! Nothing is better than documentation with examples. But nothing is worse than examples that don&amp;rsquo;t work because the code has changed since the documentation was written. If we run &lt;code&gt;cargo test&lt;/code&gt; with the documentation for the &lt;code&gt;add_one&lt;/code&gt; function from Listing 14-1, we will see a section in the test results like this:</source>
          <target state="translated">문서 주석에 예제 코드 블록을 추가하면 라이브러리 사용 방법을 설명하는 데 도움이되며 추가 보너스가 있습니다. &lt;code&gt;cargo test&lt;/code&gt; 를 실행하면 문서의 코드 예제가 테스트로 실행됩니다! 예제가있는 문서보다 낫지는 않습니다. 그러나 문서가 작성된 후 코드가 변경되어 작동하지 않는 예제보다 나쁜 것은 없습니다. Listing 14-1 의 &lt;code&gt;add_one&lt;/code&gt; 함수에 대한 문서를 사용하여 &lt;code&gt;cargo test&lt;/code&gt; 를 실행 하면 테스트 결과에 다음과 같은 섹션이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ceb9b506f927db7479477e625a150623510cf2aa" translate="yes" xml:space="preserve">
          <source>Adding the &lt;code id=&quot;adding-the-approve-method-that-changes-the-behavior-of-content&quot;&gt;approve&lt;/code&gt; Method that Changes the Behavior of &lt;code&gt;content&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;content&lt;/code&gt; 의 동작을 변경 하는 &lt;code id=&quot;adding-the-approve-method-that-changes-the-behavior-of-content&quot;&gt;approve&lt;/code&gt; 메소드 추가</target>
        </trans-unit>
        <trans-unit id="718d273106ffd821ac0c7d93c2d34d8556d7365d" translate="yes" xml:space="preserve">
          <source>Adding the &lt;code&gt;break&lt;/code&gt; line after &lt;code&gt;You win!&lt;/code&gt; makes the program exit the loop when the user guesses the secret number correctly. Exiting the loop also means exiting the program, because the loop is the last part of &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;You win!&lt;/code&gt; 후 &lt;code&gt;break&lt;/code&gt; 라인 추가 ! 사용자가 비밀 번호를 올바르게 추측하면 프로그램이 루프를 종료합니다. 루프가 &lt;code&gt;main&lt;/code&gt; 의 마지막 부분이기 때문에 루프를 종료한다는 것은 프로그램을 종료하는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="097cf74b7fb2e319a4766446302ea478dcd635f5" translate="yes" xml:space="preserve">
          <source>Adding the &lt;code&gt;mut&lt;/code&gt; keyword dereferences a mutable reference. The mutability must match the mutability of the reference.</source>
          <target state="translated">&lt;code&gt;mut&lt;/code&gt; 키워드를 추가하면 변경 가능한 참조가 역 참조됩니다. 변경 가능성은 참조의 변경 가능성과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="8e8428e85c661f03dd33db8f12b20a010ab5be5e" translate="yes" xml:space="preserve">
          <source>Addition</source>
          <target state="translated">Addition</target>
        </trans-unit>
        <trans-unit id="c8217392646c4b940c031f95cbb65a4bfa731556" translate="yes" xml:space="preserve">
          <source>Addition assignment</source>
          <target state="translated">추가 과제</target>
        </trans-unit>
        <trans-unit id="b078f9f7ba47f896a06212df108079bcbb1553ff" translate="yes" xml:space="preserve">
          <source>Additional functionality for numerics.</source>
          <target state="translated">숫자에 대한 추가 기능.</target>
        </trans-unit>
        <trans-unit id="2ffc443f11be980490aef62083275ee8c11f674b" translate="yes" xml:space="preserve">
          <source>Additional implementors</source>
          <target state="translated">추가 구현 자</target>
        </trans-unit>
        <trans-unit id="911a0b354b810ade1b41221cd419095a4767144e" translate="yes" xml:space="preserve">
          <source>Additional information</source>
          <target state="translated">추가 정보</target>
        </trans-unit>
        <trans-unit id="0c05d0c23b9a6f9971368dd97467c0d0e294ca18" translate="yes" xml:space="preserve">
          <source>Additional parameters passed to &lt;code&gt;format!&lt;/code&gt; replace the &lt;code&gt;{}&lt;/code&gt;s within the formatting string in the order given unless named or positional parameters are used; see &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">추가 매개 변수가 &lt;code&gt;format!&lt;/code&gt; 전달되었습니다 ! 명명 된 또는 위치 매개 변수가 사용되지 않는 한 지정된 순서로 형식화 문자열 내의 &lt;code&gt;{}&lt;/code&gt; 을 대체하십시오 . 자세한 내용은 &lt;a href=&quot;fmt/index&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dc3992de92a20dddf33d6770f13a67c41e82f34f" translate="yes" xml:space="preserve">
          <source>Additionally, a type &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; can implement &lt;code&gt;CoerceUnsized&amp;lt;Foo&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Unsize&amp;lt;U&amp;gt;&lt;/code&gt; or &lt;code&gt;CoerceUnsized&amp;lt;Foo&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt;. This allows it to provide a unsized coercion to &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;Unsize&amp;lt;U&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;CoerceUnsized&amp;lt;Foo&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; 구현할 때 &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; 유형 은 &lt;code&gt;CoerceUnsized&amp;lt;Foo&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; 구현할 수 있습니다 . 이를 통해 &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt; 대해 크기가 조정되지 않은 강제 변환을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="30e7a03e650ce2c7f3e6f58657d0e770d7ebbede" translate="yes" xml:space="preserve">
          <source>Additionally, even though &lt;code&gt;$crate&lt;/code&gt; allows a macro to refer to items within its own crate when expanding, its use has no effect on visibility. An item or macro referred to must still be visible from the invocation site. In the following example, any attempt to invoke &lt;code&gt;call_foo!()&lt;/code&gt; from outside its crate will fail because &lt;code&gt;foo()&lt;/code&gt; is not public.</source>
          <target state="translated">또한 &lt;code&gt;$crate&lt;/code&gt; 사용하면 확장시 매크로가 자체 상자 내의 항목을 참조 할 수 있지만 가시성에 영향을 미치지 않습니다. 참조 된 항목이나 매크로는 여전히 호출 사이트에서 볼 수 있어야합니다. 다음 예제에서는 &lt;code&gt;foo()&lt;/code&gt; 가 공개 되지 않기 때문에 상자 외부에서 &lt;code&gt;call_foo!()&lt;/code&gt; 를 호출하려는 시도 가 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="45cbb93035ac4b5290adcbd441c337adab3295a5" translate="yes" xml:space="preserve">
          <source>Additionally, if &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using the pointed-to value after calling &lt;code&gt;drop_in_place&lt;/code&gt; can cause undefined behavior. Note that &lt;code&gt;*to_drop = foo&lt;/code&gt; counts as a use because it will cause the value to be dropped again. &lt;a href=&quot;../ptr/fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; can be used to overwrite data without causing it to be dropped.</source>
          <target state="translated">또한 &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 &lt;code&gt;drop_in_place&lt;/code&gt; 를 호출 한 후 지정된 값을 사용 하면 정의되지 않은 동작이 발생할 수 있습니다. 참고 &lt;code&gt;*to_drop = foo&lt;/code&gt; 카운트가 사용으로이 값의 원인이 있기 때문에 다시 삭제 될 수 있습니다. 데이터를 삭제하지 않고 덮어 쓰는 데 &lt;a href=&quot;../ptr/fn.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74bd1999d14b1334b93c7bef28b699b66b0d25fc" translate="yes" xml:space="preserve">
          <source>Additionally, if &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, using the pointed-to value after calling &lt;code&gt;drop_in_place&lt;/code&gt; can cause undefined behavior. Note that &lt;code&gt;*to_drop = foo&lt;/code&gt; counts as a use because it will cause the value to be dropped again. &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; can be used to overwrite data without causing it to be dropped.</source>
          <target state="translated">또한 &lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 &lt;code&gt;drop_in_place&lt;/code&gt; 를 호출 한 후 지정된 값을 사용 하면 정의되지 않은 동작이 발생할 수 있습니다. 참고 &lt;code&gt;*to_drop = foo&lt;/code&gt; 카운트가 사용으로이 값의 원인이 있기 때문에 다시 삭제 될 수 있습니다. 데이터를 삭제하지 않고 덮어 쓰는 데 &lt;a href=&quot;fn.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90a70db7c7bfc77bbf274f46c324d605b6ac9ac3" translate="yes" xml:space="preserve">
          <source>Additionally, it does not drop &lt;code&gt;src&lt;/code&gt;. Semantically, &lt;code&gt;src&lt;/code&gt; is moved into the location pointed to by &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;code&gt;src&lt;/code&gt; 를 삭제하지 않습니다 . 의미 상, &lt;code&gt;src&lt;/code&gt; 는 &lt;code&gt;dst&lt;/code&gt; 가 가리키는 위치로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="a5ab7ed4a3b0357f6baec92b0d45381b0f7726c3" translate="yes" xml:space="preserve">
          <source>Additionally, on Unix &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::unix::ffi::&lt;/code&gt;&lt;a href=&quot;../os/unix/ffi/trait.osstringext&quot;&gt;&lt;code&gt;OsStringExt&lt;/code&gt;&lt;/a&gt; trait, which provides &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.from_vec&quot;&gt;&lt;code&gt;from_vec&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.into_vec&quot;&gt;&lt;code&gt;into_vec&lt;/code&gt;&lt;/a&gt; methods that consume their arguments, and take or produce vectors of &lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">또한 Unix에서 &lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;std::os::unix::ffi::&lt;/code&gt; &lt;a href=&quot;../os/unix/ffi/trait.osstringext&quot;&gt; &lt;code&gt;OsStringExt&lt;/code&gt; &lt;/a&gt; 특성을 구현합니다.이 특성 은 인수를 사용하고 &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; 의&lt;/a&gt; 벡터를 가져 오거나 생성 하는 &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.from_vec&quot;&gt; &lt;code&gt;from_vec&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../os/unix/ffi/trait.osstringext#tymethod.into_vec&quot;&gt; &lt;code&gt;into_vec&lt;/code&gt; &lt;/a&gt; 메소드를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="8bb517701cd0832c45c67c28da4b399a605014b6" translate="yes" xml:space="preserve">
          <source>Additionally, on Windows &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;std::os::windows:ffi::&lt;/code&gt;&lt;a href=&quot;../os/windows/ffi/trait.osstringext&quot;&gt;&lt;code&gt;OsStringExt&lt;/code&gt;&lt;/a&gt; trait, which provides a &lt;a href=&quot;../os/windows/ffi/trait.osstringext#tymethod.from_wide&quot;&gt;&lt;code&gt;from_wide&lt;/code&gt;&lt;/a&gt; method. The result of this method is an &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; which can be round-tripped to a Windows string losslessly.</source>
          <target state="translated">또한 Windows에서 &lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;std::os::windows:ffi::&lt;/code&gt; &lt;a href=&quot;../os/windows/ffi/trait.osstringext&quot;&gt; &lt;code&gt;OsStringExt&lt;/code&gt; &lt;/a&gt; 특성을 구현하여 &lt;a href=&quot;../os/windows/ffi/trait.osstringext#tymethod.from_wide&quot;&gt; &lt;code&gt;from_wide&lt;/code&gt; &lt;/a&gt; 메소드 를 제공합니다 . 이 방법의 결과는 손실없이 Windows 문자열로 라운드 트립 될 수 있는 &lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0f7d5354cdb11e461595056b1602a23178a20138" translate="yes" xml:space="preserve">
          <source>Additionally, taking a job off the channel queue involves mutating the &lt;code&gt;receiver&lt;/code&gt;, so the threads need a safe way to share and modify &lt;code&gt;receiver&lt;/code&gt;; otherwise, we might get race conditions (as covered in Chapter 16).</source>
          <target state="translated">또한, 채널의 큐 작업을 복용하면 변이 포함 &lt;code&gt;receiver&lt;/code&gt; 스레드가 공유하고 수정할 수있는 안전한 방법이 필요하므로, &lt;code&gt;receiver&lt;/code&gt; ; 그렇지 않으면 경쟁 조건이 발생할 수 있습니다 (16 장에서 설명).</target>
        </trans-unit>
        <trans-unit id="0eb5702e98a03d052d40c8aabb340aee4d2332a4" translate="yes" xml:space="preserve">
          <source>Additionally, the &lt;code&gt;isize&lt;/code&gt; and &lt;code&gt;usize&lt;/code&gt; types depend on the kind of computer your program is running on: 64 bits if you&amp;rsquo;re on a 64-bit architecture and 32 bits if you&amp;rsquo;re on a 32-bit architecture.</source>
          <target state="translated">또한 &lt;code&gt;isize&lt;/code&gt; 및 &lt;code&gt;usize&lt;/code&gt; 유형은 프로그램이 실행되는 컴퓨터 종류에 따라 다릅니다. 64 비트 아키텍처 인 경우 64 비트, 32 비트 아키텍처 인 경우 32 비트.</target>
        </trans-unit>
        <trans-unit id="e3aa1d01d453f95734172c24dd2caadad96e569f" translate="yes" xml:space="preserve">
          <source>Additionally, the caller must ensure that writing &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes to the given region of memory results in a valid value of &lt;code&gt;T&lt;/code&gt;. Using a region of memory typed as a &lt;code&gt;T&lt;/code&gt; that contains an invalid value of &lt;code&gt;T&lt;/code&gt; is undefined behavior.</source>
          <target state="translated">또한 호출자는 주어진 메모리 영역에 &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 바이트를 쓰면 유효한 값 &lt;code&gt;T&lt;/code&gt; 가되도록해야 합니다. 유효하지 않은 &lt;code&gt;T&lt;/code&gt; 값을 포함하는 &lt;code&gt;T&lt;/code&gt; 로 유형이 지정된 메모리 영역을 사용하는 것은 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="f3d0f5351803248ec3d677cec08967bab902a3b1" translate="yes" xml:space="preserve">
          <source>Additionally, the length of the string will be recalculated from the pointer.</source>
          <target state="translated">또한 문자열의 길이는 포인터에서 다시 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="5c93e6fb82861fecd56783e8c74a9dcd85037abd" translate="yes" xml:space="preserve">
          <source>Additionally, the lifetime &lt;code&gt;'a&lt;/code&gt; returned is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data. It is up to the caller to ensure that for the duration of this lifetime, the memory this pointer points to does not get accessed through any other pointer.</source>
          <target state="translated">또한, 수명 &lt;code&gt;'a&lt;/code&gt; 돌아 임의로 선택되고 반드시 데이터의 실제 수명을 반영하지 않습니다. 이 수명 동안이 포인터가 가리키는 메모리가 다른 포인터를 통해 액세스되지 않도록하는 것은 호출자에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e203e0080d407af9cc4130e8b5859f062bfa85b" translate="yes" xml:space="preserve">
          <source>Additionally, the lifetime &lt;code&gt;'a&lt;/code&gt; returned is arbitrarily chosen and does not necessarily reflect the actual lifetime of the data. It is up to the caller to ensure that for the duration of this lifetime, the memory this pointer points to does not get written to outside of &lt;code&gt;UnsafeCell&amp;lt;U&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">또한, 수명 &lt;code&gt;'a&lt;/code&gt; 돌아 임의로 선택되고 반드시 데이터의 실제 수명을 반영하지 않습니다. 이 수명 동안이 포인터가 가리키는 메모리가 &lt;code&gt;UnsafeCell&amp;lt;U&amp;gt;&lt;/code&gt; 외부에 쓰지 않도록하는 것은 호출자에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb09e099663e4fdfec9970e8541bfc0bbcb8c136" translate="yes" xml:space="preserve">
          <source>Additionally, the return value of this function is &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;fmt::Result&lt;/code&gt;&lt;/a&gt; which is a type alias of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;(), &lt;/code&gt;&lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;std::fmt::Error&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Formatting implementations should ensure that they propagate errors from the &lt;a href=&quot;struct.formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; (e.g., when calling &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt;). However, they should never return errors spuriously. That is, a formatting implementation must and may only return an error if the passed-in &lt;a href=&quot;struct.formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; returns an error. This is because, contrary to what the function signature might suggest, string formatting is an infallible operation. This function only returns a result because writing to the underlying stream might fail and it must provide a way to propagate the fact that an error has occurred back up the stack.</source>
          <target state="translated">또한이 함수의 반환 값은 &lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;fmt::Result&lt;/code&gt; &lt;/a&gt; 이며 이는 &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;(), &lt;/code&gt; &lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;std::fmt::Error&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 의 유형 별칭입니다 . 포맷팅 구현은 &lt;a href=&quot;struct.formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; 에서 오류를 전파해야합니다 (예 : &lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; 를&lt;/a&gt; 호출 할 때 ). 그러나 오류를 허위로 반환해서는 안됩니다. 즉, 서식 구현은 전달 된 &lt;a href=&quot;struct.formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; 인&lt;/a&gt; 경우에만 오류를 반환해야합니다.오류를 반환합니다. 함수 시그니처가 제안하는 것과 달리 문자열 형식화는 잘못된 작업이기 때문입니다. 이 함수는 기본 스트림에 쓰지 못할 수 있기 때문에 결과 만 반환하며, 스택을 백업 할 때 오류가 발생했다는 사실을 전파 할 수있는 방법을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="c51e0d7d6467942093ff85910240899ecb3312bc" translate="yes" xml:space="preserve">
          <source>Additionally, we can&amp;rsquo;t yet provide the &lt;code&gt;hello_macro&lt;/code&gt; function with default implementation that will print the name of the type the trait is implemented on: Rust doesn&amp;rsquo;t have reflection capabilities, so it can&amp;rsquo;t look up the type&amp;rsquo;s name at runtime. We need a macro to generate code at compile time.</source>
          <target state="translated">또한, 특성이 구현 된 유형의 이름을 인쇄하는 기본 구현으로 &lt;code&gt;hello_macro&lt;/code&gt; 함수를 아직 제공 할 수 없습니다 . Rust에는 리플렉션 기능이 없으므로 런타임시 유형 이름을 찾을 수 없습니다. 컴파일 타임에 코드를 생성하려면 매크로가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="009b5112bedb7bc7f35022f14f637dbf23e46083" translate="yes" xml:space="preserve">
          <source>Additionally, you&amp;rsquo;ll need a linker of some kind. It&amp;rsquo;s likely one is already installed, but when you try to compile a Rust program and get errors indicating that a linker could not execute, that means a linker isn&amp;rsquo;t installed on your system and you&amp;rsquo;ll need to install one manually. C compilers usually come with the correct linker. Check your platform&amp;rsquo;s documentation for how to install a C compiler. Also, some common Rust packages depend on C code and will need a C compiler. Therefore, it might be worth installing one now.</source>
          <target state="translated">또한 일종의 링커가 필요합니다. 이미 설치되었을 수도 있지만 Rust 프로그램을 컴파일하려고 시도하고 링커를 실행할 수 없다는 오류가 발생하면 링커가 시스템에 설치되어 있지 않으므로 수동으로 설치해야합니다. C 컴파일러는 일반적으로 올바른 링커와 함께 제공됩니다. C 컴파일러 설치 방법은 플랫폼 설명서를 확인하십시오. 또한 일부 일반적인 Rust 패키지는 C 코드에 의존하며 C 컴파일러가 필요합니다. 따라서 지금 설치하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e8f6c433136e97e0a25822d00a70a971083e0df2" translate="yes" xml:space="preserve">
          <source>AddrParseError</source>
          <target state="translated">AddrParseError</target>
        </trans-unit>
        <trans-unit id="4db89e8ded7777748645ac21edd601141065b25a" translate="yes" xml:space="preserve">
          <source>AddrParseError::borrow</source>
          <target state="translated">AddrParseError::borrow</target>
        </trans-unit>
        <trans-unit id="ba5e2e5b2d73d903fb597da8809d6182f967fe26" translate="yes" xml:space="preserve">
          <source>AddrParseError::borrow_mut</source>
          <target state="translated">AddrParseError::borrow_mut</target>
        </trans-unit>
        <trans-unit id="eec3364cb0e6e631bd766aeee8473eb3c5d8b783" translate="yes" xml:space="preserve">
          <source>AddrParseError::cause</source>
          <target state="translated">AddrParseError::cause</target>
        </trans-unit>
        <trans-unit id="c8650de9923d2b7b74fd1fb851b3c0ddd4117148" translate="yes" xml:space="preserve">
          <source>AddrParseError::clone</source>
          <target state="translated">AddrParseError::clone</target>
        </trans-unit>
        <trans-unit id="53ddfe6ad8c3351ba945f5b6cd6f647e3fa91325" translate="yes" xml:space="preserve">
          <source>AddrParseError::clone_from</source>
          <target state="translated">AddrParseError::clone_from</target>
        </trans-unit>
        <trans-unit id="08355c15003499e28a7411918357d4a2f001b709" translate="yes" xml:space="preserve">
          <source>AddrParseError::clone_into</source>
          <target state="translated">AddrParseError::clone_into</target>
        </trans-unit>
        <trans-unit id="25cb3b50c76347b7f6a85db7c339595baf0f003c" translate="yes" xml:space="preserve">
          <source>AddrParseError::description</source>
          <target state="translated">AddrParseError::description</target>
        </trans-unit>
        <trans-unit id="10b9b968cc3bf94f7c5c39dea8bf21d7dd54888c" translate="yes" xml:space="preserve">
          <source>AddrParseError::eq</source>
          <target state="translated">AddrParseError::eq</target>
        </trans-unit>
        <trans-unit id="49cf29f6a6f46e91fe5234ee3c02c53e59ab7578" translate="yes" xml:space="preserve">
          <source>AddrParseError::fmt</source>
          <target state="translated">AddrParseError::fmt</target>
        </trans-unit>
        <trans-unit id="60405d6d13708e4d85c176a98cb4377bfb7ee9d7" translate="yes" xml:space="preserve">
          <source>AddrParseError::from</source>
          <target state="translated">AddrParseError::from</target>
        </trans-unit>
        <trans-unit id="dbfcfd8a7eba25880c9888cb8208fce8e37c895d" translate="yes" xml:space="preserve">
          <source>AddrParseError::into</source>
          <target state="translated">AddrParseError::into</target>
        </trans-unit>
        <trans-unit id="81cea92a5c59d76a750c2dc91be0b6bebf9c1c4f" translate="yes" xml:space="preserve">
          <source>AddrParseError::ne</source>
          <target state="translated">AddrParseError::ne</target>
        </trans-unit>
        <trans-unit id="85b81474bbc6034c17600e25b324b8f7ff89e65b" translate="yes" xml:space="preserve">
          <source>AddrParseError::source</source>
          <target state="translated">AddrParseError::source</target>
        </trans-unit>
        <trans-unit id="ba1fd539045fde8129efbfd52fe6aba361392170" translate="yes" xml:space="preserve">
          <source>AddrParseError::to_owned</source>
          <target state="translated">AddrParseError::to_owned</target>
        </trans-unit>
        <trans-unit id="e2552e76eca8011ad4e06db73e14e51d90cd4e86" translate="yes" xml:space="preserve">
          <source>AddrParseError::to_string</source>
          <target state="translated">AddrParseError::to_string</target>
        </trans-unit>
        <trans-unit id="ff5f57540e8ea426311cdc19ccc6971134dcdb7f" translate="yes" xml:space="preserve">
          <source>AddrParseError::try_from</source>
          <target state="translated">AddrParseError::try_from</target>
        </trans-unit>
        <trans-unit id="bec376def9a1123d4f124dfc1a6840567151a145" translate="yes" xml:space="preserve">
          <source>AddrParseError::try_into</source>
          <target state="translated">AddrParseError::try_into</target>
        </trans-unit>
        <trans-unit id="26c560bba3044ee670c8f3ee436e252e0e2dad89" translate="yes" xml:space="preserve">
          <source>AddrParseError::type_id</source>
          <target state="translated">AddrParseError::type_id</target>
        </trans-unit>
        <trans-unit id="5cf7a9b41ce47d27a30e791bbfb6bec2ca816fcf" translate="yes" xml:space="preserve">
          <source>Address to pointer cast</source>
          <target state="translated">포인터 캐스트 할 주소</target>
        </trans-unit>
        <trans-unit id="d7aa7412717eb74583761a8560faa539aaf27874" translate="yes" xml:space="preserve">
          <source>Address type can be any implementor of &lt;a href=&quot;trait.tosocketaddrs&quot;&gt;&lt;code&gt;ToSocketAddrs&lt;/code&gt;&lt;/a&gt; trait. See its documentation for concrete examples.</source>
          <target state="translated">주소 유형은 &lt;a href=&quot;trait.tosocketaddrs&quot;&gt; &lt;code&gt;ToSocketAddrs&lt;/code&gt; &lt;/a&gt; 특성을 구현할 수 있습니다 . 구체적인 예는 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5a1149884af3cef69504ddd9428373fea25aa2ca" translate="yes" xml:space="preserve">
          <source>Addresses returned by the operating system that are not IP addresses are silently ignored.</source>
          <target state="translated">IP 주소가 아닌 운영 체제가 리턴 한 주소는 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5915abc490110180d1540b6234219f020e04a70a" translate="yes" xml:space="preserve">
          <source>Adds a &lt;a href=&quot;struct.peekable#method.peek&quot;&gt;&lt;code&gt;peek&lt;/code&gt;&lt;/a&gt; method to an iterator. See its documentation for more information.</source>
          <target state="translated">반복기에 &lt;a href=&quot;struct.peekable#method.peek&quot;&gt; &lt;code&gt;peek&lt;/code&gt; &lt;/a&gt; 메소드를 추가 합니다. 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c870f816a116db65c4b82439ff891f426f80ff41" translate="yes" xml:space="preserve">
          <source>Adds a &lt;code&gt;usize&lt;/code&gt;, returning &lt;code&gt;None&lt;/code&gt; on overflow.</source>
          <target state="translated">오버플 로시 &lt;code&gt;None&lt;/code&gt; 을 반환 하여 &lt;code&gt;usize&lt;/code&gt; 를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="31cf127eab5bb935c2abe6cc6bba90f4ae0b71a3" translate="yes" xml:space="preserve">
          <source>Adds a new entry to the list output.</source>
          <target state="translated">목록 출력에 새 항목을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="15cb5f7efe200723c3b721e295fbebc13dfc9e31" translate="yes" xml:space="preserve">
          <source>Adds a new entry to the map output.</source>
          <target state="translated">맵 출력에 새 항목을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0ef3b59a4597ecf10372b8f11eb26c1a52f2f272" translate="yes" xml:space="preserve">
          <source>Adds a new entry to the set output.</source>
          <target state="translated">설정된 출력에 새 항목을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="60f1cf0bd8c4a027b017ecaa893cb9c74c91f78b" translate="yes" xml:space="preserve">
          <source>Adds a new field to the generated struct output.</source>
          <target state="translated">생성 된 구조체 출력에 새 필드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="b8fafafece871a01042ed5a0ab5c6c9b2e80442c" translate="yes" xml:space="preserve">
          <source>Adds a new field to the generated tuple struct output.</source>
          <target state="translated">생성 된 튜플 구조체 출력에 새 필드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0b002c9af6c57cafdfe28d411ed57cf85e2ebe81" translate="yes" xml:space="preserve">
          <source>Adds a value to the set, replacing the existing value, if any, that is equal to the given one. Returns the replaced value.</source>
          <target state="translated">주어진 값과 동일한 기존 값을 대체하여 값을 세트에 추가합니다. 대체 된 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="82f4c899437f1a62750b1776b4b1b6599530f1e6" translate="yes" xml:space="preserve">
          <source>Adds a value to the set.</source>
          <target state="translated">세트에 값을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="f1a3f6979754c5ca7c9e4122b44f7541e9636107" translate="yes" xml:space="preserve">
          <source>Adds an argument to pass to the program.</source>
          <target state="translated">프로그램에 전달할 인수를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="658707171b5a956fa506d45ca2578865d314c2a0" translate="yes" xml:space="preserve">
          <source>Adds an element first in the list.</source>
          <target state="translated">목록에서 요소를 먼저 추가합니다.</target>
        </trans-unit>
        <trans-unit id="969d7672cd1e94e2e3f766816cef88b15855a861" translate="yes" xml:space="preserve">
          <source>Adds multiple arguments to pass to the program.</source>
          <target state="translated">프로그램에 전달할 여러 인수를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="68adca23d26862cb362a13d5d500e729dc911a8b" translate="yes" xml:space="preserve">
          <source>Adds one to this step, returning the result.</source>
          <target state="translated">이 단계에 하나를 추가하여 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0151250bd8bdb46ad8abec9aa6c7d2adc6f4d3c2" translate="yes" xml:space="preserve">
          <source>Adds or updates multiple environment variable mappings.</source>
          <target state="translated">여러 환경 변수 매핑을 추가하거나 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="c1ea158bb2722c6d5db848a523c49d2d1b4ef996" translate="yes" xml:space="preserve">
          <source>Adds support for special Unix file types such as block/character devices, pipes, and sockets.</source>
          <target state="translated">블록 / 문자 장치, 파이프 및 소켓과 같은 특수 Unix 파일 유형에 대한 지원을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="671bf2741316962d688bf4f15b0556af370525fd" translate="yes" xml:space="preserve">
          <source>Adds the contents of an iterator of entries to the list output.</source>
          <target state="translated">항목 반복자의 내용을 목록 출력에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6172d9346f85a8afb18c30e9f6e11792ac6685f3" translate="yes" xml:space="preserve">
          <source>Adds the contents of an iterator of entries to the map output.</source>
          <target state="translated">항목 반복자의 컨텐츠를 맵 출력에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="45f4916d90bbb31a57ac59c642d372fc8465632a" translate="yes" xml:space="preserve">
          <source>Adds the contents of an iterator of entries to the set output.</source>
          <target state="translated">항목 반복자의 컨텐츠를 세트 출력에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="64dedb52a39f499be5ddacaf33bea0b6af530c2b" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value.</source>
          <target state="translated">현재 값에 더하고 이전 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fec400f1cdf6c0803479c71a8ae238f9468f9b58" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::AcqRel&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 값에 더하고 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_add&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::AcqRel&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_add 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형에서 사용 가능합니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="be9a5a4d4b7398c45da8fcba5bded3bbc8f71847" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Acquire&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 값에 더하고 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_add&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Acquire&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_add 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형에서 사용 가능합니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e8510188bc5ebdc1c7bffee425e4b31fab3c7278" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Relaxed&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 값에 더하고 이전 값을 반환합니다. 이 내장 함수의 안정화 버전은 &lt;code&gt;fetch_add&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Relaxed&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_add 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형 에서 사용할 수 있습니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5d050db3800c7dd71e5057e0d9def9358e61a419" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::Release&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 값에 더하고 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_add&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::Release&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_add 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형에서 사용 가능합니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1973476bdfd162d29c3bf0eb0f1911803377eae3" translate="yes" xml:space="preserve">
          <source>Adds to the current value, returning the previous value. The stabilized version of this intrinsic is available on the &lt;code&gt;std::sync::atomic&lt;/code&gt; types via the &lt;code&gt;fetch_add&lt;/code&gt; method by passing &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt;&lt;code&gt;Ordering::SeqCst&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;order&lt;/code&gt;. For example, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt;&lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 값에 더하고 이전 값을 반환합니다. 이 내장 함수의 안정화 된 버전은 &lt;code&gt;fetch_add&lt;/code&gt; &lt;a href=&quot;../sync/atomic/enum.ordering&quot;&gt; &lt;code&gt;Ordering::SeqCst&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;order&lt;/code&gt; 로 전달 하여 fetch_add 메소드 를 통해 &lt;code&gt;std::sync::atomic&lt;/code&gt; 유형에서 사용 가능합니다 . 예를 들어, &lt;a href=&quot;../sync/atomic/struct.atomicisize#method.fetch_add&quot;&gt; &lt;code&gt;AtomicIsize::fetch_add&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b2ed5841682a101d798c6152b62dca74cfea4b15" translate="yes" xml:space="preserve">
          <source>Advance to the next arg.</source>
          <target state="translated">다음 인수로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="96731dbaea6a5720dd33b64dc334ff765eec736a" translate="yes" xml:space="preserve">
          <source>Advanced Features</source>
          <target state="translated">고급 기능</target>
        </trans-unit>
        <trans-unit id="7f4668d91bf23526ef1f05a0e7de95630615e93b" translate="yes" xml:space="preserve">
          <source>Advanced Functions and Closures</source>
          <target state="translated">고급 기능 및 폐쇄</target>
        </trans-unit>
        <trans-unit id="d5d49bfe71b011aa5e9e308b0bd9089c84c3c245" translate="yes" xml:space="preserve">
          <source>Advanced Traits</source>
          <target state="translated">고급 특성</target>
        </trans-unit>
        <trans-unit id="ae95896c3a125d9a5e8ed95928ac9721dd8d3752" translate="yes" xml:space="preserve">
          <source>Advanced Types</source>
          <target state="translated">고급 유형</target>
        </trans-unit>
        <trans-unit id="9b4509b6a0eecdabec69457f9e139e56f305f9a7" translate="yes" xml:space="preserve">
          <source>Advanced functions and closures: function pointers and returning closures</source>
          <target state="translated">고급 함수 및 클로저 : 함수 포인터 및 리턴 클로저</target>
        </trans-unit>
        <trans-unit id="9c622feb39e22136f98cc1cfffb6cc56c0cb6ac7" translate="yes" xml:space="preserve">
          <source>Advanced traits: associated types, default type parameters, fully qualified syntax, supertraits, and the newtype pattern in relation to traits</source>
          <target state="translated">고급 특성 : 연관된 유형, 기본 유형 매개 변수, 완전한 구문, 상위 특성 및 특성과 관련된 새 유형 패턴</target>
        </trans-unit>
        <trans-unit id="d050af08a92ff2ff0056bb035493a0f2f1620de8" translate="yes" xml:space="preserve">
          <source>Advanced types: more about the newtype pattern, type aliases, the never type, and dynamically sized types</source>
          <target state="translated">고급 유형 : 새 유형 패턴, 유형 별칭, never 유형 및 동적 크기 유형에 대한 추가 정보</target>
        </trans-unit>
        <trans-unit id="bc73315bb680ddc61259cb6b2cc7f603f7017af5" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value.</source>
          <target state="translated">반복자를 진행시키고 다음 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="47778efc70c16f19b03a33e09324cdfef37b8397" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;../../../iter/trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자를 진행시키고 다음 값을 반환합니다. &lt;a href=&quot;../../../iter/trait.iterator#tymethod.next&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e5c10d1dad50204036d6641dc96f179feac3c880" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자를 진행시키고 다음 값을 반환합니다. &lt;a href=&quot;../../iter/trait.iterator#tymethod.next&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e0d17cb524aa65c6531ab7f58b22a2915be47179" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;../iter/trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자를 진행시키고 다음 값을 반환합니다. &lt;a href=&quot;../iter/trait.iterator#tymethod.next&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2af190b4bf87220daaa7fcdfebb435d1dda577b1" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;iter/trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자를 진행시키고 다음 값을 반환합니다. &lt;a href=&quot;iter/trait.iterator#tymethod.next&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75ff050bc0f28af247ba9f7e987965071e370a8f" translate="yes" xml:space="preserve">
          <source>Advances the iterator and returns the next value. &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">반복자를 진행시키고 다음 값을 반환합니다. &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fc5df98fcac936e0dd69b6d3ac4bff062078ea9f" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;#[test]&lt;/code&gt; we add the &lt;code&gt;#[ignore]&lt;/code&gt; line to the test we want to exclude. Now when we run our tests, &lt;code&gt;it_works&lt;/code&gt; runs, but &lt;code&gt;expensive_test&lt;/code&gt; doesn&amp;rsquo;t:</source>
          <target state="translated">후 &lt;code&gt;#[test]&lt;/code&gt; 우리는 추가 &lt;code&gt;#[ignore]&lt;/code&gt; 우리가 제외 할 테스트에 줄을. 이제 테스트를 실행하면 &lt;code&gt;it_works&lt;/code&gt; 가 실행되지만 &lt;code&gt;expensive_test&lt;/code&gt; 는 다음을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="471c4d510c078cce605f07ee5e3b57ac50f1448c" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;crate&lt;/code&gt;, we include each of the successive modules until we make our way to &lt;code&gt;add_to_waitlist&lt;/code&gt;. You can imagine a filesystem with the same structure, and we&amp;rsquo;d specify the path &lt;code&gt;/front_of_house/hosting/add_to_waitlist&lt;/code&gt; to run the &lt;code&gt;add_to_waitlist&lt;/code&gt; program; using the &lt;code&gt;crate&lt;/code&gt; name to start from the crate root is like using &lt;code&gt;/&lt;/code&gt; to start from the filesystem root in your shell.</source>
          <target state="translated">&lt;code&gt;crate&lt;/code&gt; 뒤에 &lt;code&gt;add_to_waitlist&lt;/code&gt; 로 갈 때까지 각 연속 모듈을 포함 시킵니다 . 동일한 구조의 파일 시스템을 상상할 수 있으며 &lt;code&gt;add_to_waitlist&lt;/code&gt; 프로그램 을 실행하기 위해 &lt;code&gt;/front_of_house/hosting/add_to_waitlist&lt;/code&gt; 경로를 지정합니다 . &lt;code&gt;crate&lt;/code&gt; 이름을 사용하여 상자 루트에서 시작하는 것은 &lt;code&gt;/&lt;/code&gt; 를 사용 하여 쉘의 파일 시스템 루트에서 시작하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="72900f50989a74635a45f599f7af957665be760a" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;false&lt;/code&gt; is returned, &lt;code&gt;skip_while()&lt;/code&gt;'s job is over, and the rest of the elements are yielded.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 가 반환 된 후 &lt;code&gt;skip_while()&lt;/code&gt; 의 작업이 종료되고 나머지 요소가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a8fe2c79e763fccf582bfde64f2cf9442ce9db7c" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;false&lt;/code&gt; is returned, &lt;code&gt;take_while()&lt;/code&gt;'s job is over, and the rest of the elements are ignored.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 가 반환 된 후 &lt;code&gt;take_while()&lt;/code&gt; 의 작업이 끝나고 나머지 요소는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d9d86d37284d13e516ed39f67cc2c963b4451b66" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;leaf&lt;/code&gt; is created, its &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; has a strong count of 1 and a weak count of 0. In the inner scope, we create &lt;code&gt;branch&lt;/code&gt; and associate it with &lt;code&gt;leaf&lt;/code&gt;, at which point when we print the counts, the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;branch&lt;/code&gt; will have a strong count of 1 and a weak count of 1 (for &lt;code&gt;leaf.parent&lt;/code&gt; pointing to &lt;code&gt;branch&lt;/code&gt; with a &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt;). When we print the counts in &lt;code&gt;leaf&lt;/code&gt;, we&amp;rsquo;ll see it will have a strong count of 2, because &lt;code&gt;branch&lt;/code&gt; now has a clone of the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; of &lt;code&gt;leaf&lt;/code&gt; stored in &lt;code&gt;branch.children&lt;/code&gt;, but will still have a weak count of 0.</source>
          <target state="translated">&lt;code&gt;leaf&lt;/code&gt; 가 생성 된 후 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 수는 1이고 약한 수는 0입니다. 내부 범위에서 &lt;code&gt;branch&lt;/code&gt; 를 만들고 &lt;code&gt;leaf&lt;/code&gt; 와 연결합니다 .이 시점에서 수를 인쇄 할 때 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 에서 &lt;code&gt;branch&lt;/code&gt; (1 강한 카운트 1 약함 수있을 것이다 &lt;code&gt;leaf.parent&lt;/code&gt; 가리키는 &lt;code&gt;branch&lt;/code&gt; A의 &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; ). 우리가 카운트 인쇄 할 때 &lt;code&gt;leaf&lt;/code&gt; 하기 때문에, 우리는이 둘의 강한 수있을 것이다 볼 &lt;code&gt;branch&lt;/code&gt; 현재의 복제가 &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; 의 &lt;code&gt;leaf&lt;/code&gt; 에 저장 &lt;code&gt;branch.children&lt;/code&gt; 이지만 여전히 약한 카운트는 0입니다.</target>
        </trans-unit>
        <trans-unit id="4cde8475e322a79219c56c165831cd534e7a6b56" translate="yes" xml:space="preserve">
          <source>After an iterator returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, future calls may or may not yield &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(T)&lt;/code&gt;&lt;/a&gt; again. &lt;code&gt;fuse()&lt;/code&gt; adapts an iterator, ensuring that after a &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is given, it will always return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; forever.</source>
          <target state="translated">반복자가 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 반환 하면 이후의 호출은 &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(T)&lt;/code&gt; &lt;/a&gt; 다시 생성하거나 생성하지 않을 수 있습니다 . &lt;code&gt;fuse()&lt;/code&gt; 는 반복자를 조정하여 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이 주어지면 항상 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 영원히 리턴하도록 합니다.</target>
        </trans-unit>
        <trans-unit id="568e22b9792d58baafe078fb9cf96ab4d0418d3f" translate="yes" xml:space="preserve">
          <source>After applying this closure to every element of the iterator, &lt;code&gt;fold()&lt;/code&gt; returns the accumulator.</source>
          <target state="translated">이 클로저를 반복자의 모든 요소에 적용한 후 &lt;code&gt;fold()&lt;/code&gt; 는 누산기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c5c6fbc1d802b5c2313fc5d60dee8a9485ff2828" translate="yes" xml:space="preserve">
          <source>After applying this closure to every element of the iterator, &lt;code&gt;rfold()&lt;/code&gt; returns the accumulator.</source>
          <target state="translated">이 클로저를 반복자의 모든 요소에 적용한 후 &lt;code&gt;rfold()&lt;/code&gt; 는 누산기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bc617f1ae4108d460b1173f3a7067fe06a8d7ed6" translate="yes" xml:space="preserve">
          <source>After calling this function, the caller is responsible for the memory previously managed by the &lt;code&gt;Box&lt;/code&gt;. In particular, the caller should properly destroy &lt;code&gt;T&lt;/code&gt; and release the memory, taking into account the &lt;a href=&quot;index#memory-layout&quot;&gt;memory layout&lt;/a&gt; used by &lt;code&gt;Box&lt;/code&gt;. The easiest way to do this is to convert the raw pointer back into a &lt;code&gt;Box&lt;/code&gt; with the &lt;a href=&quot;struct.box#method.from_raw&quot;&gt;&lt;code&gt;Box::from_raw&lt;/code&gt;&lt;/a&gt; function, allowing the &lt;code&gt;Box&lt;/code&gt; destructor to perform the cleanup.</source>
          <target state="translated">이 함수를 호출 한 후 호출자는 &lt;code&gt;Box&lt;/code&gt; 가 이전에 관리 한 메모리를 담당합니다 . 특히, 호출자는 &lt;code&gt;Box&lt;/code&gt; 가 사용 하는 &lt;a href=&quot;index#memory-layout&quot;&gt;메모리 레이아웃&lt;/a&gt; 을 고려하여 &lt;code&gt;T&lt;/code&gt; 를 올바르게 파괴 하고 메모리를 해제 해야합니다 . 가장 쉬운 방법 은 &lt;a href=&quot;struct.box#method.from_raw&quot;&gt; &lt;code&gt;Box::from_raw&lt;/code&gt; &lt;/a&gt; 함수를 사용 하여 Raw 포인터를 &lt;code&gt;Box&lt;/code&gt; 로 다시 변환 하여 &lt;code&gt;Box&lt;/code&gt; 소멸자가 정리를 수행하도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="47bfd04ad6639821cf514c2ef1fb0d7b6f63839d" translate="yes" xml:space="preserve">
          <source>After calling this function, the caller is responsible for the memory previously managed by the &lt;code&gt;Box&lt;/code&gt;. In particular, the caller should properly destroy &lt;code&gt;T&lt;/code&gt; and release the memory. The easiest way to do so is to convert the &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; pointer into a raw pointer and back into a &lt;code&gt;Box&lt;/code&gt; with the &lt;a href=&quot;struct.box#method.from_raw&quot;&gt;&lt;code&gt;Box::from_raw&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">이 함수를 호출 한 후 호출자는 &lt;code&gt;Box&lt;/code&gt; 가 이전에 관리 한 메모리를 담당합니다 . 특히, 호출자는 &lt;code&gt;T&lt;/code&gt; 를 올바르게 파괴 하고 메모리를 해제해야합니다. 이렇게하는 가장 쉬운 방법은 변환하는 것입니다 &lt;code&gt;NonNull&amp;lt;T&amp;gt;&lt;/code&gt; 에 원시 포인터와 뒷면에 포인터 &lt;code&gt;Box&lt;/code&gt; 와 &lt;a href=&quot;struct.box#method.from_raw&quot;&gt; &lt;code&gt;Box::from_raw&lt;/code&gt; &lt;/a&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="3d10c7bbc7ba580c584a70857a59b76ef027af83" translate="yes" xml:space="preserve">
          <source>After calling this function, the raw pointer is owned by the resulting &lt;code&gt;Box&lt;/code&gt;. Specifically, the &lt;code&gt;Box&lt;/code&gt; destructor will call the destructor of &lt;code&gt;T&lt;/code&gt; and free the allocated memory. For this to be safe, the memory must have been allocated in accordance with the &lt;a href=&quot;index#memory-layout&quot;&gt;memory layout&lt;/a&gt; used by &lt;code&gt;Box&lt;/code&gt; .</source>
          <target state="translated">이 함수를 호출 한 후, 원시 포인터는 결과가 소유 &lt;code&gt;Box&lt;/code&gt; . 특히 &lt;code&gt;Box&lt;/code&gt; 소멸자는 &lt;code&gt;T&lt;/code&gt; 의 소멸자를 호출 하고 할당 된 메모리를 해제합니다. 이를 안전하게하려면 &lt;code&gt;Box&lt;/code&gt; 가 사용 하는 &lt;a href=&quot;index#memory-layout&quot;&gt;메모리 레이아웃&lt;/a&gt; 에 따라 메모리 가 할당되어 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="ef76ea7ae2deed3f017eb7251cbd0d7c334a7aaf" translate="yes" xml:space="preserve">
          <source>After changing &lt;code&gt;println!&lt;/code&gt; to &lt;code&gt;eprintln!&lt;/code&gt;, let&amp;rsquo;s run the program again in the same way, without any arguments and redirecting standard output with &lt;code&gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;println!&lt;/code&gt; 변경 후 ! 에 &lt;code&gt;eprintln!&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 와 같은 방식으로 표준 출력을 재지 정하는 인수없이 동일한 방식으로 프로그램을 다시 실행 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="93133f68d39862996d0135a231d1905a95e950c2" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;TcpListener&lt;/code&gt; by &lt;a href=&quot;#method.bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt;ing it to a socket address, it listens for incoming TCP connections. These can be accepted by calling &lt;a href=&quot;#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt; or by iterating over the &lt;a href=&quot;struct.incoming&quot;&gt;&lt;code&gt;Incoming&lt;/code&gt;&lt;/a&gt; iterator returned by &lt;a href=&quot;#method.incoming&quot;&gt;&lt;code&gt;incoming&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">소켓 주소 에 &lt;a href=&quot;#method.bind&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt; 하여 &lt;code&gt;TcpListener&lt;/code&gt; 를 작성한 후 들어오는 TCP 연결을 청취합니다. 이러한 호출에 의해 허용 될 수있다 &lt;a href=&quot;#method.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt; 또는 이상 반복에 의해 &lt;a href=&quot;struct.incoming&quot;&gt; &lt;code&gt;Incoming&lt;/code&gt; &lt;/a&gt; 에 의해 반환 된 반복자 &lt;a href=&quot;#method.incoming&quot;&gt; &lt;code&gt;incoming&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="422e2b7f3798df18a9e41b4f6d8230c5f7fbaae2" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;TcpStream&lt;/code&gt; by either &lt;a href=&quot;#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt;ing to a remote host or &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt;ing a connection on a &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt;, data can be transmitted by &lt;a href=&quot;../io/trait.read&quot;&gt;reading&lt;/a&gt; and &lt;a href=&quot;../io/trait.write&quot;&gt;writing&lt;/a&gt; to it.</source>
          <target state="translated">만든 후 &lt;code&gt;TcpStream&lt;/code&gt; 를 하나에 의해 &lt;a href=&quot;#method.connect&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt; 원격 호스트에 보내고 또는 &lt;a href=&quot;struct.tcplistener#method.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt; A의 연결 보내고 &lt;a href=&quot;struct.tcplistener&quot;&gt; &lt;code&gt;TcpListener&lt;/code&gt; 를&lt;/a&gt; , 데이터가 전송 될 수있는 &lt;a href=&quot;../io/trait.read&quot;&gt;판독&lt;/a&gt; 및 &lt;a href=&quot;../io/trait.write&quot;&gt;기록&lt;/a&gt; 그것에.</target>
        </trans-unit>
        <trans-unit id="b9be232588db8403f71ee1411aa554678f33dfa7" translate="yes" xml:space="preserve">
          <source>After creating a &lt;code&gt;UdpSocket&lt;/code&gt; by &lt;a href=&quot;#method.bind&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt;ing it to a socket address, data can be &lt;a href=&quot;#method.send_to&quot;&gt;sent to&lt;/a&gt; and &lt;a href=&quot;#method.recv_from&quot;&gt;received from&lt;/a&gt; any other socket address.</source>
          <target state="translated">소켓 주소 에 &lt;a href=&quot;#method.bind&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt; 하여 &lt;code&gt;UdpSocket&lt;/code&gt; 을 만든 후 다른 소켓 주소 와 데이터 &lt;a href=&quot;#method.send_to&quot;&gt;를&lt;/a&gt; 주고 &lt;a href=&quot;#method.recv_from&quot;&gt;받을&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3fc506cb877752d66797eaa2996ad1bfc89765b7" translate="yes" xml:space="preserve">
          <source>After creating a new &lt;code&gt;Job&lt;/code&gt; instance using the closure we get in &lt;code&gt;execute&lt;/code&gt;, we send that job down the sending end of the channel. We&amp;rsquo;re calling &lt;code&gt;unwrap&lt;/code&gt; on &lt;code&gt;send&lt;/code&gt; for the case that sending fails. This might happen if, for example, we stop all our threads from executing, meaning the receiving end has stopped receiving new messages. At the moment, we can&amp;rsquo;t stop our threads from executing: our threads continue executing as long as the pool exists. The reason we use &lt;code&gt;unwrap&lt;/code&gt; is that we know the failure case won&amp;rsquo;t happen, but the compiler doesn&amp;rsquo;t know that.</source>
          <target state="translated">우리가 &lt;code&gt;execute&lt;/code&gt; 에 넣은 클로저를 사용하여 새로운 &lt;code&gt;Job&lt;/code&gt; 인스턴스를 생성 한 후 , 우리는 해당 작업을 채널의 전송 끝으로 보냅니다. 전송이 실패한 경우 &lt;code&gt;unwrap&lt;/code&gt; on &lt;code&gt;send&lt;/code&gt; 를 호출 합니다. 예를 들어 모든 스레드의 실행을 중지하면 수신 측에서 새 메시지 수신을 중지 한 경우에 발생할 수 있습니다. 현재 스레드 실행을 중지 할 수 없습니다. 풀이 존재하는 한 스레드가 계속 실행됩니다. 우리가 &lt;code&gt;unwrap&lt;/code&gt; 을 사용하는 이유는 실패 사례가 발생하지 않는다는 것을 알고 컴파일러가 그것을 알지 못하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="458779f7008edf7b181827b22b99edf77f39bc41" translate="yes" xml:space="preserve">
          <source>After dropping the lock, we can print the mutex value and see that we were able to change the inner &lt;code&gt;i32&lt;/code&gt; to 6.</source>
          <target state="translated">잠금을 해제 한 후 뮤텍스 값을 인쇄하고 내부 &lt;code&gt;i32&lt;/code&gt; 를 6 으로 변경할 수 있음을 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="04760e628105c26e60bea171285ea7fc05de2cc2" translate="yes" xml:space="preserve">
          <source>After implementing the trait, we can call the methods on instances of &lt;code&gt;NewsArticle&lt;/code&gt; and &lt;code&gt;Tweet&lt;/code&gt; in the same way we call regular methods, like this:</source>
          <target state="translated">특성을 구현 한 후에는 다음 과 같이 일반 메소드를 호출하는 것과 같은 방식으로 &lt;code&gt;NewsArticle&lt;/code&gt; 및 &lt;code&gt;Tweet&lt;/code&gt; 의 인스턴스에서 메소드를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a81464f303d05310b655ad576139ba2eadc374a" translate="yes" xml:space="preserve">
          <source>After learning about the &lt;code&gt;while let&lt;/code&gt; loop in Chapter 18, you might be wondering why we didn&amp;rsquo;t write the worker thread code as shown in Listing 20-22.</source>
          <target state="translated">18 장에서 &lt;code&gt;while let&lt;/code&gt; 루프에 대해 배운 후 Listing 20-22에 표시된 것처럼 작업자 스레드 코드를 작성하지 않은 이유가 궁금 할 것이다.</target>
        </trans-unit>
        <trans-unit id="56e7d653965ec5efdfa2c953ebd2075ad09eb04a" translate="yes" xml:space="preserve">
          <source>After running the code, the precedence behavior is evident: if the match guard were applied only to the final value in the list of values specified using the &lt;code&gt;|&lt;/code&gt; operator, the arm would have matched and the program would have printed &lt;code&gt;yes&lt;/code&gt;.</source>
          <target state="translated">코드를 실행 한 후 우선 순위 동작이 분명합니다. &lt;code&gt;|&lt;/code&gt; 운전자는 팔이 맞았을 것이고 프로그램은 &lt;code&gt;yes&lt;/code&gt; 를 인쇄했을 것이다 .</target>
        </trans-unit>
        <trans-unit id="6918a63768fd69dd2401af6cba199a57c7c6b4f3" translate="yes" xml:space="preserve">
          <source>After some time, once Rust developers who use nightly releases have been able to try out the new feature, team members will discuss the feature, how it&amp;rsquo;s worked out on nightly, and decide if it should make it into stable Rust or not. If the decision is to move forward, the feature gate is removed, and the feature is now considered stable! It rides the trains into a new stable release of Rust.</source>
          <target state="translated">일정 시간이 지난 후 야간 릴리스를 사용하는 Rust 개발자가 새로운 기능을 시험해 볼 수있게되면 팀 구성원은이 기능에 대해 논의하고 야간에 어떻게 작동했는지를 확인하고 안정적인 녹으로 만들어야하는지 여부를 결정합니다. 결정이 앞으로 진행되면 형상 게이트가 제거되고 형상이 안정된 것으로 간주됩니다! 열차를 타고 Rust의 새로운 안정적인 릴리스로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="780f735c7776bf172259bb14b7f1d801e95b8329" translate="yes" xml:space="preserve">
          <source>After that statement, we&amp;rsquo;ve again added a temporary &lt;code&gt;println!&lt;/code&gt; statement that prints the value of &lt;code&gt;contents&lt;/code&gt; after the file is read, so we can check that the program is working so far.</source>
          <target state="translated">그 진술 후에 우리는 다시 일시적인 &lt;code&gt;println!&lt;/code&gt; 추가했습니다 ! 파일을 읽은 후 &lt;code&gt;contents&lt;/code&gt; 의 값을 인쇄하는 명령문 이므로 지금까지 프로그램이 작동하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96e831200e66693625317e3844fc1e89f068a7a9" translate="yes" xml:space="preserve">
          <source>After the method signature, instead of providing an implementation within curly brackets, we use a semicolon. Each type implementing this trait must provide its own custom behavior for the body of the method. The compiler will enforce that any type that has the &lt;code&gt;Summary&lt;/code&gt; trait will have the method &lt;code&gt;summarize&lt;/code&gt; defined with this signature exactly.</source>
          <target state="translated">메소드 서명 후 중괄호 안에 구현을 제공하는 대신 세미콜론을 사용합니다. 이 특성을 구현하는 각 유형은 메소드 본문에 대해 고유 한 사용자 정의 동작을 제공해야합니다. 컴파일러는 &lt;code&gt;Summary&lt;/code&gt; 특성이있는 모든 유형 에이 서명으로 정의 된 메소드 &lt;code&gt;summarize&lt;/code&gt; 정확하게 갖도록 강제합니다 .</target>
        </trans-unit>
        <trans-unit id="fd61e6cd4b0dca5587c3bdc8b19a36c54df5d01a" translate="yes" xml:space="preserve">
          <source>After the parameters, we place curly brackets that hold the body of the closure&amp;mdash;these are optional if the closure body is a single expression. The end of the closure, after the curly brackets, needs a semicolon to complete the &lt;code&gt;let&lt;/code&gt; statement. The value returned from the last line in the closure body (&lt;code&gt;num&lt;/code&gt;) will be the value returned from the closure when it&amp;rsquo;s called, because that line doesn&amp;rsquo;t end in a semicolon; just as in function bodies.</source>
          <target state="translated">매개 변수 뒤에는 클로저 바디를 고정하는 중괄호를 배치합니다. 클로저 바디가 단일 표현식 인 경우 선택적입니다. 중괄호 뒤에있는 클로저 끝에는 &lt;code&gt;let&lt;/code&gt; 문 을 완료하기 위해 세미콜론이 필요합니다 . 클로저 본문 ( &lt;code&gt;num&lt;/code&gt; ) 의 마지막 라인에서 반환 된 값은 호출 될 때 클로저에서 반환 된 값입니다. 해당 라인은 세미콜론으로 끝나지 않기 때문입니다. 함수 본문에서와 같이.</target>
        </trans-unit>
        <trans-unit id="3409f581311196341ada32cc2fb23895a79e2d64" translate="yes" xml:space="preserve">
          <source>After the request line, the remaining lines starting from &lt;code&gt;Host:&lt;/code&gt; onward are headers. &lt;code&gt;GET&lt;/code&gt; requests have no body.</source>
          <target state="translated">요청 라인 다음에 &lt;code&gt;Host:&lt;/code&gt; 부터 시작하는 나머지 라인 은 헤더입니다. &lt;code&gt;GET&lt;/code&gt; 요청에는 본문이 없습니다.</target>
        </trans-unit>
        <trans-unit id="94ada77990e54a7199b314d48e7c28b8866c26f5" translate="yes" xml:space="preserve">
          <source>After these two lines, &lt;code&gt;s&lt;/code&gt; will contain &lt;code&gt;foobar&lt;/code&gt;. The &lt;code&gt;push_str&lt;/code&gt; method takes a string slice because we don&amp;rsquo;t necessarily want to take ownership of the parameter. For example, the code in Listing 8-16 shows that it would be unfortunate if we weren&amp;rsquo;t able to use &lt;code&gt;s2&lt;/code&gt; after appending its contents to &lt;code&gt;s1&lt;/code&gt;.</source>
          <target state="translated">이 두 줄 뒤에 &lt;code&gt;s&lt;/code&gt; 에는 &lt;code&gt;foobar&lt;/code&gt; 가 포함 됩니다. &lt;code&gt;push_str&lt;/code&gt; 의 우리가 반드시 매개 변수의 소유권을 싶지 않기 때문에 방법은 문자열 조각을합니다. 예를 들어, 목록 8-16의 코드 는 내용을 &lt;code&gt;s1&lt;/code&gt; 에 추가 한 후 &lt;code&gt;s2&lt;/code&gt; 를 사용할 수 없으면 불행한 것임을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="d28bc7bf7124bb617821696b52f238bf37faf9be" translate="yes" xml:space="preserve">
          <source>After they have been consumed, the rest of the elements are yielded. Rather than overriding this method directly, instead override the &lt;code&gt;nth&lt;/code&gt; method.</source>
          <target state="translated">그것들이 소비 된 후에, 나머지 요소들이 산출됩니다. 이 메소드를 직접 대체하는 대신, &lt;code&gt;nth&lt;/code&gt; 메소드 를 대체하십시오 .</target>
        </trans-unit>
        <trans-unit id="17378b2abc480d099ee902b5db16470e7091ec08" translate="yes" xml:space="preserve">
          <source>After updating the registry, Cargo checks the &lt;code&gt;[dependencies]&lt;/code&gt; section and downloads any crates you don&amp;rsquo;t have yet. In this case, although we only listed &lt;code&gt;rand&lt;/code&gt; as a dependency, Cargo also grabbed a copy of &lt;code&gt;libc&lt;/code&gt;, because &lt;code&gt;rand&lt;/code&gt; depends on &lt;code&gt;libc&lt;/code&gt; to work. After downloading the crates, Rust compiles them and then compiles the project with the dependencies available.</source>
          <target state="translated">레지스트리를 업데이트 한 후 Cargo는 &lt;code&gt;[dependencies]&lt;/code&gt; 섹션을 확인하고 아직없는 상자를 다운로드합니다. 이 경우 &lt;code&gt;rand&lt;/code&gt; 를 의존성으로 만 나열했지만 Cargo는 &lt;code&gt;rand&lt;/code&gt; 가 작동하기 위해 &lt;code&gt;libc&lt;/code&gt; 에 의존 하기 때문에 &lt;code&gt;libc&lt;/code&gt; 사본 을 가져 왔습니다. 상자를 다운로드 한 후 Rust는 상자를 컴파일 한 다음 사용 가능한 종속성으로 프로젝트를 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="9d98c1489e41fbd88598871e5f8d212bbc3f78c5" translate="yes" xml:space="preserve">
          <source>After we define &lt;code&gt;summarize_author&lt;/code&gt;, we can call &lt;code&gt;summarize&lt;/code&gt; on instances of the &lt;code&gt;Tweet&lt;/code&gt; struct, and the default implementation of &lt;code&gt;summarize&lt;/code&gt; will call the definition of &lt;code&gt;summarize_author&lt;/code&gt; that we&amp;rsquo;ve provided. Because we&amp;rsquo;ve implemented &lt;code&gt;summarize_author&lt;/code&gt;, the &lt;code&gt;Summary&lt;/code&gt; trait has given us the behavior of the &lt;code&gt;summarize&lt;/code&gt; method without requiring us to write any more code.</source>
          <target state="translated">우리가 정의한 후 &lt;code&gt;summarize_author&lt;/code&gt; 을 , 우리는 호출 할 수 있습니다 &lt;code&gt;summarize&lt;/code&gt; 의 인스턴스 &lt;code&gt;Tweet&lt;/code&gt; 구조체, 그리고 기본 구현 &lt;code&gt;summarize&lt;/code&gt; 의 정의 호출 &lt;code&gt;summarize_author&lt;/code&gt; 우리가 제공 한 것으로합니다. 우리가 구현 한 때문에 &lt;code&gt;summarize_author&lt;/code&gt; 을 의 &lt;code&gt;Summary&lt;/code&gt; 특성은 우리의 행동 주신 &lt;code&gt;summarize&lt;/code&gt; 더 이상 코드를 작성하는 우리를 필요로하지 않고 방법을.</target>
        </trans-unit>
        <trans-unit id="2556b8fd31ff1260ec94fc2ed10873de0af61a38" translate="yes" xml:space="preserve">
          <source>After we&amp;rsquo;ve acquired the lock, we can treat the return value, named &lt;code&gt;num&lt;/code&gt; in this case, as a mutable reference to the data inside. The type system ensures that we acquire a lock before using the value in &lt;code&gt;m&lt;/code&gt;: &lt;code&gt;Mutex&amp;lt;i32&amp;gt;&lt;/code&gt; is not an &lt;code&gt;i32&lt;/code&gt;, so we &lt;em&gt;must&lt;/em&gt; acquire the lock to be able to use the &lt;code&gt;i32&lt;/code&gt; value. We can&amp;rsquo;t forget; the type system won&amp;rsquo;t let us access the inner &lt;code&gt;i32&lt;/code&gt; otherwise.</source>
          <target state="translated">잠금을 얻은 후에는 이 경우 &lt;code&gt;num&lt;/code&gt; 이라는 반환 값을 내부 데이터에 대한 변경 가능한 참조로 처리 할 수 ​​있습니다. 우리가 값을 사용하기 전에 잠금을 획득하는 유형의 시스템 보장하지만 &lt;code&gt;m&lt;/code&gt; : &lt;code&gt;Mutex&amp;lt;i32&amp;gt;&lt;/code&gt; 하지 &lt;code&gt;i32&lt;/code&gt; 우리가 있도록 &lt;em&gt;해야한다&lt;/em&gt; 사용 할 수 있도록 잠금을 획득 &lt;code&gt;i32&lt;/code&gt; 값입니다. 우리는 잊을 수 없다. 타입 시스템은 그렇지 않으면 내부 &lt;code&gt;i32&lt;/code&gt; 에 액세스 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="eea76bdbc5658f7fad1ad625716859e45f8c384f" translate="yes" xml:space="preserve">
          <source>After we&amp;rsquo;ve created &lt;em&gt;tests/common/mod.rs&lt;/em&gt;, we can use it from any of the integration test files as a module. Here&amp;rsquo;s an example of calling the &lt;code&gt;setup&lt;/code&gt; function from the &lt;code&gt;it_adds_two&lt;/code&gt; test in &lt;em&gt;tests/integration_test.rs&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;tests / common / mod.rs를&lt;/em&gt; 만든 후에는 통합 테스트 파일에서 모듈로 사용할 수 있습니다. &lt;em&gt;tests / integration_test.rs&lt;/em&gt; 의 &lt;code&gt;it_adds_two&lt;/code&gt; 테스트에서 &lt;code&gt;setup&lt;/code&gt; 함수를 호출하는 예는 다음과 같습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="43dc84fb12e1a579a9d73c911c37d0ab1b82a9f5" translate="yes" xml:space="preserve">
          <source>After we&amp;rsquo;ve created the lists in &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, we add 10 to the value in &lt;code&gt;value&lt;/code&gt;. We do this by calling &lt;code&gt;borrow_mut&lt;/code&gt; on &lt;code&gt;value&lt;/code&gt;, which uses the automatic dereferencing feature we discussed in Chapter 5 (see the section &lt;a href=&quot;ch05-03-method-syntax#wheres-the---operator&quot;&gt;&amp;ldquo;Where&amp;rsquo;s the &lt;code&gt;-&amp;gt;&lt;/code&gt; Operator?&amp;rdquo;&lt;/a&gt;) to dereference the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to the inner &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; value. The &lt;code&gt;borrow_mut&lt;/code&gt; method returns a &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; smart pointer, and we use the dereference operator on it and change the inner value.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;c&lt;/code&gt; 로 목록을 만든 후에 value의 값에 10을 추가 &lt;code&gt;value&lt;/code&gt; . &lt;code&gt;borrow_mut&lt;/code&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 를 내부 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 값 으로 역 참조하기 위해 5 장에서 논의한 자동 역 참조 기능 ( &lt;a href=&quot;ch05-03-method-syntax#wheres-the---operator&quot;&gt;&quot; &lt;/a&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; 연산자 는 어디에 있습니까 ?&quot; 섹션 참조)을 사용 하는 wonre_mut on &lt;code&gt;value&lt;/code&gt; 를 호출 하여 이를 수행합니다 . &lt;code&gt;borrow_mut&lt;/code&gt; 에 있어서 리턴 &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; 스마트 포인터, 우리는 그것을 참조 연산자를 사용하여 내부 값을 변경.</target>
        </trans-unit>
        <trans-unit id="b18bd157b258782bdf4328d729095843e56901f9" translate="yes" xml:space="preserve">
          <source>After writing a lot of Rust code, the Rust team found that Rust programmers were entering the same lifetime annotations over and over in particular situations. These situations were predictable and followed a few deterministic patterns. The developers programmed these patterns into the compiler&amp;rsquo;s code so the borrow checker could infer the lifetimes in these situations and wouldn&amp;rsquo;t need explicit annotations.</source>
          <target state="translated">많은 Rust 코드를 작성한 후, Rust 팀은 Rust 프로그래머가 특정 상황에서 반복해서 동일한 수명 주석을 입력하고 있음을 발견했습니다. 이러한 상황은 예측 가능했으며 몇 가지 결정적인 패턴을 따랐습니다. 개발자는 이러한 패턴을 컴파일러 코드에 프로그래밍하여 차용 검사기가 이러한 상황에서 수명을 추론 할 수 있으며 명시적인 주석이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8911f4e8942ad7726d100e32781ae750b7e4baf7" translate="yes" xml:space="preserve">
          <source>After you&amp;rsquo;ve installed Rust via &lt;code&gt;rustup&lt;/code&gt;, updating to the latest version is easy. From your shell, run the following update script:</source>
          <target state="translated">&lt;code&gt;rustup&lt;/code&gt; 을 통해 Rust를 설치 한 후 최신 버전으로 쉽게 업데이트 할 수 있습니다. 쉘에서 다음 업데이트 스크립트를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="13f2d652f70945cb85fc5562fc3600a535ffb359" translate="yes" xml:space="preserve">
          <source>After:</source>
          <target state="translated">After:</target>
        </trans-unit>
        <trans-unit id="1d0c9f96248d537407790c171b6d4f7cd1fd7157" translate="yes" xml:space="preserve">
          <source>Again, this is the simplest implementation of the &lt;code&gt;execute&lt;/code&gt; method: it does nothing, but we&amp;rsquo;re trying only to make our code compile. Let&amp;rsquo;s check it again:</source>
          <target state="translated">다시 말하지만, 이것은 &lt;code&gt;execute&lt;/code&gt; 메소드 의 가장 간단한 구현입니다. 아무것도하지 않지만 코드를 컴파일하려고합니다. 다시 확인해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="7b6d0c4005bedf77e43140c67158dc3c2786f272" translate="yes" xml:space="preserve">
          <source>Again, we&amp;rsquo;re using &lt;code&gt;thread::spawn&lt;/code&gt; to create a new thread and then using &lt;code&gt;move&lt;/code&gt; to move &lt;code&gt;tx&lt;/code&gt; into the closure so the spawned thread owns &lt;code&gt;tx&lt;/code&gt;. The spawned thread needs to own the transmitting end of the channel to be able to send messages through the channel.</source>
          <target state="translated">다시, 우리는 &lt;code&gt;thread::spawn&lt;/code&gt; 을 사용하여 새 스레드를 만든 다음 &lt;code&gt;move&lt;/code&gt; 를 사용하여 &lt;code&gt;tx&lt;/code&gt; 를 클로저로 이동 시켜 생성 된 스레드가 &lt;code&gt;tx&lt;/code&gt; 를 소유 합니다. 생성 된 스레드는 채널을 통해 메시지를 보낼 수 있으려면 채널의 전송 끝을 소유해야합니다.</target>
        </trans-unit>
        <trans-unit id="42935bf9ba7e07a25a52edfb6e2d38809a0c1bab" translate="yes" xml:space="preserve">
          <source>Again, you need not specify the full type if the compiler can infer it:</source>
          <target state="translated">컴파일러가 유추 할 수있는 경우 전체 유형을 지정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3cc0e9834230ccbe94275d501fa3b8e31c8d1c62" translate="yes" xml:space="preserve">
          <source>Aha! The first error message indicates that &lt;code&gt;counter&lt;/code&gt; is moved into the closure for the thread associated with &lt;code&gt;handle&lt;/code&gt;. That move is preventing us from capturing &lt;code&gt;counter&lt;/code&gt; when we try to call &lt;code&gt;lock&lt;/code&gt; on it and store the result in &lt;code&gt;num2&lt;/code&gt; in the second thread! So Rust is telling us that we can&amp;rsquo;t move ownership of &lt;code&gt;counter&lt;/code&gt; into multiple threads. This was hard to see earlier because our threads were in a loop, and Rust can&amp;rsquo;t point to different threads in different iterations of the loop. Let&amp;rsquo;s fix the compiler error with a multiple-ownership method we discussed in Chapter 15.</source>
          <target state="translated">아하! 첫 번째 오류 메시지는 &lt;code&gt;counter&lt;/code&gt; 가 &lt;code&gt;handle&lt;/code&gt; 과 연관된 스레드의 클로저로 이동 되었음을 나타냅니다 . 이로 인해 &lt;code&gt;lock&lt;/code&gt; 을 호출 하고 결과를 두 번째 스레드의 &lt;code&gt;num2&lt;/code&gt; 에 저장할 때 &lt;code&gt;counter&lt;/code&gt; 를 캡처하지 못하게 됩니다 ! 따라서 Rust는 &lt;code&gt;counter&lt;/code&gt; 소유권 을 여러 스레드로 옮길 수 없다고 말합니다 . 우리의 스레드가 루프에 있었기 때문에 이전에보기 어려웠으며 Rust는 루프의 다른 반복에서 다른 스레드를 가리킬 수 없습니다. 15 장에서 논의한 다중 소유권 방법으로 컴파일러 오류를 수정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="7f8c5176c3f03b97659161923f2b6492f7de7e73" translate="yes" xml:space="preserve">
          <source>Alignment</source>
          <target state="translated">Alignment</target>
        </trans-unit>
        <trans-unit id="6c230b19ce360dc47ab1f803ec5d75221398ff9e" translate="yes" xml:space="preserve">
          <source>Alignment::borrow</source>
          <target state="translated">Alignment::borrow</target>
        </trans-unit>
        <trans-unit id="77b6c3d761057550ac535096603085a4ab21f25d" translate="yes" xml:space="preserve">
          <source>Alignment::borrow_mut</source>
          <target state="translated">Alignment::borrow_mut</target>
        </trans-unit>
        <trans-unit id="d45a68b20b4cc6114f5421add49178bf870ce27b" translate="yes" xml:space="preserve">
          <source>Alignment::fmt</source>
          <target state="translated">Alignment::fmt</target>
        </trans-unit>
        <trans-unit id="0912a9a905355e3a6df915cce4fce3e26fba4e82" translate="yes" xml:space="preserve">
          <source>Alignment::from</source>
          <target state="translated">Alignment::from</target>
        </trans-unit>
        <trans-unit id="14750a6b1eb92c0620b2d52bd702a109608e9cb3" translate="yes" xml:space="preserve">
          <source>Alignment::into</source>
          <target state="translated">Alignment::into</target>
        </trans-unit>
        <trans-unit id="b06fe916f5f193304938aca87ce9baf4fe4a81c0" translate="yes" xml:space="preserve">
          <source>Alignment::try_from</source>
          <target state="translated">Alignment::try_from</target>
        </trans-unit>
        <trans-unit id="7e4c9d31924344ef62791e3f5778cc0b64650841" translate="yes" xml:space="preserve">
          <source>Alignment::try_into</source>
          <target state="translated">Alignment::try_into</target>
        </trans-unit>
        <trans-unit id="f8d85378f8bd14502ad4a535bf35eace323f7be0" translate="yes" xml:space="preserve">
          <source>Alignment::type_id</source>
          <target state="translated">Alignment::type_id</target>
        </trans-unit>
        <trans-unit id="1f13dd31cf3795018ba8cb51097f5cee92e51d26" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;items&quot;&gt;item declarations&lt;/a&gt; accept outer attributes while &lt;a href=&quot;items/external-blocks&quot;&gt;external blocks&lt;/a&gt;, &lt;a href=&quot;items/functions&quot;&gt;functions&lt;/a&gt;, &lt;a href=&quot;items/implementations&quot;&gt;implementations&lt;/a&gt;, and &lt;a href=&quot;items/modules&quot;&gt;modules&lt;/a&gt; accept inner attributes.</source>
          <target state="translated">모든 &lt;a href=&quot;items&quot;&gt;항목 선언&lt;/a&gt; 은 외부 속성을 허용하는 반면 &lt;a href=&quot;items/external-blocks&quot;&gt;외부 블록&lt;/a&gt; , &lt;a href=&quot;items/functions&quot;&gt;함수&lt;/a&gt; , &lt;a href=&quot;items/implementations&quot;&gt;구현&lt;/a&gt; 및 &lt;a href=&quot;items/modules&quot;&gt;모듈&lt;/a&gt; 은 내부 속성을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="e7edfb23f380c12b821737c77295267e0d55adfa" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;if&lt;/code&gt; expressions start with the keyword &lt;code&gt;if&lt;/code&gt;, which is followed by a condition. In this case, the condition checks whether or not the variable &lt;code&gt;number&lt;/code&gt; has a value less than 5. The block of code we want to execute if the condition is true is placed immediately after the condition inside curly brackets. Blocks of code associated with the conditions in &lt;code&gt;if&lt;/code&gt; expressions are sometimes called &lt;em&gt;arms&lt;/em&gt;, just like the arms in &lt;code&gt;match&lt;/code&gt; expressions that we discussed in the &lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;&amp;ldquo;Comparing the Guess to the Secret Number&amp;rdquo;&lt;/a&gt; section of Chapter 2.</source>
          <target state="translated">모든 &lt;code&gt;if&lt;/code&gt; 표현식은 키워드 &lt;code&gt;if&lt;/code&gt; 로 시작하며 그 뒤에 조건이옵니다. 이 경우 조건은 변수 &lt;code&gt;number&lt;/code&gt; 의 값이 5보다 작은 지 여부를 확인합니다 . 조건이 true 인 경우 실행하려는 코드 블록은 조건 뒤에 중괄호 안에 배치됩니다. 의 조건과 관련된 코드 블록 &lt;code&gt;if&lt;/code&gt; 표현이라고도하는 &lt;em&gt;무기&lt;/em&gt; 그냥 팔처럼, &lt;code&gt;match&lt;/code&gt; 우리가 논의 것을 표현 &lt;a href=&quot;ch02-00-guessing-game-tutorial#comparing-the-guess-to-the-secret-number&quot;&gt;&quot;비밀 번호에 맞춰 비교&quot;&lt;/a&gt; 장 2 절.</target>
        </trans-unit>
        <trans-unit id="6d770608aae868ce44cc837cd9b78c8161bf1b4b" translate="yes" xml:space="preserve">
          <source>All ASCII</source>
          <target state="translated">모든 ASCII</target>
        </trans-unit>
        <trans-unit id="941b268ba2f8b2e2bf50827de379fcc106a7ae00" translate="yes" xml:space="preserve">
          <source>All Rust compiler versions support any edition that existed prior to that compiler&amp;rsquo;s release, and they can link crates of any supported editions together. Edition changes only affect the way the compiler initially parses code. Therefore, if you&amp;rsquo;re using Rust 2015 and one of your dependencies uses Rust 2018, your project will compile and be able to use that dependency. The opposite situation, where your project uses Rust 2018 and a dependency uses Rust 2015, works as well.</source>
          <target state="translated">모든 Rust 컴파일러 버전은 해당 컴파일러의 릴리스 이전에 존재하는 모든 버전을 지원하며 지원되는 버전의 상자를 함께 연결할 수 있습니다. 에디션 변경 사항은 컴파일러가 코드를 처음 구문 분석하는 방식에만 영향을줍니다. 따라서 Rust 2015를 사용 중이고 종속성 중 하나가 Rust 2018을 사용하는 경우 프로젝트가 컴파일되어 해당 종속성을 사용할 수 있습니다. 프로젝트가 Rust 2018을 사용하고 종속성이 Rust 2015를 사용하는 반대 상황도 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7652c7eeda6497653864c68957d9fcd32bd3f053" translate="yes" xml:space="preserve">
          <source>All Unicode</source>
          <target state="translated">모든 유니 코드</target>
        </trans-unit>
        <trans-unit id="47de5609df925352bb65b1c68fe6d11ef3c5f11f" translate="yes" xml:space="preserve">
          <source>All Unicode characters contained in the raw string body represent themselves, the characters &lt;code&gt;U+0022&lt;/code&gt; (double-quote) (except when followed by at least as many &lt;code&gt;U+0023&lt;/code&gt; (&lt;code&gt;#&lt;/code&gt;) characters as were used to start the raw string literal) or &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) do not have any special meaning.</source>
          <target state="translated">원시 문자열 본문에 포함 된 모든 유니 코드 문자는 문자 &lt;code&gt;U+0022&lt;/code&gt; (큰 따옴표) ( 원시 문자열 리터럴을 시작하는 데 사용 된 &lt;code&gt;U+0023&lt;/code&gt; ( &lt;code&gt;#&lt;/code&gt; ) 문자 이상이 뒤에 오는 경우 제외 ) 또는 &lt;code&gt;U+005C&lt;/code&gt; 냅니다. + 005C ( &lt;code&gt;\&lt;/code&gt; )는 특별한 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8a1ba3bb13e8cd072a280ba55ff12cd4ec0faacf" translate="yes" xml:space="preserve">
          <source>All access to a static is safe, but there are a number of restrictions on statics:</source>
          <target state="translated">정적에 대한 모든 액세스는 안전하지만 정적에 대한 여러 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc4193fdbde0490cb6df1ff9fd4927655f61fac3" translate="yes" xml:space="preserve">
          <source>All access to the inner value through methods is &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">메소드를 통한 내부 가치에 대한 모든 접근은 &lt;code&gt;unsafe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ceb9b59e717209dd478129622af76401fc92a7ef" translate="yes" xml:space="preserve">
          <source>All accesses performed by functions in this module are &lt;em&gt;non-atomic&lt;/em&gt; in the sense of &lt;a href=&quot;../sync/atomic/index&quot;&gt;atomic operations&lt;/a&gt; used to synchronize between threads. This means it is undefined behavior to perform two concurrent accesses to the same location from different threads unless both accesses only read from memory. Notice that this explicitly includes &lt;a href=&quot;fn.read_volatile&quot;&gt;&lt;code&gt;read_volatile&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.write_volatile&quot;&gt;&lt;code&gt;write_volatile&lt;/code&gt;&lt;/a&gt;: Volatile accesses cannot be used for inter-thread synchronization.</source>
          <target state="translated">이 모듈의 기능을 수행하는 모든 액세스는 &lt;em&gt;비 원자&lt;/em&gt; 의 의미 &lt;a href=&quot;../sync/atomic/index&quot;&gt;원자 연산&lt;/a&gt; 스레드 간의 동기화에 사용된다. 이는 두 액세스가 모두 메모리에서 읽지 않는 한 다른 스레드에서 동일한 위치에 대한 두 개의 동시 액세스를 수행하는 것은 정의되지 않은 동작임을 의미합니다. 여기에는 명시 적으로 &lt;a href=&quot;fn.read_volatile&quot;&gt; &lt;code&gt;read_volatile&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;fn.write_volatile&quot;&gt; &lt;code&gt;write_volatile&lt;/code&gt; &lt;/a&gt; 이 포함됩니다 . 휘발성 액세스는 스레드 간 동기화에 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5d3e246179e6158acb2b336b6eaaa6c3cd96b12d" translate="yes" xml:space="preserve">
          <source>All amortized costs are for the potential need to resize when capacity is exhausted. If a resize occurs it will take O(n) time. Our collections never automatically shrink, so removal operations aren't amortized. Over a sufficiently large series of operations, the average cost per operation will deterministically equal the given cost.</source>
          <target state="translated">상각 된 모든 비용은 용량이 소진 될 때 크기를 조정해야 할 필요가 있습니다. 크기 조정이 발생하면 O (n) 시간이 걸립니다. Google의 컬렉션은 자동으로 축소되지 않으므로 제거 작업이 상각되지 않습니다. 충분히 큰 일련의 작업에서 평균 작업 당 비용은 주어진 비용과 결정적으로 동일합니다.</target>
        </trans-unit>
        <trans-unit id="ad40505a1a509d19ac8713b0e6d72bf2f8406439" translate="yes" xml:space="preserve">
          <source>All associated functions must either have a &lt;code&gt;where Self: Sized&lt;/code&gt; bound, or</source>
          <target state="translated">모든 관련 함수 &lt;code&gt;where Self: Sized&lt;/code&gt; 제한 이 있어야합니다 . 또는</target>
        </trans-unit>
        <trans-unit id="15061bca973f1e3bdfd6bc4220f487a4d9f0fa2e" translate="yes" xml:space="preserve">
          <source>All atomic types in this module are guaranteed to be &lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm&quot;&gt;lock-free&lt;/a&gt; if they're available. This means they don't internally acquire a global mutex. Atomic types and operations are not guaranteed to be wait-free. This means that operations like &lt;code&gt;fetch_or&lt;/code&gt; may be implemented with a compare-and-swap loop.</source>
          <target state="translated">이 모듈의 모든 원자 유형 은 사용 가능한 경우 &lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm&quot;&gt;잠금이없는&lt;/a&gt; 것으로 보장됩니다 . 이것은 내부적으로 글로벌 뮤텍스를 얻지 않는다는 것을 의미합니다. 원자 유형과 작업이 대기 시간을 보장하지는 않습니다. 이것은 &lt;code&gt;fetch_or&lt;/code&gt; 와 같은 연산이 비교 및 스왑 루프로 구현 될 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="290ed2d52fa06b05e83bf6a12f1d4aa3dca7ba7c" translate="yes" xml:space="preserve">
          <source>All binaries installed with &lt;code&gt;cargo install&lt;/code&gt; are stored in the installation root&amp;rsquo;s &lt;em&gt;bin&lt;/em&gt; folder. If you installed Rust using &lt;em&gt;rustup.rs&lt;/em&gt; and don&amp;rsquo;t have any custom configurations, this directory will be &lt;em&gt;$HOME/.cargo/bin&lt;/em&gt;. Ensure that directory is in your &lt;code&gt;$PATH&lt;/code&gt; to be able to run programs you&amp;rsquo;ve installed with &lt;code&gt;cargo install&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cargo install&lt;/code&gt; 와 함께 설치된 모든 바이너리 는 설치 루트의 &lt;em&gt;bin&lt;/em&gt; 폴더에 저장됩니다. &lt;em&gt;rustup.rs를&lt;/em&gt; 사용하여 Rust를 설치 &lt;em&gt;했고&lt;/em&gt; 사용자 정의 구성이없는 경우이 디렉토리는 &lt;em&gt;$ HOME / .cargo / bin&lt;/em&gt; 입니다. &lt;code&gt;cargo install&lt;/code&gt; 로 설치 한 프로그램을 실행할 수 있도록 디렉토리가 &lt;code&gt;$PATH&lt;/code&gt; 에 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="33d170f2503ad727df2773d3d501af5a7c6f33f7" translate="yes" xml:space="preserve">
          <source>All boolean operators except for &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; which are banned since they are short-circuiting.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;||&lt;/code&gt; 를 제외한 모든 부울 연산자 단락되어 금지되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1797e85af758baa0954345dbaa6c305b8c789f74" translate="yes" xml:space="preserve">
          <source>All bytes read from this source will be appended to the specified buffer &lt;code&gt;buf&lt;/code&gt;. This function will continuously call &lt;a href=&quot;trait.read#tymethod.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; to append more data to &lt;code&gt;buf&lt;/code&gt; until &lt;a href=&quot;trait.read#tymethod.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; returns either &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/a&gt; or an error of non-&lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; kind.</source>
          <target state="translated">이 소스에서 읽은 모든 바이트는 지정된 버퍼 &lt;code&gt;buf&lt;/code&gt; 에 추가됩니다 . 이 함수는 &lt;a href=&quot;trait.read#tymethod.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(0)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; 종류 의 오류를 반환 할 때까지 계속해서 &lt;a href=&quot;trait.read#tymethod.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 &lt;code&gt;buf&lt;/code&gt; 에 더 많은 데이터를 추가 합니다 .</target>
        </trans-unit>
        <trans-unit id="792e4e8c3b4454b76d09b3a55c5244a2a04987c6" translate="yes" xml:space="preserve">
          <source>All calls to &lt;code&gt;write&lt;/code&gt; on the returned instance will return &lt;code&gt;Ok(buf.len())&lt;/code&gt; and the contents of the buffer will not be inspected.</source>
          <target state="translated">모든 호출 &lt;code&gt;write&lt;/code&gt; 반환 된 인스턴스가 반환됩니다 &lt;code&gt;Ok(buf.len())&lt;/code&gt; 및 버퍼의 내용이 검사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="163ac7eae61cfe370b91ace9f314d434af91aec2" translate="yes" xml:space="preserve">
          <source>All characters contained in the raw string body represent their ASCII encoding, the characters &lt;code&gt;U+0022&lt;/code&gt; (double-quote) (except when followed by at least as many &lt;code&gt;U+0023&lt;/code&gt; (&lt;code&gt;#&lt;/code&gt;) characters as were used to start the raw string literal) or &lt;code&gt;U+005C&lt;/code&gt; (&lt;code&gt;\&lt;/code&gt;) do not have any special meaning.</source>
          <target state="translated">원시 문자열 본문에 포함 된 모든 문자는 ASCII 인코딩, 문자 &lt;code&gt;U+0022&lt;/code&gt; (큰 따옴표)를 나타냅니다 ( 원시 문자열 리터럴을 시작하는 데 사용 된 &lt;code&gt;U+0023&lt;/code&gt; ( &lt;code&gt;#&lt;/code&gt; ) 문자 이상이 뒤에 오는 경우 제외 ) 또는 &lt;code&gt;U+005C&lt;/code&gt; ( &lt;code&gt;\&lt;/code&gt; )는 특별한 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="43d6b6384605c36d010e25334a7b59d1666b30b5" translate="yes" xml:space="preserve">
          <source>All closure types implement &lt;a href=&quot;../special-types-and-traits#sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt;. Additionally, closure types implement the following traits if allowed to do so by the types of the captures it stores:</source>
          <target state="translated">모든 클로저 유형은 &lt;a href=&quot;../special-types-and-traits#sized&quot;&gt; &lt;code&gt;Sized&lt;/code&gt; 를&lt;/a&gt; 구현 합니다. 또한 클로저 유형은 저장하는 캡처 유형으로 허용되는 경우 다음 특성을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="a34254512b20b7c3c4f4d4cb8623d62bc5f25917" translate="yes" xml:space="preserve">
          <source>All crates have a &lt;em&gt;prelude&lt;/em&gt; that automatically inserts names from a specific module, the &lt;em&gt;prelude module&lt;/em&gt;, into scope of each &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt; and an &lt;a href=&quot;items/extern-crates&quot;&gt;&lt;code&gt;extern crate&lt;/code&gt;&lt;/a&gt; into the crate root module. By default, the &lt;em&gt;standard prelude&lt;/em&gt; is used. The linked crate is &lt;a href=&quot;../std/index&quot;&gt;&lt;code&gt;std&lt;/code&gt;&lt;/a&gt; and the prelude module is &lt;a href=&quot;../std/prelude/index&quot;&gt;&lt;code&gt;std::prelude::v1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모든 상자에는 특정 모듈 인 &lt;em&gt;prelude 모듈의&lt;/em&gt; 이름 을 각 &lt;a href=&quot;items/modules&quot;&gt;모듈의&lt;/a&gt; 범위에 , &lt;a href=&quot;items/extern-crates&quot;&gt; &lt;code&gt;extern crate&lt;/code&gt; &lt;/a&gt; 를 상자 루트 모듈에 자동으로 삽입 하는 &lt;em&gt;prelude&lt;/em&gt; 가 있습니다. 기본적으로 &lt;em&gt;표준 전주곡&lt;/em&gt; 이 사용됩니다. 연결된 크레이트는 &lt;a href=&quot;../std/index&quot;&gt; &lt;code&gt;std&lt;/code&gt; &lt;/a&gt; 이고 prelude 모듈은 &lt;a href=&quot;../std/prelude/index&quot;&gt; &lt;code&gt;std::prelude::v1&lt;/code&gt; &lt;/a&gt; 입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="80e6d9f67f0a7d01f6edd0112ce6e32390cc7b99" translate="yes" xml:space="preserve">
          <source>All currently blocked and future &lt;a href=&quot;../io/trait.read&quot;&gt;reads&lt;/a&gt; will return &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 차단 및 향후 &lt;a href=&quot;../io/trait.read&quot;&gt;읽기&lt;/a&gt; 는 모두 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(0)&lt;/code&gt; &lt;/a&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="a6d40cb983863467fc229fa6f4b9f265ef62418a" translate="yes" xml:space="preserve">
          <source>All currently blocked and future &lt;a href=&quot;../io/trait.write&quot;&gt;writes&lt;/a&gt; will return an error.</source>
          <target state="translated">현재 차단되고 향후 &lt;a href=&quot;../io/trait.write&quot;&gt;쓰기&lt;/a&gt; 는 모두 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b5ad10491502eb3084d1fb833cddef2d6e97c099" translate="yes" xml:space="preserve">
          <source>All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead. The heap is less organized: when you put data on the heap, you request a certain amount of space. The operating system finds an empty spot in the heap that is big enough, marks it as being in use, and returns a &lt;em&gt;pointer&lt;/em&gt;, which is the address of that location. This process is called &lt;em&gt;allocating on the heap&lt;/em&gt; and is sometimes abbreviated as just &lt;em&gt;allocating&lt;/em&gt;. Pushing values onto the stack is not considered allocating. Because the pointer is a known, fixed size, you can store the pointer on the stack, but when you want the actual data, you must follow the pointer.</source>
          <target state="translated">스택에 저장된 모든 데이터는 알려진 고정 크기를 가져야합니다. 컴파일 타임에 알 수없는 크기 또는 변경 될 수있는 크기의 데이터는 힙에 대신 저장해야합니다. 힙은 덜 체계적입니다. 힙에 데이터를 넣을 때 특정 공간을 요청합니다. 운영 체제는 힙에서 충분히 큰 빈 지점을 찾아서 사용중인 것으로 표시하고 해당 위치의 주소 인 &lt;em&gt;pointer를&lt;/em&gt; 반환합니다 . 이 과정은이라고 &lt;em&gt;힙에 할당&lt;/em&gt; 하고 때로는로 축약됩니다 &lt;em&gt;할당&lt;/em&gt; . 스택으로 값을 푸시하는 것은 할당으로 간주되지 않습니다. 포인터는 알려진 고정 크기이므로 포인터를 스택에 저장할 수 있지만 실제 데이터를 원할 경우 포인터를 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="c3ab61183db153bdcb93b3db49372bcfa15c64d0" translate="yes" xml:space="preserve">
          <source>All elements of arrays are always initialized, and access to an array is always bounds-checked in safe methods and operators.</source>
          <target state="translated">배열의 모든 요소는 항상 초기화되며 안전한 방법과 연산자로 배열에 대한 액세스를 항상 경계 검사합니다.</target>
        </trans-unit>
        <trans-unit id="7fbb5676d98408c23a91ee3e50ae6931e19803d3" translate="yes" xml:space="preserve">
          <source>All elements of slices are always initialized, and access to a slice is always bounds-checked in safe methods and operators.</source>
          <target state="translated">슬라이스의 모든 요소는 항상 초기화되며 슬라이스에 대한 액세스는 항상 안전한 방법과 연산자로 바운드 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="833e88d98de8f4240c961bc71bc4ebdf6caf04e8" translate="yes" xml:space="preserve">
          <source>All five array values appear in the terminal, as expected. Even though &lt;code&gt;index&lt;/code&gt; will reach a value of &lt;code&gt;5&lt;/code&gt; at some point, the loop stops executing before trying to fetch a sixth value from the array.</source>
          <target state="translated">예상대로 5 개의 배열 값이 모두 터미널에 나타납니다. &lt;code&gt;index&lt;/code&gt; 가 어느 시점에서 &lt;code&gt;5&lt;/code&gt; 의 값에 도달 하더라도 배열에서 여섯 번째 값을 가져 오기 전에 루프 실행이 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="e11d83f6e553be6952611c97ac05bbc3817eeae9" translate="yes" xml:space="preserve">
          <source>All four types of loop support &lt;a href=&quot;loop-expr#break-expressions&quot;&gt;&lt;code&gt;break&lt;/code&gt; expressions&lt;/a&gt;, &lt;a href=&quot;loop-expr#continue-expressions&quot;&gt;&lt;code&gt;continue&lt;/code&gt; expressions&lt;/a&gt;, and &lt;a href=&quot;loop-expr#loop-labels&quot;&gt;labels&lt;/a&gt;. Only &lt;code&gt;loop&lt;/code&gt; supports &lt;a href=&quot;loop-expr#break-and-loop-values&quot;&gt;evaluation to non-trivial values&lt;/a&gt;.</source>
          <target state="translated">네 가지 유형의 루프는 모두 &lt;a href=&quot;loop-expr#break-expressions&quot;&gt; &lt;code&gt;break&lt;/code&gt; 표현식&lt;/a&gt; , &lt;a href=&quot;loop-expr#continue-expressions&quot;&gt; &lt;code&gt;continue&lt;/code&gt; 표현식&lt;/a&gt; 및 &lt;a href=&quot;loop-expr#loop-labels&quot;&gt;레이블을 지원&lt;/a&gt; 합니다. &lt;code&gt;loop&lt;/code&gt; 만이 &lt;a href=&quot;loop-expr#break-and-loop-values&quot;&gt;사소한 값에 대한 평가를&lt;/a&gt; 지원 합니다 .</target>
        </trans-unit>
        <trans-unit id="0615d0c10f128d4e7e9a656552c9285eca738194" translate="yes" xml:space="preserve">
          <source>All function items implement &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../std/ops/trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모든 기능 항목은 &lt;a href=&quot;../../std/ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../std/ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../std/ops/trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; 를 구현&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c77d0720d55ff4ece3326614a73ddde6503e3179" translate="yes" xml:space="preserve">
          <source>All implementations of &lt;code&gt;Unsize&lt;/code&gt; are provided automatically by the compiler.</source>
          <target state="translated">&lt;code&gt;Unsize&lt;/code&gt; 의 모든 구현은 컴파일러에 의해 자동으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="94282a18d174676690037624bae4b4b406cb02ee" translate="yes" xml:space="preserve">
          <source>All iterators implement a trait named &lt;code&gt;Iterator&lt;/code&gt; that is defined in the standard library. The definition of the trait looks like this:</source>
          <target state="translated">모든 반복자 는 표준 라이브러리에 정의 된 &lt;code&gt;Iterator&lt;/code&gt; 라는 특성을 구현합니다 . 특성의 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7da42c45b54f4237c99325204711121b9f08beec" translate="yes" xml:space="preserve">
          <source>All kinds of ASCII whitespace are considered:</source>
          <target state="translated">모든 종류의 ASCII 공백이 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="3e530c202d9d3c48672f8f7b98a14e41befed3be" translate="yes" xml:space="preserve">
          <source>All kinds of whitespace are considered:</source>
          <target state="translated">모든 종류의 공백이 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="9c42bdece20642dd1d10ab718ff507235d349b8d" translate="yes" xml:space="preserve">
          <source>All layouts have an associated non-negative size and a power-of-two alignment.</source>
          <target state="translated">모든 레이아웃에는 음이 아닌 크기와 2의 거듭 제곱이 있습니다.</target>
        </trans-unit>
        <trans-unit id="32f70044558e382c5ebf59ec68e9d711cc2cb7b2" translate="yes" xml:space="preserve">
          <source>All of the coefficients get stored in registers, which means accessing the values is very fast. There are no bounds checks on the array access at runtime. All these optimizations that Rust is able to apply make the resulting code extremely efficient. Now that you know this, you can use iterators and closures without fear! They make code seem like it&amp;rsquo;s higher level but don&amp;rsquo;t impose a runtime performance penalty for doing so.</source>
          <target state="translated">모든 계수는 레지스터에 저장되므로 값에 액세스하는 것이 매우 빠릅니다. 런타임시 어레이 액세스에 대한 경계 검사가 없습니다. Rust가 적용 할 수있는 이러한 모든 최적화는 결과 코드를 매우 효율적으로 만듭니다. 이제 이것을 알았으므로 반복자와 클로저를 두려움없이 사용할 수 있습니다! 그것들은 코드를 더 높은 수준의 것처럼 보이게하지만 런타임 성능 저하를 부과하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="17dabbf042cc2454dd1f0ba98c8b7c6f3be65ec5" translate="yes" xml:space="preserve">
          <source>All of the logic that manages the counts and value dropping is built into &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; and their implementations of the &lt;code&gt;Drop&lt;/code&gt; trait. By specifying that the relationship from a child to its parent should be a &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; reference in the definition of &lt;code&gt;Node&lt;/code&gt;, you&amp;rsquo;re able to have parent nodes point to child nodes and vice versa without creating a reference cycle and memory leaks.</source>
          <target state="translated">카운트 및 값 삭제를 관리하는 모든 논리는 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 및 &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 및 해당 &lt;code&gt;Drop&lt;/code&gt; 특성 의 구현에 내장되어 있습니다. &lt;code&gt;Node&lt;/code&gt; 정의에서 자식 관계와 부모 관계가 &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 참조가되도록 지정 하면 참조주기와 메모리 누수를 만들지 않고도 부모 노드가 자식 노드를 가리 키거나 그 반대로 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="469c3254d30ae896569972fb8c0f6e762f31a91d" translate="yes" xml:space="preserve">
          <source>All of the standard collections provide several iterators for performing bulk manipulation of their contents. The three primary iterators almost every collection should provide are &lt;code&gt;iter&lt;/code&gt;, &lt;code&gt;iter_mut&lt;/code&gt;, and &lt;code&gt;into_iter&lt;/code&gt;. Some of these are not provided on collections where it would be unsound or unreasonable to provide them.</source>
          <target state="translated">모든 표준 콜렉션은 내용의 대량 조작을 수행하기 위해 여러 반복자를 제공합니다. 거의 모든 컬렉션이 제공해야하는 세 가지 주요 반복자는 &lt;code&gt;iter&lt;/code&gt; , &lt;code&gt;iter_mut&lt;/code&gt; 및 &lt;code&gt;into_iter&lt;/code&gt; 입니다. 이들 중 일부는 소리가 나지 않거나 불합리한 컬렉션에는 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7c09f50beeaa399a934ba76d5cc5d913f4961d31" translate="yes" xml:space="preserve">
          <source>All of these are valid &lt;code&gt;String&lt;/code&gt; values.</source>
          <target state="translated">이들은 모두 유효한 &lt;code&gt;String&lt;/code&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="3488f647e2016335e532591f4617d056149f656a" translate="yes" xml:space="preserve">
          <source>All of these method calls are possible because we specified how the &lt;code&gt;next&lt;/code&gt; method works, and the standard library provides default implementations for other methods that call &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;next&lt;/code&gt; 메소드의 작동 방식을 지정 하고 표준 라이브러리는 &lt;code&gt;next&lt;/code&gt; 를 호출하는 다른 메소드에 대한 기본 구현을 제공 하기 때문에 이러한 메소드 호출이 모두 가능 합니다 .</target>
        </trans-unit>
        <trans-unit id="2a8409870b71900361c6e9ce41cc4d8b31f5a720" translate="yes" xml:space="preserve">
          <source>All options are initially set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">모든 옵션은 처음에 &lt;code&gt;false&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="cec813890e4d07a2defc7bce522b39b7b6522a4d" translate="yes" xml:space="preserve">
          <source>All other arguments given to the &lt;code&gt;inline&lt;/code&gt; attribute will return this error. Example:</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; 속성에 제공된 다른 모든 인수 는이 오류를 반환합니다. 예:</target>
        </trans-unit>
        <trans-unit id="110d2b10be35d17317e6c561cf91a4fabbf8e826" translate="yes" xml:space="preserve">
          <source>All other characters are given hexadecimal Unicode escapes; see &lt;a href=&quot;#method.escape_unicode&quot;&gt;&lt;code&gt;escape_unicode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다른 모든 문자에는 16 진수 유니 코드 이스케이프가 제공됩니다. &lt;a href=&quot;#method.escape_unicode&quot;&gt; &lt;code&gt;escape_unicode&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f76ce538d07b9974a525f600e48b7f5dff4ae16c" translate="yes" xml:space="preserve">
          <source>All other fragment specifiers have no restrictions.</source>
          <target state="translated">다른 모든 조각 지정자는 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="fef84ba857bf1c83a92f8d5a5b2d52afc2b3c691" translate="yes" xml:space="preserve">
          <source>All pointers (except for the null pointer) are valid for all operations of &lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;size zero&lt;/a&gt;.</source>
          <target state="translated">모든 포인터 (널 포인터 제외)는 &lt;a href=&quot;https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts&quot;&gt;크기가 0 인&lt;/a&gt; 모든 작업에 유효 합니다 .</target>
        </trans-unit>
        <trans-unit id="bcec8da89ce19312f810d6e8b0a4c1c994af8c3f" translate="yes" xml:space="preserve">
          <source>All pointers in Rust are explicit first-class values. They can be moved or copied, stored into data structs, and returned from functions.</source>
          <target state="translated">Rust의 모든 포인터는 명시적인 일류 값입니다. 그것들은 이동 또는 복사, 데이터 구조체로 저장 및 함수에서 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a33c45e166bf3f976aac4c7eec793b7d8946ca1" translate="yes" xml:space="preserve">
          <source>All programmers strive to make their code easy to understand, but sometimes extra explanation is warranted. In these cases, programmers leave notes, or &lt;em&gt;comments&lt;/em&gt;, in their source code that the compiler will ignore but people reading the source code may find useful.</source>
          <target state="translated">모든 프로그래머는 코드를 이해하기 쉽도록 노력하지만 때로는 추가 설명이 필요합니다. 이 경우 프로그래머 는 소스 코드에 컴파일러가 무시하지만 소스 코드를 읽는 사람들이 유용 할 수 있다는 메모 나 &lt;em&gt;설명을&lt;/em&gt; 남깁니다 .</target>
        </trans-unit>
        <trans-unit id="aa0c879bcf5cab9e7f4749d5ede013d5bf918c1f" translate="yes" xml:space="preserve">
          <source>All programs have to manage the way they use a computer&amp;rsquo;s memory while running. Some languages have garbage collection that constantly looks for no longer used memory as the program runs; in other languages, the programmer must explicitly allocate and free the memory. Rust uses a third approach: memory is managed through a system of ownership with a set of rules that the compiler checks at compile time. None of the ownership features slow down your program while it&amp;rsquo;s running.</source>
          <target state="translated">모든 프로그램은 실행 중에 컴퓨터 메모리를 사용하는 방식을 관리해야합니다. 일부 언어에는 프로그램이 실행될 때 더 이상 사용되지 않는 메모리를 지속적으로 찾는 가비지 콜렉션이 있습니다. 다른 언어에서는 프로그래머가 명시 적으로 메모리를 할당하고 해제해야합니다. Rust는 세 번째 접근 방식을 사용합니다. 메모리는 컴파일러가 컴파일 타임에 확인하는 일련의 규칙으로 소유권 시스템을 통해 관리됩니다. 어떤 소유권 기능도 프로그램이 실행되는 동안 속도를 늦추지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cf610b10a23cb06f62489f071586a11ed04b1ece" translate="yes" xml:space="preserve">
          <source>All reads from the returned reader will return &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(0)&lt;/code&gt;.</source>
          <target state="translated">반환 된 판독기의 모든 판독 값은 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(0)&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="5edadac5bb39f603d58e3300e69ef3e103ed0e48" translate="yes" xml:space="preserve">
          <source>All reads from this reader will succeed by filling the specified buffer with the given byte.</source>
          <target state="translated">지정된 바이트로 지정된 버퍼를 채워이 판독기의 모든 읽기에 성공합니다.</target>
        </trans-unit>
        <trans-unit id="8042ca5a8b0159faa7d15d89ddf16924d0bee8ca" translate="yes" xml:space="preserve">
          <source>All results of &lt;code&gt;next()&lt;/code&gt; need to be identical to the results of &lt;code&gt;next_back()&lt;/code&gt; in reverse order.</source>
          <target state="translated">&lt;code&gt;next()&lt;/code&gt; 의 모든 결과는 &lt;code&gt;next_back()&lt;/code&gt; 의 결과와 역순 으로 동일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="051b0a6da7e5a99366866472afe4cedd9c4ae587" translate="yes" xml:space="preserve">
          <source>All strings that adhere to the following &lt;a href=&quot;https://www.w3.org/TR/REC-xml/#sec-notation&quot;&gt;EBNF&lt;/a&gt; grammar will result in an &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; being returned:</source>
          <target state="translated">다음 &lt;a href=&quot;https://www.w3.org/TR/REC-xml/#sec-notation&quot;&gt;EBNF&lt;/a&gt; 문법 을 준수하는 모든 문자열 은 &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8c2330d9e11176797f3b69c4b492614aa87568d1" translate="yes" xml:space="preserve">
          <source>All strings that adhere to the following &lt;a href=&quot;https://www.w3.org/TR/REC-xml/#sec-notation&quot;&gt;EBNF&lt;/a&gt; grammar will result in an &lt;a href=&quot;result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; being returned:</source>
          <target state="translated">다음 &lt;a href=&quot;https://www.w3.org/TR/REC-xml/#sec-notation&quot;&gt;EBNF&lt;/a&gt; 문법 을 준수하는 모든 문자열 은 &lt;a href=&quot;result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d19c4500c8b81bcefce226435a932d9bd67dd1d4" translate="yes" xml:space="preserve">
          <source>All supertraits must also be object safe.</source>
          <target state="translated">모든 초 특성은 객체 안전해야합니다.</target>
        </trans-unit>
        <trans-unit id="3834b26accc0c7926a85719d5492f93bbdde2cd6" translate="yes" xml:space="preserve">
          <source>All the Places Patterns Can Be Used</source>
          <target state="translated">모든 장소 패턴을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="70ddc33f2c0eb4587fa8e2cac6e8f77be9184d95" translate="yes" xml:space="preserve">
          <source>All the code we&amp;rsquo;ve discussed so far has had Rust&amp;rsquo;s memory safety guarantees enforced at compile time. However, Rust has a second language hidden inside it that doesn&amp;rsquo;t enforce these memory safety guarantees: it&amp;rsquo;s called &lt;em&gt;unsafe Rust&lt;/em&gt; and works just like regular Rust, but gives us extra superpowers.</source>
          <target state="translated">지금까지 논의한 모든 코드에는 컴파일시 Rust의 메모리 안전 보장이 적용되었습니다. 그러나 Rust에는 이러한 메모리 안전 보장을 적용하지 않는 두 번째 언어가 숨겨져 있습니다. &lt;em&gt;안전하지 않은 Rust&lt;/em&gt; 라고하며 일반 Rust와 동일하게 작동하지만 추가적인 강력한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5d094a6ebf518b356f6cc88f0daffccbeaa88d1a" translate="yes" xml:space="preserve">
          <source>All the floating point types, such as &lt;code&gt;f64&lt;/code&gt;.</source>
          <target state="translated">같은 모든 부동 소수점 유형, &lt;code&gt;f64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49768c9761f944e57fd8b28ffb7ccca3ce0255bf" translate="yes" xml:space="preserve">
          <source>All the integer types, such as &lt;code&gt;u32&lt;/code&gt;.</source>
          <target state="translated">같은 모든 정수 타입, &lt;code&gt;u32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7aad067d2eb4fd66349ef7460833027940768e31" translate="yes" xml:space="preserve">
          <source>All the traits in &lt;a href=&quot;fmt/index&quot;&gt;&lt;code&gt;std::fmt&lt;/code&gt;&lt;/a&gt; except &lt;a href=&quot;fmt/trait.pointer&quot;&gt;&lt;code&gt;Pointer&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fmt/trait.write&quot;&gt;&lt;code&gt;fmt::Write&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;fmt/trait.pointer&quot;&gt; &lt;code&gt;Pointer&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;fmt/trait.write&quot;&gt; &lt;code&gt;fmt::Write&lt;/code&gt; &lt;/a&gt; 제외한 &lt;a href=&quot;fmt/index&quot;&gt; &lt;code&gt;std::fmt&lt;/code&gt; &lt;/a&gt; 모든 특성</target>
        </trans-unit>
        <trans-unit id="5fbc378a4bea0c74a504553c4655c69b13216d43" translate="yes" xml:space="preserve">
          <source>All tokens have an associated &lt;code&gt;Span&lt;/code&gt;. A &lt;code&gt;Span&lt;/code&gt; is an opaque value that cannot be modified but can be manufactured. &lt;code&gt;Span&lt;/code&gt;s represent an extent of source code within a program and are primarily used for error reporting. You can modify the &lt;code&gt;Span&lt;/code&gt; of any token.</source>
          <target state="translated">모든 토큰에는 관련 &lt;code&gt;Span&lt;/code&gt; 있습니다. &lt;code&gt;Span&lt;/code&gt; 변경 될 수 있지만, 제조 할 수있는 불투명 한 값이다. &lt;code&gt;Span&lt;/code&gt; 은 프로그램 내 소스 코드의 범위를 나타내며 주로 오류보고에 사용됩니다. 모든 토큰 의 &lt;code&gt;Span&lt;/code&gt; 을 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c4b7c6a0fbafa4ae17e0c283d126acf9c731f848" translate="yes" xml:space="preserve">
          <source>All traits define an implicit type parameter &lt;code&gt;Self&lt;/code&gt; that refers to &quot;the type that is implementing this interface&quot;. Traits may also contain additional type parameters. These type parameters, including &lt;code&gt;Self&lt;/code&gt;, may be constrained by other traits and so forth &lt;a href=&quot;generics&quot;&gt;as usual&lt;/a&gt;.</source>
          <target state="translated">모든 특성 은 &quot;이 인터페이스를 구현하는 유형&quot;을 나타내는 암시 적 유형 매개 변수 &lt;code&gt;Self&lt;/code&gt; 를 정의합니다 . 특성은 추가 유형 매개 변수를 포함 할 수도 있습니다. &lt;code&gt;Self&lt;/code&gt; 를 포함하여 이러한 유형 매개 변수 &lt;a href=&quot;generics&quot;&gt;는 평소&lt;/a&gt; 와 같이 다른 특성 등에 의해 제한 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e6af2c7840468532a887d826478745d410145630" translate="yes" xml:space="preserve">
          <source>All type parameters have an implicit bound of &lt;code&gt;Sized&lt;/code&gt;. The special syntax &lt;code&gt;?Sized&lt;/code&gt; can be used to remove this bound if it's not appropriate.</source>
          <target state="translated">모든 형식 매개 변수는 암시 적 &lt;code&gt;Sized&lt;/code&gt; 의 Sized 입니다. 이 구문 이 적절하지 않은 경우 특수 구문 &lt;code&gt;?Sized&lt;/code&gt; 를 사용하여이 바운드를 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="687bde44d55450fc7926f1ddbef8c12777b88228" translate="yes" xml:space="preserve">
          <source>All user-defined composite types (&lt;code&gt;struct&lt;/code&gt;s, &lt;code&gt;enum&lt;/code&gt;s, and &lt;code&gt;union&lt;/code&gt;s) have a &lt;em&gt;representation&lt;/em&gt; that specifies what the layout is for the type. The possible representations for a type are:</source>
          <target state="translated">모든 사용자 정의 복합 유형 ( &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;enum&lt;/code&gt; , &lt;code&gt;union&lt;/code&gt; )에는 유형에 대한 레이아웃을 지정 하는 &lt;em&gt;표현&lt;/em&gt; 이 있습니다. 유형에 대한 가능한 표현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b66aa8bf38f6384faa05e5ba7a817e6473b9a5b6" translate="yes" xml:space="preserve">
          <source>All values have an alignment and size.</source>
          <target state="translated">모든 값은 정렬 및 크기를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="6b3bc16295776314b52aa5587d61ce1888ff84c1" translate="yes" xml:space="preserve">
          <source>Alloc</source>
          <target state="translated">Alloc</target>
        </trans-unit>
        <trans-unit id="73c626eee3cffa40774dfe1fcb9f6b9bd69dc64f" translate="yes" xml:space="preserve">
          <source>Alloc::alloc</source>
          <target state="translated">Alloc::alloc</target>
        </trans-unit>
        <trans-unit id="58fa8f803498e5ec9addefde8bfd45a79dbec5ed" translate="yes" xml:space="preserve">
          <source>Alloc::alloc_array</source>
          <target state="translated">Alloc::alloc_array</target>
        </trans-unit>
        <trans-unit id="b50e7d6a8a9d06e47daea96c8b2aea5c45efb165" translate="yes" xml:space="preserve">
          <source>Alloc::alloc_excess</source>
          <target state="translated">Alloc::alloc_excess</target>
        </trans-unit>
        <trans-unit id="889b443e61594610d30213145f921f146db36832" translate="yes" xml:space="preserve">
          <source>Alloc::alloc_one</source>
          <target state="translated">Alloc::alloc_one</target>
        </trans-unit>
        <trans-unit id="a34261c2be453348710c37c58e7b9c83398884d8" translate="yes" xml:space="preserve">
          <source>Alloc::alloc_zeroed</source>
          <target state="translated">Alloc::alloc_zeroed</target>
        </trans-unit>
        <trans-unit id="7d3d2688c4fd76b53fe3390539a364662ab17d4b" translate="yes" xml:space="preserve">
          <source>Alloc::dealloc</source>
          <target state="translated">Alloc::dealloc</target>
        </trans-unit>
        <trans-unit id="640d5625de8ef766306d60749a2169115e55e156" translate="yes" xml:space="preserve">
          <source>Alloc::dealloc_array</source>
          <target state="translated">Alloc::dealloc_array</target>
        </trans-unit>
        <trans-unit id="7053fc65b9dd32b26e961ddd07f10fe845724b56" translate="yes" xml:space="preserve">
          <source>Alloc::dealloc_one</source>
          <target state="translated">Alloc::dealloc_one</target>
        </trans-unit>
        <trans-unit id="c1a3b352f967fd646042d5ec8feb84a7842b4835" translate="yes" xml:space="preserve">
          <source>Alloc::grow_in_place</source>
          <target state="translated">Alloc::grow_in_place</target>
        </trans-unit>
        <trans-unit id="b0c3031aac44345a0cd3601e017910c7886cd822" translate="yes" xml:space="preserve">
          <source>Alloc::realloc</source>
          <target state="translated">Alloc::realloc</target>
        </trans-unit>
        <trans-unit id="50682f5a6557029f4ae580a726dd0a2a8ee83c83" translate="yes" xml:space="preserve">
          <source>Alloc::realloc_array</source>
          <target state="translated">Alloc::realloc_array</target>
        </trans-unit>
        <trans-unit id="71b9b4276801f0c0a766cb281400a5a34452c7e1" translate="yes" xml:space="preserve">
          <source>Alloc::realloc_excess</source>
          <target state="translated">Alloc::realloc_excess</target>
        </trans-unit>
        <trans-unit id="caed8ad7c332dd652a64a2f5a64ee5adce448144" translate="yes" xml:space="preserve">
          <source>Alloc::shrink_in_place</source>
          <target state="translated">Alloc::shrink_in_place</target>
        </trans-unit>
        <trans-unit id="4bdde8e404d1e339cdf8e89ef42138d76fb64cb5" translate="yes" xml:space="preserve">
          <source>Alloc::usable_size</source>
          <target state="translated">Alloc::usable_size</target>
        </trans-unit>
        <trans-unit id="74f9a2a318fbafb57c2a318b7f97cd7f558235f5" translate="yes" xml:space="preserve">
          <source>AllocErr</source>
          <target state="translated">AllocErr</target>
        </trans-unit>
        <trans-unit id="81a1e8e44229166f6c5d59b8b5cdfbd7de11a910" translate="yes" xml:space="preserve">
          <source>AllocErr::borrow</source>
          <target state="translated">AllocErr::borrow</target>
        </trans-unit>
        <trans-unit id="cab0d29cfc07f03d441e5891d8fdae354b136ec1" translate="yes" xml:space="preserve">
          <source>AllocErr::borrow_mut</source>
          <target state="translated">AllocErr::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c63e5f5e71fd2207c8a6514237ae70d9dca95cf3" translate="yes" xml:space="preserve">
          <source>AllocErr::cause</source>
          <target state="translated">AllocErr::cause</target>
        </trans-unit>
        <trans-unit id="09ff0aa0e6ca318ce203b20e17f08354650229f1" translate="yes" xml:space="preserve">
          <source>AllocErr::clone</source>
          <target state="translated">AllocErr::clone</target>
        </trans-unit>
        <trans-unit id="777d6911608c872b31c4bdb18d3b776c08a9b8f5" translate="yes" xml:space="preserve">
          <source>AllocErr::clone_from</source>
          <target state="translated">AllocErr::clone_from</target>
        </trans-unit>
        <trans-unit id="b678a089fb922c246660ee4daaf38a5251355da7" translate="yes" xml:space="preserve">
          <source>AllocErr::clone_into</source>
          <target state="translated">AllocErr::clone_into</target>
        </trans-unit>
        <trans-unit id="5df229543f81998e9da115264fa06013a927adb1" translate="yes" xml:space="preserve">
          <source>AllocErr::description</source>
          <target state="translated">AllocErr::description</target>
        </trans-unit>
        <trans-unit id="d2cf0a94fd5cf29c79c5284616875b84972fb312" translate="yes" xml:space="preserve">
          <source>AllocErr::eq</source>
          <target state="translated">AllocErr::eq</target>
        </trans-unit>
        <trans-unit id="5881f4abcdbf06d5924b4a78a521cc0027e69523" translate="yes" xml:space="preserve">
          <source>AllocErr::fmt</source>
          <target state="translated">AllocErr::fmt</target>
        </trans-unit>
        <trans-unit id="270a3da0beb21d444fb57d0c363b8a08cfe0f022" translate="yes" xml:space="preserve">
          <source>AllocErr::from</source>
          <target state="translated">AllocErr::from</target>
        </trans-unit>
        <trans-unit id="98b28dbbeacbc8b3f7530e8cbb0f5369608cd809" translate="yes" xml:space="preserve">
          <source>AllocErr::into</source>
          <target state="translated">AllocErr::into</target>
        </trans-unit>
        <trans-unit id="039711c278e014b513a0be997690fca2416f8474" translate="yes" xml:space="preserve">
          <source>AllocErr::ne</source>
          <target state="translated">AllocErr::ne</target>
        </trans-unit>
        <trans-unit id="ffa94c7186e9f5d1d7bf9c63828fb87e4a775ad5" translate="yes" xml:space="preserve">
          <source>AllocErr::source</source>
          <target state="translated">AllocErr::source</target>
        </trans-unit>
        <trans-unit id="0aeb755570b957275d6d9d5317212dc6a6535090" translate="yes" xml:space="preserve">
          <source>AllocErr::to_owned</source>
          <target state="translated">AllocErr::to_owned</target>
        </trans-unit>
        <trans-unit id="0e17e4e80e3c6af6ed45e6c032cf33d55d346e46" translate="yes" xml:space="preserve">
          <source>AllocErr::to_string</source>
          <target state="translated">AllocErr::to_string</target>
        </trans-unit>
        <trans-unit id="3e40fc0676c76a71ca131dafb97f38662652bfbf" translate="yes" xml:space="preserve">
          <source>AllocErr::try_from</source>
          <target state="translated">AllocErr::try_from</target>
        </trans-unit>
        <trans-unit id="34d1124cc06e84256717b819e1f63b955e0350bf" translate="yes" xml:space="preserve">
          <source>AllocErr::try_into</source>
          <target state="translated">AllocErr::try_into</target>
        </trans-unit>
        <trans-unit id="663b204a54c41c16c072ee135d91fa4be49de349" translate="yes" xml:space="preserve">
          <source>AllocErr::type_id</source>
          <target state="translated">AllocErr::type_id</target>
        </trans-unit>
        <trans-unit id="4893c8174f6c1eabc41e7843e70d7ebcff1b1f84" translate="yes" xml:space="preserve">
          <source>Allocate memory as described by the given &lt;code&gt;layout&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;layout&lt;/code&gt; 설명 된대로 메모리를 할당하십시오 .</target>
        </trans-unit>
        <trans-unit id="cd02c9bc4eedba216d90a16d722506e0ce680a8a" translate="yes" xml:space="preserve">
          <source>Allocate memory as described by the given &lt;code&gt;layout&lt;/code&gt;. &lt;a href=&quot;trait.globalalloc#tymethod.alloc&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">주어진 &lt;code&gt;layout&lt;/code&gt; 설명 된대로 메모리를 할당하십시오 . &lt;a href=&quot;trait.globalalloc#tymethod.alloc&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="74c59d8374e4ee1d975ce714a71b5fcdbb7aacac" translate="yes" xml:space="preserve">
          <source>Allocate memory with the global allocator.</source>
          <target state="translated">글로벌 할당 자로 메모리를 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="cfb8411e19f0f79e91b6b66f6609da2b9991a1e5" translate="yes" xml:space="preserve">
          <source>Allocate zero-initialized memory with the global allocator.</source>
          <target state="translated">전역 할당기로 0으로 초기화 된 메모리를 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="1bfdf7915bd5c3db982b39e0a3309425f8ee260d" translate="yes" xml:space="preserve">
          <source>Allocates a block suitable for holding &lt;code&gt;n&lt;/code&gt; instances of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 개의 인스턴스 &lt;code&gt;T&lt;/code&gt; 를 보유하기에 적합한 블록을 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="c63c156459af2e92bb9b73d7f0f9844433b5dc2f" translate="yes" xml:space="preserve">
          <source>Allocates a block suitable for holding &lt;code&gt;n&lt;/code&gt; instances of &lt;code&gt;T&lt;/code&gt;. &lt;a href=&quot;trait.alloc#method.alloc_array&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 개의 인스턴스 &lt;code&gt;T&lt;/code&gt; 를 보유하기에 적합한 블록을 할당합니다 . &lt;a href=&quot;trait.alloc#method.alloc_array&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed375cd7b209e0c5769df096531bae03a872bbbb" translate="yes" xml:space="preserve">
          <source>Allocates a block suitable for holding an instance of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 의 인스턴스를 보유하기에 적합한 블록을 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="02c72ac7d36294390fedc764c2754fe1636d64b1" translate="yes" xml:space="preserve">
          <source>Allocates a block suitable for holding an instance of &lt;code&gt;T&lt;/code&gt;. &lt;a href=&quot;trait.alloc#method.alloc_one&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 의 인스턴스를 보유하기에 적합한 블록을 할당합니다 . &lt;a href=&quot;trait.alloc#method.alloc_one&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="76e23de7e691468d4d99aac266130e3bc34f2ea4" translate="yes" xml:space="preserve">
          <source>Allocates an empty &lt;code&gt;PathBuf&lt;/code&gt;.</source>
          <target state="translated">빈 &lt;code&gt;PathBuf&lt;/code&gt; 를 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="f9ce219d6c4b42c1f87ab6030532c065b1fec11f" translate="yes" xml:space="preserve">
          <source>Allocates memory on the heap and then places &lt;code&gt;x&lt;/code&gt; into it.</source>
          <target state="translated">힙에 메모리를 할당 한 다음 &lt;code&gt;x&lt;/code&gt; 를 메모리에 배치 합니다.</target>
        </trans-unit>
        <trans-unit id="e910169c58168ed4f75b19228b519cfb61699e61" translate="yes" xml:space="preserve">
          <source>Allow generic type parameter to be a dynamically sized type</source>
          <target state="translated">일반 유형 매개 변수가 동적 크기 유형이되도록 허용</target>
        </trans-unit>
        <trans-unit id="40680c6330eab7e25541ffbe63efc1d14385635b" translate="yes" xml:space="preserve">
          <source>Allow users to add text content only when a post is in the &lt;code&gt;Draft&lt;/code&gt; state. Hint: have the state object responsible for what might change about the content but not responsible for modifying the &lt;code&gt;Post&lt;/code&gt;.</source>
          <target state="translated">게시물이 &lt;code&gt;Draft&lt;/code&gt; 상태 인 경우에만 사용자가 텍스트 내용을 추가 할 수 있습니다 . 힌트 : 상태 개체가 콘텐츠에 대해 변경 될 수 있지만 &lt;code&gt;Post&lt;/code&gt; 수정에 대한 책임은 없습니다. .</target>
        </trans-unit>
        <trans-unit id="6cb50b4ef5745cf62353aeff34203276011ef50f" translate="yes" xml:space="preserve">
          <source>Allowing Access from Multiple Threads with &lt;code id=&quot;allowing-access-from-multiple-threads-with-sync&quot;&gt;Sync&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;allowing-access-from-multiple-threads-with-sync&quot;&gt;Sync&lt;/code&gt; 하여 여러 스레드에서 액세스 허용</target>
        </trans-unit>
        <trans-unit id="fae2d8f4c50be8a20cdea347ace493568595fcd3" translate="yes" xml:space="preserve">
          <source>Allowing Multiple Guesses with Looping</source>
          <target state="translated">루핑으로 여러 번의 손님을 허용</target>
        </trans-unit>
        <trans-unit id="7db289670d5f2b576ba5fbc25cdc4ef16295c536" translate="yes" xml:space="preserve">
          <source>Allowing Transference of Ownership Between Threads with &lt;code id=&quot;allowing-transference-of-ownership-between-threads-with-send&quot;&gt;Send&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;allowing-transference-of-ownership-between-threads-with-send&quot;&gt;Send&lt;/code&gt; 를 사용 하여 스레드 간 소유권 이전 허용</target>
        </trans-unit>
        <trans-unit id="fb09e5f22f3b7d16947a2ecaccff480c6609f901" translate="yes" xml:space="preserve">
          <source>Almost always it is better to use &lt;code&gt;Vec&lt;/code&gt; or &lt;a href=&quot;../vec_deque/struct.vecdeque&quot;&gt;&lt;code&gt;VecDeque&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;struct.linkedlist&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt;. In general, array-based containers are faster, more memory efficient and make better use of CPU cache.</source>
          <target state="translated">거의 항상 &lt;a href=&quot;struct.linkedlist&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; &lt;/a&gt; 대신 &lt;code&gt;Vec&lt;/code&gt; 또는 &lt;a href=&quot;../vec_deque/struct.vecdeque&quot;&gt; &lt;code&gt;VecDeque&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 . 일반적으로 어레이 기반 컨테이너는 더 빠르고 더 메모리 효율적이며 CPU 캐시를 더 잘 활용합니다.</target>
        </trans-unit>
        <trans-unit id="96a3f97ad5d3ab3ce2ee9333276a6a44f6055cf9" translate="yes" xml:space="preserve">
          <source>Almost always it is better to use &lt;code&gt;Vec&lt;/code&gt; or &lt;code&gt;VecDeque&lt;/code&gt; instead of &lt;code&gt;LinkedList&lt;/code&gt;. In general, array-based containers are faster, more memory efficient and make better use of CPU cache.</source>
          <target state="translated">거의 항상 &lt;code&gt;LinkedList&lt;/code&gt; 대신 &lt;code&gt;Vec&lt;/code&gt; 또는 &lt;code&gt;VecDeque&lt;/code&gt; 를 사용하는 것이 좋습니다 . 일반적으로 어레이 기반 컨테이너는 더 빠르고 더 메모리 효율적이며 CPU 캐시를 더 잘 활용합니다.</target>
        </trans-unit>
        <trans-unit id="30066ada2ed0aa1faf9262f27c4ed17333b52206" translate="yes" xml:space="preserve">
          <source>Along the way, we&amp;rsquo;ll show how to make our command line tool use features of the terminal that many command line tools use. We&amp;rsquo;ll read the value of an environment variable to allow the user to configure the behavior of our tool. We&amp;rsquo;ll also print error messages to the standard error console stream (&lt;code&gt;stderr&lt;/code&gt;) instead of standard output (&lt;code&gt;stdout&lt;/code&gt;), so, for example, the user can redirect successful output to a file while still seeing error messages onscreen.</source>
          <target state="translated">그 과정에서 많은 명령 행 도구가 사용하는 터미널의 기능을 명령 행 도구로 사용하는 방법을 보여줍니다. 사용자가 도구의 동작을 구성 할 수 있도록 환경 변수의 값을 읽습니다. 또한 표준 출력 ( &lt;code&gt;stdout&lt;/code&gt; ) 대신 표준 오류 콘솔 스트림 ( &lt;code&gt;stderr&lt;/code&gt; )에 오류 메시지를 인쇄 하므로 사용자는 화면에 오류 메시지가 표시되는 동안 성공적인 출력을 파일로 리디렉션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cbf8cd5d5a46820a0f6ab73279f92ce571b3bc8" translate="yes" xml:space="preserve">
          <source>Along with being made public via &lt;code&gt;pub&lt;/code&gt;, &lt;code&gt;fn&lt;/code&gt; can also have an &lt;a href=&quot;keyword.extern&quot;&gt;&lt;code&gt;extern&lt;/code&gt;&lt;/a&gt; added for use in FFI.</source>
          <target state="translated">를 통해 공개되는과 함께 &lt;code&gt;pub&lt;/code&gt; , &lt;code&gt;fn&lt;/code&gt; 또한 가질 수 &lt;a href=&quot;keyword.extern&quot;&gt; &lt;code&gt;extern&lt;/code&gt; &lt;/a&gt; FFI에 사용하기 위해 추가합니다.</target>
        </trans-unit>
        <trans-unit id="569f87a8387e1554badafba00588c85d0f8bf792" translate="yes" xml:space="preserve">
          <source>Along with the newtype pattern, Rust provides the ability to declare a &lt;em&gt;type alias&lt;/em&gt; to give an existing type another name. For this we use the &lt;code&gt;type&lt;/code&gt; keyword. For example, we can create the alias &lt;code&gt;Kilometers&lt;/code&gt; to &lt;code&gt;i32&lt;/code&gt; like so:</source>
          <target state="translated">새 유형 패턴과 함께 Rust는 기존 유형에 다른 이름을 부여하기 위해 &lt;em&gt;유형 별명&lt;/em&gt; 을 선언하는 기능을 제공합니다 . 이를 위해 &lt;code&gt;type&lt;/code&gt; 키워드를 사용합니다 . 예를 들어 다음 과 같이 별명 &lt;code&gt;Kilometers&lt;/code&gt; 를 &lt;code&gt;i32&lt;/code&gt; 로 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6444cb062f09d53622baea0cd17deb96b9dc9f75" translate="yes" xml:space="preserve">
          <source>Also discussed were the &lt;code&gt;Deref&lt;/code&gt; and &lt;code&gt;Drop&lt;/code&gt; traits, which enable a lot of the functionality of smart pointers. We explored reference cycles that can cause memory leaks and how to prevent them using &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">스마트 포인터의 많은 기능을 가능하게하는 &lt;code&gt;Deref&lt;/code&gt; 및 &lt;code&gt;Drop&lt;/code&gt; 특성 도 논의했습니다 . 메모리 누수를 일으킬 수있는 참조주기와 &lt;code&gt;Weak&amp;lt;T&amp;gt;&lt;/code&gt; 사용하여이를 방지하는 방법을 살펴 보았습니다 .</target>
        </trans-unit>
        <trans-unit id="d6fc1b2f8caf81c693f670285ed3e30e58c8f202" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;Iterator&lt;/code&gt; provides a default implementation of methods such as &lt;code&gt;nth&lt;/code&gt; and &lt;code&gt;fold&lt;/code&gt; which call &lt;code&gt;next&lt;/code&gt; internally. However, it is also possible to write a custom implementation of methods like &lt;code&gt;nth&lt;/code&gt; and &lt;code&gt;fold&lt;/code&gt; if an iterator can compute them more efficiently without calling &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;code&gt;Iterator&lt;/code&gt; 는 내부적으로 &lt;code&gt;next&lt;/code&gt; 호출되는 &lt;code&gt;nth&lt;/code&gt; 및 &lt;code&gt;fold&lt;/code&gt; 와 같은 메소드의 기본 구현을 제공합니다 . 그러나 반복자가 &lt;code&gt;next&lt;/code&gt; 를 호출하지 않고 더 효율적으로 계산할 수 있으면 &lt;code&gt;nth&lt;/code&gt; 및 &lt;code&gt;fold&lt;/code&gt; 와 같은 메소드의 사용자 정의 구현을 작성할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a7fb665b167f214e0e11085759c66fc45c5b538" translate="yes" xml:space="preserve">
          <source>Also note that Cargo build scripts can learn about this feature through &lt;a href=&quot;http://doc.crates.io/environment-variables.html#environment-variables-cargo-sets-for-build-scripts&quot;&gt;environment variables&lt;/a&gt;. In a build script you can detect the linkage via:</source>
          <target state="translated">또한 Cargo 빌드 스크립트는 &lt;a href=&quot;http://doc.crates.io/environment-variables.html#environment-variables-cargo-sets-for-build-scripts&quot;&gt;환경 변수를&lt;/a&gt; 통해이 기능에 대해 배울 수 있습니다 . 빌드 스크립트에서 다음을 통해 연결을 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="729f1c9440272260f81d5cd373556bbc830572f8" translate="yes" xml:space="preserve">
          <source>Also note that the values we get from the calls to &lt;code&gt;next&lt;/code&gt; are immutable references to the values in the vector. The &lt;code&gt;iter&lt;/code&gt; method produces an iterator over immutable references. If we want to create an iterator that takes ownership of &lt;code&gt;v1&lt;/code&gt; and returns owned values, we can call &lt;code&gt;into_iter&lt;/code&gt; instead of &lt;code&gt;iter&lt;/code&gt;. Similarly, if we want to iterate over mutable references, we can call &lt;code&gt;iter_mut&lt;/code&gt; instead of &lt;code&gt;iter&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;code&gt;next&lt;/code&gt; 호출에서 얻는 값은 벡터의 값에 대한 불변의 참조입니다. &lt;code&gt;iter&lt;/code&gt; 있어서 불변 참조 반복자를 생성한다. &lt;code&gt;v1&lt;/code&gt; 의 소유권을 가져와 소유 한 값을 리턴 하는 반복자를 작성하려는 경우 &lt;code&gt;iter&lt;/code&gt; 대신 &lt;code&gt;into_iter&lt;/code&gt; 를 호출 할 수 있습니다 . 마찬가지로, 변경 가능한 참조를 반복하려면 &lt;code&gt;iter&lt;/code&gt; 대신 &lt;code&gt;iter_mut&lt;/code&gt; 를 호출 하면 됩니다 .</target>
        </trans-unit>
        <trans-unit id="ce251a63845ba69b5ad2fd9f201455284f4f01ee" translate="yes" xml:space="preserve">
          <source>Also note that we switched the type of the &lt;code&gt;t&lt;/code&gt; parameter from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;&amp;amp;T&lt;/code&gt;. Because the type might not be &lt;code&gt;Sized&lt;/code&gt;, we need to use it behind some kind of pointer. In this case, we&amp;rsquo;ve chosen a reference.</source>
          <target state="translated">또한 &lt;code&gt;t&lt;/code&gt; 매개 변수 의 유형을 &lt;code&gt;T&lt;/code&gt; 에서 &lt;code&gt;&amp;amp;T&lt;/code&gt; . 유형이 &lt;code&gt;Sized&lt;/code&gt; 가 아닐 수 있으므로 일종의 포인터 뒤에 사용해야합니다. 이 경우 참조를 선택했습니다.</target>
        </trans-unit>
        <trans-unit id="19148a1d1c1b97af52ac182d255aa33cc3c9304e" translate="yes" xml:space="preserve">
          <source>Also of note is the special syntax for &lt;code&gt;Fn&lt;/code&gt; traits (e.g. &lt;code&gt;Fn(usize, bool) -&amp;gt; usize&lt;/code&gt;). Those interested in the technical details of this can refer to &lt;a href=&quot;https://doc.rust-lang.org/nomicon/hrtb.html&quot;&gt;the relevant section in the &lt;em&gt;Rustonomicon&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">또한 &lt;code&gt;Fn&lt;/code&gt; 특성에 대한 특수 구문 (예 : &lt;code&gt;Fn(usize, bool) -&amp;gt; usize&lt;/code&gt; )이 중요 합니다. 이것의 기술적 세부 사항에 관심이있는 사람들 &lt;a href=&quot;https://doc.rust-lang.org/nomicon/hrtb.html&quot;&gt;은 &lt;em&gt;Rustonomicon&lt;/em&gt;&lt;/a&gt; 의 관련 섹션을 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d4cb652a8b78bec628c1d26d0df6d4c9f7c28ed" translate="yes" xml:space="preserve">
          <source>Also, if the type of the expression to the left of the dot is a pointer, it is automatically dereferenced as many times as necessary to make the field access possible. In cases of ambiguity, we prefer fewer autoderefs to more.</source>
          <target state="translated">또한 점 왼쪽의 표현식 유형이 포인터 인 경우 필드 액세스가 가능하도록 필요한 횟수만큼 자동으로 역 참조됩니다. 애매 모호한 경우, 우리는 더 적은 양의 autoderef를 선호합니다.</target>
        </trans-unit>
        <trans-unit id="56542ee08fdcb89c559a45ec666da5ba100aa6fa" translate="yes" xml:space="preserve">
          <source>Also, it allocates temporary storage half the size of &lt;code&gt;self&lt;/code&gt;, but for short slices a non-allocating insertion sort is used instead.</source>
          <target state="translated">또한 &lt;code&gt;self&lt;/code&gt; 저장소의 절반 크기의 임시 저장소를 할당 하지만 짧은 슬라이스의 경우 비 할당 삽입 정렬이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="71671f4bb484f8a1e973c0578cc13715a3aa2105" translate="yes" xml:space="preserve">
          <source>Also, note that because &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; has a private field, the struct needs to provide a public associated function that constructs an instance of &lt;code&gt;Breakfast&lt;/code&gt; (we&amp;rsquo;ve named it &lt;code&gt;summer&lt;/code&gt; here). If &lt;code&gt;Breakfast&lt;/code&gt; didn&amp;rsquo;t have such a function, we couldn&amp;rsquo;t create an instance of &lt;code&gt;Breakfast&lt;/code&gt; in &lt;code&gt;eat_at_restaurant&lt;/code&gt; because we couldn&amp;rsquo;t set the value of the private &lt;code&gt;seasonal_fruit&lt;/code&gt; field in &lt;code&gt;eat_at_restaurant&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; 에는 개인 필드가 있으므로이 구조체는 &lt;code&gt;Breakfast&lt;/code&gt; 인스턴스를 구성하는 공개 관련 함수를 제공해야합니다 ( 여기서 &lt;code&gt;summer&lt;/code&gt; 이라고 칭함 ). 경우 &lt;code&gt;Breakfast&lt;/code&gt; 이러한 기능을하지 않았다, 우리는의 인스턴스를 만들 수 없습니다 &lt;code&gt;Breakfast&lt;/code&gt; 에 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 우리는 개인의 가치 설정할 수 없습니다 때문에 &lt;code&gt;seasonal_fruit&lt;/code&gt; 의 필드 &lt;code&gt;eat_at_restaurant&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="477dbb63bb02aa6d30fe03da09f8465ff169a963" translate="yes" xml:space="preserve">
          <source>Also, note that the function body is wrapped in curly brackets, &lt;code&gt;{}&lt;/code&gt;. Rust requires these around all function bodies. It&amp;rsquo;s good style to place the opening curly bracket on the same line as the function declaration, adding one space in between.</source>
          <target state="translated">또한 함수 본문은 중괄호 &lt;code&gt;{}&lt;/code&gt; 로 싸여 있습니다. 녹은 모든 기능 몸체 주위에 이것들을 요구합니다. 여는 중괄호를 함수 선언과 같은 줄에 배치하고 사이에 공백을 하나 추가하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8c50010a52d6913ce8428bd39d3014c723f0db3d" translate="yes" xml:space="preserve">
          <source>Also, please be aware that this method is only for special circumstances and is usually not what you want. In case of doubt, use &lt;a href=&quot;#method.borrow_mut&quot;&gt;&lt;code&gt;borrow_mut&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">또한이 방법은 특수한 상황을위한 것이며 일반적으로 원하는 것이 아닙니다. &lt;a href=&quot;#method.borrow_mut&quot;&gt; &lt;code&gt;borrow_mut&lt;/code&gt; &lt;/a&gt; 하지 않은 경우, 대신 retrieve_mut를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2edbd5a08a0137666e61eca4932691fdf6681fd9" translate="yes" xml:space="preserve">
          <source>Also, since &lt;code&gt;bool&lt;/code&gt; implements the &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; trait, we don't have to worry about the move semantics (just like the integer and float primitives).</source>
          <target state="translated">또한 &lt;code&gt;bool&lt;/code&gt; 은 &lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; 특성을 구현 하므로 정수 및 부동 소수와 같이 이동 의미에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a9b0dcda2ee36870b49794f990ce3f2eb9803892" translate="yes" xml:space="preserve">
          <source>Alternatively there can be exactly two expressions inside the brackets, separated by a semi-colon. The expression after the &lt;code&gt;;&lt;/code&gt; must be a have type &lt;code&gt;usize&lt;/code&gt; and be a &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;constant expression&lt;/a&gt;, such as a &lt;a href=&quot;../tokens#literals&quot;&gt;literal&lt;/a&gt; or a &lt;a href=&quot;../items/constant-items&quot;&gt;constant item&lt;/a&gt;. &lt;code&gt;[a; b]&lt;/code&gt; creates an array containing &lt;code&gt;b&lt;/code&gt; copies of the value of &lt;code&gt;a&lt;/code&gt;. If the expression after the semi-colon has a value greater than 1 then this requires that the type of &lt;code&gt;a&lt;/code&gt; is &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">또는 대괄호 안에 정확히 두 개의식이있을 수 있으며 세미콜론으로 구분됩니다. &lt;code&gt;;&lt;/code&gt; 뒤에 나오는 표현식 사용 유형이 &lt;code&gt;usize&lt;/code&gt; 하고 &lt;a href=&quot;../tokens#literals&quot;&gt;리터럴&lt;/a&gt; 또는 &lt;a href=&quot;../items/constant-items&quot;&gt;상수 항목&lt;/a&gt; 과 같은 &lt;a href=&quot;../const_eval#constant-expressions&quot;&gt;상수 표현식&lt;/a&gt; 이어야합니다 . &lt;code&gt;[a; b]&lt;/code&gt; B] 포함하는 배열 생성 &lt;code&gt;b&lt;/code&gt; 의 값의 사본 &lt;code&gt;a&lt;/code&gt; . 세미콜론 뒤의 표현식의 값이 1보다 큰 경우 &lt;code&gt;a&lt;/code&gt; 유형 이 &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; 가되어야&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="3c2b342df42a5ce80106fad6cca3ec251f8df3e4" translate="yes" xml:space="preserve">
          <source>Alternatively, &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; has alignment 1 for all &lt;code&gt;T&lt;/code&gt;, so you can use it if you need to keep the field for some reason:</source>
          <target state="translated">또는 &lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt; 는 모든 &lt;code&gt;T&lt;/code&gt; 에 대해 정렬 1을 가지 므로 어떤 이유로 필드를 유지 해야하는 경우 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38449305205a0baadf0d931713ad745060ac7795" translate="yes" xml:space="preserve">
          <source>Alternatively, a paren-less version of the attribute may be used to hint the compiler about inlining opportunity:</source>
          <target state="translated">대안으로, paren-less 버전의 속성을 사용하여 컴파일러에게 기회 인라인에 대한 힌트를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d329c92752ab59bc5a187b9f641894d29c9fd208" translate="yes" xml:space="preserve">
          <source>Alternatively, define a trait locally and implement that instead:</source>
          <target state="translated">또는 특성을 로컬로 정의하고 대신 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="30596c4d15742cc562b249b398f8c80c1a13a17f" translate="yes" xml:space="preserve">
          <source>Alternatively, if the type parameter was intentionally inserted, it must be used. A simple fix is shown below:</source>
          <target state="translated">또는 유형 매개 변수를 의도적으로 삽입 한 경우 사용해야합니다. 간단한 수정 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7c8d494311629dbdec7e4dda72d552e11aace0ec" translate="yes" xml:space="preserve">
          <source>Alternatively, if we don't control the struct's definition, or mutable shared ownership is truly required, we can use &lt;code&gt;Rc&lt;/code&gt; and &lt;code&gt;RefCell&lt;/code&gt;:</source>
          <target state="translated">또는 구조체의 정의를 제어하지 않거나 변경 가능한 공유 소유권이 실제로 필요한 경우 &lt;code&gt;Rc&lt;/code&gt; 및 &lt;code&gt;RefCell&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0a59d2fc84eff79b213967bc64daab09652e8ccb" translate="yes" xml:space="preserve">
          <source>Alternatively, if your type implements &lt;code&gt;Clone&lt;/code&gt; and you need to own the value, consider borrowing and then cloning:</source>
          <target state="translated">또는 유형이 &lt;code&gt;Clone&lt;/code&gt; 구현 하고 값을 소유해야하는 경우 빌린 다음 복제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="ed9c6950d0598f33adea6619e4f5e3230fd020da" translate="yes" xml:space="preserve">
          <source>Alternatively, move the other attributes to the contained type:</source>
          <target state="translated">또는 다른 속성을 포함 된 유형으로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="b5cf6202d850db2d8b7a0068cf052fbe7d132528" translate="yes" xml:space="preserve">
          <source>Alternatively, split the pattern:</source>
          <target state="translated">또는 패턴을 분할하십시오.</target>
        </trans-unit>
        <trans-unit id="9b111c2948f7df0faec47eb57a97f3c7f99e8980" translate="yes" xml:space="preserve">
          <source>Alternatively, we can consider using the &lt;code&gt;Cell&lt;/code&gt; and &lt;code&gt;RefCell&lt;/code&gt; types to achieve interior mutability through a shared reference. Our example's &lt;code&gt;mutable&lt;/code&gt; function could be redefined as below:</source>
          <target state="translated">또는 공유 참조를 통해 내부 &lt;code&gt;RefCell&lt;/code&gt; 를 달성하기 위해 &lt;code&gt;Cell&lt;/code&gt; 및 RefCell 유형을 사용할 수도 있습니다 . 예제의 &lt;code&gt;mutable&lt;/code&gt; 함수는 다음과 같이 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="754e721e3e9779de9d32c607142b98694b9bb365" translate="yes" xml:space="preserve">
          <source>Alternatively, we can move out of &lt;code&gt;fancy_num&lt;/code&gt; into a second &lt;code&gt;fancy_num&lt;/code&gt;:</source>
          <target state="translated">또는 &lt;code&gt;fancy_num&lt;/code&gt; 에서 두 번째 &lt;code&gt;fancy_num&lt;/code&gt; 으로 이동할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da767a10b83371c7ea419ae14469880fbc9efc2b" translate="yes" xml:space="preserve">
          <source>Alternatively, wrapping trait objects requires something like the following:</source>
          <target state="translated">또는 특성 오브젝트를 줄 바꿈하려면 다음과 같은 것이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="980127d7c92391c13b6615bd3076240a03531f1c" translate="yes" xml:space="preserve">
          <source>Alternatively, you can add the following line to your &lt;em&gt;~/.bash_profile&lt;/em&gt;:</source>
          <target state="translated">또는 &lt;em&gt;~ / .bash_profile에&lt;/em&gt; 다음 줄을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="53009511a1501672faf73d204dc3eb7eb0e15f4c" translate="yes" xml:space="preserve">
          <source>Alternatively, you can create a newtype. A newtype is a wrapping tuple-struct. For example, &lt;code&gt;NewType&lt;/code&gt; is a newtype over &lt;code&gt;Foo&lt;/code&gt; in &lt;code&gt;struct NewType(Foo)&lt;/code&gt;. Example:</source>
          <target state="translated">또는 새 유형을 작성할 수 있습니다. 새로운 유형은 래핑 튜플 구조체입니다. 예를 들어, &lt;code&gt;NewType&lt;/code&gt; 위에 newtype은 인 &lt;code&gt;Foo&lt;/code&gt; 의 &lt;code&gt;struct NewType(Foo)&lt;/code&gt; . 예:</target>
        </trans-unit>
        <trans-unit id="f44934b9e6665fc0ff65386cfc3a7e7022fcb44e" translate="yes" xml:space="preserve">
          <source>Alternatively, you can obtain a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice from a &lt;code&gt;CString&lt;/code&gt; with the &lt;a href=&quot;#method.as_bytes&quot;&gt;&lt;code&gt;as_bytes&lt;/code&gt;&lt;/a&gt; method. Slices produced in this way do &lt;em&gt;not&lt;/em&gt; contain the trailing nul terminator. This is useful when you will be calling an extern function that takes a &lt;code&gt;*const u8&lt;/code&gt; argument which is not necessarily nul-terminated, plus another argument with the length of the string &amp;mdash; like C's &lt;code&gt;strndup()&lt;/code&gt;. You can of course get the slice's length with its &lt;a href=&quot;../primitive.slice#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">다른 방법으로는 얻을 수 &lt;code&gt;&amp;amp;[&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;]&lt;/code&gt; (A)로부터 슬라이스 &lt;code&gt;CString&lt;/code&gt; 을 와 &lt;a href=&quot;#method.as_bytes&quot;&gt; &lt;code&gt;as_bytes&lt;/code&gt; 의&lt;/a&gt; 방법. 이러한 방식으로 생성 된 슬라이스 에는 후미 널 종결자가 포함 &lt;em&gt;되지 않습니다&lt;/em&gt; . 이것은 반드시 null로 끝나지 않을 &lt;code&gt;*const u8&lt;/code&gt; 인수와 C의 &lt;code&gt;strndup()&lt;/code&gt; 과 같은 문자열 길이를 가진 또 다른 인수 를 취하는 extern 함수를 호출 할 때 유용합니다 . 물론 &lt;a href=&quot;../primitive.slice#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 슬라이스의 길이를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a4be7155bcffba0850c80a370bc5c6b34c37e74" translate="yes" xml:space="preserve">
          <source>Alternatives</source>
          <target state="translated">Alternatives</target>
        </trans-unit>
        <trans-unit id="fb4db1dca17b4c832ac69c83b18f73ad9aa68bf9" translate="yes" xml:space="preserve">
          <source>Although Rust will let you bind &lt;code&gt;Sized&lt;/code&gt; to a trait, you won't be able to use it to form a trait object later:</source>
          <target state="translated">Rust를 사용하면 &lt;code&gt;Sized&lt;/code&gt; 를 특성에 바인딩 할 수 있지만 나중에 특성 개체를 형성하는 데 사용할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="18938413590ec4f421c089a648f9b8a820edd657" translate="yes" xml:space="preserve">
          <source>Although UDP is a connectionless protocol, this implementation provides an interface to set an address where data should be sent and received from. After setting a remote address with &lt;a href=&quot;#method.connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt;, data can be sent to and received from that address with &lt;a href=&quot;#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">UDP는 비 연결 프로토콜이지만이 구현은 데이터를주고받을 주소를 설정하는 인터페이스를 제공합니다. &lt;a href=&quot;#method.connect&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt; 로 원격 주소를 설정 한 후 &lt;a href=&quot;#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; 를 사용&lt;/a&gt; 하여 해당 주소로 데이터를주고받을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6138cf1c64fdfba340547fa72a908d945fa65b3f" translate="yes" xml:space="preserve">
          <source>Although a &lt;code&gt;SystemTime&lt;/code&gt; cannot be directly inspected, the &lt;a href=&quot;constant.unix_epoch&quot;&gt;&lt;code&gt;UNIX_EPOCH&lt;/code&gt;&lt;/a&gt; constant is provided in this module as an anchor in time to learn information about a &lt;code&gt;SystemTime&lt;/code&gt;. By calculating the duration from this fixed point in time, a &lt;code&gt;SystemTime&lt;/code&gt; can be converted to a human-readable time, or perhaps some other string representation.</source>
          <target state="translated">있지만 &lt;code&gt;SystemTime&lt;/code&gt; 직접 검사 될 수 있고, &lt;a href=&quot;constant.unix_epoch&quot;&gt; &lt;code&gt;UNIX_EPOCH&lt;/code&gt; 의&lt;/a&gt; 상수는 약 정보 배울 시간에서 앵커로 모듈이 제공된다 &lt;code&gt;SystemTime&lt;/code&gt; . 이 고정 된 시점에서 지속 시간을 계산하면 &lt;code&gt;SystemTime&lt;/code&gt; 을 사람이 읽을 수있는 시간 또는 다른 문자열 표현으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bf2565395a043df30a2266cce3b26bdd4f8ff03" translate="yes" xml:space="preserve">
          <source>Although both Listing 7-11 and 7-13 accomplish the same task, Listing 7-11 is the idiomatic way to bring a function into scope with &lt;code&gt;use&lt;/code&gt;. Bringing the function&amp;rsquo;s parent module into scope with &lt;code&gt;use&lt;/code&gt; so we have to specify the parent module when calling the function makes it clear that the function isn&amp;rsquo;t locally defined while still minimizing repetition of the full path. The code in Listing 7-13 is unclear as to where &lt;code&gt;add_to_waitlist&lt;/code&gt; is defined.</source>
          <target state="translated">Listing 7-11과 7-13은 모두 동일한 작업을 수행하지만 Listing 7-11은 함수를 범위 내에서 &lt;code&gt;use&lt;/code&gt; 하는 관용적 방법 이다. 함수의 부모 모듈을 &lt;code&gt;use&lt;/code&gt; 하여 범위로 가져 오므로 함수를 호출 할 때 부모 모듈을 지정해야 전체 경로의 반복을 최소화하면서 함수가 로컬로 정의되지 않았 음을 알 수 있습니다. 목록 7-13의 코드는 &lt;code&gt;add_to_waitlist&lt;/code&gt; 가 정의 된 위치에 대해 명확하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="af1566b2870173a676122bd4c9750a25b9287966" translate="yes" xml:space="preserve">
          <source>Although functional programming languages use cons lists frequently, the cons list isn&amp;rsquo;t a commonly used data structure in Rust. Most of the time when you have a list of items in Rust, &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; is a better choice to use. Other, more complex recursive data types &lt;em&gt;are&lt;/em&gt; useful in various situations, but by starting with the cons list, we can explore how boxes let us define a recursive data type without much distraction.</source>
          <target state="translated">함수형 프로그래밍 언어는 단점 목록을 자주 사용하지만 단점 목록은 Rust에서 일반적으로 사용되는 데이터 구조가 아닙니다. Rust에 항목 목록이있는 경우 대부분 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용하는 것이 좋습니다. 더 복잡한 다른 재귀 데이터 유형 &lt;em&gt;은&lt;/em&gt; 다양한 상황에서 유용하지만 단점 목록으로 시작하여 상자가 많은 방해없이 재귀 데이터 유형을 정의하는 방법을 살펴볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d04af4e6b5ccd4c4682747098fc1db0b02dbd661" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;::&lt;/code&gt; token is allowed before the generics arguments, it is not required because there is no ambiguity like there is in &lt;em&gt;PathInExpression&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;::&lt;/code&gt; 토큰이 generics 인수 앞에 허용 되지만 &lt;em&gt;PathInExpression&lt;/em&gt; 과 같은 모호성이 없기 때문에 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7bf75499d3d552ee0a87d1fa70ed0a0e35bd067e" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;let&lt;/code&gt; is pointless here, it illustrates the meaning of &lt;code&gt;!&lt;/code&gt;. Since &lt;code&gt;x&lt;/code&gt; is never assigned a value (because &lt;code&gt;return&lt;/code&gt; returns from the entire function), &lt;code&gt;x&lt;/code&gt; can be given type &lt;code&gt;!&lt;/code&gt;. We could also replace &lt;code&gt;return 123&lt;/code&gt; with a &lt;code&gt;panic!&lt;/code&gt; or a never-ending &lt;code&gt;loop&lt;/code&gt; and this code would still be valid.</source>
          <target state="translated">있지만 &lt;code&gt;let&lt;/code&gt; 여기 무의미, 그것의 의미를 보여줍니다 &lt;code&gt;!&lt;/code&gt; . 이후 &lt;code&gt;x&lt;/code&gt; 값이 할당되지 않습니다 (때문에 &lt;code&gt;return&lt;/code&gt; 전체 함수의 반환), &lt;code&gt;x&lt;/code&gt; 유형을 부여 할 수 있습니다 &lt;code&gt;!&lt;/code&gt; . &lt;code&gt;return 123&lt;/code&gt; 을 &lt;code&gt;panic!&lt;/code&gt; 바꿀 수도 있습니다 ! 또는 끝없는 &lt;code&gt;loop&lt;/code&gt; 와이 코드는 여전히 유효합니다.</target>
        </trans-unit>
        <trans-unit id="6e8ecdea30a2a1885eeb369d7e2426712a189f17" translate="yes" xml:space="preserve">
          <source>Although the SipHash algorithm is considered to be generally strong, it is not intended for cryptographic purposes. As such, all cryptographic uses of this implementation are &lt;em&gt;strongly discouraged&lt;/em&gt;.</source>
          <target state="translated">SipHash 알고리즘은 일반적으로 강력한 것으로 간주되지만 암호화 목적으로 사용되지는 않습니다. &lt;em&gt;따라서이&lt;/em&gt; 구현의 모든 암호화 사용은 &lt;em&gt;권장되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f07ca613351cf8dcbbc0ccd12d8ef0d4721b46b7" translate="yes" xml:space="preserve">
          <source>Although the number of keys and values is growable, each key can only have one value associated with it at a time. When you want to change the data in a hash map, you have to decide how to handle the case when a key already has a value assigned. You could replace the old value with the new value, completely disregarding the old value. You could keep the old value and ignore the new value, only adding the new value if the key &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; already have a value. Or you could combine the old value and the new value. Let&amp;rsquo;s look at how to do each of these!</source>
          <target state="translated">키와 값의 수는 늘릴 수 있지만 각 키는 한 번에 하나의 값만 가질 수 있습니다. 해시 맵에서 데이터를 변경하려면 키에 이미 값이 할당 된 경우를 처리하는 방법을 결정해야합니다. 이전 값을 완전히 무시하고 이전 값을 새 값으로 바꿀 수 있습니다. 키에 아직 값 &lt;em&gt;이없는&lt;/em&gt; 경우에만 새 값을 추가하여 이전 값을 유지하고 새 값을 무시할 수 있습니다. 또는 이전 값과 새 값을 결합 할 수 있습니다. 이들 각각을 수행하는 방법을 봅시다!</target>
        </trans-unit>
        <trans-unit id="d281e954555c8484110a6fecba9e6260dd297fe7" translate="yes" xml:space="preserve">
          <source>Although this code has the same behavior as Listing 9-5, it doesn&amp;rsquo;t contain any &lt;code&gt;match&lt;/code&gt; expressions and is cleaner to read. Come back to this example after you&amp;rsquo;ve read Chapter 13, and look up the &lt;code&gt;unwrap_or_else&lt;/code&gt; method in the standard library documentation. Many more of these methods can clean up huge nested &lt;code&gt;match&lt;/code&gt; expressions when you&amp;rsquo;re dealing with errors.</source>
          <target state="translated">이 코드는 목록 9-5와 동일한 동작을 갖지만 &lt;code&gt;match&lt;/code&gt; 표현식을 포함하지 않으며 읽기에 더 깨끗합니다. 13 장을 읽은 &lt;code&gt;unwrap_or_else&lt;/code&gt; 표준 라이브러리 문서에서 unwrap_or_else 메소드를 찾으십시오 . 이러한 방법 중 더 많은 것은 오류를 처리 할 때 거대한 중첩 된 &lt;code&gt;match&lt;/code&gt; 표현식을 정리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db0fe462f2aa334b05d61f387c6225bd0bc5a2b6" translate="yes" xml:space="preserve">
          <source>Although this code works, duplicating code is tedious and error prone. We also have to update the code in multiple places when we want to change it.</source>
          <target state="translated">이 코드는 작동하지만 중복 코드는 지루하고 오류가 발생하기 쉽습니다. 또한 코드를 변경하려면 여러 위치에서 코드를 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="094096c8e8871948579e001659d96f6f0cd91ded" translate="yes" xml:space="preserve">
          <source>Although using it won&amp;rsquo;t cause compilation warning, new code should use &lt;a href=&quot;../fmt/trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; instead and new &lt;code&gt;impl&lt;/code&gt;s can omit it.</source>
          <target state="translated">그것을 사용하면 컴파일 경고가 발생하지 않지만 새로운 코드는 &lt;a href=&quot;../fmt/trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; 를&lt;/a&gt; 대신 사용해야 하며 새로운 &lt;code&gt;impl&lt;/code&gt; 은 그것을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce3c8369369ce1fe72325205b70eb3e2961e011c" translate="yes" xml:space="preserve">
          <source>Although you can&amp;rsquo;t remove previous versions of a crate, you can prevent any future projects from adding them as a new dependency. This is useful when a crate version is broken for one reason or another. In such situations, Cargo supports &lt;em&gt;yanking&lt;/em&gt; a crate version.</source>
          <target state="translated">이전 버전의 상자를 제거 할 수는 없지만, 향후 프로젝트에서 새 버전으로 추가하지 못하게 할 수 있습니다. 이것은 크레이트 버전이 어떤 이유로 든 깨졌을 때 유용합니다. 이러한 상황에서,화물은 지원 &lt;em&gt;확 잡아 당기는&lt;/em&gt; 나무 상자 버전.</target>
        </trans-unit>
        <trans-unit id="a876dd4a0d144d06dda24f474bedf4412b3d4b86" translate="yes" xml:space="preserve">
          <source>Always empty bottom type for diverging functions</source>
          <target state="translated">분기 기능을위한 항상 빈 바닥 유형</target>
        </trans-unit>
        <trans-unit id="30044213367fd946b86a46fbbf0f3c415f92d7bc" translate="yes" xml:space="preserve">
          <source>Always returns &lt;code&gt;Err&lt;/code&gt; on arithmetic overflow.</source>
          <target state="translated">산술 오버플로에서 항상 &lt;code&gt;Err&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="81c2dadc15a7e41133f5895d6079a63549a2abb5" translate="yes" xml:space="preserve">
          <source>Always returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;needle&lt;/code&gt; is an empty slice:</source>
          <target state="translated">항상 반환 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;needle&lt;/code&gt; 빈 조각입니다 :</target>
        </trans-unit>
        <trans-unit id="0d0ce480d587247832892434b17dbf1b556a5191" translate="yes" xml:space="preserve">
          <source>Always use &lt;code&gt;.add(count)&lt;/code&gt; instead when possible, because &lt;code&gt;add&lt;/code&gt; allows the compiler to optimize better.</source>
          <target state="translated">&lt;code&gt;add&lt;/code&gt; 를 사용하면 컴파일러가 더 잘 최적화 할 수 있으므로 가능하면 항상 &lt;code&gt;.add(count)&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2dbc1421ee3e3a275bd2bb6e8f64943056afdc31" translate="yes" xml:space="preserve">
          <source>Always use &lt;code&gt;.offset(count)&lt;/code&gt; instead when possible, because &lt;code&gt;offset&lt;/code&gt; allows the compiler to optimize better. If you need to cross object boundaries, cast the pointer to an integer and do the arithmetic there.</source>
          <target state="translated">&lt;code&gt;offset&lt;/code&gt; 사용하면 컴파일러가 더 잘 최적화 할 수 있으므로 가능하면 항상 &lt;code&gt;.offset(count)&lt;/code&gt; 를 사용하십시오. 객체 경계를 넘어야하는 경우 포인터를 정수로 캐스트하고 거기서 산술하십시오.</target>
        </trans-unit>
        <trans-unit id="701562825affe99f99fee809f333cf1e955284e4" translate="yes" xml:space="preserve">
          <source>Always use &lt;code&gt;.sub(count)&lt;/code&gt; instead when possible, because &lt;code&gt;sub&lt;/code&gt; allows the compiler to optimize better.</source>
          <target state="translated">&lt;code&gt;sub&lt;/code&gt; 를 사용하면 컴파일러가 더 잘 최적화 할 수 있으므로 가능한 경우 항상 &lt;code&gt;.sub(count)&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9fda5d5730cef377a6f455b42dbcfb53fb2ca5ca" translate="yes" xml:space="preserve">
          <source>Among other causes, &lt;code&gt;ParseIntError&lt;/code&gt; can be thrown because of leading or trailing whitespace in the string e.g., when it is obtained from the standard input. Using the &lt;a href=&quot;../primitive.str#method.trim&quot;&gt;&lt;code&gt;str.trim()&lt;/code&gt;&lt;/a&gt; method ensures that no whitespace remains before parsing.</source>
          <target state="translated">다른 원인들 중에서도 &lt;code&gt;ParseIntError&lt;/code&gt; 는 문자열에서 선행 또는 후행 공백 때문에 표준 입력에서 얻을 때 발생할 수 있습니다. 은 Using &lt;a href=&quot;../primitive.str#method.trim&quot;&gt; &lt;code&gt;str.trim()&lt;/code&gt; &lt;/a&gt; 이없는 공백 남아 구문 분석하기 전에 방법 보장하지만합니다.</target>
        </trans-unit>
        <trans-unit id="f82aa4d4f03b38410c80f80025c8644ba744b247" translate="yes" xml:space="preserve">
          <source>Among other causes, this variant will be constructed when parsing a string that contains a letter.</source>
          <target state="translated">다른 원인 중에서도이 변형은 문자가 포함 된 문자열을 구문 분석 할 때 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="e8d19d51f5faed38ee6324a9eb71c292315da9f7" translate="yes" xml:space="preserve">
          <source>Among other causes, this variant will be constructed when parsing an empty string.</source>
          <target state="translated">다른 원인 중에서도이 변형은 빈 문자열을 구문 분석 할 때 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="1692574d1eb8d1443991c925dc8e2acd8ed2cbd7" translate="yes" xml:space="preserve">
          <source>An &quot;or&quot; pattern was used where the variable bindings are not consistently bound across patterns.</source>
          <target state="translated">변수 바인딩이 패턴에 일관되게 바인딩되지 않은 &quot;또는&quot;패턴이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="43d68d3a293f07f835d90c6279bf8faa22ceb0c8" translate="yes" xml:space="preserve">
          <source>An &amp;lsquo;abstract syntax tree&amp;rsquo;, or &amp;lsquo;AST&amp;rsquo;, is an intermediate representation of the structure of the program when the compiler is compiling it.</source>
          <target state="translated">'추상 구문 트리'또는 'AST'는 컴파일러가 컴파일 할 때 프로그램 구조의 중간 표현입니다.</target>
        </trans-unit>
        <trans-unit id="db2d4110f56313292c834e1861a95c89c601039f" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../../../result/enum.result#Err.v&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method:</source>
          <target state="translated">&lt;a href=&quot;../../../result/enum.result#Err.v&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 방법에 전달됩니다 :</target>
        </trans-unit>
        <trans-unit id="c2d78c88964f9736a45223d8f771f07ad6bd857e" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method:</source>
          <target state="translated">&lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 방법에 전달됩니다 :</target>
        </trans-unit>
        <trans-unit id="0a7f0956daf2ce936a64a4b1e04b5752d5af8c85" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt; item&lt;/a&gt; declares both the type and a number of &lt;em&gt;variants&lt;/em&gt;, each of which is independently named and has the syntax of a struct, tuple struct or unit-like struct.</source>
          <target state="translated">&lt;a href=&quot;../items/enumerations&quot;&gt; &lt;code&gt;enum&lt;/code&gt; 항목&lt;/a&gt; 유형과 다수 모두 선언 &lt;em&gt;변형&lt;/em&gt; 독립적이라는 및 구조체 튜플 구조체 구조체 또는 장치와 같은 구문을 갖고, 각각의이.</target>
        </trans-unit>
        <trans-unit id="eccb90f6f9e2e1cba49165645ca18ce97f7c3bdc" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method:</source>
          <target state="translated">&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 방법에 전달됩니다 :</target>
        </trans-unit>
        <trans-unit id="ee613500276e22e6ef67273653d1676ba809144c" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;items&quot;&gt;item&lt;/a&gt; that is not a member of an &lt;a href=&quot;items/implementations&quot;&gt;implementation&lt;/a&gt;, such as a &lt;em&gt;free function&lt;/em&gt; or a &lt;em&gt;free const&lt;/em&gt;. Contrast to an &lt;a href=&quot;glossary#associated-item&quot;&gt;associated item&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;items&quot;&gt;항목&lt;/a&gt; 의 구성원이 아닌 &lt;a href=&quot;items/implementations&quot;&gt;실시&lt;/a&gt; 예로서, &lt;em&gt;프리 기능&lt;/em&gt; 또는 &lt;em&gt;무료 CONST&lt;/em&gt; . &lt;a href=&quot;glossary#associated-item&quot;&gt;관련 항목과&lt;/a&gt; 대조됩니다 .</target>
        </trans-unit>
        <trans-unit id="dcdff555d3629a9d75bb0e2e48e4c4243e57c8c2" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;items/implementations&quot;&gt;implementation&lt;/a&gt; that applies to a nominal type, not to a trait-type pair. &lt;a href=&quot;items/implementations#inherent-implementations&quot;&gt;More&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;items/implementations&quot;&gt;구현&lt;/a&gt; 하지 않는 특성 형 쌍, 공칭 유형에 적용됩니다. &lt;a href=&quot;items/implementations#inherent-implementations&quot;&gt;더&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f864e2f214828c68972804234bf4534f4526fce2" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;struct.atomicbool&quot;&gt;&lt;code&gt;AtomicBool&lt;/code&gt;&lt;/a&gt; initialized to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.atomicbool&quot;&gt; &lt;code&gt;AtomicBool&lt;/code&gt; 는&lt;/a&gt; 초기화 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36aa4d3dbc6bef64eda94b67a998204c02c9bc40" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Err&lt;/code&gt; will be returned if an error occurs while flushing the buffer.</source>
          <target state="translated">&lt;code&gt;Err&lt;/code&gt; 버퍼를 플러시하는 동안 오류가 발생하면 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="08eb1e2f2f021298ee3677019a6bda280ed6f694" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Ordering&lt;/code&gt; is the result of a comparison between two values.</source>
          <target state="translated">&lt;code&gt;Ordering&lt;/code&gt; 두 값 사이의 비교의 결과이다.</target>
        </trans-unit>
        <trans-unit id="001eb435d69650fbb2db42365be5918489730c71" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;RwLock&lt;/code&gt;, like &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt;, will become poisoned on a panic. Note, however, that an &lt;code&gt;RwLock&lt;/code&gt; may only be poisoned if a panic occurs while it is locked exclusively (write mode). If a panic occurs in any reader, then the lock will not be poisoned.</source>
          <target state="translated">&lt;code&gt;RwLock&lt;/code&gt; , 같은 &lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt; , 패닉에 중독 될 것입니다. 그러나 &lt;code&gt;RwLock&lt;/code&gt; 은 독점적으로 잠겨있는 동안 패닉이 발생하는 경우 (쓰기 모드)에만 중독 될 수 있습니다. 모든 리더에서 패닉이 발생하면 잠금 장치가 손상되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5247e633cc3100e9500337757cb3044553bdf55d" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;enum&lt;/code&gt; with a discriminant must specify a &lt;code&gt;#[repr(inttype)]&lt;/code&gt;.</source>
          <target state="translated">판별자가 있는 &lt;code&gt;enum&lt;/code&gt; 은 &lt;code&gt;#[repr(inttype)]&lt;/code&gt; 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="21ec5e4c1f77a0601ab37f0e8a98cf223a18e608" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;if let&lt;/code&gt; expression is equivalent to a &lt;a href=&quot;match-expr&quot;&gt;&lt;code&gt;match&lt;/code&gt; expression&lt;/a&gt; as follows:</source>
          <target state="translated">&lt;code&gt;if let&lt;/code&gt; 표현은 동일하다 &lt;a href=&quot;match-expr&quot;&gt; &lt;code&gt;match&lt;/code&gt; 표현&lt;/a&gt; 은 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="2ca624a02ac8519763d7ccacb2b0ad8dad16c279" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;if let&lt;/code&gt; expression is semantically similar to an &lt;code&gt;if&lt;/code&gt; expression but in place of a condition expression it expects the keyword &lt;code&gt;let&lt;/code&gt; followed by a pattern, an &lt;code&gt;=&lt;/code&gt; and a &lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee&lt;/a&gt; expression. If the value of the scrutinee matches the pattern, the corresponding block will execute. Otherwise, flow proceeds to the following &lt;code&gt;else&lt;/code&gt; block if it exists. Like &lt;code&gt;if&lt;/code&gt; expressions, &lt;code&gt;if let&lt;/code&gt; expressions have a value determined by the block that is evaluated.</source>
          <target state="translated">&lt;code&gt;if let&lt;/code&gt; 표현은 의미 상 유사하다 &lt;code&gt;if&lt;/code&gt; 표현식이 조건식의 장소에는이 키워드를 기대하지만 &lt;code&gt;let&lt;/code&gt; 패턴, 다음 &lt;code&gt;=&lt;/code&gt; 와 &lt;a href=&quot;../glossary#scrutinee&quot;&gt;scrutinee의&lt;/a&gt; 식입니다. scrutinee의 값이 패턴과 일치하면 해당 블록이 실행됩니다. 그렇지 않으면 플로우는 다음 &lt;code&gt;else&lt;/code&gt; 블록이있는 경우 진행 합니다. &lt;code&gt;if&lt;/code&gt; 식과 마찬가지로 식에 평가 된 블록에 의해 결정된 값이있는 &lt;code&gt;if let&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eee510cf708477f86b4dc6237cd892de065d1aca" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;if&lt;/code&gt; expression allows you to branch your code depending on conditions. You provide a condition and then state, &amp;ldquo;If this condition is met, run this block of code. If the condition is not met, do not run this block of code.&amp;rdquo;</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 표현은 당신이 당신의 코드가 조건에 따라 분기 할 수 있습니다. 조건을 제공 한 다음&amp;ldquo;이 조건이 충족되면이 코드 블록을 실행하십시오. 조건이 충족되지 않으면이 코드 블록을 실행하지 마십시오.&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="23bc01de0e1b8681253f7b567d2d01b7869caf61" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;if&lt;/code&gt; expression is a conditional branch in program control. The form of an &lt;code&gt;if&lt;/code&gt; expression is a condition expression, followed by a consequent block, any number of &lt;code&gt;else if&lt;/code&gt; conditions and blocks, and an optional trailing &lt;code&gt;else&lt;/code&gt; block. The condition expressions must have type &lt;code&gt;bool&lt;/code&gt;. If a condition expression evaluates to &lt;code&gt;true&lt;/code&gt;, the consequent block is executed and any subsequent &lt;code&gt;else if&lt;/code&gt; or &lt;code&gt;else&lt;/code&gt; block is skipped. If a condition expression evaluates to &lt;code&gt;false&lt;/code&gt;, the consequent block is skipped and any subsequent &lt;code&gt;else if&lt;/code&gt; condition is evaluated. If all &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else if&lt;/code&gt; conditions evaluate to &lt;code&gt;false&lt;/code&gt; then any &lt;code&gt;else&lt;/code&gt; block is executed. An if expression evaluates to the same value as the executed block, or &lt;code&gt;()&lt;/code&gt; if no block is evaluated. An &lt;code&gt;if&lt;/code&gt; expression must have the same type in all situations.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 표현은 프로그램 제어에서 조건 분기입니다. &lt;code&gt;if&lt;/code&gt; 표현식 의 형식은 조건 표현식이며 그 뒤에 결과 블록, &lt;code&gt;else if&lt;/code&gt; 조건 및 블록 수 및 선택적인 후행 &lt;code&gt;else&lt;/code&gt; 블록이옵니다. 조건식은 &lt;code&gt;bool&lt;/code&gt; 유형이어야합니다 . 조건식이 &lt;code&gt;true&lt;/code&gt; 로 평가 되면 결과 블록이 실행되고 이후의 &lt;code&gt;else if&lt;/code&gt; 또는 &lt;code&gt;else&lt;/code&gt; 블록은 건너 뜁니다. 조건식이 &lt;code&gt;false&lt;/code&gt; 로 평가 되면 결과 블록은 건너 뛰고 조건이 평가 &lt;code&gt;else if&lt;/code&gt; 후속 블록은 건너 뜁니다 . 모든 &lt;code&gt;if&lt;/code&gt; 에 &lt;code&gt;else if&lt;/code&gt; 조건이 &lt;code&gt;false&lt;/code&gt; 로 평가 &lt;code&gt;else&lt;/code&gt; 블록이 실행됩니다. if 식은 실행 된 블록과 동일한 값으로 평가되거나 블록이 평가되지 않으면 &lt;code&gt;()&lt;/code&gt; 입니다. &lt;code&gt;if&lt;/code&gt; 표현은 모든 상황에서 동일한 유형이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="8f0d0db502cd02811b94f8110c6b6a57d9c4d08b" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;if&lt;/code&gt; expression without an &lt;code&gt;else&lt;/code&gt; block has the type &lt;code&gt;()&lt;/code&gt;, so this is a type error. To resolve it, add an &lt;code&gt;else&lt;/code&gt; block having the same type as the &lt;code&gt;if&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 없이 발현 &lt;code&gt;else&lt;/code&gt; 블록 형태를 갖는다 &lt;code&gt;()&lt;/code&gt; 이 타입 에러 그래서. 이를 해결하기 위해, 추가 &lt;code&gt;else&lt;/code&gt; 와 동일한 유형 가진 블록을 &lt;code&gt;if&lt;/code&gt; 블록을.</target>
        </trans-unit>
        <trans-unit id="86c2bbd51b64dbea789df858c004c474818f64aa" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;impl Trait&lt;/code&gt; type expands to a recursive type.</source>
          <target state="translated">&lt;code&gt;impl Trait&lt;/code&gt; 유형은 재귀 형태로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="714f0cd77b96bfb041f113fa02745f0b3de0da54" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;impl Trait&lt;/code&gt; type must be expandable to a concrete type that contains no &lt;code&gt;impl Trait&lt;/code&gt; types. For example the following example tries to create an &lt;code&gt;impl Trait&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; that is equal to &lt;code&gt;[T, T]&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;impl Trait&lt;/code&gt; 유형에는 포함되어 있지 구체적인 형태로 확장해야합니다 &lt;code&gt;impl Trait&lt;/code&gt; 유형. 예를 들어 다음 예제는 &lt;code&gt;[T, T]&lt;/code&gt; 같은 &lt;code&gt;impl Trait&lt;/code&gt; 유형 &lt;code&gt;T&lt;/code&gt; 를 작성하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="ee4fc89f6e27033dd75c8304209d0e35cd3688c5" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;impl&lt;/code&gt; for a &lt;code&gt;#[marker]&lt;/code&gt; trait tried to override an associated item.</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; A에 대한 &lt;code&gt;#[marker]&lt;/code&gt; 특성은 관련 항목을 무시하려고 노력했다.</target>
        </trans-unit>
        <trans-unit id="6d1073354ecc9c5e7785479d7d2a13da928ab63a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;x&lt;/code&gt; with value &lt;code&gt;0&lt;/code&gt; will return the bit width of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;0&lt;/code&gt; 인 &lt;code&gt;x&lt;/code&gt; 는 비트 폭 &lt;code&gt;T&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="80f05b7296f4e1950e87afc07c23f9e722a69148" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;x&lt;/code&gt; with value &lt;code&gt;0&lt;/code&gt; will return the bit width of &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">값이 &lt;code&gt;0&lt;/code&gt; 인 &lt;code&gt;x&lt;/code&gt; 는 비트 폭 &lt;code&gt;T&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="534dc31a67cf35753f9f6ff5f73b65cd1ba58ab5" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;&lt;a href=&quot;../types/array&quot;&gt;array&lt;/a&gt; expression&lt;/em&gt; can be written by enclosing zero or more comma-separated expressions of uniform type in square brackets. This produces and array containing each of these values in the order they are written.</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;../types/array&quot;&gt;어레이&lt;/a&gt; 발현&lt;/em&gt; 대괄호 일정한 유형의 0 개 이상의 콤마로 분리 식 둘러싸 기록 될 수있다. 이렇게하면 작성된 각 순서대로 각 값이 포함 된 배열이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="32616f8cb6d3bd819da208e9fcccc36635a05f1e" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;&lt;code&gt;extern crate&lt;/code&gt; declaration&lt;/em&gt; specifies a dependency on an external crate. The external crate is then bound into the declaring scope as the &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt; provided in the &lt;code&gt;extern crate&lt;/code&gt; declaration. The &lt;code&gt;as&lt;/code&gt; clause can be used to bind the imported crate to a different name.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;extern crate&lt;/code&gt; 선언&lt;/em&gt; 외부 상자에 대한 종속성을 지정한다. 그런 다음 외부 상자는 &lt;code&gt;extern crate&lt;/code&gt; 선언에 제공된 &lt;a href=&quot;../identifiers&quot;&gt;식별자&lt;/a&gt; 로 선언 범위에 묶 입니다. &lt;code&gt;as&lt;/code&gt; 절은 다른 이름으로 가져온 상자를 결합하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13494e1cedf4f5c5ecdcb7c07e83d0cd9827df20" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;absolute path&lt;/em&gt; starts from a crate root by using a crate name or a literal &lt;code&gt;crate&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;절대 경로는&lt;/em&gt; 나무 상자에 이름이나 문자 사용하여 상자 루트에서 시작 &lt;code&gt;crate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86fdc788150826ae707ba926f5a66e96063c57f9" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;assignment expression&lt;/em&gt; consists of a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt; followed by an equals sign (&lt;code&gt;=&lt;/code&gt;) and a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;value expression&lt;/a&gt;. Such an expression always has the &lt;a href=&quot;../types/tuple&quot;&gt;&lt;code&gt;unit&lt;/code&gt; type&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;할당 식&lt;/em&gt; (A)의 구성 &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;장소 발현&lt;/a&gt; 등호 기호 다음에 ( &lt;code&gt;=&lt;/code&gt; )와 &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;값 표현&lt;/a&gt; . 이러한 표현식은 항상 &lt;a href=&quot;../types/tuple&quot;&gt; &lt;code&gt;unit&lt;/code&gt; 유형을&lt;/a&gt; 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="ca56087cc708820efe9481bf7313fdab4a040e22" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;associated constant declaration&lt;/em&gt; declares a signature for associated constant definitions. It is written as &lt;code&gt;const&lt;/code&gt;, then an identifier, then &lt;code&gt;:&lt;/code&gt;, then a type, finished by a &lt;code&gt;;&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;관련 상수 선언은&lt;/em&gt; 관련 상수 정의에 대한 서명을 선언합니다. &lt;code&gt;const&lt;/code&gt; 로 작성된 다음 식별자 로 작성된 다음 &lt;code&gt;:&lt;/code&gt; 을 입력 한 다음 &lt;code&gt;;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec29836d6b0ec5f807474f5934209d4fe8c7bb83" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;associated constant definition&lt;/em&gt; defines a constant associated with a type. It is written the same as a &lt;a href=&quot;constant-items&quot;&gt;constant item&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;관련 상수 정의&lt;/em&gt; 유형과 관련된 상수를 정의합니다. &lt;a href=&quot;constant-items&quot;&gt;상수 항목&lt;/a&gt; 과 동일하게 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="c9d2944c74176d8d6fa13f7d573ee85d9e742d32" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;associated function declaration&lt;/em&gt; declares a signature for an associated function definition. It is written as a function item, except the function body is replaced with a &lt;code&gt;;&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;관련 함수 선언은&lt;/em&gt; 연관된 함수 정의에 대한 서명을 선언합니다. 함수 본문이 &lt;code&gt;;&lt;/code&gt; 으로 대체되는 것을 제외하고는 함수 항목으로 작성됩니다 . .</target>
        </trans-unit>
        <trans-unit id="dce2c17d462060e477f166e6bcfabaf54ef17987" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;associated function definition&lt;/em&gt; defines a function associated with another type. It is written the same as a &lt;a href=&quot;../types/function-item&quot;&gt;function item&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;관련 함수 정의는&lt;/em&gt; 다른 유형과 관련된 함수를 정의합니다. &lt;a href=&quot;../types/function-item&quot;&gt;기능 항목&lt;/a&gt; 과 동일하게 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="ddd6d9f2bd71f652e6f6a519a466ea3ae43a3bff" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;associated type declaration&lt;/em&gt; declares a signature for associated type definitions. It is written as &lt;code&gt;type&lt;/code&gt;, then an &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt;, and finally an optional list of trait bounds.</source>
          <target state="translated">&lt;em&gt;관련된 유형 선언은&lt;/em&gt; 연관 유형 정의에 대한 서명을 선언합니다. &lt;code&gt;type&lt;/code&gt; , &lt;a href=&quot;../identifiers&quot;&gt;식별자&lt;/a&gt; 및 마지막으로 선택적인 특성 범위 목록으로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="9bd2e844486eba2a5ee0638c6e470984a319e1bf" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;associated type definition&lt;/em&gt; defines a type alias on another type. It is written as &lt;code&gt;type&lt;/code&gt;, then an &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt;, then an &lt;code&gt;=&lt;/code&gt;, and finally a &lt;a href=&quot;../types#type-expressions&quot;&gt;type&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;관련된 유형 정의는&lt;/em&gt; 다른 유형에 유형 별칭을 정의합니다. 다음과 같이 작성된다 &lt;code&gt;type&lt;/code&gt; , 다음 &lt;a href=&quot;../identifiers&quot;&gt;식별자&lt;/a&gt; , 다음 &lt;code&gt;=&lt;/code&gt; , 마침내 &lt;a href=&quot;../types#type-expressions&quot;&gt;타입&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="335c18325b2749c2db5132eb57bce1ffbfa512dc" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;attribute&lt;/em&gt; is a general, free-form metadatum that is interpreted according to name, convention, and language and compiler version. Attributes are modeled on Attributes in &lt;a href=&quot;https://www.ecma-international.org/publications/standards/Ecma-335.htm&quot;&gt;ECMA-335&lt;/a&gt;, with the syntax coming from &lt;a href=&quot;https://www.ecma-international.org/publications/standards/Ecma-334.htm&quot;&gt;ECMA-334&lt;/a&gt; (C#).</source>
          <target state="translated">&lt;em&gt;속성은&lt;/em&gt; 이름, 규칙, 언어 및 컴파일러 버전에 따라 해석됩니다 일반, 자유 형식의 메타 데이터입니다. 속성은 &lt;a href=&quot;https://www.ecma-international.org/publications/standards/Ecma-334.htm&quot;&gt;ECMA-334&lt;/a&gt; (C #) 에서 오는 구문 으로 &lt;a href=&quot;https://www.ecma-international.org/publications/standards/Ecma-335.htm&quot;&gt;ECMA-335의&lt;/a&gt; 속성에 모델링됩니다 .</target>
        </trans-unit>
        <trans-unit id="fe8d0e2999c5dfed50da51262f087365afa14a25" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;enumerated type&lt;/em&gt; is a nominal, heterogeneous disjoint union type, denoted by the name of an &lt;a href=&quot;../items/enumerations&quot;&gt;&lt;code&gt;enum&lt;/code&gt; item&lt;/a&gt;. &lt;sup&gt;&lt;a href=&quot;enum#enumtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;em&gt;열거 형은&lt;/em&gt; 의 이름으로 표시 명목 이기종 분리 된 조합 유형이다 &lt;a href=&quot;../items/enumerations&quot;&gt; &lt;code&gt;enum&lt;/code&gt; 항목&lt;/a&gt; . &lt;sup&gt;&lt;a href=&quot;enum#enumtype&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="519b32460e4cf24cbf7584ec56a2b57870f1cdef" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;enumeration&lt;/em&gt;, also referred to as &lt;em&gt;enum&lt;/em&gt; is a simultaneous definition of a nominal &lt;a href=&quot;../types/enum&quot;&gt;enumerated type&lt;/a&gt; as well as a set of &lt;em&gt;constructors&lt;/em&gt;, that can be used to create or pattern-match values of the corresponding enumerated type.</source>
          <target state="translated">&lt;em&gt;열거&lt;/em&gt; 이라고도, &lt;em&gt;ENUM은&lt;/em&gt; 명목상의 동시 정의다&lt;a href=&quot;../types/enum&quot;&gt; 열거 형&lt;/a&gt; 뿐만 아니라 일련의 &lt;em&gt;생성자&lt;/em&gt; 생성하거나 대응 열거 형의 패턴 매치 값으로 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="670995bec677d5fc81f3189dbec41d6de7da346c" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;example term&lt;/em&gt; is an example of a term being defined.</source>
          <target state="translated">안 &lt;em&gt;예 용어&lt;/em&gt; 정의되는 용어의 한 예이다.</target>
        </trans-unit>
        <trans-unit id="03f2bd4498afb61074c0d1568fbae87b71b0a6a3" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;expression statement&lt;/em&gt; is one that evaluates an &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; and ignores its result. As a rule, an expression statement's purpose is to trigger the effects of evaluating its expression.</source>
          <target state="translated">&lt;em&gt;표현 문&lt;/em&gt; 평가되는 하나 인 &lt;a href=&quot;expressions&quot;&gt;표현을&lt;/a&gt; 하고 그 결과를 무시합니다. 일반적으로 표현식 문의 목적은 표현식 평가의 영향을 유발하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="111aa957a35f04452bf335357f4b5845abfce6b9" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;implementation&lt;/em&gt; is an item that associates items with an &lt;em&gt;implementing type&lt;/em&gt;. Implementations are defined with the keyword &lt;code&gt;impl&lt;/code&gt; and contain functions that belong to an instance of the type that is being implemented or to the type statically.</source>
          <target state="translated">&lt;em&gt;구현&lt;/em&gt; 있는 항목 연관 항목입니다 &lt;em&gt;구현 유형을&lt;/em&gt; . 구현은 키워드 &lt;code&gt;impl&lt;/code&gt; 로 정의되며 구현중인 유형의 인스턴스 또는 정적으로 유형에 속하는 함수를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="26714676268e63e4c19e025e4e919231c94ab7b4" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;integer literal&lt;/em&gt; has one of four forms:</source>
          <target state="translated">&lt;em&gt;정수 리터럴은&lt;/em&gt; 네 가지 형태 중 하나가 :</target>
        </trans-unit>
        <trans-unit id="3b04f25de241c42aa4cc17d61d52253aec0db163" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;integer&lt;/em&gt; is a number without a fractional component. We used one integer type in Chapter 2, the &lt;code&gt;u32&lt;/code&gt; type. This type declaration indicates that the value it&amp;rsquo;s associated with should be an unsigned integer (signed integer types start with &lt;code&gt;i&lt;/code&gt;, instead of &lt;code&gt;u&lt;/code&gt;) that takes up 32 bits of space. Table 3-1 shows the built-in integer types in Rust. Each variant in the Signed and Unsigned columns (for example, &lt;code&gt;i16&lt;/code&gt;) can be used to declare the type of an integer value.</source>
          <target state="translated">&lt;em&gt;정수는&lt;/em&gt; 소수 구성 요소가없는 숫자입니다. 2 장에서는 &lt;code&gt;u32&lt;/code&gt; 유형 인 정수 유형을 사용했습니다 . 이 형식 선언은 연관된 값이 32 비트의 공간을 차지하는 부호없는 정수 ( &lt;code&gt;u&lt;/code&gt; 대신 &lt;code&gt;i&lt;/code&gt; 로 시작하는 부호있는 정수) 여야 함을 나타냅니다 . 표 3-1은 Rust의 내장 정수 유형을 보여줍니다. 부호있는 열 및 부호없는 열 (예 : &lt;code&gt;i16&lt;/code&gt; )의 각 변형을 사용하여 정수 값의 유형을 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c86645edb5b5b0c86e3d214a4daf335142eb0487" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;item declaration statement&lt;/em&gt; has a syntactic form identical to an &lt;a href=&quot;items&quot;&gt;item declaration&lt;/a&gt; within a &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt;. Declaring an item within a statement block restricts its scope to the block containing the statement. The item is not given a &lt;a href=&quot;paths#canonical-paths&quot;&gt;canonical path&lt;/a&gt; nor are any sub-items it may declare. The exception to this is that associated items defined by &lt;a href=&quot;items/implementations&quot;&gt;implementations&lt;/a&gt; are still accessible in outer scopes as long as the item and, if applicable, trait are accessible. It is otherwise identical in meaning to declaring the item inside a module.</source>
          <target state="translated">&lt;em&gt;상품 선언문은&lt;/em&gt; 동일한 신택 틱 폼 갖는 &lt;a href=&quot;items&quot;&gt;아이템 선언&lt;/a&gt; 내의 &lt;a href=&quot;items/modules&quot;&gt;모듈&lt;/a&gt; . 명령문 블록 내에서 항목을 선언하면 해당 범위가 명령문을 포함하는 블록으로 제한됩니다. 품목에 &lt;a href=&quot;paths#canonical-paths&quot;&gt;정식 경로&lt;/a&gt; 가 제공되지 않거나 선언 할 수있는 하위 항목도 없습니다. 이에 대한 예외는&lt;a href=&quot;items/implementations&quot;&gt; 구현&lt;/a&gt; 에 은 항목 및 해당되는 경우 특성에 액세스 할 수있는 한 외부 범위에서 여전히 액세스 할 수 있습니다. 그렇지 않으면 모듈 내부의 항목을 선언한다는 의미가 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7cb6bea3f24f939f1296c8f5c8b195169146ee81" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;item&lt;/em&gt; is a component of a crate. Items are organized within a crate by a nested set of &lt;a href=&quot;items/modules&quot;&gt;modules&lt;/a&gt;. Every crate has a single &quot;outermost&quot; anonymous module; all further items within the crate have &lt;a href=&quot;paths&quot;&gt;paths&lt;/a&gt; within the module tree of the crate.</source>
          <target state="translated">&lt;em&gt;항목은&lt;/em&gt; 나무 상자의 구성 요소입니다. 상자 내에서 항목은 중첩 된 &lt;a href=&quot;items/modules&quot;&gt;모듈&lt;/a&gt; 세트로 구성됩니다 . 모든 상자에는 하나의 &quot;가장 바깥 쪽&quot;의 익명 모듈이 있습니다. 상자 안의 모든 추가 품목에는&lt;a href=&quot;paths&quot;&gt;&lt;/a&gt; 의 모듈 트리 내에 경로가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8df47e4537a8816a2744d87425d00def520f575a" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;octal literal&lt;/em&gt; starts with the character sequence &lt;code&gt;U+0030&lt;/code&gt;&lt;code&gt;U+006F&lt;/code&gt; (&lt;code&gt;0o&lt;/code&gt;) and continues as any mixture (with at least one digit) of octal digits and underscores.</source>
          <target state="translated">&lt;em&gt;진수 문자&lt;/em&gt; 문자 시퀀스로 시작하는 &lt;code&gt;U+0030&lt;/code&gt; &lt;code&gt;U+006F&lt;/code&gt; ( &lt;code&gt;0o&lt;/code&gt; 에서 ) 및 진수 숫자 및 밑줄 (적어도 한 디지트를 가진) 임의의 혼합물로 계속된다.</target>
        </trans-unit>
        <trans-unit id="a141d1e8af86d54f8339e504d3e1c56051728a15" translate="yes" xml:space="preserve">
          <source>An Example Program Using Structs</source>
          <target state="translated">Structs를 사용한 예제 프로그램</target>
        </trans-unit>
        <trans-unit id="5aefcb56dc6b861369f867948d8b3b7d49377bfe" translate="yes" xml:space="preserve">
          <source>An I/O Project: Building a Command Line Program</source>
          <target state="translated">I / O 프로젝트 : 명령 행 프로그램 작성</target>
        </trans-unit>
        <trans-unit id="0827868381963388a6304543297f7f95e42e9164" translate="yes" xml:space="preserve">
          <source>An IP address, either IPv4 or IPv6.</source>
          <target state="translated">IPv4 또는 IPv6의 IP 주소</target>
        </trans-unit>
        <trans-unit id="ac4cbc9b22ca704cfdd900cac5407adcf23c5edb" translate="yes" xml:space="preserve">
          <source>An IPv4 address representing an unspecified address: 0.0.0.0</source>
          <target state="translated">지정되지 않은 주소를 나타내는 IPv4 주소 : 0.0.0.0</target>
        </trans-unit>
        <trans-unit id="d2e22ab3badaaaa01e7375dd220a2065ca03f949" translate="yes" xml:space="preserve">
          <source>An IPv4 address representing the broadcast address: 255.255.255.255</source>
          <target state="translated">브로드 캐스트 주소를 나타내는 IPv4 주소 : 255.255.255.255</target>
        </trans-unit>
        <trans-unit id="5f0e70a5e365495e2ae4d74f302988b1f303a907" translate="yes" xml:space="preserve">
          <source>An IPv4 address with the address pointing to localhost: 127.0.0.1.</source>
          <target state="translated">주소가 localhost를 가리키는 IPv4 주소 : 127.0.0.1.</target>
        </trans-unit>
        <trans-unit id="c9d68f8900e66f00bfbfd5b6cf93e7f299173890" translate="yes" xml:space="preserve">
          <source>An IPv4 address.</source>
          <target state="translated">IPv4 주소</target>
        </trans-unit>
        <trans-unit id="5bb8e3b87105ecbe9c8ed2a2e3a9821088df2706" translate="yes" xml:space="preserve">
          <source>An IPv4 socket address.</source>
          <target state="translated">IPv4 소켓 주소</target>
        </trans-unit>
        <trans-unit id="a30848e04ae8ee9ab468ffa0929f622538606ceb" translate="yes" xml:space="preserve">
          <source>An IPv6 address representing localhost: &lt;code&gt;::1&lt;/code&gt;.</source>
          <target state="translated">localhost를 나타내는 IPv6 주소 : &lt;code&gt;::1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e145c57ced7f65d6f3f83ddc10fbd40d1da4596" translate="yes" xml:space="preserve">
          <source>An IPv6 address representing the unspecified address: &lt;code&gt;::&lt;/code&gt;</source>
          <target state="translated">지정되지 않은 주소를 나타내는 IPv6 주소 : &lt;code&gt;::&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee7dda9f630704f82008f3562e22d445246045b1" translate="yes" xml:space="preserve">
          <source>An IPv6 address.</source>
          <target state="translated">IPv6 주소</target>
        </trans-unit>
        <trans-unit id="51d9d6e575aa92d12e0b2c0fb0d5fdcf4923ff85" translate="yes" xml:space="preserve">
          <source>An IPv6 socket address.</source>
          <target state="translated">IPv6 소켓 주소</target>
        </trans-unit>
        <trans-unit id="bb7fb098f948c20be5364a0797d6630c8f71fe36" translate="yes" xml:space="preserve">
          <source>An RAII implementation of a &quot;scoped lock&quot; of a mutex. When this structure is dropped (falls out of scope), the lock will be unlocked.</source>
          <target state="translated">뮤텍스의 &quot;범위 잠금&quot;의 RAII 구현. 이 구조가 삭제되면 (범위를 벗어남) 잠금이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="445fdaee68caea7b120e9af421a1f499e812ae92" translate="yes" xml:space="preserve">
          <source>An additional advantage of using Cargo is that the commands are the same no matter which operating system you&amp;rsquo;re working on. So, at this point, we&amp;rsquo;ll no longer provide specific instructions for Linux and macOS versus Windows.</source>
          <target state="translated">Cargo를 사용하는 또 다른 이점은 작업중인 운영 체제에 관계없이 명령이 동일하다는 것입니다. 따라서 현재로서는 Linux 및 macOS와 Windows에 대한 특정 지침을 더 이상 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="71d51fdd16cd827000271f90af417efeb9cea05f" translate="yes" xml:space="preserve">
          <source>An address associated with a Unix socket.</source>
          <target state="translated">유닉스 소켓과 관련된 주소.</target>
        </trans-unit>
        <trans-unit id="13ebc470b9c08ca083e04f253e5b3a814fa55f28" translate="yes" xml:space="preserve">
          <source>An anchor in time which can be used to create new &lt;code&gt;SystemTime&lt;/code&gt; instances or learn about where in time a &lt;code&gt;SystemTime&lt;/code&gt; lies.</source>
          <target state="translated">새로운 만들 수 있습니다 시간에 앵커 &lt;code&gt;SystemTime&lt;/code&gt; 인스턴스를 어디서 시간에 대한 자세한 내용은 &lt;code&gt;SystemTime&lt;/code&gt; 거짓말.</target>
        </trans-unit>
        <trans-unit id="65f427918d6366c3545d7bcd1528880b6655f86b" translate="yes" xml:space="preserve">
          <source>An array is a fixed-size sequence of &lt;code&gt;N&lt;/code&gt; elements of type &lt;code&gt;T&lt;/code&gt;. The array type is written as &lt;code&gt;[T; N]&lt;/code&gt;. The size is an expression that evaluates to a &lt;a href=&quot;numeric#machine-dependent-integer-types&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">배열은 &lt;code&gt;T&lt;/code&gt; 형 의 &lt;code&gt;N&lt;/code&gt; 요소의 고정 크기 시퀀스입니다 . 배열 유형은 &lt;code&gt;[T; N]&lt;/code&gt; N] . 크기는 &lt;a href=&quot;numeric#machine-dependent-integer-types&quot;&gt; &lt;code&gt;usize&lt;/code&gt; 로&lt;/a&gt; 평가되는 표현식입니다 .</target>
        </trans-unit>
        <trans-unit id="d98f60a77f0bbfa809e448ded22428fbfae4e33e" translate="yes" xml:space="preserve">
          <source>An array is a single chunk of memory allocated on the stack. You can access elements of an array using indexing, like this:</source>
          <target state="translated">배열은 스택에 할당 된 단일 메모리 청크입니다. 다음과 같이 인덱싱을 사용하여 배열의 요소에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7bac5ec811f30188ce6fd849b796ac2d30ffddc" translate="yes" xml:space="preserve">
          <source>An array itself is not iterable:</source>
          <target state="translated">배열 자체는 반복 할 수 없습니다 :</target>
        </trans-unit>
        <trans-unit id="f510f3fd4950ebae5518ce0880fd83877599bc5e" translate="yes" xml:space="preserve">
          <source>An array or slice pattern required more elements than were present in the matched array.</source>
          <target state="translated">배열 또는 슬라이스 패턴에는 일치하는 배열에있는 것보다 많은 요소가 필요했습니다.</target>
        </trans-unit>
        <trans-unit id="005f7187c479dcce2321a163ab284d4855025280" translate="yes" xml:space="preserve">
          <source>An array or slice pattern was matched against some other type.</source>
          <target state="translated">배열 또는 슬라이스 패턴이 다른 유형과 일치했습니다.</target>
        </trans-unit>
        <trans-unit id="910b39cfa9beb5c32b52af8b271e7bb38ba1d4da" translate="yes" xml:space="preserve">
          <source>An array without a fixed length was pattern-matched.</source>
          <target state="translated">고정 길이가없는 배열은 패턴과 일치했습니다.</target>
        </trans-unit>
        <trans-unit id="9f6ee782e8b3dacab5901a68a88743cdf8f6df8d" translate="yes" xml:space="preserve">
          <source>An array, sometimes also called a fixed-size array or an inline array, is a value describing a collection of elements, each selected by an index that can be computed at run time by the program. It occupies a contiguous region of memory.</source>
          <target state="translated">고정 크기 배열 또는 인라인 배열이라고도하는 배열은 프로그램에서 런타임에 계산할 수있는 인덱스로 각각 선택된 요소 컬렉션을 설명하는 값입니다. 연속 된 메모리 영역을 차지합니다.</target>
        </trans-unit>
        <trans-unit id="704af6b84f8ec0b7b57fdf7ea0ff93aa51a032a6" translate="yes" xml:space="preserve">
          <source>An associated const was implemented when another trait item was expected. Erroneous code example:</source>
          <target state="translated">다른 특성 아이템이 예상되었을 때 관련 const가 구현되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="ac10e51ff90ef78acbd226706348e7754e0cff2c" translate="yes" xml:space="preserve">
          <source>An associated function for a trait was defined to be a method (i.e., to take a &lt;code&gt;self&lt;/code&gt; parameter), but an implementation of the trait declared the same function to be static.</source>
          <target state="translated">특성에 대한 관련 함수는 메소드 (즉, &lt;code&gt;self&lt;/code&gt; 매개 변수 사용)로 정의되었지만 특성의 구현은 동일한 함수를 정적이라고 선언했습니다.</target>
        </trans-unit>
        <trans-unit id="825b9fd38095eee93e418cc09ae8f9ace5e1f868" translate="yes" xml:space="preserve">
          <source>An associated function for a trait was defined to be static, but an implementation of the trait declared the same function to be a method (i.e., to take a &lt;code&gt;self&lt;/code&gt; parameter).</source>
          <target state="translated">특성에 대한 관련 함수는 정적 인 것으로 정의되었지만 특성의 구현은 동일한 함수를 메소드 (즉, &lt;code&gt;self&lt;/code&gt; 매개 변수 사용)로 선언했습니다 .</target>
        </trans-unit>
        <trans-unit id="1035c9277b00c3deebef8eabfe1b836a5766b141" translate="yes" xml:space="preserve">
          <source>An associated item is an item that is associated with another item. Associated items are defined in &lt;a href=&quot;items/implementations&quot;&gt;implementations&lt;/a&gt; and declared in &lt;a href=&quot;items/traits&quot;&gt;traits&lt;/a&gt;. Only functions, constants, and type aliases can be associated. Contrast to a &lt;a href=&quot;glossary#free-item&quot;&gt;free item&lt;/a&gt;.</source>
          <target state="translated">연관된 항목은 다른 항목과 연관된 항목입니다. 관련 항목은 &lt;a href=&quot;items/implementations&quot;&gt;구현&lt;/a&gt; 에서 정의 되고 &lt;a href=&quot;items/traits&quot;&gt;특성으로&lt;/a&gt; 선언됩니다 . 함수, 상수 및 유형 별칭 만 연결할 수 있습니다. &lt;a href=&quot;glossary#free-item&quot;&gt;무료 상품과&lt;/a&gt; 대조 .</target>
        </trans-unit>
        <trans-unit id="9116723797d95c7e68863b40ba3626f52a6ce11f" translate="yes" xml:space="preserve">
          <source>An associated type binding was done outside of the type parameter declaration and &lt;code&gt;where&lt;/code&gt; clause. Erroneous code example:</source>
          <target state="translated">연관된 유형 바인딩이 유형 매개 변수 선언 및 &lt;code&gt;where&lt;/code&gt; 절 외부에서 수행되었습니다 . 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="01d78cadc098f0f8d19a172d639f50a5e45d007b" translate="yes" xml:space="preserve">
          <source>An associated type was implemented when another trait item was expected. Erroneous code example:</source>
          <target state="translated">다른 특성 아이템이 예상 될 때 관련 유형이 구현되었습니다. 잘못된 코드 예 :</target>
        </trans-unit>
        <trans-unit id="ca2d4322730aa4a674f88f33ea28a7a44379f38a" translate="yes" xml:space="preserve">
          <source>An asterisk &lt;code&gt;.*&lt;/code&gt;:</source>
          <target state="translated">별표 &lt;code&gt;.*&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fcbf33b833d8349f917a7e3318533a910b1e01c0" translate="yes" xml:space="preserve">
          <source>An asynchronous, infinitely buffered channel. The &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; function will return a &lt;code&gt;(Sender, Receiver)&lt;/code&gt; tuple where all sends will be &lt;strong&gt;asynchronous&lt;/strong&gt; (they never block). The channel conceptually has an infinite buffer.</source>
          <target state="translated">비동기식으로 무한 버퍼링 된 채널. &lt;a href=&quot;fn.channel&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt; 함수 반환 &lt;code&gt;(Sender, Receiver)&lt;/code&gt; 는 모두 전송 될 것이다 튜플 &lt;strong&gt;비동기&lt;/strong&gt; (블록들이 결코 참조). 채널에는 개념적으로 무한 버퍼가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f387b126eb53d62fa04e8482ab5a1aac01b56bf6" translate="yes" xml:space="preserve">
          <source>An atomic fence.</source>
          <target state="translated">원자 울타리.</target>
        </trans-unit>
        <trans-unit id="a37a15efc349a5896258ef2d831759eaab050729" translate="yes" xml:space="preserve">
          <source>An atomic integer initialized to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">원자 정수는 &lt;code&gt;0&lt;/code&gt; 으로 초기화되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ae4be8bb4563b5c446bf4ec14a3a559fbf234d0d" translate="yes" xml:space="preserve">
          <source>An attempt to implement the &lt;code&gt;Copy&lt;/code&gt; trait for a struct failed because one of the fields does not implement &lt;code&gt;Copy&lt;/code&gt;. To fix this, you must implement &lt;code&gt;Copy&lt;/code&gt; for the mentioned field. Note that this may not be possible, as in the example of</source>
          <target state="translated">구현하는 시도 &lt;code&gt;Copy&lt;/code&gt; 필드 중 하나가 구현하지 않기 때문에 구조체에 대한 특성은 실패 &lt;code&gt;Copy&lt;/code&gt; . 이 문제를 해결하려면 언급 된 필드에 대해 &lt;code&gt;Copy&lt;/code&gt; 를 구현해야 합니다. 의 예에서와 같이 가능하지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b71c2935e96e5f7fe3e3f35ad00fd7b30920019f" translate="yes" xml:space="preserve">
          <source>An attempt to index into a type which doesn't implement the &lt;code&gt;std::ops::Index&lt;/code&gt; trait was performed.</source>
          <target state="translated">&lt;code&gt;std::ops::Index&lt;/code&gt; 특성을 구현하지 않는 유형으로 색인을 시도 했습니다.</target>
        </trans-unit>
        <trans-unit id="8febb37ae18b2d657b2615e5b330d2a55118441d" translate="yes" xml:space="preserve">
          <source>An attempt was made to implement &lt;code&gt;Drop&lt;/code&gt; on a concrete specialization of a generic type. An example is shown below:</source>
          <target state="translated">일반 유형의 구체적인 전문화에서 &lt;code&gt;Drop&lt;/code&gt; 을 구현하려고 시도했습니다 . 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="09ba79d4404f5653d6f77e24331c8ba336aac40d" translate="yes" xml:space="preserve">
          <source>An attempt was made to implement &lt;code&gt;Drop&lt;/code&gt; on a specialization of a generic type. An example is shown below:</source>
          <target state="translated">일반 유형의 특수화에서 &lt;code&gt;Drop&lt;/code&gt; 을 구현하려고했습니다 . 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c55e6f81b7dc27d46319cedb33bad7716f5297f4" translate="yes" xml:space="preserve">
          <source>An attempt was made to implement Drop on a trait, which is not allowed: only structs and enums can implement Drop. An example causing this error:</source>
          <target state="translated">특성에 Drop을 구현하려는 시도는 허용되지 않았습니다. 구조체와 열거 만 Drop을 구현할 수 있습니다. 이 오류를 일으키는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e153b913d67d75c58662cead8cf242032c80e00b" translate="yes" xml:space="preserve">
          <source>An attempt was made to mutate data using a non-mutable reference. This commonly occurs when attempting to assign to a non-mutable reference of a mutable reference (&lt;code&gt;&amp;amp;(&amp;amp;mut T)&lt;/code&gt;).</source>
          <target state="translated">변경 불가능한 참조를 사용하여 데이터를 변경하려고했습니다. 이는 일반적으로 변경 불가능한 참조의 변경 불가능한 참조 ( &lt;code&gt;&amp;amp;(&amp;amp;mut T)&lt;/code&gt; ) 에 지정하려고 할 때 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="adb3222e10ca68a4902e2fef67ce06d659218b60" translate="yes" xml:space="preserve">
          <source>An attempt was made to retrieve an associated type, but the type was ambiguous. For example:</source>
          <target state="translated">연관된 유형을 검색하려고 시도했지만 유형이 모호했습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="89de6efbf294db50ea9580038de7bf4a99c6cc2d" translate="yes" xml:space="preserve">
          <source>An attempted conversion that consumes &lt;code&gt;self&lt;/code&gt;, which may or may not be expensive.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 를 소비하는 전환을 시도했지만 비용이 많이 들거나 들지 않습니다.</target>
        </trans-unit>
        <trans-unit id="863f680a55f734bd0dbbca55a32cd8aa13a2d823" translate="yes" xml:space="preserve">
          <source>An attribute is either active or inert. During attribute processing, &lt;em&gt;active attributes&lt;/em&gt; remove themselves from the thing they are on while &lt;em&gt;inert attributes&lt;/em&gt; stay on.</source>
          <target state="translated">속성이 활성 또는 비활성입니다. 속성 처리 중 &lt;em&gt;활성 속성&lt;/em&gt; 은 &lt;em&gt;비활성 속성이&lt;/em&gt; 유지되는 동안 &lt;em&gt;현재 속성에서&lt;/em&gt; 제거 됩니다.</target>
        </trans-unit>
        <trans-unit id="8f22761bfa3bdfb0003204a934bf1010c9716a93" translate="yes" xml:space="preserve">
          <source>An empty buffer returned indicates that the stream has reached EOF.</source>
          <target state="translated">빈 버퍼가 반환되면 스트림이 EOF에 도달했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="dc01027756efda949405e0e59c0d834ec342e061" translate="yes" xml:space="preserve">
          <source>An empty iterator returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">빈 이터레이터는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="442cf9396651f26f54eeff92f4dde433d7f72454" translate="yes" xml:space="preserve">
          <source>An empty iterator returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">빈 이터레이터는 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="e3ba001b1a53998b8d224cd77e4663359ef99e71" translate="yes" xml:space="preserve">
          <source>An empty iterator returns the one value of the type.</source>
          <target state="translated">빈 반복자는 유형의 하나의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="54261d577d85895bf8c09d3febd150e6fae82418" translate="yes" xml:space="preserve">
          <source>An empty iterator returns the zero value of the type.</source>
          <target state="translated">빈 반복자는 유형의 0 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="95f62854280c7cd5daf0c2b6b4a29d4a8c72ac30" translate="yes" xml:space="preserve">
          <source>An endpoint of a range of keys.</source>
          <target state="translated">키 범위의 엔드 포인트</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
