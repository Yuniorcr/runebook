<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="34977281a088ed668126c16ffced4c672d9ee045" translate="yes" xml:space="preserve">
          <source>Function std::mem::forget</source>
          <target state="translated">기능 std :: mem :: forget</target>
        </trans-unit>
        <trans-unit id="93c2b9571818c664355ea5a0dcd917eacf555574" translate="yes" xml:space="preserve">
          <source>Function std::mem::forget_unsized</source>
          <target state="translated">함수 std :: mem :: forget_unsized</target>
        </trans-unit>
        <trans-unit id="6ddede8e9373838661e83d5e49c5870ddfc635d4" translate="yes" xml:space="preserve">
          <source>Function std::mem::min_align_of</source>
          <target state="translated">함수 std :: mem :: min_align_of</target>
        </trans-unit>
        <trans-unit id="22810ad4b80752b76f6272e78e7f24408c71745f" translate="yes" xml:space="preserve">
          <source>Function std::mem::min_align_of_val</source>
          <target state="translated">함수 std :: mem :: min_align_of_val</target>
        </trans-unit>
        <trans-unit id="e1b2757db0555bef1a5af563113bea383ea658f1" translate="yes" xml:space="preserve">
          <source>Function std::mem::needs_drop</source>
          <target state="translated">기능 std :: mem :: needs_drop</target>
        </trans-unit>
        <trans-unit id="1d250c3f7215728aec0a7bfa6379b0d693c87c55" translate="yes" xml:space="preserve">
          <source>Function std::mem::replace</source>
          <target state="translated">기능 std :: mem :: replace</target>
        </trans-unit>
        <trans-unit id="273ddf6ee92bb4e40157a902d61bcf24a9c611ad" translate="yes" xml:space="preserve">
          <source>Function std::mem::size_of</source>
          <target state="translated">기능 std :: mem :: size_of</target>
        </trans-unit>
        <trans-unit id="f9365fb71c6db7ab8823f257068c1fa0c61895c4" translate="yes" xml:space="preserve">
          <source>Function std::mem::size_of_val</source>
          <target state="translated">함수 std :: mem :: size_of_val</target>
        </trans-unit>
        <trans-unit id="5bf15dfcadccab356db41c543e7d2dd0719bc54b" translate="yes" xml:space="preserve">
          <source>Function std::mem::swap</source>
          <target state="translated">기능 std :: mem :: swap</target>
        </trans-unit>
        <trans-unit id="a9a358b3691976e722e4f46966a0191a117318e2" translate="yes" xml:space="preserve">
          <source>Function std::mem::take</source>
          <target state="translated">기능 std :: mem :: take</target>
        </trans-unit>
        <trans-unit id="8000c51bce3358a180dec44b363d021f765dee13" translate="yes" xml:space="preserve">
          <source>Function std::mem::transmute</source>
          <target state="translated">기능 std :: mem :: transmute</target>
        </trans-unit>
        <trans-unit id="a34058ce750ce0e9d7fea1e2756db0e58fabdb12" translate="yes" xml:space="preserve">
          <source>Function std::mem::transmute_copy</source>
          <target state="translated">함수 std :: mem :: transmute_copy</target>
        </trans-unit>
        <trans-unit id="e2168cf325d9fdb4bb40acb9002e87cae0a35230" translate="yes" xml:space="preserve">
          <source>Function std::mem::uninitialized</source>
          <target state="translated">기능 std :: mem :: uninitialized</target>
        </trans-unit>
        <trans-unit id="d6aee94a962f29ccad67cacb5695c37eb2e57120" translate="yes" xml:space="preserve">
          <source>Function std::mem::zeroed</source>
          <target state="translated">기능 std :: mem :: zeroed</target>
        </trans-unit>
        <trans-unit id="9fbabcc1415c98e197c63a5df4d5f8ec75a6fd2b" translate="yes" xml:space="preserve">
          <source>Function std::os::unix::fs::symlink</source>
          <target state="translated">기능 std :: os :: unix :: fs :: symlink</target>
        </trans-unit>
        <trans-unit id="0cb9d4491f67786e23110780ee139d285c647816" translate="yes" xml:space="preserve">
          <source>Function std::os::unix::process::parent_id</source>
          <target state="translated">함수 std :: os :: unix :: process :: parent_id</target>
        </trans-unit>
        <trans-unit id="955a8b38ef9ca7cc74dba342165900b733f89c71" translate="yes" xml:space="preserve">
          <source>Function std::os::windows::fs::symlink_dir</source>
          <target state="translated">기능 std :: os :: windows :: fs :: symlink_dir</target>
        </trans-unit>
        <trans-unit id="7030c8af6886acb93aefd94038042b18937920ce" translate="yes" xml:space="preserve">
          <source>Function std::os::windows::fs::symlink_file</source>
          <target state="translated">기능 std :: os :: windows :: fs :: symlink_file</target>
        </trans-unit>
        <trans-unit id="8561ba72a9691a11d16234536f898f0406c41e4b" translate="yes" xml:space="preserve">
          <source>Function std::panic::catch_unwind</source>
          <target state="translated">기능 std :: panic :: catch_unwind</target>
        </trans-unit>
        <trans-unit id="d0b54652683b0f081f3c450fac3c724be97e0e07" translate="yes" xml:space="preserve">
          <source>Function std::panic::resume_unwind</source>
          <target state="translated">기능 std :: panic :: resume_unwind</target>
        </trans-unit>
        <trans-unit id="39271975d3373b9cea19608740e1ec82ed2ae6b7" translate="yes" xml:space="preserve">
          <source>Function std::panic::set_hook</source>
          <target state="translated">기능 std :: panic :: set_hook</target>
        </trans-unit>
        <trans-unit id="bbe33939a3aefba77a1076ac9c7e64784a3a15b1" translate="yes" xml:space="preserve">
          <source>Function std::panic::take_hook</source>
          <target state="translated">기능 std :: panic :: take_hook</target>
        </trans-unit>
        <trans-unit id="25a8c22b45e0de0551522051b0461b2b6ab3b0ee" translate="yes" xml:space="preserve">
          <source>Function std::path::is_separator</source>
          <target state="translated">함수 std :: path :: is_separator</target>
        </trans-unit>
        <trans-unit id="f5cf3f4b834aa36120f315ecc6215ba2718045a8" translate="yes" xml:space="preserve">
          <source>Function std::process::abort</source>
          <target state="translated">기능 std :: process :: abort</target>
        </trans-unit>
        <trans-unit id="91cb6a8fd57a0224ea3dfbfbdf9c471db4732292" translate="yes" xml:space="preserve">
          <source>Function std::process::exit</source>
          <target state="translated">기능 std :: process :: exit</target>
        </trans-unit>
        <trans-unit id="64d60f6bf21bdc40c4034158a74b2e2029d72d52" translate="yes" xml:space="preserve">
          <source>Function std::process::id</source>
          <target state="translated">기능 std :: process :: id</target>
        </trans-unit>
        <trans-unit id="fde6de7146b98e72342b68e2f087fb2c0df102c7" translate="yes" xml:space="preserve">
          <source>Function std::ptr::copy</source>
          <target state="translated">함수 std :: ptr :: copy</target>
        </trans-unit>
        <trans-unit id="a761215fdab6c66c0e836d73083b80b5919290f7" translate="yes" xml:space="preserve">
          <source>Function std::ptr::copy_nonoverlapping</source>
          <target state="translated">함수 std :: ptr :: copy_nonoverlapping</target>
        </trans-unit>
        <trans-unit id="e5cd973501b571a40a9d66363842f4e1f61d69db" translate="yes" xml:space="preserve">
          <source>Function std::ptr::drop_in_place</source>
          <target state="translated">함수 std :: ptr :: drop_in_place</target>
        </trans-unit>
        <trans-unit id="7d8139ca630c43a21993cd3cc28785c5944a7309" translate="yes" xml:space="preserve">
          <source>Function std::ptr::eq</source>
          <target state="translated">기능 std :: ptr :: eq</target>
        </trans-unit>
        <trans-unit id="9f66565ab45d94ff05fc6926dcfe0bbd68272b62" translate="yes" xml:space="preserve">
          <source>Function std::ptr::hash</source>
          <target state="translated">함수 std :: ptr :: hash</target>
        </trans-unit>
        <trans-unit id="a03cdb32dfba992c5ba308341a9ecf47921cafcd" translate="yes" xml:space="preserve">
          <source>Function std::ptr::null</source>
          <target state="translated">함수 std :: ptr :: null</target>
        </trans-unit>
        <trans-unit id="4c7d5ac57a6bf5a7b544b85794d87b81e4bab2bb" translate="yes" xml:space="preserve">
          <source>Function std::ptr::null_mut</source>
          <target state="translated">함수 std :: ptr :: null_mut</target>
        </trans-unit>
        <trans-unit id="c850fed4a12786c6b64cf8983a8b4ed6836f871b" translate="yes" xml:space="preserve">
          <source>Function std::ptr::read</source>
          <target state="translated">기능 std :: ptr :: read</target>
        </trans-unit>
        <trans-unit id="b5627f9e5c58db99606464fa93bdcc9942395ffe" translate="yes" xml:space="preserve">
          <source>Function std::ptr::read_unaligned</source>
          <target state="translated">함수 std :: ptr :: read_unaligned</target>
        </trans-unit>
        <trans-unit id="cfe13a6b31ec05872aa7514cbd914f1bb5861485" translate="yes" xml:space="preserve">
          <source>Function std::ptr::read_volatile</source>
          <target state="translated">함수 std :: ptr :: read_volatile</target>
        </trans-unit>
        <trans-unit id="d039612bde4c6048992efb15148a025858e32b3b" translate="yes" xml:space="preserve">
          <source>Function std::ptr::replace</source>
          <target state="translated">함수 std :: ptr :: replace</target>
        </trans-unit>
        <trans-unit id="d248267b6dd81ea6d45a36bf72ea24089aebcfc9" translate="yes" xml:space="preserve">
          <source>Function std::ptr::slice_from_raw_parts</source>
          <target state="translated">함수 std :: ptr :: slice_from_raw_parts</target>
        </trans-unit>
        <trans-unit id="993ad2b27084f4ef376400115cc16edac21caa44" translate="yes" xml:space="preserve">
          <source>Function std::ptr::slice_from_raw_parts_mut</source>
          <target state="translated">함수 std :: ptr :: slice_from_raw_parts_mut</target>
        </trans-unit>
        <trans-unit id="9d32d4c811c372eac376d6b3bdbf406666808400" translate="yes" xml:space="preserve">
          <source>Function std::ptr::swap</source>
          <target state="translated">기능 std :: ptr :: swap</target>
        </trans-unit>
        <trans-unit id="ddca334754be5ad5ccbbcff1fdd2a964723a383a" translate="yes" xml:space="preserve">
          <source>Function std::ptr::swap_nonoverlapping</source>
          <target state="translated">함수 std :: ptr :: swap_nonoverlapping</target>
        </trans-unit>
        <trans-unit id="0a29c6829aba2904ca27c5fa1c9fe49944ebe1c7" translate="yes" xml:space="preserve">
          <source>Function std::ptr::write</source>
          <target state="translated">함수 std :: ptr :: write</target>
        </trans-unit>
        <trans-unit id="6f751c45c330611925cbdc91328104f0d8563329" translate="yes" xml:space="preserve">
          <source>Function std::ptr::write_bytes</source>
          <target state="translated">함수 std :: ptr :: write_bytes</target>
        </trans-unit>
        <trans-unit id="1fda9527bc74f49c29a63948c2c6dbd1ab94b1f4" translate="yes" xml:space="preserve">
          <source>Function std::ptr::write_unaligned</source>
          <target state="translated">함수 std :: ptr :: write_unaligned</target>
        </trans-unit>
        <trans-unit id="6144b17aff45708885f2b21a0ccd281ad4b03511" translate="yes" xml:space="preserve">
          <source>Function std::ptr::write_volatile</source>
          <target state="translated">함수 std :: ptr :: write_volatile</target>
        </trans-unit>
        <trans-unit id="a2b7a6ea0f1d928fd925aaf7a8ce4d41592caaba" translate="yes" xml:space="preserve">
          <source>Function std::slice::from_mut</source>
          <target state="translated">함수 std :: slice :: from_mut</target>
        </trans-unit>
        <trans-unit id="c9b1f099f247a42a47b176a483889ae2efb191a9" translate="yes" xml:space="preserve">
          <source>Function std::slice::from_raw_parts</source>
          <target state="translated">함수 std :: slice :: from_raw_parts</target>
        </trans-unit>
        <trans-unit id="1572930120c6eeb9d2f52363340245d3c52eeaa2" translate="yes" xml:space="preserve">
          <source>Function std::slice::from_raw_parts_mut</source>
          <target state="translated">함수 std :: slice :: from_raw_parts_mut</target>
        </trans-unit>
        <trans-unit id="ec11607378374baf49258a7deea8633da5e2c00f" translate="yes" xml:space="preserve">
          <source>Function std::slice::from_ref</source>
          <target state="translated">함수 std :: slice :: from_ref</target>
        </trans-unit>
        <trans-unit id="5f10d43fc04f417378de60595b6a08287404fc58" translate="yes" xml:space="preserve">
          <source>Function std::str::from_boxed_utf8_unchecked</source>
          <target state="translated">std :: str :: from_boxed_utf8_unchecked 함수</target>
        </trans-unit>
        <trans-unit id="b3494167f42728c01d009e107c9996379772b067" translate="yes" xml:space="preserve">
          <source>Function std::str::from_utf8</source>
          <target state="translated">함수 std :: str :: from_utf8</target>
        </trans-unit>
        <trans-unit id="8ab808fea002d56433d1a4c8010bde81eaf0bafe" translate="yes" xml:space="preserve">
          <source>Function std::str::from_utf8_mut</source>
          <target state="translated">함수 std :: str :: from_utf8_mut</target>
        </trans-unit>
        <trans-unit id="c9eb986ba9ada7c0b92ddab5aeb8be6542adebfb" translate="yes" xml:space="preserve">
          <source>Function std::str::from_utf8_unchecked</source>
          <target state="translated">함수 std :: str :: from_utf8_unchecked</target>
        </trans-unit>
        <trans-unit id="ff6fb073e193843ab8761db003fa3d1397bde0ae" translate="yes" xml:space="preserve">
          <source>Function std::str::from_utf8_unchecked_mut</source>
          <target state="translated">함수 std :: str :: from_utf8_unchecked_mut</target>
        </trans-unit>
        <trans-unit id="426edab7099b267d5c0fadbf655008d3c3071033" translate="yes" xml:space="preserve">
          <source>Function std::sync::atomic::compiler_fence</source>
          <target state="translated">함수 std :: sync :: atomic :: compiler_fence</target>
        </trans-unit>
        <trans-unit id="746c3ced7e8fb5967d8a30871aeec3190755754d" translate="yes" xml:space="preserve">
          <source>Function std::sync::atomic::fence</source>
          <target state="translated">기능 std :: sync :: atomic :: fence</target>
        </trans-unit>
        <trans-unit id="417c1f03a8782ffed0046f05147205a5928d2325" translate="yes" xml:space="preserve">
          <source>Function std::sync::atomic::spin_loop_hint</source>
          <target state="translated">기능 std :: sync :: atomic :: spin_loop_hint</target>
        </trans-unit>
        <trans-unit id="ca876872e4c8a255561392341646d67ae0b513b3" translate="yes" xml:space="preserve">
          <source>Function std::sync::mpsc::channel</source>
          <target state="translated">기능 std :: sync :: mpsc :: channel</target>
        </trans-unit>
        <trans-unit id="ed61e6291293ba5e6efc025a526a4ca0aeef12a5" translate="yes" xml:space="preserve">
          <source>Function std::sync::mpsc::sync_channel</source>
          <target state="translated">기능 std :: sync :: mpsc :: sync_channel</target>
        </trans-unit>
        <trans-unit id="0af550e5e373712dc2a979ef83bfd2ff92a021a5" translate="yes" xml:space="preserve">
          <source>Function std::thread::current</source>
          <target state="translated">기능 std :: thread :: current</target>
        </trans-unit>
        <trans-unit id="fe9807edb6332c001f6afe09456d514679fa63c2" translate="yes" xml:space="preserve">
          <source>Function std::thread::panicking</source>
          <target state="translated">기능 std :: thread :: panicking</target>
        </trans-unit>
        <trans-unit id="9315e3ef8d5452c0247f62dbf54f7a6f10da132d" translate="yes" xml:space="preserve">
          <source>Function std::thread::park</source>
          <target state="translated">기능 std :: thread :: park</target>
        </trans-unit>
        <trans-unit id="fcab5565f3d2f6769e2d47ead2f243674b5700e5" translate="yes" xml:space="preserve">
          <source>Function std::thread::park_timeout</source>
          <target state="translated">함수 std :: thread :: park_timeout</target>
        </trans-unit>
        <trans-unit id="2f1f8ca90cd667cbf91c70fd5328d42118f543d6" translate="yes" xml:space="preserve">
          <source>Function std::thread::park_timeout_ms</source>
          <target state="translated">함수 std :: thread :: park_timeout_ms</target>
        </trans-unit>
        <trans-unit id="11ae6d9580fb9910ca48b8e032535befd540831c" translate="yes" xml:space="preserve">
          <source>Function std::thread::sleep</source>
          <target state="translated">기능 std :: thread :: sleep</target>
        </trans-unit>
        <trans-unit id="1f22ee1120ba93e964441735b057a58abda65aa0" translate="yes" xml:space="preserve">
          <source>Function std::thread::sleep_ms</source>
          <target state="translated">함수 std :: thread :: sleep_ms</target>
        </trans-unit>
        <trans-unit id="659b9896115b8a757c17153932bb710d0018ce8b" translate="yes" xml:space="preserve">
          <source>Function std::thread::spawn</source>
          <target state="translated">기능 std :: thread :: spawn</target>
        </trans-unit>
        <trans-unit id="e317cb6f0697f119f701c359a0df2074f48a4962" translate="yes" xml:space="preserve">
          <source>Function std::thread::yield_now</source>
          <target state="translated">함수 std :: thread :: yield_now</target>
        </trans-unit>
        <trans-unit id="6cd47a4c3bb4392119be7e20d333f200330e1d43" translate="yes" xml:space="preserve">
          <source>Function types:</source>
          <target state="translated">기능 유형 :</target>
        </trans-unit>
        <trans-unit id="2e3030f5a7f048cef8382d50828336e71bb753d2" translate="yes" xml:space="preserve">
          <source>Function-like macros</source>
          <target state="translated">함수형 매크로</target>
        </trans-unit>
        <trans-unit id="2a9fd93daca58d7ebff71d8a39637cdf3ce39fd8" translate="yes" xml:space="preserve">
          <source>Function-like macros define macros that look like function calls. Similarly to &lt;code&gt;macro_rules!&lt;/code&gt; macros, they&amp;rsquo;re more flexible than functions; for example, they can take an unknown number of arguments. However, &lt;code&gt;macro_rules!&lt;/code&gt; macros can be defined only using the match-like syntax we discussed in the section &lt;a href=&quot;#declarative-macros-with-macro_rules-for-general-metaprogramming&quot;&gt;&amp;ldquo;Declarative Macros with &lt;code&gt;macro_rules!&lt;/code&gt; for General Metaprogramming&amp;rdquo;&lt;/a&gt; earlier. Function-like macros take a &lt;code&gt;TokenStream&lt;/code&gt; parameter and their definition manipulates that &lt;code&gt;TokenStream&lt;/code&gt; using Rust code as the other two types of procedural macros do. An example of a function-like macro is an &lt;code&gt;sql!&lt;/code&gt; macro that might be called like so:</source>
          <target state="translated">함수형 매크로는 함수 호출처럼 보이는 매크로를 정의합니다. &lt;code&gt;macro_rules!&lt;/code&gt; 유사합니다 ! 매크로는 함수보다 유연합니다. 예를 들어, 알려지지 않은 수의 인수를 취할 수 있습니다. 그러나 &lt;code&gt;macro_rules!&lt;/code&gt; 매크로는 &lt;a href=&quot;#declarative-macros-with-macro_rules-for-general-metaprogramming&quot;&gt;&amp;ldquo; &lt;code&gt;macro_rules!&lt;/code&gt; 선언적 매크로 ! &quot;일반 메타 프로그래밍에 대한&lt;/a&gt; 이전. 함수형 매크로는 &lt;code&gt;TokenStream&lt;/code&gt; 매개 변수를 사용하며 정의 는 다른 두 가지 유형의 절차 매크로와 마찬가지로 Rust 코드를 사용하여 해당 &lt;code&gt;TokenStream&lt;/code&gt; 을 조작합니다 . 함수형 매크로의 예는 &lt;code&gt;sql!&lt;/code&gt; 다음과 같이 매크로가 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13e701d0c602544129b90642819e8ce654632b4a" translate="yes" xml:space="preserve">
          <source>Function-like macros that look like function calls but operate on the tokens specified as their argument</source>
          <target state="translated">함수 호출처럼 보이지만 인수로 지정된 토큰에서 작동하는 함수 유사 매크로</target>
        </trans-unit>
        <trans-unit id="08300f312a4ed1b5c2034356b30682b98bac9713" translate="yes" xml:space="preserve">
          <source>Function-like procedural macros</source>
          <target state="translated">함수형 절차 매크로</target>
        </trans-unit>
        <trans-unit id="95ee21bcc50578b01a326947473e22f8250802dc" translate="yes" xml:space="preserve">
          <source>Functional Language Features: Iterators and Closures</source>
          <target state="translated">기능적 언어 기능 : 반복자와 클로저</target>
        </trans-unit>
        <trans-unit id="4e21f7bee8221a74639e92992dc14d632a7c8af0" translate="yes" xml:space="preserve">
          <source>Functional update syntax</source>
          <target state="translated">기능 업데이트 구문</target>
        </trans-unit>
        <trans-unit id="1a08f42a1b56e730c49367ca1e924228662ea26b" translate="yes" xml:space="preserve">
          <source>Functionality for ordering and comparison.</source>
          <target state="translated">주문 및 비교 기능.</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="79a1ec8a61d65a41557e7d6041585e466687237c" translate="yes" xml:space="preserve">
          <source>Functions and consts can both be defined in an implementation. A function defined in an &lt;code&gt;impl&lt;/code&gt; block can be standalone, meaning it would be called like &lt;code&gt;Foo::bar()&lt;/code&gt;. If the function takes &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;&amp;amp;self&lt;/code&gt;, or &lt;code&gt;&amp;amp;mut self&lt;/code&gt; as its first argument, it can also be called using method-call syntax, a familiar feature to any object oriented programmer, like &lt;code&gt;foo.bar()&lt;/code&gt;.</source>
          <target state="translated">함수와 const는 모두 구현에서 정의 할 수 있습니다. &lt;code&gt;impl&lt;/code&gt; 블록에 정의 된 함수 는 독립형 일 수 있으며 &lt;code&gt;Foo::bar()&lt;/code&gt; 와 같이 호출 됩니다. 함수가 &lt;code&gt;self&lt;/code&gt; , &lt;code&gt;&amp;amp;self&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut self&lt;/code&gt; 를 첫 번째 인수로 사용하는 경우 &lt;code&gt;foo.bar()&lt;/code&gt; 와 같은 객체 지향 프로그래머에게 친숙한 기능인 메소드 호출 구문을 사용하여 호출 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="349871b1a6efea930aaaf0ae51e6d8084ba76744" translate="yes" xml:space="preserve">
          <source>Functions are pervasive in Rust code. You&amp;rsquo;ve already seen one of the most important functions in the language: the &lt;code&gt;main&lt;/code&gt; function, which is the entry point of many programs. You&amp;rsquo;ve also seen the &lt;code&gt;fn&lt;/code&gt; keyword, which allows you to declare new functions.</source>
          <target state="translated">Rust 코드에는 함수가 널리 사용됩니다. 이미 언어에서 가장 중요한 기능 중 하나 인 &lt;code&gt;main&lt;/code&gt; 기능은 많은 프로그램의 진입 점입니다. 새로운 기능을 선언 할 수있는 &lt;code&gt;fn&lt;/code&gt; 키워드 도 보았습니다 .</target>
        </trans-unit>
        <trans-unit id="ec13d42591018f6323f28c9a51bc9ae1f1e62226" translate="yes" xml:space="preserve">
          <source>Functions are the primary way code is executed within Rust. Function blocks, usually just called functions, can be defined in a variety of different places and be assigned many different attributes and modifiers.</source>
          <target state="translated">함수는 Rust 내에서 코드가 실행되는 기본 방식입니다. 일반적으로 기능이라고하는 기능 블록은 다양한 장소에 정의 할 수 있으며 여러 가지 속성과 수정자를 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c9b40f565c06060c423846265af5229e6fca5a3" translate="yes" xml:space="preserve">
          <source>Functions can also be defined to have &lt;em&gt;parameters&lt;/em&gt;, which are special variables that are part of a function&amp;rsquo;s signature. When a function has parameters, you can provide it with concrete values for those parameters. Technically, the concrete values are called &lt;em&gt;arguments&lt;/em&gt;, but in casual conversation, people tend to use the words &lt;em&gt;parameter&lt;/em&gt; and &lt;em&gt;argument&lt;/em&gt; interchangeably for either the variables in a function&amp;rsquo;s definition or the concrete values passed in when you call a function.</source>
          <target state="translated">또한 함수는 시그니처의 일부인 특수 변수 인 &lt;em&gt;parameters&lt;/em&gt; 를 갖도록 정의 할 수 있습니다 . 함수에 매개 변수가 있으면 해당 매개 변수에 대한 구체적인 값을 제공 할 수 있습니다. 기술적으로 구체적인 값은 &lt;em&gt;arguments&lt;/em&gt; 이지만 우연한 대화에서는 사람들이 함수 정의의 변수 또는 함수를 호출 할 때 전달되는 구체적 값에 대해 단어 &lt;em&gt;매개 변수&lt;/em&gt; 와 &lt;em&gt;인수를&lt;/em&gt; 서로 바꿔 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7772489f6a9ea8bcb945930292f262cd76d7056" translate="yes" xml:space="preserve">
          <source>Functions can declare an argument to be an anonymous type parameter where the callee must provide a type that has the bounds declared by the anonymous type parameter and the function can only use the methods available by the trait bounds of the anonymous type parameter.</source>
          <target state="translated">함수는 인수가 익명 형식 매개 변수로 선언 할 수 있으며 여기서 수신자는 익명 형식 매개 변수에 의해 선언 된 범위를 가진 형식을 제공해야하며 익명 형식 매개 변수의 특성 범위에서만 사용할 수있는 메서드 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e06e07a734b3acc49e3963f1c74ffeae667ea5a" translate="yes" xml:space="preserve">
          <source>Functions can return values to the code that calls them. We don&amp;rsquo;t name return values, but we do declare their type after an arrow (&lt;code&gt;-&amp;gt;&lt;/code&gt;). In Rust, the return value of the function is synonymous with the value of the final expression in the block of the body of a function. You can return early from a function by using the &lt;code&gt;return&lt;/code&gt; keyword and specifying a value, but most functions return the last expression implicitly. Here&amp;rsquo;s an example of a function that returns a value:</source>
          <target state="translated">함수는이를 호출하는 코드에 값을 반환 할 수 있습니다. 반환 값의 이름은 지정하지 않지만 화살표 ( &lt;code&gt;-&amp;gt;&lt;/code&gt; ) 뒤에 유형을 선언합니다 . Rust에서 함수의 반환 값은 함수 본문 블록의 최종 표현식 값과 동의어입니다. &lt;code&gt;return&lt;/code&gt; 키워드 를 사용하고 값을 지정 하여 함수에서 일찍 반환 할 수 있지만 대부분의 함수는 마지막 식을 암시 적으로 반환합니다. 다음은 값을 반환하는 함수의 예입니다.</target>
        </trans-unit>
        <trans-unit id="8578e1edc63515b51db6bed787869c23c34bb35c" translate="yes" xml:space="preserve">
          <source>Functions do not capture local variables. To fix this error, you can replace the function with a closure:</source>
          <target state="translated">함수는 지역 변수를 캡처하지 않습니다. 이 오류를 해결하기 위해 함수를 클로저로 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c048b3feb011016ec1af315c1f0d26b938c26a99" translate="yes" xml:space="preserve">
          <source>Functions in this module will block the current &lt;strong&gt;thread&lt;/strong&gt; of execution and are bindings to system-provided condition variables where possible. Note that this module places one additional restriction over the system condition variables: each condvar can be used with precisely one mutex at runtime. Any attempt to use multiple mutexes on the same condition variable will result in a runtime panic. If this is not desired, then the unsafe primitives in &lt;code&gt;sys&lt;/code&gt; do not have this restriction but may result in undefined behavior.</source>
          <target state="translated">이 모듈의 함수는 현재 실행 &lt;strong&gt;스레드&lt;/strong&gt; 를 차단하고 가능한 경우 시스템 제공 조건 변수에 바인딩합니다. 이 모듈은 시스템 조건 변수에 대해 하나의 추가 제한 사항을 적용합니다. 각 condvar는 런타임시 정확히 하나의 뮤텍스와 함께 사용할 수 있습니다. 동일한 조건 변수에서 여러 뮤텍스를 사용하려고하면 런타임 패닉이 발생합니다. 이것이 바람직하지 않은 경우, &lt;code&gt;sys&lt;/code&gt; 의 안전하지 않은 프리미티브 에는이 제한이 없지만 정의되지 않은 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a797a5b3b54d57d908332f50a0ff14a598f923ef" translate="yes" xml:space="preserve">
          <source>Functions marked with &lt;code&gt;target_feature&lt;/code&gt; are not inlined into a context that does not support the given features. The &lt;code&gt;#[inline(always)]&lt;/code&gt; attribute may not be used with a &lt;code&gt;target_feature&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;target_feature&lt;/code&gt; 로 표시된 함수 는 지정된 기능을 지원하지 않는 컨텍스트에 인라인되지 않습니다. &lt;code&gt;#[inline(always)]&lt;/code&gt; 속성은 함께 사용할 수 없다 &lt;code&gt;target_feature&lt;/code&gt; 의 속성.</target>
        </trans-unit>
        <trans-unit id="debf8c3aa1da35922894a71fde41ce5baca3e6ad" translate="yes" xml:space="preserve">
          <source>Functions qualified with the &lt;code&gt;const&lt;/code&gt; keyword are const functions. &lt;em&gt;Const functions&lt;/em&gt; can be called from within &lt;a href=&quot;../const_eval#const-context&quot;&gt;const context&lt;/a&gt;s. When called from a const context, the function is interpreted by the compiler at compile time. The interpretation happens in the environment of the compilation target and not the host. So &lt;code&gt;usize&lt;/code&gt; is &lt;code&gt;32&lt;/code&gt; bits if you are compiling against a &lt;code&gt;32&lt;/code&gt; bit system, irrelevant of whether you are building on a &lt;code&gt;64&lt;/code&gt; bit or a &lt;code&gt;32&lt;/code&gt; bit system.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 키워드로 한정된 함수는 const 함수입니다. &lt;a href=&quot;../const_eval#const-context&quot;&gt;const 컨텍스트&lt;/a&gt; 내에서 const &lt;em&gt;함수&lt;/em&gt; 를 호출 할 수 있습니다 . const 컨텍스트에서 호출되면 함수는 컴파일 타임에 컴파일러에 의해 해석됩니다. 해석은 호스트가 아닌 컴파일 대상 환경에서 발생합니다. 따라서 &lt;code&gt;64&lt;/code&gt; 비트 또는 &lt;code&gt;32&lt;/code&gt; 비트 시스템 에서 빌드하는지 여부와 상관없이 &lt;code&gt;32&lt;/code&gt; 비트 시스템 에 대해 컴파일하는 경우 &lt;code&gt;usize&lt;/code&gt; 는 &lt;code&gt;32&lt;/code&gt; 비트 입니다.</target>
        </trans-unit>
        <trans-unit id="27716c2844ef6662e00babc6885a69e2dec63380" translate="yes" xml:space="preserve">
          <source>Functions return &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; whenever errors are expected and recoverable. In the &lt;code&gt;std&lt;/code&gt; crate, &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; is most prominently used for &lt;a href=&quot;../io/index&quot;&gt;I/O&lt;/a&gt;.</source>
          <target state="translated">오류가 예상되고 복구 가능할 때마다 함수가 &lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 반환 합니다. 에서 &lt;code&gt;std&lt;/code&gt; 상자, &lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 가장 눈에 띄게 사용되는 &lt;a href=&quot;../io/index&quot;&gt;I / O&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ba4110fcc3e4c930df9cd4a44d4369d4a726954" translate="yes" xml:space="preserve">
          <source>Functions which take an &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; and return another &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; are often called 'iterator adapters', as they're a form of the 'adapter pattern'.</source>
          <target state="translated">&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 를 가져와 다른 &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; 를&lt;/a&gt; 반환 하는 함수 는 '어댑터 패턴'의 형식이므로 종종 '반복자 어댑터'라고합니다.</target>
        </trans-unit>
        <trans-unit id="e3428425ba667eae06c3ff2021c3de7d88b772af" translate="yes" xml:space="preserve">
          <source>Functions with Return Values</source>
          <target state="translated">반환 값이있는 함수</target>
        </trans-unit>
        <trans-unit id="92807c856bd111462699f9e06c09bb56c14702fe" translate="yes" xml:space="preserve">
          <source>Functions within external blocks are declared in the same way as other Rust functions, with the exception that they may not have a body and are instead terminated by a semicolon. Patterns are not allowed in parameters, only &lt;a href=&quot;../identifiers&quot;&gt;IDENTIFIER&lt;/a&gt; or &lt;code&gt;_&lt;/code&gt; may be used.</source>
          <target state="translated">외부 블록 내의 함수는 다른 Rust 함수와 동일한 방식으로 선언됩니다. 단, 본문이 없을 수 있고 세미콜론으로 종료됩니다. 매개 변수에는 패턴을 사용할 수 없으며 &lt;a href=&quot;../identifiers&quot;&gt;IDENTIFIER&lt;/a&gt; 또는 &lt;code&gt;_&lt;/code&gt; 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc77dcb074f08a32cc87de1996bea238f078997a" translate="yes" xml:space="preserve">
          <source>Functions within external blocks may be called by Rust code, just like functions defined in Rust. The Rust compiler automatically translates between the Rust ABI and the foreign ABI.</source>
          <target state="translated">외부 블록 내의 함수는 Rust에 정의 된 함수와 마찬가지로 Rust 코드에 의해 호출 될 수 있습니다. Rust 컴파일러는 Rust ABI와 외부 ABI 사이를 자동으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="255f924e1ffd5da6e3f850e0ae72ac4d9101aff6" translate="yes" xml:space="preserve">
          <source>Functions within external blocks may be variadic by specifying &lt;code&gt;...&lt;/code&gt; after one or more named arguments in the argument list:</source>
          <target state="translated">인수 목록에서 하나 이상의 명명 된 인수 뒤에 &lt;code&gt;...&lt;/code&gt; 를 지정하여 외부 블록 내의 함수는 가변적 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="559bba4281b9cbb5285ad035b18e638f9254aa96" translate="yes" xml:space="preserve">
          <source>Functions, except for associated trait functions, can return an abstract return type. These types stand in for another concrete type where the use-site may only use the trait methods declared by the trait bounds of the type.</source>
          <target state="translated">연관된 특성 함수를 제외한 함수는 추상 리턴 유형을 리턴 할 수 있습니다. 이러한 유형은 사용 사이트가 유형의 특성 경계에 의해 선언 된 특성 메소드 만 사용할 수있는 또 다른 구체적인 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5234ca15ccfb340b3c32fd38f23a4ff8df3cca57" translate="yes" xml:space="preserve">
          <source>Functions, type aliases, structs, enumerations, unions, traits and implementations may be &lt;em&gt;parameterized&lt;/em&gt; by types and lifetimes. These parameters are listed in angle brackets (&lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt;), usually immediately after the name of the item and before its definition. For implementations, which don't have a name, they come directly after &lt;code&gt;impl&lt;/code&gt;. Lifetime parameters must be declared before type parameters. Some examples of items with type and lifetime parameters:</source>
          <target state="translated">함수, 타입 별칭, 구조체, 열거 형, 공용체, 특성 및 구현은 타입과 수명에 의해 &lt;em&gt;파라미터 화&lt;/em&gt; 될 수 있습니다 . 이러한 매개 변수는 일반적으로 항목 이름 바로 뒤에 정의하기 전에 꺾쇠 괄호 ( &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; )로 표시됩니다. 이름이없는 구현의 경우, &lt;code&gt;impl&lt;/code&gt; 바로 뒤에옵니다 . 수명 매개 변수는 유형 매개 변수보다 먼저 선언해야합니다. 유형 및 수명 매개 변수가있는 항목의 일부 예 :</target>
        </trans-unit>
        <trans-unit id="bc0f9166454ea8a2d6c4817bb65ab3b4f20a8394" translate="yes" xml:space="preserve">
          <source>Fundamentally, macros are a way of writing code that writes other code, which is known as &lt;em&gt;metaprogramming&lt;/em&gt;. In Appendix C, we discuss the &lt;code&gt;derive&lt;/code&gt; attribute, which generates an implementation of various traits for you. We&amp;rsquo;ve also used the &lt;code&gt;println!&lt;/code&gt; and &lt;code&gt;vec!&lt;/code&gt; macros throughout the book. All of these macros &lt;em&gt;expand&lt;/em&gt; to produce more code than the code you&amp;rsquo;ve written manually.</source>
          <target state="translated">기본적으로 매크로는 &lt;em&gt;metaprogramming&lt;/em&gt; 이라고하는 다른 코드를 작성하는 코드를 작성하는 방법입니다 . 부록 C에서는 다양한 특성의 구현을 생성하는 &lt;code&gt;derive&lt;/code&gt; 속성에 대해 설명합니다. 우리는 또한 &lt;code&gt;println!&lt;/code&gt; 사용했습니다 ! 그리고 &lt;code&gt;vec!&lt;/code&gt; 책 전체에서 매크로. 이 매크로는 모두 수동으로 작성한 코드보다 더 많은 코드를 생성하도록 &lt;em&gt;확장&lt;/em&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="33aa27b63995ba1fcb3ce7d14470a2ebda4e9afb" translate="yes" xml:space="preserve">
          <source>Further examples</source>
          <target state="translated">추가 예</target>
        </trans-unit>
        <trans-unit id="d09598b8462cb55fafc0925eb6b3707aebcdffff" translate="yes" xml:space="preserve">
          <source>Further methods that return iterators are &lt;a href=&quot;../primitive.slice#method.split&quot;&gt;&lt;code&gt;.split&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../primitive.slice#method.splitn&quot;&gt;&lt;code&gt;.splitn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../primitive.slice#method.chunks&quot;&gt;&lt;code&gt;.chunks&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../primitive.slice#method.windows&quot;&gt;&lt;code&gt;.windows&lt;/code&gt;&lt;/a&gt; and more.</source>
          <target state="translated">반복자를 반환하는 추가 메서드는 &lt;a href=&quot;../primitive.slice#method.split&quot;&gt; &lt;code&gt;.split&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../primitive.slice#method.splitn&quot;&gt; &lt;code&gt;.splitn&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../primitive.slice#method.chunks&quot;&gt; &lt;code&gt;.chunks&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../primitive.slice#method.windows&quot;&gt; &lt;code&gt;.windows&lt;/code&gt; &lt;/a&gt; 등입니다.</target>
        </trans-unit>
        <trans-unit id="1ca30366a5d0ab34525f2208365c1ca94a1f8b77" translate="yes" xml:space="preserve">
          <source>Further, when providing implementations for additional traits, it needs to be considered whether they should behave identical to those of the underlying type as a consequence of acting as a representation of that underlying type. Generic code typically uses &lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt; when it relies on the identical behavior of these additional trait implementations. These traits will likely appear as additional trait bounds.</source>
          <target state="translated">또한, 추가 특성에 대한 구현을 제공 할 때 해당 기본 유형의 표현으로 작동 한 결과 기본 유형과 동일하게 작동해야하는지 여부를 고려해야합니다. 일반 코드는 일반적으로 이러한 추가 특성 구현의 동일한 동작에 의존 할 때 &lt;code&gt;Borrow&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용합니다. 이러한 특성은 추가 특성 범위로 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb1960550ff747636004d7c48533ff64eb2c7cb0" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;code&gt;usize&lt;/code&gt; and &lt;code&gt;isize&lt;/code&gt; have the same size.</source>
          <target state="translated">또한 &lt;code&gt;usize&lt;/code&gt; 와 &lt;code&gt;isize&lt;/code&gt; 의 크기는 같습니다.</target>
        </trans-unit>
        <trans-unit id="cdc25e51f3bd03cefd6c886e6015dd4e5ab94438" translate="yes" xml:space="preserve">
          <source>Fuse</source>
          <target state="translated">Fuse</target>
        </trans-unit>
        <trans-unit id="5b5bb3bd654173bbe0ca32ea3cdd799fc39be7e0" translate="yes" xml:space="preserve">
          <source>Fuse::all</source>
          <target state="translated">Fuse::all</target>
        </trans-unit>
        <trans-unit id="be234633fcc19983cf10e500a6cea263759de0ec" translate="yes" xml:space="preserve">
          <source>Fuse::any</source>
          <target state="translated">Fuse::any</target>
        </trans-unit>
        <trans-unit id="fb657f6faeb38bdc2196ebc9819c5d95fe340748" translate="yes" xml:space="preserve">
          <source>Fuse::borrow</source>
          <target state="translated">Fuse::borrow</target>
        </trans-unit>
        <trans-unit id="8f3044155e9d5c84cd57e23debc6442d0e4670b3" translate="yes" xml:space="preserve">
          <source>Fuse::borrow_mut</source>
          <target state="translated">Fuse::borrow_mut</target>
        </trans-unit>
        <trans-unit id="1d289dac98b2c0ee8af0ae119550bb75a8647436" translate="yes" xml:space="preserve">
          <source>Fuse::by_ref</source>
          <target state="translated">Fuse::by_ref</target>
        </trans-unit>
        <trans-unit id="831eb7c4481fb4be2c2082f7b1da24d8f9f757ec" translate="yes" xml:space="preserve">
          <source>Fuse::chain</source>
          <target state="translated">Fuse::chain</target>
        </trans-unit>
        <trans-unit id="438fd4561c9ccfadcfc75a150d349251bb6bad15" translate="yes" xml:space="preserve">
          <source>Fuse::clone</source>
          <target state="translated">Fuse::clone</target>
        </trans-unit>
        <trans-unit id="1430674975c3f47c8efafda98d99fb2a28139d1d" translate="yes" xml:space="preserve">
          <source>Fuse::clone_from</source>
          <target state="translated">Fuse::clone_from</target>
        </trans-unit>
        <trans-unit id="9be81b457f16a4af2ac97486a4694037294d9f73" translate="yes" xml:space="preserve">
          <source>Fuse::clone_into</source>
          <target state="translated">Fuse::clone_into</target>
        </trans-unit>
        <trans-unit id="98f760afb80a8eff0c0ef367859e40f090d49189" translate="yes" xml:space="preserve">
          <source>Fuse::cloned</source>
          <target state="translated">Fuse::cloned</target>
        </trans-unit>
        <trans-unit id="6da9651643728cd0c44496dee9b4303124cabbfa" translate="yes" xml:space="preserve">
          <source>Fuse::cmp</source>
          <target state="translated">Fuse::cmp</target>
        </trans-unit>
        <trans-unit id="0c4f37e97803f9d70993fa59d61809aea7d9011a" translate="yes" xml:space="preserve">
          <source>Fuse::collect</source>
          <target state="translated">Fuse::collect</target>
        </trans-unit>
        <trans-unit id="ddc6005989b65675ac3ce7404f4341aa3e45bd46" translate="yes" xml:space="preserve">
          <source>Fuse::copied</source>
          <target state="translated">Fuse::copied</target>
        </trans-unit>
        <trans-unit id="6086889f4261af2a35bbde15545aa2b38e286eb0" translate="yes" xml:space="preserve">
          <source>Fuse::count</source>
          <target state="translated">Fuse::count</target>
        </trans-unit>
        <trans-unit id="2c7439b70ce0f07bef285135b6810c8416ce3ceb" translate="yes" xml:space="preserve">
          <source>Fuse::cycle</source>
          <target state="translated">Fuse::cycle</target>
        </trans-unit>
        <trans-unit id="1d21878382d8db3eef5c3ccb0162b537561d5fe1" translate="yes" xml:space="preserve">
          <source>Fuse::enumerate</source>
          <target state="translated">Fuse::enumerate</target>
        </trans-unit>
        <trans-unit id="823d811ae87865a3afe81991f5b1ce5c5d3e05fb" translate="yes" xml:space="preserve">
          <source>Fuse::eq</source>
          <target state="translated">Fuse::eq</target>
        </trans-unit>
        <trans-unit id="bd7cbe6bf9c8e8d0dbf1a520e5d8f393c41d5e76" translate="yes" xml:space="preserve">
          <source>Fuse::filter</source>
          <target state="translated">Fuse::filter</target>
        </trans-unit>
        <trans-unit id="ff249feec5a8ff44c09ac4d58cf0c46bc03c2e27" translate="yes" xml:space="preserve">
          <source>Fuse::filter_map</source>
          <target state="translated">Fuse::filter_map</target>
        </trans-unit>
        <trans-unit id="d65f3a653005a9aca1a47f1daa9574aadcf81146" translate="yes" xml:space="preserve">
          <source>Fuse::find</source>
          <target state="translated">Fuse::find</target>
        </trans-unit>
        <trans-unit id="92189ce0a3d924bfcfe5daafee0096f97e345e8a" translate="yes" xml:space="preserve">
          <source>Fuse::find_map</source>
          <target state="translated">Fuse::find_map</target>
        </trans-unit>
        <trans-unit id="1cf8f29dde6618a7c7a45ae0ed611ea18dc6d814" translate="yes" xml:space="preserve">
          <source>Fuse::flat_map</source>
          <target state="translated">Fuse::flat_map</target>
        </trans-unit>
        <trans-unit id="9f855deea4a227b1c412204b1b500286ca9898ff" translate="yes" xml:space="preserve">
          <source>Fuse::flatten</source>
          <target state="translated">Fuse::flatten</target>
        </trans-unit>
        <trans-unit id="27bca4d23d19f854df553c1f82824f7edd33ecdd" translate="yes" xml:space="preserve">
          <source>Fuse::fmt</source>
          <target state="translated">Fuse::fmt</target>
        </trans-unit>
        <trans-unit id="8293be1030013adbfbddb7413ab47a9d5713fbb2" translate="yes" xml:space="preserve">
          <source>Fuse::fold</source>
          <target state="translated">Fuse::fold</target>
        </trans-unit>
        <trans-unit id="d70e6b78ab1bfb6ecef7e95f085adfaeb6422f4a" translate="yes" xml:space="preserve">
          <source>Fuse::for_each</source>
          <target state="translated">Fuse::for_each</target>
        </trans-unit>
        <trans-unit id="c637a607309c42c80a08d11fa1900890151225d1" translate="yes" xml:space="preserve">
          <source>Fuse::from</source>
          <target state="translated">Fuse::from</target>
        </trans-unit>
        <trans-unit id="3f4b35dca4545ef8a3669e274f565d795f26df61" translate="yes" xml:space="preserve">
          <source>Fuse::fuse</source>
          <target state="translated">Fuse::fuse</target>
        </trans-unit>
        <trans-unit id="d32ae472a05f042237f60672a294af6e0f780002" translate="yes" xml:space="preserve">
          <source>Fuse::ge</source>
          <target state="translated">Fuse::ge</target>
        </trans-unit>
        <trans-unit id="db14a349561c9657cb02ec4378f0041d394de512" translate="yes" xml:space="preserve">
          <source>Fuse::gt</source>
          <target state="translated">Fuse::gt</target>
        </trans-unit>
        <trans-unit id="8e137668bb3688ae855ccc5853810b47754a3872" translate="yes" xml:space="preserve">
          <source>Fuse::inspect</source>
          <target state="translated">Fuse::inspect</target>
        </trans-unit>
        <trans-unit id="5cfef3b06c43a18ed973402f005ed7cd09e8c04c" translate="yes" xml:space="preserve">
          <source>Fuse::into</source>
          <target state="translated">Fuse::into</target>
        </trans-unit>
        <trans-unit id="f0ca9438fb188b5b8dad26c6bf148f9659520041" translate="yes" xml:space="preserve">
          <source>Fuse::into_iter</source>
          <target state="translated">Fuse::into_iter</target>
        </trans-unit>
        <trans-unit id="391ea300511ad72ed0c52d931ec32f9ad0fd9c6f" translate="yes" xml:space="preserve">
          <source>Fuse::is_empty</source>
          <target state="translated">Fuse::is_empty</target>
        </trans-unit>
        <trans-unit id="dbc1aa11443b40a7ec81e5ce0dd280ae99df5395" translate="yes" xml:space="preserve">
          <source>Fuse::is_sorted</source>
          <target state="translated">Fuse::is_sorted</target>
        </trans-unit>
        <trans-unit id="6de34202c0045be112d2ee0f948bb537aa9be637" translate="yes" xml:space="preserve">
          <source>Fuse::is_sorted_by</source>
          <target state="translated">Fuse::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="6e5a92b697e11f4f97be1cb92bf8a2c8203571cd" translate="yes" xml:space="preserve">
          <source>Fuse::is_sorted_by_key</source>
          <target state="translated">Fuse::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="c01cf3c78cdbb7fdd9e68eeecd85fe4f5fc5bcc7" translate="yes" xml:space="preserve">
          <source>Fuse::last</source>
          <target state="translated">Fuse::last</target>
        </trans-unit>
        <trans-unit id="fca9c9805a04224315e282c3be9b6a888b5ed9a1" translate="yes" xml:space="preserve">
          <source>Fuse::le</source>
          <target state="translated">Fuse::le</target>
        </trans-unit>
        <trans-unit id="53bec7ede087d7f3b55b0287278a68b38404a6d6" translate="yes" xml:space="preserve">
          <source>Fuse::len</source>
          <target state="translated">Fuse::len</target>
        </trans-unit>
        <trans-unit id="7b4183ba0f386cd9443aa4992eba62aa3b6deb95" translate="yes" xml:space="preserve">
          <source>Fuse::lt</source>
          <target state="translated">Fuse::lt</target>
        </trans-unit>
        <trans-unit id="5c262325339cd3156152addc6dd873caf49ad2b7" translate="yes" xml:space="preserve">
          <source>Fuse::map</source>
          <target state="translated">Fuse::map</target>
        </trans-unit>
        <trans-unit id="f34722d429c594a066614633112c87b369af6d10" translate="yes" xml:space="preserve">
          <source>Fuse::max</source>
          <target state="translated">Fuse::max</target>
        </trans-unit>
        <trans-unit id="74cd81b2b264540f6cf86176ce650c3ace7df66c" translate="yes" xml:space="preserve">
          <source>Fuse::max_by</source>
          <target state="translated">Fuse::max_by</target>
        </trans-unit>
        <trans-unit id="6363e416dfff32dea4b85f002985261e301ff120" translate="yes" xml:space="preserve">
          <source>Fuse::max_by_key</source>
          <target state="translated">Fuse::max_by_key</target>
        </trans-unit>
        <trans-unit id="ea71fbd8ca048cb3a4327bc3c665fd836b260d15" translate="yes" xml:space="preserve">
          <source>Fuse::min</source>
          <target state="translated">Fuse::min</target>
        </trans-unit>
        <trans-unit id="3e45b43694c4d735e3284df51fc1d5afa72689a1" translate="yes" xml:space="preserve">
          <source>Fuse::min_by</source>
          <target state="translated">Fuse::min_by</target>
        </trans-unit>
        <trans-unit id="460a4dae2436a52e10ab6fe47215192d0d2cc26c" translate="yes" xml:space="preserve">
          <source>Fuse::min_by_key</source>
          <target state="translated">Fuse::min_by_key</target>
        </trans-unit>
        <trans-unit id="fdbe92dea6e61847df85f41bba1c90d74049ae28" translate="yes" xml:space="preserve">
          <source>Fuse::ne</source>
          <target state="translated">Fuse::ne</target>
        </trans-unit>
        <trans-unit id="5230c2613200a1d46de34a7083facac940e009ab" translate="yes" xml:space="preserve">
          <source>Fuse::next</source>
          <target state="translated">Fuse::next</target>
        </trans-unit>
        <trans-unit id="51b95d33641283d83b2d3ca707d3b05b32955f7c" translate="yes" xml:space="preserve">
          <source>Fuse::next_back</source>
          <target state="translated">Fuse::next_back</target>
        </trans-unit>
        <trans-unit id="732184abb4e4b26b7896c98d0f1f6fb79face59a" translate="yes" xml:space="preserve">
          <source>Fuse::nth</source>
          <target state="translated">Fuse::nth</target>
        </trans-unit>
        <trans-unit id="ecf2d99b326b90bba4e5e94a2cfcb8fca5d36bf8" translate="yes" xml:space="preserve">
          <source>Fuse::nth_back</source>
          <target state="translated">Fuse::nth_back</target>
        </trans-unit>
        <trans-unit id="645b953e826c63fc9e513fa454ed5315f66f63e7" translate="yes" xml:space="preserve">
          <source>Fuse::partial_cmp</source>
          <target state="translated">Fuse::partial_cmp</target>
        </trans-unit>
        <trans-unit id="909f5215d0717af781bec722f3b0dd010a16016b" translate="yes" xml:space="preserve">
          <source>Fuse::partition</source>
          <target state="translated">Fuse::partition</target>
        </trans-unit>
        <trans-unit id="01e3171662432979d4756fdb5c7d60d5e3d3688a" translate="yes" xml:space="preserve">
          <source>Fuse::peekable</source>
          <target state="translated">Fuse::peekable</target>
        </trans-unit>
        <trans-unit id="6b80140311ab3ce2aaec8ebfd30dcf2e8f274077" translate="yes" xml:space="preserve">
          <source>Fuse::position</source>
          <target state="translated">Fuse::position</target>
        </trans-unit>
        <trans-unit id="cdf77414329bacb067e1a8328f80ce08984f20c6" translate="yes" xml:space="preserve">
          <source>Fuse::product</source>
          <target state="translated">Fuse::product</target>
        </trans-unit>
        <trans-unit id="8ef76fc13b788c76e379230ed857338ce665522c" translate="yes" xml:space="preserve">
          <source>Fuse::rev</source>
          <target state="translated">Fuse::rev</target>
        </trans-unit>
        <trans-unit id="c6ceda460157839498baef5d44fcbf90dfa55a4d" translate="yes" xml:space="preserve">
          <source>Fuse::rfind</source>
          <target state="translated">Fuse::rfind</target>
        </trans-unit>
        <trans-unit id="d330c64599fdb09d15b95c557b4d7892f68af3e1" translate="yes" xml:space="preserve">
          <source>Fuse::rfold</source>
          <target state="translated">Fuse::rfold</target>
        </trans-unit>
        <trans-unit id="4b3396affd9754021af0b44df2dd12d80df33ae6" translate="yes" xml:space="preserve">
          <source>Fuse::rposition</source>
          <target state="translated">Fuse::rposition</target>
        </trans-unit>
        <trans-unit id="ab43bd0b883653041efa0ea7cc154b6bf9af47c1" translate="yes" xml:space="preserve">
          <source>Fuse::scan</source>
          <target state="translated">Fuse::scan</target>
        </trans-unit>
        <trans-unit id="1b8b4c672f99a52b32d55c7bb8972a6f72ece7cf" translate="yes" xml:space="preserve">
          <source>Fuse::size_hint</source>
          <target state="translated">Fuse::size_hint</target>
        </trans-unit>
        <trans-unit id="d347c87cd849d9a01c9a979b0311dbcf96965bae" translate="yes" xml:space="preserve">
          <source>Fuse::skip</source>
          <target state="translated">Fuse::skip</target>
        </trans-unit>
        <trans-unit id="ecd51b0feeb4bb83cc2ee12bb364791884b19e9f" translate="yes" xml:space="preserve">
          <source>Fuse::skip_while</source>
          <target state="translated">Fuse::skip_while</target>
        </trans-unit>
        <trans-unit id="31f474af09ad27dc8cad30dd87438f396efab185" translate="yes" xml:space="preserve">
          <source>Fuse::step_by</source>
          <target state="translated">Fuse::step_by</target>
        </trans-unit>
        <trans-unit id="a8a56103bdd56576e7451868c2de237a02390598" translate="yes" xml:space="preserve">
          <source>Fuse::sum</source>
          <target state="translated">Fuse::sum</target>
        </trans-unit>
        <trans-unit id="29656f53c0fe5965acddeba06fd4f327a57a6b22" translate="yes" xml:space="preserve">
          <source>Fuse::take</source>
          <target state="translated">Fuse::take</target>
        </trans-unit>
        <trans-unit id="70ed5974147d5d5c47345358f79e9fe42830a0e2" translate="yes" xml:space="preserve">
          <source>Fuse::take_while</source>
          <target state="translated">Fuse::take_while</target>
        </trans-unit>
        <trans-unit id="c61f9148a2472fccbc543adcedcaef00ebc36916" translate="yes" xml:space="preserve">
          <source>Fuse::to_owned</source>
          <target state="translated">Fuse::to_owned</target>
        </trans-unit>
        <trans-unit id="9b8e9e88c43c584957c03c4a9790125c18a326dc" translate="yes" xml:space="preserve">
          <source>Fuse::try_fold</source>
          <target state="translated">Fuse::try_fold</target>
        </trans-unit>
        <trans-unit id="019976673022e8a2538f04e41619085b0509b968" translate="yes" xml:space="preserve">
          <source>Fuse::try_for_each</source>
          <target state="translated">Fuse::try_for_each</target>
        </trans-unit>
        <trans-unit id="fe419dd037d95472b807e093d3ea02ccb57032fd" translate="yes" xml:space="preserve">
          <source>Fuse::try_from</source>
          <target state="translated">Fuse::try_from</target>
        </trans-unit>
        <trans-unit id="f05020a71bfc101fbe84356da0aa7b927615342b" translate="yes" xml:space="preserve">
          <source>Fuse::try_into</source>
          <target state="translated">Fuse::try_into</target>
        </trans-unit>
        <trans-unit id="c841af43e247c2928b1064e08f72070c26de3b92" translate="yes" xml:space="preserve">
          <source>Fuse::try_rfold</source>
          <target state="translated">Fuse::try_rfold</target>
        </trans-unit>
        <trans-unit id="5d8927e5ec76098e5f2f5c0d2886eb49af8b8071" translate="yes" xml:space="preserve">
          <source>Fuse::type_id</source>
          <target state="translated">Fuse::type_id</target>
        </trans-unit>
        <trans-unit id="11c88abe9b80924ead19e08c32a0e7d6ff055afa" translate="yes" xml:space="preserve">
          <source>Fuse::unzip</source>
          <target state="translated">Fuse::unzip</target>
        </trans-unit>
        <trans-unit id="6e1886d4b16f1cab13382140a5a4f1a5275134bc" translate="yes" xml:space="preserve">
          <source>Fuse::zip</source>
          <target state="translated">Fuse::zip</target>
        </trans-unit>
        <trans-unit id="9c86bce2cc6fe0fed1d906293dbdc3155ee68bd1" translate="yes" xml:space="preserve">
          <source>Fused multiply-add. Computes &lt;code&gt;(self * a) + b&lt;/code&gt; with only one rounding error, yielding a more accurate result than an unfused multiply-add.</source>
          <target state="translated">융합 곱셈 추가. 계산해 &lt;code&gt;(self * a) + b&lt;/code&gt; 하나의 에러 라운딩 융착 곱셈 - 덧셈보다 정확한 결과를 산출와.</target>
        </trans-unit>
        <trans-unit id="b5bb5c0c622a64179c02df6d378fd9fe00019e5d" translate="yes" xml:space="preserve">
          <source>FusedIterator</source>
          <target state="translated">FusedIterator</target>
        </trans-unit>
        <trans-unit id="047ca54032a1756c098d3bc1a941a0ed8e583df8" translate="yes" xml:space="preserve">
          <source>Future</source>
          <target state="translated">Future</target>
        </trans-unit>
        <trans-unit id="34f9f68cc95c47f600ff51f98b51efdc1e4973b7" translate="yes" xml:space="preserve">
          <source>Future compatibility</source>
          <target state="translated">향후 호환성</target>
        </trans-unit>
        <trans-unit id="fe870fd01f0abd72a18fbaf5c5cbed77f351525a" translate="yes" xml:space="preserve">
          <source>Future::poll</source>
          <target state="translated">Future::poll</target>
        </trans-unit>
        <trans-unit id="5404be636a9f63c6aa8f665b2d42ad260f8e8dfb" translate="yes" xml:space="preserve">
          <source>Futures alone are &lt;em&gt;inert&lt;/em&gt;; they must be &lt;em&gt;actively&lt;/em&gt;&lt;code&gt;poll&lt;/code&gt;ed to make progress, meaning that each time the current task is woken up, it should actively re-&lt;code&gt;poll&lt;/code&gt; pending futures that it still has an interest in.</source>
          <target state="translated">선물만으로는 &lt;em&gt;불활성이다&lt;/em&gt; . 그들이해야 &lt;em&gt;적극적으로 &lt;/em&gt; &lt;code&gt;poll&lt;/code&gt; 때마다이 현재 작업이 깨어 것을 의미 메이크업의 발전에 에드, 적극적 다시해야 &lt;code&gt;poll&lt;/code&gt; 가 여전히 관심을 가지고 미래를 보류.</target>
        </trans-unit>
        <trans-unit id="170618a3c56100e7f9817b28534dee7fda36bd36" translate="yes" xml:space="preserve">
          <source>GNU C library Bugzilla</source>
          <target state="translated">GNU C 라이브러리 Bugzilla</target>
        </trans-unit>
        <trans-unit id="ae44bdb1ff1d7f62acdd7de8bfa0f16c08c76789" translate="yes" xml:space="preserve">
          <source>Gain a reference to the underlying &lt;code&gt;stat&lt;/code&gt; structure which contains the raw information returned by the OS.</source>
          <target state="translated">OS가 반환 한 원시 정보를 포함 하는 기본 &lt;code&gt;stat&lt;/code&gt; 구조에 대한 참조를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="28e18309d45539def481f7786d4cc8d73b9f5aec" translate="yes" xml:space="preserve">
          <source>Gain a reference to the underlying &lt;code&gt;stat&lt;/code&gt; structure which contains the raw information returned by the OS. &lt;a href=&quot;../os/linux/fs/trait.metadataext#tymethod.as_raw_stat&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">OS가 반환 한 원시 정보를 포함 하는 기본 &lt;code&gt;stat&lt;/code&gt; 구조에 대한 참조를 얻습니다 . &lt;a href=&quot;../os/linux/fs/trait.metadataext#tymethod.as_raw_stat&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5023fde21a93efcc45f3ef1278a03020db274d7f" translate="yes" xml:space="preserve">
          <source>Ge</source>
          <target state="translated">Ge</target>
        </trans-unit>
        <trans-unit id="826e54d9f3341da0639215d591e03f7d7c85bcf1" translate="yes" xml:space="preserve">
          <source>Generalizing the latter case, any type implementing &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt; can't be &lt;code&gt;Copy&lt;/code&gt;, because it's managing some resource besides its own &lt;a href=&quot;../mem/fn.size_of&quot;&gt;&lt;code&gt;size_of::&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; bytes.</source>
          <target state="translated">후자의 경우를 일반화하면 &lt;a href=&quot;../ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt; 을 구현하는 모든 유형 은 자체 &lt;a href=&quot;../mem/fn.size_of&quot;&gt; &lt;code&gt;size_of::&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 바이트 이외의 일부 리소스를 관리하기 때문에 &lt;code&gt;Copy&lt;/code&gt; 일 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b3f505d3f65e19757f523841da2ceb51bc20ba3c" translate="yes" xml:space="preserve">
          <source>Generally speaking, if your type &lt;em&gt;can&lt;/em&gt; implement &lt;code&gt;Copy&lt;/code&gt;, it should. Keep in mind, though, that implementing &lt;code&gt;Copy&lt;/code&gt; is part of the public API of your type. If the type might become non-&lt;code&gt;Copy&lt;/code&gt; in the future, it could be prudent to omit the &lt;code&gt;Copy&lt;/code&gt; implementation now, to avoid a breaking API change.</source>
          <target state="translated">일반적으로 타입 &lt;em&gt;이 &lt;/em&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;em&gt;를&lt;/em&gt; 구현할 &lt;em&gt;수&lt;/em&gt; 있다면 , 그렇게해야합니다. 그러나 &lt;code&gt;Copy&lt;/code&gt; 구현 은 사용자 유형의 공용 API의 일부입니다. 향후에 유형이 &lt;code&gt;Copy&lt;/code&gt; 가 아닌 경우 API 변경을 피하기 위해 지금 &lt;code&gt;Copy&lt;/code&gt; 구현 을 생략하는 것이 현명 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f413a99b90fcebaf815708bcac6bf2c609712621" translate="yes" xml:space="preserve">
          <source>Generally speaking, when using &lt;code&gt;OpenOptions&lt;/code&gt;, you'll first call &lt;a href=&quot;struct.openoptions#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt;, then chain calls to methods to set each option, then call &lt;a href=&quot;struct.openoptions#method.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt;, passing the path of the file you're trying to open. This will give you a &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt; with a &lt;a href=&quot;struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; inside that you can further operate on.</source>
          <target state="translated">일반적으로 &lt;code&gt;OpenOptions&lt;/code&gt; 를 사용할 때는 먼저 &lt;a href=&quot;struct.openoptions#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 를 호출 한 다음 메소드를 호출하여 각 옵션을 설정 한 다음 &lt;a href=&quot;struct.openoptions#method.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; 을 호출하여 열려고 하는 파일의 경로를 전달합니다. 그러면 &lt;a href=&quot;struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; 을 추가로 조작 할 수 있는 &lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; 가 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="ef7a9d88d07b5708f08d417b4551f7e7322bf0bc" translate="yes" xml:space="preserve">
          <source>Generally speaking, you should just &lt;code&gt;derive&lt;/code&gt; a &lt;code&gt;Debug&lt;/code&gt; implementation.</source>
          <target state="translated">일반적으로, 당신은해야한다 &lt;code&gt;derive&lt;/code&gt; &lt;code&gt;Debug&lt;/code&gt; 구현을.</target>
        </trans-unit>
        <trans-unit id="732f11f2232d28d3cd17a16f8d12c4158ae671a2" translate="yes" xml:space="preserve">
          <source>Generally, &lt;code&gt;Self: Sized&lt;/code&gt; is used to indicate that the trait should not be used as a trait object. If the trait comes from your own crate, consider removing this restriction.</source>
          <target state="translated">일반적으로 &lt;code&gt;Self: Sized&lt;/code&gt; 은 특성을 특성 오브젝트로 사용해서는 안됨을 나타내는 데 사용됩니다. 특성이 자신의 상자에서 나온 경우이 제한을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="4e2b4a1c449efa70704f19e5e57263ca0c4ffc22" translate="yes" xml:space="preserve">
          <source>Generally, for smart pointers you will implement &lt;code&gt;CoerceUnsized&amp;lt;Ptr&amp;lt;U&amp;gt;&amp;gt; for Ptr&amp;lt;T&amp;gt; where T: Unsize&amp;lt;U&amp;gt;, U: ?Sized&lt;/code&gt;, with an optional &lt;code&gt;?Sized&lt;/code&gt; bound on &lt;code&gt;T&lt;/code&gt; itself. For wrapper types that directly embed &lt;code&gt;T&lt;/code&gt; like &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, you can directly implement &lt;code&gt;CoerceUnsized&amp;lt;Wrap&amp;lt;U&amp;gt;&amp;gt; for Wrap&amp;lt;T&amp;gt; where T: CoerceUnsized&amp;lt;U&amp;gt;&lt;/code&gt;. This will let coercions of types like &lt;code&gt;Cell&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; work.</source>
          <target state="translated">일반적으로, 스마트 포인터를 위해 당신이 구현할 &lt;code&gt;CoerceUnsized&amp;lt;Ptr&amp;lt;U&amp;gt;&amp;gt; for Ptr&amp;lt;T&amp;gt; where T: Unsize&amp;lt;U&amp;gt;, U: ?Sized&lt;/code&gt; , 옵션으로 &lt;code&gt;?Sized&lt;/code&gt; 에 바인딩 &lt;code&gt;T&lt;/code&gt; 자체. &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; 및 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; &amp;lt;T&amp;gt; 와 같이 &lt;code&gt;T&lt;/code&gt; 를 직접 임베드하는 랩퍼 유형의 &lt;code&gt;CoerceUnsized&amp;lt;Wrap&amp;lt;U&amp;gt;&amp;gt; for Wrap&amp;lt;T&amp;gt; where T: CoerceUnsized&amp;lt;U&amp;gt;&lt;/code&gt; 직접 구현할 수 있습니다 . 여기서 T : CoerceUnsized &amp;lt;U&amp;gt; 입니다. 이렇게하면 &lt;code&gt;Cell&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 와 같은 유형의 강제가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5a24acc6c6f1f6f5fa4a70e0c8ec97be7ad2c8f4" translate="yes" xml:space="preserve">
          <source>Generate the nth Fibonacci number.</source>
          <target state="translated">n 번째 피보나치 수를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="4055bcedf4ef42a40655c354d55e695956e52c99" translate="yes" xml:space="preserve">
          <source>Generates a wide character sequence for potentially ill-formed UTF-16.</source>
          <target state="translated">잠재적으로 잘못된 형식의 UTF-16에 대한 넓은 문자 시퀀스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2358686f35ad9babf41475908fbf7fb94c7fb8f0" translate="yes" xml:space="preserve">
          <source>Generates the base configuration for spawning a thread, from which configuration methods can be chained.</source>
          <target state="translated">구성 방법을 체인화 할 수있는 스레드 생성을위한 기본 구성을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="4eed3f4ef0910be56eecb5b88bc01f17517c6c08" translate="yes" xml:space="preserve">
          <source>Generating a Random Number</source>
          <target state="translated">난수 생성</target>
        </trans-unit>
        <trans-unit id="4344ed85b4c6edaff3d6a74283da67d4030e7149" translate="yes" xml:space="preserve">
          <source>Generating a Secret Number</source>
          <target state="translated">비밀 번호 생성</target>
        </trans-unit>
        <trans-unit id="1d20de03126b297e05c13a7d280f33e24c72c537" translate="yes" xml:space="preserve">
          <source>Generator</source>
          <target state="translated">Generator</target>
        </trans-unit>
        <trans-unit id="be3352ebf40a7e8e4b021ce3ac0440a124629bf5" translate="yes" xml:space="preserve">
          <source>Generator::resume</source>
          <target state="translated">Generator::resume</target>
        </trans-unit>
        <trans-unit id="8a05177b6fef574c9007b27a5b9c1d6d147b496c" translate="yes" xml:space="preserve">
          <source>GeneratorState</source>
          <target state="translated">GeneratorState</target>
        </trans-unit>
        <trans-unit id="d04f291cf43bb98ceb2d5124b4e75aa6ba1544d4" translate="yes" xml:space="preserve">
          <source>GeneratorState::borrow</source>
          <target state="translated">GeneratorState::borrow</target>
        </trans-unit>
        <trans-unit id="e237a5c5d934ed2bcc036a7ec579e8363436fa8f" translate="yes" xml:space="preserve">
          <source>GeneratorState::borrow_mut</source>
          <target state="translated">GeneratorState::borrow_mut</target>
        </trans-unit>
        <trans-unit id="2502b2db43ac135d156ec67093f193a1d551ada7" translate="yes" xml:space="preserve">
          <source>GeneratorState::clamp</source>
          <target state="translated">GeneratorState::clamp</target>
        </trans-unit>
        <trans-unit id="14c55996161a4d9905bb442a79bebdda60c0a770" translate="yes" xml:space="preserve">
          <source>GeneratorState::clone</source>
          <target state="translated">GeneratorState::clone</target>
        </trans-unit>
        <trans-unit id="3f7f8fe2855b988679d6469ba23b116c95fb7f94" translate="yes" xml:space="preserve">
          <source>GeneratorState::clone_from</source>
          <target state="translated">GeneratorState::clone_from</target>
        </trans-unit>
        <trans-unit id="80b100a3f0da64d40e398e415f7da34b79e8c141" translate="yes" xml:space="preserve">
          <source>GeneratorState::clone_into</source>
          <target state="translated">GeneratorState::clone_into</target>
        </trans-unit>
        <trans-unit id="e257c93690e4d8869ec57678eef2e65d13e430ee" translate="yes" xml:space="preserve">
          <source>GeneratorState::cmp</source>
          <target state="translated">GeneratorState::cmp</target>
        </trans-unit>
        <trans-unit id="8a2e0ed5e7b43d7400dac081e69edcd39c918c34" translate="yes" xml:space="preserve">
          <source>GeneratorState::eq</source>
          <target state="translated">GeneratorState::eq</target>
        </trans-unit>
        <trans-unit id="89c2703dea761c8c48ffa4254fb375381596d10f" translate="yes" xml:space="preserve">
          <source>GeneratorState::fmt</source>
          <target state="translated">GeneratorState::fmt</target>
        </trans-unit>
        <trans-unit id="eda2eb9f12fc2973fa0ac082be186f3fadfe23bd" translate="yes" xml:space="preserve">
          <source>GeneratorState::from</source>
          <target state="translated">GeneratorState::from</target>
        </trans-unit>
        <trans-unit id="a10861d2a70c2a97bea18ae69516399a36bee43f" translate="yes" xml:space="preserve">
          <source>GeneratorState::ge</source>
          <target state="translated">GeneratorState::ge</target>
        </trans-unit>
        <trans-unit id="72a246cb6eeb7bd47306411db8d35d82c5c697bd" translate="yes" xml:space="preserve">
          <source>GeneratorState::gt</source>
          <target state="translated">GeneratorState::gt</target>
        </trans-unit>
        <trans-unit id="f47d401161e51de0bd3708a6aa6b0162f13c3a4d" translate="yes" xml:space="preserve">
          <source>GeneratorState::hash</source>
          <target state="translated">GeneratorState::hash</target>
        </trans-unit>
        <trans-unit id="0d2cf74073e99ac2f7b4a8d84ac45a2dec7d63a3" translate="yes" xml:space="preserve">
          <source>GeneratorState::hash_slice</source>
          <target state="translated">GeneratorState::hash_slice</target>
        </trans-unit>
        <trans-unit id="d362c3c3176b8bb099ef83d916f2d082b1a7c9b7" translate="yes" xml:space="preserve">
          <source>GeneratorState::into</source>
          <target state="translated">GeneratorState::into</target>
        </trans-unit>
        <trans-unit id="b756ce5dda7c46f9d07b0d1aca348d701a969f8c" translate="yes" xml:space="preserve">
          <source>GeneratorState::le</source>
          <target state="translated">GeneratorState::le</target>
        </trans-unit>
        <trans-unit id="93e42bf71e3b440df1059a94e8e0dc45070ae52f" translate="yes" xml:space="preserve">
          <source>GeneratorState::lt</source>
          <target state="translated">GeneratorState::lt</target>
        </trans-unit>
        <trans-unit id="6d1cac78c83d7c9a11d1fbbd289720c9f3206ab7" translate="yes" xml:space="preserve">
          <source>GeneratorState::max</source>
          <target state="translated">GeneratorState::max</target>
        </trans-unit>
        <trans-unit id="37560d6c837e27a56cbfe576d408ec65983cd14a" translate="yes" xml:space="preserve">
          <source>GeneratorState::min</source>
          <target state="translated">GeneratorState::min</target>
        </trans-unit>
        <trans-unit id="3549d5021f412f184a2ec1f2eb1ad44c8d1d5469" translate="yes" xml:space="preserve">
          <source>GeneratorState::ne</source>
          <target state="translated">GeneratorState::ne</target>
        </trans-unit>
        <trans-unit id="eaf2826ae0eabec3e56edf7fd20219fdbd1719d8" translate="yes" xml:space="preserve">
          <source>GeneratorState::partial_cmp</source>
          <target state="translated">GeneratorState::partial_cmp</target>
        </trans-unit>
        <trans-unit id="bc63dfa2c5dc307fd7de8a64413574342399b682" translate="yes" xml:space="preserve">
          <source>GeneratorState::to_owned</source>
          <target state="translated">GeneratorState::to_owned</target>
        </trans-unit>
        <trans-unit id="50328fd3c1aba2c5f8f065dcd6362c0cc51dfd2c" translate="yes" xml:space="preserve">
          <source>GeneratorState::try_from</source>
          <target state="translated">GeneratorState::try_from</target>
        </trans-unit>
        <trans-unit id="98ea27a003d07dda294e378b634a2c17ba4c3a3e" translate="yes" xml:space="preserve">
          <source>GeneratorState::try_into</source>
          <target state="translated">GeneratorState::try_into</target>
        </trans-unit>
        <trans-unit id="87741a9ed7c3b2106ba319e6c46fba99b623309a" translate="yes" xml:space="preserve">
          <source>GeneratorState::type_id</source>
          <target state="translated">GeneratorState::type_id</target>
        </trans-unit>
        <trans-unit id="7f39e996a867af2cbe188c7b44ecc3d06e5acc04" translate="yes" xml:space="preserve">
          <source>Generators, also commonly referred to as coroutines, are currently an experimental language feature in Rust. Added in &lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/2033&quot;&gt;RFC 2033&lt;/a&gt; generators are currently intended to primarily provide a building block for async/await syntax but will likely extend to also providing an ergonomic definition for iterators and other primitives.</source>
          <target state="translated">일반적으로 코 루틴이라고도하는 생성기는 현재 Rust의 실험 언어 기능입니다. &lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/2033&quot;&gt;RFC 2033에&lt;/a&gt; 추가 된 제너레이터는 현재 주로 비동기 / 대기 구문을위한 빌딩 블록을 제공하지만 반복자와 다른 프리미티브에 대한 인체 공학적 정의를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="326f639e29705946500c3f82d8731c2e1774c768" translate="yes" xml:space="preserve">
          <source>Generic &lt;a href=&quot;types/parameters&quot;&gt;type parameters&lt;/a&gt;.</source>
          <target state="translated">일반 &lt;a href=&quot;types/parameters&quot;&gt;유형 매개 변수&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1807cc787d281913c23f12bd3560541d8f00b032" translate="yes" xml:space="preserve">
          <source>Generic Data Types</source>
          <target state="translated">일반 데이터 유형</target>
        </trans-unit>
        <trans-unit id="98f64976fc4f70ae5ee15f3bc5b13a2d6b9d672a" translate="yes" xml:space="preserve">
          <source>Generic Implementations</source>
          <target state="translated">일반적인 구현</target>
        </trans-unit>
        <trans-unit id="f072da836e4d916032d518ff0f18fd650d4581ad" translate="yes" xml:space="preserve">
          <source>Generic Lifetimes in Functions</source>
          <target state="translated">함수의 일반적인 수명</target>
        </trans-unit>
        <trans-unit id="27eeb642b1a0c27c15bf839571b69f7e44c24936" translate="yes" xml:space="preserve">
          <source>Generic Traits</source>
          <target state="translated">일반 특성</target>
        </trans-unit>
        <trans-unit id="efb89da0fe84fb1c10e0e67f29f7eeede9f0ba20" translate="yes" xml:space="preserve">
          <source>Generic Type Parameters, Trait Bounds, and Lifetimes Together</source>
          <target state="translated">일반 유형 매개 변수, 특성 경계 및 수명 함께</target>
        </trans-unit>
        <trans-unit id="9cd42050d57736e2d4fca7655d0893381fa92cbb" translate="yes" xml:space="preserve">
          <source>Generic Types, Traits, and Lifetimes</source>
          <target state="translated">일반 유형, 특성 및 수명</target>
        </trans-unit>
        <trans-unit id="37f5365cdbef14515226dcd384583192170cc525" translate="yes" xml:space="preserve">
          <source>Generic functions</source>
          <target state="translated">일반 함수</target>
        </trans-unit>
        <trans-unit id="1f4659089d7ab3bbc1fbc01f1bd9729f123901fd" translate="yes" xml:space="preserve">
          <source>Generic functions and generic structs can use traits to constrain, or bound, the types they accept.</source>
          <target state="translated">제네릭 함수와 제네릭 구조체는 특성을 사용하여 허용되는 형식을 제한하거나 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eae8cd46084865929b442cf8ea6d11173b23b60b" translate="yes" xml:space="preserve">
          <source>Generic functions and types with a &lt;code&gt;T: Trait&lt;/code&gt; bounds can be used with &lt;code&gt;Ty&lt;/code&gt; being used for &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">A의 일반 기능 및 유형 &lt;code&gt;T: Trait&lt;/code&gt; 경계는 함께 사용할 수있는 &lt;code&gt;Ty&lt;/code&gt; 에 사용되는 &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4bcab43ed4f07d581db4e91c1af83663a27b91de" translate="yes" xml:space="preserve">
          <source>Generic hashing support.</source>
          <target state="translated">일반 해싱 지원.</target>
        </trans-unit>
        <trans-unit id="5c44d31fa6749df8167db78b7f69c1e6b8112cff" translate="yes" xml:space="preserve">
          <source>Generic items may use traits as &lt;a href=&quot;../trait-bounds&quot;&gt;bounds&lt;/a&gt; on their type parameters.</source>
          <target state="translated">일반 항목은 특성을 유형 매개 변수의 &lt;a href=&quot;../trait-bounds&quot;&gt;경계&lt;/a&gt; 로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="910a23e27585722660fb101574581723e9023985" translate="yes" xml:space="preserve">
          <source>Generic lifetime &lt;code&gt;'b&lt;/code&gt; must outlive lifetime &lt;code&gt;'a&lt;/code&gt;</source>
          <target state="translated">일반 수명 &lt;code&gt;'b&lt;/code&gt; 수명보다 수명이 길어야합니다 &lt;code&gt;'a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7374523f7aaffe9d327555dcc2269e6002424197" translate="yes" xml:space="preserve">
          <source>Generic lifetime and type parameters allow &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; on them. There are no built-in attributes that do anything in this position, although custom derive attributes may give meaning to it.</source>
          <target state="translated">일반 수명 및 유형 매개 변수는 &lt;a href=&quot;../attributes&quot;&gt;속성&lt;/a&gt; 을 허용 합니다. 사용자 지정 파생 속성에 의미가있을 수 있지만이 위치에 어떤 작업을 수행하는 기본 제공 속성은 없습니다.</target>
        </trans-unit>
        <trans-unit id="070d7b64bfe57bcc62addca63e2c1cff8dd83211" translate="yes" xml:space="preserve">
          <source>Generic parameter &lt;code&gt;T&lt;/code&gt; constrained to types that implement &lt;code&gt;U&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;U&lt;/code&gt; 를 구현하는 유형으로 제한되는 일반 매개 변수 &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a0662e93a0c0518f55b130b80b54fb79df0d0c94" translate="yes" xml:space="preserve">
          <source>Generic type &lt;code&gt;T&lt;/code&gt; contains no borrowed references other than &lt;code&gt;'static&lt;/code&gt; ones</source>
          <target state="translated">일반 타입 &lt;code&gt;T&lt;/code&gt; 는 더 이상 다른 참조를 빌려하지 포함 &lt;code&gt;'static&lt;/code&gt; 들</target>
        </trans-unit>
        <trans-unit id="aff0c7dbfb36e71d34305b173306f472b0221612" translate="yes" xml:space="preserve">
          <source>Generic type &lt;code&gt;T&lt;/code&gt; must outlive lifetime &lt;code&gt;'a&lt;/code&gt; (meaning the type cannot transitively contain any references with lifetimes shorter than &lt;code&gt;'a&lt;/code&gt;)</source>
          <target state="translated">제네릭 형식 &lt;code&gt;T&lt;/code&gt; 수명보다 오래해야한다 &lt;code&gt;'a&lt;/code&gt; (유형을 의미하는 것은 이적으로보다 짧은 수명에 대한 참조를 포함 할 수 없습니다 &lt;code&gt;'a&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e6e64547108bd126e5d53a717612fe87ff383d16" translate="yes" xml:space="preserve">
          <source>Generic type parameters in a struct definition aren&amp;rsquo;t always the same as those you use in that struct&amp;rsquo;s method signatures. For example, Listing 10-11 defines the method &lt;code&gt;mixup&lt;/code&gt; on the &lt;code&gt;Point&amp;lt;T, U&amp;gt;&lt;/code&gt; struct from Listing 10-8. The method takes another &lt;code&gt;Point&lt;/code&gt; as a parameter, which might have different types from the &lt;code&gt;self&lt;/code&gt;&lt;code&gt;Point&lt;/code&gt; we&amp;rsquo;re calling &lt;code&gt;mixup&lt;/code&gt; on. The method creates a new &lt;code&gt;Point&lt;/code&gt; instance with the &lt;code&gt;x&lt;/code&gt; value from the &lt;code&gt;self&lt;/code&gt;&lt;code&gt;Point&lt;/code&gt; (of type &lt;code&gt;T&lt;/code&gt;) and the &lt;code&gt;y&lt;/code&gt; value from the passed-in &lt;code&gt;Point&lt;/code&gt; (of type &lt;code&gt;W&lt;/code&gt;).</source>
          <target state="translated">구조체 정의의 제네릭 형식 매개 변수가 해당 구조체의 메서드 시그니처에서 사용하는 것과 항상 같지는 않습니다. 예를 들어, 목록 10-11은 목록 10-8 의 &lt;code&gt;Point&amp;lt;T, U&amp;gt;&lt;/code&gt; 구조체에서 메서드 &lt;code&gt;mixup&lt;/code&gt; 을 정의합니다 . 이 메서드는 다른 &lt;code&gt;Point&lt;/code&gt; 를 매개 변수로 사용합니다 . 이 &lt;code&gt;Point&lt;/code&gt; 는 &lt;code&gt;mixup&lt;/code&gt; 을 호출 하는 &lt;code&gt;self&lt;/code&gt; 포인트 와 다른 유형을 가질 수 있습니다 . 이 방법은 새로 생성 &lt;code&gt;Point&lt;/code&gt; 와 인스턴스 &lt;code&gt;x&lt;/code&gt; 로부터 값 &lt;code&gt;self&lt;/code&gt; &lt;code&gt;Point&lt;/code&gt; (유형의 &lt;code&gt;T&lt;/code&gt; ) 및 &lt;code&gt;y&lt;/code&gt; 전달 된 값에서 &lt;code&gt;Point&lt;/code&gt; (A 타입의 &lt;code&gt;W&lt;/code&gt; )를.</target>
        </trans-unit>
        <trans-unit id="7a5cd7c90099ca5a967101e4cfad667e3decbf3d" translate="yes" xml:space="preserve">
          <source>Gets a handle to the thread that invokes it.</source>
          <target state="translated">호출하는 스레드에 대한 핸들을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d82a8f0547b098b3e15a8465f846472c994e131e" translate="yes" xml:space="preserve">
          <source>Gets a mutable iterator over the entries of the map, sorted by key.</source>
          <target state="translated">키로 정렬 된 맵 항목에 대해 변경 가능한 반복자를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="1ac6a489d416bd5c5ef9fe3e6c54e36610970d42" translate="yes" xml:space="preserve">
          <source>Gets a mutable iterator over the values of the map, in order by key.</source>
          <target state="translated">키를 기준으로 맵 값에 대해 변경 가능한 반복자를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c387218a90a9bb1918a7924816b86e529b82f080" translate="yes" xml:space="preserve">
          <source>Gets a mutable pointer to the contained value. Reading from this pointer or turning it into a reference is undefined behavior unless the &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; is initialized.</source>
          <target state="translated">포함 된 값에 대한 가변 포인터를 가져옵니다. &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 가 초기화 되지 않으면이 포인터에서 읽거나 참조로 바꾸는 것은 정의되지 않은 동작 입니다.</target>
        </trans-unit>
        <trans-unit id="b569ba746c83e8a3f0560e8c5640e4d7d0cf471a" translate="yes" xml:space="preserve">
          <source>Gets a mutable pointer to the first element of the array.</source>
          <target state="translated">배열의 첫 번째 요소에 대한 가변 포인터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="93221faf609cb53b66eed583ddd8ff4650ad1090" translate="yes" xml:space="preserve">
          <source>Gets a mutable pointer to the wrapped value.</source>
          <target state="translated">랩핑 된 값에 대한 변경 가능한 포인터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6d7b2240ef54c761d6faa307793ba693f884b564" translate="yes" xml:space="preserve">
          <source>Gets a mutable reference to the contained value.</source>
          <target state="translated">포함 된 값에 대한 변경 가능한 참조를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="baa6d6ef07f8226c5636c761217972d8dab55984" translate="yes" xml:space="preserve">
          <source>Gets a mutable reference to the data inside of this &lt;code&gt;Pin&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Pin&lt;/code&gt; 내부의 데이터에 대한 변경 가능한 참조를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="be59995f2e9c7b5e3f2085e347793a76d09f5142" translate="yes" xml:space="preserve">
          <source>Gets a mutable reference to the key and value in the entry.</source>
          <target state="translated">항목의 키 및 값에 대한 변경 가능한 참조를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="392a07775c4cbc76c6f5c44ba9a3213fc2da81fd" translate="yes" xml:space="preserve">
          <source>Gets a mutable reference to the key in the entry.</source>
          <target state="translated">항목의 키에 대한 변경 가능한 참조를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="5011a90347126d03d01127126a86107c5208ff3e" translate="yes" xml:space="preserve">
          <source>Gets a mutable reference to the underlying reader.</source>
          <target state="translated">기본 판독기에 대한 변경 가능한 참조를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="f2e7f5b6ab637a03072f9c7e9b6f73027700454e" translate="yes" xml:space="preserve">
          <source>Gets a mutable reference to the underlying value in this cursor.</source>
          <target state="translated">이 커서의 기본 값에 대한 변경 가능한 참조를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="dec4b0e863c4ca94f197dad1d6d087c7c4489b09" translate="yes" xml:space="preserve">
          <source>Gets a mutable reference to the underlying writer.</source>
          <target state="translated">기본 작성기에 대한 변경 가능한 참조를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="46ecc0b581f4368e77b78de6bcf33878428bee2b" translate="yes" xml:space="preserve">
          <source>Gets a mutable reference to the value in the entry.</source>
          <target state="translated">항목의 값에 대한 변경 가능한 참조를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="325584547464337b8a139f4e032f2c9235b63738" translate="yes" xml:space="preserve">
          <source>Gets a pinned mutable reference from this pinned pointer.</source>
          <target state="translated">이 고정 된 포인터에서 고정 된 가변 참조를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b99a2e7f3dd3f0850a631d924a0f85ceb5ab793c" translate="yes" xml:space="preserve">
          <source>Gets a pinned shared reference from this pinned pointer.</source>
          <target state="translated">이 고정 포인터에서 고정 공유 참조를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4518638a3643d66963581854e8f287c3740674d7" translate="yes" xml:space="preserve">
          <source>Gets a pointer to the contained value. Reading from this pointer or turning it into a reference is undefined behavior unless the &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; is initialized. Writing to memory that this pointer (non-transitively) points to is undefined behavior (except inside an &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">포함 된 값에 대한 포인터를 가져옵니다. &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 가 초기화 되지 않으면이 포인터에서 읽거나 참조로 바꾸는 것은 정의되지 않은 동작 입니다. 이 포인터가 (전 이적으로) 가리키는 메모리에 쓰는 것은 정의되지 않은 동작입니다 ( &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; 내부 제외 ).</target>
        </trans-unit>
        <trans-unit id="df26339f7815b59c7db8559b2dc091cf260e6a95" translate="yes" xml:space="preserve">
          <source>Gets a pointer to the first element of the array.</source>
          <target state="translated">배열의 첫 번째 요소에 대한 포인터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="de0b41d5362a52c7e2047db8d30137b1ccf260d5" translate="yes" xml:space="preserve">
          <source>Gets a reference to the contained value.</source>
          <target state="translated">포함 된 값에 대한 참조를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="cff65263d72903c422d0a7597523c0375366ab3b" translate="yes" xml:space="preserve">
          <source>Gets a reference to the key and value in the entry.</source>
          <target state="translated">항목의 키 및 값에 대한 참조를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a73b6b64fba7c9a4c0709973dbffd936a0e9fbd2" translate="yes" xml:space="preserve">
          <source>Gets a reference to the key in the entry.</source>
          <target state="translated">항목의 키에 대한 참조를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="feddda07d6595d79eeaf54c555c5ae797d32fafa" translate="yes" xml:space="preserve">
          <source>Gets a reference to the key that would be used when inserting a value through the &lt;code&gt;VacantEntry&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;VacantEntry&lt;/code&gt; 를 통해 값을 삽입 할 때 사용될 키에 대한 참조를 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="7ec6e3eeb0b6ad5023996187968d591cae5085ca" translate="yes" xml:space="preserve">
          <source>Gets a reference to the key that would be used when inserting a value through the VacantEntry.</source>
          <target state="translated">VacantEntry를 통해 값을 삽입 할 때 사용될 키에 대한 참조를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="cf505aa88d1d27b7fd7210fea3eb5f424893e421" translate="yes" xml:space="preserve">
          <source>Gets a reference to the underlying reader.</source>
          <target state="translated">기본 독자에 대한 참조를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="bcf7058743e55a29769e9f52c6d7eb995745282c" translate="yes" xml:space="preserve">
          <source>Gets a reference to the underlying value in this cursor.</source>
          <target state="translated">이 커서의 기본 값에 대한 참조를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="cb7cc9508e37a0159bd3a7b3b0845509f330a592" translate="yes" xml:space="preserve">
          <source>Gets a reference to the underlying writer.</source>
          <target state="translated">기본 작성자에 대한 참조를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a9eb138b06bc622e04583407ce48c73c001c324e" translate="yes" xml:space="preserve">
          <source>Gets a reference to the value in the entry.</source>
          <target state="translated">항목의 값에 대한 참조를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="bf39c650c88ad522e7aa25fef3aa0cf8f15445c4" translate="yes" xml:space="preserve">
          <source>Gets a shared reference out of a pin.</source>
          <target state="translated">핀에서 공유 참조를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7979bb5a2e24a20633426914599d65cc13e380ce" translate="yes" xml:space="preserve">
          <source>Gets a static string slice containing the name of a type.</source>
          <target state="translated">형식 이름이 포함 된 정적 문자열 슬라이스를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="fe0c54b937e7b93e8f39dc4887850e732a02eae2" translate="yes" xml:space="preserve">
          <source>Gets an approximation of the number of &lt;code&gt;Weak&lt;/code&gt; pointers pointing to this value.</source>
          <target state="translated">이 값을 가리키는 &lt;code&gt;Weak&lt;/code&gt; 포인터 수의 근사값을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="234ebcadb6ac6bb0def6ad4173e0e189daeb1439" translate="yes" xml:space="preserve">
          <source>Gets an identifier which is globally unique to the specified type. This function will return the same value for a type regardless of whichever crate it is invoked in.</source>
          <target state="translated">지정된 형식에 대해 전역 적으로 고유 한 식별자를 가져옵니다. 이 함수는 호출 된 상자에 관계없이 유형에 대해 동일한 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="77e393eb1ab1f3573f4cc8c8d9a6214bd3e5808e" translate="yes" xml:space="preserve">
          <source>Gets an iterator for moving out the &lt;code&gt;BTreeSet&lt;/code&gt;'s contents.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; 의 내용 을 옮기는 반복자를 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="11b43ebc9818fa3526a8e800dba2a829340904c9" translate="yes" xml:space="preserve">
          <source>Gets an iterator over the entries of the map, sorted by key.</source>
          <target state="translated">키로 정렬 된 맵 항목에 대한 반복자를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4282f4ebb370a2d3e37842bf8bea7691a93cc17f" translate="yes" xml:space="preserve">
          <source>Gets an iterator over the keys of the map, in sorted order.</source>
          <target state="translated">정렬 된 순서로 맵의 키에 대한 반복자를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="88cd2b443e0410f773c3db3b4b02c30273a29587" translate="yes" xml:space="preserve">
          <source>Gets an iterator over the values of the map, in order by key.</source>
          <target state="translated">키 순서대로 맵 값에 대한 반복자를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="f7d58dcf7a90c88a6dd8d8e2a936de88caad9b01" translate="yes" xml:space="preserve">
          <source>Gets an iterator that visits the values in the &lt;code&gt;BTreeSet&lt;/code&gt; in ascending order.</source>
          <target state="translated">&lt;code&gt;BTreeSet&lt;/code&gt; 의 값 을 오름차순으로 방문하는 반복자를 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="bf50547bde43305eadfc81da6c51963036f0b0bc" translate="yes" xml:space="preserve">
          <source>Gets mutable references to the underlying readers in this &lt;code&gt;Chain&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Chain&lt;/code&gt; 의 기본 독자에 대한 변경 가능한 참조를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="c5d75c4c07b578c3182dd1391a22f0515f568828" translate="yes" xml:space="preserve">
          <source>Gets references to the underlying readers in this &lt;code&gt;Chain&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Chain&lt;/code&gt; 의 기본 독자에 대한 참조를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="4099d19a8a1a54e1ad72f73ecdd2402a0b7a3136" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;TypeId&lt;/code&gt; of &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 의 &lt;code&gt;TypeId&lt;/code&gt; 를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="41602bda251eaed54ccea25679c0483e128331bf" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;TypeId&lt;/code&gt; of &lt;code&gt;self&lt;/code&gt;. &lt;a href=&quot;../../../any/trait.any#tymethod.type_id&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 의 &lt;code&gt;TypeId&lt;/code&gt; 를 가져옵니다 . &lt;a href=&quot;../../../any/trait.any#tymethod.type_id&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7397491fe536b6ab323bc3962fba8e1fb15e1948" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;TypeId&lt;/code&gt; of &lt;code&gt;self&lt;/code&gt;. &lt;a href=&quot;../../any/trait.any#tymethod.type_id&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 의 &lt;code&gt;TypeId&lt;/code&gt; 를 가져옵니다 . &lt;a href=&quot;../../any/trait.any#tymethod.type_id&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d0958a5367c67c57557138ce54a3c5f59d233668" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;TypeId&lt;/code&gt; of &lt;code&gt;self&lt;/code&gt;. &lt;a href=&quot;../any/trait.any#tymethod.type_id&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 의 &lt;code&gt;TypeId&lt;/code&gt; 를 가져옵니다 . &lt;a href=&quot;../any/trait.any#tymethod.type_id&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e0dc7f61a814ccb0f4c7bc6d983b16e56f33b8b7" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;TypeId&lt;/code&gt; of &lt;code&gt;self&lt;/code&gt;. &lt;a href=&quot;any/trait.any#tymethod.type_id&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 의 &lt;code&gt;TypeId&lt;/code&gt; 를 가져옵니다 . &lt;a href=&quot;any/trait.any#tymethod.type_id&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d6053452902f00975747e0db67cb9da5bcc78254" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;TypeId&lt;/code&gt; of &lt;code&gt;self&lt;/code&gt;. &lt;a href=&quot;trait.any#tymethod.type_id&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 의 &lt;code&gt;TypeId&lt;/code&gt; 를 가져옵니다 . &lt;a href=&quot;trait.any#tymethod.type_id&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cfed0516ca0cceacbef295ac249aa061f2675ee1" translate="yes" xml:space="preserve">
          <source>Gets the given key's corresponding entry in the map for in-place manipulation.</source>
          <target state="translated">전체 조작을 위해 맵에서 지정된 키의 해당 항목을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="82785258c5148ac429e819aa10802824ac7d2a46" translate="yes" xml:space="preserve">
          <source>Gets the number of &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to this value.</source>
          <target state="translated">이 값에 대한 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 포인터 수를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="2d6bb90de6f3314e5b0aa7676e3fa2574049a5b1" translate="yes" xml:space="preserve">
          <source>Gets the number of &lt;code&gt;Weak&lt;/code&gt; pointers pointing to this value.</source>
          <target state="translated">이 값을 가리키는 &lt;code&gt;Weak&lt;/code&gt; 포인터 수를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="55f33a15ae6da7b8fd099c7f81c55a8c43992a9c" translate="yes" xml:space="preserve">
          <source>Gets the number of strong (&lt;code&gt;Arc&lt;/code&gt;) pointers pointing to this value.</source>
          <target state="translated">이 값을 가리키는 강한 ( &lt;code&gt;Arc&lt;/code&gt; ) 포인터 의 수를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="8c9d8a68862d17ae50fe9b2191b4bc755a3b2c57" translate="yes" xml:space="preserve">
          <source>Gets the number of strong (&lt;code&gt;Arc&lt;/code&gt;) pointers to this value.</source>
          <target state="translated">이 값에 대한 강한 ( &lt;code&gt;Arc&lt;/code&gt; ) 포인터 수를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="6dfd6b399c6a7a5e5c213f4220d6a406180d8d29" translate="yes" xml:space="preserve">
          <source>Gets the number of strong (&lt;code&gt;Rc&lt;/code&gt;) pointers pointing to this value.</source>
          <target state="translated">이 값을 가리키는 강한 ( &lt;code&gt;Rc&lt;/code&gt; ) 포인터 의 수를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="62256e04434cb17270e60d73bd90064ac287c70a" translate="yes" xml:space="preserve">
          <source>Gets the number of strong (&lt;code&gt;Rc&lt;/code&gt;) pointers to this value.</source>
          <target state="translated">이 값에 대한 강한 ( &lt;code&gt;Rc&lt;/code&gt; ) 포인터 의 수를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="9a803af3c996a7aeaae26131be70879a8de1e8ca" translate="yes" xml:space="preserve">
          <source>Gets the thread's name.</source>
          <target state="translated">스레드 이름을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="49ee03c4c760e66b9e940fbfa2d32f04a888601b" translate="yes" xml:space="preserve">
          <source>Gets the thread's unique identifier.</source>
          <target state="translated">스레드의 고유 식별자를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e80f24c5e15d0db75eb52ca4f146d8328ad163c8" translate="yes" xml:space="preserve">
          <source>Gets the underlying byte view of the &lt;a href=&quot;../../../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; slice.</source>
          <target state="translated">&lt;a href=&quot;../../../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt; 슬라이스 의 기본 바이트보기를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="6ce976fab972b71cb3689e58f2c81f4c1b2c23c3" translate="yes" xml:space="preserve">
          <source>Gets the underlying byte view of the [&lt;code&gt;OsStr&lt;/code&gt;] slice. &lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.as_bytes&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">[ &lt;code&gt;OsStr&lt;/code&gt; ] 슬라이스 의 기본 바이트보기를 가져옵니다 . &lt;a href=&quot;../os/unix/ffi/trait.osstrext#tymethod.as_bytes&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b70bb73da43a0dacb273f9c29de1ad90c047f9b2" translate="yes" xml:space="preserve">
          <source>Gets the value of the &lt;code&gt;IPV6_MULTICAST_LOOP&lt;/code&gt; option for this socket.</source>
          <target state="translated">이 소켓 의 &lt;code&gt;IPV6_MULTICAST_LOOP&lt;/code&gt; 옵션 의 값을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="541e09715c0e448d9ee0ceae38a6c62a42e062e7" translate="yes" xml:space="preserve">
          <source>Gets the value of the &lt;code&gt;IP_MULTICAST_LOOP&lt;/code&gt; option for this socket.</source>
          <target state="translated">이 소켓 의 &lt;code&gt;IP_MULTICAST_LOOP&lt;/code&gt; 옵션 의 값을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="ee99abd672fa0bc29c2f53bc51cd2022f7fe6174" translate="yes" xml:space="preserve">
          <source>Gets the value of the &lt;code&gt;IP_MULTICAST_TTL&lt;/code&gt; option for this socket.</source>
          <target state="translated">이 소켓 의 &lt;code&gt;IP_MULTICAST_TTL&lt;/code&gt; 옵션 의 값을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="ca264fa81bb9d68241254fa46d7aa2c2cda498bc" translate="yes" xml:space="preserve">
          <source>Gets the value of the &lt;code&gt;IP_TTL&lt;/code&gt; option for this socket.</source>
          <target state="translated">이 소켓 의 &lt;code&gt;IP_TTL&lt;/code&gt; 옵션 의 값을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="081675c2121b5c0eba69352ff7f20ab17e65e3d1" translate="yes" xml:space="preserve">
          <source>Gets the value of the &lt;code&gt;SO_BROADCAST&lt;/code&gt; option for this socket.</source>
          <target state="translated">이 소켓 의 &lt;code&gt;SO_BROADCAST&lt;/code&gt; 옵션 의 값을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="0f6a73f5b7aaab6427c36574dc2e96dbd9e394ff" translate="yes" xml:space="preserve">
          <source>Gets the value of the &lt;code&gt;SO_ERROR&lt;/code&gt; option on this socket.</source>
          <target state="translated">이 소켓 의 &lt;code&gt;SO_ERROR&lt;/code&gt; 옵션 의 값을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="fd9694065ed8ce77dc78229e63dba85fa8ab43e4" translate="yes" xml:space="preserve">
          <source>Gets the value of the &lt;code&gt;TCP_NODELAY&lt;/code&gt; option on this socket.</source>
          <target state="translated">이 소켓 에서 &lt;code&gt;TCP_NODELAY&lt;/code&gt; 옵션 의 값을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="a351f54361bf1111912e96b2243de3d3ba2e710e" translate="yes" xml:space="preserve">
          <source>Getter for the underlying string to be searched in</source>
          <target state="translated">검색 할 기본 문자열에 대한 Getter</target>
        </trans-unit>
        <trans-unit id="946249472d59c612c049bc459ef794710e06ea0f" translate="yes" xml:space="preserve">
          <source>Getter for the underlying string to be searched in &lt;a href=&quot;trait.searcher#tymethod.haystack&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">기본 문자열에 대한 게터는에서 검색 할 &lt;a href=&quot;trait.searcher#tymethod.haystack&quot;&gt;더 읽기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">시작하기</target>
        </trans-unit>
        <trans-unit id="5995d36c171cb98f5012509471c6af75ae9b7b83" translate="yes" xml:space="preserve">
          <source>Getting a handle to the current thread with &lt;code&gt;thread::current()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;thread::current()&lt;/code&gt; 사용하여 현재 스레드에 대한 핸들 가져 오기 :</target>
        </trans-unit>
        <trans-unit id="18ecec4eaf70488e9516f42f4c700b0d3f3801c9" translate="yes" xml:space="preserve">
          <source>Getting grapheme clusters from strings is complex, so this functionality is not provided by the standard library. Crates are available on &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; if this is the functionality you need.</source>
          <target state="translated">문자열에서 grapheme 클러스터를 얻는 것은 복잡하므로이 기능은 표준 라이브러리에서 제공되지 않습니다. 크레이트는 필요한 기능이라면 &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io에서&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ce1a3d0561d101c4db29f248d240d379840a525" translate="yes" xml:space="preserve">
          <source>Give it text interactively by running the executable directly, in which case it will wait for the Enter key to be pressed before continuing</source>
          <target state="translated">실행 파일을 직접 실행하여 대화식으로 텍스트를 제공하십시오.이 경우 계속하기 전에 Enter 키를 누를 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="460459e684630e18d67dce5af60c9aa1a9d7fe48" translate="yes" xml:space="preserve">
          <source>Given a list of integers, use a vector and return the mean (the average value), median (when sorted, the value in the middle position), and mode (the value that occurs most often; a hash map will be helpful here) of the list.</source>
          <target state="translated">정수 목록이 주어지면 벡터를 사용하여 평균 (평균 값), 중앙값 (정렬시 중간 위치의 값) 및 모드 (가장 자주 발생하는 값; 해시 맵이 도움이 됨)를 반환 목록의.</target>
        </trans-unit>
        <trans-unit id="ea3d2794af8f5c0a103590ed2dfa3cbed7263acb" translate="yes" xml:space="preserve">
          <source>Given a path, query the file system to get information about a file, directory, etc.</source>
          <target state="translated">경로가 주어지면 파일 시스템을 쿼리하여 파일, 디렉토리 등에 대한 정보를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="30386826e248fa1c007d69f26e43a06ce7da9de9" translate="yes" xml:space="preserve">
          <source>Given that a &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; will call &lt;code&gt;drop&lt;/code&gt; as it unwinds, any &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt; in a &lt;code&gt;drop&lt;/code&gt; implementation will likely abort.</source>
          <target state="translated">그 &lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt; 감안할 때 ! 풀리면 &lt;code&gt;drop&lt;/code&gt; 을 호출 합니다 &lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;A의 &lt;code&gt;drop&lt;/code&gt; 구현 가능성이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="e523f1998c41a0b9adf80292e1554bbf7101fb13" translate="yes" xml:space="preserve">
          <source>Given that the &lt;code&gt;String&lt;/code&gt; is empty, this will not allocate any initial buffer. While that means that this initial operation is very inexpensive, it may cause excessive allocation later when you add data. If you have an idea of how much data the &lt;code&gt;String&lt;/code&gt; will hold, consider the &lt;a href=&quot;#method.with_capacity&quot;&gt;&lt;code&gt;with_capacity&lt;/code&gt;&lt;/a&gt; method to prevent excessive re-allocation.</source>
          <target state="translated">점을 감안 &lt;code&gt;String&lt;/code&gt; 비어 있습니다, 이것은 어떤 초기 버퍼를 할당하지 않습니다. 이는이 초기 작업이 매우 저렴하다는 것을 의미하지만 나중에 데이터를 추가 할 때 과도한 할당이 발생할 수 있습니다. &lt;code&gt;String&lt;/code&gt; 이 얼마나 많은 데이터 를 보유 할 지 &lt;a href=&quot;#method.with_capacity&quot;&gt; &lt;code&gt;with_capacity&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 과도한 재 할당을 방지하십시오.</target>
        </trans-unit>
        <trans-unit id="ad539d6fb0976a5b2b95b62832510a1f84220951" translate="yes" xml:space="preserve">
          <source>Given that the smart pointer pattern is a general design pattern used frequently in Rust, this chapter won&amp;rsquo;t cover every existing smart pointer. Many libraries have their own smart pointers, and you can even write your own. We&amp;rsquo;ll cover the most common smart pointers in the standard library:</source>
          <target state="translated">스마트 포인터 패턴은 Rust에서 자주 사용되는 일반적인 디자인 패턴이므로이 장에서는 기존의 모든 스마트 포인터를 다루지 않습니다. 많은 라이브러리에는 자체 스마트 포인터가 있으며 직접 작성할 수도 있습니다. 표준 라이브러리에서 가장 일반적인 스마트 포인터를 다룰 것입니다.</target>
        </trans-unit>
        <trans-unit id="4a31e9d96bd27c24e6fc00ba6a064634849de284" translate="yes" xml:space="preserve">
          <source>Given that we don't know what type the pointer is, and there's potential ambiguity for some types, we disallow calling methods on raw pointers when the type is unknown.</source>
          <target state="translated">우리는 포인터가 어떤 타입인지 알지 못하고, 어떤 타입에는 모호성이있을 수 있으므로 타입을 알 수 없을 때 원시 포인터에 대한 메소드 호출을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5f1184f7df96c5928092ad9c6b550699bf887826" translate="yes" xml:space="preserve">
          <source>Global</source>
          <target state="translated">Global</target>
        </trans-unit>
        <trans-unit id="597030c6c4f56fe393a1ab438473028f6c480a3f" translate="yes" xml:space="preserve">
          <source>Global::alloc</source>
          <target state="translated">Global::alloc</target>
        </trans-unit>
        <trans-unit id="bc8440f1b0fd5e4f27413dbc2c9588f0ac4b35e6" translate="yes" xml:space="preserve">
          <source>Global::alloc_array</source>
          <target state="translated">Global::alloc_array</target>
        </trans-unit>
        <trans-unit id="286809b4d3acafb6b79ba2357ef09d081752bcd8" translate="yes" xml:space="preserve">
          <source>Global::alloc_excess</source>
          <target state="translated">Global::alloc_excess</target>
        </trans-unit>
        <trans-unit id="055e192998c987cc2408347852310a7d777d50b2" translate="yes" xml:space="preserve">
          <source>Global::alloc_one</source>
          <target state="translated">Global::alloc_one</target>
        </trans-unit>
        <trans-unit id="4916367e840ff297f5f655976deb8d56431c82b1" translate="yes" xml:space="preserve">
          <source>Global::alloc_zeroed</source>
          <target state="translated">Global::alloc_zeroed</target>
        </trans-unit>
        <trans-unit id="422dfaa437889aa6a38e0ce319516d4e1aa7ccbe" translate="yes" xml:space="preserve">
          <source>Global::borrow</source>
          <target state="translated">Global::borrow</target>
        </trans-unit>
        <trans-unit id="7a0370da6de58c97a35cfc99cd0bed7729121756" translate="yes" xml:space="preserve">
          <source>Global::borrow_mut</source>
          <target state="translated">Global::borrow_mut</target>
        </trans-unit>
        <trans-unit id="f77b715da0c371e387a1c0cabbb0d1af068041af" translate="yes" xml:space="preserve">
          <source>Global::clone</source>
          <target state="translated">Global::clone</target>
        </trans-unit>
        <trans-unit id="50d4c87192aeed0b09b4440b16be390f6a750a2f" translate="yes" xml:space="preserve">
          <source>Global::clone_from</source>
          <target state="translated">Global::clone_from</target>
        </trans-unit>
        <trans-unit id="9cfb69614980015da407f6e7048f1148f4930023" translate="yes" xml:space="preserve">
          <source>Global::clone_into</source>
          <target state="translated">Global::clone_into</target>
        </trans-unit>
        <trans-unit id="7b2c4b961ebce1561e240a7194da73b5841efb82" translate="yes" xml:space="preserve">
          <source>Global::dealloc</source>
          <target state="translated">Global::dealloc</target>
        </trans-unit>
        <trans-unit id="1a080a708cdd5439e5302ec1934574d59cf90d7d" translate="yes" xml:space="preserve">
          <source>Global::dealloc_array</source>
          <target state="translated">Global::dealloc_array</target>
        </trans-unit>
        <trans-unit id="d428b88cec77fa2bb91fead3f27848981c76580d" translate="yes" xml:space="preserve">
          <source>Global::dealloc_one</source>
          <target state="translated">Global::dealloc_one</target>
        </trans-unit>
        <trans-unit id="995b6ad6ac004f90a18a104ffb9147bf847cb8d1" translate="yes" xml:space="preserve">
          <source>Global::default</source>
          <target state="translated">Global::default</target>
        </trans-unit>
        <trans-unit id="76169c6a841dcf12cff8e0b09058ec8d2b45201d" translate="yes" xml:space="preserve">
          <source>Global::fmt</source>
          <target state="translated">Global::fmt</target>
        </trans-unit>
        <trans-unit id="5c3cece4620e1e6edac7a400fcf912adfe0d27cb" translate="yes" xml:space="preserve">
          <source>Global::from</source>
          <target state="translated">Global::from</target>
        </trans-unit>
        <trans-unit id="a59d2fc290a04b6f0c31c9e50dafd716b2e306ed" translate="yes" xml:space="preserve">
          <source>Global::grow_in_place</source>
          <target state="translated">Global::grow_in_place</target>
        </trans-unit>
        <trans-unit id="25a7d5ad4d365ca4c966f334f3295d6b1ceaaf1d" translate="yes" xml:space="preserve">
          <source>Global::into</source>
          <target state="translated">Global::into</target>
        </trans-unit>
        <trans-unit id="ce7a411799e0b5091e1cb6d261729a98fde69476" translate="yes" xml:space="preserve">
          <source>Global::realloc</source>
          <target state="translated">Global::realloc</target>
        </trans-unit>
        <trans-unit id="55cd704a6f196baec10e6f8fc46f13be6be1a4da" translate="yes" xml:space="preserve">
          <source>Global::realloc_array</source>
          <target state="translated">Global::realloc_array</target>
        </trans-unit>
        <trans-unit id="2dc3bca035c872b5fad904a8f47f338aa69c712d" translate="yes" xml:space="preserve">
          <source>Global::realloc_excess</source>
          <target state="translated">Global::realloc_excess</target>
        </trans-unit>
        <trans-unit id="2eba0652c97a930f2bb92b95f7d1bce1986c871b" translate="yes" xml:space="preserve">
          <source>Global::shrink_in_place</source>
          <target state="translated">Global::shrink_in_place</target>
        </trans-unit>
        <trans-unit id="736720c59f4f431a038c46cc3aa525e5758a39ba" translate="yes" xml:space="preserve">
          <source>Global::to_owned</source>
          <target state="translated">Global::to_owned</target>
        </trans-unit>
        <trans-unit id="8ce6860d43ee49cdb5334bdd351c1035cc8ff38c" translate="yes" xml:space="preserve">
          <source>Global::try_from</source>
          <target state="translated">Global::try_from</target>
        </trans-unit>
        <trans-unit id="617366a681bd521ad66de932f01b46a609e71cb1" translate="yes" xml:space="preserve">
          <source>Global::try_into</source>
          <target state="translated">Global::try_into</target>
        </trans-unit>
        <trans-unit id="a23ee2c26cf33d2d9d02972f8660c76e5304674f" translate="yes" xml:space="preserve">
          <source>Global::type_id</source>
          <target state="translated">Global::type_id</target>
        </trans-unit>
        <trans-unit id="af4b996fed7b58c24cbe5ab00c833b6e42a8a4d4" translate="yes" xml:space="preserve">
          <source>Global::usable_size</source>
          <target state="translated">Global::usable_size</target>
        </trans-unit>
        <trans-unit id="240acfbbf20ecc23d32a755b89f3059599c547b8" translate="yes" xml:space="preserve">
          <source>GlobalAlloc</source>
          <target state="translated">GlobalAlloc</target>
        </trans-unit>
        <trans-unit id="fc670f003f08164e69bb95fb98d8c6ed228f9f51" translate="yes" xml:space="preserve">
          <source>GlobalAlloc::alloc</source>
          <target state="translated">GlobalAlloc::alloc</target>
        </trans-unit>
        <trans-unit id="90c20880262c918bb85b13b512a72e9595a71d28" translate="yes" xml:space="preserve">
          <source>GlobalAlloc::alloc_zeroed</source>
          <target state="translated">GlobalAlloc::alloc_zeroed</target>
        </trans-unit>
        <trans-unit id="aebfa8de2c70a18e38a89cd348582fe45986c6b2" translate="yes" xml:space="preserve">
          <source>GlobalAlloc::dealloc</source>
          <target state="translated">GlobalAlloc::dealloc</target>
        </trans-unit>
        <trans-unit id="fe2c144d895a892ee23f306ecdb0f1fde3f96ad7" translate="yes" xml:space="preserve">
          <source>GlobalAlloc::realloc</source>
          <target state="translated">GlobalAlloc::realloc</target>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="2514908c36408ef2ed4444834c9f5ccbe93b670b" translate="yes" xml:space="preserve">
          <source>Glue for usage of the &lt;a href=&quot;../macro.write&quot;&gt;&lt;code&gt;write!&lt;/code&gt;&lt;/a&gt; macro with implementors of this trait.</source>
          <target state="translated">&lt;a href=&quot;../macro.write&quot;&gt; &lt;code&gt;write!&lt;/code&gt; &lt;/a&gt; 사용을위한 접착제 ! 이 특성의 구현 자와 매크로.</target>
        </trans-unit>
        <trans-unit id="63f9aa2e6d4ad074b5cfe6a907121a6231effb73" translate="yes" xml:space="preserve">
          <source>Glue for usage of the [&lt;code&gt;write!&lt;/code&gt;] macro with implementors of this trait. &lt;a href=&quot;../fmt/trait.write#method.write_fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">[ &lt;code&gt;write!&lt;/code&gt; 사용을위한 접착제 ]이 특성을 구현 한 매크로 &lt;a href=&quot;../fmt/trait.write#method.write_fmt&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="34773aa1db362e995011ad93000d8b9d338dfdd1" translate="yes" xml:space="preserve">
          <source>Glue for usage of the [&lt;code&gt;write!&lt;/code&gt;] macro with implementors of this trait. &lt;a href=&quot;fmt/trait.write#method.write_fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">[ &lt;code&gt;write!&lt;/code&gt; 사용을위한 접착제 ]이 특성을 구현 한 매크로 &lt;a href=&quot;fmt/trait.write#method.write_fmt&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bbef5a72f8aabf3ae93fcc57e62c0a0223a518e5" translate="yes" xml:space="preserve">
          <source>Glue for usage of the [&lt;code&gt;write!&lt;/code&gt;] macro with implementors of this trait. &lt;a href=&quot;trait.write#method.write_fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">[ &lt;code&gt;write!&lt;/code&gt; 사용을위한 접착제 ]이 특성을 구현 한 매크로 &lt;a href=&quot;trait.write#method.write_fmt&quot;&gt;더 읽어보기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2c5134e463153b73435701f263a503592ab3d53a" translate="yes" xml:space="preserve">
          <source>Go into the &lt;em&gt;hello_cargo&lt;/em&gt; directory and list the files. You&amp;rsquo;ll see that Cargo has generated two files and one directory for us: a &lt;em&gt;Cargo.toml&lt;/em&gt; file and a &lt;em&gt;src&lt;/em&gt; directory with a &lt;em&gt;main.rs&lt;/em&gt; file inside. It has also initialized a new Git repository along with a &lt;em&gt;.gitignore&lt;/em&gt; file.</source>
          <target state="translated">&lt;em&gt;hello_cargo&lt;/em&gt; 디렉토리 로 이동 하여 파일을 나열하십시오. Cargo가 두 개의 파일과 하나의 디렉토리 ( &lt;em&gt;Cargo.toml&lt;/em&gt; 파일과 &lt;em&gt;main.rs&lt;/em&gt; 파일이있는 &lt;em&gt;src&lt;/em&gt; 디렉토리)를 &lt;em&gt;생성했음을 알 수&lt;/em&gt; 있습니다. 또한 &lt;em&gt;.gitignore&lt;/em&gt; 파일 과 함께 새로운 Git 리포지토리를 초기화했습니다 .</target>
        </trans-unit>
        <trans-unit id="b6849789947c3320fec7645aaddce84614976c34" translate="yes" xml:space="preserve">
          <source>Going finite with &lt;a href=&quot;trait.iterator#method.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;trait.iterator#method.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; 와 함께 유한 :</target>
        </trans-unit>
        <trans-unit id="62320f24d2e67e3a996b5eb69a47e8e61772abe1" translate="yes" xml:space="preserve">
          <source>Graceful Shutdown and Cleanup</source>
          <target state="translated">정상 종료 및 정리</target>
        </trans-unit>
        <trans-unit id="dd17342cb47b948d64f169d73cfeec3f8b3e3f31" translate="yes" xml:space="preserve">
          <source>Grammar</source>
          <target state="translated">Grammar</target>
        </trans-unit>
        <trans-unit id="78e61d853fc7dbe21e195185b06132c0a0b3267c" translate="yes" xml:space="preserve">
          <source>Great! The code read and then printed the contents of the file. But the code has a few flaws. The &lt;code&gt;main&lt;/code&gt; function has multiple responsibilities: generally, functions are clearer and easier to maintain if each function is responsible for only one idea. The other problem is that we&amp;rsquo;re not handling errors as well as we could. The program is still small, so these flaws aren&amp;rsquo;t a big problem, but as the program grows, it will be harder to fix them cleanly. It&amp;rsquo;s good practice to begin refactoring early on when developing a program, because it&amp;rsquo;s much easier to refactor smaller amounts of code. We&amp;rsquo;ll do that next.</source>
          <target state="translated">큰! 코드는 파일의 내용을 읽고 인쇄했습니다. 그러나 코드에는 몇 가지 결함이 있습니다. &lt;code&gt;main&lt;/code&gt; 기능은 여러 책임이있다 : 각 기능은 하나의 아이디어에 대한 책임이 경우 일반적으로, 기능을 유지하기 위해 명확하고 쉽다. 다른 문제는 우리가 할 수있는만큼 오류를 처리하지 않는다는 것입니다. 프로그램은 여전히 ​​작기 때문에 이러한 결함은 큰 문제는 아니지만 프로그램이 커질수록 깨끗하게 수정하기가 더 어려워집니다. 적은 양의 코드를 리팩토링하는 것이 훨씬 쉽기 때문에 프로그램을 개발할 때 리팩토링을 일찍 시작하는 것이 좋습니다. 다음에 해보겠습니다.</target>
        </trans-unit>
        <trans-unit id="24a6854de536fe8272a59608dce7cfe696deeaaa" translate="yes" xml:space="preserve">
          <source>Great! They passed. Now, let&amp;rsquo;s call the new &lt;code&gt;search_case_insensitive&lt;/code&gt; function from the &lt;code&gt;run&lt;/code&gt; function. First, we&amp;rsquo;ll add a configuration option to the &lt;code&gt;Config&lt;/code&gt; struct to switch between case-sensitive and case-insensitive search. Adding this field will cause compiler errors because we aren&amp;rsquo;t initializing this field anywhere yet:</source>
          <target state="translated">큰! 그들은 통과했다. 이제 &lt;code&gt;run&lt;/code&gt; 함수 에서 새로운 &lt;code&gt;search_case_insensitive&lt;/code&gt; 함수를 호출 해 봅시다 . 먼저 &lt;code&gt;Config&lt;/code&gt; 구조체에 구성 옵션을 추가하여 대소 문자를 구분하는 검색과 대소 문자를 구분하지 않는 검색을 전환합니다. 이 필드를 추가하면 아직이 필드를 초기화하지 않기 때문에 컴파일러 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="64d373f5a71955e4f9210539868f04851ae696bb" translate="yes" xml:space="preserve">
          <source>Great! This error tells us we need a &lt;code&gt;ThreadPool&lt;/code&gt; type or module, so we&amp;rsquo;ll build one now. Our &lt;code&gt;ThreadPool&lt;/code&gt; implementation will be independent of the kind of work our web server is doing. So, let&amp;rsquo;s switch the &lt;code&gt;hello&lt;/code&gt; crate from a binary crate to a library crate to hold our &lt;code&gt;ThreadPool&lt;/code&gt; implementation. After we change to a library crate, we could also use the separate thread pool library for any work we want to do using a thread pool, not just for serving web requests.</source>
          <target state="translated">큰! 이 에러는 &lt;code&gt;ThreadPool&lt;/code&gt; 타입이나 모듈이 필요하다는 것을 알려주 므로 지금 빌드 할 것입니다. 우리의 &lt;code&gt;ThreadPool&lt;/code&gt; 구현은 웹 서버가 수행하는 작업의 종류와 무관합니다. 자,이 전환 할 수 &lt;code&gt;hello&lt;/code&gt; 우리 개최 라이브러리 상자에 진 상자에서 상자를 &lt;code&gt;ThreadPool&lt;/code&gt; 구현. 라이브러리 상자로 변경 한 후에는 웹 요청을 처리하기위한 것이 아니라 스레드 풀을 사용하여 수행하려는 모든 작업에 별도의 스레드 풀 라이브러리를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="99b891e6f196f47f49f63f0b20ce223eaba55683" translate="yes" xml:space="preserve">
          <source>Great! This output is much friendlier for our users.</source>
          <target state="translated">큰! 이 결과는 사용자에게 훨씬 친숙합니다.</target>
        </trans-unit>
        <trans-unit id="2929f4d3537f13046a6a6654b391acff14ad5b53" translate="yes" xml:space="preserve">
          <source>Great, the program is working! The values of the arguments we need are being saved into the right variables. Later we&amp;rsquo;ll add some error handling to deal with certain potential erroneous situations, such as when the user provides no arguments; for now, we&amp;rsquo;ll ignore that situation and work on adding file-reading capabilities instead.</source>
          <target state="translated">프로그램이 작동하고 있습니다. 필요한 인수 값이 올바른 변수에 저장됩니다. 나중에 사용자가 인수를 제공하지 않는 경우와 같이 특정 잠재적 오류 상황을 처리하기 위해 오류 처리를 추가 할 것입니다. 지금은 그러한 상황을 무시하고 대신 파일 읽기 기능을 추가하는 작업을합니다.</target>
        </trans-unit>
        <trans-unit id="c5f93da0af9ef56fee44e82925405c317fbf7afc" translate="yes" xml:space="preserve">
          <source>Great, the test fails, exactly as we expected. Let&amp;rsquo;s get the test to pass!</source>
          <target state="translated">테스트가 예상대로 정확하게 실패합니다. 시험에 합격합시다!</target>
        </trans-unit>
        <trans-unit id="599294f23ef04a992bc69ba465066344c3c7cf34" translate="yes" xml:space="preserve">
          <source>Greater than</source>
          <target state="translated">보다 큰</target>
        </trans-unit>
        <trans-unit id="cc21fdb8f5e4e1d5b5c729ed455db20a348682c5" translate="yes" xml:space="preserve">
          <source>Greater than comparison</source>
          <target state="translated">비교보다 큼</target>
        </trans-unit>
        <trans-unit id="a2919540599e9df0beb579ca8d46bdc142657611" translate="yes" xml:space="preserve">
          <source>Greater than or equal to</source>
          <target state="translated">크거나 같음</target>
        </trans-unit>
        <trans-unit id="17e61387621cb5a7a3632ffc26d2a8ab3f16e769" translate="yes" xml:space="preserve">
          <source>Greater than or equal to comparison</source>
          <target state="translated">비교 이상</target>
        </trans-unit>
        <trans-unit id="d667800b5ed7b98aa0dde326047666b10d805fc3" translate="yes" xml:space="preserve">
          <source>Greater-than comparison for two &lt;code&gt;Arc&lt;/code&gt;s.</source>
          <target state="translated">두 &lt;code&gt;Arc&lt;/code&gt; 대한 비교보다 큽니다 .</target>
        </trans-unit>
        <trans-unit id="3f06e7136cc69760b0d1c2aa5adb37088b0a0311" translate="yes" xml:space="preserve">
          <source>Greater-than comparison for two &lt;code&gt;Rc&lt;/code&gt;s.</source>
          <target state="translated">두 &lt;code&gt;Rc&lt;/code&gt; 에 대한 비교보다 큽니다 .</target>
        </trans-unit>
        <trans-unit id="f464c4ed26773e9c5252581a89a104e8de23d490" translate="yes" xml:space="preserve">
          <source>Greek letters &quot;&amp;alpha;&quot; &quot;&amp;beta;&quot; &quot;&amp;gamma;&quot; &quot;&amp;delta;&quot; stand for potentially empty token-tree sequences. (However, the Greek letter &quot;&amp;epsilon;&quot; (epsilon) has a special role in the presentation and does not stand for a token-tree sequence.)</source>
          <target state="translated">그리스 문자 &quot;&amp;alpha;&quot; &quot;&amp;beta;&quot; &quot;&amp;gamma;&quot; &quot;&amp;delta;&quot;는 잠재적으로 비어있는 토큰 트리 시퀀스를 나타냅니다. 그러나 그리스 문자 &quot;&amp;epsilon;&quot;(epsilon)는 프레젠테이션에서 특별한 역할을하며 토큰 트리 시퀀스를 나타내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="90accf7e4de3f988bebb9b0fcc656094cc41c05f" translate="yes" xml:space="preserve">
          <source>Group expression attributes</source>
          <target state="translated">그룹 표현식 속성</target>
        </trans-unit>
        <trans-unit id="ef7a9bb1a692431ae6d8dff02418977a8053e1b7" translate="yes" xml:space="preserve">
          <source>Grouped expressions</source>
          <target state="translated">그룹화 된 표현</target>
        </trans-unit>
        <trans-unit id="13970f54032da4ae14dbff0318664d8c8f7ae9de" translate="yes" xml:space="preserve">
          <source>Grouped patterns</source>
          <target state="translated">그룹화 된 패턴</target>
        </trans-unit>
        <trans-unit id="990b2d14bf2da723821496eca71bc9a4f287e41e" translate="yes" xml:space="preserve">
          <source>Grouping Configuration Values</source>
          <target state="translated">구성 값 그룹화</target>
        </trans-unit>
        <trans-unit id="ad08922b155e0f0ecfa878359b6bdba11de6fcc5" translate="yes" xml:space="preserve">
          <source>Groups items</source>
          <target state="translated">그룹스 항목</target>
        </trans-unit>
        <trans-unit id="1dee13ac09a18c736a85fb7212501ca3f0535655" translate="yes" xml:space="preserve">
          <source>Gt</source>
          <target state="translated">Gt</target>
        </trans-unit>
        <trans-unit id="e72af43a28130c6f52db641d01a37aabf78c282e" translate="yes" xml:space="preserve">
          <source>Guarantees</source>
          <target state="translated">Guarantees</target>
        </trans-unit>
        <trans-unit id="643a27fb6062be0d6499f01fc4bde0f4334880b4" translate="yes" xml:space="preserve">
          <source>Guidance on which license is appropriate for your project is beyond the scope of this book. Many people in the Rust community license their projects in the same way as Rust by using a dual license of &lt;code&gt;MIT OR Apache-2.0&lt;/code&gt;. This practice demonstrates that you can also specify multiple license identifiers separated by &lt;code&gt;OR&lt;/code&gt; to have multiple licenses for your project.</source>
          <target state="translated">프로젝트에 적합한 라이센스에 대한 지침은이 책의 범위를 벗어납니다. Rust 커뮤니티의 많은 사람들은 &lt;code&gt;MIT OR Apache-2.0&lt;/code&gt; 의 이중 라이센스를 사용하여 Rust와 동일한 방식으로 프로젝트 라이센스를 부여합니다 . 이 연습에서는 &lt;code&gt;OR&lt;/code&gt; 로 구분 된 여러 라이센스 식별자를 지정 하여 프로젝트에 대한 여러 라이센스를 가질 수도 있음을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">Guide</target>
        </trans-unit>
        <trans-unit id="5662999f81a9d63d43963dff643c8f2e0db48c56" translate="yes" xml:space="preserve">
          <source>Guidelines for Error Handling</source>
          <target state="translated">오류 처리 지침</target>
        </trans-unit>
        <trans-unit id="0b19d1e1b8a5918571f9c9d135638b9f04547d8f" translate="yes" xml:space="preserve">
          <source>HANDLE</source>
          <target state="translated">HANDLE</target>
        </trans-unit>
        <trans-unit id="1a486ce8f36726233061ec65b3f6bda493fd48c9" translate="yes" xml:space="preserve">
          <source>HEX_DIGIT : [&lt;code&gt;0&lt;/code&gt;-&lt;code&gt;9&lt;/code&gt;&lt;code&gt;a&lt;/code&gt;-&lt;code&gt;f&lt;/code&gt;&lt;code&gt;A&lt;/code&gt;-&lt;code&gt;F&lt;/code&gt;]</source>
          <target state="translated">HEX_DIGIT : &lt;code&gt;0&lt;/code&gt; - &lt;code&gt;9&lt;/code&gt; - &lt;code&gt;f&lt;/code&gt; - &lt;code&gt;F&lt;/code&gt; ] &lt;code&gt;a&lt;/code&gt; &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e195a9555456bea0e92fe340c3ae06ff639810c6" translate="yes" xml:space="preserve">
          <source>HEX_DIGIT&lt;sup&gt;1..6&lt;/sup&gt;</source>
          <target state="translated">HEX_DIGIT&lt;sup&gt;1..6&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="5f9c36747e4699e63511061195cedb992801b9d3" translate="yes" xml:space="preserve">
          <source>HEX_LITERAL :</source>
          <target state="translated">HEX_LITERAL :</target>
        </trans-unit>
        <trans-unit id="85b770e7ec266276f5de99706626234eb555c7b0" translate="yes" xml:space="preserve">
          <source>HTTP is a text-based protocol, and a request takes this format:</source>
          <target state="translated">HTTP는 텍스트 기반 프로토콜이며 요청은 다음 형식을 취합니다.</target>
        </trans-unit>
        <trans-unit id="3c47a723a85c131d97bf2d4bd392d2947fe77f70" translate="yes" xml:space="preserve">
          <source>Had &lt;code&gt;path&lt;/code&gt; contained invalid unicode, the &lt;code&gt;to_string_lossy&lt;/code&gt; call might have returned &lt;code&gt;&quot;fo�.txt&quot;&lt;/code&gt;.</source>
          <target state="translated">했다 &lt;code&gt;path&lt;/code&gt; , 유효하지 않은 유니 코드 포함 &lt;code&gt;to_string_lossy&lt;/code&gt; 의 호출이 반환 수도 &lt;code&gt;&quot;fo�.txt&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ee4aa46e82881f4a75375987b71c3131634f94f" translate="yes" xml:space="preserve">
          <source>Handling Errors Returned from &lt;code id=&quot;handling-errors-returned-from-run-in-main&quot;&gt;run&lt;/code&gt; in &lt;code&gt;main&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 에서 &lt;code id=&quot;handling-errors-returned-from-run-in-main&quot;&gt;run&lt;/code&gt; 에서 리턴 된 처리 오류</target>
        </trans-unit>
        <trans-unit id="187689d6fbeb450bd6ea4e652dae8dbfd0f10e3e" translate="yes" xml:space="preserve">
          <source>Handling I/O</source>
          <target state="translated">I / O 처리</target>
        </trans-unit>
        <trans-unit id="f85b58414971efcc7eee439597523a8f745698cd" translate="yes" xml:space="preserve">
          <source>Handling Invalid Input</source>
          <target state="translated">유효하지 않은 입력 처리</target>
        </trans-unit>
        <trans-unit id="99ae89ce9129c070f0e68c272cb53e5ebe7623fe" translate="yes" xml:space="preserve">
          <source>Handling Multiple Conditions with &lt;code id=&quot;handling-multiple-conditions-with-else-if&quot;&gt;else if&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;handling-multiple-conditions-with-else-if&quot;&gt;else if&lt;/code&gt; 여러 조건 처리</target>
        </trans-unit>
        <trans-unit id="59aadebe3071fa59f50f2105cef14ad03fb21914" translate="yes" xml:space="preserve">
          <source>Handling Potential Failure with the &lt;code id=&quot;handling-potential-failure-with-the-result-type&quot;&gt;Result&lt;/code&gt; Type</source>
          <target state="translated">&lt;code id=&quot;handling-potential-failure-with-the-result-type&quot;&gt;Result&lt;/code&gt; 유형으로 잠재적 실패 처리</target>
        </trans-unit>
        <trans-unit id="90b8d168f939ff8e48ed694781964a3efae61546" translate="yes" xml:space="preserve">
          <source>Handling concurrent programming safely and efficiently is another of Rust&amp;rsquo;s major goals. &lt;em&gt;Concurrent programming&lt;/em&gt;, where different parts of a program execute independently, and &lt;em&gt;parallel programming&lt;/em&gt;, where different parts of a program execute at the same time, are becoming increasingly important as more computers take advantage of their multiple processors. Historically, programming in these contexts has been difficult and error prone: Rust hopes to change that.</source>
          <target state="translated">동시 프로그래밍을 안전하고 효율적으로 처리하는 것은 Rust의 주요 목표 중 하나입니다. &lt;em&gt;프로그램의&lt;/em&gt; 다른 부분이 독립적으로 실행되는 &lt;em&gt;동시 프로그래밍&lt;/em&gt; 과 프로그램의 다른 부분이 동시에 실행 되는 &lt;em&gt;병렬 프로그래밍&lt;/em&gt; 은 더 많은 컴퓨터가 여러 프로세서를 활용함에 따라 점점 더 중요 해지고 있습니다. 역사적으로 이러한 맥락에서 프로그래밍하는 것은 어렵고 오류가 발생하기 쉽습니다. Rust는이를 변경하기를 희망합니다.</target>
        </trans-unit>
        <trans-unit id="8f7b16e3844bb9bbaa86ba42b5bf793b3b5747f5" translate="yes" xml:space="preserve">
          <source>Handling errors (&lt;a href=&quot;ch09-00-error-handling&quot;&gt;Chapter 9&lt;/a&gt;)</source>
          <target state="translated">에러 처리 ( &lt;a href=&quot;ch09-00-error-handling&quot;&gt;9 장&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="a8a516b582d8ee827caa06b852f0927dd7ea1aa9" translate="yes" xml:space="preserve">
          <source>Handling the error if &lt;code&gt;run&lt;/code&gt; returns an error</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; 에서 오류를 반환하는 경우 오류 처리</target>
        </trans-unit>
        <trans-unit id="72f36c92a5a7396e8365dbdfe793e5eef4ad9431" translate="yes" xml:space="preserve">
          <source>Has the effects of both &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; together: For loads it uses &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; ordering. For stores it uses the &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; ordering.</source>
          <target state="translated">&lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; 가&lt;/a&gt; 함께 효과가 있습니다.로드의 경우 &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; 주문을 사용합니다 . 상점의 경우 &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; 주문을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="873507a022b58de26a88deae87268cbd8d6af5b1" translate="yes" xml:space="preserve">
          <source>Hash</source>
          <target state="translated">Hash</target>
        </trans-unit>
        <trans-unit id="d16b2d08d75092ccdbc53063c23e2c3fe71d7f34" translate="yes" xml:space="preserve">
          <source>Hash Maps and Ownership</source>
          <target state="translated">해시 맵 및 소유권</target>
        </trans-unit>
        <trans-unit id="49d09ebb7291bff93c80ac3f381f55fe8a3c4cbf" translate="yes" xml:space="preserve">
          <source>Hash a raw pointer.</source>
          <target state="translated">원시 포인터를 해시하십시오.</target>
        </trans-unit>
        <trans-unit id="6c5bfe7d7f5d3cec7864d666ab67d3faebb741c0" translate="yes" xml:space="preserve">
          <source>Hash maps are useful when you want to look up data not by using an index, as you can with vectors, but by using a key that can be of any type. For example, in a game, you could keep track of each team&amp;rsquo;s score in a hash map in which each key is a team&amp;rsquo;s name and the values are each team&amp;rsquo;s score. Given a team name, you can retrieve its score.</source>
          <target state="translated">해시 맵은 벡터를 사용할 때처럼 인덱스를 사용하지 않고 모든 유형의 키를 사용하여 데이터를 조회 할 때 유용합니다. 예를 들어 게임에서 각 키는 팀 이름이고 값은 각 팀의 점수 인 해시 맵에서 각 팀의 점수를 추적 할 수 있습니다. 팀 이름이 주어지면 점수를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f26fb9fba1361d959b70bbd8e0907090c8a67651" translate="yes" xml:space="preserve">
          <source>Hash memoization</source>
          <target state="translated">해시 메모</target>
        </trans-unit>
        <trans-unit id="1ca569e43628039695db4d117d37cb0433c51032" translate="yes" xml:space="preserve">
          <source>Hash::hash</source>
          <target state="translated">Hash::hash</target>
        </trans-unit>
        <trans-unit id="bac71fb916a479ac2558a2194819bf301931ca8b" translate="yes" xml:space="preserve">
          <source>Hash::hash_slice</source>
          <target state="translated">Hash::hash_slice</target>
        </trans-unit>
        <trans-unit id="ba62d7b8d0b157f714c6a6132554b38789c6ada5" translate="yes" xml:space="preserve">
          <source>HashMap</source>
          <target state="translated">HashMap</target>
        </trans-unit>
        <trans-unit id="fb7d8a23eadd1e4ece9d9a20a984c6c31289cb8b" translate="yes" xml:space="preserve">
          <source>HashMap::borrow</source>
          <target state="translated">HashMap::borrow</target>
        </trans-unit>
        <trans-unit id="610c174a39c8908fe163a07919237940fc37c1ca" translate="yes" xml:space="preserve">
          <source>HashMap::borrow_mut</source>
          <target state="translated">HashMap::borrow_mut</target>
        </trans-unit>
        <trans-unit id="5b073a19c1d948d2ff7ea181c3e6faa47ac950b7" translate="yes" xml:space="preserve">
          <source>HashMap::capacity</source>
          <target state="translated">HashMap::capacity</target>
        </trans-unit>
        <trans-unit id="290ef182063e668dbc9d6f81f0f99bd696eaa3ad" translate="yes" xml:space="preserve">
          <source>HashMap::clear</source>
          <target state="translated">HashMap::clear</target>
        </trans-unit>
        <trans-unit id="4504d7762629b3f09d106b8b2c49316387f83111" translate="yes" xml:space="preserve">
          <source>HashMap::clone</source>
          <target state="translated">HashMap::clone</target>
        </trans-unit>
        <trans-unit id="755ecc8e2fe0d53bf8d40f09d15dc41f5c72dee3" translate="yes" xml:space="preserve">
          <source>HashMap::clone_from</source>
          <target state="translated">HashMap::clone_from</target>
        </trans-unit>
        <trans-unit id="18149fd5a2f0ddb0a754ee5b20ae060122824af4" translate="yes" xml:space="preserve">
          <source>HashMap::clone_into</source>
          <target state="translated">HashMap::clone_into</target>
        </trans-unit>
        <trans-unit id="c981dd589a66a9541ad1bd942f956a943a21c776" translate="yes" xml:space="preserve">
          <source>HashMap::contains_key</source>
          <target state="translated">HashMap::contains_key</target>
        </trans-unit>
        <trans-unit id="6790c064706283f72985a00fd5d63757494362ee" translate="yes" xml:space="preserve">
          <source>HashMap::default</source>
          <target state="translated">HashMap::default</target>
        </trans-unit>
        <trans-unit id="ef89e29aa59c76930b39d07bb7c27f4f62ca4bc9" translate="yes" xml:space="preserve">
          <source>HashMap::drain</source>
          <target state="translated">HashMap::drain</target>
        </trans-unit>
        <trans-unit id="5c70bb5f39da25e4a3243cd372f9722cdd0aaa06" translate="yes" xml:space="preserve">
          <source>HashMap::entry</source>
          <target state="translated">HashMap::entry</target>
        </trans-unit>
        <trans-unit id="16580b886dde904eb2189a50aaa2ec8e66754a76" translate="yes" xml:space="preserve">
          <source>HashMap::eq</source>
          <target state="translated">HashMap::eq</target>
        </trans-unit>
        <trans-unit id="006972122bed4c52275751aaa6b1a76aa26a72f6" translate="yes" xml:space="preserve">
          <source>HashMap::extend</source>
          <target state="translated">HashMap::extend</target>
        </trans-unit>
        <trans-unit id="eef27e5aeaaee7ca97ef32c4174c3b7aefbfc638" translate="yes" xml:space="preserve">
          <source>HashMap::fmt</source>
          <target state="translated">HashMap::fmt</target>
        </trans-unit>
        <trans-unit id="2bac685119eec98678bcc3e2df09e34b76b251fb" translate="yes" xml:space="preserve">
          <source>HashMap::from</source>
          <target state="translated">HashMap::from</target>
        </trans-unit>
        <trans-unit id="23702b4af8c6608c05d1fc72b700af47889b23e4" translate="yes" xml:space="preserve">
          <source>HashMap::from_iter</source>
          <target state="translated">HashMap::from_iter</target>
        </trans-unit>
        <trans-unit id="688fd04b9fb0128d305e248d2f3d8f8222392c9c" translate="yes" xml:space="preserve">
          <source>HashMap::get</source>
          <target state="translated">HashMap::get</target>
        </trans-unit>
        <trans-unit id="ecd394b5e97d505b5180c88396d32eb04f7a2ef5" translate="yes" xml:space="preserve">
          <source>HashMap::get_key_value</source>
          <target state="translated">HashMap::get_key_value</target>
        </trans-unit>
        <trans-unit id="59fd726634d31c7b61261668c05f7485bf9decb1" translate="yes" xml:space="preserve">
          <source>HashMap::get_mut</source>
          <target state="translated">HashMap::get_mut</target>
        </trans-unit>
        <trans-unit id="9e2f5e352b69c23e1f8634441216dbbc589410a2" translate="yes" xml:space="preserve">
          <source>HashMap::hasher</source>
          <target state="translated">HashMap::hasher</target>
        </trans-unit>
        <trans-unit id="977407424016d1150ed5a54f71aa720d8b5fc1e0" translate="yes" xml:space="preserve">
          <source>HashMap::index</source>
          <target state="translated">HashMap::index</target>
        </trans-unit>
        <trans-unit id="575b9b99b8b6536e98f82916772ec179324759de" translate="yes" xml:space="preserve">
          <source>HashMap::insert</source>
          <target state="translated">HashMap::insert</target>
        </trans-unit>
        <trans-unit id="4241974ff3713d57ec86ed4fb2960fb964b4c28f" translate="yes" xml:space="preserve">
          <source>HashMap::into</source>
          <target state="translated">HashMap::into</target>
        </trans-unit>
        <trans-unit id="2ee397e85e03d2df5163ed8c1f36f63a8275c934" translate="yes" xml:space="preserve">
          <source>HashMap::into_iter</source>
          <target state="translated">HashMap::into_iter</target>
        </trans-unit>
        <trans-unit id="a649d7141d86759b290a9b727d47ad161b114361" translate="yes" xml:space="preserve">
          <source>HashMap::is_empty</source>
          <target state="translated">HashMap::is_empty</target>
        </trans-unit>
        <trans-unit id="cfdbb20825a41950e4f6625ab41ffc0a12e6cfd4" translate="yes" xml:space="preserve">
          <source>HashMap::iter</source>
          <target state="translated">HashMap::iter</target>
        </trans-unit>
        <trans-unit id="2bfca7b0b17c04d487077c012bec3c640635d95c" translate="yes" xml:space="preserve">
          <source>HashMap::iter_mut</source>
          <target state="translated">HashMap::iter_mut</target>
        </trans-unit>
        <trans-unit id="15748fe38a254ba57dde931f14941b25230915de" translate="yes" xml:space="preserve">
          <source>HashMap::keys</source>
          <target state="translated">HashMap::keys</target>
        </trans-unit>
        <trans-unit id="013a2db0fc0510df2be8bb9a81336355dd6c81f5" translate="yes" xml:space="preserve">
          <source>HashMap::len</source>
          <target state="translated">HashMap::len</target>
        </trans-unit>
        <trans-unit id="bbd14da0450a45b2de193fcab5c00bb0eb5903d6" translate="yes" xml:space="preserve">
          <source>HashMap::ne</source>
          <target state="translated">HashMap::ne</target>
        </trans-unit>
        <trans-unit id="7a43b41cd29931fa0443de6420eab17418a5775e" translate="yes" xml:space="preserve">
          <source>HashMap::new</source>
          <target state="translated">HashMap::new</target>
        </trans-unit>
        <trans-unit id="292e274cb26beafe87f9986cd7a69d6e80f0d70e" translate="yes" xml:space="preserve">
          <source>HashMap::raw_entry</source>
          <target state="translated">HashMap::raw_entry</target>
        </trans-unit>
        <trans-unit id="ddac1348f5646998be5c764f10f7f59d986ae24a" translate="yes" xml:space="preserve">
          <source>HashMap::raw_entry_mut</source>
          <target state="translated">HashMap::raw_entry_mut</target>
        </trans-unit>
        <trans-unit id="eb7e68ea1cad35b4a180ddda2294c0954904ff9c" translate="yes" xml:space="preserve">
          <source>HashMap::remove</source>
          <target state="translated">HashMap::remove</target>
        </trans-unit>
        <trans-unit id="daa065a9f2946c9de97f049237fe61d1096fd3ad" translate="yes" xml:space="preserve">
          <source>HashMap::remove_entry</source>
          <target state="translated">HashMap::remove_entry</target>
        </trans-unit>
        <trans-unit id="0121bfc051e62887774fc3f9ec592514d686885b" translate="yes" xml:space="preserve">
          <source>HashMap::reserve</source>
          <target state="translated">HashMap::reserve</target>
        </trans-unit>
        <trans-unit id="88a2076f3660ecd79e0adb0243f0e9d4a8862721" translate="yes" xml:space="preserve">
          <source>HashMap::retain</source>
          <target state="translated">HashMap::retain</target>
        </trans-unit>
        <trans-unit id="f4991ea8c7797b408f7805334922bf7e0c8d10d6" translate="yes" xml:space="preserve">
          <source>HashMap::shrink_to</source>
          <target state="translated">HashMap::shrink_to</target>
        </trans-unit>
        <trans-unit id="dc8f377e69db6a1e9ed141ae6bf011880bd42c53" translate="yes" xml:space="preserve">
          <source>HashMap::shrink_to_fit</source>
          <target state="translated">HashMap::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="bab5c2ac135dfe90b9b32c652153883ceeee3b33" translate="yes" xml:space="preserve">
          <source>HashMap::to_owned</source>
          <target state="translated">HashMap::to_owned</target>
        </trans-unit>
        <trans-unit id="391acc19f610e927b497bb4e11b352a7b2af949e" translate="yes" xml:space="preserve">
          <source>HashMap::try_from</source>
          <target state="translated">HashMap::try_from</target>
        </trans-unit>
        <trans-unit id="2893c51bf9c281d2ca7aba047803684d9a1aa860" translate="yes" xml:space="preserve">
          <source>HashMap::try_into</source>
          <target state="translated">HashMap::try_into</target>
        </trans-unit>
        <trans-unit id="9e7015c3cc0d5bc1003d09ff24337d2b0ad55c7b" translate="yes" xml:space="preserve">
          <source>HashMap::try_reserve</source>
          <target state="translated">HashMap::try_reserve</target>
        </trans-unit>
        <trans-unit id="b2ebec04fba53bc16fb11b0073bb6cc66af50890" translate="yes" xml:space="preserve">
          <source>HashMap::type_id</source>
          <target state="translated">HashMap::type_id</target>
        </trans-unit>
        <trans-unit id="d17a786e030134db4f1882f47a85dce856cb6c49" translate="yes" xml:space="preserve">
          <source>HashMap::values</source>
          <target state="translated">HashMap::values</target>
        </trans-unit>
        <trans-unit id="162e585c9055d46d3b3067b924bb60d67e948304" translate="yes" xml:space="preserve">
          <source>HashMap::values_mut</source>
          <target state="translated">HashMap::values_mut</target>
        </trans-unit>
        <trans-unit id="01bde569a6ca247f70b925283ac4eabf1fae164b" translate="yes" xml:space="preserve">
          <source>HashMap::with_capacity</source>
          <target state="translated">HashMap::with_capacity</target>
        </trans-unit>
        <trans-unit id="c95ee5e43e53e6378ec649a9c2e69ab43598f8fb" translate="yes" xml:space="preserve">
          <source>HashMap::with_capacity_and_hasher</source>
          <target state="translated">HashMap::with_capacity_and_hasher</target>
        </trans-unit>
        <trans-unit id="e7c4071d4f77cdf1820942e0c1ab3de0a91ed2cf" translate="yes" xml:space="preserve">
          <source>HashMap::with_hasher</source>
          <target state="translated">HashMap::with_hasher</target>
        </trans-unit>
        <trans-unit id="cac17f9bdb6febebe0052a72f2ab8a6828d20944" translate="yes" xml:space="preserve">
          <source>HashSet</source>
          <target state="translated">HashSet</target>
        </trans-unit>
        <trans-unit id="b68646e63dfce36d83be9cbaa54a303ef6a007af" translate="yes" xml:space="preserve">
          <source>HashSet::bitand</source>
          <target state="translated">HashSet::bitand</target>
        </trans-unit>
        <trans-unit id="1ab81639812d7d4b62dc39b7419600230fdcf25f" translate="yes" xml:space="preserve">
          <source>HashSet::bitor</source>
          <target state="translated">HashSet::bitor</target>
        </trans-unit>
        <trans-unit id="8075cc2581f90ca9a8938fc5f82b21b6e3d28edf" translate="yes" xml:space="preserve">
          <source>HashSet::bitxor</source>
          <target state="translated">HashSet::bitxor</target>
        </trans-unit>
        <trans-unit id="c77b68f5068bcecde6e8ffd8572dfb041513399a" translate="yes" xml:space="preserve">
          <source>HashSet::borrow</source>
          <target state="translated">HashSet::borrow</target>
        </trans-unit>
        <trans-unit id="03d0b56c31db1f8ba8c12e20646074ec753d52c9" translate="yes" xml:space="preserve">
          <source>HashSet::borrow_mut</source>
          <target state="translated">HashSet::borrow_mut</target>
        </trans-unit>
        <trans-unit id="bdd5342708fbc173156c0ad0e7ccdcf72b87bbec" translate="yes" xml:space="preserve">
          <source>HashSet::capacity</source>
          <target state="translated">HashSet::capacity</target>
        </trans-unit>
        <trans-unit id="b496a7fc22db5dfee5a71eb5501bd54af27226af" translate="yes" xml:space="preserve">
          <source>HashSet::clear</source>
          <target state="translated">HashSet::clear</target>
        </trans-unit>
        <trans-unit id="f6f7e84776c0a1492c95ca329cccd559dae22239" translate="yes" xml:space="preserve">
          <source>HashSet::clone</source>
          <target state="translated">HashSet::clone</target>
        </trans-unit>
        <trans-unit id="ad872e535653208fd311ddac1851f60e92c27461" translate="yes" xml:space="preserve">
          <source>HashSet::clone_from</source>
          <target state="translated">HashSet::clone_from</target>
        </trans-unit>
        <trans-unit id="30071df27bb602cc36f2524cd6272f86cf175d82" translate="yes" xml:space="preserve">
          <source>HashSet::clone_into</source>
          <target state="translated">HashSet::clone_into</target>
        </trans-unit>
        <trans-unit id="e9929a76352b9c6c4517057784d174ca502e4659" translate="yes" xml:space="preserve">
          <source>HashSet::contains</source>
          <target state="translated">HashSet::contains</target>
        </trans-unit>
        <trans-unit id="ee9499c5d925a80b927374f5fc18c8cf7acba286" translate="yes" xml:space="preserve">
          <source>HashSet::default</source>
          <target state="translated">HashSet::default</target>
        </trans-unit>
        <trans-unit id="c5666651d6d13e045665faaee91da5ee35aefa99" translate="yes" xml:space="preserve">
          <source>HashSet::difference</source>
          <target state="translated">HashSet::difference</target>
        </trans-unit>
        <trans-unit id="559bf337908631f9dc2cd3ab1c34c4b7158b1609" translate="yes" xml:space="preserve">
          <source>HashSet::drain</source>
          <target state="translated">HashSet::drain</target>
        </trans-unit>
        <trans-unit id="f25e9846b65f287b930b9d456cbbec8f01e240e9" translate="yes" xml:space="preserve">
          <source>HashSet::eq</source>
          <target state="translated">HashSet::eq</target>
        </trans-unit>
        <trans-unit id="6a91f6923c3310862ee3596940ed5b097a1bf087" translate="yes" xml:space="preserve">
          <source>HashSet::extend</source>
          <target state="translated">HashSet::extend</target>
        </trans-unit>
        <trans-unit id="8be48241f0d314ab0acacea29d3d926070bb5fa9" translate="yes" xml:space="preserve">
          <source>HashSet::fmt</source>
          <target state="translated">HashSet::fmt</target>
        </trans-unit>
        <trans-unit id="b4f60277034657d60f3728ccd3956ff96b1819e2" translate="yes" xml:space="preserve">
          <source>HashSet::from</source>
          <target state="translated">HashSet::from</target>
        </trans-unit>
        <trans-unit id="60f387d38899e1b57c8d30e798c352963e26a097" translate="yes" xml:space="preserve">
          <source>HashSet::from_iter</source>
          <target state="translated">HashSet::from_iter</target>
        </trans-unit>
        <trans-unit id="33cae8d46ad9832e17073c4a9f1abb51a6504d81" translate="yes" xml:space="preserve">
          <source>HashSet::get</source>
          <target state="translated">HashSet::get</target>
        </trans-unit>
        <trans-unit id="6c7ba6a45c151f970088dcc70a1b7618e6395baf" translate="yes" xml:space="preserve">
          <source>HashSet::get_or_insert</source>
          <target state="translated">HashSet::get_or_insert</target>
        </trans-unit>
        <trans-unit id="3c9bf791b1bc89ff50ed8e094f3d77efdc799512" translate="yes" xml:space="preserve">
          <source>HashSet::get_or_insert_with</source>
          <target state="translated">HashSet::get_or_insert_with</target>
        </trans-unit>
        <trans-unit id="01c1744d870244b7145beb071040d269b906cc15" translate="yes" xml:space="preserve">
          <source>HashSet::hasher</source>
          <target state="translated">HashSet::hasher</target>
        </trans-unit>
        <trans-unit id="6f9a670d4aa69b73fdbaf199b1f0dd8253423bff" translate="yes" xml:space="preserve">
          <source>HashSet::insert</source>
          <target state="translated">HashSet::insert</target>
        </trans-unit>
        <trans-unit id="5c5bf765bc94406fc16ab265fee5caf8d4d6d147" translate="yes" xml:space="preserve">
          <source>HashSet::intersection</source>
          <target state="translated">HashSet::intersection</target>
        </trans-unit>
        <trans-unit id="1847c872f1c798ce2ed7fda1f927b3db87be02ae" translate="yes" xml:space="preserve">
          <source>HashSet::into</source>
          <target state="translated">HashSet::into</target>
        </trans-unit>
        <trans-unit id="06dc65fe61329213ae7394dadf80b120758e58bf" translate="yes" xml:space="preserve">
          <source>HashSet::into_iter</source>
          <target state="translated">HashSet::into_iter</target>
        </trans-unit>
        <trans-unit id="67c6eb738c50bfb089cc9e9dd3c556b76c5e5a19" translate="yes" xml:space="preserve">
          <source>HashSet::is_disjoint</source>
          <target state="translated">HashSet::is_disjoint</target>
        </trans-unit>
        <trans-unit id="9463f6acefaba610600eb7b086516e06a56e7415" translate="yes" xml:space="preserve">
          <source>HashSet::is_empty</source>
          <target state="translated">HashSet::is_empty</target>
        </trans-unit>
        <trans-unit id="3494ecfcdfcc0fd49b4716ada245492c590484c8" translate="yes" xml:space="preserve">
          <source>HashSet::is_subset</source>
          <target state="translated">HashSet::is_subset</target>
        </trans-unit>
        <trans-unit id="5a5bed7c64ac7bd90ff2fd3978bbf37d738addfa" translate="yes" xml:space="preserve">
          <source>HashSet::is_superset</source>
          <target state="translated">HashSet::is_superset</target>
        </trans-unit>
        <trans-unit id="d4aa44a96215a84918fccfb358fa46f4343aa9e3" translate="yes" xml:space="preserve">
          <source>HashSet::iter</source>
          <target state="translated">HashSet::iter</target>
        </trans-unit>
        <trans-unit id="e772fc3259c95bf6f1d149e4fe5b58f7beb84957" translate="yes" xml:space="preserve">
          <source>HashSet::len</source>
          <target state="translated">HashSet::len</target>
        </trans-unit>
        <trans-unit id="9d950bd82fcd2e87760e296232658decf6487907" translate="yes" xml:space="preserve">
          <source>HashSet::ne</source>
          <target state="translated">HashSet::ne</target>
        </trans-unit>
        <trans-unit id="faff6aa961e961cb5d0e5be8b0c1765f5a91c089" translate="yes" xml:space="preserve">
          <source>HashSet::new</source>
          <target state="translated">HashSet::new</target>
        </trans-unit>
        <trans-unit id="ab12b0529a6e1a5dea72839456e2d81f89fbb648" translate="yes" xml:space="preserve">
          <source>HashSet::remove</source>
          <target state="translated">HashSet::remove</target>
        </trans-unit>
        <trans-unit id="11dfa3918fa59c9dba2c405236023985e68113d1" translate="yes" xml:space="preserve">
          <source>HashSet::replace</source>
          <target state="translated">HashSet::replace</target>
        </trans-unit>
        <trans-unit id="f3111bd9bb9284dd24b994e9c70b335390828fac" translate="yes" xml:space="preserve">
          <source>HashSet::reserve</source>
          <target state="translated">HashSet::reserve</target>
        </trans-unit>
        <trans-unit id="ce64d74e2bc22c15cfa1eaba2edb312838993eda" translate="yes" xml:space="preserve">
          <source>HashSet::retain</source>
          <target state="translated">HashSet::retain</target>
        </trans-unit>
        <trans-unit id="029a9cdc9ae9ee65ed460a0ec02d113e093964b2" translate="yes" xml:space="preserve">
          <source>HashSet::shrink_to</source>
          <target state="translated">HashSet::shrink_to</target>
        </trans-unit>
        <trans-unit id="3aba29e196a563c0a26e6c5d67e4388b6713cebf" translate="yes" xml:space="preserve">
          <source>HashSet::shrink_to_fit</source>
          <target state="translated">HashSet::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="137d5ee967421f3423450e1436080f3b38640647" translate="yes" xml:space="preserve">
          <source>HashSet::sub</source>
          <target state="translated">HashSet::sub</target>
        </trans-unit>
        <trans-unit id="39cf21ce1dee41e9b1e7cb0c554d9ccf20702455" translate="yes" xml:space="preserve">
          <source>HashSet::symmetric_difference</source>
          <target state="translated">HashSet::symmetric_difference</target>
        </trans-unit>
        <trans-unit id="b78b12fa7d65d7ed557c2e12c743c86bcbc88775" translate="yes" xml:space="preserve">
          <source>HashSet::take</source>
          <target state="translated">HashSet::take</target>
        </trans-unit>
        <trans-unit id="93138236c5609c2dee4b1e913e9fcc9e3e9fdf44" translate="yes" xml:space="preserve">
          <source>HashSet::to_owned</source>
          <target state="translated">HashSet::to_owned</target>
        </trans-unit>
        <trans-unit id="96f13425b733a2e08673b87dffc523aee111609b" translate="yes" xml:space="preserve">
          <source>HashSet::try_from</source>
          <target state="translated">HashSet::try_from</target>
        </trans-unit>
        <trans-unit id="85d076b1561829592d046d057f0210cf9a4ff355" translate="yes" xml:space="preserve">
          <source>HashSet::try_into</source>
          <target state="translated">HashSet::try_into</target>
        </trans-unit>
        <trans-unit id="a9c0b3c82611415705e046ee581719e01be9eecc" translate="yes" xml:space="preserve">
          <source>HashSet::try_reserve</source>
          <target state="translated">HashSet::try_reserve</target>
        </trans-unit>
        <trans-unit id="105a18b817256119cb17af97da897c56eba29e40" translate="yes" xml:space="preserve">
          <source>HashSet::type_id</source>
          <target state="translated">HashSet::type_id</target>
        </trans-unit>
        <trans-unit id="685fa7682d344986ee2f2ae55086a7531364bc35" translate="yes" xml:space="preserve">
          <source>HashSet::union</source>
          <target state="translated">HashSet::union</target>
        </trans-unit>
        <trans-unit id="c3204331b41dcd6ae424437b8e36081a10f0c506" translate="yes" xml:space="preserve">
          <source>HashSet::with_capacity</source>
          <target state="translated">HashSet::with_capacity</target>
        </trans-unit>
        <trans-unit id="6bb25440ddefbed0a8db0d432f23f0ca38d089d8" translate="yes" xml:space="preserve">
          <source>HashSet::with_capacity_and_hasher</source>
          <target state="translated">HashSet::with_capacity_and_hasher</target>
        </trans-unit>
        <trans-unit id="550d3800dfa4eb2bdb493d733dabf4b1ffabf984" translate="yes" xml:space="preserve">
          <source>HashSet::with_hasher</source>
          <target state="translated">HashSet::with_hasher</target>
        </trans-unit>
        <trans-unit id="fc0f48d98ae0d2092a247d5cee9ccdb867d1d001" translate="yes" xml:space="preserve">
          <source>Hasher</source>
          <target state="translated">Hasher</target>
        </trans-unit>
        <trans-unit id="e9a193bcbf138ba881c64b5b1a29eba015da6009" translate="yes" xml:space="preserve">
          <source>Hasher::finish</source>
          <target state="translated">Hasher::finish</target>
        </trans-unit>
        <trans-unit id="2b1c79f133b4285e8cbe820d3b0dbaa110a81b6c" translate="yes" xml:space="preserve">
          <source>Hasher::write</source>
          <target state="translated">Hasher::write</target>
        </trans-unit>
        <trans-unit id="aea45433ea07ad24495217b0093e410e9770ebb6" translate="yes" xml:space="preserve">
          <source>Hasher::write_i128</source>
          <target state="translated">Hasher::write_i128</target>
        </trans-unit>
        <trans-unit id="f97466e2fd5ec3a618a0b518a5dd39118b1b15e0" translate="yes" xml:space="preserve">
          <source>Hasher::write_i16</source>
          <target state="translated">Hasher::write_i16</target>
        </trans-unit>
        <trans-unit id="10de8ddcd6d092ee0ae793c2f146d59545948d06" translate="yes" xml:space="preserve">
          <source>Hasher::write_i32</source>
          <target state="translated">Hasher::write_i32</target>
        </trans-unit>
        <trans-unit id="fa2e80124215b4059a687baa99ddde7e8adc899d" translate="yes" xml:space="preserve">
          <source>Hasher::write_i64</source>
          <target state="translated">Hasher::write_i64</target>
        </trans-unit>
        <trans-unit id="fe5b0947dfe31def847c17d1e11ec3d408a4124c" translate="yes" xml:space="preserve">
          <source>Hasher::write_i8</source>
          <target state="translated">Hasher::write_i8</target>
        </trans-unit>
        <trans-unit id="53164f3f3dd297fb85292187a041f87e1d16695e" translate="yes" xml:space="preserve">
          <source>Hasher::write_isize</source>
          <target state="translated">Hasher::write_isize</target>
        </trans-unit>
        <trans-unit id="e477fb5169da10ce163639bd122b949d5314f471" translate="yes" xml:space="preserve">
          <source>Hasher::write_u128</source>
          <target state="translated">Hasher::write_u128</target>
        </trans-unit>
        <trans-unit id="05c5de3720de3f253e1541c3b244cb58450b4be2" translate="yes" xml:space="preserve">
          <source>Hasher::write_u16</source>
          <target state="translated">Hasher::write_u16</target>
        </trans-unit>
        <trans-unit id="1cf90d27fda48a3335fb25c8aa60e25c50bc3767" translate="yes" xml:space="preserve">
          <source>Hasher::write_u32</source>
          <target state="translated">Hasher::write_u32</target>
        </trans-unit>
        <trans-unit id="420bdb25cc27d8fac4c5399c4359ccee510eacbd" translate="yes" xml:space="preserve">
          <source>Hasher::write_u64</source>
          <target state="translated">Hasher::write_u64</target>
        </trans-unit>
        <trans-unit id="82a921392efa7001c790d5b80024db7be281f9cb" translate="yes" xml:space="preserve">
          <source>Hasher::write_u8</source>
          <target state="translated">Hasher::write_u8</target>
        </trans-unit>
        <trans-unit id="d1a0408c2f79ae7c9f420468772c41716a5e1a04" translate="yes" xml:space="preserve">
          <source>Hasher::write_usize</source>
          <target state="translated">Hasher::write_usize</target>
        </trans-unit>
        <trans-unit id="461629db972167b8f4c1f8c130db9885c4944304" translate="yes" xml:space="preserve">
          <source>Hashing Functions</source>
          <target state="translated">해싱 함수</target>
        </trans-unit>
        <trans-unit id="baf48f49b04e2fe65712d113e9024e4c5a00d1bc" translate="yes" xml:space="preserve">
          <source>Haskell (GHC): typeclasses, type families</source>
          <target state="translated">Haskell (GHC) : 타입 클래스, 타입 패밀리</target>
        </trans-unit>
        <trans-unit id="0561de3a6257f6d36364146fd6581f1315dd2333" translate="yes" xml:space="preserve">
          <source>Having &lt;code&gt;common&lt;/code&gt; appear in the test results with &lt;code&gt;running 0 tests&lt;/code&gt; displayed for it is not what we wanted. We just wanted to share some code with the other integration test files.</source>
          <target state="translated">갖는 &lt;code&gt;common&lt;/code&gt; 테스트 결과에 표시 &lt;code&gt;running 0 tests&lt;/code&gt; 이를 표시하는 것은 우리가 원하는 것이 아니다. 우리는 다른 통합 테스트 파일과 일부 코드를 공유하고 싶었습니다.</target>
        </trans-unit>
        <trans-unit id="11f087b15a668ce62e66a014863909ef9d55cd94" translate="yes" xml:space="preserve">
          <source>Having Multiple Owners of Mutable Data by Combining &lt;code id=&quot;having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt&quot;&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt&quot;&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 와 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 를 결합하여 여러 개의 가변 데이터 소유자 보유</target>
        </trans-unit>
        <trans-unit id="6b19652c5d2b3e9984ece4975d1cc403d1ab4a0a" translate="yes" xml:space="preserve">
          <source>Having one mutable reference (&lt;code&gt;&amp;amp;mut T&lt;/code&gt;) to the object (also known as &lt;strong&gt;mutability&lt;/strong&gt;).</source>
          <target state="translated">객체에 대한 하나의 변경 가능한 참조 ( &lt;code&gt;&amp;amp;mut T&lt;/code&gt; )가 있습니다 ( &lt;strong&gt;mutability&lt;/strong&gt; 라고도 함 ).</target>
        </trans-unit>
        <trans-unit id="08041929016b8a695800e1c093d6357eb61d9428" translate="yes" xml:space="preserve">
          <source>Having several immutable references (&lt;code&gt;&amp;amp;T&lt;/code&gt;) to the object (also known as &lt;strong&gt;aliasing&lt;/strong&gt;).</source>
          <target state="translated">오브젝트에 대한 여러 불변의 참조 ( &lt;code&gt;&amp;amp;T&lt;/code&gt; )가 있습니다 ( &lt;strong&gt;앨리어싱&lt;/strong&gt; 이라고도 함 ).</target>
        </trans-unit>
        <trans-unit id="89c8fa1c2c4d0b146e76f764a7dc959cbfc87737" translate="yes" xml:space="preserve">
          <source>Having to worry about the index in &lt;code&gt;word&lt;/code&gt; getting out of sync with the data in &lt;code&gt;s&lt;/code&gt; is tedious and error prone! Managing these indices is even more brittle if we write a &lt;code&gt;second_word&lt;/code&gt; function. Its signature would have to look like this:</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 의 데이터와 동기화되지 않는 &lt;code&gt;word&lt;/code&gt; 의 색인에 대해 걱정 해야하는 것은 지루하고 오류가 발생하기 쉽습니다! &lt;code&gt;second_word&lt;/code&gt; 함수를 작성하면 이러한 인덱스를 관리하는 것이 훨씬 더 취약 합니다. 서명은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="257810d9a0b57b3d3f2b083b4e88460a9ed6c299" translate="yes" xml:space="preserve">
          <source>Hello, Cargo!</source>
          <target state="translated">안녕하세요,화물!</target>
        </trans-unit>
        <trans-unit id="0a0a9f2a6772942557ab5355d76af442f8f65e01" translate="yes" xml:space="preserve">
          <source>Hello, World!</source>
          <target state="translated">안녕, 월드!</target>
        </trans-unit>
        <trans-unit id="d9d2b1e388fd73fa4e7cc0203db99342ed1255e1" translate="yes" xml:space="preserve">
          <source>Helper struct for safely printing paths with &lt;a href=&quot;../macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt; 경로를 안전하게 인쇄하기위한 도우미 구조 ! 와 &lt;code&gt;{}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c4fbb21f9ed5068758832ea51d122515fab93c7" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;X&lt;/code&gt; will have already been specified the discriminant 0 by the time &lt;code&gt;Y&lt;/code&gt; is encountered, so a conflict occurs.</source>
          <target state="translated">여기서 &lt;code&gt;X&lt;/code&gt; 는 &lt;code&gt;Y&lt;/code&gt; 가 발생할 때까지 판별 자 0으로 이미 지정 되었으므로 충돌이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b3f6e00f3163ec48a9acfd477c8ec87919fc2c8c" translate="yes" xml:space="preserve">
          <source>Here are a couple examples of this error:</source>
          <target state="translated">이 오류의 몇 가지 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8ff34494ac843686469f6f02e338741820201079" translate="yes" xml:space="preserve">
          <source>Here are examples of the comparison operators being used.</source>
          <target state="translated">사용중인 비교 연산자의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bca374bff5c3dac21037ded7599cd1fe12249f7d" translate="yes" xml:space="preserve">
          <source>Here are examples of these operators being used.</source>
          <target state="translated">사용되는 이러한 연산자의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="07272e166a1d2e40b130f94ad3a0aa3df774ca3b" translate="yes" xml:space="preserve">
          <source>Here are similar examples but now for LAST.</source>
          <target state="translated">다음은 비슷한 예이지만 지금은 마지막입니다.</target>
        </trans-unit>
        <trans-unit id="0a1abd5c7569db9404cdcd75f1cc6cdc0c6dca93" translate="yes" xml:space="preserve">
          <source>Here are some example of these operators</source>
          <target state="translated">다음은 이러한 연산자의 예입니다</target>
        </trans-unit>
        <trans-unit id="4684b015ded3bc0731a2cef8198e5596403f6b07" translate="yes" xml:space="preserve">
          <source>Here are some examples of elision errors:</source>
          <target state="translated">다음은 제거 오류의 예입니다.</target>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="translated">여기 몇 가지 예가 있어요.</target>
        </trans-unit>
        <trans-unit id="51de71d79af0f5165810b64b8288dc0e2f418033" translate="yes" xml:space="preserve">
          <source>Here are some examples: a reference to an &lt;code&gt;i32&lt;/code&gt; without a lifetime parameter, a reference to an &lt;code&gt;i32&lt;/code&gt; that has a lifetime parameter named &lt;code&gt;'a&lt;/code&gt;, and a mutable reference to an &lt;code&gt;i32&lt;/code&gt; that also has the lifetime &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">참조 : 몇 가지 예 &lt;code&gt;i32&lt;/code&gt; 수명 파라미터 제공되지 않을 경우에 참조 &lt;code&gt;i32&lt;/code&gt; 이라는 수명 파라미터 가진다 &lt;code&gt;'a&lt;/code&gt; 내지 An 및 가변 기준 &lt;code&gt;i32&lt;/code&gt; 또한 수명이 있는지 &lt;code&gt;'a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20d5c7a1de98768721ba1e4861f1afaf92322548" translate="yes" xml:space="preserve">
          <source>Here are some of the things this module contains:</source>
          <target state="translated">이 모듈에 포함 된 것들 중 일부는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2a92602de41a70e7040e9f2a4fb9598c573570c2" translate="yes" xml:space="preserve">
          <source>Here are some simple examples of where you'll run into this error:</source>
          <target state="translated">이 오류가 발생하는 간단한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5b8f26110eb51a4ab181ea0b693d59c927775bab" translate="yes" xml:space="preserve">
          <source>Here are the topics we&amp;rsquo;ll cover in this chapter:</source>
          <target state="translated">이 장에서 다룰 주제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bc16616a997e1c54d6f12cfc92a13207a77b9160" translate="yes" xml:space="preserve">
          <source>Here are the two primary ways in which &lt;code&gt;entry&lt;/code&gt; is used. First, a simple example where the logic performed on the values is trivial.</source>
          <target state="translated">다음은 &lt;code&gt;entry&lt;/code&gt; 이 사용 되는 두 가지 기본 방법입니다 . 첫째, 값에 대해 수행되는 논리가 사소한 예입니다.</target>
        </trans-unit>
        <trans-unit id="8d3de595e318046b488878fdfd592e24474accd6" translate="yes" xml:space="preserve">
          <source>Here executing &lt;code&gt;x = None&lt;/code&gt; would modify the value being matched and require us to go &quot;back in time&quot; to the &lt;code&gt;None&lt;/code&gt; arm.</source>
          <target state="translated">다음은 실행 &lt;code&gt;x = None&lt;/code&gt; 일치되는 값을 수정하지 않으며이 &quot;시간을 거슬러&quot;가서 우리를 필요 &lt;code&gt;None&lt;/code&gt; 팔을.</target>
        </trans-unit>
        <trans-unit id="87b503ee6f76be5b3f344961161f897b4c2e8a33" translate="yes" xml:space="preserve">
          <source>Here is a basic example:</source>
          <target state="translated">기본 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="40d986bccf61bb4616c6b2d5e45138cb6f650868" translate="yes" xml:space="preserve">
          <source>Here is a recap of the reasons to choose &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;, or &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; , &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 를 선택해야하는 이유를 요약하면 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="2fd70c4f72651018616cf4fae80bda013db29aef" translate="yes" xml:space="preserve">
          <source>Here is a variation on the previous example, showing that no further elements are taken from &lt;code&gt;iter&lt;/code&gt; after the first &lt;code&gt;Err&lt;/code&gt;.</source>
          <target state="translated">다음은 이전 예제의 변형으로 , 첫 번째 &lt;code&gt;Err&lt;/code&gt; 이후의 &lt;code&gt;iter&lt;/code&gt; 에서 더 이상 요소를 가져 오지 않음을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="f2d33e000bef3fae0bc1e18459c72a6974d4c8ec" translate="yes" xml:space="preserve">
          <source>Here is a variation on the previous example, showing that no further elements are taken from &lt;code&gt;iter&lt;/code&gt; after the first &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">다음 예제 는 첫 번째 &lt;code&gt;None&lt;/code&gt; 이후 &lt;code&gt;iter&lt;/code&gt; 에서 더 이상 요소를 가져 오지 않음을 보여주는 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="64fa9f151e952c55124309eb57d3e7e04cdb27ce" translate="yes" xml:space="preserve">
          <source>Here is an example of the same &lt;code&gt;Point&lt;/code&gt; struct implementing the &lt;code&gt;Add&lt;/code&gt; trait using generics.</source>
          <target state="translated">다음은 제네릭을 사용하여 &lt;code&gt;Add&lt;/code&gt; 특성을 구현하는 동일한 &lt;code&gt;Point&lt;/code&gt; 구조체 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="f4eeb15c7a7b93e1eb2dc6a8750be5fd94bbc8b2" translate="yes" xml:space="preserve">
          <source>Here is an example of the same &lt;code&gt;Point&lt;/code&gt; struct implementing the &lt;code&gt;Sub&lt;/code&gt; trait using generics.</source>
          <target state="translated">다음은 제네릭을 사용하여 &lt;code&gt;Sub&lt;/code&gt; 특성을 구현하는 동일한 &lt;code&gt;Point&lt;/code&gt; 구조체 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="e2a455b6868a34c4c660661290fdc27380049549" translate="yes" xml:space="preserve">
          <source>Here is an example response that uses HTTP version 1.1, has a status code of 200, an OK reason phrase, no headers, and no body:</source>
          <target state="translated">다음은 HTTP 버전 1.1을 사용하고 상태 코드 200, 확인 이유 문구, 헤더 및 본문이없는 응답 예입니다.</target>
        </trans-unit>
        <trans-unit id="f7c4ae388ef10758f9c1ee112d05af3dedb5a8c1" translate="yes" xml:space="preserve">
          <source>Here is an example that demonstrates the error:</source>
          <target state="translated">다음은 오류를 보여주는 예입니다.</target>
        </trans-unit>
        <trans-unit id="eb168180e8af601284ef4a6f97cd122e9d48a93f" translate="yes" xml:space="preserve">
          <source>Here is an example using ranges of &lt;code&gt;char&lt;/code&gt; values:</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 값의 범위를 사용하는 예는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="2190806deeaf3eb0d2b99ddd8ded1889adb9e2dc" translate="yes" xml:space="preserve">
          <source>Here is an example where the third lifetime elision rule applies:</source>
          <target state="translated">다음은 세 번째 수명 제거 규칙이 적용되는 예입니다.</target>
        </trans-unit>
        <trans-unit id="8be714949bc61ee0dfb58dd8b6d077f499efa300" translate="yes" xml:space="preserve">
          <source>Here is an example which increments every integer in a vector, checking for overflow:</source>
          <target state="translated">다음은 벡터의 모든 정수를 증가시키고 오버플로를 확인하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="b8d2a1ec18a168b45aede187d064b1d87d98387f" translate="yes" xml:space="preserve">
          <source>Here is an example which increments every integer in a vector. We use the checked variant of &lt;code&gt;add&lt;/code&gt; that returns &lt;code&gt;None&lt;/code&gt; when the calculation would result in an overflow.</source>
          <target state="translated">다음은 벡터의 모든 정수를 증가시키는 예입니다. 계산에 오버플로가 발생하면 &lt;code&gt;None&lt;/code&gt; 을 반환 하는 &lt;code&gt;add&lt;/code&gt; 의 확인 된 변형을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="669e450458761957293db53fc0e8c919ba0f5a7a" translate="yes" xml:space="preserve">
          <source>Here is an unsafe function named &lt;code&gt;dangerous&lt;/code&gt; that doesn&amp;rsquo;t do anything in its body:</source>
          <target state="translated">다음은 본문에서 아무 것도하지 않는 &lt;code&gt;dangerous&lt;/code&gt; 라는 안전하지 않은 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="d9606eca0f59289409929077841f751f72b656be" translate="yes" xml:space="preserve">
          <source>Here is another example that tries to subtract one from another list of integers, this time checking for underflow:</source>
          <target state="translated">다음은 언더 플로를 검사하는 다른 정수 목록에서 하나를 빼려는 또 다른 예입니다.</target>
        </trans-unit>
        <trans-unit id="967e8f702b29651ccfd3eff162bdd1236f185e1b" translate="yes" xml:space="preserve">
          <source>Here is how you would define and use a &lt;code&gt;calculate_length&lt;/code&gt; function that has a reference to an object as a parameter instead of taking ownership of the value:</source>
          <target state="translated">다음은 값의 소유권을 가져 오는 대신 객체에 대한 참조가 있는 &lt;code&gt;calculate_length&lt;/code&gt; 함수를 정의하고 사용하는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="853cb0e889b6e921d08e41239a16f75171fa3cf1" translate="yes" xml:space="preserve">
          <source>Here is that same example again, with some explanatory comments:</source>
          <target state="translated">다음은 몇 가지 설명 주석이 포함 된 동일한 예입니다.</target>
        </trans-unit>
        <trans-unit id="183c940df02f2ac1c7e0b320aa5e4607c7fd14f0" translate="yes" xml:space="preserve">
          <source>Here is the error we get when we compile this code:</source>
          <target state="translated">이 코드를 컴파일 할 때 발생하는 오류는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="20e589c1d30a718b69866f0e87eb12f8b53bb806" translate="yes" xml:space="preserve">
          <source>Here is the plan to build the web server:</source>
          <target state="translated">웹 서버 구축 계획은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c50f83c6cf619c1c5fb8951e5f26cafe1c807151" translate="yes" xml:space="preserve">
          <source>Here is the previous example again, with the correct order:</source>
          <target state="translated">올바른 순서로 이전 예를 다시 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="c6b6ce6ac56caf7839b74c32ae618de3ed902bea" translate="yes" xml:space="preserve">
          <source>Here is this algorithm described in pseudocode.</source>
          <target state="translated">여기이 알고리즘은 의사 코드로 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ade7d43a649a8f35a37c5c4df50d404ac17d264" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;Apple&lt;/code&gt; variant has two fields, and should be matched against like so:</source>
          <target state="translated">여기 &lt;code&gt;Apple&lt;/code&gt; 변형에는 두 개의 필드가 있으며 다음과 같이 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="77492962523ab1872ec0db64f3e31206c8e37741" translate="yes" xml:space="preserve">
          <source>Here we create &lt;code&gt;Status::Value&lt;/code&gt; instances using each &lt;code&gt;u32&lt;/code&gt; value in the range that &lt;code&gt;map&lt;/code&gt; is called on by using the initializer function of &lt;code&gt;Status::Value&lt;/code&gt;. Some people prefer this style, and some people prefer to use closures. They compile to the same code, so use whichever style is clearer to you.</source>
          <target state="translated">여기에서 우리는 만들 &lt;code&gt;Status::Value&lt;/code&gt; 각 사용 인스턴스 &lt;code&gt;u32&lt;/code&gt; 하는 범위에서 값 &lt;code&gt;map&lt;/code&gt; 의 초기화 기능을 사용하여 호출됩니다 &lt;code&gt;Status::Value&lt;/code&gt; . 어떤 사람들은이 스타일을 선호하고 어떤 사람들은 클로저를 사용하는 것을 선호합니다. 그것들은 같은 코드로 컴파일되므로, 당신에게 더 명확한 스타일을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ab78b83024b9be055a5f592dcee8323d7eae1a44" translate="yes" xml:space="preserve">
          <source>Here we get a warning about not using the variable &lt;code&gt;y&lt;/code&gt;, but we don&amp;rsquo;t get a warning about not using the variable preceded by the underscore.</source>
          <target state="translated">여기에 변수 &lt;code&gt;y&lt;/code&gt; 를 사용 하지 않는다는 경고가 표시되지만 밑줄 앞에 변수를 사용하지 않는다는 경고는 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e6c5079a1585dd8c6aa581475ab7d948402fef68" translate="yes" xml:space="preserve">
          <source>Here we have an iterator &lt;code&gt;results&lt;/code&gt; over &lt;code&gt;Result&amp;lt;bool, ()&amp;gt;&lt;/code&gt;. Hence, &lt;code&gt;results.collect()&lt;/code&gt; can return any type implementing &lt;code&gt;FromIterator&amp;lt;Result&amp;lt;bool, ()&amp;gt;&amp;gt;&lt;/code&gt;. On the other hand, the &lt;code&gt;?&lt;/code&gt; operator can accept any type implementing &lt;code&gt;Try&lt;/code&gt;.</source>
          <target state="translated">여기 에 &lt;code&gt;Result&amp;lt;bool, ()&amp;gt;&lt;/code&gt; 대한 반복자 &lt;code&gt;results&lt;/code&gt; 가 있습니다 . 따라서 &lt;code&gt;results.collect()&lt;/code&gt; 는 &lt;code&gt;FromIterator&amp;lt;Result&amp;lt;bool, ()&amp;gt;&amp;gt;&lt;/code&gt; 구현하는 모든 유형을 리턴 할 수 있습니다 . 반면에 &lt;code&gt;?&lt;/code&gt; 연산자는 &lt;code&gt;Try&lt;/code&gt; 를 구현하는 모든 유형을 허용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cb5b6fe6a43391cbaff0a797a1749d4999cf682c" translate="yes" xml:space="preserve">
          <source>Here we have declared a string literal, also known as a string slice. String literals have a static lifetime, which means the string &lt;code&gt;hello_world&lt;/code&gt; is guaranteed to be valid for the duration of the entire program. We can explicitly specify &lt;code&gt;hello_world&lt;/code&gt;'s lifetime as well:</source>
          <target state="translated">여기에서는 문자열 슬라이스라고도하는 문자열 리터럴을 선언했습니다. 문자열 리터럴은 정적 수명을 가지므로 &lt;code&gt;hello_world&lt;/code&gt; 문자열 은 전체 프로그램 기간 동안 유효합니다. &lt;code&gt;hello_world&lt;/code&gt; 의 수명도 명시 적으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6a5e69251fb02d97a8da5895df070cb741e7a14" translate="yes" xml:space="preserve">
          <source>Here we see that &lt;code&gt;flatten()&lt;/code&gt; does not perform a &quot;deep&quot; flatten. Instead, only one level of nesting is removed. That is, if you &lt;code&gt;flatten()&lt;/code&gt; a three-dimensional array the result will be two-dimensional and not one-dimensional. To get a one-dimensional structure, you have to &lt;code&gt;flatten()&lt;/code&gt; again.</source>
          <target state="translated">여기서 &lt;code&gt;flatten()&lt;/code&gt; 은 &quot;deep&quot;flatten을 수행하지 않습니다. 대신, 한 수준의 중첩 만 제거됩니다. 즉, 3 차원 배열 을 &lt;code&gt;flatten()&lt;/code&gt; 하면 결과는 2 차원이며 1 차원이 아닙니다. 1 차원 구조를 얻으려면 다시 &lt;code&gt;flatten()&lt;/code&gt; 해야합니다.</target>
        </trans-unit>
        <trans-unit id="72ccb25410f6e8d0ac401f0e115875ab4db2e28c" translate="yes" xml:space="preserve">
          <source>Here we tell Rust that when the result is &lt;code&gt;Ok&lt;/code&gt;, return the inner &lt;code&gt;file&lt;/code&gt; value out of the &lt;code&gt;Ok&lt;/code&gt; variant, and we then assign that file handle value to the variable &lt;code&gt;f&lt;/code&gt;. After the &lt;code&gt;match&lt;/code&gt;, we can use the file handle for reading or writing.</source>
          <target state="translated">여기서 Rust에 결과가 &lt;code&gt;Ok&lt;/code&gt; 일 때 &lt;code&gt;Ok&lt;/code&gt; 변형 에서 내부 &lt;code&gt;file&lt;/code&gt; 값을 반환 한 다음 해당 파일 핸들 값을 변수 &lt;code&gt;f&lt;/code&gt; 에 지정 합니다. &lt;code&gt;match&lt;/code&gt; 후에 파일 핸들을 사용하여 읽거나 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80012795e5bb9f7fa353370133e88ca78ecd6ec8" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;re calling the &lt;code&gt;hello&lt;/code&gt; function with the argument &lt;code&gt;&amp;amp;m&lt;/code&gt;, which is a reference to a &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; value. Because we implemented the &lt;code&gt;Deref&lt;/code&gt; trait on &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; in Listing 15-10, Rust can turn &lt;code&gt;&amp;amp;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; into &lt;code&gt;&amp;amp;String&lt;/code&gt; by calling &lt;code&gt;deref&lt;/code&gt;. The standard library provides an implementation of &lt;code&gt;Deref&lt;/code&gt; on &lt;code&gt;String&lt;/code&gt; that returns a string slice, and this is in the API documentation for &lt;code&gt;Deref&lt;/code&gt;. Rust calls &lt;code&gt;deref&lt;/code&gt; again to turn the &lt;code&gt;&amp;amp;String&lt;/code&gt; into &lt;code&gt;&amp;amp;str&lt;/code&gt;, which matches the &lt;code&gt;hello&lt;/code&gt; function&amp;rsquo;s definition.</source>
          <target state="translated">여기서는 &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; 값에 대한 참조 인 &lt;code&gt;&amp;amp;m&lt;/code&gt; 인수와 함께 &lt;code&gt;hello&lt;/code&gt; 함수를 호출합니다 . Listing 15-10의 &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; 에 &lt;code&gt;Deref&lt;/code&gt; 특성을 구현했기 때문에 Rust는 &lt;code&gt;deref&lt;/code&gt; 를 호출 하여 &lt;code&gt;&amp;amp;String&lt;/code&gt; &lt;code&gt;&amp;amp;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; 을 &amp;amp; String 으로 바꿀 수있다 . 표준 라이브러리의 구현 제공 &lt;code&gt;Deref&lt;/code&gt; 에 &lt;code&gt;String&lt;/code&gt; 문자열 조각을 반환하고이에 대한 API 문서에 &lt;code&gt;Deref&lt;/code&gt; . 녹 호출 &lt;code&gt;deref&lt;/code&gt; 차례 다시 &lt;code&gt;&amp;amp;String&lt;/code&gt; 로 &lt;code&gt;&amp;amp;str&lt;/code&gt; 성냥하는 &lt;code&gt;hello&lt;/code&gt; 함수의 정의.</target>
        </trans-unit>
        <trans-unit id="466e3552c39fe3a92c2d4c054173a56d883575cc" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;ve defined a struct and named it &lt;code&gt;Rectangle&lt;/code&gt;. Inside the curly brackets, we defined the fields as &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt;, both of which have type &lt;code&gt;u32&lt;/code&gt;. Then in &lt;code&gt;main&lt;/code&gt;, we created a particular instance of &lt;code&gt;Rectangle&lt;/code&gt; that has a width of 30 and a height of 50.</source>
          <target state="translated">여기에 구조체를 정의하고 이름을 &lt;code&gt;Rectangle&lt;/code&gt; 로 지정했습니다 . 중괄호 안에 필드를 &lt;code&gt;width&lt;/code&gt; 및 &lt;code&gt;height&lt;/code&gt; 로 정의했으며 둘 다 유형이 &lt;code&gt;u32&lt;/code&gt; 입니다. 그런 다음 &lt;code&gt;main&lt;/code&gt; 에서 너비가 30이고 높이가 50 인 &lt;code&gt;Rectangle&lt;/code&gt; 의 특정 인스턴스를 만들었습니다 .</target>
        </trans-unit>
        <trans-unit id="817f9efff3a295f34cca74e6a4819cd4626be8b2" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a simple comment:</source>
          <target state="translated">간단한 의견은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="539936e83a01369f912b07f9a46070e22c533c8a" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a small programming problem: write a function that takes a string and returns the first word it finds in that string. If the function doesn&amp;rsquo;t find a space in the string, the whole string must be one word, so the entire string should be returned.</source>
          <target state="translated">다음은 작은 프로그래밍 문제입니다. 문자열을 가져 와서 해당 문자열에서 찾은 첫 번째 단어를 반환하는 함수를 작성하십시오. 함수가 문자열에서 공백을 찾지 못하면 전체 문자열이 한 단어 여야하므로 전체 문자열을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="7f3b7e87f399f43770545cc13990ab6cc8dd6c83" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a constant declaration where the constant&amp;rsquo;s name is &lt;code&gt;MAX_POINTS&lt;/code&gt; and its value is set to 100,000. (Rust&amp;rsquo;s naming convention for constants is to use all uppercase with underscores between words, and underscores can be inserted in numeric literals to improve readability):</source>
          <target state="translated">다음은 상수 이름이 &lt;code&gt;MAX_POINTS&lt;/code&gt; 이고 값이 100,000으로 설정된 상수 선언의 예입니다 . 상수에 대한 Rust의 명명 규칙은 단어 사이에 밑줄이있는 모든 대문자를 사용하는 것이며 가독성을 높이기 위해 밑줄을 숫자 리터럴로 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e399b9c3b58dba78ca66c0c45518f8657e4f783" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of how the development and release process works: let&amp;rsquo;s assume that the Rust team is working on the release of Rust 1.5. That release happened in December of 2015, but it will provide us with realistic version numbers. A new feature is added to Rust: a new commit lands on the &lt;code&gt;master&lt;/code&gt; branch. Each night, a new nightly version of Rust is produced. Every day is a release day, and these releases are created by our release infrastructure automatically. So as time passes, our releases look like this, once a night:</source>
          <target state="translated">다음은 개발 및 릴리스 프로세스의 작동 방식에 대한 예입니다. Rust 팀이 Rust 1.5 릴리스를 작업 중이라고 가정 해 봅시다. 이 릴리스는 2015 년 12 월에 발생했지만 실제 버전 번호를 제공 할 것입니다. Rust에 새로운 기능이 추가되었습니다 : 새로운 커밋이 &lt;code&gt;master&lt;/code&gt; 브랜치 . 매일 밤 Rust의 새로운 야간 버전이 생성됩니다. 매일은 릴리스 일이며 이러한 릴리스는 릴리스 인프라에서 자동으로 생성됩니다. 시간이 지남에 따라 릴리스는 다음과 같이 밤에 한 번 나타납니다.</target>
        </trans-unit>
        <trans-unit id="dd2c057fc04f01fae93788be5795a76d18a55fe9" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of the &lt;code&gt;clone&lt;/code&gt; method in action:</source>
          <target state="translated">여기에 예가 있습니다 &lt;code&gt;clone&lt;/code&gt; 방법의 실제 .</target>
        </trans-unit>
        <trans-unit id="01162de636320bfb3aac73f8ee64a4ca8f8b3f36" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example that shows floating-point numbers in action:</source>
          <target state="translated">다음은 실제 부동 소수점 숫자를 보여주는 예입니다.</target>
        </trans-unit>
        <trans-unit id="b756692957834549ddc1e80ed843e1c05120a8e7" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how it works: when you call a method with &lt;code&gt;object.something()&lt;/code&gt;, Rust automatically adds in &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;&amp;amp;mut&lt;/code&gt;, or &lt;code&gt;*&lt;/code&gt; so &lt;code&gt;object&lt;/code&gt; matches the signature of the method. In other words, the following are the same:</source>
          <target state="translated">작동 방식은 다음과 같습니다. &lt;code&gt;object.something()&lt;/code&gt; 으로 메소드를 호출하면 Rust가 자동으로 &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;&amp;amp;mut&lt;/code&gt; 또는 &lt;code&gt;*&lt;/code&gt; so &lt;code&gt;object&lt;/code&gt; 는 메서드의 서명과 일치합니다. 다시 말해 다음은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="bbfc2aa9173a426f43e60848a0174bac37b702fe" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the compiler error:</source>
          <target state="translated">컴파일러 오류는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7ba4bf6763c0003ca703ce8f7299229f35cbda9a" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the error:</source>
          <target state="translated">오류는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="916eb038e9d9b0f05a6d2dec1a88d2849aef616b" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the full code for reference:</source>
          <target state="translated">다음은 참조를위한 전체 코드입니다.</target>
        </trans-unit>
        <trans-unit id="815ea8397604a0309cd918e79463e69ce092e31e" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the resulting compilation error:</source>
          <target state="translated">결과 컴파일 오류는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0221cef214e9504c84ca1c9204c7ee34f36785b0" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the scenario we&amp;rsquo;ll test: we&amp;rsquo;ll create a library that tracks a value against a maximum value and sends messages based on how close to the maximum value the current value is. This library could be used to keep track of a user&amp;rsquo;s quota for the number of API calls they&amp;rsquo;re allowed to make, for example.</source>
          <target state="translated">테스트 할 시나리오는 다음과 같습니다. 최대 값에 대해 값을 추적하고 현재 값이 최대 값에 얼마나 가까운 지에 따라 메시지를 보내는 라이브러리를 만듭니다. 이 라이브러리는 예를 들어 사용자가 허용 한 API 호출 수에 대한 사용자 할당량을 추적하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d29162aaec04ffdbb58bf12aa825c48d5666dd6" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s what the countdown would look like using a &lt;code&gt;for&lt;/code&gt; loop and another method we&amp;rsquo;ve not yet talked about, &lt;code&gt;rev&lt;/code&gt;, to reverse the range:</source>
          <target state="translated">다음은 &lt;code&gt;for&lt;/code&gt; 루프와 범위를 뒤집기 위해 아직 이야기하지 않은 또 다른 방법 인 &lt;code&gt;rev&lt;/code&gt; 를 사용하여 카운트 다운을하는 모습입니다 .</target>
        </trans-unit>
        <trans-unit id="d3bb7457d5469dff80002a12eb2b6537482105f8" translate="yes" xml:space="preserve">
          <source>Here's an example of a program which exemplifies the three cases outlined above:</source>
          <target state="translated">다음은 위에서 설명한 세 가지 사례를 보여주는 프로그램의 예입니다.</target>
        </trans-unit>
        <trans-unit id="8f4d98d4c0a8996c7a0518c8611a7d795ca5c7fb" translate="yes" xml:space="preserve">
          <source>Here's an example of a struct that has this problem:</source>
          <target state="translated">이 문제가있는 구조체의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="38707ff87f1d5297f1ba77c802780450fd07e571" translate="yes" xml:space="preserve">
          <source>Here's an example of how a collection might make use of &lt;code&gt;needs_drop&lt;/code&gt;:</source>
          <target state="translated">다음은 컬렉션이 &lt;code&gt;needs_drop&lt;/code&gt; 을 사용하는 방법에 대한 예입니다 .</target>
        </trans-unit>
        <trans-unit id="6b4165c575ea75c83f4faaec0830fc7c979ed3b7" translate="yes" xml:space="preserve">
          <source>Here's an example of some in-progress code. We have a trait &lt;code&gt;Foo&lt;/code&gt;:</source>
          <target state="translated">다음은 진행중인 코드의 예입니다. &lt;code&gt;Foo&lt;/code&gt; 라는 특성이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f441ef09b0ea3aff9bb06d2bb0621baad2037ee9" translate="yes" xml:space="preserve">
          <source>Here's an example of this error:</source>
          <target state="translated">이 오류의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9ee387ebc736d2db87034681c5da1089287c37d" translate="yes" xml:space="preserve">
          <source>Here's an example where you want to sort people by height only, disregarding &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;id&lt;/code&gt; 와 &lt;code&gt;name&lt;/code&gt; 을 무시하고 키만 기준으로 사람을 정렬하려는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="51e85e4e8113fb3e1f07e1727e78d73f5f0043e6" translate="yes" xml:space="preserve">
          <source>Here's an example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="52eb68597e531c606446cb2bd5c17dccc5e369fd" translate="yes" xml:space="preserve">
          <source>Here's another example that will fail:</source>
          <target state="translated">실패 할 또 다른 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cb729976f0325910542c6a857a3758115eda6f00" translate="yes" xml:space="preserve">
          <source>Here's one example of this error:</source>
          <target state="translated">이 오류의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4919036b58ea25eeee47e5a5bbcefebd8f5446fd" translate="yes" xml:space="preserve">
          <source>Here's the same example, but with &lt;a href=&quot;#method.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">다음은 같은 예제이지만 &lt;a href=&quot;#method.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; 이 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3adc3a6ab8335913c0c03d10dd56aa70986ccdbc" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;&amp;amp;mut fancy&lt;/code&gt; is mutable, but &lt;code&gt;&amp;amp;(&amp;amp;mut fancy)&lt;/code&gt; is not. Creating an immutable reference to a value borrows it immutably. There can be multiple references of type &lt;code&gt;&amp;amp;(&amp;amp;mut T)&lt;/code&gt; that point to the same value, so they must be immutable to prevent multiple mutable references to the same value.</source>
          <target state="translated">여기서 &lt;code&gt;&amp;amp;mut fancy&lt;/code&gt; 는 변경할 수 있지만 &lt;code&gt;&amp;amp;(&amp;amp;mut fancy)&lt;/code&gt; 는 변경할 수 없습니다. 값에 대한 불변의 참조를 작성하면 불변으로 차용됩니다. 동일한 값을 가리키는 &lt;code&gt;&amp;amp;(&amp;amp;mut T)&lt;/code&gt; 유형에 대한 여러 참조가있을 수 있으므로 동일한 값에 대한 여러 변경 가능한 참조를 방지하려면 변경 불가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="ae9903eacaebe1bfadd3100f5d35d502f8c50279" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Grams2&lt;/code&gt; is a not equivalent to &lt;code&gt;Grams&lt;/code&gt; -- the former transparently wraps a (non-transparent) struct containing a single float, while &lt;code&gt;Grams&lt;/code&gt; is a transparent wrapper around a float. This can make a difference for the ABI.</source>
          <target state="translated">여기에서 &lt;code&gt;Grams2&lt;/code&gt; 는 &lt;code&gt;Grams&lt;/code&gt; 와 동등하지 않습니다 . 전자는 단일 float를 포함하는 (투명하지 않은) 구조체를 투명하게 감싸고, &lt;code&gt;Grams&lt;/code&gt; 는 float 주위의 투명한 래퍼입니다. 이것은 ABI를 변화시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc33c2bfb4ee352bfa1ddf50a16705d99896734f" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;demo&lt;/code&gt; tries to borrow the string data held within its argument &lt;code&gt;s&lt;/code&gt; and then return that borrow. However, &lt;code&gt;S&lt;/code&gt; is declared as implementing &lt;code&gt;Drop&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;demo&lt;/code&gt; 는 인수 &lt;code&gt;s&lt;/code&gt; 내에 보유 된 문자열 데이터 를 빌린 다음 빌린 값을 반환 하려고 시도합니다 . 그러나 &lt;code&gt;S&lt;/code&gt; 는 &lt;code&gt;Drop&lt;/code&gt; 구현으로 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="d42c53fe9a57832c14dca225308392012e6122d1" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;fancy_num&lt;/code&gt; is borrowed by &lt;code&gt;fancy_ref&lt;/code&gt; and so cannot be moved into the closure &lt;code&gt;x&lt;/code&gt;. There is no way to move a value into a closure while it is borrowed, as that would invalidate the borrow.</source>
          <target state="translated">여기서 &lt;code&gt;fancy_num&lt;/code&gt; 은 fancy_ref 에 의해 빌려 &lt;code&gt;fancy_ref&lt;/code&gt; 클로저 &lt;code&gt;x&lt;/code&gt; 로 이동할 수 없습니다 . 차용을 무효화 할 수 있기 때문에 차용 한 값을 클로저로 옮길 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="125b181d950db988334868421de4a90fab534474" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;first&lt;/code&gt; has type &lt;code&gt;A&lt;/code&gt;, referring to &lt;code&gt;to_vec&lt;/code&gt;'s &lt;code&gt;A&lt;/code&gt; type parameter; and &lt;code&gt;rest&lt;/code&gt; has type &lt;code&gt;Vec&amp;lt;A&amp;gt;&lt;/code&gt;, a vector with element type &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">여기에서는 &lt;code&gt;first&lt;/code&gt; &lt;code&gt;to_vec&lt;/code&gt; 의 &lt;code&gt;A&lt;/code&gt; 유형 매개 변수를 참조하여 유형 &lt;code&gt;A&lt;/code&gt; 를 갖습니다 . 그리고 &lt;code&gt;rest&lt;/code&gt; 유형이 &lt;code&gt;Vec&amp;lt;A&amp;gt;&lt;/code&gt; , 요소 유형과 벡터 &lt;code&gt;A&lt;/code&gt; 는 .</target>
        </trans-unit>
        <trans-unit id="df5a4c41f4c7ffd30b5c670cb408c350a9013b94" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;i32&lt;/code&gt; is the type of each element. After the semicolon, the number &lt;code&gt;5&lt;/code&gt; indicates the element contains five items.</source>
          <target state="translated">여기서 &lt;code&gt;i32&lt;/code&gt; 는 각 요소의 유형입니다. 세미콜론 다음에 숫자 &lt;code&gt;5&lt;/code&gt; 는 요소에 5 개의 항목이 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1068c0619a68aa52935f67e1c63f9f6ef1422570" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;s&lt;/code&gt; will be a &lt;code&gt;&amp;amp;str&lt;/code&gt; that contains the first 4 bytes of the string. Earlier, we mentioned that each of these characters was 2 bytes, which means &lt;code&gt;s&lt;/code&gt; will be &lt;code&gt;Зд&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;s&lt;/code&gt; 는 문자열의 처음 4 바이트를 포함 하는 &lt;code&gt;&amp;amp;str&lt;/code&gt; 입니다. 앞에서 우리는이 문자들 각각이 2 바이트라고 언급했는데, 이는 &lt;code&gt;s&lt;/code&gt; 가 &lt;code&gt;Зд&lt;/code&gt; 일 것 입니다.</target>
        </trans-unit>
        <trans-unit id="75b866d15247e93817fc99798a57f0ab2950be56" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;score&lt;/code&gt; will have the value that&amp;rsquo;s associated with the Blue team, and the result will be &lt;code&gt;Some(&amp;amp;10)&lt;/code&gt;. The result is wrapped in &lt;code&gt;Some&lt;/code&gt; because &lt;code&gt;get&lt;/code&gt; returns an &lt;code&gt;Option&amp;lt;&amp;amp;V&amp;gt;&lt;/code&gt;; if there&amp;rsquo;s no value for that key in the hash map, &lt;code&gt;get&lt;/code&gt; will return &lt;code&gt;None&lt;/code&gt;. The program will need to handle the &lt;code&gt;Option&lt;/code&gt; in one of the ways that we covered in Chapter 6.</source>
          <target state="translated">여기서 &lt;code&gt;score&lt;/code&gt; 는 Blue 팀과 관련된 값을 가지며 결과는 &lt;code&gt;Some(&amp;amp;10)&lt;/code&gt; 입니다. &lt;code&gt;get&lt;/code&gt; 은 &lt;code&gt;Option&amp;lt;&amp;amp;V&amp;gt;&lt;/code&gt; 반환 하므로 결과는 &lt;code&gt;Some&lt;/code&gt; 로 래핑됩니다 . 해시 맵에 해당 키에 대한 값이 없으면 &lt;code&gt;get&lt;/code&gt; 은 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다. 프로그램은 6 장에서 다룬 방법 중 하나로 &lt;code&gt;Option&lt;/code&gt; 을 처리해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8bd05f4a31a90f3b6414a315addec81f40aa24ad" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;x&lt;/code&gt; has the lifetime &lt;code&gt;'b&lt;/code&gt;, which in this case is larger than &lt;code&gt;'a&lt;/code&gt;. This means &lt;code&gt;r&lt;/code&gt; can reference &lt;code&gt;x&lt;/code&gt; because Rust knows that the reference in &lt;code&gt;r&lt;/code&gt; will always be valid while &lt;code&gt;x&lt;/code&gt; is valid.</source>
          <target state="translated">여기서 &lt;code&gt;x&lt;/code&gt; 의 수명은 &lt;code&gt;'b&lt;/code&gt; ' 이며,이 경우 &lt;code&gt;'a&lt;/code&gt; ' 보다 큽니다 . 이 방법은 &lt;code&gt;r&lt;/code&gt; 에 참조 할 수 &lt;code&gt;x&lt;/code&gt; 녹에서 참조 것을 알고 있기 때문에 &lt;code&gt;r&lt;/code&gt; 은 동안 항상 유효합니다 &lt;code&gt;x&lt;/code&gt; 는 유효합니다.</target>
        </trans-unit>
        <trans-unit id="e10c369ea788e27a00713fc168a85308c89bf1c9" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;y&lt;/code&gt; is bound by-value in one case and by-reference in the other.</source>
          <target state="translated">여기서 &lt;code&gt;y&lt;/code&gt; 는 하나의 경우 값에 의해 바인딩되고 다른 경우에는 참조에 의해 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="7d5607669abd7c37655a986b9a8d2fca66769741" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;y&lt;/code&gt; is bound to the contents of the &lt;code&gt;Some&lt;/code&gt; and can be used within the block corresponding to the match arm. However, in case &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, we have not specified what &lt;code&gt;y&lt;/code&gt; is, and the block will use a nonexistent variable.</source>
          <target state="translated">여기서, &lt;code&gt;y&lt;/code&gt; 는 &lt;code&gt;Some&lt;/code&gt; 의 내용에 묶여 있고 매치 암에 해당하는 블록 내에서 사용될 수있다. 그러나 &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;None&lt;/code&gt; 인 경우 &lt;code&gt;y&lt;/code&gt; 가 무엇인지 지정하지 않았 으며 블록은 존재하지 않는 변수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a792c6d2920136f42b2c0328d50b11b4b1f68c36" translate="yes" xml:space="preserve">
          <source>Here, all types implementing &lt;code&gt;Foo&lt;/code&gt; must have a method &lt;code&gt;foo&amp;lt;T&amp;gt;(x: T)&lt;/code&gt; which can take any type &lt;code&gt;T&lt;/code&gt;. However, in the &lt;code&gt;impl&lt;/code&gt; for &lt;code&gt;bool&lt;/code&gt;, we have added an extra bound that &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Copy&lt;/code&gt;, which isn't compatible with the original trait.</source>
          <target state="translated">여기에 구현 모든 유형의 &lt;code&gt;Foo&lt;/code&gt; 메소드가 있어야합니다 &lt;code&gt;foo&amp;lt;T&amp;gt;(x: T)&lt;/code&gt; 모든 종류의 걸릴 수 &lt;code&gt;T&lt;/code&gt; 를 . 그러나 &lt;code&gt;bool&lt;/code&gt; 의 &lt;code&gt;impl&lt;/code&gt; 에 추가 경계를 추가했습니다. &lt;code&gt;T&lt;/code&gt; 는 &lt;code&gt;Copy&lt;/code&gt; 인 하여 원래 특성과 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e86bf62ea38db4534581f774aebf9c330891b88f" translate="yes" xml:space="preserve">
          <source>Here, even though &lt;code&gt;x&lt;/code&gt; is not one of the parameters of &lt;code&gt;equal_to_x&lt;/code&gt;, the &lt;code&gt;equal_to_x&lt;/code&gt; closure is allowed to use the &lt;code&gt;x&lt;/code&gt; variable that&amp;rsquo;s defined in the same scope that &lt;code&gt;equal_to_x&lt;/code&gt; is defined in.</source>
          <target state="translated">여기서, 비록 &lt;code&gt;x&lt;/code&gt; 의 파라미터 중 하나가 아닌 &lt;code&gt;equal_to_x&lt;/code&gt; 상기 &lt;code&gt;equal_to_x&lt;/code&gt; 클로져가 사용하도록 허용 &lt;code&gt;x&lt;/code&gt; 것과 동일한 범위에 정의되어 가변 &lt;code&gt;equal_to_x&lt;/code&gt; 가 정의된다.</target>
        </trans-unit>
        <trans-unit id="3efa2682153806eb1dbead68e3ef30ae590912ca" translate="yes" xml:space="preserve">
          <source>Here, even though we&amp;rsquo;ve specified a lifetime parameter &lt;code&gt;'a&lt;/code&gt; for the return type, this implementation will fail to compile because the return value lifetime is not related to the lifetime of the parameters at all. Here is the error message we get:</source>
          <target state="translated">여기서는 평생 매개 변수를 지정했지만 &lt;code&gt;'a&lt;/code&gt; 반환 유형에 'a 를 반환 값 수명이 매개 변수의 수명과 전혀 관련이 없으므로이 구현은 컴파일에 실패합니다. 우리가 얻는 오류 메시지는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="da2b63d2db9c34aa4fad7b681faf1cae153440c5" translate="yes" xml:space="preserve">
          <source>Here, our response has a status line with status code 404 and the reason phrase &lt;code&gt;NOT FOUND&lt;/code&gt;. We&amp;rsquo;re still not returning headers, and the body of the response will be the HTML in the file &lt;em&gt;404.html&lt;/em&gt;. You&amp;rsquo;ll need to create a &lt;em&gt;404.html&lt;/em&gt; file next to &lt;em&gt;hello.html&lt;/em&gt; for the error page; again feel free to use any HTML you want or use the example HTML in Listing 20-8.</source>
          <target state="translated">여기에 응답에 상태 코드가 404 인 상태 표시 줄과 이유 구문 &lt;code&gt;NOT FOUND&lt;/code&gt; 가 있습니다. 우리는 여전히 헤더를 반환하지 않으며 응답 본문은 &lt;em&gt;404.html&lt;/em&gt; 파일의 HTML이됩니다 . &lt;em&gt;404.html&lt;/em&gt; 을 만들어야합니다&lt;em&gt;&lt;/em&gt;오류 페이지에 대해 &lt;em&gt;hello.html&lt;/em&gt; 옆에 파일 합니다. 원하는 HTML을 사용하거나 Listing 20-8의 예제 HTML을 자유롭게 사용한다.</target>
        </trans-unit>
        <trans-unit id="a2749e5eb8656bede400f4e0b8d184580a4d9adf" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;BitAndAssign&lt;/code&gt; trait is implemented for a wrapper around &lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">여기, &lt;code&gt;BitAndAssign&lt;/code&gt; 특성은 &lt;code&gt;Vec&amp;lt;bool&amp;gt;&lt;/code&gt; 주위의 래퍼에 대해 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="73314800534c2c9290a895f1b2e09cd5c74b13fa" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;nothing_is_true&lt;/code&gt; method takes the ownership of &lt;code&gt;self&lt;/code&gt;. However, &lt;code&gt;self&lt;/code&gt; cannot be moved because &lt;code&gt;.borrow()&lt;/code&gt; only provides an &lt;code&gt;&amp;amp;TheDarkKnight&lt;/code&gt;, which is a borrow of the content owned by the &lt;code&gt;RefCell&lt;/code&gt;. To fix this error, you have three choices:</source>
          <target state="translated">여기서 &lt;code&gt;nothing_is_true&lt;/code&gt; 메소드는 &lt;code&gt;self&lt;/code&gt; 의 소유권을 갖습니다 . 그러나 &lt;code&gt;.borrow()&lt;/code&gt; 는 &lt;code&gt;RefCell&lt;/code&gt; 소유의 컨텐츠를 빌린 &lt;code&gt;&amp;amp;TheDarkKnight&lt;/code&gt; 만 제공 하기 때문에 &lt;code&gt;self&lt;/code&gt; 를 이동할 수 없습니다 . 이 오류를 해결하려면 세 가지 선택 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5f1ad21d4790c6fa776cb2d79a7da13085bbb0b" translate="yes" xml:space="preserve">
          <source>Here, the code counts up through the elements in the array. It starts at index &lt;code&gt;0&lt;/code&gt;, and then loops until it reaches the final index in the array (that is, when &lt;code&gt;index &amp;lt; 5&lt;/code&gt; is no longer true). Running this code will print every element in the array:</source>
          <target state="translated">여기서 코드는 배열의 요소를 통해 계산됩니다. 인덱스 &lt;code&gt;0&lt;/code&gt; 에서 시작한 다음 배열의 최종 인덱스에 도달 할 때까지 (즉, &lt;code&gt;index &amp;lt; 5&lt;/code&gt; 가 더 이상 참이 아닌 경우) 반복됩니다 . 이 코드를 실행하면 배열의 모든 요소가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="f6e9fdb531b1a1a673e70ab403c2068ef72bf3e1" translate="yes" xml:space="preserve">
          <source>Here, the expression &lt;code&gt;&amp;amp;foo()&lt;/code&gt; is borrowing the expression &lt;code&gt;foo()&lt;/code&gt;. As &lt;code&gt;foo()&lt;/code&gt; is a call to a function, and not the name of a variable, this creates a &lt;strong&gt;temporary&lt;/strong&gt; -- that temporary stores the return value from &lt;code&gt;foo()&lt;/code&gt; so that it can be borrowed. You could imagine that &lt;code&gt;let p = bar(&amp;amp;foo());&lt;/code&gt; is equivalent to this:</source>
          <target state="translated">여기에서 &lt;code&gt;&amp;amp;foo()&lt;/code&gt; 표현식은 &lt;code&gt;foo()&lt;/code&gt; 표현식을 빌리고 있습니다. 마찬가지로 &lt;code&gt;foo()&lt;/code&gt; A A 함수 호출, 그리고 변수의 이름이며, 이는 생성 &lt;strong&gt;일시&lt;/strong&gt; - 즉 임시 저장 반환 값 &lt;code&gt;foo()&lt;/code&gt; 가 대여 할 수 있도록한다. 당신이 상상할 수있는 &lt;code&gt;let p = bar(&amp;amp;foo());&lt;/code&gt; 이것과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="408c7fbfdfe961fb58eba63dc21b905f34fe6b5c" translate="yes" xml:space="preserve">
          <source>Here, the function &lt;code&gt;eat&lt;/code&gt; takes ownership of &lt;code&gt;x&lt;/code&gt;. However, &lt;code&gt;x&lt;/code&gt; cannot be moved because the borrow to &lt;code&gt;_ref_to_val&lt;/code&gt; needs to last till the function &lt;code&gt;borrow&lt;/code&gt;. To fix that you can do a few different things:</source>
          <target state="translated">여기서 &lt;code&gt;eat&lt;/code&gt; 함수 는 &lt;code&gt;x&lt;/code&gt; 의 소유권을 갖습니다 . 그러나 &lt;code&gt;_ref_to_val&lt;/code&gt; 에 &lt;code&gt;borrow&lt;/code&gt; 함수는 차용 함수까지 지속 되어야하므로 &lt;code&gt;x&lt;/code&gt; 를 이동할 수 없습니다 . 이를 해결하기 위해 몇 가지 다른 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34b4fc7688b4cc55dbce35a5cbba7cf5aa481597" translate="yes" xml:space="preserve">
          <source>Here, the function &lt;code&gt;foo&lt;/code&gt; returns a value of type &lt;code&gt;Cell&amp;lt;&amp;amp;'x u32&amp;gt;&lt;/code&gt;, which references the lifetime &lt;code&gt;'x&lt;/code&gt;. However, the return type is declared as &lt;code&gt;impl Trait&amp;lt;'y&amp;gt;&lt;/code&gt; -- this indicates that &lt;code&gt;foo&lt;/code&gt; returns &quot;some type that implements &lt;code&gt;Trait&amp;lt;'y&amp;gt;&lt;/code&gt;&quot;, but it also indicates that the return type &lt;strong&gt;only captures data referencing the lifetime &lt;code&gt;'y&lt;/code&gt;&lt;/strong&gt;. In this case, though, we are referencing data with lifetime &lt;code&gt;'x&lt;/code&gt;, so this function is in error.</source>
          <target state="translated">여기서 &lt;code&gt;foo&lt;/code&gt; 함수 는 수명 &lt;code&gt;'x&lt;/code&gt; 를 참조하는 &lt;code&gt;Cell&amp;lt;&amp;amp;'x u32&amp;gt;&lt;/code&gt; 유형의 값을 리턴합니다 . 그러나 반환 유형은 &lt;code&gt;impl Trait&amp;lt;'y&amp;gt;&lt;/code&gt; 로 선언됩니다. 이는 &lt;code&gt;foo&lt;/code&gt; 가 &quot; &lt;code&gt;Trait&amp;lt;'y&amp;gt;&lt;/code&gt; 를 구현하는 일부 유형&quot;을 반환 하지만 반환 유형 &lt;strong&gt;은 수명 &lt;/strong&gt;&lt;strong&gt; &lt;code&gt;'y&lt;/code&gt; 를&lt;/strong&gt;&lt;strong&gt; 참조하는 데이터 만 캡처&lt;/strong&gt; 함을 나타냅니다.&lt;strong&gt;&lt;/strong&gt; . 이 경우 수명이 &lt;code&gt;'x&lt;/code&gt; 인 데이터를 참조 하므로이 기능에 오류가 있습니다.</target>
        </trans-unit>
        <trans-unit id="89055a364d466030b4b32dbb99ee9d2965691a35" translate="yes" xml:space="preserve">
          <source>Here, the loop never ends, so &lt;code&gt;!&lt;/code&gt; is the value of the expression. However, this wouldn&amp;rsquo;t be true if we included a &lt;code&gt;break&lt;/code&gt;, because the loop would terminate when it got to the &lt;code&gt;break&lt;/code&gt;.</source>
          <target state="translated">여기서 루프는 끝나지 않습니다 &lt;code&gt;!&lt;/code&gt; 식의 값입니다. 우리가 포함 된 경우,이 사실이되지 않을 것 &lt;code&gt;break&lt;/code&gt; 가 도착했을 때 루프가 종료 때문에, &lt;code&gt;break&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df47ee6ed5cabbf7215bb10c59a544458415fee2" translate="yes" xml:space="preserve">
          <source>Here, the problem is that a reference type like &lt;code&gt;&amp;amp;'a T&lt;/code&gt; is only valid if all the data in T outlives the lifetime &lt;code&gt;'a&lt;/code&gt;. But this impl as written is applicable to any lifetime &lt;code&gt;'a&lt;/code&gt; and any type &lt;code&gt;T&lt;/code&gt; -- we have no guarantee that &lt;code&gt;T&lt;/code&gt; outlives &lt;code&gt;'a&lt;/code&gt;. To fix this, you can add a where clause like &lt;code&gt;where T: 'a&lt;/code&gt;.</source>
          <target state="translated">여기서 문제는 &lt;code&gt;&amp;amp;'a T&lt;/code&gt; 와 같은 참조 유형 이 T의 모든 데이터가 수명 &lt;code&gt;'a&lt;/code&gt; 보다 오래 지속되는 경우에만 유효하다는 것 입니다. 그러나 작성된이 IMPL은 평생에 적용 할 수있다 &lt;code&gt;'a&lt;/code&gt; 어떤 타입의 &lt;code&gt;T&lt;/code&gt; - 우리는 보장이 없다는 &lt;code&gt;T&lt;/code&gt; 의 들보 다 오래 남았습니다 &lt;code&gt;'a&lt;/code&gt; . 이 문제를 해결하기 위해 &lt;code&gt;where T: 'a&lt;/code&gt; 와 같은 where 절을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="362d656c8582920eb1fa6e2f837dcd77621e2783" translate="yes" xml:space="preserve">
          <source>Here, the supertrait might have methods as follows:</source>
          <target state="translated">여기에서, 초 특성은 다음과 같은 방법을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09d377b97ceff52f388bef9d69ecd4e08de82e8e" translate="yes" xml:space="preserve">
          <source>Here, the type of &lt;code&gt;bar&lt;/code&gt; isn't known; it could be a pointer to anything. Instead, specify a type for the pointer (preferably something that makes sense for the thing you're pointing to):</source>
          <target state="translated">여기, &lt;code&gt;bar&lt;/code&gt; 의 종류 알려져 있지 않습니다. 그것은 무엇이든에 대한 포인터 일 수 있습니다. 대신 포인터의 유형을 지정하십시오 (바람직하게 가리키는 대상).</target>
        </trans-unit>
        <trans-unit id="6683d46fded95c67df0b49024b3446d80dd204a6" translate="yes" xml:space="preserve">
          <source>Here, the where clause &lt;code&gt;T: 'a&lt;/code&gt; that appears on the impl is not known to be satisfied on the struct. To make this example compile, you have to add a where-clause like &lt;code&gt;T: 'a&lt;/code&gt; to the struct definition:</source>
          <target state="translated">여기서 impl에 나타나는 where 절 &lt;code&gt;T: 'a&lt;/code&gt; 는 구조체에서 충족되는 것으로 알려져 있지 않습니다. 이 예제를 컴파일하려면 구조체 정의에 &lt;code&gt;T: 'a&lt;/code&gt; 와 같은 where-clause를 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5f5bdb12ef17925552b810b20339fc4188e58923" translate="yes" xml:space="preserve">
          <source>Here, there's no need to allocate more memory inside the loop.</source>
          <target state="translated">루프 내부에 더 많은 메모리를 할당 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="64f50e4beb0199dca819447bd86bfb2e950cfebb" translate="yes" xml:space="preserve">
          <source>Here, transmute is being used to convert the types of the fn arguments. This pattern is incorrect because, because the type of &lt;code&gt;foo&lt;/code&gt; is a function &lt;strong&gt;item&lt;/strong&gt; (&lt;code&gt;typeof(foo)&lt;/code&gt;), which is zero-sized, and the target type (&lt;code&gt;fn()&lt;/code&gt;) is a function pointer, which is not zero-sized. This pattern should be rewritten. There are a few possible ways to do this:</source>
          <target state="translated">여기서 변환은 fn 인수의 유형을 변환하는 데 사용됩니다. 이 패턴은 &lt;code&gt;foo&lt;/code&gt; 의 유형이 크기가 0 인 함수 &lt;strong&gt;항목&lt;/strong&gt; ( &lt;code&gt;typeof(foo)&lt;/code&gt; )이고 대상 유형 ( &lt;code&gt;fn()&lt;/code&gt; )이 0이 아닌 함수 포인터이기 때문에 올바르지 않습니다. 이 패턴을 다시 작성해야합니다. 이를 수행 할 수있는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="11f7e7a9427d5e270e6bb9180be033e23a1b7abb" translate="yes" xml:space="preserve">
          <source>Here, we are still borrowing &lt;code&gt;foo()&lt;/code&gt;, but as the borrow is assigned directly into a variable, the temporary will not be dropped until the end of the enclosing block. Similar rules apply when temporaries are stored into aggregate structures like a tuple or struct:</source>
          <target state="translated">여기서 우리는 여전히 &lt;code&gt;foo()&lt;/code&gt; 빌리고 있지만, 빌려 오기가 변수에 직접 할당되기 때문에 임시 블록은 둘러싸는 블록이 끝날 때까지 삭제되지 않습니다. 임시 규칙이 튜플 또는 구조체와 같은 집계 구조에 저장 될 때 유사한 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2fe93444419186b520c70f702a92a3495d890ab8" translate="yes" xml:space="preserve">
          <source>Here, we create a new variable &lt;code&gt;case_sensitive&lt;/code&gt;. To set its value, we call the &lt;code&gt;env::var&lt;/code&gt; function and pass it the name of the &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; environment variable. The &lt;code&gt;env::var&lt;/code&gt; function returns a &lt;code&gt;Result&lt;/code&gt; that will be the successful &lt;code&gt;Ok&lt;/code&gt; variant that contains the value of the environment variable if the environment variable is set. It will return the &lt;code&gt;Err&lt;/code&gt; variant if the environment variable is not set.</source>
          <target state="translated">여기에 새로운 변수 &lt;code&gt;case_sensitive&lt;/code&gt; 를 만듭니다 . 값을 설정하기 위해 &lt;code&gt;env::var&lt;/code&gt; 함수를 호출 하고 &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; 환경 변수 의 이름을 전달합니다 . &lt;code&gt;env::var&lt;/code&gt; 함수는 반환 &lt;code&gt;Result&lt;/code&gt; 성공적으로 될 것입니다 &lt;code&gt;Ok&lt;/code&gt; 환경 변수가 설정되어있는 경우 환경 변수의 값을 포함 변형. 환경 변수가 설정되지 않은 경우 &lt;code&gt;Err&lt;/code&gt; 변형 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="629de8d4fd404424f68755750d18203229995313" translate="yes" xml:space="preserve">
          <source>Here, we declare a trait using the &lt;code&gt;trait&lt;/code&gt; keyword and then the trait&amp;rsquo;s name, which is &lt;code&gt;Summary&lt;/code&gt; in this case. Inside the curly brackets, we declare the method signatures that describe the behaviors of the types that implement this trait, which in this case is &lt;code&gt;fn summarize(&amp;amp;self) -&amp;gt; String&lt;/code&gt;.</source>
          <target state="translated">여기서는 &lt;code&gt;trait&lt;/code&gt; 키워드를 사용하여 특성을 선언 한 다음 특성의 이름 ( 이 경우 &lt;code&gt;Summary&lt;/code&gt; 을 선언합니다 . 중괄호 안에이 특성을 구현하는 유형의 동작을 설명하는 메소드 시그니처를 선언합니다.이 경우 &lt;code&gt;fn summarize(&amp;amp;self) -&amp;gt; String&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d5d31c7a816695d5663a1af214bdd61a0f312631" translate="yes" xml:space="preserve">
          <source>Here, we first call &lt;code&gt;lock&lt;/code&gt; on the &lt;code&gt;receiver&lt;/code&gt; to acquire the mutex, and then we call &lt;code&gt;unwrap&lt;/code&gt; to panic on any errors. Acquiring a lock might fail if the mutex is in a &lt;em&gt;poisoned&lt;/em&gt; state, which can happen if some other thread panicked while holding the lock rather than releasing the lock. In this situation, calling &lt;code&gt;unwrap&lt;/code&gt; to have this thread panic is the correct action to take. Feel free to change this &lt;code&gt;unwrap&lt;/code&gt; to an &lt;code&gt;expect&lt;/code&gt; with an error message that is meaningful to you.</source>
          <target state="translated">먼저 &lt;code&gt;receiver&lt;/code&gt; 에서 &lt;code&gt;lock&lt;/code&gt; 을 호출 하여 뮤텍스를 얻은 다음 &lt;code&gt;unwrap&lt;/code&gt; 을 호출 하여 오류가 발생하면 패닉 상태가됩니다. 뮤텍스가 &lt;em&gt;독&lt;/em&gt; 상태 인 경우 잠금을 획득하지 못할 수 있습니다. 잠금을 해제하지 않고 잠금을 잡고있는 동안 다른 스레드가 당황한 경우 발생할 수 있습니다. 이 상황에서 &lt;code&gt;unwrap&lt;/code&gt; 을 호출 하여이 스레드 패닉이 발생하도록하는 것이 올바른 조치입니다. 의미있는 오류 메시지와 함께이 &lt;code&gt;unwrap&lt;/code&gt; 를 &lt;code&gt;expect&lt;/code&gt; 대로 변경하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="90ed3acfd08d6add91c92898299f8f082c9b0a5d" translate="yes" xml:space="preserve">
          <source>Here, we give a description of what the &lt;code&gt;add_one&lt;/code&gt; function does, start a section with the heading &lt;code&gt;Examples&lt;/code&gt;, and then provide code that demonstrates how to use the &lt;code&gt;add_one&lt;/code&gt; function. We can generate the HTML documentation from this documentation comment by running &lt;code&gt;cargo doc&lt;/code&gt;. This command runs the &lt;code&gt;rustdoc&lt;/code&gt; tool distributed with Rust and puts the generated HTML documentation in the &lt;em&gt;target/doc&lt;/em&gt; directory.</source>
          <target state="translated">여기에서는 &lt;code&gt;add_one&lt;/code&gt; 함수의 기능에 대한 설명 을 제공 하고 제목 &lt;code&gt;Examples&lt;/code&gt; 로 섹션을 시작한 다음 &lt;code&gt;add_one&lt;/code&gt; 함수 를 사용하는 방법을 보여주는 코드를 제공 합니다. &lt;code&gt;cargo doc&lt;/code&gt; 을 실행하여이 문서 주석에서 HTML 문서를 생성 할 수 있습니다 . 이 명령은 Rust와 함께 배포 된 &lt;code&gt;rustdoc&lt;/code&gt; 도구를 실행하고 생성 된 HTML 문서를 &lt;em&gt;target / doc&lt;/em&gt; 디렉토리 에 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="509084bc1cc2854ecab3677678733d63bccc2260" translate="yes" xml:space="preserve">
          <source>Here, we have a package that only contains &lt;em&gt;src/main.rs&lt;/em&gt;, meaning it only contains a binary crate named &lt;code&gt;my-project&lt;/code&gt;. If a package contains &lt;em&gt;src/main.rs&lt;/em&gt; and &lt;em&gt;src/lib.rs&lt;/em&gt;, it has two crates: a library and a binary, both with the same name as the package. A package can have multiple binary crates by placing files in the &lt;em&gt;src/bin&lt;/em&gt; directory: each file will be a separate binary crate.</source>
          <target state="translated">여기에는 &lt;em&gt;src / main.rs&lt;/em&gt; 만 포함하는 패키지가 있습니다 . 즉, &lt;code&gt;my-project&lt;/code&gt; 라는 이진 상자 만 포함합니다 . 패키지에 &lt;em&gt;src / main.rs&lt;/em&gt; 및 &lt;em&gt;src / lib.rs&lt;/em&gt; 가 포함 된 경우 패키지 와 이름이 같은 라이브러리와 바이너리라는 두 개의 상자가 있습니다. 패키지는 &lt;em&gt;src / bin&lt;/em&gt; 디렉토리에 파일을 배치하여 여러 바이너리 상자를 가질 수 있습니다 . 각 파일은 별도의 바이너리 상자입니다.</target>
        </trans-unit>
        <trans-unit id="214685b848acbf415bb3dbd9186c1466aa631aa7" translate="yes" xml:space="preserve">
          <source>Here, we have two parameters of type &lt;code&gt;TokenStream&lt;/code&gt;. The first is for the contents of the attribute: the &lt;code&gt;GET, &quot;/&quot;&lt;/code&gt; part. The second is the body of the item the attribute is attached to: in this case, &lt;code&gt;fn index() {}&lt;/code&gt; and the rest of the function&amp;rsquo;s body.</source>
          <target state="translated">여기에는 &lt;code&gt;TokenStream&lt;/code&gt; 유형의 두 매개 변수가 있습니다 . 첫 번째는 속성의 내용 인 &lt;code&gt;GET, &quot;/&quot;&lt;/code&gt; 부분입니다. 두 번째는 속성이 첨부 된 항목의 본문입니다.이 경우 &lt;code&gt;fn index() {}&lt;/code&gt; 및 나머지 함수의 본문입니다.</target>
        </trans-unit>
        <trans-unit id="9da25d2edfbc8a834054d09a3a531a79272bf467" translate="yes" xml:space="preserve">
          <source>Here, we match a tuple against a pattern. Rust compares the value &lt;code&gt;(1, 2, 3)&lt;/code&gt; to the pattern &lt;code&gt;(x, y, z)&lt;/code&gt; and sees that the value matches the pattern, so Rust binds &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; to &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt; to &lt;code&gt;z&lt;/code&gt;. You can think of this tuple pattern as nesting three individual variable patterns inside it.</source>
          <target state="translated">여기서 우리는 패턴과 튜플을 일치시킵니다. Rust는 값 &lt;code&gt;(1, 2, 3)&lt;/code&gt; 을 패턴 &lt;code&gt;(x, y, z)&lt;/code&gt; 와 비교하고 값이 패턴과 일치하는 것을 확인하므로 Rust는 &lt;code&gt;1&lt;/code&gt; 을 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; 를 &lt;code&gt;y&lt;/code&gt; , &lt;code&gt;3&lt;/code&gt; 을 &lt;code&gt;z&lt;/code&gt; 에 바인딩 합니다. 이 튜플 패턴은 그 안에 세 개의 개별 변수 패턴을 중첩시키는 것으로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3807aec2b6a72b122da57a852fc8dc8b9b746c8b" translate="yes" xml:space="preserve">
          <source>Here, we tried to move a field out of a struct of type &lt;code&gt;DropStruct&lt;/code&gt; which implements the &lt;code&gt;Drop&lt;/code&gt; trait. However, a struct cannot be dropped if one or more of its fields have been moved.</source>
          <target state="translated">여기에서는 &lt;code&gt;Drop&lt;/code&gt; 특성 을 구현하는 &lt;code&gt;DropStruct&lt;/code&gt; 유형의 구조체에서 필드를 이동하려고했습니다 . 그러나 하나 이상의 필드가 이동 된 경우 구조체를 삭제할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="182fd49127f0c327471148134a76b7aecc6837c0" translate="yes" xml:space="preserve">
          <source>Here, we try to print &lt;code&gt;val&lt;/code&gt; after we&amp;rsquo;ve sent it down the channel via &lt;code&gt;tx.send&lt;/code&gt;. Allowing this would be a bad idea: once the value has been sent to another thread, that thread could modify or drop it before we try to use the value again. Potentially, the other thread&amp;rsquo;s modifications could cause errors or unexpected results due to inconsistent or nonexistent data. However, Rust gives us an error if we try to compile the code in Listing 16-9:</source>
          <target state="translated">여기에서는 &lt;code&gt;tx.send&lt;/code&gt; 를 통해 &lt;code&gt;val&lt;/code&gt; 을 채널로 보낸 후에 val 을 인쇄하려고합니다 . 이것을 허용하는 것은 나쁜 생각입니다. 일단 값이 다른 스레드로 보내지면 값을 다시 사용하기 전에 해당 스레드가 수정하거나 삭제할 수 있습니다. 잠재적으로 다른 스레드의 수정으로 인해 데이터가 일치하지 않거나 존재하지 않아 오류가 발생하거나 예기치 않은 결과가 발생할 수 있습니다. 그러나 Listing 16-9의 코드를 컴파일하려고하면 Rust에서 오류가 발생한다.</target>
        </trans-unit>
        <trans-unit id="e6e942400049c5831b3b39dbc83c98fc061c7f27" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ll work up to a program that has one thread to generate values and send them down a channel, and another thread that will receive the values and print them out. We&amp;rsquo;ll be sending simple values between threads using a channel to illustrate the feature. Once you&amp;rsquo;re familiar with the technique, you could use channels to implement a chat system or a system where many threads perform parts of a calculation and send the parts to one thread that aggregates the results.</source>
          <target state="translated">여기서 우리는 하나의 스레드가 값을 생성하여 채널로 전송하고 다른 스레드가 값을 수신하여 인쇄하는 프로그램으로 작업합니다. 기능을 설명하기 위해 채널을 사용하여 스레드간에 간단한 값을 전송합니다. 이 기술에 익숙해지면 채널을 사용하여 많은 스레드가 계산의 일부를 수행하고 결과를 집계하는 하나의 스레드로 부품을 보내는 채팅 시스템 또는 시스템을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b30624caca04c6adde1f0c4c5c0896dda9444b6" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;re attempting to access the 100th element of our vector (which is at index 99 because indexing starts at zero), but it has only 3 elements. In this situation, Rust will panic. Using &lt;code&gt;[]&lt;/code&gt; is supposed to return an element, but if you pass an invalid index, there&amp;rsquo;s no element that Rust could return here that would be correct.</source>
          <target state="translated">여기서는 벡터의 100 번째 요소 (인덱싱이 0에서 시작하기 때문에 인덱스 99에 있음)에 액세스하려고하지만 3 개의 요소 만 있습니다. 이 상황에서 Rust는 공황 상태에 빠질 것입니다. &lt;code&gt;[]&lt;/code&gt; 를 사용 하면 요소를 반환하지만 잘못된 인덱스를 전달하면 Rust가 여기에 반환 할 수있는 요소가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5696f367dcde9c29280ed019893b8b93043b4ae3" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;re calling the &lt;code&gt;do_something&lt;/code&gt; function 100 times, but we never use the variable &lt;code&gt;i&lt;/code&gt; in the body of the &lt;code&gt;for&lt;/code&gt; loop. Rust warns us about that:</source>
          <target state="translated">여기서는 &lt;code&gt;do_something&lt;/code&gt; 함수를 100 번 호출 하지만 &lt;code&gt;for&lt;/code&gt; 루프 의 본문에서 변수 &lt;code&gt;i&lt;/code&gt; 를 사용하지 않습니다 . 녹은 우리에게 그것에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="0738694c0b9e33967ee0ed11850ca18af144e2e8" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;re creating a new instance of the &lt;code&gt;User&lt;/code&gt; struct, which has a field named &lt;code&gt;email&lt;/code&gt;. We want to set the &lt;code&gt;email&lt;/code&gt; field&amp;rsquo;s value to the value in the &lt;code&gt;email&lt;/code&gt; parameter of the &lt;code&gt;build_user&lt;/code&gt; function. Because the &lt;code&gt;email&lt;/code&gt; field and the &lt;code&gt;email&lt;/code&gt; parameter have the same name, we only need to write &lt;code&gt;email&lt;/code&gt; rather than &lt;code&gt;email: email&lt;/code&gt;.</source>
          <target state="translated">여기서는 &lt;code&gt;email&lt;/code&gt; 이라는 필드가있는 &lt;code&gt;User&lt;/code&gt; 구조체 의 새 인스턴스를 만듭니다 . &lt;code&gt;email&lt;/code&gt; 필드의 값을 &lt;code&gt;build_user&lt;/code&gt; 함수 의 &lt;code&gt;email&lt;/code&gt; 매개 변수 값 으로 설정 하려고 합니다. 때문에 &lt;code&gt;email&lt;/code&gt; 필드와 &lt;code&gt;email&lt;/code&gt; 매개 변수는 같은 이름을 가지고, 우리는 쓰기에 필요한 &lt;code&gt;email&lt;/code&gt; 이 아닌 &lt;code&gt;email: email&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2e907cc8b08cfb8b71a6716a55c4e7e4751a1f7" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ve annotated the lifetime of &lt;code&gt;r&lt;/code&gt; with &lt;code&gt;'a&lt;/code&gt; and the lifetime of &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;'b&lt;/code&gt;. As you can see, the inner &lt;code&gt;'b&lt;/code&gt; block is much smaller than the outer &lt;code&gt;'a&lt;/code&gt; lifetime block. At compile time, Rust compares the size of the two lifetimes and sees that &lt;code&gt;r&lt;/code&gt; has a lifetime of &lt;code&gt;'a&lt;/code&gt; but that it refers to memory with a lifetime of &lt;code&gt;'b&lt;/code&gt;. The program is rejected because &lt;code&gt;'b&lt;/code&gt; is shorter than &lt;code&gt;'a&lt;/code&gt;: the subject of the reference doesn&amp;rsquo;t live as long as the reference.</source>
          <target state="translated">여기, 우리가의 수명 주석 한 &lt;code&gt;r&lt;/code&gt; 함께 &lt;code&gt;'a&lt;/code&gt; 및의 수명 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;'b&lt;/code&gt; . 보시다시피, 내부 &lt;code&gt;'b&lt;/code&gt; 블록은 외부 &lt;code&gt;'a&lt;/code&gt; 평생 블록 보다 훨씬 작습니다 . 컴파일 타임에 Rust는 두 수명의 크기를 비교하여 &lt;code&gt;r&lt;/code&gt; 의 수명이 &lt;code&gt;'a&lt;/code&gt; 이지만 수명이 &lt;code&gt;'b&lt;/code&gt; 인 메모리를 나타냅니다 . 때문에이 프로그램은 거부 &lt;code&gt;'b&lt;/code&gt; 는 보다 짧은 &lt;code&gt;'a&lt;/code&gt; : 참조의 대상이 참조로하지 라이브 한 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d072835ae81d38506d756c212f27d937b407880" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ve defined a method named &lt;code&gt;x&lt;/code&gt; on &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; that returns a reference to the data in the field &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">여기, 우리가하는 방법이라는 정의한 &lt;code&gt;x&lt;/code&gt; 에 &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; 이 반환 필드의 데이터에 대한 참조 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b22056ea03c2bfc7c7131245d47003a6d2f7232e" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ve defined a struct &lt;code&gt;IpAddr&lt;/code&gt; that has two fields: a &lt;code&gt;kind&lt;/code&gt; field that is of type &lt;code&gt;IpAddrKind&lt;/code&gt; (the enum we defined previously) and an &lt;code&gt;address&lt;/code&gt; field of type &lt;code&gt;String&lt;/code&gt;. We have two instances of this struct. The first, &lt;code&gt;home&lt;/code&gt;, has the value &lt;code&gt;IpAddrKind::V4&lt;/code&gt; as its &lt;code&gt;kind&lt;/code&gt; with associated address data of &lt;code&gt;127.0.0.1&lt;/code&gt;. The second instance, &lt;code&gt;loopback&lt;/code&gt;, has the other variant of &lt;code&gt;IpAddrKind&lt;/code&gt; as its &lt;code&gt;kind&lt;/code&gt; value, &lt;code&gt;V6&lt;/code&gt;, and has address &lt;code&gt;::1&lt;/code&gt; associated with it. We&amp;rsquo;ve used a struct to bundle the &lt;code&gt;kind&lt;/code&gt; and &lt;code&gt;address&lt;/code&gt; values together, so now the variant is associated with the value.</source>
          <target state="translated">여기, 우리는 구조체 정의한 &lt;code&gt;IpAddr&lt;/code&gt; A : 두 개의 필드가 &lt;code&gt;kind&lt;/code&gt; 유형 인 필드 &lt;code&gt;IpAddrKind&lt;/code&gt; (우리가 이전에 정의 된 열거)과 &lt;code&gt;address&lt;/code&gt; 타입의 필드 &lt;code&gt;String&lt;/code&gt; . 이 구조체의 두 인스턴스가 있습니다. 첫 번째, &lt;code&gt;home&lt;/code&gt; 값이 &lt;code&gt;IpAddrKind::V4&lt;/code&gt; 그와 같은 &lt;code&gt;kind&lt;/code&gt; 관련해, 주소 데이터와 &lt;code&gt;127.0.0.1&lt;/code&gt; 을 . 두 번째 인스턴스 인 &lt;code&gt;loopback&lt;/code&gt; 은 &lt;code&gt;kind&lt;/code&gt; 값 &lt;code&gt;V6&lt;/code&gt; 으로 &lt;code&gt;IpAddrKind&lt;/code&gt; 의 다른 변형을 가지며 이와 관련된 주소 &lt;code&gt;::1&lt;/code&gt; 을 갖 습니다. 우리는 구조체를 사용하여 &lt;code&gt;kind&lt;/code&gt; 와 &lt;code&gt;address&lt;/code&gt; 값이 함께 있으므로 이제 변형이 값과 연관됩니다.</target>
        </trans-unit>
        <trans-unit id="046091a3f10b4e94cc5b7d93ba3518dfd24f4c0f" translate="yes" xml:space="preserve">
          <source>Here, we're saying that the implementation exists on Wrapper only when the wrapped type &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Clone&lt;/code&gt;. The &lt;code&gt;where&lt;/code&gt; clause is important because some types will not implement &lt;code&gt;Clone&lt;/code&gt;, and thus will not get this method.</source>
          <target state="translated">여기서는 래핑 된 유형 &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;Clone&lt;/code&gt; 을 구현할 때만 구현이 래퍼에 존재한다고 말합니다 . &lt;code&gt;where&lt;/code&gt; 일부 유형의 구현하지 않기 때문에 절은 중요 &lt;code&gt;Clone&lt;/code&gt; 이 방법을받지 않습니다 따라서합니다.</target>
        </trans-unit>
        <trans-unit id="2eb18b6c522d039c3c0dcd7089256c0ad6492059" translate="yes" xml:space="preserve">
          <source>Hex</source>
          <target state="translated">Hex</target>
        </trans-unit>
        <trans-unit id="91ed5d7ea6cd895e371f61ed45ccc686b068fc10" translate="yes" xml:space="preserve">
          <source>Hex integer</source>
          <target state="translated">16 진 정수</target>
        </trans-unit>
        <trans-unit id="df212c2ac8dde3b394685d24542d906c68321356" translate="yes" xml:space="preserve">
          <source>Higher-level synchronization objects</source>
          <target state="translated">더 높은 수준의 동기화 개체</target>
        </trans-unit>
        <trans-unit id="7319d8cc88397a63e7ae82683fed6023e2ba482c" translate="yes" xml:space="preserve">
          <source>Higher-ranked lifetime bounds</source>
          <target state="translated">더 높은 수명주기</target>
        </trans-unit>
        <trans-unit id="699f2601254a23df8fa1d5fed485a0da27f47873" translate="yes" xml:space="preserve">
          <source>Higher-ranked lifetimes may also be specified just before the trait, the only difference is the scope of the lifetime parameter, which extends only to the end of the following trait instead of the whole bound. This function is equivalent to the last one.</source>
          <target state="translated">특성 직전에 더 높은 수명을 지정할 수도 있지만, 유일한 차이는 전체 매개 변수가 아닌 다음 특성의 끝까지 만 연장되는 수명 매개 변수의 범위입니다. 이 기능은 마지막 기능과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="33df4c2b13cbd6c2495bdbed3c2c401ea9db0b73" translate="yes" xml:space="preserve">
          <source>Higher-ranked trait bounds</source>
          <target state="translated">더 높은 특성의 한계</target>
        </trans-unit>
        <trans-unit id="02d9e95b138a4fba666ec5899da0c73598dfb07a" translate="yes" xml:space="preserve">
          <source>Hints to compiler that affects how code should be emitted or optimized.</source>
          <target state="translated">코드 생성 또는 최적화 방법에 영향을주는 컴파일러 힌트.</target>
        </trans-unit>
        <trans-unit id="8fa3a5e1e29277a4a2b8f85784650b518cec2c19" translate="yes" xml:space="preserve">
          <source>Hints to the compiler that branch condition is likely to be false. Returns the value passed to it.</source>
          <target state="translated">분기 조건이 거짓 일 가능성이 있음을 컴파일러에 알립니다. 전달 된 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="97a557b0407c848d7b5a674a63e1f75673a72a22" translate="yes" xml:space="preserve">
          <source>Hints to the compiler that branch condition is likely to be true. Returns the value passed to it.</source>
          <target state="translated">분기 조건이 참일 가능성이 있음을 컴파일러에 알립니다. 전달 된 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="80fd9958e4052dae4a04ec25478352520d67b4b8" translate="yes" xml:space="preserve">
          <source>Hooray! Rust 1.5 is done! However, we&amp;rsquo;ve forgotten one thing: because the six weeks have gone by, we also need a new beta of the &lt;em&gt;next&lt;/em&gt; version of Rust, 1.6. So after &lt;code&gt;stable&lt;/code&gt; branches off of &lt;code&gt;beta&lt;/code&gt;, the next version of &lt;code&gt;beta&lt;/code&gt; branches off of &lt;code&gt;nightly&lt;/code&gt; again:</source>
          <target state="translated">만세! 녹 1.5가 완료되었습니다! 그러나 6 주가 지났기 때문에 &lt;em&gt;다음&lt;/em&gt; 버전의 Rust, 1.6 의 새로운 베타 버전도 필요합니다 . 따라서 &lt;code&gt;beta&lt;/code&gt; 에서 &lt;code&gt;stable&lt;/code&gt; 브랜치가 나간 후 다음 버전의 &lt;code&gt;beta&lt;/code&gt; 브랜치가 &lt;code&gt;nightly&lt;/code&gt; 다시 나옵니다 .</target>
        </trans-unit>
        <trans-unit id="a341da978b3cbbea425da4874e79958a3be6b854" translate="yes" xml:space="preserve">
          <source>How Deref Coercion Interacts with Mutability</source>
          <target state="translated">Deref 강제 변환이 돌연변이와 상호 작용하는 방법</target>
        </trans-unit>
        <trans-unit id="d344cc5f79b7b6e913f964dbbc4e02bc173d4e92" translate="yes" xml:space="preserve">
          <source>How can I compare two different types?</source>
          <target state="translated">두 가지 유형을 어떻게 비교할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="b9691dd477ecb76d1a6f3d5bbee24f86998a66d9" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Clone&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;Clone&lt;/code&gt; 어떻게 구현할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="a983251965c63473a1e84135e053268152b20692" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Copy&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;Copy&lt;/code&gt; 어떻게 구현할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="90084b4cc636cc9404dd416f2e580ffcac6958d2" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Default&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;Default&lt;/code&gt; 를 어떻게 구현할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="d8e36d59adc904734a7c5575517b6fe0eeceec60" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Eq&lt;/code&gt;?</source>
          <target state="translated">어떻게 &lt;code&gt;Eq&lt;/code&gt; 를 구현할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="abe50871479611eca84afd8dcffaec7414f4b665" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Ord&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;Ord&lt;/code&gt; 를 어떻게 구현할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="a86f0c480a53af07a5339e4a6426e55601cb46dc" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;PartialEq&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;PartialEq&lt;/code&gt; 를 어떻게 구현할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="a00e532c303bae49fb14eef74bc7c06484efea04" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;PartialOrd&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;PartialOrd&lt;/code&gt; 를 어떻게 구현할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="8bcb70d690260ea744efd091583de3413f03f2d0" translate="yes" xml:space="preserve">
          <source>How can we define some default values? You can use &lt;code&gt;Default&lt;/code&gt;:</source>
          <target state="translated">기본값을 어떻게 정의 할 수 있습니까? 당신은 &lt;code&gt;Default&lt;/code&gt; 을 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ac97bbda97cfacdb06a7fbecfd828bfbc649940c" translate="yes" xml:space="preserve">
          <source>How do we know &lt;code&gt;File::open&lt;/code&gt; returns a &lt;code&gt;Result&lt;/code&gt;? We could look at the &lt;a href=&quot;../std/index&quot;&gt;standard library API documentation&lt;/a&gt;, or we could ask the compiler! If we give &lt;code&gt;f&lt;/code&gt; a type annotation that we know is &lt;em&gt;not&lt;/em&gt; the return type of the function and then try to compile the code, the compiler will tell us that the types don&amp;rsquo;t match. The error message will then tell us what the type of &lt;code&gt;f&lt;/code&gt;&lt;em&gt;is&lt;/em&gt;. Let&amp;rsquo;s try it! We know that the return type of &lt;code&gt;File::open&lt;/code&gt; isn&amp;rsquo;t of type &lt;code&gt;u32&lt;/code&gt;, so let&amp;rsquo;s change the &lt;code&gt;let f&lt;/code&gt; statement to this:</source>
          <target state="translated">&lt;code&gt;File::open&lt;/code&gt; 이 &lt;code&gt;Result&lt;/code&gt; 반환 한다는 것을 어떻게 알 수 있습니까? 우리는 볼 수 있었다 &lt;a href=&quot;../std/index&quot;&gt;표준 라이브러리 API 문서&lt;/a&gt; , 또는 우리는 컴파일러를 요청할 수 있습니다! &lt;code&gt;f&lt;/code&gt; 가 함수의 반환 유형 이 &lt;em&gt;아니라는&lt;/em&gt; 타입 주석을 제공 한 다음 코드를 컴파일하려고하면 컴파일러는 유형이 일치하지 않는다고 알려줍니다. 오류 메시지는 다음의 종류 무엇을 우리에게 말할 것이다 &lt;code&gt;f&lt;/code&gt; 는&lt;em&gt;것입니다&lt;/em&gt; . 해 봅시다! &lt;code&gt;File::open&lt;/code&gt; 의 반환 유형이 &lt;code&gt;u32&lt;/code&gt; 유형이 아니므로 &lt;code&gt;let f&lt;/code&gt; 문을 다음과 같이 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="c77df57666e7d061d1c5eeb6d1b1b4663f41398a" translate="yes" xml:space="preserve">
          <source>How to Use This Book</source>
          <target state="translated">이 책을 사용하는 방법</target>
        </trans-unit>
        <trans-unit id="9264c72068f4a42ab4bf1cb16708fbe650c704ec" translate="yes" xml:space="preserve">
          <source>How to Write Tests</source>
          <target state="translated">시험을 쓰는 방법</target>
        </trans-unit>
        <trans-unit id="fc0a5ea77505e42cd0dd485ee502c0a345de0fc4" translate="yes" xml:space="preserve">
          <source>How to Write a Custom &lt;code id=&quot;how-to-write-a-custom-derive-macro&quot;&gt;derive&lt;/code&gt; Macro</source>
          <target state="translated">사용자 지정 &lt;code id=&quot;how-to-write-a-custom-derive-macro&quot;&gt;derive&lt;/code&gt; 매크로 를 작성하는 방법</target>
        </trans-unit>
        <trans-unit id="ad4a0038f92fbf9afa07ab6d269a6a337b56f053" translate="yes" xml:space="preserve">
          <source>How to combine the sub-expressions' values to obtain the value of the expression</source>
          <target state="translated">하위 표현식의 값을 결합하여 표현식의 값을 얻는 방법</target>
        </trans-unit>
        <trans-unit id="9a65f179439d735746c8cd2892082ebe3669f2c2" translate="yes" xml:space="preserve">
          <source>How to create threads to run multiple pieces of code at the same time</source>
          <target state="translated">동시에 여러 코드 조각을 실행하는 스레드를 만드는 방법</target>
        </trans-unit>
        <trans-unit id="62c635e88978649a0009198984dfd524bc6937d1" translate="yes" xml:space="preserve">
          <source>How to read this documentation</source>
          <target state="translated">이 문서를 읽는 방법</target>
        </trans-unit>
        <trans-unit id="2ef34f8c5ce17d8eb29baa4d5f6535815ba4013f" translate="yes" xml:space="preserve">
          <source>How to use these two features to improve the I/O project in Chapter 12</source>
          <target state="translated">12 장에서이 두 기능을 사용하여 I / O 프로젝트를 개선하는 방법</target>
        </trans-unit>
        <trans-unit id="f5abcbd8d5f910274d31d405f70ebd71158dda69" translate="yes" xml:space="preserve">
          <source>However be careful: if you try to access an index which isn't in the &lt;code&gt;Vec&lt;/code&gt;, your software will panic! You cannot do this:</source>
          <target state="translated">그러나 &lt;code&gt;Vec&lt;/code&gt; 에 없는 인덱스에 액세스하려고하면 소프트웨어가 패닉 상태가됩니다! 너는 이것을 못해:</target>
        </trans-unit>
        <trans-unit id="9a3761438ee9135873d2d6c4d19984a1561781e6" translate="yes" xml:space="preserve">
          <source>However be cautious: this method expects &lt;code&gt;self&lt;/code&gt; to be mutable, which is generally not the case when using a &lt;code&gt;RefCell&lt;/code&gt;. Take a look at the &lt;a href=&quot;#method.borrow_mut&quot;&gt;&lt;code&gt;borrow_mut&lt;/code&gt;&lt;/a&gt; method instead if &lt;code&gt;self&lt;/code&gt; isn't mutable.</source>
          <target state="translated">그러나주의해야합니다.이 방법은 &lt;code&gt;self&lt;/code&gt; 가 변경 가능할 것으로 예상합니다. 일반적으로 &lt;code&gt;RefCell&lt;/code&gt; 을 사용할 때는 그렇지 않습니다 . &lt;code&gt;self&lt;/code&gt; 가 변경 불가능한 경우, 대신 &lt;a href=&quot;#method.borrow_mut&quot;&gt; &lt;code&gt;borrow_mut&lt;/code&gt; &lt;/a&gt; 메소드를 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="98f7e0f867227ba5004f997a2d43f7281873ef09" translate="yes" xml:space="preserve">
          <source>However it remains possible to implement the others separately for types which do not have a total order. For example, for floating point numbers, &lt;code&gt;NaN &amp;lt; 0 == false&lt;/code&gt; and &lt;code&gt;NaN &amp;gt;= 0 == false&lt;/code&gt; (cf. IEEE 754-2008 section 5.11).</source>
          <target state="translated">그러나 전체 주문이없는 유형에 대해서는 다른 것을 별도로 구현할 수 있습니다. 예를 들어 부동 소수점 숫자의 경우 &lt;code&gt;NaN &amp;lt; 0 == false&lt;/code&gt; 및 &lt;code&gt;NaN &amp;gt;= 0 == false&lt;/code&gt; (IEEE 754-2008 섹션 5.11 참조).</target>
        </trans-unit>
        <trans-unit id="06b5f47175aeebdf26128c567eba8d39893966c4" translate="yes" xml:space="preserve">
          <source>However programmers will usually prefer to use &lt;a href=&quot;../sync/mpsc/index&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt;s, &lt;a href=&quot;../sync/struct.condvar&quot;&gt;&lt;code&gt;Condvar&lt;/code&gt;&lt;/a&gt;s, &lt;a href=&quot;../sync/struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt;es or &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; for their synchronization routines, as they avoid thinking about thread scheduling.</source>
          <target state="translated">그러나 프로그래머는 일반적으로 스레드 스케줄링에 대해 생각하지 않기 때문에 &lt;a href=&quot;../sync/mpsc/index&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../sync/struct.condvar&quot;&gt; &lt;code&gt;Condvar&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../sync/struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt; es 또는 동기화 루틴에 &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt; 을 선호합니다 .</target>
        </trans-unit>
        <trans-unit id="99de4c47e704419c664802a54254a42292d00132" translate="yes" xml:space="preserve">
          <source>However remember that a type &lt;em&gt;containing&lt;/em&gt; a &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; is not necessarily the same layout; Rust does not in general guarantee that the fields of a &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; have the same order as a &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt; even if &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; have the same size and alignment. Furthermore because any bit value is valid for a &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; the compiler can't apply non-zero/niche-filling optimizations, potentially resulting in a larger size:</source>
          <target state="translated">그러나 유형 기억 &lt;em&gt;함유 &lt;/em&gt; &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 반드시 동일한 레이아웃 아니다; Rust는 일반적으로 &lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;U&lt;/code&gt; 의 크기와 정렬이 동일 하더라도 &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; 의 필드가 &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt; 와 동일한 순서를 보장하지 않습니다 . 또한 비트 값이 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; 유효하기 때문에 컴파일러는 0이 아닌 / 틈새 채우기 최적화를 적용 할 수 없으므로 더 큰 크기가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbb72443619bbca435164ca1a76cab29482ce889" translate="yes" xml:space="preserve">
          <source>However there is one case where &lt;code&gt;!&lt;/code&gt; syntax can be used before &lt;code&gt;!&lt;/code&gt; is stabilized as a full-fleged type: in the position of a function&amp;rsquo;s return type. Specifically, it is possible implementations for two different function pointer types:</source>
          <target state="translated">그러나 한 가지 경우가 있습니다 &lt;code&gt;!&lt;/code&gt; 구문은 전에 사용할 수 있습니다 &lt;code&gt;!&lt;/code&gt; 함수의 반환 유형 위치에서 전체 유형으로 안정화됩니다. 특히 두 가지 함수 포인터 유형에 대한 구현이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="d670e0e16c2745ec16c6eaa903327038d8c0e422" translate="yes" xml:space="preserve">
          <source>However there is one caveat: prior to the 2008 version of IEEE-754, how to interpret the NaN signaling bit wasn't actually specified. Most platforms (notably x86 and ARM) picked the interpretation that was ultimately standardized in 2008, but some didn't (notably MIPS). As a result, all signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.</source>
          <target state="translated">그러나 IEEE-754의 2008 버전 이전에는 NaN 신호 비트를 해석하는 방법이 실제로 지정되지 않았다는 한 가지 경고가 있습니다. 대부분의 플랫폼 (특히 x86 및 ARM)은 2008 년에 궁극적으로 표준화 된 해석을 선택했지만 일부는 그렇지 않았습니다 (특히 MIPS). 결과적으로 MIPS의 모든 신호 NaN은 x86의 조용한 NaN이며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="0351e6925d735478389ca7fa9374b4cd22a63b09" translate="yes" xml:space="preserve">
          <source>However, &lt;a href=&quot;struct.pathbuf#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; is best used for dynamic situations. This is a better way to do this when you know all of the components ahead of time:</source>
          <target state="translated">그러나 &lt;a href=&quot;struct.pathbuf#method.push&quot;&gt; &lt;code&gt;push&lt;/code&gt; &lt;/a&gt; 는 동적 상황에 가장 적합합니다. 이것은 모든 구성 요소를 미리 알고있을 때이를 수행하는 더 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="9e9143c027c4bd572f82aee5fcf41df94d158757" translate="yes" xml:space="preserve">
          <source>However, a better solution would be using fully explicit naming of type and trait:</source>
          <target state="translated">그러나 더 나은 해결책은 유형과 특성을 완전히 명시 적으로 명명하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ee975de6dd0772652ad342b32f8653a59db9e61f" translate="yes" xml:space="preserve">
          <source>However, a single argument with a trailing comma will still not be treated as a tuple, following the convention of ignoring trailing commas in macro invocations. You can use a 1-tuple directly if you need one:</source>
          <target state="translated">그러나 매크로 호출에서 후행 쉼표를 무시하는 규칙에 따라 후행 쉼표가있는 단일 인수는 여전히 튜플로 취급되지 않습니다. 필요한 경우 1 개의 튜플을 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b007fe5fc274829b5c0d27c599f3eea8f9ba132a" translate="yes" xml:space="preserve">
          <source>However, associated functions that are part of traits don&amp;rsquo;t have a &lt;code&gt;self&lt;/code&gt; parameter. When two types in the same scope implement that trait, Rust can&amp;rsquo;t figure out which type you mean unless you use &lt;em&gt;fully qualified syntax&lt;/em&gt;. For example, the &lt;code&gt;Animal&lt;/code&gt; trait in Listing 19-19 has the associated function &lt;code&gt;baby_name&lt;/code&gt;, the implementation of &lt;code&gt;Animal&lt;/code&gt; for the struct &lt;code&gt;Dog&lt;/code&gt;, and the associated function &lt;code&gt;baby_name&lt;/code&gt; defined on &lt;code&gt;Dog&lt;/code&gt; directly.</source>
          <target state="translated">그러나 특성의 일부인 관련 함수에는 &lt;code&gt;self&lt;/code&gt; 매개 변수 가 없습니다 . 동일한 범위의 두 유형이 해당 특성을 구현할 때 &lt;em&gt;정규화 된 구문&lt;/em&gt; 을 사용하지 않으면 Rust가 어떤 유형을 의미하는지 파악할 수 없습니다 . 예를 들어, 목록 19-19 의 &lt;code&gt;Animal&lt;/code&gt; 특성에는 연관된 함수 &lt;code&gt;baby_name&lt;/code&gt; , 구조체 &lt;code&gt;Dog&lt;/code&gt; 에 대한 &lt;code&gt;Animal&lt;/code&gt; 구현 및 &lt;code&gt;Dog&lt;/code&gt; 에 직접 정의 된 연관된 함수 &lt;code&gt;baby_name&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8a92146e9c361c007de32df04115100977209af" translate="yes" xml:space="preserve">
          <source>However, be careful when two types have a common associated type:</source>
          <target state="translated">그러나 두 유형에 공통된 유형이있는 경우주의하십시오.</target>
        </trans-unit>
        <trans-unit id="7c05de5702d4d9921eaeead5a04ffacda460142d" translate="yes" xml:space="preserve">
          <source>However, because &lt;code&gt;a&lt;/code&gt; is still referencing the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; that was in &lt;code&gt;b&lt;/code&gt;, that &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; has a count of 1 rather than 0, so the memory the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; has on the heap won&amp;rsquo;t be dropped. The memory will just sit there with a count of 1, forever. To visualize this reference cycle, we&amp;rsquo;ve created a diagram in Figure 15-4.</source>
          <target state="translated">그러나, &lt;code&gt;a&lt;/code&gt; 여전히 참조하고 &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 에 있었던 &lt;code&gt;b&lt;/code&gt; 것으로, &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 상기 메모리 있도록 1보다 0의 카운트를 보유하고, &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; 힙 갖는다는 삭제되지 않을 것이다. 기억은 단지 1의 카운트로 영원히 거기에 앉을 것입니다. 이 참조주기를 시각화하기 위해 그림 15-4에서 다이어그램을 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="a75f8c79454007f698be22ee125cb88b1db6c03c" translate="yes" xml:space="preserve">
          <source>However, for clients that do not wish to track the capacity returned by &lt;code&gt;alloc_excess&lt;/code&gt; locally, this method is likely to produce useful results.</source>
          <target state="translated">그러나 &lt;code&gt;alloc_excess&lt;/code&gt; 가 로컬로 리턴 한 용량을 추적하지 않으려는 클라이언트의 경우이 방법으로 유용한 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6f1d589fbc14406ddd7e944ec737df44d57ed77" translate="yes" xml:space="preserve">
          <source>However, having lots of error checks in all of your functions would be verbose and annoying. Fortunately, you can use Rust&amp;rsquo;s type system (and thus the type checking the compiler does) to do many of the checks for you. If your function has a particular type as a parameter, you can proceed with your code&amp;rsquo;s logic knowing that the compiler has already ensured you have a valid value. For example, if you have a type rather than an &lt;code&gt;Option&lt;/code&gt;, your program expects to have &lt;em&gt;something&lt;/em&gt; rather than &lt;em&gt;nothing&lt;/em&gt;. Your code then doesn&amp;rsquo;t have to handle two cases for the &lt;code&gt;Some&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; variants: it will only have one case for definitely having a value. Code trying to pass nothing to your function won&amp;rsquo;t even compile, so your function doesn&amp;rsquo;t have to check for that case at runtime. Another example is using an unsigned integer type such as &lt;code&gt;u32&lt;/code&gt;, which ensures the parameter is never negative.</source>
          <target state="translated">그러나 모든 기능에 많은 오류 검사가 있으면 장황하고 성 가실 것입니다. 다행스럽게도 Rust의 타입 시스템 (따라서 컴파일러가 수행하는 타입 검사)을 사용하여 많은 검사를 할 수 있습니다. 함수에 특정 유형의 매개 변수가있는 경우 컴파일러가 이미 유효한 값을 가지고 있음을 알고 코드 논리를 진행할 수 있습니다. 예를 들어, &lt;code&gt;Option&lt;/code&gt; 이 아닌 유형이있는 경우 프로그램 은 &lt;em&gt;아무것도&lt;/em&gt; 아닌 &lt;em&gt;것을&lt;/em&gt; 기대합니다 . 그러면 코드에서 &lt;code&gt;Some&lt;/code&gt; 과 &lt;code&gt;None&lt;/code&gt; 에 대해 두 가지 경우를 처리 할 필요가 없습니다.&lt;em&gt;&lt;/em&gt;변형 : 확실히 가치가있는 경우는 하나뿐입니다. 함수에 아무것도 전달하지 않는 코드는 컴파일되지 않으므로 런타임에 함수가 해당 사례를 확인할 필요가 없습니다. 또 다른 예는 &lt;code&gt;u32&lt;/code&gt; 와 같은 부호없는 정수 유형을 사용 하여 매개 변수가 음수가 아닌지 확인 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c47ddb353392208fbaf5c29553d62da521ea2e56" translate="yes" xml:space="preserve">
          <source>However, if a type implements &lt;code&gt;Copy&lt;/code&gt;, it instead has 'copy semantics':</source>
          <target state="translated">그러나 유형이 &lt;code&gt;Copy&lt;/code&gt; 를 구현 하면 대신 'copy semantics'가 있습니다.</target>
        </trans-unit>
        <trans-unit id="601ae6aeca914c05ec96fb8df8c9c4178c5a0a78" translate="yes" xml:space="preserve">
          <source>However, if it derives from &lt;code&gt;Super&amp;lt;Self&amp;gt;&lt;/code&gt;, even though &lt;code&gt;Super&lt;/code&gt; is object safe, the method &lt;code&gt;get_a()&lt;/code&gt; would return an object of unknown type when called on the function. &lt;code&gt;Self&lt;/code&gt; type parameters let us make object safe traits no longer safe, so they are forbidden when specifying supertraits.</source>
          <target state="translated">그러나 &lt;code&gt;Super&lt;/code&gt; 가 객체 안전 하더라도 &lt;code&gt;Super&amp;lt;Self&amp;gt;&lt;/code&gt; 에서 파생되는 경우 &lt;code&gt;get_a()&lt;/code&gt; 메소드 는 함수에서 호출 될 때 알 수없는 유형의 객체를 반환합니다. &lt;code&gt;Self&lt;/code&gt; 유형 매개 변수를 사용하면 객체 안전 특성을 더 이상 안전하게 만들 수 없으므로 수퍼 특성을 지정할 때 금지됩니다.</target>
        </trans-unit>
        <trans-unit id="7fad1dff57715fb5c533987e92e806ddbde896cc" translate="yes" xml:space="preserve">
          <source>However, if you still wish to use these types, you can achieve this by an unsafe wrapper:</source>
          <target state="translated">그러나 이러한 유형을 계속 사용하려면 안전하지 않은 래퍼로이를 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f1b0df6bf40f54deee89e8870694822d74c8932" translate="yes" xml:space="preserve">
          <source>However, if you wanted to access a field of a struct check that the field name is spelled correctly. Example:</source>
          <target state="translated">그러나 구조체의 필드에 액세스하려면 필드 이름의 철자가 올바른지 확인하십시오. 예:</target>
        </trans-unit>
        <trans-unit id="26830adb8373fabf090d221485ccd723186cf9b8" translate="yes" xml:space="preserve">
          <source>However, one long line is difficult to read, so it&amp;rsquo;s best to divide it: two lines for two method calls. Now let&amp;rsquo;s discuss what this line does.</source>
          <target state="translated">그러나 하나의 긴 줄은 읽기가 어렵 기 때문에 나누는 것이 가장 좋습니다. 두 개의 메소드 호출에 대해 두 줄입니다. 이제이 라인이 무엇을하는지 논의 해 보자.</target>
        </trans-unit>
        <trans-unit id="dd472996f3f286211f48a487c70490ad383642d1" translate="yes" xml:space="preserve">
          <source>However, our intention in this chapter is to help you learn, not to take the easy route. Because Rust is a systems programming language, we can choose the level of abstraction we want to work with and can go to a lower level than is possible or practical in other languages. We&amp;rsquo;ll write the basic HTTP server and thread pool manually so you can learn the general ideas and techniques behind the crates you might use in the future.</source>
          <target state="translated">그러나이 장의 목적은 쉬운 길을 택하지 않고 배우는 것을 돕기위한 것입니다. Rust는 시스템 프로그래밍 언어이기 때문에 작업하려는 추상화 수준을 선택할 수 있으며 다른 언어에서 가능하거나 실용적인 것보다 낮은 수준으로 갈 수 있습니다. 기본 HTTP 서버 및 스레드 풀을 수동으로 작성하여 향후 사용할 상자 뒤에있는 일반적인 아이디어와 기술을 배울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3c7769e69d54d27cbd8d165bbdf117ddc427c2b" translate="yes" xml:space="preserve">
          <source>However, please keep in mind that the first solution should be preferred.</source>
          <target state="translated">그러나 첫 번째 솔루션을 선호해야합니다.</target>
        </trans-unit>
        <trans-unit id="9e7ca595910d369d04059d59dd0f26ad24257742" translate="yes" xml:space="preserve">
          <source>However, some higher-level allocation methods (&lt;code&gt;alloc_one&lt;/code&gt;, &lt;code&gt;alloc_array&lt;/code&gt;) are well-defined on zero-sized types and can optionally support them: it is left up to the implementor whether to return &lt;code&gt;Err&lt;/code&gt;, or to return &lt;code&gt;Ok&lt;/code&gt; with some pointer.</source>
          <target state="translated">그러나 일부 고급 할당 방법 ( &lt;code&gt;alloc_one&lt;/code&gt; , &lt;code&gt;alloc_array&lt;/code&gt; )은 크기가 0 인 유형에 대해 잘 정의되어 있으며 선택적으로 지원할 수 있습니다. &lt;code&gt;Err&lt;/code&gt; 를 반환할지 또는 포인터 로 &lt;code&gt;Ok&lt;/code&gt; 를 반환 할지 여부는 구현 자에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb26cd270c81cacb615098ed7b7796b24ddb7cc6" translate="yes" xml:space="preserve">
          <source>However, sometimes we want our library user to be able to extend the set of types that are valid in a particular situation. To show how we might achieve this, we&amp;rsquo;ll create an example graphical user interface (GUI) tool that iterates through a list of items, calling a &lt;code&gt;draw&lt;/code&gt; method on each one to draw it to the screen&amp;mdash;a common technique for GUI tools. We&amp;rsquo;ll create a library crate called &lt;code&gt;gui&lt;/code&gt; that contains the structure of a GUI library. This crate might include some types for people to use, such as &lt;code&gt;Button&lt;/code&gt; or &lt;code&gt;TextField&lt;/code&gt;. In addition, &lt;code&gt;gui&lt;/code&gt; users will want to create their own types that can be drawn: for instance, one programmer might add an &lt;code&gt;Image&lt;/code&gt; and another might add a &lt;code&gt;SelectBox&lt;/code&gt;.</source>
          <target state="translated">그러나 때로는 라이브러리 사용자가 특정 상황에서 유효한 유형 세트를 확장 할 수 있기를 원합니다. 이를 달성하는 방법을 보여주기 위해 항목 목록을 반복하는 GUI (Graphical User Interface) 도구를 만들어 각 GUI 도구에 대한 일반적인 기술인 화면에 &lt;code&gt;draw&lt;/code&gt; 방법을 호출 합니다. GUI 라이브러리의 구조를 포함하는 &lt;code&gt;gui&lt;/code&gt; 라는 라이브러리 상자를 만듭니다 . 이 상자에는 &lt;code&gt;Button&lt;/code&gt; 또는 &lt;code&gt;TextField&lt;/code&gt; 와 같이 사람들이 사용할 수있는 일부 유형이 포함될 수 있습니다 . 또한 &lt;code&gt;gui&lt;/code&gt; 사용자는 그릴 수있는 고유 한 유형을 만들려고합니다. 예를 들어 한 프로그래머가 &lt;code&gt;Image&lt;/code&gt; 추가 하고 다른 프로그래머가 이미지 를 추가 할 수 있습니다. &lt;code&gt;SelectBox&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="090c640dded64692c1c679520894484188072e98" translate="yes" xml:space="preserve">
          <source>However, structural pinning comes with a few extra requirements:</source>
          <target state="translated">그러나 구조적 고정에는 몇 가지 추가 요구 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6446591953c7036afa44804569e6b2a76fecb194" translate="yes" xml:space="preserve">
          <source>However, suffixes on literal tokens parsed as Rust code are restricted.</source>
          <target state="translated">그러나 Rust 코드로 구문 분석 된 리터럴 토큰의 접미 부는 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="e53d985c5c53455719af4369d5bd75e2e43f4f1b" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;match&lt;/code&gt; expression can be a bit wordy in a situation in which we care about only &lt;em&gt;one&lt;/em&gt; of the cases. For this situation, Rust provides &lt;code&gt;if let&lt;/code&gt;.</source>
          <target state="translated">그러나 &lt;em&gt;하나&lt;/em&gt; 의 경우 에만 관심이있는 상황 에서는 &lt;code&gt;match&lt;/code&gt; 표현식이 약간 까다로울 수 있습니다 . 이 상황에서 Rust은 &lt;code&gt;if let&lt;/code&gt; 제공 합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a11b9e584ed4976bfbc4897d2baa5077bb7ad3ff" translate="yes" xml:space="preserve">
          <source>However, the code in Listing 2-4 won&amp;rsquo;t compile yet. Let&amp;rsquo;s try it:</source>
          <target state="translated">그러나 목록 2-4의 코드는 아직 컴파일되지 않습니다. 해 봅시다:</target>
        </trans-unit>
        <trans-unit id="5ff36d97f387c34f0e3f89e3b84848ea32f28366" translate="yes" xml:space="preserve">
          <source>However, the concept that null is trying to express is still a useful one: a null is a value that is currently invalid or absent for some reason.</source>
          <target state="translated">그러나 null이 표현하려고한다는 개념은 여전히 ​​유용한 개념입니다. null은 현재 어떤 이유로 인해 유효하지 않거나없는 값입니다.</target>
        </trans-unit>
        <trans-unit id="cda87a9e6a4c7e24911050c4147eddad9fb1a4fd" translate="yes" xml:space="preserve">
          <source>However, the pointer may not actually point to allocated memory. In particular, if you construct a &lt;code&gt;Vec&lt;/code&gt; with capacity 0 via &lt;a href=&quot;struct.vec#method.new&quot;&gt;&lt;code&gt;Vec::new&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../macro.vec&quot;&gt;&lt;code&gt;vec![]&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.vec#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity(0)&lt;/code&gt;&lt;/a&gt;, or by calling &lt;a href=&quot;struct.vec#method.shrink_to_fit&quot;&gt;&lt;code&gt;shrink_to_fit&lt;/code&gt;&lt;/a&gt; on an empty Vec, it will not allocate memory. Similarly, if you store zero-sized types inside a &lt;code&gt;Vec&lt;/code&gt;, it will not allocate space for them. &lt;em&gt;Note that in this case the &lt;code&gt;Vec&lt;/code&gt; may not report a &lt;a href=&quot;struct.vec#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; of 0&lt;/em&gt;. &lt;code&gt;Vec&lt;/code&gt; will allocate if and only if &lt;a href=&quot;../mem/fn.size_of&quot;&gt;&lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;() * capacity() &amp;gt; 0&lt;/code&gt;. In general, &lt;code&gt;Vec&lt;/code&gt;'s allocation details are very subtle &amp;mdash; if you intend to allocate memory using a &lt;code&gt;Vec&lt;/code&gt; and use it for something else (either to pass to unsafe code, or to build your own memory-backed collection), be sure to deallocate this memory by using &lt;code&gt;from_raw_parts&lt;/code&gt; to recover the &lt;code&gt;Vec&lt;/code&gt; and then dropping it.</source>
          <target state="translated">그러나 포인터가 실제로 할당 된 메모리를 가리 키지 않을 수 있습니다. 특히 &lt;a href=&quot;struct.vec#method.new&quot;&gt; &lt;code&gt;Vec::new&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../macro.vec&quot;&gt; &lt;code&gt;vec![]&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.vec#method.with_capacity&quot;&gt; &lt;code&gt;Vec::with_capacity(0)&lt;/code&gt; &lt;/a&gt; 를 통해 용량이 0 인 &lt;code&gt;Vec&lt;/code&gt; 을 구성 하거나 빈 Vec에서 &lt;a href=&quot;struct.vec#method.shrink_to_fit&quot;&gt; &lt;code&gt;shrink_to_fit&lt;/code&gt; &lt;/a&gt; 을 호출 하면 메모리가 할당되지 않습니다. 마찬가지로 &lt;code&gt;Vec&lt;/code&gt; 안에 0 크기의 유형을 저장하면 공간을 할당하지 않습니다. &lt;em&gt;이 경우 &lt;/em&gt;&lt;em&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/em&gt;&lt;em&gt; 은 &lt;/em&gt;&lt;em&gt;&lt;a href=&quot;struct.vec#method.capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt;&lt;/em&gt;&lt;em&gt; 0을 &lt;/em&gt;&lt;em&gt;보고하지 않을 수 있습니다&lt;/em&gt; . &lt;code&gt;Vec&lt;/code&gt; 은 &lt;a href=&quot;../mem/fn.size_of&quot;&gt; &lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;() * capacity() &amp;gt; 0&lt;/code&gt; 경우에만 할당합니다 . 일반적으로 &lt;code&gt;Vec&lt;/code&gt; &lt;em&gt;&lt;/em&gt; &lt;code&gt;Vec&lt;/code&gt; 을 사용 하여 메모리를 할당 하고 다른 용도로 사용하려는 경우 (안전하지 않은 코드로 전달하거나 자체 메모리 기반 컬렉션을 작성하려는 경우)를 사용하여이 메모리를 할당 해제해야합니다. &lt;code&gt;from_raw_parts&lt;/code&gt; 를 사용하여 &lt;code&gt;Vec&lt;/code&gt; 을 복구 한 다음 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="71a07da2ac46a34c0d6bf7a73675b61fc8ad742b" translate="yes" xml:space="preserve">
          <source>However, the reverse is not true: not all valid &lt;a href=&quot;../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s are valid &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;from_u32()&lt;/code&gt; will return &lt;code&gt;None&lt;/code&gt; if the input is not a valid value for a &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">그러나 그 반대는 사실이 아닙니다. 모든 유효한 &lt;a href=&quot;../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; 가 유효한 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 는 아닙니다 . &lt;code&gt;from_u32()&lt;/code&gt; 는 입력 값이 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 의 유효한 값이 아닌 경우 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="627ab6996d8e9eb90f195c27a7e3d742a80e3b8e" translate="yes" xml:space="preserve">
          <source>However, the reverse is not true: not all valid &lt;a href=&quot;../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s are valid &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;from_u32_unchecked()&lt;/code&gt; will ignore this, and blindly cast to &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, possibly creating an invalid one.</source>
          <target state="translated">그러나 그 반대는 사실이 아닙니다. 모든 유효한 &lt;a href=&quot;../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; 가 유효한 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; 는 아닙니다 . &lt;code&gt;from_u32_unchecked()&lt;/code&gt; 는 이것을 무시하고 맹목적으로 &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; 로&lt;/a&gt; 캐스팅 하여 유효하지 않은 것을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1f5612bf46edfe618e917ff01d32fb9bebb43312" translate="yes" xml:space="preserve">
          <source>However, the second part is different. In languages with a &lt;em&gt;garbage collector (GC)&lt;/em&gt;, the GC keeps track and cleans up memory that isn&amp;rsquo;t being used anymore, and we don&amp;rsquo;t need to think about it. Without a GC, it&amp;rsquo;s our responsibility to identify when memory is no longer being used and call code to explicitly return it, just as we did to request it. Doing this correctly has historically been a difficult programming problem. If we forget, we&amp;rsquo;ll waste memory. If we do it too early, we&amp;rsquo;ll have an invalid variable. If we do it twice, that&amp;rsquo;s a bug too. We need to pair exactly one &lt;code&gt;allocate&lt;/code&gt; with exactly one &lt;code&gt;free&lt;/code&gt;.</source>
          <target state="translated">그러나 두 번째 부분은 다릅니다. &lt;em&gt;가비지 수집기 (GC)&lt;/em&gt; 가있는 언어 에서 GC는 더 이상 사용되지 않는 메모리를 추적하고 정리하므로 이에 대해 생각할 필요가 없습니다. GC가 없으면 메모리를 더 이상 사용하지 않을 때를 식별하고 요청하는 것처럼 메모리를 명시 적으로 반환하는 코드를 호출해야합니다. 이것을 올바르게하는 것은 역사적으로 어려운 프로그래밍 문제였습니다. 잊어 버리면 기억이 낭비됩니다. 너무 일찍하면 유효하지 않은 변수가 생깁니다. 우리가 두 번 그렇게하면 버그이기도합니다. 우리는 정확히 하나의 &lt;code&gt;allocate&lt;/code&gt; 을 정확히 하나의 &lt;code&gt;free&lt;/code&gt; 와 페어링해야합니다 .</target>
        </trans-unit>
        <trans-unit id="af229bc0a48ef0630b724d21dd6f456c48e60c69" translate="yes" xml:space="preserve">
          <source>However, there are situations in which it would be useful for a value to mutate itself in its methods but appear immutable to other code. Code outside the value&amp;rsquo;s methods would not be able to mutate the value. Using &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; is one way to get the ability to have interior mutability. But &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; doesn&amp;rsquo;t get around the borrowing rules completely: the borrow checker in the compiler allows this interior mutability, and the borrowing rules are checked at runtime instead. If you violate the rules, you&amp;rsquo;ll get a &lt;code&gt;panic!&lt;/code&gt; instead of a compiler error.</source>
          <target state="translated">그러나 값이 메소드에서 자체적으로 변경되는 것이 유용하지만 다른 코드에서는 변경할 수없는 상황이 있습니다. 값의 메소드 외부의 코드는 값을 변경할 수 없습니다. &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 사용하면 내부 변경 기능을 사용할 수 있습니다. 그러나 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; 는 차용 규칙을 완전히 극복하지 못합니다. 컴파일러의 차용 검사기는 이러한 내부 변경을 허용하며 차용 규칙은 런타임에 대신 확인됩니다. 규칙을 위반하면 &lt;code&gt;panic!&lt;/code&gt; 컴파일러 오류 대신.</target>
        </trans-unit>
        <trans-unit id="a0d46c846b73ae9a30e6ec8307068cbd57726662" translate="yes" xml:space="preserve">
          <source>However, there is a &lt;a href=&quot;../type-coercions&quot;&gt;coercion&lt;/a&gt; from function items to &lt;a href=&quot;function-pointer&quot;&gt;function pointers&lt;/a&gt; with the same signature, which is triggered not only when a function item is used when a function pointer is directly expected, but also when different function item types with the same signature meet in different arms of the same &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;match&lt;/code&gt;:</source>
          <target state="translated">그러나 함수 항목 에서 동일한 서명을 가진 &lt;a href=&quot;function-pointer&quot;&gt;함수 포인터&lt;/a&gt; 로 &lt;a href=&quot;../type-coercions&quot;&gt;강제 변환&lt;/a&gt; 됩니다. 이는 함수 포인터가 직접 예상 될 때 함수 항목이 사용될 때뿐만 아니라 동일한 서명을 가진 다른 함수 항목 유형이 다른 경우에도 트리거됩니다. 같은 &lt;code&gt;if&lt;/code&gt; 또는 &lt;code&gt;match&lt;/code&gt; 하는 무기 :</target>
        </trans-unit>
        <trans-unit id="a66a1dddad283613aaa962e121910c064ac30ef0" translate="yes" xml:space="preserve">
          <source>However, there&amp;rsquo;s one problem with this test, as shown here:</source>
          <target state="translated">그러나이 테스트에는 다음과 같은 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="18f90c271b4c818c9717e731f31d20c5d63240c8" translate="yes" xml:space="preserve">
          <source>However, they would need to write the implementation block for each type they wanted to use with &lt;code&gt;hello_macro&lt;/code&gt;; we want to spare them from having to do this work.</source>
          <target state="translated">그러나 &lt;code&gt;hello_macro&lt;/code&gt; 와 함께 사용하려는 각 유형에 대해 구현 블록을 작성해야합니다 . 우리는이 일을하지 않아도되기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="d3b75e55302f15f6020a4b2831ab78b8a9cd134e" translate="yes" xml:space="preserve">
          <source>However, this is not an ideal solution: if it was absolutely critical that the program only operated on values between 1 and 100, and it had many functions with this requirement, having a check like this in every function would be tedious (and might impact performance).</source>
          <target state="translated">그러나 이것은 이상적인 해결책은 아닙니다. 프로그램이 1에서 100 사이의 값으로 만 작동하는 것이 절대적으로 중요하고이 요구 사항을 가진 많은 기능이있는 경우 모든 기능에서 이와 같이 확인하는 것이 번거롭고 영향을 줄 수 있습니다. 공연).</target>
        </trans-unit>
        <trans-unit id="a824bb12ed66d349d925794b2e3920170b4c275c" translate="yes" xml:space="preserve">
          <source>However, this pattern is so common that Rust has a built-in language construct for it, called a &lt;code&gt;while&lt;/code&gt; loop. Listing 3-3 uses &lt;code&gt;while&lt;/code&gt;: the program loops three times, counting down each time, and then, after the loop, it prints another message and exits.</source>
          <target state="translated">그러나이 패턴은 매우 일반적이므로 Rust는이를 위해 &lt;code&gt;while&lt;/code&gt; 루프 라고하는 내장 언어 구조를 가지고 있습니다. Listing 3-3은 &lt;code&gt;while&lt;/code&gt; : 프로그램을 세 번 반복하고 매번 카운트 다운 한 다음 루프 후에 다른 메시지를 인쇄하고 종료한다.</target>
        </trans-unit>
        <trans-unit id="ada98a89852cf14a520ca2427888843bc3fd0869" translate="yes" xml:space="preserve">
          <source>However, this won't:</source>
          <target state="translated">그러나 이것은 :</target>
        </trans-unit>
        <trans-unit id="2ba8355a99e10032076801bb58aaec6886066a15" translate="yes" xml:space="preserve">
          <source>However, two concurrency concepts are embedded in the language: the &lt;code&gt;std::marker&lt;/code&gt; traits &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt;.</source>
          <target state="translated">그러나 언어에는 두 개의 동시성 개념이 포함되어 있습니다. &lt;code&gt;std::marker&lt;/code&gt; 특성 &lt;code&gt;Sync&lt;/code&gt; 및 &lt;code&gt;Send&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fad3453f67fa7a8abf1de710cc99507cae5f79c" translate="yes" xml:space="preserve">
          <source>However, using &lt;code&gt;..&lt;/code&gt; must be unambiguous. If it is unclear which values are intended for matching and which should be ignored, Rust will give us an error. Listing 18-25 shows an example of using &lt;code&gt;..&lt;/code&gt; ambiguously, so it will not compile.</source>
          <target state="translated">그러나 &lt;code&gt;..&lt;/code&gt; 를 사용하면 명확해야합니다. 일치시킬 값과 무시해야 할 값이 확실하지 않은 경우 Rust는 오류를 표시합니다. Listing 18-25는 &lt;code&gt;..&lt;/code&gt; 를 모호하게 사용하는 예제를 보여 주므로 컴파일되지 않는다.</target>
        </trans-unit>
        <trans-unit id="f1a26fc372d073b9ed76f398473c3b964914605f" translate="yes" xml:space="preserve">
          <source>However, we&amp;rsquo;ve reintroduced one of the problems from Listing 13-3: we&amp;rsquo;re still calling the closure twice in the first &lt;code&gt;if&lt;/code&gt; block, which will call the expensive code twice and make the user wait twice as long as they need to. We could fix this problem by creating a variable local to that &lt;code&gt;if&lt;/code&gt; block to hold the result of calling the closure, but closures provide us with another solution. We&amp;rsquo;ll talk about that solution in a bit. But first let&amp;rsquo;s talk about why there aren&amp;rsquo;t type annotations in the closure definition and the traits involved with closures.</source>
          <target state="translated">그러나 Listing 13-3의 문제점 중 하나를 다시 도입했다. 첫 번째 &lt;code&gt;if&lt;/code&gt; 블록 에서 클로저를 여전히 두 번 호출하고 있는데,이 경우 고가의 코드를 두 번 호출하고 사용자가 필요한 시간을 두 번 기다릴 것이다. 클로저 호출 결과를 보유하기 위해 &lt;code&gt;if&lt;/code&gt; 블록에 로컬 변수를 생성하여이 문제를 해결할 수 있지만 클로저는 다른 솔루션을 제공합니다. 우리는 그 해결책에 대해 조금 이야기 할 것입니다. 그러나 먼저 클로저 정의에 클로저 정의에 타입 주석이없는 이유와 클로저와 관련된 특성에 대해 이야기하겠습니다.</target>
        </trans-unit>
        <trans-unit id="aeba4f050e04fdf1cf910571a9c79d642b8343c4" translate="yes" xml:space="preserve">
          <source>However, when failure is expected, it&amp;rsquo;s more appropriate to return a &lt;code&gt;Result&lt;/code&gt; than to make a &lt;code&gt;panic!&lt;/code&gt; call. Examples include a parser being given malformed data or an HTTP request returning a status that indicates you have hit a rate limit. In these cases, returning a &lt;code&gt;Result&lt;/code&gt; indicates that failure is an expected possibility that the calling code must decide how to handle.</source>
          <target state="translated">그러나 실패가 예상되는 경우 &lt;code&gt;panic!&lt;/code&gt; 를 만드는 것보다 &lt;code&gt;Result&lt;/code&gt; 를 반환하는 것이 더 적절합니다 ! 요구. 예를 들어 형식이 잘못된 데이터가 제공되는 파서 또는 속도 제한에 도달했음을 나타내는 상태를 반환하는 HTTP 요청이 있습니다. 이 경우 &lt;code&gt;Result&lt;/code&gt; 반환 하면 호출 코드를 처리하는 방법을 결정해야 할 가능성이 예상되는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bd1b29ca1d0594e55daa86076890956a32cf494f" translate="yes" xml:space="preserve">
          <source>However, with trait objects we have to make a table containing &lt;em&gt;every&lt;/em&gt; object that implements the trait. Now, if it has type parameters, we need to add implementations for every type that implements the trait, and there could theoretically be an infinite number of types.</source>
          <target state="translated">그러나 특성 오브젝트를 사용 하여 특성을 구현 하는 &lt;em&gt;모든&lt;/em&gt; 오브젝트를 포함하는 테이블을 작성해야합니다 . 유형 매개 변수가있는 경우 이제 특성을 구현하는 모든 유형에 대한 구현을 추가해야하며 이론적으로 무한한 유형이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c83a1e89e4828f4c8e8c03978096139099426f82" translate="yes" xml:space="preserve">
          <source>However, you can only use &lt;code&gt;impl Trait&lt;/code&gt; if you&amp;rsquo;re returning a single type. For example, this code that returns either a &lt;code&gt;NewsArticle&lt;/code&gt; or a &lt;code&gt;Tweet&lt;/code&gt; with the return type specified as &lt;code&gt;impl Summary&lt;/code&gt; wouldn&amp;rsquo;t work:</source>
          <target state="translated">그러나 단일 유형을 반환하는 경우 &lt;code&gt;impl Trait&lt;/code&gt; 만 사용할 수 있습니다 . 예를 들어, &lt;code&gt;NewsArticle&lt;/code&gt; 또는 반환 형식이 &lt;code&gt;impl Summary&lt;/code&gt; 로 지정된 &lt;code&gt;Tweet&lt;/code&gt; 을 반환하는이 코드는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e2fcea022d94a9775aabc30c1a2c51d018156b80" translate="yes" xml:space="preserve">
          <source>Hundreds of companies, large and small, use Rust in production for a variety of tasks. Those tasks include command line tools, web services, DevOps tooling, embedded devices, audio and video analysis and transcoding, cryptocurrencies, bioinformatics, search engines, Internet of Things applications, machine learning, and even major parts of the Firefox web browser.</source>
          <target state="translated">크고 작은 수백 개의 회사에서 다양한 작업을 위해 생산시 Rust를 사용합니다. 이러한 작업에는 명령 줄 도구, 웹 서비스, DevOps 도구, 임베디드 장치, 오디오 및 비디오 분석 및 트랜스 코딩, 암호 화폐, 생물 정보학, 검색 엔진, 사물 인터넷 응용 프로그램, 기계 학습 및 Firefox 웹 브라우저의 주요 부분이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="37906f8372f8c377be7b1e328309d3c4f609ea59" translate="yes" xml:space="preserve">
          <source>Hygiene</source>
          <target state="translated">Hygiene</target>
        </trans-unit>
        <trans-unit id="ad65c5b3b86039ac673217b5d774ea59d147e7b7" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine function.</source>
          <target state="translated">쌍곡 코사인 함수.</target>
        </trans-unit>
        <trans-unit id="c686c752760e59aa04f64bbe28ff2dbeca59fd00" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine function.</source>
          <target state="translated">쌍곡 사인 함수.</target>
        </trans-unit>
        <trans-unit id="78df70baad8c07fe855fe47101a5902c14b1e359" translate="yes" xml:space="preserve">
          <source>Hyperbolic tangent function.</source>
          <target state="translated">쌍곡 탄젠트 함수.</target>
        </trans-unit>
        <trans-unit id="bdf6cba1852f21a59de6863b8e6d7784db0851c8" translate="yes" xml:space="preserve">
          <source>I call it my billion-dollar mistake. At that time, I was designing the first comprehensive type system for references in an object-oriented language. My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn&amp;rsquo;t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.</source>
          <target state="translated">나는 그것을 10 억 달러의 실수라고 부릅니다. 당시에는 객체 지향 언어로 참조 할 수있는 최초의 포괄적 인 유형 시스템을 설계하고있었습니다. 필자의 목표는 컴파일러가 자동으로 검사를 수행하여 모든 참조 사용이 절대적으로 안전하도록하는 것이 었습니다. 그러나 구현하기가 쉽기 때문에 null 참조를 넣는 유혹에 저항 할 수 없었습니다. 이로 인해 수많은 오류, 취약성 및 시스템 충돌이 발생했으며, 이는 아마도 지난 40 년 동안 수십억 달러의 고통과 피해를 야기했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="e7c23cd87ff8917afb8c94f0de55718d338f0dac" translate="yes" xml:space="preserve">
          <source>IDE Integration Using the Rust Language Server</source>
          <target state="translated">Rust Language Server를 사용한 IDE 통합</target>
        </trans-unit>
        <trans-unit id="0e3b1f1fb38a7fe314d2f472da7f442366e6c3f3" translate="yes" xml:space="preserve">
          <source>IDENTIFIER</source>
          <target state="translated">IDENTIFIER</target>
        </trans-unit>
        <trans-unit id="55b1203af6cad8ae52e0d0a37f140db7910d8eda" translate="yes" xml:space="preserve">
          <source>IDENTIFIER :</source>
          <target state="translated">식별자 :</target>
        </trans-unit>
        <trans-unit id="c0fcd90425d895f40b307f4c7f56f5df18b1668f" translate="yes" xml:space="preserve">
          <source>IDENTIFIER_OR_KEYWORD :</source>
          <target state="translated">IDENTIFIER_OR_KEYWORD :</target>
        </trans-unit>
        <trans-unit id="b8dae77b24288c011d2b9b755b9a1a42811917e3" translate="yes" xml:space="preserve">
          <source>IEEE-754 very precisely specifies the bit layout of floats.</source>
          <target state="translated">IEEE-754는 부동 소수점의 비트 레이아웃을 매우 정확하게 지정합니다.</target>
        </trans-unit>
        <trans-unit id="1852814b8596efd4647ef533b868ea9c6f371594" translate="yes" xml:space="preserve">
          <source>IETF RFC 4291 section 2.4</source>
          <target state="translated">IETF RFC 4291 섹션 2.4</target>
        </trans-unit>
        <trans-unit id="aa0c0f5169dc17cce987a2ba8ef3419dba45ba72" translate="yes" xml:space="preserve">
          <source>IETF RFC 4291 section 2.5.6</source>
          <target state="translated">IETF RFC 4291 섹션 2.5.6</target>
        </trans-unit>
        <trans-unit id="bb6e7841dba2c83d7f4685d9f749f0a969927ab9" translate="yes" xml:space="preserve">
          <source>INFINITY</source>
          <target state="translated">INFINITY</target>
        </trans-unit>
        <trans-unit id="a1a3b8cc81502982ba95837302feb61e65dd8a3d" translate="yes" xml:space="preserve">
          <source>INNER_BLOCK_DOC :</source>
          <target state="translated">INNER_BLOCK_DOC :</target>
        </trans-unit>
        <trans-unit id="53a0430947a0edbae0af7f9e49d8f2dfe4e9afb4" translate="yes" xml:space="preserve">
          <source>INNER_LINE_DOC :</source>
          <target state="translated">INNER_LINE_DOC :</target>
        </trans-unit>
        <trans-unit id="3f9135bee30f70c629387b1f17caf9d0de0eb83e" translate="yes" xml:space="preserve">
          <source>INTEGER_LITERAL :</source>
          <target state="translated">INTEGER_LITERAL :</target>
        </trans-unit>
        <trans-unit id="6371ddd611a0269a5bb8329b8b5ad2906b65b001" translate="yes" xml:space="preserve">
          <source>INTEGER_SUFFIX :</source>
          <target state="translated">INTEGER_SUFFIX :</target>
        </trans-unit>
        <trans-unit id="11cbb1f84a9535024b6452829b5548dd25b90335" translate="yes" xml:space="preserve">
          <source>IPv4 addresses are defined as 32-bit integers in &lt;a href=&quot;https://tools.ietf.org/html/rfc791&quot;&gt;IETF RFC 791&lt;/a&gt;. They are usually represented as four octets.</source>
          <target state="translated">IPv4 주소는 &lt;a href=&quot;https://tools.ietf.org/html/rfc791&quot;&gt;IETF RFC 791&lt;/a&gt; 에서 32 비트 정수로 정의됩니다 . 그것들은 보통 4 옥텟으로 표현됩니다.</target>
        </trans-unit>
        <trans-unit id="125cc8de0dff730e4520fc003986c19a1b8554df" translate="yes" xml:space="preserve">
          <source>IPv4 socket addresses consist of an &lt;a href=&quot;struct.ipv4addr&quot;&gt;IPv4 address&lt;/a&gt; and a 16-bit port number, as stated in &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793&lt;/a&gt;.</source>
          <target state="translated">IPv4 소켓 주소 는 &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793에&lt;/a&gt; 명시된 바와 같이 &lt;a href=&quot;struct.ipv4addr&quot;&gt;IPv4 주소&lt;/a&gt; 와 16 비트 포트 번호로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="0fb594a9f230f62a93a2d236d355fee291f5f0ed" translate="yes" xml:space="preserve">
          <source>IPv6 addresses are defined as 128-bit integers in &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt;. They are usually represented as eight 16-bit segments.</source>
          <target state="translated">IPv6 주소는 &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt; 에서 128 비트 정수로 정의됩니다 . 일반적으로 8 개의 16 비트 세그먼트로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3a88c8ad7ac15b70173172e130a9df32e2c85f47" translate="yes" xml:space="preserve">
          <source>IPv6 socket addresses consist of an &lt;a href=&quot;struct.ipv6addr&quot;&gt;Ipv6 address&lt;/a&gt;, a 16-bit port number, as well as fields containing the traffic class, the flow label, and a scope identifier (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553, Section 3.3&lt;/a&gt; for more details).</source>
          <target state="translated">IPv6 소켓 주소 는 트래픽 클래스, 플로우 레이블 및 범위 ID를 포함하는 필드뿐만 아니라 &lt;a href=&quot;struct.ipv6addr&quot;&gt;Ipv6 주소&lt;/a&gt; , 16 비트 포트 번호로 구성됩니다 (자세한 내용은 &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553, 섹션 3.3&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="5e75cacea0fd3b6b14f0b4659c3bb43c233b1bc1" translate="yes" xml:space="preserve">
          <source>Identifier patterns</source>
          <target state="translated">식별자 패턴</target>
        </trans-unit>
        <trans-unit id="b14c125598d88502f5133a3afc5b567be6c1a2d3" translate="yes" xml:space="preserve">
          <source>Identifier patterns bind the value they match to a variable. The identifier must be unique within the pattern. The variable will shadow any variables of the same name in scope. The scope of the new binding depends on the context of where the pattern is used (such as a &lt;code&gt;let&lt;/code&gt; binding or a &lt;code&gt;match&lt;/code&gt; arm).</source>
          <target state="translated">식별자 패턴은 변수와 일치하는 값을 바인딩합니다. 식별자는 패턴 내에서 고유해야합니다. 변수는 범위 내에서 같은 이름의 변수를 음영 처리합니다. 새 바인딩의 범위는 패턴이 사용되는 컨텍스트 (예 : &lt;code&gt;let&lt;/code&gt; 바인딩 또는 &lt;code&gt;match&lt;/code&gt; arm)에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="649d2864df18704de32e689e69e63f2483e8b76e" translate="yes" xml:space="preserve">
          <source>Identifiers</source>
          <target state="translated">Identifiers</target>
        </trans-unit>
        <trans-unit id="a28f079910fa2727e597ae224c9f3f8cbc529307" translate="yes" xml:space="preserve">
          <source>Identify duplicate code.</source>
          <target state="translated">중복 코드를 식별하십시오.</target>
        </trans-unit>
        <trans-unit id="9f0d27a694b397b392e1c0d4d2916d104a364051" translate="yes" xml:space="preserve">
          <source>If &amp;epsilon; &amp;isin; LAST(&lt;code&gt;uu ...&lt;/code&gt;), then LAST(M) = LAST(&lt;code&gt;tt&lt;/code&gt;) &amp;cup; (LAST(&lt;code&gt;uu ...&lt;/code&gt;) \ { &amp;epsilon; }).</source>
          <target state="translated">&amp;epsilon; &amp;isin; LAST ( &lt;code&gt;uu ...&lt;/code&gt; )이면 LAST (M) = LAST ( &lt;code&gt;tt&lt;/code&gt; ) &amp;cup; (LAST ( &lt;code&gt;uu ...&lt;/code&gt; ) \ {&amp;epsilon;})입니다.</target>
        </trans-unit>
        <trans-unit id="534c6252638c1abdb91099e943245185bc915d7e" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.pathbuf#method.extension&quot;&gt;&lt;code&gt;self.extension&lt;/code&gt;&lt;/a&gt; is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the extension is added; otherwise it is replaced.</source>
          <target state="translated">경우 &lt;a href=&quot;struct.pathbuf#method.extension&quot;&gt; &lt;code&gt;self.extension&lt;/code&gt; 가&lt;/a&gt; 없습니다 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , 확장이 추가됩니다; 그렇지 않으면 교체됩니다.</target>
        </trans-unit>
        <trans-unit id="01a2757701a9695cb15304f9062c5f6fe543e1d0" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.pathbuf#method.file_name&quot;&gt;&lt;code&gt;self.file_name&lt;/code&gt;&lt;/a&gt; was &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, this is equivalent to pushing &lt;code&gt;file_name&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.pathbuf#method.file_name&quot;&gt; &lt;code&gt;self.file_name&lt;/code&gt; &lt;/a&gt; 이 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 인 경우 &lt;code&gt;file_name&lt;/code&gt; 을 누르는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="4087b2407c0523ab27c22d69edd0438fe2e50815" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'static&lt;/code&gt; is used for any lifetime bound then &lt;code&gt;'static&lt;/code&gt; is used.</source>
          <target state="translated">경우 &lt;code&gt;'static&lt;/code&gt; 다음 바인딩 어떤 일생에 사용되는 &lt;code&gt;'static&lt;/code&gt; 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2299b8f75754da8b24aff81fd36ddb6f9ef90ec2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;..&lt;/code&gt; is not used, it is required to match all fields:</source>
          <target state="translated">경우 &lt;code&gt;..&lt;/code&gt; 가 사용되지 않는, 모든 필드와 일치해야합니다 :</target>
        </trans-unit>
        <trans-unit id="f3b5be9d19759c8147145d2b3c53249ad84a368f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;.create_new(true)&lt;/code&gt; is set, &lt;a href=&quot;#method.create&quot;&gt;&lt;code&gt;.create()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.truncate&quot;&gt;&lt;code&gt;.truncate()&lt;/code&gt;&lt;/a&gt; are ignored.</source>
          <target state="translated">경우 &lt;code&gt;.create_new(true)&lt;/code&gt; 설정, &lt;a href=&quot;#method.create&quot;&gt; &lt;code&gt;.create()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#method.truncate&quot;&gt; &lt;code&gt;.truncate()&lt;/code&gt; &lt;/a&gt; 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="2ad0cab5b7af8f6f0d802cf376de0871197cd2fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Complete&lt;/code&gt; is returned then the generator has completely finished with the value provided. It is invalid for the generator to be resumed again.</source>
          <target state="translated">경우 &lt;code&gt;Complete&lt;/code&gt; IS 다음 반환 된 발전기는 완전히 제공되는 값으로 완료되었습니다. 생성기가 다시 재개 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ac903d4e63c4f5e9053aaefd66eff84df6124016" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ForeignTrait&lt;/code&gt; is a trait defined in some external crate &lt;code&gt;foo&lt;/code&gt;, then the following trait &lt;code&gt;impl&lt;/code&gt; is an error:</source>
          <target state="translated">&lt;code&gt;ForeignTrait&lt;/code&gt; 이 일부 외부 상자 &lt;code&gt;foo&lt;/code&gt; 에 정의 된 특성 인 경우 다음 특성 &lt;code&gt;impl&lt;/code&gt; 이 오류입니다.</target>
        </trans-unit>
        <trans-unit id="c1fd05b3bcfcb4d8ea20c271d94557cb3d13d52d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hello, world!&lt;/code&gt; did print, congratulations! You&amp;rsquo;ve officially written a Rust program. That makes you a Rust programmer&amp;mdash;welcome!</source>
          <target state="translated">만약 &lt;code&gt;Hello, world!&lt;/code&gt; 인쇄, 축하했다! 당신은 공식적으로 Rust 프로그램을 작성했습니다. 그것은 당신을 Rust 프로그래머로 만듭니다 &amp;ndash; 환영합니다!</target>
        </trans-unit>
        <trans-unit id="5b6043d2d9c915604d4623e46635d9a9a232a5d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt;, two &lt;code&gt;Arc&lt;/code&gt;s that point to the same value are always equal.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 또한 구현 &lt;code&gt;Eq&lt;/code&gt; 개의 &lt;code&gt;Arc&lt;/code&gt; 동일한 값의 시점은 항상 동일하다.</target>
        </trans-unit>
        <trans-unit id="ec82a111c6092884516e8540e107bb1534de81bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt;, two &lt;code&gt;Arc&lt;/code&gt;s that point to the same value are never unequal.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 또한 구현 &lt;code&gt;Eq&lt;/code&gt; 개의 &lt;code&gt;Arc&lt;/code&gt; 동일한 값의 시점 불평등 결코.</target>
        </trans-unit>
        <trans-unit id="21cc57c8697439642e0504b016521d59698b000c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt;, two &lt;code&gt;Rc&lt;/code&gt;s that point to the same value are always equal.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 또한 구현 &lt;code&gt;Eq&lt;/code&gt; 두 &lt;code&gt;Rc&lt;/code&gt; 를 동일한 값의 시점은 항상 동일하다.</target>
        </trans-unit>
        <trans-unit id="79dd19ff096e35ccdc8e2994890606a0f2b80c5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt;, two &lt;code&gt;Rc&lt;/code&gt;s that point to the same value are never unequal.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 또한 구현 &lt;code&gt;Eq&lt;/code&gt; 두 &lt;code&gt;Rc&lt;/code&gt; 를 같은 값으로 그 시점의 불평등 결코.</target>
        </trans-unit>
        <trans-unit id="2aad32f156303fc5a2bc63ee3fa5dad5cc0ca6bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Deref&amp;lt;Target = U&amp;gt;&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt; is a value of type &lt;code&gt;T&lt;/code&gt;, then:</source>
          <target state="translated">만약 &lt;code&gt;T&lt;/code&gt; 의 구현 &lt;code&gt;Deref&amp;lt;Target = U&amp;gt;&lt;/code&gt; , 및 &lt;code&gt;x&lt;/code&gt; 형의 값 &lt;code&gt;T&lt;/code&gt; 는 다음 :</target>
        </trans-unit>
        <trans-unit id="95d72afe0884b2306850bd095670df15024528ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;DerefMut&amp;lt;Target = U&amp;gt;&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt; is a value of type &lt;code&gt;T&lt;/code&gt;, then:</source>
          <target state="translated">만약 &lt;code&gt;T&lt;/code&gt; 의 구현 &lt;code&gt;DerefMut&amp;lt;Target = U&amp;gt;&lt;/code&gt; , 및 &lt;code&gt;x&lt;/code&gt; 형의 값 &lt;code&gt;T&lt;/code&gt; 는 다음 :</target>
        </trans-unit>
        <trans-unit id="8b6c90a17aa05dcdf98932b5f27171dbd2de33f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is FFI-safe, then so is &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 FFI-안전하고 그렇습니다 &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49964ef73f44405d2ac7053108ae2569108b6abf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is not an enum, calling this function will not result in undefined behavior, but the return value is unspecified.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 가 열거되지 않습니다,이 함수를 호출하면 정의되지 않은 동작이 발생할 수 있지만, 반환 값은 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f81fb6d8ced60b0cd6b321f060ac68460468aa0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addr&lt;/code&gt; yields multiple addresses, &lt;code&gt;bind&lt;/code&gt; will be attempted with each of the addresses until one succeeds and returns the listener. If none of the addresses succeed in creating a listener, the error returned from the last attempt (the last address) is returned.</source>
          <target state="translated">경우 &lt;code&gt;addr&lt;/code&gt; 수율 여러 개의 주소, &lt;code&gt;bind&lt;/code&gt; 하나가 성공하고 수신기를 리턴 할 때까지 각 주소로 시도됩니다. 리스너 작성에 성공한 주소가 없으면 마지막 시도 (마지막 주소)에서 리턴 된 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="7f3c01a32008b38d419c728226a54e01a7d962fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addr&lt;/code&gt; yields multiple addresses, &lt;code&gt;bind&lt;/code&gt; will be attempted with each of the addresses until one succeeds and returns the socket. If none of the addresses succeed in creating a socket, the error returned from the last attempt (the last address) is returned.</source>
          <target state="translated">경우 &lt;code&gt;addr&lt;/code&gt; 수율 여러 개의 주소, &lt;code&gt;bind&lt;/code&gt; 하나가 성공하고 소켓을 반환 할 때까지 각 주소로 시도됩니다. 소켓 생성에 성공한 주소가 없으면 마지막 시도 (마지막 주소)에서 반환 된 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0c53eddc64c1e675eb29f0974efda41f4b33efd1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addr&lt;/code&gt; yields multiple addresses, &lt;code&gt;connect&lt;/code&gt; will be attempted with each of the addresses until a connection is successful. If none of the addresses result in a successful connection, the error returned from the last connection attempt (the last address) is returned.</source>
          <target state="translated">경우 &lt;code&gt;addr&lt;/code&gt; 여러 개의 주소를 얻을 수, &lt;code&gt;connect&lt;/code&gt; 연결이 성공할 때까지 각 주소로 시도됩니다. 어떤 주소도 연결에 성공하지 못하면 마지막 연결 시도 (마지막 주소)에서 반환 된 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="07f5c20249e5fa3260da27a7df45155885f3dd08" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addr&lt;/code&gt; yields multiple addresses, &lt;code&gt;connect&lt;/code&gt; will be attempted with each of the addresses until the underlying OS function returns no error. Note that usually, a successful &lt;code&gt;connect&lt;/code&gt; call does not specify that there is a remote server listening on the port, rather, such an error would only be detected after the first send. If the OS returns an error for each of the specified addresses, the error returned from the last connection attempt (the last address) is returned.</source>
          <target state="translated">경우 &lt;code&gt;addr&lt;/code&gt; 수율 여러 개의 주소, &lt;code&gt;connect&lt;/code&gt; 기본 OS 기능 반환하지 오류 때까지 각 주소로 시도됩니다. 일반적으로 성공적인 &lt;code&gt;connect&lt;/code&gt; 호출은 포트에서 수신 대기중인 원격 서버가 있음을 지정하지 않으며, 이러한 오류는 첫 번째 송신 후에 만 ​​감지됩니다. OS가 지정된 각 주소에 대해 오류를 반환하면 마지막 연결 시도 (마지막 주소)에서 반환 된 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="acfc45781f88c4761baec8897c0ca4cf03d5120d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is not a prefix of &lt;code&gt;self&lt;/code&gt; (i.e., &lt;a href=&quot;#method.starts_with&quot;&gt;&lt;code&gt;starts_with&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;), returns &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; 가 &lt;code&gt;self&lt;/code&gt; 의 접두사가 아닌 경우 (즉, &lt;a href=&quot;#method.starts_with&quot;&gt; &lt;code&gt;starts_with&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;false&lt;/code&gt; 를 리턴 함) &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; 을&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="1b461fd46fdb1045defa6bb08692a4c2d8f4230a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; start with the bytes in &lt;code&gt;get&lt;/code&gt;, it means we&amp;rsquo;ve received some other request. We&amp;rsquo;ll add code to the &lt;code&gt;else&lt;/code&gt; block in a moment to respond to all other requests.</source>
          <target state="translated">경우 &lt;code&gt;buffer&lt;/code&gt; 않습니다 &lt;em&gt;하지&lt;/em&gt; 의 바이트로 시작 &lt;code&gt;get&lt;/code&gt; , 우리가 다른 요청을 받았습니다 의미한다. 잠시 후 &lt;code&gt;else&lt;/code&gt; 블록에 코드를 추가하여 다른 모든 요청에 ​​응답합니다.</target>
        </trans-unit>
        <trans-unit id="bb805fab8234f3a9b02923cee55ae95cc32673cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;k&lt;/code&gt; is greater than &lt;code&gt;len()&lt;/code&gt;. Note that &lt;code&gt;k == len()&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic and is a no-op rotation.</source>
          <target state="translated">경우 &lt;code&gt;k&lt;/code&gt; 보다 큰 &lt;code&gt;len()&lt;/code&gt; . 참고 &lt;code&gt;k == len()&lt;/code&gt; 않는다 &lt;em&gt;하지&lt;/em&gt; 당황 무 조작 회전이다.</target>
        </trans-unit>
        <trans-unit id="f9e7bcd447817a79430b03e0a66dfa67f1d0816a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; is greater than the &lt;code&gt;VecDeque&lt;/code&gt;'s current length, this has no effect.</source>
          <target state="translated">경우 &lt;code&gt;len&lt;/code&gt; 보다 큰 &lt;code&gt;VecDeque&lt;/code&gt; 의 현재 길이,이 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3d4f7e3b9010f5f85b09ea6a7879139a55bd516a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; is greater than the vector's current length, this has no effect.</source>
          <target state="translated">경우 &lt;code&gt;len&lt;/code&gt; 벡터의 현재 길이보다 큰 경우,이 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1cf8419e86a3170a30c5b069909ed1f0302b608f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mid&lt;/code&gt; is greater than &lt;code&gt;len()&lt;/code&gt;. Note that &lt;code&gt;mid == len()&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic and is a no-op rotation.</source>
          <target state="translated">경우 &lt;code&gt;mid&lt;/code&gt; 보다 큰 &lt;code&gt;len()&lt;/code&gt; . 참고 &lt;code&gt;mid == len()&lt;/code&gt; 않습니다 &lt;em&gt;하지&lt;/em&gt; 당황을하고, 무 조작 회전이다.</target>
        </trans-unit>
        <trans-unit id="5a6e0913f28771cf69b8d16954b1cc061c4e770a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; substrings are returned, the last substring (the &lt;code&gt;n&lt;/code&gt;th substring) will contain the remainder of the string.</source>
          <target state="translated">경우 &lt;code&gt;n&lt;/code&gt; 개의 문자열이 반환, 마지막 문자열합니다 ( &lt;code&gt;n&lt;/code&gt; 번째 문자열은) 문자열의 나머지 부분을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="705ee37ce1f2981d5872c521c36f0e77f17b6dcb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is greater than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is extended by the difference, with each additional slot filled with &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;Default::default()&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;new_len&lt;/code&gt; is less than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is simply truncated.</source>
          <target state="translated">경우 &lt;code&gt;new_len&lt;/code&gt; 이 보다 큰 &lt;code&gt;len&lt;/code&gt; 의 &lt;code&gt;Vec&lt;/code&gt; 가득 각각의 추가 슬롯, 차이에 의해 확장되는 &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt; &lt;code&gt;Default::default()&lt;/code&gt; &lt;/a&gt; . 경우 &lt;code&gt;new_len&lt;/code&gt; 이 적은보다 &lt;code&gt;len&lt;/code&gt; 의 &lt;code&gt;Vec&lt;/code&gt; 단순히 잘립니다.</target>
        </trans-unit>
        <trans-unit id="ad28de2b804b7bf236f81edae0db607218d0ac6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is greater than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is extended by the difference, with each additional slot filled with &lt;code&gt;value&lt;/code&gt;. If &lt;code&gt;new_len&lt;/code&gt; is less than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is simply truncated.</source>
          <target state="translated">경우 &lt;code&gt;new_len&lt;/code&gt; 가 보다 큰 &lt;code&gt;len&lt;/code&gt; 의 &lt;code&gt;Vec&lt;/code&gt; 가득 각 추가 슬롯이 차이에 의해 확장 &lt;code&gt;value&lt;/code&gt; . 경우 &lt;code&gt;new_len&lt;/code&gt; 이 적은보다 &lt;code&gt;len&lt;/code&gt; 의 &lt;code&gt;Vec&lt;/code&gt; 단순히 잘립니다.</target>
        </trans-unit>
        <trans-unit id="c6a8aec540c240a392d0120d56829bf27ca15fcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is greater than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is extended by the difference, with each additional slot filled with the result of calling the closure &lt;code&gt;f&lt;/code&gt;. The return values from &lt;code&gt;f&lt;/code&gt; will end up in the &lt;code&gt;Vec&lt;/code&gt; in the order they have been generated.</source>
          <target state="translated">경우 &lt;code&gt;new_len&lt;/code&gt; 가 보다 큰 &lt;code&gt;len&lt;/code&gt; 의 &lt;code&gt;Vec&lt;/code&gt; 폐쇄 호출의 결과로 채워진 각 추가 슬롯이 차이에 의해 확장 &lt;code&gt;f&lt;/code&gt; . &lt;code&gt;f&lt;/code&gt; 의 반환 값 은 &lt;code&gt;Vec&lt;/code&gt; 에서 생성 된 순서대로 끝납니다 .</target>
        </trans-unit>
        <trans-unit id="57261354a67401e0b42f57fdd95ec00fffeda84c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is greater than the string's current length, this has no effect.</source>
          <target state="translated">경우 &lt;code&gt;new_len&lt;/code&gt; 이 문자열의 현재 길이보다 큰이는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8e6148a2ee667e899f4bb89c993862e7efe20971" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is less than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is simply truncated.</source>
          <target state="translated">경우 &lt;code&gt;new_len&lt;/code&gt; 이 적은보다 &lt;code&gt;len&lt;/code&gt; 의 &lt;code&gt;Vec&lt;/code&gt; 단순히 잘립니다.</target>
        </trans-unit>
        <trans-unit id="abb4fe85675ce478754ece04841053fa5e5c6a3e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num&lt;/code&gt; had been &lt;code&gt;Some(10)&lt;/code&gt; instead, the match guard in the first arm would have been false because 10 is not less than 5. Rust would then go to the second arm, which would match because the second arm doesn&amp;rsquo;t have a match guard and therefore matches any &lt;code&gt;Some&lt;/code&gt; variant.</source>
          <target state="translated">경우 &lt;code&gt;num&lt;/code&gt; 있었던 &lt;code&gt;Some(10)&lt;/code&gt; 대신에 제 1 암의 경기 가드했을 거짓 (10)는 녹는 다음 두 번째 팔이 없기 때문에 일치하는 것이다, 제 2 암에 갈 것이라고 이하 5보다이기 때문에 성냥 가드 따라서 &lt;code&gt;Some&lt;/code&gt; 변형 과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="b32b62b97ea86132915f7572c0fc7127777250a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;parse&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; able to turn the string into a number, it will return an &lt;code&gt;Err&lt;/code&gt; value that contains more information about the error. The &lt;code&gt;Err&lt;/code&gt; value does not match the &lt;code&gt;Ok(num)&lt;/code&gt; pattern in the first &lt;code&gt;match&lt;/code&gt; arm, but it does match the &lt;code&gt;Err(_)&lt;/code&gt; pattern in the second arm. The underscore, &lt;code&gt;_&lt;/code&gt;, is a catchall value; in this example, we&amp;rsquo;re saying we want to match all &lt;code&gt;Err&lt;/code&gt; values, no matter what information they have inside them. So the program will execute the second arm&amp;rsquo;s code, &lt;code&gt;continue&lt;/code&gt;, which tells the program to go to the next iteration of the &lt;code&gt;loop&lt;/code&gt; and ask for another guess. So, effectively, the program ignores all errors that &lt;code&gt;parse&lt;/code&gt; might encounter!</source>
          <target state="translated">경우 &lt;code&gt;parse&lt;/code&gt; 입니다 &lt;em&gt;하지&lt;/em&gt; 문자열을 숫자로 켤 수, 그것은 반환 &lt;code&gt;Err&lt;/code&gt; 오류에 대한 자세한 정보가 포함되어 값입니다. &lt;code&gt;Err&lt;/code&gt; 값이 일치하지 &lt;code&gt;Ok(num)&lt;/code&gt; 제의 패턴 &lt;code&gt;match&lt;/code&gt; 아암 있지만 일치 않는 &lt;code&gt;Err(_)&lt;/code&gt; 제 2 아암의 패턴. 밑줄 &lt;code&gt;_&lt;/code&gt; 은 포괄적 인 값입니다. 이 예에서는 어떤 정보가 내부에 있는지에 상관없이 모든 &lt;code&gt;Err&lt;/code&gt; 값 을 일치 시키려고 합니다. 따라서 프로그램은 두 번째 암의 코드를 &lt;code&gt;continue&lt;/code&gt; 실행 하여 &lt;code&gt;loop&lt;/code&gt; 의 다음 반복으로 이동하도록 프로그램에 지시합니다.또 다른 추측을 요청하십시오. 따라서 프로그램은 &lt;code&gt;parse&lt;/code&gt; 할 수있는 모든 오류를 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="40e42a10c4724a12b9d742d659e990cc0a90590e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;parse&lt;/code&gt; is able to successfully turn the string into a number, it will return an &lt;code&gt;Ok&lt;/code&gt; value that contains the resulting number. That &lt;code&gt;Ok&lt;/code&gt; value will match the first arm&amp;rsquo;s pattern, and the &lt;code&gt;match&lt;/code&gt; expression will just return the &lt;code&gt;num&lt;/code&gt; value that &lt;code&gt;parse&lt;/code&gt; produced and put inside the &lt;code&gt;Ok&lt;/code&gt; value. That number will end up right where we want it in the new &lt;code&gt;guess&lt;/code&gt; variable we&amp;rsquo;re creating.</source>
          <target state="translated">경우 &lt;code&gt;parse&lt;/code&gt; 성공적으로 문자열을 숫자로 설정 할 수 있습니다, 그것은 반환됩니다 &lt;code&gt;Ok&lt;/code&gt; 결과 수를 포함 값입니다. 해당 &lt;code&gt;Ok&lt;/code&gt; 값은 첫 번째 팔의 패턴과 &lt;code&gt;match&lt;/code&gt; 하며 일치 표현식은 &lt;code&gt;parse&lt;/code&gt; 하여 &lt;code&gt;Ok&lt;/code&gt; 값 안에 넣은 &lt;code&gt;num&lt;/code&gt; 값만 반환합니다 . 그 숫자는 우리가 만들고 있는 새로운 &lt;code&gt;guess&lt;/code&gt; 변수 에서 원하는 위치에있게됩니다 .</target>
        </trans-unit>
        <trans-unit id="a78bf9200d69e40c9e7de71399af9b041b718f05" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is absolute, it replaces the current path.</source>
          <target state="translated">경우 &lt;code&gt;path&lt;/code&gt; 절대, 현재의 경로를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="73e4e153f655353974f6e6f2c813b5b3915ef1cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pointer&lt;/code&gt; dereferences to an &lt;code&gt;Unpin&lt;/code&gt; type, &lt;code&gt;Pin::new&lt;/code&gt; should be used instead.</source>
          <target state="translated">&lt;code&gt;pointer&lt;/code&gt; 가 &lt;code&gt;Unpin&lt;/code&gt; 유형을 참조하지 않으면 대신 &lt;code&gt;Pin::new&lt;/code&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ac86606be8e832102840dbcc4086a1857a76012b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;program&lt;/code&gt; is not an absolute path, the &lt;code&gt;PATH&lt;/code&gt; will be searched in an OS-defined way.</source>
          <target state="translated">&lt;code&gt;program&lt;/code&gt; 이 절대 경로가 아닌 경우 &lt;code&gt;PATH&lt;/code&gt; 는 OS 정의 방식으로 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="a98fb4db9993bb6b25528d614208eeeedcf64c3a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self &amp;lt;= other&lt;/code&gt;: &lt;code&gt;0:0&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;self &amp;lt;= other&lt;/code&gt; : &lt;code&gt;0:0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="822bf36472f08b6c870c4a7eb729d5b79300c331" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self.value&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, the code calls the closure stored in &lt;code&gt;self.calculation&lt;/code&gt;, saves the result in &lt;code&gt;self.value&lt;/code&gt; for future use, and returns the value as well.</source>
          <target state="translated">경우 &lt;code&gt;self.value&lt;/code&gt; 가 없습니다 &lt;code&gt;None&lt;/code&gt; , 코드에 저장된 폐쇄 호출 &lt;code&gt;self.calculation&lt;/code&gt; 을 ,에 결과를 저장 &lt;code&gt;self.value&lt;/code&gt; 향후 사용을 위해, 그리고뿐만 아니라 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0f62f6b36639e7064e0402d98d3c38179c58dd42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; already meets the prescribed alignment, then returns &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;self&lt;/code&gt; 이미 규정 된 정렬을 충족 한 후 반환 &lt;code&gt;self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14fb52988b52fdaf20fd6eb41395b17915e1caaa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, this will return 0.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 가 &lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;Weak::new&lt;/code&gt; &lt;/a&gt; 사용하여 작성된 경우 0을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ffe2ed689988d142674d1aa54b3aa925c7f0ceb1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, this will return 0. If not, the returned value is at least 1, since &lt;code&gt;self&lt;/code&gt; still points to the value.</source>
          <target state="translated">경우 &lt;code&gt;self&lt;/code&gt; 사용하여 만든 &lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;Weak::new&lt;/code&gt; &lt;/a&gt; 되지, 반환 값이 있기 때문에, 적어도 한 경우,이 0을 반환합니다 &lt;code&gt;self&lt;/code&gt; 가치에 아직 점.</target>
        </trans-unit>
        <trans-unit id="f7cf04a558af40a8692e8d38e72f630ad0f921d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, this will return &lt;code&gt;None&lt;/code&gt;. If not, the returned value is at least 1, since &lt;code&gt;self&lt;/code&gt; still points to the value.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 가 &lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;Weak::new&lt;/code&gt; &lt;/a&gt; 사용하여 생성 된 경우 &lt;code&gt;None&lt;/code&gt; 이 반환 됩니다. 그렇지 않은 경우 &lt;code&gt;self&lt;/code&gt; 는 여전히 값을 가리 키 므로 리턴 된 값은 1 이상 입니다.</target>
        </trans-unit>
        <trans-unit id="8ab90cc43346ebf820e0570ac8953d279713fad0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;some_option_value&lt;/code&gt; was a &lt;code&gt;None&lt;/code&gt; value, it would fail to match the pattern &lt;code&gt;Some(x)&lt;/code&gt;, meaning the pattern is refutable. However, the &lt;code&gt;let&lt;/code&gt; statement can only accept an irrefutable pattern because there is nothing valid the code can do with a &lt;code&gt;None&lt;/code&gt; value. At compile time, Rust will complain that we&amp;rsquo;ve tried to use a refutable pattern where an irrefutable pattern is required:</source>
          <target state="translated">경우 &lt;code&gt;some_option_value&lt;/code&gt; 이 했다 &lt;code&gt;None&lt;/code&gt; 값이이 패턴과 일치하지 않을 것이라고 &lt;code&gt;Some(x)&lt;/code&gt; 패턴을 의미하는 것은 논박이다. 그러나 &lt;code&gt;let&lt;/code&gt; 문은 코드가 &lt;code&gt;None&lt;/code&gt; 값으로 수행 할 수있는 유효한 것이 없기 때문에 반박 할 수없는 패턴 만 허용 합니다. 컴파일 타임에 Rust는 반박 할 수없는 패턴이 필요한 반박 가능한 패턴을 사용하려했다고 불평합니다.</target>
        </trans-unit>
        <trans-unit id="7912a0b36bd857714b86c8f65975fd42323403e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; does not implement &lt;code&gt;Copy&lt;/code&gt;, use &lt;a href=&quot;#method.clone_from_slice&quot;&gt;&lt;code&gt;clone_from_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;src&lt;/code&gt; 구현하지 않습니다 &lt;code&gt;Copy&lt;/code&gt; 사용 &lt;a href=&quot;#method.clone_from_slice&quot;&gt; &lt;code&gt;clone_from_slice&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d89aaab24b69c1dc1835d5c53542bd5dee44e824" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; implements &lt;code&gt;Copy&lt;/code&gt;, it can be more performant to use &lt;a href=&quot;#method.copy_from_slice&quot;&gt;&lt;code&gt;copy_from_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;src&lt;/code&gt; 가 구현 &lt;code&gt;Copy&lt;/code&gt; , 그것은 사용에 더 확대됨에 될 수 &lt;a href=&quot;#method.copy_from_slice&quot;&gt; &lt;code&gt;copy_from_slice&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e2f26bdddcd85ded44fb8dcca9f30dea327428d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; had been a &lt;code&gt;None&lt;/code&gt; value instead of &lt;code&gt;Some(5)&lt;/code&gt;, the patterns in the first two arms wouldn&amp;rsquo;t have matched, so the value would have matched to the underscore. We didn&amp;rsquo;t introduce the &lt;code&gt;x&lt;/code&gt; variable in the pattern of the underscore arm, so the &lt;code&gt;x&lt;/code&gt; in the expression is still the outer &lt;code&gt;x&lt;/code&gt; that hasn&amp;rsquo;t been shadowed. In this hypothetical case, the &lt;code&gt;match&lt;/code&gt; would print &lt;code&gt;Default case, x = None&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 는 있었다 &lt;code&gt;None&lt;/code&gt; 값 대신 &lt;code&gt;Some(5)&lt;/code&gt; 값은 밑줄에 일치하는 것, 그래서 처음 두 팔에 패턴이 일치하지 것이다. 밑줄의 패턴에 &lt;code&gt;x&lt;/code&gt; 변수를 도입하지 않았 으므로 표현식 의 &lt;code&gt;x&lt;/code&gt; 는 여전히 음영 처리되지 않은 외부 &lt;code&gt;x&lt;/code&gt; 입니다. 이 가상의 경우, &lt;code&gt;match&lt;/code&gt; 는 &lt;code&gt;Default case, x = None&lt;/code&gt; 인쇄 합니다.</target>
        </trans-unit>
        <trans-unit id="18bf4b6aafae989a7516ceac94bb945e71eddb6d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more convenient than using the &lt;code&gt;|&lt;/code&gt; operator to express the same idea; instead of &lt;code&gt;1...5&lt;/code&gt;, we would have to specify &lt;code&gt;1 | 2 | 3 | 4 | 5&lt;/code&gt; if we used &lt;code&gt;|&lt;/code&gt;. Specifying a range is much shorter, especially if we want to match, say, any number between 1 and 1,000!</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 1, 2, 3, 4, 또는 5이고, 제 1 아암이 일치한다. 이 구문은 &lt;code&gt;|&lt;/code&gt; 같은 생각을 표현하는 연산자; 대신 &lt;code&gt;1...5&lt;/code&gt; , 우리는 지정해야 &lt;code&gt;1 | 2 | 3 | 4 | 5&lt;/code&gt; 를 사용한 경우 &lt;code&gt;|&lt;/code&gt; . 범위를 지정하는 것이 훨씬 짧습니다. 특히 1에서 1,000 사이의 숫자를 일치시키려는 경우 더욱 그렇습니다!</target>
        </trans-unit>
        <trans-unit id="cb2cf548505fabb01a736215a09d7eb4359e58a1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;main.rs&lt;/em&gt; was your Hello, world! program, this line would print &lt;code&gt;Hello, world!&lt;/code&gt; to your terminal.</source>
          <target state="translated">&lt;em&gt;main.rs&lt;/em&gt; 가 당신의 Hello, world 라면 ! 프로그램,이 줄은 &lt;code&gt;Hello, world!&lt;/code&gt; 터미널에.</target>
        </trans-unit>
        <trans-unit id="d9079a0efb2b14490cdc2479436c152fdb5fa1c2" translate="yes" xml:space="preserve">
          <source>If Rust code &lt;em&gt;does&lt;/em&gt; need to look into those strings, it can convert them to valid UTF-8, possibly lossily, by substituting invalid sequences with &lt;a href=&quot;../../../char/constant.replacement_character&quot;&gt;&lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt;&lt;/a&gt;, as is conventionally done in other Rust APIs that deal with string encodings.</source>
          <target state="translated">Rust 코드 &lt;em&gt;가&lt;/em&gt; 해당 문자열을 조사해야하는 경우 문자열 인코딩을 처리하는 다른 Rust API에서 일반적으로 수행되는 것과 같이 &lt;a href=&quot;../../../char/constant.replacement_character&quot;&gt; &lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt; 로&lt;/a&gt; 유효하지 않은 시퀀스를 대체하여 유실 한 UTF-8로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="197312fbd3b9939e66c78499e206ee75ae2c0258" translate="yes" xml:space="preserve">
          <source>If Rust didn&amp;rsquo;t implement deref coercion, we would have to write the code in Listing 15-13 instead of the code in Listing 15-12 to call &lt;code&gt;hello&lt;/code&gt; with a value of type &lt;code&gt;&amp;amp;MyBox&amp;lt;String&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Rust가 역 참조 강제를 구현하지 않았다면 Listing 15-12의 코드 대신 Listing 15-13의 코드를 작성하여 &lt;code&gt;&amp;amp;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; 유형의 값으로 &lt;code&gt;hello&lt;/code&gt; 를 호출 해야한다 .</target>
        </trans-unit>
        <trans-unit id="56ff52226d48b491c91c2959c2741fe1a5e96b46" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Read&lt;/code&gt;er guarantees that it can work properly with uninitialized memory, it should call &lt;a href=&quot;struct.initializer#method.nop&quot;&gt;&lt;code&gt;Initializer::nop()&lt;/code&gt;&lt;/a&gt;. See the documentation for &lt;a href=&quot;struct.initializer&quot;&gt;&lt;code&gt;Initializer&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">경우 &lt;code&gt;Read&lt;/code&gt; 가 초기화되지 않은 메모리가 제대로 작동 할 수있는 어 보장, 그것은 호출해야 &lt;a href=&quot;struct.initializer#method.nop&quot;&gt; &lt;code&gt;Initializer::nop()&lt;/code&gt; &lt;/a&gt; . 자세한 내용은 &lt;a href=&quot;struct.initializer&quot;&gt; &lt;code&gt;Initializer&lt;/code&gt; &lt;/a&gt; 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="6f382719afa245fe22b4489961298212f0dd9d4d" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;String&lt;/code&gt; has enough capacity, adding elements to it will not re-allocate. For example, consider this program:</source>
          <target state="translated">경우 &lt;code&gt;String&lt;/code&gt; 을 다시 할당하지 않습니다 그것에 요소를 추가 충분한 용량을 가지고 있습니다. 예를 들어 다음 프로그램을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="9fa35bc4f2bce6280405afd54339a1d6674f6de7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Vacant(entry)&lt;/code&gt; is yielded, then the key &lt;em&gt;was not&lt;/em&gt; found. In this case the only valid operation is to &lt;code&gt;insert&lt;/code&gt; a value into the entry. When this is done, the vacant entry is consumed and converted into a mutable reference to the value that was inserted. This allows for further manipulation of the value beyond the lifetime of the search itself. This is useful if complex logic needs to be performed on the value regardless of whether the value was just inserted.</source>
          <target state="translated">&lt;code&gt;Vacant(entry)&lt;/code&gt; 이 나오면 키 &lt;em&gt;를&lt;/em&gt; 찾지 &lt;em&gt;못한 것&lt;/em&gt; 입니다. 이 경우 유효한 조작은 항목에 값 을 &lt;code&gt;insert&lt;/code&gt; 하는 것입니다. 이 작업이 완료되면 비어있는 항목이 소비되고 삽입 된 값에 대한 변경 가능한 참조로 변환됩니다. 이를 통해 검색 자체의 수명을 넘어서 값을 추가로 조작 할 수 있습니다. 값이 삽입되었는지 여부에 관계없이 값에 대해 복잡한 논리를 수행해야하는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="cda87c5518b5b9027cd10d7cda1ac0257185a449" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Vec&lt;/code&gt;&lt;em&gt;has&lt;/em&gt; allocated memory, then the memory it points to is on the heap (as defined by the allocator Rust is configured to use by default), and its pointer points to &lt;a href=&quot;struct.vec#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; initialized, contiguous elements in order (what you would see if you coerced it to a slice), followed by &lt;a href=&quot;struct.vec#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt;&lt;code&gt;-&lt;/code&gt;&lt;a href=&quot;struct.vec#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; logically uninitialized, contiguous elements.</source>
          <target state="translated">&lt;code&gt;Vec&lt;/code&gt; &lt;em&gt;이&lt;/em&gt; 메모리 &lt;em&gt;를&lt;/em&gt; 할당 한 경우 할당 된 메모리가 힙에 있고 (할당 자 Rust가 기본적으로 사용하도록 정의 된대로) 포인터가 &lt;a href=&quot;struct.vec#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt; 초기화되고 연속 된 요소를 순서대로 가리 킵니다. 슬라이스로 강제 변환 한 다음)&lt;a href=&quot;struct.vec#method.capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt; &lt;code&gt;-&lt;/code&gt; &lt;a href=&quot;struct.vec#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt; 논리적으로 초기화되지 않은, 연속적인 요소.</target>
        </trans-unit>
        <trans-unit id="8c0ce05d92f7c594a3a90bea8f233df56be2f1d6" translate="yes" xml:space="preserve">
          <source>If a &lt;em&gt;new&lt;/em&gt; file is created because it does not yet exist and &lt;code&gt;.create(true)&lt;/code&gt; or &lt;code&gt;.create_new(true)&lt;/code&gt; are specified, the new file is given the attributes declared with &lt;code&gt;.attributes()&lt;/code&gt;.</source>
          <target state="translated">아직 존재하지 않아서 &lt;em&gt;새&lt;/em&gt; 파일을 만든 경우 &lt;code&gt;.create(true)&lt;/code&gt; 또는 &lt;code&gt;.create_new(true)&lt;/code&gt; 지정되어, 새로운 파일이 속성으로 선언 주어진다 &lt;code&gt;.attributes()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16c8daede20373077d8ff711c94e64a0b59b67bb" translate="yes" xml:space="preserve">
          <source>If a binding pattern does not explicitly have &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;ref mut&lt;/code&gt;, or &lt;code&gt;mut&lt;/code&gt;, then it uses the &lt;em&gt;default binding mode&lt;/em&gt; to determine how the variable is bound. The default binding mode starts in &quot;move&quot; mode which uses move semantics. When matching a pattern, the compiler starts from the outside of the pattern and works inwards. Each time a reference is matched using a non-reference pattern, it will automatically dereference the value and update the default binding mode. References will set the default binding mode to &lt;code&gt;ref&lt;/code&gt;. Mutable references will set the mode to &lt;code&gt;ref mut&lt;/code&gt; unless the mode is already &lt;code&gt;ref&lt;/code&gt; in which case it remains &lt;code&gt;ref&lt;/code&gt;. If the automatically dereferenced value is still a reference, it is dereferenced and this process repeats.</source>
          <target state="translated">바인딩 패턴이 명시되어 있지 않은 경우 &lt;code&gt;ref&lt;/code&gt; , &lt;code&gt;ref mut&lt;/code&gt; , 또는 &lt;code&gt;mut&lt;/code&gt; , 다음은 사용 &lt;em&gt;기본 바인딩 모드&lt;/em&gt; 변수가 바인딩되는 방법을 결정합니다. 기본 바인딩 모드는 이동 의미론을 사용하는 &quot;이동&quot;모드에서 시작합니다. 패턴을 일치시킬 때 컴파일러는 패턴 외부에서 시작하여 안쪽으로 작동합니다. 비 참조 패턴을 사용하여 참조를 일치시킬 때마다 자동으로 값을 역 참조하고 기본 바인딩 모드를 업데이트합니다. 참조는 기본 바인딩 모드를 &lt;code&gt;ref&lt;/code&gt; 로 설정합니다 . 변경 가능한 참조로 모드를 설정합니다 &lt;code&gt;ref mut&lt;/code&gt; 모드가 이미하지 않는 한 &lt;code&gt;ref&lt;/code&gt; 이 경우에 남아 &lt;code&gt;ref&lt;/code&gt; . 자동 역 참조 된 값이 여전히 참조 인 경우 역 참조되고이 프로세스가 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="7cce383f10beb57ed085cf340ccb835736dad8de" translate="yes" xml:space="preserve">
          <source>If a character does not have a lowercase equivalent, the same character will be returned back by the iterator.</source>
          <target state="translated">문자에 소문자가 없으면 동일한 문자가 반복자에 의해 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ef2f005976fec5c6467e7bb3fc454eb0cb7f06ed" translate="yes" xml:space="preserve">
          <source>If a character does not have an uppercase equivalent, the same character will be returned back by the iterator.</source>
          <target state="translated">문자에 대문자가 없으면 동일한 문자가 반복자에 의해 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d0d13af4b33d582574dec6432db47608e7a6fcac" translate="yes" xml:space="preserve">
          <source>If a clean shutdown is needed it is recommended to only call this function at a known point where there are no more destructors left to run.</source>
          <target state="translated">클린 셧다운이 필요한 경우 더 이상 소멸자가 남아 있지 않은 알려진 지점에서만이 기능을 호출하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="90545bafc06a46b5933ce2daa0969b441705a55d" translate="yes" xml:space="preserve">
          <source>If a const function is called outside a &lt;a href=&quot;../const_eval#const-context&quot;&gt;const context&lt;/a&gt;, it is indistinguishable from any other function. You can freely do anything with a const function that you can do with a regular function.</source>
          <target state="translated">const 함수가 &lt;a href=&quot;../const_eval#const-context&quot;&gt;const 컨텍스트&lt;/a&gt; 외부에서 호출되면 다른 함수와 구별 할 수 없습니다. 정규 함수로 할 수있는 const 함수로 자유롭게 무엇이든 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba510c5879ea4cc171f31422ae04de034d50983c" translate="yes" xml:space="preserve">
          <source>If a destructor must be run manually, such as when implementing your own smart pointer, &lt;a href=&quot;../std/ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;std::ptr::drop_in_place&lt;/code&gt;&lt;/a&gt; can be used.</source>
          <target state="translated">자체 스마트 포인터를 구현할 때와 같이 소멸자를 수동으로 실행해야하는 경우 &lt;a href=&quot;../std/ptr/fn.drop_in_place&quot;&gt; &lt;code&gt;std::ptr::drop_in_place&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aac87c21fcf6474549d65e03ca36c8ec59d12740" translate="yes" xml:space="preserve">
          <source>If a dynamic library or an executable that is being dynamically linked is being produced, then the compiler will attempt to reconcile the available dependencies in either the rlib or dylib format to create a final product.</source>
          <target state="translated">동적 라이브러리 또는 동적으로 링크되는 실행 파일이 생성되는 경우 컴파일러는 사용 가능한 종속성을 rlib 또는 dylib 형식으로 조정하여 최종 제품을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b25b09268442abcdc7a1f9b2c36f533d27627828" translate="yes" xml:space="preserve">
          <source>If a file is opened with both read and append access, beware that after opening, and after every write, the position for reading may be set at the end of the file. So, before writing, save the current position (using &lt;a href=&quot;struct.file#method.seek&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;../io/enum.seekfrom&quot;&gt;&lt;code&gt;SeekFrom&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../io/enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(0))&lt;/code&gt;), and restore it before the next read.</source>
          <target state="translated">읽기 및 추가 액세스로 파일을 연 경우에는 파일을 연 후 및 모든 쓰기 후에 파일의 끝에서 읽을 위치를 설정할 수 있습니다. 따라서 쓰기 전에 현재 위치를 저장하고 ( &lt;a href=&quot;struct.file#method.seek&quot;&gt; &lt;code&gt;seek&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;../io/enum.seekfrom&quot;&gt; &lt;code&gt;SeekFrom&lt;/code&gt; &lt;/a&gt; &lt;code&gt;::&lt;/code&gt; &lt;a href=&quot;../io/enum.seekfrom#variant.Current&quot;&gt; &lt;code&gt;Current&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(0))&lt;/code&gt; 사용 ) 다음 읽기 전에 복원하십시오.</target>
        </trans-unit>
        <trans-unit id="7ae8e9b37b3fae0e90c2e27255beba504df5f00d" translate="yes" xml:space="preserve">
          <source>If a file is successfully opened with this option set it will truncate the file to 0 length if it already exists.</source>
          <target state="translated">이 옵션을 설정 한 상태에서 파일을 성공적으로 열면 파일이 이미 있으면 길이가 0으로 잘립니다.</target>
        </trans-unit>
        <trans-unit id="d0abbc43e6eb90b8c51d1b76b304256ddf0362aa" translate="yes" xml:space="preserve">
          <source>If a floating-point type can be &lt;em&gt;uniquely&lt;/em&gt; determined from the surrounding program context, the unsuffixed floating-point literal has that type.</source>
          <target state="translated">부동 소수점 유형이 &lt;em&gt;고유&lt;/em&gt; 할 수있는 경우&lt;em&gt;&lt;/em&gt;주변 프로그램 컨텍스트에서 판별 경우 접미사 부동 소수점 리터럴에 해당 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="04efa2d88cc29b968e806cf715e0ee4d0b695c80" translate="yes" xml:space="preserve">
          <source>If a language must have inheritance to be an object-oriented language, then Rust is not one. There is no way to define a struct that inherits the parent struct&amp;rsquo;s fields and method implementations. However, if you&amp;rsquo;re used to having inheritance in your programming toolbox, you can use other solutions in Rust, depending on your reason for reaching for inheritance in the first place.</source>
          <target state="translated">언어가 객체 지향 언어가되도록 상속을 받아야하는 경우 Rust는 언어가 아닙니다. 부모 구조체의 필드와 메소드 구현을 상속하는 구조체를 정의 할 방법이 없습니다. 그러나 프로그래밍 도구 상자에서 상속을받는 데 익숙한 경우 먼저 상속 이유에 따라 Rust에서 다른 솔루션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="442a02939139d9c59cef162a2647bac06f4e1997" translate="yes" xml:space="preserve">
          <source>If a method call fails in a test, you&amp;rsquo;d want the whole test to fail, even if that method isn&amp;rsquo;t the functionality under test. Because &lt;code&gt;panic!&lt;/code&gt; is how a test is marked as a failure, calling &lt;code&gt;unwrap&lt;/code&gt; or &lt;code&gt;expect&lt;/code&gt; is exactly what should happen.</source>
          <target state="translated">테스트에서 메소드 호출이 실패하면 해당 메소드가 테스트중인 기능이 아니더라도 전체 테스트에 실패 할 수 있습니다. &lt;code&gt;panic!&lt;/code&gt; 때문에 ! 테스트가 실패로 표시되는 방법입니다. &lt;code&gt;unwrap&lt;/code&gt; 또는 &lt;code&gt;expect&lt;/code&gt; 호출 하면 정확히 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9d96dca6a8141f4e31a24310383d3fa9b46a981c" translate="yes" xml:space="preserve">
          <source>If a new file is created as part of a &lt;code&gt;File::open_opts&lt;/code&gt; call then this specified &lt;code&gt;mode&lt;/code&gt; will be used as the permission bits for the new file. If no &lt;code&gt;mode&lt;/code&gt; is set, the default of &lt;code&gt;0o666&lt;/code&gt; will be used. The operating system masks out bits with the systems &lt;code&gt;umask&lt;/code&gt;, to produce the final permissions.</source>
          <target state="translated">&lt;code&gt;File::open_opts&lt;/code&gt; 호출의 일부로 새 파일이 작성되면 이 지정된 &lt;code&gt;mode&lt;/code&gt; 가 새 파일의 권한 비트로 사용됩니다. &lt;code&gt;mode&lt;/code&gt; 를 설정 하지 않으면 기본값 &lt;code&gt;0o666&lt;/code&gt; 이 사용됩니다. 운영 체제는 &lt;code&gt;umask&lt;/code&gt; 시스템으로 비트를 마스크 하여 최종 권한을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="edf29e89879313dc8e8b20d286c6fbf984a0c2ff" translate="yes" xml:space="preserve">
          <source>If a panic occurs in a named thread, the thread name will be printed in the panic message.</source>
          <target state="translated">명명 된 스레드에서 패닉이 발생하면 스레드 이름이 패닉 메시지에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="ae66f71517007a8faed7e8f14069d9743a8fc1d6" translate="yes" xml:space="preserve">
          <source>If a program contains arithmetic overflow, the programmer has made an error. In the following discussion, we maintain a distinction between arithmetic overflow and wrapping arithmetic. The first is erroneous, while the second is intentional.</source>
          <target state="translated">프로그램에 산술 오버플로가 포함되어 있으면 프로그래머가 오류를 범한 것입니다. 다음 논의에서, 우리는 산술 오버 플로우와 랩핑 산술의 구별을 유지합니다. 첫 번째는 잘못된 반면 두 번째는 의도적 인 것입니다.</target>
        </trans-unit>
        <trans-unit id="9ed92fa5e7088a3110b1cc9346594a14bbfacbbf" translate="yes" xml:space="preserve">
          <source>If a static item is declared with the &lt;code&gt;mut&lt;/code&gt; keyword, then it is allowed to be modified by the program. One of Rust's goals is to make concurrency bugs hard to run into, and this is obviously a very large source of race conditions or other bugs. For this reason, an &lt;code&gt;unsafe&lt;/code&gt; block is required when either reading or writing a mutable static variable. Care should be taken to ensure that modifications to a mutable static are safe with respect to other threads running in the same process.</source>
          <target state="translated">정적 키워드 가 &lt;code&gt;mut&lt;/code&gt; 키워드로 선언 되면 프로그램이이를 수정할 수 있습니다. Rust의 목표 중 하나는 동시성 버그가 발생하기 어렵게 만드는 것이며, 이는 경쟁 조건 또는 기타 버그의 매우 큰 원인입니다. 이러한 이유로, 가변 정적 변수를 읽거나 쓸 때 &lt;code&gt;unsafe&lt;/code&gt; 블록이 필요합니다. 동일한 프로세스에서 실행중인 다른 스레드와 관련하여 변경 가능한 정적에 대한 수정이 안전하도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="a1766ce77343ee3ad45def8d871224ac057e5320" translate="yes" xml:space="preserve">
          <source>If a static library is being produced, all upstream dependencies are required to be available in &lt;code&gt;rlib&lt;/code&gt; formats. This requirement stems from the reason that a dynamic library cannot be converted into a static format.</source>
          <target state="translated">정적 라이브러리가 생성되는 경우 모든 업스트림 종속성이 &lt;code&gt;rlib&lt;/code&gt; 에서 사용 가능해야합니다. 형식 . 이 요구 사항은 동적 라이브러리를 정적 형식으로 변환 할 수없는 이유에서 비롯됩니다.</target>
        </trans-unit>
        <trans-unit id="7bac0e8b6805f499b0c443af2ab6fa54c5aa649c" translate="yes" xml:space="preserve">
          <source>If a step is reached where there is more than one possible method, such as where generic methods or traits are considered the same, then it is a compiler error. These cases require a &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;disambiguating function call syntax&lt;/a&gt; for method and function invocation.</source>
          <target state="translated">일반 메소드 또는 특성이 동일한 것으로 간주되는 경우와 같이 둘 이상의 가능한 메소드가있는 단계에 도달하면 컴파일러 오류입니다. 이러한 경우 메소드 및 함수 호출을위한 &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;명확한 함수 호출 구문&lt;/a&gt; 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="7f3fff7995601b35f7065fae1e640e2f2eeb6214" translate="yes" xml:space="preserve">
          <source>If a string contains multiple contiguous separators, you will end up with empty strings in the output:</source>
          <target state="translated">문자열에 연속 된 여러 구분 기호가 포함되어 있으면 출력에 빈 문자열이 생깁니다.</target>
        </trans-unit>
        <trans-unit id="4ab14222518e8fb43884627c81d597c32a8700e2" translate="yes" xml:space="preserve">
          <source>If a type &lt;code&gt;Item&lt;/code&gt; has an associated type &lt;code&gt;Assoc&lt;/code&gt; from a trait &lt;code&gt;Trait&lt;/code&gt;, then &lt;code&gt;&amp;lt;Item as Trait&amp;gt;::Assoc&lt;/code&gt; is a type that is an alias of the type specified in the associated type definition. Furthermore, if &lt;code&gt;Item&lt;/code&gt; is a type parameter, then &lt;code&gt;Item::Assoc&lt;/code&gt; can be used in type parameters.</source>
          <target state="translated">유형 &lt;code&gt;Item&lt;/code&gt; 에 특성 &lt;code&gt;Trait&lt;/code&gt; 의 연관 유형 &lt;code&gt;Assoc&lt;/code&gt; 이있는 경우 &lt;code&gt;&amp;lt;Item as Trait&amp;gt;::Assoc&lt;/code&gt; 은 연관된 유형 정의에 지정된 유형의 별명 인 유형입니다. 또한 &lt;code&gt;Item&lt;/code&gt; 이 유형 매개 변수 인 경우 &lt;code&gt;Item::Assoc&lt;/code&gt; 을 형식 매개 변수에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98ce79152874ad30a4163310f54c79462c6fb1d7" translate="yes" xml:space="preserve">
          <source>If a type contains a &lt;code&gt;PhantomPinned&lt;/code&gt;, it will not implement &lt;code&gt;Unpin&lt;/code&gt; by default.</source>
          <target state="translated">유형에 &lt;code&gt;PhantomPinned&lt;/code&gt; 가 포함 된 경우 기본적으로 &lt;code&gt;Unpin&lt;/code&gt; 을 구현하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1433c5d355e130cd227bc3635eea7b7161e572f3" translate="yes" xml:space="preserve">
          <source>If all goes well, &lt;code&gt;Hello, world!&lt;/code&gt; should print to the terminal. Running &lt;code&gt;cargo build&lt;/code&gt; for the first time also causes Cargo to create a new file at the top level: &lt;em&gt;Cargo.lock&lt;/em&gt;. This file keeps track of the exact versions of dependencies in your project. This project doesn&amp;rsquo;t have dependencies, so the file is a bit sparse. You won&amp;rsquo;t ever need to change this file manually; Cargo manages its contents for you.</source>
          <target state="translated">모두 잘되면 &lt;code&gt;Hello, world!&lt;/code&gt; 터미널에 인쇄해야합니다. &lt;code&gt;cargo build&lt;/code&gt; 를 처음으로 실행 하면 Cargo는 최상위 레벨 &lt;em&gt;Cargo.lock에&lt;/em&gt; 새 파일을 작성합니다 . 이 파일은 프로젝트에서 정확한 버전의 종속성을 추적합니다. 이 프로젝트에는 종속성이 없으므로 파일이 약간 희박합니다. 이 파일을 수동으로 변경할 필요는 없습니다. 화물은 당신을 위해 그 내용을 관리합니다.</target>
        </trans-unit>
        <trans-unit id="5ace79993641886b01cac522412b514b142053ea" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;Alloc&lt;/code&gt; implementation chooses to return &lt;code&gt;Ok&lt;/code&gt; in this case (i.e., the pointer denotes a zero-sized inaccessible block) then that returned pointer must be considered &quot;currently allocated&quot;. On such an allocator, &lt;em&gt;all&lt;/em&gt; methods that take currently-allocated pointers as inputs must accept these zero-sized pointers, &lt;em&gt;without&lt;/em&gt; causing undefined behavior.</source>
          <target state="translated">경우 &lt;code&gt;Alloc&lt;/code&gt; 구현이 돌아 선택 &lt;code&gt;Ok&lt;/code&gt; 이 경우 반환 포인터가 &quot;현재 할당&quot;으로 간주해야한다고 다음 (즉, 포인터가 0 크기의 액세스 블록을 의미한다). 이러한 할당 자에서 현재 할당 된 포인터를 입력으로 사용하는 &lt;em&gt;모든&lt;/em&gt; 메서드는 정의되지 않은 동작 &lt;em&gt;을&lt;/em&gt; 발생 &lt;em&gt;시키지 않고&lt;/em&gt; 크기가 0 인 포인터를 수용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="766a342529319b1e212f056deacbe904859bc648" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;Err(e)&lt;/code&gt; result is returned, the value &lt;code&gt;e&lt;/code&gt; will be &quot;wrapped&quot; in the return type of the enclosing scope (which must itself implement &lt;code&gt;Try&lt;/code&gt;). Specifically, the value &lt;code&gt;X::from_error(From::from(e))&lt;/code&gt; is returned, where &lt;code&gt;X&lt;/code&gt; is the return type of the enclosing function.</source>
          <target state="translated">경우 &lt;code&gt;Err(e)&lt;/code&gt; 결과가 반환되는, 값 &lt;code&gt;e&lt;/code&gt; 바깥 쪽 범위의 리턴 타입 (그 자체가 구현해야하는 「랩」됩니다 &lt;code&gt;Try&lt;/code&gt; ). 특히 &lt;code&gt;X::from_error(From::from(e))&lt;/code&gt; 이 반환됩니다. 여기서 &lt;code&gt;X&lt;/code&gt; 는 둘러싸는 함수의 반환 유형입니다.</target>
        </trans-unit>
        <trans-unit id="d07fb8a7b5eba0666b8e8c43c71f4a92c4cff59d" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;Occupied(entry)&lt;/code&gt; is yielded, then the key &lt;em&gt;was&lt;/em&gt; found. In this case, the user has several options: they can &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;insert&lt;/code&gt; or &lt;code&gt;remove&lt;/code&gt; the value of the occupied entry. Additionally, they can convert the occupied entry into a mutable reference to its value, providing symmetry to the vacant &lt;code&gt;insert&lt;/code&gt; case.</source>
          <target state="translated">는 IF &lt;code&gt;Occupied(entry)&lt;/code&gt; 산출되고, 그 키를 &lt;em&gt;한&lt;/em&gt; 발견했다. 이 경우, 사용자는 여러 가지 옵션이 있습니다 : 그들은 수 있습니다 &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;insert&lt;/code&gt; 또는 &lt;code&gt;remove&lt;/code&gt; 점령 항목의 값을. 또한, 점유 된 항목을 해당 값에 대한 변경 가능한 참조로 변환하여 빈 &lt;code&gt;insert&lt;/code&gt; 케이스에 대칭을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6496ceefd96285c8c2e145eb325b81df30982dd9" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;rlib&lt;/code&gt; file is being produced, then there are no restrictions on what format the upstream dependencies are available in. It is simply required that all upstream dependencies be available for reading metadata from.</source>
          <target state="translated">는 IF &lt;code&gt;rlib&lt;/code&gt; 의 파일이 생성되고, 그 상류 종속성에서 사용할 수있는 형식을 무엇에 아무런 제한이 없습니다. 단순히 모든 업스트림 의존성에서 메타 데이터를 읽을 수있는 것이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c8e60161efc2f2d7cfcdc0d31414bc493321f65f" translate="yes" xml:space="preserve">
          <source>If an &lt;em&gt;existing&lt;/em&gt; file is opened with &lt;code&gt;.create(true).truncate(true)&lt;/code&gt;, its existing attributes are preserved and combined with the ones declared with &lt;code&gt;.attributes()&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;기존&lt;/em&gt; 파일이 열립니다 &lt;code&gt;.create(true).truncate(true)&lt;/code&gt; , 기존의 속성은 보존으로 선언 된 것들과 결합 &lt;code&gt;.attributes()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f270e545d597563858cae4afcff9e37ad4508d2c" translate="yes" xml:space="preserve">
          <source>If an I/O error is encountered then all bytes read so far will be present in &lt;code&gt;buf&lt;/code&gt; and its length will have been adjusted appropriately.</source>
          <target state="translated">I / O 오류가 발생하면 지금까지 읽은 모든 바이트가 &lt;code&gt;buf&lt;/code&gt; 에 있으며 길이가 적절하게 조정 된 것입니다.</target>
        </trans-unit>
        <trans-unit id="ace1a7d9bf9ec54c3308257f201a03fece98ab35" translate="yes" xml:space="preserve">
          <source>If an executable is being produced and the &lt;code&gt;-C prefer-dynamic&lt;/code&gt; flag is not specified, then dependencies are first attempted to be found in the &lt;code&gt;rlib&lt;/code&gt; format. If some dependencies are not available in an rlib format, then dynamic linking is attempted (see below).</source>
          <target state="translated">실행 파일이 생성되고 &lt;code&gt;-C prefer-dynamic&lt;/code&gt; 플래그가 지정되지 않은 경우 우선 &lt;code&gt;rlib&lt;/code&gt; 형식으로 종속성을 찾습니다 . rlib 형식으로 일부 종속성을 사용할 수없는 경우 동적 연결이 시도됩니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="5e13abdce3cf8ba0eee5f3efa1352739a357002e" translate="yes" xml:space="preserve">
          <source>If an impl has a generic parameter with the &lt;code&gt;#[may_dangle]&lt;/code&gt; attribute, then that impl must be declared as an `unsafe impl.</source>
          <target state="translated">impl에 &lt;code&gt;#[may_dangle]&lt;/code&gt; 속성 이있는 일반 매개 변수가있는 경우 해당 impl은 `안전하지 않은 impl로 선언되어야합니다.</target>
        </trans-unit>
        <trans-unit id="11945bca4b49d81520c3d9de6a4cbb63f81941bb" translate="yes" xml:space="preserve">
          <source>If an integer type can be &lt;em&gt;uniquely&lt;/em&gt; determined from the surrounding program context, the unsuffixed integer literal has that type.</source>
          <target state="translated">주변 프로그램 컨텍스트에서 정수 유형을 &lt;em&gt;고유하게&lt;/em&gt; 판별 할 수있는 경우 접미사없는 정수 리터럴이 해당 유형을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="39805e5d14d8cab59f3ec2eabeee9744560e1fb2" translate="yes" xml:space="preserve">
          <source>If an item is private, it may be accessed by the current module and its descendants.</source>
          <target state="translated">개인 항목 인 경우 현재 모듈과 해당 하위 항목에서 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07080131ca18f6d9e5b13a9d88dcf93cd9dc48cd" translate="yes" xml:space="preserve">
          <source>If an item is public, then it can be accessed externally from some module &lt;code&gt;m&lt;/code&gt; if you can access all the item's parent modules from &lt;code&gt;m&lt;/code&gt;. You can also potentially be able to name the item through re-exports. See below.</source>
          <target state="translated">항목이 공개되면, 다음은 몇 가지 모듈에서 외부에서 액세스 할 수 &lt;code&gt;m&lt;/code&gt; 당신은 모든 항목의 부모 모듈에 액세스 할 수 있는지 &lt;code&gt;m&lt;/code&gt; . 재수출을 통해 항목의 이름을 지정할 수도 있습니다. 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="63585324ac753447dc7a54f44e90a00d790fca2c" translate="yes" xml:space="preserve">
          <source>If another thread is active, the lock can still become poisoned at any time. You should not trust a &lt;code&gt;false&lt;/code&gt; value for program correctness without additional synchronization.</source>
          <target state="translated">다른 스레드가 활성화되어 있으면 언제든지 잠금 장치가 손상 될 수 있습니다. 추가 동기화없이 프로그램 정확성을 위해 &lt;code&gt;false&lt;/code&gt; 값을 신뢰해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="109588b2017fbb996d88327d5cc6be15dd8d4ba0" translate="yes" xml:space="preserve">
          <source>If another thread is active, the mutex can still become poisoned at any time. You should not trust a &lt;code&gt;false&lt;/code&gt; value for program correctness without additional synchronization.</source>
          <target state="translated">다른 스레드가 활성화되어 있으면 언제든지 뮤텍스가 중독 될 수 있습니다. 추가 동기화없이 프로그램 정확성을 위해 &lt;code&gt;false&lt;/code&gt; 값을 신뢰해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="e8114d3ac34051321d85f9acd763dd0f154fb356" translate="yes" xml:space="preserve">
          <source>If another user of this mutex panicked while holding the mutex, then this call will return an error instead.</source>
          <target state="translated">이 뮤텍스의 다른 사용자가 뮤텍스를 잡고있는 동안 당황한 경우이 호출은 대신 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="937c1840433dcebbb1b2c20629e7140489485c5e" translate="yes" xml:space="preserve">
          <source>If another user of this mutex panicked while holding the mutex, then this call will return an error once the mutex is acquired.</source>
          <target state="translated">이 뮤텍스의 다른 사용자가 뮤텍스를 잡고있는 동안 당황한 경우,이 호출은 뮤텍스가 획득되면 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="94a8b260ae2fd91c20d30826f0ac290f20d42663" translate="yes" xml:space="preserve">
          <source>If another user of this mutex panicked while holding the mutex, then this call will return failure if the mutex would otherwise be acquired.</source>
          <target state="translated">이 뮤텍스의 다른 사용자가 뮤텍스를 잡고있는 동안 당황한 경우, 뮤텍스를 획득하면이 호출은 실패를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b8a9fd6020c6344c3b4ec789d5cdc75685b6c76f" translate="yes" xml:space="preserve">
          <source>If any directory in the path specified by &lt;code&gt;path&lt;/code&gt; does not already exist and it could not be created otherwise. The specific error conditions for when a directory is being created (after it is determined to not exist) are outlined by &lt;a href=&quot;fn.create_dir&quot;&gt;&lt;code&gt;fs::create_dir&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경로에있는 디렉토리로 지정하면 &lt;code&gt;path&lt;/code&gt; 가 존재하지 않으며, 그렇지 않으면 만들 수 없습니다. 디렉토리가 생성 될 때 (존재하지 않는 것으로 확인 된 후)에 대한 특정 오류 조건은 &lt;a href=&quot;fn.create_dir&quot;&gt; &lt;code&gt;fs::create_dir&lt;/code&gt; &lt;/a&gt; 로 요약됩니다 .</target>
        </trans-unit>
        <trans-unit id="8c9733a4a8648c17f076f404425858c19e3e7e60" translate="yes" xml:space="preserve">
          <source>If any of the following conditions are violated, the result is Undefined Behavior:</source>
          <target state="translated">다음 조건 중 하나라도 위반하면 결과는 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="abfc6e25813ef681d155e66f1a056df288816b17" translate="yes" xml:space="preserve">
          <source>If any other read error is encountered then this function immediately returns. Any bytes which have already been read will be appended to &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">다른 읽기 오류가 발생하면이 함수는 즉시 반환합니다. 이미 읽은 바이트는 &lt;code&gt;buf&lt;/code&gt; 에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="dc672b538a09f0d8b7133f8175c1bdde7ae9dbbb" translate="yes" xml:space="preserve">
          <source>If any other read error is encountered then this function immediately returns. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">다른 읽기 오류가 발생하면이 함수는 즉시 반환합니다. 이 경우 &lt;code&gt;buf&lt;/code&gt; 의 내용 은 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ddacadc60603d21344f24b6aa894045e4936178f" translate="yes" xml:space="preserve">
          <source>If both do not exist, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762280(v=vs.85).aspx&quot;&gt;&lt;code&gt;GetUserProfileDirectory&lt;/code&gt;&lt;/a&gt; is used to return the path.</source>
          <target state="translated">둘 다 존재하지 않으면 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762280(v=vs.85).aspx&quot;&gt; &lt;code&gt;GetUserProfileDirectory&lt;/code&gt; &lt;/a&gt; 를 사용하여 경로를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7fce57c290d26a88e07f0e0c3e4758aa4174e90c" translate="yes" xml:space="preserve">
          <source>If compiled as a dylib, the resulting .so could then be linked to from a C library, and the function could be used as if it was from any other library.</source>
          <target state="translated">dylib로 컴파일 된 경우 결과 .so는 C 라이브러리에서 링크 될 수 있으며 다른 라이브러리에서 온 것처럼 함수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7b59b345b11e01a4787fa859ca6ad581aae3ad3" translate="yes" xml:space="preserve">
          <source>If either iterator returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; from the zipped iterator will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. If the first iterator returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;zip&lt;/code&gt; will short-circuit and &lt;code&gt;next&lt;/code&gt; will not be called on the second iterator.</source>
          <target state="translated">두 반복자를 반환하는 경우 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; 압축 된 반복자로부터 반환하지 않습니다 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; . 최초의 반복자를 반환하는 경우 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;zip&lt;/code&gt; 단락 것이다 &lt;code&gt;next&lt;/code&gt; 두 번째 반복자에 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="84103f8a5cb4506a8862655c59a4b3682ff15678" translate="yes" xml:space="preserve">
          <source>If enabled, multicast packets will be looped back to the local socket. Note that this may not have any affect on IPv6 sockets.</source>
          <target state="translated">활성화되면 멀티 캐스트 패킷이 로컬 소켓으로 루프백됩니다. IPv6 소켓에는 영향을 미치지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fb4d55515faf0167f284803093db70ba6bdf600" translate="yes" xml:space="preserve">
          <source>If encapsulation is a required aspect for a language to be considered object oriented, then Rust meets that requirement. The option to use &lt;code&gt;pub&lt;/code&gt; or not for different parts of code enables encapsulation of implementation details.</source>
          <target state="translated">언어가 객체 지향으로 간주되기 위해 캡슐화가 필수 요소 인 경우 Rust는 해당 요구 사항을 충족합니다. 다른 코드 부분에 &lt;code&gt;pub&lt;/code&gt; 을 사용 하거나 사용 하지 않는 옵션을 사용 하면 구현 세부 정보를 캡슐화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f88c3e80e7b4d154c2577f1e634c78e02c1c42d5" translate="yes" xml:space="preserve">
          <source>If every type inside a tuple implements one of the following traits, then a tuple itself also implements it.</source>
          <target state="translated">튜플 내부의 모든 유형이 다음 특성 중 하나를 구현하면 튜플 자체도이를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="b8129e0ab4f408174bb11267c05f089405b50c77" translate="yes" xml:space="preserve">
          <source>If generic code merely needs to work for all types that can provide a reference to related type &lt;code&gt;T&lt;/code&gt;, it is often better to use &lt;a href=&quot;../convert/trait.asref&quot;&gt;&lt;code&gt;AsRef&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; as more types can safely implement it.</source>
          <target state="translated">일반 코드가 관련 유형 &lt;code&gt;T&lt;/code&gt; 에 대한 참조를 제공 할 수있는 모든 유형에 &lt;a href=&quot;../convert/trait.asref&quot;&gt; &lt;code&gt;AsRef&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 경우 더 많은 유형이 안전하게 구현할 수 있으므로 AsRef &amp;lt;T&amp;gt; 를 사용 하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="57c986c219a8db1074aab149e63ad254d155df91" translate="yes" xml:space="preserve">
          <source>If given a position, returns a reference to the element at that position or &lt;code&gt;None&lt;/code&gt; if out of bounds.</source>
          <target state="translated">위치가 지정되면 해당 위치의 요소에 대한 참조를 리턴하거나 범위를 벗어난 경우 &lt;code&gt;None&lt;/code&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="0807d56f2c6d8607e36641ca45b2207a499de182" translate="yes" xml:space="preserve">
          <source>If given a range, returns the subslice corresponding to that range, or &lt;code&gt;None&lt;/code&gt; if out of bounds.</source>
          <target state="translated">범위가 지정되면 해당 범위에 해당하는 하위 슬라이스를 반환하거나 범위 를 벗어난 경우 &lt;code&gt;None&lt;/code&gt; 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c78c81075548342c17a3cb41f1d7c207afd16e82" translate="yes" xml:space="preserve">
          <source>If it does, add it to the list of values we&amp;rsquo;re returning.</source>
          <target state="translated">그렇다면 반환하는 값 목록에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="6eb8349ae4604f3200e1b12d72175fa1292b930e" translate="yes" xml:space="preserve">
          <source>If it doesn&amp;rsquo;t, do nothing.</source>
          <target state="translated">그렇지 않으면 아무 것도하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="9651a04b746a289895c0ff4ac7dbbd9c6c4bd1d9" translate="yes" xml:space="preserve">
          <source>If it is not possible to align the pointer, the implementation returns &lt;code&gt;usize::max_value()&lt;/code&gt;.</source>
          <target state="translated">포인터를 정렬 할 수 없으면 구현에서 &lt;code&gt;usize::max_value()&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="36c410707c8ca092b792e6807c748e0afad6b271" translate="yes" xml:space="preserve">
          <source>If it's possible, hand-monomorphize the code by writing the function for each possible type substitution. It's possible to use traits to do this cleanly, for example:</source>
          <target state="translated">가능하면 가능한 각 유형 대체에 대한 함수를 작성하여 코드를 수동으로 변형하십시오. 예를 들어 특성을 사용하여이를 명확하게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c4391f80fe19e3beba14af1b68f867a8deafde6" translate="yes" xml:space="preserve">
          <source>If necessary, you can circumvent this check using custom target specifications.</source>
          <target state="translated">필요한 경우 사용자 지정 대상 사양을 사용하여이 검사를 우회 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8e62341b0bd62d9e8cebd223a1dae7b6e2b460b" translate="yes" xml:space="preserve">
          <source>If neither of those rules apply, then the bounds on the trait are used:</source>
          <target state="translated">이러한 규칙 중 어느 것도 적용되지 않으면 특성의 경계가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f04e4c83d03462bae231d396fbd6bc133f04e581" translate="yes" xml:space="preserve">
          <source>If no custom hook is registered, the default hook will be returned.</source>
          <target state="translated">사용자 정의 후크가 등록되지 않은 경우 기본 후크가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="3ea6cae08b251d423319bdb503b4761220cd47ba" translate="yes" xml:space="preserve">
          <source>If no explicit implementation or negative implementation is written out for an auto trait for a given type, then the compiler implements it automatically according to the following rules:</source>
          <target state="translated">지정된 유형의 자동 특성에 대해 명시 적 구현 또는 부정적인 구현이 작성되지 않은 경우 컴파일러는 다음 규칙에 따라 자동 구현을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="902fe9b3f2f74127ecf6007749394b452c7a24b7" translate="yes" xml:space="preserve">
          <source>If one of the arguments is NaN, then the other argument is returned.</source>
          <target state="translated">인수 중 하나가 NaN이면 다른 인수가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="7ae9dd3ada03870a6668bdcb11d4ca3933501dde" translate="yes" xml:space="preserve">
          <source>If only some methods aren't object-safe, you can add a &lt;code&gt;where Self: Sized&lt;/code&gt; bound on them to mark them as explicitly unavailable to trait objects. The functionality will still be available to all other implementers, including &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; which is itself sized (assuming you &lt;code&gt;impl Trait for Box&amp;lt;Trait&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">일부 메서드 만 객체로부터 안전하지 않은 경우 특성 : 객체에 명시 적으로 사용할 수없는 것으로 표시하기 위해 &lt;code&gt;where Self: Sized&lt;/code&gt; 제한을 추가 할 수 있습니다 . &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; 과 같은 다른 모든 구현자는이 기능을 계속 사용할 수 있습니다 ( Box &amp;lt;Trait&amp;gt;의 &lt;code&gt;impl Trait for Box&amp;lt;Trait&amp;gt;&lt;/code&gt; 한다고 가정 ).</target>
        </trans-unit>
        <trans-unit id="df3400bc60a85af8ff3ace18e07d7c2d1864912a" translate="yes" xml:space="preserve">
          <source>If our project is a binary crate that only contains a &lt;em&gt;src/main.rs&lt;/em&gt; file and doesn&amp;rsquo;t have a &lt;em&gt;src/lib.rs&lt;/em&gt; file, we can&amp;rsquo;t create integration tests in the &lt;em&gt;tests&lt;/em&gt; directory and bring functions defined in the &lt;em&gt;src/main.rs&lt;/em&gt; file into scope with a &lt;code&gt;use&lt;/code&gt; statement. Only library crates expose functions that other crates can use; binary crates are meant to be run on their own.</source>
          <target state="translated">우리의 프로젝트 만이 포함 진 상자 인 경우 &lt;em&gt;SRC / main.rs의&lt;/em&gt; 파일을하고 있지 않습니다 &lt;em&gt;SRC / lib.rs의&lt;/em&gt; 파일을, 우리는에서 통합 테스트를 작성할 수 없습니다 &lt;em&gt;테스트를&lt;/em&gt; 디렉토리에 정의 가져 기능 &lt;em&gt;/ 주요 SRC를 .rs&lt;/em&gt; 는 &lt;code&gt;use&lt;/code&gt; 문을 사용 하여 범위 내에 있습니다 . 라이브러리 상자 만 다른 상자가 사용할 수있는 기능을 노출합니다. 이진 상자는 자체적으로 실행되도록되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6324fa8ddd04d1618f1aebd83b3f76a15a2cd28" translate="yes" xml:space="preserve">
          <source>If our requirements change, and we also need to be able to traverse from &lt;code&gt;Owner&lt;/code&gt; to &lt;code&gt;Gadget&lt;/code&gt;, we will run into problems. An &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointer from &lt;code&gt;Owner&lt;/code&gt; to &lt;code&gt;Gadget&lt;/code&gt; introduces a cycle between the values. This means that their reference counts can never reach 0, and the values will remain allocated forever: a memory leak. In order to get around this, we can use &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers.</source>
          <target state="translated">요구 사항이 변경되고 &lt;code&gt;Owner&lt;/code&gt; 에서 &lt;code&gt;Gadget&lt;/code&gt; 으로 이동할 수 있어야하는 경우 문제가 발생합니다. &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; 에서 포인터 &lt;code&gt;Owner&lt;/code&gt; 에 &lt;code&gt;Gadget&lt;/code&gt; 는 값 사이에주기를 도입합니다. 이는 참조 카운트가 0에 도달 할 수 없으며 메모리 누출이라는 ​​값이 영원히 할당 된 상태로 유지됨을 의미합니다. 이 문제를 해결하기 위해 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 포인터를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9b786199b10d931840d1086948f15c121bb97b51" translate="yes" xml:space="preserve">
          <source>If parsing succeeds, return the value inside &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;, otherwise when the string is ill-formatted return an error specific to the inside &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;. The error type is specific to implementation of the trait.</source>
          <target state="translated">구문 분석에 성공하면 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; 안에 값을 반환하고 , 그렇지 않으면 문자열 형식이 잘못된 경우 내부에 특정한 오류를 반환&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; 에&lt;/a&gt;. 오류 유형은 특성의 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1260ea15bf2742af82873380ef5cdc057469a6e9" translate="yes" xml:space="preserve">
          <source>If set, this option disables the Nagle algorithm. This means that segments are always sent as soon as possible, even if there is only a small amount of data. When not set, data is buffered until there is a sufficient amount to send out, thereby avoiding the frequent sending of small packets.</source>
          <target state="translated">설정된 경우이 옵션은 Nagle 알고리즘을 비활성화합니다. 즉, 적은 양의 데이터 만 있더라도 세그먼트는 가능한 한 빨리 전송됩니다. 설정하지 않으면 데이터를 보낼 양이 충분해질 때까지 데이터가 버퍼링되므로 작은 패킷이 자주 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0161295a4165e472097a556bd12e3cb8153ce739" translate="yes" xml:space="preserve">
          <source>If several elements are equally maximum, the last element is returned. If the iterator is empty, &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">여러 요소가 동일하게 최대 인 경우 마지막 요소가 반환됩니다. 반복자가 비어 있으면 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="949e58f9ba98c6ec3b36a7ff32fc3bb4b305461a" translate="yes" xml:space="preserve">
          <source>If several elements are equally minimum, the first element is returned. If the iterator is empty, &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">여러 요소가 동일하게 최소 인 경우 첫 번째 요소가 리턴됩니다. 반복자가 비어 있으면 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b831b3eb60862f2e083acd74777a5de0ed02dd83" translate="yes" xml:space="preserve">
          <source>If someone calls your code and passes in values that don&amp;rsquo;t make sense, the best choice might be to call &lt;code&gt;panic!&lt;/code&gt; and alert the person using your library to the bug in their code so they can fix it during development. Similarly, &lt;code&gt;panic!&lt;/code&gt; is often appropriate if you&amp;rsquo;re calling external code that is out of your control and it returns an invalid state that you have no way of fixing.</source>
          <target state="translated">누군가 코드를 호출하고 의미가 맞지 않는 값을 전달하면 &lt;code&gt;panic!&lt;/code&gt; 을 호출하는 것이 가장 좋습니다 ! 라이브러리를 사용하는 사람에게 코드의 버그를 알려 주어 개발 중에 수정할 수 있도록합니다. 비슷하게, &lt;code&gt;panic!&lt;/code&gt; 제어 할 수없는 외부 코드를 호출하고 수정 방법이없는 잘못된 상태를 반환하는 경우가 종종 있습니다.</target>
        </trans-unit>
        <trans-unit id="acb94f3e0ba146c655ce1db4be8cf7e52d6ff088" translate="yes" xml:space="preserve">
          <source>If someone using our library decides to implement a &lt;code&gt;SelectBox&lt;/code&gt; struct that has &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, and &lt;code&gt;options&lt;/code&gt; fields, they implement the &lt;code&gt;Draw&lt;/code&gt; trait on the &lt;code&gt;SelectBox&lt;/code&gt; type as well, as shown in Listing 17-8:</source>
          <target state="translated">우리의 라이브러리를 사용하여 누군가가 구현하기로 결정하면 &lt;code&gt;SelectBox&lt;/code&gt; 가지고 구조체 &lt;code&gt;width&lt;/code&gt; , &lt;code&gt;height&lt;/code&gt; , 및 &lt;code&gt;options&lt;/code&gt; 필드를 그들은 구현 &lt;code&gt;Draw&lt;/code&gt; 상의 특성 &lt;code&gt;SelectBox&lt;/code&gt; Listing 17-8에 표시된 것처럼 유형에서도 .</target>
        </trans-unit>
        <trans-unit id="c3e301e4e887fd636487b5cc6eb192ded20f6d8f" translate="yes" xml:space="preserve">
          <source>If successful, &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; is returned where the duration represents the amount of time elapsed from the specified measurement to this one.</source>
          <target state="translated">성공하면 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; 이 반환되며 여기서 지속 시간은 지정된 측정에서이 측정까지 경과 한 시간을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="89f232794c16a32779f42828429fca7b54b7471f" translate="yes" xml:space="preserve">
          <source>If successful, this function returns the number of bytes which were read and appended to &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">성공하면이 함수는 &lt;code&gt;buf&lt;/code&gt; 에 읽고 추가 된 바이트 수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="dbb9443efd5c60b83bc142aff81add19921534e6" translate="yes" xml:space="preserve">
          <source>If successful, this function will return the total number of bytes read.</source>
          <target state="translated">성공하면이 함수는 읽은 총 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8f3b4d7781f3d86f3d03470464550aa348524451" translate="yes" xml:space="preserve">
          <source>If taking ownership is not an option, using indices can work too:</source>
          <target state="translated">소유권을 얻는 것이 옵션이 아닌 경우 인덱스를 사용하는 것도 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf999049465c29583e4954eb5930504df7197d78" translate="yes" xml:space="preserve">
          <source>If that field has type &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt;, then &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; implements &lt;code&gt;Unsized&amp;lt;Bar&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">해당 필드의 유형이 &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; 인 경우 &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; 는 &lt;code&gt;Unsized&amp;lt;Bar&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="9156e468bccd98925a16dabd42948c9bf77880b3" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; is disconnected while trying to &lt;a href=&quot;struct.sender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;struct.sender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; method will return a &lt;a href=&quot;struct.senderror&quot;&gt;&lt;code&gt;SendError&lt;/code&gt;&lt;/a&gt;. Similarly, if the &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt; is disconnected while trying to &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; method will return a &lt;a href=&quot;struct.recverror&quot;&gt;&lt;code&gt;RecvError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt; 하는 동안 연결이 끊어 &lt;a href=&quot;struct.sender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; 와 함께 &lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;struct.sender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; 방법은 반환 &lt;a href=&quot;struct.senderror&quot;&gt; &lt;code&gt;SendError&lt;/code&gt; &lt;/a&gt; . 마찬가지로 &lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt; 를 시도하는 동안 &lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt; 연결이 끊어 지면 &lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt; 메서드는 &lt;a href=&quot;struct.recverror&quot;&gt; &lt;code&gt;RecvError&lt;/code&gt; &lt;/a&gt; 를 반환합니다 . .</target>
        </trans-unit>
        <trans-unit id="84c875b11ce397c9d5300f965f6f873d7aacf46f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;documentation&lt;/code&gt; environment variable is not defined, you'll get the following error:</source>
          <target state="translated">는 IF &lt;code&gt;documentation&lt;/code&gt; 환경 변수가 정의되지 않으며, 다음과 같은 오류가 발생합니다 :</target>
        </trans-unit>
        <trans-unit id="772ba2d0efb42bb291361897234d8c41bb1fcad0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;move&lt;/code&gt; keyword is used, then all captures are by move or, for &lt;code&gt;Copy&lt;/code&gt; types, by copy, regardless of whether a borrow would work. The &lt;code&gt;move&lt;/code&gt; keyword is usually used to allow the closure to outlive the captured values, such as if the closure is being returned or used to spawn a new thread.</source>
          <target state="translated">는 IF &lt;code&gt;move&lt;/code&gt; 키워드를 사용, 모든 캡처를 위해, 이동에 의해 또는 &lt;code&gt;Copy&lt;/code&gt; 유형, 복사에 의해 관계없이의 차용이 작동할지 여부. &lt;code&gt;move&lt;/code&gt; 키워드는 일반적으로 폐쇄는 폐쇄 반품 새로운 스레드를 생성하는 데 사용되는 경우로 캡처 한 값을, 오래 살 수 있도록하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9d0e8d596c36d8fd761ca63dbd3e067a9bd6e058" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;panic!&lt;/code&gt; macro from the &lt;code&gt;core&lt;/code&gt; crate (not from &lt;code&gt;std&lt;/code&gt;) was used with a formatting string and some additional arguments, returns that message ready to be used for example with &lt;a href=&quot;../fmt/fn.write&quot;&gt;&lt;code&gt;fmt::write&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">경우] &lt;code&gt;panic!&lt;/code&gt; &lt;code&gt;core&lt;/code&gt; 크레이트의 매크로 ( &lt;code&gt;std&lt;/code&gt; 가 아닌 )가 형식화 문자열 및 일부 추가 인수와 함께 사용되었으며, 예를 들어 &lt;a href=&quot;../fmt/fn.write&quot;&gt; &lt;code&gt;fmt::write&lt;/code&gt; &lt;/a&gt; 와 함께 사용할 수있는 메시지를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1aa7728f06aa3a7a4db7dd1c33587c7078d8308d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;push_str&lt;/code&gt; method took ownership of &lt;code&gt;s2&lt;/code&gt;, we wouldn&amp;rsquo;t be able to print its value on the last line. However, this code works as we&amp;rsquo;d expect!</source>
          <target state="translated">는 IF &lt;code&gt;push_str&lt;/code&gt; 의 방법은 소유권했다 &lt;code&gt;s2&lt;/code&gt; , 우리는 마지막 줄에 그 값을 인쇄 할 수 없습니다. 그러나이 코드는 예상대로 작동합니다!</target>
        </trans-unit>
        <trans-unit id="dced1236ce3e008b86324aaba64ac8eb311fb832" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;self&lt;/code&gt; parameter is prefixed with &lt;code&gt;mut&lt;/code&gt;, it becomes a mutable variable, similar to regular parameters using a &lt;code&gt;mut&lt;/code&gt;&lt;a href=&quot;../patterns#identifier-patterns&quot;&gt;identifier pattern&lt;/a&gt;. For example:</source>
          <target state="translated">상기 중간 &lt;code&gt;self&lt;/code&gt; 파라미터 접두어 &lt;code&gt;mut&lt;/code&gt; , 그것을 사용하여 일반 파라미터 유사한 가변 변수된다 &lt;code&gt;mut&lt;/code&gt; &lt;a href=&quot;../patterns#identifier-patterns&quot;&gt;식별자 패턴&lt;/a&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7d8f23d79fbc7e291c341b29a3b5a67aa2ad2d40" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;size&lt;/code&gt; is less than the current file's size, then the file will be shrunk. If it is greater than the current file's size, then the file will be extended to &lt;code&gt;size&lt;/code&gt; and have all of the intermediate data filled in with 0s.</source>
          <target state="translated">경우 &lt;code&gt;size&lt;/code&gt; 작은 현재 파일의 크기보다, 다음 파일이 수축 될 것입니다. 그것은 현재 파일의 크기보다 큰 경우, 파일이 확장 될 것입니다 &lt;code&gt;size&lt;/code&gt; 와 0으로 채워 중간 데이터를 모두 가지고있다.</target>
        </trans-unit>
        <trans-unit id="d57ee1700b4eb4f8d7a231756f83fc0d2f0976ae" translate="yes" xml:space="preserve">
          <source>If the access could not be granted at this time, then &lt;code&gt;Err&lt;/code&gt; is returned. Otherwise, an RAII guard is returned which will release the shared access when it is dropped.</source>
          <target state="translated">이때 액세스 권한을 부여 할 수 없으면 &lt;code&gt;Err&lt;/code&gt; 이 리턴됩니다. 그렇지 않으면 RAII 가드가 리턴되어 공유 액세스가 삭제 될 때 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="21bd5a18cb6b77fd8278b94aa3db19219a263b12" translate="yes" xml:space="preserve">
          <source>If the actual type neither requires drop glue nor implements &lt;code&gt;Copy&lt;/code&gt;, then may return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">실제 유형이 드롭 접착제를 필요로하거나 &lt;code&gt;Copy&lt;/code&gt; 를 구현하지 않으면 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 를 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc42b30b1c7732695b4b3457f14e9c116c60ba57" translate="yes" xml:space="preserve">
          <source>If the address different between the two pointers is not a multiple of &lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; then the result of the division is rounded towards zero.</source>
          <target state="translated">두 포인터간에 다른 주소가 &lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; 의 배수가 아닌 경우 나누기 결과는 0으로 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="521a07de2e3c6e68db23d9d0aa394b57d65a9c91" translate="yes" xml:space="preserve">
          <source>If the array has 32 or fewer elements (see above), you can also use the array reference's &lt;a href=&quot;iter/trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; implementation:</source>
          <target state="translated">배열에 32 개 이하의 요소가있는 경우 (위 참조) 배열 참조의 &lt;a href=&quot;iter/trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt; 구현을 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cfb58ffddaf17c8830de11935999affae3277e66" translate="yes" xml:space="preserve">
          <source>If the author information that Cargo obtained from your environment is not correct, fix that in the file and save it again.</source>
          <target state="translated">Cargo가 사용자 환경에서 얻은 작성자 정보가 올바르지 않은 경우 파일에서 수정 한 후 다시 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="a413f73c6a00e8ec27d7656a64c0041d810a18fb" translate="yes" xml:space="preserve">
          <source>If the capacity overflows, or the allocator reports a failure, then an error is returned.</source>
          <target state="translated">용량이 초과되거나 할당자가 실패를보고하면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d22b2ac0a0ad8bf3c9d2af95eda6c6dcbfb7f5e8" translate="yes" xml:space="preserve">
          <source>If the child has exited, then &lt;code&gt;Ok(Some(status))&lt;/code&gt; is returned. If the exit status is not available at this time then &lt;code&gt;Ok(None)&lt;/code&gt; is returned. If an error occurs, then that error is returned.</source>
          <target state="translated">자식이 종료되면 &lt;code&gt;Ok(Some(status))&lt;/code&gt; 가 반환됩니다. 현재 종료 상태를 사용할 수 없으면 &lt;code&gt;Ok(None)&lt;/code&gt; 이 반환됩니다. 오류가 발생하면 해당 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="c11de405bba2eb95a67f5ddf98e8d367a826811a" translate="yes" xml:space="preserve">
          <source>If the child thread panics, &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned with the parameter given to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자식 스레드 패닉 이 &lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic&lt;/code&gt; &lt;/a&gt; 하면 panic에 지정된 매개 변수와 함께 &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 이 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="611996f7840618a761ac96c392b8f31568d8ec31" translate="yes" xml:space="preserve">
          <source>If the closure can't outlive the value being moved, try using a reference rather than moving:</source>
          <target state="translated">클로저가 이동중인 값보다 오래 지속될 수없는 경우 이동하는 대신 참조를 사용해보십시오.</target>
        </trans-unit>
        <trans-unit id="0f3013a1be5e1908d0fd59aee1eeb2a1559501d9" translate="yes" xml:space="preserve">
          <source>If the closure returns &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(element)&lt;/code&gt;&lt;/a&gt;, then that element is returned.</source>
          <target state="translated">클로저가 &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(element)&lt;/code&gt; &lt;/a&gt; 반환하면 해당 요소가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="bb67b7c500cdec79f1ce3d7841c806209783608e" translate="yes" xml:space="preserve">
          <source>If the closure returns true, then the element is removed and yielded. If the closure returns false, the element will remain in the list and will not be yielded by the iterator.</source>
          <target state="translated">클로저가 true를 반환하면 요소가 제거되고 생성됩니다. 클로저가 false를 반환하면 요소는 목록에 유지되며 반복자에 의해 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6dd010d31dbb3764b4ed75ed86f6e32953c1d0d8" translate="yes" xml:space="preserve">
          <source>If the closure returns true, then the element is removed and yielded. If the closure returns false, the element will remain in the vector and will not be yielded by the iterator.</source>
          <target state="translated">클로저가 true를 반환하면 요소가 제거되고 생성됩니다. 클로저가 false를 반환하면 요소는 벡터에 남아 있고 반복자에 의해 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="31dba64d7d22c597dfce03fd7cdb2b9f96c2ab94" translate="yes" xml:space="preserve">
          <source>If the contents of the &lt;code&gt;CStr&lt;/code&gt; are valid UTF-8 data, this function will return a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../borrow/enum.cow#variant.Borrowed&quot;&gt;&lt;code&gt;Borrowed&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;[&lt;code&gt;&amp;amp;str&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt; with the corresponding [&lt;code&gt;&amp;amp;str&lt;/code&gt;] slice. Otherwise, it will replace any invalid UTF-8 sequences with &lt;a href=&quot;../char/constant.replacement_character&quot;&gt;&lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt;&lt;/a&gt; and return a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../borrow/enum.cow#variant.Owned&quot;&gt;&lt;code&gt;Owned&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; with the result.</source>
          <target state="translated">&lt;code&gt;CStr&lt;/code&gt; 의 내용 이 유효한 UTF-8 데이터 인 경우이 함수는 해당 [ &lt;code&gt;&amp;amp;str&lt;/code&gt; ] 슬라이스 와 함께 &lt;a href=&quot;../borrow/enum.cow&quot;&gt; &lt;code&gt;Cow&lt;/code&gt; &lt;/a&gt; &lt;code&gt;::&lt;/code&gt; &lt;a href=&quot;../borrow/enum.cow#variant.Borrowed&quot;&gt; &lt;code&gt;Borrowed&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; [ &lt;code&gt;&amp;amp;str&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt; 를 리턴합니다 . 그렇지 않으면 유효하지 않은 UTF-8 시퀀스를 &lt;a href=&quot;../char/constant.replacement_character&quot;&gt; &lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt; 로&lt;/a&gt; 바꾸고 &lt;a href=&quot;../borrow/enum.cow&quot;&gt; &lt;code&gt;Cow&lt;/code&gt; &lt;/a&gt; &lt;code&gt;::&lt;/code&gt; &lt;a href=&quot;../borrow/enum.cow#variant.Owned&quot;&gt; &lt;code&gt;Owned&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; 를 결과와 함께 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="db9461413b5ee9b4f01c463f0ad906b75913f24c" translate="yes" xml:space="preserve">
          <source>If the contents of the &lt;code&gt;CStr&lt;/code&gt; are valid UTF-8 data, this function will return the corresponding &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; slice. Otherwise, it will return an error with details of where UTF-8 validation failed.</source>
          <target state="translated">&lt;code&gt;CStr&lt;/code&gt; 의 내용 이 유효한 UTF-8 데이터 인 경우이 함수는 해당 &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; 슬라이스를 리턴합니다 . 그렇지 않으면 UTF-8 유효성 검사가 실패한 위치에 대한 세부 정보가 포함 된 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="99bd91603a025b03597fd1f9cbdd0b5e23a815bb" translate="yes" xml:space="preserve">
          <source>If the corresponding &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt; has disconnected, or it disconnects while this call is blocking, this call will wake up and return &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; to indicate that no more messages can ever be received on this channel. However, since channels are buffered, messages sent before the disconnect will still be properly received.</source>
          <target state="translated">해당 &lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt; 가 연결을 끊었 거나이 호출이 차단되는 동안 연결이 끊어지면이 호출은 깨어나 &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 을 반환 하여이 채널에서 더 이상 메시지를 수신 할 수 없음을 나타냅니다. 그러나 채널이 버퍼링되므로 연결 끊기 전에 전송 된 메시지는 여전히 제대로 수신됩니다.</target>
        </trans-unit>
        <trans-unit id="c9097bc3fc6399fb3bc83c93071781dffb279d65" translate="yes" xml:space="preserve">
          <source>If the data in this stream is &lt;em&gt;not&lt;/em&gt; valid UTF-8 then an error is returned and &lt;code&gt;buf&lt;/code&gt; is unchanged.</source>
          <target state="translated">이 스트림의 데이터가 유효한 UTF-8 이 &lt;em&gt;아닌&lt;/em&gt; 경우 오류가 리턴되고 &lt;code&gt;buf&lt;/code&gt; 는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10754b248a576fdba9d5228dc71f26ade299f007" translate="yes" xml:space="preserve">
          <source>If the definition of &lt;code&gt;foo&lt;/code&gt; is under your control, the simplest solution is to capture the data mutably. This can be done by defining &lt;code&gt;foo&lt;/code&gt; to take FnMut rather than Fn:</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 정의가 제어 할 수있는 경우 가장 간단한 해결책은 데이터를 가변적으로 캡처하는 것입니다. Fn 대신 FnMut을 사용하도록 &lt;code&gt;foo&lt;/code&gt; 를 정의하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="42bdc1ae118555b88ae881099abace5a191c0219" translate="yes" xml:space="preserve">
          <source>If the destination type is not part of the current crate then you can't implement &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; directly. For example, take this code:</source>
          <target state="translated">대상 유형이 현재 상자의 일부가 아닌 경우에 당신은 구현할 수 없습니다 &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; 직접. 예를 들어 다음 코드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="587511482f256e8f952acfee186e5aefae6cf9ca" translate="yes" xml:space="preserve">
          <source>If the determination that the code is unreachable proves incorrect, the program immediately terminates with a &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">코드에 도달 할 수 없다는 결정이 틀린 것으로 판명되면 프로그램은 즉시 &lt;a href=&quot;macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt; 종료됩니다 ! .</target>
        </trans-unit>
        <trans-unit id="480ada98c1c5ece146ecdc077a3e40775d89fd0e" translate="yes" xml:space="preserve">
          <source>If the element type of the iterator you need does not implement &lt;code&gt;Clone&lt;/code&gt;, or if you do not want to keep the repeated element in memory, you can instead use the &lt;a href=&quot;fn.repeat_with&quot;&gt;&lt;code&gt;repeat_with&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">필요한 반복자의 요소 유형이 &lt;code&gt;Clone&lt;/code&gt; 을 구현하지 않거나 반복 된 요소를 메모리에 유지하지 않으려면 &lt;a href=&quot;fn.repeat_with&quot;&gt; &lt;code&gt;repeat_with&lt;/code&gt; &lt;/a&gt; 함수를 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b5563e722ef79a66827ad237de3ff713088f72a" translate="yes" xml:space="preserve">
          <source>If the element type of the iterator you need implements &lt;code&gt;Clone&lt;/code&gt;, and it is OK to keep the source element in memory, you should instead use the &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">필요한 반복자의 요소 유형이 &lt;code&gt;Clone&lt;/code&gt; 을 구현 하고 소스 요소를 메모리에 유지하는 것이 좋다면 대신 &lt;a href=&quot;fn.repeat&quot;&gt; &lt;code&gt;repeat&lt;/code&gt; &lt;/a&gt; 함수 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fdfbdf49a01ecb81ac4dd4acab163dbc68e7e8c0" translate="yes" xml:space="preserve">
          <source>If the environment variable is not defined, then a compilation error will be emitted. To not emit a compile error, use the &lt;a href=&quot;macro.option_env&quot;&gt;&lt;code&gt;option_env!&lt;/code&gt;&lt;/a&gt; macro instead.</source>
          <target state="translated">환경 변수가 정의되어 있지 않으면 컴파일 오류가 발생합니다. 컴파일 오류를 발생시키지 않으려면 &lt;a href=&quot;macro.option_env&quot;&gt; &lt;code&gt;option_env!&lt;/code&gt; &lt;/a&gt;대신 매크로.</target>
        </trans-unit>
        <trans-unit id="6e8972418288b27e60b8fafe88d7c99a7d59e984" translate="yes" xml:space="preserve">
          <source>If the executable was invoked through a symbolic link, some platforms will return the path of the symbolic link and other platforms will return the path of the symbolic link&amp;rsquo;s target.</source>
          <target state="translated">실행 파일이 심볼릭 링크를 통해 호출 된 경우 일부 플랫폼은 심볼릭 링크의 경로를 반환하고 다른 플랫폼은 심볼릭 링크 대상의 경로를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fd55e486394dd1866434bdc5faf39742bfb2a2d4" translate="yes" xml:space="preserve">
          <source>If the expression in one of these coercion sites is a coercion-propagating expression, then the relevant sub-expressions in that expression are also coercion sites. Propagation recurses from these new coercion sites. Propagating expressions and their relevant sub-expressions are:</source>
          <target state="translated">이들 강요 부위 중 하나에서의 발현이 강요-전파 발현 인 경우, 그 발현의 관련 하위-발현도 강요 부위이다. 전파는이 새로운 강제 사이트에서 반복됩니다. 전파 표현 및 관련 하위 표현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="da06749df21ae19d99c10837b4fef8698354acfb" translate="yes" xml:space="preserve">
          <source>If the feature is accepted, an issue is opened on the Rust repository, and someone can implement it. The person who implements it very well may not be the person who proposed the feature in the first place! When the implementation is ready, it lands on the &lt;code&gt;master&lt;/code&gt; branch behind a feature gate, as we discussed in the &lt;a href=&quot;#unstable-features&quot;&gt;&amp;ldquo;Unstable Features&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">기능이 승인되면 Rust 저장소에서 문제가 열리고 누군가가이를 구현할 수 있습니다. 잘 구현 한 사람은 처음에 기능을 제안한 사람이 아닐 수도 있습니다! 구현이 준비되면 &lt;a href=&quot;#unstable-features&quot;&gt;&quot;불안정한 기능&quot;&lt;/a&gt; 섹션 에서 설명한 것처럼 기능 게이트 뒤 의 &lt;code&gt;master&lt;/code&gt; 브랜치에 도달 합니다.</target>
        </trans-unit>
        <trans-unit id="3414a33407bd3dac73209f0f3c8c87238661b1ca" translate="yes" xml:space="preserve">
          <source>If the file already exists, any write calls on it will overwrite its contents, without truncating it.</source>
          <target state="translated">파일이 이미 존재하면 파일을 쓸 때 파일을 자르지 않고 내용을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="9132b3e3ab7219a34cb586c6f14321ce888d6773" translate="yes" xml:space="preserve">
          <source>If the first element is matched, an empty slice will be the first item returned by the iterator. Similarly, if the last element in the slice is matched, an empty slice will be the last item returned by the iterator:</source>
          <target state="translated">첫 번째 요소가 일치하면 빈 슬라이스가 반복자가 반환 한 첫 번째 항목이됩니다. 마찬가지로 슬라이스의 마지막 요소가 일치하면 빈 슬라이스는 반복자가 반환 한 마지막 항목이됩니다.</target>
        </trans-unit>
        <trans-unit id="a3fd11d96e62e4df934fdc1fa4662261ba86625c" translate="yes" xml:space="preserve">
          <source>If the given capacity is &lt;code&gt;0&lt;/code&gt;, no allocation will occur, and this method is identical to the &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">주어진 용량이 &lt;code&gt;0&lt;/code&gt; 이면 할당이 발생하지 않으며이 방법은 &lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 방법 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="3e650fcb37c79e73b248840291059fa9ab82facc" translate="yes" xml:space="preserve">
          <source>If the given closure recursively invokes &lt;code&gt;call_once&lt;/code&gt; on the same &lt;code&gt;Once&lt;/code&gt; instance the exact behavior is not specified, allowed outcomes are a panic or a deadlock.</source>
          <target state="translated">지정된 클로저 가 동일한 &lt;code&gt;Once&lt;/code&gt; 인스턴스에서 &lt;code&gt;call_once&lt;/code&gt; 를 재귀 적으로 호출 하는 경우 정확한 동작이 지정되지 않으면 허용되는 결과는 패닉 또는 교착 상태입니다.</target>
        </trans-unit>
        <trans-unit id="82cd743013a3edab20be44d34d8b246c9798bdd1" translate="yes" xml:space="preserve">
          <source>If the input isn't NaN, then there is no portability concern.</source>
          <target state="translated">입력이 NaN이 아닌 경우 이식성 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="678a91cbb4ec06d73442b77832f91bad809fe51b" translate="yes" xml:space="preserve">
          <source>If the item is a function, you may use a closure:</source>
          <target state="translated">항목이 함수이면 클로저를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e29e02642c9eb9601c44c59f05b7d126f43b3f4" translate="yes" xml:space="preserve">
          <source>If the item is not defined in the current module, it must be imported using a &lt;code&gt;use&lt;/code&gt; statement, like so:</source>
          <target state="translated">항목이 현재 모듈에 정의되어 있지 않으면 다음 과 같이 &lt;code&gt;use&lt;/code&gt; 문을 사용하여 가져와야합니다 .</target>
        </trans-unit>
        <trans-unit id="5030e30e9a190114fd41d37b0c1ba92d9eec8bbd" translate="yes" xml:space="preserve">
          <source>If the item you are importing is not defined in some super-module of the current module, then it must also be declared as public (e.g., &lt;code&gt;pub fn&lt;/code&gt;).</source>
          <target state="translated">가져 오는 항목이 현재 모듈의 일부 수퍼 모듈에 정의되어 있지 않으면 공용으로 선언해야합니다 (예 : &lt;code&gt;pub fn&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c7f0b78af6a1f2b8da54724cc60c89fb090afb8c" translate="yes" xml:space="preserve">
          <source>If the lifetime of a reference isn't enough, such as in the case of threading, consider using an &lt;code&gt;Arc&lt;/code&gt; to create a reference-counted value:</source>
          <target state="translated">스레딩과 같이 참조의 수명이 충분하지 않으면 &lt;code&gt;Arc&lt;/code&gt; 를 사용하여 참조 카운트 값을 만드십시오.</target>
        </trans-unit>
        <trans-unit id="0e305a8484a9cd9dc5c8361f54c572219ec9804c" translate="yes" xml:space="preserve">
          <source>If the lock could not be acquired at this time, then &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned. Otherwise, an RAII guard is returned. The lock will be unlocked when the guard is dropped.</source>
          <target state="translated">이때 잠금을 획득 할 수 없으면 &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 이 리턴됩니다. 그렇지 않으면 RAII 가드가 리턴됩니다. 가드가 떨어지면 잠금이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="f8b222d65f3e5a011a407bdb03d5df29adfec456" translate="yes" xml:space="preserve">
          <source>If the lock could not be acquired at this time, then &lt;code&gt;Err&lt;/code&gt; is returned. Otherwise, an RAII guard is returned which will release the lock when it is dropped.</source>
          <target state="translated">이때 잠금을 획득 할 수 없으면 &lt;code&gt;Err&lt;/code&gt; 이 리턴됩니다. 그렇지 않으면 RAII 가드가 리턴되어 잠금이 해제 될 때 잠금을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="ecf781a8afe2a0c63a1d40b96befbc6c4dce088d" translate="yes" xml:space="preserve">
          <source>If the main thread panics it will terminate all your threads and end your program with code &lt;code&gt;101&lt;/code&gt;.</source>
          <target state="translated">메인 스레드 패닉이 발생하면 모든 스레드가 종료되고 코드 &lt;code&gt;101&lt;/code&gt; 로 프로그램이 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="d96d894c9cb755e3982e02a5fa557e27c759b559" translate="yes" xml:space="preserve">
          <source>If the map did have this key present, the value is updated, and the old value is returned. The key is not updated, though; this matters for types that can be &lt;code&gt;==&lt;/code&gt; without being identical. See the &lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;module-level documentation&lt;/a&gt; for more.</source>
          <target state="translated">지도에이 키가 있으면 값이 업데이트되고 이전 값이 반환됩니다. 그러나 키는 업데이트되지 않습니다. 이것은 동일하지 않고 &lt;code&gt;==&lt;/code&gt; 일 수있는 유형에 중요 합니다. 자세한 내용은 &lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;모듈 수준 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a660d0d730c1d18357284ffbb42b24c56c1fea09" translate="yes" xml:space="preserve">
          <source>If the map did not have this key present, &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">지도에이 키가 없으면 &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="22fc8ad8eb7527fa9d4557d1bcf87a2d2bd7edcb" translate="yes" xml:space="preserve">
          <source>If the map did not have this key present, &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">지도에이 키가 없으면 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ce6ece3326d8becac91cb49d0dcc5a346e703bba" translate="yes" xml:space="preserve">
          <source>If the map did not have this key present, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">지도에이 키가 없으면 &lt;code&gt;None&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c00b93ea8ff90e66022ac61d150c9d932705572a" translate="yes" xml:space="preserve">
          <source>If the named environment variable is present at compile time, this will expand into an expression of type &lt;code&gt;Option&amp;lt;&amp;amp;'static str&amp;gt;&lt;/code&gt; whose value is &lt;code&gt;Some&lt;/code&gt; of the value of the environment variable. If the environment variable is not present, then this will expand to &lt;code&gt;None&lt;/code&gt;. See &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; for more information on this type.</source>
          <target state="translated">명명 환경 변수 컴파일시에 존재하는 경우, 이러한 유형의 표현으로 확장 할 &lt;code&gt;Option&amp;lt;&amp;amp;'static str&amp;gt;&lt;/code&gt; 그 값이 &lt;code&gt;Some&lt;/code&gt; 환경 변수의 값을. 환경 변수가 없으면 &lt;code&gt;None&lt;/code&gt; 으로 확장됩니다 . 이 유형에 대한 자세한 내용 은 &lt;a href=&quot;option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a6575b526f3c9f6ff8f51c0abc90eb128dc80c26" translate="yes" xml:space="preserve">
          <source>If the number of elements in the pattern doesn&amp;rsquo;t match the number of elements in the tuple, the overall type won&amp;rsquo;t match and we&amp;rsquo;ll get a compiler error. For example, Listing 18-5 shows an attempt to destructure a tuple with three elements into two variables, which won&amp;rsquo;t work.</source>
          <target state="translated">패턴의 요소 수가 튜플의 요소 수와 일치하지 않으면 전체 유형이 일치하지 않으며 컴파일러 오류가 발생합니다. 예를 들어, 목록 18-5는 세 개의 요소가있는 튜플을 두 개의 변수로 구조화하려는 시도를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="d5f255ea3f66f81885c9b2fd50418cdf94440a9b" translate="yes" xml:space="preserve">
          <source>If the number of nanoseconds is greater than 1 billion (the number of nanoseconds in a second), then it will carry over into the seconds provided.</source>
          <target state="translated">나노초의 수가 10 억을 초과하면 (초당 나노초의 수) 제공된 초로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="7587948fbc56d5936df283dc95c30a87905bc378" translate="yes" xml:space="preserve">
          <source>If the path is a normal file, this is the file name. If it's the path of a directory, this is the directory name.</source>
          <target state="translated">경로가 일반 파일 인 경우 파일 이름입니다. 디렉토리 경로 인 경우 디렉토리 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a7ef120bc4e6081962026d321af347e6c4f9a831" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;#method.rmatch_indices&quot;&gt;&lt;code&gt;rmatch_indices&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역 검색을 허용하지만 결과가 정방향 검색과 다를 수있는 경우 &lt;a href=&quot;#method.rmatch_indices&quot;&gt; &lt;code&gt;rmatch_indices&lt;/code&gt; &lt;/a&gt; 메소드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04680e781abdf689365df53a980b052d9694289c" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;#method.rmatches&quot;&gt;&lt;code&gt;rmatches&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역 검색을 허용하지만 결과가 정방향 검색과 다를 수있는 경우 &lt;a href=&quot;#method.rmatches&quot;&gt; &lt;code&gt;rmatches&lt;/code&gt; &lt;/a&gt; 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdde1b4f273f0ed1e791a6fe885f57ab847c6655" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;#method.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역방향 검색을 허용하지만 결과가 정방향 검색과 다를 수있는 경우 &lt;a href=&quot;#method.rsplit&quot;&gt; &lt;code&gt;rsplit&lt;/code&gt; &lt;/a&gt; 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7628f0f92ea01c70ac165a6fae25950d70760fc1" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;#method.rsplit_terminator&quot;&gt;&lt;code&gt;rsplit_terminator&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역방향 검색을 허용하지만 결과가 정방향 검색과 다를 수있는 경우 &lt;a href=&quot;#method.rsplit_terminator&quot;&gt; &lt;code&gt;rsplit_terminator&lt;/code&gt; &lt;/a&gt; 메소드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02eda760b5bfe240d7c8b8f222a4d4b7100d666e" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search, the &lt;a href=&quot;#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">패턴이 역방향 검색을 허용하는 경우 &lt;a href=&quot;#method.rsplitn&quot;&gt; &lt;code&gt;rsplitn&lt;/code&gt; &lt;/a&gt; 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9d4003e7c8cd37da9426d5d4d889d3aaff32c4e" translate="yes" xml:space="preserve">
          <source>If the predicate is true, the thing is rewritten to not have the &lt;code&gt;cfg&lt;/code&gt; attribute on it. If the predicate is false, the thing is removed from the source code.</source>
          <target state="translated">술어가 true이면, &lt;code&gt;cfg&lt;/code&gt; 속성 이없는 것으로 재 작성됩니다 . 술어가 false 인 경우 소스 코드에서 해당 내용이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="9ddbcce981c839ba50c36650f18e74f28c3996cc" translate="yes" xml:space="preserve">
          <source>If the process was terminated by a signal, returns that signal.</source>
          <target state="translated">프로세스가 신호에 의해 종료 된 경우 해당 신호를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="12b3054a5c2c9f1f42244cb5633baa4905430f09" translate="yes" xml:space="preserve">
          <source>If the program context over-constrains the type, it is considered a static type error.</source>
          <target state="translated">프로그램 컨텍스트가 유형을 과도하게 제한하는 경우 정적 유형 오류로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="0342ae828ad12df97309a477cf872adf919b1902" translate="yes" xml:space="preserve">
          <source>If the program context under-constrains the type, it defaults to &lt;code&gt;f64&lt;/code&gt;.</source>
          <target state="translated">프로그램 컨텍스트가 유형을 제한하지 않으면 기본값은 &lt;code&gt;f64&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9c5273dc0a13c7cc0e077b4b3fa98da50edca969" translate="yes" xml:space="preserve">
          <source>If the program context under-constrains the type, it defaults to the signed 32-bit integer &lt;code&gt;i32&lt;/code&gt;.</source>
          <target state="translated">프로그램 컨텍스트가 유형을 제한하지 않으면 기본적으로 부호있는 32 비트 정수 &lt;code&gt;i32&lt;/code&gt; 로 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="46f99ab4b433b6230008eadc71e11c58b7b1e70b" translate="yes" xml:space="preserve">
          <source>If the program path is relative (e.g., &lt;code&gt;&quot;./script.sh&quot;&lt;/code&gt;), it's ambiguous whether it should be interpreted relative to the parent's working directory or relative to &lt;code&gt;current_dir&lt;/code&gt;. The behavior in this case is platform specific and unstable, and it's recommended to use &lt;a href=&quot;../fs/fn.canonicalize&quot;&gt;&lt;code&gt;canonicalize&lt;/code&gt;&lt;/a&gt; to get an absolute program path instead.</source>
          <target state="translated">프로그램 경로가 상대적인 경우 (예 : &lt;code&gt;&quot;./script.sh&quot;&lt;/code&gt; ) 부모의 작업 디렉토리 또는 &lt;code&gt;current_dir&lt;/code&gt; 과 관련하여 해석해야하는지 모호합니다 . 이 경우의 동작은 플랫폼에 따라 다르고 불안정하므로 &lt;a href=&quot;../fs/fn.canonicalize&quot;&gt; &lt;code&gt;canonicalize&lt;/code&gt; &lt;/a&gt; 프로그램 을 사용 하여 절대 프로그램 경로를 얻는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="5f463c42ca012031b77b1b6ba6bda1bbf7d242ce" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.recv_from&quot;&gt;&lt;code&gt;recv_from&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">제공된 값이 &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#method.recv_from&quot;&gt; &lt;code&gt;recv_from&lt;/code&gt; &lt;/a&gt; 호출은 무기한 차단됩니다. &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="27457ae3a7ce774b0ba53e72b68851ec71f67265" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.send_to&quot;&gt;&lt;code&gt;send_to&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#Err.v&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">제공된 값이 &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#method.send_to&quot;&gt; &lt;code&gt;send_to&lt;/code&gt; &lt;/a&gt; 호출이 무기한 차단됩니다. &lt;a href=&quot;../../../result/enum.result#Err.v&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="a1795e7946ced7825121511cc106a9015fd798ec" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../io/trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">제공된 값이 &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;../../../io/trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 호출이 무기한 차단됩니다. &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="e1ea6f1309304cb111df61243a566c96b67b3b82" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">제공된 값이 &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;../../../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 호출이 무기한 차단됩니다. &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="02ca5c816748f7e2bf4c21dd7d1f2eac8980aece" translate="yes" xml:space="preserve">
          <source>If the receiver has type &lt;code&gt;&amp;amp;Self&lt;/code&gt; or &lt;code&gt;&amp;amp;mut Self&lt;/code&gt;, then the lifetime of that reference to &lt;code&gt;Self&lt;/code&gt; is assigned to all elided output lifetime parameters.</source>
          <target state="translated">수신기 입력이있는 경우 &lt;code&gt;&amp;amp;Self&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;mut Self&lt;/code&gt; , 그 다음에 기준의 수명 &lt;code&gt;Self&lt;/code&gt; 모두 생략 된 출력 유효 기간 파라미터에 할당된다.</target>
        </trans-unit>
        <trans-unit id="87acaebec96dcd891a49b70723f561ac4a00a2ef" translate="yes" xml:space="preserve">
          <source>If the repetition can match zero times (&lt;code&gt;*&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt;), then whatever comes after must be able to follow whatever comes before.</source>
          <target state="translated">반복이 0 번 일치 할 수 있으면 ( &lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;?&lt;/code&gt; ), 이후에 오는 것은 무엇이든 따라 올 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0c4e89c7ed58ca57a531d68235db3f5dd485fb44" translate="yes" xml:space="preserve">
          <source>If the repetition can repeat multiple times (&lt;code&gt;*&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt;), then the contents must be able to follow themselves.</source>
          <target state="translated">반복이 여러 번 반복 될 수있는 경우 ( &lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;+&lt;/code&gt; ) 내용이 스스로 따라갈 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f0a7f9f74244abd35ce8e1d2208c1f4bd4a178de" translate="yes" xml:space="preserve">
          <source>If the repetition includes a separator, that separator must be able to follow the contents of the repetition.</source>
          <target state="translated">반복에 구분 기호가 포함 된 경우 해당 구분 기호는 반복 내용을 따라갈 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="93fda8c7280ac97a010f00a3edbfb2871f7e4163" translate="yes" xml:space="preserve">
          <source>If the results of this method are only manipulated by the same architecture that produced them, then there is no portability concern.</source>
          <target state="translated">이 방법의 결과가 동일한 아키텍처에 의해서만 조작된다면, 이식성 문제는 없습니다.</target>
        </trans-unit>
        <trans-unit id="2714df80ed99e7f5046c9baa63d90d1d03b47084" translate="yes" xml:space="preserve">
          <source>If the return value is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(n)&lt;/code&gt;&lt;/a&gt; then it must be guaranteed that &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt;. A return value of &lt;code&gt;0&lt;/code&gt; typically means that the underlying object is no longer able to accept bytes and will likely not be able to in the future as well, or that the buffer provided is empty.</source>
          <target state="translated">리턴 값이 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(n)&lt;/code&gt; &lt;/a&gt; 이면 &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt; 합니다. 반환 값이 &lt;code&gt;0&lt;/code&gt; 이면 일반적으로 기본 개체가 더 이상 바이트를 받아 들일 수 없으며 앞으로는 더 이상 사용할 수 없거나 제공된 버퍼가 비어 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3d8a15b3b50cba05982491cd9452366b174a6982" translate="yes" xml:space="preserve">
          <source>If the return value of this method is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(n)&lt;/code&gt;&lt;/a&gt;, then it must be guaranteed that &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt;. A nonzero &lt;code&gt;n&lt;/code&gt; value indicates that the buffer &lt;code&gt;buf&lt;/code&gt; has been filled in with &lt;code&gt;n&lt;/code&gt; bytes of data from this source. If &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, then it can indicate one of two scenarios:</source>
          <target state="translated">이 메소드의 리턴 값이 &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(n)&lt;/code&gt; &lt;/a&gt; 인 경우 &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt; 보장되어야합니다 . &lt;code&gt;n&lt;/code&gt; 이 아닌 n 값은 버퍼 &lt;code&gt;buf&lt;/code&gt; 가이 소스의 &lt;code&gt;n&lt;/code&gt; 바이트 데이터 로 채워 졌음을 나타냅니다 . &lt;code&gt;n&lt;/code&gt; 이 &lt;code&gt;0&lt;/code&gt; 인 경우 두 시나리오 중 하나를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ded67fe7a6c072a895832d05a296084ac3d461ad" translate="yes" xml:space="preserve">
          <source>If the seek operation completed successfully, this method returns the new position from the start of the stream. That position can be used later with &lt;a href=&quot;enum.seekfrom#variant.Start&quot;&gt;&lt;code&gt;SeekFrom::Start&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">탐색 작업이 성공적으로 완료되면이 메서드는 스트림 시작 부분에서 새 위치를 반환합니다. 이 위치는 나중에 &lt;a href=&quot;enum.seekfrom#variant.Start&quot;&gt; &lt;code&gt;SeekFrom::Start&lt;/code&gt; &lt;/a&gt; 와 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="40a290f3a15c2cd192fbe0ef4a0681d5f1afa2a2" translate="yes" xml:space="preserve">
          <source>If the set did have this value present, &lt;code&gt;false&lt;/code&gt; is returned, and the entry is not updated. See the &lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;module-level documentation&lt;/a&gt; for more.</source>
          <target state="translated">집합에이 값이 있으면 &lt;code&gt;false&lt;/code&gt; 가 반환되고 항목이 업데이트되지 않습니다. 자세한 내용은 &lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;모듈 수준 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="94e9a109c03e48a1d66a80ba76a8cd1667e1c88c" translate="yes" xml:space="preserve">
          <source>If the set did have this value present, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">집합에이 값이 있으면 &lt;code&gt;false&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3bf8ca60d7471ccc5d2a042445134f6d59f07692" translate="yes" xml:space="preserve">
          <source>If the set did not have this value present, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">세트에이 값이 없으면 &lt;code&gt;true&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f83ff10b230425401b084d2888a7c546a452e490" translate="yes" xml:space="preserve">
          <source>If the slice is shorter than &lt;code&gt;size&lt;/code&gt;:</source>
          <target state="translated">슬라이스가 &lt;code&gt;size&lt;/code&gt; 보다 짧은 경우 :</target>
        </trans-unit>
        <trans-unit id="1412fa3c4897cefe27e1dd8f5c2bdb81e3843fe2" translate="yes" xml:space="preserve">
          <source>If the slice is sorted, the first returned slice contains no duplicates.</source>
          <target state="translated">슬라이스가 정렬되면 첫 번째로 반환 된 슬라이스에 중복이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a7500b2ee92288b054ccbb9cf159239611040c00" translate="yes" xml:space="preserve">
          <source>If the socket isn't connected, it will return a &lt;a href=&quot;../io/enum.errorkind#variant.NotConnected&quot;&gt;&lt;code&gt;NotConnected&lt;/code&gt;&lt;/a&gt; error.</source>
          <target state="translated">소켓이 연결되어 있지 않으면 &lt;a href=&quot;../io/enum.errorkind#variant.NotConnected&quot;&gt; &lt;code&gt;NotConnected&lt;/code&gt; &lt;/a&gt; 오류 가 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="78527ed1205c7d745b52b60ade93722ffae3f052" translate="yes" xml:space="preserve">
          <source>If the source and destination will &lt;em&gt;never&lt;/em&gt; overlap, &lt;a href=&quot;fn.copy_nonoverlapping&quot;&gt;&lt;code&gt;copy_nonoverlapping&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">소스 및 대상이됩니다 &lt;em&gt;결코&lt;/em&gt; 중복, &lt;a href=&quot;fn.copy_nonoverlapping&quot;&gt; &lt;code&gt;copy_nonoverlapping&lt;/code&gt; &lt;/a&gt; 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddcbef4bcc4007d5bd1893bc755dafa184d9df1c" translate="yes" xml:space="preserve">
          <source>If the timeout is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; calls will block indefinitely.</source>
          <target state="translated">시간 초과가 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 호출이 무기한 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="071f9fdeaf91e92bcf2267f9e0f60277f6bcc97e" translate="yes" xml:space="preserve">
          <source>If the timeout is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely.</source>
          <target state="translated">시간 초과가 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 호출은 무기한 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="86ffa0ca9fede5aea50d7e731aa1e556c2cfcb06" translate="yes" xml:space="preserve">
          <source>If the trait &lt;code&gt;Foo&lt;/code&gt; was deriving from something like &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; or &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; (where &lt;code&gt;Foo&lt;/code&gt; itself is &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt;), this is okay, because given a type &lt;code&gt;get_a()&lt;/code&gt; will definitely return an object of that type.</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; 특성 이 &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; ( &lt;code&gt;Foo&lt;/code&gt; 자체가 &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; )와 같은 &lt;code&gt;get_a()&lt;/code&gt; 된 경우 get_a () 유형이 주어진 경우 해당 유형의 객체를 확실히 반환 하기 때문에 괜찮습니다 .</target>
        </trans-unit>
        <trans-unit id="f3977c8ff69bc736e667f7951c5a2e7ce42dc78b" translate="yes" xml:space="preserve">
          <source>If the trait has no lifetime bounds, then the lifetime is inferred in expressions and is &lt;code&gt;'static&lt;/code&gt; outside of expressions.</source>
          <target state="translated">특성에 수명 한계가없는 경우 수명은 표현식에서 유추되며 &lt;code&gt;'static&lt;/code&gt; 표현식 외부에서 정적 입니다.</target>
        </trans-unit>
        <trans-unit id="91f2e745c85e0029a493a85d365496779bca0a85" translate="yes" xml:space="preserve">
          <source>If the trait is defined with a single lifetime &lt;em&gt;bound&lt;/em&gt; then that bound is used.</source>
          <target state="translated">특성이 단일 수명 &lt;em&gt;한계&lt;/em&gt; 로 정의 &lt;em&gt;된&lt;/em&gt; 경우 해당 한계가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="357e0325de10f1713bb7e2ce24ee991bac9ba465" translate="yes" xml:space="preserve">
          <source>If the trait object is used as a type argument of a generic type then the containing type is first used to try to infer a bound.</source>
          <target state="translated">trait 객체가 제네릭 형식의 형식 인수로 사용되는 경우 포함 형식을 먼저 사용하여 바운드를 유추하려고합니다.</target>
        </trans-unit>
        <trans-unit id="560d3597e83d956d002972f4abc002a7d2adb557" translate="yes" xml:space="preserve">
          <source>If the type of the &lt;code&gt;self&lt;/code&gt; parameter is specified, it is limited to one of the following types:</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 매개 변수 의 유형 이 지정되면 다음 유형 중 하나로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="ce48e604713fdd5d1a45036f133935186dfa1172" translate="yes" xml:space="preserve">
          <source>If the type parameter was included by mistake, this error can be fixed by simply removing the type parameter, as shown below:</source>
          <target state="translated">실수로 형식 매개 변수가 포함 된 경우 아래에 표시된 것처럼 형식 매개 변수를 간단히 제거하면이 오류를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="518ddacd66d25987845bcd6f93021680b5c6a782" translate="yes" xml:space="preserve">
          <source>If the underlying data is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#method.into_inner&quot;&gt;&lt;code&gt;Pin::into_inner&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="translated">기본 데이터 인 경우 &lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#method.into_inner&quot;&gt; &lt;code&gt;Pin::into_inner&lt;/code&gt; &lt;/a&gt; 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d6a64661df18427c960804044729f48ac301ae02" translate="yes" xml:space="preserve">
          <source>If the underlying data is &lt;code&gt;Unpin&lt;/code&gt;, &lt;code&gt;Pin::get_mut&lt;/code&gt; should be used instead.</source>
          <target state="translated">기본 데이터 인 경우 &lt;code&gt;Unpin&lt;/code&gt; , &lt;code&gt;Pin::get_mut&lt;/code&gt; 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8405b8ad332b999aa219670b74caa5f46b181830" translate="yes" xml:space="preserve">
          <source>If the underlying filesystem does not support creation time, the returned value is 0.</source>
          <target state="translated">기본 파일 시스템이 작성 시간을 지원하지 않으면 리턴 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="413f9b68289dcc8297528df41e0f0feb6ddb8349" translate="yes" xml:space="preserve">
          <source>If the underlying filesystem does not support last access time, the returned value is 0.</source>
          <target state="translated">기본 파일 시스템이 마지막 액세스 시간을 지원하지 않으면 리턴 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="fb7130f0e0ffc326e8ffb3bb43790b19856655f3" translate="yes" xml:space="preserve">
          <source>If the underlying filesystem does not support the last write time, the returned value is 0.</source>
          <target state="translated">기본 파일 시스템이 마지막 쓰기 시간을 지원하지 않으면 반환 된 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="2800f0b4e13fb2d5eedd5490b06177fdb31e9a98" translate="yes" xml:space="preserve">
          <source>If the user specifies a favorite color, that color is the background color. If today is Tuesday, the background color is green. If the user specifies their age as a string and we can parse it as a number successfully, the color is either purple or orange depending on the value of the number. If none of these conditions apply, the background color is blue.</source>
          <target state="translated">사용자가 선호하는 색상을 지정하면 해당 색상이 배경색입니다. 오늘이 화요일이면 배경색이 녹색입니다. 사용자가 나이를 문자열로 지정하고 숫자로 구문 분석 할 수있는 경우 숫자 값에 따라 색상이 자주색 또는 주황색입니다. 이러한 조건 중 어느 것도 해당되지 않으면 배경색이 파란색입니다.</target>
        </trans-unit>
        <trans-unit id="e4dd9bc072921d826fb4feb5e2064cc014699b96" translate="yes" xml:space="preserve">
          <source>If the user wants a high-intensity workout, there&amp;rsquo;s some additional logic: if the value of the random number generated by the app happens to be 3, the app will recommend a break and hydration. If not, the user will get a number of minutes of running based on the complex algorithm.</source>
          <target state="translated">사용자가 고강도 운동을 원한다면 몇 가지 추가 논리가 있습니다. 앱에서 생성 된 난수 값이 3이면 앱은 휴식과 수화를 권장합니다. 그렇지 않으면 복잡한 알고리즘을 기반으로 몇 분 동안 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="de326f90242f044e38821476a3f1590bb4fba9d2" translate="yes" xml:space="preserve">
          <source>If the value has to be borrowed and then moved, try limiting the lifetime of the borrow using a scoped block:</source>
          <target state="translated">값을 빌린 다음 이동해야하는 경우 범위가 지정된 블록을 사용하여 빌림의 수명을 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="439bfb205198efd0a4754651bf5aae96ad735451" translate="yes" xml:space="preserve">
          <source>If the value has to be borrowed, try limiting the lifetime of the borrow using a scoped block:</source>
          <target state="translated">값을 빌려야하는 경우 범위가 지정된 블록을 사용하여 빌려주기를 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="8d1fe880a09ab231c6fd293521ee6addfe1a6459" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;../result/enum.result#Err.v&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">값을 찾으면 일치하는 요소의 색인을 포함하는 &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt; 가 리턴됩니다. 일치하는 항목이 여러 개인 경우 일치하는 항목 중 하나가 반환 될 수 있습니다. 값을 찾을 수 없으면 정렬 순서를 유지하면서 일치하는 요소를 삽입 할 수있는 색인을 포함하는 &lt;a href=&quot;../result/enum.result#Err.v&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="50a46bb743147d3eacb03edd963a4e09c15c1d2d" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;result/enum.result#Err.v&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">값을 찾으면 일치하는 요소의 색인을 포함하는 &lt;a href=&quot;result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt; 가 리턴됩니다. 일치하는 항목이 여러 개인 경우 일치하는 항목 중 하나가 반환 될 수 있습니다. 값을 찾을 수 없으면 정렬 순서를 유지하면서 일치하는 요소를 삽입 할 수있는 색인을 포함하는 &lt;a href=&quot;result/enum.result#Err.v&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="3d22ef5ff5dbc4cc40b70616ba2e0f0190b53527" translate="yes" xml:space="preserve">
          <source>If the value specified is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">지정된 값이 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 호출이 무기한 차단됩니다. &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="29067101ad21459828f0c00fe18eef137fbe68c7" translate="yes" xml:space="preserve">
          <source>If the value specified is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">지정된 값이 &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이면 &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 호출은 무기한 차단됩니다. &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; 제로 경우 반환 &lt;a href=&quot;../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; 이 메서드에 전달된다.</target>
        </trans-unit>
        <trans-unit id="181ed969af7558ba19cf6745f45eb52729d76a52" translate="yes" xml:space="preserve">
          <source>If the value will be consumed in the pattern guard, using its clone will not move its ownership, so the code works.</source>
          <target state="translated">패턴 가드에서 값을 사용하는 경우 복제본을 사용해도 소유권이 이동하지 않으므로 코드가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="fcea84573a8b7607a7187659bdbb55dd1d39b19b" translate="yes" xml:space="preserve">
          <source>If the vector is sorted, this removes all duplicates.</source>
          <target state="translated">벡터가 정렬되면 모든 복제본이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="ff03d8563fa4e1bf22eab63535da2e3b71548d3f" translate="yes" xml:space="preserve">
          <source>If there are no other &lt;code&gt;Rc&lt;/code&gt; pointers to this value, then &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to this value will be dissassociated.</source>
          <target state="translated">이 값에 대한 다른 &lt;code&gt;Rc&lt;/code&gt; 포인터 가 없으면 이 값에 대한 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 포인터의 연결이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="4f600b6c8aaa0b5d77a10aa7a739f040bbc9e0c6" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Arc&lt;/code&gt; or &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to the same value, then &lt;code&gt;make_mut&lt;/code&gt; will invoke &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on the inner value to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="translated">동일한 값에 대한 다른 &lt;code&gt;Arc&lt;/code&gt; 또는 &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; 포인터가 &lt;code&gt;make_mut&lt;/code&gt; 는 고유 한 소유권을 보장하기 위해 내부 값에서 &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 를 호출 합니다. 이를 기록 중 복제라고도합니다.</target>
        </trans-unit>
        <trans-unit id="f863941a685dbb092b44959406a2b7b73529caaa" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Rc&lt;/code&gt; pointers to the same value, then &lt;code&gt;make_mut&lt;/code&gt; will &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; the inner value to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="translated">동일한 값에 대한 다른 &lt;code&gt;Rc&lt;/code&gt; 포인터 가 있으면 &lt;code&gt;make_mut&lt;/code&gt; 은 고유 한 소유권을 보장하기 위해 내부 값을 &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 합니다. 이를 기록 중 복제라고도합니다.</target>
        </trans-unit>
        <trans-unit id="dea40bb57bee20622d3883c554a725db6e6aee3b" translate="yes" xml:space="preserve">
          <source>If there is a blocked thread on this condition variable, then it will be woken up from its call to &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.wait_timeout&quot;&gt;&lt;code&gt;wait_timeout&lt;/code&gt;&lt;/a&gt;. Calls to &lt;code&gt;notify_one&lt;/code&gt; are not buffered in any way.</source>
          <target state="translated">이 조건 변수에 차단 된 스레드가 있으면 &lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#method.wait_timeout&quot;&gt; &lt;code&gt;wait_timeout&lt;/code&gt; &lt;/a&gt; 호출에서 깨어납니다 . &lt;code&gt;notify_one&lt;/code&gt; 에 대한 호출 은 어떤 식으로도 버퍼링되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bee2363bd2a2c8c97c0aa8c6f834b6380ae23a5d" translate="yes" xml:space="preserve">
          <source>If there is a unique bound from the containing type then that is the default</source>
          <target state="translated">포함 유형에서 고유 한 경계가있는 경우 이것이 기본값입니다</target>
        </trans-unit>
        <trans-unit id="352f58ee146eece567c530e6f6054aff283c53ea" translate="yes" xml:space="preserve">
          <source>If there is exactly one lifetime used in the parameters (elided or not), that lifetime is assigned to &lt;em&gt;all&lt;/em&gt; elided output lifetimes.</source>
          <target state="translated">매개 변수에 사용 된 수명이 정확히 하나 (필요한지 여부) 인 경우 해당 수명은 &lt;em&gt;모든&lt;/em&gt; 생략 된 출력 수명에 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="05c8d9cff8b4cacded32e768ce8c1fe1b9bf7b05" translate="yes" xml:space="preserve">
          <source>If there is more than one bound from the containing type then an explicit bound must be specified</source>
          <target state="translated">포함 유형에서 둘 이상의 바운드가있는 경우 명시 적 바운드를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="3635b90aa1ac5e9d56b967f455ea5a68c64aa12a" translate="yes" xml:space="preserve">
          <source>If there is no data attached to &lt;em&gt;any&lt;/em&gt; of the variants of an enumeration, then the discriminant can be directly chosen and accessed.</source>
          <target state="translated">첨부 데이터가없는 경우에 &lt;em&gt;임의의&lt;/em&gt; 열거의 변형 후 판별 직접 선택 및 액세스 될 수있다.</target>
        </trans-unit>
        <trans-unit id="5a74422fbdc8c963cd6dd0e8d60bffef84d0d7d1" translate="yes" xml:space="preserve">
          <source>If there's still a partial line in the buffer when the &lt;code&gt;LineWriter&lt;/code&gt; is dropped, it will flush those contents.</source>
          <target state="translated">&lt;code&gt;LineWriter&lt;/code&gt; 가 삭제 될 때 버퍼에 여전히 부분 라인이 있으면 해당 내용을 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="abb98d91de395055f4edd70094a7b8dcc7dd5d8b" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Error&lt;/code&gt; was constructed via &lt;code&gt;last_os_error&lt;/code&gt; or &lt;code&gt;from_raw_os_error&lt;/code&gt;, then this function will return &lt;code&gt;Some&lt;/code&gt;, otherwise it will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Error&lt;/code&gt; 가 &lt;code&gt;last_os_error&lt;/code&gt; 또는 &lt;code&gt;from_raw_os_error&lt;/code&gt; 를 통해 생성 된 경우이 함수는 &lt;code&gt;Some&lt;/code&gt; 을 반환 하고 그렇지 않으면 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="d6ffccf610cd6b37d68c88255675f6191805f967" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Error&lt;/code&gt; was constructed via &lt;code&gt;new&lt;/code&gt; then this function will return &lt;code&gt;Some&lt;/code&gt;, otherwise it will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Error&lt;/code&gt; 가 &lt;code&gt;new&lt;/code&gt; 를 통해 생성 된 경우이 함수는 &lt;code&gt;Some&lt;/code&gt; 을 반환하고, 그렇지 않으면 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="b584e3b971153b633a07eca679cded17a1c1b693" translate="yes" xml:space="preserve">
          <source>If this chapter has piqued your interest and you want to implement your own smart pointers, check out &lt;a href=&quot;https://doc.rust-lang.org/stable/nomicon/index.html&quot;&gt;&amp;ldquo;The Rustonomicon&amp;rdquo;&lt;/a&gt; for more useful information.</source>
          <target state="translated">이 장에서 관심을 끌고 자신 만의 스마트 포인터를 구현하려는 경우 &lt;a href=&quot;https://doc.rust-lang.org/stable/nomicon/index.html&quot;&gt;&amp;ldquo;Rustonomicon&amp;rdquo;&lt;/a&gt; 에서 더 유용한 정보를 확인하십시오.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
