<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="django">
    <body>
      <group id="django">
        <trans-unit id="f679fdeca5300eb43fca301ba6fb9ce9ba96c576" translate="yes" xml:space="preserve">
          <source>To log out a user who has been logged in via &lt;a href=&quot;#django.contrib.auth.login&quot;&gt;&lt;code&gt;django.contrib.auth.login()&lt;/code&gt;&lt;/a&gt;, use &lt;a href=&quot;#django.contrib.auth.logout&quot;&gt;&lt;code&gt;django.contrib.auth.logout()&lt;/code&gt;&lt;/a&gt; within your view. It takes an &lt;a href=&quot;../../ref/request-response#django.http.HttpRequest&quot;&gt;&lt;code&gt;HttpRequest&lt;/code&gt;&lt;/a&gt; object and has no return value. Example:</source>
          <target state="translated">를 통해 로그인 된 사용자 로그 아웃 &lt;a href=&quot;#django.contrib.auth.login&quot;&gt; &lt;code&gt;django.contrib.auth.login()&lt;/code&gt; &lt;/a&gt; 사용 &lt;a href=&quot;#django.contrib.auth.logout&quot;&gt; &lt;code&gt;django.contrib.auth.logout()&lt;/code&gt; &lt;/a&gt; 보기 내. 그것은 소요 &lt;a href=&quot;../../ref/request-response#django.http.HttpRequest&quot;&gt; &lt;code&gt;HttpRequest&lt;/code&gt; 에의&lt;/a&gt; 객체 및 반환 값이 없습니다. 예:</target>
        </trans-unit>
        <trans-unit id="e0969ced350b1de664eeb639cc06454bda5538b0" translate="yes" xml:space="preserve">
          <source>To make a &lt;a href=&quot;../../ref/template-response#django.template.response.TemplateResponse&quot;&gt;&lt;code&gt;TemplateResponse&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.djangoproject.com/en/3.0/ref/class-based-views/flattened-index/#ListView&quot;&gt;&lt;code&gt;ListView&lt;/code&gt;&lt;/a&gt; then uses &lt;a href=&quot;../../ref/class-based-views/mixins-multiple-object#django.views.generic.list.MultipleObjectTemplateResponseMixin&quot;&gt;&lt;code&gt;MultipleObjectTemplateResponseMixin&lt;/code&gt;&lt;/a&gt;; as with &lt;a href=&quot;../../ref/class-based-views/mixins-single-object#django.views.generic.detail.SingleObjectTemplateResponseMixin&quot;&gt;&lt;code&gt;SingleObjectTemplateResponseMixin&lt;/code&gt;&lt;/a&gt; above, this overrides &lt;code&gt;get_template_names()&lt;/code&gt; to provide &lt;a href=&quot;../../ref/class-based-views/mixins-multiple-object#django.views.generic.list.MultipleObjectTemplateResponseMixin&quot;&gt;&lt;code&gt;a range of
options&lt;/code&gt;&lt;/a&gt;, with the most commonly-used being &lt;code&gt;&amp;lt;app_label&amp;gt;/&amp;lt;model_name&amp;gt;_list.html&lt;/code&gt;, with the &lt;code&gt;_list&lt;/code&gt; part again being taken from the &lt;a href=&quot;../../ref/class-based-views/mixins-multiple-object#django.views.generic.list.MultipleObjectTemplateResponseMixin.template_name_suffix&quot;&gt;&lt;code&gt;template_name_suffix&lt;/code&gt;&lt;/a&gt; attribute. (The date based generic views use suffixes such as &lt;code&gt;_archive&lt;/code&gt;, &lt;code&gt;_archive_year&lt;/code&gt; and so on to use different templates for the various specialized date-based list views.)</source>
          <target state="translated">a를 위해 &lt;a href=&quot;../../ref/template-response#django.template.response.TemplateResponse&quot;&gt; &lt;code&gt;TemplateResponse&lt;/code&gt; 을&lt;/a&gt; , &lt;a href=&quot;https://docs.djangoproject.com/en/3.0/ref/class-based-views/flattened-index/#ListView&quot;&gt; &lt;code&gt;ListView&lt;/code&gt; 에는&lt;/a&gt; 다음 사용 &lt;a href=&quot;../../ref/class-based-views/mixins-multiple-object#django.views.generic.list.MultipleObjectTemplateResponseMixin&quot;&gt; &lt;code&gt;MultipleObjectTemplateResponseMixin&lt;/code&gt; 는&lt;/a&gt; ; 위의 &lt;a href=&quot;../../ref/class-based-views/mixins-single-object#django.views.generic.detail.SingleObjectTemplateResponseMixin&quot;&gt; &lt;code&gt;SingleObjectTemplateResponseMixin&lt;/code&gt; &lt;/a&gt; 과 마찬가지로 , &lt;code&gt;get_template_names()&lt;/code&gt; 를 재정 의하여 가장 &lt;a href=&quot;../../ref/class-based-views/mixins-multiple-object#django.views.generic.list.MultipleObjectTemplateResponseMixin&quot;&gt; &lt;code&gt;a range of options&lt;/code&gt; &lt;/a&gt; 을 제공 하고 &lt;code&gt;&amp;lt;app_label&amp;gt;/&amp;lt;model_name&amp;gt;_list.html&lt;/code&gt; 과 함께 &lt;code&gt;_list&lt;/code&gt; 부분을 &lt;a href=&quot;../../ref/class-based-views/mixins-multiple-object#django.views.generic.list.MultipleObjectTemplateResponseMixin.template_name_suffix&quot;&gt; &lt;code&gt;template_name_suffix&lt;/code&gt; &lt;/a&gt; 속성 에서 다시 가져옵니다 . 날짜 기반 일반 뷰는 &lt;code&gt;_archive&lt;/code&gt; , &lt;code&gt;_archive_year&lt;/code&gt; 등과 같은 접미사 를 사용하여 다양한 특수 날짜 기반 목록 뷰에 다른 템플릿을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ca01aa7dc8d510ddd6404060503124f9be2550e6" translate="yes" xml:space="preserve">
          <source>To make a database user with the ability to create databases, use the following command:</source>
          <target state="translated">데이터베이스를 작성할 수있는 데이터베이스 사용자를 작성하려면 다음 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9a6c7a36589674f719f8be165aa09666c30df38f" translate="yes" xml:space="preserve">
          <source>To make it easy to include Django&amp;rsquo;s permission framework into your own user class, Django provides &lt;a href=&quot;#django.contrib.auth.models.PermissionsMixin&quot;&gt;&lt;code&gt;PermissionsMixin&lt;/code&gt;&lt;/a&gt;. This is an abstract model you can include in the class hierarchy for your user model, giving you all the methods and database fields necessary to support Django&amp;rsquo;s permission model.</source>
          <target state="translated">Django의 권한 프레임 워크를 사용자 클래스에 쉽게 포함시키기 위해 Django는 &lt;a href=&quot;#django.contrib.auth.models.PermissionsMixin&quot;&gt; &lt;code&gt;PermissionsMixin&lt;/code&gt; 을&lt;/a&gt; 제공합니다 . 이것은 사용자 모델의 클래스 계층 구조에 포함 할 수있는 추상 모델이며, Django의 권한 모델을 지원하는 데 필요한 모든 메소드와 데이터베이스 필드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e10cf317e715c56a5544042f851627a316008c9e" translate="yes" xml:space="preserve">
          <source>To make sure your template tags are thread safe, you should never store state information on the node itself. For example, Django provides a builtin &lt;a href=&quot;../ref/templates/builtins#std:templatetag-cycle&quot;&gt;&lt;code&gt;cycle&lt;/code&gt;&lt;/a&gt; template tag that cycles among a list of given strings each time it&amp;rsquo;s rendered:</source>
          <target state="translated">템플릿 태그가 스레드에 안전하도록하려면 노드 자체에 상태 정보를 저장해서는 안됩니다. 예를 들어, Django는 렌더링 될 때마다 지정된 문자열 목록 사이를 순환 하는 내장 &lt;a href=&quot;../ref/templates/builtins#std:templatetag-cycle&quot;&gt; &lt;code&gt;cycle&lt;/code&gt; &lt;/a&gt; 템플릿 태그를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="0ac3e172478172f45b73523b0b92db40ee32caf6" translate="yes" xml:space="preserve">
          <source>To make the tutorial shorter, all template examples use incomplete HTML. In your own projects you should use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/Getting_started#Anatomy_of_an_HTML_document&quot;&gt;complete HTML documents&lt;/a&gt;.</source>
          <target state="translated">자습서를 더 짧게 만들기 위해 모든 템플릿 예제는 불완전한 HTML을 사용합니다. 자신의 프로젝트에서는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/Getting_started#Anatomy_of_an_HTML_document&quot;&gt;완전한 HTML 문서&lt;/a&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="097f7c4a300b255715774f4a04eff1912247ae24" translate="yes" xml:space="preserve">
          <source>To make use of the caching behavior of &lt;code&gt;QuerySet&lt;/code&gt;, you may need to use the &lt;a href=&quot;../../ref/templates/builtins#std:templatetag-with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; template tag.</source>
          <target state="translated">&lt;code&gt;QuerySet&lt;/code&gt; 의 캐싱 동작 을 사용하려면 &lt;a href=&quot;../../ref/templates/builtins#std:templatetag-with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; template 태그 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1ef43b45b7098726a6240c3b5678aa3381ab235a" translate="yes" xml:space="preserve">
          <source>To manually resolve a &lt;code&gt;CircularDependencyError&lt;/code&gt;, break out one of the ForeignKeys in the circular dependency loop into a separate migration, and move the dependency on the other app with it. If you&amp;rsquo;re unsure, see how &lt;a href=&quot;../ref/django-admin#django-admin-makemigrations&quot;&gt;&lt;code&gt;makemigrations&lt;/code&gt;&lt;/a&gt; deals with the problem when asked to create brand new migrations from your models. In a future release of Django, &lt;a href=&quot;../ref/django-admin#django-admin-squashmigrations&quot;&gt;&lt;code&gt;squashmigrations&lt;/code&gt;&lt;/a&gt; will be updated to attempt to resolve these errors itself.</source>
          <target state="translated">&lt;code&gt;CircularDependencyError&lt;/code&gt; 를 수동으로 해결하려면 순환 종속성 루프의 ForeignKeys 중 하나를 별도의 마이그레이션으로 분리하고 다른 앱에 대한 종속성을 다른 마이그레이션으로 이동하십시오. 확실하지 않은 경우 모델에서 새 마이그레이션을 생성하라는 메시지가 표시되면 &lt;a href=&quot;../ref/django-admin#django-admin-makemigrations&quot;&gt; &lt;code&gt;makemigrations&lt;/code&gt; &lt;/a&gt; 가 문제를 어떻게 처리 하는지 확인하십시오 . Django의 다음 릴리스에서는 이러한 오류 자체를 해결하기 위해 &lt;a href=&quot;../ref/django-admin#django-admin-squashmigrations&quot;&gt; &lt;code&gt;squashmigrations&lt;/code&gt; &lt;/a&gt; 가 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="a65740b15dc1324e8ab6675ef8918dd329d4fc39" translate="yes" xml:space="preserve">
          <source>To map a &lt;code&gt;Field&lt;/code&gt; to a database-specific type, Django exposes several methods:</source>
          <target state="translated">Django는 &lt;code&gt;Field&lt;/code&gt; 를 데이터베이스 별 유형에 매핑하기 위해 몇 가지 방법을 노출합니다.</target>
        </trans-unit>
        <trans-unit id="ed8e29f95821d713561cedad08d9a419bc12e750" translate="yes" xml:space="preserve">
          <source>To mark the output as a safe string, use &lt;a href=&quot;../ref/utils#django.utils.safestring.mark_safe&quot;&gt;&lt;code&gt;django.utils.safestring.mark_safe()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">출력을 안전한 문자열로 표시하려면 &lt;a href=&quot;../ref/utils#django.utils.safestring.mark_safe&quot;&gt; &lt;code&gt;django.utils.safestring.mark_safe()&lt;/code&gt; &lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2abb96d8420d49cfa11c625524c74ddde0cf0d5" translate="yes" xml:space="preserve">
          <source>To modify the session and then save it, it must be stored in a variable first (because a new &lt;code&gt;SessionStore&lt;/code&gt; is created every time this property is accessed):</source>
          <target state="translated">세션을 수정 한 후 저장하려면 먼저 변수에 저장해야합니다 ( 이 특성에 액세스 할 때마다 새 &lt;code&gt;SessionStore&lt;/code&gt; 가 작성 되므로 ).</target>
        </trans-unit>
        <trans-unit id="9f3629d4ab730252cea3245c879bab3e2deef492" translate="yes" xml:space="preserve">
          <source>To order by &lt;code&gt;pub_date&lt;/code&gt; descending, then by &lt;code&gt;author&lt;/code&gt; ascending, use this:</source>
          <target state="translated">&lt;code&gt;pub_date&lt;/code&gt; 를 내림차순 으로 정렬 한 다음 &lt;code&gt;author&lt;/code&gt; 오름차순으로 정렬 하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9168398518075271d3adee0f7783ac0e0183544d" translate="yes" xml:space="preserve">
          <source>To order by &lt;code&gt;pub_date&lt;/code&gt; descending, use this:</source>
          <target state="translated">&lt;code&gt;pub_date&lt;/code&gt; 를 내림차순으로 주문하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c36a8120f941334e38d3c0d9d86ad3b4279328ce" translate="yes" xml:space="preserve">
          <source>To order by a field in a different model, use the same syntax as when you are querying across model relations. That is, the name of the field, followed by a double underscore (&lt;code&gt;__&lt;/code&gt;), followed by the name of the field in the new model, and so on for as many models as you want to join. For example:</source>
          <target state="translated">다른 모델의 필드를 기준으로 정렬하려면 모델 관계에서 쿼리 할 때와 동일한 구문을 사용하십시오. 즉, 필드 이름, 이중 밑줄 ( &lt;code&gt;__&lt;/code&gt; ), 새 모델의 필드 이름 등이 결합됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1155377a5472b987ecab520a04fe68bf4ace30c6" translate="yes" xml:space="preserve">
          <source>To override an admin template for a specific app, copy and edit the template from the &lt;code&gt;django/contrib/admin/templates/admin&lt;/code&gt; directory, and save it to one of the directories you just created.</source>
          <target state="translated">특정 앱에 대한 관리 템플릿을 재정의하려면 &lt;code&gt;django/contrib/admin/templates/admin&lt;/code&gt; 디렉토리 에서 템플릿을 복사 및 편집하여 방금 만든 디렉토리 중 하나에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="0333fec38d8fa2cdb19b20b1c32d048eb1a1d8cf" translate="yes" xml:space="preserve">
          <source>To override the database table name, use the &lt;code&gt;db_table&lt;/code&gt; parameter in &lt;code&gt;class Meta&lt;/code&gt;.</source>
          <target state="translated">데이터베이스 테이블 이름을 대체하려면 &lt;code&gt;class Meta&lt;/code&gt; 에서 &lt;code&gt;db_table&lt;/code&gt; 매개 변수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="86a8fb1311f30c29c5ce8a362b20754970e95043" translate="yes" xml:space="preserve">
          <source>To override widget templates, you must use the &lt;a href=&quot;#django.forms.renderers.TemplatesSetting&quot;&gt;&lt;code&gt;TemplatesSetting&lt;/code&gt;&lt;/a&gt; renderer. Then overriding widget templates works &lt;a href=&quot;../../howto/overriding-templates&quot;&gt;the same as&lt;/a&gt; overriding any other template in your project.</source>
          <target state="translated">위젯 템플릿을 재정의하려면 &lt;a href=&quot;#django.forms.renderers.TemplatesSetting&quot;&gt; &lt;code&gt;TemplatesSetting&lt;/code&gt; &lt;/a&gt; 렌더러를 사용해야합니다 . 그런 다음 위젯 템플릿 &lt;a href=&quot;../../howto/overriding-templates&quot;&gt;을&lt;/a&gt; 재정의하면 프로젝트의 다른 템플릿 을 재정의 하는 것과 동일하게 작동 합니다 .</target>
        </trans-unit>
        <trans-unit id="1c82bfccb4e359e6c38351250a2e0a2d48cbccee" translate="yes" xml:space="preserve">
          <source>To pick an example, we might want to order a list of books by publication date, with the most recent first:</source>
          <target state="translated">예를 선택하기 위해 가장 최근의 책을 출판 날짜순으로 주문할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1c60922692d44778690595c6c3cb5c8aa83a8cc" translate="yes" xml:space="preserve">
          <source>To prevent a new migration from being created each time &lt;a href=&quot;../ref/django-admin#django-admin-makemigrations&quot;&gt;&lt;code&gt;makemigrations&lt;/code&gt;&lt;/a&gt; is run, you should also add a &lt;code&gt;__eq__()&lt;/code&gt; method to the decorated class. This function will be called by Django&amp;rsquo;s migration framework to detect changes between states.</source>
          <target state="translated">&lt;a href=&quot;../ref/django-admin#django-admin-makemigrations&quot;&gt; &lt;code&gt;makemigrations&lt;/code&gt; &lt;/a&gt; 가 실행될 때마다 새 마이그레이션이 생성되지 않도록하려면 데코 레이팅 된 클래스에 &lt;code&gt;__eq__()&lt;/code&gt; 메서드를 추가해야합니다 . 이 함수는 Django의 마이그레이션 프레임 워크에 의해 호출되어 상태 간의 변화를 감지합니다.</target>
        </trans-unit>
        <trans-unit id="8b0e8569ae6169ad48efc19e59bd57073d9847ef" translate="yes" xml:space="preserve">
          <source>To prevent a subquery from returning multiple rows, a slice (&lt;code&gt;[:1]&lt;/code&gt;) of the queryset is used:</source>
          <target state="translated">하위 쿼리가 여러 행을 반환하지 못하도록 쿼리 집합의 슬라이스 ( &lt;code&gt;[:1]&lt;/code&gt; )가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1e3800e863d80fb570e2314d0fdc1217dd40f511" translate="yes" xml:space="preserve">
          <source>To prevent serialized data from being loaded twice, setting &lt;code&gt;serialized_rollback=True&lt;/code&gt; disables the &lt;a href=&quot;../../ref/signals#django.db.models.signals.post_migrate&quot;&gt;&lt;code&gt;post_migrate&lt;/code&gt;&lt;/a&gt; signal when flushing the test database.</source>
          <target state="translated">직렬화 된 데이터가 두 번로드되지 않도록하려면 &lt;code&gt;serialized_rollback=True&lt;/code&gt; 를 설정 하면 테스트 데이터베이스를 &lt;a href=&quot;../../ref/signals#django.db.models.signals.post_migrate&quot;&gt; &lt;code&gt;post_migrate&lt;/code&gt; &lt;/a&gt; 때 post_migrate 신호가 비활성화 됩니다.</target>
        </trans-unit>
        <trans-unit id="e55b54e592245513a68fa8b680fdeaf73a6ae558" translate="yes" xml:space="preserve">
          <source>To prevent the browser from guessing the content type and force it to always use the type provided in the &lt;code&gt;Content-Type&lt;/code&gt; header, you can pass the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options&quot;&gt;X-Content-Type-Options: nosniff&lt;/a&gt; header. &lt;code&gt;SecurityMiddleware&lt;/code&gt; will do this for all responses if the &lt;a href=&quot;settings#std:setting-SECURE_CONTENT_TYPE_NOSNIFF&quot;&gt;&lt;code&gt;SECURE_CONTENT_TYPE_NOSNIFF&lt;/code&gt;&lt;/a&gt; setting is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">브라우저가 컨텐츠 유형을 추측하지 않고 &lt;code&gt;Content-Type&lt;/code&gt; 헤더에 제공된 유형을 항상 사용 하도록 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options&quot;&gt;X-Content-Type-Options : nosniff&lt;/a&gt; 헤더를 전달할 수 있습니다 . &lt;a href=&quot;settings#std:setting-SECURE_CONTENT_TYPE_NOSNIFF&quot;&gt; &lt;code&gt;SECURE_CONTENT_TYPE_NOSNIFF&lt;/code&gt; &lt;/a&gt; 설정이 &lt;code&gt;True&lt;/code&gt; 인 경우 &lt;code&gt;SecurityMiddleware&lt;/code&gt; 는 모든 응답에 대해이 작업을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="4ea70e9f1000103eca9dd81608549b7f843b34f7" translate="yes" xml:space="preserve">
          <source>To prevent these transformations (this is usually required only when dealing with legacy databases or accessing tables which belong to other users), use a quoted name as the value for &lt;code&gt;db_table&lt;/code&gt;:</source>
          <target state="translated">이러한 변환을 방지하려면 (일반적으로 레거시 데이터베이스를 처리하거나 다른 사용자에게 속한 테이블에 액세스 할 때만 필요함) 인용 된 이름을 &lt;code&gt;db_table&lt;/code&gt; 의 값으로 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4ee414f446a97ee1373d2e4d52243ad59fbedc45" translate="yes" xml:space="preserve">
          <source>To prevent this, Django provides the ability to prefix all cache keys used by a server. When a particular cache key is saved or retrieved, Django will automatically prefix the cache key with the value of the &lt;a href=&quot;../ref/settings#std:setting-CACHES-KEY_PREFIX&quot;&gt;&lt;code&gt;KEY_PREFIX&lt;/code&gt;&lt;/a&gt; cache setting.</source>
          <target state="translated">이를 방지하기 위해 Django는 서버에서 사용하는 모든 캐시 키를 접두어로 붙일 수있는 기능을 제공합니다. 특정 캐시 키가 저장 또는 검색되면 Django는 자동으로 캐시 키 앞에 &lt;a href=&quot;../ref/settings#std:setting-CACHES-KEY_PREFIX&quot;&gt; &lt;code&gt;KEY_PREFIX&lt;/code&gt; &lt;/a&gt; 캐시 설정 값을 붙 입니다.</target>
        </trans-unit>
        <trans-unit id="7349e69fa1ce99f07283d4bae013bf1dc2656977" translate="yes" xml:space="preserve">
          <source>To prevent this, set an &lt;code&gt;alters_data&lt;/code&gt; attribute on the callable variable. The template system won&amp;rsquo;t call a variable if it has &lt;code&gt;alters_data=True&lt;/code&gt; set, and will instead replace the variable with &lt;code&gt;string_if_invalid&lt;/code&gt;, unconditionally. The dynamically-generated &lt;a href=&quot;../models/instances#django.db.models.Model.delete&quot;&gt;&lt;code&gt;delete()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../models/instances#django.db.models.Model.save&quot;&gt;&lt;code&gt;save()&lt;/code&gt;&lt;/a&gt; methods on Django model objects get &lt;code&gt;alters_data=True&lt;/code&gt; automatically. Example:</source>
          <target state="translated">이를 방지하려면 호출 가능 변수에 &lt;code&gt;alters_data&lt;/code&gt; 속성을 설정 하십시오. 템플릿 시스템은 &lt;code&gt;alters_data=True&lt;/code&gt; 가 설정되어 있으면 변수를 호출하지 않고 무조건 변수를 &lt;code&gt;string_if_invalid&lt;/code&gt; 로바꿉니다 . Django 모델 객체에서 동적으로 생성 된 &lt;a href=&quot;../models/instances#django.db.models.Model.delete&quot;&gt; &lt;code&gt;delete()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../models/instances#django.db.models.Model.save&quot;&gt; &lt;code&gt;save()&lt;/code&gt; &lt;/a&gt; 메소드는 자동으로 &lt;code&gt;alters_data=True&lt;/code&gt; 를 얻 습니다 . 예:</target>
        </trans-unit>
        <trans-unit id="4d2524738e846efefcc9c7fc0fe196047d822943" translate="yes" xml:space="preserve">
          <source>To print the SQL that would be run, rather than run it, use the &lt;a href=&quot;../ref/django-admin#cmdoption-createcachetable-dry-run&quot;&gt;&lt;code&gt;createcachetable --dry-run&lt;/code&gt;&lt;/a&gt; option.</source>
          <target state="translated">실행하지 않고 실행될 SQL을 인쇄하려면 &lt;a href=&quot;../ref/django-admin#cmdoption-createcachetable-dry-run&quot;&gt; &lt;code&gt;createcachetable --dry-run&lt;/code&gt; &lt;/a&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="474d55192d63e8cc0d1e7c7fe308e0e1730c31d0" translate="yes" xml:space="preserve">
          <source>To protect against &lt;a href=&quot;https://en.wikipedia.org/wiki/SQL_injection&quot;&gt;SQL injection attacks&lt;/a&gt;, you must escape any parameters that the user can control by using &lt;code&gt;params&lt;/code&gt;. &lt;code&gt;params&lt;/code&gt; is a required argument to force you to acknowledge that you&amp;rsquo;re not interpolating your SQL with user-provided data.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/SQL_injection&quot;&gt;SQL 인젝션 공격&lt;/a&gt; 으로부터 보호하려면 &lt;code&gt;params&lt;/code&gt; 를 사용하여 사용자가 제어 할 수있는 모든 매개 변수를 이스케이프해야합니다 . &lt;code&gt;params&lt;/code&gt; 는 사용자가 제공 한 데이터로 SQL을 보간하지 않는다는 것을 인정하기 위해 필요한 인수입니다.</target>
        </trans-unit>
        <trans-unit id="d50819175119c401b13354ca2231e0aa3bcbf3d4" translate="yes" xml:space="preserve">
          <source>To protect against SQL injection, you must not include quotes around the &lt;code&gt;%s&lt;/code&gt; placeholders in the SQL string.</source>
          <target state="translated">SQL 삽입을 방지하려면 SQL 문자열에서 &lt;code&gt;%s&lt;/code&gt; 자리 표시 자 주위에 따옴표를 포함하지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="89d33d8d7e1ca93bcd45128d829ea44b210c1487" translate="yes" xml:space="preserve">
          <source>To provide an intermediary page, return an &lt;a href=&quot;../../request-response#django.http.HttpResponse&quot;&gt;&lt;code&gt;HttpResponse&lt;/code&gt;&lt;/a&gt; (or subclass) from your action. For example, you might write a export function that uses Django&amp;rsquo;s &lt;a href=&quot;../../../topics/serialization&quot;&gt;serialization functions&lt;/a&gt; to dump some selected objects as JSON:</source>
          <target state="translated">중개 페이지를 제공하려면 조치에서 &lt;a href=&quot;../../request-response#django.http.HttpResponse&quot;&gt; &lt;code&gt;HttpResponse&lt;/code&gt; &lt;/a&gt; (또는 서브 클래스)를 리턴 하십시오. 예를 들어, Django의 &lt;a href=&quot;../../../topics/serialization&quot;&gt;직렬화 함수&lt;/a&gt; 를 사용 하여 선택된 일부 객체를 JSON으로 덤프 하는 내보내기 함수를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="967b1f1f3861b4fe730b2f72236198ac38eac862" translate="yes" xml:space="preserve">
          <source>To provide thread-safety, a different instance of the cache backend will be returned for each thread.</source>
          <target state="translated">스레드 안전성을 제공하기 위해 각 스레드마다 다른 캐시 백엔드 인스턴스가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="e384c9b6a6947556bfb3455e671772e2e29c2842" translate="yes" xml:space="preserve">
          <source>To query based on a given dictionary key, use that key as the lookup name:</source>
          <target state="translated">주어진 사전 키를 기반으로 쿼리하려면 해당 키를 조회 이름으로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="18e8bb9c2d051da9589c355c95c2faaccf38ff14" translate="yes" xml:space="preserve">
          <source>To query based on a given key, you can use that key as the lookup name:</source>
          <target state="translated">주어진 키를 기준으로 쿼리하려면 해당 키를 조회 이름으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00b71e3f18734eac77180537ecb388dec18313c2" translate="yes" xml:space="preserve">
          <source>To query for &lt;code&gt;null&lt;/code&gt; in JSON data, use &lt;code&gt;None&lt;/code&gt; as a value:</source>
          <target state="translated">JSON 데이터에서 &lt;code&gt;null&lt;/code&gt; 을 쿼리하려면 &lt;code&gt;None&lt;/code&gt; 을 값으로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f0d33ba8b5797d23f73ff8ab464e0dd8ed34342f" translate="yes" xml:space="preserve">
          <source>To query for missing keys, use the &lt;code&gt;isnull&lt;/code&gt; lookup:</source>
          <target state="translated">누락 된 키를 쿼리하려면 &lt;code&gt;isnull&lt;/code&gt; 조회를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fa4300f27cad2fde677245092d51cec5e2696452" translate="yes" xml:space="preserve">
          <source>To receive a signal, register a &lt;em&gt;receiver&lt;/em&gt; function using the &lt;a href=&quot;#django.dispatch.Signal.connect&quot;&gt;&lt;code&gt;Signal.connect()&lt;/code&gt;&lt;/a&gt; method. The receiver function is called when the signal is sent. All of the signal&amp;rsquo;s receiver functions are called one at a time, in the order they were registered.</source>
          <target state="translated">신호를 수신하려면 &lt;a href=&quot;#django.dispatch.Signal.connect&quot;&gt; &lt;code&gt;Signal.connect()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 &lt;em&gt;수신자&lt;/em&gt; 함수를 등록하십시오 . 신호가 전송되면 수신자 기능이 호출됩니다. 모든 신호의 수신기 기능은 등록 된 순서대로 한 번에 하나씩 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="17902d9cb95ce3302f806e97278549b86b4e4bfd" translate="yes" xml:space="preserve">
          <source>To reexamine all source code and templates for new translation strings and update all message files for &lt;strong&gt;all&lt;/strong&gt; languages, run this:</source>
          <target state="translated">새 번역 문자열에 대한 모든 소스 코드 및 템플릿을 다시 검토하고 &lt;strong&gt;모든&lt;/strong&gt; 언어에 대한 &lt;strong&gt;모든&lt;/strong&gt; 메시지 파일을 업데이트 하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="218431610ff169a0ddfc890b9b025fdf1af0fda1" translate="yes" xml:space="preserve">
          <source>To refer to models defined in another application, you can explicitly specify a model with the full application label. For example, if the &lt;code&gt;Manufacturer&lt;/code&gt; model above is defined in another application called &lt;code&gt;production&lt;/code&gt;, you&amp;rsquo;d need to use:</source>
          <target state="translated">다른 애플리케이션에 정의 된 모델을 참조하기 위해 전체 애플리케이션 레이블이있는 모델을 명시 적으로 지정할 수 있습니다. 예를 들어, 위 의 &lt;code&gt;Manufacturer&lt;/code&gt; 모델이 &lt;code&gt;production&lt;/code&gt; 이라는 다른 응용 프로그램에서 정의 된 경우 다음을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c3dd6aacadfc80673e0507ec5cf5469a982bbbf4" translate="yes" xml:space="preserve">
          <source>To register the &lt;code&gt;NotEqual&lt;/code&gt; lookup we will need to call &lt;code&gt;register_lookup&lt;/code&gt; on the field class we want the lookup to be available for. In this case, the lookup makes sense on all &lt;code&gt;Field&lt;/code&gt; subclasses, so we register it with &lt;code&gt;Field&lt;/code&gt; directly:</source>
          <target state="translated">&lt;code&gt;NotEqual&lt;/code&gt; 조회 를 등록하려면 조회를 사용할 필드 클래스에서 &lt;code&gt;register_lookup&lt;/code&gt; 을 호출해야합니다 . 이 경우 조회는 모든 &lt;code&gt;Field&lt;/code&gt; 서브 클래스에서 의미가 있으므로 &lt;code&gt;Field&lt;/code&gt; 에 직접 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="ac1030841ff49dc56c0fcf818146be53d3c6f351" translate="yes" xml:space="preserve">
          <source>To remove a metadata item, use &lt;code&gt;None&lt;/code&gt; as the metadata value.</source>
          <target state="translated">메타 데이터 항목을 제거하려면 메타 데이터 값으로 &lt;code&gt;None&lt;/code&gt; 을 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="58653187d1eebcc5e82130d30a0d8f990efae8ec" translate="yes" xml:space="preserve">
          <source>To remove old references, you can &lt;a href=&quot;#migration-squashing&quot;&gt;squash migrations&lt;/a&gt; or, if there aren&amp;rsquo;t many references, copy them into the migration files.</source>
          <target state="translated">이전 참조를 제거하려면 &lt;a href=&quot;#migration-squashing&quot;&gt;마이그레이션&lt;/a&gt; 을 스쿼시 하거나 참조가 많지 않은 경우 마이그레이션 파일로 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="e5506e21296606ad0ea57a1384dcc262341b7990" translate="yes" xml:space="preserve">
          <source>To represent database-table data in Python objects, Django uses an intuitive system: A model class represents a database table, and an instance of that class represents a particular record in the database table.</source>
          <target state="translated">Django는 Python 객체에서 데이터베이스 테이블 데이터를 나타 내기 위해 직관적 인 시스템을 사용합니다. 모델 클래스는 데이터베이스 테이블을 나타내고 해당 클래스의 인스턴스는 데이터베이스 테이블의 특정 레코드를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="25c648c5fc6a1c55cdc291d1506f75ee833d3b9f" translate="yes" xml:space="preserve">
          <source>To resolve URLs, the test client uses whatever URLconf is pointed-to by your &lt;a href=&quot;../../ref/settings#std:setting-ROOT_URLCONF&quot;&gt;&lt;code&gt;ROOT_URLCONF&lt;/code&gt;&lt;/a&gt; setting.</source>
          <target state="translated">URL을 확인하기 위해 테스트 클라이언트는 &lt;a href=&quot;../../ref/settings#std:setting-ROOT_URLCONF&quot;&gt; &lt;code&gt;ROOT_URLCONF&lt;/code&gt; &lt;/a&gt; 설정에서 가리키는 URLconf를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="3f4f2a36b7474ed22ee47ab663cc01d19e88f646" translate="yes" xml:space="preserve">
          <source>To resolve this, you can use &lt;code&gt;fk_name&lt;/code&gt; to &lt;a href=&quot;../../ref/forms/models#django.forms.models.inlineformset_factory&quot;&gt;&lt;code&gt;inlineformset_factory()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이를 해결하기 위해 &lt;code&gt;fk_name&lt;/code&gt; 을 사용 하여 &lt;a href=&quot;../../ref/forms/models#django.forms.models.inlineformset_factory&quot;&gt; &lt;code&gt;inlineformset_factory()&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78c264a1c9f248dfd6a44c1a7d47c02f12b07b43" translate="yes" xml:space="preserve">
          <source>To retrieve a &lt;em&gt;single&lt;/em&gt; object rather than a list (e.g. &lt;code&gt;SELECT foo FROM bar LIMIT 1&lt;/code&gt;), use an index instead of a slice. For example, this returns the first &lt;code&gt;Entry&lt;/code&gt; in the database, after ordering entries alphabetically by headline:</source>
          <target state="translated">목록이 아닌 &lt;em&gt;단일&lt;/em&gt; 객체 를 검색하려면 (예 : &lt;code&gt;SELECT foo FROM bar LIMIT 1&lt;/code&gt; ) 슬라이스 대신 인덱스를 사용하십시오. 예를 들어, 제목을 기준으로 사전 순으로 항목을 정렬 한 후 데이터베이스 의 첫 번째 &lt;code&gt;Entry&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4765ac48802bddf0999a7c15709843c14d246139" translate="yes" xml:space="preserve">
          <source>To retrieve a single &lt;code&gt;BoundField&lt;/code&gt;, use dictionary lookup syntax on your form using the field&amp;rsquo;s name as the key:</source>
          <target state="translated">단일 &lt;code&gt;BoundField&lt;/code&gt; 를 검색하려면 필드 이름을 키로 사용하여 양식에서 사전 조회 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="567c301e3e71ffb977789f4f66a8a3a693172f89" translate="yes" xml:space="preserve">
          <source>To retrieve all &lt;code&gt;BoundField&lt;/code&gt; objects, iterate the form:</source>
          <target state="translated">모든 &lt;code&gt;BoundField&lt;/code&gt; 객체 를 검색하려면 다음 형식을 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="0eb8e6ff9300735260e0501b9aaa7da90638d90d" translate="yes" xml:space="preserve">
          <source>To retrieve objects from your database, construct a &lt;a href=&quot;../../ref/models/querysets#django.db.models.query.QuerySet&quot;&gt;&lt;code&gt;QuerySet&lt;/code&gt;&lt;/a&gt; via a &lt;a href=&quot;managers#django.db.models.Manager&quot;&gt;&lt;code&gt;Manager&lt;/code&gt;&lt;/a&gt; on your model class.</source>
          <target state="translated">데이터베이스에서 객체를 검색하려면 모델 클래스 의 &lt;a href=&quot;managers#django.db.models.Manager&quot;&gt; &lt;code&gt;Manager&lt;/code&gt; &lt;/a&gt; 를 통해 &lt;a href=&quot;../../ref/models/querysets#django.db.models.query.QuerySet&quot;&gt; &lt;code&gt;QuerySet&lt;/code&gt; &lt;/a&gt; 을 구성 하십시오.</target>
        </trans-unit>
        <trans-unit id="7d1634e01ef31fcc492a099f0e55fba508d70b00" translate="yes" xml:space="preserve">
          <source>To retrieve the &amp;ldquo;last&amp;rdquo; five items in a queryset, you could do this:</source>
          <target state="translated">쿼리 세트에서 &quot;마지막&quot;5 개 항목을 검색하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="973b9aba21603070c2092b13f7436cbd426ccf42" translate="yes" xml:space="preserve">
          <source>To run a project&amp;rsquo;s test suite, the user usually needs these &lt;em&gt;additional&lt;/em&gt; privileges:</source>
          <target state="translated">프로젝트의 테스트 스위트를 실행하려면 일반적으로 다음과 같은 &lt;em&gt;추가&lt;/em&gt; 권한 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="c9532ce85b2e90166823ec55f1fb3b2d8d470152" translate="yes" xml:space="preserve">
          <source>To run on 1.2.3.4:7000 with a &lt;code&gt;test&lt;/code&gt; fixture:</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; 픽스처 와 함께 1.2.3.4:7000에서 실행하려면 :</target>
        </trans-unit>
        <trans-unit id="e7c999287cf0597293724b3bb9f941e4fe078978" translate="yes" xml:space="preserve">
          <source>To run only the GeoDjango test suite, specify &lt;code&gt;gis_tests&lt;/code&gt;:</source>
          <target state="translated">GeoDjango 테스트 스위트 만 실행하려면 gis_tests를 지정 &lt;code&gt;gis_tests&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67d835ef8f8485dc70780878bf83a8987cbdec91" translate="yes" xml:space="preserve">
          <source>To run the entire Django test suite, &lt;code&gt;cd&lt;/code&gt; into the Django &lt;code&gt;tests/&lt;/code&gt; directory and run:</source>
          <target state="translated">전체 Django 테스트 스위트를 실행하려면 Django &lt;code&gt;tests/&lt;/code&gt; 디렉토리 로 &lt;code&gt;cd&lt;/code&gt; 하고 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="3990cfbb61c88cf03e73164e2869860b861209a1" translate="yes" xml:space="preserve">
          <source>To run the test server on port 7000 with &lt;code&gt;fixture1&lt;/code&gt; and &lt;code&gt;fixture2&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;fixture1&lt;/code&gt; 및 &lt;code&gt;fixture2&lt;/code&gt; 를 사용하여 포트 7000에서 테스트 서버를 실행하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="c4f1d600c11b68aa9fd5322b4e9dd569205946cf" translate="yes" xml:space="preserve">
          <source>To save an object back to the database, call &lt;code&gt;save()&lt;/code&gt;:</source>
          <target state="translated">객체를 데이터베이스에 다시 저장하려면 save &lt;code&gt;save()&lt;/code&gt; 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="890a2f9f817fd2e54b44144270ec18b2d156e365" translate="yes" xml:space="preserve">
          <source>To save changes to an object that&amp;rsquo;s already in the database, use &lt;a href=&quot;../../ref/models/instances#django.db.models.Model.save&quot;&gt;&lt;code&gt;save()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">데이터베이스에 이미있는 객체에 변경 사항을 저장하려면 save &lt;a href=&quot;../../ref/models/instances#django.db.models.Model.save&quot;&gt; &lt;code&gt;save()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ce5d8df07e72d9b23f8c3596f642a7017463dd7" translate="yes" xml:space="preserve">
          <source>To save you time, Django automatically derives the name of the database table from the name of your model class and the app that contains it. A model&amp;rsquo;s database table name is constructed by joining the model&amp;rsquo;s &amp;ldquo;app label&amp;rdquo; &amp;ndash; the name you used in &lt;a href=&quot;../django-admin#django-admin-startapp&quot;&gt;&lt;code&gt;manage.py startapp&lt;/code&gt;&lt;/a&gt; &amp;ndash; to the model&amp;rsquo;s class name, with an underscore between them.</source>
          <target state="translated">Django는 시간을 절약하기 위해 모델 클래스 이름과 해당 클래스가 포함 된 앱에서 데이터베이스 테이블 이름을 자동으로 파생시킵니다. 모델의 데이터베이스 테이블 이름은 모델의 &quot;앱 레이블&quot;( &lt;a href=&quot;../django-admin#django-admin-startapp&quot;&gt; &lt;code&gt;manage.py startapp&lt;/code&gt; 에&lt;/a&gt; 사용 된 이름)을 모델의 클래스 이름에 결합하고 모델 이름 사이에 밑줄을 표시하여 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="821889f749eaa7a7c8d01712b3461d0e358828cd" translate="yes" xml:space="preserve">
          <source>To select all blogs that contain an entry with &lt;em&gt;&amp;ldquo;Lennon&amp;rdquo;&lt;/em&gt; in the headline &lt;strong&gt;as well as&lt;/strong&gt; an entry that was published in 2008, we would write:</source>
          <target state="translated">제목에 &lt;em&gt;&quot;Lennon&quot;이&lt;/em&gt; 있는 항목과 2008 년에 게시 된 항목 이 포함 된 모든 블로그를 선택하려면 다음과 &lt;strong&gt;같이&lt;/strong&gt; 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="4ed5624e0b2332d4616b353f72aa27df2c8cce76" translate="yes" xml:space="preserve">
          <source>To send a signal, call either &lt;a href=&quot;#django.dispatch.Signal.send&quot;&gt;&lt;code&gt;Signal.send()&lt;/code&gt;&lt;/a&gt; (all built-in signals use this) or &lt;a href=&quot;#django.dispatch.Signal.send_robust&quot;&gt;&lt;code&gt;Signal.send_robust()&lt;/code&gt;&lt;/a&gt;. You must provide the &lt;code&gt;sender&lt;/code&gt; argument (which is a class most of the time) and may provide as many other keyword arguments as you like.</source>
          <target state="translated">신호를 보내려면 &lt;a href=&quot;#django.dispatch.Signal.send&quot;&gt; &lt;code&gt;Signal.send()&lt;/code&gt; &lt;/a&gt; (모든 내장 신호가 이것을 사용) 또는 &lt;a href=&quot;#django.dispatch.Signal.send_robust&quot;&gt; &lt;code&gt;Signal.send_robust()&lt;/code&gt; &lt;/a&gt; . 당신은 제공해야 &lt;code&gt;sender&lt;/code&gt; (대부분의 시간의 수업입니다) 인수와 같은 다른 많은 키워드 인수로 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d5b26ae50352248c988a0bc326228e487be07b9" translate="yes" xml:space="preserve">
          <source>To send a text and HTML combination, you could write:</source>
          <target state="translated">텍스트와 HTML 조합을 보내려면 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7443b37aca9694d05f36a0a7319a761ec07706df" translate="yes" xml:space="preserve">
          <source>To separately render the label tag of a form field, you can call its &lt;code&gt;label_tag()&lt;/code&gt; method:</source>
          <target state="translated">양식 필드의 레이블 태그를 별도로 렌더링하려면 해당 &lt;code&gt;label_tag()&lt;/code&gt; 메소드를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="497fe9ebfd975f8aa11d69448f9789930f65b4a2" translate="yes" xml:space="preserve">
          <source>To set a variable in the context, use dictionary assignment on the context object in the &lt;code&gt;render()&lt;/code&gt; method. Here&amp;rsquo;s an updated version of &lt;code&gt;CurrentTimeNode&lt;/code&gt; that sets a template variable &lt;code&gt;current_time&lt;/code&gt; instead of outputting it:</source>
          <target state="translated">컨텍스트에서 변수를 설정하려면 &lt;code&gt;render()&lt;/code&gt; 메서드 의 컨텍스트 객체에 사전 할당을 사용하십시오 . 템플릿 변수 &lt;code&gt;current_time&lt;/code&gt; 을 출력하는 대신 설정하는 &lt;code&gt;CurrentTimeNode&lt;/code&gt; 의 업데이트 된 버전은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="69ad533068c5606f43827a23c110e468488685a4" translate="yes" xml:space="preserve">
          <source>To set an installation-wide language preference, set &lt;a href=&quot;../../ref/settings#std:setting-LANGUAGE_CODE&quot;&gt;&lt;code&gt;LANGUAGE_CODE&lt;/code&gt;&lt;/a&gt;. Django uses this language as the default translation &amp;ndash; the final attempt if no better matching translation is found through one of the methods employed by the locale middleware (see below).</source>
          <target state="translated">설치 전체 언어 환경 설정을 설정하려면 &lt;a href=&quot;../../ref/settings#std:setting-LANGUAGE_CODE&quot;&gt; &lt;code&gt;LANGUAGE_CODE&lt;/code&gt; 를&lt;/a&gt; 설정하십시오 . Django는이 언어를 기본 번역으로 사용합니다. 로케일 미들웨어에서 사용하는 방법 중 하나를 통해 더 일치하는 번역을 찾지 못하면 마지막 시도입니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="f3b76a8f45ccc02ebb34a720f86cd451e8bae55d" translate="yes" xml:space="preserve">
          <source>To set multiple values more efficiently, use &lt;code&gt;set_many()&lt;/code&gt; to pass a dictionary of key-value pairs:</source>
          <target state="translated">여러 값을보다 효율적으로 설정하려면 &lt;code&gt;set_many()&lt;/code&gt; 를 사용 하여 키-값 쌍의 사전을 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="3c89081d58b75bdc9d1b40ebb29e9d1048550715" translate="yes" xml:space="preserve">
          <source>To set or remove a header field in your response, treat it like a dictionary:</source>
          <target state="translated">응답에서 헤더 필드를 설정하거나 제거하려면 사전처럼 취급하십시오.</target>
        </trans-unit>
        <trans-unit id="7d790b7349782877df7f47c364825354ee8c3d96" translate="yes" xml:space="preserve">
          <source>To set or update a metadata item, pass the corresponding metadata item to the method using the nested structure described above. Only keys that are in the specified dictionary are updated; the rest of the metadata remains unchanged.</source>
          <target state="translated">메타 데이터 항목을 설정하거나 업데이트하려면 위에서 설명한 중첩 구조를 사용하여 해당 메타 데이터 항목을 메소드에 전달하십시오. 지정된 사전에있는 키만 업데이트됩니다. 나머지 메타 데이터는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d50eaa18a22441f9524b1956ed8f4ce8e7eeb129" translate="yes" xml:space="preserve">
          <source>To set the &lt;code&gt;X-Frame-Options&lt;/code&gt; header on a per view basis, Django provides these decorators:</source>
          <target state="translated">뷰별로 &lt;code&gt;X-Frame-Options&lt;/code&gt; 헤더 를 설정하기 위해 Django는 다음 데코레이터를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="804438197b065c1ce9b96fd3aac091baf3ae134b" translate="yes" xml:space="preserve">
          <source>To set the same &lt;code&gt;X-Frame-Options&lt;/code&gt; value for all responses in your site, put &lt;code&gt;'django.middleware.clickjacking.XFrameOptionsMiddleware'&lt;/code&gt; to &lt;a href=&quot;settings#std:setting-MIDDLEWARE&quot;&gt;&lt;code&gt;MIDDLEWARE&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">사이트의 모든 응답에 대해 동일한 &lt;code&gt;X-Frame-Options&lt;/code&gt; 값 을 설정하려면 &lt;code&gt;'django.middleware.clickjacking.XFrameOptionsMiddleware'&lt;/code&gt; 를 &lt;a href=&quot;settings#std:setting-MIDDLEWARE&quot;&gt; &lt;code&gt;MIDDLEWARE&lt;/code&gt; 로 설정하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7ffc7a39d85674f2db5a0831ce4a64e2cc1b2de5" translate="yes" xml:space="preserve">
          <source>To show the detail of an object, we basically need to do two things: we need to look up the object and then we need to make a &lt;a href=&quot;../../ref/template-response#django.template.response.TemplateResponse&quot;&gt;&lt;code&gt;TemplateResponse&lt;/code&gt;&lt;/a&gt; with a suitable template, and that object as context.</source>
          <target state="translated">객체의 세부 사항을 표시하려면 기본적으로 두 가지 작업을 수행해야합니다. 객체를 조회 한 다음 적절한 템플릿 으로 &lt;a href=&quot;../../ref/template-response#django.template.response.TemplateResponse&quot;&gt; &lt;code&gt;TemplateResponse&lt;/code&gt; &lt;/a&gt; 를 만들고 해당 객체를 컨텍스트 로 만들어야합니다 .</target>
        </trans-unit>
        <trans-unit id="d5a877e3f799d84c11fc2385ba2109f58d75fb1a" translate="yes" xml:space="preserve">
          <source>To show this resolution strategy in action, consider an example of two instances of the &lt;code&gt;polls&lt;/code&gt; application from the tutorial: one called &lt;code&gt;'author-polls'&lt;/code&gt; and one called &lt;code&gt;'publisher-polls'&lt;/code&gt;. Assume we have enhanced that application so that it takes the instance namespace into consideration when creating and displaying polls.</source>
          <target state="translated">이 해결 전략을 실제로 보여주기 위해 학습서 의 두 &lt;code&gt;polls&lt;/code&gt; 애플리케이션 인스턴스 ( &lt;code&gt;'author-polls'&lt;/code&gt; 및 &lt;code&gt;'publisher-polls'&lt;/code&gt; 의 두 가지 예를 고려하십시오 . 설문을 작성하고 표시 할 때 인스턴스 네임 스페이스를 고려하도록 해당 애플리케이션을 개선했다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="1337e6dfb3d68cc1e8eb8a0c2e00f823736a456e" translate="yes" xml:space="preserve">
          <source>To show what happens when you try to get more sophisticated, we show an example that sacrifices readability and maintainability when there is a simpler solution. First, let&amp;rsquo;s look at a naive attempt to combine &lt;a href=&quot;../../ref/class-based-views/generic-display#django.views.generic.detail.DetailView&quot;&gt;&lt;code&gt;DetailView&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;../../ref/class-based-views/mixins-editing#django.views.generic.edit.FormMixin&quot;&gt;&lt;code&gt;FormMixin&lt;/code&gt;&lt;/a&gt; to enable us to &lt;code&gt;POST&lt;/code&gt; a Django &lt;a href=&quot;../../ref/forms/api#django.forms.Form&quot;&gt;&lt;code&gt;Form&lt;/code&gt;&lt;/a&gt; to the same URL as we&amp;rsquo;re displaying an object using &lt;a href=&quot;https://docs.djangoproject.com/en/3.0/ref/class-based-views/flattened-index/#DetailView&quot;&gt;&lt;code&gt;DetailView&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">보다 정교 해 지려고 할 때 발생하는 상황을 보여주기 위해 더 간단한 솔루션이있을 때 가독성과 유지 관리 성을 희생하는 예를 보여줍니다. 먼저 &lt;a href=&quot;../../ref/class-based-views/mixins-editing#django.views.generic.edit.FormMixin&quot;&gt; &lt;code&gt;FormMixin&lt;/code&gt; &lt;/a&gt; 를 &lt;a href=&quot;../../ref/class-based-views/generic-display#django.views.generic.detail.DetailView&quot;&gt; &lt;code&gt;DetailView&lt;/code&gt; &lt;/a&gt; 과 결합 하여 DetailView 를 사용 하여 객체를 표시하는 것과 동일한 URL에 Django &lt;a href=&quot;../../ref/forms/api#django.forms.Form&quot;&gt; &lt;code&gt;Form&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;POST&lt;/code&gt; 할 수 있도록 순진한 시도를 살펴 &lt;a href=&quot;https://docs.djangoproject.com/en/3.0/ref/class-based-views/flattened-index/#DetailView&quot;&gt; &lt;code&gt;DetailView&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="521520f54722886a2e54d75ee6c633f1abe79507" translate="yes" xml:space="preserve">
          <source>To silence a particular type of &lt;code&gt;SuspiciousOperation&lt;/code&gt;, you can override that specific logger following this example:</source>
          <target state="translated">특정 유형의 &lt;code&gt;SuspiciousOperation&lt;/code&gt; 을 침묵 시키려면 다음 예에 따라 해당 특정 로거를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96f03767d2c982949b605e412965afc212fc4d18" translate="yes" xml:space="preserve">
          <source>To specify a custom widget for a field, use the &lt;code&gt;widgets&lt;/code&gt; attribute of the inner &lt;code&gt;Meta&lt;/code&gt; class. This should be a dictionary mapping field names to widget classes or instances.</source>
          <target state="translated">필드에 사용자 정의 위젯을 지정하려면 내부 &lt;code&gt;Meta&lt;/code&gt; 클래스 의 &lt;code&gt;widgets&lt;/code&gt; 속성을 사용하십시오 . 이것은 필드 이름을 위젯 클래스 또는 인스턴스에 사전 맵핑해야합니다.</target>
        </trans-unit>
        <trans-unit id="7334a2ff6f1cfa851f5ceaa48f8322ea8b760fdc" translate="yes" xml:space="preserve">
          <source>To specify a protocol other than &lt;code&gt;'http'&lt;/code&gt;, use &lt;a href=&quot;#django.contrib.sitemaps.Sitemap.protocol&quot;&gt;&lt;code&gt;protocol&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이외의 프로토콜 지정하려면 &lt;code&gt;'http'&lt;/code&gt; 를 사용 &lt;a href=&quot;#django.contrib.sitemaps.Sitemap.protocol&quot;&gt; &lt;code&gt;protocol&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d2733c45de684a6e50c59a672a277ec8487b9bf7" translate="yes" xml:space="preserve">
          <source>To specify dynamic initial data, see the &lt;a href=&quot;api#django.forms.Form.initial&quot;&gt;&lt;code&gt;Form.initial&lt;/code&gt;&lt;/a&gt; parameter.</source>
          <target state="translated">동적 초기 데이터를 지정하려면 &lt;a href=&quot;api#django.forms.Form.initial&quot;&gt; &lt;code&gt;Form.initial&lt;/code&gt; &lt;/a&gt; 매개 변수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d84076e7f25d13f39592f28046be385ed3f5504c" translate="yes" xml:space="preserve">
          <source>To specify enclosures, such as those used in creating podcast feeds, use the &lt;code&gt;item_enclosures&lt;/code&gt; hook or, alternatively and if you only have a single enclosure per item, the &lt;code&gt;item_enclosure_url&lt;/code&gt;, &lt;code&gt;item_enclosure_length&lt;/code&gt;, and &lt;code&gt;item_enclosure_mime_type&lt;/code&gt; hooks. See the &lt;code&gt;ExampleFeed&lt;/code&gt; class below for usage examples.</source>
          <target state="translated">Podcast 피드 생성에 사용되는 인클로저와 같은 인클로저를 지정하려면 &lt;code&gt;item_enclosures&lt;/code&gt; 후크를 사용하거나, 항목 당 하나의 인클로저 만있는 경우 &lt;code&gt;item_enclosure_url&lt;/code&gt; , &lt;code&gt;item_enclosure_length&lt;/code&gt; 및 &lt;code&gt;item_enclosure_mime_type&lt;/code&gt; 후크를 사용하십시오. 사용법 예제는 아래 &lt;code&gt;ExampleFeed&lt;/code&gt; 클래스를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f60ed6cc7713011694e00a1af10798b672fc080b" translate="yes" xml:space="preserve">
          <source>To specify that a field is &lt;em&gt;not&lt;/em&gt; required, pass &lt;code&gt;required=False&lt;/code&gt; to the &lt;code&gt;Field&lt;/code&gt; constructor:</source>
          <target state="translated">필드가 필요 &lt;em&gt;하지 않도록&lt;/em&gt; 지정하려면 &lt;code&gt;required=False&lt;/code&gt; 를 &lt;code&gt;Field&lt;/code&gt; 생성자에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="e98c02e6d9fd147c868e1c0d49aa5e9620b85f69" translate="yes" xml:space="preserve">
          <source>To specify the band index, an additional parameter can be specified on both sides of the lookup. On the left hand side, the double underscore syntax is used to pass a band index. On the right hand side, a tuple of the raster and band index can be specified.</source>
          <target state="translated">밴드 인덱스를 지정하기 위해 조회의 양쪽에 추가 매개 변수를 지정할 수 있습니다. 왼쪽에서 이중 밑줄 구문은 밴드 인덱스를 전달하는 데 사용됩니다. 오른쪽에는 래스터 및 밴드 인덱스의 튜플을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a1e291a777f75e6fb80364f656b45912c91eea9" translate="yes" xml:space="preserve">
          <source>To specify the contents of &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;, you have two options. For each item in &lt;code&gt;items()&lt;/code&gt;, Django first tries calling the &lt;code&gt;item_link()&lt;/code&gt; method on the &lt;a href=&quot;#django.contrib.syndication.views.Feed&quot;&gt;&lt;code&gt;Feed&lt;/code&gt;&lt;/a&gt; class. In a similar way to the title and description, it is passed it a single parameter, &lt;code&gt;item&lt;/code&gt;. If that method doesn&amp;rsquo;t exist, Django tries executing a &lt;code&gt;get_absolute_url()&lt;/code&gt; method on that object. Both &lt;code&gt;get_absolute_url()&lt;/code&gt; and &lt;code&gt;item_link()&lt;/code&gt; should return the item&amp;rsquo;s URL as a normal Python string. As with &lt;code&gt;get_absolute_url()&lt;/code&gt;, the result of &lt;code&gt;item_link()&lt;/code&gt; will be included directly in the URL, so you are responsible for doing all necessary URL quoting and conversion to ASCII inside the method itself.</source>
          <target state="translated">&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; 의 내용을 지정하려면 두 가지 옵션이 있습니다. Django 는 &lt;code&gt;items()&lt;/code&gt; 각 항목에 대해 먼저 &lt;a href=&quot;#django.contrib.syndication.views.Feed&quot;&gt; &lt;code&gt;Feed&lt;/code&gt; &lt;/a&gt; 클래스 에서 &lt;code&gt;item_link()&lt;/code&gt; 메소드 호출을 시도합니다 . 제목 및 설명과 유사한 방식으로 단일 매개 변수 &lt;code&gt;item&lt;/code&gt; 으로 전달됩니다 . 해당 메소드가 존재하지 않으면 Django는 해당 오브젝트에서 &lt;code&gt;get_absolute_url()&lt;/code&gt; 메소드를 실행하려고 시도 합니다. 두 &lt;code&gt;get_absolute_url()&lt;/code&gt; 와 &lt;code&gt;item_link()&lt;/code&gt; 일반 파이썬 문자열로 항목의 URL을 반환해야합니다. 와 같이 &lt;code&gt;get_absolute_url()&lt;/code&gt; 의 결과 &lt;code&gt;item_link()&lt;/code&gt; 이 URL에 직접 포함되므로 메소드 자체에서 필요한 모든 URL 인용 및 ASCII 변환을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="91579049fc7e2eebe1fccec84b51da89aee1b25f" translate="yes" xml:space="preserve">
          <source>To specify the database from which a model will be deleted, pass a &lt;code&gt;using&lt;/code&gt; keyword argument to the &lt;code&gt;Model.delete()&lt;/code&gt; method. This argument works just like the &lt;code&gt;using&lt;/code&gt; keyword argument to &lt;code&gt;save()&lt;/code&gt;.</source>
          <target state="translated">모델을 삭제할 데이터베이스를 지정하려면 &lt;code&gt;using&lt;/code&gt; 키워드 인수를 &lt;code&gt;Model.delete()&lt;/code&gt; 메소드에 전달하십시오. 이 인수는 키워드 인수를 &lt;code&gt;using&lt;/code&gt; 하여 &lt;code&gt;save()&lt;/code&gt; 처럼 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="3c8e8bd7481d1547775f0ff52a407c897a3724ca" translate="yes" xml:space="preserve">
          <source>To specify this backend, put the following in your settings:</source>
          <target state="translated">이 백엔드를 지정하려면 설정에 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="920adb2f866906791bd1463cd1efaa38ef75b46b" translate="yes" xml:space="preserve">
          <source>To start, make an empty migration file you can work from (Django will put the file in the right place, suggest a name, and add dependencies for you):</source>
          <target state="translated">시작하려면 작업 할 수있는 빈 마이그레이션 파일을 만드십시오 (Django는 파일을 올바른 위치에 놓고 이름을 제안하고 종속성을 추가합니다).</target>
        </trans-unit>
        <trans-unit id="cd60a624492a6f13df7c8fb2282a908a537335fa" translate="yes" xml:space="preserve">
          <source>To store session data using Django&amp;rsquo;s cache system, you&amp;rsquo;ll first need to make sure you&amp;rsquo;ve configured your cache; see the &lt;a href=&quot;../cache&quot;&gt;cache documentation&lt;/a&gt; for details.</source>
          <target state="translated">Django의 캐시 시스템을 사용하여 세션 데이터를 저장하려면 먼저 캐시를 구성했는지 확인해야합니다. 자세한 내용은 &lt;a href=&quot;../cache&quot;&gt;캐시 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cf410959dfd7187b1b8181380f0a33db67f70b91" translate="yes" xml:space="preserve">
          <source>To submit multiple values for a given key &amp;ndash; for example, to specify the selections for a &lt;code&gt;&amp;lt;select multiple&amp;gt;&lt;/code&gt; &amp;ndash; provide the values as a list or tuple for the required key. For example, this value of &lt;code&gt;data&lt;/code&gt; would submit three selected values for the field named &lt;code&gt;choices&lt;/code&gt;:</source>
          <target state="translated">주어진 키에 대해 여러 값을 제출하려면 (예 : &lt;code&gt;&amp;lt;select multiple&amp;gt;&lt;/code&gt; 대한 선택 사항 지정) 값을 필요한 키의 목록 또는 튜플로 제공하십시오. 예를 들어,이 &lt;code&gt;data&lt;/code&gt; 값은 &lt;code&gt;choices&lt;/code&gt; 필드에 대해 선택된 3 개의 값을 제출 합니다 .</target>
        </trans-unit>
        <trans-unit id="cf96ae154547dae883208bd4fd929f84de5a0e60" translate="yes" xml:space="preserve">
          <source>To supplement these test skipping behaviors, Django provides two additional skip decorators. Instead of testing a generic boolean, these decorators check the capabilities of the database, and skip the test if the database doesn&amp;rsquo;t support a specific named feature.</source>
          <target state="translated">이러한 테스트 건너 뛰기 동작을 보완하기 위해 Django는 두 개의 추가 건너 뛰기 데코레이터를 제공합니다. 이 데코레이터는 일반 부울을 테스트하는 대신 데이터베이스의 기능을 확인하고 데이터베이스가 특정 명명 된 기능을 지원하지 않으면 테스트를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="a305ef1167e836dfcebd05c82099108731fe8fbe" translate="yes" xml:space="preserve">
          <source>To support the &lt;code&gt;WSGIAuthGroupScript&lt;/code&gt; directive, the same WSGI script &lt;code&gt;mysite.wsgi&lt;/code&gt; must also import the &lt;code&gt;groups_for_user&lt;/code&gt; function which returns a list groups the given user belongs to.</source>
          <target state="translated">&lt;code&gt;WSGIAuthGroupScript&lt;/code&gt; 지시문 을 지원하려면 동일한 WSGI 스크립트 &lt;code&gt;mysite.wsgi&lt;/code&gt; 도 주어진 사용자가 속한 목록 그룹을 리턴하는 &lt;code&gt;groups_for_user&lt;/code&gt; 함수를 가져와야합니다 .</target>
        </trans-unit>
        <trans-unit id="b934389e1e43f1dffc82897f88fb50a594fdbb0c" translate="yes" xml:space="preserve">
          <source>To systematically hide all POST parameters of a request in error reports, do not provide any argument to the &lt;code&gt;sensitive_post_parameters&lt;/code&gt; decorator:</source>
          <target state="translated">오류 보고서에서 요청의 모든 POST 매개 변수를 체계적으로 숨기려면 &lt;code&gt;sensitive_post_parameters&lt;/code&gt; 데코레이터에 인수를 제공하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="1ae8b00e224406053f2eea0c00f9c74a1bd7e163" translate="yes" xml:space="preserve">
          <source>To systematically hide all local variables of a function from error logs, do not provide any argument to the &lt;code&gt;sensitive_variables&lt;/code&gt; decorator:</source>
          <target state="translated">오류 로그에서 함수의 모든 로컬 변수를 체계적으로 숨기려면 &lt;code&gt;sensitive_variables&lt;/code&gt; 데코레이터에 인수를 제공하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="94cb9a3ba3f31c87a3d8bb2defe98f00c4f78a66" translate="yes" xml:space="preserve">
          <source>To take advantage of CSRF protection in your views, follow these steps:</source>
          <target state="translated">보기에서 CSRF 보호를 활용하려면 다음 단계를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="477503c4da2f549d196cdf06ef3af367b281680a" translate="yes" xml:space="preserve">
          <source>To tell the browser to treat the response as a file attachment, use the &lt;code&gt;content_type&lt;/code&gt; argument and set the &lt;code&gt;Content-Disposition&lt;/code&gt; header. For example, this is how you might return a Microsoft Excel spreadsheet:</source>
          <target state="translated">브라우저에 응답을 파일 첨부로 처리하도록 지시하려면 &lt;code&gt;content_type&lt;/code&gt; 인수를 사용하고 &lt;code&gt;Content-Disposition&lt;/code&gt; 헤더를 설정하십시오 . 예를 들어, 다음은 Microsoft Excel 스프레드 시트를 반환하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="955cb9fdd64d64078fd752a0a8a33891962420a9" translate="yes" xml:space="preserve">
          <source>To test the response of a custom error handler, raise the appropriate exception in a test view. For example:</source>
          <target state="translated">사용자 정의 오류 핸들러의 응답을 테스트하려면 테스트보기에서 적절한 예외를 발생 시키십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e5ff185e23bfe01550eeb9a52e5d8f22f590bd68" translate="yes" xml:space="preserve">
          <source>To then make a &lt;a href=&quot;../../ref/template-response#django.template.response.TemplateResponse&quot;&gt;&lt;code&gt;TemplateResponse&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.djangoproject.com/en/3.0/ref/class-based-views/flattened-index/#DetailView&quot;&gt;&lt;code&gt;DetailView&lt;/code&gt;&lt;/a&gt; uses &lt;a href=&quot;../../ref/class-based-views/mixins-single-object#django.views.generic.detail.SingleObjectTemplateResponseMixin&quot;&gt;&lt;code&gt;SingleObjectTemplateResponseMixin&lt;/code&gt;&lt;/a&gt;, which extends &lt;a href=&quot;../../ref/class-based-views/mixins-simple#django.views.generic.base.TemplateResponseMixin&quot;&gt;&lt;code&gt;TemplateResponseMixin&lt;/code&gt;&lt;/a&gt;, overriding &lt;a href=&quot;../../ref/class-based-views/mixins-simple#django.views.generic.base.TemplateResponseMixin.get_template_names&quot;&gt;&lt;code&gt;get_template_names()&lt;/code&gt;&lt;/a&gt; as discussed above. It actually provides a fairly sophisticated set of options, but the main one that most people are going to use is &lt;code&gt;&amp;lt;app_label&amp;gt;/&amp;lt;model_name&amp;gt;_detail.html&lt;/code&gt;. The &lt;code&gt;_detail&lt;/code&gt; part can be changed by setting &lt;a href=&quot;../../ref/class-based-views/mixins-single-object#django.views.generic.detail.SingleObjectTemplateResponseMixin.template_name_suffix&quot;&gt;&lt;code&gt;template_name_suffix&lt;/code&gt;&lt;/a&gt; on a subclass to something else. (For instance, the &lt;a href=&quot;generic-editing&quot;&gt;generic edit views&lt;/a&gt; use &lt;code&gt;_form&lt;/code&gt; for create and update views, and &lt;code&gt;_confirm_delete&lt;/code&gt; for delete views.)</source>
          <target state="translated">다음하려면 &lt;a href=&quot;../../ref/template-response#django.template.response.TemplateResponse&quot;&gt; &lt;code&gt;TemplateResponse&lt;/code&gt; 을&lt;/a&gt; , &lt;a href=&quot;https://docs.djangoproject.com/en/3.0/ref/class-based-views/flattened-index/#DetailView&quot;&gt; &lt;code&gt;DetailView&lt;/code&gt; 는&lt;/a&gt; 사용 &lt;a href=&quot;../../ref/class-based-views/mixins-single-object#django.views.generic.detail.SingleObjectTemplateResponseMixin&quot;&gt; &lt;code&gt;SingleObjectTemplateResponseMixin&lt;/code&gt; &lt;/a&gt; 연장 &lt;a href=&quot;../../ref/class-based-views/mixins-simple#django.views.generic.base.TemplateResponseMixin&quot;&gt; &lt;code&gt;TemplateResponseMixin&lt;/code&gt; 을&lt;/a&gt; 무시하고 &lt;a href=&quot;../../ref/class-based-views/mixins-simple#django.views.generic.base.TemplateResponseMixin.get_template_names&quot;&gt; &lt;code&gt;get_template_names()&lt;/code&gt; &lt;/a&gt; 상술 한 바와 같이. 실제로 상당히 정교한 옵션 세트를 제공하지만 대부분의 사람들이 사용할 주요 옵션은 &lt;code&gt;&amp;lt;app_label&amp;gt;/&amp;lt;model_name&amp;gt;_detail.html&lt;/code&gt; 입니다. &lt;code&gt;_detail&lt;/code&gt; 의 일부 설정을 변경할 수 있습니다 &lt;a href=&quot;../../ref/class-based-views/mixins-single-object#django.views.generic.detail.SingleObjectTemplateResponseMixin.template_name_suffix&quot;&gt; &lt;code&gt;template_name_suffix&lt;/code&gt; 을&lt;/a&gt; 뭔가 다른 서브 클래스에. (예를 들어, &lt;a href=&quot;generic-editing&quot;&gt;일반적인 편집 뷰를&lt;/a&gt; 사용 &lt;code&gt;_form&lt;/code&gt; 를 생성하고 업데이트 뷰 및 대한 &lt;code&gt;_confirm_delete&lt;/code&gt; 삭제 뷰.)</target>
        </trans-unit>
        <trans-unit id="72cc96024c139aa3446414d9d4f0d1e7e10c43a7" translate="yes" xml:space="preserve">
          <source>To track the user that created an object using a &lt;a href=&quot;https://docs.djangoproject.com/en/3.0/ref/class-based-views/flattened-index/#CreateView&quot;&gt;&lt;code&gt;CreateView&lt;/code&gt;&lt;/a&gt;, you can use a custom &lt;a href=&quot;../forms/modelforms#django.forms.ModelForm&quot;&gt;&lt;code&gt;ModelForm&lt;/code&gt;&lt;/a&gt; to do this. First, add the foreign key relation to the model:</source>
          <target state="translated">&lt;a href=&quot;https://docs.djangoproject.com/en/3.0/ref/class-based-views/flattened-index/#CreateView&quot;&gt; &lt;code&gt;CreateView&lt;/code&gt; 를&lt;/a&gt; 사용하여 객체를 만든 사용자를 추적하기 위해 사용자 지정 &lt;a href=&quot;../forms/modelforms#django.forms.ModelForm&quot;&gt; &lt;code&gt;ModelForm&lt;/code&gt; &lt;/a&gt; 을 사용하여 이를 수행 할 수 있습니다 . 먼저 모델에 외래 키 관계를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="d9a0dbb9b2381c1c12737ad70331610227f56b57" translate="yes" xml:space="preserve">
          <source>To translate a template expression &amp;ndash; say, accessing object attributes or using template filters &amp;ndash; you need to bind the expression to a local variable for use within the translation block. Examples:</source>
          <target state="translated">개체 속성에 액세스하거나 템플릿 필터를 사용하여 템플릿 식을 변환하려면 변환 블록 내에서 사용하기 위해 식을 로컬 변수에 바인딩해야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="5d84f55ae73d5309c0886031a6fc9c4fb841b8a4" translate="yes" xml:space="preserve">
          <source>To understand this problem, consider what happens with the database backend. When a user logs in, Django adds a row to the &lt;code&gt;django_session&lt;/code&gt; database table. Django updates this row each time the session data changes. If the user logs out manually, Django deletes the row. But if the user does &lt;em&gt;not&lt;/em&gt; log out, the row never gets deleted. A similar process happens with the file backend.</source>
          <target state="translated">이 문제점을 이해하려면 데이터베이스 백엔드에서 발생하는 상황을 고려하십시오. 사용자가 로그인하면 Django는 &lt;code&gt;django_session&lt;/code&gt; 데이터베이스 테이블에 행을 추가 합니다. Django는 세션 데이터가 변경 될 때마다이 행을 업데이트합니다. 사용자가 수동으로 로그 아웃하면 Django가 행을 삭제합니다. 그러나 사용자가 로그 아웃 하지 &lt;em&gt;않으면&lt;/em&gt; 행이 삭제되지 않습니다. 파일 백엔드에서도 비슷한 프로세스가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="01fb6801a51266c120e1fd851448afaa792241c5" translate="yes" xml:space="preserve">
          <source>To uninstall the package, use pip:</source>
          <target state="translated">패키지를 제거하려면 pip를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9f2ea180efbb7c1d90bd7f94be6c160c63d0fa55" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;LocaleMiddleware&lt;/code&gt;, add &lt;code&gt;'django.middleware.locale.LocaleMiddleware'&lt;/code&gt; to your &lt;a href=&quot;../../ref/settings#std:setting-MIDDLEWARE&quot;&gt;&lt;code&gt;MIDDLEWARE&lt;/code&gt;&lt;/a&gt; setting. Because middleware order matters, follow these guidelines:</source>
          <target state="translated">&lt;code&gt;LocaleMiddleware&lt;/code&gt; 를 사용하려면 &lt;a href=&quot;../../ref/settings#std:setting-MIDDLEWARE&quot;&gt; &lt;code&gt;MIDDLEWARE&lt;/code&gt; &lt;/a&gt; 설정에 &lt;code&gt;'django.middleware.locale.LocaleMiddleware'&lt;/code&gt; 를 추가 하십시오 . 미들웨어 주문이 중요하므로 다음 지침을 따르십시오.</target>
        </trans-unit>
        <trans-unit id="baa822ac6eb7ab08744a7c59adc145245cdb2844" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;citext&lt;/code&gt;, use the &lt;a href=&quot;operations#django.contrib.postgres.operations.CITextExtension&quot;&gt;&lt;code&gt;CITextExtension&lt;/code&gt;&lt;/a&gt; operation to &lt;a href=&quot;operations#create-postgresql-extensions&quot;&gt;setup the citext extension&lt;/a&gt; in PostgreSQL before the first &lt;code&gt;CreateModel&lt;/code&gt; migration operation.</source>
          <target state="translated">&lt;code&gt;citext&lt;/code&gt; 를 사용하려면 첫 번째 &lt;code&gt;CreateModel&lt;/code&gt; 마이그레이션 작업 전에 &lt;a href=&quot;operations#django.contrib.postgres.operations.CITextExtension&quot;&gt; &lt;code&gt;CITextExtension&lt;/code&gt; &lt;/a&gt; 작업을 사용하여 PostgreSQL &lt;a href=&quot;operations#create-postgresql-extensions&quot;&gt;에서 citext 확장&lt;/a&gt; 을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="b4a817c822b891a6eec6a2ca8ffe782ad2950c7b" translate="yes" xml:space="preserve">
          <source>To use Argon2 as your default storage algorithm, do the following:</source>
          <target state="translated">Argon2를 기본 스토리지 알고리즘으로 사용하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="fada25cd715e1e85490a40a1feb799219fa46c82" translate="yes" xml:space="preserve">
          <source>To use Bcrypt as your default storage algorithm, do the following:</source>
          <target state="translated">Bcrypt를 기본 스토리지 알고리즘으로 사용하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="af251ecea63c45faaf6632213e241f6424f6e86e" translate="yes" xml:space="preserve">
          <source>To use MariaDB, use the MySQL backend, which is shared between the two. See the &lt;a href=&quot;#mysql-notes&quot;&gt;MySQL notes&lt;/a&gt; for more details.</source>
          <target state="translated">MariaDB를 사용하려면 둘 사이에 공유되는 MySQL 백엔드를 사용하십시오. 자세한 내용은 &lt;a href=&quot;#mysql-notes&quot;&gt;MySQL 노트&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4a39213a308cd1b150ad571b0ac2903ff09b8401" translate="yes" xml:space="preserve">
          <source>To use Memcached with Django:</source>
          <target state="translated">Django와 함께 Memcached를 사용하려면 :</target>
        </trans-unit>
        <trans-unit id="5c1111bfa35c7b250b7f816d393ebc5636f7a3db" translate="yes" xml:space="preserve">
          <source>To use a database table as your cache backend:</source>
          <target state="translated">데이터베이스 테이블을 캐시 백엔드로 사용하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="e4762e18b3465ef14ba41cb461ca9dc71f0af17f" translate="yes" xml:space="preserve">
          <source>To use cookies-based sessions, set the &lt;a href=&quot;../../ref/settings#std:setting-SESSION_ENGINE&quot;&gt;&lt;code&gt;SESSION_ENGINE&lt;/code&gt;&lt;/a&gt; setting to &lt;code&gt;&quot;django.contrib.sessions.backends.signed_cookies&quot;&lt;/code&gt;. The session data will be stored using Django&amp;rsquo;s tools for &lt;a href=&quot;../signing&quot;&gt;cryptographic signing&lt;/a&gt; and the &lt;a href=&quot;../../ref/settings#std:setting-SECRET_KEY&quot;&gt;&lt;code&gt;SECRET_KEY&lt;/code&gt;&lt;/a&gt; setting.</source>
          <target state="translated">쿠키 기반 세션을 사용하려면 &lt;a href=&quot;../../ref/settings#std:setting-SESSION_ENGINE&quot;&gt; &lt;code&gt;SESSION_ENGINE&lt;/code&gt; &lt;/a&gt; 설정을 &lt;code&gt;&quot;django.contrib.sessions.backends.signed_cookies&quot;&lt;/code&gt; 로 설정하십시오 . 세션 데이터는 Django의 &lt;a href=&quot;../signing&quot;&gt;암호화 서명&lt;/a&gt; 도구 및 &lt;a href=&quot;../../ref/settings#std:setting-SECRET_KEY&quot;&gt; &lt;code&gt;SECRET_KEY&lt;/code&gt; &lt;/a&gt; 설정 을 사용하여 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="57ad92bf4a1b1756b263032d92cc436040b71cbb" translate="yes" xml:space="preserve">
          <source>To use custom formats, specify the path where you&amp;rsquo;ll place format files first. To do that, set your &lt;a href=&quot;../../ref/settings#std:setting-FORMAT_MODULE_PATH&quot;&gt;&lt;code&gt;FORMAT_MODULE_PATH&lt;/code&gt;&lt;/a&gt; setting to the package where format files will exist, for instance:</source>
          <target state="translated">사용자 정의 형식을 사용하려면 먼저 형식 파일을 배치 할 경로를 지정하십시오. 이렇게하려면 &lt;a href=&quot;../../ref/settings#std:setting-FORMAT_MODULE_PATH&quot;&gt; &lt;code&gt;FORMAT_MODULE_PATH&lt;/code&gt; &lt;/a&gt; 설정을 형식 파일이 존재하는 패키지로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc792a21102589f91f33c563bc400eb85b75cbbc" translate="yes" xml:space="preserve">
          <source>To use file-based sessions, set the &lt;a href=&quot;../../ref/settings#std:setting-SESSION_ENGINE&quot;&gt;&lt;code&gt;SESSION_ENGINE&lt;/code&gt;&lt;/a&gt; setting to &lt;code&gt;&quot;django.contrib.sessions.backends.file&quot;&lt;/code&gt;.</source>
          <target state="translated">파일 기반 세션을 사용하려면 &lt;a href=&quot;../../ref/settings#std:setting-SESSION_ENGINE&quot;&gt; &lt;code&gt;SESSION_ENGINE&lt;/code&gt; &lt;/a&gt; 설정을 &lt;code&gt;&quot;django.contrib.sessions.backends.file&quot;&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c3598f751aa1cf1a9812b1defcdcca93242d049" translate="yes" xml:space="preserve">
          <source>To use it, add &lt;code&gt;'django.contrib.postgres'&lt;/code&gt; in your &lt;a href=&quot;../../settings#std:setting-INSTALLED_APPS&quot;&gt;&lt;code&gt;INSTALLED_APPS&lt;/code&gt;&lt;/a&gt; and activate the &lt;a href=&quot;https://www.postgresql.org/docs/current/pgtrgm.html&quot;&gt;pg_trgm extension&lt;/a&gt; on PostgreSQL. You can install the extension using the &lt;a href=&quot;operations#django.contrib.postgres.operations.TrigramExtension&quot;&gt;&lt;code&gt;TrigramExtension&lt;/code&gt;&lt;/a&gt; migration operation.</source>
          <target state="translated">사용하려면 &lt;a href=&quot;../../settings#std:setting-INSTALLED_APPS&quot;&gt; &lt;code&gt;INSTALLED_APPS&lt;/code&gt; &lt;/a&gt; 에 &lt;code&gt;'django.contrib.postgres'&lt;/code&gt; 를 &lt;a href=&quot;https://www.postgresql.org/docs/current/pgtrgm.html&quot;&gt;추가&lt;/a&gt; 하고 PostgreSQL 에서 pg_trgm 확장자 를 활성화하십시오 . &lt;a href=&quot;operations#django.contrib.postgres.operations.TrigramExtension&quot;&gt; &lt;code&gt;TrigramExtension&lt;/code&gt; &lt;/a&gt; 마이그레이션 작업을 사용하여 확장을 설치할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="76e67951aa69302b851ac2530c37f2eadd7ce54f" translate="yes" xml:space="preserve">
          <source>To use the &lt;code&gt;Variable&lt;/code&gt; class, instantiate it with the name of the variable to be resolved, and then call &lt;code&gt;variable.resolve(context)&lt;/code&gt;. So, for example:</source>
          <target state="translated">&lt;code&gt;Variable&lt;/code&gt; 클래스 를 사용하려면 분석 할 변수 이름으로 인스턴스화 한 다음 &lt;code&gt;variable.resolve(context)&lt;/code&gt; 를 호출 하십시오 . 예를 들어,</target>
        </trans-unit>
        <trans-unit id="16225e0c3805ac91771d395de942941ab404ce4b" translate="yes" xml:space="preserve">
          <source>To use the &lt;code&gt;search&lt;/code&gt; lookup, &lt;code&gt;'django.contrib.postgres'&lt;/code&gt; must be in your &lt;a href=&quot;../../settings#std:setting-INSTALLED_APPS&quot;&gt;&lt;code&gt;INSTALLED_APPS&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;search&lt;/code&gt; 조회 를 사용하려면 &lt;code&gt;'django.contrib.postgres'&lt;/code&gt; 가 &lt;a href=&quot;../../settings#std:setting-INSTALLED_APPS&quot;&gt; &lt;code&gt;INSTALLED_APPS&lt;/code&gt; 에&lt;/a&gt; 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="786844c1792217b772b28f4949010de85d216ec5" translate="yes" xml:space="preserve">
          <source>To use the catalog, pull in the dynamically generated script like this:</source>
          <target state="translated">카탈로그를 사용하려면 다음과 같이 동적으로 생성 된 스크립트를 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="5393b4ea06e16dbcbbda086da37dfeb9ba70e9a7" translate="yes" xml:space="preserve">
          <source>To use the test client, instantiate &lt;code&gt;django.test.Client&lt;/code&gt; and retrieve Web pages:</source>
          <target state="translated">테스트 클라이언트를 사용하려면 &lt;code&gt;django.test.Client&lt;/code&gt; 를 인스턴스화 하고 웹 페이지를 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="09f68d7c531da74bc4907fe9c6caef905b249f55" translate="yes" xml:space="preserve">
          <source>To use them, you need to activate the &lt;a href=&quot;https://www.postgresql.org/docs/current/pgtrgm.html&quot;&gt;pg_trgm extension&lt;/a&gt; on PostgreSQL. You can install it using the &lt;a href=&quot;operations#django.contrib.postgres.operations.TrigramExtension&quot;&gt;&lt;code&gt;TrigramExtension&lt;/code&gt;&lt;/a&gt; migration operation.</source>
          <target state="translated">그것들을 사용하려면 PostgreSQL 에서 &lt;a href=&quot;https://www.postgresql.org/docs/current/pgtrgm.html&quot;&gt;pg_trgm 확장자&lt;/a&gt; 를 활성화해야합니다 . &lt;a href=&quot;operations#django.contrib.postgres.operations.TrigramExtension&quot;&gt; &lt;code&gt;TrigramExtension&lt;/code&gt; &lt;/a&gt; 마이그레이션 작업을 사용하여 설치할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="640e66bbf1a609338fa745697e84216c358fceb5" translate="yes" xml:space="preserve">
          <source>To use this backend, all the widgets in your project and its third-party apps must have Jinja2 templates. Unless you provide your own Jinja2 templates for widgets that don&amp;rsquo;t have any, you can&amp;rsquo;t use this renderer. For example, &lt;a href=&quot;../contrib/admin/index#module-django.contrib.admin&quot;&gt;&lt;code&gt;django.contrib.admin&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t include Jinja2 templates for its widgets due to their usage of Django template tags.</source>
          <target state="translated">이 백엔드를 사용하려면 프로젝트 및 타사 앱의 모든 위젯에 Jinja2 템플릿이 있어야합니다. 위젯이없는 고유 한 Jinja2 템플릿을 제공하지 않으면이 렌더러를 사용할 수 없습니다. 예를 들어 &lt;a href=&quot;../contrib/admin/index#module-django.contrib.admin&quot;&gt; &lt;code&gt;django.contrib.admin&lt;/code&gt; &lt;/a&gt; 에는 Django 템플릿 태그 사용으로 인해 위젯에 Jinja2 템플릿이 포함되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="48a55f22ed3d2ec1661da41a78b752a33c32e845" translate="yes" xml:space="preserve">
          <source>To use this field, you&amp;rsquo;ll need to:</source>
          <target state="translated">이 필드를 사용하려면 다음이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1d9714f7290bd8633ec611abd6d6d94e0fbde753" translate="yes" xml:space="preserve">
          <source>To use this index on data types not in the &lt;a href=&quot;https://www.postgresql.org/docs/current/gin-builtin-opclasses.html&quot;&gt;built-in operator classes&lt;/a&gt;, you need to activate the &lt;a href=&quot;https://www.postgresql.org/docs/current/btree-gin.html&quot;&gt;btree_gin extension&lt;/a&gt; on PostgreSQL. You can install it using the &lt;a href=&quot;operations#django.contrib.postgres.operations.BtreeGinExtension&quot;&gt;&lt;code&gt;BtreeGinExtension&lt;/code&gt;&lt;/a&gt; migration operation.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/current/gin-builtin-opclasses.html&quot;&gt;내장 연산자 클래스에&lt;/a&gt; 없는 데이터 형식에이 인덱스를 사용하려면 PostgreSQL 에서 &lt;a href=&quot;https://www.postgresql.org/docs/current/btree-gin.html&quot;&gt;btree_gin 확장&lt;/a&gt; 을 활성화해야합니다 . &lt;a href=&quot;operations#django.contrib.postgres.operations.BtreeGinExtension&quot;&gt; &lt;code&gt;BtreeGinExtension&lt;/code&gt; &lt;/a&gt; 마이그레이션 작업을 사용하여 설치할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dab0dc60f215f42387b6ddb6526b18ece09b9c92" translate="yes" xml:space="preserve">
          <source>To use this index on data types not in the built-in &lt;a href=&quot;https://www.postgresql.org/docs/current/gist-builtin-opclasses.html&quot;&gt;gist operator classes&lt;/a&gt;, you need to activate the &lt;a href=&quot;https://www.postgresql.org/docs/current/btree-gist.html&quot;&gt;btree_gist extension&lt;/a&gt; on PostgreSQL. You can install it using the &lt;a href=&quot;operations#django.contrib.postgres.operations.BtreeGistExtension&quot;&gt;&lt;code&gt;BtreeGistExtension&lt;/code&gt;&lt;/a&gt; migration operation.</source>
          <target state="translated">내장 된 &lt;a href=&quot;https://www.postgresql.org/docs/current/gist-builtin-opclasses.html&quot;&gt;gist 연산자 클래스&lt;/a&gt; 에없는 데이터 유형에이 인덱스를 사용하려면 PostgreSQL 에서 &lt;a href=&quot;https://www.postgresql.org/docs/current/btree-gist.html&quot;&gt;btree_gist 확장&lt;/a&gt; 을 활성화해야합니다 . &lt;a href=&quot;operations#django.contrib.postgres.operations.BtreeGistExtension&quot;&gt; &lt;code&gt;BtreeGistExtension&lt;/code&gt; &lt;/a&gt; 마이그레이션 작업을 사용하여 설치할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd50380a411af4c8c98fdf32a3c5b864f6df4d20" translate="yes" xml:space="preserve">
          <source>To use this, you would create a logger object and install it as a wrapper:</source>
          <target state="translated">이를 사용하려면 로거 오브젝트를 작성하고 랩퍼로 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="fe7701cad8e60311cb68fbb23dda09cef817284d" translate="yes" xml:space="preserve">
          <source>To verify that Django can be seen by Python, type &lt;code&gt;python&lt;/code&gt; from your shell. Then at the Python prompt, try to import Django:</source>
          <target state="translated">&lt;code&gt;python&lt;/code&gt; 에서 장고를 볼 수 있는지 확인하려면 쉘에서 python 을 입력 하십시오. 그런 다음 Python 프롬프트에서 Django를 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="a61f393918d4cd43d564e78e7460e64593570e27" translate="yes" xml:space="preserve">
          <source>To work around this dilemma, instead override &lt;a href=&quot;#django.db.models.Model.clean_fields&quot;&gt;&lt;code&gt;Model.clean_fields()&lt;/code&gt;&lt;/a&gt; as it receives the list of fields that are excluded from validation. For example:</source>
          <target state="translated">이 딜레마를 해결하려면 유효성 검증에서 제외 된 필드 목록을 수신 할 때 &lt;a href=&quot;#django.db.models.Model.clean_fields&quot;&gt; &lt;code&gt;Model.clean_fields()&lt;/code&gt; &lt;/a&gt; 를 대체 하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dfca1814eef53ed8ffbff4bb996fff9c6dd827b5" translate="yes" xml:space="preserve">
          <source>To work around this problem, every time you save a form using &lt;code&gt;commit=False&lt;/code&gt;, Django adds a &lt;code&gt;save_m2m()&lt;/code&gt; method to your &lt;code&gt;ModelForm&lt;/code&gt; subclass. After you&amp;rsquo;ve manually saved the instance produced by the form, you can invoke &lt;code&gt;save_m2m()&lt;/code&gt; to save the many-to-many form data. For example:</source>
          <target state="translated">이 문제를 해결하기 위해 &lt;code&gt;commit=False&lt;/code&gt; 를 사용하여 양식을 저장할 때마다 Django는 &lt;code&gt;save_m2m()&lt;/code&gt; 메소드를 &lt;code&gt;ModelForm&lt;/code&gt; 서브 클래스에 추가합니다. 양식에서 생성 된 인스턴스를 수동으로 저장 한 후 &lt;code&gt;save_m2m()&lt;/code&gt; 을 호출 하여 다 대다 양식 데이터를 저장할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f54d061f17765b43748bfa5d08851a656c84aedd" translate="yes" xml:space="preserve">
          <source>To work around this problem, when you are using &lt;a href=&quot;../../ref/models/fields#django.db.models.ForeignKey.related_name&quot;&gt;&lt;code&gt;related_name&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../ref/models/fields#django.db.models.ForeignKey.related_query_name&quot;&gt;&lt;code&gt;related_query_name&lt;/code&gt;&lt;/a&gt; in an abstract base class (only), part of the value should contain &lt;code&gt;'%(app_label)s'&lt;/code&gt; and &lt;code&gt;'%(class)s'&lt;/code&gt;.</source>
          <target state="translated">이 문제를 해결하려면 추상 기본 클래스 ( &lt;a href=&quot;../../ref/models/fields#django.db.models.ForeignKey.related_query_name&quot;&gt; &lt;code&gt;related_query_name&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;../../ref/models/fields#django.db.models.ForeignKey.related_name&quot;&gt; &lt;code&gt;related_name&lt;/code&gt; &lt;/a&gt; 또는 related_query_name 을 사용하는 경우 값의 일부에 &lt;code&gt;'%(app_label)s'&lt;/code&gt; 및 &lt;code&gt;'%(class)s'&lt;/code&gt; 가 포함되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="500332f734dd1119d7d26f256ec045e809390595" translate="yes" xml:space="preserve">
          <source>To work around this problem, you can use the &lt;a href=&quot;templates/builtins#std:templatetag-templatetag&quot;&gt;&lt;code&gt;templatetag&lt;/code&gt;&lt;/a&gt; template tag to &amp;ldquo;escape&amp;rdquo; the various parts of the template syntax.</source>
          <target state="translated">이 문제를 해결하려면 &lt;a href=&quot;templates/builtins#std:templatetag-templatetag&quot;&gt; &lt;code&gt;templatetag&lt;/code&gt; &lt;/a&gt; template 태그를 사용 하여 템플릿 구문의 다양한 부분을 &quot;이스케이프&quot; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3cb52a774dadf47c7ba70ca3205a5d7e985c67ce" translate="yes" xml:space="preserve">
          <source>To workaround this, you can escape percent signs by adding a second percent sign:</source>
          <target state="translated">이 문제를 해결하려면 두 번째 퍼센트 부호를 추가하여 퍼센트 부호를 이스케이프 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e45626d90d731c836542c1bd42bf5a00f5639adb" translate="yes" xml:space="preserve">
          <source>To write your own storage class, subclass the &lt;code&gt;BaseStorage&lt;/code&gt; class in &lt;code&gt;django.contrib.messages.storage.base&lt;/code&gt; and implement the &lt;code&gt;_get&lt;/code&gt; and &lt;code&gt;_store&lt;/code&gt; methods.</source>
          <target state="translated">고유 한 스토리지 클래스를 작성하려면 &lt;code&gt;django.contrib.messages.storage.base&lt;/code&gt; 에서 &lt;code&gt;BaseStorage&lt;/code&gt; 클래스를 서브 클래스 화 하고 &lt;code&gt;_get&lt;/code&gt; 및 &lt;code&gt;_store&lt;/code&gt; 메소드를 구현하십시오 .</target>
        </trans-unit>
        <trans-unit id="3eb154850e5f24fbe26b0076feb792ca9d0428ea" translate="yes" xml:space="preserve">
          <source>Together &lt;a href=&quot;../../ref/files/uploads#django.core.files.uploadhandler.MemoryFileUploadHandler&quot;&gt;&lt;code&gt;MemoryFileUploadHandler&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../ref/files/uploads#django.core.files.uploadhandler.TemporaryFileUploadHandler&quot;&gt;&lt;code&gt;TemporaryFileUploadHandler&lt;/code&gt;&lt;/a&gt; provide Django&amp;rsquo;s default file upload behavior of reading small files into memory and large ones onto disk.</source>
          <target state="translated">함께 &lt;a href=&quot;../../ref/files/uploads#django.core.files.uploadhandler.MemoryFileUploadHandler&quot;&gt; &lt;code&gt;MemoryFileUploadHandler&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../ref/files/uploads#django.core.files.uploadhandler.TemporaryFileUploadHandler&quot;&gt; &lt;code&gt;TemporaryFileUploadHandler&lt;/code&gt; 는&lt;/a&gt; 디스크에 메모리와 큰 것들로 작은 파일을 읽는 장고의 기본 파일 업로드 동작을 제공한다.</target>
        </trans-unit>
        <trans-unit id="f1a338854ec6d8a43e661b17b8393a82f00e0c2c" translate="yes" xml:space="preserve">
          <source>Together the &lt;a href=&quot;#django.core.files.uploadhandler.MemoryFileUploadHandler&quot;&gt;&lt;code&gt;MemoryFileUploadHandler&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#django.core.files.uploadhandler.TemporaryFileUploadHandler&quot;&gt;&lt;code&gt;TemporaryFileUploadHandler&lt;/code&gt;&lt;/a&gt; provide Django&amp;rsquo;s default file upload behavior of reading small files into memory and large ones onto disk. They are located in &lt;code&gt;django.core.files.uploadhandler&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#django.core.files.uploadhandler.MemoryFileUploadHandler&quot;&gt; &lt;code&gt;MemoryFileUploadHandler&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#django.core.files.uploadhandler.TemporaryFileUploadHandler&quot;&gt; &lt;code&gt;TemporaryFileUploadHandler&lt;/code&gt; &lt;/a&gt; 는 함께 작은 파일을 메모리로, 큰 파일을 디스크로 읽는 Django의 기본 파일 업로드 동작을 제공합니다. 그것들은 &lt;code&gt;django.core.files.uploadhandler&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6d6e131878a5bd30a31f8e4582caac3d2c3accd" translate="yes" xml:space="preserve">
          <source>Together, &lt;a href=&quot;#django.contrib.contenttypes.models.ContentType.get_object_for_this_type&quot;&gt;&lt;code&gt;get_object_for_this_type()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#django.contrib.contenttypes.models.ContentType.model_class&quot;&gt;&lt;code&gt;model_class()&lt;/code&gt;&lt;/a&gt; enable two extremely important use cases:</source>
          <target state="translated">함께 &lt;a href=&quot;#django.contrib.contenttypes.models.ContentType.get_object_for_this_type&quot;&gt; &lt;code&gt;get_object_for_this_type()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#django.contrib.contenttypes.models.ContentType.model_class&quot;&gt; &lt;code&gt;model_class()&lt;/code&gt; &lt;/a&gt; 이 매우 중요한 사용 사례를 수 :</target>
        </trans-unit>
        <trans-unit id="4ee207b35334a52677a67ccab83eadf325462a1a" translate="yes" xml:space="preserve">
          <source>Tokyo: 33,000,000</source>
          <target state="translated">도쿄 : 33,000,000</target>
        </trans-unit>
        <trans-unit id="dfad6d73838f0a49a5fe3bbb30a238a65c4c6edb" translate="yes" xml:space="preserve">
          <source>Topological Methods</source>
          <target state="translated">토폴로지 방법</target>
        </trans-unit>
        <trans-unit id="a6a81ba3353da570809d4488bccd637293cb0c17" translate="yes" xml:space="preserve">
          <source>Topological Properties</source>
          <target state="translated">토폴로지 속성</target>
        </trans-unit>
        <trans-unit id="7b45bb8b1ad15e339bd29770f6402c7a7b3b58e0" translate="yes" xml:space="preserve">
          <source>Tracking Django development</source>
          <target state="translated">장고 개발 추적</target>
        </trans-unit>
        <trans-unit id="da9f9720dca134f79b23a5d42b97649bef0a1f32" translate="yes" xml:space="preserve">
          <source>Transaction Exceptions</source>
          <target state="translated">거래 예외</target>
        </trans-unit>
        <trans-unit id="6ac0699883f8dfb3412349bc07d7d39cdc96f27b" translate="yes" xml:space="preserve">
          <source>Transaction exceptions are defined in &lt;code&gt;django.db.transaction&lt;/code&gt;.</source>
          <target state="translated">트랜잭션 예외는 &lt;code&gt;django.db.transaction&lt;/code&gt; 에 정의되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="731b827a84b0918b5448942cbc15befc9f1ae8fa" translate="yes" xml:space="preserve">
          <source>Transaction pooling and server-side cursors</source>
          <target state="translated">트랜잭션 풀링 및 서버 측 커서</target>
        </trans-unit>
        <trans-unit id="f7c629e41a1c0684584cfed2bccfc91dcf67c23d" translate="yes" xml:space="preserve">
          <source>Transaction rollback</source>
          <target state="translated">트랜잭션 롤백</target>
        </trans-unit>
        <trans-unit id="1e3281a962e6db2e54e787f796eb7d2b1582389a" translate="yes" xml:space="preserve">
          <source>Transactions</source>
          <target state="translated">Transactions</target>
        </trans-unit>
        <trans-unit id="aa4f704b486664ba27eb98cadaf8b60a50cfb5bb" translate="yes" xml:space="preserve">
          <source>Transactions in MySQL</source>
          <target state="translated">MySQL의 트랜잭션</target>
        </trans-unit>
        <trans-unit id="7f7820e1a6968d5e9b37e35722072ab464c02ea9" translate="yes" xml:space="preserve">
          <source>Transformation of values between the database and the model, validation of data and configuration, and serialization are all delegated to the underlying base field.</source>
          <target state="translated">데이터베이스와 모델 간의 값 변환, 데이터 및 구성의 유효성 검증 및 직렬화는 모두 기본 기반 필드에 위임됩니다.</target>
        </trans-unit>
        <trans-unit id="ac7069f5c930308780379e83ebe458de1ad8150b" translate="yes" xml:space="preserve">
          <source>Transforms part (may be omitted) (e.g. &lt;code&gt;__lower__first3chars__reversed&lt;/code&gt;);</source>
          <target state="translated">변환 부분 (생략 가능) (예 : &lt;code&gt;__lower__first3chars__reversed&lt;/code&gt; );</target>
        </trans-unit>
        <trans-unit id="0cca7130d0ec8592171956a9cb15889d86a250e7" translate="yes" xml:space="preserve">
          <source>Transforms the geometry according to the given coordinate transformation parameter (&lt;code&gt;ct&lt;/code&gt;), which may be an integer SRID, spatial reference WKT string, a PROJ.4 string, a &lt;a href=&quot;gdal#django.contrib.gis.gdal.SpatialReference&quot;&gt;&lt;code&gt;SpatialReference&lt;/code&gt;&lt;/a&gt; object, or a &lt;a href=&quot;gdal#django.contrib.gis.gdal.CoordTransform&quot;&gt;&lt;code&gt;CoordTransform&lt;/code&gt;&lt;/a&gt; object. By default, the geometry is transformed in-place and nothing is returned. However if the &lt;code&gt;clone&lt;/code&gt; keyword is set, then the geometry is not modified and a transformed clone of the geometry is returned instead.</source>
          <target state="translated">주어진 변환 좌표 변환 파라미터 (형상에 따른 &lt;code&gt;ct&lt;/code&gt; 정수 SRID, 공간 참조 WKT 문자열하는 PROJ.4 문자열하는 일 수도 있음), &lt;a href=&quot;gdal#django.contrib.gis.gdal.SpatialReference&quot;&gt; &lt;code&gt;SpatialReference&lt;/code&gt; 의&lt;/a&gt; 개체 또는 &lt;a href=&quot;gdal#django.contrib.gis.gdal.CoordTransform&quot;&gt; &lt;code&gt;CoordTransform&lt;/code&gt; 의&lt;/a&gt; 개체. 기본적으로 지오메트리는 제자리에서 변형되며 아무것도 반환되지 않습니다. 그러나 &lt;code&gt;clone&lt;/code&gt; 키워드를 설정하면 지오메트리가 수정되지 않고 대신 지오메트리의 변환 된 클론이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5442acbd9a445d59215510347be70da5e4fa7554" translate="yes" xml:space="preserve">
          <source>Transforms this geometry to a different spatial reference system. May take a &lt;a href=&quot;#django.contrib.gis.gdal.CoordTransform&quot;&gt;&lt;code&gt;CoordTransform&lt;/code&gt;&lt;/a&gt; object, a &lt;a href=&quot;#django.contrib.gis.gdal.SpatialReference&quot;&gt;&lt;code&gt;SpatialReference&lt;/code&gt;&lt;/a&gt; object, or any other input accepted by &lt;a href=&quot;#django.contrib.gis.gdal.SpatialReference&quot;&gt;&lt;code&gt;SpatialReference&lt;/code&gt;&lt;/a&gt; (including spatial reference WKT and PROJ.4 strings, or an integer SRID).</source>
          <target state="translated">이 지오메트리를 다른 공간 참조 시스템으로 변환합니다. 테이크있다 &lt;a href=&quot;#django.contrib.gis.gdal.CoordTransform&quot;&gt; &lt;code&gt;CoordTransform&lt;/code&gt; 의&lt;/a&gt; 목적하는 &lt;a href=&quot;#django.contrib.gis.gdal.SpatialReference&quot;&gt; &lt;code&gt;SpatialReference&lt;/code&gt; 의&lt;/a&gt; 개체 또는 수락 다른 입력 &lt;a href=&quot;#django.contrib.gis.gdal.SpatialReference&quot;&gt; &lt;code&gt;SpatialReference&lt;/code&gt; &lt;/a&gt; (공간 참조 WKT 및 PROJ.4 문자열 또는 정수를 포함 SRID).</target>
        </trans-unit>
        <trans-unit id="9e78768739633ded86c85aeae29d1f3294b180fb" translate="yes" xml:space="preserve">
          <source>Translated strings</source>
          <target state="translated">번역 된 문자열</target>
        </trans-unit>
        <trans-unit id="4e03d50351116684ec2bd004c93f60ece81bcabe" translate="yes" xml:space="preserve">
          <source>Translated strings will not be escaped when rendered in a template. This allows you to include HTML in translations, for example for emphasis, but potentially dangerous characters (e.g. &lt;code&gt;&quot;&lt;/code&gt;) will also be rendered unchanged.</source>
          <target state="translated">템플릿으로 렌더링 할 때 번역 된 문자열은 이스케이프되지 않습니다. 이를 통해 강조와 같이 HTML을 번역에 포함 할 수 있지만 잠재적으로 위험한 문자 (예 : &lt;code&gt;&quot;&lt;/code&gt; )도 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82cdabaa2b7684f81ac8a7b2619639ecb5f8af56" translate="yes" xml:space="preserve">
          <source>Translates &lt;code&gt;message&lt;/code&gt; and returns it as a string.</source>
          <target state="translated">&lt;code&gt;message&lt;/code&gt; 번역 하여 문자열로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9045667fb6fd07d7870e3361b2bd77d0cac15852" translate="yes" xml:space="preserve">
          <source>Translates &lt;code&gt;message&lt;/code&gt; given the &lt;code&gt;context&lt;/code&gt; and returns it as a string.</source>
          <target state="translated">주어진 &lt;code&gt;context&lt;/code&gt; &lt;code&gt;message&lt;/code&gt; 번역 하고 문자열로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1740660b5857dd65b64b54536e1d4a4715e5f16a" translate="yes" xml:space="preserve">
          <source>Translates &lt;code&gt;singular&lt;/code&gt; and &lt;code&gt;plural&lt;/code&gt; and returns the appropriate string based on &lt;code&gt;number&lt;/code&gt; and the &lt;code&gt;context&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;singular&lt;/code&gt; 및 &lt;code&gt;plural&lt;/code&gt; 변환 하고 &lt;code&gt;number&lt;/code&gt; 와 &lt;code&gt;context&lt;/code&gt; 에 따라 적절한 문자열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="88a75c8469945b3f184f005d741c5cc7b359814c" translate="yes" xml:space="preserve">
          <source>Translates &lt;code&gt;singular&lt;/code&gt; and &lt;code&gt;plural&lt;/code&gt; and returns the appropriate string based on &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;singular&lt;/code&gt; 및 &lt;code&gt;plural&lt;/code&gt; 변환 하고 &lt;code&gt;number&lt;/code&gt; 에 따라 적절한 문자열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5073b9b31929f3a1c9175fe141e1f87878972664" translate="yes" xml:space="preserve">
          <source>Translating URL patterns</source>
          <target state="translated">URL 패턴 번역</target>
        </trans-unit>
        <trans-unit id="ac26a7a94ea2e66490f932b6415a09ef6f2a913c" translate="yes" xml:space="preserve">
          <source>Translation</source>
          <target state="translated">Translation</target>
        </trans-unit>
        <trans-unit id="f4ea577eaf6053e35930b0b3629eb9d2527e96f2" translate="yes" xml:space="preserve">
          <source>Translation and formatting are controlled by &lt;a href=&quot;../../ref/settings#std:setting-USE_I18N&quot;&gt;&lt;code&gt;USE_I18N&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../ref/settings#std:setting-USE_L10N&quot;&gt;&lt;code&gt;USE_L10N&lt;/code&gt;&lt;/a&gt; settings respectively. However, both features involve internationalization and localization. The names of the settings are an unfortunate result of Django&amp;rsquo;s history.</source>
          <target state="translated">번역 및 서식은 각각 &lt;a href=&quot;../../ref/settings#std:setting-USE_I18N&quot;&gt; &lt;code&gt;USE_I18N&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../ref/settings#std:setting-USE_L10N&quot;&gt; &lt;code&gt;USE_L10N&lt;/code&gt; &lt;/a&gt; 설정에 의해 제어됩니다 . 그러나 두 기능 모두 국제화 및 현지화와 관련이 있습니다. 설정 이름은 Django의 역사에서 불행한 결과입니다.</target>
        </trans-unit>
        <trans-unit id="bc6c34ba83563ba95a2cc42e2a9ce0d774d4f732" translate="yes" xml:space="preserve">
          <source>Translation depends on the target language, and formatting usually depends on the target country. This information is provided by browsers in the &lt;code&gt;Accept-Language&lt;/code&gt; header. However, the time zone isn&amp;rsquo;t readily available.</source>
          <target state="translated">번역은 대상 언어에 따라 다르며 형식은 일반적으로 대상 국가에 따라 다릅니다. 이 정보는 브라우저가 &lt;code&gt;Accept-Language&lt;/code&gt; 헤더에 제공합니다. 그러나 시간대를 쉽게 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c47ad4235ffdc277c83dd34d65bc526c0b3c7b4c" translate="yes" xml:space="preserve">
          <source>Translation domain containing strings to add in the view output. Defaults to &lt;code&gt;'djangojs'&lt;/code&gt;.</source>
          <target state="translated">보기 출력에 추가 할 문자열을 포함하는 변환 도메인. 기본값은 &lt;code&gt;'djangojs'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f2b7a83ad8c411a7ac09d98466b1c678be34b398" translate="yes" xml:space="preserve">
          <source>Translation works on computed values. This example is identical to the previous two:</source>
          <target state="translated">변환은 계산 된 값에서 작동합니다. 이 예는 이전 두 가지와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4c947517be7a1e4ea71922d743363f5cf53b76a9" translate="yes" xml:space="preserve">
          <source>Translation works on variables. Again, here&amp;rsquo;s an identical example:</source>
          <target state="translated">번역은 변수에서 작동합니다. 다시, 동일한 예가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="783abfdf979297410cf00a9ab66bb6e7426cdd96" translate="yes" xml:space="preserve">
          <source>Translations in &lt;a href=&quot;../../ref/templates/language&quot;&gt;Django templates&lt;/a&gt; uses two template tags and a slightly different syntax than in Python code. To give your template access to these tags, put &lt;code&gt;{% load i18n %}&lt;/code&gt; toward the top of your template. As with all template tags, this tag needs to be loaded in all templates which use translations, even those templates that extend from other templates which have already loaded the &lt;code&gt;i18n&lt;/code&gt; tag.</source>
          <target state="translated">&lt;a href=&quot;../../ref/templates/language&quot;&gt;Django 템플릿의&lt;/a&gt; 번역 은 두 개의 템플릿 태그와 Python 코드와는 약간 다른 구문을 사용합니다. 템플릿에 이러한 태그에 대한 액세스 권한을 부여하려면 템플릿 상단에 &lt;code&gt;{% load i18n %}&lt;/code&gt; 를 넣으십시오. 모든 템플릿 태그와 마찬가지로이 태그는 번역을 사용하는 모든 템플릿, &lt;code&gt;i18n&lt;/code&gt; 태그를 이미로드 한 다른 템플릿에서 확장 된 템플릿까지로드해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d633f816f8674619a1a1dc50b935cf60445a6c8e" translate="yes" xml:space="preserve">
          <source>Tries to authenticate &lt;code&gt;username&lt;/code&gt; with &lt;code&gt;password&lt;/code&gt; by calling &lt;a href=&quot;#django.contrib.auth.models.User.check_password&quot;&gt;&lt;code&gt;User.check_password&lt;/code&gt;&lt;/a&gt;. If no &lt;code&gt;username&lt;/code&gt; is provided, it tries to fetch a username from &lt;code&gt;kwargs&lt;/code&gt; using the key &lt;a href=&quot;../../topics/auth/customizing#django.contrib.auth.models.CustomUser.USERNAME_FIELD&quot;&gt;&lt;code&gt;CustomUser.USERNAME_FIELD&lt;/code&gt;&lt;/a&gt;. Returns an authenticated user or &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#django.contrib.auth.models.User.check_password&quot;&gt; &lt;code&gt;User.check_password&lt;/code&gt; &lt;/a&gt; 를 호출 하여 &lt;code&gt;password&lt;/code&gt; 로 &lt;code&gt;username&lt;/code&gt; 을 인증하려고합니다 . &lt;code&gt;username&lt;/code&gt; 이 제공 되지 않으면 &lt;a href=&quot;../../topics/auth/customizing#django.contrib.auth.models.CustomUser.USERNAME_FIELD&quot;&gt; &lt;code&gt;CustomUser.USERNAME_FIELD&lt;/code&gt; &lt;/a&gt; 키를 사용하여 &lt;code&gt;kwargs&lt;/code&gt; 에서 사용자 이름을 가져 오려고 합니다. 인증 된 사용자 또는 &lt;code&gt;None&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5e55a13baa36056519b60c3c7783089af3ebcba8" translate="yes" xml:space="preserve">
          <source>Tries to execute this command, performing system checks if needed (as controlled by the &lt;a href=&quot;#django.core.management.BaseCommand.requires_system_checks&quot;&gt;&lt;code&gt;requires_system_checks&lt;/code&gt;&lt;/a&gt; attribute). If the command raises a &lt;a href=&quot;#django.core.management.CommandError&quot;&gt;&lt;code&gt;CommandError&lt;/code&gt;&lt;/a&gt;, it&amp;rsquo;s intercepted and printed to stderr.</source>
          <target state="translated">이 명령을 실행하여 필요한 경우 시스템 검사를 수행합니다 ( &lt;a href=&quot;#django.core.management.BaseCommand.requires_system_checks&quot;&gt; &lt;code&gt;requires_system_checks&lt;/code&gt; &lt;/a&gt; 속성에 의해 제어 됨 ). 명령이 &lt;a href=&quot;#django.core.management.CommandError&quot;&gt; &lt;code&gt;CommandError&lt;/code&gt; &lt;/a&gt; 를 발생 시키면 가로 채서 stderr에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="7ea666b83a76d073ce8efb322aacd2bb0ff78ea3" translate="yes" xml:space="preserve">
          <source>Tries to remove anything that looks like an HTML tag from the string, that is anything contained within &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 안에 포함 된 문자열에서 HTML 태그처럼 보이는 것을 제거하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="d668a782670dcf4c5a80114c4524aac4ff98e9ec" translate="yes" xml:space="preserve">
          <source>Trigram similarity</source>
          <target state="translated">트라이 그램 유사성</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="5e7438331562a2f457b2132529b4ab943bed42b5" translate="yes" xml:space="preserve">
          <source>Troubleshooting: &lt;code&gt;gettext()&lt;/code&gt; incorrectly detects &lt;code&gt;python-format&lt;/code&gt; in strings with percent signs</source>
          <target state="translated">문제 해결 : &lt;code&gt;gettext()&lt;/code&gt; 가 퍼센트 기호가있는 문자열에서 &lt;code&gt;python-format&lt;/code&gt; 을 잘못 감지 합니다.</target>
        </trans-unit>
        <trans-unit id="5e21f2d7a5745961469790892ce6f150553e93d8" translate="yes" xml:space="preserve">
          <source>True if this is the first time through the loop</source>
          <target state="translated">루프를 통해 처음이라면 참</target>
        </trans-unit>
        <trans-unit id="1aa1b998942a0c8319a693bf4a7c87da0b06a08e" translate="yes" xml:space="preserve">
          <source>True if this is the last time through the loop</source>
          <target state="translated">루프를 마지막으로 통과 한 경우 true</target>
        </trans-unit>
        <trans-unit id="dd86d9bcf9b606458b609c3325381daa634757e1" translate="yes" xml:space="preserve">
          <source>True spatial indexes (R-trees) are only supported with MyISAM tables on MySQL. &lt;a href=&quot;#fnmysqlidx&quot; id=&quot;id3&quot;&gt;[4]&lt;/a&gt; In other words, when using MySQL spatial extensions you have to choose between fast spatial lookups and the integrity of your data &amp;ndash; MyISAM tables do not support transactions or foreign key constraints.</source>
          <target state="translated">실제 공간 인덱스 (R- 트리)는 MySQL의 MyISAM 테이블에서만 지원됩니다. &lt;a href=&quot;#fnmysqlidx&quot; id=&quot;id3&quot;&gt;[4]&lt;/a&gt; 즉, MySQL 공간 확장을 사용할 때는 빠른 공간 조회와 데이터 무결성 중에서 선택해야합니다. &amp;ndash; MyISAM 테이블은 트랜잭션 또는 외래 키 제약 조건을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="806c6d594fab8992021d41496eeee5d6e7a4bedf" translate="yes" xml:space="preserve">
          <source>Truncates a date up to a significant component.</source>
          <target state="translated">중요한 구성 요소까지 날짜를 자릅니다.</target>
        </trans-unit>
        <trans-unit id="d38b00a2f83e97634b57a7cf99eb5016799d9c0b" translate="yes" xml:space="preserve">
          <source>Truncates a string after a certain number of words.</source>
          <target state="translated">특정 단어 수만큼 문자열을 자릅니다.</target>
        </trans-unit>
        <trans-unit id="fa00b8e91b9d4dde4cc5dc072688fd9ba27ffdf1" translate="yes" xml:space="preserve">
          <source>Truncates a string if it is longer than the specified number of characters. Truncated strings will end with a translatable ellipsis character (&amp;ldquo;&amp;hellip;&amp;rdquo;).</source>
          <target state="translated">지정된 문자 수보다 긴 문자열을 자릅니다. 잘린 문자열은 번역 가능한 줄임표 문자 (&amp;ldquo;&amp;hellip;&amp;rdquo;)로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="c8b58467aa1abac43bff02bf205defa26c158c2b" translate="yes" xml:space="preserve">
          <source>Truncates to midnight on the Monday of the week.</source>
          <target state="translated">월요일 월요일 자정까지 잘립니다.</target>
        </trans-unit>
        <trans-unit id="4bb0c0d7b2719dd08a282d13a8fbac631466b8b1" translate="yes" xml:space="preserve">
          <source>Try &lt;code&gt;ogrinspect&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ogrinspect&lt;/code&gt; 를 시도 하십시오</target>
        </trans-unit>
        <trans-unit id="4b7ccca3ceae5c83ff288cc4eb0abc220de47e8b" translate="yes" xml:space="preserve">
          <source>Try building your package with &lt;code&gt;python setup.py sdist&lt;/code&gt; (run from inside &lt;code&gt;django-polls&lt;/code&gt;). This creates a directory called &lt;code&gt;dist&lt;/code&gt; and builds your new package, &lt;code&gt;django-polls-0.1.tar.gz&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;python setup.py sdist&lt;/code&gt; ( &lt;code&gt;django-polls&lt;/code&gt; 내부에서 실행)로 패키지를 빌드하십시오 . 그러면 &lt;code&gt;dist&lt;/code&gt; 라는 디렉토리가 만들어 지고 &lt;code&gt;django-polls-0.1.tar.gz&lt;/code&gt; 라는 새 패키지 가 만들어집니다 .</target>
        </trans-unit>
        <trans-unit id="81d1a0a5d7fa3f602c181827b8e6e45df5684d9d" translate="yes" xml:space="preserve">
          <source>Try the &lt;a href=&quot;https://docs.djangoproject.com/en/3.0/faq/index/&quot;&gt;FAQ&lt;/a&gt; &amp;ndash; it&amp;rsquo;s got answers to many common questions.</source>
          <target state="translated">&lt;a href=&quot;https://docs.djangoproject.com/en/3.0/faq/index/&quot;&gt;FAQ를&lt;/a&gt; 사용해보십시오 . 많은 일반적인 질문에 대한 답변이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b72362907fdcf8f8383ea35245756dd8c92376e" translate="yes" xml:space="preserve">
          <source>Turns a Django template into something that is understood by &lt;code&gt;xgettext&lt;/code&gt;. It does so by translating the Django translation tags into standard &lt;code&gt;gettext&lt;/code&gt; function invocations.</source>
          <target state="translated">Django 템플릿을 &lt;code&gt;xgettext&lt;/code&gt; 가 이해하는 것으로 바꿉니다 . Django 변환 태그를 표준 &lt;code&gt;gettext&lt;/code&gt; 함수 호출 로 변환하여이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="7dc01edfef659ca9656de153951cd03b7f04f6b7" translate="yes" xml:space="preserve">
          <source>Turns a language name (en-us) into a locale name (en_US).</source>
          <target state="translated">언어 이름 (en-us)을 로캘 이름 (en_US)으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">Tutorial</target>
        </trans-unit>
        <trans-unit id="2e5c8a1bba5f02cdf1bbaf90b229d5b43c239eab" translate="yes" xml:space="preserve">
          <source>Two &lt;a href=&quot;#django.contrib.gis.measure.Distance&quot;&gt;&lt;code&gt;Distance&lt;/code&gt;&lt;/a&gt; objects multiplied together will yield an &lt;a href=&quot;#django.contrib.gis.measure.Area&quot;&gt;&lt;code&gt;Area&lt;/code&gt;&lt;/a&gt; object, which uses squared units of measure:</source>
          <target state="translated">두 &lt;a href=&quot;#django.contrib.gis.measure.Distance&quot;&gt; &lt;code&gt;Distance&lt;/code&gt; &lt;/a&gt; 오브젝트를 함께 곱하면 제곱 측정 단위를 사용 하는 &lt;a href=&quot;#django.contrib.gis.measure.Area&quot;&gt; &lt;code&gt;Area&lt;/code&gt; &lt;/a&gt; 오브젝트 가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="1ddba53b1994066fc414e01042121a473c383f33" translate="yes" xml:space="preserve">
          <source>Two central mixins are provided that help in providing a consistent interface to working with templates in class-based views.</source>
          <target state="translated">클래스 기반보기에서 템플리트 작업에 대한 일관된 인터페이스를 제공하는 데 도움이되는 두 가지 중앙 믹스 인이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="d816953eb086441b820d022f8dd3a40162fb2ccf" translate="yes" xml:space="preserve">
          <source>Two fields are available for representing relationships between models: &lt;a href=&quot;#django.forms.ModelChoiceField&quot;&gt;&lt;code&gt;ModelChoiceField&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#django.forms.ModelMultipleChoiceField&quot;&gt;&lt;code&gt;ModelMultipleChoiceField&lt;/code&gt;&lt;/a&gt;. Both of these fields require a single &lt;code&gt;queryset&lt;/code&gt; parameter that is used to create the choices for the field. Upon form validation, these fields will place either one model object (in the case of &lt;code&gt;ModelChoiceField&lt;/code&gt;) or multiple model objects (in the case of &lt;code&gt;ModelMultipleChoiceField&lt;/code&gt;) into the &lt;code&gt;cleaned_data&lt;/code&gt; dictionary of the form.</source>
          <target state="translated">&lt;a href=&quot;#django.forms.ModelChoiceField&quot;&gt; &lt;code&gt;ModelChoiceField&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#django.forms.ModelMultipleChoiceField&quot;&gt; &lt;code&gt;ModelMultipleChoiceField&lt;/code&gt; 의&lt;/a&gt; 두 모델을 사용하여 모델 간의 관계를 표시 할 수 있습니다 . 이 두 필드 모두 필드에 대한 선택 사항을 작성하는 데 사용되는 단일 &lt;code&gt;queryset&lt;/code&gt; 매개 변수가 필요 합니다. 양식 유효성 검증시,이 필드는 하나의 모델 오브젝트 ( &lt;code&gt;ModelChoiceField&lt;/code&gt; 의 경우 ) 또는 여러 모델 오브젝트 ( &lt;code&gt;ModelMultipleChoiceField&lt;/code&gt; 의 경우 )를 양식 의 &lt;code&gt;cleaned_data&lt;/code&gt; 사전에 배치합니다.</target>
        </trans-unit>
        <trans-unit id="b170ac349370f8d310253a7a01514b90d0c26dca" translate="yes" xml:space="preserve">
          <source>Two methods of this class, &lt;a href=&quot;#django.db.models.fields.files.FieldFile.save&quot;&gt;&lt;code&gt;save()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#django.db.models.fields.files.FieldFile.delete&quot;&gt;&lt;code&gt;delete()&lt;/code&gt;&lt;/a&gt;, default to saving the model object of the associated &lt;code&gt;FieldFile&lt;/code&gt; in the database.</source>
          <target state="translated">이 클래스의 두 가지 메소드 인 &lt;a href=&quot;#django.db.models.fields.files.FieldFile.save&quot;&gt; &lt;code&gt;save()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#django.db.models.fields.files.FieldFile.delete&quot;&gt; &lt;code&gt;delete()&lt;/code&gt; &lt;/a&gt; 는 기본값으로 연관된 &lt;code&gt;FieldFile&lt;/code&gt; 의 모델 오브젝트를 데이터베이스에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="b2e570d805954365899ee35de180ff9bd49641c6" translate="yes" xml:space="preserve">
          <source>Two points to keep in mind:</source>
          <target state="translated">명심해야 할 두 가지 사항 :</target>
        </trans-unit>
        <trans-unit id="815a24a5cc5ca41345b659877e73616c58415b17" translate="yes" xml:space="preserve">
          <source>Two useful classes defined by the default admin site stylesheet are &lt;code&gt;collapse&lt;/code&gt; and &lt;code&gt;wide&lt;/code&gt;. Fieldsets with the &lt;code&gt;collapse&lt;/code&gt; style will be initially collapsed in the admin and replaced with a small &amp;ldquo;click to expand&amp;rdquo; link. Fieldsets with the &lt;code&gt;wide&lt;/code&gt; style will be given extra horizontal space.</source>
          <target state="translated">기본 관리 사이트 스타일 시트로 정의 된 두 가지 유용한 클래스는 &lt;code&gt;collapse&lt;/code&gt; 및 &lt;code&gt;wide&lt;/code&gt; 입니다. 와 필드 셋 &lt;code&gt;collapse&lt;/code&gt; 스타일은 처음에 관리자에 쓰러져 작은으로 대체됩니다 링크 &quot;를 클릭하여 확장합니다.&quot; &lt;code&gt;wide&lt;/code&gt; 스타일의 필드 세트에는 추가 수평 공간이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6b2b03652663529bd450d6bbe6d5fc37a61eb7ce" translate="yes" xml:space="preserve">
          <source>Two, you can take advantage of Django&amp;rsquo;s automatic HTML escaping. The remainder of this section describes how auto-escaping works.</source>
          <target state="translated">둘째, Django의 자동 HTML 이스케이프를 활용할 수 있습니다. 이 섹션의 나머지 부분에서는 자동 이스케이프 작동 방식에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="25c0a3b54746b5c6ae00df28e01c6ee12259be54" translate="yes" xml:space="preserve">
          <source>Tying transactions to HTTP requests</source>
          <target state="translated">트랜잭션을 HTTP 요청에 연결</target>
        </trans-unit>
        <trans-unit id="284b399f23fa53068e7e6cbd4722903619258932" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;django-admin&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;django-admin&lt;/code&gt; 을 입력 하십시오 .</target>
        </trans-unit>
        <trans-unit id="925e03542b6d4d6c0808e833d67cd7b0d2c2d7a4" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;sql&lt;/code&gt;, then [TAB], to see all available options whose names start with &lt;code&gt;sql&lt;/code&gt;.</source>
          <target state="translated">이름이 &lt;code&gt;sql&lt;/code&gt; 로 시작하는 사용 가능한 모든 옵션을 보려면 &lt;code&gt;sql&lt;/code&gt; 을 입력 한 다음 [TAB]을 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="9371d55d8f419ec9e71f9ff1823ffa8380a68e6c" translate="yes" xml:space="preserve">
          <source>Typical usage could look like:</source>
          <target state="translated">일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6586dad6c3167af1032694da1cb2d6724883211c" translate="yes" xml:space="preserve">
          <source>Typical usage is to pass the contents of the page, as a string, bytestring, or &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#memoryview&quot;&gt;&lt;code&gt;memoryview&lt;/code&gt;&lt;/a&gt;, to the &lt;a href=&quot;#django.http.HttpResponse&quot;&gt;&lt;code&gt;HttpResponse&lt;/code&gt;&lt;/a&gt; constructor:</source>
          <target state="translated">일반적인 사용법은 페이지의 컨텐츠를 문자열, &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#memoryview&quot;&gt; &lt;code&gt;memoryview&lt;/code&gt; &lt;/a&gt; 스트링 또는 memoryview 로 &lt;a href=&quot;#django.http.HttpResponse&quot;&gt; &lt;code&gt;HttpResponse&lt;/code&gt; &lt;/a&gt; 생성자에 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8d2be8893af1440290d9688a1844738f711ab097" translate="yes" xml:space="preserve">
          <source>Typical usage looks like this:</source>
          <target state="translated">일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f3508436aca4931ed78c0fb1cc8a48c3810e49c1" translate="yes" xml:space="preserve">
          <source>Typically no special setup is required, so you can create a database as you would for any other project. We provide some tips for selected databases:</source>
          <target state="translated">일반적으로 특별한 설정이 필요하지 않으므로 다른 프로젝트와 마찬가지로 데이터베이스를 만들 수 있습니다. 선택한 데이터베이스에 대한 몇 가지 팁을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="171a04d7323b7ce0a800dd8dd2d6c0b2de9b680a" translate="yes" xml:space="preserve">
          <source>Typically you won&amp;rsquo;t need to call this function directly as &lt;a href=&quot;#django.contrib.admin.apps.AdminConfig&quot;&gt;&lt;code&gt;AdminConfig&lt;/code&gt;&lt;/a&gt; calls it when Django starts.</source>
          <target state="translated">Django가 시작될 때 &lt;a href=&quot;#django.contrib.admin.apps.AdminConfig&quot;&gt; &lt;code&gt;AdminConfig&lt;/code&gt; 가&lt;/a&gt; 호출 할 때 일반적으로이 함수를 직접 호출 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="194eec74135e2433ce763a4495e6e4c62acf5871" translate="yes" xml:space="preserve">
          <source>Typically, SRID integer corresponds to an EPSG (&lt;a href=&quot;http://www.epsg.org&quot;&gt;European Petroleum Survey Group&lt;/a&gt;) identifier. However, it may also be associated with custom projections defined in spatial database&amp;rsquo;s spatial reference systems table.</source>
          <target state="translated">일반적으로 SRID 정수는 EPSG ( &lt;a href=&quot;http://www.epsg.org&quot;&gt;European Petroleum Survey Group&lt;/a&gt; ) 식별자에 해당합니다. 그러나 공간 데이터베이스의 공간 참조 시스템 테이블에 정의 된 사용자 정의 투영과 연관 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe375bf4dcf4d6939b07c3b9a84b4a5bb829f992" translate="yes" xml:space="preserve">
          <source>Typically, all the features in a given layer have the same geometry type. The &lt;a href=&quot;#django.contrib.gis.gdal.Layer.geom_type&quot;&gt;&lt;code&gt;geom_type&lt;/code&gt;&lt;/a&gt; property of a layer is an &lt;a href=&quot;#django.contrib.gis.gdal.OGRGeomType&quot;&gt;&lt;code&gt;OGRGeomType&lt;/code&gt;&lt;/a&gt; that identifies the feature type. We can use it to print out some basic information about each layer in a &lt;a href=&quot;#django.contrib.gis.gdal.DataSource&quot;&gt;&lt;code&gt;DataSource&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">일반적으로 지정된 레이어의 모든 피처는 동일한 지오메트리 유형을 갖습니다. 레이어 의 &lt;a href=&quot;#django.contrib.gis.gdal.Layer.geom_type&quot;&gt; &lt;code&gt;geom_type&lt;/code&gt; &lt;/a&gt; 속성은 기능 유형을 식별 하는 &lt;a href=&quot;#django.contrib.gis.gdal.OGRGeomType&quot;&gt; &lt;code&gt;OGRGeomType&lt;/code&gt; &lt;/a&gt; 입니다. 이를 사용하여 &lt;a href=&quot;#django.contrib.gis.gdal.DataSource&quot;&gt; &lt;code&gt;DataSource&lt;/code&gt; 의&lt;/a&gt; 각 레이어에 대한 몇 가지 기본 정보를 인쇄 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="addbaa5134e849cbef651142b78c7358e9b21b1c" translate="yes" xml:space="preserve">
          <source>Typically, these situations only arise once you&amp;rsquo;re maintaining several Django projects. When they do, the best solution is to use &lt;a href=&quot;https://virtualenv.pypa.io/&quot;&gt;virtualenv&lt;/a&gt;. This tool allows you to maintain multiple isolated Python environments, each with its own copy of the libraries and package namespace.</source>
          <target state="translated">일반적으로 이러한 상황은 여러 장고 프로젝트를 유지 관리하는 경우에만 발생합니다. 그들이 할 때, 가장 좋은 해결책은 &lt;a href=&quot;https://virtualenv.pypa.io/&quot;&gt;virtualenv&lt;/a&gt; 를 사용하는 것 입니다. 이 도구를 사용하면 각각 자체 라이브러리 및 패키지 네임 스페이스 사본이있는 여러 개의 격리 된 Python 환경을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70bb89b902745d894f0e1eafcb41ded5f44ac90e" translate="yes" xml:space="preserve">
          <source>U.S. Foot, US survey foot</source>
          <target state="translated">미국 발, 미국 측량 발</target>
        </trans-unit>
        <trans-unit id="a052aa98c496052d56ddc42a2048784696547215" translate="yes" xml:space="preserve">
          <source>URI and IRI handling</source>
          <target state="translated">URI 및 IRI 처리</target>
        </trans-unit>
        <trans-unit id="537934d17dfeba7650e4ed80813214cc05308357" translate="yes" xml:space="preserve">
          <source>URL Resolver exceptions</source>
          <target state="translated">URL 확인자 예외</target>
        </trans-unit>
        <trans-unit id="76465e7de64e7d6c35a96f84b56d72b629ef7b51" translate="yes" xml:space="preserve">
          <source>URL Resolver exceptions are defined in &lt;code&gt;django.urls&lt;/code&gt;.</source>
          <target state="translated">URL &lt;code&gt;django.urls&lt;/code&gt; 예외는 django.urls에 정의되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="817b6f3e6db010d7fe83dad284aa883291e1a446" translate="yes" xml:space="preserve">
          <source>URL dispatcher</source>
          <target state="translated">URL 디스패처</target>
        </trans-unit>
        <trans-unit id="24a86b04a9f50c5d82d505233a5777d87f685ab5" translate="yes" xml:space="preserve">
          <source>URL name</source>
          <target state="translated">URL 이름</target>
        </trans-unit>
        <trans-unit id="c629a665566f9c1e3063cb1969010515a8213be7" translate="yes" xml:space="preserve">
          <source>URL namespaces</source>
          <target state="translated">URL 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="dc1e6ac2e11787b957382ad433ed1a87487d1ecf" translate="yes" xml:space="preserve">
          <source>URL namespaces allow you to uniquely reverse &lt;a href=&quot;#naming-url-patterns&quot;&gt;named URL patterns&lt;/a&gt; even if different applications use the same URL names. It&amp;rsquo;s a good practice for third-party apps to always use namespaced URLs (as we did in the tutorial). Similarly, it also allows you to reverse URLs if multiple instances of an application are deployed. In other words, since multiple instances of a single application will share named URLs, namespaces provide a way to tell these named URLs apart.</source>
          <target state="translated">다른 응용 프로그램에서 동일한 URL 이름을 사용하더라도 URL 네임 스페이스를 사용하면 &lt;a href=&quot;#naming-url-patterns&quot;&gt;명명 된 URL 패턴&lt;/a&gt; 을 고유하게 되돌릴 수 있습니다 . 자습서에서와 같이 타사 응용 프로그램은 항상 네임 스페이스 URL을 사용하는 것이 좋습니다. 마찬가지로 응용 프로그램의 여러 인스턴스가 배포 된 경우 URL을 되돌릴 수도 있습니다. 즉, 단일 응용 프로그램의 여러 인스턴스가 명명 된 URL을 공유하므로 네임 스페이스는 이러한 명명 된 URL을 구별하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2559622dd3ed7db1b8df6c56bbc7b62234ce53d5" translate="yes" xml:space="preserve">
          <source>URL namespaces and included URLconfs</source>
          <target state="translated">URL 네임 스페이스 및 포함 된 URLconf</target>
        </trans-unit>
        <trans-unit id="d1547aa9a835c26a8cee3da710e3248942951f5a" translate="yes" xml:space="preserve">
          <source>URL patterns can also be marked translatable using the &lt;a href=&quot;../../ref/utils#django.utils.translation.gettext_lazy&quot;&gt;&lt;code&gt;gettext_lazy()&lt;/code&gt;&lt;/a&gt; function. Example:</source>
          <target state="translated">&lt;a href=&quot;../../ref/utils#django.utils.translation.gettext_lazy&quot;&gt; &lt;code&gt;gettext_lazy()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 URL 패턴을 번역 가능으로 표시 할 수도 있습니다 . 예:</target>
        </trans-unit>
        <trans-unit id="3dd216f364451630b0caa07bd44f1c704b470880" translate="yes" xml:space="preserve">
          <source>URL that handles the media served from &lt;a href=&quot;#std:setting-MEDIA_ROOT&quot;&gt;&lt;code&gt;MEDIA_ROOT&lt;/code&gt;&lt;/a&gt;, used for &lt;a href=&quot;../topics/files&quot;&gt;managing stored files&lt;/a&gt;. It must end in a slash if set to a non-empty value. You will need to &lt;a href=&quot;../howto/static-files/index#serving-uploaded-files-in-development&quot;&gt;configure these files to be served&lt;/a&gt; in both development and production environments.</source>
          <target state="translated">&lt;a href=&quot;../topics/files&quot;&gt;저장된 파일 관리에&lt;/a&gt; 사용되는 &lt;a href=&quot;#std:setting-MEDIA_ROOT&quot;&gt; &lt;code&gt;MEDIA_ROOT&lt;/code&gt; &lt;/a&gt; 에서 제공되는 미디어를 처리하는 URL입니다 . 비어 있지 않은 값으로 설정되면 슬래시로 끝나야합니다. 개발 및 프로덕션 환경 모두에서 &lt;a href=&quot;../howto/static-files/index#serving-uploaded-files-in-development&quot;&gt;이러한 파일을 제공하도록 구성&lt;/a&gt; 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="5bb14ab7cd6e24c66e5777b642adc9e5f1f60672" translate="yes" xml:space="preserve">
          <source>URL that serves the files stored at this location. Defaults to the value of your &lt;a href=&quot;../settings#std:setting-MEDIA_URL&quot;&gt;&lt;code&gt;MEDIA_URL&lt;/code&gt;&lt;/a&gt; setting.</source>
          <target state="translated">이 위치에 저장된 파일을 제공하는 URL입니다. 기본값은 &lt;a href=&quot;../settings#std:setting-MEDIA_URL&quot;&gt; &lt;code&gt;MEDIA_URL&lt;/code&gt; &lt;/a&gt; 설정 값입니다 .</target>
        </trans-unit>
        <trans-unit id="26ae75a5bfde1dd4675ea7fb479db6f98a7ec902" translate="yes" xml:space="preserve">
          <source>URL to use when referring to static files located in &lt;a href=&quot;#std:setting-STATIC_ROOT&quot;&gt;&lt;code&gt;STATIC_ROOT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#std:setting-STATIC_ROOT&quot;&gt; &lt;code&gt;STATIC_ROOT&lt;/code&gt; &lt;/a&gt; 에있는 정적 파일을 참조 할 때 사용할 URL 입니다.</target>
        </trans-unit>
        <trans-unit id="497117c14c985e24e2ba585ac0a1bee910038b27" translate="yes" xml:space="preserve">
          <source>URL/URI scheme list to validate against. If not provided, the default list is &lt;code&gt;['http', 'https', 'ftp', 'ftps']&lt;/code&gt;. As a reference, the IANA website provides a full list of &lt;a href=&quot;https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml&quot;&gt;valid URI schemes&lt;/a&gt;.</source>
          <target state="translated">확인할 URL / URI 체계 목록입니다. 제공되지 않은 경우 기본 목록은 &lt;code&gt;['http', 'https', 'ftp', 'ftps']&lt;/code&gt; 입니다. 참고로 IANA 웹 사이트는 &lt;a href=&quot;https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml&quot;&gt;유효한 URI 체계&lt;/a&gt; 의 전체 목록을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="13535bcaecf34cb0b8195c2d1fff7157703c3b22" translate="yes" xml:space="preserve">
          <source>URLconf configuration</source>
          <target state="translated">URLconf 구성</target>
        </trans-unit>
        <trans-unit id="2c4a4c0c224c02286d9e3417d15bc754ce40a177" translate="yes" xml:space="preserve">
          <source>URLconfs have a hook that lets you pass extra arguments to your view functions, as a Python dictionary.</source>
          <target state="translated">URLconf에는 파이썬 사전으로서 뷰 함수에 추가 인수를 전달할 수있는 후크가 있습니다.</target>
        </trans-unit>
        <trans-unit id="01f03837323aab32409bb99c50d6c475179c49df" translate="yes" xml:space="preserve">
          <source>URLs</source>
          <target state="translated">URLs</target>
        </trans-unit>
        <trans-unit id="fe4ee470c2d9d9422184f5e40e8c4eddab2bd6d5" translate="yes" xml:space="preserve">
          <source>URLs can only contain ASCII characters. If you&amp;rsquo;re constructing a URL from pieces of data that might be non-ASCII, be careful to encode the results in a way that is suitable for a URL. The &lt;a href=&quot;urlresolvers#django.urls.reverse&quot;&gt;&lt;code&gt;reverse()&lt;/code&gt;&lt;/a&gt; function handles this for you automatically.</source>
          <target state="translated">URL은 ASCII 문자 만 포함 할 수 있습니다. ASCII가 아닌 데이터 조각으로 URL을 구성하는 경우 결과를 URL에 적합한 방식으로 인코딩해야합니다. &lt;a href=&quot;urlresolvers#django.urls.reverse&quot;&gt; &lt;code&gt;reverse()&lt;/code&gt; &lt;/a&gt; 함수는 자동으로이 문제를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="18bc5956dbf1cc6c9a5baeb624c9e7e472a04c2e" translate="yes" xml:space="preserve">
          <source>USA</source>
          <target state="translated">USA</target>
        </trans-unit>
        <trans-unit id="3ff8bc01be66cf3d1a62c736b545ceee1d390ce8" translate="yes" xml:space="preserve">
          <source>USE_TZ, TIME_ZONE</source>
          <target state="translated">USE_TZ, TIME_ZONE</target>
        </trans-unit>
        <trans-unit id="2896e5725681c6c61a1e90ef8fdb155a5aaacdc6" translate="yes" xml:space="preserve">
          <source>UTC offsets are supported; if &lt;code&gt;value&lt;/code&gt; describes one, the result&amp;rsquo;s &lt;code&gt;tzinfo&lt;/code&gt; attribute is a &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#datetime.timezone&quot;&gt;&lt;code&gt;datetime.timezone&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">UTC 오프셋이 지원됩니다. 경우 &lt;code&gt;value&lt;/code&gt; 을 설명, 결과의 &lt;code&gt;tzinfo&lt;/code&gt; 의 속성은입니다 &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#datetime.timezone&quot;&gt; &lt;code&gt;datetime.timezone&lt;/code&gt; 의&lt;/a&gt; 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="f1c3660f6451ec964daeb830f8ed5e7e3d28a651" translate="yes" xml:space="preserve">
          <source>UTC offsets aren&amp;rsquo;t supported; if &lt;code&gt;value&lt;/code&gt; describes one, the result is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">UTC 오프셋은 지원되지 않습니다. 만약 &lt;code&gt;value&lt;/code&gt; 한 설명의 결과는 없다 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef4f3dbafb7dcdfb75412e4bd3ff34f766181f02" translate="yes" xml:space="preserve">
          <source>Ultimately, a log record needs to be rendered as text. Formatters describe the exact format of that text. A formatter usually consists of a Python formatting string containing &lt;a href=&quot;https://docs.python.org/3/library/logging.html#logrecord-attributes&quot;&gt;LogRecord attributes&lt;/a&gt;; however, you can also write custom formatters to implement specific formatting behavior.</source>
          <target state="translated">궁극적으로 로그 레코드는 텍스트로 렌더링해야합니다. 포맷터는 해당 텍스트의 정확한 형식을 설명합니다. 포맷터는 일반적으로 &lt;a href=&quot;https://docs.python.org/3/library/logging.html#logrecord-attributes&quot;&gt;LogRecord 속성을&lt;/a&gt; 포함하는 Python 포맷 문자열로 구성됩니다 . 그러나 특정 포맷 동작을 구현하기 위해 사용자 정의 포맷터를 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="daed8868347d31d8ec9063c8de3c7b3283a1982c" translate="yes" xml:space="preserve">
          <source>Ultimately, this decoupling of compilation and rendering results in an efficient template system, because a template can render multiple contexts without having to be parsed multiple times.</source>
          <target state="translated">궁극적으로 템플릿 컴파일은 여러 번 구문 분석 할 필요없이 여러 컨텍스트를 렌더링 할 수 있기 때문에 컴파일 및 렌더링을 분리하면 효율적인 템플릿 시스템이됩니다.</target>
        </trans-unit>
        <trans-unit id="f2263abf4919f6f700b496c264250c09010ae59a" translate="yes" xml:space="preserve">
          <source>Ultimately, which of these methods are implemented is up to you. Leaving some methods unimplemented will result in a partial (possibly broken) interface.</source>
          <target state="translated">궁극적으로 이러한 방법 중 어느 것이 구현되는지는 귀하에게 달려 있습니다. 구현되지 않은 일부 메소드를 남겨두면 인터페이스가 부분적으로 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6ffee908070a6e965544e9f8f0ab655b5d142d7" translate="yes" xml:space="preserve">
          <source>Unbound methods used from within the class body</source>
          <target state="translated">클래스 본문 내에서 사용되는 언 바운드 메소드</target>
        </trans-unit>
        <trans-unit id="8d8e3267c6f21de72e6dc30a8c452305fba38653" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;MIDDLEWARE_CLASSES&lt;/code&gt;, &lt;code&gt;process_exception&lt;/code&gt; is applied to exceptions raised from a middleware &lt;code&gt;process_request&lt;/code&gt; method. Under &lt;a href=&quot;../../ref/settings#std:setting-MIDDLEWARE&quot;&gt;&lt;code&gt;MIDDLEWARE&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;process_exception&lt;/code&gt; applies only to exceptions raised from the view (or from the &lt;code&gt;render&lt;/code&gt; method of a &lt;a href=&quot;../../ref/template-response#django.template.response.TemplateResponse&quot;&gt;&lt;code&gt;TemplateResponse&lt;/code&gt;&lt;/a&gt;). Exceptions raised from a middleware are converted to the appropriate HTTP response and then passed to the next middleware.</source>
          <target state="translated">아래 &lt;code&gt;MIDDLEWARE_CLASSES&lt;/code&gt; , &lt;code&gt;process_exception&lt;/code&gt; 는 미들웨어에서 발행되는 예외에 적용되는 &lt;code&gt;process_request&lt;/code&gt; 의 방법. 에서 &lt;a href=&quot;../../ref/settings#std:setting-MIDDLEWARE&quot;&gt; &lt;code&gt;MIDDLEWARE&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;process_exception&lt;/code&gt; 는 뷰 (또는에서에서 발행되는 예외에만 적용 &lt;code&gt;render&lt;/code&gt; (A)의 방법 &lt;a href=&quot;../../ref/template-response#django.template.response.TemplateResponse&quot;&gt; &lt;code&gt;TemplateResponse&lt;/code&gt; &lt;/a&gt; ). 미들웨어에서 발생한 예외는 적절한 HTTP 응답으로 변환 된 후 다음 미들웨어로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="a517ca73ec3959b2bebd89a9f2095b9820a5a3f7" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;MIDDLEWARE_CLASSES&lt;/code&gt;, every middleware will always have its &lt;code&gt;process_response&lt;/code&gt; method called, even if an earlier middleware short-circuited by returning a response from its &lt;code&gt;process_request&lt;/code&gt; method. Under &lt;a href=&quot;../../ref/settings#std:setting-MIDDLEWARE&quot;&gt;&lt;code&gt;MIDDLEWARE&lt;/code&gt;&lt;/a&gt;, middleware behaves more like an onion: the layers that a response goes through on the way out are the same layers that saw the request on the way in. If a middleware short-circuits, only that middleware and the ones before it in &lt;a href=&quot;../../ref/settings#std:setting-MIDDLEWARE&quot;&gt;&lt;code&gt;MIDDLEWARE&lt;/code&gt;&lt;/a&gt; will see the response.</source>
          <target state="translated">아래 &lt;code&gt;MIDDLEWARE_CLASSES&lt;/code&gt; , 모든 미들웨어는 항상있을 것이다 &lt;code&gt;process_response&lt;/code&gt; 의 이전 미들웨어가의 응답을 반환하여 단락 경우에도, 메소드가 호출 &lt;code&gt;process_request&lt;/code&gt; 방법. 에서 &lt;a href=&quot;../../ref/settings#std:setting-MIDDLEWARE&quot;&gt; &lt;code&gt;MIDDLEWARE&lt;/code&gt; &lt;/a&gt; , 더 양파와 같은 미들웨어 동작합니다. 레이어 응답이 길을가는 것이 밖으로의 길에 요청을했다 같은 층은 미들웨어 단락의 경우, 해당 미들웨어 및 그 이전의 것들에 &lt;a href=&quot;../../ref/settings#std:setting-MIDDLEWARE&quot;&gt; &lt;code&gt;MIDDLEWARE&lt;/code&gt; &lt;/a&gt; 가 응답을 보게됩니다.</target>
        </trans-unit>
        <trans-unit id="2e095708d3920e34ee1dc311c28ec0dbf966c605" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;MIDDLEWARE_CLASSES&lt;/code&gt;, if a &lt;code&gt;process_response&lt;/code&gt; method raises an exception, the &lt;code&gt;process_response&lt;/code&gt; methods of all earlier middleware are skipped and a &lt;code&gt;500 Internal Server Error&lt;/code&gt; HTTP response is always returned (even if the exception raised was e.g. an &lt;a href=&quot;views#django.http.Http404&quot;&gt;&lt;code&gt;Http404&lt;/code&gt;&lt;/a&gt;). Under &lt;a href=&quot;../../ref/settings#std:setting-MIDDLEWARE&quot;&gt;&lt;code&gt;MIDDLEWARE&lt;/code&gt;&lt;/a&gt;, an exception raised from a middleware will immediately be converted to the appropriate HTTP response, and then the next middleware in line will see that response. Middleware are never skipped due to a middleware raising an exception.</source>
          <target state="translated">아래 &lt;code&gt;MIDDLEWARE_CLASSES&lt;/code&gt; 경우, &lt;code&gt;process_response&lt;/code&gt; 의 방법은 예외를 발생의 &lt;code&gt;process_response&lt;/code&gt; 의 방법은 모든 이전 미들웨어는 건너 뜁니다과 &lt;code&gt;500 Internal Server Error&lt;/code&gt; (제기 예외가 예 경우에도 HTTP 응답은 항상 반환 &lt;a href=&quot;views#django.http.Http404&quot;&gt; &lt;code&gt;Http404&lt;/code&gt; &lt;/a&gt; )를. &lt;a href=&quot;../../ref/settings#std:setting-MIDDLEWARE&quot;&gt; &lt;code&gt;MIDDLEWARE&lt;/code&gt; &lt;/a&gt; 에서 미들웨어 에서 발생한 예외는 즉시 해당 HTTP 응답으로 변환 된 후 다음 미들웨어가 해당 응답을 보게됩니다. 예외를 발생시키는 미들웨어로 인해 미들웨어를 건너 뛰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="515ce2727abcbfd2ac3b85d45a81ce5e030f2c11" translate="yes" xml:space="preserve">
          <source>Under Windows, the native console doesn&amp;rsquo;t support ANSI escape sequences so by default there is no color output. But you can install the &lt;a href=&quot;http://adoxa.altervista.org/ansicon/&quot;&gt;ANSICON&lt;/a&gt; third-party tool, the Django commands will detect its presence and will make use of its services to color output just like on Unix-based platforms.</source>
          <target state="translated">Windows에서 기본 콘솔은 ANSI 이스케이프 시퀀스를 지원하지 않으므로 기본적으로 색상 출력이 없습니다. 그러나 &lt;a href=&quot;http://adoxa.altervista.org/ansicon/&quot;&gt;ANSICON&lt;/a&gt; 타사 도구를 설치할 수 있습니다 . Django 명령은 존재 여부를 감지하고 Unix 기반 플랫폼에서와 같이 해당 서비스를 사용하여 색상을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="72919eaa82f1485690318e923afbdd3baf5e0c35" translate="yes" xml:space="preserve">
          <source>Under higher isolation levels, your application should be prepared to handle exceptions raised on serialization failures. This option is designed for advanced uses.</source>
          <target state="translated">높은 격리 수준에서는 직렬화 실패로 인해 발생한 예외를 처리 할 수 ​​있도록 응용 프로그램을 준비해야합니다. 이 옵션은 고급 사용을 위해 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="8eaeab2e86278d9371f61d3e5bc4e8aa909cbf8c" translate="yes" xml:space="preserve">
          <source>Under some Web server configurations, the portion of the URL after the host name is split up into a script prefix portion and a path info portion. The &lt;code&gt;path_info&lt;/code&gt; attribute always contains the path info portion of the path, no matter what Web server is being used. Using this instead of &lt;a href=&quot;#django.http.HttpRequest.path&quot;&gt;&lt;code&gt;path&lt;/code&gt;&lt;/a&gt; can make your code easier to move between test and deployment servers.</source>
          <target state="translated">일부 웹 서버 구성에서 호스트 이름 뒤에있는 URL 부분은 스크립트 접두사 부분과 경로 정보 부분으로 나뉩니다. &lt;code&gt;path_info&lt;/code&gt; 속성은 항상 경로의 경로 정보 부분, 사용되는 어떤 웹 서버에 상관없이이 포함되어 있습니다. &lt;a href=&quot;#django.http.HttpRequest.path&quot;&gt; &lt;code&gt;path&lt;/code&gt; &lt;/a&gt; 대신이 옵션을 사용하면 테스트 서버와 배포 서버간에 코드를보다 쉽게 ​​이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6be0c94a1de74f1c879eb8f444c36fc42fd443c6" translate="yes" xml:space="preserve">
          <source>Under the hood, Django&amp;rsquo;s transaction management code:</source>
          <target state="translated">Django의 트랜잭션 관리 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6e395b95068084161c0fecdba4578ad3974b0839" translate="yes" xml:space="preserve">
          <source>Under the hood, all methods of pagination use the &lt;a href=&quot;../ref/paginator#django.core.paginator.Paginator&quot;&gt;&lt;code&gt;Paginator&lt;/code&gt;&lt;/a&gt; class. It does all the heavy lifting of actually splitting a &lt;code&gt;QuerySet&lt;/code&gt; into &lt;a href=&quot;../ref/paginator#django.core.paginator.Page&quot;&gt;&lt;code&gt;Page&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">후드 아래에서 모든 페이지 매김 방법은 &lt;a href=&quot;../ref/paginator#django.core.paginator.Paginator&quot;&gt; &lt;code&gt;Paginator&lt;/code&gt; &lt;/a&gt; 클래스를 사용합니다 . 실제로 &lt;code&gt;QuerySet&lt;/code&gt; 을 &lt;a href=&quot;../ref/paginator#django.core.paginator.Page&quot;&gt; &lt;code&gt;Page&lt;/code&gt; &lt;/a&gt; 개체 로 분할하는 모든 작업 을 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="fdf244fbceb38e0293830a8ef0ab0068c00bdf38" translate="yes" xml:space="preserve">
          <source>Under this configuration, the &lt;code&gt;diamonds&lt;/code&gt; database will be created first, as it is the only database alias without dependencies. The &lt;code&gt;default&lt;/code&gt; and &lt;code&gt;clubs&lt;/code&gt; alias will be created next (although the order of creation of this pair is not guaranteed), then &lt;code&gt;hearts&lt;/code&gt;, and finally &lt;code&gt;spades&lt;/code&gt;.</source>
          <target state="translated">이 구성에서 &lt;code&gt;diamonds&lt;/code&gt; 데이터베이스는 종속성이없는 유일한 데이터베이스 별명이므로 먼저 작성됩니다. &lt;code&gt;default&lt;/code&gt; 및 &lt;code&gt;clubs&lt;/code&gt; 별칭 (이 쌍 생성 순서가 보장되지 않지만) 다음 다음 생성됩니다 &lt;code&gt;hearts&lt;/code&gt; , 그리고 마지막으로 &lt;code&gt;spades&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa7abe66c644f5fb29a4aa5308e783fb1ba57d00" translate="yes" xml:space="preserve">
          <source>Understand &lt;a href=&quot;../../ref/models/querysets#django.db.models.query.QuerySet.select_related&quot;&gt;&lt;code&gt;select_related()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../ref/models/querysets#django.db.models.query.QuerySet.prefetch_related&quot;&gt;&lt;code&gt;prefetch_related()&lt;/code&gt;&lt;/a&gt; thoroughly, and use them:</source>
          <target state="translated">&lt;a href=&quot;../../ref/models/querysets#django.db.models.query.QuerySet.select_related&quot;&gt; &lt;code&gt;select_related()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../ref/models/querysets#django.db.models.query.QuerySet.prefetch_related&quot;&gt; &lt;code&gt;prefetch_related()&lt;/code&gt; &lt;/a&gt; 철저히 이해 하고 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="27980d221e4d7607bce2a77be739711a85c6fc46" translate="yes" xml:space="preserve">
          <source>Understand &lt;code&gt;QuerySet&lt;/code&gt; evaluation</source>
          <target state="translated">&lt;code&gt;QuerySet&lt;/code&gt; 평가 이해</target>
        </trans-unit>
        <trans-unit id="da26931c5ffe8e8dd904862e9c483d0529d441a2" translate="yes" xml:space="preserve">
          <source>Understand &lt;code&gt;QuerySet&lt;/code&gt;s</source>
          <target state="translated">이해 &lt;code&gt;QuerySet&lt;/code&gt; 들</target>
        </trans-unit>
        <trans-unit id="c640adaa4bcd6100eb85e216fb2751b4f5517a47" translate="yes" xml:space="preserve">
          <source>Understand cached attributes</source>
          <target state="translated">캐시 된 속성 이해</target>
        </trans-unit>
        <trans-unit id="71ed66dcb485624104289d9bd9b4772eda2851af" translate="yes" xml:space="preserve">
          <source>Understanding &lt;a href=&quot;../../ref/models/querysets&quot;&gt;QuerySets&lt;/a&gt; is vital to getting good performance with simple code. In particular:</source>
          <target state="translated">간단한 코드로 좋은 성능을 얻으 &lt;a href=&quot;../../ref/models/querysets&quot;&gt;려면 QuerySets를&lt;/a&gt; 이해해야 합니다. 특히:</target>
        </trans-unit>
        <trans-unit id="44e0564168e9f481eb7d7f8a8e069862f6568044" translate="yes" xml:space="preserve">
          <source>Understanding laziness</source>
          <target state="translated">게으름 이해</target>
        </trans-unit>
        <trans-unit id="03304f96252689acd75d763baef36be1fbc94028" translate="yes" xml:space="preserve">
          <source>Understanding the &lt;code&gt;ManagementForm&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ManagementForm&lt;/code&gt; 이해</target>
        </trans-unit>
        <trans-unit id="3a71d9fcfd423a5cbc8dffae4786be506702c12b" translate="yes" xml:space="preserve">
          <source>Understanding the test output</source>
          <target state="translated">테스트 결과 이해</target>
        </trans-unit>
        <trans-unit id="5116cc56e238056bf43c2a1ee00ef6ef926e36c3" translate="yes" xml:space="preserve">
          <source>Unfortunately, during DST transitions, some datetimes don&amp;rsquo;t exist or are ambiguous. In such situations, &lt;a href=&quot;http://pytz.sourceforge.net/&quot;&gt;pytz&lt;/a&gt; raises an exception. That&amp;rsquo;s why you should always create aware datetime objects when time zone support is enabled.</source>
          <target state="translated">불행하게도 DST 전환 중에 일부 날짜 시간이 존재하지 않거나 모호합니다. 이러한 상황에서 &lt;a href=&quot;http://pytz.sourceforge.net/&quot;&gt;pytz&lt;/a&gt; 는 예외를 발생시킵니다. 따라서 시간대 지원이 활성화 된 경우 항상 인식 가능한 datetime 객체를 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="ca0d2e522969bfd623b1447d12c00e981fbc823f" translate="yes" xml:space="preserve">
          <source>Unfortunately, the shapefile data format does not allow for greater specificity with regards to geometry types. This shapefile, like many others, actually includes &lt;code&gt;MultiPolygon&lt;/code&gt; geometries, not Polygons. It&amp;rsquo;s important to use a more general field type in models: a GeoDjango &lt;code&gt;MultiPolygonField&lt;/code&gt; will accept a &lt;code&gt;Polygon&lt;/code&gt; geometry, but a &lt;code&gt;PolygonField&lt;/code&gt; will not accept a &lt;code&gt;MultiPolygon&lt;/code&gt; type geometry. This is why the &lt;code&gt;WorldBorder&lt;/code&gt; model defined above uses a &lt;code&gt;MultiPolygonField&lt;/code&gt;.</source>
          <target state="translated">불행하게도, shapefile 데이터 형식은 기하학 유형과 관련하여 더 큰 특이성을 허용하지 않습니다. 이 모양 파일은 다른 많은 파일과 마찬가지로 실제로 다각형이 아닌 &lt;code&gt;MultiPolygon&lt;/code&gt; 형상을 포함 합니다. GeoDjango :이 모델에서 더 일반적인 필드 타입을 사용하는 것이 중요 &lt;code&gt;MultiPolygonField&lt;/code&gt; 이 받아 &lt;code&gt;Polygon&lt;/code&gt; 형상을하지만, &lt;code&gt;PolygonField&lt;/code&gt; 은 허용하지 않습니다 &lt;code&gt;MultiPolygon&lt;/code&gt; 유형 형상을. 이것이 위에서 정의한 &lt;code&gt;WorldBorder&lt;/code&gt; 모델이 &lt;code&gt;MultiPolygonField&lt;/code&gt; 를 사용하는 이유 입니다.</target>
        </trans-unit>
        <trans-unit id="b23456ee1564dc412530c13a18ee087c2a31acdd" translate="yes" xml:space="preserve">
          <source>Unfortunately, there isn&amp;rsquo;t a workaround when &lt;a href=&quot;../../ref/models/querysets#django.db.models.query.QuerySet.bulk_create&quot;&gt;&lt;code&gt;creating&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../ref/models/querysets#django.db.models.query.QuerySet.update&quot;&gt;&lt;code&gt;updating&lt;/code&gt;&lt;/a&gt; objects in bulk, since none of &lt;a href=&quot;../../ref/models/instances#django.db.models.Model.save&quot;&gt;&lt;code&gt;save()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../ref/signals#django.db.models.signals.pre_save&quot;&gt;&lt;code&gt;pre_save&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../ref/signals#django.db.models.signals.post_save&quot;&gt;&lt;code&gt;post_save&lt;/code&gt;&lt;/a&gt; are called.</source>
          <target state="translated">불행히도 &lt;a href=&quot;../../ref/models/instances#django.db.models.Model.save&quot;&gt; &lt;code&gt;save()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../ref/signals#django.db.models.signals.pre_save&quot;&gt; &lt;code&gt;pre_save&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../ref/signals#django.db.models.signals.post_save&quot;&gt; &lt;code&gt;post_save&lt;/code&gt; &lt;/a&gt; 가 호출 되지 않기 때문에 대량으로 객체를 &lt;a href=&quot;../../ref/models/querysets#django.db.models.query.QuerySet.bulk_create&quot;&gt; &lt;code&gt;creating&lt;/code&gt; &lt;/a&gt; 거나 &lt;a href=&quot;../../ref/models/querysets#django.db.models.query.QuerySet.update&quot;&gt; &lt;code&gt;updating&lt;/code&gt; &lt;/a&gt; 할 때 해결 방법이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7254fe973cc02ae833e930a145c40e0a25336622" translate="yes" xml:space="preserve">
          <source>Unicode data</source>
          <target state="translated">유니 코드 데이터</target>
        </trans-unit>
        <trans-unit id="24dadab1131ed32d7d7ac91e36aefe2463f2ecdb" translate="yes" xml:space="preserve">
          <source>Unicode in Django</source>
          <target state="translated">장고의 유니 코드</target>
        </trans-unit>
        <trans-unit id="22b1a258da86647a31c614474aeddf831cfa9efb" translate="yes" xml:space="preserve">
          <source>Unioning a set of &lt;a href=&quot;#django.contrib.gis.geos.LineString&quot;&gt;&lt;code&gt;LineString&lt;/code&gt;&lt;/a&gt;s has the effect of fully noding and dissolving the linework.</source>
          <target state="translated">&lt;a href=&quot;#django.contrib.gis.geos.LineString&quot;&gt; &lt;code&gt;LineString&lt;/code&gt; &lt;/a&gt; 세트를 통합 하면 선 작업을 완전히 끄고 녹이는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b30b34da7d8cd3e388c075b09418c024426b9e2c" translate="yes" xml:space="preserve">
          <source>Unioning a set of &lt;a href=&quot;#django.contrib.gis.geos.Polygon&quot;&gt;&lt;code&gt;Polygon&lt;/code&gt;&lt;/a&gt;s will always return a &lt;a href=&quot;#django.contrib.gis.geos.Polygon&quot;&gt;&lt;code&gt;Polygon&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#django.contrib.gis.geos.MultiPolygon&quot;&gt;&lt;code&gt;MultiPolygon&lt;/code&gt;&lt;/a&gt; geometry (unlike &lt;a href=&quot;#django.contrib.gis.geos.GEOSGeometry.union&quot;&gt;&lt;code&gt;GEOSGeometry.union()&lt;/code&gt;&lt;/a&gt;, which may return geometries of lower dimension if a topology collapse occurs).</source>
          <target state="translated">세트 Unioning &lt;a href=&quot;#django.contrib.gis.geos.Polygon&quot;&gt; &lt;code&gt;Polygon&lt;/code&gt; &lt;/a&gt; 항상 반환들 &lt;a href=&quot;#django.contrib.gis.geos.Polygon&quot;&gt; &lt;code&gt;Polygon&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#django.contrib.gis.geos.MultiPolygon&quot;&gt; &lt;code&gt;MultiPolygon&lt;/code&gt; &lt;/a&gt; (달리 형상을 &lt;a href=&quot;#django.contrib.gis.geos.GEOSGeometry.union&quot;&gt; &lt;code&gt;GEOSGeometry.union()&lt;/code&gt; &lt;/a&gt; 토폴로지 붕괴가 발생했을 경우 낮은 차원의 형상을 반환 할 수있는).</target>
        </trans-unit>
        <trans-unit id="76660353a02939d47608b4895f31932c22f7ec9a" translate="yes" xml:space="preserve">
          <source>Unit Attribute</source>
          <target state="translated">단위 속성</target>
        </trans-unit>
        <trans-unit id="5d7ee7381504ec51f518c36b80d6775b2d3f2322" translate="yes" xml:space="preserve">
          <source>Universally unique identifiers are a good alternative to &lt;a href=&quot;#django.db.models.AutoField&quot;&gt;&lt;code&gt;AutoField&lt;/code&gt;&lt;/a&gt; for &lt;a href=&quot;#django.db.models.Field.primary_key&quot;&gt;&lt;code&gt;primary_key&lt;/code&gt;&lt;/a&gt;. The database will not generate the UUID for you, so it is recommended to use &lt;a href=&quot;#django.db.models.Field.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">기본적으로 고유 식별자는 &lt;a href=&quot;#django.db.models.Field.primary_key&quot;&gt; &lt;code&gt;primary_key&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;#django.db.models.AutoField&quot;&gt; &lt;code&gt;AutoField&lt;/code&gt; &lt;/a&gt; 를 대체 할 수있는 좋은 방법 입니다. 데이터베이스는 UUID를 생성하지 않으므로 &lt;a href=&quot;#django.db.models.Field.default&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="038880b22ef1bdad9adbe66638b8b1ff26dfee0b" translate="yes" xml:space="preserve">
          <source>UnixImageIO</source>
          <target state="translated">UnixImageIO</target>
        </trans-unit>
        <trans-unit id="5a219be7c44ca3cb5e3ff711b79016b64fb5c51a" translate="yes" xml:space="preserve">
          <source>Unknown Policy Values</source>
          <target state="translated">알 수없는 정책 값</target>
        </trans-unit>
        <trans-unit id="f1dfafec9d936072f91c136e6ba6640393a092fa" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;#django.db.models.Field.blank&quot;&gt;&lt;code&gt;blank=False&lt;/code&gt;&lt;/a&gt; is set on the field along with a &lt;a href=&quot;#django.db.models.Field.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt; then a label containing &lt;code&gt;&quot;---------&quot;&lt;/code&gt; will be rendered with the select box. To override this behavior, add a tuple to &lt;code&gt;choices&lt;/code&gt; containing &lt;code&gt;None&lt;/code&gt;; e.g. &lt;code&gt;(None, 'Your String For Display')&lt;/code&gt;. Alternatively, you can use an empty string instead of &lt;code&gt;None&lt;/code&gt; where this makes sense - such as on a &lt;a href=&quot;#django.db.models.CharField&quot;&gt;&lt;code&gt;CharField&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#django.db.models.Field.blank&quot;&gt; &lt;code&gt;blank=False&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;#django.db.models.Field.default&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; 과 함께 필드에 설정되어 있지 않으면 &lt;code&gt;&quot;---------&quot;&lt;/code&gt; 가 포함 된 레이블 이 선택 상자와 함께 렌더링됩니다. 이 동작을 무시하려면 &lt;code&gt;None&lt;/code&gt; 을 포함 하는 &lt;code&gt;choices&lt;/code&gt; 튜플을 추가하십시오 . 예 : &lt;code&gt;(None, 'Your String For Display')&lt;/code&gt; . 또는 &lt;a href=&quot;#django.db.models.CharField&quot;&gt; &lt;code&gt;CharField&lt;/code&gt; &lt;/a&gt; 와 같이 의미가없는 경우 &lt;code&gt;None&lt;/code&gt; 대신 빈 문자열을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3db17a7bc41c0f6a22503c839b33446a2279f8d7" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;#django.http.HttpResponse.reason_phrase&quot;&gt;&lt;code&gt;reason_phrase&lt;/code&gt;&lt;/a&gt; is explicitly set, modifying the value of &lt;code&gt;status_code&lt;/code&gt; outside the constructor will also modify the value of &lt;code&gt;reason_phrase&lt;/code&gt;.</source>
          <target state="translated">하지 않는 한 &lt;a href=&quot;#django.http.HttpResponse.reason_phrase&quot;&gt; &lt;code&gt;reason_phrase&lt;/code&gt; 가&lt;/a&gt; 명시 적으로 설정되어, 값 수정 &lt;code&gt;status_code&lt;/code&gt; 생성자 밖에서도의 값이 수정됩니다 &lt;code&gt;reason_phrase&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="c5a806901b6c23e268175e841ca21f60f7306d52" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;#django.http.StreamingHttpResponse.reason_phrase&quot;&gt;&lt;code&gt;reason_phrase&lt;/code&gt;&lt;/a&gt; is explicitly set, modifying the value of &lt;code&gt;status_code&lt;/code&gt; outside the constructor will also modify the value of &lt;code&gt;reason_phrase&lt;/code&gt;.</source>
          <target state="translated">하지 않는 한 &lt;a href=&quot;#django.http.StreamingHttpResponse.reason_phrase&quot;&gt; &lt;code&gt;reason_phrase&lt;/code&gt; 가&lt;/a&gt; 명시 적으로 설정되어, 값 수정 &lt;code&gt;status_code&lt;/code&gt; 생성자 밖에서도의 값이 수정됩니다 &lt;code&gt;reason_phrase&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="1a77a82516c84a4d978cd6360e0a448ebed466e2" translate="yes" xml:space="preserve">
          <source>Unless all of these conditions are met, passing a function to the template is more in line with the design of Jinja2.</source>
          <target state="translated">이러한 모든 조건이 충족되지 않으면 함수를 템플릿에 전달하는 것이 Jinja2의 디자인과 더 일치합니다.</target>
        </trans-unit>
        <trans-unit id="2e89eef1dbfdd4d03c59ddabff36042e6e2785c6" translate="yes" xml:space="preserve">
          <source>Unless explicitly set, &lt;code&gt;reason_phrase&lt;/code&gt; is determined by the value of &lt;a href=&quot;#django.http.HttpResponse.status_code&quot;&gt;&lt;code&gt;status_code&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">명시 적으로 설정되지 않는 한, &lt;code&gt;reason_phrase&lt;/code&gt; 이 값에 의해 결정된다 &lt;a href=&quot;#django.http.HttpResponse.status_code&quot;&gt; &lt;code&gt;status_code&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="444a5339ec993cb3409bdbe5ef891ef8627d9051" translate="yes" xml:space="preserve">
          <source>Unless explicitly set, &lt;code&gt;reason_phrase&lt;/code&gt; is determined by the value of &lt;a href=&quot;#django.http.StreamingHttpResponse.status_code&quot;&gt;&lt;code&gt;status_code&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">명시 적으로 설정되지 않는 한, &lt;code&gt;reason_phrase&lt;/code&gt; 이 값에 의해 결정된다 &lt;a href=&quot;#django.http.StreamingHttpResponse.status_code&quot;&gt; &lt;code&gt;status_code&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3c7876aed78ac30bf32714bf42c71266b74c8a18" translate="yes" xml:space="preserve">
          <source>Unless you are explicitly testing primary keys sequence numbers, it is recommended that you do not hard code primary key values in tests.</source>
          <target state="translated">기본 키 시퀀스 번호를 명시 적으로 테스트하지 않는 한 테스트에서 기본 키 값을 하드 코딩하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="678e810328e4c0a1506ae206987b6432c407477a" translate="yes" xml:space="preserve">
          <source>Unless you&amp;rsquo;re planning to build websites and applications that do nothing but publish content, and don&amp;rsquo;t accept input from your visitors, you&amp;rsquo;re going to need to understand and use forms.</source>
          <target state="translated">컨텐츠 만 게시하고 방문자의 입력을받지 않는 웹 사이트 및 응용 프로그램을 만들 계획이 아니라면 양식을 이해하고 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="5defa9f68e76decb18c25afb5e5d930dca60e719" translate="yes" xml:space="preserve">
          <source>Unless you&amp;rsquo;ve encountered an unusual performance problem in a particular version, you&amp;rsquo;ll generally find better features, reliability, and security in a new release and that these benefits are far more significant than any performance you might win or lose.</source>
          <target state="translated">특정 버전에서 비정상적인 성능 문제가 발생하지 않는 한 일반적으로 새 릴리스에서 더 나은 기능, 안정성 및 보안을 발견 할 수 있으며 이러한 이점은 귀하가 얻거나 잃을 수있는 성능보다 훨씬 중요합니다.</target>
        </trans-unit>
        <trans-unit id="f79b8744b8c2abd594dff4e049086da34b5dfc07" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../../ref/request-response#django.http.HttpResponse&quot;&gt;&lt;code&gt;HttpResponse&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../ref/request-response#django.http.StreamingHttpResponse&quot;&gt;&lt;code&gt;StreamingHttpResponse&lt;/code&gt;&lt;/a&gt; does not have a &lt;code&gt;content&lt;/code&gt; attribute. As a result, middleware can no longer assume that all responses will have a &lt;code&gt;content&lt;/code&gt; attribute. If they need access to the content, they must test for streaming responses and adjust their behavior accordingly:</source>
          <target state="translated">달리 &lt;a href=&quot;../../ref/request-response#django.http.HttpResponse&quot;&gt; &lt;code&gt;HttpResponse&lt;/code&gt; 에&lt;/a&gt; , &lt;a href=&quot;../../ref/request-response#django.http.StreamingHttpResponse&quot;&gt; &lt;code&gt;StreamingHttpResponse&lt;/code&gt; 는&lt;/a&gt; 이없는 &lt;code&gt;content&lt;/code&gt; 속성을. 결과적으로 미들웨어는 더 이상 모든 응답에 &lt;code&gt;content&lt;/code&gt; 속성 이 있다고 가정 할 수 없습니다 . 콘텐츠에 액세스해야하는 경우 스트리밍 응답을 테스트하고 그에 따라 동작을 조정해야합니다.</target>
        </trans-unit>
        <trans-unit id="b0bde4eebaa761807dbdcd55cada3f385b3e217b" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../models/fields#django.db.models.ForeignKey&quot;&gt;&lt;code&gt;ForeignKey&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#django.contrib.contenttypes.fields.GenericForeignKey&quot;&gt;&lt;code&gt;GenericForeignKey&lt;/code&gt;&lt;/a&gt; does not accept an &lt;a href=&quot;../models/fields#django.db.models.ForeignKey.on_delete&quot;&gt;&lt;code&gt;on_delete&lt;/code&gt;&lt;/a&gt; argument to customize this behavior; if desired, you can avoid the cascade-deletion by not using &lt;a href=&quot;#django.contrib.contenttypes.fields.GenericRelation&quot;&gt;&lt;code&gt;GenericRelation&lt;/code&gt;&lt;/a&gt;, and alternate behavior can be provided via the &lt;a href=&quot;../signals#django.db.models.signals.pre_delete&quot;&gt;&lt;code&gt;pre_delete&lt;/code&gt;&lt;/a&gt; signal.</source>
          <target state="translated">달리 &lt;a href=&quot;../models/fields#django.db.models.ForeignKey&quot;&gt; &lt;code&gt;ForeignKey&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#django.contrib.contenttypes.fields.GenericForeignKey&quot;&gt; &lt;code&gt;GenericForeignKey&lt;/code&gt; 는&lt;/a&gt; accept를하지 않습니다 &lt;a href=&quot;../models/fields#django.db.models.ForeignKey.on_delete&quot;&gt; &lt;code&gt;on_delete&lt;/code&gt; &lt;/a&gt; 이 동작을 사용자 정의 인수를; 원하는 경우 &lt;a href=&quot;#django.contrib.contenttypes.fields.GenericRelation&quot;&gt; &lt;code&gt;GenericRelation&lt;/code&gt; 을&lt;/a&gt; 사용하지 않고 계단식 삭제를 피할 수 있으며 &lt;a href=&quot;../signals#django.db.models.signals.pre_delete&quot;&gt; &lt;code&gt;pre_delete&lt;/code&gt; &lt;/a&gt; 신호 를 통해 대체 동작을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b267cd5954155c1cb2e6f98971cc680db6a0833e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;aggregate()&lt;/code&gt;, &lt;code&gt;annotate()&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; a terminal clause. The output of the &lt;code&gt;annotate()&lt;/code&gt; clause is a &lt;code&gt;QuerySet&lt;/code&gt;; this &lt;code&gt;QuerySet&lt;/code&gt; can be modified using any other &lt;code&gt;QuerySet&lt;/code&gt; operation, including &lt;code&gt;filter()&lt;/code&gt;, &lt;code&gt;order_by()&lt;/code&gt;, or even additional calls to &lt;code&gt;annotate()&lt;/code&gt;.</source>
          <target state="translated">달리 &lt;code&gt;aggregate()&lt;/code&gt; , &lt;code&gt;annotate()&lt;/code&gt; 입니다 &lt;em&gt;하지&lt;/em&gt; 터미널 절. &lt;code&gt;annotate()&lt;/code&gt; 절의 출력은 &lt;code&gt;QuerySet&lt;/code&gt; 입니다 . 이 &lt;code&gt;QuerySet&lt;/code&gt; 은 &lt;code&gt;filter()&lt;/code&gt; , &lt;code&gt;order_by()&lt;/code&gt; 또는 &lt;code&gt;annotate()&lt;/code&gt; 추가 호출을 포함한 다른 &lt;code&gt;QuerySet&lt;/code&gt; 작업을 사용하여 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f43101e89ef51ffa185a0a0273d8ef63b36ebfdc" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;login()&lt;/code&gt;, this method skips the authentication and verification steps: inactive users (&lt;a href=&quot;../../ref/contrib/auth#django.contrib.auth.models.User.is_active&quot;&gt;&lt;code&gt;is_active=False&lt;/code&gt;&lt;/a&gt;) are permitted to login and the user&amp;rsquo;s credentials don&amp;rsquo;t need to be provided.</source>
          <target state="translated">&lt;code&gt;login()&lt;/code&gt; 과 달리이 메소드는 인증 및 검증 단계를 건너 뜁니다. 비활성 사용자 ( &lt;a href=&quot;../../ref/contrib/auth#django.contrib.auth.models.User.is_active&quot;&gt; &lt;code&gt;is_active=False&lt;/code&gt; &lt;/a&gt; )는 로그인이 허용되며 사용자의 신임 정보를 제공 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ceb1ea35ebeb0c7749a9a4d72f42387dcf261ba4" translate="yes" xml:space="preserve">
          <source>Unlike other tag utilities, &lt;code&gt;simple_tag&lt;/code&gt; passes its output through &lt;a href=&quot;../ref/utils#django.utils.html.conditional_escape&quot;&gt;&lt;code&gt;conditional_escape()&lt;/code&gt;&lt;/a&gt; if the template context is in autoescape mode, to ensure correct HTML and protect you from XSS vulnerabilities.</source>
          <target state="translated">다른 태그 유틸리티와 달리, &lt;code&gt;simple_tag&lt;/code&gt; 는 템플리트 컨텍스트가 자동 이스케이프 모드 인 경우 &lt;a href=&quot;../ref/utils#django.utils.html.conditional_escape&quot;&gt; &lt;code&gt;conditional_escape()&lt;/code&gt; &lt;/a&gt; 통해 출력을 전달하여 올바른 HTML을 보장하고 XSS 취약성으로부터 사용자를 보호합니다.</target>
        </trans-unit>
        <trans-unit id="54d5ebbcf8813870bdbcd48cd610aec6a10c9221" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;__call__()&lt;/code&gt; method which is called once per request, &lt;code&gt;__init__()&lt;/code&gt; is called only &lt;em&gt;once&lt;/em&gt;, when the Web server starts.</source>
          <target state="translated">요청 당 한 번 호출되는 &lt;code&gt;__call__()&lt;/code&gt; 메서드 와 달리 웹 서버가 시작 &lt;em&gt;되면 &lt;/em&gt; &lt;code&gt;__init__()&lt;/code&gt; 이 &lt;em&gt;한 번만&lt;/em&gt; 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="202025e3309078b14a1181c5cee117b67bb522e3" translate="yes" xml:space="preserve">
          <source>Unlike the hook-type &lt;code&gt;ModelAdmin&lt;/code&gt; methods detailed in the previous section, these five methods are in reality designed to be invoked as Django views from the admin application URL dispatching handler to render the pages that deal with model instances CRUD operations. As a result, completely overriding these methods will significantly change the behavior of the admin application.</source>
          <target state="translated">이전 섹션에서 자세히 설명 된 후크 유형 &lt;code&gt;ModelAdmin&lt;/code&gt; 메소드 와 달리이 5 가지 메소드는 실제로 관리자 애플리케이션 URL 디스패치 핸들러에서 Django보기로 호출되어 모델 인스턴스 CRUD 조작을 처리하는 페이지를 렌더링하도록 설계되었습니다. 결과적으로 이러한 방법을 완전히 재정의하면 관리 응용 프로그램의 동작이 크게 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="7448c48b0e15a159fa8619af49fe604f26c0dd5e" translate="yes" xml:space="preserve">
          <source>Unlike the other request methods, &lt;code&gt;data&lt;/code&gt; is not provided as a keyword parameter in order to comply with &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html#section-4.3.8&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 7231#section-4.3.8&lt;/strong&gt;&lt;/a&gt;, which mandates that TRACE requests must not have a body.</source>
          <target state="translated">다른 요청 방법과 달리 &lt;code&gt;data&lt;/code&gt; 는 TRC 요청에 본문이 없어야하는 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231.html#section-4.3.8&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 7231 # section-4.3.8&lt;/strong&gt;&lt;/a&gt; 을 준수하기 위해 키워드 매개 변수로 제공 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d529120907e93c9b6651314a6b6850d4e61de9fa" translate="yes" xml:space="preserve">
          <source>Unlike your &lt;a href=&quot;../ref/settings#std:setting-SECRET_KEY&quot;&gt;&lt;code&gt;SECRET_KEY&lt;/code&gt;&lt;/a&gt;, your salt argument does not need to stay secret.</source>
          <target state="translated">&lt;a href=&quot;../ref/settings#std:setting-SECRET_KEY&quot;&gt; &lt;code&gt;SECRET_KEY&lt;/code&gt; &lt;/a&gt; 와 달리 소금 인수는 비밀을 유지할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="646567a43dc53e8124c9276136ee0906fa597983" translate="yes" xml:space="preserve">
          <source>Unpacks IPv4 mapped addresses like &lt;code&gt;::ffff:192.0.2.1&lt;/code&gt;. If this option is enabled that address would be unpacked to &lt;code&gt;192.0.2.1&lt;/code&gt;. Default is disabled. Can only be used when &lt;code&gt;protocol&lt;/code&gt; is set to &lt;code&gt;'both'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;::ffff:192.0.2.1&lt;/code&gt; 과 같은 IPv4 매핑 주소의 압축을 풉니 다 . 이 옵션이 활성화되면 해당 주소는 &lt;code&gt;192.0.2.1&lt;/code&gt; 로 압축이 풀 립니다. 기본값은 비활성화입니다. &lt;code&gt;protocol&lt;/code&gt; 이 &lt;code&gt;'both'&lt;/code&gt; 로 설정된 경우에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4b3101b9b97c07dcf8246267009b68d85ce4a3d1" translate="yes" xml:space="preserve">
          <source>Unprotected view needs the CSRF token</source>
          <target state="translated">보호되지 않은보기에는 CSRF 토큰이 필요합니다</target>
        </trans-unit>
        <trans-unit id="a2f7bd457bb79e3ede8fe75e0a7bd5ebce89f31d" translate="yes" xml:space="preserve">
          <source>Unsets the &lt;a href=&quot;../topics/i18n/timezones#default-current-time-zone&quot;&gt;current time zone&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../topics/i18n/timezones#default-current-time-zone&quot;&gt;현재 시간대를&lt;/a&gt; 설정 해제합니다 .</target>
        </trans-unit>
        <trans-unit id="9779aaba6192e6801dfcb0ca30efd16317cb3614" translate="yes" xml:space="preserve">
          <source>Unused (always &lt;code&gt;None&lt;/code&gt;).</source>
          <target state="translated">미사용 (항상 &lt;code&gt;None&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="28f1e198b2b32b5a385660c50f73ada65053f742" translate="yes" xml:space="preserve">
          <source>Up to a certain point, &amp;lsquo;checking that it seems to work&amp;rsquo; will be a satisfactory test. In a more sophisticated application, you might have dozens of complex interactions between components.</source>
          <target state="translated">특정 시점까지 '작동하는 것 확인'은 만족스러운 테스트가 될 것입니다. 보다 복잡한 응용 프로그램에서는 구성 요소간에 수십 개의 복잡한 상호 작용이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd8ace3c2cfc128eba36a48ab3ae7c64274036b6" translate="yes" xml:space="preserve">
          <source>Update in bulk</source>
          <target state="translated">대량 업데이트</target>
        </trans-unit>
        <trans-unit id="d9b7bf87e5ec56f44a8a260b0fcbaca06109aa71" translate="yes" xml:space="preserve">
          <source>Updates the message files for all available languages.</source>
          <target state="translated">사용 가능한 모든 언어의 메시지 파일을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="68a8d10084ae0bebf69893cb99cea9ebe1d09180" translate="yes" xml:space="preserve">
          <source>Updating a &lt;a href=&quot;../../ref/models/fields#django.db.models.ForeignKey&quot;&gt;&lt;code&gt;ForeignKey&lt;/code&gt;&lt;/a&gt; field works exactly the same way as saving a normal field &amp;ndash; assign an object of the right type to the field in question. This example updates the &lt;code&gt;blog&lt;/code&gt; attribute of an &lt;code&gt;Entry&lt;/code&gt; instance &lt;code&gt;entry&lt;/code&gt;, assuming appropriate instances of &lt;code&gt;Entry&lt;/code&gt; and &lt;code&gt;Blog&lt;/code&gt; are already saved to the database (so we can retrieve them below):</source>
          <target state="translated">&lt;a href=&quot;../../ref/models/fields#django.db.models.ForeignKey&quot;&gt; &lt;code&gt;ForeignKey&lt;/code&gt; &lt;/a&gt; 필드를 업데이트하면 일반 필드를 저장하는 것과 동일한 방식으로 작동합니다. 문제의 필드에 올바른 유형의 개체를 할당하십시오. 이 예제 는 &lt;code&gt;Entry&lt;/code&gt; 및 &lt;code&gt;Blog&lt;/code&gt; 의 적절한 인스턴스가 데이터베이스에 이미 저장되어 있다고 가정 하여 &lt;code&gt;Entry&lt;/code&gt; 인스턴스 &lt;code&gt;entry&lt;/code&gt; 의 &lt;code&gt;blog&lt;/code&gt; 속성을 업데이트 합니다 (아래에서 검색 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="a8e7a4750a28eaec5d642cf652d2931c02e5279a" translate="yes" xml:space="preserve">
          <source>Updating a &lt;a href=&quot;../../ref/models/fields#django.db.models.ManyToManyField&quot;&gt;&lt;code&gt;ManyToManyField&lt;/code&gt;&lt;/a&gt; works a little differently &amp;ndash; use the &lt;a href=&quot;../../ref/models/relations#django.db.models.fields.related.RelatedManager.add&quot;&gt;&lt;code&gt;add()&lt;/code&gt;&lt;/a&gt; method on the field to add a record to the relation. This example adds the &lt;code&gt;Author&lt;/code&gt; instance &lt;code&gt;joe&lt;/code&gt; to the &lt;code&gt;entry&lt;/code&gt; object:</source>
          <target state="translated">&lt;a href=&quot;../../ref/models/fields#django.db.models.ManyToManyField&quot;&gt; &lt;code&gt;ManyToManyField&lt;/code&gt; &lt;/a&gt; 업데이트는 약간 다르게 작동합니다 . 필드 에서 &lt;a href=&quot;../../ref/models/relations#django.db.models.fields.related.RelatedManager.add&quot;&gt; &lt;code&gt;add()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 관계에 레코드를 추가하십시오. 이 예제는 &lt;code&gt;Author&lt;/code&gt; 인스턴스 &lt;code&gt;joe&lt;/code&gt; 를 &lt;code&gt;entry&lt;/code&gt; 오브젝트에 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="1e57f159716031e6de627e9ebc5a07d01ac49262" translate="yes" xml:space="preserve">
          <source>Updating all migrations that depend on the deleted migrations to depend on the squashed migration instead.</source>
          <target state="translated">삭제 된 마이그레이션에 의존하는 모든 마이그레이션을 스쿼시 마이그레이션에 대신 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="7b598ffb6a2d08a645946f7901a024fcf5f394b6" translate="yes" xml:space="preserve">
          <source>Updating attributes based on existing fields</source>
          <target state="translated">기존 필드를 기반으로 속성 업데이트</target>
        </trans-unit>
        <trans-unit id="7ae75eae246f9db307b0995fd2b4d26ecb167f67" translate="yes" xml:space="preserve">
          <source>Updating fields defined on multi-table inheritance ancestors will incur an extra query per ancestor.</source>
          <target state="translated">다중 테이블 상속 조상에 정의 된 필드를 업데이트하면 조상마다 추가 쿼리가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f5eb7efc8341ac4fc061ce26a06c4f9477c26414" translate="yes" xml:space="preserve">
          <source>Updating multiple objects at once</source>
          <target state="translated">여러 객체를 한 번에 업데이트</target>
        </trans-unit>
        <trans-unit id="62ab655a1d6efe8beca16e6191378d2648f74add" translate="yes" xml:space="preserve">
          <source>Upgrading Django to a newer version</source>
          <target state="translated">장고를 최신 버전으로 업그레이드</target>
        </trans-unit>
        <trans-unit id="46a4bffa218165f20eb2c6cad688e95301db67ea" translate="yes" xml:space="preserve">
          <source>Upgrading as each new Django release is available makes future upgrades less painful by keeping your code base up to date.</source>
          <target state="translated">각각의 새로운 Django 릴리스가 출시 될 때마다 업그레이드하면 코드 기반을 최신 상태로 유지하여 향후 업그레이드가 덜 어려워집니다.</target>
        </trans-unit>
        <trans-unit id="05d94a7523b73b5252283606a582bc13a2aa41e6" translate="yes" xml:space="preserve">
          <source>Upgrading pre-Django 1.10-style middleware</source>
          <target state="translated">장고 1.10 스타일 미들웨어 업그레이드</target>
        </trans-unit>
        <trans-unit id="f7b48108d745155b7ecc0b26e195e1cf984e3128" translate="yes" xml:space="preserve">
          <source>Upload Handlers</source>
          <target state="translated">처리기 업로드</target>
        </trans-unit>
        <trans-unit id="18c3f0d628afcda47eae72f604c2cbb8fe852d42" translate="yes" xml:space="preserve">
          <source>Upload handler that streams data into a temporary file using &lt;a href=&quot;#django.core.files.uploadedfile.TemporaryUploadedFile&quot;&gt;&lt;code&gt;TemporaryUploadedFile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#django.core.files.uploadedfile.TemporaryUploadedFile&quot;&gt; &lt;code&gt;TemporaryUploadedFile&lt;/code&gt; 을&lt;/a&gt; 사용하여 데이터를 임시 파일로 스트리밍하는 업로드 핸들러입니다 .</target>
        </trans-unit>
        <trans-unit id="dd142961ffce6aae336b913b089bda434f9de101" translate="yes" xml:space="preserve">
          <source>Upload the package on your website.</source>
          <target state="translated">웹 사이트에 패키지를 업로드하십시오.</target>
        </trans-unit>
        <trans-unit id="8007dda7676e7989647bad361adfb846332bd4ab" translate="yes" xml:space="preserve">
          <source>Uploaded Files and Upload Handlers</source>
          <target state="translated">업로드 된 파일 및 업로드 핸들러</target>
        </trans-unit>
        <trans-unit id="96523b9ddbe4851dbc40cbb0a21acda23b6ea9b0" translate="yes" xml:space="preserve">
          <source>Uploaded files</source>
          <target state="translated">업로드 된 파일</target>
        </trans-unit>
        <trans-unit id="184646850e7101f37ef2ae2d3067a13d69ba40dc" translate="yes" xml:space="preserve">
          <source>Uploading multiple files</source>
          <target state="translated">여러 파일 업로드</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="fec43ce445f974147bd0eb223a50147e7fb7202d" translate="yes" xml:space="preserve">
          <source>Usage example:</source>
          <target state="translated">사용 예 :</target>
        </trans-unit>
        <trans-unit id="950d9c1aee5a0b8ac1664c8a9f40a8cddde14c8b" translate="yes" xml:space="preserve">
          <source>Usage examples</source>
          <target state="translated">사용 예</target>
        </trans-unit>
        <trans-unit id="173610cb31251b28e80fadc258036215d99d7128" translate="yes" xml:space="preserve">
          <source>Usage examples:</source>
          <target state="translated">사용 예 :</target>
        </trans-unit>
        <trans-unit id="3ff0224034c5075c4d17ea1e9764c2fb807106e5" translate="yes" xml:space="preserve">
          <source>Usage in your URLconf</source>
          <target state="translated">URLconf에서의 사용법</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="fec36d5334003297df655c134a6c111aba4c201a" translate="yes" xml:space="preserve">
          <source>Use &amp;lsquo;secure&amp;rsquo; cookies.</source>
          <target state="translated">'보안'쿠키를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b88ea17862a7a6c14914e5065dd7470d56000b4f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#cmdoption-verbosity&quot;&gt;&lt;code&gt;--verbosity&lt;/code&gt;&lt;/a&gt; to specify the amount of notification and debug information that &lt;code&gt;django-admin&lt;/code&gt; prints to the console.</source>
          <target state="translated">&lt;code&gt;django-admin&lt;/code&gt; 이 콘솔에 인쇄 하는 알림 및 디버그 정보의 양을 지정 하려면 &lt;a href=&quot;#cmdoption-verbosity&quot;&gt; &lt;code&gt;--verbosity&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5707b3a7949cc072230b7fe1e71e763576d50451" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#django.contrib.auth.authenticate&quot;&gt;&lt;code&gt;authenticate()&lt;/code&gt;&lt;/a&gt; to verify a set of credentials. It takes credentials as keyword arguments, &lt;code&gt;username&lt;/code&gt; and &lt;code&gt;password&lt;/code&gt; for the default case, checks them against each &lt;a href=&quot;customizing#authentication-backends&quot;&gt;authentication backend&lt;/a&gt;, and returns a &lt;a href=&quot;../../ref/contrib/auth#django.contrib.auth.models.User&quot;&gt;&lt;code&gt;User&lt;/code&gt;&lt;/a&gt; object if the credentials are valid for a backend. If the credentials aren&amp;rsquo;t valid for any backend or if a backend raises &lt;a href=&quot;../../ref/exceptions#django.core.exceptions.PermissionDenied&quot;&gt;&lt;code&gt;PermissionDenied&lt;/code&gt;&lt;/a&gt;, it returns &lt;code&gt;None&lt;/code&gt;. For example:</source>
          <target state="translated">사용하여 &lt;a href=&quot;#django.contrib.auth.authenticate&quot;&gt; &lt;code&gt;authenticate()&lt;/code&gt; &lt;/a&gt; 자격 증명 집합을 확인 할 수 있습니다. 자격 증명은 키워드 인수, 기본 &lt;code&gt;username&lt;/code&gt; 및 &lt;code&gt;password&lt;/code&gt; 로 기본 &lt;a href=&quot;customizing#authentication-backends&quot;&gt;인증 백엔드&lt;/a&gt; 에 대해 확인하고 자격 증명이 백엔드에 유효한 경우 &lt;a href=&quot;../../ref/contrib/auth#django.contrib.auth.models.User&quot;&gt; &lt;code&gt;User&lt;/code&gt; &lt;/a&gt; 객체를 반환합니다 . 자격 증명이 백엔드에 유효하지 않거나 백엔드가 &lt;a href=&quot;../../ref/exceptions#django.core.exceptions.PermissionDenied&quot;&gt; &lt;code&gt;PermissionDenied&lt;/code&gt; 를&lt;/a&gt; 올리면 &lt;code&gt;None&lt;/code&gt; 을 반환합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="faa6d9f7f8e0a5e0ca7a29abd763d5e935b14263" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#django.contrib.gis.utils.LayerMapping&quot;&gt;&lt;code&gt;LayerMapping&lt;/code&gt;&lt;/a&gt; to extract all the features and place them in the database:</source>
          <target state="translated">&lt;a href=&quot;#django.contrib.gis.utils.LayerMapping&quot;&gt; &lt;code&gt;LayerMapping&lt;/code&gt; &lt;/a&gt; 을 사용 하여 모든 기능을 추출하고 데이터베이스에 배치하십시오.</target>
        </trans-unit>
        <trans-unit id="b8b2029e079f8927cefb4c2e337ab8a65848b660" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#django.contrib.sites.managers.CurrentSiteManager&quot;&gt;&lt;code&gt;CurrentSiteManager&lt;/code&gt;&lt;/a&gt; by adding it to your model explicitly. For example:</source>
          <target state="translated">&lt;a href=&quot;#django.contrib.sites.managers.CurrentSiteManager&quot;&gt; &lt;code&gt;CurrentSiteManager&lt;/code&gt; &lt;/a&gt; 를 모델에 명시 적으로 추가하여 사용하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eabc3f3ec2fd97c8a006e18a6962ea0f30a4edde" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#django.forms.Form.get_initial_for_field&quot;&gt;&lt;code&gt;get_initial_for_field()&lt;/code&gt;&lt;/a&gt; to retrieve initial data for a form field. It retrieves data from &lt;a href=&quot;#django.forms.Form.initial&quot;&gt;&lt;code&gt;Form.initial&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fields#django.forms.Field.initial&quot;&gt;&lt;code&gt;Field.initial&lt;/code&gt;&lt;/a&gt;, in that order, and evaluates any callable initial values.</source>
          <target state="translated">&lt;a href=&quot;#django.forms.Form.get_initial_for_field&quot;&gt; &lt;code&gt;get_initial_for_field()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 양식 필드의 초기 데이터를 검색 하십시오 . &lt;a href=&quot;#django.forms.Form.initial&quot;&gt; &lt;code&gt;Form.initial&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;fields#django.forms.Field.initial&quot;&gt; &lt;code&gt;Field.initial&lt;/code&gt; &lt;/a&gt; 에서 순서대로 데이터를 검색 하고 호출 가능한 초기 값을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="67b7653ccb00ad1f07983205fa648a2da3bc1a79" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#django.forms.Form.initial&quot;&gt;&lt;code&gt;initial&lt;/code&gt;&lt;/a&gt; to declare the initial value of form fields at runtime. For example, you might want to fill in a &lt;code&gt;username&lt;/code&gt; field with the username of the current session.</source>
          <target state="translated">런타임시 양식 필드의 초기 값을 선언 하려면 &lt;a href=&quot;#django.forms.Form.initial&quot;&gt; &lt;code&gt;initial&lt;/code&gt; &lt;/a&gt; 을 사용하십시오 . 예를 들어, 현재 세션의 사용자 이름으로 &lt;code&gt;username&lt;/code&gt; 필드 를 채울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a115779617d9a80d8bced3b6f45fe8aa24508a8d" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../../ref/models/expressions#django.db.models.F&quot;&gt;&lt;code&gt;F expressions&lt;/code&gt;&lt;/a&gt; to filter based on other fields within the same model.</source>
          <target state="translated">동일한 모델 내 다른 필드를 기준으로 필터링 하려면 &lt;a href=&quot;../../ref/models/expressions#django.db.models.F&quot;&gt; &lt;code&gt;F expressions&lt;/code&gt; &lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="02e5b5e781f26d3896200a3fedaffd73434d32fd" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../../ref/models/querysets#django.db.models.query.QuerySet.defer&quot;&gt;&lt;code&gt;defer()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../ref/models/querysets#django.db.models.query.QuerySet.only&quot;&gt;&lt;code&gt;only()&lt;/code&gt;&lt;/a&gt; if there are database columns you know that you won&amp;rsquo;t need (or won&amp;rsquo;t need in most cases) to avoid loading them. Note that if you &lt;em&gt;do&lt;/em&gt; use them, the ORM will have to go and get them in a separate query, making this a pessimization if you use it inappropriately.</source>
          <target state="translated">로드를 피하기 위해 필요하지 않거나 대부분의 경우 필요하지 않은 데이터베이스 열이있는 경우 &lt;a href=&quot;../../ref/models/querysets#django.db.models.query.QuerySet.defer&quot;&gt; &lt;code&gt;defer()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../ref/models/querysets#django.db.models.query.QuerySet.only&quot;&gt; &lt;code&gt;only()&lt;/code&gt; &lt;/a&gt; 사용하십시오 . 당신이 경우주의 &lt;em&gt;할&lt;/em&gt; 을 사용하여 ORM 당신이 부적절하게 사용할 경우 이것을 pessimization을 가서 별도의 질의에 그들을 얻을해야합니다.</target>
        </trans-unit>
        <trans-unit id="a7ebce217ada5930342b97afbff9c6a1d7a61384" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../../topics/i18n/translation#std:templatetag-blocktrans&quot;&gt;&lt;code&gt;blocktrans&lt;/code&gt;&lt;/a&gt; to pluralize translated strings.</source>
          <target state="translated">번역 된 문자열을 복수화 하려면 &lt;a href=&quot;../../topics/i18n/translation#std:templatetag-blocktrans&quot;&gt; &lt;code&gt;blocktrans&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf6137c66ab9c8f60411f6806750837507be1304" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../ref/middleware#http-strict-transport-security&quot;&gt;HTTP Strict Transport Security&lt;/a&gt; (HSTS)</source>
          <target state="translated">사용 &lt;a href=&quot;../ref/middleware#http-strict-transport-security&quot;&gt;HTTP 엄격한 전송 보안&lt;/a&gt; (HSTS를)</target>
        </trans-unit>
        <trans-unit id="425757bec238aca8c7f19955c39460f9752fea04" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;aggregation&quot;&gt;annotate to do aggregation in the database&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;aggregation&quot;&gt;데이터베이스에서 집계를 수행&lt;/a&gt; 하려면 주석을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="43bcd1ae26176a1479c056894d22162dbac7d218" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;constraints#django.db.models.UniqueConstraint&quot;&gt;&lt;code&gt;UniqueConstraint&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;#django.db.models.Options.constraints&quot;&gt;&lt;code&gt;constraints&lt;/code&gt;&lt;/a&gt; option instead.</source>
          <target state="translated">대신 &lt;a href=&quot;#django.db.models.Options.constraints&quot;&gt; &lt;code&gt;constraints&lt;/code&gt; &lt;/a&gt; 옵션 과 함께 &lt;a href=&quot;constraints#django.db.models.UniqueConstraint&quot;&gt; &lt;code&gt;UniqueConstraint&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="673bdba6a222578611d0a288f5ec5b900c3656f2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;F()&lt;/code&gt; and the &lt;code&gt;nulls_first&lt;/code&gt; or &lt;code&gt;nulls_last&lt;/code&gt; keyword argument to &lt;a href=&quot;#django.db.models.Expression.asc&quot;&gt;&lt;code&gt;Expression.asc()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#django.db.models.Expression.desc&quot;&gt;&lt;code&gt;desc()&lt;/code&gt;&lt;/a&gt; to control the ordering of a field&amp;rsquo;s null values. By default, the ordering depends on your database.</source>
          <target state="translated">사용 &lt;code&gt;F()&lt;/code&gt; 와 &lt;code&gt;nulls_first&lt;/code&gt; 또는 &lt;code&gt;nulls_last&lt;/code&gt; 키워드에 인수 &lt;a href=&quot;#django.db.models.Expression.asc&quot;&gt; &lt;code&gt;Expression.asc()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#django.db.models.Expression.desc&quot;&gt; &lt;code&gt;desc()&lt;/code&gt; &lt;/a&gt; 필드의 널 (null) 값의 순서를 제어 할 수 있습니다. 기본적으로 순서는 데이터베이스에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a431ca1748877571cbf4c61df7ba6ea2350ba7ff" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;MultiEmailField&lt;/code&gt; like any other form field. When the &lt;code&gt;is_valid()&lt;/code&gt; method is called on the form, the &lt;code&gt;MultiEmailField.clean()&lt;/code&gt; method will be run as part of the cleaning process and it will, in turn, call the custom &lt;code&gt;to_python()&lt;/code&gt; and &lt;code&gt;validate()&lt;/code&gt; methods.</source>
          <target state="translated">다른 양식 필드와 마찬가지로 &lt;code&gt;MultiEmailField&lt;/code&gt; 를 사용하십시오 . 때 &lt;code&gt;is_valid()&lt;/code&gt; 메소드가 양식에 호출되면 &lt;code&gt;MultiEmailField.clean()&lt;/code&gt; 메소드는 청소 프로세스의 일부로 실행됩니다 그것은, 차례로, 사용자 정의 호출합니다 &lt;code&gt;to_python()&lt;/code&gt; 및 &lt;code&gt;validate()&lt;/code&gt; 메소드.</target>
        </trans-unit>
        <trans-unit id="73dfa9df450263eee20a485f1cee8b25c4267cbf" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;OuterRef&lt;/code&gt; when a queryset in a &lt;code&gt;Subquery&lt;/code&gt; needs to refer to a field from the outer query. It acts like an &lt;a href=&quot;#django.db.models.F&quot;&gt;&lt;code&gt;F&lt;/code&gt;&lt;/a&gt; expression except that the check to see if it refers to a valid field isn&amp;rsquo;t made until the outer queryset is resolved.</source>
          <target state="translated">&lt;code&gt;Subquery&lt;/code&gt; 의 쿼리 &lt;code&gt;OuterRef&lt;/code&gt; 이 외부 쿼리의 필드를 참조 해야하는 경우 OuterRef를 사용 하십시오. 외부 쿼리 셋이 해결 될 때까지 유효한 필드가 참조되는지 확인하는 것을 제외하고 는 &lt;a href=&quot;#django.db.models.F&quot;&gt; &lt;code&gt;F&lt;/code&gt; &lt;/a&gt; 표현식 처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="89f3f8ce3f4a6a927b77694be46ffaa70b2a1af3" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;QuerySet.count()&lt;/code&gt;</source>
          <target state="translated">사용 &lt;code&gt;QuerySet.count()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8215431606919c07a39ea4ee01eb6193038c5f6a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;QuerySet.defer()&lt;/code&gt; and &lt;code&gt;only()&lt;/code&gt;</source>
          <target state="translated">사용 &lt;code&gt;QuerySet.defer()&lt;/code&gt; 및 &lt;code&gt;only()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="38e324fb9baf782813621cb43f1170931e8418f2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;QuerySet.exists()&lt;/code&gt;</source>
          <target state="translated">사용 &lt;code&gt;QuerySet.exists()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e205b5dd8f99b942ca1134ca580322ffd0800b21" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;QuerySet.select_related()&lt;/code&gt; and &lt;code&gt;prefetch_related()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;QuerySet.select_related()&lt;/code&gt; 및 &lt;code&gt;prefetch_related()&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6f15950f279fea65601a40f674ab6995cadb1dea" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;QuerySet.update()&lt;/code&gt; and &lt;code&gt;delete()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;QuerySet.update()&lt;/code&gt; 및 &lt;code&gt;delete()&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6946ee8fcbac1d731f74e4e7337c8fdfcc1dc24b" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;QuerySet.values()&lt;/code&gt; and &lt;code&gt;values_list()&lt;/code&gt;</source>
          <target state="translated">사용 &lt;code&gt;QuerySet.values()&lt;/code&gt; 및 &lt;code&gt;values_list()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="147814ea5cc7235ff99a4852324abde1ca2308d3" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;RawSQL&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;RawSQL&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="49a9d4f189179c274ac18fdbf300b78cd384ad75" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;alters_data&lt;/code&gt; where appropriate</source>
          <target state="translated">적절한 경우 &lt;code&gt;alters_data&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="28219df422141245465188f8b0c9a06afcdf36c6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;condition&lt;/code&gt; when testing both conditions</source>
          <target state="translated">두 가지 조건을 테스트 할 때 사용 &lt;code&gt;condition&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2ebedbe3df550f0423eae393d1b0c0c03fa68aed" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;domain&lt;/code&gt; if you want to set a cross-domain cookie. For example, &lt;code&gt;domain=&quot;example.com&quot;&lt;/code&gt; will set a cookie that is readable by the domains www.example.com, blog.example.com, etc. Otherwise, a cookie will only be readable by the domain that set it.</source>
          <target state="translated">&lt;code&gt;domain&lt;/code&gt; 간 쿠키를 설정 하려면 도메인을 사용하십시오 . 예를 들어 &lt;code&gt;domain=&quot;example.com&quot;&lt;/code&gt; 은 도메인 www.example.com, blog.example.com 등이 읽을 수있는 쿠키를 설정합니다. 그렇지 않으면 쿠키는 쿠키를 설정 한 도메인에서만 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2cba934b1b1094982655d010aa56fde400c6c7b" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;explain()&lt;/code&gt;</source>
          <target state="translated">사용 &lt;code&gt;explain()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c5ad41fcd7b19417f7cc2f56d695fd8d0b93ee38" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;force_str()&lt;/code&gt; in preference to &lt;code&gt;smart_str()&lt;/code&gt; in these places. Tag rendering and filter calls occur as the template is being rendered, so there is no advantage to postponing the conversion of lazy translation objects into strings. It&amp;rsquo;s easier to work solely with strings at that point.</source>
          <target state="translated">이러한 장소에서는 &lt;code&gt;smart_str()&lt;/code&gt; 보다 &lt;code&gt;force_str()&lt;/code&gt; 을 사용하십시오 . 템플릿이 렌더링 될 때 태그 렌더링 및 필터 호출이 발생하므로 지연 변환 객체를 문자열로 변환하는 기능을 연기 할 수 없습니다. 그 시점에서 문자열로만 작업하는 것이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="4a6663e350ecc6b0449be40f8da20b9d7d95a7e3" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;httponly=True&lt;/code&gt; if you want to prevent client-side JavaScript from having access to the cookie.</source>
          <target state="translated">클라이언트 측 JavaScript가 쿠키에 액세스하지 못하게 하려면 &lt;code&gt;httponly=True&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c78ed189dc1baa114964d1295b64425b5c52765c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;iterator()&lt;/code&gt;</source>
          <target state="translated">사용 &lt;code&gt;iterator()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9213d5b1a951ca202f1c25340fb468f74b4053ef" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;list_display_links&lt;/code&gt; to control if and which fields in &lt;a href=&quot;#django.contrib.admin.ModelAdmin.list_display&quot;&gt;&lt;code&gt;list_display&lt;/code&gt;&lt;/a&gt; should be linked to the &amp;ldquo;change&amp;rdquo; page for an object.</source>
          <target state="translated">사용 &lt;code&gt;list_display_links&lt;/code&gt; 제어는 경우 필드 &lt;a href=&quot;#django.contrib.admin.ModelAdmin.list_display&quot;&gt; &lt;code&gt;list_display&lt;/code&gt; 는&lt;/a&gt; 개체의 &quot;변화&quot;페이지에 링크해야합니다.</target>
        </trans-unit>
        <trans-unit id="1bc5d05f5409556416ced1c1d82b7a1ccd5dc47b" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ogrinfo&lt;/code&gt; to examine spatial data</source>
          <target state="translated">&lt;code&gt;ogrinfo&lt;/code&gt; 를 사용 하여 공간 데이터 검사</target>
        </trans-unit>
        <trans-unit id="2426b3cdda0816d837536846ea97140289d9e4e0" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;samesite='Strict'&lt;/code&gt; or &lt;code&gt;samesite='Lax'&lt;/code&gt; to tell the browser not to send this cookie when performing a cross-origin request. &lt;a href=&quot;https://www.owasp.org/index.php/SameSite&quot;&gt;SameSite&lt;/a&gt; isn&amp;rsquo;t supported by all browsers, so it&amp;rsquo;s not a replacement for Django&amp;rsquo;s CSRF protection, but rather a defense in depth measure.</source>
          <target state="translated">교차 출처 요청을 수행 할 때 브라우저에이 쿠키를 보내지 않도록 브라우저에 알리려면 &lt;code&gt;samesite='Strict'&lt;/code&gt; 또는 &lt;code&gt;samesite='Lax'&lt;/code&gt; 를 사용하십시오 . &lt;a href=&quot;https://www.owasp.org/index.php/SameSite&quot;&gt;SameSite&lt;/a&gt; 는 모든 브라우저에서 지원되지 않으므로 Django의 CSRF 보호를 대체하는 것이 아니라 심층 방어를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="771c2d91047462c6aa10efae966845132574bd34" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;secure=True&lt;/code&gt; if you want the cookie to be only sent to the server when a request is made with the &lt;code&gt;https&lt;/code&gt; scheme.</source>
          <target state="translated">&lt;code&gt;https&lt;/code&gt; 체계 로 요청을 할 때 쿠키를 서버로만 보내려면 &lt;code&gt;secure=True&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c5c0671a0be6041e5f1d3866fb7667e4202e512d" translate="yes" xml:space="preserve">
          <source>Use Cases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c464023f52c6a7bc1e7e39151d666b9b2888a42" translate="yes" xml:space="preserve">
          <source>Use Django&amp;rsquo;s test client to establish that the correct template is being rendered and that the template is passed the correct context data.</source>
          <target state="translated">Django의 테스트 클라이언트를 사용하여 올바른 템플릿이 렌더링되고 템플릿에 올바른 컨텍스트 데이터가 전달되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c7f9bb01a81fa04cc6857cf3f16846e6964d79eb" translate="yes" xml:space="preserve">
          <source>Use a comma separated list of OGR field names to add the &lt;code&gt;blank=True&lt;/code&gt; keyword option to the field definition. Set with &lt;code&gt;true&lt;/code&gt; to apply to all applicable fields.</source>
          <target state="translated">쉼표로 구분 된 OGR 필드 이름 목록을 사용하여 &lt;code&gt;blank=True&lt;/code&gt; 키워드 옵션을 필드 정의 에 추가하십시오 . 적용 가능한 모든 필드에 적용하려면 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="13fd6dc8b13cffcb7da66d455a2d1979aa29213e" translate="yes" xml:space="preserve">
          <source>Use a comma separated list of OGR field names to add the &lt;code&gt;null=True&lt;/code&gt; keyword option to the field definition. Set with &lt;code&gt;true&lt;/code&gt; to apply to all applicable fields.</source>
          <target state="translated">쉼표로 구분 된 OGR 필드 이름 목록을 사용 하여 필드 정의에 &lt;code&gt;null=True&lt;/code&gt; 키워드 옵션을 추가하십시오 . 적용 가능한 모든 필드에 적용하려면 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="36f7c9e9d0df5297ad93cb8b17f1c7c0e8a1c1b0" translate="yes" xml:space="preserve">
          <source>Use a comma separated list of OGR float fields to generate &lt;a href=&quot;../../models/fields#django.db.models.DecimalField&quot;&gt;&lt;code&gt;DecimalField&lt;/code&gt;&lt;/a&gt; instead of the default &lt;a href=&quot;../../models/fields#django.db.models.FloatField&quot;&gt;&lt;code&gt;FloatField&lt;/code&gt;&lt;/a&gt;. Set to &lt;code&gt;true&lt;/code&gt; to apply to all OGR float fields.</source>
          <target state="translated">쉼표로 구분 된 OGR 부동 필드 목록을 사용 하여 기본 &lt;a href=&quot;../../models/fields#django.db.models.FloatField&quot;&gt; &lt;code&gt;FloatField&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;../../models/fields#django.db.models.DecimalField&quot;&gt; &lt;code&gt;DecimalField&lt;/code&gt; &lt;/a&gt; 를 생성 하십시오 . 모든 OGR 부동 필드에 적용 하려면 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d3904e3ba5481071c26a0eb472b6a7d17bd7ed2" translate="yes" xml:space="preserve">
          <source>Use a dot (&lt;code&gt;.&lt;/code&gt;) to access attributes of a variable.</source>
          <target state="translated">점 ( &lt;code&gt;.&lt;/code&gt; )을 사용하여 변수의 속성에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="6eb1215cc5d44336b81b57e644156b179a8da43c" translate="yes" xml:space="preserve">
          <source>Use a subset of Python&amp;rsquo;s array-slicing syntax to limit your &lt;a href=&quot;../../ref/models/querysets#django.db.models.query.QuerySet&quot;&gt;&lt;code&gt;QuerySet&lt;/code&gt;&lt;/a&gt; to a certain number of results. This is the equivalent of SQL&amp;rsquo;s &lt;code&gt;LIMIT&lt;/code&gt; and &lt;code&gt;OFFSET&lt;/code&gt; clauses.</source>
          <target state="translated">Python의 배열 분할 구문의 하위 집합을 사용하여 &lt;a href=&quot;../../ref/models/querysets#django.db.models.query.QuerySet&quot;&gt; &lt;code&gt;QuerySet&lt;/code&gt; &lt;/a&gt; 을 특정 수의 결과 로 제한하십시오 . 이는 SQL의 &lt;code&gt;LIMIT&lt;/code&gt; 및 &lt;code&gt;OFFSET&lt;/code&gt; 절 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="47dcd88a250016a33b6a0e274696acbfb243015e" translate="yes" xml:space="preserve">
          <source>Use a web server of your choice to serve the files. &lt;a href=&quot;deployment&quot;&gt;Deploying static files&lt;/a&gt; covers some common deployment strategies for static files.</source>
          <target state="translated">선택한 웹 서버를 사용하여 파일을 제공하십시오. &lt;a href=&quot;deployment&quot;&gt;정적 파일 배포에는 정적 파일에&lt;/a&gt; 대한 몇 가지 일반적인 배포 전략이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="71475c2e9781cedd3ba308fda2b976cdb0297ba9" translate="yes" xml:space="preserve">
          <source>Use an &lt;code&gt;Alias&lt;/code&gt; directive, as demonstrated above, to alias the appropriate URL (probably &lt;a href=&quot;../../../ref/settings#std:setting-STATIC_URL&quot;&gt;&lt;code&gt;STATIC_URL&lt;/code&gt;&lt;/a&gt; + &lt;code&gt;admin/&lt;/code&gt;) to the actual location of the admin files.</source>
          <target state="translated">위에서 설명한대로 &lt;code&gt;Alias&lt;/code&gt; 지시문을 사용 하여 적절한 URL (아마도 &lt;a href=&quot;../../../ref/settings#std:setting-STATIC_URL&quot;&gt; &lt;code&gt;STATIC_URL&lt;/code&gt; &lt;/a&gt; + &lt;code&gt;admin/&lt;/code&gt; )을 관리자 파일의 실제 위치에 별칭으로 지정 하십시오.</target>
        </trans-unit>
        <trans-unit id="237ebf3a163bef9aa3fb50dced0002df72a644d8" translate="yes" xml:space="preserve">
          <source>Use bulk methods</source>
          <target state="translated">대량 방법 사용</target>
        </trans-unit>
        <trans-unit id="e2ad887cdae670908c696d1bffcce9331b73a201" translate="yes" xml:space="preserve">
          <source>Use bulk methods to reduce the number of SQL statements.</source>
          <target state="translated">벌크 메소드를 사용하여 SQL 문 수를 줄이십시오.</target>
        </trans-unit>
        <trans-unit id="a92a268cbbb61d3b1bd3e7383548f34ce09d080e" translate="yes" xml:space="preserve">
          <source>Use foreign key values directly</source>
          <target state="translated">외래 키 값을 직접 사용</target>
        </trans-unit>
        <trans-unit id="674e22f8e4da7fd026af00605b3af864518826eb" translate="yes" xml:space="preserve">
          <source>Use generic views: Less code is better</source>
          <target state="translated">일반 뷰 사용 : 코드가 적을수록 좋습니다</target>
        </trans-unit>
        <trans-unit id="7fa9129374a97fe179ff72417908f6ac11cdecfe" translate="yes" xml:space="preserve">
          <source>Use in tests</source>
          <target state="translated">테스트에 사용</target>
        </trans-unit>
        <trans-unit id="468ce6248630a798b80e9ce0a6e864a558940ec0" translate="yes" xml:space="preserve">
          <source>Use in-browser frameworks like &lt;a href=&quot;http://seleniumhq.org/&quot;&gt;Selenium&lt;/a&gt; to test &lt;em&gt;rendered&lt;/em&gt; HTML and the &lt;em&gt;behavior&lt;/em&gt; of Web pages, namely JavaScript functionality. Django also provides special support for those frameworks; see the section on &lt;a href=&quot;#django.test.LiveServerTestCase&quot;&gt;&lt;code&gt;LiveServerTestCase&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;a href=&quot;http://seleniumhq.org/&quot;&gt;Selenium&lt;/a&gt; 과 같은 브라우저 내 프레임 워크를 사용하여 &lt;em&gt;렌더링 된&lt;/em&gt; HTML 및 웹 페이지 의 &lt;em&gt;동작 (&lt;/em&gt; 예 : JavaScript 기능) 을 테스트 하십시오 . Django는 이러한 프레임 워크에 대한 특별한 지원도 제공합니다. 자세한 내용 은 &lt;a href=&quot;#django.test.LiveServerTestCase&quot;&gt; &lt;code&gt;LiveServerTestCase&lt;/code&gt; &lt;/a&gt; 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="db7f07507027eede9790c3fae489d053cb736298" translate="yes" xml:space="preserve">
          <source>Use it if your single Django installation powers more than one site and you need to differentiate between those sites in some way.</source>
          <target state="translated">단일 Django 설치로 둘 이상의 사이트를 구동하고 어떤 방식으로 해당 사이트를 구별해야하는 경우에 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6cbb4767566e4dcaa84e686249abc74932215302" translate="yes" xml:space="preserve">
          <source>Use lowercase table names for MariaDB and MySQL</source>
          <target state="translated">MariaDB 및 MySQL에 소문자 테이블 이름 사용</target>
        </trans-unit>
        <trans-unit id="4bc2e22dd4f2f8998f1464d31b56aa90fedd6e89" translate="yes" xml:space="preserve">
          <source>Use mapping keys instead of positional formatting. This enables putting the variables in any order or omitting them altogether when rewriting the message:</source>
          <target state="translated">위치 형식 대신 매핑 키를 사용하십시오. 이렇게하면 메시지를 다시 쓸 때 변수를 임의의 순서로 배치하거나 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="926b3650608c51ce2c85dfb00905947918094f40" translate="yes" xml:space="preserve">
          <source>Use normal Python strings as dictionary keys on &lt;code&gt;request.session&lt;/code&gt;. This is more of a convention than a hard-and-fast rule.</source>
          <target state="translated">&lt;code&gt;request.session&lt;/code&gt; 에서 일반 Python 문자열을 사전 키로 사용하십시오 . 이것은 단단하고 빠른 규칙보다 더 많은 규칙입니다.</target>
        </trans-unit>
        <trans-unit id="799cfa51047a6862b506166a580b500402cd6528" translate="yes" xml:space="preserve">
          <source>Use of &lt;a href=&quot;#django.contrib.gis.utils.LayerMapping&quot;&gt;&lt;code&gt;LayerMapping&lt;/code&gt;&lt;/a&gt; requires GDAL.</source>
          <target state="translated">&lt;a href=&quot;#django.contrib.gis.utils.LayerMapping&quot;&gt; &lt;code&gt;LayerMapping&lt;/code&gt; 을&lt;/a&gt; 사용 하려면 GDAL이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b6a6521f8515e4e8e0424eb6999a30064b3c8532" translate="yes" xml:space="preserve">
          <source>Use of &lt;a href=&quot;../../ref/templates/builtins#std:templatetag-with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; means that we store &lt;code&gt;user.emails.all&lt;/code&gt; in a variable for later use, allowing its cache to be re-used.</source>
          <target state="translated">&lt;a href=&quot;../../ref/templates/builtins#std:templatetag-with&quot;&gt; &lt;code&gt;with&lt;/code&gt; 를&lt;/a&gt; 사용하면 나중에 사용할 수 있도록 &lt;code&gt;user.emails.all&lt;/code&gt; 을 변수에 저장 하여 캐시를 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3af60da1cd19f7153b4755b868ace44fd17204cb" translate="yes" xml:space="preserve">
          <source>Use of actual parentheses in the &lt;a href=&quot;#std:templatetag-if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; tag is invalid syntax. If you need them to indicate precedence, you should use nested &lt;a href=&quot;#std:templatetag-if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; tags.</source>
          <target state="translated">&lt;a href=&quot;#std:templatetag-if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; 태그 에서 실제 괄호 사용 이 유효하지 않은 구문입니다. 우선 순위를 나타 내기 위해 필요한 경우 중첩 된 &lt;a href=&quot;#std:templatetag-if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; 태그를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="3f753d3c87fb4244c8f2a179a66ab2d2499de2a2" translate="yes" xml:space="preserve">
          <source>Use of both &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; clauses within the same tag is allowed, with &lt;code&gt;and&lt;/code&gt; having higher precedence than &lt;code&gt;or&lt;/code&gt; e.g.:</source>
          <target state="translated">모두의 사용 &lt;code&gt;and&lt;/code&gt; 그리고 &lt;code&gt;or&lt;/code&gt; 같은 태그 내에서 절은 허용과 &lt;code&gt;and&lt;/code&gt; 보다 높은 우선 순위를 가진 &lt;code&gt;or&lt;/code&gt; 예 :</target>
        </trans-unit>
        <trans-unit id="fadcdff675c6dec3efc2bd0991a40c1647c3f87e" translate="yes" xml:space="preserve">
          <source>Use of the decorator by itself is &lt;strong&gt;not recommended&lt;/strong&gt;, since if you forget to use it, you will have a security hole. The &amp;lsquo;belt and braces&amp;rsquo; strategy of using both is fine, and will incur minimal overhead.</source>
          <target state="translated">데코레이터 자체 를 사용하는 &lt;strong&gt;것은 권장하지 않습니다.&lt;/strong&gt; 사용을 잊어 버리면 보안 구멍이 생길 수 있습니다. 두 가지를 모두 사용하는 '벨트 및 버팀대'전략은 훌륭하며 최소한의 오버 헤드가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="168fe6fb0a8b1323e7d3e9c6e7782e85d5cf7380" translate="yes" xml:space="preserve">
          <source>Use one of the &lt;a href=&quot;#built-in-template-form-renderers&quot;&gt;built-in template form renderers&lt;/a&gt; or implement your own. Custom renderers must implement a &lt;code&gt;render(template_name, context, request=None)&lt;/code&gt; method. It should return a rendered templates (as a string) or raise &lt;a href=&quot;../../topics/templates#django.template.TemplateDoesNotExist&quot;&gt;&lt;code&gt;TemplateDoesNotExist&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#built-in-template-form-renderers&quot;&gt;내장 템플릿 양식 렌더러&lt;/a&gt; 중 하나를 사용 하거나 직접 구현하십시오. 커스텀 렌더러는 &lt;code&gt;render(template_name, context, request=None)&lt;/code&gt; 메소드를 구현해야합니다 . 렌더링 된 템플릿을 문자열로 반환하거나 &lt;a href=&quot;../../topics/templates#django.template.TemplateDoesNotExist&quot;&gt; &lt;code&gt;TemplateDoesNotExist&lt;/code&gt; 를 발생&lt;/a&gt; 시켜야합니다 .</target>
        </trans-unit>
        <trans-unit id="5e9f3ee53edd4d79ad0917afcf58b18bf5f912db" translate="yes" xml:space="preserve">
          <source>Use raw SQL</source>
          <target state="translated">원시 SQL 사용</target>
        </trans-unit>
        <trans-unit id="8980332c0881d0b34f4edc6b2343f3349549c03b" translate="yes" xml:space="preserve">
          <source>Use standard DB optimization techniques</source>
          <target state="translated">표준 DB 최적화 기술 사용</target>
        </trans-unit>
        <trans-unit id="b7af8324f8e5f08e6603c29ec67fea93b2366801" translate="yes" xml:space="preserve">
          <source>Use strings when creating templates manually:</source>
          <target state="translated">템플릿을 수동으로 만들 때 문자열을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a04cbe6e886cef74243cae3f5258179ecdc27cc5" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;#django.db.models.Options.indexes&quot;&gt;&lt;code&gt;indexes&lt;/code&gt;&lt;/a&gt; option instead.</source>
          <target state="translated">대신 &lt;a href=&quot;#django.db.models.Options.indexes&quot;&gt; &lt;code&gt;indexes&lt;/code&gt; &lt;/a&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="195d0b7a96d01751ad3c6a736e49af7d7d67f1fb" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;../../ref/settings#std:setting-CSRF_FAILURE_VIEW&quot;&gt;&lt;code&gt;CSRF_FAILURE_VIEW&lt;/code&gt;&lt;/a&gt; setting to override the CSRF error view.</source>
          <target state="translated">&lt;a href=&quot;../../ref/settings#std:setting-CSRF_FAILURE_VIEW&quot;&gt; &lt;code&gt;CSRF_FAILURE_VIEW&lt;/code&gt; &lt;/a&gt; 설정을 사용하여 CSRF 오류보기를 대체하십시오.</target>
        </trans-unit>
        <trans-unit id="2c4a2e97ff34babbdaddd31936e6dba7db0b602d" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;../ref/django-admin#cmdoption-squashmigrations-squashed-name&quot;&gt;&lt;code&gt;squashmigrations --squashed-name&lt;/code&gt;&lt;/a&gt; option if you want to set the name of the squashed migration rather than use an autogenerated one.</source>
          <target state="translated">자동 생성 된 이름을 사용하지 않고 스쿼시 된 마이그레이션 이름을 설정 하려면 &lt;a href=&quot;../ref/django-admin#cmdoption-squashmigrations-squashed-name&quot;&gt; &lt;code&gt;squashmigrations --squashed-name&lt;/code&gt; &lt;/a&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c97168807f7db5ba19b0d53c4a581637693718d5" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;--insecure&lt;/code&gt; option to force serving of static files with the staticfiles app even if the &lt;a href=&quot;../settings#std:setting-DEBUG&quot;&gt;&lt;code&gt;DEBUG&lt;/code&gt;&lt;/a&gt; setting is &lt;code&gt;False&lt;/code&gt;. By using this you acknowledge the fact that it&amp;rsquo;s &lt;strong&gt;grossly inefficient&lt;/strong&gt; and probably &lt;strong&gt;insecure&lt;/strong&gt;. This is only intended for local development, should &lt;strong&gt;never be used in production&lt;/strong&gt; and is only available if the staticfiles app is in your project&amp;rsquo;s &lt;a href=&quot;../settings#std:setting-INSTALLED_APPS&quot;&gt;&lt;code&gt;INSTALLED_APPS&lt;/code&gt;&lt;/a&gt; setting.</source>
          <target state="translated">&lt;a href=&quot;../settings#std:setting-DEBUG&quot;&gt; &lt;code&gt;DEBUG&lt;/code&gt; &lt;/a&gt; 설정이 &lt;code&gt;False&lt;/code&gt; 인 경우에도 &lt;code&gt;--insecure&lt;/code&gt; 옵션을 사용하여 staticfiles 앱에서 정적 파일을 강제로 제공하십시오 . 이것을 사용함으로써 당신은 그것이 &lt;strong&gt;비효율적&lt;/strong&gt; 이고 아마도 &lt;strong&gt;안전하지&lt;/strong&gt; 않다는 사실을 인정합니다 . 이것은 로컬 개발만을위한 것이며 &lt;strong&gt;프로덕션 환경에서 사용&lt;/strong&gt; 해서는 &lt;strong&gt;안되며&lt;/strong&gt; 정적 파일 앱이 프로젝트의 &lt;a href=&quot;../settings#std:setting-INSTALLED_APPS&quot;&gt; &lt;code&gt;INSTALLED_APPS&lt;/code&gt; &lt;/a&gt; 설정 에있는 경우에만 사용할 수 있습니다 .&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f79eb5d4bf26767f280725b4453ea3b9036ab9f2" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;--nostatic&lt;/code&gt; option to disable serving of static files with the staticfiles app entirely. This option is only available if the staticfiles app is in your project&amp;rsquo;s &lt;a href=&quot;../settings#std:setting-INSTALLED_APPS&quot;&gt;&lt;code&gt;INSTALLED_APPS&lt;/code&gt;&lt;/a&gt; setting.</source>
          <target state="translated">&lt;code&gt;--nostatic&lt;/code&gt; 옵션을 사용하여 staticfiles 앱에서 정적 파일 제공을 완전히 비활성화 하십시오 . 이 옵션은 정적 파일 앱이 프로젝트의 &lt;a href=&quot;../settings#std:setting-INSTALLED_APPS&quot;&gt; &lt;code&gt;INSTALLED_APPS&lt;/code&gt; &lt;/a&gt; 설정 에있는 경우에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d78e1141d368d02f95a8c029e41dfea2eb926a3e" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;--settings&lt;/code&gt; command-line argument to specify the settings manually:</source>
          <target state="translated">사용 &lt;code&gt;--settings&lt;/code&gt; 의 설정을 수동으로 지정하려면 명령 줄 인수를 :</target>
        </trans-unit>
        <trans-unit id="7246aeb10a269f469d009d82937e996e37d6cbb2" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;auto_id&lt;/code&gt; argument to the &lt;code&gt;Form&lt;/code&gt; constructor to control the &lt;code&gt;id&lt;/code&gt; and label behavior. This argument must be &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;False&lt;/code&gt; or a string.</source>
          <target state="translated">&lt;code&gt;Form&lt;/code&gt; 생성자에 &lt;code&gt;auto_id&lt;/code&gt; 인수를 사용하여 &lt;code&gt;id&lt;/code&gt; 및 레이블 동작 을 제어하십시오 . 이 인수는 &lt;code&gt;True&lt;/code&gt; , &lt;code&gt;False&lt;/code&gt; 또는 문자열 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="9e7f1979abd58b8d73106b0e254494e0165dcb11" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;backend&lt;/code&gt; in &lt;a href=&quot;../../ref/settings#std:setting-AUTHENTICATION_BACKENDS&quot;&gt;&lt;code&gt;AUTHENTICATION_BACKENDS&lt;/code&gt;&lt;/a&gt;, if there is only one.</source>
          <target state="translated">&lt;code&gt;backend&lt;/code&gt; 가 &lt;a href=&quot;../../ref/settings#std:setting-AUTHENTICATION_BACKENDS&quot;&gt; &lt;code&gt;AUTHENTICATION_BACKENDS&lt;/code&gt; &lt;/a&gt; 에 있으면 하나만 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7314d0d878c7e5d009d660112540a0ec2313291e" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;databases&lt;/code&gt; class attribute on the test class to request transaction wrapping against non-&lt;code&gt;default&lt;/code&gt; databases.</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; 아닌 데이터베이스 에 대한 트랜잭션 랩핑을 요청하려면 테스트 클래스 에서 &lt;code&gt;databases&lt;/code&gt; 클래스 속성을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0bddc0e0b627ae8f430241cb75e4dcf9b74bf88d" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;db_manager()&lt;/code&gt; method on managers to give managers access to a non-default database.</source>
          <target state="translated">관리자가 기본이 아닌 데이터베이스에 액세스 할 수 있도록 관리자 에서 &lt;code&gt;db_manager()&lt;/code&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0fb541f6207f27bff691edd2dffb142b56ca8770" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;django.test.Client&lt;/code&gt; class to make requests.</source>
          <target state="translated">&lt;code&gt;django.test.Client&lt;/code&gt; 클래스를 사용하여 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="b147ee672c2bf72b3de75374c5bcf4b120ebe8ad" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;fields&lt;/code&gt; option to make simple layout changes in the forms on the &amp;ldquo;add&amp;rdquo; and &amp;ldquo;change&amp;rdquo; pages such as showing only a subset of available fields, modifying their order, or grouping them into rows. For example, you could define a simpler version of the admin form for the &lt;a href=&quot;../flatpages#django.contrib.flatpages.models.FlatPage&quot;&gt;&lt;code&gt;django.contrib.flatpages.models.FlatPage&lt;/code&gt;&lt;/a&gt; model as follows:</source>
          <target state="translated">&quot;추가&quot;및 &quot;변경&quot;페이지에서 사용 가능한 필드의 서브 세트 만 표시, 순서 수정 또는 행으로 그룹화와 같은 양식에서 레이아웃을 간단하게 변경 하려면 &lt;code&gt;fields&lt;/code&gt; 옵션을 사용하십시오 . 예를 들어 &lt;a href=&quot;../flatpages#django.contrib.flatpages.models.FlatPage&quot;&gt; &lt;code&gt;django.contrib.flatpages.models.FlatPage&lt;/code&gt; &lt;/a&gt; 모델에 대한 간단한 관리 양식 버전을 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66c0a7c3ab2d4b6ce32d11c2ad994768fe859dab" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;has_changed()&lt;/code&gt; method on your &lt;code&gt;Form&lt;/code&gt; when you need to check if the form data has been changed from the initial data.</source>
          <target state="translated">양식 데이터가 초기 데이터에서 변경되었는지 확인해야하는 경우 &lt;code&gt;Form&lt;/code&gt; 에서 &lt;code&gt;has_changed()&lt;/code&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2073f8de8a9324d45506f7f1d7766391a7acbbb2" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;page&lt;/code&gt; parameter in the URLconf. For example, this is what your URLconf might look like:</source>
          <target state="translated">URLconf에서 &lt;code&gt;page&lt;/code&gt; 매개 변수를 사용하십시오 . 예를 들어, URLconf는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2e1eff9da47574fb6d40ec57c08e57f5a6caef8b" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;reverse()&lt;/code&gt; method to reverse the order in which a queryset&amp;rsquo;s elements are returned. Calling &lt;code&gt;reverse()&lt;/code&gt; a second time restores the ordering back to the normal direction.</source>
          <target state="translated">쿼리 세트의 요소가 리턴되는 순서를 반대로 하려면 &lt;code&gt;reverse()&lt;/code&gt; 메소드를 사용하십시오 . &lt;code&gt;reverse()&lt;/code&gt; 를 두 번 호출 하면 순서가 다시 원래 방향으로 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="28b553ecf519e86e702731f17010a94862c9bacf" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;safe&lt;/code&gt; parameter to pass characters which don&amp;rsquo;t require encoding. For example:</source>
          <target state="translated">인코딩이 필요없는 문자를 전달 하려면 &lt;code&gt;safe&lt;/code&gt; 매개 변수를 사용하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b54d8314cb5f5e0a81b5387709591ac9fcd1f324" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;through_defaults&lt;/code&gt; argument to specify values for the new &lt;a href=&quot;../../topics/db/models#intermediary-manytomany&quot;&gt;intermediate model&lt;/a&gt; instance(s), if needed.</source>
          <target state="translated">필요한 경우 &lt;code&gt;through_defaults&lt;/code&gt; 인수를 사용하여 새 &lt;a href=&quot;../../topics/db/models#intermediary-manytomany&quot;&gt;중간 모델&lt;/a&gt; 인스턴스 의 값을 지정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="e26e529e4efab2ebcb50d871e4b69cdab7672804" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;through_defaults&lt;/code&gt; argument to specify values for the new &lt;a href=&quot;../../topics/db/models#intermediary-manytomany&quot;&gt;intermediate model&lt;/a&gt; instance, if needed.</source>
          <target state="translated">필요한 경우 &lt;code&gt;through_defaults&lt;/code&gt; 인수를 사용하여 새 &lt;a href=&quot;../../topics/db/models#intermediary-manytomany&quot;&gt;중간 모델&lt;/a&gt; 인스턴스 의 값을 지정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b989c090a376edd8f435f925fcab6e32091865f4" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;using&lt;/code&gt; keyword to &lt;code&gt;Model.save()&lt;/code&gt; to specify to which database the data should be saved.</source>
          <target state="translated">사용 &lt;code&gt;using&lt;/code&gt; 키워드 &lt;code&gt;Model.save()&lt;/code&gt; 하는 데이터베이스에 데이터를 저장해야하는 지정합니다.</target>
        </trans-unit>
        <trans-unit id="edbbe62ae795b45dd28c47d176fb3603777b0547" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;with&lt;/code&gt; template tag</source>
          <target state="translated">를 사용 &lt;code&gt;with&lt;/code&gt; 템플릿 태그</target>
        </trans-unit>
        <trans-unit id="9f2d0e0382932356709e4e95da891e0c79234a4b" translate="yes" xml:space="preserve">
          <source>Use the Source</source>
          <target state="translated">소스 사용</target>
        </trans-unit>
        <trans-unit id="3c3a3a80d9ec31dd4d6f4f9b24722f06698ca2eb" translate="yes" xml:space="preserve">
          <source>Use the application registry for introspection</source>
          <target state="translated">검사를 위해 응용 프로그램 레지스트리를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="df83f6c0c040d0ed9c09cca8bf801454dd6a2d03" translate="yes" xml:space="preserve">
          <source>Use the arrow keys to move up and down.</source>
          <target state="translated">화살표 키를 사용하여 위아래로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="9f4cd031ac323a8a959f3b89c8cf7aecd47d103c" translate="yes" xml:space="preserve">
          <source>Use the function &lt;a href=&quot;../../ref/utils#django.utils.translation.gettext_noop&quot;&gt;&lt;code&gt;django.utils.translation.gettext_noop()&lt;/code&gt;&lt;/a&gt; to mark a string as a translation string without translating it. The string is later translated from a variable.</source>
          <target state="translated">&lt;a href=&quot;../../ref/utils#django.utils.translation.gettext_noop&quot;&gt; &lt;code&gt;django.utils.translation.gettext_noop()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 문자열을 변환하지 않고 번역 문자열로 표시하십시오. 문자열은 나중에 변수에서 번역됩니다.</target>
        </trans-unit>
        <trans-unit id="654becaa96db783b32aef610977406ee78e93386" translate="yes" xml:space="preserve">
          <source>Use the function &lt;a href=&quot;../../ref/utils#django.utils.translation.ngettext&quot;&gt;&lt;code&gt;django.utils.translation.ngettext()&lt;/code&gt;&lt;/a&gt; to specify pluralized messages.</source>
          <target state="translated">&lt;a href=&quot;../../ref/utils#django.utils.translation.ngettext&quot;&gt; &lt;code&gt;django.utils.translation.ngettext()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 복수 메시지를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="463b31d27922a85467ed487ebc5dc446cda7a316" translate="yes" xml:space="preserve">
          <source>Use the functions below to temporarily alter the value of settings in tests. Don&amp;rsquo;t manipulate &lt;code&gt;django.conf.settings&lt;/code&gt; directly as Django won&amp;rsquo;t restore the original values after such manipulations.</source>
          <target state="translated">테스트에서 설정 값을 임시로 변경하려면 아래 기능을 사용하십시오. Django는 그러한 조작 후에 원래 값을 복원 하지 않으므로 &lt;code&gt;django.conf.settings&lt;/code&gt; 를 직접 조작하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="6357e293c9348e9b53e809b3bd6b3ad353cf8a24" translate="yes" xml:space="preserve">
          <source>Use the lazy versions of translation functions in &lt;a href=&quot;../../ref/utils#module-django.utils.translation&quot;&gt;&lt;code&gt;django.utils.translation&lt;/code&gt;&lt;/a&gt; (easily recognizable by the &lt;code&gt;lazy&lt;/code&gt; suffix in their names) to translate strings lazily &amp;ndash; when the value is accessed rather than when they&amp;rsquo;re called.</source>
          <target state="translated">&lt;a href=&quot;../../ref/utils#module-django.utils.translation&quot;&gt; &lt;code&gt;django.utils.translation&lt;/code&gt; &lt;/a&gt; ( 이름 이 &lt;code&gt;lazy&lt;/code&gt; 접미어로 쉽게 인식 가능) 에서 게으른 버전의 번역 함수를 사용하여 문자열을 느리게 번역 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66bd7221828ab630b45136de0b2000b60930fce0" translate="yes" xml:space="preserve">
          <source>Use the standard &lt;code&gt;django-admin&lt;/code&gt; script to create a project called &lt;code&gt;geodjango&lt;/code&gt;:</source>
          <target state="translated">표준 &lt;code&gt;django-admin&lt;/code&gt; 스크립트를 사용하여 &lt;code&gt;geodjango&lt;/code&gt; 라는 프로젝트를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="539a53dc5ceeb04eb00c06aa1022fa833c54a91c" translate="yes" xml:space="preserve">
          <source>Use the template system</source>
          <target state="translated">템플릿 시스템 사용</target>
        </trans-unit>
        <trans-unit id="3477abf22170421c5b4a2b5024e77f3f47b0432b" translate="yes" xml:space="preserve">
          <source>Use the value of the &lt;code&gt;user.backend&lt;/code&gt; attribute, if present. This allows pairing &lt;a href=&quot;#django.contrib.auth.authenticate&quot;&gt;&lt;code&gt;authenticate()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#django.contrib.auth.login&quot;&gt;&lt;code&gt;login()&lt;/code&gt;&lt;/a&gt;: &lt;a href=&quot;#django.contrib.auth.authenticate&quot;&gt;&lt;code&gt;authenticate()&lt;/code&gt;&lt;/a&gt; sets the &lt;code&gt;user.backend&lt;/code&gt; attribute on the user object it returns.</source>
          <target state="translated">있는 경우 &lt;code&gt;user.backend&lt;/code&gt; 속성 의 값을 사용하십시오 . 이를 통해 &lt;a href=&quot;#django.contrib.auth.authenticate&quot;&gt; &lt;code&gt;authenticate()&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;#django.contrib.auth.login&quot;&gt; &lt;code&gt;login()&lt;/code&gt; &lt;/a&gt; 페어링 할 수 있습니다 . &lt;a href=&quot;#django.contrib.auth.authenticate&quot;&gt; &lt;code&gt;authenticate()&lt;/code&gt; &lt;/a&gt; 는 반환하는 사용자 객체에 &lt;code&gt;user.backend&lt;/code&gt; 속성을 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="e6cd924e3a2586cf8fb3a7b49051617b7d3b2d1e" translate="yes" xml:space="preserve">
          <source>Use the value of the optional &lt;code&gt;backend&lt;/code&gt; argument, if provided.</source>
          <target state="translated">제공되는 경우 선택적 &lt;code&gt;backend&lt;/code&gt; 인수 의 값을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="10a17fd335f4333a3bc2b5d5e4806bfdb5de12b3" translate="yes" xml:space="preserve">
          <source>Use this backend to take advantage of external-to-Django-handled authentication. It authenticates using usernames passed in &lt;a href=&quot;../request-response#django.http.HttpRequest.META&quot;&gt;&lt;code&gt;request.META['REMOTE_USER']&lt;/code&gt;&lt;/a&gt;. See the &lt;a href=&quot;../../howto/auth-remote-user&quot;&gt;Authenticating against REMOTE_USER&lt;/a&gt; documentation.</source>
          <target state="translated">이 백엔드를 사용하여 외부에서 장고 처리 인증을 이용하십시오. &lt;a href=&quot;../request-response#django.http.HttpRequest.META&quot;&gt; &lt;code&gt;request.META['REMOTE_USER']&lt;/code&gt; 에&lt;/a&gt; 전달 된 사용자 이름을 사용하여 인증합니다 . &lt;a href=&quot;../../howto/auth-remote-user&quot;&gt;REMOTE_USER에&lt;/a&gt; 대한 인증 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3d48b137a4ae0b003fae82778016f25c8cdf8fde" translate="yes" xml:space="preserve">
          <source>Use this class if you want access to all of the mechanisms which parse the command-line arguments and work out what code to call in response; if you don&amp;rsquo;t need to change any of that behavior, consider using one of its &lt;a href=&quot;#ref-basecommand-subclasses&quot;&gt;subclasses&lt;/a&gt;.</source>
          <target state="translated">명령 행 인수를 구문 분석하고 응답으로 호출 할 코드를 해결하는 모든 메커니즘에 액세스하려면이 클래스를 사용하십시오. 해당 동작을 변경할 필요가 없으면 해당 &lt;a href=&quot;#ref-basecommand-subclasses&quot;&gt;서브 클래스&lt;/a&gt; 중 하나를 사용해보십시오 .</target>
        </trans-unit>
        <trans-unit id="4177727acdea78a12afa02fb86eb57a7b1ea27d2" translate="yes" xml:space="preserve">
          <source>Use this command to generate SQL which will fix cases where a sequence is out of sync with its automatically incremented field data.</source>
          <target state="translated">시퀀스가 자동으로 증가 된 필드 데이터와 동기화되지 않은 경우를 수정하는 SQL을 생성하려면이 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1d05212e77f4ec328f6230076fc920bee7136265" translate="yes" xml:space="preserve">
          <source>Use this if you have a legacy database with which you&amp;rsquo;d like to use Django. The script will inspect the database and create a model for each table within it.</source>
          <target state="translated">Django를 사용하려는 레거시 데이터베이스가있는 경우 이것을 사용하십시오. 스크립트는 데이터베이스를 검사하고 데이터베이스 내의 각 테이블에 대한 모델을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8a1c5f439620e6d3968f1f5086c4587f9ce3ad99" translate="yes" xml:space="preserve">
          <source>Use this if you have constant strings that should be stored in the source language because they are exchanged over systems or users &amp;ndash; such as strings in a database &amp;ndash; but should be translated at the last possible point in time, such as when the string is presented to the user.</source>
          <target state="translated">데이터베이스의 문자열과 같이 시스템이나 사용자를 통해 교환되기 때문에 소스 언어로 저장해야하는 상수 문자열이 있지만 문자열이 표시 될 때와 같이 가능한 마지막 시점에 변환되어야하는 경우이를 사용하십시오. 사용자에게.</target>
        </trans-unit>
        <trans-unit id="ade054ba01a453d797cf828018cfa0e2a81a6062" translate="yes" xml:space="preserve">
          <source>Use this index only on PostgreSQL 10 and later</source>
          <target state="translated">이 인덱스는 PostgreSQL 10 이상에서만 사용하십시오</target>
        </trans-unit>
        <trans-unit id="4b41c1f6065fc6443e013c22c93e47c223118e53" translate="yes" xml:space="preserve">
          <source>Use this method anytime you need to identify an error by its &lt;code&gt;code&lt;/code&gt;. This enables things like rewriting the error&amp;rsquo;s message or writing custom logic in a view when a given error is present. It can also be used to serialize the errors in a custom format (e.g. XML); for instance, &lt;a href=&quot;#django.forms.Form.errors.as_json&quot;&gt;&lt;code&gt;as_json()&lt;/code&gt;&lt;/a&gt; relies on &lt;code&gt;as_data()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;code&lt;/code&gt; 로 오류를 식별해야 할 때마다이 방법을 사용하십시오 . 이를 통해 주어진 오류가있을 때 오류 메시지를 다시 작성하거나보기에서 사용자 정의 논리를 작성하는 등의 작업을 수행 할 수 있습니다. 또한 오류를 사용자 정의 형식 (예 : XML)으로 직렬화하는 데 사용될 수도 있습니다. 예를 들어, &lt;a href=&quot;#django.forms.Form.errors.as_json&quot;&gt; &lt;code&gt;as_json()&lt;/code&gt; &lt;/a&gt; 에 의존 &lt;code&gt;as_data()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="039c2b7f06147eadb210ece4506cbbf31f08a31c" translate="yes" xml:space="preserve">
          <source>Use this method as a last resort</source>
          <target state="translated">이 방법을 최후의 수단으로 사용하십시오</target>
        </trans-unit>
        <trans-unit id="bb6885d9d850504ec29a1b90d21dcd2710558805" translate="yes" xml:space="preserve">
          <source>Use this method to render the raw value of this field as it would be rendered by a &lt;code&gt;Widget&lt;/code&gt;:</source>
          <target state="translated">이 메소드를 사용하여 &lt;code&gt;Widget&lt;/code&gt; 의해 렌더링 될 때이 필드의 원시 값을 렌더링하십시오 .</target>
        </trans-unit>
        <trans-unit id="3721161646e1320c786e23b4f05ea0b2dd7625dd" translate="yes" xml:space="preserve">
          <source>Use this mixin with a custom storage to append the MD5 hash of the file&amp;rsquo;s content to the filename as &lt;a href=&quot;#django.contrib.staticfiles.storage.ManifestStaticFilesStorage&quot;&gt;&lt;code&gt;ManifestStaticFilesStorage&lt;/code&gt;&lt;/a&gt; does.</source>
          <target state="translated">이 믹스 인을 사용자 정의 스토리지와 함께 사용하여 &lt;a href=&quot;#django.contrib.staticfiles.storage.ManifestStaticFilesStorage&quot;&gt; &lt;code&gt;ManifestStaticFilesStorage&lt;/code&gt; &lt;/a&gt; 와 같이 파일 컨텐츠의 MD5 해시를 파일 이름에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="dceed3cb8a7202beb9761b6a7901e0e7fc2a7cd5" translate="yes" xml:space="preserve">
          <source>Use this option if your sitemap uses &lt;code&gt;http&lt;/code&gt; rather than &lt;code&gt;https&lt;/code&gt;.</source>
          <target state="translated">사이트 맵 이 &lt;code&gt;https&lt;/code&gt; 대신 &lt;code&gt;http&lt;/code&gt; 를 사용하는 경우이 옵션을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c1cedd2a801fbb8c995ffd8b4ed596de97c1bfb5" translate="yes" xml:space="preserve">
          <source>Use this property to render the ID of this field. For example, if you are manually constructing a &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt; in your template (despite the fact that &lt;a href=&quot;#django.forms.BoundField.label_tag&quot;&gt;&lt;code&gt;label_tag()&lt;/code&gt;&lt;/a&gt; will do this for you):</source>
          <target state="translated">이 필드를 사용하여이 필드의 ID를 렌더링하십시오. 예를 들어, 템플릿에서 &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt; 을 수동으로 구성하는 경우 ( &lt;a href=&quot;#django.forms.BoundField.label_tag&quot;&gt; &lt;code&gt;label_tag()&lt;/code&gt; &lt;/a&gt; 가이를 수행 한다는 사실에도 불구하고 ) :</target>
        </trans-unit>
        <trans-unit id="b654d1cfd6c0ad8798146161bdb6685bcbd18e49" translate="yes" xml:space="preserve">
          <source>Use this to specify the source SRS manually (for example, some shapefiles don&amp;rsquo;t come with a &lt;code&gt;'.prj'&lt;/code&gt; file). An integer SRID, WKT or PROJ.4 strings, and &lt;a href=&quot;gdal#django.contrib.gis.gdal.SpatialReference&quot;&gt;&lt;code&gt;django.contrib.gis.gdal.SpatialReference&lt;/code&gt;&lt;/a&gt; objects are accepted.</source>
          <target state="translated">소스 SRS를 수동으로 지정하려면이를 사용하십시오 (예 : 일부 shapefile에는 &lt;code&gt;'.prj'&lt;/code&gt; 파일 이 제공되지 않음 ). 정수 SRID, WKT 또는 PROJ.4 문자열 및 &lt;a href=&quot;gdal#django.contrib.gis.gdal.SpatialReference&quot;&gt; &lt;code&gt;django.contrib.gis.gdal.SpatialReference&lt;/code&gt; &lt;/a&gt; 객체가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="836260084abbe1393bc18330a9cbd90b6809228c" translate="yes" xml:space="preserve">
          <source>Used by the &lt;a href=&quot;../topics/auth/default#django.contrib.auth.views.PasswordResetConfirmView&quot;&gt;&lt;code&gt;PasswordResetConfirmView&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../topics/auth/default#django.contrib.auth.views.PasswordResetConfirmView&quot;&gt; &lt;code&gt;PasswordResetConfirmView&lt;/code&gt; 에&lt;/a&gt; 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7066317eeac89df2fd40433e22e6edecf40c5b51" translate="yes" xml:space="preserve">
          <source>Used to display HTML or access attributes for a single field of a &lt;a href=&quot;#django.forms.Form&quot;&gt;&lt;code&gt;Form&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;#django.forms.Form&quot;&gt; &lt;code&gt;Form&lt;/code&gt; &lt;/a&gt; 인스턴스 의 단일 필드에 대한 HTML 또는 액세스 속성을 표시하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c1cb64be7a2a67594b7d626d9f4897c48ec7aed0" translate="yes" xml:space="preserve">
          <source>Useful attributes on &lt;code&gt;{{ field }}&lt;/code&gt; include:</source>
          <target state="translated">&lt;code&gt;{{ field }}&lt;/code&gt; 유용한 속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="367c9af8f5219c455beec84a8f5a0dfda8c891aa" translate="yes" xml:space="preserve">
          <source>Useful methods</source>
          <target state="translated">유용한 방법</target>
        </trans-unit>
        <trans-unit id="58709dc241dce0e52626b79ad2c2664105b5e8fa" translate="yes" xml:space="preserve">
          <source>Useful utility functions</source>
          <target state="translated">유용한 유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="43d37396bb7e453a9b5f5f52c14de02018b7ce02" translate="yes" xml:space="preserve">
          <source>User authentication in Django</source>
          <target state="translated">장고의 사용자 인증</target>
        </trans-unit>
        <trans-unit id="b913547c7a6a8c51069ff0548901d0da5d88ddad" translate="yes" xml:space="preserve">
          <source>User friendly forms</source>
          <target state="translated">사용하기 쉬운 양식</target>
        </trans-unit>
        <trans-unit id="eb66d774b36988a4729251435f0dffd26cc86f50" translate="yes" xml:space="preserve">
          <source>User passwords are not displayed in the admin (nor stored in the database), but the &lt;a href=&quot;passwords&quot;&gt;password storage details&lt;/a&gt; are displayed. Included in the display of this information is a link to a password change form that allows admins to change user passwords.</source>
          <target state="translated">사용자 비밀번호는 관리자 (데이터베이스에 저장되지 않음)에 표시되지 않지만 &lt;a href=&quot;passwords&quot;&gt;비밀번호 저장 세부 사항&lt;/a&gt; 은 표시됩니다. 이 정보의 표시에는 관리자가 사용자 비밀번호를 변경할 수있는 비밀번호 변경 양식 링크가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a94795ad5a95f108b2080e9d3eeee6f50ceaa08" translate="yes" xml:space="preserve">
          <source>User-uploaded content</source>
          <target state="translated">사용자 업로드 콘텐츠</target>
        </trans-unit>
        <trans-unit id="89af20f6c126b1f63ff3f9b54adfaf51ed4793db" translate="yes" xml:space="preserve">
          <source>Username to use for the SMTP server defined in &lt;a href=&quot;#std:setting-EMAIL_HOST&quot;&gt;&lt;code&gt;EMAIL_HOST&lt;/code&gt;&lt;/a&gt;. If empty, Django won&amp;rsquo;t attempt authentication.</source>
          <target state="translated">&lt;a href=&quot;#std:setting-EMAIL_HOST&quot;&gt; &lt;code&gt;EMAIL_HOST&lt;/code&gt; 에&lt;/a&gt; 정의 된 SMTP 서버에 사용할 사용자 이름 입니다. 비어 있으면 장고는 인증을 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b0bc40e0c8edad2f7b984bd301c092667e346ae" translate="yes" xml:space="preserve">
          <source>Usernames and Unicode</source>
          <target state="translated">사용자 이름과 유니 코드</target>
        </trans-unit>
        <trans-unit id="57f2b181d0a5e79a147ea1cdf41457f58dbbb3c9" translate="yes" xml:space="preserve">
          <source>Users</source>
          <target state="translated">Users</target>
        </trans-unit>
        <trans-unit id="c2e88ddde705dca6a7e43341564354275bc1b559" translate="yes" xml:space="preserve">
          <source>Users flagged with an unusable password (see &lt;a href=&quot;../../ref/contrib/auth#django.contrib.auth.models.User.set_unusable_password&quot;&gt;&lt;code&gt;set_unusable_password()&lt;/code&gt;&lt;/a&gt; aren&amp;rsquo;t allowed to request a password reset to prevent misuse when using an external authentication source like LDAP. Note that they won&amp;rsquo;t receive any error message since this would expose their account&amp;rsquo;s existence but no mail will be sent either.</source>
          <target state="translated">사용할 수없는 비밀번호로 플래그가 지정된 사용자 ( &lt;a href=&quot;../../ref/contrib/auth#django.contrib.auth.models.User.set_unusable_password&quot;&gt; &lt;code&gt;set_unusable_password()&lt;/code&gt; &lt;/a&gt; 참조 ) 는 LDAP와 같은 외부 인증 소스를 사용할 때 오용을 방지하기 위해 비밀번호 재설정을 요청할 수 없습니다. 계정이 존재하지만 오류 메시지가 표시되지는 않습니다. 메일도 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="289623b2475e55c3d50ee213e143d6623c760d07" translate="yes" xml:space="preserve">
          <source>Users often choose poor passwords. To help mitigate this problem, Django offers pluggable password validation. You can configure multiple password validators at the same time. A few validators are included in Django, but you can write your own as well.</source>
          <target state="translated">사용자는 종종 잘못된 암호를 선택합니다. 이 문제를 완화하기 위해 Django는 플러그 가능한 암호 유효성 검사를 제공합니다. 여러 개의 암호 유효성 검사기를 동시에 구성 할 수 있습니다. 장고에는 몇 가지 유효성 검사기가 포함되어 있지만 직접 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5250f2e691432cb1c5e7e4ca18b160de38535b1" translate="yes" xml:space="preserve">
          <source>Users with &lt;a href=&quot;../ref/contrib/auth#django.contrib.auth.models.User.is_active&quot;&gt;&lt;code&gt;is_active=False&lt;/code&gt;&lt;/a&gt; won&amp;rsquo;t be allowed to authenticate. Use &lt;a href=&quot;../ref/contrib/auth#django.contrib.auth.backends.AllowAllUsersRemoteUserBackend&quot;&gt;&lt;code&gt;AllowAllUsersRemoteUserBackend&lt;/code&gt;&lt;/a&gt; if you want to allow them to.</source>
          <target state="translated">&lt;a href=&quot;../ref/contrib/auth#django.contrib.auth.models.User.is_active&quot;&gt; &lt;code&gt;is_active=False&lt;/code&gt; 인&lt;/a&gt; 사용자는 인증 할 수 없습니다. 허용 하려면 &lt;a href=&quot;../ref/contrib/auth#django.contrib.auth.backends.AllowAllUsersRemoteUserBackend&quot;&gt; &lt;code&gt;AllowAllUsersRemoteUserBackend&lt;/code&gt; 를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6f191d2993f3a3534c48cb1d8703497679eb685c" translate="yes" xml:space="preserve">
          <source>Uses &lt;a href=&quot;#django.contrib.auth.backends.BaseBackend.get_all_permissions&quot;&gt;&lt;code&gt;get_all_permissions()&lt;/code&gt;&lt;/a&gt; to check if &lt;code&gt;user_obj&lt;/code&gt; has the permission string &lt;code&gt;perm&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#django.contrib.auth.backends.BaseBackend.get_all_permissions&quot;&gt; &lt;code&gt;get_all_permissions()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 &lt;code&gt;user_obj&lt;/code&gt; 에 권한 문자열 &lt;code&gt;perm&lt;/code&gt; 이 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="06ef8c2b0578b3222e3a7abab3a5e0d9bb4617c6" translate="yes" xml:space="preserve">
          <source>Uses &lt;a href=&quot;#django.contrib.auth.backends.BaseBackend.get_user_permissions&quot;&gt;&lt;code&gt;get_user_permissions()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#django.contrib.auth.backends.BaseBackend.get_group_permissions&quot;&gt;&lt;code&gt;get_group_permissions()&lt;/code&gt;&lt;/a&gt; to get the set of permission strings the &lt;code&gt;user_obj&lt;/code&gt; has.</source>
          <target state="translated">용도의 &lt;a href=&quot;#django.contrib.auth.backends.BaseBackend.get_user_permissions&quot;&gt; &lt;code&gt;get_user_permissions()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#django.contrib.auth.backends.BaseBackend.get_group_permissions&quot;&gt; &lt;code&gt;get_group_permissions()&lt;/code&gt; &lt;/a&gt; 권한 문자열의 집합을 얻을 수 &lt;code&gt;user_obj&lt;/code&gt; 이 있다합니다.</target>
        </trans-unit>
        <trans-unit id="c7fc8e0a30e1cc3038c5f6e22b647d35cba10e4e" translate="yes" xml:space="preserve">
          <source>Uses &lt;a href=&quot;#django.contrib.auth.backends.ModelBackend.get_all_permissions&quot;&gt;&lt;code&gt;get_all_permissions()&lt;/code&gt;&lt;/a&gt; to check if &lt;code&gt;user_obj&lt;/code&gt; has the permission string &lt;code&gt;perm&lt;/code&gt;. Returns &lt;code&gt;False&lt;/code&gt; if the user is not &lt;a href=&quot;../../topics/auth/customizing#django.contrib.auth.models.CustomUser.is_active&quot;&gt;&lt;code&gt;is_active&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#django.contrib.auth.backends.ModelBackend.get_all_permissions&quot;&gt; &lt;code&gt;get_all_permissions()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 &lt;code&gt;user_obj&lt;/code&gt; 에 권한 문자열 &lt;code&gt;perm&lt;/code&gt; 이 있는지 확인하십시오 . 사용자가 &lt;a href=&quot;../../topics/auth/customizing#django.contrib.auth.models.CustomUser.is_active&quot;&gt; &lt;code&gt;is_active&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 &lt;code&gt;False&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="9f272f832e26bb5cfe0a9e8ad2639e5f7f4c012e" translate="yes" xml:space="preserve">
          <source>Uses &lt;a href=&quot;#django.utils.timezone.localtime&quot;&gt;&lt;code&gt;localtime()&lt;/code&gt;&lt;/a&gt; to convert an aware &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; to a &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#datetime.datetime.date&quot;&gt;&lt;code&gt;date()&lt;/code&gt;&lt;/a&gt; in a different time zone, by default the &lt;a href=&quot;../topics/i18n/timezones#default-current-time-zone&quot;&gt;current time zone&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#django.utils.timezone.localtime&quot;&gt; &lt;code&gt;localtime()&lt;/code&gt; &lt;/a&gt; 을 사용 하여 기본적으로 &lt;a href=&quot;../topics/i18n/timezones#default-current-time-zone&quot;&gt;현재&lt;/a&gt; 시간대 인 다른 시간대 의 인식 &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 을 &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#datetime.datetime.date&quot;&gt; &lt;code&gt;date()&lt;/code&gt; &lt;/a&gt; 로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="c6e1f5d694ae15854b36239346c2c9dccc52d080" translate="yes" xml:space="preserve">
          <source>Uses &lt;a href=&quot;../validators#django.core.validators.EmailValidator&quot;&gt;&lt;code&gt;EmailValidator&lt;/code&gt;&lt;/a&gt; to validate that the given value is a valid email address, using a moderately complex regular expression.</source>
          <target state="translated">사용 &lt;a href=&quot;../validators#django.core.validators.EmailValidator&quot;&gt; &lt;code&gt;EmailValidator&lt;/code&gt; 를&lt;/a&gt; 주어진 값이 적당히 복잡한 정규 표현식을 사용하여 유효한 이메일 주소인지 확인하려면.</target>
        </trans-unit>
        <trans-unit id="953ea14a529db6342ded15c80e8b07bae00cbb63" translate="yes" xml:space="preserve">
          <source>Uses &lt;a href=&quot;../validators#django.core.validators.MaxLengthValidator&quot;&gt;&lt;code&gt;MaxLengthValidator&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../validators#django.core.validators.MinLengthValidator&quot;&gt;&lt;code&gt;MinLengthValidator&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;max_length&lt;/code&gt; and &lt;code&gt;min_length&lt;/code&gt; are provided. Otherwise, all inputs are valid.</source>
          <target state="translated">&lt;code&gt;max_length&lt;/code&gt; 및 &lt;code&gt;min_length&lt;/code&gt; 가 제공되는 경우 &lt;a href=&quot;../validators#django.core.validators.MaxLengthValidator&quot;&gt; &lt;code&gt;MaxLengthValidator&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../validators#django.core.validators.MinLengthValidator&quot;&gt; &lt;code&gt;MinLengthValidator&lt;/code&gt; 를&lt;/a&gt; 사용합니다 . 그렇지 않으면 모든 입력이 유효합니다.</target>
        </trans-unit>
        <trans-unit id="8fac0e63b41d104489510a99bdcaa4ed7ffcc09f" translate="yes" xml:space="preserve">
          <source>Uses &lt;a href=&quot;../validators#django.core.validators.RegexValidator&quot;&gt;&lt;code&gt;RegexValidator&lt;/code&gt;&lt;/a&gt; to validate that the given value matches a certain regular expression.</source>
          <target state="translated">지정된 값이 특정 정규식과 일치하는지 확인하기 위해 &lt;a href=&quot;../validators#django.core.validators.RegexValidator&quot;&gt; &lt;code&gt;RegexValidator&lt;/code&gt; &lt;/a&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="0142e646af983484cab72120b49e8b2aaa0571e0" translate="yes" xml:space="preserve">
          <source>Uses &lt;a href=&quot;../validators#django.core.validators.URLValidator&quot;&gt;&lt;code&gt;URLValidator&lt;/code&gt;&lt;/a&gt; to validate that the given value is a valid URL.</source>
          <target state="translated">지정된 값이 유효한 URL인지 확인하기 위해 &lt;a href=&quot;../validators#django.core.validators.URLValidator&quot;&gt; &lt;code&gt;URLValidator&lt;/code&gt; &lt;/a&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="8fed16b5446b8b1117c85079fade2e0121f4ad34" translate="yes" xml:space="preserve">
          <source>Uses &lt;a href=&quot;../validators#django.core.validators.validate_slug&quot;&gt;&lt;code&gt;validate_slug&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../validators#django.core.validators.validate_unicode_slug&quot;&gt;&lt;code&gt;validate_unicode_slug&lt;/code&gt;&lt;/a&gt; to validate that the given value contains only letters, numbers, underscores, and hyphens.</source>
          <target state="translated">&lt;a href=&quot;../validators#django.core.validators.validate_slug&quot;&gt; &lt;code&gt;validate_slug&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../validators#django.core.validators.validate_unicode_slug&quot;&gt; &lt;code&gt;validate_unicode_slug&lt;/code&gt; &lt;/a&gt; 를 사용 하여 지정된 값에 문자, 숫자, 밑줄 및 하이픈 만 포함되어 있는지 검증하십시오.</target>
        </trans-unit>
        <trans-unit id="8672ab5c98f4703993d8ca0c08ff38ef1d0dcb0f" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;django.utils.ipv6&lt;/code&gt; to check the validity of an IPv6 address.</source>
          <target state="translated">&lt;code&gt;django.utils.ipv6&lt;/code&gt; 을 사용 하여 IPv6 주소의 유효성을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="f7c96ba25515c9caaf893a88dad2b049007d330a" translate="yes" xml:space="preserve">
          <source>Uses Django&amp;rsquo;s base manager, dumping records which might otherwise be filtered or modified by a custom manager.</source>
          <target state="translated">Django의 기본 관리자를 사용하여 사용자 지정 관리자가 필터링하거나 수정할 수있는 레코드를 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="65fc97eed1fb4ae7cbf6a40d591962586fac7f9b" translate="yes" xml:space="preserve">
          <source>Uses IPv6 for the development server. This changes the default IP address from &lt;code&gt;127.0.0.1&lt;/code&gt; to &lt;code&gt;::1&lt;/code&gt;.</source>
          <target state="translated">개발 서버에 IPv6을 사용합니다. 기본 IP 주소가 &lt;code&gt;127.0.0.1&lt;/code&gt; 에서 &lt;code&gt;::1&lt;/code&gt; 로 변경 됩니다.</target>
        </trans-unit>
        <trans-unit id="6767002ed97bcbf99046034dcd0ede82d720202a" translate="yes" xml:space="preserve">
          <source>Uses Pillow to ensure that &lt;code&gt;value.name&lt;/code&gt; (&lt;code&gt;value&lt;/code&gt; is a &lt;a href=&quot;files/file#django.core.files.File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;) has &lt;a href=&quot;https://pillow.readthedocs.io/en/latest/handbook/image-file-formats.html&quot;&gt;a valid image extension&lt;/a&gt;.</source>
          <target state="translated">Pillow를 사용하여 &lt;code&gt;value.name&lt;/code&gt; ( &lt;code&gt;value&lt;/code&gt; 는 &lt;a href=&quot;files/file#django.core.files.File&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; )의 &lt;a href=&quot;https://pillow.readthedocs.io/en/latest/handbook/image-file-formats.html&quot;&gt;이미지 확장명이 유효한지 확인하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="125e5daaec0421f24c358f601b815141990297a0" translate="yes" xml:space="preserve">
          <source>Uses SQL&amp;rsquo;s &lt;code&gt;EXCEPT&lt;/code&gt; operator to keep only elements present in the &lt;code&gt;QuerySet&lt;/code&gt; but not in some other &lt;code&gt;QuerySet&lt;/code&gt;s. For example:</source>
          <target state="translated">SQL의 &lt;code&gt;EXCEPT&lt;/code&gt; 연산자를 사용 하여 &lt;code&gt;QuerySet&lt;/code&gt; 에는 요소 만 있고 다른 &lt;code&gt;QuerySet&lt;/code&gt; 에는없는 요소를 유지합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3de4a2ffe8370cbd5a822ab275bcf6cc61c481b9" translate="yes" xml:space="preserve">
          <source>Uses SQL&amp;rsquo;s &lt;code&gt;INTERSECT&lt;/code&gt; operator to return the shared elements of two or more &lt;code&gt;QuerySet&lt;/code&gt;s. For example:</source>
          <target state="translated">SQL의 &lt;code&gt;INTERSECT&lt;/code&gt; 연산자를 사용 하여 둘 이상의 &lt;code&gt;QuerySet&lt;/code&gt; 의 공유 요소를 리턴합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2031e06cd24355497239576de343072c6db6271e" translate="yes" xml:space="preserve">
          <source>Uses SQL&amp;rsquo;s &lt;code&gt;UNION&lt;/code&gt; operator to combine the results of two or more &lt;code&gt;QuerySet&lt;/code&gt;s. For example:</source>
          <target state="translated">SQL의 &lt;code&gt;UNION&lt;/code&gt; 연산자를 사용하여 둘 이상의 &lt;code&gt;QuerySet&lt;/code&gt; 결과를 결합합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5e1a7aadb8516cb4e6d4971411020ae828a90fd3" translate="yes" xml:space="preserve">
          <source>Uses a default &lt;code&gt;context_object_name&lt;/code&gt; of &lt;code&gt;latest&lt;/code&gt;.</source>
          <target state="translated">기본 사용 &lt;code&gt;context_object_name&lt;/code&gt; 의 &lt;code&gt;latest&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99f7d85a721a5e722cedfea90549604eb923be2b" translate="yes" xml:space="preserve">
          <source>Uses a default &lt;code&gt;template_name_suffix&lt;/code&gt; of &lt;code&gt;_archive&lt;/code&gt;.</source>
          <target state="translated">기본 사용 &lt;code&gt;template_name_suffix&lt;/code&gt; 의 &lt;code&gt;_archive&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="00b047ef8f4c2dd32ddb6c22defda634972308f8" translate="yes" xml:space="preserve">
          <source>Uses a default &lt;code&gt;template_name_suffix&lt;/code&gt; of &lt;code&gt;_archive_day&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;_archive_day&lt;/code&gt; 의 기본 &lt;code&gt;template_name_suffix&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="3e49632d93f1b4a3f28e6287d3f0fb9c0c6b4ad6" translate="yes" xml:space="preserve">
          <source>Uses a default &lt;code&gt;template_name_suffix&lt;/code&gt; of &lt;code&gt;_archive_month&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;_archive_month&lt;/code&gt; 의 기본 &lt;code&gt;template_name_suffix&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="7deea9532efe12f7c854c16806f8fc290fa8b1d1" translate="yes" xml:space="preserve">
          <source>Uses a default &lt;code&gt;template_name_suffix&lt;/code&gt; of &lt;code&gt;_archive_today&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;_archive_today&lt;/code&gt; 의 기본 &lt;code&gt;template_name_suffix&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="df28b4cc4ac1a5c77af57d526924046a4781c048" translate="yes" xml:space="preserve">
          <source>Uses a default &lt;code&gt;template_name_suffix&lt;/code&gt; of &lt;code&gt;_archive_week&lt;/code&gt;.</source>
          <target state="translated">기본 사용 &lt;code&gt;template_name_suffix&lt;/code&gt; 의 &lt;code&gt;_archive_week&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="e4e11e098e88e27f837f3fa26e67b02d480a1467" translate="yes" xml:space="preserve">
          <source>Uses a default &lt;code&gt;template_name_suffix&lt;/code&gt; of &lt;code&gt;_archive_year&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;_archive_year&lt;/code&gt; 의 기본 &lt;code&gt;template_name_suffix&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="54244df9bed065a50fb71a09505698963728df9f" translate="yes" xml:space="preserve">
          <source>Uses a default &lt;code&gt;template_name_suffix&lt;/code&gt; of &lt;code&gt;_detail&lt;/code&gt;.</source>
          <target state="translated">기본 &lt;code&gt;template_name_suffix&lt;/code&gt; 의 &lt;code&gt;_detail&lt;/code&gt; 을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="12b3fcb9443ff8309e7c480b3f341978c79673d6" translate="yes" xml:space="preserve">
          <source>Uses a similar format as PHP&amp;rsquo;s &lt;code&gt;date()&lt;/code&gt; function (&lt;a href=&quot;https://php.net/date&quot;&gt;https://php.net/date&lt;/a&gt;) with some differences.</source>
          <target state="translated">PHP의 &lt;code&gt;date()&lt;/code&gt; 함수 ( &lt;a href=&quot;https://php.net/date&quot;&gt;https://php.net/date&lt;/a&gt; )와 유사한 형식을 사용하지만 약간의 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="18bdacb84c3de2098cfb7ac40b7799da9bb55af4" translate="yes" xml:space="preserve">
          <source>Uses both &lt;code&gt;validate_ipv4_address&lt;/code&gt; and &lt;code&gt;validate_ipv6_address&lt;/code&gt; to ensure a value is either a valid IPv4 or IPv6 address.</source>
          <target state="translated">&lt;code&gt;validate_ipv4_address&lt;/code&gt; 및 &lt;code&gt;validate_ipv6_address&lt;/code&gt; 를 모두 사용 하여 값이 유효한 IPv4 또는 IPv6 주소인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9bea1b04370e50097e847be42426fcfefc4424ae" translate="yes" xml:space="preserve">
          <source>Uses of the key shouldn&amp;rsquo;t assume that it&amp;rsquo;s text or bytes. Every use should go through &lt;a href=&quot;utils#django.utils.encoding.force_str&quot;&gt;&lt;code&gt;force_str()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;utils#django.utils.encoding.force_bytes&quot;&gt;&lt;code&gt;force_bytes()&lt;/code&gt;&lt;/a&gt; to convert it to the desired type.</source>
          <target state="translated">키를 사용한다고해서 텍스트 나 바이트라고 가정해서는 안됩니다. 모든 사용은 &lt;a href=&quot;utils#django.utils.encoding.force_str&quot;&gt; &lt;code&gt;force_str()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;utils#django.utils.encoding.force_bytes&quot;&gt; &lt;code&gt;force_bytes()&lt;/code&gt; &lt;/a&gt; 를 거쳐 원하는 유형으로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="bea49df91e9fe86d8bb0515ae800d6cc283d575a" translate="yes" xml:space="preserve">
          <source>Uses the &lt;a href=&quot;checks&quot;&gt;system check framework&lt;/a&gt; to inspect the entire Django project for common problems.</source>
          <target state="translated">&lt;a href=&quot;checks&quot;&gt;시스템 검사 프레임 워크&lt;/a&gt; 를 사용하여 전체 장고 프로젝트에서 일반적인 문제를 검사합니다.</target>
        </trans-unit>
        <trans-unit id="26cc4e364dc077b521ad9604dc7af7c01085e5c8" translate="yes" xml:space="preserve">
          <source>Uses the &lt;code&gt;natural_key()&lt;/code&gt; model method to serialize any foreign key and many-to-many relationship to objects of the type that defines the method. If you&amp;rsquo;re dumping &lt;code&gt;contrib.auth&lt;/code&gt;&lt;code&gt;Permission&lt;/code&gt; objects or &lt;code&gt;contrib.contenttypes&lt;/code&gt;&lt;code&gt;ContentType&lt;/code&gt; objects, you should probably use this flag. See the &lt;a href=&quot;../topics/serialization#topics-serialization-natural-keys&quot;&gt;natural keys&lt;/a&gt; documentation for more details on this and the next option.</source>
          <target state="translated">&lt;code&gt;natural_key()&lt;/code&gt; 모델 메소드를 사용하여 메소드를 정의하는 유형의 오브젝트에 대한 외래 키 및 다 대다 관계를 직렬화하십시오. &lt;code&gt;contrib.auth&lt;/code&gt; &lt;code&gt;Permission&lt;/code&gt; 오브젝트 또는 &lt;code&gt;contrib.contenttypes&lt;/code&gt; &lt;code&gt;ContentType&lt;/code&gt; 오브젝트를 덤프 하는 경우이 플래그를 사용해야합니다. 이 옵션과 다음 옵션에 대한 자세한 내용 은 &lt;a href=&quot;../topics/serialization#topics-serialization-natural-keys&quot;&gt;자연 키&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ea1db0a351f2ad0e1560aadc2efb4b15c21271fe" translate="yes" xml:space="preserve">
          <source>Uses the arguments to send an &lt;code&gt;EmailMultiAlternatives&lt;/code&gt;. Can be overridden to customize how the email is sent to the user.</source>
          <target state="translated">인수를 사용하여 &lt;code&gt;EmailMultiAlternatives&lt;/code&gt; 를 보냅니다 . 이메일이 사용자에게 전송되는 방식을 사용자 정의하기 위해 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7becf0f44c69c198ea5e27a9303602edebd9dee3" translate="yes" xml:space="preserve">
          <source>Uses the same logic as &lt;a href=&quot;#django.http.QueryDict.__getitem__&quot;&gt;&lt;code&gt;__getitem__()&lt;/code&gt;&lt;/a&gt;, with a hook for returning a default value if the key doesn&amp;rsquo;t exist.</source>
          <target state="translated">키가 존재하지 않는 경우 기본값을 반환하기위한 후크와 함께 &lt;a href=&quot;#django.http.QueryDict.__getitem__&quot;&gt; &lt;code&gt;__getitem__()&lt;/code&gt; &lt;/a&gt; 과 동일한 논리를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="39b440eb3eed1d809a0a9fc6c36dd6f0647a5e1e" translate="yes" xml:space="preserve">
          <source>Uses the same syntax as Python&amp;rsquo;s list slicing. See &lt;a href=&quot;https://www.diveinto.org/python3/native-datatypes.html#slicinglists&quot;&gt;https://www.diveinto.org/python3/native-datatypes.html#slicinglists&lt;/a&gt; for an introduction.</source>
          <target state="translated">Python의 목록 슬라이싱과 동일한 구문을 사용합니다. 소개는 &lt;a href=&quot;https://www.diveinto.org/python3/native-datatypes.html#slicinglists&quot;&gt;https://www.diveinto.org/python3/native-datatypes.html#slicinglists&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f24911cdd3b9dff6bec82f21a4395f23823f0070" translate="yes" xml:space="preserve">
          <source>Uses the system check framework to inspect the entire Django project for potential problems. Serious problems are raised as a &lt;a href=&quot;#django.core.management.CommandError&quot;&gt;&lt;code&gt;CommandError&lt;/code&gt;&lt;/a&gt;; warnings are output to stderr; minor notifications are output to stdout.</source>
          <target state="translated">시스템 검사 프레임 워크를 사용하여 잠재적 인 문제가 있는지 Django 프로젝트 전체를 검사합니다. 심각한 문제는 &lt;a href=&quot;#django.core.management.CommandError&quot;&gt; &lt;code&gt;CommandError&lt;/code&gt; &lt;/a&gt; 로 발생합니다 . 경고는 stderr에 출력됩니다. 사소한 알림이 stdout에 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="db016a3680e480604c743d4e90fec15878ead9ce" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#django.db.models.query.QuerySet.only&quot;&gt;&lt;code&gt;only()&lt;/code&gt;&lt;/a&gt; and omitting a field requested using &lt;a href=&quot;#django.db.models.query.QuerySet.select_related&quot;&gt;&lt;code&gt;select_related()&lt;/code&gt;&lt;/a&gt; is an error as well.</source>
          <target state="translated">사용 &lt;a href=&quot;#django.db.models.query.QuerySet.only&quot;&gt; &lt;code&gt;only()&lt;/code&gt; &lt;/a&gt; 및 필드를 사용하여 요청을 생략 &lt;a href=&quot;#django.db.models.query.QuerySet.select_related&quot;&gt; &lt;code&gt;select_related()&lt;/code&gt; &lt;/a&gt; 아니라 에러이다.</target>
        </trans-unit>
        <trans-unit id="438d82e9aec538511844c8e2f9bf7f25bea4cf79" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;https://docs.python.org/3/library/unittest.html#unittest.TestCase&quot;&gt;&lt;code&gt;unittest.TestCase&lt;/code&gt;&lt;/a&gt; avoids the cost of running each test in a transaction and flushing the database, but if your tests interact with the database their behavior will vary based on the order that the test runner executes them. This can lead to unit tests that pass when run in isolation but fail when run in a suite.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/unittest.html#unittest.TestCase&quot;&gt; &lt;code&gt;unittest.TestCase&lt;/code&gt; 를&lt;/a&gt; 사용 하면 트랜잭션에서 각 테스트를 실행하고 데이터베이스를 플러시하는 비용을 피할 수 있지만 테스트가 데이터베이스와 상호 작용하는 경우 테스트 실행기가 실행하는 순서에 따라 동작이 달라집니다. 이로 인해 단독으로 실행될 때 통과하지만 스위트에서 실행될 때 실패하는 단위 테스트가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="240a00d92cdbee3a749a6819d32f47477a077619" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;querysets#std:fieldlookup-iexact&quot;&gt;&lt;code&gt;iexact&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;querysets#std:fieldlookup-contains&quot;&gt;&lt;code&gt;contains&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;querysets#std:fieldlookup-icontains&quot;&gt;&lt;code&gt;icontains&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;querysets#std:fieldlookup-startswith&quot;&gt;&lt;code&gt;startswith&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;querysets#std:fieldlookup-istartswith&quot;&gt;&lt;code&gt;istartswith&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;querysets#std:fieldlookup-endswith&quot;&gt;&lt;code&gt;endswith&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;querysets#std:fieldlookup-iendswith&quot;&gt;&lt;code&gt;iendswith&lt;/code&gt;&lt;/a&gt; lookups on PostgreSQL don&amp;rsquo;t work for values without hyphens, because PostgreSQL stores them in a hyphenated uuid datatype type.</source>
          <target state="translated">사용 &lt;a href=&quot;querysets#std:fieldlookup-iexact&quot;&gt; &lt;code&gt;iexact&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;querysets#std:fieldlookup-contains&quot;&gt; &lt;code&gt;contains&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;querysets#std:fieldlookup-icontains&quot;&gt; &lt;code&gt;icontains&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;querysets#std:fieldlookup-startswith&quot;&gt; &lt;code&gt;startswith&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;querysets#std:fieldlookup-istartswith&quot;&gt; &lt;code&gt;istartswith&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;querysets#std:fieldlookup-endswith&quot;&gt; &lt;code&gt;endswith&lt;/code&gt; 을&lt;/a&gt; , 또는 &lt;a href=&quot;querysets#std:fieldlookup-iendswith&quot;&gt; &lt;code&gt;iendswith&lt;/code&gt; &lt;/a&gt; PostgreSQL의에 대한 조회는 하이픈 UUID 데이터 형식 유형, 하이픈없이 값 때문에 PostgreSQL을 저장합니다 일을하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="192c5d4ca2a859cf240e165c53b1431f2c2a04e2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;F()&lt;/code&gt; in filters</source>
          <target state="translated">필터에서 &lt;code&gt;F()&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="89e9b8ce835887af4444dabc7a5989c1974ba5f0" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;F()&lt;/code&gt; to sort null values</source>
          <target state="translated">&lt;code&gt;F()&lt;/code&gt; 를 사용하여 null 값 정렬</target>
        </trans-unit>
        <trans-unit id="d9b41bd428d18e154d56d4cc11ad4db2bbd2997e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;F()&lt;/code&gt; with annotations</source>
          <target state="translated">주석과 함께 &lt;code&gt;F()&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="c5bf5746085c1c46653f2851e075d952c659e479" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;FormMixin&lt;/code&gt; with &lt;code&gt;DetailView&lt;/code&gt;</source>
          <target state="translated">사용 &lt;code&gt;FormMixin&lt;/code&gt; 을 함께 &lt;code&gt;DetailView&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c5f5cae8b58f41fab635dfc165144611731fd17e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;Paginator&lt;/code&gt; in a view function</source>
          <target state="translated">뷰 함수에서 &lt;code&gt;Paginator&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="c4599383ea3640a6681189547d65931d7051c711" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;REMOTE_USER&lt;/code&gt; on login pages only</source>
          <target state="translated">로그인 페이지에서만 &lt;code&gt;REMOTE_USER&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="b49b9bee5a68f171f253f809c64cc0658be501f9" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;RequestContext&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;RequestContext&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="d2961e9d5f5a3bf82c9483e1f71b6131d4a16c0d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;SingleObjectMixin&lt;/code&gt; with &lt;code&gt;ListView&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ListView&lt;/code&gt; 와 함께 &lt;code&gt;SingleObjectMixin&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="20dd297fa49a9ec9ad5b5fb10f6289f43f6bdcf7" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;SingleObjectMixin&lt;/code&gt; with View</source>
          <target state="translated">View와 함께 &lt;code&gt;SingleObjectMixin&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="44fdd84431ebb03a6787f3f87eeb34ae8744e07a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;TemplateResponse&lt;/code&gt; and &lt;code&gt;SimpleTemplateResponse&lt;/code&gt;</source>
          <target state="translated">사용 &lt;code&gt;TemplateResponse&lt;/code&gt; 및 &lt;code&gt;SimpleTemplateResponse&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="6f06f60733ca1a6becd19a587eab8a2d1275611e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;Vary&lt;/code&gt; headers</source>
          <target state="translated">&lt;code&gt;Vary&lt;/code&gt; 헤더 사용</target>
        </trans-unit>
        <trans-unit id="75e049fad96622be908d7f101a3a317d93f08fe1" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;add()&lt;/code&gt; on a relation that already exists won&amp;rsquo;t duplicate the relation, but it will still trigger signals.</source>
          <target state="translated">사용 &lt;code&gt;add()&lt;/code&gt; 이미 관계를 복제하지 않습니다 존재하는 관계에, 그러나 그것은 것입니다 여전히 트리거 신호.</target>
        </trans-unit>
        <trans-unit id="55d88c56f438dcd5396ed9988909235b18a2ae07" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;add()&lt;/code&gt; with a many-to-many relationship, however, will not call any &lt;code&gt;save()&lt;/code&gt; methods (the &lt;code&gt;bulk&lt;/code&gt; argument doesn&amp;rsquo;t exist), but rather create the relationships using &lt;a href=&quot;querysets#django.db.models.query.QuerySet.bulk_create&quot;&gt;&lt;code&gt;QuerySet.bulk_create()&lt;/code&gt;&lt;/a&gt;. If you need to execute some custom logic when a relationship is created, listen to the &lt;a href=&quot;../signals#django.db.models.signals.m2m_changed&quot;&gt;&lt;code&gt;m2m_changed&lt;/code&gt;&lt;/a&gt; signal, which will trigger &lt;code&gt;pre_add&lt;/code&gt; and &lt;code&gt;post_add&lt;/code&gt; actions.</source>
          <target state="translated">그러나 다 대다 관계로 &lt;code&gt;add()&lt;/code&gt; 를 사용하면 &lt;code&gt;save()&lt;/code&gt; 메소드를 호출 하지 않고 ( &lt;code&gt;bulk&lt;/code&gt; 인수가 존재하지 않음) &lt;a href=&quot;querysets#django.db.models.query.QuerySet.bulk_create&quot;&gt; &lt;code&gt;QuerySet.bulk_create()&lt;/code&gt; &lt;/a&gt; 사용하여 관계를 작성하십시오 . 관계가 생성 될 때 사용자 지정 논리를 실행해야하는 경우 &lt;a href=&quot;../signals#django.db.models.signals.m2m_changed&quot;&gt; &lt;code&gt;m2m_changed&lt;/code&gt; &lt;/a&gt; 신호를 수신 하면 &lt;code&gt;pre_add&lt;/code&gt; 및 &lt;code&gt;post_add&lt;/code&gt; 작업 이 트리거됩니다 .</target>
        </trans-unit>
        <trans-unit id="5acf28b1bd09990263617fd374ec302c0aec5985" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;bcrypt&lt;/code&gt; with Django</source>
          <target state="translated">Django와 함께 &lt;code&gt;bcrypt&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="2b19af77d241f81b5ac425ae85ab9a1f7b4f4e8c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;fields&lt;/code&gt; restricts the formset to use only the given fields. Alternatively, you can take an &amp;ldquo;opt-out&amp;rdquo; approach, specifying which fields to exclude:</source>
          <target state="translated">사용 &lt;code&gt;fields&lt;/code&gt; 에만 주어진 필드를 사용하여 해당 formset을 제한합니다. 또는 제외 할 필드를 지정하여 &quot;opt-out&quot;접근 방식을 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="039acdb52ac92a1cfd3e9639964236e7ca1c9e7a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;flatten()&lt;/code&gt; method you can get whole &lt;code&gt;Context&lt;/code&gt; stack as one dictionary including builtin variables.</source>
          <target state="translated">&lt;code&gt;flatten()&lt;/code&gt; 메소드를 사용하면 내장 변수를 포함한 하나의 사전으로 전체 &lt;code&gt;Context&lt;/code&gt; 스택을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e88500185b2ad0f0dd422c60cf35b2223ff6b337" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;floatformat&lt;/code&gt; with no argument is equivalent to using &lt;code&gt;floatformat&lt;/code&gt; with an argument of &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">사용 &lt;code&gt;floatformat&lt;/code&gt; 를 인수없이 사용하는 것은 동일하다 &lt;code&gt;floatformat&lt;/code&gt; 을 의 인자에 &lt;code&gt;-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4511ef3dae490655332edf14f92cdd6836d8fe77" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;get_queryset()&lt;/code&gt; with multiple databases</source>
          <target state="translated">여러 데이터베이스에서 &lt;code&gt;get_queryset()&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="c3573e1315745e058aea0948cb1e8909b3c77ca1" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;get_queryset&lt;/code&gt; to add logic to the queryset selection is as convenient as it is powerful. For instance, if we wanted, we could use &lt;code&gt;self.request.user&lt;/code&gt; to filter using the current user, or other more complex logic.</source>
          <target state="translated">&lt;code&gt;get_queryset&lt;/code&gt; 을 사용하여 쿼리 세트 선택에 논리를 추가하는 것이 강력 할 때만 큼 편리합니다. 예를 들어, 원한다면 &lt;code&gt;self.request.user&lt;/code&gt; 를 사용하여 현재 사용자 또는 다른 복잡한 로직을 사용하여 필터링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="427aa7c7f286ded4302712ef858f7941069f5da8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;gettext_lazy()&lt;/code&gt; and &lt;code&gt;ngettext_lazy()&lt;/code&gt; to mark strings in models and utility functions is a common operation. When you&amp;rsquo;re working with these objects elsewhere in your code, you should ensure that you don&amp;rsquo;t accidentally convert them to strings, because they should be converted as late as possible (so that the correct locale is in effect). This necessitates the use of the helper function described next.</source>
          <target state="translated">사용 &lt;code&gt;gettext_lazy()&lt;/code&gt; 와 &lt;code&gt;ngettext_lazy()&lt;/code&gt; 모델 및 유틸리티 함수에 문자열을 표시하는 것은 일반적인 작업입니다. 코드의 다른 곳에서 이러한 객체로 작업 할 때는 가능한 한 늦게 변환해야하므로 (올바른 로케일이 적용되도록) 실수로 문자열로 변환하지 않아야합니다. 이를 위해서는 다음에 설명 된 도우미 기능을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8856f8f8d77239a5102a36a2a398e9528cbb2e29" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;mod_wsgi&lt;/code&gt; daemon mode</source>
          <target state="translated">사용 &lt;code&gt;mod_wsgi&lt;/code&gt; 에의 데몬 모드를</target>
        </trans-unit>
        <trans-unit id="6dcd5d80d3dead15560e306d8abd6e6d1e83d519" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;reset_sequences = True&lt;/code&gt; will slow down the test, since the primary key reset is a relatively expensive database operation.</source>
          <target state="translated">기본 키 재설정은 비교적 비싼 데이터베이스 작업 &lt;code&gt;reset_sequences = True&lt;/code&gt; 사용 하면 테스트 속도가 느려집니다.</target>
        </trans-unit>
        <trans-unit id="03bd039600d68a99bed9b64b0b880a87f9a2422d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;select_for_update()&lt;/code&gt; on backends which do not support &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt; (such as SQLite) will have no effect. &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt; will not be added to the query, and an error isn&amp;rsquo;t raised if &lt;code&gt;select_for_update()&lt;/code&gt; is used in autocommit mode.</source>
          <target state="translated">&lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt; (예 : SQLite)를 지원하지 않는 백엔드에서 &lt;code&gt;select_for_update()&lt;/code&gt; 를 사용하면 아무 효과가 없습니다. &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt; 는 쿼리에 추가되지 않으며 &lt;code&gt;select_for_update()&lt;/code&gt; 가 자동 커밋 모드에서 사용 되면 오류가 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d9baca10f1c201ac0b7a615f0d932a766dd3f7f2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;to_attr&lt;/code&gt; is recommended when filtering down the prefetch result as it is less ambiguous than storing a filtered result in the related manager&amp;rsquo;s cache:</source>
          <target state="translated">프리 페치 결과를 필터링 할 때 관련 관리자 캐시에 필터링 된 결과를 저장하는 것보다 덜 모호하므로 &lt;code&gt;to_attr&lt;/code&gt; 을 사용 하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a9ae85568273877dc93b343fd9d078c2d322deaf" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;update()&lt;/code&gt; also prevents a race condition wherein something might change in your database in the short period of time between loading the object and calling &lt;code&gt;save()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;update()&lt;/code&gt; 사용 하면 객체로드와 &lt;code&gt;save()&lt;/code&gt; 호출 사이에 짧은 시간 내에 데이터베이스에서 무언가가 변경 될 수있는 경쟁 조건이 방지 됩니다.</target>
        </trans-unit>
        <trans-unit id="8abc2ab7403186ea06b014edd02f87ba112c2c9e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;update_fields&lt;/code&gt; will force an update similarly to &lt;code&gt;force_update&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;update_fields&lt;/code&gt; 를 사용하면 &lt;code&gt;force_update&lt;/code&gt; 와 유사하게 업데이트가 수행 됩니다.</target>
        </trans-unit>
        <trans-unit id="ca34e58511e7303e69e810e3398f97b3b363306f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;{{ form.name_of_field.errors }}&lt;/code&gt; displays a list of form errors, rendered as an unordered list. This might look like:</source>
          <target state="translated">&lt;code&gt;{{ form.name_of_field.errors }}&lt;/code&gt; 사용하면 양식 오류 목록이 정렬되지 않은 목록으로 표시됩니다. 이것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8e899daa0ce71ec5504c502a55876050d3c44c1f" translate="yes" xml:space="preserve">
          <source>Using Apache 2.2 with authentication</source>
          <target state="translated">인증과 함께 Apache 2.2 사용</target>
        </trans-unit>
        <trans-unit id="e05ac861d5058b9153e223e6baa38b194b688bd1" translate="yes" xml:space="preserve">
          <source>Using Argon2 with Django</source>
          <target state="translated">Django와 함께 Argon2 사용</target>
        </trans-unit>
        <trans-unit id="a8d1d7cc6a0d6f8d0df20e490f66f73a702f1246" translate="yes" xml:space="preserve">
          <source>Using CSRF in Jinja2 templates</source>
          <target state="translated">Jinja2 템플릿에서 CSRF 사용</target>
        </trans-unit>
        <trans-unit id="fcc8b59a085eaea0754d276a0eb696a4b666cb29" translate="yes" xml:space="preserve">
          <source>Using Django</source>
          <target state="translated">장고 사용하기</target>
        </trans-unit>
        <trans-unit id="cd5bb4a549b9c32bc6f124b1f245addac8cb79e0" translate="yes" xml:space="preserve">
          <source>Using Django templates protects you against the majority of XSS attacks. However, it is important to understand what protections it provides and its limitations.</source>
          <target state="translated">Django 템플릿을 사용하면 대부분의 XSS 공격으로부터 보호 할 수 있습니다. 그러나 어떤 보호 기능과 제한 사항을 이해하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="6c364cef6c7f2ec56ce45c43c7c5348a456206ef" translate="yes" xml:space="preserve">
          <source>Using Django&amp;rsquo;s class-based view mixins</source>
          <target state="translated">Django의 클래스 기반 뷰 믹스 인 사용</target>
        </trans-unit>
        <trans-unit id="91764571bd2d96046a1bfab77a8b340993799415" translate="yes" xml:space="preserve">
          <source>Using Django&amp;rsquo;s default implementation</source>
          <target state="translated">Django의 기본 구현 사용</target>
        </trans-unit>
        <trans-unit id="e4e1565e7633ecce85000b862d43d0350d6c8c07" translate="yes" xml:space="preserve">
          <source>Using GDAL&amp;rsquo;s Virtual Filesystem</source>
          <target state="translated">GDAL의 가상 파일 시스템 사용</target>
        </trans-unit>
        <trans-unit id="2997d82b6f6f0b482087ec1829760c2ab11d1f43" translate="yes" xml:space="preserve">
          <source>Using Jinja2 templates?</source>
          <target state="translated">Jinja2 템플릿을 사용하십니까?</target>
        </trans-unit>
        <trans-unit id="e442c9139b072335fe05c4d7e693b8ef2e853571" translate="yes" xml:space="preserve">
          <source>Using a 3rd-party database backend</source>
          <target state="translated">타사 데이터베이스 백엔드 사용</target>
        </trans-unit>
        <trans-unit id="642c11eb942723edae1f7421c59da61fe8b8bd6d" translate="yes" xml:space="preserve">
          <source>Using a &lt;a href=&quot;#django.db.models.FileField&quot;&gt;&lt;code&gt;FileField&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;#django.db.models.ImageField&quot;&gt;&lt;code&gt;ImageField&lt;/code&gt;&lt;/a&gt; (see below) in a model takes a few steps:</source>
          <target state="translated">사용 &lt;a href=&quot;#django.db.models.FileField&quot;&gt; &lt;code&gt;FileField&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#django.db.models.ImageField&quot;&gt; &lt;code&gt;ImageField&lt;/code&gt; &lt;/a&gt; 모델에 (아래 참조) 몇 단계를 수행합니다</target>
        </trans-unit>
        <trans-unit id="d980db7d9bf092411f9376ef23d0ff9e0c242fe2" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;Context&lt;/code&gt; as a stack comes in handy in &lt;a href=&quot;../../howto/custom-template-tags#howto-writing-custom-template-tags&quot;&gt;some custom template tags&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Context&lt;/code&gt; 를 스택으로 사용하면 &lt;a href=&quot;../../howto/custom-template-tags#howto-writing-custom-template-tags&quot;&gt;일부 사용자 정의 템플릿 태그&lt;/a&gt; 에서 편리 합니다 .</target>
        </trans-unit>
        <trans-unit id="111c55353137548e9daf8a2ee1edd88613fb7b72" translate="yes" xml:space="preserve">
          <source>Using a connection pooler in transaction pooling mode (e.g. &lt;a href=&quot;https://pgbouncer.github.io/&quot;&gt;pgBouncer&lt;/a&gt;) requires disabling server-side cursors for that connection.</source>
          <target state="translated">트랜잭션 풀링 모드 (예 : &lt;a href=&quot;https://pgbouncer.github.io/&quot;&gt;pgBouncer&lt;/a&gt; ) 에서 연결 풀러를 사용 하려면 해당 연결에 대해 서버 측 커서를 비활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="e718b4edbe1f8f94597125a8692544c848614110" translate="yes" xml:space="preserve">
          <source>Using a cursor as a context manager:</source>
          <target state="translated">컨텍스트 관리자로 커서 사용 :</target>
        </trans-unit>
        <trans-unit id="f2b5d2bb6073fdfcd60745dcc3038452ff9dfa6d" translate="yes" xml:space="preserve">
          <source>Using a custom cache backend</source>
          <target state="translated">사용자 정의 캐시 백엔드 사용</target>
        </trans-unit>
        <trans-unit id="4ed8a31148ab2393e9f95e90c2eff0e8761cf0c7" translate="yes" xml:space="preserve">
          <source>Using a custom queryset</source>
          <target state="translated">맞춤 검색어 사용</target>
        </trans-unit>
        <trans-unit id="43ee37d685f1736d2d9a4ec2cccc82de7072f531" translate="yes" xml:space="preserve">
          <source>Using a custom reverse manager</source>
          <target state="translated">커스텀 리버스 매니저 사용하기</target>
        </trans-unit>
        <trans-unit id="8f30c53065d1a8f29f5826d7a3c55766efd3f518" translate="yes" xml:space="preserve">
          <source>Using a custom user model when starting a project</source>
          <target state="translated">프로젝트를 시작할 때 사용자 정의 사용자 모델 사용</target>
        </trans-unit>
        <trans-unit id="ac5fc9a6e6dd9fd7e0756e971ff223c0650d7618" translate="yes" xml:space="preserve">
          <source>Using a formset in views and templates</source>
          <target state="translated">뷰 및 템플릿에서 폼셋 사용</target>
        </trans-unit>
        <trans-unit id="62a42325a81cdd46ba2b7cefcfec8c8e044912c6" translate="yes" xml:space="preserve">
          <source>Using a formset inside a view is not very different from using a regular &lt;code&gt;Form&lt;/code&gt; class. The only thing you will want to be aware of is making sure to use the management form inside the template. Let&amp;rsquo;s look at a sample view:</source>
          <target state="translated">뷰 내에서 폼셋을 사용하는 것은 일반 &lt;code&gt;Form&lt;/code&gt; 클래스 를 사용하는 것과 크게 다르지 않습니다 . 알고 싶은 것은 템플릿 내부에서 관리 양식을 사용하는 것입니다. 샘플 뷰를 보자.</target>
        </trans-unit>
        <trans-unit id="554f1d02415f3045d2c5c14e8a1f5bf8c94f8a36" translate="yes" xml:space="preserve">
          <source>Using a model formset in a view</source>
          <target state="translated">뷰에서 모델 폼셋 사용</target>
        </trans-unit>
        <trans-unit id="db3324bd54ed9eeed57a55679e9c833aaf4916fb" translate="yes" xml:space="preserve">
          <source>Using a named tuple may make use of the results more readable, at the expense of a small performance penalty for transforming the results into a named tuple.</source>
          <target state="translated">명명 된 튜플을 사용하면 결과를 명명 된 튜플로 변환하는 데 약간의 성능 저하로 인해 결과를 더 읽기 쉽게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ac0fcd6222036020612a574b9621ca2cac6cf37" translate="yes" xml:space="preserve">
          <source>Using a non-English base language</source>
          <target state="translated">영어 이외의 기본 언어 사용</target>
        </trans-unit>
        <trans-unit id="14aa51fa69a9ae47b4024aa7c6a23dee4abfaba5" translate="yes" xml:space="preserve">
          <source>Using aggregates within a &lt;code&gt;Subquery&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;Subquery&lt;/code&gt; 표현식 내에서 집계 사용</target>
        </trans-unit>
        <trans-unit id="a2827914354d99fe0075fba7ea5460a51fbd4f2f" translate="yes" xml:space="preserve">
          <source>Using an &lt;code&gt;ImageField&lt;/code&gt; requires that &lt;a href=&quot;https://pillow.readthedocs.io/en/latest/&quot;&gt;Pillow&lt;/a&gt; is installed with support for the image formats you use. If you encounter a &lt;code&gt;corrupt image&lt;/code&gt; error when you upload an image, it usually means that Pillow doesn&amp;rsquo;t understand its format. To fix this, install the appropriate library and reinstall Pillow.</source>
          <target state="translated">&lt;code&gt;ImageField&lt;/code&gt; 를 사용 하려면 사용하는 이미지 형식을 지원 하는 &lt;a href=&quot;https://pillow.readthedocs.io/en/latest/&quot;&gt;베개&lt;/a&gt; 가 설치되어 있어야합니다. 당신이 발생하면 &lt;code&gt;corrupt image&lt;/code&gt; 는 이미지를 업로드 할 때 오류, 보통 수단 베개는 형식을 이해하지 않습니다. 이 문제를 해결하려면 적절한 라이브러리를 설치하고 필로우를 다시 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="899a9c4925a0559fe4ce33d9cd243a4e2f7f04ec" translate="yes" xml:space="preserve">
          <source>Using an alternative implementation may introduce compatibility, deployment, portability, or maintenance issues. It goes without saying that before adopting a non-standard implementation you should ensure it provides sufficient performance gains for your application to outweigh the potential risks.</source>
          <target state="translated">대체 구현을 사용하면 호환성, 배포, 이식성 또는 유지 관리 문제가 발생할 수 있습니다. 비표준 구현을 채택하기 전에 잠재적 인 위험을 능가 할 수있는 충분한 성능 향상을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="4047bded8c1c1e1deab6956c159c6c37394bc632" translate="yes" xml:space="preserve">
          <source>Using an inline formset in a view</source>
          <target state="translated">뷰에서 인라인 폼셋 사용</target>
        </trans-unit>
        <trans-unit id="09008c6e49eab9cde27b4c36a436b69d9c12a28b" translate="yes" xml:space="preserve">
          <source>Using cached sessions</source>
          <target state="translated">캐시 된 세션 사용</target>
        </trans-unit>
        <trans-unit id="712e243532dae57a4a508def1a52fcc093cfe453" translate="yes" xml:space="preserve">
          <source>Using class-based views</source>
          <target state="translated">클래스 기반 뷰 사용</target>
        </trans-unit>
        <trans-unit id="219b33243ea77db284122c06a23a335486827ca8" translate="yes" xml:space="preserve">
          <source>Using context processors with Jinja2 templates is discouraged.</source>
          <target state="translated">Jinja2 템플릿과 함께 컨텍스트 프로세서를 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9b5e521be6207ccf6984218b0f3f6cfaeef47736" translate="yes" xml:space="preserve">
          <source>Using cookie-based sessions</source>
          <target state="translated">쿠키 기반 세션 사용</target>
        </trans-unit>
        <trans-unit id="e963177b880b3107082891701819119d5a3c4952" translate="yes" xml:space="preserve">
          <source>Using database-backed sessions</source>
          <target state="translated">데이터베이스 기반 세션 사용</target>
        </trans-unit>
        <trans-unit id="722d50240897f7ae0e4cf8ed772f8e17a88c6692" translate="yes" xml:space="preserve">
          <source>Using different testing frameworks</source>
          <target state="translated">다른 테스트 프레임 워크 사용</target>
        </trans-unit>
        <trans-unit id="91407b7ece83eef5dce52bf7f80c98bfa8d97713" translate="yes" xml:space="preserve">
          <source>Using different versions of available software</source>
          <target state="translated">사용 가능한 소프트웨어의 다른 버전 사용</target>
        </trans-unit>
        <trans-unit id="30a5103ae8eec9a9c1b5e20061ad0468d854eb13" translate="yes" xml:space="preserve">
          <source>Using either one of these features requires that an active language be set for each request; in other words, you need to have &lt;a href=&quot;../../ref/middleware#django.middleware.locale.LocaleMiddleware&quot;&gt;&lt;code&gt;django.middleware.locale.LocaleMiddleware&lt;/code&gt;&lt;/a&gt; in your &lt;a href=&quot;../../ref/settings#std:setting-MIDDLEWARE&quot;&gt;&lt;code&gt;MIDDLEWARE&lt;/code&gt;&lt;/a&gt; setting.</source>
          <target state="translated">이러한 기능 중 하나를 사용하려면 각 요청에 대해 활성 언어를 설정해야합니다. 즉, 당신은 할 필요가 &lt;a href=&quot;../../ref/middleware#django.middleware.locale.LocaleMiddleware&quot;&gt; &lt;code&gt;django.middleware.locale.LocaleMiddleware&lt;/code&gt; 을&lt;/a&gt; 당신의 &lt;a href=&quot;../../ref/settings#std:setting-MIDDLEWARE&quot;&gt; &lt;code&gt;MIDDLEWARE&lt;/code&gt; &lt;/a&gt; 설정.</target>
        </trans-unit>
        <trans-unit id="94899c6a3467596b737d710599f463e0a5fefab4" translate="yes" xml:space="preserve">
          <source>Using file-based sessions</source>
          <target state="translated">파일 기반 세션 사용</target>
        </trans-unit>
        <trans-unit id="396ca845e263c8cba2f72b24ba14f0bb213b6969" translate="yes" xml:space="preserve">
          <source>Using files in models</source>
          <target state="translated">모델에서 파일 사용</target>
        </trans-unit>
        <trans-unit id="53415d30f410d9eaa46365eda26aa38b029be4c2" translate="yes" xml:space="preserve">
          <source>Using forms to validate data</source>
          <target state="translated">양식을 사용하여 데이터 유효성 검사</target>
        </trans-unit>
        <trans-unit id="f7abd395b7d9e7bcc61766a85ccb669c81d39541" translate="yes" xml:space="preserve">
          <source>Using generic relations as an inline</source>
          <target state="translated">일반 관계를 인라인으로 사용</target>
        </trans-unit>
        <trans-unit id="d3efb3102778069f675e857fd0eeb2c948c7eca3" translate="yes" xml:space="preserve">
          <source>Using initial data with a formset</source>
          <target state="translated">폼셋과 함께 초기 데이터 사용</target>
        </trans-unit>
        <trans-unit id="459816856889e1240afd58cac446eb13de2bf33e" translate="yes" xml:space="preserve">
          <source>Using logging</source>
          <target state="translated">로깅 사용</target>
        </trans-unit>
        <trans-unit id="7e7f28c61f2b667796155286733724e7db2835d4" translate="yes" xml:space="preserve">
          <source>Using managers for related object access</source>
          <target state="translated">관련 개체 액세스에 관리자 사용</target>
        </trans-unit>
        <trans-unit id="d639ac959d5c0b2ddde832ed6431f77e13d03c2a" translate="yes" xml:space="preserve">
          <source>Using managers with multiple databases</source>
          <target state="translated">여러 데이터베이스에서 관리자 사용</target>
        </trans-unit>
        <trans-unit id="a562ed381203352442504a5755ffaa5a9ddc5506" translate="yes" xml:space="preserve">
          <source>Using messages in views and templates</source>
          <target state="translated">보기 및 템플릿에서 메시지 사용</target>
        </trans-unit>
        <trans-unit id="54a59821b006489f143ba9ff1774c5e1eb660ec1" translate="yes" xml:space="preserve">
          <source>Using mixins</source>
          <target state="translated">믹스 인 사용</target>
        </trans-unit>
        <trans-unit id="3b505367a73d0f30530501f569cf8d66cb316242" translate="yes" xml:space="preserve">
          <source>Using mixins with class-based views</source>
          <target state="translated">클래스 기반 뷰에서 믹스 인 사용</target>
        </trans-unit>
        <trans-unit id="fa5d07edc488e375d172798cad0bfe3830d3be56" translate="yes" xml:space="preserve">
          <source>Using models</source>
          <target state="translated">모델 사용</target>
        </trans-unit>
        <trans-unit id="5e4776a63386fd9267b226c945a1b3275a3f2e2b" translate="yes" xml:space="preserve">
          <source>Using more than one formset in a view</source>
          <target state="translated">뷰에서 둘 이상의 폼셋 사용</target>
        </trans-unit>
        <trans-unit id="a3bf09f1e97f7bcd6438f31c0e77e29c6ce13da0" translate="yes" xml:space="preserve">
          <source>Using other management commands</source>
          <target state="translated">다른 관리 명령 사용</target>
        </trans-unit>
        <trans-unit id="da23df4511acb0fe5c38fc44856610089abb9886" translate="yes" xml:space="preserve">
          <source>Using raw cursors with multiple databases</source>
          <target state="translated">여러 데이터베이스에서 원시 커서 사용</target>
        </trans-unit>
        <trans-unit id="38ecb5a74be8eb3ad805ff07aca2f34559f33e2f" translate="yes" xml:space="preserve">
          <source>Using raw strings (e.g., &lt;code&gt;r'foo'&lt;/code&gt; instead of &lt;code&gt;'foo'&lt;/code&gt;) for passing in the regular expression syntax is recommended.</source>
          <target state="translated">정규 표현식 구문을 전달하기 위해 원시 문자열 (예 : &lt;code&gt;'foo'&lt;/code&gt; 대신 &lt;code&gt;r'foo'&lt;/code&gt; ' )을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="18988fc8caaba44179708163dbb1aad1050b3dcd" translate="yes" xml:space="preserve">
          <source>Using regular expressions</source>
          <target state="translated">정규 표현식 사용</target>
        </trans-unit>
        <trans-unit id="a9cc1741d165448eff74bcae7a3e3908595538ad" translate="yes" xml:space="preserve">
          <source>Using related models results in additional queries or joins to retrieve the related data. Depending on your needs, a custom user model that includes the related fields may be your better option, however, existing relations to the default user model within your project&amp;rsquo;s apps may justify the extra database load.</source>
          <target state="translated">관련 모델을 사용하면 관련 데이터를 검색하기 위해 추가 쿼리 또는 조인이 발생합니다. 필요에 따라 관련 필드를 포함하는 사용자 지정 사용자 모델이 더 나은 옵션 일 수 있지만 프로젝트 앱 내 기본 사용자 모델과의 기존 관계는 추가 데이터베이스로드를 정당화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a05e29bf07e9996682f553c9a5402b7ef382c513" translate="yes" xml:space="preserve">
          <source>Using routers</source>
          <target state="translated">라우터 사용</target>
        </trans-unit>
        <trans-unit id="c78e51a835808de3e9a9397afc60c4ef984e7144" translate="yes" xml:space="preserve">
          <source>Using salt in this way puts the different signatures into different namespaces. A signature that comes from one namespace (a particular salt value) cannot be used to validate the same plaintext string in a different namespace that is using a different salt setting. The result is to prevent an attacker from using a signed string generated in one place in the code as input to another piece of code that is generating (and verifying) signatures using a different salt.</source>
          <target state="translated">이런 방식으로 salt를 사용하면 다른 서명이 다른 네임 스페이스에 배치됩니다. 하나의 네임 스페이스 (특정 솔트 값)에서 가져온 서명을 사용하여 다른 솔트 설정을 사용하는 다른 네임 스페이스에서 동일한 일반 텍스트 문자열의 유효성을 검사 할 수 없습니다. 결과적으로 공격자는 코드의 한 위치에서 생성 된 부호있는 문자열을 다른 소금을 사용하여 서명을 생성 (및 확인)하는 다른 코드에 대한 입력으로 사용하지 못하게됩니다.</target>
        </trans-unit>
        <trans-unit id="bba38cc11217dc042aa7082661f9b1799f84a4c1" translate="yes" xml:space="preserve">
          <source>Using sessions in views</source>
          <target state="translated">뷰에서 세션 사용</target>
        </trans-unit>
        <trans-unit id="3c07b1e7a86ae545464f8a5e4d28a0455a58a067" translate="yes" xml:space="preserve">
          <source>Using sessions out of views</source>
          <target state="translated">보기에서 벗어난 세션 사용</target>
        </trans-unit>
        <trans-unit id="37999324c24e63b8affa3e0800da106fa1a6135a" translate="yes" xml:space="preserve">
          <source>Using settings in Python code</source>
          <target state="translated">파이썬 코드에서 설정 사용</target>
        </trans-unit>
        <trans-unit id="e5adbccdcf800861d1cee63d526315264c0caee5" translate="yes" xml:space="preserve">
          <source>Using settings without setting &lt;code&gt;DJANGO_SETTINGS_MODULE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;DJANGO_SETTINGS_MODULE&lt;/code&gt; 을 설정하지 않고 설정 사용</target>
        </trans-unit>
        <trans-unit id="ac88b3fee6d9019798db8365e7b93e589686ab06" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;#django.test.SimpleTestCase.client&quot;&gt;&lt;code&gt;client&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;#django.test.Client&quot;&gt;&lt;code&gt;Client&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#django.test.SimpleTestCase.client&quot;&gt; &lt;code&gt;client&lt;/code&gt; &lt;/a&gt; 사용 &lt;a href=&quot;#django.test.Client&quot;&gt; &lt;code&gt;Client&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2a4088855a0650aae6391fe4b7364d7fd81adccf" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;../ref/utils#django.utils.functional.cached_property&quot;&gt;&lt;code&gt;cached_property&lt;/code&gt;&lt;/a&gt; decorator saves the value returned by a property; the next time the function is called on that instance, it will return the saved value rather than re-computing it. Note that this only works on methods that take &lt;code&gt;self&lt;/code&gt; as their only argument and that it changes the method to a property.</source>
          <target state="translated">&lt;a href=&quot;../ref/utils#django.utils.functional.cached_property&quot;&gt; &lt;code&gt;cached_property&lt;/code&gt; &lt;/a&gt; 데코레이터를 사용하면 속성에서 반환 된 값이 저장됩니다. 다음에 해당 인스턴스에서 함수를 호출하면 저장된 값을 다시 계산하지 않고 반환합니다. 참고이 단지 걸릴 방법에 작동 &lt;code&gt;self&lt;/code&gt; 유일한 인수로 그리고 그것은 재산에 대한 방법을 변경하는 것이다.</target>
        </trans-unit>
        <trans-unit id="63cdfe9e1c37c173d8bbf7c99d274b35062cfb2c" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;Entry&lt;/code&gt; example above, the following two statements are equivalent:</source>
          <target state="translated">위 의 &lt;code&gt;Entry&lt;/code&gt; 예제를 사용하면 다음 두 명령문은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f63700f11e33ca9cebf526f3424fec7dcd18baef" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;localized_fields&lt;/code&gt; parameter, you can enable localization for fields in the form.</source>
          <target state="translated">&lt;code&gt;localized_fields&lt;/code&gt; 매개 변수를 사용하면 양식에서 필드의 현지화를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3561c519a106d78786967e6e5ab97c000946b087" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;salt&lt;/code&gt; argument</source>
          <target state="translated">은 Using &lt;code&gt;salt&lt;/code&gt; 인수를</target>
        </trans-unit>
        <trans-unit id="15ad75ac1567453b20adde00c041ccc2df84a0b6" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;widgets&lt;/code&gt; parameter, you can specify a dictionary of values to customize the &lt;code&gt;ModelForm&lt;/code&gt;&amp;rsquo;s widget class for a particular field. This works the same way as the &lt;code&gt;widgets&lt;/code&gt; dictionary on the inner &lt;code&gt;Meta&lt;/code&gt; class of a &lt;code&gt;ModelForm&lt;/code&gt; works:</source>
          <target state="translated">&lt;code&gt;widgets&lt;/code&gt; 매개 변수를 사용하여 값 사전을 지정하여 특정 필드에 대한 &lt;code&gt;ModelForm&lt;/code&gt; 의 위젯 클래스 를 사용자 정의 할 수 있습니다 . 이것은 &lt;code&gt;ModelForm&lt;/code&gt; 의 내부 &lt;code&gt;Meta&lt;/code&gt; 클래스에있는 &lt;code&gt;widgets&lt;/code&gt; 사전 과 같은 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="661566691fa044ff4e089905a69fb1bdef2450fe" translate="yes" xml:space="preserve">
          <source>Using the Django authentication system</source>
          <target state="translated">Django 인증 시스템 사용</target>
        </trans-unit>
        <trans-unit id="1d702f2bf5fde5187f538ba36a04680276f94cf2" translate="yes" xml:space="preserve">
          <source>Using the Django test runner to test reusable applications</source>
          <target state="translated">Django 테스트 러너를 사용하여 재사용 가능한 애플리케이션 테스트</target>
        </trans-unit>
        <trans-unit id="ecf17c47e1f42f1b44e2dd8414284049a1f64782" translate="yes" xml:space="preserve">
          <source>Using the JavaScript translation catalog</source>
          <target state="translated">JavaScript 번역 카탈로그 사용</target>
        </trans-unit>
        <trans-unit id="93436abaf3f289f71fad6be4ae2eee21c3aba0f7" translate="yes" xml:space="preserve">
          <source>Using the Python CSV library</source>
          <target state="translated">Python CSV 라이브러리 사용</target>
        </trans-unit>
        <trans-unit id="ca22ebd07b6cf67b2b0910519965287ba635921f" translate="yes" xml:space="preserve">
          <source>Using the URLconf</source>
          <target state="translated">URLconf 사용</target>
        </trans-unit>
        <trans-unit id="be93b82fa1b8507dec9d6a64171f583efdf10315" translate="yes" xml:space="preserve">
          <source>Using the decorators with other HTTP methods</source>
          <target state="translated">다른 HTTP 메소드와 함께 데코레이터 사용</target>
        </trans-unit>
        <trans-unit id="7d0bc78b7817642ff9929ca2925be4b7924ff499" translate="yes" xml:space="preserve">
          <source>Using the formset in the template</source>
          <target state="translated">템플릿에서 폼셋 사용</target>
        </trans-unit>
        <trans-unit id="815235c7cdf01efac8a2d52e29479788c7d74fb3" translate="yes" xml:space="preserve">
          <source>Using the low-level API</source>
          <target state="translated">저수준 API 사용</target>
        </trans-unit>
        <trans-unit id="cb188ff02b9a0523149bba733ccf29acf02a61ba" translate="yes" xml:space="preserve">
          <source>Using the middleware</source>
          <target state="translated">미들웨어 사용</target>
        </trans-unit>
        <trans-unit id="77d723f298255b5c5fa52336710b52e11b0b4c76" translate="yes" xml:space="preserve">
          <source>Using the models at the top of this page, for example, an &lt;code&gt;Entry&lt;/code&gt; object &lt;code&gt;e&lt;/code&gt; can get its associated &lt;code&gt;Blog&lt;/code&gt; object by accessing the &lt;code&gt;blog&lt;/code&gt; attribute: &lt;code&gt;e.blog&lt;/code&gt;.</source>
          <target state="translated">예를 들어,이 페이지의 맨 위에있는 모델을 사용하여 &lt;code&gt;Entry&lt;/code&gt; 오브젝트 &lt;code&gt;e&lt;/code&gt; 는 &lt;code&gt;blog&lt;/code&gt; 속성 &lt;code&gt;e.blog&lt;/code&gt; 에 액세스하여 연관된 &lt;code&gt;Blog&lt;/code&gt; 오브젝트를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="06c614313c96fb0af3bfe23f148af5d8141ae7ad" translate="yes" xml:space="preserve">
          <source>Using the parameters, a slightly more complex version of the blocker could include the connection name in the error message:</source>
          <target state="translated">매개 변수를 사용하면 약간 더 복잡한 버전의 차단기가 오류 메시지에 연결 이름을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e53963dfe0a1fc2a212f3c4ff9b628f2420e818" translate="yes" xml:space="preserve">
          <source>Using the result multiple times in each template.</source>
          <target state="translated">각 템플릿에서 결과를 여러 번 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2d76080bcad973ee8659bf823f8341e9cdcb01a2" translate="yes" xml:space="preserve">
          <source>Using the same &lt;a href=&quot;../ref/settings#std:setting-TEMPLATES&quot;&gt;&lt;code&gt;TEMPLATES&lt;/code&gt;&lt;/a&gt; option as above, this will attempt to load the following templates:</source>
          <target state="translated">위와 동일한 &lt;a href=&quot;../ref/settings#std:setting-TEMPLATES&quot;&gt; &lt;code&gt;TEMPLATES&lt;/code&gt; &lt;/a&gt; 옵션을 사용하면 다음 템플릿을로드하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="9fbbd5375161aa64abb0617a231597b64c460223" translate="yes" xml:space="preserve">
          <source>Using the template system</source>
          <target state="translated">템플릿 시스템 사용</target>
        </trans-unit>
        <trans-unit id="61e2bf83bb86f60fd447308f6616a261218345ef" translate="yes" xml:space="preserve">
          <source>Using the template system in Python is a three-step process:</source>
          <target state="translated">파이썬에서 템플릿 시스템을 사용하는 것은 3 단계 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="5377b9ee650ece2fb2a4d8587e3ca7c80984bb0f" translate="yes" xml:space="preserve">
          <source>Using the views</source>
          <target state="translated">뷰 사용</target>
        </trans-unit>
        <trans-unit id="06f38a09cd7db1bb0ae52d6487b6bada3e4df33f" translate="yes" xml:space="preserve">
          <source>Using these methods, you can write high-level generic code that performs queries on any installed model &amp;ndash; instead of importing and using a single specific model class, you can pass an &lt;code&gt;app_label&lt;/code&gt; and &lt;code&gt;model&lt;/code&gt; into a &lt;a href=&quot;#django.contrib.contenttypes.models.ContentType&quot;&gt;&lt;code&gt;ContentType&lt;/code&gt;&lt;/a&gt; lookup at runtime, and then work with the model class or retrieve objects from it.</source>
          <target state="translated">이러한 방법을 사용하면 설치된 특정 모델에서 쿼리를 수행하는 고급 일반 코드를 작성할 수 있습니다. 단일 특정 모델 클래스를 가져오고 사용하는 대신 &lt;code&gt;app_label&lt;/code&gt; 및 &lt;code&gt;model&lt;/code&gt; 을 런타임에 &lt;a href=&quot;#django.contrib.contenttypes.models.ContentType&quot;&gt; &lt;code&gt;ContentType&lt;/code&gt; &lt;/a&gt; 조회에 전달한 다음 모델 클래스를 만들거나 객체를 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="431e90afd5f06e6bd944377797ad9c73357f38e2" translate="yes" xml:space="preserve">
          <source>Using this bookmarklet requires that &lt;code&gt;XViewMiddleware&lt;/code&gt; is installed and that you are logged into the &lt;a href=&quot;index#module-django.contrib.admin&quot;&gt;&lt;code&gt;Django admin&lt;/code&gt;&lt;/a&gt; as a &lt;a href=&quot;../auth#django.contrib.auth.models.User&quot;&gt;&lt;code&gt;User&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;../auth#django.contrib.auth.models.User.is_staff&quot;&gt;&lt;code&gt;is_staff&lt;/code&gt;&lt;/a&gt; set to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">이 북마크를 사용해야합니다 &lt;code&gt;XViewMiddleware&lt;/code&gt; 가 설치되어 있고이에 로그인했는지 &lt;a href=&quot;index#module-django.contrib.admin&quot;&gt; &lt;code&gt;Django admin&lt;/code&gt; &lt;/a&gt; A와 &lt;a href=&quot;../auth#django.contrib.auth.models.User&quot;&gt; &lt;code&gt;User&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;../auth#django.contrib.auth.models.User.is_staff&quot;&gt; &lt;code&gt;is_staff&lt;/code&gt; &lt;/a&gt; 로 설정 &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbeee8bfa7b08a0c5da0b3386d5f491c796e4c48" translate="yes" xml:space="preserve">
          <source>Using this decorator means you can write your function and assume that the input is a proper string, then add support for lazy translation objects at the end.</source>
          <target state="translated">이 데코레이터를 사용하면 함수를 작성하고 입력이 올바른 문자열이라고 가정 한 다음 끝에 게으른 변환 객체에 대한 지원을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7480984e78ad4eb9e153bf7a81ed50521acc1b75" translate="yes" xml:space="preserve">
          <source>Using this example model, &lt;code&gt;Person.objects&lt;/code&gt; will generate an &lt;code&gt;AttributeError&lt;/code&gt; exception, but &lt;code&gt;Person.people.all()&lt;/code&gt; will provide a list of all &lt;code&gt;Person&lt;/code&gt; objects.</source>
          <target state="translated">이 예제 모델을 사용하여 &lt;code&gt;Person.objects&lt;/code&gt; 는 &lt;code&gt;AttributeError&lt;/code&gt; 예외 를 생성 하지만 &lt;code&gt;Person.people.all()&lt;/code&gt; 은 모든 &lt;code&gt;Person&lt;/code&gt; 오브젝트 목록을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="262fd65d339e5a7db75999c15071593bf6231689" translate="yes" xml:space="preserve">
          <source>Using this feature usefully is probably best explained with an example. Suppose you have this pair of models, representing a small blog system:</source>
          <target state="translated">이 기능을 유용하게 사용하는 것이 예제와 함께 가장 잘 설명 될 것입니다. 작은 블로그 시스템을 나타내는이 모델 쌍이 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="0ea5d6a0d304b934c5dbf1fb4ac5997a88cc09a3" translate="yes" xml:space="preserve">
          <source>Using this renderer along with the built-in widget templates requires either:</source>
          <target state="translated">내장 위젯 템플리트와 함께이 렌더러를 사용하려면 다음 중 하나가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="38af29bc15e311d440bad7fbd6e2bace11b25e9b" translate="yes" xml:space="preserve">
          <source>Using this renderer requires you to make sure the form templates your project needs can be located.</source>
          <target state="translated">이 렌더러를 사용하려면 프로젝트에 필요한 양식 서식 파일을 찾을 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="42f7f1f775fcbbccfb41145a7b4acdcbd45277e1" translate="yes" xml:space="preserve">
          <source>Using this setup, the following lookups are possible:</source>
          <target state="translated">이 설정을 사용하면 다음과 같은 조회가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="d03e7d65dccb786da0c5ea2cdc1052bcedd878aa" translate="yes" xml:space="preserve">
          <source>Using translations outside views and templates</source>
          <target state="translated">뷰 및 템플릿 외부에서 번역 사용</target>
        </trans-unit>
        <trans-unit id="54c5b26ddde5892747473c35017de53a6b164dac" translate="yes" xml:space="preserve">
          <source>Using unnamed regular expression groups</source>
          <target state="translated">명명되지 않은 정규식 그룹 사용</target>
        </trans-unit>
        <trans-unit id="c7d70893665ff77fdaaf302ea439164a93f896e7" translate="yes" xml:space="preserve">
          <source>Using validation in practice</source>
          <target state="translated">실제로 검증 사용</target>
        </trans-unit>
        <trans-unit id="5bf70941f96163c1833edf8ea3db5448e4a4ba9e" translate="yes" xml:space="preserve">
          <source>Using validators</source>
          <target state="translated">유효성 검사기 사용</target>
        </trans-unit>
        <trans-unit id="a3f0cdb408fe2eb8b7926c9f3b3bbc789e6203e6" translate="yes" xml:space="preserve">
          <source>Using your own package</source>
          <target state="translated">자신의 패키지 사용</target>
        </trans-unit>
        <trans-unit id="550e826a2927cd8ea25940bb561b837a288a51b3" translate="yes" xml:space="preserve">
          <source>Usually there is no need to set this attribute. The default is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">일반적으로이 속성을 설정할 필요가 없습니다. 기본값은 &lt;code&gt;False&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0aaadd10ea3107f1c4459342ec34687215a60c17" translate="yes" xml:space="preserve">
          <source>Usually this will be enough, but from time to time you may need to ensure that your migration runs &lt;em&gt;before&lt;/em&gt; other migrations. This is useful, for example, to make third-party apps&amp;rsquo; migrations run &lt;em&gt;after&lt;/em&gt; your &lt;a href=&quot;../ref/settings#std:setting-AUTH_USER_MODEL&quot;&gt;&lt;code&gt;AUTH_USER_MODEL&lt;/code&gt;&lt;/a&gt; replacement.</source>
          <target state="translated">일반적으로 이것으로 충분하지만 때때로 다른 마이그레이션 &lt;em&gt;전에&lt;/em&gt; 마이그레이션이 실행되도록해야합니다 . 이것은 예를 들어, 타사 응용 프로그램 '마이그레이션을 실행하기 위해 유용 &lt;em&gt;후에&lt;/em&gt; 당신의 &lt;a href=&quot;../ref/settings#std:setting-AUTH_USER_MODEL&quot;&gt; &lt;code&gt;AUTH_USER_MODEL&lt;/code&gt; 의&lt;/a&gt; 교체.</target>
        </trans-unit>
        <trans-unit id="0aff3f9e73f7904475aa03cc2e6098355ceb5556" translate="yes" xml:space="preserve">
          <source>Usually when you&amp;rsquo;ll interact with a &lt;code&gt;QuerySet&lt;/code&gt; you&amp;rsquo;ll use it by &lt;a href=&quot;../../topics/db/queries#chaining-filters&quot;&gt;chaining filters&lt;/a&gt;. To make this work, most &lt;code&gt;QuerySet&lt;/code&gt; methods return new querysets. These methods are covered in detail later in this section.</source>
          <target state="translated">일반적으로 &lt;code&gt;QuerySet&lt;/code&gt; 과 상호 작용할 때는 &lt;a href=&quot;../../topics/db/queries#chaining-filters&quot;&gt;필터&lt;/a&gt; 를 연결 하여 사용합니다 . 이 작업을 수행하기 위해 대부분의 &lt;code&gt;QuerySet&lt;/code&gt; 메소드는 새 조회 세트를 리턴합니다. 이러한 방법은이 섹션의 뒷부분에서 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b21469443450cb938303739ea070f5a77ad694ea" translate="yes" xml:space="preserve">
          <source>Usually you should build up HTML using Django&amp;rsquo;s templates to make use of its autoescape mechanism, using the utilities in &lt;a href=&quot;#module-django.utils.safestring&quot;&gt;&lt;code&gt;django.utils.safestring&lt;/code&gt;&lt;/a&gt; where appropriate. This module provides some additional low level utilities for escaping HTML.</source>
          <target state="translated">일반적으로 당신의 유틸리티를 사용하여, 자사의 autoescape 메커니즘을 사용하도록 장고의 템플릿을 사용하여 HTML 구축해야 &lt;a href=&quot;#module-django.utils.safestring&quot;&gt; &lt;code&gt;django.utils.safestring&lt;/code&gt; &lt;/a&gt; 적절한. 이 모듈은 HTML을 이스케이프 처리하기위한 추가 저수준 유틸리티를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0f36944fd9a406992a7e16bb0c9c72e4d2f92f04" translate="yes" xml:space="preserve">
          <source>Usually, elements of &lt;code&gt;list_display&lt;/code&gt; that aren&amp;rsquo;t actual database fields can&amp;rsquo;t be used in sorting (because Django does all the sorting at the database level).</source>
          <target state="translated">일반적으로 실제 데이터베이스 필드가 아닌 &lt;code&gt;list_display&lt;/code&gt; 의 요소는 정렬에서 사용할 수 없습니다 (Django는 데이터베이스 수준에서 모든 정렬을 수행하기 때문에).</target>
        </trans-unit>
        <trans-unit id="1f83b78620a3f44e86a39030f5a235640c96f74f" translate="yes" xml:space="preserve">
          <source>Usually, if another transaction has already acquired a lock on one of the selected rows, the query will block until the lock is released. If this is not the behavior you want, call &lt;code&gt;select_for_update(nowait=True)&lt;/code&gt;. This will make the call non-blocking. If a conflicting lock is already acquired by another transaction, &lt;a href=&quot;../exceptions#django.db.DatabaseError&quot;&gt;&lt;code&gt;DatabaseError&lt;/code&gt;&lt;/a&gt; will be raised when the queryset is evaluated. You can also ignore locked rows by using &lt;code&gt;select_for_update(skip_locked=True)&lt;/code&gt; instead. The &lt;code&gt;nowait&lt;/code&gt; and &lt;code&gt;skip_locked&lt;/code&gt; are mutually exclusive and attempts to call &lt;code&gt;select_for_update()&lt;/code&gt; with both options enabled will result in a &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적으로 다른 트랜잭션이 선택된 행 중 하나에서 이미 잠금을 획득 한 경우 잠금이 해제 될 때까지 쿼리가 차단됩니다. 원하는 동작이 아닌 경우 &lt;code&gt;select_for_update(nowait=True)&lt;/code&gt; 호출 하십시오 . 이렇게하면 통화가 차단되지 않습니다. 다른 트랜잭션에서 이미 충돌 잠금을 획득 한 경우 쿼리 집합을 평가할 때 &lt;a href=&quot;../exceptions#django.db.DatabaseError&quot;&gt; &lt;code&gt;DatabaseError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 대신 &lt;code&gt;select_for_update(skip_locked=True)&lt;/code&gt; 를 사용하여 잠긴 행을 무시할 수도 있습니다 . &lt;code&gt;nowait&lt;/code&gt; 및 &lt;code&gt;skip_locked&lt;/code&gt; 은 상호 배타적 및 통화에 대한 시도 &lt;code&gt;select_for_update()&lt;/code&gt; 두 옵션은 발생합니다 활성화 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="439a51ffd52fc469c95fceae28d995d4c094f903" translate="yes" xml:space="preserve">
          <source>Usually, the application namespace should be specified by the included module. If an application namespace is set, the &lt;code&gt;namespace&lt;/code&gt; argument can be used to set a different instance namespace.</source>
          <target state="translated">일반적으로 응용 프로그램 네임 스페이스는 포함 된 모듈로 지정해야합니다. 응용 프로그램 네임 스페이스가 설정된 경우 &lt;code&gt;namespace&lt;/code&gt; 인수를 사용하여 다른 인스턴스 네임 스페이스를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18fdc5ee8b1f8fba8dabaa933373c0483ab7fad7" translate="yes" xml:space="preserve">
          <source>Utilities</source>
          <target state="translated">Utilities</target>
        </trans-unit>
        <trans-unit id="f16cdccb3faaa5e67faa6fdb65caa5cf29d51cbb" translate="yes" xml:space="preserve">
          <source>Utility functions</source>
          <target state="translated">유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="df5a81323fd824a5ae16e1b2c1131af236466235" translate="yes" xml:space="preserve">
          <source>Validate the field uniqueness - &lt;a href=&quot;#django.db.models.Model.validate_unique&quot;&gt;&lt;code&gt;Model.validate_unique()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">필드 고유성 검증 &lt;a href=&quot;#django.db.models.Model.validate_unique&quot;&gt; &lt;code&gt;Model.validate_unique()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c0758db94eadfc40bb6f1aec50a9b3167bbf24b8" translate="yes" xml:space="preserve">
          <source>Validate the model as a whole - &lt;a href=&quot;#django.db.models.Model.clean&quot;&gt;&lt;code&gt;Model.clean()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">모델 전체를 검증합니다 &lt;a href=&quot;#django.db.models.Model.clean&quot;&gt; &lt;code&gt;Model.clean()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b0ea75efddc63e41263e629cf2f36ff06ff116f0" translate="yes" xml:space="preserve">
          <source>Validate the model fields - &lt;a href=&quot;#django.db.models.Model.clean_fields&quot;&gt;&lt;code&gt;Model.clean_fields()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">모델 필드 확인 &lt;a href=&quot;#django.db.models.Model.clean_fields&quot;&gt; &lt;code&gt;Model.clean_fields()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e8f7b38fbffba806e0ac0f63853430f5bef3b147" translate="yes" xml:space="preserve">
          <source>Validates a password. If all validators find the password valid, returns &lt;code&gt;None&lt;/code&gt;. If one or more validators reject the password, raises a &lt;a href=&quot;../../ref/exceptions#django.core.exceptions.ValidationError&quot;&gt;&lt;code&gt;ValidationError&lt;/code&gt;&lt;/a&gt; with all the error messages from the validators.</source>
          <target state="translated">비밀번호를 확인합니다. 모든 유효성 검사기가 유효한 암호를 찾으면 &lt;code&gt;None&lt;/code&gt; 을 반환합니다 . 하나 이상의 유효성 검사기가 암호를 거부하면 유효성 검사기의 모든 오류 메시지와 함께 &lt;a href=&quot;../../ref/exceptions#django.core.exceptions.ValidationError&quot;&gt; &lt;code&gt;ValidationError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="57438d749f0f60d8c3629d9567fe391119db098c" translate="yes" xml:space="preserve">
          <source>Validates nothing (i.e., it never raises a &lt;code&gt;ValidationError&lt;/code&gt;).</source>
          <target state="translated">아무것도 검증하지 않습니다 (즉, &lt;code&gt;ValidationError&lt;/code&gt; 를 발생 시키지 않습니다 ).</target>
        </trans-unit>
        <trans-unit id="c605c7277e2bfe1fb583ddbab51805c05f6d0c98" translate="yes" xml:space="preserve">
          <source>Validates that every id in the given list of values exists in the queryset.</source>
          <target state="translated">주어진 값 목록의 모든 ID가 쿼리 집합에 존재하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="5f36358736b0e491d63d28efe23ef97ae0a786a4" translate="yes" xml:space="preserve">
          <source>Validates that every value in the given list of values exists in the list of choices.</source>
          <target state="translated">주어진 값 목록의 모든 값이 선택 목록에 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="86e24952143ad19570f9cc006bc6c7a350adf549" translate="yes" xml:space="preserve">
          <source>Validates that file data has been bound to the form. Also uses &lt;a href=&quot;../validators#django.core.validators.FileExtensionValidator&quot;&gt;&lt;code&gt;FileExtensionValidator&lt;/code&gt;&lt;/a&gt; to validate that the file extension is supported by Pillow.</source>
          <target state="translated">파일 데이터가 양식에 바인드되었는지 확인합니다. 또한 &lt;a href=&quot;../validators#django.core.validators.FileExtensionValidator&quot;&gt; &lt;code&gt;FileExtensionValidator&lt;/code&gt; &lt;/a&gt; 를 사용 하여 파일 확장자가 Pillow에서 지원 되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2486043717d64c0e0f90e88711ae8ac419c28d2a" translate="yes" xml:space="preserve">
          <source>Validates that the given id exists in the queryset.</source>
          <target state="translated">주어진 ID가 쿼리 세트에 존재하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d41eab543390f84e6c86d3be58fa5e65ae9b9375" translate="yes" xml:space="preserve">
          <source>Validates that the given keys are contained in the value. If &lt;code&gt;strict&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, then it also checks that there are no other keys present.</source>
          <target state="translated">주어진 키가 값에 포함되어 있는지 확인합니다. 경우 &lt;code&gt;strict&lt;/code&gt; 있다 &lt;code&gt;True&lt;/code&gt; , 다음 또한 검사 다른 키는 존재가 없음.</target>
        </trans-unit>
        <trans-unit id="f39b079a0f6688e4451cf4348efe2c48b017367a" translate="yes" xml:space="preserve">
          <source>Validates that the given value exists in the list of choices and can be coerced.</source>
          <target state="translated">주어진 값이 선택 목록에 존재하고 강제 될 수 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="c7d1ad278ad027ddf2dcdab2d2137843da014d4d" translate="yes" xml:space="preserve">
          <source>Validates that the given value exists in the list of choices.</source>
          <target state="translated">주어진 값이 선택 목록에 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="8d333d4dd21aa6d46d75d3ef13f00f761223d12a" translate="yes" xml:space="preserve">
          <source>Validates that the given value is a &lt;code&gt;datetime.datetime&lt;/code&gt; or string formatted in a particular datetime format.</source>
          <target state="translated">주어진 값이 &lt;code&gt;datetime.datetime&lt;/code&gt; 또는 특정 날짜 / 시간 형식으로 형식화 된 문자열인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="3ff141624a9f19e384151c40784a3378838d71b0" translate="yes" xml:space="preserve">
          <source>Validates that the given value is a decimal. Uses &lt;a href=&quot;../validators#django.core.validators.MaxValueValidator&quot;&gt;&lt;code&gt;MaxValueValidator&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../validators#django.core.validators.MinValueValidator&quot;&gt;&lt;code&gt;MinValueValidator&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;max_value&lt;/code&gt; and &lt;code&gt;min_value&lt;/code&gt; are provided. Leading and trailing whitespace is ignored.</source>
          <target state="translated">주어진 값이 10 진수인지 확인합니다. &lt;code&gt;max_value&lt;/code&gt; 및 &lt;code&gt;min_value&lt;/code&gt; 가 제공되는 경우 &lt;a href=&quot;../validators#django.core.validators.MaxValueValidator&quot;&gt; &lt;code&gt;MaxValueValidator&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../validators#django.core.validators.MinValueValidator&quot;&gt; &lt;code&gt;MinValueValidator&lt;/code&gt; 를&lt;/a&gt; 사용합니다 . 선행 및 후행 공백은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="46d6a2daba6396cf25045876054f0cf4431a075a" translate="yes" xml:space="preserve">
          <source>Validates that the given value is a float. Uses &lt;a href=&quot;../validators#django.core.validators.MaxValueValidator&quot;&gt;&lt;code&gt;MaxValueValidator&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../validators#django.core.validators.MinValueValidator&quot;&gt;&lt;code&gt;MinValueValidator&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;max_value&lt;/code&gt; and &lt;code&gt;min_value&lt;/code&gt; are provided. Leading and trailing whitespace is allowed, as in Python&amp;rsquo;s &lt;code&gt;float()&lt;/code&gt; function.</source>
          <target state="translated">주어진 값이 부동 소수점인지 확인합니다. &lt;code&gt;max_value&lt;/code&gt; 및 &lt;code&gt;min_value&lt;/code&gt; 가 제공되는 경우 &lt;a href=&quot;../validators#django.core.validators.MaxValueValidator&quot;&gt; &lt;code&gt;MaxValueValidator&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../validators#django.core.validators.MinValueValidator&quot;&gt; &lt;code&gt;MinValueValidator&lt;/code&gt; 를&lt;/a&gt; 사용합니다 . 파이썬의 &lt;code&gt;float()&lt;/code&gt; 함수 에서와 같이 선행 및 후행 공백이 허용 됩니다.</target>
        </trans-unit>
        <trans-unit id="495fddce59b02f9daa87c856e04632c05eada534" translate="yes" xml:space="preserve">
          <source>Validates that the given value is a string which can be converted into a &lt;code&gt;timedelta&lt;/code&gt;. The value must be between &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#datetime.timedelta.min&quot;&gt;&lt;code&gt;datetime.timedelta.min&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#datetime.timedelta.max&quot;&gt;&lt;code&gt;datetime.timedelta.max&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 값이 &lt;code&gt;timedelta&lt;/code&gt; 로 변환 될 수있는 문자열인지 확인합니다 . 값은 &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#datetime.timedelta.min&quot;&gt; &lt;code&gt;datetime.timedelta.min&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#datetime.timedelta.max&quot;&gt; &lt;code&gt;datetime.timedelta.max&lt;/code&gt; &lt;/a&gt; 사이 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="e00b8907889f17e61e5a6cab7c3a791557aeee76" translate="yes" xml:space="preserve">
          <source>Validates that the given value is a valid IP address.</source>
          <target state="translated">주어진 값이 유효한 IP 주소인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="9f80a852bfc910bdb75a27c34bd5a1c6f0179f01" translate="yes" xml:space="preserve">
          <source>Validates that the given value is an integer. Uses &lt;a href=&quot;../validators#django.core.validators.MaxValueValidator&quot;&gt;&lt;code&gt;MaxValueValidator&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../validators#django.core.validators.MinValueValidator&quot;&gt;&lt;code&gt;MinValueValidator&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;max_value&lt;/code&gt; and &lt;code&gt;min_value&lt;/code&gt; are provided. Leading and trailing whitespace is allowed, as in Python&amp;rsquo;s &lt;code&gt;int()&lt;/code&gt; function.</source>
          <target state="translated">주어진 값이 정수인지 확인합니다. &lt;code&gt;max_value&lt;/code&gt; 및 &lt;code&gt;min_value&lt;/code&gt; 가 제공되는 경우 &lt;a href=&quot;../validators#django.core.validators.MaxValueValidator&quot;&gt; &lt;code&gt;MaxValueValidator&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../validators#django.core.validators.MinValueValidator&quot;&gt; &lt;code&gt;MinValueValidator&lt;/code&gt; 를&lt;/a&gt; 사용합니다 . 파이썬의 &lt;code&gt;int()&lt;/code&gt; 함수 에서와 같이 선행 및 후행 공백이 허용 됩니다.</target>
        </trans-unit>
        <trans-unit id="98c5e2cdb3ff066588923a7959c004a5961dfbc1" translate="yes" xml:space="preserve">
          <source>Validates that the given value is either a &lt;code&gt;datetime.date&lt;/code&gt;, &lt;code&gt;datetime.datetime&lt;/code&gt; or string formatted in a particular date format.</source>
          <target state="translated">제공된 값이 &lt;code&gt;datetime.date&lt;/code&gt; , &lt;code&gt;datetime.datetime&lt;/code&gt; 또는 특정 날짜 형식으로 형식화 된 문자열인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="f254971ebd82d894de9ef8230a471619ea1b34ad" translate="yes" xml:space="preserve">
          <source>Validates that the given value is either a &lt;code&gt;datetime.datetime&lt;/code&gt;, &lt;code&gt;datetime.date&lt;/code&gt; or string formatted in a particular datetime format.</source>
          <target state="translated">지정된 값이 &lt;code&gt;datetime.datetime&lt;/code&gt; , &lt;code&gt;datetime.date&lt;/code&gt; 또는 특정 날짜 / 시간 형식으로 형식화 된 문자열인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="ff6831b127aae626d785b35ed1f7b0a4f254dd5c" translate="yes" xml:space="preserve">
          <source>Validates that the given value is either a &lt;code&gt;datetime.time&lt;/code&gt; or string formatted in a particular time format.</source>
          <target state="translated">제공된 값이 &lt;code&gt;datetime.time&lt;/code&gt; 또는 특정 시간 형식으로 형식화 된 문자열인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="71faa5d84e73b11d9583cc19f86b79703a92d13a" translate="yes" xml:space="preserve">
          <source>Validates that the given values exists in the list of choices and can be coerced.</source>
          <target state="translated">주어진 값이 선택 목록에 존재하고 강제 될 수 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="b7a61822235d8ac591f2a6b5cecc0e31bcc9342d" translate="yes" xml:space="preserve">
          <source>Validates that the lower bound of the range is not less than the &lt;code&gt;limit_value&lt;/code&gt;.</source>
          <target state="translated">범위의 하한이 &lt;code&gt;limit_value&lt;/code&gt; 이상인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="be85eb361a7ffbeae5f00430bd3b7c70309985a8" translate="yes" xml:space="preserve">
          <source>Validates that the selected choice exists in the list of choices.</source>
          <target state="translated">선택한 선택 사항이 선택 사항 목록에 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="b65ee0e7fcae80203fa7c550d0dc4476bd8120f7" translate="yes" xml:space="preserve">
          <source>Validates that the upper bound of the range is not greater than &lt;code&gt;limit_value&lt;/code&gt;.</source>
          <target state="translated">범위의 상한이 &lt;code&gt;limit_value&lt;/code&gt; 보다 크지 않은지 검증합니다 .</target>
        </trans-unit>
        <trans-unit id="0534f4b79462a177c2e1b4df5068fe643e4bfcfb" translate="yes" xml:space="preserve">
          <source>Validates that the value is &lt;code&gt;True&lt;/code&gt; (e.g. the check box is checked) if the field has &lt;code&gt;required=True&lt;/code&gt;.</source>
          <target state="translated">필드에 &lt;code&gt;required=True&lt;/code&gt; 가 있으면 값이 &lt;code&gt;True&lt;/code&gt; 인지 (예 : 확인란이 선택되어 있는지) 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="a089e7322f294a22f3ad9da0096a9e006b93e7a5" translate="yes" xml:space="preserve">
          <source>Validates the &lt;code&gt;filename&lt;/code&gt; by calling &lt;a href=&quot;../../howto/custom-file-storage#django.core.files.storage.get_valid_name&quot;&gt;&lt;code&gt;get_valid_name()&lt;/code&gt;&lt;/a&gt; and returns a filename to be passed to the &lt;a href=&quot;#django.core.files.storage.Storage.save&quot;&gt;&lt;code&gt;save()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;../../howto/custom-file-storage#django.core.files.storage.get_valid_name&quot;&gt; &lt;code&gt;get_valid_name()&lt;/code&gt; &lt;/a&gt; 을 호출 하여 &lt;code&gt;filename&lt;/code&gt; 을 검증하고 &lt;a href=&quot;#django.core.files.storage.Storage.save&quot;&gt; &lt;code&gt;save()&lt;/code&gt; &lt;/a&gt; 메소드에 전달할 파일 이름을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="bc90cf11ebffc582e4f98413176ac20116765baa" translate="yes" xml:space="preserve">
          <source>Validates the given value against each of the fields specified as an argument to the &lt;code&gt;ComboField&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ComboField&lt;/code&gt; 에 대한 인수로 지정된 각 필드에 대해 지정된 값을 검증합니다 .</target>
        </trans-unit>
        <trans-unit id="2380f84c16ec3e446eee9c517ff7bd0fa8d14d5e" translate="yes" xml:space="preserve">
          <source>Validates the given value against each of the fields specified as an argument to the &lt;code&gt;MultiValueField&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MultiValueField&lt;/code&gt; 에 대한 인수로 지정된 각 필드에 대해 지정된 값을 검증합니다 .</target>
        </trans-unit>
        <trans-unit id="fa12a71d357b7f53e8c955aa61a68dcf2af5f3a1" translate="yes" xml:space="preserve">
          <source>Validates whether the password is not a common password. This converts the password to lowercase (to do a case-insensitive comparison) and checks it against a list of 20,000 common password created by &lt;a href=&quot;https://gist.github.com/roycewilliams/281ce539915a947a23db17137d91aeb7&quot;&gt;Royce Williams&lt;/a&gt;.</source>
          <target state="translated">비밀번호가 공통 비밀번호가 아닌지 확인합니다. 이것은 암호를 소문자로 변환하고 (대소 문자를 구분하지 않는 비교를하기 위해) &lt;a href=&quot;https://gist.github.com/roycewilliams/281ce539915a947a23db17137d91aeb7&quot;&gt;Royce Williams가&lt;/a&gt; 만든 20,000 개의 공통 암호 목록과 비교하여 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="21ff5172199f09805bd9b455bcbee4947d3940a8" translate="yes" xml:space="preserve">
          <source>Validates whether the password is not entirely numeric.</source>
          <target state="translated">비밀번호가 완전히 숫자가 아닌지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="c9956251c8b8c02b6d045e02c44fbe656fcd8f39" translate="yes" xml:space="preserve">
          <source>Validates whether the password is sufficiently different from certain attributes of the user.</source>
          <target state="translated">비밀번호가 사용자의 특정 속성과 충분히 다른지 검증합니다.</target>
        </trans-unit>
        <trans-unit id="e7266cd2c7a3c6e05c68d94757dea222c5869f67" translate="yes" xml:space="preserve">
          <source>Validates whether the password meets a minimum length. The minimum length can be customized with the &lt;code&gt;min_length&lt;/code&gt; parameter.</source>
          <target state="translated">비밀번호가 최소 길이를 충족하는지 확인합니다. 최소 길이는 &lt;code&gt;min_length&lt;/code&gt; 매개 변수를 사용하여 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ceacc9ef8e6f9f466b5a2ddbaf3ed076c074611" translate="yes" xml:space="preserve">
          <source>Validating objects</source>
          <target state="translated">객체 검증</target>
        </trans-unit>
        <trans-unit id="7c9010b470fc6428464a81d5e7a42f479bc96d1d" translate="yes" xml:space="preserve">
          <source>Validating the form</source>
          <target state="translated">양식 확인</target>
        </trans-unit>
        <trans-unit id="2c5ab0c367616f5e10abcfa96e22d5221e7c7276" translate="yes" xml:space="preserve">
          <source>Validating the model instance</source>
          <target state="translated">모델 인스턴스 확인</target>
        </trans-unit>
        <trans-unit id="93d2e5f8f6a2a818943a053f1a783db3315193d8" translate="yes" xml:space="preserve">
          <source>Validating the number of forms in a formset</source>
          <target state="translated">폼 세트에서 폼 수 확인</target>
        </trans-unit>
        <trans-unit id="c5b08d19271a6bae52b7700e7b690302e1ee34ff" translate="yes" xml:space="preserve">
          <source>Validation is controlled by the &lt;a href=&quot;../../ref/settings#std:setting-AUTH_PASSWORD_VALIDATORS&quot;&gt;&lt;code&gt;AUTH_PASSWORD_VALIDATORS&lt;/code&gt;&lt;/a&gt; setting. The default for the setting is an empty list, which means no validators are applied. In new projects created with the default &lt;a href=&quot;../../ref/django-admin#django-admin-startproject&quot;&gt;&lt;code&gt;startproject&lt;/code&gt;&lt;/a&gt; template, a set of validators is enabled by default.</source>
          <target state="translated">유효성 검사는 &lt;a href=&quot;../../ref/settings#std:setting-AUTH_PASSWORD_VALIDATORS&quot;&gt; &lt;code&gt;AUTH_PASSWORD_VALIDATORS&lt;/code&gt; &lt;/a&gt; 설정에 의해 제어됩니다 . 설정의 기본값은 빈 목록으로, 유효성 검사기가 적용되지 않습니다. 기본 &lt;a href=&quot;../../ref/django-admin#django-admin-startproject&quot;&gt; &lt;code&gt;startproject&lt;/code&gt; &lt;/a&gt; 템플릿 으로 생성 된 새 프로젝트에서는 기본적 으로 유효성 검사기 세트가 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="1edcc1599a83cd0f9be14f27f9a77ac4fff5ee75" translate="yes" xml:space="preserve">
          <source>Validation of Constraints</source>
          <target state="translated">제약 조건의 검증</target>
        </trans-unit>
        <trans-unit id="b85ceec6f2e5f55b99d6a6f16aca09d6a81c2e03" translate="yes" xml:space="preserve">
          <source>Validation of a form is split into several steps, which can be customized or overridden:</source>
          <target state="translated">양식의 유효성 검사는 여러 단계로 나뉘며 사용자 지정하거나 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43fe8e18085c1ef39d666d38cf65376cb5e479df" translate="yes" xml:space="preserve">
          <source>Validation on a &lt;code&gt;ModelForm&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ModelForm&lt;/code&gt; 에 대한 유효성 검사</target>
        </trans-unit>
        <trans-unit id="121f69a605445393d3b651cc48c1b124569cb334" translate="yes" xml:space="preserve">
          <source>Validation with a formset is almost identical to a regular &lt;code&gt;Form&lt;/code&gt;. There is an &lt;code&gt;is_valid&lt;/code&gt; method on the formset to provide a convenient way to validate all forms in the formset:</source>
          <target state="translated">폼셋을 사용한 유효성 검사는 일반 &lt;code&gt;Form&lt;/code&gt; 과 거의 동일합니다 . 폼 세트 에는 &lt;code&gt;is_valid&lt;/code&gt; 메소드가있어 폼 세트의 모든 폼을 편리하게 검증 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a0ba3ac7ebb303bf0df645df17c3a747223a65e" translate="yes" xml:space="preserve">
          <source>Validator headers with non-safe request methods</source>
          <target state="translated">안전하지 않은 요청 방법이있는 유효성 검사기 헤더</target>
        </trans-unit>
        <trans-unit id="762f13c2259b5fbab6d8f1bdbab081fc48bc558f" translate="yes" xml:space="preserve">
          <source>Validators</source>
          <target state="translated">Validators</target>
        </trans-unit>
        <trans-unit id="b9484cd6bf104ca5d09633368136c8b22940b570" translate="yes" xml:space="preserve">
          <source>Validators can be used to validate values inside the field, let&amp;rsquo;s have a look at Django&amp;rsquo;s &lt;code&gt;SlugField&lt;/code&gt;:</source>
          <target state="translated">유효성 검사기를 사용하여 필드 내부의 값을 확인할 수 있습니다. Django의 &lt;code&gt;SlugField&lt;/code&gt; 를 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="f3deef60b96c0d8cee4c47ffe60be58ec6def1e8" translate="yes" xml:space="preserve">
          <source>Values in this list can be fully qualified names (e.g. &lt;code&gt;'www.example.com'&lt;/code&gt;), in which case they will be matched against the request&amp;rsquo;s &lt;code&gt;Host&lt;/code&gt; header exactly (case-insensitive, not including port). A value beginning with a period can be used as a subdomain wildcard: &lt;code&gt;'.example.com'&lt;/code&gt; will match &lt;code&gt;example.com&lt;/code&gt;, &lt;code&gt;www.example.com&lt;/code&gt;, and any other subdomain of &lt;code&gt;example.com&lt;/code&gt;. A value of &lt;code&gt;'*'&lt;/code&gt; will match anything; in this case you are responsible to provide your own validation of the &lt;code&gt;Host&lt;/code&gt; header (perhaps in a middleware; if so this middleware must be listed first in &lt;a href=&quot;#std:setting-MIDDLEWARE&quot;&gt;&lt;code&gt;MIDDLEWARE&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 목록의 값은 정규화 된 이름 (예 : &lt;code&gt;'www.example.com'&lt;/code&gt; ) 일 수 있으며,이 경우 요청의 &lt;code&gt;Host&lt;/code&gt; 헤더 (대소 문자 구분, 포트 제외)와 정확히 일치합니다. 마침표로 시작하는 값을 하위 도메인 와일드 카드로 사용할 수 있습니다. &lt;code&gt;'.example.com'&lt;/code&gt; 은 &lt;code&gt;example.com&lt;/code&gt; , &lt;code&gt;www.example.com&lt;/code&gt; 및 &lt;code&gt;example.com&lt;/code&gt; 의 다른 하위 도메인과 일치 합니다. &lt;code&gt;'*'&lt;/code&gt; 값은 무엇이든 일치합니다. 이 경우, &lt;code&gt;Host&lt;/code&gt; 헤더 에 대한 자체 유효성 검증을 제공해야합니다 (미들웨어 일 수도 있습니다.이 경우이 미들웨어는 &lt;a href=&quot;#std:setting-MIDDLEWARE&quot;&gt; &lt;code&gt;MIDDLEWARE&lt;/code&gt; &lt;/a&gt; 에서 먼저 나열되어야합니다 ).</target>
        </trans-unit>
        <trans-unit id="5c641ae18626a5257cc160b58b233dc1e5ba03e4" translate="yes" xml:space="preserve">
          <source>Values must be callables, or strings representing the full Python import path to the view that should be called to handle the error condition at hand.</source>
          <target state="translated">값은 호출 가능한 값이거나 현재 오류 조건을 처리하기 위해 호출해야하는 뷰에 대한 전체 Python 가져 오기 경로를 나타내는 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="890a72f9e8996089403208d002bfb488ce9caeac" translate="yes" xml:space="preserve">
          <source>Values up to 10^100 (Googol) are supported.</source>
          <target state="translated">최대 10 ^ 100 (구골)의 값이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="19de69cb601f53a4ea7af22a65c71ae63251365c" translate="yes" xml:space="preserve">
          <source>Variable</source>
          <target state="translated">Variable</target>
        </trans-unit>
        <trans-unit id="952e9aa92fd3d7a192f749b3b960fb5ac876f991" translate="yes" xml:space="preserve">
          <source>Variable attributes that begin with an underscore may not be accessed as they&amp;rsquo;re generally considered private.</source>
          <target state="translated">밑줄로 시작하는 변수 속성은 일반적으로 비공개로 간주되므로 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b861c2b05eae6bf5d374d127fd50ed98df426d61" translate="yes" xml:space="preserve">
          <source>Variable names must consist of any letter (A-Z), any digit (0-9), an underscore (but they must not start with an underscore) or a dot.</source>
          <target state="translated">변수 이름은 문자 (AZ), 숫자 (0-9), 밑줄 (밑줄로 시작해서는 안 됨) 또는 점으로 구성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="6fbf76eadf437ca353be2984032b630945a78945" translate="yes" xml:space="preserve">
          <source>Variable resolution will throw a &lt;code&gt;VariableDoesNotExist&lt;/code&gt; exception if it cannot resolve the string passed to it in the current context of the page.</source>
          <target state="translated">페이지의 현재 컨텍스트에서 전달 된 문자열을 확인할 수없는 경우 변수 분석에서 &lt;code&gt;VariableDoesNotExist&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fbfd347d1745f53cd9fc737cbf27a8df5a437849" translate="yes" xml:space="preserve">
          <source>Variable scope in context</source>
          <target state="translated">상황에 따른 변수 범위</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="91d24d94fe69030fb1913352f80e45d64513af99" translate="yes" xml:space="preserve">
          <source>Variables and lookups</source>
          <target state="translated">변수와 조회</target>
        </trans-unit>
        <trans-unit id="c889d071680db632177ca231bcb857b021a6fcbf" translate="yes" xml:space="preserve">
          <source>Variables are surrounded by &lt;code&gt;{{&lt;/code&gt; and &lt;code&gt;}}&lt;/code&gt; like this:</source>
          <target state="translated">변수는 다음과 같이 &lt;code&gt;{{&lt;/code&gt; 및 &lt;code&gt;}}&lt;/code&gt; 로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="7f84a7ea97bc4a4443d1dfe62f45fc85323d334a" translate="yes" xml:space="preserve">
          <source>Variables are surrounded by double-curly braces. &lt;code&gt;{{ article.headline }}&lt;/code&gt; means &amp;ldquo;Output the value of the article&amp;rsquo;s headline attribute.&amp;rdquo; But dots aren&amp;rsquo;t used only for attribute lookup. They also can do dictionary-key lookup, index lookup and function calls.</source>
          <target state="translated">변수는 이중 중괄호로 묶습니다. &lt;code&gt;{{ article.headline }}&lt;/code&gt; 은 &quot;기사의 헤드 라인 속성 값을 출력합니다&quot;를 의미합니다. 그러나 점은 속성 조회에만 사용되지 않습니다. 또한 사전 키 조회, 색인 조회 및 함수 호출을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="726e2f3a9dd5987e3d0dec3bf18fa3c806d2914f" translate="yes" xml:space="preserve">
          <source>Variables created outside of a &lt;a href=&quot;builtins#std:templatetag-block&quot;&gt;&lt;code&gt;{% block %}&lt;/code&gt;&lt;/a&gt; using the template tag &lt;code&gt;as&lt;/code&gt; syntax can&amp;rsquo;t be used inside the block. For example, this template doesn&amp;rsquo;t render anything:</source>
          <target state="translated">템플릿 태그 &lt;code&gt;as&lt;/code&gt; 구문 으로 사용하여 &lt;a href=&quot;builtins#std:templatetag-block&quot;&gt; &lt;code&gt;{% block %}&lt;/code&gt; &lt;/a&gt; 외부에서 생성 된 변수 는 블록 내부에서 사용할 수 없습니다. 예를 들어이 템플릿은 아무것도 렌더링하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2b54a020663a7e9de0f900e7a33c7949a59e97fe" translate="yes" xml:space="preserve">
          <source>Variables included in the cycle will be escaped. You can disable auto-escaping with:</source>
          <target state="translated">사이클에 포함 된 변수는 이스케이프됩니다. 다음을 사용하여 자동 이스케이프를 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95b252e22f473a20d0d5f77b8067b71eb8ac8cdc" translate="yes" xml:space="preserve">
          <source>Variables look like this: &lt;code&gt;{{ variable }}&lt;/code&gt;. When the template engine encounters a variable, it evaluates that variable and replaces it with the result. Variable names consist of any combination of alphanumeric characters and the underscore (&lt;code&gt;&quot;_&quot;&lt;/code&gt;) but may not start with an underscore. The dot (&lt;code&gt;&quot;.&quot;&lt;/code&gt;) also appears in variable sections, although that has a special meaning, as indicated below. Importantly, &lt;em&gt;you cannot have spaces or punctuation characters in variable names.&lt;/em&gt;</source>
          <target state="translated">변수는 &lt;code&gt;{{ variable }}&lt;/code&gt; 과 같습니다 . 템플릿 엔진은 변수를 만나면 해당 변수를 평가하여 결과로 바꿉니다. 변수 이름은 영숫자와 밑줄 ( &lt;code&gt;&quot;_&quot;&lt;/code&gt; )의 조합으로 구성 되지만 밑줄로 시작할 수 없습니다. 점 ( &lt;code&gt;&quot;.&quot;&lt;/code&gt; )은 아래에 표시된 것처럼 특별한 의미를 갖지만 변수 섹션에도 나타납니다. 중요하게 &lt;em&gt;는 변수 이름에 공백이나 문장 부호 문자를 사용할 수 없습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7b2cddda2582c05e8c4dad4699997660f29594f1" translate="yes" xml:space="preserve">
          <source>Vary headers</source>
          <target state="translated">다양한 헤더</target>
        </trans-unit>
        <trans-unit id="ce758a684cf3266fd922f3e988747fb02f4c453b" translate="yes" xml:space="preserve">
          <source>Vector Data Source Objects</source>
          <target state="translated">벡터 데이터 소스 객체</target>
        </trans-unit>
        <trans-unit id="7455570dc3bf7f4b79d9d30b8b95373e37003003" translate="yes" xml:space="preserve">
          <source>Verbose field names</source>
          <target state="translated">자세한 필드 이름</target>
        </trans-unit>
        <trans-unit id="536244f4cc64c32141c5753233b90a09618435ae" translate="yes" xml:space="preserve">
          <source>Verifying</source>
          <target state="translated">Verifying</target>
        </trans-unit>
        <trans-unit id="9db95c1103ad0d7ef81bc6d919b2f562add7553f" translate="yes" xml:space="preserve">
          <source>Verifying a HTTP &lt;a href=&quot;#django.test.SimpleTestCase.assertRedirects&quot;&gt;&lt;code&gt;redirect&lt;/code&gt;&lt;/a&gt; is performed by the app.</source>
          <target state="translated">HTTP &lt;a href=&quot;#django.test.SimpleTestCase.assertRedirects&quot;&gt; &lt;code&gt;redirect&lt;/code&gt; &lt;/a&gt; 확인 은 앱에서 수행합니다.</target>
        </trans-unit>
        <trans-unit id="351091639e5c6f0d0701ca6effc4c47f1d2d960a" translate="yes" xml:space="preserve">
          <source>Verifying that a template &lt;a href=&quot;#django.test.SimpleTestCase.assertTemplateUsed&quot;&gt;&lt;code&gt;has/hasn't been used to generate a given
response content&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#django.test.SimpleTestCase.assertTemplateUsed&quot;&gt; &lt;code&gt;has/hasn't been used to generate a given response content&lt;/code&gt; &lt;/a&gt; 템플릿 을 사용하지 않았는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="43f47a8beba569e78ae4a7db0330ae6f1f1ff4cd" translate="yes" xml:space="preserve">
          <source>Verifying that two &lt;a href=&quot;#django.test.SimpleTestCase.assertURLEqual&quot;&gt;&lt;code&gt;URLs&lt;/code&gt;&lt;/a&gt; are equal.</source>
          <target state="translated">두 &lt;a href=&quot;#django.test.SimpleTestCase.assertURLEqual&quot;&gt; &lt;code&gt;URLs&lt;/code&gt; &lt;/a&gt; 이 동일한 지 확인</target>
        </trans-unit>
        <trans-unit id="b2937b0c385e43ff0fab1c832f3a0e7c50dcaa59" translate="yes" xml:space="preserve">
          <source>Verifying timestamped values</source>
          <target state="translated">타임 스탬프 된 값 확인</target>
        </trans-unit>
        <trans-unit id="62f1aa26f4254bd96d4eb6f8b646ba000ec16032" translate="yes" xml:space="preserve">
          <source>Version control</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42d0c619b516797e08e7d157352a414b4b3843d8" translate="yes" xml:space="preserve">
          <source>Version support</source>
          <target state="translated">버전 지원</target>
        </trans-unit>
        <trans-unit id="8d19c9371431d1419c761233733405e0d04b0c48" translate="yes" xml:space="preserve">
          <source>Via the Python API</source>
          <target state="translated">파이썬 API를 통해</target>
        </trans-unit>
        <trans-unit id="80530ee23eded1296fb593e559258c50db6c5b60" translate="yes" xml:space="preserve">
          <source>Via the admin interface</source>
          <target state="translated">관리자 인터페이스를 통해</target>
        </trans-unit>
        <trans-unit id="efae37704a326e950f2a675d17061b1a12be0c12" translate="yes" xml:space="preserve">
          <source>View decorators</source>
          <target state="translated">데코레이터보기</target>
        </trans-unit>
        <trans-unit id="7a095affdff63c67d4d89f5b28c39584c3db1d08" translate="yes" xml:space="preserve">
          <source>View needs protection for one path</source>
          <target state="translated">하나의 경로에 대한 보호가 필요한 뷰</target>
        </trans-unit>
        <trans-unit id="7a4c8e3a560fabb6e8eeacddfdab8496436472a9" translate="yes" xml:space="preserve">
          <source>View reference</source>
          <target state="translated">참조보기</target>
        </trans-unit>
        <trans-unit id="b9a5232730a30862e5a9b0884958c7c34e1899cd" translate="yes" xml:space="preserve">
          <source>Viewing subsets of objects</source>
          <target state="translated">객체의 부분 집합보기</target>
        </trans-unit>
        <trans-unit id="24be61285e096fa817d4cdb0a0ed8294ea5bd2fb" translate="yes" xml:space="preserve">
          <source>Views</source>
          <target state="translated">Views</target>
        </trans-unit>
        <trans-unit id="c52102d53eeaab9b9a88302a361a6f600497ed10" translate="yes" xml:space="preserve">
          <source>Vote action &amp;ndash; handles voting for a particular choice in a particular question.</source>
          <target state="translated">투표 조치 &amp;ndash; 특정 질문에서 특정 선택에 대한 투표를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="181526b1a828fc52b70ef8658aba4470e617ea82" translate="yes" xml:space="preserve">
          <source>WKB / EWKB</source>
          <target state="translated">WKB / EWKB</target>
        </trans-unit>
        <trans-unit id="e90361962589bfebc2d23c92d7e7625e6769ba36" translate="yes" xml:space="preserve">
          <source>WKT / EWKT</source>
          <target state="translated">WKT / EWKT</target>
        </trans-unit>
        <trans-unit id="e6de5c6b0a4c7c9823e24df26d4d513a3d0ebab6" translate="yes" xml:space="preserve">
          <source>WSGI servers obtain the path to the &lt;code&gt;application&lt;/code&gt; callable from their configuration. Django&amp;rsquo;s built-in server, namely the &lt;a href=&quot;../../../ref/django-admin#django-admin-runserver&quot;&gt;&lt;code&gt;runserver&lt;/code&gt;&lt;/a&gt; command, reads it from the &lt;a href=&quot;../../../ref/settings#std:setting-WSGI_APPLICATION&quot;&gt;&lt;code&gt;WSGI_APPLICATION&lt;/code&gt;&lt;/a&gt; setting. By default, it&amp;rsquo;s set to &lt;code&gt;&amp;lt;project_name&amp;gt;.wsgi.application&lt;/code&gt;, which points to the &lt;code&gt;application&lt;/code&gt; callable in &lt;code&gt;&amp;lt;project_name&amp;gt;/wsgi.py&lt;/code&gt;.</source>
          <target state="translated">WSGI 서버 는 구성에서 호출 가능한 &lt;code&gt;application&lt;/code&gt; 의 경로를 얻습니다 . Django의 내장 서버, 즉 &lt;a href=&quot;../../../ref/django-admin#django-admin-runserver&quot;&gt; &lt;code&gt;runserver&lt;/code&gt; &lt;/a&gt; 명령은 &lt;a href=&quot;../../../ref/settings#std:setting-WSGI_APPLICATION&quot;&gt; &lt;code&gt;WSGI_APPLICATION&lt;/code&gt; &lt;/a&gt; 설정 에서 읽습니다 . 기본적으로,이로 설정되어 &lt;code&gt;&amp;lt;project_name&amp;gt;.wsgi.application&lt;/code&gt; 의 어떤 점 &lt;code&gt;application&lt;/code&gt; 호출에서 &lt;code&gt;&amp;lt;project_name&amp;gt;/wsgi.py&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae4d3ecfc9ebb20c6629acd459701f8bd334fd07" translate="yes" xml:space="preserve">
          <source>Wait a minute. &lt;code&gt;&amp;lt;Question: Question object (1)&amp;gt;&lt;/code&gt; isn&amp;rsquo;t a helpful representation of this object. Let&amp;rsquo;s fix that by editing the &lt;code&gt;Question&lt;/code&gt; model (in the &lt;code&gt;polls/models.py&lt;/code&gt; file) and adding a &lt;a href=&quot;../ref/models/instances#django.db.models.Model.__str__&quot;&gt;&lt;code&gt;__str__()&lt;/code&gt;&lt;/a&gt; method to both &lt;code&gt;Question&lt;/code&gt; and &lt;code&gt;Choice&lt;/code&gt;:</source>
          <target state="translated">잠깐만 &lt;code&gt;&amp;lt;Question: Question object (1)&amp;gt;&lt;/code&gt; 은이 개체를 나타내는 데 도움이되지 않습니다. &lt;code&gt;polls/models.py&lt;/code&gt; 파일 에서 &lt;code&gt;Question&lt;/code&gt; 모델 을 편집하고 &lt;code&gt;Question&lt;/code&gt; 과 &lt;code&gt;Choice&lt;/code&gt; 모두에 &lt;a href=&quot;../ref/models/instances#django.db.models.Model.__str__&quot;&gt; &lt;code&gt;__str__()&lt;/code&gt; &lt;/a&gt; 메소드를 추가하여 문제를 해결해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="fbfaf3ade1ca7644d388e882f1b2cfe035e94a2a" translate="yes" xml:space="preserve">
          <source>Watchman support replaced support for &lt;code&gt;pyinotify&lt;/code&gt;.</source>
          <target state="translated">경비원 지원은 &lt;code&gt;pyinotify&lt;/code&gt; 에 대한 지원을 대체 했습니다 .</target>
        </trans-unit>
        <trans-unit id="7dd6e6e9ec6baba5ad08ccb4f5157c652ddce32c" translate="yes" xml:space="preserve">
          <source>Watchman timeout</source>
          <target state="translated">경비원 타임 아웃</target>
        </trans-unit>
        <trans-unit id="7b3933b2da6f5bf2fa9cd97037aef0e731929204" translate="yes" xml:space="preserve">
          <source>We &lt;strong&gt;strongly&lt;/strong&gt; recommend using &lt;a href=&quot;../../../ref/contrib/staticfiles#module-django.contrib.staticfiles&quot;&gt;&lt;code&gt;django.contrib.staticfiles&lt;/code&gt;&lt;/a&gt; to handle the admin files (along with a Web server as outlined in the previous section; this means using the &lt;a href=&quot;../../../ref/contrib/staticfiles#django-admin-collectstatic&quot;&gt;&lt;code&gt;collectstatic&lt;/code&gt;&lt;/a&gt; management command to collect the static files in &lt;a href=&quot;../../../ref/settings#std:setting-STATIC_ROOT&quot;&gt;&lt;code&gt;STATIC_ROOT&lt;/code&gt;&lt;/a&gt;, and then configuring your Web server to serve &lt;a href=&quot;../../../ref/settings#std:setting-STATIC_ROOT&quot;&gt;&lt;code&gt;STATIC_ROOT&lt;/code&gt;&lt;/a&gt; at &lt;a href=&quot;../../../ref/settings#std:setting-STATIC_URL&quot;&gt;&lt;code&gt;STATIC_URL&lt;/code&gt;&lt;/a&gt;), but here are three other approaches:</source>
          <target state="translated">우리는 &lt;strong&gt;강력하게&lt;/strong&gt; 사용하는 것이 좋습니다 &lt;a href=&quot;../../../ref/contrib/staticfiles#module-django.contrib.staticfiles&quot;&gt; &lt;code&gt;django.contrib.staticfiles&lt;/code&gt; 를&lt;/a&gt; 이전 섹션에 설명 된대로 웹 서버와 함께 (관리자 파일을 처리하기 위해,이 방법은 사용 &lt;a href=&quot;../../../ref/contrib/staticfiles#django-admin-collectstatic&quot;&gt; &lt;code&gt;collectstatic&lt;/code&gt; &lt;/a&gt; 에서 정적 파일을 수집하는 관리 명령을 &lt;a href=&quot;../../../ref/settings#std:setting-STATIC_ROOT&quot;&gt; &lt;code&gt;STATIC_ROOT&lt;/code&gt; 을&lt;/a&gt; 다음 웹 서버를 구성하는 역할을 &lt;a href=&quot;../../../ref/settings#std:setting-STATIC_ROOT&quot;&gt; &lt;code&gt;STATIC_ROOT&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../../../ref/settings#std:setting-STATIC_URL&quot;&gt; &lt;code&gt;STATIC_URL&lt;/code&gt; &lt;/a&gt; )이지만 다른 세 가지 접근 방식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="07b29f95d7b54dbb652a7863ac9ba76dc0b4b9e8" translate="yes" xml:space="preserve">
          <source>We advise against storing the literal value &lt;code&gt;None&lt;/code&gt; in the cache, because you won&amp;rsquo;t be able to distinguish between your stored &lt;code&gt;None&lt;/code&gt; value and a cache miss signified by a return value of &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">저장된 &lt;code&gt;None&lt;/code&gt; 값과 반환 값이 &lt;code&gt;None&lt;/code&gt; 으로 표시된 캐시 미스 를 구분할 수 없으므로 캐시에 리터럴 값 &lt;code&gt;None&lt;/code&gt; 을 저장 하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="298a1cbc241e125b5254baaec7a1c73ae729225d" translate="yes" xml:space="preserve">
          <source>We already know what the problem is: &lt;code&gt;Question.was_published_recently()&lt;/code&gt; should return &lt;code&gt;False&lt;/code&gt; if its &lt;code&gt;pub_date&lt;/code&gt; is in the future. Amend the method in &lt;code&gt;models.py&lt;/code&gt;, so that it will only return &lt;code&gt;True&lt;/code&gt; if the date is also in the past:</source>
          <target state="translated">우리는 이미 문제가 무엇인지 알고 있습니다. &lt;code&gt;Question.was_published_recently()&lt;/code&gt; 는 &lt;code&gt;pub_date&lt;/code&gt; 가 미래에 있으면 &lt;code&gt;False&lt;/code&gt; 를 반환해야합니다 . &lt;code&gt;models.py&lt;/code&gt; 의 메소드를 수정하여 날짜가 지난 날짜 인 경우 에만 &lt;code&gt;True&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="5899248bb49703fd618e2fbb5d5ee585bf81ee76" translate="yes" xml:space="preserve">
          <source>We already know what we want our HTML form to look like. Our starting point for it in Django is this:</source>
          <target state="translated">우리는 이미 HTML 형식의 모양을 알고 있습니다. 장고에서의 시작점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1e5053ba84ae9bf771ee62969c89341da54a84c9" translate="yes" xml:space="preserve">
          <source>We also created a dummy implementation of the &lt;code&gt;vote()&lt;/code&gt; function. Let&amp;rsquo;s create a real version. Add the following to &lt;code&gt;polls/views.py&lt;/code&gt;:</source>
          <target state="translated">또한 &lt;code&gt;vote()&lt;/code&gt; 함수 의 더미 구현을 만들었습니다 . 실제 버전을 만들어 봅시다. &lt;code&gt;polls/views.py&lt;/code&gt; 에 다음을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab5f37e35f55eab0757ee7b44a7f137f974e6971" translate="yes" xml:space="preserve">
          <source>We are using a template for the item descriptions. It can be as minimal as this:</source>
          <target state="translated">아이템 설명에 템플릿을 사용하고 있습니다. 다음과 같이 최소한 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1036e5f257dd49774ce5b8738e7cf23a97247a1" translate="yes" xml:space="preserve">
          <source>We are using the &lt;a href=&quot;../ref/urlresolvers#django.urls.reverse&quot;&gt;&lt;code&gt;reverse()&lt;/code&gt;&lt;/a&gt; function in the &lt;a href=&quot;../ref/request-response#django.http.HttpResponseRedirect&quot;&gt;&lt;code&gt;HttpResponseRedirect&lt;/code&gt;&lt;/a&gt; constructor in this example. This function helps avoid having to hardcode a URL in the view function. It is given the name of the view that we want to pass control to and the variable portion of the URL pattern that points to that view. In this case, using the URLconf we set up in &lt;a href=&quot;tutorial03&quot;&gt;Tutorial 3&lt;/a&gt;, this &lt;a href=&quot;../ref/urlresolvers#django.urls.reverse&quot;&gt;&lt;code&gt;reverse()&lt;/code&gt;&lt;/a&gt; call will return a string like</source>
          <target state="translated">이 예제 에서는 &lt;a href=&quot;../ref/request-response#django.http.HttpResponseRedirect&quot;&gt; &lt;code&gt;HttpResponseRedirect&lt;/code&gt; &lt;/a&gt; 생성자에서 &lt;a href=&quot;../ref/urlresolvers#django.urls.reverse&quot;&gt; &lt;code&gt;reverse()&lt;/code&gt; &lt;/a&gt; 함수를 사용하고 있습니다. 이 기능은보기 기능에서 URL을 하드 코딩하지 않아도됩니다. 컨트롤에 전달하려는 뷰의 이름과 해당 뷰를 가리키는 URL 패턴의 변수 부분이 제공됩니다. 이 경우 &lt;a href=&quot;tutorial03&quot;&gt;자습서 3&lt;/a&gt; 에서 설정 한 URLconf를 사용 하여이 &lt;a href=&quot;../ref/urlresolvers#django.urls.reverse&quot;&gt; &lt;code&gt;reverse()&lt;/code&gt; &lt;/a&gt; 호출은 다음과 같은 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3da8009532e1dddd2ecda49e5b9486015547c9a2" translate="yes" xml:space="preserve">
          <source>We assign to and retrieve from the &lt;code&gt;hand&lt;/code&gt; attribute in our model just like any other Python class. The trick is to tell Django how to handle saving and loading such an object.</source>
          <target state="translated">다른 Python 클래스와 마찬가지로 모델 의 &lt;code&gt;hand&lt;/code&gt; 속성을 할당하고 검색합니다 . 트릭은 장고에게 그러한 객체를 저장하고로드하는 방법을 알려주는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6f810cc90b63a95ec62b929cc54f803561d191c9" translate="yes" xml:space="preserve">
          <source>We call &lt;code&gt;process_lhs&lt;/code&gt; and &lt;code&gt;process_rhs&lt;/code&gt; to convert them into the values we need for SQL using the &lt;code&gt;compiler&lt;/code&gt; object described before. These methods return tuples containing some SQL and the parameters to be interpolated into that SQL, just as we need to return from our &lt;code&gt;as_sql&lt;/code&gt; method. In the above example, &lt;code&gt;process_lhs&lt;/code&gt; returns &lt;code&gt;('&quot;author&quot;.&quot;name&quot;', [])&lt;/code&gt; and &lt;code&gt;process_rhs&lt;/code&gt; returns &lt;code&gt;('&quot;%s&quot;', ['Jack'])&lt;/code&gt;. In this example there were no parameters for the left hand side, but this would depend on the object we have, so we still need to include them in the parameters we return.</source>
          <target state="translated">앞에서 설명한 &lt;code&gt;compiler&lt;/code&gt; 객체를 사용하여 &lt;code&gt;process_lhs&lt;/code&gt; 및 &lt;code&gt;process_rhs&lt;/code&gt; 를 호출 하여 SQL에 필요한 값으로 변환합니다 . 이러한 메소드는 &lt;code&gt;as_sql&lt;/code&gt; 메소드 에서 리턴해야하는 것처럼 일부 SQL 및 해당 SQL에 보간 될 매개 변수를 포함하는 튜플을 리턴 합니다. 위의 예에서 &lt;code&gt;process_lhs&lt;/code&gt; 는 &lt;code&gt;('&quot;author&quot;.&quot;name&quot;', [])&lt;/code&gt; 를 반환 하고 &lt;code&gt;process_rhs&lt;/code&gt; 는 &lt;code&gt;('&quot;%s&quot;', ['Jack'])&lt;/code&gt; 반환합니다 . 이 예제에는 왼쪽에 대한 매개 변수가 없었지만, 이것은 우리가 가지고있는 객체에 따라 다르므로 반환하는 매개 변수에 여전히 포함시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="1b8da204b55ff9d5826452cdca58f92131b371ea" translate="yes" xml:space="preserve">
          <source>We call the form&amp;rsquo;s &lt;code&gt;is_valid()&lt;/code&gt; method; if it&amp;rsquo;s not &lt;code&gt;True&lt;/code&gt;, we go back to the template with the form. This time the form is no longer empty (&lt;em&gt;unbound&lt;/em&gt;) so the HTML form will be populated with the data previously submitted, where it can be edited and corrected as required.</source>
          <target state="translated">폼의 &lt;code&gt;is_valid()&lt;/code&gt; 메소드를 호출합니다 . &lt;code&gt;True&lt;/code&gt; 가 아닌 경우 양식이있는 템플릿으로 돌아갑니다. 이번에는 양식이 더 이상 비어 &lt;em&gt;있지 않은&lt;/em&gt; ( &lt;em&gt;unbound&lt;/em&gt; ) HTML 양식이 이전에 제출 된 데이터로 채워지며 필요에 따라 편집하고 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="711e9c2728d93a0d7f5aecd52cb04a7a4450ba85" translate="yes" xml:space="preserve">
          <source>We can also add the publisher into the context at the same time, so we can use it in the template:</source>
          <target state="translated">게시자를 컨텍스트에 동시에 추가하여 템플릿에서 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9594d66d4a2f99efb6f5c9733e7a3cad6cb9c24b" translate="yes" xml:space="preserve">
          <source>We can also ask for the oldest book of any of those managed by every publisher:</source>
          <target state="translated">또한 모든 출판사가 관리하는 책 중 가장 오래된 책을 요청할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e35e496a83890c3c496acc86165ade68c2ef188e" translate="yes" xml:space="preserve">
          <source>We can also check if form data differs from the initial data (i.e. the form was sent without any data):</source>
          <target state="translated">양식 데이터가 초기 데이터와 다른지 확인할 수도 있습니다 (예 : 양식이 데이터없이 전송 된 경우).</target>
        </trans-unit>
        <trans-unit id="c0a02e85856e0b32637eda7d71e370ce47953d5a" translate="yes" xml:space="preserve">
          <source>We can also use &lt;a href=&quot;querysets#django.db.models.query.QuerySet.update&quot;&gt;&lt;code&gt;update()&lt;/code&gt;&lt;/a&gt; to increment the field value on multiple objects - which could be very much faster than pulling them all into Python from the database, looping over them, incrementing the field value of each one, and saving each one back to the database:</source>
          <target state="translated">&lt;a href=&quot;querysets#django.db.models.query.QuerySet.update&quot;&gt; &lt;code&gt;update()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 여러 객체에서 필드 값을 증가시킬 수 있습니다. 이는 데이터베이스에서 파이썬으로 모든 객체를 가져 와서 반복하고, 반복하고, 각각의 필드 값을 증가시키고, 각각을 다시 저장하는 것보다 훨씬 빠릅니다. 데이터베이스 :</target>
        </trans-unit>
        <trans-unit id="b010c0f28527c47a44980371af407815cc627c55" translate="yes" xml:space="preserve">
          <source>We can change the behavior on a specific backend by creating a subclass of &lt;code&gt;NotEqual&lt;/code&gt; with an &lt;code&gt;as_mysql&lt;/code&gt; method:</source>
          <target state="translated">&lt;code&gt;as_mysql&lt;/code&gt; 메소드를 사용하여 &lt;code&gt;NotEqual&lt;/code&gt; 의 서브 클래스를 작성하여 특정 백엔드의 작동을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="267b606647e452759e42da09874ac7be88e5c880" translate="yes" xml:space="preserve">
          <source>We can create a mixin class to use in all of our views, handling the conversion to JSON once.</source>
          <target state="translated">JSON으로의 변환을 한 번 처리하여 모든 뷰에서 사용할 믹스 인 클래스를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec411184425a81fa91294f8a10570ea9fa48ca89" translate="yes" xml:space="preserve">
          <source>We can hook this into our URLs easily enough:</source>
          <target state="translated">이를 URL에 쉽게 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0d379d05279757935c9cc615687d7cee1cc80f0" translate="yes" xml:space="preserve">
          <source>We can improve this by stating the common path prefix only once and grouping the suffixes that differ:</source>
          <target state="translated">공통 경로 접두사를 한 번만 지정하고 다른 접미사를 그룹화하여이를 개선 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27e67e475cc6caf59fb2d9fb135f9e98d46e4c67" translate="yes" xml:space="preserve">
          <source>We can now run the queries we had before. &lt;code&gt;Experiment.objects.filter(change__abs=27)&lt;/code&gt; will generate the following SQL:</source>
          <target state="translated">이제 이전에 수행 한 쿼리를 실행할 수 있습니다. &lt;code&gt;Experiment.objects.filter(change__abs=27)&lt;/code&gt; 은 다음 SQL을 생성합니다 :</target>
        </trans-unit>
        <trans-unit id="dd71e5a512d7369a50ef1810661360cde684437b" translate="yes" xml:space="preserve">
          <source>We can now use &lt;code&gt;foo__ne&lt;/code&gt; for any field &lt;code&gt;foo&lt;/code&gt;. You will need to ensure that this registration happens before you try to create any querysets using it. You could place the implementation in a &lt;code&gt;models.py&lt;/code&gt; file, or register the lookup in the &lt;code&gt;ready()&lt;/code&gt; method of an &lt;code&gt;AppConfig&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;foo&lt;/code&gt; 필드에 &lt;code&gt;foo__ne&lt;/code&gt; 을 사용할 수 있습니다 . 이 등록을 사용하여 쿼리 세트를 작성하기 전에이 등록이 발생하는지 확인해야합니다. 구현을 &lt;code&gt;models.py&lt;/code&gt; 파일에 배치하거나 &lt;code&gt;AppConfig&lt;/code&gt; 의 &lt;code&gt;ready()&lt;/code&gt; 메소드에 조회를 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e783abdee66a0e8ca97da482ff1cc5e6c0fb351" translate="yes" xml:space="preserve">
          <source>We can recognize certain common tasks, like displaying a list of objects, and write code that displays a list of &lt;em&gt;any&lt;/em&gt; object. Then the model in question can be passed as an extra argument to the URLconf.</source>
          <target state="translated">우리는 개체의 목록을 표시처럼, 특정 일반적인 작업을 인식하고 코드를 작성 표시의 목록이 할 수 &lt;em&gt;있는&lt;/em&gt; 객체입니다. 그런 다음 해당 모델을 URLconf에 추가 인수로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0a47343146c3813275e98a1c596eadc4b54c4f8" translate="yes" xml:space="preserve">
          <source>We can reduce to just two queries using &lt;code&gt;prefetch_related&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;prefetch_related&lt;/code&gt; 를 사용하여 두 개의 쿼리로 줄일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ce220374ed6e2c859c17174b70c0d16bde0f63a" translate="yes" xml:space="preserve">
          <source>We can then register it with &lt;code&gt;Field&lt;/code&gt;. It takes the place of the original &lt;code&gt;NotEqual&lt;/code&gt; class as it has the same &lt;code&gt;lookup_name&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;Field&lt;/code&gt; 에 등록 할 수 있습니다 . &lt;code&gt;lookup_name&lt;/code&gt; 과 동일한 원래 &lt;code&gt;NotEqual&lt;/code&gt; 클래스를 대신 합니다.</target>
        </trans-unit>
        <trans-unit id="4cda4919893b9d469e2023cfef7cadff866ac578" translate="yes" xml:space="preserve">
          <source>We could also improve our application in other ways, adding tests along the way. For example, it&amp;rsquo;s silly that &lt;code&gt;Questions&lt;/code&gt; can be published on the site that have no &lt;code&gt;Choices&lt;/code&gt;. So, our views could check for this, and exclude such &lt;code&gt;Questions&lt;/code&gt;. Our tests would create a &lt;code&gt;Question&lt;/code&gt; without &lt;code&gt;Choices&lt;/code&gt; and then test that it&amp;rsquo;s not published, as well as create a similar &lt;code&gt;Question&lt;/code&gt;&lt;em&gt;with&lt;/em&gt;&lt;code&gt;Choices&lt;/code&gt;, and test that it &lt;em&gt;is&lt;/em&gt; published.</source>
          <target state="translated">또한 다른 방법으로 테스트를 추가하여 응용 프로그램을 개선 할 수도 있습니다. 예를 들어, &lt;code&gt;Choices&lt;/code&gt; 가없는 사이트에 &lt;code&gt;Questions&lt;/code&gt; 을 게시 할 수있는 것은 바보입니다 . 따라서 Google의 견해에서이를 확인하고 해당 &lt;code&gt;Questions&lt;/code&gt; 제외 할 수 있습니다 . 우리의 테스트는 만들 것이다 &lt;code&gt;Question&lt;/code&gt; 없이 &lt;code&gt;Choices&lt;/code&gt; 뿐만 아니라 비슷한 만들 때, 그리고이 게시 아니라고 다음 테스트를 &lt;code&gt;Question&lt;/code&gt; &lt;em&gt;으로 &lt;/em&gt; &lt;code&gt;Choices&lt;/code&gt; 하고, 그 시험 &lt;em&gt;입니다&lt;/em&gt; 발표했다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8faacc3d5aeac8065623130300997fd23de8b122" translate="yes" xml:space="preserve">
          <source>We could write the earlier example, which only uses a last-modified function, using one of these decorators:</source>
          <target state="translated">다음 데코레이터 중 하나를 사용하여 마지막 수정 된 함수 만 사용하는 이전 예제를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7683932b0379cee9393a53393aa64068668911b0" translate="yes" xml:space="preserve">
          <source>We define an &lt;code&gt;UpperCase&lt;/code&gt; transformer which uses the SQL function &lt;code&gt;UPPER()&lt;/code&gt; to transform the values before comparison. We define &lt;a href=&quot;../ref/models/lookups#django.db.models.Transform.bilateral&quot;&gt;&lt;code&gt;bilateral = True&lt;/code&gt;&lt;/a&gt; to indicate that this transformation should apply to both &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;:</source>
          <target state="translated">비교하기 전에 SQL 함수 &lt;code&gt;UPPER()&lt;/code&gt; 를 사용하여 값을 변환 하는 &lt;code&gt;UpperCase&lt;/code&gt; 변환기를 정의합니다 . 이 변환이 &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 모두에 적용되어야 함을 나타 내기 위해 &lt;a href=&quot;../ref/models/lookups#django.db.models.Transform.bilateral&quot;&gt; &lt;code&gt;bilateral = True&lt;/code&gt; &lt;/a&gt; 로 정의 합니다 .</target>
        </trans-unit>
        <trans-unit id="b954514e8e0a9bda83f108b7ce3235380c8a4a2d" translate="yes" xml:space="preserve">
          <source>We do not recommend altering the &lt;a href=&quot;../../ref/settings#std:setting-DATABASES&quot;&gt;&lt;code&gt;DATABASES&lt;/code&gt;&lt;/a&gt; setting. Altering the &lt;a href=&quot;../../ref/settings#std:setting-CACHES&quot;&gt;&lt;code&gt;CACHES&lt;/code&gt;&lt;/a&gt; setting is possible, but a bit tricky if you are using internals that make using of caching, like &lt;a href=&quot;../http/sessions#module-django.contrib.sessions&quot;&gt;&lt;code&gt;django.contrib.sessions&lt;/code&gt;&lt;/a&gt;. For example, you will have to reinitialize the session backend in a test that uses cached sessions and overrides &lt;a href=&quot;../../ref/settings#std:setting-CACHES&quot;&gt;&lt;code&gt;CACHES&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../ref/settings#std:setting-DATABASES&quot;&gt; &lt;code&gt;DATABASES&lt;/code&gt; &lt;/a&gt; 설정을 변경하지 않는 것이 좋습니다 . 변경하면 &lt;a href=&quot;../../ref/settings#std:setting-CACHES&quot;&gt; &lt;code&gt;CACHES&lt;/code&gt; &lt;/a&gt; 당신이 좋아, 캐싱 사용하여 만든다 내부를 사용하는 경우 설정하는 것은 가능하지만, 약간 까다로운 &lt;a href=&quot;../http/sessions#module-django.contrib.sessions&quot;&gt; &lt;code&gt;django.contrib.sessions&lt;/code&gt; &lt;/a&gt; . 예를 들어, 캐시 된 세션을 사용하고 &lt;a href=&quot;../../ref/settings#std:setting-CACHES&quot;&gt; &lt;code&gt;CACHES&lt;/code&gt; 를&lt;/a&gt; 재정의하는 테스트에서 세션 백엔드를 다시 초기화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="bd8db168c549c993f35ece0fd32ea0990b20ca5c" translate="yes" xml:space="preserve">
          <source>We do some basic validation on the parameters, including requiring at least 2 columns or values, and ensuring they are expressions. We are requiring &lt;code&gt;output_field&lt;/code&gt; here so that Django knows what kind of model field to assign the eventual result to.</source>
          <target state="translated">최소 2 개의 열 또는 값을 요구하고 표현식인지 확인하는 등 매개 변수에 대한 기본 유효성 검증을 수행합니다. Django가 최종 결과를 할당 할 모델 필드의 종류를 알 수 있도록 여기에 &lt;code&gt;output_field&lt;/code&gt; 가 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="b97600cf10df1313b720a13fe3fe56b0957b11c3" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t have to let Django unpack the form&amp;rsquo;s fields; we can do it manually if we like (allowing us to reorder the fields, for example). Each field is available as an attribute of the form using &lt;code&gt;{{ form.name_of_field }}&lt;/code&gt;, and in a Django template, will be rendered appropriately. For example:</source>
          <target state="translated">Django가 양식의 필드를 풀도록 할 필요는 없습니다. 원하는 경우 수동으로 수행 할 수 있습니다 (예 : 필드를 다시 정렬 할 수 있도록 허용). 각 필드는 &lt;code&gt;{{ form.name_of_field }}&lt;/code&gt; 사용하여 양식의 속성으로 사용 가능 하며 Django 템플릿에서 적절하게 렌더링됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="73f282ce88f3a86bf8d2a3a51ee5ea14fdad7a55" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t need to do much in our &lt;code&gt;name.html&lt;/code&gt; template:</source>
          <target state="translated">&lt;code&gt;name.html&lt;/code&gt; 템플릿 에서 많은 작업을 수행 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d447add9d095e2ce74e1fedd149b4fbef51cbcec" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t usually recommend allowing &lt;code&gt;null=True&lt;/code&gt; for &lt;code&gt;CharField&lt;/code&gt; since this allows the field to have two &amp;ldquo;empty values&amp;rdquo;, but it&amp;rsquo;s important for the &lt;code&gt;Coalesce&lt;/code&gt; example below.</source>
          <target state="translated">&lt;code&gt;CharField&lt;/code&gt; 에 대해 &lt;code&gt;null=True&lt;/code&gt; 를 허용하지 않는 것이 좋습니다. 이렇게하면 필드에 두 개의 &quot;빈 값&quot;이있을 수 있지만 아래 의 &lt;code&gt;Coalesce&lt;/code&gt; 예에서는 중요 합니다.</target>
        </trans-unit>
        <trans-unit id="b8093131b1cf67c3786bc3e4228d6dd19b6489fd" translate="yes" xml:space="preserve">
          <source>We generate the SQL for each of the &lt;code&gt;expressions&lt;/code&gt; by using the &lt;code&gt;compiler.compile()&lt;/code&gt; method, and join the result together with commas. Then the template is filled out with our data and the SQL and parameters are returned.</source>
          <target state="translated">&lt;code&gt;compiler.compile()&lt;/code&gt; 메소드 를 사용하여 각 &lt;code&gt;expressions&lt;/code&gt; 에 대한 SQL을 생성하고 결과를 쉼표로 결합합니다. 그런 다음 템플릿이 데이터로 채워지고 SQL 및 매개 변수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="160435c9ed5f63cbd006fc1390af74d08d92e498" translate="yes" xml:space="preserve">
          <source>We have to think carefully about &lt;code&gt;get_context_data()&lt;/code&gt;. Since both &lt;a href=&quot;../../ref/class-based-views/mixins-single-object#django.views.generic.detail.SingleObjectMixin&quot;&gt;&lt;code&gt;SingleObjectMixin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.djangoproject.com/en/3.0/ref/class-based-views/flattened-index/#ListView&quot;&gt;&lt;code&gt;ListView&lt;/code&gt;&lt;/a&gt; will put things in the context data under the value of &lt;code&gt;context_object_name&lt;/code&gt; if it&amp;rsquo;s set, we&amp;rsquo;ll instead explicitly ensure the &lt;code&gt;Publisher&lt;/code&gt; is in the context data. &lt;a href=&quot;https://docs.djangoproject.com/en/3.0/ref/class-based-views/flattened-index/#ListView&quot;&gt;&lt;code&gt;ListView&lt;/code&gt;&lt;/a&gt; will add in the suitable &lt;code&gt;page_obj&lt;/code&gt; and &lt;code&gt;paginator&lt;/code&gt; for us providing we remember to call &lt;code&gt;super()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;get_context_data()&lt;/code&gt; 에 대해 신중하게 생각해야 합니다. &lt;a href=&quot;../../ref/class-based-views/mixins-single-object#django.views.generic.detail.SingleObjectMixin&quot;&gt; &lt;code&gt;SingleObjectMixin&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;https://docs.djangoproject.com/en/3.0/ref/class-based-views/flattened-index/#ListView&quot;&gt; &lt;code&gt;ListView&lt;/code&gt; &lt;/a&gt; 모두 컨텍스트 데이터 가 설정된 경우 &lt;code&gt;context_object_name&lt;/code&gt; 값 아래에 컨텍스트 데이터를 배치 하므로 &lt;code&gt;Publisher&lt;/code&gt; 가 컨텍스트 데이터에 있는지 명시 적으로 확인합니다 . &lt;a href=&quot;https://docs.djangoproject.com/en/3.0/ref/class-based-views/flattened-index/#ListView&quot;&gt; &lt;code&gt;ListView&lt;/code&gt; &lt;/a&gt; 는 우리에게 &lt;code&gt;super()&lt;/code&gt; 를 호출하는 것을 기억하는 데 적합한 &lt;code&gt;page_obj&lt;/code&gt; 및 페이지 &lt;code&gt;paginator&lt;/code&gt; 자를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="e0efbb1db19fc0d7dc8ffb262fad015a2c7b9cdf" translate="yes" xml:space="preserve">
          <source>We have to use &lt;a href=&quot;../../ref/urlresolvers#django.urls.reverse_lazy&quot;&gt;&lt;code&gt;reverse_lazy()&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;reverse()&lt;/code&gt;, as the urls are not loaded when the file is imported.</source>
          <target state="translated">파일을 가져올 때 URL이로드되지 않으므로 &lt;code&gt;reverse()&lt;/code&gt; &lt;a href=&quot;../../ref/urlresolvers#django.urls.reverse_lazy&quot;&gt; &lt;code&gt;reverse_lazy()&lt;/code&gt; &lt;/a&gt; 대신 reverse_lazy () 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="223d1aa414abcd011cb093db8170ef669b5d129d" translate="yes" xml:space="preserve">
          <source>We identify a bug</source>
          <target state="translated">우리는 버그를 식별</target>
        </trans-unit>
        <trans-unit id="03b6c402843d85d0ab3a3daabaeb0d9d9441458b" translate="yes" xml:space="preserve">
          <source>We map the URL to book list view in the URLconf:</source>
          <target state="translated">URLconf의 URL을 책 목록보기에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="d2acb7c7d04ae7422ab94eeac7f1f6194fc4ccb8" translate="yes" xml:space="preserve">
          <source>We might require some validation to occur in the browser, even before the form is submitted; we might want to use much more complex fields, that allow the user to do things like pick dates from a calendar and so on.</source>
          <target state="translated">양식을 제출하기 전에 브라우저에서 확인이 필요할 수 있습니다. 훨씬 복잡한 필드를 사용하여 사용자가 달력에서 날짜를 선택하는 등의 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e36022d2bd75747870a373de1ac5c360d5ec6a9" translate="yes" xml:space="preserve">
          <source>We need to amend the &lt;code&gt;get_queryset()&lt;/code&gt; method and change it so that it also checks the date by comparing it with &lt;code&gt;timezone.now()&lt;/code&gt;. First we need to add an import:</source>
          <target state="translated">&lt;code&gt;get_queryset()&lt;/code&gt; 메소드 를 수정하고 &lt;code&gt;timezone.now()&lt;/code&gt; 와 비교하여 날짜를 확인하도록 변경해야합니다 . 먼저 가져 오기를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="657206f41960cce5defac255a31d2bb4538ea7c8" translate="yes" xml:space="preserve">
          <source>We now have a working web form, described by a Django &lt;a href=&quot;../../ref/forms/api#django.forms.Form&quot;&gt;&lt;code&gt;Form&lt;/code&gt;&lt;/a&gt;, processed by a view, and rendered as an HTML &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이제 Django &lt;a href=&quot;../../ref/forms/api#django.forms.Form&quot;&gt; &lt;code&gt;Form&lt;/code&gt; 으로&lt;/a&gt; 설명되고 뷰로 처리되고 HTML &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 으로 렌더링 되는 작동하는 웹 양식 이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b2774d1c273a96860eb9d19dcdf390b8d0c84e2a" translate="yes" xml:space="preserve">
          <source>We ought to add a similar &lt;code&gt;get_queryset&lt;/code&gt; method to &lt;code&gt;ResultsView&lt;/code&gt; and create a new test class for that view. It&amp;rsquo;ll be very similar to what we have just created; in fact there will be a lot of repetition.</source>
          <target state="translated">&lt;code&gt;ResultsView&lt;/code&gt; 에 비슷한 &lt;code&gt;get_queryset&lt;/code&gt; 메소드 를 추가하고 해당 뷰에 대한 새 테스트 클래스를 작성해야합니다. 우리가 방금 만든 것과 매우 유사합니다. 사실 많은 반복이있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="e96ab7268710f2a9a19854775a022fa4250a16be" translate="yes" xml:space="preserve">
          <source>We passed in no data to the formset which is resulting in a valid form. The formset is smart enough to ignore extra forms that were not changed. If we provide an invalid article:</source>
          <target state="translated">양식에 데이터를 전달하지 않아서 유효한 양식이 작성되었습니다. 양식 세트는 변경되지 않은 추가 양식을 무시할만큼 영리합니다. 우리가 잘못된 기사를 제공하는 경우 :</target>
        </trans-unit>
        <trans-unit id="89af611e787898de3046cc5f2b98307b4d09ecad" translate="yes" xml:space="preserve">
          <source>We recommend using a separate Web server &amp;ndash; i.e., one that&amp;rsquo;s not also running Django &amp;ndash; for serving media. Here are some good choices:</source>
          <target state="translated">미디어를 제공하기 위해 별도의 웹 서버 (즉, Django를 실행하지 않는 서버)를 사용하는 것이 좋습니다. 다음은 좋은 선택입니다.</target>
        </trans-unit>
        <trans-unit id="9b2e5541ae2be21d3ebe970f9ffd39d29f1a7564" translate="yes" xml:space="preserve">
          <source>We set the form&amp;rsquo;s &lt;code&gt;action&lt;/code&gt; to &lt;code&gt;{% url 'polls:vote' question.id %}&lt;/code&gt;, and we set &lt;code&gt;method=&quot;post&quot;&lt;/code&gt;. Using &lt;code&gt;method=&quot;post&quot;&lt;/code&gt; (as opposed to &lt;code&gt;method=&quot;get&quot;&lt;/code&gt;) is very important, because the act of submitting this form will alter data server-side. Whenever you create a form that alters data server-side, use &lt;code&gt;method=&quot;post&quot;&lt;/code&gt;. This tip isn&amp;rsquo;t specific to Django; it&amp;rsquo;s good Web development practice in general.</source>
          <target state="translated">폼의 &lt;code&gt;action&lt;/code&gt; 을 &lt;code&gt;{% url 'polls:vote' question.id %}&lt;/code&gt; 설정하고 &lt;code&gt;method=&quot;post&quot;&lt;/code&gt; 를 설정했습니다 . 사용 &lt;code&gt;method=&quot;post&quot;&lt;/code&gt; (반대로 &lt;code&gt;method=&quot;get&quot;&lt;/code&gt; 이 양식을 제출하는 행위는 데이터 서버 측을 변경하기 때문에), 매우 중요합니다. 데이터 서버 측을 변경하는 양식을 작성할 때마다 &lt;code&gt;method=&quot;post&quot;&lt;/code&gt; 를 사용하십시오 . 이 팁은 Django에만 국한되지 않습니다. 일반적으로 좋은 웹 개발 방법입니다.</target>
        </trans-unit>
        <trans-unit id="fc42be64a47b15895b31b124661f5f6bcc3acc7e" translate="yes" xml:space="preserve">
          <source>We then need to define the &lt;code&gt;as_sql&lt;/code&gt; method. This takes a &lt;code&gt;SQLCompiler&lt;/code&gt; object, called &lt;code&gt;compiler&lt;/code&gt;, and the active database connection. &lt;code&gt;SQLCompiler&lt;/code&gt; objects are not documented, but the only thing we need to know about them is that they have a &lt;code&gt;compile()&lt;/code&gt; method which returns a tuple containing an SQL string, and the parameters to be interpolated into that string. In most cases, you don&amp;rsquo;t need to use it directly and can pass it on to &lt;code&gt;process_lhs()&lt;/code&gt; and &lt;code&gt;process_rhs()&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;as_sql&lt;/code&gt; 메소드 를 정의해야합니다 . 이것은 &lt;code&gt;compiler&lt;/code&gt; 라는 &lt;code&gt;SQLCompiler&lt;/code&gt; 객체 와 활성 데이터베이스 연결을 취 합니다. &lt;code&gt;SQLCompiler&lt;/code&gt; 객체는 문서화되어 있지 않지만, 우리가 알아야 할 유일한 것은 SQL 문자열을 포함하는 튜플을 반환하는 &lt;code&gt;compile()&lt;/code&gt; 메소드와 해당 문자열에 삽입 될 매개 변수가 있다는 것입니다. 대부분의 경우 직접 사용할 필요가 없으며 &lt;code&gt;process_lhs()&lt;/code&gt; 및 &lt;code&gt;process_rhs()&lt;/code&gt; 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b8d8ba68d6e0f92901090154023154f5ecaaec25" translate="yes" xml:space="preserve">
          <source>We use &lt;a href=&quot;../../ref/class-based-views/mixins-editing#django.views.generic.edit.FormMixin&quot;&gt;&lt;code&gt;FormMixin&lt;/code&gt;&lt;/a&gt; and implement &lt;code&gt;post()&lt;/code&gt; ourselves rather than try to mix &lt;a href=&quot;https://docs.djangoproject.com/en/3.0/ref/class-based-views/flattened-index/#DetailView&quot;&gt;&lt;code&gt;DetailView&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;https://docs.djangoproject.com/en/3.0/ref/class-based-views/flattened-index/#FormView&quot;&gt;&lt;code&gt;FormView&lt;/code&gt;&lt;/a&gt; (which provides a suitable &lt;code&gt;post()&lt;/code&gt; already) because both of the views implement &lt;code&gt;get()&lt;/code&gt;, and things would get much more confusing.</source>
          <target state="translated">두 뷰 모두 &lt;code&gt;get()&lt;/code&gt; 구현하기 때문에 &lt;a href=&quot;https://docs.djangoproject.com/en/3.0/ref/class-based-views/flattened-index/#DetailView&quot;&gt; &lt;code&gt;DetailView&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;https://docs.djangoproject.com/en/3.0/ref/class-based-views/flattened-index/#FormView&quot;&gt; &lt;code&gt;FormView&lt;/code&gt; &lt;/a&gt; ( 이미 적합한 &lt;code&gt;post()&lt;/code&gt; 이미 제공함) 를 혼합하려고하는 대신 &lt;a href=&quot;../../ref/class-based-views/mixins-editing#django.views.generic.edit.FormMixin&quot;&gt; &lt;code&gt;FormMixin&lt;/code&gt; 을&lt;/a&gt; 사용 하고 &lt;code&gt;post()&lt;/code&gt; 직접 구현 하면 상황이 훨씬 혼란스러워집니다.</target>
        </trans-unit>
        <trans-unit id="a3dc43e4be151cc2c2f7f07fc3a4db3d0d5c6c37" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;as_sqlserver()&lt;/code&gt; because &lt;code&gt;django.db.connection.vendor&lt;/code&gt; returns &lt;code&gt;sqlserver&lt;/code&gt; for the backend.</source>
          <target state="translated">&lt;code&gt;django.db.connection.vendor&lt;/code&gt; 가 백엔드에 대해 &lt;code&gt;sqlserver&lt;/code&gt; 를 리턴 하므로 &lt;code&gt;as_sqlserver()&lt;/code&gt; 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="d1ae934cc7e157b66945a5829fc84cf381d87a54" translate="yes" xml:space="preserve">
          <source>We use this approach to teach you how to override templates. In an actual project, you would probably use the &lt;a href=&quot;../ref/contrib/admin/index#django.contrib.admin.AdminSite.site_header&quot;&gt;&lt;code&gt;django.contrib.admin.AdminSite.site_header&lt;/code&gt;&lt;/a&gt; attribute to more easily make this particular customization.</source>
          <target state="translated">이 방법을 사용하여 템플릿을 재정의하는 방법을 알려줍니다. 실제 프로젝트에서는 &lt;a href=&quot;../ref/contrib/admin/index#django.contrib.admin.AdminSite.site_header&quot;&gt; &lt;code&gt;django.contrib.admin.AdminSite.site_header&lt;/code&gt; &lt;/a&gt; 속성을 사용하여이 특정 사용자 정의를보다 쉽게 ​​만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7186b750b69092f1f52f97b68bb2caf43a952b80" translate="yes" xml:space="preserve">
          <source>We will also use the following example objects:</source>
          <target state="translated">다음 예제 객체도 사용합니다.</target>
        </trans-unit>
        <trans-unit id="47682dad7df1f41009d3007a026fa2e8f5b7691e" translate="yes" xml:space="preserve">
          <source>We will assume you have done the things listed above. The rest of this document focuses on how to use Django in such a way that you are not doing unnecessary work. This document also does not address other optimization techniques that apply to all expensive operations, such as &lt;a href=&quot;../cache&quot;&gt;general purpose caching&lt;/a&gt;.</source>
          <target state="translated">위에 나열된 작업을 수행했다고 가정합니다. 이 문서의 나머지 부분에서는 불필요한 작업을하지 않는 방식으로 Django를 사용하는 방법에 중점을 둡니다. 이 문서는 &lt;a href=&quot;../cache&quot;&gt;범용 캐싱&lt;/a&gt; 과 같이 값 비싼 모든 작업에 적용되는 다른 최적화 기술도 다루지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b33e7cdc7a1ef731906fd6faafbf9ece40a257f5" translate="yes" xml:space="preserve">
          <source>We will start again with the &lt;a href=&quot;../ref/django-admin#django-admin-shell&quot;&gt;&lt;code&gt;shell&lt;/code&gt;&lt;/a&gt;, where we need to do a couple of things that won&amp;rsquo;t be necessary in &lt;code&gt;tests.py&lt;/code&gt;. The first is to set up the test environment in the &lt;a href=&quot;../ref/django-admin#django-admin-shell&quot;&gt;&lt;code&gt;shell&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">우리는 &lt;a href=&quot;../ref/django-admin#django-admin-shell&quot;&gt; &lt;code&gt;shell&lt;/code&gt; &lt;/a&gt; 에서 다시 시작할 것이다 . 여기서 &lt;code&gt;tests.py&lt;/code&gt; 에 필요하지 않은 몇 가지 일을해야한다 . 첫 번째는 &lt;a href=&quot;../ref/django-admin#django-admin-shell&quot;&gt; &lt;code&gt;shell&lt;/code&gt; &lt;/a&gt; 에서 테스트 환경을 설정하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="e63c1d31807e5eb22db7573c7e0cd9844bb8440d" translate="yes" xml:space="preserve">
          <source>We will start by writing an &lt;code&gt;AbsoluteValue&lt;/code&gt; transformer. This will use the SQL function &lt;code&gt;ABS()&lt;/code&gt; to transform the value before comparison:</source>
          <target state="translated">&lt;code&gt;AbsoluteValue&lt;/code&gt; 변환기 를 작성하는 것으로 시작하겠습니다 . SQL 함수 &lt;code&gt;ABS()&lt;/code&gt; 를 사용하여 비교하기 전에 값을 변환합니다.</target>
        </trans-unit>
        <trans-unit id="6994185dd4f0daae68ae788c5d79cf9c02209ce4" translate="yes" xml:space="preserve">
          <source>We will use the following example model:</source>
          <target state="translated">다음 예제 모델을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ea73482f7312b9913706ddd50b19565e8a02d2aa" translate="yes" xml:space="preserve">
          <source>We will use this example table:</source>
          <target state="translated">이 예제 테이블을 사용하겠습니다.</target>
        </trans-unit>
        <trans-unit id="d94a1a475857ec25945fc572e61005d3a810dcba" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll assume you have &lt;a href=&quot;install&quot;&gt;Django installed&lt;/a&gt; already. You can tell Django is installed and which version by running the following command in a shell prompt (indicated by the $ prefix):</source>
          <target state="translated">&lt;a href=&quot;install&quot;&gt;Django가&lt;/a&gt; 이미 설치되어 있다고 가정합니다 . 쉘 프롬프트 ($ 접두사로 표시)에서 다음 명령을 실행하여 Django가 설치되어 있고 어떤 버전인지 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73ee0526642e1c28139dc5025721130054297320" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll be using the following model in examples of each function:</source>
          <target state="translated">각 함수의 예에서 다음 모델을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b080e55e27e48cdce6588c57c66d42761a4c524a" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll be using the following model in math function examples:</source>
          <target state="translated">수학 함수 예제에서 다음 모델을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="77d8af3871c48b2c62d81c710fa37fac60e443bc" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll be using the following model in the subsequent examples:</source>
          <target state="translated">다음 예제에서는 다음 모델을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="224362074af2bd7d6db0791cb47c69dc48f0b8df" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll be using these models:</source>
          <target state="translated">우리는이 모델들을 사용할 것입니다 :</target>
        </trans-unit>
        <trans-unit id="eb9c88c3107897eeaf2a76497c2477389af1543e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll be walking you through contributing a patch to Django for the first time. By the end of this tutorial, you should have a basic understanding of both the tools and the processes involved. Specifically, we&amp;rsquo;ll be covering the following:</source>
          <target state="translated">Django에 처음으로 패치를 제공하는 과정을 안내합니다. 이 학습서를 마치면 도구 및 관련 프로세스에 대한 기본 지식이 있어야합니다. 구체적으로, 우리는 다음을 다룰 것입니다 :</target>
        </trans-unit>
        <trans-unit id="0cb108c95b4580462d671212818f2a14d54e7712" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll demonstrate this with the &lt;code&gt;Author&lt;/code&gt; model we used in the &lt;a href=&quot;generic-display&quot;&gt;generic class-based views introduction&lt;/a&gt;.</source>
          <target state="translated">우리는 &lt;a href=&quot;generic-display&quot;&gt;일반적인 클래스 기반 뷰 소개&lt;/a&gt; 에서 사용한 &lt;code&gt;Author&lt;/code&gt; 모델로 이것을 보여줄 것 입니다.</target>
        </trans-unit>
        <trans-unit id="a9d616ca20bcc0f2293ba609fc35bcb7f9fde0fb" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll discuss what you could put in that &lt;code&gt;polls/detail.html&lt;/code&gt; template a bit later, but if you&amp;rsquo;d like to quickly get the above example working, a file containing just:</source>
          <target state="translated">나중에 &lt;code&gt;polls/detail.html&lt;/code&gt; 템플릿에 넣을 수있는 내용에 대해 논의 할 것이지만 위의 예제를 빠르게 작동 시키려면 다음을 포함하는 파일 만 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="763ada299d1f5513368509f6164b886d2e532d64" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll keep the &lt;code&gt;GET&lt;/code&gt; handling from &lt;a href=&quot;https://docs.djangoproject.com/en/3.0/ref/class-based-views/flattened-index/#DetailView&quot;&gt;&lt;code&gt;DetailView&lt;/code&gt;&lt;/a&gt;, although we&amp;rsquo;ll have to add a &lt;a href=&quot;../../ref/forms/api#django.forms.Form&quot;&gt;&lt;code&gt;Form&lt;/code&gt;&lt;/a&gt; into the context data so we can render it in the template. We&amp;rsquo;ll also want to pull in form processing from &lt;a href=&quot;../../ref/class-based-views/mixins-editing#django.views.generic.edit.FormMixin&quot;&gt;&lt;code&gt;FormMixin&lt;/code&gt;&lt;/a&gt;, and write a bit of code so that on &lt;code&gt;POST&lt;/code&gt; the form gets called appropriately.</source>
          <target state="translated">템플릿에서 렌더링 할 수 있도록 컨텍스트 데이터에 &lt;a href=&quot;../../ref/forms/api#django.forms.Form&quot;&gt; &lt;code&gt;Form&lt;/code&gt; &lt;/a&gt; 을 추가해야하지만 &lt;a href=&quot;https://docs.djangoproject.com/en/3.0/ref/class-based-views/flattened-index/#DetailView&quot;&gt; &lt;code&gt;DetailView&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;GET&lt;/code&gt; 처리를 유지합니다 . 또한 &lt;a href=&quot;../../ref/class-based-views/mixins-editing#django.views.generic.edit.FormMixin&quot;&gt; &lt;code&gt;FormMixin&lt;/code&gt; &lt;/a&gt; 에서 양식 처리를 가져오고 &lt;code&gt;POST&lt;/code&gt; 에서 양식이 적절하게 호출 되도록 약간의 코드를 작성하려고 합니다.</target>
        </trans-unit>
        <trans-unit id="8c750857e385814a77a51e7359f94a4d51c414b3" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll look at senders &lt;a href=&quot;#connecting-to-signals-sent-by-specific-senders&quot;&gt;a bit later&lt;/a&gt;, but right now look at the &lt;code&gt;**kwargs&lt;/code&gt; argument. All signals send keyword arguments, and may change those keyword arguments at any time. In the case of &lt;a href=&quot;../ref/signals#django.core.signals.request_finished&quot;&gt;&lt;code&gt;request_finished&lt;/code&gt;&lt;/a&gt;, it&amp;rsquo;s documented as sending no arguments, which means we might be tempted to write our signal handling as &lt;code&gt;my_callback(sender)&lt;/code&gt;.</source>
          <target state="translated">우리는 발신자 &lt;a href=&quot;#connecting-to-signals-sent-by-specific-senders&quot;&gt;를 조금 후에&lt;/a&gt; 살펴볼 것이지만, 지금 &lt;code&gt;**kwargs&lt;/code&gt; 인수를 살펴보십시오 . 모든 신호는 키워드 인수를 전송하며 언제든지 키워드 인수를 변경할 수 있습니다. &lt;a href=&quot;../ref/signals#django.core.signals.request_finished&quot;&gt; &lt;code&gt;request_finished&lt;/code&gt; &lt;/a&gt; 의 경우 인수를 보내지 않는 것으로 문서화되어 신호 처리를 &lt;code&gt;my_callback(sender)&lt;/code&gt; 로 작성하려고 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c91ec2af4dfcde2a552163e5d586ec61d2a9802c" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll now implement this feature and associated tests.</source>
          <target state="translated">이제이 기능과 관련 테스트를 구현하겠습니다.</target>
        </trans-unit>
        <trans-unit id="ecf33e599bf3a0a48c4d65bea717787559521381" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll refer to the same models used in &lt;a href=&quot;queries&quot;&gt;Making queries&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;queries&quot;&gt;쿼리 만들기에&lt;/a&gt; 사용 된 것과 동일한 모델을 참조 합니다 .</target>
        </trans-unit>
        <trans-unit id="047dc08cd7b3dab69b879a2678d50f6e81394a26" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll rely on the default implementation of &lt;code&gt;get_object()&lt;/code&gt; to fetch the correct &lt;code&gt;Publisher&lt;/code&gt; object. However, we need to explicitly pass a &lt;code&gt;queryset&lt;/code&gt; argument because otherwise the default implementation of &lt;code&gt;get_object()&lt;/code&gt; would call &lt;code&gt;get_queryset()&lt;/code&gt; which we have overridden to return &lt;code&gt;Book&lt;/code&gt; objects instead of &lt;code&gt;Publisher&lt;/code&gt; ones.</source>
          <target state="translated">올바른 &lt;code&gt;Publisher&lt;/code&gt; 객체 를 가져 오기 위해 &lt;code&gt;get_object()&lt;/code&gt; 의 기본 구현을 사용 합니다. 그러나 &lt;code&gt;get_object()&lt;/code&gt; 의 기본 구현은 &lt;code&gt;get_queryset()&lt;/code&gt; 을 호출 하여 &lt;code&gt;Publisher&lt;/code&gt; 객체 대신 &lt;code&gt;Book&lt;/code&gt; 객체 를 반환하도록 재정의 했기 때문에 &lt;code&gt;queryset&lt;/code&gt; 인수 를 명시 적으로 전달해야 합니다.</target>
        </trans-unit>
        <trans-unit id="9c4548251e06e1886348b1aa5f683e176ef44520" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll start by defining the template to be used for SQL generation and an &lt;code&gt;__init__()&lt;/code&gt; method to set some attributes:</source>
          <target state="translated">먼저 SQL 생성에 사용할 템플릿과 &lt;code&gt;__init__()&lt;/code&gt; 메서드를 정의하여 몇 가지 속성을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="c1aeb67516976b953c5a92919bc8b866f38bb896" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re using this instead of simply typing &amp;ldquo;python&amp;rdquo;, because &lt;code&gt;manage.py&lt;/code&gt; sets the &lt;code&gt;DJANGO_SETTINGS_MODULE&lt;/code&gt; environment variable, which gives Django the Python import path to your &lt;code&gt;mysite/settings.py&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;manage.py&lt;/code&gt; 는 &lt;code&gt;DJANGO_SETTINGS_MODULE&lt;/code&gt; 환경 변수를 설정하여 Django에 &lt;code&gt;mysite/settings.py&lt;/code&gt; 파일 의 Python 가져 오기 경로를 제공 하기 때문에 단순히 &quot;python&quot;을 입력하는 대신 이것을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="79d7a195ab163eef181a020beabde25bf55d2a3a" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re using two generic views here: &lt;a href=&quot;../ref/class-based-views/generic-display#django.views.generic.list.ListView&quot;&gt;&lt;code&gt;ListView&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ref/class-based-views/generic-display#django.views.generic.detail.DetailView&quot;&gt;&lt;code&gt;DetailView&lt;/code&gt;&lt;/a&gt;. Respectively, those two views abstract the concepts of &amp;ldquo;display a list of objects&amp;rdquo; and &amp;ldquo;display a detail page for a particular type of object.&amp;rdquo;</source>
          <target state="translated">여기서는 일반적인 두 가지보기를 사용하고 있습니다 : &lt;a href=&quot;../ref/class-based-views/generic-display#django.views.generic.list.ListView&quot;&gt; &lt;code&gt;ListView&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../ref/class-based-views/generic-display#django.views.generic.detail.DetailView&quot;&gt; &lt;code&gt;DetailView&lt;/code&gt; &lt;/a&gt; . 각각,이 두보기는 &quot;개체 목록 표시&quot;및 &quot;특정 유형의 개체에 대한 세부 사항 페이지 표시&quot;의 개념을 추상화합니다.</target>
        </trans-unit>
        <trans-unit id="d1e5b3b6d0afba152a478ef86e04c270e924cef6" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve also defined a custom implementation that is specific to the Oracle backend. The &lt;code&gt;as_oracle()&lt;/code&gt; function will be called instead of &lt;code&gt;as_sql()&lt;/code&gt; if the Oracle backend is in use.</source>
          <target state="translated">또한 Oracle 백엔드에 고유 한 사용자 정의 구현도 정의했습니다. &lt;code&gt;as_oracle()&lt;/code&gt; 함수가 대신 호출됩니다 &lt;code&gt;as_sql()&lt;/code&gt; 오라클 백엔드가 사용중인 경우.</target>
        </trans-unit>
        <trans-unit id="d447ba890fcc516ad78217b89db5969690d6369e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve described HTML forms briefly, but an HTML &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; is just one part of the machinery required.</source>
          <target state="translated">HTML 양식을 간략하게 설명했지만 HTML &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 은 필요한 기계의 일부일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="8daaf8f525135647638730066811f34013f8ca5e" translate="yes" xml:space="preserve">
          <source>Web frameworks have to deal with URLs (which are a type of &lt;a href=&quot;https://www.ietf.org/rfc/rfc3987.txt&quot;&gt;IRI&lt;/a&gt;). One requirement of URLs is that they are encoded using only ASCII characters. However, in an international environment, you might need to construct a URL from an &lt;a href=&quot;https://www.ietf.org/rfc/rfc3987.txt&quot;&gt;IRI&lt;/a&gt; &amp;ndash; very loosely speaking, a &lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.txt&quot;&gt;URI&lt;/a&gt; that can contain Unicode characters. Use these functions for quoting and converting an IRI to a URI:</source>
          <target state="translated">웹 프레임 워크는 URL ( &lt;a href=&quot;https://www.ietf.org/rfc/rfc3987.txt&quot;&gt;IRI&lt;/a&gt; 유형 ) 을 처리해야합니다 . URL의 요구 사항 중 하나는 ASCII 문자 만 사용하여 인코딩해야한다는 것입니다. 그러나 국제 환경에서는 유니 코드 문자를 포함 할 수 있는 &lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.txt&quot;&gt;URI&lt;/a&gt; 인 &lt;a href=&quot;https://www.ietf.org/rfc/rfc3987.txt&quot;&gt;IRI&lt;/a&gt; 에서 URL을 구성해야 할 수도 있습니다 . IRI를 인용하고 URI로 변환하려면 다음 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e3cacb431dcd6f5ad84f9067d03caf8014ac077d" translate="yes" xml:space="preserve">
          <source>Web servers should automatically strip the content of responses to HEAD requests while leaving the headers unchanged, so you may handle HEAD requests exactly like GET requests in your views. Since some software, such as link checkers, rely on HEAD requests, you might prefer using &lt;code&gt;require_safe&lt;/code&gt; instead of &lt;code&gt;require_GET&lt;/code&gt;.</source>
          <target state="translated">웹 서버는 헤더를 변경하지 않고 HEAD 요청에 대한 응답 내용을 자동으로 제거하므로 뷰에서 GET 요청과 같은 HEAD 요청을 처리 할 수 ​​있습니다. 일부 소프트웨어 때문에, 이러한 링크 검사기로, HEAD 요청에 사용 선호 할 수도 의존 &lt;code&gt;require_safe&lt;/code&gt; 대신 &lt;code&gt;require_GET&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="ced4ef0c8aff57dd4677ea5d3d1381403fa1486a" translate="yes" xml:space="preserve">
          <source>Websites generally need to serve additional files such as images, JavaScript, or CSS. In Django, we refer to these files as &amp;ldquo;static files&amp;rdquo;. Django provides &lt;a href=&quot;../../ref/contrib/staticfiles#module-django.contrib.staticfiles&quot;&gt;&lt;code&gt;django.contrib.staticfiles&lt;/code&gt;&lt;/a&gt; to help you manage them.</source>
          <target state="translated">웹 사이트는 일반적으로 이미지, JavaScript 또는 CSS와 같은 추가 파일을 제공해야합니다. Django에서는 이러한 파일을&amp;ldquo;정적 파일&amp;rdquo;이라고합니다. Django는 &lt;a href=&quot;../../ref/contrib/staticfiles#module-django.contrib.staticfiles&quot;&gt; &lt;code&gt;django.contrib.staticfiles&lt;/code&gt; &lt;/a&gt; 을 제공 하여 파일 관리에 도움을줍니다.</target>
        </trans-unit>
        <trans-unit id="2486ded59242b22c93f91c0413ca9cdb8ba66c34" translate="yes" xml:space="preserve">
          <source>Weighting queries</source>
          <target state="translated">가중치 쿼리</target>
        </trans-unit>
        <trans-unit id="fe1179206f1dde85454521032eb1a8affb336433" translate="yes" xml:space="preserve">
          <source>Weighting words based on different criteria such as how frequently they appear in the text, or the importance of the fields, such as the title or keywords, that they appear in.</source>
          <target state="translated">텍스트에 나타나는 빈도 또는 제목 또는 키워드와 같은 필드의 중요성과 같은 다른 기준에 따라 단어에 가중치를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="dc5c22c786fe9ac36f3c8e095c9c31ab6bb61f24" translate="yes" xml:space="preserve">
          <source>Well, if you&amp;rsquo;re dealing with a model object, this is already done for you. When you are dealing with an object or queryset, Django is able to populate the context using the lowercased version of the model class&amp;rsquo; name. This is provided in addition to the default &lt;code&gt;object_list&lt;/code&gt; entry, but contains exactly the same data, i.e. &lt;code&gt;publisher_list&lt;/code&gt;.</source>
          <target state="translated">글쎄, 당신이 모델 객체를 다루고 있다면, 이것은 이미 당신을 위해 이루어졌습니다. 객체 또는 쿼리 셋을 다룰 때, Django는 소문자 버전의 모델 클래스 이름을 사용하여 컨텍스트를 채울 수 있습니다. 이것은 기본 &lt;code&gt;object_list&lt;/code&gt; 항목 외에 제공 되지만 정확히 동일한 데이터 (예 : &lt;code&gt;publisher_list&lt;/code&gt; )를 포함 합니다.</target>
        </trans-unit>
        <trans-unit id="bbe1ad8ffb0513c5ff715c6bca2c1b63bc23f395" translate="yes" xml:space="preserve">
          <source>Well, the first question is, do you really need to?</source>
          <target state="translated">첫 번째 질문은 정말로 필요한가?</target>
        </trans-unit>
        <trans-unit id="fd0ee5d6d6e7da918b154e0536134f2373631aa3" translate="yes" xml:space="preserve">
          <source>What Django looks for when it loads a migration file (as a Python module) is a subclass of &lt;code&gt;django.db.migrations.Migration&lt;/code&gt; called &lt;code&gt;Migration&lt;/code&gt;. It then inspects this object for four attributes, only two of which are used most of the time:</source>
          <target state="translated">무엇 장고는 (파이썬 모듈로) 마이그레이션 파일을로드 할 때 찾는 것은의 서브 클래스입니다 &lt;code&gt;django.db.migrations.Migration&lt;/code&gt; 이 라는 &lt;code&gt;Migration&lt;/code&gt; . 그런 다음이 개체에서 네 가지 특성을 검사하며 그 중 두 가지만 대부분 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="73d5a2cbae3880889ba2c36cf05438ecc4afa8c9" translate="yes" xml:space="preserve">
          <source>What are automated tests?</source>
          <target state="translated">자동 테스트 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="a90f741b287880d6b8238a4682cede2000d25a06" translate="yes" xml:space="preserve">
          <source>What are you optimizing &lt;em&gt;for&lt;/em&gt;?</source>
          <target state="translated">무엇을 최적화 &lt;em&gt;하고&lt;/em&gt; 있습니까?</target>
        </trans-unit>
        <trans-unit id="49d785fdf1aaeeffbaf02a3e6848571c383be3f9" translate="yes" xml:space="preserve">
          <source>What does a field class do?</source>
          <target state="translated">현장 수업은 무엇을합니까?</target>
        </trans-unit>
        <trans-unit id="3600de883e3134ae04e19a0fbfcb7919eacd6460" translate="yes" xml:space="preserve">
          <source>What does this mean in practice?</source>
          <target state="translated">이것이 실제로 무엇을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="50059d13dad33d56222a97f97ac957c4aa6ee416" translate="yes" xml:space="preserve">
          <source>What does this tutorial cover?</source>
          <target state="translated">이 튜토리얼은 무엇을 다루나요?</target>
        </trans-unit>
        <trans-unit id="209ae8aa9ffb9d033d311becbfae81206edc8933" translate="yes" xml:space="preserve">
          <source>What follows are examples of operations that can be performed using the Python API facilities.</source>
          <target state="translated">다음은 Python API 기능을 사용하여 수행 할 수있는 작업의 예입니다.</target>
        </trans-unit>
        <trans-unit id="2ee343555ab5a3c52abcbce735167379d27fe26c" translate="yes" xml:space="preserve">
          <source>What functions may be aliased as &lt;code&gt;_&lt;/code&gt;?</source>
          <target state="translated">어떤 함수가 &lt;code&gt;_&lt;/code&gt; 로 별칭을 지정할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="ae9ab6813edb3233457948992b74de91dd6367a7" translate="yes" xml:space="preserve">
          <source>What happened is this:</source>
          <target state="translated">무슨 일이 있었습니까?</target>
        </trans-unit>
        <trans-unit id="21359d35a68bc966b5546b0bb679ba74f497f023" translate="yes" xml:space="preserve">
          <source>What happens when you save?</source>
          <target state="translated">당신이 저장하면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="2cfbb160725e8c3d2c4e97ea22a9c9d24194252b" translate="yes" xml:space="preserve">
          <source>What if we want to find out how many clients there are for each &lt;code&gt;account_type&lt;/code&gt;? We can use the &lt;code&gt;filter&lt;/code&gt; argument of &lt;a href=&quot;querysets#aggregation-functions&quot;&gt;aggregate functions&lt;/a&gt; to achieve this:</source>
          <target state="translated">각 &lt;code&gt;account_type&lt;/code&gt; 에 대해 얼마나 많은 클라이언트가 있는지 확인하려면 어떻게해야 합니까? &lt;a href=&quot;querysets#aggregation-functions&quot;&gt;집계 함수&lt;/a&gt; 의 &lt;code&gt;filter&lt;/code&gt; 인수를 사용하여 이를 달성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f2f304800d05b0d7afc70e62b9335abbc72aede3" translate="yes" xml:space="preserve">
          <source>What is GEOS?</source>
          <target state="translated">GEOS 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="bc86744d7c979d0ab7fd2d3f9b8fc90e9c8ded8f" translate="yes" xml:space="preserve">
          <source>What spatial reference system an integer SRID corresponds to may depend on the spatial database used. In other words, the SRID numbers used for Oracle are not necessarily the same as those used by PostGIS.</source>
          <target state="translated">정수 SRID가 대응하는 공간 기준 시스템은 사용 된 공간 데이터베이스에 따라 달라질 수있다. 즉, Oracle에 사용 된 SRID 번호는 PostGIS에서 사용 된 SRID 번호와 반드시 같을 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="38abffa7d6e05df914d0e0cfa3a9331b7bdaaa1b" translate="yes" xml:space="preserve">
          <source>What the URLconf searches against</source>
          <target state="translated">URLconf가 검색하는 것</target>
        </trans-unit>
        <trans-unit id="3fae8ea3c4ffe4022a514e2fafbaaa78ddff879a" translate="yes" xml:space="preserve">
          <source>What to read next</source>
          <target state="translated">다음에 읽어야 할 것</target>
        </trans-unit>
        <trans-unit id="6eca7c9a97d2a7c5deebe98003d01aae75432333" translate="yes" xml:space="preserve">
          <source>What we have works well; however, even though future questions don&amp;rsquo;t appear in the &lt;em&gt;index&lt;/em&gt;, users can still reach them if they know or guess the right URL. So we need to add a similar constraint to &lt;code&gt;DetailView&lt;/code&gt;:</source>
          <target state="translated">우리가 잘하는 것; 그러나 향후 질문이 &lt;em&gt;색인에&lt;/em&gt; 나타나지 않더라도 사용자는 올바른 URL을 알고 있거나 추측 할 경우 여전히 질문에 도달 할 수 있습니다. 따라서 &lt;code&gt;DetailView&lt;/code&gt; 에 비슷한 제약을 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="df6ffeb464676f8a5b4baac3001093be8375caea" translate="yes" xml:space="preserve">
          <source>What we need is a way to calculate summary values over the objects that belong to this &lt;code&gt;QuerySet&lt;/code&gt;. This is done by appending an &lt;code&gt;aggregate()&lt;/code&gt; clause onto the &lt;code&gt;QuerySet&lt;/code&gt;:</source>
          <target state="translated">우리가 필요로하는 것은이 &lt;code&gt;QuerySet&lt;/code&gt; 에 속하는 객체에 대한 요약 값을 계산하는 방법 입니다. 이것은 &lt;code&gt;QuerySet&lt;/code&gt; 에 &lt;code&gt;aggregate()&lt;/code&gt; 절을 추가하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="ebf37cb3a8ec4afc59cdb8f8742be6dd66d19c60" translate="yes" xml:space="preserve">
          <source>What we&amp;rsquo;re really trying to do here is to use two different class based views from the same URL. So why not do just that? We have a very clear division here: &lt;code&gt;GET&lt;/code&gt; requests should get the &lt;a href=&quot;https://docs.djangoproject.com/en/3.0/ref/class-based-views/flattened-index/#DetailView&quot;&gt;&lt;code&gt;DetailView&lt;/code&gt;&lt;/a&gt; (with the &lt;a href=&quot;../../ref/forms/api#django.forms.Form&quot;&gt;&lt;code&gt;Form&lt;/code&gt;&lt;/a&gt; added to the context data), and &lt;code&gt;POST&lt;/code&gt; requests should get the &lt;a href=&quot;https://docs.djangoproject.com/en/3.0/ref/class-based-views/flattened-index/#FormView&quot;&gt;&lt;code&gt;FormView&lt;/code&gt;&lt;/a&gt;. Let&amp;rsquo;s set up those views first.</source>
          <target state="translated">우리가 실제로하려고하는 것은 동일한 URL에서 두 개의 다른 클래스 기반보기를 사용하는 것입니다. 왜 그렇게하지 않습니까? : 우리는 여기에 아주 명확한 구분이 &lt;code&gt;GET&lt;/code&gt; 의 요청이 가야 &lt;a href=&quot;https://docs.djangoproject.com/en/3.0/ref/class-based-views/flattened-index/#DetailView&quot;&gt; &lt;code&gt;DetailView&lt;/code&gt; 를&lt;/a&gt; 합니다 (와 &lt;a href=&quot;../../ref/forms/api#django.forms.Form&quot;&gt; &lt;code&gt;Form&lt;/code&gt; &lt;/a&gt; 컨텍스트 데이터에 추가), 및 &lt;code&gt;POST&lt;/code&gt; 의 요청이 가야 &lt;a href=&quot;https://docs.djangoproject.com/en/3.0/ref/class-based-views/flattened-index/#FormView&quot;&gt; &lt;code&gt;FormView&lt;/code&gt; 를&lt;/a&gt; . 먼저 이러한 뷰를 설정하겠습니다.</target>
        </trans-unit>
        <trans-unit id="5515466b8a99342a704c54b376a52ff906321c66" translate="yes" xml:space="preserve">
          <source>What we&amp;rsquo;ve just done in the &lt;a href=&quot;../ref/django-admin#django-admin-shell&quot;&gt;&lt;code&gt;shell&lt;/code&gt;&lt;/a&gt; to test for the problem is exactly what we can do in an automated test, so let&amp;rsquo;s turn that into an automated test.</source>
          <target state="translated">&lt;a href=&quot;../ref/django-admin#django-admin-shell&quot;&gt; &lt;code&gt;shell&lt;/code&gt; &lt;/a&gt; 에서 문제를 테스트하기 위해 방금 수행 한 작업 은 자동화 된 테스트에서 수행 할 수있는 작업과 정확히 일치하므로이를 자동화 된 테스트로 바꿔 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="9d4113a7d518fa0336cf182ad7bf88bbf845c70d" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s a &amp;ldquo;fixture&amp;rdquo;?</source>
          <target state="translated">&amp;ldquo;픽스처&amp;rdquo;란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="0f2e25adec3c48ee54304ad2c335260c06b43021" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s different in &lt;em&gt;automated&lt;/em&gt; tests is that the testing work is done for you by the system. You create a set of tests once, and then as you make changes to your app, you can check that your code still works as you originally intended, without having to perform time consuming manual testing.</source>
          <target state="translated">&lt;em&gt;자동화 된&lt;/em&gt; 테스트 와 다른 점은 테스트 작업이 시스템에서 수행된다는 것입니다. 테스트 세트를 한 번 만든 다음 앱을 변경할 때 시간이 많이 걸리는 수동 테스트를 수행하지 않고도 코드가 원래 의도 한대로 작동하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f1520394d28503f78dc8be072bc6cd246458d1d" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s next after creating a pull request?</source>
          <target state="translated">풀 요청을 만든 후 다음은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="0c564930a438d61179a5f862967e76654c4d3aaa" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s next?</source>
          <target state="translated">무엇 향후 계획?</target>
        </trans-unit>
        <trans-unit id="15a658302c48a33d9ee50d1f5419c52f2f1d8034" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s the difference between a project and an app? An app is a Web application that does something &amp;ndash; e.g., a Weblog system, a database of public records or a small poll app. A project is a collection of configuration and apps for a particular website. A project can contain multiple apps. An app can be in multiple projects.</source>
          <target state="translated">프로젝트와 앱의 차이점은 무엇입니까? 앱은 웹 로그 시스템, 공개 레코드 데이터베이스 또는 소규모 설문 조사 앱과 같은 작업을 수행하는 웹 애플리케이션입니다. 프로젝트는 특정 웹 사이트의 구성 및 앱 모음입니다. 프로젝트에는 여러 앱이 포함될 수 있습니다. 앱은 여러 프로젝트에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04f28f5d914e67c96004dd694d92258abd0c7141" translate="yes" xml:space="preserve">
          <source>Whatever features you add to your custom &lt;code&gt;Manager&lt;/code&gt;, it must be possible to make a shallow copy of a &lt;code&gt;Manager&lt;/code&gt; instance; i.e., the following code must work:</source>
          <target state="translated">사용자 정의 &lt;code&gt;Manager&lt;/code&gt; 에 추가하는 기능이 무엇이든 상관없이 &lt;code&gt;Manager&lt;/code&gt; 인스턴스 의 간단한 사본을 만들 수 있어야 합니다. 즉, 다음 코드가 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="987929f581043dd44f61bd2c584b51d10539e03a" translate="yes" xml:space="preserve">
          <source>Whatever fields you use for a natural key must be able to uniquely identify an object. This will usually mean that your model will have a uniqueness clause (either unique=True on a single field, or &lt;code&gt;unique_together&lt;/code&gt; over multiple fields) for the field or fields in your natural key. However, uniqueness doesn&amp;rsquo;t need to be enforced at the database level. If you are certain that a set of fields will be effectively unique, you can still use those fields as a natural key.</source>
          <target state="translated">자연 키에 사용하는 모든 필드는 객체를 고유하게 식별 할 수 있어야합니다. 이는 일반적으로 모델에 자연 키의 필드에 대해 고유성 절 (단일 필드에서 unique = True 또는 여러 필드에서 &lt;code&gt;unique_together&lt;/code&gt; )을 갖음 을 의미합니다. 그러나 데이터베이스 수준에서 고유성을 적용 할 필요는 없습니다. 필드 세트가 효과적으로 고유 할 것이라고 확신하는 경우 해당 필드를 여전히 자연 키로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="780c3ac757cd456f35b4b9267755186ee7fcae8d" translate="yes" xml:space="preserve">
          <source>Whatever the data submitted with a form, once it has been successfully validated by calling &lt;code&gt;is_valid()&lt;/code&gt; (and &lt;code&gt;is_valid()&lt;/code&gt; has returned &lt;code&gt;True&lt;/code&gt;), the validated form data will be in the &lt;code&gt;form.cleaned_data&lt;/code&gt; dictionary. This data will have been nicely converted into Python types for you.</source>
          <target state="translated">양식과 함께 제출 된 데이터가 무엇이든, &lt;code&gt;is_valid()&lt;/code&gt; 를 호출하여 성공적으로 유효성이 검증되면 ( &lt;code&gt;is_valid()&lt;/code&gt; 가 &lt;code&gt;True&lt;/code&gt; 를 리턴 한 경우 ), 유효성이 검증 된 양식 데이터는 &lt;code&gt;form.cleaned_data&lt;/code&gt; 사전에 있습니다. 이 데이터는 파이썬 유형으로 훌륭하게 변환되었습니다.</target>
        </trans-unit>
        <trans-unit id="4de9dbf82e7c4f1a199c68eb694c7ee30ba4708c" translate="yes" xml:space="preserve">
          <source>Whatever value is or was on &lt;code&gt;reporter.stories_filed&lt;/code&gt;, Python never gets to know about it - it is dealt with entirely by the database. All Python does, through Django&amp;rsquo;s &lt;code&gt;F()&lt;/code&gt; class, is create the SQL syntax to refer to the field and describe the operation.</source>
          <target state="translated">&lt;code&gt;reporter.stories_filed&lt;/code&gt; 에 있거나 그 가치가 무엇이든 , 파이썬은 결코 그것에 대해 알지 못합니다-그것은 데이터베이스에 의해 전적으로 처리됩니다. 모든 Python은 Django의 &lt;code&gt;F()&lt;/code&gt; 클래스를 통해 필드를 참조하고 작업을 설명하는 SQL 구문을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="54face92924e906d3eac2a3ec37de7864281ecc4" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#creating-message-files-from-js-code&quot;&gt;creating message files from JavaScript source code&lt;/a&gt; you need to use the special &lt;code&gt;djangojs&lt;/code&gt; domain, &lt;strong&gt;not&lt;/strong&gt;&lt;code&gt;-e js&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#creating-message-files-from-js-code&quot;&gt;JavaScript 소스 코드에서 메시지 파일을 작성할&lt;/a&gt; 때 &lt;code&gt;-e js&lt;/code&gt; 가&lt;strong&gt;아닌&lt;/strong&gt; 특수 &lt;code&gt;djangojs&lt;/code&gt; 도메인 을 사용해야합니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c4eec7d7d5daca200324ce0e8b8d1f109846f529" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#django.contrib.admin.ModelAdmin.save_as&quot;&gt;&lt;code&gt;save_as=True&lt;/code&gt;&lt;/a&gt;, the default redirect after saving the new object is to the change view for that object. If you set &lt;code&gt;save_as_continue=False&lt;/code&gt;, the redirect will be to the changelist view.</source>
          <target state="translated">때 &lt;a href=&quot;#django.contrib.admin.ModelAdmin.save_as&quot;&gt; &lt;code&gt;save_as=True&lt;/code&gt; &lt;/a&gt; , 새 개체를 저장 한 후 기본 리디렉션 해당 개체에 대한 변경보기로한다. &lt;code&gt;save_as_continue=False&lt;/code&gt; 를 설정 하면 변경 목록보기로 경로 재 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="e1b58b2876ee1b53da723f34b8bf2f76d912ee9c" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#django.contrib.auth.mixins.AccessMixin.raise_exception&quot;&gt;&lt;code&gt;raise_exception&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;True&lt;/code&gt;, this method can be used to control the error message passed to the error handler for display to the user. Returns the &lt;a href=&quot;#django.contrib.auth.mixins.AccessMixin.permission_denied_message&quot;&gt;&lt;code&gt;permission_denied_message&lt;/code&gt;&lt;/a&gt; attribute by default.</source>
          <target state="translated">경우 &lt;a href=&quot;#django.contrib.auth.mixins.AccessMixin.raise_exception&quot;&gt; &lt;code&gt;raise_exception&lt;/code&gt; 가&lt;/a&gt; 있다 &lt;code&gt;True&lt;/code&gt; ,이 방법은 사용자에게 디스플레이 오류 처리기로 전달 된 에러 메시지를 제어하기 위해 사용될 수있다. 기본적으로 &lt;a href=&quot;#django.contrib.auth.mixins.AccessMixin.permission_denied_message&quot;&gt; &lt;code&gt;permission_denied_message&lt;/code&gt; &lt;/a&gt; 속성을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="39edf3421230df0fe87e02d979bd6550c6912094" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#django.views.generic.detail.SingleObjectMixin.query_pk_and_slug&quot;&gt;&lt;code&gt;query_pk_and_slug&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;get_object()&lt;/code&gt; will perform its lookup using both the primary key and the slug.</source>
          <target state="translated">경우 &lt;a href=&quot;#django.views.generic.detail.SingleObjectMixin.query_pk_and_slug&quot;&gt; &lt;code&gt;query_pk_and_slug&lt;/code&gt; 가&lt;/a&gt; 인 &lt;code&gt;True&lt;/code&gt; , &lt;code&gt;get_object()&lt;/code&gt; 기본 키와 슬러그 모두를 사용하여 검색을 수행 할 것이다.</target>
        </trans-unit>
        <trans-unit id="2a96433fef861e8751b38f9ad0ee8b3ab562ec74" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#std:setting-DEBUG&quot;&gt;&lt;code&gt;DEBUG&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;ALLOWED_HOSTS&lt;/code&gt; is empty, the host is validated against &lt;code&gt;['localhost', '127.0.0.1', '[::1]']&lt;/code&gt;.</source>
          <target state="translated">때 &lt;a href=&quot;#std:setting-DEBUG&quot;&gt; &lt;code&gt;DEBUG&lt;/code&gt; 가&lt;/a&gt; 있다 &lt;code&gt;True&lt;/code&gt; 과 &lt;code&gt;ALLOWED_HOSTS&lt;/code&gt; 가 비어 호스트에 대해 검증 &lt;code&gt;['localhost', '127.0.0.1', '[::1]']&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b786200e2e2862908e9858456e92bfd86ad34d63" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#std:setting-USE_L10N&quot;&gt;&lt;code&gt;USE_L10N&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;True&lt;/code&gt;, the locale-dictated format has higher precedence and will be applied instead.</source>
          <target state="translated">때 &lt;a href=&quot;#std:setting-USE_L10N&quot;&gt; &lt;code&gt;USE_L10N&lt;/code&gt; 가&lt;/a&gt; 있다 &lt;code&gt;True&lt;/code&gt; , 로케일 구술 형식은 높은 우선 순위를 가지고 있으며, 대신 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="35abb370fc03c6da6e2c136a576ddf684be0ea28" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#std:setting-USE_TZ&quot;&gt;&lt;code&gt;USE_TZ&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;False&lt;/code&gt;, it is an error to set this option.</source>
          <target state="translated">때 &lt;a href=&quot;#std:setting-USE_TZ&quot;&gt; &lt;code&gt;USE_TZ&lt;/code&gt; 이&lt;/a&gt; 있다 &lt;code&gt;False&lt;/code&gt; ,이 옵션을 설정하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="a645f847d9b1f7dfe1442293862a225073b47caa" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#std:setting-USE_TZ&quot;&gt;&lt;code&gt;USE_TZ&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;False&lt;/code&gt;, this is the time zone in which Django will store all datetimes. When &lt;a href=&quot;#std:setting-USE_TZ&quot;&gt;&lt;code&gt;USE_TZ&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;True&lt;/code&gt;, this is the default time zone that Django will use to display datetimes in templates and to interpret datetimes entered in forms.</source>
          <target state="translated">때 &lt;a href=&quot;#std:setting-USE_TZ&quot;&gt; &lt;code&gt;USE_TZ&lt;/code&gt; 이&lt;/a&gt; 있다 &lt;code&gt;False&lt;/code&gt; 이 장고 모든 날짜 시간을 저장하는 시간 영역입니다. 때 &lt;a href=&quot;#std:setting-USE_TZ&quot;&gt; &lt;code&gt;USE_TZ&lt;/code&gt; 가&lt;/a&gt; 있다 &lt;code&gt;True&lt;/code&gt; 이 장고 템플릿에 표시 날짜 시간에 사용 및 양식에 입력 한 날짜 시간을 해석하는 기본 시간대입니다.</target>
        </trans-unit>
        <trans-unit id="7e84b7eff65b046bdf31d4c4bb666b31f1e95271" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#std:setting-USE_TZ&quot;&gt;&lt;code&gt;USE_TZ&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;True&lt;/code&gt; and the database doesn&amp;rsquo;t support time zones (e.g. SQLite, MySQL, Oracle), Django reads and writes datetimes in local time according to this option if it is set and in UTC if it isn&amp;rsquo;t.</source>
          <target state="translated">때 &lt;a href=&quot;#std:setting-USE_TZ&quot;&gt; &lt;code&gt;USE_TZ&lt;/code&gt; 는&lt;/a&gt; 것입니다 &lt;code&gt;True&lt;/code&gt; 데이터베이스는 시간대를 지원하지 않습니다 (예를 들어, SQLite는은, MySQL은, 오라클), 장고 읽기와 그렇지 않은 경우가 설정된 경우이 옵션에 따라와 UTC에서 현지 시간으로 날짜 시간을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="52e571402d09016980c16852db8806f0f6cc2bfd" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#std:setting-USE_TZ&quot;&gt;&lt;code&gt;USE_TZ&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;True&lt;/code&gt; and the database supports time zones (e.g. PostgreSQL), it is an error to set this option.</source>
          <target state="translated">때 &lt;a href=&quot;#std:setting-USE_TZ&quot;&gt; &lt;code&gt;USE_TZ&lt;/code&gt; 가&lt;/a&gt; 있다 &lt;code&gt;True&lt;/code&gt; 데이터베이스 시간대 (예를 들어, PostgreSQL을)를 지원,이 옵션을 설정하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="8ab1087dcba0b177d632f8a9fb32c9532b072a32" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;../../../ref/contrib/staticfiles#module-django.contrib.staticfiles&quot;&gt;&lt;code&gt;django.contrib.staticfiles&lt;/code&gt;&lt;/a&gt; is in &lt;a href=&quot;../../../ref/settings#std:setting-INSTALLED_APPS&quot;&gt;&lt;code&gt;INSTALLED_APPS&lt;/code&gt;&lt;/a&gt;, the Django development server automatically serves the static files of the admin app (and any other installed apps). This is however not the case when you use any other server arrangement. You&amp;rsquo;re responsible for setting up Apache, or whichever Web server you&amp;rsquo;re using, to serve the admin files.</source>
          <target state="translated">&lt;a href=&quot;../../../ref/contrib/staticfiles#module-django.contrib.staticfiles&quot;&gt; &lt;code&gt;django.contrib.staticfiles&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;../../../ref/settings#std:setting-INSTALLED_APPS&quot;&gt; &lt;code&gt;INSTALLED_APPS&lt;/code&gt; 에&lt;/a&gt; 있으면 Django 개발 서버는 자동으로 관리 앱 (및 기타 설치된 앱)의 정적 파일을 제공합니다. 그러나 다른 서버 배열을 사용하는 경우에는 해당되지 않습니다. 관리자 파일을 제공하기 위해 Apache 또는 사용중인 웹 서버를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="3b50175f0680c819ffc7a719fe6b23a4f2af0a27" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;../../ref/settings#std:setting-DATABASE-ATOMIC_REQUESTS&quot;&gt;&lt;code&gt;ATOMIC_REQUESTS&lt;/code&gt;&lt;/a&gt; is enabled, it&amp;rsquo;s still possible to prevent views from running in a transaction.</source>
          <target state="translated">때 &lt;a href=&quot;../../ref/settings#std:setting-DATABASE-ATOMIC_REQUESTS&quot;&gt; &lt;code&gt;ATOMIC_REQUESTS&lt;/code&gt; 가&lt;/a&gt; 활성화되어, 그것은 트랜잭션에서 실행 뷰를 방지하는 것은 여전히 가능합니다.</target>
        </trans-unit>
        <trans-unit id="6c2cd04fc26581cf986214f076f70474d7264eee" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;../../ref/settings#std:setting-DEBUG&quot;&gt;&lt;code&gt;DEBUG = False&lt;/code&gt;&lt;/a&gt;, Django doesn&amp;rsquo;t work at all without a suitable value for &lt;a href=&quot;../../ref/settings#std:setting-ALLOWED_HOSTS&quot;&gt;&lt;code&gt;ALLOWED_HOSTS&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../ref/settings#std:setting-DEBUG&quot;&gt; &lt;code&gt;DEBUG = False&lt;/code&gt; &lt;/a&gt; 일 때 Django는 &lt;a href=&quot;../../ref/settings#std:setting-ALLOWED_HOSTS&quot;&gt; &lt;code&gt;ALLOWED_HOSTS&lt;/code&gt; 에&lt;/a&gt; 적합한 값이 없으면 전혀 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d3d8a8b962fbf0384bf1184ef985c582adc01f8f" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;../../ref/settings#std:setting-DEBUG&quot;&gt;&lt;code&gt;DEBUG&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;True&lt;/code&gt;, you can provide a message to &lt;code&gt;Http404&lt;/code&gt; and it will appear in the standard 404 debug template. Use these messages for debugging purposes; they generally aren&amp;rsquo;t suitable for use in a production 404 template.</source>
          <target state="translated">때 &lt;a href=&quot;../../ref/settings#std:setting-DEBUG&quot;&gt; &lt;code&gt;DEBUG&lt;/code&gt; 가&lt;/a&gt; 있다 &lt;code&gt;True&lt;/code&gt; , 당신에게 메시지를 제공 할 수 &lt;code&gt;Http404&lt;/code&gt; 을 그리고 표준 404 디버그 템플릿에 나타납니다. 디버깅 목적으로이 메시지를 사용하십시오. 그것들은 일반적으로 프로덕션 404 템플릿에 사용하기에 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e6d7057736e395edf7b8c0761777458f5893d5be" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;../../ref/settings#std:setting-USE_TZ&quot;&gt;&lt;code&gt;USE_TZ&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;True&lt;/code&gt;, Django still accepts naive datetime objects, in order to preserve backwards-compatibility. When the database layer receives one, it attempts to make it aware by interpreting it in the &lt;a href=&quot;#default-current-time-zone&quot;&gt;default time zone&lt;/a&gt; and raises a warning.</source>
          <target state="translated">때 &lt;a href=&quot;../../ref/settings#std:setting-USE_TZ&quot;&gt; &lt;code&gt;USE_TZ&lt;/code&gt; 가&lt;/a&gt; 있다 &lt;code&gt;True&lt;/code&gt; , 장고는 여전히 이전 버전과의 호환성을 유지하기 위해, 순진 날짜 객체를 받아들입니다. 데이터베이스 계층이 데이터베이스 계층을 수신하면이를 &lt;a href=&quot;#default-current-time-zone&quot;&gt;기본 시간대&lt;/a&gt; 로 해석하여이를 인식하려고 시도 하고 경고를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="e1e4b43eb2f5455ef3fd9052ac4d560cf74b0a7d" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;../../ref/settings#std:setting-USE_TZ&quot;&gt;&lt;code&gt;USE_TZ&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;True&lt;/code&gt;, this is useful to preserve backwards-compatibility with applications that still rely on local time. However, &lt;a href=&quot;#naive-datetime-objects&quot;&gt;as explained above&lt;/a&gt;, this isn&amp;rsquo;t entirely reliable, and you should always work with aware datetimes in UTC in your own code. For instance, use &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#datetime.datetime.fromtimestamp&quot;&gt;&lt;code&gt;fromtimestamp()&lt;/code&gt;&lt;/a&gt; and set the &lt;code&gt;tz&lt;/code&gt; parameter to &lt;a href=&quot;../../ref/utils#django.utils.timezone.utc&quot;&gt;&lt;code&gt;utc&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">때 &lt;a href=&quot;../../ref/settings#std:setting-USE_TZ&quot;&gt; &lt;code&gt;USE_TZ&lt;/code&gt; 가&lt;/a&gt; 있다 &lt;code&gt;True&lt;/code&gt; , 이것은 여전히 현지 시간에 의존하는 응용 프로그램과 이전 버전과의 호환성을 유지하는 데 유용합니다. 그러나 &lt;a href=&quot;#naive-datetime-objects&quot;&gt;위에서 설명한 것처럼&lt;/a&gt; 이것이 완전히 신뢰할 수는 없으며 항상 UTC로 인식하는 날짜 시간을 자체 코드로 사용해야합니다. 예를 들어 &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#datetime.datetime.fromtimestamp&quot;&gt; &lt;code&gt;fromtimestamp()&lt;/code&gt; &lt;/a&gt; 를 사용하고 &lt;code&gt;tz&lt;/code&gt; 매개 변수를 &lt;a href=&quot;../../ref/utils#django.utils.timezone.utc&quot;&gt; &lt;code&gt;utc&lt;/code&gt; 로&lt;/a&gt; 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="f31d5e090ee6d233bb5c9aa648c6b52809501fc5" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;../../topics/i18n/timezones&quot;&gt;time zone support&lt;/a&gt; is enabled and &lt;code&gt;date_field&lt;/code&gt; is a &lt;code&gt;DateTimeField&lt;/code&gt;, dates are assumed to be in the current time zone. Otherwise, the queryset could include objects from the previous or the next day in the end user&amp;rsquo;s time zone.</source>
          <target state="translated">시 &lt;a href=&quot;../../topics/i18n/timezones&quot;&gt;시간대 지원이&lt;/a&gt; 활성화되어 &lt;code&gt;date_field&lt;/code&gt; A는 &lt;code&gt;DateTimeField&lt;/code&gt; , 날짜는 현재 시간 영역에있는 것으로 가정한다. 그렇지 않으면 쿼리 집합에 최종 사용자 시간대의 전날 또는 다음 날의 개체가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72677e01e448c4a67c8b2f3229218908d4742d51" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;../ref/settings#std:setting-DEBUG&quot;&gt;&lt;code&gt;DEBUG&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;False&lt;/code&gt;, Django will email the users listed in the &lt;a href=&quot;../ref/settings#std:setting-ADMINS&quot;&gt;&lt;code&gt;ADMINS&lt;/code&gt;&lt;/a&gt; setting whenever your code raises an unhandled exception and results in an internal server error (strictly speaking, for any response with an HTTP status code of 500 or greater). This gives the administrators immediate notification of any errors. The &lt;a href=&quot;../ref/settings#std:setting-ADMINS&quot;&gt;&lt;code&gt;ADMINS&lt;/code&gt;&lt;/a&gt; will get a description of the error, a complete Python traceback, and details about the HTTP request that caused the error.</source>
          <target state="translated">때 &lt;a href=&quot;../ref/settings#std:setting-DEBUG&quot;&gt; &lt;code&gt;DEBUG&lt;/code&gt; 가&lt;/a&gt; 있다 &lt;code&gt;False&lt;/code&gt; , 장고에 나열된 사용자의 이메일을 보내드립니다 &lt;a href=&quot;../ref/settings#std:setting-ADMINS&quot;&gt; &lt;code&gt;ADMINS&lt;/code&gt; &lt;/a&gt; 코드가 처리되지 않은 예외가 발생하고 내부 서버 오류가 발생 할 때마다 설정을 (엄격하게 500 이상의 HTTP 상태 코드에 어떤 응답을, 말하기). 이를 통해 관리자는 오류를 즉시 알 수 있습니다. &lt;a href=&quot;../ref/settings#std:setting-ADMINS&quot;&gt; &lt;code&gt;ADMINS&lt;/code&gt; &lt;/a&gt; 오류를 발생시킨 HTTP 요청에 대한 오류에 대한 설명, 완전한 파이썬 역 추적 및 세부 사항을 얻을 것이다.</target>
        </trans-unit>
        <trans-unit id="7ebfe91d6b34d1e102da8dbfcae13c88a558dcb6" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;../ref/settings#std:setting-DEBUG&quot;&gt;&lt;code&gt;DEBUG&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;False&lt;/code&gt;:</source>
          <target state="translated">때 &lt;a href=&quot;../ref/settings#std:setting-DEBUG&quot;&gt; &lt;code&gt;DEBUG&lt;/code&gt; 가&lt;/a&gt; 있습니다 &lt;code&gt;False&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="078008cba232f61c75acc7e754cbf66dc98202e5" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;../ref/settings#std:setting-DEBUG&quot;&gt;&lt;code&gt;DEBUG&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;True&lt;/code&gt;:</source>
          <target state="translated">때 &lt;a href=&quot;../ref/settings#std:setting-DEBUG&quot;&gt; &lt;code&gt;DEBUG&lt;/code&gt; 가&lt;/a&gt; 있다 &lt;code&gt;True&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5015937ba5a6d6910d698b65098ff7bc8004ab0c" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;../ref/settings#std:setting-TEMPLATES-APP_DIRS&quot;&gt;&lt;code&gt;APP_DIRS&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;DjangoTemplates&lt;/code&gt; engines look for templates in the &lt;code&gt;templates&lt;/code&gt; subdirectory of installed applications. This generic name was kept for backwards-compatibility.</source>
          <target state="translated">때 &lt;a href=&quot;../ref/settings#std:setting-TEMPLATES-APP_DIRS&quot;&gt; &lt;code&gt;APP_DIRS&lt;/code&gt; 가&lt;/a&gt; 있다 &lt;code&gt;True&lt;/code&gt; , &lt;code&gt;DjangoTemplates&lt;/code&gt; 의 엔진은 템플릿을 찾아 &lt;code&gt;templates&lt;/code&gt; 설치된 응용 프로그램의 하위 디렉토리. 이 일반 이름은 이전 버전과의 호환성을 위해 유지되었습니다.</target>
        </trans-unit>
        <trans-unit id="d2b8728dfc9f01a4852d25c45bc8d5cd20588b22" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;../ref/settings#std:setting-TEMPLATES-APP_DIRS&quot;&gt;&lt;code&gt;APP_DIRS&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;Jinja2&lt;/code&gt; engines look for templates in the &lt;code&gt;jinja2&lt;/code&gt; subdirectory of installed applications.</source>
          <target state="translated">때 &lt;a href=&quot;../ref/settings#std:setting-TEMPLATES-APP_DIRS&quot;&gt; &lt;code&gt;APP_DIRS&lt;/code&gt; 가&lt;/a&gt; 있다 &lt;code&gt;True&lt;/code&gt; , &lt;code&gt;Jinja2&lt;/code&gt; 의 엔진은 템플릿을 찾아 &lt;code&gt;jinja2&lt;/code&gt; 에 설치된 응용 프로그램의 하위 디렉토리.</target>
        </trans-unit>
        <trans-unit id="a47be6a21b160ae4c773dc9a96f59c08e428aa57" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;../settings#std:setting-USE_TZ&quot;&gt;&lt;code&gt;USE_TZ&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;True&lt;/code&gt; then datetimes are stored in the database in UTC. If a different timezone is active in Django, the datetime is converted to that timezone before the value is extracted. The example below converts to the Melbourne timezone (UTC +10:00), which changes the day, weekday, and hour values that are returned:</source>
          <target state="translated">때 &lt;a href=&quot;../settings#std:setting-USE_TZ&quot;&gt; &lt;code&gt;USE_TZ&lt;/code&gt; 가&lt;/a&gt; 있다 &lt;code&gt;True&lt;/code&gt; 다음 날짜 시간은 UTC의 데이터베이스에 저장됩니다. Django에서 다른 시간대가 활성화되어 있으면 값을 추출하기 전에 날짜 시간이 해당 시간대로 변환됩니다. 아래 예제는 멜버른 시간대 (UTC +10 : 00)로 변환되어 반환되는 요일, 주중 및 시간 값을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="063e498ca71858482d88e52c880934c8b218cedb" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;../settings#std:setting-USE_TZ&quot;&gt;&lt;code&gt;USE_TZ&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;True&lt;/code&gt;, datetime fields are converted to the current time zone before filtering. This requires &lt;a href=&quot;#database-time-zone-definitions&quot;&gt;time zone definitions in the database&lt;/a&gt;.</source>
          <target state="translated">때 &lt;a href=&quot;../settings#std:setting-USE_TZ&quot;&gt; &lt;code&gt;USE_TZ&lt;/code&gt; 가&lt;/a&gt; 있다 &lt;code&gt;True&lt;/code&gt; , 날짜 필드를 필터링하기 전에 현재 시간대로 변환됩니다. 이것은 &lt;a href=&quot;#database-time-zone-definitions&quot;&gt;데이터베이스에 시간대 정의가&lt;/a&gt; 필요 합니다 .</target>
        </trans-unit>
        <trans-unit id="b0306814aafd870e05a002219eaae32fd6c85471" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;../settings#std:setting-USE_TZ&quot;&gt;&lt;code&gt;USE_TZ&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;True&lt;/code&gt;, fields are converted to the current time zone before filtering. This requires &lt;a href=&quot;#database-time-zone-definitions&quot;&gt;time zone definitions in the database&lt;/a&gt;.</source>
          <target state="translated">때 &lt;a href=&quot;../settings#std:setting-USE_TZ&quot;&gt; &lt;code&gt;USE_TZ&lt;/code&gt; 가&lt;/a&gt; 있다 &lt;code&gt;True&lt;/code&gt; , 필드 필터링하기 전에 현재 시간대로 변환됩니다. 이것은 &lt;a href=&quot;#database-time-zone-definitions&quot;&gt;데이터베이스에 시간대 정의가&lt;/a&gt; 필요 합니다 .</target>
        </trans-unit>
        <trans-unit id="01bb73f4cb5b8dbd0178f8c58e67dd4ae072bb6c" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;index#module-django.contrib.gis&quot;&gt;&lt;code&gt;django.contrib.gis&lt;/code&gt;&lt;/a&gt; is in your &lt;a href=&quot;../../settings#std:setting-INSTALLED_APPS&quot;&gt;&lt;code&gt;INSTALLED_APPS&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;../../django-admin#django-admin-inspectdb&quot;&gt;&lt;code&gt;inspectdb&lt;/code&gt;&lt;/a&gt; management command is overridden with one from GeoDjango. The overridden command is spatially-aware, and places geometry fields in the auto-generated model definition, where appropriate.</source>
          <target state="translated">때 &lt;a href=&quot;index#module-django.contrib.gis&quot;&gt; &lt;code&gt;django.contrib.gis&lt;/code&gt; 이&lt;/a&gt; 당신에 &lt;a href=&quot;../../settings#std:setting-INSTALLED_APPS&quot;&gt; &lt;code&gt;INSTALLED_APPS&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../../django-admin#django-admin-inspectdb&quot;&gt; &lt;code&gt;inspectdb&lt;/code&gt; 의&lt;/a&gt; 관리 명령은 GeoDjango에서 하나 무시됩니다. 재 지정된 명령은 공간을 인식하며 필요한 경우 자동 생성 된 모델 정의에 형상 필드를 배치합니다.</target>
        </trans-unit>
        <trans-unit id="29b195d9be07b40b09610c72be5c863541e21bb5" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;settings#std:setting-INSTALLED_APPS&quot;&gt;&lt;code&gt;INSTALLED_APPS&lt;/code&gt;&lt;/a&gt; contains the dotted path to an application module, Django checks for a &lt;code&gt;default_app_config&lt;/code&gt; variable in that module.</source>
          <target state="translated">&lt;a href=&quot;settings#std:setting-INSTALLED_APPS&quot;&gt; &lt;code&gt;INSTALLED_APPS&lt;/code&gt; &lt;/a&gt; 에 애플리케이션 모듈에 대한 점선 경로가 포함되어 있으면 Django는 해당 모듈에서 &lt;code&gt;default_app_config&lt;/code&gt; 변수를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="398778ea614be173441f7f04a2b19bc1d3236d24" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;QuerySet&lt;/code&gt;s are evaluated</source>
          <target state="translated">&lt;code&gt;QuerySet&lt;/code&gt; 가 평가 될 때</target>
        </trans-unit>
        <trans-unit id="fe546d84fcea8aa4dd9e239d639913333df82f4d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;QuerySet&lt;/code&gt;s are not cached</source>
          <target state="translated">때 &lt;code&gt;QuerySet&lt;/code&gt; 의는 캐시되지 않습니다</target>
        </trans-unit>
        <trans-unit id="76b3da3eec2f82e519b883850ccb3bff46a1b0bb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;SessionMiddleware&lt;/code&gt; is activated, each &lt;a href=&quot;../../ref/request-response#django.http.HttpRequest&quot;&gt;&lt;code&gt;HttpRequest&lt;/code&gt;&lt;/a&gt; object &amp;ndash; the first argument to any Django view function &amp;ndash; will have a &lt;code&gt;session&lt;/code&gt; attribute, which is a dictionary-like object.</source>
          <target state="translated">경우 &lt;code&gt;SessionMiddleware&lt;/code&gt; 가 활성화되어, 각각 &lt;a href=&quot;../../ref/request-response#django.http.HttpRequest&quot;&gt; &lt;code&gt;HttpRequest&lt;/code&gt; &lt;/a&gt; 객체 - 모든 장고보기 기능 첫번째 인자 - 한 것이다 &lt;code&gt;session&lt;/code&gt; 사전 같은 목적 특성.</target>
        </trans-unit>
        <trans-unit id="2281102406a3606cdc5d223c0da9b592c79085db" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;True&lt;/code&gt; and used in a model which inherits from another &lt;a href=&quot;https://docs.djangoproject.com/en/3.0/glossary/#term-concrete-model&quot;&gt;concrete model&lt;/a&gt;, indicates that this field should be used as the link back to the parent class, rather than the extra &lt;code&gt;OneToOneField&lt;/code&gt; which would normally be implicitly created by subclassing.</source>
          <target state="translated">때 &lt;code&gt;True&lt;/code&gt; 어느 다른로부터 상속 모델에 사용되는 &lt;a href=&quot;https://docs.djangoproject.com/en/3.0/glossary/#term-concrete-model&quot;&gt;콘크리트 모델&lt;/a&gt; 이 필드 오히려 여분의보다 상위 클래스에 링크 다시로 사용하는 것을 나타낸다 &lt;code&gt;OneToOneField&lt;/code&gt; 일반적으로 암시 적으로 서브 클래스에 의해 생성된다.</target>
        </trans-unit>
        <trans-unit id="6b66bc42495d61095eae0d619a166b87b76d25b5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;as_attachment=True&lt;/code&gt; is passed to &lt;code&gt;FileResponse&lt;/code&gt;, it sets the appropriate &lt;code&gt;Content-Disposition&lt;/code&gt; header and that tells Web browsers to pop-up a dialog box prompting/confirming how to handle the document even if a default is set on the machine. If the &lt;code&gt;as_attachment&lt;/code&gt; parameter is omitted, browsers will handle the PDF using whatever program/plugin they&amp;rsquo;ve been configured to use for PDFs.</source>
          <target state="translated">때 &lt;code&gt;as_attachment=True&lt;/code&gt; 전달됩니다 &lt;code&gt;FileResponse&lt;/code&gt; , 그것은 적절한 설정 &lt;code&gt;Content-Disposition&lt;/code&gt; 헤더를하고 팝업 수있는 대화 상자를 디폴트가 컴퓨터에 설정되어있는 경우에도 문서를 처리하는 방법을 확인 /하라는 메시지가 웹 브라우저를 알려줍니다. 는 IF &lt;code&gt;as_attachment&lt;/code&gt; 의 매개 변수가 생략, 브라우저는이 PDF 파일에 사용하도록 구성했습니다 플러그인 / 어떤 프로그램을 사용하여 PDF를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="1a7c826c3d8d7a29a6926a93fc412782b2ca3288" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;condition()&lt;/code&gt; returns a conditional response, any decorators below it will be skipped and won&amp;rsquo;t apply to the response. Therefore, any decorators that need to apply to both the regular view response and a conditional response must be above &lt;code&gt;condition()&lt;/code&gt;. In particular, &lt;a href=&quot;http/decorators#django.views.decorators.vary.vary_on_cookie&quot;&gt;&lt;code&gt;vary_on_cookie()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http/decorators#django.views.decorators.vary.vary_on_headers&quot;&gt;&lt;code&gt;vary_on_headers()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;http/decorators#django.views.decorators.cache.cache_control&quot;&gt;&lt;code&gt;cache_control()&lt;/code&gt;&lt;/a&gt; should come first because &lt;a href=&quot;https://tools.ietf.org/html/rfc7232.html#section-4.1&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 7232&lt;/strong&gt;&lt;/a&gt; requires that the headers they set be present on 304 responses.</source>
          <target state="translated">때 &lt;code&gt;condition()&lt;/code&gt; 조건부 응답을 반환, 그 아래에 어떤 장식은 건너 뛰고 응답에 적용되지 않습니다. 따라서 일반 뷰 응답과 조건부 응답에 모두 적용해야하는 데코레이터는 &lt;code&gt;condition()&lt;/code&gt; 이상이어야합니다 . 특히, &lt;a href=&quot;https://tools.ietf.org/html/rfc7232.html#section-4.1&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 7232에서&lt;/strong&gt;&lt;/a&gt; 설정 한 헤더가 304 응답에 있어야 하므로 &lt;a href=&quot;http/decorators#django.views.decorators.vary.vary_on_cookie&quot;&gt; &lt;code&gt;vary_on_cookie()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;http/decorators#django.views.decorators.vary.vary_on_headers&quot;&gt; &lt;code&gt;vary_on_headers()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;http/decorators#django.views.decorators.cache.cache_control&quot;&gt; &lt;code&gt;cache_control()&lt;/code&gt; &lt;/a&gt; 이 먼저 나와야 합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="97a65d5923678bf0a3bda94eb07758399a62601f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;data&lt;/code&gt; is provided, it is used as the request body, and a &lt;code&gt;Content-Type&lt;/code&gt; header is set to &lt;code&gt;content_type&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 가 제공 되면 요청 본문으로 사용되며 &lt;code&gt;Content-Type&lt;/code&gt; 헤더는 &lt;code&gt;content_type&lt;/code&gt; 으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="f36fbe34ea908e2948f6b82890c92abd7e906163" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;django.contrib.auth&lt;/code&gt; is listed in your &lt;a href=&quot;../../ref/settings#std:setting-INSTALLED_APPS&quot;&gt;&lt;code&gt;INSTALLED_APPS&lt;/code&gt;&lt;/a&gt; setting, it will ensure that four default permissions &amp;ndash; add, change, delete, and view &amp;ndash; are created for each Django model defined in one of your installed applications.</source>
          <target state="translated">&lt;code&gt;django.contrib.auth&lt;/code&gt; 가 &lt;a href=&quot;../../ref/settings#std:setting-INSTALLED_APPS&quot;&gt; &lt;code&gt;INSTALLED_APPS&lt;/code&gt; &lt;/a&gt; 설정에 나열 되면 설치된 응용 프로그램 중 하나에 정의 된 각 장고 모델에 대해 4 개의 기본 권한 (추가, 변경, 삭제 및보기)이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="1d00448e3ca50e633908e17ad4a635b466c6dbcf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;model_name&lt;/code&gt; is set, &lt;code&gt;hints&lt;/code&gt; normally contains the model class under the key &lt;code&gt;'model'&lt;/code&gt;. Note that it may be a &lt;a href=&quot;../migrations#historical-models&quot;&gt;historical model&lt;/a&gt;, and thus not have any custom attributes, methods, or managers. You should only rely on &lt;code&gt;_meta&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;model_name&lt;/code&gt; 설정되어, &lt;code&gt;hints&lt;/code&gt; 보통 키에 모델 클래스 포함 &lt;code&gt;'model'&lt;/code&gt; . &lt;a href=&quot;../migrations#historical-models&quot;&gt;히스토리 모델&lt;/a&gt; 일 수 있으므로 사용자 정의 속성, 메소드 또는 관리자가 없습니다. &lt;code&gt;_meta&lt;/code&gt; 에만 의존해야합니다 .</target>
        </trans-unit>
        <trans-unit id="97a33c629f4e24b73117e132e13d2978b18833f5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;order_with_respect_to&lt;/code&gt; is set, two additional methods are provided to retrieve and to set the order of the related objects: &lt;code&gt;get_RELATED_order()&lt;/code&gt; and &lt;code&gt;set_RELATED_order()&lt;/code&gt;, where &lt;code&gt;RELATED&lt;/code&gt; is the lowercased model name. For example, assuming that a &lt;code&gt;Question&lt;/code&gt; object has multiple related &lt;code&gt;Answer&lt;/code&gt; objects, the list returned contains the primary keys of the related &lt;code&gt;Answer&lt;/code&gt; objects:</source>
          <target state="translated">&lt;code&gt;order_with_respect_to&lt;/code&gt; 가 설정 되면 get_RELATED_order &lt;code&gt;get_RELATED_order()&lt;/code&gt; 및 &lt;code&gt;set_RELATED_order()&lt;/code&gt; 와 같이 관련 오브젝트의 순서를 검색하고 설정하기위한 두 가지 추가 메소드가 제공됩니다. 여기서 &lt;code&gt;RELATED&lt;/code&gt; 는 소문자 모델 이름입니다. 예를 들어, &lt;code&gt;Question&lt;/code&gt; 객체에 여러 개의 관련 &lt;code&gt;Answer&lt;/code&gt; 객체가 있다고 가정하면 반환 된 목록에는 관련 &lt;code&gt;Answer&lt;/code&gt; 객체 의 기본 키가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="1464244508e91f4433a85b30ad476d39b193ed44" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;require_ready&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, &lt;code&gt;get_model()&lt;/code&gt; returns a model class that may not be fully functional (reverse accessors may be missing, for example) until the app registry is fully populated. For this reason, it&amp;rsquo;s best to leave &lt;code&gt;require_ready&lt;/code&gt; to the default value of &lt;code&gt;True&lt;/code&gt; whenever possible.</source>
          <target state="translated">때 &lt;code&gt;require_ready&lt;/code&gt; 이 있다 &lt;code&gt;False&lt;/code&gt; , &lt;code&gt;get_model()&lt;/code&gt; 응용 프로그램 레지스트리가 완전히 채워 때까지 (역 접근, 예를 들어, 누락 될 수 있습니다) 완벽하게 작동하지 않을 수 있습니다 모델 클래스를 반환합니다. 따라서 &lt;code&gt;require_ready&lt;/code&gt; 를 기본값 인 &lt;code&gt;True&lt;/code&gt; 로 유지하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="7d1ae82005ecae97e3baad3ecd2d706ad2a25a9e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;start_migration_name&lt;/code&gt; is given, Django will only include migrations starting from and including this migration. This helps to mitigate the squashing limitation of &lt;a href=&quot;migration-operations#django.db.migrations.operations.RunPython&quot;&gt;&lt;code&gt;RunPython&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;migration-operations#django.db.migrations.operations.RunSQL&quot;&gt;&lt;code&gt;django.db.migrations.operations.RunSQL&lt;/code&gt;&lt;/a&gt; migration operations.</source>
          <target state="translated">때 &lt;code&gt;start_migration_name&lt;/code&gt; 이 주어집니다, 장고는 마이그레이션이 마이그레이션을 포함에서 시작이 포함됩니다. 이는 &lt;a href=&quot;migration-operations#django.db.migrations.operations.RunPython&quot;&gt; &lt;code&gt;RunPython&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;migration-operations#django.db.migrations.operations.RunSQL&quot;&gt; &lt;code&gt;django.db.migrations.operations.RunSQL&lt;/code&gt; &lt;/a&gt; 마이그레이션 조작 의 스쿼시 한계를 완화하는 데 도움이됩니다 .</target>
        </trans-unit>
        <trans-unit id="bcb15caf9c8e2ad031c5694cb1b57113b550a57b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use_natural_foreign_keys=True&lt;/code&gt; is specified, Django will use the &lt;code&gt;natural_key()&lt;/code&gt; method to serialize any foreign key reference to objects of the type that defines the method.</source>
          <target state="translated">경우 &lt;code&gt;use_natural_foreign_keys=True&lt;/code&gt; 지정되어, 장고는 사용 &lt;code&gt;natural_key()&lt;/code&gt; 유형을 정의하는 방법의 모든 오브젝트에 외래 키 참조를 직렬화하는 방법.</target>
        </trans-unit>
        <trans-unit id="69c2f1096bca18408685b53cb08ccad793a09b12" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use_natural_primary_keys=True&lt;/code&gt; is specified, Django will not provide the primary key in the serialized data of this object since it can be calculated during deserialization:</source>
          <target state="translated">때 &lt;code&gt;use_natural_primary_keys=True&lt;/code&gt; 지정이 직렬화 복원시에 계산 될 수 있기 때문에, 장고는이 객체의 직렬화 된 데이터의 기본 키를 제공하지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="1bd77747a087f95cbda44f8709ec4e90e31e5665" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;value&lt;/code&gt; is omitted, it defaults to &lt;a href=&quot;#django.utils.timezone.now&quot;&gt;&lt;code&gt;now()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;value&lt;/code&gt; 을, 디폴트를 생략 &lt;a href=&quot;#django.utils.timezone.now&quot;&gt; &lt;code&gt;now()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3131f5060bfafb3929fde29ac384381155e1a13f" translate="yes" xml:space="preserve">
          <source>When Daphne is installed, a &lt;code&gt;daphne&lt;/code&gt; command is available which starts the Daphne server process. At its simplest, Daphne needs to be called with the location of a module containing an ASGI application object, followed by what the application is called (separated by a colon).</source>
          <target state="translated">Daphne이 설치되면 Daphne 서버 프로세스를 시작 하는 &lt;code&gt;daphne&lt;/code&gt; 명령을 사용할 수 있습니다. 가장 간단한 방법으로, Daphne은 ASGI 응용 프로그램 객체를 포함하는 모듈의 위치와 콜론으로 구분 된 응용 프로그램을 호출하여 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="fd0be0e29eeab55bae3e3c9a146a3c1d575a91da" translate="yes" xml:space="preserve">
          <source>When Django can&amp;rsquo;t find a match for the requested URL, or when an exception is raised, Django invokes an error-handling view.</source>
          <target state="translated">Django가 요청한 URL과 일치하는 항목을 찾을 수 없거나 예외가 발생하면 Django는 오류 처리보기를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="0796b7c6790a393507472022529cf27b1eb27bbb" translate="yes" xml:space="preserve">
          <source>When Django compiles a template, it splits the raw template text into &amp;lsquo;&amp;rsquo;nodes&amp;rsquo;&amp;lsquo;. Each node is an instance of &lt;code&gt;django.template.Node&lt;/code&gt; and has a &lt;code&gt;render()&lt;/code&gt; method. A compiled template is a list of &lt;code&gt;Node&lt;/code&gt; objects. When you call &lt;code&gt;render()&lt;/code&gt; on a compiled template object, the template calls &lt;code&gt;render()&lt;/code&gt; on each &lt;code&gt;Node&lt;/code&gt; in its node list, with the given context. The results are all concatenated together to form the output of the template.</source>
          <target state="translated">Django는 템플릿을 컴파일 할 때 원시 템플릿 텍스트를``노드 ''로 분할합니다. 각 노드는 &lt;code&gt;django.template.Node&lt;/code&gt; 의 인스턴스이며 &lt;code&gt;render()&lt;/code&gt; 메소드를 갖습니다 . 컴파일 된 템플릿은 &lt;code&gt;Node&lt;/code&gt; 객체 의 목록입니다 . 당신이 호출 할 때 &lt;code&gt;render()&lt;/code&gt; 컴파일 된 템플릿 객체, 템플릿 호출은 &lt;code&gt;render()&lt;/code&gt; 각 &lt;code&gt;Node&lt;/code&gt; 주어진 컨텍스트와의 노드 목록에서. 결과는 모두 함께 연결되어 템플릿의 출력을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="ccfecb06224691e925d260d19074cceb0f3f9271" translate="yes" xml:space="preserve">
          <source>When Django deletes an object, by default it emulates the behavior of the SQL constraint &lt;code&gt;ON DELETE CASCADE&lt;/code&gt; &amp;ndash; in other words, any objects which had foreign keys pointing at the object to be deleted will be deleted along with it. For example:</source>
          <target state="translated">Django는 객체를 삭제하면 기본적으로 SQL 제약 조건 &lt;code&gt;ON DELETE CASCADE&lt;/code&gt; 의 동작을 에뮬레이트합니다. 즉, 삭제할 객체를 가리키는 외래 키가있는 객체는 함께 삭제됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="94ba4ccedde0d0ccf54a7ea60509089958795bac" translate="yes" xml:space="preserve">
          <source>When Django encounters an instance of &lt;code&gt;F()&lt;/code&gt;, it overrides the standard Python operators to create an encapsulated SQL expression; in this case, one which instructs the database to increment the database field represented by &lt;code&gt;reporter.stories_filed&lt;/code&gt;.</source>
          <target state="translated">Django가 &lt;code&gt;F()&lt;/code&gt; 인스턴스를 만나면 표준 Python 연산자를 재정 의하여 캡슐화 된 SQL 식을 만듭니다. 이 경우 &lt;code&gt;reporter.stories_filed&lt;/code&gt; 로 표시되는 데이터베이스 필드를 증가 시키도록 데이터베이스에 지시하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="c0dbb7b8673bc175a119522d511a7d7727c1c25d" translate="yes" xml:space="preserve">
          <source>When Django establishes a connection to the database, it sets up appropriate parameters, depending on the backend being used. If you enable persistent connections, this setup is no longer repeated every request. If you modify parameters such as the connection&amp;rsquo;s isolation level or time zone, you should either restore Django&amp;rsquo;s defaults at the end of each request, force an appropriate value at the beginning of each request, or disable persistent connections.</source>
          <target state="translated">Django가 데이터베이스에 연결하면 사용되는 백엔드에 따라 적절한 매개 변수가 설정됩니다. 영구 연결을 사용하면이 설정이 더 이상 모든 요청에 ​​반복되지 않습니다. 연결 격리 수준 또는 시간대와 같은 매개 변수를 수정하는 경우 각 요청이 끝날 때 Django의 기본값을 복원하거나 각 요청이 시작될 때 적절한 값을 설정하거나 영구 연결을 비활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="65ecc9404e204680c3af970a5abba12007e950eb" translate="yes" xml:space="preserve">
          <source>When Django finds a matching pattern, it calls the specified view function with an &lt;a href=&quot;../ref/request-response#django.http.HttpRequest&quot;&gt;&lt;code&gt;HttpRequest&lt;/code&gt;&lt;/a&gt; object as the first argument and any &amp;ldquo;captured&amp;rdquo; values from the route as keyword arguments. We&amp;rsquo;ll give an example of this in a bit.</source>
          <target state="translated">Django는 일치하는 패턴을 찾으면 &lt;a href=&quot;../ref/request-response#django.http.HttpRequest&quot;&gt; &lt;code&gt;HttpRequest&lt;/code&gt; &lt;/a&gt; 객체를 첫 번째 인수로 사용하고 경로에서 &quot;캡처 된&quot;값을 키워드 인수로 사용 하여 지정된 뷰 함수를 호출합니다 . 우리는 이것에 대한 예를 조금 보여줄 것입니다.</target>
        </trans-unit>
        <trans-unit id="3d951f7a17a65a289b94f27b19bbdfea34341a24" translate="yes" xml:space="preserve">
          <source>When Django finds a template that exists, it stops looking.</source>
          <target state="translated">Django가 존재하는 템플릿을 찾으면 찾기를 중지합니다.</target>
        </trans-unit>
        <trans-unit id="bf9acef06aca584a21d6599b770a9002850563aa" translate="yes" xml:space="preserve">
          <source>When Django generates the schema, it doesn&amp;rsquo;t specify a storage engine, so tables will be created with whatever default storage engine your database server is configured for. The easiest solution is to set your database server&amp;rsquo;s default storage engine to the desired engine.</source>
          <target state="translated">Django는 스키마를 생성 할 때 스토리지 엔진을 지정하지 않으므로 데이터베이스 서버가 구성된 기본 스토리지 엔진으로 테이블이 작성됩니다. 가장 쉬운 해결책은 데이터베이스 서버의 기본 스토리지 엔진을 원하는 엔진으로 설정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="14b089a116a4deb126a1e28310400694e7f85581" translate="yes" xml:space="preserve">
          <source>When Django handles a file upload, the file data ends up placed in &lt;a href=&quot;../../ref/request-response#django.http.HttpRequest.FILES&quot;&gt;&lt;code&gt;request.FILES&lt;/code&gt;&lt;/a&gt; (for more on the &lt;code&gt;request&lt;/code&gt; object see the documentation for &lt;a href=&quot;../../ref/request-response&quot;&gt;request and response objects&lt;/a&gt;). This document explains how files are stored on disk and in memory, and how to customize the default behavior.</source>
          <target state="translated">Django가 파일 업로드를 처리하면 파일 데이터가 &lt;a href=&quot;../../ref/request-response#django.http.HttpRequest.FILES&quot;&gt; &lt;code&gt;request.FILES&lt;/code&gt; 에&lt;/a&gt; 배치됩니다 ( &lt;code&gt;request&lt;/code&gt; 오브젝트 에 대한 자세한 내용은 &lt;a href=&quot;../../ref/request-response&quot;&gt;요청 및 응답 오브젝트에&lt;/a&gt; 대한 문서 참조 ). 이 문서는 파일이 디스크와 메모리에 저장되는 방법과 기본 동작을 사용자 정의하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="21639defdf0032fad512f6c56eadaa1382fe98ce" translate="yes" xml:space="preserve">
          <source>When Django processes this model, it identifies that it has a &lt;a href=&quot;#django.db.models.ManyToManyField&quot;&gt;&lt;code&gt;ManyToManyField&lt;/code&gt;&lt;/a&gt; on itself, and as a result, it doesn&amp;rsquo;t add a &lt;code&gt;person_set&lt;/code&gt; attribute to the &lt;code&gt;Person&lt;/code&gt; class. Instead, the &lt;a href=&quot;#django.db.models.ManyToManyField&quot;&gt;&lt;code&gt;ManyToManyField&lt;/code&gt;&lt;/a&gt; is assumed to be symmetrical &amp;ndash; that is, if I am your friend, then you are my friend.</source>
          <target state="translated">Django는이 모델을 처리 할 때 모델 자체에 &lt;a href=&quot;#django.db.models.ManyToManyField&quot;&gt; &lt;code&gt;ManyToManyField&lt;/code&gt; &lt;/a&gt; 가 있음을 식별 하여 &lt;code&gt;Person&lt;/code&gt; 클래스에 &lt;code&gt;person_set&lt;/code&gt; 속성을 추가하지 않습니다 . 대신 &lt;a href=&quot;#django.db.models.ManyToManyField&quot;&gt; &lt;code&gt;ManyToManyField&lt;/code&gt; &lt;/a&gt; 는 대칭 인 것으로 가정합니다. 즉, 내가 친구 인 경우 귀하는 내 친구입니다.</target>
        </trans-unit>
        <trans-unit id="97be14b3390eb9e1c77abcd7fd95afa9cbb4690b" translate="yes" xml:space="preserve">
          <source>When Django renders a widget as HTML, it only renders very minimal markup - Django doesn&amp;rsquo;t add class names, or any other widget-specific attributes. This means, for example, that all &lt;a href=&quot;#django.forms.TextInput&quot;&gt;&lt;code&gt;TextInput&lt;/code&gt;&lt;/a&gt; widgets will appear the same on your Web pages.</source>
          <target state="translated">Django는 위젯을 HTML로 렌더링 할 때 최소한의 마크 업 만 렌더링합니다. Django는 클래스 이름이나 다른 위젯 특정 속성을 추가하지 않습니다. 예를 들어 모든 &lt;a href=&quot;#django.forms.TextInput&quot;&gt; &lt;code&gt;TextInput&lt;/code&gt; &lt;/a&gt; 위젯은 웹 페이지에서 동일하게 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0edee919db33c1a71cfc2cbe18ab4a9c760b5a41" translate="yes" xml:space="preserve">
          <source>When Django searches for a certain format, it will go through all given Python paths until it finds a module that actually defines the given format. This means that formats defined in packages farther up in the list will take precedence over the same formats in packages farther down.</source>
          <target state="translated">Django가 특정 형식을 검색하면 주어진 형식을 실제로 정의하는 모듈을 찾을 때까지 주어진 모든 Python 경로를 통과합니다. 이는 목록에서 더 멀리있는 패키지에 정의 된 형식이 더 멀리있는 패키지의 동일한 형식보다 우선 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="75677919e0e7b52a38682f0e8354264b3272df7a" translate="yes" xml:space="preserve">
          <source>When Django starts, &lt;a href=&quot;#django.setup&quot;&gt;&lt;code&gt;django.setup()&lt;/code&gt;&lt;/a&gt; is responsible for populating the application registry.</source>
          <target state="translated">Django가 시작되면 &lt;a href=&quot;#django.setup&quot;&gt; &lt;code&gt;django.setup()&lt;/code&gt; &lt;/a&gt; 이 응용 프로그램 레지스트리를 채 웁니다 .</target>
        </trans-unit>
        <trans-unit id="c5f7f659f0efcdc3a7060fac73444677c3cf5fab" translate="yes" xml:space="preserve">
          <source>When GeoDjango can&amp;rsquo;t find GEOS, this error is raised:</source>
          <target state="translated">GeoDjango가 GEOS를 찾을 수 없으면이 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3345102299d2049cd3b1889a7ab80760fe7ab357" translate="yes" xml:space="preserve">
          <source>When GeoDjango can&amp;rsquo;t find the GDAL library, configure your &lt;a href=&quot;index#libsettings&quot;&gt;Library environment settings&lt;/a&gt;&lt;em&gt;or&lt;/em&gt; set &lt;a href=&quot;#gdallibrarypath&quot;&gt;GDAL_LIBRARY_PATH&lt;/a&gt; in your settings.</source>
          <target state="translated">GeoDjango가 GDAL 라이브러리를 찾을 수없는 경우 &lt;a href=&quot;index#libsettings&quot;&gt;라이브러리 환경 설정을&lt;/a&gt; 구성 &lt;em&gt;하거나&lt;/em&gt; 설정에서 &lt;a href=&quot;#gdallibrarypath&quot;&gt;GDAL_LIBRARY_PATH&lt;/a&gt; 를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="1e4c1fd5d2a871766c78499bf711d26c9f348099" translate="yes" xml:space="preserve">
          <source>When GeoDjango&amp;rsquo;s spatial backend initializes on PostGIS, it has to perform an SQL query to determine the version in order to figure out what features are available. Advanced users wishing to prevent this additional query may set the version manually using a 3-tuple of integers specifying the major, minor, and micro version numbers for PostGIS. For example, to configure for PostGIS X.Y.Z you would use:</source>
          <target state="translated">GeoDjango의 공간 백엔드가 PostGIS에서 초기화되면 사용 가능한 기능을 파악하기 위해 버전을 확인하기 위해 SQL 쿼리를 수행해야합니다. 이 추가 쿼리를 방지하려는 고급 사용자는 PostGIS의 주 버전, 부 버전 및 마이크로 버전 번호를 지정하는 3 배의 정수를 사용하여 버전을 수동으로 설정할 수 있습니다. 예를 들어 PostGIS XYZ를 구성하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7e951e0c1686513e03322583b58957f6977278cc" translate="yes" xml:space="preserve">
          <source>When Gunicorn is installed, a &lt;code&gt;gunicorn&lt;/code&gt; command is available which starts the Gunicorn server process. The simplest invocation of gunicorn is to pass the location of a module containing a WSGI application object named &lt;code&gt;application&lt;/code&gt;, which for a typical Django project would look like:</source>
          <target state="translated">Gunicorn이 설치되면 Gunicorn 서버 프로세스를 시작 하는 &lt;code&gt;gunicorn&lt;/code&gt; 명령을 사용할 수 있습니다. gunicorn의 간단한 호출라는 이름의 WSGI 응용 프로그램 개체가 포함 된 모듈의 위치를 전달하는 &lt;code&gt;application&lt;/code&gt; 전형적인 장고 프로젝트처럼 보일 것이다 :</target>
        </trans-unit>
        <trans-unit id="25c4eeb22683ac77d01607a524a5cc6e6abc4c76" translate="yes" xml:space="preserve">
          <source>When Uvicorn is installed, a &lt;code&gt;uvicorn&lt;/code&gt; command is available which runs ASGI applications. Uvicorn needs to be called with the location of a module containing a ASGI application object, followed by what the application is called (separated by a colon).</source>
          <target state="translated">Uvicorn이 설치되면 ASGI 응용 프로그램을 실행 하는 &lt;code&gt;uvicorn&lt;/code&gt; 명령을 사용할 수 있습니다. Uvicorn은 ASGI 응용 프로그램 객체를 포함하는 모듈의 위치와 콜론으로 구분 된 응용 프로그램의 이름으로 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="b2fe4270d9bd2c70f48127f0ebf3ed244ea8bbae" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;exceptions#django.core.exceptions.SuspiciousOperation&quot;&gt;&lt;code&gt;SuspiciousOperation&lt;/code&gt;&lt;/a&gt; is raised in Django, it may be handled by a component of Django (for example resetting the session data). If not specifically handled, Django will consider the current request a &amp;lsquo;bad request&amp;rsquo; instead of a server error.</source>
          <target state="translated">Django에서 &lt;a href=&quot;exceptions#django.core.exceptions.SuspiciousOperation&quot;&gt; &lt;code&gt;SuspiciousOperation&lt;/code&gt; &lt;/a&gt; 이 발생 하면 Django의 구성 요소 (예 : 세션 데이터 재설정)에 의해 처리 될 수 있습니다. 특별히 처리하지 않으면 Django는 현재 요청을 서버 오류 대신 '잘못된 요청'으로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="44cadbde59e9ad88559b5b09a4aba4bca5882390" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;QuerySet&lt;/code&gt; is &lt;a href=&quot;#when-querysets-are-evaluated&quot;&gt;evaluated&lt;/a&gt;, it typically caches its results. If the data in the database might have changed since a &lt;code&gt;QuerySet&lt;/code&gt; was evaluated, you can get updated results for the same query by calling &lt;code&gt;all()&lt;/code&gt; on a previously evaluated &lt;code&gt;QuerySet&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;QuerySet&lt;/code&gt; 되어 &lt;a href=&quot;#when-querysets-are-evaluated&quot;&gt;평가&lt;/a&gt; , 그것은 일반적으로 그 결과를 캐시합니다. &lt;code&gt;QuerySet&lt;/code&gt; 을 평가 한 후 데이터베이스의 데이터가 변경된 경우 이전에 평가 한 &lt;code&gt;QuerySet&lt;/code&gt; 에서 &lt;code&gt;all()&lt;/code&gt; 을 호출하여 동일한 쿼리에 대한 업데이트 된 결과를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3112408e34af556995bab6644c19357e93101162" translate="yes" xml:space="preserve">
          <source>When a conditional expression returns a boolean value, it is possible to use it directly in filters. This means that it will not be added to the &lt;code&gt;SELECT&lt;/code&gt; columns, but you can still use it to filter results:</source>
          <target state="translated">조건식이 부울 값을 반환하면 필터에서 직접 사용할 수 있습니다. 이는 &lt;code&gt;SELECT&lt;/code&gt; 열에 추가되지 않지만 결과를 필터링하는 데 계속 사용할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="cfb7a0ce636d4c4a2105872c97027a0e48a7b66d" translate="yes" xml:space="preserve">
          <source>When a message is given to the logger, the log level of the message is compared to the log level of the logger. If the log level of the message meets or exceeds the log level of the logger itself, the message will undergo further processing. If it doesn&amp;rsquo;t, the message will be ignored.</source>
          <target state="translated">메시지가 로거에 제공되면 메시지의 로그 레벨이 로거의 로그 레벨과 비교됩니다. 메시지의 로그 레벨이 로거 자체의 로그 레벨을 충족하거나 초과하는 경우, 메시지가 추가 처리됩니다. 그렇지 않으면 메시지가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0f0ac0c0a7dca2cb8bedfdefd255ec3ae4b5fd30" translate="yes" xml:space="preserve">
          <source>When a page is requested, Django creates an &lt;a href=&quot;#django.http.HttpRequest&quot;&gt;&lt;code&gt;HttpRequest&lt;/code&gt;&lt;/a&gt; object that contains metadata about the request. Then Django loads the appropriate view, passing the &lt;a href=&quot;#django.http.HttpRequest&quot;&gt;&lt;code&gt;HttpRequest&lt;/code&gt;&lt;/a&gt; as the first argument to the view function. Each view is responsible for returning an &lt;a href=&quot;#django.http.HttpResponse&quot;&gt;&lt;code&gt;HttpResponse&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">페이지가 요청되면 Django는 요청에 대한 메타 데이터가 포함 된 &lt;a href=&quot;#django.http.HttpRequest&quot;&gt; &lt;code&gt;HttpRequest&lt;/code&gt; &lt;/a&gt; 객체를 만듭니다 . 그런 다음 Django는 적절한보기를로드하고 &lt;a href=&quot;#django.http.HttpRequest&quot;&gt; &lt;code&gt;HttpRequest&lt;/code&gt; &lt;/a&gt; 를 첫 번째 인수로 view 함수에 전달합니다. 각 뷰는 &lt;a href=&quot;#django.http.HttpResponse&quot;&gt; &lt;code&gt;HttpResponse&lt;/code&gt; &lt;/a&gt; 객체 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="38d44950f06c56c3f332c08d1c7449371a4004cb" translate="yes" xml:space="preserve">
          <source>When a query expression wraps another expression, it is responsible for calling the appropriate methods on the wrapped expression.</source>
          <target state="translated">쿼리식이 다른 식을 래핑하면 래핑 된 식에서 적절한 메서드를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="a5686af260b48c0cf44d20a73aea34d9eb7e7669" translate="yes" xml:space="preserve">
          <source>When a user logs in, the user&amp;rsquo;s ID and the backend that was used for authentication are saved in the user&amp;rsquo;s session. This allows the same &lt;a href=&quot;customizing#authentication-backends&quot;&gt;authentication backend&lt;/a&gt; to fetch the user&amp;rsquo;s details on a future request. The authentication backend to save in the session is selected as follows:</source>
          <target state="translated">사용자가 로그인하면 인증에 사용 된 사용자 ID와 백엔드가 사용자 세션에 저장됩니다. 이를 통해 동일한 &lt;a href=&quot;customizing#authentication-backends&quot;&gt;인증 백엔드&lt;/a&gt; 가 향후 요청에 대한 사용자 세부 정보를 가져올 수 있습니다 . 세션에 저장할 인증 백엔드는 다음과 같이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="6f15763a17a0d00c2a73b845d62394d5d2fa28c8" translate="yes" xml:space="preserve">
          <source>When a user requests a page from your Django-powered site, this is the algorithm the system follows to determine which Python code to execute:</source>
          <target state="translated">사용자가 Django 기반 사이트에서 페이지를 요청하면 시스템이 실행할 Python 코드를 결정하기 위해 시스템이 따르는 알고리즘입니다.</target>
        </trans-unit>
        <trans-unit id="61f422350cb8bf6e4c1edd44dae8ccdf2fdfd346" translate="yes" xml:space="preserve">
          <source>When a user uploads a file, Django passes off the file data to an &lt;em&gt;upload handler&lt;/em&gt; &amp;ndash; a small class that handles file data as it gets uploaded. Upload handlers are initially defined in the &lt;a href=&quot;../../ref/settings#std:setting-FILE_UPLOAD_HANDLERS&quot;&gt;&lt;code&gt;FILE_UPLOAD_HANDLERS&lt;/code&gt;&lt;/a&gt; setting, which defaults to:</source>
          <target state="translated">사용자가 파일을 업로드하면 Django는 파일 데이터를 &lt;em&gt;업로드 처리기&lt;/em&gt; 로 전달합니다. &lt;em&gt;업로드 핸들러&lt;/em&gt; 는 파일이 업로드 될 때 파일 데이터를 처리하는 작은 클래스입니다. 업로드 핸들러는 처음에 &lt;a href=&quot;../../ref/settings#std:setting-FILE_UPLOAD_HANDLERS&quot;&gt; &lt;code&gt;FILE_UPLOAD_HANDLERS&lt;/code&gt; &lt;/a&gt; 설정 에서 정의되며 기본값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f7b1b5a53701b93325e4815678f8a0bd8b0e9368" translate="yes" xml:space="preserve">
          <source>When a view returns a &lt;a href=&quot;../../ref/request-response#django.http.StreamingHttpResponse&quot;&gt;&lt;code&gt;StreamingHttpResponse&lt;/code&gt;&lt;/a&gt;, reading the contents of the response will often execute code to generate the content. Since the view has already returned, such code runs outside of the transaction.</source>
          <target state="translated">뷰가 &lt;a href=&quot;../../ref/request-response#django.http.StreamingHttpResponse&quot;&gt; &lt;code&gt;StreamingHttpResponse&lt;/code&gt; 를&lt;/a&gt; 반환 하면 응답의 내용을 읽으면 종종 내용을 생성하는 코드가 실행됩니다. 뷰가 이미 리턴되었으므로 이러한 코드는 트랜잭션 외부에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="a7e6eed462fa73c861b891a675a87e3b8f1cb7d1" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;#django.contrib.admin.AdminSite&quot;&gt;&lt;code&gt;AdminSite&lt;/code&gt;&lt;/a&gt; is deployed, the views provided by that site are accessible using Django&amp;rsquo;s &lt;a href=&quot;../../../topics/http/urls#naming-url-patterns&quot;&gt;URL reversing system&lt;/a&gt;.</source>
          <target state="translated">때 &lt;a href=&quot;#django.contrib.admin.AdminSite&quot;&gt; &lt;code&gt;AdminSite&lt;/code&gt; 가&lt;/a&gt; 배치되어, 해당 사이트에서 제공하는 뷰는 장고의 사용하여 액세스 할 수있는 &lt;a href=&quot;../../../topics/http/urls#naming-url-patterns&quot;&gt;URL 반전 시스템을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82d50837bd9a76898a9d01512daa0b09a723a71f" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;annotate()&lt;/code&gt; clause is applied to a query, the annotation is computed over the state of the query up to the point where the annotation is requested. The practical implication of this is that &lt;code&gt;filter()&lt;/code&gt; and &lt;code&gt;annotate()&lt;/code&gt; are not commutative operations.</source>
          <target state="translated">때 &lt;code&gt;annotate()&lt;/code&gt; 절이 쿼리에 적용되고, 주석이 주석이 요청되는 지점까지 쿼리의 상태를 통해 계산됩니다. 이것의 실질적인 의미는 &lt;code&gt;filter()&lt;/code&gt; 와 &lt;code&gt;annotate()&lt;/code&gt; 가 정류 연산이 아니라는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c0066b9a86902f532f6c5122ba7a98655416b06b" translate="yes" xml:space="preserve">
          <source>When an English variant is activated and English strings are missing, the fallback language will not be the &lt;a href=&quot;../../ref/settings#std:setting-LANGUAGE_CODE&quot;&gt;&lt;code&gt;LANGUAGE_CODE&lt;/code&gt;&lt;/a&gt; of the project, but the original strings. For example, an English user visiting a site with &lt;a href=&quot;../../ref/settings#std:setting-LANGUAGE_CODE&quot;&gt;&lt;code&gt;LANGUAGE_CODE&lt;/code&gt;&lt;/a&gt; set to Spanish and original strings written in Russian will see Russian text rather than Spanish.</source>
          <target state="translated">영어 변형이 활성화되고 영어 문자열이없는 경우 대체 언어는 프로젝트 의 &lt;a href=&quot;../../ref/settings#std:setting-LANGUAGE_CODE&quot;&gt; &lt;code&gt;LANGUAGE_CODE&lt;/code&gt; &lt;/a&gt; 가 아니라 원래 문자열입니다. 예를 들어 &lt;a href=&quot;../../ref/settings#std:setting-LANGUAGE_CODE&quot;&gt; &lt;code&gt;LANGUAGE_CODE&lt;/code&gt; &lt;/a&gt; 가 스페인어로 설정되고 러시아어로 작성된 원래 문자열이 있는 사이트를 방문하는 영어 사용자 는 스페인어가 아닌 러시아어 텍스트를 보게됩니다.</target>
        </trans-unit>
        <trans-unit id="02b193dcf2b9af6d2fe916861664208e5e18d31e" translate="yes" xml:space="preserve">
          <source>When an abstract base class is created, Django makes any &lt;a href=&quot;#meta-options&quot;&gt;Meta&lt;/a&gt; inner class you declared in the base class available as an attribute. If a child class does not declare its own &lt;a href=&quot;#meta-options&quot;&gt;Meta&lt;/a&gt; class, it will inherit the parent&amp;rsquo;s &lt;a href=&quot;#meta-options&quot;&gt;Meta&lt;/a&gt;. If the child wants to extend the parent&amp;rsquo;s &lt;a href=&quot;#meta-options&quot;&gt;Meta&lt;/a&gt; class, it can subclass it. For example:</source>
          <target state="translated">추상 기본 클래스가 생성되면 Django는 기본 클래스에서 선언 한 모든 &lt;a href=&quot;#meta-options&quot;&gt;메타&lt;/a&gt; 내부 클래스를 속성으로 사용할 수있게합니다. 자식 클래스가 자체 &lt;a href=&quot;#meta-options&quot;&gt;Meta&lt;/a&gt; 클래스를 선언하지 않으면 부모의 &lt;a href=&quot;#meta-options&quot;&gt;Meta&lt;/a&gt; 클래스를 상속합니다 . 자식이 부모의 &lt;a href=&quot;#meta-options&quot;&gt;Meta&lt;/a&gt; 클래스 를 확장하려는 경우 하위 클래스를 만들 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7d9702c943a452b9984773add9ad412003ffb037" translate="yes" xml:space="preserve">
          <source>When an object referenced by a &lt;a href=&quot;#django.db.models.ForeignKey&quot;&gt;&lt;code&gt;ForeignKey&lt;/code&gt;&lt;/a&gt; is deleted, Django will emulate the behavior of the SQL constraint specified by the &lt;a href=&quot;#django.db.models.ForeignKey.on_delete&quot;&gt;&lt;code&gt;on_delete&lt;/code&gt;&lt;/a&gt; argument. For example, if you have a nullable &lt;a href=&quot;#django.db.models.ForeignKey&quot;&gt;&lt;code&gt;ForeignKey&lt;/code&gt;&lt;/a&gt; and you want it to be set null when the referenced object is deleted:</source>
          <target state="translated">&lt;a href=&quot;#django.db.models.ForeignKey&quot;&gt; &lt;code&gt;ForeignKey&lt;/code&gt; &lt;/a&gt; 가 참조하는 객체 가 삭제되면 Django는 &lt;a href=&quot;#django.db.models.ForeignKey.on_delete&quot;&gt; &lt;code&gt;on_delete&lt;/code&gt; &lt;/a&gt; 인수로 지정된 SQL 제약 조건의 동작을 에뮬레이트합니다 . 예를 들어, nullable &lt;a href=&quot;#django.db.models.ForeignKey&quot;&gt; &lt;code&gt;ForeignKey&lt;/code&gt; 가&lt;/a&gt; 있고 참조 된 개체가 삭제 될 때 null로 설정하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="6d43cc5a53dee15e460ec423c1ca686e65544d6d" translate="yes" xml:space="preserve">
          <source>When auto-escaping is in effect, all variable content has HTML escaping applied to it before placing the result into the output (but after any filters have been applied). This is equivalent to manually applying the &lt;a href=&quot;#std:templatefilter-escape&quot;&gt;&lt;code&gt;escape&lt;/code&gt;&lt;/a&gt; filter to each variable.</source>
          <target state="translated">자동 이스케이프가 적용되면 결과에 출력하기 전에 (그러나 필터가 적용된 후) 모든 가변 컨텐츠에 HTML 이스케이프가 적용됩니다. 이는 각 변수에 &lt;a href=&quot;#std:templatefilter-escape&quot;&gt; &lt;code&gt;escape&lt;/code&gt; &lt;/a&gt; 필터를 수동으로 적용하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="cccc6b2743259572ce842852541189590bc10664" translate="yes" xml:space="preserve">
          <source>When autocommit is enabled, savepoints don&amp;rsquo;t make sense. When it&amp;rsquo;s disabled, &lt;a href=&quot;https://docs.python.org/3/library/sqlite3.html#module-sqlite3&quot;&gt;&lt;code&gt;sqlite3&lt;/code&gt;&lt;/a&gt; commits implicitly before savepoint statements. (In fact, it commits before any statement other than &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt; and &lt;code&gt;REPLACE&lt;/code&gt;.) This bug has two consequences:</source>
          <target state="translated">자동 커밋이 활성화되면 세이브 포인트가 의미가 없습니다. 비활성화 된 경우 &lt;a href=&quot;https://docs.python.org/3/library/sqlite3.html#module-sqlite3&quot;&gt; &lt;code&gt;sqlite3&lt;/code&gt; &lt;/a&gt; 은 저장 점 문 전에 암시 적으로 커밋합니다. (실제로 &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; 및 &lt;code&gt;REPLACE&lt;/code&gt; 이외의 명령문보다 먼저 커밋합니다 .)이 버그에는 두 가지 결과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="675cccfe8fa1bab73852683e00d7c4ad0534907c" translate="yes" xml:space="preserve">
          <source>When called without the &lt;code&gt;import_path&lt;/code&gt; parameter &lt;code&gt;get_storage_class&lt;/code&gt; will return the current default storage system as defined by &lt;a href=&quot;../settings#std:setting-DEFAULT_FILE_STORAGE&quot;&gt;&lt;code&gt;DEFAULT_FILE_STORAGE&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;import_path&lt;/code&gt; is provided, &lt;code&gt;get_storage_class&lt;/code&gt; will attempt to import the class or module from the given path and will return it if successful. An exception will be raised if the import is unsuccessful.</source>
          <target state="translated">&lt;code&gt;import_path&lt;/code&gt; 매개 변수 없이 호출되면 &lt;code&gt;get_storage_class&lt;/code&gt; 는 &lt;a href=&quot;../settings#std:setting-DEFAULT_FILE_STORAGE&quot;&gt; &lt;code&gt;DEFAULT_FILE_STORAGE&lt;/code&gt; 에&lt;/a&gt; 의해 정의 된 현재 기본 스토리지 시스템을 리턴합니다 . 경우 &lt;code&gt;import_path&lt;/code&gt; 가 제공되며, &lt;code&gt;get_storage_class&lt;/code&gt; 는 주어진 경로에서 클래스 나 모듈을 수입하려고 시도하고 성공하면 반환됩니다. 가져 오기에 실패하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2f0f632ea59f942f5eade1f689ffb654226e223b" translate="yes" xml:space="preserve">
          <source>When called, callbacks will be passed a single argument &amp;ndash; the rendered &lt;a href=&quot;#django.template.response.SimpleTemplateResponse&quot;&gt;&lt;code&gt;SimpleTemplateResponse&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">호출되면 콜백에는 단일 인수 (렌더링 된 &lt;a href=&quot;#django.template.response.SimpleTemplateResponse&quot;&gt; &lt;code&gt;SimpleTemplateResponse&lt;/code&gt; &lt;/a&gt; 인스턴스) 가 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="7fd45e0758569c65bbba8e1860deb79a579af464" translate="yes" xml:space="preserve">
          <source>When calling &lt;a href=&quot;instances#django.db.models.Model.save&quot;&gt;&lt;code&gt;save()&lt;/code&gt;&lt;/a&gt; for instances with deferred fields, only the loaded fields will be saved. See &lt;a href=&quot;instances#django.db.models.Model.save&quot;&gt;&lt;code&gt;save()&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">지연된 필드가있는 인스턴스에 대해 &lt;a href=&quot;instances#django.db.models.Model.save&quot;&gt; &lt;code&gt;save()&lt;/code&gt; &lt;/a&gt; 를 호출 하면 로드 된 필드 만 저장됩니다. 자세한 내용은 &lt;a href=&quot;instances#django.db.models.Model.save&quot;&gt; &lt;code&gt;save()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bda759db08ff8c0e87bc3825b809b30fe8d238af" translate="yes" xml:space="preserve">
          <source>When choosing a name for your package, check resources like PyPI to avoid naming conflicts with existing packages. It&amp;rsquo;s often useful to prepend &lt;code&gt;django-&lt;/code&gt; to your module name when creating a package to distribute. This helps others looking for Django apps identify your app as Django specific.</source>
          <target state="translated">패키지 이름을 선택할 때 기존 패키지와의 이름 충돌을 피하기 위해 PyPI와 같은 리소스를 확인하십시오. 배포 할 패키지를 만들 때 모듈 이름 앞에 &lt;code&gt;django-&lt;/code&gt; 를 추가하면 유용합니다 . 이를 통해 Django 앱을 찾는 다른 사람들이 앱을 Django 전용으로 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c89f0ebd4bab6531ff03034464d7b1e1dff9d44" translate="yes" xml:space="preserve">
          <source>When combining multiple field types, Django can only determine the &lt;code&gt;output_field&lt;/code&gt; if all fields are of the same type. Otherwise, you must provide the &lt;code&gt;output_field&lt;/code&gt; yourself.</source>
          <target state="translated">여러 필드 유형을 결합 할 때 Django는 모든 필드가 동일한 유형 인 경우 에만 &lt;code&gt;output_field&lt;/code&gt; 를 결정할 수 있습니다 . 그렇지 않으면 &lt;code&gt;output_field&lt;/code&gt; 를 직접 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a0bfee5d0d97832a6a69ff41a9efdb8902e02017" translate="yes" xml:space="preserve">
          <source>When compiling a query, Django first looks for &lt;code&gt;as_%s % connection.vendor&lt;/code&gt; methods, and then falls back to &lt;code&gt;as_sql&lt;/code&gt;. The vendor names for the in-built backends are &lt;code&gt;sqlite&lt;/code&gt;, &lt;code&gt;postgresql&lt;/code&gt;, &lt;code&gt;oracle&lt;/code&gt; and &lt;code&gt;mysql&lt;/code&gt;.</source>
          <target state="translated">Django는 쿼리를 컴파일 할 때 먼저 &lt;code&gt;as_%s % connection.vendor&lt;/code&gt; 메소드를 &lt;code&gt;as_sql&lt;/code&gt; 다음 as_sql 로 폴백 합니다. 내장 백엔드의 공급 업체 이름은 &lt;code&gt;sqlite&lt;/code&gt; , &lt;code&gt;postgresql&lt;/code&gt; , &lt;code&gt;oracle&lt;/code&gt; 및 &lt;code&gt;mysql&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f39ae5cdee8e6b07f7e1a6980c0f609502856e4d" translate="yes" xml:space="preserve">
          <source>When connecting to other database backends, such as MariaDB, MySQL, Oracle, or PostgreSQL, additional connection parameters will be required. See the &lt;a href=&quot;#std:setting-DATABASE-ENGINE&quot;&gt;&lt;code&gt;ENGINE&lt;/code&gt;&lt;/a&gt; setting below on how to specify other database types. This example is for PostgreSQL:</source>
          <target state="translated">MariaDB, MySQL, Oracle 또는 PostgreSQL과 같은 다른 데이터베이스 백엔드에 연결하는 경우 추가 연결 매개 변수가 필요합니다. 다른 데이터베이스 유형을 지정하는 방법은 아래 의 &lt;a href=&quot;#std:setting-DATABASE-ENGINE&quot;&gt; &lt;code&gt;ENGINE&lt;/code&gt; &lt;/a&gt; 설정을 참조하십시오 . 이 예제는 PostgreSQL에 대한 것입니다.</target>
        </trans-unit>
        <trans-unit id="1c481af2084277b5e5da4bf5edff2e79752a100e" translate="yes" xml:space="preserve">
          <source>When connecting to signals sent by the user model, you should specify the custom model using the &lt;a href=&quot;../../ref/settings#std:setting-AUTH_USER_MODEL&quot;&gt;&lt;code&gt;AUTH_USER_MODEL&lt;/code&gt;&lt;/a&gt; setting. For example:</source>
          <target state="translated">사용자 모델이 보낸 신호에 연결할 때 &lt;a href=&quot;../../ref/settings#std:setting-AUTH_USER_MODEL&quot;&gt; &lt;code&gt;AUTH_USER_MODEL&lt;/code&gt; &lt;/a&gt; 설정을 사용하여 사용자 정의 모델을 지정해야 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e91cb5e7e921bf302395449394c4441d41270b44" translate="yes" xml:space="preserve">
          <source>When constructing an instance of an &lt;code&gt;AdminSite&lt;/code&gt;, you can provide a unique instance name using the &lt;code&gt;name&lt;/code&gt; argument to the constructor. This instance name is used to identify the instance, especially when &lt;a href=&quot;#admin-reverse-urls&quot;&gt;reversing admin URLs&lt;/a&gt;. If no instance name is provided, a default instance name of &lt;code&gt;admin&lt;/code&gt; will be used. See &lt;a href=&quot;#customizing-adminsite&quot;&gt;Customizing the AdminSite class&lt;/a&gt; for an example of customizing the &lt;a href=&quot;#django.contrib.admin.AdminSite&quot;&gt;&lt;code&gt;AdminSite&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">&lt;code&gt;AdminSite&lt;/code&gt; 인스턴스를 생성 할 때 생성자에 &lt;code&gt;name&lt;/code&gt; 인수를 사용하여 고유 한 인스턴스 이름을 제공 할 수 있습니다 . 이 인스턴스 이름은 특히 &lt;a href=&quot;#admin-reverse-urls&quot;&gt;관리 URL을 되돌릴&lt;/a&gt; 때 인스턴스를 식별하는 데 사용 됩니다 . 인스턴스 이름이 제공되지 않으면 기본 인스턴스 이름 인 &lt;code&gt;admin&lt;/code&gt; 이 사용됩니다. 페이지의 &lt;a href=&quot;#customizing-adminsite&quot;&gt;사용자 정의 AdminSite 클래스&lt;/a&gt; 커스터마이징의 예를 들어 &lt;a href=&quot;#django.contrib.admin.AdminSite&quot;&gt; &lt;code&gt;AdminSite&lt;/code&gt; &lt;/a&gt; 클래스를.</target>
        </trans-unit>
        <trans-unit id="a36e5b0713f3eb92ed4fab232160ed69eada8f4e" translate="yes" xml:space="preserve">
          <source>When context processors are applied</source>
          <target state="translated">컨텍스트 프로세서가 적용되는 경우</target>
        </trans-unit>
        <trans-unit id="e6b434d1741ccb871b17c69cfc35d23b04dad27a" translate="yes" xml:space="preserve">
          <source>When contributing to Django it&amp;rsquo;s very important that your code changes don&amp;rsquo;t introduce bugs into other areas of Django. One way to check that Django still works after you make your changes is by running Django&amp;rsquo;s test suite. If all the tests still pass, then you can be reasonably sure that your changes work and haven&amp;rsquo;t broken other parts Django. If you&amp;rsquo;ve never run Django&amp;rsquo;s test suite before, it&amp;rsquo;s a good idea to run it once beforehand to get familiar with its output.</source>
          <target state="translated">Django에 기여할 때는 코드 변경으로 Django의 다른 영역에 버그가 발생하지 않는 것이 중요합니다. 변경 후 Django가 여전히 작동하는지 확인하는 한 가지 방법은 Django의 테스트 스위트를 실행하는 것입니다. 모든 테스트가 여전히 통과하면 변경 사항이 작동하고 다른 부분이 장고를 손상시키지 않았 음을 합리적으로 확신 할 수 있습니다. 전에 Django의 테스트 스위트를 실행 한 적이 없다면 출력에 익숙해지기 전에 미리 한 번 실행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="41cebc45fe86060ffa0347f7c85715435a8081ab" translate="yes" xml:space="preserve">
          <source>When creating a SpatiaLite database, the &lt;code&gt;spatialite&lt;/code&gt; program is required. However, instead of attempting to compile the SpatiaLite tools from source, download the &lt;a href=&quot;https://www.kyngchaos.com/software/frameworks/&quot;&gt;SpatiaLite Tools&lt;/a&gt; package for macOS, and install &lt;code&gt;spatialite&lt;/code&gt; in a location available in your &lt;code&gt;PATH&lt;/code&gt;. For example:</source>
          <target state="translated">SpatiaLite 데이터베이스를 작성할 때 &lt;code&gt;spatialite&lt;/code&gt; 프로그램이 필요합니다. 그러나 소스에서 SpatiaLite 도구를 컴파일하는 대신 macOS 용 &lt;a href=&quot;https://www.kyngchaos.com/software/frameworks/&quot;&gt;SpatiaLite 도구&lt;/a&gt; 패키지를 다운로드하고 &lt;code&gt;PATH&lt;/code&gt; 에서 사용 가능한 위치에 &lt;code&gt;spatialite&lt;/code&gt; 을 설치 하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f9a84a18f5de7131514373281a4198be304cf839" translate="yes" xml:space="preserve">
          <source>When creating custom message levels you should be careful to avoid overloading existing levels. The values for the built-in levels are:</source>
          <target state="translated">사용자 지정 메시지 수준을 만들 때는 기존 수준에 과부하가 걸리지 않도록주의해야합니다. 내장 레벨의 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="80d07743261c17a24bac144259c4216c257fed12" translate="yes" xml:space="preserve">
          <source>When creating objects, where possible, use the &lt;a href=&quot;../../ref/models/querysets#django.db.models.query.QuerySet.bulk_create&quot;&gt;&lt;code&gt;bulk_create()&lt;/code&gt;&lt;/a&gt; method to reduce the number of SQL queries. For example:</source>
          <target state="translated">가능하면 객체를 만들 때 &lt;a href=&quot;../../ref/models/querysets#django.db.models.query.QuerySet.bulk_create&quot;&gt; &lt;code&gt;bulk_create()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 SQL 쿼리 수를 줄입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="10add64e768175da214899669aca285eb32afddc" translate="yes" xml:space="preserve">
          <source>When creating raster models, the raster field will implicitly convert the input into a &lt;a href=&quot;gdal#django.contrib.gis.gdal.GDALRaster&quot;&gt;&lt;code&gt;GDALRaster&lt;/code&gt;&lt;/a&gt; using lazy-evaluation. The raster field will therefore accept any input that is accepted by the &lt;a href=&quot;gdal#django.contrib.gis.gdal.GDALRaster&quot;&gt;&lt;code&gt;GDALRaster&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">래스터 모델을 만들 때 래스터 필드는 지연 평가를 사용하여 입력을 &lt;a href=&quot;gdal#django.contrib.gis.gdal.GDALRaster&quot;&gt; &lt;code&gt;GDALRaster&lt;/code&gt; &lt;/a&gt; 로 암시 적으로 변환합니다 . 따라서 래스터 필드는 &lt;a href=&quot;gdal#django.contrib.gis.gdal.GDALRaster&quot;&gt; &lt;code&gt;GDALRaster&lt;/code&gt; &lt;/a&gt; 생성자 가 허용하는 모든 입력을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="2d7179c6c16598cc452029b58db0a60addb7a726" translate="yes" xml:space="preserve">
          <source>When customizing the templates for the &lt;a href=&quot;#django.contrib.sitemaps.views.index&quot;&gt;&lt;code&gt;index()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#django.contrib.sitemaps.views.sitemap&quot;&gt;&lt;code&gt;sitemap()&lt;/code&gt;&lt;/a&gt; views, you can rely on the following context variables.</source>
          <target state="translated">&lt;a href=&quot;#django.contrib.sitemaps.views.index&quot;&gt; &lt;code&gt;index()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#django.contrib.sitemaps.views.sitemap&quot;&gt; &lt;code&gt;sitemap()&lt;/code&gt; &lt;/a&gt; 보기 의 템플리트를 사용자 정의 할 때 다음 컨텍스트 변수에 의존 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5401ed82a14d2c81a841459327ff53e254082021" translate="yes" xml:space="preserve">
          <source>When dealing with views that generate very large responses, you might want to consider using Django&amp;rsquo;s &lt;a href=&quot;../ref/request-response#django.http.StreamingHttpResponse&quot;&gt;&lt;code&gt;StreamingHttpResponse&lt;/code&gt;&lt;/a&gt; instead. For example, by streaming a file that takes a long time to generate you can avoid a load balancer dropping a connection that might have otherwise timed out while the server was generating the response.</source>
          <target state="translated">매우 큰 응답을 생성하는 뷰를 처리 할 때 대신 Django의 &lt;a href=&quot;../ref/request-response#django.http.StreamingHttpResponse&quot;&gt; &lt;code&gt;StreamingHttpResponse&lt;/code&gt; 를&lt;/a&gt; 사용하는 것이 좋습니다. 예를 들어, 생성하는 데 시간이 오래 걸리는 파일을 스트리밍하면로드 밸런서가 서버가 응답을 생성하는 동안 시간이 초과되었을 수있는 연결을 끊는 것을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f2a4fe18202a0cb7c1d27b8727cfa44ae742f2d" translate="yes" xml:space="preserve">
          <source>When defining a many-to-many relationship from a model to itself, using an intermediary model, you &lt;em&gt;must&lt;/em&gt; use &lt;a href=&quot;../../ref/models/fields#django.db.models.ManyToManyField.symmetrical&quot;&gt;&lt;code&gt;symmetrical=False&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;../../ref/models/fields#manytomany-arguments&quot;&gt;the model field reference&lt;/a&gt;).</source>
          <target state="translated">중간 모델을 사용, 자체 모델에서 다 대다 관계를 정의 할 때, 당신은 &lt;em&gt;해야한다&lt;/em&gt; 사용 &lt;a href=&quot;../../ref/models/fields#django.db.models.ManyToManyField.symmetrical&quot;&gt; &lt;code&gt;symmetrical=False&lt;/code&gt; &lt;/a&gt; (참조 &lt;a href=&quot;../../ref/models/fields#manytomany-arguments&quot;&gt;모델 필드 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2e01b2c34b29f92f171b6918a748b31c9449cffe" translate="yes" xml:space="preserve">
          <source>When deployed with &lt;a href=&quot;#security-recommendation-ssl&quot;&gt;HTTPS&lt;/a&gt;, &lt;code&gt;CsrfViewMiddleware&lt;/code&gt; will check that the HTTP referer header is set to a URL on the same origin (including subdomain and port). Because HTTPS provides additional security, it is imperative to ensure connections use HTTPS where it is available by forwarding insecure connection requests and using HSTS for supported browsers.</source>
          <target state="translated">함께 배포하면 &lt;a href=&quot;#security-recommendation-ssl&quot;&gt;HTTPS&lt;/a&gt; , &lt;code&gt;CsrfViewMiddleware&lt;/code&gt; 이 는 HTTP 리퍼러 헤더 (하위 도메인 및 포트 포함) 같은 기원에서 URL로 설정되어 있는지 확인합니다. HTTPS는 추가 보안을 제공하므로 안전하지 않은 연결 요청을 전달하고 지원되는 브라우저에 HSTS를 사용하여 사용 가능한 위치에서 HTTPS를 사용하도록 연결하는 것이 필수적입니다.</target>
        </trans-unit>
        <trans-unit id="30838d4e118bdb2790fbded0355406a25ac5da66" translate="yes" xml:space="preserve">
          <source>When determining the number of objects contained in &lt;code&gt;object_list&lt;/code&gt;, &lt;code&gt;Paginator&lt;/code&gt; will first try calling &lt;code&gt;object_list.count()&lt;/code&gt;. If &lt;code&gt;object_list&lt;/code&gt; has no &lt;code&gt;count()&lt;/code&gt; method, then &lt;code&gt;Paginator&lt;/code&gt; will fall back to using &lt;code&gt;len(object_list)&lt;/code&gt;. This allows objects, such as &lt;code&gt;QuerySet&lt;/code&gt;, to use a more efficient &lt;code&gt;count()&lt;/code&gt; method when available.</source>
          <target state="translated">객체의 수에 포함 결정할 때 &lt;code&gt;object_list&lt;/code&gt; , &lt;code&gt;Paginator&lt;/code&gt; 먼저 호출하려고합니다 &lt;code&gt;object_list.count()&lt;/code&gt; . 경우 &lt;code&gt;object_list&lt;/code&gt; 이 더 없습니다 &lt;code&gt;count()&lt;/code&gt; 메소드를 다음 &lt;code&gt;Paginator&lt;/code&gt; 사용하여 다시 떨어질 것 &lt;code&gt;len(object_list)&lt;/code&gt; . 이를 통해 &lt;code&gt;QuerySet&lt;/code&gt; 과 같은 객체 가 사용 가능한 경우보다 효율적인 &lt;code&gt;count()&lt;/code&gt; 메서드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8591ac387a52a2898b08328434ec2ae27d24970c" translate="yes" xml:space="preserve">
          <source>When developing a complex query that involves both &lt;code&gt;annotate()&lt;/code&gt; and &lt;code&gt;filter()&lt;/code&gt; clauses, pay particular attention to the order in which the clauses are applied to the &lt;code&gt;QuerySet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;annotate()&lt;/code&gt; 및 &lt;code&gt;filter()&lt;/code&gt; 절을 모두 포함하는 복잡한 쿼리를 개발할 때 절이 &lt;code&gt;QuerySet&lt;/code&gt; 에 적용되는 순서에 특히주의하십시오 .</target>
        </trans-unit>
        <trans-unit id="db184ffcdc7c4d2d64c33f2b5cccd1427c60b564" translate="yes" xml:space="preserve">
          <source>When distances are calculated with geodetic (angular) coordinates, as is the case with the default WGS84 (4326) SRID, you can set the &lt;code&gt;spheroid&lt;/code&gt; keyword argument to decide if the calculation should be based on a simple sphere (less accurate, less resource-intensive) or on a spheroid (more accurate, more resource-intensive).</source>
          <target state="translated">기본 WGS84 (4326) SRID의 경우와 같이 측지 (각도) 좌표를 사용하여 거리를 계산할 때 &lt;code&gt;spheroid&lt;/code&gt; 키워드 인수를 설정 하여 계산이 단순한 구 (낮지 않고 덜 적은 자원- 집중적) 또는 회전 타원체 (보다 정확하고 자원 집약적)</target>
        </trans-unit>
        <trans-unit id="acf0a1040f202022ac1e558b1f6898ddcc50fd38" translate="yes" xml:space="preserve">
          <source>When doing spatial queries, GeoDjango automatically transforms geometries if they&amp;rsquo;re in a different coordinate system. In the following example, coordinates will be expressed in &lt;a href=&quot;https://spatialreference.org/ref/epsg/32140/&quot;&gt;EPSG SRID 32140&lt;/a&gt;, a coordinate system specific to south Texas &lt;strong&gt;only&lt;/strong&gt; and in units of &lt;strong&gt;meters&lt;/strong&gt;, not degrees:</source>
          <target state="translated">공간 쿼리를 수행 할 때 GeoDjango는 다른 좌표계에있는 경우 형상을 자동으로 변환합니다. 다음 예에서 좌표는 &lt;a href=&quot;https://spatialreference.org/ref/epsg/32140/&quot;&gt;EPS가 아닌&lt;/a&gt; 남쪽 텍사스 &lt;strong&gt;에만 해당&lt;/strong&gt; 하는 좌표계 인 EPSG SRID 32140 으로 표시되며 각도가 아닌 &lt;strong&gt;미터&lt;/strong&gt; 단위로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="fcf90bbef1b9b8846a55cdad056fa89091005607" translate="yes" xml:space="preserve">
          <source>When enabling HSTS, it&amp;rsquo;s a good idea to first use a small value for testing, for example, &lt;a href=&quot;settings#std:setting-SECURE_HSTS_SECONDS&quot;&gt;&lt;code&gt;SECURE_HSTS_SECONDS = 3600&lt;/code&gt;&lt;/a&gt; for one hour. Each time a Web browser sees the HSTS header from your site, it will refuse to communicate non-securely (using HTTP) with your domain for the given period of time. Once you confirm that all assets are served securely on your site (i.e. HSTS didn&amp;rsquo;t break anything), it&amp;rsquo;s a good idea to increase this value so that infrequent visitors will be protected (31536000 seconds, i.e. 1 year, is common).</source>
          <target state="translated">HSTS를 활성화 할 때는 먼저 테스트에 작은 값을 사용하는 것이 좋습니다 (예 : &lt;a href=&quot;settings#std:setting-SECURE_HSTS_SECONDS&quot;&gt; &lt;code&gt;SECURE_HSTS_SECONDS = 3600&lt;/code&gt; &lt;/a&gt; . 웹 브라우저가 사이트에서 HSTS 헤더를 볼 때마다 주어진 기간 동안 도메인과 비보안 적으로 (HTTP를 사용하여) 통신하는 것을 거부합니다. 모든 자산이 사이트에서 안전하게 제공된다는 것을 확인한 후 (예 : HSTS가 아무 것도 위반하지 않음), 드물게 방문자를 보호 할 수 있도록이 값을 높이는 것이 좋습니다 (31536000 초, 즉 1 년이 일반적 임).</target>
        </trans-unit>
        <trans-unit id="d223af5ce54c6fb836fe9eef9ac56b6081e73432" translate="yes" xml:space="preserve">
          <source>When exiting an &lt;code&gt;atomic&lt;/code&gt; block, Django looks at whether it&amp;rsquo;s exited normally or with an exception to determine whether to commit or roll back. If you catch and handle exceptions inside an &lt;code&gt;atomic&lt;/code&gt; block, you may hide from Django the fact that a problem has happened. This can result in unexpected behavior.</source>
          <target state="translated">Django는 &lt;code&gt;atomic&lt;/code&gt; 블록을 나갈 때 정상적으로 종료했는지 또는 예외로 커밋 또는 롤백 여부를 결정합니다. &lt;code&gt;atomic&lt;/code&gt; 블록 내에서 예외를 포착하고 처리 하면 문제가 발생했다는 사실을 장고에서 숨길 수 있습니다. 예기치 않은 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07b67cc9627c1897ead0d8a3ad29c379697776a3" translate="yes" xml:space="preserve">
          <source>When fields are missing from the form (for example because they have been excluded), these fields will not be set by the &lt;code&gt;save()&lt;/code&gt; method. You can find more information about this restriction, which also holds for regular &lt;code&gt;ModelForms&lt;/code&gt;, in &lt;a href=&quot;#selecting-the-fields-to-use&quot;&gt;Selecting the fields to use&lt;/a&gt;.</source>
          <target state="translated">필드가 필드에서 누락 된 경우 (예 : 필드가 제외되었으므로) 이러한 필드는 &lt;code&gt;save()&lt;/code&gt; 메소드 로 설정되지 않습니다 . 이 &lt;a href=&quot;#selecting-the-fields-to-use&quot;&gt;필드에&lt;/a&gt; 대한 자세한 정보는 사용할 필드 선택 에서 일반 &lt;code&gt;ModelForms&lt;/code&gt; 에도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="3f47a73938d9f8c7da11013db8ccf991c51c26bc" translate="yes" xml:space="preserve">
          <source>When filtering, if there is only one lookup name remaining to be resolved, we will look for a &lt;code&gt;Lookup&lt;/code&gt;. If there are multiple names, it will look for a &lt;code&gt;Transform&lt;/code&gt;. In the situation where there is only one name and a &lt;code&gt;Lookup&lt;/code&gt; is not found, we look for a &lt;code&gt;Transform&lt;/code&gt; and then the &lt;code&gt;exact&lt;/code&gt; lookup on that &lt;code&gt;Transform&lt;/code&gt;. All call sequences always end with a &lt;code&gt;Lookup&lt;/code&gt;. To clarify:</source>
          <target state="translated">필터링 할 때 해결해야 할 조회 이름이 하나만 남아 있으면 &lt;code&gt;Lookup&lt;/code&gt; 을 찾습니다 . 이름이 여러 개인 경우 &lt;code&gt;Transform&lt;/code&gt; 을 찾습니다 . 하나의 이름 만 있고 &lt;code&gt;Lookup&lt;/code&gt; 를 찾을 수없는 상황에서는 &lt;code&gt;Transform&lt;/code&gt; 을 찾은 다음 해당 &lt;code&gt;Transform&lt;/code&gt; 에 대한 &lt;code&gt;exact&lt;/code&gt; 조회를 찾습니다 . 모든 호출 시퀀스는 항상 &lt;code&gt;Lookup&lt;/code&gt; 으로 끝납니다 . 명확히하기 위해 :</target>
        </trans-unit>
        <trans-unit id="168b469a0307be68165782716e6e007ca2291fc0" translate="yes" xml:space="preserve">
          <source>When fixture files are processed, the data is saved to the database as is. Model defined &lt;a href=&quot;models/instances#django.db.models.Model.save&quot;&gt;&lt;code&gt;save()&lt;/code&gt;&lt;/a&gt; methods are not called, and any &lt;a href=&quot;signals#django.db.models.signals.pre_save&quot;&gt;&lt;code&gt;pre_save&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;signals#django.db.models.signals.post_save&quot;&gt;&lt;code&gt;post_save&lt;/code&gt;&lt;/a&gt; signals will be called with &lt;code&gt;raw=True&lt;/code&gt; since the instance only contains attributes that are local to the model. You may, for example, want to disable handlers that access related fields that aren&amp;rsquo;t present during fixture loading and would otherwise raise an exception:</source>
          <target state="translated">조명기 파일이 처리되면 데이터는 그대로 데이터베이스에 저장됩니다. 모델 정의 &lt;a href=&quot;models/instances#django.db.models.Model.save&quot;&gt; &lt;code&gt;save()&lt;/code&gt; &lt;/a&gt; 메소드는 호출되지 않으며 인스턴스에 모델에 로컬 인 속성 만 포함되므로 모든 &lt;a href=&quot;signals#django.db.models.signals.pre_save&quot;&gt; &lt;code&gt;pre_save&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;signals#django.db.models.signals.post_save&quot;&gt; &lt;code&gt;post_save&lt;/code&gt; &lt;/a&gt; 신호는 &lt;code&gt;raw=True&lt;/code&gt; 와 함께 호출됩니다 . 예를 들어, 조명기 로딩 중에 존재하지 않는 관련 필드에 액세스하는 핸들러를 비활성화하고 그렇지 않으면 예외를 발생시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21f29b0108bff6caa83fb655b3ecdaf9e063e8ae" translate="yes" xml:space="preserve">
          <source>When formatting is enabled, Django can use localized formats when parsing dates, times and numbers in forms. That means it tries different formats for different locales when guessing the format used by the user when inputting data on forms.</source>
          <target state="translated">포맷이 활성화되면 Django는 날짜, 시간 및 숫자를 양식으로 구문 분석 할 때 현지화 된 형식을 사용할 수 있습니다. 즉, 양식에 데이터를 입력 할 때 사용자가 사용하는 형식을 추측 할 때 다른 로케일에 대해 다른 형식을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="4e8b1eb50d54cc332383eec9c627f9f744e3a0b6" translate="yes" xml:space="preserve">
          <source>When generating HTML from templates, there&amp;rsquo;s always a risk that a variable will include characters that affect the resulting HTML. For example, consider this template fragment:</source>
          <target state="translated">템플릿에서 HTML을 생성 할 때 변수에 결과 HTML에 영향을주는 문자가 포함될 위험이 항상 있습니다. 예를 들어이 템플릿 조각을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="b8e12ab3ef8eb81964a582ce521ab20f4d290d6e" translate="yes" xml:space="preserve">
          <source>When generating the geometry field, treat it as a geometry collection. For example, if this setting is enabled then a &lt;a href=&quot;model-api#django.contrib.gis.db.models.MultiPolygonField&quot;&gt;&lt;code&gt;MultiPolygonField&lt;/code&gt;&lt;/a&gt; will be placed in the generated model rather than &lt;a href=&quot;model-api#django.contrib.gis.db.models.PolygonField&quot;&gt;&lt;code&gt;PolygonField&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지오메트리 필드를 생성 할 때 지오메트리 컬렉션으로 취급하십시오. 예를 &lt;a href=&quot;model-api#django.contrib.gis.db.models.PolygonField&quot;&gt; &lt;code&gt;PolygonField&lt;/code&gt; &lt;/a&gt; 설정을 사용하면 &lt;a href=&quot;model-api#django.contrib.gis.db.models.MultiPolygonField&quot;&gt; &lt;code&gt;MultiPolygonField&lt;/code&gt; &lt;/a&gt; 가 PolygonField가 아닌 생성 된 모델에 배치됩니다 .</target>
        </trans-unit>
        <trans-unit id="3ee5d9c70b807f7e856b951e2d0a8f69f1b2a210" translate="yes" xml:space="preserve">
          <source>When given a class, these decorators modify the class directly and return it; they don&amp;rsquo;t create and return a modified copy of it. So if you try to tweak the above examples to assign the return value to a different name than &lt;code&gt;LoginTestCase&lt;/code&gt; or &lt;code&gt;MiddlewareTestCase&lt;/code&gt;, you may be surprised to find that the original test case classes are still equally affected by the decorator. For a given class, &lt;a href=&quot;#django.test.modify_settings&quot;&gt;&lt;code&gt;modify_settings()&lt;/code&gt;&lt;/a&gt; is always applied after &lt;a href=&quot;#django.test.override_settings&quot;&gt;&lt;code&gt;override_settings()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">클래스가 주어지면이 데코레이터는 클래스를 직접 수정하여 반환합니다. 수정 된 사본을 작성하여 리턴하지 않습니다. 따라서 위의 예제를 조정하여 &lt;code&gt;LoginTestCase&lt;/code&gt; 또는 &lt;code&gt;MiddlewareTestCase&lt;/code&gt; 와 다른 이름으로 반환 값을 할당하려고 하면 원래 테스트 케이스 클래스가 여전히 데코레이터의 영향을 받는다는 사실에 놀랄 수 있습니다. 지정된 클래스에 대해 &lt;a href=&quot;#django.test.modify_settings&quot;&gt; &lt;code&gt;modify_settings()&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#django.test.override_settings&quot;&gt; &lt;code&gt;override_settings()&lt;/code&gt; &lt;/a&gt; 뒤에 항상 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f898834e6234c818ddb9e17079c4250b400dcd76" translate="yes" xml:space="preserve">
          <source>When given a namespaced URL (e.g. &lt;code&gt;'polls:index'&lt;/code&gt;) to resolve, Django splits the fully qualified name into parts and then tries the following lookup:</source>
          <target state="translated">Django 는 확인할 네임 스페이스 URL (예 : &lt;code&gt;'polls:index'&lt;/code&gt; )을 제공하면 정규화 된 이름을 부분으로 분할 한 후 다음 조회를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="c557758565df392f118d1a6d67a3ecbe6e4c74e8" translate="yes" xml:space="preserve">
          <source>When in autocommit mode and outside of an &lt;a href=&quot;#django.db.transaction.atomic&quot;&gt;&lt;code&gt;atomic()&lt;/code&gt;&lt;/a&gt; block, the function will run immediately, not on commit.</source>
          <target state="translated">자동 커밋 모드에 있고 &lt;a href=&quot;#django.db.transaction.atomic&quot;&gt; &lt;code&gt;atomic()&lt;/code&gt; &lt;/a&gt; 블록 외부에있는 경우, 함수는 커밋이 아닌 즉시 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="e643c97aaaf745dee53483cffd548b81b20b2ce0" translate="yes" xml:space="preserve">
          <source>When inserting different pairs of objects into &lt;a href=&quot;../../ref/models/fields#django.db.models.ManyToManyField&quot;&gt;&lt;code&gt;ManyToManyField&lt;/code&gt;&lt;/a&gt; or when the custom &lt;a href=&quot;../../ref/models/fields#django.db.models.ManyToManyField.through&quot;&gt;&lt;code&gt;through&lt;/code&gt;&lt;/a&gt; table is defined, use &lt;a href=&quot;../../ref/models/querysets#django.db.models.query.QuerySet.bulk_create&quot;&gt;&lt;code&gt;bulk_create()&lt;/code&gt;&lt;/a&gt; method to reduce the number of SQL queries. For example:</source>
          <target state="translated">&lt;a href=&quot;../../ref/models/fields#django.db.models.ManyToManyField&quot;&gt; &lt;code&gt;ManyToManyField&lt;/code&gt; 에&lt;/a&gt; 다른 오브젝트 쌍을 삽입 하거나 사용자 정의 &lt;a href=&quot;../../ref/models/fields#django.db.models.ManyToManyField.through&quot;&gt; &lt;code&gt;through&lt;/code&gt; &lt;/a&gt; 테이블이 정의 된 경우 &lt;a href=&quot;../../ref/models/querysets#django.db.models.query.QuerySet.bulk_create&quot;&gt; &lt;code&gt;bulk_create()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 SQL 쿼리 수를 줄이십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="faa578905e0cde99e4821dc6e2893a874507c6d1" translate="yes" xml:space="preserve">
          <source>When inserting objects into &lt;a href=&quot;../../ref/models/fields#django.db.models.ManyToManyField&quot;&gt;&lt;code&gt;ManyToManyFields&lt;/code&gt;&lt;/a&gt;, use &lt;a href=&quot;../../ref/models/relations#django.db.models.fields.related.RelatedManager.add&quot;&gt;&lt;code&gt;add()&lt;/code&gt;&lt;/a&gt; with multiple objects to reduce the number of SQL queries. For example:</source>
          <target state="translated">물체를 삽입 할 때 &lt;a href=&quot;../../ref/models/fields#django.db.models.ManyToManyField&quot;&gt; &lt;code&gt;ManyToManyFields&lt;/code&gt; &lt;/a&gt; , 사용 &lt;a href=&quot;../../ref/models/relations#django.db.models.fields.related.RelatedManager.add&quot;&gt; &lt;code&gt;add()&lt;/code&gt; &lt;/a&gt; 여러 개체와 함께 SQL 쿼리의 수를 줄일 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9e3d2548d2d0f6c30d3418d31de7d1e55bd04e17" translate="yes" xml:space="preserve">
          <source>When installing Python on Windows, make sure you check the option &amp;ldquo;Add python.exe to Path&amp;rdquo;, so that it is always available on the command line.</source>
          <target state="translated">Windows에 Python을 설치할 때 항상 &quot;python.exe를 경로에 추가&quot;옵션을 확인하여 명령 행에서 항상 사용할 수 있도록하십시오.</target>
        </trans-unit>
        <trans-unit id="107de19ba0dc210be75fd5bab7ce5e18a0052427" translate="yes" xml:space="preserve">
          <source>When installing from source on UNIX and GNU/Linux systems, please follow the installation instructions carefully, and install the libraries in the given order. If using MySQL or Oracle as the spatial database, only GEOS is required.</source>
          <target state="translated">UNIX 및 GNU / Linux 시스템의 소스에서 설치할 때 설치 지시 사항을주의하여 따르고 지정된 순서로 라이브러리를 설치하십시오. 공간 데이터베이스로 MySQL 또는 Oracle을 사용하는 경우 GEOS 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0cb6cf870e8e9a1ccdcbe16722c8d954773b0b69" translate="yes" xml:space="preserve">
          <source>When instantiating an &lt;code&gt;Engine&lt;/code&gt; all arguments must be passed as keyword arguments:</source>
          <target state="translated">&lt;code&gt;Engine&lt;/code&gt; 인스턴스화 할 때 모든 인수는 키워드 인수로 전달되어야합니다.</target>
        </trans-unit>
        <trans-unit id="0815a0ed8bbb0b090f447f1490d9d1620b8258e4" translate="yes" xml:space="preserve">
          <source>When invoking a management command.</source>
          <target state="translated">관리 명령을 호출 할 때.</target>
        </trans-unit>
        <trans-unit id="795cabcf0b9ec9c90102f5c511b1c5012e5a8949" translate="yes" xml:space="preserve">
          <source>When it&amp;rsquo;s enabled, two users accessing the same content may see dates, times and numbers formatted in different ways, depending on the formats for their current locale.</source>
          <target state="translated">사용하도록 설정하면 동일한 콘텐츠에 액세스하는 두 명의 사용자가 현재 로캘의 형식에 따라 다른 방식으로 날짜, 시간 및 숫자 형식을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9999bf655fc678d33ba1fd0ba46531c92a1eb59" translate="yes" xml:space="preserve">
          <source>When loading data, &lt;a href=&quot;#django.db.models.Field.from_db_value&quot;&gt;&lt;code&gt;from_db_value()&lt;/code&gt;&lt;/a&gt; is used:</source>
          <target state="translated">데이터를로드 할 때 &lt;a href=&quot;#django.db.models.Field.from_db_value&quot;&gt; &lt;code&gt;from_db_value()&lt;/code&gt; &lt;/a&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b58436e4c6d75b33bc5ed1c188a3172355b5fac4" translate="yes" xml:space="preserve">
          <source>When looking for which lookups are allowable after the &lt;code&gt;Transform&lt;/code&gt; has been applied, Django uses the &lt;code&gt;output_field&lt;/code&gt; attribute. We didn&amp;rsquo;t need to specify this here as it didn&amp;rsquo;t change, but supposing we were applying &lt;code&gt;AbsoluteValue&lt;/code&gt; to some field which represents a more complex type (for example a point relative to an origin, or a complex number) then we may have wanted to specify that the transform returns a &lt;code&gt;FloatField&lt;/code&gt; type for further lookups. This can be done by adding an &lt;code&gt;output_field&lt;/code&gt; attribute to the transform:</source>
          <target state="translated">&lt;code&gt;Transform&lt;/code&gt; 이 적용된 후 허용 가능한 조회를 찾을 때 Django는 &lt;code&gt;output_field&lt;/code&gt; 속성을 사용 합니다. 여기서는 변경되지 않았으므로 여기에 지정할 필요는 없지만 좀 더 복잡한 유형 (예 : 원점 또는 복소수에 대한 점)을 나타내는 일부 필드에 &lt;code&gt;AbsoluteValue&lt;/code&gt; 를 적용한다고 가정 하면 변환 이 추가 조회를 위해 &lt;code&gt;FloatField&lt;/code&gt; 유형을 리턴하도록 지정하려고했습니다 . &lt;code&gt;output_field&lt;/code&gt; 속성을 변환 에 추가하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4392f60737f8c65db01e29f3b7c42b4677c2c3bc" translate="yes" xml:space="preserve">
          <source>When looping over the checkboxes, the &lt;code&gt;label&lt;/code&gt; and &lt;code&gt;input&lt;/code&gt; tags include &lt;code&gt;for&lt;/code&gt; and &lt;code&gt;id&lt;/code&gt; attributes, respectively. Each checkbox has an &lt;code&gt;id_for_label&lt;/code&gt; attribute to output the element&amp;rsquo;s ID.</source>
          <target state="translated">확인란을 반복 할 때 &lt;code&gt;label&lt;/code&gt; 및 &lt;code&gt;input&lt;/code&gt; 태그에는 각각 &lt;code&gt;for&lt;/code&gt; 및 &lt;code&gt;id&lt;/code&gt; 속성이 포함 됩니다. 각 확인란에는 요소의 ID를 출력하기 위한 &lt;code&gt;id_for_label&lt;/code&gt; 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="870628b6fbeb1390517e73a74ad3698d31f3659d" translate="yes" xml:space="preserve">
          <source>When looping over the radio buttons, the &lt;code&gt;label&lt;/code&gt; and &lt;code&gt;input&lt;/code&gt; tags include &lt;code&gt;for&lt;/code&gt; and &lt;code&gt;id&lt;/code&gt; attributes, respectively. Each radio button has an &lt;code&gt;id_for_label&lt;/code&gt; attribute to output the element&amp;rsquo;s ID.</source>
          <target state="translated">단일 선택 단추를 반복 할 때 &lt;code&gt;label&lt;/code&gt; 및 &lt;code&gt;input&lt;/code&gt; 태그에는 각각 &lt;code&gt;for&lt;/code&gt; 및 &lt;code&gt;id&lt;/code&gt; 속성이 포함 됩니다. 각 라디오 버튼에는 요소의 ID를 출력하기 위한 &lt;code&gt;id_for_label&lt;/code&gt; 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="40d1631cc126c8365afcbb75b7556476d4380faf" translate="yes" xml:space="preserve">
          <source>When methods return naive &lt;code&gt;datetime&lt;/code&gt; objects, the effective timezone used will be the current value of &lt;code&gt;os.environ['TZ']&lt;/code&gt;; note that this is usually set from Django&amp;rsquo;s &lt;a href=&quot;../settings#std:setting-TIME_ZONE&quot;&gt;&lt;code&gt;TIME_ZONE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">메소드가 순진한 &lt;code&gt;datetime&lt;/code&gt; 객체를 반환하면 사용 된 유효 시간대는 &lt;code&gt;os.environ['TZ']&lt;/code&gt; 의 현재 값이됩니다 . 이것은 일반적으로 Django의 &lt;a href=&quot;../settings#std:setting-TIME_ZONE&quot;&gt; &lt;code&gt;TIME_ZONE&lt;/code&gt; &lt;/a&gt; 에서 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="0e5fe2b100ff5188a0a5930e25fbe9122ecb9a42" translate="yes" xml:space="preserve">
          <source>When naming URL patterns, choose names that are unlikely to clash with other applications&amp;rsquo; choice of names. If you call your URL pattern &lt;code&gt;comment&lt;/code&gt; and another application does the same thing, the URL that &lt;a href=&quot;../../ref/urlresolvers#django.urls.reverse&quot;&gt;&lt;code&gt;reverse()&lt;/code&gt;&lt;/a&gt; finds depends on whichever pattern is last in your project&amp;rsquo;s &lt;code&gt;urlpatterns&lt;/code&gt; list.</source>
          <target state="translated">URL 패턴의 이름을 지정할 때 다른 응용 프로그램의 이름 선택과 충돌하지 않는 이름을 선택하십시오. URL 패턴 &lt;code&gt;comment&lt;/code&gt; 을 호출 하고 다른 응용 프로그램이 동일한 작업을 수행하는 경우 &lt;a href=&quot;../../ref/urlresolvers#django.urls.reverse&quot;&gt; &lt;code&gt;reverse()&lt;/code&gt; &lt;/a&gt; 가 찾은 URL은 프로젝트의 &lt;code&gt;urlpatterns&lt;/code&gt; 목록 에서 마지막 패턴에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="06033c285fc959f0b03642505215cc4952f049c4" translate="yes" xml:space="preserve">
          <source>When nesting &lt;code&gt;ArrayField&lt;/code&gt;, whether you use the &lt;code&gt;size&lt;/code&gt; parameter or not, PostgreSQL requires that the arrays are rectangular:</source>
          <target state="translated">&lt;code&gt;ArrayField&lt;/code&gt; 를 중첩 할 때 &lt;code&gt;size&lt;/code&gt; 매개 변수 사용 여부에 관계없이 PostgreSQL에서는 배열이 직사각형 이어야 합니다 .</target>
        </trans-unit>
        <trans-unit id="7eb30f96869e1d16507b694cc7eab76d349dc579" translate="yes" xml:space="preserve">
          <source>When overriding &lt;a href=&quot;#django.contrib.admin.ModelAdmin.save_model&quot;&gt;&lt;code&gt;ModelAdmin.save_model()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#django.contrib.admin.ModelAdmin.delete_model&quot;&gt;&lt;code&gt;ModelAdmin.delete_model()&lt;/code&gt;&lt;/a&gt;, your code must save/delete the object. They aren&amp;rsquo;t meant for veto purposes, rather they allow you to perform extra operations.</source>
          <target state="translated">&lt;a href=&quot;#django.contrib.admin.ModelAdmin.save_model&quot;&gt; &lt;code&gt;ModelAdmin.save_model()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#django.contrib.admin.ModelAdmin.delete_model&quot;&gt; &lt;code&gt;ModelAdmin.delete_model()&lt;/code&gt; &lt;/a&gt; 재정의하는 경우 코드는 객체를 저장 / 삭제해야합니다. 거부권을 부여하기위한 것이 아니라 추가 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd8d28225a4e8254dd7eeefe85e1d12fda404710" translate="yes" xml:space="preserve">
          <source>When overriding methods on &lt;code&gt;InlineFormSet&lt;/code&gt;, you should subclass &lt;a href=&quot;#django.forms.models.BaseInlineFormSet&quot;&gt;&lt;code&gt;BaseInlineFormSet&lt;/code&gt;&lt;/a&gt; rather than &lt;a href=&quot;#django.forms.models.BaseModelFormSet&quot;&gt;&lt;code&gt;BaseModelFormSet&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;InlineFormSet&lt;/code&gt; 에서 메소드를 재정의 하는 경우 &lt;a href=&quot;#django.forms.models.BaseModelFormSet&quot;&gt; &lt;code&gt;BaseModelFormSet&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;#django.forms.models.BaseInlineFormSet&quot;&gt; &lt;code&gt;BaseInlineFormSet&lt;/code&gt; &lt;/a&gt; 을 서브 클래 싱해야합니다 .</target>
        </trans-unit>
        <trans-unit id="dd49030b94b8233bc17c651f028b779552c6de15" translate="yes" xml:space="preserve">
          <source>When overriding settings, make sure to handle the cases in which your app&amp;rsquo;s code uses a cache or similar feature that retains state even if the setting is changed. Django provides the &lt;a href=&quot;../../ref/signals#django.test.signals.setting_changed&quot;&gt;&lt;code&gt;django.test.signals.setting_changed&lt;/code&gt;&lt;/a&gt; signal that lets you register callbacks to clean up and otherwise reset state when settings are changed.</source>
          <target state="translated">설정을 재정의하는 경우 설정이 변경 되어도 앱 코드가 상태를 유지하는 캐시 또는 유사한 기능을 사용하는 경우를 처리해야합니다. Django는 &lt;a href=&quot;../../ref/signals#django.test.signals.setting_changed&quot;&gt; &lt;code&gt;django.test.signals.setting_changed&lt;/code&gt; &lt;/a&gt; 신호를 제공하여 설정이 변경 될 때 콜백을 등록하여 정리 및 상태 재설정을 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="b5a667c4fe16280d0b8e4644f4bd5226d5d8911c" translate="yes" xml:space="preserve">
          <source>When performing a query on a string type, but with an integer value, MySQL will coerce the types of all values in the table to an integer before performing the comparison. If your table contains the values &lt;code&gt;'abc'&lt;/code&gt;, &lt;code&gt;'def'&lt;/code&gt; and you query for &lt;code&gt;WHERE mycolumn=0&lt;/code&gt;, both rows will match. Similarly, &lt;code&gt;WHERE mycolumn=1&lt;/code&gt; will match the value &lt;code&gt;'abc1'&lt;/code&gt;. Therefore, string type fields included in Django will always cast the value to a string before using it in a query.</source>
          <target state="translated">문자열 유형에 대해 쿼리를 수행하지만 정수 값을 사용하는 경우 MySQL은 비교를 수행하기 전에 테이블의 모든 값 유형을 정수로 강제 변환합니다. 테이블에 &lt;code&gt;'abc'&lt;/code&gt; , &lt;code&gt;'def'&lt;/code&gt; 값이 포함되어 있고 &lt;code&gt;WHERE mycolumn=0&lt;/code&gt; 을 쿼리하면 두 행이 모두 일치합니다. 마찬가지로, &lt;code&gt;WHERE mycolumn=1&lt;/code&gt; 은 &lt;code&gt;'abc1'&lt;/code&gt; 값과 일치합니다 . 따라서 Django에 포함 된 문자열 유형 필드는 값을 쿼리에 사용하기 전에 항상 문자열로 캐스트합니다.</target>
        </trans-unit>
        <trans-unit id="f41484ab1fa1f63afeea48eed18424188496a529" translate="yes" xml:space="preserve">
          <source>When planning your &lt;a href=&quot;../ref/models/fields#django.db.models.Field&quot;&gt;&lt;code&gt;Field&lt;/code&gt;&lt;/a&gt; subclass, first give some thought to which existing &lt;a href=&quot;../ref/models/fields#django.db.models.Field&quot;&gt;&lt;code&gt;Field&lt;/code&gt;&lt;/a&gt; class your new field is most similar to. Can you subclass an existing Django field and save yourself some work? If not, you should subclass the &lt;a href=&quot;../ref/models/fields#django.db.models.Field&quot;&gt;&lt;code&gt;Field&lt;/code&gt;&lt;/a&gt; class, from which everything is descended.</source>
          <target state="translated">&lt;a href=&quot;../ref/models/fields#django.db.models.Field&quot;&gt; &lt;code&gt;Field&lt;/code&gt; &lt;/a&gt; 서브 클래스를 계획 할 때 , 먼저 새로운 Field가 가장 유사한 기존 &lt;a href=&quot;../ref/models/fields#django.db.models.Field&quot;&gt; &lt;code&gt;Field&lt;/code&gt; &lt;/a&gt; 클래스에 대해 생각해 보십시오. 기존 Django 필드를 서브 클래 싱하고 작업을 저장할 수 있습니까? 그렇지 않은 경우 모든 것이 내려진 &lt;a href=&quot;../ref/models/fields#django.db.models.Field&quot;&gt; &lt;code&gt;Field&lt;/code&gt; &lt;/a&gt; 클래스를 서브 클래 싱해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0e31bd6aa0a9ff46edf926454409c0907eb204b0" translate="yes" xml:space="preserve">
          <source>When querying, &lt;a href=&quot;#django.db.models.Field.get_db_prep_value&quot;&gt;&lt;code&gt;get_db_prep_value()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#django.db.models.Field.get_prep_value&quot;&gt;&lt;code&gt;get_prep_value()&lt;/code&gt;&lt;/a&gt; are used:</source>
          <target state="translated">조회 할 때 &lt;a href=&quot;#django.db.models.Field.get_db_prep_value&quot;&gt; &lt;code&gt;get_db_prep_value()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#django.db.models.Field.get_prep_value&quot;&gt; &lt;code&gt;get_prep_value()&lt;/code&gt; &lt;/a&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0188e409f61b51913c9abffaede4af62ec49b3df" translate="yes" xml:space="preserve">
          <source>When reading from &lt;code&gt;stdin&lt;/code&gt;, the &lt;a href=&quot;#cmdoption-loaddata-format&quot;&gt;&lt;code&gt;--format&lt;/code&gt;&lt;/a&gt; option is required to specify the &lt;a href=&quot;../topics/serialization#serialization-formats&quot;&gt;serialization format&lt;/a&gt; of the input (e.g., &lt;code&gt;json&lt;/code&gt; or &lt;code&gt;xml&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;stdin&lt;/code&gt; 에서 읽을 때 &lt;a href=&quot;#cmdoption-loaddata-format&quot;&gt; &lt;code&gt;--format&lt;/code&gt; &lt;/a&gt; 옵션은 입력 의 &lt;a href=&quot;../topics/serialization#serialization-formats&quot;&gt;직렬화 형식&lt;/a&gt; (예 : &lt;code&gt;json&lt;/code&gt; 또는 &lt;code&gt;xml&lt;/code&gt; ) 을 지정하는 데 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="761e336ae74f9e6660293806ca5fc08783fafd7f" translate="yes" xml:space="preserve">
          <source>When referencing relational fields such as &lt;code&gt;ForeignKey&lt;/code&gt;, &lt;code&gt;F()&lt;/code&gt; returns the primary key value rather than a model instance:</source>
          <target state="translated">같은 관계형 필드를 참조 할 때 &lt;code&gt;ForeignKey&lt;/code&gt; , &lt;code&gt;F()&lt;/code&gt; 모델 인스턴스가 아닌 기본 키 값을 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="07c490a14291e9e945c2248d2d2d4825be1a6f30" translate="yes" xml:space="preserve">
          <source>When removing different pairs of objects from &lt;a href=&quot;../../ref/models/fields#django.db.models.ManyToManyField&quot;&gt;&lt;code&gt;ManyToManyFields&lt;/code&gt;&lt;/a&gt;, use &lt;a href=&quot;../../ref/models/querysets#django.db.models.query.QuerySet.delete&quot;&gt;&lt;code&gt;delete()&lt;/code&gt;&lt;/a&gt; on a &lt;a href=&quot;../../ref/models/querysets#django.db.models.Q&quot;&gt;&lt;code&gt;Q&lt;/code&gt;&lt;/a&gt; expression with multiple &lt;a href=&quot;../../ref/models/fields#django.db.models.ManyToManyField.through&quot;&gt;&lt;code&gt;through&lt;/code&gt;&lt;/a&gt; model instances to reduce the number of SQL queries. For example:</source>
          <target state="translated">에서 객체의 다른 쌍을 제거 할 때 &lt;a href=&quot;../../ref/models/fields#django.db.models.ManyToManyField&quot;&gt; &lt;code&gt;ManyToManyFields&lt;/code&gt; 을&lt;/a&gt; 사용 &lt;a href=&quot;../../ref/models/querysets#django.db.models.query.QuerySet.delete&quot;&gt; &lt;code&gt;delete()&lt;/code&gt; &lt;/a&gt; A의 &lt;a href=&quot;../../ref/models/querysets#django.db.models.Q&quot;&gt; &lt;code&gt;Q&lt;/code&gt; 의&lt;/a&gt; 복수와 표현 &lt;a href=&quot;../../ref/models/fields#django.db.models.ManyToManyField.through&quot;&gt; &lt;code&gt;through&lt;/code&gt; &lt;/a&gt; SQL 쿼리의 수를 줄이기 위해 모델 인스턴스. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eaa83ceed94b004ec32e5382ced54334f70df09e" translate="yes" xml:space="preserve">
          <source>When removing objects from &lt;a href=&quot;../../ref/models/fields#django.db.models.ManyToManyField&quot;&gt;&lt;code&gt;ManyToManyFields&lt;/code&gt;&lt;/a&gt;, use &lt;a href=&quot;../../ref/models/relations#django.db.models.fields.related.RelatedManager.remove&quot;&gt;&lt;code&gt;remove()&lt;/code&gt;&lt;/a&gt; with multiple objects to reduce the number of SQL queries. For example:</source>
          <target state="translated">&lt;a href=&quot;../../ref/models/fields#django.db.models.ManyToManyField&quot;&gt; &lt;code&gt;ManyToManyFields&lt;/code&gt; &lt;/a&gt; 에서 오브젝트를 제거 할 때 여러 오브젝트와 함께 &lt;a href=&quot;../../ref/models/relations#django.db.models.fields.related.RelatedManager.remove&quot;&gt; &lt;code&gt;remove()&lt;/code&gt; &lt;/a&gt; 를 사용하여 SQL 쿼리 수를 줄이십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fdb8259bf4312bcc56e6be69aee68359ea8104ec" translate="yes" xml:space="preserve">
          <source>When rendering a template &lt;a href=&quot;../../ref/templates/api#django.template.RequestContext&quot;&gt;&lt;code&gt;RequestContext&lt;/code&gt;&lt;/a&gt;, the currently logged-in user, either a &lt;a href=&quot;../../ref/contrib/auth#django.contrib.auth.models.User&quot;&gt;&lt;code&gt;User&lt;/code&gt;&lt;/a&gt; instance or an &lt;a href=&quot;../../ref/contrib/auth#django.contrib.auth.models.AnonymousUser&quot;&gt;&lt;code&gt;AnonymousUser&lt;/code&gt;&lt;/a&gt; instance, is stored in the template variable &lt;code&gt;{{ user }}&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;../../ref/templates/api#django.template.RequestContext&quot;&gt; &lt;code&gt;RequestContext&lt;/code&gt; &lt;/a&gt; 템플리트를 렌더링 할 때 현재 로그인 한 &lt;a href=&quot;../../ref/contrib/auth#django.contrib.auth.models.User&quot;&gt; &lt;code&gt;User&lt;/code&gt; &lt;/a&gt; 인스턴스 또는 &lt;a href=&quot;../../ref/contrib/auth#django.contrib.auth.models.AnonymousUser&quot;&gt; &lt;code&gt;AnonymousUser&lt;/code&gt; &lt;/a&gt; 인스턴스)는 템플리트 변수 &lt;code&gt;{{ user }}&lt;/code&gt; 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="808d315e00ac7185d287c64ce35e3cc3f5fd0df6" translate="yes" xml:space="preserve">
          <source>When rendering an object in Django, we generally:</source>
          <target state="translated">Django에서 객체를 렌더링 할 때 일반적으로 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="856789f04d4c60c3bc73952216dc19bd3b0d46b0" translate="yes" xml:space="preserve">
          <source>When reopening a file, &lt;code&gt;mode&lt;/code&gt; will override whatever mode the file was originally opened with; &lt;code&gt;None&lt;/code&gt; means to reopen with the original mode.</source>
          <target state="translated">파일을 다시 열면 mode는 파일이 처음에 열린 &lt;code&gt;mode&lt;/code&gt; 를 무시합니다. &lt;code&gt;None&lt;/code&gt; 은 원래 모드로 다시 여는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6e4af341c64d5e72990d2ecd907647bc3fc5b380" translate="yes" xml:space="preserve">
          <source>When retrieving pages, remember to specify the &lt;em&gt;path&lt;/em&gt; of the URL, not the whole domain. For example, this is correct:</source>
          <target state="translated">페이지를 검색 할 때는 전체 도메인이 아닌 URL &lt;em&gt;경로&lt;/em&gt; 를 지정해야 합니다. 예를 들어 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="14b32ffa98f1f2260ab494309b3077cd8a2888a3" translate="yes" xml:space="preserve">
          <source>When run interactively, this command will prompt for a password for the new superuser account. When run non-interactively, you can provide a password by setting the &lt;code&gt;DJANGO_SUPERUSER_PASSWORD&lt;/code&gt; environment variable. Otherwise, no password will be set, and the superuser account will not be able to log in until a password has been manually set for it.</source>
          <target state="translated">대화식으로 실행하면이 명령은 새 수퍼 유저 계정의 비밀번호를 묻습니다. 비 대화식으로 실행될 때 &lt;code&gt;DJANGO_SUPERUSER_PASSWORD&lt;/code&gt; 환경 변수를 설정하여 비밀번호를 제공 할 수 있습니다 . 그렇지 않으면 암호가 설정되지 않고 암호를 수동으로 설정해야 슈퍼 유저 계정에 로그인 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5d20b8654cd731328d005adb0fca0735b38b648e" translate="yes" xml:space="preserve">
          <source>When running &lt;a href=&quot;../ref/django-admin#django-admin-loaddata&quot;&gt;&lt;code&gt;manage.py loaddata&lt;/code&gt;&lt;/a&gt;, you can also specify a path to a fixture file, which overrides searching the usual directories.</source>
          <target state="translated">&lt;a href=&quot;../ref/django-admin#django-admin-loaddata&quot;&gt; &lt;code&gt;manage.py loaddata&lt;/code&gt; 를&lt;/a&gt; 실행할 때 일반적인 디렉토리 검색보다 우선하는 조명기 파일의 경로를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff07ba123012975f92e072d09c9476492136d884" translate="yes" xml:space="preserve">
          <source>When running &lt;code&gt;migrate&lt;/code&gt;, an &lt;code&gt;ORA-06552&lt;/code&gt; error may be encountered if certain Oracle keywords are used as the name of a model field or the value of a &lt;code&gt;db_column&lt;/code&gt; option. Django quotes all identifiers used in queries to prevent most such problems, but this error can still occur when an Oracle datatype is used as a column name. In particular, take care to avoid using the names &lt;code&gt;date&lt;/code&gt;, &lt;code&gt;timestamp&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt; or &lt;code&gt;float&lt;/code&gt; as a field name.</source>
          <target state="translated">실행하는 경우 &lt;code&gt;migrate&lt;/code&gt; , &lt;code&gt;ORA-06552&lt;/code&gt; 특정 오라클 키워드가 모델 필드의 이름이나 값으로 사용하는 경우 오류가 발생할 수 있습니다 &lt;code&gt;db_column&lt;/code&gt; 의 옵션을 선택합니다. Django는 대부분의 이러한 문제를 방지하기 위해 쿼리에 사용 된 모든 식별자를 인용하지만 Oracle 데이터 유형이 열 이름으로 사용될 때이 오류가 계속 발생할 수 있습니다. 특히, &lt;code&gt;date&lt;/code&gt; , &lt;code&gt;timestamp&lt;/code&gt; , &lt;code&gt;number&lt;/code&gt; 또는 &lt;code&gt;float&lt;/code&gt; 이름을 필드 이름으로 사용하지 않도록주의하십시오 .</target>
        </trans-unit>
        <trans-unit id="721ec4a813cff227ffc21e0de2f449d9b7f009ca" translate="yes" xml:space="preserve">
          <source>When running an HTTP server via Django&amp;rsquo;s WSGI support.</source>
          <target state="translated">Django의 WSGI 지원을 통해 HTTP 서버를 실행할 때.</target>
        </trans-unit>
        <trans-unit id="c37f24c30e901c673348f951eb749ccd2b3d1124" translate="yes" xml:space="preserve">
          <source>When running concurrent loads, database transactions from different sessions (say, separate threads handling different requests) may interact with each other. These interactions are affected by each session&amp;rsquo;s &lt;a href=&quot;https://dev.mysql.com/doc/refman/en/innodb-transaction-isolation-levels.html&quot;&gt;transaction isolation level&lt;/a&gt;. You can set a connection&amp;rsquo;s isolation level with an &lt;code&gt;'isolation_level'&lt;/code&gt; entry in the &lt;a href=&quot;settings#std:setting-OPTIONS&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; part of your database configuration in &lt;a href=&quot;settings#std:setting-DATABASES&quot;&gt;&lt;code&gt;DATABASES&lt;/code&gt;&lt;/a&gt;. Valid values for this entry are the four standard isolation levels:</source>
          <target state="translated">동시로드를 실행하는 경우 다른 세션의 데이터베이스 트랜잭션 (예 : 다른 요청을 처리하는 별도의 스레드)이 서로 상호 작용할 수 있습니다. 이러한 상호 작용은 각 세션의 &lt;a href=&quot;https://dev.mysql.com/doc/refman/en/innodb-transaction-isolation-levels.html&quot;&gt;트랜잭션 격리 수준에&lt;/a&gt; 영향을받습니다 . &lt;a href=&quot;settings#std:setting-DATABASES&quot;&gt; &lt;code&gt;DATABASES&lt;/code&gt; &lt;/a&gt; 의 데이터베이스 구성에서 &lt;a href=&quot;settings#std:setting-OPTIONS&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt; 부분에 있는 &lt;code&gt;'isolation_level'&lt;/code&gt; 항목을 사용하여 연결의 격리 레벨을 설정할 수 있습니다 . 이 항목에 유효한 값은 네 가지 표준 격리 수준입니다.</target>
        </trans-unit>
        <trans-unit id="294a23b7523ebacf26bdc672c5ce4ecd9bfa6658" translate="yes" xml:space="preserve">
          <source>When running tests that use actual HTTP requests instead of the built-in testing client (i.e. when using the built-in &lt;a href=&quot;../../topics/testing/tools#django.test.LiveServerTestCase&quot;&gt;&lt;code&gt;LiveServerTestCase&lt;/code&gt;&lt;/a&gt;) the static assets need to be served along the rest of the content so the test environment reproduces the real one as faithfully as possible, but &lt;code&gt;LiveServerTestCase&lt;/code&gt; has only very basic static file-serving functionality: It doesn&amp;rsquo;t know about the finders feature of the &lt;code&gt;staticfiles&lt;/code&gt; application and assumes the static content has already been collected under &lt;a href=&quot;../../ref/settings#std:setting-STATIC_ROOT&quot;&gt;&lt;code&gt;STATIC_ROOT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">내장 테스트 클라이언트 대신 실제 HTTP 요청을 사용하는 테스트를 실행하는 경우 (예 : 내장 &lt;a href=&quot;../../topics/testing/tools#django.test.LiveServerTestCase&quot;&gt; &lt;code&gt;LiveServerTestCase&lt;/code&gt; 를&lt;/a&gt; 사용하는 경우 ) 테스트 환경이 실제 컨텐츠를 충실하게 재현 할 수 있도록 정적 컨텐츠를 나머지 컨텐츠와 함께 제공해야합니다. 가능하지만 &lt;code&gt;LiveServerTestCase&lt;/code&gt; 에는 매우 기본적인 정적 파일 서비스 기능 만 있습니다. 정적 파일 응용 프로그램 의 파인더 기능에 대해 &lt;code&gt;staticfiles&lt;/code&gt; 정적 컨텐츠가 이미 &lt;a href=&quot;../../ref/settings#std:setting-STATIC_ROOT&quot;&gt; &lt;code&gt;STATIC_ROOT&lt;/code&gt; &lt;/a&gt; 에 수집 된 것으로 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="0ed1aad3a46b86d1700ecfe2911963f054fdf21d" translate="yes" xml:space="preserve">
          <source>When saving a model fetched through deferred model loading (&lt;a href=&quot;querysets#django.db.models.query.QuerySet.only&quot;&gt;&lt;code&gt;only()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;querysets#django.db.models.query.QuerySet.defer&quot;&gt;&lt;code&gt;defer()&lt;/code&gt;&lt;/a&gt;) only the fields loaded from the DB will get updated. In effect there is an automatic &lt;code&gt;update_fields&lt;/code&gt; in this case. If you assign or change any deferred field value, the field will be added to the updated fields.</source>
          <target state="translated">지연된 모델로드 ( &lt;a href=&quot;querysets#django.db.models.query.QuerySet.only&quot;&gt; &lt;code&gt;only()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;querysets#django.db.models.query.QuerySet.defer&quot;&gt; &lt;code&gt;defer()&lt;/code&gt; &lt;/a&gt; )를 통해 가져온 모델을 저장 하면 DB에서로드 된 필드 만 업데이트됩니다. &lt;code&gt;update_fields&lt;/code&gt; 경우 자동 update_fields 가 있습니다. 지연된 필드 값을 지정하거나 변경하면 해당 필드가 업데이트 된 필드에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="9ebf387588ca59c2753af79a53e5657c29443130" translate="yes" xml:space="preserve">
          <source>When saving, &lt;a href=&quot;#django.db.models.Field.pre_save&quot;&gt;&lt;code&gt;pre_save()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#django.db.models.Field.get_db_prep_save&quot;&gt;&lt;code&gt;get_db_prep_save()&lt;/code&gt;&lt;/a&gt; are used:</source>
          <target state="translated">저장할 때 &lt;a href=&quot;#django.db.models.Field.pre_save&quot;&gt; &lt;code&gt;pre_save()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#django.db.models.Field.get_db_prep_save&quot;&gt; &lt;code&gt;get_db_prep_save()&lt;/code&gt; &lt;/a&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="51eae9a99f047d4352d7ea734c0fc842bd23b0a2" translate="yes" xml:space="preserve">
          <source>When serializing an aware datetime, the UTC offset is included, like this:</source>
          <target state="translated">인식 날짜 시간을 직렬화 할 때 다음과 같이 UTC 오프셋이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1ae29d936e6f8d7922fe5d8e1cd4ca8cd697ab5a" translate="yes" xml:space="preserve">
          <source>When sessions are saved</source>
          <target state="translated">세션이 저장 될 때</target>
        </trans-unit>
        <trans-unit id="752f427eacd231b342cb2bd792e22d3bfb22b4c0" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;False&lt;/code&gt;, the &lt;a href=&quot;#django.forms.Field.required&quot;&gt;&lt;code&gt;Field.required&lt;/code&gt;&lt;/a&gt; attribute can be set to &lt;code&gt;False&lt;/code&gt; for individual fields to make them optional. If no value is supplied for a required field, an &lt;code&gt;incomplete&lt;/code&gt; validation error will be raised.</source>
          <target state="translated">로 설정하면 &lt;code&gt;False&lt;/code&gt; 의 &lt;a href=&quot;#django.forms.Field.required&quot;&gt; &lt;code&gt;Field.required&lt;/code&gt; &lt;/a&gt; 속성을 설정할 수 있습니다 &lt;code&gt;False&lt;/code&gt; 개별 필드 그들이 선택하게하기 위해. 필수 필드에 값이 제공되지 않으면 &lt;code&gt;incomplete&lt;/code&gt; 유효성 검사 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="027d0a97bdc9c261a0c19725496fd3cb2bf2cc9c" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;True&lt;/code&gt; (the default), required form fields will have the &lt;code&gt;required&lt;/code&gt; HTML attribute.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; (기본값)로 설정하면 필수 양식 필드에 &lt;code&gt;required&lt;/code&gt; HTML 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0d4e85359911049c1658d23dab7c3fa4d7ab4e7" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;True&lt;/code&gt;, if the request URL does not match any of the patterns in the URLconf and it doesn&amp;rsquo;t end in a slash, an HTTP redirect is issued to the same URL with a slash appended. Note that the redirect may cause any data submitted in a POST request to be lost.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 로 설정되면 요청 URL이 URLconf의 패턴과 일치하지 않고 슬래시로 끝나지 않으면 슬래시가 추가 된 동일한 URL로 HTTP 리디렉션이 발행됩니다. 리디렉션으로 인해 POST 요청에 제출 된 모든 데이터가 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bfabba073780370d551059c2da67193915c5482" translate="yes" xml:space="preserve">
          <source>When set, the given fields will use a bit of JavaScript to populate from the fields assigned. The main use for this functionality is to automatically generate the value for &lt;code&gt;SlugField&lt;/code&gt; fields from one or more other fields. The generated value is produced by concatenating the values of the source fields, and then by transforming that result into a valid slug (e.g. substituting dashes for spaces; lowercasing ASCII letters; and removing various English stop words such as &amp;lsquo;a&amp;rsquo;, &amp;lsquo;an&amp;rsquo;, &amp;lsquo;as&amp;rsquo;, and similar).</source>
          <target state="translated">설정하면 지정된 필드는 약간의 JavaScript를 사용하여 지정된 필드에서 채 웁니다. 이 기능의 주된 용도 는 하나 이상의 다른 필드에서 &lt;code&gt;SlugField&lt;/code&gt; 필드 의 값을 자동으로 생성하는 것 입니다. 생성 된 값은 소스 필드의 값을 연결 한 다음 그 결과를 유효한 슬러그로 변환하여 생성합니다 (예 : 공백을 대시로 대체, ASCII 문자를 줄임, 'a', 'an'과 같은 다양한 영어 중지 단어 제거) , 'as'등이 있습니다.</target>
        </trans-unit>
        <trans-unit id="be91e3ffcfb24067cff74a1c958f1030cc764fe6" translate="yes" xml:space="preserve">
          <source>When several applications provide different versions of the same resource (template, static file, management command, translation), the application listed first in &lt;a href=&quot;#std:setting-INSTALLED_APPS&quot;&gt;&lt;code&gt;INSTALLED_APPS&lt;/code&gt;&lt;/a&gt; has precedence.</source>
          <target state="translated">여러 애플리케이션이 동일한 자원의 다른 버전 (템플릿, 정적 파일, 관리 명령, 변환)을 제공하는 경우 &lt;a href=&quot;#std:setting-INSTALLED_APPS&quot;&gt; &lt;code&gt;INSTALLED_APPS&lt;/code&gt; &lt;/a&gt; 에서 첫 번째로 나열된 애플리케이션 이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="6347796946aeeedc17b3c2eefd2a1f8bc226dcdf" translate="yes" xml:space="preserve">
          <source>When somebody does a search in the admin search box, Django splits the search query into words and returns all objects that contain each of the words, case-insensitive (using the &lt;a href=&quot;../../models/querysets#std:fieldlookup-icontains&quot;&gt;&lt;code&gt;icontains&lt;/code&gt;&lt;/a&gt; lookup), where each word must be in at least one of &lt;code&gt;search_fields&lt;/code&gt;. For example, if &lt;code&gt;search_fields&lt;/code&gt; is set to &lt;code&gt;['first_name', 'last_name']&lt;/code&gt; and a user searches for &lt;code&gt;john lennon&lt;/code&gt;, Django will do the equivalent of this SQL &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">관리자 검색 창에서 누군가 검색하면 Django는 검색어를 단어로 나누고 대소 문자를 구분하지 않고 ( &lt;a href=&quot;../../models/querysets#std:fieldlookup-icontains&quot;&gt; &lt;code&gt;icontains&lt;/code&gt; &lt;/a&gt; 검색을 사용하여 ) 각 단어 를 포함하는 모든 객체를 반환합니다 . 여기서 각 단어는 적어도 하나의 &lt;code&gt;search_fields&lt;/code&gt; 에 있어야합니다. . 예를 들어 &lt;code&gt;search_fields&lt;/code&gt; 가 &lt;code&gt;['first_name', 'last_name']&lt;/code&gt; 되고 사용자가 &lt;code&gt;john lennon&lt;/code&gt; 을 검색 하면 Django는이 SQL &lt;code&gt;WHERE&lt;/code&gt; 절 과 동일한 작업을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="28da51b25107551649a5bee0b6ab20428b15fc11" translate="yes" xml:space="preserve">
          <source>When somebody requests a page from your website &amp;ndash; say, &amp;ldquo;/polls/34/&amp;rdquo;, Django will load the &lt;code&gt;mysite.urls&lt;/code&gt; Python module because it&amp;rsquo;s pointed to by the &lt;a href=&quot;../ref/settings#std:setting-ROOT_URLCONF&quot;&gt;&lt;code&gt;ROOT_URLCONF&lt;/code&gt;&lt;/a&gt; setting. It finds the variable named &lt;code&gt;urlpatterns&lt;/code&gt; and traverses the patterns in order. After finding the match at &lt;code&gt;'polls/'&lt;/code&gt;, it strips off the matching text (&lt;code&gt;&quot;polls/&quot;&lt;/code&gt;) and sends the remaining text &amp;ndash; &lt;code&gt;&quot;34/&quot;&lt;/code&gt; &amp;ndash; to the &amp;lsquo;polls.urls&amp;rsquo; URLconf for further processing. There it matches &lt;code&gt;'&amp;lt;int:question_id&amp;gt;/'&lt;/code&gt;, resulting in a call to the &lt;code&gt;detail()&lt;/code&gt; view like so:</source>
          <target state="translated">누군가가 웹 사이트에서 &quot;/ polls / 34 /&quot;와 같은 페이지를 요청하면 Django는 &lt;code&gt;mysite.urls&lt;/code&gt; Python 모듈이 &lt;a href=&quot;../ref/settings#std:setting-ROOT_URLCONF&quot;&gt; &lt;code&gt;ROOT_URLCONF&lt;/code&gt; &lt;/a&gt; 설정 에 의해 지정되어 있기 때문에이를 로드 합니다. &lt;code&gt;urlpatterns&lt;/code&gt; 라는 변수를 찾고 순서대로 패턴을 순회합니다. &lt;code&gt;'polls/'&lt;/code&gt; 에서 일치하는 것을 찾은 후에는 일치 하는 텍스트 ( &lt;code&gt;&quot;polls/&quot;&lt;/code&gt; )를 제거하고 추가 처리를 위해 나머지 텍스트 &lt;code&gt;&quot;34/&quot;&lt;/code&gt; 를 'polls.urls'URLconf로 보냅니다. &lt;code&gt;'&amp;lt;int:question_id&amp;gt;/'&lt;/code&gt; 와 일치 하므로 &lt;code&gt;detail()&lt;/code&gt; 보기가 다음과 같이 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="057dcfb3428d9a5609848b8e3067fdd04d1f11d4" translate="yes" xml:space="preserve">
          <source>When specifying &lt;code&gt;db_index=True&lt;/code&gt; on your model fields, Django typically outputs a single &lt;code&gt;CREATE INDEX&lt;/code&gt; statement. However, if the database type for the field is either &lt;code&gt;varchar&lt;/code&gt; or &lt;code&gt;text&lt;/code&gt; (e.g., used by &lt;code&gt;CharField&lt;/code&gt;, &lt;code&gt;FileField&lt;/code&gt;, and &lt;code&gt;TextField&lt;/code&gt;), then Django will create an additional index that uses an appropriate &lt;a href=&quot;https://www.postgresql.org/docs/current/indexes-opclass.html&quot;&gt;PostgreSQL operator class&lt;/a&gt; for the column. The extra index is necessary to correctly perform lookups that use the &lt;code&gt;LIKE&lt;/code&gt; operator in their SQL, as is done with the &lt;code&gt;contains&lt;/code&gt; and &lt;code&gt;startswith&lt;/code&gt; lookup types.</source>
          <target state="translated">모델 필드에서 &lt;code&gt;db_index=True&lt;/code&gt; 를 지정하면 Django는 일반적으로 단일 &lt;code&gt;CREATE INDEX&lt;/code&gt; 문을 출력합니다 . 그러나 필드의 데이터베이스 유형이 &lt;code&gt;varchar&lt;/code&gt; 또는 &lt;code&gt;text&lt;/code&gt; 인 경우 (예 : &lt;code&gt;CharField&lt;/code&gt; , &lt;code&gt;FileField&lt;/code&gt; 및 &lt;code&gt;TextField&lt;/code&gt; 에 의해 사용됨 ) Django는 열에 적절한 &lt;a href=&quot;https://www.postgresql.org/docs/current/indexes-opclass.html&quot;&gt;PostgreSQL 연산자 클래스&lt;/a&gt; 를 사용하는 추가 색인을 작성합니다 . &lt;code&gt;contains&lt;/code&gt; 및 &lt;code&gt;startswith&lt;/code&gt; 유형으로 시작 되는 것처럼 SQL에서 &lt;code&gt;LIKE&lt;/code&gt; 연산자 를 사용하는 조회를 올바르게 수행하려면 추가 색인이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="93c379fecdc5d0472c214382feae8f30b77b6e64" translate="yes" xml:space="preserve">
          <source>When specifying a custom form class, you must still specify the model, even though the &lt;a href=&quot;../../ref/class-based-views/mixins-editing#django.views.generic.edit.FormMixin.form_class&quot;&gt;&lt;code&gt;form_class&lt;/code&gt;&lt;/a&gt; may be a &lt;a href=&quot;../forms/modelforms#django.forms.ModelForm&quot;&gt;&lt;code&gt;ModelForm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용자 정의 양식 클래스를 지정할 때 &lt;a href=&quot;../../ref/class-based-views/mixins-editing#django.views.generic.edit.FormMixin.form_class&quot;&gt; &lt;code&gt;form_class&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;../forms/modelforms#django.forms.ModelForm&quot;&gt; &lt;code&gt;ModelForm&lt;/code&gt; &lt;/a&gt; 일지라도 모델을 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d6c5c02fcd017fd78dd6abd243c96f6129e667fb" translate="yes" xml:space="preserve">
          <source>When specifying the field to be aggregated in an aggregate function, Django will allow you to use the same &lt;a href=&quot;queries#field-lookups-intro&quot;&gt;double underscore notation&lt;/a&gt; that is used when referring to related fields in filters. Django will then handle any table joins that are required to retrieve and aggregate the related value.</source>
          <target state="translated">집계 함수에서 집계 할 필드를 지정할 때 Django 에서는 필터에서 관련 필드를 참조 할 때 사용되는 것과 동일한 &lt;a href=&quot;queries#field-lookups-intro&quot;&gt;이중 밑줄 표기법&lt;/a&gt; 을 사용할 수 있습니다. 그러면 Django는 관련 값을 검색하고 집계하는 데 필요한 모든 테이블 조인을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="4285f0a70b9a43cf232f4e43936fd67c82ba521c" translate="yes" xml:space="preserve">
          <source>When staying with the same example data as before it would be serialized as JSON in the following way:</source>
          <target state="translated">이전과 동일한 예제 데이터를 유지하면 다음과 같은 방식으로 JSON으로 직렬화됩니다.</target>
        </trans-unit>
        <trans-unit id="aa815810926eb615ffa41ef8b1e646f78f102179" translate="yes" xml:space="preserve">
          <source>When support for time zones is enabled, Django stores datetime information in UTC in the database, uses time-zone-aware datetime objects internally, and translates them to the end user&amp;rsquo;s time zone in templates and forms.</source>
          <target state="translated">표준 시간대 지원이 활성화되면 Django는 날짜 시간 정보를 데이터베이스에 UTC로 저장하고 표준 시간대 인식 날짜 시간 객체를 내부적으로 사용하여 템플릿 및 양식에서 최종 사용자의 시간대로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="de20bb7951f56b8554f4e028d68ec84b15495470" translate="yes" xml:space="preserve">
          <source>When switching from using &lt;a href=&quot;../../ref/urls#django.urls.path&quot;&gt;&lt;code&gt;path()&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;../../ref/urls#django.urls.re_path&quot;&gt;&lt;code&gt;re_path()&lt;/code&gt;&lt;/a&gt; or vice versa, it&amp;rsquo;s particularly important to be aware that the type of the view arguments may change, and so you may need to adapt your views.</source>
          <target state="translated">&lt;a href=&quot;../../ref/urls#django.urls.path&quot;&gt; &lt;code&gt;path()&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;../../ref/urls#django.urls.re_path&quot;&gt; &lt;code&gt;re_path()&lt;/code&gt; &lt;/a&gt; 또는 그 반대로 전환 할 때 뷰 인수의 유형이 변경 될 수 있으므로 뷰를 조정해야 할 수 있다는 점을 특히 중요합니다.</target>
        </trans-unit>
        <trans-unit id="8ed1d9a8327d1fd8ec9e9674e0008132f5b500fe" translate="yes" xml:space="preserve">
          <source>When test parallelization is enabled and a test fails, Django may be unable to display the exception traceback. This can make debugging difficult. If you encounter this problem, run the affected test without parallelization to see the traceback of the failure.</source>
          <target state="translated">테스트 병렬화가 활성화되고 테스트가 실패하면 Django가 예외 추적을 표시하지 못할 수 있습니다. 이로 인해 디버깅이 어려워 질 수 있습니다. 이 문제점이 발생하면 병렬화없이 영향을받는 테스트를 실행하여 실패의 역 추적을보십시오.</target>
        </trans-unit>
        <trans-unit id="e69d901833901b9fa4f1b39aa662469f37295910" translate="yes" xml:space="preserve">
          <source>When testing applications that support internationalization and localization, you might want to set the language for a test client request. The method for doing so depends on whether or not the &lt;a href=&quot;../../ref/middleware#django.middleware.locale.LocaleMiddleware&quot;&gt;&lt;code&gt;LocaleMiddleware&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">국제화 및 현지화를 지원하는 응용 프로그램을 테스트 할 때 테스트 클라이언트 요청에 대한 언어를 설정하려고 할 수 있습니다. 이를 수행하는 방법은 &lt;a href=&quot;../../ref/middleware#django.middleware.locale.LocaleMiddleware&quot;&gt; &lt;code&gt;LocaleMiddleware&lt;/code&gt; 의&lt;/a&gt; 활성화 여부에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="d17ab068977042b051a879f6727a9eec3d7e61fd" translate="yes" xml:space="preserve">
          <source>When testing, more is better</source>
          <target state="translated">테스트 할 때 더 많은 것이 좋습니다</target>
        </trans-unit>
        <trans-unit id="1297aaa6d3078711f3af30e8a2de30ca3c79003d" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;#django.db.transaction.atomic&quot;&gt;&lt;code&gt;atomic()&lt;/code&gt;&lt;/a&gt; decorator is nested, it creates a savepoint to allow partial commit or rollback. You&amp;rsquo;re strongly encouraged to use &lt;a href=&quot;#django.db.transaction.atomic&quot;&gt;&lt;code&gt;atomic()&lt;/code&gt;&lt;/a&gt; rather than the functions described below, but they&amp;rsquo;re still part of the public API, and there&amp;rsquo;s no plan to deprecate them.</source>
          <target state="translated">때 &lt;a href=&quot;#django.db.transaction.atomic&quot;&gt; &lt;code&gt;atomic()&lt;/code&gt; &lt;/a&gt; 장식이 중첩되어, 그 부분이 커밋 또는 롤백 할 수 있도록 저장 점을 생성한다. 아래에 설명 된 함수 대신 &lt;a href=&quot;#django.db.transaction.atomic&quot;&gt; &lt;code&gt;atomic()&lt;/code&gt; &lt;/a&gt; 을 사용하는 것이 좋지만 여전히 공용 API의 일부이므로 더 이상 사용하지 않을 계획이 없습니다.</target>
        </trans-unit>
        <trans-unit id="471e20a4382a873b6e21c286d787cc261af00882" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;../ref/django-admin#cmdoption-migrate-fake-initial&quot;&gt;&lt;code&gt;migrate --fake-initial&lt;/code&gt;&lt;/a&gt; option is used, these initial migrations are treated specially. For an initial migration that creates one or more tables (&lt;code&gt;CreateModel&lt;/code&gt; operation), Django checks that all of those tables already exist in the database and fake-applies the migration if so. Similarly, for an initial migration that adds one or more fields (&lt;code&gt;AddField&lt;/code&gt; operation), Django checks that all of the respective columns already exist in the database and fake-applies the migration if so. Without &lt;code&gt;--fake-initial&lt;/code&gt;, initial migrations are treated no differently from any other migration.</source>
          <target state="translated">때 &lt;a href=&quot;../ref/django-admin#cmdoption-migrate-fake-initial&quot;&gt; &lt;code&gt;migrate --fake-initial&lt;/code&gt; &lt;/a&gt; 옵션을 사용, 이러한 초기 마이그레이션 특별히 처리됩니다. 하나 이상의 테이블을 생성하는 초기 마이그레이션 ( &lt;code&gt;CreateModel&lt;/code&gt; 작업)의 경우 Django는 해당 테이블이 모두 데이터베이스에 이미 존재하는지 확인하고 마이그레이션을 가짜로 적용합니다. 마찬가지로, 하나 이상의 필드를 추가하는 초기 마이그레이션 ( &lt;code&gt;AddField&lt;/code&gt; 작업)의 경우 Django는 각 열이 모두 데이터베이스에 이미 존재하는지 확인하여 마이그레이션을 가짜로 적용합니다. &lt;code&gt;--fake-initial&lt;/code&gt; 이 없으면 초기 마이그레이션은 다른 마이그레이션과 다르게 취급되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ffc45b453571974a359fca6b3599059b3d056ae" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&amp;lt;input type=&quot;submit&quot; value=&quot;Log in&quot;&amp;gt;&lt;/code&gt; element is triggered, the data is returned to &lt;code&gt;/admin/&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;&amp;lt;input type=&quot;submit&quot; value=&quot;Log in&quot;&amp;gt;&lt;/code&gt; 요소가 트리거되어, 데이터에 반환 &lt;code&gt;/admin/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3e46e4242019691fc54404ee906eebca1762446" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;Form&lt;/code&gt; is valid, &lt;code&gt;cleaned_data&lt;/code&gt; will include a key and value for &lt;em&gt;all&lt;/em&gt; its fields, even if the data didn&amp;rsquo;t include a value for some optional fields. In this example, the data dictionary doesn&amp;rsquo;t include a value for the &lt;code&gt;nick_name&lt;/code&gt; field, but &lt;code&gt;cleaned_data&lt;/code&gt; includes it, with an empty value:</source>
          <target state="translated">때 &lt;code&gt;Form&lt;/code&gt; 유효 &lt;code&gt;cleaned_data&lt;/code&gt; 는 의 키와 값이 포함됩니다 &lt;em&gt;모든&lt;/em&gt; 데이터가 일부 선택적 필드에 대한 값을 포함하지 않은 경우에도 해당 필드를. 이 예에서 데이터 딕셔너리는 &lt;code&gt;nick_name&lt;/code&gt; 필드에 대한 값을 포함하지 않지만 &lt;code&gt;cleaned_data&lt;/code&gt; 는 빈 값으로 포함합니다.</target>
        </trans-unit>
        <trans-unit id="4f0388451b2840bd5965e3402e06905ee1e4c8c3" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;TemplateResponse&lt;/code&gt; instance is explicitly rendered, using the &lt;a href=&quot;#django.template.response.SimpleTemplateResponse.render&quot;&gt;&lt;code&gt;SimpleTemplateResponse.render()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;#django.template.response.SimpleTemplateResponse.render&quot;&gt; &lt;code&gt;SimpleTemplateResponse.render()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 &lt;code&gt;TemplateResponse&lt;/code&gt; 인스턴스가 명시 적으로 렌더링 될 때</target>
        </trans-unit>
        <trans-unit id="beb71bb9ca9e9ddf253bd0db0a5a196f7ababf05" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;fields&lt;/code&gt; parameter is not specified, the &lt;code&gt;geojson&lt;/code&gt; serializer adds a &lt;code&gt;pk&lt;/code&gt; key to the &lt;code&gt;properties&lt;/code&gt; dictionary with the primary key of the object as the value.</source>
          <target state="translated">때 &lt;code&gt;fields&lt;/code&gt; 매개 변수가 지정되지 않은 상기 &lt;code&gt;geojson&lt;/code&gt; 의 직렬화는 추가 &lt;code&gt;pk&lt;/code&gt; 받는 키 &lt;code&gt;properties&lt;/code&gt; 값과 오브젝트의 기본 키 사전.</target>
        </trans-unit>
        <trans-unit id="a3fe3a10f08cea3e9caf55f72a5a6be6caac3616" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;raw_password&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, the password will be set to an unusable password, as if &lt;a href=&quot;#django.contrib.auth.models.User.set_unusable_password&quot;&gt;&lt;code&gt;set_unusable_password()&lt;/code&gt;&lt;/a&gt; were used.</source>
          <target state="translated">때 &lt;code&gt;raw_password&lt;/code&gt; 가 없는 &lt;code&gt;None&lt;/code&gt; 것처럼 암호는 사용할 수없는 암호로 설정한다 &lt;a href=&quot;#django.contrib.auth.models.User.set_unusable_password&quot;&gt; &lt;code&gt;set_unusable_password()&lt;/code&gt; &lt;/a&gt; 사용 하였다.</target>
        </trans-unit>
        <trans-unit id="3efe252d05546c2dfb5b54804653e58578f3f43c" translate="yes" xml:space="preserve">
          <source>When the ASGI server loads your application, Django needs to import the settings module &amp;mdash; that&amp;rsquo;s where your entire application is defined.</source>
          <target state="translated">ASGI 서버가 애플리케이션을로드 할 때 Django는 전체 애플리케이션이 정의 된 설정 모듈을 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="7be5534960f71045451c905d71f45bc9b28f3cc4" translate="yes" xml:space="preserve">
          <source>When the WSGI server loads your application, Django needs to import the settings module &amp;mdash; that&amp;rsquo;s where your entire application is defined.</source>
          <target state="translated">WSGI 서버가 애플리케이션을로드 할 때 Django는 전체 애플리케이션이 정의 된 설정 모듈을 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="bead5079ae32a470110abae674a71028189fd77f" translate="yes" xml:space="preserve">
          <source>When the Web server takes care of authentication it typically sets the &lt;code&gt;REMOTE_USER&lt;/code&gt; environment variable for use in the underlying application. In Django, &lt;code&gt;REMOTE_USER&lt;/code&gt; is made available in the &lt;a href=&quot;../ref/request-response#django.http.HttpRequest.META&quot;&gt;&lt;code&gt;request.META&lt;/code&gt;&lt;/a&gt; attribute. Django can be configured to make use of the &lt;code&gt;REMOTE_USER&lt;/code&gt; value using the &lt;code&gt;RemoteUserMiddleware&lt;/code&gt; or &lt;code&gt;PersistentRemoteUserMiddleware&lt;/code&gt;, and &lt;a href=&quot;../ref/contrib/auth#django.contrib.auth.backends.RemoteUserBackend&quot;&gt;&lt;code&gt;RemoteUserBackend&lt;/code&gt;&lt;/a&gt; classes found in &lt;a href=&quot;../topics/auth/index#module-django.contrib.auth&quot;&gt;&lt;code&gt;django.contrib.auth&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">웹 서버는 인증을 처리 할 때 기본 응용 프로그램에서 사용할 &lt;code&gt;REMOTE_USER&lt;/code&gt; 환경 변수를 설정합니다 . 장고에서는 &lt;code&gt;REMOTE_USER&lt;/code&gt; 를&lt;a href=&quot;../ref/request-response#django.http.HttpRequest.META&quot;&gt; &lt;code&gt;request.META&lt;/code&gt; &lt;/a&gt; 속성 에서 사용할 수 있습니다 . Django는 &lt;code&gt;RemoteUserMiddleware&lt;/code&gt; 또는 &lt;code&gt;PersistentRemoteUserMiddleware&lt;/code&gt; 및 &lt;a href=&quot;../topics/auth/index#module-django.contrib.auth&quot;&gt; &lt;code&gt;django.contrib.auth&lt;/code&gt; 에있는&lt;/a&gt;&lt;a href=&quot;../ref/contrib/auth#django.contrib.auth.backends.RemoteUserBackend&quot;&gt; &lt;code&gt;RemoteUserBackend&lt;/code&gt; &lt;/a&gt; 클래스를 사용하여 &lt;code&gt;REMOTE_USER&lt;/code&gt; 값을 사용 하도록 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="34c0a4324cee3a7c1d35122ff488e25d45d3432d" translate="yes" xml:space="preserve">
          <source>When the app template files are rendered with the Django template engine (by default all &lt;code&gt;*.py&lt;/code&gt; files), Django will also replace all stray template variables contained. For example, if one of the Python files contains a docstring explaining a particular feature related to template rendering, it might result in an incorrect example.</source>
          <target state="translated">앱 템플릿 파일이 Django 템플릿 엔진으로 렌더링 될 때 (기본적으로 모든 &lt;code&gt;*.py&lt;/code&gt; 파일) Django는 포함 된 모든 스트레이 템플릿 변수도 대체합니다. 예를 들어, Python 파일 중 하나에 템플릿 렌더링과 관련된 특정 기능을 설명하는 docstring이 포함되어 있으면 잘못된 예가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d5358f22e824499ab309dad7569732afa54b760" translate="yes" xml:space="preserve">
          <source>When the client next requests the same resource, it might send along a header such as either &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.3&quot;&gt;If-modified-since&lt;/a&gt; or &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.4&quot;&gt;If-unmodified-since&lt;/a&gt;, containing the date of the last modification time it was sent, or either &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.1&quot;&gt;If-match&lt;/a&gt; or &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.2&quot;&gt;If-none-match&lt;/a&gt;, containing the last &lt;code&gt;ETag&lt;/code&gt; it was sent. If the current version of the page matches the &lt;code&gt;ETag&lt;/code&gt; sent by the client, or if the resource has not been modified, a 304 status code can be sent back, instead of a full response, telling the client that nothing has changed. Depending on the header, if the page has been modified or does not match the &lt;code&gt;ETag&lt;/code&gt; sent by the client, a 412 status code (Precondition Failed) may be returned.</source>
          <target state="translated">클라이언트가 다음에 동일한 리소스를 요청하면 마지막으로 전송 된 수정 날짜가 포함 &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.3&quot;&gt;된 If-modified-since&lt;/a&gt; 또는 &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.4&quot;&gt;If-unmodified-since&lt;/a&gt; 와 같은 헤더 또는 &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.2&quot;&gt;If &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.1&quot;&gt;-match&lt;/a&gt; 또는 If- none-match 는 전송 된 마지막 &lt;code&gt;ETag&lt;/code&gt; 를 포함합니다 . 페이지의 현재 버전이 클라이언트가 전송 한 &lt;code&gt;ETag&lt;/code&gt; 와 일치 하거나 자원이 수정되지 않은 경우 전체 응답 대신 304 상태 코드를 다시 전송하여 클라이언트에게 아무것도 변경하지 않았 음을 알릴 수 있습니다. 헤더에 따라 페이지가 수정되었거나 클라이언트가 전송 한 &lt;code&gt;ETag&lt;/code&gt; 와 일치하지 않으면 412 상태 코드 (전제 조건 실패)가 리턴 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b698c2efdd478d0453e6a2965114cb34bcaeebb6" translate="yes" xml:space="preserve">
          <source>When the content of the response is explicitly set by assigning &lt;code&gt;response.content&lt;/code&gt;.</source>
          <target state="translated">때 응답의 콘텐츠는 명시 적으로 지정하여 설정 &lt;code&gt;response.content&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="18f37817105a586812300378e9afc9a86b86f6d1" translate="yes" xml:space="preserve">
          <source>When the form is submitted, the &lt;code&gt;POST&lt;/code&gt; request which is sent to the server will contain the form data.</source>
          <target state="translated">양식이 제출되면 서버로 전송 된 &lt;code&gt;POST&lt;/code&gt; 요청에 양식 데이터가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="363fa540327867c28ec880e617b2c717b7548dfc" translate="yes" xml:space="preserve">
          <source>When the form is submitted, we reconstruct it and provide the original data so that the comparison can be done:</source>
          <target state="translated">양식을 제출하면 양식을 재구성하고 원본 데이터를 제공하여 비교를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d69996ce729092f51629e9925a7d8acaf8e3130" translate="yes" xml:space="preserve">
          <source>When the installer completes, it will ask to launch the Application Stack Builder (ASB) on exit &amp;ndash; keep this checked, as it is necessary to install &lt;a href=&quot;#postgisasb&quot;&gt;PostGIS&lt;/a&gt;.</source>
          <target state="translated">설치 프로그램이 완료되면 종료시 ASB (Application Stack Builder)를 시작하라는 메시지가 표시 됩니다. &lt;a href=&quot;#postgisasb&quot;&gt;PostGIS&lt;/a&gt; 를 설치하는 데 필요 하므로이 확인란을 선택 상태로 유지하십시오 .</target>
        </trans-unit>
        <trans-unit id="a875fa7bf5148acf6e0840cee8d4d1c2f3db9d62" translate="yes" xml:space="preserve">
          <source>When the new environment is set up, &lt;a href=&quot;../topics/testing/overview&quot;&gt;run the full test suite&lt;/a&gt; for your application. Again, it&amp;rsquo;s useful to turn on deprecation warnings on so they&amp;rsquo;re shown in the test output (you can also use the flag if you test your app manually using &lt;code&gt;manage.py runserver&lt;/code&gt;):</source>
          <target state="translated">새 환경이 설정되면 애플리케이션에 대한 &lt;a href=&quot;../topics/testing/overview&quot;&gt;전체 테스트 스위트&lt;/a&gt; 를 실행하십시오 . 또한 사용 중단 경고를 켜서 테스트 출력에 표시되도록하는 것이 유용합니다 ( &lt;code&gt;manage.py runserver&lt;/code&gt; 를 사용하여 앱을 수동으로 테스트하는 경우 플래그를 사용할 수도 있음 ).</target>
        </trans-unit>
        <trans-unit id="785471747ca8ecda2ffd40de07f7c4a2bc42595c" translate="yes" xml:space="preserve">
          <source>When the queryset is evaluated (&lt;code&gt;for entry in entries&lt;/code&gt; in this case), all matched entries will be locked until the end of the transaction block, meaning that other transactions will be prevented from changing or acquiring locks on them.</source>
          <target state="translated">쿼리 세트가 평가되면 ( 이 경우 &lt;code&gt;for entry in entries&lt;/code&gt; 에 대해) 일치하는 모든 항목이 트랜잭션 블록이 끝날 때까지 잠기므로 다른 트랜잭션이 잠금을 변경하거나 획득 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e7d6a1507f88ed674c7b2aaee9ac033a746dfecf" translate="yes" xml:space="preserve">
          <source>When the raw_password is &lt;code&gt;None&lt;/code&gt;, the password will be set to an unusable password, as if &lt;a href=&quot;#django.contrib.auth.models.AbstractBaseUser.set_unusable_password&quot;&gt;&lt;code&gt;set_unusable_password()&lt;/code&gt;&lt;/a&gt; were used.</source>
          <target state="translated">raw_password가 &lt;code&gt;None&lt;/code&gt; 이면, &lt;a href=&quot;#django.contrib.auth.models.AbstractBaseUser.set_unusable_password&quot;&gt; &lt;code&gt;set_unusable_password()&lt;/code&gt; &lt;/a&gt; 가 사용 된 것처럼 암호는 사용할 수없는 암호로 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="cec1d756f8afab135911c8fdea967e7806176a26" translate="yes" xml:space="preserve">
          <source>When the save occurs in statement 2, &lt;code&gt;p&lt;/code&gt; already has a primary key value, and Django will attempt to use that primary key on the new database. If the primary key value isn&amp;rsquo;t in use in the &lt;code&gt;second&lt;/code&gt; database, then you won&amp;rsquo;t have any problems &amp;ndash; the object will be copied to the new database.</source>
          <target state="translated">명령문 2에서 저장이 발생하면 &lt;code&gt;p&lt;/code&gt; 에는 이미 기본 키 값이 있으며 Django는 새 데이터베이스에서 해당 기본 키를 사용하려고 시도합니다. &lt;code&gt;second&lt;/code&gt; 데이터베이스 에서 기본 키 값을 사용 하지 않으면 아무런 문제가 없습니다. 개체가 새 데이터베이스에 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="dccf9b5068c7356eb3923ff457b14ea0e80377b8" translate="yes" xml:space="preserve">
          <source>When the silent keyword is used on a cycle definition, the silence automatically applies to all subsequent uses of that specific cycle tag. The following template would output &lt;em&gt;nothing&lt;/em&gt;, even though the second call to &lt;code&gt;{% cycle %}&lt;/code&gt; doesn&amp;rsquo;t specify &lt;code&gt;silent&lt;/code&gt;:</source>
          <target state="translated">자동 키워드가 사이클 정의에 사용되면 자동은 해당 특정 사이클 태그의 모든 후속 사용에 자동으로 적용됩니다. 다음 템플릿은 &lt;code&gt;{% cycle %}&lt;/code&gt; 에 대한 두 번째 호출이 &lt;code&gt;silent&lt;/code&gt; 를 지정하지 않더라도 &lt;em&gt;아무것도&lt;/em&gt; 출력 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6b60b4776b928d223d277e17de90ece841e26f95" translate="yes" xml:space="preserve">
          <source>When the test environment is configured, a test version of &lt;code&gt;replica&lt;/code&gt; will &lt;em&gt;not&lt;/em&gt; be created. Instead the connection to &lt;code&gt;replica&lt;/code&gt; will be redirected to point at &lt;code&gt;default&lt;/code&gt;. As a result, writes to &lt;code&gt;default&lt;/code&gt; will appear on &lt;code&gt;replica&lt;/code&gt; &amp;ndash; but because they are actually the same database, not because there is data replication between the two databases.</source>
          <target state="translated">테스트 환경이 구성되면 테스트 버전의 &lt;code&gt;replica&lt;/code&gt; 이 작성 &lt;em&gt;되지 않습니다&lt;/em&gt; . 대신 &lt;code&gt;replica&lt;/code&gt; 대한 연결이 &lt;code&gt;default&lt;/code&gt; 을 가리 키도록 리디렉션됩니다 . 결과적으로 &lt;code&gt;default&lt;/code&gt; 쓰기가 &lt;code&gt;replica&lt;/code&gt; 나타납니다. 그러나 두 데이터베이스간에 데이터 복제가 없기 때문에 실제로 동일한 데이터베이스이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="d751e321728d95b528f6707cdbd05b0666be03f7" translate="yes" xml:space="preserve">
          <source>When the value is retrieved from the database, it will be in the format chosen by the custom encoder (most often a string), so you&amp;rsquo;ll need to take extra steps to convert the value back to the initial data type (&lt;a href=&quot;../../models/instances#django.db.models.Model.from_db&quot;&gt;&lt;code&gt;Model.from_db()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../models/fields#django.db.models.Field.from_db_value&quot;&gt;&lt;code&gt;Field.from_db_value()&lt;/code&gt;&lt;/a&gt; are two possible hooks for that purpose). Your deserialization may need to account for the fact that you can&amp;rsquo;t be certain of the input type. For example, you run the risk of returning a &lt;code&gt;datetime&lt;/code&gt; that was actually a string that just happened to be in the same format chosen for &lt;code&gt;datetime&lt;/code&gt;s.</source>
          <target state="translated">데이터베이스에서 값을 검색 할 때 사용자 지정 인코더에서 선택한 형식 (대부분 문자열)으로되어 있으므로 값을 초기 데이터 형식 ( &lt;a href=&quot;../../models/instances#django.db.models.Model.from_db&quot;&gt; &lt;code&gt;Model.from_db()&lt;/code&gt; &lt;/a&gt; 다시 변환하려면 추가 단계를 수행해야합니다. () 및 &lt;a href=&quot;../../models/fields#django.db.models.Field.from_db_value&quot;&gt; &lt;code&gt;Field.from_db_value()&lt;/code&gt; &lt;/a&gt; 는 해당 목적을위한 두 가지 가능한 후크입니다. 역 직렬화는 입력 유형을 확신 할 수 없다는 사실을 설명해야 할 수도 있습니다. 예를 들어, 당신은 반환의 위험 실행 &lt;code&gt;datetime&lt;/code&gt; 실제로 단지에 대해 선택한 동일한 형식으로 우연히 문자열이었다 &lt;code&gt;datetime&lt;/code&gt; 들.</target>
        </trans-unit>
        <trans-unit id="2b5b1ec78c10f118e7af9fdf9899bf371a8d4ba7" translate="yes" xml:space="preserve">
          <source>When the view is called during the request/response cycle, the &lt;a href=&quot;#django.views.generic.base.View.setup&quot;&gt;&lt;code&gt;setup()&lt;/code&gt;&lt;/a&gt; method assigns the &lt;a href=&quot;../request-response#django.http.HttpRequest&quot;&gt;&lt;code&gt;HttpRequest&lt;/code&gt;&lt;/a&gt; to the view&amp;rsquo;s &lt;code&gt;request&lt;/code&gt; attribute, and any positional and/or keyword arguments &lt;a href=&quot;../../topics/http/urls#how-django-processes-a-request&quot;&gt;captured from the URL pattern&lt;/a&gt; to the &lt;code&gt;args&lt;/code&gt; and &lt;code&gt;kwargs&lt;/code&gt; attributes, respectively. Then &lt;a href=&quot;#django.views.generic.base.View.dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">요청 / 응답주기 동안 뷰가 호출되면 &lt;a href=&quot;#django.views.generic.base.View.setup&quot;&gt; &lt;code&gt;setup()&lt;/code&gt; &lt;/a&gt; 메소드는 &lt;a href=&quot;../request-response#django.http.HttpRequest&quot;&gt; &lt;code&gt;HttpRequest&lt;/code&gt; &lt;/a&gt; 를 뷰의 &lt;code&gt;request&lt;/code&gt; 속성 및 &lt;a href=&quot;../../topics/http/urls#how-django-processes-a-request&quot;&gt;URL 패턴에서 캡처 된&lt;/a&gt; 모든 위치 및 / 또는 키워드 인수 를 &lt;code&gt;args&lt;/code&gt; 및 &lt;code&gt;kwargs&lt;/code&gt; 속성에 각각 지정합니다. 그런 다음 &lt;a href=&quot;#django.views.generic.base.View.dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="e84181abe0512de047fe20994bb235aec2df4841" translate="yes" xml:space="preserve">
          <source>When this filter is used in a template where auto-escaping is enabled, Django will escape the output whenever the input is not already marked as &amp;ldquo;safe&amp;rdquo;.</source>
          <target state="translated">자동 이스케이프가 활성화 된 템플릿에서이 필터를 사용하면 Django는 입력이 &quot;안전&quot;으로 표시되지 않을 때마다 출력을 이스케이프합니다.</target>
        </trans-unit>
        <trans-unit id="22e5980717f6273c1f20c30fd94e0c2b94c59917" translate="yes" xml:space="preserve">
          <source>When this flag is set, if the first argument to your filter is a time zone aware datetime, Django will convert it to the current time zone before passing it to your filter when appropriate, according to &lt;a href=&quot;../topics/i18n/timezones#time-zones-in-templates&quot;&gt;rules for time zones conversions in templates&lt;/a&gt;.</source>
          <target state="translated">이 플래그를 설정하면 필터에 대한 첫 번째 인수가 표준 시간대 인식 날짜 시간 인 경우 Django는 &lt;a href=&quot;../topics/i18n/timezones#time-zones-in-templates&quot;&gt;템플릿의 표준 시간대 변환 규칙에&lt;/a&gt; 따라 적절한 경우 필터로 전달하기 전에 현재 표준 시간대로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="b7c128c4f37f4a951b44692e41cba49d49f20842" translate="yes" xml:space="preserve">
          <source>When this happens, Django will prompt you and give you some options. If it thinks it&amp;rsquo;s safe enough, it will offer to automatically linearize the two migrations for you. If not, you&amp;rsquo;ll have to go in and modify the migrations yourself - don&amp;rsquo;t worry, this isn&amp;rsquo;t difficult, and is explained more in &lt;a href=&quot;#migration-files&quot;&gt;Migration files&lt;/a&gt; below.</source>
          <target state="translated">이런 일이 발생하면 Django가 메시지를 표시하고 몇 가지 옵션을 제공합니다. 그것이 충분히 안전하다고 생각되면 두 가지 마이그레이션을 자동으로 선형화하도록 제안합니다. 그렇지 않은 경우 마이그레이션을 직접 수행하고 수정해야합니다. 걱정하지 마십시오. 어렵지 않으며 아래의 &lt;a href=&quot;#migration-files&quot;&gt;마이그레이션 파일에&lt;/a&gt; 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a093c4c46e5bf330ccdb0c2b616c4c47493877db" translate="yes" xml:space="preserve">
          <source>When this keyword is set, status information will be printed giving the number of features processed and successfully saved. By default, progress information will be printed every 1000 features processed, however, this default may be overridden by setting this keyword with an integer for the desired interval.</source>
          <target state="translated">이 키워드가 설정되면 처리되고 성공적으로 저장되는 기능의 수를 제공하는 상태 정보가 인쇄됩니다. 기본적으로 진행 정보는 처리 된 1000 개의 기능마다 인쇄되지만이 키워드를 원하는 간격으로 정수로 설정하면이 기본값이 무시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ff66661a0636a62c1caeda607ead031097067b2" translate="yes" xml:space="preserve">
          <source>When this option is set and &lt;code&gt;--verbosity&lt;/code&gt; is greater than 0 (the default), a progress bar is shown in the terminal.</source>
          <target state="translated">이 옵션을 설정하고 &lt;code&gt;--verbosity&lt;/code&gt; 가 0보다 큰 경우 (기본값) 터미널에 진행률 표시 줄이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="73eec5a69cc5450d9db602d73b521439010931f7" translate="yes" xml:space="preserve">
          <source>When time zone support is disabled, Django uses naive datetime objects in local time. This is sufficient for many use cases. In this mode, to obtain the current time, you would write:</source>
          <target state="translated">시간대 지원이 비활성화되면 Django는 순진 날짜 시간 객체를 현지 시간으로 사용합니다. 이것은 많은 사용 사례에 충분합니다. 이 모드에서 현재 시간을 얻으려면 다음과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="0872d0dc1ca1535e2fe23fdaa5988047ba925c91" translate="yes" xml:space="preserve">
          <source>When time zone support is enabled (&lt;a href=&quot;../../ref/settings#std:setting-USE_TZ&quot;&gt;&lt;code&gt;USE_TZ=True&lt;/code&gt;&lt;/a&gt;), Django uses time-zone-aware datetime objects. If your code creates datetime objects, they should be aware too. In this mode, the example above becomes:</source>
          <target state="translated">시간대 지원이 활성화되면 ( &lt;a href=&quot;../../ref/settings#std:setting-USE_TZ&quot;&gt; &lt;code&gt;USE_TZ=True&lt;/code&gt; &lt;/a&gt; ) Django는 시간대 인식 날짜 / 시간 객체를 사용합니다. 코드에서 날짜 / 시간 객체를 만들면 객체도 인식해야합니다. 이 모드에서 위의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5a76084623ffeb407225eeb7cf7734eb659ccb85" translate="yes" xml:space="preserve">
          <source>When time zone support is enabled, the database layer expects to receive only aware datetimes from your code. This warning occurs when it receives a naive datetime. This indicates that you haven&amp;rsquo;t finished porting your code for time zone support. Please refer to the &lt;a href=&quot;#time-zones-migration-guide&quot;&gt;migration guide&lt;/a&gt; for tips on this process.</source>
          <target state="translated">표준 시간대 지원이 활성화되면 데이터베이스 계층은 코드에서 인식 된 날짜 시간 만 수신합니다. 이 경고는 순진한 날짜 시간을 수신 할 때 발생합니다. 표준 시간대 지원을위한 코드 이식이 완료되지 않았 음을 나타냅니다. 이 프로세스에 대한 팁 은 &lt;a href=&quot;#time-zones-migration-guide&quot;&gt;마이그레이션 안내서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="720dc315a597b2a7840587fb3646c786ec8cc55e" translate="yes" xml:space="preserve">
          <source>When to use &lt;a href=&quot;../ref/urls#django.urls.include&quot;&gt;&lt;code&gt;include()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../ref/urls#django.urls.include&quot;&gt; &lt;code&gt;include()&lt;/code&gt; &lt;/a&gt; 를 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="9c0d324dd44969dbda2d5384041d37d5cafdc4b7" translate="yes" xml:space="preserve">
          <source>When to use custom signals</source>
          <target state="translated">맞춤형 신호를 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="631e54b71fc7c52854012ff86c91adc811e89ac2" translate="yes" xml:space="preserve">
          <source>When unapplying migrations, all dependent migrations will also be unapplied, regardless of &lt;code&gt;&amp;lt;app_label&amp;gt;&lt;/code&gt;. You can use &lt;code&gt;--plan&lt;/code&gt; to check which migrations will be unapplied.</source>
          <target state="translated">마이그레이션을 적용하지 않으면 &lt;code&gt;&amp;lt;app_label&amp;gt;&lt;/code&gt; 에 관계없이 모든 종속 마이그레이션도 적용되지 않습니다. &lt;code&gt;--plan&lt;/code&gt; 을 사용 하여 적용 할 마이그레이션을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9cdd9bcaca82d5fb22cef56f82d3b7b259cf6712" translate="yes" xml:space="preserve">
          <source>When updating objects, where possible, use the &lt;a href=&quot;../../ref/models/querysets#django.db.models.query.QuerySet.bulk_update&quot;&gt;&lt;code&gt;bulk_update()&lt;/code&gt;&lt;/a&gt; method to reduce the number of SQL queries. Given a list or queryset of objects:</source>
          <target state="translated">가능하면 객체를 업데이트 할 때 &lt;a href=&quot;../../ref/models/querysets#django.db.models.query.QuerySet.bulk_update&quot;&gt; &lt;code&gt;bulk_update()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 SQL 쿼리 수를 줄이십시오. 객체의 목록 또는 쿼리 세트가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f6d7a21259554b39157fe766c9cf521b1c37bb36" translate="yes" xml:space="preserve">
          <source>When used with an &lt;code&gt;aggregate()&lt;/code&gt; clause, a filter has the effect of constraining the objects over which the aggregate is calculated. For example, you can generate the average price of all books with a title that starts with &amp;ldquo;Django&amp;rdquo; using the query:</source>
          <target state="translated">&lt;code&gt;aggregate()&lt;/code&gt; 절 과 함께 사용 하면 필터는 집계가 계산되는 객체를 제한하는 효과가 있습니다. 예를 들어, 쿼리를 사용하여 제목이 &quot;Django&quot;로 시작하는 모든 책의 평균 가격을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5e7b094c4e683c6372f0932a9061afc0e3362f6" translate="yes" xml:space="preserve">
          <source>When used with an &lt;code&gt;annotate()&lt;/code&gt; clause, a filter has the effect of constraining the objects for which an annotation is calculated. For example, you can generate an annotated list of all books that have a title starting with &amp;ldquo;Django&amp;rdquo; using the query:</source>
          <target state="translated">&lt;code&gt;annotate()&lt;/code&gt; 절 과 함께 사용 하면 필터는 주석이 계산되는 객체를 제한하는 효과가 있습니다. 예를 들어, 쿼리를 사용하여 제목이 &quot;Django&quot;로 시작하는 모든 책의 주석이 달린 목록을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3d51273c36ece1653fd4d4ebacaf044f093947e" translate="yes" xml:space="preserve">
          <source>When used without a format string, the &lt;code&gt;DATE_FORMAT&lt;/code&gt; format specifier is used. Assuming the same settings as the previous example:</source>
          <target state="translated">형식 문자열없이 사용하면 &lt;code&gt;DATE_FORMAT&lt;/code&gt; 형식 지정자가 사용됩니다. 이전 예제와 동일한 설정을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="12ed6ae761a6cca8e535e293dc46964d04148a68" translate="yes" xml:space="preserve">
          <source>When used without a format string, the &lt;code&gt;TIME_FORMAT&lt;/code&gt; format specifier is used:</source>
          <target state="translated">형식 문자열없이 사용하면 &lt;code&gt;TIME_FORMAT&lt;/code&gt; 형식 지정자가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="de0c859864536b75a456e5415aefa56e679e10b8" translate="yes" xml:space="preserve">
          <source>When used without an argument, rounds a floating-point number to one decimal place &amp;ndash; but only if there&amp;rsquo;s a decimal part to be displayed. For example:</source>
          <target state="translated">인수없이 사용하면 부동 소수점 숫자를 소수점 이하 한 자리로 반올림합니다. 그러나 소수점 이하 자릿수가 표시되는 경우에만 가능합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7a7e5162037701750b4b87650a308b6b03f09f47" translate="yes" xml:space="preserve">
          <source>When users log in, if their passwords are stored with anything other than the preferred algorithm, Django will automatically upgrade the algorithm to the preferred one. This means that old installs of Django will get automatically more secure as users log in, and it also means that you can switch to new (and better) storage algorithms as they get invented.</source>
          <target state="translated">사용자가 로그인 할 때 비밀번호가 선호하는 알고리즘 이외의 다른 것으로 저장되면 Django는 알고리즘을 선호하는 알고리즘으로 자동 업그레이드합니다. 즉, 사용자가 로그인하면 Django의 이전 설치가 자동으로 더 안전 해지며 새로 개발 된 스토리지 알고리즘으로 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a941cc02cd3d56c1a9e4a2f0cd5a60b53639133" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;#multi-table-inheritance&quot;&gt;multi-table inheritance&lt;/a&gt;, a new database table is created for each subclass of a model. This is usually the desired behavior, since the subclass needs a place to store any additional data fields that are not present on the base class. Sometimes, however, you only want to change the Python behavior of a model &amp;ndash; perhaps to change the default manager, or add a new method.</source>
          <target state="translated">&lt;a href=&quot;#multi-table-inheritance&quot;&gt;다중 테이블 상속을&lt;/a&gt; 사용 하면 모델의 각 서브 클래스에 대해 새 데이터베이스 테이블이 작성됩니다. 서브 클래스는 기본 클래스에 존재하지 않는 추가 데이터 필드를 저장할 장소가 필요하기 때문에 이는 일반적으로 원하는 동작입니다. 그러나 때로는 모델의 Python 동작 만 변경하려고합니다 (기본 관리자를 변경하거나 새 메소드 추가).</target>
        </trans-unit>
        <trans-unit id="a3513d79dca3637d2232ce2c4c10837774d9eb0e" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;../../../topics/db/sql&quot;&gt;raw queries&lt;/a&gt;, you must wrap your geometry fields so that the field value can be recognized by GEOS:</source>
          <target state="translated">&lt;a href=&quot;../../../topics/db/sql&quot;&gt;원시 쿼리를&lt;/a&gt; 사용 하는 경우 GEOS가 필드 값을 인식 할 수 있도록 지오메트리 필드를 랩핑해야합니다.</target>
        </trans-unit>
        <trans-unit id="6ec4593435566f15455cd2694810fd5596e6f4e9" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;../../topics/forms/modelforms#django.forms.ModelForm&quot;&gt;&lt;code&gt;model forms&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;Field&lt;/code&gt; needs to know which form field it should be represented by:</source>
          <target state="translated">&lt;a href=&quot;../../topics/forms/modelforms#django.forms.ModelForm&quot;&gt; &lt;code&gt;model forms&lt;/code&gt; &lt;/a&gt; 사용 하는 경우 &lt;code&gt;Field&lt;/code&gt; 는 다음으로 표시되어야하는 양식 필드를 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="8250762299c1a3dba6133b99366bb46738a045cd" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;../class-based-views/index&quot;&gt;class-based views&lt;/a&gt;, you can achieve the same behavior as with &lt;code&gt;login_required&lt;/code&gt; by using the &lt;code&gt;LoginRequiredMixin&lt;/code&gt;. This mixin should be at the leftmost position in the inheritance list.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;../class-based-views/index&quot;&gt;클래스 기반 뷰&lt;/a&gt; 와 마찬가지로 동일한 동작을 달성 할 수 &lt;code&gt;login_required&lt;/code&gt; 사용하여 &lt;code&gt;LoginRequiredMixin&lt;/code&gt; 을 . 이 믹스 인은 상속 목록에서 가장 왼쪽에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3f771af210041f2f64f394e85d2a2e48b7bab5ea" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;../class-based-views/index&quot;&gt;class-based views&lt;/a&gt;, you can use the &lt;code&gt;UserPassesTestMixin&lt;/code&gt; to do this.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;../class-based-views/index&quot;&gt;클래스 기반 뷰를&lt;/a&gt; , 당신은 사용할 수 있습니다 &lt;code&gt;UserPassesTestMixin&lt;/code&gt; 을 이 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62a14dc820acf0d2e2ce39535e3f0037dfd118aa" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;../db/models#multi-table-inheritance&quot;&gt;multi-table inheritance&lt;/a&gt;, forms generated by a formset factory will contain a parent link field (by default &lt;code&gt;&amp;lt;parent_model_name&amp;gt;_ptr&lt;/code&gt;) instead of an &lt;code&gt;id&lt;/code&gt; field.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;../db/models#multi-table-inheritance&quot;&gt;멀티 테이블 상속을&lt;/a&gt; 하는 해당 formset 공장에 의해 생성 된 양식은 (기본적으로 상위 링크 필드가 포함됩니다 &lt;code&gt;&amp;lt;parent_model_name&amp;gt;_ptr&lt;/code&gt; ) 대신의 &lt;code&gt;id&lt;/code&gt; 필드.</target>
        </trans-unit>
        <trans-unit id="4d8399cf1d09eaa038bdef494ce3261154cd5f7d" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;../ref/django-admin&quot;&gt;django-admin&lt;/a&gt;, you can either set the environment variable once, or explicitly pass in the settings module each time you run the utility.</source>
          <target state="translated">&lt;a href=&quot;../ref/django-admin&quot;&gt;django-admin을&lt;/a&gt; 사용 하는 경우 환경 변수를 한 번 설정하거나 유틸리티를 실행할 때마다 설정 모듈을 명시 적으로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0437ff052879747e27beaaeb0c018478a746e97c" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;models/querysets#django.db.models.query.QuerySet.iterator&quot;&gt;&lt;code&gt;QuerySet.iterator()&lt;/code&gt;&lt;/a&gt;, Django opens a &lt;a href=&quot;https://www.psycopg.org/docs/usage.html#server-side-cursors&quot;&gt;server-side cursor&lt;/a&gt;. By default, PostgreSQL assumes that only the first 10% of the results of cursor queries will be fetched. The query planner spends less time planning the query and starts returning results faster, but this could diminish performance if more than 10% of the results are retrieved. PostgreSQL&amp;rsquo;s assumptions on the number of rows retrieved for a cursor query is controlled with the &lt;a href=&quot;https://www.postgresql.org/docs/current/runtime-config-query.html#GUC-CURSOR-TUPLE-FRACTION&quot;&gt;cursor_tuple_fraction&lt;/a&gt; option.</source>
          <target state="translated">&lt;a href=&quot;models/querysets#django.db.models.query.QuerySet.iterator&quot;&gt; &lt;code&gt;QuerySet.iterator()&lt;/code&gt; &lt;/a&gt; 사용할 때 Django는 &lt;a href=&quot;https://www.psycopg.org/docs/usage.html#server-side-cursors&quot;&gt;서버 측 커서를&lt;/a&gt; 엽니 다 . 기본적으로 PostgreSQL은 커서 쿼리 결과의 처음 10 % 만 가져 오도록 가정합니다. 쿼리 플래너는 쿼리 계획에 더 적은 시간을 소비하고 결과를 더 빨리 리턴하기 시작하지만 결과의 10 % 이상이 검색되면 성능이 저하 될 수 있습니다. 커서 쿼리에 대해 검색된 행 수에 대한 PostgreSQL의 가정은 &lt;a href=&quot;https://www.postgresql.org/docs/current/runtime-config-query.html#GUC-CURSOR-TUPLE-FRACTION&quot;&gt;cursor_tuple_fraction&lt;/a&gt; 옵션으로 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="9659364a71d70fbf95e380c80ce6967af593e382" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;CreateView&lt;/code&gt; you have access to &lt;code&gt;self.object&lt;/code&gt;, which is the object being created. If the object hasn&amp;rsquo;t been created yet, the value will be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;CreateView&lt;/code&gt; 을 당신은에 액세스 할 수 있습니다 &lt;code&gt;self.object&lt;/code&gt; 생성되는 객체입니다. 객체가 아직 생성되지 않은 경우 값은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0f63903971bafa4a17ef764e5804f9f501e2686d" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;UpdateView&lt;/code&gt; you have access to &lt;code&gt;self.object&lt;/code&gt;, which is the object being updated.</source>
          <target state="translated">&lt;code&gt;UpdateView&lt;/code&gt; 를 사용하면 업데이트되는 객체 인 &lt;code&gt;self.object&lt;/code&gt; 에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c74977f82ed485f5a3b6a96d4ced0d7a275c4c78" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;ngettext()&lt;/code&gt;, make sure you use a single name for every extrapolated variable included in the literal. In the examples above, note how we used the &lt;code&gt;name&lt;/code&gt; Python variable in both translation strings. This example, besides being incorrect in some languages as noted above, would fail:</source>
          <target state="translated">사용하는 경우 &lt;code&gt;ngettext()&lt;/code&gt; , 당신은 문자에 포함 된 모든 외삽 변수에 대한 하나의 이름을 사용할 수 있는지 확인하십시오. 위의 예제 에서 두 번역 문자열에서 Python 변수 &lt;code&gt;name&lt;/code&gt; 어떻게 사용했는지 주목하십시오 . 이 예는 위에서 언급 한 일부 언어에서 올바르지 않은 것 외에도 실패합니다.</target>
        </trans-unit>
        <trans-unit id="dcd2c60415076465633077f90e188c3f2b766bfb" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;select_for_update()&lt;/code&gt; on MySQL, make sure you filter a queryset against at least set of fields contained in unique constraints or only against fields covered by indexes. Otherwise, an exclusive write lock will be acquired over the full table for the duration of the transaction.</source>
          <target state="translated">MySQL에서 &lt;code&gt;select_for_update()&lt;/code&gt; 를 사용 하는 경우 고유 제한 조건에 포함 된 최소한의 필드 세트 또는 인덱스가 포함 된 필드에 대해서만 쿼리 세트를 필터링해야합니다. 그렇지 않으면 트랜잭션 지속 시간 동안 전체 테이블에 대해 독점 쓰기 잠금이 획득됩니다.</target>
        </trans-unit>
        <trans-unit id="e1c08bac491c7a74901305a1ed5034d55188ef49" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;to_attr&lt;/code&gt; the prefetched result is stored in a list. This can provide a significant speed improvement over traditional &lt;code&gt;prefetch_related&lt;/code&gt; calls which store the cached result within a &lt;code&gt;QuerySet&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;to_attr&lt;/code&gt; 을 사용 하면 프리 페치 된 결과가 목록에 저장됩니다. 이는 캐시 된 결과를 &lt;code&gt;QuerySet&lt;/code&gt; 인스턴스 내에 저장하는 전통적인 &lt;code&gt;prefetch_related&lt;/code&gt; 호출에 비해 속도가 크게 향상 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c2c4b1f8a8dd3759ff72b3f0c488417558fbe0eb" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;values()&lt;/code&gt; together with &lt;a href=&quot;#django.db.models.query.QuerySet.distinct&quot;&gt;&lt;code&gt;distinct()&lt;/code&gt;&lt;/a&gt;, be aware that ordering can affect the results. See the note in &lt;a href=&quot;#django.db.models.query.QuerySet.distinct&quot;&gt;&lt;code&gt;distinct()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;a href=&quot;#django.db.models.query.QuerySet.distinct&quot;&gt; &lt;code&gt;distinct()&lt;/code&gt; &lt;/a&gt; 와 함께 &lt;code&gt;values()&lt;/code&gt; 사용 하는 경우 순서가 결과에 영향을 줄 수 있습니다. 자세한 내용은 &lt;a href=&quot;#django.db.models.query.QuerySet.distinct&quot;&gt; &lt;code&gt;distinct()&lt;/code&gt; &lt;/a&gt; 의 메모를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="87f04040b5fce1804819fd7c7d858dbfee03cb03" translate="yes" xml:space="preserve">
          <source>When using Watchman with a project that includes large non-Python directories like &lt;code&gt;node_modules&lt;/code&gt;, it&amp;rsquo;s advisable to ignore this directory for optimal performance. See the &lt;a href=&quot;https://facebook.github.io/watchman/docs/config.html#ignore_dirs&quot;&gt;watchman documentation&lt;/a&gt; for information on how to do this.</source>
          <target state="translated">&lt;code&gt;node_modules&lt;/code&gt; 와 같은 비 Python 이외의 큰 디렉토리가 포함 된 프로젝트에서 Watchman을 사용하는 경우 최적의 성능을 위해이 디렉토리를 무시하는 것이 좋습니다. 이를 수행하는 방법에 대한 자세한 내용은 &lt;a href=&quot;https://facebook.github.io/watchman/docs/config.html#ignore_dirs&quot;&gt;파수꾼 설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7af642b3e83f4d0f8f4f5c688a3abe4e01b5cff8" translate="yes" xml:space="preserve">
          <source>When using an in-memory SQLite database to run the tests, the same database connection will be shared by two threads in parallel: the thread in which the live server is run and the thread in which the test case is run. It&amp;rsquo;s important to prevent simultaneous database queries via this shared connection by the two threads, as that may sometimes randomly cause the tests to fail. So you need to ensure that the two threads don&amp;rsquo;t access the database at the same time. In particular, this means that in some cases (for example, just after clicking a link or submitting a form), you might need to check that a response is received by Selenium and that the next page is loaded before proceeding with further test execution. Do this, for example, by making Selenium wait until the &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; HTML tag is found in the response (requires Selenium &amp;gt; 2.13):</source>
          <target state="translated">메모리 내 SQLite 데이터베이스를 사용하여 테스트를 실행하는 경우 동일한 데이터베이스 연결은 두 개의 스레드 (라이브 서버가 실행되는 스레드와 테스트 케이스가 실행되는 스레드)에서 병렬로 공유됩니다. 두 스레드에 의한이 공유 연결을 통한 동시 데이터베이스 쿼리를 방지하는 것이 때때로 테스트에 무작위로 실패 할 수 있으므로 중요합니다. 따라서 두 스레드가 동시에 데이터베이스에 액세스하지 않도록해야합니다. 특히 이는 링크를 클릭하거나 양식을 제출 한 직후와 같이 일부 경우에 Selenium이 응답을 수신하고 추가 테스트 실행을 진행하기 전에 다음 페이지가로드되는지 확인해야 할 수도 있음을 의미합니다. 예를 들어 셀레늄이 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 응답에 HTML 태그가 있습니다 (Selenium&amp;gt; 2.13 필요).</target>
        </trans-unit>
        <trans-unit id="fefc5699ef431be89d5c3ca734f4848301324ee0" translate="yes" xml:space="preserve">
          <source>When using lazy translation for a plural string (&lt;code&gt;[u]n[p]gettext_lazy&lt;/code&gt;), you generally don&amp;rsquo;t know the &lt;code&gt;number&lt;/code&gt; argument at the time of the string definition. Therefore, you are authorized to pass a key name instead of an integer as the &lt;code&gt;number&lt;/code&gt; argument. Then &lt;code&gt;number&lt;/code&gt; will be looked up in the dictionary under that key during string interpolation. Here&amp;rsquo;s example:</source>
          <target state="translated">복수 문자열 ( &lt;code&gt;[u]n[p]gettext_lazy&lt;/code&gt; )에 지연 변환을 사용하는 경우 일반적으로 문자열 정의시 &lt;code&gt;number&lt;/code&gt; 인수를 알 수 없습니다 . 따라서 정수 대신 키 이름을 &lt;code&gt;number&lt;/code&gt; 인수 로 전달할 수 있습니다. 그런 다음 문자열 보간 중에 해당 키 아래의 사전에서 &lt;code&gt;number&lt;/code&gt; 를 찾습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fbd67b7b5d6890ba55bd664ca5d74adfa55a8425" translate="yes" xml:space="preserve">
          <source>When using multiple databases, you may need to figure out whether or not to run a migration against a particular database. For example, you may want to &lt;strong&gt;only&lt;/strong&gt; run a migration on a particular database.</source>
          <target state="translated">여러 데이터베이스를 사용하는 경우 특정 데이터베이스에 대해 마이그레이션을 실행할지 여부를 알아야합니다. 예를 들어 특정 데이터베이스 &lt;strong&gt;에서만&lt;/strong&gt; 마이그레이션을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75de4d9da06c6302461ce0554d1c0b43544ed3e3" translate="yes" xml:space="preserve">
          <source>When using multiple decorators</source>
          <target state="translated">여러 데코레이터를 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="77f47283c9d7575f2d9ad8ea0830ff2587f3a2a3" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;AppDirectoriesFinder&lt;/code&gt; finder, make sure your apps can be found by staticfiles by adding the app to the &lt;a href=&quot;#std:setting-INSTALLED_APPS&quot;&gt;&lt;code&gt;INSTALLED_APPS&lt;/code&gt;&lt;/a&gt; setting of your site.</source>
          <target state="translated">&lt;code&gt;AppDirectoriesFinder&lt;/code&gt; 파인더를 사용하는 경우 사이트 의 &lt;a href=&quot;#std:setting-INSTALLED_APPS&quot;&gt; &lt;code&gt;INSTALLED_APPS&lt;/code&gt; &lt;/a&gt; 설정에 앱을 추가하여 정적 파일로 앱을 찾을 수 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="17fb307e8a448fb6d0dfbbbc4c65560af2581de6" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;pylibmc&lt;/code&gt; binding, do not include the &lt;code&gt;unix:/&lt;/code&gt; prefix:</source>
          <target state="translated">&lt;code&gt;pylibmc&lt;/code&gt; 바인딩을 사용할 때 &lt;code&gt;unix:/&lt;/code&gt; 접 두부를 포함하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="c9bd7b3ed30a984b2e493fa110691e0e9f48c7c2" translate="yes" xml:space="preserve">
          <source>When using the Oracle database backend, the value &lt;code&gt;NULL&lt;/code&gt; will be stored to denote the empty string regardless of this attribute.</source>
          <target state="translated">Oracle 데이터베이스 백엔드 를 사용하는 경우이 속성에 관계없이 빈 문자열을 나타 내기 위해 &lt;code&gt;NULL&lt;/code&gt; 값 이 저장됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
