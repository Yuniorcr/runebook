<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="gnu_cobol">
    <body>
      <group id="gnu_cobol">
        <trans-unit id="e9543acb0a3b6ae140b676bdd75a9f04b94c736b" translate="yes" xml:space="preserve">
          <source>CONFIGURATION SECTION Syntax</source>
          <target state="translated">구성 섹션 구문</target>
        </trans-unit>
        <trans-unit id="fd14e0768d8e03137017ff03d76cc74754b47cbb" translate="yes" xml:space="preserve">
          <source>CONSTANT Attribute Syntax</source>
          <target state="translated">상수 속성 구문</target>
        </trans-unit>
        <trans-unit id="45f863a18c883ddde1c38a1609e1083371a910f8" translate="yes" xml:space="preserve">
          <source>CONTINUE Syntax</source>
          <target state="translated">계속 구문</target>
        </trans-unit>
        <trans-unit id="57c118d0153aad86aee87fdaf7399dce402a08bd" translate="yes" xml:space="preserve">
          <source>CONTROL FOOTING(S) [2]</source>
          <target state="translated">컨트롤 풋 (들) [2]</target>
        </trans-unit>
        <trans-unit id="a0b77db4412f953dc79ec3e8dadb8c3312edb9f0" translate="yes" xml:space="preserve">
          <source>CONTROL HEADING(S) [2]</source>
          <target state="translated">제어 청각 (들) [2]</target>
        </trans-unit>
        <trans-unit id="a0fe3388635d6d014a065ee11d0aee898e490bea" translate="yes" xml:space="preserve">
          <source>COS Function Syntax</source>
          <target state="translated">COS 함수 구문</target>
        </trans-unit>
        <trans-unit id="e2bf90245c3eae70b50309837f6647c1f83fdf58" translate="yes" xml:space="preserve">
          <source>COUNT</source>
          <target state="translated">COUNT</target>
        </trans-unit>
        <trans-unit id="46a355610c958a2df7dbd1b4d7bf89438582b10c" translate="yes" xml:space="preserve">
          <source>CURRENCY-SYMBOL Function Syntax</source>
          <target state="translated">CURRENCY-SYMBOL 함수 구문</target>
        </trans-unit>
        <trans-unit id="7ab87c3b533221867b4462ee901838685c51bd46" translate="yes" xml:space="preserve">
          <source>CURRENT-DATE Function Syntax</source>
          <target state="translated">CURRENT-DATE 함수 구문</target>
        </trans-unit>
        <trans-unit id="a2b6abc7961dcf84b76adf0da7d0e3cb7258497a" translate="yes" xml:space="preserve">
          <source>Called Program</source>
          <target state="translated">호출 된 프로그램</target>
        </trans-unit>
        <trans-unit id="08e86dd2cb3e588792e5a1445c80be0d6ca86b4d" translate="yes" xml:space="preserve">
          <source>Called program not found</source>
          <target state="translated">호출 된 프로그램을 찾을 수 없습니다</target>
        </trans-unit>
        <trans-unit id="79de0a0be26f9fe0196ab734446be6015cb155b5" translate="yes" xml:space="preserve">
          <source>Calling Program</source>
          <target state="translated">전화 프로그램</target>
        </trans-unit>
        <trans-unit id="4aa75fa92437b6df595f9667af7d64254448be0b" translate="yes" xml:space="preserve">
          <source>Care must be taken that &amp;lt;</source>
          <target state="translated">&amp;lt;</target>
        </trans-unit>
        <trans-unit id="232276f2c2caa7b4c6621023fcbe761e2f25eb06" translate="yes" xml:space="preserve">
          <source>Care must be taken that programs reading such a file describe records whose length is exactly the same as that used by the program that created the file. For example, the following shows the contents of a&lt;code&gt;SEQUENTIAL&lt;/code&gt;file created by a program that wrote five 6-character records to it. The &quot;A&quot;, &quot;B&quot;, &amp;hellip; values reflect the records that were written to the file:</source>
          <target state="translated">이러한 파일을 읽는 프로그램은 길이가 파일을 작성한 프로그램에서 사용한 길이와 정확히 동일한 레코드를 설명하도록주의해야합니다. 예를 들어, 다음은 5 개의 6 문자 레코드를 기록한 프로그램으로 작성된 &lt;code&gt;SEQUENTIAL&lt;/code&gt; 파일 의 내용을 보여줍니다 . &quot;A&quot;, &quot;B&quot;,&amp;hellip; 값은 파일에 기록 된 레코드를 반영합니다.</target>
        </trans-unit>
        <trans-unit id="0d6ab5c40892951a44701a3cbbc3363615028003" translate="yes" xml:space="preserve">
          <source>Care must be taken that programs reading such a file describe records whose length is exactly the same as that used by the programs that created the file. It won&amp;rsquo;t end well if the GnuCOBOL runtime library interprets a four-byte ASCII character string as a record length when it transfers data from the file into the program!</source>
          <target state="translated">이러한 파일을 읽는 프로그램은 길이가 파일을 작성한 프로그램에서 사용한 길이와 정확히 동일한 레코드를 설명하도록주의해야합니다. 파일에서 프로그램으로 데이터를 전송할 때 GnuCOBOL 런타임 라이브러리가 4 바이트 ASCII 문자열을 레코드 길이로 해석하면 제대로 끝나지 않습니다!</target>
        </trans-unit>
        <trans-unit id="008af863881dc7149313286a97c8945b993a34fe" translate="yes" xml:space="preserve">
          <source>Case-folding may also be turned on and off within the program source code using the CDF&lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt;statement (see &lt;a href=&quot;#g_t_003e_003eSET&quot;&gt;&amp;gt;&amp;gt;SET&lt;/a&gt;).</source>
          <target state="translated">CDF &lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt; 문을 사용하여 프로그램 소스 코드 내에서 케이스 폴딩을 켜거나 끌 수도 있습니다 ( &lt;a href=&quot;#g_t_003e_003eSET&quot;&gt;&amp;gt;&amp;gt; SET&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="98accb26910de4948b37b8fbb0b408fbd1a965e0" translate="yes" xml:space="preserve">
          <source>Caution. Although this document is for version 2.2 of the compiler, it also includes a description of the functions of the RWCS (Report Writer module) which is not included in the compiler version 2.2. Please see availability notes on this at 1.3.13.</source>
          <target state="translated">주의. 이 문서는 컴파일러 버전 2.2 용이지만 컴파일러 버전 2.2에 포함되지 않은 RWCS (보고서 작성기 모듈) 기능에 대한 설명도 포함합니다. 1.3.13의 가용성 정보를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fb48ed86295c01e223491405da96e0725331ba29" translate="yes" xml:space="preserve">
          <source>Changes made by a subprogram to the value of an argument specified on the&lt;code&gt;USING&lt;/code&gt;clause will &quot;be visible&quot; to the calling program only if&lt;code&gt;BY REFERENCE&lt;/code&gt;was explicitly specified or implicitly assumed for the argument on the subprogram&amp;rsquo;s procedure division header</source>
          <target state="translated">서브 프로그램이 &lt;code&gt;USING&lt;/code&gt; 절 에 지정된 인수 값을 변경 하면 &lt;code&gt;BY REFERENCE&lt;/code&gt; 가 서브 프로그램의 프로 시저 분할 헤더의 인수에 대해 명시 적으로 지정되거나 내재적으로 가정 된 경우에만 호출 프로그램에 &quot;표시&quot;됩니다</target>
        </trans-unit>
        <trans-unit id="1cf367703f62db4730492b29e986ff87aabe8968" translate="yes" xml:space="preserve">
          <source>Changing the currency symbol via the&lt;code&gt;SPECIAL-NAMES&lt;/code&gt;(see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) paragraph&amp;rsquo;s&lt;code&gt;CURRENCY SYMBOL&lt;/code&gt;setting will</source>
          <target state="translated">&lt;code&gt;SPECIAL-NAMES&lt;/code&gt; ( &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt; 참조 ) 단락의 &lt;code&gt;CURRENCY SYMBOL&lt;/code&gt; 설정을 통해 통화 기호를 변경 하면</target>
        </trans-unit>
        <trans-unit id="3290313e1574c3d689ba9eb70ce2b545abfe41ec" translate="yes" xml:space="preserve">
          <source>Changing the current directory</source>
          <target state="translated">현재 디렉토리 변경</target>
        </trans-unit>
        <trans-unit id="6dd47dabb9df79c85d4c9bbf8e536ca75ef3576e" translate="yes" xml:space="preserve">
          <source>Character positions in this list do not affect the actual binary storage values used for the characters &amp;mdash; binary values will still be those of the&lt;code&gt;NATIVE&lt;/code&gt;character set.</source>
          <target state="translated">이 목록의 문자 위치는 문자에 사용 된 실제 이진 저장 값에 영향을 미치지 않습니다. 이진 값은 여전히 &lt;code&gt;NATIVE&lt;/code&gt; 문자 집합의 값입니다.</target>
        </trans-unit>
        <trans-unit id="b6f59f08fd6d58c6725e21a9ec24e068148ec586" translate="yes" xml:space="preserve">
          <source>Characters</source>
          <target state="translated">Characters</target>
        </trans-unit>
        <trans-unit id="06ba9f8b51464a92c09ba8adb0428ae07c0698c2" translate="yes" xml:space="preserve">
          <source>Class-Condition Syntax</source>
          <target state="translated">클래스 조건 구문</target>
        </trans-unit>
        <trans-unit id="6dcfeb045a3fd680afc99e0a6405f85f4b06bc0e" translate="yes" xml:space="preserve">
          <source>Class-Definition-Clause</source>
          <target state="translated">Class-Definition-Clause</target>
        </trans-unit>
        <trans-unit id="88225646933261b2af20b61cd0a15701c0f8d989" translate="yes" xml:space="preserve">
          <source>Clearly, even a non-programmer could at least conceptually understand what was going on! Over time, languages like FORTRAN evolved more robust variable names, and COBOL introduced a more formula-based syntactical capability for arithmetic operations, but FORTRAN was never as readable as COBOL.</source>
          <target state="translated">분명히 프로그래머가 아닌 사람조차도 적어도 무슨 일이 있었는지 개념적으로 이해할 수있었습니다! 시간이 지남에 따라 FORTRAN과 같은 언어는보다 강력한 변수 이름을 발전 시켰으며 COBOL은 산술 연산을위한보다 공식 기반의 구문 기능을 도입했지만 FORTRAN은 COBOL만큼 읽을 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="732a5387092d26a94fef7e2ce8d5d9519c238b19" translate="yes" xml:space="preserve">
          <source>Closed with lock</source>
          <target state="translated">자물쇠로 마감</target>
        </trans-unit>
        <trans-unit id="adac69379a626c2436948a4ef1792c7d719ef929" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>
        </trans-unit>
        <trans-unit id="594422a8373a45016503112a0d76d479ebc2de36" translate="yes" xml:space="preserve">
          <source>Collating Sequence</source>
          <target state="translated">조합 순서</target>
        </trans-unit>
        <trans-unit id="1d0c8304baedcf8e3a78982c2e7c0b04622bf2a0" translate="yes" xml:space="preserve">
          <source>Color</source>
          <target state="translated">Color</target>
        </trans-unit>
        <trans-unit id="5ff247b294c4c4680923f6b83955ad2dd9bcc50b" translate="yes" xml:space="preserve">
          <source>Colors may also be specified using a numeric non-edited identifier whose value is in the range 0-7.</source>
          <target state="translated">색상은 값이 0-7 범위 인 편집되지 않은 숫자로 된 식별자를 사용하여 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3da9b0a1bd95ee2ff92f0876a9bc1660e1b7f92d" translate="yes" xml:space="preserve">
          <source>Column 7 serves as an indicator in which one of five possible values will appear &amp;mdash; space,&lt;code&gt;D&lt;/code&gt;(or&lt;code&gt;d&lt;/code&gt;,&lt;code&gt;-&lt;/code&gt;(dash),&lt;code&gt;/&lt;/code&gt;or&lt;code&gt;*&lt;/code&gt; The meanings of these characters are as follows:</source>
          <target state="translated">7 열은 공백, &lt;code&gt;D&lt;/code&gt; (또는 &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; (대시) 또는 &lt;code&gt;/&lt;/code&gt; 또는 &lt;code&gt;*&lt;/code&gt; ) 의 5 가지 값 중 하나가 나타나는 표시기 역할을합니다. 이러한 문자의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f92afaa3e8bfcd3ea4fa0e30b81b8a7e79d9e878" translate="yes" xml:space="preserve">
          <source>Column headings describing the fields within the detail group(s)</source>
          <target state="translated">세부 사항 그룹 내의 필드를 설명하는 열 표제</target>
        </trans-unit>
        <trans-unit id="ef3b24c82e2e70a56915cb2e013177a3e224de2a" translate="yes" xml:space="preserve">
          <source>Combined Condition Syntax</source>
          <target state="translated">결합 된 조건 구문</target>
        </trans-unit>
        <trans-unit id="11bac06e449288d8a0080c4c6a977a78a032bea7" translate="yes" xml:space="preserve">
          <source>Comment Type</source>
          <target state="translated">댓글 유형</target>
        </trans-unit>
        <trans-unit id="94ef186c06d95cc1077474be4d410b632a210905" translate="yes" xml:space="preserve">
          <source>Comments that may be treated as code, typically for debugging purposes</source>
          <target state="translated">일반적으로 디버깅 목적으로 코드로 취급 될 수있는 주석</target>
        </trans-unit>
        <trans-unit id="2fd8ee31128a27c3741cf64157f9abf402269ba4" translate="yes" xml:space="preserve">
          <source>Compatible Binary Integer</source>
          <target state="translated">호환되는 이진 정수</target>
        </trans-unit>
        <trans-unit id="da8cf05ee405cd9a986668c8c46c9a8e120fd720" translate="yes" xml:space="preserve">
          <source>Compilation Group</source>
          <target state="translated">편집 그룹</target>
        </trans-unit>
        <trans-unit id="96cd345d12b5b7ca5ae139bb77e1a9c53007e491" translate="yes" xml:space="preserve">
          <source>Compilation Unit</source>
          <target state="translated">컴파일 유닛</target>
        </trans-unit>
        <trans-unit id="e859ddacb886ecaac3920b7f115299577527697c" translate="yes" xml:space="preserve">
          <source>Compilations may be performed to generate dynamically-loadable modules (or dynamically-loadable libraries, as they are frequently called). These compilations are performed by using the&lt;code&gt;-m&lt;/code&gt;switch</source>
          <target state="translated">동적으로로드 가능한 모듈 (또는 자주 호출되는 동적으로로드 가능한 라이브러리)을 생성하기 위해 컴파일이 수행 될 수 있습니다. 이러한 컴파일은 &lt;code&gt;-m&lt;/code&gt; 스위치 를 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="6218c92ed166d6dee1c3823d57775cd989a17afa" translate="yes" xml:space="preserve">
          <source>Compile this program as follows (the assumption is made that you are executing the&lt;code&gt;cobc&lt;/code&gt;command from the directory in which the above program source code (subvsindex.cbl) exists.</source>
          <target state="translated">이 프로그램을 다음과 같이 컴파일하십시오 ( 위의 프로그램 소스 코드 (subvsindex.cbl)가 존재하는 디렉토리에서 &lt;code&gt;cobc&lt;/code&gt; 명령을 실행한다고 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="c4e180aae5f5ffed0f5284c8c7daee050f8017a2" translate="yes" xml:space="preserve">
          <source>Compiler directives are</source>
          <target state="translated">컴파일러 지시문은</target>
        </trans-unit>
        <trans-unit id="746fe304b6da04f2948db99dc5a6735e74cebf7a" translate="yes" xml:space="preserve">
          <source>Complete GnuCOBOL Program Syntax</source>
          <target state="translated">완전한 GnuCOBOL 프로그램 구문</target>
        </trans-unit>
        <trans-unit id="e0f7f8b906be02847bd6c0bc57ead1c617c67102" translate="yes" xml:space="preserve">
          <source>Complex-Syntax-Clause</source>
          <target state="translated">Complex-Syntax-Clause</target>
        </trans-unit>
        <trans-unit id="8e66b8e5477316fe83d734c891de408f9f788241" translate="yes" xml:space="preserve">
          <source>Computer scientists will compare the two techniques implemented by the&lt;code&gt;SEARCH&lt;/code&gt;and&lt;code&gt;SEARCH ALL&lt;/code&gt;statements as follows:</source>
          <target state="translated">컴퓨터 과학자는 &lt;code&gt;SEARCH&lt;/code&gt; 및 &lt;code&gt;SEARCH ALL&lt;/code&gt; 문으로 구현 된 두 가지 기술 을 다음과 같이 비교합니다.</target>
        </trans-unit>
        <trans-unit id="333d34a78170ebdea1656c8398a11eab37b54584" translate="yes" xml:space="preserve">
          <source>Condition names are Boolean (i.e. TRUE / FALSE) data items that receive their TRUE and FALSE values based upon the values of the non 88-level data item whose definition they immediately follow.</source>
          <target state="translated">조건 이름은 정의가 바로 따르는 88 레벨이 아닌 데이터 항목의 값을 기반으로 TRUE 및 FALSE 값을받는 부울 (예 : TRUE / FALSE) 데이터 항목입니다.</target>
        </trans-unit>
        <trans-unit id="c87464dfce9a9aff3851d0944fefb1558383352f" translate="yes" xml:space="preserve">
          <source>Condition names are always defined subordinate to another (non 88-level) data item. That data item must be an elementary item. Whenever the parent data item assumes one of the values specified on the 88-level item&amp;rsquo;s&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause, &amp;lt;</source>
          <target state="translated">조건 이름은 항상 다른 (88 수준이 아닌) 데이터 항목에 종속적으로 정의됩니다. 해당 데이터 항목은 기본 항목이어야합니다. 상위 데이터 항목이 88 수준 항목의 &lt;code&gt;VALUE&lt;/code&gt; ( &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt; 참조 ) 절에 지정된 값 중 하나를 가정 할 때마다 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="027a11b37533ca20669bb17281d210c5767e61eb" translate="yes" xml:space="preserve">
          <source>Condition names do not occupy any storage.</source>
          <target state="translated">조건 이름은 스토리지를 차지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="300654fa157f6c6e091010b7777c8e3f6af9ccc2" translate="yes" xml:space="preserve">
          <source>Conflicting attribute</source>
          <target state="translated">충돌하는 속성</target>
        </trans-unit>
        <trans-unit id="bd243da61bc83e255c691b0eeb1676f5cf315d17" translate="yes" xml:space="preserve">
          <source>Consider</source>
          <target state="translated">Consider</target>
        </trans-unit>
        <trans-unit id="fdb2d9eaefe67e778b752e4f472db4c9da926388" translate="yes" xml:space="preserve">
          <source>Consider including a trailing descriptor of the nature of all data items in their names. The following chart presents a variety of such descriptors the author has encountered and used through the years.</source>
          <target state="translated">이름에 모든 데이터 항목의 특성에 대한 후미 설명자를 포함시키는 것을 고려하십시오. 다음 차트는 저자가 여러 해 동안 접해 왔던 다양한 설명자를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="49ad35a272291924fe1567effd78bef2707d1787" translate="yes" xml:space="preserve">
          <source>Consider including an acronym to be inserted into the name of any data item defined directly or indirectly subordinate to an 01-level item, typically to be specified after any section-level tag, if you&amp;rsquo;re using them. For example, consider the names used in the following structure:</source>
          <target state="translated">01 레벨 항목에 직간접 적으로 정의 된 데이터 항목의 이름에 약어를 포함하는 것을 고려하십시오 (일반적으로 섹션 레벨 태그를 사용하는 경우). 예를 들어, 다음 구조에서 사용 된 이름을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="474092c4530711a5712f2088d0c7006e1c6ea236" translate="yes" xml:space="preserve">
          <source>Consider using&lt;code&gt;SET ENVIRONMENT&lt;/code&gt;(see &lt;a href=&quot;#SET-ENVIRONMENT&quot;&gt;SET ENVIRONMENT&lt;/a&gt;) in lieu of&lt;code&gt;DISPLAY&lt;/code&gt;to set environment variables as it is much simpler.</source>
          <target state="translated">사용을 고려 &lt;code&gt;SET ENVIRONMENT&lt;/code&gt; 합니다 ( &lt;a href=&quot;#SET-ENVIRONMENT&quot;&gt;SET 환경을&lt;/a&gt; 대신) &lt;code&gt;DISPLAY&lt;/code&gt; 가 훨씬 간단로 설정 환경 변수.</target>
        </trans-unit>
        <trans-unit id="cd60aa178f4b05c8b4e18662c70566d29b29c05b" translate="yes" xml:space="preserve">
          <source>Console output when run (user input follows the colons on the prompts for input):</source>
          <target state="translated">실행시 콘솔 출력 (사용자 입력은 입력 프롬프트에서 콜론을 따릅니다) :</target>
        </trans-unit>
        <trans-unit id="482dcfb6a26e7cc8dbfee8b9c6882a08cb82b778" translate="yes" xml:space="preserve">
          <source>Constants defined in this way become undefined once an&lt;code&gt;END PROGRAM&lt;/code&gt;or&lt;code&gt;END FUNCTION&lt;/code&gt;is encountered in the input source.</source>
          <target state="translated">이 방법으로 정의 된 상수 는 입력 소스에서 &lt;code&gt;END PROGRAM&lt;/code&gt; 또는 &lt;code&gt;END FUNCTION&lt;/code&gt; 이 발생 하면 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="97f677ffe8002bb978e6196b88b1b9221d3315cd" translate="yes" xml:space="preserve">
          <source>Consult the documentation on the</source>
          <target state="translated">의 설명서를 참조하십시오</target>
        </trans-unit>
        <trans-unit id="ee9d7834b4e03028e401f780d9d177af07cb943c" translate="yes" xml:space="preserve">
          <source>Contain a leading numeric component (for example:&lt;code&gt;2000-Update-Customer&lt;/code&gt;, AND&amp;hellip;</source>
          <target state="translated">선행 숫자 구성 요소를 포함합니다 (예 : &lt;code&gt;2000-Update-Customer&lt;/code&gt; , AND&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="d504f89e29051ac2c61a4e1307b823272b01fbfa" translate="yes" xml:space="preserve">
          <source>Contained Subprograms</source>
          <target state="translated">포함 된 서브 프로그램</target>
        </trans-unit>
        <trans-unit id="32b3d87c6ceda12546f190f2210a22df0cdf6e15" translate="yes" xml:space="preserve">
          <source>Contrast this function with the&lt;code&gt;BYTE-LENGTH&lt;/code&gt;(see &lt;a href=&quot;#BYTE_002dLENGTH&quot;&gt;BYTE-LENGTH&lt;/a&gt;) and&lt;code&gt;LENGTH-AN&lt;/code&gt;(see &lt;a href=&quot;#LENGTH_002dAN&quot;&gt;LENGTH-AN&lt;/a&gt;) functions.</source>
          <target state="translated">이 함수 대조 &lt;code&gt;BYTE-LENGTH&lt;/code&gt; (참조 &lt;a href=&quot;#BYTE_002dLENGTH&quot;&gt;BYTE 길이&lt;/a&gt; 등) &lt;code&gt;LENGTH-AN&lt;/code&gt; (참조 &lt;a href=&quot;#LENGTH_002dAN&quot;&gt;길이&lt;/a&gt; 기능).</target>
        </trans-unit>
        <trans-unit id="c13b5b85342bf60c0e7b3cad62d98a00d84bed25" translate="yes" xml:space="preserve">
          <source>Contrast this with the&lt;code&gt;LENGTH&lt;/code&gt;(see &lt;a href=&quot;#LENGTH&quot;&gt;LENGTH&lt;/a&gt;) function.</source>
          <target state="translated">이것을 &lt;code&gt;LENGTH&lt;/code&gt; ( &lt;a href=&quot;#LENGTH&quot;&gt;LENGTH&lt;/a&gt; 참조 ) 함수 와 대조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="d864d1d594bb58da63124b3e532077a2280da211" translate="yes" xml:space="preserve">
          <source>Control Break</source>
          <target state="translated">컨트롤 브레이크</target>
        </trans-unit>
        <trans-unit id="e707dbac72bfee188a71125817eb3d24f8da1780" translate="yes" xml:space="preserve">
          <source>Control Field</source>
          <target state="translated">컨트롤 필드</target>
        </trans-unit>
        <trans-unit id="960257afeb12f77fa6f8f055108e92a370b0072a" translate="yes" xml:space="preserve">
          <source>Control Footing</source>
          <target state="translated">기초 조정</target>
        </trans-unit>
        <trans-unit id="b37055601ddd24b634819c08af5e0ee3aec0c2f5" translate="yes" xml:space="preserve">
          <source>Control Heading</source>
          <target state="translated">제어 제목</target>
        </trans-unit>
        <trans-unit id="3089ab53c60beb89e389be8470443c8bae92e074" translate="yes" xml:space="preserve">
          <source>Control Hierarchy</source>
          <target state="translated">제어 계층</target>
        </trans-unit>
        <trans-unit id="1bef2ffd2d898c95784379f9d8d159b85d5b9c39" translate="yes" xml:space="preserve">
          <source>Control will return back to the&lt;code&gt;PERFORM&lt;/code&gt; where &amp;mdash; if&lt;code&gt;WITH TEST AFTER&lt;/code&gt;was specified &amp;mdash; &amp;lt;</source>
          <target state="translated">&lt;code&gt;WITH TEST AFTER&lt;/code&gt; 가 지정된 경우 제어는 &lt;code&gt;PERFORM&lt;/code&gt; 으로 되돌아갑니다. &amp;lt;</target>
        </trans-unit>
        <trans-unit id="6b631a4ffc81ee3a9a3caa199af3dfcb4b9eebb2" translate="yes" xml:space="preserve">
          <source>Control will then proceed to the statement following the&lt;code&gt;END-EVALUATE&lt;/code&gt;or the first statement that follows the next period if there is no&lt;code&gt;END-EVALUATE&lt;/code&gt; If,however, the &amp;lt;</source>
          <target state="translated">제어는 다음 문으로 진행됩니다 &lt;code&gt;END-EVALUATE&lt;/code&gt; 더가없는 경우에는 다음 기간을 다음 첫 번째 문 &lt;code&gt;END-EVALUATE&lt;/code&gt; 경우에는, 그러나, &amp;lt;</target>
        </trans-unit>
        <trans-unit id="6821ab076fc8e4c97eea6b8244b17e70476d24ee" translate="yes" xml:space="preserve">
          <source>Controlling the pagination of reports, including:</source>
          <target state="translated">다음을 포함하여 보고서의 페이지 매김 제어</target>
        </trans-unit>
        <trans-unit id="7dd804bb2edf5c6b71e08057b1fe7806375aa80d" translate="yes" xml:space="preserve">
          <source>Copybook</source>
          <target state="translated">Copybook</target>
        </trans-unit>
        <trans-unit id="e2aa0e7c3bd507e669da6cc819890494774937c3" translate="yes" xml:space="preserve">
          <source>Copybooks containing code intended for the identification division. These will be rare as you almost never encounter copied code in the identification division.</source>
          <target state="translated">식별 부서 용 코드가 포함 된 카피 북 식별 부서에서 복사 된 코드가 거의 발생하지 않기 때문에 이러한 경우는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="ae4bb1674f81c29f3e27ad4dcb083e8655d69118" translate="yes" xml:space="preserve">
          <source>Copybooks containing code intended for use in the environment division. These copybooks are generally used for predefined&lt;code&gt;SPECIAL-NAMES&lt;/code&gt;(see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) or&lt;code&gt;FILE-CONTROL&lt;/code&gt;(see &lt;a href=&quot;#INPUT_002dOUTPUT-SECTION&quot;&gt;INPUT-OUTPUT SECTION&lt;/a&gt;) syntax,</source>
          <target state="translated">환경 부서에서 사용하기위한 코드가 들어있는 카피 북. 이러한 카피 북은 일반적으로 사전 정의 된 사용되는 &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; (참조 &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL - 이름&lt;/a&gt; 또는) &lt;code&gt;FILE-CONTROL&lt;/code&gt; 는 (참조 &lt;a href=&quot;#INPUT_002dOUTPUT-SECTION&quot;&gt;입출력 SECTION&lt;/a&gt; , 구문)</target>
        </trans-unit>
        <trans-unit id="2518777d2abfc517966e28f0596ae3116363bcc5" translate="yes" xml:space="preserve">
          <source>Copybooks that contain data definitions.</source>
          <target state="translated">데이터 정의가 포함 된 카피 북</target>
        </trans-unit>
        <trans-unit id="752aff643f4fc290408c7437031076a71eebc79b" translate="yes" xml:space="preserve">
          <source>Copybooks that contain executable instructions.</source>
          <target state="translated">실행 가능한 지침이 포함 된 카피 북</target>
        </trans-unit>
        <trans-unit id="b6a8b5660c828f3b2c93bf54e7099762c731d4dd" translate="yes" xml:space="preserve">
          <source>Copying files</source>
          <target state="translated">파일 복사</target>
        </trans-unit>
        <trans-unit id="154784820baffd42626a2bcde20aa0381aaae095" translate="yes" xml:space="preserve">
          <source>Copyright &amp;copy; 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb54a4d008dbbbce9c32d6cda871fb64051a8eba" translate="yes" xml:space="preserve">
          <source>Could be abbreviated as:</source>
          <target state="translated">다음과 같이 축약 될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="8e7fb87ed35f3e95693d0d85ac2e5bb078a3fccb" translate="yes" xml:space="preserve">
          <source>Creating a directory</source>
          <target state="translated">디렉토리 만들기</target>
        </trans-unit>
        <trans-unit id="364920436a8c309c1b52c0fc8087c58a7ed12784" translate="yes" xml:space="preserve">
          <source>Creating, Opening, Closing, Reading and Writing byte-stream files</source>
          <target state="translated">바이트 스트림 파일 작성, 열기, 닫기, 읽기 및 쓰기</target>
        </trans-unit>
        <trans-unit id="03cc92b2de6a93842702049006d74479339df02c" translate="yes" xml:space="preserve">
          <source>Current date in Gregorian form</source>
          <target state="translated">그레고리 안 형식의 현재 날짜</target>
        </trans-unit>
        <trans-unit id="1ff8e9efb80c4e62bf5d39a66f9af66f72010f2d" translate="yes" xml:space="preserve">
          <source>Current date in Julian form</source>
          <target state="translated">줄리안 형태의 현재 날짜</target>
        </trans-unit>
        <trans-unit id="38570a962a72c984faa65f99b9fe8bbed297680c" translate="yes" xml:space="preserve">
          <source>Current programming philosophy would prefer the use of the&lt;code&gt;EVALUATE&lt;/code&gt;statement to that of this form of the&lt;code&gt;GO TO&lt;/code&gt;statement.</source>
          <target state="translated">현재 프로그래밍 철학은 &lt;code&gt;EVALUATE&lt;/code&gt; 문을이 형태의 &lt;code&gt;GO TO&lt;/code&gt; 문에 사용하는 것을 선호합니다 .</target>
        </trans-unit>
        <trans-unit id="176c3c5df0bbd0c7ccd68b1562b9f4c3348a64ae" translate="yes" xml:space="preserve">
          <source>Currently, the only allowable value for the flags argument is 0. This argument may be specified either as a numeric literal or as a&lt;code&gt;PIC X(1) USAGE COMP-X&lt;/code&gt;data item.</source>
          <target state="translated">현재 flags 인수에 허용되는 유일한 값은 0입니다.이 인수는 숫자 리터럴 또는 &lt;code&gt;PIC X(1) USAGE COMP-X&lt;/code&gt; 데이터 항목 으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="93fe007c4c23a7d4870c091f49c3529c51d38ef8" translate="yes" xml:space="preserve">
          <source>Cyan (Turquoise): COB-COLOR-CYAN</source>
          <target state="translated">청록색 (청록색) : COB-COLOR-CYAN</target>
        </trans-unit>
        <trans-unit id="d2b0ee310620d9febc825ce9071e2fb5b6a37cd7" translate="yes" xml:space="preserve">
          <source>D/d</source>
          <target state="translated">D/d</target>
        </trans-unit>
        <trans-unit id="cacf54f34dffa98ab8fe95ec01049b87cf34a8a2" translate="yes" xml:space="preserve">
          <source>DATA DIVISION Syntax</source>
          <target state="translated">데이터 분할 구문</target>
        </trans-unit>
        <trans-unit id="ef1ab2c530e1e7a4a273bb9ed22fe35098c7702a" translate="yes" xml:space="preserve">
          <source>DATA, DATA-POINTER, DATE, DATE-COMPILED, DATE-MODIFIED, DATE-OF-INTEGER, DATE-TO-YYYYMMDD, DATE-WRITTEN, DAY, DAY-OF-INTEGER, DAY-OF-WEEK, DAY-TO-YYYYDDD, DE, DEBUGGING, DECIMAL-POINT, DECLARATIVES, DEFAULT, DELETE, DELIMITED, DELIMITER, DEPENDING, DESCENDING, DESTINATION, DETAIL, DISABLE, DISC, DISK, DISPLAY, DISPLAY-OF, DIVIDE, DIVISION, DOWN, DUPLICATES, DYNAMIC</source>
          <target state="translated">DATA, DATA-POINTER, DATE, DATE-COMPILED, DATE-MODIFIED, DATE-OF-INTEGER, DATE-TO-YYYYMMDD, DATE-WRITTEN, DAY, OF-INTEGER, DAY-OF-WEEK, DAY-TO-WEEK YYYYDDD, DE, DEBUGGING, DECIMAL-POINT, DECLARATIVES, DEFAULT, DELETE, DELIMITED, DELIMITER, DEPENDING, DESCENDING, DESTINATION, DETAIL, DISABLE, DISC, DISK, DISPLAY, DISPLAY-OF, DIVIDE, DIVISION, DOWN, DDYLICATES</target>
        </trans-unit>
        <trans-unit id="9a7769dbf47324c33f9163090c128fdce266a34c" translate="yes" xml:space="preserve">
          <source>DATE-OF-INTEGER Function Syntax</source>
          <target state="translated">DATE-OF-INTEGER 함수 구문</target>
        </trans-unit>
        <trans-unit id="de2d56241f31b520010f3bce0b98db0bbbf5b2cb" translate="yes" xml:space="preserve">
          <source>DATE-TO-YYYYMMDD Function Syntax</source>
          <target state="translated">DATE-TO-YYYYMMDD 함수 구문</target>
        </trans-unit>
        <trans-unit id="39bcedb8c2b80fd139b489090f66d6091874fd22" translate="yes" xml:space="preserve">
          <source>DAY-OF-INTEGER Function Syntax</source>
          <target state="translated">DAY-OF-INTEGER 함수 구문</target>
        </trans-unit>
        <trans-unit id="2bf1dfe2e631bd8b0d7dad6f48c0cacb9a884526" translate="yes" xml:space="preserve">
          <source>DAY-TO-YYYYDDD Function Syntax</source>
          <target state="translated">DAY-TO-YYYYDDD 함수 구문</target>
        </trans-unit>
        <trans-unit id="025121e8c60ec006f18d8b8d88589c258c15c1d7" translate="yes" xml:space="preserve">
          <source>DDDDEEEEEE</source>
          <target state="translated">DDDDEEEEEE</target>
        </trans-unit>
        <trans-unit id="86bb1aaff76c60b46fc6063e792d77c4344339b1" translate="yes" xml:space="preserve">
          <source>DECLARATIVES Syntax</source>
          <target state="translated">선언적 구문</target>
        </trans-unit>
        <trans-unit id="143eef2ea0db77ce833000c49d3c0b7fd423279e" translate="yes" xml:space="preserve">
          <source>DELETE Syntax</source>
          <target state="translated">삭제 구문</target>
        </trans-unit>
        <trans-unit id="3a15730e7f841dfe68e53a32b12047839a2d3fb6" translate="yes" xml:space="preserve">
          <source>DETAIL GROUP(S) [2]</source>
          <target state="translated">상세 그룹 (2) [2]</target>
        </trans-unit>
        <trans-unit id="4f10c1a7a81f590cb0c5833f5f9e81467169d145" translate="yes" xml:space="preserve">
          <source>DISPLAY UPON COMMAND-LINE Syntax</source>
          <target state="translated">명령 행 구문 표시 구문</target>
        </trans-unit>
        <trans-unit id="adda0092f73a761f60d98ab42f5c7b4bba54e2d5" translate="yes" xml:space="preserve">
          <source>DISPLAY UPON ENVIRONMENT-NAME Syntax</source>
          <target state="translated">ENVIRONMENT-NAME 구문 표시</target>
        </trans-unit>
        <trans-unit id="dc0e227d85b3e8e67592171973f030e41c7ab926" translate="yes" xml:space="preserve">
          <source>DISPLAY UPON device Syntax</source>
          <target state="translated">DISPLAY UPON 장치 구문</target>
        </trans-unit>
        <trans-unit id="6145b9122a8e41c787d9431bd205fd12fd53c5a1" translate="yes" xml:space="preserve">
          <source>DISPLAY screen-data-item Syntax</source>
          <target state="translated">DISPLAY 화면 데이터 항목 구문</target>
        </trans-unit>
        <trans-unit id="c274523a24ad6574ea39bdfb176f7732c4c4c3d8" translate="yes" xml:space="preserve">
          <source>DIVIDE BY GIVING Syntax</source>
          <target state="translated">GIVING 구문으로 나누기</target>
        </trans-unit>
        <trans-unit id="1719d6e667413941c4bdcd1de4638431f43816ff" translate="yes" xml:space="preserve">
          <source>DIVIDE INTO GIVING Syntax</source>
          <target state="translated">GIVING 구문으로 나누기</target>
        </trans-unit>
        <trans-unit id="b020f4b6ba07306586627a0af3f4509d6885ff83" translate="yes" xml:space="preserve">
          <source>DIVIDE INTO Syntax</source>
          <target state="translated">구문으로 나누기</target>
        </trans-unit>
        <trans-unit id="542d08c7255dff568bdff9294205546046c0a7c5" translate="yes" xml:space="preserve">
          <source>Data Item</source>
          <target state="translated">데이터 아이템</target>
        </trans-unit>
        <trans-unit id="b5ab5631945fc781f3a554ec97b7ea5c28882fb6" translate="yes" xml:space="preserve">
          <source>Data Retrieved</source>
          <target state="translated">검색된 데이터</target>
        </trans-unit>
        <trans-unit id="86ce25bf2c845338976617d76d9424c933ce8444" translate="yes" xml:space="preserve">
          <source>Data descriptions of this form do not actually allocate any storage &amp;mdash; they merely define a name (&amp;lt;</source>
          <target state="translated">이 형식의 데이터 설명은 실제로 스토리지를 할당하지 않으며 단지 이름을 정의합니다 (&amp;lt;</target>
        </trans-unit>
        <trans-unit id="e82b1d0242f8c91a364756e74c764b6e3af9b59f" translate="yes" xml:space="preserve">
          <source>Data items declared with the&lt;code&gt;ANY LENGTH&lt;/code&gt;attribute have no fixed compile-time length. Such items may only be defined in the linkage section of a subprogram as they may only serve as subroutine argument descriptions. These items must have a&lt;code&gt;PICTURE&lt;/code&gt;(see &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt;) clause that specifies exactly one A, X or 9 symbol.</source>
          <target state="translated">&lt;code&gt;ANY LENGTH&lt;/code&gt; 속성으로 선언 된 데이터 항목 에는 고정 컴파일 시간 길이가 없습니다. 이러한 항목은 서브 루틴 인수 설명으로 만 사용될 수 있으므로 서브 프로그램의 링크 섹션에서만 정의 될 수 있습니다. 이 항목은이 있어야 &lt;code&gt;PICTURE&lt;/code&gt; (참조 &lt;a href=&quot;#PICTURE&quot;&gt;사진&lt;/a&gt; ) 절을 지정 정확히 하나의 A, X 또는 9 기호가.</target>
        </trans-unit>
        <trans-unit id="8ff9e95bc3e45b129ac52c4861ceb28707b8b1d0" translate="yes" xml:space="preserve">
          <source>Data items declared with&lt;code&gt;BASED&lt;/code&gt;are allocated no storage at compilation time. At run-time, the&lt;code&gt;ALLOCATE&lt;/code&gt;(see &lt;a href=&quot;#ALLOCATE&quot;&gt;ALLOCATE&lt;/a&gt;) or&lt;code&gt;SET ADDRESS&lt;/code&gt;(see &lt;a href=&quot;#SET-ADDRESS&quot;&gt;SET ADDRESS&lt;/a&gt;) statements are used to allocate space for and (optionally) initialize such items.</source>
          <target state="translated">&lt;code&gt;BASED&lt;/code&gt; 로 선언 된 데이터 항목 에는 컴파일시 스토리지가 할당되지 않습니다. 런타임에서,이 &lt;code&gt;ALLOCATE&lt;/code&gt; (참조 &lt;a href=&quot;#ALLOCATE&quot;&gt;ALLOCATE&lt;/a&gt; ) 또는 &lt;code&gt;SET ADDRESS&lt;/code&gt; (참조 &lt;a href=&quot;#SET-ADDRESS&quot;&gt;SET 주소를&lt;/a&gt; ) 문에 대한 (선택 사항) 공간을 할당하는 데 사용되는이 같은 항목을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="3884223bd8738175ccb76e30292953182185f26d" translate="yes" xml:space="preserve">
          <source>Data items defined in a calling program may be passed to either type of called program (subroutine or user-defined function) as arguments.</source>
          <target state="translated">호출 프로그램에 정의 된 데이터 항목은 호출 된 프로그램 유형 (서브 루틴 또는 사용자 정의 함수)에 인수로 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b6be4a0a08f89796b4ca060304e3df78e6642bf" translate="yes" xml:space="preserve">
          <source>Data items defined in the screen section describe input, output or combination screen layouts to be used with&lt;code&gt;ACCEPT screen-data-item&lt;/code&gt;statement (see &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;) or&lt;code&gt;DISPLAY screen-data-item&lt;/code&gt;statement (see &lt;a href=&quot;#DISPLAY-screen_002ddata_002ditem&quot;&gt;DISPLAY screen-data-item&lt;/a&gt;) statements. These screen layouts may define the entire available screen area or any subset of it.</source>
          <target state="translated">화면 섹션에 정의 된 데이터 항목은 &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; 명령문 ( &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT 화면 데이터 항목 참조&lt;/a&gt; ) 또는 &lt;code&gt;DISPLAY screen-data-item&lt;/code&gt; 명령문 ( &lt;a href=&quot;#DISPLAY-screen_002ddata_002ditem&quot;&gt;DISPLAY 화면 &lt;/a&gt;데이터 항목 참조) 과 함께 사용할 입력, 출력 또는 조합 화면 레이아웃을 설명합니다. 항목 ) 진술. 이러한 화면 레이아웃은 사용 가능한 전체 화면 영역 또는 그 일부를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b209ac3623f15088290faf41d529558938a6bd3" translate="yes" xml:space="preserve">
          <source>Data items defined within the working-storage section are automatically initialized once &amp;mdash; as the program in which the data is defined is loaded into memory. Subprograms may be loaded into memory more than once (see the&lt;code&gt;CANCEL&lt;/code&gt;statement (see &lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt;)), in which case initialization will happen each time they are loaded. See &lt;a href=&quot;#Data-Initialization&quot;&gt;Data Initialization&lt;/a&gt;, for a discussion of the initialization rules.</source>
          <target state="translated">작업 스토리지 섹션에 정의 된 데이터 항목은 데이터가 정의 된 프로그램이 메모리에로드되므로 자동으로 한 번 초기화됩니다. 서브 프로그램은 메모리에 두 번 이상로드 될 수 있습니다 ( &lt;code&gt;CANCEL&lt;/code&gt; 문 ( &lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt; 참조 ) 참조 ).이 경우로드 될 때마다 초기화가 수행됩니다. 초기화 규칙에 대한 설명은 &lt;a href=&quot;#Data-Initialization&quot;&gt;데이터 초기화를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4eb8574d2d5270d2d786dec0a24f5040d14d6919" translate="yes" xml:space="preserve">
          <source>Data items that have the&lt;code&gt;UNSIGNED&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;UNSIGNED&lt;/code&gt; 가있는 데이터 항목</target>
        </trans-unit>
        <trans-unit id="b9af005425ba8ce8de1a932e2c2f2ab684e4ed8c" translate="yes" xml:space="preserve">
          <source>Data items with an explicit&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause in their definition will be initialized to that specific value.</source>
          <target state="translated">명시 적으로 데이터 항목 &lt;code&gt;VALUE&lt;/code&gt; (참조 &lt;a href=&quot;#VALUE&quot;&gt;VALUE를&lt;/a&gt; 자신의 정의) 절은 특정 값으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="25d47c3faf24644ac0e22641a7e663390a36c7aa" translate="yes" xml:space="preserve">
          <source>Data items with level numbers 01 (Constants), 66, 78 and 88 may be used in the screen section; they have the same syntax, rules and usage as they do in the other data division sections.</source>
          <target state="translated">레벨 번호 01 (상수), 66, 78 및 88의 데이터 항목이 화면 섹션에 사용될 수 있습니다. 다른 데이터 분할 섹션에서와 동일한 구문, 규칙 및 사용법을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="3f037b50f5ed4565ce4707a24021f4f6ad083ed5" translate="yes" xml:space="preserve">
          <source>Data-pointer contains an address that is out of bounds</source>
          <target state="translated">데이터 포인터에 범위를 벗어난 주소가 포함되어 있습니다</target>
        </trans-unit>
        <trans-unit id="874809dfddadcc0363d1a9a37ac20f4611145b1a" translate="yes" xml:space="preserve">
          <source>Declarative procedures may not reference any other procedures defined outside the scope of DECLARATIVES.</source>
          <target state="translated">선언적 절차는 선언의 범위 밖에서 정의 된 다른 절차를 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d14e2f78a3303228220a36dc985b5fd5e385137b" translate="yes" xml:space="preserve">
          <source>Defined by the quantity of&lt;code&gt;9&lt;/code&gt; and the presence or absence of an&lt;code&gt;S&lt;/code&gt;in the PICTURE</source>
          <target state="translated">의 금액에서 정의 &lt;code&gt;9&lt;/code&gt; 와의 유무 &lt;code&gt;S&lt;/code&gt; 그림에</target>
        </trans-unit>
        <trans-unit id="1e681574ae7448c8ae4c05d776be5265b2dc953d" translate="yes" xml:space="preserve">
          <source>Defined by the quantity of&lt;code&gt;9&lt;/code&gt; and the presence or absence of an&lt;code&gt;S&lt;/code&gt;in the&lt;code&gt;PICTURE&lt;/code&gt;</source>
          <target state="translated">의 금액에서 정의 &lt;code&gt;9&lt;/code&gt; 와의 유무 &lt;code&gt;S&lt;/code&gt; 에 &lt;code&gt;PICTURE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3721726af464447c08ddb23c2de0ce50d614e3dd" translate="yes" xml:space="preserve">
          <source>Defines an implied digit position that will be considered to be a zero when the data item is referenced at run-time. This symbol is used to allow data items that will contain very large values to be allocated using less storage by assuming a certain number of trailing zeros (one per&lt;code&gt;P&lt;/code&gt; to exist at the end of values.</source>
          <target state="translated">데이터 항목이 런타임에 참조 될 때 0으로 간주 될 암시 적 숫자 위치를 정의합니다. 이 기호는 특정 수의 후행 0 ( 값의 끝에 &lt;code&gt;P&lt;/code&gt; 당 하나씩 있음)을 가정하여 매우 큰 값을 포함하는 데이터 항목을 적은 스토리지를 사용하여 할당 할 수 있도록하는 데 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="d2dadb60fe73f669fa3a07340c506372af50e9c1" translate="yes" xml:space="preserve">
          <source>Defines storage reserved for a single alphabetic character &lt;code&gt;A&lt;/code&gt;&lt;code&gt;Z&lt;/code&gt;&lt;code&gt;a&lt;/code&gt;&lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">단일 영문자 &lt;code&gt;A&lt;/code&gt; &lt;code&gt;Z&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;z&lt;/code&gt; 로 예약 된 스토리지를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="cc276340305e669eb0c75e2233fed96937f0eb10" translate="yes" xml:space="preserve">
          <source>Defines storage reserved for a single alphanumeric character (any character).</source>
          <target state="translated">단일 영숫자 문자 (모든 문자)를 위해 예약 된 스토리지를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="9157b25b7fe6ae0f7d0e3ba566a50c8e263af1e0" translate="yes" xml:space="preserve">
          <source>Defines storage reserved for a single character in the computer&amp;rsquo;s &amp;rsquo;</source>
          <target state="translated">컴퓨터의 '에서 단일 문자 용으로 예약 된 스토리지를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="94ae1e544866ccd53a2d46a1a530f0a06f98b727" translate="yes" xml:space="preserve">
          <source>Defines storage reserved for a single numeric digit character &lt;code&gt;0&lt;/code&gt;&lt;code&gt;9&lt;/code&gt;.</source>
          <target state="translated">단일 숫자 숫자 문자 &lt;code&gt;0&lt;/code&gt; &lt;code&gt;9&lt;/code&gt; 에 예약 된 스토리지를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="4c35955c5a43713921be58f39b4f9f08b952ef23" translate="yes" xml:space="preserve">
          <source>Defining a control hierarchy (via&lt;code&gt;CONTROLS ARE&lt;/code&gt; that does not match the actual sequence in which data will be processed is a great way to guarantee a &quot;broken&quot; report. I&amp;rsquo;ll show you an example in a later section.</source>
          <target state="translated">데이터가 처리되는 실제 순서와 일치하지 않는 &lt;code&gt;CONTROLS ARE&lt;/code&gt; 를 통해 제어 계층 정의는 &quot;손상된&quot;보고서를 보장하는 좋은 방법입니다. 나중 섹션에서 예제를 보여 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="86f4d7d5ec62e8d3cd6d42936730cd899552e6b1" translate="yes" xml:space="preserve">
          <source>Deleting directories (folders)</source>
          <target state="translated">디렉토리 (폴더) 삭제</target>
        </trans-unit>
        <trans-unit id="184170aedafad0bad24b165d0963d2623119dff1" translate="yes" xml:space="preserve">
          <source>Deleting files</source>
          <target state="translated">파일 삭제</target>
        </trans-unit>
        <trans-unit id="a300dcf45b8bb3ac35bf8bf6fa05fb9627dec545" translate="yes" xml:space="preserve">
          <source>Depending upon which source format mode the compiler is in, you will need to follow various rules for the format mode currently in effect. These rules are presented in the upcoming paragraphs.</source>
          <target state="translated">컴파일러가 어떤 소스 형식 모드에 있는지에 따라 현재 유효한 형식 모드에 대한 다양한 규칙을 따라야합니다. 이 규칙은 다음 단락에 제시되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1d3403c95ff976211a614c7aff47a8b06f0d474" translate="yes" xml:space="preserve">
          <source>Depends on number of&lt;code&gt;9&lt;/code&gt; in the&lt;code&gt;PICTURE&lt;/code&gt;and the&lt;code&gt;binary-size&lt;/code&gt;setting of the configuration file used to compile the program</source>
          <target state="translated">의 수에 따라 &lt;code&gt;9&lt;/code&gt; 의 &lt;code&gt;PICTURE&lt;/code&gt; 과 &lt;code&gt;binary-size&lt;/code&gt; 구성 파일의 설정은 프로그램을 컴파일하는 데 사용</target>
        </trans-unit>
        <trans-unit id="8f554af0cabf84f3acc6bcb170a806e225d3ade1" translate="yes" xml:space="preserve">
          <source>Depends on&lt;code&gt;PICTURE&lt;/code&gt; One character per X, A, 9, period, $, Z, 0, *, S (if&lt;code&gt;SEPARATE CHARACTER&lt;/code&gt;specified), +, - or B symbol in&lt;code&gt;PICTURE&lt;/code&gt; Add 2 more bytes if the&lt;code&gt;DB&lt;/code&gt;or&lt;code&gt;CR&lt;/code&gt;editing symbol is used</source>
          <target state="translated">에 따라 다릅니다 &lt;code&gt;PICTURE&lt;/code&gt; - (경우 X, A, 9, 기간, $, Z, 0 당 하나 개의 캐릭터가, *, S는 &lt;code&gt;SEPARATE CHARACTER&lt;/code&gt; 지정), +, -에서 B 기호 또는 &lt;code&gt;PICTURE&lt;/code&gt; 2 바이트 이상을 추가하면 &lt;code&gt;DB&lt;/code&gt; 또는 &lt;code&gt;CR&lt;/code&gt; 편집 기호 사용</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="a7bc7ee00f8b51dc232f39ec929df41c6a0ebda7" translate="yes" xml:space="preserve">
          <source>Despite what the name of this routine might make you believe, this routine is more than just a simple &quot;rename&quot; &amp;mdash; it will actually move the file supplied as the 1st argument to the file specified as the 2nd argument. Think of it as a two-step sequence, first copying the &amp;lt;</source>
          <target state="translated">이 루틴의 이름이 당신을 믿게 만들 수도 있지만,이 루틴은 단순한 &quot;이름 바꾸기&quot;그 이상입니다. 실제로 첫 번째 인수로 제공된 파일을 두 번째 인수로 지정된 파일로 옮깁니다. 이를 2 단계 시퀀스로 생각하고 먼저 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="6dc01a0b93964e7ed3110112972c2448074cd5a5" translate="yes" xml:space="preserve">
          <source>Despite what you&amp;rsquo;ve seen here, the more complex the programming logic being implemented, the more concise the Java code will appear to be, even compared to 2002-standard COBOL. That conciseness comes with a price though &amp;mdash; program code readability. Java (or C or C++ or C#) programs are generally intelligible only to trained programmers. COBOL programs can, however, be quite understandable by non-programmers. This is actually a side-effect of the &quot;wordiness&quot; of the language, where COBOL statements use natural English words to describe their actions. This inherent readability has come in handy many times throughout my career when I&amp;rsquo;ve had to learn obscure business (or legal) processes by reading the COBOL program code that supports them.</source>
          <target state="translated">여기에서 보았지만 프로그래밍 로직이 복잡할수록 2002 표준 COBOL에 비해 Java 코드가 더 간결 해 보입니다. 이 간결함은 프로그램 코드 판독성이라는 가격과 함께 제공됩니다. Java (또는 C 또는 C ++ 또는 C #) 프로그램은 일반적으로 숙련 된 프로그래머 만 이해할 수 있습니다. 그러나 COBOL 프로그램은 비 프로그래머가 이해할 수 있습니다. 이것은 실제로 언어의 &quot;단어&quot;의 부작용이며, COBOL 문은 자연 영어 단어를 사용하여 동작을 설명합니다. 이 고유 한 가독성은 내가 지원하는 COBOL 프로그램 코드를 읽음으로써 모호한 비즈니스 (또는 법적) 프로세스를 배워야 할 때 내 경력 전반에 걸쳐 여러 번 유용했습니다.</target>
        </trans-unit>
        <trans-unit id="7d18a0bca02af71f36038a10035b4fe89b253e6e" translate="yes" xml:space="preserve">
          <source>Detail Group</source>
          <target state="translated">세부 사항 그룹</target>
        </trans-unit>
        <trans-unit id="fc513aa1c1486f07867ac9c63a186583402ee0ec" translate="yes" xml:space="preserve">
          <source>Detail Report</source>
          <target state="translated">상세 보고서</target>
        </trans-unit>
        <trans-unit id="c352d575e112605537ad32d24ea8d1abed42a987" translate="yes" xml:space="preserve">
          <source>Determining how many arguments were passed to a subroutine</source>
          <target state="translated">서브 루틴에 전달 된 인수 수 결정</target>
        </trans-unit>
        <trans-unit id="a5a74a6df09278b88cb6ea23b7d7f2570c33babf" translate="yes" xml:space="preserve">
          <source>Device</source>
          <target state="translated">Device</target>
        </trans-unit>
        <trans-unit id="b4bdf8d06c8ee9447b53a8835fd50fd6f2691a97" translate="yes" xml:space="preserve">
          <source>Did you notice that there are two each of&lt;code&gt;Year&lt;/code&gt;&lt;code&gt;Month&lt;/code&gt;and&lt;code&gt;Day&lt;/code&gt;data names defined? That&amp;rsquo;s perfectly legal, provided that each can be uniquely&lt;code&gt;qualified&lt;/code&gt;so as to be distinct from the other. Take for example the&lt;code&gt;Year&lt;/code&gt;items. One is defined as part of the&lt;code&gt;From-Date&lt;/code&gt;data item while the other is defined as part of the &quot;To-Date&quot; data item. In COBOL, we would actually code references to these two data items as either&lt;code&gt;Year OF From-Date&lt;/code&gt;and&lt;code&gt;Year OF To-Date&lt;/code&gt;or&lt;code&gt;Year IN From-Date&lt;/code&gt;and&lt;code&gt;Year IN To-Date&lt;/code&gt;(COBOL allows either&lt;code&gt;IN&lt;/code&gt;or&lt;code&gt;OF&lt;/code&gt;to be used). Since these references would clarify any confusion to us as to which&lt;code&gt;Year&lt;/code&gt;might be referenced, the GnuCOBOL compiler won&amp;rsquo;t be confused either.</source>
          <target state="translated">&lt;code&gt;Year&lt;/code&gt; &lt;code&gt;Month&lt;/code&gt; 및 &lt;code&gt;Day&lt;/code&gt; 데이터 이름이 각각 두 개씩 정의되어 있습니까? 각각 이 다른 것과 구별되도록 고유하게 &lt;code&gt;qualified&lt;/code&gt; 할 수 있다면, 그것은 완전히 합법적 입니다. &lt;code&gt;Year&lt;/code&gt; 항목 을 예로 들어 보겠습니다 . 하나는 &lt;code&gt;From-Date&lt;/code&gt; 데이터 항목의 일부로 정의되고 다른 하나는 &quot;To-Date&quot;데이터 항목의 일부로 정의됩니다. COBOL에서는 실제로이 두 데이터 항목에 대한 참조를 &lt;code&gt;Year OF From-Date&lt;/code&gt; &lt;code&gt;Year OF To-Date&lt;/code&gt; 및 연도 연도 또는 &lt;code&gt;Year IN From-Date&lt;/code&gt; &lt;code&gt;Year IN To-Date&lt;/code&gt; 및 연도 중 연도 (COBOL은 &lt;code&gt;IN&lt;/code&gt; 또는 &lt;code&gt;OF&lt;/code&gt; 를 허용 함)로 코딩합니다.사용될). 이러한 참조는 어느 &lt;code&gt;Year&lt;/code&gt; 가 참조 될 수 있는지에 대한 혼동을 명확히하기 때문에 GnuCOBOL 컴파일러도 혼동되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3dae4df8e307eadc33cccfbf09afcf7803b28a27" translate="yes" xml:space="preserve">
          <source>Did you notice the output showing the contents of &quot;Arg1&quot; after the subroutine was called? Those contents were unchanged! The subroutine</source>
          <target state="translated">서브 루틴이 호출 된 후 &quot;Arg1&quot;의 내용을 보여주는 출력을 보셨습니까? 그 내용은 바뀌지 않았습니다! 서브 루틴</target>
        </trans-unit>
        <trans-unit id="6db57f7358d87d80d9ffe675eab1fa80c2597c75" translate="yes" xml:space="preserve">
          <source>Direct program execution syntax is as follows:</source>
          <target state="translated">직접 프로그램 실행 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f3a08a300c1fa7c7b7c3869e07803b1ee488a676" translate="yes" xml:space="preserve">
          <source>Directly executable form</source>
          <target state="translated">직접 실행 가능한 양식</target>
        </trans-unit>
        <trans-unit id="bbbec44416269797757a1579d0b1247911acd066" translate="yes" xml:space="preserve">
          <source>Division</source>
          <target state="translated">Division</target>
        </trans-unit>
        <trans-unit id="50a314209c54751015d5ea87733dbccc98864d31" translate="yes" xml:space="preserve">
          <source>Division by zero</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c91054f46891fec1cae6331f29fdbccb03d6a39" translate="yes" xml:space="preserve">
          <source>Divisions</source>
          <target state="translated">Divisions</target>
        </trans-unit>
        <trans-unit id="768a18bcfd50a4cdbad454ea5c1997d92ec2f9ed" translate="yes" xml:space="preserve">
          <source>Do not specify the &quot;.so&quot; or &quot;.dll&quot; extension on the program name. The</source>
          <target state="translated">프로그램 이름에 &quot;.so&quot;또는 &quot;.dll&quot;확장자를 지정하지 마십시오. 그만큼</target>
        </trans-unit>
        <trans-unit id="fa34cf297b7f3240b7cd6005ab3bf76a3b53feb2" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t bother worrying about it at compile-time. Use the&lt;code&gt;INITIALIZE&lt;/code&gt;(see &lt;a href=&quot;#INITIALIZE&quot;&gt;INITIALIZE&lt;/a&gt;) to initialize all data item occurrences in a table (at run-time) to their data-type-specific default values (numerics: 0, alphabetic and alphanumerics: spaces).</source>
          <target state="translated">컴파일 타임에 걱정하지 마십시오. 사용 &lt;code&gt;INITIALIZE&lt;/code&gt; 를 (참조 &lt;a href=&quot;#INITIALIZE&quot;&gt;INITIALIZE를&lt;/a&gt; 데이터 형 고유의 디폴트 값 (0, 알파벳과 알파벳과 숫자 : 공간 수치)에 (실행시) 테이블에있는 모든 데이터 항목의 발생을 초기화).</target>
        </trans-unit>
        <trans-unit id="a1aca23a3aa1e9e5ee434e5c251ba724ccb58be9" translate="yes" xml:space="preserve">
          <source>Down-Arrow was pressed</source>
          <target state="translated">아래쪽 화살표를 눌렀습니다.</target>
        </trans-unit>
        <trans-unit id="c121671e83c83f33db959abee0785d1ae6b8351f" translate="yes" xml:space="preserve">
          <source>During the presentation of the&lt;code&gt;CONTROL FOOTING&lt;/code&gt;groups, any necessary&lt;code&gt;PAGE FOOTING&lt;/code&gt;and&lt;code&gt;PAGE HEADING&lt;/code&gt;groups will be presented as well.</source>
          <target state="translated">&lt;code&gt;CONTROL FOOTING&lt;/code&gt; 그룹 의 프레젠테이션 중에 필요한 &lt;code&gt;PAGE FOOTING&lt;/code&gt; 및 &lt;code&gt;PAGE HEADING&lt;/code&gt; 그룹도 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a70150b4c0486379b53b2bc61cc3b9e1cb791978" translate="yes" xml:space="preserve">
          <source>Dynamic Subprogram</source>
          <target state="translated">다이나믹 서브 프로그램</target>
        </trans-unit>
        <trans-unit id="6eb0f764570bb14c352993b6d496277e64157960" translate="yes" xml:space="preserve">
          <source>Dynamically-loadable</source>
          <target state="translated">Dynamically-loadable</target>
        </trans-unit>
        <trans-unit id="1348d390510adbb26537a28adfa74ec9b8165ca8" translate="yes" xml:space="preserve">
          <source>Dynamically-loadable executable form</source>
          <target state="translated">동적으로로드 가능한 실행 양식</target>
        </trans-unit>
        <trans-unit id="eb8d20220991838c8009592b6e63139e1b78c3ba" translate="yes" xml:space="preserve">
          <source>Dynamically-loadable modules may be removed from memory via the&lt;code&gt;CANCEL&lt;/code&gt;statement (see &lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;CANCEL&lt;/code&gt; 문을 통해 동적으로로드 가능한 모듈을 메모리에서 제거 할 수 있습니다 ( &lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="901bdca5f99ca3f0f8c3c45d17df5cd4768b3649" translate="yes" xml:space="preserve">
          <source>Dynamically-loadable modules will be named &quot;xxxxxxxx.dll&quot; on a Windows system, &quot;xxxxxxxx.so&quot; on a Unix system or &quot;xxxxxxxx.dylib&quot; on an OSX system, where &quot;xxxxxxxx&quot; exactly matches, including the usage of upper- and lower-case letters, the primary entry-point name &lt;code&gt;PROGRAM-ID&lt;/code&gt;or&lt;code&gt;FUNCTION-ID&lt;/code&gt; or an alternate entry point name defined via the&lt;code&gt;ENTRY&lt;/code&gt;statement (see &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY&lt;/a&gt;) of any one of the GnuCOBOL programs included in that module.</source>
          <target state="translated">동적으로로드 가능한 모듈은 Windows 시스템에서 &quot;xxxxxxxx.dll&quot;, Unix 시스템에서 &quot;xxxxxxxx.so&quot;또는 OSX 시스템에서 &quot;xxxxxxxx.dylib&quot;로 이름이 지정됩니다. 여기서 &quot;xxxxxxxx&quot;는 상위 시스템의 사용을 포함하여 정확히 일치합니다. 소문자, 기본 진입 점 이름 &lt;code&gt;PROGRAM-ID&lt;/code&gt; 또는 &lt;code&gt;FUNCTION-ID&lt;/code&gt; 또는 해당 모듈에 포함 된 GnuCOBOL 프로그램 중 하나의 &lt;code&gt;ENTRY&lt;/code&gt; 문 ( &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY&lt;/a&gt; 참조 )을 통해 정의 된 대체 진입 점 이름 .</target>
        </trans-unit>
        <trans-unit id="1ba95e0268763043cd1e34a29d8c36e35ba2d644" translate="yes" xml:space="preserve">
          <source>Dynamically-loaded subprograms are executed (from a COBOL syntax point of view) just like any other subprograms. What makes them unique, however, is that they are loaded into memory only when they are actually used the first time during the execution of a program.</source>
          <target state="translated">동적으로로드 된 서브 프로그램은 다른 서브 프로그램과 마찬가지로 (COBOL 구문 관점에서) 실행됩니다. 그러나 그것들을 독특하게 만드는 것은 프로그램을 실행하는 동안 실제로 처음 사용될 때만 메모리에로드된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="030dcb4209a1709b74f2d59ef6da0355f006e9c6" translate="yes" xml:space="preserve">
          <source>E Function Syntax</source>
          <target state="translated">E 함수 구문</target>
        </trans-unit>
        <trans-unit id="765a70eecffa68061065b3955fd85a92329d8392" translate="yes" xml:space="preserve">
          <source>E, EBCDIC, EC, ECHO, EGI, ELSE, EMI, EMPTY-CHECK, ENABLE, END, END-ACCEPT, END-ADD, END-CALL, END-CHAIN, END-COMPUTE, END-DELETE, END-DISPLAY, END-DIVIDE, END-EVALUATE, END-IF, END-MULTIPLY, END-OF-PAGE, END-PERFORM, END-READ, END-RECEIVE, END-RETURN, END-REWRITE, END-SEARCH, END-START, END-STRING, END-SUBTRACT, END-UNSTRING, END-WRITE, ENTRY, ENTRY-CONVENTION, ENVIRONMENT, ENVIRONMENT-NAME, ENVIRONMENT-VALUE, EO, EOL, EOP, EOS, EQUAL, EQUALS, ERASE, ERROR, ESCAPE, ESI, EVALUATE, EXCEPTION, EXCEPTION-FILE, EXCEPTION-FILE-N, EXCEPTION-LOCATION, EXCEPTION-LOCATION-N, EXCEPTION-OBJECT, EXCEPTION-STATEMENT, EXCEPTION-STATUS, EXCLUSIVE, EXIT, EXP, EXP10, EXPANDS, EXTEND, EXTERN, EXTERNAL</source>
          <target state="translated">E, EBCDIC, EC, ECHO, EGI, ELSE, EMI, EMPTY-CHECK, ENABLE, END, END-ACCEPT, END-ADD, END-CALL, END-CHAIN, END-COMPUTE, END-DELETE, END-DISPLAY, END-DIVIDE, END-EVALUATE, END-IF, END-IF, END-OF, END-OF-PAGE, END-PERFORM, END-READ, END-RECEIVE, END-RETURN, END-REWRITE, END-SEARCH, END-START, 엔드-스트링, 엔드-서브-엔드, 엔드-언 스트링, END-WRITE, ENTRY, ENTRY- 컨벤션, 환경, 환경-이름, 환경-값, EO, EOL, EOP, EOS, EQUAL, EQUALS, ERASE, ERROR, ECAPE, ESI, 평가, 예외, 예외 파일, 예외 파일 -N, 예외 위치, 예외 위치 -N, 예외 목표, 예외 상태, 예외 상태, 예외, 종료, EXP, EXP10, 확장, 확장, 외부, 외부</target>
        </trans-unit>
        <trans-unit id="5effca06a41a1d22ea816cb82b7101e0e5ef5985" translate="yes" xml:space="preserve">
          <source>EC-ARGUMENT-FUNCTION</source>
          <target state="translated">EC-ARGUMENT-FUNCTION</target>
        </trans-unit>
        <trans-unit id="6f64130193ed68a9cf43ad043a1db86b51b7732f" translate="yes" xml:space="preserve">
          <source>EC-BOUND-ODO</source>
          <target state="translated">EC-BOUND-ODO</target>
        </trans-unit>
        <trans-unit id="7758bece637db0db2aa2eaf68b0a5ca23becb2f7" translate="yes" xml:space="preserve">
          <source>EC-BOUND-PTR</source>
          <target state="translated">EC-BOUND-PTR</target>
        </trans-unit>
        <trans-unit id="35ce6218474a39cc348cc1b04f5cfeb6a7093fba" translate="yes" xml:space="preserve">
          <source>EC-BOUND-REF-MOD</source>
          <target state="translated">EC-BOUND-REF-MOD</target>
        </trans-unit>
        <trans-unit id="b180672a32ac9f504a398165500845e145ddac86" translate="yes" xml:space="preserve">
          <source>EC-BOUND-SUBSCRIPT</source>
          <target state="translated">EC-BOUND-SUBSCRIPT</target>
        </trans-unit>
        <trans-unit id="47bd90096a9329462194bb3efc2ec0777c1cc384" translate="yes" xml:space="preserve">
          <source>EC-DATA-INCOMPATIBLE</source>
          <target state="translated">EC-DATA-INCOMPATIBLE</target>
        </trans-unit>
        <trans-unit id="599ae453fdf489e4c5507f42fe19ed6e9f07ec45" translate="yes" xml:space="preserve">
          <source>EC-I-O</source>
          <target state="translated">EC-I-O</target>
        </trans-unit>
        <trans-unit id="37a26c3979aa50c34cd4c0ac08b0ca77f51e47c2" translate="yes" xml:space="preserve">
          <source>EC-I-O-AT-END</source>
          <target state="translated">EC-I-O-AT-END</target>
        </trans-unit>
        <trans-unit id="7695dbca75bfb201f44d69c5f1d6236c16575ead" translate="yes" xml:space="preserve">
          <source>EC-I-O-EOP</source>
          <target state="translated">EC-I-O-EOP</target>
        </trans-unit>
        <trans-unit id="f5e8f83ff584e8d475c4cd5b0545216bba034cd9" translate="yes" xml:space="preserve">
          <source>EC-I-O-FILE-SHARING</source>
          <target state="translated">EC-I-O-FILE-SHARING</target>
        </trans-unit>
        <trans-unit id="6f67df493e29d40d1c466d3532abcf2151feb116" translate="yes" xml:space="preserve">
          <source>EC-I-O-IMP</source>
          <target state="translated">EC-I-O-IMP</target>
        </trans-unit>
        <trans-unit id="2bedcca397988fdafc22d2b1db2fe596c55b7abc" translate="yes" xml:space="preserve">
          <source>EC-I-O-INVALID-KEY</source>
          <target state="translated">EC-I-O-INVALID-KEY</target>
        </trans-unit>
        <trans-unit id="d37a719c5ec9cc280a3423d35c359f53361556cf" translate="yes" xml:space="preserve">
          <source>EC-I-O-LOGIC-ERROR</source>
          <target state="translated">EC-I-O-LOGIC-ERROR</target>
        </trans-unit>
        <trans-unit id="22c38171abcae25c72623446be7e409f53d9f1cb" translate="yes" xml:space="preserve">
          <source>EC-I-O-PERMANENT-ERROR</source>
          <target state="translated">EC-I-O-PERMANENT-ERROR</target>
        </trans-unit>
        <trans-unit id="e57f56d25192a637896e66e92bcae79d33a72575" translate="yes" xml:space="preserve">
          <source>EC-I-O-RECORD-OPERATION</source>
          <target state="translated">EC-I-O-RECORD-OPERATION</target>
        </trans-unit>
        <trans-unit id="f232808a3899bdcf8d909765f6e715db467fc08e" translate="yes" xml:space="preserve">
          <source>EC-IMP-ACCEPT</source>
          <target state="translated">EC-IMP-ACCEPT</target>
        </trans-unit>
        <trans-unit id="5b7c6f8d33dccc651230c71c804f70a23dfd3fb3" translate="yes" xml:space="preserve">
          <source>EC-IMP-DISPLAY</source>
          <target state="translated">EC-IMP-DISPLAY</target>
        </trans-unit>
        <trans-unit id="0348c4c249e24b62ec6318d07a0918b290c97136" translate="yes" xml:space="preserve">
          <source>EC-OVERFLOW</source>
          <target state="translated">EC-OVERFLOW</target>
        </trans-unit>
        <trans-unit id="39873e8196f86a467a7a5394f6dae0df7cb7ec49" translate="yes" xml:space="preserve">
          <source>EC-OVERFLOW-STRING</source>
          <target state="translated">EC-OVERFLOW-STRING</target>
        </trans-unit>
        <trans-unit id="a912b54889e1360e1822bf001ecc4bcce0057de1" translate="yes" xml:space="preserve">
          <source>EC-OVERFLOW-UNSTRING</source>
          <target state="translated">EC-OVERFLOW-UNSTRING</target>
        </trans-unit>
        <trans-unit id="642796743342819c46389d927083877ea07d115a" translate="yes" xml:space="preserve">
          <source>EC-PROGRAM-NOT-FOUND</source>
          <target state="translated">EC-PROGRAM-NOT-FOUND</target>
        </trans-unit>
        <trans-unit id="fbeac2b7df577454ec16676f61d4d1c2dd9e4b66" translate="yes" xml:space="preserve">
          <source>EC-RANGE-INSPECT-SIZE</source>
          <target state="translated">EC-RANGE-INSPECT-SIZE</target>
        </trans-unit>
        <trans-unit id="44603209bfd2fe1e4c13a73d2183c6926c88fa44" translate="yes" xml:space="preserve">
          <source>EC-SIZE</source>
          <target state="translated">EC-SIZE</target>
        </trans-unit>
        <trans-unit id="d4c83319eed34736080dc026b83369dc0ab0f9e0" translate="yes" xml:space="preserve">
          <source>EC-SIZE-OVERFLOW</source>
          <target state="translated">EC-SIZE-OVERFLOW</target>
        </trans-unit>
        <trans-unit id="995fc7c1e9f2389fb223769d4efff5b6078bcd23" translate="yes" xml:space="preserve">
          <source>EC-SIZE-TRUNCATION</source>
          <target state="translated">EC-SIZE-TRUNCATION</target>
        </trans-unit>
        <trans-unit id="2b0855452a33f27ee0e3591f258c880264670a28" translate="yes" xml:space="preserve">
          <source>EC-SIZE-ZERO-DIVIDE</source>
          <target state="translated">EC-SIZE-ZERO-DIVIDE</target>
        </trans-unit>
        <trans-unit id="74425f6db6d6bbce95e0144ef83b5f7377196c52" translate="yes" xml:space="preserve">
          <source>EC-STORAGE-NOT-ALLOC</source>
          <target state="translated">EC-STORAGE-NOT-ALLOC</target>
        </trans-unit>
        <trans-unit id="2bcce8379324db20847e97d1dbdd7613e1e978ce" translate="yes" xml:space="preserve">
          <source>EC-STORAGE-NOT-AVAIL</source>
          <target state="translated">EC-STORAGE-NOT-AVAIL</target>
        </trans-unit>
        <trans-unit id="af80c9b4c454f7d961a11331ae6fb9445df82b42" translate="yes" xml:space="preserve">
          <source>EMPTY-CHECK Attribute Syntax</source>
          <target state="translated">비어있는 점검 속성 구문</target>
        </trans-unit>
        <trans-unit id="f84802327b6f04b6ca9f5ad265dd6839e26a2682" translate="yes" xml:space="preserve">
          <source>ENTER key pressed</source>
          <target state="translated">ENTER 키를 눌렀습니다</target>
        </trans-unit>
        <trans-unit id="1737c25f7adeb7b4b0cf8beddc7007f6c44cee3c" translate="yes" xml:space="preserve">
          <source>ENTRY Syntax</source>
          <target state="translated">ENTRY 구문</target>
        </trans-unit>
        <trans-unit id="c8d3810b7c62cddd57ba48b6b05b3d7aaeb1d1c3" translate="yes" xml:space="preserve">
          <source>ENTRY-Argument</source>
          <target state="translated">ENTRY-Argument</target>
        </trans-unit>
        <trans-unit id="56bc597bd92048db144c774480c4ac8ebc388d8a" translate="yes" xml:space="preserve">
          <source>ENTRY-Argument Syntax</source>
          <target state="translated">ENTRY- 인수 구문</target>
        </trans-unit>
        <trans-unit id="aeefff7bdd0630e9dbc6edcccf44b29d8e1b5f66" translate="yes" xml:space="preserve">
          <source>ENVIRONMENT DIVISION Syntax</source>
          <target state="translated">환경 분할 구문</target>
        </trans-unit>
        <trans-unit id="10be88097f9b48fa4b8f5918ab59b09ba828e0cf" translate="yes" xml:space="preserve">
          <source>ERASE Clause Syntax</source>
          <target state="translated">지우기 절 구문</target>
        </trans-unit>
        <trans-unit id="5dad113e5d1b8f3e62a36027129de407d3e20ed5" translate="yes" xml:space="preserve">
          <source>EVALUATE Selection Object Syntax</source>
          <target state="translated">평가 선택 객체 구문</target>
        </trans-unit>
        <trans-unit id="5a83d6a3d7ae8bc96fedf1c772fbc996a4a470be" translate="yes" xml:space="preserve">
          <source>EVALUATE Selection Subject Syntax</source>
          <target state="translated">평가 선택 주제 구문</target>
        </trans-unit>
        <trans-unit id="692ff2f950c444cebee2d4c4c60df5cc939b8fd9" translate="yes" xml:space="preserve">
          <source>EVALUATE Syntax</source>
          <target state="translated">평가 구문</target>
        </trans-unit>
        <trans-unit id="469cc380359b81f762280d15538dfac8966996c9" translate="yes" xml:space="preserve">
          <source>EXCEPTION-FILE Function Syntax</source>
          <target state="translated">EXCEPTION-FILE 함수 구문</target>
        </trans-unit>
        <trans-unit id="479aad1c99b2dd0808d2f3ab8cbcb8f9343aaefd" translate="yes" xml:space="preserve">
          <source>EXCEPTION-LOCATION Function Syntax</source>
          <target state="translated">EXCEPTION-LOCATION 함수 구문</target>
        </trans-unit>
        <trans-unit id="33912bed8a51a3f75c3314cf3a0622c55f3ea0f0" translate="yes" xml:space="preserve">
          <source>EXCEPTION-STATEMENT Function Syntax</source>
          <target state="translated">EXCEPTION-STATEMENT 함수 구문</target>
        </trans-unit>
        <trans-unit id="e953091eafe979edb67d0cb82e5a7cfb2279431b" translate="yes" xml:space="preserve">
          <source>EXCEPTION-STATUS Function Syntax</source>
          <target state="translated">EXCEPTION-STATUS 함수 구문</target>
        </trans-unit>
        <trans-unit id="2d0d9c09a42e3d4ca8de4f760e2a0e18040ed305" translate="yes" xml:space="preserve">
          <source>EXIT Syntax</source>
          <target state="translated">종료 구문</target>
        </trans-unit>
        <trans-unit id="d686d0c0c789b999f85984848eb8e9e113877d1c" translate="yes" xml:space="preserve">
          <source>EXP Function Syntax</source>
          <target state="translated">EXP 함수 구문</target>
        </trans-unit>
        <trans-unit id="82ec30d94a7c621453c959d12251cec86e515836" translate="yes" xml:space="preserve">
          <source>EXP10 Function Syntax</source>
          <target state="translated">EXP10 함수 구문</target>
        </trans-unit>
        <trans-unit id="f6c4ca6abf37447285ca9c9057e5a05661c09827" translate="yes" xml:space="preserve">
          <source>EXTERN the program name is treated as an external reference.</source>
          <target state="translated">EXTERN 프로그램 이름은 외부 참조로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="03fa72b305c4462fb55710bd2cd41b8ac8239e43" translate="yes" xml:space="preserve">
          <source>EXTERNAL Attribute Syntax</source>
          <target state="translated">외부 속성 구문</target>
        </trans-unit>
        <trans-unit id="76da433919c17ebd8d966fabcaa51186d16cbb3c" translate="yes" xml:space="preserve">
          <source>Each &amp;lt;</source>
          <target state="translated">각 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="ab7a12a52c6f9b3787b7205827450dfa5e210ea2" translate="yes" xml:space="preserve">
          <source>Each &amp;lt;&amp;lt;</source>
          <target state="translated">각 &amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="212df151f4df6b415b0184ea3c628ccc78c3a454" translate="yes" xml:space="preserve">
          <source>Each 01-level data item described within a subprogram&amp;rsquo;s linkage section should correspond to an argument passed on a&lt;code&gt;CALL&lt;/code&gt;statement (see &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt;) or an argument on a function call to the subprogram.</source>
          <target state="translated">서브 프로그램의 링크 섹션에 설명 된 각 01 레벨 데이터 항목은 &lt;code&gt;CALL&lt;/code&gt; 문 에 전달 된 인수 ( &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt; 참조 ) 또는 서브 프로그램에 대한 함수 호출의 인수와 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="50184d6f70a255b3866145aa336ae939da7ab9ab" translate="yes" xml:space="preserve">
          <source>Each Event-Handler-Routine will be a separate section devoted to trapping a particular run-time event. If there are no such sections coded, the&lt;code&gt;DECLARATIVES.&lt;/code&gt;and&lt;code&gt;END DECLARATIVES.&lt;/code&gt;lines may be omitted.</source>
          <target state="translated">각 Event-Handler-Routine은 특정 런타임 이벤트를 포착하기위한 별도의 섹션입니다. 그러한 섹션이 코딩되어 있지 않으면 &lt;code&gt;DECLARATIVES.&lt;/code&gt; 그리고 &lt;code&gt;END DECLARATIVES.&lt;/code&gt; 라인은 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b25dfd77ca9db15d2164fe35f200c91c7b2bda7" translate="yes" xml:space="preserve">
          <source>Each character, in turn, within the &quot;from&quot; string will be searched for in the target range of the inspect subject. Each located occurrence will be replaced by the corresponding character of the &quot;to&quot; string.</source>
          <target state="translated">&quot;from&quot;문자열 내의 각 문자는 검사 대상의 대상 범위에서 검색됩니다. 찾은 각 발생은 &quot;to&quot;문자열의 해당 문자로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="97de2fc8d281d19be767cf651c3cbc1b7509f469" translate="yes" xml:space="preserve">
          <source>Each data item has 7 added to it ten</source>
          <target state="translated">각 데이터 항목에는 10이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="83ca16f4859e7d91cc156f672d81b61c4963b390" translate="yes" xml:space="preserve">
          <source>Each destination field may have an optional&lt;code&gt;COUNT&lt;/code&gt;</source>
          <target state="translated">각 목적지 필드에는 선택 사항 인 &lt;code&gt;COUNT&lt;/code&gt; 가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce3fcdc8c9dc594c99b3c39bb2ebb465ca20a452" translate="yes" xml:space="preserve">
          <source>Each destination field may have an optional&lt;code&gt;DELIMITER&lt;/code&gt;</source>
          <target state="translated">각 대상 필드에는 선택적인 &lt;code&gt;DELIMITER&lt;/code&gt; 가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="824ef1a5b203c9da09868c95374d778cb8131338" translate="yes" xml:space="preserve">
          <source>Each division may consist of a variety of sections and each section consists of one or more paragraphs. A paragraph consists of sentences, each of which consists of one or more statements.</source>
          <target state="translated">각 부서는 다양한 섹션으로 구성 될 수 있으며 각 섹션은 하나 이상의 단락으로 구성됩니다. 단락은 문장으로 구성되며 각 문장은 하나 이상의 문장으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="e2bd01ccaa12000bd7c8aa2fcbf0347999187549" translate="yes" xml:space="preserve">
          <source>Each file specified on the&lt;code&gt;cobc&lt;/code&gt;command constitutes a &amp;rsquo;</source>
          <target state="translated">&lt;code&gt;cobc&lt;/code&gt; 명령 에 지정된 각 파일 은 '</target>
        </trans-unit>
        <trans-unit id="00f5259fa9f0d932f10e8397b1eec6feeb68f182" translate="yes" xml:space="preserve">
          <source>Each occurrence is referenced using the subscript syntax (a numeric literal, arithmetic expression or numeric identifier enclosed within parenthesis) shown above.</source>
          <target state="translated">각 어커런스는 위에 표시된 아래 첨자 구문 (숫자 리터럴, 산술 표현식 또는 괄호로 묶인 숫자 식별자)을 사용하여 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="2246e9f359281d69c5119e3504fc16ed25bac66e" translate="yes" xml:space="preserve">
          <source>Each occurrence that is set to a value of zero prior to the&lt;code&gt;CALL X&quot;91&quot;&lt;/code&gt;will cause the corresponding switch to be cleared. Each occurrence set to 1 prior to the&lt;code&gt;CALL X&quot;91&quot;&lt;/code&gt;will cause the corresponding switch to be set.</source>
          <target state="translated">&lt;code&gt;CALL X&quot;91&quot;&lt;/code&gt; 이전에 값이 0으로 설정 될 때마다 해당 스위치가 지워집니다. &lt;code&gt;CALL X&quot;91&quot;&lt;/code&gt; 이전에 각각 1을 설정 하면 해당 스위치가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="47a2c92912290d0b93c63c77a2120c44882c45e8" translate="yes" xml:space="preserve">
          <source>Each of &amp;lt;</source>
          <target state="translated">각각의 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="a97f6698ca0ef433fb7ac939df954fa715d8f25a" translate="yes" xml:space="preserve">
          <source>Each of the &amp;lt;</source>
          <target state="translated">각각의 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="7287503eaa543018b27e0323b8db19263aedff48" translate="yes" xml:space="preserve">
          <source>Each of the 1st eight occurrences of the array will be set to either 0 or 1 &amp;mdash; 1 if the corresponding switch is set, 0 otherwise.</source>
          <target state="translated">어레이의 첫 8 개 발생은 각각 해당 스위치가 설정된 경우 0 또는 1 &amp;ndash; 1로 설정되고 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="c09592cadb2ed51d0f1c709d0f7fdfe9b96c7560" translate="yes" xml:space="preserve">
          <source>Each of the folders named on the&lt;code&gt;COBCPY&lt;/code&gt;compilation-time environment variable</source>
          <target state="translated">&lt;code&gt;COBCPY&lt;/code&gt; 컴파일 타임 환경 변수 에 이름이 지정된 각 폴더</target>
        </trans-unit>
        <trans-unit id="324c91e30099fbc60529755c27c3efdd05d14a69" translate="yes" xml:space="preserve">
          <source>Each of the following symbols behave like a&lt;code&gt;9&lt;/code&gt; until such point as all digits in the numeric value are exhausted and leading zeros are about to be inserted. In effect, these editing symbols define what should happen to those leading zero.</source>
          <target state="translated">다음의 각 기호 는 숫자 값의 모든 자릿수가 소진되고 선행 0이 삽입 될 때까지 &lt;code&gt;9&lt;/code&gt; 처럼 작동합니다 . 실제로,이 편집 기호는 0을 선행하는 사람들에게 일어날 일을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="d9d2be1b968bb484ea3bd99238ffa88f1a9b097c" translate="yes" xml:space="preserve">
          <source>Each of these sections consists of a series of specific paragraphs &lt;code&gt;SOURCE-COMPUTER&lt;/code&gt;and&lt;code&gt;OBJECT-COMPUTER&lt;/code&gt; for example). Each of these paragraphs serves a specific purpose. If no code is required for the purpose one of the paragraphs serves, the entire paragraph may be omitted.</source>
          <target state="translated">이러한 각 섹션은 예를 들어 &lt;code&gt;SOURCE-COMPUTER&lt;/code&gt; 및 &lt;code&gt;OBJECT-COMPUTER&lt;/code&gt; 와 같은 일련의 특정 단락으로 구성됩니다 . 이러한 각 단락은 특정 목적을 수행합니다. 단락 중 하나가 제공하는 목적으로 코드가 필요하지 않으면 전체 단락을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49fb2845c3cf679efe7de1449e9eb5da506280b3" translate="yes" xml:space="preserve">
          <source>Each of these sections consists of code which serves a specific purpose. If no code is required for the purpose one of those sections serves, the entire section, including it&amp;rsquo;s header, may be omitted.</source>
          <target state="translated">이러한 각 섹션은 특정 목적을 수행하는 코드로 구성됩니다. 해당 섹션 중 하나가 제공하는 목적으로 코드가 필요하지 않으면 헤더를 포함하여 전체 섹션이 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5476f035d3a01cedf662032e9a562423f2c27af" translate="yes" xml:space="preserve">
          <source>Each of those files is assumed to be already sorted according to the specifications set forth on the&lt;code&gt;MERGE&lt;/code&gt;statement&amp;rsquo;s&lt;code&gt;KEY&lt;/code&gt;</source>
          <target state="translated">이러한 각 파일은 &lt;code&gt;MERGE&lt;/code&gt; 문의 &lt;code&gt;KEY&lt;/code&gt; 에 명시된 사양에 따라 이미 정렬 된 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="39b6b7cca90aab953adf3ec432fdd03b2921cced" translate="yes" xml:space="preserve">
          <source>Each page of a report is divided into as many as five (5) areas, as shown in the following diagram.</source>
          <target state="translated">다음 다이어그램과 같이 보고서의 각 페이지는 최대 5 개의 영역으로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="e972c979eeb51709c3026fa1585338428e0bcde2" translate="yes" xml:space="preserve">
          <source>Each program consists of up to four &amp;rsquo;</source>
          <target state="translated">각 프로그램은 최대 4 개의 '</target>
        </trans-unit>
        <trans-unit id="41ad41c5b7c7e05b20b0cee772dbf1deebed0213" translate="yes" xml:space="preserve">
          <source>Each report referenced on a&lt;code&gt;REPORT IS&lt;/code&gt;clause (see &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File/Sort-Description&lt;/a&gt;) must be described with a report description &lt;code&gt;RD&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;REPORT IS&lt;/code&gt; 절 ( &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;파일 / 정렬 설명&lt;/a&gt; 참조)에서 참조 된 각 보고서 는 보고서 설명 &lt;code&gt;RD&lt;/code&gt; 로 설명해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c43f0748874dff6862d449d932e3f73e50432ff7" translate="yes" xml:space="preserve">
          <source>Each set of counting instructions contains the following information:</source>
          <target state="translated">각 계산 지침 세트에는 다음 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1713797d1fd5be38aa62ec74f40cb5e4ea9a66cb" translate="yes" xml:space="preserve">
          <source>Each set of replacement instructions contains the following information:</source>
          <target state="translated">각 교체 지침 세트에는 다음 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec64521d31f73aadd610d57e3314c5c0cb07d6c8" translate="yes" xml:space="preserve">
          <source>Each specified switch must have at least one of a&lt;code&gt;IS &amp;lt;&lt;i&gt;mnemonic-name-1&lt;/i&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;ON STATUS&lt;/code&gt;or an&lt;code&gt;OFF STATUS&lt;/code&gt;option defined for it, otherwise there will be no way to reference the switch from within a GnuCOBOL program.</source>
          <target state="translated">지정된 각 스위치에는 &lt;code&gt;IS &amp;lt;&lt;i&gt;mnemonic-name-1&lt;/i&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;ON STATUS&lt;/code&gt; 또는 &lt;code&gt;OFF STATUS&lt;/code&gt; 옵션 중 하나 이상이 정의되어 있어야합니다. 그렇지 않으면 GnuCOBOL 프로그램 내에서 스위치를 참조 할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e559cbff67ac689ef745772d42537a3b513d5011" translate="yes" xml:space="preserve">
          <source>Each symbolic character name will be associated with the corresponding &amp;lt;</source>
          <target state="translated">각 기호 문자 이름은 해당 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="4c00430742f8eba1eaf3bd142512606b4b7f5494" translate="yes" xml:space="preserve">
          <source>Each time a&lt;code&gt;GENERATE&lt;/code&gt;statement (see &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;) is executed against a detail report group defined for this&lt;code&gt;RD&lt;/code&gt; the RWCS will check the contents of each &amp;lt;</source>
          <target state="translated">마다는 &lt;code&gt;GENERATE&lt;/code&gt; (참조 문 &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt; )이 정의 상세 보고서 그룹에 대해 실행되는 &lt;code&gt;RD&lt;/code&gt; 각각의 내용을 검사 할 RWCS &amp;lt;</target>
        </trans-unit>
        <trans-unit id="48545f108d6d890063854ad082ddb7636b0f7c42" translate="yes" xml:space="preserve">
          <source>Each&lt;code&gt;&amp;gt;&amp;gt;IF&lt;/code&gt;directive must be terminated by an&lt;code&gt;&amp;gt;&amp;gt;END-IF&lt;/code&gt;</source>
          <target state="translated">각 &lt;code&gt;&amp;gt;&amp;gt;IF&lt;/code&gt; 지시문은 &lt;code&gt;&amp;gt;&amp;gt;END-IF&lt;/code&gt; 로 끝나야합니다.</target>
        </trans-unit>
        <trans-unit id="3fecee34669e35b4e24782aec546eab94e861c5a" translate="yes" xml:space="preserve">
          <source>Each&lt;code&gt;RD&lt;/code&gt;will have the following allocated for it:</source>
          <target state="translated">각 &lt;code&gt;RD&lt;/code&gt; 에는 다음이 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="558bbf35a31701a51f5e603c87d6e37860e5bac5" translate="yes" xml:space="preserve">
          <source>Each&lt;code&gt;WHEN&lt;/code&gt;clause (other than the&lt;code&gt;WHEN OTHER&lt;/code&gt;</source>
          <target state="translated">각 &lt;code&gt;WHEN&lt;/code&gt; 절 ( &lt;code&gt;WHEN OTHER&lt;/code&gt; 이외)</target>
        </trans-unit>
        <trans-unit id="db708aa4613d2d89fc52c61a7a68b8e5310b35b1" translate="yes" xml:space="preserve">
          <source>Early versions of Micro Focus COBOL allowed programmers to access various runtime library routines by using a single two-digit hexadecimal number as the entry-point name. These were known as call-by-number routines. Over time, Micro Focus COBOL evolved, replacing most of the call-by-number routines with ones accessible using a more conventional call-by-name technique.</source>
          <target state="translated">초기 버전의 Micro Focus COBOL을 사용하면 프로그래머는 시작점 이름으로 단일 두 자리 16 진수를 사용하여 다양한 런타임 라이브러리 루틴에 액세스 할 수있었습니다. 이것을 번호 별 호출 루틴이라고합니다. 시간이 지남에 따라 Micro Focus COBOL이 진화하여 대부분의 번호순 루틴을보다 일반적인 이름 별 통화 기술을 사용하여 액세스 가능한 루틴으로 대체했습니다.</target>
        </trans-unit>
        <trans-unit id="60914652372d8aacfba426f94ef0a27b6bd64788" translate="yes" xml:space="preserve">
          <source>Effortlessly providing arithmetic accuracy to 31 digits, with performance approaching that of well-written assembly-language programs. Don&amp;rsquo;t think this isn&amp;rsquo;t critically important to banks, investment houses and any business interested in tracking revenues, expenses and profits (duh - like ALL of them).</source>
          <target state="translated">잘 작성된 어셈블리 언어 프로그램의 성능에 근접한 성능으로 31 자리까지 산술 정확도를 손쉽게 제공 이것이 은행, 투자 회사 및 수익, 지출 및 이익을 추적하는 데 관심이있는 모든 비즈니스에 중요하지 않다고 생각하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="eb8c33f1bd7b54199aabb312bdff6ad20c4a00e4" translate="yes" xml:space="preserve">
          <source>Eight (8) different colors may be specified for both the background (screen) and foreground (text) color of any row/column position on the screen. Colors are specified by number, although a copybook supplied with all GnuCOBOL distributions (&quot;screenio.cpy&quot;) defines COB-COLOR-xxxxxx names for the various colors so they may be specified as a more meaningful name rather than a number. The eight colors, by number, with the constant names defined in screenio.cpy, are as follows:</source>
          <target state="translated">화면에서 행 / 열 위치의 배경 (화면) 및 전경 (텍스트) 색상 모두에 8 가지 색상을 지정할 수 있습니다. 색상은 숫자로 지정되지만 모든 GnuCOBOL 배포판 ( &quot;screenio.cpy&quot;)과 함께 제공된 카피 북은 다양한 색상에 대해 COB-COLOR-xxxxxx 이름을 정의하므로 숫자가 아닌보다 의미있는 이름으로 지정 될 수 있습니다. screenio.cpy에 정의 된 상수 이름을 가진 숫자로 된 8 가지 색상은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0de188972590d50f27e84d7799cae74d5422d21a" translate="yes" xml:space="preserve">
          <source>Either a statement that begins with a non decision-making verb and specifies an unconditional action to be taken or a conditional verb such as&lt;code&gt;IF&lt;/code&gt;or&lt;code&gt;EVALUATE&lt;/code&gt; delimited by its explicit scope terminator (such as&lt;code&gt;END-IF&lt;/code&gt;or&lt;code&gt;END-EVALUATE&lt;/code&gt;. An imperative statement can consist of a sequence of imperative statements.</source>
          <target state="translated">비 의사 결정 동사로 시작하고 수행 할 무조건적 조치 또는 명시 적 범위 종결 자 (예 : &lt;code&gt;END-IF&lt;/code&gt; 또는 &lt;code&gt;END-EVALUATE&lt;/code&gt; ) 로 구분되는 조건부 동사 (예 : &lt;code&gt;IF&lt;/code&gt; 또는 &lt;code&gt;EVALUATE&lt;/code&gt; )를 지정 하는 명령문입니다. 일련의 명령문으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="30ea0da285c9a0b0bf611b3900abc0d992ef03bb" translate="yes" xml:space="preserve">
          <source>Either a&lt;code&gt;BEFORE&lt;/code&gt;phrase, an&lt;code&gt;AFTER&lt;/code&gt;phrase or both may be specified. They may be specified in any order.</source>
          <target state="translated">어느 &lt;code&gt;BEFORE&lt;/code&gt; 문구, &lt;code&gt;AFTER&lt;/code&gt; 의 문구 또는 둘 모두를 지정할 수 있습니다. 어떤 순서로도 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0caa91b8f1f5f36fcf7fbe55099f1de176c8fde9" translate="yes" xml:space="preserve">
          <source>Either or both of the 1st two arguments may be an alphanumeric literal, a group item or an elementary item appropriate to storing alphabetic or alphanumeric data. If the lengths of the two arguments are unequal, the shorter will be assumed to be padded to the right with spaces.</source>
          <target state="translated">첫 번째 두 인수 중 하나 또는 둘다는 영숫자 리터럴, 그룹 항목 또는 영문자 또는 영숫자 데이터를 저장하기에 적합한 기본 항목 일 수 있습니다. 두 인수의 길이가 동일하지 않은 경우 공백으로 오른쪽에 더 짧은 것으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="858e7defec8698672940f8ce436c406862616ecb" translate="yes" xml:space="preserve">
          <source>Either the name of an identifier or a procedure in the program. GnuCOBOL limits user-defined names to a maximum of 31 characters taken from the set of numeric digits, upper- and lower-case letters, hyphens and underscores. A user-defined name may neither begin nor end with a hyphen or underscore. User-defined names used as file names may additionally not begin with a digit although - unlike many other programming languages - user-defined names used as identifiers or procedure names may.</source>
          <target state="translated">프로그램의 식별자 또는 프로 시저 이름입니다. GnuCOBOL은 사용자 정의 이름을 숫자, 대문자 및 소문자, 하이픈 및 밑줄 집합에서 가져온 최대 31 자로 제한합니다. 사용자 정의 이름은 하이픈이나 밑줄로 시작하거나 끝날 수 없습니다. 파일 이름으로 사용되는 사용자 정의 이름은 다른 프로그래밍 언어와 달리 식별자 또는 프로 시저 이름으로 사용되는 사용자 정의 이름 일 수도 있지만 숫자로 시작하지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7567d0d8aa3c2f98c0119f54054a4094bbdf6b09" translate="yes" xml:space="preserve">
          <source>Either the&lt;code&gt;USAGE&lt;/code&gt;(see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) of &amp;lt;</source>
          <target state="translated">어느 &lt;code&gt;USAGE&lt;/code&gt; 는 (참조 &lt;a href=&quot;#USAGE&quot;&gt;사용&lt;/a&gt; 중) &amp;lt;</target>
        </trans-unit>
        <trans-unit id="12419b0638b06653e626b1a31d9f95a7e8c75d0a" translate="yes" xml:space="preserve">
          <source>Elementary Item</source>
          <target state="translated">초등학교 아이템</target>
        </trans-unit>
        <trans-unit id="f61c9f064c3d39237a20a4d7d3d38cc92ed48b49" translate="yes" xml:space="preserve">
          <source>End of file reached if reading forward or beginning-of-file reached if reading backward</source>
          <target state="translated">앞으로 읽을 경우 파일 끝에 도달하거나 뒤로 읽을 경우 파일 시작에 도달</target>
        </trans-unit>
        <trans-unit id="eb4a1c1bc69354df732a1fb660f7766fbc1365bb" translate="yes" xml:space="preserve">
          <source>End of page</source>
          <target state="translated">페이지 끝</target>
        </trans-unit>
        <trans-unit id="1f90eed9e128990aa3916d4821f0afedd06fce42" translate="yes" xml:space="preserve">
          <source>Entry-point</source>
          <target state="translated">Entry-point</target>
        </trans-unit>
        <trans-unit id="318f6eeac5e0a5f73cec3c1a7fec998a2d2b42bf" translate="yes" xml:space="preserve">
          <source>Entry-point Name</source>
          <target state="translated">진입 점 이름</target>
        </trans-unit>
        <trans-unit id="f15859f3eeefa48c8447da8cc8be18ae2f96c167" translate="yes" xml:space="preserve">
          <source>Environment variables created or changed from within GnuCOBOL programs will be available to any sub-shell processes spawned by that program (i.e. CALL &quot;SYSTEM&quot;) but will not be known to the shell or console window that started the GnuCOBOL program.</source>
          <target state="translated">GnuCOBOL 프로그램 내에서 작성 또는 변경된 환경 변수는 해당 프로그램이 생성 한 서브 쉘 프로세스 (예 : CALL &quot;SYSTEM&quot;)에서 사용할 수 있지만 GnuCOBOL 프로그램을 시작한 쉘 또는 콘솔 창에는 알려지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d9b239553d90073cbc48e1842b57308d0f503d32" translate="yes" xml:space="preserve">
          <source>Environment variables created or changed from within GnuCOBOL programs will be available to any sub-shell processes spawned by that program (i.e.&lt;code&gt;CALL 'SYSTEM'&lt;/code&gt;(see &lt;a href=&quot;#SYSTEM&quot;&gt;SYSTEM&lt;/a&gt;)) but will not be known to the shell or console window that started the GnuCOBOL program.</source>
          <target state="translated">GnuCOBOL 프로그램 내에서 작성 또는 변경된 환경 변수는 해당 프로그램이 생성 한 모든 서브 쉘 프로세스 (예 : &lt;code&gt;CALL 'SYSTEM'&lt;/code&gt; ( &lt;a href=&quot;#SYSTEM&quot;&gt;SYSTEM&lt;/a&gt; 참조 ))에서 사용할 수 있지만 GnuCOBOL 프로그램을 시작한 쉘 또는 콘솔 창에는 알려지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a831ca77884d7fa1627dca65d5bcf5b32460e5b1" translate="yes" xml:space="preserve">
          <source>Erased areas will have their foreground and background colors set to the attributes of the field containing the&lt;code&gt;ERASE&lt;/code&gt;clause.</source>
          <target state="translated">지워진 영역의 전경색과 배경색은 &lt;code&gt;ERASE&lt;/code&gt; 절을 포함하는 필드의 속성으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="5da25ad570031cfc548ccf057713182fe2696bf6" translate="yes" xml:space="preserve">
          <source>Error Type</source>
          <target state="translated">오류 유형</target>
        </trans-unit>
        <trans-unit id="091e812df524f11e726f776aeeac24e5d0a26bc7" translate="yes" xml:space="preserve">
          <source>Esc was pressed</source>
          <target state="translated">Esc를 누르면</target>
        </trans-unit>
        <trans-unit id="1d5c1c82e60d938ff99b4032766d8759f53965f9" translate="yes" xml:space="preserve">
          <source>Evaluates to FALSE</source>
          <target state="translated">거짓으로 평가</target>
        </trans-unit>
        <trans-unit id="7718b010814db3432233ea3bdf4b33cc8999b495" translate="yes" xml:space="preserve">
          <source>Evaluates to FALSE AND (FALSE AND TRUE) which evaluates to FALSE</source>
          <target state="translated">FALSE로 평가되는 FALSE AND (FALSE AND TRUE)로 평가</target>
        </trans-unit>
        <trans-unit id="e61648f7d13955bbfcf9bc100110e4859aa8fce4" translate="yes" xml:space="preserve">
          <source>Evaluates to FALSE AND FALSE AND TRUE which evaluates to FALSE</source>
          <target state="translated">FALSE로 평가되는 FALSE 및 FALSE AND TRUE로 평가</target>
        </trans-unit>
        <trans-unit id="dcd13fd025cd8853636d96d1e4febe9db19f5d33" translate="yes" xml:space="preserve">
          <source>Evaluates to NOT (FALSE) which evaluates to TRUE</source>
          <target state="translated">NOT으로 평가되는 NOT (FALSE), TRUE로 평가</target>
        </trans-unit>
        <trans-unit id="382d1cb13ed9d55b2c9159d78c596a71f0163e66" translate="yes" xml:space="preserve">
          <source>Evaluates to TRUE</source>
          <target state="translated">TRUE로 평가</target>
        </trans-unit>
        <trans-unit id="f75486ff1410d50667eeed0386b80ad55880746c" translate="yes" xml:space="preserve">
          <source>Evaluates to TRUE (since AND has precedence over OR) - this is identical to the previous example</source>
          <target state="translated">AND가 OR보다 우선하므로 TRUE로 평가됩니다. 이는 이전 예와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4d6d770c334405188a688baa0a731edb1fd48f77" translate="yes" xml:space="preserve">
          <source>Even without the&lt;code&gt;DEBUGGING MODE&lt;/code&gt;clause, it is still possible to compile debugging lines. Debugging lines may also be compiled by specifying the&lt;code&gt;-fdebugging-line&lt;/code&gt;switch</source>
          <target state="translated">&lt;code&gt;DEBUGGING MODE&lt;/code&gt; 절이 없어도 디버깅 라인을 컴파일 할 수 있습니다. &lt;code&gt;-fdebugging-line&lt;/code&gt; 스위치를 지정하여 디버깅 라인을 컴파일 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="91552a3314a03734e404c7b97ca06f17613df4cd" translate="yes" xml:space="preserve">
          <source>Every &amp;lt;</source>
          <target state="translated">모든 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="9f42753b88c31f07e6bcdfda34cbd05a816f1808" translate="yes" xml:space="preserve">
          <source>Every &amp;lt;&amp;lt;</source>
          <target state="translated">모든 &amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="77e9bb85e78385998b2213a27bb8d8376a21fddb" translate="yes" xml:space="preserve">
          <source>Every data item at the same&lt;code&gt;level&lt;/code&gt;of a hierarchy diagram such as the one you see here (if you were to make one, which you rarely &amp;mdash; if ever &amp;mdash; will, once you get used to this concept) must have the same level number.</source>
          <target state="translated">여기에 표시되는 것과 같이 동일한 &lt;code&gt;level&lt;/code&gt; 의 계층 구조 다이어그램에있는 모든 데이터 항목 (만약이 개념에 익숙해지면 거의 만들지 않는 경우)은 동일한 수준 번호를 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="464315bf9feceba501caec897c0b6079a97e791c" translate="yes" xml:space="preserve">
          <source>Every entry-point has a name. That name must be unique for all programs that comprise an executable program. Entry-point names are defined using a subroutine&amp;rsquo;s&lt;code&gt;PROGRAM-ID&lt;/code&gt;paragraph, a user-defined function&amp;rsquo;s&lt;code&gt;FUNCTION-ID&lt;/code&gt;paragraph or via&lt;code&gt;ENTRY&lt;/code&gt;(see &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY&lt;/a&gt;) statements coded in a subprogram&amp;rsquo;s procedure division.</source>
          <target state="translated">모든 진입 점에는 이름이 있습니다. 해당 이름은 실행 프로그램을 구성하는 모든 프로그램에서 고유해야합니다. 진입 점 이름은 서브 루틴의 &lt;code&gt;PROGRAM-ID&lt;/code&gt; 단락, 사용자 정의 함수의 &lt;code&gt;FUNCTION-ID&lt;/code&gt; 단락을 사용하거나 서브 프로그램의 절차 부서에 코딩 된 &lt;code&gt;ENTRY&lt;/code&gt; ( &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY&lt;/a&gt; 참조 ) 문을 통해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="22c250c80a48d66257ba552ab395682e38c843f2" translate="yes" xml:space="preserve">
          <source>Every new level uses a level number that is strictly greater than the one used in the parent (next higher) level.</source>
          <target state="translated">모든 새 레벨은 상위 (다음 상위) 레벨에서 사용 된 레벨보다 엄격하게 큰 레벨 번호를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e22c344c08f0a674fec53d0ccadbf31f6f3afb87" translate="yes" xml:space="preserve">
          <source>Every non-FILLER elementary item subordinate to &amp;lt;</source>
          <target state="translated">필러가 아닌 모든 기본 항목은 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="004439041e706926e609b461ee10ab7fd206e801" translate="yes" xml:space="preserve">
          <source>Every program has at least one entry-point &amp;mdash; known as the primary entry-point &amp;mdash; which corresponds to the first executable statement in the procedure division following the declaratives area, if any.</source>
          <target state="translated">모든 프로그램에는 선언 영역 다음에있는 프로 시저 분할의 첫 번째 실행 문에 해당하는 하나 이상의 진입 점이 기본 진입 점으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="1601a99f6446d942e939a06dabeb60be03814480" translate="yes" xml:space="preserve">
          <source>Every report has the same basic structure, as shown here, even though not all reports will have all of the groups shown. In fact, it is a very unusual report indeed that actually has every one of these groups:</source>
          <target state="translated">모든 보고서에 모든 그룹이 표시되는 것은 아니지만 모든 보고서는 여기에 표시된 것과 동일한 기본 구조를 갖습니다. 실제로 실제로 다음 그룹 중 하나를 모두 가지고있는 것은 매우 이례적인 보고서입니다.</target>
        </trans-unit>
        <trans-unit id="cec461b13ba9e76a1b658d70ba02bcb163ba81a4" translate="yes" xml:space="preserve">
          <source>Every report that employs control breaks has a natural hierarchy of those control breaks based upon the manner in which the data the report is being generated from is sorted. This concept is best understood using an example which assumes a COBOL program to process sales data collected from every computerized cash register across a chain of stores having multiple departments is being developed.</source>
          <target state="translated">제어 구분을 사용하는 모든 보고서에는 보고서가 생성되는 데이터가 정렬되는 방식에 따라 자연스럽게 제어 구분이 있습니다. 이 개념은 여러 부서가있는 상점 체인에 걸쳐 모든 전산화 된 금전 등록기에서 수집 된 판매 데이터를 처리하는 COBOL 프로그램을 가정하는 예를 사용하여 가장 잘 이해됩니다.</target>
        </trans-unit>
        <trans-unit id="b56d93d247b7135e025b8bb06d8e4f1f8158cab1" translate="yes" xml:space="preserve">
          <source>Every time this program is executed, it will produce the same output, because the same sequence of pseudo-random numbers will be generated:</source>
          <target state="translated">이 프로그램이 실행될 때마다 동일한 시퀀스의 의사 난수가 생성되므로 동일한 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="631a83a57af68e8b556c535abcfba9d122280242" translate="yes" xml:space="preserve">
          <source>Executable File</source>
          <target state="translated">실행 가능 파일</target>
        </trans-unit>
        <trans-unit id="c4aff9d44d0a696a912102a8ff52dc1f8917cec9" translate="yes" xml:space="preserve">
          <source>Executing a&lt;code&gt;DISPLAY UPON COMMAND-LINE&lt;/code&gt;will influence subsequent&lt;code&gt;ACCEPT FROM COMMAND-LINE&lt;/code&gt;statements (which will then return the value you displayed), but will not influence subsequent&lt;code&gt;ACCEPT FROM ARGUMENT-VALUE&lt;/code&gt;statements &amp;mdash; these will continue to return the original program execution parameters.</source>
          <target state="translated">&lt;code&gt;DISPLAY UPON COMMAND-LINE&lt;/code&gt; 실행하면 후속 &lt;code&gt;ACCEPT FROM COMMAND-LINE&lt;/code&gt; 문에 영향을 주지만 (표시된 값을 리턴 함) 이후 &lt;code&gt;ACCEPT FROM ARGUMENT-VALUE&lt;/code&gt; 문에 영향을 미치지 않습니다 . 이는 원래 프로그램 실행 매개 변수를 계속 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b5eccd53038d68d6fe98e6c74bbc70fbdda0f1d8" translate="yes" xml:space="preserve">
          <source>Executing the statement&lt;code&gt;SET &amp;lt;&lt;i&gt;condition-name-1&lt;/i&gt;&amp;gt; TO FALSE&lt;/code&gt;will cause &amp;lt;</source>
          <target state="translated">&lt;code&gt;SET &amp;lt;&lt;i&gt;condition-name-1&lt;/i&gt;&amp;gt; TO FALSE&lt;/code&gt; 문을 실행 하면 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="d3202330dc255528350ed15988600d69cebe769e" translate="yes" xml:space="preserve">
          <source>Executing the statement&lt;code&gt;SET &amp;lt;&lt;i&gt;condition-name-1&lt;/i&gt;&amp;gt; TO TRUE&lt;/code&gt;will cause &amp;lt;</source>
          <target state="translated">&lt;code&gt;SET &amp;lt;&lt;i&gt;condition-name-1&lt;/i&gt;&amp;gt; TO TRUE&lt;/code&gt; 문을 실행 하면 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="699332aeb03074ecdaa898353c6db354128e04e0" translate="yes" xml:space="preserve">
          <source>Execution Thread</source>
          <target state="translated">실행 스레드</target>
        </trans-unit>
        <trans-unit id="f7b699c1f1fca94c3574d70d8a9956ade47096d2" translate="yes" xml:space="preserve">
          <source>Execution of the calling program is suspended and control will transfer to the called program, as follows:</source>
          <target state="translated">호출 프로그램의 실행이 일시 중단되고 다음과 같이 제어가 호출 된 프로그램으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="c1fdde2e7a98a43a8969fd6782e1df3e5e50ec04" translate="yes" xml:space="preserve">
          <source>Execution will begin at the first executable statement following the subprograms entry-point. The entry point will be either the first executable statement following any&lt;code&gt;DECLARATIVES&lt;/code&gt;(see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) that might be present (if the subprogram was invoked using its primary entry-point name) or the first executable statement following the&lt;code&gt;ENTRY&lt;/code&gt;statement (see &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY&lt;/a&gt;) naming the entry-point specified on the&lt;code&gt;CALL&lt;/code&gt;if the subprogram was invoked using an alternate entry point.</source>
          <target state="translated">서브 프로그램 진입 점 다음의 첫 번째 실행 문에서 실행이 시작됩니다. 엔트리 포인트는 것 중 어느 후 첫 실행 문 &lt;code&gt;DECLARATIVES&lt;/code&gt; 는 (참조 &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES를&lt;/a&gt; 하거나 다음 첫 번째 실행 문 (서브 프로그램은 주 진입 점 이름을 사용하여 호출 된 경우))있을 수있는 그 &lt;code&gt;ENTRY&lt;/code&gt; 의 문을 (참조 &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY를&lt;/a&gt; 명명)를 서브 프로그램이 대체 시작점을 사용하여 호출 된 경우 &lt;code&gt;CALL&lt;/code&gt; 에 지정된 시작점.</target>
        </trans-unit>
        <trans-unit id="df928d8218fa60aea80b123d18575cb29a66dc2a" translate="yes" xml:space="preserve">
          <source>Execution will begin with the first executable statement in the procedure division following any&lt;code&gt;DECLARATIVES&lt;/code&gt;(see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) that might be present.</source>
          <target state="translated">실행은 존재할 수있는 &lt;code&gt;DECLARATIVES&lt;/code&gt; ( &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt; 참조 ) 다음에 프로 시저 분할의 첫 번째 실행 문으로 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="813d8ff4c4f053c1fe5a4302c6f9c49604c7c000" translate="yes" xml:space="preserve">
          <source>Execution will resume back in the calling program at the point where the returned value of the function is needed. At that point, the value in the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register will be used for the function&amp;rsquo;s value.</source>
          <target state="translated">함수의 반환 값이 필요한 시점에서 호출 프로그램에서 실행이 다시 시작됩니다. 이때 &lt;code&gt;RETURN-CODE&lt;/code&gt; 특수 레지스터의 값이 함수 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6604bac134b018c911ef4c369060da53971d99cd" translate="yes" xml:space="preserve">
          <source>Execution will resume back in the calling program with the first executable statement following the&lt;code&gt;CALL&lt;/code&gt;that invoked the subprogram.</source>
          <target state="translated">서브 프로그램을 호출 한 &lt;code&gt;CALL&lt;/code&gt; 다음에 첫 번째 실행 문으로 호출 프로그램에서 실행이 다시 시작 됩니다.</target>
        </trans-unit>
        <trans-unit id="1c4f897e49f43d61c8c285a5f8b529c6df7d4952" translate="yes" xml:space="preserve">
          <source>Expiration of the&lt;code&gt;TIMEOUT&lt;/code&gt;timer &amp;mdash; this will be treated as if the Enter key had been pressed with no data being entered.</source>
          <target state="translated">&lt;code&gt;TIMEOUT&lt;/code&gt; 타이머의 만료 &amp;mdash; 데이터를 입력하지 않고 Enter 키를 누른 것처럼 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="97b695b9b9cfde3612c21b3add972cc0f21f4e26" translate="yes" xml:space="preserve">
          <source>Expression</source>
          <target state="translated">Expression</target>
        </trans-unit>
        <trans-unit id="1ba54893e49d5a98fdd72b1731cb837c15733eae" translate="yes" xml:space="preserve">
          <source>F, FACTORIAL, FACTORY, FALSE, FD, FILE, FILE-CONTROL, FILE-ID, FILLER, FINAL, FIRST, FIXED, FLOAT-BINARY-128, FLOAT-BINARY-32, FLOAT-BINARY-64, FLOAT-DECIMAL-16, FLOAT-DECIMAL-34, FLOAT-EXTENDED, FLOAT-INFINITY, FLOAT-LONG, FLOAT-NOT-A-NUMBER, FLOAT-SHORT, FOOTING, FOR, FOREGROUND-COLOR, FOREGROUND-COLOUR, FOREVER, FORMAT, FORMATTED-CURRENT-DATE, FORMATTED-DATE, FORMATTED-DATETIME, FORMATTED-TIME, FORMFEED, FRACTION-PART, FREE, FROM, FULL, FUNCTION, FUNCTION-ID, FUNCTION-POINTER</source>
          <target state="translated">F, 공장, 공장, 거짓, FD, 파일, 파일 제어, 파일 ID, 필러, 최종, 첫 번째, 고정, 플로트 이진 -128, 플로트 이진 -32, 플로트 이진 -64, 플로트 데크 16, FLOAT-DECIMAL-34, FLOAT-EXTENDED, FLOAT-INFINITY, FLOAT-LONG, FLOAT-NOT-A-NUMBER, FLOAT-SHORT, FOOTING, FOR, FOREGROUND-COLOR, FOREGROUND-COLOUR, FOREVER, FORMAT, FORMAT- CURRENT-DATE, FORMATTED-DATE, FORMATTED-DATETIME, FORMATTED-TIME, FORMFEED, FRACTION-PART, FREE, FROM, FULL, FUNCTION, FUNCTION-ID, FUNCTION-POINTER</target>
        </trans-unit>
        <trans-unit id="c388ca73e917511c83a42c7c3347b5330aa45cac" translate="yes" xml:space="preserve">
          <source>F1&amp;ndash;F64, respectively, were pressed</source>
          <target state="translated">F1&amp;ndash;F64를 각각 눌렀습니다.</target>
        </trans-unit>
        <trans-unit id="03de1b80d9ce6c956e045a67ec26864bd9ba86c4" translate="yes" xml:space="preserve">
          <source>FACTORIAL Function Syntax</source>
          <target state="translated">FACTORIAL 함수 구문</target>
        </trans-unit>
        <trans-unit id="c9236dbf1d5f35b60810d9900ebae017d4554e9f" translate="yes" xml:space="preserve">
          <source>FALSE Clause Syntax</source>
          <target state="translated">거짓 조항 구문</target>
        </trans-unit>
        <trans-unit id="237f463d19c40eb262085170910a45a2579d4007" translate="yes" xml:space="preserve">
          <source>FILE SECTION Syntax</source>
          <target state="translated">파일 섹션 구문</target>
        </trans-unit>
        <trans-unit id="6dfe1492af3adfd94529936ae7572256a4829765" translate="yes" xml:space="preserve">
          <source>FILE-SECTION-Data-Item</source>
          <target state="translated">FILE-SECTION-Data-Item</target>
        </trans-unit>
        <trans-unit id="a00fbabfeb0e3333ddad8f67452398d7a56df6cc" translate="yes" xml:space="preserve">
          <source>FILE-SECTION-Data-Item Syntax</source>
          <target state="translated">파일 섹션 데이터 항목 구문</target>
        </trans-unit>
        <trans-unit id="3e19d8cecb7e5bc7a9e28e9032b126d8e079e6f9" translate="yes" xml:space="preserve">
          <source>FOREGROUND-COLOR Attribute Syntax</source>
          <target state="translated">FOREGROUND-COLOR 속성 구문</target>
        </trans-unit>
        <trans-unit id="d5452f4037c6aa0b6e742313c3d7af9ddb944ba1" translate="yes" xml:space="preserve">
          <source>FRACTION-PART Function Syntax</source>
          <target state="translated">FRACTION-PART 함수 구문</target>
        </trans-unit>
        <trans-unit id="6a87ce926e3fdeec20b1a39152e04f9b4879b7c9" translate="yes" xml:space="preserve">
          <source>FREE Syntax</source>
          <target state="translated">무료 구문</target>
        </trans-unit>
        <trans-unit id="42879485a7a11418680abc60f6ddfab84a32360f" translate="yes" xml:space="preserve">
          <source>FROM Clause Syntax</source>
          <target state="translated">FROM 절 구문</target>
        </trans-unit>
        <trans-unit id="2f45ea6b6316a4f10231808ddaece8cd1888d793" translate="yes" xml:space="preserve">
          <source>FULL Attribute Syntax</source>
          <target state="translated">전체 속성 구문</target>
        </trans-unit>
        <trans-unit id="19aa8d076903fa405aac265ff791623484d35537" translate="yes" xml:space="preserve">
          <source>Fails due to rule #1</source>
          <target state="translated">규칙 # 1로 인해 실패</target>
        </trans-unit>
        <trans-unit id="c8f41e04860a699d459755ee5bc85c6fd14d5b99" translate="yes" xml:space="preserve">
          <source>Fails due to rule #2a</source>
          <target state="translated">규칙 # 2a로 인해 실패</target>
        </trans-unit>
        <trans-unit id="ff00be8ee320bab1c7ba44d9360894c017495313" translate="yes" xml:space="preserve">
          <source>Fails due to rule #2b</source>
          <target state="translated">규칙 # 2b로 인해 실패</target>
        </trans-unit>
        <trans-unit id="75efda3b01e99fcd496782dcc687d25e00babfe5" translate="yes" xml:space="preserve">
          <source>Fails due to rule #3a</source>
          <target state="translated">규칙 # 3a로 인해 실패</target>
        </trans-unit>
        <trans-unit id="050c309a1409aa9e640bd99affba7737a0884c7e" translate="yes" xml:space="preserve">
          <source>Fails due to rule #3b</source>
          <target state="translated">규칙 # 3b로 인해 실패</target>
        </trans-unit>
        <trans-unit id="296fa1d7af3bb7cac562c31b466a3232f2bb3696" translate="yes" xml:space="preserve">
          <source>Fails due to rule #5</source>
          <target state="translated">규칙 # 5로 인해 실패</target>
        </trans-unit>
        <trans-unit id="8ba4b7cd854379dc43efe678aa9fc863d5f197f9" translate="yes" xml:space="preserve">
          <source>Fails due to rule #6</source>
          <target state="translated">규칙 # 6으로 인해 실패</target>
        </trans-unit>
        <trans-unit id="1c882dc98a68cae48a636d1057fb89ac7d36d44d" translate="yes" xml:space="preserve">
          <source>Failure Reason</source>
          <target state="translated">실패 이유</target>
        </trans-unit>
        <trans-unit id="c35c802e8500c8d21fd613e5ef4507f4da40a451" translate="yes" xml:space="preserve">
          <source>Fatal screen I/O error</source>
          <target state="translated">치명적인 화면 I / O 오류</target>
        </trans-unit>
        <trans-unit id="e19ab926093727a391692498a7ce5cfb742d2ae9" translate="yes" xml:space="preserve">
          <source>Field Outlining</source>
          <target state="translated">필드 개요</target>
        </trans-unit>
        <trans-unit id="3e7ab145eda1bc068c4891bdc4d2491b7ca3babf" translate="yes" xml:space="preserve">
          <source>Figurative Constants</source>
          <target state="translated">형상 상수</target>
        </trans-unit>
        <trans-unit id="daa8d8ba501862c2b07978aab870f1b814a865ba" translate="yes" xml:space="preserve">
          <source>File Location Strings are used (at runtime) to identify the path and filename to the data file that must be attached to &amp;lt;</source>
          <target state="translated">파일 위치 문자열은 런타임시 &amp;lt;에 첨부해야하는 데이터 파일의 경로와 파일 이름을 식별하는 데 사용됩니다 (</target>
        </trans-unit>
        <trans-unit id="0f3e89f8a70a0298352574b5f3d10f8e9f6307ef" translate="yes" xml:space="preserve">
          <source>File Location Strings will be discussed shortly.</source>
          <target state="translated">파일 위치 문자열은 곧 논의 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="30ee6392d050dffb23e534b9b1e788b586e3c285" translate="yes" xml:space="preserve">
          <source>File already open</source>
          <target state="translated">파일이 이미 열려 있습니다</target>
        </trans-unit>
        <trans-unit id="1f1c6a46840542ee93667be29fe00c4a2ca6e55e" translate="yes" xml:space="preserve">
          <source>File not available</source>
          <target state="translated">사용할 수없는 파일</target>
        </trans-unit>
        <trans-unit id="a22e9c3b6a9f5c70de4f76a464810ecba1fb97c3" translate="yes" xml:space="preserve">
          <source>File not found</source>
          <target state="translated">파일을 찾을 수 없습니다</target>
        </trans-unit>
        <trans-unit id="d5a01ba68e46b606375d0915c493efcb6d3e3101" translate="yes" xml:space="preserve">
          <source>File not open</source>
          <target state="translated">파일이 열리지 않습니다</target>
        </trans-unit>
        <trans-unit id="aa73a3bd94b48e7abeca430b784ba4827580e7e5" translate="yes" xml:space="preserve">
          <source>File section data buffers (and therefore all 01-level record layouts defined in the file section) are initialized to all binary zeros when the program is loaded into storage.</source>
          <target state="translated">파일 섹션 데이터 버퍼 (및 파일 섹션에 정의 된 모든 01 레벨 레코드 레이아웃)는 프로그램이 스토리지에로드 될 때 모든 이진 0으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="2b5ebf13d43a94cfe869d3ece0ff8aa5a1595ced" translate="yes" xml:space="preserve">
          <source>File sharing failure</source>
          <target state="translated">파일 공유 실패</target>
        </trans-unit>
        <trans-unit id="d6b7a316c213638a85b3dd6184fc41aa5cc4fb7b" translate="yes" xml:space="preserve">
          <source>File sharing is controlled through the use of a&lt;code&gt;SHARING&lt;/code&gt;</source>
          <target state="translated">파일 공유는의 사용을 통해 제어됩니다 &lt;code&gt;SHARING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f47df965cafac62967f207b6e7f09ae5add8b8f" translate="yes" xml:space="preserve">
          <source>File-Based SORT Syntax</source>
          <target state="translated">파일 기반 SORT 구문</target>
        </trans-unit>
        <trans-unit id="d87ff91def81de51380ccde36991f463b59063af" translate="yes" xml:space="preserve">
          <source>File/Sort-Description Syntax</source>
          <target state="translated">파일 / 정렬 설명 구문</target>
        </trans-unit>
        <trans-unit id="7083473fe7c031e4e4634ba20b9fb70b80346024" translate="yes" xml:space="preserve">
          <source>Files assigned to&lt;code&gt;PRINTER&lt;/code&gt;or&lt;code&gt;CONSOLE&lt;/code&gt;should be specified as&lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;PRINTER&lt;/code&gt; 또는 &lt;code&gt;CONSOLE&lt;/code&gt; 에 지정된 파일 은 &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; 로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="edea6aacf2ec3d63ce72d8e95db88b7bd15eacd7" translate="yes" xml:space="preserve">
          <source>Files destined for use as sort/merge work files must be described with a Sort/Merge File Description &lt;code&gt;SD&lt;/code&gt; while every other file is described with a File Description &lt;code&gt;FD&lt;/code&gt;. Each of these descriptions will almost always be followed with at least one record description.</source>
          <target state="translated">정렬 / 병합 작업 파일로 사용되는 파일은 정렬 / 병합 파일 설명 &lt;code&gt;SD&lt;/code&gt; 를 사용하여 설명해야하며 다른 모든 파일은 파일 설명 &lt;code&gt;FD&lt;/code&gt; 를 사용하여 설명해야합니다 . 이러한 각 설명에는 거의 항상 하나 이상의 레코드 설명이옵니다.</target>
        </trans-unit>
        <trans-unit id="367feea21d15dacc3ac862c7a57bd856bad73096" translate="yes" xml:space="preserve">
          <source>Finally, COBOL has the ability to perform in-place sorts of the data that is found in a table.</source>
          <target state="translated">마지막으로 COBOL은 테이블에서 찾은 데이터를 제자리에서 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6001a209721116a31aff91d01e445326ed01374" translate="yes" xml:space="preserve">
          <source>Finally, here&amp;rsquo;s the report the program generates!</source>
          <target state="translated">마지막으로, 프로그램이 생성하는 보고서가 있습니다!</target>
        </trans-unit>
        <trans-unit id="f8e1fd8ed05817c2c1238d06570433fc37097c39" translate="yes" xml:space="preserve">
          <source>Finally,the&lt;code&gt;REPORT FOOTING&lt;/code&gt;group, if any, will be presented.</source>
          <target state="translated">마지막으로 &lt;code&gt;REPORT FOOTING&lt;/code&gt; 그룹 (있는 경우)이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8a928ac89796afd20a583c169e78e1d2e97f3cee" translate="yes" xml:space="preserve">
          <source>First, the &quot;Hard Way&quot;:</source>
          <target state="translated">먼저 &quot;하드 웨이&quot;:</target>
        </trans-unit>
        <trans-unit id="69a656c5968fc19e26398c39c1d42930578021ec" translate="yes" xml:space="preserve">
          <source>First/Last Digit</source>
          <target state="translated">첫 번째 / 마지막 자리</target>
        </trans-unit>
        <trans-unit id="c698ef5e7b0a316052b55cd8ba9f275dd3cc64d1" translate="yes" xml:space="preserve">
          <source>Fixed Format Mode</source>
          <target state="translated">고정 형식 모드</target>
        </trans-unit>
        <trans-unit id="fb6455fd910bbce0c221e84e30d7a80946a5a47c" translate="yes" xml:space="preserve">
          <source>Floating-point values using &quot;Enn&quot; notation such as 9.92E25, representing 9.92 x 10^25 (10 raised to the 25th power) or 5.7E-14, representing 5.7 x 10^-14 (10 raised to the -14th power). Both the mantissa (the number before the E) and the exponent (the number after the E) may be explicitly specified as positive (with a +), negative (with a -) or unsigned (and therefore implicitly positive). A floating-point literals value must be within the range -1.7 x 10^308 to +1.7 x 10^308 with no more than 15 decimal digits of precision.</source>
          <target state="translated">9.92 x 10 ^ 25 (10은 25 승으로 올림) 또는 5.7E-14를 나타내는 9.92E25와 같이 &quot;Enn&quot;표기법을 사용하는 부동 소수점 값 . 가수 (E 이전의 숫자)와 지수 (E 이후의 숫자)는 모두 양수 (+), 음수 (-) 또는 부호없는 (따라서 암시 적으로 양수)로 명시 적으로 지정할 수 있습니다. 부동 소수점 리터럴 값은 -1.7 x 10 ^ 308-+1.7 x 10 ^ 308 범위에 있어야하며 소수점 이하 자릿수는 15 자리를 넘지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="5988bca9b2f3443b9ecd1f06fab806eb243168de" translate="yes" xml:space="preserve">
          <source>Footing Area</source>
          <target state="translated">바닥 면적</target>
        </trans-unit>
        <trans-unit id="e40c95fbb3b9dc7a620c19bde2435c717bde7695" translate="yes" xml:space="preserve">
          <source>Footing Area &amp;mdash; An exception to this is the situation where the report footing report group contains the&lt;code&gt;NEXT PAGE&lt;/code&gt;option in its&lt;code&gt;LINE&lt;/code&gt;(see &lt;a href=&quot;#LINE&quot;&gt;LINE&lt;/a&gt;) clause; in those cases, the report footing will be presented on a page by itself at the end of the report.</source>
          <target state="translated">Footing Area &amp;mdash; 보고서 예외 보고서 그룹 의 &lt;code&gt;LINE&lt;/code&gt; ( &lt;a href=&quot;#LINE&quot;&gt;LINE&lt;/a&gt; 참조 ) 절 에 &lt;code&gt;NEXT PAGE&lt;/code&gt; 옵션이 포함 된 상황은 예외입니다 . 이 경우 보고서 마지막 부분에 보고서 기초가 페이지에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a3127f980dbd36611f50532c041a2233802b3eff" translate="yes" xml:space="preserve">
          <source>For all other data types, the field size is set to the size of the item (same as if CONVERT were not specified).</source>
          <target state="translated">다른 모든 데이터 유형의 경우 필드 크기는 항목의 크기로 설정됩니다 (CONVERT가 지정되지 않은 것과 동일).</target>
        </trans-unit>
        <trans-unit id="c1fcb175d336c0714548be23a006f2304e931f29" translate="yes" xml:space="preserve">
          <source>For each source item, the contents of the sending item will be copied &amp;mdash; character-by-character &amp;mdash; into &amp;lt;</source>
          <target state="translated">각 소스 항목에 대해 전송 항목의 내용이 문자별로 복사되어 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="cf9156cf449643f9bda337a140c24f2f1504f039" translate="yes" xml:space="preserve">
          <source>For example, You will not expect to see any difference whatsoever between values of 1, 100, 500 or 1000, but you should see a difference between values such as 250000000 and 500000000.</source>
          <target state="translated">예를 들어, 1, 100, 500 또는 1000 값의 차이는 없을 것으로 예상되지만 250000000 및 500000000과 같은 값의 차이는 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3368f51d3762d71c83916eebf4457e0236b996e5" translate="yes" xml:space="preserve">
          <source>For example, assuming the program is using the standard ASCII collating sequence,&lt;code&gt;ORD('!')&lt;/code&gt;returns 34 because &quot;!&quot; is the 34th ASCII character. If you are using this function to convert an ASCII character to its numeric value, you must subtract one from the result.</source>
          <target state="translated">예를 들어, 프로그램이 표준 ASCII 조합 순서를 사용한다고 가정하면 &lt;code&gt;ORD('!')&lt;/code&gt; 는 &quot;!&quot; 34 번째 ASCII 문자입니다. 이 기능을 사용하여 ASCII 문자를 숫자 값으로 변환하는 경우 결과에서 하나를 빼야합니다.</target>
        </trans-unit>
        <trans-unit id="55a9ee5de13cdf67bb331bd003f29ecf42021db7" translate="yes" xml:space="preserve">
          <source>For example, assuming the program is using the standard ASCII collating sequence,&lt;code&gt;ORD-MAX('Z', 'z', '!')&lt;/code&gt;returns 2 because the 2nd character in the argument list (the ASCII character &amp;rsquo;z&amp;rsquo;) occurs after &amp;rsquo;Z&amp;rsquo; and &amp;rsquo;!&amp;rsquo; in the program collating sequence. Each &amp;lt;</source>
          <target state="translated">예를 들어, 프로그램이 표준 ASCII 조합 순서를 사용한다고 가정하면 &lt;code&gt;ORD-MAX('Z', 'z', '!')&lt;/code&gt; 는 인수 목록의 두 번째 문자 (ASCII 문자 'z')가 다음에 발생하므로 2를 리턴합니다. 'Z'와 '!' 프로그램 조합 순서에서. 각 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="0b8897a3e322f2447e1c9d83730f3c7e2254e611" translate="yes" xml:space="preserve">
          <source>For example, assuming the program is using the standard ASCII collating sequence,&lt;code&gt;ORD-MIN('Z', 'z', '!')&lt;/code&gt;returns 3 because the 3rd character in the argument list (the ASCII character &amp;rsquo;!&amp;rsquo;) occurs before &amp;rsquo;Z&amp;rsquo; and &amp;rsquo;z&amp;rsquo; in the program collating sequence. Each &amp;lt;</source>
          <target state="translated">예를 들어, 프로그램이 표준 ASCII 조합 순서를 사용한다고 가정하면 &lt;code&gt;ORD-MIN('Z', 'z', '!')&lt;/code&gt; 은 인수 목록의 3 번째 문자 (ASCII 문자 '!')가 발생하기 때문에 3을 리턴합니다. 프로그램 조합 순서에서 'Z'및 'z' 각 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="749e13e172aac64f618104a47c4a2c7a40595730" translate="yes" xml:space="preserve">
          <source>For example, if &amp;lt;</source>
          <target state="translated">예를 들어 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="24697a3ba1d925f052573a7696493b003e3077cd" translate="yes" xml:space="preserve">
          <source>For example, if the program is using the (default) ASCII character set, CHAR(34) returns the 34th character in the ASCII character set &amp;mdash; an exclamation-point (&quot;!&quot;). If you are using this function to convert a numeric value to its corresponding ASCII character, you must use an argument value one greater than the numeric value.</source>
          <target state="translated">예를 들어, 프로그램이 (기본) ASCII 문자 집합을 사용하는 경우 CHAR (34)는 ASCII 문자 집합의 34 번째 문자 인 느낌표 ( &quot;!&quot;)를 반환합니다. 이 함수를 사용하여 숫자 값을 해당 ASCII 문자로 변환하는 경우 숫자 값보다 하나 더 큰 인수 값을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="86d303a32d15849fb5f8b370e6bee4a9d77d8625" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s assume we&amp;rsquo;re sorting a series of financial transactions. The SORT statement might look like this:</source>
          <target state="translated">예를 들어, 일련의 금융 거래를 정렬한다고 가정 해 봅시다. SORT 문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb00a63cdc6f6eb78d00ce4dd102beadda021aab" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say you need to allocate a data item that contains however many millions of dollars of revenue your company has in gross revenues this year:</source>
          <target state="translated">예를 들어 올해 회사가 총 매출에서 수백만 달러의 수입을 포함하는 데이터 항목을 할당해야한다고 가정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="baad68c9ee59c08b3b83b0d9b5e6c9c54362d8ca" translate="yes" xml:space="preserve">
          <source>For example, observe the following data structure which defines a 4 column by 3 row grid of characters:</source>
          <target state="translated">예를 들어, 4 열 x 3 행 문자 격자를 정의하는 다음 데이터 구조를 관찰하십시오.</target>
        </trans-unit>
        <trans-unit id="3aafb29761d15f601ec670e73bfded28362456c7" translate="yes" xml:space="preserve">
          <source>For example, the following defines a class called &quot;Hexadecimal&quot;, the definition of which specifies the only characters that may be present in an alphanumeric data item if that data item is to be part of the &quot;Hexadecimal&quot; class:</source>
          <target state="translated">예를 들어, 다음은 &quot;16 진수&quot;라는 클래스를 정의합니다. 정의는 해당 데이터 항목이 &quot;16 진수&quot;클래스의 일부인 경우 영숫자 데이터 항목에 존재할 수있는 유일한 문자를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dab6ce21e23d5e22f729efd782034eee11b18ef5" translate="yes" xml:space="preserve">
          <source>For files in the&lt;code&gt;SEQUENTIAL&lt;/code&gt;access mode, the last input-output statement executed against &amp;lt;</source>
          <target state="translated">&lt;code&gt;SEQUENTIAL&lt;/code&gt; 액세스 모드 에있는 파일의 경우 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="0033fcaf736090140a9ae955ceeeed639d0db017" translate="yes" xml:space="preserve">
          <source>For non-trivial computations,&lt;code&gt;COMPUTE&lt;/code&gt;statements &quot;read&quot; better. Take this, for example:</source>
          <target state="translated">사소한 계산의 경우 &lt;code&gt;COMPUTE&lt;/code&gt; 문이 &quot;읽기&quot;좋습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4b25cf83aa9b241d27a0438f702e22b38e6a5771" translate="yes" xml:space="preserve">
          <source>For non-trivial computations,&lt;code&gt;COMPUTE&lt;/code&gt;statements may execute faster than the equivalent chain of basic arithmetic statements. For example, the COMPUTE statement shown above executes about 25% faster on my computer using GnuCOBOL than does the MULTIPLY-ADD-DIVIDE sequence.</source>
          <target state="translated">사소한 계산의 경우, &lt;code&gt;COMPUTE&lt;/code&gt; 문은 기본 산술 명령문의 동등한 체인보다 빠르게 실행될 수 있습니다. 예를 들어, 위에 표시된 COMPUTE 문은 MULTIPLY-ADD-DIVIDE 시퀀스보다 GnuCOBOL을 사용하는 컴퓨터에서 약 25 % 더 빠르게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="483a043da3e58761a7a31d92b7cee03f34d3a0e9" translate="yes" xml:space="preserve">
          <source>For quite a while now (back to the late 1970&amp;rsquo;s), the &quot;sequence number area&quot; of a COBOL statement (columns 1-6) has come to be used as a change indicator area. Programmers would place a code in columns 1-6 of every line they changed in a program. The author works in a COBOL shop where change indicators of the form &quot;xxmmyy&quot; are required on every altered line of a program &amp;mdash; &quot;xx&quot; is the initials of the programmer while &quot;mmyy&quot; are the month and two-digit year of the date the change was made. This is frequently accompanied by a comment block at or near the top of a COBOL program providing general documentation of what changes were made and what change indicator was used to mark that change.</source>
          <target state="translated">꽤 오랫동안 (1970 년대 후반으로), COBOL 문의 &quot;열 번호 영역&quot;(1-6 열)이 변경 표시기 영역으로 사용되었습니다. 프로그래머는 프로그램에서 변경 한 모든 줄의 1-6 열에 코드를 배치합니다. 저자는 프로그램의 모든 변경된 줄에 &quot;xxmmyy&quot;형식의 변경 표시기가 필요한 COBOL 상점에서 작업합니다. &quot;xx&quot;는 프로그래머의 이니셜이고 &quot;mmyy&quot;는 날짜의 월과 두 자리 연도입니다. 변경되었습니다. 여기에는 COBOL 프로그램의 맨 위 또는 근처에 주석 블록이 수반되어 변경 내용 및 변경 표시에 사용 된 변경 표시에 대한 일반적인 문서를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e2dea5e1669c0a9fe3c1fbcb48cb6bd943c60b26" translate="yes" xml:space="preserve">
          <source>For the sake of brevity, this document lists the data in three columns.</source>
          <target state="translated">간략하게하기 위해이 문서는 데이터를 세 개의 열로 나열합니다.</target>
        </trans-unit>
        <trans-unit id="ba325520d21c79af4680da537a3249fca4c6eeab" translate="yes" xml:space="preserve">
          <source>For the values specified on a&lt;code&gt;PAGE LIMIT&lt;/code&gt;clause to be valid, all of the following must be true:</source>
          <target state="translated">&lt;code&gt;PAGE LIMIT&lt;/code&gt; 절 에 지정된 값 이 유효하려면 다음이 모두 참이어야합니다.</target>
        </trans-unit>
        <trans-unit id="efdae81d538ace29e7236aee7c1c96a4ee6706e5" translate="yes" xml:space="preserve">
          <source>For trivial computations, on the other hand, I prefer the inherent readability of a statement such as this:</source>
          <target state="translated">반면에 사소한 계산의 경우 다음과 같은 문장의 고유 한 가독성을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="09bebf0bea412802e3fbb625d9294d89526d28f2" translate="yes" xml:space="preserve">
          <source>Format 1 of the&lt;code&gt;REPLACE&lt;/code&gt;statement can be used to make changes to program source code in much the same way as the&lt;code&gt;REPLACING&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;REPLACE&lt;/code&gt; 문의 형식 1을 사용하면 &lt;code&gt;REPLACING&lt;/code&gt; 과 거의 같은 방식으로 프로그램 소스 코드를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e143df1aa83eabbe82d17220703bff1e6c2ae88e" translate="yes" xml:space="preserve">
          <source>Free Format Mode</source>
          <target state="translated">자유 형식 모드</target>
        </trans-unit>
        <trans-unit id="fbc349f93c5e079ef91504e8bcea3293322299f8" translate="yes" xml:space="preserve">
          <source>From the sequence of &amp;lt;</source>
          <target state="translated">&amp;lt;의 순서에서</target>
        </trans-unit>
        <trans-unit id="ffd07c1bac910139b31da58ed3629443089db490" translate="yes" xml:space="preserve">
          <source>Full awareness of where the &quot;pen&quot; is about to &quot;write&quot; on the current page, automatically forcing an eject to a new page, along with the automatic generation of a page footer to close the old page and/or a page header to begin the new one.</source>
          <target state="translated">현재 페이지에서 &quot;펜&quot;이 &quot;쓰기&quot;되는 위치를 완전히 인식하여 이전 페이지 및 / 또는 페이지 머리글을 닫기위한 페이지 바닥 글 자동 생성과 함께 새 페이지로 자동으로 배출 새로운 것.</target>
        </trans-unit>
        <trans-unit id="3a8b63681a5465651b7dd860e482efb9e8de5eee" translate="yes" xml:space="preserve">
          <source>Full-line comments</source>
          <target state="translated">전체 댓글</target>
        </trans-unit>
        <trans-unit id="a21a4b632492cfc3397cd22cf7495b9aac4c3cd0" translate="yes" xml:space="preserve">
          <source>Full-line comments with form-feed</source>
          <target state="translated">양식 피드가 포함 된 전체 주석</target>
        </trans-unit>
        <trans-unit id="a09ae3cf11bf198bd67625dda3216ea87527262f" translate="yes" xml:space="preserve">
          <source>Function argument error</source>
          <target state="translated">함수 인수 오류</target>
        </trans-unit>
        <trans-unit id="fe94fb61bab790759d07739129a3829c99d0ddcc" translate="yes" xml:space="preserve">
          <source>GENERATE Syntax</source>
          <target state="translated">생성 구문</target>
        </trans-unit>
        <trans-unit id="ce7e9bdff283283e8c751261303522d7a587ceec" translate="yes" xml:space="preserve">
          <source>GENERATE, GET, GIVING, GLOBAL, GO, GOBACK, GREATER, GRID, GROUP, GROUP-USAGE</source>
          <target state="translated">생성, GET, GIVING, GLOBAL, GO, GOBACK, GREATER, GRID, GROUP, GROUP-USAGE</target>
        </trans-unit>
        <trans-unit id="3f77fc06eaeeaf7f12de14c907a75f7348ac4dc4" translate="yes" xml:space="preserve">
          <source>GLOBAL Attribute Syntax</source>
          <target state="translated">글로벌 속성 구문</target>
        </trans-unit>
        <trans-unit id="be6aeb1acd05ec878a2af6fecff181b13e85aa9a" translate="yes" xml:space="preserve">
          <source>GO TO DEPENDING ON Syntax</source>
          <target state="translated">구문에 따라 이동</target>
        </trans-unit>
        <trans-unit id="64f22d3218b9eaee10fe86a76b0f4f7308747bfe" translate="yes" xml:space="preserve">
          <source>GOBACK Syntax</source>
          <target state="translated">GOBACK 구문</target>
        </trans-unit>
        <trans-unit id="508368112dc00f3cf1200af84f7e4f2f7a3b1cbd" translate="yes" xml:space="preserve">
          <source>GROUP-INDICATE Attribute Syntax</source>
          <target state="translated">GROUP-INDICATE 속성 구문</target>
        </trans-unit>
        <trans-unit id="c9af09d3388e8d49bb54cf04c1c03cad69919dbf" translate="yes" xml:space="preserve">
          <source>Generally, these routines are intended to match those available in Micro Focus COBOL, ACUCOBOL and directly for GnuCOBOL.</source>
          <target state="translated">일반적으로 이러한 루틴은 Micro Focus COBOL, ACUCOBOL 및 GnuCOBOL에서 직접 사용할 수있는 루틴과 일치하도록 고안되었습니다.</target>
        </trans-unit>
        <trans-unit id="9d41e5d8aa938481797b811e06ef4d213ca2b12d" translate="yes" xml:space="preserve">
          <source>Generic terms representing user-defined substitutable items will be shown entirely in lower-case in syntax diagrams. When such items are referenced in text, they will appear as &amp;lt;</source>
          <target state="translated">사용자 정의 대체 가능 항목을 나타내는 일반 용어는 구문 다이어그램에서 모두 소문자로 표시됩니다. 이러한 항목이 텍스트로 참조되면 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="a9457bdd27c6a3d78025d6c377d1adcbbc659a08" translate="yes" xml:space="preserve">
          <source>Getting file information (size and last-modification date/time)</source>
          <target state="translated">파일 정보 얻기 (크기 및 최종 수정 날짜 / 시간)</target>
        </trans-unit>
        <trans-unit id="75e08852c633c9bcebe7ab91746503bd91ff4946" translate="yes" xml:space="preserve">
          <source>Getting the length (in bytes) of an argument passed to a subroutine</source>
          <target state="translated">서브 루틴에 전달 된 인수의 길이 (바이트) 가져 오기</target>
        </trans-unit>
        <trans-unit id="838fcc5009c91a67ccafcd3d8a98dceb9843f0c5" translate="yes" xml:space="preserve">
          <source>Giving a table an initial, compile-time value is one of the trickier aspects of COBOL data definition. There are basically three standard techniques and a fourth that people familiar with other COBOL implementations but new to GnuCOBOL may find interesting. So, here are the three</source>
          <target state="translated">테이블에 초기 컴파일 시간 값을주는 것은 COBOL 데이터 정의의 까다로운 측면 중 하나입니다. 다른 COBOL 구현에 익숙하지만 GnuCOBOL에 익숙하지 않은 사람들은 기본적으로 세 가지 표준 기술과 네 번째 표준이 있습니다. 그래서 여기에 세</target>
        </trans-unit>
        <trans-unit id="dacd5d80181f68a262558fbeed5d04078293a6de" translate="yes" xml:space="preserve">
          <source>GnuCOBOL</source>
          <target state="translated">GnuCOBOL</target>
        </trans-unit>
        <trans-unit id="b879a384bcf6b18e0b722cf0970e253d133c9742" translate="yes" xml:space="preserve">
          <source>GnuCOBOL Sample Programs</source>
          <target state="translated">GnuCOBOL 샘플 프로그램</target>
        </trans-unit>
        <trans-unit id="e9fc1fe76cf391a32dad55a122f4e0a0353992f7" translate="yes" xml:space="preserve">
          <source>GnuCOBOL always behaves as if the&lt;code&gt;WITH DUPLICATES IN ORDER&lt;/code&gt;clause is specified, even if it isn&amp;rsquo;t.</source>
          <target state="translated">GnuCOBOL은 &lt;code&gt;WITH DUPLICATES IN ORDER&lt;/code&gt; 절이 지정되지 않은 경우에도 항상 지정된 것처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="9e90bf626298379ff7d3f8b411b399e5608f6660" translate="yes" xml:space="preserve">
          <source>GnuCOBOL considers&lt;code&gt;ASCII&lt;/code&gt;</source>
          <target state="translated">GnuCOBOL은 &lt;code&gt;ASCII&lt;/code&gt; 를 고려합니다</target>
        </trans-unit>
        <trans-unit id="ade20b6aef56cd0ff2aed2427da9159fa14af39b" translate="yes" xml:space="preserve">
          <source>GnuCOBOL defines compilation variables when certain conditions are true.</source>
          <target state="translated">GnuCOBOL은 특정 조건이 참일 때 컴파일 변수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="12cf00b4626858f857b18dd724c1c9875f678c7e" translate="yes" xml:space="preserve">
          <source>GnuCOBOL fully supports much of the ANSI 85 standard for COBOL (the only major exclusion is the Communications Module) and also supports some of the components of the COBOL2002 standard, such as the&lt;code&gt;SCREEN SECTION&lt;/code&gt;(see &lt;a href=&quot;#SCREEN-SECTION&quot;&gt;SCREEN SECTION&lt;/a&gt;), table-based&lt;code&gt;SORT&lt;/code&gt;(see &lt;a href=&quot;#Table-SORT&quot;&gt;Table SORT&lt;/a&gt;) and user-defined functions.</source>
          <target state="translated">GnuCOBOL은 COBOL에 대한 많은 ANSI 85 표준 (통신 모듈 만 유일하게 제외)을 완전히 지원하고 &lt;code&gt;SCREEN SECTION&lt;/code&gt; ( &lt;a href=&quot;#SCREEN-SECTION&quot;&gt;스크린 섹션&lt;/a&gt; 참조 ), 테이블 기반 &lt;code&gt;SORT&lt;/code&gt; 와 같은 COBOL2002 표준의 일부 구성 요소도 지원합니다 (참조 &lt;a href=&quot;#Table-SORT&quot;&gt;표 SORT&lt;/a&gt; ) 및 사용자 정의 함수</target>
        </trans-unit>
        <trans-unit id="97e9d0710dd9b847b88301b5ded4630f6ebd6cf5" translate="yes" xml:space="preserve">
          <source>GnuCOBOL has also been built as a truly native Windows application utilizing Microsoft&amp;rsquo;s freely-downloadable Visual Studio Express package to provide the C compiler and linker/loader. This approach does not lend itself well to a &quot;portable&quot; distribution.</source>
          <target state="translated">GnuCOBOL은 또한 무료로 다운로드 할 수있는 Microsoft의 Visual Studio Express 패키지를 사용하여 C 컴파일러 및 링커 / 로더를 제공하는 진정한 네이티브 Windows 응용 프로그램으로 구축되었습니다. 이 접근 방식은 &quot;휴대용&quot;배포에 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="763499a319b22b6d28fecd96e5e4577d44422e38" translate="yes" xml:space="preserve">
          <source>GnuCOBOL programs compiled with the&lt;code&gt;-x&lt;/code&gt;switch</source>
          <target state="translated">&lt;code&gt;-x&lt;/code&gt; 스위치로 컴파일 된 GnuCOBOL 프로그램</target>
        </trans-unit>
        <trans-unit id="20252ad5ff4fe084533d45067eda2369ad4e5568" translate="yes" xml:space="preserve">
          <source>GnuCOBOL run-time screen management must have been initialized prior to CALLing this routine in order to receive meaningful values. This means that a&lt;code&gt;DISPLAY screen-data-item&lt;/code&gt;statement (see &lt;a href=&quot;#DISPLAY-screen_002ddata_002ditem&quot;&gt;DISPLAY screen-data-item&lt;/a&gt;) or a&lt;code&gt;ACCEPT screen-data-item&lt;/code&gt;statement (see &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;) must have been executed prior to executing the&lt;code&gt;CALL&lt;/code&gt;statement.</source>
          <target state="translated">의미있는 값을 받으려면이 루틴을 호출하기 전에 GnuCOBOL 런타임 화면 관리를 초기화해야합니다. 이는 &lt;code&gt;CALL&lt;/code&gt; 문 을 실행하기 전에 &lt;a href=&quot;#DISPLAY-screen_002ddata_002ditem&quot;&gt;DISPLAY 화면 &lt;/a&gt; &lt;code&gt;DISPLAY screen-data-item&lt;/code&gt; 명령문 ( DISPLAY screen-data-item 참조 ) 또는 &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; ( &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item 참조&lt;/a&gt; )이 실행되어야 함을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="bca9afd1bdb28fa197bd33fb7a24153cdc7c56b4" translate="yes" xml:space="preserve">
          <source>GnuCOBOL stores&lt;code&gt;FLOAT-DECIMAL-16&lt;/code&gt;and&lt;code&gt;FLOAT-DECIMAL-34&lt;/code&gt;data items using either Big-Endian or Little-Endian form, whichever is native to the system.</source>
          <target state="translated">GnuCOBOL 은 시스템 고유의 Big-Endian 또는 Little-Endian 형식을 사용하여 &lt;code&gt;FLOAT-DECIMAL-16&lt;/code&gt; 및 &lt;code&gt;FLOAT-DECIMAL-34&lt;/code&gt; 데이터 항목을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="3b9f975d574fd7cc4ea7de4b02075b1a7eaf9bfc" translate="yes" xml:space="preserve">
          <source>GnuCOBOL stores&lt;code&gt;FLOAT-LONG&lt;/code&gt;and&lt;code&gt;FLOAT-SHORT&lt;/code&gt;data items using either Big-Endian or Little-Endian form, whichever is native to the system.</source>
          <target state="translated">GnuCOBOL 은 시스템 고유의 Big-Endian 또는 Little-Endian 형식을 사용하여 &lt;code&gt;FLOAT-LONG&lt;/code&gt; 및 &lt;code&gt;FLOAT-SHORT&lt;/code&gt; 데이터 항목을 저장 합니다.</target>
        </trans-unit>
        <trans-unit id="6ab3cffbe92c165a46df6ca158ad1c4a6a0c158c" translate="yes" xml:space="preserve">
          <source>GnuCOBOL subprograms may be created as either static or dynamic subprograms, as desired by the programmer.</source>
          <target state="translated">GnuCOBOL 서브 프로그램은 프로그래머가 원하는대로 정적 또는 동적 서브 프로그램으로 작성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="183088592eb0fa2ad8ba5f34425e030453ebfcc8" translate="yes" xml:space="preserve">
          <source>GnuCOBOL supports the following visual attribute specifications in the&lt;code&gt;SCREEN SECTION&lt;/code&gt;(see &lt;a href=&quot;#SCREEN-SECTION&quot;&gt;SCREEN SECTION&lt;/a&gt;):</source>
          <target state="translated">GnuCOBOL은 &lt;code&gt;SCREEN SECTION&lt;/code&gt; 에서 다음과 같은 시각적 속성 사양을 지원합니다 ( &lt;a href=&quot;#SCREEN-SECTION&quot;&gt;화면 섹션&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6684809df42a659397430ece5dce09f5dd77386c" translate="yes" xml:space="preserve">
          <source>GnuCOBOL uses compiler configuration files to define various options that will control the compilation process. These configuration files are specified using the&lt;code&gt;-conf&lt;/code&gt;switch</source>
          <target state="translated">GnuCOBOL은 컴파일러 구성 파일을 사용하여 컴파일 프로세스를 제어 할 다양한 옵션을 정의합니다. 이러한 구성 파일은 &lt;code&gt;-conf&lt;/code&gt; 스위치를 사용하여 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="3bd06fc3f53a54465c3ccaa768b1a3b1875dd413" translate="yes" xml:space="preserve">
          <source>GnuCOBOL, like other COBOL implementations, supports a number of reserved words that may be used to represent a specific literal value. These are known as figurative constants. See &lt;a href=&quot;#Figurative-Constants&quot;&gt;Figurative Constants&lt;/a&gt;, for more information.</source>
          <target state="translated">GnuCOBOL은 다른 COBOL 구현과 마찬가지로 특정 리터럴 값을 나타내는 데 사용될 수있는 많은 예약어를 지원합니다. 이것을 형상 상수라고합니다. 자세한 내용은 &lt;a href=&quot;#Figurative-Constants&quot;&gt;형상 상수&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e2bb4d252c23fe267cb78311b78a5c392a8eb567" translate="yes" xml:space="preserve">
          <source>Good programmers have &amp;mdash; for decades &amp;mdash; maintained their own skeleton &quot;template&quot; programs for a variety of program types; simply load a template into a text editor and you&amp;rsquo;ve got a good start to the program&amp;hellip;</source>
          <target state="translated">훌륭한 프로그래머는 수십 년 동안 다양한 프로그램 유형에 대한 자체 &quot;템플릿&quot;프로그램을 유지해 왔습니다. 템플릿을 텍스트 편집기에로드하기 만하면 프로그램을 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bb1297cd4586126018027c7f1e1612420c22c4d" translate="yes" xml:space="preserve">
          <source>Green: COB-COLOR-GREEN</source>
          <target state="translated">그린 : COB-COLOR-GREEN</target>
        </trans-unit>
        <trans-unit id="7c42686edc5c14ca17081cedfebfa14c924ebc58" translate="yes" xml:space="preserve">
          <source>Group Item</source>
          <target state="translated">그룹 아이템</target>
        </trans-unit>
        <trans-unit id="abf442e977221f7e251a5aee4a674647ed69f44a" translate="yes" xml:space="preserve">
          <source>Group Item &amp;mdash; A group item in which debugging information generated by a&lt;code&gt;USE FOR DEBUGGING&lt;/code&gt;section in the declaratives area of the procedure division will place information documenting why the&lt;code&gt;USE FOR DEBUGGING&lt;/code&gt;procedure was invoked. Consult the&lt;code&gt;DECLARATIVES&lt;/code&gt;(see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) documentation for information on the structure of this register.</source>
          <target state="translated">그룹 항목 &amp;mdash; 프로 시저 분할의 선언 영역 에있는 &lt;code&gt;USE FOR DEBUGGING&lt;/code&gt; 섹션에서 생성 된 디버깅 정보 가 &lt;code&gt;USE FOR DEBUGGING&lt;/code&gt; 프로 시저가 호출 된 이유를 설명하는 정보를 배치 하는 그룹 항목입니다 . 상담 호 &lt;code&gt;DECLARATIVES&lt;/code&gt; (참조 &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES를&lt;/a&gt; 이 레지스터의 구조에 대한 정보) 문서를.</target>
        </trans-unit>
        <trans-unit id="810a65e9b0bdcfef9d822c231c10d01c65b32ddf" translate="yes" xml:space="preserve">
          <source>Group items (those without&lt;code&gt;PICTURE&lt;/code&gt;</source>
          <target state="translated">그룹 항목 ( &lt;code&gt;PICTURE&lt;/code&gt; 이없는 항목)</target>
        </trans-unit>
        <trans-unit id="89a17ef0f66b4296a009bd40714a7d880bc71878" translate="yes" xml:space="preserve">
          <source>HEADING, HIGHEST-ALGEBRAIC, HIGHLIGHT, HIGH-VALUE, HIGH-VALUES</source>
          <target state="translated">청각, 최고 대수, 하이라이트, 고가, 고가</target>
        </trans-unit>
        <trans-unit id="30cfc7dc90ba24ab43e38507c7e4463f0560ba02" translate="yes" xml:space="preserve">
          <source>HIGHEST-ALGEBRAIC Function Syntax</source>
          <target state="translated">최고 대수 함수 구문</target>
        </trans-unit>
        <trans-unit id="d60066848e06a51085c8e2354e105347e3c601c8" translate="yes" xml:space="preserve">
          <source>HIGHLIGHT Attribute Syntax</source>
          <target state="translated">하이라이트 속성 구문</target>
        </trans-unit>
        <trans-unit id="8c6979d233b84b4e040cc3b6f33204115bd4f223" translate="yes" xml:space="preserve">
          <source>Had there been at least one space to the left and/or the right of the&lt;code&gt;-&lt;/code&gt; there would have been no ambiguity &amp;mdash; the compiler would have been forced to use the individual&lt;code&gt;C&lt;/code&gt;and&lt;code&gt;D&lt;/code&gt;data items.</source>
          <target state="translated">왼쪽 및 / 또는 오른쪽에 적어도 하나 개의 공간이 있었다면 &lt;code&gt;-&lt;/code&gt; 모호함이 없었을 것입니다 - 컴파일러는 개인 사용을 강요했을 &lt;code&gt;C&lt;/code&gt; 와 &lt;code&gt;D&lt;/code&gt; 의 데이터 항목을.</target>
        </trans-unit>
        <trans-unit id="87a433cf0bc677c32d39cd5b979920082688b536" translate="yes" xml:space="preserve">
          <source>Heading Area</source>
          <target state="translated">제목 영역</target>
        </trans-unit>
        <trans-unit id="cbbb9cee65c6576a367576c2ac65ada91311b34f" translate="yes" xml:space="preserve">
          <source>Heading Area &amp;mdash; An exception to this is the situation where the report heading report group contains the&lt;code&gt;NEXT GROUP NEXT PAGE&lt;/code&gt;(see &lt;a href=&quot;#NEXT-GROUP&quot;&gt;NEXT GROUP&lt;/a&gt;) option; in those cases, the report heading will be presented on a page by itself (anywhere on that page) at the beginning of the report.</source>
          <target state="translated">제목 영역 &amp;mdash; 예외는 보고서 제목 보고서 그룹에 &lt;code&gt;NEXT GROUP NEXT PAGE&lt;/code&gt; ( &lt;a href=&quot;#NEXT-GROUP&quot;&gt;다음 그룹&lt;/a&gt; 참조 ) 옵션이 포함 된 경우입니다. 이 경우 보고서 머리글은 보고서 시작 부분에 페이지 자체 (해당 페이지의 아무 곳이나)에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9a3fc3dac7c2610f19172d33b654b99f82029bf8" translate="yes" xml:space="preserve">
          <source>Here are a few examples:</source>
          <target state="translated">다음은 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="a58d0be2a26b29065720289affde96b396953bc6" translate="yes" xml:space="preserve">
          <source>Here are some examples of how the precedence of operations affects the results of arithmetic expressions (all examples use numeric literals, to simplify the discussion).</source>
          <target state="translated">다음은 연산 우선 순위가 산술 표현식의 결과에 어떤 영향을 미치는지에 대한 몇 가지 예입니다 (모든 예는 토론을 단순화하기 위해 숫자 리터럴을 사용합니다).</target>
        </trans-unit>
        <trans-unit id="ce8b7658bf191725329e97e66717da8863c93fce" translate="yes" xml:space="preserve">
          <source>Here are the facts &amp;mdash; draw your own conclusions as to which approach is more appropriate under which circumstances.</source>
          <target state="translated">사실은 다음과 같습니다. 어떤 상황에서 어떤 접근법이 더 적합한 지에 대한 자신의 결론을 도출하십시오.</target>
        </trans-unit>
        <trans-unit id="71e41b379565b9db9a0898e306e44094c8f202bb" translate="yes" xml:space="preserve">
          <source>Here are the meanings of the three options:</source>
          <target state="translated">세 가지 옵션의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8db79160667581172099438ddb7cbe10fdc25a56" translate="yes" xml:space="preserve">
          <source>Here are the relevant sections of code in a program named &quot;testprog&quot;, which is designed to simply announce if SWITCH-1 is on:</source>
          <target state="translated">다음은 &quot;testprog&quot;라는 프로그램의 관련 코드 섹션입니다.이 코드는 SWITCH-1이 켜져있는 경우 간단히 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="4806c2364021b8f8145a30057c39a5142245883f" translate="yes" xml:space="preserve">
          <source>Here are the results:</source>
          <target state="translated">Here are the results:</target>
        </trans-unit>
        <trans-unit id="6bcf44b499d0088da0556d2de36d212cd7d4aaa3" translate="yes" xml:space="preserve">
          <source>Here are the rules about GnuCOBOL dynamically-loadable modules:</source>
          <target state="translated">GnuCOBOL 동적으로로드 가능한 모듈에 대한 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d98760fd5f7d0d451fc2f1b70dda01b46952cd2b" translate="yes" xml:space="preserve">
          <source>Here are two different &quot;Hello World&quot; applications &amp;mdash; one written in Java and the second in GnuCOBOL. First, the Java version:</source>
          <target state="translated">다음은 두 가지 다른 &quot;Hello World&quot;응용 프로그램입니다. 하나는 Java로 작성되었고 다른 하나는 GnuCOBOL로 작성되었습니다. 먼저, Java 버전 :</target>
        </trans-unit>
        <trans-unit id="2486c63ce113fa9dfa91ee5ea183529c4d50239f" translate="yes" xml:space="preserve">
          <source>Here are two examples of using&lt;code&gt;cobcrun&lt;/code&gt; First, on a Unix, OSX or Windows/Cygwin system:</source>
          <target state="translated">다음은 Unix, OSX 또는 Windows / Cygwin 시스템에서 &lt;code&gt;cobcrun&lt;/code&gt; First 를 사용하는 두 가지 예입니다 .</target>
        </trans-unit>
        <trans-unit id="88f0b25a36a42c34f75db34b7878e30378e348fc" translate="yes" xml:space="preserve">
          <source>Here is a sample program that illustrates the EVALUATE statement.</source>
          <target state="translated">다음은 EVALUATE 문을 보여주는 샘플 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="b44351443986b8d6208b8077f937b80d2c5d797f" translate="yes" xml:space="preserve">
          <source>Here is an example of a main program (DEMOFACT) that calls both a subprogram (SUB) and a user-defined function (FUNC) to compute the factorial value of a number.</source>
          <target state="translated">다음은 서브 프로그램 (SUB)과 사용자 정의 함수 (FUNC)를 모두 호출하여 숫자의 계승 값을 계산하는 기본 프로그램 (DEMOFACT)의 예입니다.</target>
        </trans-unit>
        <trans-unit id="fce56f05dd0a684307248e0509281b28f6150e2a" translate="yes" xml:space="preserve">
          <source>Here is an example. The following two GnuCOBOL statements both display the same result (27):</source>
          <target state="translated">다음은 예입니다. 다음 두 GnuCOBOL 문은 모두 동일한 결과를 표시합니다 (27).</target>
        </trans-unit>
        <trans-unit id="b6e578854c806b2cf1a7f51f1181b4443af68716" translate="yes" xml:space="preserve">
          <source>Here is how the main program and the three subprograms could be compiled if the three subprograms are to be dynamic:</source>
          <target state="translated">다음은 세 개의 서브 프로그램이 동적 일 경우 메인 프로그램과 세 개의 서브 프로그램을 컴파일하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="b8a4250afe2b9b703be52c8963f7c7e83af93bec" translate="yes" xml:space="preserve">
          <source>Here is how these four programs would be compiled if the three subprograms are to be static:</source>
          <target state="translated">세 개의 서브 프로그램이 정적 인 경우이 네 가지 프로그램을 컴파일하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3885b22c6e4bdc48af657c6fedb7ca8f97433747" translate="yes" xml:space="preserve">
          <source>Here is the data that the program will be reading. Each record reflects the aggregated benchmark scoring for one particular CPU, as scores for benchmarks against that CPU have been reported to the &lt;a href=&quot;https://open-cobol.sourceforge.io/HTML/cpubenchmark.net&quot;&gt;cpubenchmark.net&lt;/a&gt; website by their PassMark benchmark software. The data consists of four fields. Fields are separated from one another by a single comma. The descriptions of the fields are as follows:</source>
          <target state="translated">다음은 프로그램이 읽을 데이터입니다. 각 레코드는 해당 CPU에 대한 벤치 마크 점수 가 PassMark 벤치 마크 소프트웨어에 의해 &lt;a href=&quot;https://open-cobol.sourceforge.io/HTML/cpubenchmark.net&quot;&gt;cpubenchmark.net&lt;/a&gt; 웹 사이트에 보고되었으므로 특정 CPU에 대한 집계 된 벤치 마크 점수를 반영합니다 . 데이터는 네 개의 필드로 구성됩니다. 필드는 단일 쉼표로 서로 구분됩니다. 필드에 대한 설명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b01180e30ff342f12b30bea352d08df8ee331a14" translate="yes" xml:space="preserve">
          <source>Here is the listing of a GnuCOBOL program that uses 01-level constants to display the length (in bytes) of the various picture-less usage types.</source>
          <target state="translated">다음은 01 레벨 상수를 사용하여 다양한 그림이없는 사용 유형의 길이 (바이트)를 표시하는 GnuCOBOL 프로그램 목록입니다.</target>
        </trans-unit>
        <trans-unit id="73247c417733995d371c239937b20d07507d4db9" translate="yes" xml:space="preserve">
          <source>Here is the program that will be producing the report. Pay attention to how the data is sorted and how the control hierarchy &lt;code&gt;CONTROLS ARE&lt;/code&gt; relates to the&lt;code&gt;SORT&lt;/code&gt;</source>
          <target state="translated">보고서를 작성하는 프로그램은 다음과 같습니다. 데이터 정렬 방법과 제어 계층 구조 가 &lt;code&gt;SORT&lt;/code&gt; 와 어떤 관련이 &lt;code&gt;CONTROLS ARE&lt;/code&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="e5a81b08e879fde5dd2a59dae3f46849e9f50742" translate="yes" xml:space="preserve">
          <source>Here we see that PROG2 is nested inside of PROG1 because there is no&lt;code&gt;END PROGRAM&lt;/code&gt;marker separating them. This means that data items or files defined within PROG1 can be used within PROG2 simply by attaching the&lt;code&gt;GLOBAL&lt;/code&gt;(see &lt;a href=&quot;#GLOBAL&quot;&gt;GLOBAL&lt;/a&gt;) attribute to them back in PROG1 when they are defined.</source>
          <target state="translated">여기서는 PROG2가 분리되는 &lt;code&gt;END PROGRAM&lt;/code&gt; 마커 가 없기 때문에 PROG2가 PROG1 안에 중첩되어 있음을 알 수 있습니다. 이는 PROG1에 정의 된 데이터 항목 또는 파일을 정의 할 때 &lt;code&gt;GLOBAL&lt;/code&gt; ( &lt;a href=&quot;#GLOBAL&quot;&gt;GLOBAL&lt;/a&gt; 참조 ) 속성을 PROG1에 다시 첨부하여 PROG2 내에서 사용할 수 있음 을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9e665b8afaa854f3affd19ae081739fadefc957c" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a demonstration:</source>
          <target state="translated">데모는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1bb3a890739a2d89878b41828136b7843797b0c4" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a more practical view of the difference. Let&amp;rsquo;s say that a table has 1,000 entries in it. With a sequential search, on average, you&amp;rsquo;ll have to check 500 of them to find an entry and you&amp;rsquo;ll have to look at all 1,000 of them to find that an entry doesn&amp;rsquo;t exist.</source>
          <target state="translated">차이점에 대한보다 실용적인 견해는 다음과 같습니다. 테이블에 1,000 개의 항목이 있다고 가정 해 봅시다. 순차적으로 검색하는 경우 평균적으로 항목을 찾기 위해 500 개를 확인해야하며 항목이 존재하지 않는 것을 찾으려면 1,000 개를 모두 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="5e93bdc7d9e913c109cf4064444cedee83b88ddb" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a sample of a GnuCOBOL program that CALLs a C subprogram.</source>
          <target state="translated">다음은 C 서브 프로그램을 호출하는 GnuCOBOL 프로그램의 샘플입니다.</target>
        </trans-unit>
        <trans-unit id="bce0f5ae6fe98feb4beb66b9de11f14f54d3934d" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a small example:</source>
          <target state="translated">다음은 작은 예입니다.</target>
        </trans-unit>
        <trans-unit id="79a379c34c53ce83d07e71356345ea69136a74d1" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b4f96988044521adc26ab35ce61bb5f09db1123c" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the output of the compilation process as well as the program&amp;rsquo;s execution. The example assumes a Windows system with a GnuCOBOL build that uses the GNU C compiler on that system; the technique works equally well regardless of which C compiler and which operating system you&amp;rsquo;re using.</source>
          <target state="translated">다음은 컴파일 프로세스의 출력과 프로그램 실행입니다. 이 예에서는 해당 시스템에서 GNU C 컴파일러를 사용하는 GnuCOBOL 빌드가있는 Windows 시스템을 가정합니다. 이 기술은 사용하는 C 컴파일러와 운영 체제에 관계없이 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="411f51a5654b397be9062ca82d9069ac5e760156" translate="yes" xml:space="preserve">
          <source>Hexadecimal Alphanumeric Literal</source>
          <target state="translated">16 진 영숫자 리터럴</target>
        </trans-unit>
        <trans-unit id="0622237faae035a0d62bd2b8400c09913d5beb12" translate="yes" xml:space="preserve">
          <source>Hexadecimal Numeric Literal</source>
          <target state="translated">16 진 숫자 리터럴</target>
        </trans-unit>
        <trans-unit id="9b5d84e4c523dc629848bb4349e680f8bf34c64b" translate="yes" xml:space="preserve">
          <source>Hexadecimal numeric literals</source>
          <target state="translated">16 진 숫자 리터럴</target>
        </trans-unit>
        <trans-unit id="fc83f87e3f62574b840ab2334e64d62930fb1c3c" translate="yes" xml:space="preserve">
          <source>Historically in the early 60&amp;rsquo;s programs were first punched on to paper tape and by the mid 60&amp;rsquo;s that was replaced almost totally, by punched cards although paper tape was still used by programmers for the odd few changes to their sources held on magnetic tape or disk as a portable paper tape punch could be put in your pocket. Now the problem with punched cards were there was 2,000 cards per box and that they could and did, get dropped. So, cc (column) 1 through 6 had the card sequence number in and that way if a box was dropped they could be feed in to a card sorter to be fixed. This was after the cards was cleaned up so that they were all in the same direction which one corner cut out helped.</source>
          <target state="translated">역사적으로 60 년대 초의 프로그램은 종이 테이프에 처음으로 펀칭되었고 60 년대 중반에는 거의 완전히 교체 된 펀치 카드로 프로그래머가 종이 테이프를 사용하여 자기 테이프 또는 디스크에 저장된 소스에 대한 이상한 변화가 거의 없었습니다. 휴대용 종이 테이프 펀치를 주머니에 넣을 수 있습니다. 이제 천공 카드의 문제점은 상자 당 2,000 장의 카드가 있었고 떨어 뜨릴 수 있다는 것입니다. 따라서 cc (열) 1에서 6까지는 카드 순서 번호를 가지고 있으며 상자를 떨어 뜨린 경우 카드 분류기로 공급하여 고정 할 수 있습니다. 이것은 한 쪽 모서리를 잘라낸 것과 같은 방향이되도록 카드를 정리 한 후에였습니다.</target>
        </trans-unit>
        <trans-unit id="82581b08d1abc17171e1f2f9cf9815374d6d8df7" translate="yes" xml:space="preserve">
          <source>Historically, back in the days when punched-cards were used to submit COBOL program source to a COBOL compiler, this part of a COBOL statement was reserved for a six-digit sequence number. While the contents of this area are ignored by COBOL compilers, it existed so that a program actually punched on 80-character cards could &amp;mdash; if the card deck were dropped on the floor &amp;mdash; be run through a card sorter machine and restored to it&amp;rsquo;s proper sequence. Of course, this isn&amp;rsquo;t necessary today; if truth be told, it hasn&amp;rsquo;t been necessary for a long time.</source>
          <target state="translated">역사적으로 펀치 카드를 사용하여 COBOL 프로그램 소스를 COBOL 컴파일러에 제출했던 시절에이 COBOL 문의이 부분은 6 자리 시퀀스 번호로 예약되었습니다. 이 영역의 내용은 COBOL 컴파일러에 의해 무시되지만 실제로 80 자 카드에 펀칭 된 프로그램 (카드 데크를 바닥에 떨어 뜨린 경우)이 카드 분류기 시스템을 통해 실행되고 올바른 순서로 복원 될 수 있도록 존재했습니다. . 물론 오늘날에는 필요하지 않습니다. 진실을 말하면 오랫동안 필요하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="dbfbb76720b9c478938cb351772ad799b84f9efe" translate="yes" xml:space="preserve">
          <source>I also ran the tests multiple times, just to make sure I had consistent results (I did). Like I mentioned earlier, this is not a rigorous, scientific benchmark of numeric performance; it&amp;rsquo;s just a quick-and-dirty comparison.</source>
          <target state="translated">또한 일관된 결과를 얻었는지 확인하기 위해 테스트를 여러 번 실행했습니다. 앞에서 언급했듯이 이것은 수치 적 성능에 대한 엄격하고 과학적인 벤치 마크가 아닙니다. 그것은 단지 더럽고 더러운 비교 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="555eb23964b638ebb4898ef46762a788413b2a7a" translate="yes" xml:space="preserve">
          <source>I always include a numeric prefix to all procedure names I define, for the reasons stated earlier.</source>
          <target state="translated">앞에서 언급 한 이유로 항상 정의한 모든 프로 시저 이름에 숫자 접두사를 포함시킵니다.</target>
        </trans-unit>
        <trans-unit id="df6a4fe99929dd991e0202127b86aa20cecf96af" translate="yes" xml:space="preserve">
          <source>I changed the&lt;code&gt;CONTROLS ARE&lt;/code&gt;clause on the sample program from this:</source>
          <target state="translated">샘플 프로그램에서 &lt;code&gt;CONTROLS ARE&lt;/code&gt; 절을 다음과 같이 변경했습니다 .</target>
        </trans-unit>
        <trans-unit id="8d7255df40c7e6bd55c76738ac87c79c48b55013" translate="yes" xml:space="preserve">
          <source>I do not use&lt;code&gt;THRU&lt;/code&gt;on any&lt;code&gt;MERGE&lt;/code&gt;&lt;code&gt;PERFORM&lt;/code&gt;or&lt;code&gt;SORT&lt;/code&gt;statement unless the programming standards of the shop in which I am working require it. My reasoning for this is that it is too easy to accidentally introduce a new procedure into the scope of a&lt;code&gt;THRU&lt;/code&gt;</source>
          <target state="translated">작업중인 상점의 프로그래밍 표준에서 요구하지 않는 한 &lt;code&gt;MERGE&lt;/code&gt; &lt;code&gt;PERFORM&lt;/code&gt; 또는 &lt;code&gt;SORT&lt;/code&gt; 문 에 &lt;code&gt;THRU&lt;/code&gt; 를 사용하지 않습니다 . 이것에 대한 나의 추론은 실수로 &lt;code&gt;THRU&lt;/code&gt; 의 범위에 새로운 절차를 도입하는 것이 너무 쉽다는 것입니다</target>
        </trans-unit>
        <trans-unit id="1fbc97a4457717dc23d1ecc1bf25f471eabb9c4f" translate="yes" xml:space="preserve">
          <source>I like to use procedure division paragraphs and sections as follows:</source>
          <target state="translated">절차 구분 단락과 섹션을 다음과 같이 사용하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="80ed72858cef207934e285ac054f1c8a269fc88f" translate="yes" xml:space="preserve">
          <source>I-O status &quot;1x&quot;</source>
          <target state="translated">IO 상태 &quot;1x&quot;</target>
        </trans-unit>
        <trans-unit id="e7876f32dd29146c722eec80cdba831c36ef9026" translate="yes" xml:space="preserve">
          <source>I-O status &quot;2x&quot;</source>
          <target state="translated">IO 상태 &quot;2x&quot;</target>
        </trans-unit>
        <trans-unit id="76b397e0ec9019d1f6c9d9402f9be35add987c62" translate="yes" xml:space="preserve">
          <source>I-O status &quot;3x&quot;</source>
          <target state="translated">IO 상태 &quot;3x&quot;</target>
        </trans-unit>
        <trans-unit id="6eff1612faad7c99ae78ea1e6080ebc0dc3c4df1" translate="yes" xml:space="preserve">
          <source>I-O status &quot;4x&quot;</source>
          <target state="translated">IO 상태 &quot;4x&quot;</target>
        </trans-unit>
        <trans-unit id="67e793587f319a335dc7c63a71a23c530563d185" translate="yes" xml:space="preserve">
          <source>I-O status &quot;5x&quot;</source>
          <target state="translated">IO 상태 &quot;5x&quot;</target>
        </trans-unit>
        <trans-unit id="b8524f001cba70110ae60dee01287daded416b11" translate="yes" xml:space="preserve">
          <source>I-O status &quot;6x&quot;</source>
          <target state="translated">IO 상태 &quot;6x&quot;</target>
        </trans-unit>
        <trans-unit id="be335b5a5eadd43e4b4e63cf77557e87542095cf" translate="yes" xml:space="preserve">
          <source>I-O status &quot;9x&quot;</source>
          <target state="translated">IO 상태 &quot;9x&quot;</target>
        </trans-unit>
        <trans-unit id="0f12b2d4b4f8188676296a19fede62525110b1c0" translate="yes" xml:space="preserve">
          <source>I-O-CONTROL MULTIPLE FILE Syntax</source>
          <target state="translated">IO-CONTROL 다중 파일 구문</target>
        </trans-unit>
        <trans-unit id="6f75dae5c47d389ce684040629f1e36258a6ce54" translate="yes" xml:space="preserve">
          <source>I-O-CONTROL SAME AREA Syntax</source>
          <target state="translated">IO-CONTROL SAME AREA 구문</target>
        </trans-unit>
        <trans-unit id="9c32595038680ec5b76e6c8935109525fa67eebc" translate="yes" xml:space="preserve">
          <source>ID, IDENTIFICATION, IF, IGNORE, IGNORING, IMPLEMENTS, IN, INDEX, INDEXED, INDICATE, INHERITS, INITIAL, INITIALISE, INITIALISED, INITIALIZE, INITIALIZED, INITIATE, INPUT, INPUT-OUTPUT, INSPECT, INSTALLATION, INTEGER, INTEGER-OF-BOOLEAN, INTEGER-OF-DATE, INTEGER-OF-DAY, INTEGER-OF-FORMATTED-DATE, INTEGER-PART, INTERFACE, INTERFACE-ID, INTERMEDIATE, INTO, INTRINSIC, INVALID, INVOKE, I-O, I-O-CONTROL, IS</source>
          <target state="translated">ID, 식별, IF, IGNORE, IGNORING, IMPLEMENTS, IN, INDEX, INDEXED, INDICATE, INITITS, INITIALISE, INITIALISED, INITIALISED, INITIALIZE, 초기화, 초기화, 입력, 입력 출력, 검사, 설치, 정수, 설치, 정수 BOOLEAN, 정수, 날짜, 정수, 정수 날짜, 정수, 인터페이스, 인터페이스 ID, 중간, INTO, INTRINSIC, INVALNSIC, INVOKE, IO, IO-CONTROL, IS</target>
        </trans-unit>
        <trans-unit id="9b9c55248e0c5e189619271ca0ded3b5bd005453" translate="yes" xml:space="preserve">
          <source>IDENTIFICATION DIVISION Syntax</source>
          <target state="translated">식별 구분 구문</target>
        </trans-unit>
        <trans-unit id="b825b4511a0db8bbe7c5d10a6be13d4b3f73d3e5" translate="yes" xml:space="preserve">
          <source>IF Syntax</source>
          <target state="translated">IF 구문</target>
        </trans-unit>
        <trans-unit id="8a579c7bbbf6cdd11286272217a8b94f74b4f75a" translate="yes" xml:space="preserve">
          <source>INITIALIZE Syntax</source>
          <target state="translated">초기화 구문</target>
        </trans-unit>
        <trans-unit id="f22feedf7bc3a1ceec5b7c202882c8aa6f0e185d" translate="yes" xml:space="preserve">
          <source>INITIATE Syntax</source>
          <target state="translated">초기화 구문</target>
        </trans-unit>
        <trans-unit id="4f5b873e331f2e93c7e38f36475cf57cbfec3d6a" translate="yes" xml:space="preserve">
          <source>INPUT-OUTPUT SECTION Syntax</source>
          <target state="translated">입력-출력 섹션 구문</target>
        </trans-unit>
        <trans-unit id="baa55ae57b9d3c323f03e28edc87f8c479cca623" translate="yes" xml:space="preserve">
          <source>INSPECT Syntax</source>
          <target state="translated">검사 구문</target>
        </trans-unit>
        <trans-unit id="078ab307f07f53957c6ec7a0918c5e4474c21ea5" translate="yes" xml:space="preserve">
          <source>INTEGER Function Syntax</source>
          <target state="translated">INTEGER 함수 구문</target>
        </trans-unit>
        <trans-unit id="2c22d504f0b728c455886a880af6cd5a9ad23315" translate="yes" xml:space="preserve">
          <source>INTEGER-OF-DATE Function Syntax</source>
          <target state="translated">정수 날짜 함수 구문</target>
        </trans-unit>
        <trans-unit id="c56815bbf474260cef47707dfeb34754b39ce7d9" translate="yes" xml:space="preserve">
          <source>INTEGER-OF-DAY Function Syntax</source>
          <target state="translated">정수 오늘 함수 구문</target>
        </trans-unit>
        <trans-unit id="8690212db49eea2a08db459f36ed19a01dcc1797" translate="yes" xml:space="preserve">
          <source>INTEGER-PART Function Syntax</source>
          <target state="translated">INTEGER-PART 함수 구문</target>
        </trans-unit>
        <trans-unit id="b7b5138514830769db3bcc33e44ecf17e41dd72e" translate="yes" xml:space="preserve">
          <source>INVALID KEY Syntax</source>
          <target state="translated">잘못된 키 구문</target>
        </trans-unit>
        <trans-unit id="1e0e983b66f7b85304dc35598bdbe112fd3d5cf6" translate="yes" xml:space="preserve">
          <source>Identified sub strings will be moved into each destination field in the sequence they are identified; values moved into a destination field will be truncated if the sub string length exceeds the destination field length, or padded with spaces if the destination field length exceeds the sub string length. Both truncation and padding will be controlled by the presence or absence of a&lt;code&gt;JUSTIFIED&lt;/code&gt;(see &lt;a href=&quot;#JUSTIFIED&quot;&gt;JUSTIFIED&lt;/a&gt;) clause on the destination field.</source>
          <target state="translated">식별 된 하위 문자열은 식별 된 순서대로 각 대상 필드로 이동합니다. 하위 문자열 길이가 대상 필드 길이를 초과하면 대상 필드로 이동 한 값이 잘 리거나 대상 필드 길이가 하위 문자열 길이를 초과하면 공백으로 채워집니다. 잘림 및 패딩은 대상 필드에 &lt;code&gt;JUSTIFIED&lt;/code&gt; ( &lt;a href=&quot;#JUSTIFIED&quot;&gt;JUSTIFIED&lt;/a&gt; 참조 ) 절의 존재 여부에 따라 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="649d2864df18704de32e689e69e63f2483e8b76e" translate="yes" xml:space="preserve">
          <source>Identifiers</source>
          <target state="translated">Identifiers</target>
        </trans-unit>
        <trans-unit id="85fdddf7199ca1a02d1e410b6661de3c0d82e8ec" translate="yes" xml:space="preserve">
          <source>If &amp;lt;</source>
          <target state="translated">&amp;lt;</target>
        </trans-unit>
        <trans-unit id="a4c0ae6969ecd1edf278dc7c43adf6ccf840a59b" translate="yes" xml:space="preserve">
          <source>If CALL &quot;literal&quot; is used, the subroutine can only be located and linked with the calling program at compilation time.</source>
          <target state="translated">CALL &quot;literal&quot;이 사용되는 경우, 서브 루틴은 컴파일 할 때 호출 프로그램에만 위치하고 링크 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb834ae0ee1fee06659da54155901a048c8ab107" translate="yes" xml:space="preserve">
          <source>If CALL &quot;literal&quot; is used, the subroutine will be located and linked in with the calling program at compile time or may be dynamically located and loaded at execution time, depending on compiler switch settings and operating system capabilities.</source>
          <target state="translated">CALL &quot;literal&quot;을 사용하는 경우, 컴파일 타임에 서브 루틴이 호출 프로그램과 함께 위치하여 링크되거나 실행 시간에 컴파일러 스위치 설정 및 운영 체제 기능에 따라 동적으로 위치 및로드 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c0a19ff2f39be755da80b6e4db03b3261af8ab0" translate="yes" xml:space="preserve">
          <source>If COB_SET_TRACE is set to Y, then tracing will always occur regardless of the presence of READY TRACE or RESET TRACE so in effect they will have no action on program execution.</source>
          <target state="translated">COB_SET_TRACE가 Y로 설정되면 READY TRACE 또는 RESET TRACE의 존재 여부에 관계없이 추적이 항상 발생하므로 사실상 프로그램 실행에 대한 조치가 없습니다.</target>
        </trans-unit>
        <trans-unit id="fca0edd85d905b4998e39dbc0abfe08d59abf9e2" translate="yes" xml:space="preserve">
          <source>If Replace Mode is currently active, a&lt;code&gt;REPLACE LAST OFF.&lt;/code&gt;will replace the current replace specification(s) with those popped off the top of the stack. If there were no replace specification(s) on the stack, the effect will be as if a&lt;code&gt;REPLACE OFF.&lt;/code&gt;had been coded.</source>
          <target state="translated">교체 모드가 현재 활성화되어 있으면 &lt;code&gt;REPLACE LAST OFF.&lt;/code&gt; 현재 교체 사양을 스택 상단에서 튀어 나온 사양으로 교체합니다. 스택에 교체 사양이 없으면 &lt;code&gt;REPLACE OFF.&lt;/code&gt; 와 같은 결과가 나타납니다 . 코딩되었습니다.</target>
        </trans-unit>
        <trans-unit id="3aa454bf040b4488335636d3825b242cd96c6894" translate="yes" xml:space="preserve">
          <source>If Replace Mode is currently active, a&lt;code&gt;REPLACE OFF.&lt;/code&gt;will deactivate Replace Mode and discard any replace specification(s) on the stack. The compiler will henceforth operate as if no&lt;code&gt;REPLACE&lt;/code&gt;had ever been encountered, until such time as another Format 1&lt;code&gt;REPLACE&lt;/code&gt;is encountered.</source>
          <target state="translated">교체 모드가 현재 활성화되어 있으면 교체를 &lt;code&gt;REPLACE OFF.&lt;/code&gt; 교체 모드를 비활성화하고 스택에서 교체 사양을 폐기합니다. 따라서 컴파일러는 다른 형식 1 &lt;code&gt;REPLACE&lt;/code&gt; 가 나타날 때까지 &lt;code&gt;REPLACE&lt;/code&gt; 가 없는 것처럼 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="f9f8b4a7fa7d08d0000f216b49dbe0fdb7aba40b" translate="yes" xml:space="preserve">
          <source>If Replace Mode is currently inactive, the Format 2 REPLACE statement will be ignored.</source>
          <target state="translated">대체 모드가 현재 비활성 인 경우 형식 2 REPLACE 문은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="02d270f35c2331a3f0b66309eedab53f64314826" translate="yes" xml:space="preserve">
          <source>If a &amp;lt;</source>
          <target state="translated">&amp;lt;</target>
        </trans-unit>
        <trans-unit id="eab9e954d4363fe95501767a50e10db235e4192f" translate="yes" xml:space="preserve">
          <source>If a &amp;lt;&amp;lt;</source>
          <target state="translated">&amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="fc1c32024a481de06916a31d66dbe9f8f79db74e" translate="yes" xml:space="preserve">
          <source>If a &amp;rsquo;</source>
          <target state="translated">만약 '</target>
        </trans-unit>
        <trans-unit id="edb4a54100b677ae4d121fffad6d12711ca6c737" translate="yes" xml:space="preserve">
          <source>If a dynamically-loadable module unloaded by the&lt;code&gt;CANCEL&lt;/code&gt;statement is subsequently re-executed, all data division storage for that module will once again be in it&amp;rsquo;s initial state.</source>
          <target state="translated">&lt;code&gt;CANCEL&lt;/code&gt; 문에 의해 언로드 된 동적으로로드 가능한 모듈 이 이후에 다시 실행되면 해당 모듈에 대한 모든 데이터 분할 스토리지가 다시 초기 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="df6f3afc62331cf6c1dea91965aa4ef057173188" translate="yes" xml:space="preserve">
          <source>If a numeric literal or&lt;code&gt;PIC 9&lt;/code&gt;identifier is specified as an argument, decimal points, if any, will be removed and negative signs in&lt;code&gt;PIC S9&lt;/code&gt;fields or numeric literals will be inserted as defined by the&lt;code&gt;SIGN IS&lt;/code&gt;(see &lt;a href=&quot;#SIGN-IS&quot;&gt;SIGN IS&lt;/a&gt;) clause (or absence thereof) of the field. Numeric literals are processed as if&lt;code&gt;SIGN IS TRAILING SEPARATE&lt;/code&gt;were in effect.</source>
          <target state="translated">숫자 리터럴 또는 &lt;code&gt;PIC 9&lt;/code&gt; 식별자가 인수로 지정된 경우 소수점이있는 경우 소수점이 제거되고 &lt;code&gt;PIC S9&lt;/code&gt; 필드 또는 숫자 리터럴의 부호 가 &lt;code&gt;SIGN IS&lt;/code&gt; ( &lt;a href=&quot;#SIGN-IS&quot;&gt;SIGN IS&lt;/a&gt; 참조 ) 절에 정의 된대로 삽입됩니다 (또는 필드의 부재). &lt;code&gt;SIGN IS TRAILING SEPARATE&lt;/code&gt; 가 적용된 것처럼 숫자 리터럴이 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="57490b79cb430dd4450134ac2677f6cf11e26604" translate="yes" xml:space="preserve">
          <source>If a report data item&amp;rsquo;s description includes the&lt;code&gt;SOURCE&lt;/code&gt;(see &lt;a href=&quot;#SOURCE&quot;&gt;SOURCE&lt;/a&gt;),&lt;code&gt;SUM&lt;/code&gt;(see &lt;a href=&quot;#SUM&quot;&gt;SUM&lt;/a&gt;) or&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause but has no&lt;code&gt;COLUMN&lt;/code&gt;clause,&lt;code&gt;COLUMN PLUS 1&lt;/code&gt;will be assumed.</source>
          <target state="translated">보고서 데이터 항목의 설명이 포함 된 경우 &lt;code&gt;SOURCE&lt;/code&gt; 를 (참조 &lt;a href=&quot;#SOURCE&quot;&gt;SOURCE를&lt;/a&gt; ), &lt;code&gt;SUM&lt;/code&gt; 은 (참조 &lt;a href=&quot;#SUM&quot;&gt;SUM&lt;/a&gt; 또는) &lt;code&gt;VALUE&lt;/code&gt; (참조 &lt;a href=&quot;#VALUE&quot;&gt;VALUE를&lt;/a&gt; ) 절을하지만이 없습니다 &lt;code&gt;COLUMN&lt;/code&gt; 의 절, &lt;code&gt;COLUMN PLUS 1&lt;/code&gt; 가정한다.</target>
        </trans-unit>
        <trans-unit id="71da1ffb9548582f3fa4c8e682811f42638458f2" translate="yes" xml:space="preserve">
          <source>If a screen data item&amp;rsquo;s description includes the&lt;code&gt;FROM&lt;/code&gt;(see &lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;),&lt;code&gt;TO&lt;/code&gt;(see &lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt;),&lt;code&gt;USING&lt;/code&gt;(see &lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;) or&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause but has no LINE clause, the &quot;current screen line&quot; will be assumed.</source>
          <target state="translated">화면 데이터 항목의 설명이 포함되어있는 경우 &lt;code&gt;FROM&lt;/code&gt; (참조 &lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt; ), &lt;code&gt;TO&lt;/code&gt; 가 (참조 &lt;a href=&quot;#TO&quot;&gt;TO를&lt;/a&gt; ) &lt;code&gt;USING&lt;/code&gt; 합니다 ( &lt;a href=&quot;#USING&quot;&gt;사용&lt;/a&gt; ) 또는 &lt;code&gt;VALUE&lt;/code&gt; (참조 &lt;a href=&quot;#VALUE&quot;&gt;VALUE를&lt;/a&gt; 절)하지만 LINE 절, &quot;현재 화면 라인&quot;가정한다이 없습니다.</target>
        </trans-unit>
        <trans-unit id="48d3ea6a5c04f441a3bbe9ad4aa57d07cef44e81" translate="yes" xml:space="preserve">
          <source>If a screen data item&amp;rsquo;s description includes the&lt;code&gt;FROM&lt;/code&gt;(see &lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;),&lt;code&gt;TO&lt;/code&gt;(see &lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt;),&lt;code&gt;USING&lt;/code&gt;(see &lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;) or&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause but has no&lt;code&gt;COLUMN&lt;/code&gt;clause, the new screen field will begin at the column coordinate of the last character of the previous field.</source>
          <target state="translated">화면 데이터 항목의 설명이 포함 된 경우 &lt;code&gt;FROM&lt;/code&gt; 을 합니다 ( &lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt; ) &lt;code&gt;TO&lt;/code&gt; (참조 &lt;a href=&quot;#TO&quot;&gt;TO를&lt;/a&gt; ) &lt;code&gt;USING&lt;/code&gt; 합니다 ( &lt;a href=&quot;#USING&quot;&gt;사용&lt;/a&gt; ) 또는 &lt;code&gt;VALUE&lt;/code&gt; (참조 &lt;a href=&quot;#VALUE&quot;&gt;VALUE를&lt;/a&gt; 절)하지만이 없습니다 &lt;code&gt;COLUMN&lt;/code&gt; 절을, 새 화면 필드는 좌표 열에서 시작됩니다 이전 필드의 마지막 문자.</target>
        </trans-unit>
        <trans-unit id="1ecf4f102cec092a989e853dbb05716d18d10735" translate="yes" xml:space="preserve">
          <source>If a subprogram does not expect any arguments, it should not have a&lt;code&gt;USING&lt;/code&gt;clause specified on it&amp;rsquo;s procedure division header.</source>
          <target state="translated">서브 프로그램이 인수를 기대하지 않으면, 프로 시저 분할 헤더에 &lt;code&gt;USING&lt;/code&gt; 절이 지정 되어서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="92b7f84efc871dae3988a9b29ad470f6b8703091" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;CONVERTING&lt;/code&gt;</source>
          <target state="translated">만약 &lt;code&gt;CONVERTING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2032d4dadae8be3fe061169d553c0926d6a379ee" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;DEFAULT&lt;/code&gt;clause is specified, any remaining uninitialized members of the field list will be initialized according to the default for their class (numeric and numeric-edited are initialized to ZERO, all others are initialized to SPACES).</source>
          <target state="translated">경우 &lt;code&gt;DEFAULT&lt;/code&gt; 의 절이 지정된 필드 목록의 나머지 초기화되지 않은 회원은 자신의 클래스에 대한 기본에 따라 초기화됩니다 (숫자와 숫자-편집이 0으로 초기화, 나머지는 모두 공간으로 초기화된다).</target>
        </trans-unit>
        <trans-unit id="7156dc318e4e3f5aa0881e3dc01f136733e5ac30" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;GO TO&lt;/code&gt;is executed within the scope of&amp;hellip;</source>
          <target state="translated">다음 의 범위 내에서 &lt;code&gt;GO TO&lt;/code&gt; 가 실행되는 경우&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="e12db606ad57abcf661cf0d99d8020cc167d9db0" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;LINAGE&lt;/code&gt;clause is also specified, Values specified for&lt;code&gt;LINAGE IS&lt;/code&gt;and&lt;code&gt;FOOTING AT&lt;/code&gt;will be ignored. The values of&lt;code&gt;LINES AT BOTTOM&lt;/code&gt;and&lt;code&gt;LINES AT TOP&lt;/code&gt; if any, will be honoured.</source>
          <target state="translated">경우 &lt;code&gt;LINAGE&lt;/code&gt; 절도 지정되어, 지정된 값 &lt;code&gt;LINAGE IS&lt;/code&gt; 와 &lt;code&gt;FOOTING AT&lt;/code&gt; 는 무시된다. 의 값 &lt;code&gt;LINES AT BOTTOM&lt;/code&gt; 및 &lt;code&gt;LINES AT TOP&lt;/code&gt; 어떤 경우에는 수상한다.</target>
        </trans-unit>
        <trans-unit id="b64062bb86b4cc026b65a0da4120142c176e5547" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;REMAINDER&lt;/code&gt;clause is specified, the value of the one and only &amp;lt;</source>
          <target state="translated">경우 &lt;code&gt;REMAINDER&lt;/code&gt; 절이 지정, 유일의 값 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="c8a9ba4a49154db62b70c94627e9f9a09a50f6f3" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;REPLACING&lt;/code&gt;clause is specified on the&lt;code&gt;INITIALIZE&lt;/code&gt;statement, each qualifying member of the field list that was not already initialized by a&lt;code&gt;VALUE&lt;/code&gt;clause, if any, will be initialized to the specified &amp;lt;</source>
          <target state="translated">경우 &lt;code&gt;REPLACING&lt;/code&gt; 절을에 지정된 &lt;code&gt;INITIALIZE&lt;/code&gt; 의 문, 이미 초기화되지 않은 필드 목록의 각 자격을 갖춘 회원 &lt;code&gt;VALUE&lt;/code&gt; 의 조항이있는 경우, 지정된 초기화됩니다 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="5b838d7717f95d20a08cd03498f7882a18db7072" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;TALLYING&lt;/code&gt;clause is coded, &amp;lt;</source>
          <target state="translated">경우 &lt;code&gt;TALLYING&lt;/code&gt; 절을 코딩, &amp;lt;</target>
        </trans-unit>
        <trans-unit id="42850d1581077257d5fcf6cbd3d76feb45a57582" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;USE FOR DEBUGGING&lt;/code&gt;(see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) section exists, the code within it will be disabled unless this environment variable is set to a value of &quot;Y&quot;, &quot;y&quot; or &quot;1&quot;.</source>
          <target state="translated">경우 &lt;code&gt;USE FOR DEBUGGING&lt;/code&gt; (참조 &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES를&lt;/a&gt; ) 섹션이 존재하는 환경 변수가 &quot;Y&quot;, &quot;Y&quot;또는 &quot;1&quot;의 값으로 설정되지 않는 한, 그 안에 코드는 비활성화 될 것이다.</target>
        </trans-unit>
        <trans-unit id="936f63734566944fcd01e49ee30a1e66bbeaea72" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;VALUE&lt;/code&gt;clause is specified on the&lt;code&gt;INITIALIZE&lt;/code&gt;statement, each qualifying member of the field list having a compile-time&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) specified in it&amp;rsquo;s definition will be initialized to that value. Field list members with&lt;code&gt;VALUE&lt;/code&gt;clauses will qualify for this treatment as follows:</source>
          <target state="translated">&lt;code&gt;INITIALIZE&lt;/code&gt; 문 에 &lt;code&gt;VALUE&lt;/code&gt; 절이 지정된 경우, 정의에 지정된 컴파일 시간 &lt;code&gt;VALUE&lt;/code&gt; ( &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt; 참조 ) 가있는 필드 목록의 각 규정 멤버는 해당 값으로 초기화됩니다. &lt;code&gt;VALUE&lt;/code&gt; 절이있는 필드 목록 멤버는 다음과 같이이 처리에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="bbb21152f55feeb2156f854427c62c771c0ef692" translate="yes" xml:space="preserve">
          <source>If all &amp;lt;</source>
          <target state="translated">모두 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="82152df9872b03795b0f65167d26e2e94749c462" translate="yes" xml:space="preserve">
          <source>If an argument identifier is smaller in storage size than the token value to be stored in it, the right-most excess characters of the token value will be truncated as the value is moved in. Any JUSTIFIED RIGHT clause on such an argument identifier will be ignored.</source>
          <target state="translated">인수 ID가 저장 될 토큰 값보다 저장 영역 크기가 더 작은 경우, 값이 이동함에 따라 토큰 값의 가장 오른쪽에있는 문자가 잘립니다. 이러한 인수 ID의 JUSTIFIED RIGHT 절은 다음과 같습니다. 무시되었습니다.</target>
        </trans-unit>
        <trans-unit id="bccb47600312a31302d4243c123c27cac5d4e303" translate="yes" xml:space="preserve">
          <source>If an argument is larger in storage size than the token value to be stored in it, the token value will be moved into the argument identifier in a left-justified manner. unmodified-modified byte positions in the identifier will be space filled, unless the argument identifier is defined as PIC 9 USAGE DISPLAY, in which case unmodified bytes will be filled with &quot;0&quot; characters from the systems native character set.</source>
          <target state="translated">인수가 저장 될 토큰 값보다 저장 영역 크기가 더 큰 경우, 토큰 값은 왼쪽 정렬 방식으로 인수 ID로 이동합니다. 인수 식별자가 PIC 9 USAGE DISPLAY로 정의되지 않으면 식별자의 수정되지 않은 수정 바이트 위치는 공백으로 채워집니다.이 경우 수정되지 않은 바이트는 시스템 기본 문자 세트의 &quot;0&quot;문자로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="14f8fa4ce97209c48ec71484cb50b99ef2bd0709" translate="yes" xml:space="preserve">
          <source>If an argument lacks a&lt;code&gt;BY&lt;/code&gt;clause, the most-recently encountered&lt;code&gt;BY&lt;/code&gt;specification on that&lt;code&gt;CALL&lt;/code&gt;statement will be assumed. If the first argument specified on a&lt;code&gt;CALL&lt;/code&gt;lacks a&lt;code&gt;BY&lt;/code&gt;clause,&lt;code&gt;BY REFERENCE&lt;/code&gt;will be assumed.</source>
          <target state="translated">인수에 &lt;code&gt;BY&lt;/code&gt; 절이 없으면 해당 &lt;code&gt;CALL&lt;/code&gt; 문 에서 가장 최근에 발생한 &lt;code&gt;BY&lt;/code&gt; 스펙 이 가정됩니다. 에 지정된 첫 번째 인수하는 경우 &lt;code&gt;CALL&lt;/code&gt; 이 부족 &lt;code&gt;BY&lt;/code&gt; 의 절을 &lt;code&gt;BY REFERENCE&lt;/code&gt; 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="05823b59c6e317b0d6f6bda99166cee75a4f73b6" translate="yes" xml:space="preserve">
          <source>If an argument whose value is less than 1 or greater than 256 is specified, the character in the program collating sequence corresponding to a value of all zero bits is returned.</source>
          <target state="translated">값이 1보다 작거나 256보다 큰 인수가 지정된 경우, 프로그램 조합 순서에서 모든 0 비트의 값에 해당하는 문자가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="2b8c1834ab8abb452a19e34dee7da8437a78703c" translate="yes" xml:space="preserve">
          <source>If an environment variable was found, it&amp;rsquo;s value will serve as the path and filename to the data file.</source>
          <target state="translated">환경 변수가 발견되면 해당 값은 데이터 파일의 경로 및 파일 이름으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bcab58a3e462d384fa130cd4e9016e959b6a71b4" translate="yes" xml:space="preserve">
          <source>If an&lt;code&gt;ASSIGN&lt;/code&gt;clause is coded without a &amp;lt;&amp;lt;</source>
          <target state="translated">&lt;code&gt;ASSIGN&lt;/code&gt; 절이 &amp;lt;&amp;lt;없이 코딩 된 경우</target>
        </trans-unit>
        <trans-unit id="c44efa18b320631b1a96a201bad730ca80153f8d" translate="yes" xml:space="preserve">
          <source>If an&lt;code&gt;EXIT PARAGRAPH&lt;/code&gt;statement or&lt;code&gt;EXIT SECTION&lt;/code&gt;statement resides</source>
          <target state="translated">에 If &lt;code&gt;EXIT PARAGRAPH&lt;/code&gt; 문 또는 &lt;code&gt;EXIT SECTION&lt;/code&gt; 문 상주</target>
        </trans-unit>
        <trans-unit id="87612bdd6bb75a44b81526c8c27d9968de497f3d" translate="yes" xml:space="preserve">
          <source>If an&lt;code&gt;EXIT PARAGRAPH&lt;/code&gt;statement or&lt;code&gt;EXIT SECTION&lt;/code&gt;statement resides in a paragraph</source>
          <target state="translated">에 If &lt;code&gt;EXIT PARAGRAPH&lt;/code&gt; 문 또는 &lt;code&gt;EXIT SECTION&lt;/code&gt; 단락의 문 상주</target>
        </trans-unit>
        <trans-unit id="3f0242e3af04c028a1ddce44867fb3964faf61b9" translate="yes" xml:space="preserve">
          <source>If an&lt;code&gt;INITIATE&lt;/code&gt;is followed by a&lt;code&gt;TERMINATE&lt;/code&gt;with no intervening&lt;code&gt;GENERATE&lt;/code&gt;(see &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;) statements (all pertaining to the same report, of course), no report groups will be presented to the output file.</source>
          <target state="translated">이 경우 &lt;code&gt;INITIATE&lt;/code&gt; a로 다음에 &lt;code&gt;TERMINATE&lt;/code&gt; 중간에 더와 &lt;code&gt;GENERATE&lt;/code&gt; (참조 &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt; ) 문 (모든 물론, 동일한 보고서에 관한), 어떤 보고서 그룹은 출력 파일에 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1989e1692cf63856050ee6de069649854e1b7eed" translate="yes" xml:space="preserve">
          <source>If any &amp;lt;</source>
          <target state="translated">만약 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="ded48aebbdbbf018e482c90608c9d4d54578f860" translate="yes" xml:space="preserve">
          <source>If any of the paragraphs within one of the sections are coded, the section header itself must be coded.</source>
          <target state="translated">섹션 중 하나에있는 단락 중 하나라도 코딩 된 경우 섹션 헤더 자체를 코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="098c66a7cc7db43fe1a5e65ab50d6051cee41a88" translate="yes" xml:space="preserve">
          <source>If at least one&lt;code&gt;GENERATE&lt;/code&gt;statement of this form is executed against a report, the report is said to be a &amp;rsquo;</source>
          <target state="translated">이 형식의 &lt;code&gt;GENERATE&lt;/code&gt; 문을 하나 이상 보고서에 대해 실행하면 보고서는 '</target>
        </trans-unit>
        <trans-unit id="bbb1f438e0e2ddccdd230dea44836bc244c52259" translate="yes" xml:space="preserve">
          <source>If both optional sections of this division are coded, they must be coded in the sequence shown.</source>
          <target state="translated">이 부서의 두 옵션 섹션이 모두 코딩 된 경우 표시된 순서대로 코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="e41dfd24c49449dc06a287d66915bfb31196edfa" translate="yes" xml:space="preserve">
          <source>If both statement types are coded in the&lt;code&gt;I-O-CONTROL&lt;/code&gt;paragraph, the order in which those statements are coded is irrelevant.</source>
          <target state="translated">두 명령문 유형이 모두 &lt;code&gt;I-O-CONTROL&lt;/code&gt; 단락에 코딩 된 경우 해당 명령문이 코딩되는 순서는 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="776f3c5eecbcd34d511d3925b8b352f3fe294871" translate="yes" xml:space="preserve">
          <source>If both the&lt;code&gt;TALLYING&lt;/code&gt;and&lt;code&gt;REPLACING&lt;/code&gt;clauses are specified, they must be specified in the order shown.</source>
          <target state="translated">두 경우 &lt;code&gt;TALLYING&lt;/code&gt; 및 &lt;code&gt;REPLACING&lt;/code&gt; 절을 지정, 그들은 표시된 순서대로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="49551f9075c0114086955d559a1442bce3fdaf10" translate="yes" xml:space="preserve">
          <source>If control of execution is transferred to a procedure named on the statement, and the&lt;code&gt;GO TO&lt;/code&gt;is executed within the scope of&amp;hellip;</source>
          <target state="translated">실행 제어가 명령문에 명명 된 프로 시저로 전송되고 &lt;code&gt;GO TO&lt;/code&gt; 가 |</target>
        </trans-unit>
        <trans-unit id="25bbb2134d570b993f324faa68838566a3259e83" translate="yes" xml:space="preserve">
          <source>If copybooks your program needs are NOT stored in the same directory as your program, set this environment variable to the folder in which the copybooks may be found (IBM mainframe programmers will recognize this as &quot;SYSLIB&quot;).</source>
          <target state="translated">프로그램에 필요한 카피 북이 프로그램과 동일한 디렉토리에 저장되어 있지 않으면이 환경 변수를 카피 북을 찾을 수있는 폴더로 설정하십시오 (IBM 메인 프레임 프로그래머는이를 &quot;SYSLIB&quot;로 인식 함).</target>
        </trans-unit>
        <trans-unit id="325de08baac6d6bd1b4e1ebed585b6caa542bf6a" translate="yes" xml:space="preserve">
          <source>If desired, screen fields used as input fields may defined as &quot;secure&quot; fields, where each input character (regardless of what was actually typed) will appear as an asterisk (*) character. The actual character whose key was pressed will still be stored into the field in the program, however. This is very useful for password or account number fields.</source>
          <target state="translated">원하는 경우 입력 필드로 사용 된 화면 필드는 &quot;보안&quot;필드로 정의 될 수 있으며, 여기서 각 입력 문자 (실제로 입력 한 내용에 관계없이)는 별표 (*) 문자로 나타납니다. 그러나 키를 누른 실제 문자는 여전히 프로그램의 필드에 저장됩니다. 암호 또는 계정 번호 필드에 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e8c0e23858d8c34351be31b2e2dd7ef0f308a47c" translate="yes" xml:space="preserve">
          <source>If desired, you may reverse the roles of the&lt;code&gt;.&lt;/code&gt;and&lt;code&gt;,&lt;/code&gt;editing symbols by specifying&lt;code&gt;DECIMAL POINT IS COMMA&lt;/code&gt;in the&lt;code&gt;SPECIAL-NAMES&lt;/code&gt;(see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) paragraph.</source>
          <target state="translated">원하는 경우의 역할을 취소 할 수 있습니다 &lt;code&gt;.&lt;/code&gt; 그리고 &lt;code&gt;,&lt;/code&gt; 특정 심볼에 의해 편집 &lt;code&gt;DECIMAL POINT IS COMMA&lt;/code&gt; 에 &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; (참조 &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt; 단락).</target>
        </trans-unit>
        <trans-unit id="cfeb571780980c15ef5118f06fd533dfd406e005" translate="yes" xml:space="preserve">
          <source>If either condition has a value of TRUE, the result of&lt;code&gt;OR&lt;/code&gt;</source>
          <target state="translated">두 조건 중 하나라도 TRUE이면 &lt;code&gt;OR&lt;/code&gt; 의 결과</target>
        </trans-unit>
        <trans-unit id="bc1c6b979e9c37d992caa4fdb32b5bbe5b97b0db" translate="yes" xml:space="preserve">
          <source>If either the&lt;code&gt;TALLYING&lt;/code&gt;or&lt;code&gt;REPLACING&lt;/code&gt;clauses are specified, the&lt;code&gt;CONVERTING&lt;/code&gt;clause cannot be used.</source>
          <target state="translated">어느 경우 &lt;code&gt;TALLYING&lt;/code&gt; 또는 &lt;code&gt;REPLACING&lt;/code&gt; 절을 지정의 &lt;code&gt;CONVERTING&lt;/code&gt; 절은 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="65d896699ba7417f38fac49a744a6351011f2338" translate="yes" xml:space="preserve">
          <source>If event (A) occurs, &amp;lt;</source>
          <target state="translated">이벤트 (A)가 발생하면 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="c6ea8276245b74726b44312b8cbb459b9ea45f59" translate="yes" xml:space="preserve">
          <source>If event (A) occurs, none of the destination field contents (or the contents of their&lt;code&gt;DELIMITER&lt;/code&gt;or &amp;lt;</source>
          <target state="translated">이벤트 (A)가 발생하면 대상 필드 내용 (또는 &lt;code&gt;DELIMITER&lt;/code&gt; 또는 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="c766138e5b6a0fb5e159fe3be6df3cb65c15aa94" translate="yes" xml:space="preserve">
          <source>If excess space is allocated, the returned value will be padded with spaces (to the right).</source>
          <target state="translated">초과 공간이 할당되면 반환 된 값은 공백으로 채워집니다 (오른쪽).</target>
        </trans-unit>
        <trans-unit id="dcf599fa35195bfeb7d750a1aa7ddb9854348d4d" translate="yes" xml:space="preserve">
          <source>If executed by a main program, neither the&lt;code&gt;EXIT PROGRAM&lt;/code&gt;nor&lt;code&gt;EXIT FUNCTION&lt;/code&gt;statements will take any action.</source>
          <target state="translated">기본 프로그램에서 실행하면 &lt;code&gt;EXIT PROGRAM&lt;/code&gt; 또는 &lt;code&gt;EXIT FUNCTION&lt;/code&gt; 문은 어떤 조치도 취하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="adc22a801c0d5cf9afd2251ba837acc24c7e7595" translate="yes" xml:space="preserve">
          <source>If executed within a main program,&lt;code&gt;GOBACK&lt;/code&gt;will act as a&lt;code&gt;STOP RUN&lt;/code&gt;statement.</source>
          <target state="translated">기본 프로그램 내에서 실행되면 &lt;code&gt;GOBACK&lt;/code&gt; 은 &lt;code&gt;STOP RUN&lt;/code&gt; 문 으로 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="0c913e686677f4f2542ed04551fc54a61ca3b586" translate="yes" xml:space="preserve">
          <source>If executed within a subprogram (i.e. a subroutine or user-defined function),&lt;code&gt;GOBACK&lt;/code&gt;behaves like an&lt;code&gt;EXIT PROGRAM&lt;/code&gt;or&lt;code&gt;EXIT FUNCTION&lt;/code&gt;statement, respectively.</source>
          <target state="translated">서브 프로그램 (즉, 서브 루틴 또는 사용자 정의 함수) 내에서 실행되는 경우 &lt;code&gt;GOBACK&lt;/code&gt; 은 각각 &lt;code&gt;EXIT PROGRAM&lt;/code&gt; 또는 &lt;code&gt;EXIT FUNCTION&lt;/code&gt; 문 처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="37a5ec4ba4f6eb14fb6bc4cdf6c2b834a2e18251" translate="yes" xml:space="preserve">
          <source>If insufficient space is allocated, the returned value will be truncated.</source>
          <target state="translated">충분한 공간이 할당되지 않으면 반환 된 값이 잘립니다.</target>
        </trans-unit>
        <trans-unit id="20788d6df5c521759ffd6da038d7efacbc53537c" translate="yes" xml:space="preserve">
          <source>If it begins with a capital &quot;C&quot;, the value will be centred</source>
          <target state="translated">대문자 &quot;C&quot;로 시작하면 값이 중앙에 위치합니다.</target>
        </trans-unit>
        <trans-unit id="cce45705eb2edf3ee981ccb8a02325faa9873b7a" translate="yes" xml:space="preserve">
          <source>If it begins with a capital &quot;L&quot;, the value will be left-justified, space-filled to the right</source>
          <target state="translated">대문자 &quot;L&quot;로 시작하면 값이 왼쪽으로 정렬되고 오른쪽으로 공간이 채워집니다.</target>
        </trans-unit>
        <trans-unit id="49095cec719464061ddd1eea1650a1e60b0b3522" translate="yes" xml:space="preserve">
          <source>If it begins with a capital &quot;R&quot;, the value will be right-justified, space-filled to the left</source>
          <target state="translated">대문자 &quot;R&quot;로 시작하면 값이 오른쪽으로 정렬되고 왼쪽으로 공간이 채워집니다.</target>
        </trans-unit>
        <trans-unit id="e6e9d41a84edd6ab6b611b8a64b21d8cc9efa7ef" translate="yes" xml:space="preserve">
          <source>If it begins with anything else, or is absent, it will be treated as if it is present and begins with a capital &quot;R&quot;</source>
          <target state="translated">다른 것으로 시작하거나없는 경우, 존재하는 것처럼 취급되고 대문자 &quot;R&quot;로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="ddfddaec4eb6defafd4236c3804acb2833a56ffc" translate="yes" xml:space="preserve">
          <source>If it is a dynamic subroutine, the GnuCOBOL run-time system will check to see if a dynamically-loadable module containing the subprogram&amp;rsquo;s entry point was already located. If it was, no further &quot;location&quot; activity is needed. If not, the dynamically-loadable module will be located (see &lt;a href=&quot;#Locating-Dynamically_002dLoadable-Modules&quot;&gt;Locating Dynamically-Loadable Modules&lt;/a&gt;).</source>
          <target state="translated">동적 서브 루틴 인 경우 GnuCOBOL 런타임 시스템은 서브 프로그램의 진입 점이 포함 된 동적으로로드 가능한 모듈이 이미 있는지 확인합니다. 그렇다면 추가 &quot;위치&quot;활동이 필요하지 않습니다. 그렇지 않으면 동적으로로드 가능한 모듈이 배치됩니다 ( &lt;a href=&quot;#Locating-Dynamically_002dLoadable-Modules&quot;&gt;동적로드 가능한 모듈 찾기&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a084bcee5f6f297e9fac72fc57197692e67653da" translate="yes" xml:space="preserve">
          <source>If it is a dynamic user-defined function, the GnuCOBOL run-time system will check to see if a dynamically-loadable module containing the function&amp;rsquo;s entry point was already located. If it was, no further &quot;location&quot; activity is needed. If not, the dynamically-loadable module will be located (see &lt;a href=&quot;#Locating-Dynamically_002dLoadable-Modules&quot;&gt;Locating Dynamically-Loadable Modules&lt;/a&gt;).</source>
          <target state="translated">동적 사용자 정의 함수 인 경우 GnuCOBOL 런타임 시스템은 함수의 진입 점이 포함 된 동적으로로드 가능한 모듈이 이미 있는지 확인합니다. 그렇다면 추가 &quot;위치&quot;활동이 필요하지 않습니다. 그렇지 않으면 동적으로로드 가능한 모듈이 배치됩니다 ( &lt;a href=&quot;#Locating-Dynamically_002dLoadable-Modules&quot;&gt;동적로드 가능한 모듈 찾기&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d0f43ca29a675e226a37e6b6d8088cdbc37ebd39" translate="yes" xml:space="preserve">
          <source>If it is a static subroutine, it will already be part of the executable program issuing the&lt;code&gt;CALL&lt;/code&gt;(see &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt;).</source>
          <target state="translated">정적 서브 루틴 인 경우 이미 &lt;code&gt;CALL&lt;/code&gt; 을 발행하는 실행 프로그램의 일부입니다 ( &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="caa175b4499a85fc8b3c0efe4a0f73f3d1c1c886" translate="yes" xml:space="preserve">
          <source>If it is a static user-defined function, it will already be part of the executable file containing the calling program.</source>
          <target state="translated">정적 사용자 정의 함수 인 경우 이미 호출 프로그램을 포함하는 실행 파일의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="84a0f01c66da97418e3aa21d01e0ef5b3ae55060" translate="yes" xml:space="preserve">
          <source>If more than one section is needed in the data division (a common situation), the sections must be coded in the sequence they are presented above.</source>
          <target state="translated">데이터 분할 (일반적인 상황)에 둘 이상의 섹션이 필요한 경우 섹션은 위에 제시된 순서대로 코딩되어야합니다.</target>
        </trans-unit>
        <trans-unit id="08575c4d82cf8b371a6f7d53f268979ac88898e9" translate="yes" xml:space="preserve">
          <source>If necessary, &amp;lt;</source>
          <target state="translated">필요한 경우 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="f63584104f0c3fb031bde71d0b6dcee112c103e0" translate="yes" xml:space="preserve">
          <source>If neither paragraph is coded, the&lt;code&gt;INPUT-OUTPUT SECTION.&lt;/code&gt;header itself may be omitted, otherwise it is normally required.</source>
          <target state="translated">단락이 코딩되지 않으면 &lt;code&gt;INPUT-OUTPUT SECTION.&lt;/code&gt; 헤더 자체는 생략 될 수 있으며, 그렇지 않으면 일반적으로 필요합니다.</target>
        </trans-unit>
        <trans-unit id="112a01f52ed19b32bc288508d6054c95da8fdd85" translate="yes" xml:space="preserve">
          <source>If no &amp;lt;</source>
          <target state="translated">없는 경우 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="c520e3d4aae69229f5d030660491f8d24e39ce90" translate="yes" xml:space="preserve">
          <source>If no &amp;lt;&amp;lt;</source>
          <target state="translated">없는 경우 &amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="cccae1dc6e8637e1b5c5c2fbf5052d3f0ccf07fa" translate="yes" xml:space="preserve">
          <source>If no &amp;rsquo;</source>
          <target state="translated">'아니요</target>
        </trans-unit>
        <trans-unit id="80ec6de7e7c7e7960f42ef9bf764d5e364ff0ae6" translate="yes" xml:space="preserve">
          <source>If no data division sections are needed, the&lt;code&gt;DATA DIVISION.&lt;/code&gt;header itself may be omitted.</source>
          <target state="translated">데이터 분할 섹션이 필요하지 않으면 &lt;code&gt;DATA DIVISION.&lt;/code&gt; 헤더 자체는 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5c8083a19d4bf6b791a2ad3bee37fd9780d046a" translate="yes" xml:space="preserve">
          <source>If no data will be described in one of the data division sections, that section header may be omitted.</source>
          <target state="translated">데이터 분할 섹션 중 하나에서 데이터가 설명되지 않으면, 해당 섹션 헤더는 생략 될 수있다.</target>
        </trans-unit>
        <trans-unit id="4ea37cd62fe13ae475efaf0fa631e7d1254a22ce" translate="yes" xml:space="preserve">
          <source>If no environment variable was found, or the &quot;config&quot; file used to compile the program had a &quot;filename-mapping&quot; value of &quot;no&quot;, then the File Locator String value will serve as the path and filename to the data file.</source>
          <target state="translated">환경 변수가 없거나 프로그램을 컴파일하는 데 사용 된 &quot;config&quot;파일의 &quot;filename-mapping&quot;값이 &quot;no&quot;인 경우 File Locator String 값은 데이터 파일의 경로 및 파일 이름으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="97d63005403252ba6869749f325e5b668c7826c7" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;ADVANCING&lt;/code&gt;clause is specified on a&lt;code&gt;WRITE&lt;/code&gt;to a line-advancing file,&lt;code&gt;AFTER ADVANCING 1 LINE&lt;/code&gt;will be assumed; on other than line-advancing files,&lt;code&gt;BEFORE ADVANCING 1 LINE&lt;/code&gt;will be assumed.</source>
          <target state="translated">&lt;code&gt;WRITE&lt;/code&gt; 에 &lt;code&gt;ADVANCING&lt;/code&gt; 절이 라인 어드밴 &lt;code&gt;AFTER ADVANCING 1 LINE&lt;/code&gt; 파일 에 지정 되지 않으면 AFTER ADVANCING 1 LINE 이 가정됩니다. &lt;code&gt;BEFORE ADVANCING 1 LINE&lt;/code&gt; 진행 파일 이외의 다른 파일에서는 가정합니다.</target>
        </trans-unit>
        <trans-unit id="6c0dd54af0bcfe6aba553419a7f8fa41175966da" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;AFTER&lt;/code&gt;is specified, the first character position of the target range will be character position #1 of the inspect subject.</source>
          <target state="translated">&lt;code&gt;AFTER&lt;/code&gt; 를 지정 하지 않으면 대상 범위의 첫 번째 문자 위치가 검사 대상의 문자 위치 # 1이됩니다.</target>
        </trans-unit>
        <trans-unit id="15393df0a9af6eb90b29b75caf239e68d67158ac" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;BEFORE&lt;/code&gt;is specified, the last character position of the target range will be the last character position of the inspect subject.</source>
          <target state="translated">&lt;code&gt;BEFORE&lt;/code&gt; 를 지정 하지 않으면 대상 범위의 마지막 문자 위치가 검사 대상의 마지막 문자 위치가됩니다.</target>
        </trans-unit>
        <trans-unit id="1a0d2b27d4ce9b801ffdc741e7e7060c7a514405" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;COLLATING SEQUENCE&lt;/code&gt;clause is specified, the collating sequence implied by the character set native to the computer (usually ASCII) will be used.</source>
          <target state="translated">&lt;code&gt;COLLATING SEQUENCE&lt;/code&gt; 절을 지정 하지 않으면 컴퓨터 고유 문자 세트 (일반적으로 ASCII)에 의해 암시 된 조합 순서가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="938ef54a5b2f3a79dc5e586019fcecd25b200f27" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;FIRST&lt;/code&gt;&lt;code&gt;LAST&lt;/code&gt;or&lt;code&gt;KEY&lt;/code&gt;clause is specified,&lt;code&gt;KEY IS EQUAL TO xxx&lt;/code&gt;will be assumed, where &quot;xxx&quot; is the defined&lt;code&gt;RELATIVE KEY&lt;/code&gt;of (if &amp;lt;</source>
          <target state="translated">&lt;code&gt;FIRST&lt;/code&gt; &lt;code&gt;LAST&lt;/code&gt; 또는 &lt;code&gt;KEY&lt;/code&gt; 절이 지정 되지 않으면 &lt;code&gt;KEY IS EQUAL TO xxx&lt;/code&gt; 가 가정됩니다. 여기서 &quot;xxx&quot;는 정의 된 &lt;code&gt;RELATIVE KEY&lt;/code&gt; (</target>
        </trans-unit>
        <trans-unit id="3c134ddd26a13c987732536178ffc2d3596e0cc0" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;FROM&lt;/code&gt;clause is specified,&lt;code&gt;FROM CONSOLE&lt;/code&gt;is assumed.</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 절이 지정 되지 않으면 &lt;code&gt;FROM CONSOLE&lt;/code&gt; 이 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="a936605766c63b6943b34a949cbfd95d11891a47" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;PAGE LIMITS&lt;/code&gt;clause is specified, the entire report will be generated as if it consists of a single arbitrarily long page.</source>
          <target state="translated">&lt;code&gt;PAGE LIMITS&lt;/code&gt; 절을 지정 하지 않으면 , 임의의 긴 페이지로 구성된 것처럼 전체 보고서가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="8df6bcbeab6aa11894e4fe7cbd9a91d3d00317e5" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;UPON&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;UPON&lt;/code&gt; 이 없으면</target>
        </trans-unit>
        <trans-unit id="fe6ea8dfb325db99c6308c46b06bda141821bb43" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;VALUE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;VALUE&lt;/code&gt; 가 없으면</target>
        </trans-unit>
        <trans-unit id="acc316a6b22ed428d8859027514f370adf001d62" translate="yes" xml:space="preserve">
          <source>If none of the features provided by the configuration section are required by a program, the entire&lt;code&gt;CONFIGURATION SECTION.&lt;/code&gt;header may be omitted from the program.</source>
          <target state="translated">구성 섹션에서 제공하는 기능이 프로그램에 필요하지 않은 경우 전체 &lt;code&gt;CONFIGURATION SECTION.&lt;/code&gt; 프로그램에서 헤더를 생략해도됩니다.</target>
        </trans-unit>
        <trans-unit id="38302bf8e20435daf87449711673f45dc0fc7efa" translate="yes" xml:space="preserve">
          <source>If none of the paragraphs within one of the sections are coded, the section header itself may be omitted.</source>
          <target state="translated">섹션 중 하나 내의 단락이 코딩되지 않은 경우 섹션 헤더 자체는 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c20690aa244c08791983cf1b27135cf3c295161b" translate="yes" xml:space="preserve">
          <source>If none of the sections within the data division are coded (a highly unlikely, but theoretically possible circumstance), the&lt;code&gt;DATA DIVISION.&lt;/code&gt;header itself may be omitted.</source>
          <target state="translated">데이터 분할 내의 섹션이 코딩되지 않은 경우 (아마도 가능하지만 이론적으로 가능한 상황 인 경우) &lt;code&gt;DATA DIVISION.&lt;/code&gt; 헤더 자체는 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a6df96501f79aab798f69106ec9e2b97487e708" translate="yes" xml:space="preserve">
          <source>If none of the sections within the environment division are coded, the&lt;code&gt;ENVIRONMENT DIVISION.&lt;/code&gt;header itself may be omitted.</source>
          <target state="translated">환경 부서 내의 섹션이 코딩되지 않은 경우 &lt;code&gt;ENVIRONMENT DIVISION.&lt;/code&gt; 헤더 자체는 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f3504ace1fcbbfe8785eaf44906c2e8b0fac8ce" translate="yes" xml:space="preserve">
          <source>If references to table elements are going to be performed many, many times (tens or hundreds of thousands of times or more) during program execution, you will probably see a noticeable reduction in program execution time if you use indexing versus subscripting.</source>
          <target state="translated">프로그램을 실행하는 동안 테이블 요소에 대한 참조를 여러 번 (수십 또는 수십만 회 이상) 수행하려는 경우 인덱싱과 첨자를 사용하면 프로그램 실행 시간이 눈에 띄게 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="8e464aa3baae37e1c17db766f8597a99a293b6e4" translate="yes" xml:space="preserve">
          <source>If references to table elements are not going to be performed many, many times it probably won&amp;rsquo;t make much difference whether you use indexing or subscripting.</source>
          <target state="translated">테이블 요소에 대한 참조가 여러 번 수행되지 않으면 인덱싱 또는 첨자 사용 여부에 따라 큰 차이가 없을 것입니다.</target>
        </trans-unit>
        <trans-unit id="2d7b2b72b6ddc84fee15212248b1a81b23f1b096" translate="yes" xml:space="preserve">
          <source>If rule (A) is violated, the compiler will reject the&lt;code&gt;SEARCH ALL&lt;/code&gt; If rules (B) and/or (C) are violated, there will be no message issued by the compiler, but the run-time results of a&lt;code&gt;SEARCH ALL&lt;/code&gt;against the table will probably be incorrect.</source>
          <target state="translated">규칙 (A)를 위반하는 경우, 거부합니다 컴파일러 &lt;code&gt;SEARCH ALL&lt;/code&gt; 규칙 (B) 및 / 또는 (C)를 위반하는 경우, 컴파일러에 의해 발행 된 어떠한 메시지,하지만의 런타임 결과가 없습니다 &lt;code&gt;SEARCH ALL&lt;/code&gt; 에 대한 테이블이 잘못되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="953965bec96dd86973cb12584b0c3f4d8e27d9dc" translate="yes" xml:space="preserve">
          <source>If set to &quot;Y&quot;, &quot;y&quot; or &quot;1&quot;, a&lt;code&gt;CANCEL&lt;/code&gt;statement (see &lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt;) will physically unload a subprogram dynamically-loadable module.</source>
          <target state="translated">&quot;Y&quot;, &quot;y&quot;또는 &quot;1&quot;로 설정되면 &lt;code&gt;CANCEL&lt;/code&gt; 문 ( &lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt; 참조 )이 서브 프로그램 동적로드 가능 모듈을 실제로 언로드합니다.</target>
        </trans-unit>
        <trans-unit id="e304fe2f130a29229fe3b203d139f3c8d0b1b8a9" translate="yes" xml:space="preserve">
          <source>If set to a value of &quot;Y&quot;, any run-time warnings (such as noting the implicit closing of open files when a&lt;code&gt;GOBACK&lt;/code&gt;statement (see &lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt;) or&lt;code&gt;STOP&lt;/code&gt;statement (see &lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt;) with the&lt;code&gt;RUN&lt;/code&gt;option is executed) will be displayed. Any other value for this environment variable (including not setting the variable at all) will suppress such messages.</source>
          <target state="translated">&quot;Y&quot;값으로 설정하면 런타임 경고 (예 : &lt;code&gt;GOBACK&lt;/code&gt; 문 ( &lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt; 참조 ) 또는 &lt;code&gt;RUN&lt;/code&gt; 옵션으로 &lt;code&gt;STOP&lt;/code&gt; 문 ( &lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt; 참조 ) 이 실행될 때 열린 파일을 암시 적으로 닫는 것과 같은 )가 표시됩니다. . 이 환경 변수의 다른 값 (변수를 전혀 설정하지 않은 것을 포함하여)은 그러한 메시지를 억제합니다.</target>
        </trans-unit>
        <trans-unit id="2bc077c4c98b87e839493508304c45c1d8484f6d" translate="yes" xml:space="preserve">
          <source>If set to a value of upper- or lower-case &quot;p&quot;, this variable will force a file commit every time a file is written to (ensuring that data is immediately written to the file rather than retained in memory until a future commit occurs). This will slow-down update access to files, but will provide for better integrity in the event of a program failure.</source>
          <target state="translated">대문자 또는 소문자 &quot;p&quot;값으로 설정하면이 변수는 파일을 쓸 때마다 파일 커밋을 강제 실행합니다 (미래 커밋이 발생할 때까지 데이터가 메모리에 유지되지 않고 즉시 파일에 기록되도록 보장합니다) ). 이렇게하면 파일에 대한 업데이트 액세스 속도가 느려지지만 프로그램 오류 발생시 무결성이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="1ff6dd80412acb65fea091eeee45227f17f79745" translate="yes" xml:space="preserve">
          <source>If set to any non-blank value, this variable allows a&lt;code&gt;ACCEPT screen-data-item&lt;/code&gt;statement (see &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;) to detect the &quot;Esc&quot; key.</source>
          <target state="translated">공백이 아닌 값으로 설정된 경우이 변수를 사용하면 &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; 명령문 ( &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT 화면 데이터 항목 참조&lt;/a&gt; )이 &quot;Esc&quot;키를 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02c873d8dea11df102afae708aa8d02b69151e6b" translate="yes" xml:space="preserve">
          <source>If set to any non-null value, this environment variable specifies the file to which all&lt;code&gt;-ftrace&lt;/code&gt;switch and&lt;code&gt;-ftraceall&lt;/code&gt;switch output will be written.</source>
          <target state="translated">널이 아닌 값으로 설정되면이 환경 변수는 모든 &lt;code&gt;-ftrace&lt;/code&gt; 스위치 및 &lt;code&gt;-ftraceall&lt;/code&gt; 스위치 출력이 기록 될 파일을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="422d3cddd2d7b811c88085d18de9df66cdccb313" translate="yes" xml:space="preserve">
          <source>If set to any non-null value, this variable will cause all dynamically-loadable libraries to be loaded when the program begins execution (rather than searching for and loading the module upon first use).</source>
          <target state="translated">널이 아닌 값으로 설정되면이 변수는 프로그램이 실행을 시작할 때 (처음 사용할 때 모듈을 검색하여로드하지 않고) 동적으로로드 가능한 모든 라이브러리를로드합니다.</target>
        </trans-unit>
        <trans-unit id="d8aab5d7cf6334fa7d1d64a36e03690790d2311f" translate="yes" xml:space="preserve">
          <source>If set to anything else, a&lt;code&gt;CANCEL&lt;/code&gt;statement (see &lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt;) logically unloads a module so that subsequent use will re-initialize the module as if it had actually been reloaded, but the overhead of actually reloading the module will be avoided.</source>
          <target state="translated">다른 것으로 설정하면 &lt;code&gt;CANCEL&lt;/code&gt; 문 ( &lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt; 참조 )이 모듈을 논리적으로 언로드하여 후속 사용에서 실제로 재로드 된 것처럼 모듈을 다시 초기화하지만 실제로 재로드하는 오버 헤드는 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffb03e9553a2471b244e5697186cb21ecae1836a" translate="yes" xml:space="preserve">
          <source>If set to either&lt;code&gt;UPPER&lt;/code&gt;or&lt;code&gt;LOWER&lt;/code&gt; this environment variable will internally convert referenced entry-point names to either upper- or lower-case before initiating searches for dynamically-loadable modules. The&lt;code&gt;UPPER&lt;/code&gt;and&lt;code&gt;LOWER&lt;/code&gt;values of the environment variable are actually case-insensitive.</source>
          <target state="translated">&lt;code&gt;UPPER&lt;/code&gt; 또는 &lt;code&gt;LOWER&lt;/code&gt; 로 설정되면 이 환경 변수는 동적으로로드 가능한 모듈에 대한 검색을 시작하기 전에 참조 된 진입 점 이름을 내부적으로 대문자 또는 소문자로 변환합니다. 환경 변수 의 &lt;code&gt;UPPER&lt;/code&gt; 및 &lt;code&gt;LOWER&lt;/code&gt; 값은 실제로 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75ff3ad897d4389bd5d4346a9d0cead6b649265f" translate="yes" xml:space="preserve">
          <source>If specified, &amp;lt;</source>
          <target state="translated">지정된 경우 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="fc641baf619f0e3d0d10496e69f3b55fd6e604c8" translate="yes" xml:space="preserve">
          <source>If the &amp;lt;</source>
          <target state="translated">&amp;lt;</target>
        </trans-unit>
        <trans-unit id="80f8927587ac8a416163b826212188d6cd97481c" translate="yes" xml:space="preserve">
          <source>If the DISPLAY verb is executing, then the size is the same as if the CONVERT phrase were not specified except for numeric items. For numeric items, the size is the number of digits in the item, plus one if it is not an integer, plus one if it is signed. The remaining cases cover the size when an ACCEPT statement is used.</source>
          <target state="translated">DISPLAY 동사가 실행중인 경우 크기는 숫자 항목을 제외하고 CONVERT 문구가 지정되지 않은 것과 같습니다. 숫자 항목의 경우 크기는 항목의 자릿수와 정수가 아닌 경우 1을 더한 값, 부호가있는 경우 1을 더한 값입니다. 나머지 경우는 ACCEPT 문이 사용될 때 크기를 커버합니다.</target>
        </trans-unit>
        <trans-unit id="fd1fa5d5fdcea9b7c73d25c9d04a3be93ca9dd38" translate="yes" xml:space="preserve">
          <source>If the GnuCOBOL build you are using was configured to use the Berkeley Database (BDB) package for indexed file I/O, record locking will be available by using the</source>
          <target state="translated">사용중인 GnuCOBOL 빌드가 색인화 된 파일 I / O에 BDB (Berkeley Database) 패키지를 사용하도록 구성된 경우 레코드 잠금을 사용하여 레코드 잠금을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa11e579492cde59f0f2b4460dae0515f472c0c0" translate="yes" xml:space="preserve">
          <source>If the GnuCOBOL compiler you are using was built to utilize a native Windows environment, use a semicolon (;) as the delimiter character.</source>
          <target state="translated">사용중인 GnuCOBOL 컴파일러가 고유 Windows 환경을 사용하도록 빌드 된 경우 세미콜론 (;)을 구분 기호 문자로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e8e174d71b0a53ce0abb721ccafcd0e36830ee7a" translate="yes" xml:space="preserve">
          <source>If the LINAGE clause is</source>
          <target state="translated">LINAGE 절이</target>
        </trans-unit>
        <trans-unit id="876792b175fdff61a6c190841827c8f95e62bf94" translate="yes" xml:space="preserve">
          <source>If the SIZE phrase is not used, then the field length defaults to the size of the item being accepted or displayed. If the CONVERT phrase is used, however, then the size of the field depends on the data type of the item and the verb being used.</source>
          <target state="translated">SIZE 구문을 사용하지 않으면 필드 길이는 기본적으로 허용되거나 표시되는 항목의 크기입니다. 그러나 CONVERT 문구가 사용되는 경우 필드의 크기는 항목의 데이터 유형과 사용되는 동사에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a1a846b486d6a849fb5aee6dc27f07a8ed92c919" translate="yes" xml:space="preserve">
          <source>If the attempt to copy the file fails (for example, it or the destination directory doesn&amp;rsquo;t exist), the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) will be set to 128; on successful completion it will be set to 0.</source>
          <target state="translated">파일을 복사 할 수있는 시도가 실패하면 (예를 들어, 또는 존재하지 않는 대상 디렉토리)는 &lt;code&gt;RETURN-CODE&lt;/code&gt; 의 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터를&lt;/a&gt; 128로 설정됩니다) 성공적으로 완료되면 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="da68db930b7285a3ca3007bae8464343ac79a0ea" translate="yes" xml:space="preserve">
          <source>If the attempt to delete the file fails (for example, it doesn&amp;rsquo;t exist), the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) will be set to 128; on successful completion it will be set to 0.</source>
          <target state="translated">파일을 삭제하는 시도가 (예를 들어, 존재하지 않는) 실패하면 &lt;code&gt;RETURN-CODE&lt;/code&gt; 의 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터를&lt;/a&gt; 128로 설정됩니다) 성공적으로 완료되면 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="6d499ade6d8bd513045d21fd97b496bc7d59e814" translate="yes" xml:space="preserve">
          <source>If the attempt to move the file fails (for example, it doesn&amp;rsquo;t exist), the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) will be set to 128; on successful completion it will be set to 0.</source>
          <target state="translated">파일을 이동하는 시도가 (예를 들어, 존재하지 않는) 실패하면 &lt;code&gt;RETURN-CODE&lt;/code&gt; 의 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터를&lt;/a&gt; 128로 설정됩니다) 성공적으로 완료되면 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9cc49a6a7bfb3aab04847a284111d2050a7803d8" translate="yes" xml:space="preserve">
          <source>If the binary item occupies four bytes of storage, the binary item is allocated at the next word boundary.</source>
          <target state="translated">이진 항목이 4 바이트의 스토리지를 차지하는 경우 이진 항목은 다음 단어 경계에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="c9eb3b2ff78316af9e06d9ecdca03186e9054272" translate="yes" xml:space="preserve">
          <source>If the binary item occupies one byte of storage, no synchronization is performed.</source>
          <target state="translated">이진 항목이 1 바이트의 저장소를 차지하면 동기화가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="29ee50f202c57db2b363fa927e6f5d81d5d2accb" translate="yes" xml:space="preserve">
          <source>If the binary item occupies two bytes of storage, the binary item is allocated at the next half-word boundary.</source>
          <target state="translated">이진 항목이 2 바이트의 스토리지를 차지하면 이진 항목은 다음 반 단어 경계에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="78d1c026459ef474eb28e2011cf978cfda3d3820" translate="yes" xml:space="preserve">
          <source>If the calling program included a&lt;code&gt;RETURNING&lt;/code&gt;clause on the&lt;code&gt;CALL&lt;/code&gt;statement that invoked the subprogram, the value of the&lt;code&gt;RETURNING&lt;/code&gt;data item in the subroutine is moved to that data item. If there was no&lt;code&gt;RETURNING&lt;/code&gt;specified in the subroutine, the value of the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register is moved to that data item.</source>
          <target state="translated">호출 프로그램 이 서브 프로그램을 호출 한 &lt;code&gt;CALL&lt;/code&gt; 문 에 &lt;code&gt;RETURNING&lt;/code&gt; 절을 포함 하면 서브 루틴 의 &lt;code&gt;RETURNING&lt;/code&gt; 데이터 항목 값이 해당 데이터 항목으로 이동됩니다. 서브 루틴에 &lt;code&gt;RETURNING&lt;/code&gt; 이 지정 되지 않은 경우 &lt;code&gt;RETURN-CODE&lt;/code&gt; 특수 레지스터 의 값이 해당 데이터 항목으로 이동됩니다.</target>
        </trans-unit>
        <trans-unit id="237f820b1887571d0c11ce781473f803467fad98" translate="yes" xml:space="preserve">
          <source>If the compiler &quot;config&quot; file (see &lt;a href=&quot;#Compiler-Configuration-Files&quot;&gt;Compiler Configuration Files&lt;/a&gt;) you used to compile the program specified &quot;mf&quot; as the &quot;assign-clause&quot; value, then the File Locator String will be interpreted according to Microfocus COBOL rules &amp;mdash; namely, everything before the last &quot;-&quot; in the File Locator String will be ignored; the characters after the last &quot;-&quot; will be treated as the base of an environment variable name. If there is no &quot;-&quot; character in the File Locator String then the entire File Locator String will serve as the base of an environment variable name. This is the default behaviour for every config file except &quot;ibm&quot;.</source>
          <target state="translated">컴파일러 &quot;config&quot;파일 ( &lt;a href=&quot;#Compiler-Configuration-Files&quot;&gt;컴파일러 구성 파일&lt;/a&gt; 참조 )을 &quot;assign-clause&quot;값으로 &quot;mf&quot;로 지정한 프로그램을 컴파일하는 데 사용한 경우 파일 로케이터 문자열은 Microfocus COBOL 규칙에 따라 해석됩니다. File Locator String의 마지막 &quot;-&quot;는 무시됩니다. 마지막 &quot;-&quot;뒤의 문자는 환경 변수 이름의 기본으로 취급됩니다. 파일 로케이터 문자열에 &quot;-&quot;문자가 없으면 전체 파일 로케이터 문자열이 환경 변수 이름의 기본으로 사용됩니다. &quot;ibm&quot;을 제외한 모든 구성 파일의 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="be7c428b2bd6fcf64ba18d7fc20a33ae78ee6418" translate="yes" xml:space="preserve">
          <source>If the compiler &quot;config&quot; file you are using has &quot;relaxed-syntax-check&quot; set to &quot;yes&quot;, the&lt;code&gt;FILE-CONTROL&lt;/code&gt;and&lt;code&gt;I-O-CONTROL&lt;/code&gt;paragraphs may be specified without the&lt;code&gt;INPUT-OUTPUT SECTION.&lt;/code&gt;header having been coded.</source>
          <target state="translated">사용중인 컴파일러 &quot;config&quot;파일에 &quot;relaxed-syntax-check&quot;가 &quot;yes&quot;로 설정되어 있으면 &lt;code&gt;INPUT-OUTPUT SECTION.&lt;/code&gt; 없이 &lt;code&gt;FILE-CONTROL&lt;/code&gt; 및 &lt;code&gt;I-O-CONTROL&lt;/code&gt; 단락을 지정할 수 있습니다 . 헤더가 코딩되었습니다.</target>
        </trans-unit>
        <trans-unit id="fe92b0755173ad538d05379125cea0810a360175" translate="yes" xml:space="preserve">
          <source>If the compiler &quot;config&quot; file you used to compile the program with had a &quot;filename-mapping&quot; value of &quot;yes&quot;, the GnuCOBOL runtime system will first attempt to identify a currently-defined environment variable whose value will serve as the data file&amp;rsquo;s path and filename, as follows:</source>
          <target state="translated">프로그램을 컴파일하는 데 사용한 컴파일러 &quot;config&quot;파일의 &quot;filename-mapping&quot;값이 &quot;yes&quot;인 경우 GnuCOBOL 런타임 시스템은 먼저 값이 데이터 파일의 역할을하는 현재 정의 된 환경 변수를 식별하려고 시도합니다 다음과 같이 경로 및 파일 이름 :</target>
        </trans-unit>
        <trans-unit id="ada8d4fd5949881c69e3976ea553cf9ce6a69ad2" translate="yes" xml:space="preserve">
          <source>If the compiler is already in the specified mode, this statement will have no effect.</source>
          <target state="translated">컴파일러가 이미 지정된 모드에있는 경우이 명령문은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e079882ba26c2f94b1fe1a9df7387534f553e034" translate="yes" xml:space="preserve">
          <source>If the condition associated with a variable is false, the variable is not defined during compilations.</source>
          <target state="translated">변수와 연관된 조건이 false 인 경우 컴파일 중에 변수가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a326fe6a76a0eaf9c6262d498515fe5ffc5ef03" translate="yes" xml:space="preserve">
          <source>If the condition-name has a value of TRUE, the group will be presented.</source>
          <target state="translated">condition-name의 값이 TRUE이면 그룹이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8c023cec5138da702e62deee764a0698dddd5f75" translate="yes" xml:space="preserve">
          <source>If the counter has a value greater than zero, the statement(s) within the&lt;code&gt;PERFORM&lt;/code&gt;scope will be executed, after which the counter will be decremented by 1 with each repetition. Once that counter reaches zero, repetition will cease and control will fall into the next statement following the&lt;code&gt;PERFORM&lt;/code&gt;</source>
          <target state="translated">카운터의 값이 0보다 크면 &lt;code&gt;PERFORM&lt;/code&gt; 범위 내의 문 이 실행 된 후 각 반복마다 카운터가 1 씩 감소합니다. 해당 카운터가 0에 도달하면 반복이 중단되고 &lt;code&gt;PERFORM&lt;/code&gt; 다음에 나오는 다음 명령문에 제어가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="139a2f116480a978d8a516ae3f69011cef95b11e" translate="yes" xml:space="preserve">
          <source>If the data item in which the&lt;code&gt;SUM&lt;/code&gt;clause appears has been assigned it&amp;rsquo;s own identifier name, and that name is not&lt;code&gt;FILLER&lt;/code&gt; then that data item is referred to as a sum counter.</source>
          <target state="translated">&lt;code&gt;SUM&lt;/code&gt; 절이 나타나는 데이터 항목에 고유 식별자 이름이 할당되고 해당 이름이 &lt;code&gt;FILLER&lt;/code&gt; 가 아닌 경우 해당 데이터 항목을 합계 카운터라고합니다.</target>
        </trans-unit>
        <trans-unit id="d6641aac6877a23c3a650b80aa0141134bfbab68" translate="yes" xml:space="preserve">
          <source>If the date is valid, a 0 value is returned. If it isn&amp;rsquo;t, a value of 1 or 2 is returned signalling the problem lies with the year or day, respectively.</source>
          <target state="translated">날짜가 유효하면 0 값이 리턴됩니다. 그렇지 않은 경우 1 또는 2의 값이 반환되어 문제가 각각 년 또는 일에 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7b011773af10dd8c1b119874aa6b6d6a7bdffaf9" translate="yes" xml:space="preserve">
          <source>If the file defined by the &amp;lt;</source>
          <target state="translated">파일이 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="8308b61ce7bcbfc94d926cc1722564983504a579" translate="yes" xml:space="preserve">
          <source>If the file has&lt;code&gt;ACCESS MODE SEQUENTIAL&lt;/code&gt; the record to be rewritten will be the one retrieved by the most-recently executed&lt;code&gt;READ&lt;/code&gt;of the file. If the file has&lt;code&gt;ACCESS MODE RANDOM&lt;/code&gt;or&lt;code&gt;ACCESS MODE DYNAMIC&lt;/code&gt; no&lt;code&gt;READ&lt;/code&gt;is required before a record may be rewritten &amp;mdash; the&lt;code&gt;RELATIVE KEY&lt;/code&gt;or&lt;code&gt;RECORD KEY&lt;/code&gt;definition for the file, respectively, will specify the record to be updated.</source>
          <target state="translated">파일에 &lt;code&gt;ACCESS MODE SEQUENTIAL&lt;/code&gt; 이 있는 경우, 재기록 할 레코드는 가장 최근에 실행 된 파일의 &lt;code&gt;READ&lt;/code&gt; 에 의해 검색된 레코드 입니다. 파일에 &lt;code&gt;ACCESS MODE RANDOM&lt;/code&gt; 또는 &lt;code&gt;ACCESS MODE DYNAMIC&lt;/code&gt; 이있는 경우 레코드를 다시 쓰기 전에 &lt;code&gt;READ&lt;/code&gt; 가 필요 하지 않습니다 . 파일에 대한 &lt;code&gt;RELATIVE KEY&lt;/code&gt; 또는 &lt;code&gt;RECORD KEY&lt;/code&gt; 정의는 각각 업데이트 할 레코드를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="979f0a1fc8e50fd115ef1c5a2607d25c8a146e66" translate="yes" xml:space="preserve">
          <source>If the file has&lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;ORGANIZATION RELATIVE&lt;/a&gt;) or&lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;):</source>
          <target state="translated">파일이있는 경우 &lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt; (참조 &lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;조직 RELATIVE&lt;/a&gt; 또는) &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; (참조 &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;조직 색인을&lt;/a&gt; ) :</target>
        </trans-unit>
        <trans-unit id="a1d7d6e295ed262b048e40c65c57cc69c1a22916" translate="yes" xml:space="preserve">
          <source>If the file has&lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt;):</source>
          <target state="translated">파일에 &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; 이있는 경우 ( &lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt; 참조 ) :</target>
        </trans-unit>
        <trans-unit id="e57bb4b94ad8d138b6e068547fa0dd3393b0fc4d" translate="yes" xml:space="preserve">
          <source>If the file&amp;rsquo;s&lt;code&gt;SELECT&lt;/code&gt;contains a&lt;code&gt;LOCK MODE IS AUTOMATIC&lt;/code&gt;</source>
          <target state="translated">파일의 &lt;code&gt;SELECT&lt;/code&gt; 에 &lt;code&gt;LOCK MODE IS AUTOMATIC&lt;/code&gt; 이 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="b0edb822a1ecdc41221997c63041ba9a3c222689" translate="yes" xml:space="preserve">
          <source>If the file&amp;rsquo;s&lt;code&gt;SELECT&lt;/code&gt;contains a&lt;code&gt;LOCK MODE IS MANUAL&lt;/code&gt;</source>
          <target state="translated">파일의 &lt;code&gt;SELECT&lt;/code&gt; 에 &lt;code&gt;LOCK MODE IS MANUAL&lt;/code&gt; 이 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="9ac3ef7c53e5a1a9ebd82e6132c731fb366bb269" translate="yes" xml:space="preserve">
          <source>If the function issues a&lt;code&gt;STOP&lt;/code&gt;statement (see &lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt;) with the&lt;code&gt;RUN&lt;/code&gt;option, program execution ceases and control returns to the operating system or whatever execution shell invoked the main program.</source>
          <target state="translated">함수 가 &lt;code&gt;RUN&lt;/code&gt; 옵션 과 함께 &lt;code&gt;STOP&lt;/code&gt; 문 ( &lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt; 참조 )을 발행하면 프로그램 실행이 중지되고 운영 체제 또는 기본 프로그램을 호출 한 실행 쉘로 제어가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="768fc6ac0826962232769e54ee3d27933dbe814a" translate="yes" xml:space="preserve">
          <source>If the function wishes to return control back to the calling program, it will do so using either the&lt;code&gt;GOBACK&lt;/code&gt;statement (see &lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt;) or the&lt;code&gt;EXIT FUNCTION&lt;/code&gt;statement (see &lt;a href=&quot;#EXIT&quot;&gt;EXIT&lt;/a&gt;). At this time:</source>
          <target state="translated">함수가 호출 프로그램으로 제어 등을 반환하고자 할 경우에는 하나 사용하여 그렇게 할 것입니다 &lt;code&gt;GOBACK&lt;/code&gt; 문 (참조 &lt;a href=&quot;#GOBACK&quot;&gt;하고 GoBack을&lt;/a&gt; ) 또는 &lt;code&gt;EXIT FUNCTION&lt;/code&gt; 문을합니다 ( &lt;a href=&quot;#EXIT&quot;&gt;EXIT를&lt;/a&gt; ). 현재 :</target>
        </trans-unit>
        <trans-unit id="30455ee292f12916879ea7b27b16596593857296" translate="yes" xml:space="preserve">
          <source>If the item is alphanumeric edited, then the size is set to the number of &quot;A&quot; or &quot;X&quot; positions specified in its PICTURE clause.</source>
          <target state="translated">항목을 영숫자 편집하면 크기는 PICTURE 절에 지정된 &quot;A&quot;또는 &quot;X&quot;위치 수로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="5a3ac59ecad83c4e62bbb64e4efcc1980153a8fd" translate="yes" xml:space="preserve">
          <source>If the item is numeric or numeric edited, then the size is the number of digits in the item, plus one if it is not an integer, plus one if it is signed.</source>
          <target state="translated">항목이 숫자 또는 편집 된 항목 인 경우 크기는 항목의 자릿수와 정수가 아닌 경우 1을 더한 값, 부호가있는 경우 1을 더한 값입니다.</target>
        </trans-unit>
        <trans-unit id="0bf6190961c1d912062042b050c89a336fba6e4f" translate="yes" xml:space="preserve">
          <source>If the key(s) and value(s) match, &amp;lt;</source>
          <target state="translated">키와 값이 일치하면 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="8718b549db26737624f77d41114ec5bbc3bc5cfc" translate="yes" xml:space="preserve">
          <source>If the key(s) are GREATER THAN the value(s), then the table entry being searched for can only occur in the &quot;first&quot; to &quot;current&quot; range of the table, so a new &quot;last&quot; pointer value is set (it will be set to the &quot;current&quot; pointer).</source>
          <target state="translated">키가 값보다 크면 검색되는 테이블 항목이 테이블의 &quot;첫 번째&quot;에서 &quot;현재&quot;범위에서만 발생할 수 있으므로 새로운 &quot;마지막&quot;포인터 값이 설정됩니다 ( &quot;현재&quot;포인터로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f855f7c7ead100cd07565ea01cc7a9230a155db1" translate="yes" xml:space="preserve">
          <source>If the key(s) are LESS THAN the value(s), then the table entry being searched for can only occur in the &quot;current&quot; to &quot;last&quot; range of the table, so a new &quot;first&quot; pointer value is set (it will be set to the &quot;current&quot; pointer).</source>
          <target state="translated">키가 값보다 적은 경우, 검색중인 테이블 항목은 테이블의 &quot;현재&quot;에서 &quot;마지막&quot;범위에서만 발생할 수 있으므로 새로운 &quot;첫 번째&quot;포인터 값이 설정됩니다 ( &quot;현재&quot;포인터로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="75791070ef3413617c60c665e733867b07b700c6" translate="yes" xml:space="preserve">
          <source>If the length of &amp;lt;</source>
          <target state="translated">길이가 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="f678ec7b4d2b5c8286ebadce4169b6ec51506464" translate="yes" xml:space="preserve">
          <source>If the length of the &quot;from&quot; string</source>
          <target state="translated">&quot;from&quot;문자열의 길이가</target>
        </trans-unit>
        <trans-unit id="163af06aed58d0ce62be6ce917a711c8bc398a55" translate="yes" xml:space="preserve">
          <source>If the new &quot;first&quot; and &quot;last&quot; pointers are different than the old &quot;first&quot; and &quot;last&quot; pointers, there&amp;rsquo;s more left to be searched, so return to step (A) and continue.</source>
          <target state="translated">새로운 &quot;첫번째&quot;및 &quot;마지막&quot;포인터가 이전의 &quot;첫번째&quot;및 &quot;마지막&quot;포인터와 다른 경우, 더 검색 할 것이 남아 있으므로 단계 (A)로 돌아가서 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="20cd460d91c2dd82c32020553b0991e55b5ca84b" translate="yes" xml:space="preserve">
          <source>If the new &quot;first&quot; and &quot;last&quot; pointers are the same as the old &quot;first&quot; and &quot;last&quot; pointers, the table has been exhausted and the entry being searched for cannot be found; &amp;lt;</source>
          <target state="translated">새로운 &quot;첫번째&quot;및 &quot;마지막&quot;포인터가 이전의 &quot;첫번째&quot;및 &quot;마지막&quot;포인터와 동일하면 테이블이 소진되어 검색중인 항목을 찾을 수 없습니다. &amp;lt;</target>
        </trans-unit>
        <trans-unit id="99b9a44588304e8fd897153b6442bc44498ed178" translate="yes" xml:space="preserve">
          <source>If the optional&lt;code&gt;ALL&lt;/code&gt;</source>
          <target state="translated">선택 사항 인 경우 &lt;code&gt;ALL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b7bdbfa412dd855282c99935345311e80faa35ff" translate="yes" xml:space="preserve">
          <source>If the optional&lt;code&gt;ELSE&lt;/code&gt;clause is present and conditional-expression evaluates to false, then (and only then) &amp;lt;</source>
          <target state="translated">선택적 &lt;code&gt;ELSE&lt;/code&gt; 절이 존재하고 조건식이 false로 평가되면 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="214f8446472e76c131789cea52e9df99ff6d7324" translate="yes" xml:space="preserve">
          <source>If the optional&lt;code&gt;WITH FILLER&lt;/code&gt;</source>
          <target state="translated">선택 품목 인 &lt;code&gt;WITH FILLER&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e0c98a1a847d99310eeb35f540d53fc5e523af7" translate="yes" xml:space="preserve">
          <source>If the program is compiled with the&lt;code&gt;-fsyntax-extension&lt;/code&gt;switch</source>
          <target state="translated">프로그램이 &lt;code&gt;-fsyntax-extension&lt;/code&gt; 스위치로 컴파일 된 경우</target>
        </trans-unit>
        <trans-unit id="3f250bad0b5b4ae9aea9503229c333bf1801f01f" translate="yes" xml:space="preserve">
          <source>If the replacement string is a multiple-item phrase or is to be deleted altogether, you must use the&lt;code&gt;==&amp;lt;&lt;i&gt;pseudo-text-2&lt;/i&gt;&amp;gt;==&lt;/code&gt;option. If&lt;code&gt;&amp;lt;&lt;i&gt;pseudo-text-2&lt;/i&gt;&amp;gt;&lt;/code&gt;is null (in other words, the replacement text is specified as&lt;code&gt;====&lt;/code&gt;, all encountered occurrences of the search string will be deleted.</source>
          <target state="translated">대체 문자열이 여러 항목 문구이거나 모두 삭제되는 경우 &lt;code&gt;==&amp;lt;&lt;i&gt;pseudo-text-2&lt;/i&gt;&amp;gt;==&lt;/code&gt; 옵션을 사용해야합니다 . 경우 &lt;code&gt;&amp;lt;&lt;i&gt;pseudo-text-2&lt;/i&gt;&amp;gt;&lt;/code&gt; 즉, 대체 텍스트는 다음과 같이 지정됩니다 (null 인 &lt;code&gt;====&lt;/code&gt; , 검색 문자열의 모든 발생 사건이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="b864101b1cf94817be38b70b043aacccfa75cd6e" translate="yes" xml:space="preserve">
          <source>If the routine is successful, a value of 0 will be returned to the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;). If the routine failed because of a problem with an argument (such as a negative or 0 length), a value of 128 will result. Finally, if the 1st argument value is anything but zero, the routine will fail with a 129 value.</source>
          <target state="translated">루틴이 성공하면 0의 값이 반환됩니다 &lt;code&gt;RETURN-CODE&lt;/code&gt; 의 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터&lt;/a&gt; ). 인수에 문제 (예 : 음수 또는 0 길이)로 인해 루틴이 실패한 경우 값 128이 발생합니다. 마지막으로, 첫 번째 인수 값이 0이 아닌 경우 루틴은 129 값으로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="5a1b44b26b84f05f8af22b9e038aef3fc238f233" translate="yes" xml:space="preserve">
          <source>If the search index now has a value greater than the number of entries in the table, the search is considered to have failed and the &amp;lt;</source>
          <target state="translated">검색 색인의 값이 테이블의 항목 수보다 큰 경우 검색이 실패한 것으로 간주되고 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="94565d23be2bb0fc7d85c959aef69eff52cd9069" translate="yes" xml:space="preserve">
          <source>If the search index now has a value less than or equal to the number of entries in the table, search processing returns back to step (A).</source>
          <target state="translated">검색 색인이 이제 테이블의 항목 수보다 작거나 같은 값을 갖는 경우 검색 처리는 단계 (A)로 되돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="63b646dd35f2ad5b466ac70be0367ce3e11e5b92" translate="yes" xml:space="preserve">
          <source>If the specified argument does not exist, or an invalid argument number is specified, a value of 0 is returned.</source>
          <target state="translated">지정된 인수가 존재하지 않거나 유효하지 않은 인수 번호가 지정되면 값 0이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="a1c8f712007564d99604775da06766bbac9f03bb" translate="yes" xml:space="preserve">
          <source>If the specified condition-name has a value of FALSE when a&lt;code&gt;GENERATE&lt;/code&gt;statement (see &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;) causes a report group to be presented, the presentation of that group will be suppressed.</source>
          <target state="translated">&lt;code&gt;GENERATE&lt;/code&gt; 문 ( &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt; 참조 )으로 인해 보고서 그룹이 표시 될 때 지정된 condition-name 값이 FALSE 인 경우 해당 그룹의 표시가 억제됩니다.</target>
        </trans-unit>
        <trans-unit id="66774ceedbe10981e42302c55639170b0ed0f28a" translate="yes" xml:space="preserve">
          <source>If the structure contains the following grid of characters:</source>
          <target state="translated">구조에 다음 문자 그리드가 포함 된 경우 :</target>
        </trans-unit>
        <trans-unit id="5be0ca5096c1af0f623320b98f1b64f052b51144" translate="yes" xml:space="preserve">
          <source>If the subprogram being called is a GnuCOBOL program, and if that program had the&lt;code&gt;INITIAL&lt;/code&gt;(see &lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;IDENTIFICATION DIVISION&lt;/a&gt;) attribute specified on its&lt;code&gt;PROGRAM-ID&lt;/code&gt;clause, all of the subprogram&amp;rsquo;s data division data will be restored to its initial state each time the subprogram is executed, regardless of which entry-point within the subprogram is being referenced.</source>
          <target state="translated">호출되는 서브 프로그램이 GnuCOBOL 프로그램이고 해당 &lt;code&gt;PROGRAM-ID&lt;/code&gt; 절 에 지정된 &lt;code&gt;INITIAL&lt;/code&gt; ( &lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;IDENTIFICATION DIVISION&lt;/a&gt; 참조 ) 속성 이 있으면 서브 프로그램이 호출 될 때마다 서브 프로그램의 모든 데이터 분할 데이터가 초기 상태로 복원됩니다. 서브 프로그램 내에서 시작점에 관계없이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1ad68b7c421e5be7cfd3f061b145123e5b308674" translate="yes" xml:space="preserve">
          <source>If the subprogram issues a&lt;code&gt;STOP&lt;/code&gt;statement (see &lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt;) with the&lt;code&gt;RUN&lt;/code&gt;option, program execution ceases and control returns to the operating system or whatever execution shell invoked the main program.</source>
          <target state="translated">서브 프로그램 이 &lt;code&gt;RUN&lt;/code&gt; 옵션 과 함께 &lt;code&gt;STOP&lt;/code&gt; 문 ( &lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt; 참조 )을 발행하면 프로그램 실행이 중단되고 운영 체제 또는 기본 프로그램을 호출 한 실행 쉘로 제어가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="3fddc95876d626c2ec7bbbe309cf154f2991a624" translate="yes" xml:space="preserve">
          <source>If the subprogram returns a value, the data item in which the value is returned must also be defined in the subprogram&amp;rsquo;s linkage section, with a&lt;code&gt;USAGE&lt;/code&gt;(see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) of&lt;code&gt;BINARY-LONG SIGNED&lt;/code&gt; or it&amp;rsquo;s equivalent.</source>
          <target state="translated">서브 프로그램이 값을 리턴하면 값이 리턴되는 데이터 항목도 서브 프로그램의 링크 섹션에 정의되어야하며 &lt;code&gt;USAGE&lt;/code&gt; ( &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt; 참조 )가 &lt;code&gt;BINARY-LONG SIGNED&lt;/code&gt; 또는 이와 동등한 값이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="3977b529e0e7ac10b11afc507f2c9eb5bfc68f03" translate="yes" xml:space="preserve">
          <source>If the subprogram wishes to return control back to the calling program, it will do so using either the&lt;code&gt;GOBACK&lt;/code&gt;statement (see &lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt;) or the&lt;code&gt;EXIT PROGRAM&lt;/code&gt;statement (see &lt;a href=&quot;#EXIT&quot;&gt;EXIT&lt;/a&gt;). At this time:</source>
          <target state="translated">서브 프로그램이 호출 프로그램으로 제어 등을 반환하고자 할 경우에는 하나 사용하여 그렇게 할 것입니다 &lt;code&gt;GOBACK&lt;/code&gt; 문 (참조 &lt;a href=&quot;#GOBACK&quot;&gt;하고 GoBack을&lt;/a&gt; ) 또는 &lt;code&gt;EXIT PROGRAM&lt;/code&gt; 문을합니다 ( &lt;a href=&quot;#EXIT&quot;&gt;EXIT를&lt;/a&gt; ). 현재 :</target>
        </trans-unit>
        <trans-unit id="fb4435d664648be40b4a8cc4319cd6f4b4970f02" translate="yes" xml:space="preserve">
          <source>If the subprograms procedure division header or&lt;code&gt;ENTRY&lt;/code&gt;statement included a&lt;code&gt;RETURNING&lt;/code&gt; (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;); this behaviour can be altered utilizing the&lt;code&gt;CALL-CONVENTION&lt;/code&gt;(see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) feature to leave&lt;code&gt;RETURN-CODE&lt;/code&gt;unchanged.</source>
          <target state="translated">서브 프로그램 프로 시저 분할 헤더 또는 &lt;code&gt;ENTRY&lt;/code&gt; 문에 &lt;code&gt;RETURNING&lt;/code&gt; 이 포함 된 경우 ( &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터&lt;/a&gt; 참조 ); 이 동작은 &lt;code&gt;CALL-CONVENTION&lt;/code&gt; ( &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt; 참조 ) 기능을 사용하여 변경하여 &lt;code&gt;RETURN-CODE&lt;/code&gt; 를 변경하지 않고 그대로 둘 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fca4d357c4da52ecdfe09ff7f3b59313032d58e" translate="yes" xml:space="preserve">
          <source>If the subroutine is successful, a value of 0 will be returned in the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;). Failure to retrieve the needed statistics on the file will cause a&lt;code&gt;RETURN-CODE&lt;/code&gt;special register value of 35 to be passed back. Supplying less than two arguments will generate a 128&lt;code&gt;RETURN-CODE&lt;/code&gt;special register value.</source>
          <target state="translated">서브 루틴이 성공하면 0의 값이 반환됩니다 &lt;code&gt;RETURN-CODE&lt;/code&gt; 의 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터&lt;/a&gt; ). 파일에서 필요한 통계를 검색하지 못하면 &lt;code&gt;RETURN-CODE&lt;/code&gt; 특수 레지스터 값 35가 다시 전달됩니다. 두 개 미만의 인수를 제공하면 128 &lt;code&gt;RETURN-CODE&lt;/code&gt; 특수 레지스터 값 이 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="2e2d3e910dfeb525715cdc365898fd54399a43c4" translate="yes" xml:space="preserve">
          <source>If the subroutine is successful, a value of 0 will be returned in the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;). Failure will cause a&lt;code&gt;RETURN-CODE&lt;/code&gt;special register value of -1 to be passed back.</source>
          <target state="translated">서브 루틴이 성공하면 0의 값이 반환됩니다 &lt;code&gt;RETURN-CODE&lt;/code&gt; 의 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터&lt;/a&gt; ). 실패하면 &lt;code&gt;RETURN-CODE&lt;/code&gt; 특수 레지스터 값 -1이 다시 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="d1bb984fa6207ca92b69374fdf44a4d8170a10b1" translate="yes" xml:space="preserve">
          <source>If the value being stored into the field is the same length as the receiving field, the presence or absence of the&lt;code&gt;JUSTIFIED RIGHT&lt;/code&gt;clause on that field&amp;rsquo;s description is irrelevant.</source>
          <target state="translated">필드에 저장되는 값이 수신 필드와 동일한 길이 인 경우 해당 필드 설명에 &lt;code&gt;JUSTIFIED RIGHT&lt;/code&gt; 절의 존재 여부 는 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e5b69bef404018740f53a3d7738badc9ff4e4531" translate="yes" xml:space="preserve">
          <source>If the value of &amp;lt;</source>
          <target state="translated">&amp;lt;의 값이</target>
        </trans-unit>
        <trans-unit id="a8941ef78769624061ef92939b2c773736817ccd" translate="yes" xml:space="preserve">
          <source>If the value of the numeric value moved into the field is positive (0 or greater), a &quot;+&quot; character will be inserted. If the value is negative (less than 0), a &quot;-&quot; character is inserted.</source>
          <target state="translated">필드로 이동 한 숫자 값이 양수 (0 이상)이면 &quot;+&quot;문자가 삽입됩니다. 값이 음수 (0 미만)이면 &quot;-&quot;문자가 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="fa45922afd3a1788e3ef11576266d429b5817fba" translate="yes" xml:space="preserve">
          <source>If the value of the numeric value moved into the field is positive (0 or greater), a space will be inserted. If the value is negative (less than 0), a &quot;-&quot; character is inserted.</source>
          <target state="translated">필드로 이동 한 숫자 값이 양수 (0 이상)이면 공백이 삽입됩니다. 값이 음수 (0 미만)이면 &quot;-&quot;문자가 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="48dd00b4185648ad98a04dd28fc9dd3c41fb5dc5" translate="yes" xml:space="preserve">
          <source>If the value specified for the &amp;lt;</source>
          <target state="translated">&amp;lt;에 지정된 값이</target>
        </trans-unit>
        <trans-unit id="0831d72b5b85932627f6976dfb6259ade2e7b74e" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;-fintrinsics=WHEN-COMPILED&lt;/code&gt;switch or&lt;code&gt;-fintrinsics=ALL&lt;/code&gt;switch is specified to the compiler or the&lt;code&gt;REPOSITORY&lt;/code&gt;(see &lt;a href=&quot;#REPOSITORY&quot;&gt;REPOSITORY&lt;/a&gt;) paragraph specifies either&lt;code&gt;FUNCTION WHEN-COMPILED INTRINSIC&lt;/code&gt;or&lt;code&gt;FUNCTION ALL INTRINSIC&lt;/code&gt; then references to&lt;code&gt;WHEN-COMPILED&lt;/code&gt;(without a leading&lt;code&gt;FUNCTION&lt;/code&gt;keyword will always reference this intrinsic function and there will be no way to access the&lt;code&gt;WHEN-COMPILED&lt;/code&gt;special register.</source>
          <target state="translated">경우] &lt;code&gt;-fintrinsics=WHEN-COMPILED&lt;/code&gt; 또는 스위치 &lt;code&gt;-fintrinsics=ALL&lt;/code&gt; 스위치 컴파일러 또는로한다 &lt;code&gt;REPOSITORY&lt;/code&gt; (참조 &lt;a href=&quot;#REPOSITORY&quot;&gt;저장소&lt;/a&gt; ) 단락 지정하거나 &lt;code&gt;FUNCTION WHEN-COMPILED INTRINSIC&lt;/code&gt; 또는 &lt;code&gt;FUNCTION ALL INTRINSIC&lt;/code&gt; 으로 다음의 참조 &lt;code&gt;WHEN-COMPILED&lt;/code&gt; (a 선도없이 &lt;code&gt;FUNCTION&lt;/code&gt; 키워드는 항상이 내장 함수를 참조하며 &lt;code&gt;WHEN-COMPILED&lt;/code&gt; 특수 레지스터 에 액세스 할 방법이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="3b420486302df3f6e207a4313dfd931a759d89b7" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;-ftrace&lt;/code&gt;switch</source>
          <target state="translated">경우] &lt;code&gt;-ftrace&lt;/code&gt; 의 스위치</target>
        </trans-unit>
        <trans-unit id="3349b7269aaccc8bb1cc998766e4a46beb55bde2" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;ACCESS MODE&lt;/code&gt;of &amp;lt;</source>
          <target state="translated">경우] &lt;code&gt;ACCESS MODE&lt;/code&gt; 의 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="2e5d9e90a43cf87c9978ea30182b2bcd04cc6c52" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;ADDRESS OF&lt;/code&gt;clause is absent after the&lt;code&gt;TO&lt;/code&gt; the contents of &amp;lt;</source>
          <target state="translated">&lt;code&gt;TO&lt;/code&gt; 다음에 &lt;code&gt;ADDRESS OF&lt;/code&gt; 절이없는 경우 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="26199d3754ff366a5846d65d208ee2e6de9686ad" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;ALL&lt;/code&gt;keyword was specified on the&lt;code&gt;VALUE&lt;/code&gt;clause, all members of the field list with&lt;code&gt;VALUE&lt;/code&gt;clauses will qualify.</source>
          <target state="translated">는 IF &lt;code&gt;ALL&lt;/code&gt; 의 키워드가에 지정된 &lt;code&gt;VALUE&lt;/code&gt; 의 절과 필드 목록의 모든 구성원 &lt;code&gt;VALUE&lt;/code&gt; 의 조항은 자격이됩니다.</target>
        </trans-unit>
        <trans-unit id="df5d251bac8a9bff6db280d0993ff1dbfac8f41c" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;CONSTANT&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;CONSTANT&lt;/code&gt; 경우</target>
        </trans-unit>
        <trans-unit id="0c81429e41c0cb12a035faac7aa149969b981744" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;CRT STATUS&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;CRT STATUS&lt;/code&gt; 경우</target>
        </trans-unit>
        <trans-unit id="bdf79d6d2d1dddc9f4d79dc6b3151fcff14428de" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;FD&lt;/code&gt;of the file contains the&lt;code&gt;RECORD CONTAINS&lt;/code&gt;or&lt;code&gt;RECORD IS VARYING&lt;/code&gt;clause, and that clause allows the record size to vary, the size</source>
          <target state="translated">파일 의 &lt;code&gt;FD&lt;/code&gt; 에 &lt;code&gt;RECORD CONTAINS&lt;/code&gt; 또는 &lt;code&gt;RECORD IS VARYING&lt;/code&gt; 절이 포함되어 있고 해당 절에서 레코드 크기를 변경할 수있는 경우</target>
        </trans-unit>
        <trans-unit id="7cd7e97ca9d4f2995a04bb967f17ad631843750e" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;FD&lt;/code&gt;of the file contains the&lt;code&gt;RECORD CONTAINS&lt;/code&gt;or&lt;code&gt;RECORD IS VARYING&lt;/code&gt;clause, and that clause allows the record size to vary, the size of &amp;lt;</source>
          <target state="translated">파일 의 &lt;code&gt;FD&lt;/code&gt; 에 &lt;code&gt;RECORD CONTAINS&lt;/code&gt; 또는 &lt;code&gt;RECORD IS VARYING&lt;/code&gt; 절이 포함되어 있고 해당 절에서 레코드 크기를 변경할 수있는 경우 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="8342745452a46e82129819210173c072a362af42" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;LINAGE&lt;/code&gt;(see &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File/Sort-Description&lt;/a&gt;) clause is</source>
          <target state="translated">만약 &lt;code&gt;LINAGE&lt;/code&gt; (참조 &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;파일 / 정렬-설명&lt;/a&gt; ) 절은</target>
        </trans-unit>
        <trans-unit id="67faed20b65d381e0f35f57376ea02fccee28463" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;LOCK ON&lt;/code&gt;</source>
          <target state="translated">경우] &lt;code&gt;LOCK ON&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9a4cf245f7ab4d128cf1a215befd46fe8ca30464" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;LOCK ON&lt;/code&gt;clause</source>
          <target state="translated">경우] &lt;code&gt;LOCK ON&lt;/code&gt; 의 절</target>
        </trans-unit>
        <trans-unit id="5348e096005262a0ab82c3168003e7e7371e7dae" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;PERFORM&lt;/code&gt;specifies or implies&lt;code&gt;WITH TEST BEFORE&lt;/code&gt; &amp;lt;</source>
          <target state="translated">&lt;code&gt;PERFORM&lt;/code&gt; 이 &lt;code&gt;WITH TEST BEFORE&lt;/code&gt; &amp;lt;을 지정하거나 암시 하는 경우 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="dd5a2104ff28017a6be9e284824ff9c6d67e6603" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;PROGRAM-ID&lt;/code&gt;(see &lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;IDENTIFICATION DIVISION&lt;/a&gt;) clause of the subprogram included the&lt;code&gt;INITIAL&lt;/code&gt;</source>
          <target state="translated">서브 프로그램 의 &lt;code&gt;PROGRAM-ID&lt;/code&gt; ( &lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;IDENTIFICATION DIVISION&lt;/a&gt; 참조 ) 절에 &lt;code&gt;INITIAL&lt;/code&gt; 이 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="68679aad3ae2e21817a3db3c1cd8a4c87162b63f" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;RD&lt;/code&gt;(see &lt;a href=&quot;#REPORT-SECTION&quot;&gt;REPORT SECTION&lt;/a&gt;) in which the report group containing a&lt;code&gt;NEXT GROUP&lt;/code&gt;clause does not contain a&lt;code&gt;PAGE LIMITS&lt;/code&gt;clause, only the&lt;code&gt;PLUS integer-1&lt;/code&gt;option may be specified.</source>
          <target state="translated">경우 &lt;code&gt;RD&lt;/code&gt; 는 (참조 &lt;a href=&quot;#REPORT-SECTION&quot;&gt;보고서 제&lt;/a&gt; 이 포함 된 보고서 그룹있는) &lt;code&gt;NEXT GROUP&lt;/code&gt; 의 조항이 포함되지 않은 &lt;code&gt;PAGE LIMITS&lt;/code&gt; 조항 만 &lt;code&gt;PLUS integer-1&lt;/code&gt; 옵션을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6326e274617c726298b0f2a259364a71ec08cb9a" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;REMAINDER&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;REMAINDER&lt;/code&gt; 인 경우</target>
        </trans-unit>
        <trans-unit id="d46ae7e0403a69183623c2c0c30c04ac183c02a4" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;RESET&lt;/code&gt;option is coded,&lt;code&gt;FINAL&lt;/code&gt;or &amp;lt;</source>
          <target state="translated">경우 &lt;code&gt;RESET&lt;/code&gt; 옵션을 코딩, &lt;code&gt;FINAL&lt;/code&gt; 또는 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="38a1fbfcc2ff5f0f55dba89a7b49d153d656d7e5" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;SELECT&lt;/code&gt;(see &lt;a href=&quot;#SELECT&quot;&gt;SELECT&lt;/a&gt;) statement or file&lt;code&gt;OPEN&lt;/code&gt;(see &lt;a href=&quot;#OPEN&quot;&gt;OPEN&lt;/a&gt;) specifies&lt;code&gt;SHARING WITH NO OTHER&lt;/code&gt; record locking will be disabled.</source>
          <target state="translated">만약 &lt;code&gt;SELECT&lt;/code&gt; (참조 &lt;a href=&quot;#SELECT&quot;&gt;SELECT를&lt;/a&gt; ) 문 또는 파일 &lt;code&gt;OPEN&lt;/code&gt; (참조 &lt;a href=&quot;#OPEN&quot;&gt;OPEN가&lt;/a&gt; ) 지정 &lt;code&gt;SHARING WITH NO OTHER&lt;/code&gt; 사용할 수있을 것입니다 레코드 잠금을.</target>
        </trans-unit>
        <trans-unit id="4469b431cec5ac5fa31a45bf59859b62ee522aee" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;SELECT&lt;/code&gt;of a file is coded with a&lt;code&gt;FILE STATUS&lt;/code&gt;clause,&lt;code&gt;OPEN&lt;/code&gt;failures &amp;mdash; including those induced by sharing failures &amp;mdash; will be detectable by the program and a graceful recovery (or at least a graceful termination) will be possible. If no such clause was coded, however, a runtime message will be issued and the program will be terminated.</source>
          <target state="translated">파일 의 &lt;code&gt;SELECT&lt;/code&gt; 가 &lt;code&gt;FILE STATUS&lt;/code&gt; 절로 코딩 된 경우, 공유 실패로 인한 오류를 포함하여 &lt;code&gt;OPEN&lt;/code&gt; 실패는 프로그램에 의해 감지 될 수 있으며 정상적인 복구 (또는 적어도 적절한 종료)가 가능합니다. 그러나 그러한 절이 코딩되지 않으면 런타임 메시지가 발행되고 프로그램이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="d43773d0d9856113d341b49d71c616d3ba81cd29" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;SEPARATE CHARACTER&lt;/code&gt;clause</source>
          <target state="translated">경우] &lt;code&gt;SEPARATE CHARACTER&lt;/code&gt; 절</target>
        </trans-unit>
        <trans-unit id="cc7da6fe4678bd908df6708f4cd87c152a905cc1" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;SYNCRONIZED&lt;/code&gt;clause is coded on anything but a numeric data item with a&lt;code&gt;USAGE&lt;/code&gt;(see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) that specifies storage of data in a binary form, the&lt;code&gt;SYNCRONIZED&lt;/code&gt;clause will be ignored.</source>
          <target state="translated">경우 &lt;code&gt;SYNCRONIZED&lt;/code&gt; 절은 아무것도하지만 숫자 데이터 항목에 코딩 &lt;code&gt;USAGE&lt;/code&gt; (참조 &lt;a href=&quot;#USAGE&quot;&gt;사용법을&lt;/a&gt; 바이너리 형태로 데이터의 지정 저장)에 &lt;code&gt;SYNCRONIZED&lt;/code&gt; 절은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3d2f7b6539018dd97bf4f7ebf6332805f3b4ccf8" translate="yes" xml:space="preserve">
          <source>If there are fewer tokens than there are arguments, the excess arguments will be initialized as if the&lt;code&gt;INITIALIZE &amp;lt;&lt;i&gt;identifier-1&lt;/i&gt;&amp;gt;&lt;/code&gt;(see &lt;a href=&quot;#INITIALIZE&quot;&gt;INITIALIZE&lt;/a&gt;) statement were executed.</source>
          <target state="translated">인수보다 토큰이 적 으면 초과 인수는 &lt;code&gt;INITIALIZE &amp;lt;&lt;i&gt;identifier-1&lt;/i&gt;&amp;gt;&lt;/code&gt; ( &lt;a href=&quot;#INITIALIZE&quot;&gt;INITIALIZE&lt;/a&gt; 참조 ) 명령문이 실행 된 것처럼 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="061529f2e81b4789d20b56f0ff94bb58b24306f6" translate="yes" xml:space="preserve">
          <source>If there are more tokens than there are arguments, the excess tokens will be discarded.</source>
          <target state="translated">인수보다 많은 토큰이 있으면 초과 토큰은 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="f2d936a65b86a2841ae9003e465d423ea6c6934c" translate="yes" xml:space="preserve">
          <source>If there are multiple cash registers in a particular department of a specific store, the data needs to be further sorted so that the cash registers are ordered in sequence of their register number.</source>
          <target state="translated">특정 상점의 특정 부서에 여러 개의 금전 등록 기가있는 경우, 금전 등록 기가 등록 번호 순서대로 정렬되도록 데이터를 추가로 정렬해야합니다.</target>
        </trans-unit>
        <trans-unit id="3972fbb29cfb0307f762dc829ca3e5c79c5963a7" translate="yes" xml:space="preserve">
          <source>If there are multiple record descriptions present for a given&lt;code&gt;FD&lt;/code&gt;or&lt;code&gt;SD&lt;/code&gt; the one with the longest length will define the size of the record buffer into which a&lt;code&gt;READ&lt;/code&gt;statement (see &lt;a href=&quot;#READ&quot;&gt;READ&lt;/a&gt;) or a&lt;code&gt;RETURN&lt;/code&gt;statement (see &lt;a href=&quot;#RETURN&quot;&gt;RETURN&lt;/a&gt;) will deliver data read from the file and from which a&lt;code&gt;WRITE&lt;/code&gt;statement (see &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt;) or&lt;code&gt;RELEASE&lt;/code&gt;statement (see &lt;a href=&quot;#RELEASE&quot;&gt;RELEASE&lt;/a&gt;) statement will obtain the data to be written to the file.</source>
          <target state="translated">주어진 &lt;code&gt;FD&lt;/code&gt; 또는 &lt;code&gt;SD&lt;/code&gt; 에 대해 여러 레코드 설명이있는 경우 길이가 가장 긴 레코드 설명 은 &lt;code&gt;READ&lt;/code&gt; 문 ( &lt;a href=&quot;#READ&quot;&gt;READ&lt;/a&gt; 참조 ) 또는 &lt;code&gt;RETURN&lt;/code&gt; 문 ( &lt;a href=&quot;#RETURN&quot;&gt;RETURN&lt;/a&gt; 참조 )이 읽은 데이터를 전달할 레코드 버퍼의 크기를 정의합니다 . 파일 및 이로부터 &lt;code&gt;WRITE&lt;/code&gt; 문 (참조 &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt; ) 또는 &lt;code&gt;RELEASE&lt;/code&gt; 의 문 (참조 &lt;a href=&quot;#RELEASE&quot;&gt;RELEASE&lt;/a&gt; 데이터를 얻을 것이다 문) 파일에 기록합니다.</target>
        </trans-unit>
        <trans-unit id="75eb31de9a88419e99f8f2249dfa222651219fe7" translate="yes" xml:space="preserve">
          <source>If there is no picture clause and the&lt;code&gt;ALL&lt;/code&gt;option is specified, the&lt;code&gt;ALL&lt;/code&gt;option will be ignored.</source>
          <target state="translated">picture 절이없고 &lt;code&gt;ALL&lt;/code&gt; 옵션이 지정되면 &lt;code&gt;ALL&lt;/code&gt; 옵션이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0c755b4b694e7c4beb9b1c5901a6f3a6e90065fa" translate="yes" xml:space="preserve">
          <source>If there is no picture clause specified, the size of the screen data item will be the length of the &amp;lt;</source>
          <target state="translated">picture 절이 지정되지 않은 경우 화면 데이터 항목의 크기는 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="be6e32115bff0c291e8d3c6d6525390722099349" translate="yes" xml:space="preserve">
          <source>If there is no&lt;code&gt;C-D&lt;/code&gt;data item, then are there&lt;code&gt;C&lt;/code&gt;and&lt;code&gt;D&lt;/code&gt;data items? If not, the&lt;code&gt;COMPUTE&lt;/code&gt;statement is in error. If there are, however, then code will be generated to subtract the value of&lt;code&gt;D&lt;/code&gt;from&lt;code&gt;C&lt;/code&gt;and add 1 to the result.</source>
          <target state="translated">어떤이없는 경우 &lt;code&gt;C-D&lt;/code&gt; 의 데이터 항목, 다음, 거기에 &lt;code&gt;C&lt;/code&gt; 와 &lt;code&gt;D&lt;/code&gt; 데이터 항목? 그렇지 않으면 &lt;code&gt;COMPUTE&lt;/code&gt; 문에 오류가 있습니다. 그러나 존재하는 경우 &lt;code&gt;C&lt;/code&gt; 에서 &lt;code&gt;D&lt;/code&gt; 의 값을 빼고 결과에 1을 더하는 코드가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="6dbb73155f0ea4fd82ba811977b3d699fc88a4ae" translate="yes" xml:space="preserve">
          <source>If there is no&lt;code&gt;CONTROL&lt;/code&gt;clause, the report will contain no control breaks; this implies that there can be no&lt;code&gt;CONTROL HEADING&lt;/code&gt;or&lt;code&gt;CONTROL FOOTING&lt;/code&gt;report groups defined for this&lt;code&gt;RD&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;CONTROL&lt;/code&gt; 절이 없으면 보고서에 제어 구분이 없습니다. 이는 이 &lt;code&gt;RD&lt;/code&gt; 에 대해 정의 된 &lt;code&gt;CONTROL HEADING&lt;/code&gt; 또는 &lt;code&gt;CONTROL FOOTING&lt;/code&gt; 보고서 그룹 이 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a351d89c95027f7701058bc9f942df00ed507cdc" translate="yes" xml:space="preserve">
          <source>If there is no&lt;code&gt;INITIAL&lt;/code&gt;clause specified, the target range is the entire inspect subject.</source>
          <target state="translated">&lt;code&gt;INITIAL&lt;/code&gt; 절이 지정 되지 않은 경우 대상 범위는 전체 검사 주제입니다.</target>
        </trans-unit>
        <trans-unit id="f81540f4079ee51c4206d96a7efc736809a22ed7" translate="yes" xml:space="preserve">
          <source>If there is no&lt;code&gt;RESET&lt;/code&gt;option coded, the sum counter will be reset back to zero after each time the control footing containing the&lt;code&gt;SUM&lt;/code&gt;clause is presented. This is the typical behaviour that would be expected.</source>
          <target state="translated">코딩 된 &lt;code&gt;RESET&lt;/code&gt; 옵션 이 없으면 &lt;code&gt;SUM&lt;/code&gt; 절을 포함하는 제어 푸팅이 나타날 때마다 합계 카운터가 0으로 다시 재설정됩니다 . 이것이 예상되는 일반적인 동작입니다.</target>
        </trans-unit>
        <trans-unit id="d5e252dc91e0d99f464bda7bc7cffd6140f7edd1" translate="yes" xml:space="preserve">
          <source>If there is no&lt;code&gt;UPON&lt;/code&gt;clause specified, the value of &amp;lt;</source>
          <target state="translated">&lt;code&gt;UPON&lt;/code&gt; 절이 지정 되지 않은 경우 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="3241679c69995dc4a256fad0940c95e8635b9f3e" translate="yes" xml:space="preserve">
          <source>If there is only a single detail group in the report&amp;rsquo;s definition, the&lt;code&gt;UPON&lt;/code&gt;clause is meaningless.</source>
          <target state="translated">보고서 정의에 단일 세부 사항 그룹 만있는 경우 &lt;code&gt;UPON&lt;/code&gt; 절은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c11b35162c1c669848bde8fb8b4adb40363c054b" translate="yes" xml:space="preserve">
          <source>If this format of the&lt;code&gt;GO TO&lt;/code&gt;statement appears in a consecutive sequence of imperative statements (see &lt;a href=&quot;#Imperative-Statement&quot;&gt;Imperative Statement&lt;/a&gt;) within a sentence, it must be the</source>
          <target state="translated">의 형식 경우 &lt;code&gt;GO TO&lt;/code&gt; 의 문이 필수적 문 (볼의 연속 순서로 나타납니다 &lt;a href=&quot;#Imperative-Statement&quot;&gt;명령형 문&lt;/a&gt; 문장 내에서), 그것은을해야합니다</target>
        </trans-unit>
        <trans-unit id="87568d2d981805ff51bcc79d09c4d6bfd7b2a8ef" translate="yes" xml:space="preserve">
          <source>If this is NOT set to a value, all&lt;code&gt;-ftrace&lt;/code&gt;switch and&lt;code&gt;-ftraceall&lt;/code&gt;switch output will be written to STDERR, where it may be piped via a &quot;2&amp;gt; filename&quot; on the command that executes the program.</source>
          <target state="translated">이 값을 설정하지 않으면 모든 &lt;code&gt;-ftrace&lt;/code&gt; 스위치 및 &lt;code&gt;-ftraceall&lt;/code&gt; 스위치 출력이 STDERR에 기록되며 프로그램을 실행하는 명령에서 &quot;2&amp;gt; 파일 이름&quot;을 통해 파이프 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e41eac2db71cda7170c71b8ec2c30d7834407d0c" translate="yes" xml:space="preserve">
          <source>If this is not defined under *nix it will default to /usr/local/share/gnucobol/config.</source>
          <target state="translated">이것이 * nix에 정의되어 있지 않으면 / usr / local / share / gnucobol / config로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="023cf0ecfd0afc5f6ae392348d069495edac90d8" translate="yes" xml:space="preserve">
          <source>If used with&lt;code&gt;PIC X&lt;/code&gt; allocates one byte of storage per&lt;code&gt;X&lt;/code&gt; range of values is 0 to max storable in that many bytes. If used with&lt;code&gt;PIC 9&lt;/code&gt; range of values depends on number of&lt;code&gt;9&lt;/code&gt; in PICTURE</source>
          <target state="translated">&lt;code&gt;PIC X&lt;/code&gt; 와 함께 사용하는 경우 &lt;code&gt;X&lt;/code&gt; 범위 당 1 바이트의 스토리지를 할당 하면 값의 범위는 0부터 최대 바이트까지 저장 가능합니다. &lt;code&gt;PIC 9&lt;/code&gt; 와 함께 사용하는 경우 PICTURE 의 값 범위는 &lt;code&gt;9&lt;/code&gt; 의 수에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="5b48ea3221a5bd190b3da00947706eadb4325c47" translate="yes" xml:space="preserve">
          <source>If used, &amp;lt;</source>
          <target state="translated">사용하는 경우 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="f92f6ebb3f39d6efd118da1f36149fda0df27506" translate="yes" xml:space="preserve">
          <source>If you are comfortable with the &quot;C&quot; programming language, you might find the following simple GnuCOBOL program useful in exploring the differences between subscripting and indexing:</source>
          <target state="translated">&quot;C&quot;프로그래밍 언어에 익숙하다면 다음과 같은 간단한 GnuCOBOL 프로그램이 아래 첨자와 색인 작성의 차이점을 탐색하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66062304bf503c5649ee5c39992874bd53f8d855" translate="yes" xml:space="preserve">
          <source>If you are planning on using static-linked subroutine libraries, set this variable to the path of the directory containing your libraries.</source>
          <target state="translated">정적 링크 서브 루틴 라이브러리를 사용하려는 경우이 변수를 라이브러리가 포함 된 디렉토리의 경로로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="01f92f2645932d2e7b72a1c8110cdcfbd8882f1a" translate="yes" xml:space="preserve">
          <source>If you are sorting &amp;lt;</source>
          <target state="translated">정렬중인 경우 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="02aa6a4a695c82943ebf8b43c9d16d82122de6f1" translate="yes" xml:space="preserve">
          <source>If you are using Fixed Format Mode, the alphanumeric literal can be run right up to and including column 72. The literal may then be continued on the next line anywhere after column 11 by coding another quote or apostrophe (whichever was used to begin the literal originally). The continuation line must also have a hyphen (-)</source>
          <target state="translated">고정 형식 모드를 사용하는 경우 영숫자 리터럴을 열 72까지 포함하여 바로 실행할 수 있습니다. 그런 다음 리터럴을 시작하는 데 사용 된 다른 따옴표 나 아포스트로피를 코딩하여 열 11 다음의 다음 행에서 리터럴을 계속할 수 있습니다. 원래). 연속 줄에도 하이픈 (-)이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="67c575e7eebaede09fa7a3ba7a66b085e2b666ab" translate="yes" xml:space="preserve">
          <source>If you attempt to store a negative number into a packed decimal field that has no&lt;code&gt;S&lt;/code&gt;in its&lt;code&gt;PICTURE&lt;/code&gt; the absolute value of the negative number will actually be stored.</source>
          <target state="translated">더이없는 팩 십진 필드에 음의 번호를 저장하려고하면 &lt;code&gt;S&lt;/code&gt; 를 자사에서 &lt;code&gt;PICTURE&lt;/code&gt; 부정적인 숫자의 절대 값을 실제로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="33f09798c9350fe782168c79a484ebfce1dfd921" translate="yes" xml:space="preserve">
          <source>If you have used other versions of COBOL before (particularly mainframe implementations), you&amp;rsquo;ve possibly seen subroutine calls made passing a procedure name as an argument &amp;mdash; that is not possible in GnuCOBOL; instead, you need to know how to use this form of the&lt;code&gt;SET&lt;/code&gt;statement.</source>
          <target state="translated">이전에 다른 버전의 COBOL (특히 메인 프레임 구현)을 사용한 경우 프로 시저 이름을 인수로 전달하는 서브 루틴 호출이 GnuCOBOL에서는 불가능한 것으로 보았을 것입니다. 대신,이 양식의 &lt;code&gt;SET&lt;/code&gt; 문 을 사용하는 방법을 알아야합니다 .</target>
        </trans-unit>
        <trans-unit id="8575747ffb34e15317f4825a1a6d194e243908c5" translate="yes" xml:space="preserve">
          <source>If you like to hold a book in your hands, I strongly recommend &quot;Murach&amp;rsquo;s Structured COBOL&quot;, by Mike Murach, Anne Prince and Raul Menendez (2000) - ISBN 9781890774059. Mike Murach and his various writing partners have been writing outstanding COBOL textbooks for decades, and this text is no exception. It&amp;rsquo;s an excellent book for those familiar with the concepts of programming in other languages, but unfamiliar with COBOL.</source>
          <target state="translated">Mike Murach, Anne Prince 및 Raul Menendez (2000)-ISBN 9781890774059의 &quot;Murach 's Structured COBOL&quot;을 강력히 추천합니다. Mike Murach와 그의 다양한 저술 파트너는 뛰어난 COBOL 교과서를 작성했습니다. 이 텍스트도 예외는 아닙니다. 다른 언어로 된 프로그래밍 개념에 익숙하지만 COBOL에 익숙하지 않은 사람들에게 훌륭한 책입니다.</target>
        </trans-unit>
        <trans-unit id="a983cec50cc8adb2cb72101e62421b49b40c3f8f" translate="yes" xml:space="preserve">
          <source>If you need to allocate space for a data item whose format is two letters followed by five digits followed by three letters, you could use the &amp;lt;</source>
          <target state="translated">형식이 2 자, 5 자리, 3자인 데이터 항목에 공간을 할당해야하는 경우 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="3d7ab34ba2edb8344ca5cd05ed4f78d8ca295856" translate="yes" xml:space="preserve">
          <source>If you need to apply&lt;code&gt;REPLACING&lt;/code&gt;initialization to multiple &amp;lt;</source>
          <target state="translated">당신은 적용해야하는 경우 &lt;code&gt;REPLACING&lt;/code&gt; 배수로 초기화 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="0be77805ea73d60e3aa2532f09cd1417a0b5f725" translate="yes" xml:space="preserve">
          <source>If you need to apply&lt;code&gt;VALUE&lt;/code&gt;initialization to multiple &amp;lt;</source>
          <target state="translated">여러 &lt;code&gt;VALUE&lt;/code&gt; 초기화를 적용해야하는 경우 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="09b277bb04315e13de2ea2c1d6215f972f449420" translate="yes" xml:space="preserve">
          <source>If you need to qualify a reference to a table, do so by coding something like&lt;code&gt;&amp;lt;&lt;i&gt;identifier-1&lt;/i&gt;&amp;gt; OF &amp;lt;&lt;i&gt;identifier-2&lt;/i&gt;&amp;gt; ( subscript(s) )&lt;/code&gt;</source>
          <target state="translated">테이블에 대한 참조를 규정해야하는 경우 &lt;code&gt;&amp;lt;&lt;i&gt;identifier-1&lt;/i&gt;&amp;gt; OF &amp;lt;&lt;i&gt;identifier-2&lt;/i&gt;&amp;gt; ( subscript(s) )&lt;/code&gt; &lt;i&gt;identifier-1&lt;/i&gt; &amp;gt; OF &amp;lt; &lt;i&gt;identifier-2&lt;/i&gt; &amp;gt; (subscript (s)) 와 같은 코드를 작성하십시오.&lt;i&gt;&lt;/i&gt;&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="ea477a1b93e894e00c5029bde5c4700835a658bc" translate="yes" xml:space="preserve">
          <source>If you only need to use the computed occurrence number once, you might as well just use the computed occurrence number data item as a subscript. If, however, you will need to use a computed &quot;subscript&quot; many more times than once, the run-time overhead of converting that occurrence value to an index (via&lt;code&gt;SET Index&lt;/code&gt; will be worth the coding effort.</source>
          <target state="translated">계산 된 발생 수를 한 번만 사용해야하는 경우 계산 된 발생 수 데이터 항목을 아래 첨자로 사용할 수도 있습니다. 그러나 계산 된 &quot;첨자&quot;를 두 번 이상 여러 번 사용해야하는 경우 해당 발생 값을 인덱스로 변환하는 런타임 오버 헤드 ( &lt;code&gt;SET Index&lt;/code&gt; 를 통해) 는 코딩 노력의 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b1aec7f2d01b9337cb99ecf14cbd063323c6bfc" translate="yes" xml:space="preserve">
          <source>If you specify a specific filename in the sort/merge work file&amp;rsquo;s&lt;code&gt;SELECT&lt;/code&gt; it will be ignored.</source>
          <target state="translated">정렬 / 병합 작업 파일의 &lt;code&gt;SELECT&lt;/code&gt; 에 특정 파일 이름을 지정하면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="db4b705d51633a3053f41836b85c013703781c0c" translate="yes" xml:space="preserve">
          <source>If you specify&lt;code&gt;FINAL&lt;/code&gt; it must be the first control break named in the&lt;code&gt;RD&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;FINAL&lt;/code&gt; 을 지정 하면 &lt;code&gt;RD&lt;/code&gt; 에 이름이 지정된 첫 번째 제어 구분이어야합니다.</target>
        </trans-unit>
        <trans-unit id="bd75b97fc760ccc29226f53558113a860ab9c393" translate="yes" xml:space="preserve">
          <source>If you want to squeeze every last bit of performance out of your GnuCOBOL programs, don&amp;rsquo;t forget to investigate the&lt;code&gt;-O&lt;/code&gt;switch</source>
          <target state="translated">GnuCOBOL 프로그램에서 성능의 모든 마지막 비트를 짜내려면 &lt;code&gt;-O&lt;/code&gt; 스위치 를 조사하는 것을 잊지 마십시오</target>
        </trans-unit>
        <trans-unit id="d6f238b944da72a8958154ef52736f8bf20193b7" translate="yes" xml:space="preserve">
          <source>If you wanted to store the value 128 million into that field, you would do so as if the&lt;code&gt;P&lt;/code&gt; were&lt;code&gt;9&lt;/code&gt;:</source>
          <target state="translated">해당 필드에 1 억 2 천 2 백만 값을 저장하려면 &lt;code&gt;P&lt;/code&gt; 가 &lt;code&gt;9&lt;/code&gt; 인 것처럼 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="f960091ad57764e902ba6a62fa5a1b8ba304ce95" translate="yes" xml:space="preserve">
          <source>If you will be porting existing code over to GnuCOBOL, you&amp;rsquo;ll find it an accommodating facility capable of conforming to whatever language and coding standards that code is likely to use. If you are creating new GnuCOBOL programs, however, I would strongly counsel you to use the&lt;code&gt;END-verb&lt;/code&gt;structures in those programs.</source>
          <target state="translated">기존 코드를 GnuCOBOL로 포팅 할 경우 해당 코드가 사용하는 언어 및 코딩 표준을 준수 할 수있는 수용 시설을 찾을 수 있습니다. 그러나 새로운 GnuCOBOL 프로그램을 작성하는 경우 해당 프로그램에서 &lt;code&gt;END-verb&lt;/code&gt; 구조 를 사용하도록 강력히 권고합니다 .</target>
        </trans-unit>
        <trans-unit id="84f76abe3e8dfd99557f1d9c28b5a29519b7cdd8" translate="yes" xml:space="preserve">
          <source>If your GnuCOBOL build uses the Berkeley Database (BDB) package, use this environment variable to specify the folder in which the lock management files to be associated with all non-SORT files opened by the program will be stored.&lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;) files will also have their data file allocated in the folder pointed to by this environment variable, if it exists.. Having this variable defined will activate record locking features on the&lt;code&gt;READ&lt;/code&gt;statement (see &lt;a href=&quot;#READ&quot;&gt;READ&lt;/a&gt;),&lt;code&gt;REWRITE&lt;/code&gt;statement (see &lt;a href=&quot;#REWRITE&quot;&gt;REWRITE&lt;/a&gt;) and&lt;code&gt;WRITE&lt;/code&gt;statement (see &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt;). Even with DB_HOME, locking will not work with&lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt;),&lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;ORGANIZATION LINE SEQUENTIAL&lt;/a&gt;) or ORGANIZATION RELATIVE files with GnuCOBOL builds created for Windows/MinGW.&lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt;locks will work with Windows/MinGW + BDB and all locks will work for all file organizations with UNIX GnuCOBOL builds.</source>
          <target state="translated">GnuCOBOL 빌드가 BDB (Berkeley Database) 패키지를 사용하는 경우이 환경 변수를 사용하여 프로그램에서 연 모든 비 SORT 파일과 연관 될 잠금 관리 파일이 저장 될 폴더를 지정하십시오. &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; (참조 &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;조직 인덱스를&lt;/a&gt; 존재하는 경우) 파일이 또한 자신의 데이터 파일은 폴더에 할당 된 것은 .. 기록 잠금을에 기능을 활성화 정의이 변수 데,이 환경 변수가 가리키는 &lt;code&gt;READ&lt;/code&gt; (참조 문을 &lt;a href=&quot;#READ&quot;&gt;READ를&lt;/a&gt; ) &lt;code&gt;REWRITE&lt;/code&gt; 문 ( &lt;a href=&quot;#REWRITE&quot;&gt;REWRITE&lt;/a&gt; 참조 ) 및 &lt;code&gt;WRITE&lt;/code&gt; 문 ( &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt; 참조 ). DB_HOME을 사용하더라도 &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; 에서는 잠금이 작동하지 않습니다.( &lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;조직&lt;/a&gt; 시퀀스 참조 ), &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; ( &lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;조직 라인&lt;/a&gt; 시퀀스 참조 ) 또는 Windows / MinGW 용으로 생성 된 GnuCOBOL 빌드가 포함 된 조직 관련 파일. &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; 잠금은 Windows / MinGW + BDB에서 작동하며 모든 잠금은 UNIX GnuCOBOL 빌드가있는 모든 파일 조직에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5d5c76b0afd98975a32ec5cfb6a7e9651011522c" translate="yes" xml:space="preserve">
          <source>If your program is using Free Format Mode, there&amp;rsquo;s less need to continue long alphanumeric literals because statements may be as long as 255 characters.</source>
          <target state="translated">프로그램이 자유 형식 모드를 사용하는 경우 명령문의 길이가 255 자일 수 있으므로 긴 영숫자 리터럴을 계속할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9ec069692353086fbfea33bd5148cbb40a61d28b" translate="yes" xml:space="preserve">
          <source>If, however, the GnuCOBOL compiler was built for a Unix, OSX or Linux environment, or was built for a Windows environment utilizing either the Cygwin or MinGW Unix emulators, use a colon character (:) as the delimiter.</source>
          <target state="translated">그러나 GnuCOBOL 컴파일러가 Unix, OSX 또는 Linux 환경 용으로 구축되었거나 Cygwin 또는 MinGW Unix 에뮬레이터를 사용하는 Windows 환경 용으로 구축 된 경우 콜론 문자 (:)를 구분 기호로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="732d00d8a979e2d6acfa93077091ec5aa45575e1" translate="yes" xml:space="preserve">
          <source>If, however, you want to reset the&lt;code&gt;SUM&lt;/code&gt;counter only when the control footing for a control break higher in the control hierarchy is presented, specify that higher control break on the&lt;code&gt;RESET&lt;/code&gt;option.</source>
          <target state="translated">그러나 제어 계층 구조에서 더 높은 제어 브레이크에 대한 제어 푸팅이 표시 될 때만 &lt;code&gt;SUM&lt;/code&gt; 카운터 를 재설정 하려면 &lt;code&gt;RESET&lt;/code&gt; 옵션 에서 더 높은 제어 브레이크를 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="2cd8cc804f2a5ff93a10ce1b74fdd3576f5a7e3f" translate="yes" xml:space="preserve">
          <source>If, on the other hand, the compiler &quot;config&quot; file you used to compile the program specified &quot;mf&quot; as the &quot;assign-clause&quot; value, then the File Locator String will be interpreted according to according to IBM COBOL rules &amp;mdash; namely, the File Locator String is expected to be of the form &quot;S-xxx&quot; or &quot;AS-xxx&quot;, in which case the &quot;xxx&quot; will be treated as the base of an environment variable name. If there is no &quot;-&quot; character in the File Locator String then the entire File Locator String will serve as the base of an environment variable name.</source>
          <target state="translated">반면, 프로그램 &quot;mf&quot;를 &quot;assign-clause&quot;값으로 지정한 프로그램을 컴파일하는 데 사용한 컴파일러 &quot;config&quot;파일 인 경우 File Locator String은 IBM COBOL 규칙에 따라 해석됩니다. 파일 로케이터 문자열은 &quot;S-xxx&quot;또는 &quot;AS-xxx&quot;형식이어야하며,이 경우 &quot;xxx&quot;는 환경 변수 이름의 기본으로 취급됩니다. 파일 로케이터 문자열에 &quot;-&quot;문자가 없으면 전체 파일 로케이터 문자열이 환경 변수 이름의 기본으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="14a1e778d3d526022a292de2dd1ee46c48882f7a" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;AFTER ADVANCING&lt;/code&gt;</source>
          <target state="translated">만약 &lt;code&gt;AFTER ADVANCING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2484c7b62fe9d88e48bcea28b9bbba49a4a0abff" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;FIRST&lt;/code&gt;was specified, the logical record pointer will point to the first record in the file.</source>
          <target state="translated">&lt;code&gt;FIRST&lt;/code&gt; 가 지정된 경우 논리 레코드 포인터는 파일의 첫 번째 레코드를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="7863a8759644caaed13a6998607dcd0f2e23acf3" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;KEY&lt;/code&gt;was specified or implied, the logical record pointer will be specified to the</source>
          <target state="translated">경우 &lt;code&gt;KEY&lt;/code&gt; 가 지정되거나 암시 된 논리 레코드 포인터가로 지정됩니다</target>
        </trans-unit>
        <trans-unit id="1552ccf0c116c7d239331a720f9d74cec693c257" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;LAST&lt;/code&gt;was specified, the logical record pointer will point to the last record in the file.</source>
          <target state="translated">&lt;code&gt;LAST&lt;/code&gt; 가 지정된 경우 논리 레코드 포인터는 파일의 마지막 레코드를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="8278b8c8384858282c9b205d0ba2082757d20698" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;PICTURE&lt;/code&gt;9 and contains&lt;code&gt;S&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;PICTURE&lt;/code&gt; 9에 &lt;code&gt;S&lt;/code&gt; 가 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="8061e9cae2be0636e69237bf17be3f7098f0542a" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;PICTURE&lt;/code&gt;contains&lt;code&gt;S&lt;/code&gt;</source>
          <target state="translated">If&lt;code&gt;PICTURE&lt;/code&gt;contains&lt;code&gt;S&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9cd6edca65a7476c700085fccd1713df6568c8bd" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;n&lt;/code&gt;represents the level number of the object, then no other data items with a level number numerically less than&lt;code&gt;n&lt;/code&gt;may be defined between the subject and object data items.</source>
          <target state="translated">경우 &lt;code&gt;n&lt;/code&gt; 보다 작은 수치의 레벨 번호를 가진 물체의 레벨 번호 다음 다른 데이터 항목을 나타내며 &lt;code&gt;n&lt;/code&gt; 주체와 대상 데이터 항목들 사이에 형성 될 수있다.</target>
        </trans-unit>
        <trans-unit id="d3c3a4ef34b214c7901c86d04f87249a39615cfd" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;n&lt;/code&gt;represents the level number of the object, then no other data items with level number&lt;code&gt;n&lt;/code&gt;may be defined between the subject and object data items unless they too are&lt;code&gt;REDEFINES&lt;/code&gt;of the subject.</source>
          <target state="translated">경우에 &lt;code&gt;n&lt;/code&gt; 상기 객체의 레벨 번호 일절 레벨 번호와 다른 데이터 항목을 대표하지 &lt;code&gt;n&lt;/code&gt; 이 너무 아니라면 주체와 대상 데이터 항목 사이에 형성 될 수있다 &lt;code&gt;REDEFINES&lt;/code&gt; 피사체.</target>
        </trans-unit>
        <trans-unit id="41e3512adad8c7a49c2bc5818c26857faf073355" translate="yes" xml:space="preserve">
          <source>Imagine my surprise, however, when I discovered that the use of&lt;code&gt;-fnotrunc&lt;/code&gt;switch also made a difference:</source>
          <target state="translated">그러나 &lt;code&gt;-fnotrunc&lt;/code&gt; 스위치를 사용 하면 차이가 있음을 발견했을 때 놀랍게 상상해보십시오 .</target>
        </trans-unit>
        <trans-unit id="ba2d2155230191737321736ab1c421252a9d474f" translate="yes" xml:space="preserve">
          <source>Imperative Statement</source>
          <target state="translated">명령문</target>
        </trans-unit>
        <trans-unit id="093f2fea111647ab73586789136bb3d0d4a0950c" translate="yes" xml:space="preserve">
          <source>Implementation-defined accept condition</source>
          <target state="translated">구현 정의 수락 조건</target>
        </trans-unit>
        <trans-unit id="3d29bb9dbd4be0c211a42d389e2c3292fd50b3aa" translate="yes" xml:space="preserve">
          <source>Implementation-defined display condition</source>
          <target state="translated">구현 정의 표시 조건</target>
        </trans-unit>
        <trans-unit id="3d3ffee367a47df22f0329d2161f7179c7140f49" translate="yes" xml:space="preserve">
          <source>In an attempt to correct the problem, we could qualify the reference to CITY as&lt;code&gt;MOVE 'Philadelphia' TO CITY OF MAILING-ADDRESS&lt;/code&gt;</source>
          <target state="translated">문제를 해결하기 위해, 우리는 &lt;code&gt;MOVE 'Philadelphia' TO CITY OF MAILING-ADDRESS&lt;/code&gt; 로 이동하는 '필라델피아 (Philadelphia)' 로 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1132a1566c2ed19e4f36c07a65dd3752e2bf4c83" translate="yes" xml:space="preserve">
          <source>In complex expressions composed of multiple operators and operands, a precedence of operation applies whereby those operations having a higher precedence are computed first before operations with a lower precedence.</source>
          <target state="translated">여러 연산자와 피연산자로 구성된 복잡한 식에서 우선 순위가 높은 연산이 우선 순위가 낮은 연산보다 먼저 계산되는 연산 우선 순위가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="67cd2a991339c0db61eccf443f46cb731b97b13e" translate="yes" xml:space="preserve">
          <source>In either instance, program &quot;A&quot; is referred to as the &amp;rsquo;</source>
          <target state="translated">어느 경우 든, 프로그램 &quot;A&quot;는 &quot;</target>
        </trans-unit>
        <trans-unit id="b68b4bcf151b57e71e554fe7952a0e73619a414f" translate="yes" xml:space="preserve">
          <source>In general, each picture symbol represents either a single character in storage or a single decimal digit. There are a few exceptions, and they will be discussed as needed.</source>
          <target state="translated">일반적으로 각 그림 기호는 저장시 단일 문자 또는 하나의 10 진수를 나타냅니다. 몇 가지 예외가 있으며 필요에 따라 논의 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="2411df7c12420101004e143cb3943a4101a56bf7" translate="yes" xml:space="preserve">
          <source>In general, table references such as example #1 (constant subscript) generate the smallest, simplest and fastest object code while table references such as example #2 (numeric data item subscript) generate the largest, most-complicated and slowest object code.</source>
          <target state="translated">일반적으로 예제 # 1 (일정한 첨자)과 같은 테이블 참조는 가장 작고 단순하며 빠른 객체 코드를 생성하는 반면 예제 # 2 (숫자 데이터 항목 첨자)와 같은 테이블 참조는 가장 크고 복잡하고 느린 객체 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="9f3d74011ccc810b1770ab4e3dfbc7f8f1fdf305" translate="yes" xml:space="preserve">
          <source>In highest to lowest order of precedence, here is a discussion of each category of operation:</source>
          <target state="translated">우선 순위가 가장 높은 순서대로 다음은 각 작업 범주에 대한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="37e03fd035bc729f5e1bac261783ab6dc96b9a08" translate="yes" xml:space="preserve">
          <source>In order for &amp;lt;</source>
          <target state="translated">&amp;lt;</target>
        </trans-unit>
        <trans-unit id="6bb3bbadc2d27138c4c9dae5d396fb6f7ddc8694" translate="yes" xml:space="preserve">
          <source>In order for a &amp;lt;</source>
          <target state="translated">&amp;lt;</target>
        </trans-unit>
        <trans-unit id="36616f50c54eeaba783ad05be353c37e7580b497" translate="yes" xml:space="preserve">
          <source>In order for this clause to take effect at execution time, the user must move the cursor into the field having this clause in its definition.</source>
          <target state="translated">이 절이 실행 시간에 적용 되려면 사용자는 정의에이 절이있는 필드로 커서를 이동해야합니다.</target>
        </trans-unit>
        <trans-unit id="d4cc191768c1993e9df309f3f21d935b4723ece5" translate="yes" xml:space="preserve">
          <source>In order for this statement to be functional, tracing code must have been generated into the compiled program using either the&lt;code&gt;-ftrace&lt;/code&gt;switch</source>
          <target state="translated">이 명령문이 작동하려면 &lt;code&gt;-ftrace&lt;/code&gt; 스위치를 사용하여 컴파일 된 프로그램에 추적 코드가 생성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d5716d69487d7213f5a154886aec1d579f1359df" translate="yes" xml:space="preserve">
          <source>In order for&lt;code&gt;AND&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;AND&lt;/code&gt; 를 위해</target>
        </trans-unit>
        <trans-unit id="12840b41d70472b409489727335424ef0070e853" translate="yes" xml:space="preserve">
          <source>In order to be functional, this attribute must be supported by the underlying &amp;rsquo;curses&amp;rsquo; package your GnuCOBOL implementation was built with. As of this time, the &amp;rsquo;PDCurses&amp;rsquo; package (used for native Windows or MinGW builds) does not support&lt;code&gt;EMPTY-CHECK&lt;/code&gt;</source>
          <target state="translated">기능적으로 작동하려면 GnuCOBOL 구현이 빌드 된 기본 'curses'패키지에서이 속성을 지원해야합니다. 현재 'PDCurses'패키지 (기본 Windows 또는 MinGW 빌드에 사용)는 &lt;code&gt;EMPTY-CHECK&lt;/code&gt; 를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="17d285867c49f9dd90eb1f27cf9c7a60d1e38df8" translate="yes" xml:space="preserve">
          <source>In order to be functional, this attribute must be supported by the underlying &amp;rsquo;curses&amp;rsquo; package your GnuCOBOL implementation was built with. As of this time, the &amp;rsquo;PDCurses&amp;rsquo; package (used for native Windows or MinGW builds) does not support&lt;code&gt;FULL&lt;/code&gt;</source>
          <target state="translated">기능적으로 작동하려면 GnuCOBOL 구현이 빌드 된 기본 'curses'패키지에서이 속성을 지원해야합니다. 현재 'PDCurses'패키지 (기본 Windows 또는 MinGW 빌드에 사용)는 &lt;code&gt;FULL&lt;/code&gt; 을 지원하지 않습니다</target>
        </trans-unit>
        <trans-unit id="0a81aca05eb7b3e3ebeefcb93bfd42b8a77e381a" translate="yes" xml:space="preserve">
          <source>In order to be functional, this attribute must be supported by the underlying &amp;rsquo;curses&amp;rsquo; package your GnuCOBOL implementation was built with. As of this time, the &amp;rsquo;PDCurses&amp;rsquo; package (used for native Windows or MinGW builds) does not support&lt;code&gt;LENGTH-CHECK&lt;/code&gt;</source>
          <target state="translated">기능적으로 작동하려면 GnuCOBOL 구현이 빌드 된 기본 'curses'패키지에서이 속성을 지원해야합니다. 현재 'PDCurses'패키지 (기본 Windows 또는 MinGW 빌드에 사용)는 &lt;code&gt;LENGTH-CHECK&lt;/code&gt; 를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="de32275ede835ac63170073ab2d665b3951078da" translate="yes" xml:space="preserve">
          <source>In order to be functional, this attribute must be supported by the underlying &amp;rsquo;curses&amp;rsquo; package your GnuCOBOL implementation was built with. As of this time, the &amp;rsquo;PDCurses&amp;rsquo; package (used for native Windows or MinGW builds) does not support&lt;code&gt;REQUIRED&lt;/code&gt;</source>
          <target state="translated">기능적으로 작동하려면 GnuCOBOL 구현이 빌드 된 기본 'curses'패키지에서이 속성을 지원해야합니다. 현재 'PDCurses'패키지 (기본 Windows 또는 MinGW 빌드에 사용)는 &lt;code&gt;REQUIRED&lt;/code&gt; 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ea48fcaef90024e13873585a7560dd9b545d9d4" translate="yes" xml:space="preserve">
          <source>In order to take effect, the user must first move the cursor into the field having this clause in its definition.</source>
          <target state="translated">적용하려면 사용자가 먼저 정의에서이 절이있는 필드로 커서를 이동해야합니다.</target>
        </trans-unit>
        <trans-unit id="c1ff1f707da403375eb5aac3df8097ce50066a1d" translate="yes" xml:space="preserve">
          <source>In the above examples, a comma is used as a separator character between the two subscript values; semicolons &lt;code&gt;;&lt;/code&gt; are also valid subscript separator characters, as are spaces! The use of a comma or semicolon separator in such a situation is technically optional, but by convention most COBOL programmers use one or the other. The use of no separator character (other than a space) is not recommended, even though it is syntactically correct, as this practice can lead to programmer-unfriendly code. It isn&amp;rsquo;t too difficult to read and understand&lt;code&gt;GRID-CHARACTER(2 3)&lt;/code&gt; but it&amp;rsquo;s another story entirely when trying to comprehend&lt;code&gt;GRID-CHARACTER(I + 1 J / 3)&lt;/code&gt;(instead of&lt;code&gt;GRID-CHARACTER(I + 1, J / 3)&lt;/code&gt;. The compiler accepts it, but too much of this would make</source>
          <target state="translated">위의 예에서 쉼표는 두 첨자 값 사이의 구분 문자로 사용됩니다. 세미콜론 &lt;code&gt;;&lt;/code&gt; 공백과 같이 유효한 첨자 구분 문자도 있습니다! 이러한 상황에서 쉼표 또는 세미콜론 구분 기호를 사용하는 것은 기술적으로 선택 사항이지만, 대부분의 COBOL 프로그래머는 일반적으로 하나를 사용합니다. 프로그래밍 방식에 친숙하지 않은 코드로 이어질 수 있으므로 구문 상 올바르지 만 구분 기호 문자 (공백 이외의)를 사용하지 않는 것이 좋습니다. &lt;code&gt;GRID-CHARACTER(2 3)&lt;/code&gt; 를 읽고 이해하는 것은 너무 어렵지 않지만 &lt;code&gt;GRID-CHARACTER(I + 1 J / 3)&lt;/code&gt; 를 이해하려고 할 때의 이야기 입니다 ( &lt;code&gt;GRID-CHARACTER(I + 1, J / 3)&lt;/code&gt; . 컴파일러가이를 받아들이지 만 너무 많으면</target>
        </trans-unit>
        <trans-unit id="ab0a8c97ecdd65110e9781dbe9e9bcdabaa33882" translate="yes" xml:space="preserve">
          <source>In the absence of the&lt;code&gt;OVERRIDE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;OVERRIDE&lt;/code&gt; 가 없을 때</target>
        </trans-unit>
        <trans-unit id="be9ad81756c2c029daadb7f85dc6de13011d4872" translate="yes" xml:space="preserve">
          <source>In the case of the former, the&lt;code&gt;USING&lt;/code&gt;clause on the procedure division header should describe the argument via the&lt;code&gt;BY REFERENCE&lt;/code&gt;</source>
          <target state="translated">전자의 경우 , 프로 시저 분할 헤더 의 &lt;code&gt;USING&lt;/code&gt; 절은 &lt;code&gt;BY REFERENCE&lt;/code&gt; 를 통해 인수를 설명해야합니다.</target>
        </trans-unit>
        <trans-unit id="3683f2272e68eee3328548bbf75c6cbed2e45e7d" translate="yes" xml:space="preserve">
          <source>In the late 70&amp;rsquo;s cards was also on its way out to the point where P.C&amp;rsquo;s started being used (and no they were not made by IBM), so these columns could be used for other purposes including cc 73 - 80 instead of indicating the 8 character program name which was the maximum size allowed on a IBM system.</source>
          <target state="translated">70 년대 후반에 PC가 사용되기 시작한 시점 (그리고 IBM이 만든 것이 아님)까지 카드가 나왔기 때문에이 열은 CC 73-80을 포함한 다른 목적으로 사용될 수 있습니다. IBM 시스템에서 허용되는 최대 크기 인 8 자 프로그램 이름.</target>
        </trans-unit>
        <trans-unit id="82849a227b43e92353f440e6cf481dde7d3eb800" translate="yes" xml:space="preserve">
          <source>In this case, the&lt;code&gt;EXIT&lt;/code&gt;statement takes no other run-time action.</source>
          <target state="translated">이 경우 &lt;code&gt;EXIT&lt;/code&gt; 문은 다른 런타임 조치를 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a9d1dc97c6798126e8a06dda35c75cc92d21220" translate="yes" xml:space="preserve">
          <source>In this context,&lt;code&gt;VALUE&lt;/code&gt;specifies an initial compilation-time value that will be assigned to the storage occupied by the data item in the program object code generated by the compiler.</source>
          <target state="translated">이 컨텍스트에서 &lt;code&gt;VALUE&lt;/code&gt; 는 컴파일러가 생성 한 프로그램 오브젝트 코드에서 데이터 항목이 차지하는 스토리지에 지정 될 초기 컴파일 시간 값을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="84cb1e4aa0b378b3db93b48860594751f6ae285f" translate="yes" xml:space="preserve">
          <source>In this example, all six&lt;code&gt;A&lt;/code&gt;items will be initialized to &quot;?&quot;, all six&lt;code&gt;B&lt;/code&gt;items will be initialized to &quot;%&quot; and all six&lt;code&gt;N&lt;/code&gt;items will be initialized to 10. It&amp;rsquo;s not clear exactly how many times this sort of initialization will be useful, but it&amp;rsquo;s there if you need it.</source>
          <target state="translated">이 예에서는 6 개의 &lt;code&gt;A&lt;/code&gt; 항목이 모두 &quot;?&quot;로 초기화되고 6 개의 &lt;code&gt;B&lt;/code&gt; 항목이 모두 &quot;%&quot;로 초기화되고 6 개의 &lt;code&gt;N&lt;/code&gt; 항목이 모두 10으로 초기화됩니다. 이러한 초기화 유형이 정확히 몇 번인지는 명확하지 않습니다. 유용하지만 필요한 경우 있습니다.</target>
        </trans-unit>
        <trans-unit id="2879e2f56bb5d870554e86f04a4bf9ebe7fb4ed9" translate="yes" xml:space="preserve">
          <source>In this example, the IF statement actually has a scope that can include two sets of associated statements &amp;ndash; one set to be executed when the&lt;code&gt;IF&lt;/code&gt;(see &lt;a href=&quot;#IF&quot;&gt;IF&lt;/a&gt;) condition is TRUE and another if it is FALSE.</source>
          <target state="translated">이 예에서 IF 문에는 실제로 두 세트의 연관된 명령문이 포함될 수있는 범위가 있습니다. 하나는 &lt;code&gt;IF&lt;/code&gt; ( &lt;a href=&quot;#IF&quot;&gt;IF&lt;/a&gt; 참조 ) 조건이 TRUE 일 때 실행 되고 다른 하나는 FALSE 일 경우 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="b671b6f79a2badfb5c4ccb993eb5f1ff2485bd4c" translate="yes" xml:space="preserve">
          <source>In which case 9 characters of storage will be reserved. The values 000000000 through 999999999 will represent the gross-revenues. But, if only the millions are tracked (meaning the last six digits are always going to be 0), you could define the field as:</source>
          <target state="translated">이 경우 9 문자의 스토리지가 예약됩니다. 000000000-999999999 값은 총 수익을 나타냅니다. 그러나 수백만 만 추적하는 경우 (마지막 6 자리가 항상 0이 됨) 필드를 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6178a2fcb450efe4624273996659b2d5392d26b6" translate="yes" xml:space="preserve">
          <source>Include the reserved word&lt;code&gt;FINAL&lt;/code&gt;</source>
          <target state="translated">예약어 &lt;code&gt;FINAL&lt;/code&gt; 포함</target>
        </trans-unit>
        <trans-unit id="4587868819f3914fb0d960b2a017af52903b843c" translate="yes" xml:space="preserve">
          <source>Including an&lt;code&gt;ON SIZE ERROR&lt;/code&gt;clause on an arithmetic statement will allow your program to trap a failure of an arithmetic statement (either generating a result too large for the receiving field, or attempting to divide by zero) and handle it gracefully by executing &amp;lt;</source>
          <target state="translated">산술 문에 &lt;code&gt;ON SIZE ERROR&lt;/code&gt; 절을 포함하면 프로그램이 산술 문의 실패 (수신 필드에 대해 너무 큰 결과를 생성하거나 0으로 나누려고 시도 함)를 트랩하고 &amp;lt;를 실행하여 정상적으로 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="2ec9e5e5288405f63d74272e4e8bcad544b64e15" translate="yes" xml:space="preserve">
          <source>Incompatible data exception</source>
          <target state="translated">호환되지 않는 데이터 예외</target>
        </trans-unit>
        <trans-unit id="e0049c7018b06d02f3c0ba2245a0ee83c74d7cc7" translate="yes" xml:space="preserve">
          <source>Inconsistent filename</source>
          <target state="translated">일치하지 않는 파일 이름</target>
        </trans-unit>
        <trans-unit id="e5d727021f58d38c370cf7243256d9dff80ee53f" translate="yes" xml:space="preserve">
          <source>Independent Subprograms</source>
          <target state="translated">독립 서브 프로그램</target>
        </trans-unit>
        <trans-unit id="0e0834dadd433c69c101f415ef11e7aef2f4805a" translate="yes" xml:space="preserve">
          <source>Indexed files are processed using the following statements:</source>
          <target state="translated">색인화 된 파일은 다음 명령문을 사용하여 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="9353f9003cee9268ec86b3a1ea7f4d4ecb16eb1c" translate="yes" xml:space="preserve">
          <source>Indexing is the process of referencing an element of a table utilizing a data item with an explicitly or implicitly defined&lt;code&gt;USAGE&lt;/code&gt;(see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) of&lt;code&gt;INDEX&lt;/code&gt;to select the desired occurrence, while &amp;hellip;</source>
          <target state="translated">인덱싱은 &lt;code&gt;INDEX&lt;/code&gt; 의 명시 적 또는 암시 적으로 정의 된 &lt;code&gt;USAGE&lt;/code&gt; ( &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt; 참조 )가 있는 데이터 항목을 사용 하여 원하는 요소를 선택하는 동안 테이블 요소를 참조하는 프로세스입니다 .</target>
        </trans-unit>
        <trans-unit id="a6c6b82216692a3106690069e47ca45a2e70d92d" translate="yes" xml:space="preserve">
          <source>Initialize small tables at compile time by including a&lt;code&gt;VALUE&lt;/code&gt;clause on the group item that serves as a parent to the table, as follows:</source>
          <target state="translated">다음과 같이 테이블의 부모 역할을하는 그룹 항목에 &lt;code&gt;VALUE&lt;/code&gt; 절을 포함시켜 컴파일 타임에 작은 테이블을 초기화하십시오 .</target>
        </trans-unit>
        <trans-unit id="24b3196c683087c1c3199428c0580a1c1d58213b" translate="yes" xml:space="preserve">
          <source>Initialize tables of almost any size at compilation time by utilizing the&lt;code&gt;REDEFINES&lt;/code&gt;(see &lt;a href=&quot;#REDEFINES&quot;&gt;REDEFINES&lt;/a&gt;) clause:</source>
          <target state="translated">&lt;code&gt;REDEFINES&lt;/code&gt; ( &lt;a href=&quot;#REDEFINES&quot;&gt;REDEFINES&lt;/a&gt; 참조 ) 절 을 사용하여 컴파일 타임에 거의 모든 크기의 테이블을 초기화 하십시오 .</target>
        </trans-unit>
        <trans-unit id="2fec9ecf2a45eb0fd0af8f70fdb0cee7e4377f3b" translate="yes" xml:space="preserve">
          <source>Inline PERFORM Syntax</source>
          <target state="translated">인라인 PERFORM 구문</target>
        </trans-unit>
        <trans-unit id="bc36d8128c5a1e8ca8d8c4f2854d174a361c1c90" translate="yes" xml:space="preserve">
          <source>Input fields may have any character used as a fill character. These fill characters provide a visual indication of the size of the input field, and will automatically be transformed into spaces when the input field is processed by the program. If no such character is defined for an input field, an underscore (&quot;_&quot;) will be assumed.</source>
          <target state="translated">입력 필드에는 채우기 문자로 사용되는 문자가있을 수 있습니다. 이 채우기 문자는 입력 필드의 크기를 시각적으로 표시하며 입력 필드가 프로그램에 의해 처리 될 때 공백으로 자동 변환됩니다. 입력 필드에 이러한 문자가 정의되어 있지 않으면 밑줄 ( &quot;_&quot;)이 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="d4fe42447823ec3b9e2e9421bf9fdef259cf35f1" translate="yes" xml:space="preserve">
          <source>Input will be read either from the console window &lt;code&gt;CONSOLE&lt;/code&gt; or from the system-standard input (pipe 0 =&lt;code&gt;STDIN&lt;/code&gt;&lt;code&gt;SYSIN&lt;/code&gt;or&lt;code&gt;SYSIPT&lt;/code&gt; and will be saved in &amp;lt;</source>
          <target state="translated">콘솔 창 &lt;code&gt;CONSOLE&lt;/code&gt; 또는 시스템 표준 입력 (파이프 0 = &lt;code&gt;STDIN&lt;/code&gt; &lt;code&gt;SYSIN&lt;/code&gt; 또는 &lt;code&gt;SYSIPT&lt;/code&gt; )에서 입력을 읽고 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="11b11dadbac78c35efb5d86e561bfcff60c6701b" translate="yes" xml:space="preserve">
          <source>Integer and non-integer operands may be freely intermixed</source>
          <target state="translated">정수와 비정 수 피연산자는 자유롭게 섞일 수 있습니다</target>
        </trans-unit>
        <trans-unit id="8626f5223c37139c00a44d21c18f768de6e8df20" translate="yes" xml:space="preserve">
          <source>Integers such as 1, 56, 2192 or -54.</source>
          <target state="translated">1, 56, 2192 또는 -54와 같은 정수</target>
        </trans-unit>
        <trans-unit id="d47bc2c05ec93f214d2f93848b03eba3a04ff0c4" translate="yes" xml:space="preserve">
          <source>Integrating well with non-COBOL infrastructures such as XML, SOA, MQ, almost any DBMS, Transaction Processing platforms, Queue-Management facilities and other programming languages.</source>
          <target state="translated">XML, SOA, MQ, 거의 모든 DBMS, 트랜잭션 처리 플랫폼, 큐 관리 기능 및 기타 프로그래밍 언어와 같은 비 COBOL 인프라와의 통합</target>
        </trans-unit>
        <trans-unit id="8b3eb3d9c05dbc205b027a6d0771b0af833c1b89" translate="yes" xml:space="preserve">
          <source>Interactions between the program and the user will take place using the standard input, standard output and standard error streams. Any screen section I/O performed by the program will take place within the command shell &quot;window&quot;.</source>
          <target state="translated">프로그램과 사용자 간의 상호 작용은 표준 입력, 표준 출력 및 표준 오류 스트림을 사용하여 수행됩니다. 프로그램이 수행하는 모든 화면 섹션 I / O는 &quot;shell&quot;명령 셸 내에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="4004bbedc882730cd7377c55c8a60c3d77d841f3" translate="yes" xml:space="preserve">
          <source>Intrinsic Function</source>
          <target state="translated">내장 함수</target>
        </trans-unit>
        <trans-unit id="3afb87dd54b38fa7410a22ca94bf84568bc6f936" translate="yes" xml:space="preserve">
          <source>Is there a data item named&lt;code&gt;C-D&lt;/code&gt;defined? If so, use its value for the character sequence&lt;code&gt;C-D&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;C-D&lt;/code&gt; 라는 데이터 항목이 정의되어 있습니까? 그렇다면 문자 순서 &lt;code&gt;C-D&lt;/code&gt; 에 해당 값을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b2a3023db707fff296813396a984d683cabd59f0" translate="yes" xml:space="preserve">
          <source>It is also possible to create source files where GnuCOBOL programs are nested inside each other. Take for example these four GnuCOBOL programs:</source>
          <target state="translated">GnuCOBOL 프로그램이 서로 중첩 된 소스 파일을 만들 수도 있습니다. 다음 네 가지 GnuCOBOL 프로그램을 예로 들어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="84300e8f98a0f3852c30d9579e7c60614ed0dbd3" translate="yes" xml:space="preserve">
          <source>It is expected that:</source>
          <target state="translated">다음이 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="6c528e93ea46610dc90b04c262c6d8a0c4d80f39" translate="yes" xml:space="preserve">
          <source>It is possible to generate executable modules for all GnuCOBOL programs, not just subprograms, by choosing to use the&lt;code&gt;-m&lt;/code&gt;switch</source>
          <target state="translated">&lt;code&gt;-m&lt;/code&gt; 스위치 를 사용하여 하위 프로그램뿐만 아니라 모든 GnuCOBOL 프로그램에 대해 실행 가능한 모듈을 생성 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="fd71df406ad79246a83a283db27a4507793dc703" translate="yes" xml:space="preserve">
          <source>It is possible, however, to automatically cause all library names to &amp;rsquo;fold&amp;rsquo; to upper-case by specifying the&lt;code&gt;-ffold-call&lt;/code&gt;switch</source>
          <target state="translated">그러나 &lt;code&gt;-ffold-call&lt;/code&gt; 스위치를 지정하여 모든 라이브러리 이름을 자동으로 대문자로 '폴드'할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f5ff5b5b0cc8eb3a5f026f5c68c2c34d3dd2e58" translate="yes" xml:space="preserve">
          <source>It is possible, however, to automatically cause all&lt;code&gt;COPY&lt;/code&gt;statements to &amp;rsquo;fold&amp;rsquo; the names of all copybooks to upper-case by specifying the&lt;code&gt;-ffold-copy&lt;/code&gt;switch</source>
          <target state="translated">그러나 &lt;code&gt;-ffold-copy&lt;/code&gt; 스위치를 지정하여 모든 &lt;code&gt;COPY&lt;/code&gt; 문 이 자동으로 모든 카피 북의 이름을 대문자로 '폴딩'하게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d95a0b3b4408000436885116c035d2b4d4eb090" translate="yes" xml:space="preserve">
          <source>It is possible, if supported by the &quot;curses&quot; package being used, to draw borders on the top, left and/or bottom edges of a field.</source>
          <target state="translated">사용중인 &quot;저주&quot;패키지가 지원하는 경우 필드의 위쪽, 왼쪽 및 / 또는 아래쪽 가장자리에 테두리를 그릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d7394694e1e1adbaef5eeee92d5a9373e538bc3" translate="yes" xml:space="preserve">
          <source>It is recommended to change the CBL_OC routines to CBL_GC for forward compatability as at some point they will be removed as they are a hangover from Open Cobol.</source>
          <target state="translated">순방향 호환성을 위해 CBL_OC 루틴을 CBL_GC로 변경하여 Open Cobol에서 숙취가되어 언젠가는 제거 될 것을 권장합니다.</target>
        </trans-unit>
        <trans-unit id="4bc4bb06183a156efac27d1054572b8c27c65421" translate="yes" xml:space="preserve">
          <source>It is worth mentioning that if the</source>
          <target state="translated">언급하면 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="18a80c8fa72d80aad7d81f986d63eacc53ab4b98" translate="yes" xml:space="preserve">
          <source>It would appear that it should be possible to locate and process any record in the file directly simply by calculating its starting character position based upon the program-defined record size. Even so, however, records must be still be read or written to these files in a purely sequential manner. The only way to read (or write) record number 100 would be to have read (or written) records number 1 through 99 first.</source>
          <target state="translated">프로그램 정의 레코드 크기에 따라 시작 문자 위치를 계산하여 파일에서 레코드를 직접 찾아서 처리 할 수 ​​있어야합니다. 그러나 그럼에도 불구하고 레코드는 순차 순차로 이러한 파일에 계속 읽거나 써야합니다. 레코드 번호 100을 읽거나 쓰는 유일한 방법은 레코드 번호 1-99를 먼저 읽거나 쓰는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6d1a9ad994fd74f3ea9c0abfcfff5c67eb069908" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s impossible to perform any arithmetic operation against an index data item directly (other than a simple incrementation or decremental operation via the&lt;code&gt;SET UP/DOWN&lt;/code&gt;statement (see &lt;a href=&quot;#SET-UP_002fDOWN&quot;&gt;SET UP/DOWN&lt;/a&gt;)). Situations where any non-trivial computations are required to calculate the effective occurrence number for a table reference will require you to use a conventional unedited numeric data item as the receiving field for the calculation. That calculated value would then need to be saved into the index data item via a&lt;code&gt;SET Index&lt;/code&gt;statement.</source>
          <target state="translated">인덱스 데이터 항목에 대해 직접 산술 연산을 수행하는 것은 불가능합니다 ( &lt;code&gt;SET UP/DOWN&lt;/code&gt; 문을 통한 간단한 증분 또는 감산 연산 제외) ( &lt;a href=&quot;#SET-UP_002fDOWN&quot;&gt;SET UP / DOWN&lt;/a&gt; 참조). 테이블 참조의 유효 발생 수를 계산하기 위해 사소한 계산이 필요한 상황에서는 계산을위한 수신 필드로 기존의 편집되지 않은 숫자 데이터 항목을 사용해야합니다. 계산 된 값은 &lt;code&gt;SET Index&lt;/code&gt; 문을 통해 인덱스 데이터 항목에 저장해야 합니다.</target>
        </trans-unit>
        <trans-unit id="48149098c4b72f980cb6ef484a18559b6952ecbd" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s probably a true that an IT professional can no longer afford to allow COBOL to be the</source>
          <target state="translated">IT 전문가가 더 이상 COBOL을</target>
        </trans-unit>
        <trans-unit id="02387685edacc74ddafb8999ab4d02ea233cee8c" translate="yes" xml:space="preserve">
          <source>Items appearing in Mixed Case within a syntax diagram represent complex clauses of other syntax elements that may appear in that position. Some COBOL syntax gets quite complicated, and using a convention such as this significantly reduces the complexity of a syntax diagram. When such items are referenced in text, they will appear as &amp;lt;&amp;lt;</source>
          <target state="translated">구문 다이어그램 내에 대소 문자가 혼합 된 항목은 해당 위치에 나타날 수있는 다른 구문 요소의 복잡한 절을 나타냅니다. 일부 COBOL 구문은 상당히 복잡해지며 이와 같은 규칙을 사용하면 구문 다이어그램의 복잡성이 크게 줄어 듭니다. 이러한 항목이 텍스트로 참조되면 &amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="56625773bdd51fd820fa786a2e0f16b75e88d894" translate="yes" xml:space="preserve">
          <source>JUST, JUSTIFIED</source>
          <target state="translated">그냥 정당화</target>
        </trans-unit>
        <trans-unit id="362a2940964523b043977ef5c326c0da3c417c71" translate="yes" xml:space="preserve">
          <source>JUSTIFIED Attribute Syntax</source>
          <target state="translated">정당한 속성 구문</target>
        </trans-unit>
        <trans-unit id="69d7203c7ddac97c0f7dbb23cc2fe036c4f8c92f" translate="yes" xml:space="preserve">
          <source>Just as multiplication takes precedence over addition in arithmetic expressions, so does&lt;code&gt;AND&lt;/code&gt;take precedence over&lt;code&gt;OR&lt;/code&gt;in combined conditions. Use parenthesis to change this precedence, if necessary. For example:</source>
          <target state="translated">산술 연산 식에서 곱셈이 덧셈보다 우선하고, 결합 된 조건에서 &lt;code&gt;AND&lt;/code&gt; 가 &lt;code&gt;OR&lt;/code&gt; 보다 우선 합니다. 필요한 경우 괄호를 사용하여이 우선 순위를 변경하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7d13eab767d2368877889bd7045a0a16db421d69" translate="yes" xml:space="preserve">
          <source>Just because COBOL doesn&amp;rsquo;t traditionally support objects, classes, and the like doesn&amp;rsquo;t mean that its &quot;procedural&quot; approach to computing isn&amp;rsquo;t valuable &amp;mdash; after all, it runs 70% of the</source>
          <target state="translated">COBOL이 전통적으로 객체, 클래스 등을 지원하지 않는다고해서 컴퓨팅에 대한 &quot;절차&quot;접근 방식이 가치가 없다는 것을 의미하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="eab1ffaceb7e528d02f388bc4a44de1ac999f956" translate="yes" xml:space="preserve">
          <source>Just because the table has one or more&lt;code&gt;KEY&lt;/code&gt;clauses doesn&amp;rsquo;t mean the data is actually</source>
          <target state="translated">테이블에 하나 이상의 &lt;code&gt;KEY&lt;/code&gt; 절이 있다고 해서 데이터가 실제로는 아닙니다</target>
        </trans-unit>
        <trans-unit id="c2d43141ba675c34b7c1d27c2a20a48306114ad6" translate="yes" xml:space="preserve">
          <source>Justifying a field left-, right- or center-aligned</source>
          <target state="translated">필드를 왼쪽, 오른쪽 또는 가운데로 정렬</target>
        </trans-unit>
        <trans-unit id="84f38d3f20c7775e2217cde20dd53b4fca4c4de9" translate="yes" xml:space="preserve">
          <source>KEPT, KEY, KEYBOARD</source>
          <target state="translated">KEPT, KEY, KEYBOARD</target>
        </trans-unit>
        <trans-unit id="a1abb8bae6a20d6d2a3d297fadb85dbb06f153f7" translate="yes" xml:space="preserve">
          <source>Key invalid</source>
          <target state="translated">키가 잘못되었습니다</target>
        </trans-unit>
        <trans-unit id="0dca24f2a9944795f9d4824194f21fc80ddaa094" translate="yes" xml:space="preserve">
          <source>Key not found</source>
          <target state="translated">키를 찾을 수 없습니다</target>
        </trans-unit>
        <trans-unit id="b27d585a06f48010c011f378dec6cda9ce6fe385" translate="yes" xml:space="preserve">
          <source>LABEL. LAST, LC_ALL, LC_COLLATE, LC_CTYPE, LC_MESSAGES, LC_MONETARY, LC_NUMERIC, LC_TIME, LEADING, LEFT, LEFT-JUSTIFY, LEFTLINE, LENGTH, LENGTH-AN, LENGTH-CHECK, LESS, LIMIT, LIMITS, LINAGE, LINAGE-COUNTER, LINE, LINE-COUNTER, LINES, LINKAGE, LOCALE, LOCALE-COMPARE, LOCALE-DATE, LOCALE-TIME, LOCALE-TIME-FROM-SECONDS, LOCAL-STORAGE, LOCK, LOG, LOG10, LOWER, LOWER-CASE, LOWEST-ALGEBRAIC, LOWLIGHT, LOW-VALUE, LOW-VALUES</source>
          <target state="translated">상표. LAST, LC_ALL, LC_COLLATE, LC_CTYPE, LC_MESSAGES, LC_MONETARY, LC_NUMERIC, LC_TIME, LEADING, LEFT, LEFT-JUSTIFY, LEFTLINE, LENGTH, LENGTH-AN, LENGTH-CHECK, LESS, LIMIT, LIMITS, LINAGE, LINEAGE 라인 카운터, 라인, 링키지, 로케일, 로케일 비교, 로케일-날짜, 로케일-시간, 로케일-시간 -ROM- 초, 로칼-스토리지, 잠금, 로그, LOG10, 로어, 로어-케이스, 최저-대수, LOWLIGHT, LOW-VALUE, LOW-VALUES</target>
        </trans-unit>
        <trans-unit id="f7adab25c99ba32828c8334645ed0e592317c0dd" translate="yes" xml:space="preserve">
          <source>LEFTLINE Attribute Syntax</source>
          <target state="translated">LEFTLINE 속성 구문</target>
        </trans-unit>
        <trans-unit id="131342f51da66f70ac3d8ad3a42ad6266e7cfe09" translate="yes" xml:space="preserve">
          <source>LENGTH Function Syntax</source>
          <target state="translated">LENGTH 함수 구문</target>
        </trans-unit>
        <trans-unit id="d74d405b72ac688357a94ddb91f3bd1d36b38a48" translate="yes" xml:space="preserve">
          <source>LENGTH OF Syntax</source>
          <target state="translated">구문의 길이</target>
        </trans-unit>
        <trans-unit id="a6c3bbbb104612f77a62807c2c1de5109220484e" translate="yes" xml:space="preserve">
          <source>LENGTH-AN Function Syntax</source>
          <target state="translated">LENGTH-AN 함수 구문</target>
        </trans-unit>
        <trans-unit id="954f779688b59664bc2c0157a1a346f68764ce28" translate="yes" xml:space="preserve">
          <source>LENGTH-CHECK Attribute Syntax</source>
          <target state="translated">길이 검사 속성 구문</target>
        </trans-unit>
        <trans-unit id="700c1989f8b190ed7e6537ef207d774a560d050f" translate="yes" xml:space="preserve">
          <source>LINE (REPORT SECTION) Clause Syntax</source>
          <target state="translated">LINE (보고서 섹션) 조항 구문</target>
        </trans-unit>
        <trans-unit id="e8f4389c48575a281e9f925b390e924cf0c4233d" translate="yes" xml:space="preserve">
          <source>LINE (SCREEN SECTION) Clause Syntax</source>
          <target state="translated">LINE (스크린 섹션) 조항 구문</target>
        </trans-unit>
        <trans-unit id="e4f2ff384d74fc8578647b7045a783150209d9b6" translate="yes" xml:space="preserve">
          <source>LINKAGE-SECTION-Data-Item</source>
          <target state="translated">LINKAGE-SECTION-Data-Item</target>
        </trans-unit>
        <trans-unit id="6c615d91fc665579223c013c286410416b6e1014" translate="yes" xml:space="preserve">
          <source>LINKAGE-SECTION-Data-Item Syntax</source>
          <target state="translated">연결 섹션 데이터 항목 구문</target>
        </trans-unit>
        <trans-unit id="de80fa7cc22fe7bc720ec1f880b19a375e416fad" translate="yes" xml:space="preserve">
          <source>LOCAL-STORAGE-SECTION-Data-Item</source>
          <target state="translated">LOCAL-STORAGE-SECTION-Data-Item</target>
        </trans-unit>
        <trans-unit id="7aaab284fb19784decbd8f8b27788cee676e6312" translate="yes" xml:space="preserve">
          <source>LOCAL-STORAGE-SECTION-Data-Item Syntax</source>
          <target state="translated">로컬 스토리지 섹션 데이터 항목 구문</target>
        </trans-unit>
        <trans-unit id="43137ffee30418f0ee2f9cddfdfde852be8ee37f" translate="yes" xml:space="preserve">
          <source>LOCALE-COMPARE Function Syntax</source>
          <target state="translated">LOCALE-COMPARE 함수 구문</target>
        </trans-unit>
        <trans-unit id="b1fca96794478203376fc5f182a5206a1cd9879a" translate="yes" xml:space="preserve">
          <source>LOCALE-DATE Function Syntax</source>
          <target state="translated">LOCALE-DATE 함수 구문</target>
        </trans-unit>
        <trans-unit id="bb3ee280b5397e14e50725a5217c3a5d3ba477ce" translate="yes" xml:space="preserve">
          <source>LOCALE-TIME Function Syntax</source>
          <target state="translated">LOCALE-TIME 함수 구문</target>
        </trans-unit>
        <trans-unit id="5471c4a61062a5428ab007db0990af8c067fcb5d" translate="yes" xml:space="preserve">
          <source>LOCALE-TIME-FROM-SECONDS Function Syntax</source>
          <target state="translated">LOCALE-TIME-FROM-SECONDS 함수 구문</target>
        </trans-unit>
        <trans-unit id="37c5bf8af77ce9710567f4d33ea9e7df839040cc" translate="yes" xml:space="preserve">
          <source>LOG Function Syntax</source>
          <target state="translated">LOG 함수 구문</target>
        </trans-unit>
        <trans-unit id="9192c8decf1f9c720375df3f6fa03e112ff20e88" translate="yes" xml:space="preserve">
          <source>LOG10 Function Syntax</source>
          <target state="translated">LOG10 함수 구문</target>
        </trans-unit>
        <trans-unit id="ee7e6e2ad53ef8f056736d307514898fdd404c69" translate="yes" xml:space="preserve">
          <source>LOWER-CASE Function Syntax</source>
          <target state="translated">LOWER-CASE 함수 구문</target>
        </trans-unit>
        <trans-unit id="439e85988349d2d4d56bcd162fc79031cbfe5293" translate="yes" xml:space="preserve">
          <source>LOWEST-ALGEBRAIC Function Syntax</source>
          <target state="translated">최저 대수 함수 구문</target>
        </trans-unit>
        <trans-unit id="a8456caa490bee9c2c0be989a83696a4f186cc13" translate="yes" xml:space="preserve">
          <source>LOWLIGHT Attribute Syntax</source>
          <target state="translated">LOWLIGHT 속성 구문</target>
        </trans-unit>
        <trans-unit id="b77f5ed95a31f852095a500e8931cb13a5b9471b" translate="yes" xml:space="preserve">
          <source>Language DIVISION, SECTION and paragraph section headers must begin in Area A, as must the level numbers 01, 77 in data description entries and the &quot;FD&quot; and &quot;SD&quot; file and SORT description headers.</source>
          <target state="translated">언어 DIVISION, SECTION 및 단락 섹션 헤더는 영역 A에서 시작해야하며 데이터 설명 항목의 레벨 번호 01, 77 및 &quot;FD&quot;및 &quot;SD&quot;파일 및 SORT 설명 헤더와 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="1882dc6a1967f34bbac58b9f9a979e4a9b63398b" translate="yes" xml:space="preserve">
          <source>Later, when you wish to compile a calling program and combine any needed assembly language subroutines in (as static subroutines &amp;mdash; see &lt;a href=&quot;#Dynamic-vs-Static-Subprograms&quot;&gt;Dynamic vs Static Subprograms&lt;/a&gt;), use a command such as this:</source>
          <target state="translated">나중에 호출 프로그램을 컴파일하고 필요한 어셈블리 언어 서브 루틴을 정적 서브 루틴 ( &lt;a href=&quot;#Dynamic-vs-Static-Subprograms&quot;&gt;동적 vs 정적 서브 프로그램&lt;/a&gt; 참조 )으로 결합하려면 다음과 같은 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="66985c4b56238cdffd3d626011e0ae9656911e65" translate="yes" xml:space="preserve">
          <source>Leading and/or trailing spaces are allowed, as are spaces before and/or after any sign characters.</source>
          <target state="translated">선행 및 / 또는 후행 공백은 부호 문자 앞뒤 및 공백과 같이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="0ff8a66126e2608d00693ba8dd0efcf5b6c8473c" translate="yes" xml:space="preserve">
          <source>Leading and/or trailing spaces are allowed, as are spaces before and/or after the currency symbol, sign, CR and DB characters.</source>
          <target state="translated">통화 기호, 부호, CR 및 DB 문자 앞뒤에 공백과 마찬가지로 선행 및 / 또는 후행 공백이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="13235fcc87f3e6e8669414dd697a803db485fc34" translate="yes" xml:space="preserve">
          <source>Leading and/or trailing spaces are allowed, as are spaces before and/or after the sign, CR and DB characters.</source>
          <target state="translated">선행 및 / 또는 후행 공백이 허용되며 부호 앞뒤의 공백, CR 및 DB 문자가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="6d1192545a490f725efd7534bb1ad77133927978" translate="yes" xml:space="preserve">
          <source>Legend has it that there&amp;rsquo;s actually only been ONE program ever written in COBOL, and all programs ever &quot;written&quot; thereafter were simply derivatives of that one. Although this is clearly intended as a (probably) bad joke, it is nevertheless close to the very simple truth that many programmers&quot;reuse&quot; existing COBOL programs when creating new ones. There&amp;rsquo;s certainly nothing preventing this from happening with programs written in other languages, but it does seem to happen more in COBOL shops. It&amp;rsquo;s ironic that &quot;code re-usability&quot; is one of the arguments used to justify the existence of the &quot;modern&quot; languages.</source>
          <target state="translated">전설에 따르면 실제로 COBOL로 작성된 프로그램은 하나 뿐이며 이후 &quot;작성된&quot;모든 프로그램은 그 프로그램의 파생물 일뿐입니다. 비록 이것이 아마도 나쁜 농담으로 의도되었지만, 많은 프로그래머들이 새로운 코볼 프로그램을 만들 때 기존 COBOL 프로그램을 &quot;재사용&quot;한다는 것은 매우 단순한 사실에 가깝습니다. 다른 언어로 작성된 프로그램에서 이런 일이 발생하는 것을 막을 수는 없지만 COBOL 상점에서는 더 많이 발생하는 것 같습니다. &quot;코드 재사용 성&quot;이 &quot;현대&quot;언어의 존재를 정당화하는 데 사용되는 주장 중 하나라는 것은 아이러니 한 일입니다.</target>
        </trans-unit>
        <trans-unit id="0b3fb64877d0da3cc80aa54b2402a8b8eaf24bde" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at a different problem. Surely a program that asks a user to input a positive integer, generates the sum of all positive integers from 1 to that number and then prints the result will be MUCH shorter and MUCH easier to understand when coded in Java than in COBOL, right?</source>
          <target state="translated">다른 문제를 봅시다. 분명히 사용자에게 양의 정수를 입력하도록 요청하고 1에서 그 숫자까지의 모든 양의 정수의 합을 생성 한 다음 결과를 인쇄하면 COBOL보다 Java로 코딩 할 때 이해하기가 훨씬 짧고 이해하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="26e5808de92654f265239c37c8e3bd7a273163fd" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at how much more &quot;wordy&quot; COBOL is than Java. Count the characters in the two programs. The Java program has 95 (not counting carriage returns and any indentation). The COBOL program has 89 (again, not counting carriage returns and indentation)! Technically, it could have been only 65 because the&lt;code&gt;IDENTIFICATION DIVISION.&lt;/code&gt;header is actually optional. Clearly, &quot;Hello World&quot; doesn&amp;rsquo;t look any more concise in Java than it does in COBOL.</source>
          <target state="translated">Java보다 얼마나 &quot;협잡 한&quot;COBOL이 있는지 살펴 보자. 두 프로그램에서 문자를 세십시오. Java 프로그램에는 95가 있습니다 (캐리지 리턴 및 들여 쓰기 제외). COBOL 프로그램에는 89가 있습니다 (캐리지 리턴 및 들여 쓰기를 세지 않음)! 기술적으로, &lt;code&gt;IDENTIFICATION DIVISION.&lt;/code&gt; 인해 65 세에 불과했습니다 . 헤더는 실제로 선택 사항입니다. 분명히 &quot;Hello World&quot;는 COBOL보다 Java에서 더 간결하게 보이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="963bbbacb61f8751db91170e221a486a9a4d3b42" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say the 3x4 &quot;grid&quot; defined by the above structure has these values:</source>
          <target state="translated">위 구조로 정의 된 3x4 &quot;그리드&quot;에 다음 값이 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="807ef358de181fc6f5a56bc69f36677531a8d93e" translate="yes" xml:space="preserve">
          <source>Level 1 (Highest) &amp;mdash; Unary Sign Specification &lt;code&gt;+&lt;/code&gt;and&lt;code&gt;-&lt;/code&gt;with a single argument)</source>
          <target state="translated">수준 1 (가장 높음) &amp;mdash; 단항 부호 사양 &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;-&lt;/code&gt; 단일 인수 사용)</target>
        </trans-unit>
        <trans-unit id="c0776e45f0a30777bc589139ec70ff962e33c83c" translate="yes" xml:space="preserve">
          <source>Level 2 &amp;mdash; Exponentiation &lt;code&gt;**&lt;/code&gt;or&lt;code&gt;^&lt;/code&gt;</source>
          <target state="translated">수준 2 &amp;mdash; 지수 &lt;code&gt;**&lt;/code&gt; 또는 &lt;code&gt;^&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6d3eb2924374b17ead104f2e6704337373d534b" translate="yes" xml:space="preserve">
          <source>Level 3 &amp;mdash; Multiplication &lt;code&gt;*&lt;/code&gt; and division &lt;code&gt;/&lt;/code&gt;</source>
          <target state="translated">레벨 3 &amp;mdash; 곱하기 &lt;code&gt;*&lt;/code&gt; 와 나누기 &lt;code&gt;/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76c7a53b8aaf3b4d3d4c40f9ab98b835416a16f8" translate="yes" xml:space="preserve">
          <source>Level 4 &amp;mdash; Addition &lt;code&gt;+&lt;/code&gt; or subtraction &lt;code&gt;+&lt;/code&gt;</source>
          <target state="translated">4 단계 &amp;mdash; 더하기 &lt;code&gt;+&lt;/code&gt; 또는 빼기 &lt;code&gt;+&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5597f96dc9d80c27ec5e33857991562ca948cabc" translate="yes" xml:space="preserve">
          <source>Level Number</source>
          <target state="translated">레벨 번호</target>
        </trans-unit>
        <trans-unit id="3052fa9dd47259fbdfdaada2330b8f6e3cbdd9ac" translate="yes" xml:space="preserve">
          <source>Level numbers 66, 77, 78 and 88 all have special uses &amp;mdash; See &lt;a href=&quot;#Special-Data-Items&quot;&gt;Special Data Items&lt;/a&gt;, for details.</source>
          <target state="translated">레벨 번호 66, 77, 78 및 88은 모두 특수 용도로 사용됩니다. 자세한 내용은 &lt;a href=&quot;#Special-Data-Items&quot;&gt;특수 데이터 항목&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c40b4c76be763282435e76a210c233701e5f2f23" translate="yes" xml:space="preserve">
          <source>Level numbers 66, 77, 78 and 88 identify special properties of a data description entry.</source>
          <target state="translated">레벨 번호 66, 77, 78 및 88은 데이터 설명 항목의 특수 속성을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="f058b290679bb97e2e65e2ade8e908cf0471986c" translate="yes" xml:space="preserve">
          <source>Level numbers in the range 1 through 49 indicate the position of a data item in the hierarchical structure of a logical record. Level numbers in the range 1 through 9 can be written either as a single digit or as a zero followed by the significant digit.</source>
          <target state="translated">1-49 범위의 레벨 번호는 논리 레코드의 계층 구조에서 데이터 항목의 위치를 ​​나타냅니다. 1-9 범위의 레벨 번호는 단일 숫자 또는 0과 유효 숫자 뒤에 기록 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d0db8c2b020268e4b2e48ddcbb42e59195d905a" translate="yes" xml:space="preserve">
          <source>Licensed under the GNU Free Documentation License.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c7be671b82e536f670976ec80f415fa5dd43afc" translate="yes" xml:space="preserve">
          <source>Like line sequential files, these files should not be defined to contain any exact binary data fields because the contents of those fields could inadvertently have the end-of-record sequence as part of their values &amp;mdash; this would confuse the runtime system when reading the file, and it would interpret that value as an actual end-of-record sequence.</source>
          <target state="translated">행 순차 파일과 같이 이러한 파일은 해당 2 진 데이터 필드를 포함하도록 정의되어서는 안됩니다. 해당 필드의 내용이 실수로 레코드 끝 순서를 값의 일부로 가질 수 있기 때문에 파일을 읽을 때 런타임 시스템이 혼동 될 수 있습니다. 이 값을 실제 레코드 끝 시퀀스로 해석합니다.</target>
        </trans-unit>
        <trans-unit id="57489ee4e43a2ed5c736dd719377be4582a70ea3" translate="yes" xml:space="preserve">
          <source>Like most other implementations of the COBOL language, GnuCOBOL utilizes a run-time library. When the first program executed in a given execution sequence is a GnuCOBOL program, any run-time library initialization will be performed by the compiled COBOL code in a manner that is transparent to the C-language programmer. If, however, a C program is the first to execute, the burden of performing GnuCOBOL run-time library initialization falls upon the C program. See &lt;a href=&quot;#C-Main-Programs-Calling-GnuCOBOL-Subprograms&quot;&gt;C Main Programs Calling GnuCOBOL Subprograms&lt;/a&gt;, for an example of how to do this.</source>
          <target state="translated">다른 대부분의 COBOL 언어 구현과 마찬가지로 GnuCOBOL은 런타임 라이브러리를 사용합니다. 주어진 실행 시퀀스에서 실행 된 첫 번째 프로그램이 GnuCOBOL 프로그램 인 경우, 런타임 라이브러리 초기화는 C 언어 프로그래머에게 투명한 방식으로 컴파일 된 COBOL 코드에 의해 수행됩니다. 그러나 C 프로그램이 처음으로 실행되는 경우 GnuCOBOL 런타임 라이브러리 초기화 수행 부담은 C 프로그램에 달려 있습니다. 이를 수행하는 방법에 대한 예제는 &lt;a href=&quot;#C-Main-Programs-Calling-GnuCOBOL-Subprograms&quot;&gt;GnuCOBOL 서브 프로그램 호출 C 기본 프로그램을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="57fb879374ae97e5eb278f255c02c63fea22e809" translate="yes" xml:space="preserve">
          <source>Line Sequential files are processed using the following statements:</source>
          <target state="translated">행 순차 파일은 다음 명령문을 사용하여 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="92e97e035f44f8980e413b0d3167603ea36902ee" translate="yes" xml:space="preserve">
          <source>Literal</source>
          <target state="translated">Literal</target>
        </trans-unit>
        <trans-unit id="44ac976e13987b2e461319b6b07bf2f1d2977574" translate="yes" xml:space="preserve">
          <source>Little-Endian</source>
          <target state="translated">Little-Endian</target>
        </trans-unit>
        <trans-unit id="226d589b5f25caf9198d123daff4d9daae8eba87" translate="yes" xml:space="preserve">
          <source>Little-endian data allocation calls for the bytes that comprise a binary item to be allocated such that the least-significant byte is the left-most byte. For example, a four-byte binary item having a value of decimal 20 would be little-endian allocated as 14000000 (shown in hexadecimal notation).</source>
          <target state="translated">리틀 엔디안 데이터 할당은 가장 중요하지 않은 바이트가 가장 왼쪽 바이트가되도록 할당 할 이진 항목을 구성하는 바이트를 요구합니다. 예를 들어, 10 진수 값이 20 인 4 바이트 2 진 항목은 14000000 (16 진수 표기법으로 표시)으로 리틀 엔디안이 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="835de5c115f7b3e75f88f1bf5d8aaf4ad47e0bd8" translate="yes" xml:space="preserve">
          <source>Local-storage cannot be used in nested subprograms.</source>
          <target state="translated">로컬 서브 시스템은 중첩 서브 프로그램에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a5e093ebdd409890bed85c2fed42792048e3ee67" translate="yes" xml:space="preserve">
          <source>Local-storage, if any, is de-allocated.</source>
          <target state="translated">로컬 스토리지 (있는 경우)가 할당 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="3690da6677c866b7070485f97c20dfa1fc2058b7" translate="yes" xml:space="preserve">
          <source>Local-storage, if any, will be allocated and initialized.</source>
          <target state="translated">로컬 스토리지 (있는 경우)가 할당되고 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="029c39972ba6042647e3f70b02f4bd91260e9fb3" translate="yes" xml:space="preserve">
          <source>Locator</source>
          <target state="translated">Locator</target>
        </trans-unit>
        <trans-unit id="8d02c4cdcb2b9946ab2619bfecc5df1af1b12a02" translate="yes" xml:space="preserve">
          <source>Locks acquired vie multiple record locking remain in-effect until the program holding the lock&amp;hellip;</source>
          <target state="translated">다중 레코드 잠금을 통해 획득 한 잠금은 프로그램이 잠금을 보유 할 때까지 영향을받지 않습니다&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="be9a3c255cc059f59d89184276ee44ce2ff74a47" translate="yes" xml:space="preserve">
          <source>MAGNETIC-TAPE, MANUAL, MAX, MEAN, MEDIAN, MEMORY, MERGE, MESSAGE, METHOD, METHOD-ID, MIDRANGE, MIN, MINUS, MOD, MODE, MODULE-CALLER-ID, MODULE-DATE, MODULE-FORMATTED-DATE, MODULE-ID, MODULE-PATH, MODULES, MODULE-SOURCE, MODULE-TIME, MONETARY-DECIMAL-POINT, MONETARY-THOUSANDS-SEPARATOR, MOVE, MULTIPLE, MULTIPLY</source>
          <target state="translated">자기 테이프, 수동, 최대, 평균, 중간, 메모리, 병합, 메시지, 방법, 방법 ID, 중간 범위, 최소, 최소, 모드, 모드, 모듈러 ID, 모듈 날짜, 모듈 형식 날짜, 모듈 식 ID, 모듈 식 경로, 모듈 식, 모듈 식 소스, 모듈 식 시간, 금전적 소수점, 금전적-분리기, 이동, 다중, 복수</target>
        </trans-unit>
        <trans-unit id="57e71373c55e995e80f24e3f2087d0a7b5dbbec9" translate="yes" xml:space="preserve">
          <source>MAX Function Syntax</source>
          <target state="translated">MAX 함수 구문</target>
        </trans-unit>
        <trans-unit id="0abf13bfa8b362e60f0cf8bd2bacaab30d7f67c9" translate="yes" xml:space="preserve">
          <source>MEAN Function Syntax</source>
          <target state="translated">MEAN 함수 구문</target>
        </trans-unit>
        <trans-unit id="31a496c910f49ef35450cbdb8cbc4374b9f67273" translate="yes" xml:space="preserve">
          <source>MEDIAN Function Syntax</source>
          <target state="translated">MEDIAN 함수 구문</target>
        </trans-unit>
        <trans-unit id="daee7fdd946c270a9b400d0cb5b7e42fe5872e0c" translate="yes" xml:space="preserve">
          <source>MERGE Syntax</source>
          <target state="translated">병합 구문</target>
        </trans-unit>
        <trans-unit id="c8035dd19f4b057f89b85a604ee1af37d346e31e" translate="yes" xml:space="preserve">
          <source>MIDRANGE Function Syntax</source>
          <target state="translated">MIDRANGE 함수 구문</target>
        </trans-unit>
        <trans-unit id="b3922fba0ffbf0d82c96e71393fb62e945ccf5b9" translate="yes" xml:space="preserve">
          <source>MIN Function Syntax</source>
          <target state="translated">MIN 함수 구문</target>
        </trans-unit>
        <trans-unit id="6df76c53746f58160bf9ed45943e438821905bb2" translate="yes" xml:space="preserve">
          <source>MOD Function Syntax</source>
          <target state="translated">MOD 함수 구문</target>
        </trans-unit>
        <trans-unit id="fb9072e5497502c8b0c9f0cc92c12083bdb2cecc" translate="yes" xml:space="preserve">
          <source>MODULE-CALLER-ID Function Syntax</source>
          <target state="translated">모듈러 ID 기능 구문</target>
        </trans-unit>
        <trans-unit id="77023dbd5e71addbd6ecdf7b0de7955c05a7cbcc" translate="yes" xml:space="preserve">
          <source>MODULE-DATE Function Syntax</source>
          <target state="translated">모듈 날짜 함수 구문</target>
        </trans-unit>
        <trans-unit id="e4f1aeb1a72fe45f289846eea035900277d6474e" translate="yes" xml:space="preserve">
          <source>MODULE-FORMATTED-DATE Function Syntax</source>
          <target state="translated">모듈 식 날짜 함수 구문</target>
        </trans-unit>
        <trans-unit id="e4708a13b25aed7fbcdde2ed7eb4f478e4e5a0d2" translate="yes" xml:space="preserve">
          <source>MODULE-ID Function Syntax</source>
          <target state="translated">모듈 ID 함수 구문</target>
        </trans-unit>
        <trans-unit id="9c157b8be74a13e0253ff0fdbcddcca6237613e4" translate="yes" xml:space="preserve">
          <source>MODULE-PATH Function Syntax</source>
          <target state="translated">모듈 경로 함수 구문</target>
        </trans-unit>
        <trans-unit id="6aeac5d8bb6edf96b2cc15b2e1900d618339fe87" translate="yes" xml:space="preserve">
          <source>MODULE-SOURCE Function Syntax</source>
          <target state="translated">모듈 소스 함수 구문</target>
        </trans-unit>
        <trans-unit id="9ba6dae63e2adfd381389ee805e05d8f98957c6a" translate="yes" xml:space="preserve">
          <source>MODULE-TIME Function Syntax</source>
          <target state="translated">MODULE-TIME 함수 구문</target>
        </trans-unit>
        <trans-unit id="f73ead11798a2b39d355bdb9cc3ee0afd6c73ca2" translate="yes" xml:space="preserve">
          <source>MONETARY-DECIMAL-POINT Function Syntax</source>
          <target state="translated">MOTORARY-DECIMAL-POINT 함수 구문</target>
        </trans-unit>
        <trans-unit id="f959bf7a22a6fa8fd96fe2dd391a08fa5dd22aa0" translate="yes" xml:space="preserve">
          <source>MONETARY-THOUSANDS-SEPARATOR Function Syntax</source>
          <target state="translated">통화-천-분리기 함수 구문</target>
        </trans-unit>
        <trans-unit id="ec0648f1ef8e6f8e156101c88dcd2b9563d62924" translate="yes" xml:space="preserve">
          <source>MOVE CORRESPONDING Syntax</source>
          <target state="translated">이동 구문</target>
        </trans-unit>
        <trans-unit id="569fe924e80927234226e1da480e2aaeb896476b" translate="yes" xml:space="preserve">
          <source>MULTIPLY BY Syntax</source>
          <target state="translated">여러 구문으로</target>
        </trans-unit>
        <trans-unit id="3ad347c2697684ef0953e3a767d0bc1635d31d5a" translate="yes" xml:space="preserve">
          <source>MULTIPLY GIVING Syntax</source>
          <target state="translated">다양한 기부 구문</target>
        </trans-unit>
        <trans-unit id="412299ff020a7154d245c3b0f04152fc824d367f" translate="yes" xml:space="preserve">
          <source>Magenta: COB-COLOR-MAGENTA</source>
          <target state="translated">마젠타 : COB-COLOR-MAGENTA</target>
        </trans-unit>
        <trans-unit id="4ad990da0619f2f6612747fd3b18ae051e2e5eca" translate="yes" xml:space="preserve">
          <source>Main Program</source>
          <target state="translated">메인 프로그램</target>
        </trans-unit>
        <trans-unit id="62df8b8e9bbaa8bb9f1517aa2bf38f13fc37e36a" translate="yes" xml:space="preserve">
          <source>Main program</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="154c8bfc5f3e601547791b40d3a205f6ed780b67" translate="yes" xml:space="preserve">
          <source>Main programs compiled in this manner should be executed as follows:</source>
          <target state="translated">이러한 방식으로 컴파일 된 주요 프로그램은 다음과 같이 실행되어야합니다.</target>
        </trans-unit>
        <trans-unit id="ad9766c462696f99f3025a340a18914544b7bff9" translate="yes" xml:space="preserve">
          <source>Main programs that wish to &quot;pass back&quot; a return code value to the operating system when they exit do not use RETURNING - they do so simply by MOVEing a value to the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register.</source>
          <target state="translated">종료시 리턴 코드 값을 운영 체제로 &quot;패스 백&quot;하려는 기본 프로그램은 RETURNING을 사용하지 않습니다. 단순히 &lt;code&gt;RETURN-CODE&lt;/code&gt; 특수 레지스터 로 값을 이동하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="7a5053f6a0e7ffe3e98db384f4662350eb992d81" translate="yes" xml:space="preserve">
          <source>Management of areas on the printed page such as top-of page headers, bottom-of-page footers, dealing with &quot;full page&quot; situations and the like are now the joint responsibility of the programmer and the GnuCOBOL run-time library, which provides tools such as the&lt;code&gt;LINAGE-COUNTER&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) and the&lt;code&gt;END-OF-PAGE&lt;/code&gt;</source>
          <target state="translated">&quot;전체 페이지&quot;상황 등을 처리하는 페이지 상단 머리글, 페이지 하단 바닥 글과 같은 인쇄 페이지의 영역 관리는 이제 프로그래머와 GnuCOBOL 런타임 라이브러리의 공동 책임입니다. 예를 들면 같은 도구 &lt;code&gt;LINAGE-COUNTER&lt;/code&gt; 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터&lt;/a&gt; )와 &lt;code&gt;END-OF-PAGE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="535d01a3bb7e25e935da4ad3d0028806321932cc" translate="yes" xml:space="preserve">
          <source>Management of areas on the printed page such as top-of page headers, bottom-of-page footers, dealing with &quot;full page&quot; situations and the like are the complete responsibility of the programmer.</source>
          <target state="translated">&quot;전체 페이지&quot;상황 등을 다루는 페이지 상단 머리글, 페이지 하단 바닥 글과 같은 인쇄 된 페이지 영역 관리는 프로그래머의 전적인 책임입니다.</target>
        </trans-unit>
        <trans-unit id="5d904664fde10f48cc22ff0d5ed913f64ac37406" translate="yes" xml:space="preserve">
          <source>Many COBOL compilers do not allow the use of&lt;code&gt;VALUE&lt;/code&gt;and&lt;code&gt;OCCURS&lt;/code&gt;(see &lt;a href=&quot;#OCCURS&quot;&gt;OCCURS&lt;/a&gt;) on the same data item; additionally, they don&amp;rsquo;t allow a&lt;code&gt;VALUE&lt;/code&gt;clause on a data item subordinate to an&lt;code&gt;OCCURS&lt;/code&gt; GnuCOBOL, however, has neither of these restrictions!</source>
          <target state="translated">많은 COBOL 컴파일러는 동일한 데이터 항목에 &lt;code&gt;VALUE&lt;/code&gt; 및 &lt;code&gt;OCCURS&lt;/code&gt; ( &lt;a href=&quot;#OCCURS&quot;&gt;OCCURS&lt;/a&gt; 참조 )를 사용할 수 없습니다 . 또한 &lt;code&gt;OCCURS&lt;/code&gt; GnuCOBOL에 종속 된 데이터 항목에 &lt;code&gt;VALUE&lt;/code&gt; 절을 허용하지 않지만 이러한 제한은 없습니다!</target>
        </trans-unit>
        <trans-unit id="cec330cac6c061d7cea06b901961f17d2342ed88" translate="yes" xml:space="preserve">
          <source>Many systems have program-development tools available to ease the task of coding programs; those tools that concentrate on COBOL are capable of providing templates for much of the &quot;overhead&quot; verbiage of any program&amp;hellip;</source>
          <target state="translated">많은 시스템에는 프로그램 코딩 작업을 쉽게 수행 할 수있는 프로그램 개발 도구가 있습니다. COBOL에 중점을 둔 도구는 모든 프로그램의 &quot;오버 헤드&quot;에 대한 템플릿을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bea0e296af322cedefa66548ccd5635e5218df89" translate="yes" xml:space="preserve">
          <source>Many times these businesses are finding the cost of the system/networking engineering, operational management and monitoring and risk management (i.e. disaster recovery) infrastructures necessary to support truly mission-critical applications to be so high that the &quot;less-expensive&quot; solution really isn&amp;rsquo;t; in these cases the mainframe may remain the best option, thus leaving COBOL in play and businesses seeking another solution for at least part of their application base.</source>
          <target state="translated">이러한 비즈니스는 여러 번 이러한 시스템에서 네트워킹, 엔지니어링 관리, 운영 관리 및 모니터링 및 위험 관리 (예 : 재난 복구) 인프라의 비용을 찾아야 미션 크리티컬 한 응용 프로그램을 지원하여 &quot;비싼&quot;솔루션이 될 정도로 '티; 이 경우 메인 프레임이 최상의 옵션으로 남아있을 수 있으므로 COBOL을 사용하고 비즈니스는 애플리케이션 기반의 적어도 일부를위한 다른 솔루션을 찾고 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c7162a608e9a76bc0cf997699b25c2bb027fd85" translate="yes" xml:space="preserve">
          <source>Marking changes becomes more of a challenge when free-format source code is in effect. Creating a top-of-program comment block to generically describe changes that have been made isn&amp;rsquo;t difficult, even in free-form. What IS difficult, however, is coming up with a scheme for per-statement mark up of changes that doesn&amp;rsquo;t introduce a ridiculously excessive number of source lines to the program. I&amp;rsquo;m not sure there is a good answer to this problem (if a reader has one, please let me know). Generally, I&amp;rsquo;ve noticed that shops using free-format conventions for their COBOL source tend to stick with just the top-of-program comment block combined with minimal comment blocks sprinkled throughout the program noting areas that underwent major changes.</source>
          <target state="translated">자유 형식 소스 코드가 적용되면 변경 사항을 표시하는 것이 더 어려워집니다. 작성된 변경 사항을 일반적으로 설명하기 위해 프로그램 상단 주석 블록을 작성하는 것은 자유 형식에서도 어렵지 않습니다. 그러나 어려운 점은 프로그램에 엄청나게 많은 수의 소스 라인을 도입하지 않는 변경 사항에 대한 문별 마크 업 체계를 제시하는 것입니다. 이 문제에 대한 좋은 답변이 있는지 잘 모르겠습니다 (독자가있는 경우 알려주세요). 일반적으로 COBOL 소스에 대해 자유 형식 규칙을 사용하는 상점은 주요 변경 사항이 발생한 영역을 지적하면서 프로그램 전체에 뿌려지는 최소 주석 블록과 결합 된 최고 프로그램 주석 블록 만 사용하는 경향이 있음을 알았습니다.</target>
        </trans-unit>
        <trans-unit id="44df495b9a46d581843f66787d274a1a7bcc6fc8" translate="yes" xml:space="preserve">
          <source>Matching up GnuCOBOL numeric Usage s with their C language data type equivalents is possible via the following chart:</source>
          <target state="translated">다음 차트를 통해 GnuCOBOL 숫자 사용법과 C 언어 데이터 유형을 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="f15a625eabeb2b9b8fbf957ba6acb6ea6384e8c2" translate="yes" xml:space="preserve">
          <source>Meaning if 0</source>
          <target state="translated">0의 의미</target>
        </trans-unit>
        <trans-unit id="0b296b5b70a4eb122d3023d41ac6ce6b7484aab3" translate="yes" xml:space="preserve">
          <source>Meaning if 1</source>
          <target state="translated">1의 의미</target>
        </trans-unit>
        <trans-unit id="f99e481919f7772162edf428466c40acaa045b03" translate="yes" xml:space="preserve">
          <source>Most &amp;lt;</source>
          <target state="translated">대부분 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="f9aaebcdc913ba77329c6f07dbfd334a3e319cb4" translate="yes" xml:space="preserve">
          <source>Most COBOL programmers, when using&lt;code&gt;WITH TEST BEFORE&lt;/code&gt;explicitly or implicitly have developed the habit of using &quot;&amp;gt;&quot; rather than &quot;=&quot; on&lt;code&gt;UNTIL&lt;/code&gt;clauses. This would make the sample code:</source>
          <target state="translated">&lt;code&gt;WITH TEST BEFORE&lt;/code&gt; 를 명시 적 또는 암시 적으로 사용할 때 대부분의 COBOL 프로그래머 는 &lt;code&gt;UNTIL&lt;/code&gt; 절 에서 &quot;=&quot;대신 &quot;&amp;gt;&quot;를 사용하는 습관을 개발했습니다 . 이것은 샘플 코드를 만들 것입니다 :</target>
        </trans-unit>
        <trans-unit id="af302c911fcda5124147255d68b3ea18b4163a54" translate="yes" xml:space="preserve">
          <source>Most of the call-by-number routines have evolved into even more powerful call-by-name routines, many of which are supported by GnuCOBOL.</source>
          <target state="translated">대부분의 번호순 전화 루틴은 훨씬 더 강력한 이름순 전화 루틴으로 발전했으며 그 중 많은 것이 GnuCOBOL에 의해 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="817d5274cb3dad555ae670d47cd2b238950e0a1b" translate="yes" xml:space="preserve">
          <source>Most other COBOL implementations reject the use of multiple occurrences of multiple floating editing symbols. For example, they would reject &amp;lt;</source>
          <target state="translated">대부분의 다른 COBOL 구현은 여러 번의 여러 부동 편집 기호 사용을 거부합니다. 예를 들어, 그들은 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="bd8dc228cac7dc6165d9a7427a86371a364ab9e9" translate="yes" xml:space="preserve">
          <source>Moving files (a destructive &quot;copy&quot;)</source>
          <target state="translated">파일 이동 (파괴적인 &quot;복사&quot;)</target>
        </trans-unit>
        <trans-unit id="8068c142bfb974eaa19e904ed221669dae03ee9c" translate="yes" xml:space="preserve">
          <source>Multiple programs, separated from one another by&lt;code&gt;END PROGRAM&lt;/code&gt;or&lt;code&gt;END FUNCTION&lt;/code&gt;statements. The final program in such a source code file need not have an&lt;code&gt;END PROGRAM&lt;/code&gt;or&lt;code&gt;END FUNCTION&lt;/code&gt;statement.</source>
          <target state="translated">&lt;code&gt;END PROGRAM&lt;/code&gt; 또는 &lt;code&gt;END FUNCTION&lt;/code&gt; 문으로 서로 분리 된 여러 프로그램 . 이러한 소스 코드 파일의 최종 프로그램에는 &lt;code&gt;END PROGRAM&lt;/code&gt; 또는 &lt;code&gt;END FUNCTION&lt;/code&gt; 문 이 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="02160c2d59fcbe5c753ac574ebfed903f459af79" translate="yes" xml:space="preserve">
          <source>Multiple space-delimited tokens may be treated as a single token by enclosing them in quotes. For example, there are only three tokens generated from the command line &lt;code&gt;C:\Pgms\myprog.exe &quot;THIS IS A&quot; TEST&lt;/code&gt; &amp;mdash; &quot;C:\Pgms\myprog.exe&quot;, &quot;THIS IS A&quot; and &quot;TEST&quot;. When quote characters are used to create multi-word tokens, the quote characters themselves are stripped from the token&amp;rsquo;s value.</source>
          <target state="translated">공백으로 구분 된 여러 토큰은 따옴표로 묶어 단일 토큰으로 취급 될 수 있습니다. 예를 들어 명령 줄 &lt;code&gt;C:\Pgms\myprog.exe &quot;THIS IS A&quot; TEST&lt;/code&gt; &amp;mdash; &quot;C : \ Pgms \ myprog.exe&quot;, &quot;THIS IS A&quot;및 &quot;TEST&quot; 에서 생성 된 토큰은 3 개뿐입니다 . 따옴표 문자를 사용하여 다중 단어 토큰을 만들면 따옴표 문자 자체가 토큰 값에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="0c9327341de5e837b95068cae1399d3901498283" translate="yes" xml:space="preserve">
          <source>Multiple-item search strings can be specified using the&lt;code&gt;==&amp;lt;&lt;i&gt;pseudo-text-1&lt;/i&gt;&amp;gt;==&lt;/code&gt;option. For example, to replace all occurrences of&lt;code&gt;UPON PRINTER&lt;/code&gt; you would specify&lt;code&gt;==UPON PRINTER==&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;==&amp;lt;&lt;i&gt;pseudo-text-1&lt;/i&gt;&amp;gt;==&lt;/code&gt; 옵션을 사용하여 여러 항목 검색 문자열을 지정할 수 있습니다 . 예를 들어, 모든 &lt;code&gt;UPON PRINTER&lt;/code&gt; 항목을 바꾸 려면 &lt;code&gt;==UPON PRINTER==&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="512c7a9b64ee7852d8007b60e8e382406285cb64" translate="yes" xml:space="preserve">
          <source>Multiple&lt;code&gt;/&lt;/code&gt;symbols may be coded.</source>
          <target state="translated">여러 개의 &lt;code&gt;/&lt;/code&gt; 기호가 코딩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bb573db89249b4de6d85f0d6303b423ef55f890" translate="yes" xml:space="preserve">
          <source>Multiple&lt;code&gt;0&lt;/code&gt;symbols may be coded.</source>
          <target state="translated">다수의 &lt;code&gt;0&lt;/code&gt; 심볼이 코딩 될 수있다.</target>
        </trans-unit>
        <trans-unit id="4e4e78bcc251379bcccaef2662ec5c92b786e53d" translate="yes" xml:space="preserve">
          <source>Multiple&lt;code&gt;B&lt;/code&gt;symbols may be coded.</source>
          <target state="translated">다수의 &lt;code&gt;B&lt;/code&gt; 심볼이 코딩 될 수있다.</target>
        </trans-unit>
        <trans-unit id="4272ab5411f12b91ef6d0e34934e3b2c6d362159" translate="yes" xml:space="preserve">
          <source>Multiply the result of this function times the desired principal amount to determine the amount of each period&amp;rsquo;s payment.</source>
          <target state="translated">이 함수의 결과에 원하는 원금 금액을 곱하여 각 기간의 지불 금액을 결정하십시오.</target>
        </trans-unit>
        <trans-unit id="257327ddfd98406ae03a0f3e1b7b410f8b01fe5e" translate="yes" xml:space="preserve">
          <source>My familiarity with COBOL may be prejudicing my opinion, but it doesn&amp;rsquo;t appear to me that the Java code is any simpler than the COBOL code. In case you&amp;rsquo;re interested in character counts, the Java code comes in at 278 (not counting indentation characters). The COBOL code is 298 (274 without the&lt;code&gt;IDENTIFICATION DIVISION.&lt;/code&gt;header).</source>
          <target state="translated">COBOL에 대해 잘 알고 있으면 내 의견이 편견 일 수 있지만 Java 코드가 COBOL 코드보다 간단한 것으로 보이지는 않습니다. 문자 수에 관심이있는 경우 Java 코드는 278 (들여 쓰기 문자는 제외)로 제공됩니다. COBOL 코드는 298입니다 ( &lt;code&gt;IDENTIFICATION DIVISION.&lt;/code&gt; 헤더가 없는 274 ).</target>
        </trans-unit>
        <trans-unit id="8841ca9cf4a3d6697ad899f49ceee826a96da464" translate="yes" xml:space="preserve">
          <source>N/A (no GnuCOBOL equivalent)</source>
          <target state="translated">해당 없음 (GnuCOBOL에 해당 없음)</target>
        </trans-unit>
        <trans-unit id="456048850e9d09e5cbfde5c2a6be5799c526a49a" translate="yes" xml:space="preserve">
          <source>NAME, NATIONAL, NATIONAL-EDITED, NATIONAL-OF, NATIVE, NEAREST-AWAY-FROM-ZERO, NEAREST-EVEN, NEAREST-TOWARD-ZERO, NEGATIVE, NESTED, NEXT, NO, NO-ECHO, NONE, NORMAL, NOT, NOTHING, NULL, NULLS, NUMBER, NUMBER-OF-CALL-PARAMETERS, NUMBERS, NUMERIC, NUMERIC-DECIMAL-POINT, NUMERIC-EDITED, NUMERIC-THOUSANDS-SEPARATOR, NUMVAL, NUMVAL-C, NUMVAL-F</source>
          <target state="translated">NAME, NATIONAL, NATIONAL-EDITED, NATIONAL-OF, NATIVE, ANEEST-AWAY-FROM-ZERO, NESTEST-EVEN, NEAREST-TOWARD-ZERO, NEGATIVE, NESTED, NEXT, NO, NO-ECHO, NONE, NORMAL, NOT, NOTHING, NULL, NULLS, NUMBER, NUMBER-OF-CALL-PARAMETERS, NUMBERS, NUMERIC, NUMERIC-DECIMAL-POINT, NUMERIC-EDITED, NUMERIC-THOUSANDS-SEPARATOR, NUMVAL, NUMVAL-C, NUMVAL-F</target>
        </trans-unit>
        <trans-unit id="23579a7244afbe343b0ef7777f40fe65dd6d391f" translate="yes" xml:space="preserve">
          <source>NEXT-GROUP Clause Syntax</source>
          <target state="translated">다음 그룹 절 구문</target>
        </trans-unit>
        <trans-unit id="4fd04833b3755cfdf59219f364a4c19cf95dcc36" translate="yes" xml:space="preserve">
          <source>NO-ECHO Attribute Syntax</source>
          <target state="translated">NO-ECHO 속성 구문</target>
        </trans-unit>
        <trans-unit id="969e7d8dee132181523a501a068fec75bded3005" translate="yes" xml:space="preserve">
          <source>NOT</source>
          <target state="translated">NOT</target>
        </trans-unit>
        <trans-unit id="a9ea4f7a4f03a9c52a7aa0d54a54e0ee6d21feed" translate="yes" xml:space="preserve">
          <source>NOTE that CBL_GC_PRINTABLE replaces this although it is currently still supported for legacy reasons.</source>
          <target state="translated">CBL_GC_PRINTABLE은 현재 레거시 이유로 여전히 지원되지만이를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="1c7a5d29d866f9947d87ce89b623e7dcee44fb1b" translate="yes" xml:space="preserve">
          <source>NUMERIC-DECIMAL-POINT Function Syntax</source>
          <target state="translated">NUMERIC-DECIMAL-POINT 함수 구문</target>
        </trans-unit>
        <trans-unit id="0f7032d6214932877eaeb90684d8b5e91b84fe2d" translate="yes" xml:space="preserve">
          <source>NUMERIC-THOUSANDS-SEPARATOR Function Syntax</source>
          <target state="translated">숫자-천 단위 구분자 함수 구문</target>
        </trans-unit>
        <trans-unit id="24a2cb0031362dfda9217165484fefd16498a931" translate="yes" xml:space="preserve">
          <source>NUMVAL Function Syntax</source>
          <target state="translated">NUMVAL 함수 구문</target>
        </trans-unit>
        <trans-unit id="31988bddc5cc6a4166042e84de6cbd874cb74a99" translate="yes" xml:space="preserve">
          <source>NUMVAL-C Function Syntax</source>
          <target state="translated">NUMVAL-C 함수 구문</target>
        </trans-unit>
        <trans-unit id="ae21c526020f5a22401b17f7aa4bfb1762439159" translate="yes" xml:space="preserve">
          <source>NUMVAL-F Function Syntax</source>
          <target state="translated">NUMVAL-F 함수 구문</target>
        </trans-unit>
        <trans-unit id="057d3c3f4e6e8dc1ec58c53e9789c01dd0b62e89" translate="yes" xml:space="preserve">
          <source>National Character set</source>
          <target state="translated">자국 문자 세트</target>
        </trans-unit>
        <trans-unit id="4245f0ee71bd17093500ac16c41a1dd1b33008e5" translate="yes" xml:space="preserve">
          <source>Native Binary Integer</source>
          <target state="translated">기본 이진 정수</target>
        </trans-unit>
        <trans-unit id="3f00afda761d5e13a699220ac15df2aa008259c3" translate="yes" xml:space="preserve">
          <source>Native IEEE 754 Binary32</source>
          <target state="translated">네이티브 IEEE 754 Binary32</target>
        </trans-unit>
        <trans-unit id="38d71bfaf2af5e86c02dd007bae5cd22e8350547" translate="yes" xml:space="preserve">
          <source>Native IEEE 754 Binary64 Floating-point</source>
          <target state="translated">기본 IEEE 754 Binary64 부동 소수점</target>
        </trans-unit>
        <trans-unit id="4775cd57bf8ad48397acf03e156ee31bbc505817" translate="yes" xml:space="preserve">
          <source>Native IEEE 754 Decimal128 Floating-point</source>
          <target state="translated">기본 IEEE 754 Decimal128 부동 소수점</target>
        </trans-unit>
        <trans-unit id="1579bca067a63e4a82df0092b6bb19e611a1879b" translate="yes" xml:space="preserve">
          <source>Native IEEE 754 Decimal64 Floating-point</source>
          <target state="translated">기본 IEEE 754 Decimal64 부동 소수점</target>
        </trans-unit>
        <trans-unit id="663645109bc4810ff83f3fcb9242af60d6271f15" translate="yes" xml:space="preserve">
          <source>Native unsigned (X) or signed (9) Binary</source>
          <target state="translated">네이티브 부호없는 (X) 또는 부호있는 (9) 이진</target>
        </trans-unit>
        <trans-unit id="0bb1805002fe928c11731e2fe434c6710e0546aa" translate="yes" xml:space="preserve">
          <source>Negated Condition Syntax</source>
          <target state="translated">부정 조건 구문</target>
        </trans-unit>
        <trans-unit id="b258f825a32604b32cf66b5f27af5bbeed3d0dbd" translate="yes" xml:space="preserve">
          <source>Negative Values Allowed?:</source>
          <target state="translated">허용되는 음수? :</target>
        </trans-unit>
        <trans-unit id="569eabdf4b8f2757a51f46ddb9444a185ebc7cb4" translate="yes" xml:space="preserve">
          <source>Negative values are returned for system dependand error codes and -1 if the function is not available on the current system.</source>
          <target state="translated">시스템 종속 오류 코드에 대해 음수 값이 리턴되고 현재 시스템에서 기능을 사용할 수없는 경우 -1이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="fac968968fa4c7a06b3ca207e37616b4cf010c7c" translate="yes" xml:space="preserve">
          <source>Neither &amp;lt;</source>
          <target state="translated">둘 다 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="dcdcf73a59a8f2ad5bc285a8314df00761fcb686" translate="yes" xml:space="preserve">
          <source>Neither a another file-based&lt;code&gt;SORT&lt;/code&gt;statement nor a&lt;code&gt;MERGE&lt;/code&gt;statement may be executed within the input procedure unless those statements utilize a different sort or merge work file.</source>
          <target state="translated">다른 파일 기반 &lt;code&gt;SORT&lt;/code&gt; 문이나 &lt;code&gt;MERGE&lt;/code&gt; 문은 다른 정렬 또는 병합 작업 파일을 사용하지 않는 한 입력 프로 시저 내에서 실행될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="24fe46648b02cf0f40c1f64b86fe9a8a1b238380" translate="yes" xml:space="preserve">
          <source>Neither a another file-based&lt;code&gt;SORT&lt;/code&gt;statement nor a&lt;code&gt;MERGE&lt;/code&gt;statement may be executed within the output procedure unless those statements utilize a different sort or merge work file.</source>
          <target state="translated">다른 정렬 또는 병합 작업 파일을 사용하지 않는 한 다른 파일 기반 &lt;code&gt;SORT&lt;/code&gt; 문이나 &lt;code&gt;MERGE&lt;/code&gt; 문은 출력 프로 시저 내에서 실행될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1a3ec78fb2431caff148e7bb1cf8ea0ff18e700c" translate="yes" xml:space="preserve">
          <source>Neither a file-based&lt;code&gt;SORT&lt;/code&gt;statement (see &lt;a href=&quot;#File_002dBased-SORT&quot;&gt;File-Based SORT&lt;/a&gt;) nor another&lt;code&gt;MERGE&lt;/code&gt;statement may be executed within the scope of the procedures comprising the output procedure unless those statements utilize a different sort or merge work file.</source>
          <target state="translated">파일 기반 &lt;code&gt;SORT&lt;/code&gt; 문 ( &lt;a href=&quot;#File_002dBased-SORT&quot;&gt;File-Based SORT&lt;/a&gt; 참조 )이나 다른 &lt;code&gt;MERGE&lt;/code&gt; 문은 다른 정렬 또는 병합 작업 파일을 사용하지 않는 한 출력 프로 시저를 구성하는 프로 시저 범위 내에서 실행될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cc989bf49db06aa48ebb1422a2de0e6c00423d9d" translate="yes" xml:space="preserve">
          <source>Neither the presence of an encoded digit (see above) nor an actual&lt;code&gt;+&lt;/code&gt;or&lt;code&gt;-&lt;/code&gt;character embedded within the data item&amp;rsquo;s storage prevents the data item from being used as a source field in arithmetic operations.</source>
          <target state="translated">인코딩 된 숫자 (위 참조)가 존재하지 않거나 데이터 항목의 저장소에 실제 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 문자가 포함되어 있어도 데이터 항목이 산술 연산에서 소스 필드로 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5e391e55efc04c3c0f99e29e799c743a6b88a5c" translate="yes" xml:space="preserve">
          <source>Neither the value of &amp;lt;</source>
          <target state="translated">&amp;lt;의 값 모두</target>
        </trans-unit>
        <trans-unit id="a8d23bd6a6b56505c754a0566832b43e6c7deddd" translate="yes" xml:space="preserve">
          <source>Neither&lt;code&gt;EXIT PROGRAM&lt;/code&gt;nor&lt;code&gt;EXIT FUNCTION&lt;/code&gt;may be used within a&lt;code&gt;USE GLOBAL&lt;/code&gt;routine in&lt;code&gt;DECLARATIVES&lt;/code&gt;(see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;).</source>
          <target state="translated">어느 &lt;code&gt;EXIT PROGRAM&lt;/code&gt; 이나 &lt;code&gt;EXIT FUNCTION&lt;/code&gt; 내에서 사용할 수 있습니다 &lt;code&gt;USE GLOBAL&lt;/code&gt; 의 일상 &lt;code&gt;DECLARATIVES&lt;/code&gt; (참조 &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2ef44da87cf7da408056f5b8df3aee8b08f3e63d" translate="yes" xml:space="preserve">
          <source>Nested Subprograms</source>
          <target state="translated">중첩 서브 프로그램</target>
        </trans-unit>
        <trans-unit id="02345bc4e59618249ddd33b89a552e74eefc9cca" translate="yes" xml:space="preserve">
          <source>New programs requiring a stand-alone elementary item should be coded to use a level number of 01 rather than 77.</source>
          <target state="translated">독립형 기본 항목이 필요한 새 프로그램은 77이 아닌 01의 레벨 번호를 사용하도록 코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="cb2f4a912a9c59ceb0b74adc342b766667a643e7" translate="yes" xml:space="preserve">
          <source>Next, the&lt;code&gt;CONTROL HEADING&lt;/code&gt;for each &amp;lt;</source>
          <target state="translated">다음에, &lt;code&gt;CONTROL HEADING&lt;/code&gt; 각 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="1a6b2761c5a03cb41776cc1a48760cf197b63fc7" translate="yes" xml:space="preserve">
          <source>No data is available on screen ACCEPT</source>
          <target state="translated">ACCEPT 화면에 데이터가 없습니다</target>
        </trans-unit>
        <trans-unit id="22f4fdea4baac33f85e6d27a113ce40e1b051a05" translate="yes" xml:space="preserve">
          <source>No more than 36 arguments may be passed to a subroutine, unless the GnuCOBOL compiler was built with a specifically different argument limit specified for it. If you have access to the GnuCOBOL source code, you may adjust this limit by changing the value of the&lt;code&gt;COB_MAX_FIELD_PARAMS&lt;/code&gt;in the&lt;code&gt;common.h&lt;/code&gt;file (found in the&lt;code&gt;libcob&lt;/code&gt;folder) before you run&lt;code&gt;make&lt;/code&gt;to build the compiler and run-time library.</source>
          <target state="translated">GnuCOBOL 컴파일러가 특별히 다른 인수 제한으로 지정된 경우를 제외하고는 36 개의 인수 만 서브 루틴에 전달 될 수 없습니다. 당신이 GnuCOBOL 소스 코드에 액세스 할 수있는 경우, 당신은의 값을 변경하여이 제한을 조정할 수 있습니다 &lt;code&gt;COB_MAX_FIELD_PARAMS&lt;/code&gt; 에서 &lt;code&gt;common.h&lt;/code&gt; 의 파일을 삭제합니다 (에서 발견 &lt;code&gt;libcob&lt;/code&gt; 의 당신이 실행하기 전에 폴더) &lt;code&gt;make&lt;/code&gt; 컴파일러와 런타임 라이브러리를 구축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d5b904086ff2a2ac1ab9032a0b17994d3c8146f" translate="yes" xml:space="preserve">
          <source>No report content will actually presented to the report file as a result of a successful&lt;code&gt;INITIATE&lt;/code&gt;statement &amp;mdash; that will not occur until the first&lt;code&gt;GENERATE&lt;/code&gt;statement (see &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;) is executed.</source>
          <target state="translated">성공적인 &lt;code&gt;INITIATE&lt;/code&gt; 문의 결과로 보고서 내용이 실제로 보고서 파일 에 표시되지 않습니다. 이는 첫 번째 &lt;code&gt;GENERATE&lt;/code&gt; 문 ( &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt; 참조 )이 실행될 때까지 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="841e2fb51fda0ae1893e020320984500822af311" translate="yes" xml:space="preserve">
          <source>No rounding is performed. If the value cannot be represented exactly in the desired format, the EC-SIZE-TRUNCATION condition (exception code 1005) is set (and may be retrieved via the&lt;code&gt;ACCEPT&lt;/code&gt;(see &lt;a href=&quot;#ACCEPT-FROM-Runtime_002dInfo&quot;&gt;ACCEPT FROM Runtime-Info&lt;/a&gt;) statement) and the results of the operation are undefined.</source>
          <target state="translated">반올림이 수행되지 않습니다. 값을 원하는 형식으로 정확하게 표현할 수없는 경우 EC-SIZE-TRUNCATION 조건 (예외 코드 1005)이 설정되고 &lt;code&gt;ACCEPT&lt;/code&gt; ( &lt;a href=&quot;#ACCEPT-FROM-Runtime_002dInfo&quot;&gt;ACCEPT FROM Runtime-Info 참조&lt;/a&gt; ) 문을 통해 검색 될 수 있으며 작업 결과 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="eae4ac248869b9a9f5a910afc02caead622a3640" translate="yes" xml:space="preserve">
          <source>No special meaning &amp;mdash; this is the normal character that will appear in this area.</source>
          <target state="translated">특별한 의미는 없습니다. 이것은이 영역에 나타날 일반적인 문자입니다.</target>
        </trans-unit>
        <trans-unit id="0cfdaae490927c423f2c8197638d2a8e5c4b9c06" translate="yes" xml:space="preserve">
          <source>No storage is allocated for data defined in the linkage section; the data descriptions there are merely defining storage areas that will be passed to the subprogram by a calling program. Therefore, any discussion of the default initialization of such data is irrelevant. It</source>
          <target state="translated">연계 섹션에 정의 된 데이터에 스토리지가 할당되지 않습니다. 데이터 설명은 호출 프로그램에 의해 서브 프로그램으로 전달 될 저장 영역을 정의하기 만합니다. 따라서 이러한 데이터의 기본 초기화에 대한 설명은 관련이 없습니다. 그것</target>
        </trans-unit>
        <trans-unit id="7438d13425aae9891e97195f6fa784ef1702eda9" translate="yes" xml:space="preserve">
          <source>No two of those files may be referenced on a&lt;code&gt;SAME RECORD AREA&lt;/code&gt;(see &lt;a href=&quot;#SAME-RECORD-AREA&quot;&gt;SAME RECORD AREA&lt;/a&gt;),&lt;code&gt;SAME SORT AREA&lt;/code&gt;or&lt;code&gt;SAME SORT-MERGE AREA&lt;/code&gt;statement.</source>
          <target state="translated">이러한 파일 중 어느 것도 &lt;code&gt;SAME RECORD AREA&lt;/code&gt; ( &lt;a href=&quot;#SAME-RECORD-AREA&quot;&gt;SAM RECORD AREA&lt;/a&gt; 참조 ), &lt;code&gt;SAME SORT AREA&lt;/code&gt; 또는 &lt;code&gt;SAME SORT-MERGE AREA&lt;/code&gt; 문에서 참조 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="de44dc71aad924a999900997ea794d8dd652830f" translate="yes" xml:space="preserve">
          <source>No two records in the table may have the same&lt;code&gt;KEY&lt;/code&gt;field values. If the table has multiple&lt;code&gt;KEY&lt;/code&gt;definitions, then no two records in the table may have the same</source>
          <target state="translated">테이블의 두 레코드가 동일한 &lt;code&gt;KEY&lt;/code&gt; 필드 값을 가질 수 없습니다 . 테이블에 여러 &lt;code&gt;KEY&lt;/code&gt; 정의 가있는 경우 테이블의 두 레코드가 동일하지 않을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="a81a89d7fe3f234fdfe59b26feaf85b577259ebb" translate="yes" xml:space="preserve">
          <source>No two report groups in the same report &lt;code&gt;RD&lt;/code&gt; may named with the same &amp;lt;</source>
          <target state="translated">동일한 보고서 &lt;code&gt;RD&lt;/code&gt; 의 두 보고서 그룹 이 동일한 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="d7e5774021597c332a13e1b5235f812224be797b" translate="yes" xml:space="preserve">
          <source>No&lt;code&gt;INVALID KEY&lt;/code&gt;or&lt;code&gt;NOT INVALID KEY&lt;/code&gt;clause may be specified for a file who&amp;rsquo;s&lt;code&gt;ACCESS MODE IS SEQUENTIAL&lt;/code&gt;</source>
          <target state="translated">아니 &lt;code&gt;INVALID KEY&lt;/code&gt; 또는 &lt;code&gt;NOT INVALID KEY&lt;/code&gt; 의 절의 파일을 지정할 수 있습니다 &lt;code&gt;ACCESS MODE IS SEQUENTIAL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf0db7b3bb9f408f9b74f8f298755ddc3e66b9b8" translate="yes" xml:space="preserve">
          <source>No&lt;code&gt;OCCURS&lt;/code&gt;(see &lt;a href=&quot;#OCCURS&quot;&gt;OCCURS&lt;/a&gt;) clause may be part of the definition of either the subject or object data items. Either or both, however, may be group items that</source>
          <target state="translated">없음 &lt;code&gt;OCCURS&lt;/code&gt; (참조가 &lt;a href=&quot;#OCCURS&quot;&gt;OCCURS&lt;/a&gt; ) 절은 주체 또는 객체 데이터 항목 중 하나의 정의의 일부가 될 수 있습니다. 그러나 둘 중 하나 또는 둘 다 그룹 항목 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca1b683a95bedaa03b1b7fa72858ee0c6ecd486e" translate="yes" xml:space="preserve">
          <source>No&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause may be defined on the object data item, and no data items subordinate to the object data item may have&lt;code&gt;VALUE&lt;/code&gt;clauses, with the exception of level-88 condition names.</source>
          <target state="translated">없음 &lt;code&gt;VALUE&lt;/code&gt; 없습니다 (참조 &lt;a href=&quot;#VALUE&quot;&gt;VALUE를&lt;/a&gt; ) 절 오브젝트 데이터 항목을 정의 할 수 있고, 가질 수있는 객체 데이터 항목에 종속 데이터가없는 항목 &lt;code&gt;VALUE&lt;/code&gt; 의 레벨 88의 조건 이름을 제외하고 절을.</target>
        </trans-unit>
        <trans-unit id="25fc4526232d80ffb715ab31181b4409345c2f9b" translate="yes" xml:space="preserve">
          <source>Non-integer fixed point values such as 1.317 or -2.95.</source>
          <target state="translated">1.317 또는 -2.95와 같은 정수가 아닌 고정 소수점 값</target>
        </trans-unit>
        <trans-unit id="e2c9b438099e818e760bdec714a929f4ed0713ad" translate="yes" xml:space="preserve">
          <source>None of &amp;lt;</source>
          <target state="translated">&amp;lt;없음</target>
        </trans-unit>
        <trans-unit id="b822fcd670cee5b981bb06fc3472b35bc909a687" translate="yes" xml:space="preserve">
          <source>None of them may be open at the time the&lt;code&gt;MERGE&lt;/code&gt;is executed.</source>
          <target state="translated">&lt;code&gt;MERGE&lt;/code&gt; 가 실행될 때 열 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e27f545e660688ab7b2fa768237fd2139f657e72" translate="yes" xml:space="preserve">
          <source>Not all GnuCOBOL implementations support file sharing and record-locking options. Whether they do or not depends upon the operating system they were built for and the build options that were used when the specific GnuCOBOL implementation was generated.</source>
          <target state="translated">모든 GnuCOBOL 구현이 파일 공유 및 레코드 잠금 옵션을 지원하는 것은 아닙니다. 사용 여부는 빌드 된 운영 체제 및 특정 GnuCOBOL 구현시 생성 된 빌드 옵션에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="306e41cc992ba155fc93cf3121e83571aae63d84" translate="yes" xml:space="preserve">
          <source>Not all GnuCOBOL implementations support locking. Whether they do or not depends upon the operating system they were built for and the build options that were used when GnuCOBOL was generated. When a program using one of those GnuCOBOL implementations issues an UNLOCK, it will ignored. There will be no compiler message issued. Buffer syncing, if needed, will still occur.</source>
          <target state="translated">모든 GnuCOBOL 구현이 잠금을 지원하는 것은 아닙니다. 사용 여부는 빌드 된 운영 체제 및 GnuCOBOL 생성시 사용 된 빌드 옵션에 따라 다릅니다. 이러한 GnuCOBOL 구현 중 하나를 사용하는 프로그램이 UNLOCK을 발행하면 무시됩니다. 컴파일러 메시지가 발행되지 않습니다. 필요한 경우 버퍼 동기화가 계속 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e9c1ce73c055e69ee3402cf0e4efbc368e26f9fc" translate="yes" xml:space="preserve">
          <source>Not all divisions are needed in every program, but they must be specified in the order shown when they</source>
          <target state="translated">모든 프로그램에 모든 부서가 필요한 것은 아니지만, 표시 될 때 순서대로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="70ba7f89a0cdff0df48d89a63760a916d2a3530e" translate="yes" xml:space="preserve">
          <source>Not specifying an &amp;lt;</source>
          <target state="translated">&amp;lt;를 지정하지 않음</target>
        </trans-unit>
        <trans-unit id="dc309739aae3a8f2ebf82a717d61d549c5be4bac" translate="yes" xml:space="preserve">
          <source>Note how the COBOL program ensures that a null end-of-string terminator is present on both string arguments.</source>
          <target state="translated">COBOL 프로그램이 두 문자열 인수 모두에 널 (NULL) 문자열 끝 종결자가 있는지 확인하는 방법에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="9c109c67ad2b3a941d3d17742fa522392c11f75b" translate="yes" xml:space="preserve">
          <source>Note how the word&lt;code&gt;FUNCTION&lt;/code&gt;is part of the syntax when you use an intrinsic function. You can use intrinsic functions without having to include the reserved word&lt;code&gt;FUNCTION&lt;/code&gt;via settings in the&lt;code&gt;REPOSITORY&lt;/code&gt;(see &lt;a href=&quot;#REPOSITORY&quot;&gt;REPOSITORY&lt;/a&gt;) paragraph. You may accomplish the same thing by specifying the&lt;code&gt;-fintrinsics&lt;/code&gt;switch</source>
          <target state="translated">내장 함수를 사용할 때 &lt;code&gt;FUNCTION&lt;/code&gt; 이라는 단어 가 구문의 일부인 방법에 유의하십시오 . &lt;code&gt;REPOSITORY&lt;/code&gt; ( &lt;a href=&quot;#REPOSITORY&quot;&gt;REPOSITORY&lt;/a&gt; 참조 ) 단락의 설정을 통해 예약어 &lt;code&gt;FUNCTION&lt;/code&gt; 을 포함하지 않고도 내장 함수를 사용할 수 있습니다 . &lt;code&gt;-fintrinsics&lt;/code&gt; 스위치 를 지정하여 동일한 작업을 수행 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="d04e9fec76c5812c7a9b640cbfeccc8e41ebd984" translate="yes" xml:space="preserve">
          <source>Note how the&lt;code&gt;cobcrun&lt;/code&gt;command does not allow a path to be specified with the program name &amp;mdash; the directory in which the programs dynamically loadable module exists must either be the current directory or must be defined in the current PATH.</source>
          <target state="translated">&lt;code&gt;cobcrun&lt;/code&gt; 명령으로 프로그램 이름으로 경로를 지정할 수없는 방법에 유의 하십시오. 프로그램이 동적으로로드 할 수있는 모듈이 존재하는 디렉토리는 현재 디렉토리이거나 현재 PATH에 정의되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ec332543bc6a4b8ecabc6857c2e09711a937c08d" translate="yes" xml:space="preserve">
          <source>Note that bit 0 is the right-most bit in the binary value.</source>
          <target state="translated">비트 0은 이진 값에서 가장 오른쪽에있는 비트입니다.</target>
        </trans-unit>
        <trans-unit id="2539952aecc19d7b3a92ef3357fabc279c56a247" translate="yes" xml:space="preserve">
          <source>Note that even though we told GnuCOBOL that the 1st argument was to be&lt;code&gt;BY VALUE&lt;/code&gt; it was treated as if it were&lt;code&gt;BY REFERENCE&lt;/code&gt;anyway. String (char array) arguments passed from C callers to GnuCOBOL subprograms will be modifiable by the subprogram. It&amp;rsquo;s best to pass a copy of such data if you want to ensure that the subprogram doesn&amp;rsquo;t change it.</source>
          <target state="translated">주 우리가 1 인자가 될 것을 GnuCOBOL 말했다 비록 &lt;code&gt;BY VALUE&lt;/code&gt; 를 그 것처럼 그것을 처리 &lt;code&gt;BY REFERENCE&lt;/code&gt; 어쨌든. C 호출자에서 GnuCOBOL 서브 프로그램으로 전달 된 문자열 (char 배열) 인수는 서브 프로그램에 의해 수정 될 수 있습니다. 서브 프로그램이 변경하지 않도록하려면 그러한 데이터의 사본을 전달하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="871c018f1f8ef5bab7bedbfc57441be80385c284" translate="yes" xml:space="preserve">
          <source>Note that the OUTPUT phrase changes the way in which the default field size is computed. See that heading above for details. Also note that the OUTPUT phrase affects only the way items are displayed on the screen; the internal format of accepted data is not affected.</source>
          <target state="translated">OUTPUT 문구는 기본 필드 크기가 계산되는 방식을 변경합니다. 자세한 내용은 위의 제목을 참조하십시오. 또한 OUTPUT 문구는 항목이 화면에 표시되는 방식에만 영향을 미칩니다. 허용 된 데이터의 내부 형식은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1fbd4eeb5f6972ceb99cdf3aac9f4be0886c77cb" translate="yes" xml:space="preserve">
          <source>Note that the legacy name of this routine starts with CBL_OC is deprecated, as is HOSTED but will still work. It is recommended that all libary routines names starting with CBL_OC are replaced with CBL_GC to minimise issues.</source>
          <target state="translated">이 루틴의 레거시 이름은 CBL_OC로 시작하지만 HOSTED와 같이 더 이상 사용되지 않지만 여전히 작동합니다. 문제를 최소화하기 위해 CBL_OC로 시작하는 모든 라이브러리 루틴 이름을 CBL_GC로 바꾸는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7a40b40bf40810b907f7cf0d8aaaa83843011c4d" translate="yes" xml:space="preserve">
          <source>Note that the legacy name of this routine that starts with CBL_OC is deprecated, as is NANOSLEEP but will still work. It is recommended that all libary routines names starting with CBL_OC are replaced with CBL_GC to minimise issues.</source>
          <target state="translated">CBL_OC로 시작하는이 루틴의 레거시 이름은 NANOSLEEP와 같이 더 이상 사용되지 않지만 여전히 작동합니다. 문제를 최소화하기 위해 CBL_OC로 시작하는 모든 라이브러리 루틴 이름을 CBL_GC로 바꾸는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="efe51ebdd06327d81c22d954a952f012e8b5debd" translate="yes" xml:space="preserve">
          <source>Note that the value returned by this function is not the number of</source>
          <target state="translated">이 함수에 의해 반환되는 값은</target>
        </trans-unit>
        <trans-unit id="f3452b747551a3e31882fb7b479a113ecf58accb" translate="yes" xml:space="preserve">
          <source>Note that these errors include but are not limited to: argument (string) is zero length, contains only spaces or contains valid characters but is incomplete, such as the string &quot;+.&quot;.</source>
          <target state="translated">인수 (문자열)의 길이가 0이거나 공백 만 포함하거나 유효한 문자를 포함하지만 문자열 &quot;+&quot;와 같이 불완전한 오류가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="cc0412d45415b86da0a43a8c1ca6e6dc158f2456" translate="yes" xml:space="preserve">
          <source>Note that what constitutes a &quot;letter&quot; (or upper/lower case too, for that manner) may be influenced through the use of&lt;code&gt;CHARACTER CLASSIFICATION&lt;/code&gt;specifications in the&lt;code&gt;OBJECT-COMPUTER&lt;/code&gt;(see &lt;a href=&quot;#OBJECT_002dCOMPUTER&quot;&gt;OBJECT-COMPUTER&lt;/a&gt;) paragraph.</source>
          <target state="translated">&quot;글자&quot;(또는 그와 같은 경우 대문자 / 소문자)를 구성하는 것은 &lt;code&gt;OBJECT-COMPUTER&lt;/code&gt; ( &lt;a href=&quot;#OBJECT_002dCOMPUTER&quot;&gt;OBJECT-COMPUTER&lt;/a&gt; 참조 ) 단락 에서 &lt;code&gt;CHARACTER CLASSIFICATION&lt;/code&gt; 스펙을 사용하여 영향을받을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d3c2b08b61d1a38bbeee29bc320c48df653d057" translate="yes" xml:space="preserve">
          <source>Note that you cannot supply the CONVERT phrase in the Screen Section. Thus the size of a Screen Section field is always the size of its screen entry unless the SIZE phrase is specified.</source>
          <target state="translated">화면 섹션에는 CONVERT 문구를 제공 할 수 없습니다. 따라서 SIZE 구문을 지정하지 않으면 스크린 섹션 필드의 크기는 항상 스크린 항목의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="28b8e9bdefe3979b0685c44999ad9084995ed4c9" translate="yes" xml:space="preserve">
          <source>Now observe the following code, which will execute the&lt;code&gt;150-Process-Hex-Value&lt;/code&gt;procedure if&lt;code&gt;Entered-Value&lt;/code&gt;contains nothing but valid hexadecimal digits:</source>
          <target state="translated">&lt;code&gt;Entered-Value&lt;/code&gt; 에 유효한 16 진수 만 있으면 &lt;code&gt;150-Process-Hex-Value&lt;/code&gt; 프로 시저 를 실행하는 다음 코드를 관찰하십시오 .</target>
        </trans-unit>
        <trans-unit id="d9e0e91f86531814b287253e68ce747a1135f32c" translate="yes" xml:space="preserve">
          <source>Now that you know</source>
          <target state="translated">이제 알았습니다</target>
        </trans-unit>
        <trans-unit id="d0861e2e052b3dc839be9fe7e44875aa59ec9523" translate="yes" xml:space="preserve">
          <source>Now there can be no confusion as to which CITY is being changed. Fortunately, you don&amp;rsquo;t need to be quite so specific; COBOL allows intermediate and unnecessary qualification levels to be omitted. This allows&lt;code&gt;MOVE 'Philadelphia' TO CITY OF EMPLOYEE&lt;/code&gt;to do the job nicely.</source>
          <target state="translated">이제 어떤 도시가 변경되고 있는지 혼동 될 수 없습니다. 다행히도, 당신은 그렇게 구체적 일 필요는 없습니다. COBOL을 통해 중간 및 불필요한 자격 수준을 생략 할 수 있습니다. 이를 통해 &lt;code&gt;MOVE 'Philadelphia' TO CITY OF EMPLOYEE&lt;/code&gt; 에게 '필라델피아'MOVE를 잘 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="219877a3941189d29da78605ffc816ab5f2a7b89" translate="yes" xml:space="preserve">
          <source>Now, assume that another program reads this file, but describes 10-character records rather than 6. Here are the records</source>
          <target state="translated">이제 다른 프로그램이이 파일을 읽지 만 6이 아닌 10 자 레코드를 설명한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="9b0d34c0dc28860109b36ba3a6f8a912103ad454" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s deal with the problem of setting the CITY portion of an EMPLOYEEs MAILING-ADDRESS to &quot;Philadelphia&quot;. Clearly,&lt;code&gt;MOVE 'Philadelphia' TO CITY&lt;/code&gt;cannot work because the compiler will be unable to determine which of the two CITY fields you are referring to.</source>
          <target state="translated">이제 직원 우편 주소의 CITY 부분을 &quot;필라델피아&quot;로 설정하는 문제를 해결해 보겠습니다. 컴파일러가 사용자가 참조하는 두 개의 CITY 필드를 판별 할 수 없기 때문에 분명히 &lt;code&gt;MOVE 'Philadelphia' TO CITY&lt;/code&gt; 은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ce50db412280505597bf9414695fbcc5fc0e3f7b" translate="yes" xml:space="preserve">
          <source>Now, the roles of the two languages in the previous section will be reversed, having a C main program execute a GnuCOBOL subprogram.</source>
          <target state="translated">이제 이전 섹션에서 두 언어의 역할이 바뀌어 C 메인 프로그램이 GnuCOBOL 서브 프로그램을 실행하게됩니다.</target>
        </trans-unit>
        <trans-unit id="f60c8b64229a047f941675b68f85587ecce4b520" translate="yes" xml:space="preserve">
          <source>Numeric Data Item</source>
          <target state="translated">숫자 데이터 항목</target>
        </trans-unit>
        <trans-unit id="c9fbc7f3c5ecccd87db3e696a9c121879251fe81" translate="yes" xml:space="preserve">
          <source>Numeric Edited</source>
          <target state="translated">숫자 편집</target>
        </trans-unit>
        <trans-unit id="63ddf527a277f4c347e2246f00b1c4f8cda03669" translate="yes" xml:space="preserve">
          <source>Numeric Edited Data Item</source>
          <target state="translated">숫자 편집 된 데이터 항목</target>
        </trans-unit>
        <trans-unit id="a24a22f9b40fcfe4d2691a6016ec524613059e17" translate="yes" xml:space="preserve">
          <source>Numeric Literal</source>
          <target state="translated">숫자 리터럴</target>
        </trans-unit>
        <trans-unit id="be2d608e3fa3ed6ad269186745305eb23ec33b56" translate="yes" xml:space="preserve">
          <source>Numeric data items will be initialized to a value of&lt;code&gt;ZERO&lt;/code&gt;</source>
          <target state="translated">숫자 데이터 항목은 &lt;code&gt;ZERO&lt;/code&gt; 값으로 초기화됩니다</target>
        </trans-unit>
        <trans-unit id="289405511920b64e6183e96801f299b0a1170932" translate="yes" xml:space="preserve">
          <source>Numeric keypad keys are not recognizable on Windows MinGW/PDCurses builds of GnuCOBOL, regardless of the number lock settings. Windows Cygwin/NCurses builds recognize numeric keypad inputs properly. Although not tested during the preparation of this documentation, I would expect native Windows builds using PDCurses to behave as MinGW builds do and native Unix builds using NCurses to behave as do Cygwin builds.</source>
          <target state="translated">숫자 잠금 설정에 관계없이 GnuCOBOL의 Windows MinGW / PDCurses 빌드에서 숫자 키패드 키를 인식 할 수 없습니다. Windows Cygwin / NCurses 빌드는 숫자 키패드 입력을 올바르게 인식합니다. 이 문서를 준비하는 동안 테스트되지는 않았지만 PDCurses를 사용하는 기본 Windows 빌드는 MinGW 빌드와 마찬가지로 작동하고 NCurses를 사용하는 기본 Unix 빌드는 Cygwin 빌드와 같이 동작합니다.</target>
        </trans-unit>
        <trans-unit id="8eeea7541c21f9801d7c1875ed5f9c434348ce35" translate="yes" xml:space="preserve">
          <source>Numeric literals may be split across lines just as alphanumeric literals are, using either of the above techniques and both reserved and user-defined words can be split across lines too (using the first technique). The continuation of numeric literals and user-defined/reserved words is provided merely to provide compatibility with older COBOL versions and programs, but should not be used with new programs &amp;mdash; it just makes for ugly-looking programs.</source>
          <target state="translated">위의 기술 중 하나를 사용하여 영숫자 리터럴과 마찬가지로 숫자 리터럴을 여러 줄로 나눌 수 있으며 예약 된 단어와 사용자 정의 단어를 모두 줄로 나눌 수 있습니다 (첫 번째 기술 사용). 숫자 리터럴과 사용자 정의 / 예약 단어의 연속은 이전 COBOL 버전 및 프로그램과의 호환성을 제공하기 위해 제공되지만 새로운 프로그램과 함께 사용해서는 안됩니다. 이는보기 흉한 프로그램을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="6f2932e8faff18c0314f3a04f9aec75edec07a2f" translate="yes" xml:space="preserve">
          <source>OBJECT, OBJECT-COMPUTER, OBJECT-REFERENCE, OCCURS, OF, OFF, OMITTED, ON, ONLY, OPEN, OPTIONAL, OPTIONS, OR, ORD, ORDER, ORD-MAX, ORD-MIN, ORGANISATION, ORGANIZATION, OTHER, OUTPUT, OVERFLOW, OVERLINE, OVERRIDE</source>
          <target state="translated">객체, 객체 컴퓨터, 객체 참조, 발생, OF, OFF, 생략, ON, ONLY, OPEN, OPTIONAL, OPTIONS, OR, ORD, ORDER, ORD-MAX, ORD-MIN, ORGANISATION, ORGANIZATION, OTHER, OUTPUT, 오버플로, 개요, 오버라이드</target>
        </trans-unit>
        <trans-unit id="2e78bec2d3800e6a21f1a284d7a3afd18c2fcd63" translate="yes" xml:space="preserve">
          <source>OBJECT-COMPUTER Syntax</source>
          <target state="translated">객체 컴퓨터 구문</target>
        </trans-unit>
        <trans-unit id="cec1574213ff5c57fb26687d05dd766be420fc2b" translate="yes" xml:space="preserve">
          <source>OCCURS &amp;hellip; DEPENDING ON data item out of bounds</source>
          <target state="translated">OCCURS&amp;hellip; 범위를 벗어난 데이터 항목에 따라 다름</target>
        </trans-unit>
        <trans-unit id="b800486653c7a1c77e853e0c004749a0fd2748a9" translate="yes" xml:space="preserve">
          <source>OCCURS (All Other Sections Clause Syntax</source>
          <target state="translated">OCCURS (다른 모든 섹션 조항 구문</target>
        </trans-unit>
        <trans-unit id="dd0b3221d40b5306dd784b27996de5c44ec57b1a" translate="yes" xml:space="preserve">
          <source>OCCURS (REPORT SECTION) Clause Syntax</source>
          <target state="translated">OCCURS (보고서 섹션) 조항 구문</target>
        </trans-unit>
        <trans-unit id="6b31ee2b7fdf9b827a81f695d24c794e1825c9ac" translate="yes" xml:space="preserve">
          <source>OCCURS (SCREEN SECTION) Clause Syntax</source>
          <target state="translated">OCCURS (스크린 섹션) 절 구문</target>
        </trans-unit>
        <trans-unit id="12163d548f84d0d3a65be49f9405b588882fb830" translate="yes" xml:space="preserve">
          <source>ON EXCEPTION Syntax</source>
          <target state="translated">익셉션 구문</target>
        </trans-unit>
        <trans-unit id="fae727086e90c1747900d70ffd7f8b15f8dbda95" translate="yes" xml:space="preserve">
          <source>ON OVERFLOW Syntax</source>
          <target state="translated">오버플로 구문</target>
        </trans-unit>
        <trans-unit id="66bebaca5aeeed104d7154b3d0f92463c9dd8dd1" translate="yes" xml:space="preserve">
          <source>ON SIZE ERROR Syntax</source>
          <target state="translated">크기 오류 구문</target>
        </trans-unit>
        <trans-unit id="36dfa4bed24bebe94e869396499f245644973c4a" translate="yes" xml:space="preserve">
          <source>OPEN Syntax</source>
          <target state="translated">구문 열기</target>
        </trans-unit>
        <trans-unit id="cf0fe9af8bea7d1e731289cfef0c8038f4bc83dd" translate="yes" xml:space="preserve">
          <source>ORD Function Syntax</source>
          <target state="translated">ORD 함수 구문</target>
        </trans-unit>
        <trans-unit id="9ad6006b98ba7b9576a4512aa283c527f6a05c6a" translate="yes" xml:space="preserve">
          <source>ORD-MAX Function Syntax</source>
          <target state="translated">ORD-MAX 함수 구문</target>
        </trans-unit>
        <trans-unit id="09ee84df5eb17ff7d1f3553b1cbd5d58418d7791" translate="yes" xml:space="preserve">
          <source>ORD-MIN Function Syntax</source>
          <target state="translated">ORD-MIN 함수 구문</target>
        </trans-unit>
        <trans-unit id="08b26f9634d2a732e998aa2218316415ad38194c" translate="yes" xml:space="preserve">
          <source>ORGANIZATION INDEXED Clause Syntax</source>
          <target state="translated">조직 INDEXED 절 구문</target>
        </trans-unit>
        <trans-unit id="2df4622dcdea677d5d9a83663b8cbf91c2189a6b" translate="yes" xml:space="preserve">
          <source>ORGANIZATION LINE SEQUENTIAL Clause Syntax</source>
          <target state="translated">ORGANIZATION LINE SEQUENTIAL 절 구문</target>
        </trans-unit>
        <trans-unit id="86ee1da50c2e8a0ec7111d29363f3c837bd97118" translate="yes" xml:space="preserve">
          <source>ORGANIZATION RELATIVE Clause Syntax</source>
          <target state="translated">조직 관련 조항 구문</target>
        </trans-unit>
        <trans-unit id="750186647b33c3656503302d8eccc530bc37f0af" translate="yes" xml:space="preserve">
          <source>ORGANIZATION SEQUENTIAL Clause Syntax</source>
          <target state="translated">조직 순서 조항 구문</target>
        </trans-unit>
        <trans-unit id="578fbcff15d7037e9429c12a53b4d74f6a1577f1" translate="yes" xml:space="preserve">
          <source>OS/2 &quot;OPTLINK&quot; conventions will be used to CALL the subprogram.</source>
          <target state="translated">서브 프로그램을 호출하는 데 OS / 2 &quot;OPTLINK&quot;규칙이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c666501d06dc9305a9b7b68de3b3d3562fd28b49" translate="yes" xml:space="preserve">
          <source>OS/2 &quot;OPTLINK&quot; conventions will not be used to CALL the subprogram.</source>
          <target state="translated">서브 프로그램을 호출하는 데 OS / 2 &quot;OPTLINK&quot;규칙이 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c8e1209593b1149f5f3f8ee76008515520f2193a" translate="yes" xml:space="preserve">
          <source>OVERLINE Attribute Syntax</source>
          <target state="translated">개요 속성 구문</target>
        </trans-unit>
        <trans-unit id="4924a4d3bf56aa4a828e65f5066f009ce7e62b7d" translate="yes" xml:space="preserve">
          <source>Observe the definitions of data items &quot;Q&quot; and &quot;Y&quot;&amp;hellip;</source>
          <target state="translated">&quot;Q&quot;및 &quot;Y&quot;데이터 항목의 정의를 준수하십시오&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="46c20583dd7802c40938fc2ba6c6048df2b3e1e9" translate="yes" xml:space="preserve">
          <source>Observe the following example, which illustrates a fourth manner in which tables may be initialized in GnuCOBOL:</source>
          <target state="translated">GnuCOBOL에서 테이블을 초기화 할 수있는 네 번째 방법을 보여주는 다음 예를 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="cec634d4f1c842c1c34e5d70b1e1bba15a325f09" translate="yes" xml:space="preserve">
          <source>Of course, arithmetic expression operands may be numeric data items (any USAGE except POINTER or PROGRAM POINTER) as well as numeric literals.</source>
          <target state="translated">물론, 산술 연산 식 피연산자는 숫자 리터럴뿐만 아니라 숫자 데이터 항목 (POINTER 또는 PROGRAM POINTER를 제외한 모든 USAGE) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78a794760583154700dfa158ef52ff59305ad6d4" translate="yes" xml:space="preserve">
          <source>Of course, in keeping with the long-standing COBOL tradition of maintaining backwards compatibility with older standards, programmers (and, of course, compliant COBOL compilers) are capable of working in either mode. It is even possible to switch back and forth in the same program. The terms &amp;rsquo;</source>
          <target state="translated">물론, 오래된 표준과의 하위 호환성을 유지하는 오랜 COBOL 전통을 유지하면서 프로그래머 (물론 호환되는 COBOL 컴파일러)는 어느 모드에서나 작업 할 수 있습니다. 동일한 프로그램에서 앞뒤로 전환 할 수도 있습니다. '</target>
        </trans-unit>
        <trans-unit id="c2e2ad12fe5d5be1ef373c4a92ce471d2c101183" translate="yes" xml:space="preserve">
          <source>Of course, whatever software you are using to deliver the printed document to the printer with must allow the ASCII form-feed character to pass through to the printer.</source>
          <target state="translated">물론 인쇄 된 문서를 프린터로 전달하는 데 사용하는 소프트웨어는 ASCII 용지 공급 문자를 프린터로 전달할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="debcb349f44f33085c8c31a98daa95f7f75004d5" translate="yes" xml:space="preserve">
          <source>Of those currency symbols that correspond to character positions in which leading zeros reside, the right-most will have its &quot;0&quot; value replaced by the currency symbol in-effect for the program (see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;). Any remaining leading zero values occupying positions described by this symbol will be replaced by spaces.</source>
          <target state="translated">선행 0이있는 문자 위치에 해당하는 통화 기호 중 가장 오른쪽에 &quot;0&quot;값이 프로그램에 영향을주는 통화 기호로 대체됩니다 ( &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt; 참조 ). 이 기호로 표시된 위치를 차지하는 나머지 선행 0 값은 공백으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="6b4cb7a0fee3f3079461060f2f2b75e5bfc06ee6" translate="yes" xml:space="preserve">
          <source>Of those&lt;code&gt;+&lt;/code&gt;symbols that correspond to character positions in which leading zeros reside, the right-most will have its &quot;0&quot; value replaced by a &quot;+&quot; if the value in the data item is zero or greater or a &quot;-&quot; otherwise. Any remaining leading zero values occupying positions described by this symbol will be replaced by spaces. You cannot use both&lt;code&gt;+&lt;/code&gt;and&lt;code&gt;-&lt;/code&gt;in the same &amp;lt;</source>
          <target state="translated">선행 0이있는 문자 위치에 해당 하는 &lt;code&gt;+&lt;/code&gt; 기호 중 데이터 항목의 값이 0 이상이면 가장 오른쪽에있는 &quot;0&quot;값이 &quot;+&quot;로 바뀌고 그렇지 않으면 &quot;-&quot;가됩니다. 이 기호로 표시된 위치를 차지하는 나머지 선행 0 값은 공백으로 바뀝니다. &lt;code&gt;+&lt;/code&gt; 와 &lt;code&gt;-&lt;/code&gt; 를 동시에 사용할 수 없습니다 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="bbf75e8475f5c8168cfdefa614e07198b0695e55" translate="yes" xml:space="preserve">
          <source>Of those&lt;code&gt;-&lt;/code&gt;symbols that correspond to character positions in which leading zeros reside, the right-most will have its &quot;0&quot; value replaced by a space if the value in the data item is zero or greater or a &quot;-&quot; otherwise. Any remaining leading zero values occupying positions described by this symbol will be replaced by spaces. You cannot use both&lt;code&gt;+&lt;/code&gt;and&lt;code&gt;-&lt;/code&gt;in the same &amp;lt;</source>
          <target state="translated">이 중 &lt;code&gt;-&lt;/code&gt; &quot;-&quot;그렇지 않으면 데이터 항목의 값이 0 이상이거나 경우 문자 앞에 0이 상주하는 문자 위치에 해당하는이, 우측은 가장 공백으로 대체의 &quot;0&quot;값을 가질 것이다. 이 기호로 표시된 위치를 차지하는 나머지 선행 0 값은 공백으로 바뀝니다. &lt;code&gt;+&lt;/code&gt; 와 &lt;code&gt;-&lt;/code&gt; 를 동시에 사용할 수 없습니다 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="8b1fab1aa655192e46dd089ef5dc5c15017129e0" translate="yes" xml:space="preserve">
          <source>On UNIX (including OSX, Windows/Cygwin and Windows/MinGW) systems, your locale is established via the</source>
          <target state="translated">UNIX (OSX, Windows / Cygwin 및 Windows / MinGW 포함) 시스템에서 로케일은</target>
        </trans-unit>
        <trans-unit id="7a4815ab2f080a81cd2be95835f85ca49905ca48" translate="yes" xml:space="preserve">
          <source>On Unix, OSX, or Windows/Cygwin builds, the&lt;code&gt;-x&lt;/code&gt;switch switch will generate an executable binary file, usually with no particular extension unless one is explicitly requested of the compiler via the&lt;code&gt;-o&lt;/code&gt;switch</source>
          <target state="translated">Unix, OSX 또는 Windows / Cygwin 빌드에서 &lt;code&gt;-x&lt;/code&gt; 스위치 스위치는 실행 가능한 이진 파일을 생성합니다. 일반적으로 &lt;code&gt;-o&lt;/code&gt; 스위치 를 통해 명시 적으로 컴파일러에 요청 된 경우가 아니면 특별한 확장명을 갖지 않습니다.</target>
        </trans-unit>
        <trans-unit id="baa101f65e9944384124638ea3189587789c566a" translate="yes" xml:space="preserve">
          <source>On Windows systems, single-quote, or apostrophe characters (&amp;rsquo;) will be treated just like any other data character and will NOT delineate argument strings.</source>
          <target state="translated">Windows 시스템에서 작은 따옴표 또는 아포스트로피 문자 ( ')는 다른 데이터 문자처럼 취급되며 인수 문자열을 나타내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4540801fc126e86f0e453dd121110c00baa3a3f3" translate="yes" xml:space="preserve">
          <source>On a UNIX system this means the programs may be executed from a command shell such as bash, csh, ksh and so forth. When a GnuCOBOL program runs on a Windows system, it runs within a console window (i.e. &quot;cmd.exe&quot;). OSX versions of GnuCOBOL programs run within a &quot;terminal.app&quot; window.</source>
          <target state="translated">UNIX 시스템에서 이것은 프로그램이 bash, csh, ksh 등과 같은 명령 쉘에서 실행될 수 있음을 의미합니다. GnuCOBOL 프로그램이 Windows 시스템에서 실행될 때 콘솔 창 (예 : &quot;cmd.exe&quot;) 내에서 실행됩니다. GnuCOBOL 프로그램의 OSX 버전은 &quot;terminal.app&quot;창에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="29e07a8440be1b45abe631d62a1c13d7f8e27480" translate="yes" xml:space="preserve">
          <source>On a Unix system, the shell environment will be established using the default shell program. This is also true when using a GnuCOBOL build created with and for OSX or the Cygwin Unix emulator.</source>
          <target state="translated">유닉스 시스템에서 쉘 환경은 기본 쉘 프로그램을 사용하여 설정됩니다. OSX 또는 Cygwin Unix 에뮬레이터로 생성 된 GnuCOBOL 빌드를 사용할 때도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="09cea21f0e62fb9defc06b78067faf5ba65df913" translate="yes" xml:space="preserve">
          <source>On a Windows system, the&lt;code&gt;TMP&lt;/code&gt;environment variable is normally set for you when you logon. If you wish to use a different temporary folder, you may set&lt;code&gt;TMPDIR&lt;/code&gt;yourself and have no fear of disrupting other Windows software that relies on TMP.</source>
          <target state="translated">Windows 시스템에서는 일반적으로 로그온 할 때 &lt;code&gt;TMP&lt;/code&gt; 환경 변수가 설정됩니다. 다른 임시 폴더를 사용하려면 &lt;code&gt;TMPDIR&lt;/code&gt; 을 직접 설정 하고 TMP에 의존하는 다른 Windows 소프트웨어를 방해 할 염려가 없습니다.</target>
        </trans-unit>
        <trans-unit id="49c811f291ecda0c24fa5479b92e28877266432a" translate="yes" xml:space="preserve">
          <source>On a system supporting only one format of binary storage (generally, that would be big-endian), the terms &amp;rsquo;most-efficient&amp;rsquo; and &amp;rsquo;native format&amp;rsquo; are synonymous.</source>
          <target state="translated">하나의 이진 저장 형식 (일반적으로 빅 엔디안) 만 지원하는 시스템에서 '가장 효율적인'및 '네이티브 형식'이라는 용어는 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="8cf55637bf6e9946a839f557065a9756657be924" translate="yes" xml:space="preserve">
          <source>On the first presentation of the detail group after any control break occurs.</source>
          <target state="translated">제어 중단 후 세부 사항 그룹의 첫 번째 프리젠 테이션에서.</target>
        </trans-unit>
        <trans-unit id="e5bea69f1d184e8b4396de7835faab7aa40b288f" translate="yes" xml:space="preserve">
          <source>On the first presentation of the detail group after every new page is started.</source>
          <target state="translated">모든 새 페이지가 시작된 후 세부 사항 그룹의 첫 번째 프리젠 테이션에서.</target>
        </trans-unit>
        <trans-unit id="17545f79b06e402b5aa4758aadea0e8d4f7b4497" translate="yes" xml:space="preserve">
          <source>On the first presentation of the detail group following the&lt;code&gt;INITIATE&lt;/code&gt;(see &lt;a href=&quot;#INITIATE&quot;&gt;INITIATE&lt;/a&gt;) of the report.</source>
          <target state="translated">보고서 의 &lt;code&gt;INITIATE&lt;/code&gt; ( &lt;a href=&quot;#INITIATE&quot;&gt;INITIATE&lt;/a&gt; 참조 ) 다음에 세부 사항 그룹의 첫 번째 프리젠 테이션에서 .</target>
        </trans-unit>
        <trans-unit id="621bb9957748f1c9660b66609e36e16b3f8976de" translate="yes" xml:space="preserve">
          <source>Once GnuCOBOL programs have been compiled into either directly-executable programs (created via the&lt;code&gt;-x&lt;/code&gt;switch) or dynamically-loadable libraries (created via the&lt;code&gt;-m&lt;/code&gt;switch), those programs may be executed from any shell environment. The exact manner in which the two are executed will differ, as described in the upcoming sections.</source>
          <target state="translated">GnuCOBOL 프로그램이 직접 실행 가능한 프로그램 ( &lt;code&gt;-x&lt;/code&gt; 스위치 를 통해 생성됨 ) 또는 동적으로로드 가능한 라이브러리 ( &lt;code&gt;-m&lt;/code&gt; 스위치 를 통해 생성됨) 로 컴파일되면 해당 프로그램은 모든 쉘 환경에서 실행될 수 있습니다. 다음 섹션에서 설명하는 것처럼 두 가지를 실행하는 정확한 방식은 다릅니다.</target>
        </trans-unit>
        <trans-unit id="77004179f0b5866728a6a173ab6e2cd8c6678cae" translate="yes" xml:space="preserve">
          <source>Once a Format 1&lt;code&gt;REPLACE&lt;/code&gt;statement is encountered in the currently-compiling source file, Replace Mode becomes active, and the change(s) specified by that statement will be automatically made on all subsequent source statements the compiler reads from the file.</source>
          <target state="translated">현재 컴파일중인 소스 파일에서 형식 1 &lt;code&gt;REPLACE&lt;/code&gt; 문이 발생하면 대체 모드가 활성화되고 해당 명령문으로 지정된 변경이 컴파일러가 파일에서 읽는 모든 후속 소스 명령문에서 자동으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="dc16e338caa3250507aeb7e1c7c59077ca7fc160" translate="yes" xml:space="preserve">
          <source>Once a dynamically-loadable module is actually loaded into memory, even if it is subsequently unloaded (via the&lt;code&gt;CANCEL&lt;/code&gt;statement), it&amp;rsquo;s list of entry-points remain available to the GnuCOBOL run-time library and subsequent re-executions of any of those entry points will be able to bypass the search (rule #4) as well as the &quot;first-execution rule&quot; (rule #3).</source>
          <target state="translated">동적으로로드 가능한 모듈이 실제로 메모리에로드되면 ( &lt;code&gt;CANCEL&lt;/code&gt; 문을 통해) 나중에 언로드하더라도 엔트리 포인트 목록은 GnuCOBOL 런타임 라이브러리에서 계속 사용할 수 있으며 해당 엔트리의 재실행은 계속 유지됩니다. 포인트는 &quot;첫 실행 규칙&quot;(규칙 # 3)뿐만 아니라 검색 (규칙 # 4)을 우회 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59e918dab4bdf59a27422aa9bebbbdf5591d8385" translate="yes" xml:space="preserve">
          <source>Once a field list has been determined, each item in that field list will be initialized as if an individual&lt;code&gt;MOVE&lt;/code&gt;(see &lt;a href=&quot;#MOVE&quot;&gt;MOVE&lt;/a&gt;) statement to that effect had been coded. The rules for initialization are as follows:</source>
          <target state="translated">필드 목록이 결정되면 해당 필드 목록의 각 항목은 해당 효과에 대한 개별 &lt;code&gt;MOVE&lt;/code&gt; ( &lt;a href=&quot;#MOVE&quot;&gt;MOVE&lt;/a&gt; 참조 ) 명령문이 코딩 된 것처럼 초기화됩니다 . 초기화 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="286757838794003214e83168a9d3c53442e79df6" translate="yes" xml:space="preserve">
          <source>Once an environment variable name base (let&amp;rsquo;s refer to it as &quot;bbbb&quot;) has been determined, the runtime system will look for the first one of the following environment variables that exists, in this sequence:</source>
          <target state="translated">환경 변수 이름 기반 ( &quot;bbbb&quot;라고 함)이 결정되면 런타임 시스템은 다음 순서로 존재하는 다음 환경 변수 중 첫 번째 변수를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="e625244fde391b91510dca176749dade404d9a46" translate="yes" xml:space="preserve">
          <source>Once class &quot;Hexadecimal&quot; has been defined, program code could then use a statement such as&lt;code&gt;IF input-item IS Hexadecimal&lt;/code&gt;to determine if the value of characters in a data item are valid according to that class.</source>
          <target state="translated">&quot;16 진수&quot;클래스가 정의되면 프로그램 코드는 &lt;code&gt;IF input-item IS Hexadecimal&lt;/code&gt; 와 같은 명령문을 사용 하여 데이터 항목의 문자 값이 해당 클래스에 따라 유효한지 여부를 판별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0585d2910d0c3575c9ce966ec284963466eee0b8" translate="yes" xml:space="preserve">
          <source>Once in that form, mathematical operations may be performed against the internal date before it is transformed back into a date using the&lt;code&gt;DATE-OF-INTEGER&lt;/code&gt;(see &lt;a href=&quot;#DATE_002dOF_002dINTEGER&quot;&gt;DATE-OF-INTEGER&lt;/a&gt;) or&lt;code&gt;DAY-OF-INTEGER&lt;/code&gt;(see &lt;a href=&quot;#DAY_002dOF_002dINTEGER&quot;&gt;DAY-OF-INTEGER&lt;/a&gt;) function.</source>
          <target state="translated">해당 양식에 들어가면 &lt;code&gt;DATE-OF-INTEGER&lt;/code&gt; ( &lt;a href=&quot;#DATE_002dOF_002dINTEGER&quot;&gt;DATE-OF-INTEGER 참조&lt;/a&gt; ) 또는 &lt;code&gt;DAY-OF-INTEGER&lt;/code&gt; ( &lt;a href=&quot;#DAY_002dOF_002dINTEGER&quot;&gt;DAY-OF-INTEGER&lt;/a&gt; 참조 )를 사용하여 날짜 로 다시 변환되기 전에 내부 날짜에 대해 수학 연산을 수행 할 수 있습니다. ) 함수.</target>
        </trans-unit>
        <trans-unit id="3d181d18b6a5fa0a6fa8cff3acb56941d7cd3053" translate="yes" xml:space="preserve">
          <source>Once read from the file, the newly-retrieved record data will be saved into the 01-level record structure(s) that immediately follow the file&amp;rsquo;s&lt;code&gt;FD&lt;/code&gt; If the optional&lt;code&gt;INTO&lt;/code&gt;</source>
          <target state="translated">파일에서 읽은 후 새로 검색된 레코드 데이터는 파일의 &lt;code&gt;FD&lt;/code&gt; 를 바로 따르는 01 레벨 레코드 구조에 저장됩니다 ( 선택적 &lt;code&gt;INTO&lt;/code&gt; 인 경우).</target>
        </trans-unit>
        <trans-unit id="ed7991d9259d5488ffed54f05830f63330c16c88" translate="yes" xml:space="preserve">
          <source>Once the &amp;lt;</source>
          <target state="translated">한 번 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="76eaa092cafda97efbcf2f6303d6984802250d02" translate="yes" xml:space="preserve">
          <source>Once the address of a procedure division code area has been acquired in this way, the address could be passed to a subroutine (usually written in C) for whatever use it needs it for. For examples of&lt;code&gt;PROGRAM-POINTER&lt;/code&gt; at work, see the discussions of the&lt;code&gt;CBL_ERROR_PROC&lt;/code&gt;built-in system subroutine (see &lt;a href=&quot;#CBL_005fERROR_005fPROC&quot;&gt;CBL_ERROR_PROC&lt;/a&gt;) and&lt;code&gt;CBL_EXIT_PROC&lt;/code&gt;built-in system subroutine (see &lt;a href=&quot;#CBL_005fEXIT_005fPROC&quot;&gt;CBL_EXIT_PROC&lt;/a&gt;).</source>
          <target state="translated">절차 분할 코드 영역의 주소가 이러한 방식으로 획득되면, 주소는 필요한 용도로 서브 루틴 (일반적으로 C로 작성 됨)으로 전달 될 수 있습니다. 작동중인 &lt;code&gt;PROGRAM-POINTER&lt;/code&gt; 의 예는 &lt;code&gt;CBL_ERROR_PROC&lt;/code&gt; 내장 시스템 서브 루틴 ( &lt;a href=&quot;#CBL_005fERROR_005fPROC&quot;&gt;CBL_ERROR_PROC&lt;/a&gt; 참조 ) 및 &lt;code&gt;CBL_EXIT_PROC&lt;/code&gt; 내장 시스템 서브 루틴 ( &lt;a href=&quot;#CBL_005fEXIT_005fPROC&quot;&gt;CBL_EXIT_PROC&lt;/a&gt; 참조 )에 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7b3e993beace23677f33388c1750dc84928bf9a" translate="yes" xml:space="preserve">
          <source>Once the dynamically-loadable module has been successfully loaded, any of the entry-points contained within it are now available for reference.</source>
          <target state="translated">동적으로로드 가능한 모듈이 성공적으로로드되면 모듈에 포함 된 진입 점을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf655804b96355c58d780ad7c184b2358e70ed87" translate="yes" xml:space="preserve">
          <source>Once the input procedure terminates, the input phase is complete.</source>
          <target state="translated">입력 절차가 끝나면 입력 단계가 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="3fd5f8ce1885cd5e6704d4107925ee0fa79ae370" translate="yes" xml:space="preserve">
          <source>Once the list of control breaks has been determined, the&lt;code&gt;CONTROL FOOTING&lt;/code&gt;for each &amp;lt;</source>
          <target state="translated">브레이크 제어 목록은 결정되면 &lt;code&gt;CONTROL FOOTING&lt;/code&gt; 각각을 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="da82fa2addff5a8b53971b5198ac5b3f2dbaf44c" translate="yes" xml:space="preserve">
          <source>Once the module has been located (if location was needed), it will be loaded into memory (if not already loaded).</source>
          <target state="translated">일단 모듈을 찾으면 (위치가 필요한 경우) 메모리에로드됩니다 (아직로드되지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="4ea7f4222f4e79b517953879f7a0910e37dccbb7" translate="yes" xml:space="preserve">
          <source>Once the output procedure terminates, or the last &amp;lt;</source>
          <target state="translated">출력 절차가 종료되거나 마지막 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="ff0f3a202fb5e56e9e5055a0c22a464e320087b3" translate="yes" xml:space="preserve">
          <source>Once the output procedure terminates, the sort is complete.</source>
          <target state="translated">출력 절차가 끝나면 정렬이 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="aa2d27ad2b6a5bb2d485b2b3cf531800fdf57d2a" translate="yes" xml:space="preserve">
          <source>Once the sort stage is complete, a copy of the sorted data will be written to each &amp;lt;</source>
          <target state="translated">정렬 단계가 완료되면 정렬 된 데이터의 사본이 각 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="a952da0c3633e235f52bb16ddddf1c8394a97156" translate="yes" xml:space="preserve">
          <source>Once tokens have been identified, the first (the command) will be discarded; the rest will be stored into the &quot;CHAINING&quot; arguments when the program begins execution, with the 2nd token going to the 1st argument, the 3rd token going to the 2nd argument and so forth.</source>
          <target state="translated">토큰이 식별되면 첫 번째 (명령)가 삭제됩니다. 나머지는 프로그램이 실행을 시작할 때 &quot;CHAINING&quot;인수에 저장되며, 두 번째 토큰은 첫 번째 인수로, 세 번째 토큰은 두 번째 인수로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="fc842de35b43065fcc2486b3f9cd1a54afa40e68" translate="yes" xml:space="preserve">
          <source>Once you have defined an alphabet name, that alphabet name may be used on specifications in&lt;code&gt;CODE-SET&lt;/code&gt;&lt;code&gt;COLLATING SEQUENCE&lt;/code&gt; or&lt;code&gt;SYMBOLIC CHARACTERS&lt;/code&gt;clauses elsewhere in the program.</source>
          <target state="translated">알파벳 이름을 정의하면 해당 알파벳 이름을 프로그램의 다른 곳에서 &lt;code&gt;CODE-SET&lt;/code&gt; &lt;code&gt;SYMBOLIC CHARACTERS&lt;/code&gt; &lt;code&gt;COLLATING SEQUENCE&lt;/code&gt; 또는 SYMBOLIC CHARACTERS 절의 스펙에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1db8d869f5e31c2a114146e31c6c3bb19304efe6" translate="yes" xml:space="preserve">
          <source>Once you know the answer to questions 1-4, you may easily determine the answers to the remaining questions as follows:</source>
          <target state="translated">질문 1-4에 대한 답을 알고 나면 다음과 같이 나머지 질문에 대한 답을 쉽게 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d64e944e7805a2994fd1366f274fdd6a314f0fc1" translate="yes" xml:space="preserve">
          <source>Once your program has been thoroughly tested, you&amp;rsquo;ll want different sequences to be generated each time the program runs. One possible way to accomplish this is to use a &amp;lt;</source>
          <target state="translated">프로그램이 철저히 테스트되면 프로그램이 실행될 때마다 다른 시퀀스가 ​​생성되기를 원할 것입니다. 이를 수행하는 한 가지 가능한 방법은 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="54f89a5962f679ffd2d3e844b0b1ce85b6df3297" translate="yes" xml:space="preserve">
          <source>One of these environment variables must be set to a directory/folder appropriate to create temporary files in. They will be checked in the order shown. This will be used by the&lt;code&gt;SORT&lt;/code&gt;statement (see &lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt;) and&lt;code&gt;MERGE&lt;/code&gt;statement (see &lt;a href=&quot;#MERGE&quot;&gt;MERGE&lt;/a&gt;) to create temporary work files. You may also use this folder for any temporary files your application may require.</source>
          <target state="translated">이러한 환경 변수 중 하나는 임시 파일을 작성하기에 적합한 디렉토리 / 폴더로 설정해야합니다. 표시된 순서대로 검사됩니다. 이것은에 의해 사용됩니다 &lt;code&gt;SORT&lt;/code&gt; 의 문 (참조 &lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt; ) 및 &lt;code&gt;MERGE&lt;/code&gt; 의 문 (참조 &lt;a href=&quot;#MERGE&quot;&gt;MERGE를&lt;/a&gt; ) 임시 작업 파일을 만들 수 있습니다. 응용 프로그램에 필요할 수있는 임시 파일에이 폴더를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6463f11b8fdf738c63c7b961b5112c2ffeb1404" translate="yes" xml:space="preserve">
          <source>One or more consecutive lines on a report that serve a common informational purpose or function. For example, lines of text that are displayed at the top or bottom of every printed page of a report.</source>
          <target state="translated">공통 정보 목적 또는 기능을 제공하는 보고서에서 하나 이상의 연속 행. 예를 들어, 보고서의 인쇄 된 모든 페이지의 상단 또는 하단에 표시되는 텍스트 줄입니다.</target>
        </trans-unit>
        <trans-unit id="6c681ed8f13156a1b9ed27937daab32b1e788722" translate="yes" xml:space="preserve">
          <source>Only after this processing has occurred will the detail report group specified on the&lt;code&gt;GENERATE&lt;/code&gt;be presented.</source>
          <target state="translated">이 처리가 수행 된 후에 만 &lt;code&gt;GENERATE&lt;/code&gt; 에 지정된 세부 사항 보고서 그룹 이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="003eead4533ce41b48b2d118ad6982ea6215902b" translate="yes" xml:space="preserve">
          <source>Only data items whose&lt;code&gt;USAGE&lt;/code&gt;(see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) is either explicitly or implicitly defined as&lt;code&gt;DISPLAY&lt;/code&gt;may be used in&lt;code&gt;NUMERIC&lt;/code&gt;or any of the&lt;code&gt;ALPHABETIC&lt;/code&gt;class conditions.</source>
          <target state="translated">그의 유일한 데이터 항목 &lt;code&gt;USAGE&lt;/code&gt; (참조 &lt;a href=&quot;#USAGE&quot;&gt;사용&lt;/a&gt; ) 명시 적으로 또는 암시 적으로 정의 &lt;code&gt;DISPLAY&lt;/code&gt; 사용될 수있다 &lt;code&gt;NUMERIC&lt;/code&gt; 또는 임의의 &lt;code&gt;ALPHABETIC&lt;/code&gt; 클래스 조건.</target>
        </trans-unit>
        <trans-unit id="d711ce7b6238bc52f8a6bcb50fdf5f00798177b9" translate="yes" xml:space="preserve">
          <source>Only files intended for use as work files for either the&lt;code&gt;SORT&lt;/code&gt;(see &lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt;) or&lt;code&gt;MERGE&lt;/code&gt;(see &lt;a href=&quot;#MERGE&quot;&gt;MERGE&lt;/a&gt;) statements should be coded with an SD &amp;mdash; all others should be defined with a FD.</source>
          <target state="translated">오직 하나의 작업 파일로 사용하기위한 파일 &lt;code&gt;SORT&lt;/code&gt; (참조 &lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt; ) 또는 &lt;code&gt;MERGE&lt;/code&gt; (참조 &lt;a href=&quot;#MERGE&quot;&gt;병합&lt;/a&gt; ) 문가 SD로 코딩해야한다 - 모든 사람은 FD로 정의되어야한다.</target>
        </trans-unit>
        <trans-unit id="5e7f05d01153592a3701f9579ca1ebed0c7e36f8" translate="yes" xml:space="preserve">
          <source>Only numeric data can be moved to a numeric or numeric-edited &amp;lt;</source>
          <target state="translated">숫자 데이터 만 숫자 또는 숫자로 편집 된 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="1a023314ae52d9ab2ebf57a5486f828683de142e" translate="yes" xml:space="preserve">
          <source>Only one of the &amp;lt;&amp;lt;</source>
          <target state="translated">&amp;lt;&amp;lt; 중 하나만</target>
        </trans-unit>
        <trans-unit id="6e90f6903d2acd5d4289ceddbb76ae736395dc5d" translate="yes" xml:space="preserve">
          <source>Only one user-defined error procedure may be in effect at any time.</source>
          <target state="translated">언제든지 하나의 사용자 정의 오류 절차 만 적용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27fae19fb8fcab28fe3712f2fe8be9894d412e8a" translate="yes" xml:space="preserve">
          <source>Only one user-defined exit procedure may be in effect at any time.</source>
          <target state="translated">언제든지 하나의 사용자 정의 종료 절차 만 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8276bb34bd3b8954c5e1d44b6e4b6663af21c5d2" translate="yes" xml:space="preserve">
          <source>Only the final clause specified within this paragraph should be terminated with a period.</source>
          <target state="translated">이 단락에 지정된 최종 조항 만 마침표로 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="19093a1f09bb5bb1f9ea7e1e012a0f82b409bbd3" translate="yes" xml:space="preserve">
          <source>Only the lowest-level directory (last) in the specified path can be created &amp;mdash; all others must already exist. This subroutine will NOT behave as a&lt;code&gt;mkdir -p&lt;/code&gt;(Unix) or&lt;code&gt;mkdir /p&lt;/code&gt;(Windows).</source>
          <target state="translated">지정된 경로에서 최하위 디렉토리 (마지막) 만 만들 수 있습니다. 다른 모든 디렉토리는 이미 존재해야합니다. 이 서브 루틴은 &lt;code&gt;mkdir -p&lt;/code&gt; (Unix) 또는 &lt;code&gt;mkdir /p&lt;/code&gt; (Windows) 로 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="18a2770fd2028b8848e5939f9beca76f8630c1c6" translate="yes" xml:space="preserve">
          <source>Only the lowest-level directory (last) in the specified path will be deleted, and that directory must be empty to be deleted.</source>
          <target state="translated">지정된 경로에서 최하위 디렉토리 (마지막) 만 삭제되며 해당 디렉토리는 비어 있어야 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="1aec312e1ee36a7183965a81eb1e3cb89dc201e9" translate="yes" xml:space="preserve">
          <source>Only those as-yet uninitialized list members meeting the criteria set forth for the specified &amp;lt;</source>
          <target state="translated">아직 초기화되지 않은리스트 멤버 만 지정된 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="e4d4f39f5c6f13114530b1c856be188e28a33feb" translate="yes" xml:space="preserve">
          <source>Opening a file with this sharing option indicates you are willing to allow other programs to&lt;code&gt;OPEN&lt;/code&gt;the file for input while you have it open. If they attempt any other&lt;code&gt;OPEN&lt;/code&gt; theirs will fail with a file status of 37. Of course, your program may fail if someone else got to the file first and opened it with a sharing option that imposed file-sharing limitations.</source>
          <target state="translated">이 공유 옵션으로 파일을 열면 다른 프로그램이 할 수 있도록 기꺼이 나타냅니다 &lt;code&gt;OPEN&lt;/code&gt; 당신이 그것을 열려있는 동안 입력 파일을. 다른 &lt;code&gt;OPEN&lt;/code&gt; 을 시도 하면 파일 상태가 37 인 상태로 실패합니다. 물론 다른 사람이 먼저 파일을 가져 와서 파일 공유 제한을 부과하는 공유 옵션으로 파일을 열면 프로그램이 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b290988bf20769fb3be0ec9ad35e8ff883c8e032" translate="yes" xml:space="preserve">
          <source>Optionally, the&lt;code&gt;-o&lt;/code&gt;switch</source>
          <target state="translated">선택적으로 &lt;code&gt;-o&lt;/code&gt; 스위치</target>
        </trans-unit>
        <trans-unit id="447171bcea279a3f9260c4de4e227c2d6dd68c76" translate="yes" xml:space="preserve">
          <source>Or it could simply utilize the condition name XL as follows:</source>
          <target state="translated">또는 다음과 같이 조건 이름 XL을 간단히 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="370e4c255f90d246d5721bdc9fd05e213464a25e" translate="yes" xml:space="preserve">
          <source>Or, on a Native Windows or Windows/MinGW system:</source>
          <target state="translated">또는 기본 Windows 또는 Windows / MinGW 시스템에서 :</target>
        </trans-unit>
        <trans-unit id="ba479d2e9dd775cad43c293e560fad3af36bde42" translate="yes" xml:space="preserve">
          <source>Other programming language provide the programmer with a similar capability of creating their own words (names) for parts of a program; COBOL is somewhat unusual when compared to other languages in that user-defined words may</source>
          <target state="translated">다른 프로그래밍 언어는 프로그래머에게 프로그램의 일부에 대해 고유 한 단어 (이름)를 작성하는 유사한 기능을 제공합니다. COBOL은 사용자 정의 단어에서 다른 언어와 비교할 때 다소 특이합니다.</target>
        </trans-unit>
        <trans-unit id="8bbcce1456c742787b1580fde33b8148c8987df5" translate="yes" xml:space="preserve">
          <source>Out of key range</source>
          <target state="translated">키 범위를 벗어남</target>
        </trans-unit>
        <trans-unit id="a553d2153badfb1db45ee73715be9107f08adc68" translate="yes" xml:space="preserve">
          <source>Output from the command (if any) will appear in the command window in which the GnuCOBOL program was executed.</source>
          <target state="translated">GnuCOBOL 프로그램이 실행 된 명령 창에 명령의 출력 (있는 경우)이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="bf18ec4bed8c30a9b19eac1b32547e33a663188d" translate="yes" xml:space="preserve">
          <source>Over the years, there has been much debate over the efficiency and arithmetic accuracy of using the&lt;code&gt;COMPUTE&lt;/code&gt;statement (see &lt;a href=&quot;#COMPUTE&quot;&gt;COMPUTE&lt;/a&gt;) rather than the four basic arithmetic operation statements.</source>
          <target state="translated">수년에 걸쳐 4 가지 기본 산술 연산 문 대신 &lt;code&gt;COMPUTE&lt;/code&gt; 문 ( &lt;a href=&quot;#COMPUTE&quot;&gt;COMPUTE&lt;/a&gt; 참조 ) 을 사용하는 효율성과 산술 정확도에 대해 많은 논쟁이있었습니다 .</target>
        </trans-unit>
        <trans-unit id="0e6ac5f3f6d5399374fefa09919d1c279a782632" translate="yes" xml:space="preserve">
          <source>Overflow condition</source>
          <target state="translated">오버 플로우 조건</target>
        </trans-unit>
        <trans-unit id="9caea4b058bdda37551cfd4b0757e6365f49b9e6" translate="yes" xml:space="preserve">
          <source>PACKED-DECIMAL, PADDING, PAGE, PAGE-COUNTER, PARAGRAPH, PERFORM, PF, PH, PI, PIC, PICTURE, PLUS, POINTER, POSITION, POSITIVE, PREFIXED, PRESENT, PRESENT-VALUE, PREVIOUS, PRINT, PRINTER, PRINTER-1, PRINTING, PROCEDURE, PROCEDURE-POINTER, PROCEDURES, PROCEED, PROGRAM, PROGRAM-ID, PROGRAM-POINTER, PROHIBITED, PROMPT, PROPERTY, PROTECTED, PROTOTYPE, PURGE</source>
          <target state="translated">팩형, 패딩, 페이지, 페이지 카운터, 패러 그래프, 퍼포먼스, PF, PH, PI, PIC, PICTURE, PLUS, POINTER, POSITION, POSITIVE, PREFIXED, PRESENT, 현재 가치, 이전, 인쇄, 프린터, 프린터- 1, 인쇄, 절차, 절차 -POINTER, 절차, PROCERAMRES, PROGRAM, PROGRAM-ID, 프로그램 -POINTER, 금지, 프롬프트, 속성, 보호, 프로토 타입, 퍼지</target>
        </trans-unit>
        <trans-unit id="d48971351ade6fc5f890bc67a75e3fa21b22ca7e" translate="yes" xml:space="preserve">
          <source>PAGE FOOTING [1]</source>
          <target state="translated">페이지 풋팅 [1]</target>
        </trans-unit>
        <trans-unit id="74d126652169159b5d6e6ea5e735209263036ae6" translate="yes" xml:space="preserve">
          <source>PAGE HEADING [1]</source>
          <target state="translated">페이지 머리글 [1]</target>
        </trans-unit>
        <trans-unit id="a7aa2c13f70d4d267a113972d52fc8706a2f0e22" translate="yes" xml:space="preserve">
          <source>PI Function Syntax</source>
          <target state="translated">PI 함수 구문</target>
        </trans-unit>
        <trans-unit id="b3194ebbb74c1fdb2502a50c00eae2deeb0fe962" translate="yes" xml:space="preserve">
          <source>PIC 9(4) &amp;mdash; This is the default data item allocated for use by the&lt;code&gt;ACCEPT &amp;lt;&lt;i&gt;screen-data-item&lt;/i&gt;&amp;gt;&lt;/code&gt;statement (see &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;), if no&lt;code&gt;CRT STATUS&lt;/code&gt;(see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) clause was specified..</source>
          <target state="translated">PIC 9 (4) &amp;mdash; &lt;code&gt;CRT STATUS&lt;/code&gt; ( &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt; 참조 ) 절이 지정 되지 않은 경우 &lt;code&gt;ACCEPT &amp;lt;&lt;i&gt;screen-data-item&lt;/i&gt;&amp;gt;&lt;/code&gt; 문 ( &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt; 참조)에 의해 사용되도록 할당 된 기본 데이터 항목 입니다. .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
