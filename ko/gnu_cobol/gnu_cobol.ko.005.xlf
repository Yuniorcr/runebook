<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="gnu_cobol">
    <body>
      <group id="gnu_cobol">
        <trans-unit id="0fc0cf31d380c601652f18b89e88c9440ae44509" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;GLOBAL&lt;/code&gt;(see &lt;a href=&quot;#GLOBAL&quot;&gt;GLOBAL&lt;/a&gt;) option, if used, allows a declarative procedure to be used across the program containing the&lt;code&gt;USE&lt;/code&gt;statement and any subprograms nested within that program.</source>
          <target state="translated">&lt;code&gt;GLOBAL&lt;/code&gt; (참조 &lt;a href=&quot;#GLOBAL&quot;&gt;GLOBAL을&lt;/a&gt; ) 옵션을 사용하는 경우, 선언적인 절차가 포함 된 프로그램을 통해 사용할 수 있습니다 &lt;code&gt;USE&lt;/code&gt; 문을 및 서브 프로그램은 그 프로그램 내에 중첩.</target>
        </trans-unit>
        <trans-unit id="240c10ec2d49e82b240cb5715a5fc14b42af2e23" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;GLOBAL&lt;/code&gt;clause may only be specified at the 77 or 01 level.</source>
          <target state="translated">&lt;code&gt;GLOBAL&lt;/code&gt; 절은 77 또는 01 레벨에서 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="240bee57d6a7efd96456c540029cdd16308db77b" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;GROUP INDICATE&lt;/code&gt;clause specifies that the data item in whose definition the clause appears will be presented only in very limited circumstances.</source>
          <target state="translated">&lt;code&gt;GROUP INDICATE&lt;/code&gt; 데이터 항목이 그 정의에 절 나타납니다 만 매우 제한된 경우에 표시됩니다 절을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="092a1706b012a6b5b377ba35011edef971368020" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;HEADING&lt;/code&gt;</source>
          <target state="translated">The&lt;code&gt;HEADING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bc78f46fecb70d98a28dfbb8142ef85185373142" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;IDENTIFICATION DIVISION.&lt;/code&gt;header is always optional.</source>
          <target state="translated">&lt;code&gt;IDENTIFICATION DIVISION.&lt;/code&gt; 헤더는 항상 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="ba482728d471d9105aac31726e7e313ffb035224" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;INITIAL&lt;/code&gt;</source>
          <target state="translated">The&lt;code&gt;INITIAL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5dbf67f7d784d03d80e375cee901235615d6576e" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;INITIAL&lt;/code&gt;&lt;code&gt;COMMON&lt;/code&gt;and&lt;code&gt;RECURSIVE&lt;/code&gt;words are used only within subprograms serving as subroutines. Their purposes are as follows:</source>
          <target state="translated">&lt;code&gt;INITIAL&lt;/code&gt; &lt;code&gt;COMMON&lt;/code&gt; 및 &lt;code&gt;RECURSIVE&lt;/code&gt; 말은 서브 루틴의 역할을 서브 프로그램 내에서 사용된다. 그들의 목적은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e26477fdc925216e88967ba6abb6ae023c5f02a2" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;INITIATE&lt;/code&gt;statement will initialize all of the following for each report named on the statement:</source>
          <target state="translated">은 &lt;code&gt;INITIATE&lt;/code&gt; 문은 문에 이름이 각 보고서에 대한 다음의 모든 초기화합니다 :</target>
        </trans-unit>
        <trans-unit id="a812729603250bbd74845df26369dd4dd2ca6424" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;INSPECT&lt;/code&gt;statement will make a single pass through the sequence of characters comprising the inspect subject. As the pointer to the current inspect target character reaches a point where it falls within the explicit or implicit target ranges specified on the operational instructions of the two clauses, the actions specified by those instructions will become eligible to be taken. As the character pointer reaches a point where it falls past the end of target ranges, the instructions belonging to those target ranges will become disabled.</source>
          <target state="translated">은 &lt;code&gt;INSPECT&lt;/code&gt; 문은이 주제를 검사 포함하는 문자의 순서를 통해 단일 패스를 만들 것입니다. 현재 검사 대상 문자에 대한 포인터가 두 절의 작동 지침에 지정된 명시 적 또는 암시 적 대상 범위 내에있는 지점에 도달하면 해당 명령으로 지정된 작업을 수행 할 수 있습니다. 문자 포인터가 목표 범위의 끝을 넘어가는 지점에 도달하면 해당 목표 범위에 속하는 명령이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="dc3efb2d833410d14d77c014d4d15de9bf238bb9" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;INTRINSIC&lt;/code&gt;</source>
          <target state="translated">The&lt;code&gt;INTRINSIC&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c128e9074e2fdd0f9a1510881726ab5b336acdd9" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;IS &amp;lt;&lt;i&gt;mnemonic-name-1&lt;/i&gt;&amp;gt;&lt;/code&gt;syntax provides a means for setting the switch to either an ON or OFF value via the&lt;code&gt;SET&lt;/code&gt;statement (see &lt;a href=&quot;#SET&quot;&gt;SET&lt;/a&gt;).</source>
          <target state="translated">은 &lt;code&gt;IS &amp;lt;&lt;i&gt;mnemonic-name-1&lt;/i&gt;&amp;gt;&lt;/code&gt; 구문을 통해 ON이나 OFF 중 어느 하나의 값으로 스위치를 설정하는 수단을 제공 &lt;code&gt;SET&lt;/code&gt; 의 (참조 문 &lt;a href=&quot;#SET&quot;&gt;SET를&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b3826fac21a8db135a89a82474010a532f026623" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;LAST CONTROL&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;LAST CONTROL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e828ae214d21e345ec6cc338a453dd469572ed06" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;LAST DETAIL&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;LAST DETAIL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="28963f95ba7d07fa8c767c4da0dde92b91de94cf" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;LEFT&lt;/code&gt;and&lt;code&gt;RIGHT&lt;/code&gt;(SYNCRONIZED) clauses are syntactically recognized but are otherwise non-functional.</source>
          <target state="translated">&lt;code&gt;LEFT&lt;/code&gt; 와 &lt;code&gt;RIGHT&lt;/code&gt; (동기화 된 안정된) 절은 구문 적으로 인식하지만, 그렇지 않은 비 기능입니다.</target>
        </trans-unit>
        <trans-unit id="8763f071994cf95d11eb0c9a249ade5467851a72" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;LEFTLINE&lt;/code&gt;(see &lt;a href=&quot;#LEFTLINE&quot;&gt;LEFTLINE&lt;/a&gt;),&lt;code&gt;OVERLINE&lt;/code&gt;(see &lt;a href=&quot;#OVERLINE&quot;&gt;OVERLINE&lt;/a&gt;) and&lt;code&gt;UNDERLINE&lt;/code&gt;clauses may be used in any combination in a single field&amp;rsquo;s description.</source>
          <target state="translated">&lt;code&gt;LEFTLINE&lt;/code&gt; (참조 &lt;a href=&quot;#LEFTLINE&quot;&gt;LEFTLINE를&lt;/a&gt; ) &lt;code&gt;OVERLINE&lt;/code&gt; (참조 &lt;a href=&quot;#OVERLINE&quot;&gt;윗줄을&lt;/a&gt; ) 및 &lt;code&gt;UNDERLINE&lt;/code&gt; 절은 하나의 필드의 설명에있어서의 임의의 조합으로 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="efc1a0aaea882aa8e5b2b11ac0c091aa05ac792c" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;LEFTLINE&lt;/code&gt;(see &lt;a href=&quot;#LEFTLINE&quot;&gt;LEFTLINE&lt;/a&gt;),&lt;code&gt;OVERLINE&lt;/code&gt;and&lt;code&gt;UNDERLINE&lt;/code&gt;(see &lt;a href=&quot;#UNDERLINE&quot;&gt;UNDERLINE&lt;/a&gt;) clauses may be used in any combination in a single field&amp;rsquo;s description.</source>
          <target state="translated">&lt;code&gt;LEFTLINE&lt;/code&gt; 는 (참조 &lt;a href=&quot;#LEFTLINE&quot;&gt;LEFTLINE를&lt;/a&gt; ) &lt;code&gt;OVERLINE&lt;/code&gt; 과 &lt;code&gt;UNDERLINE&lt;/code&gt; (참조 &lt;a href=&quot;#UNDERLINE&quot;&gt;UNDERLINE&lt;/a&gt; ) 절은 하나의 필드의 설명에있어서의 임의의 조합으로 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="3bf090a375e9e923f069d91ebb057803a43b5901" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;LEFTLINE&lt;/code&gt;&lt;code&gt;OVERLINE&lt;/code&gt;(see &lt;a href=&quot;#OVERLINE&quot;&gt;OVERLINE&lt;/a&gt;) and&lt;code&gt;UNDERLINE&lt;/code&gt;(see &lt;a href=&quot;#UNDERLINE&quot;&gt;UNDERLINE&lt;/a&gt;) clauses may be used in any combination in a single field&amp;rsquo;s description.</source>
          <target state="translated">&lt;code&gt;LEFTLINE&lt;/code&gt; &lt;code&gt;OVERLINE&lt;/code&gt; (참조 &lt;a href=&quot;#OVERLINE&quot;&gt;윗줄&lt;/a&gt; )과 &lt;code&gt;UNDERLINE&lt;/code&gt; (참조 &lt;a href=&quot;#UNDERLINE&quot;&gt;UNDERLINE&lt;/a&gt; ) 절은 하나의 필드의 설명에있어서의 임의의 조합으로 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="5d98ac017e9120de8c4e1f659ee0afc48de458f7" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;LEFTLINE&lt;/code&gt;clause will introduce a vertical line at the left edge of a screen field.</source>
          <target state="translated">&lt;code&gt;LEFTLINE&lt;/code&gt; 의 절은 화면 필드의 왼쪽 가장자리에 수직 라인을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="7f17ea951c4c119e24f3bed71fa9ead62c195cc5" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;LENGTH OF&lt;/code&gt;clause on a literal or identifier reference may generally be used anywhere a numeric literal might be specified, with the following exceptions:</source>
          <target state="translated">리터럴 또는 식별자 참조 의 &lt;code&gt;LENGTH OF&lt;/code&gt; 절은 일반적으로 다음을 제외하고 숫자 리터럴이 지정된 모든 위치에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cb10159c054730e96f9d055565111a8f0ade1c8" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;LENGTH-CHECK&lt;/code&gt;clause forces the user to enter data into the field it is specified on (or into all subordinate input-capable fields if specified on a group item) sufficient to fill every character position of the field.</source>
          <target state="translated">&lt;code&gt;LENGTH-CHECK&lt;/code&gt; 절 힘은 사용자가 상 (또는 그룹 항목에 지정된 경우, 하위의 모든 입력 가능한 필드로) 필드의 모든 문자 위치를 채우기에 충분한 지정된 필드에 데이터를 입력한다.</target>
        </trans-unit>
        <trans-unit id="c8978ba84e6193b722cc1a188a1963fa998e039f" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;LENGTH&lt;/code&gt;clause will produce a numeric value for &amp;lt;</source>
          <target state="translated">&lt;code&gt;LENGTH&lt;/code&gt; 절에 대한 숫자 값을 생성합니다 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="3e1e7e24a4893be326c12bb6bc4166545b89656c" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;LINAGE&lt;/code&gt;clause may only be specified in the&lt;code&gt;FD&lt;/code&gt;of a sequential or line sequential file. If used with a sequential file, the organization of that file will be implicitly changed to line sequential. The various components of the&lt;code&gt;LINAGE&lt;/code&gt;clause define the layout of printed pages as follows:</source>
          <target state="translated">&lt;code&gt;LINAGE&lt;/code&gt; 절에만 지정할 수 있습니다 &lt;code&gt;FD&lt;/code&gt; 순차적 또는 라인 순차 파일의. 순차 파일과 함께 사용하면 해당 파일의 구성이 내재적으로 행 순차로 변경됩니다. &lt;code&gt;LINAGE&lt;/code&gt; 절의 다양한 구성 요소는 다음과 같이 인쇄 된 페이지의 레이아웃을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="91bdb763a8ebb6a9e2aa2470f0c1435446d7a60e" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;LINE ADVANCING&lt;/code&gt;device</source>
          <target state="translated">&lt;code&gt;LINE ADVANCING&lt;/code&gt; 장치</target>
        </trans-unit>
        <trans-unit id="90f4027716d5f9168ac8b5457a093122fd9838c5" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;LINE-COUNTER&lt;/code&gt;special register , which will contain the current line number on the current page.</source>
          <target state="translated">&lt;code&gt;LINE-COUNTER&lt;/code&gt; 현재 페이지의 현재 행 번호를 포함 특수 레지스터.</target>
        </trans-unit>
        <trans-unit id="2a5ca6b887cfa76d7109d61ab60b82742194d1eb" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;LINE&lt;/code&gt;and&lt;code&gt;COLUMN&lt;/code&gt;clauses provide one mechanism for specifying the line and column position to which the cursor will be positioned before allowing the user to enter data. In the absence of one or the other, a value of 1 will be assumed for the one that is missing. The author&amp;rsquo;s personal preference, however, is to explicitly code both.</source>
          <target state="translated">&lt;code&gt;LINE&lt;/code&gt; 및 &lt;code&gt;COLUMN&lt;/code&gt; 절 커서는 사용자가 데이터를 입력하도록 허용하기 전에 위치 될 행의 행 및 열 위치를 특정하기위한 하나의 메커니즘을 제공한다. 둘 중 하나가 없으면 누락 된 값에 대해 1의 값이 가정됩니다. 그러나 저자의 선호는 명시 적으로 두 가지를 모두 코딩하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3d1ef19f0c5ac5abc4888904986a5112c9affa90" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;LINES&lt;/code&gt;</source>
          <target state="translated">The&lt;code&gt;LINES&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d6540b56f45c83cfcc5c9d3cd91fd76d1290b0be" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;LOCALE&lt;/code&gt;</source>
          <target state="translated">The&lt;code&gt;LOCALE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab96edf1a9a3247d7a17aa761b8dd18e82d49728" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;LOCK&lt;/code&gt;</source>
          <target state="translated">The&lt;code&gt;LOCK&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f60d564116b9753de46911898446622a701bd209" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;LOWLIGHT&lt;/code&gt;clause controls the intensity of text &lt;code&gt;FOREGROUND-COLOR&lt;/code&gt; by setting that intensity to its lowest of three possible settings.</source>
          <target state="translated">&lt;code&gt;LOWLIGHT&lt;/code&gt; 의 절 컨트롤 텍스트의 강도 &lt;code&gt;FOREGROUND-COLOR&lt;/code&gt; 세 가지 설정의 가장 낮은에 그 강도를 설정하여.</target>
        </trans-unit>
        <trans-unit id="787765c1548ddc3c40d046025213efcb589e90ae" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;MEMORY SIZE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;MEMORY SIZE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab81899ed3de82c6ee00eead9ea5e4e56caddf3f" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;MOVE&lt;/code&gt;statement will replace the contents of one or more receiving data items (&amp;lt;</source>
          <target state="translated">&lt;code&gt;MOVE&lt;/code&gt; 문 (하나 개 이상의 수신 데이터 항목의 내용을 대체합니다 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="f882c2fe36226bfcda7192c311fa4da3d4abd51f" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;MULTIPLE FILE TAPE&lt;/code&gt;clause is obsolete and is therefore recognized but not functional.</source>
          <target state="translated">&lt;code&gt;MULTIPLE FILE TAPE&lt;/code&gt; 조항은 무효이며, 따라서 인식하지만 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="32ac32fd9aeb395056b18e53d2d6d4bdfad7cc04" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;NEXT GROUP&lt;/code&gt;option cannot be specified in either a&lt;code&gt;REPORT HEADING&lt;/code&gt;or a&lt;code&gt;PAGE HEADING&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;NEXT GROUP&lt;/code&gt; 의 옵션은 하나로 지정 될 수 없습니다 &lt;code&gt;REPORT HEADING&lt;/code&gt; 또는 &lt;code&gt;PAGE HEADING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f8183cafb93bb749edfb23e991a0aea1752a192" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;NEXT PAGE&lt;/code&gt;option cannot be used in a&lt;code&gt;PAGE FOOTING&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;NEXT PAGE&lt;/code&gt; 옵션은 사용할 수 없습니다 &lt;code&gt;PAGE FOOTING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b3f0f1977efddbd87bcf38a9b16d64fe9fb9ed07" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;NEXT SENTENCE&lt;/code&gt;clause informs the compiler that if the&lt;code&gt;B = 1&lt;/code&gt;condition is false, control should fall into the first statement that follows the next period.</source>
          <target state="translated">&lt;code&gt;NEXT SENTENCE&lt;/code&gt; 절 알리는 경우 그 컴파일러 &lt;code&gt;B = 1&lt;/code&gt; 조건이 거짓, 컨트롤이 다음 기간을 다음 첫 번째 문에 해당한다.</target>
        </trans-unit>
        <trans-unit id="aebdeea070033adbcddb290c8522d3e06283842a" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;NO ADVANCING&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;NO ADVANCING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d2e059ca417360f623c02bd2c487a510c3fdcdc7" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;NO REWIND&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;NO REWIND&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="27b5355fe6261328ab3f9c6b4ea4d3c03adbfe9a" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;NO-ECHO&lt;/code&gt;(see &lt;a href=&quot;#NO_002dECHO&quot;&gt;NO-ECHO&lt;/a&gt;) and&lt;code&gt;SECURE&lt;/code&gt;clauses are interchangeable, and may not be used together in the same data item description.</source>
          <target state="translated">&lt;code&gt;NO-ECHO&lt;/code&gt; (보지 &lt;a href=&quot;#NO_002dECHO&quot;&gt;NO-에코&lt;/a&gt; )와 &lt;code&gt;SECURE&lt;/code&gt; 절은 상호 교환과 같은 데이터 항목 설명에서 함께 사용할 수 없다.</target>
        </trans-unit>
        <trans-unit id="b731291895b1c8ea3952ce233bc613ec22aeef4b" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;NO-ECHO&lt;/code&gt;and&lt;code&gt;SECURE&lt;/code&gt;(see &lt;a href=&quot;#SECURE&quot;&gt;SECURE&lt;/a&gt;) clauses are interchangeable, and may not be used together in the same data item description.</source>
          <target state="translated">&lt;code&gt;NO-ECHO&lt;/code&gt; 및 &lt;code&gt;SECURE&lt;/code&gt; (참조 &lt;a href=&quot;#SECURE&quot;&gt;SECURE&lt;/a&gt; ) 조항은 상호 교환과 같은 데이터 항목 설명에서 함께 사용할 수 없다.</target>
        </trans-unit>
        <trans-unit id="ffec813d041cebd80e7a061ec732fbafea42e8c0" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;NO-ECHO&lt;/code&gt;clause will cause all data entered into the field to appear on the screen as asterisks.</source>
          <target state="translated">&lt;code&gt;NO-ECHO&lt;/code&gt; 의 절은 필드에 입력 한 모든 데이터가 별표로 화면에 표시하게됩니다.</target>
        </trans-unit>
        <trans-unit id="684f1aa63a7a1d9199e9e8ccf0ef8577eef29592" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;NOFOLDCOPYNAME&lt;/code&gt;</source>
          <target state="translated">The&lt;code&gt;NOFOLDCOPYNAME&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="caca53f9e0c21c2332f2c06aa0d999bf97083e85" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;NOT AT END&lt;/code&gt;clause is not allowed on either form of table search.</source>
          <target state="translated">&lt;code&gt;NOT AT END&lt;/code&gt; 절은 테이블 검색 중 하나를 양식에 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7444e63d315af0f591ee565ee11508d6c9aa2e16" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;NOT&lt;/code&gt;operator has the highest precedence of all logical operators, just as a unary minus sign (which &quot;negates&quot; a numeric value) is the highest precedence arithmetic operator.</source>
          <target state="translated">&lt;code&gt;NOT&lt;/code&gt; 연산자는 ( &quot;을 Negate&quot;숫자 값)이 가장 높은 우선 순위 산술 연산자 단항 마이너스 기호로, 모든 논리 연산자의 우선 순위가 가장 높습니다.</target>
        </trans-unit>
        <trans-unit id="1b79accd181bac56da6d51e2b1d271ceccd3ae3e" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;NOT&lt;/code&gt;option reverses the TRUE/FALSE value of the condition.</source>
          <target state="translated">&lt;code&gt;NOT&lt;/code&gt; 옵션은 조건의 TRUE / FALSE 값을 반전시킵니다.</target>
        </trans-unit>
        <trans-unit id="0199ae90ca000fc87e20302627dbd3ef3a2c4ad2" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;NUMERIC SIGN TRAILING SEPARATE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;NUMERIC SIGN TRAILING SEPARATE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f0a28990ba560c2aa2a876f8c35342b9613008aa" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;NUMERIC&lt;/code&gt;</source>
          <target state="translated">The&lt;code&gt;NUMERIC&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="518a4f1b30d0446e84b009cab2b2767f9590dd78" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;OBJECT-COMPUTER&lt;/code&gt;paragraph is not allowed in a nested subprogram &amp;mdash; nested programs will inherit the&lt;code&gt;OBJECT-COMPUTER&lt;/code&gt;settings of their parent program.</source>
          <target state="translated">&lt;code&gt;OBJECT-COMPUTER&lt;/code&gt; 단락은 중첩 된 서브 프로그램에서 사용할 수 없습니다 - 중첩 된 프로그램은 상속 &lt;code&gt;OBJECT-COMPUTER&lt;/code&gt; 상위 프로그램의 설정을.</target>
        </trans-unit>
        <trans-unit id="c3f471822de68df6fe523d3f35e7a4795a357491" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;OCCURS&lt;/code&gt;clause cannot be specified in a data description entry that has a level number of 01, 66, 77, or 88, although it is valid in data items described</source>
          <target state="translated">는 &lt;code&gt;OCCURS&lt;/code&gt; 가 기재된 데이터 항목에 유효하지만, 절 레벨 번호 01, 66, 77 또는 88을 갖는 데이터 정보 항목에 지정 될 수 없다</target>
        </trans-unit>
        <trans-unit id="4808ea06ca6eaab6759f2ff5d69da222e50227c0" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;OCCURS&lt;/code&gt;clause is used to create a data structure called a table, where entries in that structure repeat multiple times.</source>
          <target state="translated">은 &lt;code&gt;OCCURS&lt;/code&gt; 절은 테이블라는 데이터 구조, 그 구조를 반복 항목을 여러 번 작성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="205e171115b8bf55b1b08ff02e6724bfac647821" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;OCCURS&lt;/code&gt;clause may be used at the group level too, in which case the entire group structure repeats, as follows:</source>
          <target state="translated">는 &lt;code&gt;OCCURS&lt;/code&gt; 절이도 그룹 레벨에서 사용되는 경우, 전체 그룹 구조의 반복에서, 다음과 같은 수있다 :</target>
        </trans-unit>
        <trans-unit id="652e2f932d6866b1020ec1ea7eee21d6e399bf8b" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;OCCURS&lt;/code&gt;clause of &amp;lt;</source>
          <target state="translated">&amp;lt; 의 &lt;code&gt;OCCURS&lt;/code&gt; 절</target>
        </trans-unit>
        <trans-unit id="eb92b72bc191ca96735cd244c86a1f00576681b8" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;OMITTED&lt;/code&gt;</source>
          <target state="translated">The&lt;code&gt;OMITTED&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f97838374b3bcafe4490af925db286f0fc880fcd" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;ON STATUS&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ON STATUS&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5533e622a92563f592ab39701247867de81fdb4b" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;OPTIONAL&lt;/code&gt;</source>
          <target state="translated">The&lt;code&gt;OPTIONAL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6691656bfa44b4ff3fe9ff5470faa21d5d3c53a6" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;ORGANIZATION&lt;/code&gt;of &amp;lt;</source>
          <target state="translated">&amp;lt; 의 &lt;code&gt;ORGANIZATION&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="87f565e7aac407e97f08035eed73e5c5b2a099c6" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;OVERLINE&lt;/code&gt;clause will introduce a horizontal line at the top edge of a screen field.</source>
          <target state="translated">&lt;code&gt;OVERLINE&lt;/code&gt; 절은 화면 필드의 상단 가장자리에 수평 라인을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="f8cd8f1cca83ca45e14be2b0649e5ec37ff0e378" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;P&lt;/code&gt;symbol is not allowed in conjunction with&lt;code&gt;N&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;P&lt;/code&gt; 의 심볼과 관련하여 허용되지 &lt;code&gt;N&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="98622ca9850be6412fa60f219bfe8da59e2fee63" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;P&lt;/code&gt;symbol may only be used at the beginning or end of a picture clause.</source>
          <target state="translated">&lt;code&gt;P&lt;/code&gt; 의 심볼은 화상 절의 시작 또는 끝 부분에 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="42429e3c10c7694c51e8679b7f8a8e7f9146b5ea" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;PADDING CHARACTER&lt;/code&gt;clause is syntactically recognized but is otherwise non-functional.</source>
          <target state="translated">&lt;code&gt;PADDING CHARACTER&lt;/code&gt; 절은 구문 적으로 인식하지만, 그렇지 않은 비 기능입니다.</target>
        </trans-unit>
        <trans-unit id="a04f48bd190d4d08a5d1a4e6756760140be9b397" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;PAGE-COUNTER&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;), which will contain the current report page number.</source>
          <target state="translated">&lt;code&gt;PAGE-COUNTER&lt;/code&gt; 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터를&lt;/a&gt; 현재 보고서의 페이지 번호를 포함하는).</target>
        </trans-unit>
        <trans-unit id="46bf1615a2373b15c609270bc57bab762aaaa13c" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;PARAMETER&lt;/code&gt;</source>
          <target state="translated">The&lt;code&gt;PARAMETER&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="688682d4cd4d8c85564267f07be399fe4dc2dc46" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;PICTURE&lt;/code&gt;(see &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt;) and/or&lt;code&gt;USAGE&lt;/code&gt;(see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) of the specified &amp;lt;</source>
          <target state="translated">&lt;code&gt;PICTURE&lt;/code&gt; (참고 &lt;a href=&quot;#PICTURE&quot;&gt;사진&lt;/a&gt; ) 및 / 또는 &lt;code&gt;USAGE&lt;/code&gt; (참조 &lt;a href=&quot;#USAGE&quot;&gt;USAGE를&lt;/a&gt; 특정의) &amp;lt;</target>
        </trans-unit>
        <trans-unit id="3176fa4f867ee9425588f7d621965a439a15cbca" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;PICTURE&lt;/code&gt;(see &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt;) of the data item only contains&lt;code&gt;A&lt;/code&gt;symbols.</source>
          <target state="translated">&lt;code&gt;PICTURE&lt;/code&gt; (참조 &lt;a href=&quot;#PICTURE&quot;&gt;영상을&lt;/a&gt; 데이터 항목의는)만을 포함 &lt;code&gt;A&lt;/code&gt; 문자.</target>
        </trans-unit>
        <trans-unit id="df7acbf428256ea730526ef32176f728b5817ed8" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;PICTURE&lt;/code&gt;(see &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt;) of the report data item must be such that it would be legal to&lt;code&gt;MOVE&lt;/code&gt;(see &lt;a href=&quot;#MOVE&quot;&gt;MOVE&lt;/a&gt;) the specified literal or identifier to a data item with that&lt;code&gt;PICTURE&lt;/code&gt;</source>
          <target state="translated">보고서 데이터 항목 의 &lt;code&gt;PICTURE&lt;/code&gt; ( &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt; 참조 )는 지정된 리터럴 또는 식별자를 해당 &lt;code&gt;PICTURE&lt;/code&gt; 가있는 데이터 항목으로 &lt;code&gt;MOVE&lt;/code&gt; ( &lt;a href=&quot;#MOVE&quot;&gt;MOVE&lt;/a&gt; 참조 )하는 것이 합법적이어야합니다.</target>
        </trans-unit>
        <trans-unit id="fb21d61ce2df3af488fb7375aa39dde73430c3bb" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;PICTURE&lt;/code&gt;of the data item contains nothing but the symbol&lt;code&gt;9&lt;/code&gt;and at least one of the editing symbols&lt;code&gt;$&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;CR&lt;/code&gt;&lt;code&gt;DB&lt;/code&gt;&lt;code&gt;.&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;&lt;code&gt;*&lt;/code&gt;or&lt;code&gt;Z&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;PICTURE&lt;/code&gt; 데이터 항목의 아무것도하지만, 기호가없는 &lt;code&gt;9&lt;/code&gt; 과 편집 기호 중 적어도 하나의 &lt;code&gt;$&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;CR&lt;/code&gt; &lt;code&gt;DB&lt;/code&gt; 를 &lt;code&gt;.&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;Z&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4e1ccbbf8e23461192e1f1608748b1984c37e610" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;PICTURE&lt;/code&gt;of the data item contains only&lt;code&gt;X&lt;/code&gt;or a combination of&lt;code&gt;A&lt;/code&gt;and&lt;code&gt;9&lt;/code&gt;symbols plus at least one&lt;code&gt;B&lt;/code&gt;&lt;code&gt;0&lt;/code&gt;(zero) or&lt;code&gt;/&lt;/code&gt;symbol.</source>
          <target state="translated">&lt;code&gt;PICTURE&lt;/code&gt; 데이터 항목은 포함 &lt;code&gt;X&lt;/code&gt; 또는 조합 및 &lt;code&gt;9&lt;/code&gt; 심볼 플러스 적어도 하나 &lt;code&gt;B&lt;/code&gt; &lt;code&gt;0&lt;/code&gt; (제로) 또는 &lt;code&gt;/&lt;/code&gt; 기호. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e64cf330170ded445b7995b1c3a1c8c7b030463" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;PICTURE&lt;/code&gt;of the data item contains only&lt;code&gt;X&lt;/code&gt;or a combination of&lt;code&gt;A&lt;/code&gt;and&lt;code&gt;9&lt;/code&gt;symbols.</source>
          <target state="translated">데이터 항목 의 &lt;code&gt;PICTURE&lt;/code&gt; 에는 &lt;code&gt;X&lt;/code&gt; 또는 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;9&lt;/code&gt; 기호 의 조합 만 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="3ddc24a81af87bfcabe827bd62d671fcc05435eb" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;PICTURE&lt;/code&gt;of the report data item in who&amp;rsquo;s description this&lt;code&gt;SUM&lt;/code&gt;clause appears in must be such that it would be legal to&lt;code&gt;MOVE&lt;/code&gt;(see &lt;a href=&quot;#MOVE&quot;&gt;MOVE&lt;/a&gt;) the specified &amp;lt;</source>
          <target state="translated">이 &lt;code&gt;SUM&lt;/code&gt; 절을 설명하는 사람의 보고서 데이터 항목 의 &lt;code&gt;PICTURE&lt;/code&gt; 은 지정된 &amp;lt; 을 &lt;code&gt;MOVE&lt;/code&gt; ( &lt;a href=&quot;#MOVE&quot;&gt;이동&lt;/a&gt; 참조 )하는 것이 합법적이어야합니다.</target>
        </trans-unit>
        <trans-unit id="cd5b56df7d5643e8e6c1d13d5eef6467a44663b7" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;POINTER&lt;/code&gt;</source>
          <target state="translated">The&lt;code&gt;POINTER&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="55cf82c42e5dffa3009d2028f7d77cf81b5969f6" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;PREVIOUS&lt;/code&gt;option is available only for&lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt;files.</source>
          <target state="translated">&lt;code&gt;PREVIOUS&lt;/code&gt; 옵션은 사용할 &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; 파일입니다.</target>
        </trans-unit>
        <trans-unit id="52edba794107fc7f5d72b661a8915f0ccc5c017c" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;PRIMARY KEY&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;PRIMARY KEY&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5912f9eed8762ec69777411a942d8cfcdffb86d1" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;PROGRAM-ID&lt;/code&gt;and&lt;code&gt;FUNCTION-ID&lt;/code&gt;paragraphs serve to identify the program to the external (i.e. operating system) environment. If there is no&lt;code&gt;AS&lt;/code&gt;clause present, the &amp;lt;</source>
          <target state="translated">&lt;code&gt;PROGRAM-ID&lt;/code&gt; 및 &lt;code&gt;FUNCTION-ID&lt;/code&gt; 단락은 외부 (예 : 운영 체제) 환경에 프로그램을 식별하는 역할을한다. &lt;code&gt;AS&lt;/code&gt; 절이 없으면 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="c1c454f05e4f28350a2e6913fedd1c1e562398e3" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;PROTECTED&lt;/code&gt;extended clause will effect the specified field to be limited in size, regardless of the picture size. OR DOES IT?</source>
          <target state="translated">&lt;code&gt;PROTECTED&lt;/code&gt; 특정 필드에 영향을 연장한다 절에 관계없이 화상의 크기, 크기가 제한된다. 아니면 그것을합니까?</target>
        </trans-unit>
        <trans-unit id="5aab88c37cbc8acfdac038cd438491ef58729107" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;RD&lt;/code&gt;must be followed by at least one 01-level report group definition.</source>
          <target state="translated">&lt;code&gt;RD&lt;/code&gt; 는 적어도 하나의 01 레벨 보고서 그룹 정의가 와야합니다.</target>
        </trans-unit>
        <trans-unit id="f0ce41e4fa3da1be73c6c6fc27c3c50ddbd8f8a3" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;RECORD CONTAINS&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;RECORD CONTAINS&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="555235a703b5221e417e305b6134c05fe5ceabb6" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;RECURSIVE&lt;/code&gt;</source>
          <target state="translated">The&lt;code&gt;RECURSIVE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8909def6b2ca86d072725f9f6b1f91617e14d51e" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;REDEFINES&lt;/code&gt;clause causes the data item in who&amp;rsquo;s definition the&lt;code&gt;REDEFINES&lt;/code&gt;clause is specified (hereafter referred to as the redefines object) to occupy the same physical storage space as &amp;lt;</source>
          <target state="translated">&lt;code&gt;REDEFINES&lt;/code&gt; 의 절 정의 누구의 데이터 항목 발생 &lt;code&gt;REDEFINES&lt;/code&gt; 의 같은 물리적 저장 공간을 점유하는 (이하, 재정의 객체 라 함) 절을 지정 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="9f9d65569ecacba017a75460dcc62e3904bb8c3e" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;REEL&lt;/code&gt;</source>
          <target state="translated">The&lt;code&gt;REEL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f0984cdb83bf116f902a3baa1ae6bb201fe30075" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;RELATIVE KEY&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;RELATIVE KEY&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a035071e9b4ae569b67fc517bbe985407c64f571" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;RENAMES&lt;/code&gt;clause regroups previously defined items by specifying alternative, possibly overlapping, groupings of elementary data items.</source>
          <target state="translated">은 &lt;code&gt;RENAMES&lt;/code&gt; 절 재 그룹화 이전 가능성, 대안을 지정, 기본 데이터 항목의 그룹을 중복하여 항목을 정의했다.</target>
        </trans-unit>
        <trans-unit id="972ed51222c85ed80d8cb41bfc9fa2d0c38ae3ea" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;REPLACE&lt;/code&gt;statement provides a mechanism for changing all or part of one or more GnuCOBOL statements.</source>
          <target state="translated">는 &lt;code&gt;REPLACE&lt;/code&gt; 문은 하나 이상의 GnuCOBOL 문의 전부 또는 일부를 변경하는 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3bc9b6947b8a61989808bb5fc7c6aa5a6041371b" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;REPLACING&lt;/code&gt;clause replaces one or more sub strings located in the inspect subject with a different, but equally-sized replacement sub string. If you need to replace a sub string with another of a</source>
          <target state="translated">&lt;code&gt;REPLACING&lt;/code&gt; 절은 하나 이상의 서브에있는 문자열을 다른, 그러나 동등 크기의 대체 하위 문자열로 대상을 검사를 대체합니다. 하위 문자열을 다른 문자열로 교체해야하는 경우</target>
        </trans-unit>
        <trans-unit id="75a6ef57f5eee8d4c4915237206af1fee54fdcc5" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;REPORT IS&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;REPORT IS&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0b1cbc1c7566a852950494f2ee2c5c4659e5d1e6" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;REPORT SECTION&lt;/code&gt;(see &lt;a href=&quot;#REPORT-SECTION&quot;&gt;REPORT SECTION&lt;/a&gt;) documentation explores the description of reports and the&lt;code&gt;PROCEDURE DIVISION&lt;/code&gt;(see &lt;a href=&quot;#PROCEDURE-DIVISION&quot;&gt;PROCEDURE DIVISION&lt;/a&gt;) chapter documents the various language statements that actually produce reports. Before reading these, you might find it helpful to read &lt;a href=&quot;#Report-Writer-Usage-Notes&quot;&gt;Report Writer Usage Notes&lt;/a&gt;, which is dedicated to putting the pieces together for you.</source>
          <target state="translated">&lt;code&gt;REPORT SECTION&lt;/code&gt; (참조 &lt;a href=&quot;#REPORT-SECTION&quot;&gt;보고서 섹션을&lt;/a&gt; ) 문서는 보고서의 설명 탐구 &lt;code&gt;PROCEDURE DIVISION&lt;/code&gt; (참조 &lt;a href=&quot;#PROCEDURE-DIVISION&quot;&gt;절차 부문&lt;/a&gt; ) 장 문서 실제로 보고서를 다양한 언어 문을. 이것들을 읽기 전에, 당신 을 위해 조각을 모으는 데 전념하는 &lt;a href=&quot;#Report-Writer-Usage-Notes&quot;&gt;Report Writer Usage Notes&lt;/a&gt; 를 읽는 것이 도움이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="5ffa691b86c54921913161c07ed4c0fdae77b97f" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;REPOSITORY&lt;/code&gt;paragraph is not allowed in a nested subprogram &amp;mdash; nested programs will inherit the&lt;code&gt;REPOSITORY&lt;/code&gt;settings of their parent program.</source>
          <target state="translated">&lt;code&gt;REPOSITORY&lt;/code&gt; 단락은 중첩 된 서브 프로그램에서 사용할 수 없습니다 - 중첩 된 프로그램은 상속 &lt;code&gt;REPOSITORY&lt;/code&gt; 부모 프로그램의 설정을.</target>
        </trans-unit>
        <trans-unit id="db53820f9bbd6839a6330ed033f1270f9053aae4" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) will be set to one of the following values:</source>
          <target state="translated">&lt;code&gt;RETURN-CODE&lt;/code&gt; 의 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터를&lt;/a&gt; 다음 값 중 하나로 설정됩니다)</target>
        </trans-unit>
        <trans-unit id="a2ece1b3043a5af4e62f72479af7c1f0fe2a497c" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) will be set to the return code of the operation; the value will be either 0=Success or 128=failure.</source>
          <target state="translated">&lt;code&gt;RETURN-CODE&lt;/code&gt; 의 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터를&lt;/a&gt; 작업의 반환 코드로 설정됩니다) 값은 0 = 성공 또는 128 = 실패입니다.</target>
        </trans-unit>
        <trans-unit id="29cfe2b8be25dbea67a0f3dfbc964e61d2a52467" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) will be updated in addition to any&lt;code&gt;RETURNING&lt;/code&gt;or&lt;code&gt;GIVING&lt;/code&gt;data item.</source>
          <target state="translated">&lt;code&gt;RETURN-CODE&lt;/code&gt; 의 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터&lt;/a&gt; ) 어떤 외에도 업데이트됩니다 &lt;code&gt;RETURNING&lt;/code&gt; 또는 &lt;code&gt;GIVING&lt;/code&gt; 데이터 항목.</target>
        </trans-unit>
        <trans-unit id="c5a656f40c4e9113b8d59d560265cff574ef083e" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;RETURN-CODE&lt;/code&gt;special register will not be updated (but any&lt;code&gt;RETURNING&lt;/code&gt;or&lt;code&gt;GIVING&lt;/code&gt;data item still will).</source>
          <target state="translated">&lt;code&gt;RETURN-CODE&lt;/code&gt; 의 특수 레지스터는 업데이트되지 않습니다 (그러나 어떤 &lt;code&gt;RETURNING&lt;/code&gt; 또는 &lt;code&gt;GIVING&lt;/code&gt; 데이터 항목은 여전히 것이다).</target>
        </trans-unit>
        <trans-unit id="cb6d8ac532f0a56c64b059e77da7c87fe364e9b8" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;RETURN&lt;/code&gt;statement is valid only within the&lt;code&gt;OUTPUT PROCEDURE&lt;/code&gt;of a file-based&lt;code&gt;SORT&lt;/code&gt;(see &lt;a href=&quot;#File_002dBased-SORT&quot;&gt;File-Based SORT&lt;/a&gt;) or a&lt;code&gt;MERGE&lt;/code&gt;statement (see &lt;a href=&quot;#MERGE&quot;&gt;MERGE&lt;/a&gt;) statement.</source>
          <target state="translated">&lt;code&gt;RETURN&lt;/code&gt; 문은 단지 내에서 유효 &lt;code&gt;OUTPUT PROCEDURE&lt;/code&gt; 파일 기반의 &lt;code&gt;SORT&lt;/code&gt; (참조 &lt;a href=&quot;#File_002dBased-SORT&quot;&gt;파일 기반 SORT를&lt;/a&gt; ) 또는 &lt;code&gt;MERGE&lt;/code&gt; 의 문 (참조 &lt;a href=&quot;#MERGE&quot;&gt;MERGE&lt;/a&gt; 문을).</target>
        </trans-unit>
        <trans-unit id="28fa8d7005c4ec07beca189cbb92cfd936a91503" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;RETURNING&lt;/code&gt;</source>
          <target state="translated">The&lt;code&gt;RETURNING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a63d9874318a78f4cc65d5829ddf504e3a4dbfa8" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;RETURNING&lt;/code&gt;clause is mandatory within a user-defined function, as all such must return a numeric result.</source>
          <target state="translated">&lt;code&gt;RETURNING&lt;/code&gt; 절은 이러한 모든이 숫자 결과를 반환해야하기 때문에, 사용자 정의 함수 내에서 필수입니다.</target>
        </trans-unit>
        <trans-unit id="95445675f1cf56aed21a5add64d40c233347a543" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;RETURNING&lt;/code&gt;clause is optional within a subroutine, as not all subroutines return a value to their caller.</source>
          <target state="translated">&lt;code&gt;RETURNING&lt;/code&gt; 모든 서브 루틴은 자신의 호출자에게 값을 반환로 절은, 서브 루틴 내에서 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="7e2a4ceb7992211d0bd86000e60608a622b22fc4" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;REVERSE-VIDEO&lt;/code&gt;attribute swaps the specified or implied&lt;code&gt;FOREGROUND-COLOR&lt;/code&gt;(see &lt;a href=&quot;#FOREGROUND_002dCOLOR&quot;&gt;FOREGROUND-COLOR&lt;/a&gt;) and&lt;code&gt;BACKGROUND-COLOR&lt;/code&gt;(see &lt;a href=&quot;#BACKGROUND_002dCOLOR&quot;&gt;BACKGROUND-COLOR&lt;/a&gt;) attributes for the field whose definition contains this clause (or all subordinate fields if used on a group item).</source>
          <target state="translated">&lt;code&gt;REVERSE-VIDEO&lt;/code&gt; 의 속성 스왑 지정된 또는 묵시적 &lt;code&gt;FOREGROUND-COLOR&lt;/code&gt; (참조 &lt;a href=&quot;#FOREGROUND_002dCOLOR&quot;&gt;포 그라운드-COLOR를&lt;/a&gt; ) 및 &lt;code&gt;BACKGROUND-COLOR&lt;/code&gt; (참조 &lt;a href=&quot;#BACKGROUND_002dCOLOR&quot;&gt;BACKGROUND-COLOR는&lt;/a&gt; ) 그 정의 (그룹 항목에 사용 된 경우 또는 모든 하위 필드)이 절을 포함하는 필드 속성 .</target>
        </trans-unit>
        <trans-unit id="5f720cac17ce569b524e66019c35b16223af7f54" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;RH&lt;/code&gt;and&lt;code&gt;REPORT HEADING&lt;/code&gt;terms are interchangeable, as are&lt;code&gt;PH&lt;/code&gt;and&lt;code&gt;PAGE HEADING&lt;/code&gt;&lt;code&gt;CH&lt;/code&gt;and&lt;code&gt;CONTROL HEADING&lt;/code&gt;&lt;code&gt;DE&lt;/code&gt;and&lt;code&gt;DETAIL&lt;/code&gt;&lt;code&gt;CF&lt;/code&gt;and&lt;code&gt;CONTROL FOOTING&lt;/code&gt;&lt;code&gt;PF&lt;/code&gt;and&lt;code&gt;PAGE FOOTING&lt;/code&gt;as well as&lt;code&gt;RF&lt;/code&gt;and&lt;code&gt;REPORT FOOTING&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;RH&lt;/code&gt; 및 &lt;code&gt;REPORT HEADING&lt;/code&gt; 의 조건은이며, 상호 교환 &lt;code&gt;PH&lt;/code&gt; 및 &lt;code&gt;PAGE HEADING&lt;/code&gt; &lt;code&gt;CH&lt;/code&gt; 및 &lt;code&gt;CONTROL HEADING&lt;/code&gt; &lt;code&gt;DE&lt;/code&gt; 및 &lt;code&gt;DETAIL&lt;/code&gt; &lt;code&gt;CF&lt;/code&gt; 및 &lt;code&gt;CONTROL FOOTING&lt;/code&gt; &lt;code&gt;PF&lt;/code&gt; 및 &lt;code&gt;PAGE FOOTING&lt;/code&gt; 뿐만 아니라 &lt;code&gt;RF&lt;/code&gt; 및 &lt;code&gt;REPORT FOOTING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6a36f3285cba4ad1d04a5a8e0172c3f3617fb600" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;ROUNDED&lt;/code&gt;option comes into play should the number of digits to the right of an actual or assumed decimal point be different between the specified literal or identifier value (the &quot;source value&quot;) and the&lt;code&gt;PICTURE&lt;/code&gt;specified for the field in whose definition the&lt;code&gt;SOURCE&lt;/code&gt;clause appears (the &quot;target field&quot;).</source>
          <target state="translated">&lt;code&gt;ROUNDED&lt;/code&gt; 옵션은 실제 또는 가정 된 소수점 이하의 자리수가 지정 문자 또는 식별자 값 ( &quot;소스 값&quot;) 및 사이 달라야 플레이하게된다 &lt;code&gt;PICTURE&lt;/code&gt; 그 정의의 필드에 지정된 &lt;code&gt;SOURCE&lt;/code&gt; 의 절 ( &quot;대상 필드&quot;)가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="e5b57af795e426620f1cff1f90a5b07fda649357" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;RUN&lt;/code&gt;</source>
          <target state="translated">The&lt;code&gt;RUN&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f2bc059532c4db7ea883cdf3418416f278e978d" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;S&lt;/code&gt;symbol is not allowed in conjunction with&lt;code&gt;N&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;S&lt;/code&gt; 의 심볼과 관련하여 허용되지 &lt;code&gt;N&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="07182c87a31d666cbbfecd4564cf71b810d7c9ce" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;S&lt;/code&gt;symbol may only occur once in a picture string. See &lt;a href=&quot;#SIGN-IS&quot;&gt;SIGN IS&lt;/a&gt;, for further discussion of how negative values may be stored in a numeric data item.</source>
          <target state="translated">&lt;code&gt;S&lt;/code&gt; 의 기호는 그림 문자열에 한 번 발생할 수 있습니다. 참조 &lt;a href=&quot;#SIGN-IS&quot;&gt;SIGN가&lt;/a&gt; 마이너스 값이 수치 데이터 항목에 저장 될 수있는 방법에 대한 자세한 설명.</target>
        </trans-unit>
        <trans-unit id="755a8ea68f853233b47153735e1913245b364020" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;SAME SORT-MERGE&lt;/code&gt;</source>
          <target state="translated">같은 &lt;code&gt;SAME SORT-MERGE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="551f033a903200cb8dbe12ed629ab537aea3540f" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;SCROLL&lt;/code&gt;</source>
          <target state="translated">The&lt;code&gt;SCROLL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a39faa5b0b53fa856827ad39e21dc23767d74e2a" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;SELECT&lt;/code&gt;statement creates a definition of a file and links that COBOL definition to the external operating system environment.</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 문은 파일의 정의와 링크를 작성하는 외부 운영 체제 환경에 COBOL 정의가.</target>
        </trans-unit>
        <trans-unit id="74285607be30e1995d79f2da282dadacab8c6a10" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;SET&lt;/code&gt;</source>
          <target state="translated">The&lt;code&gt;SET&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43d76d2175ce9a36c0236e940c42a9bb0e1260e9" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;SHARING&lt;/code&gt;</source>
          <target state="translated">The&lt;code&gt;SHARING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2cd4c8047468092ced70cb247ba9fda6c61a67a4" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;SHARING&lt;/code&gt;and&lt;code&gt;WITH LOCK&lt;/code&gt;clauses may not both be specified in the same&lt;code&gt;OPEN&lt;/code&gt;statement.</source>
          <target state="translated">&lt;code&gt;SHARING&lt;/code&gt; 와 &lt;code&gt;WITH LOCK&lt;/code&gt; 조항은 모두 동일한에 지정되지 않을 수도 있습니다 &lt;code&gt;OPEN&lt;/code&gt; 문.</target>
        </trans-unit>
        <trans-unit id="e03e6c4dc1104dd92ac95a4a629a90ee07b538b7" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;SOURCE&lt;/code&gt;(see &lt;a href=&quot;#SOURCE&quot;&gt;SOURCE&lt;/a&gt;),&lt;code&gt;SUM&lt;/code&gt;(see &lt;a href=&quot;#SUM&quot;&gt;SUM&lt;/a&gt;) and&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clauses, valid only on an elementary item, are mutually-exclusive of each other.</source>
          <target state="translated">&lt;code&gt;SOURCE&lt;/code&gt; 는 (참조 &lt;a href=&quot;#SOURCE&quot;&gt;SOURCE를&lt;/a&gt; ), &lt;code&gt;SUM&lt;/code&gt; (참조 &lt;a href=&quot;#SUM&quot;&gt;합&lt;/a&gt; )과 &lt;code&gt;VALUE&lt;/code&gt; (참조 &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt; 단지 기본 항목의 유효 조항), 서로 상호 배타적이다.</target>
        </trans-unit>
        <trans-unit id="a8b8b7cc793fdd76321ae9e12bd465f6f3f6d42c" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;SOURCE&lt;/code&gt;clause is syntactically recognized but is otherwise non-functional. It is supported to provide compatibility with COBOL source written for other COBOL implementations.</source>
          <target state="translated">&lt;code&gt;SOURCE&lt;/code&gt; 의 절은 구문 적으로 인식하지만, 그렇지 않은 비 기능입니다. 다른 COBOL 구현을 위해 작성된 COBOL 소스와의 호환성을 제공하도록 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="126b8554f7aa38280fe5b1ac3142bc7725dbf3c4" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;SPECIAL-NAMES&lt;/code&gt;paragraph is not allowed in a nested subprogram &amp;mdash; nested programs will inherit the&lt;code&gt;SPECIAL-NAMES&lt;/code&gt;settings of their parent program.</source>
          <target state="translated">&lt;code&gt;SPECIAL-NAMES&lt;/code&gt; 의 단락은 중첩 된 서브 프로그램에서 사용할 수 없습니다 - 중첩 된 프로그램은 상속 &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; 의 부모 프로그램의 설정을.</target>
        </trans-unit>
        <trans-unit id="e793b745385c02e516ce5b29f0e93b6f3882702a" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;SPECIAL-NAMES&lt;/code&gt;paragraph provides a means for specifying various program and operating environment configuration options.</source>
          <target state="translated">&lt;code&gt;SPECIAL-NAMES&lt;/code&gt; 단락 환경 설정 옵션을 다양한 프로그램을 지정하고 조작하기위한 수단을 제공한다.</target>
        </trans-unit>
        <trans-unit id="0d011b65b66e1e6e89e174048a01e683d43ac8ef" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;STATIC&lt;/code&gt;option will cause the linkage to the subroutine to be performed in such a way as to require the subroutine to be statically-linked with the calling program. Note that this enables static-linking to be used on a subroutine-by-subroutine selective basis.</source>
          <target state="translated">&lt;code&gt;STATIC&lt;/code&gt; 의 서브 루틴에 연결을하게됩니다 옵션은 호출 프로그램에 정적으로 링크로 서브 루틴을 요구하는 것과 같은 방식으로 수행한다. 이는 서브 루틴마다 선택적으로 정적 링크를 사용할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="ba090f77e311ccb3a708276448fc2a10479a8b7c" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;STATUS&lt;/code&gt;</source>
          <target state="translated">The&lt;code&gt;STATUS&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e74e5595db3929ff7f14df817b00f367555c9fdb" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;STDCALL&lt;/code&gt;option allows system-standard calling conventions (as opposed to GnuCOBOL calling conventions) to be used when calling a subroutine. The definition of what constitutes &quot;system standard&quot; may vary from operating system to operating system. Use of this requires special knowledge about the linkage requirements of subroutines you are intending to&lt;code&gt;CALL&lt;/code&gt; Subroutines written in GnuCOBOL do not need this option.</source>
          <target state="translated">&lt;code&gt;STDCALL&lt;/code&gt; 의 서브 루틴을 호출 할 때 사용되는 (GnuCOBOL가 호출 규칙을 반대) 옵션은 시스템 표준 호출 규칙을 할 수 있습니다. &quot;시스템 표준&quot;을 구성하는 요소에 대한 정의는 운영 체제마다 다를 수 있습니다. 이를 사용하려면 &lt;code&gt;CALL&lt;/code&gt; 하려는 서브 루틴의 링크 요구 사항에 대한 특별한 지식이 필요합니다 . GnuCOBOL로 작성된 서브 루틴에는이 옵션이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="53ebdd88168196c24db23a5b9e82ee7c85567ae7" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;STRING&lt;/code&gt;statement&amp;rsquo;s processing is based upon a &amp;rsquo;</source>
          <target state="translated">&lt;code&gt;STRING&lt;/code&gt; 의 문의 처리가 '를 기반으로</target>
        </trans-unit>
        <trans-unit id="ffba9342d27935e08ac4a7f3fa5d9d0987271f7c" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;SUM&lt;/code&gt;clause establishes a summation counter whose value will be arithmetically calculated whenever the field is presented.</source>
          <target state="translated">&lt;code&gt;SUM&lt;/code&gt; 절는 값 필드가 제시 될 때마다 산술적으로 계산하는 가산 계수기를 설정한다.</target>
        </trans-unit>
        <trans-unit id="6d6cbb467d33a4cd2308fc51e721e25d9c701e95" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;SUM&lt;/code&gt;clause may only appear in a&lt;code&gt;CONTROL FOOTING&lt;/code&gt;report group.</source>
          <target state="translated">&lt;code&gt;SUM&lt;/code&gt; 의 절에만 나타날 수 있습니다 &lt;code&gt;CONTROL FOOTING&lt;/code&gt; 보고서 그룹.</target>
        </trans-unit>
        <trans-unit id="26c6a8c6711137de3b4268bd4788efb29e8fe0fc" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;TALLYING&lt;/code&gt;clause counts the number of occurrences of one or more strings of characters in the inspect subject.</source>
          <target state="translated">&lt;code&gt;TALLYING&lt;/code&gt; 절 카운트는 문자 중 하나 이상의 문자열의 발생 수는 주제를 검사합니다.</target>
        </trans-unit>
        <trans-unit id="78eae2f080d85ab3f08088222be18f10973bf99d" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;TERMINATE&lt;/code&gt;statement will present each&lt;code&gt;CONTROL FOOTING&lt;/code&gt;(if any), in reverse sequence of the control hierarchy, starting with the most minor up to&lt;code&gt;FINAL&lt;/code&gt;(if any). During the presentation of these groups and the processing of any&lt;code&gt;USE BEFORE REPORTING&lt;/code&gt;procedures for those groups, the prior set of control data item values will be available, as though a control break had been detected at the most major control data name.</source>
          <target state="translated">&lt;code&gt;TERMINATE&lt;/code&gt; 문 각각 제시한다 &lt;code&gt;CONTROL FOOTING&lt;/code&gt; 에 가장 작은쪽으로부터, 상기 제어 계층의 역순으로, (만약 있다면) &lt;code&gt;FINAL&lt;/code&gt; (있는 경우). 이러한 그룹을 제시 하고 해당 그룹에 대한 &lt;code&gt;USE BEFORE REPORTING&lt;/code&gt; 절차를 처리하는 동안 가장 큰 제어 데이터 이름에서 제어 중단이 감지 된 것처럼 이전 제어 데이터 항목 값 세트를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99159d05cc901de677679740cac097ef045e644c" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;TIMEOUT&lt;/code&gt;</source>
          <target state="translated">The&lt;code&gt;TIMEOUT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="44cda50e3c27774f5b9859885b7209dc6ffc7cab" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;TIMES&lt;/code&gt;option will repeat the execution of the code within the perform scope a fixed number of times. When the&lt;code&gt;PERFORM&lt;/code&gt;statement begins execution, an internal repeat counter (not accessible to the programmer) will be set to the value of &amp;lt;</source>
          <target state="translated">&lt;code&gt;TIMES&lt;/code&gt; 의 (가) 범위를 시간의 고정을 수행 내 옵션은 코드의 실행을 반복합니다. (가) 때 &lt;code&gt;PERFORM&lt;/code&gt; 문이 실행 (프로그래머에 액세스 할 수 없습니다) 내부 반복 카운터를 시작의 값으로 설정됩니다 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="2fa80dd2b962d1386793c29ce7dc09f9cae7f15f" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;TO&lt;/code&gt;clause is used to define a data-entry field with no initial value; when a value is entered, it will be saved to the specified identifier.</source>
          <target state="translated">&lt;code&gt;TO&lt;/code&gt; 의 절은없고 초기 값으로 데이터 입력 필드를 정의하는 데 사용됩니다; 값을 입력하면 지정된 식별자에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="0159bff66a3fd25a850ce6b9e63156b7f1e529e5" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;TRANSFORM&lt;/code&gt;statement will replace characters within &amp;lt;</source>
          <target state="translated">&lt;code&gt;TRANSFORM&lt;/code&gt; 문 내에서 문자를 대체합니다 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="4797665934bcdd1fa5669e153c2f8ec73538bd74" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;TYPE&lt;/code&gt;(see &lt;a href=&quot;#TYPE&quot;&gt;TYPE&lt;/a&gt;) clause specifies the type of report group being defined.</source>
          <target state="translated">&lt;code&gt;TYPE&lt;/code&gt; 은 (참조 &lt;a href=&quot;#TYPE&quot;&gt;TYPE를&lt;/a&gt; ) 절은 보고서 그룹의 유형을 지정 정의된다.</target>
        </trans-unit>
        <trans-unit id="3b34ec864a7541e17b331925e47f82d8a62c5432" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;UNDERLINE&lt;/code&gt;clause will introduce a horizontal line at the bottom edge of a screen field.</source>
          <target state="translated">&lt;code&gt;UNDERLINE&lt;/code&gt; 절은 화면 필드의 아래쪽 가장자리에 수평 라인을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="48e0ddccedb7624a5967292ff34528c5fb3ef2f5" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;UNSTRING&lt;/code&gt;statement&amp;rsquo;s processing is based upon a &amp;rsquo;</source>
          <target state="translated">&lt;code&gt;UNSTRING&lt;/code&gt; 문의 처리가 '를 기반으로</target>
        </trans-unit>
        <trans-unit id="b191849cd6d04efbc0fc259b30172db78d8998d3" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;UNTIL &amp;lt;&lt;i&gt;conditional-expression-1&lt;/i&gt;&amp;gt;&lt;/code&gt;option will repeat the code within the perform scope until the specified conditional expression evaluates to a TRUE value.</source>
          <target state="translated">&lt;code&gt;UNTIL &amp;lt;&lt;i&gt;conditional-expression-1&lt;/i&gt;&amp;gt;&lt;/code&gt; (가) 참값에 조건식을 평가하여 지정 될 때까지이 범위 내에서 수행 옵션 코드를 반복 할 것이다.</target>
        </trans-unit>
        <trans-unit id="ed559a53f6dca89bbdc88634f28ab037e2679144" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;UPON CRT&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;UPON CRT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="25e5851d9ef5cbab92642156097f43be1e5840b4" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;USAGE&lt;/code&gt;(see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) of &amp;lt;</source>
          <target state="translated">&lt;code&gt;USAGE&lt;/code&gt; 는 (참조 &lt;a href=&quot;#USAGE&quot;&gt;사용&lt;/a&gt; 중) &amp;lt;</target>
        </trans-unit>
        <trans-unit id="96064edbf47d5172889ce7ea6c32eff63602aed6" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;USAGE&lt;/code&gt;clause defines the format that will be used to store the value of a data item.</source>
          <target state="translated">&lt;code&gt;USAGE&lt;/code&gt; 절은 데이터 항목의 값을 저장하는 데 사용되는 형식을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="1e54572372eefe8c8c071369f69f8bda09152498" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;USAGE&lt;/code&gt;specifications&lt;code&gt;FLOAT-DECIMAL-16&lt;/code&gt;and&lt;code&gt;FLOAT-DECIMAL-34&lt;/code&gt;will encode data using IEEE 754&lt;code&gt;Decimal64&lt;/code&gt;and&lt;code&gt;Decimal128&lt;/code&gt;format, respectively. The former allows for up to 16 digits of exact precision while the latter offers 34. The phrase &quot;exact precision&quot; is used because the traditional binary renderings of decimal real numbers in a floating-point format &lt;code&gt;FLOAT-LONG&lt;/code&gt;and&lt;code&gt;FLOAT-SHORT&lt;/code&gt; for example) only yield an approximation of the actual value because many decimal fractions cannot be precisely rendered in binary. The Decimal64 and Decimal128 renderings, however, render decimal real numbers in encoded decimal form in much the same way that&lt;code&gt;PACKED-DECIMAL&lt;/code&gt;renders a decimal integer in digit-by-digit decimal form. The exact manner in which this rendering is performed is complex (Wikipedia has an excellent article on the subject  just search for&lt;code&gt;Decimal64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;USAGE&lt;/code&gt; 의 사양 &lt;code&gt;FLOAT-DECIMAL-16&lt;/code&gt; 및 &lt;code&gt;FLOAT-DECIMAL-34&lt;/code&gt; IEEE 754하여 데이터를 인코딩한다 &lt;code&gt;Decimal64&lt;/code&gt; 및 &lt;code&gt;Decimal128&lt;/code&gt; 각각 형식. 후자의 이벤트 (34) 문구 &quot;정확한 정밀&quot;가 사용되는 반면 전자는 정확한 정밀도의 16 자리까지 가능하기 때문에 부동 소수점 형식으로 소수점 실수의 전통적인 바이너리 렌더링 &lt;code&gt;FLOAT-LONG&lt;/code&gt; 및 &lt;code&gt;FLOAT-SHORT&lt;/code&gt; 예를 들어) 많은 소수 부분을 이진수로 정확하게 렌더링 할 수 없기 때문에 실제 값의 근사값 만 산출합니다. 그러나 Decimal64 및 Decimal128 렌더링은 &lt;code&gt;PACKED-DECIMAL&lt;/code&gt; 과 거의 같은 방식으로 10 진수 실수를 인코딩 된 10 진수 형식으로 렌더링합니다.10 진수 정수를 자릿수 10 진수 형식으로 렌더링합니다. 이 렌더링이 수행되는 정확한 방법은 복잡합니다 (Wikipedia에는 ​​주제에 대한 훌륭한 기사가 있습니다. &lt;code&gt;Decimal64&lt;/code&gt; 만 검색하면 됩니다) .</target>
        </trans-unit>
        <trans-unit id="ff85164447b1725c365e1a77b634b135ebc49a2b" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;USAGE&lt;/code&gt;specifications&lt;code&gt;FLOAT-LONG&lt;/code&gt;and&lt;code&gt;FLOAT-SHORT&lt;/code&gt;use the IEEE 754&lt;code&gt;Binary64&lt;/code&gt;and&lt;code&gt;Binary32&lt;/code&gt;formats, respectively. These are binary encodings of real decimal numbers, and as such cannot represent every possible value between the minimum and maximum values in the range for those usages. Wikipedia has an excellent article on the Binary64 and Binary32 encoding schemes  just search on&lt;code&gt;Binary32&lt;/code&gt;or&lt;code&gt;Binary64&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;USAGE&lt;/code&gt; 사양 &lt;code&gt;FLOAT-LONG&lt;/code&gt; 및 &lt;code&gt;FLOAT-SHORT&lt;/code&gt; 이 는 IEEE 754 사용 &lt;code&gt;Binary64&lt;/code&gt; 및 &lt;code&gt;Binary32&lt;/code&gt; 각각 형식을. 이것은 실제 십진수의 이진 인코딩이므로 해당 사용 범위에서 최소값과 최대 값 사이의 모든 가능한 값을 나타낼 수는 없습니다. Wikipedia에는 ​​Binary64 및 Binary32 인코딩 체계에 대한 훌륭한 기사가 있습니다. &lt;code&gt;Binary32&lt;/code&gt; 또는 &lt;code&gt;Binary64&lt;/code&gt; 만 검색 하면됩니다.</target>
        </trans-unit>
        <trans-unit id="d32c59dc798bfa1e56d5946c082930e16cc3c034" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;USE AFTER STANDARD ERROR PROCEDURE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;USE AFTER STANDARD ERROR PROCEDURE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5fedd920ebcc5b40d0ef8570ea82835a72bbac1f" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;USING&lt;/code&gt;</source>
          <target state="translated">The&lt;code&gt;USING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d79559aace3582f3a12fc2828f7a09754a67e86d" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;V&lt;/code&gt;symbol is not allowed in conjunction with&lt;code&gt;N&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;V&lt;/code&gt; 의 심볼과 관련하여 허용되지 &lt;code&gt;N&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6dd187e1bed86a29f631b6e3e32e2954ccdfcdac" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;V&lt;/code&gt;symbol may only occur once in a picture string.</source>
          <target state="translated">&lt;code&gt;V&lt;/code&gt; 의 기호는 그림 문자열에 한 번 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="884b63a939a0d35e847a9f70d03f22aac161c982" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;VALUE&lt;/code&gt;clause is ignored on&lt;code&gt;EXTERNAL&lt;/code&gt;(see &lt;a href=&quot;#EXTERNAL&quot;&gt;EXTERNAL&lt;/a&gt;) data items or on any data items defines as subordinate to an&lt;code&gt;EXTERNAL&lt;/code&gt;data item.</source>
          <target state="translated">&lt;code&gt;VALUE&lt;/code&gt; 의 절은 무시됩니다 &lt;code&gt;EXTERNAL&lt;/code&gt; (참조 &lt;a href=&quot;#EXTERNAL&quot;&gt;외부를&lt;/a&gt; ) 데이터 항목 또는 종속 등의 데이터 항목을 정의에 &lt;code&gt;EXTERNAL&lt;/code&gt; 데이터 항목.</target>
        </trans-unit>
        <trans-unit id="4501a735b5b0743d9917cbf02a54169b24cd1d3a" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;VALUE&lt;/code&gt;clause is used to define condition names or to assign values (at compilation time) to data items.</source>
          <target state="translated">&lt;code&gt;VALUE&lt;/code&gt; 의 절은 조건 이름을 정의하거나 데이터 항목 (컴파일 시간) 값을 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ea0510abe58940faf7a2631109e1e219902cb11d" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;WHEN OTHER&lt;/code&gt;clause&amp;rsquo;s &amp;lt;</source>
          <target state="translated">&lt;code&gt;WHEN OTHER&lt;/code&gt; 조항의 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="40567bd129da73943595e75d8066457a86196e30" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;WITH FILLER&lt;/code&gt;&lt;code&gt;REPLACING&lt;/code&gt;and&lt;code&gt;DEFAULT&lt;/code&gt;clauses are meaningful only if &amp;lt;</source>
          <target state="translated">&lt;code&gt;WITH FILLER&lt;/code&gt; 는 &lt;code&gt;REPLACING&lt;/code&gt; 및 &lt;code&gt;DEFAULT&lt;/code&gt; 의 절은 경우에만 의미가있다 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="abffa90af71af4b07367d5ba037585ae1917d13e" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;WITH LOCK&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;WITH LOCK&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9aeb4d34b610a6acf77e84cf40889eab990f0808" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;WITH [ NO ] LOCK&lt;/code&gt;option is the only one available to&lt;code&gt;REWRITE&lt;/code&gt;or&lt;code&gt;WRITE&lt;/code&gt;statements.</source>
          <target state="translated">&lt;code&gt;WITH [ NO ] LOCK&lt;/code&gt; 옵션에 유일하게 볼 수 있습니다 &lt;code&gt;REWRITE&lt;/code&gt; 또는 &lt;code&gt;WRITE&lt;/code&gt; 문.</target>
        </trans-unit>
        <trans-unit id="5e30c581c08b91220c9d24868ced1cb99278e475" translate="yes" xml:space="preserve">
          <source>Then the&lt;code&gt;SORT&lt;/code&gt;statement to accomplish the desired sequencing would be:</source>
          <target state="translated">그런 다음 원하는 시퀀싱을 수행하기위한 &lt;code&gt;SORT&lt;/code&gt; 문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e38ab9160fec731a01f1367fbf83371dab74e317" translate="yes" xml:space="preserve">
          <source>Then&lt;code&gt;GRID-CHARACTER (2, 3)&lt;/code&gt;references the &quot;G&quot; and&lt;code&gt;GRID-CHARACTER (3, 2)&lt;/code&gt;references the &quot;J&quot;.</source>
          <target state="translated">그런 다음 &lt;code&gt;GRID-CHARACTER (2, 3)&lt;/code&gt; 는 &quot;G&quot;를 참조하고 &lt;code&gt;GRID-CHARACTER (3, 2)&lt;/code&gt; 는 &quot;J&quot;를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="9a101bf83fd195a893f710ebf566989f02a510e7" translate="yes" xml:space="preserve">
          <source>There are a number of built-in system subroutines included with GnuCOBOL.</source>
          <target state="translated">GnuCOBOL에는 여러 내장 시스템 서브 루틴이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0be6fbb0574525dce427b2303a85441d0df4ccbd" translate="yes" xml:space="preserve">
          <source>There are no arguments to this routine.</source>
          <target state="translated">이 루틴에 대한 주장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="fd5cb604bda8268d03a9c5cd32843c368eb88a76" translate="yes" xml:space="preserve">
          <source>There are one BILLION nanoseconds in a second, so if you wanted to put the program to sleep for 1/4 second you&amp;rsquo;d use a &amp;lt;</source>
          <target state="translated">1 초에 10 억 나노초가 있으므로 프로그램을 1/4 초 동안 잠자기 상태로하려면 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="020fa42993b6fc6ec0bc3949920b61e4bd932626" translate="yes" xml:space="preserve">
          <source>There are seven types of conditional expressions, as discussed in the following sections.</source>
          <target state="translated">다음 섹션에서 설명하는 것처럼 7 가지 유형의 조건식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="92f691d8ad6d639098ba87668a21a2213bd40974" translate="yes" xml:space="preserve">
          <source>There are several excellent commercially available COBOL implementations available for non-mainframe systems (Micro Focus COBOL, AccuCOBOL, NetCOBOL and Elastic COBOL, just to name a few), including Windows and UNIX/Linux systems. These aren&amp;rsquo;t cheap, however.</source>
          <target state="translated">Windows 및 UNIX / Linux 시스템을 포함하여 비 메인 프레임 시스템 (Micro Focus COBOL, AccuCOBOL, NetCOBOL 및 Elastic COBOL)에 사용할 수있는 뛰어난 상용 COBOL 구현이 몇 가지 있습니다. 그러나 이것들은 싸지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0dce23e05744c73fc816ba5c16c392a921bbc444" translate="yes" xml:space="preserve">
          <source>There are three circumstances under which the use of certain GnuCOBOL statements or options will require the specification of procedures. These situations are:</source>
          <target state="translated">특정 GnuCOBOL 문 또는 옵션을 사용하려면 절차 지정이 필요한 세 가지 환경이 있습니다. 이러한 상황은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="10ad1c511653b5d215a5277edbec699d40d5d3d3" translate="yes" xml:space="preserve">
          <source>There are three components to the&lt;code&gt;ASSIGN&lt;/code&gt;clause &amp;mdash; a &amp;lt;&amp;lt;</source>
          <target state="translated">&lt;code&gt;ASSIGN&lt;/code&gt; 절 에는 세 가지 구성 요소가 있습니다. a &amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="8d509d352bc24cdc74343dea231f54530dbcd1c6" translate="yes" xml:space="preserve">
          <source>There are three possible brightness levels supported for text &amp;mdash; lowlight (dim), normal and highlight (bright). Not all GnuCOBOL implementations will support all three (some treat lowlight the same as normal). The deciding factor as to whether two or three levels are supported lies with the version of the &quot;curses&quot; package that is being used. This is a utility screen-IO package that is included into the GnuCOBOL run-time library when the GnuCOBOL software is built.</source>
          <target state="translated">텍스트에 대해 지원되는 밝기 수준은 저 조명 (어둡게), 보통 및 밝게 (밝음)입니다. 모든 GnuCOBOL 구현이 세 가지를 모두 지원하지는 않습니다 (일부는 저조도를 평소와 동일하게 취급 함). 2 개 또는 3 개의 수준이 지원되는지 여부에 대한 결정 요인은 사용중인 &quot;저주&quot;패키지 버전에 있습니다. GnuCOBOL 소프트웨어가 빌드 될 때 GnuCOBOL 런타임 라이브러리에 포함 된 유틸리티 screen-IO 패키지입니다.</target>
        </trans-unit>
        <trans-unit id="e2cdd55f831b7e22c059f748c6225fddac6fa5bd" translate="yes" xml:space="preserve">
          <source>There are two basic ways in which this statement is used. The simplest is:</source>
          <target state="translated">이 진술이 사용되는 두 가지 기본 방법이 있습니다. 가장 간단한 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f2ae9bd4fcb7980cbd610e02ecf22ecc2edb13a4" translate="yes" xml:space="preserve">
          <source>There are two types of supported CDF statements in GnuCOBOL &amp;mdash; Text Manipulation Statements and Compiler Directives.</source>
          <target state="translated">GnuCOBOL에는 두 가지 유형의 지원되는 CDF 문인 텍스트 조작 명령문 및 컴파일러 지시문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3118c6d73925cdf45fafc8737c45e6b1b31dd73" translate="yes" xml:space="preserve">
          <source>There cannot be more than one&lt;code&gt;DETAIL&lt;/code&gt;group defined for &amp;lt;</source>
          <target state="translated">&amp;lt;에 대해 둘 이상의 &lt;code&gt;DETAIL&lt;/code&gt; 그룹을 정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9bebf23fd49611ef7dd93e1c67cb81decb6c95f0" translate="yes" xml:space="preserve">
          <source>There could be multiple counting instructions specified:</source>
          <target state="translated">여러 계산 명령이 지정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fbc0341c40fa77dd3e3d21ac3ee753ac9b28a06" translate="yes" xml:space="preserve">
          <source>There could be multiple replacement instructions:</source>
          <target state="translated">여러 가지 교체 지침이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="540ac53ab2fcd130aaa4aa63451df289da4558f8" translate="yes" xml:space="preserve">
          <source>There is never an issue of exactly what the length of a string contained in a&lt;code&gt;USAGE DISPLAY&lt;/code&gt;(see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) data item is &amp;mdash; there are always exactly how ever many characters as were allowed for by the&lt;code&gt;PICTURE&lt;/code&gt;clause. In the example above, &quot;LastName&quot; will always contain exactly fifteen characters; of course, there may be anywhere from 0 to 15 trailing SPACES as part of the current LastName value.</source>
          <target state="translated">&lt;code&gt;USAGE DISPLAY&lt;/code&gt; ( &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt; 참조 ) 데이터 항목에 포함 된 문자열의 길이가 정확히 어떤 문제도 없습니다 . &lt;code&gt;PICTURE&lt;/code&gt; 절에 허용 된 문자 수는 항상 정확히 있습니다. 위의 예에서 &quot;LastName&quot;은 항상 정확히 15 자입니다. 물론 현재 LastName 값의 일부로 후행 공백이 0에서 15 사이 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df1b00bfc7b7482cc2c58d4b4eadac54da6a80ee" translate="yes" xml:space="preserve">
          <source>There is no difference between the use of the word&lt;code&gt;IN&lt;/code&gt;and the word&lt;code&gt;OF&lt;/code&gt;&amp;mdash; use the one you prefer.</source>
          <target state="translated">&lt;code&gt;IN&lt;/code&gt; 단어 와 &lt;code&gt;OF&lt;/code&gt; 단어 의 사용에는 차이가 없습니다 . 원하는 단어를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2e69e27c74451e57828d9e78c8c01833eaf23a96" translate="yes" xml:space="preserve">
          <source>There is no functional difference between using the wordy version &lt;code&gt;IS EQUAL TO&lt;/code&gt;&lt;code&gt;IS LESS THAN&lt;/code&gt; &amp;hellip;) versus the symbolic version &lt;code&gt;=&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; &amp;hellip;) of the actual relation operators.</source>
          <target state="translated">말의 버전을 사용하는 사이의 기능적 차이는 없다 &lt;code&gt;IS EQUAL TO&lt;/code&gt; &lt;code&gt;IS LESS THAN&lt;/code&gt; 심볼 버전 대 ...) &lt;code&gt;=&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; 실제 관계 연산자는 ...).</target>
        </trans-unit>
        <trans-unit id="02fee693563302ccb3fcc2dd8ddd4d0cad379b2c" translate="yes" xml:space="preserve">
          <source>There may be a maximum of one (1) report group per&lt;code&gt;RD&lt;/code&gt;defined with a&lt;code&gt;TYPE&lt;/code&gt;of&lt;code&gt;REPORT HEADING&lt;/code&gt;&lt;code&gt;PAGE HEADING&lt;/code&gt;&lt;code&gt;PAGE FOOTING&lt;/code&gt;and&lt;code&gt;REPORT FOOTING&lt;/code&gt;</source>
          <target state="translated">당 일 (1)보고 그룹의 최대 수있을 &lt;code&gt;RD&lt;/code&gt; 정의 &lt;code&gt;TYPE&lt;/code&gt; 의 &lt;code&gt;REPORT HEADING&lt;/code&gt; &lt;code&gt;PAGE HEADING&lt;/code&gt; &lt;code&gt;PAGE FOOTING&lt;/code&gt; 와 &lt;code&gt;REPORT FOOTING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="601772c1e7516b0cc2fa774123597831d154d81b" translate="yes" xml:space="preserve">
          <source>There may be any number of alternate keys, but each key field comes with a disk space penalty as well as an execution time penalty. As the number of alternate key fields increases, it will take longer and longer to write and/or modify records in the file.</source>
          <target state="translated">대체 키는 여러 개있을 수 있지만 각 키 필드에는 디스크 공간 패널티와 실행 시간 패널티가 있습니다. 대체 키 필드의 수가 증가함에 따라 파일에서 레코드를 작성 및 / 또는 수정하는 데 시간이 오래 걸립니다.</target>
        </trans-unit>
        <trans-unit id="8de1a0170f33950bf833321d1bb264c327e73df6" translate="yes" xml:space="preserve">
          <source>There may be any number of&lt;code&gt;&amp;gt;&amp;gt;ELIF&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;gt;&amp;gt;ELIF&lt;/code&gt; 는 여러 개있을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="13543fcb8666b10f9ca386bfaa4946157edf3257" translate="yes" xml:space="preserve">
          <source>There may be multiple GnuCOBOL subprograms contained within a single dynamically-loadable library if the&lt;code&gt;-b&lt;/code&gt;switch is used in addition to&lt;code&gt;-m&lt;/code&gt; If not, each subprogram will be compiled to a separate dynamically-loadable library.</source>
          <target state="translated">&lt;code&gt;-m&lt;/code&gt; 스위치와 함께 &lt;code&gt;-b&lt;/code&gt; 스위치를 사용 하는 경우 단일 동적로드 가능 라이브러리에 여러 GnuCOBOL 서브 프로그램이 포함되어있을 수 있습니다. 그렇지 않은 경우 각 서브 프로그램은 별도의 동적로드 가능 라이브러리로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="84ed95516f1da9d25c273e4c45769f7abd24e687" translate="yes" xml:space="preserve">
          <source>There may be multiple level-66 data items that rename data items contained within the same 01-level record description.</source>
          <target state="translated">동일한 01 레벨 레코드 설명 내에 포함 된 데이터 항목의 이름을 바꾸는 여러 레벨 -66 데이터 항목이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="746557be4488b58d20e9ceb7df314d3df9962318" translate="yes" xml:space="preserve">
          <source>There may be multiple&lt;code&gt;ALTERNATE RECORD KEY&lt;/code&gt;clauses, each defining an additional alternate key for the file.</source>
          <target state="translated">파일에 대한 추가 대체 키를 각각 정의하는 여러 &lt;code&gt;ALTERNATE RECORD KEY&lt;/code&gt; 절이 있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="675261999d9154918069f28a8c6000b8d7ac4f5a" translate="yes" xml:space="preserve">
          <source>There may be times where this is exactly what you were looking for. More often than not, however, this is not desirable behaviour. Suggestion: use a copybook to describe the record layouts of any file; this guarantees that multiple programs accessing that file will &quot;see&quot; the same record sizes and layouts by coding a&lt;code&gt;COPY&lt;/code&gt;statement (see &lt;a href=&quot;#COPY&quot;&gt;COPY&lt;/a&gt;) to import the record layout(s) rather than hand-coding them.</source>
          <target state="translated">이것이 바로 당신이 찾고있는 시간 일 수 있습니다. 그러나 종종 이것은 바람직한 행동이 아닙니다. 제안 : 카피 북을 사용하여 파일의 레코드 레이아웃을 설명하십시오. 해당 파일을 액세스하는 여러 프로그램 &quot;페이지의&quot;코딩에 의해 같은 기록 크기와 레이아웃 것을이 보장 &lt;code&gt;COPY&lt;/code&gt; 문 (참조 &lt;a href=&quot;#COPY&quot;&gt;COPY를&lt;/a&gt; 기록 레이아웃 (들)보다는 가져올 수)을 손 코딩.</target>
        </trans-unit>
        <trans-unit id="661c423a3cc3d7452566ced142d4e45fb970c7fa" translate="yes" xml:space="preserve">
          <source>There may no more than one&lt;code&gt;&amp;gt;&amp;gt;ELSE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;gt;&amp;gt;ELSE&lt;/code&gt; 는 하나만있을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="4cd649e0acf88ff17d874a8e588314d1de3c8980" translate="yes" xml:space="preserve">
          <source>There may not even be a path &lt;code&gt;datafile.dat&lt;/code&gt;, in which case the file must be in the current directory.</source>
          <target state="translated">&lt;code&gt;datafile.dat&lt;/code&gt; 경로가 없을 수도 있습니다. 이 경우 파일은 현재 디렉토리에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="507c1e3e0dbd9ffe3e3f24c00fe8085425cb4faa" translate="yes" xml:space="preserve">
          <source>There may only be one report heading, report footing, final control heading, final control footing, page heading and page footing defined per report.</source>
          <target state="translated">보고서 당 정의 된 보고서 머리글, 보고서 바닥 글, 최종 제어 머리글, 최종 제어 바닥 글, 페이지 머리글 및 페이지 바닥 글은 하나만있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="518b810465e363566a4c7d3c539355da8bf7ebc3" translate="yes" xml:space="preserve">
          <source>There must be a&lt;code&gt;CONTROL HEADING&lt;/code&gt;and/or&lt;code&gt;CONTROL FOOTING&lt;/code&gt;report group defined in the report section for each &amp;lt;</source>
          <target state="translated">이 있어야 &lt;code&gt;CONTROL HEADING&lt;/code&gt; 및 / 또는 &lt;code&gt;CONTROL FOOTING&lt;/code&gt; 각 보고서 섹션에 정의 보고서 그룹 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="66239c10c0c842dbb093eeb9311e6d69d4f59b58" translate="yes" xml:space="preserve">
          <source>There must be at least one &amp;lt;</source>
          <target state="translated">&amp;lt;하나 이상이 있어야합니다 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="a2e36aa6bd9d108e8bf2235290363f9eb0d0094b" translate="yes" xml:space="preserve">
          <source>There must be at least one digit character both before and after the&lt;code&gt;E&lt;/code&gt;in the string.</source>
          <target state="translated">문자열 에서 &lt;code&gt;E&lt;/code&gt; 앞뒤에 적어도 하나의 숫자 문자가 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="14b006140589016cc5de1b8ad38be708e2b6794b" translate="yes" xml:space="preserve">
          <source>There must be at least one digit character in the string.</source>
          <target state="translated">문자열에 하나 이상의 숫자 문자가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="795b44a226ec3d42da80c4a65b2a6f3a2cb6daf9" translate="yes" xml:space="preserve">
          <source>There must be at least one&lt;code&gt;CONTROL&lt;/code&gt;(see &lt;a href=&quot;#RWCS-Lexicon&quot;&gt;RWCS Lexicon&lt;/a&gt;) group defined for &amp;lt;</source>
          <target state="translated">&amp;lt;에 대해 정의 된 하나 이상의 &lt;code&gt;CONTROL&lt;/code&gt; ( &lt;a href=&quot;#RWCS-Lexicon&quot;&gt;RWCS Lexicon&lt;/a&gt; 참조 ) 그룹 이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="dd22863c4f2ddad207059b4f1714bd509ab3b240" translate="yes" xml:space="preserve">
          <source>There must be at least one&lt;code&gt;WHEN&lt;/code&gt;</source>
          <target state="translated">이 있어야합니다 적어도 하나의 &lt;code&gt;WHEN&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3dffe960a3018466276a5e31c01a220090e4aaa5" translate="yes" xml:space="preserve">
          <source>There must be either a&lt;code&gt;CONTROL HEADING&lt;/code&gt;or a&lt;code&gt;CONTROL FOOTING&lt;/code&gt;or both specified for each entry specified on the&lt;code&gt;CONTROLS ARE&lt;/code&gt;clause of the&lt;code&gt;RD&lt;/code&gt;</source>
          <target state="translated">중 하나가 있어야 &lt;code&gt;CONTROL HEADING&lt;/code&gt; 또는 &lt;code&gt;CONTROL FOOTING&lt;/code&gt; 나에 지정된 각 항목에 대해 지정된 모두 &lt;code&gt;CONTROLS ARE&lt;/code&gt; 의 절 &lt;code&gt;RD&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7e2249a4e9b8a0f8cda2212e8b4ac76c36e08fe" translate="yes" xml:space="preserve">
          <source>There must be exactly as many &amp;lt;</source>
          <target state="translated">정확히 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="1c913968575eb0fea981fd9dac476aba1039c1db" translate="yes" xml:space="preserve">
          <source>There will be multiple structures stored for an&lt;code&gt;INDEXED&lt;/code&gt;file. The first will be a data component, which may be thought of as being similar to the internal structure of a relative file. Data records may not, however, be directly accessed by their record number as would be the case with a relative file, nor may they be processed sequentially by their physical sequence in the file.</source>
          <target state="translated">&lt;code&gt;INDEXED&lt;/code&gt; 파일 에 대해 여러 구조가 저장 됩니다. 첫 번째는 데이터 구성 요소로, 상대 파일의 내부 구조와 유사하다고 생각할 수 있습니다. 그러나 데이터 레코드는 상대 파일의 경우와 같이 레코드 번호로 직접 액세스 할 수 없으며 파일의 실제 순서에 따라 순차적으로 처리 될 수도 없습니다.</target>
        </trans-unit>
        <trans-unit id="daf54f45e2ecf41cd74bccd2cc6ed23d1c32f358" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s no particular order of importance to the topics presented here.</source>
          <target state="translated">여기에 제시된 주제에는 특별한 순서가 없습니다.</target>
        </trans-unit>
        <trans-unit id="af4eed54a73e4ce289f89ea8e838e12942c4ab30" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s no reason that user-defined functions cannot be included too &amp;mdash; they&amp;rsquo;ll just have&lt;code&gt;FUNCTION-ID&lt;/code&gt; and will be ended by&lt;code&gt;END FUNCTION&lt;/code&gt;markers.</source>
          <target state="translated">사용자 정의 함수도 포함시킬 수없는 이유는 없습니다. &lt;code&gt;FUNCTION-ID&lt;/code&gt; 만 있고 &lt;code&gt;END FUNCTION&lt;/code&gt; 마커 로 끝납니다 .</target>
        </trans-unit>
        <trans-unit id="3e273b988fc2338c0c738dfe07fdfb9b6ce96432" translate="yes" xml:space="preserve">
          <source>These are alphanumeric literals whose character sequence is specified by hexadecimal value. These literals are formed by a quote- or apostrophe-delimited sequence of an even number of hexadecimal digits (upper- or lower-case), prefixed with the letter &quot;X&quot; (also upper- or lower-case). For example, the character string &quot;Demo&quot; could be specified as the hexadecimal alphanumeric literal&lt;code&gt;X'44656D6F'&lt;/code&gt; assuming the ASCII character set. See &lt;a href=&quot;#Alphanumeric-Literals&quot;&gt;Alphanumeric Literals&lt;/a&gt;.</source>
          <target state="translated">문자 시퀀스가 ​​16 진수 값으로 지정되는 영숫자 리터럴입니다. 이 리터럴은 문자 &quot;X&quot;(대문자 또는 소문자)가 앞에 붙는 짝수의 16 진수 (대문자 또는 소문자)의 따옴표 또는 아포스트로피로 구분 된 순서로 구성됩니다. 예를 들어, 문자열 &quot;Demo&quot; 는 ASCII 문자 세트를 가정하여 16 진 영숫자 리터럴 &lt;code&gt;X'44656D6F'&lt;/code&gt; 로 지정할 수 있습니다 . &lt;a href=&quot;#Alphanumeric-Literals&quot;&gt;영숫자 리터럴을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="39d5865baa6c47f2c3e2e3e23066a7be896a5033" translate="yes" xml:space="preserve">
          <source>These are data items a COBOL program will be working with. The vast majority of identifiers are defined by the user (programmer) while a few are pre-defined by the GnuCOBOL compiler. Identifiers pre-defined by the compiler are referred to as special registers. Other programming languages generally refer to identifiers as &quot;variables&quot;.</source>
          <target state="translated">이들은 COBOL 프로그램이 작업 할 데이터 항목입니다. 대다수의 식별자는 사용자 (프로그래머)에 의해 정의되고 일부는 GnuCOBOL 컴파일러에 의해 미리 정의됩니다. 컴파일러에 의해 미리 정의 된 식별자를 특수 레지스터라고합니다. 다른 프로그래밍 언어는 일반적으로 식별자를 &quot;변수&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="fcd4a7d412a70cff6f407be688122841b2c032dc" translate="yes" xml:space="preserve">
          <source>These are dynamically-loadable object code files ready to be invoked from other programs at execution time. On Windows systems, these would be &quot;.dll&quot; files, while on Unix systems they are typically &quot;.so&quot; files (OSX uses &quot;.dylib&quot;).</source>
          <target state="translated">실행 시간에 다른 프로그램에서 호출 할 준비가 된 동적으로로드 가능한 객체 코드 파일입니다. Windows 시스템에서는 이러한 파일이 &quot;.dll&quot;파일이고 Unix 시스템에서는 일반적으로 &quot;.so&quot;파일입니다 (OSX는 &quot;.dylib&quot;사용).</target>
        </trans-unit>
        <trans-unit id="6bf41e4479b00c42c49855a07b20df0f65d01747" translate="yes" xml:space="preserve">
          <source>These are files with an internal structure similar to that of a line sequential file. These files are defined (without an explicit&lt;code&gt;ORGANIZATION&lt;/code&gt;specification) using the&lt;code&gt;LINE ADVANCING&lt;/code&gt;clause on their&lt;code&gt;SELECT&lt;/code&gt;statement (see &lt;a href=&quot;#SELECT&quot;&gt;SELECT&lt;/a&gt;).</source>
          <target state="translated">이들은 내부 순차 파일과 유사한 내부 구조를 가진 파일입니다. 이 파일 (명시 적없이 정의 된 &lt;code&gt;ORGANIZATION&lt;/code&gt; 은 Using 사양) &lt;code&gt;LINE ADVANCING&lt;/code&gt; 자신에 절을 &lt;code&gt;SELECT&lt;/code&gt; 문을하십시오 ( &lt;a href=&quot;#SELECT&quot;&gt;선택을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="28646aa778ad9f51bc3b0c02f6a6bed635cd1dc4" translate="yes" xml:space="preserve">
          <source>These are files with the simplest of all internal structures. Their contents are structured simply as a series of identically- or differently-sized data records, each terminated by a special end-of-record delimiter character. An ASCII line-feed character (hexadecimal 0A) is the end-of-record delimiter character used by any UNIX or pseudo-UNIX (MinGW, Cygwin, OSX) GnuCOBOL build. A truly native Windows build would use a carriage-return, line-feed (hexadecimal 0D0A) sequence.</source>
          <target state="translated">내부 구조가 가장 단순한 파일입니다. 이들의 내용은 단순히 일련의 동일하거나 다른 크기의 데이터 레코드로 구성되며 각 레코드는 특수 레코드 끝 구분 문자로 종료됩니다. ASCII 줄 바꿈 문자 (16 진수 0A)는 UNIX 또는 의사 UNIX (MinGW, Cygwin, OSX) GnuCOBOL 빌드에서 사용하는 레코드 끝 구분 문자입니다. 진정한 네이티브 Windows 빌드는 캐리지 리턴, 줄 바꿈 (16 진 0D0A) 시퀀스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c509a81ef47b8fdd35b47d702a31d34f26b41ddc" translate="yes" xml:space="preserve">
          <source>These are subprograms that are coded as the only COBOL program in their Compilation Unit (see &lt;a href=&quot;#Compilation-Unit&quot;&gt;Compilation Unit&lt;/a&gt;).</source>
          <target state="translated">이들은 Compilation Unit에서 유일한 COBOL 프로그램으로 코딩 된 서브 프로그램입니다 ( &lt;a href=&quot;#Compilation-Unit&quot;&gt;Compilation Unit&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6964e4f0b96da5cc6fc1fee3211bc2fd98839ed6" translate="yes" xml:space="preserve">
          <source>These are subprograms which occur in the same Compilation Unit as a main program and/or other subprograms. Each contained subprogram is separated from the next via an&lt;code&gt;END PROGRAM&lt;/code&gt;marker line. As an example&amp;hellip;</source>
          <target state="translated">이들은 메인 프로그램 및 / 또는 다른 서브 프로그램과 동일한 Compilation Unit에서 발생하는 서브 프로그램입니다. 포함 된 각 서브 프로그램은 &lt;code&gt;END PROGRAM&lt;/code&gt; 마커 라인을 통해 다음 프로그램과 분리됩니다 . 예로서&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="76895e0b97ab91b915995d5416d147145fe43369" translate="yes" xml:space="preserve">
          <source>These are the ANSI2002 standard specifications for C-program data compatibility and GnuCOBOL programmers should get used to using them when data is being shared with C programs (they&amp;rsquo;re good documentation too, highlighting the fact that the data will be &quot;shared&quot; with a C program).</source>
          <target state="translated">이는 C 프로그램 데이터 호환성에 대한 ANSI2002 표준 사양이며, GnuCOBOL 프로그래머는 데이터가 C 프로그램과 공유 될 때이를 사용하는 데 익숙해 져야합니다. C 프로그램).</target>
        </trans-unit>
        <trans-unit id="d558b8e16ecda88cc1598dbc79652351d9dcfde2" translate="yes" xml:space="preserve">
          <source>These arguments described in the&lt;code&gt;PROCEDURE DIVISION USING&lt;/code&gt;clause may each be defined as either&lt;code&gt;BY REFERENCE&lt;/code&gt; if the calling program is passing them either&lt;code&gt;BY REFERENCE&lt;/code&gt;</source>
          <target state="translated">호출 프로그램이 &lt;code&gt;BY REFERENCE&lt;/code&gt; 를 전달하는 경우 &lt;code&gt;PROCEDURE DIVISION USING&lt;/code&gt; 절에 설명 된 이러한 인수 는 각각 &lt;code&gt;BY REFERENCE&lt;/code&gt; 로 정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4b37ed305f5bbfb8394faae831ccebcaf1a77a8" translate="yes" xml:space="preserve">
          <source>These arguments must be explicitly included on the&lt;code&gt;PROCEDURE DIVISION USING&lt;/code&gt;(see &lt;a href=&quot;#PROCEDURE-DIVISION-USING&quot;&gt;PROCEDURE DIVISION USING&lt;/a&gt;) clause that lists the arguments in the sequence in which they will be passed to the subprogram.</source>
          <target state="translated">이러한 인수는 명시 적으로에 포함되어야 &lt;code&gt;PROCEDURE DIVISION USING&lt;/code&gt; (참조 &lt;a href=&quot;#PROCEDURE-DIVISION-USING&quot;&gt;PROCEDURE DIVISION 사용&lt;/a&gt; ) 순서리스트 인수가있는 그들이 서브 프로그램에 전달 될 것이라고 절을.</target>
        </trans-unit>
        <trans-unit id="02a7c8c4d3d7c8bd99bb149229246abcdc7add63" translate="yes" xml:space="preserve">
          <source>These commands will create an executable file for the main program &lt;code&gt;-x&lt;/code&gt;switch) and three separate dynamically-loadable libraries &lt;code&gt;-m&lt;/code&gt;switch</source>
          <target state="translated">이 명령은 기본 프로그램 &lt;code&gt;-x&lt;/code&gt; 스위치 의 실행 파일 과 3 개의 별도 동적로드 라이브러리 &lt;code&gt;-m&lt;/code&gt; 스위치를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="d1f06f00b4c3110e6c26b51c5ed23b441bc94fcf" translate="yes" xml:space="preserve">
          <source>These default initialization rules can vary quite substantially from one COBOL implementation to another. For example, it is quite common for data division storage to be initialized to all binary zeros except for those data items where&lt;code&gt;VALUE&lt;/code&gt;clauses are present. Take care when working with applications originally developed for another COBOL implementation to ensure that GnuCOBOL&amp;rsquo;s default initialization rules won&amp;rsquo;t prove disruptive.</source>
          <target state="translated">이러한 기본 초기화 규칙은 COBOL 구현마다 상당히 다를 수 있습니다. 예를 들어, &lt;code&gt;VALUE&lt;/code&gt; 절이 있는 데이터 항목을 제외하고 데이터 분할 스토리지가 모든 이진 0으로 초기화되는 것이 일반적입니다 . 원래 다른 COBOL 구현을 위해 개발 된 응용 프로그램으로 작업 할 때 GnuCOBOL의 기본 초기화 규칙이 중단되지 않는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="701217fa2db2cbf23b55c09465a26e4066b8e336" translate="yes" xml:space="preserve">
          <source>These devices (they are all synonymous) represent standard system input (pipe 0). On a PC or UNIX system, this is typically the keyboard. The contents of a file may be delivered to a GnuCOBOL program for access via one of these device names by adding the sequence &quot;0&amp;lt; filename&quot; to the end of the programs execution command.</source>
          <target state="translated">이러한 장치 (모두 동의어)는 표준 시스템 입력 (파이프 0)을 나타냅니다. PC 또는 UNIX 시스템에서는 일반적으로 키보드입니다. 파일의 내용은 프로그램 실행 명령 끝에 &quot;0 &amp;lt;filename&quot;시퀀스를 추가하여 이러한 장치 이름 중 하나를 통해 액세스하기 위해 GnuCOBOL 프로그램으로 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61151614a5aad3f93304e8a9e0cec0132ad8c50d" translate="yes" xml:space="preserve">
          <source>These devices (they are all synonymous) represent standard system output (pipe 1). On a PC or UNIX system, this is typically the display. Output sent to one of these devices by a GnuCOBOL program can be sent to a file by adding the sequence &quot;1&amp;gt; filename&quot; to the end of the programs execution command.</source>
          <target state="translated">이러한 장치 (모두 동의어)는 표준 시스템 출력 (파이프 1)을 나타냅니다. PC 또는 UNIX 시스템에서는 일반적으로 디스플레이입니다. GnuCOBOL 프로그램에 의해 이들 장치 중 하나로 전송 된 출력은 프로그램 실행 명령 끝에 &quot;1&amp;gt; filename&quot;시퀀스를 추가하여 파일로 전송 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f0d5a3b8f4599a8d931f9bdeee9e6eacf68dbde" translate="yes" xml:space="preserve">
          <source>These devices (they are synonymous) represent standard system error output (pipe 2). On a PC or UNIX system, this is typically the display. Output sent to one of these devices by a GnuCOBOL program can be sent to a file by adding the sequence &quot;2&amp;gt; filename&quot; to the end of the programs execution command.</source>
          <target state="translated">이러한 장치 (동의어)는 표준 시스템 오류 출력 (파이프 2)을 나타냅니다. PC 또는 UNIX 시스템에서는 일반적으로 디스플레이입니다. GnuCOBOL 프로그램에 의해 이들 장치 중 하나로 전송 된 출력은 프로그램 실행 명령 끝에 &quot;2&amp;gt; filename&quot;시퀀스를 추가하여 파일로 전송 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6181c3ae008350673a8b8fdda1aa5bac1a8461a7" translate="yes" xml:space="preserve">
          <source>These disk files will be automatically purged upon&lt;code&gt;SORT&lt;/code&gt;or&lt;code&gt;MERGE&lt;/code&gt;termination. They will also be purged if the program terminates abnormally before the&lt;code&gt;SORT&lt;/code&gt;or&lt;code&gt;MERGE&lt;/code&gt;finishes. Should you ever need to know, temporary sort/merge work files will be named &quot;cob*.tmp&quot;.</source>
          <target state="translated">이 디스크 파일은 &lt;code&gt;SORT&lt;/code&gt; 또는 &lt;code&gt;MERGE&lt;/code&gt; 종료시 자동으로 제거 됩니다. &lt;code&gt;SORT&lt;/code&gt; 또는 &lt;code&gt;MERGE&lt;/code&gt; 가 완료 되기 전에 프로그램이 비정상적으로 종료되면 제거됩니다 . 알아야 할 경우 임시 정렬 / 병합 작업 파일의 이름은 &quot;cob * .tmp&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="92cbe7f0dcf04b1baa2ffbbd7a037fda6e1753e7" translate="yes" xml:space="preserve">
          <source>These editing symbols are known as floating replacement symbols. These symbols may occur in sequences</source>
          <target state="translated">이러한 편집 기호를 부동 대체 기호라고합니다. 이러한 기호는 순서대로 나타날 수 있습니다</target>
        </trans-unit>
        <trans-unit id="33dda627ab340ce9d39efbbe3a800c3f6c378519" translate="yes" xml:space="preserve">
          <source>These environment variables have default values established for them when the version of GnuCOBOL you are using was built. To see these default values, as well as other build-specific information, execute the command:</source>
          <target state="translated">이 환경 변수에는 사용중인 GnuCOBOL 버전이 빌드 ​​될 때 설정된 기본값이 있습니다. 다른 빌드 특정 정보뿐만 아니라 이러한 기본값을 보려면 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="f379b779cb3a15704659f5e4f041967679a77328" translate="yes" xml:space="preserve">
          <source>These features allow fields to be displayed at specific row/column positions, various colors and video attributes to be assigned to screen fields and the pressing of specific function keys (F1, F2, &amp;hellip;) to be detectable. All of this takes place through the auspices of the&lt;code&gt;SCREEN SECTION&lt;/code&gt;(see &lt;a href=&quot;#SCREEN-SECTION&quot;&gt;SCREEN SECTION&lt;/a&gt;) and special formats of the&lt;code&gt;ACCEPT&lt;/code&gt;statement (see &lt;a href=&quot;#ACCEPT&quot;&gt;ACCEPT&lt;/a&gt;) and the&lt;code&gt;DISPLAY&lt;/code&gt;statement (see &lt;a href=&quot;#DISPLAY&quot;&gt;DISPLAY&lt;/a&gt;).</source>
          <target state="translated">이 기능을 사용하면 필드를 특정 행 / 열 위치에 표시 할 수 있으며, 다양한 색상 및 비디오 속성을 화면 필드에 할당하고 특정 기능 키 (F1, F2,&amp;hellip;)를 눌러 감지 할 수 있습니다. 이 모든의 후원을 통해 발생하는 &lt;code&gt;SCREEN SECTION&lt;/code&gt; (참조 &lt;a href=&quot;#SCREEN-SECTION&quot;&gt;화면 섹션을&lt;/a&gt; )과의 특별한 형식 &lt;code&gt;ACCEPT&lt;/code&gt; 문 (참조 &lt;a href=&quot;#ACCEPT&quot;&gt;ACCEPT&lt;/a&gt; )와 &lt;code&gt;DISPLAY&lt;/code&gt; 문 (참조 &lt;a href=&quot;#DISPLAY&quot;&gt;표시&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fbbacca89e38681e816ad731a72f876256195970" translate="yes" xml:space="preserve">
          <source>These files</source>
          <target state="translated">이 파일들</target>
        </trans-unit>
        <trans-unit id="6699f7b349ca5309c79afaf648bc3f7430d29e70" translate="yes" xml:space="preserve">
          <source>These files also have a simple internal structure. Their contents are structured simply as an arbitrarily-long sequence of data characters. This sequence of characters will be treated as a series of fixed-length records simply by logically splitting the sequence of characters up into fixed-length segments, each as long as the maximum record size defined in the program. There are no special end-of-record delimiter characters in the file and when the file is written to by a GnuCOBOL program, no delimiter sequence is appended to the data.</source>
          <target state="translated">이 파일들은 또한 간단한 내부 구조를 가지고 있습니다. 그 내용은 단순히 임의의 긴 데이터 문자 시퀀스로 구성됩니다. 이 일련의 문자는 각각 프로그램에 정의 된 최대 레코드 크기 인 경우 문자 순서를 고정 길이 세그먼트로 논리적으로 분할하여 일련의 고정 길이 레코드로 취급됩니다. 파일에는 특별한 레코드 끝 구분 문자가 없으며 GnuCOBOL 프로그램에서 파일을 쓸 때 구분 기호 시퀀스가 ​​데이터에 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a554d7231d837a9d0fff7ec687b719c088ec80e" translate="yes" xml:space="preserve">
          <source>These files can contain exact binary data fields. The contents of record fields are irrelevant to the reading process as there is no end-of-record delimiter.</source>
          <target state="translated">이 파일에는 정확한 이진 데이터 필드가 포함될 수 있습니다. 레코드 끝 구분 기호가 없으므로 레코드 필드의 내용은 읽기 프로세스와 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a8fb25f6745fe6006a100e5683bfd6f58d6f7e12" translate="yes" xml:space="preserve">
          <source>These files cannot be prepared with any standard text-editing or word processing software as all such programs will embed delimiter characters at the end of records (use&lt;code&gt;ORGANIZATION IS LINE SEQUENTIAL&lt;/code&gt;instead).</source>
          <target state="translated">이러한 파일은 표준 텍스트 편집 또는 워드 프로세싱 소프트웨어를 사용하여 준비 할 수 없습니다. 모든 프로그램은 레코드 끝에 구분 문자를 포함합니다 ( 대신 &lt;code&gt;ORGANIZATION IS LINE SEQUENTIAL&lt;/code&gt; 사용).</target>
        </trans-unit>
        <trans-unit id="30a90bc57eedd447e2279c68436fe656951f3a9d" translate="yes" xml:space="preserve">
          <source>These files may be created with any standard text-editing or word processing software capable of writing text files. Such files should not contain any&lt;code&gt;USAGE COMPUTATIONAL&lt;/code&gt;or&lt;code&gt;BINARY&lt;/code&gt;(of any variety) data since such fields could accidentally contain byte sequences that could be interpreted as an end-of-record delimiter.</source>
          <target state="translated">이러한 파일은 텍스트 파일을 작성할 수있는 표준 텍스트 편집 또는 워드 프로세싱 소프트웨어로 만들 수 있습니다. 이러한 파일에는 레코드 끝 구분 기호로 해석 될 수있는 바이트 시퀀스가 ​​실수로 포함될 수 있으므로 &lt;code&gt;USAGE COMPUTATIONAL&lt;/code&gt; 또는 &lt;code&gt;BINARY&lt;/code&gt; (다양한) 데이터를 포함해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="773a999ee736be9c1049bf3f8df28ec43faf4564" translate="yes" xml:space="preserve">
          <source>These files may contain either&lt;code&gt;USAGE DISPLAY&lt;/code&gt;or&lt;code&gt;USAGE COMPUTATIONAL&lt;/code&gt;(of any variety) data since no binary data sequence can be accidentally interpreted as an end-of-record delimiter.</source>
          <target state="translated">이진 데이터 시퀀스를 실수로 레코드 끝 구분 기호로 해석 할 수 없으므로 이러한 파일에는 &lt;code&gt;USAGE DISPLAY&lt;/code&gt; 또는 &lt;code&gt;USAGE COMPUTATIONAL&lt;/code&gt; (모든 다양한) 데이터 가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3f638138c2e4babf6d1aad28a17b4b4df0bf8d9" translate="yes" xml:space="preserve">
          <source>These files should not be defined to contain any exact binary data fields because the contents of those fields could inadvertently have the end-of-record sequence as part of their values &amp;mdash; this would confuse the runtime system when reading the file, and it would interpret that value as an actual end-of-record sequence.</source>
          <target state="translated">이 필드의 내용이 실수로 레코드 끝 순서를 값의 일부로 가질 수 있으므로 이러한 파일은 정확한 이진 데이터 필드를 포함하도록 정의되어서는 안됩니다. 파일을 읽을 때 런타임 시스템이 혼동되어 해석됩니다. 이 값은 실제 레코드 끝 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="9b88d3f29bd1f69c7a3b3ea40973dd9ef6c1de56" translate="yes" xml:space="preserve">
          <source>These groups will be presented (printed) across however many formatted pages are necessary to hold them. No single report group will be allowed to cross page boundaries.</source>
          <target state="translated">이러한 그룹은 여러 페이지에 걸쳐 표시 (인쇄)되지만이를 유지하려면 많은 형식의 페이지가 필요합니다. 단일 보고서 그룹이 페이지 경계를 넘을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6c9c454d2c7ecb45f67795257e95a0e2650d038c" translate="yes" xml:space="preserve">
          <source>These options (which are synonymous) inform GnuCOBOL that any locks held by other programs should be ignored.</source>
          <target state="translated">이러한 옵션 (동의어)은 GnuCOBOL에 다른 프로그램이 보유한 잠금을 무시해야 함을 알립니다.</target>
        </trans-unit>
        <trans-unit id="f4561a548392bb7602e8485832140307787f88a0" translate="yes" xml:space="preserve">
          <source>These programs are compiled and executed as follows.</source>
          <target state="translated">이 프로그램들은 다음과 같이 컴파일되고 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="eed10b6657fe3ffe33cc3bac878e3db916bf48af" translate="yes" xml:space="preserve">
          <source>These routines, all executed via their UPPER-CASE NAMES via the&lt;code&gt;CALL&lt;/code&gt;statement (see &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt;), are capable of performing the following Functions:</source>
          <target state="translated">이 루틴은 모두 &lt;code&gt;CALL&lt;/code&gt; 문을 통해 UPPER-CASE NAMES를 통해 실행되며 ( &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt; 참조 ) 다음 기능을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b8d289146d8f0f781c1476cb857a4eed48416eb" translate="yes" xml:space="preserve">
          <source>These sections consist of a series of specific, pre-defined, paragraphs &lt;code&gt;SOURCE-COMPUTER&lt;/code&gt;and&lt;code&gt;OBJECT-COMPUTER&lt;/code&gt; for example), each of which serves a specific purpose. If no code is required for the purpose one of the paragraphs serves, the entire paragraph may be omitted.</source>
          <target state="translated">이 섹션은 일련의 특정 사전 정의 된 단락 &lt;code&gt;SOURCE-COMPUTER&lt;/code&gt; 및 &lt;code&gt;OBJECT-COMPUTER&lt;/code&gt; 로 구성되어 있습니다. 단락 중 하나가 제공하는 목적으로 코드가 필요하지 않으면 전체 단락을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62929ba0db03b4beb2bd013b744397c9e2894dab" translate="yes" xml:space="preserve">
          <source>They conform to the principles of Object-Oriented Programming (OOP). This is desired for one major reason &amp;mdash; it facilitates &quot;code re-usability&quot;, thus improving the productivity of programmers by allowing them to re-use previously written (and debugged) code in new applications. For one reason or another, COBOL is perceived as being weak in this regard. It isn&amp;rsquo;t (especially today), as we&amp;rsquo;ll see in the next section, but perception is important.</source>
          <target state="translated">이들은 OOP (Object-Oriented Programming)의 원칙을 준수합니다. 이는 &quot;코드 재사용 성&quot;을 촉진하여 프로그래머가 새로운 애플리케이션에서 이전에 작성된 코드를 재사용 할 수 있도록함으로써 생산성을 향상시킵니다. 어떤 이유로 든, COBOL은 이와 관련하여 약한 것으로 인식됩니다. 다음 섹션에서 볼 수 있듯이 (특히 오늘)는 아니지만 인식이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="6af427b8aed8b7509a22f79cb7449b442b82701f" translate="yes" xml:space="preserve">
          <source>This [re]-initialization behaviour will</source>
          <target state="translated">이 [재] 초기화 동작은</target>
        </trans-unit>
        <trans-unit id="fca78a299aa4a30f104a6b087a5d63861845b4d5" translate="yes" xml:space="preserve">
          <source>This behaviour when the argument is defined as&lt;code&gt;PIC 9&lt;/code&gt;may be unacceptable, as an argument defined as&lt;code&gt;PIC 9(3)&lt;/code&gt;but passed in a value of &quot;1&quot; from the command line will receive a value of &quot;100&quot;, not &quot;001&quot;. Consider defining &quot;numeric&quot; command line arguments as&lt;code&gt;PIC X&lt;/code&gt;and then using the&lt;code&gt;NUMVAL&lt;/code&gt;intrinsic function (see &lt;a href=&quot;#NUMVAL&quot;&gt;NUMVAL&lt;/a&gt;) function to determine the proper numeric value.</source>
          <target state="translated">인수가 &lt;code&gt;PIC 9&lt;/code&gt; 로 정의 된 경우이 동작 은 &lt;code&gt;PIC 9(3)&lt;/code&gt; 으로 정의 된 인수로 받아 들일 수 없지만 명령 행에서 &quot;1&quot;값으로 전달되면 &quot;001&quot;이 아닌 &quot;100&quot;값이 수신됩니다. . &quot;숫자&quot;명령 행 인수를 &lt;code&gt;PIC X&lt;/code&gt; 로 정의한 다음 &lt;code&gt;NUMVAL&lt;/code&gt; 내장 함수 ( &lt;a href=&quot;#NUMVAL&quot;&gt;NUMVAL&lt;/a&gt; 참조 ) 함수를 사용하여 적절한 숫자 값을 결정하십시오.</target>
        </trans-unit>
        <trans-unit id="11da61e63c24de1b7043b9eb592216695d265e9a" translate="yes" xml:space="preserve">
          <source>This clause allows you to define a declarative procedure that will be invoked whenever&amp;hellip;</source>
          <target state="translated">이 절에서는 다음과 같은 경우에 호출되는 선언적 절차를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38f94dd3668fa950b3453abccfbc32b8184f6b66" translate="yes" xml:space="preserve">
          <source>This clause cannot be specified on the same data item as a&lt;code&gt;FROM&lt;/code&gt;(see &lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;),&lt;code&gt;TO&lt;/code&gt;(see &lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt;) or&lt;code&gt;USING&lt;/code&gt;(see &lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;) clause.</source>
          <target state="translated">이 절은 &lt;code&gt;FROM&lt;/code&gt; ( &lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt; 참조 ), &lt;code&gt;TO&lt;/code&gt; ( &lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt; 참조 ) 또는 &lt;code&gt;USING&lt;/code&gt; ( &lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt; 참조 ) 절 과 동일한 데이터 항목에 지정할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d94784dc77a17d2c590404b1a5fb63ba7e8436cd" translate="yes" xml:space="preserve">
          <source>This clause controls the intensity of text &lt;code&gt;FOREGROUND-COLOR&lt;/code&gt;(see &lt;a href=&quot;#FOREGROUND_002dCOLOR&quot;&gt;FOREGROUND-COLOR&lt;/a&gt;)) by setting that intensity to its highest of three possible settings.</source>
          <target state="translated">이 절 컨트롤 텍스트의 강도 &lt;code&gt;FOREGROUND-COLOR&lt;/code&gt; 는 (참조 &lt;a href=&quot;#FOREGROUND_002dCOLOR&quot;&gt;포 그라운드-COLOR를&lt;/a&gt; 세 가지 설정의 최고에 그 강도를 설정하여)).</target>
        </trans-unit>
        <trans-unit id="9ed9ae0c7de7345f71cffae88b4e5e38e2a5f8f1" translate="yes" xml:space="preserve">
          <source>This clause defines any rules for where the next group to be presented on a report will begin, line-wise, with respect to the</source>
          <target state="translated">이 절은 보고서에 다음에 표시 될 그룹이 줄 단위로 시작되는 규칙을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="2aaa7f66dde0442e1de03fe873ed48b0cb4ee29a" translate="yes" xml:space="preserve">
          <source>This clause defines the character that will be used as the fill-character for any input fields on the screen.</source>
          <target state="translated">이 절은 화면의 모든 입력 필드에 대한 채우기 문자로 사용될 문자를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="9c6d71f9e8e9d855c6cd571360f2bd903599d77f" translate="yes" xml:space="preserve">
          <source>This clause defines the type of report group that is being defined for a report.</source>
          <target state="translated">이 절은 보고서에 정의중인 보고서 그룹의 유형을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="121fa1385c3f6f2d6f8162c059efbd88965e045d" translate="yes" xml:space="preserve">
          <source>This clause forces the user to enter data into the field it is specified on (or into all subordinate input-capable fields if&lt;code&gt;EMPTY-CHECK&lt;/code&gt;is specified on a group item).</source>
          <target state="translated">이 절은 사용자가 지정된 필드 (또는 &lt;code&gt;EMPTY-CHECK&lt;/code&gt; 가 그룹 항목에 지정된 경우 모든 하위 입력 가능 필드)에 데이터를 입력하도록합니다 .</target>
        </trans-unit>
        <trans-unit id="2038deeb71f2d4c7ad23b64fdc30f7b3c2bd2cdf" translate="yes" xml:space="preserve">
          <source>This clause forces the user to enter data into the field it is specified on (or into all subordinate input-capable fields if&lt;code&gt;REQUIRED&lt;/code&gt;is specified on a group item).</source>
          <target state="translated">이 절은 사용자가 지정된 필드 (또는 &lt;code&gt;REQUIRED&lt;/code&gt; 가 그룹 항목에 지정된 경우 모든 하위 입력 가능 필드)에 데이터를 입력하도록합니다 .</target>
        </trans-unit>
        <trans-unit id="e3181363a5f88a363ea6416864d3a93a60b89415" translate="yes" xml:space="preserve">
          <source>This clause is essentially non-functional when used within Windows command shell (cmd.exe) environments and running programs compiled using a GnuCOBOL implementation built using &amp;rsquo;PDCurses&amp;rsquo; (such as Windows/MinGW builds).</source>
          <target state="translated">이 절은 Windows 명령 셸 (cmd.exe) 환경에서 사용하고 'PDCurses'(예 : Windows / MinGW 빌드)를 사용하여 빌드 된 GnuCOBOL 구현을 사용하여 컴파일 된 프로그램을 실행할 때 기본적으로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2cc890e042f0a9a83b808a4cbd76773d885f97bf" translate="yes" xml:space="preserve">
          <source>This clause is required on any 01-level data item definitions (other than 01-level constants) in the report section. This clause is invalid on any other report section data item definitions.</source>
          <target state="translated">이 절은 보고서 섹션의 01 수준 상수 이외의 01 수준 데이터 항목 정의에 필요합니다. 이 절은 다른 보고서 섹션 데이터 항목 정의에서 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db907bca7d96bbf58cb7a4a40b12e9f74eb40044" translate="yes" xml:space="preserve">
          <source>This clause is used to specify either the data item a screen section field is to obtain it&amp;rsquo;s value from when the screen is displayed, or a literal that will specify the value of that same field.</source>
          <target state="translated">이 절은 화면이 표시 될 때 화면 섹션 필드에서 값을 가져 오는 데이터 항목 또는 동일한 필드의 값을 지정하는 리터럴을 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="91d42cb0282570b9e5009b94e38dd2c762edfecb" translate="yes" xml:space="preserve">
          <source>This clause is used to specify the color of text within a screen data item or the default text color of subordinate items if used on a group item.</source>
          <target state="translated">이 항목은 화면 데이터 항목 내의 텍스트 색상 또는 그룹 항목에 사용되는 경우 하위 항목의 기본 텍스트 색상을 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="59ea3fb6b91a391253a515d607f2d2f10ea8106d" translate="yes" xml:space="preserve">
          <source>This clause is used to specify the screen background color of the screen data item or the default screen background color of subordinate items if used on a group item.</source>
          <target state="translated">이 항목은 그룹 데이터에 사용되는 경우 화면 데이터 항목의 화면 배경색 또는 하위 항목의 기본 화면 배경색을 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f01d93fbfc751a50def36fb34dab2fffc71fcd79" translate="yes" xml:space="preserve">
          <source>This clause is useful when one screen section item is being displayed over the top of a previously-displayed one.</source>
          <target state="translated">이 절은 하나의 화면 섹션 항목이 이전에 표시된 항목 위에 표시 될 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f0d8e4898356eb496cdba9f66a6179a5d88ea25a" translate="yes" xml:space="preserve">
          <source>This clause is valid only on alphabetic (PIC A) or alphanumeric (PIC X) data items.</source>
          <target state="translated">이 절은 알파벳 (PIC A) 또는 영숫자 (PIC X) 데이터 항목에만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="13caed7c0c09caeb47640b14b0fa422d5c420f06" translate="yes" xml:space="preserve">
          <source>This clause logically attaches a report section data item to another data item defined elsewhere in the data division.</source>
          <target state="translated">이 절은 데이터 섹션의 다른 곳에 정의 된 다른 데이터 항목에 보고서 섹션 데이터 항목을 논리적으로 연결합니다.</target>
        </trans-unit>
        <trans-unit id="8ebecaa22c921ba3164d2f77c87706477a4ef3c3" translate="yes" xml:space="preserve">
          <source>This clause logically attaches a screen section data item to another data item defined elsewhere in the data division.</source>
          <target state="translated">이 절은 데이터 섹션의 다른 곳에 정의 된 다른 데이터 항목에 화면 섹션 데이터 항목을 논리적으로 연결합니다.</target>
        </trans-unit>
        <trans-unit id="7eb8a086adda7db320c456ee19ce704ce4ce85f9" translate="yes" xml:space="preserve">
          <source>This clause marks a data item description,&lt;code&gt;FD&lt;/code&gt;or&lt;code&gt;SD&lt;/code&gt;see &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File/Sort-Description&lt;/a&gt; as being shareable with other programs executed from the same execution thread.</source>
          <target state="translated">이 항목은 데이터 항목 설명을 표시합니다. &lt;code&gt;FD&lt;/code&gt; 또는 &lt;code&gt;SD&lt;/code&gt; 는 동일한 실행 스레드에서 실행 된 다른 프로그램과 공유 할 수있는 &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;파일 / 정렬 설명&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3994e985dfc22a70635e03f6a148c64983e7db21" translate="yes" xml:space="preserve">
          <source>This clause marks a data item, 01-level constant,&lt;code&gt;FD&lt;/code&gt;(see &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File/Sort-Description&lt;/a&gt;),&lt;code&gt;SD&lt;/code&gt;(see &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File/Sort-Description&lt;/a&gt;) or an&lt;code&gt;RD&lt;/code&gt;(see &lt;a href=&quot;#REPORT-SECTION&quot;&gt;REPORT SECTION&lt;/a&gt;) as being shareable with any nested subprograms.</source>
          <target state="translated">이 절은 데이터 레벨, 01 레벨 상수, &lt;code&gt;FD&lt;/code&gt; ( &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;파일 / 정렬 설명&lt;/a&gt; 참조 ), &lt;code&gt;SD&lt;/code&gt; ( &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;파일 / 정렬 설명 참조&lt;/a&gt; ) 또는 &lt;code&gt;RD&lt;/code&gt; ( &lt;a href=&quot;#REPORT-SECTION&quot;&gt;보고서 섹션&lt;/a&gt; 참조 )를 중첩 서브 프로그램과 공유 할 수있는 것으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="5247bdd054b75c267aed74c09cf0430b40fcc80e" translate="yes" xml:space="preserve">
          <source>This clause may be used either in the file&amp;rsquo;s&lt;code&gt;SELECT&lt;/code&gt;statement (see &lt;a href=&quot;#SELECT&quot;&gt;SELECT&lt;/a&gt;), on the&lt;code&gt;OPEN&lt;/code&gt;statement (see &lt;a href=&quot;#OPEN&quot;&gt;OPEN&lt;/a&gt;) which initiates your program&amp;rsquo;s use of the file, or both. If a&lt;code&gt;SHARING&lt;/code&gt;option is specified in</source>
          <target state="translated">이 절은 파일의 &lt;code&gt;SELECT&lt;/code&gt; 문 ( &lt;a href=&quot;#SELECT&quot;&gt;SELECT&lt;/a&gt; 참조 ), 프로그램의 파일 사용을 시작 하는 &lt;code&gt;OPEN&lt;/code&gt; 문 ( &lt;a href=&quot;#OPEN&quot;&gt;OPEN&lt;/a&gt; 참조 ) 또는 둘 다에 사용될 수 있습니다. 에 &lt;code&gt;SHARING&lt;/code&gt; 옵션이 지정된 경우</target>
        </trans-unit>
        <trans-unit id="24a6073724ea84bea33701d7a91b18b885bb2235" translate="yes" xml:space="preserve">
          <source>This clause may not be coded when the&lt;code&gt;TIMES&lt;/code&gt;clause is used.</source>
          <target state="translated">이 절은 &lt;code&gt;TIMES&lt;/code&gt; 절이 사용될 때 코딩되지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b0a48719a69aefd8e4d288d7a3183fba77f02c6f" translate="yes" xml:space="preserve">
          <source>This clause may only appear within a&lt;code&gt;DETAIL&lt;/code&gt;report group (see &lt;a href=&quot;#TYPE&quot;&gt;TYPE&lt;/a&gt;).</source>
          <target state="translated">이 절은 &lt;code&gt;DETAIL&lt;/code&gt; 보고서 그룹 에만 나타날 수 있습니다 ( &lt;a href=&quot;#TYPE&quot;&gt;TYPE&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="eaaa44a46b363baed90c7da1705fc5b90a0edd81" translate="yes" xml:space="preserve">
          <source>This clause may only be used on a PIC 9 data item with a&lt;code&gt;USAGE&lt;/code&gt;(see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) of&lt;code&gt;DISPLAY&lt;/code&gt;</source>
          <target state="translated">이 절은 &lt;code&gt;USAGE&lt;/code&gt; ( &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt; 참조 )가 &lt;code&gt;DISPLAY&lt;/code&gt; 인 PIC 9 데이터 항목에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7211b6d5e0e9f864cc6c6959daec16ab3376908" translate="yes" xml:space="preserve">
          <source>This clause may only be used on a field allowing data entry (a field containing either the&lt;code&gt;USING&lt;/code&gt;(see &lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;) or&lt;code&gt;TO&lt;/code&gt;(see &lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt;) clause).</source>
          <target state="translated">이 절은 데이터 입력을 허용하는 필드 ( &lt;code&gt;USING&lt;/code&gt; ( &lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt; 참조 ) 또는 &lt;code&gt;TO&lt;/code&gt; ( &lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt; 참조 ) 절을 포함하는 필드)에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="08b5266d5319f17fcf8a21c06aa3dde528b43596" translate="yes" xml:space="preserve">
          <source>This clause names an existing&lt;code&gt;Condition Name&lt;/code&gt;(see &lt;a href=&quot;#Condition-Names&quot;&gt;Condition Names&lt;/a&gt;) that will serve as a switch controlling the presentation or suppression of a report group.</source>
          <target state="translated">이 절 은 보고서 그룹의 표시 또는 억제를 제어하는 ​​스위치 역할을 하는 기존 &lt;code&gt;Condition Name&lt;/code&gt; ( &lt;a href=&quot;#Condition-Names&quot;&gt;조건 이름&lt;/a&gt; 참조 )의 이름 을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="df172b9ca36246b34aa957a22ed3ce8d436f11b9" translate="yes" xml:space="preserve">
          <source>This clause provides a means of explicitly stating on which line a field should be presented on the console window (screen section) or on a report (report section).</source>
          <target state="translated">이 절은 콘솔 창 (화면 섹션) 또는 보고서 (보고서 섹션)에 필드를 표시 할 행을 명시 적으로 나타내는 수단을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f4c013879b65c37f36a99cb408b528bc68685e7f" translate="yes" xml:space="preserve">
          <source>This clause will blank out either the entire screen (BLANK SCREEN) or just the line upon which data is about to be displayed (BLANK LINE).</source>
          <target state="translated">이 절은 전체 화면 (BLANK SCREEN) 또는 데이터가 표시 될 라인 (BLANK LINE)을 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="9c445faa645ee68e8edd382544cb24f7f90c3338" translate="yes" xml:space="preserve">
          <source>This clause will cause all data entered into the field to appear on the screen as asterisks.</source>
          <target state="translated">이 절은 필드에 입력 된 모든 데이터가 화면에 별표로 표시되도록합니다.</target>
        </trans-unit>
        <trans-unit id="5ad7569ae442e9e27dac3533de8959f4fc969d4a" translate="yes" xml:space="preserve">
          <source>This clause will cause that item&amp;rsquo;s value to be automatically transformed into spaces if a value of 0 is ever MOVEd to the item.</source>
          <target state="translated">이 절은 값 0이 항목으로 이동 된 경우 항목 값이 공백으로 자동 변환되도록합니다.</target>
        </trans-unit>
        <trans-unit id="ff84335e1ef2c6796366de71262bba2490866866" translate="yes" xml:space="preserve">
          <source>This clause, allowable only for&lt;code&gt;USAGE DISPLAY&lt;/code&gt;numeric data items, specifies how an&lt;code&gt;S&lt;/code&gt;symbol will be interpreted in a data item&amp;rsquo;s picture clause.</source>
          <target state="translated">&lt;code&gt;USAGE DISPLAY&lt;/code&gt; 숫자 데이터 항목 에만 허용되는이 절 은 데이터 항목의 그림 절에서 &lt;code&gt;S&lt;/code&gt; 기호를 해석 하는 방법을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="09206ccb9bca33a3ce057096afb3043cd2413ccd" translate="yes" xml:space="preserve">
          <source>This clause, along with&lt;code&gt;HIGHLIGHT&lt;/code&gt;(see &lt;a href=&quot;#HIGHLIGHT&quot;&gt;HIGHLIGHT&lt;/a&gt;), are intended to provide a three-level intensity scheme &lt;code&gt;LOWLIGHT&lt;/code&gt;&amp;hellip; nothing (Normal) &amp;hellip;&lt;code&gt;HIGHLIGHT&lt;/code&gt;. In environments such as a Windows console where only two levels of intensity are supported,&lt;code&gt;LOWLIGHT&lt;/code&gt;is the same as leaving this clause off altogether.</source>
          <target state="translated">와 함께이 절, &lt;code&gt;HIGHLIGHT&lt;/code&gt; (참조 &lt;a href=&quot;#HIGHLIGHT&quot;&gt;HIGHLIGHT을&lt;/a&gt; ), 세 수준의 강도 구성표 제공하기위한 것입니다 &lt;code&gt;LOWLIGHT&lt;/code&gt; ... 아무것도 (일반)을 &lt;code&gt;HIGHLIGHT&lt;/code&gt; . 두 가지 수준의 강도 만 지원되는 Windows 콘솔과 같은 환경에서 &lt;code&gt;LOWLIGHT&lt;/code&gt; 는이 절을 모두 해제 한 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0207532638521d74ddbd59580a8671e6f34a7f96" translate="yes" xml:space="preserve">
          <source>This clause, along with&lt;code&gt;LOWLIGHT&lt;/code&gt;(see &lt;a href=&quot;#LOWLIGHT&quot;&gt;LOWLIGHT&lt;/a&gt;), are intended to provide a three-level intensity scheme &lt;code&gt;LOWLIGHT&lt;/code&gt;&amp;hellip; nothing (Normal) &amp;hellip;&lt;code&gt;HIGHLIGHT&lt;/code&gt;.</source>
          <target state="translated">와 함께이 절, &lt;code&gt;LOWLIGHT&lt;/code&gt; 은 (참조 &lt;a href=&quot;#LOWLIGHT&quot;&gt;LOWLIGHT을&lt;/a&gt; ), 세 수준의 강도 구성표 제공하기위한 것입니다 &lt;code&gt;LOWLIGHT&lt;/code&gt; ... 아무것도 (일반) ... &lt;code&gt;HIGHLIGHT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa6967469379904fde1e85b4edbc94809eeef916" translate="yes" xml:space="preserve">
          <source>This clause, which may only appear on the definition of a level-88 condition name, is used to specify the value of the data item that serves as the parent of the level-88 condition name that will force the condition name to assume a value of FALSE.</source>
          <target state="translated">레벨 88 조건 이름의 정의에만 나타날 수있는이 절은 조건 이름이 값을 갖도록 강제하는 레벨 88 조건 이름의 상위 역할을하는 데이터 항목의 값을 지정하는 데 사용됩니다. 거짓.</target>
        </trans-unit>
        <trans-unit id="d0c031a83df18d5e9b429da47ff25c4b19bd76d9" translate="yes" xml:space="preserve">
          <source>This code will display&lt;code&gt;518 555 1212&lt;/code&gt;</source>
          <target state="translated">이 코드는 &lt;code&gt;518 555 1212&lt;/code&gt; 표시합니다</target>
        </trans-unit>
        <trans-unit id="565178ff429d2ded9f5a38aa204215e31677bf03" translate="yes" xml:space="preserve">
          <source>This code will display&lt;code&gt;ABCDEFGHIJKL&lt;/code&gt;on the console output window:</source>
          <target state="translated">이 코드는 콘솔 출력 창에 &lt;code&gt;ABCDEFGHIJKL&lt;/code&gt; 을 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="35c0dc3687874b148a4618825702578b69013557" translate="yes" xml:space="preserve">
          <source>This command assumes that all source files are in the directory from which the&lt;code&gt;cobc&lt;/code&gt;command was executed. You are, of course, free to include full pathnames with any filename, if necessary.</source>
          <target state="translated">이 명령은 모든 소스 파일이 &lt;code&gt;cobc&lt;/code&gt; 명령이 실행 된 디렉토리에 있다고 가정합니다 . 물론 필요한 경우 파일 이름과 함께 전체 경로 이름을 자유롭게 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2958764b8cdf29141518a961cbd01874df3b3d71" translate="yes" xml:space="preserve">
          <source>This command informs the compiler (cobc) that four programs are to be compiled (the first named on the command must always be the main program), and a single executable file is to be created (due to the&lt;code&gt;-x&lt;/code&gt;switch</source>
          <target state="translated">이 명령은 컴파일러 (cobc)에게 4 개의 프로그램을 컴파일해야하고 (명령에서 첫 번째로 명명 된 이름은 항상 기본 프로그램이어야 함) 단일 실행 파일을 작성해야합니다 ( &lt;code&gt;-x&lt;/code&gt; 스위치 로 인해).</target>
        </trans-unit>
        <trans-unit id="62aa426b6c1dd7fc0f65bbcf081d3edc2a27e34a" translate="yes" xml:space="preserve">
          <source>This document is intended to serve as a full-function reference and user&amp;rsquo;s guide suitable for both those readers learning COBOL for the first time as usage as a training tool, as well as those already familiar with some dialect of the COBOL language.</source>
          <target state="translated">이 문서는 COBOL 언어의 일부 방언에 이미 익숙한 사람뿐만 아니라 교육 도구로 처음으로 COBOL을 배우는 독자 모두에게 적합한 전체 기능 참조 및 사용자 안내서 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="8320ed07ae225bb4c27370ae109fe71dbc4c523a" translate="yes" xml:space="preserve">
          <source>This editing symbol is most-frequently used to format dates, as follows:</source>
          <target state="translated">이 편집 기호는 다음과 같이 날짜를 형식화하는 데 가장 자주 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="17495e64e87cb35eec0c33d27079dc582028d95a" translate="yes" xml:space="preserve">
          <source>This environment variable provides an additional means of specifying where copybooks may be found by the compiler (see also COB_COPY_DIR, above).</source>
          <target state="translated">이 환경 변수는 컴파일러가 카피 북을 찾을 수있는 위치를 지정하는 추가 수단을 제공합니다 (위의 COB_COPY_DIR 참조).</target>
        </trans-unit>
        <trans-unit id="b8253752b150482cf6ad5cdb0b758ad6fca3b008" translate="yes" xml:space="preserve">
          <source>This example displays&lt;code&gt;2014/02/07&lt;/code&gt;</source>
          <target state="translated">이 예는 &lt;code&gt;2014/02/07&lt;/code&gt; 을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="3b4de826b82e4d400a3b614ee31ad3629693d377" translate="yes" xml:space="preserve">
          <source>This figurative constant has a value of numeric 0 (zero).&lt;code&gt;ZEROS&lt;/code&gt;and&lt;code&gt;ZEROES&lt;/code&gt;are both synonyms of&lt;code&gt;ZERO&lt;/code&gt;</source>
          <target state="translated">이 형상 상수는 숫자 0 값을 갖습니다. &lt;code&gt;ZEROS&lt;/code&gt; 와 &lt;code&gt;ZEROES&lt;/code&gt; 는 모두 &lt;code&gt;ZERO&lt;/code&gt; 의 동의어입니다</target>
        </trans-unit>
        <trans-unit id="eff4c7fb0c7fa4f780be5a10c77c977502f0c8b3" translate="yes" xml:space="preserve">
          <source>This figurative constant has a value of one or more double-quote characters (&quot;).&lt;code&gt;QUOTES&lt;/code&gt;is a synonym of&lt;code&gt;QUOTE&lt;/code&gt;</source>
          <target state="translated">이 형상 상수는 하나 이상의 큰 따옴표 문자 ( &quot;)의 값을 갖습니다. &lt;code&gt;QUOTES&lt;/code&gt; 는 &lt;code&gt;QUOTE&lt;/code&gt; 의 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="4ddb532bf5d34fb1734bf09306b736d1cd53d9de" translate="yes" xml:space="preserve">
          <source>This figurative constant has a value of one or more of whatever character occupies the highest position in the program&amp;rsquo;s collating sequence as defined in the&lt;code&gt;OBJECT-COMPUTER&lt;/code&gt;paragraph or &amp;mdash; if no such specification was made &amp;mdash; in whatever default character set the program is using (typically, this is the ASCII character set).&lt;code&gt;HIGH-VALUES&lt;/code&gt;is a synonym of&lt;code&gt;HIGH-VALUE&lt;/code&gt;</source>
          <target state="translated">이 형상 상수는 &lt;code&gt;OBJECT-COMPUTER&lt;/code&gt; 단락에 정의 된대로 또는 프로그램이 사용하는 기본 문자 세트 (일반적으로 프로그램이 지정하지 않은 경우) 에서 프로그램의 조합 순서에서 가장 높은 위치를 차지하는 문자 중 하나 이상의 값을 갖 습니다 (일반적으로 , 이것은 ASCII 문자 세트입니다). &lt;code&gt;HIGH-VALUES&lt;/code&gt; 는 &lt;code&gt;HIGH-VALUE&lt;/code&gt; 의 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="250f27c81b4f472dd34104c1c993c391cc93f710" translate="yes" xml:space="preserve">
          <source>This figurative constant has a value of one or more of whatever character occupies the lowest position in the program&amp;rsquo;s collating sequence as defined in the&lt;code&gt;OBJECT-COMPUTER&lt;/code&gt;(see &lt;a href=&quot;#OBJECT_002dCOMPUTER&quot;&gt;OBJECT-COMPUTER&lt;/a&gt;) paragraph or &amp;mdash; if no such specification was made &amp;mdash; in whatever default character set the program is using (typically, this is the ASCII character set).&lt;code&gt;LOW-VALUES&lt;/code&gt;is a synonym of&lt;code&gt;LOW-VALUE&lt;/code&gt;</source>
          <target state="translated">이 형상 상수는 &lt;code&gt;OBJECT-COMPUTER&lt;/code&gt; ( &lt;a href=&quot;#OBJECT_002dCOMPUTER&quot;&gt;OBJECT-COMPUTER&lt;/a&gt; 참조 ) 단락에 정의 된대로 또는 프로그램의 조합 순서에서 가장 낮은 위치를 차지하는 문자 중 하나 이상의 값을 갖습니다 ( 또는 기본 문자 세트가 아닌 경우). 프로그램이 사용 중입니다 (일반적으로 ASCII 문자 세트 임). &lt;code&gt;LOW-VALUES&lt;/code&gt; 는 &lt;code&gt;LOW-VALUE&lt;/code&gt; 의 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="8e2d457e5068c7c2013fd78d9c2da096be86e08e" translate="yes" xml:space="preserve">
          <source>This figurative constant has a value of one or more space characters.&lt;code&gt;SPACES&lt;/code&gt;is a synonym of&lt;code&gt;SPACE&lt;/code&gt;</source>
          <target state="translated">이 형상 상수는 하나 이상의 공백 문자 값을 갖습니다. &lt;code&gt;SPACES&lt;/code&gt; 는 &lt;code&gt;SPACE&lt;/code&gt; 의 동의어입니다</target>
        </trans-unit>
        <trans-unit id="0e6ec9ef62cfa272a163b28376feb88550e88820" translate="yes" xml:space="preserve">
          <source>This file organization was defined to accommodate either sequential or random processing. With a&lt;code&gt;RELATIVE&lt;/code&gt;file, it is possible to read or write record 100 directly, without having to have first read or written records 1-99. The GnuCOBOL runtime system uses the program-defined maximum record size to calculate a relative byte position in the file where the record header and data begin, and then transfers the necessary data to or from the program.</source>
          <target state="translated">이 파일 구성은 순차적 또는 무작위 처리를 수용하도록 정의되었습니다. &lt;code&gt;RELATIVE&lt;/code&gt; 파일을 사용하면 레코드를 처음 읽거나 쓸 필요없이 레코드 100을 직접 읽거나 쓸 수 있습니다. GnuCOBOL 런타임 시스템은 프로그램 정의 최대 레코드 크기를 사용하여 레코드 헤더 및 데이터가 시작되는 파일에서 상대 바이트 위치를 계산 한 다음 필요한 데이터를 프로그램과주고받습니다.</target>
        </trans-unit>
        <trans-unit id="840a8a261537d658d16c4fa88f4a6883a4b2aba9" translate="yes" xml:space="preserve">
          <source>This first set of picture symbols defines the basic data type of a data item. Each symbol represents a single character&amp;rsquo;s worth of storage.</source>
          <target state="translated">이 첫 번째 그림 심볼 세트는 데이터 항목의 기본 데이터 유형을 정의합니다. 각 기호는 단일 문자의 저장 용량을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="06433910bd68203fa8e17c3c9d62a80e6271e0fd" translate="yes" xml:space="preserve">
          <source>This format of the&lt;code&gt;ACCEPT&lt;/code&gt;statement will be terminated by any of the following events:</source>
          <target state="translated">&lt;code&gt;ACCEPT&lt;/code&gt; 문의이 형식은 다음 이벤트 중 하나로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="1aa88821f5b12f956a3679153d9a166397c02c7d" translate="yes" xml:space="preserve">
          <source>This format of the&lt;code&gt;VALUE&lt;/code&gt;clause may not be used anywhere in the description of an 01 item (or any of it&amp;rsquo;s subordinate items) serving as an&lt;code&gt;FD&lt;/code&gt;or&lt;code&gt;SD&lt;/code&gt;record description.</source>
          <target state="translated">이 &lt;code&gt;VALUE&lt;/code&gt; 절 형식은 &lt;code&gt;FD&lt;/code&gt; 또는 &lt;code&gt;SD&lt;/code&gt; 레코드 설명 으로 사용되는 01 항목 (또는 그 하위 항목)에 대한 설명의 어느 곳에서도 사용될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="6e4ad0b9c835982248cbc79b9da86c524e736b96" translate="yes" xml:space="preserve">
          <source>This hierarchical structure of program components standardizes the composition of all COBOL programs. Much of this manual describes the various divisions, sections, paragraphs and statements that may comprise any COBOL program.</source>
          <target state="translated">프로그램 구성 요소의이 계층 구조는 모든 COBOL 프로그램의 구성을 표준화합니다. 이 매뉴얼의 대부분은 COBOL 프로그램을 구성 할 수있는 다양한 부서, 섹션, 단락 및 명령문을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6ae4bfbfc916d521c80d00746025a60a711f94c7" translate="yes" xml:space="preserve">
          <source>This intrinsic function is identical to the&lt;code&gt;BYTE-LENGTH&lt;/code&gt;(see &lt;a href=&quot;#BYTE_002dLENGTH&quot;&gt;BYTE-LENGTH&lt;/a&gt;) function.</source>
          <target state="translated">이 내장 함수는 &lt;code&gt;BYTE-LENGTH&lt;/code&gt; ( &lt;a href=&quot;#BYTE_002dLENGTH&quot;&gt;BYTE-LENGTH&lt;/a&gt; 참조 ) 함수와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7f85265828c6d0641a9e58aeb39fcf33cdddf170" translate="yes" xml:space="preserve">
          <source>This is a much simpler and more readable means of setting environment variables than by using the&lt;code&gt;DISPLAY UPON ENVIRONMENT-NAME&lt;/code&gt;statement (see &lt;a href=&quot;#DISPLAY-UPON-ENVIRONMENT_002dNAME&quot;&gt;DISPLAY UPON ENVIRONMENT-NAME&lt;/a&gt;). For example, these two code sequences produce identical results:</source>
          <target state="translated">이는 &lt;code&gt;DISPLAY UPON ENVIRONMENT-NAME&lt;/code&gt; 문 을 사용하는 것보다 환경 변수를 설정하는 훨씬 간단하고 읽기 쉬운 방법입니다 ( &lt;a href=&quot;#DISPLAY-UPON-ENVIRONMENT_002dNAME&quot;&gt;DISPLAY UPON ENVIRONMENT-NAME 참조&lt;/a&gt; ). 예를 들어,이 두 코드 시퀀스는 동일한 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="965f34faa5c50ed88f8280125ce952da010c9357" translate="yes" xml:space="preserve">
          <source>This is a single subprogram compiled into object-code form, ready to be linked in with a main program to form a directly-executable program. On windows computers, these generally are &quot;.o&quot; (object-code) files.</source>
          <target state="translated">이것은 직접 실행 가능한 프로그램을 형성하기 위해 주 프로그램과 연결될 준비가 된 객체 코드 형식으로 컴파일 된 단일 서브 프로그램입니다. Windows 컴퓨터에서 이러한 파일은 일반적으로 &quot;.o&quot;(개체 코드) 파일입니다.</target>
        </trans-unit>
        <trans-unit id="5680105b6f3bc691199fb9367470b0460d669e4d" translate="yes" xml:space="preserve">
          <source>This is an executable file directly-executable from the command-line. On Windows computers, this would be an &quot;.exe&quot; file. On Unix systems, this will be a file with no specific extension, but with execute permissions. This file will include the main program as well as any static-linked subprograms.</source>
          <target state="translated">이 파일은 명령 줄에서 직접 실행 가능한 파일입니다. Windows 컴퓨터에서이 파일은 &quot;.exe&quot;파일입니다. Unix 시스템에서이 파일은 특정 확장자가 없지만 실행 권한이있는 파일입니다. 이 파일에는 메인 프로그램과 정적 링크 서브 프로그램이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d7627abdc45a56d26b37ce7bfb991f3d894a199a" translate="yes" xml:space="preserve">
          <source>This is another obsolete area of COBOL statements. This part of every statement also hails back to the day when programs were punched on cards; it was expected that the name of the program (or at least the first 8 characters of it) would be punched here so that &amp;mdash; if a dropped COBOL source deck contained more than one program &amp;mdash; that handy card sorter machine could be used to first separate the cards by program name and then sort them by sequence number. Today&amp;rsquo;s COBOL compilers (including GnuCOBOL) simply ignore anything past column 72.</source>
          <target state="translated">이것은 COBOL 문의 또 다른 쓸모없는 영역입니다. 모든 성명서의이 부분은 또한 프로그램이 카드에 구멍을 뚫었 던 날로 거슬러 올라갑니다. 삭제 된 COBOL 소스 데크에 둘 이상의 프로그램이 포함 된 경우 편리한 카드 분류기 시스템을 사용하여 먼저 분리 할 수 ​​있도록 프로그램 이름 (또는 적어도 첫 8 자)이 여기에 입력됩니다. 프로그램 이름으로 카드를 찾은 다음 순서 번호로 정렬하십시오. 오늘날의 COBOL 컴파일러 (GnuCOBOL 포함)는 72 열 이상을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="b8262b1a5e28afc8573713c3447ed8c76aba1a44" translate="yes" xml:space="preserve">
          <source>This is not the only mechanism that a subprogram may use to pass a value back to it&amp;rsquo;s caller. Other possibilities are:</source>
          <target state="translated">이것은 서브 프로그램이 값을 호출자에게 다시 전달하는 데 사용할 수있는 유일한 메커니즘은 아닙니다. 다른 가능성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b0c4ce68e7b56a1a96125757a3df8b43b56c8e47" translate="yes" xml:space="preserve">
          <source>This is the (screen-mode) display of the PC or Unix system.</source>
          <target state="translated">PC 또는 Unix 시스템의 (화면 모드) 표시입니다.</target>
        </trans-unit>
        <trans-unit id="1c99be849f118744e6bc3598b57888aaeafa0726" translate="yes" xml:space="preserve">
          <source>This is the most advanced file structure available to GnuCOBOL programs. It&amp;rsquo;s not possible to describe the physical structure of such files because that structure will vary depending upon which advanced file-management facility was included into the GnuCOBOL build you will be using (Berkeley Database [BDB], VBISAM, etc.). We will &amp;mdash; instead &amp;mdash; discuss the logical structure of the file.</source>
          <target state="translated">이것은 GnuCOBOL 프로그램에서 사용할 수있는 가장 고급 파일 구조입니다. 이러한 파일의 실제 구조는 설명 할 수 없습니다. 그 구조는 사용할 GnuCOBOL 빌드 (Berkeley Database [BDB], VBISAM 등)에 포함 된 고급 파일 관리 기능에 따라 달라지기 때문입니다. 대신 파일의 논리적 구조에 대해 논의 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="1badc8f9153de01fee0f789d4e536e5dd8ad0bcb" translate="yes" xml:space="preserve">
          <source>This is the only&lt;code&gt;ORGANIZATION&lt;/code&gt;valid for files that are assigned to the&lt;code&gt;PRINTER&lt;/code&gt;device.</source>
          <target state="translated">이것은 &lt;code&gt;PRINTER&lt;/code&gt; 장치에 지정된 파일에 유효한 유일한 &lt;code&gt;ORGANIZATION&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e87ba303b6d6b0090a8938a64057d6464229206f" translate="yes" xml:space="preserve">
          <source>This is the point where an example should really help you see this at work. Observe the following code which defines a two-dimensional (3 row by 4 column) table and a pair of numeric data items to be used to subscript references to each element of the table:</source>
          <target state="translated">이것이 실제로 직장에서이를 이해하는 데 도움이되는 예제입니다. 2 차원 (3 행 x 4 열) 테이블 및 테이블의 각 요소에 대한 참조를 첨자 화하는 데 사용되는 숫자 데이터 항목 쌍을 정의하는 다음 코드를 준수하십시오.</target>
        </trans-unit>
        <trans-unit id="c57172b3dcf74c1dd7032cbb7c95160d130130fd" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t a bad practice to use in actual programs, as it leads to programs where it is much easier to distinguish reserved words from user-defined ones!</source>
          <target state="translated">예약 된 단어와 사용자 정의 단어를 훨씬 쉽게 구별 할 수있는 프로그램으로 연결되므로 실제 프로그램에서 사용하는 것은 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e108411a0a4862fc264b807343e4da89ba19833" translate="yes" xml:space="preserve">
          <source>This last example shows the final modification to the previous examples by using an in-line&lt;code&gt;PERFORM&lt;/code&gt;along with&lt;code&gt;EXIT PERFORM&lt;/code&gt;and&lt;code&gt;EXIT PERFORM CYCLE&lt;/code&gt;statements:</source>
          <target state="translated">이 마지막 예는 &lt;code&gt;EXIT PERFORM&lt;/code&gt; 및 &lt;code&gt;EXIT PERFORM CYCLE&lt;/code&gt; 문과 함께 인라인 &lt;code&gt;PERFORM&lt;/code&gt; 을 사용하여 이전 예제에 대한 최종 수정을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="e52c0929a3aa85fb8f3d6752206dc0813989fbad" translate="yes" xml:space="preserve">
          <source>This new facility made the period almost obsolete, as our program segment would probably be coded like this today:</source>
          <target state="translated">이 새로운 시설은 프로그램 세그먼트가 오늘날 다음과 같이 코딩 될 것이므로이 기간을 거의 쓸모 없게 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="097ce2b00098ac8b676b39bc452dc9f76d3d46ec" translate="yes" xml:space="preserve">
          <source>This option allows one or more data items within one group item (&amp;lt;</source>
          <target state="translated">이 옵션은 하나의 그룹 항목 내에서 하나 이상의 데이터 항목을 허용합니다 (&amp;lt;</target>
        </trans-unit>
        <trans-unit id="0be9b068c85cf244a501012a5f0311e7d9c5859e" translate="yes" xml:space="preserve">
          <source>This option cannot be used to replace part of a word, identifier or literal.</source>
          <target state="translated">이 옵션은 단어, 식별자 또는 리터럴의 일부를 대체하는 데 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e72cecdabad359ae3ce9d6f163cd2b83b745fa5e" translate="yes" xml:space="preserve">
          <source>This option informs GnuCOBOL that the program is willing to wait for a lock held (by another program) on the record being read to be released.</source>
          <target state="translated">이 옵션은 GnuCOBOL에 프로그램이 읽고있는 레코드의 잠금이 해제 될 때까지 기꺼이 기다릴 것을 알립니다.</target>
        </trans-unit>
        <trans-unit id="db42c9b200625f22e61e944cdd7ea647d1596001" translate="yes" xml:space="preserve">
          <source>This option signifies that the 01-level data item in whose declaration&lt;code&gt;CONSTANT&lt;/code&gt;is specified will be treated as a symbolic name for a literal value, usable wherever a literal of the appropriate type could be used.</source>
          <target state="translated">이 옵션 은 &lt;code&gt;CONSTANT&lt;/code&gt; 선언 이 지정된 01 레벨 데이터 항목 이 적절한 유형의 리터럴을 사용할 수있는 모든 곳에서 사용할 수있는 리터럴 값의 기호 이름으로 취급 됨을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="e9df6ef8811d8e705e95d7406018d9d95cf22bf3" translate="yes" xml:space="preserve">
          <source>This optional clause optimizes the storage of binary numeric items to store them in such a manner as to make it as fast as possible for the CPU to fetch them.</source>
          <target state="translated">이 선택적 절은 이진 숫자 항목의 저장을 최적화하여 CPU가 가능한 빨리 항목을 가져 오는 방식으로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="f04295a5103c51cf4fbd0f627d898649399e3417" translate="yes" xml:space="preserve">
          <source>This page structure &amp;mdash; once defined &amp;mdash; can be automatically enforced by the&lt;code&gt;WRITE&lt;/code&gt;statement (see &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt;).</source>
          <target state="translated">이 페이지 구조는 일단 정의되면 &lt;code&gt;WRITE&lt;/code&gt; 문에 의해 자동으로 시행 될 수 있습니다 ( &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="664e97f85696614d2b39afe1b09419859db59715" translate="yes" xml:space="preserve">
          <source>This paragraph is not allowed in a nested subprogram &amp;mdash; nested programs will inherit the&lt;code&gt;SOURCE-COMPUTER&lt;/code&gt;settings of their parent program.</source>
          <target state="translated">중첩 된 서브 프로그램에서는이 단락을 사용할 수 없습니다. 중첩 된 프로그램은 상위 프로그램 의 &lt;code&gt;SOURCE-COMPUTER&lt;/code&gt; 설정을 상속합니다 .</target>
        </trans-unit>
        <trans-unit id="572e6cd49a11ec0337e2c33c0458f740e184c5a3" translate="yes" xml:space="preserve">
          <source>This particular type of constant declaration provides the ability to determine the length of a data item or the storage size associated with a particular numeric&lt;code&gt;USAGE&lt;/code&gt;(see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) type &amp;mdash; something not possible with the other types of constants.</source>
          <target state="translated">이 특정 유형의 상수 선언은 다른 숫자 유형의 상수로는 불가능한 특정 숫자 &lt;code&gt;USAGE&lt;/code&gt; ( &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt; 참조 ) 유형 과 연관된 데이터 항목의 길이 또는 스토리지 크기를 판별하는 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="380cda3c2cb0c5e08e0112c45703dbc42112d001" translate="yes" xml:space="preserve">
          <source>This register will be set to a value of 1 when an&lt;code&gt;INITIATE&lt;/code&gt;statement (see &lt;a href=&quot;#INITIATE&quot;&gt;INITIATE&lt;/a&gt;) is executed for the report and will be incremented by 1 each time the RWCS starts a new page of the report.</source>
          <target state="translated">이 레지스터는 보고서에 대해 &lt;code&gt;INITIATE&lt;/code&gt; 문 ( &lt;a href=&quot;#INITIATE&quot;&gt;INITIATE&lt;/a&gt; 참조 )이 실행될 때 값 1로 설정되며 RWCS가 보고서의 새 페이지를 시작할 때마다 1 씩 증가합니다.</target>
        </trans-unit>
        <trans-unit id="ec166f97c7c660a59320c4bf094cc9e8f3c5eac6" translate="yes" xml:space="preserve">
          <source>This routine is non-functional in GnuCOBOL. It exists only to provide compatibility for applications that may have been developed for Micro Focus COBOL.</source>
          <target state="translated">이 루틴은 GnuCOBOL에서 작동하지 않습니다. Micro Focus COBOL 용으로 개발 된 응용 프로그램에 대한 호환성을 제공하기 위해서만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="69314e9d5c7b4fcb83b44f2cf02d99c206a321ae" translate="yes" xml:space="preserve">
          <source>This section contains an example of the RWCS at work. The complete program, presented here, is a stripped-down version of a program I have used to generate a report for a class I teach on PC hardware. This report will provide benchmark statistics on a variety of popular AMD and Intel CPUs. The data for the report was obtained from the website &lt;a href=&quot;https://open-cobol.sourceforge.io/HTML/www.cpubenchmark.net&quot;&gt;www.cpubenchmark.net&lt;/a&gt; in December of 2013. By the time you are reading this, that data will most likely have become rather out-of-date, but it illustrates RWCS well enough.</source>
          <target state="translated">이 섹션에는 작업중인 RWCS의 예가 포함되어 있습니다. 여기에 제시된 전체 프로그램은 내가 PC 하드웨어에서 가르치는 수업에 대한 보고서를 생성하는 데 사용한 프로그램의 제거 된 버전입니다. 이 보고서는 널리 사용되는 다양한 AMD 및 Intel CPU에 대한 벤치 마크 통계를 제공합니다. 보고서의 데이터 는 2013 년 12 월 웹 사이트 &lt;a href=&quot;https://open-cobol.sourceforge.io/HTML/www.cpubenchmark.net&quot;&gt;www.cpubenchmark.net&lt;/a&gt; 에서 입수 했습니다.이 자료를 읽을 때 그 데이터는 최신 정보가 아닐 수 있지만 RWCS를 충분히 잘 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a9cbd937f57f1157f89f77ae950fb22111f0e16f" translate="yes" xml:space="preserve">
          <source>This sequence of control breaks from least- to most-frequent (in other words, in the order they occur on the CONTROLS ARE clause) is the &amp;rsquo;</source>
          <target state="translated">이 제어 순서는 가장 빈번하지 않은 빈도에서 가장 빈번한 것으로 (즉, CONTROLS ARE 절에서 발생하는 순서대로) '</target>
        </trans-unit>
        <trans-unit id="588642384df92049d1c499945e68a2db6b48b278" translate="yes" xml:space="preserve">
          <source>This sort of problem led to a band-aid solution &amp;mdash; the&lt;code&gt;NEXT SENTENCE&lt;/code&gt;</source>
          <target state="translated">이런 종류의 문제는 반창고 해결책, 즉 &lt;code&gt;NEXT SENTENCE&lt;/code&gt; 이어졌습니다.</target>
        </trans-unit>
        <trans-unit id="ae9f40e2192fc4bc15bea7604753d25049a362aa" translate="yes" xml:space="preserve">
          <source>This statement (perhaps in combination with an appropriate comment or two) makes a convenient &quot;place holder&quot; &amp;mdash; particularly in&lt;code&gt;ELSE&lt;/code&gt;(see &lt;a href=&quot;#IF&quot;&gt;IF&lt;/a&gt;) or&lt;code&gt;WHEN&lt;/code&gt;(see &lt;a href=&quot;#EVALUATE&quot;&gt;EVALUATE&lt;/a&gt;) clauses where no code is currently expected to be needed, but a place for code to handle the conditions in question is to be reserved in case it&amp;rsquo;s ever needed.</source>
          <target state="translated">이 문장 (아마도 적절한 의견 또는 2 개와 함께)은 편리한 &quot;자리 표시 자&quot;를 만듭니다. 특히 코드가 필요하지 않은 &lt;code&gt;ELSE&lt;/code&gt; ( &lt;a href=&quot;#IF&quot;&gt;IF&lt;/a&gt; 참조 ) 또는 &lt;code&gt;WHEN&lt;/code&gt; ( &lt;a href=&quot;#EVALUATE&quot;&gt;EVLUATE&lt;/a&gt; 참조 ) 절에서 코드를위한 장소입니다. 문제가되는 조건을 처리하기 위해 필요한 경우를 대비하여 예약해야합니다.</target>
        </trans-unit>
        <trans-unit id="3559a4ff64551030c8f57e78a309f05d1dddf1bf" translate="yes" xml:space="preserve">
          <source>This statement exists within GnuCOBOL to provide compatibility with COBOL programs written to pre-1985 standards. The&lt;code&gt;TRANSFORM&lt;/code&gt;statement was made obsolete in the 1985 standard of COBOL, having been replaced by the&lt;code&gt;CONVERTING&lt;/code&gt;clause of the&lt;code&gt;INSPECT&lt;/code&gt;statement (see &lt;a href=&quot;#INSPECT&quot;&gt;INSPECT&lt;/a&gt;). New programs should be coded to use&lt;code&gt;INSPECT CONVERTING&lt;/code&gt;rather than&lt;code&gt;TRANSFORM&lt;/code&gt;</source>
          <target state="translated">이 진술은 GnuCOBOL 내에 있으며 1985 년 이전 표준으로 작성된 COBOL 프로그램과의 호환성을 제공합니다. &lt;code&gt;TRANSFORM&lt;/code&gt; 문으로 대체 된, COBOL의 1985 년 표준에서 필요 없게 된 &lt;code&gt;CONVERTING&lt;/code&gt; 의 절 &lt;code&gt;INSPECT&lt;/code&gt; (참조 문 &lt;a href=&quot;#INSPECT&quot;&gt;INSPECT&lt;/a&gt; ). &lt;code&gt;TRANSFORM&lt;/code&gt; 대신 &lt;code&gt;INSPECT CONVERTING&lt;/code&gt; 을 사용하도록 새 프로그램을 코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="c23cadc6d5b15a7778e9fe6e8aa080b1a7f685cc" translate="yes" xml:space="preserve">
          <source>This statement is valid only within the&lt;code&gt;INPUT PROCEDURE&lt;/code&gt;of a file-based&lt;code&gt;SORT&lt;/code&gt;statement (see &lt;a href=&quot;#File_002dBased-SORT&quot;&gt;File-Based SORT&lt;/a&gt;).</source>
          <target state="translated">이 명령문은 파일 기반 &lt;code&gt;SORT&lt;/code&gt; 문의 &lt;code&gt;INPUT PROCEDURE&lt;/code&gt; 내에서만 유효 합니다 ( &lt;a href=&quot;#File_002dBased-SORT&quot;&gt;파일 기반 SORT&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e0839e84b61963a0bb33e0ce15e20f8f99ab941d" translate="yes" xml:space="preserve">
          <source>This statement may not be used with&lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;ORGANIZATION LINE SEQUENTIAL&lt;/a&gt;) files.</source>
          <target state="translated">이 명령문은 &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; ( &lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;ORGANIZATION LINE SEQUENTIAL&lt;/a&gt; 참조 ) 파일 과 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="37a2705ee9acf17d9e4ab38895f20b30d7a43d92" translate="yes" xml:space="preserve">
          <source>This statement may only appear within a&lt;code&gt;USE BEFORE REPORTING&lt;/code&gt;procedure (in&lt;code&gt;DECLARATIVES&lt;/code&gt;(see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;)).</source>
          <target state="translated">이 문은 단지 내에서 나타날 수 있습니다 &lt;code&gt;USE BEFORE REPORTING&lt;/code&gt; 절차 (에 &lt;code&gt;DECLARATIVES&lt;/code&gt; (참조 &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt; )).</target>
        </trans-unit>
        <trans-unit id="a955379ee2366ba5c7be7f48dc2c70763b07bee4" translate="yes" xml:space="preserve">
          <source>This statement must be executed each time presentation of the report group is to be suppressed.</source>
          <target state="translated">이 명령문은 보고서 그룹의 표시가 억제 될 때마다 실행되어야합니다.</target>
        </trans-unit>
        <trans-unit id="6cd687270e9ef8d38b390cf5f1448793eb71cedd" translate="yes" xml:space="preserve">
          <source>This statement must be terminated with a period.</source>
          <target state="translated">이 진술은 마침표로 끝나야합니다.</target>
        </trans-unit>
        <trans-unit id="d911ad1e335943100258253cf90b17ef8a82b565" translate="yes" xml:space="preserve">
          <source>This subroutine performs a bit-by-bit comparison between the left-most 8*&amp;lt;</source>
          <target state="translated">이 서브 루틴은 가장 왼쪽 8 ** 사이의 비트 단위 비교를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="46a0de84c7251067379930594eb551e5a4a694e9" translate="yes" xml:space="preserve">
          <source>This subroutine performs a bit-by-bit logical &quot;exclusive or&quot; process between the left-most 8*&amp;lt;</source>
          <target state="translated">이 서브 루틴은 가장 왼쪽의 8 * &amp;lt;</target>
        </trans-unit>
        <trans-unit id="301be21d19fb7adef3f61e04d0a582843ce8fb30" translate="yes" xml:space="preserve">
          <source>This subroutine performs a bit-by-bit logical &quot;implies&quot; process between the left-most 8*&amp;lt;</source>
          <target state="translated">이 서브 루틴은 가장 왼쪽의 8 * &amp;lt;</target>
        </trans-unit>
        <trans-unit id="56ef80fcbaa21047faab80e574ddf8ad0d106f59" translate="yes" xml:space="preserve">
          <source>This subroutine performs a bit-by-bit logical &quot;or&quot; process between the left-most 8*&amp;lt;</source>
          <target state="translated">이 서브 루틴은 가장 왼쪽 8 * 사이의 비트 단위 논리 &quot;또는&quot;프로세스를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1dcd963ff016076262fffdf8eea8455225b09040" translate="yes" xml:space="preserve">
          <source>This subroutine performs a bit-by-bit logical AND operation between the left-most 8*&amp;lt;</source>
          <target state="translated">이 서브 루틴은 가장 왼쪽 8 * 사이에서 비트 단위 논리 AND 연산을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="c5d97efcb0d3ce32f4b292e106bee1aea3f38ee9" translate="yes" xml:space="preserve">
          <source>This subroutine performs the negation of a bit-by-bit logical &quot;implies&quot; process between the left-most 8*&amp;lt;</source>
          <target state="translated">이 서브 루틴은 가장 왼쪽에있는 8 비트 사이의 비트 단위 논리 &quot;암시&quot;프로세스의 부정을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="3fffd964245f95d7d2761ff5901c2950808d5e0b" translate="yes" xml:space="preserve">
          <source>This subroutine performs the negation of a bit-by-bit logical &quot;or&quot; process between the left-most 8*&amp;lt;</source>
          <target state="translated">이 서브 루틴은 가장 왼쪽에있는 8 비트 사이의 비트 단위 논리 &quot;또는&quot;프로세스의 부정을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="15b1c27985b5128d5143355de8813140ef314408" translate="yes" xml:space="preserve">
          <source>This symbol is coded as the two characters &quot;C&quot; and &quot;R&quot;. If the value of the numeric value moved into the field is positive (0 or greater), two spaces will be inserted. If the value is negative (less than 0), the characters &quot;CR&quot; (credit) are inserted.</source>
          <target state="translated">이 기호는 두 문자 &quot;C&quot;와 &quot;R&quot;로 코딩됩니다. 필드로 이동 한 숫자 값이 양수 (0 이상)이면 두 개의 공백이 삽입됩니다. 값이 음수 (0 미만)이면 문자 &quot;CR&quot;(신용)이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="f90d4820eb2055d0657b65e260b67d07e03b2996" translate="yes" xml:space="preserve">
          <source>This symbol is coded as the two characters &quot;D&quot; and &quot;B&quot;. If the value of the numeric value moved into the field is positive (0 or greater), two spaces will be inserted. If the value is negative (less than 0), the characters &quot;DB&quot; (debit) are inserted.</source>
          <target state="translated">이 기호는 두 문자 &quot;D&quot;와 &quot;B&quot;로 코딩됩니다. 필드로 이동 한 숫자 값이 양수 (0 이상)이면 두 개의 공백이 삽입됩니다. 값이 음수 (0 미만)이면 문자 &quot;DB&quot;(debit)가 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="0ae4256c1781bf78d5b6b91a0aa6f1695a16a43a" translate="yes" xml:space="preserve">
          <source>This symbol is referred to as a check protection symbol. All check-protection symbols that correspond to character positions in which leading zeros reside will have their &quot;0&quot; values replaced by &quot;*&quot;.</source>
          <target state="translated">이 기호를 점검 보호 기호라고합니다. 선행 0이있는 문자 위치에 해당하는 모든 검사 방지 기호는 &quot;0&quot;값이 &quot;*&quot;로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="bee1dfdaab5db7ed53f90d4626da74943bc544e4" translate="yes" xml:space="preserve">
          <source>This symbol is used to define where an implied decimal-point (if any) is located in a numeric item. Just as there may only be a single decimal point in a number so may there be no more than one&lt;code&gt;V&lt;/code&gt;in a&lt;code&gt;PICTURE&lt;/code&gt; Implied decimal points occupy no space in storage &amp;mdash; they just specify how values are used. For example, if the value&lt;code&gt;1234&lt;/code&gt;is in storage in a field defined as PIC 999V9, that value would be treated as 123.4 in any statements that referenced it.</source>
          <target state="translated">이 기호는 숫자 항목에서 암시 적 소수점 (있는 경우)이있는 위치를 정의하는 데 사용됩니다. 단지 숫자에 하나의 소수점이있을 수 있습니다 것처럼 지금이 더 이상보다하지 않을 수 &lt;code&gt;V&lt;/code&gt; A의 &lt;code&gt;PICTURE&lt;/code&gt; 그들은 단지 값이 사용되는 방법을 지정 - 묵시적 소수점 포인트 저장에는 공간을 차지하지 않습니다. 예를 들어, 값 &lt;code&gt;1234&lt;/code&gt; 가 PIC 999V9로 정의 된 필드에 저장되어 있으면 해당 값은이를 참조하는 모든 명령문에서 123.4로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="596e3ec17997e0feab3c9f8d7bbd0c1cecabea7c" translate="yes" xml:space="preserve">
          <source>This symbol, if used, must be the very first symbol in the&lt;code&gt;PICTURE&lt;/code&gt;value. A&lt;code&gt;S&lt;/code&gt;indicates that the data item is&lt;code&gt;Signed&lt;/code&gt; meaning that negative values are possible for this data item. Without an&lt;code&gt;S&lt;/code&gt; any negative values stored into this data item via a&lt;code&gt;MOVE&lt;/code&gt;or arithmetic statement will have the negative sign stripped from it (in effect becoming the absolute value).</source>
          <target state="translated">이 기호가 사용되는 경우 &lt;code&gt;PICTURE&lt;/code&gt; 값 에서 첫 번째 기호 여야합니다 . &lt;code&gt;S&lt;/code&gt; 는 데이터 항목임을 나타낸다 &lt;code&gt;Signed&lt;/code&gt; 음의 값이 데이터 항목이 가능하다는 것을 의미한다. &lt;code&gt;S&lt;/code&gt; 가 없으면 &lt;code&gt;MOVE&lt;/code&gt; 또는 산술 문 을 통해이 데이터 항목에 저장된 음수 값이 음수 부호에서 제거됩니다 (실제로 절대 값이 됨).</target>
        </trans-unit>
        <trans-unit id="73d0f5b806c9a49bd3884db8a429022edd6c25fe" translate="yes" xml:space="preserve">
          <source>This syntax is valid in the following sections:</source>
          <target state="translated">이 구문은 다음 섹션에서 유효합니다.</target>
        </trans-unit>
        <trans-unit id="ef37ebe9fe805ece3a4a5b43a5e1e81c2d9bc1d4" translate="yes" xml:space="preserve">
          <source>This system routine is not available on Windows (exception: GCC on Cygwin).</source>
          <target state="translated">이 시스템 루틴은 Windows에서 사용할 수 없습니다 (예외 : Cygwin의 GCC).</target>
        </trans-unit>
        <trans-unit id="8536330e4cbe7398834d5b82e00b926f3a57770f" translate="yes" xml:space="preserve">
          <source>This technique of using columns 1-6 as a change indicator will ONLY work if fixed source-record format is in effect.</source>
          <target state="translated">1-6 행을 변경 표시기로 사용하는이 기술은 고정 소스 레코드 형식이 유효한 경우에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="bc453ccccb3790caac1b485f31289e6eafde3f70" translate="yes" xml:space="preserve">
          <source>This too is a video feature that is dependent upon the &quot;curses&quot; package built into your version of GnuCOBOL. If blinking is enabled in that package, text displayed in fields defined in the screen section as being blinking will endlessly cycle between the brightest possible setting (highlight) and an &quot;invisible&quot; setting where the text color matches that of the field background color. A Windows build, which generally uses the &quot;pcurses&quot; package, will uses a brighter-than-normal background color to signify &quot;blinking&quot;.</source>
          <target state="translated">이것은 또한 GnuCOBOL 버전에 내장 된 &quot;저주&quot;패키지에 의존하는 비디오 기능입니다. 해당 패키지에서 깜박임이 활성화 된 경우 화면 섹션에 정의 된 필드에 깜박이는 것으로 표시되는 텍스트는 가능한 가장 밝은 설정 (강조 표시)과 텍스트 색상이 필드 배경색과 일치하는 &quot;보이지 않는&quot;설정 사이에서 끝없이 순환합니다. 일반적으로 &quot;pcurses&quot;패키지를 사용하는 Windows 빌드는 &quot;깜박임&quot;을 나타 내기 위해 보통보다 밝은 배경색을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e1fbac529f8f95a034dc9c827c1cbafb5a9d2d97" translate="yes" xml:space="preserve">
          <source>This usage of the&lt;code&gt;EXIT&lt;/code&gt;statement simply provides a common &quot;GO TO&quot; end point for a series of procedures, as may be seen in the following example:</source>
          <target state="translated">&lt;code&gt;EXIT&lt;/code&gt; 문의 이러한 사용법은 다음 예제에서 볼 수 있듯이 일련의 프로 시저에 대한 일반적인 &quot;GO TO&quot;엔드 포인트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f451787942f8e48147358c429db550a285886065" translate="yes" xml:space="preserve">
          <source>This video attribute simply swaps the foreground and background colors and display options.</source>
          <target state="translated">이 비디오 속성은 단순히 전경색과 배경색 및 표시 옵션을 교체합니다.</target>
        </trans-unit>
        <trans-unit id="a7815b186cb5e02b42c5fca6e64c4779155fa889" translate="yes" xml:space="preserve">
          <source>This will allocate the following:</source>
          <target state="translated">이것은 다음을 할당합니다 :</target>
        </trans-unit>
        <trans-unit id="50d6ae0d30a3efb7546fe92379ba6f0c6814f00d" translate="yes" xml:space="preserve">
          <source>This would allow references to any of the following:</source>
          <target state="translated">이를 통해 다음 중 하나를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08d73d9393e2045589ad4cc87782d5e3cceefcad" translate="yes" xml:space="preserve">
          <source>Those characters that are deemed printable (as defined by the character set used by &amp;lt;</source>
          <target state="translated">인쇄 가능한 것으로 간주되는 문자 (&amp;lt;</target>
        </trans-unit>
        <trans-unit id="e3bc9b7d801e7bcd2ee90cc6f27b6b26e1d8e9a4" translate="yes" xml:space="preserve">
          <source>Those languages aren&amp;rsquo;t limited to mainframe computers, as COBOL is</source>
          <target state="translated">COBOL과 같은 언어는 메인 프레임 컴퓨터에만 국한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8e3726bd2acc660bebcc4cc17555d32040786e5" translate="yes" xml:space="preserve">
          <source>Those that argue that it is too boring / wasteful / time-consuming / insulting (pick one) to have to code a COBOL program &quot;from scratch&quot; are clearly ignorant of the following facts:</source>
          <target state="translated">COBOL 프로그램을 &quot;처음부터&quot;코딩하기에는 너무 지루하고 낭비 적이며 시간이 많이 걸리고 모욕적이라고 주장하는 사람들은 다음 사실을 분명히 알지 못합니다.</target>
        </trans-unit>
        <trans-unit id="9591373087bdb6fea4b5539eb0dbc0bb9f7ad3a6" translate="yes" xml:space="preserve">
          <source>Through the&lt;code&gt;CALL&lt;/code&gt;statement, COBOL programs may invoke other COBOL programs serving as subprograms. This is quite similar to cross-program linkage capabilities provided by other languages. In GnuCOBOL&amp;rsquo;s case, the&lt;code&gt;CALL&lt;/code&gt;facility is powerful enough to be tailored to the point where a GnuCOBOL program can communicate with operating system, database management and run-time library APIs, even if they weren&amp;rsquo;t written in COBOL themselves. See &lt;a href=&quot;#GnuCOBOL-Main-Programs-CALLing-C-Subprograms&quot;&gt;GnuCOBOL Main Programs CALLing C Subprograms&lt;/a&gt;, for an example of how a GnuCOBOL program could invoke a C-language subprogram, passing information back and forth between the two.</source>
          <target state="translated">&lt;code&gt;CALL&lt;/code&gt; 문을 통해 COBOL 프로그램은 서브 프로그램 역할을하는 다른 COBOL 프로그램을 호출 할 수 있습니다. 이것은 다른 언어에서 제공하는 교차 프로그램 연결 기능과 매우 유사합니다. GnuCOBOL의 경우, &lt;code&gt;CALL&lt;/code&gt; 기능은 GnuCOBOL 프로그램이 COBOL 자체로 작성되지 않았더라도 운영 체제, 데이터베이스 관리 및 런타임 라이브러리 API와 통신 할 수있는 지점에 맞게 조정될 수있을 정도로 강력합니다. GnuCOBOL 프로그램이 C 언어 서브 프로그램을 호출하여 정보를주고받는 방법에 대한 예는 &lt;a href=&quot;#GnuCOBOL-Main-Programs-CALLing-C-Subprograms&quot;&gt;GnuCOBOL 기본 프로그램 C 서브 프로그램 호출을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="815743fdd17d13d11a41a6490909afcf545be8bb" translate="yes" xml:space="preserve">
          <source>Time, including hundredths of a second (nn)</source>
          <target state="translated">100 분의 1 초 (nn)를 포함한 시간</target>
        </trans-unit>
        <trans-unit id="7752796ce276dd1963ca59b13e249c85e33a8357" translate="yes" xml:space="preserve">
          <source>To This&amp;hellip;</source>
          <target state="translated">이에&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="4351ef8f8ed7ab261634d29751d6878a09fc70bd" translate="yes" xml:space="preserve">
          <source>To accomplish this, you will use a&lt;code&gt;SORT&lt;/code&gt;statement (see &lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt;) to sort the file of cash register sales data into:</source>
          <target state="translated">이를 위해 &lt;code&gt;SORT&lt;/code&gt; 문 ( &lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt; 참조 )을 사용하여 금전 등록기 판매 데이터 파일을 다음과 같이 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="196b2bc627c24d382addba68fc7aeb3ad298c926" translate="yes" xml:space="preserve">
          <source>To avoid any possible ambiguity, as well as to improve program readability, it&amp;rsquo;s considered good COBOL programming practice to always code at least one space to both the left and right of every operator in arithmetic expressions as well as the&lt;code&gt;=&lt;/code&gt;sign on a COMPUTE.</source>
          <target state="translated">가능한 모호성을 피하고 프로그램 가독성을 향상시키기 위해 COMPUTE 의 &lt;code&gt;=&lt;/code&gt; 부호 뿐만 아니라 산술 연산 식에서 모든 연산자의 왼쪽과 오른쪽에 최소한 하나의 공간을 항상 코딩하는 것이 좋은 COBOL 프로그래밍 실습으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="7a3e9f65a93a3a7ee18468a6cd0229bc532677b6" translate="yes" xml:space="preserve">
          <source>To be eligible for searching via&lt;code&gt;SEARCH ALL&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;SEARCH ALL&lt;/code&gt; 을 통한 검색 자격을 얻으려면</target>
        </trans-unit>
        <trans-unit id="382c951f729774c49952dd7e71894c12d45e8352" translate="yes" xml:space="preserve">
          <source>To create or change an environment variable will require two&lt;code&gt;DISPLAY&lt;/code&gt;statements. The following example sets the environment variable &quot;MY_ENV_VAR&quot; to a value of &quot;Demonstration Value&quot;:</source>
          <target state="translated">환경 변수를 만들거나 변경하려면 두 개의 &lt;code&gt;DISPLAY&lt;/code&gt; 문 이 필요 합니다. 다음 예제는 환경 변수 &quot;MY_ENV_VAR&quot;을 &quot;Demonstration Value&quot;값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="c9f6f3e99a7b7a9b35619c04e390aa19ef14345a" translate="yes" xml:space="preserve">
          <source>To demonstrate, assume that a GnuCOBOL Main Program (whose code resides in the file &quot;M.cbl&quot;) will be calling three subprograms, named &quot;A&quot;, &quot;B&quot; and &quot;C&quot; (these are the&lt;code&gt;PROGRAM-ID&lt;/code&gt; of the three subprograms, and their source code may be found in the files &quot;A.cbl&quot;, &quot;B.cbl&quot; and &quot;C.cbl&quot;, respectively.</source>
          <target state="translated">시연을 위해 GnuCOBOL 메인 프로그램 (이 코드가 &quot;M.cbl&quot;파일에 있음)이 &quot;A&quot;, &quot;B&quot;및 &quot;C&quot;라는 세 개의 서브 프로그램을 호출한다고 가정합니다 (이것은 세 개의 &lt;code&gt;PROGRAM-ID&lt;/code&gt; 입니다) 서브 프로그램 및 해당 소스 코드는 각각 &quot;A.cbl&quot;, &quot;B.cbl&quot;및 &quot;C.cbl&quot;파일에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01001acb876204dec5aa9d50cb3a5befd78ae9ab" translate="yes" xml:space="preserve">
          <source>To see qualification at work, observe the following segments of two data records defined in a COBOL program:</source>
          <target state="translated">실제 자격을 확인하려면 COBOL 프로그램에 정의 된 다음 두 데이터 레코드 세그먼트를 관찰하십시오.</target>
        </trans-unit>
        <trans-unit id="31217910df272b1f25ece09faa304c39aefdc3a5" translate="yes" xml:space="preserve">
          <source>To this:</source>
          <target state="translated">이에:</target>
        </trans-unit>
        <trans-unit id="b40576020845001a255765a757d1a098911f2927" translate="yes" xml:space="preserve">
          <source>To trap output from the executed command and process it within the GnuCOBOL program, use a pipe (&amp;gt;) to send the command output to a temporary file which you read from within the program once control returns.</source>
          <target state="translated">실행 된 명령의 출력을 트랩하여 GnuCOBOL 프로그램 내에서 처리하려면 파이프 (&amp;gt;)를 ​​사용하여 명령 출력을 제어가 리턴되면 프로그램 내에서 읽은 임시 파일로 보내십시오.</target>
        </trans-unit>
        <trans-unit id="f695d5443429ec7511bdbe3ca8da89add1aedb91" translate="yes" xml:space="preserve">
          <source>To use this statement, &amp;lt;</source>
          <target state="translated">이 문장을 사용하려면 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="5ac9e14bb8a97d61c9cd0891f1f26e6299883fa6" translate="yes" xml:space="preserve">
          <source>Today&amp;rsquo;s IT managers and business leaders are faced with a challenging dilemma &amp;mdash; how do you maintain the enormous COBOL code base that is still running their businesses when academia has all but abandoned the language they need their people to use to keep the wheels rolling? The problem is compounded by the fact that those programmers that are skilled in COBOL are retiring and taking their knowledge with them. In some markets, this appears to be having an inflationary effect on the cost of resources (COBOL programmers) whose supply is becoming smaller and smaller. The pressure to update applications to make use of more up-to-date graphical user interfaces is also perceived as a reason to abandon COBOL in favour of GUI-friendly languages such as Java.</source>
          <target state="translated">오늘날의 IT 관리자와 비즈니스 리더는 어려운 딜레마에 직면하고 있습니다. 학계가 바퀴를 계속 굴리기 위해 필요한 언어를 거의 포기하지 않은 상태에서 비즈니스를 계속 운영하는 거대한 COBOL 코드 기반을 어떻게 유지합니까? COBOL에 능숙한 프로그래머가 은퇴하고 지식을 가지고 있다는 사실로 인해 문제가 더욱 악화됩니다. 일부 시장에서는 공급이 점점 줄어들면서 자원 비용 (COBOL 프로그래머)에 인플레이션 효과가있는 것으로 보입니다. 보다 최신의 그래픽 사용자 인터페이스를 사용하기 위해 애플리케이션을 업데이트해야한다는 압력 또한 Java와 같은 GUI 친화적 인 언어를 선호하기 위해 COBOL을 포기하는 이유로 인식되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ff6f66a804bbf04219e7eafe5b382e0fdd2b88e" translate="yes" xml:space="preserve">
          <source>Today&amp;rsquo;s current programming languages have a statement (usually, this statement is named &quot;import&quot;, &quot;include&quot; or &quot;#include&quot;) that performs this same function. What makes the COBOL copybook feature different than the &quot;include&quot; facility in newer languages, however, is the fact that the&lt;code&gt;COPY&lt;/code&gt;statement can edit the imported source code as it is being copied. This capability makes copybook libraries extremely valuable to making code reusable.</source>
          <target state="translated">오늘날의 현재 프로그래밍 언어에는 동일한 기능을 수행하는 명령문 (일반적으로이 명령문의 이름은 &quot;import&quot;, &quot;include&quot;또는 &quot;#include&quot;)이 있습니다. 그러나 COBOL 카피 북 기능을 최신 언어의 &quot;include&quot;기능과 다른 점은 &lt;code&gt;COPY&lt;/code&gt; 문 이 복사 된 소스 코드를 가져올 때 편집 할 수 있다는 사실입니다 . 이 기능은 카피 북 라이브러리를 코드 재사용에 매우 유용하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="25b7ed12e84b1423118cf55ec1248f29bb802f37" translate="yes" xml:space="preserve">
          <source>Tracing may be turned off at any point by executing the&lt;code&gt;RESET TRACE&lt;/code&gt;statement (see &lt;a href=&quot;#RESET-TRACE&quot;&gt;RESET TRACE&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;RESET TRACE&lt;/code&gt; 문 을 실행하여 언제든지 추적을 끌 수 있습니다 ( &lt;a href=&quot;#RESET-TRACE&quot;&gt;RESET TRACE&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="00825313e6049642f785057dc146e4f0c223003c" translate="yes" xml:space="preserve">
          <source>Tracing, if configured by one of the two switches described above, can also be controlled via the the&lt;code&gt;READY TRACE&lt;/code&gt;statement (see &lt;a href=&quot;#READY-TRACE&quot;&gt;READY TRACE&lt;/a&gt;) and&lt;code&gt;RESET TRACE&lt;/code&gt;statement (see &lt;a href=&quot;#RESET-TRACE&quot;&gt;RESET TRACE&lt;/a&gt;).</source>
          <target state="translated">위에서 설명한 두 스위치 중 하나에 의해 구성된 추적은 &lt;code&gt;READY TRACE&lt;/code&gt; 문 ( &lt;a href=&quot;#READY-TRACE&quot;&gt;READY TRACE&lt;/a&gt; 참조 ) 및 &lt;code&gt;RESET TRACE&lt;/code&gt; 문 ( &lt;a href=&quot;#RESET-TRACE&quot;&gt;RESET TRACE&lt;/a&gt; 참조 )을 통해 제어 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="57eb2758cbceeae8f8bd9a71d84652befc3b1cbb" translate="yes" xml:space="preserve">
          <source>Training their own COBOL programmers. Since colleges, universities and technical schools have lost interest in doing so, many businesses have undertaken the task of &quot;growing their own&quot; new crop of COBOL programmers. Fear of being pigeon-holed into a niche technology is a factor inhibiting many of today&amp;rsquo;s programmers from willingly volunteering for such training.</source>
          <target state="translated">자체 COBOL 프로그래머 교육 대학, 대학 및 기술 학교는 그렇게하는 데 관심을 잃어 버렸기 때문에 많은 기업들이 새로운 COBOL 프로그래머 작물을 &quot;자체 재배&quot;하는 임무를 수행했습니다. 틈새 기술에 비둘기를 껴안는 것에 대한 두려움은 오늘날 많은 프로그래머들이 그러한 훈련에 기꺼이 자원하는 것을 방해하는 요소입니다.</target>
        </trans-unit>
        <trans-unit id="a04ea8126636acd1ffe5d49455e1613a61495ac8" translate="yes" xml:space="preserve">
          <source>Turning runtime switches (SWITCH-1, &amp;hellip; , SWITCH-8) off.</source>
          <target state="translated">런타임 스위치 (SWITCH-1,&amp;hellip;, SWITCH-8)를 끕니다.</target>
        </trans-unit>
        <trans-unit id="88ec67c6605b41aba8977bbdfff87dbb28d2f1c9" translate="yes" xml:space="preserve">
          <source>Turning runtime switches (SWITCH-1, &amp;hellip; , SWITCH-8) on.</source>
          <target state="translated">런타임 스위치 (SWITCH-1,&amp;hellip;, SWITCH-8) 켜기</target>
        </trans-unit>
        <trans-unit id="5be262e63602e73346cd7d0dd33902709c81e4ef" translate="yes" xml:space="preserve">
          <source>Two CDF variables, two literals or a single CDF variable and a single literal may be compared against each other using a relational operator. Unlike the standard GnuCOBOL&lt;code&gt;IF&lt;/code&gt;statement (see &lt;a href=&quot;#IF&quot;&gt;IF&lt;/a&gt;), multiple comparisons cannot be &quot;AND&quot;ed or &quot;OR&quot;ed together; you may nest a second&lt;code&gt;&amp;gt;&amp;gt;IF&lt;/code&gt;inside the first, however, to simulate an &quot;AND&quot; and an &quot;OR&quot; may be simulated via the&lt;code&gt;&amp;gt;&amp;gt;ELIF&lt;/code&gt;option.</source>
          <target state="translated">관계 연산자를 사용하여 두 개의 CDF 변수, 두 개의 리터럴 또는 단일 CDF 변수 및 단일 리터럴을 서로 비교할 수 있습니다. 표준 GnuCOBOL &lt;code&gt;IF&lt;/code&gt; 문 ( &lt;a href=&quot;#IF&quot;&gt;IF&lt;/a&gt; 참조 ) 과 달리 여러 비교는 &quot;AND&quot;또는 &quot;OR&quot;할 수 없습니다. &quot;AND&quot;를 시뮬레이션하기 위해 두 번째 &lt;code&gt;&amp;gt;&amp;gt;IF&lt;/code&gt; 를 첫 번째 안에 중첩 시킬 수 있으며 &lt;code&gt;&amp;gt;&amp;gt;ELIF&lt;/code&gt; 옵션을 통해 &quot;OR&quot;을 시뮬레이션 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b6c230ac1df76d2a36a5191c668e572442fad29" translate="yes" xml:space="preserve">
          <source>Two consecutive delimiter sequences will identify a null sub string.</source>
          <target state="translated">연속 된 두 개의 분리 문자 시퀀스는 널 서브 문자열을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="b423285c43b44eadb68779d025fb853f0220585b" translate="yes" xml:space="preserve">
          <source>Typically 0 to 4,294,967,295</source>
          <target state="translated">일반적으로 0 ~ 4,294,967,295</target>
        </trans-unit>
        <trans-unit id="e21a49e453cddde061f6e0c1769c5ae165ba57e6" translate="yes" xml:space="preserve">
          <source>Typically, only one kind of each of those symbols is used in the same picture clause, but that isn&amp;rsquo;t a requirement. Data items that, of the three symbols above, use nothing but&lt;code&gt;A&lt;/code&gt;picture symbols are known as &amp;rsquo;</source>
          <target state="translated">일반적으로 각 기호 중 한 종류 만 동일한 그림 절에 사용되지만 반드시 그럴 필요는 없습니다. 위의 세 가지 기호 중 &lt;code&gt;A&lt;/code&gt; 만 사용하는 데이터 항목 은 '</target>
        </trans-unit>
        <trans-unit id="53feeb0e8546e3697f070f6a4954e904f02f35f2" translate="yes" xml:space="preserve">
          <source>Typically, table is defined similarly to the following:</source>
          <target state="translated">일반적으로 테이블은 다음과 유사하게 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="17764f916f88ba28f51ab2c17c75354d23401d9e" translate="yes" xml:space="preserve">
          <source>U, UCS-4, UNBOUNDED, UNDERLINE, UNIT, UNIVERSAL, UNLOCK, UNSIGNED, UNSIGNED-INT, UNSIGNED-LONG, UNSIGNED-SHORT, UNSTRING, UNTIL, UP, UPDATE, UPON, UPPER, UPPER-CASE, USAGE, USE, USER, USER-DEFAULT, USING, UTF-16, UTF-8</source>
          <target state="translated">U, UCS-4, UNBOUNDED, UNDERLINE, UNIT, UNIVERSAL, UNLOCK, UNSIGNED, UNSIGNED-INT, UNSIGNED-LONG, UNSIGNED-SHORT, UNSTRING, UNTIL, UP, UPDATE, UPON, UPPER, 대문자, 사용, 사용, USER, USER-DEFAULT, USING, UTF-16, UTF-8</target>
        </trans-unit>
        <trans-unit id="44d8e7bb1877a9b145f3ff3e2097ea27018a2891" translate="yes" xml:space="preserve">
          <source>UNDERLINE Attribute Syntax</source>
          <target state="translated">UNDERLINE 속성 구문</target>
        </trans-unit>
        <trans-unit id="0087bab1992e0800616988b583fe6234014cc093" translate="yes" xml:space="preserve">
          <source>UNLOCK Syntax</source>
          <target state="translated">잠금 해제 구문</target>
        </trans-unit>
        <trans-unit id="a17b6fee1c419bb8d2727ffd6ea1af1f20d9bfef" translate="yes" xml:space="preserve">
          <source>UNSTRING Syntax</source>
          <target state="translated">언 스트링 문법</target>
        </trans-unit>
        <trans-unit id="286a95978a25c9a871eae074bb371382ecec0f80" translate="yes" xml:space="preserve">
          <source>UNSTRING overflow condition</source>
          <target state="translated">언 스트링 오버 플로우 조건</target>
        </trans-unit>
        <trans-unit id="cf9be7ae238af3e2326fc071f8baaaca43ad9299" translate="yes" xml:space="preserve">
          <source>UPPER-CASE Function Syntax</source>
          <target state="translated">대문자 사례 함수 구문</target>
        </trans-unit>
        <trans-unit id="d9ef7b9c9881cab27604ca7d95dad1785d837577" translate="yes" xml:space="preserve">
          <source>USAGE Clause Syntax</source>
          <target state="translated">사용법 절 구문</target>
        </trans-unit>
        <trans-unit id="263056f861bf805c436ea7c1963038f7c3b50e90" translate="yes" xml:space="preserve">
          <source>USAGE DISPLAY</source>
          <target state="translated">사용 디스플레이</target>
        </trans-unit>
        <trans-unit id="9c0a623c832b01ddec3e3e8a54abce2dc5080f56" translate="yes" xml:space="preserve">
          <source>USE THIS FEATURE AT YOUR OWN RISK &amp;ndash; YOU SHOULD ALWAYS USE THE C COMPILER YOUR GnuCOBOL BUILD WAS GENERATED FOR</source>
          <target state="translated">귀하의 책임하에이 기능을 사용하십시오 &amp;ndash; 귀하는 항상 귀하의 GnucoBOL 빌드가 생성 된 C 컴파일러를 사용해야합니다</target>
        </trans-unit>
        <trans-unit id="5278c45ae981174d297e4eea84bb028bba3d9b35" translate="yes" xml:space="preserve">
          <source>USING Clause Syntax</source>
          <target state="translated">절 구문 사용</target>
        </trans-unit>
        <trans-unit id="497461db741a76ab5c324283684cac8797acec67" translate="yes" xml:space="preserve">
          <source>Unary-Expression Syntax</source>
          <target state="translated">단항 표현 구문</target>
        </trans-unit>
        <trans-unit id="b3b1ea937a0336aee93ae54ddc77dbf6c45c2648" translate="yes" xml:space="preserve">
          <source>Unfortunately that too is insufficient because it still insufficiently specifies which CITY is being referenced. To truly identify which specific CITY you want, you&amp;rsquo;d have to code&lt;code&gt;MOVE 'Philadelphia' TO CITY OF MAILING-ADDRESS OF EMPLOYEE&lt;/code&gt;</source>
          <target state="translated">불행히도 그 도시는 여전히 어느 도시가 참조되고 있는지를 불충분하게 지정하기 때문에 충분하지 않습니다. 원하는 특정 도시를 진정으로 식별하려면 &lt;code&gt;MOVE 'Philadelphia' TO CITY OF MAILING-ADDRESS OF EMPLOYEE&lt;/code&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="48d9c1e9120e152d96ee96e1c698eb3da83cb434" translate="yes" xml:space="preserve">
          <source>Unfortunately, there&amp;rsquo;s a problem with the above. A human being looking at that code would probably infer that the&lt;code&gt;DISPLAY&lt;/code&gt;(see &lt;a href=&quot;#DISPLAY&quot;&gt;DISPLAY&lt;/a&gt;) statement, because of its lack of indentation, is to be executed regardless of the TRUE/FALSE value of the&lt;code&gt;IF&lt;/code&gt;condition. Unfortunately, the GnuCOBOL compiler (or any other COBOL compiler for that matter) won&amp;rsquo;t see it that way because it really couldn&amp;rsquo;t care less what sort of indentation, if any, is used. In fact, any COBOL compiler would be just as happy to see the code written like this:</source>
          <target state="translated">불행히도, 위의 문제가 있습니다. 인간은 아마 것을 추론 할 것이라고 코드를 찾고있는 &lt;code&gt;DISPLAY&lt;/code&gt; (참조 &lt;a href=&quot;#DISPLAY&quot;&gt;DISPLAY&lt;/a&gt; 때문에 들여 쓰기의 부족, 문)에 관계없이의 TRUE / FALSE 값 실행될 &lt;code&gt;IF&lt;/code&gt; 조건. 불행히도 GnuCOBOL 컴파일러 (또는 그 문제에 대한 다른 COBOL 컴파일러)는 어떤 종류의 들여 쓰기 (있는 경우)가 실제로 사용되는지 신경 쓰지 않았기 때문에 그렇게 보지 못했습니다. 실제로 모든 COBOL 컴파일러는 다음과 같이 작성된 코드를 보는 것이 행복 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="84b92ca23e9ba2635b4832f6266fc7dd38dc8a07" translate="yes" xml:space="preserve">
          <source>Unfortunately, this caused some problems. Take a look at this code:</source>
          <target state="translated">불행히도 이로 인해 일부 문제가 발생했습니다. 이 코드를 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="4561955c890fd3190de91d6c9aa8b6a31c61f6c9" translate="yes" xml:space="preserve">
          <source>Universities love the &quot;Modern&quot; languages. In the U.S., 73% of colleges lack even one COBOL course on their curricula. COBOL, it appears, is no longer &quot;cool&quot; enough for students to fill a classroom.</source>
          <target state="translated">대학은 &quot;현대&quot;언어를 좋아합니다. 미국에서는 73 %의 대학이 교과 과정에 코볼 과정이 하나도 부족합니다. 코볼은 학생들이 교실을 채우기에 더 이상 &quot;쿨하지&quot;않은 것으로 보인다.</target>
        </trans-unit>
        <trans-unit id="230f683b116d6271c58990371d26f1ef0df144a6" translate="yes" xml:space="preserve">
          <source>Unlike the&lt;code&gt;TALLYING&lt;/code&gt;and&lt;code&gt;REPLACING&lt;/code&gt;clauses, both of which may have multiple operations specified, there may be only one&lt;code&gt;CONVERTING&lt;/code&gt;operation per&lt;code&gt;INSPECT&lt;/code&gt;</source>
          <target state="translated">달리 &lt;code&gt;TALLYING&lt;/code&gt; 및 &lt;code&gt;REPLACING&lt;/code&gt; 여러 작업 지정한있다 둘 절, 하나만 존재할 수있다 &lt;code&gt;CONVERTING&lt;/code&gt; 당 동작 &lt;code&gt;INSPECT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4081735511995168272cde9e072118caa1e2c4e1" translate="yes" xml:space="preserve">
          <source>Unlike the&lt;code&gt;WHEN-COMPILED&lt;/code&gt;special register, which has an ASCII value of the compilation date/time in the format &quot;mm/dd/yyhh.mm.ss&quot;, the&lt;code&gt;WHEN-COMPILED&lt;/code&gt;intrinsic function returns the compilation date/time as an ASCII string in the format &quot;yyyymmddhhmmssnnooooo&quot;, where &quot;yyyymmdd&quot; is the date, &quot;hhmmss&quot; is the time, &quot;nn&quot; is the hundredths of a second component of the compilation time, if available (or &quot;00&quot; if it isn&amp;rsquo;t) and &quot;ooooo&quot; is the time zone offset from GMT.</source>
          <target state="translated">컴파일 날짜 / 시간의 ASCII 값이 &quot;mm / dd / yyhh.mm.ss&quot;형식 인 &lt;code&gt;WHEN-COMPILED&lt;/code&gt; 특수 레지스터 와 달리 &lt;code&gt;WHEN-COMPILED&lt;/code&gt; 내장 함수는 컴파일 날짜 / 시간을 ASCII 문자열로 반환합니다. &quot;yyyymmddhhmmssnnooooo&quot;형식으로, 여기서 &quot;yyyymmdd&quot;는 날짜, &quot;hhmmss&quot;는 시간, &quot;nn&quot;은 컴파일 시간의 두 번째 구성 요소 중 100 분의 1 (사용할 수없는 경우 &quot;00&quot;)입니다. &quot;ooooo&quot;는 GMT에서 표준 시간대 오프셋입니다.</target>
        </trans-unit>
        <trans-unit id="b8ce105822f86c63a748c41812ce7e1512a397cf" translate="yes" xml:space="preserve">
          <source>Unsigned Packed Decimal</source>
          <target state="translated">부호없는 팩형 10 진수</target>
        </trans-unit>
        <trans-unit id="5056b52a9ad2f1098057a49c5432ea24fe03ab80" translate="yes" xml:space="preserve">
          <source>Up Arrow was pressed</source>
          <target state="translated">위쪽 화살표를 눌렀습니다</target>
        </trans-unit>
        <trans-unit id="e6af6048b4951ba04f524154737eee9921cd23c9" translate="yes" xml:space="preserve">
          <source>Upon completion, the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) will be set to 0 if the read was successful or to 10 if an &quot;end-of-file&quot; condition occurred. If a value of -1 is returned, a problem was identified with the subroutine arguments.</source>
          <target state="translated">완료되면, &lt;code&gt;RETURN-CODE&lt;/code&gt; 의 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터&lt;/a&gt; 에 &quot;파일 끝&quot;조건이 발생하면 읽기가 성공 또는 제 10 경우) 0으로 설정됩니다. -1 값이 리턴되면 서브 루틴 인수로 문제점이 식별되었습니다.</target>
        </trans-unit>
        <trans-unit id="eabc537d1cfeb3028c4b50019bea306adaebd7f7" translate="yes" xml:space="preserve">
          <source>Upon completion, the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) will be set to 0 if the write was successful or to 30 if an I/O error condition occurred. If a value of -1 is returned, a problem was identified with the subroutine arguments.</source>
          <target state="translated">완료되면, &lt;code&gt;RETURN-CODE&lt;/code&gt; 의 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터를&lt;/a&gt; I / O 오류 조건이 발생하면 쓰기가 성공 또는 30 경우) 0으로 설정됩니다. -1 값이 리턴되면 서브 루틴 인수로 문제점이 식별되었습니다.</target>
        </trans-unit>
        <trans-unit id="a077f478ea6c8b338771cd509e06fe612041307c" translate="yes" xml:space="preserve">
          <source>Use a&lt;code&gt;DECLARATIVES&lt;/code&gt;(see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) routine or an explicitly-declared file status field tested after the&lt;code&gt;READ&lt;/code&gt;or&lt;code&gt;RETURN&lt;/code&gt;to detect error conditions other than end-of-file.</source>
          <target state="translated">용도 &lt;code&gt;DECLARATIVES&lt;/code&gt; 를 (참조 &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt; 루틴 또는 후 테스트를 명시 적으로 선언 파일 상태 필드) &lt;code&gt;READ&lt;/code&gt; 또는 &lt;code&gt;RETURN&lt;/code&gt; end-of-file 이외의 오류 조건을 감지합니다.</target>
        </trans-unit>
        <trans-unit id="1df41f6fa8acd2d4a7200e2fefac6d5d04cf6a05" translate="yes" xml:space="preserve">
          <source>Use constant subscripts (example #1) wherever possible/practical.</source>
          <target state="translated">가능한 한 / 실제로 일정한 첨자를 사용하십시오 (예 # 1).</target>
        </trans-unit>
        <trans-unit id="70d5d4de708078d88800b585c6de016b9cfd3034" translate="yes" xml:space="preserve">
          <source>Use of a reference modifier on the string field - See &lt;a href=&quot;#Reference-Modifiers&quot;&gt;Reference Modifiers&lt;/a&gt;.</source>
          <target state="translated">문자열 필드에서 &lt;a href=&quot;#Reference-Modifiers&quot;&gt;참조 수정 자 사용&lt;/a&gt; &amp;ndash; 참조 수정 자 참조 .</target>
        </trans-unit>
        <trans-unit id="49e7f0a9502b6030322ad77ec830602c53a48d0e" translate="yes" xml:space="preserve">
          <source>Use of a&lt;code&gt;ROUNDED&lt;/code&gt;clause without a&lt;code&gt;MODE&lt;/code&gt;specification is the same as specifying&lt;code&gt;ROUNDED MODE IS NEAREST-AWAY-FROM-ZERO&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;MODE&lt;/code&gt; 스펙 없이 &lt;code&gt;ROUNDED&lt;/code&gt; 절을 사용하는 것은 ROUNDED &lt;code&gt;ROUNDED MODE IS NEAREST-AWAY-FROM-ZERO&lt;/code&gt; 를 지정하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="543986951caf80e7bf2ee225eace63af8f6047bf" translate="yes" xml:space="preserve">
          <source>Use this clause to cause an audible tone to occur when the screen item is DISPLAYed.</source>
          <target state="translated">화면 항목이 표시 될 때 소리가 나게하려면이 절을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3e6837cd5f7c10330960b6d4123be7352b790cc4" translate="yes" xml:space="preserve">
          <source>User-Defined Function</source>
          <target state="translated">사용자 정의 기능</target>
        </trans-unit>
        <trans-unit id="90912dab063fcb2124df96e643e8ab0464a51dc5" translate="yes" xml:space="preserve">
          <source>User-Defined Names</source>
          <target state="translated">사용자 정의 이름</target>
        </trans-unit>
        <trans-unit id="d6b3ce6e7694d86d90e740481f312ce05fcd9c4d" translate="yes" xml:space="preserve">
          <source>User-defined functions (i.e.&lt;code&gt;FUNCTION-ID&lt;/code&gt; are always recursive.</source>
          <target state="translated">사용자 정의 함수 (예 : &lt;code&gt;FUNCTION-ID&lt;/code&gt; ) 는 항상 재귀 적입니다.</target>
        </trans-unit>
        <trans-unit id="1fc4ac540a1a64364793a04fa696f3ddff4bcdfc" translate="yes" xml:space="preserve">
          <source>User-defined words may be composed from the characters &quot;A&quot; through &quot;Z&quot; (upper- and/or lower-case), &quot;0&quot; through &quot;9&quot;, dash (&quot;-&quot;)</source>
          <target state="translated">사용자 정의 단어는 &quot;A&quot;~ &quot;Z&quot;(대문자 및 / 또는 소문자), &quot;0&quot;~ ​​&quot;9&quot;, 대시 ( &quot;-&quot;) 문자로 구성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0d6673b38b9cdf2e1a6d43c1347627240486119" translate="yes" xml:space="preserve">
          <source>User-written functions (see &lt;a href=&quot;#Subprogram-Types&quot;&gt;Subprogram Types&lt;/a&gt;) never require the&lt;code&gt;FUNCTION&lt;/code&gt;keyword when they are executed, because each user-written function a program uses</source>
          <target state="translated">프로그램이 사용하는 각 사용자 작성 함수 때문에 사용자 작성 함수 ( &lt;a href=&quot;#Subprogram-Types&quot;&gt;서브 프로그램 유형&lt;/a&gt; 참조 ) 는 실행될 때 &lt;code&gt;FUNCTION&lt;/code&gt; 키워드를 요구하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e2d361932d2db4fa457a5f503d958c818df2ef65" translate="yes" xml:space="preserve">
          <source>Using &amp;lt;</source>
          <target state="translated">&amp;lt;</target>
        </trans-unit>
        <trans-unit id="6d25575124f2b1d21418340870745666f2f2eccf" translate="yes" xml:space="preserve">
          <source>Using a compiler option switch &amp;mdash; use the&lt;code&gt;-fixed&lt;/code&gt;switch</source>
          <target state="translated">컴파일러 옵션 스위치 사용 &amp;mdash; &lt;code&gt;-fixed&lt;/code&gt; 스위치 사용</target>
        </trans-unit>
        <trans-unit id="bf0e03ebfa108b2c88b9744b24c7946ec2982481" translate="yes" xml:space="preserve">
          <source>Using methods 2-4 above, you may switch back and forth between the two formats at will.</source>
          <target state="translated">위의 방법 2-4를 사용하면 마음대로 두 형식간에 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30fc2e97060231bd35e5ef9e873ee5e07f7e8bf0" translate="yes" xml:space="preserve">
          <source>Using programs that, for the most part, are much more self-documenting than would be the case with any other programming language.</source>
          <target state="translated">대부분의 경우 다른 프로그래밍 언어의 경우보다 훨씬 더 많은 자체 문서화 프로그램을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="dce1ca9279ec7bad57a4928960fcf2964806a117" translate="yes" xml:space="preserve">
          <source>Using relative column positioning &lt;code&gt;COLUMN PLUS&lt;/code&gt; has slightly different behaviour depending upon the section in which the clause is used, as follows:</source>
          <target state="translated">상대 열 위치 지정 사용 &lt;code&gt;COLUMN PLUS&lt;/code&gt; 는 다음과 같이 절이 사용되는 섹션에 따라 동작이 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="364ebd5efd21da183fb00b1c6ce4d7d1330a8f9c" translate="yes" xml:space="preserve">
          <source>Using the&lt;code&gt;ALL&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ALL&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="5c7418af4591ec3349c45d28db0db908a5995065" translate="yes" xml:space="preserve">
          <source>Using the&lt;code&gt;DECIMAL-POINT IS COMMA&lt;/code&gt;(see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) clause in your program will not affect the value returned by this function.</source>
          <target state="translated">프로그램에서 &lt;code&gt;DECIMAL-POINT IS COMMA&lt;/code&gt; ( &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt; 참조 ) 절을 사용 해도이 함수가 반환하는 값에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7d7bec9edfe24f7bc97ad7025c81773afc592db4" translate="yes" xml:space="preserve">
          <source>Using the&lt;code&gt;STATIC&lt;/code&gt;option on a&lt;code&gt;CALL&lt;/code&gt;statement is equivalent to using&lt;code&gt;CALL CONVENTION 64&lt;/code&gt;(only bit 6 set).</source>
          <target state="translated">&lt;code&gt;CALL&lt;/code&gt; 문 에서 &lt;code&gt;STATIC&lt;/code&gt; 옵션을 사용하는 것은 &lt;code&gt;CALL CONVENTION 64&lt;/code&gt; (비트 6 만 설정) 를 사용하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="dcda3f19c20b8f12cf9e41bdefb3336575eeba80" translate="yes" xml:space="preserve">
          <source>Using the&lt;code&gt;STATUS&lt;/code&gt;clause without a &amp;lt;</source>
          <target state="translated">&amp;lt;없이 &lt;code&gt;STATUS&lt;/code&gt; 절 사용</target>
        </trans-unit>
        <trans-unit id="1cbde56e4687cbd99f85608012c26564941b51d8" translate="yes" xml:space="preserve">
          <source>Using the&lt;code&gt;STDCALL&lt;/code&gt;option on a&lt;code&gt;CALL&lt;/code&gt;statement is equivalent to using&lt;code&gt;CALL-CONVENTION 8&lt;/code&gt;(only bit 3 set).</source>
          <target state="translated">&lt;code&gt;CALL&lt;/code&gt; 문 에서 &lt;code&gt;STDCALL&lt;/code&gt; 옵션을 사용하는 것은 &lt;code&gt;CALL-CONVENTION 8&lt;/code&gt; (비트 3 만 설정) 을 사용하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="055069cd0b3ac72305253e471732284f0ce7b811" translate="yes" xml:space="preserve">
          <source>Using this clause with any organization other than&lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt;will either be rejected outright by the compiler (relative or indexed files) or may introduce unwanted characters into the file &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt;)).</source>
          <target state="translated">&lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; 이외의 조직 에서이 절을 사용 하면 컴파일러 (상대 또는 색인화 된 파일)가 즉시 거부하거나 &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; 파일에 원하지 않는 문자를 도입 할 수 있습니다 ( &lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="d045dc0df6c82b505ff2b86a71d9d7ecfebed4da" translate="yes" xml:space="preserve">
          <source>Using this, you may replace character sequences that occur at the beginning &lt;code&gt;LEADING&lt;/code&gt;</source>
          <target state="translated">이 사용하면 처음에 발생 문자 시퀀스를 대체 할 수 &lt;code&gt;LEADING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="473751d4f457e913755e0b7d0834b9e83484f656" translate="yes" xml:space="preserve">
          <source>Using&lt;code&gt;DELIMITED BY &amp;lt;&lt;i&gt;literal-2&lt;/i&gt;&amp;gt;&lt;/code&gt;or&lt;code&gt;DELIMITED BY &amp;lt;&lt;i&gt;identifier-2&lt;/i&gt;&amp;gt;&lt;/code&gt;causes only the contents of the source item up to but not including the character sequence specified by the literal or identifier to be copied.</source>
          <target state="translated">사용 &lt;code&gt;DELIMITED BY &amp;lt;&lt;i&gt;literal-2&lt;/i&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;DELIMITED BY &amp;lt;&lt;i&gt;identifier-2&lt;/i&gt;&amp;gt;&lt;/code&gt; 최대하지만 문자 또는 식별자를 복사 할 수로 지정된 문자 순서를 포함하지 않고 소스 항목의 내용 만됩니다.</target>
        </trans-unit>
        <trans-unit id="5d1ad554e0d92c73f5806ac5626ba8fead7eeabd" translate="yes" xml:space="preserve">
          <source>V, VALID, VALIDATE, VALIDATE-STATUS, VAL-STATUS, VALUE, VALUES, VARIABLE, VARIANCE, VARYING</source>
          <target state="translated">V, VALID, VALIDATE, VALIDATE-STATUS, VAL-STATUS, VALUE, VALUES, VARIABLE, VARIANCE, VARYING</target>
        </trans-unit>
        <trans-unit id="ebc6e4ee470001bf8e164fc1af3e6959efcb65bb" translate="yes" xml:space="preserve">
          <source>VALUE (Condition Names) Clause Syntax</source>
          <target state="translated">VALUE (조건 이름) 절 구문</target>
        </trans-unit>
        <trans-unit id="63cd3ebb0fb81cea3748b8d9509c32ae6fe58ee7" translate="yes" xml:space="preserve">
          <source>VALUE (Other Data Items) Syntax</source>
          <target state="translated">VALUE (기타 데이터 항목) 구문</target>
        </trans-unit>
        <trans-unit id="f93f233c1e3f1c1329fd9fd4d748269757ee2f23" translate="yes" xml:space="preserve">
          <source>VARIANCE Function Syntax</source>
          <target state="translated">VARIANCE 함수 구문</target>
        </trans-unit>
        <trans-unit id="d8eedc8107b965cbde0511d027a2377e39a085bf" translate="yes" xml:space="preserve">
          <source>VARYING Syntax</source>
          <target state="translated">다양한 구문</target>
        </trans-unit>
        <trans-unit id="1460437d17a2fe697f601b3af9079d9a98ae5afb" translate="yes" xml:space="preserve">
          <source>VARYING-Clause</source>
          <target state="translated">VARYING-Clause</target>
        </trans-unit>
        <trans-unit id="ce1b089a7469f7a7435681b1daa0f9444f349773" translate="yes" xml:space="preserve">
          <source>Valid return code values can be in the range -2147483648 to +2147483647.</source>
          <target state="translated">유효한 리턴 코드 값은 -2147483648에서 +2147483647 범위에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06b8a672cadb78c6399afa356021a887f83eef82" translate="yes" xml:space="preserve">
          <source>Value For Positive</source>
          <target state="translated">긍정적 인 가치</target>
        </trans-unit>
        <trans-unit id="867cb97da0125676cf5656c5dafc6e5f822d8d38" translate="yes" xml:space="preserve">
          <source>Value for Negative</source>
          <target state="translated">부정적 가치</target>
        </trans-unit>
        <trans-unit id="ce10391642834208f65de6172d958c969f7f4bc8" translate="yes" xml:space="preserve">
          <source>Values of 0 will be returned if GnuCOBOL was not generated to include screen I/O.</source>
          <target state="translated">화면 I / O를 포함하도록 GnuCOBOL이 생성되지 않은 경우 0 값이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="81cad7d9a6789eaf829d8bb24bf8cd92e85aefe9" translate="yes" xml:space="preserve">
          <source>Values of 1 (Line) and 1 (column) will be returned if GnuCOBOL was not generated to include screen I/O.</source>
          <target state="translated">화면 I / O를 포함하도록 GnuCOBOL이 생성되지 않은 경우 1 (라인) 및 1 (열) 값이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b814d960006b5980858a36bc094f395a0b420215" translate="yes" xml:space="preserve">
          <source>Values other than 0 or 1 will be ignored.</source>
          <target state="translated">0 또는 1 이외의 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="655249fc2f22beeccfa0d8e17b14dfe0bbd81872" translate="yes" xml:space="preserve">
          <source>Various implementations of COBOL generate object code that is quite different in each of these three situations, and GnuCOBOL is no exception.</source>
          <target state="translated">다양한 COBOL 구현은 이러한 세 가지 상황에서 각각 다른 객체 코드를 생성하며 GnuCOBOL도 예외는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="33817a63b651d4a84e7a5d740d58bef5f67a6a2a" translate="yes" xml:space="preserve">
          <source>Verb</source>
          <target state="translated">Verb</target>
        </trans-unit>
        <trans-unit id="8f924ae8f2821ea13136a49a2f30149c04dea61b" translate="yes" xml:space="preserve">
          <source>Vertical bar meta characters on syntax diagrams document simple choices. The | character itself should not be coded. If a syntax diagram contains &quot;a|b|c&quot;, exactly one of the items &quot;a&quot;, &quot;b&quot; or &quot;c&quot; must be selected.</source>
          <target state="translated">구문 다이어그램의 세로 막대 메타 문자는 간단한 선택을 문서화합니다. | 문자 자체는 코딩해서는 안됩니다. 구문 다이어그램에 &quot;a | b | c&quot;가 포함 된 경우 &quot;a&quot;, &quot;b&quot;또는 &quot;c&quot;항목 중 정확히 하나를 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="865bd476e8da657a3730a2cf5b4afe0ce5ef5c72" translate="yes" xml:space="preserve">
          <source>WAIT, WHEN, WHEN-COMPILED, WITH, WORDS, WORKING-STORAGE, WRITE</source>
          <target state="translated">대기 시간, 종료 시점, 단어 포함, 작업 스토리지, 쓰기</target>
        </trans-unit>
        <trans-unit id="9526c3fde17971c75db66951966656c3a9bcdf06" translate="yes" xml:space="preserve">
          <source>WHEN-COMPILED Function Syntax</source>
          <target state="translated">언제 COMPILED 함수 구문</target>
        </trans-unit>
        <trans-unit id="b8afbfcec0d7323da75e2cbb6538598b82bc6ba1" translate="yes" xml:space="preserve">
          <source>WORKING-STORAGE-SECTION-Data-Item</source>
          <target state="translated">WORKING-STORAGE-SECTION-Data-Item</target>
        </trans-unit>
        <trans-unit id="e509974f5343f06b8c28dd65e19b1ca0fc9e9e74" translate="yes" xml:space="preserve">
          <source>WORKING-STORAGE-SECTION-Data-Item Syntax</source>
          <target state="translated">작업 스토리지 섹션 데이터 항목 구문</target>
        </trans-unit>
        <trans-unit id="8a3a0314ec970477daf2970487711f5978bc099d" translate="yes" xml:space="preserve">
          <source>WRITE Syntax</source>
          <target state="translated">쓰기 구문</target>
        </trans-unit>
        <trans-unit id="71b237df64f9b51f1237736626ec7b82bf855929" translate="yes" xml:space="preserve">
          <source>What constitutes a &quot;letter&quot; (or upper/lower case too, for that manner) may be influenced through the use of a&lt;code&gt;CHARACTER CLASSIFICATION&lt;/code&gt;(see &lt;a href=&quot;#OBJECT_002dCOMPUTER&quot;&gt;OBJECT-COMPUTER&lt;/a&gt;).</source>
          <target state="translated">&quot;문자&quot;(또는 그와 같은 경우 대문자 / 소문자도)를 구성하는 것은 &lt;code&gt;CHARACTER CLASSIFICATION&lt;/code&gt; 사용하여 영향을받을 수 있습니다 ( &lt;a href=&quot;#OBJECT_002dCOMPUTER&quot;&gt;OBJECT-COMPUTER&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7a5dc3b00fd066d729c12426c404973d472ba142" translate="yes" xml:space="preserve">
          <source>What font and font size will be used for the report when it is printed? RWCS-generated reports will assume that a fixed-width font such as &quot;Courier&quot;, &quot;Lucida Console&quot;, &quot;Consolas&quot; and the like will be used to print, as variable-pitch fonts would make the proper alignment of columns of data on reports virtually impossible.</source>
          <target state="translated">보고서를 인쇄 할 때 어떤 글꼴 및 글꼴 크기가 사용됩니까? RWCS 생성 보고서는 가변 피치 글꼴이 데이터 열을 올바르게 정렬하기 때문에 &quot;Courier&quot;, &quot;Lucida Console&quot;, &quot;Consolas&quot;등과 같은 고정 폭 글꼴이 인쇄에 사용된다고 가정합니다. 사실상 불가능한보고.</target>
        </trans-unit>
        <trans-unit id="bbdcaf0e5f1badb74e39f4542272bcd8c71b4fe2" translate="yes" xml:space="preserve">
          <source>What is the maximum number of characters that may be printed on one line?</source>
          <target state="translated">한 줄에 인쇄 할 수있는 최대 문자 수는 얼마입니까?</target>
        </trans-unit>
        <trans-unit id="3dfea8d0c26dbf8641b4160af02785df1d84b8c3" translate="yes" xml:space="preserve">
          <source>What is the maximum number of lines per page that may be printed on a single sheet of paper?</source>
          <target state="translated">한 장에 인쇄 할 수있는 페이지 당 최대 줄 수는 얼마입니까?</target>
        </trans-unit>
        <trans-unit id="b95c1be1be9b54be43aa4ba3ab14463b33d596e0" translate="yes" xml:space="preserve">
          <source>What paper orientation will you use, &amp;mdash; Landscape (long edge of the paper at the top and bottom of page), or Portrait (long edge of the paper at the left and right of page)?</source>
          <target state="translated">가로 (페이지의 위쪽과 아래쪽에있는 용지의 긴 쪽) 또는 세로 (페이지의 왼쪽과 오른쪽에있는 용지의 긴 쪽)와 같은 용지 방향을 사용 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="2b65da80c1855dc3510a765ddb84dc985073cfee" translate="yes" xml:space="preserve">
          <source>What printer(s) will the report be printed on?</source>
          <target state="translated">보고서는 어떤 프린터에 인쇄됩니까?</target>
        </trans-unit>
        <trans-unit id="2e74d89aed0becdc4a29ee6ec0d6b154837ce475" translate="yes" xml:space="preserve">
          <source>What tool will be used to print the report (direct printing to the device, notepad.exe, MS-Word, &amp;hellip;)?</source>
          <target state="translated">보고서를 인쇄하는 데 어떤 도구가 사용됩니까 (장치로 직접 인쇄, notepad.exe, MS-Word 등)?</target>
        </trans-unit>
        <trans-unit id="6a852f999ff1776e3230a0faadd9d1d3879bd2b8" translate="yes" xml:space="preserve">
          <source>What value will be stored in&lt;code&gt;I&lt;/code&gt; The number 4, which is the result of subtracting the value of&lt;code&gt;D&lt;/code&gt;(2) from the value of&lt;code&gt;C&lt;/code&gt;(5) and then adding 1? Or, will it be the number 8, which is the value of adding 1 to the value of data item&lt;code&gt;C-D&lt;/code&gt;(7)?</source>
          <target state="translated">어떤 값이 저장된다 &lt;code&gt;I&lt;/code&gt; 의 값을 뺀 결과 인 4 번, &lt;code&gt;D&lt;/code&gt; 의 값과 (2) &lt;code&gt;C&lt;/code&gt; (5), 그리고, 1을 가산을? 또는 데이터 항목 &lt;code&gt;C-D&lt;/code&gt; (7) 의 값에 1을 더한 값인 숫자 8 입니까?</target>
        </trans-unit>
        <trans-unit id="acdaf525a738f8ef278213e37b2b43ac406e433a" translate="yes" xml:space="preserve">
          <source>Whatever precedes the&lt;code&gt;BY&lt;/code&gt;will be referred to here as the search string.</source>
          <target state="translated">&lt;code&gt;BY&lt;/code&gt; 앞에 오는 것은 여기에서 검색 문자열이라고합니다.</target>
        </trans-unit>
        <trans-unit id="e1f2e5f165dcc0919ed94a24e87936dac695bc95" translate="yes" xml:space="preserve">
          <source>When DEMOFACT is executed, the output shown below is generated.</source>
          <target state="translated">DEMOFACT가 실행되면 아래와 같은 출력이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="e454e9d4e085d6ac64b7d40e4d1c8805cb4336a7" translate="yes" xml:space="preserve">
          <source>When a &amp;lt;</source>
          <target state="translated">때 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="071f0bb9b82c84d3aab4d8e0fd4613bf250b9554" translate="yes" xml:space="preserve">
          <source>When a COBOL program needs to process string data prepared by a C program, the embedded null character must be accounted for. This can easily be accomplished with an&lt;code&gt;INSPECT&lt;/code&gt;statement (see &lt;a href=&quot;#INSPECT&quot;&gt;INSPECT&lt;/a&gt;) such as the following:</source>
          <target state="translated">COBOL 프로그램이 C 프로그램에서 준비한 문자열 데이터를 처리해야하는 경우 임베드 된 널 문자를 고려해야합니다. 이것은 다음과 같은 &lt;code&gt;INSPECT&lt;/code&gt; 문 ( &lt;a href=&quot;#INSPECT&quot;&gt;INSPECT&lt;/a&gt; 참조 )으로 쉽게 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="74c72b319d141b225148d238fb8c1fedb422ca16" translate="yes" xml:space="preserve">
          <source>When a Format 1&lt;code&gt;REPLACE&lt;/code&gt;statement with the&lt;code&gt;ALSO&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ALSO&lt;/code&gt; 가 있는 형식 1 &lt;code&gt;REPLACE&lt;/code&gt; 문</target>
        </trans-unit>
        <trans-unit id="609d85ba79405fab967ad11164a5456813a08759" translate="yes" xml:space="preserve">
          <source>When a Format 1&lt;code&gt;REPLACE&lt;/code&gt;without the&lt;code&gt;ALSO&lt;/code&gt;keyword is encountered, any stacked change specification(s), if any, will be discarded and the currently in-effect change specification(s), if any, will be replaced by those of the new statement.</source>
          <target state="translated">&lt;code&gt;ALSO&lt;/code&gt; 키워드가 없는 형식 1 &lt;code&gt;REPLACE&lt;/code&gt; 가 발생하면 누적 변경 스펙 (있는 경우)이 삭제되고 현재 적용중인 변경 스펙 (있는 경우)이 새 명령문의 스펙으로 대체됩니다. .</target>
        </trans-unit>
        <trans-unit id="3e4370629d8db76dfdb59a6d547a7a75da5953b1" translate="yes" xml:space="preserve">
          <source>When a GnuCOBOL program is executed from a command-line, the complete command line text will be broken into a series of &quot;tokens&quot;, where each token is identified as being a word separated from the others in the command text by at least one space. For example, if the command line was &lt;code&gt;/usr/local/myprog THIS IS A TEST&lt;/code&gt;, there will be five tokens identified by the operating system &amp;mdash; &quot;/usr/local/myprog&quot;, &quot;THIS&quot;, &quot;IS&quot;, &quot;A&quot; and &quot;TEST&quot;.</source>
          <target state="translated">GnuCOBOL 프로그램이 명령 행에서 실행될 때, 전체 명령 행 텍스트는 일련의 &quot;토큰&quot;으로 분리되며, 여기서 각 토큰은 하나 이상의 공백으로 명령 텍스트에서 다른 토큰과 분리 된 단어로 식별됩니다. . 예를 들어, 명령 행이 &lt;code&gt;/usr/local/myprog THIS IS A TEST&lt;/code&gt; 경우 운영 체제에서 식별 한 토큰은 &quot;/ usr / local / myprog&quot;, &quot;THIS&quot;, &quot;IS&quot;, &quot;A&quot;입니다. &quot;테스트&quot;.</target>
        </trans-unit>
        <trans-unit id="1968e3e733fa898eb7fff35a164afeee04aa71e6" translate="yes" xml:space="preserve">
          <source>When a dynamically-loadable module needs to be loaded (because it is not already in memory from a previous subprogram execution), the dynamically-loadable library will be sought in the same directory from which the main program was loaded. If it cannot be found there, each directory named in the</source>
          <target state="translated">동적으로로드 가능한 모듈을로드해야하는 경우 (이전 서브 프로그램 실행의 메모리에 아직 없기 때문에) 동적으로로드 가능한 라이브러리는 기본 프로그램이로드 된 동일한 디렉토리에 있습니다. 찾을 수없는 경우 각 디렉토리는</target>
        </trans-unit>
        <trans-unit id="8e4263cd1334069c6f7173b8ede8ed05ebf8464b" translate="yes" xml:space="preserve">
          <source>When a function key (Fn) is pressed.</source>
          <target state="translated">기능 키 (Fn)를 누를 때.</target>
        </trans-unit>
        <trans-unit id="ac45edb70ad44424b1a7876ade379c91f86efe2c" translate="yes" xml:space="preserve">
          <source>When a program or subprogram is first executed, much of the data in it&amp;rsquo;s data division will be initialized as follows:</source>
          <target state="translated">프로그램 또는 서브 프로그램이 처음 실행될 때, 데이터 분할의 많은 데이터는 다음과 같이 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="facb9dbcd71a4e9843cdc8b09ad8afde94406f7e" translate="yes" xml:space="preserve">
          <source>When a report group&amp;rsquo;s presentation is suppressed, none of the following operations for the report will take place:</source>
          <target state="translated">보고서 그룹의 표시가 억제되면 보고서에 대해 다음 작업이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca3ab3a9579a8665008e315c51d31fce818d6ed6" translate="yes" xml:space="preserve">
          <source>When a subprogram is invoked, the flow of execution will differ slightly depending on whether the subprogram is a subroutine or a user-defined function.</source>
          <target state="translated">서브 프로그램이 호출되면 서브 플로우가 서브 루틴인지 사용자 정의 함수인지에 따라 실행 흐름이 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="940be2e3508e9644f58b55af8a2958ecec5b3cd5" translate="yes" xml:space="preserve">
          <source>When a subroutine argument is passed&lt;code&gt;BY REFERENCE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;BY REFERENCE&lt;/code&gt; 에 의해 서브 루틴 인수가 전달 될 때</target>
        </trans-unit>
        <trans-unit id="3f72daa026176d89a20466eece46174a0229f9e4" translate="yes" xml:space="preserve">
          <source>When a subroutine is passed an argument&lt;code&gt;BY CONTENT&lt;/code&gt;</source>
          <target state="translated">서브 루틴에 인수 &lt;code&gt;BY CONTENT&lt;/code&gt; 가 전달 될 때</target>
        </trans-unit>
        <trans-unit id="999bc503c0b4c1d58f8dd2e8dc5c53e05d6a972d" translate="yes" xml:space="preserve">
          <source>When a subroutine is&lt;code&gt;CALL&lt;/code&gt;d:</source>
          <target state="translated">서브 루틴이 &lt;code&gt;CALL&lt;/code&gt; 일 때 :</target>
        </trans-unit>
        <trans-unit id="6b3f0dcc87d05529aa57daa3996393da6636f775" translate="yes" xml:space="preserve">
          <source>When a user-defined function is executed:</source>
          <target state="translated">사용자 정의 함수가 실행될 때 :</target>
        </trans-unit>
        <trans-unit id="c194fc952fa4a418c7fa17712386ca1ffdddb141" translate="yes" xml:space="preserve">
          <source>When a&lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;ORGANIZATION LINE SEQUENTIAL&lt;/a&gt;) or&lt;code&gt;LINE ADVANCING&lt;/code&gt;(see &lt;a href=&quot;#LINE-ADVANCING&quot;&gt;LINE ADVANCING&lt;/a&gt;) file is closed, a final delimiter sequence will be written to the file to signal the termination point of the final data record in the file. This will only be necessary if the final record written to the file was written with the&lt;code&gt;AFTER ADVANCING&lt;/code&gt;(see &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt;) option.</source>
          <target state="translated">때 &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; (참조 &lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;ORGANIZATION LINE 순차&lt;/a&gt; ) 또는 &lt;code&gt;LINE ADVANCING&lt;/code&gt; (참조 &lt;a href=&quot;#LINE-ADVANCING&quot;&gt;LINE 전진&lt;/a&gt; ) 파일을 닫고, 최종 분리 시퀀스 파일의 최종 데이터 기록의 종료 시점을 알리기 위해 파일에 기록한다. 파일에 기록 된 최종 레코드가 &lt;code&gt;AFTER ADVANCING&lt;/code&gt; ( &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt; 참조 ) 옵션으로 기록 된 경우에만 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="40d9758a601000c88af8c955e6507ffc04cc2191" translate="yes" xml:space="preserve">
          <source>When an alternate entry-point is called, execution within the subroutine will begin at the first executable statement following the&lt;code&gt;ENTRY&lt;/code&gt;statement.</source>
          <target state="translated">대체 진입 점을 호출하면 서브 루틴 내에서 실행이 &lt;code&gt;ENTRY&lt;/code&gt; 문 다음의 첫 번째 실행 문에서 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="92d196d291e628f332ffc42a4d148518815e95a2" translate="yes" xml:space="preserve">
          <source>When an input procedure is used, the procedure(s) specified on the&lt;code&gt;INPUT PROCEDURE&lt;/code&gt;</source>
          <target state="translated">입력 절차를 사용하는 경우 입력 절차에 지정된 &lt;code&gt;INPUT PROCEDURE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a4c9a37d6d2b90cdc80ee4f641c1c61745e1756" translate="yes" xml:space="preserve">
          <source>When an output procedure is used, the procedure(s) specified on the&lt;code&gt;OUTPUT PROCEDURE&lt;/code&gt;</source>
          <target state="translated">출력 절차가 사용되는 경우, &lt;code&gt;OUTPUT PROCEDURE&lt;/code&gt; 에 지정된 절차</target>
        </trans-unit>
        <trans-unit id="93684fea254995b6865fb1a4ab54f6078a0b1615" translate="yes" xml:space="preserve">
          <source>When an output procedure is used, the procedure(s) specified on the&lt;code&gt;OUTPUT PROCEDURE&lt;/code&gt;clause will be invoked as if by a procedural&lt;code&gt;PERFORM&lt;/code&gt;(see &lt;a href=&quot;#Procedural-PERFORM&quot;&gt;Procedural PERFORM&lt;/a&gt;) statement with no&lt;code&gt;VARYING&lt;/code&gt;&lt;code&gt;TIMES&lt;/code&gt;or&lt;code&gt;UNTIL&lt;/code&gt;options specified. Merged records may be read from the merge work file &amp;mdash; one at a time &amp;mdash; within the output procedure using the&lt;code&gt;RETURN&lt;/code&gt;(see &lt;a href=&quot;#RETURN&quot;&gt;RETURN&lt;/a&gt;) statement.</source>
          <target state="translated">출력 프로 시저가 사용될 때, &lt;code&gt;OUTPUT PROCEDURE&lt;/code&gt; 절 에 지정된 프로시 저는 &lt;code&gt;VARYING&lt;/code&gt; &lt;code&gt;TIMES&lt;/code&gt; 또는 &lt;code&gt;UNTIL&lt;/code&gt; 옵션이 지정 되지 않은 &lt;a href=&quot;#Procedural-PERFORM&quot;&gt;프로&lt;/a&gt; 시저 &lt;code&gt;PERFORM&lt;/code&gt; ( 프로 시저 PERFORM 참조 ) 명령문에 의해 호출되는 것처럼 호출됩니다 . 병합 된 레코드는 &lt;code&gt;RETURN&lt;/code&gt; ( &lt;a href=&quot;#RETURN&quot;&gt;RETURN&lt;/a&gt; 참조 ) 문을 사용하여 출력 프로 시저 내에서 병합 작업 파일에서 한 번에 하나씩 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a7ec9aff785eae6a95fe44d95188bd4764eb8f20" translate="yes" xml:space="preserve">
          <source>When an&lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt;file has been successfully read, the file&amp;rsquo;s&lt;code&gt;RELATIVE KEY&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;ORGANIZATION RELATIVE&lt;/a&gt;) field will be automatically populated with the relative record number (ordinal occurrence number) of the record in the file.</source>
          <target state="translated">때 &lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt; 파일이 성공적으로 읽은 파일의 &lt;code&gt;RELATIVE KEY&lt;/code&gt; (참조 &lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;조직 상대적으로&lt;/a&gt; ) 필드는 자동으로 파일의 레코드의 상대 레코드 번호 (서수 발생 번호)로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="b8912a19f17811c2f39822283e113ebcf7a32e2d" translate="yes" xml:space="preserve">
          <source>When any procedure division statement that references procedures is used. These statements are:</source>
          <target state="translated">절차를 참조하는 절차 구분 문이 사용될 때. 이러한 진술은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="146c574872a542aa257d3bc0f72bf6c4b3c7b165" translate="yes" xml:space="preserve">
          <source>When both a&lt;code&gt;TALLYING&lt;/code&gt;and a&lt;code&gt;REPLACING&lt;/code&gt;instruction have been selected for execution, the&lt;code&gt;TALLYING&lt;/code&gt;instruction will be executed first. This guarantees that&lt;code&gt;TALLYING&lt;/code&gt;will compute occurrences based upon the</source>
          <target state="translated">둘 다를 경우 &lt;code&gt;TALLYING&lt;/code&gt; 및 &lt;code&gt;REPLACING&lt;/code&gt; 명령이 실행을 위해 선택되었습니다 &lt;code&gt;TALLYING&lt;/code&gt; 지시가 먼저 실행된다. 이를 통해 &lt;code&gt;TALLYING&lt;/code&gt; 은 다음을 기반으로 발생을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="24eab9fb267801a6ef7bd6685824bbe296e86f53" translate="yes" xml:space="preserve">
          <source>When both&lt;code&gt;REPLACING&lt;/code&gt;and&lt;code&gt;TALLYING&lt;/code&gt;are specified:</source>
          <target state="translated">때 모두 &lt;code&gt;REPLACING&lt;/code&gt; 및 &lt;code&gt;TALLYING&lt;/code&gt; 지정됩니다</target>
        </trans-unit>
        <trans-unit id="7941f0aacf9a7dc1f040df5e95ab186de4cadc32" translate="yes" xml:space="preserve">
          <source>When called from a main program, the returned value will always be 0.</source>
          <target state="translated">메인 프로그램에서 호출 될 때 반환되는 값은 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="2cc80ec14d3e2b6d6e5c2a0277fa1296504b79a1" translate="yes" xml:space="preserve">
          <source>When chaining multiple, similar conditions together with the same operator (OR/AND), and left or right arguments have common subjects, it is possible to abbreviate the program code. For example:</source>
          <target state="translated">동일한 연산자 (OR / AND)와 함께 여러 개의 유사한 조건을 연결하고 왼쪽 또는 오른쪽 인수에 공통 주제가있는 경우 프로그램 코드를 축약 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f2ed9ec2463a0d709bd1b56388694f65c1fa1e8b" translate="yes" xml:space="preserve">
          <source>When coding a GnuCOBOL subprogram (a subroutine or user-defined function), all arguments to the subprogram must be defined in the subprogram&amp;rsquo;s linkage section.</source>
          <target state="translated">GnuCOBOL 서브 프로그램 (서브 루틴 또는 사용자 정의 함수)을 코딩 할 때 서브 프로그램의 모든 인수는 서브 프로그램의 링크 섹션에 정의되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1b1d786daa32294159fc0ca54e3d597c33137bce" translate="yes" xml:space="preserve">
          <source>When comparing one numeric value to another, the&lt;code&gt;USAGE&lt;/code&gt;(see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) and number of significant digits in either value are irrelevant as the comparison is performed using the actual algebraic values.</source>
          <target state="translated">다른 하나 개의 수치를 비교하면, &lt;code&gt;USAGE&lt;/code&gt; 는 (참조 &lt;a href=&quot;#USAGE&quot;&gt;사용&lt;/a&gt; ) 및 비교는 실제의 대수 값을 이용하여 수행됨에 따라 어느 값이 유효 숫자의 수는 적합하다.</target>
        </trans-unit>
        <trans-unit id="5173647e20c2eb250053e19884f9ad6c1ef4fdf3" translate="yes" xml:space="preserve">
          <source>When comparing strings, the comparison is made based upon the program&amp;rsquo;s collating sequence. When the two string arguments are of unequal length, the shorter is assumed to be padded (on the right) with a sufficient number of spaces as to make the two strings of equal length. String comparisons take place on a corresponding character-by-character basis, left to right, until the TRUE/FALSE value for the relation test can be established. Characters are compared according to their relative position in the program&amp;rsquo;s&lt;code&gt;COLLATING SEQUENCE&lt;/code&gt;(as defined in&lt;code&gt;SPECIAL-NAMES&lt;/code&gt;(see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;)),</source>
          <target state="translated">문자열을 비교할 때 프로그램의 조합 순서에 따라 비교가 이루어집니다. 두 문자열 인수의 길이가 동일하지 않은 경우 두 문자열을 같은 길이로 만들기에 충분한 수의 공백으로 더 짧은 것으로 채워집니다 (오른쪽). 문자열 비교는 관계 테스트에 대한 TRUE / FALSE 값이 설정 될 때까지 왼쪽에서 오른쪽으로 해당 문자별로 수행됩니다. 문자는 프로그램의 &lt;code&gt;COLLATING SEQUENCE&lt;/code&gt; ( &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; ( &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt; 참조)에 정의 된)에서 상대 위치에 따라 비교됩니다 .</target>
        </trans-unit>
        <trans-unit id="d9b3397e0799dd72dda73077c1607271c7cf700e" translate="yes" xml:space="preserve">
          <source>When corresponding matches are established, the effect of a&lt;code&gt;MOVE CORRESPONDING&lt;/code&gt;on those matches will be as if a series of individual&lt;code&gt;MOVE&lt;/code&gt; were done &amp;mdash; one for each match.</source>
          <target state="translated">해당 일치가 설정되면 해당 일치에 대한 &lt;code&gt;MOVE CORRESPONDING&lt;/code&gt; 의 효과 는 일련의 개별 &lt;code&gt;MOVE&lt;/code&gt; 가 수행 된 것처럼 (매 일치마다 하나씩)됩니다.</target>
        </trans-unit>
        <trans-unit id="41a918721b83779c30ebf56d095541b79d4dacdc" translate="yes" xml:space="preserve">
          <source>When describing a report via the&lt;code&gt;RD&lt;/code&gt;(see &lt;a href=&quot;#REPORT-SECTION&quot;&gt;REPORT SECTION&lt;/a&gt;) clause, the total number of usable lines are specified as the&lt;code&gt;PAGE LIMIT&lt;/code&gt;value; this value is the sum of the number of lines contained in the Heading, Body and Footing Areas.</source>
          <target state="translated">&lt;code&gt;RD&lt;/code&gt; ( &lt;a href=&quot;#REPORT-SECTION&quot;&gt;보고서 섹션&lt;/a&gt; 참조 ) 절을 통해 보고서를 설명 할 때 사용 가능한 총 행 수는 &lt;code&gt;PAGE LIMIT&lt;/code&gt; 값 으로 지정됩니다 . 이 값은 제목, 본문 및 기초 영역에 포함 된 줄 수의 합계입니다.</target>
        </trans-unit>
        <trans-unit id="39392c2e6fa180cc814e786c6003f2f16a336a4e" translate="yes" xml:space="preserve">
          <source>When describing data hierarchies, you may never use a level number greater than 49 (except for 66, 77, 78 and 88 which have very special meanings &amp;mdash; see see &lt;a href=&quot;#Special-Data-Items&quot;&gt;Special Data Items&lt;/a&gt;).</source>
          <target state="translated">데이터 계층을 설명 할 때는 49보다 큰 레벨 번호를 사용할 수 없습니다 (66, 77, 78 및 88은 매우 특별한 의미가 있습니다 ( &lt;a href=&quot;#Special-Data-Items&quot;&gt;특별 데이터 항목&lt;/a&gt; 참조) 참조 ).</target>
        </trans-unit>
        <trans-unit id="3c5513aeebcad1e2856cc9f8d4cb7d2f2eaec2c2" translate="yes" xml:space="preserve">
          <source>When displaying upon the&lt;code&gt;CONSOLE&lt;/code&gt;&lt;code&gt;PRINTER&lt;/code&gt;&lt;code&gt;STDOUT&lt;/code&gt;&lt;code&gt;SYSLIST&lt;/code&gt;&lt;code&gt;SYSLST&lt;/code&gt;or&lt;code&gt;SYSOUT&lt;/code&gt;devices or to a &amp;lt;</source>
          <target state="translated">에 표시 할 때 &lt;code&gt;CONSOLE&lt;/code&gt; &lt;code&gt;PRINTER&lt;/code&gt; &lt;code&gt;STDOUT&lt;/code&gt; &lt;code&gt;SYSLIST&lt;/code&gt; &lt;code&gt;SYSLST&lt;/code&gt; 또는 &lt;code&gt;SYSOUT&lt;/code&gt; 장치 또는로 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="655d94f947c604b783209f57f37ba32fc344e54d" translate="yes" xml:space="preserve">
          <source>When displaying upon the&lt;code&gt;STDERR&lt;/code&gt;or&lt;code&gt;SYSERR&lt;/code&gt;devices or to a &amp;lt;</source>
          <target state="translated">에 표시 할 때 &lt;code&gt;STDERR&lt;/code&gt; 또는 &lt;code&gt;SYSERR&lt;/code&gt; 장치 또는로 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="bbb1f161357d396c754cf54ef943e316e55193af" translate="yes" xml:space="preserve">
          <source>When executed, this program produces the following output:</source>
          <target state="translated">실행될 때이 프로그램은 다음과 같은 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1144df86ac6d48e9fa3c46d5a49a748eabd886e5" translate="yes" xml:space="preserve">
          <source>When executed, this sample program generates the following console output.</source>
          <target state="translated">이 샘플 프로그램을 실행하면 다음과 같은 콘솔 출력이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="204809fb0c4c4ee192c241c5223178a3a7e57dd4" translate="yes" xml:space="preserve">
          <source>When group items are being defined, subordinate items may be assigned a&lt;code&gt;name&lt;/code&gt;of&lt;code&gt;FILLER&lt;/code&gt;</source>
          <target state="translated">그룹 항목을 정의 할 때 하위 항목 에 &lt;code&gt;FILLER&lt;/code&gt; &lt;code&gt;name&lt;/code&gt; 이 할당 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81cc473530e4b89a1df51da3c3b3540a6bfb4031" translate="yes" xml:space="preserve">
          <source>When it first was developed, Cobol&amp;rsquo;s easily-readable syntax made it profoundly different from anything that had been seen before. For the first time, it was possible to specify logic in a manner that was &amp;mdash; at least to some extent &amp;mdash; comprehensible even to non-programmers. Take for example, the following code written in FORTRAN &amp;mdash; a language developed only a year before COBOL:</source>
          <target state="translated">처음 개발되었을 때, Cobol의 쉽게 읽을 수있는 구문은 이전에 보았던 것과는 크게 달랐습니다. 처음으로, 프로그래머가 아닌 사람도 이해할 수있는 방식으로 논리를 지정할 수있었습니다. 예를 들어, COBOL 1 년 전에 개발 된 언어 인 FORTRAN으로 작성된 다음 코드를 생각해보십시오.</target>
        </trans-unit>
        <trans-unit id="4f44d0cc215e6bf095db28c3b9429a71f8b099ef" translate="yes" xml:space="preserve">
          <source>When making an attribute change to &amp;lt;</source>
          <target state="translated">속성을 &amp;lt;로 변경하면</target>
        </trans-unit>
        <trans-unit id="765347088d1cd595526699fe437b6c492beff319" translate="yes" xml:space="preserve">
          <source>When multiple floating symbols are coded, even if there is only one of them used they will all be considered floating and will all be able to assume each other&amp;rsquo;s properties. For example, if a data item has a&lt;code&gt;PIC +$ZZZZ9.99&lt;/code&gt;&amp;lt;</source>
          <target state="translated">여러 개의 부동 기호가 코딩 될 때, 그 중 하나만 사용 된 경우에도 모두 부동으로 간주되며 서로의 속성을 가정 할 수 있습니다. 예를 들어 데이터 항목에 &lt;code&gt;PIC +$ZZZZ9.99&lt;/code&gt; &amp;lt;</target>
        </trans-unit>
        <trans-unit id="357bac3f35e4cad10100a74fa4de493239fed268" translate="yes" xml:space="preserve">
          <source>When multiple programs occur in a source file, it is assumed that the programs are related to one another in that they will be CALLed or executed as functions from the others.</source>
          <target state="translated">소스 파일에서 여러 프로그램이 발생하면 프로그램이 다른 프로그램의 함수로 호출되거나 실행될 것이라는 점에서 프로그램이 서로 관련되어 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="ee4d022507775e46145db061fb817e298c431714" translate="yes" xml:space="preserve">
          <source>When only a portion of a reserved word is underlined, it indicates that the word may either be coded in its full form or may be abbreviated to the portion that is underlined.</source>
          <target state="translated">예약어의 일부에만 밑줄이있는 경우, 단어가 전체 형식으로 코딩되었거나 밑줄이있는 부분으로 축약 될 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="16b43a9e336b11f14ff5999514c47a3da0207e37" translate="yes" xml:space="preserve">
          <source>When program &quot;A&quot; invokes program &quot;B&quot; as a &amp;rsquo;</source>
          <target state="translated">프로그램 &quot;A&quot;가 &quot;B&quot;프로그램을 '</target>
        </trans-unit>
        <trans-unit id="cb631f6f2ec2e69653942f71a148c4d305b9976c" translate="yes" xml:space="preserve">
          <source>When program &quot;A&quot; invokes subprogram &quot;B&quot; as a &amp;rsquo;</source>
          <target state="translated">프로그램 &quot;A&quot;가 서브 프로그램 &quot;B&quot;를 '</target>
        </trans-unit>
        <trans-unit id="24575c99a46bc504177bdf4d662ceef89ceff979" translate="yes" xml:space="preserve">
          <source>When programs get very large, it becomes more and more challenging to keep track of the data items that will be used in the program. Here, in no particular order of importance, are a variety of conventions that can simply that problem.</source>
          <target state="translated">프로그램이 매우 커지면 프로그램에서 사용될 데이터 항목을 추적하는 것이 점점 더 어려워집니다. 여기서 중요한 순서는 아니지만 단순히 그 문제를 해결할 수있는 다양한 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="12f9d3bfdb77a158eebc43ccf582ee2143f458e5" translate="yes" xml:space="preserve">
          <source>When reading a&lt;code&gt;LINE SEQUENTIAL&lt;/code&gt;file, records in excess of the size implied by the file&amp;rsquo;s description in the&lt;code&gt;FILE SECTION&lt;/code&gt;will be truncated while records shorter than that size will be padded to the right with&lt;code&gt;SPACES&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;LINE SEQUENTIAL&lt;/code&gt; 파일을 읽을 때 &lt;code&gt;FILE SECTION&lt;/code&gt; 에서 파일 설명에 의해 암시 된 크기를 초과 하는 레코드는 절단되고 해당 크기보다 짧은 레코드는 &lt;code&gt;SPACES&lt;/code&gt; 로 오른쪽에 채워집니다</target>
        </trans-unit>
        <trans-unit id="0e7557431ef7c1f77d37d108a31fd016e5ee22c0" translate="yes" xml:space="preserve">
          <source>When reading any sequential (any organization) or relative file, the &quot;next&quot; direction refers to the physical sequence of records in the file. When reading an indexed file, the &quot;next&quot; and &quot;previous&quot; directions refer to the sequence of primary or alternate record key values in the file&amp;rsquo;s records, regardless of where the records physically occur within the file.</source>
          <target state="translated">순차 (모든 조직) 또는 상대 파일을 읽을 때 &quot;다음&quot;방향은 파일의 실제 레코드 순서를 나타냅니다. 인덱스 파일을 읽을 때 &quot;다음&quot;및 &quot;이전&quot;방향은 파일 내에서 레코드가 실제로 발생하는 위치에 관계없이 파일 레코드의 기본 또는 대체 레코드 키 값 시퀀스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3f6d782d21d25a325bf3c06a721b2e954c4410af" translate="yes" xml:space="preserve">
          <source>When reserved words appear without underlining, as this one is, they are optional; such reserved words are available in the language syntax merely to improve readability &amp;mdash; their presence or absence has no effect upon the program.</source>
          <target state="translated">예약어가 밑줄없이 나타나면이 단어는 선택 사항입니다. 이러한 예약어는 가독성을 향상시키기 위해 언어 구문으로 제공됩니다. 존재 여부는 프로그램에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9bf691cf2e7161985065f654248401fc0ecfeb3b" translate="yes" xml:space="preserve">
          <source>When searching a table with &quot;n&quot; entries, a binary search will need a worst-case of log2(n) tests in order to find an entry and log2(n) tests to identify that an entry doesn&amp;rsquo;t exist (n = the number of entries in the table), where &quot;log2&quot; is the base-2 logarithm function.</source>
          <target state="translated">&quot;n&quot;항목이있는 테이블을 검색 할 때 이진 검색은 항목을 찾기 위해 최악의 경우 log2 (n) 테스트와 항목이 존재하지 않는 것을 식별하기 위해 log2 (n) 테스트가 필요합니다 (n = the &quot;log2&quot;는 밑이 2 인 로그 함수입니다.</target>
        </trans-unit>
        <trans-unit id="7f79e279fbc5ca83bb92ac3dcf632fe2490e114e" translate="yes" xml:space="preserve">
          <source>When searching a table with &quot;n&quot; entries, a sequential search will need an average of n/2 tests and a worst case of n tests in order to find an entry and n tests to identify that an entry doesn&amp;rsquo;t exist.</source>
          <target state="translated">&quot;n&quot;항목이있는 테이블을 검색 할 때, 순차 검색에는 항목을 찾기 위해 평균 n / 2 테스트와 최악의 n 테스트가 필요하고 항목이 존재하지 않음을 식별하기 위해 n 테스트가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1ead7f9a0129742e47eb21548cb149b2afd83a4f" translate="yes" xml:space="preserve">
          <source>When single record locking is in-effect, as a new record is accessed, locks held for previous records are released. By using this option, not only is the newly-accessed record locked (as WITH LOCK would do), but prior record locks will be retained as well. A subsequent&lt;code&gt;READ&lt;/code&gt;without the&lt;code&gt;KEPT LOCK&lt;/code&gt;option will release all &quot;kept&quot; locks, as will the&lt;code&gt;UNLOCK&lt;/code&gt;statement.</source>
          <target state="translated">단일 레코드 잠금이 영향을받는 경우 새 레코드에 액세스 할 때 이전 레코드에 대해 보유 된 잠금이 해제됩니다. 이 옵션을 사용하면 WITH LOCK처럼 새로 액세스 한 레코드가 잠길뿐만 아니라 이전 레코드 잠금도 유지됩니다. &lt;code&gt;KEPT LOCK&lt;/code&gt; 옵션이 없는 후속 &lt;code&gt;READ&lt;/code&gt; 는 &lt;code&gt;UNLOCK&lt;/code&gt; 문과 마찬가지로 모든 &quot;kept&quot;잠금을 해제 합니다.</target>
        </trans-unit>
        <trans-unit id="ba00b2b56dccc0c37a2385d169dfa2ac94c0801e" translate="yes" xml:space="preserve">
          <source>When specifying&lt;code&gt;FALSE&lt;/code&gt; the value assigned to each parent data item will be the value specified for the&lt;code&gt;FALSE&lt;/code&gt;clause of the condition name&amp;rsquo;s definition; if any &amp;lt;</source>
          <target state="translated">&lt;code&gt;FALSE&lt;/code&gt; 를 지정할 때 각 상위 데이터 항목에 지정된 값 은 조건 이름 정의 의 &lt;code&gt;FALSE&lt;/code&gt; 절에 지정된 값입니다 . 만약에 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="4356780039a5293c513a6b6cd5c3842864bda12f" translate="yes" xml:space="preserve">
          <source>When specifying&lt;code&gt;TRUE&lt;/code&gt; the value assigned to each parent data item will be the first value specified on the condition name&amp;rsquo;s&lt;code&gt;VALUE&lt;/code&gt;clause.</source>
          <target state="translated">지정하는 경우 &lt;code&gt;TRUE&lt;/code&gt; 각 상위 데이터 항목에 할당 된 값은 조건 이름의에 지정된 첫 번째 값이됩니다 &lt;code&gt;VALUE&lt;/code&gt; 의 절.</target>
        </trans-unit>
        <trans-unit id="3567380cba462a3ad588bf15ca96ed5e4b76ffa4" translate="yes" xml:space="preserve">
          <source>When the &amp;lt;</source>
          <target state="translated">때 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="ecb5c7291bd4406532b8655fe4140ec4851a635e" translate="yes" xml:space="preserve">
          <source>When the &amp;rsquo;Enter&amp;rsquo; key is pressed.</source>
          <target state="translated">'Enter'키를 누를 때</target>
        </trans-unit>
        <trans-unit id="eec1d6e3a7e2975948f245e3fa65949ec9243c1e" translate="yes" xml:space="preserve">
          <source>When the character set in use is ASCII with no collating sequence modifications, the&lt;code&gt;LOW-VALUES&lt;/code&gt;figurative constant value is the ASCII &quot;NUL&quot; character. Because character sets can be redefined, however, you should not rely on this fact &amp;mdash; use the&lt;code&gt;NULL&lt;/code&gt;figurative constant instead.</source>
          <target state="translated">사용중인 문자 세트가 배열 순서를 수정하지 않은 ASCII 인 경우 &lt;code&gt;LOW-VALUES&lt;/code&gt; 형상 상수 값은 ASCII &quot;NUL&quot;문자입니다. 그러나 문자 집합을 재정의 할 수 있기 때문에이 사실에 의존해서는 안됩니다 . 대신 &lt;code&gt;NULL&lt;/code&gt; 비유 상수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2dadab11f4931efd0eadc4c86b99fe85b231c15c" translate="yes" xml:space="preserve">
          <source>When the compiler is operating in Fixed Format Mode, all CDF statements must begin in column eight (8) or beyond.</source>
          <target state="translated">컴파일러가 고정 형식 모드에서 작동하는 경우 모든 CDF 문은 8 열 이상에서 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="40abc34cb1f8c895d660e103e7ef08d30419b512" translate="yes" xml:space="preserve">
          <source>When the console is running in a windowed environment, this will be the sizing of the window in which the program is executing, in terms of horizontal &lt;code&gt;COLUMNS&lt;/code&gt; or vertical &lt;code&gt;LINES&lt;/code&gt; character counts &amp;mdash; not pixels.</source>
          <target state="translated">콘솔이 윈도우 환경에서 실행될 때, 이것은 픽셀이 아닌 수평 &lt;code&gt;COLUMNS&lt;/code&gt; 또는 수직 &lt;code&gt;LINES&lt;/code&gt; 문자 수 와 관련하여 프로그램이 실행되는 창의 크기입니다 .</target>
        </trans-unit>
        <trans-unit id="49d311bd71e37ea88f80c1acf5a46cc2cd7e9896" translate="yes" xml:space="preserve">
          <source>When the end of the currently-compiling source file is reached, Replace Mode is deactivated and any stacked replace specifications will be discarded &amp;mdash; compilation of the next source file (if any) will begin with Replace Mode inactive and no change specification(s) on the stack.</source>
          <target state="translated">현재 컴파일중인 소스 파일의 끝에 도달하면 교체 모드가 비활성화되고 스택 된 교체 사양이 모두 폐기됩니다. 다음 소스 파일 (있는 경우)의 컴파일은 교체 모드가 비활성화 된 상태에서 시작되고 변경 사양은 없습니다. 스택.</target>
        </trans-unit>
        <trans-unit id="2227a36d5cd7f4d291abcce4764658ad8567a554" translate="yes" xml:space="preserve">
          <source>When the file is read, the GnuCOBOL runtime system will strip the trailing delimiter sequence from each record. The data will be padded (on the right) with spaces if the data just read is shorter than the area described for data records in the program. If the data is too long, it will be truncated and the excess will be lost.</source>
          <target state="translated">파일을 읽을 때 GnuCOBOL 런타임 시스템은 각 레코드에서 후행 구분 기호 시퀀스를 제거합니다. 방금 읽은 데이터가 프로그램의 데이터 레코드에 대해 설명 된 영역보다 짧은 경우 데이터는 공백으로 채워집니다 (오른쪽). 데이터가 너무 길면 잘리고 초과분이 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="4eebc909f1695d64257ea0ebfb9c8ad6e5e72760" translate="yes" xml:space="preserve">
          <source>When the file is read, the data is transferred into the program exactly as it exists in the file.</source>
          <target state="translated">파일을 읽을 때 데이터는 파일에있는 그대로 프로그램으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="1095f382913505e70906f62a227a9960253628ee" translate="yes" xml:space="preserve">
          <source>When the file is read, the data is transferred into the program exactly as it exists in the file. In the event that a short record is read as the very last record, that record will be padded (to the right) with spaces.</source>
          <target state="translated">파일을 읽을 때 데이터는 파일에있는 그대로 프로그램으로 전송됩니다. 짧은 레코드를 마지막 레코드로 읽는 경우 해당 레코드는 공백으로 채워집니다 (오른쪽).</target>
        </trans-unit>
        <trans-unit id="4714998234fd85ca6aacf95b1f60fc2e0606d179" translate="yes" xml:space="preserve">
          <source>When the file is written by a GnuCOBOL program, no delimiter sequence is appended to the data, but a record-length field is added to the beginning of each physical record.</source>
          <target state="translated">파일이 GnuCOBOL 프로그램에 의해 작성되면 구분 기호 시퀀스가 ​​데이터에 추가되지 않지만 레코드 길이 필드는 각 실제 레코드의 시작 부분에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="81691df2003fd4bbec12f9dc36d30933f837ffbe" translate="yes" xml:space="preserve">
          <source>When the file is written to by a GnuCOBOL program, the delimiter sequence will be automatically appended to each data record as it is written to the file. A&lt;code&gt;WRITE&lt;/code&gt;(see &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt;) to this type of file will be done as if a&lt;code&gt;BEFORE ADVANCING 1 LINE&lt;/code&gt;clause were specified on the&lt;code&gt;WRITE&lt;/code&gt; if no&lt;code&gt;ADVANCING&lt;/code&gt;clause is coded.</source>
          <target state="translated">파일이 GnuCOBOL 프로그램에 의해 쓰여질 때, 분리 문자 시퀀스는 파일에 쓰여질 때 각 데이터 레코드에 자동으로 추가됩니다. &lt;code&gt;WRITE&lt;/code&gt; (참조 &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt; 것처럼이 유형의 파일에)가 수행됩니다 &lt;code&gt;BEFORE ADVANCING 1 LINE&lt;/code&gt; 절을에 지정된 &lt;code&gt;WRITE&lt;/code&gt; 어떤 경우 &lt;code&gt;ADVANCING&lt;/code&gt; 절을 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f1c4a220f73cf6e6321e6a87a7569c10ca47095d" translate="yes" xml:space="preserve">
          <source>When the first&lt;code&gt;GENERATE&lt;/code&gt;statement for a report is executed, the contents of all control fields are saved so they may be referenced during the processing of subsequent&lt;code&gt;GENERATE&lt;/code&gt;statements.</source>
          <target state="translated">보고서 의 첫 번째 &lt;code&gt;GENERATE&lt;/code&gt; 문이 실행될 때 모든 제어 필드의 컨텐츠가 저장되어 후속 &lt;code&gt;GENERATE&lt;/code&gt; 문 처리 중에 참조 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="074e2dcc44a417676e5996468b40ba0494eff2f2" translate="yes" xml:space="preserve">
          <source>When the program runs, it produces the output:</source>
          <target state="translated">프로그램이 실행되면 출력이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a8010d73ef14277722d75fc16df53fde2a0c078f" translate="yes" xml:space="preserve">
          <source>When the report group containing this clause is presented, the value of the specified numeric literal or identifier will be automatically moved to the report data item prior to presentation.</source>
          <target state="translated">이 절을 포함하는 보고서 그룹이 표시되면 지정된 숫자 리터럴 또는 식별자의 값이 프리젠 테이션 전에 보고서 데이터 항목으로 자동 이동됩니다.</target>
        </trans-unit>
        <trans-unit id="f3c5fe04ca5c5ff54e7b4c5484bdebe852cb3224" translate="yes" xml:space="preserve">
          <source>When the report is defined, it&amp;rsquo;s&lt;code&gt;RD&lt;/code&gt;would contain a&lt;code&gt;CONTROLS ARE&lt;/code&gt;clause that lists the control breaks in least- to most-frequent sequence of changing. This would be coded as:</source>
          <target state="translated">보고서가 정의되면 &lt;code&gt;RD&lt;/code&gt; 에는 &lt;code&gt;CONTROLS ARE&lt;/code&gt; 절이 포함되어 있으며 가장 자주 또는 가장 자주 변경되는 순서대로 제어 구분을 나열합니다. 이것은 다음과 같이 코딩됩니다 :</target>
        </trans-unit>
        <trans-unit id="bcfb647dc5347cb77600489e720593442321749d" translate="yes" xml:space="preserve">
          <source>When the screen item whose definition this clause is part of (or its parent) is accepted, the current contents of the screen item will be saved back to &amp;lt;</source>
          <target state="translated">이 항목의 정의가 부모 (또는 그 상위) 인 화면 항목이 승인되면 화면 항목의 현재 내용이 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="695d50e951aec5be635277efb4ba5d0a5d981166" translate="yes" xml:space="preserve">
          <source>When the screen item whose definition this clause is part of is displayed, the value currently in &amp;lt;</source>
          <target state="translated">이 절이 정의 된 화면 항목이 표시되면 현재 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="07b8542ab787f6c8b8c395ad790e2a6b7ca2ff49" translate="yes" xml:space="preserve">
          <source>When the statements within the perform scope terminate the loop iteration, by&amp;hellip;</source>
          <target state="translated">수행 범위 내의 명령문이 루프 반복을 종료하면</target>
        </trans-unit>
        <trans-unit id="69280dd9886752b96dbde5900ee345503734c4e6" translate="yes" xml:space="preserve">
          <source>When the system is not running a windowing environment, the physical console screen attributes will be returned.</source>
          <target state="translated">시스템이 윈도우 환경을 실행하지 않으면 실제 콘솔 화면 속성이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f718469daec1d449d89ac94fc080a888412ff614" translate="yes" xml:space="preserve">
          <source>When the system is running in a windowed environment, this will be the sizing of the console window in which the program is executing. When the system is not running a windowing environment, the physical console screen attributes will be returned. In environments such as a Windows console window, where the logical size of the window may far exceed that of the physical console window, the size returned will be that of the physical console window. Two one-byte values will be returned &amp;mdash; the first will be the current number of lines (rows) while the second will be the number of columns.</source>
          <target state="translated">시스템이 창 환경에서 실행될 때 프로그램이 실행되는 콘솔 창의 크기가됩니다. 시스템이 윈도우 환경을 실행하지 않으면 실제 콘솔 화면 속성이 리턴됩니다. 창의 콘솔 크기가 실제 콘솔 창의 크기를 훨씬 초과 할 수있는 Windows 콘솔 창의 환경에서는 리턴되는 크기가 실제 콘솔 창의 크기가됩니다. 두 개의 1 바이트 값이 리턴됩니다. 첫 번째는 현재 행 수 (행)이고 두 번째는 열 수입니다.</target>
        </trans-unit>
        <trans-unit id="4bd372c2bfab46fb27f74cff162404f89944fc1c" translate="yes" xml:space="preserve">
          <source>When the&lt;code&gt;&amp;lt;&lt;i&gt;expression-1&lt;/i&gt;&amp;gt; CHARACTERS&lt;/code&gt;option is used,&lt;code&gt;INITIALIZED&lt;/code&gt;will initialize the allocated memory block to binary zeros. If&lt;code&gt;INITIALIZED&lt;/code&gt;is not used, the initial contents of allocated memory will be left to whatever rules of memory allocation are in effect for the operating system the program is running under.</source>
          <target state="translated">때 &lt;code&gt;&amp;lt;&lt;i&gt;expression-1&lt;/i&gt;&amp;gt; CHARACTERS&lt;/code&gt; 옵션이 사용된다 &lt;code&gt;INITIALIZED&lt;/code&gt; 는 진 0에 할당 된 메모리 블록을 초기화한다. 경우 &lt;code&gt;INITIALIZED&lt;/code&gt; 가 사용되지 않는, 할당 된 메모리의 초기 내용은 메모리 할당의 규칙은 프로그램이 실행중인 운영 체제에 적용되는 무엇에 남아있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="2d804e2ac555d7cf12d198a962f66c87e56b175e" translate="yes" xml:space="preserve">
          <source>When the&lt;code&gt;-m&lt;/code&gt;switch is used, an operating-system specific dynamically-loadable module is generated</source>
          <target state="translated">때 &lt;code&gt;-m&lt;/code&gt; 스위치가 사용되며, 운영 시스템 특정 동적으로로드 가능한 모듈을 생성</target>
        </trans-unit>
        <trans-unit id="13f46effb41077b1e944109400444a4ff5cd4992" translate="yes" xml:space="preserve">
          <source>When the&lt;code&gt;ADDRESS OF&lt;/code&gt;</source>
          <target state="translated">때 &lt;code&gt;ADDRESS OF&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d289ba86ffbf5db049321c033b99dd64249f3f0f" translate="yes" xml:space="preserve">
          <source>When the&lt;code&gt;ADDRESS OF&lt;/code&gt;clause is used</source>
          <target state="translated">때 &lt;code&gt;ADDRESS OF&lt;/code&gt; 절 사용</target>
        </trans-unit>
        <trans-unit id="a8b9a2b204f8e6e0ca17a32a4de5e1a2e43de083" translate="yes" xml:space="preserve">
          <source>When the&lt;code&gt;ALLOCATE&lt;/code&gt;statement (see &lt;a href=&quot;#ALLOCATE&quot;&gt;ALLOCATE&lt;/a&gt;) statement is used to allocate a data item or to simply allocate an area of storage of a size specified on the&lt;code&gt;ALLOCATE&lt;/code&gt; that allocation may occur with or without initialization, as per the programmer&amp;rsquo;s needs.</source>
          <target state="translated">(가)하면 &lt;code&gt;ALLOCATE&lt;/code&gt; 문 (참조 &lt;a href=&quot;#ALLOCATE&quot;&gt;ALLOCATE&lt;/a&gt; 단순히 지정 사이즈의 기억 영역을 할당 문 데이터 항목을 할당하는 데 사용되거나) &lt;code&gt;ALLOCATE&lt;/code&gt; 프로그래머의 요구에 따라, 또는 초기화없이 발생할 수있는 할당.</target>
        </trans-unit>
        <trans-unit id="74a04afcd016118307ae353a14ee261c728b8565" translate="yes" xml:space="preserve">
          <source>When the&lt;code&gt;ENTRY&lt;/code&gt;statement (see &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY&lt;/a&gt;) is being used.</source>
          <target state="translated">때 &lt;code&gt;ENTRY&lt;/code&gt; 의 문 (참조 &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY을&lt;/a&gt; )를 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="5250dcf950b00231f60ea92c0ea15f05da5cadc0" translate="yes" xml:space="preserve">
          <source>When the&lt;code&gt;PERFORM&lt;/code&gt;begins execution, the&lt;code&gt;FROM&lt;/code&gt;value will be moved to &amp;lt;</source>
          <target state="translated">(가)하면 &lt;code&gt;PERFORM&lt;/code&gt; 실행 시작은 &lt;code&gt;FROM&lt;/code&gt; 값으로 이동한다 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="72447040e7a4b4f4bf2a5e524fd5777a11ef4d60" translate="yes" xml:space="preserve">
          <source>When there</source>
          <target state="translated">있을 때</target>
        </trans-unit>
        <trans-unit id="d0ccd0b2ea32415458ae1ae69c697ed322392468" translate="yes" xml:space="preserve">
          <source>When this clause is present, the data item in question will be presented only under the following circumstances:</source>
          <target state="translated">이 항목이 존재하면 해당 데이터 항목은 다음 상황에서만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="aabb87d78c631aff329a8607b2f22afa622c4b99" translate="yes" xml:space="preserve">
          <source>When this form of an&lt;code&gt;EXIT&lt;/code&gt;statement is used, it must be the only statement in the procedure (paragraph or section) in which it occurs.</source>
          <target state="translated">이 형식의 &lt;code&gt;EXIT&lt;/code&gt; 문을 사용하는 경우, 프로 시저 (문단 또는 섹션)에서 발생하는 유일한 명령문이어야합니다.</target>
        </trans-unit>
        <trans-unit id="97b30ad0f25dcade2d01e3738933c789a0d0e584" translate="yes" xml:space="preserve">
          <source>When this kind of file is written to by a GnuCOBOL program, an end-of-record delimiter sequence will be automatically added to each data record as it is written to the file. A&lt;code&gt;WRITE&lt;/code&gt;to this type of file will be done as if an&lt;code&gt;AFTER ADVANCING 1 LINE&lt;/code&gt;clause were specified on the&lt;code&gt;WRITE&lt;/code&gt; if no&lt;code&gt;ADVANCING&lt;/code&gt;clause is coded.</source>
          <target state="translated">이런 종류의 파일이 GnuCOBOL 프로그램에 의해 쓰여질 때, 레코드 끝 구분 기호 시퀀스는 파일에 쓰여질 때 각 데이터 레코드에 자동으로 추가됩니다. &lt;code&gt;ADVANCING&lt;/code&gt; 절이 코딩 되지 않은 경우 &lt;code&gt;WRITE&lt;/code&gt; 에 &lt;code&gt;AFTER ADVANCING 1 LINE&lt;/code&gt; 절이 지정된 것처럼이 유형의 파일에 대한 &lt;code&gt;WRITE&lt;/code&gt; 가 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="f0a1df19b6c99bf68d1fce26c8f95a4cf1892a89" translate="yes" xml:space="preserve">
          <source>When unprintable area exists at all four margins of the paper? These are generally caused by the printer itself or by its software driver.</source>
          <target state="translated">용지의 여백에 인쇄 할 수없는 영역이있는 경우 이러한 문제는 일반적으로 프린터 자체 또는 소프트웨어 드라이버로 인해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="194120b0286a35a2dcf5def798c14d60552c4e11" translate="yes" xml:space="preserve">
          <source>When used in the definition of a screen data item:</source>
          <target state="translated">화면 데이터 항목의 정의에 사용되는 경우 :</target>
        </trans-unit>
        <trans-unit id="5d7dee905f968e799c08d314024c914b9335fa97" translate="yes" xml:space="preserve">
          <source>When used on a report section data item,&lt;code&gt;COLUMN PLUS&lt;/code&gt;will position the start of the new field&amp;rsquo;s value such that there are &amp;lt;</source>
          <target state="translated">보고서 섹션 데이터 항목에 사용될 경우 &lt;code&gt;COLUMN PLUS&lt;/code&gt; 는 새 필드 값의 시작 위치를 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="f12387ad8083a72240747b5e731f9f439e5dc6b8" translate="yes" xml:space="preserve">
          <source>When used on a screen section data item,&lt;code&gt;COLUMN PLUS&lt;/code&gt;will position the new field so that it begins exactly &amp;lt;</source>
          <target state="translated">화면 섹션 데이터 항목에서 사용될 경우 &lt;code&gt;COLUMN PLUS&lt;/code&gt; 는 새 필드가 정확하게 시작되도록 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="65aa1415a9565bd8d28746dc9c2570be60594107" translate="yes" xml:space="preserve">
          <source>When used with a&lt;code&gt;MOVE&lt;/code&gt;verb&amp;hellip;</source>
          <target state="translated">&lt;code&gt;MOVE&lt;/code&gt; 동사 와 함께 사용하면 &amp;hellip;</target>
        </trans-unit>
        <trans-unit id="735fedfc0b2cf513cd84398c479056078487c738" translate="yes" xml:space="preserve">
          <source>When used with&lt;code&gt;ADD&lt;/code&gt;or&lt;code&gt;SUBTRACT&lt;/code&gt;verbs, both &amp;lt;</source>
          <target state="translated">&lt;code&gt;ADD&lt;/code&gt; 또는 &lt;code&gt;SUBTRACT&lt;/code&gt; 동사 와 함께 사용하는 경우 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="c148563bd1d3d7efcb2e158a73738fe2860d1763" translate="yes" xml:space="preserve">
          <source>When using&lt;code&gt;THRU&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;THRU&lt;/code&gt; 를 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="3c15ffd2b0bb8da495d78e861fe2dddbedf49918" translate="yes" xml:space="preserve">
          <source>When viewing, note the Default settings.</source>
          <target state="translated">볼 때 기본 설정에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="3a8294f64ceb40348b6de0e74db01a84f5474364" translate="yes" xml:space="preserve">
          <source>When you accept from the&lt;code&gt;COMMAND-LINE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;COMMAND-LINE&lt;/code&gt; 줄에서 수락하면</target>
        </trans-unit>
        <trans-unit id="6bd1b751d7e6715a12fe1f8e23931d88a5a54f9a" translate="yes" xml:space="preserve">
          <source>When you are looking at or editing any large COBOL program that has been created with programming standards that include these two rules, it is always a simple thing to know whether a reference to a procedure is being made to code that exists before or after your current location in the program, simply by comparing the numeric component of the current procedure&amp;rsquo;s name with the one in question.</source>
          <target state="translated">이 두 규칙을 포함하는 프로그래밍 표준으로 작성된 대형 COBOL 프로그램을 보거나 편집 할 때 항상 현재 또는 이전에 존재하는 코드에 대한 프로 시저 참조가 있는지 여부를 아는 것은 간단합니다. 현재 프로 시저 이름의 숫자 구성 요소와 해당 프로 시저의 구성 요소를 비교하여 프로그램의 위치.</target>
        </trans-unit>
        <trans-unit id="c326fe2a33e3eca5f34e00297d48c498f3021042" translate="yes" xml:space="preserve">
          <source>When you call a subroutine using &amp;lt;</source>
          <target state="translated">&amp;lt;를 사용하여 서브 루틴을 호출 할 때</target>
        </trans-unit>
        <trans-unit id="c9af7dd389fd17e7c67b109e83a0d0b301a015b6" translate="yes" xml:space="preserve">
          <source>When your program opens a file with this sharing option in effect, no restrictions will be placed on other programs attempting to&lt;code&gt;OPEN&lt;/code&gt;the file after your program did. This is the default sharing mode.</source>
          <target state="translated">프로그램이 효과에서이 공유 옵션으로 파일을 열 때 제한을 시도하는 다른 프로그램에 배치되지 않습니다 &lt;code&gt;OPEN&lt;/code&gt; 프로그램이 한 후 파일을. 이것이 기본 공유 모드입니다.</target>
        </trans-unit>
        <trans-unit id="12ebbc4e8a1599c7bdbee469dfb83f639975ca1d" translate="yes" xml:space="preserve">
          <source>When your program opens a file with this sharing option in effect, your program announces that it is unwilling to allow any other program to have any access to the file as long as you are using that file;&lt;code&gt;OPEN&lt;/code&gt;attempts made in other programs will fail with a file status of 37 (&quot;PERMISSION DENIED&quot;) until such time as you&lt;code&gt;CLOSE&lt;/code&gt;(see &lt;a href=&quot;#CLOSE&quot;&gt;CLOSE&lt;/a&gt;) the file.</source>
          <target state="translated">프로그램이이 공유 옵션을 사용하여 파일을 열면 프로그램은 해당 파일을 사용하는 한 다른 프로그램이 파일에 액세스 할 수 없다는 것을 알립니다. &lt;code&gt;OPEN&lt;/code&gt; 당신이 같은 다른 프로그램에서 만든 시도 때까지 37의 파일 상태 ( &quot;사용 권한이 거부되었습니다&quot;) 실패합니다 &lt;code&gt;CLOSE&lt;/code&gt; (참조 &lt;a href=&quot;#CLOSE&quot;&gt;CLOSE를&lt;/a&gt; 파일).</target>
        </trans-unit>
        <trans-unit id="989ffa5528ba9c1e7d6cced1426d8c8808d2dc65" translate="yes" xml:space="preserve">
          <source>When, during the processing of a subsequent&lt;code&gt;GENERATE&lt;/code&gt; it is determined that a control field has changed value (ie. a control break has occurred), the appropriate control footing and control heading processing will take place and a snapshot of the current values of all control fields will again be saved.</source>
          <target state="translated">후속 &lt;code&gt;GENERATE&lt;/code&gt; 처리 중에 제어 필드 값이 변경되었다고 판단되면 (즉, 제어 중단이 발생 함) 적절한 제어 푸팅 및 제어 표제 처리가 수행되고 모든 제어의 현재 값에 대한 스냅 샷이 생성됩니다. 필드가 다시 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="aba2821f2c7d19a9257df5bad889f05eefb35aa0" translate="yes" xml:space="preserve">
          <source>When&lt;code&gt;BEFORE ADVANCING&lt;/code&gt;</source>
          <target state="translated">때 &lt;code&gt;BEFORE ADVANCING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="660c42a17efa48500b4895ec5768fbd5f4682f3e" translate="yes" xml:space="preserve">
          <source>When&lt;code&gt;DECLARATIVES&lt;/code&gt;(see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) are specified.</source>
          <target state="translated">때 &lt;code&gt;DECLARATIVES&lt;/code&gt; 는 (참조 &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES를&lt;/a&gt; ) 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="8be9ad62baef7dbf9c77304fcc8e3b58cbb0fc10" translate="yes" xml:space="preserve">
          <source>When&lt;code&gt;GIVING&lt;/code&gt;is specified, none of the &amp;lt;</source>
          <target state="translated">&lt;code&gt;GIVING&lt;/code&gt; 이 지정 되면 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="9f15bbea56b2d4b899e335cb9a345cd9d8f82a29" translate="yes" xml:space="preserve">
          <source>When&lt;code&gt;SEPARATE CHARACTER&lt;/code&gt;is specified, the&lt;code&gt;S&lt;/code&gt;symbol in the data item&amp;rsquo;s&lt;code&gt;PICTURE&lt;/code&gt;must be counted when determining the data item&amp;rsquo;s size.</source>
          <target state="translated">경우 &lt;code&gt;SEPARATE CHARACTER&lt;/code&gt; 지정되면, &lt;code&gt;S&lt;/code&gt; 의 데이터 항목의 상징 &lt;code&gt;PICTURE&lt;/code&gt; 데이터 항목의 크기를 결정할 때 계산해야합니다.</target>
        </trans-unit>
        <trans-unit id="3e42c65e553940b7f9a1f905ef498a75f481d086" translate="yes" xml:space="preserve">
          <source>When&lt;code&gt;USING&lt;/code&gt;</source>
          <target state="translated">When&lt;code&gt;USING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="043b8829b0449fc5ab1a590150209867725cb659" translate="yes" xml:space="preserve">
          <source>When&lt;code&gt;WRITE&lt;/code&gt;is used against an&lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;ORGANIZATION LINE SEQUENTIAL&lt;/a&gt;) file, with or without the&lt;code&gt;LINE ADVANCING&lt;/code&gt;(see &lt;a href=&quot;#LINE-ADVANCING&quot;&gt;LINE ADVANCING&lt;/a&gt;) option, an end-of-record delimiter character sequence will be written to the file to signify where one record ends and the next record begins. This delimiter sequence will be either of the following:</source>
          <target state="translated">때 &lt;code&gt;WRITE&lt;/code&gt; 가 에 사용되는 &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; (참조 &lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;조직 LINE SEQUENTIAL&lt;/a&gt; 와 함께 또는없이, 파일)을 &lt;code&gt;LINE ADVANCING&lt;/code&gt; (참조 &lt;a href=&quot;#LINE-ADVANCING&quot;&gt;LINE 전진&lt;/a&gt; ) 옵션, 최종의 레코드 구분 문자 순서가 파일에 기록 될 위치를 하나 개의 레코드를 의미합니다 종료하고 다음 레코드가 시작됩니다. 이 분리 문자 순서는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="5b508f605ade03c2f540e4f5a3cebc74803e17cc" translate="yes" xml:space="preserve">
          <source>Whenever Gross-Revenue is referenced in calculations, or whenever its value is moved to another data item, the value of Gross-Revenue will be treated as if it is nnn000000, where &amp;rsquo;nnn&amp;rsquo; is the actual value in storage.</source>
          <target state="translated">총 수익이 계산에서 참조되거나 해당 값이 다른 데이터 항목으로 이동 될 때마다 총 수익의 값은 nnn000000 인 것처럼 처리됩니다. 여기서 'nnn'은 스토리지의 실제 값입니다.</target>
        </trans-unit>
        <trans-unit id="785ec59aee9a72bba26200b372a399baa862df4e" translate="yes" xml:space="preserve">
          <source>Whenever the parent data item assumes any value</source>
          <target state="translated">부모 데이터 항목이 값을 가질 때마다</target>
        </trans-unit>
        <trans-unit id="3020ed815683faf46902fc4b199d49c0e3b037f1" translate="yes" xml:space="preserve">
          <source>Whether or not changes made to an argument within a subroutine will be &quot;visible&quot; to the calling program depends on how the argument was passed. There are three ways in which arguments may be passed from a calling program to a subroutine, as defined by the use of optional&lt;code&gt;BY&lt;/code&gt;clauses in the&lt;code&gt;CALL&lt;/code&gt;(see &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt;) statement&amp;rsquo;s list of arguments.</source>
          <target state="translated">서브 루틴 내의 인수에 대한 변경 사항이 호출 프로그램에 &quot;표시&quot;되는지 여부는 인수가 전달 된 방법에 따라 다릅니다. &lt;code&gt;CALL&lt;/code&gt; ( &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt; 참조 ) 명령문의 인수 목록 에서 선택적 &lt;code&gt;BY&lt;/code&gt; 절을 사용하여 정의 된대로 호출 프로그램에서 서브 루틴으로 인수를 전달할 수있는 세 가지 방법이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="993618ed434a2a43305ba7349ec2785f35f4d2db" translate="yes" xml:space="preserve">
          <source>Whether or not this clause operates on Cygwin or UNIX/Linux/OSX systems will depend upon the video attribute capabilities of the terminal output drivers and &amp;rsquo;curses&amp;rsquo; software being used.</source>
          <target state="translated">이 절이 Cygwin 또는 UNIX / Linux / OSX 시스템에서 작동하는지 여부는 사용중인 터미널 출력 드라이버 및 '저주'소프트웨어의 비디오 속성 기능에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="16e0ad6794fdb0dfdd1676519f08a64fbdcb0d14" translate="yes" xml:space="preserve">
          <source>Whether the&lt;code&gt;CANCEL&lt;/code&gt;statement actually physically unloads a dynamically-loaded module or simply marks it as logically-unloaded depends on the use and value of the</source>
          <target state="translated">(가) 여부 &lt;code&gt;CANCEL&lt;/code&gt; 문을 실제로 물리적으로 동적으로로드 된 모듈을 언로드하거나 논리적으로-언로드 단순히 마크의 사용과 값에 따라 달라집니다</target>
        </trans-unit>
        <trans-unit id="6db0e2b97dbdb94af74fc2dc892c61e0833952d1" translate="yes" xml:space="preserve">
          <source>Whew!</source>
          <target state="translated">Whew!</target>
        </trans-unit>
        <trans-unit id="2d2aa5ab115d5ea9193b33a8f0fce25b2e1a1345" translate="yes" xml:space="preserve">
          <source>Whichever is specified &amp;mdash; &amp;lt;</source>
          <target state="translated">어느 것이 지정 되나 &amp;mdash; &amp;lt;</target>
        </trans-unit>
        <trans-unit id="2d9ab71a82ddf03172f5ae146fa990c99623a69e" translate="yes" xml:space="preserve">
          <source>While GnuCOBOL supports few of the OOP programming constructs defined by the COBOL2002 and COBOL20xx standards, it supports every aspect of the ANSI 85 standard and therefore fully meets the needs of points #1 and #2, above. With it&amp;rsquo;s supported feature set (see &lt;a href=&quot;#So-What-is-GnuCOBOL_003f&quot;&gt;So What is GnuCOBOL?&lt;/a&gt;), it provides significant programmer productivity capabilities.</source>
          <target state="translated">GnuCOBOL은 COBOL2002 및 COBOL20xx 표준으로 정의 된 OOP 프로그래밍 구성을 거의 지원하지 않지만 ANSI 85 표준의 모든 측면을 지원하므로 위의 1 번 및 2 번 지점의 요구를 완전히 충족합니다. 지원되는 기능 세트 ( &lt;a href=&quot;#So-What-is-GnuCOBOL_003f&quot;&gt;GnuCOBOL이란 무엇입니까? 참조&lt;/a&gt; )를 통해 중요한 프로그래머 생산성 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cc119e55dcd0c1775da7b76db9572116ad0f404f" translate="yes" xml:space="preserve">
          <source>While an&lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt;file may be defined as having variable-length records, the file will be structured in such a manner as to reserve space for each record equal to the size of the largest possible record as defined by the file&amp;rsquo;s description in the&lt;code&gt;FILE SECTION&lt;/code&gt;</source>
          <target state="translated">동안 &lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt; 에서 파일의 설명에 의해 정의 된 바와 같은 파일이 가변 길이 레코드를 갖는 것으로 정의 될 수있다,이 파일은 각각의 기록 영역을 확보하는 것과 같은 방식으로 구성 될 가능한 최대 기록 크기와 동일 &lt;code&gt;FILE SECTION&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a9b658db9baa0989c9e3b4d3ec36c86799d0b8e0" translate="yes" xml:space="preserve">
          <source>While any COBOL implementation&amp;rsquo;s sort or merge facilities guarantee that records with duplicate key values will be in proper sequence with regard to other records with different key values, they generally make no promises as to the resulting relative sequence of records having duplicate key values with one another.</source>
          <target state="translated">COBOL 구현의 정렬 또는 병합 기능은 중복 키 값을 가진 레코드가 다른 키 값을 가진 다른 레코드와 관련하여 올바른 순서로 유지되도록 보장하지만, 일반적으로 중복 키 값을 갖는 레코드의 상대적 레코드 시퀀스에 대해서는 약속하지 않습니다. .</target>
        </trans-unit>
        <trans-unit id="1c536667b503a5b3159f51a218c42911686d55c2" translate="yes" xml:space="preserve">
          <source>While coding only a single file name (the repeated &amp;lt;</source>
          <target state="translated">단일 파일 이름 만 코딩하는 동안 (반복되는 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="4898f28fd78ff6e887f5e83820e41d22333b3cdf" translate="yes" xml:space="preserve">
          <source>While many technological and procedural developments have made</source>
          <target state="translated">많은 기술 및 절차 적 개발이 이루어졌지만</target>
        </trans-unit>
        <trans-unit id="68135204143b500639be0a19a270194158addb58" translate="yes" xml:space="preserve">
          <source>While records in a&lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt;file may be defined as having variable-length records, the file will be structured in such a manner as to reserve space for each record equal to the size of the largest possible record, based on the file&amp;rsquo;s description in the&lt;code&gt;FILE SECTION&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; 파일의 레코드는 가변 길이 레코드를 갖는 것으로 정의 될 수 있지만, 파일은 파일의 설명에 따라 가능한 최대 레코드 크기와 동일한 각 레코드의 공간을 예약하는 방식으로 구성됩니다. &lt;code&gt;FILE SECTION&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e3cfce579f36338b8d7457dd5cdd72e83934491f" translate="yes" xml:space="preserve">
          <source>While simple, these two programs illustrate the techniques required quite nicely.</source>
          <target state="translated">이 두 프로그램은 단순하지만 필요한 기술을 잘 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a47bb81be25a2cdf3581d7e855505093b3e30386" translate="yes" xml:space="preserve">
          <source>While the actual&lt;code&gt;IDENTIFICATION DIVISION&lt;/code&gt;or&lt;code&gt;ID DIVISION&lt;/code&gt;header is optional, the&lt;code&gt;PROGRAM-ID&lt;/code&gt;/&lt;code&gt;FUNCTION-ID&lt;/code&gt;</source>
          <target state="translated">실제 &lt;code&gt;IDENTIFICATION DIVISION&lt;/code&gt; 또는 &lt;code&gt;ID DIVISION&lt;/code&gt; 헤더는 선택 사항이지만 &lt;code&gt;PROGRAM-ID&lt;/code&gt; / &lt;code&gt;FUNCTION-ID&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="72bf04cdadfed642909255f7fc579bddbbd28879" translate="yes" xml:space="preserve">
          <source>While there will typically be only be a single set of counting instructions on an&lt;code&gt;INSPECT&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;INSPECT&lt;/code&gt; 에는 일반적으로 하나의 카운팅 명령 세트 만 있지만</target>
        </trans-unit>
        <trans-unit id="22879925a3c987ac29988c1ec2fc71f9d9d5a5c1" translate="yes" xml:space="preserve">
          <source>While there will typically be only be a single set of replacement instructions on an&lt;code&gt;INSPECT&lt;/code&gt;</source>
          <target state="translated">일반적으로 &lt;code&gt;INSPECT&lt;/code&gt; 에는 단일 교체 지시 세트 만 있지만</target>
        </trans-unit>
        <trans-unit id="29d43a6a9c4b7b033de415ebc142a3f57ece324e" translate="yes" xml:space="preserve">
          <source>While this code will display&lt;code&gt;AEIBFJCGKDHL&lt;/code&gt;on the console output window:</source>
          <target state="translated">이 코드는 콘솔 출력 창에 &lt;code&gt;AEIBFJCGKDHL&lt;/code&gt; 을 표시하지만 :</target>
        </trans-unit>
        <trans-unit id="5a95c1be453d4df24ce5e16c30f82bcc31a23762" translate="yes" xml:space="preserve">
          <source>While we&amp;rsquo;re looking at sample code, this code displays&lt;code&gt;ABCEFG&lt;/code&gt;</source>
          <target state="translated">샘플 코드를보고있는 동안이 코드는 &lt;code&gt;ABCEFG&lt;/code&gt; 를 표시 합니다.</target>
        </trans-unit>
        <trans-unit id="caf3a21bbc17cb9f6d2a069e72716706eb83cda5" translate="yes" xml:space="preserve">
          <source>White: COB-COLOR-WHITE</source>
          <target state="translated">화이트 : COB-COLOR-WHITE</target>
        </trans-unit>
        <trans-unit id="893e0ae52146465f8879b903cc2cd576ae909bb7" translate="yes" xml:space="preserve">
          <source>Windows 16-bit &quot;thunking&quot; will be used to call the subroutine as a DLL.</source>
          <target state="translated">Windows 16 비트 &quot;썽킹&quot;은 서브 루틴을 DLL로 호출하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c44c44110ccd48cf9d68ccd53a21edcfdc414c35" translate="yes" xml:space="preserve">
          <source>Windows 16-bit &quot;thunking&quot; will not be in effect.</source>
          <target state="translated">Windows 16 비트 &quot;썽킹&quot;은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a854364cf6b93b75d3740d8a770c6dd3b65e7eaa" translate="yes" xml:space="preserve">
          <source>Windows implementations of GnuCOBOL may, or may not, be similarly case sensitive with regard to copybook names, depending upon the Windows version and GnuCOBOL build options &amp;mdash; it is safest to simply treat the COPY command as case-sensitive in all environments.</source>
          <target state="translated">GnuCOBOL의 Windows 구현은 Windows 버전 및 GnuCOBOL 빌드 옵션에 따라 카피 북 이름과 관련하여 대소 문자를 구분하거나 유사하게 대소 문자를 구분하지 않을 수 있습니다. 모든 환경에서 COPY 명령을 대소 문자를 구분하여 처리하는 것이 가장 안전합니다.</target>
        </trans-unit>
        <trans-unit id="1054f28a5174d8cdc32cfadf25c22e4f7097d403" translate="yes" xml:space="preserve">
          <source>Windows implementations of GnuCOBOL may, or may not, be similarly case sensitive with regard to library names, depending upon the Windows version and GnuCOBOL build options &amp;mdash; it is safest to simply treat library names as case-sensitive in all environments.</source>
          <target state="translated">GnuCOBOL의 Windows 구현은 Windows 버전 및 GnuCOBOL 빌드 옵션에 따라 라이브러리 이름과 유사하게 대소 문자를 구분할 수도 있고 그렇지 않을 수도 있습니다. 모든 환경에서 라이브러리 이름을 대소 문자를 구분하여 처리하는 것이 가장 안전합니다.</target>
        </trans-unit>
        <trans-unit id="8da945840c5e04775bc13e57dab1de5604b64371" translate="yes" xml:space="preserve">
          <source>Windows systems are case-insensitive with regard to environment variables, so there is no difference between the first two when using a GnuCOBOL implementation built for either Windows/MinGW or native Windows.</source>
          <target state="translated">Windows 시스템은 환경 변수와 관련하여 대소 문자를 구분하지 않으므로 Windows / MinGW 또는 기본 Windows 용으로 빌드 된 GnuCOBOL 구현을 사용할 때 처음 두 시스템간에 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="564f8c6e76fbd512be2e38dabdfdd61550d0c3cc" translate="yes" xml:space="preserve">
          <source>With</source>
          <target state="translated">With</target>
        </trans-unit>
        <trans-unit id="fa06feed7cedbea00f76e3fa9443e210cb593516" translate="yes" xml:space="preserve">
          <source>With JUSTIFIED</source>
          <target state="translated">JUSTIFIED로</target>
        </trans-unit>
        <trans-unit id="11454b97dcb0273b7a714ac8435c03de473ffd56" translate="yes" xml:space="preserve">
          <source>With a binary search, express the number of entries as a binary number (1,000 = 1111101000), count the number of digits in the result (which is, essentially, what a logarithm is, when rounded up to the next integer &amp;mdash; the number of digits a decimal number would have if expressed in the logarithm&amp;rsquo;s number base). In this case, we end up with 10 &amp;mdash; THAT is the worst-case number of tests required to find an entry or to identify that it doesn&amp;rsquo;t exist. That&amp;rsquo;s quite an improvement!</source>
          <target state="translated">이진 검색을 사용하면 항목 수를 이진 숫자 (1,000 = 1111101000)로 표시하고 결과의 자릿수를 계산합니다 (즉, 다음 정수로 반올림 할 때의 로그 수, 즉 숫자는 로그의 숫자로 표현 된 경우 10 진수입니다. 이 경우 10으로 끝납니다. 항목을 찾거나 존재하지 않는 것을 식별하는 데 필요한 최악의 테스트 수입니다. 상당히 개선되었습니다!</target>
        </trans-unit>
        <trans-unit id="47e879273dc7c65aef87a79fda96d4ad7f96b774" translate="yes" xml:space="preserve">
          <source>With its original limitation on the length of variable names (one- to six-character names comprised of a letter followed by up to five letters and/or digits), it&amp;rsquo;s implicit rule that variable were automatically created as real (floating-point) unless their name started with a letter in the range I-N, and its use of algebraic notation to express actions being taken, FORTRAN wasn&amp;rsquo;t a particularly readable language, even for programmers. Compare this with the equivalent COBOL code:</source>
          <target state="translated">변수 이름의 길이에 대한 원래의 제한 (문자와 최대 5 개의 문자 및 / 또는 숫자로 구성되는 1-6 자의 이름)으로 인해 변수가 자동으로 실수 (부동 소수점)로 생성 된 것은 암시적인 규칙입니다. 그들의 이름은 IN 범위의 문자로 시작했으며, 행동을 표현하기 위해 대수 표기법을 사용했기 때문에 FORTRAN은 프로그래머조차도 특히 읽을 수있는 언어가 아니 었습니다. 이것을 동등한 COBOL 코드와 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="fd0418f7bed2f93e5ebeccb68eca807233f86dda" translate="yes" xml:space="preserve">
          <source>With native Windows Windows/MinGW builds, the shell environment will be the Windows console window command processor (usually &quot;cmd.exe&quot;) appropriate for the version of Windows you&amp;rsquo;re using.</source>
          <target state="translated">기본 Windows Windows / MinGW 빌드에서 셸 환경은 사용중인 Windows 버전에 적합한 Windows 콘솔 창 명령 프로세서 (일반적으로 &quot;cmd.exe&quot;)입니다.</target>
        </trans-unit>
        <trans-unit id="900c601e8872bca9c518d845e59cdea0f51bca60" translate="yes" xml:space="preserve">
          <source>With the 1985 standard for COBOL, a much more elegant solution was introduced. Any COBOL &amp;rsquo;</source>
          <target state="translated">COBOL의 1985 표준에 따라 훨씬 더 우아한 솔루션이 도입되었습니다. 모든 코볼 '</target>
        </trans-unit>
        <trans-unit id="0b2e3a1904c05e56dc97d5236366be38066e9720" translate="yes" xml:space="preserve">
          <source>With the above example, if the inspect subject were&lt;code&gt;--ABCDEF----BCDEF--&lt;/code&gt; the final result of the counting would be that C-ABC would be incremented by 1 while C-BCDE would be incremented only once; although the human eye clearly sees two &quot;BCDE&quot; sequences, the&lt;code&gt;INSPECT ... TALLYING&lt;/code&gt;would only &quot;see&quot; the second &amp;mdash; the first would have been processed by the first (higher-priority) counting instruction.</source>
          <target state="translated">위의 예에서 검사 대상이 &lt;code&gt;--ABCDEF----BCDEF--&lt;/code&gt; 인 경우 계산의 최종 결과는 C-ABC가 1 씩 증가하는 반면 C-BCDE는 한 번만 증가한다는 것입니다. 인간의 눈에는 두 개의 &quot;BCDE&quot;시퀀스가 명확하게 &lt;code&gt;INSPECT ... TALLYING&lt;/code&gt; 은 두 번째 만 &quot;보는&quot;것입니다. 첫 번째는 첫 번째 (더 높은 우선 순위) 계산 명령에 의해 처리되었을 것입니다.</target>
        </trans-unit>
        <trans-unit id="0ec61b9beac4bc288026474e74d20b0a8c2b16b1" translate="yes" xml:space="preserve">
          <source>With the above example, if the inspect subject were&lt;code&gt;--ABCDEF----BCDEF--&lt;/code&gt; the final result of the replacement would be&lt;code&gt;--DEFDEF----WXYZF--&lt;/code&gt;</source>
          <target state="translated">위의 예에서 검사 대상이 &lt;code&gt;--ABCDEF----BCDEF--&lt;/code&gt; 인 경우 교체의 최종 결과는 &lt;code&gt;--DEFDEF----WXYZF--&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6bfa1062b6dfc9197230a44113df7b463aed0e73" translate="yes" xml:space="preserve">
          <source>With the exception of logic procedure names, which may consist entirely of nothing but digits, user-defined words must contain at least one letter.</source>
          <target state="translated">숫자로만 구성 될 수있는 논리 프로 시저 이름을 제외하고 사용자 정의 단어는 하나 이상의 문자를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="14cb39996348ed7ae459bae96a3b068a93114c37" translate="yes" xml:space="preserve">
          <source>With the&lt;code&gt;-x&lt;/code&gt;switch</source>
          <target state="translated">와 &lt;code&gt;-x&lt;/code&gt; 스위치</target>
        </trans-unit>
        <trans-unit id="78966db73e1c66deedbeb3320b74e26b2a795c32" translate="yes" xml:space="preserve">
          <source>With this change,&lt;code&gt;ABCDEFGHIJKL&lt;/code&gt;is once again displayed.</source>
          <target state="translated">이 변경으로 &lt;code&gt;ABCDEFGHIJKL&lt;/code&gt; 이 다시 한 번 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="eacf1d46236299e914ae93e3d3c7dea5357d90e9" translate="yes" xml:space="preserve">
          <source>With this form, a block of storage equal in size to the defined size of My-01-Item (which must have been defined with the&lt;code&gt;BASED&lt;/code&gt;attribute) will be allocated. The address of that block of storage will become the base address of My-01-Item so that it and its subordinate data items become usable within the program.</source>
          <target state="translated">이 형식을 사용하면 정의 된 크기의 My-01-Item ( &lt;code&gt;BASED&lt;/code&gt; 속성 으로 정의되어야 함)과 동일한 크기의 스토리지 블록 이 할당됩니다. 해당 스토리지 블록의 주소는 My-01-Item의 기본 주소가되므로 프로그램 및 해당 하위 데이터 항목을 프로그램 내에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e37330921085546813e977e7d077fc41a6c9d12" translate="yes" xml:space="preserve">
          <source>With this option, the program will wait for a pre-configured time for the lock to be released. If the lock is released within the preconfigured wait time, the read will be successful. If the pre-configured wait time expires before the lock is released, the read attempt will be aborted and a 51 file status will be issued.</source>
          <target state="translated">이 옵션을 사용하면 잠금이 해제 될 때까지 사전 구성된 시간 동안 프로그램이 대기합니다. 사전 구성된 대기 시간 내에 잠금이 해제되면 읽기에 성공합니다. 잠금이 해제되기 전에 사전 구성된 대기 시간이 만료되면 읽기 시도가 중단되고 51 파일 상태가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="9896244cd1008752a0e7c117022d3e2f86f69b57" translate="yes" xml:space="preserve">
          <source>Within each store, data will be sorted into ascending sequence of department number</source>
          <target state="translated">각 상점 내에서 데이터는 부서 번호의 오름차순으로 정렬됩니다</target>
        </trans-unit>
        <trans-unit id="cb7353567e5fa105e1e904cb9f6dc9fbbd610436" translate="yes" xml:space="preserve">
          <source>Without</source>
          <target state="translated">Without</target>
        </trans-unit>
        <trans-unit id="2b8ae25757eec97d48c815b31dad6e832a80cdd7" translate="yes" xml:space="preserve">
          <source>Without JUSTIFIED</source>
          <target state="translated">근거없이</target>
        </trans-unit>
        <trans-unit id="ab1662b525695dcf16eaed53309bddac5a86a0a2" translate="yes" xml:space="preserve">
          <source>Without the&lt;code&gt;UNTIL&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;UNTIL&lt;/code&gt; 없이</target>
        </trans-unit>
        <trans-unit id="318d16788cef4def38bb2bb4185f58e85897fa0b" translate="yes" xml:space="preserve">
          <source>Without this option, an attempt to read a locked record will be immediately aborted and a file status of 51 will be returned.</source>
          <target state="translated">이 옵션이 없으면 잠긴 레코드를 읽으려는 시도가 즉시 중단되고 파일 상태 51이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8cd37d9eaa3e8129d58497de8c9d51d756352ce2" translate="yes" xml:space="preserve">
          <source>Without&lt;code&gt;LINE&lt;/code&gt;(see &lt;a href=&quot;#LINE&quot;&gt;LINE&lt;/a&gt;) or&lt;code&gt;COLUMN&lt;/code&gt;(see &lt;a href=&quot;#COLUMN&quot;&gt;COLUMN&lt;/a&gt;) clauses, screen section fields will display on the console window beginning at whatever line/column coordinate is stated or implied by the&lt;code&gt;ACCEPT screen-data-item&lt;/code&gt;or&lt;code&gt;DISPLAY screen-data-item&lt;/code&gt;statement that presents the screen item. After a field is presented to the console window, the next field will be presented immediately following that field.</source>
          <target state="translated">없이 &lt;code&gt;LINE&lt;/code&gt; (참조 &lt;a href=&quot;#LINE&quot;&gt;LINE&lt;/a&gt; ) 또는 &lt;code&gt;COLUMN&lt;/code&gt; (참조 &lt;a href=&quot;#COLUMN&quot;&gt;COLUMN&lt;/a&gt; ) 조항 섹션의 필드는 콘솔 창에 표시됩니다 화면이 언급하거나 암시 좌표 어떤 행 / 열에서 시작 &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; 또는 &lt;code&gt;DISPLAY screen-data-item&lt;/code&gt; 문 화면 항목을 표시합니다. 콘솔 창에 필드가 표시되면 해당 필드 바로 다음에 다음 필드가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="67fbefc0694f5d33e6c127adf3f2289741a4299a" translate="yes" xml:space="preserve">
          <source>Would &amp;mdash; with&lt;code&gt;DECIMAL POINT IS COMMA&lt;/code&gt;in effect &amp;mdash; actually be interpreted as a subroutine call with 1 argument (the non-integer numeric literal whose value is 1 and 2 tenths). For this reason, it is best to always follow a comma with a space.</source>
          <target state="translated">함께 -겠습니까 &lt;code&gt;DECIMAL POINT IS COMMA&lt;/code&gt; 효과는 - 실제로 1 개 인수 서브 루틴 호출로서 해석 (비 - 정수 숫자 리터럴 값이 1 10분의 2이다). 이러한 이유로 항상 공백이있는 쉼표를 따르는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8b8150892159602ee6880cbdb65c5c94fa3b86c2" translate="yes" xml:space="preserve">
          <source>Would you prefer a web-based tutorial? Try the University of Limerick (Ireland) COBOL web site - &amp;lsquo;&lt;code&gt;http://www.csis.ul.ie/cobol/&lt;/code&gt;&amp;rsquo;.</source>
          <target state="translated">웹 기반 튜토리얼을 원하십니까? University of Limerick (아일랜드) COBOL 웹 사이트- ' &lt;code&gt;http://www.csis.ul.ie/cobol/&lt;/code&gt; '를 사용해보십시오 .</target>
        </trans-unit>
        <trans-unit id="b4d3ab0d60813524c789808a8629059951cba18f" translate="yes" xml:space="preserve">
          <source>X&quot;91&quot; Built-In Subroutine Syntax</source>
          <target state="translated">X &quot;91&quot;내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="97f87e069e216128f98e9c2af0cce434c82ce350" translate="yes" xml:space="preserve">
          <source>X&quot;91&quot;, X&quot;E4&quot;, X&quot;E5&quot;, X&quot;F4&quot;, X&quot;F5&quot;</source>
          <target state="translated">X &quot;91&quot;, X &quot;E4&quot;, X &quot;E5&quot;, X &quot;F4&quot;, X &quot;F5&quot;</target>
        </trans-unit>
        <trans-unit id="8d8536c7c0c1fd48eeadd62a1f344a382c3c755f" translate="yes" xml:space="preserve">
          <source>X&quot;E4&quot; Built-In Subroutine Syntax</source>
          <target state="translated">X &quot;E4&quot;내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="96be13de8161c84b26c98d09bc8893feddb2cc4b" translate="yes" xml:space="preserve">
          <source>X&quot;E5&quot; Built-In Subroutine Syntax</source>
          <target state="translated">X &quot;E5&quot;내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="19f11b35bad70a5b1ede73eadccb8461da3d60ec" translate="yes" xml:space="preserve">
          <source>X&quot;F4&quot; Built-In Subroutine Syntax</source>
          <target state="translated">X &quot;F4&quot;내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="a6f980fd2288ee90e3ff3cf7a2750572499659dc" translate="yes" xml:space="preserve">
          <source>X&quot;F5&quot; Built-In Subroutine Syntax</source>
          <target state="translated">X &quot;F5&quot;내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="76a4acaf31b815aa2c41cc2a2176b11fa9edf00a" translate="yes" xml:space="preserve">
          <source>XXXXXXXX</source>
          <target state="translated">XXXXXXXX</target>
        </trans-unit>
        <trans-unit id="25e75fdfd45a2fc65a1561c4a55be63b9304cfed" translate="yes" xml:space="preserve">
          <source>XXXXXXXX.CBL</source>
          <target state="translated">XXXXXXXX.CBL</target>
        </trans-unit>
        <trans-unit id="1a01c2f9db4448135c332d5f03b244553defd98d" translate="yes" xml:space="preserve">
          <source>XXXXXXXX.COB</source>
          <target state="translated">XXXXXXXX.COB</target>
        </trans-unit>
        <trans-unit id="26a11bebdc3ad2e98fe156aadc84bf03c8dc8f3c" translate="yes" xml:space="preserve">
          <source>XXXXXXXX.CPY</source>
          <target state="translated">XXXXXXXX.CPY</target>
        </trans-unit>
        <trans-unit id="3cd491714e8ed44d5cb357d61183cedb0a3402e5" translate="yes" xml:space="preserve">
          <source>XXXXXXXX.cbl</source>
          <target state="translated">XXXXXXXX.cbl</target>
        </trans-unit>
        <trans-unit id="9fb508638a72e981e0325bbdcc50cdc1f9f3620f" translate="yes" xml:space="preserve">
          <source>XXXXXXXX.cob</source>
          <target state="translated">XXXXXXXX.cob</target>
        </trans-unit>
        <trans-unit id="a5fa44a32f41bda6ec768284d959a8ea5287ffce" translate="yes" xml:space="preserve">
          <source>XXXXXXXX.cpy</source>
          <target state="translated">XXXXXXXX.cpy</target>
        </trans-unit>
        <trans-unit id="035d6c7fc713b700d2289c38ad8671ce8b5cdfbb" translate="yes" xml:space="preserve">
          <source>YEAR-TO-YYYY Function Syntax</source>
          <target state="translated">YEAR-TO-YYYY 함수 구문</target>
        </trans-unit>
        <trans-unit id="ba22b3f45e963d700438d015dd547e20f4b6b3c3" translate="yes" xml:space="preserve">
          <source>YEAR-TO-YYYY, YYYYDDD, YYYYMMDD</source>
          <target state="translated">YEAR-TO-YYYY, YYYYDDD, YYYYMMDD</target>
        </trans-unit>
        <trans-unit id="d14d07d181bf7b8dada461fc0c61775f143468e4" translate="yes" xml:space="preserve">
          <source>Yellow: COB-COLOR-YELLOW</source>
          <target state="translated">노랑 : COB-COLOR-YELLOW</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="8873953cd7a77c3bfb5aeec4e2dbe92cc8b6c02b" translate="yes" xml:space="preserve">
          <source>You are using a procedural&lt;code&gt;PERFORM&lt;/code&gt;statement (see &lt;a href=&quot;#Procedural-PERFORM&quot;&gt;Procedural PERFORM&lt;/a&gt;)</source>
          <target state="translated">당신은 절차 적 사용 &lt;code&gt;PERFORM&lt;/code&gt; 문을 (참조 &lt;a href=&quot;#Procedural-PERFORM&quot;&gt;절차 수행&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="6f37cb61f92c3ee61980cefac590243753a942fa" translate="yes" xml:space="preserve">
          <source>You are using a&lt;code&gt;GO TO&lt;/code&gt;statement (see &lt;a href=&quot;#GO-TO&quot;&gt;GO TO&lt;/a&gt;)</source>
          <target state="translated">당신이 사용하는 &lt;code&gt;GO TO&lt;/code&gt; 의 문을합니다 ( &lt;a href=&quot;#GO-TO&quot;&gt;이동을&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="415be0c2a589d6613ea0e96ff0fa4a09a854f06e" translate="yes" xml:space="preserve">
          <source>You are using a&lt;code&gt;MERGE&lt;/code&gt;statement (see &lt;a href=&quot;#MERGE&quot;&gt;MERGE&lt;/a&gt;) with an&lt;code&gt;OUTPUT PROCEDURE&lt;/code&gt;</source>
          <target state="translated">당신은 사용하는 &lt;code&gt;MERGE&lt;/code&gt; 의 문 (참조 &lt;a href=&quot;#MERGE&quot;&gt;MERGE를&lt;/a&gt; 로) &lt;code&gt;OUTPUT PROCEDURE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4b4d6fcd956ffc249b5fe966f8cd9c513397f34" translate="yes" xml:space="preserve">
          <source>You are using a&lt;code&gt;SORT&lt;/code&gt;statement (see &lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt;) with either (or both) an&lt;code&gt;INPUT PROCEDURE&lt;/code&gt;or&lt;code&gt;OUTPUT PROCEDURE&lt;/code&gt;</source>
          <target state="translated">당신은 사용하는 &lt;code&gt;SORT&lt;/code&gt; (참조 문을 &lt;a href=&quot;#SORT&quot;&gt;SORT를&lt;/a&gt; 하나 (또는 둘 다)와 함께) &lt;code&gt;INPUT PROCEDURE&lt;/code&gt; 또는 &lt;code&gt;OUTPUT PROCEDURE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="441752d0d9f2139c764487ac2e305c7a3ab08b46" translate="yes" xml:space="preserve">
          <source>You are using the&lt;code&gt;ALTER&lt;/code&gt;statement (see &lt;a href=&quot;#ALTER&quot;&gt;ALTER&lt;/a&gt;) (the use of which should be avoided at all costs)</source>
          <target state="translated">당신이 사용하는 &lt;code&gt;ALTER&lt;/code&gt; 의 (참조 문을 &lt;a href=&quot;#ALTER&quot;&gt;ALTER를&lt;/a&gt; (사용이있는 희생을 치르더라도 피해야한다))</target>
        </trans-unit>
        <trans-unit id="aac698e9bc381153d9f728b218ad195b63c4d794" translate="yes" xml:space="preserve">
          <source>You are using&lt;code&gt;DECLARATIVES&lt;/code&gt;(see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;)</source>
          <target state="translated">당신이 사용하는 &lt;code&gt;DECLARATIVES&lt;/code&gt; 를 (참조 &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES를&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="37683c4bf268a521f1e0ce750e80912f0e6b5185" translate="yes" xml:space="preserve">
          <source>You can be the judge. First, the Java version:</source>
          <target state="translated">당신은 판사가 될 수 있습니다. 먼저, Java 버전 :</target>
        </trans-unit>
        <trans-unit id="1f7d5d96863dbc8809bed0960c251cfde3ab6242" translate="yes" xml:space="preserve">
          <source>You can force the GnuCOBOL runtime system to pre-load all dynamically-loaded modules that could ever be called by the program, at the time the program starts executing. This is accomplished through the use of the</source>
          <target state="translated">프로그램 실행을 시작할 때 프로그램에서 호출 할 수있는 동적으로로드 된 모든 모듈을 GnuCOBOL 런타임 시스템에 미리로드하도록 할 수 있습니다. 이것은 사용하여 달성됩니다</target>
        </trans-unit>
        <trans-unit id="fe1621c0d0817ae920144fa8c01766737cc2e5c6" translate="yes" xml:space="preserve">
          <source>You can trick RWCS into using the PAGE LIMIT values as logical specifications rather than physical ones quite easily &amp;mdash; simply include an ASCII form-feed (X&amp;rsquo;0C&amp;rsquo;) character into your page heading design! Here&amp;rsquo;s how the sample program shown earlier could be easily modified:</source>
          <target state="translated">실제 페이지가 아닌 논리적 사양으로 PAGE LIMIT 값을 사용하여 RWCS를 속일 수 있습니다. 페이지 머리글 디자인에 ASCII form-feed (X'0C ') 문자를 포함시키기 만하면됩니다! 이전에 표시된 샘플 프로그램을 쉽게 수정하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d332c1100eaac1c578cd4f2b04aa5eec038af7a8" translate="yes" xml:space="preserve">
          <source>You can used extended attributes, useful for setting timeouts or positioning.</source>
          <target state="translated">시간 초과 또는 위치 설정에 유용한 확장 된 속성을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77d05b291c9496cc2a1f64183cd8f36a18749716" translate="yes" xml:space="preserve">
          <source>You cannot use both&lt;code&gt;NEXT SENTENCE&lt;/code&gt;and the&lt;code&gt;END-IF&lt;/code&gt;scope terminator in the same&lt;code&gt;IF&lt;/code&gt;statement.</source>
          <target state="translated">동일한 &lt;code&gt;IF&lt;/code&gt; 문 에서 &lt;code&gt;NEXT SENTENCE&lt;/code&gt; 와 &lt;code&gt;END-IF&lt;/code&gt; 범위 종결 자를 모두 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2163b4265cac1689d879f5158a2a727ab8743995" translate="yes" xml:space="preserve">
          <source>You may adjust the value(s) of any items referenced in&lt;code&gt;SUM&lt;/code&gt;(see &lt;a href=&quot;#SUM&quot;&gt;SUM&lt;/a&gt;) or&lt;code&gt;SOURCE&lt;/code&gt;(see &lt;a href=&quot;#SOURCE&quot;&gt;SOURCE&lt;/a&gt;) clauses in the report group.</source>
          <target state="translated">보고서 그룹 에서 &lt;code&gt;SUM&lt;/code&gt; ( &lt;a href=&quot;#SUM&quot;&gt;SUM&lt;/a&gt; 참조 ) 또는 &lt;code&gt;SOURCE&lt;/code&gt; ( &lt;a href=&quot;#SOURCE&quot;&gt;SOURCE&lt;/a&gt; 참조 ) 절에서 참조 된 항목의 값을 조정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c81bd8b7d8060cbc5296d5c531b7829e7783dc1d" translate="yes" xml:space="preserve">
          <source>You may also use the&lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt;CDF directive to perform this function.</source>
          <target state="translated">&lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt; CDF 지시문을 사용하여이 기능을 수행 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="054cafde64dedbde58f8596ae459b0722d673330" translate="yes" xml:space="preserve">
          <source>You may compile GnuCOBOL subprograms into assembler source code which can then be assembled and linked with a main program when that main program is compiled. To create such an assembler source file, compile the subprogram(s) as follows:</source>
          <target state="translated">GnuCOBOL 서브 프로그램을 어셈블러 소스 코드로 컴파일 한 다음 해당 메인 프로그램이 컴파일 될 때 메인 프로그램과 어셈블되고 링크 될 수 있습니다. 이러한 어셈블러 소스 파일을 작성하려면 다음과 같이 서브 프로그램을 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="293e8ddddd1f1c233342acd299061a2bfd3ebdc9" translate="yes" xml:space="preserve">
          <source>You may execute the&lt;code&gt;SUPPRESS&lt;/code&gt;(see &lt;a href=&quot;#SUPPRESS&quot;&gt;SUPPRESS&lt;/a&gt;) statement to squelch the presentation of the specified report group altogether. Note that you will be suppressing this one specific instance of that group&amp;rsquo;s presentation and not all of them.</source>
          <target state="translated">당신은 실행할 수 &lt;code&gt;SUPPRESS&lt;/code&gt; (참조 &lt;a href=&quot;#SUPPRESS&quot;&gt;SUPPRESS를&lt;/a&gt; 모두 지정된 보고서 그룹의 프리젠 테이션을 퀠치하기 위해) 문을. 해당 그룹 프리젠 테이션의 특정 인스턴스 하나를 모두 억제하지는 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="cf35460f181c19d36a0dc1c7b0ad84cfd0d3c69d" translate="yes" xml:space="preserve">
          <source>You may include an optional &amp;lt;</source>
          <target state="translated">선택 사항 인 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="1e65202f55f04b3e7b3e9d4991c283932e0f6d32" translate="yes" xml:space="preserve">
          <source>You may include an optional second argument to specify the &amp;lt;</source>
          <target state="translated">선택적인 두 번째 인수를 포함하여 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="98c555bf0695949427e1a3b270cc9a04b52aee11" translate="yes" xml:space="preserve">
          <source>You may not use an&lt;code&gt;ENTRY&lt;/code&gt;statement in a nested subprogram, nor may you use it in any form of user-defined function.</source>
          <target state="translated">당신은 사용할 수 없습니다 &lt;code&gt;ENTRY&lt;/code&gt; 의 중첩 된 서브 프로그램에서 문을 없으며 사용자 정의 함수의 형태로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63c66023128251792acf3aef777c2a0929748699" translate="yes" xml:space="preserve">
          <source>You may only read the existing contents of the file &amp;mdash; only the&lt;code&gt;CLOSE&lt;/code&gt;&lt;code&gt;READ&lt;/code&gt;&lt;code&gt;START&lt;/code&gt;and&lt;code&gt;UNLOCK&lt;/code&gt;statements will be allowed. This enforcement takes place at execution time, not compilation time.</source>
          <target state="translated">파일의 기존 내용 만 읽을 수 있습니다. &lt;code&gt;CLOSE&lt;/code&gt; &lt;code&gt;READ&lt;/code&gt; &lt;code&gt;START&lt;/code&gt; 및 &lt;code&gt;UNLOCK&lt;/code&gt; 문만 허용됩니다. 이 시행은 컴파일 시간이 아닌 실행 시간에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0fceeeee26f5eba247280b6d471f003bdfb30269" translate="yes" xml:space="preserve">
          <source>You may only write new content (which will be appended after the previously existing file contents) to the file &amp;mdash; only the&lt;code&gt;CLOSE&lt;/code&gt;&lt;code&gt;UNLOCK&lt;/code&gt;and&lt;code&gt;WRITE&lt;/code&gt;statements will be allowed. This enforcement takes place at execution time, not compilation time. You cannot extend an empty file; this will not generate a runtime error, but no output will appear in the file.</source>
          <target state="translated">파일에 새 내용 (이전에 존재하는 파일 내용 뒤에 추가됨) 만 쓸 수 있습니다. &lt;code&gt;CLOSE&lt;/code&gt; &lt;code&gt;UNLOCK&lt;/code&gt; 및 &lt;code&gt;WRITE&lt;/code&gt; 문만 허용됩니다. 이 시행은 컴파일 시간이 아닌 실행 시간에 발생합니다. 빈 파일은 확장 할 수 없습니다. 이렇게하면 런타임 오류가 발생하지 않지만 파일에 출력이 나타나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7194a843c087582371e18303f104720cc644680d" translate="yes" xml:space="preserve">
          <source>You may only write new content (which will completely replace any previous file contents) to the file &amp;mdash; only the&lt;code&gt;CLOSE&lt;/code&gt;&lt;code&gt;UNLOCK&lt;/code&gt;and&lt;code&gt;WRITE&lt;/code&gt;statements will be allowed. This enforcement takes place at execution time, not compilation time.</source>
          <target state="translated">파일에 새 내용 (이전 파일 내용을 완전히 대체 함) 만 쓸 수 있습니다. &lt;code&gt;CLOSE&lt;/code&gt; &lt;code&gt;UNLOCK&lt;/code&gt; 및 &lt;code&gt;WRITE&lt;/code&gt; 문만 허용됩니다. 이 시행은 컴파일 시간이 아닌 실행 시간에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e3756c1b6ac169f0b0368c02dd5c3224b2fbaf2d" translate="yes" xml:space="preserve">
          <source>You may perform any operation you wish against the file &amp;mdash; all file I/O statements will be allowed.</source>
          <target state="translated">파일에 대해 원하는 작업을 수행 할 수 있습니다. 모든 파일 I / O 문이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="2a5faeff37b19213ac8a6045d710277e7246741c" translate="yes" xml:space="preserve">
          <source>You may specify any of the figurative constants&lt;code&gt;SPACE&lt;/code&gt;&lt;code&gt;SPACES&lt;/code&gt;&lt;code&gt;ZERO&lt;/code&gt;&lt;code&gt;ZEROS&lt;/code&gt;&lt;code&gt;ZEROES&lt;/code&gt;&lt;code&gt;QUOTE&lt;/code&gt;&lt;code&gt;QUOTES&lt;/code&gt;&lt;code&gt;HIGH-VALUE&lt;/code&gt;&lt;code&gt;HIGH-VALUES&lt;/code&gt;&lt;code&gt;LOW-VALUE&lt;/code&gt;or&lt;code&gt;LOW-VALUES&lt;/code&gt;for any of the &amp;lt;</source>
          <target state="translated">당신은 상징적 인 상수의 지정할 수 있습니다 &lt;code&gt;SPACE&lt;/code&gt; &lt;code&gt;SPACES&lt;/code&gt; &lt;code&gt;ZERO&lt;/code&gt; &lt;code&gt;ZEROS&lt;/code&gt; &lt;code&gt;ZEROES&lt;/code&gt; &lt;code&gt;QUOTE&lt;/code&gt; &lt;code&gt;QUOTES&lt;/code&gt; &lt;code&gt;HIGH-VALUE&lt;/code&gt; &lt;code&gt;HIGH-VALUES&lt;/code&gt; &lt;code&gt;LOW-VALUE&lt;/code&gt; 또는 &lt;code&gt;LOW-VALUES&lt;/code&gt; 의 어떤을 위해 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="8d0528105c78c72bb842f937fe08a1a8a0fb3af6" translate="yes" xml:space="preserve">
          <source>You may switch between&lt;code&gt;FIXED&lt;/code&gt;and&lt;code&gt;FREE&lt;/code&gt;mode as desired.</source>
          <target state="translated">원하는대로 &lt;code&gt;FIXED&lt;/code&gt; 와 &lt;code&gt;FREE&lt;/code&gt; 모드를 전환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c57bbd7fad45df71287483ca0cb429f32233abf" translate="yes" xml:space="preserve">
          <source>You may use the&lt;code&gt;&amp;gt;&amp;gt;FORMAT IS FIXED&lt;/code&gt;and&lt;code&gt;FORMAT IS FREE&lt;/code&gt;clauses of the&lt;code&gt;&amp;gt;&amp;gt;DEFINE&lt;/code&gt;CDF directive (see &lt;a href=&quot;#g_t_003e_003eDEFINE&quot;&gt;&amp;gt;&amp;gt;DEFINE&lt;/a&gt;) within your source code to switch to Fixed or Free Format Mode, respectively.</source>
          <target state="translated">소스 코드 내 에서 &lt;code&gt;&amp;gt;&amp;gt;DEFINE&lt;/code&gt; CDF 지시문 의 &lt;code&gt;&amp;gt;&amp;gt;FORMAT IS FIXED&lt;/code&gt; 및 &lt;code&gt;FORMAT IS FREE&lt;/code&gt; 절 ( &lt;a href=&quot;#g_t_003e_003eDEFINE&quot;&gt;&amp;gt;&amp;gt; DEFINE&lt;/a&gt; 참조 )을 사용하여 각각 고정 또는 자유 형식 모드로 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a65c2afd5c4a99f2eba4f6b86c709ea517566a11" translate="yes" xml:space="preserve">
          <source>You may use the&lt;code&gt;&amp;gt;&amp;gt;SOURCE&lt;/code&gt;CDF directive (see &lt;a href=&quot;#g_t_003e_003eSOURCE&quot;&gt;&amp;gt;&amp;gt;SOURCE&lt;/a&gt;) to switch to Free Format Mode &lt;code&gt;&amp;gt;&amp;gt;SOURCE FORMAT IS FREE&lt;/code&gt; or Fixed Format Mode &lt;code&gt;&amp;gt;&amp;gt;SOURCE FORMAT IS FIXED&lt;/code&gt;</source>
          <target state="translated">당신은 사용할 수 있습니다 &lt;code&gt;&amp;gt;&amp;gt;SOURCE&lt;/code&gt; (참조 CDF 지시어를 &lt;a href=&quot;#g_t_003e_003eSOURCE&quot;&gt;SOURCE &amp;gt;&amp;gt;&lt;/a&gt; 자유 형식 모드로 전환) &lt;code&gt;&amp;gt;&amp;gt;SOURCE FORMAT IS FREE&lt;/code&gt; 또는 고정 형식 모드 &lt;code&gt;&amp;gt;&amp;gt;SOURCE FORMAT IS FIXED&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="23232cdf18e0d19a45c1b2ca8eac3e2ecb81eddb" translate="yes" xml:space="preserve">
          <source>You may use the&lt;code&gt;SOURCEFORMAT AS FIXED&lt;/code&gt;and&lt;code&gt;SOURCEFORMAT AS FREE&lt;/code&gt;clauses of the&lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt;CDF directive (see &lt;a href=&quot;#g_t_003e_003eSET&quot;&gt;&amp;gt;&amp;gt;SET&lt;/a&gt;) within your source code to switch to Fixed or Free Format Mode, respectively.</source>
          <target state="translated">소스 코드 내 에서 &lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt; CDF 지시문 ( &lt;a href=&quot;#g_t_003e_003eSET&quot;&gt;&amp;gt;&amp;gt; SET&lt;/a&gt; 참조 ) 의 &lt;code&gt;SOURCEFORMAT AS FIXED&lt;/code&gt; 및 &lt;code&gt;SOURCEFORMAT AS FREE&lt;/code&gt; 절을 사용하여 각각 고정 또는 자유 형식 모드로 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="630674bf3cd87d358512935149be2e55f84e3ea8" translate="yes" xml:space="preserve">
          <source>You must use the level number 66 for data description entries that contain the&lt;code&gt;RENAMES&lt;/code&gt;clause.</source>
          <target state="translated">&lt;code&gt;RENAMES&lt;/code&gt; 절 을 포함하는 데이터 설명 항목에는 레벨 번호 66을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="be9486f9c225e2cf954dbe853b25986a80f7ef23" translate="yes" xml:space="preserve">
          <source>You specify colors by number (0-7), or by using the constant names provided in the &quot;screenio.cpy&quot; copybook (which is provided with all GnuCOBOL source distributions).</source>
          <target state="translated">숫자 (0-7) 또는 &quot;screenio.cpy&quot;카피 북 (모든 GnuCOBOL 소스 배포와 함께 제공됨)에 제공된 상수 이름을 사용하여 색상을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="b4527f9a0d70d5e57ae677d77f4d8889745ffdc5" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll find COBOL an easy language to learn and a FAR EASIER language to master than many of the &quot;modern&quot; languages.</source>
          <target state="translated">COBOL은 배우기 쉬운 언어이며 많은 &quot;현대&quot;언어보다 마스터하기 쉬운 FAR EASIER 언어입니다.</target>
        </trans-unit>
        <trans-unit id="015e7877b250464577511fa0a6efa973747a2e0a" translate="yes" xml:space="preserve">
          <source>Your program will</source>
          <target state="translated">당신의 프로그램은</target>
        </trans-unit>
        <trans-unit id="7652dfd94315da720712c87b3ed050c2c020ba57" translate="yes" xml:space="preserve">
          <source>Your task is to develop a report that shows the sales total from each cash register and summarizes those sales by department within each store, by store and also generates a total sales figure for the day across all stores.</source>
          <target state="translated">귀하의 임무는 각 금전 등록기의 판매 총계를 표시하고 각 상점의 부서별 판매량을 상점별로 요약하고 모든 상점에서 하루 동안의 총 판매량을 생성하는 보고서를 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="477c268e42b87c6b2096a0b9b74b0654741b83dd" translate="yes" xml:space="preserve">
          <source>ZERO, ZERO-FILL, ZEROES, ZEROS</source>
          <target state="translated">ZERO, ZERO-FILL, ZEROES, ZEROS</target>
        </trans-unit>
        <trans-unit id="2ec58715d6df7f2d792b4cca3206894cdc59a26f" translate="yes" xml:space="preserve">
          <source>Zero values will be returned if the screen has not been initialized and values of 24 (lines) and 80 (columns) will be returned if GnuCOBOL was not generated to include screen I/O.</source>
          <target state="translated">화면이 초기화되지 않은 경우 0 값이 반환되고 GnuCOBOL이 화면 I / O를 포함하도록 생성되지 않은 경우 24 (행) 및 80 (열) 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7791354c5965aaef2b88cad01bede0954dcce40c" translate="yes" xml:space="preserve">
          <source>Zero-Delimited Alphanumeric Literals</source>
          <target state="translated">영으로 구분 된 영숫자 리터럴</target>
        </trans-unit>
        <trans-unit id="918bdfb46a691d311de2d2b5efbe36ecf4756dd6" translate="yes" xml:space="preserve">
          <source>a GnuCOBOL rule &amp;mdash; this is my own personal programming practice intended to improve the readability and maintainability of my programs.</source>
          <target state="translated">GnuCOBOL 규칙-이것은 내 프로그램의 가독성 및 유지 관리 성을 향상시키기위한 개인적인 프로그래밍 관행입니다.</target>
        </trans-unit>
        <trans-unit id="4f304498bf53e92eac59949cf9de42bddf58e0be" translate="yes" xml:space="preserve">
          <source>a recursive subroutine. This is accomplished by adding the&lt;code&gt;RECURSIVE&lt;/code&gt;attribute to it&amp;rsquo;s&lt;code&gt;PROGRAM-ID&lt;/code&gt;(see &lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;IDENTIFICATION DIVISION&lt;/a&gt;).</source>
          <target state="translated">재귀 서브 루틴 &lt;code&gt;RECURSIVE&lt;/code&gt; 속성을 &lt;code&gt;PROGRAM-ID&lt;/code&gt; 에 추가하면됩니다 ( &lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;식별&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="16ca7689b5f953679c1b2277cacb8702590a370d" translate="yes" xml:space="preserve">
          <source>absent</source>
          <target state="translated">absent</target>
        </trans-unit>
        <trans-unit id="17f83623a1a2bf8f175e19de5a9671b06ec81ca2" translate="yes" xml:space="preserve">
          <source>access-mode</source>
          <target state="translated">access-mode</target>
        </trans-unit>
        <trans-unit id="5164e24487b4e9a05448434ac3e600826fe14664" translate="yes" xml:space="preserve">
          <source>according to the bit-pattern values the characters have in storage.</source>
          <target state="translated">문자가 저장에있는 비트 패턴 값에 따라.</target>
        </trans-unit>
        <trans-unit id="acd5d99ec4b1e046d49c78b276a85efe8f9022a0" translate="yes" xml:space="preserve">
          <source>af_ZA, am_ET, ar_AE, ar_BH, ar_DZ, ar_EG, ar_IQ, ar_JO, ar_KW, ar_LB, ar_LY, ar_MA, ar_OM, ar_QA, ar_SA, ar_SY, ar_TN, ar_YE, arn_CL, as_IN, az_Cyrl_AZ, az_Latn_AZ</source>
          <target state="translated">af_ZA, am_ET, ar_AE, ar_BH, ar_DZ, ar_EG, ar_IQ, ar_JO, ar_KW, ar_LB, ar_LY, ar_MA, ar_OM, ar_QA, ar_SA, ar_SY, ar_TN, ar_YE, arn_CL, as_IN, az_Cyrl_AZ,</target>
        </trans-unit>
        <trans-unit id="12f9d82a9e8e502cf4a6191377da462ef5f2fc82" translate="yes" xml:space="preserve">
          <source>affect the repetition count.</source>
          <target state="translated">반복 횟수에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="79da5dd0b59f9ff1b16d302146ba7b172322a180" translate="yes" xml:space="preserve">
          <source>affect the value returned by this function.</source>
          <target state="translated">이 함수가 반환 한 값에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="405906c9d5be6ae5393ca65fb0e7c38e0d585ecb" translate="yes" xml:space="preserve">
          <source>after</source>
          <target state="translated">after</target>
        </trans-unit>
        <trans-unit id="ab64e92b8ed3846e3f1f30a25bd334e437e4cefc" translate="yes" xml:space="preserve">
          <source>agree with the KEY clause(s)! A table-based&lt;code&gt;SORT&lt;/code&gt;(see &lt;a href=&quot;#Table-SORT&quot;&gt;Table SORT&lt;/a&gt;) can prove very useful in this regard.</source>
          <target state="translated">KEY 조항에 동의하십시오! 이와 관련하여 테이블 기반 &lt;code&gt;SORT&lt;/code&gt; ( &lt;a href=&quot;#Table-SORT&quot;&gt;Table SORT&lt;/a&gt; 참조 )가 매우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cbc7ba2b65974670df89fbe8132e872527b5526" translate="yes" xml:space="preserve">
          <source>alphabet-name-1</source>
          <target state="translated">alphabet-name-1</target>
        </trans-unit>
        <trans-unit id="09706c418809f1f4cfda992435ca1438eddaaeed" translate="yes" xml:space="preserve">
          <source>also</source>
          <target state="translated">also</target>
        </trans-unit>
        <trans-unit id="6656018ac96d0295d887ff2893ba9af66ae16af2" translate="yes" xml:space="preserve">
          <source>always</source>
          <target state="translated">always</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="11a9215ec620218c8e8d409263469091431ff0d4" translate="yes" xml:space="preserve">
          <source>angle</source>
          <target state="translated">angle</target>
        </trans-unit>
        <trans-unit id="c5fe0200d1c7a5139bd18fd22268c4ca8bf45e90" translate="yes" xml:space="preserve">
          <source>any</source>
          <target state="translated">any</target>
        </trans-unit>
        <trans-unit id="d0556c73c33d86f01f7279b33f28b599f555f488" translate="yes" xml:space="preserve">
          <source>any&lt;code&gt;9&lt;/code&gt;editing symbols in the &amp;lt;</source>
          <target state="translated">어떤 &lt;code&gt;9&lt;/code&gt; 개 에서 편집 기호를 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="910f17dc52f0ccb23c3fe3b44a23cb9b097f162a" translate="yes" xml:space="preserve">
          <source>appear</source>
          <target state="translated">appear</target>
        </trans-unit>
        <trans-unit id="7ad6dd8109ca919475311b73fe54db7348d531dd" translate="yes" xml:space="preserve">
          <source>apply to any subprogram&amp;rsquo;s local-storage (if any), regardless of the use (or not) of&lt;code&gt;INITIAL&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;INITIAL&lt;/code&gt; 의 사용 여부에 관계없이 서브 프로그램의 로컬 스토리지 (있는 경우)에 적용</target>
        </trans-unit>
        <trans-unit id="7683453cdf2eff068451e7462bee7ef655e9870a" translate="yes" xml:space="preserve">
          <source>approaches:</source>
          <target state="translated">approaches:</target>
        </trans-unit>
        <trans-unit id="5f9e5802bbabc71f9275fccf122f5a52b8599f12" translate="yes" xml:space="preserve">
          <source>are</source>
          <target state="translated">are</target>
        </trans-unit>
        <trans-unit id="29948a0a66c87654b20be9c4115624bb821e2e3a" translate="yes" xml:space="preserve">
          <source>are also known by the term dynamically-loadable</source>
          <target state="translated">동적로드 가능이라는 용어로도 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="f36f6877daeed6091f68c806fda4a33e3c5452f3" translate="yes" xml:space="preserve">
          <source>are discussed in detail in the next four sections.</source>
          <target state="translated">다음 네 섹션에서 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="975aafa5f2d95d44f3bca9869a18011d029224a8" translate="yes" xml:space="preserve">
          <source>argument-1</source>
          <target state="translated">argument-1</target>
        </trans-unit>
        <trans-unit id="4ae676b823e986b993a278f745f557f8d2ed84da" translate="yes" xml:space="preserve">
          <source>argument-2</source>
          <target state="translated">argument-2</target>
        </trans-unit>
        <trans-unit id="20988a5ccb7a4e693b66e54bb26fb4920fb42b4a" translate="yes" xml:space="preserve">
          <source>attached</source>
          <target state="translated">attached</target>
        </trans-unit>
        <trans-unit id="7b231a50a498ef151e291795f46f56bee569eae5" translate="yes" xml:space="preserve">
          <source>available</source>
          <target state="translated">available</target>
        </trans-unit>
        <trans-unit id="e9d71f5ee7c92d6dc9e92ffdad17b8bd49418f98" translate="yes" xml:space="preserve">
          <source>b</source>
          <target state="translated">b</target>
        </trans-unit>
        <trans-unit id="8574c92d5408a2611ef5579b3457177f0e71591f" translate="yes" xml:space="preserve">
          <source>ba_R, be_BY, bg_BG, bn_IN bo_BT, bo_CN, br_FR, bs_Cyrl_BA, bs_Latn_BA</source>
          <target state="translated">ba_R, be_BY, bg_BG, bn_IN bo_BT, bo_CN, br_FR, bs_Cyrl_BA, bs_Latn_BA</target>
        </trans-unit>
        <trans-unit id="5cb138284d431abd6a053a56625ec088bfb88912" translate="yes" xml:space="preserve">
          <source>bbb</source>
          <target state="translated">bbb</target>
        </trans-unit>
        <trans-unit id="939d32e2787670e0c75caf85136869e4565bd7c5" translate="yes" xml:space="preserve">
          <source>be altered.</source>
          <target state="translated">변경됩니다.</target>
        </trans-unit>
        <trans-unit id="e5d09d9b66a4129da6d84709951467918b797970" translate="yes" xml:space="preserve">
          <source>be an identifier. Locale names are specified using UNIX-standard names.</source>
          <target state="translated">식별자입니다. 로케일 이름은 UNIX 표준 이름을 사용하여 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="d27337cff63054b63275f40d49eb20ca852b3ee7" translate="yes" xml:space="preserve">
          <source>be an object-code module (output</source>
          <target state="translated">객체 코드 모듈 (출력)</target>
        </trans-unit>
        <trans-unit id="6e5f49b74408f187421cb162814725b355a262a8" translate="yes" xml:space="preserve">
          <source>be consistent with the&lt;code&gt;PICTURE&lt;/code&gt;(see &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt;) clause of that item, although that will not be enforced by the&lt;code&gt;ACCEPT&lt;/code&gt;statement. You may use&lt;code&gt;Class Conditions&lt;/code&gt;(see &lt;a href=&quot;#Class-Conditions&quot;&gt;Class Conditions&lt;/a&gt;) after the data is accepted to enforce the data type.</source>
          <target state="translated">과 일치 &lt;code&gt;PICTURE&lt;/code&gt; (참조 &lt;a href=&quot;#PICTURE&quot;&gt;그림을&lt;/a&gt; 그가에 의해 적용되지 않습니다 있지만) 해당 항목의 조항 &lt;code&gt;ACCEPT&lt;/code&gt; 문. 당신은 사용할 수 있습니다 &lt;code&gt;Class Conditions&lt;/code&gt; (참조 &lt;a href=&quot;#Class-Conditions&quot;&gt;클래스 조건&lt;/a&gt; 데이터가 데이터 형식을 시행 승인 후).</target>
        </trans-unit>
        <trans-unit id="6cdc6e7bb66fbea5641669c73f21ddc31c4d50ef" translate="yes" xml:space="preserve">
          <source>be consistent with the&lt;code&gt;PICTURE&lt;/code&gt;(see &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt;) clause of that item. This will be enforced at runtime by the&lt;code&gt;ACCEPT&lt;/code&gt;statement.</source>
          <target state="translated">과 일치 &lt;code&gt;PICTURE&lt;/code&gt; (참조 &lt;a href=&quot;#PICTURE&quot;&gt;영상&lt;/a&gt; 해당 항목의 절). 이것은 &lt;code&gt;ACCEPT&lt;/code&gt; 문에 의해 런타임에 시행됩니다 .</target>
        </trans-unit>
        <trans-unit id="c02c30672a6d6bb0800865402cb2b81c4de6e0d9" translate="yes" xml:space="preserve">
          <source>be included in that program&amp;rsquo;s&lt;code&gt;REPOSITORY&lt;/code&gt;paragraph, which therefore makes the&lt;code&gt;FUNCTION&lt;/code&gt;keyword optional.</source>
          <target state="translated">해당 프로그램의 &lt;code&gt;REPOSITORY&lt;/code&gt; 단락에 포함되어 &lt;code&gt;FUNCTION&lt;/code&gt; 키워드를 선택 사항으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b56c5f861486451b494423cecbbcfa75af783203" translate="yes" xml:space="preserve">
          <source>be null-terminating their strings!</source>
          <target state="translated">문자열을 null로 종료하십시오!</target>
        </trans-unit>
        <trans-unit id="1cf9515113004ee74094093f1af2dbbea9e220db" translate="yes" xml:space="preserve">
          <source>be processed but will not actually be presented to any report page. This will allow summary processing to take place. If all&lt;code&gt;GENERATE&lt;/code&gt;statements are of this form, the report is said to be a &amp;rsquo;</source>
          <target state="translated">처리되지만 실제로는 보고서 페이지에 표시되지 않습니다. 이를 통해 요약 처리가 수행됩니다. 모든 &lt;code&gt;GENERATE&lt;/code&gt; 문이이 형식 인 경우 보고서는 '</target>
        </trans-unit>
        <trans-unit id="bf25b5dab4899cf41e9e3be57720ff2e1b853f30" translate="yes" xml:space="preserve">
          <source>be the&lt;code&gt;RECORD KEY&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;) or one of the file&amp;rsquo;s&lt;code&gt;ALTERNATE RECORD KEY&lt;/code&gt;fields (if any) &amp;mdash; the current contents of that field will identify the record to be accessed. If an alternate record key is used, and that key allows duplicate values, the record accessed will be the</source>
          <target state="translated">수 &lt;code&gt;RECORD KEY&lt;/code&gt; (참조 &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;조직 인덱스를&lt;/a&gt; ) 또는 파일의 하나 &lt;code&gt;ALTERNATE RECORD KEY&lt;/code&gt; 의 필드 (있는 경우) - 해당 필드의 현재 내용은 레코드를 액세스 할 수 식별합니다. 대체 레코드 키가 사용되고 해당 키가 중복 값을 허용하는 경우 액세스 된 레코드는</target>
        </trans-unit>
        <trans-unit id="40166cb4775ca6d1342e7c80b14a94342553cf77" translate="yes" xml:space="preserve">
          <source>be treated as a random&lt;code&gt;READ&lt;/code&gt;</source>
          <target state="translated">무작위 &lt;code&gt;READ&lt;/code&gt; 로 취급</target>
        </trans-unit>
        <trans-unit id="51de2b835bd35a67eb32dbcd3d77d4b96e5aa39d" translate="yes" xml:space="preserve">
          <source>before</source>
          <target state="translated">before</target>
        </trans-unit>
        <trans-unit id="336edf81860bdfc5e56a603ab1759d4ec3c587d2" translate="yes" xml:space="preserve">
          <source>beginning</source>
          <target state="translated">beginning</target>
        </trans-unit>
        <trans-unit id="e8b95d665e2ceb500a33527b2321b156a6f1e2d2" translate="yes" xml:space="preserve">
          <source>being</source>
          <target state="translated">being</target>
        </trans-unit>
        <trans-unit id="a31e44e0548b4c995336834db72c429ffc0f13ba" translate="yes" xml:space="preserve">
          <source>better</source>
          <target state="translated">better</target>
        </trans-unit>
        <trans-unit id="fc39b18f287d8bbfaceae020f4a4eb32ac5c1e70" translate="yes" xml:space="preserve">
          <source>both</source>
          <target state="translated">both</target>
        </trans-unit>
        <trans-unit id="e53c2ea1fe4bd2b78bf4723c7c155a578e020a25" translate="yes" xml:space="preserve">
          <source>buffer</source>
          <target state="translated">buffer</target>
        </trans-unit>
        <trans-unit id="7bede894df35d0068545c9b1530be26c8101c681" translate="yes" xml:space="preserve">
          <source>business transactions, and does so:</source>
          <target state="translated">비즈니스 거래 및 그렇게 :</target>
        </trans-unit>
        <trans-unit id="8cf1783fa99f62ca581f6fe8f3cd66b0f9ab9fc3" translate="yes" xml:space="preserve">
          <source>byte</source>
          <target state="translated">byte</target>
        </trans-unit>
        <trans-unit id="d9ac3e11fefbb7ec102338bbc279e87b8162e569" translate="yes" xml:space="preserve">
          <source>byte of a&lt;code&gt;PACKED-DECIMAL&lt;/code&gt;or&lt;code&gt;COMP-3&lt;/code&gt;data item will always have its left nibble corresponding to the last&lt;code&gt;9&lt;/code&gt;in the&lt;code&gt;PICTURE&lt;/code&gt;and its right nibble reserved as a sign indicator. This sign indicator is always present regardless of whether or not the&lt;code&gt;PICTURE&lt;/code&gt;included an&lt;code&gt;S&lt;/code&gt;symbol.</source>
          <target state="translated">&lt;code&gt;PACKED-DECIMAL&lt;/code&gt; 또는 &lt;code&gt;COMP-3&lt;/code&gt; 데이터 항목의 바이트 는 항상 &lt;code&gt;PICTURE&lt;/code&gt; 의 마지막 &lt;code&gt;9&lt;/code&gt; 에 해당하는 왼쪽 니블 과 부호 표시 자로 예약 된 오른쪽 니블을 갖습니다. 이 기호 표시기는 &lt;code&gt;PICTURE&lt;/code&gt; 에 &lt;code&gt;S&lt;/code&gt; 기호가 포함되어 있는지 여부에 관계없이 항상 존재합니다 .</target>
        </trans-unit>
        <trans-unit id="8dddc0a54b0d5290a97771b9c64fb19fb1449dfb" translate="yes" xml:space="preserve">
          <source>byte of the data item will contain an unused left nibble if the&lt;code&gt;PICTURE&lt;/code&gt;had an even number of&lt;code&gt;9&lt;/code&gt;symbols in it.</source>
          <target state="translated">&lt;code&gt;PICTURE&lt;/code&gt; 에 짝수의 &lt;code&gt;9&lt;/code&gt; 개 심볼 이 있으면 데이터 항목의 바이트에 사용되지 않은 왼쪽 니블이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="7f53e9e0d45bdd5f6b7cff71771eaa637b33d856" translate="yes" xml:space="preserve">
          <source>byte-length</source>
          <target state="translated">byte-length</target>
        </trans-unit>
        <trans-unit id="daf529a73101c2be626b99fc6938163e7a27620b" translate="yes" xml:space="preserve">
          <source>bytes</source>
          <target state="translated">bytes</target>
        </trans-unit>
        <trans-unit id="d911be42721d2dba24da73c4d7c079e8855f77ea" translate="yes" xml:space="preserve">
          <source>ca_ES, cs_CZ, cy_GB</source>
          <target state="translated">ca_ES, cs_CZ, cy_GB</target>
        </trans-unit>
        <trans-unit id="3a3f75346c72eb3d88c3f6ebab78414f0335a06a" translate="yes" xml:space="preserve">
          <source>call to any entry-point within the module being made at run-time, the contents of &amp;lt;</source>
          <target state="translated">런타임에 모듈 내에서 시작점을 호출하면 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="7e9219a0599eae1d9601883f894b4fbe60870586" translate="yes" xml:space="preserve">
          <source>can</source>
          <target state="translated">can</target>
        </trans-unit>
        <trans-unit id="ba66513885706cb6a15b73c09c19bdb842147a3b" translate="yes" xml:space="preserve">
          <source>category-name</source>
          <target state="translated">category-name</target>
        </trans-unit>
        <trans-unit id="e9caf8630551c29ad4932878a08a50cbeb5eaae8" translate="yes" xml:space="preserve">
          <source>category-name-1</source>
          <target state="translated">category-name-1</target>
        </trans-unit>
        <trans-unit id="22342094b67766e3316ea5d2f18158c85575c178" translate="yes" xml:space="preserve">
          <source>category-name-2</source>
          <target state="translated">category-name-2</target>
        </trans-unit>
        <trans-unit id="b3b836b6d3e1f47968489287c1e0548e95a4d5a5" translate="yes" xml:space="preserve">
          <source>changed that argument, but since the COBOL program passed that argument&lt;code&gt;BY CONTENT&lt;/code&gt; the change was made to a</source>
          <target state="translated">해당 인수를 변경했지만 COBOL 프로그램이 해당 인수 &lt;code&gt;BY CONTENT&lt;/code&gt; 를 전달한 이후로 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="71fafc4e2fc1e47e234762a96b80512b6b5534c2" translate="yes" xml:space="preserve">
          <source>char</source>
          <target state="translated">char</target>
        </trans-unit>
        <trans-unit id="b788d2d8258d677c25673d0d7a7e7f3f71952e42" translate="yes" xml:space="preserve">
          <source>char-n</source>
          <target state="translated">char-n</target>
        </trans-unit>
        <trans-unit id="d7bce3f12d4abaa2e130fb08144194778e53b6c3" translate="yes" xml:space="preserve">
          <source>character of the previous field. Thus,&lt;code&gt;COLUMN PLUS 1&lt;/code&gt;will leave no blank positions between the end of the previous field and the start of this one.</source>
          <target state="translated">이전 필드의 문자 따라서 &lt;code&gt;COLUMN PLUS 1&lt;/code&gt; 은 이전 필드의 끝과이 필드의 시작 사이에 공백 위치를 남기지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e16d5410e80c68f6e79485651dd566b4a31a1c7" translate="yes" xml:space="preserve">
          <source>character should be copied.</source>
          <target state="translated">문자를 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="aa908a40ba515918f9d5edbdcad8ebc1fe5c2b42" translate="yes" xml:space="preserve">
          <source>characters</source>
          <target state="translated">characters</target>
        </trans-unit>
        <trans-unit id="a11971e3e49773aad3e9437b286e6b4004a839eb" translate="yes" xml:space="preserve">
          <source>class-name-1</source>
          <target state="translated">class-name-1</target>
        </trans-unit>
        <trans-unit id="77ffa6b4ec61bc57f3f63935b0894f05ea401e88" translate="yes" xml:space="preserve">
          <source>combination</source>
          <target state="translated">combination</target>
        </trans-unit>
        <trans-unit id="023646ce8406be5b9700f2babded876beaf4396b" translate="yes" xml:space="preserve">
          <source>compilation</source>
          <target state="translated">compilation</target>
        </trans-unit>
        <trans-unit id="1c8d44cbafac2dce468ebeca5512dabab659262d" translate="yes" xml:space="preserve">
          <source>compilation of that file will be bypassed by the&lt;code&gt;cobc&lt;/code&gt;command; instead, the file will be passed directly to the C compiler or assembler (executed automatically by&lt;code&gt;cobc&lt;/code&gt;.</source>
          <target state="translated">해당 파일의 컴파일은 &lt;code&gt;cobc&lt;/code&gt; 명령 으로 무시됩니다 . 대신, 파일은 C 컴파일러 또는 어셈블러에 직접 전달됩니다 ( &lt;code&gt;cobc&lt;/code&gt; 에 의해 자동으로 실행 됨) .</target>
        </trans-unit>
        <trans-unit id="d41597c0c2a80da2c7cd737d1070882d465efb8b" translate="yes" xml:space="preserve">
          <source>computer-name</source>
          <target state="translated">computer-name</target>
        </trans-unit>
        <trans-unit id="1c7188ab4172abb6c62697f890095f0a676e3f97" translate="yes" xml:space="preserve">
          <source>condition-name-1</source>
          <target state="translated">condition-name-1</target>
        </trans-unit>
        <trans-unit id="ef1ee50bd158d6ed3c36884c33e77ef494c6396c" translate="yes" xml:space="preserve">
          <source>conditional-expression</source>
          <target state="translated">conditional-expression</target>
        </trans-unit>
        <trans-unit id="5a86dfc34df5a8f883b051eb759549ec71849023" translate="yes" xml:space="preserve">
          <source>conditional-expression-1</source>
          <target state="translated">conditional-expression-1</target>
        </trans-unit>
        <trans-unit id="45d3ac68f56243d622aa900efcd26c772a59280c" translate="yes" xml:space="preserve">
          <source>conditional-expression-n</source>
          <target state="translated">conditional-expression-n</target>
        </trans-unit>
        <trans-unit id="e23ea9fa92024f274edf17de5120d9997324d2b6" translate="yes" xml:space="preserve">
          <source>constant-name-1</source>
          <target state="translated">constant-name-1</target>
        </trans-unit>
        <trans-unit id="c1380af48659113969e097bf1cb2bc27425f186c" translate="yes" xml:space="preserve">
          <source>contain</source>
          <target state="translated">contain</target>
        </trans-unit>
        <trans-unit id="b9b6529f9dead616c10e5b27dcd19a05e26bca8b" translate="yes" xml:space="preserve">
          <source>contain exact binary data fields. This is possible because &amp;mdash; since there is no character sequence that constitutes an end-of-record delimiter &amp;mdash; the contents of record fields are irrelevant to the reading process.</source>
          <target state="translated">정확한 이진 데이터 필드를 포함합니다. 레코드 끝 구분자를 구성하는 문자 시퀀스가 ​​없기 때문에 레코드 필드의 내용이 읽기 프로세스와 관련이 없기 때문에 가능합니다.</target>
        </trans-unit>
        <trans-unit id="25b3b540ffe91062307298e03d6b133116e04a3f" translate="yes" xml:space="preserve">
          <source>control hierarchy</source>
          <target state="translated">제어 계층</target>
        </trans-unit>
        <trans-unit id="297b7cef30711e4f96f89482acd1108c3d436888" translate="yes" xml:space="preserve">
          <source>convert-length</source>
          <target state="translated">convert-length</target>
        </trans-unit>
        <trans-unit id="f84e2e2dadd87384fb55f25886926b777e8378f1" translate="yes" xml:space="preserve">
          <source>copy</source>
          <target state="translated">copy</target>
        </trans-unit>
        <trans-unit id="900b9508be71f44d3cd16145e6c11f753e0f48ef" translate="yes" xml:space="preserve">
          <source>current character pointer</source>
          <target state="translated">현재 문자 포인터</target>
        </trans-unit>
        <trans-unit id="0517dc15ace78f45267daf3f51414b59ec2cf7cb" translate="yes" xml:space="preserve">
          <source>currently</source>
          <target state="translated">currently</target>
        </trans-unit>
        <trans-unit id="84f12e2f2d8f5f2ae96f442c17f5afcff6f86f1e" translate="yes" xml:space="preserve">
          <source>cursor-locn-buffer</source>
          <target state="translated">cursor-locn-buffer</target>
        </trans-unit>
        <trans-unit id="e2672e3ce1a6432042ad7551a1c96f43987698ea" translate="yes" xml:space="preserve">
          <source>da_DK, de_AT, de_CH, de_DE, de_LI, de_LU, dsb_DE, dv_MV</source>
          <target state="translated">da_DK, de_AT, de_CH, de_DE, de_LI, de_LU, dsb_DE, dv_MV</target>
        </trans-unit>
        <trans-unit id="b2682df29294579cd37979cde1e8ce10b70ef166" translate="yes" xml:space="preserve">
          <source>data has been entered into the field. Function keys will still be allowed to terminate the&lt;code&gt;ACCEPT&lt;/code&gt;</source>
          <target state="translated">데이터가 필드에 입력되었습니다. 기능 키는 여전히 &lt;code&gt;ACCEPT&lt;/code&gt; 를 종료 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f7a7f78f73f3ad64b6531ad23828c3b5cc1707e7" translate="yes" xml:space="preserve">
          <source>data item, which can no longer be used in calculations or subscripts.</source>
          <target state="translated">더 이상 계산 또는 아래 첨자에 사용할 수없는 데이터 항목.</target>
        </trans-unit>
        <trans-unit id="a91167500c594bafd47b06f9a4ed1e12b292c9c0" translate="yes" xml:space="preserve">
          <source>data items with&lt;code&gt;OCCURS&lt;/code&gt;clauses.</source>
          <target state="translated">&lt;code&gt;OCCURS&lt;/code&gt; 절이있는 데이터 항목</target>
        </trans-unit>
        <trans-unit id="c1979d332f0d4265a9660ff50d55b8010fbaa636" translate="yes" xml:space="preserve">
          <source>data-item</source>
          <target state="translated">data-item</target>
        </trans-unit>
        <trans-unit id="82af73cdcddd95abf635f91d39cd40ecb7a0fd4d" translate="yes" xml:space="preserve">
          <source>data-item-1</source>
          <target state="translated">data-item-1</target>
        </trans-unit>
        <trans-unit id="8df1978c5a66677984c580c0c50109d84c490108" translate="yes" xml:space="preserve">
          <source>data-item-2</source>
          <target state="translated">data-item-2</target>
        </trans-unit>
        <trans-unit id="e927d0677c77241b707442314346326278051dd6" translate="yes" xml:space="preserve">
          <source>date</source>
          <target state="translated">date</target>
        </trans-unit>
        <trans-unit id="5548ae4f34cbb6e30414532924e2088d915b460f" translate="yes" xml:space="preserve">
          <source>days</source>
          <target state="translated">days</target>
        </trans-unit>
        <trans-unit id="782543c51caa24ef638b37ad436e82c446f910f0" translate="yes" xml:space="preserve">
          <source>decimal points in their picture clauses. They actually don&amp;rsquo;t, because the last character of every data item definition is always a period &amp;mdash; the period that ends the definition.</source>
          <target state="translated">그림 절의 소수점. 모든 데이터 항목 정의의 마지막 문자는 항상 마침표 (정의를 끝내는 마침표)이기 때문에 실제로는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="090d6cc90a32a19a738eb06290adb96cc6b806ff" translate="yes" xml:space="preserve">
          <source>defined in the&lt;code&gt;SCREEN SECTION&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;SCREEN SECTION&lt;/code&gt; 정의</target>
        </trans-unit>
        <trans-unit id="458af8cd52c66c0fcc964c0c890514e881f3c4c3" translate="yes" xml:space="preserve">
          <source>definitely</source>
          <target state="translated">definitely</target>
        </trans-unit>
        <trans-unit id="d911c6b3e4180f05850a2b50e12b0f3cc050a527" translate="yes" xml:space="preserve">
          <source>destination field</source>
          <target state="translated">대상 필드</target>
        </trans-unit>
        <trans-unit id="7733da1c8899a87c0260881bbabb171d30b1bab8" translate="yes" xml:space="preserve">
          <source>detail report</source>
          <target state="translated">상세 보고서</target>
        </trans-unit>
        <trans-unit id="ebd2df6b79c966e0e9938d3484c93e09a98f2a02" translate="yes" xml:space="preserve">
          <source>device-name-1</source>
          <target state="translated">device-name-1</target>
        </trans-unit>
        <trans-unit id="517d5a7240861ec297fa07542a7bf7470bb604fe" translate="yes" xml:space="preserve">
          <source>different</source>
          <target state="translated">different</target>
        </trans-unit>
        <trans-unit id="5a60df0fd4e35ca5b91140235dbf7ac24dec5d07" translate="yes" xml:space="preserve">
          <source>dir-path</source>
          <target state="translated">dir-path</target>
        </trans-unit>
        <trans-unit id="eadcd9bd2a09c75aef04954e6799e50278ee124a" translate="yes" xml:space="preserve">
          <source>do</source>
          <target state="translated">do</target>
        </trans-unit>
        <trans-unit id="ba2a1650a795afc041726acf1824670ed22f1154" translate="yes" xml:space="preserve">
          <source>documentation</source>
          <target state="translated">documentation</target>
        </trans-unit>
        <trans-unit id="f0d521a5dc37493901c869e3f3753ee3ac06b9c0" translate="yes" xml:space="preserve">
          <source>does</source>
          <target state="translated">does</target>
        </trans-unit>
        <trans-unit id="bdb36bb22deb169275b3094ba9005a29eeddd195" translate="yes" xml:space="preserve">
          <source>double</source>
          <target state="translated">double</target>
        </trans-unit>
        <trans-unit id="b32f279e548b6fceef4343170778273bfe60658c" translate="yes" xml:space="preserve">
          <source>each</source>
          <target state="translated">each</target>
        </trans-unit>
        <trans-unit id="a22fca6c3065d5684c7f16ed40b8c3b877a68a24" translate="yes" xml:space="preserve">
          <source>edited</source>
          <target state="translated">edited</target>
        </trans-unit>
        <trans-unit id="120d2922d41c49c93ebfce3fbeb16a6a5cca7bc9" translate="yes" xml:space="preserve">
          <source>el_GR, en_029, en_AU, en_BZ, en_CA, en_GB, en_IE, en_IN, en_JM, en_MY en_NZ, en_PH, en_SG, en_TT, en_US, en_ZA, en_ZW, es_AR, es_BO, es_CL, es_CO, es_CR, es_DO, es_EC, es_ES, es_GT, es_HN, es_MX, es_NI, es_PA, es_PE, es_PR, es_PY, es_SV, es_US, es_UY es_VE, et_EE, eu_ES</source>
          <target state="translated">el_GR, en_029, en_AU, en_BZ, en_CA, en_GB, en_IE, en_IN, en_JM, en_MY en_NZ, en_PH, en_SG, en_TT, en_US, en_ZA, en_ZW, es_AR, es_BO, es_CL, es_CO, es_CR, es_DO, es_DO, , es_HN, es_MX, es_NI, es_PA, es_PE, es_PR, es_PY, es_SV, es_US, es_UY es_VE, et_EE, eu_ES</target>
        </trans-unit>
        <trans-unit id="04b8c80bb78edbc4f2742dedfab5f5bddf895cd1" translate="yes" xml:space="preserve">
          <source>even</source>
          <target state="translated">even</target>
        </trans-unit>
        <trans-unit id="644588b073b3c51e8781a7cc23f3fa1cf09ad9a9" translate="yes" xml:space="preserve">
          <source>evolutionary</source>
          <target state="translated">evolutionary</target>
        </trans-unit>
        <trans-unit id="fa361dc6994cb4f44130d42a561627e721bc4af8" translate="yes" xml:space="preserve">
          <source>exactly</source>
          <target state="translated">exactly</target>
        </trans-unit>
        <trans-unit id="28250c910f8a1df05447e14189aca065edd114d8" translate="yes" xml:space="preserve">
          <source>exceeds</source>
          <target state="translated">exceeds</target>
        </trans-unit>
        <trans-unit id="672fccd70b672edfe12c4b12cbbdf7da010ad355" translate="yes" xml:space="preserve">
          <source>except</source>
          <target state="translated">except</target>
        </trans-unit>
        <trans-unit id="1e214745988827864e768979d9a107575a2772a7" translate="yes" xml:space="preserve">
          <source>execution</source>
          <target state="translated">execution</target>
        </trans-unit>
        <trans-unit id="8f58cb7f2d45f91da77ac9d8b15ce5d5f8bdc76f" translate="yes" xml:space="preserve">
          <source>execution of&lt;code&gt;RANDOM&lt;/code&gt;in your program lacks a &amp;lt;</source>
          <target state="translated">프로그램에서 &lt;code&gt;RANDOM&lt;/code&gt; 을 실행 하면 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="de3ac21778e51de199438300e1a9f816c618d33a" translate="yes" xml:space="preserve">
          <source>exit</source>
          <target state="translated">exit</target>
        </trans-unit>
        <trans-unit id="3a85e310858fac24740203d4b8282ad28b2b2ac2" translate="yes" xml:space="preserve">
          <source>expense</source>
          <target state="translated">expense</target>
        </trans-unit>
        <trans-unit id="5c67f5de5ad488d73e422b27497baec8997e1104" translate="yes" xml:space="preserve">
          <source>expression-1</source>
          <target state="translated">expression-1</target>
        </trans-unit>
        <trans-unit id="1d74f5ff81953122b3b3ac32ccc5f077ce56777e" translate="yes" xml:space="preserve">
          <source>fa_IR, fi_FI, fil_PH, fo_FO, fr_BE, fr_CA, fr_CH, fr_FR, fr_LU, fr_MC, fy_NL</source>
          <target state="translated">fa_IR, fi_FI, fil_PH, fo_FO, fr_BE, fr_CA, fr_CH, fr_FR, fr_LU, fr_MC, fy_NL</target>
        </trans-unit>
        <trans-unit id="078cdc5e24f16f0fa98419d87311a47ccfd8f33d" translate="yes" xml:space="preserve">
          <source>field list</source>
          <target state="translated">필드리스트</target>
        </trans-unit>
        <trans-unit id="610d5740cca3d5dc8a1c5803668922a81f3f89fd" translate="yes" xml:space="preserve">
          <source>file-handle</source>
          <target state="translated">file-handle</target>
        </trans-unit>
        <trans-unit id="cdef4f783f2a73e3396664124161bcd7640efa9e" translate="yes" xml:space="preserve">
          <source>file-info</source>
          <target state="translated">file-info</target>
        </trans-unit>
        <trans-unit id="402826864b88e53c9e8819c84191512e637a9f2c" translate="yes" xml:space="preserve">
          <source>file-name-1</source>
          <target state="translated">file-name-1</target>
        </trans-unit>
        <trans-unit id="aa80f54f3221afeb97150f16e0214de20dc115ff" translate="yes" xml:space="preserve">
          <source>file-name-2</source>
          <target state="translated">file-name-2</target>
        </trans-unit>
        <trans-unit id="228f0ffa33e96512091505ed4ee0488ccaef5821" translate="yes" xml:space="preserve">
          <source>file-name-3</source>
          <target state="translated">file-name-3</target>
        </trans-unit>
        <trans-unit id="add9146ac2ae9febab7d2d73acf47890527b93c3" translate="yes" xml:space="preserve">
          <source>file-path</source>
          <target state="translated">file-path</target>
        </trans-unit>
        <trans-unit id="d594c2cc0a53025004791399d80e20852af4c988" translate="yes" xml:space="preserve">
          <source>final</source>
          <target state="translated">final</target>
        </trans-unit>
        <trans-unit id="e0996a37c13d44c3b06074939d43fa3759bd32c1" translate="yes" xml:space="preserve">
          <source>first</source>
          <target state="translated">first</target>
        </trans-unit>
        <trans-unit id="112f3a99b283a4e1788dedd8e0e5d35375c33747" translate="yes" xml:space="preserve">
          <source>flag</source>
          <target state="translated">flag</target>
        </trans-unit>
        <trans-unit id="685e80366130387cb75c055248326976d16fdf8d" translate="yes" xml:space="preserve">
          <source>float</source>
          <target state="translated">float</target>
        </trans-unit>
        <trans-unit id="2db90ad54b4a54a2a32c1bae87a0fac6b7a109df" translate="yes" xml:space="preserve">
          <source>folder specified on the COB_COPY_DIR environment variable.</source>
          <target state="translated">COB_COPY_DIR 환경 변수에 지정된 폴더.</target>
        </trans-unit>
        <trans-unit id="8540abcfa75b00672715f592e3daa2d3a8a3f6df" translate="yes" xml:space="preserve">
          <source>for each individual compilation unit</source>
          <target state="translated">각 개별 편집 단위</target>
        </trans-unit>
        <trans-unit id="ac0145cef797b732f1ae24da018faf97c04ea4c7" translate="yes" xml:space="preserve">
          <source>form-feed the printer when the report is printed. As long as any printer you plan on using supports at least as many physical print lines as what is defined as the&lt;code&gt;PAGE LIMIT&lt;/code&gt;value in whatever paper orientation and font you plan on (or are limited to) printing in, you have now divorced your program from the physical realities of the printer!</source>
          <target state="translated">보고서가 인쇄 될 때 프린터에 용지를 공급합니다. 사용하려는 프린터가 인쇄 하려는 용지 방향 및 글꼴에서 &lt;code&gt;PAGE LIMIT&lt;/code&gt; 값 으로 정의 된 것보다 많은 물리적 인쇄 라인을 지원하는 한, 이제 프로그램을 이혼했습니다. 프린터의 실제 현실에서!</target>
        </trans-unit>
        <trans-unit id="faf930434155f8dd7dfa52b0063df281b5f3d4cc" translate="yes" xml:space="preserve">
          <source>form.</source>
          <target state="translated">form.</target>
        </trans-unit>
        <trans-unit id="785987648f85190cfde9eadc69fc7c46fe8a7433" translate="yes" xml:space="preserve">
          <source>format</source>
          <target state="translated">format</target>
        </trans-unit>
        <trans-unit id="a38e7493ce48eebce728d03d0d79ecc6bedd8c08" translate="yes" xml:space="preserve">
          <source>format of the&lt;code&gt;READ&lt;/code&gt;statement that is available.</source>
          <target state="translated">사용 가능한 &lt;code&gt;READ&lt;/code&gt; 문의 형식</target>
        </trans-unit>
        <trans-unit id="0b1e95cfd9775191a7224d0a218ae79187e80c1d" translate="yes" xml:space="preserve">
          <source>from</source>
          <target state="translated">from</target>
        </trans-unit>
        <trans-unit id="e1a6c03dfc6b6ca5efd873e9790afcbbc546d8c7" translate="yes" xml:space="preserve">
          <source>from the file&amp;rsquo;s&lt;code&gt;FD&lt;/code&gt;</source>
          <target state="translated">파일의 &lt;code&gt;FD&lt;/code&gt; 에서</target>
        </trans-unit>
        <trans-unit id="cc545ae12a78e3b7d0b7c0c3183b6fc9932272c3" translate="yes" xml:space="preserve">
          <source>from-n</source>
          <target state="translated">from-n</target>
        </trans-unit>
        <trans-unit id="c218e39efa2e1aae69f39d2054528369ce1e1f46" translate="yes" xml:space="preserve">
          <source>function</source>
          <target state="translated">function</target>
        </trans-unit>
        <trans-unit id="1dcf1bf6437e1ecb2b2ed377936a3e31dc030c98" translate="yes" xml:space="preserve">
          <source>function-code</source>
          <target state="translated">function-code</target>
        </trans-unit>
        <trans-unit id="5c95b841a8c31fc92fb4ebf32d39fadb342a1a9c" translate="yes" xml:space="preserve">
          <source>function-prototype-name-1</source>
          <target state="translated">function-prototype-name-1</target>
        </trans-unit>
        <trans-unit id="16b36791517907892e73c0edd5ee6e89eb57110f" translate="yes" xml:space="preserve">
          <source>function-reference-1</source>
          <target state="translated">function-reference-1</target>
        </trans-unit>
        <trans-unit id="8af904e6eb6589d42306b2e39375aa6e10ddd19c" translate="yes" xml:space="preserve">
          <source>ga_IE, gbz_AF, gl_ES, gsw_FR, gu_IN</source>
          <target state="translated">ga_IE, gbz_AF, gl_ES, gsw_FR, gu_IN</target>
        </trans-unit>
        <trans-unit id="577a679f233117f18eb15e67d20713a480c3f64e" translate="yes" xml:space="preserve">
          <source>group-item-1</source>
          <target state="translated">group-item-1</target>
        </trans-unit>
        <trans-unit id="1fc0c3216db67923c6e875b2b538a212ea127609" translate="yes" xml:space="preserve">
          <source>group-item-2</source>
          <target state="translated">group-item-2</target>
        </trans-unit>
        <trans-unit id="4dc4de69e102c80f392d678e8815167fafbb3cd8" translate="yes" xml:space="preserve">
          <source>ha_Latn_NG, he_IL, hi_IN, hr_BA, hr_HR, hu_HU, hy_AM</source>
          <target state="translated">ha_Latn_NG, he_IL, hi_IN, hr_BA, hr_HR, hu_HU, hy_AM</target>
        </trans-unit>
        <trans-unit id="a2dd7ec666aacd57fc6d0571db038b51deb9fb6e" translate="yes" xml:space="preserve">
          <source>handle</source>
          <target state="translated">handle</target>
        </trans-unit>
        <trans-unit id="ff87cea4a48b77342a2dbef29133a128abc52679" translate="yes" xml:space="preserve">
          <source>have</source>
          <target state="translated">have</target>
        </trans-unit>
        <trans-unit id="57df2f3744644fba20a5d968635d3bfe48c791c0" translate="yes" xml:space="preserve">
          <source>have an&lt;code&gt;OCCURS&lt;/code&gt;clause (assuming rule 3a applies)</source>
          <target state="translated">이는 &lt;code&gt;OCCURS&lt;/code&gt; 절 (3A 가정 룰을 적용)</target>
        </trans-unit>
        <trans-unit id="761b2694b65d2b39fde48322b9a0d889a60ef955" translate="yes" xml:space="preserve">
          <source>have been defined via an&lt;code&gt;FD&lt;/code&gt;(see &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File/Sort-Description&lt;/a&gt;), not an&lt;code&gt;SD&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;SD&lt;/code&gt; 가 아닌 &lt;code&gt;FD&lt;/code&gt; ( &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;파일 / 정렬 설명&lt;/a&gt; 참조) 를 통해 정의되었습니다</target>
        </trans-unit>
        <trans-unit id="07c4cf9b26a7dd721ee5c0e10a7f57704f8856da" translate="yes" xml:space="preserve">
          <source>head hurt.</source>
          <target state="translated">머리가 아프다.</target>
        </trans-unit>
        <trans-unit id="8476a1f414faa841f749102ad2d90ce217062c3a" translate="yes" xml:space="preserve">
          <source>hhmmssnn</source>
          <target state="translated">hhmmssnn</target>
        </trans-unit>
        <trans-unit id="9d0735a57e0f7a5d955a42afc340a62fa49446d7" translate="yes" xml:space="preserve">
          <source>how long each record may be, add additional records and reprint. Continue until printing overflows to a second page.</source>
          <target state="translated">각 기록의 길이에 따라 기록을 추가하고 재 인쇄하십시오. 인쇄가 두 번째 페이지로 넘칠 때까지 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="f7f67fb647a86905691ae276eb823d6505dad545" translate="yes" xml:space="preserve">
          <source>id_ID, ig_NG, ii_CN, is_IS, it_CH, it_IT, iu_Cans_CA, iu_Latn_CA</source>
          <target state="translated">id_ID, ig_NG, ii_CN, is_IS, it_CH, it_IT, iu_Cans_CA, iu_Latn_CA</target>
        </trans-unit>
        <trans-unit id="fae9fd39301eb7e657d4dad32a828cda5d7399e5" translate="yes" xml:space="preserve">
          <source>identifier</source>
          <target state="translated">identifier</target>
        </trans-unit>
        <trans-unit id="ff9ef548a6e30a0462795d916f3f00d1e2b082ca" translate="yes" xml:space="preserve">
          <source>identifier-1</source>
          <target state="translated">identifier-1</target>
        </trans-unit>
        <trans-unit id="4299e8ddd819f9bde9cfacf45716724c17b5ddf7" translate="yes" xml:space="preserve">
          <source>identifier-2</source>
          <target state="translated">identifier-2</target>
        </trans-unit>
        <trans-unit id="54d8030f95bd952a5fdbf08042150efd045c5757" translate="yes" xml:space="preserve">
          <source>identifier-3</source>
          <target state="translated">identifier-3</target>
        </trans-unit>
        <trans-unit id="a8f51733a16b09b02c26d93e713eacfbd6f33acb" translate="yes" xml:space="preserve">
          <source>identifier-4</source>
          <target state="translated">identifier-4</target>
        </trans-unit>
        <trans-unit id="35b69c24481dea97ec439b3877fe487af8c3fed9" translate="yes" xml:space="preserve">
          <source>identifier-5</source>
          <target state="translated">identifier-5</target>
        </trans-unit>
        <trans-unit id="16b2129453949d508c94af10dbf524d3fde69390" translate="yes" xml:space="preserve">
          <source>identifier-6</source>
          <target state="translated">identifier-6</target>
        </trans-unit>
        <trans-unit id="4a772137f40adf1842f5bd6b1f70526822586bfb" translate="yes" xml:space="preserve">
          <source>identifier-7</source>
          <target state="translated">identifier-7</target>
        </trans-unit>
        <trans-unit id="2fb5b73dfce72d993ba2e440cbe7a630330e7436" translate="yes" xml:space="preserve">
          <source>identifier-8</source>
          <target state="translated">identifier-8</target>
        </trans-unit>
        <trans-unit id="89630820e7fead9119682cc5c69c73676b1fb288" translate="yes" xml:space="preserve">
          <source>identifier-9</source>
          <target state="translated">identifier-9</target>
        </trans-unit>
        <trans-unit id="a10d4d0cbbf122b7a2fae40eadaaa68b67ee991b" translate="yes" xml:space="preserve">
          <source>imperative-statement-1</source>
          <target state="translated">imperative-statement-1</target>
        </trans-unit>
        <trans-unit id="92d0ba5bd03f855a2a8bb930ed07ff61462ce5a3" translate="yes" xml:space="preserve">
          <source>imperative-statement-2</source>
          <target state="translated">imperative-statement-2</target>
        </trans-unit>
        <trans-unit id="b19f275ec20d29c93524ce9ad12c37ea45b29190" translate="yes" xml:space="preserve">
          <source>imperative-statement-n</source>
          <target state="translated">imperative-statement-n</target>
        </trans-unit>
        <trans-unit id="1b2dada4799292907e0dca408b6f4eb3ea2b486d" translate="yes" xml:space="preserve">
          <source>imperative-statement-other</source>
          <target state="translated">imperative-statement-other</target>
        </trans-unit>
        <trans-unit id="8ea5b19d8359d0ceda3368180c4aadeaab15475c" translate="yes" xml:space="preserve">
          <source>improvements to programmer productivity, each of the following three events has been responsible for</source>
          <target state="translated">프로그래머 생산성 향상, 다음 세 가지 이벤트 각각이</target>
        </trans-unit>
        <trans-unit id="67617b5a9180ad92e9057c52cde11c3337e20a93" translate="yes" xml:space="preserve">
          <source>improvements:</source>
          <target state="translated">improvements:</target>
        </trans-unit>
        <trans-unit id="af10ef20dd9060bbeead0afbc55381a66af442ef" translate="yes" xml:space="preserve">
          <source>in</source>
          <target state="translated">in</target>
        </trans-unit>
        <trans-unit id="3086b509c23f67816e1a1d1d97ac0fa65d97a22b" translate="yes" xml:space="preserve">
          <source>in Fixed Format Mode, the&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;must begin in column 8 or beyond, provided no part of the directive extends past column 72. If the compiler is currently in Free Format Mode, the&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;may appear in any column, provided no part of the directive extends past column 255.</source>
          <target state="translated">고정 형식 모드에서 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 컴파일러는 무료 형식 모드에서 현재 인 경우 지침의 어떤 부분은 과거의 열 (72)을 확장하지 않습니다 제공, 열 8 이상에서 시작해야는 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 어떤 부분을 제공하지, 어떤 열에 표시 할 수 있습니다 지시문은 255 열을지나 연장됩니다.</target>
        </trans-unit>
        <trans-unit id="fe0a755f8359cbd92ceadc4d4666a50511f50cae" translate="yes" xml:space="preserve">
          <source>in the file&amp;rsquo;s&lt;code&gt;FD&lt;/code&gt;</source>
          <target state="translated">파일의 &lt;code&gt;FD&lt;/code&gt; 에서</target>
        </trans-unit>
        <trans-unit id="674ad124fd8077ba060909e1d56ebfb9b77671f1" translate="yes" xml:space="preserve">
          <source>in the remainder of this section, will include:</source>
          <target state="translated">이 섹션의 나머지 부분에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="18bcbd949d4382c088f0afab28112f135a66d781" translate="yes" xml:space="preserve">
          <source>in the result.</source>
          <target state="translated">결과적으로.</target>
        </trans-unit>
        <trans-unit id="fd8f3d2cabb404ce841edf65b3a71c0e063298ff" translate="yes" xml:space="preserve">
          <source>index-name-1</source>
          <target state="translated">index-name-1</target>
        </trans-unit>
        <trans-unit id="8ad7d21c71b049b7003ba31b5f1322974df77ac8" translate="yes" xml:space="preserve">
          <source>initial</source>
          <target state="translated">initial</target>
        </trans-unit>
        <trans-unit id="6174d19ad37ae52255cedcecf45fe5d15533d060" translate="yes" xml:space="preserve">
          <source>input-output exception</source>
          <target state="translated">입출력 예외</target>
        </trans-unit>
        <trans-unit id="4e3c52ffe7593eb8b18d91cc855f3f4d45780b35" translate="yes" xml:space="preserve">
          <source>inspect subject</source>
          <target state="translated">주제를 검사하다</target>
        </trans-unit>
        <trans-unit id="1a06e0fbe4a9af107ecf682db9f47f21add5c1a2" translate="yes" xml:space="preserve">
          <source>int  short  short int  signed int  signed short  signed short int</source>
          <target state="translated">int short short int signed int 서명 된 짧은 서명 된 짧은 int</target>
        </trans-unit>
        <trans-unit id="1178cafbd64bbbfa77f5ac0a9d5032ed88162781" translate="yes" xml:space="preserve">
          <source>integer</source>
          <target state="translated">integer</target>
        </trans-unit>
        <trans-unit id="0880e19f0422595cf18fea5d9a9d51f9476732ea" translate="yes" xml:space="preserve">
          <source>integer-1</source>
          <target state="translated">integer-1</target>
        </trans-unit>
        <trans-unit id="d466665e16fb91305bce8b0426267d80ee09fca8" translate="yes" xml:space="preserve">
          <source>integer-2</source>
          <target state="translated">integer-2</target>
        </trans-unit>
        <trans-unit id="3eff3cc6f22d383c685b3ec52acab1331dc78647" translate="yes" xml:space="preserve">
          <source>interest-rate</source>
          <target state="translated">interest-rate</target>
        </trans-unit>
        <trans-unit id="b47f363e2b430c0647f14deea3eced9b0ef300ce" translate="yes" xml:space="preserve">
          <source>is</source>
          <target state="translated">is</target>
        </trans-unit>
        <trans-unit id="04ba37a0efab1b66029a25010fd96149606f9bf6" translate="yes" xml:space="preserve">
          <source>is less than</source>
          <target state="translated">보다 작다</target>
        </trans-unit>
        <trans-unit id="82577b2a63db0207534b5e7ba5dd739d0aa31cd3" translate="yes" xml:space="preserve">
          <source>is selected. This mode is sometimes called &quot;Banker&amp;rsquo;s rounding&quot;.</source>
          <target state="translated">가 선택되었습니다. 이 모드를 &quot;뱅커의 반올림&quot;이라고도합니다.</target>
        </trans-unit>
        <trans-unit id="8d6b6cf8e6806f74576ba203a91c471b5fa3d139" translate="yes" xml:space="preserve">
          <source>item-1</source>
          <target state="translated">item-1</target>
        </trans-unit>
        <trans-unit id="334df637d343c683e687dbe25c19c31e60954863" translate="yes" xml:space="preserve">
          <source>item-2</source>
          <target state="translated">item-2</target>
        </trans-unit>
        <trans-unit id="b2dccae6b4872c82f860d6e9ce9893824ac678a8" translate="yes" xml:space="preserve">
          <source>ja_JP</source>
          <target state="translated">ja_JP</target>
        </trans-unit>
        <trans-unit id="da556d2f307f11e88fb19c027c41779c23c8d3a3" translate="yes" xml:space="preserve">
          <source>ka_GE, kh_KH, kk_KZ, kl_GL, kn_IN, ko_KR, kok_IN, ky_KG</source>
          <target state="translated">ka_GE, kh_KH, kk_KZ, kl_GL, kn_IN, ko_KR, kok_IN, ky_KG</target>
        </trans-unit>
        <trans-unit id="213ed3ea453bf610688ff8041e0a3b7b6abb5e6e" translate="yes" xml:space="preserve">
          <source>last</source>
          <target state="translated">last</target>
        </trans-unit>
        <trans-unit id="47c20fed16aa6fcb3da0a146bf1113d60840b502" translate="yes" xml:space="preserve">
          <source>lb_LU, lo_LA, lt_LT, lv_LV</source>
          <target state="translated">lb_LU, lo_LA, lt_LT, lv_LV</target>
        </trans-unit>
        <trans-unit id="30ee943dd3606c7af7cfbb5617967cb82ca25748" translate="yes" xml:space="preserve">
          <source>leading and trailing spaces will be removed. The case (upper, lower or mixed) of this argument is irrelevant.</source>
          <target state="translated">선행 및 후행 공백이 제거됩니다. 이 주장의 경우 (상단, 하한 또는 혼합)는 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3d54973f528b01019a58a52d34d518405a01b891" translate="yes" xml:space="preserve">
          <source>length</source>
          <target state="translated">length</target>
        </trans-unit>
        <trans-unit id="36b7334d64ab3bf5006b87f513210897492d9aeb" translate="yes" xml:space="preserve">
          <source>length, consider using either the&lt;code&gt;SUBSTITUTE&lt;/code&gt;intrinsic function (see &lt;a href=&quot;#SUBSTITUTE&quot;&gt;SUBSTITUTE&lt;/a&gt;) or the&lt;code&gt;SUBSTITUTE-CASE&lt;/code&gt;intrinsic function (see &lt;a href=&quot;#SUBSTITUTE_002dCASE&quot;&gt;SUBSTITUTE-CASE&lt;/a&gt;).</source>
          <target state="translated">길이는 사용 중 고려 &lt;code&gt;SUBSTITUTE&lt;/code&gt; 내장 함수 (참조 &lt;a href=&quot;#SUBSTITUTE&quot;&gt;대용품&lt;/a&gt; ) 또는 &lt;code&gt;SUBSTITUTE-CASE&lt;/code&gt; (참조 고유 함수를 &lt;a href=&quot;#SUBSTITUTE_002dCASE&quot;&gt;대체 케이스를&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bad634f05e7986e4b446add7334f687200fcc30f" translate="yes" xml:space="preserve">
          <source>libraries</source>
          <target state="translated">libraries</target>
        </trans-unit>
        <trans-unit id="4e35ef6c79c937e3508918f6d81ee08f922921c1" translate="yes" xml:space="preserve">
          <source>library-name-1</source>
          <target state="translated">library-name-1</target>
        </trans-unit>
        <trans-unit id="4c295ebe9d557baf1130270941dda5964740971a" translate="yes" xml:space="preserve">
          <source>line of the group in which this clause appears.</source>
          <target state="translated">이 절이 나타나는 그룹의 줄.</target>
        </trans-unit>
        <trans-unit id="b91ec97e22039cb627485497de5939717e3b5b7d" translate="yes" xml:space="preserve">
          <source>literal-1</source>
          <target state="translated">literal-1</target>
        </trans-unit>
        <trans-unit id="0a65b805c715c90695767079697ba735dac8548d" translate="yes" xml:space="preserve">
          <source>literal-2</source>
          <target state="translated">literal-2</target>
        </trans-unit>
        <trans-unit id="5ec53893b895f76908df9f21f08a3f472729cde8" translate="yes" xml:space="preserve">
          <source>literal-3</source>
          <target state="translated">literal-3</target>
        </trans-unit>
        <trans-unit id="8f151b5686e5f22d0433c0e8cf8b66a73acf8874" translate="yes" xml:space="preserve">
          <source>literal-7</source>
          <target state="translated">literal-7</target>
        </trans-unit>
        <trans-unit id="abf5608f8d79f898fb306253d2975050ec1b130a" translate="yes" xml:space="preserve">
          <source>literal-8</source>
          <target state="translated">literal-8</target>
        </trans-unit>
        <trans-unit id="2ddac5929f220245722c86038084c6b721a15ecb" translate="yes" xml:space="preserve">
          <source>literal-n</source>
          <target state="translated">literal-n</target>
        </trans-unit>
        <trans-unit id="0e038a42cca30122c3324dfda646d3f079374dd5" translate="yes" xml:space="preserve">
          <source>locale</source>
          <target state="translated">locale</target>
        </trans-unit>
        <trans-unit id="ad5df452f8f3d434647b8422aa8ceac40006c89c" translate="yes" xml:space="preserve">
          <source>locale-name-1</source>
          <target state="translated">locale-name-1</target>
        </trans-unit>
        <trans-unit id="bd3027fa569ea15ca76d84db21c67e2d514c1a5a" translate="yes" xml:space="preserve">
          <source>long</source>
          <target state="translated">long</target>
        </trans-unit>
        <trans-unit id="1171c9c4d02af61af8bf008c32cfdf108d9ddf9b" translate="yes" xml:space="preserve">
          <source>long  long int  signed long  signed long int</source>
          <target state="translated">long long int signed long 서명 된 긴 int</target>
        </trans-unit>
        <trans-unit id="b5656629587221b8239b7141684c8f69c57c8f23" translate="yes" xml:space="preserve">
          <source>long double</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5dba644f98b3753342c7053cd1f1cf4d33492b4" translate="yes" xml:space="preserve">
          <source>long long int  signed long long int</source>
          <target state="translated">long long int 서명 long long int</target>
        </trans-unit>
        <trans-unit id="225607305b3a0bea58569f390ffdfb5e0a57a681" translate="yes" xml:space="preserve">
          <source>making up the &amp;lt;</source>
          <target state="translated">&amp;lt;</target>
        </trans-unit>
        <trans-unit id="07e9b8035af557b3dfaa8d6423a3d5988e463a69" translate="yes" xml:space="preserve">
          <source>making up the string. For example, if &amp;lt;</source>
          <target state="translated">문자열을 구성합니다. 예를 들어 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="2e9240d009766bf7dcc35040c929bc9d417fbade" translate="yes" xml:space="preserve">
          <source>mi_NZ, mk_MK, ml_IN, mn_Cyrl_MN, mn_Mong_CN moh_CA, mr_IN, ms_BN, ms_MY, mt_MT</source>
          <target state="translated">mi_NZ, mk_MK, ml_IN, mn_Cyrl_MN, mn_Mong_CN moh_CA, mr_IN, ms_BN, ms_MY, mt_MT</target>
        </trans-unit>
        <trans-unit id="e8502058829cfba51a93c4e9b73a28d5bbf1c8eb" translate="yes" xml:space="preserve">
          <source>million</source>
          <target state="translated">million</target>
        </trans-unit>
        <trans-unit id="9590fc58f5377ae5b917003bb31ebe13133e932b" translate="yes" xml:space="preserve">
          <source>mnemonic-name-1</source>
          <target state="translated">mnemonic-name-1</target>
        </trans-unit>
        <trans-unit id="0f92dda0c509fe67988118bc93ddecd1e3b90c22" translate="yes" xml:space="preserve">
          <source>mnemonic-name-2</source>
          <target state="translated">mnemonic-name-2</target>
        </trans-unit>
        <trans-unit id="cfba570e97e848caaa28f6ee1d8d851fb1873c2c" translate="yes" xml:space="preserve">
          <source>mnemonic-name-3</source>
          <target state="translated">mnemonic-name-3</target>
        </trans-unit>
        <trans-unit id="4580485d482a9037af94f68af98adf23819cbdf4" translate="yes" xml:space="preserve">
          <source>modules</source>
          <target state="translated">modules</target>
        </trans-unit>
        <trans-unit id="4d0a9e1e89dd9419ca99d38f5cb0a00266462ce2" translate="yes" xml:space="preserve">
          <source>multiple instructions, the one specified first will take priority over the one specified second, (and so forth) as the&lt;code&gt;INSPECT&lt;/code&gt;proceeds forward through the inspect subject, character-by-character.</source>
          <target state="translated">&lt;code&gt;INSPECT&lt;/code&gt; 가 검사 대상을 문자 단위로 진행 함에 따라 여러 명령의 경우 첫 번째로 지정된 명령이 지정된 두 번째 명령보다 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="b752a34cdbf2688aea2d0b54d697c7ca41481962" translate="yes" xml:space="preserve">
          <source>multiple record locking</source>
          <target state="translated">다중 레코드 잠금</target>
        </trans-unit>
        <trans-unit id="50f378229c2f281da767eb8a6f1aaab660dbc7e7" translate="yes" xml:space="preserve">
          <source>multiple replacement instructions, the one specified first will take priority over the one specified second, (and so forth) as the&lt;code&gt;INSPECT&lt;/code&gt;proceeds forward through the inspect subject, character-by-character.</source>
          <target state="translated">&lt;code&gt;INSPECT&lt;/code&gt; 가 검사 대상을 문자 단위로 진행 함에 따라, 복수의 교체 명령에있어서, 먼저 지정된 하나가 지정된 초보다 우선 할 것이다 .</target>
        </trans-unit>
        <trans-unit id="5723d165ed59595207e8c0c85bb720c83f4ce809" translate="yes" xml:space="preserve">
          <source>must</source>
          <target state="translated">must</target>
        </trans-unit>
        <trans-unit id="3ece1471f44f63177cbc35ba0b904e0c096b6783" translate="yes" xml:space="preserve">
          <source>my</source>
          <target state="translated">my</target>
        </trans-unit>
        <trans-unit id="2d21cb91498086c56bd98d77ed2e347f323e5abc" translate="yes" xml:space="preserve">
          <source>nanoseconds-to-sleep</source>
          <target state="translated">nanoseconds-to-sleep</target>
        </trans-unit>
        <trans-unit id="bb84549a6c61802d443c69b93e2044f47674a8d7" translate="yes" xml:space="preserve">
          <source>nb_NO, ne_NP, nl_BE, nl_NL, nn_NO, ns_ZA</source>
          <target state="translated">nb_NO, ne_NP, nl_BE, nl_NL, nn_NO, ns_ZA</target>
        </trans-unit>
        <trans-unit id="e75caf8a34e88ca0f260e3151a4a7c25d661ed86" translate="yes" xml:space="preserve">
          <source>nbytes</source>
          <target state="translated">nbytes</target>
        </trans-unit>
        <trans-unit id="85777c03b72554cd08e721b6148dc27d2a50a7a6" translate="yes" xml:space="preserve">
          <source>never</source>
          <target state="translated">never</target>
        </trans-unit>
        <trans-unit id="7d1b75d4524035840e3860a4b0a00d3e0cf501b6" translate="yes" xml:space="preserve">
          <source>new-file-path</source>
          <target state="translated">new-file-path</target>
        </trans-unit>
        <trans-unit id="edee9402d198b04ac77dcf5dc9cc3dac44573782" translate="yes" xml:space="preserve">
          <source>next</source>
          <target state="translated">next</target>
        </trans-unit>
        <trans-unit id="693601abe691ba1a256cb7ec7310ef05b4342b73" translate="yes" xml:space="preserve">
          <source>no-of-columns</source>
          <target state="translated">no-of-columns</target>
        </trans-unit>
        <trans-unit id="8a4124f3d444fcef48d5c730d8a58b5371714ace" translate="yes" xml:space="preserve">
          <source>no-of-lines</source>
          <target state="translated">no-of-lines</target>
        </trans-unit>
        <trans-unit id="557f255516719ea16f8f4a0aae1166054e2c9b43" translate="yes" xml:space="preserve">
          <source>not</source>
          <target state="translated">not</target>
        </trans-unit>
        <trans-unit id="19bd795751043a22ccad28f97f10989ae6773ac9" translate="yes" xml:space="preserve">
          <source>number-n</source>
          <target state="translated">number-n</target>
        </trans-unit>
        <trans-unit id="1ceb1fc8f4515311d653d1a9fceb729eda7e612e" translate="yes" xml:space="preserve">
          <source>oc_FR, or_IN</source>
          <target state="translated">oc_FR, or_IN</target>
        </trans-unit>
        <trans-unit id="438df02371524711a6810f863f8af74761d4adbe" translate="yes" xml:space="preserve">
          <source>of a word they are creating themselves, but may not create their own word as an exact duplicate (without regard to case) of a COBOL reserved word. Note that a reserved word includes all classes, such as intrinsic functions, mnemonics names, system routines and reserved words.</source>
          <target state="translated">단어 자체는 자신을 만들지 만 COBOL 예약어의 정확한 복제본 (사건에 관계없이)으로 자체 단어를 만들 수는 없습니다. 예약어에는 내장 함수, 니모닉 이름, 시스템 루틴 및 예약어와 같은 모든 클래스가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d2cef8324449cad6fcd6296dd50ba7bfc4485549" translate="yes" xml:space="preserve">
          <source>of its &amp;lt;</source>
          <target state="translated">그것의 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="7eea32ae6b997e915cde5a9467168690b3fc12b3" translate="yes" xml:space="preserve">
          <source>of storage occupied by string, but rather the number of actual</source>
          <target state="translated">문자열이 차지하는 저장 공간이 아니라 실제 수</target>
        </trans-unit>
        <trans-unit id="2605e91ed9c4a654cfb0cc10d80a5b839d89aa18" translate="yes" xml:space="preserve">
          <source>of storage required to store &amp;lt;</source>
          <target state="translated">저장에 필요한 저장 공간 수 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="2dce3529fe1d643164f3325788f59fbe751ab6a8" translate="yes" xml:space="preserve">
          <source>of the &amp;lt;</source>
          <target state="translated">&amp;lt;</target>
        </trans-unit>
        <trans-unit id="584528fbd584739d3cee4f96d2f0e5160df76da5" translate="yes" xml:space="preserve">
          <source>of the argument, not to the &quot;Arg1&quot; data item itself.</source>
          <target state="translated">&quot;Arg1&quot;데이터 항목 자체가 아닌 인수</target>
        </trans-unit>
        <trans-unit id="12f8f69ca68615b20f7a59b8e9461c480041ed91" translate="yes" xml:space="preserve">
          <source>of the choices could be selected.</source>
          <target state="translated">선택 중 하나를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b67d462cb1898a67ac15be58129e5f4a0c45ea82" translate="yes" xml:space="preserve">
          <source>of the expected field contents, but they don&amp;rsquo;t provide any run-time enforcement capabilities.</source>
          <target state="translated">예상되는 필드 내용 중 하나이지만 런타임 시행 기능을 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cdb7134f602e9ae69a5c1b1e5d9ed01b5c1089f2" translate="yes" xml:space="preserve">
          <source>of&lt;code&gt;KEY&lt;/code&gt;field values.</source>
          <target state="translated">의 &lt;code&gt;KEY&lt;/code&gt; 필드 값.</target>
        </trans-unit>
        <trans-unit id="53a610e925bbc0a175e365d31241ae75aeead651" translate="yes" xml:space="preserve">
          <source>offset</source>
          <target state="translated">offset</target>
        </trans-unit>
        <trans-unit id="f39eff231d902e951120c52e24ec1ec55c0f4e02" translate="yes" xml:space="preserve">
          <source>old-file-path</source>
          <target state="translated">old-file-path</target>
        </trans-unit>
        <trans-unit id="0c5dc404c04a6382420b1067dcbd54dd9c72d36d" translate="yes" xml:space="preserve">
          <source>on mainframes. The &quot;modern&quot; programming languages were designed and intended for use on the full variety of computer platforms, from shirt-pocket computers (i.e. smart phones) up to the most massive of supercomputers.</source>
          <target state="translated">메인 프레임에. &quot;현대&quot;프로그래밍 언어는 셔츠 포켓 컴퓨터 (예 : 스마트 폰)에서 가장 큰 수퍼 컴퓨터에 이르기까지 모든 종류의 컴퓨터 플랫폼에서 사용하도록 설계 및 고안되었습니다.</target>
        </trans-unit>
        <trans-unit id="927ba17967f5c8574bec59d8abdb698f02f77da5" translate="yes" xml:space="preserve">
          <source>one having that key value.</source>
          <target state="translated">하나는 그 키 값을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="535be298fd198220e216b199a8f61c63c31e3940" translate="yes" xml:space="preserve">
          <source>one of the values specified on &amp;lt;</source>
          <target state="translated">&amp;lt;에 지정된 값 중 하나</target>
        </trans-unit>
        <trans-unit id="f8969a18a0daab6f59b42990613def0b8b6d48eb" translate="yes" xml:space="preserve">
          <source>only</source>
          <target state="translated">only</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="b4ec2698d7966ba79f03fb8d1d275336dad6acf8" translate="yes" xml:space="preserve">
          <source>or each A,B,C item could be referenced as follows:</source>
          <target state="translated">또는 각 A, B, C 항목은 다음과 같이 참조 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fede30d067e948f0b1df282d890c3f9b28c88f04" translate="yes" xml:space="preserve">
          <source>or more</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e18dad51fd9e8869897fba48fa93d118e5e404" translate="yes" xml:space="preserve">
          <source>outside</source>
          <target state="translated">outside</target>
        </trans-unit>
        <trans-unit id="10e80591d92f76de99d040a135745da09e965721" translate="yes" xml:space="preserve">
          <source>overflow</source>
          <target state="translated">overflow</target>
        </trans-unit>
        <trans-unit id="a85aeba05ff29a64c79b46e91721e04ad7b237c4" translate="yes" xml:space="preserve">
          <source>overflow condition</source>
          <target state="translated">오버 플로우 조건</target>
        </trans-unit>
        <trans-unit id="516b9783fca517eecbd1d064da2d165310b19759" translate="yes" xml:space="preserve">
          <source>p</source>
          <target state="translated">p</target>
        </trans-unit>
        <trans-unit id="c79bf582b108ff0d1408803265b812180b4b0a05" translate="yes" xml:space="preserve">
          <source>pa_IN, pl_PL, ps_AF, pt_BR, pt_PT</source>
          <target state="translated">pa_IN, pl_PL, ps_AF, pt_BR, pt_PT</target>
        </trans-unit>
        <trans-unit id="3fc88b83767af036ec64f408a5c22693db6e3b76" translate="yes" xml:space="preserve">
          <source>part</source>
          <target state="translated">part</target>
        </trans-unit>
        <trans-unit id="1082bca68f8e12601a08bba7c233915f43845b35" translate="yes" xml:space="preserve">
          <source>partial-expression</source>
          <target state="translated">partial-expression</target>
        </trans-unit>
        <trans-unit id="f7ff4ed368bedac08f79aae442cc1507c3f8e23c" translate="yes" xml:space="preserve">
          <source>partial-word-2</source>
          <target state="translated">partial-word-2</target>
        </trans-unit>
        <trans-unit id="430aa2dd7372e5d1ea04b9ce0e001d99a27f773c" translate="yes" xml:space="preserve">
          <source>perceived</source>
          <target state="translated">perceived</target>
        </trans-unit>
        <trans-unit id="87027c65c23c23ca979c2b2a4d13bdd2bda88973" translate="yes" xml:space="preserve">
          <source>perform scope</source>
          <target state="translated">범위를 수행</target>
        </trans-unit>
        <trans-unit id="6c0f74889f239077d2ad94ee7c3c1570d90b5725" translate="yes" xml:space="preserve">
          <source>physically</source>
          <target state="translated">physically</target>
        </trans-unit>
        <trans-unit id="533b443aa0f0c65e72e2c3119f30bca75af15df6" translate="yes" xml:space="preserve">
          <source>picture-string</source>
          <target state="translated">picture-string</target>
        </trans-unit>
        <trans-unit id="31199b77f53a9467ce06fa11ec3bc6de1f3a9f05" translate="yes" xml:space="preserve">
          <source>places, the specifications made on the&lt;code&gt;OPEN&lt;/code&gt;statement will take precedence over those from the&lt;code&gt;SELECT&lt;/code&gt;statement.</source>
          <target state="translated">&lt;code&gt;OPEN&lt;/code&gt; 문에 작성된 스펙 이 &lt;code&gt;SELECT&lt;/code&gt; 문의 스펙 보다 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="c20c2e1477b31426734d5a6addf21b86323eaab8" translate="yes" xml:space="preserve">
          <source>pointer-name-1</source>
          <target state="translated">pointer-name-1</target>
        </trans-unit>
        <trans-unit id="de2dd0958981ff4f0c8b0f6f982d77c9873a3c84" translate="yes" xml:space="preserve">
          <source>pointer-name-2</source>
          <target state="translated">pointer-name-2</target>
        </trans-unit>
        <trans-unit id="e18f18bda25aa010088527eb0a3d4152b2449c73" translate="yes" xml:space="preserve">
          <source>possible, however, to manually allocate linkage section data items that aren&amp;rsquo;t subprogram arguments via the&lt;code&gt;ALLOCATE&lt;/code&gt;statement (see &lt;a href=&quot;#ALLOCATE&quot;&gt;ALLOCATE&lt;/a&gt;) statement. In such cases, initialization will take place as per the documentation of that statement.</source>
          <target state="translated">그러나 &lt;code&gt;ALLOCATE&lt;/code&gt; 문을 통해 서브 프로그램 인수가 아닌 연계 섹션 데이터 항목을 수동으로 할당 할 수 있습니다 ( &lt;a href=&quot;#ALLOCATE&quot;&gt;ALLOCATE&lt;/a&gt; 참조 ). 이러한 경우 해당 명령문의 문서에 따라 초기화가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="967bab6ce060caba3daa22350131f0b8d115cfb8" translate="yes" xml:space="preserve">
          <source>prefixing data items with an indication of where in the program structure they were created. For example:</source>
          <target state="translated">프로그램 구조에서 생성 된 위치를 나타내는 데이터 항목 접두어. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="50644481c7cd620b733fcc580e5d6745665dac74" translate="yes" xml:space="preserve">
          <source>present</source>
          <target state="translated">present</target>
        </trans-unit>
        <trans-unit id="1b2bf1cea7985b24f409bb71d85b8ce321a18c03" translate="yes" xml:space="preserve">
          <source>prevent</source>
          <target state="translated">prevent</target>
        </trans-unit>
        <trans-unit id="d76f79729efeafccf0ae84e817750988afa8142b" translate="yes" xml:space="preserve">
          <source>primary-entry-point-name; paragraph OF section; statement-number</source>
          <target state="translated">기본 엔트리 포인트 이름; 섹션의 단락; 명세서 번호</target>
        </trans-unit>
        <trans-unit id="d807007bebf317b7d6f4e7440492bf70d8284c7f" translate="yes" xml:space="preserve">
          <source>primary-entry-point-name; paragraph; statement-number</source>
          <target state="translated">기본 엔트리 포인트 이름; 절; 명세서 번호</target>
        </trans-unit>
        <trans-unit id="e20ff6a4a8243a1860898c825de6b1e274487d09" translate="yes" xml:space="preserve">
          <source>primary-entry-point-name; section; statement-number</source>
          <target state="translated">기본 엔트리 포인트 이름; 부분; 명세서 번호</target>
        </trans-unit>
        <trans-unit id="6123a6ccd2c4400eb6b9fbec9e6f999012983a94" translate="yes" xml:space="preserve">
          <source>primary-entry-point-name; statement-number</source>
          <target state="translated">기본 엔트리 포인트 이름; 명세서 번호</target>
        </trans-unit>
        <trans-unit id="a25713781b11256c74c4697e173c717844965570" translate="yes" xml:space="preserve">
          <source>procedure-name-1</source>
          <target state="translated">procedure-name-1</target>
        </trans-unit>
        <trans-unit id="e986ac33edee17e139ecc7fc0b6e5329594d34cc" translate="yes" xml:space="preserve">
          <source>procedure-name-2</source>
          <target state="translated">procedure-name-2</target>
        </trans-unit>
        <trans-unit id="f6830a1949c43eac237ae8af2e50dd85b2fad098" translate="yes" xml:space="preserve">
          <source>prog-name-area</source>
          <target state="translated">prog-name-area</target>
        </trans-unit>
        <trans-unit id="81d9aeea0e1a408d65b6660a176c5de83dc98e7b" translate="yes" xml:space="preserve">
          <source>program</source>
          <target state="translated">program</target>
        </trans-unit>
        <trans-unit id="7ca2597258912c52e810db1c329a57b3f6675549" translate="yes" xml:space="preserve">
          <source>program requiring it. This sharing allows the file to be opened, read and/or written and closed in different programs. This sharing applies to the record descriptions subordinate to the file description too.</source>
          <target state="translated">그것을 요구하는 프로그램. 이 공유를 통해 파일을 다른 프로그램에서 열고, 읽거나 쓰고 쓸 수 있습니다. 이 공유는 파일 설명에 종속 된 레코드 설명에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="14aeca04c4fe691bec4a99ab1466754ad67ef664" translate="yes" xml:space="preserve">
          <source>program will read:</source>
          <target state="translated">프로그램은 다음을 읽습니다 :</target>
        </trans-unit>
        <trans-unit id="1a8713bbf0aa6b03447fd0a82f9b4665956fa7be" translate="yes" xml:space="preserve">
          <source>program-id</source>
          <target state="translated">program-id</target>
        </trans-unit>
        <trans-unit id="006de2c31562e5d0ab0f9068e221b36c389cd38f" translate="yes" xml:space="preserve">
          <source>program-pointer</source>
          <target state="translated">program-pointer</target>
        </trans-unit>
        <trans-unit id="4645a2a90a791dddb4d4c1861422bcc7f36292b2" translate="yes" xml:space="preserve">
          <source>program-pointer-1</source>
          <target state="translated">program-pointer-1</target>
        </trans-unit>
        <trans-unit id="cb6fef073fd712f286d487a67671c08ca29eb22f" translate="yes" xml:space="preserve">
          <source>pseudo-text-2</source>
          <target state="translated">pseudo-text-2</target>
        </trans-unit>
        <trans-unit id="22ea1c649c82946aa6e479e1ffd321e4a318b1b0" translate="yes" xml:space="preserve">
          <source>q</source>
          <target state="translated">q</target>
        </trans-unit>
        <trans-unit id="f0cccd21f830d2a19e8fd9e9d0e534af08c2b526" translate="yes" xml:space="preserve">
          <source>qut_GT, quz_BO, quz_EC, quz_PE</source>
          <target state="translated">qut_GT, quz_BO, quz_EC, quz_PE</target>
        </trans-unit>
        <trans-unit id="4dc7c9ec434ed06502767136789763ec11d2c4b7" translate="yes" xml:space="preserve">
          <source>r</source>
          <target state="translated">r</target>
        </trans-unit>
        <trans-unit id="a415ab5cc17c8c093c015ccdb7e552aee7911aa4" translate="yes" xml:space="preserve">
          <source>random</source>
          <target state="translated">random</target>
        </trans-unit>
        <trans-unit id="3bf21923c3325416a371c19c37d33f78c091a774" translate="yes" xml:space="preserve">
          <source>record satisfying the relation condition; to identify this record, the file&amp;rsquo;s contents are searched in a first-to-last (in sequence of the key implied by the&lt;code&gt;KEY&lt;/code&gt;clause), provided the relation is&lt;code&gt;EQUAL TO&lt;/code&gt;&lt;code&gt;GREATER THAN&lt;/code&gt;or&lt;code&gt;GREATER THAN OR EQUAL TO&lt;/code&gt;(or any of their syntactical equivalents).</source>
          <target state="translated">관계 조건을 만족시키는 기록; 이 레코드를 식별하기 위해, 파일의 내용이 검색됩니다 첫 번째 - 투 - 마지막으로 (에 의해 묵시적 키의 순서 &lt;code&gt;KEY&lt;/code&gt; 의 관계를 제공, 절)입니다 &lt;code&gt;EQUAL TO&lt;/code&gt; &lt;code&gt;GREATER THAN&lt;/code&gt; 나 &lt;code&gt;GREATER THAN OR EQUAL TO&lt;/code&gt; (또는 구문의 등가).</target>
        </trans-unit>
        <trans-unit id="b6d5d27d5286bf5026101f5e44bad4c5e54354b6" translate="yes" xml:space="preserve">
          <source>record satisfying the relation condition; to identify this record, the file&amp;rsquo;s contents are searched in a last-to-first (in sequence of the key implied by the&lt;code&gt;KEY&lt;/code&gt;clause), provided the relation is&lt;code&gt;LESS THAN&lt;/code&gt;&lt;code&gt;LESS THAN OR EQUAL TO&lt;/code&gt;or&lt;code&gt;NOT GREATER THAN&lt;/code&gt;(or any of their syntactical equivalents).</source>
          <target state="translated">관계 조건을 만족시키는 기록; 이 레코드를 식별하기 위해, 파일의 내용이 마지막에 - 첫 번째 (에 의해 묵시적 키의 순서로 검색됩니다 &lt;code&gt;KEY&lt;/code&gt; 의 관계를 제공, 절)입니다 &lt;code&gt;LESS THAN&lt;/code&gt; &lt;code&gt;LESS THAN OR EQUAL TO&lt;/code&gt; 나 &lt;code&gt;NOT GREATER THAN&lt;/code&gt; (또는 어떤 자신의 구문 상 등가).</target>
        </trans-unit>
        <trans-unit id="7d8f2fc89c538ae3573d1e8a3d72aa08aa98f40b" translate="yes" xml:space="preserve">
          <source>record-name-1</source>
          <target state="translated">record-name-1</target>
        </trans-unit>
        <trans-unit id="201c8ed1b8f0fb92ffdbcdbd255a22b238d1c653" translate="yes" xml:space="preserve">
          <source>report-name-1</source>
          <target state="translated">report-name-1</target>
        </trans-unit>
        <trans-unit id="47104e2b70e98b356f6378a79d0fbc592a40bfc2" translate="yes" xml:space="preserve">
          <source>represents a space.</source>
          <target state="translated">공백을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d6e7cd005c0ada962cf1ca31f4b64e6f45e1f24b" translate="yes" xml:space="preserve">
          <source>requires</source>
          <target state="translated">requires</target>
        </trans-unit>
        <trans-unit id="37a5301a88da334dc5afc5b63979daa0f3f45e68" translate="yes" xml:space="preserve">
          <source>result</source>
          <target state="translated">result</target>
        </trans-unit>
        <trans-unit id="9ba5ceb884fd6460da4c2340df57740ea5778c5b" translate="yes" xml:space="preserve">
          <source>result is the value which is moved to &amp;lt;</source>
          <target state="translated">결과는 &amp;lt;로 이동 한 값입니다.</target>
        </trans-unit>
        <trans-unit id="16baccc36f9ebda34fff61982c26cfd8fcd0a383" translate="yes" xml:space="preserve">
          <source>result. Additionally, only the&lt;code&gt;TALLYING&lt;/code&gt;clause may be specified.</source>
          <target state="translated">결과. 또한 &lt;code&gt;TALLYING&lt;/code&gt; 절만 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d25adff12aeca79ff39bbb8bb19fc4380115c08" translate="yes" xml:space="preserve">
          <source>return a return code, even if no&lt;code&gt;RETURNING&lt;/code&gt;or&lt;code&gt;STATUS&lt;/code&gt;clause is specified. In the absence of the use of these clauses, the value in the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) at the time the&lt;code&gt;STOP&lt;/code&gt;statement is executed will be used as the return code.</source>
          <target state="translated">&lt;code&gt;RETURNING&lt;/code&gt; 또는 &lt;code&gt;STATUS&lt;/code&gt; 절이 지정 되지 않은 경우에도 리턴 코드를 리턴하십시오 . 이 조항의 사용의 부재에서의 값 &lt;code&gt;RETURN-CODE&lt;/code&gt; 의 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터를&lt;/a&gt; 하여 시간) &lt;code&gt;STOP&lt;/code&gt; 의 문이 리턴 코드로 사용됩니다 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="5bc45587e88faa8f15780a08e796216aafcf7257" translate="yes" xml:space="preserve">
          <source>return-code</source>
          <target state="translated">return-code</target>
        </trans-unit>
        <trans-unit id="d194afe1d8cc0b0e9bcfbbe1bfb2a7d8d66c97c3" translate="yes" xml:space="preserve">
          <source>revolutionary</source>
          <target state="translated">revolutionary</target>
        </trans-unit>
        <trans-unit id="6a7ef641dd9552f46f0ea72685cbccf06a072f6c" translate="yes" xml:space="preserve">
          <source>rm_CH, ro_RO, ru_RU, rw_RW</source>
          <target state="translated">rm_CH, ro_RO, ru_RU, rw_RW</target>
        </trans-unit>
        <trans-unit id="a0f1490a20d0211c997b44bc357e1972deab8ae3" translate="yes" xml:space="preserve">
          <source>s</source>
          <target state="translated">s</target>
        </trans-unit>
        <trans-unit id="1b79c2fe17bf1346e57695b21c57ab6123cfaf3f" translate="yes" xml:space="preserve">
          <source>sa_IN, sah_RU, se_FI, se_NO se_SE, si_LK, sk_SK, sl_SI, sma_NO, sma_SE, smj_NO, smj_SE, smn_FI, sms_FI, sq_AL, sr_Cyrl_BA, sr_Cyrl_CS, sr_Latn_BA, sr_Latn_CS, sv_FI, sv_SE, sw_KE syr_SY</source>
          <target state="translated">sa_IN, sah_RU, se_FI, se_NO se_SE, si_LK, sk_SK, sl_SI, sma_NO, sma_SE, smj_NO, smj_SE, smn_FI, sms_FI, sq_AL, sr_Cyrl_BA, sr_Cyrl_CS, sr_Latn_CS, sr_Latn_BA</target>
        </trans-unit>
        <trans-unit id="7febce039c4cf1c9115e832792b7d7f24fa56d4e" translate="yes" xml:space="preserve">
          <source>seconds</source>
          <target state="translated">seconds</target>
        </trans-unit>
        <trans-unit id="92713d4709377111cf31f2a71986c411bd6cb5b0" translate="yes" xml:space="preserve">
          <source>seed</source>
          <target state="translated">seed</target>
        </trans-unit>
        <trans-unit id="b37299e1f1f93a4a25f4a4f58451d67c881992ea" translate="yes" xml:space="preserve">
          <source>sequential</source>
          <target state="translated">sequential</target>
        </trans-unit>
        <trans-unit id="c6dc9bc9f77b486a13b3f63ffb2ffd1cb3fef4db" translate="yes" xml:space="preserve">
          <source>should</source>
          <target state="translated">should</target>
        </trans-unit>
        <trans-unit id="4306fbbc0e3566b25aaa377909e968804f6bb4dc" translate="yes" xml:space="preserve">
          <source>signed char</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce0b1612aa711b78a720295d271a33894e2b72bf" translate="yes" xml:space="preserve">
          <source>single</source>
          <target state="translated">single</target>
        </trans-unit>
        <trans-unit id="9aef70a1e4e2904358590db89f2743c6ddc1051f" translate="yes" xml:space="preserve">
          <source>sort-file-1</source>
          <target state="translated">sort-file-1</target>
        </trans-unit>
        <trans-unit id="9d953869b5e8556de83213e742ef1e50c58a24e9" translate="yes" xml:space="preserve">
          <source>sort-file-name-1</source>
          <target state="translated">sort-file-name-1</target>
        </trans-unit>
        <trans-unit id="1daf600c25217c309ef03b510e4c83cd70921b85" translate="yes" xml:space="preserve">
          <source>source string</source>
          <target state="translated">소스 문자열</target>
        </trans-unit>
        <trans-unit id="0803df4ff1650933d2ffe6be04d4b21432134252" translate="yes" xml:space="preserve">
          <source>space</source>
          <target state="translated">space</target>
        </trans-unit>
        <trans-unit id="b7ec7da52849cfb15b90e0143a4a307e0f6d6f01" translate="yes" xml:space="preserve">
          <source>specified in the file&amp;rsquo;s&lt;code&gt;SELECT&lt;/code&gt; locks (either automatically or manually acquired) will continue to accumulate as more and more records are read, until they are explicitly released. This is referred to as &amp;rsquo;</source>
          <target state="translated">파일의 &lt;code&gt;SELECT&lt;/code&gt; 잠금에 지정된 (자동 또는 수동으로 획득) 명시 적으로 해제 될 때까지 점점 더 많은 레코드를 읽을 때 누적됩니다. 이것을 '</target>
        </trans-unit>
        <trans-unit id="42f84357f0b8015663a2c088257da04644f9d463" translate="yes" xml:space="preserve">
          <source>specified or implied, or if the conditional expression evaluated to FALSE, processing proceeds with step (C).</source>
          <target state="translated">명시 적이거나 묵시적이거나, 조건식이 FALSE로 평가되면, 처리는 단계 (C)로 진행된다.</target>
        </trans-unit>
        <trans-unit id="3b0e6f143cc51294474bf92cc11c1ff7a50dc8cd" translate="yes" xml:space="preserve">
          <source>specified, and&amp;hellip;</source>
          <target state="translated">지정하고&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="5df6a7389193e5d2949fbbdbb661214ae6d117fa" translate="yes" xml:space="preserve">
          <source>specified, or if the conditional expression evaluated to FALSE, processing continues with the next step.</source>
          <target state="translated">지정되거나 조건식이 FALSE로 평가되면 다음 단계로 처리가 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="9f4dc98623ade7c5ca14c6df925fd732825247fb" translate="yes" xml:space="preserve">
          <source>specified, the compiler will create a&lt;code&gt;PIC X(1024)&lt;/code&gt;data item named &amp;lt;</source>
          <target state="translated">지정된 경우 컴파일러는 &amp;lt;라는 이름 의 &lt;code&gt;PIC X(1024)&lt;/code&gt; 데이터 항목 을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f410e0466ae4b065bfa4d9010ad6056864ed4e50" translate="yes" xml:space="preserve">
          <source>standard</source>
          <target state="translated">standard</target>
        </trans-unit>
        <trans-unit id="2b020927d3c6eb407223a1baa3d6ce3597a3f88d" translate="yes" xml:space="preserve">
          <source>start</source>
          <target state="translated">start</target>
        </trans-unit>
        <trans-unit id="f25feca64a38a57313bdd1f13f76338eb5dade07" translate="yes" xml:space="preserve">
          <source>statement in the sentence.</source>
          <target state="translated">문장에서 진술.</target>
        </trans-unit>
        <trans-unit id="ecb252044b5ea0f679ee78ec1a12904739e2904d" translate="yes" xml:space="preserve">
          <source>string</source>
          <target state="translated">string</target>
        </trans-unit>
        <trans-unit id="eb581281d92f985cc502e78811c5c563d507cbbb" translate="yes" xml:space="preserve">
          <source>subordinate</source>
          <target state="translated">subordinate</target>
        </trans-unit>
        <trans-unit id="67951192c64d6968b79170b6dddeeac619464db2" translate="yes" xml:space="preserve">
          <source>subordinate to</source>
          <target state="translated">종속</target>
        </trans-unit>
        <trans-unit id="044869e8c5c0bc69f8d5fd3b5f06a1fb64f3c6b8" translate="yes" xml:space="preserve">
          <source>substitutable-items</source>
          <target state="translated">substitutable-items</target>
        </trans-unit>
        <trans-unit id="598e0dd9cc034b97f80183f32f7a67201edde5c6" translate="yes" xml:space="preserve">
          <source>summary report</source>
          <target state="translated">요약 보고서</target>
        </trans-unit>
        <trans-unit id="3cbf11c61bec78b03506b701a6f123a3db818acc" translate="yes" xml:space="preserve">
          <source>support this form-feed behaviour when it generates program source listings! See &lt;a href=&quot;https://open-cobol.sourceforge.io/HTML/gnucobsp.html#GCic&quot;&gt;GCic&lt;/a&gt; in</source>
          <target state="translated">프로그램 소스 목록을 생성 할 때이 양식 피드 동작을 지원하십시오! 참조 &lt;a href=&quot;https://open-cobol.sourceforge.io/HTML/gnucobsp.html#GCic&quot;&gt;GCic을&lt;/a&gt; 에</target>
        </trans-unit>
        <trans-unit id="c89e69a1ab912433f13e7d47456dd8954a9e2b46" translate="yes" xml:space="preserve">
          <source>switch-name-1</source>
          <target state="translated">switch-name-1</target>
        </trans-unit>
        <trans-unit id="810a25d76c31e495cc070bdf42e076f7c9b0a1cd" translate="yes" xml:space="preserve">
          <source>symbol</source>
          <target state="translated">symbol</target>
        </trans-unit>
        <trans-unit id="8d08aed541200e2755395f7e69d000d36b1b4aa8" translate="yes" xml:space="preserve">
          <source>symbol represents a space)&lt;code&gt;&lt;i&gt;bbbb&lt;/i&gt;+$1.00&lt;/code&gt; This is not consistent with many other COBOL implementations, where the result would have been&lt;code&gt;+$&lt;i&gt;bbbb&lt;/i&gt;1.00&lt;/code&gt;</source>
          <target state="translated">기호는 공백을 나타냅니다) &lt;code&gt;&lt;i&gt;bbbb&lt;/i&gt;+$1.00&lt;/code&gt; 결과는 &lt;code&gt;+$&lt;i&gt;bbbb&lt;/i&gt;1.00&lt;/code&gt; &lt;i&gt;bbbb&lt;/i&gt; 1.00 이었던 다른 많은 COBOL 구현과 일치하지 않습니다.&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="b5e3b12c6ce4ab936a2a92ef769f03d7184fb620" translate="yes" xml:space="preserve">
          <source>symbolic-character-1</source>
          <target state="translated">symbolic-character-1</target>
        </trans-unit>
        <trans-unit id="8efd86fb78a56a5145ed7739dcb00c78581c5375" translate="yes" xml:space="preserve">
          <source>t</source>
          <target state="translated">t</target>
        </trans-unit>
        <trans-unit id="9638e80a0bffbb8f4712b2bcddc75385f3de2352" translate="yes" xml:space="preserve">
          <source>ta_IN, te_IN, tg_Cyrl_TJ, th_TH tk_TM, tmz_Latn_DZ, tn_ZA, tr_IN, tr_TR, tt_RU</source>
          <target state="translated">ta_IN, te_IN, tg_Cyrl_TJ, th_TH tk_TM, tmz_Latn_DZ, tn_ZA, tr_IN, tr_TR, tt_RU</target>
        </trans-unit>
        <trans-unit id="c3ee137d4f22eb06ed1351d644f3674592c90836" translate="yes" xml:space="preserve">
          <source>table</source>
          <target state="translated">table</target>
        </trans-unit>
        <trans-unit id="2eaa1225f20801f896508a02b9974133b90fc9aa" translate="yes" xml:space="preserve">
          <source>table-name-1</source>
          <target state="translated">table-name-1</target>
        </trans-unit>
        <trans-unit id="aedd4ee4b42bb6735ffe9dcae487a1ec0979a32a" translate="yes" xml:space="preserve">
          <source>target range</source>
          <target state="translated">목표 범위</target>
        </trans-unit>
        <trans-unit id="f5da4e655e7c96491b0104dae4cbc160c531ff7a" translate="yes" xml:space="preserve">
          <source>terminated with a period.</source>
          <target state="translated">마침표로 종료되었습니다.</target>
        </trans-unit>
        <trans-unit id="33b82201081ec7c438cb5d9a36cd72bcb153050b" translate="yes" xml:space="preserve">
          <source>that</source>
          <target state="translated">that</target>
        </trans-unit>
        <trans-unit id="ac835edbd30cb7522ab67e82ef03bac1fcee889e" translate="yes" xml:space="preserve">
          <source>that a &amp;lt;&amp;lt;</source>
          <target state="translated">그 &amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="01a9de102c8170c5461ce6925a98ae4cc11fe8ee" translate="yes" xml:space="preserve">
          <source>that sequence in the table &amp;mdash; the actual sequence of the data</source>
          <target state="translated">표의 해당 순서 &amp;mdash; 데이터의 실제 순서</target>
        </trans-unit>
        <trans-unit id="bbccdf2efb33b52e6c9d0a14dd70b2d415fbea6e" translate="yes" xml:space="preserve">
          <source>the</source>
          <target state="translated">the</target>
        </trans-unit>
        <trans-unit id="2486306f82e3f5971ea30b66b200cf2baa8e6554" translate="yes" xml:space="preserve">
          <source>the C compiler), recognized as such by having a file extension of&lt;code&gt;.o&lt;/code&gt; In these situations, all compilation will be bypassed, and the object code will be &quot;bound&quot; into the generated executable by the loader (an &quot;ld&quot; command executed internally by the&lt;code&gt;cobc&lt;/code&gt;command).</source>
          <target state="translated">파일 확장자가 &lt;code&gt;.o&lt;/code&gt; 인 것으로 인식되는 C 컴파일러) 이러한 상황에서는 모든 컴파일이 무시되고 로더에 의해 생성 된 실행 파일에 오브젝트 코드가 &quot;바운드&quot;됩니다 (내부적으로 실행 된 &quot;ld&quot;명령). 바이 &lt;code&gt;cobc&lt;/code&gt; 의 ) 명령.</target>
        </trans-unit>
        <trans-unit id="0dd3ab43b6b80b1a9f4a627d1d5aa568e5e6bc46" translate="yes" xml:space="preserve">
          <source>the argument was passed to the subprogram&lt;code&gt;BY REFERENCE&lt;/code&gt;by the calling program. See &lt;a href=&quot;#Subprogram-Arguments&quot;&gt;Subprogram Arguments&lt;/a&gt;, for additional information on the mechanics of how arguments are passed to subprograms.</source>
          <target state="translated">호출 프로그램 이 인수를 서브 프로그램 &lt;code&gt;BY REFERENCE&lt;/code&gt; 에 전달했습니다 . 인수가 서브 프로그램에 전달되는 방식에 대한 추가 정보는 &lt;a href=&quot;#Subprogram-Arguments&quot;&gt;서브 프로그램 인수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6c329baf35625d7b39ff51b67492590d39fe4c7c" translate="yes" xml:space="preserve">
          <source>the following are two different command window sessions &amp;mdash; the left on a Unix/Cygwin/OSX system and the right on a windows system &amp;mdash; that will set the switch on and then execute the &quot;testprog&quot; program. Notice how the message indicating that the program detected the switch was set is displayed in both examples:</source>
          <target state="translated">다음은 서로 다른 두 가지 명령 창 세션 (UNIX / Cygwin / OSX 시스템의 왼쪽과 Windows 시스템의 오른쪽)으로, 스위치를 켜고 &quot;testprog&quot;프로그램을 실행합니다. 프로그램이 스위치 설정을 감지했음을 나타내는 메시지가 두 예에서 어떻게 표시되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a9ab3d8b07e7734fe1768b2412be537e1d55d314" translate="yes" xml:space="preserve">
          <source>the form-feed character depends upon whether the programmer coded&lt;code&gt;WRITE &amp;lt;&lt;i&gt;record-name&lt;/i&gt;&amp;gt; BEFORE ADVANCING PAGE&lt;/code&gt;or&lt;code&gt;WRITE &amp;lt;&lt;i&gt;record-name&lt;/i&gt;&amp;gt; AFTER ADVANCING PAGE&lt;/code&gt; respectively.</source>
          <target state="translated">형태 공급 문자 프로그래머 부호화할지 여부에 의존 &lt;code&gt;WRITE &amp;lt;&lt;i&gt;record-name&lt;/i&gt;&amp;gt; BEFORE ADVANCING PAGE&lt;/code&gt; 또는 &lt;code&gt;WRITE &amp;lt;&lt;i&gt;record-name&lt;/i&gt;&amp;gt; AFTER ADVANCING PAGE&lt;/code&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="695c5d4133e38e7c1ca5eb28525db3e6918b58f1" translate="yes" xml:space="preserve">
          <source>the length of &amp;lt;</source>
          <target state="translated">&amp;lt;의 길이</target>
        </trans-unit>
        <trans-unit id="c63a6a8383c8472ad904a2231e32fbce4b1ac611" translate="yes" xml:space="preserve">
          <source>the length of the &quot;to&quot; string, then the &quot;to&quot; string will be truncated to the length of the &quot;from&quot; string.</source>
          <target state="translated">&quot;to&quot;문자열의 길이 인 경우 &quot;to&quot;문자열은 &quot;from&quot;문자열의 길이로 잘립니다.</target>
        </trans-unit>
        <trans-unit id="3a83f85ad2a3de250d7ed2104ecdea9fd7c88fa2" translate="yes" xml:space="preserve">
          <source>the report or screen sections.</source>
          <target state="translated">보고서 또는 화면 섹션.</target>
        </trans-unit>
        <trans-unit id="f1c5674ea2dee341d6d96912ce540d3a4cf42de4" translate="yes" xml:space="preserve">
          <source>the scope of a procedural&lt;code&gt;PERFORM&lt;/code&gt; control simply transfers to the first executable statement in the next paragraph &lt;code&gt;EXIT PARAGRAPH&lt;/code&gt; or section &lt;code&gt;EXIT SECTION&lt;/code&gt;.</source>
          <target state="translated">절차 적 &lt;code&gt;PERFORM&lt;/code&gt; 컨트롤 의 범위는 단순히 다음 단락 &lt;code&gt;EXIT PARAGRAPH&lt;/code&gt; 또는 &lt;code&gt;EXIT SECTION&lt;/code&gt; 섹션 의 첫 번째 실행 문으로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="2188bd025dd469ba059449931e15e610aae4bff0" translate="yes" xml:space="preserve">
          <source>the scope of a procedural&lt;code&gt;PERFORM&lt;/code&gt;(see &lt;a href=&quot;#Procedural-PERFORM&quot;&gt;Procedural PERFORM&lt;/a&gt;), control will be returned back to the&lt;code&gt;PERFORM&lt;/code&gt;for evaluation of any&lt;code&gt;TIMES&lt;/code&gt;&lt;code&gt;VARYING&lt;/code&gt;and/or&lt;code&gt;UNTIL&lt;/code&gt;clauses.</source>
          <target state="translated">절차의 범위가 &lt;code&gt;PERFORM&lt;/code&gt; (참조 &lt;a href=&quot;#Procedural-PERFORM&quot;&gt;절차 수행&lt;/a&gt; ), 컨트롤을 다시 반환한다 &lt;code&gt;PERFORM&lt;/code&gt; 어느 평가 &lt;code&gt;TIMES&lt;/code&gt; &lt;code&gt;VARYING&lt;/code&gt; 및 / 또는 &lt;code&gt;UNTIL&lt;/code&gt; 절.</target>
        </trans-unit>
        <trans-unit id="a6ba10cc3bd4c97618d69ba8655b6ae4e12a9e13" translate="yes" xml:space="preserve">
          <source>the termination of program execution; should the error procedure not issue its own&lt;code&gt;STOP RUN&lt;/code&gt; control will return back to the standard error routine when the error procedure exits.</source>
          <target state="translated">프로그램 실행의 종료; 오류 절차가 자체 &lt;code&gt;STOP RUN&lt;/code&gt; 을 발행하지 않으면 오류 절차가 종료 될 때 표준 오류 루틴으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="f9896a7eeac75d15ec5e301d11fec2de13b7cfda" translate="yes" xml:space="preserve">
          <source>the&lt;code&gt;DISPLAY&lt;/code&gt;statement gets executed, when PD-Row-No is 3 and PD-Col-No is 4 the&lt;code&gt;DISPLAY&lt;/code&gt;statement won&amp;rsquo;t be executed.</source>
          <target state="translated">&lt;code&gt;DISPLAY&lt;/code&gt; 문은 PD-행-없음이 3 일 때, 실행 및 PD-골 - 아니오 4 도착 &lt;code&gt;DISPLAY&lt;/code&gt; 문이 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="19fbaeb3cccbf3301c042b84bd950f4865c8cd86" translate="yes" xml:space="preserve">
          <source>the&lt;code&gt;SEPARATE CHARACTER&lt;/code&gt;</source>
          <target state="translated">분리 &lt;code&gt;SEPARATE CHARACTER&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dd748a38b5c610caccec151a6f48d8e1047527ed" translate="yes" xml:space="preserve">
          <source>the&lt;code&gt;TO&lt;/code&gt; this statement will be identifying the address of &amp;lt;</source>
          <target state="translated">&lt;code&gt;TO&lt;/code&gt; 이 문의 주소를 확인하는 것입니다 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="1ea8d2f1cd68bde8a980e3dbe9c912ddb9e905f6" translate="yes" xml:space="preserve">
          <source>the&lt;code&gt;TO&lt;/code&gt;keyword with the corresponding characters from the string specified</source>
          <target state="translated">지정된 문자열의 해당 문자가 있는 &lt;code&gt;TO&lt;/code&gt; 키워드</target>
        </trans-unit>
        <trans-unit id="bf891b806423f3a78536d67e64dd38a521a37f63" translate="yes" xml:space="preserve">
          <source>the&lt;code&gt;TO&lt;/code&gt;keyword.</source>
          <target state="translated">the&lt;code&gt;TO&lt;/code&gt;keyword.</target>
        </trans-unit>
        <trans-unit id="714eea0f4c980736bde0065fe73f573487f08e3a" translate="yes" xml:space="preserve">
          <source>time</source>
          <target state="translated">time</target>
        </trans-unit>
        <trans-unit id="c1d464db0a444b174dd7d8be04139f022d7349f7" translate="yes" xml:space="preserve">
          <source>time &amp;mdash; via an&lt;code&gt;EXIT&lt;/code&gt;statement (see &lt;a href=&quot;#EXIT&quot;&gt;EXIT&lt;/a&gt;) &amp;mdash; if required.</source>
          <target state="translated">필요한 경우 &lt;code&gt;EXIT&lt;/code&gt; 문을 통한 시간 ( &lt;a href=&quot;#EXIT&quot;&gt;EXIT&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="a145d1330e9c8a763559c8e46505c73885124942" translate="yes" xml:space="preserve">
          <source>time unless the</source>
          <target state="translated">시간이 아니라면</target>
        </trans-unit>
        <trans-unit id="b044a6e5cd90fc108cda94f52dd0af692a7cad3f" translate="yes" xml:space="preserve">
          <source>time unless&lt;code&gt;WITH DEBUGGING MODE&lt;/code&gt;is specified in the&lt;code&gt;SOURCE-COMPUTER&lt;/code&gt;(see &lt;a href=&quot;#SOURCE_002dCOMPUTER&quot;&gt;SOURCE-COMPUTER&lt;/a&gt;) paragraph. Neither the compiler&amp;rsquo;s&lt;code&gt;-fdebugging-line&lt;/code&gt;switch</source>
          <target state="translated">&lt;code&gt;WITH DEBUGGING MODE&lt;/code&gt; 가 &lt;code&gt;SOURCE-COMPUTER&lt;/code&gt; ( &lt;a href=&quot;#SOURCE_002dCOMPUTER&quot;&gt;SOURCE-COMPUTER&lt;/a&gt; 참조 ) 단락에 지정되어 있지 않으면 시간 입니다. 컴파일러의 &lt;code&gt;-fdebugging-line&lt;/code&gt; 스위치도</target>
        </trans-unit>
        <trans-unit id="11a572aecafbc0f74cba80722d6c2694c9293479" translate="yes" xml:space="preserve">
          <source>times.</source>
          <target state="translated">times.</target>
        </trans-unit>
        <trans-unit id="01029925e79f8625c47170d35e01dd762bf1df59" translate="yes" xml:space="preserve">
          <source>to an 01-level data item.</source>
          <target state="translated">01 수준 데이터 항목에.</target>
        </trans-unit>
        <trans-unit id="77799c08e21729f4a3ac743f43c361cc38ef53e6" translate="yes" xml:space="preserve">
          <source>to be specified as two-digit numbers, but every example you see in this document will take that approach!</source>
          <target state="translated">두 자리 숫자로 지정해야하지만이 문서에서 볼 수있는 모든 예제가 그 방법을 사용합니다!</target>
        </trans-unit>
        <trans-unit id="1e5b960fcb2c525cce542ecfbaa4980a0fc6cfe3" translate="yes" xml:space="preserve">
          <source>to be. Some, like .NET and Ruby, aren&amp;rsquo;t even</source>
          <target state="translated">되려고. .NET 및 Ruby와 같은 일부는</target>
        </trans-unit>
        <trans-unit id="4efa2ec2b14abc39f6d804aa170ac871a1eeb05f" translate="yes" xml:space="preserve">
          <source>to have</source>
          <target state="translated">가지고</target>
        </trans-unit>
        <trans-unit id="ae51058b5a080e94f27f5e5b121184b6cb2f8f65" translate="yes" xml:space="preserve">
          <source>to one of those four device names.</source>
          <target state="translated">네 가지 장치 이름 중 하나에</target>
        </trans-unit>
        <trans-unit id="8b44c248ec32b071a1a7aafa16b55a17a8feb834" translate="yes" xml:space="preserve">
          <source>to this:</source>
          <target state="translated">이에:</target>
        </trans-unit>
        <trans-unit id="d6df94276e016ba6af225219e234219c7eeae7ce" translate="yes" xml:space="preserve">
          <source>to-n</source>
          <target state="translated">to-n</target>
        </trans-unit>
        <trans-unit id="f99abcfae6c3ce6d22597f95ad6ef260d31527a6" translate="yes" xml:space="preserve">
          <source>twice</source>
          <target state="translated">twice</target>
        </trans-unit>
        <trans-unit id="ad782ecdac770fc6eb9a62e44f90873fb97fb26b" translate="yes" xml:space="preserve">
          <source>two</source>
          <target state="translated">two</target>
        </trans-unit>
        <trans-unit id="51e69892ab49df85c6230ccc57f8e1d1606caccc" translate="yes" xml:space="preserve">
          <source>u</source>
          <target state="translated">u</target>
        </trans-unit>
        <trans-unit id="915ba93f0fecb20fc8f4c5df3de04df7d2967812" translate="yes" xml:space="preserve">
          <source>ug_CN, uk_UA, ur_PK, uz_Cyrl_UZ, uz_Latn_UZ</source>
          <target state="translated">ug_CN, uk_UA, ur_PK, uz_Cyrl_UZ, uz_Latn_UZ</target>
        </trans-unit>
        <trans-unit id="42e184930956d048c819e40f18f94f0094d47bc6" translate="yes" xml:space="preserve">
          <source>unless</source>
          <target state="translated">unless</target>
        </trans-unit>
        <trans-unit id="9b1fb9e82074e8aa4edc08ad23dce59c4abcd2ea" translate="yes" xml:space="preserve">
          <source>unsigned  unsigned int  unsigned short  unsigned short int</source>
          <target state="translated">부호없는 부호없는 int 부호없는 짧은 부호없는 short int</target>
        </trans-unit>
        <trans-unit id="3dc11840724e97d93a4558d0250b1f937eb7198b" translate="yes" xml:space="preserve">
          <source>unsigned char</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d524cc23149567a725f674f908d6a4b0fda70f77" translate="yes" xml:space="preserve">
          <source>unsigned long  unsigned long int</source>
          <target state="translated">부호없는 long 부호없는 long int</target>
        </trans-unit>
        <trans-unit id="e4ab158d2c89a62641582afbbfca7c144d6958d8" translate="yes" xml:space="preserve">
          <source>unsigned long long  unsigned long long int</source>
          <target state="translated">부호없는 long long 부호없는 long long int</target>
        </trans-unit>
        <trans-unit id="70e59eb9757e4a4b74cad1a8c4a0c6a481d909a1" translate="yes" xml:space="preserve">
          <source>usage-name</source>
          <target state="translated">usage-name</target>
        </trans-unit>
        <trans-unit id="b91fc6f415b2403b4cb508b03e84e5ca72547203" translate="yes" xml:space="preserve">
          <source>use&lt;code&gt;BY VALUE&lt;/code&gt;arguments when calling GnuCOBOL subroutines, but remember that those arguments are limited to being a numeric binary data item.</source>
          <target state="translated">GnuCOBOL 서브 루틴을 호출 할 때 &lt;code&gt;BY VALUE&lt;/code&gt; 인수를 사용 하지만 해당 인수는 숫자 2 진 데이터 항목으로 제한됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
