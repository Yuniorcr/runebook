<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="gnu_fortran">
    <body>
      <group id="gnu_fortran">
        <trans-unit id="31118522388c4531f8fb8950dd7f59eac534bf88" translate="yes" xml:space="preserve">
          <source>9.99 &lt;code&gt;EVENT_QUERY&lt;/code&gt; &amp;mdash; Query whether a coarray event has occurred</source>
          <target state="translated">9.99 &lt;code&gt;EVENT_QUERY&lt;/code&gt; &amp;mdash; 성긴 이벤트가 발생했는지 쿼리</target>
        </trans-unit>
        <trans-unit id="1535bcbe09c7757b3227dd9b6b2a79e542fb2334" translate="yes" xml:space="preserve">
          <source>9.99 EVENT_QUERY &amp;mdash; Query whether a coarray event has occurred</source>
          <target state="translated">9.99 EVENT_QUERY &amp;mdash; 성긴 이벤트가 발생했는지 쿼리</target>
        </trans-unit>
        <trans-unit id="848ad12645bdcac61958ced883f82f64f6373edd" translate="yes" xml:space="preserve">
          <source>9.99. EVENT_QUERY</source>
          <target state="translated">9.99. EVENT_QUERY</target>
        </trans-unit>
        <trans-unit id="05a79f06cf3f67f726dae68d18a2290f6c9a50c9" translate="yes" xml:space="preserve">
          <source>:</source>
          <target state="translated">:</target>
        </trans-unit>
        <trans-unit id="30efd688ae27fc8b3582f6390698667e33a87317" translate="yes" xml:space="preserve">
          <source>; a line may start with a semicolon; for internal and module procedures &lt;code&gt;END&lt;/code&gt; can be used instead of &lt;code&gt;END SUBROUTINE&lt;/code&gt; and &lt;code&gt;END FUNCTION&lt;/code&gt;; &lt;code&gt;SELECTED_REAL_KIND&lt;/code&gt; now also takes a &lt;code&gt;RADIX&lt;/code&gt; argument; intrinsic types are supported for &lt;code&gt;TYPE&lt;/code&gt;(&lt;var&gt;intrinsic-type-spec&lt;/var&gt;); multiple type-bound procedures can be declared in a single &lt;code&gt;PROCEDURE&lt;/code&gt; statement; implied-shape arrays are supported for named constants (&lt;code&gt;PARAMETER&lt;/code&gt;).</source>
          <target state="translated">; 줄은 세미콜론으로 시작할 수 있습니다. 내부 및 모듈 절차 의 경우 &lt;code&gt;END SUBROUTINE&lt;/code&gt; 및 &lt;code&gt;END FUNCTION&lt;/code&gt; 대신 &lt;code&gt;END&lt;/code&gt; 를 사용할 수 있습니다 . &lt;code&gt;SELECTED_REAL_KIND&lt;/code&gt; 는 이제 &lt;code&gt;RADIX&lt;/code&gt; 인수도 사용합니다. 내장형은 &lt;code&gt;TYPE&lt;/code&gt; ( &lt;var&gt;intrinsic-type-spec&lt;/var&gt; )에 지원됩니다. 단일 유형 프로시 저는 단일 &lt;code&gt;PROCEDURE&lt;/code&gt; 문 에서 선언 될 수 있습니다 . 묵시적 배열은 명명 된 상수 ( &lt;code&gt;PARAMETER&lt;/code&gt; )에 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="c5ad5a39e32070263fcba8df5389d5af8c1e1b6d" translate="yes" xml:space="preserve">
          <source>; it causes the preprocessor to treat comments as tokens in their own right. For example, comments appearing at the start of what would be a directive line have the effect of turning that line into an ordinary source line, since the first token on the line is no longer a &lt;code&gt;'#'&lt;/code&gt;.</source>
          <target state="translated">; 전처리 기가 주석을 토큰으로 취급하도록합니다. 예를 들어, 지시문 줄의 시작 부분에 나타나는 주석은 해당 줄을 첫 번째 토큰이 더 이상 &lt;code&gt;'#'&lt;/code&gt; 이 아니기 때문에 해당 줄을 일반 소스 줄로 바꾸는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e0c84559f5ca074359299544164c9bb4eb30b6d" translate="yes" xml:space="preserve">
          <source>; note, however, that compile-time optimizations may convert them into quiet NaN and that trapping needs to be enabled (e.g. via</source>
          <target state="translated">; 그러나 컴파일 타임 최적화는이를 조용한 NaN으로 변환 할 수 있으며 트래핑을 활성화해야합니다 (예 :</target>
        </trans-unit>
        <trans-unit id="169a27909cc4636a203820a2820a62bb0c08be3d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;abort#ABORT&quot;&gt;ABORT&lt;/a&gt;, &lt;a href=&quot;exit#EXIT&quot;&gt;EXIT&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;abort#ABORT&quot;&gt;ABORT&lt;/a&gt; , &lt;a href=&quot;exit#EXIT&quot;&gt;EXIT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="49a6a9585c0d98c108876115490fe2636299cb42" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;abort#ABORT&quot;&gt;ABORT&lt;/a&gt;, &lt;a href=&quot;kill#KILL&quot;&gt;KILL&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;abort#ABORT&quot;&gt;ABORT&lt;/a&gt; , &lt;a href=&quot;kill#KILL&quot;&gt;KILL&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="11b77efacfc6239cf4f9846e2baca734d33ea3f9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;achar#ACHAR&quot;&gt;ACHAR&lt;/a&gt;, &lt;a href=&quot;char#CHAR&quot;&gt;CHAR&lt;/a&gt;, &lt;a href=&quot;iachar#IACHAR&quot;&gt;IACHAR&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;achar#ACHAR&quot;&gt;ACHAR&lt;/a&gt; , &lt;a href=&quot;char#CHAR&quot;&gt;CHAR&lt;/a&gt; , &lt;a href=&quot;iachar#IACHAR&quot;&gt;IACHAR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0ad15f1024b6e010663591857404106d9410dae6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;achar#ACHAR&quot;&gt;ACHAR&lt;/a&gt;, &lt;a href=&quot;char#CHAR&quot;&gt;CHAR&lt;/a&gt;, &lt;a href=&quot;ichar#ICHAR&quot;&gt;ICHAR&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;achar#ACHAR&quot;&gt;ACHAR&lt;/a&gt; , &lt;a href=&quot;char#CHAR&quot;&gt;CHAR&lt;/a&gt; , &lt;a href=&quot;ichar#ICHAR&quot;&gt;ICHAR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7f4bfd344c9ccf8e3fa89519025cfb4e1109b5ed" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;achar#ACHAR&quot;&gt;ACHAR&lt;/a&gt;, &lt;a href=&quot;iachar#IACHAR&quot;&gt;IACHAR&lt;/a&gt;, &lt;a href=&quot;ichar#ICHAR&quot;&gt;ICHAR&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;achar#ACHAR&quot;&gt;ACHAR&lt;/a&gt; , &lt;a href=&quot;iachar#IACHAR&quot;&gt;IACHAR&lt;/a&gt; , &lt;a href=&quot;ichar#ICHAR&quot;&gt;ICHAR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a99a0a5ca80d4620c475abff493a6b1d609e2c1d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;adjustl#ADJUSTL&quot;&gt;ADJUSTL&lt;/a&gt;, &lt;a href=&quot;adjustr#ADJUSTR&quot;&gt;ADJUSTR&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;adjustl#ADJUSTL&quot;&gt;조정&lt;/a&gt; , &lt;a href=&quot;adjustr#ADJUSTR&quot;&gt;조정&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1c7ff4866c02ca82f7ccecfa09fce986b765f577" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;adjustl#ADJUSTL&quot;&gt;ADJUSTL&lt;/a&gt;, &lt;a href=&quot;trim#TRIM&quot;&gt;TRIM&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;adjustl#ADJUSTL&quot;&gt;조정&lt;/a&gt; , &lt;a href=&quot;trim#TRIM&quot;&gt;트림&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="24a8fbd10b4817bc8a7eff60d437ad56af5229f2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;adjustr#ADJUSTR&quot;&gt;ADJUSTR&lt;/a&gt;, &lt;a href=&quot;trim#TRIM&quot;&gt;TRIM&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;adjustr#ADJUSTR&quot;&gt;조정&lt;/a&gt; , &lt;a href=&quot;trim#TRIM&quot;&gt;트림&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1406d0512531a3ada467de82d3440b3945cd78a1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;atomic_005fdefine#ATOMIC_005fDEFINE&quot;&gt;ATOMIC_DEFINE&lt;/a&gt;, &lt;a href=&quot;atomic_005fadd#ATOMIC_005fADD&quot;&gt;ATOMIC_ADD&lt;/a&gt;, &lt;a href=&quot;iso_005ffortran_005fenv#ISO_005fFORTRAN_005fENV&quot;&gt;ISO_FORTRAN_ENV&lt;/a&gt;, &lt;a href=&quot;atomic_005ffetch_005fand#ATOMIC_005fFETCH_005fAND&quot;&gt;ATOMIC_FETCH_AND&lt;/a&gt;, &lt;a href=&quot;atomic_005ffetch_005for#ATOMIC_005fFETCH_005fOR&quot;&gt;ATOMIC_FETCH_OR&lt;/a&gt;, &lt;a href=&quot;atomic_005ffetch_005fxor#ATOMIC_005fFETCH_005fXOR&quot;&gt;ATOMIC_FETCH_XOR&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;atomic_005fdefine#ATOMIC_005fDEFINE&quot;&gt;ATOMIC_DEFINE&lt;/a&gt; , &lt;a href=&quot;atomic_005fadd#ATOMIC_005fADD&quot;&gt;ATOMIC_ADD&lt;/a&gt; , &lt;a href=&quot;iso_005ffortran_005fenv#ISO_005fFORTRAN_005fENV&quot;&gt;ISO_FORTRAN_ENV&lt;/a&gt; , &lt;a href=&quot;atomic_005ffetch_005fand#ATOMIC_005fFETCH_005fAND&quot;&gt;ATOMIC_FETCH_AND&lt;/a&gt; , &lt;a href=&quot;atomic_005ffetch_005for#ATOMIC_005fFETCH_005fOR&quot;&gt;ATOMIC_FETCH_OR&lt;/a&gt; , &lt;a href=&quot;atomic_005ffetch_005fxor#ATOMIC_005fFETCH_005fXOR&quot;&gt;ATOMIC_FETCH_XOR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b27ac829751ca6e3102078d89c1ac3e776120b6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;atomic_005fdefine#ATOMIC_005fDEFINE&quot;&gt;ATOMIC_DEFINE&lt;/a&gt;, &lt;a href=&quot;atomic_005fand#ATOMIC_005fAND&quot;&gt;ATOMIC_AND&lt;/a&gt;, &lt;a href=&quot;iso_005ffortran_005fenv#ISO_005fFORTRAN_005fENV&quot;&gt;ISO_FORTRAN_ENV&lt;/a&gt;, &lt;a href=&quot;atomic_005ffetch_005fadd#ATOMIC_005fFETCH_005fADD&quot;&gt;ATOMIC_FETCH_ADD&lt;/a&gt;, &lt;a href=&quot;atomic_005ffetch_005for#ATOMIC_005fFETCH_005fOR&quot;&gt;ATOMIC_FETCH_OR&lt;/a&gt;, &lt;a href=&quot;atomic_005ffetch_005fxor#ATOMIC_005fFETCH_005fXOR&quot;&gt;ATOMIC_FETCH_XOR&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;atomic_005fdefine#ATOMIC_005fDEFINE&quot;&gt;ATOMIC_DEFINE&lt;/a&gt; , &lt;a href=&quot;atomic_005fand#ATOMIC_005fAND&quot;&gt;ATOMIC_AND&lt;/a&gt; , &lt;a href=&quot;iso_005ffortran_005fenv#ISO_005fFORTRAN_005fENV&quot;&gt;ISO_FORTRAN_ENV&lt;/a&gt; , &lt;a href=&quot;atomic_005ffetch_005fadd#ATOMIC_005fFETCH_005fADD&quot;&gt;ATOMIC_FETCH_ADD&lt;/a&gt; , &lt;a href=&quot;atomic_005ffetch_005for#ATOMIC_005fFETCH_005fOR&quot;&gt;ATOMIC_FETCH_OR&lt;/a&gt; , &lt;a href=&quot;atomic_005ffetch_005fxor#ATOMIC_005fFETCH_005fXOR&quot;&gt;ATOMIC_FETCH_XOR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a0421581df3c451147b544d9ddccc775159b4a3a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;atomic_005fdefine#ATOMIC_005fDEFINE&quot;&gt;ATOMIC_DEFINE&lt;/a&gt;, &lt;a href=&quot;atomic_005fcas#ATOMIC_005fCAS&quot;&gt;ATOMIC_CAS&lt;/a&gt;, &lt;a href=&quot;iso_005ffortran_005fenv#ISO_005fFORTRAN_005fENV&quot;&gt;ISO_FORTRAN_ENV&lt;/a&gt;, &lt;a href=&quot;atomic_005ffetch_005fadd#ATOMIC_005fFETCH_005fADD&quot;&gt;ATOMIC_FETCH_ADD&lt;/a&gt;, &lt;a href=&quot;atomic_005ffetch_005fand#ATOMIC_005fFETCH_005fAND&quot;&gt;ATOMIC_FETCH_AND&lt;/a&gt;, &lt;a href=&quot;atomic_005ffetch_005for#ATOMIC_005fFETCH_005fOR&quot;&gt;ATOMIC_FETCH_OR&lt;/a&gt;, &lt;a href=&quot;atomic_005ffetch_005fxor#ATOMIC_005fFETCH_005fXOR&quot;&gt;ATOMIC_FETCH_XOR&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;atomic_005fdefine#ATOMIC_005fDEFINE&quot;&gt;ATOMIC_DEFINE&lt;/a&gt; , &lt;a href=&quot;atomic_005fcas#ATOMIC_005fCAS&quot;&gt;ATOMIC_CAS&lt;/a&gt; , &lt;a href=&quot;iso_005ffortran_005fenv#ISO_005fFORTRAN_005fENV&quot;&gt;ISO_FORTRAN_ENV&lt;/a&gt; , &lt;a href=&quot;atomic_005ffetch_005fadd#ATOMIC_005fFETCH_005fADD&quot;&gt;ATOMIC_FETCH_ADD&lt;/a&gt; , &lt;a href=&quot;atomic_005ffetch_005fand#ATOMIC_005fFETCH_005fAND&quot;&gt;ATOMIC_FETCH_AND&lt;/a&gt; , &lt;a href=&quot;atomic_005ffetch_005for#ATOMIC_005fFETCH_005fOR&quot;&gt;ATOMIC_FETCH_OR&lt;/a&gt; , &lt;a href=&quot;atomic_005ffetch_005fxor#ATOMIC_005fFETCH_005fXOR&quot;&gt;ATOMIC_FETCH_XOR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb838e1b6f86b043360891bbef483c9f88cc0b9f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;atomic_005fdefine#ATOMIC_005fDEFINE&quot;&gt;ATOMIC_DEFINE&lt;/a&gt;, &lt;a href=&quot;atomic_005ffetch_005fadd#ATOMIC_005fFETCH_005fADD&quot;&gt;ATOMIC_FETCH_ADD&lt;/a&gt;, &lt;a href=&quot;iso_005ffortran_005fenv#ISO_005fFORTRAN_005fENV&quot;&gt;ISO_FORTRAN_ENV&lt;/a&gt;, &lt;a href=&quot;atomic_005fand#ATOMIC_005fAND&quot;&gt;ATOMIC_AND&lt;/a&gt;, &lt;a href=&quot;atomic_005for#ATOMIC_005fOR&quot;&gt;ATOMIC_OR&lt;/a&gt;, &lt;a href=&quot;atomic_005fxor#ATOMIC_005fXOR&quot;&gt;ATOMIC_XOR&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;atomic_005fdefine#ATOMIC_005fDEFINE&quot;&gt;ATOMIC_DEFINE&lt;/a&gt; , &lt;a href=&quot;atomic_005ffetch_005fadd#ATOMIC_005fFETCH_005fADD&quot;&gt;ATOMIC_FETCH_ADD&lt;/a&gt; , &lt;a href=&quot;iso_005ffortran_005fenv#ISO_005fFORTRAN_005fENV&quot;&gt;ISO_FORTRAN_ENV&lt;/a&gt; , &lt;a href=&quot;atomic_005fand#ATOMIC_005fAND&quot;&gt;ATOMIC_AND&lt;/a&gt; , &lt;a href=&quot;atomic_005for#ATOMIC_005fOR&quot;&gt;ATOMIC_OR&lt;/a&gt; , &lt;a href=&quot;atomic_005fxor#ATOMIC_005fXOR&quot;&gt;ATOMIC_XOR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="38f700700644863751917c38e8eff9c704c9537c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;atomic_005fdefine#ATOMIC_005fDEFINE&quot;&gt;ATOMIC_DEFINE&lt;/a&gt;, &lt;a href=&quot;atomic_005ffetch_005fand#ATOMIC_005fFETCH_005fAND&quot;&gt;ATOMIC_FETCH_AND&lt;/a&gt;, &lt;a href=&quot;iso_005ffortran_005fenv#ISO_005fFORTRAN_005fENV&quot;&gt;ISO_FORTRAN_ENV&lt;/a&gt;, &lt;a href=&quot;atomic_005fadd#ATOMIC_005fADD&quot;&gt;ATOMIC_ADD&lt;/a&gt;, &lt;a href=&quot;atomic_005for#ATOMIC_005fOR&quot;&gt;ATOMIC_OR&lt;/a&gt;, &lt;a href=&quot;atomic_005fxor#ATOMIC_005fXOR&quot;&gt;ATOMIC_XOR&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;atomic_005fdefine#ATOMIC_005fDEFINE&quot;&gt;ATOMIC_DEFINE&lt;/a&gt; , &lt;a href=&quot;atomic_005ffetch_005fand#ATOMIC_005fFETCH_005fAND&quot;&gt;ATOMIC_FETCH_AND&lt;/a&gt; , &lt;a href=&quot;iso_005ffortran_005fenv#ISO_005fFORTRAN_005fENV&quot;&gt;ISO_FORTRAN_ENV&lt;/a&gt; , &lt;a href=&quot;atomic_005fadd#ATOMIC_005fADD&quot;&gt;ATOMIC_ADD&lt;/a&gt; , &lt;a href=&quot;atomic_005for#ATOMIC_005fOR&quot;&gt;ATOMIC_OR&lt;/a&gt; , &lt;a href=&quot;atomic_005fxor#ATOMIC_005fXOR&quot;&gt;ATOMIC_XOR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="89f5045c2f0f25757bf4d2bab7e262d48bbee40d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;atomic_005fdefine#ATOMIC_005fDEFINE&quot;&gt;ATOMIC_DEFINE&lt;/a&gt;, &lt;a href=&quot;atomic_005ffetch_005for#ATOMIC_005fFETCH_005fOR&quot;&gt;ATOMIC_FETCH_OR&lt;/a&gt;, &lt;a href=&quot;iso_005ffortran_005fenv#ISO_005fFORTRAN_005fENV&quot;&gt;ISO_FORTRAN_ENV&lt;/a&gt;, &lt;a href=&quot;atomic_005fadd#ATOMIC_005fADD&quot;&gt;ATOMIC_ADD&lt;/a&gt;, &lt;a href=&quot;#ATOMIC_005fOR&quot;&gt;ATOMIC_OR&lt;/a&gt;, &lt;a href=&quot;atomic_005fxor#ATOMIC_005fXOR&quot;&gt;ATOMIC_XOR&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;atomic_005fdefine#ATOMIC_005fDEFINE&quot;&gt;ATOMIC_DEFINE&lt;/a&gt; , &lt;a href=&quot;atomic_005ffetch_005for#ATOMIC_005fFETCH_005fOR&quot;&gt;ATOMIC_FETCH_OR&lt;/a&gt; , &lt;a href=&quot;iso_005ffortran_005fenv#ISO_005fFORTRAN_005fENV&quot;&gt;ISO_FORTRAN_ENV&lt;/a&gt; , &lt;a href=&quot;atomic_005fadd#ATOMIC_005fADD&quot;&gt;ATOMIC_ADD&lt;/a&gt; , &lt;a href=&quot;#ATOMIC_005fOR&quot;&gt;ATOMIC_OR&lt;/a&gt; , &lt;a href=&quot;atomic_005fxor#ATOMIC_005fXOR&quot;&gt;ATOMIC_XOR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5cbfc65007204979a5d5af287fe6c5a20215dfa1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;atomic_005fdefine#ATOMIC_005fDEFINE&quot;&gt;ATOMIC_DEFINE&lt;/a&gt;, &lt;a href=&quot;atomic_005ffetch_005fxor#ATOMIC_005fFETCH_005fXOR&quot;&gt;ATOMIC_FETCH_XOR&lt;/a&gt;, &lt;a href=&quot;iso_005ffortran_005fenv#ISO_005fFORTRAN_005fENV&quot;&gt;ISO_FORTRAN_ENV&lt;/a&gt;, &lt;a href=&quot;atomic_005fadd#ATOMIC_005fADD&quot;&gt;ATOMIC_ADD&lt;/a&gt;, &lt;a href=&quot;atomic_005for#ATOMIC_005fOR&quot;&gt;ATOMIC_OR&lt;/a&gt;, &lt;a href=&quot;#ATOMIC_005fXOR&quot;&gt;ATOMIC_XOR&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;atomic_005fdefine#ATOMIC_005fDEFINE&quot;&gt;ATOMIC_DEFINE&lt;/a&gt; , &lt;a href=&quot;atomic_005ffetch_005fxor#ATOMIC_005fFETCH_005fXOR&quot;&gt;ATOMIC_FETCH_XOR&lt;/a&gt; , &lt;a href=&quot;iso_005ffortran_005fenv#ISO_005fFORTRAN_005fENV&quot;&gt;ISO_FORTRAN_ENV&lt;/a&gt; , &lt;a href=&quot;atomic_005fadd#ATOMIC_005fADD&quot;&gt;ATOMIC_ADD&lt;/a&gt; , &lt;a href=&quot;atomic_005for#ATOMIC_005fOR&quot;&gt;ATOMIC_OR&lt;/a&gt; , &lt;a href=&quot;#ATOMIC_005fXOR&quot;&gt;ATOMIC_XOR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="69ede20794d0e9d09bfb50d3d1371cdc4600b7b7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;atomic_005fdefine#ATOMIC_005fDEFINE&quot;&gt;ATOMIC_DEFINE&lt;/a&gt;, &lt;a href=&quot;atomic_005for#ATOMIC_005fOR&quot;&gt;ATOMIC_OR&lt;/a&gt;, &lt;a href=&quot;iso_005ffortran_005fenv#ISO_005fFORTRAN_005fENV&quot;&gt;ISO_FORTRAN_ENV&lt;/a&gt;, &lt;a href=&quot;atomic_005ffetch_005fadd#ATOMIC_005fFETCH_005fADD&quot;&gt;ATOMIC_FETCH_ADD&lt;/a&gt;, &lt;a href=&quot;atomic_005ffetch_005fand#ATOMIC_005fFETCH_005fAND&quot;&gt;ATOMIC_FETCH_AND&lt;/a&gt;, &lt;a href=&quot;atomic_005ffetch_005fxor#ATOMIC_005fFETCH_005fXOR&quot;&gt;ATOMIC_FETCH_XOR&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;atomic_005fdefine#ATOMIC_005fDEFINE&quot;&gt;ATOMIC_DEFINE&lt;/a&gt; , &lt;a href=&quot;atomic_005for#ATOMIC_005fOR&quot;&gt;ATOMIC_OR&lt;/a&gt; , &lt;a href=&quot;iso_005ffortran_005fenv#ISO_005fFORTRAN_005fENV&quot;&gt;ISO_FORTRAN_ENV&lt;/a&gt; , &lt;a href=&quot;atomic_005ffetch_005fadd#ATOMIC_005fFETCH_005fADD&quot;&gt;ATOMIC_FETCH_ADD&lt;/a&gt; , &lt;a href=&quot;atomic_005ffetch_005fand#ATOMIC_005fFETCH_005fAND&quot;&gt;ATOMIC_FETCH_AND&lt;/a&gt; , &lt;a href=&quot;atomic_005ffetch_005fxor#ATOMIC_005fFETCH_005fXOR&quot;&gt;ATOMIC_FETCH_XOR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dc8f14dfe8b1e1503664e2f3de611015ca8e9fb0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;atomic_005fdefine#ATOMIC_005fDEFINE&quot;&gt;ATOMIC_DEFINE&lt;/a&gt;, &lt;a href=&quot;atomic_005fref#ATOMIC_005fREF&quot;&gt;ATOMIC_REF&lt;/a&gt;, &lt;a href=&quot;iso_005ffortran_005fenv#ISO_005fFORTRAN_005fENV&quot;&gt;ISO_FORTRAN_ENV&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;atomic_005fdefine#ATOMIC_005fDEFINE&quot;&gt;ATOMIC_DEFINE&lt;/a&gt; , &lt;a href=&quot;atomic_005fref#ATOMIC_005fREF&quot;&gt;ATOMIC_REF&lt;/a&gt; , &lt;a href=&quot;iso_005ffortran_005fenv#ISO_005fFORTRAN_005fENV&quot;&gt;ISO_FORTRAN_ENV&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e1cee3720fd385e7a40a67217c409a392df6438e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;atomic_005fdefine#ATOMIC_005fDEFINE&quot;&gt;ATOMIC_DEFINE&lt;/a&gt;, &lt;a href=&quot;atomic_005fxor#ATOMIC_005fXOR&quot;&gt;ATOMIC_XOR&lt;/a&gt;, &lt;a href=&quot;iso_005ffortran_005fenv#ISO_005fFORTRAN_005fENV&quot;&gt;ISO_FORTRAN_ENV&lt;/a&gt;, &lt;a href=&quot;atomic_005ffetch_005fadd#ATOMIC_005fFETCH_005fADD&quot;&gt;ATOMIC_FETCH_ADD&lt;/a&gt;, &lt;a href=&quot;atomic_005ffetch_005fand#ATOMIC_005fFETCH_005fAND&quot;&gt;ATOMIC_FETCH_AND&lt;/a&gt;, &lt;a href=&quot;atomic_005ffetch_005for#ATOMIC_005fFETCH_005fOR&quot;&gt;ATOMIC_FETCH_OR&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;atomic_005fdefine#ATOMIC_005fDEFINE&quot;&gt;ATOMIC_DEFINE&lt;/a&gt; , &lt;a href=&quot;atomic_005fxor#ATOMIC_005fXOR&quot;&gt;ATOMIC_XOR&lt;/a&gt; , &lt;a href=&quot;iso_005ffortran_005fenv#ISO_005fFORTRAN_005fENV&quot;&gt;ISO_FORTRAN_ENV&lt;/a&gt; , &lt;a href=&quot;atomic_005ffetch_005fadd#ATOMIC_005fFETCH_005fADD&quot;&gt;ATOMIC_FETCH_ADD&lt;/a&gt; , &lt;a href=&quot;atomic_005ffetch_005fand#ATOMIC_005fFETCH_005fAND&quot;&gt;ATOMIC_FETCH_AND&lt;/a&gt; , &lt;a href=&quot;atomic_005ffetch_005for#ATOMIC_005fFETCH_005fOR&quot;&gt;ATOMIC_FETCH_OR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="57ea4f72a0be11882c29fa94a6b6d15c8c35bf4d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;atomic_005fref#ATOMIC_005fREF&quot;&gt;ATOMIC_REF&lt;/a&gt;, &lt;a href=&quot;atomic_005fcas#ATOMIC_005fCAS&quot;&gt;ATOMIC_CAS&lt;/a&gt;, &lt;a href=&quot;iso_005ffortran_005fenv#ISO_005fFORTRAN_005fENV&quot;&gt;ISO_FORTRAN_ENV&lt;/a&gt;, &lt;a href=&quot;atomic_005fadd#ATOMIC_005fADD&quot;&gt;ATOMIC_ADD&lt;/a&gt;, &lt;a href=&quot;atomic_005fand#ATOMIC_005fAND&quot;&gt;ATOMIC_AND&lt;/a&gt;, &lt;a href=&quot;atomic_005for#ATOMIC_005fOR&quot;&gt;ATOMIC_OR&lt;/a&gt;, &lt;a href=&quot;atomic_005fxor#ATOMIC_005fXOR&quot;&gt;ATOMIC_XOR&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;atomic_005fref#ATOMIC_005fREF&quot;&gt;ATOMIC_REF&lt;/a&gt; , &lt;a href=&quot;atomic_005fcas#ATOMIC_005fCAS&quot;&gt;ATOMIC_CAS&lt;/a&gt; , &lt;a href=&quot;iso_005ffortran_005fenv#ISO_005fFORTRAN_005fENV&quot;&gt;ISO_FORTRAN_ENV&lt;/a&gt; , &lt;a href=&quot;atomic_005fadd#ATOMIC_005fADD&quot;&gt;ATOMIC_ADD&lt;/a&gt; , &lt;a href=&quot;atomic_005fand#ATOMIC_005fAND&quot;&gt;ATOMIC_AND&lt;/a&gt; , &lt;a href=&quot;atomic_005for#ATOMIC_005fOR&quot;&gt;ATOMIC_OR&lt;/a&gt; , &lt;a href=&quot;atomic_005fxor#ATOMIC_005fXOR&quot;&gt;ATOMIC_XOR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a7a32b4c3d234583040884c92166edd0304cee35" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;bge#BGE&quot;&gt;BGE&lt;/a&gt;, &lt;a href=&quot;bgt#BGT&quot;&gt;BGT&lt;/a&gt;, &lt;a href=&quot;ble#BLE&quot;&gt;BLE&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;bge#BGE&quot;&gt;BGE&lt;/a&gt; , &lt;a href=&quot;bgt#BGT&quot;&gt;BGT&lt;/a&gt; , &lt;a href=&quot;ble#BLE&quot;&gt;BLE&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="62808544fd83637a6eb94c8391a568a27bbe8b33" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;bge#BGE&quot;&gt;BGE&lt;/a&gt;, &lt;a href=&quot;ble#BLE&quot;&gt;BLE&lt;/a&gt;, &lt;a href=&quot;blt#BLT&quot;&gt;BLT&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;bge#BGE&quot;&gt;BGE&lt;/a&gt; , &lt;a href=&quot;ble#BLE&quot;&gt;BLE&lt;/a&gt; , &lt;a href=&quot;blt#BLT&quot;&gt;BLT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cdf6da1d69475281643fffc0f28f1e8c19a3a53c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;bgt#BGT&quot;&gt;BGT&lt;/a&gt;, &lt;a href=&quot;bge#BGE&quot;&gt;BGE&lt;/a&gt;, &lt;a href=&quot;blt#BLT&quot;&gt;BLT&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;bgt#BGT&quot;&gt;BGT&lt;/a&gt; , &lt;a href=&quot;bge#BGE&quot;&gt;BGE&lt;/a&gt; , &lt;a href=&quot;blt#BLT&quot;&gt;BLT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8749dd78f2e55b584f87bce850bfa42a6c9300b4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;bgt#BGT&quot;&gt;BGT&lt;/a&gt;, &lt;a href=&quot;ble#BLE&quot;&gt;BLE&lt;/a&gt;, &lt;a href=&quot;blt#BLT&quot;&gt;BLT&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;bgt#BGT&quot;&gt;BGT&lt;/a&gt; , &lt;a href=&quot;ble#BLE&quot;&gt;BLE&lt;/a&gt; , &lt;a href=&quot;blt#BLT&quot;&gt;BLT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e6ee2e3b1e7ee1bd07ae76641f70bdd89d3c024" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;bit_005fsize#BIT_005fSIZE&quot;&gt;BIT_SIZE&lt;/a&gt;, &lt;a href=&quot;ibclr#IBCLR&quot;&gt;IBCLR&lt;/a&gt;, &lt;a href=&quot;ibset#IBSET&quot;&gt;IBSET&lt;/a&gt;, &lt;a href=&quot;iand#IAND&quot;&gt;IAND&lt;/a&gt;, &lt;a href=&quot;ior#IOR&quot;&gt;IOR&lt;/a&gt;, &lt;a href=&quot;ieor#IEOR&quot;&gt;IEOR&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;bit_005fsize#BIT_005fSIZE&quot;&gt;BIT_SIZE&lt;/a&gt; , &lt;a href=&quot;ibclr#IBCLR&quot;&gt;IBCLR&lt;/a&gt; , &lt;a href=&quot;ibset#IBSET&quot;&gt;IBSET&lt;/a&gt; , &lt;a href=&quot;iand#IAND&quot;&gt;IAND&lt;/a&gt; , &lt;a href=&quot;ior#IOR&quot;&gt;IOR&lt;/a&gt; , &lt;a href=&quot;ieor#IEOR&quot;&gt;IEOR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9da6fce59bb4839cb9ad4c522dad8604caa752d3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;bit_005fsize#BIT_005fSIZE&quot;&gt;BIT_SIZE&lt;/a&gt;, &lt;a href=&quot;leadz#LEADZ&quot;&gt;LEADZ&lt;/a&gt;, &lt;a href=&quot;poppar#POPPAR&quot;&gt;POPPAR&lt;/a&gt;, &lt;a href=&quot;popcnt#POPCNT&quot;&gt;POPCNT&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;bit_005fsize#BIT_005fSIZE&quot;&gt;BIT_SIZE&lt;/a&gt; , &lt;a href=&quot;leadz#LEADZ&quot;&gt;LEADZ&lt;/a&gt; , &lt;a href=&quot;poppar#POPPAR&quot;&gt;POPPAR&lt;/a&gt; , &lt;a href=&quot;popcnt#POPCNT&quot;&gt;POPCNT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b9081f9b9038e06195a86ffcbf10dfcc833c211b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;bit_005fsize#BIT_005fSIZE&quot;&gt;BIT_SIZE&lt;/a&gt;, &lt;a href=&quot;trailz#TRAILZ&quot;&gt;TRAILZ&lt;/a&gt;, &lt;a href=&quot;popcnt#POPCNT&quot;&gt;POPCNT&lt;/a&gt;, &lt;a href=&quot;poppar#POPPAR&quot;&gt;POPPAR&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;bit_005fsize#BIT_005fSIZE&quot;&gt;BIT_SIZE&lt;/a&gt; , &lt;a href=&quot;trailz#TRAILZ&quot;&gt;TRAILZ&lt;/a&gt; , &lt;a href=&quot;popcnt#POPCNT&quot;&gt;POPCNT&lt;/a&gt; , &lt;a href=&quot;poppar#POPPAR&quot;&gt;POPPAR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7228a162a0196ce9bbbd220e434a9c1e0655aa0e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c_005fassociated#C_005fASSOCIATED&quot;&gt;C_ASSOCIATED&lt;/a&gt;, &lt;a href=&quot;c_005ffunloc#C_005fFUNLOC&quot;&gt;C_FUNLOC&lt;/a&gt;, &lt;a href=&quot;c_005ff_005fpointer#C_005fF_005fPOINTER&quot;&gt;C_F_POINTER&lt;/a&gt;, &lt;a href=&quot;c_005ff_005fprocpointer#C_005fF_005fPROCPOINTER&quot;&gt;C_F_PROCPOINTER&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;c_005fassociated#C_005fASSOCIATED&quot;&gt;C_ASSOCIATED&lt;/a&gt; , &lt;a href=&quot;c_005ffunloc#C_005fFUNLOC&quot;&gt;C_FUNLOC&lt;/a&gt; , &lt;a href=&quot;c_005ff_005fpointer#C_005fF_005fPOINTER&quot;&gt;C_F_POINTER&lt;/a&gt; , &lt;a href=&quot;c_005ff_005fprocpointer#C_005fF_005fPROCPOINTER&quot;&gt;C_F_PROCPOINTER&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3fe10df6bc2de5104a1ff6e0a3d27dc868a8b8fd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c_005fassociated#C_005fASSOCIATED&quot;&gt;C_ASSOCIATED&lt;/a&gt;, &lt;a href=&quot;c_005floc#C_005fLOC&quot;&gt;C_LOC&lt;/a&gt;, &lt;a href=&quot;c_005ff_005fpointer#C_005fF_005fPOINTER&quot;&gt;C_F_POINTER&lt;/a&gt;, &lt;a href=&quot;c_005ff_005fprocpointer#C_005fF_005fPROCPOINTER&quot;&gt;C_F_PROCPOINTER&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;c_005fassociated#C_005fASSOCIATED&quot;&gt;C_ASSOCIATED&lt;/a&gt; , &lt;a href=&quot;c_005floc#C_005fLOC&quot;&gt;C_LOC&lt;/a&gt; , &lt;a href=&quot;c_005ff_005fpointer#C_005fF_005fPOINTER&quot;&gt;C_F_POINTER&lt;/a&gt; , &lt;a href=&quot;c_005ff_005fprocpointer#C_005fF_005fPROCPOINTER&quot;&gt;C_F_PROCPOINTER&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c227a5fcc12080fddb9841aaed05156fe9227a1f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c_005floc#C_005fLOC&quot;&gt;C_LOC&lt;/a&gt;, &lt;a href=&quot;c_005ff_005fpointer#C_005fF_005fPOINTER&quot;&gt;C_F_POINTER&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;c_005floc#C_005fLOC&quot;&gt;C_LOC&lt;/a&gt; , &lt;a href=&quot;c_005ff_005fpointer#C_005fF_005fPOINTER&quot;&gt;C_F_POINTER&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8ca6a8c0e7031812d68236e5f929cdf0a17b172d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c_005floc#C_005fLOC&quot;&gt;C_LOC&lt;/a&gt;, &lt;a href=&quot;c_005ff_005fprocpointer#C_005fF_005fPROCPOINTER&quot;&gt;C_F_PROCPOINTER&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;c_005floc#C_005fLOC&quot;&gt;C_LOC&lt;/a&gt; , &lt;a href=&quot;c_005ff_005fprocpointer#C_005fF_005fPROCPOINTER&quot;&gt;C_F_PROCPOINTER&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f4b3b558d6cbdafd13901ddab927d3ee2f93766a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c_005floc#C_005fLOC&quot;&gt;C_LOC&lt;/a&gt;, &lt;a href=&quot;c_005ffunloc#C_005fFUNLOC&quot;&gt;C_FUNLOC&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;c_005floc#C_005fLOC&quot;&gt;C_LOC&lt;/a&gt; , &lt;a href=&quot;c_005ffunloc#C_005fFUNLOC&quot;&gt;C_FUNLOC&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cb1b3ea478d3e342eb081656b7b3bdb372e44504" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c_005fsizeof#C_005fSIZEOF&quot;&gt;C_SIZEOF&lt;/a&gt;, &lt;a href=&quot;sizeof#SIZEOF&quot;&gt;SIZEOF&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;c_005fsizeof#C_005fSIZEOF&quot;&gt;C_SIZEOF&lt;/a&gt; , &lt;a href=&quot;sizeof#SIZEOF&quot;&gt;SIZEOF&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="83ea2da1c4759591d880594d8997a0d392b71661" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;c_005fsizeof#C_005fSIZEOF&quot;&gt;C_SIZEOF&lt;/a&gt;, &lt;a href=&quot;storage_005fsize#STORAGE_005fSIZE&quot;&gt;STORAGE_SIZE&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;c_005fsizeof#C_005fSIZEOF&quot;&gt;C_SIZEOF&lt;/a&gt; , &lt;a href=&quot;storage_005fsize#STORAGE_005fSIZE&quot;&gt;STORAGE_SIZE&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dd3fa58c4f4b4b3df9f0e4562ddc64fdb21c6c62" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;ceiling#CEILING&quot;&gt;CEILING&lt;/a&gt;, &lt;a href=&quot;floor#FLOOR&quot;&gt;FLOOR&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ceiling#CEILING&quot;&gt;천장&lt;/a&gt; , &lt;a href=&quot;floor#FLOOR&quot;&gt;바닥&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8ca3a9891a8eba7d46f8123717c525d6862e7df8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;ceiling#CEILING&quot;&gt;CEILING&lt;/a&gt;, &lt;a href=&quot;nint#NINT&quot;&gt;NINT&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ceiling#CEILING&quot;&gt;천장&lt;/a&gt; , &lt;a href=&quot;nint#NINT&quot;&gt;닌트&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="73d379f29a8523fdd5be52bd8c685cdbbfa03fcf" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;char#CHAR&quot;&gt;CHAR&lt;/a&gt;, &lt;a href=&quot;iachar#IACHAR&quot;&gt;IACHAR&lt;/a&gt;, &lt;a href=&quot;ichar#ICHAR&quot;&gt;ICHAR&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;char#CHAR&quot;&gt;CHAR&lt;/a&gt; , &lt;a href=&quot;iachar#IACHAR&quot;&gt;IACHAR&lt;/a&gt; , &lt;a href=&quot;ichar#ICHAR&quot;&gt;ICHAR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d885b6952199c0a9054beddcd4e44e621c740e0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;co_005fmax#CO_005fMAX&quot;&gt;CO_MAX&lt;/a&gt;, &lt;a href=&quot;co_005fmin#CO_005fMIN&quot;&gt;CO_MIN&lt;/a&gt;, &lt;a href=&quot;co_005freduce#CO_005fREDUCE&quot;&gt;CO_REDUCE&lt;/a&gt;, &lt;a href=&quot;co_005fbroadcast#CO_005fBROADCAST&quot;&gt;CO_BROADCAST&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;co_005fmax#CO_005fMAX&quot;&gt;CO_MAX&lt;/a&gt; , &lt;a href=&quot;co_005fmin#CO_005fMIN&quot;&gt;CO_MIN&lt;/a&gt; , &lt;a href=&quot;co_005freduce#CO_005fREDUCE&quot;&gt;CO_REDUCE&lt;/a&gt; , &lt;a href=&quot;co_005fbroadcast#CO_005fBROADCAST&quot;&gt;CO_BROADCAST&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ff9840ab819e772c57f4952f9b26d59950cf8584" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;co_005fmax#CO_005fMAX&quot;&gt;CO_MAX&lt;/a&gt;, &lt;a href=&quot;co_005fmin#CO_005fMIN&quot;&gt;CO_MIN&lt;/a&gt;, &lt;a href=&quot;co_005fsum#CO_005fSUM&quot;&gt;CO_SUM&lt;/a&gt;, &lt;a href=&quot;co_005freduce#CO_005fREDUCE&quot;&gt;CO_REDUCE&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;co_005fmax#CO_005fMAX&quot;&gt;CO_MAX&lt;/a&gt; , &lt;a href=&quot;co_005fmin#CO_005fMIN&quot;&gt;CO_MIN&lt;/a&gt; , &lt;a href=&quot;co_005fsum#CO_005fSUM&quot;&gt;CO_SUM&lt;/a&gt; , &lt;a href=&quot;co_005freduce#CO_005fREDUCE&quot;&gt;CO_REDUCE&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="91efd3d975fcffba060250e3ae6b6c69ade8463d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;co_005fmax#CO_005fMAX&quot;&gt;CO_MAX&lt;/a&gt;, &lt;a href=&quot;co_005fsum#CO_005fSUM&quot;&gt;CO_SUM&lt;/a&gt;, &lt;a href=&quot;co_005freduce#CO_005fREDUCE&quot;&gt;CO_REDUCE&lt;/a&gt;, &lt;a href=&quot;co_005fbroadcast#CO_005fBROADCAST&quot;&gt;CO_BROADCAST&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;co_005fmax#CO_005fMAX&quot;&gt;CO_MAX&lt;/a&gt; , &lt;a href=&quot;co_005fsum#CO_005fSUM&quot;&gt;CO_SUM&lt;/a&gt; , &lt;a href=&quot;co_005freduce#CO_005fREDUCE&quot;&gt;CO_REDUCE&lt;/a&gt; , &lt;a href=&quot;co_005fbroadcast#CO_005fBROADCAST&quot;&gt;CO_BROADCAST&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a44ed95d7ce6b4235958294c0287c6989405bd40" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;co_005fmin#CO_005fMIN&quot;&gt;CO_MIN&lt;/a&gt;, &lt;a href=&quot;co_005fmax#CO_005fMAX&quot;&gt;CO_MAX&lt;/a&gt;, &lt;a href=&quot;co_005fsum#CO_005fSUM&quot;&gt;CO_SUM&lt;/a&gt;, &lt;a href=&quot;co_005fbroadcast#CO_005fBROADCAST&quot;&gt;CO_BROADCAST&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;co_005fmin#CO_005fMIN&quot;&gt;CO_MIN&lt;/a&gt; , &lt;a href=&quot;co_005fmax#CO_005fMAX&quot;&gt;CO_MAX&lt;/a&gt; , &lt;a href=&quot;co_005fsum#CO_005fSUM&quot;&gt;CO_SUM&lt;/a&gt; , &lt;a href=&quot;co_005fbroadcast#CO_005fBROADCAST&quot;&gt;CO_BROADCAST&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b3f710f8aa2b5b54829eb715bb7443b977c83651" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;co_005fmin#CO_005fMIN&quot;&gt;CO_MIN&lt;/a&gt;, &lt;a href=&quot;co_005fsum#CO_005fSUM&quot;&gt;CO_SUM&lt;/a&gt;, &lt;a href=&quot;co_005freduce#CO_005fREDUCE&quot;&gt;CO_REDUCE&lt;/a&gt;, &lt;a href=&quot;co_005fbroadcast#CO_005fBROADCAST&quot;&gt;CO_BROADCAST&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;co_005fmin#CO_005fMIN&quot;&gt;CO_MIN&lt;/a&gt; , &lt;a href=&quot;co_005fsum#CO_005fSUM&quot;&gt;CO_SUM&lt;/a&gt; , &lt;a href=&quot;co_005freduce#CO_005fREDUCE&quot;&gt;CO_REDUCE&lt;/a&gt; , &lt;a href=&quot;co_005fbroadcast#CO_005fBROADCAST&quot;&gt;CO_BROADCAST&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0cc8c0dc466fbf69c028e51abba35a4b42c54a85" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;compiler_005foptions#COMPILER_005fOPTIONS&quot;&gt;COMPILER_OPTIONS&lt;/a&gt;, &lt;a href=&quot;iso_005ffortran_005fenv#ISO_005fFORTRAN_005fENV&quot;&gt;ISO_FORTRAN_ENV&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;compiler_005foptions#COMPILER_005fOPTIONS&quot;&gt;COMPILER_OPTIONS&lt;/a&gt; , &lt;a href=&quot;iso_005ffortran_005fenv#ISO_005fFORTRAN_005fENV&quot;&gt;ISO_FORTRAN_ENV&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9cf2a7ba5a8ed52cf5d4d725a8b05686e22c2c3c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;compiler_005fversion#COMPILER_005fVERSION&quot;&gt;COMPILER_VERSION&lt;/a&gt;, &lt;a href=&quot;iso_005ffortran_005fenv#ISO_005fFORTRAN_005fENV&quot;&gt;ISO_FORTRAN_ENV&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;compiler_005fversion#COMPILER_005fVERSION&quot;&gt;COMPILER_VERSION&lt;/a&gt; , &lt;a href=&quot;iso_005ffortran_005fenv#ISO_005fFORTRAN_005fENV&quot;&gt;ISO_FORTRAN_ENV&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="70c346e0b646336f1105b728433c422e425966fa" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;cpu_005ftime#CPU_005fTIME&quot;&gt;CPU_TIME&lt;/a&gt;, &lt;a href=&quot;system_005fclock#SYSTEM_005fCLOCK&quot;&gt;SYSTEM_CLOCK&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;cpu_005ftime#CPU_005fTIME&quot;&gt;CPU_TIME&lt;/a&gt; , &lt;a href=&quot;system_005fclock#SYSTEM_005fCLOCK&quot;&gt;SYSTEM_CLOCK&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f4e67dd17fbb833da6139e8ce9e38f4b47f84f0b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;ctime#CTIME&quot;&gt;CTIME&lt;/a&gt;, &lt;a href=&quot;gmtime#GMTIME&quot;&gt;GMTIME&lt;/a&gt;, &lt;a href=&quot;ltime#LTIME&quot;&gt;LTIME&lt;/a&gt;, &lt;a href=&quot;#MCLOCK&quot;&gt;MCLOCK&lt;/a&gt;, &lt;a href=&quot;time#TIME&quot;&gt;TIME&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ctime#CTIME&quot;&gt;CTIME&lt;/a&gt; , &lt;a href=&quot;gmtime#GMTIME&quot;&gt;GMTIME&lt;/a&gt; , &lt;a href=&quot;ltime#LTIME&quot;&gt;LTIME&lt;/a&gt; , &lt;a href=&quot;#MCLOCK&quot;&gt;MCLOCK&lt;/a&gt; , &lt;a href=&quot;time#TIME&quot;&gt;TIME&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4a59760819ab6767161f9e615a62821fb7808b9b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;ctime#CTIME&quot;&gt;CTIME&lt;/a&gt;, &lt;a href=&quot;gmtime#GMTIME&quot;&gt;GMTIME&lt;/a&gt;, &lt;a href=&quot;ltime#LTIME&quot;&gt;LTIME&lt;/a&gt;, &lt;a href=&quot;mclock#MCLOCK&quot;&gt;MCLOCK&lt;/a&gt;, &lt;a href=&quot;time8#TIME8&quot;&gt;TIME8&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ctime#CTIME&quot;&gt;CTIME&lt;/a&gt; , &lt;a href=&quot;gmtime#GMTIME&quot;&gt;GMTIME&lt;/a&gt; , &lt;a href=&quot;ltime#LTIME&quot;&gt;LTIME&lt;/a&gt; , &lt;a href=&quot;mclock#MCLOCK&quot;&gt;MCLOCK&lt;/a&gt; , &lt;a href=&quot;time8#TIME8&quot;&gt;TIME8&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="263fd304f31507d306578d2754b0bed39f7a7c2a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;date_005fand_005ftime#DATE_005fAND_005fTIME&quot;&gt;DATE_AND_TIME&lt;/a&gt;, &lt;a href=&quot;cpu_005ftime#CPU_005fTIME&quot;&gt;CPU_TIME&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;date_005fand_005ftime#DATE_005fAND_005fTIME&quot;&gt;DATE_AND_TIME&lt;/a&gt; , &lt;a href=&quot;cpu_005ftime#CPU_005fTIME&quot;&gt;CPU_TIME&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ba6ac47db5037ec917b31d8436e2e632da763db0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;date_005fand_005ftime#DATE_005fAND_005fTIME&quot;&gt;DATE_AND_TIME&lt;/a&gt;, &lt;a href=&quot;ctime#CTIME&quot;&gt;CTIME&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;date_005fand_005ftime#DATE_005fAND_005fTIME&quot;&gt;DATE_AND_TIME&lt;/a&gt; , &lt;a href=&quot;ctime#CTIME&quot;&gt;CTIME&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9574df458de5197224c61e9fb600df9eeae5603a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;date_005fand_005ftime#DATE_005fAND_005fTIME&quot;&gt;DATE_AND_TIME&lt;/a&gt;, &lt;a href=&quot;ctime#CTIME&quot;&gt;CTIME&lt;/a&gt;, &lt;a href=&quot;gmtime#GMTIME&quot;&gt;GMTIME&lt;/a&gt;, &lt;a href=&quot;ltime#LTIME&quot;&gt;LTIME&lt;/a&gt;, &lt;a href=&quot;mclock#MCLOCK&quot;&gt;MCLOCK&lt;/a&gt;, &lt;a href=&quot;time8#TIME8&quot;&gt;TIME8&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;date_005fand_005ftime#DATE_005fAND_005fTIME&quot;&gt;DATE_AND_TIME&lt;/a&gt; , &lt;a href=&quot;ctime#CTIME&quot;&gt;CTIME&lt;/a&gt; , &lt;a href=&quot;gmtime#GMTIME&quot;&gt;GMTIME&lt;/a&gt; , &lt;a href=&quot;ltime#LTIME&quot;&gt;LTIME&lt;/a&gt; , &lt;a href=&quot;mclock#MCLOCK&quot;&gt;MCLOCK&lt;/a&gt; , &lt;a href=&quot;time8#TIME8&quot;&gt;TIME8&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed5bbb869cc25bb7594acb58897a2eb60fcb9d74" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;date_005fand_005ftime#DATE_005fAND_005fTIME&quot;&gt;DATE_AND_TIME&lt;/a&gt;, &lt;a href=&quot;ctime#CTIME&quot;&gt;CTIME&lt;/a&gt;, &lt;a href=&quot;gmtime#GMTIME&quot;&gt;GMTIME&lt;/a&gt;, &lt;a href=&quot;ltime#LTIME&quot;&gt;LTIME&lt;/a&gt;, &lt;a href=&quot;mclock8#MCLOCK8&quot;&gt;MCLOCK8&lt;/a&gt;, &lt;a href=&quot;time#TIME&quot;&gt;TIME&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;date_005fand_005ftime#DATE_005fAND_005fTIME&quot;&gt;DATE_AND_TIME&lt;/a&gt; , &lt;a href=&quot;ctime#CTIME&quot;&gt;CTIME&lt;/a&gt; , &lt;a href=&quot;gmtime#GMTIME&quot;&gt;GMTIME&lt;/a&gt; , &lt;a href=&quot;ltime#LTIME&quot;&gt;LTIME&lt;/a&gt; , &lt;a href=&quot;mclock8#MCLOCK8&quot;&gt;MCLOCK8&lt;/a&gt; , &lt;a href=&quot;time#TIME&quot;&gt;TIME&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bcb87565b4ba4a97ddc6941158d7126991aa4734" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;date_005fand_005ftime#DATE_005fAND_005fTIME&quot;&gt;DATE_AND_TIME&lt;/a&gt;, &lt;a href=&quot;ctime#CTIME&quot;&gt;CTIME&lt;/a&gt;, &lt;a href=&quot;gmtime#GMTIME&quot;&gt;GMTIME&lt;/a&gt;, &lt;a href=&quot;time#TIME&quot;&gt;TIME&lt;/a&gt;, &lt;a href=&quot;time8#TIME8&quot;&gt;TIME8&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;date_005fand_005ftime#DATE_005fAND_005fTIME&quot;&gt;DATE_AND_TIME&lt;/a&gt; , &lt;a href=&quot;ctime#CTIME&quot;&gt;CTIME&lt;/a&gt; , &lt;a href=&quot;gmtime#GMTIME&quot;&gt;GMTIME&lt;/a&gt; , &lt;a href=&quot;time#TIME&quot;&gt;TIME&lt;/a&gt; , &lt;a href=&quot;time8#TIME8&quot;&gt;TIME8&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="afb3516201eb2d2dfbccec5b135695f8bda27c3c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;date_005fand_005ftime#DATE_005fAND_005fTIME&quot;&gt;DATE_AND_TIME&lt;/a&gt;, &lt;a href=&quot;ctime#CTIME&quot;&gt;CTIME&lt;/a&gt;, &lt;a href=&quot;ltime#LTIME&quot;&gt;LTIME&lt;/a&gt;, &lt;a href=&quot;time#TIME&quot;&gt;TIME&lt;/a&gt;, &lt;a href=&quot;time8#TIME8&quot;&gt;TIME8&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;date_005fand_005ftime#DATE_005fAND_005fTIME&quot;&gt;DATE_AND_TIME&lt;/a&gt; , &lt;a href=&quot;ctime#CTIME&quot;&gt;CTIME&lt;/a&gt; , &lt;a href=&quot;ltime#LTIME&quot;&gt;LTIME&lt;/a&gt; , &lt;a href=&quot;time#TIME&quot;&gt;TIME&lt;/a&gt; , &lt;a href=&quot;time8#TIME8&quot;&gt;TIME8&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0c64a9b72261151a363fa3435bd72f9153aae87e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;date_005fand_005ftime#DATE_005fAND_005fTIME&quot;&gt;DATE_AND_TIME&lt;/a&gt;, &lt;a href=&quot;gmtime#GMTIME&quot;&gt;GMTIME&lt;/a&gt;, &lt;a href=&quot;ltime#LTIME&quot;&gt;LTIME&lt;/a&gt;, &lt;a href=&quot;time#TIME&quot;&gt;TIME&lt;/a&gt;, &lt;a href=&quot;time8#TIME8&quot;&gt;TIME8&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;date_005fand_005ftime#DATE_005fAND_005fTIME&quot;&gt;DATE_AND_TIME&lt;/a&gt; , &lt;a href=&quot;gmtime#GMTIME&quot;&gt;GMTIME&lt;/a&gt; , &lt;a href=&quot;ltime#LTIME&quot;&gt;LTIME&lt;/a&gt; , &lt;a href=&quot;time#TIME&quot;&gt;TIME&lt;/a&gt; , &lt;a href=&quot;time8#TIME8&quot;&gt;TIME8&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b184347d55e7236c78e23c38df711ac8239a9953" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;execute_005fcommand_005fline#EXECUTE_005fCOMMAND_005fLINE&quot;&gt;EXECUTE_COMMAND_LINE&lt;/a&gt;, which is part of the Fortran 2008 standard and should considered in new code for future portability.</source>
          <target state="translated">&lt;a href=&quot;execute_005fcommand_005fline#EXECUTE_005fCOMMAND_005fLINE&quot;&gt;EXECUTE_COMMAND_LINE&lt;/a&gt; . Fortran 2008 표준의 일부이며 향후 이식성을 위해 새 코드에서 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="47df2f41a48ec91366898dc90ac25bec240f6087" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;exit#EXIT&quot;&gt;EXIT&lt;/a&gt;, &lt;a href=&quot;kill#KILL&quot;&gt;KILL&lt;/a&gt;, &lt;a href=&quot;backtrace#BACKTRACE&quot;&gt;BACKTRACE&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;exit#EXIT&quot;&gt;출구&lt;/a&gt; , &lt;a href=&quot;kill#KILL&quot;&gt;킬&lt;/a&gt; , &lt;a href=&quot;backtrace#BACKTRACE&quot;&gt;등받이&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cd5e6e6e90b682d66a41168dc1502b419fb97348" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;fget#FGET&quot;&gt;FGET&lt;/a&gt;, &lt;a href=&quot;fput#FPUT&quot;&gt;FPUT&lt;/a&gt;, &lt;a href=&quot;fputc#FPUTC&quot;&gt;FPUTC&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;fget#FGET&quot;&gt;FGET&lt;/a&gt; , &lt;a href=&quot;fput#FPUT&quot;&gt;FPUT&lt;/a&gt; , &lt;a href=&quot;fputc#FPUTC&quot;&gt;FPUTC&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dd8054436c25450ff52c089475bea5200a046e14" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;fgetc#FGETC&quot;&gt;FGETC&lt;/a&gt;, &lt;a href=&quot;fput#FPUT&quot;&gt;FPUT&lt;/a&gt;, &lt;a href=&quot;fputc#FPUTC&quot;&gt;FPUTC&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;fgetc#FGETC&quot;&gt;FGETC&lt;/a&gt; , &lt;a href=&quot;fput#FPUT&quot;&gt;FPUT&lt;/a&gt; , &lt;a href=&quot;fputc#FPUTC&quot;&gt;FPUTC&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="11bd9c34d1363a3d05aaa31395369451c8d078ec" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;floor#FLOOR&quot;&gt;FLOOR&lt;/a&gt;, &lt;a href=&quot;nint#NINT&quot;&gt;NINT&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;floor#FLOOR&quot;&gt;바닥&lt;/a&gt; , &lt;a href=&quot;nint#NINT&quot;&gt;닌트&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="017846bbfaa37eaa62ff725c21bbad19002e26d9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;fput#FPUT&quot;&gt;FPUT&lt;/a&gt;, &lt;a href=&quot;fget#FGET&quot;&gt;FGET&lt;/a&gt;, &lt;a href=&quot;fgetc#FGETC&quot;&gt;FGETC&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;fput#FPUT&quot;&gt;FPUT&lt;/a&gt; , &lt;a href=&quot;fget#FGET&quot;&gt;FGET&lt;/a&gt; , &lt;a href=&quot;fgetc#FGETC&quot;&gt;FGETC&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a08c1785de756d65a7b7616ad9a20dcf34aa09df" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;fputc#FPUTC&quot;&gt;FPUTC&lt;/a&gt;, &lt;a href=&quot;fget#FGET&quot;&gt;FGET&lt;/a&gt;, &lt;a href=&quot;fgetc#FGETC&quot;&gt;FGETC&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;fputc#FPUTC&quot;&gt;FPUTC&lt;/a&gt; , &lt;a href=&quot;fget#FGET&quot;&gt;FGET&lt;/a&gt; , &lt;a href=&quot;fgetc#FGETC&quot;&gt;FGETC&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6f3433a0e1a55d9c769ef588c49ab6e748cd6d9b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;get_005fcommand#GET_005fCOMMAND&quot;&gt;GET_COMMAND&lt;/a&gt;, &lt;a href=&quot;command_005fargument_005fcount#COMMAND_005fARGUMENT_005fCOUNT&quot;&gt;COMMAND_ARGUMENT_COUNT&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;get_005fcommand#GET_005fCOMMAND&quot;&gt;GET_COMMAND&lt;/a&gt; , &lt;a href=&quot;command_005fargument_005fcount#COMMAND_005fARGUMENT_005fCOUNT&quot;&gt;COMMAND_ARGUMENT_COUNT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e35f60cdfe5d53fb030f0170bc0f639de7484e80" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;get_005fcommand#GET_005fCOMMAND&quot;&gt;GET_COMMAND&lt;/a&gt;, &lt;a href=&quot;get_005fcommand_005fargument#GET_005fCOMMAND_005fARGUMENT&quot;&gt;GET_COMMAND_ARGUMENT&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;get_005fcommand#GET_005fCOMMAND&quot;&gt;GET_COMMAND&lt;/a&gt; , &lt;a href=&quot;get_005fcommand_005fargument#GET_005fCOMMAND_005fARGUMENT&quot;&gt;GET_COMMAND_ARGUMENT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e11dbcb79ce53dfb986b80c0a08ed9a03207c1ff" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;get_005fcommand_005fargument#GET_005fCOMMAND_005fARGUMENT&quot;&gt;GET_COMMAND_ARGUMENT&lt;/a&gt;, &lt;a href=&quot;command_005fargument_005fcount#COMMAND_005fARGUMENT_005fCOUNT&quot;&gt;COMMAND_ARGUMENT_COUNT&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;get_005fcommand_005fargument#GET_005fCOMMAND_005fARGUMENT&quot;&gt;GET_COMMAND_ARGUMENT&lt;/a&gt; , &lt;a href=&quot;command_005fargument_005fcount#COMMAND_005fARGUMENT_005fCOUNT&quot;&gt;COMMAND_ARGUMENT_COUNT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="658e625380b70ddbbe7b62e5f3fe6e61627ed2fd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;getgid#GETGID&quot;&gt;GETGID&lt;/a&gt;, &lt;a href=&quot;getuid#GETUID&quot;&gt;GETUID&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;getgid#GETGID&quot;&gt;GETGID&lt;/a&gt; , &lt;a href=&quot;getuid#GETUID&quot;&gt;GETUID&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cc7faf06df3becfbaeefe1430546361f7557d592" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;getpid#GETPID&quot;&gt;GETPID&lt;/a&gt;, &lt;a href=&quot;getlog#GETLOG&quot;&gt;GETLOG&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;getpid#GETPID&quot;&gt;GETPID&lt;/a&gt; , &lt;a href=&quot;getlog#GETLOG&quot;&gt;GETLOG&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3c9d6911154773d4163d7c1271ff2a2ecec011f6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;getpid#GETPID&quot;&gt;GETPID&lt;/a&gt;, &lt;a href=&quot;getuid#GETUID&quot;&gt;GETUID&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;getpid#GETPID&quot;&gt;GETPID&lt;/a&gt; , &lt;a href=&quot;getuid#GETUID&quot;&gt;GETUID&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d5310f89357e3bebc0f0d6feb5bfc40946e6acb2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;iand#IAND&quot;&gt;IAND&lt;/a&gt;, &lt;a href=&quot;ieor#IEOR&quot;&gt;IEOR&lt;/a&gt;, &lt;a href=&quot;ior#IOR&quot;&gt;IOR&lt;/a&gt;, &lt;a href=&quot;ibits#IBITS&quot;&gt;IBITS&lt;/a&gt;, &lt;a href=&quot;ibset#IBSET&quot;&gt;IBSET&lt;/a&gt;, &lt;a href=&quot;ibclr#IBCLR&quot;&gt;IBCLR&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;iand#IAND&quot;&gt;IAND&lt;/a&gt; , &lt;a href=&quot;ieor#IEOR&quot;&gt;IEOR&lt;/a&gt; , &lt;a href=&quot;ior#IOR&quot;&gt;IOR&lt;/a&gt; , &lt;a href=&quot;ibits#IBITS&quot;&gt;IBITS&lt;/a&gt; , &lt;a href=&quot;ibset#IBSET&quot;&gt;IBSET&lt;/a&gt; , &lt;a href=&quot;ibclr#IBCLR&quot;&gt;IBCLR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="de812457391468ec86fd39e353b9bed3eaca48c3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;iany#IANY&quot;&gt;IANY&lt;/a&gt;, &lt;a href=&quot;iall#IALL&quot;&gt;IALL&lt;/a&gt;, &lt;a href=&quot;ieor#IEOR&quot;&gt;IEOR&lt;/a&gt;, &lt;a href=&quot;parity#PARITY&quot;&gt;PARITY&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;iany#IANY&quot;&gt;IANY&lt;/a&gt; , &lt;a href=&quot;iall#IALL&quot;&gt;IALL&lt;/a&gt; , &lt;a href=&quot;ieor#IEOR&quot;&gt;IEOR&lt;/a&gt; , &lt;a href=&quot;parity#PARITY&quot;&gt;패리티&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="00480143e5dbd7b8e77dc1940e713390a6dbfd40" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;iany#IANY&quot;&gt;IANY&lt;/a&gt;, &lt;a href=&quot;iparity#IPARITY&quot;&gt;IPARITY&lt;/a&gt;, &lt;a href=&quot;iand#IAND&quot;&gt;IAND&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;iany#IANY&quot;&gt;IANY&lt;/a&gt; , &lt;a href=&quot;iparity#IPARITY&quot;&gt;IPARITY&lt;/a&gt; , &lt;a href=&quot;iand#IAND&quot;&gt;IAND&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="17827c32c924369fb2d1d73898356f4dc9b1ce23" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;ibclr#IBCLR&quot;&gt;IBCLR&lt;/a&gt;, &lt;a href=&quot;ibits#IBITS&quot;&gt;IBITS&lt;/a&gt;, &lt;a href=&quot;iand#IAND&quot;&gt;IAND&lt;/a&gt;, &lt;a href=&quot;ior#IOR&quot;&gt;IOR&lt;/a&gt;, &lt;a href=&quot;ieor#IEOR&quot;&gt;IEOR&lt;/a&gt;, &lt;a href=&quot;mvbits#MVBITS&quot;&gt;MVBITS&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ibclr#IBCLR&quot;&gt;IBCLR&lt;/a&gt; , &lt;a href=&quot;ibits#IBITS&quot;&gt;IBITS&lt;/a&gt; , &lt;a href=&quot;iand#IAND&quot;&gt;IAND&lt;/a&gt; , &lt;a href=&quot;ior#IOR&quot;&gt;IOR&lt;/a&gt; , &lt;a href=&quot;ieor#IEOR&quot;&gt;IEOR&lt;/a&gt; , &lt;a href=&quot;mvbits#MVBITS&quot;&gt;MVBITS&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a394d58e8ed6d0532ff735961463687427eaa099" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;ibclr#IBCLR&quot;&gt;IBCLR&lt;/a&gt;, &lt;a href=&quot;ibset#IBSET&quot;&gt;IBSET&lt;/a&gt;, &lt;a href=&quot;ibits#IBITS&quot;&gt;IBITS&lt;/a&gt;, &lt;a href=&quot;iand#IAND&quot;&gt;IAND&lt;/a&gt;, &lt;a href=&quot;ior#IOR&quot;&gt;IOR&lt;/a&gt;, &lt;a href=&quot;ieor#IEOR&quot;&gt;IEOR&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ibclr#IBCLR&quot;&gt;IBCLR&lt;/a&gt; , &lt;a href=&quot;ibset#IBSET&quot;&gt;IBSET&lt;/a&gt; , &lt;a href=&quot;ibits#IBITS&quot;&gt;IBITS&lt;/a&gt; , &lt;a href=&quot;iand#IAND&quot;&gt;IAND&lt;/a&gt; , &lt;a href=&quot;ior#IOR&quot;&gt;IOR&lt;/a&gt; , &lt;a href=&quot;ieor#IEOR&quot;&gt;IEOR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2de3856df0fe04a5a53d205aab92a508debcd61d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;ibits#IBITS&quot;&gt;IBITS&lt;/a&gt;, &lt;a href=&quot;ibset#IBSET&quot;&gt;IBSET&lt;/a&gt;, &lt;a href=&quot;iand#IAND&quot;&gt;IAND&lt;/a&gt;, &lt;a href=&quot;ior#IOR&quot;&gt;IOR&lt;/a&gt;, &lt;a href=&quot;ieor#IEOR&quot;&gt;IEOR&lt;/a&gt;, &lt;a href=&quot;mvbits#MVBITS&quot;&gt;MVBITS&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ibits#IBITS&quot;&gt;IBITS&lt;/a&gt; , &lt;a href=&quot;ibset#IBSET&quot;&gt;IBSET&lt;/a&gt; , &lt;a href=&quot;iand#IAND&quot;&gt;IAND&lt;/a&gt; , &lt;a href=&quot;ior#IOR&quot;&gt;IOR&lt;/a&gt; , &lt;a href=&quot;ieor#IEOR&quot;&gt;IEOR&lt;/a&gt; , &lt;a href=&quot;mvbits#MVBITS&quot;&gt;MVBITS&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6cb311a1b6e4ea3a2a00d9e91940c577a2f9a781" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;ieor#IEOR&quot;&gt;IEOR&lt;/a&gt;, &lt;a href=&quot;iand#IAND&quot;&gt;IAND&lt;/a&gt;, &lt;a href=&quot;ibits#IBITS&quot;&gt;IBITS&lt;/a&gt;, &lt;a href=&quot;ibset#IBSET&quot;&gt;IBSET&lt;/a&gt;, &lt;a href=&quot;ibclr#IBCLR&quot;&gt;IBCLR&lt;/a&gt;, &lt;a href=&quot;not#NOT&quot;&gt;NOT&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ieor#IEOR&quot;&gt;IEOR&lt;/a&gt; , &lt;a href=&quot;iand#IAND&quot;&gt;IAND&lt;/a&gt; , &lt;a href=&quot;ibits#IBITS&quot;&gt;IBITS&lt;/a&gt; , &lt;a href=&quot;ibset#IBSET&quot;&gt;IBSET&lt;/a&gt; , &lt;a href=&quot;ibclr#IBCLR&quot;&gt;IBCLR&lt;/a&gt; , &lt;a href=&quot;not#NOT&quot;&gt;NOT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b78bced9706386fd2120f370dbc08ea3d8b487a7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;ierrno#IERRNO&quot;&gt;IERRNO&lt;/a&gt;, &lt;a href=&quot;perror#PERROR&quot;&gt;PERROR&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ierrno#IERRNO&quot;&gt;오류&lt;/a&gt; , &lt;a href=&quot;perror#PERROR&quot;&gt;오류&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bcdab080591a5f1905fa7ed5da3b3fbe67447b18" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;index-intrinsic#INDEX-intrinsic&quot;&gt;INDEX intrinsic&lt;/a&gt;, &lt;a href=&quot;len_005ftrim#LEN_005fTRIM&quot;&gt;LEN_TRIM&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;index-intrinsic#INDEX-intrinsic&quot;&gt;INDEX 내장&lt;/a&gt; , &lt;a href=&quot;len_005ftrim#LEN_005fTRIM&quot;&gt;LEN_TRIM&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2bcccb25db5a052607cf5d04f0e83e7355b648c6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;index-intrinsic#INDEX-intrinsic&quot;&gt;INDEX intrinsic&lt;/a&gt;, &lt;a href=&quot;verify#VERIFY&quot;&gt;VERIFY&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;index-intrinsic#INDEX-intrinsic&quot;&gt;INDEX 본질&lt;/a&gt; , &lt;a href=&quot;verify#VERIFY&quot;&gt;VERIFY&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="19b7c63a7127907f41bc2edf422c39fd1a062cc5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;int#INT&quot;&gt;INT&lt;/a&gt;, &lt;a href=&quot;int2#INT2&quot;&gt;INT2&lt;/a&gt;, &lt;a href=&quot;int8#INT8&quot;&gt;INT8&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;int#INT&quot;&gt;INT&lt;/a&gt; , &lt;a href=&quot;int2#INT2&quot;&gt;INT2&lt;/a&gt; , &lt;a href=&quot;int8#INT8&quot;&gt;INT8&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7a36206d1e28f39dfba3352c0829e97a6fa2a5a5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;int#INT&quot;&gt;INT&lt;/a&gt;, &lt;a href=&quot;int2#INT2&quot;&gt;INT2&lt;/a&gt;, &lt;a href=&quot;long#LONG&quot;&gt;LONG&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;int#INT&quot;&gt;INT&lt;/a&gt; , &lt;a href=&quot;int2#INT2&quot;&gt;INT2&lt;/a&gt; , &lt;a href=&quot;long#LONG&quot;&gt;긴&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c52d15e712a3b00897d3f030a13ddac28a24cac4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;int#INT&quot;&gt;INT&lt;/a&gt;, &lt;a href=&quot;int8#INT8&quot;&gt;INT8&lt;/a&gt;, &lt;a href=&quot;long#LONG&quot;&gt;LONG&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;int#INT&quot;&gt;INT&lt;/a&gt; , &lt;a href=&quot;int8#INT8&quot;&gt;INT8&lt;/a&gt; , &lt;a href=&quot;long#LONG&quot;&gt;긴&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4941b2aac52c33c34f7d0813155cfa82cd24fee4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;int#INT&quot;&gt;INT&lt;/a&gt;, &lt;a href=&quot;real#REAL&quot;&gt;REAL&lt;/a&gt;, &lt;a href=&quot;cmplx#CMPLX&quot;&gt;CMPLX&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;int#INT&quot;&gt;INT&lt;/a&gt; , &lt;a href=&quot;real#REAL&quot;&gt;REAL&lt;/a&gt; , &lt;a href=&quot;cmplx#CMPLX&quot;&gt;CMPLX&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7e6dd905772934afd5be67d8e3cf8c855a5c0813" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;ior#IOR&quot;&gt;IOR&lt;/a&gt;, &lt;a href=&quot;iand#IAND&quot;&gt;IAND&lt;/a&gt;, &lt;a href=&quot;ibits#IBITS&quot;&gt;IBITS&lt;/a&gt;, &lt;a href=&quot;ibset#IBSET&quot;&gt;IBSET&lt;/a&gt;, &lt;a href=&quot;ibclr#IBCLR&quot;&gt;IBCLR&lt;/a&gt;, &lt;a href=&quot;not#NOT&quot;&gt;NOT&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ior#IOR&quot;&gt;IOR&lt;/a&gt; , &lt;a href=&quot;iand#IAND&quot;&gt;IAND&lt;/a&gt; , &lt;a href=&quot;ibits#IBITS&quot;&gt;IBITS&lt;/a&gt; , &lt;a href=&quot;ibset#IBSET&quot;&gt;IBSET&lt;/a&gt; , &lt;a href=&quot;ibclr#IBCLR&quot;&gt;IBCLR&lt;/a&gt; , &lt;a href=&quot;not#NOT&quot;&gt;NOT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="24b1c92ca54f588bc0bab81c7aa50d92f6ae8070" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;ior#IOR&quot;&gt;IOR&lt;/a&gt;, &lt;a href=&quot;ieor#IEOR&quot;&gt;IEOR&lt;/a&gt;, &lt;a href=&quot;ibits#IBITS&quot;&gt;IBITS&lt;/a&gt;, &lt;a href=&quot;ibset#IBSET&quot;&gt;IBSET&lt;/a&gt;, &lt;a href=&quot;ibclr#IBCLR&quot;&gt;IBCLR&lt;/a&gt;, &lt;a href=&quot;not#NOT&quot;&gt;NOT&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ior#IOR&quot;&gt;IOR&lt;/a&gt; , &lt;a href=&quot;ieor#IEOR&quot;&gt;IEOR&lt;/a&gt; , &lt;a href=&quot;ibits#IBITS&quot;&gt;IBITS&lt;/a&gt; , &lt;a href=&quot;ibset#IBSET&quot;&gt;IBSET&lt;/a&gt; , &lt;a href=&quot;ibclr#IBCLR&quot;&gt;IBCLR&lt;/a&gt; , &lt;a href=&quot;not#NOT&quot;&gt;NOT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eed65ede294207b01e5c34904438adaa943b37fa" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;iparity#IPARITY&quot;&gt;IPARITY&lt;/a&gt;, &lt;a href=&quot;iall#IALL&quot;&gt;IALL&lt;/a&gt;, &lt;a href=&quot;ior#IOR&quot;&gt;IOR&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;iparity#IPARITY&quot;&gt;IPARITY&lt;/a&gt; , &lt;a href=&quot;iall#IALL&quot;&gt;IALL&lt;/a&gt; , &lt;a href=&quot;ior#IOR&quot;&gt;IOR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9e78ddd0526e609c3a5d37d799c6f136cc60c77" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;ishft#ISHFT&quot;&gt;ISHFT&lt;/a&gt;, &lt;a href=&quot;ishftc#ISHFTC&quot;&gt;ISHFTC&lt;/a&gt;, &lt;a href=&quot;lshift#LSHIFT&quot;&gt;LSHIFT&lt;/a&gt;, &lt;a href=&quot;shifta#SHIFTA&quot;&gt;SHIFTA&lt;/a&gt;, &lt;a href=&quot;shiftr#SHIFTR&quot;&gt;SHIFTR&lt;/a&gt;, &lt;a href=&quot;shiftl#SHIFTL&quot;&gt;SHIFTL&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ishft#ISHFT&quot;&gt;ISHFT&lt;/a&gt; , &lt;a href=&quot;ishftc#ISHFTC&quot;&gt;ISHFTC&lt;/a&gt; , &lt;a href=&quot;lshift#LSHIFT&quot;&gt;LSHIFT&lt;/a&gt; , &lt;a href=&quot;shifta#SHIFTA&quot;&gt;SHIFTA&lt;/a&gt; , &lt;a href=&quot;shiftr#SHIFTR&quot;&gt;SHIFTR&lt;/a&gt; , &lt;a href=&quot;shiftl#SHIFTL&quot;&gt;SHIFTL&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9eaa0c0788005e3a7bc56581d1038d531585f553" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;ishft#ISHFT&quot;&gt;ISHFT&lt;/a&gt;, &lt;a href=&quot;ishftc#ISHFTC&quot;&gt;ISHFTC&lt;/a&gt;, &lt;a href=&quot;rshift#RSHIFT&quot;&gt;RSHIFT&lt;/a&gt;, &lt;a href=&quot;shifta#SHIFTA&quot;&gt;SHIFTA&lt;/a&gt;, &lt;a href=&quot;shiftl#SHIFTL&quot;&gt;SHIFTL&lt;/a&gt;, &lt;a href=&quot;shiftr#SHIFTR&quot;&gt;SHIFTR&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ishft#ISHFT&quot;&gt;ISHFT&lt;/a&gt; , &lt;a href=&quot;ishftc#ISHFTC&quot;&gt;ISHFTC&lt;/a&gt; , &lt;a href=&quot;rshift#RSHIFT&quot;&gt;RSHIFT&lt;/a&gt; , &lt;a href=&quot;shifta#SHIFTA&quot;&gt;SHIFTA&lt;/a&gt; , &lt;a href=&quot;shiftl#SHIFTL&quot;&gt;SHIFTL&lt;/a&gt; , &lt;a href=&quot;shiftr#SHIFTR&quot;&gt;SHIFTR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dc7ff850230e9aa0c226ee11b78a90daf852649c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;lbound#LBOUND&quot;&gt;LBOUND&lt;/a&gt;, &lt;a href=&quot;lcobound#LCOBOUND&quot;&gt;LCOBOUND&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;lbound#LBOUND&quot;&gt;LBOUND&lt;/a&gt; , &lt;a href=&quot;lcobound#LCOBOUND&quot;&gt;LCOBOUND&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f889d98ac99aae65b14f680ae1fb7ce68f463c5e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;lcobound#LCOBOUND&quot;&gt;LCOBOUND&lt;/a&gt;, &lt;a href=&quot;lbound#LBOUND&quot;&gt;LBOUND&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;lcobound#LCOBOUND&quot;&gt;LCOBOUND&lt;/a&gt; , &lt;a href=&quot;lbound#LBOUND&quot;&gt;LBOUND&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="68679e7cadfe7d8c0c3efd4366df115976492f2c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;len#LEN&quot;&gt;LEN&lt;/a&gt;, &lt;a href=&quot;adjustl#ADJUSTL&quot;&gt;ADJUSTL&lt;/a&gt;, &lt;a href=&quot;adjustr#ADJUSTR&quot;&gt;ADJUSTR&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;len#LEN&quot;&gt;LEN&lt;/a&gt; , &lt;a href=&quot;adjustl#ADJUSTL&quot;&gt;ADJUSTL&lt;/a&gt; , &lt;a href=&quot;adjustr#ADJUSTR&quot;&gt;ADJUSTR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="93f1583ffa63e95f448e6103d6d7845e4139e1b9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;len_005ftrim#LEN_005fTRIM&quot;&gt;LEN_TRIM&lt;/a&gt;, &lt;a href=&quot;adjustl#ADJUSTL&quot;&gt;ADJUSTL&lt;/a&gt;, &lt;a href=&quot;adjustr#ADJUSTR&quot;&gt;ADJUSTR&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;len_005ftrim#LEN_005fTRIM&quot;&gt;LEN_TRIM&lt;/a&gt; , &lt;a href=&quot;adjustl#ADJUSTL&quot;&gt;ADJUSTL&lt;/a&gt; , &lt;a href=&quot;adjustr#ADJUSTR&quot;&gt;ADJUSTR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e6131b4b38d9ff9bb31ac8ef9b6e47951cd4bb4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;lge#LGE&quot;&gt;LGE&lt;/a&gt;, &lt;a href=&quot;lgt#LGT&quot;&gt;LGT&lt;/a&gt;, &lt;a href=&quot;lle#LLE&quot;&gt;LLE&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;lge#LGE&quot;&gt;LGE&lt;/a&gt; , &lt;a href=&quot;lgt#LGT&quot;&gt;LGT&lt;/a&gt; , &lt;a href=&quot;lle#LLE&quot;&gt;LLE&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cb9cf79f644b5c847bb415e1fcb35ab90337d29d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;lge#LGE&quot;&gt;LGE&lt;/a&gt;, &lt;a href=&quot;lgt#LGT&quot;&gt;LGT&lt;/a&gt;, &lt;a href=&quot;llt#LLT&quot;&gt;LLT&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;lge#LGE&quot;&gt;LGE&lt;/a&gt; , &lt;a href=&quot;lgt#LGT&quot;&gt;LGT&lt;/a&gt; , &lt;a href=&quot;llt#LLT&quot;&gt;LLT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e64c8f9707dc7d01b5f0a791e168f0290508f245" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;lge#LGE&quot;&gt;LGE&lt;/a&gt;, &lt;a href=&quot;lle#LLE&quot;&gt;LLE&lt;/a&gt;, &lt;a href=&quot;llt#LLT&quot;&gt;LLT&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;lge#LGE&quot;&gt;LGE&lt;/a&gt; , &lt;a href=&quot;lle#LLE&quot;&gt;LLE&lt;/a&gt; , &lt;a href=&quot;llt#LLT&quot;&gt;LLT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c5d80985b3beddaa32869824ea0bb35c505dccf4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;lgt#LGT&quot;&gt;LGT&lt;/a&gt;, &lt;a href=&quot;lle#LLE&quot;&gt;LLE&lt;/a&gt;, &lt;a href=&quot;llt#LLT&quot;&gt;LLT&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;lgt#LGT&quot;&gt;LGT&lt;/a&gt; , &lt;a href=&quot;lle#LLE&quot;&gt;LLE&lt;/a&gt; , &lt;a href=&quot;llt#LLT&quot;&gt;LLT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="856ce70cf9e195fe679039665252c3564e06d321" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;link#LINK&quot;&gt;LINK&lt;/a&gt;, &lt;a href=&quot;symlnk#SYMLNK&quot;&gt;SYMLNK&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;link#LINK&quot;&gt;링크&lt;/a&gt; , &lt;a href=&quot;symlnk#SYMLNK&quot;&gt;SYMLNK&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9a6007d85a053fa6df1292d1a07aca9b1011bc31" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;link#LINK&quot;&gt;LINK&lt;/a&gt;, &lt;a href=&quot;unlink#UNLINK&quot;&gt;UNLINK&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;link#LINK&quot;&gt;LINK&lt;/a&gt; , &lt;a href=&quot;unlink#UNLINK&quot;&gt;UNLINK&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="21a588fa1b37b2bee5215f27f6029d8c7c77be78" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;max#MAX&quot;&gt;MAX&lt;/a&gt;, &lt;a href=&quot;maxloc#MAXLOC&quot;&gt;MAXLOC&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;max#MAX&quot;&gt;MAX&lt;/a&gt; , &lt;a href=&quot;maxloc#MAXLOC&quot;&gt;MAXLOC&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e117b4b43b2189c8671c8d89cb3b186066140441" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;max#MAX&quot;&gt;MAX&lt;/a&gt;, &lt;a href=&quot;maxval#MAXVAL&quot;&gt;MAXVAL&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;max#MAX&quot;&gt;MAX&lt;/a&gt; , &lt;a href=&quot;maxval#MAXVAL&quot;&gt;MAXVAL&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9a12d155464ff7f78fe96ab13faa196c2a91e38a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;max#MAX&quot;&gt;MAX&lt;/a&gt;, &lt;a href=&quot;minloc#MINLOC&quot;&gt;MINLOC&lt;/a&gt;, &lt;a href=&quot;minval#MINVAL&quot;&gt;MINVAL&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;max#MAX&quot;&gt;MAX&lt;/a&gt; , &lt;a href=&quot;minloc#MINLOC&quot;&gt;MINLOC&lt;/a&gt; , &lt;a href=&quot;minval#MINVAL&quot;&gt;MINVAL&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52e6000d41fdf5adfe3c819329e80c25af63ef37" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;maxloc#MAXLOC&quot;&gt;MAXLOC&lt;/a&gt;&lt;a href=&quot;maxval#MAXVAL&quot;&gt;MAXVAL&lt;/a&gt;, &lt;a href=&quot;min#MIN&quot;&gt;MIN&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;maxloc#MAXLOC&quot;&gt;MAXLOC &lt;/a&gt;&lt;a href=&quot;maxval#MAXVAL&quot;&gt;MAXVAL&lt;/a&gt; , &lt;a href=&quot;min#MIN&quot;&gt;최소&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="957ea31c72af871b88afde6167e582247d505099" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;min#MIN&quot;&gt;MIN&lt;/a&gt;, &lt;a href=&quot;minloc#MINLOC&quot;&gt;MINLOC&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;min#MIN&quot;&gt;MIN&lt;/a&gt; , &lt;a href=&quot;minloc#MINLOC&quot;&gt;MINLOC&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d327384ec4debce9055bf7ac83db99cc5fb4c169" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;min#MIN&quot;&gt;MIN&lt;/a&gt;, &lt;a href=&quot;minval#MINVAL&quot;&gt;MINVAL&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;min#MIN&quot;&gt;MIN&lt;/a&gt; , &lt;a href=&quot;minval#MINVAL&quot;&gt;MINVAL&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4a2b73f0763dded9468c4fac7ce4ae77be74983d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;num_005fimages#NUM_005fIMAGES&quot;&gt;NUM_IMAGES&lt;/a&gt;, &lt;a href=&quot;image_005findex#IMAGE_005fINDEX&quot;&gt;IMAGE_INDEX&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;num_005fimages#NUM_005fIMAGES&quot;&gt;NUM_IMAGES&lt;/a&gt; , &lt;a href=&quot;image_005findex#IMAGE_005fINDEX&quot;&gt;IMAGE_INDEX&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ff2bf61cca9f51478e7868d177f9f32967b614a4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;pack#PACK&quot;&gt;PACK&lt;/a&gt;, &lt;a href=&quot;spread#SPREAD&quot;&gt;SPREAD&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;pack#PACK&quot;&gt;팩&lt;/a&gt; , &lt;a href=&quot;spread#SPREAD&quot;&gt;스프레드&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5b6f2415db058492ef9ba31af51b18f847473b16" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;popcnt#POPCNT&quot;&gt;POPCNT&lt;/a&gt;, &lt;a href=&quot;leadz#LEADZ&quot;&gt;LEADZ&lt;/a&gt;, &lt;a href=&quot;trailz#TRAILZ&quot;&gt;TRAILZ&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;popcnt#POPCNT&quot;&gt;POPCNT&lt;/a&gt; , &lt;a href=&quot;leadz#LEADZ&quot;&gt;LEADZ&lt;/a&gt; , &lt;a href=&quot;trailz#TRAILZ&quot;&gt;TRAILZ&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e305d31d8e1329776fada2eb2219287df4ae59a3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;poppar#POPPAR&quot;&gt;POPPAR&lt;/a&gt;, &lt;a href=&quot;leadz#LEADZ&quot;&gt;LEADZ&lt;/a&gt;, &lt;a href=&quot;trailz#TRAILZ&quot;&gt;TRAILZ&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;poppar#POPPAR&quot;&gt;POPPAR&lt;/a&gt; , &lt;a href=&quot;leadz#LEADZ&quot;&gt;LEADZ&lt;/a&gt; , &lt;a href=&quot;trailz#TRAILZ&quot;&gt;TRAILZ&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d894b2f5473e211b604ca2ed624437057a2e0210" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;precision#PRECISION&quot;&gt;PRECISION&lt;/a&gt;, &lt;a href=&quot;range#RANGE&quot;&gt;RANGE&lt;/a&gt;, &lt;a href=&quot;radix#RADIX&quot;&gt;RADIX&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;precision#PRECISION&quot;&gt;정밀&lt;/a&gt; , &lt;a href=&quot;range#RANGE&quot;&gt;범위&lt;/a&gt; , &lt;a href=&quot;radix#RADIX&quot;&gt;RADIX&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="64592654dc6bb3d483c3d3e7cd9b582887a4481b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;rand#RAND&quot;&gt;RAND&lt;/a&gt;, &lt;a href=&quot;random_005fnumber#RANDOM_005fNUMBER&quot;&gt;RANDOM_NUMBER&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;rand#RAND&quot;&gt;RAND&lt;/a&gt; , &lt;a href=&quot;random_005fnumber#RANDOM_005fNUMBER&quot;&gt;RANDOM_NUMBER&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8cf8aee6865221a3dd232e2fc29c7337cee7c497" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;rand#RAND&quot;&gt;RAND&lt;/a&gt;, &lt;a href=&quot;random_005fseed#RANDOM_005fSEED&quot;&gt;RANDOM_SEED&lt;/a&gt;, &lt;a href=&quot;random_005fnumber#RANDOM_005fNUMBER&quot;&gt;RANDOM_NUMBER&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;rand#RAND&quot;&gt;RAND&lt;/a&gt; , &lt;a href=&quot;random_005fseed#RANDOM_005fSEED&quot;&gt;RANDOM_SEED&lt;/a&gt; , &lt;a href=&quot;random_005fnumber#RANDOM_005fNUMBER&quot;&gt;RANDOM_NUMBER&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0bfe931e5caf04dc292d29ea35f7e3855bd0aa1a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reshape#RESHAPE&quot;&gt;RESHAPE&lt;/a&gt;, &lt;a href=&quot;size#SIZE&quot;&gt;SIZE&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;reshape#RESHAPE&quot;&gt;모양 변경&lt;/a&gt; , &lt;a href=&quot;size#SIZE&quot;&gt;SIZE&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c1fdb2d759ff4ebb4625b549841b3154723a9217" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;scan#SCAN&quot;&gt;SCAN&lt;/a&gt;, &lt;a href=&quot;index-intrinsic#INDEX-intrinsic&quot;&gt;INDEX intrinsic&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;scan#SCAN&quot;&gt;스캔&lt;/a&gt; , &lt;a href=&quot;index-intrinsic#INDEX-intrinsic&quot;&gt;INDEX 내장&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eca168a0b71d0ae0edd6f9c0e77f24d483e409c7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;scan#SCAN&quot;&gt;SCAN&lt;/a&gt;, &lt;a href=&quot;verify#VERIFY&quot;&gt;VERIFY&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;scan#SCAN&quot;&gt;스캔&lt;/a&gt; , &lt;a href=&quot;verify#VERIFY&quot;&gt;검증&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0d9376341b2e4225fdea329e06adfffd03b2eb6b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;selected_005freal_005fkind#SELECTED_005fREAL_005fKIND&quot;&gt;SELECTED_REAL_KIND&lt;/a&gt;, &lt;a href=&quot;precision#PRECISION&quot;&gt;PRECISION&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;selected_005freal_005fkind#SELECTED_005fREAL_005fKIND&quot;&gt;SELECTED_REAL_KIND&lt;/a&gt; , &lt;a href=&quot;precision#PRECISION&quot;&gt;PRECISION&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aa56dfac4255d977113eace1b0247c82026e96c3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;selected_005freal_005fkind#SELECTED_005fREAL_005fKIND&quot;&gt;SELECTED_REAL_KIND&lt;/a&gt;, &lt;a href=&quot;range#RANGE&quot;&gt;RANGE&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;selected_005freal_005fkind#SELECTED_005fREAL_005fKIND&quot;&gt;SELECTED_REAL_KIND&lt;/a&gt; , &lt;a href=&quot;range#RANGE&quot;&gt;RANGE&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="43e046e8e78c5c8ce9bc4b956927ee7de914f5c9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;shape#SHAPE&quot;&gt;SHAPE&lt;/a&gt;, &lt;a href=&quot;reshape#RESHAPE&quot;&gt;RESHAPE&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;shape#SHAPE&quot;&gt;모양&lt;/a&gt; , &lt;a href=&quot;reshape#RESHAPE&quot;&gt;개조&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3772c2ceaadc6c05c8387049eedde607516ce87" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;shifta#SHIFTA&quot;&gt;SHIFTA&lt;/a&gt;, &lt;a href=&quot;shiftl#SHIFTL&quot;&gt;SHIFTL&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;shifta#SHIFTA&quot;&gt;SHIFTA&lt;/a&gt; , &lt;a href=&quot;shiftl#SHIFTL&quot;&gt;SHIFTL&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5806b0bfed6c8476ed3c77c5c19d8f2346b8583c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;shifta#SHIFTA&quot;&gt;SHIFTA&lt;/a&gt;, &lt;a href=&quot;shiftr#SHIFTR&quot;&gt;SHIFTR&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;shifta#SHIFTA&quot;&gt;SHIFTA&lt;/a&gt; , &lt;a href=&quot;shiftr#SHIFTR&quot;&gt;SHIFTR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="86f3566e2e0b1f753d129839aec1d7301a657e46" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;shiftl#SHIFTL&quot;&gt;SHIFTL&lt;/a&gt;, &lt;a href=&quot;shiftr#SHIFTR&quot;&gt;SHIFTR&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;shiftl#SHIFTL&quot;&gt;SHIFTL&lt;/a&gt; , &lt;a href=&quot;shiftr#SHIFTR&quot;&gt;SHIFTR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b2b0792a996b19328323e6931ede6b43599538be" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;sizeof#SIZEOF&quot;&gt;SIZEOF&lt;/a&gt;, &lt;a href=&quot;storage_005fsize#STORAGE_005fSIZE&quot;&gt;STORAGE_SIZE&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;sizeof#SIZEOF&quot;&gt;SIZEOF&lt;/a&gt; , &lt;a href=&quot;storage_005fsize#STORAGE_005fSIZE&quot;&gt;STORAGE_SIZE&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cd645fb65404cd3560326d06742c8b360ea62d43" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;srand#SRAND&quot;&gt;SRAND&lt;/a&gt;, &lt;a href=&quot;random_005fnumber#RANDOM_005fNUMBER&quot;&gt;RANDOM_NUMBER&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;srand#SRAND&quot;&gt;SRAND&lt;/a&gt; , &lt;a href=&quot;random_005fnumber#RANDOM_005fNUMBER&quot;&gt;RANDOM_NUMBER&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7a8362d1a33a3edb78dbd045b2950426fe3b5c2e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;symlnk#SYMLNK&quot;&gt;SYMLNK&lt;/a&gt;, &lt;a href=&quot;unlink#UNLINK&quot;&gt;UNLINK&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;symlnk#SYMLNK&quot;&gt;SYMLNK&lt;/a&gt; , &lt;a href=&quot;unlink#UNLINK&quot;&gt;UNLINK&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ea5437f761377c46dc17739f390ce57463725c3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;system_005fclock#SYSTEM_005fCLOCK&quot;&gt;SYSTEM_CLOCK&lt;/a&gt;, &lt;a href=&quot;date_005fand_005ftime#DATE_005fAND_005fTIME&quot;&gt;DATE_AND_TIME&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;system_005fclock#SYSTEM_005fCLOCK&quot;&gt;SYSTEM_CLOCK&lt;/a&gt; , &lt;a href=&quot;date_005fand_005ftime#DATE_005fAND_005fTIME&quot;&gt;DATE_AND_TIME&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aa62f38a6d5e78888b29355a505d0392c862a9fe" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;this_005fimage#THIS_005fIMAGE&quot;&gt;THIS_IMAGE&lt;/a&gt;, &lt;a href=&quot;image_005findex#IMAGE_005fINDEX&quot;&gt;IMAGE_INDEX&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;this_005fimage#THIS_005fIMAGE&quot;&gt;THIS_IMAGE&lt;/a&gt; , &lt;a href=&quot;image_005findex#IMAGE_005fINDEX&quot;&gt;IMAGE_INDEX&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="198671ba6dfc783952bcbcebdd2cc934c2bba728" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;this_005fimage#THIS_005fIMAGE&quot;&gt;THIS_IMAGE&lt;/a&gt;, &lt;a href=&quot;num_005fimages#NUM_005fIMAGES&quot;&gt;NUM_IMAGES&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;this_005fimage#THIS_005fIMAGE&quot;&gt;THIS_IMAGE&lt;/a&gt; , &lt;a href=&quot;num_005fimages#NUM_005fIMAGES&quot;&gt;NUM_IMAGES&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7356151ae43fd499d7a2b1dc8cdb19a2ed9e1c9b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;ubound#UBOUND&quot;&gt;UBOUND&lt;/a&gt;, &lt;a href=&quot;lcobound#LCOBOUND&quot;&gt;LCOBOUND&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ubound#UBOUND&quot;&gt;UBound 함수&lt;/a&gt; , &lt;a href=&quot;lcobound#LCOBOUND&quot;&gt;LCOBOUND&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1d8eb0d4c4b384b913a09c6a710a0250ed8bd4a4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;ucobound#UCOBOUND&quot;&gt;UCOBOUND&lt;/a&gt;, &lt;a href=&quot;lbound#LBOUND&quot;&gt;LBOUND&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ucobound#UCOBOUND&quot;&gt;UCOBOUND&lt;/a&gt; , &lt;a href=&quot;lbound#LBOUND&quot;&gt;LBOUND&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9fdfe6d0118c5c6a7db30fa577a49dda6ae82b73" translate="yes" xml:space="preserve">
          <source>&lt;code id=&quot;index-ALLOCATABLE-components-of-derived-types&quot;&gt;ALLOCATABLE&lt;/code&gt; components of derived types</source>
          <target state="translated">&lt;code id=&quot;index-ALLOCATABLE-components-of-derived-types&quot;&gt;ALLOCATABLE&lt;/code&gt; 파생 형식의 할당 가능 구성 요소</target>
        </trans-unit>
        <trans-unit id="474c69ccde4995b3f01df8c230e53676bf801645" translate="yes" xml:space="preserve">
          <source>&lt;code id=&quot;index-ALLOCATABLE-dummy-arguments&quot;&gt;ALLOCATABLE&lt;/code&gt; dummy arguments.</source>
          <target state="translated">&lt;code id=&quot;index-ALLOCATABLE-dummy-arguments&quot;&gt;ALLOCATABLE&lt;/code&gt; 더미 인수.</target>
        </trans-unit>
        <trans-unit id="60bc6b56a1bc6b78e9c663ab7fea85f4cb06106d" translate="yes" xml:space="preserve">
          <source>&lt;code id=&quot;index-ALLOCATABLE-function-results&quot;&gt;ALLOCATABLE&lt;/code&gt; function results</source>
          <target state="translated">&lt;code id=&quot;index-ALLOCATABLE-function-results&quot;&gt;ALLOCATABLE&lt;/code&gt; 함수 결과</target>
        </trans-unit>
        <trans-unit id="5c146f4c06505e60251059c305ee1713d83a6182" translate="yes" xml:space="preserve">
          <source>&lt;code id=&quot;index-IOMSG_003d-specifier&quot;&gt;IOMSG=&lt;/code&gt; specifier for I/O statements.</source>
          <target state="translated">&lt;code id=&quot;index-IOMSG_003d-specifier&quot;&gt;IOMSG=&lt;/code&gt; I / O 문에 대한 IOMSG = 지정자</target>
        </trans-unit>
        <trans-unit id="cc66bbc51ea243e84e69dacae7000550c88f50ae" translate="yes" xml:space="preserve">
          <source>&lt;code id=&quot;index-statement_002c-FLUSH&quot;&gt;FLUSH&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code id=&quot;index-statement_002c-FLUSH&quot;&gt;FLUSH&lt;/code&gt; 진술서.</target>
        </trans-unit>
        <trans-unit id="3cf1291bad1c439580fcc0c21f2b5dfce367d675" translate="yes" xml:space="preserve">
          <source>&lt;code id=&quot;index-statement_002c-ISO_005fFORTRAN_005fENV&quot;&gt;USE&lt;/code&gt; statement with &lt;code&gt;INTRINSIC&lt;/code&gt; and &lt;code&gt;NON_INTRINSIC&lt;/code&gt; attribute; supported intrinsic modules: &lt;code&gt;ISO_FORTRAN_ENV&lt;/code&gt;, &lt;code&gt;ISO_C_BINDING&lt;/code&gt;, &lt;code&gt;OMP_LIB&lt;/code&gt; and &lt;code&gt;OMP_LIB_KINDS&lt;/code&gt;, and &lt;code&gt;OPENACC&lt;/code&gt;.</source>
          <target state="translated">&lt;code id=&quot;index-statement_002c-ISO_005fFORTRAN_005fENV&quot;&gt;USE&lt;/code&gt; 과 문 &lt;code&gt;INTRINSIC&lt;/code&gt; 하고 &lt;code&gt;NON_INTRINSIC&lt;/code&gt; 속성; 지원되는 고유 모듈 : &lt;code&gt;ISO_FORTRAN_ENV&lt;/code&gt; , &lt;code&gt;ISO_C_BINDING&lt;/code&gt; , &lt;code&gt;OMP_LIB&lt;/code&gt; 및 &lt;code&gt;OMP_LIB_KINDS&lt;/code&gt; 및 &lt;code&gt;OPENACC&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b4403453492b3c91fdb82617c289be09f560d47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!GCC$ ATTRIBUTES&lt;/code&gt;&lt;var&gt;attribute-list&lt;/var&gt;&lt;code&gt;::&lt;/code&gt;&lt;var&gt;variable-list&lt;/var&gt;</source>
          <target state="translated">&lt;code&gt;!GCC$ ATTRIBUTES&lt;/code&gt; &lt;var&gt;attribute-list&lt;/var&gt; &lt;code&gt;::&lt;/code&gt; &lt;var&gt;variable-list&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="0841e6ecf9c716e3ca319a2cb8cd5bbba76a806c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%VAL&lt;/code&gt; passes a scalar argument by value, &lt;code&gt;%REF&lt;/code&gt; passes it by reference and &lt;code&gt;%LOC&lt;/code&gt; passes its memory location. Since gfortran already passes scalar arguments by reference, &lt;code&gt;%REF&lt;/code&gt; is in effect a do-nothing. &lt;code&gt;%LOC&lt;/code&gt; has the same effect as a Fortran pointer.</source>
          <target state="translated">&lt;code&gt;%VAL&lt;/code&gt; 은 스칼라 인수를 값으로 전달하고 &lt;code&gt;%REF&lt;/code&gt; 는이를 참조로 전달 하고 &lt;code&gt;%LOC&lt;/code&gt; 는 메모리 위치를 전달합니다. gfortran은 이미 참조로 스칼라 인수를 전달하므로 &lt;code&gt;%REF&lt;/code&gt; 는 사실상 아무것도 아닙니다. &lt;code&gt;%LOC&lt;/code&gt; 는 포트란 포인터와 동일한 효과를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="3c998bd0d36ebf004984d00c2efa8d31fbd031b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'10-20'&lt;/code&gt; Units 10 to 20 are big-endian, the rest is native.</source>
          <target state="translated">&lt;code&gt;'10-20'&lt;/code&gt; 호기는 빅 엔디안이고 나머지는 원산지입니다.</target>
        </trans-unit>
        <trans-unit id="329f7f1f301199b8935f4ed12d9cacd563f7192b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'big_endian'&lt;/code&gt; Do all unformatted I/O in big_endian mode.</source>
          <target state="translated">&lt;code&gt;'big_endian'&lt;/code&gt; big_endian 모드에서 형식화되지 않은 모든 I / O를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ef312558b238d9e441ab5dd8e48ba54b19f57311" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'little_endian;native:10-20,25'&lt;/code&gt; Do all unformatted I/O in little_endian mode, except for units 10 to 20 and 25, which are in native format.</source>
          <target state="translated">&lt;code&gt;'little_endian;native:10-20,25'&lt;/code&gt; 기본 형식 인 단위 10-20 및 25를 제외하고 little_endian 모드에서 형식화되지 않은 모든 I / O를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="e1a3fddd168b8988d3371d28364babe990f9c6cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.FALSE.&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.FALSE.&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="76a1c1a7cc36bbed5ba75233368f7cf1de890765" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;acosd#ACOSD&quot;&gt;ACOSD&lt;/a&gt;&lt;/code&gt;*</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;acosd#ACOSD&quot;&gt;ACOSD&lt;/a&gt;&lt;/code&gt;*</target>
        </trans-unit>
        <trans-unit id="af730bb964fcc7fa3545f4388a977802ade1a457" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;asind#ASIND&quot;&gt;ASIND&lt;/a&gt;&lt;/code&gt;*</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;asind#ASIND&quot;&gt;ASIND&lt;/a&gt;&lt;/code&gt;*</target>
        </trans-unit>
        <trans-unit id="993ba0764155256b438e447f5e8cbff5a116843c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;atan2d#ATAN2D&quot;&gt;ATAN2D&lt;/a&gt;&lt;/code&gt;*</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;atan2d#ATAN2D&quot;&gt;ATAN2D&lt;/a&gt;&lt;/code&gt;*</target>
        </trans-unit>
        <trans-unit id="e4580a111040e0f5374d562f5f6bcb312dfdd949" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;atand#ATAND&quot;&gt;ATAND&lt;/a&gt;&lt;/code&gt;*</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;atand#ATAND&quot;&gt;ATAND&lt;/a&gt;&lt;/code&gt;*</target>
        </trans-unit>
        <trans-unit id="eb097cf0f4f63b47974b79e3b21ba77cf67f6864" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;cosd#COSD&quot;&gt;COSD&lt;/a&gt;&lt;/code&gt;*</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;cosd#COSD&quot;&gt;COSD&lt;/a&gt;&lt;/code&gt;*</target>
        </trans-unit>
        <trans-unit id="b38cd41112692a8645c3f8d089334ed8c087520f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;cotan#COTAN&quot;&gt;COTAN&lt;/a&gt;&lt;/code&gt;*</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;cotan#COTAN&quot;&gt;COTAN&lt;/a&gt;&lt;/code&gt;*</target>
        </trans-unit>
        <trans-unit id="102948bdafe0da74dad53b834cf5e654561fb8f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;cotand#COTAND&quot;&gt;COTAND&lt;/a&gt;&lt;/code&gt;*</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;cotand#COTAND&quot;&gt;COTAND&lt;/a&gt;&lt;/code&gt;*</target>
        </trans-unit>
        <trans-unit id="891f6c74267e3aad988dad8021fb4070c590080c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;sind#SIND&quot;&gt;SIND&lt;/a&gt;&lt;/code&gt;*</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;sind#SIND&quot;&gt;SIND&lt;/a&gt;&lt;/code&gt;*</target>
        </trans-unit>
        <trans-unit id="f16e4c049b446d2e0eaa21a3f7d4cd5b9c44ff03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;a href=&quot;tand#TAND&quot;&gt;TAND&lt;/a&gt;&lt;/code&gt;*</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;tand#TAND&quot;&gt;TAND&lt;/a&gt;&lt;/code&gt;*</target>
        </trans-unit>
        <trans-unit id="a800140e9a03829e17781638ef4d266fbca130a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ABORT&lt;/code&gt; causes immediate termination of the program. On operating systems that support a core dump, &lt;code&gt;ABORT&lt;/code&gt; will produce a core dump. It will also print a backtrace, unless &lt;code&gt;-fno-backtrace&lt;/code&gt; is given.</source>
          <target state="translated">&lt;code&gt;ABORT&lt;/code&gt; 는 프로그램을 즉시 종료시킵니다. 코어 덤프를 지원하는 운영 체제에서 &lt;code&gt;ABORT&lt;/code&gt; 는 코어 덤프를 생성합니다. &lt;code&gt;-fno-backtrace&lt;/code&gt; 를 지정 하지 않으면 역 추적도 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="39f599b2326a6c1861e1530da23afe4ceb4ceb08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ABS(A)&lt;/code&gt; computes the absolute value of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ABS(A)&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 의 절대 값을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="620496eaa136f47c0f4a775c9d12fb95dd85e7cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ACCESS(NAME, MODE)&lt;/code&gt; checks whether the file &lt;var&gt;NAME&lt;/var&gt; exists, is readable, writable or executable. Except for the executable check, &lt;code&gt;ACCESS&lt;/code&gt; can be replaced by Fortran 95&amp;rsquo;s &lt;code&gt;INQUIRE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ACCESS(NAME, MODE)&lt;/code&gt; 는 파일 &lt;var&gt;NAME&lt;/var&gt; 이 존재 하는지, 읽을 수 있는지, 쓰기 가능 또는 실행 가능한지 여부를 확인합니다 . 실행 가능 검사를 제외하고 &lt;code&gt;ACCESS&lt;/code&gt; 는 Fortran 95의 &lt;code&gt;INQUIRE&lt;/code&gt; 로 대체 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="39bd3f32e3d1ef1350ec8c45e82631450fcb8099" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ACHAR(I)&lt;/code&gt; returns the character located at position &lt;code&gt;I&lt;/code&gt; in the ASCII collating sequence.</source>
          <target state="translated">&lt;code&gt;ACHAR(I)&lt;/code&gt; 는 ASCII 조합 순서 에서 위치 &lt;code&gt;I&lt;/code&gt; 에있는 문자를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="a127c8af850b548e9d3f924065fbbcf105c332ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ACOS(X)&lt;/code&gt; computes the arccosine of &lt;var&gt;X&lt;/var&gt; (inverse of &lt;code&gt;COS(X)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;ACOS(X)&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 의 아크 코사인 ( &lt;code&gt;COS(X)&lt;/code&gt; 역수 )을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="77f5b02d4611092abe61716b49bcbdc3f2043b1c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ACOSD(X)&lt;/code&gt; computes the arccosine of &lt;var&gt;X&lt;/var&gt; in degrees (inverse of &lt;code&gt;COSD(X)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;ACOSD(X)&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 의 아크 코사인을 도 단위로 계산합니다 ( &lt;code&gt;COSD(X)&lt;/code&gt; 역수 ).</target>
        </trans-unit>
        <trans-unit id="dd9d5c9ac014242149c056c87d6d3a156f820f96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ACOSH(X)&lt;/code&gt; computes the inverse hyperbolic cosine of &lt;var&gt;X&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;ACOSH(X)&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 의 역 쌍곡 코사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="596d509ab7368f324fee5e407a66caf9f607ff4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ADJUSTL(STRING)&lt;/code&gt; will left adjust a string by removing leading spaces. Spaces are inserted at the end of the string as needed.</source>
          <target state="translated">&lt;code&gt;ADJUSTL(STRING)&lt;/code&gt; 은 선행 공백을 제거하여 문자열을 왼쪽으로 조정합니다. 필요에 따라 문자열 끝에 공백이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="f83c4d7c9284cb49d0a2aee2ad539d06077d5b5b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ADJUSTR(STRING)&lt;/code&gt; will right adjust a string by removing trailing spaces. Spaces are inserted at the start of the string as needed.</source>
          <target state="translated">&lt;code&gt;ADJUSTR(STRING)&lt;/code&gt; 은 후행 공백을 제거하여 문자열을 올바르게 조정합니다. 필요에 따라 문자열의 시작 부분에 공백이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="c15a7be428b3ae4ebef1c14e514c3e0fa63fec16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AIMAG(Z)&lt;/code&gt; yields the imaginary part of complex argument &lt;code&gt;Z&lt;/code&gt;. The &lt;code&gt;IMAG(Z)&lt;/code&gt; and &lt;code&gt;IMAGPART(Z)&lt;/code&gt; intrinsic functions are provided for compatibility with &lt;code&gt;g77&lt;/code&gt;, and their use in new code is strongly discouraged.</source>
          <target state="translated">&lt;code&gt;AIMAG(Z)&lt;/code&gt; 는 복소수 인수 &lt;code&gt;Z&lt;/code&gt; 의 허수 부분을 생성합니다 . &lt;code&gt;IMAG(Z)&lt;/code&gt; 와 &lt;code&gt;IMAGPART(Z)&lt;/code&gt; 고유 기능과의 호환성을 위해 제공되는 &lt;code&gt;g77&lt;/code&gt; , 새로운 코드의 사용은 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5db9fd14608e881abff7022f0c27d029afca6fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AINT(A [, KIND])&lt;/code&gt; truncates its argument to a whole number.</source>
          <target state="translated">&lt;code&gt;AINT(A [, KIND])&lt;/code&gt; 는 인수를 정수로 자릅니다.</target>
        </trans-unit>
        <trans-unit id="25de410960145e8f837acc1fdaa4f670ee70c507" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ALARM(SECONDS, HANDLER [, STATUS])&lt;/code&gt; causes external subroutine &lt;var&gt;HANDLER&lt;/var&gt; to be executed after a delay of &lt;var&gt;SECONDS&lt;/var&gt; by using &lt;code&gt;alarm(2)&lt;/code&gt; to set up a signal and &lt;code&gt;signal(2)&lt;/code&gt; to catch it. If &lt;var&gt;STATUS&lt;/var&gt; is supplied, it will be returned with the number of seconds remaining until any previously scheduled alarm was due to be delivered, or zero if there was no previously scheduled alarm.</source>
          <target state="translated">&lt;code&gt;ALARM(SECONDS, HANDLER [, STATUS])&lt;/code&gt; 는 &lt;code&gt;alarm(2)&lt;/code&gt; 를 사용하여 신호를 설정하고 &lt;code&gt;signal(2)&lt;/code&gt; 를 포착하여 포착하기 위해 &lt;var&gt;SECONDS&lt;/var&gt; 가 지연된 후 외부 서브 루틴 &lt;var&gt;HANDLER&lt;/var&gt; 가 실행 되도록합니다. 경우 &lt;var&gt;STATUS&lt;/var&gt; 공급되고, 그것은 이전에 예약 된 알람까지 남은 시간을 초 단위의 숫자로 인해되었다 반환됩니다 전달 될, 또는 더 이전에 설정된 알람이 없다면 제로.</target>
        </trans-unit>
        <trans-unit id="815654d39e96eed101115c8613a94cac6aea5f21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ALL(MASK [, DIM])&lt;/code&gt; determines if all the values are true in &lt;var&gt;MASK&lt;/var&gt; in the array along dimension &lt;var&gt;DIM&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;ALL(MASK [, DIM])&lt;/code&gt; 은 차원 &lt;var&gt;DIM&lt;/var&gt; 을 따라 배열의 &lt;var&gt;MASK&lt;/var&gt; 에서 모든 값이 true인지 판별합니다 .</target>
        </trans-unit>
        <trans-unit id="7fd4d0a4f8ec1036543cb3dd0bd036e235ceac14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ALL(MASK)&lt;/code&gt; is true if all elements of &lt;var&gt;MASK&lt;/var&gt; are true. It also is true if &lt;var&gt;MASK&lt;/var&gt; has zero size; otherwise, it is false.</source>
          <target state="translated">&lt;code&gt;ALL(MASK)&lt;/code&gt; 모든 요소 마찬가지입니다 &lt;var&gt;MASK&lt;/var&gt; 는 사실이다. &lt;var&gt;MASK&lt;/var&gt; 의 크기가 0 인 경우에도 마찬가지입니다 . 그렇지 않으면 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="8d3a902a09a5fe33b3dd7ff4449c4d2f47749e00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ALL(MASK)&lt;/code&gt; returns a scalar value of type &lt;code&gt;LOGICAL&lt;/code&gt; where the kind type parameter is the same as the kind type parameter of &lt;var&gt;MASK&lt;/var&gt;. If &lt;var&gt;DIM&lt;/var&gt; is present, then &lt;code&gt;ALL(MASK, DIM)&lt;/code&gt; returns an array with the rank of &lt;var&gt;MASK&lt;/var&gt; minus 1. The shape is determined from the shape of &lt;var&gt;MASK&lt;/var&gt; where the &lt;var&gt;DIM&lt;/var&gt; dimension is elided.</source>
          <target state="translated">&lt;code&gt;ALL(MASK)&lt;/code&gt; 은 kind 유형 매개 변수가 &lt;var&gt;MASK&lt;/var&gt; 의 kind 유형 매개 변수와 동일한 &lt;code&gt;LOGICAL&lt;/code&gt; 유형의 스칼라 값을 리턴합니다 . 경우 &lt;var&gt;DIM&lt;/var&gt; 이 존재하고 &lt;code&gt;ALL(MASK, DIM)&lt;/code&gt; 계급으로 배열 반환 &lt;var&gt;MASK&lt;/var&gt; 형상의 형상이 결정된다 뺀 &lt;var&gt;MASK&lt;/var&gt; &lt;var&gt;DIM&lt;/var&gt; 의 치수는 생략된다.</target>
        </trans-unit>
        <trans-unit id="040526b0fae29caab7b147f20936177c2954f7b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ALLOCATABLE&lt;/code&gt;, &lt;code&gt;INTENT(INOUT)&lt;/code&gt;, may be of any type and kind.</source>
          <target state="translated">&lt;code&gt;ALLOCATABLE&lt;/code&gt; , &lt;code&gt;INTENT(INOUT)&lt;/code&gt; 은 모든 유형 및 종류 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e61bed5113f3f589d1772c80071ee59680856172" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ALLOCATABLE&lt;/code&gt;, &lt;code&gt;INTENT(OUT)&lt;/code&gt;, shall be of the same type, kind and rank as &lt;var&gt;FROM&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;ALLOCATABLE&lt;/code&gt; , &lt;code&gt;INTENT(OUT)&lt;/code&gt; 은 &lt;var&gt;FROM&lt;/var&gt; 과 동일한 유형, 종류 및 순위를 가져야 합니다.</target>
        </trans-unit>
        <trans-unit id="70bf193a6ff166a543742ea2f8021d28337f8cf2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ALLOCATED(ARRAY)&lt;/code&gt; and &lt;code&gt;ALLOCATED(SCALAR)&lt;/code&gt; check the allocation status of &lt;var&gt;ARRAY&lt;/var&gt; and &lt;var&gt;SCALAR&lt;/var&gt;, respectively.</source>
          <target state="translated">&lt;code&gt;ALLOCATED(ARRAY)&lt;/code&gt; 및 &lt;code&gt;ALLOCATED(SCALAR)&lt;/code&gt; 는 각각 &lt;var&gt;ARRAY&lt;/var&gt; 및 &lt;var&gt;SCALAR&lt;/var&gt; 의 할당 상태를 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="a408424f6122f9b6466023dcf760908681a34900" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ANINT(A [, KIND])&lt;/code&gt; rounds its argument to the nearest whole number.</source>
          <target state="translated">&lt;code&gt;ANINT(A [, KIND])&lt;/code&gt; 는 인수를 가장 가까운 정수로 반올림합니다.</target>
        </trans-unit>
        <trans-unit id="9a65af2698c829c002363976d488e928bf0a265f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ANY(MASK [, DIM])&lt;/code&gt; determines if any of the values in the logical array &lt;var&gt;MASK&lt;/var&gt; along dimension &lt;var&gt;DIM&lt;/var&gt; are &lt;code&gt;.TRUE.&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ANY(MASK [, DIM])&lt;/code&gt; 는 차원 &lt;var&gt;DIM&lt;/var&gt; 을 따라 논리 배열 &lt;var&gt;MASK&lt;/var&gt; 의 값 이 &lt;code&gt;.TRUE.&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ce557dc91f7440a204e6659202c9899d4fbe0e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ANY(MASK)&lt;/code&gt; is true if any element of &lt;var&gt;MASK&lt;/var&gt; is true; otherwise, it is false. It also is false if &lt;var&gt;MASK&lt;/var&gt; has zero size.</source>
          <target state="translated">&lt;code&gt;ANY(MASK)&lt;/code&gt; 의 요소 마찬가지입니다 &lt;var&gt;MASK&lt;/var&gt; 는 사실이다; 그렇지 않으면 거짓입니다. &lt;var&gt;MASK&lt;/var&gt; 의 크기가 0 인 경우에도 false 입니다.</target>
        </trans-unit>
        <trans-unit id="71f39605d598c39618d4891b60323e4a7856fe54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ANY(MASK)&lt;/code&gt; returns a scalar value of type &lt;code&gt;LOGICAL&lt;/code&gt; where the kind type parameter is the same as the kind type parameter of &lt;var&gt;MASK&lt;/var&gt;. If &lt;var&gt;DIM&lt;/var&gt; is present, then &lt;code&gt;ANY(MASK, DIM)&lt;/code&gt; returns an array with the rank of &lt;var&gt;MASK&lt;/var&gt; minus 1. The shape is determined from the shape of &lt;var&gt;MASK&lt;/var&gt; where the &lt;var&gt;DIM&lt;/var&gt; dimension is elided.</source>
          <target state="translated">&lt;code&gt;ANY(MASK)&lt;/code&gt; 는 kind 유형 매개 변수가 &lt;var&gt;MASK&lt;/var&gt; 의 kind 유형 매개 변수와 동일한 &lt;code&gt;LOGICAL&lt;/code&gt; 유형의 스칼라 값을 리턴합니다 . 경우 &lt;var&gt;DIM&lt;/var&gt; 이 존재하고 &lt;code&gt;ANY(MASK, DIM)&lt;/code&gt; 계급으로 배열 반환 &lt;var&gt;MASK&lt;/var&gt; 형상의 형상이 결정된다 뺀 &lt;var&gt;MASK&lt;/var&gt; &lt;var&gt;DIM&lt;/var&gt; 의 치수는 생략된다.</target>
        </trans-unit>
        <trans-unit id="3dc1af3c11a709e2e2716d6cee94be00042a97a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ASIN(X)&lt;/code&gt; computes the arcsine of its &lt;var&gt;X&lt;/var&gt; (inverse of &lt;code&gt;SIN(X)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;ASIN(X)&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 의 아크 사인 ( &lt;code&gt;SIN(X)&lt;/code&gt; 역수 )을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="41c38295ddba6f0fabbc281e489d6710ba146838" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ASIND(X)&lt;/code&gt; computes the arcsine of its &lt;var&gt;X&lt;/var&gt; in degrees (inverse of &lt;code&gt;SIND(X)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;ASIND(X)&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 의 아크 사인을 도 단위로 계산합니다 ( &lt;code&gt;SIND(X)&lt;/code&gt; 역수 ).</target>
        </trans-unit>
        <trans-unit id="26b8d14e4433a9c154ba81635b54aab13e07ad95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ASINH(X)&lt;/code&gt; computes the inverse hyperbolic sine of &lt;var&gt;X&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;ASINH(X)&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 의 역 쌍곡 사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="963e7e73761ec544bf6cad07465bfebc3a36cada" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ASSOCIATED(POINTER [, TARGET])&lt;/code&gt; determines the status of the pointer &lt;var&gt;POINTER&lt;/var&gt; or if &lt;var&gt;POINTER&lt;/var&gt; is associated with the target &lt;var&gt;TARGET&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;ASSOCIATED(POINTER [, TARGET])&lt;/code&gt; 는 포인터 &lt;var&gt;POINTER&lt;/var&gt; 의 상태 또는 &lt;var&gt;POINTER&lt;/var&gt; 가 대상 &lt;var&gt;TARGET&lt;/var&gt; 과 연관되어 있는지 판별합니다 .</target>
        </trans-unit>
        <trans-unit id="d5a247a483f517fd57a056135495c1f4325a9dae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ASSOCIATED(POINTER)&lt;/code&gt; is true if &lt;var&gt;POINTER&lt;/var&gt; is associated with a target; otherwise, it returns false.</source>
          <target state="translated">&lt;code&gt;ASSOCIATED(POINTER)&lt;/code&gt; &lt;var&gt;POINTER&lt;/var&gt; 가 대상과 연관된 경우 ASSOCIATED (POINTER) 는 true입니다 . 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="678075069742806dbeac9168413008c622658045" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ASSOCIATED(POINTER)&lt;/code&gt; returns a scalar value of type &lt;code&gt;LOGICAL(4)&lt;/code&gt;. There are several cases:</source>
          <target state="translated">&lt;code&gt;ASSOCIATED(POINTER)&lt;/code&gt; 는 &lt;code&gt;LOGICAL(4)&lt;/code&gt; 유형의 스칼라 값을 반환합니다 . 몇 가지 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f9ee01e5617d0f6f07d03ebe6a524d0355cac3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ATAN(X)&lt;/code&gt; computes the arctangent of &lt;var&gt;X&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;ATAN(X)&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 의 아크 탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="49b396fba415b1c3fe0dfe1a45978c5982e536dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ATAN2(Y, X)&lt;/code&gt; computes the principal value of the argument function of the complex number &lt;em&gt;X + i Y&lt;/em&gt;. This function can be used to transform from Cartesian into polar coordinates and allows to determine the angle in the correct quadrant.</source>
          <target state="translated">&lt;code&gt;ATAN2(Y, X)&lt;/code&gt; 는 복소수 &lt;em&gt;X + i Y&lt;/em&gt; 의 인수 함수의 주요 값을 계산합니다 . 이 기능을 사용하여 직교 좌표계에서 극좌표로 변환하고 올바른 사분면에서 각도를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd948015be44ca4fec3bd11c9f97dfffcde68b56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ATAN2D(Y, X)&lt;/code&gt; computes the principal value of the argument function of the complex number &lt;em&gt;X + i Y&lt;/em&gt; in degrees. This function can be used to transform from Cartesian into polar coordinates and allows to determine the angle in the correct quadrant.</source>
          <target state="translated">&lt;code&gt;ATAN2D(Y, X)&lt;/code&gt; 는 복소수 &lt;em&gt;X + i Y&lt;/em&gt; 의 인수 함수의 주요 값을도 단위로 계산합니다 . 이 함수를 사용하여 직교 좌표계에서 극좌표로 변환하고 올바른 사분면에서 각도를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3d23ed3062b504ae484d9779c76e910852f2797" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ATAND(X)&lt;/code&gt; computes the arctangent of &lt;var&gt;X&lt;/var&gt; in degrees (inverse of &lt;a href=&quot;tand#TAND&quot;&gt;TAND&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;ATAND(X)&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 의 아크 탄젠트를 도 단위로 계산합니다 ( &lt;a href=&quot;tand#TAND&quot;&gt;TAND의&lt;/a&gt; 역수 ).</target>
        </trans-unit>
        <trans-unit id="a31190ac5dc73f57f2db752e573fae577158eea9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ATANH(X)&lt;/code&gt; computes the inverse hyperbolic tangent of &lt;var&gt;X&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;ATANH(X)&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 의 역 쌍곡 탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="2462c5db702ef6165543de308ddfb41e6e809cf6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ATOMIC_ADD(ATOM, VALUE)&lt;/code&gt; atomically adds the value of &lt;var&gt;VAR&lt;/var&gt; to the variable &lt;var&gt;ATOM&lt;/var&gt;. When &lt;var&gt;STAT&lt;/var&gt; is present and the invocation was successful, it is assigned the value 0. If it is present and the invocation has failed, it is assigned a positive value; in particular, for a coindexed &lt;var&gt;ATOM&lt;/var&gt;, if the remote image has stopped, it is assigned the value of &lt;code&gt;ISO_FORTRAN_ENV&lt;/code&gt;&amp;rsquo;s &lt;code&gt;STAT_STOPPED_IMAGE&lt;/code&gt; and if the remote image has failed, the value &lt;code&gt;STAT_FAILED_IMAGE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ATOMIC_ADD(ATOM, VALUE)&lt;/code&gt; 원자 적 가치 추가 &lt;var&gt;VAR&lt;/var&gt; 변수에 &lt;var&gt;ATOM&lt;/var&gt; . 경우 &lt;var&gt;STAT&lt;/var&gt; 가 존재하고 호출이 성공, 그것이 존재하고 호출이 실패한 경우,이 양의 값이 할당되는 값 0이 할당된다; 특히, coindexed 대한 &lt;var&gt;ATOM&lt;/var&gt; 원격 화상이 정지 한 경우, 그 값 할당 &lt;code&gt;ISO_FORTRAN_ENV&lt;/code&gt; 의 &lt;code&gt;STAT_STOPPED_IMAGE&lt;/code&gt; 을 원격 화상이 실패한 경우, 값 &lt;code&gt;STAT_FAILED_IMAGE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a0dc7e225209e8c901c3ec95df6c3b75f5882c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ATOMIC_AND(ATOM, VALUE)&lt;/code&gt; atomically defines &lt;var&gt;ATOM&lt;/var&gt; with the bitwise AND between the values of &lt;var&gt;ATOM&lt;/var&gt; and &lt;var&gt;VALUE&lt;/var&gt;. When &lt;var&gt;STAT&lt;/var&gt; is present and the invocation was successful, it is assigned the value 0. If it is present and the invocation has failed, it is assigned a positive value; in particular, for a coindexed &lt;var&gt;ATOM&lt;/var&gt;, if the remote image has stopped, it is assigned the value of &lt;code&gt;ISO_FORTRAN_ENV&lt;/code&gt;&amp;rsquo;s &lt;code&gt;STAT_STOPPED_IMAGE&lt;/code&gt; and if the remote image has failed, the value &lt;code&gt;STAT_FAILED_IMAGE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ATOMIC_AND(ATOM, VALUE)&lt;/code&gt; 는 &lt;var&gt;ATOM&lt;/var&gt; 과 &lt;var&gt;VALUE&lt;/var&gt; 값 사이의 비트 AND를 사용하여 &lt;var&gt;ATOM&lt;/var&gt; 을 원자 적으로 정의합니다 . 경우 &lt;var&gt;STAT&lt;/var&gt; 가 존재하고 호출이 성공, 그것이 존재하고 호출이 실패한 경우,이 양의 값이 할당되는 값 0이 할당된다; 특히, coindexed 대한 &lt;var&gt;ATOM&lt;/var&gt; 원격 화상이 정지 한 경우, 그 값 할당 &lt;code&gt;ISO_FORTRAN_ENV&lt;/code&gt; 의 &lt;code&gt;STAT_STOPPED_IMAGE&lt;/code&gt; 을 원격 화상이 실패한 경우, 값 &lt;code&gt;STAT_FAILED_IMAGE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0bb34aae75b39d386a491cbbf399bab23fcc7562" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ATOMIC_AND(ATOM, VALUE)&lt;/code&gt; atomically defines &lt;var&gt;ATOM&lt;/var&gt; with the bitwise XOR between the values of &lt;var&gt;ATOM&lt;/var&gt; and &lt;var&gt;VALUE&lt;/var&gt;. When &lt;var&gt;STAT&lt;/var&gt; is present and the invocation was successful, it is assigned the value 0. If it is present and the invocation has failed, it is assigned a positive value; in particular, for a coindexed &lt;var&gt;ATOM&lt;/var&gt;, if the remote image has stopped, it is assigned the value of &lt;code&gt;ISO_FORTRAN_ENV&lt;/code&gt;&amp;rsquo;s &lt;code&gt;STAT_STOPPED_IMAGE&lt;/code&gt; and if the remote image has failed, the value &lt;code&gt;STAT_FAILED_IMAGE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ATOMIC_AND(ATOM, VALUE)&lt;/code&gt; 는 &lt;var&gt;ATOM&lt;/var&gt; 과 &lt;var&gt;VALUE&lt;/var&gt; 사이의 비트 XOR로 &lt;var&gt;ATOM&lt;/var&gt; 을 원자 적으로 정의합니다 . 경우 &lt;var&gt;STAT&lt;/var&gt; 가 존재하고 호출이 성공, 그것이 존재하고 호출이 실패한 경우,이 양의 값이 할당되는 값 0이 할당된다; 특히, coindexed 대한 &lt;var&gt;ATOM&lt;/var&gt; 원격 화상이 정지 한 경우, 그 값 할당 &lt;code&gt;ISO_FORTRAN_ENV&lt;/code&gt; 의 &lt;code&gt;STAT_STOPPED_IMAGE&lt;/code&gt; 을 원격 화상이 실패한 경우, 값 &lt;code&gt;STAT_FAILED_IMAGE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6e831dc67cf7f1f1b9f22f342a75c3e62a8d0fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ATOMIC_AND(ATOM, VALUE)&lt;/code&gt; atomically stores the value of &lt;var&gt;ATOM&lt;/var&gt; in &lt;var&gt;OLD&lt;/var&gt; and defines &lt;var&gt;ATOM&lt;/var&gt; with the bitwise AND between the values of &lt;var&gt;ATOM&lt;/var&gt; and &lt;var&gt;VALUE&lt;/var&gt;. When &lt;var&gt;STAT&lt;/var&gt; is present and the invocation was successful, it is assigned the value 0. If it is present and the invocation has failed, it is assigned a positive value; in particular, for a coindexed &lt;var&gt;ATOM&lt;/var&gt;, if the remote image has stopped, it is assigned the value of &lt;code&gt;ISO_FORTRAN_ENV&lt;/code&gt;&amp;rsquo;s &lt;code&gt;STAT_STOPPED_IMAGE&lt;/code&gt; and if the remote image has failed, the value &lt;code&gt;STAT_FAILED_IMAGE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ATOMIC_AND(ATOM, VALUE)&lt;/code&gt; 원자 적 가치 저장 &lt;var&gt;ATOM&lt;/var&gt; 에 &lt;var&gt;OLD&lt;/var&gt; 및 정의 &lt;var&gt;ATOM&lt;/var&gt; 비트 단위로 AND 값 사이 &lt;var&gt;ATOM&lt;/var&gt; 및 &lt;var&gt;VALUE&lt;/var&gt; 를 . 경우 &lt;var&gt;STAT&lt;/var&gt; 가 존재하고 호출이 성공, 그것이 존재하고 호출이 실패한 경우,이 양의 값이 할당되는 값 0이 할당된다; 특히, coindexed 대한 &lt;var&gt;ATOM&lt;/var&gt; 원격 화상이 정지 한 경우, 그 값 할당 &lt;code&gt;ISO_FORTRAN_ENV&lt;/code&gt; 의 &lt;code&gt;STAT_STOPPED_IMAGE&lt;/code&gt; 을 원격 화상이 실패한 경우, 값 &lt;code&gt;STAT_FAILED_IMAGE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7384f5a5dc8b0dc6f4eb13493a87815032dbdb75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ATOMIC_CAS&lt;/code&gt; compares the variable &lt;var&gt;ATOM&lt;/var&gt; with the value of &lt;var&gt;COMPARE&lt;/var&gt;; if the value is the same, &lt;var&gt;ATOM&lt;/var&gt; is set to the value of &lt;var&gt;NEW&lt;/var&gt;. Additionally, &lt;var&gt;OLD&lt;/var&gt; is set to the value of &lt;var&gt;ATOM&lt;/var&gt; that was used for the comparison. When &lt;var&gt;STAT&lt;/var&gt; is present and the invocation was successful, it is assigned the value 0. If it is present and the invocation has failed, it is assigned a positive value; in particular, for a coindexed &lt;var&gt;ATOM&lt;/var&gt;, if the remote image has stopped, it is assigned the value of &lt;code&gt;ISO_FORTRAN_ENV&lt;/code&gt;&amp;rsquo;s &lt;code&gt;STAT_STOPPED_IMAGE&lt;/code&gt; and if the remote image has failed, the value &lt;code&gt;STAT_FAILED_IMAGE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ATOMIC_CAS&lt;/code&gt; 는 변수 &lt;var&gt;ATOM&lt;/var&gt; 을 &lt;var&gt;COMPARE&lt;/var&gt; 값과 비교합니다 . 값이 동일하면 &lt;var&gt;ATOM&lt;/var&gt; 이 &lt;var&gt;NEW&lt;/var&gt; 값으로 설정됩니다 . 또한 &lt;var&gt;OLD&lt;/var&gt; 는 비교에 사용 된 &lt;var&gt;ATOM&lt;/var&gt; 값으로 설정됩니다 . 경우 &lt;var&gt;STAT&lt;/var&gt; 가 존재하고 호출이 성공, 그것이 존재하고 호출이 실패한 경우,이 양의 값이 할당되는 값 0이 할당된다; 특히, coindexed 대한 &lt;var&gt;ATOM&lt;/var&gt; 원격 화상이 정지되면, 그 값 할당 &lt;code&gt;ISO_FORTRAN_ENV&lt;/code&gt; 의 &lt;code&gt;STAT_STOPPED_IMAGE&lt;/code&gt; 원격 화상이 실패한 경우, 값 &lt;code&gt;STAT_FAILED_IMAGE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a0b1b815f57797d56b4aed99b81829c59985376" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ATOMIC_DEFINE(ATOM, VALUE)&lt;/code&gt; atomically assigns the value of the variable &lt;var&gt;ATOM&lt;/var&gt; to &lt;var&gt;VALUE&lt;/var&gt;. When &lt;var&gt;STAT&lt;/var&gt; is present and the invocation was successful, it is assigned the value 0. If it is present and the invocation has failed, it is assigned a positive value; in particular, for a coindexed &lt;var&gt;ATOM&lt;/var&gt;, if the remote image has stopped, it is assigned the value of &lt;code&gt;ISO_FORTRAN_ENV&lt;/code&gt;&amp;rsquo;s &lt;code&gt;STAT_STOPPED_IMAGE&lt;/code&gt; and if the remote image has failed, the value &lt;code&gt;STAT_FAILED_IMAGE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ATOMIC_DEFINE(ATOM, VALUE)&lt;/code&gt; 원자 적 변수의 값을 할당 &lt;var&gt;ATOM&lt;/var&gt; 에 &lt;var&gt;VALUE&lt;/var&gt; 를 . 경우 &lt;var&gt;STAT&lt;/var&gt; 가 존재하고 호출이 성공, 그것이 존재하고 호출이 실패한 경우,이 양의 값이 할당되는 값 0이 할당된다; 특히, coindexed 대한 &lt;var&gt;ATOM&lt;/var&gt; 원격 화상이 정지 한 경우, 그 값 할당 &lt;code&gt;ISO_FORTRAN_ENV&lt;/code&gt; 의 &lt;code&gt;STAT_STOPPED_IMAGE&lt;/code&gt; 을 원격 화상이 실패한 경우, 값 &lt;code&gt;STAT_FAILED_IMAGE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84dc70d78578a5e9032dc4c07ca720def0cf619e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ATOMIC_DEFINE(ATOM, VALUE)&lt;/code&gt; defines the variable &lt;var&gt;ATOM&lt;/var&gt; with the value &lt;var&gt;VALUE&lt;/var&gt; atomically. When &lt;var&gt;STAT&lt;/var&gt; is present and the invocation was successful, it is assigned the value 0. If it is present and the invocation has failed, it is assigned a positive value; in particular, for a coindexed &lt;var&gt;ATOM&lt;/var&gt;, if the remote image has stopped, it is assigned the value of &lt;code&gt;ISO_FORTRAN_ENV&lt;/code&gt;&amp;rsquo;s &lt;code&gt;STAT_STOPPED_IMAGE&lt;/code&gt; and if the remote image has failed, the value &lt;code&gt;STAT_FAILED_IMAGE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ATOMIC_DEFINE(ATOM, VALUE)&lt;/code&gt; 변수의 정의 &lt;var&gt;ATOM&lt;/var&gt; 값과 &lt;var&gt;VALUE&lt;/var&gt; 극히 미세하게한다. 경우 &lt;var&gt;STAT&lt;/var&gt; 가 존재하고 호출이 성공, 그것이 존재하고 호출이 실패한 경우,이 양의 값이 할당되는 값 0이 할당된다; 특히, coindexed 대한 &lt;var&gt;ATOM&lt;/var&gt; 원격 화상이 정지 한 경우, 그 값 할당 &lt;code&gt;ISO_FORTRAN_ENV&lt;/code&gt; 의 &lt;code&gt;STAT_STOPPED_IMAGE&lt;/code&gt; 을 원격 화상이 실패한 경우, 값 &lt;code&gt;STAT_FAILED_IMAGE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="badab29c4af731a8db3167f97c1e72b091bae36b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ATOMIC_FETCH_ADD(ATOM, VALUE, OLD)&lt;/code&gt; atomically stores the value of &lt;var&gt;ATOM&lt;/var&gt; in &lt;var&gt;OLD&lt;/var&gt; and adds the value of &lt;var&gt;VAR&lt;/var&gt; to the variable &lt;var&gt;ATOM&lt;/var&gt;. When &lt;var&gt;STAT&lt;/var&gt; is present and the invocation was successful, it is assigned the value 0. If it is present and the invocation has failed, it is assigned a positive value; in particular, for a coindexed &lt;var&gt;ATOM&lt;/var&gt;, if the remote image has stopped, it is assigned the value of &lt;code&gt;ISO_FORTRAN_ENV&lt;/code&gt;&amp;rsquo;s &lt;code&gt;STAT_STOPPED_IMAGE&lt;/code&gt; and if the remote image has failed, the value &lt;code&gt;STAT_FAILED_IMAGE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ATOMIC_FETCH_ADD(ATOM, VALUE, OLD)&lt;/code&gt; 원자 적 가치 저장 &lt;var&gt;ATOM&lt;/var&gt; 에서 &lt;var&gt;OLD&lt;/var&gt; 및 값 추가 &lt;var&gt;VAR&lt;/var&gt; 변수의 발 &lt;var&gt;ATOM&lt;/var&gt; . 경우 &lt;var&gt;STAT&lt;/var&gt; 가 존재하고 호출이 성공, 그것이 존재하고 호출이 실패한 경우,이 양의 값이 할당되는 값 0이 할당된다; 특히, coindexed 대한 &lt;var&gt;ATOM&lt;/var&gt; 원격 화상이 정지 한 경우, 그 값 할당 &lt;code&gt;ISO_FORTRAN_ENV&lt;/code&gt; 의 &lt;code&gt;STAT_STOPPED_IMAGE&lt;/code&gt; 을 원격 화상이 실패한 경우, 값 &lt;code&gt;STAT_FAILED_IMAGE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47aa3defa61922f60213f14fb0dfe895d793dd88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ATOMIC_INT_KIND&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ATOMIC_INT_KIND&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="ac02760464e8fdea6ba6bb89c90608c4d2800f47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ATOMIC_LOGICAL_KIND&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ATOMIC_LOGICAL_KIND&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="4b99a01faaad0428b609dbc7917a653907a30a2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ATOMIC_OR(ATOM, VALUE)&lt;/code&gt; atomically defines &lt;var&gt;ATOM&lt;/var&gt; with the bitwise AND between the values of &lt;var&gt;ATOM&lt;/var&gt; and &lt;var&gt;VALUE&lt;/var&gt;. When &lt;var&gt;STAT&lt;/var&gt; is present and the invocation was successful, it is assigned the value 0. If it is present and the invocation has failed, it is assigned a positive value; in particular, for a coindexed &lt;var&gt;ATOM&lt;/var&gt;, if the remote image has stopped, it is assigned the value of &lt;code&gt;ISO_FORTRAN_ENV&lt;/code&gt;&amp;rsquo;s &lt;code&gt;STAT_STOPPED_IMAGE&lt;/code&gt; and if the remote image has failed, the value &lt;code&gt;STAT_FAILED_IMAGE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ATOMIC_OR(ATOM, VALUE)&lt;/code&gt; 는 &lt;var&gt;ATOM&lt;/var&gt; 과 &lt;var&gt;VALUE&lt;/var&gt; 값 사이의 비트 AND를 사용하여 &lt;var&gt;ATOM&lt;/var&gt; 을 원자 적으로 정의합니다 . 경우 &lt;var&gt;STAT&lt;/var&gt; 가 존재하고 호출이 성공, 그것이 존재하고 호출이 실패한 경우,이 양의 값이 할당되는 값 0이 할당된다; 특히, coindexed 대한 &lt;var&gt;ATOM&lt;/var&gt; 원격 화상이 정지 한 경우, 그 값 할당 &lt;code&gt;ISO_FORTRAN_ENV&lt;/code&gt; 의 &lt;code&gt;STAT_STOPPED_IMAGE&lt;/code&gt; 을 원격 화상이 실패한 경우, 값 &lt;code&gt;STAT_FAILED_IMAGE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75839c8391c3b86e17e3d3e240949d853692601a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ATOMIC_OR(ATOM, VALUE)&lt;/code&gt; atomically stores the value of &lt;var&gt;ATOM&lt;/var&gt; in &lt;var&gt;OLD&lt;/var&gt; and defines &lt;var&gt;ATOM&lt;/var&gt; with the bitwise OR between the values of &lt;var&gt;ATOM&lt;/var&gt; and &lt;var&gt;VALUE&lt;/var&gt;. When &lt;var&gt;STAT&lt;/var&gt; is present and the invocation was successful, it is assigned the value 0. If it is present and the invocation has failed, it is assigned a positive value; in particular, for a coindexed &lt;var&gt;ATOM&lt;/var&gt;, if the remote image has stopped, it is assigned the value of &lt;code&gt;ISO_FORTRAN_ENV&lt;/code&gt;&amp;rsquo;s &lt;code&gt;STAT_STOPPED_IMAGE&lt;/code&gt; and if the remote image has failed, the value &lt;code&gt;STAT_FAILED_IMAGE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ATOMIC_OR(ATOM, VALUE)&lt;/code&gt; 원자 적 가치 저장 &lt;var&gt;ATOM&lt;/var&gt; 에 &lt;var&gt;OLD&lt;/var&gt; 및 정의 &lt;var&gt;ATOM&lt;/var&gt; 비트 단위로 OR 값 사이 &lt;var&gt;ATOM&lt;/var&gt; 및 &lt;var&gt;VALUE&lt;/var&gt; 를 . 경우 &lt;var&gt;STAT&lt;/var&gt; 가 존재하고 호출이 성공, 그것이 존재하고 호출이 실패한 경우,이 양의 값이 할당되는 값 0이 할당된다; 특히, coindexed 대한 &lt;var&gt;ATOM&lt;/var&gt; 원격 화상이 정지 한 경우, 그 값 할당 &lt;code&gt;ISO_FORTRAN_ENV&lt;/code&gt; 의 &lt;code&gt;STAT_STOPPED_IMAGE&lt;/code&gt; 을 원격 화상이 실패한 경우, 값 &lt;code&gt;STAT_FAILED_IMAGE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1737969298b5750a81ab8df57d835baba288e484" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ATOMIC_XOR(ATOM, VALUE)&lt;/code&gt; atomically stores the value of &lt;var&gt;ATOM&lt;/var&gt; in &lt;var&gt;OLD&lt;/var&gt; and defines &lt;var&gt;ATOM&lt;/var&gt; with the bitwise XOR between the values of &lt;var&gt;ATOM&lt;/var&gt; and &lt;var&gt;VALUE&lt;/var&gt;. When &lt;var&gt;STAT&lt;/var&gt; is present and the invocation was successful, it is assigned the value 0. If it is present and the invocation has failed, it is assigned a positive value; in particular, for a coindexed &lt;var&gt;ATOM&lt;/var&gt;, if the remote image has stopped, it is assigned the value of &lt;code&gt;ISO_FORTRAN_ENV&lt;/code&gt;&amp;rsquo;s &lt;code&gt;STAT_STOPPED_IMAGE&lt;/code&gt; and if the remote image has failed, the value &lt;code&gt;STAT_FAILED_IMAGE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ATOMIC_XOR(ATOM, VALUE)&lt;/code&gt; 원자 적 가치 저장 &lt;var&gt;ATOM&lt;/var&gt; 에 &lt;var&gt;OLD&lt;/var&gt; 및 정의 &lt;var&gt;ATOM&lt;/var&gt; 의 값의 비트와 XOR &lt;var&gt;ATOM&lt;/var&gt; 및 &lt;var&gt;VALUE&lt;/var&gt; 를 . 경우 &lt;var&gt;STAT&lt;/var&gt; 가 존재하고 호출이 성공, 그것이 존재하고 호출이 실패한 경우,이 양의 값이 할당되는 값 0이 할당된다; 특히, coindexed 대한 &lt;var&gt;ATOM&lt;/var&gt; 원격 화상이 정지 한 경우, 그 값 할당 &lt;code&gt;ISO_FORTRAN_ENV&lt;/code&gt; 의 &lt;code&gt;STAT_STOPPED_IMAGE&lt;/code&gt; 을 원격 화상이 실패한 경우, 값 &lt;code&gt;STAT_FAILED_IMAGE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20eb8c99f8d6bf674e4ff4eb96c5ccf3b8e1ce81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BACKTRACE&lt;/code&gt; shows a backtrace at an arbitrary place in user code. Program execution continues normally afterwards. The backtrace information is printed to the unit corresponding to &lt;code&gt;ERROR_UNIT&lt;/code&gt; in &lt;code&gt;ISO_FORTRAN_ENV&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BACKTRACE&lt;/code&gt; 는 사용자 코드의 임의 위치에 역 추적을 표시합니다. 그 후 프로그램 실행이 정상적으로 계속됩니다. 역 추적 정보에 대응하는 단위로 인쇄 &lt;code&gt;ERROR_UNIT&lt;/code&gt; 에 &lt;code&gt;ISO_FORTRAN_ENV&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="659e335362c9d3454aea450b5403d6be25ddd52f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BESSEL_J0(X)&lt;/code&gt; computes the Bessel function of the first kind of order 0 of &lt;var&gt;X&lt;/var&gt;. This function is available under the name &lt;code&gt;BESJ0&lt;/code&gt; as a GNU extension.</source>
          <target state="translated">&lt;code&gt;BESSEL_J0(X)&lt;/code&gt; 순으로 0 제 1 종의 베셀 함수 계산 &lt;var&gt;X&lt;/var&gt; 를 . 이 기능은 &lt;code&gt;BESJ0&lt;/code&gt; 이라는 이름 으로 GNU 확장명으로 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="7aaa5865bd98aa9d9e1716c45ccc8d2d0b886a63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BESSEL_J1(X)&lt;/code&gt; computes the Bessel function of the first kind of order 1 of &lt;var&gt;X&lt;/var&gt;. This function is available under the name &lt;code&gt;BESJ1&lt;/code&gt; as a GNU extension.</source>
          <target state="translated">&lt;code&gt;BESSEL_J1(X)&lt;/code&gt; 순서 (1)의 제 1 종의 베셀 함수 계산 &lt;var&gt;X&lt;/var&gt; 를 . 이 기능은 &lt;code&gt;BESJ1&lt;/code&gt; 이라는 이름 으로 GNU 확장명으로 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="63c7d9044482ee1176a4d8265e7a200ef3a48e32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BESSEL_JN(N, X)&lt;/code&gt; computes the Bessel function of the first kind of order &lt;var&gt;N&lt;/var&gt; of &lt;var&gt;X&lt;/var&gt;. This function is available under the name &lt;code&gt;BESJN&lt;/code&gt; as a GNU extension. If &lt;var&gt;N&lt;/var&gt; and &lt;var&gt;X&lt;/var&gt; are arrays, their ranks and shapes shall conform.</source>
          <target state="translated">&lt;code&gt;BESSEL_JN(N, X)&lt;/code&gt; 순서의 제 1 종의 베셀 함수 계산 &lt;var&gt;N&lt;/var&gt; 의 &lt;var&gt;X&lt;/var&gt; 를 . 이 기능은 &lt;code&gt;BESJN&lt;/code&gt; 이라는 이름 으로 GNU 확장명으로 사용 가능합니다. 경우 &lt;var&gt;N&lt;/var&gt; 과 &lt;var&gt;X&lt;/var&gt; 가 배열 인, 자신의 계급과 모양에 적합하여야한다.</target>
        </trans-unit>
        <trans-unit id="04867aa960c1b4d13f57c31d5e164c7ffb029711" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BESSEL_JN(N1, N2, X)&lt;/code&gt; returns an array with the Bessel functions of the first kind of the orders &lt;var&gt;N1&lt;/var&gt; to &lt;var&gt;N2&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;BESSEL_JN(N1, N2, X)&lt;/code&gt; 는 첫 번째 종류의 차수 &lt;var&gt;N1&lt;/var&gt; ~ &lt;var&gt;N2&lt;/var&gt; 의 베셀 함수가 포함 된 배열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8d82654428ebc275a73195c1552f7e95652f2347" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BESSEL_Y0(X)&lt;/code&gt; computes the Bessel function of the second kind of order 0 of &lt;var&gt;X&lt;/var&gt;. This function is available under the name &lt;code&gt;BESY0&lt;/code&gt; as a GNU extension.</source>
          <target state="translated">&lt;code&gt;BESSEL_Y0(X)&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 의 차수 0의 두 번째 종류의 Bessel 함수를 계산합니다 . 이 기능은 &lt;code&gt;BESY0&lt;/code&gt; 라는 이름 으로 GNU 확장명으로 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="d6b689a62331c029c9b39065e5ea97626e6866db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BESSEL_Y1(X)&lt;/code&gt; computes the Bessel function of the second kind of order 1 of &lt;var&gt;X&lt;/var&gt;. This function is available under the name &lt;code&gt;BESY1&lt;/code&gt; as a GNU extension.</source>
          <target state="translated">&lt;code&gt;BESSEL_Y1(X)&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 의 차수 1의 두 번째 Bessel 함수를 계산합니다 . 이 기능은 &lt;code&gt;BESY1&lt;/code&gt; 이라는 이름 으로 GNU 확장명으로 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="a30ad80dfaa4d2f776b2dd3489f202f27df727df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BESSEL_YN(N, X)&lt;/code&gt; computes the Bessel function of the second kind of order &lt;var&gt;N&lt;/var&gt; of &lt;var&gt;X&lt;/var&gt;. This function is available under the name &lt;code&gt;BESYN&lt;/code&gt; as a GNU extension. If &lt;var&gt;N&lt;/var&gt; and &lt;var&gt;X&lt;/var&gt; are arrays, their ranks and shapes shall conform.</source>
          <target state="translated">&lt;code&gt;BESSEL_YN(N, X)&lt;/code&gt; 순서의 제 2 종의 베셀 함수 계산 &lt;var&gt;N&lt;/var&gt; 의 &lt;var&gt;X&lt;/var&gt; 를 . 이 기능은 &lt;code&gt;BESYN&lt;/code&gt; 이라는 이름 으로 GNU 확장명으로 사용 가능합니다. 경우 &lt;var&gt;N&lt;/var&gt; 과 &lt;var&gt;X&lt;/var&gt; 가 배열 인, 자신의 계급과 모양에 적합하여야한다.</target>
        </trans-unit>
        <trans-unit id="9754fff74222b86d940ae858f3ceb5b7486cdaba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BESSEL_YN(N1, N2, X)&lt;/code&gt; returns an array with the Bessel functions of the first kind of the orders &lt;var&gt;N1&lt;/var&gt; to &lt;var&gt;N2&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;BESSEL_YN(N1, N2, X)&lt;/code&gt; 는 첫 번째 종류의 차수 &lt;var&gt;N1&lt;/var&gt; ~ &lt;var&gt;N2&lt;/var&gt; 의 Bessel 함수가 포함 된 배열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9e304f524feb8eea3b3d9ab19f777c6f67f968a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BIG_ENDIAN&lt;/code&gt; Use the big-endian format for unformatted files.</source>
          <target state="translated">&lt;code&gt;BIG_ENDIAN&lt;/code&gt; 형식화되지 않은 파일에는 빅 엔디안 형식을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="52f8d22c9b4b7cb0ae2c48e678c4a285a4b7882b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BIT_SIZE(I)&lt;/code&gt; returns the number of bits (integer precision plus sign bit) represented by the type of &lt;var&gt;I&lt;/var&gt;. The result of &lt;code&gt;BIT_SIZE(I)&lt;/code&gt; is independent of the actual value of &lt;var&gt;I&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;BIT_SIZE(I)&lt;/code&gt; 는 &lt;var&gt;I&lt;/var&gt; 유형으로 표시되는 비트 수 (정수 정밀도 + 부호 비트 )를 반환합니다 . &lt;code&gt;BIT_SIZE(I)&lt;/code&gt; 의 결과 는 실제 &lt;var&gt;I&lt;/var&gt; 값과 무관합니다 .</target>
        </trans-unit>
        <trans-unit id="13fcfcc599d81093b9a77dfbcea5690b5ebe39e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BTEST(I,POS)&lt;/code&gt; returns logical &lt;code&gt;.TRUE.&lt;/code&gt; if the bit at &lt;var&gt;POS&lt;/var&gt; in &lt;var&gt;I&lt;/var&gt; is set. The counting of the bits starts at 0.</source>
          <target state="translated">&lt;code&gt;BTEST(I,POS)&lt;/code&gt; 는 논리 &lt;code&gt;.TRUE.&lt;/code&gt; 반환합니다 . &lt;var&gt;POS&lt;/var&gt; 의 비트 가 &lt;var&gt;I&lt;/var&gt; 로 설정된 경우. 비트 수는 0에서 시작합니다.</target>
        </trans-unit>
        <trans-unit id="ccbc6784f2f320f451f7ff95086351ff1f03eb6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CALL CTIME(TIME, RESULT)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CALL CTIME(TIME, RESULT)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e6648c1259a68c5c964590d1df67d71043b738d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CALL DTIME(VALUES, TIME)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CALL DTIME(VALUES, TIME)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e281d31792e1668ff16bc3948630a6e717f7c6ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CALL ETIME(VALUES, TIME)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CALL ETIME(VALUES, TIME)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc6bdd5db31f6917d22e92647e11989b77f484a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CALL FDATE(DATE)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CALL FDATE(DATE)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92e493c3c794dc504b480c5e2a668ce5c3f169de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CDECL&lt;/code&gt; &amp;ndash; standard C calling convention</source>
          <target state="translated">&lt;code&gt;CDECL&lt;/code&gt; &amp;ndash; 표준 C 호출 규칙</target>
        </trans-unit>
        <trans-unit id="124a8cd620bbc9aa59493ce34ae4cd513cbc8b04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CEILING(A)&lt;/code&gt; returns the least integer greater than or equal to &lt;var&gt;A&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;CEILING(A)&lt;/code&gt; 동일하거나보다 하나 큰 정수를 반환 &lt;var&gt;A&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="0af7b39055d3651c9a9bcb1ffa4a6c8570ea8f53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CHAR(I [, KIND])&lt;/code&gt; returns the character represented by the integer &lt;var&gt;I&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;CHAR(I [, KIND])&lt;/code&gt; 는 정수 &lt;var&gt;I&lt;/var&gt; 로 표시되는 문자를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="d30bac89def6fdbf2ba423f194dd791fd09de3a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CHARACTER_KINDS&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;CHARACTER_KINDS&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="5b13524374bc75569386f908ec58e4d41fc41720" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CHARACTER_STORAGE_SIZE&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;CHARACTER_STORAGE_SIZE&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="566384a002c40bbb283845810f269c7053ce9fb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CHMOD&lt;/code&gt; as function:</source>
          <target state="translated">&lt;code&gt;CHMOD&lt;/code&gt; 기능으로서의 CHMOD :</target>
        </trans-unit>
        <trans-unit id="d17b8e1263f83427a25c5fc2211dd8ab6cf4683b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CHMOD&lt;/code&gt; as subroutine</source>
          <target state="translated">&lt;code&gt;CHMOD&lt;/code&gt; 서브 루틴으로서의 CHMOD</target>
        </trans-unit>
        <trans-unit id="8c3c7765b88ba08896022119831797d5edb30009" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CHMOD&lt;/code&gt; changes the permissions of a file.</source>
          <target state="translated">&lt;code&gt;CHMOD&lt;/code&gt; 는 파일의 권한을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="40b90d66f307635ac3f99b2c593ab0b252bb34c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CMPLX(X [, Y [, KIND]])&lt;/code&gt; returns a complex number where &lt;var&gt;X&lt;/var&gt; is converted to the real component. If &lt;var&gt;Y&lt;/var&gt; is present it is converted to the imaginary component. If &lt;var&gt;Y&lt;/var&gt; is not present then the imaginary component is set to 0.0. If &lt;var&gt;X&lt;/var&gt; is complex then &lt;var&gt;Y&lt;/var&gt; must not be present.</source>
          <target state="translated">&lt;code&gt;CMPLX(X [, Y [, KIND]])&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 가 실수 성분으로 변환 되는 복소수를 반환합니다 . 경우 &lt;var&gt;Y&lt;/var&gt; 는 존재는 허수 성분으로 변환된다. 경우 &lt;var&gt;Y&lt;/var&gt; 가 존재하지 않는 그 허수 성분은 0.0으로 설정된다. 경우 &lt;var&gt;X&lt;/var&gt; 가 복잡 다음 &lt;var&gt;Y&lt;/var&gt; 는 존재하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="d144ab71a589686cf1eaa1fa702ccde2957c2dd0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COMMAND_ARGUMENT_COUNT&lt;/code&gt; returns the number of arguments passed on the command line when the containing program was invoked.</source>
          <target state="translated">&lt;code&gt;COMMAND_ARGUMENT_COUNT&lt;/code&gt; 는 포함 프로그램이 호출 될 때 명령 행에 전달 된 인수 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c4b214687809069dfa670afa43a9a5c464cdcd75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COMPILER_OPTIONS&lt;/code&gt; returns a string with the options used for compiling.</source>
          <target state="translated">&lt;code&gt;COMPILER_OPTIONS&lt;/code&gt; 는 컴파일에 사용되는 옵션이 포함 된 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d38461de68097c91b0516e639e92c90dd44d3f2b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COMPILER_VERSION&lt;/code&gt; returns a string with the name and the version of the compiler.</source>
          <target state="translated">&lt;code&gt;COMPILER_VERSION&lt;/code&gt; 은 이름과 컴파일러 버전이 포함 된 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="77c930124287503d64d3b3fbe229281d081bb921" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COMPLEX(X, Y)&lt;/code&gt; returns a complex number where &lt;var&gt;X&lt;/var&gt; is converted to the real component and &lt;var&gt;Y&lt;/var&gt; is converted to the imaginary component.</source>
          <target state="translated">&lt;code&gt;COMPLEX(X, Y)&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 가 실수 성분 으로 변환 되고 &lt;var&gt;Y&lt;/var&gt; 가 허수 성분으로 변환 되는 복소수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e30c9cdd8dca0f1e74a0328f75c41f54f7d69535" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CONJG(Z)&lt;/code&gt; returns the conjugate of &lt;var&gt;Z&lt;/var&gt;. If &lt;var&gt;Z&lt;/var&gt; is &lt;code&gt;(x, y)&lt;/code&gt; then the result is &lt;code&gt;(x, -y)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;CONJG(Z)&lt;/code&gt; 의 켤레 리턴 &lt;var&gt;Z&lt;/var&gt; 를 . 경우 &lt;var&gt;Z&lt;/var&gt; 는 이고 &lt;code&gt;(x, y)&lt;/code&gt; 그 결과가 &lt;code&gt;(x, -y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7cc562e4a8eb02ab44d32005920e59dfebb7144" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CONVERT&lt;/code&gt; works between big- and little-endian for &lt;code&gt;INTEGER&lt;/code&gt; values of all supported kinds and for &lt;code&gt;REAL&lt;/code&gt; on IEEE systems of kinds 4 and 8. Conversion between different &amp;ldquo;extended double&amp;rdquo; types on different architectures such as m68k and x86_64, which GNU Fortran supports as &lt;code&gt;REAL(KIND=10)&lt;/code&gt; and &lt;code&gt;REAL(KIND=16)&lt;/code&gt;, will probably not work.</source>
          <target state="translated">&lt;code&gt;CONVERT&lt;/code&gt; 는 지원되는 모든 종류의 &lt;code&gt;INTEGER&lt;/code&gt; 값과 종류 4 및 8의 IEEE 시스템 에서 &lt;code&gt;REAL&lt;/code&gt; 에 대해 빅 엔디안과 리틀 엔디안간에 작동 합니다. GNU Fortran이 지원하는 m68k 및 x86_64와 같은 다른 아키텍처에서 서로 다른 &quot;확장 이중&quot;유형 간 변환 &lt;code&gt;REAL(KIND=10)&lt;/code&gt; 및 &lt;code&gt;REAL(KIND=16)&lt;/code&gt; 은 아마 작동하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="6799fe288e06ac26d7f4bfa0835b4e2d473d8c72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CONVERT='BIG_ENDIAN'&lt;/code&gt; Use the big-endian representation for unformatted files.</source>
          <target state="translated">&lt;code&gt;CONVERT='BIG_ENDIAN'&lt;/code&gt; 형식화되지 않은 파일에는 빅 엔디안 표현을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="082812e13e90245b14a200f682ef8691e731cb63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CONVERT='LITTLE_ENDIAN'&lt;/code&gt; Use the little-endian representation for unformatted files.</source>
          <target state="translated">&lt;code&gt;CONVERT='LITTLE_ENDIAN'&lt;/code&gt; 형식화되지 않은 파일에 리틀 엔디안 표현을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="16040a897876bfedb8446618c5b692f6a3647265" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CONVERT='NATIVE'&lt;/code&gt; Use the native format. This is the default.</source>
          <target state="translated">&lt;code&gt;CONVERT='NATIVE'&lt;/code&gt; 기본 형식을 사용하십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="aad1080486dde49c310c0d93133907770f4246c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CONVERT='SWAP'&lt;/code&gt; Swap between little- and big-endian.</source>
          <target state="translated">&lt;code&gt;CONVERT='SWAP'&lt;/code&gt; 리틀 엔디안과 빅 엔디안간에 교환합니다.</target>
        </trans-unit>
        <trans-unit id="bd679be58dd4540d1566ea52dc8f6f0bfa20f420" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COS(X)&lt;/code&gt; computes the cosine of &lt;var&gt;X&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;COS(X)&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 의 코사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="d33efdd882ee8cb8c9afb0f6283c5a3085f1b2d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COSD(X)&lt;/code&gt; computes the cosine of &lt;var&gt;X&lt;/var&gt; in degrees.</source>
          <target state="translated">&lt;code&gt;COSD(X)&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 의 코사인을 도 단위로 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="584d44120fa9a02407fa0d3537948e8225bec9ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COSH(X)&lt;/code&gt; computes the hyperbolic cosine of &lt;var&gt;X&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;COSH(X)&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 의 쌍곡 코사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="901bc02a693ed9382891c54e86296c3414d0b775" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COTAN(X)&lt;/code&gt; computes the cotangent of &lt;var&gt;X&lt;/var&gt;. Equivalent to &lt;code&gt;COS(x)&lt;/code&gt; divided by &lt;code&gt;SIN(x)&lt;/code&gt;, or &lt;code&gt;1 / TAN(x)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;COTAN(X)&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 의 코탄젠트를 계산합니다 . 상당 &lt;code&gt;COS(x)&lt;/code&gt; 으로 나눈 &lt;code&gt;SIN(x)&lt;/code&gt; , 또는 &lt;code&gt;1 / TAN(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d4c293355c942859aff0b914ce4e56d62e3ce37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COTAND(X)&lt;/code&gt; computes the cotangent of &lt;var&gt;X&lt;/var&gt; in degrees. Equivalent to &lt;code&gt;COSD(x)&lt;/code&gt; divided by &lt;code&gt;SIND(x)&lt;/code&gt;, or &lt;code&gt;1 / TAND(x)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;COTAND(X)&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 의 코탄젠트를 도 단위로 계산합니다 . 상당 &lt;code&gt;COSD(x)&lt;/code&gt; 으로 나눈 &lt;code&gt;SIND(x)&lt;/code&gt; , 또는 &lt;code&gt;1 / TAND(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b9835670c0fd2b2334e0ec10b09873c3b93af2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CO_BROADCAST&lt;/code&gt; copies the value of argument &lt;var&gt;A&lt;/var&gt; on the image with image index &lt;code&gt;SOURCE_IMAGE&lt;/code&gt; to all images in the current team. &lt;var&gt;A&lt;/var&gt; becomes defined as if by intrinsic assignment. If the execution was successful and &lt;var&gt;STAT&lt;/var&gt; is present, it is assigned the value zero. If the execution failed, &lt;var&gt;STAT&lt;/var&gt; gets assigned a nonzero value and, if present, &lt;var&gt;ERRMSG&lt;/var&gt; gets assigned a value describing the occurred error.</source>
          <target state="translated">&lt;code&gt;CO_BROADCAST&lt;/code&gt; 는 이미지 색인이 &lt;code&gt;SOURCE_IMAGE&lt;/code&gt; 인 이미지 의 인수 &lt;var&gt;A&lt;/var&gt; 값을 현재 팀의 모든 이미지로 복사합니다 . &lt;var&gt;A&lt;/var&gt; 는 고유 할당에 의해 정의됩니다. 실행이 성공하고 &lt;var&gt;STAT&lt;/var&gt; 가 있으면 값 0이 할당됩니다. 실행이 실패하면 &lt;var&gt;STAT&lt;/var&gt; 에 0이 아닌 값이 할당되고 존재하는 경우 &lt;var&gt;ERRMSG&lt;/var&gt; 에 발생한 오류를 설명하는 값이 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="828969f39a9589a75e32ef77ef57c6d71a4fe978" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CO_MAX&lt;/code&gt; determines element-wise the maximal value of &lt;var&gt;A&lt;/var&gt; on all images of the current team. If &lt;var&gt;RESULT_IMAGE&lt;/var&gt; is present, the maximum values are returned in &lt;var&gt;A&lt;/var&gt; on the specified image only and the value of &lt;var&gt;A&lt;/var&gt; on the other images become undefined. If &lt;var&gt;RESULT_IMAGE&lt;/var&gt; is not present, the value is returned on all images. If the execution was successful and &lt;var&gt;STAT&lt;/var&gt; is present, it is assigned the value zero. If the execution failed, &lt;var&gt;STAT&lt;/var&gt; gets assigned a nonzero value and, if present, &lt;var&gt;ERRMSG&lt;/var&gt; gets assigned a value describing the occurred error.</source>
          <target state="translated">&lt;code&gt;CO_MAX&lt;/code&gt; 는 현재 팀의 모든 이미지에서 요소 별 &lt;var&gt;A&lt;/var&gt; 의 최대 값을 결정 합니다. 경우 &lt;var&gt;RESULT_IMAGE&lt;/var&gt; 가 존재하는 최대 값을 반환된다 는 지정된 이미지와 값 다른 이미지에 대한이 정의되지해진다. 경우 &lt;var&gt;RESULT_IMAGE&lt;/var&gt; 이 존재하지 않는 값은 모든 이미지에 반환됩니다. 실행이 성공하고 &lt;var&gt;STAT&lt;/var&gt; 가 있으면 값 0이 할당됩니다. 실행이 실패하면 &lt;var&gt;STAT&lt;/var&gt; 에 0이 아닌 값이 할당되고 존재하는 경우 &lt;var&gt;ERRMSG&lt;/var&gt; 에 발생한 오류를 설명하는 값이 할당됩니다. &lt;var&gt;A&lt;/var&gt; &lt;var&gt;A&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="eb084191b0b6dfed9b771e79102673ce8badad3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CO_MIN&lt;/code&gt; determines element-wise the minimal value of &lt;var&gt;A&lt;/var&gt; on all images of the current team. If &lt;var&gt;RESULT_IMAGE&lt;/var&gt; is present, the minimal values are returned in &lt;var&gt;A&lt;/var&gt; on the specified image only and the value of &lt;var&gt;A&lt;/var&gt; on the other images become undefined. If &lt;var&gt;RESULT_IMAGE&lt;/var&gt; is not present, the value is returned on all images. If the execution was successful and &lt;var&gt;STAT&lt;/var&gt; is present, it is assigned the value zero. If the execution failed, &lt;var&gt;STAT&lt;/var&gt; gets assigned a nonzero value and, if present, &lt;var&gt;ERRMSG&lt;/var&gt; gets assigned a value describing the occurred error.</source>
          <target state="translated">&lt;code&gt;CO_MIN&lt;/code&gt; 은 현재 팀의 모든 이미지에서 요소 별 &lt;var&gt;A&lt;/var&gt; 의 최소값을 결정 합니다. 경우 &lt;var&gt;RESULT_IMAGE&lt;/var&gt; 가 존재하고, 최소의 값이 반환된다 는 지정된 이미지와 값 다른 이미지에 대한이 정의되지해진다. 경우 &lt;var&gt;RESULT_IMAGE&lt;/var&gt; 이 존재하지 않는 값은 모든 이미지에 반환됩니다. 실행이 성공하고 &lt;var&gt;STAT&lt;/var&gt; 가 있으면 값 0이 할당됩니다. 실행이 실패하면 &lt;var&gt;STAT&lt;/var&gt; 에 0이 아닌 값이 할당되고 존재하는 경우 &lt;var&gt;ERRMSG&lt;/var&gt; 에 발생한 오류를 설명하는 값이 할당됩니다. &lt;var&gt;A&lt;/var&gt; &lt;var&gt;A&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="f216fb1da44f46994374ab67c6d336abb113c173" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CO_REDUCE&lt;/code&gt; determines element-wise the reduction of the value of &lt;var&gt;A&lt;/var&gt; on all images of the current team. The pure function passed as &lt;var&gt;OPERATOR&lt;/var&gt; is used to pairwise reduce the values of &lt;var&gt;A&lt;/var&gt; by passing either the value of &lt;var&gt;A&lt;/var&gt; of different images or the result values of such a reduction as argument. If &lt;var&gt;A&lt;/var&gt; is an array, the deduction is done element wise. If &lt;var&gt;RESULT_IMAGE&lt;/var&gt; is present, the result values are returned in &lt;var&gt;A&lt;/var&gt; on the specified image only and the value of &lt;var&gt;A&lt;/var&gt; on the other images become undefined. If &lt;var&gt;RESULT_IMAGE&lt;/var&gt; is not present, the value is returned on all images. If the execution was successful and &lt;var&gt;STAT&lt;/var&gt; is present, it is assigned the value zero. If the execution failed, &lt;var&gt;STAT&lt;/var&gt; gets assigned a nonzero value and, if present, &lt;var&gt;ERRMSG&lt;/var&gt; gets assigned a value describing the occurred error.</source>
          <target state="translated">&lt;code&gt;CO_REDUCE&lt;/code&gt; 는 현재 팀의 모든 이미지에서 요소 별 &lt;var&gt;A&lt;/var&gt; 값 감소를 결정 합니다. &lt;var&gt;OPERATOR&lt;/var&gt; 로 전달 된 순수 함수 는 다른 이미지 의 &lt;var&gt;A&lt;/var&gt; 값 또는 이러한 축소 결과 값을 인수 로 전달하여 &lt;var&gt;A&lt;/var&gt; 값을 쌍으로 줄이는 데 사용됩니다 . 경우 &lt;var&gt;A&lt;/var&gt; 는 배열이며, 공제 현명 요소를 수행합니다. 경우 &lt;var&gt;RESULT_IMAGE&lt;/var&gt; 가 존재하고, 그 결과 값이 반환된다 는 지정된 이미지와 값 다른 이미지에 대한이 정의되지해진다. 경우 &lt;var&gt;RESULT_IMAGE&lt;/var&gt; 이 존재하지 않는 값은 모든 이미지에 반환됩니다. 실행이 성공한 경우 &lt;var&gt;A&lt;/var&gt; &lt;var&gt;A&lt;/var&gt; &lt;var&gt;STAT&lt;/var&gt; 가 존재하면 0이 할당됩니다. 실행이 실패하면 &lt;var&gt;STAT&lt;/var&gt; 에 0이 아닌 값이 할당되고 존재하는 경우 &lt;var&gt;ERRMSG&lt;/var&gt; 에 발생한 오류를 설명하는 값이 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="3265bf5e79c689106690cc7a31f644c0e4ff1ab4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CO_SUM&lt;/code&gt; sums up the values of each element of &lt;var&gt;A&lt;/var&gt; on all images of the current team. If &lt;var&gt;RESULT_IMAGE&lt;/var&gt; is present, the summed-up values are returned in &lt;var&gt;A&lt;/var&gt; on the specified image only and the value of &lt;var&gt;A&lt;/var&gt; on the other images become undefined. If &lt;var&gt;RESULT_IMAGE&lt;/var&gt; is not present, the value is returned on all images. If the execution was successful and &lt;var&gt;STAT&lt;/var&gt; is present, it is assigned the value zero. If the execution failed, &lt;var&gt;STAT&lt;/var&gt; gets assigned a nonzero value and, if present, &lt;var&gt;ERRMSG&lt;/var&gt; gets assigned a value describing the occurred error.</source>
          <target state="translated">&lt;code&gt;CO_SUM&lt;/code&gt; 은 현재 팀의 모든 이미지에서 &lt;var&gt;A&lt;/var&gt; 의 각 요소 값을 요약합니다 . 경우 &lt;var&gt;RESULT_IMAGE&lt;/var&gt; 이 존재, 합산해서 값이 반환된다 는 지정된 이미지와 값 다른 이미지에 대한이 정의되지해진다. 경우 &lt;var&gt;RESULT_IMAGE&lt;/var&gt; 이 존재하지 않는 값은 모든 이미지에 반환됩니다. 실행이 성공하고 &lt;var&gt;STAT&lt;/var&gt; 가 있으면 값 0이 할당됩니다. 실행이 실패하면 &lt;var&gt;STAT&lt;/var&gt; 에 0이 아닌 값이 할당되고 존재하는 경우 &lt;var&gt;ERRMSG&lt;/var&gt; 에 발생한 오류를 설명하는 값이 할당됩니다. &lt;var&gt;A&lt;/var&gt; &lt;var&gt;A&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="7fff442d42d15bd45561895d9906b6999497f5f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CSHIFT(ARRAY, SHIFT [, DIM])&lt;/code&gt; performs a circular shift on elements of &lt;var&gt;ARRAY&lt;/var&gt; along the dimension of &lt;var&gt;DIM&lt;/var&gt;. If &lt;var&gt;DIM&lt;/var&gt; is omitted it is taken to be &lt;code&gt;1&lt;/code&gt;. &lt;var&gt;DIM&lt;/var&gt; is a scalar of type &lt;code&gt;INTEGER&lt;/code&gt; in the range of &lt;em&gt;1 \leq DIM \leq n)&lt;/em&gt; where &lt;em&gt;n&lt;/em&gt; is the rank of &lt;var&gt;ARRAY&lt;/var&gt;. If the rank of &lt;var&gt;ARRAY&lt;/var&gt; is one, then all elements of &lt;var&gt;ARRAY&lt;/var&gt; are shifted by &lt;var&gt;SHIFT&lt;/var&gt; places. If rank is greater than one, then all complete rank one sections of &lt;var&gt;ARRAY&lt;/var&gt; along the given dimension are shifted. Elements shifted out one end of each rank one section are shifted back in the other end.</source>
          <target state="translated">&lt;code&gt;CSHIFT(ARRAY, SHIFT [, DIM])&lt;/code&gt; 은 &lt;var&gt;DIM&lt;/var&gt; 의 치수를 따라 &lt;var&gt;ARRAY&lt;/var&gt; 요소에 대해 원형 이동을 수행합니다 . 경우 &lt;var&gt;DIM&lt;/var&gt; 은 생략 그것으로 촬영 &lt;code&gt;1&lt;/code&gt; . &lt;var&gt;DIM&lt;/var&gt; 은 &lt;em&gt;1 \ leq DIM \ leq n)&lt;/em&gt; 범위의 &lt;code&gt;INTEGER&lt;/code&gt; 유형의 스칼라입니다. 여기서 &lt;em&gt;n&lt;/em&gt; 은 &lt;var&gt;ARRAY&lt;/var&gt; 의 순위입니다 . &lt;var&gt;ARRAY&lt;/var&gt; 의 순위 가 1이면 &lt;var&gt;ARRAY&lt;/var&gt; 의 모든 요소 가 &lt;var&gt;SHIFT&lt;/var&gt; 자리 만큼 이동 합니다. 순위가 1보다 크면 &lt;var&gt;ARRAY&lt;/var&gt; 의 전체 섹션 중 하나를 완료합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;주어진 치수를 따라 이동합니다. 각 등급의 한쪽 끝으로 이동 된 요소는 한 섹션이 다른 쪽 끝으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="02a83c5ed7e726456685c031e495b54f38213b9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CTIME&lt;/code&gt; converts a system time value, such as returned by &lt;a href=&quot;time8#TIME8&quot;&gt;TIME8&lt;/a&gt;, to a string. The output will be of the form &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;CTIME&lt;/code&gt; 은 &lt;a href=&quot;time8#TIME8&quot;&gt;TIME8&lt;/a&gt; 에 의해 리턴 된 시스템 시간 값을 문자열 로 변환 합니다. 결과는 '</target>
        </trans-unit>
        <trans-unit id="a065a3e55bdcd38bb8039390a359d00ef36a25ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;C_ASSOCIATED(c_ptr_1[, c_ptr_2])&lt;/code&gt; determines the status of the C pointer &lt;var&gt;c_ptr_1&lt;/var&gt; or if &lt;var&gt;c_ptr_1&lt;/var&gt; is associated with the target &lt;var&gt;c_ptr_2&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;C_ASSOCIATED(c_ptr_1[, c_ptr_2])&lt;/code&gt; 는 C 포인터 &lt;var&gt;c_ptr_1&lt;/var&gt; 의 상태 또는 &lt;var&gt;c_ptr_1&lt;/var&gt; 이 대상 &lt;var&gt;c_ptr_2&lt;/var&gt; 와 연관되어 있는지 여부를 판별 합니다.</target>
        </trans-unit>
        <trans-unit id="4aa008d98a954b17c9b8e1098ea312eac7d4b5e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;C_FUNLOC(x)&lt;/code&gt; determines the C address of the argument.</source>
          <target state="translated">&lt;code&gt;C_FUNLOC(x)&lt;/code&gt; 는 인수의 C 주소를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="8779f80381247cd8664bc51796517172156390c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;C_F_POINTER(CPTR, FPTR[, SHAPE])&lt;/code&gt; assigns the target of the C pointer &lt;var&gt;CPTR&lt;/var&gt; to the Fortran pointer &lt;var&gt;FPTR&lt;/var&gt; and specifies its shape.</source>
          <target state="translated">&lt;code&gt;C_F_POINTER(CPTR, FPTR[, SHAPE])&lt;/code&gt; 는 C 포인터 &lt;var&gt;CPTR&lt;/var&gt; 의 대상을 포트란 포인터 &lt;var&gt;FPTR&lt;/var&gt; 에 할당 하고 모양을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="a5eecc38c91d53d3a1b9f562b752d919d2ee39ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;C_F_PROCPOINTER(CPTR, FPTR)&lt;/code&gt; Assign the target of the C function pointer &lt;var&gt;CPTR&lt;/var&gt; to the Fortran procedure pointer &lt;var&gt;FPTR&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;C_F_PROCPOINTER(CPTR, FPTR)&lt;/code&gt; C 함수 포인터 &lt;var&gt;CPTR&lt;/var&gt; 의 대상을 포트란 프로 시저 포인터 &lt;var&gt;FPTR&lt;/var&gt; 에 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="c4aa0ba03493d7d7ddd38112f143eed434649eee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;C_LOC(X)&lt;/code&gt; determines the C address of the argument.</source>
          <target state="translated">&lt;code&gt;C_LOC(X)&lt;/code&gt; 는 인수의 C 주소를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="e7135175e23a34da4298e9db1933b0f53bd8a3a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;C_SIZEOF(X)&lt;/code&gt; calculates the number of bytes of storage the expression &lt;code&gt;X&lt;/code&gt; occupies.</source>
          <target state="translated">&lt;code&gt;C_SIZEOF(X)&lt;/code&gt; 는 표현식 &lt;code&gt;X&lt;/code&gt; 가 차지하는 스토리지의 바이트 수를 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="6a553c05523bb1704a95f8064c5c928819dca5dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DATE = FDATE()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DATE = FDATE()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4bfea721164c68ad64db8fb084eeb2f91078695d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DATE_AND_TIME(DATE, TIME, ZONE, VALUES)&lt;/code&gt; gets the corresponding date and time information from the real-time system clock. &lt;var&gt;DATE&lt;/var&gt; is &lt;code&gt;INTENT(OUT)&lt;/code&gt; and has form ccyymmdd. &lt;var&gt;TIME&lt;/var&gt; is &lt;code&gt;INTENT(OUT)&lt;/code&gt; and has form hhmmss.sss. &lt;var&gt;ZONE&lt;/var&gt; is &lt;code&gt;INTENT(OUT)&lt;/code&gt; and has form (+-)hhmm, representing the difference with respect to Coordinated Universal Time (UTC). Unavailable time and date parameters return blanks.</source>
          <target state="translated">&lt;code&gt;DATE_AND_TIME(DATE, TIME, ZONE, VALUES)&lt;/code&gt; 는 실시간 시스템 시계에서 해당 날짜 및 시간 정보를 가져옵니다. &lt;var&gt;DATE&lt;/var&gt; 는 &lt;code&gt;INTENT(OUT)&lt;/code&gt; 이며 ccyymmdd 형식입니다. &lt;var&gt;TIME&lt;/var&gt; 은 &lt;code&gt;INTENT(OUT)&lt;/code&gt; 이며 형식은 hhmmss.sss입니다. &lt;var&gt;ZONE&lt;/var&gt; 은 &lt;code&gt;INTENT(OUT)&lt;/code&gt; 이며 형식 (+-) hhmm이며 UTC (협정 세계시)와의 차이를 나타냅니다. 사용할 수없는 시간 및 날짜 매개 변수는 공백을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a917aa3b4ab49f39be72884fa7203ba2ea2f2d9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DBLE(A)&lt;/code&gt; Converts &lt;var&gt;A&lt;/var&gt; to double precision real type.</source>
          <target state="translated">&lt;code&gt;DBLE(A)&lt;/code&gt; &lt;var&gt;A&lt;/var&gt; 를 배정 밀도 실수 형으로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="da1c3c32fc6371565d22fb1dc5c85a834d306671" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DCMPLX(X [,Y])&lt;/code&gt; returns a double complex number where &lt;var&gt;X&lt;/var&gt; is converted to the real component. If &lt;var&gt;Y&lt;/var&gt; is present it is converted to the imaginary component. If &lt;var&gt;Y&lt;/var&gt; is not present then the imaginary component is set to 0.0. If &lt;var&gt;X&lt;/var&gt; is complex then &lt;var&gt;Y&lt;/var&gt; must not be present.</source>
          <target state="translated">&lt;code&gt;DCMPLX(X [,Y])&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 가 실수 구성 요소로 변환 되는 복소수를 리턴합니다 . 경우 &lt;var&gt;Y&lt;/var&gt; 는 존재는 허수 성분으로 변환된다. 경우 &lt;var&gt;Y&lt;/var&gt; 가 존재하지 않는 그 허수 성분은 0.0으로 설정된다. 경우 &lt;var&gt;X&lt;/var&gt; 가 복잡 다음 &lt;var&gt;Y&lt;/var&gt; 는 존재하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="142e8be657c2ac104d98b3ff236a04529063b5c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DIGITS(X)&lt;/code&gt; returns the number of significant binary digits of the internal model representation of &lt;var&gt;X&lt;/var&gt;. For example, on a system using a 32-bit floating point representation, a default real number would likely return 24.</source>
          <target state="translated">&lt;code&gt;DIGITS(X)&lt;/code&gt; 의 내부 모델 표현의 중요한 이진수의 수를 반환 &lt;var&gt;X&lt;/var&gt; 를 . 예를 들어 32 비트 부동 소수점 표현을 사용하는 시스템에서 기본 실수는 24를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0892901af491f12deecbf0e80844e8ac206b327d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DIM(X,Y)&lt;/code&gt; returns the difference &lt;code&gt;X-Y&lt;/code&gt; if the result is positive; otherwise returns zero.</source>
          <target state="translated">&lt;code&gt;DIM(X,Y)&lt;/code&gt; 결과가 양수이면 DIM (X, Y) 는 차이 &lt;code&gt;X-Y&lt;/code&gt; 반환합니다 . 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="19f9baac7613c8a86540ea556a30245e569910cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DLLEXPORT&lt;/code&gt; &amp;ndash; provide a global pointer to a pointer in the DLL</source>
          <target state="translated">&lt;code&gt;DLLEXPORT&lt;/code&gt; &amp;ndash; DLL의 포인터에 대한 전역 포인터 제공</target>
        </trans-unit>
        <trans-unit id="bab620ceff1a81c3ec7a5a234c397449af806ca9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DLLIMPORT&lt;/code&gt; &amp;ndash; reference the function or variable using a global pointer</source>
          <target state="translated">&lt;code&gt;DLLIMPORT&lt;/code&gt; &amp;ndash; 전역 포인터를 사용하여 함수 또는 변수 참조</target>
        </trans-unit>
        <trans-unit id="afd9f25f0ed27db0862cb63655bfae807c4e0ead" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DOT_PRODUCT(VECTOR_A, VECTOR_B)&lt;/code&gt; computes the dot product multiplication of two vectors &lt;var&gt;VECTOR_A&lt;/var&gt; and &lt;var&gt;VECTOR_B&lt;/var&gt;. The two vectors may be either numeric or logical and must be arrays of rank one and of equal size. If the vectors are &lt;code&gt;INTEGER&lt;/code&gt; or &lt;code&gt;REAL&lt;/code&gt;, the result is &lt;code&gt;SUM(VECTOR_A*VECTOR_B)&lt;/code&gt;. If the vectors are &lt;code&gt;COMPLEX&lt;/code&gt;, the result is &lt;code&gt;SUM(CONJG(VECTOR_A)*VECTOR_B)&lt;/code&gt;. If the vectors are &lt;code&gt;LOGICAL&lt;/code&gt;, the result is &lt;code&gt;ANY(VECTOR_A .AND. VECTOR_B)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DOT_PRODUCT(VECTOR_A, VECTOR_B)&lt;/code&gt; 는 두 벡터 &lt;var&gt;VECTOR_A&lt;/var&gt; 및 &lt;var&gt;VECTOR_B&lt;/var&gt; 의 내적 곱을 계산합니다 . 두 벡터는 숫자이거나 논리 일 수 있으며 순위가 1이고 크기가 같은 배열이어야합니다. 벡터가 &lt;code&gt;INTEGER&lt;/code&gt; 또는 &lt;code&gt;REAL&lt;/code&gt; 인 경우 결과는 &lt;code&gt;SUM(VECTOR_A*VECTOR_B)&lt;/code&gt; 입니다. 벡터가 &lt;code&gt;COMPLEX&lt;/code&gt; 인 경우 결과는 &lt;code&gt;SUM(CONJG(VECTOR_A)*VECTOR_B)&lt;/code&gt; 입니다. 벡터가 &lt;code&gt;LOGICAL&lt;/code&gt; 이면 결과는 &lt;code&gt;ANY(VECTOR_A .AND. VECTOR_B)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4ae57531fc7dd3d63adb429eca2d2442a578f092" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DPROD(X,Y)&lt;/code&gt; returns the product &lt;code&gt;X*Y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DPROD(X,Y)&lt;/code&gt; 는 곱 &lt;code&gt;X*Y&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a50ccdac95dc85f4ea9be916b52d8c4e076a9655" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DREAL(Z)&lt;/code&gt; returns the real part of complex variable &lt;var&gt;Z&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;DREAL(Z)&lt;/code&gt; 는 복소수 변수 &lt;var&gt;Z&lt;/var&gt; 의 실수 부분을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="45c74cc855d9efe0cc0c4e02138e339ac8b83169" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DSHIFTL(I, J, SHIFT)&lt;/code&gt; combines bits of &lt;var&gt;I&lt;/var&gt; and &lt;var&gt;J&lt;/var&gt;. The rightmost &lt;var&gt;SHIFT&lt;/var&gt; bits of the result are the leftmost &lt;var&gt;SHIFT&lt;/var&gt; bits of &lt;var&gt;J&lt;/var&gt;, and the remaining bits are the rightmost bits of &lt;var&gt;I&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;DSHIFTL(I, J, SHIFT)&lt;/code&gt; 은 &lt;var&gt;I&lt;/var&gt; 및 &lt;var&gt;J&lt;/var&gt; 비트를 결합 합니다. 결과 의 가장 오른쪽 &lt;var&gt;SHIFT&lt;/var&gt; 비트는 &lt;var&gt;J&lt;/var&gt; 의 가장 왼쪽 &lt;var&gt;SHIFT&lt;/var&gt; 비트이고 나머지 비트는 &lt;var&gt;I&lt;/var&gt; 의 가장 오른쪽 비트입니다 .</target>
        </trans-unit>
        <trans-unit id="f7dc19427ff0123868d917641927b8e22d78f2fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DSHIFTR(I, J, SHIFT)&lt;/code&gt; combines bits of &lt;var&gt;I&lt;/var&gt; and &lt;var&gt;J&lt;/var&gt;. The leftmost &lt;var&gt;SHIFT&lt;/var&gt; bits of the result are the rightmost &lt;var&gt;SHIFT&lt;/var&gt; bits of &lt;var&gt;I&lt;/var&gt;, and the remaining bits are the leftmost bits of &lt;var&gt;J&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;DSHIFTR(I, J, SHIFT)&lt;/code&gt; 는 &lt;var&gt;I&lt;/var&gt; 와 &lt;var&gt;J&lt;/var&gt; 의 비트를 결합 합니다. 결과 의 가장 왼쪽 &lt;var&gt;SHIFT&lt;/var&gt; 비트는 &lt;var&gt;I&lt;/var&gt; 의 가장 오른쪽 &lt;var&gt;SHIFT&lt;/var&gt; 비트이고 나머지 비트는 &lt;var&gt;J&lt;/var&gt; 의 가장 왼쪽 비트입니다 .</target>
        </trans-unit>
        <trans-unit id="e5c0d5634fbc2ffeff188a14b2906da73122aec5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DTIME(VALUES, TIME)&lt;/code&gt; initially returns the number of seconds of runtime since the start of the process&amp;rsquo;s execution in &lt;var&gt;TIME&lt;/var&gt;. &lt;var&gt;VALUES&lt;/var&gt; returns the user and system components of this time in &lt;code&gt;VALUES(1)&lt;/code&gt; and &lt;code&gt;VALUES(2)&lt;/code&gt; respectively. &lt;var&gt;TIME&lt;/var&gt; is equal to &lt;code&gt;VALUES(1) +
VALUES(2)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DTIME(VALUES, TIME)&lt;/code&gt; 초기에 프로세스의 실행 시작부터 실행 시간을 초 단위로 반환 &lt;var&gt;TIME&lt;/var&gt; . &lt;var&gt;VALUES&lt;/var&gt; 는이 시간의 사용자 및 시스템 구성 요소를 각각 &lt;code&gt;VALUES(1)&lt;/code&gt; 및 &lt;code&gt;VALUES(2)&lt;/code&gt; 리턴합니다 . &lt;var&gt;TIME&lt;/var&gt; 은 &lt;code&gt;VALUES(1) + VALUES(2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72a50a2a1951559d5227778a90122595a0ca9537" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;EOSHIFT(ARRAY, SHIFT[, BOUNDARY, DIM])&lt;/code&gt; performs an end-off shift on elements of &lt;var&gt;ARRAY&lt;/var&gt; along the dimension of &lt;var&gt;DIM&lt;/var&gt;. If &lt;var&gt;DIM&lt;/var&gt; is omitted it is taken to be &lt;code&gt;1&lt;/code&gt;. &lt;var&gt;DIM&lt;/var&gt; is a scalar of type &lt;code&gt;INTEGER&lt;/code&gt; in the range of &lt;em&gt;1 \leq DIM \leq n)&lt;/em&gt; where &lt;em&gt;n&lt;/em&gt; is the rank of &lt;var&gt;ARRAY&lt;/var&gt;. If the rank of &lt;var&gt;ARRAY&lt;/var&gt; is one, then all elements of &lt;var&gt;ARRAY&lt;/var&gt; are shifted by &lt;var&gt;SHIFT&lt;/var&gt; places. If rank is greater than one, then all complete rank one sections of &lt;var&gt;ARRAY&lt;/var&gt; along the given dimension are shifted. Elements shifted out one end of each rank one section are dropped. If &lt;var&gt;BOUNDARY&lt;/var&gt; is present then the corresponding value of from &lt;var&gt;BOUNDARY&lt;/var&gt; is copied back in the other end. If &lt;var&gt;BOUNDARY&lt;/var&gt; is not present then the following are copied in depending on the type of &lt;var&gt;ARRAY&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;EOSHIFT(ARRAY, SHIFT[, BOUNDARY, DIM])&lt;/code&gt; 은 &lt;var&gt;DIM&lt;/var&gt; 의 치수를 따라 &lt;var&gt;ARRAY&lt;/var&gt; 요소에 대한 종료 시프트를 수행합니다 . 경우 &lt;var&gt;DIM&lt;/var&gt; 은 생략 그것으로 촬영 &lt;code&gt;1&lt;/code&gt; . &lt;var&gt;DIM&lt;/var&gt; 은 &lt;em&gt;1 \ leq DIM \ leq n)&lt;/em&gt; 범위의 &lt;code&gt;INTEGER&lt;/code&gt; 유형의 스칼라입니다. 여기서 &lt;em&gt;n&lt;/em&gt; 은 &lt;var&gt;ARRAY&lt;/var&gt; 의 순위입니다 . &lt;var&gt;ARRAY&lt;/var&gt; 의 순위 가 1이면 &lt;var&gt;ARRAY&lt;/var&gt; 의 모든 요소 가 &lt;var&gt;SHIFT&lt;/var&gt; 자리 만큼 이동 합니다. 순위가 1보다 크면 &lt;var&gt;ARRAY&lt;/var&gt; 의 전체 섹션 중 하나를 완료합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;주어진 치수를 따라 이동합니다. 각 등급의 한쪽 끝으로 이동 된 요소는 한 섹션이 삭제됩니다. 경우 &lt;var&gt;BOUNDARY&lt;/var&gt; 가 존재하는 다음 행의 해당 값 &lt;var&gt;BOUNDARY&lt;/var&gt; 는 타 단부에서 다시 복사된다. 경우 &lt;var&gt;BOUNDARY&lt;/var&gt; 존재하지 않는 그 다음은의 종류에 따라 복사됩니다 &lt;var&gt;ARRAY&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="60c0f14f86d3131ad2a51053f9904831e61b1467" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;EPSILON(X)&lt;/code&gt; returns the smallest number &lt;var&gt;E&lt;/var&gt; of the same kind as &lt;var&gt;X&lt;/var&gt; such that &lt;em&gt;1 + E &amp;gt; 1&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;EPSILON(X)&lt;/code&gt; 는 &lt;em&gt;1 + E&amp;gt; 1&lt;/em&gt; 과 같이 &lt;var&gt;X&lt;/var&gt; 와 같은 종류 의 가장 작은 숫자 &lt;var&gt;E&lt;/var&gt; 를 반환합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4498b50f8cc55b842a598a15d463a7fe372cb3be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ERF(X)&lt;/code&gt; computes the error function of &lt;var&gt;X&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;ERF(X)&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 의 오차 함수를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="9f3b5f89cc2ad9d45ab71986f7e378bdfce40877" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ERFC(X)&lt;/code&gt; computes the complementary error function of &lt;var&gt;X&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;ERFC(X)&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 의 상보 오차 함수를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="4fb2e505d6132ad5fd45137442ef9b6921383139" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ERFC_SCALED(X)&lt;/code&gt; computes the exponentially-scaled complementary error function of &lt;var&gt;X&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;ERFC_SCALED(X)&lt;/code&gt; 의 지수 스케일 상보 오차 함수 계산 &lt;var&gt;X&lt;/var&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="93d74d05cd64de2117e8822a46192aec9c49d989" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ERROR_UNIT&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ERROR_UNIT&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="c0df2cb6d8795ac2d89f3fbb1730dcaa894ab595" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ETIME(VALUES, TIME)&lt;/code&gt; returns the number of seconds of runtime since the start of the process&amp;rsquo;s execution in &lt;var&gt;TIME&lt;/var&gt;. &lt;var&gt;VALUES&lt;/var&gt; returns the user and system components of this time in &lt;code&gt;VALUES(1)&lt;/code&gt; and &lt;code&gt;VALUES(2)&lt;/code&gt; respectively. &lt;var&gt;TIME&lt;/var&gt; is equal to &lt;code&gt;VALUES(1) + VALUES(2)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ETIME(VALUES, TIME)&lt;/code&gt; 있는 프로세스의 실행 시작부터 실행 시간을 초 단위로 반환 &lt;var&gt;TIME&lt;/var&gt; . &lt;var&gt;VALUES&lt;/var&gt; 는이 시간의 사용자 및 시스템 구성 요소를 각각 &lt;code&gt;VALUES(1)&lt;/code&gt; 및 &lt;code&gt;VALUES(2)&lt;/code&gt; 리턴합니다 . &lt;var&gt;TIME&lt;/var&gt; 은 &lt;code&gt;VALUES(1) + VALUES(2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5eef394bac89f54210ff99c12e96db4c138e21c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;EVENT_QUERY&lt;/code&gt; assignes the number of events to &lt;var&gt;COUNT&lt;/var&gt; which have been posted to the &lt;var&gt;EVENT&lt;/var&gt; variable and not yet been removed by calling &lt;code&gt;EVENT WAIT&lt;/code&gt;. When &lt;var&gt;STAT&lt;/var&gt; is present and the invocation was successful, it is assigned the value 0. If it is present and the invocation has failed, it is assigned a positive value and &lt;var&gt;COUNT&lt;/var&gt; is assigned the value &lt;em&gt;-1&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;EVENT_QUERY&lt;/code&gt; 는 &lt;var&gt;EVENT&lt;/var&gt; 변수 에 게시 되었지만 &lt;code&gt;EVENT WAIT&lt;/code&gt; 를 호출하여 아직 제거되지 않은 이벤트 수를 &lt;var&gt;COUNT&lt;/var&gt; 에 지정 합니다. 경우 &lt;var&gt;STAT&lt;/var&gt; 가 존재하고 호출이 성공이 존재하는 경우, 0의 값이 할당되고, 호출은 그 양의 값이 할당되고, 실패 &lt;var&gt;COUNT&lt;/var&gt; 는 값을 할당 &lt;em&gt;-1&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="98ad5f23efffedcbcfb5126810b5b8ac56f94724" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;EXECUTE_COMMAND_LINE&lt;/code&gt; runs a shell command, synchronously or asynchronously.</source>
          <target state="translated">&lt;code&gt;EXECUTE_COMMAND_LINE&lt;/code&gt; 은 쉘 명령을 동기식 또는 비동기식으로 실행합니다.</target>
        </trans-unit>
        <trans-unit id="ac9e255d3703d6c843d0ea5c7d4363706f323d6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;EXIT&lt;/code&gt; causes immediate termination of the program with status. If status is omitted it returns the canonical &lt;em&gt;success&lt;/em&gt; for the system. All Fortran I/O units are closed.</source>
          <target state="translated">&lt;code&gt;EXIT&lt;/code&gt; 는 상태와 함께 프로그램을 즉시 종료시킵니다. status가 생략 되면 시스템 의 표준 &lt;em&gt;성공&lt;/em&gt; 을 리턴합니다 . 모든 포트란 I / O 장치가 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="347984a3a4f591c4766f6b74d879699f0123ef18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;EXP(X)&lt;/code&gt; computes the base &lt;em&gt;e&lt;/em&gt; exponential of &lt;var&gt;X&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;EXP(X)&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 의 기본 &lt;em&gt;e&lt;/em&gt; 지수를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="d83698b9839d014ede03ee985aca182017cbf27f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;EXPONENT(X)&lt;/code&gt; returns the value of the exponent part of &lt;var&gt;X&lt;/var&gt;. If &lt;var&gt;X&lt;/var&gt; is zero the value returned is zero.</source>
          <target state="translated">&lt;code&gt;EXPONENT(X)&lt;/code&gt; 의 지수 부분의 값 반환 &lt;var&gt;X&lt;/var&gt; 를 . 경우 &lt;var&gt;X&lt;/var&gt; 가 제로 반환 값은 0이다.</target>
        </trans-unit>
        <trans-unit id="4eb74f30d0e044ca5fc7aecde93e60273c914d19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FASTCALL&lt;/code&gt; &amp;ndash; part of the arguments are passed via registers instead using the stack</source>
          <target state="translated">&lt;code&gt;FASTCALL&lt;/code&gt; &amp;ndash; 인수의 일부는 스택을 사용하는 대신 레지스터를 통해 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="d8bcc296b69953c0f5dbfbea24db9a91a5a8e9c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FDATE(DATE)&lt;/code&gt; returns the current date (using the same format as &lt;a href=&quot;ctime#CTIME&quot;&gt;CTIME&lt;/a&gt;) in &lt;var&gt;DATE&lt;/var&gt;. It is equivalent to &lt;code&gt;CALL CTIME(DATE,
TIME())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;FDATE(DATE)&lt;/code&gt; (같은 형식을 사용하여 현재 날짜를 반환 &lt;a href=&quot;ctime#CTIME&quot;&gt;CTIME&lt;/a&gt; 에서) &lt;var&gt;DATE&lt;/var&gt; 를 . 그것은에 해당 &lt;code&gt;CALL CTIME(DATE, TIME())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50c6d19480fb943a1917d025bf47aedfc4d80474" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FILE_STORAGE_SIZE&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;FILE_STORAGE_SIZE&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="3de48ce42096ca165c124e0bc5adf90a57c24710" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FLOOR(A)&lt;/code&gt; returns the greatest integer less than or equal to &lt;var&gt;X&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;FLOOR(A)&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 이하의 가장 큰 정수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a66c962d522c1f3cdcb50be88a470fb240648b86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FNUM(UNIT)&lt;/code&gt; returns the POSIX file descriptor number corresponding to the open Fortran I/O unit &lt;code&gt;UNIT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;FNUM(UNIT)&lt;/code&gt; 은 열린 포트란 I / O 장치 &lt;code&gt;UNIT&lt;/code&gt; 에 해당하는 POSIX 파일 디스크립터 번호를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="5099952f80010fc5cd6c5a4daca0bda6094f0aa3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FRACTION(X)&lt;/code&gt; returns the fractional part of the model representation of &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;FRACTION(X)&lt;/code&gt; 의 모델 표현의 소수 부분 반환 &lt;code&gt;X&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="26ea52dead6581fc0f0ab90d5ee2dfef5efb5d7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FSTAT&lt;/code&gt; is identical to &lt;a href=&quot;stat#STAT&quot;&gt;STAT&lt;/a&gt;, except that information about an already opened file is obtained.</source>
          <target state="translated">&lt;code&gt;FSTAT&lt;/code&gt; 는 이미 열린 파일에 대한 정보 를 얻는다 는 점을 제외하고는 &lt;a href=&quot;stat#STAT&quot;&gt;STAT&lt;/a&gt; 와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="9967c5658a871745d62b681cac70d7cb09ca9e7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GAMMA(X)&lt;/code&gt; computes Gamma (&lt;em&gt;\Gamma&lt;/em&gt;) of &lt;var&gt;X&lt;/var&gt;. For positive, integer values of &lt;var&gt;X&lt;/var&gt; the Gamma function simplifies to the factorial function &lt;em&gt;\Gamma(x)=(x-1)!&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;GAMMA(X)&lt;/code&gt; )는 &lt;var&gt;X&lt;/var&gt; 의 감마 ( &lt;em&gt;\ Gamma&lt;/em&gt; )를 계산합니다 . &lt;var&gt;X&lt;/var&gt; 의 양수, 정수 값의 경우 감마 함수는 계승 함수 &lt;em&gt;\ Gamma (x) = (x-1)로&lt;/em&gt; 단순화됩니다 &lt;em&gt;! &lt;/em&gt;.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="27deaa69d326d3a834ebb41dbcac6ffe23f6912e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HUGE(X)&lt;/code&gt; returns the largest number that is not an infinity in the model of the type of &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HUGE(X)&lt;/code&gt; 는 &lt;code&gt;X&lt;/code&gt; 유형의 모델에서 무한대가 아닌 가장 큰 숫자를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ebeb8c6f9d9b8d3457ff8cf3b1e265e23dda5dfc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HYPOT(X,Y)&lt;/code&gt; is the Euclidean distance function. It is equal to &lt;em&gt;\sqrt{X^2 + Y^2}&lt;/em&gt;, without undue underflow or overflow.</source>
          <target state="translated">&lt;code&gt;HYPOT(X,Y)&lt;/code&gt; 는 유클리드 거리 함수입니다. 그것은 같다 &lt;em&gt;\ SQRT {X ^ 2 + Y ^ 2}&lt;/em&gt; 과도한 언더 플로우 나 오버 플로우없이.</target>
        </trans-unit>
        <trans-unit id="190cad20335a1ec2df1ecbaae90d6b0ebae4e100" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IACHAR(C)&lt;/code&gt; returns the code for the ASCII character in the first character position of &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;IACHAR(C)&lt;/code&gt; 의 첫 번째 문자 위치에 ASCII 문자의 코드 반환 &lt;code&gt;C&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="d610419c936a0a4ebdfca15f014dc8df802d045a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IARGC&lt;/code&gt; returns the number of arguments passed on the command line when the containing program was invoked.</source>
          <target state="translated">&lt;code&gt;IARGC&lt;/code&gt; 는 포함 프로그램이 호출 될 때 명령 행에 전달 된 인수 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5227b64c9f3a457605eed86cb7bb5a9c97791bd7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IBCLR&lt;/code&gt; returns the value of &lt;var&gt;I&lt;/var&gt; with the bit at position &lt;var&gt;POS&lt;/var&gt; set to zero.</source>
          <target state="translated">&lt;code&gt;IBCLR&lt;/code&gt; 은 &lt;var&gt;POS&lt;/var&gt; 위치의 비트 가 0으로 설정된 &lt;var&gt;I&lt;/var&gt; 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="f52f9213b2aadbf11ca5f8fd3e0a2c922d871a58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IBITS&lt;/code&gt; extracts a field of length &lt;var&gt;LEN&lt;/var&gt; from &lt;var&gt;I&lt;/var&gt;, starting from bit position &lt;var&gt;POS&lt;/var&gt; and extending left for &lt;var&gt;LEN&lt;/var&gt; bits. The result is right-justified and the remaining bits are zeroed. The value of &lt;code&gt;POS+LEN&lt;/code&gt; must be less than or equal to the value &lt;code&gt;BIT_SIZE(I)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;IBITS&lt;/code&gt; 는 비트 위치 &lt;var&gt;POS&lt;/var&gt; 에서 시작 하여 &lt;var&gt;LEN&lt;/var&gt; 비트에 대해 왼쪽으로 연장되는 &lt;var&gt;I&lt;/var&gt; 에서 길이 &lt;var&gt;LEN&lt;/var&gt; 의 필드를 추출합니다 . 결과는 오른쪽 정렬되고 나머지 비트는 0이됩니다. 값 &lt;code&gt;POS+LEN&lt;/code&gt; 은 보다 적은 수 또는 값과 동일해야 &lt;code&gt;BIT_SIZE(I)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8b3e1d9835e2555543e08916e85c7535d3de3d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IBSET&lt;/code&gt; returns the value of &lt;var&gt;I&lt;/var&gt; with the bit at position &lt;var&gt;POS&lt;/var&gt; set to one.</source>
          <target state="translated">&lt;code&gt;IBSET&lt;/code&gt; 은 &lt;var&gt;POS&lt;/var&gt; 위치의 비트 가 1로 설정된 &lt;var&gt;I&lt;/var&gt; 의 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="71c4391787465e2e12ffffaa79dcb3affdc10711" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ICHAR(C)&lt;/code&gt; returns the code for the character in the first character position of &lt;code&gt;C&lt;/code&gt; in the system&amp;rsquo;s native character set. The correspondence between characters and their codes is not necessarily the same across different GNU Fortran implementations.</source>
          <target state="translated">&lt;code&gt;ICHAR(C)&lt;/code&gt; 는 시스템의 기본 문자 세트에서 &lt;code&gt;C&lt;/code&gt; 의 첫 번째 문자 위치에있는 문자의 코드를 리턴합니다 . 문자와 해당 코드 간의 대응이 다른 GNU Fortran 구현에서 반드시 동일하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="2cd0701b296ead8a90e32c8eb37e2ce3c5d6e08f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IDATE(VALUES)&lt;/code&gt; Fills &lt;var&gt;VALUES&lt;/var&gt; with the numerical values at the current local time. The day (in the range 1-31), month (in the range 1-12), and year appear in elements 1, 2, and 3 of &lt;var&gt;VALUES&lt;/var&gt;, respectively. The year has four significant digits.</source>
          <target state="translated">&lt;code&gt;IDATE(VALUES)&lt;/code&gt; &lt;var&gt;VALUES&lt;/var&gt; 를 현재 현지 시간의 숫자 값으로 채 웁니다 . 일 (1 ~ 3 범위), 월 (1 ~ 12 범위) 및 연도 는 각각 &lt;var&gt;VALUES&lt;/var&gt; 의 요소 1, 2 및 3에 나타납니다 . 연도에는 4 자리의 유효 숫자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e7e6b67673e25b3263156f37bf3a8c22cbfe995" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IEOR&lt;/code&gt; returns the bitwise Boolean exclusive-OR of &lt;var&gt;I&lt;/var&gt; and &lt;var&gt;J&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;IEOR&lt;/code&gt; 은 &lt;var&gt;I&lt;/var&gt; 및 &lt;var&gt;J&lt;/var&gt; 의 비트 단위 부울 독점 OR을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1bec83e0803314e62cb3f38ff38272efba811995" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;INPUT_UNIT&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;INPUT_UNIT&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="22cec38d83ccf55767d1b568a5aa116fda2bbf96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;INT8&lt;/code&gt;, &lt;code&gt;INT16&lt;/code&gt;, &lt;code&gt;INT32&lt;/code&gt;, &lt;code&gt;INT64&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;INT8&lt;/code&gt; , &lt;code&gt;INT16&lt;/code&gt; , &lt;code&gt;INT32&lt;/code&gt; , &lt;code&gt;INT64&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3ac2ec146eb22028d0bdfb6fedb8544f36803492" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;INTEGER_KINDS&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;INTEGER_KINDS&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="8de83dc74b34554d35d80df437a8ae8d3e6ab4fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IOR&lt;/code&gt; returns the bitwise Boolean inclusive-OR of &lt;var&gt;I&lt;/var&gt; and &lt;var&gt;J&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;IOR&lt;/code&gt; 은 &lt;var&gt;I&lt;/var&gt; 및 &lt;var&gt;J&lt;/var&gt; 의 비트 단위 부울 포함 OR을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4d6e1edbbf3b2cbb4ca2a6c137578f84ba2b285b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IOSTAT_END&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;IOSTAT_END&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="dcf4ef956228b300c611438f60c08eccbefdeac2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IOSTAT_EOR&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;IOSTAT_EOR&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="aaab5fee9a29e06c18589e560e87e7bf808eb630" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IOSTAT_INQUIRE_INTERNAL_UNIT&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;IOSTAT_INQUIRE_INTERNAL_UNIT&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="e1832f0b5571cb7f55262d222502e3d03f525e26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IRAND(FLAG)&lt;/code&gt; returns a pseudo-random number from a uniform distribution between 0 and a system-dependent limit (which is in most cases 2147483647). If &lt;var&gt;FLAG&lt;/var&gt; is 0, the next number in the current sequence is returned; if &lt;var&gt;FLAG&lt;/var&gt; is 1, the generator is restarted by &lt;code&gt;CALL SRAND(0)&lt;/code&gt;; if &lt;var&gt;FLAG&lt;/var&gt; has any other value, it is used as a new seed with &lt;code&gt;SRAND&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;IRAND(FLAG)&lt;/code&gt; 는 0과 시스템 종속 한계 (대부분의 경우 2147483647) 사이의 균일 분포에서 의사 난수를 반환합니다. 경우 &lt;var&gt;FLAG&lt;/var&gt; 는 0, 현재의 순서의 다음 숫자가 반환됩니다; 만약 &lt;var&gt;FLAG&lt;/var&gt; 1, 발전기에 의해 다시 시작될 &lt;code&gt;CALL SRAND(0)&lt;/code&gt; ; 만약 &lt;var&gt;FLAG&lt;/var&gt; 다른 값을 가지며, 이는와 새로운 시드로 사용 &lt;code&gt;SRAND&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b970921cd8b183fe9f60c685afb0b51f403a2c2b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ISHFT&lt;/code&gt; returns a value corresponding to &lt;var&gt;I&lt;/var&gt; with all of the bits shifted &lt;var&gt;SHIFT&lt;/var&gt; places. A value of &lt;var&gt;SHIFT&lt;/var&gt; greater than zero corresponds to a left shift, a value of zero corresponds to no shift, and a value less than zero corresponds to a right shift. If the absolute value of &lt;var&gt;SHIFT&lt;/var&gt; is greater than &lt;code&gt;BIT_SIZE(I)&lt;/code&gt;, the value is undefined. Bits shifted out from the left end or right end are lost; zeros are shifted in from the opposite end.</source>
          <target state="translated">&lt;code&gt;ISHFT&lt;/code&gt; 는 모든 비트 시프트 된 &lt;var&gt;SHIFT&lt;/var&gt; 위치 로 &lt;var&gt;I&lt;/var&gt; 에 해당하는 값을 반환합니다 . 0보다 큰 &lt;var&gt;SHIFT&lt;/var&gt; 값은 왼쪽 시프트에 해당하고 0 값은 시프트 없음에 해당하며 0보다 작은 값은 오른쪽 시프트에 해당합니다. &lt;var&gt;SHIFT&lt;/var&gt; 의 절대 값 이 &lt;code&gt;BIT_SIZE(I)&lt;/code&gt; 보다 큰 경우 값이 정의되지 않습니다. 왼쪽 끝 또는 오른쪽 끝에서 이동 된 비트는 손실됩니다. 반대쪽 끝에서 0이 이동합니다.</target>
        </trans-unit>
        <trans-unit id="5f36ed6bb6cdb8854e3388ab9d6a3d162d9c2033" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ISHFTC&lt;/code&gt; returns a value corresponding to &lt;var&gt;I&lt;/var&gt; with the rightmost &lt;var&gt;SIZE&lt;/var&gt; bits shifted circularly &lt;var&gt;SHIFT&lt;/var&gt; places; that is, bits shifted out one end are shifted into the opposite end. A value of &lt;var&gt;SHIFT&lt;/var&gt; greater than zero corresponds to a left shift, a value of zero corresponds to no shift, and a value less than zero corresponds to a right shift. The absolute value of &lt;var&gt;SHIFT&lt;/var&gt; must be less than &lt;var&gt;SIZE&lt;/var&gt;. If the &lt;var&gt;SIZE&lt;/var&gt; argument is omitted, it is taken to be equivalent to &lt;code&gt;BIT_SIZE(I)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ISHFTC&lt;/code&gt; 는 가장 오른쪽에있는 &lt;var&gt;SIZE&lt;/var&gt; 비트가 원형으로 &lt;var&gt;SHIFT&lt;/var&gt; 자리 만큼 이동 한 &lt;var&gt;I&lt;/var&gt; 에 해당하는 값을 반환합니다 . 즉, 한쪽 끝으로 시프트 된 비트는 반대쪽 끝으로 시프트된다. 0보다 큰 &lt;var&gt;SHIFT&lt;/var&gt; 값은 왼쪽 시프트에 해당하고 0 값은 시프트 없음에 해당하며 0보다 작은 값은 오른쪽 시프트에 해당합니다. &lt;var&gt;SHIFT&lt;/var&gt; 의 절대 값은 &lt;var&gt;SIZE&lt;/var&gt; 보다 작아야합니다 . 상기 중간 &lt;var&gt;SIZE&lt;/var&gt; 인수를 생략이를 동등 취해진 다 &lt;code&gt;BIT_SIZE(I)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41d541fd5d3b80b4c6130e0424e2a7131ea5d958" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ISNAN&lt;/code&gt; tests whether a floating-point value is an IEEE Not-a-Number (NaN).</source>
          <target state="translated">&lt;code&gt;ISNAN&lt;/code&gt; 은 부동 소수점 값이 IEEE NaN (Not-a-Number)인지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="e187f824d03129be776606ef4dc4f126a9e4bf47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IS_IOSTAT_END&lt;/code&gt; tests whether an variable has the value of the I/O status &amp;ldquo;end of file&amp;rdquo;. The function is equivalent to comparing the variable with the &lt;code&gt;IOSTAT_END&lt;/code&gt; parameter of the intrinsic module &lt;code&gt;ISO_FORTRAN_ENV&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;IS_IOSTAT_END&lt;/code&gt; 는 변수에 I / O 상태 &quot;파일 끝&quot;값이 있는지 테스트합니다. 이 함수는 변수를 내장 모듈 &lt;code&gt;ISO_FORTRAN_ENV&lt;/code&gt; 의 &lt;code&gt;IOSTAT_END&lt;/code&gt; 매개 변수와 비교하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="e8145f61772208cc738f293b092a0a7a3f978aa1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IS_IOSTAT_EOR&lt;/code&gt; tests whether an variable has the value of the I/O status &amp;ldquo;end of record&amp;rdquo;. The function is equivalent to comparing the variable with the &lt;code&gt;IOSTAT_EOR&lt;/code&gt; parameter of the intrinsic module &lt;code&gt;ISO_FORTRAN_ENV&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;IS_IOSTAT_EOR&lt;/code&gt; 는 변수에 I / O 상태 &quot;레코드 끝&quot;값이 있는지 테스트합니다. 이 함수는 변수를 내장 모듈 &lt;code&gt;ISO_FORTRAN_ENV&lt;/code&gt; 의 &lt;code&gt;IOSTAT_EOR&lt;/code&gt; 매개 변수와 비교하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d582395270a9362271328b1a2621e5345b7e6136" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ITIME(VALUES)&lt;/code&gt; Fills &lt;var&gt;VALUES&lt;/var&gt; with the numerical values at the current local time. The hour (in the range 1-24), minute (in the range 1-60), and seconds (in the range 1-60) appear in elements 1, 2, and 3 of &lt;var&gt;VALUES&lt;/var&gt;, respectively.</source>
          <target state="translated">&lt;code&gt;ITIME(VALUES)&lt;/code&gt; 현재 현지 시간의 &lt;var&gt;VALUES&lt;/var&gt; 를 숫자 값으로 채 웁니다 . 시간 (1 ~ 24 범위), 분 (1 ~ 60 범위) 및 초 (1 ~ 60 범위) 는 각각 &lt;var&gt;VALUES&lt;/var&gt; 의 요소 1, 2 및 3에 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="07c5eea905b94a7607af3d8c946161f6cc885724" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;KIND(X)&lt;/code&gt; returns the kind value of the entity &lt;var&gt;X&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;KIND(X)&lt;/code&gt; 는 엔티티 &lt;var&gt;X&lt;/var&gt; 의 종류 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="cb9297fb52d4a2e6d326e9b770585f40c0d80820" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LEADZ&lt;/code&gt; returns the number of leading zero bits of an integer.</source>
          <target state="translated">&lt;code&gt;LEADZ&lt;/code&gt; 는 정수의 선행 0 비트 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="0391b17ffda06c41879993c2a2d0fe28f710905e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LITTLE_ENDIAN&lt;/code&gt; Use the little-endian format for unformatted files.</source>
          <target state="translated">&lt;code&gt;LITTLE_ENDIAN&lt;/code&gt; 형식화되지 않은 파일에는 리틀 엔디안 형식을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dca8db31cfa78063287e86e183f95e401189ba4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOC(X)&lt;/code&gt; returns the address of &lt;var&gt;X&lt;/var&gt; as an integer.</source>
          <target state="translated">&lt;code&gt;LOC(X)&lt;/code&gt; 의 주소를 반환 &lt;var&gt;X&lt;/var&gt; 를 정수로.</target>
        </trans-unit>
        <trans-unit id="2217dea10d00d9f621c5ed6051bb6ecbbcf3aaa9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOCK_TYPE&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;LOCK_TYPE&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="6c26fa8359996044bf958721b863afcfeb92623e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG(X)&lt;/code&gt; computes the natural logarithm of &lt;var&gt;X&lt;/var&gt;, i.e. the logarithm to the base &lt;em&gt;e&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;LOG(X)&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 의 자연 로그 , 즉 밑수 &lt;em&gt;e에&lt;/em&gt; 대한 로그를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="3b35b020287e0f8392577ce3f8d8a48452e57d55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG10(X)&lt;/code&gt; computes the base 10 logarithm of &lt;var&gt;X&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;LOG10(X)&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 의 밑이 10 인 로그를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="da870d089bad70b6dd5980d494afc71f0ceee55b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOGICAL_KINDS&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;LOGICAL_KINDS&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="6c634a17fc8f5707542e95b276bd366247689c5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOG_GAMMA(X)&lt;/code&gt; computes the natural logarithm of the absolute value of the Gamma (&lt;em&gt;\Gamma&lt;/em&gt;) function.</source>
          <target state="translated">&lt;code&gt;LOG_GAMMA(X)&lt;/code&gt; 는 감마 ( &lt;em&gt;\ Gamma&lt;/em&gt; ) 함수 의 절대 값에 대한 자연 로그를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="8fbd6781171e4a800ccd8520793c4b1fc1fb8161" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LSHIFT&lt;/code&gt; returns a value corresponding to &lt;var&gt;I&lt;/var&gt; with all of the bits shifted left by &lt;var&gt;SHIFT&lt;/var&gt; places. If the absolute value of &lt;var&gt;SHIFT&lt;/var&gt; is greater than &lt;code&gt;BIT_SIZE(I)&lt;/code&gt;, the value is undefined. Bits shifted out from the left end are lost; zeros are shifted in from the opposite end.</source>
          <target state="translated">&lt;code&gt;LSHIFT&lt;/code&gt; 는 &lt;var&gt;SHIFT&lt;/var&gt; 자리 만큼 왼쪽으로 이동 된 모든 비트를 가진 &lt;var&gt;I&lt;/var&gt; 에 해당하는 값을 반환합니다 . &lt;var&gt;SHIFT&lt;/var&gt; 의 절대 값 이 &lt;code&gt;BIT_SIZE(I)&lt;/code&gt; 보다 큰 경우 값이 정의되지 않습니다. 왼쪽 끝에서 벗어난 비트는 손실됩니다. 반대쪽 끝에서 0이 이동합니다.</target>
        </trans-unit>
        <trans-unit id="b6774fcb26ac97e2119917abeab8bce31e1a775d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LSTAT&lt;/code&gt; is identical to &lt;a href=&quot;stat#STAT&quot;&gt;STAT&lt;/a&gt;, except that if path is a symbolic link, then the link itself is statted, not the file that it refers to.</source>
          <target state="translated">&lt;code&gt;LSTAT&lt;/code&gt; 경로가 기호 링크 인 경우 링크 자체가 참조되는 파일이 아니라 스 태팅된다는 점을 제외하면 LSTAT 는 &lt;a href=&quot;stat#STAT&quot;&gt;STAT&lt;/a&gt; 와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="6bac4e5a82379f36a0ceb54090e8929b000b2bf3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MALLOC(SIZE)&lt;/code&gt; allocates &lt;var&gt;SIZE&lt;/var&gt; bytes of dynamic memory and returns the address of the allocated memory. The &lt;code&gt;MALLOC&lt;/code&gt; intrinsic is an extension intended to be used with Cray pointers, and is provided in GNU Fortran to allow the user to compile legacy code. For new code using Fortran 95 pointers, the memory allocation intrinsic is &lt;code&gt;ALLOCATE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MALLOC(SIZE)&lt;/code&gt; 를 할당 &lt;var&gt;SIZE&lt;/var&gt; 는 동적 메모리 바이트의 할당 된 메모리의 어드레스를 반환한다. &lt;code&gt;MALLOC&lt;/code&gt; 확장입니다 내장 함수는 크레이 포인터로 사용하기위한, 그리고 컴파일 레거시 코드로 사용자를 허용하는 GNU 포트란에 제공됩니다. Fortran 95 포인터를 사용하는 새 코드의 경우 메모리 할당 내장 함수는 &lt;code&gt;ALLOCATE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d84579e8742e6cb545a7d0d751eb6483e656b0ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MASKL(I[, KIND])&lt;/code&gt; has its leftmost &lt;var&gt;I&lt;/var&gt; bits set to 1, and the remaining bits set to 0.</source>
          <target state="translated">&lt;code&gt;MASKL(I[, KIND])&lt;/code&gt; 의 가장 왼쪽 &lt;var&gt;I&lt;/var&gt; 비트는 1로 설정되고 나머지 비트는 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="14cf321f55e8e8ac8420ce1db3f6f21d3b7ac2a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MASKL(I[, KIND])&lt;/code&gt; has its rightmost &lt;var&gt;I&lt;/var&gt; bits set to 1, and the remaining bits set to 0.</source>
          <target state="translated">&lt;code&gt;MASKL(I[, KIND])&lt;/code&gt; 의 가장 오른쪽 &lt;var&gt;I&lt;/var&gt; 비트는 1로 설정되고 나머지 비트는 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="03dd72f28cdb5292f683a0341fab08dde22d864b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MAXEXPONENT(X)&lt;/code&gt; returns the maximum exponent in the model of the type of &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MAXEXPONENT(X)&lt;/code&gt; 는 &lt;code&gt;X&lt;/code&gt; 유형의 모델에서 최대 지수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3c375d4b7a18a008632ec78b441523a6cde57c89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MERGE_BITS(I, J, MASK)&lt;/code&gt; merges the bits of &lt;var&gt;I&lt;/var&gt; and &lt;var&gt;J&lt;/var&gt; as determined by the mask. The i-th bit of the result is equal to the i-th bit of &lt;var&gt;I&lt;/var&gt; if the i-th bit of &lt;var&gt;MASK&lt;/var&gt; is 1; it is equal to the i-th bit of &lt;var&gt;J&lt;/var&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;MERGE_BITS(I, J, MASK)&lt;/code&gt; 는 마스크에 의해 결정된대로 &lt;var&gt;I&lt;/var&gt; 와 &lt;var&gt;J&lt;/var&gt; 의 비트를 병합합니다 . 결과의 i 번째 비트가 같은지, i 번째의 비트 &lt;var&gt;I&lt;/var&gt; 의 경우, i 번째 비트 &lt;var&gt;MASK&lt;/var&gt; 1이고; 그렇지 않으면 &lt;var&gt;J&lt;/var&gt; 의 i 번째 비트와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="283ff04b6429553ab8679c82f71b4bcaa4259ae5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MINEXPONENT(X)&lt;/code&gt; returns the minimum exponent in the model of the type of &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MINEXPONENT(X)&lt;/code&gt; 는 &lt;code&gt;X&lt;/code&gt; 유형의 모델에서 최소 지수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="dd5cacb8e74dc4bce7d5af0cf9f736dcd4a79e38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MOD(A,P)&lt;/code&gt; computes the remainder of the division of A by P.</source>
          <target state="translated">&lt;code&gt;MOD(A,P)&lt;/code&gt; 는 A를 P로 나눈 나머지를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="5e54d269bfe18f22e7aca35cc0142cfbc0ae23ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MODULO(A,P)&lt;/code&gt; computes the &lt;var&gt;A&lt;/var&gt; modulo &lt;var&gt;P&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;MODULO(A,P)&lt;/code&gt; 는 &lt;var&gt;A&lt;/var&gt; 모듈로 &lt;var&gt;P&lt;/var&gt; 를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="275af9bb1aa202404b2d30d6e3c45a583eddcb53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MODULO(A,P)&lt;/code&gt; has the value &lt;var&gt;R&lt;/var&gt; such that &lt;code&gt;A=Q*P+R&lt;/code&gt;, where &lt;var&gt;Q&lt;/var&gt; is an integer and &lt;var&gt;R&lt;/var&gt; is between 0 (inclusive) and &lt;var&gt;P&lt;/var&gt; (exclusive).</source>
          <target state="translated">&lt;code&gt;MODULO(A,P)&lt;/code&gt; 는 &lt;code&gt;A=Q*P+R&lt;/code&gt; &lt;var&gt;R&lt;/var&gt; 과 같이 R 값을 가지며 , 여기서 &lt;var&gt;Q&lt;/var&gt; 는 정수이고 &lt;var&gt;R&lt;/var&gt; 은 0 (포함)과 &lt;var&gt;P&lt;/var&gt; (제외) 사이입니다.</target>
        </trans-unit>
        <trans-unit id="81843ed91b95dc28c21f4a710c8514127e5221c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MODULO(A,P)&lt;/code&gt; has the value of &lt;code&gt;A - FLOOR (A / P) * P&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MODULO(A,P)&lt;/code&gt; 의 값은 &lt;code&gt;A - FLOOR (A / P) * P&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="139bb8c53439aa9c59ea821dc68f28a737c467b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MOVE_ALLOC(FROM, TO)&lt;/code&gt; moves the allocation from &lt;var&gt;FROM&lt;/var&gt; to &lt;var&gt;TO&lt;/var&gt;. &lt;var&gt;FROM&lt;/var&gt; will become deallocated in the process.</source>
          <target state="translated">&lt;code&gt;MOVE_ALLOC(FROM, TO)&lt;/code&gt; 는 할당을 &lt;var&gt;FROM&lt;/var&gt; 에서 &lt;var&gt;TO&lt;/var&gt; 로 이동합니다 . 이 과정에서 &lt;var&gt;FROM&lt;/var&gt; 이 할당 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="709e99788491f9922411b820087984efbd7904a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NATIVE&lt;/code&gt; Use the native format. This is the default.</source>
          <target state="translated">&lt;code&gt;NATIVE&lt;/code&gt; 를 사용하여 기본 형식입니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="2dc90b5968614a25b7061d43e3a3abbc5ac9d67d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NEAREST(X, S)&lt;/code&gt; returns the processor-representable number nearest to &lt;code&gt;X&lt;/code&gt; in the direction indicated by the sign of &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NEAREST(X, S)&lt;/code&gt; 가장 가까운 프로세서 표현할 수를 반환 &lt;code&gt;X&lt;/code&gt; 방향의 부호에 의해 표시된 &lt;code&gt;S&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2e8ef9c21a752a65daf244d8701948b258cf4bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NEW_LINE(C)&lt;/code&gt; returns the new-line character.</source>
          <target state="translated">&lt;code&gt;NEW_LINE(C)&lt;/code&gt; 는 개행 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3515b5a0ef9c7f5c07c891ca89c991eefdfe4774" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NINT(A)&lt;/code&gt; rounds its argument to the nearest whole number.</source>
          <target state="translated">&lt;code&gt;NINT(A)&lt;/code&gt; 는 인수를 가장 가까운 정수로 반올림합니다.</target>
        </trans-unit>
        <trans-unit id="443668b482579662dec35e7b167058077f4e402c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NOT&lt;/code&gt; returns the bitwise Boolean inverse of &lt;var&gt;I&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;NOT&lt;/code&gt; 의 비트 부울 역 반환 &lt;var&gt;I&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="b8c443850902f5d8356fc89828d23c61765bb82b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NO_ARG_CHECK&lt;/code&gt; &amp;ndash; disable the type, kind and rank checking</source>
          <target state="translated">&lt;code&gt;NO_ARG_CHECK&lt;/code&gt; &amp;ndash; 유형, 종류 및 순위 확인 비활성화</target>
        </trans-unit>
        <trans-unit id="0fcf35fbb335eb65bd72079faa5675277b1460e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NUMERIC_STORAGE_SIZE&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;NUMERIC_STORAGE_SIZE&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="e036abaed2ee46fa5ab9bae7625520fd07a46371" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OMP_LIB&lt;/code&gt; provides the scalar default-integer named constant &lt;code&gt;openmp_version&lt;/code&gt; with a value of the form &lt;var&gt;yyyymm&lt;/var&gt;, where &lt;code&gt;yyyy&lt;/code&gt; is the year and &lt;var&gt;mm&lt;/var&gt; the month of the OpenMP version; for OpenMP v4.5 the value is &lt;code&gt;201511&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;OMP_LIB&lt;/code&gt; 는 상수라는 스칼라 기본 정수 제공 &lt;code&gt;openmp_version&lt;/code&gt; 형식의 값을 &lt;var&gt;yyyymm&lt;/var&gt; , &lt;code&gt;yyyy&lt;/code&gt; 연도이고 &lt;var&gt;mm&lt;/var&gt; 의 OpenMP 버전의 달; OpenMP v4.5의 경우 값은 &lt;code&gt;201511&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9aafd44c58dca4dd5d043f73f33b73bde8040610" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OMP_LIB_KINDS&lt;/code&gt; provides the following scalar default-integer named constants:</source>
          <target state="translated">&lt;code&gt;OMP_LIB_KINDS&lt;/code&gt; 는 다음 스칼라 기본 정수 이름 상수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="46029585c912a51a964a544bd7858a5965e0cea8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OPENACC&lt;/code&gt; provides the scalar default-integer named constant &lt;code&gt;openacc_version&lt;/code&gt; with a value of the form &lt;var&gt;yyyymm&lt;/var&gt;, where &lt;code&gt;yyyy&lt;/code&gt; is the year and &lt;var&gt;mm&lt;/var&gt; the month of the OpenACC version; for OpenACC v2.0 the value is &lt;code&gt;201306&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;OPENACC&lt;/code&gt; 는 상수라는 스칼라 기본 정수 제공 &lt;code&gt;openacc_version&lt;/code&gt; 형식의 값을 &lt;var&gt;yyyymm&lt;/var&gt; , &lt;code&gt;yyyy&lt;/code&gt; 연도이고 &lt;var&gt;mm&lt;/var&gt; OpenACC 버전의 달; OpenACC v2.0의 경우 값은 &lt;code&gt;201306&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ebadafda6e75ee1097f256d10237bcb4d5f103c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OUTPUT_UNIT&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;OUTPUT_UNIT&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="659e2a1d5a53032fc2eb481881b3d82b0875c7a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;POPCNT(I)&lt;/code&gt; returns the number of bits set (&amp;rsquo;1&amp;rsquo; bits) in the binary representation of &lt;code&gt;I&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;POPCNT(I)&lt;/code&gt; 이진 표현 설정 비트들의 수 ( &quot;1&quot;비트)를 리턴 &lt;code&gt;I&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="32c6f50388553662a8569434f8711388705ff908" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;POPPAR(I)&lt;/code&gt; returns parity of the integer &lt;code&gt;I&lt;/code&gt;, i.e. the parity of the number of bits set (&amp;rsquo;1&amp;rsquo; bits) in the binary representation of &lt;code&gt;I&lt;/code&gt;. It is equal to 0 if &lt;code&gt;I&lt;/code&gt; has an even number of bits set, and 1 for an odd number of &amp;rsquo;1&amp;rsquo; bits.</source>
          <target state="translated">&lt;code&gt;POPPAR(I)&lt;/code&gt; 정수의 복귀 패리티 &lt;code&gt;I&lt;/code&gt; 즉 이진 표현 ( '1'비트)를 설정 비트 수의 패리티, &lt;code&gt;I&lt;/code&gt; . 경우 0과 동일하다 &lt;code&gt;I&lt;/code&gt; 가 '1'비트들의 개수가 홀수 짝수 설정 비트 수, 및 1을 갖는다.</target>
        </trans-unit>
        <trans-unit id="5b9a5433cde8707912676b7944743758a553d355" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PRECISION(X)&lt;/code&gt; returns the decimal precision in the model of the type of &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;PRECISION(X)&lt;/code&gt; 는 &lt;code&gt;X&lt;/code&gt; 유형의 모델에서 10 진 정밀도를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="b9d0a8506986b9acfcb3d0ed380c0097b6f8bc68" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PRINT&lt;/code&gt; namelist is permitted. This causes an error if</source>
          <target state="translated">&lt;code&gt;PRINT&lt;/code&gt; 이름 목록이 허용됩니다. 이 경우 오류가 발생합니다</target>
        </trans-unit>
        <trans-unit id="e7bf736e8262344dcb9385beec637ba084fb08eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RADIX(X)&lt;/code&gt; returns the base of the model representing the entity &lt;var&gt;X&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;RADIX(X)&lt;/code&gt; 는 엔티티 &lt;var&gt;X&lt;/var&gt; 를 나타내는 모델의 기준을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0f76425d9c7cdefbd7b301628377fa91f1ccf490" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RAND(FLAG)&lt;/code&gt; returns a pseudo-random number from a uniform distribution between 0 and 1. If &lt;var&gt;FLAG&lt;/var&gt; is 0, the next number in the current sequence is returned; if &lt;var&gt;FLAG&lt;/var&gt; is 1, the generator is restarted by &lt;code&gt;CALL SRAND(0)&lt;/code&gt;; if &lt;var&gt;FLAG&lt;/var&gt; has any other value, it is used as a new seed with &lt;code&gt;SRAND&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RAND(FLAG)&lt;/code&gt; 는 0과 1 사이의 균일 분포에서 의사 난수를 반환합니다. &lt;var&gt;FLAG&lt;/var&gt; 가 0이면 현재 시퀀스의 다음 숫자가 반환됩니다. 만약 &lt;var&gt;FLAG&lt;/var&gt; 1, 발전기에 의해 다시 시작될 &lt;code&gt;CALL SRAND(0)&lt;/code&gt; ; 만약 &lt;var&gt;FLAG&lt;/var&gt; 다른 값을 가지며, 이는와 새로운 시드로 사용 &lt;code&gt;SRAND&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="338f978a9c7b42d70a3e5f7f36f20ffa6122cbff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RANGE(X)&lt;/code&gt; returns the decimal exponent range in the model of the type of &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RANGE(X)&lt;/code&gt; 는 &lt;code&gt;X&lt;/code&gt; 유형의 모델에서 소수 지수 범위를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="e167f850e13c887ac10b5efdf3bb40403988a8ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RANK(A)&lt;/code&gt; returns the rank of a scalar or array data object.</source>
          <target state="translated">&lt;code&gt;RANK(A)&lt;/code&gt; 는 스칼라 또는 배열 데이터 객체의 순위를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ce5c51e9cb26eba12cfc636ceceb5d3f6576300a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;REAL(A [, KIND])&lt;/code&gt; converts its argument &lt;var&gt;A&lt;/var&gt; to a real type. The &lt;code&gt;REALPART&lt;/code&gt; function is provided for compatibility with &lt;code&gt;g77&lt;/code&gt;, and its use is strongly discouraged.</source>
          <target state="translated">&lt;code&gt;REAL(A [, KIND])&lt;/code&gt; 는 인수 &lt;var&gt;A&lt;/var&gt; 를 실수 유형으로 변환 합니다. &lt;code&gt;REALPART&lt;/code&gt; 의 기능과의 호환성을 위해 제공되는 &lt;code&gt;g77&lt;/code&gt; , 그것의 사용은 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5879439285230f2aaa838b4b36b24e02e3abf32a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;REAL(A)&lt;/code&gt; is converted to a default real type if &lt;var&gt;A&lt;/var&gt; is an integer or real variable.</source>
          <target state="translated">&lt;code&gt;REAL(A)&lt;/code&gt; &lt;var&gt;A&lt;/var&gt; 가 정수 또는 실수 변수 인 경우 REAL (A) 는 기본 실수 유형으로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="161be9a0f21927d7283c11ee769b467a75d90607" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;REAL(A)&lt;/code&gt; is converted to a real type with the kind type parameter of &lt;var&gt;A&lt;/var&gt; if &lt;var&gt;A&lt;/var&gt; is a complex variable.</source>
          <target state="translated">&lt;code&gt;REAL(A)&lt;/code&gt; &lt;var&gt;A&lt;/var&gt; 가 복합 변수 인 경우 REAL (A) 는 종류 유형 매개 변수가 &lt;var&gt;A&lt;/var&gt; 인 실수 유형으로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="4ecca9999f933a52e1df478b924d1f33e03ad78a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;REAL(A, KIND)&lt;/code&gt; is converted to a real type with kind type parameter &lt;var&gt;KIND&lt;/var&gt; if &lt;var&gt;A&lt;/var&gt; is a complex, integer, or real variable.</source>
          <target state="translated">&lt;code&gt;REAL(A, KIND)&lt;/code&gt; &lt;var&gt;A&lt;/var&gt; 가 복소수, 정수 또는 실수 변수 이면 REAL (A, KIND) 는 종류 형식 매개 변수 &lt;var&gt;KIND&lt;/var&gt; 를 사용하여 실수 형식으로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="a1533ba94e1b550e316b2102396bbceb957d222a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;REAL32&lt;/code&gt;, &lt;code&gt;REAL64&lt;/code&gt;, &lt;code&gt;REAL128&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;REAL32&lt;/code&gt; , &lt;code&gt;REAL64&lt;/code&gt; , &lt;code&gt;REAL128&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5d0d8d8c0158ac99bb8fcc49a14e359a46e84b19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;REAL_KINDS&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;REAL_KINDS&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="53a86c265ee0227cebff97156ab11acb5ee85403" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RESULT = CTIME(TIME)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RESULT = CTIME(TIME)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b733a3e260ea92b0f5da5064d228e997b142347" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RRSPACING(X)&lt;/code&gt; returns the reciprocal of the relative spacing of model numbers near &lt;var&gt;X&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;RRSPACING(X)&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 근처의 모델 번호의 상대적 간격의 역수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="09a241acc8a13829527133543488750a38f51454" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RSHIFT&lt;/code&gt; returns a value corresponding to &lt;var&gt;I&lt;/var&gt; with all of the bits shifted right by &lt;var&gt;SHIFT&lt;/var&gt; places. If the absolute value of &lt;var&gt;SHIFT&lt;/var&gt; is greater than &lt;code&gt;BIT_SIZE(I)&lt;/code&gt;, the value is undefined. Bits shifted out from the right end are lost. The fill is arithmetic: the bits shifted in from the left end are equal to the leftmost bit, which in two&amp;rsquo;s complement representation is the sign bit.</source>
          <target state="translated">&lt;code&gt;RSHIFT&lt;/code&gt; 는 &lt;var&gt;SHIFT&lt;/var&gt; 자리 만큼 오른쪽으로 이동 된 모든 비트를 가진 &lt;var&gt;I&lt;/var&gt; 에 해당하는 값을 반환합니다 . &lt;var&gt;SHIFT&lt;/var&gt; 의 절대 값 이 &lt;code&gt;BIT_SIZE(I)&lt;/code&gt; 보다 큰 경우 값이 정의되지 않습니다. 오른쪽 끝에서 이동 된 비트는 손실됩니다. 채우기는 산술입니다. 왼쪽 끝에서 이동 된 비트는 가장 왼쪽 비트와 같으며, 2의 보수 표시는 부호 비트입니다.</target>
        </trans-unit>
        <trans-unit id="f200b88fa5407ae04634bc4145693f044351bf3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SCALE(X,I)&lt;/code&gt; returns &lt;code&gt;X * RADIX(X)**I&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SCALE(X,I)&lt;/code&gt; 는 &lt;code&gt;X * RADIX(X)**I&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8d1c14f94ecc13257771f2f57d506ccd909ffc05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SECNDS(X)&lt;/code&gt; gets the time in seconds from the real-time system clock. &lt;var&gt;X&lt;/var&gt; is a reference time, also in seconds. If this is zero, the time in seconds from midnight is returned. This function is non-standard and its use is discouraged.</source>
          <target state="translated">&lt;code&gt;SECNDS(X)&lt;/code&gt; 는 실시간 시스템 시계에서 시간을 초 단위로 가져옵니다. &lt;var&gt;X&lt;/var&gt; 는 초 단위의 참조 시간입니다. 이 값이 0이면 자정부터 초 단위의 시간이 반환됩니다. 이 기능은 비표준이며 사용을 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fe6e507f6b84988b21c73cfa30314e3e47004751" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SELECTED_CHAR_KIND(NAME)&lt;/code&gt; returns the kind value for the character set named &lt;var&gt;NAME&lt;/var&gt;, if a character set with such a name is supported, or &lt;em&gt;-1&lt;/em&gt; otherwise. Currently, supported character sets include &amp;ldquo;ASCII&amp;rdquo; and &amp;ldquo;DEFAULT&amp;rdquo;, which are equivalent, and &amp;ldquo;ISO_10646&amp;rdquo; (Universal Character Set, UCS-4) which is commonly known as Unicode.</source>
          <target state="translated">&lt;code&gt;SELECTED_CHAR_KIND(NAME)&lt;/code&gt; 은 이름이 같은 문자 세트가 지원되는 경우 이름이 &lt;var&gt;NAME&lt;/var&gt; 인 문자 세트의 종류 값을 리턴하고 그렇지 않으면 &lt;em&gt;-1을&lt;/em&gt; 리턴합니다 . 현재 지원되는 문자 집합에는&amp;ldquo;ASCII&amp;rdquo;및&amp;ldquo;DEFAULT&amp;rdquo;(동등한 문자) 및&amp;ldquo;ISO_10646&amp;rdquo;(Universal Character Set, UCS-4) (일반적으로 유니 코드)이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b7f490e9b8f5501236a29f61fd5e906032d0abe4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SELECTED_INT_KIND(R)&lt;/code&gt; return the kind value of the smallest integer type that can represent all values ranging from &lt;em&gt;-10^R&lt;/em&gt; (exclusive) to &lt;em&gt;10^R&lt;/em&gt; (exclusive). If there is no integer kind that accommodates this range, &lt;code&gt;SELECTED_INT_KIND&lt;/code&gt; returns &lt;em&gt;-1&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;SELECTED_INT_KIND(R)&lt;/code&gt; 는 &lt;em&gt;-10 ^ R&lt;/em&gt; (제외)에서 &lt;em&gt;10 ^ R&lt;/em&gt; (제외) 까지의 모든 값을 나타낼 수있는 가장 작은 정수 유형의 종류 값을 반환합니다 . 이 범위를 수용하는 정수 종류가 없으면 &lt;code&gt;SELECTED_INT_KIND&lt;/code&gt; 는 &lt;em&gt;-1을&lt;/em&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="86ab01c6fb24e14dfa50127fdff68346b787ccf5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SELECTED_REAL_KIND(P,R)&lt;/code&gt; returns the kind value of a real data type with decimal precision of at least &lt;code&gt;P&lt;/code&gt; digits, exponent range of at least &lt;code&gt;R&lt;/code&gt;, and with a radix of &lt;code&gt;RADIX&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SELECTED_REAL_KIND(P,R)&lt;/code&gt; 은 최소 &lt;code&gt;P&lt;/code&gt; 자릿수 의 소수 자릿수, 최소 &lt;code&gt;R&lt;/code&gt; 의 지수 범위 및 기수 &lt;code&gt;RADIX&lt;/code&gt; 를 가진 실제 데이터 유형의 종류 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="595f035f785e10946e5189c617dce1eba4270c7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SELECTED_REAL_KIND&lt;/code&gt; returns the value of the kind type parameter of a real data type with decimal precision of at least &lt;code&gt;P&lt;/code&gt; digits, a decimal exponent range of at least &lt;code&gt;R&lt;/code&gt;, and with the requested &lt;code&gt;RADIX&lt;/code&gt;. If the &lt;code&gt;RADIX&lt;/code&gt; parameter is absent, real kinds with any radix can be returned. If more than one real data type meet the criteria, the kind of the data type with the smallest decimal precision is returned. If no real data type matches the criteria, the result is</source>
          <target state="translated">&lt;code&gt;SELECTED_REAL_KIND&lt;/code&gt; 는 최소 &lt;code&gt;P&lt;/code&gt; 자리 10 진수 정밀도 , &lt;code&gt;R&lt;/code&gt; 이상 10 진수 지수 범위 및 요청 된 &lt;code&gt;RADIX&lt;/code&gt; 와 함께 실제 데이터 유형의 종류 유형 매개 변수 값을 리턴합니다 . 는 IF &lt;code&gt;RADIX&lt;/code&gt; 매개 변수가없는, 어떤 기수와 실제 종류가 반환 될 수있다. 둘 이상의 실제 데이터 유형이 기준을 충족하면 소수 정밀도가 가장 작은 데이터 유형이 리턴됩니다. 기준과 일치하는 실제 데이터 유형이 없으면 결과는</target>
        </trans-unit>
        <trans-unit id="e1bbfcbcd18c95cc3ee66b6973daf4e9c27d3562" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SET_EXPONENT(X, I)&lt;/code&gt; returns the real number whose fractional part is that that of &lt;var&gt;X&lt;/var&gt; and whose exponent part is &lt;var&gt;I&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;SET_EXPONENT(X, I)&lt;/code&gt; 는 소수 부분이 &lt;var&gt;X&lt;/var&gt; 의 소수 이고 지수 부분이 &lt;var&gt;I&lt;/var&gt; 인 실수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="56821a9919793fef3bc4e46855b1f8d1b34f530b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SHIFTA&lt;/code&gt; returns a value corresponding to &lt;var&gt;I&lt;/var&gt; with all of the bits shifted right by &lt;var&gt;SHIFT&lt;/var&gt; places. If the absolute value of &lt;var&gt;SHIFT&lt;/var&gt; is greater than &lt;code&gt;BIT_SIZE(I)&lt;/code&gt;, the value is undefined. Bits shifted out from the right end are lost. The fill is arithmetic: the bits shifted in from the left end are equal to the leftmost bit, which in two&amp;rsquo;s complement representation is the sign bit.</source>
          <target state="translated">&lt;code&gt;SHIFTA&lt;/code&gt; 는 모든 비트가 &lt;var&gt;SHIFT&lt;/var&gt; 자리 만큼 오른쪽으로 이동 된 &lt;var&gt;I&lt;/var&gt; 에 해당하는 값을 반환합니다 . &lt;var&gt;SHIFT&lt;/var&gt; 의 절대 값 이 &lt;code&gt;BIT_SIZE(I)&lt;/code&gt; 보다 큰 경우 값이 정의되지 않습니다. 오른쪽 끝에서 이동 된 비트는 손실됩니다. 채우기는 산술입니다. 왼쪽 끝에서 이동 된 비트는 가장 왼쪽 비트와 같으며, 2의 보수 표시는 부호 비트입니다.</target>
        </trans-unit>
        <trans-unit id="873181d5c5c1bb223c9c1d9fc4e6f20e5bf5ebc8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SHIFTL&lt;/code&gt; returns a value corresponding to &lt;var&gt;I&lt;/var&gt; with all of the bits shifted left by &lt;var&gt;SHIFT&lt;/var&gt; places. If the absolute value of &lt;var&gt;SHIFT&lt;/var&gt; is greater than &lt;code&gt;BIT_SIZE(I)&lt;/code&gt;, the value is undefined. Bits shifted out from the left end are lost, and bits shifted in from the right end are set to 0.</source>
          <target state="translated">&lt;code&gt;SHIFTL&lt;/code&gt; 은 모든 비트가 &lt;var&gt;SHIFT&lt;/var&gt; 자리 만큼 왼쪽으로 시프트 된 &lt;var&gt;I&lt;/var&gt; 에 해당하는 값을 리턴합니다 . &lt;var&gt;SHIFT&lt;/var&gt; 의 절대 값 이 &lt;code&gt;BIT_SIZE(I)&lt;/code&gt; 보다 큰 경우 값이 정의되지 않습니다. 왼쪽 끝에서 이동 된 비트는 손실되고 오른쪽 끝에서 이동 된 비트는 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="415e83f1e4be741205d3ad7038a323859fa9b2b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SHIFTR&lt;/code&gt; returns a value corresponding to &lt;var&gt;I&lt;/var&gt; with all of the bits shifted right by &lt;var&gt;SHIFT&lt;/var&gt; places. If the absolute value of &lt;var&gt;SHIFT&lt;/var&gt; is greater than &lt;code&gt;BIT_SIZE(I)&lt;/code&gt;, the value is undefined. Bits shifted out from the right end are lost, and bits shifted in from the left end are set to 0.</source>
          <target state="translated">&lt;code&gt;SHIFTR&lt;/code&gt; 은 &lt;var&gt;SHIFT&lt;/var&gt; 자리 만큼 오른쪽으로 이동 된 모든 비트를 가진 &lt;var&gt;I&lt;/var&gt; 에 해당하는 값을 반환합니다 . &lt;var&gt;SHIFT&lt;/var&gt; 의 절대 값 이 &lt;code&gt;BIT_SIZE(I)&lt;/code&gt; 보다 큰 경우 값이 정의되지 않습니다. 오른쪽 끝에서 이동 된 비트는 손실되고 왼쪽 끝에서 이동 된 비트는 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="fe385f6a177126d8892513c4bd3025f059b901c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SIGN(A,B)&lt;/code&gt; returns the value of &lt;var&gt;A&lt;/var&gt; with the sign of &lt;var&gt;B&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;SIGN(A,B)&lt;/code&gt; 는 &lt;var&gt;A&lt;/var&gt; 의 값 을 &lt;var&gt;B&lt;/var&gt; 의 부호로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="009ba41ca2ab9c32be906bd2bdce1737d32eae67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SIGNAL(NUMBER, HANDLER [, STATUS])&lt;/code&gt; causes external subroutine &lt;var&gt;HANDLER&lt;/var&gt; to be executed with a single integer argument when signal &lt;var&gt;NUMBER&lt;/var&gt; occurs. If &lt;var&gt;HANDLER&lt;/var&gt; is an integer, it can be used to turn off handling of signal &lt;var&gt;NUMBER&lt;/var&gt; or revert to its default action. See &lt;code&gt;signal(2)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SIGNAL(NUMBER, HANDLER [, STATUS])&lt;/code&gt; 는 신호 &lt;var&gt;NUMBER&lt;/var&gt; 가 발생할 때 단일 정수 인수로 외부 서브 루틴 &lt;var&gt;HANDLER&lt;/var&gt; 가 실행되도록 합니다. 경우 &lt;var&gt;HANDLER&lt;/var&gt; 는 정수, 신호의 처리를 해제하는 데 사용할 수있는 &lt;var&gt;NUMBER&lt;/var&gt; 의 기본 동작 또는 되돌립니다. &lt;code&gt;signal(2)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="be8b94d4a083977dc0c0cebd756ac36182826fae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SIN(X)&lt;/code&gt; computes the sine of &lt;var&gt;X&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;SIN(X)&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 의 사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="8adfd0c680916e48ba9637d13dea16b3acad6c7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SIND(X)&lt;/code&gt; computes the sine of &lt;var&gt;X&lt;/var&gt; in degrees.</source>
          <target state="translated">&lt;code&gt;SIND(X)&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 의 사인을 도 단위로 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="4ce94d3297ac6f47247cb0d8d8db020e3f82f398" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SINH(X)&lt;/code&gt; computes the hyperbolic sine of &lt;var&gt;X&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;SINH(X)&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 의 쌍곡 사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="84d4de5f26a9631a1c20a225e26fb7ace91a1fe1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SIZEOF(X)&lt;/code&gt; calculates the number of bytes of storage the expression &lt;code&gt;X&lt;/code&gt; occupies.</source>
          <target state="translated">&lt;code&gt;SIZEOF(X)&lt;/code&gt; 는 표현식 &lt;code&gt;X&lt;/code&gt; 가 차지하는 스토리지의 바이트 수를 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="d64ad3d3823457d1f9b04086f417d5ae4b9bfeee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SQRT(X)&lt;/code&gt; computes the square root of &lt;var&gt;X&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;SQRT(X)&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 의 제곱근을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="26122c2e710c310bc95a935297203d9d00a2355b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SRAND&lt;/code&gt; reinitializes the pseudo-random number generator called by &lt;code&gt;RAND&lt;/code&gt; and &lt;code&gt;IRAND&lt;/code&gt;. The new seed used by the generator is specified by the required argument &lt;var&gt;SEED&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;SRAND&lt;/code&gt; 는 &lt;code&gt;RAND&lt;/code&gt; 및 &lt;code&gt;IRAND&lt;/code&gt; 에 의해 호출 된 의사 난수 생성기를 다시 초기화합니다 . 생성기가 사용하는 새 시드는 필수 인수 &lt;var&gt;SEED&lt;/var&gt; 로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="4304dd07f28016bc3a0c326c08aed0b7f7a0d43c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;STATIC&lt;/code&gt; is exactly equivalent to &lt;code&gt;SAVE&lt;/code&gt;, and specifies that an entity should be allocated in static memory. As an example, &lt;code&gt;STATIC&lt;/code&gt; local variables will retain their values across multiple calls to a function.</source>
          <target state="translated">&lt;code&gt;STATIC&lt;/code&gt; 은 &lt;code&gt;SAVE&lt;/code&gt; 와 정확히 동일 하며 엔티티가 정적 메모리에 할당되도록 지정합니다. 예를 들어, &lt;code&gt;STATIC&lt;/code&gt; 로컬 변수는 함수에 대한 여러 호출에서 값을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="bc0122cc4bb188ce1882ffa2ffd58be737458c05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;STATUS&lt;/code&gt; is passed to the parent process on exit.</source>
          <target state="translated">&lt;code&gt;STATUS&lt;/code&gt; 가 상위 프로세스로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="a0aecedd7f2ead6059b29dede981acc0154aa45d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;STAT_FAILED_IMAGE&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;STAT_FAILED_IMAGE&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="8fe687732e362f8763a136f309610087d06f340c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;STAT_LOCKED&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;STAT_LOCKED&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="0196e407bbbc1c96ee862cbef0ecb4726794a148" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;STAT_LOCKED_OTHER_IMAGE&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;STAT_LOCKED_OTHER_IMAGE&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="f8c43bc122d3f5f7f501d9923184695f2e2dd14a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;STAT_STOPPED_IMAGE&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;STAT_STOPPED_IMAGE&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="fc82921fc124620db5fe056de02ed29f3422c8e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;STAT_UNLOCKED&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;STAT_UNLOCKED&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="63a29e4005a0d5b2599123cc7478f6043c903308" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;STDCALL&lt;/code&gt; &amp;ndash; convention where the called procedure pops the stack</source>
          <target state="translated">&lt;code&gt;STDCALL&lt;/code&gt; &amp;ndash; 호출 된 프로 시저가 스택을 팝하는 규칙</target>
        </trans-unit>
        <trans-unit id="1424f6d841ac5af4424ea636ab970d162d968c5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SWAP&lt;/code&gt; Swap between little- and big-endian.</source>
          <target state="translated">&lt;code&gt;SWAP&lt;/code&gt; 리틀 엔디안과 빅 엔디안 간 스왑.</target>
        </trans-unit>
        <trans-unit id="1afa8cf5f307d30094407a70bb62a0007fa9db1d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TAN(X)&lt;/code&gt; computes the tangent of &lt;var&gt;X&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;TAN(X)&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 의 탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="ad8aa63b3446ed2eecaa516834474f336bfe0d86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TAND(X)&lt;/code&gt; computes the tangent of &lt;var&gt;X&lt;/var&gt; in degrees.</source>
          <target state="translated">&lt;code&gt;TAND(X)&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 의 탄젠트를 도 단위로 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="10fbdaebd08d5ad576696dbacc867af41ecd8619" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TANH(X)&lt;/code&gt; computes the hyperbolic tangent of &lt;var&gt;X&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;TANH(X)&lt;/code&gt; 는 &lt;var&gt;X&lt;/var&gt; 의 쌍곡 탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="3e35f6913f306b774aada21fa3a781b4f5a866fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TIME = DTIME(VALUES)&lt;/code&gt;, (not recommended).</source>
          <target state="translated">&lt;code&gt;TIME = DTIME(VALUES)&lt;/code&gt; , (권장하지 않음).</target>
        </trans-unit>
        <trans-unit id="3b8e653a627338d4fb971de864f6b883a3d4ef48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TIME = ETIME(VALUES)&lt;/code&gt;, (not recommended).</source>
          <target state="translated">&lt;code&gt;TIME = ETIME(VALUES)&lt;/code&gt; , (권장되지 않음).</target>
        </trans-unit>
        <trans-unit id="25bbc647d57152b46b7c13c9c7c35b2840725503" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TIME&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;TIME&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="cd7534023c9ba93bd78e5e0beeb602c1fac186ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TINY(X)&lt;/code&gt; returns the smallest positive (non zero) number in the model of the type of &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TINY(X)&lt;/code&gt; 는 &lt;code&gt;X&lt;/code&gt; 유형의 모델에서 가장 작은 양수 (0이 아님) 숫자를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="df817ef457f6b9faccc2f82d9476811a3d079560" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TRAILZ&lt;/code&gt; returns the number of trailing zero bits of an integer.</source>
          <target state="translated">&lt;code&gt;TRAILZ&lt;/code&gt; 는 정수의 후행 0 비트 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="bd39c461d8afa14555f0f5bdcd2b2005d0e7e9e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VALUE(1)&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;VALUE(1)&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="1aec4c8c43e1ead27ade16a3cadabe017ae7bf9f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VALUE(2)&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;VALUE(2)&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="f6b24262260fbae025a67e5517466206989bb09e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VALUE(3)&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;VALUE(3)&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="e0f1363e2fc379de441bf8018678f2d4ece44d8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VALUE(4)&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;VALUE(4)&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="d4a89f6a785870fcb3afa3440f51d6de9489aa1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VALUE(5)&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;VALUE(5)&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="126b7dd589265b50b65b5f0c81d152c2ee13bdb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VALUE(6)&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;VALUE(6)&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="ac09d2738bfd89f785c0f72c31a5a4aa8806a7ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VALUE(7)&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;VALUE(7)&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="ff751b7e9e4d82f4e81e80dd2bca9aaac48650dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VALUE(8)&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;VALUE(8)&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="4c0b01cbefd110ee5a18812ad4d2ef19362a48b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VALUES(1)&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;VALUES(1)&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="721bbcf648bdd8e6705c5df34cbf3376ebcc5de1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VALUES(2)&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;VALUES(2)&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="c31e753d3b1c265dcf278506861be86b0065feca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__asm__ __volatile__ (&quot;&quot;:::&quot;memory&quot;)&lt;/code&gt; to prevent code movements.</source>
          <target state="translated">&lt;code&gt;__asm__ __volatile__ (&quot;&quot;:::&quot;memory&quot;)&lt;/code&gt; 는 코드 이동을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="56b728657960d86d7c4df8eaecfd3a1d1e5262c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_gfortran_set_args&lt;/code&gt; saves the command-line arguments; this initialization is required if any of the command-line intrinsics is called. Additionally, it shall be called if backtracing is enabled (see &lt;code&gt;_gfortran_set_options&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;_gfortran_set_args&lt;/code&gt; 는 명령 행 인수를 저장합니다. 이 초기화는 명령 줄 내장 함수가 호출 된 경우 필요합니다. 또한 역 추적이 활성화 된 경우 호출됩니다 ( &lt;code&gt;_gfortran_set_options&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="63d68a0c02e891d93f58b29b2bcfbee61f13abc2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_gfortran_set_convert&lt;/code&gt; set the representation of data for unformatted files.</source>
          <target state="translated">&lt;code&gt;_gfortran_set_convert&lt;/code&gt; 는 포맷되지 않은 파일의 데이터 표현을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="1edfe62a9ccdb94ce1a00748494d9234bc63ad51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_gfortran_set_fpe&lt;/code&gt; enables floating point exception traps for the specified exceptions. On most systems, this will result in a SIGFPE signal being sent and the program being aborted.</source>
          <target state="translated">&lt;code&gt;_gfortran_set_fpe&lt;/code&gt; 는 지정된 예외에 대해 부동 소수점 예외 트랩을 활성화합니다. 대부분의 시스템에서 SIGFPE 신호가 전송되고 프로그램이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="820909460c80edc43bd2edd6dc310393a5f51ea2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_gfortran_set_max_subrecord_length&lt;/code&gt; set the maximum length for a subrecord. This option only makes sense for testing and debugging of unformatted I/O.</source>
          <target state="translated">&lt;code&gt;_gfortran_set_max_subrecord_length&lt;/code&gt; 는 서브 레코드 의 최대 길이를 설정합니다. 이 옵션은 형식화되지 않은 I / O의 테스트 및 디버깅에만 적합합니다.</target>
        </trans-unit>
        <trans-unit id="f69e8572ae4a070e32e2f1ec33c5511701d155ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_gfortran_set_options&lt;/code&gt; sets several flags related to the Fortran standard to be used, whether backtracing should be enabled and whether range checks should be performed. The syntax allows for upward compatibility since the number of passed flags is specified; for non-passed flags, the default value is used. See also see &lt;a href=&quot;code-gen-options#Code-Gen-Options&quot;&gt;Code Gen Options&lt;/a&gt;. Please note that not all flags are actually used.</source>
          <target state="translated">&lt;code&gt;_gfortran_set_options&lt;/code&gt; 는 포트 추적 표준과 관련된 몇 가지 플래그, 백 트레이싱 사용 여부 및 범위 확인 수행 여부를 설정합니다. 전달 된 플래그의 수가 지정되므로 구문은 상위 호환성을 허용합니다. 전달되지 않은 플래그의 경우 기본값이 사용됩니다. &lt;a href=&quot;code-gen-options#Code-Gen-Options&quot;&gt;코드 생성 옵션&lt;/a&gt; 도 참조하십시오 . 모든 플래그가 실제로 사용되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0f995879cc0a1da4d98ad3c583df986a2f6d70ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_gfortran_set_record_marker&lt;/code&gt; sets the length of record markers for unformatted files.</source>
          <target state="translated">&lt;code&gt;_gfortran_set_record_marker&lt;/code&gt; 는 포맷되지 않은 파일의 레코드 마커 길이를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="305c73d244dd90dd218d2e60cdd91cace80b846a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signed char&lt;/code&gt;/&lt;code&gt;unsigned char&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;signed char&lt;/code&gt; / &lt;code&gt;unsigned char&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9a03b6ac1c59a374267d6f867b7b1689491e5485" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Array Type&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;배열 유형&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c4013d58a1302800fb0cd3e02cd2dacd842bdcdd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Boundary Value&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;경계 값&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="43167334cf7bea283baba4bd19b3ec1bbcfd97d5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Caution: This option can lead to long compile times and excessively large object files.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;주의 :이 옵션을 사용하면 컴파일 시간이 길어지고 개체 파일이 지나치게 커질 수 있습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="681e5f25c4771cb0667a4e539338028ea19f116a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Caution:&lt;/em&gt; It is not a good idea to mix Fortran code compiled with</source>
          <target state="translated">&lt;em&gt;주의 :&lt;/em&gt; Fortran 코드와 컴파일 된 코드를 혼합하여 사용하는 것은 좋지 않습니다</target>
        </trans-unit>
        <trans-unit id="5143f3f427bdf8385df3ba587d4af85098970c93" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Caution:&lt;/em&gt; This will break code which passes intrinsic functions of type default &lt;code&gt;REAL&lt;/code&gt; or &lt;code&gt;COMPLEX&lt;/code&gt; as actual arguments, as the library implementations use the</source>
          <target state="translated">&lt;em&gt;주의 :&lt;/em&gt; 라이브러리 구현에서 사용하는 기본 &lt;code&gt;REAL&lt;/code&gt; 또는 &lt;code&gt;COMPLEX&lt;/code&gt; 유형의 고유 함수 를 실제 인수로 전달하는 코드가 중단 됩니다.</target>
        </trans-unit>
        <trans-unit id="1b56a57b458342c8a38e3bdd0e593d7cf950ce49" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Caution&lt;/em&gt;: The default behavior of GNU Fortran is incompatible with &lt;code&gt;f2c&lt;/code&gt; and &lt;code&gt;g77&lt;/code&gt;, please use the</source>
          <target state="translated">&lt;em&gt;주의&lt;/em&gt; : GNU Fortran의 기본 동작은 &lt;code&gt;f2c&lt;/code&gt; 및 &lt;code&gt;g77&lt;/code&gt; 과 호환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="eaa55b6f1fdb7d01eaa68d24d7eddef02fc0ce5e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTES&lt;/em&gt; The member &lt;code&gt;STATIC_ARRAY_TYPE&lt;/code&gt; is used only when the &lt;code&gt;TYPE&lt;/code&gt; is &lt;code&gt;CAF_REF_STATIC_ARRAY&lt;/code&gt;. The member gives the type of the data referenced. Because no array descriptor is available for a descriptor-less array and type conversion still needs to take place the type is transported here.</source>
          <target state="translated">&lt;em&gt;참고 &lt;/em&gt; &lt;code&gt;STATIC_ARRAY_TYPE&lt;/code&gt; 멤버 는 &lt;code&gt;TYPE&lt;/code&gt; 이 &lt;code&gt;CAF_REF_STATIC_ARRAY&lt;/code&gt; 인 경우에만 사용됩니다 . 멤버는 참조 된 데이터의 유형을 제공합니다. 디스크립터가없는 어레이에 사용할 수있는 어레이 디스크립터가없고 유형 변환이 여전히 수행되어야하므로 여기에서 유형이 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="2c0cda60ed98482d4ecedc90513448da3a393da4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note that the values specified via the GFORTRAN_CONVERT_UNIT environment variable will override the CONVERT specifier in the open statement&lt;/em&gt;. This is to give control over data formats to users who do not have the source code of their program available.</source>
          <target state="translated">&lt;em&gt;GFORTRAN_CONVERT_UNIT 환경 변수를 통해 지정된 값은 open 문에서 CONVERT 지정자를 재정의합니다&lt;/em&gt; . 프로그램의 소스 코드를 사용할 수없는 사용자에게 데이터 형식을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d39e0ef65defe2ad17c0cc27bc012057f55c3c5d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This option has an effect only when used in the main program. The &lt;code&gt;CONVERT&lt;/code&gt; specifier and the GFORTRAN_CONVERT_UNIT environment variable override the default specified by &lt;samp&gt;-fconvert&lt;/samp&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;이 옵션은 기본 프로그램에서 사용될 때만 적용됩니다. &lt;code&gt;CONVERT&lt;/code&gt; 의 지정 및 GFORTRAN_CONVERT_UNIT 환경 변수에 의해 지정된 기본값을 대체&lt;samp&gt;-fconvert&lt;/samp&gt;.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a1b63991bb4a00ea7afefeaeb3bb74cd606fdc52" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Warning:&lt;/em&gt; this intrinsic does not increase the range of the timing values over that returned by &lt;code&gt;clock(3)&lt;/code&gt;. On a system with a 32-bit &lt;code&gt;clock(3)&lt;/code&gt;, &lt;code&gt;MCLOCK8&lt;/code&gt; will return a 32-bit value, even though it is converted to a 64-bit &lt;code&gt;INTEGER(8)&lt;/code&gt; value. That means overflows of the 32-bit value can still occur. Therefore, the values returned by this intrinsic might be or become negative or numerically less than previous values during a single run of the compiled program.</source>
          <target state="translated">&lt;em&gt;경고 :&lt;/em&gt; 이 내장 함수는 &lt;code&gt;clock(3)&lt;/code&gt; 이 반환 한 타이밍 값의 범위를 늘리지 않습니다 . 32 비트 &lt;code&gt;clock(3)&lt;/code&gt; 에서 &lt;code&gt;MCLOCK8&lt;/code&gt; 은 64 비트 &lt;code&gt;INTEGER(8)&lt;/code&gt; 값으로 변환 되어도 32 비트 값을 반환 합니다. 이는 32 비트 값의 오버플로가 여전히 발생할 수 있음을 의미합니다. 따라서이 내장 함수에서 반환 된 값은 컴파일 된 프로그램을 한 번 실행하는 동안 이전 값보다 음수이거나 숫자보다 작을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9897a33ca49c27b3245df549f301ec0bd47d73c3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Warning:&lt;/em&gt; this intrinsic does not increase the range of the timing values over that returned by &lt;code&gt;time(3)&lt;/code&gt;. On a system with a 32-bit &lt;code&gt;time(3)&lt;/code&gt;, &lt;code&gt;TIME8&lt;/code&gt; will return a 32-bit value, even though it is converted to a 64-bit &lt;code&gt;INTEGER(8)&lt;/code&gt; value. That means overflows of the 32-bit value can still occur. Therefore, the values returned by this intrinsic might be or become negative or numerically less than previous values during a single run of the compiled program.</source>
          <target state="translated">&lt;em&gt;경고 :&lt;/em&gt; 이 내장 함수는 &lt;code&gt;time(3)&lt;/code&gt; 이 반환 한 타이밍 값의 범위를 늘리지 않습니다 . 32 비트 &lt;code&gt;time(3)&lt;/code&gt; 에서 &lt;code&gt;TIME8&lt;/code&gt; 은 64 비트 &lt;code&gt;INTEGER(8)&lt;/code&gt; 값으로 변환 되더라도 32 비트 값을 리턴 합니다. 이는 32 비트 값의 오버플로가 여전히 발생할 수 있음을 의미합니다. 따라서이 내장 함수에서 반환 된 값은 컴파일 된 프로그램을 한 번 실행하는 동안 이전 값보다 음수이거나 숫자보다 작을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8a1da3be4ba23514dd6ecbd71b3abb864339d4c" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;A2&lt;/var&gt;, &lt;var&gt;A3&lt;/var&gt;, ...</source>
          <target state="translated">&lt;var&gt;A2&lt;/var&gt; , &lt;var&gt;A3&lt;/var&gt; , ...</target>
        </trans-unit>
        <trans-unit id="4ee5bbddf24cd2f1ce8f56da2544afbb3756a812" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;COUNT_RATE&lt;/var&gt; is system dependent and can vary depending on the kind of the arguments. For &lt;var&gt;kind=4&lt;/var&gt; arguments (and smaller integer kinds), &lt;var&gt;COUNT&lt;/var&gt; represents milliseconds, while for &lt;var&gt;kind=8&lt;/var&gt; arguments (and larger integer kinds), &lt;var&gt;COUNT&lt;/var&gt; typically represents micro- or nanoseconds depending on resolution of the underlying platform clock. &lt;var&gt;COUNT_MAX&lt;/var&gt; usually equals &lt;code&gt;HUGE(COUNT_MAX)&lt;/code&gt;. Note that the millisecond resolution of the &lt;var&gt;kind=4&lt;/var&gt; version implies that the &lt;var&gt;COUNT&lt;/var&gt; will wrap around in roughly 25 days. In order to avoid issues with the wrap around and for more precise timing, please use the &lt;var&gt;kind=8&lt;/var&gt; version.</source>
          <target state="translated">&lt;var&gt;COUNT_RATE&lt;/var&gt; 는 시스템에 따라 다르며 인수의 종류에 따라 달라질 수 있습니다. 들면 &lt;var&gt;kind=4&lt;/var&gt; 인자 (작은 정수 종), &lt;var&gt;COUNT&lt;/var&gt; 는 위해 동안 밀리 초를 나타내는 &lt;var&gt;kind=8&lt;/var&gt; 인자 (큰 정수 종), &lt;var&gt;COUNT&lt;/var&gt; 일반적으로 기본 플랫폼 클럭의 해상도에 따라 마이크로 또는 나노 나타낸다. &lt;var&gt;COUNT_MAX&lt;/var&gt; 는 보통 &lt;code&gt;HUGE(COUNT_MAX)&lt;/code&gt; 와 같습니다 . &lt;var&gt;kind=4&lt;/var&gt; 버전 의 밀리 초 해상도 는 &lt;var&gt;COUNT&lt;/var&gt; 가 대략 25 일 안에 줄어드는 것을 의미합니다 . 랩과 관련된 문제를 피하고보다 정확한 타이밍을 위해 &lt;var&gt;kind=8&lt;/var&gt; 버전을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2651458b14f3a206b71081da103df2d59ef259fd" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;POINTER&lt;/var&gt; shall have the &lt;code&gt;POINTER&lt;/code&gt; attribute and it can be of any type.</source>
          <target state="translated">&lt;var&gt;POINTER&lt;/var&gt; 는 &lt;code&gt;POINTER&lt;/code&gt; 속성을 가지며 모든 유형이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96e21d99d5f38c3ef4326174f022376976774528" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;TARGET&lt;/var&gt; and &lt;var&gt;POINTER&lt;/var&gt; have the same shape, are not zero-sized arrays, are arrays whose elements are not zero-sized storage sequences, and &lt;var&gt;TARGET&lt;/var&gt; and &lt;var&gt;POINTER&lt;/var&gt; occupy the same storage units in array element order. As in case(B), the result is false, if &lt;var&gt;POINTER&lt;/var&gt; is disassociated.</source>
          <target state="translated">&lt;var&gt;TARGET&lt;/var&gt; 과 &lt;var&gt;POINTER&lt;/var&gt; 는 모양이 같고 크기가 0 인 배열이 아니며 요소가 크기가 0 인 스토리지 시퀀스가 ​​아닌 배열이며 &lt;var&gt;TARGET&lt;/var&gt; 과 &lt;var&gt;POINTER&lt;/var&gt; 가 배열 요소 순서대로 동일한 저장 장치를 차지합니다. 경우 (B)에서와 같이 &lt;var&gt;POINTER&lt;/var&gt; 가 연결 해제 되면 결과는 false 입니다.</target>
        </trans-unit>
        <trans-unit id="34705e75ffac67dad6c5a3b989952734ad512473" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;TARGET&lt;/var&gt; is not a zero-sized storage sequence and the target associated with &lt;var&gt;POINTER&lt;/var&gt; occupies the same storage units. If &lt;var&gt;POINTER&lt;/var&gt; is disassociated, the result is false.</source>
          <target state="translated">&lt;var&gt;TARGET&lt;/var&gt; 은 제로 크기의 스토리지 시퀀스가 ​​아니며 &lt;var&gt;POINTER&lt;/var&gt; 와 연관된 대상 이 동일한 스토리지 유닛을 차지합니다. 경우 &lt;var&gt;POINTER&lt;/var&gt; 해리되어, 결과는 false입니다.</target>
        </trans-unit>
        <trans-unit id="1740be202ff525e467643eb2a6c751c2bf38d648" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;VALUES&lt;/var&gt; and &lt;var&gt;TIME&lt;/var&gt; are &lt;code&gt;INTENT(OUT)&lt;/code&gt; and provide the following:</source>
          <target state="translated">&lt;var&gt;VALUES&lt;/var&gt; 와 &lt;var&gt;TIME&lt;/var&gt; 은 &lt;code&gt;INTENT(OUT)&lt;/code&gt; 이며 다음을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6725676eba89c36800e176d38b930bb9884d07b3" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;VALUES&lt;/var&gt; is &lt;code&gt;INTENT(OUT)&lt;/code&gt; and provides the following:</source>
          <target state="translated">&lt;var&gt;VALUES&lt;/var&gt; 는 &lt;code&gt;INTENT(OUT)&lt;/code&gt; 이며 다음을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="56a8df010524098ddf85dc494692cfc7f2b9d9ca" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;Y&lt;/var&gt; shall be of the same type and kind as &lt;var&gt;X&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;Y&lt;/var&gt; 는 &lt;var&gt;X&lt;/var&gt; 와 유형 및 종류가 동일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="db3b7a83065dde4b4ac738556770ee6e862e2c8a" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;len&lt;/var&gt; blanks.</source>
          <target state="translated">&lt;var&gt;len&lt;/var&gt; 블랭크.</target>
        </trans-unit>
        <trans-unit id="e5b8cc2bf473716ee73591a5c5168397ed1e6b3e" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;option&lt;/var&gt;[0]</source>
          <target state="translated">&lt;var&gt;option&lt;/var&gt;[0]</target>
        </trans-unit>
        <trans-unit id="f3448aa319fc77e94d173d269808b6a5a31db353" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;option&lt;/var&gt;[1]</source>
          <target state="translated">&lt;var&gt;option&lt;/var&gt;[1]</target>
        </trans-unit>
        <trans-unit id="869f684ad5a86849295f821ee0485870c407cadd" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;option&lt;/var&gt;[2]</source>
          <target state="translated">&lt;var&gt;option&lt;/var&gt;[2]</target>
        </trans-unit>
        <trans-unit id="7d4b266d1c621478bce018e88048d29940277e4a" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;option&lt;/var&gt;[3]</source>
          <target state="translated">&lt;var&gt;option&lt;/var&gt;[3]</target>
        </trans-unit>
        <trans-unit id="74443c59a5f6a48ae6e93d29851d053a201ce638" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;option&lt;/var&gt;[4]</source>
          <target state="translated">&lt;var&gt;option&lt;/var&gt;[4]</target>
        </trans-unit>
        <trans-unit id="01e66c0254ac76b7b05d0aea9c7235b7b5832962" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;option&lt;/var&gt;[5]</source>
          <target state="translated">&lt;var&gt;option&lt;/var&gt;[5]</target>
        </trans-unit>
        <trans-unit id="6479e5aec3834693dbe338465103440606e6b831" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;option&lt;/var&gt;[6]</source>
          <target state="translated">&lt;var&gt;option&lt;/var&gt;[6]</target>
        </trans-unit>
        <trans-unit id="334b08d5454c2a3a52b0d2ed6ebe54f535d91e07" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;option&lt;/var&gt;[7]</source>
          <target state="translated">&lt;var&gt;option&lt;/var&gt;[7]</target>
        </trans-unit>
        <trans-unit id="b4d7850b93156c2e3589efc550056c58f670b40a" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;option&lt;/var&gt;[8]</source>
          <target state="translated">&lt;var&gt;option&lt;/var&gt;[8]</target>
        </trans-unit>
        <trans-unit id="4b24e7eaf919998f8c6849fcfd67fdc1091d902f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CHARACTER&lt;/code&gt; variable is declared with negative length.</source>
          <target state="translated">&lt;code&gt;CHARACTER&lt;/code&gt; 변수는 음의 길이가 선언된다.</target>
        </trans-unit>
        <trans-unit id="b3a699accf48741320f41b458b33c4c3c3189f05" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;LOGICAL(KIND=N)&lt;/code&gt; variable is represented as an &lt;code&gt;INTEGER(KIND=N)&lt;/code&gt; variable, however, with only two permissible values: &lt;code&gt;1&lt;/code&gt; for &lt;code&gt;.TRUE.&lt;/code&gt; and &lt;code&gt;0&lt;/code&gt; for &lt;code&gt;.FALSE.&lt;/code&gt;. Any other integer value results in undefined behavior.</source>
          <target state="translated">&lt;code&gt;LOGICAL(KIND=N)&lt;/code&gt; 변수는로 표현 &lt;code&gt;INTEGER(KIND=N)&lt;/code&gt; : 두 개의 허용 가능한 값으로, 그러나, 변수 &lt;code&gt;1&lt;/code&gt; 대 &lt;code&gt;.TRUE.&lt;/code&gt; 및 &lt;code&gt;0&lt;/code&gt; 에 대한 &lt;code&gt;.FALSE.&lt;/code&gt; . 다른 정수 값은 정의되지 않은 동작을 초래합니다.</target>
        </trans-unit>
        <trans-unit id="b060b157ad10193f46dc2409611856cdcd3fb445" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;UNION&lt;/code&gt; declaration occurs within a structure; within the definition of each union is a number of &lt;code&gt;MAP&lt;/code&gt; blocks. Each &lt;code&gt;MAP&lt;/code&gt; shares storage with its sibling maps (in the same union), and the size of the union is the size of the largest map within it, just as with unions in C. The major difference is that component references do not indicate which union or map the component is in (the compiler gets to figure that out).</source>
          <target state="translated">&lt;code&gt;UNION&lt;/code&gt; 선언 구조 내에서 발생; 각 조합의 정의에는 여러 &lt;code&gt;MAP&lt;/code&gt; 블록이 있습니다. 각 &lt;code&gt;MAP&lt;/code&gt; 는 동위 맵에서 동위 맵과 스토리지를 공유하며 C의 유니온과 마찬가지로 유니온의 크기는 맵에서 가장 큰 맵의 크기입니다. 또는 구성 요소가 있는지도 (컴파일러가 알아 내야 함)</target>
        </trans-unit>
        <trans-unit id="ff073bece1e14a6b5f7a33381b21b7ecf1bfd38b" translate="yes" xml:space="preserve">
          <source>A Cray pointer may also point to a function or a subroutine. For example, the following excerpt is valid:</source>
          <target state="translated">Cray 포인터는 함수 또는 서브 루틴을 가리킬 수도 있습니다. 예를 들어 다음 발췌문이 유효합니다.</target>
        </trans-unit>
        <trans-unit id="143685a891792082db88f46a4dc6472aab068f8b" translate="yes" xml:space="preserve">
          <source>A LOGICAL SELECT construct has three CASE statements.</source>
          <target state="translated">LOGICAL SELECT 구문에는 세 개의 CASE 문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="770c0967c0cfd83545816b8f8d09605a432bdfb6" translate="yes" xml:space="preserve">
          <source>A TRANSFER specifies a source that is shorter than the destination.</source>
          <target state="translated">TRANSFER는 대상보다 짧은 소스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="a395b0e263933394481aeb955d7fb9ece603feac" translate="yes" xml:space="preserve">
          <source>A chain of references to address the allocatable or pointer component in the derived type coarray. The object reference needs to be a scalar or a full array reference, respectively.</source>
          <target state="translated">파생 된 유형 coarray에서 할당 가능 또는 포인터 구성 요소를 처리하기위한 참조 체인. 객체 참조는 각각 스칼라 또는 전체 배열 참조 여야합니다.</target>
        </trans-unit>
        <trans-unit id="c12b1cb82ddfa1f408d9a33bbc20fb8b6469a18d" translate="yes" xml:space="preserve">
          <source>A collection of run-time libraries. These libraries contain the machine code needed to support capabilities of the Fortran language that are not directly provided by the machine code generated by the &lt;code&gt;gfortran&lt;/code&gt; compilation phase, such as intrinsic functions and subroutines, and routines for interaction with files and the operating system.</source>
          <target state="translated">런타임 라이브러리 모음. 이 라이브러리에는 내장 함수 및 서브 루틴과 같은 &lt;code&gt;gfortran&lt;/code&gt; 컴파일 단계에서 생성 된 머신 코드에 의해 직접 제공되지 않는 포트란 언어의 기능을 지원하는 데 필요한 머신 코드가 포함되어 있으며 파일 및 운영 체제와의 상호 작용을위한 루틴이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3df78e31352f601736d816cc10dd3fc3ba4cb71" translate="yes" xml:space="preserve">
          <source>A default &lt;code&gt;INTEGER&lt;/code&gt; array with 9 elements, with &lt;code&gt;INTENT(OUT)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;INTENT(OUT)&lt;/code&gt; 9 개의 요소가 있는 기본 &lt;code&gt;INTEGER&lt;/code&gt; 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="0487241e4171bd86f6a4cab5129074e6a24c7443" translate="yes" xml:space="preserve">
          <source>A disassociated pointer.</source>
          <target state="translated">분리 된 포인터.</target>
        </trans-unit>
        <trans-unit id="85c232310e18bedafdeffa5921ae68abd0ebf55d" translate="yes" xml:space="preserve">
          <source>A matching implementation for &lt;code&gt;get_values&lt;/code&gt; in Fortran, that correctly receives the procedure pointer from C and is able to call it, is given in the following &lt;code&gt;MODULE&lt;/code&gt;:</source>
          <target state="translated">C에서 프로 시저 포인터를 올바르게 수신하고이를 호출 할 수있는 Fortran의 &lt;code&gt;get_values&lt;/code&gt; 에 대한 일치 구현 은 다음 &lt;code&gt;MODULE&lt;/code&gt; 에 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="e63491f5a07b078c142fbabf183e9c64289542da" translate="yes" xml:space="preserve">
          <source>A missing mode for an exception is taken to mean &lt;code&gt;BIG_ENDIAN&lt;/code&gt;. Examples of values for &lt;code&gt;GFORTRAN_CONVERT_UNIT&lt;/code&gt; are:</source>
          <target state="translated">예외에 대한 누락 모드는 &lt;code&gt;BIG_ENDIAN&lt;/code&gt; 을 의미 합니다. &lt;code&gt;GFORTRAN_CONVERT_UNIT&lt;/code&gt; 값의 예 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1ebaf59224bf3b5a2e4f4da54ce7a28edd6a0c5b" translate="yes" xml:space="preserve">
          <source>A new scalar of type &lt;code&gt;CHARACTER&lt;/code&gt; built up from &lt;var&gt;NCOPIES&lt;/var&gt; copies of &lt;var&gt;STRING&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;STRING&lt;/var&gt; 의 &lt;var&gt;NCOPIES&lt;/var&gt; 사본 에서 &lt;code&gt;CHARACTER&lt;/code&gt; 유형의 새 스칼라가 빌드되었습니다 .</target>
        </trans-unit>
        <trans-unit id="53c31d9c6b19034432143d78dcb8480b2bc9a6d5" translate="yes" xml:space="preserve">
          <source>A pointer may be modified during the course of a program, and this will change the location to which the pointee refers. However, when pointees are passed as arguments, they are treated as ordinary variables in the invoked function. Subsequent changes to the pointer will not change the base address of the array that was passed.</source>
          <target state="translated">프로그램이 진행되는 동안 포인터가 수정 될 수 있으며, 이렇게하면 포인트가 참조하는 위치가 변경됩니다. 그러나 포인트가 인수로 전달되면 호출 된 함수에서 일반 변수로 처리됩니다. 이후에 포인터를 변경해도 전달 된 어레이의 기본 주소는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cdd7c39a6d209284863a26a436f2ba9bf6e42b51" translate="yes" xml:space="preserve">
          <source>A scalar of type &lt;code&gt;CHARACTER&lt;/code&gt; and of the default kind.</source>
          <target state="translated">&lt;code&gt;CHARACTER&lt;/code&gt; 유형 및 기본 유형의 스칼라입니다 .</target>
        </trans-unit>
        <trans-unit id="e0ff62ca3a0502c7aa87a8cf5b29d744f4667051" translate="yes" xml:space="preserve">
          <source>A scalar of type &lt;code&gt;CHARACTER&lt;/code&gt; which length is that of &lt;var&gt;STRING&lt;/var&gt; less the number of trailing blanks.</source>
          <target state="translated">길이가 &lt;var&gt;STRING&lt;/var&gt; 인 &lt;code&gt;CHARACTER&lt;/code&gt; 유형의 스칼라는 후미 공백의 수를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="010c9adc73be2adba1d910ce59fc10b488d4bcb7" translate="yes" xml:space="preserve">
          <source>A variable &lt;code&gt;FORMAT&lt;/code&gt; expression is format statement which includes angle brackets enclosing a Fortran expression: &lt;code&gt;FORMAT(I&amp;lt;N&amp;gt;)&lt;/code&gt;. GNU Fortran does not support this legacy extension. The effect of variable format expressions can be reproduced by using the more powerful (and standard) combination of internal output and string formats. For example, replace a code fragment like this:</source>
          <target state="translated">변수 &lt;code&gt;FORMAT&lt;/code&gt; 표현식은 Fortran 표현식 : &lt;code&gt;FORMAT(I&amp;lt;N&amp;gt;)&lt;/code&gt; 묶는 꺾쇠 괄호를 포함하는 형식 명령문입니다 . GNU Fortran은이 레거시 확장을 지원하지 않습니다. 내부 출력 및 문자열 형식의보다 강력한 (및 표준) 조합을 사용하여 변수 형식 표현식의 효과를 재현 할 수 있습니다. 예를 들어 다음과 같은 코드 조각을 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="a4aef81c53b1585f24d647c6e0c6ec536ef1aba1" translate="yes" xml:space="preserve">
          <source>A version of the &lt;code&gt;gcc&lt;/code&gt; command (which also might be installed as the system&amp;rsquo;s &lt;code&gt;cc&lt;/code&gt; command) that also understands and accepts Fortran source code. The &lt;code&gt;gcc&lt;/code&gt; command is the &lt;em&gt;driver&lt;/em&gt; program for all the languages in the GNU Compiler Collection (GCC); With &lt;code&gt;gcc&lt;/code&gt;, you can compile the source code of any language for which a front end is available in GCC.</source>
          <target state="translated">포트란 소스 코드를 이해하고 승인 하는 &lt;code&gt;gcc&lt;/code&gt; 명령 버전 (시스템의 &lt;code&gt;cc&lt;/code&gt; 명령 으로 설치 될 수도 있음 ). &lt;code&gt;gcc&lt;/code&gt; 명령입니다 &lt;em&gt;드라이버&lt;/em&gt; 는 GNU 컴파일러 컬렉션 (GCC)의 모든 언어에 대한 프로그램; &lt;code&gt;gcc&lt;/code&gt; 를 사용하면 GCC 에서 프런트 엔드를 사용할 수있는 모든 언어의 소스 코드를 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbd57cfd9437b3c9c1c3ce7cb0fb7a7b8366940a" translate="yes" xml:space="preserve">
          <source>ABORT</source>
          <target state="translated">ABORT</target>
        </trans-unit>
        <trans-unit id="b14e4cc3f9a03a17ac3f6123a6226b7b7d34c952" translate="yes" xml:space="preserve">
          <source>ADDENDUM: How to use this License for your documents</source>
          <target state="translated">부록 : 문서에이 라이센스를 사용하는 방법</target>
        </trans-unit>
        <trans-unit id="f8a6ad0c85a5734b40f194ec5bdaa679c92bffb7" translate="yes" xml:space="preserve">
          <source>AIMAG</source>
          <target state="translated">AIMAG</target>
        </trans-unit>
        <trans-unit id="9902db2204cf50a1c9aed02a9c5c333e7b1cdedd" translate="yes" xml:space="preserve">
          <source>ASINH</source>
          <target state="translated">ASINH</target>
        </trans-unit>
        <trans-unit id="2538b84d6fa7c1ebf5460242f9da1aa4d79e0b25" translate="yes" xml:space="preserve">
          <source>ASSOCIATED</source>
          <target state="translated">ASSOCIATED</target>
        </trans-unit>
        <trans-unit id="e69dc76eb813ecc0aa7266456f32f3e51d54c63e" translate="yes" xml:space="preserve">
          <source>ATANH</source>
          <target state="translated">ATANH</target>
        </trans-unit>
        <trans-unit id="eedd2a5a77f8bb8419911542ebc10426b78b0cb1" translate="yes" xml:space="preserve">
          <source>Abort the program</source>
          <target state="translated">프로그램 중단</target>
        </trans-unit>
        <trans-unit id="35e4a1a9ace5e53c1521b13130f3b1fce0bb312b" translate="yes" xml:space="preserve">
          <source>Absolute value</source>
          <target state="translated">절대 값</target>
        </trans-unit>
        <trans-unit id="1c342f412fd7e2a44ed4d54f027bc9a3cdb5593b" translate="yes" xml:space="preserve">
          <source>Abstract interfaces and type extension with the possibility to override type-bound procedures or to have deferred binding.</source>
          <target state="translated">형식 바인딩 된 프로 시저를 재정의하거나 바인딩을 지연시킬 수있는 추상 인터페이스 및 형식 확장</target>
        </trans-unit>
        <trans-unit id="34d1852d63c601908c0aa993478c4e48027e40ed" translate="yes" xml:space="preserve">
          <source>According the Fortran standard, valid Fortran names consist of a letter between &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;Z&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;z&lt;/code&gt;, digits &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;9&lt;/code&gt; and underscores (&lt;code&gt;_&lt;/code&gt;) with the restriction that names may only start with a letter. As vendor extension, the dollar sign (&lt;code&gt;$&lt;/code&gt;) is additionally permitted with the option</source>
          <target state="translated">포트란 표준에 따르면, 유효 포트란 이름 사이의 문자로 구성 에 &lt;code&gt;Z&lt;/code&gt; , 에 &lt;code&gt;z&lt;/code&gt; 숫자 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; 로 &lt;code&gt;9&lt;/code&gt; 개 밑줄 ( &lt;code&gt;_&lt;/code&gt; 이름 만 쓰기 시작할 수 있다는 제한이 있음). 공급 업체 확장으로 달러 기호 ( &lt;code&gt;$&lt;/code&gt; )가 옵션과 함께 추가로 허용됩니다. &lt;code&gt;A&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2251bb4bf10f0398f05a950cae36ec46c1704a40" translate="yes" xml:space="preserve">
          <source>Acquire a lock on the given image on a scalar locking variable or for the given array element for an array-valued variable. If the &lt;var&gt;aquired_lock&lt;/var&gt; is &lt;code&gt;NULL&lt;/code&gt;, the function returns after having obtained the lock. If it is non-&lt;code&gt;NULL&lt;/code&gt;, then &lt;var&gt;acquired_lock&lt;/var&gt; is assigned the value true (one) when the lock could be obtained and false (zero) otherwise. Locking a lock variable which has already been locked by the same image is an error.</source>
          <target state="translated">스칼라 잠금 변수의 주어진 이미지 또는 배열 값 변수의 주어진 배열 요소에 대한 잠금을 획득하십시오. 경우 &lt;var&gt;aquired_lock&lt;/var&gt; 가 있다 &lt;code&gt;NULL&lt;/code&gt; 이 후 함수가 반환 잠금을 획득하는 데. 이 아닌 경우, &lt;code&gt;NULL&lt;/code&gt; 이 다음 &lt;var&gt;acquired_lock&lt;/var&gt; 상기 록이 획득 될 수있는 실제 값 (하나)과 달리 거짓 (영)을 할당한다. 동일한 이미지로 이미 잠긴 잠금 변수를 잠그는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="8cb50faf70c1e1b121cd21e8a2dddae6f20f149f" translate="yes" xml:space="preserve">
          <source>Acts as optimization barrier between different segments. It also ensures that all pending memory operations of this image have been completed.</source>
          <target state="translated">서로 다른 세그먼트 사이의 최적화 장벽 역할을합니다. 또한이 이미지의 보류중인 모든 메모리 작업이 완료되었는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="a96b77edfdbae014eec0cd18888fc03f969e50a8" translate="yes" xml:space="preserve">
          <source>Add a dimension to an array</source>
          <target state="translated">배열에 차원 추가</target>
        </trans-unit>
        <trans-unit id="ff3ba585c09c1dcf33037225d960f373d59ad4f1" translate="yes" xml:space="preserve">
          <source>Adding this option will make the Fortran compiler put all local arrays, even those of unknown size onto stack memory. If your program uses very large local arrays it is possible that you will have to extend your runtime limits for stack memory on some operating systems. This flag is enabled by default at optimization level</source>
          <target state="translated">이 옵션을 추가하면 포트란 컴파일러는 알 수없는 크기의 로컬 배열까지 모두 스택 메모리에 배치합니다. 프로그램이 매우 큰 로컬 배열을 사용하는 경우 일부 운영 체제에서 스택 메모리에 대한 런타임 제한을 확장해야 할 수 있습니다. 이 플래그는 기본적으로 최적화 수준에서 활성화됩니다</target>
        </trans-unit>
        <trans-unit id="2c40c8762feca2935c81a48468c51e83b2108046" translate="yes" xml:space="preserve">
          <source>Additionally, the GNU Fortran compilers supports the OpenMP specification (version 4.0 and most of the features of the 4.5 version, &lt;a href=&quot;http://openmp.org/wp/openmp-specifications/&quot;&gt;http://openmp.org/wp/openmp-specifications/&lt;/a&gt;). There also is initial support for the OpenACC specification (targeting version 2.0, &lt;a href=&quot;http://www.openacc.org/&quot;&gt;http://www.openacc.org/&lt;/a&gt;). Note that this is an experimental feature, incomplete, and subject to change in future versions of GCC. See &lt;a href=&quot;https://gcc.gnu.org/wiki/OpenACC&quot;&gt;https://gcc.gnu.org/wiki/OpenACC&lt;/a&gt; for more information.</source>
          <target state="translated">또한 GNU Fortran 컴파일러는 OpenMP 사양 (버전 4.0 및 4.5 버전의 대부분의 기능인 &lt;a href=&quot;http://openmp.org/wp/openmp-specifications/&quot;&gt;http://openmp.org/wp/openmp-specifications/&lt;/a&gt; )을 지원합니다. OpenACC 사양 (타겟팅 버전 2.0, &lt;a href=&quot;http://www.openacc.org/&quot;&gt;http://www.openacc.org/&lt;/a&gt; ) 도 초기 지원됩니다 . 이는 실험적인 기능이며 불완전하며 향후 GCC 버전에서 변경 될 수 있습니다. 자세한 내용은 &lt;a href=&quot;https://gcc.gnu.org/wiki/OpenACC&quot;&gt;https://gcc.gnu.org/wiki/OpenACC&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8540fbc2d2f9d953e9359449d458fe8f73b970b8" translate="yes" xml:space="preserve">
          <source>Additionally, the following parameters of type &lt;code&gt;CHARACTER(KIND=C_CHAR)&lt;/code&gt; are defined.</source>
          <target state="translated">또한 &lt;code&gt;CHARACTER(KIND=C_CHAR)&lt;/code&gt; 유형의 다음 매개 변수 가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="48b2262a7ad1228a34fc080513c9dcc690f13053" translate="yes" xml:space="preserve">
          <source>Adds the elements of &lt;var&gt;ARRAY&lt;/var&gt; along dimension &lt;var&gt;DIM&lt;/var&gt; if the corresponding element in &lt;var&gt;MASK&lt;/var&gt; is &lt;code&gt;TRUE&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;MASK&lt;/var&gt; 의 해당 요소 가 &lt;code&gt;TRUE&lt;/code&gt; 인 경우 치수 &lt;var&gt;DIM&lt;/var&gt; 을 따라 &lt;var&gt;ARRAY&lt;/var&gt; 요소를 추가 합니다 .</target>
        </trans-unit>
        <trans-unit id="9ef427bb816728cd5ff0b51840caec7e8b45d457" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;GETARG&lt;/code&gt; returns, the &lt;var&gt;VALUE&lt;/var&gt; argument holds the &lt;var&gt;POS&lt;/var&gt;th command line argument. If &lt;var&gt;VALUE&lt;/var&gt; can not hold the argument, it is truncated to fit the length of &lt;var&gt;VALUE&lt;/var&gt;. If there are less than &lt;var&gt;POS&lt;/var&gt; arguments specified at the command line, &lt;var&gt;VALUE&lt;/var&gt; will be filled with blanks. If &lt;em&gt;&lt;var&gt;POS&lt;/var&gt; = 0&lt;/em&gt;, &lt;var&gt;VALUE&lt;/var&gt; is set to the name of the program (on systems that support this feature).</source>
          <target state="translated">&lt;code&gt;GETARG&lt;/code&gt; 가 리턴 한 후 &lt;var&gt;VALUE&lt;/var&gt; 인수는 &lt;var&gt;POS&lt;/var&gt; th 명령 행 인수를 보유합니다 . &lt;var&gt;VALUE&lt;/var&gt; 가 인수를 보유 할 수없는 경우 길이가 &lt;var&gt;VALUE&lt;/var&gt; 에 맞게 잘립니다 . 명령 행에 &lt;var&gt;POS&lt;/var&gt; 인수가 지정 되지 않은 경우 &lt;var&gt;VALUE&lt;/var&gt; 는 공백으로 채워집니다. 경우 &lt;em&gt; &lt;var&gt;POS&lt;/var&gt; = 0&lt;/em&gt; , &lt;var&gt;VALUE&lt;/var&gt; (이 기능을 지원하는 시스템) 프로그램의 이름으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c59df33ede5e4c00b67aaa98e3a0fb5396c248d1" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;GET_COMMAND_ARGUMENT&lt;/code&gt; returns, the &lt;var&gt;VALUE&lt;/var&gt; argument holds the &lt;var&gt;NUMBER&lt;/var&gt;-th command line argument. If &lt;var&gt;VALUE&lt;/var&gt; can not hold the argument, it is truncated to fit the length of &lt;var&gt;VALUE&lt;/var&gt;. If there are less than &lt;var&gt;NUMBER&lt;/var&gt; arguments specified at the command line, &lt;var&gt;VALUE&lt;/var&gt; will be filled with blanks. If &lt;em&gt;&lt;var&gt;NUMBER&lt;/var&gt; = 0&lt;/em&gt;, &lt;var&gt;VALUE&lt;/var&gt; is set to the name of the program (on systems that support this feature). The &lt;var&gt;LENGTH&lt;/var&gt; argument contains the length of the &lt;var&gt;NUMBER&lt;/var&gt;-th command line argument. If the argument retrieval fails, &lt;var&gt;STATUS&lt;/var&gt; is a positive number; if &lt;var&gt;VALUE&lt;/var&gt; contains a truncated command line argument, &lt;var&gt;STATUS&lt;/var&gt; is -1; and otherwise the &lt;var&gt;STATUS&lt;/var&gt; is zero.</source>
          <target state="translated">&lt;code&gt;GET_COMMAND_ARGUMENT&lt;/code&gt; 가 리턴 된 후 &lt;var&gt;VALUE&lt;/var&gt; 인수는 &lt;var&gt;NUMBER&lt;/var&gt; 번째 명령 행 인수를 보유합니다 . &lt;var&gt;VALUE&lt;/var&gt; 가 인수를 보유 할 수없는 경우 길이가 &lt;var&gt;VALUE&lt;/var&gt; 에 맞게 잘립니다 . 명령 행에 &lt;var&gt;NUMBER&lt;/var&gt; 개 미만의 인수가 지정되면 &lt;var&gt;VALUE&lt;/var&gt; 는 공백으로 채워집니다. 경우 &lt;em&gt; &lt;var&gt;NUMBER&lt;/var&gt; = 0&lt;/em&gt; , &lt;var&gt;VALUE&lt;/var&gt; (이 기능을 지원하는 시스템) 프로그램의 이름으로 설정됩니다. &lt;var&gt;LENGTH&lt;/var&gt; 인수는 길이 포함 &lt;var&gt;NUMBER&lt;/var&gt; 번째 명령 행 인수를. 인수 검색이 실패하면 &lt;var&gt;STATUS&lt;/var&gt; 양수이고; &lt;var&gt;VALUE&lt;/var&gt; 에 잘린 명령 행 인수가 포함 된 경우 &lt;var&gt;STATUS&lt;/var&gt; 는 -1입니다. 그렇지 않으면 &lt;var&gt;STATUS&lt;/var&gt; 는 0입니다.</target>
        </trans-unit>
        <trans-unit id="5d9abd062789987bc30d3efab333d4c5972c80cb" translate="yes" xml:space="preserve">
          <source>Alias: &lt;a href=&quot;atan#ATAN&quot;&gt;ATAN&lt;/a&gt; Degrees function: &lt;a href=&quot;atan2d#ATAN2D&quot;&gt;ATAN2D&lt;/a&gt;</source>
          <target state="translated">별칭 : &lt;a href=&quot;atan#ATAN&quot;&gt;ATAN&lt;/a&gt; 도 기능 : &lt;a href=&quot;atan2d#ATAN2D&quot;&gt;ATAN2D&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c1f24dbf8ac90dccdd3db847b0e4be9137fd414c" translate="yes" xml:space="preserve">
          <source>Alias: &lt;a href=&quot;atand#ATAND&quot;&gt;ATAND&lt;/a&gt; Radians function: &lt;a href=&quot;atan2#ATAN2&quot;&gt;ATAN2&lt;/a&gt;</source>
          <target state="translated">별명 : &lt;a href=&quot;atand#ATAND&quot;&gt;ATAND&lt;/a&gt; 라디안 기능 : &lt;a href=&quot;atan2#ATAN2&quot;&gt;ATAN2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b785366a6f98d462bb0e363a439d3c3d7e49284e" translate="yes" xml:space="preserve">
          <source>All GCC and GNU Fortran options are accepted both by &lt;code&gt;gfortran&lt;/code&gt; and by &lt;code&gt;gcc&lt;/code&gt; (as well as any other drivers built at the same time, such as &lt;code&gt;g++&lt;/code&gt;), since adding GNU Fortran to the GCC distribution enables acceptance of GNU Fortran options by all of the relevant drivers.</source>
          <target state="translated">모든 GCC와 GNU 포트란 옵션으로 모두 허용됩니다 &lt;code&gt;gfortran&lt;/code&gt; 에 의해 &lt;code&gt;gcc&lt;/code&gt; (뿐만 아니라 같은시기에 내장 된 다른 드라이버, &lt;code&gt;g++&lt;/code&gt; GCC의 분포 GNU 포트란을 추가 보낸 사람)의 모든 의해 GNU 포트란 옵션의 수용을 가능하게 관련 드라이버.</target>
        </trans-unit>
        <trans-unit id="0d9b85081b41451fadfb75db3cad80f162e9761c" translate="yes" xml:space="preserve">
          <source>All-image barrier</source>
          <target state="translated">모든 이미지 장벽</target>
        </trans-unit>
        <trans-unit id="eaad1c570dd980acc725c97ccb6c9445c011f926" translate="yes" xml:space="preserve">
          <source>Allow &amp;lsquo;</source>
          <target state="translated">허용하다 '</target>
        </trans-unit>
        <trans-unit id="d7f69c896c6aa4df0ec46d4ea68068a8accaf47a" translate="yes" xml:space="preserve">
          <source>Allow indirect recursion by forcing all local arrays to be allocated on the stack. This flag cannot be used together with</source>
          <target state="translated">모든 로컬 어레이를 스택에 강제로 할당하여 간접 재귀를 허용합니다. 이 플래그는 함께 사용할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="f5aa7d9f62e553b71b8fdd9fb9271c08945bbfa5" translate="yes" xml:space="preserve">
          <source>Allowed standard; can give run-time errors if e.g. an input-output edit descriptor is invalid in a given standard. Possible values are (bitwise or-ed) &lt;code&gt;GFC_STD_F77&lt;/code&gt; (1), &lt;code&gt;GFC_STD_F95_OBS&lt;/code&gt; (2), &lt;code&gt;GFC_STD_F95_DEL&lt;/code&gt; (4), &lt;code&gt;GFC_STD_F95&lt;/code&gt; (8), &lt;code&gt;GFC_STD_F2003&lt;/code&gt; (16), &lt;code&gt;GFC_STD_GNU&lt;/code&gt; (32), &lt;code&gt;GFC_STD_LEGACY&lt;/code&gt; (64), &lt;code&gt;GFC_STD_F2008&lt;/code&gt; (128), &lt;code&gt;GFC_STD_F2008_OBS&lt;/code&gt; (256) and GFC_STD_F2008_TS (512). Default: &lt;code&gt;GFC_STD_F95_OBS | GFC_STD_F95_DEL | GFC_STD_F95 | GFC_STD_F2003
| GFC_STD_F2008 | GFC_STD_F2008_TS | GFC_STD_F2008_OBS | GFC_STD_F77
| GFC_STD_GNU | GFC_STD_LEGACY&lt;/code&gt;.</source>
          <target state="translated">허용 된 표준; 주어진 표준에서 입력-출력 편집 디스크립터가 유효하지 않은 경우 런타임 에러를 발생시킬 수 있습니다. 가능한 값은 (비트 혼성 또는)이다 &lt;code&gt;GFC_STD_F77&lt;/code&gt; (1) &lt;code&gt;GFC_STD_F95_OBS&lt;/code&gt; (2) &lt;code&gt;GFC_STD_F95_DEL&lt;/code&gt; (4) &lt;code&gt;GFC_STD_F95&lt;/code&gt; (8) &lt;code&gt;GFC_STD_F2003&lt;/code&gt; (16) &lt;code&gt;GFC_STD_GNU&lt;/code&gt; (32) &lt;code&gt;GFC_STD_LEGACY&lt;/code&gt; (64) &lt;code&gt;GFC_STD_F2008&lt;/code&gt; (128) &lt;code&gt;GFC_STD_F2008_OBS&lt;/code&gt; (256) 및 GFC_STD_F2008_TS (512). 기본값 : &lt;code&gt;GFC_STD_F95_OBS | GFC_STD_F95_DEL | GFC_STD_F95 | GFC_STD_F2003 | GFC_STD_F2008 | GFC_STD_F2008_TS | GFC_STD_F2008_OBS | GFC_STD_F77 | GFC_STD_GNU | GFC_STD_LEGACY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ccceb5451f5947860d0d11ae9c653a781703fca3" translate="yes" xml:space="preserve">
          <source>Allows to specifiy the type of deregistration of a coarray object. The &lt;code&gt;CAF_DEREGTYPE_COARRAY_DEALLOCATE_ONLY&lt;/code&gt; flag is only allowed for allocatable components in derived type coarrays.</source>
          <target state="translated">거친 객체의 등록 취소 유형을 지정할 수 있습니다. &lt;code&gt;CAF_DEREGTYPE_COARRAY_DEALLOCATE_ONLY&lt;/code&gt; 의 플래그는 파생 형 coarrays에 할당 가능한 구성 요소에 대해 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="e9b6931411a17cbd9c677fb94db8bd91fd59ea4e" translate="yes" xml:space="preserve">
          <source>Also note that the general behavior of</source>
          <target state="translated">또한 일반적인 행동은</target>
        </trans-unit>
        <trans-unit id="a010f25919a43b05cee57c97c7e10e3f1acd9f24" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;c_by_val.f&lt;/code&gt; and its partner &lt;code&gt;c_by_val.c&lt;/code&gt; of the GNU Fortran testsuite are worth a look.</source>
          <target state="translated">또한 GNU Fortran 테스트 &lt;code&gt;c_by_val.c&lt;/code&gt; 의 &lt;code&gt;c_by_val.f&lt;/code&gt; 및 파트너 c_by_val.c도 살펴볼 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="03769b6fd59ddee4b9f6c9b1a64a2fd90aa7e99f" translate="yes" xml:space="preserve">
          <source>Also, note that with</source>
          <target state="translated">또한</target>
        </trans-unit>
        <trans-unit id="9de49a3c572dc848e4b6b26dc63aa733f00e2a7a" translate="yes" xml:space="preserve">
          <source>Among other things, the GNU Fortran compiler is intended as a replacement for G77. At this point, nearly all programs that could be compiled with G77 can be compiled with GNU Fortran, although there are a few minor known regressions.</source>
          <target state="translated">무엇보다도 GNU Fortran 컴파일러는 G77을 대체하기위한 것입니다. 이 시점에서 G77로 컴파일 할 수있는 거의 모든 프로그램은 GNU Fortran으로 컴파일 할 수 있지만 약간의 알려진 회귀가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd12d1b553b898735248d531abcb8e2828ccf693" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;INTEGER&lt;/code&gt; array of rank one with as many elements as &lt;var&gt;SOURCE&lt;/var&gt; has dimensions. The elements of the resulting array correspond to the extend of &lt;var&gt;SOURCE&lt;/var&gt; along the respective dimensions. If &lt;var&gt;SOURCE&lt;/var&gt; is a scalar, the result is the rank one array of size zero. If &lt;var&gt;KIND&lt;/var&gt; is absent, the return value has the default integer kind otherwise the specified kind.</source>
          <target state="translated">&lt;var&gt;SOURCE&lt;/var&gt; 만큼 많은 수의 요소가있는 순위 1 의 &lt;code&gt;INTEGER&lt;/code&gt; 배열 에는 차원이 있습니다. 결과 배열의 요소 는 각 차원을 따라 &lt;var&gt;SOURCE&lt;/var&gt; 의 확장에 해당합니다. 경우 &lt;var&gt;SOURCE&lt;/var&gt; 는 스칼라이고, 그 결과 크기가 제로의 계수 한 배열이다. 경우 &lt;var&gt;KIND&lt;/var&gt; 결석, 반환 값은 종류, 그렇지 않으면 기본 정수 지정된 종류가 있습니다.</target>
        </trans-unit>
        <trans-unit id="971177b6434d7014803774b86a16a28ff6527986" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;INTEGER&lt;/code&gt; scalar expression corresponding to a system time, with &lt;code&gt;INTENT(IN)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;INTENT(IN)&lt;/code&gt; 시스템 시간에 해당 하는 &lt;code&gt;INTEGER&lt;/code&gt; 스칼라 표현식 입니다.</target>
        </trans-unit>
        <trans-unit id="67b042b1d2ebdd1e055d8a345580947ef6ee255d" translate="yes" xml:space="preserve">
          <source>An INTEGER SELECT construct has a CASE that can never be matched as its lower value is greater than its upper value.</source>
          <target state="translated">INTEGER SELECT 구문에는 더 낮은 값이 더 높은 값보다 크기 때문에 일치 할 수없는 CASE가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a97ad4f89c6c310657b6b72a7da664cc6f59c2e2" translate="yes" xml:space="preserve">
          <source>An allocatable left-hand side of an intrinsic assignment is automatically (re)allocated if it is either unallocated or has a different shape. The option is enabled by default except when</source>
          <target state="translated">고유 할당의 할당 가능한 왼쪽은 할당되지 않았거나 모양이 다른 경우 자동으로 (재) 할당됩니다. 이 옵션은 다음을 제외하고 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b59f5b432640358cdfcad06f3a9018693e15249" translate="yes" xml:space="preserve">
          <source>An array of &lt;code&gt;INTEGER&lt;/code&gt;, &lt;code&gt;REAL&lt;/code&gt;, &lt;code&gt;COMPLEX&lt;/code&gt;, or &lt;code&gt;LOGICAL&lt;/code&gt; type, with a rank of one or two.</source>
          <target state="translated">1 또는 2 등급 의 &lt;code&gt;INTEGER&lt;/code&gt; , &lt;code&gt;REAL&lt;/code&gt; , &lt;code&gt;COMPLEX&lt;/code&gt; 또는 &lt;code&gt;LOGICAL&lt;/code&gt; 유형 의 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="b2f8c32724b62c61e27af659ee8d5a3582642fe3" translate="yes" xml:space="preserve">
          <source>An array of &lt;code&gt;INTEGER&lt;/code&gt;, &lt;code&gt;REAL&lt;/code&gt;, or &lt;code&gt;COMPLEX&lt;/code&gt; type if &lt;var&gt;MATRIX_A&lt;/var&gt; is of a numeric type; otherwise, an array of &lt;code&gt;LOGICAL&lt;/code&gt; type. The rank shall be one or two, and the first (or only) dimension of &lt;var&gt;MATRIX_B&lt;/var&gt; shall be equal to the last (or only) dimension of &lt;var&gt;MATRIX_A&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;MATRIX_A&lt;/var&gt; 가 숫자 유형 인 경우 &lt;code&gt;INTEGER&lt;/code&gt; , &lt;code&gt;REAL&lt;/code&gt; 또는 &lt;code&gt;COMPLEX&lt;/code&gt; 유형 의 배열 . 그렇지 않으면 &lt;code&gt;LOGICAL&lt;/code&gt; 유형 의 배열입니다 . 순위는 하나 또는 두 개이며 &lt;var&gt;MATRIX_B&lt;/var&gt; 의 첫 번째 (또는 유일한) 차원은 MATRIX_A 의 마지막 (또는 유일한) 차원과 &lt;var&gt;MATRIX_A&lt;/var&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="2fb9aaa38eaf0800c9afe4fe357312a3e531b1a1" translate="yes" xml:space="preserve">
          <source>An example of a parallelized loop taken from Appendix A.1 of the OpenMP Application Program Interface v2.5:</source>
          <target state="translated">OpenMP Application Program Interface v2.5의 부록 A.1에서 가져온 병렬 루프의 예 :</target>
        </trans-unit>
        <trans-unit id="c56e866e94a12a9092a1f1d241924b5dbfaecf53" translate="yes" xml:space="preserve">
          <source>An example of passing an argument by value to a C subroutine foo.:</source>
          <target state="translated">값으로 인수를 C 서브 루틴 foo에 전달하는 예 :</target>
        </trans-unit>
        <trans-unit id="fcfb2abb6dd9553846055b3308ef6e6ad2665874" translate="yes" xml:space="preserve">
          <source>An expression of the same type and kind as &lt;var&gt;A1&lt;/var&gt;. (As a GNU extension, arguments of different kinds are permitted.)</source>
          <target state="translated">&lt;var&gt;A1&lt;/var&gt; 과 동일한 유형 및 종류의 표현식입니다 . (GNU 확장으로서 다른 종류의 인수가 허용됩니다.)</target>
        </trans-unit>
        <trans-unit id="ff2aadba47ce707a36efe2e131b078f39a58132e" translate="yes" xml:space="preserve">
          <source>An opaque pointer identifying the coarray.</source>
          <target state="translated">굵은 선을 식별하는 불투명 포인터.</target>
        </trans-unit>
        <trans-unit id="78dde013e96fb00db352e66e401a05d3737caa82" translate="yes" xml:space="preserve">
          <source>An open I/O unit number of type &lt;code&gt;INTEGER&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;INTEGER&lt;/code&gt; 유형의 열린 I / O 장치 번호입니다 .</target>
        </trans-unit>
        <trans-unit id="af6a4d792dc8d9c179fb5747c83180c4b1c22a95" translate="yes" xml:space="preserve">
          <source>And the following scalar integer named constants of the kind &lt;code&gt;omp_proc_bind_kind&lt;/code&gt;:</source>
          <target state="translated">그리고 &lt;code&gt;omp_proc_bind_kind&lt;/code&gt; 종류의 상수라는 이름의 다음 스칼라 정수 :</target>
        </trans-unit>
        <trans-unit id="092aafbf6d660f5086ac5a7729f3d793b5c20808" translate="yes" xml:space="preserve">
          <source>Any expression involving the pointee will be translated to use the value stored in the pointer as the base address.</source>
          <target state="translated">포인트와 관련된 모든 표현식은 포인터에 저장된 값을 기본 주소로 사용하도록 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="b07b9d102c8b6807cef5d4ab805ad0ef7f19356e" translate="yes" xml:space="preserve">
          <source>Apply an operation atomically to an atomic integer or logical variable. After the operation, &lt;var&gt;old&lt;/var&gt; contains the value just before the operation, which, respectively, adds (GFC_CAF_ATOMIC_ADD) atomically the &lt;code&gt;value&lt;/code&gt; to the atomic integer variable or does a bitwise AND, OR or exclusive OR between the atomic variable and &lt;var&gt;value&lt;/var&gt;; the result is then stored in the atomic variable.</source>
          <target state="translated">원자 정수 또는 논리 변수에 원자 적으로 연산을 적용하십시오. 연산 후, &lt;var&gt;old&lt;/var&gt; 는 연산 직전의 값을 각각 포함하며, 이는 각각 원자 정수 변수에 &lt;code&gt;value&lt;/code&gt; 을 원자 적으로 (GFC_CAF_ATOMIC_ADD) 추가 하거나 원자 변수와 &lt;var&gt;value&lt;/var&gt; 사이에 비트 단위 AND, OR 또는 배타적 OR을 수행합니다 . 그런 다음 결과는 원자 변수에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="f112c3d32d8d0c6c1d3d8b3290d994b99247278d" translate="yes" xml:space="preserve">
          <source>Arccosine function</source>
          <target state="translated">아크 코사인 기능</target>
        </trans-unit>
        <trans-unit id="f1fdb65d1f85c2602ba7eedf51322906a8da69d4" translate="yes" xml:space="preserve">
          <source>Arccosine function, degrees</source>
          <target state="translated">아크 코사인 함수,도</target>
        </trans-unit>
        <trans-unit id="6ecd3564ebced055a905a5c1dc9119f7cb08c240" translate="yes" xml:space="preserve">
          <source>Arcsine function</source>
          <target state="translated">아크 사인 기능</target>
        </trans-unit>
        <trans-unit id="fdd99f4a3a0ebaae8de45c28b95705c89d709535" translate="yes" xml:space="preserve">
          <source>Arcsine function, degrees</source>
          <target state="translated">아크 사인 함수,도</target>
        </trans-unit>
        <trans-unit id="3bfc68e59471e0c337229dd2a9172f2a5e4e1502" translate="yes" xml:space="preserve">
          <source>Arctangent function</source>
          <target state="translated">아크 탄젠트 함수</target>
        </trans-unit>
        <trans-unit id="391082f6ad6f2c3bf3b33362e5d47cdf6d200a7d" translate="yes" xml:space="preserve">
          <source>Arctangent function, degrees</source>
          <target state="translated">아크 탄젠트 함수,도</target>
        </trans-unit>
        <trans-unit id="ce5e5792e97fe5c7861d6ae9b29cf5a25cc0e70a" translate="yes" xml:space="preserve">
          <source>Argument</source>
          <target state="translated">Argument</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="65f9d8868845568d00ef978d0d15706c0828d738" translate="yes" xml:space="preserve">
          <source>Arguments are passed according to the platform ABI. In particular, complex arguments might not be compatible to a struct with two real components for the real and imaginary part. The argument passing matches the one of C99&amp;rsquo;s &lt;code&gt;_Complex&lt;/code&gt;. Functions with scalar complex result variables return their value and do not use a by-reference argument. Note that with the</source>
          <target state="translated">인수는 플랫폼 ABI에 따라 전달됩니다. 특히 복잡한 인수는 실수 부와 허수 부를위한 두 개의 실제 성분을 가진 구조체와 호환되지 않을 수 있습니다. 인수 전달은 C99의 &lt;code&gt;_Complex&lt;/code&gt; 중 하나와 일치합니다 . 스칼라 복소수 결과 변수가있는 함수는 값을 반환하고 참조 기준 인수를 사용하지 않습니다. 참고로</target>
        </trans-unit>
        <trans-unit id="62cf890b180b2c6442b30fab3b3ce5ddbd062d57" translate="yes" xml:space="preserve">
          <source>Arguments which are assumed-shape, assumed-rank or deferred-rank arrays or, with</source>
          <target state="translated">가정 된, 가정 된 순위 또는 지연된 순위 배열 또는</target>
        </trans-unit>
        <trans-unit id="a0478ca5f4c068ca3ac12f9474f6a15865ce9053" translate="yes" xml:space="preserve">
          <source>Arguments:</source>
          <target state="translated">Arguments:</target>
        </trans-unit>
        <trans-unit id="92b7704abee8bc3d69acafe355e16137a9995e7e" translate="yes" xml:space="preserve">
          <source>Arguments: None.</source>
          <target state="translated">인수 : 없음</target>
        </trans-unit>
        <trans-unit id="bb87ce94e5793fd89400e90e3e82274f2be82db5" translate="yes" xml:space="preserve">
          <source>Array constructors using square brackets. That is, &lt;code id=&quot;index-_005b_002e_002e_002e_005d&quot;&gt;[...]&lt;/code&gt; rather than &lt;code&gt;(/.../)&lt;/code&gt;. Type-specification for array constructors like &lt;code&gt;(/ some-type :: ... /)&lt;/code&gt;.</source>
          <target state="translated">대괄호를 사용하는 배열 생성자. 즉, &lt;code&gt;(/.../)&lt;/code&gt; 보다는 &lt;code id=&quot;index-_005b_002e_002e_002e_005d&quot;&gt;[...]&lt;/code&gt; 입니다. 같은 배열 생성자에 대한 타입 사양 &lt;code&gt;(/ some-type :: ... /)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2463d442dcf4d081242818a9b9d53d851d124a2b" translate="yes" xml:space="preserve">
          <source>As an extension for backwards compatibility with other compilers, GNU Fortran allows the implicit conversion of &lt;code&gt;LOGICAL&lt;/code&gt; values to &lt;code&gt;INTEGER&lt;/code&gt; values and vice versa. When converting from a &lt;code&gt;LOGICAL&lt;/code&gt; to an &lt;code&gt;INTEGER&lt;/code&gt;, &lt;code&gt;.FALSE.&lt;/code&gt; is interpreted as zero, and &lt;code&gt;.TRUE.&lt;/code&gt; is interpreted as one. When converting from &lt;code&gt;INTEGER&lt;/code&gt; to &lt;code&gt;LOGICAL&lt;/code&gt;, the value zero is interpreted as &lt;code&gt;.FALSE.&lt;/code&gt; and any nonzero value is interpreted as &lt;code&gt;.TRUE.&lt;/code&gt;.</source>
          <target state="translated">GNU Fortran은 다른 컴파일러와의 하위 호환성을위한 확장으로서 &lt;code&gt;LOGICAL&lt;/code&gt; 값을 &lt;code&gt;INTEGER&lt;/code&gt; 값으로 또는 그 반대로 암시 적으로 변환 할 수 있습니다 . A로부터 변환하는 경우 &lt;code&gt;LOGICAL&lt;/code&gt; 내지 An &lt;code&gt;INTEGER&lt;/code&gt; , &lt;code&gt;.FALSE.&lt;/code&gt; 0으로 해석되며 &lt;code&gt;.TRUE.&lt;/code&gt; 하나로 해석됩니다. &lt;code&gt;INTEGER&lt;/code&gt; 에서 &lt;code&gt;LOGICAL&lt;/code&gt; 로 변환 할 때 값 0은 &lt;code&gt;.FALSE.&lt;/code&gt; 로 해석됩니다 . 0이 아닌 값은 &lt;code&gt;.TRUE.&lt;/code&gt; 로 해석됩니다 . .</target>
        </trans-unit>
        <trans-unit id="4794353c36fe25632421ff7bc0e02c15efe176dc" translate="yes" xml:space="preserve">
          <source>As an extension to the Fortran standard, the GFortran &lt;code&gt;RANDOM_NUMBER&lt;/code&gt; supports multiple threads. Each thread in a multi-threaded program has its own seed. When &lt;code&gt;RANDOM_SEED&lt;/code&gt; is called either without arguments or with the &lt;var&gt;PUT&lt;/var&gt; argument, the given seed is copied into a master seed as well as the seed of the current thread. When a new thread uses &lt;code&gt;RANDOM_NUMBER&lt;/code&gt; for the first time, the seed is copied from the master seed, and forwarded &lt;em&gt;N * 2^{512}&lt;/em&gt; steps to guarantee that the random stream does not alias any other stream in the system, where &lt;var&gt;N&lt;/var&gt; is the number of threads that have used &lt;code&gt;RANDOM_NUMBER&lt;/code&gt; so far during the program execution.</source>
          <target state="translated">Fortran 표준의 확장으로서 GFortran &lt;code&gt;RANDOM_NUMBER&lt;/code&gt; 는 여러 스레드를 지원합니다. 다중 스레드 프로그램의 각 스레드에는 자체 시드가 있습니다. 때 &lt;code&gt;RANDOM_SEED&lt;/code&gt; 가 인수없이 또는 함께 중 하나라고 &lt;var&gt;PUT&lt;/var&gt; 의 인수, 주어진 씨는 마스터 씨뿐만 아니라 현재의 thread의 씨앗에 복사됩니다. 새 스레드가 처음으로 &lt;code&gt;RANDOM_NUMBER&lt;/code&gt; 를 사용 하는 경우 시드는 마스터 시드에서 복사되고 &lt;em&gt;N * 2 ^ {512}&lt;/em&gt; 단계를 전달 하여 임의 스트림이 시스템의 다른 스트림을 별명으로 지정하지 않습니다. 여기서 &lt;var&gt;N&lt;/var&gt; 은 프로그램 실행 중에 지금까지 &lt;code&gt;RANDOM_NUMBER&lt;/code&gt; 를 사용한 스레드 수</target>
        </trans-unit>
        <trans-unit id="94af6f578b8c84e49b8a4780536a468b06666ec0" translate="yes" xml:space="preserve">
          <source>As an extension, GNU Fortran allows hexadecimal BOZ literal constants to be specified using the &lt;code&gt;X&lt;/code&gt; prefix, in addition to the standard &lt;code&gt;Z&lt;/code&gt; prefix. The BOZ literal can also be specified by adding a suffix to the string, for example, &lt;code&gt;Z'ABC'&lt;/code&gt; and &lt;code&gt;'ABC'Z&lt;/code&gt; are equivalent.</source>
          <target state="translated">확장으로 GNU Fortran은 표준 &lt;code&gt;Z&lt;/code&gt; 접두사 와 함께 &lt;code&gt;X&lt;/code&gt; 접두사를 사용하여 16 진 BOZ 리터럴 상수를 지정할 수 있습니다 . 문자열에 접미사를 추가하여 BOZ 리터럴을 지정할 수도 있습니다. 예를 들어 &lt;code&gt;Z'ABC'&lt;/code&gt; 및 &lt;code&gt;'ABC'Z&lt;/code&gt; 는 같습니다.</target>
        </trans-unit>
        <trans-unit id="98f59fc1bb6520a924ea7f2226895d1d54a604a0" translate="yes" xml:space="preserve">
          <source>As an extension, GNU Fortran allows the use of &lt;code&gt;REAL&lt;/code&gt; expressions or variables as array indices.</source>
          <target state="translated">확장으로 GNU Fortran은 &lt;code&gt;REAL&lt;/code&gt; 표현식 또는 변수를 배열 인덱스로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6163b5bc3e03c9c7e587962794e237c78c1c319" translate="yes" xml:space="preserve">
          <source>As an extension, GNU Fortran allows unary plus and unary minus operators to appear as the second operand of binary arithmetic operators without the need for parenthesis.</source>
          <target state="translated">확장으로 GNU Fortran을 사용하면 단항 더하기 및 단항 빼기 연산자를 괄호없이 이진 산술 연산자의 두 번째 피연산자로 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="617aaf610a328d49eb72edcd19ea1487f239d377" translate="yes" xml:space="preserve">
          <source>As long as &lt;code&gt;ipt&lt;/code&gt; remains unchanged, &lt;code&gt;iarr&lt;/code&gt; is now an alias for &lt;code&gt;target&lt;/code&gt;. The optimizer, however, will not detect this aliasing, so it is unsafe to use &lt;code&gt;iarr&lt;/code&gt; and &lt;code&gt;target&lt;/code&gt; simultaneously. Using a pointee in any way that violates the Fortran aliasing rules or assumptions is illegal. It is the user&amp;rsquo;s responsibility to avoid doing this; the compiler works under the assumption that no such aliasing occurs.</source>
          <target state="translated">만큼 &lt;code&gt;ipt&lt;/code&gt; 그대로 유지, &lt;code&gt;iarr&lt;/code&gt; 는 지금의 별칭입니다 &lt;code&gt;target&lt;/code&gt; . 그러나 옵티마이 저는이 앨리어싱을 감지하지 &lt;code&gt;iarr&lt;/code&gt; 과 &lt;code&gt;target&lt;/code&gt; 을 동시에 사용하는 것은 안전하지 않습니다 . Fortran 앨리어싱 규칙 또는 가정을 위반하는 방식으로 포인트를 사용하는 것은 불법입니다. 이를 피하는 것은 사용자의 책임입니다. 컴파일러는 이러한 앨리어싱이 발생하지 않는다는 가정하에 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d3fea5067b1077db0f1bd8ce6ec05f67d849f63e" translate="yes" xml:space="preserve">
          <source>As soon as &lt;code&gt;gfortran&lt;/code&gt; can parse all of the statements correctly, it will be in the &amp;ldquo;larva&amp;rdquo; state. When we generate code, the &amp;ldquo;puppa&amp;rdquo; state. When &lt;code&gt;gfortran&lt;/code&gt; is done, we&amp;rsquo;ll see if it will be a beautiful butterfly, or just a big bug....</source>
          <target state="translated">즉시로 &lt;code&gt;gfortran&lt;/code&gt; 가 올바르게의 모든 문장을 구문 분석 할 수 있습니다, 그것은 &quot;애벌레&quot;상태가됩니다. 코드를 생성 할 때 &quot;puppa&quot;상태입니다. 때 &lt;code&gt;gfortran&lt;/code&gt; 이 완료가 아름다운 나비, 또는 단지 하나의 큰 버그한다면, 우리는 볼 수 있습니다 ....</target>
        </trans-unit>
        <trans-unit id="de6b2942dd45330e434da46543c484c9400417e5" translate="yes" xml:space="preserve">
          <source>As specified for the &lt;code&gt;this_image&lt;/code&gt; intrinsic in TS18508. Shall be a non-negative number.</source>
          <target state="translated">&lt;code&gt;this_image&lt;/code&gt; 내장 된 this_image에 대해 지정된 대로. 음수가 아닌 숫자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="9996ed989720054ccf4eff82b3541577d87b517b" translate="yes" xml:space="preserve">
          <source>As the example shows, one needs to ensure that the string is &lt;code&gt;NUL&lt;/code&gt; terminated. Additionally, the dummy argument &lt;var&gt;string&lt;/var&gt; of &lt;code&gt;print_C&lt;/code&gt; is a length-one assumed-size array; using &lt;code&gt;character(len=*)&lt;/code&gt; is not allowed. The example above uses &lt;code&gt;c_char_&quot;Hello World&quot;&lt;/code&gt; to ensure the string literal has the right type; typically the default character kind and &lt;code&gt;c_char&lt;/code&gt; are the same and thus &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; is equivalent. However, the standard does not guarantee this.</source>
          <target state="translated">예제에서 볼 수 있듯이 문자열이 &lt;code&gt;NUL&lt;/code&gt; 로 종료 되었는지 확인해야합니다 . 또한 &lt;code&gt;print_C&lt;/code&gt; 의 더미 인수 &lt;var&gt;string&lt;/var&gt; 은 길이가 1 인 가정 크기 배열입니다. 사용 &lt;code&gt;character(len=*)&lt;/code&gt; 허용되지 않는다. 위의 예는 &lt;code&gt;c_char_&quot;Hello World&quot;&lt;/code&gt; 를 사용하여 문자열 리터럴의 유형이 올바른지 확인합니다. 일반적으로 기본 문자 종류와 &lt;code&gt;c_char&lt;/code&gt; 는 동일하므로 &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; 는 같습니다. 그러나이 표준은이를 보증하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7784b8229779d77fd01362854bf970cadb931eb4" translate="yes" xml:space="preserve">
          <source>As there exist no direct Fortran equivalents, neither unions nor structs with bit field or variable-length array members are interoperable.</source>
          <target state="translated">직접적인 포트란 등가물이 없기 때문에 비트 필드 또는 가변 길이 배열 멤버를 가진 공용체 나 구조체는 상호 운용 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e9f6cfc3dfbfff93cafa391dca4485a931aa1d95" translate="yes" xml:space="preserve">
          <source>Assign atomically a value to an integer or logical variable.</source>
          <target state="translated">원자 적으로 값을 정수 또는 논리 변수에 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="3cf51a3eafc16a9137ac78663ccdadecdecbfc8c" translate="yes" xml:space="preserve">
          <source>Assumed types (&lt;code&gt;TYPE(*)&lt;/code&gt;) have been added, which may only be used for dummy arguments. They are unlimited polymorphic but contrary to &lt;code&gt;CLASS(*)&lt;/code&gt; they do not contain any type information, similar to C&amp;rsquo;s &lt;code&gt;void *&lt;/code&gt; pointers. Expressions of any type and kind can be passed; thus, it can be used as replacement for &lt;code&gt;TYPE(C_PTR)&lt;/code&gt;, avoiding the use of &lt;code&gt;C_LOC&lt;/code&gt; in the caller.</source>
          <target state="translated">가정 된 유형 ( &lt;code&gt;TYPE(*)&lt;/code&gt; )이 추가되었으며 더미 인수에만 사용할 수 있습니다. 그것들은 무제한 다형성이지만 &lt;code&gt;CLASS(*)&lt;/code&gt; 달리 C의 &lt;code&gt;void *&lt;/code&gt; 포인터 와 유사한 유형 정보를 포함하지 않습니다 . 모든 유형과 종류의 표현을 전달할 수 있습니다. 따라서 호출자에서 &lt;code&gt;C_LOC&lt;/code&gt; 를 사용하지 &lt;code&gt;TYPE(C_PTR)&lt;/code&gt; 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="93f893367434751a750296960d4f6f2fc2492a76" translate="yes" xml:space="preserve">
          <source>Assumed types (&lt;code&gt;TYPE(*)&lt;/code&gt;).</source>
          <target state="translated">가정 된 유형 ( &lt;code&gt;TYPE(*)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8d34a744023b48e74eef8229baf6a8786fe1e922" translate="yes" xml:space="preserve">
          <source>Assumed-rank (&lt;code&gt;DIMENSION(..)&lt;/code&gt;). However, the array descriptor of the TS is not yet supported.</source>
          <target state="translated">가정 순위 ( &lt;code&gt;DIMENSION(..)&lt;/code&gt; ). 그러나 TS의 배열 설명자는 아직 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ba660d9a165e5935ea80775a1e184e81de1b605" translate="yes" xml:space="preserve">
          <source>Assumed-rank arrays (&lt;code&gt;DIMENSION(..)&lt;/code&gt;) as dummy argument allow that scalars and arrays of any rank can be passed as actual argument. As the Technical Specification does not provide for direct means to operate with them, they have to be used either from the C side or be converted using &lt;code&gt;C_LOC&lt;/code&gt; and &lt;code&gt;C_F_POINTER&lt;/code&gt; to scalars or arrays of a specific rank. The rank can be determined using the &lt;code&gt;RANK&lt;/code&gt; intrinisic.</source>
          <target state="translated">더미 인수로 가정 된 순위 배열 ( &lt;code&gt;DIMENSION(..)&lt;/code&gt; )을 사용하면 모든 순위의 스칼라 및 배열을 실제 인수로 전달할 수 있습니다. 기술 사양은 이들과 함께 작동하는 직접적인 수단을 제공하지 않으므로 C 측에서 사용하거나 &lt;code&gt;C_LOC&lt;/code&gt; 및 &lt;code&gt;C_F_POINTER&lt;/code&gt; 를 사용하여 특정 순위의 스칼라 또는 배열 로 변환 해야 합니다. 순위는 &lt;code&gt;RANK&lt;/code&gt; 내장 함수를 사용하여 결정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="563900e7adcb10592c225da79d2d5e61a683a853" translate="yes" xml:space="preserve">
          <source>At present, the GNU Fortran compiler passes the &lt;a href=&quot;http://www.fortran-2000.com/ArnaudRecipes/fcvs21_f95.html&quot;&gt;NIST Fortran 77 Test Suite&lt;/a&gt;, and produces acceptable results on the &lt;a href=&quot;http://www.netlib.org/lapack/faq.html#1.21&quot;&gt;LAPACK Test Suite&lt;/a&gt;. It also provides respectable performance on the &lt;a href=&quot;http://www.polyhedron.com/fortran-compiler-comparisons/polyhedron-benchmark-suite&quot;&gt;Polyhedron Fortran compiler benchmarks&lt;/a&gt; and the &lt;a href=&quot;http://www.netlib.org/benchmark/livermore&quot;&gt;Livermore Fortran Kernels test&lt;/a&gt;. It has been used to compile a number of large real-world programs, including &lt;a href=&quot;http://hirlam.org/&quot;&gt;the HARMONIE and HIRLAM weather forecasting code&lt;/a&gt; and &lt;a href=&quot;http://physical-chemistry.scb.uwa.edu.au/tonto/wiki/index.php/Main_Page&quot;&gt;the Tonto quantum chemistry package&lt;/a&gt;; see &lt;a href=&quot;https://gcc.gnu.org/wiki/GfortranApps&quot;&gt;https://gcc.gnu.org/wiki/GfortranApps&lt;/a&gt; for an extended list.</source>
          <target state="translated">현재 GNU Fortran 컴파일러는 &lt;a href=&quot;http://www.fortran-2000.com/ArnaudRecipes/fcvs21_f95.html&quot;&gt;NIST Fortran 77 Test Suite를&lt;/a&gt; 통과 하고 &lt;a href=&quot;http://www.netlib.org/lapack/faq.html#1.21&quot;&gt;LAPACK Test Suite&lt;/a&gt; 에서 허용 가능한 결과를 생성합니다 . 또한 &lt;a href=&quot;http://www.polyhedron.com/fortran-compiler-comparisons/polyhedron-benchmark-suite&quot;&gt;Polyhedron Fortran 컴파일러 벤치 마크&lt;/a&gt; 및 &lt;a href=&quot;http://www.netlib.org/benchmark/livermore&quot;&gt;Livermore Fortran Kernels 테스트에서&lt;/a&gt; 뛰어난 성능을 제공합니다 . &lt;a href=&quot;http://hirlam.org/&quot;&gt;HARMONIE 및 HIRLAM 일기 예보 코드&lt;/a&gt; 및 &lt;a href=&quot;http://physical-chemistry.scb.uwa.edu.au/tonto/wiki/index.php/Main_Page&quot;&gt;Tonto 양자 화학 패키지를&lt;/a&gt; 포함 하여 다수의 대규모 실제 프로그램을 컴파일하는 데 사용되었습니다 . 확장 목록 은 &lt;a href=&quot;https://gcc.gnu.org/wiki/GfortranApps&quot;&gt;https://gcc.gnu.org/wiki/GfortranApps&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c38ba61dc1a3177f325e31a77962ad514a4ba76" translate="yes" xml:space="preserve">
          <source>At the moment &lt;code&gt;CAF_ARR_REF_VECTOR&lt;/code&gt; is not implemented in the front end for descriptor-less arrays. The library caf_single has untested support for it.</source>
          <target state="translated">현재 &lt;code&gt;CAF_ARR_REF_VECTOR&lt;/code&gt; 는 디스크립터없는 어레이의 프론트 엔드에서 구현되지 않습니다. caf_single 라이브러리는 이에 대한 테스트를 거치지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="fc42a7f818d24c88494b8202b0dda5ef77224687" translate="yes" xml:space="preserve">
          <source>Atomic ADD operation</source>
          <target state="translated">원자 ADD 작업</target>
        </trans-unit>
        <trans-unit id="b7a5c288426aa560745dc7e8cc778a204636a1a2" translate="yes" xml:space="preserve">
          <source>Atomic ADD operation with prior fetch</source>
          <target state="translated">사전 페치가있는 원자 ADD 작업</target>
        </trans-unit>
        <trans-unit id="bf565b441e83c28513d95507c62ab47aec39f341" translate="yes" xml:space="preserve">
          <source>Atomic bitwise AND operation</source>
          <target state="translated">원자 비트 AND 연산</target>
        </trans-unit>
        <trans-unit id="b1bfd7d0da8d49152a1a8c7d6c2c556d9b3af332" translate="yes" xml:space="preserve">
          <source>Atomic bitwise AND operation with prior fetch</source>
          <target state="translated">이전 페치의 원자 비트 단위 AND 연산</target>
        </trans-unit>
        <trans-unit id="2e7c52210033660c4407f96486cc4830c6e671dc" translate="yes" xml:space="preserve">
          <source>Atomic bitwise OR operation</source>
          <target state="translated">원자 비트 OR 연산</target>
        </trans-unit>
        <trans-unit id="2b0189a08c36bdfd0ae0e98e4134ef618f03ff50" translate="yes" xml:space="preserve">
          <source>Atomic bitwise OR operation with prior fetch</source>
          <target state="translated">이전 페치의 원자 비트 OR 연산</target>
        </trans-unit>
        <trans-unit id="1e033cb7b407c9e892b4e4ae1f863bd3daf383fd" translate="yes" xml:space="preserve">
          <source>Atomic bitwise XOR operation with prior fetch</source>
          <target state="translated">사전 페치가있는 원자 비트 XOR 연산</target>
        </trans-unit>
        <trans-unit id="be519469bcd3e5b2d6487fc37d44ff28def3dbae" translate="yes" xml:space="preserve">
          <source>Atomic compare and swap</source>
          <target state="translated">원자 비교 및 ​​교환</target>
        </trans-unit>
        <trans-unit id="2e78c84ab5c12dcd295734f75ebb50f2529eddd2" translate="yes" xml:space="preserve">
          <source>Atomic compare and swap of a kind-4 integer or logical variable. Assigns atomically the specified value to the atomic variable, if the latter has the value specified by the passed condition value.</source>
          <target state="translated">종류 4 정수 또는 논리 변수의 원자 비교 및 ​​스왑. 후자에 전달 된 조건 값으로 지정된 값이있는 경우 원자 변수에 지정된 값을 원자 변수에 지정합니다.</target>
        </trans-unit>
        <trans-unit id="c5c3d535b17d3b00025c7eabf767b1b26ca06d5d" translate="yes" xml:space="preserve">
          <source>Atomic operation</source>
          <target state="translated">원자력 운영</target>
        </trans-unit>
        <trans-unit id="41a12f043eece5fb2decde8f4c227ab56d7148c6" translate="yes" xml:space="preserve">
          <source>Atomic subroutine</source>
          <target state="translated">원자 서브 루틴</target>
        </trans-unit>
        <trans-unit id="f4e9d304774823ba4a2a2d7c46f1f456bd19eee0" translate="yes" xml:space="preserve">
          <source>Atomic variable assignment</source>
          <target state="translated">원자 변수 할당</target>
        </trans-unit>
        <trans-unit id="9929e2f3ce73b6567e12c96ef1a3ba883c1a55d7" translate="yes" xml:space="preserve">
          <source>Atomic variable reference</source>
          <target state="translated">원자 변수 참조</target>
        </trans-unit>
        <trans-unit id="551bdfd3bd976b65a9318fb95dbf5e832e232940" translate="yes" xml:space="preserve">
          <source>Attempt to open the file with &lt;code&gt;ACTION='READWRITE'&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ACTION='READWRITE'&lt;/code&gt; 로 파일을 열려고 시도</target>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="b356eeab734c4ff47f91e2cbe385f83b802c23df" translate="yes" xml:space="preserve">
          <source>Barrier for selected images</source>
          <target state="translated">선택된 이미지의 장벽</target>
        </trans-unit>
        <trans-unit id="1d4781248bfa1e27c4aa538e6c7ff5ca1bc7f11c" translate="yes" xml:space="preserve">
          <source>Base 10 logarithm function</source>
          <target state="translated">밑이 10 인 로그 함수</target>
        </trans-unit>
        <trans-unit id="e87278a34ffbc4c17bda6e2c994a42635c3cca72" translate="yes" xml:space="preserve">
          <source>Base of a data model</source>
          <target state="translated">데이터 모델의 기초</target>
        </trans-unit>
        <trans-unit id="b0c0a5b87b0289101611830fbd70aeb258f905c4" translate="yes" xml:space="preserve">
          <source>Because of the more complicated references possible some operations may be unsupported by certain libraries. The library is expected to issue a precise error message why the operation is not permitted.</source>
          <target state="translated">보다 복잡한 참조가 가능하기 때문에 일부 라이브러리에서는 일부 조작이 지원되지 않을 수 있습니다. 라이브러리는 조작이 허용되지 않는 정확한 오류 메시지를 발행해야합니다.</target>
        </trans-unit>
        <trans-unit id="ce5081af44393adc2ba2dab9d9793ef969ae243a" translate="yes" xml:space="preserve">
          <source>Because this intrinsic is implemented in terms of the &lt;code&gt;system&lt;/code&gt; function call, its behavior with respect to signaling is processor dependent. In particular, on POSIX-compliant systems, the SIGINT and SIGQUIT signals will be ignored, and the SIGCHLD will be blocked. As such, if the parent process is terminated, the child process might not be terminated alongside.</source>
          <target state="translated">이 내장 함수는 &lt;code&gt;system&lt;/code&gt; 함수 호출 측면에서 구현되므로 신호 처리와 관련된 동작은 프로세서에 따라 다릅니다. 특히 POSIX 호환 시스템에서는 SIGINT 및 SIGQUIT 신호가 무시되고 SIGCHLD가 차단됩니다. 따라서 상위 프로세스가 종료되면 하위 프로세스가 함께 종료되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ea4ae9824f1182424000b837597d38d844e8714" translate="yes" xml:space="preserve">
          <source>Before Fortran 2008, at least one of the arguments &lt;var&gt;R&lt;/var&gt; or &lt;var&gt;P&lt;/var&gt; shall be present; since Fortran 2008, they are assumed to be zero if absent.</source>
          <target state="translated">Fortran 2008 이전에는 인수 &lt;var&gt;R&lt;/var&gt; 또는 &lt;var&gt;P&lt;/var&gt; 중 하나 이상 이 존재합니다. Fortran 2008 이후로 부재시 0으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="1dd73ae98abaf5b21a2d39baaf5d5d005b5bfa67" translate="yes" xml:space="preserve">
          <source>Beginning with the Fortran 2003 standard, there is a &lt;code&gt;FLUSH&lt;/code&gt; statement that should be preferred over the &lt;code&gt;FLUSH&lt;/code&gt; intrinsic.</source>
          <target state="translated">Fortran 2003 표준부터 &lt;code&gt;FLUSH&lt;/code&gt; 내장 함수 보다 &lt;code&gt;FLUSH&lt;/code&gt; 문이 우선합니다 .</target>
        </trans-unit>
        <trans-unit id="5cf2869b26eb2f2fd437796e9de3996c555c124d" translate="yes" xml:space="preserve">
          <source>Besides changing the calling convention, the attributes also influence the decoration of the symbol name, e.g., by a leading underscore or by a trailing at-sign followed by the number of bytes on the stack. When assigning a procedure to a procedure pointer, both should use the same calling convention.</source>
          <target state="translated">호출 규칙을 변경하는 것 외에도 속성은 기호 이름의 장식에 영향을줍니다 (예 : 선행 밑줄 또는 후행 at-sign 및 스택의 바이트 수). 프로 시저를 프로 시저 포인터에 지정할 때 둘 다 동일한 호출 규칙을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="203c67bafdb6036d2f0cc6dbdd5189e4669b71f7" translate="yes" xml:space="preserve">
          <source>Besides decimal constants, Fortran also supports binary (&lt;code&gt;b&lt;/code&gt;), octal (&lt;code&gt;o&lt;/code&gt;) and hexadecimal (&lt;code&gt;z&lt;/code&gt;) integer constants. The syntax is: &amp;lsquo;</source>
          <target state="translated">Fortran은 10 진 상수 외에도 2 진 ( &lt;code&gt;b&lt;/code&gt; ), 8 진 ( &lt;code&gt;o&lt;/code&gt; ) 및 16 진 ( &lt;code&gt;z&lt;/code&gt; ) 정수 상수를 지원합니다. 구문은 다음과 같습니다. '</target>
        </trans-unit>
        <trans-unit id="a30dd46b9e9c1bdc36f5579db55e3eb16f955c9d" translate="yes" xml:space="preserve">
          <source>Bessel function of the first kind</source>
          <target state="translated">제 1 종 베셀 기능</target>
        </trans-unit>
        <trans-unit id="0f797fe7e2e407c0ccdf341e6a12b249c9889fcc" translate="yes" xml:space="preserve">
          <source>Bessel function of the first kind of order 0</source>
          <target state="translated">첫 번째 종류의 베셀 함수 0</target>
        </trans-unit>
        <trans-unit id="8384517ffc250230cd6045af038b0d65ea3d3e6f" translate="yes" xml:space="preserve">
          <source>Bessel function of the first kind of order 1</source>
          <target state="translated">주문의 첫 번째 종류의 선박 기능 1</target>
        </trans-unit>
        <trans-unit id="444153ea0d510a7dec96c6ace3dba56306534b6a" translate="yes" xml:space="preserve">
          <source>Bessel function of the second kind</source>
          <target state="translated">제 2 종 베셀 기능</target>
        </trans-unit>
        <trans-unit id="180d8d2861b9e37acff48c68c094e736ceadef7a" translate="yes" xml:space="preserve">
          <source>Bessel function of the second kind of order 0</source>
          <target state="translated">두 번째 종류의 차수 0</target>
        </trans-unit>
        <trans-unit id="605021b17225347c7659825bde86f71274be7f76" translate="yes" xml:space="preserve">
          <source>Bessel function of the second kind of order 1</source>
          <target state="translated">두 번째 주문의 베셀 기능 1</target>
        </trans-unit>
        <trans-unit id="f34d9b0547e467d92b9019b796258eae0e9ed102" translate="yes" xml:space="preserve">
          <source>Bit extraction</source>
          <target state="translated">비트 추출</target>
        </trans-unit>
        <trans-unit id="5de844a3f211510aa83123e4871c683a603bc6b8" translate="yes" xml:space="preserve">
          <source>Bit size inquiry function</source>
          <target state="translated">비트 크기 조회 기능</target>
        </trans-unit>
        <trans-unit id="25703c888a5e9b917351196de7861c349721ccbd" translate="yes" xml:space="preserve">
          <source>Bit test function</source>
          <target state="translated">비트 테스트 기능</target>
        </trans-unit>
        <trans-unit id="81d2ebea896d25f1a13f14232bbcc8eb08dd4ae6" translate="yes" xml:space="preserve">
          <source>Bitwise AND of array elements</source>
          <target state="translated">배열 요소의 비트 단위 AND</target>
        </trans-unit>
        <trans-unit id="728f5f3b75cd63caacb5ade57b62aa428e6330a7" translate="yes" xml:space="preserve">
          <source>Bitwise OR of array elements</source>
          <target state="translated">배열 요소의 비트 단위 OR</target>
        </trans-unit>
        <trans-unit id="22798b405425f016b1b076dd44976c0afd2c5324" translate="yes" xml:space="preserve">
          <source>Bitwise XOR of array elements</source>
          <target state="translated">배열 요소의 비트 단위 XOR</target>
        </trans-unit>
        <trans-unit id="bc64a003025d89e33f430ca072ade49abff64d75" translate="yes" xml:space="preserve">
          <source>Bitwise greater than</source>
          <target state="translated">조금 더 큰</target>
        </trans-unit>
        <trans-unit id="d618e855b47a89a9df579cca5ab8d12794e2a3e0" translate="yes" xml:space="preserve">
          <source>Bitwise greater than or equal to</source>
          <target state="translated">비트 단위 이상</target>
        </trans-unit>
        <trans-unit id="e809f4cd4800cb733cc274f61df0d7ae79489dd2" translate="yes" xml:space="preserve">
          <source>Bitwise less than</source>
          <target state="translated">비트 이하</target>
        </trans-unit>
        <trans-unit id="ec4aa5c7f77dbf1295f3945c4d0ce92888b1a26b" translate="yes" xml:space="preserve">
          <source>Bitwise less than or equal to</source>
          <target state="translated">비트 이하</target>
        </trans-unit>
        <trans-unit id="2d1a409d40ca7e64b41bba02a5680568b1d38704" translate="yes" xml:space="preserve">
          <source>Bitwise logical &lt;code&gt;AND&lt;/code&gt;.</source>
          <target state="translated">비트 논리 &lt;code&gt;AND&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4c93447f0677efd2761eac0517f4c5c95115db1" translate="yes" xml:space="preserve">
          <source>Bitwise logical &lt;code&gt;OR&lt;/code&gt;.</source>
          <target state="translated">논리적 비트 &lt;code&gt;OR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02e4d842d41b458f02ee56bb1e36d5b78e74b474" translate="yes" xml:space="preserve">
          <source>Bitwise logical AND</source>
          <target state="translated">비트 논리 AND</target>
        </trans-unit>
        <trans-unit id="51cc17b61d71e74324199fe3e18630c9479fa344" translate="yes" xml:space="preserve">
          <source>Bitwise logical OR</source>
          <target state="translated">비트 논리 OR</target>
        </trans-unit>
        <trans-unit id="7e262f8156e0bde7d3fdf45da4373816d5a0f744" translate="yes" xml:space="preserve">
          <source>Bitwise logical and</source>
          <target state="translated">비트 논리</target>
        </trans-unit>
        <trans-unit id="6fbd08e14ef9cd92c8635e48a67cba790f1f654b" translate="yes" xml:space="preserve">
          <source>Bitwise logical exclusive or</source>
          <target state="translated">비트 논리 배타적 또는</target>
        </trans-unit>
        <trans-unit id="e12d57bf21bac825baf9ff63c9856f69ab644445" translate="yes" xml:space="preserve">
          <source>Bitwise logical exclusive or.</source>
          <target state="translated">비트 논리 배타적 또는</target>
        </trans-unit>
        <trans-unit id="4870e18ecb37553176726ddbf50c1a19130c1d2d" translate="yes" xml:space="preserve">
          <source>Bitwise logical or</source>
          <target state="translated">비트 논리 또는</target>
        </trans-unit>
        <trans-unit id="4c5c0cad4ae403108a5dc8624302e33f4750bc81" translate="yes" xml:space="preserve">
          <source>Bitwise operation</source>
          <target state="translated">비트 단위 연산</target>
        </trans-unit>
        <trans-unit id="19c6b04aae9aafa4c22a40b4395f6dcb6758149d" translate="yes" xml:space="preserve">
          <source>Both are equivalent to the value &lt;code&gt;NULL&lt;/code&gt; in C.</source>
          <target state="translated">둘 다 C의 &lt;code&gt;NULL&lt;/code&gt; 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a1a67f229b779231b95e7482c8d6d7fa949c2f92" translate="yes" xml:space="preserve">
          <source>Brief list of all &lt;code&gt;gfortran&lt;/code&gt; options, without explanations.</source>
          <target state="translated">설명없이 모든 &lt;code&gt;gfortran&lt;/code&gt; 옵션 의 간략한 목록 .</target>
        </trans-unit>
        <trans-unit id="2158ee2d66e03393d4b426585c79604199f8a8d3" translate="yes" xml:space="preserve">
          <source>By default no exception traps are enabled.</source>
          <target state="translated">기본적으로 예외 트랩은 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9470bfdf5b3c18663e010eb9344ce05e5941c98f" translate="yes" xml:space="preserve">
          <source>By default the parentheses in expression are honored for all optimization levels such that the compiler does not do any re-association. Using</source>
          <target state="translated">기본적으로 표현식의 괄호는 컴파일러가 다시 연결하지 않도록 모든 최적화 수준에 적용됩니다. 사용</target>
        </trans-unit>
        <trans-unit id="6b8ea690003bcfcd116abdd1fc3d0b4c7d61f7e0" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;gfortran&lt;/code&gt; enforces proper alignment of all variables in a &lt;code&gt;COMMON&lt;/code&gt; block by padding them as needed. On certain platforms this is mandatory, on others it increases performance. If a &lt;code&gt;COMMON&lt;/code&gt; block is not declared with consistent data types everywhere, this padding can cause trouble, and</source>
          <target state="translated">&lt;code&gt;gfortran&lt;/code&gt; 은 기본적 으로 &lt;code&gt;COMMON&lt;/code&gt; 블록 의 모든 변수 를 필요에 따라 채워서 적절히 정렬 합니다. 특정 플랫폼에서는 필수이며, 다른 플랫폼에서는 성능이 향상됩니다. 경우 &lt;code&gt;COMMON&lt;/code&gt; 블록이 모든 곳에서 일관된 데이터 유형으로 선언되지 않은이 패딩 문제를 야기 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="494e8f480b13e3bd8b25bcbebeaf211910421e4c" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;gfortran&lt;/code&gt; warns about any occasion of variables being padded for proper alignment inside a &lt;code&gt;COMMON&lt;/code&gt; block. This warning can be turned off via</source>
          <target state="translated">기본적으로 &lt;code&gt;gfortran&lt;/code&gt; 은 &lt;code&gt;COMMON&lt;/code&gt; 블록 내에서 적절한 정렬을 위해 변수가 채워지는 경우에 대해 경고합니다 . 이 경고는 다음을 통해 끌 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f651876a014bd25ec25517c7b71e97c6f44ab155" translate="yes" xml:space="preserve">
          <source>By default, GNU Fortran appends an underscore to external names. If this option is used GNU Fortran appends two underscores to names with underscores and one underscore to external names with no underscores. GNU Fortran also appends two underscores to internal names with underscores to avoid naming collisions with external names.</source>
          <target state="translated">기본적으로 GNU Fortran은 밑줄을 외부 이름에 추가합니다. 이 옵션을 사용하면 GNU Fortran은 밑줄이있는 이름에 두 개의 밑줄을 추가하고 밑줄이없는 외부 이름에 한 개의 밑줄을 추가합니다. GNU Fortran은 외부 이름과의 이름 충돌을 피하기 위해 내부 이름에 두 개의 밑줄을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="621975a477791b3a406958e2698ec52a7c743143" translate="yes" xml:space="preserve">
          <source>By default, a summary for all exceptions but &amp;lsquo;</source>
          <target state="translated">기본적으로 '을 제외한 모든 예외에 대한 요약</target>
        </trans-unit>
        <trans-unit id="95c2ca9e022b2d009f78184d5dc34f0506c3b86a" translate="yes" xml:space="preserve">
          <source>By default, tabs are accepted as whitespace, but tabs are not members of the Fortran Character Set. For continuation lines, a tab followed by a digit between 1 and 9 is supported.</source>
          <target state="translated">기본적으로 탭은 공백으로 허용되지만 탭은 포트란 문자 집합의 멤버가 아닙니다. 연속 선의 경우 탭과 1에서 9 사이의 숫자가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="bf10d05944108cdfc372215085afd519fc92c049" translate="yes" xml:space="preserve">
          <source>By default, the procedure name is the lower-cased Fortran name with an appended underscore (&lt;code&gt;_&lt;/code&gt;); using</source>
          <target state="translated">기본적으로 프로 시저 이름은 밑줄 ( &lt;code&gt;_&lt;/code&gt; )이 추가 된 소문자 Fortran 이름입니다 . 사용</target>
        </trans-unit>
        <trans-unit id="edfcca908c326b0071bb7e39182b30097c02a1c8" translate="yes" xml:space="preserve">
          <source>By setting the &lt;code&gt;GFORTRAN_CONVERT_UNIT&lt;/code&gt; variable, it is possible to change the representation of data for unformatted files. The syntax for the &lt;code&gt;GFORTRAN_CONVERT_UNIT&lt;/code&gt; variable is:</source>
          <target state="translated">&lt;code&gt;GFORTRAN_CONVERT_UNIT&lt;/code&gt; 변수 를 설정하면 형식화되지 않은 파일의 데이터 표시를 변경할 수 있습니다. &lt;code&gt;GFORTRAN_CONVERT_UNIT&lt;/code&gt; 변수 의 구문 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="403b5445ac98aeb69d7c99aacbf642c1c998d25d" translate="yes" xml:space="preserve">
          <source>C definition</source>
          <target state="translated">C 정의</target>
        </trans-unit>
        <trans-unit id="edba7476e44f0a1276550cdb3f850cc6a1a2a8ea" translate="yes" xml:space="preserve">
          <source>C pointers are represented in Fortran via the special opaque derived type &lt;code&gt;type(c_ptr)&lt;/code&gt; (with private components). Thus one needs to use intrinsic conversion procedures to convert from or to C pointers.</source>
          <target state="translated">C 포인터는 특수 불투명 파생 유형 &lt;code&gt;type(c_ptr)&lt;/code&gt; (개인 구성 요소 포함)을 통해 포트란에 표시됩니다 . 따라서 C 포인터에서 또는 C 포인터로 변환하려면 고유 변환 절차를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="502ca6c945d9f8aee115c49e01f9edd12a50b0c8" translate="yes" xml:space="preserve">
          <source>C type</source>
          <target state="translated">C 타입</target>
        </trans-unit>
        <trans-unit id="f7f35938e07f994b80b54eb87f01789cb3b2a241" translate="yes" xml:space="preserve">
          <source>CHDIR</source>
          <target state="translated">CHDIR</target>
        </trans-unit>
        <trans-unit id="1258e611fc7cbd03d2f39e6a27e8d2acdd24bc5b" translate="yes" xml:space="preserve">
          <source>CMPLX</source>
          <target state="translated">CMPLX</target>
        </trans-unit>
        <trans-unit id="b93902c9a6f48c919988f40fbd5dbfc953916ca2" translate="yes" xml:space="preserve">
          <source>COMPLEX</source>
          <target state="translated">COMPLEX</target>
        </trans-unit>
        <trans-unit id="00b8f9a935ceea9af0867a7456fd37b036afca33" translate="yes" xml:space="preserve">
          <source>CPU time function</source>
          <target state="translated">CPU 시간 기능</target>
        </trans-unit>
        <trans-unit id="9c57ead1e73cf1ac994dbc83e611d53391aed85b" translate="yes" xml:space="preserve">
          <source>CPU time subroutine</source>
          <target state="translated">CPU 시간 서브 루틴</target>
        </trans-unit>
        <trans-unit id="afcb9be24b81517be9e3ecd27a6462cfa3090967" translate="yes" xml:space="preserve">
          <source>CPU_TIME</source>
          <target state="translated">CPU_TIME</target>
        </trans-unit>
        <trans-unit id="ded88b5200a35884165325c3129ae4ce1bc6646d" translate="yes" xml:space="preserve">
          <source>Calculates for each array element of the variable &lt;var&gt;a&lt;/var&gt; the maximum value for that element in the current team; if &lt;var&gt;result_image&lt;/var&gt; has the value 0, the result shall be stored on all images, otherwise, only on the specified image. This function operates on numeric values and character strings.</source>
          <target state="translated">변수 &lt;var&gt;a&lt;/var&gt; 각 배열 요소에 대해 현재 팀에서 해당 요소의 최대 값을 계산합니다. 만약 &lt;var&gt;result_image&lt;/var&gt; 가 0의 값을 가지며, 그 결과는 지정된 이미지를, 그렇지 않으면, 모든 이미지를 저장한다. 이 기능은 숫자 값과 문자열에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="61aba3fb834bcbe10aa672aee0b4e8c2bfa014cd" translate="yes" xml:space="preserve">
          <source>Calculates for each array element of the variable &lt;var&gt;a&lt;/var&gt; the minimum value for that element in the current team; if &lt;var&gt;result_image&lt;/var&gt; has the value 0, the result shall be stored on all images, otherwise, only on the specified image. This function operates on numeric values and character strings.</source>
          <target state="translated">변수 &lt;var&gt;a&lt;/var&gt; 각 배열 요소에 대해 현재 팀에서 해당 요소의 최소값을 계산합니다 . 만약 &lt;var&gt;result_image&lt;/var&gt; 가 0의 값을 가지며, 그 결과는 지정된 이미지를, 그렇지 않으면, 모든 이미지를 저장한다. 이 기능은 숫자 값과 문자열에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="368b3e1172e6f91df4e6fe15761fd822cc33fc28" translate="yes" xml:space="preserve">
          <source>Calculates for each array element of the variable &lt;var&gt;a&lt;/var&gt; the reduction value for that element in the current team; if &lt;var&gt;result_image&lt;/var&gt; has the value 0, the result shall be stored on all images, otherwise, only on the specified image. The &lt;var&gt;opr&lt;/var&gt; is a pure function doing a mathematically commutative and associative operation.</source>
          <target state="translated">변수 &lt;var&gt;a&lt;/var&gt; 각 배열 요소에 대해 현재 팀의 해당 요소에 대한 감소 값을 계산합니다. 만약 &lt;var&gt;result_image&lt;/var&gt; 가 0의 값을 가지며, 그 결과는 지정된 이미지를, 그렇지 않으면, 모든 이미지를 저장한다. &lt;var&gt;opr&lt;/var&gt; 수학적으로 교환 법칙과 결합 작업을하고있는 순수 기능입니다.</target>
        </trans-unit>
        <trans-unit id="afc6b28729b114d6cb3a4ae1ee84081e76f1467a" translate="yes" xml:space="preserve">
          <source>Calculates for each array element of the variable &lt;var&gt;a&lt;/var&gt; the sum of all values for that element in the current team; if &lt;var&gt;result_image&lt;/var&gt; has the value 0, the result shall be stored on all images, otherwise, only on the specified image. This function operates on numeric values only.</source>
          <target state="translated">변수 &lt;var&gt;a&lt;/var&gt; 각 배열 요소에 대해 현재 팀의 해당 요소에 대한 모든 값의 합계를 계산합니다 . 만약 &lt;var&gt;result_image&lt;/var&gt; 가 0의 값을 가지며, 그 결과는 지정된 이미지를, 그렇지 않으면, 모든 이미지를 저장한다. 이 기능은 숫자 값에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="51e0a82828daf667cb3858a5349dde7ff38cad64" translate="yes" xml:space="preserve">
          <source>Calculates the Euclidean vector norm (&lt;em&gt;L_2&lt;/em&gt; norm) of of &lt;var&gt;ARRAY&lt;/var&gt; along dimension &lt;var&gt;DIM&lt;/var&gt;.</source>
          <target state="translated">치수 &lt;var&gt;DIM&lt;/var&gt; 을 따라 &lt;var&gt;ARRAY&lt;/var&gt; 의 유클리드 벡터 노름 ( &lt;em&gt;L_2&lt;/em&gt; 노름)을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="c08f2f83a949abe6d99e9a132fde2833fda77c1c" translate="yes" xml:space="preserve">
          <source>Calculates the parity, i.e. the reduction using &lt;code&gt;.XOR.&lt;/code&gt;, of &lt;var&gt;MASK&lt;/var&gt; along dimension &lt;var&gt;DIM&lt;/var&gt;.</source>
          <target state="translated">패리티, 즉 &lt;code&gt;.XOR.&lt;/code&gt; 사용한 축소를 계산합니다. 의 &lt;var&gt;MASK&lt;/var&gt; 치수를 따라 &lt;var&gt;DIM&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="f67ff76084ad94c9888c164676068779412f45a6" translate="yes" xml:space="preserve">
          <source>Called to free or deregister the memory of a coarray; the processor calls this function for automatic and explicit deallocation. In case of an error, this function shall fail with an error message, unless the &lt;var&gt;STAT&lt;/var&gt; variable is not null. The library is only expected to free memory it allocated itself during a call to &lt;code&gt;_gfortran_caf_register&lt;/code&gt;.</source>
          <target state="translated">거친 기억을 해제하거나 등록 해제하기 위해 호출됩니다. 프로세서는 자동 및 명시 적 할당 해제를 위해이 기능을 호출합니다. 오류가 발생하면 &lt;var&gt;STAT&lt;/var&gt; 변수가 null이 아닌 한이 함수는 오류 메시지와 함께 실패 합니다. 라이브러리는 &lt;code&gt;_gfortran_caf_register&lt;/code&gt; 호출 중에 자체 할당 한 메모리 만 비워야 합니다.</target>
        </trans-unit>
        <trans-unit id="685a2b49527c9946029a140f6e7e862e57fd4a60" translate="yes" xml:space="preserve">
          <source>Called to get a scalar, an array section or a whole array from a remote image identified by the &lt;var&gt;image_index&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;image_index&lt;/var&gt; 로 식별 된 원격 이미지에서 스칼라, 배열 섹션 또는 전체 배열을 가져 오기 위해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="73fb8d143c8ed75342952d0a4f32ee969404700a" translate="yes" xml:space="preserve">
          <source>Called to get an array section or a whole array from a remote, image identified by the image_index.</source>
          <target state="translated">image_index로 식별 된 원격 이미지에서 배열 섹션 또는 전체 배열을 가져 오기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="42b35eab41e8652a8be66bf5712a7946e722dd84" translate="yes" xml:space="preserve">
          <source>Called to send a scalar, an array section or a whole array from a local to a remote image identified by the &lt;var&gt;image_index&lt;/var&gt;.</source>
          <target state="translated">스칼라, 배열 섹션 또는 전체 배열을 로컬에서 &lt;var&gt;image_index&lt;/var&gt; 로 식별 된 원격 이미지로 보내기 위해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="2a1f3e0ba6a5254764ea28e7afe8497a1c55cd00" translate="yes" xml:space="preserve">
          <source>Called to send a scalar, an array section or a whole array from a local to a remote image identified by the image_index.</source>
          <target state="translated">스칼라, 배열 섹션 또는 전체 배열을 로컬에서 image_index로 식별 된 원격 이미지로 보내기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a3f66a579a064fa7e118247f05db9a81443d7709" translate="yes" xml:space="preserve">
          <source>Called to send a scalar, an array section or a whole array from a remote image identified by the &lt;var&gt;src_image_index&lt;/var&gt; to a remote image identified by the &lt;var&gt;dst_image_index&lt;/var&gt;.</source>
          <target state="translated">에 의해 식별 된 원격 화상으로부터 스칼라 배열 부분 또는 전체 어레이를 보내라고 &lt;var&gt;src_image_index&lt;/var&gt; 의해 식별 된 이미지를 원격 &lt;var&gt;dst_image_index&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="de089d2fae25ce2119b044ebd58a58158d63d7b8" translate="yes" xml:space="preserve">
          <source>Calling this subroutine causes the process to pause for &lt;var&gt;SECONDS&lt;/var&gt; seconds.</source>
          <target state="translated">이 서브 루틴을 호출하면 프로세스가 &lt;var&gt;SECONDS&lt;/var&gt; 초 동안 일시 정지됩니다 .</target>
        </trans-unit>
        <trans-unit id="f8eba46ecad008a4e218a210a71672db04d7e157" translate="yes" xml:space="preserve">
          <source>Cancel an assertion with the predicate &lt;var&gt;predicate&lt;/var&gt; and answer &lt;var&gt;answer&lt;/var&gt;.</source>
          <target state="translated">술어 &lt;var&gt;predicate&lt;/var&gt; 로 어설 션을 취소 하고 응답을 &lt;var&gt;answer&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="59d15eea66865b0282cb17c0e3120ed653071f95" translate="yes" xml:space="preserve">
          <source>Cancel any previous definition of &lt;var&gt;name&lt;/var&gt;, either built in or provided with a</source>
          <target state="translated">내장 또는 제공되는 &lt;var&gt;name&lt;/var&gt; 의 이전 정의를 취소하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c3e78e25303f285caea07bc640a21603a3fdef3" translate="yes" xml:space="preserve">
          <source>Carriage return only</source>
          <target state="translated">캐리지 리턴 만</target>
        </trans-unit>
        <trans-unit id="98babc7d151e019f378c33e513d3cb9afaaa0327" translate="yes" xml:space="preserve">
          <source>Change access permissions of files</source>
          <target state="translated">파일의 액세스 권한 변경</target>
        </trans-unit>
        <trans-unit id="260f53de2ce74ccda0ba4436f6a571ffd27d12ea" translate="yes" xml:space="preserve">
          <source>Change current working directory to a specified path.</source>
          <target state="translated">현재 작업 디렉토리를 지정된 경로로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="0540db552edff9aefeb60127437ee15ff20542fb" translate="yes" xml:space="preserve">
          <source>Change the interpretation of backslashes in string literals from a single backslash character to &amp;ldquo;C-style&amp;rdquo; escape characters. The following combinations are expanded &lt;code&gt;\a&lt;/code&gt;, &lt;code&gt;\b&lt;/code&gt;, &lt;code&gt;\f&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, &lt;code&gt;\t&lt;/code&gt;, &lt;code&gt;\v&lt;/code&gt;, &lt;code&gt;\\&lt;/code&gt;, and &lt;code&gt;\0&lt;/code&gt; to the ASCII characters alert, backspace, form feed, newline, carriage return, horizontal tab, vertical tab, backslash, and NUL, respectively. Additionally, &lt;code&gt;\x&lt;/code&gt;&lt;var&gt;nn&lt;/var&gt;, &lt;code&gt;\u&lt;/code&gt;&lt;var&gt;nnnn&lt;/var&gt; and &lt;code&gt;\U&lt;/code&gt;&lt;var&gt;nnnnnnnn&lt;/var&gt; (where each &lt;var&gt;n&lt;/var&gt; is a hexadecimal digit) are translated into the Unicode characters corresponding to the specified code points. All other combinations of a character preceded by \ are unexpanded.</source>
          <target state="translated">문자열 리터럴의 백 슬래시 해석을 단일 백 슬래시 문자에서 &quot;C 스타일&quot;이스케이프 문자로 변경하십시오. 다음 조합은 &lt;code&gt;\a&lt;/code&gt; , &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;\f&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; , &lt;code&gt;\r&lt;/code&gt; , &lt;code&gt;\t&lt;/code&gt; , &lt;code&gt;\v&lt;/code&gt; , &lt;code&gt;\\&lt;/code&gt; 및 &lt;code&gt;\0&lt;/code&gt; 으로 ASCII 문자 경고, 백 스페이스, 용지 공급, 줄 바꿈, 캐리지 리턴, 가로 탭으로 확장됩니다. , 세로 탭, 백 슬래시 및 NUL. 또한 &lt;code&gt;\x&lt;/code&gt; &lt;var&gt;nn&lt;/var&gt; , &lt;code&gt;\u&lt;/code&gt; &lt;var&gt;nnnn&lt;/var&gt; 및 &lt;code&gt;\U&lt;/code&gt; &lt;var&gt;nnnnnnnn&lt;/var&gt; (각각의 &lt;var&gt;n&lt;/var&gt; 는 16 진수입니다.)는 지정된 코드 포인트에 해당하는 유니 코드 문자로 변환됩니다. \ 앞에 오는 문자의 다른 모든 조합은 확장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cbe6906aa9b8a77cda6be78ee588789dd31c70ce" translate="yes" xml:space="preserve">
          <source>Change working directory</source>
          <target state="translated">작업 디렉토리 변경</target>
        </trans-unit>
        <trans-unit id="eea370510744912991547865226311a4554eafe9" translate="yes" xml:space="preserve">
          <source>Character in ASCII collating sequence</source>
          <target state="translated">ASCII 조합 순서의 문자</target>
        </trans-unit>
        <trans-unit id="93b528fc78e924179bac2c006bbd6d1a542679e9" translate="yes" xml:space="preserve">
          <source>Character length of the function result, if it is a of type &lt;code&gt;CHARACTER&lt;/code&gt; and no C binding is used</source>
          <target state="translated">함수 결과의 문자 길이 ( &lt;code&gt;CHARACTER&lt;/code&gt; 유형 이고 C 바인딩이 사용되지 않은 경우)</target>
        </trans-unit>
        <trans-unit id="6664bcdd3d0ae01c04ee310f06653bd32340976b" translate="yes" xml:space="preserve">
          <source>Character(&lt;var&gt;len&lt;/var&gt;)</source>
          <target state="translated">Character(&lt;var&gt;len&lt;/var&gt;)</target>
        </trans-unit>
        <trans-unit id="302c5b5827e02ab0466eddb29fe2afaa117ad581" translate="yes" xml:space="preserve">
          <source>Character-to-integer conversion function</source>
          <target state="translated">문자-정수 변환 기능</target>
        </trans-unit>
        <trans-unit id="0eca3e561fce08ef4c3630019c8b1b1418625032" translate="yes" xml:space="preserve">
          <source>Check the code for syntax errors, but do not actually compile it. This will generate module files for each module present in the code, but no other output file.</source>
          <target state="translated">코드에 구문 오류가 있는지 확인하지만 실제로 컴파일하지는 마십시오. 이렇게하면 코드에있는 각 모듈에 대한 모듈 파일이 생성되지만 다른 출력 파일은 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b41f68c03619feab3cc08d3f333f33bfb9286fb0" translate="yes" xml:space="preserve">
          <source>Checks file access modes</source>
          <target state="translated">파일 액세스 모드를 확인합니다</target>
        </trans-unit>
        <trans-unit id="927b60f0a7c5bfccce8c05753c5b58b9ed32975c" translate="yes" xml:space="preserve">
          <source>Choose character kind</source>
          <target state="translated">문자 종류를 선택하십시오</target>
        </trans-unit>
        <trans-unit id="312e3da5b8d8fc186648c99a814b972c25289aa5" translate="yes" xml:space="preserve">
          <source>Choose integer kind</source>
          <target state="translated">정수 종류를 선택하십시오</target>
        </trans-unit>
        <trans-unit id="9c7d486265c78ac950c638932a8ab6895ee99567" translate="yes" xml:space="preserve">
          <source>Choose real kind</source>
          <target state="translated">진짜 종류를 선택하십시오</target>
        </trans-unit>
        <trans-unit id="8ff057702146fa9076a2b274cf3e7444e3b02e94" translate="yes" xml:space="preserve">
          <source>Circular shift elements of an array</source>
          <target state="translated">배열의 원형 이동 요소</target>
        </trans-unit>
        <trans-unit id="47e575792f49544e528121a141f6cd82ca4fe559" translate="yes" xml:space="preserve">
          <source>Class:</source>
          <target state="translated">Class:</target>
        </trans-unit>
        <trans-unit id="1d575e2b797291a4fe91e40f871090e3871d3cfc" translate="yes" xml:space="preserve">
          <source>Clear bit</source>
          <target state="translated">클리어 비트</target>
        </trans-unit>
        <trans-unit id="ffd51bd1963303cca4bcb433151864afb59b64ea" translate="yes" xml:space="preserve">
          <source>Coarray of any type (optional; if &lt;var&gt;DIM&lt;/var&gt; present, required).</source>
          <target state="translated">모든 유형의 Coarray (선택 사항, &lt;var&gt;DIM&lt;/var&gt; 이있는 경우 필수).</target>
        </trans-unit>
        <trans-unit id="6e564dd6ba682d0b6f26a4b2846edd183b01997e" translate="yes" xml:space="preserve">
          <source>Coarray of any type.</source>
          <target state="translated">모든 유형의 굵은 선.</target>
        </trans-unit>
        <trans-unit id="24a72e35898db30f8565da27e7ac5ba8bb79598b" translate="yes" xml:space="preserve">
          <source>Coarray support for serial programs with</source>
          <target state="translated">시리얼 프로그램을위한 Coarray 지원</target>
        </trans-unit>
        <trans-unit id="e7d5e82c3d8cf6aecb50f1c3dec1dfd81862c300" translate="yes" xml:space="preserve">
          <source>Code Generation Options</source>
          <target state="translated">코드 생성 옵션</target>
        </trans-unit>
        <trans-unit id="f45cb8fc71eb171d806f2c9fbc3f7e33e13ac130" translate="yes" xml:space="preserve">
          <source>Code in ASCII collating sequence</source>
          <target state="translated">ASCII 조합 순서의 코드</target>
        </trans-unit>
        <trans-unit id="642f5b8bf27f7c5ceb4089adda001f0e517e735e" translate="yes" xml:space="preserve">
          <source>Collective maximum reduction</source>
          <target state="translated">집단 최대 감소</target>
        </trans-unit>
        <trans-unit id="38e6a433107ddd7634eadc3b94f7be5df9145da8" translate="yes" xml:space="preserve">
          <source>Collective minimum reduction</source>
          <target state="translated">집단 최소 감소</target>
        </trans-unit>
        <trans-unit id="a1eaaa535d0fc93a2976d521fe34fa8f8e629578" translate="yes" xml:space="preserve">
          <source>Collective subroutine</source>
          <target state="translated">집단 서브 루틴</target>
        </trans-unit>
        <trans-unit id="136ddb6a75481e8cfd8f1998dea3b44e2f549d35" translate="yes" xml:space="preserve">
          <source>Collective summing reduction</source>
          <target state="translated">집단 합산 감소</target>
        </trans-unit>
        <trans-unit id="758d92958976f6d2dd49bd957265e0ea47511e7c" translate="yes" xml:space="preserve">
          <source>Combined left shift</source>
          <target state="translated">조합 된 왼쪽 시프트</target>
        </trans-unit>
        <trans-unit id="84e2223096285eec5a958404306f323e2a73cdf1" translate="yes" xml:space="preserve">
          <source>Combined right shift</source>
          <target state="translated">결합 된 오른쪽 교대</target>
        </trans-unit>
        <trans-unit id="34ae8a26580d6c091e1596af4eb11d77810ea06b" translate="yes" xml:space="preserve">
          <source>Command options supported by &lt;code&gt;gfortran&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gfortran&lt;/code&gt; 이 지원하는 명령 옵션 .</target>
        </trans-unit>
        <trans-unit id="719d17f048f27d99ad4ddc3aad0911b8bda899e5" translate="yes" xml:space="preserve">
          <source>Compiler extensions:</source>
          <target state="translated">컴파일러 확장 :</target>
        </trans-unit>
        <trans-unit id="ab8dc424cefdcedda375f546df052825622c54be" translate="yes" xml:space="preserve">
          <source>Compiler version string</source>
          <target state="translated">컴파일러 버전 문자열</target>
        </trans-unit>
        <trans-unit id="f8ad3ce6091208da960c4f9ee62d22e28a03304d" translate="yes" xml:space="preserve">
          <source>Complementary error function</source>
          <target state="translated">보완 오류 기능</target>
        </trans-unit>
        <trans-unit id="12a2fd6a5caf1062c731dc495f8cd1bdbb355dc3" translate="yes" xml:space="preserve">
          <source>Complex conjugate function</source>
          <target state="translated">복잡한 켤레 함수</target>
        </trans-unit>
        <trans-unit id="48e1b1b88c3d7c1dce9c133674796b1ecac0d5d1" translate="yes" xml:space="preserve">
          <source>Complex conversion function</source>
          <target state="translated">복잡한 변환 기능</target>
        </trans-unit>
        <trans-unit id="63ce726434fa9464f1128577f0a1fc19fdaa41c2" translate="yes" xml:space="preserve">
          <source>Concatenates &lt;var&gt;NCOPIES&lt;/var&gt; copies of a string.</source>
          <target state="translated">문자열의 &lt;var&gt;NCOPIES&lt;/var&gt; 사본을 연결 합니다.</target>
        </trans-unit>
        <trans-unit id="f5fe73c0e7d8afc203f459ff5d86f4fa08a5f7dc" translate="yes" xml:space="preserve">
          <source>Contrary to &lt;code&gt;gcc&lt;/code&gt;&amp;rsquo;s meaning of</source>
          <target state="translated">&lt;code&gt;gcc&lt;/code&gt; 의 의미 와 달리</target>
        </trans-unit>
        <trans-unit id="2d82a4b27a4b305690d5ac612046a955778a9fa5" translate="yes" xml:space="preserve">
          <source>Contributing</source>
          <target state="translated">Contributing</target>
        </trans-unit>
        <trans-unit id="04f897fa9705a45362d138aee1e3f78e007b1af1" translate="yes" xml:space="preserve">
          <source>Contributors to GNU Fortran</source>
          <target state="translated">GNU Fortran에 기고자</target>
        </trans-unit>
        <trans-unit id="00656ecaac3cd06dda885cb34ac89a85adf0521d" translate="yes" xml:space="preserve">
          <source>Controlling the variant of Fortran language compiled.</source>
          <target state="translated">컴파일 된 포트란 언어의 변형 제어</target>
        </trans-unit>
        <trans-unit id="619ea7422e1635a9f131b7a407dc350696993a3e" translate="yes" xml:space="preserve">
          <source>Converse function: &lt;a href=&quot;tan#TAN&quot;&gt;TAN&lt;/a&gt; Degrees function: &lt;a href=&quot;cotand#COTAND&quot;&gt;COTAND&lt;/a&gt;</source>
          <target state="translated">대화 기능 : &lt;a href=&quot;tan#TAN&quot;&gt;TAN&lt;/a&gt; Degrees 기능 : &lt;a href=&quot;cotand#COTAND&quot;&gt;COTAND&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b9e511fa9ffc4c5d4ba69bfd859cfd3ddad14b56" translate="yes" xml:space="preserve">
          <source>Converse function: &lt;a href=&quot;tand#TAND&quot;&gt;TAND&lt;/a&gt; Radians function: &lt;a href=&quot;cotan#COTAN&quot;&gt;COTAN&lt;/a&gt;</source>
          <target state="translated">대화 기능 : &lt;a href=&quot;tand#TAND&quot;&gt;TAND&lt;/a&gt; 라디안 기능 : &lt;a href=&quot;cotan#COTAN&quot;&gt;COTAN&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8bae3f0468e05ca326dfd3e0017af87a554461d2" translate="yes" xml:space="preserve">
          <source>Convert C into Fortran pointer</source>
          <target state="translated">C를 포트란 포인터로 변환</target>
        </trans-unit>
        <trans-unit id="3382caf15c9ca562f5f60b590528cc1cfb23288d" translate="yes" xml:space="preserve">
          <source>Convert C into Fortran procedure pointer</source>
          <target state="translated">C를 포트란 프로 시저 포인터로 변환</target>
        </trans-unit>
        <trans-unit id="3273790cc762cb6d20959735ffa1829bf9e648c4" translate="yes" xml:space="preserve">
          <source>Convert time to GMT info</source>
          <target state="translated">시간을 GMT 정보로 변환</target>
        </trans-unit>
        <trans-unit id="e96d13b61848efd2bc5dc39dd8e3fbf18e31b39d" translate="yes" xml:space="preserve">
          <source>Convert time to local time info</source>
          <target state="translated">시간을 현지 시간 정보로 변환</target>
        </trans-unit>
        <trans-unit id="53dc955cb07cc6d3deb2d9d88a6dc1e636329877" translate="yes" xml:space="preserve">
          <source>Convert to 16-bit integer type</source>
          <target state="translated">16 비트 정수형으로 변환</target>
        </trans-unit>
        <trans-unit id="3a4cdb9b32b6daac7eb9699a1b09f86d1d2a9778" translate="yes" xml:space="preserve">
          <source>Convert to 64-bit integer type</source>
          <target state="translated">64 비트 정수 유형으로 변환</target>
        </trans-unit>
        <trans-unit id="5269eae92cd848afb83ac4ea0c817bc408173ef2" translate="yes" xml:space="preserve">
          <source>Convert to a &lt;code&gt;KIND=2&lt;/code&gt; integer type. This is equivalent to the standard &lt;code&gt;INT&lt;/code&gt; intrinsic with an optional argument of &lt;code&gt;KIND=2&lt;/code&gt;, and is only included for backwards compatibility.</source>
          <target state="translated">&lt;code&gt;KIND=2&lt;/code&gt; 정수 유형으로 변환하십시오 . 이는 선택적 인수 &lt;code&gt;KIND=2&lt;/code&gt; 인 표준 &lt;code&gt;INT&lt;/code&gt; 내장 함수와 동일 하며 이전 버전과의 호환성을 위해서만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="02b8746fc1bca23a2145890a3c3e597a6444bf78" translate="yes" xml:space="preserve">
          <source>Convert to a &lt;code&gt;KIND=4&lt;/code&gt; integer type, which is the same size as a C &lt;code&gt;long&lt;/code&gt; integer. This is equivalent to the standard &lt;code&gt;INT&lt;/code&gt; intrinsic with an optional argument of &lt;code&gt;KIND=4&lt;/code&gt;, and is only included for backwards compatibility.</source>
          <target state="translated">(A)에 변환 &lt;code&gt;KIND=4&lt;/code&gt; 는 C와 같은 크기의 정수형, &lt;code&gt;long&lt;/code&gt; 정수. 이것은 선택적 인수 &lt;code&gt;KIND=4&lt;/code&gt; 인 표준 &lt;code&gt;INT&lt;/code&gt; 내장 함수와 동일 하며 이전 버전과의 호환성을 위해서만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="48cdb5cabc83af9ed1b46a622b31410658d42438" translate="yes" xml:space="preserve">
          <source>Convert to a &lt;code&gt;KIND=8&lt;/code&gt; integer type. This is equivalent to the standard &lt;code&gt;INT&lt;/code&gt; intrinsic with an optional argument of &lt;code&gt;KIND=8&lt;/code&gt;, and is only included for backwards compatibility.</source>
          <target state="translated">&lt;code&gt;KIND=8&lt;/code&gt; 정수 유형으로 변환하십시오 . 이는 선택적 인수 &lt;code&gt;KIND=8&lt;/code&gt; 인 표준 &lt;code&gt;INT&lt;/code&gt; 내장 함수와 동일 하며 이전 버전과의 호환성을 위해서만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5946b90c6bdbdb047c476d580caf6ef7134a8f88" translate="yes" xml:space="preserve">
          <source>Convert to integer type</source>
          <target state="translated">정수형으로 변환</target>
        </trans-unit>
        <trans-unit id="5894e58d62ebc473f5ff5540aabc124661619c5e" translate="yes" xml:space="preserve">
          <source>Convert to logical type</source>
          <target state="translated">논리 형으로 변환</target>
        </trans-unit>
        <trans-unit id="5e821a1f572fbfadbb768a60aab9dd4bd1ebce5b" translate="yes" xml:space="preserve">
          <source>Convert to real type</source>
          <target state="translated">실수 형으로 변환</target>
        </trans-unit>
        <trans-unit id="97ad744ed209b116f65bbfb63fdf02e1e49b8df4" translate="yes" xml:space="preserve">
          <source>Converts one kind of &lt;code&gt;LOGICAL&lt;/code&gt; variable to another.</source>
          <target state="translated">한 종류의 &lt;code&gt;LOGICAL&lt;/code&gt; 변수를 다른 종류의 변수로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="7f2b478e5c5c9bfbdfef7006987960c45641ed5c" translate="yes" xml:space="preserve">
          <source>Copy a value to all images the current set of images</source>
          <target state="translated">현재 이미지 세트를 모든 이미지에 값 복사</target>
        </trans-unit>
        <trans-unit id="1dd3bb7758be1b9a3198143f88e38a84abe194a2" translate="yes" xml:space="preserve">
          <source>Cosine function</source>
          <target state="translated">코사인 함수</target>
        </trans-unit>
        <trans-unit id="66814fc8ba666e3c115d37c0cda25cc7963763d1" translate="yes" xml:space="preserve">
          <source>Cosine function, degrees</source>
          <target state="translated">코사인 함수,도</target>
        </trans-unit>
        <trans-unit id="a89d25e5d1c7e0d0aad6aca918169a994bb32f0b" translate="yes" xml:space="preserve">
          <source>Cosubscript index of this image</source>
          <target state="translated">이 이미지의 첨자 색인</target>
        </trans-unit>
        <trans-unit id="3eed853d5c82805eb63e0e4270c81dc68a994730" translate="yes" xml:space="preserve">
          <source>Cosubscript to image index conversion</source>
          <target state="translated">첨자에서 이미지 인덱스로의 변환</target>
        </trans-unit>
        <trans-unit id="67620e471dedb5582ae96416e1c53fa34aaa91d2" translate="yes" xml:space="preserve">
          <source>Cotangent function</source>
          <target state="translated">코탄젠트 함수</target>
        </trans-unit>
        <trans-unit id="4da51761194b2aad5cb5e8e9bb503052a82cca64" translate="yes" xml:space="preserve">
          <source>Cotangent function, degrees</source>
          <target state="translated">코탄젠트 함수,도</target>
        </trans-unit>
        <trans-unit id="cb8163ad103a88a54e40e8bf20f12cf3ece06d65" translate="yes" xml:space="preserve">
          <source>Count occurrences of TRUE in an array</source>
          <target state="translated">배열에서 TRUE 발생 횟수</target>
        </trans-unit>
        <trans-unit id="abcaab02d87bbb084dbb6d194df8f7fa41f2b93c" translate="yes" xml:space="preserve">
          <source>Counts the number of &lt;code&gt;.TRUE.&lt;/code&gt; elements in a logical &lt;var&gt;MASK&lt;/var&gt;, or, if the &lt;var&gt;DIM&lt;/var&gt; argument is supplied, counts the number of elements along each row of the array in the &lt;var&gt;DIM&lt;/var&gt; direction. If the array has zero size, or all of the elements of &lt;var&gt;MASK&lt;/var&gt; are &lt;code&gt;.FALSE.&lt;/code&gt;, then the result is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.TRUE.&lt;/code&gt; 수를 계산합니다 . 논리 &lt;var&gt;MASK&lt;/var&gt; 의 요소 또는 &lt;var&gt;DIM&lt;/var&gt; 인수가 제공되는 경우 &lt;var&gt;DIM&lt;/var&gt; 방향으로 배열의 각 행을 따라 요소 수를 계산합니다 . 배열의 크기가 0이거나 &lt;var&gt;MASK&lt;/var&gt; 의 모든 요소 가 &lt;code&gt;.FALSE.&lt;/code&gt; 이면 결과는 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ca84aecb51df48a92404be79666e6d5fe337e2fb" translate="yes" xml:space="preserve">
          <source>Cray pointees often are used to alias an existing variable. For example:</source>
          <target state="translated">크레이 포인트는 종종 기존 변수의 별칭을 지정하는 데 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="079133d1dbb4c697df4f85c6fc9afe1637edc023" translate="yes" xml:space="preserve">
          <source>Cray pointers are part of a non-standard extension that provides a C-like pointer in Fortran. This is accomplished through a pair of variables: an integer &quot;pointer&quot; that holds a memory address, and a &quot;pointee&quot; that is used to dereference the pointer.</source>
          <target state="translated">크레이 포인터는 포트란에서 C와 같은 포인터를 제공하는 비표준 확장의 일부입니다. 이는 메모리 주소를 보유하는 정수 &quot;포인터&quot;와 포인터를 역 참조하는 데 사용되는 &quot;포인터&quot;의 변수 쌍을 통해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="189251406fc434eb4a003209d557b57ba7d792aa" translate="yes" xml:space="preserve">
          <source>Cray pointers will work correctly when there is no aliasing (i.e., when they are used to access a dynamically allocated block of memory), and also in any routine where a pointee is used, but any variable with which it shares storage is not used. Code that violates these rules may not run as the user intends. This is not a bug in the optimizer; any code that violates the aliasing rules is illegal. (Note that this is not unique to GNU Fortran; any Fortran compiler that supports Cray pointers will &amp;ldquo;incorrectly&amp;rdquo; optimize code with illegal aliasing.)</source>
          <target state="translated">앨리어싱이없는 경우 (즉, 동적으로 할당 된 메모리 블록에 액세스하는 데 사용되는 경우) 및 포인트가 사용되는 루틴이 있지만 스토리지를 공유하는 변수는 사용되지 않는 경우 크레이 포인터가 올바르게 작동합니다. 이러한 규칙을 위반하는 코드는 사용자가 의도 한대로 실행되지 않을 수 있습니다. 이것은 옵티마이 저의 버그가 아닙니다. 앨리어싱 규칙을 위반하는 코드는 불법입니다. (이것은 GNU Fortran에 고유하지 않습니다. Cray 포인터를 지원하는 모든 Fortran 컴파일러는 잘못된 앨리어싱으로 코드를 &quot;올바르게&quot;최적화합니다.</target>
        </trans-unit>
        <trans-unit id="37691e38dc85a77a1cce380491ac6ff70a383a88" translate="yes" xml:space="preserve">
          <source>Create a hard link</source>
          <target state="translated">하드 링크 만들기</target>
        </trans-unit>
        <trans-unit id="1fb3b81881446baf520c50a8895db365d405c3df" translate="yes" xml:space="preserve">
          <source>Create a symbolic link</source>
          <target state="translated">심볼릭 링크 만들기</target>
        </trans-unit>
        <trans-unit id="5a97fd2f7800692f948278bd72a1d644dd56c0aa" translate="yes" xml:space="preserve">
          <source>Current local time (day/month/year)</source>
          <target state="translated">현재 현지 시간 (일 / 월 / 년)</target>
        </trans-unit>
        <trans-unit id="d9dd5ea3b903bc3ea5cf9ee7b4e51012d213a407" translate="yes" xml:space="preserve">
          <source>Current local time (hour/minutes/seconds)</source>
          <target state="translated">현재 현지 시간 (시 / 분 / 초)</target>
        </trans-unit>
        <trans-unit id="841ee80cc5097665e4c196b6c36d0c034f58d0c4" translate="yes" xml:space="preserve">
          <source>Current stream position</source>
          <target state="translated">현재 스트림 위치</target>
        </trans-unit>
        <trans-unit id="0bfd9e295c59bdb506130f195215edf1662041f3" translate="yes" xml:space="preserve">
          <source>Currently unimplemented:</source>
          <target state="translated">현재 구현되지 않은 :</target>
        </trans-unit>
        <trans-unit id="234e141e0cc0149b5367330679e583e7377ad5de" translate="yes" xml:space="preserve">
          <source>DATE_AND_TIME</source>
          <target state="translated">DATE_AND_TIME</target>
        </trans-unit>
        <trans-unit id="9a68d58101c1167c77921bb1b3d4c775e4412eb7" translate="yes" xml:space="preserve">
          <source>DBLE</source>
          <target state="translated">DBLE</target>
        </trans-unit>
        <trans-unit id="c3fc78b985a85e8417b1171dde3ac810557056ea" translate="yes" xml:space="preserve">
          <source>DEC compatibility mode. Enables extensions and other features that mimic the default behavior of older compilers (such as DEC). These features are non-standard and should be avoided at all costs. For details on GNU Fortran&amp;rsquo;s implementation of these extensions see the full documentation.</source>
          <target state="translated">DEC 호환성 모드. 구형 컴파일러 (예 : DEC)의 기본 동작을 모방하는 확장 기능 및 기타 기능을 활성화합니다. 이러한 기능은 비표준이므로 모든 비용을 피해야합니다. GNU Fortran의 이러한 확장 구현에 대한 자세한 내용은 전체 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a062eff730d2400585803b25fb2c0e436ff1d02c" translate="yes" xml:space="preserve">
          <source>DSHIFTL</source>
          <target state="translated">DSHIFTL</target>
        </trans-unit>
        <trans-unit id="7a25328c3e7487f62dd163c5fbe22e202421c9cb" translate="yes" xml:space="preserve">
          <source>DSHIFTR</source>
          <target state="translated">DSHIFTR</target>
        </trans-unit>
        <trans-unit id="8e14ba075e7c86c483ac920c87faca0c5998f037" translate="yes" xml:space="preserve">
          <source>Date and time subroutine</source>
          <target state="translated">날짜 및 시간 서브 루틴</target>
        </trans-unit>
        <trans-unit id="a78bf1f038bb229130c5eb95cd940a8f4b199b90" translate="yes" xml:space="preserve">
          <source>Day of month, range 1&amp;ndash;31</source>
          <target state="translated">월의 일, 1-31 범위</target>
        </trans-unit>
        <trans-unit id="cd7df5f994fdf90b2919c30d4589c1be2ae92db3" translate="yes" xml:space="preserve">
          <source>Daylight savings indicator: positive if daylight savings is in effect, zero if not, and negative if the information is not available.</source>
          <target state="translated">일광 절약 시간제 표시기 : 일광 절약 시간제를 적용한 경우 양수, 그렇지 않은 경우 0, 정보를 사용할 수없는 경우 음수.</target>
        </trans-unit>
        <trans-unit id="1cf25e4dcdd21f003c5d1747e593e85b67ab4cd5" translate="yes" xml:space="preserve">
          <source>Days since January 1, range 0&amp;ndash;365</source>
          <target state="translated">1 월 1 일 이후의 일, 범위 0&amp;ndash;365</target>
        </trans-unit>
        <trans-unit id="b7b96436cf5229d16fb5897e129a114445f95678" translate="yes" xml:space="preserve">
          <source>Debugging Options</source>
          <target state="translated">디버깅 옵션</target>
        </trans-unit>
        <trans-unit id="543a00cabbb859baf30c90e9ceeba2a2406f1f5e" translate="yes" xml:space="preserve">
          <source>Decimal exponent range</source>
          <target state="translated">십진 지수 범위</target>
        </trans-unit>
        <trans-unit id="ddc70c88a42231ed25a487a924e7d53809087e6a" translate="yes" xml:space="preserve">
          <source>Decimal precision of a real kind</source>
          <target state="translated">실제 종류의 십진 정밀도</target>
        </trans-unit>
        <trans-unit id="ce0e0a7e2a933d3c8749095e1595766f541fe6a3" translate="yes" xml:space="preserve">
          <source>Default integer. If &lt;var&gt;COARRAY&lt;/var&gt; is not present, it is scalar; if &lt;var&gt;DISTANCE&lt;/var&gt; is not present or has value 0, its value is the image index on the invoking image for the current team, for values smaller or equal distance to the initial team, it returns the image index on the ancestor team which has a distance of &lt;var&gt;DISTANCE&lt;/var&gt; from the invoking team. If &lt;var&gt;DISTANCE&lt;/var&gt; is larger than the distance to the initial team, the image index of the initial team is returned. Otherwise when the &lt;var&gt;COARRAY&lt;/var&gt; is present, if &lt;var&gt;DIM&lt;/var&gt; is not present, a rank-1 array with corank elements is returned, containing the cosubscripts for &lt;var&gt;COARRAY&lt;/var&gt; specifying the invoking image. If &lt;var&gt;DIM&lt;/var&gt; is present, a scalar is returned, with the value of the &lt;var&gt;DIM&lt;/var&gt; element of &lt;code&gt;THIS_IMAGE(COARRAY)&lt;/code&gt;.</source>
          <target state="translated">기본 정수 경우 &lt;var&gt;COARRAY&lt;/var&gt; 이 존재하지 않는, 그것은 스칼라; 만약 &lt;var&gt;DISTANCE&lt;/var&gt; 존재하지 않는 또는 값 0을 가지며, 그 값은 현재 팀 호출 이미지 화상 인덱스이고, 작거나 초기 팀 등거리 값, 그것의 거리가 상위 팀 화상 인덱스를 반환 호출 팀으로부터의 &lt;var&gt;DISTANCE&lt;/var&gt; 경우 &lt;var&gt;DISTANCE&lt;/var&gt; 초기 팀까지의 거리보다 큰 초기 팀의 이미지 인덱스가 반환됩니다. 그렇지 않으면 &lt;var&gt;COARRAY&lt;/var&gt; 가 있을 때 &lt;var&gt;DIM&lt;/var&gt; 이 없으면 호출 이미지를 지정하는 &lt;var&gt;COARRAY&lt;/var&gt; 의 첨자가 포함 된 corank 요소가있는 rank-1 배열이 반환 됩니다. &lt;var&gt;DIM&lt;/var&gt; 인 경우가 존재하면 &lt;code&gt;THIS_IMAGE(COARRAY)&lt;/code&gt; 의 &lt;var&gt;DIM&lt;/var&gt; 요소 값으로 스칼라가 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="e1a3509bb9f9e43493afb4bea400ad2f5c8be81b" translate="yes" xml:space="preserve">
          <source>Default record length for new files</source>
          <target state="translated">새 파일의 기본 레코드 길이</target>
        </trans-unit>
        <trans-unit id="48bcdf14a7727032f039944b612996363b0e9f7a" translate="yes" xml:space="preserve">
          <source>Default-kind integer constant array of rank one containing the supported kind parameters of the &lt;code&gt;CHARACTER&lt;/code&gt; type. (Fortran 2008 or later.)</source>
          <target state="translated">&lt;code&gt;CHARACTER&lt;/code&gt; 유형 의 지원되는 종류 매개 변수를 포함하는 순위 1의 기본 종류 정수 상수 배열 . (Fortran 2008 이상)</target>
        </trans-unit>
        <trans-unit id="d317f117580f31040fe9523448ffeae3469357fb" translate="yes" xml:space="preserve">
          <source>Default-kind integer constant array of rank one containing the supported kind parameters of the &lt;code&gt;INTEGER&lt;/code&gt; type. (Fortran 2008 or later.)</source>
          <target state="translated">&lt;code&gt;INTEGER&lt;/code&gt; 유형 의 지원되는 종류 매개 변수를 포함하는 순위 1의 기본 종류 정수 상수 배열 . (Fortran 2008 이상)</target>
        </trans-unit>
        <trans-unit id="750c62d8bcf38185c20b80578d24d922c240cc80" translate="yes" xml:space="preserve">
          <source>Default-kind integer constant array of rank one containing the supported kind parameters of the &lt;code&gt;LOGICAL&lt;/code&gt; type. (Fortran 2008 or later.)</source>
          <target state="translated">&lt;code&gt;LOGICAL&lt;/code&gt; 유형 의 지원되는 종류 매개 변수를 포함하는 순위 1의 기본 종류 정수 상수 배열 . (Fortran 2008 이상)</target>
        </trans-unit>
        <trans-unit id="035e4e1b75f094d9cbfb79c5dc27aa69a18417dc" translate="yes" xml:space="preserve">
          <source>Default-kind integer constant array of rank one containing the supported kind parameters of the &lt;code&gt;REAL&lt;/code&gt; type. (Fortran 2008 or later.)</source>
          <target state="translated">지원되는 &lt;code&gt;REAL&lt;/code&gt; 유형 의 종류 매개 변수를 포함하는 순위 1의 기본 종류 정수 상수 배열 . (Fortran 2008 이상)</target>
        </trans-unit>
        <trans-unit id="987c3b8d4841c1db76c0897441658986e5be163a" translate="yes" xml:space="preserve">
          <source>Default-kind integer constant to be used as kind parameter when defining integer variables used in atomic operations. (Fortran 2008 or later.)</source>
          <target state="translated">원자 연산에 사용되는 정수 변수를 정의 할 때 종류 매개 변수로 사용될 기본 종류 정수 상수. (Fortran 2008 이상)</target>
        </trans-unit>
        <trans-unit id="c041cc1955dfe46abd903b429630f3acc920e89f" translate="yes" xml:space="preserve">
          <source>Default-kind integer constant to be used as kind parameter when defining logical variables used in atomic operations. (Fortran 2008 or later.)</source>
          <target state="translated">원자 연산에 사용되는 논리 변수를 정의 할 때 종류 매개 변수로 사용될 기본 종류 정수 상수. (Fortran 2008 이상)</target>
        </trans-unit>
        <trans-unit id="f61a7aa88fb5b54fda84efc2c9cb07be25b94c40" translate="yes" xml:space="preserve">
          <source>Deferred-length character strings of Fortran 2003 supports part of the features of &lt;code&gt;ISO_VARYING_STRING&lt;/code&gt; and should be considered as replacement. (Namely, allocatable or pointers of the type &lt;code&gt;character(len=:)&lt;/code&gt;.)</source>
          <target state="translated">Fortran 2003의 지연 길이 문자열은 &lt;code&gt;ISO_VARYING_STRING&lt;/code&gt; 의 일부 기능을 지원하므로 대체로 간주해야합니다. (즉, 할당 가능한 &lt;code&gt;character(len=:)&lt;/code&gt; 또는 문자 (len = :) 유형의 포인터 )</target>
        </trans-unit>
        <trans-unit id="7436ecaf3aecf955cac06effc6ca88047daebb6c" translate="yes" xml:space="preserve">
          <source>Deferred-length character variables and scalar deferred-length character components of derived types are supported. (Note that array-valued compoents are not yet implemented.)</source>
          <target state="translated">파생 유형의 지연 길이 문자 변수 및 스칼라 지연 길이 문자 구성 요소가 지원됩니다. (배열 값 구성 요소는 아직 구현되지 않았습니다.)</target>
        </trans-unit>
        <trans-unit id="f36756a2375aeaf9260cc6764ebee064766205e8" translate="yes" xml:space="preserve">
          <source>Degrees</source>
          <target state="translated">Degrees</target>
        </trans-unit>
        <trans-unit id="d91d455936afb1a85dca05e4fb682918e3149b72" translate="yes" xml:space="preserve">
          <source>Deprecated alias for</source>
          <target state="translated">더 이상 사용되지 않는 별칭</target>
        </trans-unit>
        <trans-unit id="0996e31228feb52806804af2a2eae3f6596c3d14" translate="yes" xml:space="preserve">
          <source>Deregistering coarrays</source>
          <target state="translated">코레 등록 취소</target>
        </trans-unit>
        <trans-unit id="5354039385ebb0e8aedfae0480e1551597d0418d" translate="yes" xml:space="preserve">
          <source>Derived type with private components to be use with the &lt;code&gt;LOCK&lt;/code&gt; and &lt;code&gt;UNLOCK&lt;/code&gt; statement. A variable of its type has to be always declared as coarray and may not appear in a variable-definition context. (Fortran 2008 or later.)</source>
          <target state="translated">&lt;code&gt;LOCK&lt;/code&gt; 및 &lt;code&gt;UNLOCK&lt;/code&gt; 문과 함께 사용할 개인용 구성 요소가있는 파생 유형 . 해당 유형의 변수는 항상 거친 것으로 선언되어야하며 변수 정의 컨텍스트에 나타나지 않을 수 있습니다. (Fortran 2008 이상)</target>
        </trans-unit>
        <trans-unit id="2ac0667b5b0b769cbab11ec47bfe4c30495fbe50" translate="yes" xml:space="preserve">
          <source>Derived types with the C binding attribute shall not have the &lt;code&gt;sequence&lt;/code&gt; attribute, type parameters, the &lt;code&gt;extends&lt;/code&gt; attribute, nor type-bound procedures. Every component must be of interoperable type and kind and may not have the &lt;code&gt;pointer&lt;/code&gt; or &lt;code&gt;allocatable&lt;/code&gt; attribute. The names of the components are irrelevant for interoperability.</source>
          <target state="translated">C 바인딩 속성을 가진 파생 유형은 &lt;code&gt;sequence&lt;/code&gt; 속성, 유형 매개 변수, &lt;code&gt;extends&lt;/code&gt; 속성 또는 유형 바운드 프로 시저를 가질 수 없습니다 . 모든 구성 요소는 상호 운용 가능한 유형 및 종류 여야하며 &lt;code&gt;pointer&lt;/code&gt; 또는 &lt;code&gt;allocatable&lt;/code&gt; 속성 이 없을 수 있습니다 . 구성 요소의 이름은 상호 운용성과 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9b6f3f0766171c305edc998380e7c5cc141a33d8" translate="yes" xml:space="preserve">
          <source>Description:</source>
          <target state="translated">Description:</target>
        </trans-unit>
        <trans-unit id="0d8bc074b156a947960313d7dc3e755177218fce" translate="yes" xml:space="preserve">
          <source>Determine if all values are true</source>
          <target state="translated">모든 값이 참인지 확인</target>
        </trans-unit>
        <trans-unit id="dbc43b933a41010cf9a39818d0f3483e06d3cfb0" translate="yes" xml:space="preserve">
          <source>Determine if any values are true</source>
          <target state="translated">값이 참인지 확인</target>
        </trans-unit>
        <trans-unit id="ba2a682db5500ba705aff269d2c2057387092a7b" translate="yes" xml:space="preserve">
          <source>Determine the extent of &lt;var&gt;ARRAY&lt;/var&gt; along a specified dimension &lt;var&gt;DIM&lt;/var&gt;, or the total number of elements in &lt;var&gt;ARRAY&lt;/var&gt; if &lt;var&gt;DIM&lt;/var&gt; is absent.</source>
          <target state="translated">지정된 치수 &lt;var&gt;DIM&lt;/var&gt; 을 따라 &lt;var&gt;ARRAY&lt;/var&gt; 의 범위 또는 &lt;var&gt;DIM&lt;/var&gt; 이없는 경우 &lt;var&gt;ARRAY&lt;/var&gt; 의 총 요소 수를 결정하십시오 .</target>
        </trans-unit>
        <trans-unit id="1a4d1ae3b0b68b688c02b431017566fb5eb4850e" translate="yes" xml:space="preserve">
          <source>Determine the shape of an array</source>
          <target state="translated">배열의 모양 결정</target>
        </trans-unit>
        <trans-unit id="9cf4774792e99f655367fbaf16c078d7c1ab8567" translate="yes" xml:space="preserve">
          <source>Determine the size in bytes of an expression</source>
          <target state="translated">표현식의 크기를 바이트 단위로 결정</target>
        </trans-unit>
        <trans-unit id="01fc82092db3061bbd9cb5dcb43d3e88dce5d961" translate="yes" xml:space="preserve">
          <source>Determine whether a unit is connected to a terminal device.</source>
          <target state="translated">장치가 터미널 장치에 연결되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="0df6699a2689f0edde25fde23f2cb750b949d554" translate="yes" xml:space="preserve">
          <source>Determine whether an optional dummy argument is specified</source>
          <target state="translated">선택적 더미 인수가 지정되었는지 확인</target>
        </trans-unit>
        <trans-unit id="85229bc6c3f454ded7f675001ddc0acdce11f0bd" translate="yes" xml:space="preserve">
          <source>Determines the &lt;var&gt;COUNT&lt;/var&gt; of a processor clock since an unspecified time in the past modulo &lt;var&gt;COUNT_MAX&lt;/var&gt;, &lt;var&gt;COUNT_RATE&lt;/var&gt; determines the number of clock ticks per second. If the platform supports a monotonic clock, that clock is used and can, depending on the platform clock implementation, provide up to nanosecond resolution. If a monotonic clock is not available, the implementation falls back to a realtime clock.</source>
          <target state="translated">결정 &lt;var&gt;COUNT&lt;/var&gt; 과거 모듈의 불특정 시간 보낸 프로세서 클럭 &lt;var&gt;COUNT_MAX&lt;/var&gt; 을 , &lt;var&gt;COUNT_RATE&lt;/var&gt; 는 클럭 수가 초당 틱 결정한다. 플랫폼이 모노 토닉 클록을 지원하는 경우 해당 클록이 사용되며 플랫폼 클록 구현에 따라 최대 나노초 해상도를 제공 할 수 있습니다. 단조로운 클럭을 사용할 수없는 경우 구현은 실시간 클럭으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="0a73a137a1052572beb9c2f492dde435aee4ffad" translate="yes" xml:space="preserve">
          <source>Determines the distance between the argument &lt;var&gt;X&lt;/var&gt; and the nearest adjacent number of the same type.</source>
          <target state="translated">인수 &lt;var&gt;X&lt;/var&gt; 와 같은 유형의 가장 가까운 인접 숫자 사이의 거리를 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="0a4dfc22f28e7b1911c261cf7cad0ef631f11778" translate="yes" xml:space="preserve">
          <source>Determines the location of the element in the array with the maximum value, or, if the &lt;var&gt;DIM&lt;/var&gt; argument is supplied, determines the locations of the maximum element along each row of the array in the &lt;var&gt;DIM&lt;/var&gt; direction. If &lt;var&gt;MASK&lt;/var&gt; is present, only the elements for which &lt;var&gt;MASK&lt;/var&gt; is &lt;code&gt;.TRUE.&lt;/code&gt; are considered. If more than one element in the array has the maximum value, the location returned is that of the first such element in array element order. If the array has zero size, or all of the elements of &lt;var&gt;MASK&lt;/var&gt; are &lt;code&gt;.FALSE.&lt;/code&gt;, then the result is an array of zeroes. Similarly, if &lt;var&gt;DIM&lt;/var&gt; is supplied and all of the elements of &lt;var&gt;MASK&lt;/var&gt; along a given row are zero, the result value for that row is zero.</source>
          <target state="translated">최대 값으로 배열에서 요소의 위치를 ​​결정하거나 &lt;var&gt;DIM&lt;/var&gt; 인수가 제공되는 경우 &lt;var&gt;DIM&lt;/var&gt; 방향으로 배열의 각 행을 따라 최대 요소의 위치를 ​​결정합니다 . 경우 &lt;var&gt;MASK&lt;/var&gt; 가 존재하는 요소만을되는 &lt;var&gt;MASK&lt;/var&gt; 인 &lt;code&gt;.TRUE.&lt;/code&gt; 고려됩니다. 배열에서 둘 이상의 요소가 최대 값을 갖는 경우, 반환 된 위치는 배열 요소 순서에서 첫 번째 요소의 위치입니다. 배열의 크기가 0이거나 &lt;var&gt;MASK&lt;/var&gt; 의 모든 요소 가 &lt;code&gt;.FALSE.&lt;/code&gt; 이면 결과는 0의 배열입니다. 마찬가지로 &lt;var&gt;DIM&lt;/var&gt; 이 제공되고 &lt;var&gt;MASK&lt;/var&gt; 의 모든 요소가 제공되는 경우주어진 행을 따라 0이면 해당 행의 결과 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="87809581ed451e33703ede880b8866ad0dc63b0d" translate="yes" xml:space="preserve">
          <source>Determines the location of the element in the array with the minimum value, or, if the &lt;var&gt;DIM&lt;/var&gt; argument is supplied, determines the locations of the minimum element along each row of the array in the &lt;var&gt;DIM&lt;/var&gt; direction. If &lt;var&gt;MASK&lt;/var&gt; is present, only the elements for which &lt;var&gt;MASK&lt;/var&gt; is &lt;code&gt;.TRUE.&lt;/code&gt; are considered. If more than one element in the array has the minimum value, the location returned is that of the first such element in array element order. If the array has zero size, or all of the elements of &lt;var&gt;MASK&lt;/var&gt; are &lt;code&gt;.FALSE.&lt;/code&gt;, then the result is an array of zeroes. Similarly, if &lt;var&gt;DIM&lt;/var&gt; is supplied and all of the elements of &lt;var&gt;MASK&lt;/var&gt; along a given row are zero, the result value for that row is zero.</source>
          <target state="translated">최소값으로 배열의 요소 위치를 결정하거나 &lt;var&gt;DIM&lt;/var&gt; 인수가 제공되는 경우 &lt;var&gt;DIM&lt;/var&gt; 방향으로 배열의 각 행을 따라 최소 요소의 위치를 ​​결정합니다 . 경우 &lt;var&gt;MASK&lt;/var&gt; 가 존재하는 요소만을되는 &lt;var&gt;MASK&lt;/var&gt; 인 &lt;code&gt;.TRUE.&lt;/code&gt; 고려됩니다. 배열에서 둘 이상의 요소에 최소값이있는 경우 반환 된 위치는 배열 요소 순서에서 첫 번째 요소의 위치입니다. 배열의 크기가 0이거나 &lt;var&gt;MASK&lt;/var&gt; 의 모든 요소 가 &lt;code&gt;.FALSE.&lt;/code&gt; 이면 결과는 0의 배열입니다. 마찬가지로 &lt;var&gt;DIM&lt;/var&gt; 이 제공되고 &lt;var&gt;MASK&lt;/var&gt; 의 모든 요소가 제공되는 경우주어진 행을 따라 0이면 해당 행의 결과 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="848bb5d64844e29a29d224776f1202dc4ee5e9d4" translate="yes" xml:space="preserve">
          <source>Determines the maximum value of the elements in an array value, or, if the &lt;var&gt;DIM&lt;/var&gt; argument is supplied, determines the maximum value along each row of the array in the &lt;var&gt;DIM&lt;/var&gt; direction. If &lt;var&gt;MASK&lt;/var&gt; is present, only the elements for which &lt;var&gt;MASK&lt;/var&gt; is &lt;code&gt;.TRUE.&lt;/code&gt; are considered. If the array has zero size, or all of the elements of &lt;var&gt;MASK&lt;/var&gt; are &lt;code&gt;.FALSE.&lt;/code&gt;, then the result is &lt;code&gt;-HUGE(ARRAY)&lt;/code&gt; if &lt;var&gt;ARRAY&lt;/var&gt; is numeric, or a string of nulls if &lt;var&gt;ARRAY&lt;/var&gt; is of character type.</source>
          <target state="translated">배열 값에서 요소의 최대 값을 결정하거나 &lt;var&gt;DIM&lt;/var&gt; 인수가 제공되면 &lt;var&gt;DIM&lt;/var&gt; 방향으로 배열의 각 행을 따라 최대 값을 결정합니다 . 경우 &lt;var&gt;MASK&lt;/var&gt; 가 존재하는 요소만을되는 &lt;var&gt;MASK&lt;/var&gt; 인 &lt;code&gt;.TRUE.&lt;/code&gt; 고려됩니다. 배열의 크기가 0이거나 &lt;var&gt;MASK&lt;/var&gt; 의 모든 요소 가 &lt;code&gt;.FALSE.&lt;/code&gt; 다음 결과는 &lt;code&gt;-HUGE(ARRAY)&lt;/code&gt; 경우 &lt;var&gt;ARRAY&lt;/var&gt; 이 경우 널 캐릭터가 숫자 또는 &lt;var&gt;ARRAY&lt;/var&gt; 은 문자 타입이다.</target>
        </trans-unit>
        <trans-unit id="2fecbe4ac0bbb4ab6b9c4d0b6fa23ff44fce1ad1" translate="yes" xml:space="preserve">
          <source>Determines the minimum value of the elements in an array value, or, if the &lt;var&gt;DIM&lt;/var&gt; argument is supplied, determines the minimum value along each row of the array in the &lt;var&gt;DIM&lt;/var&gt; direction. If &lt;var&gt;MASK&lt;/var&gt; is present, only the elements for which &lt;var&gt;MASK&lt;/var&gt; is &lt;code&gt;.TRUE.&lt;/code&gt; are considered. If the array has zero size, or all of the elements of &lt;var&gt;MASK&lt;/var&gt; are &lt;code&gt;.FALSE.&lt;/code&gt;, then the result is &lt;code&gt;HUGE(ARRAY)&lt;/code&gt; if &lt;var&gt;ARRAY&lt;/var&gt; is numeric, or a string of &lt;code&gt;CHAR(255)&lt;/code&gt; characters if &lt;var&gt;ARRAY&lt;/var&gt; is of character type.</source>
          <target state="translated">배열 값에서 요소의 최소값을 결정하거나 &lt;var&gt;DIM&lt;/var&gt; 인수가 제공되는 경우 배열의 각 행을 따라 &lt;var&gt;DIM&lt;/var&gt; 방향으로 최소값을 결정합니다 . 경우 &lt;var&gt;MASK&lt;/var&gt; 가 존재하는 요소만을되는 &lt;var&gt;MASK&lt;/var&gt; 인 &lt;code&gt;.TRUE.&lt;/code&gt; 고려됩니다. 배열의 크기가 0이거나 &lt;var&gt;MASK&lt;/var&gt; 의 모든 요소 가 &lt;code&gt;.FALSE.&lt;/code&gt; 다음 결과는 &lt;code&gt;HUGE(ARRAY)&lt;/code&gt; 경우 &lt;var&gt;ARRAY&lt;/var&gt; 이 숫자, 또는 문자열 &lt;code&gt;CHAR(255)&lt;/code&gt; 경우 문자 &lt;var&gt;ARRAY&lt;/var&gt; 은 문자 타입이다.</target>
        </trans-unit>
        <trans-unit id="19ab302149887d93a9aa7e018bf921d95d86c6fc" translate="yes" xml:space="preserve">
          <source>Determines the shape of an array.</source>
          <target state="translated">배열의 모양을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="abe8951f4889f667a0c3a629889daaf32fc240b7" translate="yes" xml:space="preserve">
          <source>Determines whether an integral is a bitwise greater than another.</source>
          <target state="translated">적분이 다른 적분보다 조금 더 큰지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="4da029268431fb07f97b1b75eff7ac20aebdaca3" translate="yes" xml:space="preserve">
          <source>Determines whether an integral is a bitwise greater than or equal to another.</source>
          <target state="translated">적분이 다른 비트보다 크거나 같은지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="b5c006aa4c1f3b9564c14c8fc3c67c986a9cf692" translate="yes" xml:space="preserve">
          <source>Determines whether an integral is a bitwise less than another.</source>
          <target state="translated">적분이 다른 적분보다 비트 단위로 작은 지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="351f8a26dbbdeaf5586224ab2f8686ce19a5505c" translate="yes" xml:space="preserve">
          <source>Determines whether an integral is a bitwise less than or equal to another.</source>
          <target state="translated">적분이 다른 비트보다 작거나 같은지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="ed7fa27530af04a18ec9c6571a7c85db7fda81d7" translate="yes" xml:space="preserve">
          <source>Determines whether an optional dummy argument is present.</source>
          <target state="translated">선택적 더미 인수가 있는지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="b60d333f342eb77850694efb101c6842f30ec6fd" translate="yes" xml:space="preserve">
          <source>Determines whether one string is lexically greater than another string, where the two strings are interpreted as containing ASCII character codes. If the String A and String B are not the same length, the shorter is compared as if spaces were appended to it to form a value that has the same length as the longer.</source>
          <target state="translated">한 문자열이 다른 문자열보다 어휘 적으로 큰지 여부를 결정합니다. 여기서 두 문자열은 ASCII 문자 코드를 포함하는 것으로 해석됩니다. 문자열 A와 문자열 B의 길이가 같지 않으면 공백이 추가 된 것처럼 짧아지고 길이가 같은 값을 갖는 값이 형성됩니다.</target>
        </trans-unit>
        <trans-unit id="7bb9c5d73acc9af457d47ecebc4935665189144f" translate="yes" xml:space="preserve">
          <source>Determines whether one string is lexically greater than or equal to another string, where the two strings are interpreted as containing ASCII character codes. If the String A and String B are not the same length, the shorter is compared as if spaces were appended to it to form a value that has the same length as the longer.</source>
          <target state="translated">한 문자열이 다른 문자열보다 어휘 적으로 큰지 또는 두 문자열이 ASCII 문자 코드를 포함하는 것으로 해석되는지 판별합니다. 문자열 A와 문자열 B의 길이가 같지 않으면 공백이 추가 된 것처럼 짧아지고 길이가 같은 값을 갖는 값이 형성됩니다.</target>
        </trans-unit>
        <trans-unit id="54cc2eddda49a9802234158a557e7ef28b78ff84" translate="yes" xml:space="preserve">
          <source>Determines whether one string is lexically less than another string, where the two strings are interpreted as containing ASCII character codes. If the String A and String B are not the same length, the shorter is compared as if spaces were appended to it to form a value that has the same length as the longer.</source>
          <target state="translated">한 문자열이 다른 문자열보다 어휘 적으로 작은 지 여부를 결정합니다. 여기서 두 문자열은 ASCII 문자 코드를 포함하는 것으로 해석됩니다. 문자열 A와 문자열 B의 길이가 같지 않으면 공백이 추가 된 것처럼 짧아지고 길이가 같은 값을 갖는 값이 형성됩니다.</target>
        </trans-unit>
        <trans-unit id="0d2382892a7aed218e63d9861861c9862f61fa7f" translate="yes" xml:space="preserve">
          <source>Determines whether one string is lexically less than or equal to another string, where the two strings are interpreted as containing ASCII character codes. If the String A and String B are not the same length, the shorter is compared as if spaces were appended to it to form a value that has the same length as the longer.</source>
          <target state="translated">한 문자열이 다른 문자열보다 어휘 적으로 작거나 같은지 확인합니다. 여기서 두 문자열은 ASCII 문자 코드를 포함하는 것으로 해석됩니다. 문자열 A와 문자열 B의 길이가 같지 않으면 공백이 추가 된 것처럼 짧아지고 길이가 같은 값을 갖는 값이 형성됩니다.</target>
        </trans-unit>
        <trans-unit id="7c9f0f8d9fcf58e3b112ecdbab5210f6478886d4" translate="yes" xml:space="preserve">
          <source>Device ID</source>
          <target state="translated">장치 아이디</target>
        </trans-unit>
        <trans-unit id="f710acdf8c3a36b577ab367527e400e4e4519a38" translate="yes" xml:space="preserve">
          <source>Directory Options</source>
          <target state="translated">디렉토리 옵션</target>
        </trans-unit>
        <trans-unit id="bc705c6be6645c0cdb464a3dc08ed28c834f4276" translate="yes" xml:space="preserve">
          <source>Directory for scratch files</source>
          <target state="translated">스크래치 파일의 디렉토리</target>
        </trans-unit>
        <trans-unit id="1f6f5a494170050dd5a2071ec1d37e8314afdc9f" translate="yes" xml:space="preserve">
          <source>Disable coarray support; using coarray declarations and image-control statements will produce a compile-time error. (Default)</source>
          <target state="translated">대충 지원을 비활성화합니다. 배열 선언 및 이미지 제어문을 사용하면 컴파일 타임 오류가 발생합니다. (기본)</target>
        </trans-unit>
        <trans-unit id="19cf4c749798adbcfdd0ce5247951e55e8259eac" translate="yes" xml:space="preserve">
          <source>Disable range checking on results of simplification of constant expressions during compilation. For example, GNU Fortran will give an error at compile time when simplifying &lt;code&gt;a = 1. / 0&lt;/code&gt;. With this option, no error will be given and &lt;code&gt;a&lt;/code&gt; will be assigned the value &lt;code&gt;+Infinity&lt;/code&gt;. If an expression evaluates to a value outside of the relevant range of [&lt;code&gt;-HUGE()&lt;/code&gt;:&lt;code&gt;HUGE()&lt;/code&gt;], then the expression will be replaced by &lt;code&gt;-Inf&lt;/code&gt; or &lt;code&gt;+Inf&lt;/code&gt; as appropriate. Similarly, &lt;code&gt;DATA i/Z'FFFFFFFF'/&lt;/code&gt; will result in an integer overflow on most systems, but with</source>
          <target state="translated">컴파일하는 동안 상수 표현식을 단순화 한 결과에 대한 범위 검사를 비활성화합니다. 예를 들어 GNU Fortran은 &lt;code&gt;a = 1. / 0&lt;/code&gt; 단순화 할 때 컴파일 타임에 오류를 발생시킵니다 . 이 옵션을 사용하면 오류가 제공되지 않으며 &lt;code&gt;a&lt;/code&gt; 는 값이 할당됩니다 &lt;code&gt;+Infinity&lt;/code&gt; . 식이 [ &lt;code&gt;-HUGE()&lt;/code&gt; : &lt;code&gt;HUGE()&lt;/code&gt; ] 의 관련 범위를 벗어난 값으로 평가되면 적절하게 식이 &lt;code&gt;-Inf&lt;/code&gt; 또는 &lt;code&gt;+Inf&lt;/code&gt; 로 바뀝니다 . 마찬가지로 &lt;code&gt;DATA i/Z'FFFFFFFF'/&lt;/code&gt; 는 대부분의 시스템에서 정수 오버플로가 발생하지만</target>
        </trans-unit>
        <trans-unit id="3efa8677a2d2f1a55a04bcc71e834b85911153df" translate="yes" xml:space="preserve">
          <source>Distribute a value from a given image to all other images in the team. Has to be called collectively.</source>
          <target state="translated">주어진 이미지에서 팀의 다른 모든 이미지로 값을 분배합니다. 집합 적으로 불러야합니다.</target>
        </trans-unit>
        <trans-unit id="54067347787aab9ba7be50edb99e0c22c0febc0d" translate="yes" xml:space="preserve">
          <source>Do not buffer I/O for all units.</source>
          <target state="translated">모든 장치에 대해 I / O를 버퍼링하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="6e00f4c62b721970c5323850fda6638ab16d5398" translate="yes" xml:space="preserve">
          <source>Do not buffer I/O for preconnected units.</source>
          <target state="translated">사전 연결된 장치의 I / O를 버퍼링하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="61bd4083e901aa03be2fec075c5a07232b9c93d4" translate="yes" xml:space="preserve">
          <source>Do not discard comments, including during macro expansion. This is like</source>
          <target state="translated">매크로 확장을 포함하여 주석을 버리지 마십시오. 이것은 같다</target>
        </trans-unit>
        <trans-unit id="094e1651c852304b7a16e16ed4d0185ecd59b26b" translate="yes" xml:space="preserve">
          <source>Do not discard comments. All comments are passed through to the output file, except for comments in processed directives, which are deleted along with the directive.</source>
          <target state="translated">주석을 버리지 마십시오. 처리 된 지시문의 주석을 제외한 모든 주석은 출력 파일로 전달되며, 지시문과 함께 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="5cf0a2e01f314e50aac688fcc0637765ffe183d2" translate="yes" xml:space="preserve">
          <source>Do not predefine any system-specific or GCC-specific macros. The standard predefined macros remain defined.</source>
          <target state="translated">시스템 특정 또는 GCC 특정 매크로를 미리 정의하지 마십시오. 사전 정의 된 표준 매크로는 정의 된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="222aa59b95b5ee84de37b060585fd5b26c0f9339" translate="yes" xml:space="preserve">
          <source>Do not search the standard system directories for header files. Only the directories you have specified with</source>
          <target state="translated">표준 시스템 디렉토리에서 헤더 파일을 검색하지 마십시오. 지정한 디렉토리 만</target>
        </trans-unit>
        <trans-unit id="ecd0231af8e56a99514d9c79420e07924f53d15e" translate="yes" xml:space="preserve">
          <source>Do not transform names of entities specified in the Fortran source file by appending underscores to them.</source>
          <target state="translated">밑줄을 추가하여 Fortran 소스 파일에 지정된 엔티티 이름을 변환하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="e2689b4b2ff06ffcb5bd466d619321be4e14dc1e" translate="yes" xml:space="preserve">
          <source>Does not return anything.</source>
          <target state="translated">아무것도 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="296a7b0727ac5f4d9354c9f55737697f1f04594d" translate="yes" xml:space="preserve">
          <source>Does not return.</source>
          <target state="translated">돌아 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="03ce16978c5be7e187be5ba279de9c8f71e851e8" translate="yes" xml:space="preserve">
          <source>Dot product function</source>
          <target state="translated">도트 제품 기능</target>
        </trans-unit>
        <trans-unit id="88f7a9944fcc4d921b543327df1c52badf20d41c" translate="yes" xml:space="preserve">
          <source>Double complex conversion function</source>
          <target state="translated">복소수 변환 기능</target>
        </trans-unit>
        <trans-unit id="f83fd22d6b6fbec2f57c07ff09dbbb59b9d3a0e1" translate="yes" xml:space="preserve">
          <source>Double precision conversion function</source>
          <target state="translated">배정도 변환 기능</target>
        </trans-unit>
        <trans-unit id="3b3d36ddeed7452d6c59af30dc2c050a5b361a21" translate="yes" xml:space="preserve">
          <source>Double product function</source>
          <target state="translated">이중 제품 기능</target>
        </trans-unit>
        <trans-unit id="f85ca61beb82ce6136013c70693d3a44b1384068" translate="yes" xml:space="preserve">
          <source>Double real part function</source>
          <target state="translated">이중 실수 부 기능</target>
        </trans-unit>
        <trans-unit id="7fe18e97bbdf405bd4e76fe16f36c526e30dda47" translate="yes" xml:space="preserve">
          <source>During library initialization, the C &lt;code&gt;getenv&lt;/code&gt; function is used, which need not be thread-safe. Similarly, the &lt;code&gt;getenv&lt;/code&gt; function is used to implement the &lt;code&gt;GET_ENVIRONMENT_VARIABLE&lt;/code&gt; and &lt;code&gt;GETENV&lt;/code&gt; intrinsics. It is the responsibility of the user to ensure that the environment is not being updated concurrently when any of these actions are taking place.</source>
          <target state="translated">라이브러리 초기화 중에 C &lt;code&gt;getenv&lt;/code&gt; 함수가 사용되며 스레드로부터 안전하지 않아도됩니다. 마찬가지로 &lt;code&gt;getenv&lt;/code&gt; 함수는 &lt;code&gt;GET_ENVIRONMENT_VARIABLE&lt;/code&gt; 및 &lt;code&gt;GETENV&lt;/code&gt; 내장 함수 를 구현하는 데 사용됩니다 . 이러한 조치가 수행 될 때 환경이 동시에 업데이트되지 않도록하는 것은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="068e594fc0356dbd1518222cd2a44af7284e39a5" translate="yes" xml:space="preserve">
          <source>Dynamic memory allocation function</source>
          <target state="translated">동적 메모리 할당 기능</target>
        </trans-unit>
        <trans-unit id="6a88e83c73d82668260a3fe86e1f0107b965b7fe" translate="yes" xml:space="preserve">
          <source>EXTENDS_TYPE_OF</source>
          <target state="translated">EXTENDS_TYPE_OF</target>
        </trans-unit>
        <trans-unit id="5965dceb4597ee13e7c59f1b7471b162a8c98fb7" translate="yes" xml:space="preserve">
          <source>Elapsed time in seconds since the last invocation or since the start of program execution if not called before.</source>
          <target state="translated">마지막 호출 이후 또는 호출되지 않은 경우 프로그램 실행 시작 이후 경과 된 시간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="a6ac4fc06ef735a5c94b88572231f560830c5521" translate="yes" xml:space="preserve">
          <source>Elapsed time in seconds since the start of program execution.</source>
          <target state="translated">프로그램 실행이 시작된 이후 경과 된 시간 (초)</target>
        </trans-unit>
        <trans-unit id="9637fbbf70583956dd126514d116f420b0c4657f" translate="yes" xml:space="preserve">
          <source>Elemental function</source>
          <target state="translated">원소 기능</target>
        </trans-unit>
        <trans-unit id="a53a76efbf024deae270dc5165464427c1b1e531" translate="yes" xml:space="preserve">
          <source>Elemental function, except for the transformational function &lt;code&gt;BESSEL_JN(N1, N2, X)&lt;/code&gt;</source>
          <target state="translated">변형 함수 &lt;code&gt;BESSEL_JN(N1, N2, X)&lt;/code&gt; 제외한 원소 함수</target>
        </trans-unit>
        <trans-unit id="fc148c745e81ab8bb6f2291418f9072fdf6049da" translate="yes" xml:space="preserve">
          <source>Elemental function, except for the transformational function &lt;code&gt;BESSEL_YN(N1, N2, X)&lt;/code&gt;</source>
          <target state="translated">변형 함수 &lt;code&gt;BESSEL_YN(N1, N2, X)&lt;/code&gt; 제외한 원소 함수</target>
        </trans-unit>
        <trans-unit id="a6181d67a5ad4436ac9a8cb957bd2eb3684c8e9b" translate="yes" xml:space="preserve">
          <source>Elemental subroutine</source>
          <target state="translated">원소 서브 루틴</target>
        </trans-unit>
        <trans-unit id="8bbf81520945437612d4d7fd6d97b20d12c8c0c3" translate="yes" xml:space="preserve">
          <source>Enable B/I/J/K kind variants of existing integer functions (e.g. BIAND, IIAND, JIAND, etc...). For a complete list of intrinsics see the full documentation.</source>
          <target state="translated">기존 정수 함수 (예 : BIAND, IIAND, JIAND 등)의 B / I / J / K 종류 변형을 활성화합니다. 내장 함수의 전체 목록은 전체 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a67449d4e64250c3a4f02022c303f46464c42f58" translate="yes" xml:space="preserve">
          <source>Enable DEC &lt;code&gt;STRUCTURE&lt;/code&gt; and &lt;code&gt;RECORD&lt;/code&gt; as well as &lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;MAP&lt;/code&gt;, and dot (&amp;rsquo;.&amp;rsquo;) as a member separator (in addition to &amp;rsquo;%&amp;rsquo;). This is provided for compatibility only; Fortran 90 derived types should be used instead where possible.</source>
          <target state="translated">DEC &lt;code&gt;STRUCTURE&lt;/code&gt; 및 &lt;code&gt;RECORD&lt;/code&gt; 와 &lt;code&gt;UNION&lt;/code&gt; , &lt;code&gt;MAP&lt;/code&gt; 및 점 ( '.')을 멤버 구분 기호 ( '%'이외에)로 활성화하십시오 . 호환성을 위해서만 제공됩니다. 가능한 경우 포트란 90 파생 형식을 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d974b2ad85b66558365ce154dc8407f7e5e07560" translate="yes" xml:space="preserve">
          <source>Enable DEC-style STATIC and AUTOMATIC attributes to explicitly specify the storage of variables and other objects.</source>
          <target state="translated">변수 및 기타 오브젝트의 스토리지를 명시 적으로 지정하려면 DEC 스타일 STATIC 및 AUTOMATIC 속성을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5837ae70c83ed6e5a8da9fd573ee8f0b4616d62c" translate="yes" xml:space="preserve">
          <source>Enable all run-time test of</source>
          <target state="translated">모든 런타임 테스트 사용</target>
        </trans-unit>
        <trans-unit id="816ec934d7837e44e83c9b6817eec868219c243f" translate="yes" xml:space="preserve">
          <source>Enable and customize preprocessing.</source>
          <target state="translated">전처리를 활성화하고 사용자 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="2be02fef4451c03fff215e0ca3f3405bfc0f57fd" translate="yes" xml:space="preserve">
          <source>Enable generation of linemarkers in the preprocessor output that will let the compiler know the current working directory at the time of preprocessing. When this option is enabled, the preprocessor will emit, after the initial linemarker, a second linemarker with the current working directory followed by two slashes. GCC will use this directory, when it is present in the preprocessed input, as the directory emitted as the current working directory in some debugging information formats. This option is implicitly enabled if debugging information is enabled, but this can be inhibited with the negated form</source>
          <target state="translated">사전 처리시 컴파일러가 현재 작업 디렉토리를 알 수 있도록 전 처리기 출력에서 ​​라인 마커 생성을 활성화합니다. 이 옵션이 활성화되면 전처리 기는 초기 라인 마커 이후에 현재 작업 디렉토리와 두 개의 슬래시가있는 두 번째 라인 마커를 방출합니다. GCC는 사전 처리 된 입력에이 디렉토리가있을 때 일부 디버깅 정보 형식으로 현재 작업 디렉토리로 생성 된 디렉토리로이 디렉토리를 사용합니다. 이 옵션은 디버깅 정보가 활성화 된 경우 암시 적으로 활성화되지만 부정 형식으로 억제 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="97f09c22fecc360be3a32cced5b8225a4d33235b" translate="yes" xml:space="preserve">
          <source>Enable generation of run-time checks for array subscripts and against the declared minimum and maximum values. It also checks array indices for assumed and deferred shape arrays against the actual allocated bounds and ensures that all string lengths are equal for character array constructors without an explicit typespec.</source>
          <target state="translated">배열 첨자 및 선언 된 최소값 및 최대 값에 대해 런타임 검사를 생성 할 수 있습니다. 또한 실제 할당 된 경계에 대해 가정 및 지연된 모양 배열에 대한 배열 인덱스를 검사하고 명시적인 typespec이없는 문자 배열 생성자에 대해 모든 문자열 길이가 동일한 지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="804f8ad05ca48e7309b108637b54bec71b75e2bd" translate="yes" xml:space="preserve">
          <source>Enable generation of run-time checks for invalid modification of loop iteration variables.</source>
          <target state="translated">루프 반복 변수의 유효하지 않은 수정에 대해 런타임 검사를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="640402594d74f18dabbe55ab4fea6ebd9ada4e45" translate="yes" xml:space="preserve">
          <source>Enable generation of run-time checks for memory allocation. Note: This option does not affect explicit allocations using the &lt;code&gt;ALLOCATE&lt;/code&gt; statement, which will be always checked.</source>
          <target state="translated">메모리 할당에 대한 런타임 검사를 생성 할 수 있습니다. 참고 :이 옵션은 항상 점검되는 &lt;code&gt;ALLOCATE&lt;/code&gt; 문을 사용한 명시 적 할당에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c1761460f2bc298733fa3b410d9b4ee3c5b791f4" translate="yes" xml:space="preserve">
          <source>Enable generation of run-time checks for pointers and allocatables.</source>
          <target state="translated">포인터 및 할당 가능한 런타임 검사를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d202d71df64ce14bad49ccba79ed3f4f93ab0f9" translate="yes" xml:space="preserve">
          <source>Enable generation of run-time checks for recursively called subroutines and functions which are not marked as recursive. See also</source>
          <target state="translated">재귀 적으로 호출되는 서브 루틴 및 기능에 대해 런타임 검사를 생성하여 재귀로 표시되지 않습니다. 또한보십시오</target>
        </trans-unit>
        <trans-unit id="fe19993cf2b833166cbd7876fa50e498a89e8f85" translate="yes" xml:space="preserve">
          <source>Enable legacy math intrinsics such as COTAN and degree-valued trigonometric functions (e.g. TAND, ATAND, etc...) for compatability with older code.</source>
          <target state="translated">이전 코드와의 호환성을 위해 COTAN 및 정도 평가 삼각 함수 (예 : TAND, ATAND 등)와 같은 레거시 수학 내장 함수를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="fd8c6e2e4f52eeb216da79d6d6023ac60af0d79c" translate="yes" xml:space="preserve">
          <source>Enable preprocessing. The preprocessor is automatically invoked if the file extension is</source>
          <target state="translated">전처리를 활성화합니다. 파일 확장자가 다음과 같은 경우 전처리 기가 자동으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="be660567d4e4ccd0f86d15658d9ef4c67943e4b4" translate="yes" xml:space="preserve">
          <source>Enable special treatment for lines beginning with &lt;code&gt;d&lt;/code&gt; or &lt;code&gt;D&lt;/code&gt; in fixed form sources. If the</source>
          <target state="translated">고정 양식 소스에서 &lt;code&gt;d&lt;/code&gt; 또는 &lt;code&gt;D&lt;/code&gt; 로 시작하는 행에 대해 특수 처리를 사용하십시오 . 만약</target>
        </trans-unit>
        <trans-unit id="5f05cf07b5dee288bd26b3e8429a3e173788ec9d" translate="yes" xml:space="preserve">
          <source>Enable the Cray pointer extension, which provides C-like pointer functionality.</source>
          <target state="translated">C와 같은 포인터 기능을 제공하는 Cray 포인터 확장을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="fd891f5141276d933a037740fec3d6f298095c33" translate="yes" xml:space="preserve">
          <source>Enable the OpenACC extensions. This includes OpenACC &lt;code&gt;!$acc&lt;/code&gt; directives in free form and &lt;code&gt;c$acc&lt;/code&gt;, &lt;code&gt;*$acc&lt;/code&gt; and &lt;code&gt;!$acc&lt;/code&gt; directives in fixed form, &lt;code&gt;!$&lt;/code&gt; conditional compilation sentinels in free form and &lt;code&gt;c$&lt;/code&gt;, &lt;code&gt;*$&lt;/code&gt; and &lt;code&gt;!$&lt;/code&gt; sentinels in fixed form, and when linking arranges for the OpenACC runtime library to be linked in.</source>
          <target state="translated">OpenACC 확장을 활성화하십시오. 여기에는 자유 형식의 OpenACC &lt;code&gt;!$acc&lt;/code&gt; 지시문과 &lt;code&gt;c$acc&lt;/code&gt; , 고정 형식의 &lt;code&gt;*$acc&lt;/code&gt; 및 &lt;code&gt;!$acc&lt;/code&gt; 지시문, 자유 형식의 &lt;code&gt;!$&lt;/code&gt; 조건부 컴파일 센티넬 및 고정 형식의 &lt;code&gt;c$&lt;/code&gt; , &lt;code&gt;*$&lt;/code&gt; 및 &lt;code&gt;!$&lt;/code&gt; 센티넬 및 링크하면 OpenACC 런타임 라이브러리가 링크됩니다.</target>
        </trans-unit>
        <trans-unit id="c4491cc16fe42c88d0515217c3bbc1be5ced4263" translate="yes" xml:space="preserve">
          <source>Enable the OpenMP extensions. This includes OpenMP &lt;code&gt;!$omp&lt;/code&gt; directives in free form and &lt;code&gt;c$omp&lt;/code&gt;, &lt;code&gt;*$omp&lt;/code&gt; and &lt;code&gt;!$omp&lt;/code&gt; directives in fixed form, &lt;code&gt;!$&lt;/code&gt; conditional compilation sentinels in free form and &lt;code&gt;c$&lt;/code&gt;, &lt;code&gt;*$&lt;/code&gt; and &lt;code&gt;!$&lt;/code&gt; sentinels in fixed form, and when linking arranges for the OpenMP runtime library to be linked in. The option</source>
          <target state="translated">OpenMP 확장을 활성화하십시오. 여기에는 자유 형식의 OpenMP &lt;code&gt;!$omp&lt;/code&gt; 지시문 및 고정 형식의 &lt;code&gt;c$omp&lt;/code&gt; , &lt;code&gt;*$omp&lt;/code&gt; 및 &lt;code&gt;!$omp&lt;/code&gt; 지시문, 자유 형식의 &lt;code&gt;!$&lt;/code&gt; 조건부 컴파일 센티넬 및 고정 형식의 &lt;code&gt;c$&lt;/code&gt; , &lt;code&gt;*$&lt;/code&gt; 및 &lt;code&gt;!$&lt;/code&gt; 센티넬 및 링크하면 OpenMP 런타임 라이브러리가 링크됩니다. 옵션</target>
        </trans-unit>
        <trans-unit id="3df0ff791aff36a80d556d2b67a1e152b709663d" translate="yes" xml:space="preserve">
          <source>Enable the generation of run-time checks; the argument shall be a comma-delimited list of the following keywords. Prefixing a check with</source>
          <target state="translated">런타임 검사 생성 가능; 인수는 쉼표로 구분 된 다음 키워드 목록입니다. 검사 접두사</target>
        </trans-unit>
        <trans-unit id="f55014936e9e5689911fd55434a6710cbcd8de5a" translate="yes" xml:space="preserve">
          <source>Enables commonly used warning options pertaining to usage that we recommend avoiding and that we believe are easy to avoid. This currently includes</source>
          <target state="translated">피하는 것이 좋으며 피하기 쉬운 것으로 여겨지는 사용법과 관련하여 일반적으로 사용되는 경고 옵션을 활성화합니다. 이것은 현재 포함</target>
        </trans-unit>
        <trans-unit id="c51b6a9f08bb1378874e4f235c5241ecde89a357" translate="yes" xml:space="preserve">
          <source>Enables run-time checking. Possible values are (bitwise or-ed): GFC_RTCHECK_BOUNDS (1), GFC_RTCHECK_ARRAY_TEMPS (2), GFC_RTCHECK_RECURSION (4), GFC_RTCHECK_DO (16), GFC_RTCHECK_POINTER (32). Default: disabled.</source>
          <target state="translated">런타임 검사를 활성화합니다. 가능한 값은 (비트 단위 또는 비트 단위)입니다 : GFC_RTCHECK_BOUNDS (1), GFC_RTCHECK_ARRAY_TEMPS (2), GFC_RTCHECK_RECURSION (4), GFC_RTCHECK_DO (16), GFC_RTCHECK_POINTER (32). 기본값 : 비활성화</target>
        </trans-unit>
        <trans-unit id="c4bb5e77bb32879c9b1139092395e91ea1a9638d" translate="yes" xml:space="preserve">
          <source>Enables some warning options for usages of language features which may be problematic. This currently includes</source>
          <target state="translated">문제가 될 수있는 언어 기능 사용에 대한 일부 경고 옵션을 활성화합니다. 이것은 현재 포함</target>
        </trans-unit>
        <trans-unit id="736b202b96ccbcb2d419ba178f9f6671142976d0" translate="yes" xml:space="preserve">
          <source>End-off shift elements of an array</source>
          <target state="translated">배열의 종료 시프트 요소</target>
        </trans-unit>
        <trans-unit id="717bd7ce3ae71c32074ca2e4fdd25ba9275aebf4" translate="yes" xml:space="preserve">
          <source>Endian conversion, possible values: GFC_CONVERT_NATIVE (0, default), GFC_CONVERT_SWAP (1), GFC_CONVERT_BIG (2), GFC_CONVERT_LITTLE (3).</source>
          <target state="translated">엔디안 변환, 가능한 값 : GFC_CONVERT_NATIVE (0, 기본값), GFC_CONVERT_SWAP (1), GFC_CONVERT_BIG (2), GFC_CONVERT_LITTLE (3).</target>
        </trans-unit>
        <trans-unit id="679b6834d5e74ac1addbcfb12cf181035a208ca4" translate="yes" xml:space="preserve">
          <source>Enhance test coverage by forcing most forall assignments to use temporary.</source>
          <target state="translated">대부분의 모든 할당에서 임시를 사용하도록하여 테스트 범위를 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="055ca553c9f111d93d8b8e040bb84e9ef4cc622c" translate="yes" xml:space="preserve">
          <source>Entering &amp;lsquo;</source>
          <target state="translated">'입력</target>
        </trans-unit>
        <trans-unit id="4d76ce6c27fdf6c6d1b5b427c5f1536a979fd7d5" translate="yes" xml:space="preserve">
          <source>Entities marked &lt;code&gt;AUTOMATIC&lt;/code&gt; will be stack automatic whenever possible. &lt;code&gt;AUTOMATIC&lt;/code&gt; is the default for local variables smaller than</source>
          <target state="translated">&lt;code&gt;AUTOMATIC&lt;/code&gt; 으로 표시된 엔터티는 가능할 때마다 자동으로 쌓입니다. &lt;code&gt;AUTOMATIC&lt;/code&gt; 은보다 작은 지역 변수의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="95e1752eccc38d5ee799e62cfff0d6c30ca5ac2d" translate="yes" xml:space="preserve">
          <source>Environment Options</source>
          <target state="translated">환경 옵션</target>
        </trans-unit>
        <trans-unit id="822503b7ce12eca3400e8db03d118b6a47883ce8" translate="yes" xml:space="preserve">
          <source>Environment variables that affect &lt;code&gt;gfortran&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gfortran&lt;/code&gt; 에 영향을주는 환경 변수 .</target>
        </trans-unit>
        <trans-unit id="110c7d0804a6049443bac6b51f71fe7cbaddcc42" translate="yes" xml:space="preserve">
          <source>Epsilon function</source>
          <target state="translated">엡실론 기능</target>
        </trans-unit>
        <trans-unit id="514b47930d45f4f8aa313dd4016aaa2289bef675" translate="yes" xml:space="preserve">
          <source>Error and Warning Options</source>
          <target state="translated">오류 및 경고 옵션</target>
        </trans-unit>
        <trans-unit id="a623c8e1a198390969227d2d0b456f83bf23e21d" translate="yes" xml:space="preserve">
          <source>Error function</source>
          <target state="translated">에러 기능</target>
        </trans-unit>
        <trans-unit id="1be2857ae204742673930b5b6e7e5e06a562e515" translate="yes" xml:space="preserve">
          <source>Error termination with exit code</source>
          <target state="translated">종료 코드로 오류 종료</target>
        </trans-unit>
        <trans-unit id="71a396c9bc1709f18366cff9ba8cbf4fdded6057" translate="yes" xml:space="preserve">
          <source>Error termination with string</source>
          <target state="translated">문자열로 오류 종료</target>
        </trans-unit>
        <trans-unit id="d334fd577103a199bfd3f2f850942b0b138efdac" translate="yes" xml:space="preserve">
          <source>Errors are diagnostic messages that report that the GNU Fortran compiler cannot compile the relevant piece of source code. The compiler will continue to process the program in an attempt to report further errors to aid in debugging, but will not produce any compiled output.</source>
          <target state="translated">오류는 GNU Fortran 컴파일러가 관련 소스 코드를 컴파일 할 수 없다는보고 메시지입니다. 컴파일러는 디버깅을 돕기 위해 추가 오류를보고하기 위해 프로그램을 계속 처리하지만 컴파일 된 출력은 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d106371f92338f637fe47f23a332ff1ebd2419d9" translate="yes" xml:space="preserve">
          <source>Euclidean distance function</source>
          <target state="translated">유클리드 거리 기능</target>
        </trans-unit>
        <trans-unit id="e9f121bde814d9377bcef33277dedf3bb786b52d" translate="yes" xml:space="preserve">
          <source>Euclidean vector norm</source>
          <target state="translated">유클리드 벡터 규범</target>
        </trans-unit>
        <trans-unit id="c348ee0cf6e63ecd0e206f04f9116a4e8293380b" translate="yes" xml:space="preserve">
          <source>Even if you are doing mixed-language programming, it is very likely that you do not need to know or use the information in this section. Since it is about the internal structure of GNU Fortran, it may also change in GCC minor releases.</source>
          <target state="translated">혼합 언어 프로그래밍을 수행하는 경우에도이 섹션의 정보를 알거나 사용할 필요가 없습니다. GNU Fortran의 내부 구조에 관한 것이기 때문에 GCC 부 릴리스에서도 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c2267fb1e94c781d17e9e2745a19c2b87d07f8f" translate="yes" xml:space="preserve">
          <source>Events (&lt;code&gt;EVENT POST&lt;/code&gt;, &lt;code&gt;EVENT WAIT&lt;/code&gt;, &lt;code&gt;EVENT_QUERY&lt;/code&gt;)</source>
          <target state="translated">이벤트 ( &lt;code&gt;EVENT POST&lt;/code&gt; , &lt;code&gt;EVENT WAIT&lt;/code&gt; , &lt;code&gt;EVENT_QUERY&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f03fce1e89651559dc4fef62427b73963e4b51a5" translate="yes" xml:space="preserve">
          <source>Example code for &lt;code&gt;csh&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;csh&lt;/code&gt; 의 예제 코드 :</target>
        </trans-unit>
        <trans-unit id="3ca52a83bd82617c4b879929d630469ff282b466" translate="yes" xml:space="preserve">
          <source>Example for &lt;code&gt;sh&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;sh&lt;/code&gt; 의 예 :</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="d7d21fc9aca2bd8ce5b741dc50bbd2f05d8fb0ce" translate="yes" xml:space="preserve">
          <source>Example: Assuming you have a file</source>
          <target state="translated">예 : 파일이 있다고 가정</target>
        </trans-unit>
        <trans-unit id="d2dd30cb8567ddb3d452c6b506347886f72de342" translate="yes" xml:space="preserve">
          <source>Examples of standard-conforming code equivalent to the above example are:</source>
          <target state="translated">위의 예와 동등한 표준 준수 코드의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8a18e7062dd7ab6ef5e754f3541ddbcff8268381" translate="yes" xml:space="preserve">
          <source>Examples of valid uses of Hollerith constants:</source>
          <target state="translated">Hollerith 상수의 유효한 사용 예 :</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="e5b45b3f8e1e7fcadcabc19465055e58ea97b07b" translate="yes" xml:space="preserve">
          <source>Exclusive (write) lock</source>
          <target state="translated">독점 (쓰기) 잠금</target>
        </trans-unit>
        <trans-unit id="fe8338e17b2cbe4fe73dbf0c080b9a2560bbd979" translate="yes" xml:space="preserve">
          <source>Execute a shell command</source>
          <target state="translated">쉘 명령 실행</target>
        </trans-unit>
        <trans-unit id="d2280adbbd397c997cfdecf1073f9d9e51c1e78c" translate="yes" xml:space="preserve">
          <source>Execution time subroutine (or function)</source>
          <target state="translated">실행 시간 서브 루틴 (또는 기능)</target>
        </trans-unit>
        <trans-unit id="d72d094032d0fc7b0571382de535733d0fde2b2a" translate="yes" xml:space="preserve">
          <source>Exit the program with status.</source>
          <target state="translated">상태로 프로그램을 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="5b0c206832dc7ef2660e7877a8f50474947ba66d" translate="yes" xml:space="preserve">
          <source>Expanded namelist reads are permitted. This causes an error if</source>
          <target state="translated">확장 된 이름 목록 읽기가 허용됩니다. 이 경우 오류가 발생합니다</target>
        </trans-unit>
        <trans-unit id="72001987a55c3c95306938db75f624e209fdc027" translate="yes" xml:space="preserve">
          <source>Explicit form</source>
          <target state="translated">명시 적 양식</target>
        </trans-unit>
        <trans-unit id="de91599a67aa51bfcab657facf2665db23dc5eb8" translate="yes" xml:space="preserve">
          <source>Exponent function</source>
          <target state="translated">지수 함수</target>
        </trans-unit>
        <trans-unit id="4f1941c72a58c3dfdbb377e8a0b69218db658e01" translate="yes" xml:space="preserve">
          <source>Exponential function</source>
          <target state="translated">지수 함수</target>
        </trans-unit>
        <trans-unit id="3162adee32d3803a3372c5524b8427f0be751f78" translate="yes" xml:space="preserve">
          <source>Exponentially-scaled complementary error function</source>
          <target state="translated">지수 스케일 상보 오차 함수</target>
        </trans-unit>
        <trans-unit id="82b4b0e4204e568cce8f019d876eda0d0fd07bc2" translate="yes" xml:space="preserve">
          <source>Ext.</source>
          <target state="translated">Ext.</target>
        </trans-unit>
        <trans-unit id="659087d3ca23db6ae11e0a43579b5f4a260dda11" translate="yes" xml:space="preserve">
          <source>Extension</source>
          <target state="translated">Extension</target>
        </trans-unit>
        <trans-unit id="d9f5087a226b6b4ca3c6512566b85a862a66a750" translate="yes" xml:space="preserve">
          <source>Extensions to the &lt;code&gt;ALLOCATE&lt;/code&gt; statement, allowing for a type-specification with type parameter and for allocation and initialization from a &lt;code&gt;SOURCE=&lt;/code&gt; expression; &lt;code&gt;ALLOCATE&lt;/code&gt; and &lt;code&gt;DEALLOCATE&lt;/code&gt; optionally return an error message string via &lt;code&gt;ERRMSG=&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ALLOCATE&lt;/code&gt; 문의 확장으로, 유형 매개 변수로 유형을 지정하고 &lt;code&gt;SOURCE=&lt;/code&gt; 표현식 에서 할당 및 초기화 할 수 있습니다 . &lt;code&gt;ALLOCATE&lt;/code&gt; 및 &lt;code&gt;DEALLOCATE&lt;/code&gt; 는 선택적으로 &lt;code&gt;ERRMSG=&lt;/code&gt; 를 통해 오류 메시지 문자열을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="c8fd044d83063b270bbe0406d6e7802f9b0b0f33" translate="yes" xml:space="preserve">
          <source>Extensions to the specification and initialization expressions, including the support for intrinsics with real and complex arguments.</source>
          <target state="translated">실제 및 복잡한 인수로 내장 함수 지원을 포함하여 사양 및 초기화 표현식의 확장.</target>
        </trans-unit>
        <trans-unit id="5b12df15e4b3f0f76de287c2988f11a897a181d2" translate="yes" xml:space="preserve">
          <source>F77 and later</source>
          <target state="translated">F77 이상</target>
        </trans-unit>
        <trans-unit id="ae47a00d0363e43fde2562a3b67f222cc3955326" translate="yes" xml:space="preserve">
          <source>F95 and later</source>
          <target state="translated">F95 이상</target>
        </trans-unit>
        <trans-unit id="4a9768fab0628379ad61cfc011fe3685fe4972f3" translate="yes" xml:space="preserve">
          <source>FREE</source>
          <target state="translated">FREE</target>
        </trans-unit>
        <trans-unit id="423e40a50eeb9ebcfb0a19115ffe5c3d55e61788" translate="yes" xml:space="preserve">
          <source>FSEEK</source>
          <target state="translated">FSEEK</target>
        </trans-unit>
        <trans-unit id="53551c309ecb38ca2a64866447eb9dcdf64abc08" translate="yes" xml:space="preserve">
          <source>FTELL</source>
          <target state="translated">FTELL</target>
        </trans-unit>
        <trans-unit id="4be42a04bd6aaf55b94d4242d0f631c3aee9225d" translate="yes" xml:space="preserve">
          <source>Failed images (&lt;code&gt;FAIL IMAGE&lt;/code&gt;, &lt;code&gt;IMAGE_STATUS&lt;/code&gt;, &lt;code&gt;FAILED_IMAGES&lt;/code&gt;, &lt;code&gt;STOPPED_IMAGES&lt;/code&gt;)</source>
          <target state="translated">실패한 이미지 ( &lt;code&gt;FAIL IMAGE&lt;/code&gt; , &lt;code&gt;IMAGE_STATUS&lt;/code&gt; , &lt;code&gt;FAILED_IMAGES&lt;/code&gt; , &lt;code&gt;STOPPED_IMAGES&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a42254df52793c39c2ede39da84f389dca208d33" translate="yes" xml:space="preserve">
          <source>File mode</source>
          <target state="translated">파일 모드</target>
        </trans-unit>
        <trans-unit id="d8df668120bb484081e760b37513790b01350187" translate="yes" xml:space="preserve">
          <source>File number function</source>
          <target state="translated">파일 번호 기능</target>
        </trans-unit>
        <trans-unit id="c1762107e3ccce4613cb6916b2f5f2f3f490e545" translate="yes" xml:space="preserve">
          <source>File size (bytes)</source>
          <target state="translated">파일 크기 (바이트)</target>
        </trans-unit>
        <trans-unit id="4c6cb52df9a645cf10f921a3f31ab2d5a818b1c6" translate="yes" xml:space="preserve">
          <source>Finalization function</source>
          <target state="translated">마무리 기능</target>
        </trans-unit>
        <trans-unit id="a77e3ade07a6ed30a721049e2e4e1e5b4b59568d" translate="yes" xml:space="preserve">
          <source>Finally, note that enabling any of the</source>
          <target state="translated">마지막으로</target>
        </trans-unit>
        <trans-unit id="1055921af2b8d34b3b9ae5925fe674ba7247ff53" translate="yes" xml:space="preserve">
          <source>Flush I/O unit(s)</source>
          <target state="translated">플러시 I / O 장치</target>
        </trans-unit>
        <trans-unit id="8ad3157a6acceee89fe4a8d67d9b6fced5bcec92" translate="yes" xml:space="preserve">
          <source>Flushes Fortran unit(s) currently open for output. Without the optional argument, all units are flushed, otherwise just the unit specified.</source>
          <target state="translated">플러시 포트란 장치가 현재 출력을 위해 열려 있습니다. 선택적 인수가 없으면 모든 단위가 플러시되고 그렇지 않으면 지정된 단위 만 플러시됩니다.</target>
        </trans-unit>
        <trans-unit id="891f012ae7669ec3305d5df16b52933f9f008c6f" translate="yes" xml:space="preserve">
          <source>Following is an example mirroring the layout of an Intel x86_64 register:</source>
          <target state="translated">다음은 Intel x86_64 레지스터의 레이아웃을 미러링하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="fe3141d92469bdac0372f1256fb1b519d1cd9340" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;CAF_REGTYPE_COARRAY_STATIC&lt;/code&gt; and &lt;code&gt;CAF_REGTYPE_COARRAY_ALLOC&lt;/code&gt;, the passed size is the byte size requested. For &lt;code&gt;CAF_REGTYPE_LOCK_STATIC&lt;/code&gt;, &lt;code&gt;CAF_REGTYPE_LOCK_ALLOC&lt;/code&gt; and &lt;code&gt;CAF_REGTYPE_CRITICAL&lt;/code&gt; it is the array size or one for a scalar.</source>
          <target state="translated">들어 &lt;code&gt;CAF_REGTYPE_COARRAY_STATIC&lt;/code&gt; 및 &lt;code&gt;CAF_REGTYPE_COARRAY_ALLOC&lt;/code&gt; , 전달 된 크기가 요청한 바이트 크기입니다. 들면 &lt;code&gt;CAF_REGTYPE_LOCK_STATIC&lt;/code&gt; , &lt;code&gt;CAF_REGTYPE_LOCK_ALLOC&lt;/code&gt; 및 &lt;code&gt;CAF_REGTYPE_CRITICAL&lt;/code&gt; 는 스칼라 배열 크기 또는 1이다.</target>
        </trans-unit>
        <trans-unit id="e7fdc76d6673ddd61a5752377f7cbc3656ca5dff" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;OPTIONAL&lt;/code&gt; dummy arguments, an absent argument is denoted by a NULL pointer, except for scalar dummy arguments of type &lt;code&gt;INTEGER&lt;/code&gt;, &lt;code&gt;LOGICAL&lt;/code&gt;, &lt;code&gt;REAL&lt;/code&gt; and &lt;code&gt;COMPLEX&lt;/code&gt; which have the &lt;code&gt;VALUE&lt;/code&gt; attribute. For those, a hidden Boolean argument (&lt;code&gt;logical(kind=C_bool),value&lt;/code&gt;) is used to indicate whether the argument is present.</source>
          <target state="translated">들면 &lt;code&gt;OPTIONAL&lt;/code&gt; 더미 인수 부재중 인수는 스칼라 형의 더미 인자를 제외하고 NULL 포인터에 의해 표시된다 &lt;code&gt;INTEGER&lt;/code&gt; , &lt;code&gt;LOGICAL&lt;/code&gt; , &lt;code&gt;REAL&lt;/code&gt; 및 &lt;code&gt;COMPLEX&lt;/code&gt; 이 &lt;code&gt;VALUE&lt;/code&gt; 의 속성. 이를 위해 숨겨진 부울 인수 ( &lt;code&gt;logical(kind=C_bool),value&lt;/code&gt; )를 사용하여 인수가 있는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fd7591b61c29f7a7e8a7fccd73e4bf12ac95577e" translate="yes" xml:space="preserve">
          <source>For Boolean (&lt;code&gt;LOGICAL&lt;/code&gt;) arguments, please note that GCC expects only the integer value 0 and 1. If a GNU Fortran &lt;code&gt;LOGICAL&lt;/code&gt; variable contains another integer value, the result is undefined. As some other Fortran compilers use &lt;em&gt;-1&lt;/em&gt; for &lt;code&gt;.TRUE.&lt;/code&gt;, extra care has to be taken &amp;ndash; such as passing the value as &lt;code&gt;INTEGER&lt;/code&gt;. (The same value restriction also applies to other front ends of GCC, e.g. to GCC&amp;rsquo;s C99 compiler for &lt;code&gt;_Bool&lt;/code&gt; or GCC&amp;rsquo;s Ada compiler for &lt;code&gt;Boolean&lt;/code&gt;.)</source>
          <target state="translated">부울 ( &lt;code&gt;LOGICAL&lt;/code&gt; ) 인수의 경우 GCC는 정수 값 0과 1 만 예상한다는 점에 유의하십시오. GNU Fortran &lt;code&gt;LOGICAL&lt;/code&gt; 변수에 다른 정수 값이 포함 된 경우 결과는 정의되지 않습니다. 다른 Fortran 컴파일러 는 &lt;code&gt;.TRUE.&lt;/code&gt; &lt;em&gt;-1&lt;/em&gt; 을 사용 합니다. &lt;code&gt;INTEGER&lt;/code&gt; 값을 전달하는 등의 추가주의가 필요합니다 . (GCC의 다른 프런트 엔드에도 동일한 값 제한이 적용됩니다 (예 : &lt;code&gt;_Bool&lt;/code&gt; 의 경우 GCC의 C99 컴파일러 또는 &lt;code&gt;Boolean&lt;/code&gt; 의 경우 GCC의 Ada 컴파일러 ).</target>
        </trans-unit>
        <trans-unit id="17c42d36ba186c9c9566a4f51dd4f2ecdc877351" translate="yes" xml:space="preserve">
          <source>For advanced users, it may be important to know the implementation of these functions. They are simply wrappers around the standard radian functions, which have more accurate builtin versions. These functions convert their arguments (or results) to degrees (or radians) by taking the value modulus 360 (or 2*pi) and then multiplying it by a constant radian-to-degree (or degree-to-radian) factor, as appropriate. The factor is computed at compile-time as 180/pi (or pi/180).</source>
          <target state="translated">고급 사용자의 경우 이러한 기능의 구현을 아는 것이 중요 할 수 있습니다. 그들은 더 정확한 내장 버전을 가진 표준 라디안 함수를 감싸는 것입니다. 이 함수는 값 계수 360 (또는 2 * pi)을 취한 다음 상수 라디안-도 (또는도-라디안) 계수를 곱하여 인수 (또는 결과)를도 (또는 라디안)로 변환합니다. 적당한. 인수는 컴파일 타임에 180 / pi (또는 pi / 180)로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="259f214752a0743a89be2e404853ef1cb91d6dee" translate="yes" xml:space="preserve">
          <source>For arguments of &lt;code&gt;CHARACTER&lt;/code&gt; type, the character length is passed as hidden argument. For deferred-length strings, the value is passed by reference, otherwise by value. The character length has the type &lt;code&gt;INTEGER(kind=4)&lt;/code&gt;. Note with C binding, &lt;code&gt;CHARACTER(len=1)&lt;/code&gt; result variables are returned according to the platform ABI and no hidden length argument is used for dummy arguments; with &lt;code&gt;VALUE&lt;/code&gt;, those variables are passed by value.</source>
          <target state="translated">&lt;code&gt;CHARACTER&lt;/code&gt; 유형의 인수의 경우 문자 길이가 숨겨진 인수로 전달됩니다. 지연 길이 문자열의 경우 값은 참조로, 그렇지 않으면 값으로 전달됩니다. 문자 길이는 &lt;code&gt;INTEGER(kind=4)&lt;/code&gt; 유형 입니다. C 바인딩에서 &lt;code&gt;CHARACTER(len=1)&lt;/code&gt; 결과 변수는 플랫폼 ABI에 따라 리턴되며 더미 인수에는 숨겨진 길이 인수가 사용되지 않습니다. 와 &lt;code&gt;VALUE&lt;/code&gt; , 해당 변수의 값에 의해 전달된다.</target>
        </trans-unit>
        <trans-unit id="970ca85e2243e1294e41d72d1a5174d7359f30dd" translate="yes" xml:space="preserve">
          <source>For arguments with &lt;code&gt;ALLOCATABLE&lt;/code&gt; and &lt;code&gt;POINTER&lt;/code&gt; attribute (including procedure pointers), a pointer to the pointer is passed such that the pointer address can be modified in the procedure.</source>
          <target state="translated">&lt;code&gt;ALLOCATABLE&lt;/code&gt; 및 &lt;code&gt;POINTER&lt;/code&gt; 속성 (프로 시저 포인터 포함)을 가진 인수의 경우 , 포인터 주소가 프로 시저에서 수정 될 수 있도록 포인터에 대한 포인터가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b7aebafeeb2d15a5bdeaa2c90a8ea58f48434e2d" translate="yes" xml:space="preserve">
          <source>For character arguments, the result is passed as first argument, followed by the result string length, next come the two string arguments, followed by the two hidden string length arguments. With C binding, there are no hidden arguments and by-reference passing and either only a single character is passed or an array descriptor.</source>
          <target state="translated">문자 인수의 경우 결과는 첫 번째 인수로 전달되고 그 뒤에 결과 문자열 길이가오고 다음에 두 개의 문자열 인수가오고 그 뒤에 숨겨진 문자열 길이 인수가옵니다. C 바인딩을 사용하면 숨겨진 인수 및 참조 기준 전달이 없으며 단일 문자 만 전달되거나 배열 설명자입니다.</target>
        </trans-unit>
        <trans-unit id="426c7003c930ea128233368d2180db222e3dcb29" translate="yes" xml:space="preserve">
          <source>For common blocks, the same convention is used, i.e. by default an underscore is appended to the lower-cased Fortran name. Blank commons have the name &lt;code&gt;__BLNK__&lt;/code&gt;.</source>
          <target state="translated">공통 블록의 경우 동일한 규칙이 사용됩니다. 즉, 기본적으로 밑줄이 소문자 Fortran 이름에 추가됩니다. 빈 커먼은 &lt;code&gt;__BLNK__&lt;/code&gt; 이름을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="178a1b3ff1abdd2db7e5af0d1c7094b5b151cdcc" translate="yes" xml:space="preserve">
          <source>For compatibility of derived types with &lt;code&gt;struct&lt;/code&gt;, one needs to use the &lt;code&gt;BIND(C)&lt;/code&gt; attribute in the type declaration. For instance, the following type declaration</source>
          <target state="translated">파생 형식과 &lt;code&gt;struct&lt;/code&gt; 의 호환성을 위해서는 형식 선언에 &lt;code&gt;BIND(C)&lt;/code&gt; 특성 을 사용해야합니다 . 예를 들어, 다음 유형 선언</target>
        </trans-unit>
        <trans-unit id="8f71090cd2615e03758ff6a0140e754aa8db6fa4" translate="yes" xml:space="preserve">
          <source>For compatibility with HP FORTRAN 77/iX, the &lt;code&gt;RAN&lt;/code&gt; intrinsic is provided as an alias for &lt;code&gt;RAND&lt;/code&gt;. See &lt;a href=&quot;rand#RAND&quot;&gt;RAND&lt;/a&gt; for complete documentation.</source>
          <target state="translated">HP FORTRAN 77 / iX와의 호환성을 위해 &lt;code&gt;RAN&lt;/code&gt; 내장 함수는 &lt;code&gt;RAND&lt;/code&gt; 의 별명으로 제공됩니다 . 완전한 문서는 &lt;a href=&quot;rand#RAND&quot;&gt;RAND&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="25af6b4c58f069b25e713da7d5557ff178a3f5a5" translate="yes" xml:space="preserve">
          <source>For compatibility, GNU Fortran supports a default exponent of zero in real constants with</source>
          <target state="translated">호환성을 위해 GNU Fortran은 다음과 같이 실제 상수에서 기본 지수 0을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c5af42816bc5cc524c275158a3ba0c37e8664d06" translate="yes" xml:space="preserve">
          <source>For compatibility, GNU Fortran supports legacy PARAMETER statements without parentheses with</source>
          <target state="translated">호환성을 위해 GNU Fortran은 괄호없이 레거시 PARAMETER 문을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="7e098c3322755ef138df8f0ecec6e73425f20c18" translate="yes" xml:space="preserve">
          <source>For compatibility, GNU Fortran will interpret &lt;code&gt;TYPE&lt;/code&gt; statements as &lt;code&gt;PRINT&lt;/code&gt; statements with the flag</source>
          <target state="translated">호환성을 위해 GNU Fortran은 &lt;code&gt;TYPE&lt;/code&gt; 문을 플래그가있는 &lt;code&gt;PRINT&lt;/code&gt; 문으로 해석 합니다.</target>
        </trans-unit>
        <trans-unit id="d0e99ef452ad37b29f8957ca1708f2fbb08ca447" translate="yes" xml:space="preserve">
          <source>For details refer to the actual &lt;a href=&quot;http://www.openacc.org/&quot;&gt;OpenACC Application Programming Interface v2.0&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 실제 &lt;a href=&quot;http://www.openacc.org/&quot;&gt;OpenACC 응용 프로그래밍 인터페이스 v2.0을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d00cc4c9c80b5855ef42975c57c5aee54c5b4f4a" translate="yes" xml:space="preserve">
          <source>For details refer to the actual &lt;a href=&quot;http://www.openmp.org/wp-content/uploads/openmp-4.5.pdf&quot;&gt;OpenMP Application Program Interface v4.5&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 실제 &lt;a href=&quot;http://www.openmp.org/wp-content/uploads/openmp-4.5.pdf&quot;&gt;OpenMP Application Program Interface v4.5&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e594c16383c40239383e20ad91fe6f6521c6aa29" translate="yes" xml:space="preserve">
          <source>For details refer to the g77 manual &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-3.4.6/g77/index.html#Top&quot;&gt;https://gcc.gnu.org/onlinedocs/gcc-3.4.6/g77/index.html#Top&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 g77 매뉴얼 &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-3.4.6/g77/index.html#Top&quot;&gt;https://gcc.gnu.org/onlinedocs/gcc-3.4.6/g77/index.html#Top을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8e0fade3bb34774f9ec842779237f963e3e8cfb6" translate="yes" xml:space="preserve">
          <source>For dummy arguments with the &lt;code&gt;VALUE&lt;/code&gt; attribute: Scalar arguments of the type &lt;code&gt;INTEGER&lt;/code&gt;, &lt;code&gt;LOGICAL&lt;/code&gt;, &lt;code&gt;REAL&lt;/code&gt; and &lt;code&gt;COMPLEX&lt;/code&gt; are passed by value according to the platform ABI. (As vendor extension and not recommended, using &lt;code&gt;%VAL()&lt;/code&gt; in the call to a procedure has the same effect.) For &lt;code&gt;TYPE(C_PTR)&lt;/code&gt; and procedure pointers, the pointer itself is passed such that it can be modified without affecting the caller.</source>
          <target state="translated">&lt;code&gt;VALUE&lt;/code&gt; 속성을 갖는 더미 인수 의 경우 : &lt;code&gt;INTEGER&lt;/code&gt; , &lt;code&gt;LOGICAL&lt;/code&gt; , &lt;code&gt;REAL&lt;/code&gt; 및 &lt;code&gt;COMPLEX&lt;/code&gt; 유형의 스칼라 인수 는 플랫폼 ABI에 따라 값으로 전달됩니다. (공급 업체 확장으로서 권장되지는 않지만 프로 시저 호출에서 &lt;code&gt;%VAL()&lt;/code&gt; 을 사용하는 경우에도 동일한 효과가 있습니다.) &lt;code&gt;TYPE(C_PTR)&lt;/code&gt; 및 프로 시저 포인터의 경우 호출자에게 영향을주지 않고 수정할 수 있도록 포인터 자체가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b14d0076ba78b293765b275b3929440d94cf1437" translate="yes" xml:space="preserve">
          <source>For dummy arguments, the &lt;code&gt;NO_ARG_CHECK&lt;/code&gt; attribute can be used; in other compilers, it is also known as &lt;code&gt;IGNORE_TKR&lt;/code&gt;. For dummy arguments with this attribute actual arguments of any type and kind (similar to &lt;code&gt;TYPE(*)&lt;/code&gt;), scalars and arrays of any rank (no equivalent in Fortran standard) are accepted. As with &lt;code&gt;TYPE(*)&lt;/code&gt;, the argument is unlimited polymorphic and no type information is available. Additionally, the argument may only be passed to dummy arguments with the &lt;code&gt;NO_ARG_CHECK&lt;/code&gt; attribute and as argument to the &lt;code&gt;PRESENT&lt;/code&gt; intrinsic function and to &lt;code&gt;C_LOC&lt;/code&gt; of the &lt;code&gt;ISO_C_BINDING&lt;/code&gt; module.</source>
          <target state="translated">더미 인수의 경우 &lt;code&gt;NO_ARG_CHECK&lt;/code&gt; 속성을 사용할 수 있습니다. 다른 컴파일러에서는 &lt;code&gt;IGNORE_TKR&lt;/code&gt; 로도 알려져 있습니다 . 이 속성을 가진 더미 인수의 경우 모든 유형 및 종류의 실제 인수 ( &lt;code&gt;TYPE(*)&lt;/code&gt; 와 유사 ), 스칼라 및 임의의 순위 배열 (Fortran 표준과 동일하지 않음)이 허용됩니다. 와 같이 &lt;code&gt;TYPE(*)&lt;/code&gt; , 인수 무제한 다형성이고 어떤 종류 정보를 사용할 수 없다. 또한 인수는 &lt;code&gt;NO_ARG_CHECK&lt;/code&gt; 속성 이있는 더미 인수 및 &lt;code&gt;PRESENT&lt;/code&gt; 내장 함수 및 &lt;code&gt;ISO_C_BINDING&lt;/code&gt; 모듈의 &lt;code&gt;C_LOC&lt;/code&gt; 에 대한 인수로 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="5d819b4ca99447d987dd9489f0eb33f9f0ca4cea" translate="yes" xml:space="preserve">
          <source>For example, with</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="e2fed11faf2ee2dfa0347c4b85e45acbbe12c868" translate="yes" xml:space="preserve">
          <source>For full compliance with the Fortran standards, code using the &lt;code&gt;IEEE_EXCEPTIONS&lt;/code&gt; or &lt;code&gt;IEEE_ARITHMETIC&lt;/code&gt; modules should be compiled with the following options: &lt;code&gt;-fno-unsafe-math-optimizations
-frounding-math -fsignaling-nans&lt;/code&gt;.</source>
          <target state="translated">Fortran 표준을 완전히 준수하려면 &lt;code&gt;IEEE_EXCEPTIONS&lt;/code&gt; 또는 &lt;code&gt;IEEE_ARITHMETIC&lt;/code&gt; 모듈을 사용하는 코드를 다음 옵션으로 컴파일해야합니다. &lt;code&gt;-fno-unsafe-math-optimizations -frounding-math -fsignaling-nans&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53fb0ed666c8e4637fb179fb6cd1945b65370392" translate="yes" xml:space="preserve">
          <source>For lock types, the value shall only used for checking the allocation status. Note that for critical blocks, the locking is only required on one image; in the locking statement, the processor shall always pass an image index of one for critical-block lock variables (&lt;code&gt;CAF_REGTYPE_CRITICAL&lt;/code&gt;). For lock types and critical-block variables, the initial value shall be unlocked (or, respecitively, not in critical section) such as the value false; for event types, the initial state should be no event, e.g. zero.</source>
          <target state="translated">잠금 유형의 경우이 값은 할당 상태를 확인하는 데만 사용됩니다. 중요한 블록의 경우 잠금은 하나의 이미지에만 필요합니다. 잠금 명령문에서 프로세서는 항상 임계 블록 잠금 변수 ( &lt;code&gt;CAF_REGTYPE_CRITICAL&lt;/code&gt; )에 대해 1의 이미지 인덱스를 전달해야합니다 . 잠금 유형 및 임계 블록 변수의 경우 초기 값은 false 값과 같이 잠금 해제되어야합니다 (또는 임계 섹션에 있지 않은 경우). 이벤트 유형의 경우 초기 상태는 이벤트가 없어야합니다 (예 : 0).</target>
        </trans-unit>
        <trans-unit id="afc3c44d8400821c7e66ccec759312f8ae890d0c" translate="yes" xml:space="preserve">
          <source>For logical types, please note that the Fortran standard only guarantees interoperability between C99&amp;rsquo;s &lt;code&gt;_Bool&lt;/code&gt; and Fortran&amp;rsquo;s &lt;code&gt;C_Bool&lt;/code&gt;-kind logicals and C99 defines that &lt;code&gt;true&lt;/code&gt; has the value 1 and &lt;code&gt;false&lt;/code&gt; the value 0. Using any other integer value with GNU Fortran&amp;rsquo;s &lt;code&gt;LOGICAL&lt;/code&gt; (with any kind parameter) gives an undefined result. (Passing other integer values than 0 and 1 to GCC&amp;rsquo;s &lt;code&gt;_Bool&lt;/code&gt; is also undefined, unless the integer is explicitly or implicitly casted to &lt;code&gt;_Bool&lt;/code&gt;.)</source>
          <target state="translated">논리적 유형의 경우, 주 포트란 표준은 C99의 사이의 상호 운용성을 보장하시기 &lt;code&gt;_Bool&lt;/code&gt; 및 포트란의 &lt;code&gt;C_Bool&lt;/code&gt; - 비슷한 전에 논리 것을 C99의 정의 &lt;code&gt;true&lt;/code&gt; 값 1이 &lt;code&gt;false&lt;/code&gt; GNU 포트란의 어떤 다른 정수 값을 사용하여 값을 0으로 &lt;code&gt;LOGICAL&lt;/code&gt; 어떤 종류를 ( 매개 변수)는 정의되지 않은 결과를 제공합니다. (0과 1 이외의 다른 정수 값을 GCC의 &lt;code&gt;_Bool&lt;/code&gt; 에 전달 하는 것은 정수가 명시 적으로 또는 암시 적으로 &lt;code&gt;_Bool&lt;/code&gt; 에 캐스트되지 않는 한 정의되지 않습니다 .)</target>
        </trans-unit>
        <trans-unit id="645123108939cc7f1351ed4c5ed24616382f1cd6" translate="yes" xml:space="preserve">
          <source>For non-Fortran programs, it is recommended to call the function at the end of the main program. To ensure that the shutdown is also performed for programs where this function is not explicitly invoked, for instance non-Fortran programs or calls to the system&amp;rsquo;s exit() function, the library can use a destructor function. Note that programs can also be terminated using the STOP and ERROR STOP statements; those use different library calls.</source>
          <target state="translated">포트란 프로그램이 아닌 경우, 메인 프로그램 끝에서 함수를 호출하는 것이 좋습니다. 이 함수가 명시 적으로 호출되지 않은 프로그램 (예 : Fortran 이외의 프로그램 또는 시스템의 exit () 함수 호출)에 대해서도 종료를 수행하기 위해 라이브러리는 소멸자 함수를 사용할 수 있습니다. STOP 및 ERROR STOP 문을 사용하여 프로그램을 종료 할 수도 있습니다. 이들은 다른 라이브러리 호출을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0fda3fe5658bbb16bc94a64d431d46d85c448ba3" translate="yes" xml:space="preserve">
          <source>For nonalloatable coarrays this function is never called. If a cleanup is required, it has to be handled via the finish, stop and error stop functions, and via destructors.</source>
          <target state="translated">할당 할 수없는 대립의 경우이 함수는 호출되지 않습니다. 정리가 필요한 경우 마무리, 정지 및 오류 정지 기능 및 소멸자를 통해 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="769b4b8ff7c8ca82cfd759be116b71400b388a27" translate="yes" xml:space="preserve">
          <source>For normal coarrays, the byte size of the coarray to be allocated; for lock types and event types, the number of elements.</source>
          <target state="translated">정상적인 성배의 경우, 할당 될 성의 바이트 크기; 잠금 유형 및 이벤트 유형의 경우 요소 수</target>
        </trans-unit>
        <trans-unit id="c5a7495577baa115fd7ba4bd2538cc9655c8ba1e" translate="yes" xml:space="preserve">
          <source>For platforms not supporting thread-safe POSIX functions, further functionality might not be thread-safe. For details, please consult the documentation for your operating system.</source>
          <target state="translated">스레드 안전 POSIX 기능을 지원하지 않는 플랫폼의 경우 추가 기능이 스레드 안전하지 않을 수 있습니다. 자세한 내용은 운영 체제 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0f754cea2447fc1f7de796841a533e2b0e744924" translate="yes" xml:space="preserve">
          <source>For pointers an &lt;code&gt;INTENT&lt;/code&gt; may be specified which affect the association status not the value of the pointer target.</source>
          <target state="translated">포인터 의 경우 포인터 대상 값이 아닌 연결 상태에 영향을주는 &lt;code&gt;INTENT&lt;/code&gt; 를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="861923ed4e8e6a14a71a9b944d725060158e3744" translate="yes" xml:space="preserve">
          <source>For procedures and procedure pointers, the following attributes can be used to change the calling convention:</source>
          <target state="translated">프로 시저 및 프로 시저 포인터의 경우 다음 속성을 사용하여 호출 규칙을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0c19985c4d97eb50e552a2c489eae620bd68157" translate="yes" xml:space="preserve">
          <source>For procedures and variables declared in the specification space of a module, the name is formed by &lt;code&gt;__&lt;/code&gt;, followed by the lower-cased module name, &lt;code&gt;_MOD_&lt;/code&gt;, and the lower-cased Fortran name. Note that no underscore is appended.</source>
          <target state="translated">모듈의 스펙 공간에 선언 된 프로 시저 및 변수의 경우 이름은 &lt;code&gt;__&lt;/code&gt; , 소문자 모듈 이름 &lt;code&gt;_MOD_&lt;/code&gt; 및 소문자 Fortran 이름으로 구성됩니다. 밑줄이 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="655c405a81e5a3a4c19aebaf53d1a577457fd59d" translate="yes" xml:space="preserve">
          <source>For procedures, the compiler directives shall be placed into the body of the procedure; for variables and procedure pointers, they shall be in the same declaration part as the variable or procedure pointer.</source>
          <target state="translated">절차의 경우, 컴파일러 지시문은 절차 본문에 배치해야합니다. 변수 및 프로 시저 포인터의 경우 변수 또는 프로 시저 포인터와 동일한 선언 부분에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="8a427ba74194babc5453eab5da2db6811558bae1" translate="yes" xml:space="preserve">
          <source>For some applications, using an assumed type (&lt;code&gt;TYPE(*)&lt;/code&gt;) can be an alternative to a C pointer; see &lt;a href=&quot;further-interoperability-of-fortran-with-c#Further-Interoperability-of-Fortran-with-C&quot;&gt;Further Interoperability of Fortran with C&lt;/a&gt;.</source>
          <target state="translated">일부 응용 프로그램의 경우 가정 된 유형 ( &lt;code&gt;TYPE(*)&lt;/code&gt; )을 사용하는 것이 C 포인터의 대안이 될 수 있습니다. &lt;a href=&quot;further-interoperability-of-fortran-with-c#Further-Interoperability-of-Fortran-with-C&quot;&gt;Fortran과 C의 추가 상호 운용성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bc450d193004ed238e7b680da61abe25abf08cb2" translate="yes" xml:space="preserve">
          <source>Form feed and carriage return</source>
          <target state="translated">용지 공급 및 캐리지 리턴</target>
        </trans-unit>
        <trans-unit id="8a752c06d30a05c39b13add7d13788b1ea87fc28" translate="yes" xml:space="preserve">
          <source>Fortran 2003 and 2008 features supported by GNU Fortran.</source>
          <target state="translated">GNU Fortran이 지원하는 Fortran 2003 및 2008 기능.</target>
        </trans-unit>
        <trans-unit id="8049b8b2641e35bcef652edc2904190c33161072" translate="yes" xml:space="preserve">
          <source>Fortran 2003 and later</source>
          <target state="translated">포트란 2003 이상</target>
        </trans-unit>
        <trans-unit id="be8e678d225d2b02acdd7a9b7addf693485412fe" translate="yes" xml:space="preserve">
          <source>Fortran 2003 and later, GNU extensions</source>
          <target state="translated">Fortran 2003 이상, GNU 확장</target>
        </trans-unit>
        <trans-unit id="1bac20e1b5cfb75c26c838eb05fc0f399a52b7a3" translate="yes" xml:space="preserve">
          <source>Fortran 2003 and later, except when otherwise noted</source>
          <target state="translated">달리 명시되지 않는 한 Fortran 2003 이상</target>
        </trans-unit>
        <trans-unit id="2b810db8309afcef29e853d785091fcf7ee3f676" translate="yes" xml:space="preserve">
          <source>Fortran 2003 functions and subroutines: &lt;a href=&quot;get_005fcommand#GET_005fCOMMAND&quot;&gt;GET_COMMAND&lt;/a&gt;, &lt;a href=&quot;get_005fcommand_005fargument#GET_005fCOMMAND_005fARGUMENT&quot;&gt;GET_COMMAND_ARGUMENT&lt;/a&gt;, &lt;a href=&quot;command_005fargument_005fcount#COMMAND_005fARGUMENT_005fCOUNT&quot;&gt;COMMAND_ARGUMENT_COUNT&lt;/a&gt;</source>
          <target state="translated">Fortran 2003 함수 및 서브 루틴 : &lt;a href=&quot;get_005fcommand#GET_005fCOMMAND&quot;&gt;GET_COMMAND&lt;/a&gt; , &lt;a href=&quot;get_005fcommand_005fargument#GET_005fCOMMAND_005fARGUMENT&quot;&gt;GET_COMMAND_ARGUMENT&lt;/a&gt; , &lt;a href=&quot;command_005fargument_005fcount#COMMAND_005fARGUMENT_005fCOUNT&quot;&gt;COMMAND_ARGUMENT_COUNT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="25848bf241e950c63f1af4412340dd891bb47b18" translate="yes" xml:space="preserve">
          <source>Fortran 2008</source>
          <target state="translated">포트란 2008</target>
        </trans-unit>
        <trans-unit id="1ea679a39ceb6a95c07c9136a2a03692a4fea5af" translate="yes" xml:space="preserve">
          <source>Fortran 2008 and later</source>
          <target state="translated">포트란 2008 이상</target>
        </trans-unit>
        <trans-unit id="8f34cb0c57bf1062c41e4b93972f755afbc10716" translate="yes" xml:space="preserve">
          <source>Fortran 2008 and later, negative &lt;var&gt;N&lt;/var&gt; is allowed as GNU extension</source>
          <target state="translated">Fortran 2008 및 이후 버전에서는 음수 &lt;var&gt;N&lt;/var&gt; 이 GNU 확장으로 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="322b57ba2de9a741b3868d4083ba39f7926978dc" translate="yes" xml:space="preserve">
          <source>Fortran 2008 and later. With &lt;var&gt;DISTANCE&lt;/var&gt; argument, Technical Specification (TS) 18508 or later</source>
          <target state="translated">포트란 2008 이상. &lt;var&gt;DISTANCE&lt;/var&gt; 인수를 사용하면 기술 사양 (TS) 18508 이상</target>
        </trans-unit>
        <trans-unit id="fa27f8e58cdf2fbed1b4cb7be9731382928222ae" translate="yes" xml:space="preserve">
          <source>Fortran 2008 and later. With &lt;var&gt;DISTANCE&lt;/var&gt; or &lt;var&gt;FAILED&lt;/var&gt; argument, Technical Specification (TS) 18508 or later</source>
          <target state="translated">포트란 2008 이상. 함께 &lt;var&gt;DISTANCE&lt;/var&gt; 또는 &lt;var&gt;FAILED&lt;/var&gt; 인수, 기술 명세 (TS) 18,508 이상</target>
        </trans-unit>
        <trans-unit id="9947fdd595045d2a5ada116bbf1d475822f8bd04" translate="yes" xml:space="preserve">
          <source>Fortran 2008 and later; with &lt;var&gt;STAT&lt;/var&gt;, TS 18508 or later</source>
          <target state="translated">포트란 2008 이상; 함께 &lt;var&gt;STAT&lt;/var&gt; , TS 18,508 이상</target>
        </trans-unit>
        <trans-unit id="64ebfe3bdefc03fc3b8a2fb51e20b176dbf58034" translate="yes" xml:space="preserve">
          <source>Fortran 77 and later</source>
          <target state="translated">포트란 77 이상</target>
        </trans-unit>
        <trans-unit id="406765d348ddc55fb3b91484131b625d8e6eb094" translate="yes" xml:space="preserve">
          <source>Fortran 77 and later, for a complex argument Fortran 2008 or later</source>
          <target state="translated">Fortran 77 이상, 복잡한 인수 Fortran 2008 이상</target>
        </trans-unit>
        <trans-unit id="714736797536bf0646c3b4cf42e8c2040e4ea876" translate="yes" xml:space="preserve">
          <source>Fortran 77 and later, for a complex argument and for two arguments Fortran 2008 or later</source>
          <target state="translated">Fortran 77 이상, 복잡한 인수 및 두 개의 인수 Fortran 2008 이상</target>
        </trans-unit>
        <trans-unit id="b9169d4c0be406db1eef72c1660dd14b9b9c7fa4" translate="yes" xml:space="preserve">
          <source>Fortran 77 and later, has overloads that are GNU extensions</source>
          <target state="translated">Fortran 77 이상에는 GNU 확장 인 과부하가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1445fcd8e1699afbac35eaa338e8a6e961d6a2f" translate="yes" xml:space="preserve">
          <source>Fortran 77 and later, with &lt;var&gt;KIND&lt;/var&gt; argument Fortran 2003 and later</source>
          <target state="translated">Fortran 77 이상, &lt;var&gt;KIND&lt;/var&gt; 인수 Fortran 2003 이상</target>
        </trans-unit>
        <trans-unit id="ae9013e97816898f809221ee28bd8df9c13ae6a9" translate="yes" xml:space="preserve">
          <source>Fortran 77 and later, with &lt;var&gt;KIND&lt;/var&gt; argument Fortran 90 and later</source>
          <target state="translated">Fortran 77 이상, &lt;var&gt;KIND&lt;/var&gt; 인수 Fortran 90 이상</target>
        </trans-unit>
        <trans-unit id="9d1a390a6227549bd15a3d74d47103ceed783f7a" translate="yes" xml:space="preserve">
          <source>Fortran 90 and later</source>
          <target state="translated">포트란 90 이상</target>
        </trans-unit>
        <trans-unit id="f28b6433b672ab4087d5c1052ae2b048f775e07d" translate="yes" xml:space="preserve">
          <source>Fortran 95 and later</source>
          <target state="translated">포트란 95 이상</target>
        </trans-unit>
        <trans-unit id="258b2e407dd7e5f9bbd42c55b1b282b6655a94bc" translate="yes" xml:space="preserve">
          <source>Fortran 95 and later, for a complex argument Fortran 2008 or later</source>
          <target state="translated">Fortran 95 이상, 복잡한 인수 Fortran 2008 이상</target>
        </trans-unit>
        <trans-unit id="88e83054bc9dcae86855ef30adb36bbab2552b43" translate="yes" xml:space="preserve">
          <source>Fortran 95 and later, has overloads that are GNU extensions</source>
          <target state="translated">Fortran 95 이상에는 GNU 확장 인 과부하가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7082ed796134462f215c555635c4e20555039118" translate="yes" xml:space="preserve">
          <source>Fortran 95 and later, with &lt;code&gt;RADIX&lt;/code&gt; Fortran 2008 or later</source>
          <target state="translated">&lt;code&gt;RADIX&lt;/code&gt; Fortran 2008 이상 이 설치된 Fortran 95 이상</target>
        </trans-unit>
        <trans-unit id="0768f019ed4d414b08efc2f301588a33f55b93d6" translate="yes" xml:space="preserve">
          <source>Fortran 95 and later, with &lt;var&gt;KIND&lt;/var&gt; argument Fortran 2003 and later</source>
          <target state="translated">Fortran 95 이상, &lt;var&gt;KIND&lt;/var&gt; 인수 Fortran 2003 이상</target>
        </trans-unit>
        <trans-unit id="879bb704bc2f86505f3e0631f4b58fc10950abc3" translate="yes" xml:space="preserve">
          <source>Fortran 95 and later. Note, the &lt;code&gt;SCALAR=&lt;/code&gt; keyword and allocatable scalar entities are available in Fortran 2003 and later.</source>
          <target state="translated">포트란 95 이상. 참고 &lt;code&gt;SCALAR=&lt;/code&gt; 키워드 및 할당 가능한 스칼라 기관은 포트란 2003 이상에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5d8df09e78a1084c33c7aac6193603864a17f71" translate="yes" xml:space="preserve">
          <source>Fortran 95 elemental function: &lt;a href=&quot;iand#IAND&quot;&gt;IAND&lt;/a&gt;</source>
          <target state="translated">포트란 95 원소 함수 : &lt;a href=&quot;iand#IAND&quot;&gt;IAND&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6368675714d27fbb9b56e26657d5b94a105b6e3f" translate="yes" xml:space="preserve">
          <source>Fortran 95 elemental function: &lt;a href=&quot;ieor#IEOR&quot;&gt;IEOR&lt;/a&gt;</source>
          <target state="translated">포트란 95 원소 함수 : &lt;a href=&quot;ieor#IEOR&quot;&gt;IEOR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="993f62b2d6ca12ac307616884e8ad713156de516" translate="yes" xml:space="preserve">
          <source>Fortran 95 elemental function: &lt;a href=&quot;ior#IOR&quot;&gt;IOR&lt;/a&gt;</source>
          <target state="translated">포트란 95 원소 함수 : &lt;a href=&quot;ior#IOR&quot;&gt;IOR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="42d778535505f2ef38eff025c01584470ad683bb" translate="yes" xml:space="preserve">
          <source>Fortran Language Options</source>
          <target state="translated">포트란 언어 옵션</target>
        </trans-unit>
        <trans-unit id="1d64a65cb92d6acfa4f3277db10770db00729a5f" translate="yes" xml:space="preserve">
          <source>Fortran Type</source>
          <target state="translated">포트란 유형</target>
        </trans-unit>
        <trans-unit id="442fd3f199ddd4f07bbf54f773b0e1c5ed9e8c43" translate="yes" xml:space="preserve">
          <source>Fractional part of the model representation</source>
          <target state="translated">모형 표현의 분수 부분</target>
        </trans-unit>
        <trans-unit id="21dabba56632079279a35d6666164c2072f09efc" translate="yes" xml:space="preserve">
          <source>Frees memory previously allocated by &lt;code&gt;MALLOC&lt;/code&gt;. The &lt;code&gt;FREE&lt;/code&gt; intrinsic is an extension intended to be used with Cray pointers, and is provided in GNU Fortran to allow user to compile legacy code. For new code using Fortran 95 pointers, the memory de-allocation intrinsic is &lt;code&gt;DEALLOCATE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MALLOC&lt;/code&gt; 에 의해 이전에 할당 된 메모리를 해제 합니다. &lt;code&gt;FREE&lt;/code&gt; 내장 함수는 확장 크레이 포인터로 사용하기위한, 그리고 컴파일 레거시 코드에 대한 사용자를 허용하는 GNU 포트란에 제공됩니다. Fortran 95 포인터를 사용하는 새 코드의 경우 메모리 할당 해제 고유는 &lt;code&gt;DEALLOCATE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="a323d397468d0292cd859b40e6885c1536825738" translate="yes" xml:space="preserve">
          <source>Function that returns an disassociated pointer</source>
          <target state="translated">분리 된 포인터를 반환하는 함수</target>
        </trans-unit>
        <trans-unit id="932cd43f239d13a2c65179e9e19e3285e9b79863" translate="yes" xml:space="preserve">
          <source>Function to determine the size of an array</source>
          <target state="translated">배열의 크기를 결정하는 함수</target>
        </trans-unit>
        <trans-unit id="fbc95357a0bb0e0f7999bf3d35f4957175759774" translate="yes" xml:space="preserve">
          <source>Function to get the last system error number</source>
          <target state="translated">마지막 시스템 오류 번호를 얻는 기능</target>
        </trans-unit>
        <trans-unit id="e253e93cbdfe85e94c0d10667a1052e9a8283e0c" translate="yes" xml:space="preserve">
          <source>Function to reshape an array</source>
          <target state="translated">배열을 재구성하는 기능</target>
        </trans-unit>
        <trans-unit id="940bd249ac05dca12ac5b392fbddd7c23a8edf32" translate="yes" xml:space="preserve">
          <source>Functionally, this is implemented with a driver program (&lt;code&gt;gcc&lt;/code&gt;) which provides the command-line interface for the compiler. It calls the relevant compiler front-end program (e.g., &lt;code&gt;f951&lt;/code&gt; for Fortran) for each file in the source code, and then calls the assembler and linker as appropriate to produce the compiled output. In a copy of GCC which has been compiled with Fortran language support enabled, &lt;code&gt;gcc&lt;/code&gt; will recognize files with</source>
          <target state="translated">기능적으로, 이것은 컴파일러를위한 명령 행 인터페이스를 제공 하는 드라이버 프로그램 ( &lt;code&gt;gcc&lt;/code&gt; )으로 구현됩니다 . 소스 코드의 각 파일에 대해 관련 컴파일러 프론트 엔드 프로그램 (예 : Fortran의 경우 &lt;code&gt;f951&lt;/code&gt; )을 호출 한 다음 컴파일 된 출력을 생성하기 위해 어셈블러 및 링커를 호출합니다. 포트란 언어 지원을 사용하도록 컴파일 된 GCC 사본에서 &lt;code&gt;gcc&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="9dcfc60614436d1a4ee53a29e9a404d17b3d2cd8" translate="yes" xml:space="preserve">
          <source>Functions with identical argument lists are eliminated within statements, regardless of whether these functions are marked &lt;code&gt;PURE&lt;/code&gt; or not. For example, in</source>
          <target state="translated">인수 목록이 동일한 함수는 이러한 함수가 &lt;code&gt;PURE&lt;/code&gt; 로 표시되는지 여부에 관계없이 명령문 내에서 제거됩니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="a77748cc250a919f08dac1cbb97eb54cbd2d36e9" translate="yes" xml:space="preserve">
          <source>Funding Free Software</source>
          <target state="translated">자금 조달 자유 소프트웨어</target>
        </trans-unit>
        <trans-unit id="66abd3c3ee5158c581855ea4c522e7242179740c" translate="yes" xml:space="preserve">
          <source>Furthermore, GNU Fortran allows using BOZ literal constants outside DATA statements and the four intrinsic functions allowed by Fortran 2003. In DATA statements, in direct assignments, where the right-hand side only contains a BOZ literal constant, and for old-style initializers of the form &lt;code&gt;integer i /o'0173'/&lt;/code&gt;, the constant is transferred as if &lt;code&gt;TRANSFER&lt;/code&gt; had been used; for &lt;code&gt;COMPLEX&lt;/code&gt; numbers, only the real part is initialized unless &lt;code&gt;CMPLX&lt;/code&gt; is used. In all other cases, the BOZ literal constant is converted to an &lt;code&gt;INTEGER&lt;/code&gt; value with the largest decimal representation. This value is then converted numerically to the type and kind of the variable in question. (For instance, &lt;code&gt;real :: r = b'0000001' + 1&lt;/code&gt; initializes &lt;code&gt;r&lt;/code&gt; with &lt;code&gt;2.0&lt;/code&gt;.) As different compilers implement the extension differently, one should be careful when doing bitwise initialization of non-integer variables.</source>
          <target state="translated">또한 GNU Fortran을 사용하면 DATA 문 외부에서 BOZ 리터럴 상수와 Fortran 2003에서 허용하는 4 가지 고유 함수를 사용할 수 있습니다. DATA 문에서 오른쪽에는 BOZ 리터럴 상수 만 포함 된 직접 할당 및 이전 스타일의 이니셜 라이저 &lt;code&gt;integer i /o'0173'/&lt;/code&gt; 형식으로 상수는 &lt;code&gt;TRANSFER&lt;/code&gt; 이 사용 된 것처럼 전송 됩니다. 대한 &lt;code&gt;COMPLEX&lt;/code&gt; 하지 않는 한 번호 만 실제 부분은 초기화 &lt;code&gt;CMPLX&lt;/code&gt; 가 사용됩니다. 다른 모든 경우에 BOZ 리터럴 상수는 가장 큰 10 진수 표시를 가진 &lt;code&gt;INTEGER&lt;/code&gt; 값으로 변환됩니다 . 그런 다음이 값은 해당 변수의 유형 및 종류로 숫자로 변환됩니다. (예를 들어, &lt;code&gt;real :: r = b'0000001' + 1&lt;/code&gt; &lt;code&gt;r&lt;/code&gt; 을 &lt;code&gt;2.0&lt;/code&gt; 으로 초기화합니다 .) 다른 컴파일러는 확장을 다르게 구현하므로 정수가 아닌 변수를 비트 단위로 초기화 할 때는주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="bbc57e1ff195fb60a4dc030079988a8caafdb6ef" translate="yes" xml:space="preserve">
          <source>GETCWD</source>
          <target state="translated">GETCWD</target>
        </trans-unit>
        <trans-unit id="bf64874bb6e6efb715db91b4688bc8d9b681e8a9" translate="yes" xml:space="preserve">
          <source>GETUID</source>
          <target state="translated">GETUID</target>
        </trans-unit>
        <trans-unit id="228c47fb16d6a0582ae98c80a744855f61262c0a" translate="yes" xml:space="preserve">
          <source>GET_ENVIRONMENT_VARIABLE</source>
          <target state="translated">GET_ENVIRONMENT_VARIABLE</target>
        </trans-unit>
        <trans-unit id="47589cef14436d9e5f4a4197810b9e1417f75b07" translate="yes" xml:space="preserve">
          <source>GNU Extension</source>
          <target state="translated">GNU 확장</target>
        </trans-unit>
        <trans-unit id="9d11a1402788dabb9b90460c67bf622c641fc435" translate="yes" xml:space="preserve">
          <source>GNU Extension, enabled with</source>
          <target state="translated">사용 가능한 GNU 확장</target>
        </trans-unit>
        <trans-unit id="b27d2a644db1110043e95237723e7b6fbb43d091" translate="yes" xml:space="preserve">
          <source>GNU Fortran</source>
          <target state="translated">GNU 포트란</target>
        </trans-unit>
        <trans-unit id="f9845869f9c3cabebff2ed011b38f05ca510b9b3" translate="yes" xml:space="preserve">
          <source>GNU Fortran 77 compatibility function: &lt;a href=&quot;iargc#IARGC&quot;&gt;IARGC&lt;/a&gt;</source>
          <target state="translated">GNU Fortran 77 호환성 기능 : &lt;a href=&quot;iargc#IARGC&quot;&gt;IARGC&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e98ebee3e38c9be3ca0bd13c101015227ed57bd" translate="yes" xml:space="preserve">
          <source>GNU Fortran 77 compatibility subroutine: &lt;a href=&quot;getarg#GETARG&quot;&gt;GETARG&lt;/a&gt;</source>
          <target state="translated">GNU Fortran 77 호환성 서브 루틴 : &lt;a href=&quot;getarg#GETARG&quot;&gt;GETARG&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d568bce829108a46f995220a9ab78d6b78677849" translate="yes" xml:space="preserve">
          <source>GNU Fortran accepts real literal constants with an exponent-letter of &lt;code&gt;Q&lt;/code&gt;, for example, &lt;code&gt;1.23Q45&lt;/code&gt;. The constant is interpreted as a &lt;code&gt;REAL(16)&lt;/code&gt; entity on targets that support this type. If the target does not support &lt;code&gt;REAL(16)&lt;/code&gt; but has a &lt;code&gt;REAL(10)&lt;/code&gt; type, then the real-literal-constant will be interpreted as a &lt;code&gt;REAL(10)&lt;/code&gt; entity. In the absence of &lt;code&gt;REAL(16)&lt;/code&gt; and &lt;code&gt;REAL(10)&lt;/code&gt;, an error will occur.</source>
          <target state="translated">GNU Fortran은 지수 문자 &lt;code&gt;Q&lt;/code&gt; 가 포함 된 실제 리터럴 상수 ( 예 : &lt;code&gt;1.23Q45&lt;/code&gt; )를 허용 합니다. 상수는 이 유형을 지원하는 대상 에서 &lt;code&gt;REAL(16)&lt;/code&gt; 엔티티 로 해석됩니다 . 대상이 지원하지 않는 경우 &lt;code&gt;REAL(16)&lt;/code&gt; 그러나이 &lt;code&gt;REAL(10)&lt;/code&gt; 유형을 다음 실시간 문자 상수는로 해석됩니다 &lt;code&gt;REAL(10)&lt;/code&gt; 엔티티. &lt;code&gt;REAL(16)&lt;/code&gt; 및 &lt;code&gt;REAL(10)&lt;/code&gt; 이 없으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8cc12fe6bf7d9a6f2e0f483a56e6b990f69ae76c" translate="yes" xml:space="preserve">
          <source>GNU Fortran allows old-style initialization of variables of the form:</source>
          <target state="translated">GNU Fortran은 다음과 같은 형식의 변수를 구식으로 초기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d62703b61697fd52fa89ea26be10f7ce06feb5b" translate="yes" xml:space="preserve">
          <source>GNU Fortran allows old-style kind specifications in declarations. These look like:</source>
          <target state="translated">GNU Fortran은 선언에서 구식 종류 사양을 허용합니다. 이것들은 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="f094672adc1332ad3930e3853cf12feb53281427" translate="yes" xml:space="preserve">
          <source>GNU Fortran allows the conversion of unformatted data between little- and big-endian representation to facilitate moving of data between different systems. The conversion can be indicated with the &lt;code&gt;CONVERT&lt;/code&gt; specifier on the &lt;code&gt;OPEN&lt;/code&gt; statement. See &lt;a href=&quot;gfortran_005fconvert_005funit#GFORTRAN_005fCONVERT_005fUNIT&quot;&gt;GFORTRAN_CONVERT_UNIT&lt;/a&gt;, for an alternative way of specifying the data format via an environment variable.</source>
          <target state="translated">GNU Fortran을 사용하면 형식이 지정되지 않은 데이터를 little-endian과 big-endian 표현간에 변환하여 다른 시스템간에 데이터를 쉽게 이동할 수 있습니다. 변환은 &lt;code&gt;OPEN&lt;/code&gt; 문 에 &lt;code&gt;CONVERT&lt;/code&gt; 지정자 로 표시 될 수 있습니다 . 환경 변수를 통해 데이터 형식을 지정하는 다른 방법은 &lt;a href=&quot;gfortran_005fconvert_005funit#GFORTRAN_005fCONVERT_005fUNIT&quot;&gt;GFORTRAN_CONVERT_UNIT를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6c64552c26182faee772ccec0f65d17f06acfa00" translate="yes" xml:space="preserve">
          <source>GNU Fortran also have a partial support for ISO/IEC 1539-1:2004 (Fortran 2003), ISO/IEC 1539-1:2010 (Fortran 2008), the Technical Specification &lt;code&gt;Further Interoperability of Fortran with C&lt;/code&gt; (ISO/IEC TS 29113:2012). Full support of those standards and future Fortran standards is planned. The current status of the support is can be found in the &lt;a href=&quot;fortran-2003-status#Fortran-2003-status&quot;&gt;Fortran 2003 status&lt;/a&gt;, &lt;a href=&quot;fortran-2008-status#Fortran-2008-status&quot;&gt;Fortran 2008 status&lt;/a&gt;, &lt;a href=&quot;ts-29113-status#TS-29113-status&quot;&gt;TS 29113 status&lt;/a&gt; and &lt;a href=&quot;ts-18508-status#TS-18508-status&quot;&gt;TS 18508 status&lt;/a&gt; sections of the documentation.</source>
          <target state="translated">GNU Fortran은 또한 ISO / IEC 1539-1 : 2004 (Fortran 2003), ISO / IEC 1539-1 : 2010 (Fortran 2008), &lt;code&gt;Further Interoperability of Fortran with C&lt;/code&gt; 기술 사양 (ISO / IEC TS 29113)을 부분적으로 지원합니다. 2012). 이러한 표준과 향후 포트란 표준에 대한 완벽한 지원이 계획되어 있습니다. 지원의 현재 상태는 설명서의 &lt;a href=&quot;fortran-2003-status#Fortran-2003-status&quot;&gt;Fortran 2003 상태&lt;/a&gt; , &lt;a href=&quot;fortran-2008-status#Fortran-2008-status&quot;&gt;Fortran 2008 상태&lt;/a&gt; , &lt;a href=&quot;ts-29113-status#TS-29113-status&quot;&gt;TS 29113 상태&lt;/a&gt; 및 &lt;a href=&quot;ts-18508-status#TS-18508-status&quot;&gt;TS 18508 상태&lt;/a&gt; 섹션에서 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8672e55f2e327a750569586e4e71cb4943f2bf7" translate="yes" xml:space="preserve">
          <source>GNU Fortran always uses an array descriptor, which does not match the one of the Technical Specification. The &lt;code&gt;ISO_Fortran_binding.h&lt;/code&gt; header file and the C functions it specifies are not available.</source>
          <target state="translated">GNU Fortran은 항상 배열 설명자를 사용하며, 이는 기술 사양 중 하나와 일치하지 않습니다. &lt;code&gt;ISO_Fortran_binding.h&lt;/code&gt; 의 헤더 파일과 C의 기능이 지정을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9ecddba3cc14c0996ac91825bf94c8f6b35e3904" translate="yes" xml:space="preserve">
          <source>GNU Fortran can be used in programs with multiple threads, e.g. by using OpenMP, by calling OS thread handling functions via the &lt;code&gt;ISO_C_BINDING&lt;/code&gt; facility, or by GNU Fortran compiled library code being called from a multi-threaded program.</source>
          <target state="translated">GNU Fortran은 &lt;code&gt;ISO_C_BINDING&lt;/code&gt; 기능을 통해 OS 스레드 처리 기능을 호출 하거나 다중 스레드 프로그램에서 호출 된 GNU Fortran 컴파일 된 라이브러리 코드 와 같이 OpenMP를 사용하여 다중 스레드가있는 프로그램에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="447467fdc3f175bcd86b8693e7201ee8f541a067" translate="yes" xml:space="preserve">
          <source>GNU Fortran does not support the &lt;code&gt;ENCODE&lt;/code&gt; and &lt;code&gt;DECODE&lt;/code&gt; statements. These statements are best replaced by &lt;code&gt;READ&lt;/code&gt; and &lt;code&gt;WRITE&lt;/code&gt; statements involving internal files (&lt;code&gt;CHARACTER&lt;/code&gt; variables and arrays), which have been part of the Fortran standard since Fortran 77. For example, replace a code fragment like</source>
          <target state="translated">GNU Fortran은 &lt;code&gt;ENCODE&lt;/code&gt; 및 &lt;code&gt;DECODE&lt;/code&gt; 문을 지원하지 않습니다 . 이러한 명령문은 Fortran 77 이후 Fortran 표준의 일부인 내부 파일 ( &lt;code&gt;CHARACTER&lt;/code&gt; 변수 및 배열)을 포함하는 &lt;code&gt;READ&lt;/code&gt; 및 &lt;code&gt;WRITE&lt;/code&gt; 문으로 대체하는 것이 가장 좋습니다. 예를 들어 다음과 같은 코드 단편을 대체하십시오.</target>
        </trans-unit>
        <trans-unit id="ccc03f51d2cc4d7f4f3f38601b8099e2f6d00a56" translate="yes" xml:space="preserve">
          <source>GNU Fortran fully supports the Fortran 95 standard for namelist I/O including array qualifiers, substrings and fully qualified derived types. The output from a namelist write is compatible with namelist read. The output has all names in upper case and indentation to column 1 after the namelist name. Two extensions are permitted:</source>
          <target state="translated">GNU Fortran은 배열 한정자, 부분 문자열 및 정규화 된 파생 형식을 포함하여 이름 목록 I / O에 대한 Fortran 95 표준을 완벽하게 지원합니다. 이름 목록 쓰기의 출력은 이름 목록 읽기와 호환됩니다. 출력은 모든 이름을 대문자로하고 이름 목록 이름 다음에 열 1을 들여 씁니다. 두 가지 확장이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="f548b7cd5e7e4d16ae60e93714613f0e3e130ad5" translate="yes" xml:space="preserve">
          <source>GNU Fortran has various special options that are used for debugging either your program or the GNU Fortran compiler.</source>
          <target state="translated">GNU Fortran에는 프로그램이나 GNU Fortran 컴파일러를 디버깅하는 데 사용되는 다양한 특수 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="47ad0c9eac11dcb2cdb893f6385f732a10b1853c" translate="yes" xml:space="preserve">
          <source>GNU Fortran implements STRUCTURES like derived types with the following rules and exceptions:</source>
          <target state="translated">GNU Fortran은 파생 규칙과 같은 구조를 다음 규칙과 예외로 구현합니다.</target>
        </trans-unit>
        <trans-unit id="625d543534791964fe1574ff68c00c154f782cb1" translate="yes" xml:space="preserve">
          <source>GNU Fortran implements a number of extensions over standard Fortran. This chapter contains information on their syntax and meaning. There are currently two categories of GNU Fortran extensions, those that provide functionality beyond that provided by any standard, and those that are supported by GNU Fortran purely for backward compatibility with legacy compilers. By default,</source>
          <target state="translated">GNU Fortran은 표준 Fortran보다 많은 확장을 구현합니다. 이 장에는 구문과 의미에 대한 정보가 포함되어 있습니다. 현재 두 가지 범주의 GNU Fortran 확장이 있으며, 표준에서 제공하는 것 이상의 기능을 제공하는 범주와 레거시 컴파일러와의 호환성을 위해 GNU Fortran에서 지원하는 범주가 있습니다. 기본적으로,</target>
        </trans-unit>
        <trans-unit id="f8ea9f382015a621de25c15b1f5c1e121bc69316" translate="yes" xml:space="preserve">
          <source>GNU Fortran is a part of GCC, the &lt;em&gt;GNU Compiler Collection&lt;/em&gt;. GCC consists of a collection of front ends for various languages, which translate the source code into a language-independent form called &lt;em&gt;GENERIC&lt;/em&gt;. This is then processed by a common middle end which provides optimization, and then passed to one of a collection of back ends which generate code for different computer architectures and operating systems.</source>
          <target state="translated">GNU Fortran은 GCC의 일부인 &lt;em&gt;GNU Compiler Collection&lt;/em&gt; 입니다. GCC는 다양한 언어에 대한 프런트 엔드 모음으로 구성되어 소스 코드를 &lt;em&gt;GENERIC&lt;/em&gt; 이라는 언어 독립적 형식으로 변환합니다 . 그런 다음 최적화를 제공하는 공통 중간 끝점에 의해 처리 된 다음 다른 컴퓨터 아키텍처 및 운영 체제에 대한 코드를 생성하는 백엔드 모음 중 하나로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="77fc15f7464b2307f13e0309e5d109ebdfb7903c" translate="yes" xml:space="preserve">
          <source>GNU Fortran offers the</source>
          <target state="translated">GNU 포트란은</target>
        </trans-unit>
        <trans-unit id="4b8131fce7ae118f5293b7d5ffffe8f39cc935c5" translate="yes" xml:space="preserve">
          <source>GNU Fortran passes most arguments by reference, i.e. by passing a pointer to the data. Note that the compiler might use a temporary variable into which the actual argument has been copied, if required semantically (copy-in/copy-out).</source>
          <target state="translated">GNU Fortran은 대부분의 인수를 참조, 즉 데이터에 포인터를 전달하여 전달합니다. 컴파일러는 의미 상 필요한 경우 (사본 복사 / 복사) 실제 인수가 복사 된 임시 변수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed55c7647592d8224c021fbc2513a8f43d1a33b4" translate="yes" xml:space="preserve">
          <source>GNU Fortran strives to be compatible to the &lt;a href=&quot;http://openmp.org/wp/openmp-specifications/&quot;&gt;OpenMP Application Program Interface v4.5&lt;/a&gt;.</source>
          <target state="translated">GNU Fortran은 &lt;a href=&quot;http://openmp.org/wp/openmp-specifications/&quot;&gt;OpenMP Application Program Interface v4.5&lt;/a&gt; 와 호환되도록 노력하고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="79d35f17a63cfd65b1bd1868405b806d5f1015b1" translate="yes" xml:space="preserve">
          <source>GNU Fortran strives to be compatible to the &lt;a href=&quot;http://www.openacc.org/&quot;&gt;OpenACC Application Programming Interface v2.0&lt;/a&gt;.</source>
          <target state="translated">GNU Fortran은 &lt;a href=&quot;http://www.openacc.org/&quot;&gt;OpenACC Application Programming Interface v2.0&lt;/a&gt; 과 호환되도록 노력하고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a09f1c576de44f06637c60cacd25debe5f9c37d" translate="yes" xml:space="preserve">
          <source>GNU Fortran supports &lt;code&gt;.XOR.&lt;/code&gt; as a logical operator with &lt;code&gt;-std=legacy&lt;/code&gt; for compatibility with legacy code. &lt;code&gt;.XOR.&lt;/code&gt; is equivalent to &lt;code&gt;.NEQV.&lt;/code&gt;. That is, the output is true if and only if the inputs differ.</source>
          <target state="translated">GNU Fortran은 &lt;code&gt;.XOR.&lt;/code&gt; 지원합니다 . 레거시 코드와의 호환성을 위해 &lt;code&gt;-std=legacy&lt;/code&gt; 를 가진 논리 연산자로 사용 됩니다. &lt;code&gt;.XOR.&lt;/code&gt; &lt;code&gt;.NEQV.&lt;/code&gt; 와 같습니다 . . 즉, 입력이 다른 경우에만 출력이 참입니다.</target>
        </trans-unit>
        <trans-unit id="4a00a34c938a2bbcbad18bafd9df71d187c8e3cd" translate="yes" xml:space="preserve">
          <source>GNU Fortran supports Hollerith constants in assignments, function arguments, and &lt;code&gt;DATA&lt;/code&gt; and &lt;code&gt;ASSIGN&lt;/code&gt; statements. A Hollerith constant is written as a string of characters preceded by an integer constant indicating the character count, and the letter &lt;code&gt;H&lt;/code&gt; or &lt;code&gt;h&lt;/code&gt;, and stored in bytewise fashion in a numeric (&lt;code&gt;INTEGER&lt;/code&gt;, &lt;code&gt;REAL&lt;/code&gt;, or &lt;code&gt;complex&lt;/code&gt;) or &lt;code&gt;LOGICAL&lt;/code&gt; variable. The constant will be padded or truncated to fit the size of the variable in which it is stored.</source>
          <target state="translated">GNU Fortran은 할당, 함수 인수, &lt;code&gt;DATA&lt;/code&gt; 및 &lt;code&gt;ASSIGN&lt;/code&gt; 문 에서 Hollerith 상수를 지원 합니다. Hollerith 상수는 문자 수와 문자 &lt;code&gt;H&lt;/code&gt; 또는 &lt;code&gt;h&lt;/code&gt; 를 나타내는 정수 상수가 앞에 오는 문자열로 작성되며 숫자 ( &lt;code&gt;INTEGER&lt;/code&gt; , &lt;code&gt;REAL&lt;/code&gt; 또는 &lt;code&gt;complex&lt;/code&gt; ) 또는 &lt;code&gt;LOGICAL&lt;/code&gt; 변수에 바이트 단위로 저장됩니다. 상수는 저장된 변수의 크기에 맞게 채워지거나 잘립니다.</target>
        </trans-unit>
        <trans-unit id="7704e6ebcc55f94b909980a2c64854ef85e852d7" translate="yes" xml:space="preserve">
          <source>GNU Fortran supports an extended list of mathematical intrinsics with the compile flag</source>
          <target state="translated">GNU Fortran은 compile 플래그를 사용하여 확장 된 수학 내장 함수 목록을 지원합니다</target>
        </trans-unit>
        <trans-unit id="dd7c20c1d7193db3330e2d961f55f93e67fbd664" translate="yes" xml:space="preserve">
          <source>GNU Fortran supports argument list functions &lt;code&gt;%VAL&lt;/code&gt;, &lt;code&gt;%REF&lt;/code&gt; and &lt;code&gt;%LOC&lt;/code&gt; statements, for backward compatibility with g77. It is recommended that these should be used only for code that is accessing facilities outside of GNU Fortran, such as operating system or windowing facilities. It is best to constrain such uses to isolated portions of a program&amp;ndash;portions that deal specifically and exclusively with low-level, system-dependent facilities. Such portions might well provide a portable interface for use by the program as a whole, but are themselves not portable, and should be thoroughly tested each time they are rebuilt using a new compiler or version of a compiler.</source>
          <target state="translated">GNU Fortran은 g77과의 역 호환성을 위해 인수 목록 함수 &lt;code&gt;%VAL&lt;/code&gt; , &lt;code&gt;%REF&lt;/code&gt; 및 &lt;code&gt;%LOC&lt;/code&gt; 문을 지원합니다. 운영 체제 또는 윈도우 기능과 같이 GNU Fortran 외부의 기능에 액세스하는 코드에만 사용하는 것이 좋습니다. 저수준의 시스템 종속적 시설을 구체적으로 배타적으로 다루는 프로그램 부분의 격리 된 부분으로 그러한 용도를 제한하는 것이 가장 좋습니다. 이러한 부분은 프로그램 전체에서 사용할 수있는 이식 가능한 인터페이스를 제공 할 수 있지만 이식성이 없으며 새로운 컴파일러 또는 컴파일러 버전을 사용하여 다시 빌드 할 때마다 철저히 테스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="445dfaa7f5081a7d47ac9e4767ab6be58c462303" translate="yes" xml:space="preserve">
          <source>GNU Fortran supports several Fortran 2003 features; an incomplete list can be found below. See also the &lt;a href=&quot;https://gcc.gnu.org/wiki/Fortran2003&quot;&gt;wiki page&lt;/a&gt; about Fortran 2003.</source>
          <target state="translated">GNU Fortran은 몇 가지 Fortran 2003 기능을 지원합니다. 불완전한 목록은 아래에서 찾을 수 있습니다. Fortran 2003에 대한 &lt;a href=&quot;https://gcc.gnu.org/wiki/Fortran2003&quot;&gt;위키 페이지&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0bdb89bc801212ecb67aea6afa195b4cbb5bd86a" translate="yes" xml:space="preserve">
          <source>GNU Fortran supports some of the new features of the Technical Specification (TS) 29113 on Further Interoperability of Fortran with C. The &lt;a href=&quot;https://gcc.gnu.org/wiki/TS29113Status&quot;&gt;wiki&lt;/a&gt; has some information about the current TS 29113 implementation status. In particular, the following is implemented.</source>
          <target state="translated">GNU Fortran은 Fortran과 C의 추가 상호 운용성에 관한 기술 사양 (TS) 29113의 새로운 기능 중 일부를 지원합니다. &lt;a href=&quot;https://gcc.gnu.org/wiki/TS29113Status&quot;&gt;위키&lt;/a&gt; 에는 현재 TS 29113 구현 상태에 대한 정보가 있습니다. 특히, 다음이 구현된다.</target>
        </trans-unit>
        <trans-unit id="3168af2f2d39be058f856f9c3724ece621648ace" translate="yes" xml:space="preserve">
          <source>GNU Fortran supports the DEC extended attributes &lt;code&gt;STATIC&lt;/code&gt; and &lt;code&gt;AUTOMATIC&lt;/code&gt; to provide explicit specification of entity storage. These follow the syntax of the Fortran standard &lt;code&gt;SAVE&lt;/code&gt; attribute.</source>
          <target state="translated">GNU Fortran은 DEC 확장 속성 &lt;code&gt;STATIC&lt;/code&gt; 및 &lt;code&gt;AUTOMATIC&lt;/code&gt; 을 지원하여 엔터티 저장소의 명시 적 사양을 제공합니다. 이들은 Fortran 표준 &lt;code&gt;SAVE&lt;/code&gt; 속성 의 구문을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="91ad3f0b4de8a83590fb2963cdae8d47a1099527" translate="yes" xml:space="preserve">
          <source>GNU Fortran supports the additional legacy I/O specifiers &lt;code&gt;CARRIAGECONTROL&lt;/code&gt;, &lt;code&gt;READONLY&lt;/code&gt;, and &lt;code&gt;SHARE&lt;/code&gt; with the compile flag</source>
          <target state="translated">GNU Fortran은 추가 레거시 I / O 지정자 &lt;code&gt;CARRIAGECONTROL&lt;/code&gt; , &lt;code&gt;READONLY&lt;/code&gt; 및 &lt;code&gt;SHARE&lt;/code&gt; 를 컴파일 플래그와 함께 지원합니다.</target>
        </trans-unit>
        <trans-unit id="58ddecfb39e88b81e89a51a582f2009a784a242f" translate="yes" xml:space="preserve">
          <source>GNU Fortran supports the following new features of the Technical Specification 18508 on Additional Parallel Features in Fortran:</source>
          <target state="translated">GNU Fortran은 Fortran의 추가 병렬 기능에 관한 기술 사양 18508의 다음과 같은 새로운 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="510cb0ea38009fead4207419120896cc9148954a" translate="yes" xml:space="preserve">
          <source>GNU Fortran supports these with the flag</source>
          <target state="translated">GNU Fortran은 이러한 플래그를 지원합니다</target>
        </trans-unit>
        <trans-unit id="43455e30bbbf4ab44a09434cda7dec6248d9c9a1" translate="yes" xml:space="preserve">
          <source>GNU Fortran&amp;rsquo;s implementation for variables with &lt;code&gt;ASYNCHRONOUS&lt;/code&gt; attribute is compatible with TS 29113.</source>
          <target state="translated">&lt;code&gt;ASYNCHRONOUS&lt;/code&gt; 속성을 가진 변수에 대한 GNU Fortran의 구현은 TS 29113과 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="0e4ec8a54cfff9c2845fa38842cb6cd1bdea197d" translate="yes" xml:space="preserve">
          <source>GNU Free Documentation License</source>
          <target state="translated">GNU 자유 문서 라이센스</target>
        </trans-unit>
        <trans-unit id="d9cbf0740e34d88c506fb7df6e17deeabd18660c" translate="yes" xml:space="preserve">
          <source>GNU General Public License</source>
          <target state="translated">GNU 일반 공중 사용 허가서</target>
        </trans-unit>
        <trans-unit id="72b0f7603350332026276f6acb46731114869aa9" translate="yes" xml:space="preserve">
          <source>GNU General Public License says how you can copy and share GNU Fortran.</source>
          <target state="translated">GNU General Public License는 GNU Fortran을 복사하고 공유하는 방법을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="e956d8af4614cc6d3e84a8a4627ea068fea673f9" translate="yes" xml:space="preserve">
          <source>GNU extension</source>
          <target state="translated">GNU 확장</target>
        </trans-unit>
        <trans-unit id="41bd17b399fc645999b1f94c3ff8b57752ca8b82" translate="yes" xml:space="preserve">
          <source>GNU extension.</source>
          <target state="translated">GNU 확장.</target>
        </trans-unit>
        <trans-unit id="0675e5ed2feb2a82988689be9b86b2c468fe17e1" translate="yes" xml:space="preserve">
          <source>Gamma function</source>
          <target state="translated">감마 기능</target>
        </trans-unit>
        <trans-unit id="34471dede732d687ac24eb5a1593778ba0b06069" translate="yes" xml:space="preserve">
          <source>Gamma function: &lt;a href=&quot;gamma#GAMMA&quot;&gt;GAMMA&lt;/a&gt;</source>
          <target state="translated">감마 기능 : &lt;a href=&quot;gamma#GAMMA&quot;&gt;GAMMA&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c8ca638b3696cdddd24bcd0056cafc900c7a7184" translate="yes" xml:space="preserve">
          <source>Gathering nonzero elements from an array and appending elements from &lt;var&gt;VECTOR&lt;/var&gt;:</source>
          <target state="translated">배열에서 0이 아닌 요소를 수집하고 &lt;var&gt;VECTOR&lt;/var&gt; 에서 요소를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="0a5135b58dd78ae6468fc9736ab8d345870bb9b3" translate="yes" xml:space="preserve">
          <source>Gathering nonzero elements from an array:</source>
          <target state="translated">배열에서 0이 아닌 요소 수집</target>
        </trans-unit>
        <trans-unit id="b5d810154138e075635771eb8f7059d14e72c59e" translate="yes" xml:space="preserve">
          <source>Generate code designed to be compatible with code generated by &lt;code&gt;g77&lt;/code&gt; and &lt;code&gt;f2c&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;g77&lt;/code&gt; 및 &lt;code&gt;f2c&lt;/code&gt; 에 의해 생성 된 코드와 호환되도록 설계된 코드를 생성하십시오 .</target>
        </trans-unit>
        <trans-unit id="919793fa37b98b0bf85804270264af9dd0ca28c3" translate="yes" xml:space="preserve">
          <source>Generic collective reduction</source>
          <target state="translated">일반적인 집단 감소</target>
        </trans-unit>
        <trans-unit id="049f7061c4e993da9c1f4fe97f0420d1f9690d12" translate="yes" xml:space="preserve">
          <source>Generic interface names, which have the same name as derived types, are now supported. This allows one to write constructor functions. Note that Fortran does not support static constructor functions. For static variables, only default initialization or structure-constructor initialization are available.</source>
          <target state="translated">파생 유형과 이름이 같은 일반 인터페이스 이름이 지원됩니다. 이를 통해 생성자 함수를 작성할 수 있습니다. Fortran은 정적 생성자 함수를 지원하지 않습니다. 정적 변수의 경우 기본 초기화 또는 구조 생성자 초기화 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27c46583e30309be203aa42f9d60abc74e5c3a95" translate="yes" xml:space="preserve">
          <source>Get an array of image indexes in the current &lt;var&gt;team&lt;/var&gt; that have failed. The array is sorted ascendingly. When &lt;var&gt;team&lt;/var&gt; is not provided the current team is to be used. When &lt;var&gt;kind&lt;/var&gt; is provided then the resulting array is of that integer kind else it is of default integer kind. The returns an unallocated size zero array when no images have failed.</source>
          <target state="translated">현재 &lt;var&gt;team&lt;/var&gt; 에서 실패한 이미지 인덱스 배열을 가져옵니다 . 배열이 오름차순으로 정렬됩니다. 때 &lt;var&gt;team&lt;/var&gt; 현재 팀이 제공되지 사용됩니다. 때 &lt;var&gt;kind&lt;/var&gt; 후 제공되는 결과 배열은 기본 정수 종류입니다 종류의 다른 그 정수이다. 실패한 이미지가 없을 때 할당되지 않은 크기의 0 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8750de70663bd94e3d7b799db532b0584c0a8e9e" translate="yes" xml:space="preserve">
          <source>Get an array of image indexes in the current &lt;var&gt;team&lt;/var&gt; that have stopped. The array is sorted ascendingly. When &lt;var&gt;team&lt;/var&gt; is not provided the current team is to be used. When &lt;var&gt;kind&lt;/var&gt; is provided then the resulting array is of that integer kind else it is of default integer kind. The returns an unallocated size zero array when no images have failed.</source>
          <target state="translated">현재 &lt;var&gt;team&lt;/var&gt; 에서 중지 된 이미지 인덱스 배열을 가져옵니다 . 배열이 오름차순으로 정렬됩니다. 때 &lt;var&gt;team&lt;/var&gt; 현재 팀이 제공되지 사용됩니다. 때 &lt;var&gt;kind&lt;/var&gt; 후 제공되는 결과 배열은 기본 정수 종류입니다 종류의 다른 그 정수이다. 실패한 이미지가 없을 때 할당되지 않은 크기의 0 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2aba41e9e2d4dc2b01fd8f259d8d59e7588bd504" translate="yes" xml:space="preserve">
          <source>Get an array of the indexes of the failed images</source>
          <target state="translated">실패한 이미지의 인덱스 배열을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ff3a5c1d18d8f587bdaaeacf0112eaf3065976b2" translate="yes" xml:space="preserve">
          <source>Get an array of the indexes of the stopped images</source>
          <target state="translated">중지 된 이미지의 인덱스 배열을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2bf3e201cf5f496679370a9612a717071221a5ea" translate="yes" xml:space="preserve">
          <source>Get an environmental variable</source>
          <target state="translated">환경 변수 얻기</target>
        </trans-unit>
        <trans-unit id="040140e3262d3a58f7a7816e8b40d028cdf4b91e" translate="yes" xml:space="preserve">
          <source>Get command line arguments</source>
          <target state="translated">명령 행 인수 가져 오기</target>
        </trans-unit>
        <trans-unit id="e8fb6b95e25f0305e85b02a0b01da7f4304ed68e" translate="yes" xml:space="preserve">
          <source>Get current working directory</source>
          <target state="translated">현재 작업 디렉토리 가져 오기</target>
        </trans-unit>
        <trans-unit id="42574d8ecb0db8a42c325bacc92304e852efada4" translate="yes" xml:space="preserve">
          <source>Get current working directory.</source>
          <target state="translated">현재 작업 디렉토리를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="95e14bdbc1bc3ce95d306dbd99a979d905ef8ea9" translate="yes" xml:space="preserve">
          <source>Get file status</source>
          <target state="translated">파일 상태 가져 오기</target>
        </trans-unit>
        <trans-unit id="dc1d731fd9e505246dfb70199010e7041b7bb29f" translate="yes" xml:space="preserve">
          <source>Get last system error message</source>
          <target state="translated">마지막 시스템 오류 메시지 받기</target>
        </trans-unit>
        <trans-unit id="426b193448e23996e8cb561f7b073e50373d9b40" translate="yes" xml:space="preserve">
          <source>Get login name</source>
          <target state="translated">로그인 이름 얻기</target>
        </trans-unit>
        <trans-unit id="a0d458e1bda2a42de2b2389b3f9a2fde65b8ee3b" translate="yes" xml:space="preserve">
          <source>Get number of command line arguments</source>
          <target state="translated">명령 줄 인수 수 얻기</target>
        </trans-unit>
        <trans-unit id="731831bafacd4df8009b2d1ecf1592fc81d2452c" translate="yes" xml:space="preserve">
          <source>Get system host name</source>
          <target state="translated">시스템 호스트 이름 얻기</target>
        </trans-unit>
        <trans-unit id="35c3baf37e095ff5f289ce5cb4250d099027c523" translate="yes" xml:space="preserve">
          <source>Get the &lt;var&gt;VALUE&lt;/var&gt; of the environmental variable &lt;var&gt;NAME&lt;/var&gt;.</source>
          <target state="translated">환경 변수 &lt;var&gt;NAME&lt;/var&gt; 의 &lt;var&gt;VALUE&lt;/var&gt; 을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="d211d75913429dcca3ee9dda5d278613a926b645" translate="yes" xml:space="preserve">
          <source>Get the entire command line</source>
          <target state="translated">전체 명령 행 가져 오기</target>
        </trans-unit>
        <trans-unit id="b60ec21d43c83cef00ee69748350825a081d49de" translate="yes" xml:space="preserve">
          <source>Get the name of a terminal device.</source>
          <target state="translated">터미널 장치의 이름을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="31b5607f73a87eb8e22876547cdaf23f6cc64b10" translate="yes" xml:space="preserve">
          <source>Get the name of a terminal device. For more information, see &lt;code&gt;ttyname(3)&lt;/code&gt;.</source>
          <target state="translated">터미널 장치의 이름을 가져옵니다. 자세한 내용은 &lt;code&gt;ttyname(3)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="32f6da6e7b7c6b5a48dfec5d5348c836c99f6ff5" translate="yes" xml:space="preserve">
          <source>Get the number of command line arguments</source>
          <target state="translated">명령 줄 인수의 개수를 얻습니다</target>
        </trans-unit>
        <trans-unit id="e993de4d1e7f30efea14e1469f08dfa2609ca383" translate="yes" xml:space="preserve">
          <source>Get the status of the image given by the id &lt;var&gt;image&lt;/var&gt; of the team given by &lt;var&gt;team&lt;/var&gt;. Valid results are zero, for image is ok, &lt;code&gt;STAT_STOPPED_IMAGE&lt;/code&gt; from the ISO_FORTRAN_ENV module to indicate that the image has been stopped and &lt;code&gt;STAT_FAILED_IMAGE&lt;/code&gt; also from ISO_FORTRAN_ENV to indicate that the image has executed a &lt;code&gt;FAIL IMAGE&lt;/code&gt; statement.</source>
          <target state="translated">team이 제공 한 &lt;var&gt;team&lt;/var&gt; 의 id &lt;var&gt;image&lt;/var&gt; 가 제공 한 이미지의 상태를 가져옵니다 . 유효한 결과 이미지 괜찮 들어 제로인 &lt;code&gt;STAT_STOPPED_IMAGE&lt;/code&gt; ISO_FORTRAN_ENV 모듈로부터 이미지가 정지되었음을 표시하고 &lt;code&gt;STAT_FAILED_IMAGE&lt;/code&gt; 은 또한 ISO_FORTRAN_ENV에서 이미지가 실행되었음을 나타내도록 &lt;code&gt;FAIL IMAGE&lt;/code&gt; 문.</target>
        </trans-unit>
        <trans-unit id="2a6bd4493abe9cc5b5ba4108db64b55b16fbd63f" translate="yes" xml:space="preserve">
          <source>Gets the username under which the program is running.</source>
          <target state="translated">프로그램이 실행중인 사용자 이름을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="3102bb9594e0ff6e8e038a8c1964a5c333458a56" translate="yes" xml:space="preserve">
          <source>Getting data from a remote image</source>
          <target state="translated">원격 이미지에서 데이터 가져 오기</target>
        </trans-unit>
        <trans-unit id="240ac964653bcfaab04e5fd3ec363ee0bf2af2f0" translate="yes" xml:space="preserve">
          <source>Getting data from a remote image using enhanced references</source>
          <target state="translated">향상된 참조를 사용하여 원격 이미지에서 데이터 가져 오기</target>
        </trans-unit>
        <trans-unit id="3806daf7c7ff821a9956038b5fe1d7adfa0fc983" translate="yes" xml:space="preserve">
          <source>Given a system time value &lt;var&gt;TIME&lt;/var&gt; (as provided by the &lt;a href=&quot;time#TIME&quot;&gt;TIME&lt;/a&gt; intrinsic), fills &lt;var&gt;VALUES&lt;/var&gt; with values extracted from it appropriate to the UTC time zone (Universal Coordinated Time, also known in some countries as GMT, Greenwich Mean Time), using &lt;code&gt;gmtime(3)&lt;/code&gt;.</source>
          <target state="translated">시스템 시간 값 &lt;var&gt;TIME&lt;/var&gt; ( &lt;a href=&quot;time#TIME&quot;&gt;TIME&lt;/a&gt; 내장 함수에서 제공)에 따라 &lt;code&gt;gmtime(3)&lt;/code&gt; 사용하여 UTC 시간대 (일부 국가에서는 GMT, 그리니치 표준시라고도 함)로 적절하게 추출 된 값으로 &lt;var&gt;VALUES&lt;/var&gt; 를 채 웁니다. ) .</target>
        </trans-unit>
        <trans-unit id="968e707b9fcefbfcc6db9cf99ad10ca01aff5d51" translate="yes" xml:space="preserve">
          <source>Given a system time value &lt;var&gt;TIME&lt;/var&gt; (as provided by the &lt;a href=&quot;time#TIME&quot;&gt;TIME&lt;/a&gt; intrinsic), fills &lt;var&gt;VALUES&lt;/var&gt; with values extracted from it appropriate to the local time zone using &lt;code&gt;localtime(3)&lt;/code&gt;.</source>
          <target state="translated">시스템 시간 값 &lt;var&gt;TIME&lt;/var&gt; ( &lt;a href=&quot;time#TIME&quot;&gt;TIME&lt;/a&gt; 내장 함수에서 제공)에 따라 &lt;code&gt;localtime(3)&lt;/code&gt; 사용하여 TIMES 에서 로컬 시간대로 추출 된 값으로 &lt;var&gt;VALUES&lt;/var&gt; 를 채 웁니다 .</target>
        </trans-unit>
        <trans-unit id="a3e6940f38a47d3df129001d326e2111cb6d93e8" translate="yes" xml:space="preserve">
          <source>Group ID function</source>
          <target state="translated">그룹 ID 기능</target>
        </trans-unit>
        <trans-unit id="0d1313538a726b49ebcebb349444981ad47993d2" translate="yes" xml:space="preserve">
          <source>Here is a small example:</source>
          <target state="translated">다음은 작은 예입니다.</target>
        </trans-unit>
        <trans-unit id="7a9040de5034658c4f1c776ca9472f411d205c8d" translate="yes" xml:space="preserve">
          <source>Here is a summary of all the options specific to GNU Fortran, grouped by type. Explanations are in the following sections.</source>
          <target state="translated">다음은 GNU Fortran과 관련된 모든 옵션을 유형별로 그룹화 한 것입니다. 다음 섹션에 설명이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d270a86d721c488d2b7f2378ace3926f89ec2fb5" translate="yes" xml:space="preserve">
          <source>Here is an example of code using the non portable record structure syntax:</source>
          <target state="translated">휴대용 레코드 구조가 아닌 구문을 사용하는 코드 예제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4df9cd3b9b1b6294dc038ba9a270226d44a1c4a7" translate="yes" xml:space="preserve">
          <source>Here is the mapping of logical operator to bitwise intrinsic used with</source>
          <target state="translated">다음은 논리 연산자와 비트 고유 함수의 매핑입니다.</target>
        </trans-unit>
        <trans-unit id="453e56e746b8b58d7f3ec1cadfba1451089fd6f6" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;_MyProject_flags&lt;/code&gt; is the case-sensitive name of the variable as seen from C programs while &lt;code&gt;global_flag&lt;/code&gt; is the case-insensitive name as seen from Fortran. If no binding name is specified, as for &lt;var&gt;tp&lt;/var&gt;, the C binding name is the (lowercase) Fortran binding name. If a binding name is specified, only a single variable may be after the double colon. Note of warning: You cannot use a global variable to access &lt;var&gt;errno&lt;/var&gt; of the C library as the C standard allows it to be a macro. Use the &lt;code&gt;IERRNO&lt;/code&gt; intrinsic (GNU extension) instead.</source>
          <target state="translated">여기서 &lt;code&gt;_MyProject_flags&lt;/code&gt; 는 C 프로그램에서 볼 때 대소 문자를 구분하는 변수 이름이고 &lt;code&gt;global_flag&lt;/code&gt; 는 Fortran에서 볼 때 대소 문자를 구분하지 않는 이름입니다. 바인딩 이름이 지정되지 않은 경우 &lt;var&gt;tp&lt;/var&gt; 와 같이 C 바인딩 이름은 (소문자) 포트란 바인딩 이름입니다. 바인딩 이름이 지정되면 단일 변수 만 이중 콜론 뒤에 올 수 있습니다. 경고 참고 : C 표준에서는 매크로가 될 수 있으므로 전역 변수를 사용 하여 C 라이브러리의 &lt;var&gt;errno&lt;/var&gt; 에 액세스 할 수 없습니다 . 사용 &lt;code&gt;IERRNO&lt;/code&gt; 의 고유 (GNU 확장) 대신합니다.</target>
        </trans-unit>
        <trans-unit id="58b5c30890f28e47bce9bc7844bbcc1e20f8fb25" translate="yes" xml:space="preserve">
          <source>Historically, legacy compilers allowed insertion of form feed characters (&amp;rsquo;\f&amp;rsquo;, ASCII 0xC) at the beginning of lines for formatted output to line printers, though the Fortran standard does not mention this. GNU Fortran supports the interpretation of form feed characters in source as whitespace for compatibility.</source>
          <target state="translated">역사적으로 레거시 컴파일러는 라인 시작 부분에 폼 피드 문자 ( '\ f', ASCII 0xC)를 삽입하여 포맷 된 출력을 라인 프린터로 삽입 할 수 있었지만 Fortran 표준에서는이를 언급하지 않았습니다. GNU Fortran은 소스에서 양식 피드 문자를 공백으로 해석하여 호환성을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="beb2619069b1f05f6fb873c61cb1abb0b0f1bc41" translate="yes" xml:space="preserve">
          <source>Hours past midnight, range 0&amp;ndash;23</source>
          <target state="translated">자정 이후의 시간, 범위 0&amp;ndash;23</target>
        </trans-unit>
        <trans-unit id="31524a9fb30368b64541b8aeb51e1826b2eb3b0a" translate="yes" xml:space="preserve">
          <source>How picky should the compiler be?</source>
          <target state="translated">컴파일러는 얼마나 까다 롭습니까?</target>
        </trans-unit>
        <trans-unit id="e800f9a1c4318af26c1a8da2685388acc65db0d7" translate="yes" xml:space="preserve">
          <source>How to help assure continued work for free software.</source>
          <target state="translated">무료 소프트웨어의 지속적인 작업을 보장하는 방법</target>
        </trans-unit>
        <trans-unit id="4e461b3cc6748ec681eab8b558da86d4b08a95ab" translate="yes" xml:space="preserve">
          <source>How you can copy and share this manual.</source>
          <target state="translated">이 매뉴얼을 복사하고 공유하는 방법.</target>
        </trans-unit>
        <trans-unit id="a8c96b87780fbc8dacc860ba152e6de87cea9ccc" translate="yes" xml:space="preserve">
          <source>How you can help.</source>
          <target state="translated">당신이 도울 수있는 방법.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
