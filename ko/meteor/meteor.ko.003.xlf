<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="meteor">
    <body>
      <group id="meteor">
        <trans-unit id="bdb3e52cfb8a1a584040971907ed393311be1bad" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a publication which takes a named argument. Note that it&amp;rsquo;s important to check the types of arguments that come in over the network.</source>
          <target state="translated">다음은 명명 된 인수를 사용하는 발행물의 예입니다. 네트워크를 통해 오는 인수 유형을 확인하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="d42755fc2a80f16b4ae5e6731999055912a149f1" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s exactly what happens, in order, when a Method is called:</source>
          <target state="translated">메소드가 호출 될 때 발생하는 순서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d0d2c82f3c0208bb883c5f70223a9dc14a58a834" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s example of defining a rule and adding it into the &lt;code&gt;DDPRateLimiter&lt;/code&gt;:</source>
          <target state="translated">다음은 규칙을 정의하고 &lt;code&gt;DDPRateLimiter&lt;/code&gt; 에 추가하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="3d465f47d094851011549b7b95c4e71181dc41a4" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how CoffeeScript works with Meteor&amp;rsquo;s namespacing.</source>
          <target state="translated">CoffeeScript가 Meteor의 네임 스페이스와 작동하는 방식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="69e8aca3a6933ce33491c685e121def5e8a30364" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how this naming convention looks when applied to a publication:</source>
          <target state="translated">다음은 출판에 적용될 때이 명명 규칙이 어떻게 보이는지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="cc11167a51129d41af575d59c26734ecde856b3d" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how we can add the &lt;a href=&quot;https://atmospherejs.com/practicalmeteor/mocha&quot;&gt;&lt;code&gt;practicalmeteor:mocha&lt;/code&gt;&lt;/a&gt; package to our app:</source>
          <target state="translated">&lt;a href=&quot;https://atmospherejs.com/practicalmeteor/mocha&quot;&gt; &lt;code&gt;practicalmeteor:mocha&lt;/code&gt; &lt;/a&gt; 패키지를 앱에 추가하는 방법은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="2993429f6666895611a75fd1680667898ed86228" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how you can call this Method from the client:</source>
          <target state="translated">클라이언트에서이 메소드를 호출하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a03a6bf334d1fa07c792e4ac2e93e75d11fd63f7" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how you can use the built-in &lt;a href=&quot;http://docs.meteor.com/#/full/meteor_methods&quot;&gt;&lt;code&gt;Meteor.methods&lt;/code&gt; API&lt;/a&gt; to define a Method. Note that Methods should always be defined in common code loaded on the client and the server to enable Optimistic UI. If you have some secret code in your Method, consult the &lt;a href=&quot;security#secret-code&quot;&gt;Security article&lt;/a&gt; for how to hide it from the client.</source>
          <target state="translated">내장 &lt;a href=&quot;http://docs.meteor.com/#/full/meteor_methods&quot;&gt; &lt;code&gt;Meteor.methods&lt;/code&gt; API&lt;/a&gt; 를 사용하여 메소드를 정의하는 방법 은 다음과 같습니다 . 낙관적 UI를 사용하려면 메소드가 항상 클라이언트와 서버에로드 된 공통 코드로 정의되어야합니다. 메소드에 비밀 코드가 있으면 &lt;a href=&quot;security#secret-code&quot;&gt;보안 기사&lt;/a&gt; 를 참조 하여 클라이언트에서 코드 를 숨기는 방법을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="696867911bab2ea0eb5b310080c679b35882906b" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how you would use one of these functions:</source>
          <target state="translated">다음 기능 중 하나를 사용하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b98915e0ff7bf6068966ab369348da90186ad4eb" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s some of the functionality an ideal Method would have:</source>
          <target state="translated">이상적인 Method가 가질 수있는 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="16327c7e09eaa3c233c4af5d587f0262a9f672b6" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s what a settings file with some API keys might look like:</source>
          <target state="translated">일부 API 키가있는 설정 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="712cb1c96036df069e9f03a6480e392756e99912" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s what our new override template looks like:</source>
          <target state="translated">새로운 재정의 템플릿은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb48dea1c738bb38b3eb0dee57ebc149848ecf1f" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s what the same user would look like if they instead logged in with Facebook:</source>
          <target state="translated">동일한 사용자가 Facebook으로 로그인 한 경우의 모습은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7a99388f1dcb77ee59a544e3d864ffedaf4ab1d5" translate="yes" xml:space="preserve">
          <source>Here's how events are counted: Each event that satisfies the matcher's filter is mapped to a bucket. Buckets are uniquely determined by the event object's values for all properties present in both the matcher and event objects.</source>
          <target state="translated">이벤트 계산 방법은 다음과 같습니다. 매처 필터를 만족하는 각 이벤트는 버킷에 매핑됩니다. 버킷은 매처와 이벤트 객체 모두에 존재하는 모든 속성에 대한 이벤트 객체의 값에 따라 고유하게 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="2cbef85b2a837410cdd665fc731fcf3aeefa3286" translate="yes" xml:space="preserve">
          <source>Here, we are using a Blaze feature called &lt;code&gt;Template.dynamic&lt;/code&gt; to render a template which is attached to the &lt;code&gt;main&lt;/code&gt; property of the data context. Using Blaze Layout, we can change that &lt;code&gt;main&lt;/code&gt; property when a route is accessed.</source>
          <target state="translated">여기서는 &lt;code&gt;Template.dynamic&lt;/code&gt; 이라는 Blaze 기능을 사용 하여 데이터 컨텍스트 의 &lt;code&gt;main&lt;/code&gt; 속성에 연결된 템플릿 을 렌더링합니다 . Blaze Layout을 사용 하여 경로에 액세스 할 때 해당 &lt;code&gt;main&lt;/code&gt; 속성을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98cba56377787fb9c3921bdf7829a6e92c57e6bd" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ll talk about how to manage the whole process manually from start to finish.</source>
          <target state="translated">여기서는 전체 프로세스를 처음부터 끝까지 수동으로 관리하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="bda39278f821eb4630143ec047c505f6808509c1" translate="yes" xml:space="preserve">
          <source>Highlighting the active route</source>
          <target state="translated">활성 경로 강조</target>
        </trans-unit>
        <trans-unit id="03c8f7b472c34255625fa195d9be2e582eb8c1c0" translate="yes" xml:space="preserve">
          <source>Historical comparison with allow/deny</source>
          <target state="translated">허용 / 거부와의 과거 비교</target>
        </trans-unit>
        <trans-unit id="0b8220021c88dac6621398966f4a9c2fe108248e" translate="yes" xml:space="preserve">
          <source>Historically, there have been some misconceptions about the features of Meteor Methods as compared with the allow/deny feature, including that it was more difficult to achieve Optimistic UI when using Methods. However, the client-side &lt;code&gt;insert&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;, and &lt;code&gt;remove&lt;/code&gt; feature is actually implemented &lt;em&gt;on top of&lt;/em&gt; Methods, so Methods are strictly more powerful. You get great default Optimistic UI just by defining your Method code on the client and the server, as described in the Method lifecycle section above.</source>
          <target state="translated">역사적으로, 방법을 사용할 때 낙관적 UI를 달성하기가 더 어렵다는 것을 포함하여 허용 / 거부 기능과 비교하여 유성 방법의 기능에 대해 약간의 오해가있었습니다. 그러나 클라이언트 측 &lt;code&gt;insert&lt;/code&gt; , &lt;code&gt;update&lt;/code&gt; 및 &lt;code&gt;remove&lt;/code&gt; 기능은 실제로 메소드 &lt;em&gt;위에&lt;/em&gt; 구현 되므로 메소드가 더 강력합니다. 위의 메소드 라이프 사이클 섹션에 설명 된대로 클라이언트와 서버에서 메소드 코드를 정의하기 만하면 훌륭한 기본 낙관적 UI를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b65d23158f9d2b8a79c8bdcb42105481603c266f" translate="yes" xml:space="preserve">
          <source>Hooks on insert/update/remove</source>
          <target state="translated">삽입 / 업데이트 / 제거시 후크</target>
        </trans-unit>
        <trans-unit id="98c8e71970a91a935ce63293bf6d663385373e71" translate="yes" xml:space="preserve">
          <source>Hosted service (recommended)</source>
          <target state="translated">호스팅 서비스 (권장)</target>
        </trans-unit>
        <trans-unit id="06a22da7df1c05a8fcebe643d8e0c297d4921ba5" translate="yes" xml:space="preserve">
          <source>Hot code push greatly improves the development experience, but on mobile, it is also a really useful feature for production apps, because it allows you to quickly push updates to devices without having users update the app through the store and without going through a possibly lengthy review process to get your update accepted.</source>
          <target state="translated">핫 코드 푸시는 개발 경험을 크게 향상 시키지만 모바일에서는 프로덕션 앱에 매우 유용한 기능이기도합니다. 사용자가 매장을 통해 앱을 업데이트하지 않고도 장기간에 걸쳐 앱을 업데이트하지 않고도 장치에 업데이트를 신속하게 푸시 할 수 있기 때문입니다. 업데이트 과정을 검토하십시오.</target>
        </trans-unit>
        <trans-unit id="7b97e36f13053cab23ebd066264ad4c4358f7855" translate="yes" xml:space="preserve">
          <source>Hot code push on mobile</source>
          <target state="translated">모바일에서의 핫 코드 푸시</target>
        </trans-unit>
        <trans-unit id="aa4ce17338e3e7feaab4b85c1474e46f3709dee6" translate="yes" xml:space="preserve">
          <source>Hot code pushes are loaded by the browser in the background while the app continues to run. Once the new code has been fully loaded the browser is able to switch over to the new code quickly.</source>
          <target state="translated">앱이 계속 실행되는 동안 브라우저가 핫 코드 푸시를 백그라운드에서로드합니다. 새 코드가 완전히로드되면 브라우저는 새 코드로 빠르게 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2066575c244e8a723fccd0aec086a276d9c21f57" translate="yes" xml:space="preserve">
          <source>Hot code pushing new JavaScript code to a device could accidentally push code containing errors, which might leave users with a broken app (a &amp;ldquo;white screen of death&amp;rdquo; in the worst case), and could even disable hot code push (because the code that makes a connection to the server may no longer run).</source>
          <target state="translated">새로운 자바 스크립트 코드를 기기에 푸시하는 핫 코드는 실수로 오류가 포함 된 코드를 푸시 할 수 있으며, 이로 인해 사용자에게 앱이 손상 될 수 있으며 (최악의 경우 &quot;죽음의 흰색 화면&quot;) 핫 코드 푸시를 비활성화 할 수 있습니다. 서버에 더 이상 연결되지 않을 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="0c468fa8a67f39184615650decddfc80cc0e13c4" translate="yes" xml:space="preserve">
          <source>How a Meteor application compares to other types of applications in terms of file structure.</source>
          <target state="translated">파일 구조 측면에서 Meteor 애플리케이션이 다른 유형의 애플리케이션과 비교되는 방식.</target>
        </trans-unit>
        <trans-unit id="5b27be0a7736ae16346c8f3010a0842ac1842250" translate="yes" xml:space="preserve">
          <source>How and where to load data in your Meteor app using publications and subscriptions.</source>
          <target state="translated">발행물 및 구독을 사용하여 Meteor 앱에서 데이터를로드하는 방법 및 위치.</target>
        </trans-unit>
        <trans-unit id="e21860bf37328b97ebb0ddd904694c78e4a7b382" translate="yes" xml:space="preserve">
          <source>How does it work?</source>
          <target state="translated">어떻게 작동합니까?</target>
        </trans-unit>
        <trans-unit id="79737bf4fbfdfaf16cbff20c8cedc1016aca3d24" translate="yes" xml:space="preserve">
          <source>How hot code push allows you to update your mobile app&amp;rsquo;s code without reinstalling the app on your device or submitting a new version to the store</source>
          <target state="translated">핫 코드 푸시를 사용하면 기기에 앱을 다시 설치하거나 상점에 새 버전을 제출하지 않고 모바일 앱의 코드를 업데이트하는 방법</target>
        </trans-unit>
        <trans-unit id="1dd6a17cb4033f4f74df1bb6912b8a28a8074084" translate="yes" xml:space="preserve">
          <source>How it works</source>
          <target state="translated">작동 원리</target>
        </trans-unit>
        <trans-unit id="967ddbc90240ac3f428c78a61d8e0a67a5b9403e" translate="yes" xml:space="preserve">
          <source>How much does ES2015 cost?</source>
          <target state="translated">ES2015 비용은 얼마입니까?</target>
        </trans-unit>
        <trans-unit id="6d22435b35abe40c0cf0fbd752555fbea41a477f" translate="yes" xml:space="preserve">
          <source>How the Blaze rendering engine works under the hood and some advanced techniques for using it.</source>
          <target state="translated">Blaze 렌더링 엔진이 후드에서 작동하는 방법 및이를 사용하는 몇 가지 고급 기술.</target>
        </trans-unit>
        <trans-unit id="f59d7854a399e000654c2134b562d445d54bdc3f" translate="yes" xml:space="preserve">
          <source>How to access local files and remote resources from your app</source>
          <target state="translated">앱에서 로컬 파일 및 원격 리소스에 액세스하는 방법</target>
        </trans-unit>
        <trans-unit id="79a10b0297b96af92ba177f0d19af0376a82ade1" translate="yes" xml:space="preserve">
          <source>How to add custom data to Meteor&amp;rsquo;s users collection</source>
          <target state="translated">Meteor의 사용자 컬렉션에 커스텀 데이터를 추가하는 방법</target>
        </trans-unit>
        <trans-unit id="33fc1725259f982690c0c3868e0dd264ea21ced2" translate="yes" xml:space="preserve">
          <source>How to build a fully-featured password login experience</source>
          <target state="translated">모든 기능을 갖춘 암호 로그인 환경을 구축하는 방법</target>
        </trans-unit>
        <trans-unit id="ff7ecc6e2bcc9cae41da455b438fe4522076c00e" translate="yes" xml:space="preserve">
          <source>How to build a style guide to allow you to visually test such reusable components.</source>
          <target state="translated">재사용 가능한 구성 요소를 시각적으로 테스트 할 수 있도록 스타일 가이드를 작성하는 방법</target>
        </trans-unit>
        <trans-unit id="9f0f532fd34a53fb4a594dc19a719c2439d0ea43" translate="yes" xml:space="preserve">
          <source>How to build components that can cope with a variety of different data sources.</source>
          <target state="translated">다양한 데이터 소스에 대처할 수있는 구성 요소를 구축하는 방법</target>
        </trans-unit>
        <trans-unit id="f620f1143e3f16e4c6451014fbeff86b425d54dd" translate="yes" xml:space="preserve">
          <source>How to build mobile apps using Meteor's Cordova integration.</source>
          <target state="translated">Meteor의 Cordova 통합을 사용하여 모바일 앱을 빌드하는 방법</target>
        </trans-unit>
        <trans-unit id="82e2bd276624454965277a70bec9cff399045dc9" translate="yes" xml:space="preserve">
          <source>How to build reusable client side components in any user interface framework.</source>
          <target state="translated">모든 사용자 인터페이스 프레임 워크에서 재사용 가능한 클라이언트 측 컴포넌트를 빌드하는 방법</target>
        </trans-unit>
        <trans-unit id="442c055554f5d2635c3a0c96be4746922789ee45" translate="yes" xml:space="preserve">
          <source>How to build user interfaces in a maintainable and extensible way.</source>
          <target state="translated">유지 관리 가능하고 확장 가능한 방식으로 사용자 인터페이스를 구축하는 방법</target>
        </trans-unit>
        <trans-unit id="6bb8165750968751f161ae21ffa8c2d9543a2f2b" translate="yes" xml:space="preserve">
          <source>How to build user login functionality into a Meteor app. Let your users log in with passwords, Facebook, Google, GitHub, and more.</source>
          <target state="translated">사용자 로그인 기능을 Meteor 앱에 빌드하는 방법 사용자가 비밀번호, Facebook, Google, GitHub 등으로 로그인 할 수있게하십시오.</target>
        </trans-unit>
        <trans-unit id="613a4683eaabfd5114944341c7d5cc636be600ae" translate="yes" xml:space="preserve">
          <source>How to build your project and submit your mobile app to the store</source>
          <target state="translated">프로젝트를 빌드하고 모바일 앱을 상점에 제출하는 방법</target>
        </trans-unit>
        <trans-unit id="6f79f62ec30f56e0cffa12bbf721cc206c707c8a" translate="yes" xml:space="preserve">
          <source>How to call a Method from a form.</source>
          <target state="translated">폼에서 메소드를 호출하는 방법.</target>
        </trans-unit>
        <trans-unit id="7a0489695f65f2749f41e07192ca7fb0db68aaae" translate="yes" xml:space="preserve">
          <source>How to carefully change the schema of your collection.</source>
          <target state="translated">컬렉션의 스키마를 신중하게 변경하는 방법</target>
        </trans-unit>
        <trans-unit id="f18ba9888a15c844de9e2e24971df560b7a4b57a" translate="yes" xml:space="preserve">
          <source>How to configure your app to use your own app icon, launch screen, and set other preferences</source>
          <target state="translated">자신의 앱 아이콘을 사용하도록 앱을 구성하고 화면을 시작하고 기타 기본 설정을 지정하는 방법</target>
        </trans-unit>
        <trans-unit id="084ba40658863bee602e98443850bc2d52b7cee8" translate="yes" xml:space="preserve">
          <source>How to construct links to routes and go to routes programmatically.</source>
          <target state="translated">프로그래밍 방식으로 경로에 대한 링크를 구성하고 경로로 이동하는 방법</target>
        </trans-unit>
        <trans-unit id="3206e41c33cefc9e1e4ccbd8e112597ee714051e" translate="yes" xml:space="preserve">
          <source>How to deal with associations between records.</source>
          <target state="translated">레코드 간 연결을 처리하는 방법</target>
        </trans-unit>
        <trans-unit id="bbd45428caec2a73caa2b90f0ed23e9893353fc6" translate="yes" xml:space="preserve">
          <source>How to define a publication on the server.</source>
          <target state="translated">서버에서 발행물을 정의하는 방법.</target>
        </trans-unit>
        <trans-unit id="001c195b1c8f92db4bd1e00537113ea757fcc71c" translate="yes" xml:space="preserve">
          <source>How to define a schema for a collection to control its content.</source>
          <target state="translated">컨텐츠를 제어하기 위해 콜렉션의 스키마를 정의하는 방법.</target>
        </trans-unit>
        <trans-unit id="de36a072d9a7a204255d05eeed6528e92f1d0fec" translate="yes" xml:space="preserve">
          <source>How to define client and server routes for your app using Flow Router.</source>
          <target state="translated">Flow Router를 사용하여 앱의 클라이언트 및 서버 경로를 정의하는 방법</target>
        </trans-unit>
        <trans-unit id="f4672cb2a09b02d43385cf78f81fdadbe49d67ad" translate="yes" xml:space="preserve">
          <source>How to define, use, and maintain MongoDB collections in Meteor.</source>
          <target state="translated">Meteor에서 MongoDB 모음을 정의, 사용 및 유지 관리하는 방법</target>
        </trans-unit>
        <trans-unit id="65a17df578e3256e7926af71803d435efe3f6d94" translate="yes" xml:space="preserve">
          <source>How to deploy to some common Meteor hosting environments.</source>
          <target state="translated">일반적인 Meteor 호스팅 환경에 배포하는 방법</target>
        </trans-unit>
        <trans-unit id="bf2ed0809ba4bd48b87963356019f3516c9d3ffc" translate="yes" xml:space="preserve">
          <source>How to deploy, run, and monitor your Meteor app in production.</source>
          <target state="translated">프로덕션 환경에서 Meteor 앱을 배포, 실행 및 모니터링하는 방법</target>
        </trans-unit>
        <trans-unit id="7db5874eb57134ae471f866a45450d6560a710fe" translate="yes" xml:space="preserve">
          <source>How to design a deployment process to make sure your application&amp;rsquo;s quality is maintained.</source>
          <target state="translated">응용 프로그램의 품질이 유지되도록 배포 프로세스를 디자인하는 방법</target>
        </trans-unit>
        <trans-unit id="cc48d1ba2ddebe0f75e698c7ce8e86f119fb8753" translate="yes" xml:space="preserve">
          <source>How to drive your Meteor app's UI using URLs with FlowRouter.</source>
          <target state="translated">FlowRouter가 포함 된 URL을 사용하여 Meteor 앱의 UI를 구동하는 방법</target>
        </trans-unit>
        <trans-unit id="fbdf53b5acf40587f418ac4b66f646e85284a611" translate="yes" xml:space="preserve">
          <source>How to enable login through OAuth providers like Facebook</source>
          <target state="translated">Facebook과 같은 OAuth 공급자를 통해 로그인을 활성화하는 방법</target>
        </trans-unit>
        <trans-unit id="5a8ed5bf88336ea0b05bc4fdf46c9e8c55216c14" translate="yes" xml:space="preserve">
          <source>How to enforce the schema when writing to a collection.</source>
          <target state="translated">컬렉션에 쓸 때 스키마를 적용하는 방법</target>
        </trans-unit>
        <trans-unit id="11ad33e91f73fac9016919655ed5cdc9fc196864" translate="yes" xml:space="preserve">
          <source>How to ensure your publication is secure in the face of reactive changes.</source>
          <target state="translated">사후 변경에 대비하여 발행물을 안전하게 보호하는 방법</target>
        </trans-unit>
        <trans-unit id="a9200b2e8bc1f4d62a398d453fb58a0105dd8a0a" translate="yes" xml:space="preserve">
          <source>How to follow a security checklist when auditing your app.</source>
          <target state="translated">앱을 감사 할 때 보안 점검 사항을 따르는 방법.</target>
        </trans-unit>
        <trans-unit id="865e77adcc2e8ff36ce26ab7713f52ca69f663c5" translate="yes" xml:space="preserve">
          <source>How to format your code and name the parts of your application in consistent and maintainable ways.</source>
          <target state="translated">일관되고 유지 관리 가능한 방식으로 코드 형식을 지정하고 응용 프로그램의 이름을 지정하는 방법</target>
        </trans-unit>
        <trans-unit id="08dd8cb16e8a03ad4adc353983d7261074e9be6e" translate="yes" xml:space="preserve">
          <source>How to have your app display different content depending on the URL.</source>
          <target state="translated">URL에 따라 앱에 다른 콘텐츠를 표시하는 방법</target>
        </trans-unit>
        <trans-unit id="1dcdf130c5eafaf08d5fca5c79cd4960da3cf851" translate="yes" xml:space="preserve">
          <source>How to install React in your Meteor application, and how to use it correctly.</source>
          <target state="translated">Meteor 애플리케이션에 React를 설치하는 방법 및 올바르게 사용하는 방법.</target>
        </trans-unit>
        <trans-unit id="2f53e7bc7003cb7ec4b9a690bd3c238f9761f699" translate="yes" xml:space="preserve">
          <source>How to integrate React with Meteor&amp;rsquo;s realtime data layer.</source>
          <target state="translated">React와 Meteor의 실시간 데이터 레이어를 통합하는 방법.</target>
        </trans-unit>
        <trans-unit id="79ad3e62b0f71069748525e24f5c44e73cc1405f" translate="yes" xml:space="preserve">
          <source>How to make sure your site is discoverable by search engines.</source>
          <target state="translated">검색 엔진에서 사이트를 검색 할 수 있도록하는 방법</target>
        </trans-unit>
        <trans-unit id="8116f88777601e3f230ec85d8cd5a7dc443fd6f8" translate="yes" xml:space="preserve">
          <source>How to manage user roles and permissions</source>
          <target state="translated">사용자 역할 및 권한을 관리하는 방법</target>
        </trans-unit>
        <trans-unit id="c14589324af2b2d084ebebe408ca5cffd10f5b5e" translate="yes" xml:space="preserve">
          <source>How to migrate your application to Meteor 1.5.</source>
          <target state="translated">애플리케이션을 Meteor 1.5로 마이그레이션하는 방법</target>
        </trans-unit>
        <trans-unit id="a7467688b0b4ce33388d7aa9d5757422fcf74167" translate="yes" xml:space="preserve">
          <source>How to monitor user behavior with analytics tools.</source>
          <target state="translated">분석 도구를 사용하여 사용자 동작을 모니터링하는 방법</target>
        </trans-unit>
        <trans-unit id="14a2c6edfa20423f34c12da78af6c9a5f40c05a9" translate="yes" xml:space="preserve">
          <source>How to monitor your application with Kadira.</source>
          <target state="translated">Kadira로 응용 프로그램을 모니터링하는 방법</target>
        </trans-unit>
        <trans-unit id="3ae80990ce8a4c686f061258ba9df4e41384cbed" translate="yes" xml:space="preserve">
          <source>How to organize your application both for small and larger applications.</source>
          <target state="translated">소규모 및 대규모 애플리케이션을 위해 애플리케이션을 구성하는 방법</target>
        </trans-unit>
        <trans-unit id="cae8a2c57a25249a2e7c309800eb0b62b59da9b3" translate="yes" xml:space="preserve">
          <source>How to reactively publish related data.</source>
          <target state="translated">관련 데이터를 반응 적으로 게시하는 방법</target>
        </trans-unit>
        <trans-unit id="21e7cb0d69f8aff289c7e7291815df768b889994" translate="yes" xml:space="preserve">
          <source>How to route in a React/Meteor application.</source>
          <target state="translated">React / Meteor 애플리케이션에서 라우팅하는 방법.</target>
        </trans-unit>
        <trans-unit id="590a24a3e16d85a94228b032aaa14302d5934117" translate="yes" xml:space="preserve">
          <source>How to run and debug your app on a mobile device or simulator/emulator</source>
          <target state="translated">모바일 장치 또는 시뮬레이터 / 에뮬레이터에서 앱을 실행하고 디버깅하는 방법</target>
        </trans-unit>
        <trans-unit id="cd639f12e58bf9c47cda6bdd69294c646c0cf197" translate="yes" xml:space="preserve">
          <source>How to secure Meteor Methods, publications, and source code.</source>
          <target state="translated">유성 분석법, 출판물 및 소스 코드를 보호하는 방법.</target>
        </trans-unit>
        <trans-unit id="7d1d112874c1e438b01df0fa51e394f9aa9fdc67" translate="yes" xml:space="preserve">
          <source>How to secure your Meteor app.</source>
          <target state="translated">Meteor 앱을 보호하는 방법.</target>
        </trans-unit>
        <trans-unit id="01989ca23419835536e69863931b29321a5f77ad" translate="yes" xml:space="preserve">
          <source>How to set up ESLint to check code style automatically</source>
          <target state="translated">코드 스타일을 자동으로 확인하도록 ESLint를 설정하는 방법</target>
        </trans-unit>
        <trans-unit id="ae4a6fec308fbeb396dadf1c55d3db21a38ebb0b" translate="yes" xml:space="preserve">
          <source>How to set up your local machine for mobile development</source>
          <target state="translated">모바일 개발을 위해 로컬 머신을 설정하는 방법</target>
        </trans-unit>
        <trans-unit id="075a8b2cd13873e26d2c47c68589296d27e739f4" translate="yes" xml:space="preserve">
          <source>How to structure your Meteor app with ES2015 modules, ship code to the client and server, and split your code into multiple apps.</source>
          <target state="translated">ES2015 모듈로 Meteor 앱을 구성하고, 클라이언트와 서버에 코드를 제공하고, 코드를 여러 앱으로 분할하는 방법</target>
        </trans-unit>
        <trans-unit id="61cc3e02447eba1e1dfd7f6efe94b2279004faca" translate="yes" xml:space="preserve">
          <source>How to test Blaze templates.</source>
          <target state="translated">Blaze 템플릿을 테스트하는 방법</target>
        </trans-unit>
        <trans-unit id="b4c58dbd39ef36e4b861f14a009aea0b30e603d1" translate="yes" xml:space="preserve">
          <source>How to test your Meteor application</source>
          <target state="translated">유성 응용 프로그램을 테스트하는 방법</target>
        </trans-unit>
        <trans-unit id="498a8587074134d1f49975927b063ca03d14dbde" translate="yes" xml:space="preserve">
          <source>How to throw and handle errors with Methods.</source>
          <target state="translated">Methods로 에러를 던지고 처리하는 방법.</target>
        </trans-unit>
        <trans-unit id="a42012b02b5ce5fb2147f665fac159a2785623d5" translate="yes" xml:space="preserve">
          <source>How to turn a 3rd-party REST endpoint into a publication.</source>
          <target state="translated">써드 파티 REST 엔드 포인트를 공개로 변환하는 방법</target>
        </trans-unit>
        <trans-unit id="fc9900992671d58e8ec02210e566d65a7dcfcc36" translate="yes" xml:space="preserve">
          <source>How to turn a publication in your app into a REST endpoint.</source>
          <target state="translated">앱의 게시를 REST 엔드 포인트로 전환하는 방법</target>
        </trans-unit>
        <trans-unit id="d31ca247c099f8e976ab7f7d067ea730923a0023" translate="yes" xml:space="preserve">
          <source>How to use Blaze, Meteor's frontend rendering system, to build usable and maintainable user interfaces.</source>
          <target state="translated">Meteor의 프론트 엔드 렌더링 시스템 인 Blaze를 사용하여 사용 가능하고 유지 보수 가능한 사용자 인터페이스를 구축하는 방법.</target>
        </trans-unit>
        <trans-unit id="32eec04a5518012c77e50abdb4143965eb80916c" translate="yes" xml:space="preserve">
          <source>How to use Cordova plugins to take advantage of native device features</source>
          <target state="translated">Cordova 플러그인을 사용하여 기본 장치 기능을 활용하는 방법</target>
        </trans-unit>
        <trans-unit id="299f7825137660055b571c632d327a67919b58c6" translate="yes" xml:space="preserve">
          <source>How to use Meteor's build system to compile your app.</source>
          <target state="translated">Meteor의 빌드 시스템을 사용하여 앱을 컴파일하는 방법</target>
        </trans-unit>
        <trans-unit id="0880cb01b1a00e985f2c7e71f3d0017db0085473" translate="yes" xml:space="preserve">
          <source>How to use Methods, Meteor's remote procedure call system, to write to the database.</source>
          <target state="translated">Meteor의 원격 프로 시저 호출 시스템 인 Methods를 사용하여 데이터베이스에 쓰는 방법.</target>
        </trans-unit>
        <trans-unit id="688a83c5025d4a8c046fbe31b74ab5178e41216b" translate="yes" xml:space="preserve">
          <source>How to use React, Facebook's frontend rendering library, with Meteor.</source>
          <target state="translated">Facebook의 프론트 엔드 렌더링 라이브러리 인 React를 Meteor와 함께 사용하는 방법.</target>
        </trans-unit>
        <trans-unit id="c2bb37f66501b983211c1ed6ee6200be042fda80" translate="yes" xml:space="preserve">
          <source>How to use accounts-ui for a quick prototype</source>
          <target state="translated">빠른 프로토 타입을 위해 accounts-ui를 사용하는 방법</target>
        </trans-unit>
        <trans-unit id="0f38a5a5f1894f9313a486914d1e9b393ea05617" translate="yes" xml:space="preserve">
          <source>How to use animation to keep users informed of changes.</source>
          <target state="translated">애니메이션을 사용하여 사용자에게 변경 사항을 알리는 방법</target>
        </trans-unit>
        <trans-unit id="a41fcd3ded5fd9a81452a7e3adbd33b9167094bd" translate="yes" xml:space="preserve">
          <source>How to use the Spacebars language to define templates rendered by the Blaze engine.</source>
          <target state="translated">스페이스 바 언어를 사용하여 Blaze 엔진에서 렌더링 한 템플릿을 정의하는 방법</target>
        </trans-unit>
        <trans-unit id="6fed2d3b42e94124dbea85c98c035ea167374d51" translate="yes" xml:space="preserve">
          <source>How to use the low-level publish API to publish anything.</source>
          <target state="translated">저수준 게시 API를 사용하여 게시하는 방법</target>
        </trans-unit>
        <trans-unit id="cea5029d5dba90aa9b552b8390ce67dfbb8257c1" translate="yes" xml:space="preserve">
          <source>How to use the useraccounts family of packages to build your login UI</source>
          <target state="translated">useraccounts 패키지 제품군을 사용하여 로그인 UI를 작성하는 방법</target>
        </trans-unit>
        <trans-unit id="8aa7e99c007ce54d681ed2efff96da799bd28bb4" translate="yes" xml:space="preserve">
          <source>However there are some challenges to splitting your code in this way that should be considered before jumping in.</source>
          <target state="translated">그러나 코드를 이런 식으로 나누는 데는 몇 가지 어려움이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1c8f634a52074d6597171d516f4582641100073" translate="yes" xml:space="preserve">
          <source>However, an integration test that crosses the client-server boundary of a Meteor application (where the modules under test cross that boundary) requires a different testing infrastructure, namely Meteor&amp;rsquo;s &amp;ldquo;full app&amp;rdquo; testing mode.</source>
          <target state="translated">그러나 Meteor 응용 프로그램의 클라이언트-서버 경계를 통과하는 통합 테스트 (테스트중인 모듈이 해당 경계를 교차하는 경우)에는 다른 테스트 인프라, 즉 Meteor의 &quot;풀 앱&quot;테스트 모드가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a918955046dbaa975a249800c9befcb7320189e8" translate="yes" xml:space="preserve">
          <source>However, collections are a lot more than a way to save and retrieve data. They also provide the core of the interactive, connected user experience that users expect from the best applications. Meteor makes this user experience easy to implement.</source>
          <target state="translated">그러나 컬렉션은 데이터를 저장하고 검색하는 방법 이상입니다. 또한 사용자가 최상의 애플리케이션에서 기대하는 대화식의 연결된 사용자 경험의 핵심을 제공합니다. Meteor는이 사용자 경험을 쉽게 구현할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="db39b1f8cbeac77448045e435f16b7de310b67a3" translate="yes" xml:space="preserve">
          <source>However, due to the same reasons discussed above, the publication &lt;em&gt;will not re-run&lt;/em&gt; if the user&amp;rsquo;s &lt;code&gt;admin&lt;/code&gt; status changes. If this is something that is likely to happen and reactive changes are needed, then we&amp;rsquo;ll need to make the publication reactive. We can do this via the same technique as above however:</source>
          <target state="translated">그러나 위에서 설명한 것과 같은 이유로 인해 사용자의 &lt;code&gt;admin&lt;/code&gt; 상태가 변경 되면 게시 &lt;em&gt;가 다시 실행되지 않습니다&lt;/em&gt; . 이것이 일어날 가능성이 있고 반응적인 변화가 필요한 경우 출판물을 반응 적으로 만들어야합니다. 그러나 위와 동일한 기술을 통해이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07bc3d1a3b522bd465d14dbe6b50d6184fd6ee5e" translate="yes" xml:space="preserve">
          <source>However, given that MongoDB prior to version 3.2 doesn&amp;rsquo;t support queries over multiple collections (&amp;ldquo;joins&amp;rdquo;), we typically end up having to denormalize some data back onto the parent collection. Denormalization is the practice of storing the same piece of information in the database multiple times (as opposed to a non-redundant &amp;ldquo;normal&amp;rdquo; form). MongoDB is a database where denormalizing is encouraged, and thus optimized for this practice.</source>
          <target state="translated">그러나 버전 3.2 이전의 MongoDB는 여러 콜렉션 ( &quot;조인&quot;)에 대한 쿼리를 지원하지 않으므로 일반적으로 일부 데이터를 상위 콜렉션으로 다시 비정규 화해야합니다. 비정규 화는 동일한 정보를 데이터베이스에 여러 번 저장하는 방식입니다 (중복이 아닌 &quot;정상&quot;형식과 반대). MongoDB는 비정규 화가 권장되는 데이터베이스이므로이 방법에 최적화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d915b3504d950ee54b74a67869675a06e69392b1" translate="yes" xml:space="preserve">
          <source>However, if we wanted to wait for the method to return from the server, we can put the redirection in the callback of the method:</source>
          <target state="translated">그러나 서버에서 메소드가 리턴되기를 기다리려면 메소드의 콜백에 경로 재 지정을 둘 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ead0301581de2d42f5482fead5b2800774a8f147" translate="yes" xml:space="preserve">
          <source>However, in some cases it&amp;rsquo;s better to allow one application to be the master and control access to the data for other applications via an API. This can help if you want to deploy the different applications on different schedules and need to be conservative about how the data changes.</source>
          <target state="translated">그러나 어떤 경우에는 한 응용 프로그램을 마스터로 사용하고 API를 통해 다른 응용 프로그램의 데이터에 대한 액세스를 제어하는 ​​것이 좋습니다. 다른 스케줄에 다른 애플리케이션을 배치하고 데이터 변경 방법에 대해 보수적이어야하는 경우 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f685a9f89b108ab4d5e0796da8c4712045678605" translate="yes" xml:space="preserve">
          <source>However, it is important to realize that hot code push can only be used to update the HTML, CSS, JavaScript code and other assets making up your web app. Changes to native code will still require you &lt;a href=&quot;#building-and-submitting&quot;&gt;to submit a new version of your app to the store&lt;/a&gt;.</source>
          <target state="translated">그러나 핫 코드 푸시는 웹 앱을 구성하는 HTML, CSS, JavaScript 코드 및 기타 자산을 업데이트하는 데만 사용할 수 있다는 점을 알아야합니다. 네이티브 코드를 변경하면 여전히 &lt;a href=&quot;#building-and-submitting&quot;&gt;새 버전의 앱을 스토어에 제출해야합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17106978fe2abf404ef82c52a8d4dd21b3a9e682" translate="yes" xml:space="preserve">
          <source>However, it is possible to do this thanks to our split between smart and reusable components. The reusable component simply renders what it&amp;rsquo;s given, so we use our smart component to control that information. We can use a &lt;a href=&quot;collections#local-collections&quot;&gt;&lt;em&gt;local collection&lt;/em&gt;&lt;/a&gt; to store the rendered data, and then push data into it when the user requests an update:</source>
          <target state="translated">그러나 스마트 구성 요소와 재사용 가능한 구성 요소가 분리되어 있기 때문에이 작업을 수행 할 수 있습니다. 재사용 가능한 구성 요소는 단순히 주어진 내용을 렌더링하므로 스마트 구성 요소를 사용하여 해당 정보를 제어합니다. 우리는 사용할 수있는 &lt;a href=&quot;collections#local-collections&quot;&gt;&lt;em&gt;지역 수집을&lt;/em&gt;&lt;/a&gt; 렌더링 데이터를 저장하고, 사용자가 업데이트를 요청하는 경우 다음에 데이터를 밀어 :</target>
        </trans-unit>
        <trans-unit id="73c4c15b9b1bdce95ff35a1cc7e67b8e37b22011" translate="yes" xml:space="preserve">
          <source>However, it&amp;rsquo;s a good idea to think ahead to how the schema may change over time. For instance, you may have a list of strings on a document (perhaps a set of tags). Although it&amp;rsquo;s tempting to leave them as a subfield on the document (assuming they don&amp;rsquo;t change much), if there&amp;rsquo;s a good chance that they&amp;rsquo;ll end up becoming more complicated in the future (perhaps tags will have a creator, or subtags later on?), then it might be easier in the long run to make a separate collection from the beginning.</source>
          <target state="translated">그러나 시간이 지남에 따라 스키마가 어떻게 변할 수 있는지 미리 생각해 보는 것이 좋습니다. 예를 들어, 문서에 문자열 목록 (아마도 태그 세트)이있을 수 있습니다. 문서에서 하위 필드로 남겨 두려는 경향이 있지만 (많이 변경되지 않는다고 가정 할 경우) 나중에 더 복잡해질 가능성이있는 경우 (태그에 생성자 또는 하위 태그가있을 수 있음) on?), 장기적으로는 처음부터 별도의 컬렉션을 만드는 것이 더 쉬울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b76fb027b5dabff6002b7e8af0c64c751927319" translate="yes" xml:space="preserve">
          <source>However, it&amp;rsquo;s generally a good idea to use a layout component (which you wrap all your components in) to subscribe to this subscription anyway. It&amp;rsquo;s better to be consistent about such things, and it makes for a more flexible system if you ever decide you have a screen that &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; need that data.</source>
          <target state="translated">그러나 일반적으로 레이아웃 구성 요소 (모든 구성 요소를 래핑 한)를 사용하여이 구독에 가입하는 것이 좋습니다. 그러한 것들에 대해 일관성을 유지하는 것이 좋으며, 데이터가 필요 &lt;em&gt;없는&lt;/em&gt; 화면이 있다고 결정하면 더 유연한 시스템을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="529994c2f075bbc6cb5b867bd818a97438f74275" translate="yes" xml:space="preserve">
          <source>However, it&amp;rsquo;s not &lt;em&gt;always&lt;/em&gt; necessarily a good idea to be optimistic. Sometimes we may actually want to wait for the server&amp;rsquo;s response. For instance, when a user is logging in, you &lt;em&gt;have&lt;/em&gt; to wait for the server to check the password is correct before you can start allowing them into the site.</source>
          <target state="translated">그러나 &lt;em&gt;항상&lt;/em&gt; 낙관적 인 것이 좋은 생각은 아닙니다 . 때때로 우리는 실제로 서버의 응답을 기다릴 수 있습니다. 사용자가 로그인 할 때 예를 들어, 당신 &lt;em&gt;이&lt;/em&gt; 당신이 사이트로 허용 시작하기 전에 암호가 올바른지 확인하기 위해 서버를 기다리는.</target>
        </trans-unit>
        <trans-unit id="0a152a81ab365c7c58a7a037bc1e4b320d3fabb2" translate="yes" xml:space="preserve">
          <source>However, it&amp;rsquo;s still important to test your changes throughly with a good process of Quality Assurance (QA). Although it&amp;rsquo;s easy to push out fixes to bugs, those bugs can still cause major problems to users and even potentially data corruption!</source>
          <target state="translated">그러나 양질의 QA (Quality Assurance) 프로세스를 통해 변경 사항을 전체적으로 테스트하는 것이 여전히 중요합니다. 버그를 수정하기는 쉽지만 이러한 버그는 여전히 사용자에게 중대한 문제를 야기하고 잠재적으로 데이터 손상을 일으킬 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="c54619cee1903cd2619a4bd3c99dde830c8d8834" translate="yes" xml:space="preserve">
          <source>However, it&amp;rsquo;s terrible UX to simply jump the user to an unexpected state without explaining what&amp;rsquo;s happened. We used a &lt;code&gt;alert()&lt;/code&gt; above, which is a pretty poor option, but gets the job done. One better approach is to indicate changes via a &amp;ldquo;flash notification&amp;rdquo;, which is a UI element that&amp;rsquo;s displayed &amp;ldquo;out-of-band&amp;rdquo;, typically in the top right of the screen, given the user &lt;em&gt;some&lt;/em&gt; indication of what&amp;rsquo;s happened. Here&amp;rsquo;s an example of a flash notification in Galaxy, at the top right of the page:</source>
          <target state="translated">그러나 발생한 일을 설명하지 않고 단순히 사용자를 예기치 않은 상태로 이동시키는 것은 끔찍한 UX입니다. 위 의 &lt;code&gt;alert()&lt;/code&gt; 사용 했는데 이는 상당히 좋지 않은 옵션이지만 작업을 완료합니다. 한 가지 더 나은 방법의 사용자 지정, 일반적으로 화면의 상단 오른쪽에, &quot;대역 외&quot;표시하는 UI 요소 인 &quot;플래시 통지&quot;를 통해 변경 표시하는 것입니다 &lt;em&gt;어떤&lt;/em&gt; 일이 있는지의 표시를. 다음은 페이지 오른쪽 상단에있는 Galaxy의 플래시 알림 예입니다.</target>
        </trans-unit>
        <trans-unit id="e59ebb5ff4324c5787fa66b34f3a5d8be022b8e9" translate="yes" xml:space="preserve">
          <source>However, most of the user-facing features of URLs listed above are still relevant for typical Meteor applications. Since the server is not URL-driven, the URL just becomes a useful representation of the client-side state the user is currently looking at. However, unlike in a server-rendered application, it does not need to describe the entirety of the user&amp;rsquo;s current state; it simply needs to contain the parts that you want to be linkable. For example, the URL should contain any search filters applied on a page, but not necessarily the state of a dropdown menu or popup.</source>
          <target state="translated">그러나 위에 나열된 URL의 대부분의 사용자 대면 기능은 여전히 ​​일반적인 Meteor 응용 프로그램과 관련이 있습니다. 서버는 URL 기반이 아니므로 URL은 사용자가 현재보고있는 클라이언트 측 상태를 나타내는 유용한 표현이됩니다. 그러나 서버 렌더링 응용 프로그램과 달리 사용자의 현재 상태 전체를 설명 할 필요는 없습니다. 연결하려는 부분 만 포함하면됩니다. 예를 들어, URL은 페이지에 적용된 검색 필터를 포함해야하지만 드롭 다운 메뉴 또는 팝업의 상태는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="48d6099bf45d6ffea137c3a2c863d6d16a8ede13" translate="yes" xml:space="preserve">
          <source>However, sometimes it&amp;rsquo;s useful to do more complex initialization to documents before inserting them into collections. For instance, in the Todos app, we want to set the name of new lists to be &lt;code&gt;List X&lt;/code&gt; where &lt;code&gt;X&lt;/code&gt; is the next available unique letter.</source>
          <target state="translated">그러나 때로는 문서를 컬렉션에 삽입하기 전에 문서에 대해보다 복잡한 초기화를 수행하는 것이 유용합니다. 예를 들어, Todos 앱에서 새 목록의 이름을 &lt;code&gt;List X&lt;/code&gt; 로 설정하려고합니다. 여기서 &lt;code&gt;X&lt;/code&gt; 는 사용 가능한 다음 고유 문자입니다.</target>
        </trans-unit>
        <trans-unit id="03fed144304cb92f06be961007d281acb5aa875b" translate="yes" xml:space="preserve">
          <source>However, this doesn&amp;rsquo;t mean you can&amp;rsquo;t have any flexibility in your Methods. Let&amp;rsquo;s look at an example:</source>
          <target state="translated">그러나 이것이 분석법에 유연성을 가질 수 없다는 것을 의미하지는 않습니다. 예를 보자.</target>
        </trans-unit>
        <trans-unit id="0846b39f92fd5c549adffd2cce9aa4b5fe3b812e" translate="yes" xml:space="preserve">
          <source>However, this example will not work as you might expect. The reason is that reactivity doesn&amp;rsquo;t work in the same way on the server as it does on the client. On the client, if &lt;em&gt;anything&lt;/em&gt; in a reactive function changes, the whole function will re-run, and the results are fairly intuitive.</source>
          <target state="translated">그러나이 예제는 예상대로 작동하지 않습니다. 서버에서 클라이언트와 같은 방식으로 반응성이 작동하지 않기 때문입니다. 클라이언트에서 경우 &lt;em&gt;어떤&lt;/em&gt; 반응 기능의 변화가 전체 기능을 다시 실행 한 것입니다 결과는 매우 직관적이다.</target>
        </trans-unit>
        <trans-unit id="efe7fbd39ef5cbe0a56364dcc763d212edb1215f" translate="yes" xml:space="preserve">
          <source>However, this won&amp;rsquo;t work in all cases - since the code runs asynchronously, we can&amp;rsquo;t use anything we got from an API in the method return value. We need a different approach that will convert the async API to a synchronous-looking one that will allow us to return a value.</source>
          <target state="translated">그러나 이것은 모든 경우에 작동하지 않습니다. 코드가 비동기 적으로 실행되기 때문에 메소드 반환 값에 API에서 얻은 것을 사용할 수 없습니다. 비동기 API를 동기식으로 변환하여 값을 반환 할 수있는 다른 접근 방식이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ae6ed46dde3f3aa91cbb3d5ee4fbbf57822cb7b9" translate="yes" xml:space="preserve">
          <source>However, we can write publications that are properly reactive to changes across collections. To do this, we use the &lt;a href=&quot;https://atmospherejs.com/reywood/publish-composite&quot;&gt;&lt;code&gt;reywood:publish-composite&lt;/code&gt;&lt;/a&gt; package.</source>
          <target state="translated">그러나 컬렉션 간 변경 사항에 적절하게 반응하는 게시를 작성할 수 있습니다. 이를 위해 &lt;a href=&quot;https://atmospherejs.com/reywood/publish-composite&quot;&gt; &lt;code&gt;reywood:publish-composite&lt;/code&gt; &lt;/a&gt; 패키지를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d54763561ff30677fe28c88ea1404ea1659fe6a9" translate="yes" xml:space="preserve">
          <source>However, we still need to subscribe to the list of items and the count, and collect that data somewhere. To do this, it&amp;rsquo;s sensible to use a smart wrapper component (analogous to an MVC &amp;ldquo;controller&amp;rdquo;) whose job it is to subscribe and fetch the relevant data.</source>
          <target state="translated">그러나 여전히 항목 목록과 개수를 구독하고 해당 데이터를 어딘가에 수집해야합니다. 이렇게하려면 관련 데이터를 구독하고 가져 오는 스마트 래퍼 구성 요소 (MVC&amp;ldquo;컨트롤러&amp;rdquo;와 유사)를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="75b8875b64a459d63c7376fbe3e8edbd52c6088b" translate="yes" xml:space="preserve">
          <source>Http(s) URLs to a git commit by SHA.</source>
          <target state="translated">SHA에 의한 git commit에 대한 Http URL.</target>
        </trans-unit>
        <trans-unit id="6f91972118a54e8f5071265110d2769e99d68a4a" translate="yes" xml:space="preserve">
          <source>Https URL example:</source>
          <target state="translated">Https URL 예 :</target>
        </trans-unit>
        <trans-unit id="006e123d5adcde715b21c22e9f7ad2e2086b1860" translate="yes" xml:space="preserve">
          <source>Ideally, once a smart component has assembled such a set of data, it passes it off to a reusable component child to render with. Smart components usually don&amp;rsquo;t render anything apart from one or more reusable children. This makes it easy to separate rendering and data loading in your tests.</source>
          <target state="translated">이상적으로는 스마트 구성 요소가 이러한 데이터 집합을 모은 후에는 재사용 할 수있는 구성 요소 자식으로 전달하여 렌더링합니다. 스마트 구성 요소는 일반적으로 재사용 가능한 하나 이상의 하위 요소를 제외하고는 아무것도 렌더링하지 않습니다. 따라서 테스트에서 렌더링과 데이터로드를 쉽게 분리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="295be7d94767d973e13a36c48f06bd1fd60478cb" translate="yes" xml:space="preserve">
          <source>Identifiers and Paths</source>
          <target state="translated">식별자 및 경로</target>
        </trans-unit>
        <trans-unit id="ec8d2a53e9795bdc00356965f6107d8ffc4749a6" translate="yes" xml:space="preserve">
          <source>Identifying when the link is clicked</source>
          <target state="translated">링크 클릭시기 식별</target>
        </trans-unit>
        <trans-unit id="1c24c81343fa36615a777cf9245dc925ab6b9292" translate="yes" xml:space="preserve">
          <source>If / Unless</source>
          <target state="translated">그렇지 않은 경우</target>
        </trans-unit>
        <trans-unit id="2271745d2c04f3025da05e53769aadf55c678925" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MAIL_URL&lt;/code&gt; is not set, &lt;code&gt;Email.send&lt;/code&gt; outputs the message to standard output instead.</source>
          <target state="translated">경우 &lt;code&gt;MAIL_URL&lt;/code&gt; 가 설정되지 &lt;code&gt;Email.send&lt;/code&gt; 은 표준 출력 대신에 메시지를 출력한다.</target>
        </trans-unit>
        <trans-unit id="5f296998f8bcc6d4ac57e7b10d46016c2d18e90b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;status&lt;/code&gt; is &lt;code&gt;failed&lt;/code&gt;, a description of why the connection failed.</source>
          <target state="translated">경우 &lt;code&gt;status&lt;/code&gt; 되어 &lt;code&gt;failed&lt;/code&gt; , 연결이 실패한 이유에 대한 설명.</target>
        </trans-unit>
        <trans-unit id="294b76a3566d7d21c729fe4887cb4ac5ba31bfad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, transparently follow HTTP redirects. Cannot be set to &lt;code&gt;false&lt;/code&gt; on the client. Default &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 인 경우 투명하게 HTTP 리디렉션을 따릅니다. 클라이언트 에서 &lt;code&gt;false&lt;/code&gt; 로 설정할 수 없습니다 . 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="66bae8da8eb95f3daff532cd3fc97fed66213834" translate="yes" xml:space="preserve">
          <source>If Session.get had been used instead of Session.equals, then when the selection changed, all the items would be re-rendered.</source>
          <target state="translated">Session.get이 Session.equals 대신 사용 된 경우 선택이 변경되면 모든 항목이 다시 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="f5ee0a0623a24d5220dc026e6a766f82425de2fa" translate="yes" xml:space="preserve">
          <source>If String, name of the record set. If Object, publications Dictionary of publish functions by name. If &lt;code&gt;null&lt;/code&gt;, the set has no name, and the record set is automatically sent to all connected clients.</source>
          <target state="translated">문자열 인 경우 레코드 세트의 이름입니다. 개체 인 경우 게시 기능 사전을 이름별로 게시합니다. 경우 &lt;code&gt;null&lt;/code&gt; , 세트는 이름이없는, 그리고 레코드 집합이 자동으로 연결된 모든 클라이언트로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="08b2874cec3b51d4885cefc9e71009d31d067774" translate="yes" xml:space="preserve">
          <source>If a URL is simply out-of-date (sometimes you might change the URL scheme of an application), you can redirect inside the &lt;code&gt;action&lt;/code&gt; function of the route:</source>
          <target state="translated">URL이 단순히 오래된 경우 (때로는 응용 프로그램의 URL 체계를 변경할 수 있음) 경로 의 &lt;code&gt;action&lt;/code&gt; 함수 내에서 리디렉션 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="404cb5b1b683f3615e494c3a796a23a014d494e3" translate="yes" xml:space="preserve">
          <source>If a client calls a method and is disconnected before it receives a response, it will re-call the method when it reconnects. This means that a client may call a method multiple times when it only means to call it once. If this behavior is problematic for your method, consider attaching a unique ID to each method call on the client, and checking on the server whether a call with this ID has already been made. Alternatively, you can use &lt;a href=&quot;#meteor_apply&quot;&gt;&lt;code&gt;Meteor.apply&lt;/code&gt;&lt;/a&gt; with the noRetry option set to true.</source>
          <target state="translated">클라이언트가 메소드를 호출하고 응답을 받기 전에 연결이 끊어지면 다시 연결할 때 메소드를 다시 호출합니다. 이것은 클라이언트가 메소드를 한 번만 호출한다는 의미 일 때 메소드를 여러 번 호출 할 수 있음을 의미합니다. 이 동작이 메소드에 문제가있는 경우 클라이언트의 각 메소드 호출에 고유 ID를 첨부하고 서버에서이 ID를 사용하여 호출했는지 확인하십시오. 다른 방법으로는 사용할 수 &lt;a href=&quot;#meteor_apply&quot;&gt; &lt;code&gt;Meteor.apply&lt;/code&gt; 을&lt;/a&gt; true로 설정 noRetry 옵션.</target>
        </trans-unit>
        <trans-unit id="fc6e97abc3e5521519dac25e93db492199f6f5fb" translate="yes" xml:space="preserve">
          <source>If a double-braced tag at element level evalutes to an object created with &lt;code&gt;Spacebars.SafeString(&quot;&amp;lt;span&amp;gt;Some HTML&amp;lt;/span&amp;gt;&quot;)&lt;/code&gt;, the HTML is inserted at the current location. The code that calls &lt;code&gt;SafeString&lt;/code&gt; is asserting that this HTML is safe to insert.</source>
          <target state="translated">요소 수준의 이중 괄호 태그가 &lt;code&gt;Spacebars.SafeString(&quot;&amp;lt;span&amp;gt;Some HTML&amp;lt;/span&amp;gt;&quot;)&lt;/code&gt; 생성 된 객체로 줄어드는 경우 HTML이 현재 위치에 삽입됩니다. &lt;code&gt;SafeString&lt;/code&gt; 을 호출하는 코드는 이 HTML이 삽입하기에 안전하다고 주장합니다.</target>
        </trans-unit>
        <trans-unit id="e561cf254115ebe95b56ad073070db08304a680d" translate="yes" xml:space="preserve">
          <source>If a path starts with &lt;code&gt;..&lt;/code&gt;, then the &lt;em&gt;enclosing&lt;/em&gt; data context is used instead of the current one. The enclosing data context might be the one outside the current &lt;code&gt;#each&lt;/code&gt;, &lt;code&gt;#with&lt;/code&gt;, or template inclusion.</source>
          <target state="translated">경로로 시작하면 &lt;code&gt;..&lt;/code&gt; 다음 &lt;em&gt;둘러싸고&lt;/em&gt; 데이터 컨텍스트 대신에 현재 사용된다. 둘러싸는 데이터 컨텍스트는 현재 &lt;code&gt;#each&lt;/code&gt; , &lt;code&gt;#with&lt;/code&gt; 또는 템플릿 포함 외부의 컨텍스트 일 ​​수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c296965895460cad94501bae9df4c08010ed8a6d" translate="yes" xml:space="preserve">
          <source>If a publish function does not return a cursor or array of cursors, it is assumed to be using the low-level &lt;code&gt;added&lt;/code&gt;/&lt;code&gt;changed&lt;/code&gt;/&lt;code&gt;removed&lt;/code&gt; interface, and it &lt;strong&gt;must also call &lt;a href=&quot;#publish_ready&quot;&gt;&lt;code&gt;ready&lt;/code&gt;&lt;/a&gt; once the initial record set is complete&lt;/strong&gt;.</source>
          <target state="translated">공개 함수가 커서 또는 커서 배열을 리턴하지 않으면 저수준 &lt;code&gt;added&lt;/code&gt; / &lt;code&gt;changed&lt;/code&gt; / &lt;code&gt;removed&lt;/code&gt; 인터페이스를 사용하는 것으로 가정 &lt;strong&gt;하고 초기 레코드 세트가 완료되면 &lt;/strong&gt;&lt;strong&gt;&lt;a href=&quot;#publish_ready&quot;&gt; &lt;code&gt;ready&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt;&lt;strong&gt; 를 호출해야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c67236e4a923771c827a8a9684de68ba83c48c75" translate="yes" xml:space="preserve">
          <source>If a selector matches multiple elements that an event bubbles to, it will be called multiple times, for example in the case of &lt;code&gt;'click
div'&lt;/code&gt; or &lt;code&gt;'click *'&lt;/code&gt;. If no selector is given, the handler will only be called once, on the original target element.</source>
          <target state="translated">선택자가 이벤트가 버블 링하는 여러 요소와 일치하면 예를 들어 &lt;code&gt;'click div'&lt;/code&gt; 또는 &lt;code&gt;'click *'&lt;/code&gt; 의 경우와 같이 여러 번 호출됩니다 . 선택기가 제공되지 않으면 원래 대상 요소에서 핸들러가 한 번만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="fc468b03ef781b0b140b8837f90bcd87ef3102bd" translate="yes" xml:space="preserve">
          <source>If a user types an incorrect URL, chances are you want to show them some kind of amusing not-found page. There are actually two categories of not-found pages. The first is when the URL typed in doesn&amp;rsquo;t match any of your route definitions. You can use &lt;code&gt;FlowRouter.notFound&lt;/code&gt; to handle this:</source>
          <target state="translated">사용자가 잘못된 URL을 입력하면 재미있는 종류의 찾을 수없는 페이지가 표시 될 수 있습니다. 찾을 수없는 페이지에는 실제로 두 가지 범주가 있습니다. 첫 번째는 입력 한 URL이 경로 정의와 일치하지 않는 경우입니다. &lt;code&gt;FlowRouter.notFound&lt;/code&gt; 를 사용 하여 이를 처리 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9026fe644d96ba958ad6a899068c1879787ee471" translate="yes" xml:space="preserve">
          <source>If an exception is thrown from the Method simulation, then by default Meteor ignores it and continues to step (2). If you are using &lt;code&gt;ValidatedMethod&lt;/code&gt; or pass a special &lt;code&gt;throwStubExceptions&lt;/code&gt; option to &lt;code&gt;Meteor.apply&lt;/code&gt;, then an exception thrown from the simulation will stop the server-side Method from running at all.</source>
          <target state="translated">분석법 시뮬레이션에서 예외가 발생하면 기본적으로 Meteor는이를 무시하고 2 단계로 계속 진행합니다. &lt;code&gt;ValidatedMethod&lt;/code&gt; 를 사용 하거나 특수 &lt;code&gt;throwStubExceptions&lt;/code&gt; 옵션을 &lt;code&gt;Meteor.apply&lt;/code&gt; 에 전달하는 경우 시뮬레이션에서 예외가 발생하면 서버 측 메소드가 전혀 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf211b40f906a97c0f1f5f10fafd264a5fc9b391" translate="yes" xml:space="preserve">
          <source>If an inclusion tag resolves to a function, the function must return a template object or &lt;code&gt;null&lt;/code&gt;. The function is reactively re-run, and if its return value changes, the template will be replaced.</source>
          <target state="translated">포함 태그가 함수로 해석되면 함수는 템플리트 오브젝트 또는 &lt;code&gt;null&lt;/code&gt; 을 리턴해야합니다 . 이 함수는 반응 적으로 다시 실행되며 반환 값이 변경되면 템플릿이 교체됩니다.</target>
        </trans-unit>
        <trans-unit id="c8e71dee77de483007af38976102d6166b5a09ac" translate="yes" xml:space="preserve">
          <source>If possible, it&amp;rsquo;s usually best to try and abstract out the reusable part of the two components that need to share functionality into a new, smaller component. If you follow the patterns for &lt;a href=&quot;reusable-components&quot;&gt;reusable components&lt;/a&gt;, it should be simple to reuse this sub-component everywhere you need this functionality.</source>
          <target state="translated">가능하면 일반적으로 기능을 새로운 작은 구성 요소로 공유해야하는 두 구성 요소의 재사용 가능한 부분을 추출하는 것이 가장 좋습니다. &lt;a href=&quot;reusable-components&quot;&gt;재사용 가능한 구성 요소&lt;/a&gt; 의 패턴을 따르는 경우이 기능이 필요한 모든 곳에서이 하위 구성 요소를 재사용하는 것이 간단해야합니다.</target>
        </trans-unit>
        <trans-unit id="faddab19504c5fd4ecc813555cd3025952a1e1bc" translate="yes" xml:space="preserve">
          <source>If set to a string, only allows new users if the domain part of their email address matches the string. If set to a function, only allows new users if the function returns true. The function is passed the full email address of the proposed new user. Works with password-based sign-in and external services that expose email addresses (Google, Facebook, GitHub). All existing users still can log in after enabling this option. Example: &lt;code&gt;Accounts.config({ restrictCreationByEmailDomain: 'school.edu' })&lt;/code&gt;.</source>
          <target state="translated">문자열로 설정하면 이메일 주소의 도메인 부분이 문자열과 일치하는 경우 새 사용자 만 허용합니다. 함수로 설정된 경우 함수가 true를 반환하면 새 사용자 만 허용합니다. 이 기능은 제안 된 새로운 사용자의 전체 이메일 주소로 전달됩니다. 이메일 주소 (Google, Facebook, GitHub)를 노출하는 비밀번호 기반 로그인 및 외부 서비스와 함께 작동합니다. 이 옵션을 활성화 한 후에도 기존의 모든 사용자는 여전히 로그인 할 수 있습니다. 예 : &lt;code&gt;Accounts.config({ restrictCreationByEmailDomain: 'school.edu' })&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c268ce2b10b3ffffefc2144b86ac42f77e4d52f" translate="yes" xml:space="preserve">
          <source>If someone comes along and passes a non-ID selector like &lt;code&gt;{}&lt;/code&gt;, they will end up deleting the entire collection.</source>
          <target state="translated">누군가가 와서 &lt;code&gt;{}&lt;/code&gt; 와 같은 비 ID 선택자를 전달 하면 전체 컬렉션이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="561766f90c831adc2b315203e468534153640cd3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;MAIL_URL&lt;/code&gt; environment variable is set, actually sends the email. Otherwise, prints the contents of the email to standard out.</source>
          <target state="translated">는 IF &lt;code&gt;MAIL_URL&lt;/code&gt; 의 환경 변수가 설정되어, 실제로 이메일을 보냅니다. 그렇지 않으면 전자 메일 내용을 표준 출력으로 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="760fe41acd350bff390e995daccf34f94bd6130d" translate="yes" xml:space="preserve">
          <source>If the Method throws an error, you get that in the first argument of the callback. If the Method succeeds, you get the result in the second argument and the first argument &lt;code&gt;err&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt;. For more information about errors, see the section below about error handling.</source>
          <target state="translated">메소드가 오류를 발생 시키면 콜백의 첫 번째 인수에서 오류가 발생합니다. 메소드가 성공하면 두 번째 인수에 결과가 표시되고 첫 번째 인수 &lt;code&gt;err&lt;/code&gt; 은 &lt;code&gt;undefined&lt;/code&gt; . 오류에 대한 자세한 내용은 오류 처리에 대한 아래 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ff5bffa4493549d3c3eb5dcbedb088285a119567" translate="yes" xml:space="preserve">
          <source>If the View hasn&amp;rsquo;t been created yet, calls &lt;code&gt;func&lt;/code&gt; when the View is created. In &lt;code&gt;func&lt;/code&gt;, the View is bound to &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">보기가 아직 작성되지 않은 경우보기가 작성 될 때 &lt;code&gt;func&lt;/code&gt; 를 호출 하십시오. 에서 &lt;code&gt;func&lt;/code&gt; ,보기는에 바인딩 &lt;code&gt;this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb6c5632533f02eb65b914e68ac1df32dd0adf96" translate="yes" xml:space="preserve">
          <source>If the View hasn&amp;rsquo;t been destroyed yet, calls &lt;code&gt;func&lt;/code&gt; when the View is destroyed. A View may be destroyed without ever becoming &amp;ldquo;ready.&amp;rdquo; In &lt;code&gt;func&lt;/code&gt;, the View is bound to &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">뷰가 아직 파괴되지 않았다면 , 뷰가 파괴 될 때 &lt;code&gt;func&lt;/code&gt; 를 호출 하십시오. &quot;준비&quot;상태가되지 않으면 뷰가 손상 될 수 있습니다. 에서 &lt;code&gt;func&lt;/code&gt; ,보기는에 바인딩 &lt;code&gt;this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adad32e4ae914f0a838d66caaaafb90c377bc501" translate="yes" xml:space="preserve">
          <source>If the View is removed by some other mechanism besides Meteor or jQuery (which Meteor integrates with by default), the View may continue to update indefinitely. Most users will not need to manually render templates and insert them into the DOM, but if you do, be mindful to always call &lt;a href=&quot;#Blaze-remove&quot;&gt;&lt;code&gt;Blaze.remove&lt;/code&gt;&lt;/a&gt; when the View is no longer needed.</source>
          <target state="translated">Meteor 또는 jQuery (Meteor가 기본적으로 통합되어 있음) 이외의 다른 메커니즘으로 View가 제거되면 View가 무기한으로 계속 업데이트 될 수 있습니다. 대부분의 사용자는 템플릿을 수동으로 렌더링하여 DOM에 삽입 할 필요가 없지만, 필요한 경우보기가 더 이상 필요하지 않을 때는 항상 &lt;a href=&quot;#Blaze-remove&quot;&gt; &lt;code&gt;Blaze.remove&lt;/code&gt; 를&lt;/a&gt; 호출 해야합니다.</target>
        </trans-unit>
        <trans-unit id="e2c5d9d4fb620079dab064cc2d9258b666383207" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;code&gt;#with&lt;/code&gt; is a string or other non-object value, it may be promoted to a JavaScript wrapper object (also known as a boxed value) when passed to helpers, because JavaScript traditionally only allows an object for &lt;code&gt;this&lt;/code&gt;. Use &lt;code&gt;String(this)&lt;/code&gt; to get an unboxed string value or &lt;code&gt;Number(this)&lt;/code&gt; to get an unboxed number value.</source>
          <target state="translated">&lt;code&gt;#with&lt;/code&gt; 에 대한 인수 가 문자열 또는 객체가 아닌 다른 값이면 헬퍼에 전달 될 때 JavaScript 래퍼 객체 (상자 값이라고도 함)로 승격 될 수 있습니다. JavaScript는 전통적 &lt;code&gt;this&lt;/code&gt; 객체에 대해서만 객체를 허용하기 때문 입니다. Unboxed 문자열 값을 얻으려면 &lt;code&gt;String(this)&lt;/code&gt; 을 사용 하고 Unboxed 숫자 값을 얻으려면 &lt;code&gt;Number(this)&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ad2e0c81a533f5d9fa655a5c6172c577ba7bb0c7" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;code&gt;#with&lt;/code&gt; is falsy (by the same rules as for &lt;code&gt;#if&lt;/code&gt;), the content is not rendered. An &amp;ldquo;else&amp;rdquo; block may be provided, which will be rendered instead.</source>
          <target state="translated">&lt;code&gt;#with&lt;/code&gt; 에 대한 인수가 잘못된 경우 ( &lt;code&gt;#if&lt;/code&gt; 와 동일한 규칙에 따라 ) 내용이 렌더링되지 않습니다. &quot;else&quot;블록이 제공 될 수 있으며, 대신 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="eaa59d0b779e3dfa672d6ff91d93fd367aaef255" translate="yes" xml:space="preserve">
          <source>If the autopublish package is installed, information about all users on the system is published to all clients. This includes &lt;code&gt;username&lt;/code&gt;, &lt;code&gt;profile&lt;/code&gt;, and any fields in &lt;code&gt;services&lt;/code&gt; that are meant to be public (eg &lt;code&gt;services.facebook.id&lt;/code&gt;, &lt;code&gt;services.twitter.screenName&lt;/code&gt;). Additionally, when using autopublish more information is published for the currently logged in user, including access tokens. This allows making API calls directly from the client for services that allow this.</source>
          <target state="translated">자동 게시 패키지가 설치된 경우 시스템의 모든 사용자에 대한 정보가 모든 클라이언트에 게시됩니다. 여기에는 &lt;code&gt;username&lt;/code&gt; , &lt;code&gt;profile&lt;/code&gt; 및 공개 할 &lt;code&gt;services&lt;/code&gt; 필드 (예 : &lt;code&gt;services.facebook.id&lt;/code&gt; , &lt;code&gt;services.twitter.screenName&lt;/code&gt; )가 포함됩니다. 또한 자동 게시를 사용하면 액세스 토큰을 포함하여 현재 로그인 한 사용자에 대한 추가 정보가 게시됩니다. 이를 통해이를 허용하는 서비스에 대해 클라이언트에서 직접 API 호출을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a74cfb01a0afac49fbd69424dc2af89d335da6be" translate="yes" xml:space="preserve">
          <source>If the code is private, or of no interest to others, it typically makes sense to simply include the same module in both applications (you &lt;em&gt;can&lt;/em&gt; do this with &lt;a href=&quot;https://www.npmjs.com/private-modules&quot;&gt;private npm modules&lt;/a&gt;). There are several ways to do this:</source>
          <target state="translated">코드가 비공개이거나 다른 코드에 관심이없는 경우 일반적으로 두 응용 프로그램 모두에 동일한 모듈을 포함시키는 것이 좋습니다 ( &lt;a href=&quot;https://www.npmjs.com/private-modules&quot;&gt;private npm modules로&lt;/a&gt; 수행 할 &lt;em&gt;수 있음&lt;/em&gt; ). 이를 수행하는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a810388d29aae9dd5ed67e04a227f42a27afb26" translate="yes" xml:space="preserve">
          <source>If the initial run of an autorun throws an exception, the computation is automatically stopped and won&amp;rsquo;t be rerun.</source>
          <target state="translated">자동 실행의 초기 실행에서 예외가 발생하면 계산이 자동으로 중지되고 다시 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="311fc9d51fdd289b30affd698690e03de43248a3" translate="yes" xml:space="preserve">
          <source>If the match fails, &lt;code&gt;check&lt;/code&gt; throws a &lt;code&gt;Match.Error&lt;/code&gt; describing how it failed. If this error gets sent over the wire to the client, it will appear only as &lt;code&gt;Meteor.Error(400, 'Match Failed')&lt;/code&gt;. The failure details will be written to the server logs but not revealed to the client.</source>
          <target state="translated">일치하지 않으면 &lt;code&gt;check&lt;/code&gt; 는 실패한 방법을 설명하는 &lt;code&gt;Match.Error&lt;/code&gt; 를 발생 시킵니다 . 이 오류가 유선을 통해 클라이언트로 전송되면 &lt;code&gt;Meteor.Error(400, 'Match Failed')&lt;/code&gt; 로만 나타납니다 . 실패 세부 사항은 서버 로그에 기록되지만 클라이언트에는 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6216c97351dae4afadee52afc404a9827779c513" translate="yes" xml:space="preserve">
          <source>If the migration logs anything to the console, you&amp;rsquo;ll see it in the terminal window that is running the Meteor server.</source>
          <target state="translated">마이그레이션이 콘솔에 아무것도 기록하면 Meteor 서버를 실행하는 터미널 창에 콘솔이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="383457a28536fcc159b3ba0f9ca5202fd8c020c8" translate="yes" xml:space="preserve">
          <source>If the new version involves different data formats in the database, then you need to be a little more careful about how you step through versions to ensure that all the versions that are running simultaneously can work together. You can read more about how to do this in the &lt;a href=&quot;collections#migrations&quot;&gt;collections article&lt;/a&gt;.</source>
          <target state="translated">새 버전에 데이터베이스의 다른 데이터 형식이 포함 된 경우 동시에 실행되는 모든 버전이 함께 작동 할 수 있도록 버전을 단계별로 실행하는 방법에 대해 좀 더주의해야합니다. 이 작업을 수행하는 방법에 대한 자세한 내용은 &lt;a href=&quot;collections#migrations&quot;&gt;컬렉션 기사를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c504e34fd35712e27574ed506051530693a4039" translate="yes" xml:space="preserve">
          <source>If the package is just a development dependency (i.e. it&amp;rsquo;s used for testing, linting or the like) then you should use &lt;code&gt;--save-dev&lt;/code&gt;. That way if you have some kind of build script, it can do &lt;code&gt;npm install --production&lt;/code&gt; and avoid installing packages it doesn&amp;rsquo;t need.</source>
          <target state="translated">패키지가 단지 개발 의존성 인 경우 (즉, 테스팅, 린트 닝 등에 사용되는 경우) &lt;code&gt;--save-dev&lt;/code&gt; 를 사용해야합니다 . 그렇게하면 일종의 빌드 스크립트가 있으면 &lt;code&gt;npm install --production&lt;/code&gt; 을 수행 하고 필요하지 않은 패키지 설치를 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="829ea98439cbd81ab5f2feeaae924a345f0111ea" translate="yes" xml:space="preserve">
          <source>If the response headers indicate JSON content, this contains the body of the document parsed as a JSON object.</source>
          <target state="translated">응답 헤더가 JSON 컨텐츠를 나타내는 경우 여기에는 JSON 오브젝트로 구문 분석 된 문서 본문이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="53418477ff1863486739569580596b4616219822" translate="yes" xml:space="preserve">
          <source>If the store is multi-dimensional, you may want to use a &lt;code&gt;ReactiveDict&lt;/code&gt; (from the &lt;a href=&quot;https://atmospherejs.com/meteor/reactive-dict&quot;&gt;&lt;code&gt;reactive-dict&lt;/code&gt;&lt;/a&gt; package):</source>
          <target state="translated">상점이 다차원 인 경우 &lt;code&gt;ReactiveDict&lt;/code&gt; ( &lt;a href=&quot;https://atmospherejs.com/meteor/reactive-dict&quot;&gt; &lt;code&gt;reactive-dict&lt;/code&gt; &lt;/a&gt; 패키지에서 제공) 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ae137251be09c6077d03f298005082d3e8c8fc6" translate="yes" xml:space="preserve">
          <source>If the store is single-dimensional, you can probably use a &lt;code&gt;ReactiveVar&lt;/code&gt; to store it (provided by the &lt;a href=&quot;https://atmospherejs.com/meteor/reactive-var&quot;&gt;&lt;code&gt;reactive-var&lt;/code&gt;&lt;/a&gt; package). A &lt;code&gt;ReactiveVar&lt;/code&gt; has two properties, &lt;code&gt;get()&lt;/code&gt; and &lt;code&gt;set()&lt;/code&gt;:</source>
          <target state="translated">저장소가 1 차원 인 경우 &lt;code&gt;ReactiveVar&lt;/code&gt; 를 사용 하여 저장소를 저장할 수 있습니다 ( &lt;a href=&quot;https://atmospherejs.com/meteor/reactive-var&quot;&gt; &lt;code&gt;reactive-var&lt;/code&gt; &lt;/a&gt; 패키지에서 제공). &lt;code&gt;ReactiveVar&lt;/code&gt; 는 두 가지 속성이 &lt;code&gt;get()&lt;/code&gt; 와 &lt;code&gt;set()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3a987e30de15b07bf76728d567d6ffad1e4f5236" translate="yes" xml:space="preserve">
          <source>If the subscription is run with &lt;em&gt;different arguments&lt;/em&gt;, then a new subscription is created, which connects to the publication on the server.</source>
          <target state="translated">구독이 &lt;em&gt;다른 인수&lt;/em&gt; 로 실행되면 새 구독이 작성되어 서버의 발행물에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="8c69463b66d86765802ca248de505a52a66a5048" translate="yes" xml:space="preserve">
          <source>If the subscription is run with the &lt;em&gt;same arguments&lt;/em&gt; then the &amp;ldquo;new&amp;rdquo; subscription discovers the old &amp;ldquo;marked for destruction&amp;rdquo; subscription that&amp;rsquo;s sitting around, with the same data already ready, and simply reuses that.</source>
          <target state="translated">구독이 &lt;em&gt;동일한 인수&lt;/em&gt; 로 실행되는 경우 &quot;새&quot;구독은 동일한 데이터가 이미 준비된 상태에서 기존의 &quot;파기 표시&quot;구독을 발견하고 단순히 재사용합니다.</target>
        </trans-unit>
        <trans-unit id="5e5ff626f0630055385718ace638d74ee720f863" translate="yes" xml:space="preserve">
          <source>If the user is being created as part of a login attempt from a client (eg, calling &lt;a href=&quot;#accounts_createuser&quot;&gt;&lt;code&gt;Accounts.createUser&lt;/code&gt;&lt;/a&gt; from the client, or &lt;a href=&quot;#meteor_loginwithexternalservice&quot;&gt;logging in for the first time with an external service&lt;/a&gt;), these callbacks are called &lt;em&gt;before&lt;/em&gt; the &lt;a href=&quot;#accounts_validateloginattempt&quot;&gt;&lt;code&gt;Accounts.validateLoginAttempt&lt;/code&gt;&lt;/a&gt; callbacks. If these callbacks succeed but those fail, the user will still be created but the connection will not be logged in as that user.</source>
          <target state="translated">사용자가 클라이언트에서 로그인 시도의 일환으로 작성하는 경우 (예를 들어, 호출 &lt;a href=&quot;#accounts_createuser&quot;&gt; &lt;code&gt;Accounts.createUser&lt;/code&gt; 을&lt;/a&gt; 클라이언트, 또는에서 &lt;a href=&quot;#meteor_loginwithexternalservice&quot;&gt;외부 서비스에 처음 로그인&lt;/a&gt; ),이 콜백을 호출 &lt;em&gt;하기 전에 &lt;/em&gt;&lt;a href=&quot;#accounts_validateloginattempt&quot;&gt; &lt;code&gt;Accounts.validateLoginAttempt&lt;/code&gt; 의&lt;/a&gt; 콜백. 이러한 콜백은 성공하지만 실패하면 사용자는 계속 생성되지만 연결은 해당 사용자로 로그인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2aab0de68554c2f9d2c23534c066f46b08990716" translate="yes" xml:space="preserve">
          <source>If there are multiple users with a username or email only differing in case, a case sensitive match is required. Although &lt;code&gt;createUser&lt;/code&gt; won&amp;rsquo;t let you create users with ambiguous usernames or emails, this could happen with existing databases or if you modify the users collection directly.</source>
          <target state="translated">대소 문자 만 다른 사용자 이름 또는 이메일을 가진 여러 사용자가있는 경우 대소 문자를 구분해야합니다. 비록 &lt;code&gt;createUser&lt;/code&gt; 당신이 모호한 사용자 이름 또는 이메일로 사용자를 생성 할 수 없습니다 직접 사용자 수집을 수정하는 경우, 이것은 기존의 데이터베이스와 일 또는 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="817e3d1c7ee37462fd0e8cfe4b3e638f50a62cd8" translate="yes" xml:space="preserve">
          <source>If there is no current computation and &lt;code&gt;depend()&lt;/code&gt; is called with no arguments, it does nothing and returns false.</source>
          <target state="translated">현재 계산이없고 &lt;code&gt;depend()&lt;/code&gt; 가 인수없이 호출되면 아무 작업도 수행하지 않고 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="17b33175544254dd250f44caa96b1c820435d75f" translate="yes" xml:space="preserve">
          <source>If this file is JavaScript code or will be compiled into JavaScript code by a build plugin, don't wrap the resulting file in a closure. Has the same effect as putting a file into the &lt;code&gt;client/compatibility&lt;/code&gt; directory in an app.</source>
          <target state="translated">이 파일이 JavaScript 코드이거나 빌드 플러그인에 의해 JavaScript 코드로 컴파일되는 경우 결과 파일을 닫지 마십시오. 파일을 앱 의 &lt;code&gt;client/compatibility&lt;/code&gt; 디렉토리에 넣는 것과 같은 효과 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="acdfb992cc79afe4176ec5764edc7138672f8dc2" translate="yes" xml:space="preserve">
          <source>If this template is a &amp;ldquo;smart&amp;rdquo; component that loads server data and accesses the router, append &lt;code&gt;_page&lt;/code&gt; to the name:</source>
          <target state="translated">이 템플릿이 서버 데이터를로드하고 라우터에 액세스하는 &quot;스마트&quot;구성 요소 인 경우 이름에 &lt;code&gt;_page&lt;/code&gt; 를 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="3e2beb9d526ea953a6af4e3b7966daac6dcc4894" translate="yes" xml:space="preserve">
          <source>If true, asks the user for permission to act on their behalf when offline. This stores an additional offline token in the &lt;code&gt;services&lt;/code&gt; field of the user document. Currently only supported with Google.</source>
          <target state="translated">true이면 오프라인 일 때 사용자를 대신하여 작업 할 수있는 권한을 사용자에게 요청합니다. 사용자 문서 의 &lt;code&gt;services&lt;/code&gt; 필드에 추가 오프라인 토큰을 저장합니다 . 현재 Google에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="ef8ffda122ef746673a4f129a3cf7773ea4dda80" translate="yes" xml:space="preserve">
          <source>If true, forces the user to approve the app's permissions, even if previously approved. Currently only supported with Google.</source>
          <target state="translated">true 인 경우 이전에 승인 된 경우에도 사용자가 앱의 권한을 승인하도록합니다. 현재 Google에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="3dec2ec903c1d9bed96d0c5732a548c85a313951" translate="yes" xml:space="preserve">
          <source>If true, this symbol will only be exported when running tests for this package.</source>
          <target state="translated">true 인 경우이 기호는이 패키지에 대한 테스트를 실행할 때만 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="816592e9a7f706b71f78dc4c21a438bba4f5ada5" translate="yes" xml:space="preserve">
          <source>If using &quot;redirect&quot; login style, the user will be returned to this URL after authorisation has been completed.</source>
          <target state="translated">&quot;리디렉션&quot;로그인 스타일을 사용하는 경우 인증이 완료된 후 사용자가이 URL로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="f434f553446118d172aee2015a1698385fbddd3f" translate="yes" xml:space="preserve">
          <source>If value is a scalar, then these two expressions do the same thing:</source>
          <target state="translated">value가 스칼라 인 경우이 두 표현식은 동일한 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="8d4f8a30a2b4b0eb7d59c43418b3a77576996f3a" translate="yes" xml:space="preserve">
          <source>If we defined this Method in client and server code, as all Methods should be, a Method simulation is executed in the client that called it.</source>
          <target state="translated">클라이언트와 서버 코드에서이 메소드를 정의한 경우 모든 메소드가 있어야하므로 메소드를 호출 한 클라이언트에서 메소드 시뮬레이션이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f07138b6c6c4818214c354c3a4f0782d3d62e5c5" translate="yes" xml:space="preserve">
          <source>If we have any publications on the page that have been affected by the database writes from this Method, the server sends the appropriate updates to the client. Note that the client data system doesn&amp;rsquo;t reveal these updates to the app UI until the next step.</source>
          <target state="translated">이 메소드의 데이터베이스 쓰기에 영향을받은 페이지에 발행물이있는 경우 서버는 적절한 업데이트를 클라이언트에 보냅니다. 클라이언트 데이터 시스템은 다음 단계까지 이러한 업데이트를 앱 UI에 공개하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b5bb120936667fc7c69d5cda8b46e689ced2d89a" translate="yes" xml:space="preserve">
          <source>If you also want to change the logged-in user on the client, then after calling &lt;code&gt;setUserId&lt;/code&gt; on the server, call &lt;code&gt;Meteor.connection.setUserId(userId)&lt;/code&gt; on the client.</source>
          <target state="translated">클라이언트에서 로그인 한 사용자도 변경하려면 서버에서 &lt;code&gt;setUserId&lt;/code&gt; 를 호출 한 후 클라이언트에서 &lt;code&gt;Meteor.connection.setUserId(userId)&lt;/code&gt; 를 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="788d043c0fb3fc8b9b1f135d3ca58a12cc807709" translate="yes" xml:space="preserve">
          <source>If you are a package author, in addition to putting &lt;code&gt;api.use('modules')&lt;/code&gt; or &lt;code&gt;api.use('ecmascript')&lt;/code&gt; in the &lt;code&gt;Package.onUse&lt;/code&gt; section of your &lt;code&gt;package.js&lt;/code&gt; file, you can also use a new API called &lt;code&gt;api.mainModule&lt;/code&gt; to specify the main entry point for your package:</source>
          <target state="translated">패키지 작성자 인 경우 &lt;code&gt;package.js&lt;/code&gt; 파일 의 &lt;code&gt;Package.onUse&lt;/code&gt; 섹션에 &lt;code&gt;api.use('modules')&lt;/code&gt; 또는 &lt;code&gt;api.use('ecmascript')&lt;/code&gt; 를 넣는 것 외에도 &lt;code&gt;api.mainModule&lt;/code&gt; 라는 새로운 API를 사용할 수도 있습니다 패키지의 기본 진입 점을 지정하는 .mainModule :</target>
        </trans-unit>
        <trans-unit id="d21642096bcfaa645b8d17141a6f4d338fa53a3e" translate="yes" xml:space="preserve">
          <source>If you are familiar with modules in Node, you might expect modules not to be evaluated until the first time you import them. However, because earlier versions of Meteor evaluated all of your code when the application started, and we care about backwards compatibility, eager evaluation is still the default behavior.</source>
          <target state="translated">Node의 모듈에 익숙한 경우 처음 가져올 때까지 모듈이 평가되지 않을 수 있습니다. 그러나 이전 버전의 Meteor는 응용 프로그램이 시작될 때 모든 코드를 평가했으며 이전 버전과의 호환성을 염려하기 때문에 열성적인 평가가 여전히 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="5ebda88d01db28805009fc87fd2a2245e494587f" translate="yes" xml:space="preserve">
          <source>If you are following &lt;a href=&quot;security#ssl&quot;&gt;our advice&lt;/a&gt;, you&amp;rsquo;ll probably want to &lt;a href=&quot;http://galaxy-guide.meteor.com/encryption.html&quot;&gt;set up SSL&lt;/a&gt; on your Galaxy application with the certificate and key for your domain. You should also read the &lt;a href=&quot;security#ssl&quot;&gt;Security&lt;/a&gt; section of this guide for information on how to forcibly redirect HTTP to HTTPS.</source>
          <target state="translated">&lt;a href=&quot;security#ssl&quot;&gt;Google의 조언을&lt;/a&gt; 따르는 경우 Galaxy 응용 프로그램에서 도메인의 인증서와 키를 사용하여 &lt;a href=&quot;http://galaxy-guide.meteor.com/encryption.html&quot;&gt;SSL&lt;/a&gt; 을 설정하는 것이 좋습니다. HTTP를 HTTPS로 강제로 리디렉션하는 방법에 대한 정보는이 안내서 의 &lt;a href=&quot;security#ssl&quot;&gt;보안&lt;/a&gt; 섹션을 읽어야합니다 .</target>
        </trans-unit>
        <trans-unit id="ec2da9b73ca892139e92afc2774d7ee5c4fc3049" translate="yes" xml:space="preserve">
          <source>If you are hosting a webfont as part of your application and serving it via a CDN, you may need to configure the served headers for the font to allow cross-origin resource sharing (as the webfont is now served from a different origin to your site itself). You can do this easily enough in Meteor by adding a handler (you&amp;rsquo;ll need to ensure your CDN is passing the header through):</source>
          <target state="translated">응용 프로그램의 일부로 웹 폰트를 호스팅하고 CDN을 통해 웹 폰트를 제공하는 경우, 웹 폰트가 다른 출처에서 귀하의 사이트로 제공되므로 교차 출처 리소스 공유를 허용하도록 해당 폰트에 대해 제공된 헤더를 구성해야 할 수 있습니다 그 자체). 핸들러를 추가하여 Meteor에서이를 쉽게 수행 할 수 있습니다 (CDN이 헤더를 통과하는지 확인해야 함).</target>
        </trans-unit>
        <trans-unit id="d2c577722b11f969b8bd32347a448e2c449248d7" translate="yes" xml:space="preserve">
          <source>If you are looking to write an Atmosphere package that wraps such a component, you need to take some &lt;a href=&quot;#atmosphere-packages&quot;&gt;further steps&lt;/a&gt;.</source>
          <target state="translated">이러한 구성 요소를 래핑하는 Atmosphere 패키지를 작성하려면 몇 가지 &lt;a href=&quot;#atmosphere-packages&quot;&gt;추가 단계를 수행&lt;/a&gt; 해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="8fb4dd30c782f92e559875fa4cb72b2966ae7583" translate="yes" xml:space="preserve">
          <source>If you are running a test that relies on using the database, and specifically the content of the database, you&amp;rsquo;ll need to perform some &lt;em&gt;setup&lt;/em&gt; steps in your test to ensure the database is in the state you expect. There are some tools you can use to do this.</source>
          <target state="translated">데이터베이스를 사용하는 테스트, 특히 데이터베이스의 컨텐츠에 의존하는 테스트를 실행하는 경우 테스트 에서 데이터베이스가 예상 상태에 있는지 확인 하기 위해 몇 가지 &lt;em&gt;설정&lt;/em&gt; 단계 를 수행해야합니다 . 이를 수행하는 데 사용할 수있는 도구가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b84b1c7a471fcb5f7807f6f6faaa8c384852263" translate="yes" xml:space="preserve">
          <source>If you are running on your own &lt;a href=&quot;deployment#custom-deployment&quot;&gt;infrastructure&lt;/a&gt;, there are a few options for setting up SSL, mostly through configuring a proxy web server. See the articles: &lt;a href=&quot;http://joshowens.me/ssl-and-meteor-js/&quot;&gt;Josh Owens on SSL and Meteor&lt;/a&gt;, &lt;a href=&quot;http://www.meteorpedia.com/read/SSL&quot;&gt;SSL on Meteorpedia&lt;/a&gt;, and &lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-deploy-a-meteor-js-application-on-ubuntu-14-04-with-nginx&quot;&gt;Digital Ocean tutorial with an Nginx config&lt;/a&gt;.</source>
          <target state="translated">자체 &lt;a href=&quot;deployment#custom-deployment&quot;&gt;인프라&lt;/a&gt; 에서 실행중인 경우 주로 프록시 웹 서버 구성을 통해 SSL을 설정하는 몇 가지 옵션이 있습니다. : 기사 참조 &lt;a href=&quot;http://joshowens.me/ssl-and-meteor-js/&quot;&gt;조쉬 오웬스 SSL 및 유성에&lt;/a&gt; , &lt;a href=&quot;http://www.meteorpedia.com/read/SSL&quot;&gt;Meteorpedia에 SSL&lt;/a&gt; 및 &lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-deploy-a-meteor-js-application-on-ubuntu-14-04-with-nginx&quot;&gt;의 Nginx의 설정과 디지털 오션 자습서를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="00b7fbb4db82beecfc26e25ccb6be5dc4176346d" translate="yes" xml:space="preserve">
          <source>If you are using an off-the-shelf login UI like &lt;code&gt;accounts-ui&lt;/code&gt; or &lt;code&gt;useraccounts&lt;/code&gt;, you don&amp;rsquo;t need to write any code after adding the relevant package from the list above. If you are building a login experience from scratch, you can log in programmatically using the &lt;a href=&quot;http://docs.meteor.com/#/full/meteor_loginwithexternalservice&quot;&gt;&lt;code&gt;Meteor.loginWith&amp;lt;Service&amp;gt;&lt;/code&gt;&lt;/a&gt; function. It looks like this:</source>
          <target state="translated">&lt;code&gt;accounts-ui&lt;/code&gt; 또는 &lt;code&gt;useraccounts&lt;/code&gt; 와 같은 상용 로그인 UI를 사용하는 경우 위 목록에서 관련 패키지를 추가 한 후 코드를 작성할 필요가 없습니다. 처음부터 로그인 환경을 구축하는 경우 &lt;a href=&quot;http://docs.meteor.com/#/full/meteor_loginwithexternalservice&quot;&gt; &lt;code&gt;Meteor.loginWith&amp;lt;Service&amp;gt;&lt;/code&gt; &lt;/a&gt; 기능을 사용하여 프로그래밍 방식으로 로그인 할 수 있습니다 . 다음과 같이 보입니다 :</target>
        </trans-unit>
        <trans-unit id="d8aa0b0804bd0e52d77c6e2eaa9cb79bae275633" translate="yes" xml:space="preserve">
          <source>If you are using the &lt;a href=&quot;#accounts_api&quot;&gt;built-in Meteor accounts system&lt;/a&gt; then this should correspond to the &lt;code&gt;_id&lt;/code&gt; field of a document in the &lt;a href=&quot;#meteor_users&quot;&gt;&lt;code&gt;Meteor.users&lt;/code&gt;&lt;/a&gt; collection.</source>
          <target state="translated">&lt;a href=&quot;#accounts_api&quot;&gt;내장 Meteor 계정 시스템&lt;/a&gt; 을 사용하는 경우 이는 &lt;a href=&quot;#meteor_users&quot;&gt; &lt;code&gt;Meteor.users&lt;/code&gt; &lt;/a&gt; 컬렉션 에있는 문서 의 &lt;code&gt;_id&lt;/code&gt; 필드와 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="aa9cbac2148670526d3d519e5dee6ea130222409" translate="yes" xml:space="preserve">
          <source>If you are using the &lt;a href=&quot;#accountsui&quot;&gt;&lt;code&gt;accounts-ui&lt;/code&gt; package&lt;/a&gt;, this is handled automatically. Otherwise, it is your responsibility to prompt the user for the new password and call &lt;code&gt;resetPassword&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#accountsui&quot;&gt; &lt;code&gt;accounts-ui&lt;/code&gt; package를&lt;/a&gt; 사용하는 경우 이는 자동으로 처리됩니다. 그렇지 않으면 사용자에게 새 비밀번호를 묻고 &lt;code&gt;resetPassword&lt;/code&gt; 를 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="06bcc9e78c2bb21dcb3079aac6d84540f5b3aefe" translate="yes" xml:space="preserve">
          <source>If you are writing a sufficiently complex system, there can come a time where it makes sense to split your code up into multiple applications. For example you may want to create a separate application for the administration UI (rather than checking permissions all through the admin part of your site, you can check once), or separate the code for the mobile and desktop versions of your app.</source>
          <target state="translated">충분히 복잡한 시스템을 작성하는 경우 코드를 여러 응용 프로그램으로 나누는 것이 합리적 일 수 있습니다. 예를 들어, 사이트의 관리자 부분을 통해 권한을 모두 확인하지 않고 관리 UI에 대한 별도의 응용 프로그램을 만들거나 한 번만 확인하면됩니다. 또는 모바일 및 데스크톱 버전의 앱 코드를 분리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="7f83f266fe7c51111db4542f3327157af67710c3" translate="yes" xml:space="preserve">
          <source>If you are writing an Atmosphere package and want to depend on React or an npm package that itself depends on React, you can&amp;rsquo;t use &lt;code&gt;Npm.depends()&lt;/code&gt; and &lt;code&gt;Npm.require()&lt;/code&gt;, as this will result in &lt;em&gt;2&lt;/em&gt; copies of React being installed into the application (and besides &lt;code&gt;Npm.require()&lt;/code&gt; only works on the server).</source>
          <target state="translated">당신은 그 자체가 의존하는 반작용한다는 분위기 패키지를 작성하고에 따라 반응 할 또는 NPM 패키지하는 경우에는 사용할 수 없습니다 &lt;code&gt;Npm.depends()&lt;/code&gt; 와 &lt;code&gt;Npm.require()&lt;/code&gt; 이 발생하므로, &lt;em&gt;2 개&lt;/em&gt; 반작용이되는 사본 응용 프로그램에 설치되고 &lt;code&gt;Npm.require()&lt;/code&gt; 외에는 서버에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e329ffe4d4352ad12312e6534162a4a2e649de79" translate="yes" xml:space="preserve">
          <source>If you are writing your UI in React, you don&amp;rsquo;t need to use the underscore-split names because you can import and export your components using the JavaScript module system.</source>
          <target state="translated">React에서 UI를 작성하는 경우 JavaScript 모듈 시스템을 사용하여 구성 요소를 가져오고 내보낼 수 있으므로 밑줄 분리 이름을 사용할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="659690531c99cc5e2d95d388f1499fce82ca8944" translate="yes" xml:space="preserve">
          <source>If you call &lt;a href=&quot;#observe&quot;&gt;&lt;code&gt;observe&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#observe_changes&quot;&gt;&lt;code&gt;observeChanges&lt;/code&gt;&lt;/a&gt; in your publish handler, this is the place to stop the observes.</source>
          <target state="translated">공개 핸들러에서 &lt;a href=&quot;#observe&quot;&gt; &lt;code&gt;observe&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#observe_changes&quot;&gt; &lt;code&gt;observeChanges&lt;/code&gt; &lt;/a&gt; 를 호출하면 관찰 이 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="f940f6361999d494cb3913faecf1eef5363643fe" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;Meteor.subscribe&lt;/code&gt; within a &lt;a href=&quot;#reactivity&quot;&gt;reactive computation&lt;/a&gt;, for example using &lt;a href=&quot;#tracker_autorun&quot;&gt;&lt;code&gt;Tracker.autorun&lt;/code&gt;&lt;/a&gt;, the subscription will automatically be cancelled when the computation is invalidated or stopped; it is not necessary to call &lt;code&gt;stop&lt;/code&gt; on subscriptions made from inside &lt;code&gt;autorun&lt;/code&gt;. However, if the next iteration of your run function subscribes to the same record set (same name and parameters), Meteor is smart enough to skip a wasteful unsubscribe/resubscribe. For example:</source>
          <target state="translated">예를 들어 &lt;a href=&quot;#tracker_autorun&quot;&gt; &lt;code&gt;Tracker.autorun&lt;/code&gt; &lt;/a&gt; 등을 사용하여 &lt;a href=&quot;#reactivity&quot;&gt;반응 형 계산&lt;/a&gt; 내에서 &lt;code&gt;Meteor.subscribe&lt;/code&gt; 를 호출 하면 계산이 무효화되거나 중지 될 때 구독이 자동으로 취소됩니다. &lt;code&gt;autorun&lt;/code&gt; 내부에서 만든 구독에 대해서는 &lt;code&gt;stop&lt;/code&gt; 을 호출 할 필요가 없습니다 . 그러나 다음 번 실행 기능 반복이 동일한 레코드 세트 (동일한 이름 및 매개 변수)를 구독하는 경우 Meteor는 낭비적인 구독 취소 / 다시 구독을 건너 뛸 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="363327b954cca9f195c1c649f444f45739a2e788" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;retrieveCredential&lt;/code&gt; (such as &lt;code&gt;Twitter.retrieveCredential&lt;/code&gt;) as part of your process, you&amp;rsquo;ll find when using oauth-encryption that the sensitive service data fields will be encrypted.</source>
          <target state="translated">프로세스의 일부로 &lt;code&gt;retrieveCredential&lt;/code&gt; (예 : &lt;code&gt;Twitter.retrieveCredential&lt;/code&gt; ) 을 호출 하면 oauth-encryption을 사용할 때 민감한 서비스 데이터 필드가 암호화됩니다.</target>
        </trans-unit>
        <trans-unit id="1a2a8c9ff8959cd1adc8f20009a2ba8c4e5965f4" translate="yes" xml:space="preserve">
          <source>If you call a Method from the client, and the user&amp;rsquo;s Internet connection disconnects before the result is received, Meteor assumes that the Method didn&amp;rsquo;t actually run. When the connection is re-established, the Method call will be sent again. This means that, in certain situations, Methods can be sent more than once. This should only happen very rarely, but in the case where an extra Method call could have negative consequences it is worth putting in extra effort to ensure that Methods are idempotent - that is, calling them multiple times doesn&amp;rsquo;t result in additional changes to the database.</source>
          <target state="translated">클라이언트에서 메소드를 호출하고 결과가 수신되기 전에 사용자의 인터넷 연결이 끊어지면 Meteor는 메소드가 실제로 실행되지 않은 것으로 가정합니다. 연결이 다시 설정되면 메소드 호출이 다시 전송됩니다. 이는 특정 상황에서 메소드를 두 번 이상 전송할 수 있음을 의미합니다. 이것은 매우 드물게 발생하지만, 추가적인 Method 호출이 부정적인 결과를 초래할 수있는 경우, Methods가 ent 등성이 없도록하기 위해 추가 노력을 기울일 필요가 있습니다. 즉, 여러 번 호출해도 데이터 베이스.</target>
        </trans-unit>
        <trans-unit id="2b45991fd53c406dd8ba5027a0a2ef5841574572" translate="yes" xml:space="preserve">
          <source>If you declare your function &lt;code&gt;async&lt;/code&gt; (which ends up meaning it returns a Promise itself), then you can use the &lt;code&gt;await&lt;/code&gt; keyword to wait on other promise inside. This makes it very easy to serially call Promise-based libraries:</source>
          <target state="translated">함수를 &lt;code&gt;async&lt;/code&gt; 로 선언하면 (단, Promise 자체를 반환 함을 의미 함) &lt;code&gt;await&lt;/code&gt; 키워드를 사용하여 다른 약속을 기다릴 수 있습니다 . 이를 통해 Promise 기반 라이브러리를 직렬로 매우 쉽게 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd785af84fa7dff0dbf544f602fd98895d4d3b63" translate="yes" xml:space="preserve">
          <source>If you do define a stub, when a client invokes a server method it will also run its stub in parallel. On the client, the return value of a stub is ignored. Stubs are run for their side-effects: they are intended to &lt;em&gt;simulate&lt;/em&gt; the result of what the server&amp;rsquo;s method will do, but without waiting for the round trip delay. If a stub throws an exception it will be logged to the console.</source>
          <target state="translated">스텁을 정의하면 클라이언트가 서버 메소드를 호출 할 때 스텁도 병렬로 실행됩니다. 클라이언트에서는 스텁의 반환 값이 무시됩니다. 스텁은 부작용으로 실행됩니다 . 서버 지연 시간을 기다리지 않고 서버 방법의 결과 를 &lt;em&gt;시뮬레이션&lt;/em&gt; 하기위한 것 입니다. 스텁에서 예외가 발생하면 콘솔에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="6148c0d6b3374c86a11ad5b57f1396a9d7e550bc" translate="yes" xml:space="preserve">
          <source>If you do not pass a callback on the server, the method invocation will block until the method is complete. It will eventually return the return value of the method, or it will throw an exception if the method threw an exception. (Possibly mapped to 500 Server Error if the exception happened remotely and it was not a &lt;code&gt;Meteor.Error&lt;/code&gt; exception.)</source>
          <target state="translated">서버에서 콜백을 전달하지 않으면 메소드가 완료 될 때까지 메소드 호출이 차단됩니다. 결국 메서드의 반환 값을 반환하거나 메서드에서 예외가 발생하면 예외가 발생합니다. (예외가 원격으로 발생하고 &lt;code&gt;Meteor.Error&lt;/code&gt; 예외 가 아닌 경우 500 서버 오류에 매핑되었을 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="fd4ae11be9d693e1df07c25a2b8223c096072e18" translate="yes" xml:space="preserve">
          <source>If you do not, you&amp;rsquo;ll see performance problems across the board: you&amp;rsquo;ll be flooding the user&amp;rsquo;s network connection with a lot of small changes, the UI will update on every keystroke, potentially causing poor performance, and your database will suffer with a lot of writes.</source>
          <target state="translated">그렇지 않으면 전반에 걸쳐 성능 문제가 나타납니다. 많은 작은 변경 사항으로 사용자의 네트워크 연결이 과도하게 사용되며, 키를 누를 때마다 UI가 업데이트되어 성능이 저하 될 수 있으며 데이터베이스가 손상 될 수 있습니다. 많은 쓰기.</target>
        </trans-unit>
        <trans-unit id="76fb23773566e23e36d33206e24cdb3178ab9aa9" translate="yes" xml:space="preserve">
          <source>If you do want to run on an emulator however, you will have to create an Android Virtual Device (AVD) using the &lt;a href=&quot;http://developer.android.com/tools/devices/managing-avds.html&quot;&gt;AVD Manager&lt;/a&gt;. Make sure to configure an AVD with an API level that is supported by the version of &lt;a href=&quot;https://github.com/apache/cordova-android/blob/master/RELEASENOTES.md&quot;&gt;Cordova Android&lt;/a&gt; you are using.</source>
          <target state="translated">그러나 에뮬레이터에서 실행하려면 &lt;a href=&quot;http://developer.android.com/tools/devices/managing-avds.html&quot;&gt;AVD 관리자를&lt;/a&gt; 사용하여 Android 가상 장치 (AVD)를 만들어야합니다 . 사용중인 &lt;a href=&quot;https://github.com/apache/cordova-android/blob/master/RELEASENOTES.md&quot;&gt;Cordova Android&lt;/a&gt; 버전에서 지원하는 API 레벨로 AVD를 구성하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a16236bdfe301b23681c3e64d38581d168c40e3" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t like the Spacebars syntax Meteor uses by default and want something more concise, you can give Jade a try by using &lt;a href=&quot;https://atmospherejs.com/pacreach/jade&quot;&gt;&lt;code&gt;pacreach:jade&lt;/code&gt;&lt;/a&gt;. This package will compile all files in your app with the &lt;code&gt;.jade&lt;/code&gt; extension into Blaze-compatible code, and can be used side-by-side with &lt;code&gt;blaze-html-templates&lt;/code&gt; if you want to have some of your code in Spacebars and some in Jade.</source>
          <target state="translated">Meteor가 기본적으로 사용하는 Spacebars 구문이 마음에 들지 않고 더 간결한 것을 원한다면 &lt;a href=&quot;https://atmospherejs.com/pacreach/jade&quot;&gt; &lt;code&gt;pacreach:jade&lt;/code&gt; &lt;/a&gt; 를 사용하여 Jade를 사용해보십시오 . 이 패키지는 확장명 이 &lt;code&gt;.jade&lt;/code&gt; 인 앱의 모든 파일 을 Blaze 호환 코드로 컴파일하며 , 스페이스 바와 Jade에 일부 코드를 저장하려는 경우 &lt;code&gt;blaze-html-templates&lt;/code&gt; 와 함께 사용할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="a95858c1b5bf60634e7f0d372e99009f60aac8a9" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t specify an &lt;code&gt;element&lt;/code&gt;, there must be a current View or an error will be thrown. This is in contrast to &lt;a href=&quot;#Blaze-currentView&quot;&gt;&lt;code&gt;Blaze.currentView&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;element&lt;/code&gt; 를 지정하지 않으면 현재보기가 있어야합니다. 그렇지 않으면 오류가 발생합니다. 이것은 &lt;a href=&quot;#Blaze-currentView&quot;&gt; &lt;code&gt;Blaze.currentView&lt;/code&gt; &lt;/a&gt; 와 대조적 입니다.</target>
        </trans-unit>
        <trans-unit id="cd239e7eea9e7f823e105095f42ad9b54c4839d8" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to configure routing for your login flow, you can just drop in a self-managing accounts screen. Wherever you want the accounts UI template to render, just include the &lt;code&gt;atForm&lt;/code&gt; template, like so:</source>
          <target state="translated">로그인 흐름에 대한 라우팅을 구성하지 않으려면 자체 관리 계정 화면으로 이동하면됩니다. 계정 UI 템플릿을 렌더링하려는 경우 다음과 같이 &lt;code&gt;atForm&lt;/code&gt; 템플릿을 포함하십시오 .</target>
        </trans-unit>
        <trans-unit id="b1573469eb7f247c50ce7fbab146e00b26b3f812" translate="yes" xml:space="preserve">
          <source>If you find details which are not covered here, please discuss it using the &amp;ldquo;Discuss&amp;rdquo; button above, or if you have something super important, open a pull-request to this article using the &amp;ldquo;Edit on GitHub&amp;rdquo; button above!</source>
          <target state="translated">여기에서 다루지 않은 세부 정보를 찾으면 위의 &quot;토론&quot;단추를 사용하여 자세히 설명하거나 중요한 것이 있으면 위의 &quot;GitHub에서 편집&quot;단추를 사용하여이 기사에 대한 전체 요청을여십시오!</target>
        </trans-unit>
        <trans-unit id="65bc36c47d894f01a4e87b238fceb3d19a9623f5" translate="yes" xml:space="preserve">
          <source>If you find you need to roll your code version back, you&amp;rsquo;ll need to be careful about the data, and step carefully through your deployment steps in reverse.</source>
          <target state="translated">코드 버전을 롤백해야하는 경우 데이터에주의를 기울이고 배포 단계를 반대로 신중하게 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="32c6f2c42b738be2d574541d656f4e171c4fc143" translate="yes" xml:space="preserve">
          <source>If you find yourself repeating the fields often, it makes sense to factor out a dictionary of public fields that you can always filter by, like so:</source>
          <target state="translated">필드를 자주 반복하는 경우 다음과 같이 항상 필터링 할 수있는 공용 필드 사전을 제외시키는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="60508d0195278e02c7f01b6c3816fe005d0a2af0" translate="yes" xml:space="preserve">
          <source>If you have a Meteor Method in your app that has secret business logic, you might want to split the Method into two functions - the optimistic UI part that will run on the client, and the secret part that runs on the server. Most of the time, putting the entire Method on the server doesn&amp;rsquo;t result in the best user experience. Let&amp;rsquo;s look at an example, where you have a secret algorithm for calculating someone&amp;rsquo;s MMR (ranking) in a game:</source>
          <target state="translated">앱에 비밀 비즈니스 로직이있는 Meteor 메소드가있는 경우 메소드를 두 개의 기능 (클라이언트에서 실행되는 낙관적 UI 부분과 서버에서 실행되는 비밀 부분)으로 분할 할 수 있습니다. 대부분의 경우 전체 메소드를 서버에 배치한다고해서 최상의 사용자 경험이되지는 않습니다. 게임에서 누군가의 MMR (순위)을 계산하기위한 비밀 알고리즘이있는 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="8156151f762a8b5bb399c6b5390e667ddae668b7" translate="yes" xml:space="preserve">
          <source>If you have common functionality for a template instance that needs to be abstracted or called from multiple event handlers, it&amp;rsquo;s sensible to attach it as functions directly to the template instance in the &lt;code&gt;onCreated()&lt;/code&gt; callback:</source>
          <target state="translated">여러 이벤트 핸들러에서 추상화하거나 호출해야하는 템플릿 인스턴스에 대한 공통 기능이있는 경우 &lt;code&gt;onCreated()&lt;/code&gt; 콜백 에서 템플릿 인스턴스에 직접 함수로 첨부하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="5fe8e1ee5bcaefed08e7a001aa1e129aa98523ac" translate="yes" xml:space="preserve">
          <source>If you have customized the URL, you will need to add a new route to your router that handles the URL you have specified, and the default &lt;code&gt;Accounts.onResetPasswordLink&lt;/code&gt; and friends won&amp;rsquo;t work for you.</source>
          <target state="translated">URL을 사용자 정의한 경우, 지정한 URL을 처리하는 새 경로를 라우터에 추가해야하며 기본 &lt;code&gt;Accounts.onResetPasswordLink&lt;/code&gt; 및 친구가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2576bf6b17f6256f97eaf30e6197009d3a4bb8a9" translate="yes" xml:space="preserve">
          <source>If you have files too large to fit in the cache you can disable caching by URL prefix. For example,</source>
          <target state="translated">캐시에 맞지 않는 파일이 너무 큰 경우 URL 접두사로 캐싱을 비활성화 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="55c37bdac67940dd6c04beee487794a450e41286" translate="yes" xml:space="preserve">
          <source>If you have installed the &lt;a href=&quot;https://crosswalk-project.org/&quot;&gt;Crosswalk plugin&lt;/a&gt; you will need to manually copy the APK file &lt;code&gt;cp ~/build-output-directory/android/project/build/outputs/apk/android-armv7-release-unsigned.apk ~/build-output-directory/android/release-unsigned.apk&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;https://crosswalk-project.org/&quot;&gt;Crosswalk 플러그인&lt;/a&gt; 을 설치 한 경우 APK 파일 &lt;code&gt;cp ~/build-output-directory/android/project/build/outputs/apk/android-armv7-release-unsigned.apk ~/build-output-directory/android/release-unsigned.apk&lt;/code&gt; 를 수동으로 복사해야합니다. directory / android / release-unsigned.apk</target>
        </trans-unit>
        <trans-unit id="19d4f62e5ed43836a90bb2599b61937b57ea459e" translate="yes" xml:space="preserve">
          <source>If you have two servers that access the same database and you want authenticated users to make DDP calls across the both of them, you can use the &lt;em&gt;resume token&lt;/em&gt; set on one connection to login on the other.</source>
          <target state="translated">동일한 데이터베이스에 액세스하는 두 개의 서버가 있고 인증 된 사용자가 두 서버에서 DDP 호출을하도록하려면 한 연결에서 설정된 &lt;em&gt;재개 토큰을&lt;/em&gt; 사용하여 다른 연결에서 로그인 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="708491dd1370be5e5338376bb313b8787ead6f4a" translate="yes" xml:space="preserve">
          <source>If you include a callback function as the last argument (which can&amp;rsquo;t be an argument to the method, since functions aren&amp;rsquo;t serializable), the method will run asynchronously: it will return nothing in particular and will not throw an exception. When the method is complete (which may or may not happen before &lt;code&gt;Meteor.call&lt;/code&gt; returns), the callback will be called with two arguments: &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;result&lt;/code&gt;. If an error was thrown, then &lt;code&gt;error&lt;/code&gt; will be the exception object. Otherwise, &lt;code&gt;error&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt; and the return value (possibly &lt;code&gt;undefined&lt;/code&gt;) will be in &lt;code&gt;result&lt;/code&gt;.</source>
          <target state="translated">콜백 함수를 마지막 인수로 포함하면 (함수를 직렬화 할 수 없기 때문에 메소드에 대한 인수가 될 수 없음) 메소드는 비동기 적으로 실행됩니다. 특히 아무것도 리턴하지 않으며 예외를 발생시키지 않습니다. 메소드가 완료되면 ( &lt;code&gt;Meteor.call&lt;/code&gt; 이 리턴 되기 전에 발생하거나 발생하지 않을 수 있음 ), 콜백은 &lt;code&gt;error&lt;/code&gt; 및 &lt;code&gt;result&lt;/code&gt; 의 두 인수로 호출됩니다 . 오류가 발생 된 경우, &lt;code&gt;error&lt;/code&gt; 예외 객체가 될 것입니다. 그렇지 않으면 &lt;code&gt;error&lt;/code&gt; 가 &lt;code&gt;undefined&lt;/code&gt; 않고 반환 값 (아마도 &lt;code&gt;undefined&lt;/code&gt; )이 &lt;code&gt;result&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="9c09f3964469e3d6071e869f94fc554ee91ba160" translate="yes" xml:space="preserve">
          <source>If you need more control, you can use the comprehensive &lt;a href=&quot;https://atmospherejs.com/nimble/restivus&quot;&gt;&lt;code&gt;nimble:restivus&lt;/code&gt;&lt;/a&gt; package to create more or less whatever you need in whatever ontology you require.</source>
          <target state="translated">더 많은 제어가 필요한 경우 포괄적 인 &lt;a href=&quot;https://atmospherejs.com/nimble/restivus&quot;&gt; &lt;code&gt;nimble:restivus&lt;/code&gt; &lt;/a&gt; 패키지를 사용하여 필요한 온톨로지에 필요한 것을 더 많거나 적게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69e1d32387fa3bf1f8850dd2be1963668d185452" translate="yes" xml:space="preserve">
          <source>If you need to &lt;code&gt;require&lt;/code&gt; from an ES2015 module with a &lt;code&gt;default&lt;/code&gt; export, you can grab the export with &lt;code&gt;require(&quot;package&quot;).default&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; 내보내기 를 사용하여 ES2015 모듈에서 필요로 &lt;code&gt;require&lt;/code&gt; 경우 &lt;code&gt;require(&quot;package&quot;).default&lt;/code&gt; 로 내보내기를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="32f5a311eb54e0e89f2a82767a1d291a18a86abb" translate="yes" xml:space="preserve">
          <source>If you need to communicate &lt;em&gt;up&lt;/em&gt; the component hierarchy, it&amp;rsquo;s best to pass a &lt;em&gt;callback&lt;/em&gt; for the sub-component to call.</source>
          <target state="translated">당신이 의사 소통을해야하는 경우 &lt;em&gt;최대&lt;/em&gt; 구성 요소 계층 구조를, 그것을 통과하는 것이 가장 좋습니다 &lt;em&gt;콜백을&lt;/em&gt; 호출 하위 구성 요소에 대한.</target>
        </trans-unit>
        <trans-unit id="a950a357df8eb170b55154af24dd529d3c231d91" translate="yes" xml:space="preserve">
          <source>If you need to customize configuration files, a workaround is to create a dummy Cordova plugin. In its &lt;code&gt;plugin.xml&lt;/code&gt;, you can specify a &lt;a href=&quot;https://cordova.apache.org/docs/en/dev/plugin_ref/spec.html#config-file&quot;&gt;&lt;code&gt;config-file&lt;/code&gt; element&lt;/a&gt; to selectively change parts of configuration files, including &lt;code&gt;config.xml&lt;/code&gt;.</source>
          <target state="translated">구성 파일을 사용자 정의해야하는 경우 임시 Cordova 플러그인을 작성하십시오. 그것에서 &lt;code&gt;plugin.xml&lt;/code&gt; 에 , 당신은 지정할 수 있습니다 &lt;a href=&quot;https://cordova.apache.org/docs/en/dev/plugin_ref/spec.html#config-file&quot;&gt; &lt;code&gt;config-file&lt;/code&gt; 요소&lt;/a&gt; 를 포함하여 구성 파일을 선택적으로 변경 부분에 &lt;code&gt;config.xml&lt;/code&gt; 파일을 .</target>
        </trans-unit>
        <trans-unit id="023f7fb7bd41613742fdd31b445948d2c96152f8" translate="yes" xml:space="preserve">
          <source>If you need to modify a package to do something that the published version doesn&amp;rsquo;t do, you can edit a local version of the package on your computer.</source>
          <target state="translated">게시 된 버전이 수행하지 않는 작업을 수행하기 위해 패키지를 수정해야하는 경우 컴퓨터에서 로컬 버전의 패키지를 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e59c515e053f34b94356278d4d589171811b978" translate="yes" xml:space="preserve">
          <source>If you need to modify an Atmosphere package to do something that the published version doesn&amp;rsquo;t do, you can edit a local version of the package on your computer.</source>
          <target state="translated">게시 된 버전이 수행하지 않는 작업을 수행하기 위해 Atmosphere 패키지를 수정해야하는 경우 컴퓨터에서 로컬 버전의 패키지를 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6719ea6fd09d8642115e2738b2fa7b3c19b86c2e" translate="yes" xml:space="preserve">
          <source>If you need to pass in content to a sub-component (for instance the content of a modal dialog), you can use the &lt;a href=&quot;spacebars#Block-Helpers&quot;&gt;custom block helper&lt;/a&gt; to provide a block of content. If you need more flexibility, typically just providing the component name as an argument is the way to go. The sub-component can then just render that component with:</source>
          <target state="translated">컨텐츠를 하위 컴포넌트 (예 : 모달 대화 상자의 컨텐츠)로 전달해야하는 경우 &lt;a href=&quot;spacebars#Block-Helpers&quot;&gt;사용자 정의 블록 도우미&lt;/a&gt; 를 사용하여 컨텐츠 블록을 제공 할 수 있습니다 . 유연성이 더 필요한 경우 일반적으로 구성 요소 이름을 인수로 제공하는 것이 좋습니다. 하위 구성 요소는 다음과 같이 해당 구성 요소를 렌더링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60e1562de4c4577b416776c8f13b5ce755259251" translate="yes" xml:space="preserve">
          <source>If you need to perform complex logic in the update (e.g. not just call &lt;code&gt;.set()&lt;/code&gt; etc), it&amp;rsquo;s a good idea to define a mutator on the store. As the store is a singleton, you can just attach a function to the object directly:</source>
          <target state="translated">업데이트에서 복잡한 로직을 수행해야하는 경우 (예 : &lt;code&gt;.set()&lt;/code&gt; 등을 호출하지 않음 ) 상점에서 뮤 테이터를 정의하는 것이 좋습니다. 상점이 싱글 톤이므로 함수를 객체에 직접 첨부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="654272e3ce4909f8985019cb527be487853abbd2" translate="yes" xml:space="preserve">
          <source>If you need to query the store, or store many related items, it&amp;rsquo;s probably a good idea to use a Local Collection (see the &lt;a href=&quot;collections#local-collections&quot;&gt;Collections Article&lt;/a&gt;).</source>
          <target state="translated">상점을 조회하거나 많은 관련 항목을 저장해야하는 경우 로컬 콜렉션을 사용하는 것이 좋습니다 ( &lt;a href=&quot;collections#local-collections&quot;&gt;컬렉션 기사&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6ab6af9f91959a8a24789d29e0b338bb37411702" translate="yes" xml:space="preserve">
          <source>If you need to update a store as a result of user action, you&amp;rsquo;d update the store from an event handler, just like you call &lt;a href=&quot;methods&quot;&gt;Methods&lt;/a&gt;.</source>
          <target state="translated">사용자 조치의 결과로 상점을 업데이트해야하는 경우 &lt;a href=&quot;methods&quot;&gt;Methods&lt;/a&gt; 를 호출 하는 것처럼 이벤트 핸들러에서 상점을 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="efd2957123b064a7818d716974462558124329d7" translate="yes" xml:space="preserve">
          <source>If you need to wait on specific data that you aren&amp;rsquo;t already subscribed to at creation time, you can use an &lt;code&gt;autorun&lt;/code&gt; and &lt;code&gt;subscriptionsReady()&lt;/code&gt; to wait on that subscription:</source>
          <target state="translated">생성시 아직 구독하지 않은 특정 데이터를 기다려야하는 경우 &lt;code&gt;autorun&lt;/code&gt; 및 &lt;code&gt;subscriptionsReady()&lt;/code&gt; 를 사용하여 해당 구독을 기다릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f3346d500969dfc5716aa94a72a5dfd4cd9fcf2" translate="yes" xml:space="preserve">
          <source>If you nest calls to &lt;code&gt;Tracker.autorun&lt;/code&gt;, then when the outer call stops or reruns, the inner call will stop automatically. Subscriptions and observers are also automatically stopped when used as part of a computation that is rerun, allowing new ones to be established. See &lt;a href=&quot;#meteor_subscribe&quot;&gt;&lt;code&gt;Meteor.subscribe&lt;/code&gt;&lt;/a&gt; for more information about subscriptions and reactivity.</source>
          <target state="translated">&lt;code&gt;Tracker.autorun&lt;/code&gt; 에 호출을 중첩 하면 외부 호출이 중지되거나 다시 실행될 때 내부 호출이 자동으로 중지됩니다. 구독 및 옵저버도 다시 실행되는 계산의 일부로 사용될 때 자동으로 중지되어 새로운 항목을 설정할 수 있습니다. 구독 및 반응성에 대한 자세한 내용은 &lt;a href=&quot;#meteor_subscribe&quot;&gt; &lt;code&gt;Meteor.subscribe&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eae024890ceb1234290cc4d422f8ed1a2b324cb8" translate="yes" xml:space="preserve">
          <source>If you never set up any &lt;code&gt;allow&lt;/code&gt; rules on a collection then all client writes to the collection will be denied, and it will only be possible to write to the collection from server-side code. In this case you will have to create a method for each possible write that clients are allowed to do. You&amp;rsquo;ll then call these methods with &lt;code&gt;Meteor.call&lt;/code&gt; rather than having the clients call &lt;code&gt;insert&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;, and &lt;code&gt;remove&lt;/code&gt; directly on the collection.</source>
          <target state="translated">컬렉션에 &lt;code&gt;allow&lt;/code&gt; 규칙을 설정하지 않으면 컬렉션에 대한 모든 클라이언트 쓰기가 거부되고 서버 측 코드에서만 컬렉션에 쓸 수 있습니다. 이 경우 클라이언트가 수행 할 수있는 각각의 가능한 쓰기에 대한 메소드를 작성해야합니다. 그런 다음 클라이언트 가 컬렉션에서 직접 &lt;code&gt;insert&lt;/code&gt; , &lt;code&gt;update&lt;/code&gt; 및 &lt;code&gt;remove&lt;/code&gt; 를 호출하지 않고 &lt;code&gt;Meteor.call&lt;/code&gt; 을 사용하여 이러한 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="31353d838973b6f1d6acf793dd0fd42bc4f4e33e" translate="yes" xml:space="preserve">
          <source>If you only use the package on the server (or the client), you can pass in the second argument (e.g., &lt;code&gt;'server'&lt;/code&gt;, &lt;code&gt;'client'&lt;/code&gt;, &lt;code&gt;'web.browser'&lt;/code&gt;, &lt;code&gt;'web.cordova'&lt;/code&gt;) to specify what architecture the package is used with. You can specify multiple architectures by passing in an array, for example &lt;code&gt;['web.cordova', 'os.linux']&lt;/code&gt;.</source>
          <target state="translated">서버 (또는 클라이언트)에서 패키지 만 사용하는 경우 두 번째 인수 (예 : &lt;code&gt;'server'&lt;/code&gt; , &lt;code&gt;'client'&lt;/code&gt; , &lt;code&gt;'web.browser'&lt;/code&gt; , &lt;code&gt;'web.cordova'&lt;/code&gt; )를 전달하여 아키텍처를 지정하십시오 패키지와 함께 사용됩니다. 배열을 전달하여 여러 아키텍처를 지정할 수 있습니다 (예 : &lt;code&gt;['web.cordova', 'os.linux']&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70eda8c785500d1835d716f8bcc7b8608c610f85" translate="yes" xml:space="preserve">
          <source>If you only want to export the object on the server (or the client), you can pass in the second argument (e.g., 'server', 'client', 'web.browser', 'web.cordova') to specify what architecture the export is used with. You can specify multiple architectures by passing in an array, for example &lt;code&gt;['web.cordova',
'os.linux']&lt;/code&gt;.</source>
          <target state="translated">서버 (또는 클라이언트)에서 객체 만 내보내려면 두 번째 인수 (예 : 'server', 'client', 'web.browser', 'web.cordova')를 전달하여 내보내기와 함께 사용되는 아키텍처입니다. 배열을 전달하여 여러 아키텍처를 지정할 수 있습니다 (예 : &lt;code&gt;['web.cordova', 'os.linux']&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb64e0557d37e4a2ee2273b90c1a4a82f437c565" translate="yes" xml:space="preserve">
          <source>If you only want to use the file on the server (or the client), you can pass this argument (e.g., 'server', 'client', 'web.browser', 'web.cordova') to specify what architecture the file is used with. You can specify multiple architectures by passing in an array, for example &lt;code&gt;['web.cordova', 'os.linux']&lt;/code&gt;. By default, the file will be loaded on both server and client.</source>
          <target state="translated">서버 (또는 클라이언트)에서만 파일을 사용하려면이 인수 (예 : 'server', 'client', 'web.browser', 'web.cordova')를 전달하여 아키텍처를 지정하십시오. 파일과 함께 사용됩니다. 배열을 전달하여 여러 아키텍처를 지정할 수 있습니다 (예 : &lt;code&gt;['web.cordova', 'os.linux']&lt;/code&gt; . 기본적으로 파일은 서버와 클라이언트 모두에로드됩니다.</target>
        </trans-unit>
        <trans-unit id="b51bac2bb462f0ba6e12e56dd4ca41d9afce2036" translate="yes" xml:space="preserve">
          <source>If you pass &lt;code&gt;null&lt;/code&gt; as the &lt;code&gt;name&lt;/code&gt;, then you&amp;rsquo;re creating a local collection. It&amp;rsquo;s not synchronized anywhere; it&amp;rsquo;s just a local scratchpad that supports Mongo-style &lt;a href=&quot;#find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#insert&quot;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#update&quot;&gt;&lt;code&gt;update&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#remove&quot;&gt;&lt;code&gt;remove&lt;/code&gt;&lt;/a&gt; operations. (On both the client and the server, this scratchpad is implemented using Minimongo.)</source>
          <target state="translated">당신이 전달하는 경우 &lt;code&gt;null&lt;/code&gt; 는 AS &lt;code&gt;name&lt;/code&gt; , 당신은 로컬 모음을 만들 것입니다. 어디서나 동기화되지 않습니다. Mongo 스타일의 &lt;a href=&quot;#find&quot;&gt; &lt;code&gt;find&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#insert&quot;&gt; &lt;code&gt;insert&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#update&quot;&gt; &lt;code&gt;update&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#remove&quot;&gt; &lt;code&gt;remove&lt;/code&gt; &lt;/a&gt; 작업 을 지원하는 로컬 스크래치 패드입니다 . (클라이언트와 서버 모두에서이 스크래치 패드는 Minimongo를 사용하여 구현됩니다.)</target>
        </trans-unit>
        <trans-unit id="76375f0d40a2218ea32885bbabe00ec9f6d79889" translate="yes" xml:space="preserve">
          <source>If you pass a &lt;code&gt;name&lt;/code&gt; when you create the collection, then you are declaring a persistent collection &amp;mdash; one that is stored on the server and seen by all users. Client code and server code can both access the same collection using the same API.</source>
          <target state="translated">컬렉션을 만들 때 &lt;code&gt;name&lt;/code&gt; 을 전달 하면 서버에 저장되고 모든 사용자가 볼 수있는 영구 컬렉션을 선언하는 것입니다. 클라이언트 코드와 서버 코드는 모두 동일한 API를 사용하여 동일한 콜렉션에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4c2ef87749b60f0b7cd70a7d4629765b8376fa9" translate="yes" xml:space="preserve">
          <source>If you prefer, you can &lt;code&gt;export&lt;/code&gt; variables by name, rather than prefixing their declarations with the &lt;code&gt;export&lt;/code&gt; keyword:</source>
          <target state="translated">원하는 경우 변수에 선언에 &lt;code&gt;export&lt;/code&gt; 키워드를 붙이지 않고 이름으로 변수를 &lt;code&gt;export&lt;/code&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0d3b5535270d855b9d87288618cee525ac40aa10" translate="yes" xml:space="preserve">
          <source>If you receive an error message trying to run the app on your device after adding or removing the Crosswalk plugin, you may have to remove the existing app from your device first.</source>
          <target state="translated">Crosswalk 플러그인을 추가하거나 제거한 후 장치에서 앱을 실행하려고하면 오류 메시지가 표시되면 먼저 장치에서 기존 앱을 제거해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa02ebfad523f59063b573838ecf664c424fcb41" translate="yes" xml:space="preserve">
          <source>If you return multiple cursors in an array, they currently must all be from different collections. We hope to lift this restriction in a future release.</source>
          <target state="translated">배열에서 여러 커서를 반환하는 경우 현재 커서가 모두 다른 컬렉션에 있어야합니다. 향후 릴리스에서이 제한을 해제 할 수 있도록 노력하겠습니다.</target>
        </trans-unit>
        <trans-unit id="e312d61a29c2e25efd10fe560130993582d137e4" translate="yes" xml:space="preserve">
          <source>If you run this inside an app, it will place the newly generated package in that app&amp;rsquo;s &lt;code&gt;packages/&lt;/code&gt; directory. Outside an app, it will just create a standalone package directory. The command also generates some boilerplate files for you:</source>
          <target state="translated">앱 내에서이를 실행하면 새로 생성 된 패키지가 해당 앱의 &lt;code&gt;packages/&lt;/code&gt; 디렉토리에 배치됩니다. 앱 외부에서는 독립형 패키지 디렉토리 만 생성합니다. 이 명령은 또한 상용구 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="742984d503cc47bf2c358af12faa73a9fb129605" translate="yes" xml:space="preserve">
          <source>If you specify a &lt;code&gt;transform&lt;/code&gt; option to the &lt;code&gt;Collection&lt;/code&gt; or any of its retrieval methods, documents are passed through the &lt;code&gt;transform&lt;/code&gt; function before being returned or passed to callbacks. This allows you to add methods or otherwise modify the contents of your collection from their database representation. You can also specify &lt;code&gt;transform&lt;/code&gt; on a particular &lt;code&gt;find&lt;/code&gt;, &lt;code&gt;findOne&lt;/code&gt;, &lt;code&gt;allow&lt;/code&gt;, or &lt;code&gt;deny&lt;/code&gt; call. Transform functions must return an object and they may not change the value of the document&amp;rsquo;s &lt;code&gt;_id&lt;/code&gt; field (though it&amp;rsquo;s OK to leave it out).</source>
          <target state="translated">&lt;code&gt;Collection&lt;/code&gt; 또는 검색 메소드 중 하나에 &lt;code&gt;transform&lt;/code&gt; 옵션을 지정하면 문서는 &lt;code&gt;transform&lt;/code&gt; 함수를 통해 전달되거나 콜백으로 전달됩니다. 이를 통해 메소드를 추가하거나 데이터베이스 표시에서 콜렉션의 내용을 수정할 수 있습니다. 특정 &lt;code&gt;find&lt;/code&gt; , &lt;code&gt;findOne&lt;/code&gt; , &lt;code&gt;allow&lt;/code&gt; 또는 &lt;code&gt;deny&lt;/code&gt; 호출 에 대해 &lt;code&gt;transform&lt;/code&gt; 을 지정할 수도 있습니다 . 변형 함수는 객체를 반환해야하며 문서의 &lt;code&gt;_id&lt;/code&gt; 필드 값을 변경하지 않아야 합니다 (물론 그대로 두는 것이 좋습니다).</target>
        </trans-unit>
        <trans-unit id="edc0fd33d8a117a5ab7778b16886ea7f1d79a0d8" translate="yes" xml:space="preserve">
          <source>If you use a mis-matched version of Node when deploying your application, you will encounter errors!</source>
          <target state="translated">응용 프로그램을 배포 할 때 일치하지 않는 버전의 Node를 사용하면 오류가 발생합니다!</target>
        </trans-unit>
        <trans-unit id="43c2fb22beebdc9b2308d62f74049ee5dae68715" translate="yes" xml:space="preserve">
          <source>If you used &lt;code&gt;--extra-packages&lt;/code&gt;, simply remove &lt;code&gt;bundle-visualizer&lt;/code&gt; from the list of included packages and run &lt;code&gt;meteor&lt;/code&gt; as normal.</source>
          <target state="translated">&lt;code&gt;--extra-packages&lt;/code&gt; 를 사용한 경우 포함 된 패키지 목록에서 &lt;code&gt;bundle-visualizer&lt;/code&gt; 를 제거 하고 평소처럼 &lt;code&gt;meteor&lt;/code&gt; 을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="805385e49f22a4e87ef81b6890d03855fe1bb088" translate="yes" xml:space="preserve">
          <source>If you used &lt;code&gt;meteor create&lt;/code&gt; to set up your package, Meteor will create the required scaffolding in &lt;code&gt;package.js&lt;/code&gt;, and you&amp;rsquo;ll only need to add unit test code in the &lt;code&gt;_test.js&lt;/code&gt; file that was created.</source>
          <target state="translated">&lt;code&gt;meteor create&lt;/code&gt; 를 사용 하여 패키지를 설정 한 경우 Meteor는 &lt;code&gt;package.js&lt;/code&gt; 에 필요한 스캐 폴딩을 생성하며 생성 된 &lt;code&gt;_test.js&lt;/code&gt; 파일 에 단위 테스트 코드 만 추가하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="821581b081f9e39832410418d07af184f979c66c" translate="yes" xml:space="preserve">
          <source>If you want a different URL for your reset password page, you need to customize it using the &lt;code&gt;Accounts.urls&lt;/code&gt; option:</source>
          <target state="translated">비밀번호 재설정 페이지에 다른 URL을 원하면 &lt;code&gt;Accounts.urls&lt;/code&gt; 옵션을 사용하여이를 사용자 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9c96c2c8b925cd1f056cacee3cba2eff30a8a78b" translate="yes" xml:space="preserve">
          <source>If you want something that just works out of the box, you can use &lt;code&gt;accounts-ui&lt;/code&gt; or &lt;code&gt;useraccounts&lt;/code&gt; which basically do everything for you. Only follow the directions below if you definitely want to build all parts of the email flow yourself.</source>
          <target state="translated">즉시 사용 가능한 것을 원한다면 &lt;code&gt;accounts-ui&lt;/code&gt; 또는 기본적으로 모든 것을 수행하는 &lt;code&gt;useraccounts&lt;/code&gt; 를 사용할 수 있습니다. 전자 메일 흐름의 모든 부분을 직접 작성하려면 아래 지침 만 따르십시오.</target>
        </trans-unit>
        <trans-unit id="a923cf26eb143d4bd926131addd26f0898988c97" translate="yes" xml:space="preserve">
          <source>If you want to &lt;code&gt;@import&lt;/code&gt; a file, give it the extension &lt;code&gt;.import.less&lt;/code&gt; to prevent Meteor from processing it independently.</source>
          <target state="translated">당신이 할 경우 &lt;code&gt;@import&lt;/code&gt; 파일을, 그것을 확장 제공 &lt;code&gt;.import.less&lt;/code&gt; 독립적으로 처리에서 유성을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36263f74ab08609e71e2a0635b7e0b3763fc19ed" translate="yes" xml:space="preserve">
          <source>If you want to access the custom data you&amp;rsquo;ve added to the &lt;code&gt;Meteor.users&lt;/code&gt; collection in your UI, you&amp;rsquo;ll need to publish it to the client. Mostly, you can just follow the advice in the &lt;a href=&quot;data-loading#publications&quot;&gt;Data Loading&lt;/a&gt; and &lt;a href=&quot;security#publications&quot;&gt;Security&lt;/a&gt; articles.</source>
          <target state="translated">UI에서 &lt;code&gt;Meteor.users&lt;/code&gt; 컬렉션에 추가 한 사용자 지정 데이터에 액세스 하려면 클라이언트에 해당 데이터를 게시해야합니다. 대부분 &lt;a href=&quot;data-loading#publications&quot;&gt;데이터로드&lt;/a&gt; 및 &lt;a href=&quot;security#publications&quot;&gt;보안&lt;/a&gt; 기사 의 조언을 따를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1dd7a801198a2c39927ff54c88b3c6d8df722080" translate="yes" xml:space="preserve">
          <source>If you want to add a plugin to your project directly, you use the same &lt;code&gt;meteor add&lt;/code&gt; command you use for Meteor packages, but with a &lt;code&gt;cordova:&lt;/code&gt; prefix:</source>
          <target state="translated">플러그인을 프로젝트에 직접 &lt;code&gt;meteor add&lt;/code&gt; 하려면 Meteor 패키지에 사용하는 것과 동일한 meteor add 명령을 사용하지만 &lt;code&gt;cordova:&lt;/code&gt; 접두어를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="92a9fd0bc52ad779ebd778c5fd248dc61e5c0046" translate="yes" xml:space="preserve">
          <source>If you want to control the look and feel of your accounts system a little more, we recommend reading the &lt;a href=&quot;http://guide.meteor.com/accounts.html#useraccounts&quot;&gt;useraccounts&lt;/a&gt; section of the Meteor Guide.</source>
          <target state="translated">당신이 좀 더 계정 시스템의 모양과 느낌을 제어하려면, 우리는 읽어 보시기 바랍니다 &lt;a href=&quot;http://guide.meteor.com/accounts.html#useraccounts&quot;&gt;useraccounts의&lt;/a&gt; 유성 가이드의 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e4485e7c91563dbd446f72af133ab9e712fa169e" translate="yes" xml:space="preserve">
          <source>If you want to create Meteor applications with separate code, you&amp;rsquo;ll have some modules that you&amp;rsquo;d like to share between them. If those modules are something the wider world could use, you should consider &lt;a href=&quot;https://guide.meteor.com/writing-packages.html&quot;&gt;publishing them to a package system&lt;/a&gt;, either npm or Atmosphere, depending on whether the code is Meteor-specific or otherwise.</source>
          <target state="translated">별도의 코드로 Meteor 응용 프로그램을 만들려면 해당 모듈간에 공유하려는 일부 모듈이 있습니다. 이러한 모듈이 더 넓은 세상에서 사용할 수있는 경우 코드가 Meteor 전용인지 여부에 따라 npm 또는 Atmosphere &lt;a href=&quot;https://guide.meteor.com/writing-packages.html&quot;&gt;패키지 시스템에 게시하는 것을&lt;/a&gt; 고려해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="fc0eac225bc136e4bc540429b926182185644a6c" translate="yes" xml:space="preserve">
          <source>If you want to distribute and reuse code that you&amp;rsquo;ve written for a Meteor application, then you should consider publishing that code on npm if it&amp;rsquo;s general enough to be consumed by a wider JavaScript audience. It&amp;rsquo;s simple to &lt;a href=&quot;using-npm-packages#using-npm&quot;&gt;use npm packages in Meteor applications&lt;/a&gt;, and possible to &lt;a href=&quot;writing-atmosphere-packages#npm-dependencies&quot;&gt;use npm packages within Atmosphere packages&lt;/a&gt;, so even if your main audience is Meteor developers, npm might be the best choice.</source>
          <target state="translated">Meteor 응용 프로그램 용으로 작성한 코드를 배포하고 재사용하려면 더 많은 JavaScript 사용자가 사용할 수있을 정도로 일반적인 코드 인 경우 npm에 해당 코드를 게시하는 것을 고려해야합니다. &lt;a href=&quot;using-npm-packages#using-npm&quot;&gt;Meteor 응용 프로그램에서 npm 패키지&lt;/a&gt; 를 사용하는 것은 간단하고 &lt;a href=&quot;writing-atmosphere-packages#npm-dependencies&quot;&gt;Atmosphere 패키지 내에서 npm 패키지&lt;/a&gt; 를 사용할 수 있으므로 주요 대상이 Meteor 개발자 인 경우에도 npm이 최선의 선택 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0fc530b3866845a455553c0e4ab36f9e6f967d6" translate="yes" xml:space="preserve">
          <source>If you want to figure out your hosting solution completely from scratch, the Meteor tool has a command &lt;code&gt;meteor build&lt;/code&gt; that creates a deployment bundle that contains a plain Node.js application. Any npm dependencies must be installed before issuing the &lt;code&gt;meteor build&lt;/code&gt; command to be included in the bundle. You can host this application wherever you like and there are many options in terms of how you set it up and configure it.</source>
          <target state="translated">호스팅 솔루션을 처음부터 완전히 파악하려면 Meteor 도구 에 일반 Node.js 응용 프로그램이 포함 된 배포 번들을 만드는 &lt;code&gt;meteor build&lt;/code&gt; 명령 이 있습니다. &lt;code&gt;meteor build&lt;/code&gt; 명령을 실행 하여 번들에 포함 시키려면 모든 npm 종속성이 설치되어 있어야합니다 . 원하는 곳 어디에서나이 응용 프로그램을 호스팅 할 수 있으며 설정 및 구성 방법에 대한 옵션이 많이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ae60d3de6bfaaedbdcc006106966c1f253333e9" translate="yes" xml:space="preserve">
          <source>If you want to include different files on the client and server, you can specify multiple entry points using the second argument to the function:</source>
          <target state="translated">클라이언트와 서버에 다른 파일을 포함 시키려면 함수에 대한 두 번째 인수를 사용하여 여러 진입 점을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f972521fcac6ee91fd73a08381fa4f8f920e549" translate="yes" xml:space="preserve">
          <source>If you want to return an error from a method, throw an exception. Methods can throw any kind of exception. But &lt;code&gt;Meteor.Error&lt;/code&gt; is the only kind of error that a server will send to the client. If a method function throws a different exception, then it will be mapped to a sanitized version on the wire. Specifically, if the &lt;code&gt;sanitizedError&lt;/code&gt; field on the thrown error is set to a &lt;code&gt;Meteor.Error&lt;/code&gt;, then that error will be sent to the client. Otherwise, if no sanitized version is available, the client gets &lt;code&gt;Meteor.Error(500, 'Internal server error')&lt;/code&gt;.</source>
          <target state="translated">메소드에서 오류를 리턴하려면 예외를 처리하십시오. 메소드는 모든 종류의 예외를 던질 수 있습니다. 그러나 &lt;code&gt;Meteor.Error&lt;/code&gt; 는 서버가 클라이언트에 보내는 유일한 종류의 오류입니다. 메소드 함수가 다른 예외를 처리하면 와이어에서 위생 화 된 버전에 맵핑됩니다. 특히, 발생한 오류 의 &lt;code&gt;sanitizedError&lt;/code&gt; 필드가 &lt;code&gt;Meteor.Error&lt;/code&gt; 로 설정되면 해당 오류가 클라이언트로 전송됩니다. 그렇지 않으면, 위생 처리 된 버전을 사용할 수 없으면 클라이언트는 &lt;code&gt;Meteor.Error(500, 'Internal server error')&lt;/code&gt; 얻 습니다 .</target>
        </trans-unit>
        <trans-unit id="5a7111ffe70dd95b9b0e14be2f5578ec58fc3ed2" translate="yes" xml:space="preserve">
          <source>If you want to share packages during development, we recommend using the &lt;a href=&quot;#including-in-app&quot;&gt;above methods&lt;/a&gt; instead of the registry. If you use the registry, then every time you change the package, you need to increment the version number, publish, and then &lt;code&gt;npm update my-package&lt;/code&gt; inside your app.</source>
          <target state="translated">개발 중에 패키지를 공유 하려면 레지스트리 대신 &lt;a href=&quot;#including-in-app&quot;&gt;위의 방법을&lt;/a&gt; 사용하는 것이 좋습니다 . 레지스트리를 사용하는 경우 패키지를 변경할 때마다 앱 에서 버전 번호를 증가시키고 게시 한 다음 &lt;code&gt;npm update my-package&lt;/code&gt; 해야합니다.</target>
        </trans-unit>
        <trans-unit id="cacc81197389ff21d88d4a1b76df1c865b14ae98" translate="yes" xml:space="preserve">
          <source>If you want to share variables between &lt;code&gt;.coffee&lt;/code&gt; files in the same package, and don&amp;rsquo;t want to separately declare them in a &lt;code&gt;.js&lt;/code&gt; file, we have an experimental feature that you may like. An object called &lt;code&gt;share&lt;/code&gt; is visible in CoffeeScript code and is shared across all &lt;code&gt;.coffee&lt;/code&gt; files in the same package. So, you can write &lt;code&gt;share.foo&lt;/code&gt; for a value that is shared between all CoffeeScript code in a package, but doesn&amp;rsquo;t escape that package.</source>
          <target state="translated">동일한 패키지의 &lt;code&gt;.coffee&lt;/code&gt; 파일 간에 변수를 공유 하고 &lt;code&gt;.js&lt;/code&gt; 파일 에서 개별적으로 선언하지 않으려 는 경우 실험 기능이 있습니다. &lt;code&gt;share&lt;/code&gt; 라는 객체 는 CoffeeScript 코드에서 볼 수 있으며 동일한 패키지의 모든 &lt;code&gt;.coffee&lt;/code&gt; 파일에서 공유 됩니다. 따라서 패키지의 모든 CoffeeScript 코드간에 공유되지만 해당 패키지를 이스케이프하지 않는 값으로 &lt;code&gt;share.foo&lt;/code&gt; 를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="49cf7dc12dadff9f25f077c9b8c06f4354a4b8a8" translate="yes" xml:space="preserve">
          <source>If you want to use React but don&amp;rsquo;t want to deal with JSX and prefer a more HTML-like syntax, there are a few community options available. One that stands out in particular is &lt;a href=&quot;https://github.com/timbrandin/blaze-react&quot;&gt;Blaze-React&lt;/a&gt;, which simulates the entire Blaze API using React as a rendering engine.</source>
          <target state="translated">React를 사용하고 싶지만 JSX를 다루지 않고 HTML과 같은 구문을 선호하는 경우 몇 가지 커뮤니티 옵션을 사용할 수 있습니다. 특히 눈에 띄는 것은 &lt;a href=&quot;https://github.com/timbrandin/blaze-react&quot;&gt;Blaze-React&lt;/a&gt; 인데, React를 렌더링 엔진으로 사용하여 전체 Blaze API를 시뮬레이션합니다.</target>
        </trans-unit>
        <trans-unit id="41bade3a7dcebb190bfe12581761642937527f57" translate="yes" xml:space="preserve">
          <source>If you want to use oplog tailing for livequeries, you should also set &lt;code&gt;MONGO_OPLOG_URL&lt;/code&gt; (generally you&amp;rsquo;ll need a special user with oplog access, but the detail can differ depending on how you host your MongoDB. Read more &lt;a href=&quot;https://github.com/meteor/docs/blob/master/long-form/oplog-observe-driver.md&quot;&gt;here&lt;/a&gt;).</source>
          <target state="translated">당신이 livequeries에 대한 미행 oplog 사용하려는 경우, 당신은 또한 설정해야합니다 &lt;code&gt;MONGO_OPLOG_URL&lt;/code&gt; 는 (일반적으로는 oplog 액세스 할 수있는 특별한 사용자를해야하지만, 세부 사항은 더 MongoDB를. 읽기를 호스트하는 방법에 따라 다를 수 있습니다 &lt;a href=&quot;https://github.com/meteor/docs/blob/master/long-form/oplog-observe-driver.md&quot;&gt;여기에&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ce4d1abdea3f4e41b8fe3175178e29f4791be17f" translate="yes" xml:space="preserve">
          <source>If you wanted to refactor this and create a completely fiber-wrapper GitHub client, you could write some logic to loop over all of the methods available and call &lt;code&gt;Meteor.wrapAsync&lt;/code&gt; on them, creating a new object with the same shape but with a more Meteor-compatible API.</source>
          <target state="translated">이것을 리팩토링하고 완전히 파이버 랩퍼 GitHub 클라이언트를 만들고 &lt;code&gt;Meteor.wrapAsync&lt;/code&gt; 사용 가능한 모든 메소드를 반복하고 Meteor.wrapAsync 를 호출 하여 동일한 모양이지만 더 많은 Meteor로 새로운 객체를 생성하는 로직을 작성할 수 있습니다 호환되는 API.</target>
        </trans-unit>
        <trans-unit id="1c33d46441a45788337f6d42fd1d1e26bedc1952" translate="yes" xml:space="preserve">
          <source>If you would like a module to be evaluated &lt;em&gt;lazily&lt;/em&gt; (in other words: on demand, the first time you import it, just like Node does it), then you should put that module in an &lt;code&gt;imports/&lt;/code&gt; directory (anywhere in your app, not just the root directory), and include that directory when you import the module: &lt;code&gt;import {stuff} from './imports/lazy'&lt;/code&gt;. Note: files contained by &lt;code&gt;node_modules/&lt;/code&gt; directories will also be evaluated lazily (more on that below).</source>
          <target state="translated">모듈을 &lt;em&gt;느리게&lt;/em&gt; 평가하려면 (즉, 노드가하는 것처럼 주문형으로 처음 가져올 때) 모듈을 &lt;code&gt;imports/&lt;/code&gt; 디렉토리 (앱의 어느 곳이 아닌)에 배치해야합니다 루트 디렉토리 만 사용하고 모듈을 가져올 때 해당 디렉토리를 포함하십시오. &lt;code&gt;import {stuff} from './imports/lazy'&lt;/code&gt; . 참고 : &lt;code&gt;node_modules/&lt;/code&gt; 디렉토리에 포함 된 파일 도 느리게 평가됩니다 (자세한 내용은 아래 참조).</target>
        </trans-unit>
        <trans-unit id="42245b2fe211585e66a13c2329947b0a15f2c9eb" translate="yes" xml:space="preserve">
          <source>If you would like to write your UI in Angular, you will need to switch out Meteor&amp;rsquo;s Blaze template compiler which comes by default with the Angular one. Read about how to do this in the &lt;a href=&quot;https://www.meteor.com/tutorials/angular/templates&quot;&gt;Angular-Meteor tutorial&lt;/a&gt;.</source>
          <target state="translated">UI를 Angular로 작성하려면 기본적으로 Angular와 함께 제공되는 Meteor 's Blaze 템플릿 컴파일러를 전환해야합니다. &lt;a href=&quot;https://www.meteor.com/tutorials/angular/templates&quot;&gt;Angular-Meteor tutorial&lt;/a&gt; 에서이를 수행하는 방법에 대해 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="6ae0f5526a3368a315a3ee049922b378d12a6796" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to use React within a larger app built with &lt;a href=&quot;#blaze.html&quot;&gt;Blaze&lt;/a&gt; (which is a good strategy if you&amp;rsquo;d like to incrementally migrate an app from Blaze to React), you can use the &lt;a href=&quot;https://atmospherejs.com/meteor/react-template-helper&quot;&gt;&lt;code&gt;react-template-helper&lt;/code&gt;&lt;/a&gt; component which renders a react component inside a Blaze template. First run &lt;code&gt;meteor add react-template-helper&lt;/code&gt;, then use the &lt;code&gt;React&lt;/code&gt; helper in your template:</source>
          <target state="translated">&lt;a href=&quot;#blaze.html&quot;&gt;Blaze로&lt;/a&gt; 빌드 된 더 큰 앱 내에서 React를 사용하려면 (Blaze에서 React로 앱을 점진적으로 마이그레이션하려는 경우 좋은 전략 임) &lt;a href=&quot;https://atmospherejs.com/meteor/react-template-helper&quot;&gt; &lt;code&gt;react-template-helper&lt;/code&gt; &lt;/a&gt; 구성 요소를 사용하여 Blaze 템플릿 내에서 구성 요소를 반응시킵니다. 먼저 &lt;code&gt;meteor add react-template-helper&lt;/code&gt; 를 실행 한 다음 템플릿에서 &lt;code&gt;React&lt;/code&gt; 도우미 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7596943dbc0af4ae30e0432a397f5843337ecb20" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to use a third party React component that has been &lt;a href=&quot;https://www.npmjs.com/search?q=react&quot;&gt;published on npm&lt;/a&gt;, you can &lt;code&gt;meteor npm install --save&lt;/code&gt; them and &lt;code&gt;import&lt;/code&gt; from within your app.</source>
          <target state="translated">당신이 제 3 자 사용하고자 된 해당 구성 요소 반작용 싶은 경우 &lt;a href=&quot;https://www.npmjs.com/search?q=react&quot;&gt;NPM에 게시&lt;/a&gt; , 당신은 할 수 &lt;code&gt;meteor npm install --save&lt;/code&gt; 그들과 &lt;code&gt;import&lt;/code&gt; 하여 앱 내에서.</target>
        </trans-unit>
        <trans-unit id="cc3a47851997e9719060ed24db1f93098aa6f746" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d prefer not to move your files, you can use the file names themselves as the URL prefix:</source>
          <target state="translated">파일을 이동하지 않으려면 파일 이름 자체를 URL 접두어로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="499841c65766072e137aeada538c5c92c96ee692" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d rather use different names, you&amp;rsquo;ll be glad to know &lt;code&gt;export&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt; statements can rename their arguments:</source>
          <target state="translated">다른 이름을 사용하려면 &lt;code&gt;export&lt;/code&gt; 및 &lt;code&gt;import&lt;/code&gt; 문이 인수의 이름을 바꿀 수 있다는 것을 알게되어 기쁩니다 .</target>
        </trans-unit>
        <trans-unit id="88f3c1415cb4c72de10579daaedaddf12c72050f" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re building your app&amp;rsquo;s UI with React, currently the most popular way to write your UI components involves JSX, an extension to JavaScript that allows you to type HTML tags that are converted to React DOM elements. JSX code is handled automatically by the &lt;code&gt;ecmascript&lt;/code&gt; package.</source>
          <target state="translated">React를 사용하여 앱의 UI를 구축하는 경우 현재 UI 구성 요소를 작성하는 가장 보편적 인 방법은 JSX와 관련이 있습니다. JSX는 JavaScript를 확장하여 React DOM 요소로 변환되는 HTML 태그를 입력 할 수있게합니다. JSX 코드는 &lt;code&gt;ecmascript&lt;/code&gt; 패키지에 의해 자동으로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="31775e85032a6fd9250108f5001616c8899d8c0f" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re migrating from a version of Meteor older than Meteor 1.4, there may be important considerations not listed in this guide (which specifically covers 1.4 to 1.5). Please review the older migration guides for details:</source>
          <target state="translated">Meteor 1.4 이전의 Meteor 버전에서 마이그레이션하는 경우이 안내서에 명시되지 않은 중요한 고려 사항이있을 수 있습니다 (특히 1.4-1.5 포함). 자세한 내용은 이전 마이그레이션 안내서를 검토하십시오.</target>
        </trans-unit>
        <trans-unit id="5365047de0adb8409cd922540f38f767bd93d769" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re on Ubuntu 14.04 LTS, you&amp;rsquo;ll have to add the Ubuntu Make ppa first:</source>
          <target state="translated">Ubuntu 14.04 LTS를 사용중인 경우 먼저 Ubuntu Make ppa를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="5c5696d8555b1c20f1bf0bb1844d70e90ed70e80" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re publishing a subset of your data, it might be tempting to simply query for all data available in a collection (i.e. &lt;code&gt;Lists.find()&lt;/code&gt;) in order to get that subset on the client, without re-specifying the Mongo selector you used to publish that data in the first place.</source>
          <target state="translated">데이터의 하위 집합을 게시하는 경우 Mongo 선택기를 다시 지정하지 않고 컬렉션에서 사용 가능한 모든 데이터 (예 : &lt;code&gt;Lists.find()&lt;/code&gt; )를 쿼리 하여 클라이언트에서 해당 하위 집합을 가져 오려는 유혹이있을 수 있습니다. 처음에는 그 데이터를 게시했습니다.</target>
        </trans-unit>
        <trans-unit id="fb02597191cd0266ef242c2eea7154a86775dbd9" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re running Ubuntu, the easiest way to install both a Java Development Kit and Android Studio is by using &lt;a href=&quot;https://wiki.ubuntu.com/ubuntu-make&quot;&gt;Ubuntu Make&lt;/a&gt;, a command line tool that sets up development environments and dependencies for you.</source>
          <target state="translated">Ubuntu를 실행하는 경우 Java Development Kit과 Android Studio를 모두 설치하는 가장 쉬운 방법은 개발 환경과 종속성을 설정하는 명령 줄 도구 인 &lt;a href=&quot;https://wiki.ubuntu.com/ubuntu-make&quot;&gt;Ubuntu Make&lt;/a&gt; 를 사용 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5f22fc89859e18f087e9ac77136cd04b17cad5ff" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re running your Meteor server behind a proxy (so that clients are connecting to the proxy instead of to your server directly), you&amp;rsquo;ll need to set the &lt;code&gt;HTTP_FORWARDED_COUNT&lt;/code&gt; environment variable for the correct IP address to be reported by &lt;code&gt;clientAddress&lt;/code&gt;.</source>
          <target state="translated">프록시 뒤에서 Meteor 서버를 실행중인 경우 (클라이언트가 서버 대신 프록시에 직접 연결하도록) &lt;code&gt;clientAddress&lt;/code&gt; 가 올바른 IP 주소를보고 하도록 &lt;code&gt;HTTP_FORWARDED_COUNT&lt;/code&gt; 환경 변수 를 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f20e4e29c6b6992e85e71ca85e9479b3d30a6511" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re testing code that makes use of globals, you&amp;rsquo;ll need to import those globals. For instance if you have a global &lt;code&gt;Todos&lt;/code&gt; collection and are testing this file:</source>
          <target state="translated">전역을 사용하는 코드를 테스트하는 경우 해당 전역을 가져와야합니다. 예를 들어, 글로벌 &lt;code&gt;Todos&lt;/code&gt; 콜렉션이 있고이 파일을 테스트하는 경우 :</target>
        </trans-unit>
        <trans-unit id="3ea89e1575e79ec50a68342b1f9403e4d48ee575" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using &lt;a href=&quot;https://www.meteor.com/galaxy/signup&quot;&gt;Galaxy to host your meteor apps&lt;/a&gt;, you can also take advantage of built-in automatic &lt;a href=&quot;https://prerender.io&quot;&gt;Prerender.io&lt;/a&gt; integration. Simply add &lt;a href=&quot;https://atmospherejs.com/mdg/seo&quot;&gt;&lt;code&gt;mdg:seo&lt;/code&gt;&lt;/a&gt; to your app and Galaxy will take care of the rest: loading the code and configuring it with Galaxy-provided credentials.</source>
          <target state="translated">&lt;a href=&quot;https://www.meteor.com/galaxy/signup&quot;&gt;Galaxy를&lt;/a&gt; 사용 하여 유성 앱을 호스팅 하는 경우 내장 된 자동 &lt;a href=&quot;https://prerender.io&quot;&gt;Prerender.io&lt;/a&gt; 통합 을 활용할 수도 있습니다 . 앱 에 &lt;a href=&quot;https://atmospherejs.com/mdg/seo&quot;&gt; &lt;code&gt;mdg:seo&lt;/code&gt; &lt;/a&gt; 를 추가하기 만하면 Galaxy에서 나머지 코드를로드하고 Galaxy에서 제공 한 자격 증명으로 코드를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="a4a00ef04d1c2eaefdc036812fd307a1efa0977e" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using the oauth packages directly instead of through the Meteor accounts packages, you can load the OAuth encryption key directly using &lt;code&gt;OAuthEncryption.loadKey&lt;/code&gt;:</source>
          <target state="translated">Meteor 계정 패키지 대신 oauth 패키지를 직접 사용하는 경우 &lt;code&gt;OAuthEncryption.loadKey&lt;/code&gt; 를 사용하여 OAuth 암호화 키를 직접로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0260685729406497298030dd969298bab8f10738" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve added &lt;code&gt;bundle-visualizer&lt;/code&gt; permanently with &lt;code&gt;meteor add&lt;/code&gt;, it is important to remove this package prior to bundling or deploying to production with &lt;code&gt;meteor remove bundle-visualizer&lt;/code&gt;.</source>
          <target state="translated">당신이 추가 한 경우 &lt;code&gt;bundle-visualizer&lt;/code&gt; 영구적으로 &lt;code&gt;meteor add&lt;/code&gt; , 이전의 번들 또는과 생산에 배포에이 패키지를 제거하는 것이 중요하다 &lt;code&gt;meteor remove bundle-visualizer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19725733123f8a4d34132c4329ecf327377a341b" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve ever looked inside Meteor&amp;rsquo;s package cache at &lt;code&gt;~/.meteor/packages&lt;/code&gt;, you know that the on-disk format of a built Meteor package is completely different from the way the source code looks when you&amp;rsquo;re developing the package. The idea is that the target format of a package can remain consistent even if the API for development changes.</source>
          <target state="translated">&lt;code&gt;~/.meteor/packages&lt;/code&gt; 의 Meteor 패키지 캐시 내부를 살펴본 적이 있다면 빌드 된 Meteor 패키지의 온 디스크 형식이 패키지를 개발할 때 소스 코드의 모양과 완전히 다릅니다. 아이디어는 개발 용 API가 변경 되더라도 패키지의 대상 형식이 일관성을 유지할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9f440a209b38a0f987257912b3f67de486d7d36a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve ever needed to deal with sending pretty HTML emails from an app, you know that it can quickly become a nightmare. Compatibility of popular email clients with basic HTML features like CSS is notoriously spotty, so it is hard to author something that works at all. Start with a &lt;a href=&quot;https://github.com/leemunroe/responsive-html-email-template&quot;&gt;responsive email template&lt;/a&gt; or &lt;a href=&quot;http://foundation.zurb.com/emails/email-templates.html&quot;&gt;framework&lt;/a&gt;, and then use a tool to convert your email content into something that is compatible with all email clients. &lt;a href=&quot;http://blog.mailgun.com/transactional-html-email-templates/&quot;&gt;This blog post by Mailgun covers some of the main issues with HTML email.&lt;/a&gt; In theory, a community package could extend Meteor&amp;rsquo;s build system to do the email compilation for you, but at the time of writing we were not aware of any such packages.</source>
          <target state="translated">앱에서 예쁜 HTML 전자 메일을 보내야하는 경우에는 악몽이 될 수 있습니다. 널리 사용되는 이메일 클라이언트와 CSS와 같은 기본 HTML 기능과의 호환성은 매우 드물기 때문에 전혀 작동하지 않는 것을 작성하기가 어렵습니다. 시작 &lt;a href=&quot;https://github.com/leemunroe/responsive-html-email-template&quot;&gt;응답 이메일 템플릿&lt;/a&gt; 또는 &lt;a href=&quot;http://foundation.zurb.com/emails/email-templates.html&quot;&gt;프레임 워크&lt;/a&gt; , 그리고 모든 전자 메일 클라이언트와 호환되는 무언가로 당신의 이메일 내용을 변환하는 도구를 사용합니다. &lt;a href=&quot;http://blog.mailgun.com/transactional-html-email-templates/&quot;&gt;Mailgun의이 블로그 게시물은 HTML 전자 메일의 주요 문제 중 일부를 다룹니다.&lt;/a&gt; 이론적으로, 커뮤니티 패키지는 Meteor의 빌드 시스템을 확장하여 이메일 편집을 수행 할 수 있지만, 글을 쓰는 시점에서 우리는 그러한 패키지를 인식하지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="f6cfc5243c8df3d9a63fb062cb8ee3ba3d011041" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;MAIL_URL&lt;/code&gt; is TLS/SSL-only (and does not need &lt;a href=&quot;https://en.wikipedia.org/wiki/Opportunistic_TLS&quot;&gt;&lt;code&gt;STARTTLS&lt;/code&gt;&lt;/a&gt;), be sure that the &lt;code&gt;MAIL_URL&lt;/code&gt; starts with &lt;code&gt;smtps://&lt;/code&gt; and not just &lt;code&gt;smtp://&lt;/code&gt;.</source>
          <target state="translated">귀하의 경우 &lt;code&gt;MAIL_URL&lt;/code&gt; 가 TLS이다 / SSL 전용 (그리고 필요가 없습니다 &lt;a href=&quot;https://en.wikipedia.org/wiki/Opportunistic_TLS&quot;&gt; &lt;code&gt;STARTTLS&lt;/code&gt; 를&lt;/a&gt; ), 그 확인 &lt;code&gt;MAIL_URL&lt;/code&gt; 의 로 시작 &lt;code&gt;smtps://&lt;/code&gt; 뿐 아니라 &lt;code&gt;smtp://&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bca3c619420dcc3af6e645389094a62cbd09e93a" translate="yes" xml:space="preserve">
          <source>If your Meteor application targets mobile platforms such as iOS or Android, you can configure your app&amp;rsquo;s metadata and build process in a special top-level file called &lt;code&gt;mobile-config.js&lt;/code&gt; which is &lt;em&gt;not&lt;/em&gt; included in your application and is used only for this configuration.</source>
          <target state="translated">당신의 유성 응용 프로그램은 iOS 또는 안드로이드와 같은 모바일 플랫폼을 대상으로하는 경우라는 특별한 최상위 파일에 앱의 메타 데이터와 빌드 프로세스를 구성 할 수 있습니다 &lt;code&gt;mobile-config.js&lt;/code&gt; 되어 &lt;em&gt;있지&lt;/em&gt; 응용 프로그램에 포함되어 있으며이 구성에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2da0eab193064a83b91356769c2f6cdf1588ce7f" translate="yes" xml:space="preserve">
          <source>If your app is running when you add a new package, Meteor will automatically download it and restart your app for you.</source>
          <target state="translated">새 패키지를 추가 할 때 앱이 실행중인 경우 Meteor가 자동으로 패키지를 다운로드하고 앱을 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="2222e79cd3eccad7198f782778d27c13e6b13b42" translate="yes" xml:space="preserve">
          <source>If your app supports or even requires login with an external service such as Facebook, it&amp;rsquo;s natural to also want to use that service&amp;rsquo;s API to request additional data about that user. For example, you might want to get a list of a Facebook user&amp;rsquo;s photos.</source>
          <target state="translated">앱이 Facebook과 같은 외부 서비스로 로그인을 지원하거나 필요로하는 경우 해당 서비스의 API를 사용하여 해당 사용자에 대한 추가 데이터를 요청하는 것이 당연합니다. 예를 들어 Facebook 사용자의 사진 목록을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08e998b29173e8ef9bfc7d2f8922182e751fad65" translate="yes" xml:space="preserve">
          <source>If your app uses &lt;code&gt;ES2015&lt;/code&gt; modules included from &lt;code&gt;client/main.js&lt;/code&gt; and &lt;code&gt;server/main.js&lt;/code&gt; entry points, import your JSON file(s) there. The &lt;code&gt;i18n.__()&lt;/code&gt; function will now locate keys you pass.</source>
          <target state="translated">앱이 &lt;code&gt;client/main.js&lt;/code&gt; 및 &lt;code&gt;server/main.js&lt;/code&gt; 진입 점에 포함 된 &lt;code&gt;ES2015&lt;/code&gt; 모듈을 사용하는 경우 JSON 파일을 가져 오십시오. &lt;code&gt;i18n.__()&lt;/code&gt; 함수는 이제 패스 키를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="e1b228c980b89740aa6d004bbb2d247570085696" translate="yes" xml:space="preserve">
          <source>If your application contains a lot of publicly accessible content, then you probably want it to rank well in Google and other search engines&amp;rsquo; indexes. As most webcrawlers do not support client-side rendering (or if they do, have spotty support for websockets), it&amp;rsquo;s better to render the site on the server and deliver it as HTML in this special case.</source>
          <target state="translated">애플리케이션에 공개적으로 액세스 할 수있는 많은 콘텐츠가 포함 된 경우 Google 및 기타 검색 엔진의 색인에서 순위를 매길 수 있습니다. 대부분의 웹 크롤러는 클라이언트 측 렌더링을 지원하지 않거나 웹 소켓을 지원하는 경우가 많으므로 서버에서 사이트를 렌더링하고이 특별한 경우 HTML로 제공하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="443805ac684272a5317505238336ced4fa1d6932" translate="yes" xml:space="preserve">
          <source>If your helper or sub-component is expensive to run, and often re-runs without any visible effect, you can short circuit unnecessary re-runs by using a more subtle reactive data source. The &lt;a href=&quot;https://atmospherejs.com/peerlibrary/computed-field&quot;&gt;&lt;code&gt;peerlibrary:computed-field&lt;/code&gt;&lt;/a&gt; package helps achieve this pattern.</source>
          <target state="translated">도우미 또는 하위 구성 요소가 실행 비용이 많이 들고 눈에 띄는 영향없이 다시 실행되는 경우보다 미묘한 반응 형 데이터 소스를 사용하여 불필요한 다시 실행을 단축 할 수 있습니다. &lt;a href=&quot;https://atmospherejs.com/peerlibrary/computed-field&quot;&gt; &lt;code&gt;peerlibrary:computed-field&lt;/code&gt; &lt;/a&gt; 패키지는이 패턴을 달성하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="8b6c180b8b1666c01b2235381c3ddbf401cb3710" translate="yes" xml:space="preserve">
          <source>If your local machine does not (yet) fulfill the &lt;a href=&quot;#installing-prerequisites&quot;&gt;prerequisites&lt;/a&gt; for building apps for a mobile platform, an error message with a list of missing requirements is printed (but the platform is still added). You will have to make sure these requirements are fulfilled before you&amp;rsquo;re able to build and run mobile apps from your machine.</source>
          <target state="translated">로컬 시스템이 모바일 플랫폼 용 앱을 빌드 하기위한 &lt;a href=&quot;#installing-prerequisites&quot;&gt;전제 조건&lt;/a&gt; 을 아직 충족시키지 못하면 요구 사항 누락 목록이 포함 된 오류 메시지가 인쇄되지만 플랫폼은 여전히 ​​추가됩니다. 컴퓨터에서 모바일 앱을 빌드하고 실행하기 전에 이러한 요구 사항이 충족되는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="bbfb435552ea9ee7046837462da38f718f502dd4" translate="yes" xml:space="preserve">
          <source>If your migration needs to change a lot of data, and especially if you need to stop your app server while it&amp;rsquo;s running, it may be a good idea to use a &lt;a href=&quot;https://docs.mongodb.org/v3.0/core/bulk-write-operations/&quot;&gt;MongoDB Bulk Operation&lt;/a&gt;.</source>
          <target state="translated">마이그레이션에서 많은 데이터를 변경해야하는 경우, 특히 실행중인 앱 서버를 중지해야하는 경우 &lt;a href=&quot;https://docs.mongodb.org/v3.0/core/bulk-write-operations/&quot;&gt;MongoDB 대량 작업&lt;/a&gt; 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="c47562df69dcac594dd921f0b8fca330b6da4988" translate="yes" xml:space="preserve">
          <source>If your package depends on an Atmosphere package (which, in Meteor 1.3, includes the Meteor core packages), or needs to take advantage of Meteor&amp;rsquo;s &lt;a href=&quot;build-tool&quot;&gt;build system&lt;/a&gt;, writing an Atmosphere package might be the best option for now.</source>
          <target state="translated">패키지가 Attesphere 패키지 (Meteor 1.3에서 Meteor 코어 패키지 포함)에 의존하거나 Meteor의 &lt;a href=&quot;build-tool&quot;&gt;빌드 시스템&lt;/a&gt; 을 활용해야하는 경우 Atmosphere 패키지를 작성하는 것이 현재 가장 좋은 옵션 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7df795cdeb6c4309ef74c33ebea90ca11bb2cea9" translate="yes" xml:space="preserve">
          <source>If your type does not have a &lt;code&gt;clone&lt;/code&gt; method, &lt;code&gt;EJSON.clone&lt;/code&gt; will use &lt;a href=&quot;#ejson_type_toJSONValue&quot;&gt;&lt;code&gt;toJSONValue&lt;/code&gt;&lt;/a&gt; and the factory instead.</source>
          <target state="translated">유형에 &lt;code&gt;clone&lt;/code&gt; 방법 이없는 경우 &lt;code&gt;EJSON.clone&lt;/code&gt; 은 &lt;a href=&quot;#ejson_type_toJSONValue&quot;&gt; &lt;code&gt;toJSONValue&lt;/code&gt; &lt;/a&gt; 와 팩토리를 대신 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4952908c2b33520dba66cb4ce8895b270a0b5c4d" translate="yes" xml:space="preserve">
          <source>If your type does not have an &lt;code&gt;equals&lt;/code&gt; method, &lt;code&gt;EJSON.equals&lt;/code&gt; will compare the result of calling &lt;a href=&quot;#ejson_type_toJSONValue&quot;&gt;&lt;code&gt;toJSONValue&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">형식에 &lt;code&gt;equals&lt;/code&gt; 메서드 가없는 경우 &lt;code&gt;EJSON.equals&lt;/code&gt; 는 대신 &lt;a href=&quot;#ejson_type_toJSONValue&quot;&gt; &lt;code&gt;toJSONValue&lt;/code&gt; &lt;/a&gt; 호출 결과를 비교합니다 .</target>
        </trans-unit>
        <trans-unit id="3780874bb50e4ae63d44565f0229e3cb84ecb1c3" translate="yes" xml:space="preserve">
          <source>If your user has connected to server A, then you can use &lt;code&gt;DDP.connect()&lt;/code&gt; to open a connection to server B, and pass in server A&amp;rsquo;s resume token to authenticate on server B. As both servers are using the same DB, the same server token will work in both cases. The code to authenticate looks like this:</source>
          <target state="translated">사용자가 서버 A에 연결 한 경우 &lt;code&gt;DDP.connect()&lt;/code&gt; 를 사용 하여 서버 B에 대한 연결을 열고 서버 A의 이력서 토큰을 전달하여 서버 B에서 인증 할 수 있습니다. 두 서버가 동일한 DB를 사용하므로 서버 토큰은 두 경우 모두 작동합니다. 인증하는 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0d6c3eca8ae6dd0e9730869d69558e35ae209f84" translate="yes" xml:space="preserve">
          <source>If/Unless</source>
          <target state="translated">If/Unless</target>
        </trans-unit>
        <trans-unit id="c4fff34a8b4255393b375dcf27718bc368d36741" translate="yes" xml:space="preserve">
          <source>Important: The Crosswalk project is not maintained anymore. The last Crosswalk release was Crosswalk 23. Read more in this &lt;a href=&quot;https://crosswalk-project.org/blog/crosswalk-final-release.html&quot;&gt;announcement&lt;/a&gt;</source>
          <target state="translated">중요 : 횡단 보도 프로젝트는 더 이상 유지되지 않습니다. 마지막 횡단 보도 릴리스는 횡단 보도 23입니다.이 &lt;a href=&quot;https://crosswalk-project.org/blog/crosswalk-final-release.html&quot;&gt;발표&lt;/a&gt; 에서 더 읽기</target>
        </trans-unit>
        <trans-unit id="90ab5ed3bb3e27748d586ad9b9b11e2ab9efaaf8" translate="yes" xml:space="preserve">
          <source>Importing</source>
          <target state="translated">Importing</target>
        </trans-unit>
        <trans-unit id="8de4d9b83abc3870a49a5b05034966d706aff446" translate="yes" xml:space="preserve">
          <source>Importing Meteor &amp;ldquo;pseudo-globals&amp;rdquo;</source>
          <target state="translated">Meteor &quot;의사 글로벌&quot;가져 오기</target>
        </trans-unit>
        <trans-unit id="0180eade6f8fdf9833f897f7054b069805c4cee6" translate="yes" xml:space="preserve">
          <source>Importing from packages</source>
          <target state="translated">패키지에서 가져 오기</target>
        </trans-unit>
        <trans-unit id="93d406ddd29c50f712d0a5130e11b85db3a79c5f" translate="yes" xml:space="preserve">
          <source>Importing styles</source>
          <target state="translated">스타일 가져 오기</target>
        </trans-unit>
        <trans-unit id="683aeb4ac5cf9954986f29864981cce1ab6c749f" translate="yes" xml:space="preserve">
          <source>Importing styles from Atmosphere packages</source>
          <target state="translated">분위기 패키지에서 스타일 가져 오기</target>
        </trans-unit>
        <trans-unit id="24c238bdcdfe7255fb7fb97ee01cef351c1aab61" translate="yes" xml:space="preserve">
          <source>Importing styles from an Atmosphere package using the &lt;code&gt;{}&lt;/code&gt; package name syntax:</source>
          <target state="translated">&lt;code&gt;{}&lt;/code&gt; 패키지 이름 구문을 사용하여 Atmosphere 패키지에서 스타일 가져 오기 :</target>
        </trans-unit>
        <trans-unit id="479bfc3d1edcdab2600d4235255458197f7b0cd7" translate="yes" xml:space="preserve">
          <source>Importing styles from an npm package using the &lt;code&gt;{}&lt;/code&gt; syntax:</source>
          <target state="translated">&lt;code&gt;{}&lt;/code&gt; 구문을 사용하여 npm 패키지에서 스타일 가져 오기 :</target>
        </trans-unit>
        <trans-unit id="4238f168334816b667d140df15414651a0683de7" translate="yes" xml:space="preserve">
          <source>Importing styles from an npm package with a relative path:</source>
          <target state="translated">상대 경로를 사용하여 npm 패키지에서 스타일 가져 오기 :</target>
        </trans-unit>
        <trans-unit id="0275d88be57e1367c71daad9fd6ddfc29c5fc843" translate="yes" xml:space="preserve">
          <source>Importing styles from an npm package with an absolute path using the &lt;code&gt;{}&lt;/code&gt; syntax, for instance with Less:</source>
          <target state="translated">&lt;code&gt;{}&lt;/code&gt; 구문을 사용하여 절대 경로가있는 npm 패키지에서 스타일 가져 오기 ( 예 : Less) :</target>
        </trans-unit>
        <trans-unit id="a57ac434414f4329e7d46fe7b8b105b9a5300f54" translate="yes" xml:space="preserve">
          <source>Importing styles from npm</source>
          <target state="translated">npm에서 스타일 가져 오기</target>
        </trans-unit>
        <trans-unit id="ba38d99c7c09ed3a5166d4be08a0c24fe130a291" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://guide.meteor.com/ui-ux.html#smart-components&quot;&gt;UI/UX article&lt;/a&gt; we discussed the merits of creating reusable components that interact with their environment in clear and minimal ways.</source>
          <target state="translated">에서 &lt;a href=&quot;https://guide.meteor.com/ui-ux.html#smart-components&quot;&gt;UI / UX 기사&lt;/a&gt; 우리는 명확하고 최소한의 방법으로 자신의 환경과 상호 작용하는 재사용 가능한 구성 요소를 작성의 장점을 논의했다.</target>
        </trans-unit>
        <trans-unit id="5e66dd15b560e11ce815bd97ff948a7f63a4ccea" translate="yes" xml:space="preserve">
          <source>In Attribute Values</source>
          <target state="translated">속성 값</target>
        </trans-unit>
        <trans-unit id="031be70926363c1353ae6ce239855bf4ccc6ca74" translate="yes" xml:space="preserve">
          <source>In Chimp tests, you have a DDP connection to the server available on the &lt;code&gt;server&lt;/code&gt; variable. You can thus use &lt;code&gt;server.call()&lt;/code&gt; (which is wrapped to be synchronous in Chimp tests) to call these methods. This is a convenient way to share data preparation code between acceptance and integration tests.</source>
          <target state="translated">Chimp 테스트에서는 &lt;code&gt;server&lt;/code&gt; 변수 에서 사용 가능한 서버에 대한 DDP 연결이 있습니다 . 따라서 &lt;code&gt;server.call()&lt;/code&gt; (Chip 테스트에서 동기식으로 래핑 됨)을 사용하여 이러한 메소드를 호출 할 수 있습니다. 이는 승인 테스트와 통합 테스트간에 데이터 준비 코드를 공유하는 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="cd540b8827cd136018e89af4ab6c812a10f70ce3" translate="yes" xml:space="preserve">
          <source>In ES2015, you can make variables available outside a file using the &lt;code&gt;export&lt;/code&gt; keyword. To use the variables somewhere else, you must &lt;code&gt;import&lt;/code&gt; them using the path to the source. Files that export some variables are called &amp;ldquo;modules&amp;rdquo;, because they represent a unit of reusable code. Explicitly importing the modules and packages you use helps you write your code in a modular way, avoiding the introduction of global symbols and &amp;ldquo;action at a distance&amp;rdquo;.</source>
          <target state="translated">ES2015에서는 &lt;code&gt;export&lt;/code&gt; 키워드를 사용하여 파일 외부에서 변수를 사용할 수 있습니다 . 다른 곳에서 변수를 사용하려면 소스 경로 를 사용하여 변수를 &lt;code&gt;import&lt;/code&gt; 합니다. 일부 변수를 내보내는 파일은 재사용 가능한 코드 단위를 나타 내기 때문에 &quot;모듈&quot;이라고합니다. 사용하는 모듈과 패키지를 명시 적으로 가져 오면 전역 기호가 도입되지 않고 &quot;원거리에서의 작업&quot;을 피하면서 모듈 방식으로 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ccbcafe57980d66695f4ae15c7f237da4917dae" translate="yes" xml:space="preserve">
          <source>In Meteor a &lt;strong&gt;publication&lt;/strong&gt; is a named API on the server that constructs a set of data to send to a client. A client initiates a &lt;strong&gt;subscription&lt;/strong&gt; which connects to a publication, and receives that data. That data consists of a first batch sent when the subscription is initialized and then incremental updates as the published data changes.</source>
          <target state="translated">Meteor에서 &lt;strong&gt;발행물&lt;/strong&gt; 은 클라이언트에 보낼 데이터 세트를 구성하는 서버의 명명 된 API입니다. 클라이언트 는 발행물에 연결하고 해당 데이터를 수신 하는 &lt;strong&gt;구독&lt;/strong&gt; 을 시작합니다 . 이 데이터는 구독이 초기화 될 때 전송 된 첫 번째 일괄 처리로 구성되며 게시 된 데이터가 변경되면 증분 업데이트로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="99e82a5e498c26c24995b21ed17d9fe40e3ffc83" translate="yes" xml:space="preserve">
          <source>In Meteor specifically, this means a component which does not access data from any global sources&amp;mdash;Collections, Stores, routers, user data, or similar. For instance, in the Todos example app, the &lt;code&gt;Lists_show&lt;/code&gt; template takes in the list it is rendering and the set of todos for that list, and it never looks directly in the &lt;code&gt;Todos&lt;/code&gt; or &lt;code&gt;Lists&lt;/code&gt; collections.</source>
          <target state="translated">Meteor에서 구체적으로 이것은 컬렉션, 저장소, 라우터, 사용자 데이터 등의 모든 글로벌 소스에서 데이터에 액세스하지 않는 구성 요소를 의미합니다. 예를 들어, Todos 예제 앱에서 &lt;code&gt;Lists_show&lt;/code&gt; 템플리트는 렌더링중인 목록과 해당 목록에 대한 할 일 모음을 가져 오며 &lt;code&gt;Todos&lt;/code&gt; 또는 &lt;code&gt;Lists&lt;/code&gt; 콜렉션 에서 직접 보지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="73216ee871c012e3c35909ff083baf1ebb594997" translate="yes" xml:space="preserve">
          <source>In Meteor, &lt;a href=&quot;https://atmospherejs.com/tap/i18n&quot;&gt;the excellent &lt;code&gt;tap:i18n&lt;/code&gt; package&lt;/a&gt; provides an API for building translations and using them in your components and frontend code.</source>
          <target state="translated">Meteor &lt;a href=&quot;https://atmospherejs.com/tap/i18n&quot;&gt;에서 우수한 &lt;code&gt;tap:i18n&lt;/code&gt; 패키지&lt;/a&gt; 는 번역을 작성하고 컴포넌트 및 프론트 엔드 코드에서 번역을 사용하기위한 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1ec923b5f4339427381c3dc9b43a7f722506d8be" translate="yes" xml:space="preserve">
          <source>In Meteor, &lt;code&gt;import&lt;/code&gt; statements compile to CommonJS &lt;code&gt;require&lt;/code&gt; syntax. However, as a convention we encourage you to use &lt;code&gt;import&lt;/code&gt;.</source>
          <target state="translated">Meteor에서 CommonJS &lt;code&gt;require&lt;/code&gt; &lt;code&gt;import&lt;/code&gt; 명령문 은 구문이 필요 합니다. 그러나 일반적으로 &lt;code&gt;import&lt;/code&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="32c6aaabc70a85f54e76772ac92b389fc838ac70" translate="yes" xml:space="preserve">
          <source>In Meteor, each of your &lt;code&gt;.scss&lt;/code&gt;, &lt;code&gt;.less&lt;/code&gt;, or &lt;code&gt;.styl&lt;/code&gt; source files will be one of two types: &amp;ldquo;source&amp;rdquo; or &amp;ldquo;import&amp;rdquo;.</source>
          <target state="translated">Meteor에서 각 &lt;code&gt;.scss&lt;/code&gt; , &lt;code&gt;.less&lt;/code&gt; 또는 &lt;code&gt;.styl&lt;/code&gt; 소스 파일은 &quot;source&quot;또는 &quot;import&quot;의 두 가지 유형 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="4923d1b0b76daf5fcbd508288c27cc3e7957dcff" translate="yes" xml:space="preserve">
          <source>In Meteor, it is also simple and straightforward to use the &lt;code&gt;import&lt;/code&gt; syntax to load npm packages on the client or server and access the package&amp;rsquo;s exported symbols as you would with any other module. You can also import from Meteor Atmosphere packages, but the import path must be prefixed with &lt;code&gt;meteor/&lt;/code&gt; to avoid conflict with the npm package namespace. For example, to import &lt;code&gt;moment&lt;/code&gt; from npm and &lt;code&gt;HTTP&lt;/code&gt; from Atmosphere:</source>
          <target state="translated">Meteor에서는 &lt;code&gt;import&lt;/code&gt; 구문 을 사용 하여 클라이언트 나 서버에 npm 패키지를로드하고 다른 모듈과 마찬가지로 패키지의 내 보낸 심볼에 액세스하는 것이 간단하고 간단 합니다. Meteor Atmosphere 패키지에서 가져올 수도 있지만 npm 패키지 네임 스페이스와의 충돌을 피 하려면 가져 오기 경로 앞에 &lt;code&gt;meteor/&lt;/code&gt; 를 붙여야 합니다. 예를 들어, npm에서 &lt;code&gt;moment&lt;/code&gt; 를 가져오고 Atmosphere에서 &lt;code&gt;HTTP&lt;/code&gt; 를 가져 오려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="4c64b572b6ef2d24b502212bbb30ca768c6dbbea" translate="yes" xml:space="preserve">
          <source>In Meteor, it&amp;rsquo;s best to make stores &lt;em&gt;reactive data&lt;/em&gt; sources, as that way they tie most naturally into the rest of the ecosystem. There are a few different packages you can use for stores.</source>
          <target state="translated">Meteor에서는 매장을 &lt;em&gt;반응 형 데이터&lt;/em&gt; 소스 로 만드는 것이 가장 좋습니다. 이렇게하면 매장 이 다른 생태계와 가장 자연스럽게 연결됩니다. 상점에 사용할 수있는 몇 가지 다른 패키지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e155d50f4e4eecfcb2e4f34e4e2b6a5b9a059df8" translate="yes" xml:space="preserve">
          <source>In Meteor, it&amp;rsquo;s often less of a problem doing this than it would be in a typical MongoDB application, as it&amp;rsquo;s easy to publish overlapping sets of documents (we might need one set of users to render one screen of our app, and an intersecting set for another), which may stay on the client as we move around the application. So in that scenario there is an advantage to separating the subdocuments from the parent.</source>
          <target state="translated">Meteor에서는 겹치는 문서 세트를 쉽게 게시 할 수 있기 때문에 일반적인 MongoDB 애플리케이션에서보다 문제를 덜 겪는 경우가 종종 있습니다 (앱의 한 화면을 렌더링하려면 한 세트의 사용자와 교차하는 세트가 필요할 수 있음) 우리가 응용 프로그램을 돌아 다니면서 클라이언트에 남아있을 수 있습니다. 따라서이 시나리오에서는 하위 문서를 상위 문서와 분리하는 것이 유리합니다.</target>
        </trans-unit>
        <trans-unit id="04b569e393a950ad85b36c4944e4ee78cfce96f7" translate="yes" xml:space="preserve">
          <source>In Meteor, persistent or shared data comes over the wire on publications. However, there are some types of data which doesn&amp;rsquo;t need to be persistent or shared between users. For instance, the &amp;ldquo;logged-in-ness&amp;rdquo; of the current user, or the route they are currently viewing.</source>
          <target state="translated">Meteor에서 영구 또는 공유 데이터는 간행물을 통해 제공됩니다. 그러나 일부 유형의 데이터는 사용자간에 지속적이거나 공유 할 필요가 없습니다. 예를 들어, 현재 사용자의 &quot;로그인&quot;또는 현재보고있는 경로.</target>
        </trans-unit>
        <trans-unit id="243df2bc50939e5c8dbff8ec7e02da11a7cfafdd" translate="yes" xml:space="preserve">
          <source>In Meteor, that data layer is typically stored in MongoDB. A set of related data in MongoDB is referred to as a &amp;ldquo;collection&amp;rdquo;. In Meteor you access MongoDB through &lt;a href=&quot;http://docs.meteor.com/api/collections.html#Mongo-Collection&quot;&gt;collections&lt;/a&gt;, making them the primary persistence mechanism for your app data.</source>
          <target state="translated">Meteor에서 해당 데이터 계층은 일반적으로 MongoDB에 저장됩니다. MongoDB의 관련 데이터 세트를 &quot;컬렉션&quot;이라고합니다. Meteor에서는 &lt;a href=&quot;http://docs.meteor.com/api/collections.html#Mongo-Collection&quot;&gt;collections를&lt;/a&gt; 통해 MongoDB에 액세스 하여 앱 데이터의 기본 지속성 메커니즘으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d705c2f995526763684d5c0dbcc5d7413ae75f89" translate="yes" xml:space="preserve">
          <source>In Meteor, the pre-eminent schema package is &lt;a href=&quot;https://atmospherejs.com/aldeed/simple-schema&quot;&gt;aldeed:simple-schema&lt;/a&gt;. It&amp;rsquo;s an expressive, MongoDB based schema that&amp;rsquo;s used to insert and update documents. Another alternative is &lt;a href=&quot;https://atmospherejs.com/jagi/astronomy&quot;&gt;jagi:astronomy&lt;/a&gt; which is a full Object Model (OM) layer offering schema definition, server/client side validators, object methods and event handlers.</source>
          <target state="translated">Meteor에서 탁월한 스키마 패키지는 &lt;a href=&quot;https://atmospherejs.com/aldeed/simple-schema&quot;&gt;다음과 같습니다 : simple-schema&lt;/a&gt; . 문서를 삽입하고 업데이트하는 데 사용되는 표현적인 MongoDB 기반 스키마입니다. 또 다른 대안은 &lt;a href=&quot;https://atmospherejs.com/jagi/astronomy&quot;&gt;jagi : astronomy&lt;/a&gt; 로 스키마 정의, 서버 / 클라이언트 측 유효성 검사기, 객체 메소드 및 이벤트 핸들러를 제공하는 OM (전체 객체 모델) 계층입니다.</target>
        </trans-unit>
        <trans-unit id="c20ea551526624e66f32c02279ddfd4ad6a453ae" translate="yes" xml:space="preserve">
          <source>In Meteor, you use &lt;a href=&quot;http://docs.meteor.com/api/mobile-config.html#App-accessRule&quot;&gt;&lt;code&gt;App.accessRule&lt;/code&gt;&lt;/a&gt; in &lt;a href=&quot;http://docs.meteor.com/api/mobile-config.html&quot;&gt;&lt;code&gt;mobile-config.js&lt;/code&gt;&lt;/a&gt; to set additional rules. (These correspond to &lt;code&gt;&amp;lt;access&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;allow-navigation&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;allow-intent&amp;gt;&lt;/code&gt; tags in the generated &lt;code&gt;config.xml&lt;/code&gt;.)</source>
          <target state="translated">유성에서 사용 &lt;a href=&quot;http://docs.meteor.com/api/mobile-config.html#App-accessRule&quot;&gt; &lt;code&gt;App.accessRule&lt;/code&gt; 을&lt;/a&gt; 에 &lt;a href=&quot;http://docs.meteor.com/api/mobile-config.html&quot;&gt; &lt;code&gt;mobile-config.js&lt;/code&gt; &lt;/a&gt; 추가 규칙을 설정할 수 있습니다. (이들에 대응 &lt;code&gt;&amp;lt;access&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;allow-navigation&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;allow-intent&amp;gt;&lt;/code&gt; 생성 된 태그 &lt;code&gt;config.xml&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="08cb8883e896e97469dea50de221a87f03c6ddb2" translate="yes" xml:space="preserve">
          <source>In Safari on iOS8 (&lt;code&gt;window.close&lt;/code&gt; is not supported due to a bug)</source>
          <target state="translated">iOS8의 Safari에서 ( 버그로 인해 &lt;code&gt;window.close&lt;/code&gt; 가 지원되지 않음)</target>
        </trans-unit>
        <trans-unit id="e765da49b6b79dfd4b8f2657786c8bc5f8b9e578" translate="yes" xml:space="preserve">
          <source>In a Mocha test, it makes sense to use &lt;code&gt;stub-collections&lt;/code&gt; in a &lt;code&gt;beforeEach&lt;/code&gt;/&lt;code&gt;afterEach&lt;/code&gt; block.</source>
          <target state="translated">모카 테스트에서는 &lt;code&gt;beforeEach&lt;/code&gt; / &lt;code&gt;afterEach&lt;/code&gt; 블록 에서 &lt;code&gt;stub-collections&lt;/code&gt; 을 사용 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="da80a6cebc2bbd7e40ea51ebd1046f8a19142dc8" translate="yes" xml:space="preserve">
          <source>In a basic app, defining a Meteor Method is as simple as defining a function. In a complex app, you want a few extra features to make Methods more powerful and easily testable. First, we&amp;rsquo;re going to go over how to define a Method using the Meteor core API, and in a later section we&amp;rsquo;ll go over how to use a helpful wrapper package we&amp;rsquo;ve created to enable a more powerful Method workflow.</source>
          <target state="translated">기본 앱에서 Meteor Method를 정의하는 것은 함수를 정의하는 것만 큼 간단합니다. 복잡한 앱에서는 메소드를 더욱 강력하고 쉽게 테스트 할 수있는 몇 가지 추가 기능이 필요합니다. 먼저, Meteor 코어 API를 사용하여 메소드를 정의하는 방법을 살펴보고 이후 섹션에서보다 강력한 메소드 워크 플로우를 가능하게하기 위해 작성한 유용한 래퍼 패키지를 사용하는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="84469f6f0a35debbc63a6f80271ff741912d6215" translate="yes" xml:space="preserve">
          <source>In a server-side-rendered framework like Ruby on Rails, it&amp;rsquo;s sufficient to simply not display sensitive data in the returned HTML response. In Meteor, since the rendering is done on the client, an &lt;code&gt;if&lt;/code&gt; statement in your HTML template is not secure; you need to do security at the data level to make sure that data is never sent in the first place.</source>
          <target state="translated">Ruby on Rails와 같은 서버 측 렌더링 프레임 워크에서는 리턴 된 HTML 응답에 민감한 데이터를 표시하지 않는 것으로 충분합니다. Meteor에서는 렌더링이 클라이언트에서 이루어 지므로 HTML 템플릿 의 &lt;code&gt;if&lt;/code&gt; 문은 안전하지 않습니다. 데이터가 처음에 전송되지 않도록 데이터 수준에서 보안을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="32d304712bbdf90fd9fac9646044f4bd51f3331a" translate="yes" xml:space="preserve">
          <source>In a start tag in place of an attribute name/value pair</source>
          <target state="translated">속성 이름 / 값 쌍 대신 시작 태그에서</target>
        </trans-unit>
        <trans-unit id="f96457239ad16229e782b00e8a11ce292869f998" translate="yes" xml:space="preserve">
          <source>In a traditional web application stack, where the server renders HTML one page at a time, the URL is the fundamental entry point for the user to access the application. Users navigate an application by clicking through URLs, which are sent to the server via HTTP, and the server responds appropriately via a server-side router.</source>
          <target state="translated">서버가 HTML을 한 번에 한 페이지 씩 렌더링하는 전통적인 웹 응용 프로그램 스택에서 URL은 사용자가 응용 프로그램에 액세스하기위한 기본 진입 점입니다. 사용자는 HTTP를 통해 서버로 전송되는 URL을 클릭하여 응용 프로그램을 탐색하고 서버는 서버 측 라우터를 통해 적절하게 응답합니다.</target>
        </trans-unit>
        <trans-unit id="a98f067a3014e1e496902f925c40364c5fb35573" translate="yes" xml:space="preserve">
          <source>In a traditional, HTTP-based web application, the client and server communicate in a &amp;ldquo;request-response&amp;rdquo; fashion. Typically the client makes RESTful HTTP requests to the server and receives HTML or JSON data in response, and there&amp;rsquo;s no way for the server to &amp;ldquo;push&amp;rdquo; data to the client when changes happen at the backend.</source>
          <target state="translated">전통적인 HTTP 기반 웹 응용 프로그램에서 클라이언트와 서버는 &quot;요청-응답&quot;방식으로 통신합니다. 일반적으로 클라이언트는 서버에 RESTful HTTP 요청을하고 응답으로 HTML 또는 JSON 데이터를 수신하며, 백엔드에서 변경이 발생할 때 서버가 클라이언트에 데이터를 &quot;푸시&quot;할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c0aad52585bc81d3838aafeaa544382c0c5c06fb" translate="yes" xml:space="preserve">
          <source>In a web application, &lt;em&gt;routing&lt;/em&gt; is the process of using URLs to drive the user interface (UI). URLs are a prominent feature in every single web browser, and have several main functions from the user&amp;rsquo;s point of view:</source>
          <target state="translated">웹 애플리케이션에서 &lt;em&gt;라우팅&lt;/em&gt; 은 URL을 사용하여 사용자 인터페이스 (UI)를 구동하는 프로세스입니다. URL은 모든 단일 웹 브라우저에서 눈에 띄는 기능이며 사용자 관점에서 몇 가지 주요 기능을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="24fc6d3a11f7f9ee64e5bc4614dce9e9f93e6b25" translate="yes" xml:space="preserve">
          <source>In addition to CSS pre-processors like Sass, Less, and Stylus, there is now an ecosystem of CSS post-processors. Regardless of which CSS pre-processor you use, a post-processor can give you additional benefits like cross-browser compatibility.</source>
          <target state="translated">Sass, Less 및 Stylus와 같은 CSS 전 처리기 외에도 CSS 후 처리기의 에코 시스템이 생겼습니다. 사용하는 CSS 전처리기에 관계없이 후 처리기는 브라우저 간 호환성과 같은 추가 이점을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5d55f16ffee4dd36dfbe342034bd8bbd049ead8" translate="yes" xml:space="preserve">
          <source>In addition to configuring the &lt;a href=&quot;email&quot;&gt;&lt;code&gt;email&lt;/code&gt;&lt;/a&gt; package&amp;rsquo;s &lt;code&gt;MAIL_URL&lt;/code&gt;, it is critical that you set proper values (specifically the &lt;code&gt;from&lt;/code&gt; address) in &lt;a href=&quot;#Accounts-emailTemplates&quot;&gt;&lt;code&gt;Accounts.emailTemplates&lt;/code&gt;&lt;/a&gt; to ensure proper delivery of e-mails!</source>
          <target state="translated">&lt;a href=&quot;email&quot;&gt; &lt;code&gt;email&lt;/code&gt; &lt;/a&gt; 패키지의 &lt;code&gt;MAIL_URL&lt;/code&gt; 구성 외에도 전자 메일을 제대로 전달하려면 &lt;a href=&quot;#Accounts-emailTemplates&quot;&gt; &lt;code&gt;Accounts.emailTemplates&lt;/code&gt; &lt;/a&gt; &lt;code&gt;from&lt;/code&gt; 적절한 값 (특히 보낸 사람 주소) 을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="254e551511c3f0f235073f44d097d7a3b65e7068" translate="yes" xml:space="preserve">
          <source>In addition to having control over the templates, you&amp;rsquo;ll want to be able to control the routing and URLs for the different views offered by &lt;code&gt;useraccounts&lt;/code&gt;. Since Flow Router is the officially recommended routing option for Meteor, we&amp;rsquo;ll go over that in particular.</source>
          <target state="translated">템플릿을 제어 할 수있을뿐 아니라 &lt;code&gt;useraccounts&lt;/code&gt; 가 제공하는 다양한보기에 대한 라우팅 및 URL을 제어 할 수 있습니다 . Flow Router는 공식적으로 Meteor에 권장되는 라우팅 옵션이므로 특히 이에 대해 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="a9747d35b7695a04bf88b38e2c3d4145cdd4811e" translate="yes" xml:space="preserve">
          <source>In addition to identifying the user to your application, some services have APIs that allow you to take action on behalf of the user. To request specific permissions from the user, pass the &lt;code&gt;requestPermissions&lt;/code&gt; option the login function. This will cause the user to be presented with an additional page in the pop-up dialog to permit access to their data. The user&amp;rsquo;s &lt;code&gt;accessToken&lt;/code&gt; &amp;mdash; with permissions to access the service&amp;rsquo;s API &amp;mdash; is stored in the &lt;code&gt;services&lt;/code&gt; field of the user document. The supported values for &lt;code&gt;requestPermissions&lt;/code&gt; differ for each login service and are documented on their respective developer sites:</source>
          <target state="translated">애플리케이션에 사용자를 식별하는 것 외에도 일부 서비스에는 사용자를 대신하여 조치를 취할 수있는 API가 있습니다. 사용자에게 특정 권한을 요청하려면 &lt;code&gt;requestPermissions&lt;/code&gt; 옵션을 전달하십시오 . 그러면 팝업 대화 상자에 데이터에 대한 액세스를 허용하는 추가 페이지가 사용자에게 표시됩니다. 서비스 API에 대한 액세스 권한 이있는 사용자의 &lt;code&gt;accessToken&lt;/code&gt; 은 사용자 문서 의 &lt;code&gt;services&lt;/code&gt; 필드에 저장됩니다 . &lt;code&gt;requestPermissions&lt;/code&gt; 에 지원되는 값은 각 로그인 서비스마다 다르며 해당 개발자 사이트에 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1574ee753719b0815edfc480971fd438bb650e36" translate="yes" xml:space="preserve">
          <source>In addition to local scope and package scope, there are also package exports. A package export is a &amp;ldquo;pseudo global&amp;rdquo; variable that a package makes available for you to use when you install that package. For example, the &lt;code&gt;email&lt;/code&gt; package exports the &lt;code&gt;Email&lt;/code&gt; variable. If your app uses the &lt;code&gt;email&lt;/code&gt; package (and &lt;em&gt;only&lt;/em&gt; if it uses the &lt;code&gt;email&lt;/code&gt; package!) then your app can access the &lt;code&gt;Email&lt;/code&gt; symbol and you can call &lt;code&gt;Email.send&lt;/code&gt;. Most packages have only one export, but some packages might have two or three (for example, a package that provides several classes that work together).</source>
          <target state="translated">로컬 범위 및 패키지 범위 외에 패키지 내보내기도 있습니다. 패키지 내보내기는 패키지를 설치할 때 패키지에서 사용할 수있는 &quot;의사 전역&quot;변수입니다. 예를 들어 &lt;code&gt;email&lt;/code&gt; 패키지는 &lt;code&gt;Email&lt;/code&gt; 변수를 내 보냅니다 . 당신의 앱이 사용하는 경우 &lt;code&gt;email&lt;/code&gt; 패키지를 (그리고 &lt;em&gt;단지&lt;/em&gt; 가 사용하는 경우 &lt;code&gt;email&lt;/code&gt; 패키지를!) 다음 앱이 액세스 할 수있는 &lt;code&gt;Email&lt;/code&gt; 기호를 당신이 호출 할 수 있습니다 &lt;code&gt;Email.send&lt;/code&gt; 을 . 대부분의 패키지에는 하나의 내보내기 만 있지만 일부 패키지에는 2 개 또는 3 개의 패키지가있을 수 있습니다 (예 : 함께 작동하는 여러 클래스를 제공하는 패키지).</target>
        </trans-unit>
        <trans-unit id="1b22a39f7adb1f27dfac47bb5fc5985a0ccd460d" translate="yes" xml:space="preserve">
          <source>In addition to methods like &lt;code&gt;events&lt;/code&gt; and &lt;code&gt;helpers&lt;/code&gt;, documented as part of the &lt;a href=&quot;templates&quot;&gt;Template API&lt;/a&gt;, the following fields and methods are present on template objects:</source>
          <target state="translated">&lt;a href=&quot;templates&quot;&gt;Template API의&lt;/a&gt; 일부로 문서화 된 &lt;code&gt;events&lt;/code&gt; 및 &lt;code&gt;helpers&lt;/code&gt; 와 같은 메소드 외에도 다음 필드 및 메소드가 템플리트 오브젝트에 있습니다.</target>
        </trans-unit>
        <trans-unit id="68d18296af0e1595ea377e4e8d2b91f86dd27900" translate="yes" xml:space="preserve">
          <source>In addition to passing in the parameters as arguments to the &lt;code&gt;action&lt;/code&gt; function on the route, Flow Router makes a variety of information available via (reactive and otherwise) functions on the global singleton &lt;code&gt;FlowRouter&lt;/code&gt;. As the user navigates around your app, the values of these functions will change (reactively in some cases) correspondingly.</source>
          <target state="translated">Flow Router는 경로 의 &lt;code&gt;action&lt;/code&gt; 함수에 인수로 매개 변수를 전달하는 것 외에도 글로벌 싱글 톤 &lt;code&gt;FlowRouter&lt;/code&gt; 의 (반응 및 기타) 기능을 통해 다양한 정보를 제공 합니다. 사용자가 앱을 탐색함에 따라 이러한 기능의 값이 그에 따라 변경됩니다 (일부 경우에 반응 적으로).</target>
        </trans-unit>
        <trans-unit id="500f0cdb093cfeb5c24e523d322cfcac89b9b21e" translate="yes" xml:space="preserve">
          <source>In addition to that core API, there are some helpful shorthand helpers: &lt;code&gt;Meteor.user()&lt;/code&gt;, which is exactly equal to calling &lt;code&gt;Meteor.users.findOne(Meteor.userId())&lt;/code&gt;, and the &lt;code&gt;{{currentUser}}&lt;/code&gt; Blaze helper that returns the value of &lt;code&gt;Meteor.user()&lt;/code&gt;.</source>
          <target state="translated">그 핵심 API뿐만 아니라, 몇 가지 유용한 속기 도우미가 있습니다 : &lt;code&gt;Meteor.user()&lt;/code&gt; 정확히 호출 같다, &lt;code&gt;Meteor.users.findOne(Meteor.userId())&lt;/code&gt; , 그리고 &lt;code&gt;{{currentUser}}&lt;/code&gt; 블레이즈 도우미가 반환을 값 &lt;code&gt;Meteor.user()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abfea8c8c422e9a121afa6d85247dfce6e983e55" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;jquery&lt;/code&gt; package, Meteor provides several jQuery plugins as separate packages. These include:</source>
          <target state="translated">&lt;code&gt;jquery&lt;/code&gt; 패키지 외에도 Meteor는 여러 가지 jQuery 플러그인을 별도의 패키지로 제공합니다. 여기에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="dbea572dac37433068b62198ba9f8a2ada7605d1" translate="yes" xml:space="preserve">
          <source>In addition to the domain whitelisting mechanism Cordova implements, the web view itself may also enforce access rules through &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/CSP&quot;&gt;Content Security Policy (CSP)&lt;/a&gt;. For now, Meteor adds a permissive &lt;code&gt;&amp;lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;...&quot;&lt;/code&gt; header to the generated index page. We may want to allow more fine grained control in the future (through integrating with the &lt;code&gt;browser-policy&lt;/code&gt; package for instance.)</source>
          <target state="translated">Cordova가 구현하는 도메인 화이트리스트 메커니즘 외에도 웹보기 자체는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/CSP&quot;&gt;CSP (Content Security Policy)를&lt;/a&gt; 통해 액세스 규칙을 시행 할 수 있습니다 . 현재 Meteor는 허용 된 &lt;code&gt;&amp;lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;...&quot;&lt;/code&gt; 헤더를 생성 된 색인 페이지에 추가합니다. 예를 들어 &lt;code&gt;browser-policy&lt;/code&gt; 패키지 와의 통합을 통해 향후 더 세밀한 제어를 허용하고자 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="97782f3129575db978a071a5286f076d635aebf7" translate="yes" xml:space="preserve">
          <source>In addition to the properties and functions described below, you can assign additional properties of your choice to the object. Use the &lt;a href=&quot;templates#Template-onCreated&quot;&gt;&lt;code&gt;onCreated&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;templates#Template-onDestroyed&quot;&gt;&lt;code&gt;onDestroyed&lt;/code&gt;&lt;/a&gt; methods to add callbacks performing initialization or clean-up on the object.</source>
          <target state="translated">아래에 설명 된 속성 및 기능 외에도 원하는 추가 속성을 객체에 할당 할 수 있습니다. &lt;a href=&quot;templates#Template-onCreated&quot;&gt; &lt;code&gt;onCreated&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;templates#Template-onDestroyed&quot;&gt; &lt;code&gt;onDestroyed&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 오브젝트에서 초기화 또는 정리를 수행하는 콜백을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="8ced6cb3cd6aec9aa26ccbe5e79042362fb90a7e" translate="yes" xml:space="preserve">
          <source>In addition, Spacebars will call functions for you, so &lt;code&gt;{{foo.bar}}&lt;/code&gt; may be taken to mean &lt;code&gt;foo().bar&lt;/code&gt;, &lt;code&gt;foo.bar()&lt;/code&gt;, or &lt;code&gt;foo().bar()&lt;/code&gt; as appropriate.</source>
          <target state="translated">또한 스페이스 바는 함수를 호출하므로 &lt;code&gt;{{foo.bar}}&lt;/code&gt; 는 &lt;code&gt;foo().bar&lt;/code&gt; , &lt;code&gt;foo.bar()&lt;/code&gt; 또는 &lt;code&gt;foo().bar()&lt;/code&gt; 것으로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7297153e2ff4678269802ad1c25087b6ec8655f3" translate="yes" xml:space="preserve">
          <source>In addition, packages can include a different set of files for Cordova builds and browser builds with &lt;code&gt;addFiles&lt;/code&gt;:</source>
          <target state="translated">또한 패키지에는 &lt;code&gt;addFiles&lt;/code&gt; 를 사용하여 Cordova 빌드 및 브라우저 빌드를위한 다른 파일 세트가 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41cd2029bccb8ae22ec89e0f770c614fb7bce861" translate="yes" xml:space="preserve">
          <source>In addition, you will need to configure the server with the right connection address. This happens automatically if you&amp;rsquo;re using &lt;code&gt;meteor deploy&lt;/code&gt; to deploy to Galaxy, but when deploying to your own server you&amp;rsquo;ll have to make sure to define the &lt;code&gt;ROOT_URL&lt;/code&gt; environment variable there. (For Meteor Up, you can configure this in &lt;code&gt;mup.json&lt;/code&gt;.)</source>
          <target state="translated">또한 올바른 연결 주소로 서버를 구성해야합니다. 이는 &lt;code&gt;meteor deploy&lt;/code&gt; 를 사용하여 Galaxy에 배포하는 경우 자동으로 발생 하지만 자체 서버에 배포 할 경우 &lt;code&gt;ROOT_URL&lt;/code&gt; 환경 변수 를 정의해야합니다 . (Meteor Up의 경우 &lt;code&gt;mup.json&lt;/code&gt; 에서 이를 구성 할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="eb8a4c4b4c418aa05a1ae3ff4b909a7ae6d8876e" translate="yes" xml:space="preserve">
          <source>In all of our examples so far (outside of using&lt;code&gt;Meteor.publishComposite()&lt;/code&gt;) we&amp;rsquo;ve returned a cursor from our &lt;code&gt;Meteor.publish()&lt;/code&gt; handlers. Doing this ensures Meteor takes care of the job of keeping the contents of that cursor in sync between the server and the client. However, there&amp;rsquo;s another API you can use for publish functions which is closer to the way the underlying Distributed Data Protocol (DDP) works.</source>
          <target state="translated">지금까지의 모든 예제 ( &lt;code&gt;Meteor.publishComposite()&lt;/code&gt; 사용 제외)에서는 &lt;code&gt;Meteor.publish()&lt;/code&gt; 핸들러 에서 커서를 반환했습니다 . 이렇게하면 Meteor가 해당 커서의 내용을 서버와 클라이언트간에 동기화 된 상태로 유지하는 작업을 처리합니다. 그러나 기본 분산 데이터 프로토콜 (DDP)의 작동 방식에 더 가까운 게시 기능에 사용할 수있는 또 다른 API가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ad38b740358ecdcc878fd6eb3a2e8783e86430d" translate="yes" xml:space="preserve">
          <source>In all three Meteor supported CSS pre-processors you can import other style files from both relative and absolute paths in your app and from both npm and Meteor Atmosphere packages.</source>
          <target state="translated">3 가지 Meteor 지원 CSS 프리 프로세서 모두에서 앱의 상대 경로와 절대 경로 및 npm 및 Meteor Atmosphere 패키지 모두에서 다른 스타일 파일을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2bff92a3d08447c1ef56770839a28f6a7e97560" translate="yes" xml:space="preserve">
          <source>In an attribute value</source>
          <target state="translated">속성 값에서</target>
        </trans-unit>
        <trans-unit id="074ffbf148764d68cdccba5f19c1fa7e4961aeda" translate="yes" xml:space="preserve">
          <source>In an infinite scroll publication, we simply need to add a new argument to our publication controlling how many items to load. Suppose we wanted to paginate the todo items in our Todos example app:</source>
          <target state="translated">무한 스크롤 발행물에서는로드 할 항목 수를 제어하는 ​​새로운 인수를 발행물에 추가하기 만하면됩니다. Todos 예제 앱에서 할 일 항목을 페이지 매김하고 싶다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="28a83f5f63dd43cc115d0989bd09aaa92f50fa30" translate="yes" xml:space="preserve">
          <source>In another:</source>
          <target state="translated">또 다른:</target>
        </trans-unit>
        <trans-unit id="d62204bc13f389fb789a0a84468b26acf3fc21a5" translate="yes" xml:space="preserve">
          <source>In case of duplicate identification keys, all duplicates after the first are replaced with random ones. Using objects with unique &lt;code&gt;_id&lt;/code&gt; fields is the way to get full control over the identity of rendered elements.</source>
          <target state="translated">중복 식별 키의 경우 첫 번째 이후의 모든 중복은 임의의 중복으로 대체됩니다. 고유 한 &lt;code&gt;_id&lt;/code&gt; 필드가있는 객체를 사용하면 렌더링 된 요소의 아이덴티티를 완전히 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bb2df7708ffc61dea83f8fcc495f70389246c5d" translate="yes" xml:space="preserve">
          <source>In contrast to Meteor packages, you&amp;rsquo;ll have to specify the exact version of the plugin. This can be a bit of a pain because you first need to look up what the most recent &lt;a href=&quot;#plugin-compatibility&quot;&gt;(compatible)&lt;/a&gt; version of a plugin is before you can add it.</source>
          <target state="translated">Meteor 패키지와 달리 플러그인의 정확한 버전을 지정해야합니다. 플러그인을 추가하기 전에 가장 최근의 &lt;a href=&quot;#plugin-compatibility&quot;&gt;(호환 가능한)&lt;/a&gt; 플러그인 버전 을 먼저 찾아야하기 때문에 약간의 고통 이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5fb8709a2f0ca1acce23efe04cf7b9227338776" translate="yes" xml:space="preserve">
          <source>In contrast, Meteor operates on the principle of &lt;em&gt;data on the wire&lt;/em&gt;, where the server doesn&amp;rsquo;t think in terms of URLs or HTML pages. The client application communicates with the server over DDP. Typically as an application loads, it initializes a series of &lt;em&gt;subscriptions&lt;/em&gt; which fetch the data required to render the application. As the user interacts with the application, different subscriptions may load, but there&amp;rsquo;s no technical need for URLs to be involved in this process - you could easily have a Meteor app where the URL never changes.</source>
          <target state="translated">대조적으로, Meteor는 서버가 URL 또는 HTML 페이지로 생각하지 않는 &lt;em&gt;유선상&lt;/em&gt; 의 &lt;em&gt;데이터&lt;/em&gt; 원칙에 따라 작동 합니다. 클라이언트 응용 프로그램은 DDP를 통해 서버와 통신합니다. 일반적으로 응용 프로그램이로드되면 응용 프로그램 을 렌더링하는 데 필요한 데이터를 가져 오는 일련의 &lt;em&gt;구독&lt;/em&gt; 을 초기화합니다 . 사용자가 응용 프로그램과 상호 작용할 때 다른 구독이로드 될 수 있지만이 프로세스에 URL을 포함시킬 기술적 인 요구는 없습니다. URL이 변경되지 않는 Meteor 앱을 쉽게 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a75d46c699ae9dcb32de4c2902e36e65a7323ed6" translate="yes" xml:space="preserve">
          <source>In development, this can be accomplished with &lt;code&gt;meteor run --port &amp;lt;port&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">개발시 이것은 &lt;code&gt;meteor run --port &amp;lt;port&amp;gt;&lt;/code&gt; 로 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41f2552ffb3316d00522fa03c0d672bd44ebc89c" translate="yes" xml:space="preserve">
          <source>In development, this can be accomplished with &lt;code&gt;meteor run --port a.b.c.d:port&lt;/code&gt;.</source>
          <target state="translated">개발시 이것은 &lt;code&gt;meteor run --port a.b.c.d:port&lt;/code&gt; 로 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1547e45443ffc5fb4eacd479e6a27ffff9f59035" translate="yes" xml:space="preserve">
          <source>In development, this is accomplished with &lt;code&gt;meteor --settings [file.json]&lt;/code&gt; in order to provide full-reactivity when changing settings. Those settings are simply passed as a string here. Please see the &lt;a href=&quot;http://docs.meteor.com/api/core.html#Meteor-settings&quot;&gt;Meteor.settings&lt;/a&gt; documentation for further information.</source>
          <target state="translated">개발시에는 설정을 변경할 때 전체 반응성을 제공하기 위해 &lt;code&gt;meteor --settings [file.json]&lt;/code&gt; 을 사용 하여 수행됩니다. 이러한 설정은 단순히 문자열로 전달됩니다. 자세한 내용은 &lt;a href=&quot;http://docs.meteor.com/api/core.html#Meteor-settings&quot;&gt;Meteor.settings&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="66eed1452b660a96e4920e5e5fc7876625a51627" translate="yes" xml:space="preserve">
          <source>In fact, the default export is conceptually just another named export whose name happens to be &amp;ldquo;default&amp;rdquo;:</source>
          <target state="translated">실제로 기본 내보내기는 개념적으로 이름이 &quot;기본&quot;인 다른 명명 된 내보내기입니다.</target>
        </trans-unit>
        <trans-unit id="ffee380bed7d956f4542c972231b70e87958b38a" translate="yes" xml:space="preserve">
          <source>In general if you want to store arbitrary serializable data in a URL param, you can use &lt;a href=&quot;http://docs.meteor.com/#/full/ejson_stringify&quot;&gt;&lt;code&gt;EJSON.stringify()&lt;/code&gt;&lt;/a&gt; to turn it into a string. You&amp;rsquo;ll need to URL-encode the string using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent&quot;&gt;&lt;code&gt;encodeURIComponent&lt;/code&gt;&lt;/a&gt; to remove any characters that have meaning in a URL:</source>
          <target state="translated">일반적으로 임의의 직렬화 가능 데이터를 URL 매개 변수에 저장하려는 경우 &lt;a href=&quot;http://docs.meteor.com/#/full/ejson_stringify&quot;&gt; &lt;code&gt;EJSON.stringify()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 문자열로 변환 할 수 있습니다 . URL에 의미가있는 문자를 제거하려면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent&quot;&gt; &lt;code&gt;encodeURIComponent&lt;/code&gt; &lt;/a&gt; 를 사용하여 문자열을 URL 인코딩해야합니다 .</target>
        </trans-unit>
        <trans-unit id="42f56562317830f4b12417573fd1f24084b5a994" translate="yes" xml:space="preserve">
          <source>In general, you must specify a package's version (e.g., &lt;code&gt;'accounts@1.0.0'&lt;/code&gt; to use version 1.0.0 or a higher compatible version (ex: 1.0.1, 1.5.0, etc.) of the &lt;code&gt;accounts&lt;/code&gt; package). If you are sourcing core packages from a Meteor release with &lt;code&gt;versionsFrom&lt;/code&gt;, you may leave off version names for core packages. You may also specify constraints, such as &lt;code&gt;my:forms@=1.0.0&lt;/code&gt; (this package demands &lt;code&gt;my:forms&lt;/code&gt; at &lt;code&gt;1.0.0&lt;/code&gt; exactly), or &lt;code&gt;my:forms@1.0.0 || =2.0.1&lt;/code&gt; (&lt;code&gt;my:forms&lt;/code&gt; at &lt;code&gt;1.x.y&lt;/code&gt;, or exactly &lt;code&gt;2.0.1&lt;/code&gt;).</source>
          <target state="translated">일반적으로, 패키지의 (예를 들어, 버전 지정해야합니다 &lt;code&gt;'accounts@1.0.0'&lt;/code&gt; : (가)의 1.0.1, 1.5.0 등) 사용 버전 1.0.0 또는 더 높은 호환 버전 (예 : &lt;code&gt;accounts&lt;/code&gt; 패키지). &lt;code&gt;versionsFrom&lt;/code&gt; 과 함께 Meteor 릴리스에서 코어 패키지를 소싱하는 경우 코어 패키지의 버전 이름 이 생략 될 수 있습니다. &lt;code&gt;my:forms@=1.0.0&lt;/code&gt; (이 패키지 에는 정확히 &lt;code&gt;1.0.0&lt;/code&gt; 의 &lt;code&gt;my:forms&lt;/code&gt; 가 &lt;code&gt;my:forms@1.0.0 || =2.0.1&lt;/code&gt; ) 또는 my : forms@1.0.0 과 같은 제약 조건을 지정할 수도 있습니다 . || = 2.0.1 ( &lt;code&gt;my:forms&lt;/code&gt; 은 &lt;code&gt;1.x.y&lt;/code&gt; 또는 정확히 &lt;code&gt;2.0.1&lt;/code&gt; 입니다 ).</target>
        </trans-unit>
        <trans-unit id="d90a3412a3c35ae0d4d9a00f5337fa36394e6a1a" translate="yes" xml:space="preserve">
          <source>In most cases, simply wrapping the callback in &lt;code&gt;Meteor.bindEnvironment&lt;/code&gt; will do the trick. This function both wraps the callback in a fiber, and does some work to maintain Meteor&amp;rsquo;s server-side environment tracking. Here&amp;rsquo;s the same code with &lt;code&gt;Meteor.bindEnvironment&lt;/code&gt;:</source>
          <target state="translated">대부분의 경우 단순히 &lt;code&gt;Meteor.bindEnvironment&lt;/code&gt; 에서 콜백을 래핑 하면 트릭을 수행합니다. 이 기능은 콜백을 파이버로 감싸고 Meteor의 서버 측 환경 추적을 유지하기 위해 일부 작업을 수행합니다. 다음은 &lt;code&gt;Meteor.bindEnvironment&lt;/code&gt; 와 동일한 코드입니다 .</target>
        </trans-unit>
        <trans-unit id="876ee006558850d6ced23a44b1f6767aa8a1f893" translate="yes" xml:space="preserve">
          <source>In most normal situations, API keys from your settings file will only be used by the server, and by default the data passed in through &lt;code&gt;--settings&lt;/code&gt; is only available on the server. However, if you put data under a special key called &lt;code&gt;public&lt;/code&gt;, it will be available on the client. You might want to do this if, for example, you need to make an API call from the client and are OK with users knowing that key. Public settings will be available on the client under &lt;code&gt;Meteor.settings.public&lt;/code&gt;.</source>
          <target state="translated">대부분의 일반적인 상황에서 설정 파일의 API 키는 서버에서만 사용되며 기본적으로 &lt;code&gt;--settings&lt;/code&gt; 를 통해 전달 된 데이터 는 서버에서만 사용할 수 있습니다. 그러나 &lt;code&gt;public&lt;/code&gt; 이라는 특수 키 아래에 데이터를 넣으면 클라이언트에서 사용할 수 있습니다. 예를 들어 클라이언트에서 API 호출을해야하고 해당 키를 알고있는 사용자에게 문제가없는 경우이 작업을 수행 할 수 있습니다. 공개 설정은 클라이언트의 &lt;code&gt;Meteor.settings.public&lt;/code&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ac5b0f3dd6a9204e7e6fe1a3b2ae8988622aecc7" translate="yes" xml:space="preserve">
          <source>In most ways, testing a Meteor app is no different from testing any other full stack JavaScript application. However, compared to more traditional backend or front-end focused frameworks, two factors can make testing a little more challenging:</source>
          <target state="translated">대부분의 경우, Meteor 앱 테스트는 다른 풀 스택 JavaScript 애플리케이션 테스트와 다르지 않습니다. 그러나보다 전통적인 백엔드 또는 프론트 엔드 중심 프레임 워크와 비교할 때 두 가지 요소로 인해 테스트가 조금 더 어려워 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c552c52bc3f3ce110f62879e28d7c812aa8fd7f" translate="yes" xml:space="preserve">
          <source>In one terminal, we can do:</source>
          <target state="translated">한 터미널에서 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95183e67e9e7b925ce0590a932667601e3ee8abe" translate="yes" xml:space="preserve">
          <source>In order for Galaxy to work with your custom domain (&lt;code&gt;your-app.com&lt;/code&gt; in this case), you need to &lt;a href=&quot;http://galaxy-guide.meteor.com/dns.html&quot;&gt;set up your DNS to point at Galaxy&lt;/a&gt;. Once you&amp;rsquo;ve done this, you should be able to reach your site from a browser.</source>
          <target state="translated">Galaxy가 사용자 지정 도메인 ( 이 경우 &lt;code&gt;your-app.com&lt;/code&gt; ) 과 작동하도록하려면 Galaxy &lt;a href=&quot;http://galaxy-guide.meteor.com/dns.html&quot;&gt;를 가리 키도록 DNS를 설정해야합니다&lt;/a&gt; . 이 작업을 완료하면 브라우저에서 사이트를 방문 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af11932b55bf47cb987fa62abbddfc787b349037" translate="yes" xml:space="preserve">
          <source>In order to avoid a situation where JavaScript code that relies on changed native code is pushed to a client, we calculate a compatibility version hash from the Cordova platform and plugin versions, and only download a new version to a device when there is an exact match. This means any change to the list of plugins, or updating to a Meteor release which contains a new platform version, will block hot code push to existing mobile clients until the app has been updated from the store.</source>
          <target state="translated">변경된 네이티브 코드에 의존하는 JavaScript 코드가 클라이언트로 푸시되는 상황을 피하기 위해 Cordova 플랫폼 및 플러그인 버전에서 호환성 버전 해시를 계산하고 정확히 일치하는 경우에만 장치에 새 버전을 다운로드합니다 . 즉, 플러그인 목록을 변경하거나 새 플랫폼 버전이 포함 된 Meteor 릴리스로 업데이트하면 스토어에서 앱이 업데이트 될 때까지 기존 모바일 클라이언트에 대한 핫 코드 푸시가 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="1095541060de9f532b046fdedba0debfabec44ba" translate="yes" xml:space="preserve">
          <source>In order to build and run Android apps, you will need to:</source>
          <target state="translated">Android 앱을 빌드하고 실행하려면 다음이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3f944e5599ea66b86050615b4a5b09a0f9cfeda5" translate="yes" xml:space="preserve">
          <source>In order to build and run iOS apps, you will need a Mac with &lt;a href=&quot;https://developer.apple.com/xcode/&quot;&gt;Apple Xcode&lt;/a&gt; developer tools installed. We recommend installing the latest version, but you should also check the &lt;a href=&quot;https://github.com/meteor/meteor/blob/devel/History.md&quot;&gt;Meteor history&lt;/a&gt; for any specific version dependencies.</source>
          <target state="translated">iOS 앱을 빌드하고 실행하려면 &lt;a href=&quot;https://developer.apple.com/xcode/&quot;&gt;Apple Xcode&lt;/a&gt; 개발자 도구가 설치된 Mac이 필요합니다 . 최신 버전을 설치하는 것이 좋지만 특정 버전 종속성에 대한 &lt;a href=&quot;https://github.com/meteor/meteor/blob/devel/History.md&quot;&gt;Meteor 기록&lt;/a&gt; 도 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a134fe859a2d1d915a31aa217a1d22162302e6d8" translate="yes" xml:space="preserve">
          <source>In order to build and run mobile apps, you will need to install some prerequisites on your local machine.</source>
          <target state="translated">모바일 앱을 빌드하고 실행하려면 로컬 컴퓨터에 일부 필수 구성 요소를 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="37933940fd10fbe726076dfb20016532e832ce79" translate="yes" xml:space="preserve">
          <source>In order to build your app for Android, you will need to &lt;a href=&quot;#configuring-your-app&quot;&gt;configure your app&lt;/a&gt; with at least a version number, and the required set of app icons and launch screens.</source>
          <target state="translated">Android 용 앱을 빌드하려면 최소한 버전 번호, 필요한 앱 아이콘 및 시작 화면 세트로 앱 을 &lt;a href=&quot;#configuring-your-app&quot;&gt;구성해야합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5b038d1d31a2ea430908a2ca9ebb59b5ffa98c6f" translate="yes" xml:space="preserve">
          <source>In order to build your app for iOS, you will need to &lt;a href=&quot;#configuring-your-app&quot;&gt;configure your app&lt;/a&gt; with at least a version number, and the required set of app icons and launch screens.</source>
          <target state="translated">iOS 용 앱을 빌드하려면 최소한 버전 번호, 필요한 앱 아이콘 및 시작 화면으로 앱 을 &lt;a href=&quot;#configuring-your-app&quot;&gt;구성해야합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3695f6f0f1be90a7e86fa13c1a10465a121552f0" translate="yes" xml:space="preserve">
          <source>In order to check that a user has installed the correct versions of npm packages, you can use the &lt;a href=&quot;https://atmospherejs.com/tmeasday/check-npm-versions&quot;&gt;&lt;code&gt;tmeasday:check-npm-versions&lt;/code&gt;&lt;/a&gt; package to check dependency versions at runtime.</source>
          <target state="translated">사용자가 올바른 버전의 npm 패키지를 설치 &lt;a href=&quot;https://atmospherejs.com/tmeasday/check-npm-versions&quot;&gt; &lt;code&gt;tmeasday:check-npm-versions&lt;/code&gt; &lt;/a&gt; 하기 위해 tmeasday : check-npm-versions 패키지를 사용하여 런타임시 종속성 버전을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecd270745296cda593c6978ffc2b9a281c12001c" translate="yes" xml:space="preserve">
          <source>In order to deploy to Galaxy, you&amp;rsquo;ll need to &lt;a href=&quot;https://www.meteor.com/galaxy/signup&quot;&gt;sign up for an account&lt;/a&gt;, and separately provision a MongoDB database (see below).</source>
          <target state="translated">Galaxy에 배포하려면 &lt;a href=&quot;https://www.meteor.com/galaxy/signup&quot;&gt;계정&lt;/a&gt; 에 가입 하고 MongoDB 데이터베이스를 별도로 프로비저닝해야합니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="0100e88f1f4d191fc64f05211f5fbbd8cbbe0092" translate="yes" xml:space="preserve">
          <source>In order to ensure your component always gets the data you expect, you should validate the data context provided to it. This is just like validating the arguments to any Meteor Method or publication, and lets you write your validation code in one place and then assume that the data is correct.</source>
          <target state="translated">구성 요소가 항상 예상 한 데이터를 가져 오려면 제공된 데이터 컨텍스트의 유효성을 검증해야합니다. 이는 인수를 Meteor Method 또는 Publication의 유효성을 검사하는 것과 같으며 유효성 검사 코드를 한 곳에 작성하고 데이터가 올바른 것으로 가정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d396d4b652641df47632e7daa1a2b6d5f306e7e0" translate="yes" xml:space="preserve">
          <source>In order to help with this, we pin core plugins to a minimum version known to work with the Cordova versions we bundle. This mechanism doesn&amp;rsquo;t apply to third-party plugins however, so you&amp;rsquo;ll have to assess compatibility for these yourself.</source>
          <target state="translated">이를 돕기 위해 번들로 묶은 Cordova 버전과 작동하는 것으로 알려진 최소 버전으로 핵심 플러그인을 고정합니다. 그러나이 메커니즘은 타사 플러그인에는 적용되지 않으므로 이러한 플러그인의 호환성을 평가해야합니다.</target>
        </trans-unit>
        <trans-unit id="a3dadd58446c260ec034cda6418866472bcdac4a" translate="yes" xml:space="preserve">
          <source>In our example of the list page from the Todos app, we access the current list&amp;rsquo;s id with &lt;code&gt;FlowRouter.getParam('_id')&lt;/code&gt; (we&amp;rsquo;ll see more on this below).</source>
          <target state="translated">Todos 앱의 목록 페이지 예에서 &lt;code&gt;FlowRouter.getParam('_id')&lt;/code&gt; 를 사용하여 현재 목록의 ID에 액세스합니다 (아래에서 자세히 볼 것입니다).</target>
        </trans-unit>
        <trans-unit id="110a9d1509fc3777c243276d40bda42245df81e5" translate="yes" xml:space="preserve">
          <source>In our example, the &lt;code&gt;autorun&lt;/code&gt; will re-run whenever &lt;code&gt;this.getListId()&lt;/code&gt; changes, (ultimately because &lt;code&gt;FlowRouter.getParam('_id')&lt;/code&gt; changes), although other common reactive data sources are:</source>
          <target state="translated">이 예에서 다른 일반적인 반응 형 데이터 소스는 다음과 같지만 &lt;code&gt;this.getListId()&lt;/code&gt; 변경 될 때마다 ( &lt;code&gt;autorun&lt;/code&gt; 으로 &lt;code&gt;FlowRouter.getParam('_id')&lt;/code&gt; 가 변경됨) 자동 실행 이 다시 실행 됩니다 .</target>
        </trans-unit>
        <trans-unit id="5f1118f050e1e527ba90635c862b4ac7a0be8bb1" translate="yes" xml:space="preserve">
          <source>In practice, this means that you should do most of your security and validation on the boundary between these two domains. In simple terms:</source>
          <target state="translated">실제로 이는 두 도메인 간의 경계에서 대부분의 보안 및 유효성 검사를 수행해야 함을 의미합니다. 간단히 말해서 :</target>
        </trans-unit>
        <trans-unit id="ff8362e76f2b5492fce7b9ccc1912bcccbafff6a" translate="yes" xml:space="preserve">
          <source>In production</source>
          <target state="translated">생산 중</target>
        </trans-unit>
        <trans-unit id="6e9d0b9bac3c9016a8172bf03b65fdc616968da2" translate="yes" xml:space="preserve">
          <source>In regular JavaScript functions, you indicate errors by throwing an &lt;code&gt;Error&lt;/code&gt; object. Throwing errors from Meteor Methods works almost the same way, but a bit of complexity is introduced by the fact that in some cases the error object will be sent over a websocket back to the client.</source>
          <target state="translated">일반적인 JavaScript 함수에서는 &lt;code&gt;Error&lt;/code&gt; 객체를 발생시켜 오류를 나타냅니다 . Meteor Methods에서 오류를 던지는 것은 거의 같은 방식으로 작동하지만 경우에 따라 오류 개체가 웹 소켓을 통해 클라이언트로 다시 전송된다는 사실로 인해 약간의 복잡성이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="86362326c255302320a86c160f4f23716a23fa60" translate="yes" xml:space="preserve">
          <source>In some cases you want to change routes based on user action outside of them clicking on a link. For instance, in the example app, when a user creates a new list, we want to route them to the list they just created. We do this by calling &lt;code&gt;FlowRouter.go()&lt;/code&gt; once we know the id of the new list:</source>
          <target state="translated">경우에 따라 링크를 클릭하는 외부 사용자 조치를 기반으로 경로를 변경하려고합니다. 예를 들어 예제 앱에서 사용자가 새 목록을 만들면 방금 만든 목록으로 라우팅하려고합니다. 새 목록의 ID를 알고 나면 &lt;code&gt;FlowRouter.go()&lt;/code&gt; 를 호출 하여이 작업을 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="3755ced3aa531457993ff464095e1613a41daeb3" translate="yes" xml:space="preserve">
          <source>In summary, you should make sure that any options passed from the client to a publication can only restrict the data being requested, rather than extending it.</source>
          <target state="translated">요약하면 클라이언트에서 게시로 전달 된 모든 옵션은 요청하는 데이터를 확장하는 것이 아니라 제한 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="154b7f812990909b655a30ced949019ea3ec45aa" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;#simple-blaze-unit-test&quot;&gt;unit tests above&lt;/a&gt; we saw a very limited example of how to isolate a module from the larger app. This is critical for proper unit testing. Some other utilities and techniques include:</source>
          <target state="translated">위의 &lt;a href=&quot;#simple-blaze-unit-test&quot;&gt;단위 테스트에서&lt;/a&gt; 우리는 더 큰 앱에서 모듈을 분리하는 방법에 대한 매우 제한된 예를 보았습니다. 이것은 적절한 단위 테스트에 중요합니다. 다른 유틸리티 및 기술에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="cd03cba6f3f4c87ab484dc96fbf5f9080dd290da" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;data-loading#pagination&quot;&gt;Data Loading article&lt;/a&gt; we discuss a pattern of paging through an &amp;ldquo;infinite scroll&amp;rdquo; type subscription which loads one page of data at a time as a user scrolls down the page. It&amp;rsquo;s interesting to consider UX patterns to consume that data and indicate what&amp;rsquo;s happening to the user.</source>
          <target state="translated">에서 &lt;a href=&quot;data-loading#pagination&quot;&gt;데이터로드 기사&lt;/a&gt; 우리는 부하 데이터의 한 페이지를 사용자가 페이지 아래로 스크롤 같은 시간에 &quot;무한 스크롤&quot;타입의 가입을 통해 페이징의 패턴을 설명합니다. UX 패턴을 고려하여 해당 데이터를 소비하고 사용자에게 무슨 일이 일어나고 있는지 나타내는 것이 흥미 롭습니다.</target>
        </trans-unit>
        <trans-unit id="c5b5f38a9dbced09959afc33d982e81d4214f9a8" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://github.com/meteor/todos&quot;&gt;Todos&lt;/a&gt; example app, thanks to the fact that we&amp;rsquo;ve split our User Interface into &lt;a href=&quot;ui-ux#components&quot;&gt;smart and reusable components&lt;/a&gt;, it&amp;rsquo;s natural to want to unit test some of our reusable components (we&amp;rsquo;ll see below how to &lt;a href=&quot;#simple-integration-test&quot;&gt;integration test&lt;/a&gt; our smart components).</source>
          <target state="translated">에서 &lt;a href=&quot;https://github.com/meteor/todos&quot;&gt;왜 그렇게 된&lt;/a&gt; 예제 응용 프로그램, 우리는에 우리의 사용자 인터페이스를 나누었다는 사실 덕분에 &lt;a href=&quot;ui-ux#components&quot;&gt;스마트하고 재사용 가능한 구성 요소&lt;/a&gt; , 그것은 우리의 재사용 가능한 구성 요소의 일부 (우리가 방법을 아래에 나타납니다 단위 테스트하려는 자연스러운 &lt;a href=&quot;#simple-integration-test&quot;&gt;통합 테스트&lt;/a&gt; 우리의 스마트 구성 요소) .</target>
        </trans-unit>
        <trans-unit id="aa2f9ac4ae09c3a6a03e519716500e4f30a23748" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://github.com/meteor/todos&quot;&gt;Todos&lt;/a&gt; example app, we define a factory to describe how to create a test todo item, using the &lt;a href=&quot;https://www.npmjs.com/package/faker&quot;&gt;&lt;code&gt;faker&lt;/code&gt;&lt;/a&gt; npm package:</source>
          <target state="translated">에서 &lt;a href=&quot;https://github.com/meteor/todos&quot;&gt;왜 그렇게 된&lt;/a&gt; 예제 응용 프로그램, 우리는 사용하여 테스트 할 일 항목을 생성하는 방법에 대해 설명하는 공장 정의 &lt;a href=&quot;https://www.npmjs.com/package/faker&quot;&gt; &lt;code&gt;faker&lt;/code&gt; &lt;/a&gt; NPM 패키지를 :</target>
        </trans-unit>
        <trans-unit id="0cd10266ce18083c8c52cb5aae9c7eb32c70b16e" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://github.com/meteor/todos&quot;&gt;Todos&lt;/a&gt; example app, we have an integration test for the &lt;code&gt;Lists_show_page&lt;/code&gt; smart component. This test simply ensures that when the correct data is present in the database, the template renders correctly &amp;ndash; that it is gathering the correct data as we expect. It isolates the rendering tree from the more complex data subscription part of the Meteor stack. If we wanted to test that the subscription side of things was working in concert with the smart component, we&amp;rsquo;d need to write a &lt;a href=&quot;#full-app-integration-test&quot;&gt;full app integration test&lt;/a&gt;.</source>
          <target state="translated">에서 &lt;a href=&quot;https://github.com/meteor/todos&quot;&gt;왜 그렇게 된&lt;/a&gt; 예제 응용 프로그램, 우리는 대한 통합 테스트가 &lt;code&gt;Lists_show_page&lt;/code&gt; 스마트 구성 요소를. 이 테스트는 데이터베이스에 올바른 데이터가있을 때 템플릿이 올바르게 렌더링되어 올바른 데이터가 예상대로 수집되는지 확인합니다. 렌더링 트리를 Meteor 스택의 더 복잡한 데이터 구독 부분과 분리합니다. 구독 측면이 스마트 구성 요소와 함께 작동하는지 &lt;a href=&quot;#full-app-integration-test&quot;&gt;테스트하려면 전체 앱 통합 테스트&lt;/a&gt; 를 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="00b754fe9ced1dfd5206ceba80b40b057cf765f1" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://github.com/meteor/todos&quot;&gt;Todos&lt;/a&gt; example application, we have a integration test which ensures that we see the full contents of a list when we route to it, which demonstrates a few techniques of integration tests.</source>
          <target state="translated">에서 &lt;a href=&quot;https://github.com/meteor/todos&quot;&gt;왜 그렇게 된&lt;/a&gt; 예제 응용 프로그램, 우리는 그것에 우리 경로, 통합 테스트의 몇 가지 기술에 대해 설명 할 때 우리는 목록의 전체 내용을 볼 수 있음을 보장하는 통합 테스트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd1c9fe855dd52330c81745b2eaa8b6d9a48a31b" translate="yes" xml:space="preserve">
          <source>In the Todos example app, we already have a wrapping component for the list that talks to the router and sets up subscriptions. This component could easily be extended to understand pagination:</source>
          <target state="translated">Todos 예제 앱에는 이미 라우터와 통신하고 구독을 설정하는 목록의 래핑 구성 요소가 있습니다. 이 구성 요소는 페이지 매김을 이해하도록 쉽게 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4152f7ff0a1d8b4927f75d321cc1bc0eaf345b9f" translate="yes" xml:space="preserve">
          <source>In the Todos example app, we build a &lt;code&gt;incompleteCountDenormalizer&lt;/code&gt; to abstract the counting of incomplete todos on the lists. This code needs to run whenever a todo item is inserted, updated (checked or unchecked), or removed. The code looks like:</source>
          <target state="translated">Todos 예제 앱에서 &lt;code&gt;incompleteCountDenormalizer&lt;/code&gt; 를 빌드 하여 목록에서 불완전한 할일의 계산을 추상화합니다. 이 코드는 할 일 항목을 삽입, 업데이트 (체크 또는 체크 해제)하거나 제거 할 때마다 실행해야합니다. 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bfb04dea501399ed95b413d52e56102a16943eb7" translate="yes" xml:space="preserve">
          <source>In the Todos example app, we have done this, and you can now access our publications over HTTP:</source>
          <target state="translated">Todos 예제 앱에서이를 수행했으며 이제 HTTP를 통해 발행물에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9a2d1d927f8a3f86168a8233f485d3e147994c6" translate="yes" xml:space="preserve">
          <source>In the Todos example app, we link to each list the user knows about in the &lt;code&gt;App_body&lt;/code&gt; template:</source>
          <target state="translated">Todos 예제 앱에서는 &lt;code&gt;App_body&lt;/code&gt; 템플릿 에서 사용자가 알고있는 각 목록에 연결합니다 .</target>
        </trans-unit>
        <trans-unit id="5942975a97800cdf89c874bcbc7a658118e21a15" translate="yes" xml:space="preserve">
          <source>In the Todos example app, we use the following code to set a basic rate limit on all Methods:</source>
          <target state="translated">Todos 예제 앱에서 다음 코드를 사용하여 모든 메소드에 대한 기본 속도 제한을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="4841073ceb3cd7cc3a48b756092ed6f3b5674ad0" translate="yes" xml:space="preserve">
          <source>In the below example, your &lt;code&gt;App&lt;/code&gt; component would receive a &lt;code&gt;main&lt;/code&gt; prop with a instantiated React Element to render:</source>
          <target state="translated">아래 예에서 &lt;code&gt;App&lt;/code&gt; 구성 요소는 렌더링 할 React Element 가 포함 된 &lt;code&gt;main&lt;/code&gt; 소품을 받습니다 .</target>
        </trans-unit>
        <trans-unit id="6b7dd1cd09ae0021104564795bd86664a9639f40" translate="yes" xml:space="preserve">
          <source>In the body of a callback, &lt;code&gt;this&lt;/code&gt; is a &lt;a href=&quot;templates#Template-instances&quot;&gt;template instance&lt;/a&gt; object that is unique to this occurrence of the template and persists across re-renderings. Use the &lt;code&gt;onCreated&lt;/code&gt; and &lt;code&gt;onDestroyed&lt;/code&gt; callbacks to perform initialization or clean-up on the object.</source>
          <target state="translated">콜백 본문 &lt;code&gt;this&lt;/code&gt; &lt;a href=&quot;templates#Template-instances&quot;&gt;템플릿&lt;/a&gt; 은이 템플릿 발생에 고유하고 다시 렌더링 할 때까지 지속 되는 템플릿 인스턴스 객체입니다. 사용 &lt;code&gt;onCreated&lt;/code&gt; 및 &lt;code&gt;onDestroyed&lt;/code&gt; 개체에 초기화 또는 청소를 수행하는 콜백을.</target>
        </trans-unit>
        <trans-unit id="ffcf96e7bef4cc2550b3b4637a1fe80e204eb39e" translate="yes" xml:space="preserve">
          <source>In the case of a logged-out user, we explicitly call &lt;code&gt;this.ready()&lt;/code&gt;, which indicates to the subscription that we&amp;rsquo;ve sent all the data we are initially going to send (in this case none). It&amp;rsquo;s important to know that if you don&amp;rsquo;t return a cursor from the publication or call &lt;code&gt;this.ready()&lt;/code&gt;, the user&amp;rsquo;s subscription will never become ready, and they will likely see a loading state forever.</source>
          <target state="translated">로그 아웃 한 사용자의 경우 명시 적으로 &lt;code&gt;this.ready()&lt;/code&gt; 호출 하여 구독에 처음으로 보내려는 모든 데이터를 보냈 음을 나타냅니다 (이 경우에는 없음). 게시에서 커서를 반환하지 않거나 &lt;code&gt;this.ready()&lt;/code&gt; 호출하지 않으면 사용자의 구독이 준비되지 않으며로드 상태가 영원히 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ea6c2e2f7dd4b5ca26ce085b335adebe1937488" translate="yes" xml:space="preserve">
          <source>In the case of the Todos application, as we want to display the number of unfinished todos next to each list, we need to denormalize &lt;code&gt;list.incompleteTodoCount&lt;/code&gt;. This is an inconvenience but typically reasonably easy to do as we&amp;rsquo;ll see in the section on &lt;a href=&quot;#abstracting-denormalizers&quot;&gt;abstracting denormalizers&lt;/a&gt; below.</source>
          <target state="translated">Todos 애플리케이션의 경우, 각 목록 옆에 완료되지 않은 &lt;code&gt;list.incompleteTodoCount&lt;/code&gt; 수를 표시하려면 list.incompleteTodoCount 를 비정규 화해야합니다 . 이는 불편하지만 일반적으로 아래의 &lt;a href=&quot;#abstracting-denormalizers&quot;&gt;비정규 화기 추상화&lt;/a&gt; 섹션에서 볼 수 있듯이 상당히 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="2957437af76604980e751ea1c401963d86da16c9" translate="yes" xml:space="preserve">
          <source>In the context of a Blaze helper, &lt;code&gt;this&lt;/code&gt; is scoped to the current &lt;em&gt;data context&lt;/em&gt; at the point the helper was used. This can be hard to reason about, so it&amp;rsquo;s often a good idea to instead pass the required data into the helper as an argument (as we do here).</source>
          <target state="translated">블레이즈 헬퍼의 맥락에서, &lt;code&gt;this&lt;/code&gt; 현재까지 범위가 &lt;em&gt;데이터 컨텍스트&lt;/em&gt; 헬퍼가 사용 된 점. 이것은 추론하기 어려울 수 있으므로 필요한 데이터를 대신 도우미로 전달하는 것이 좋습니다 (여기에서와 같이).</target>
        </trans-unit>
        <trans-unit id="3b111aa7d6dfce20fe48e45474489a66532dcdc1" translate="yes" xml:space="preserve">
          <source>In the distant past, it could have been a huge headache to get Facebook or Google login to work with your app. Thankfully, most popular login providers have standardized around some version of &lt;a href=&quot;https://en.wikipedia.org/wiki/OAuth&quot;&gt;OAuth&lt;/a&gt;, and Meteor supports some of the most popular login services out of the box.</source>
          <target state="translated">먼 과거에는 Facebook 또는 Google 로그인을 사용하여 앱을 작동시키는 데 큰 어려움이있었습니다. 고맙게도, 가장 인기있는 로그인 제공 업체는 일부 &lt;a href=&quot;https://en.wikipedia.org/wiki/OAuth&quot;&gt;OAuth&lt;/a&gt; 버전을 기준으로 표준화 했으며 Meteor는 기본적으로 가장 많이 사용되는 로그인 서비스를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="6f7a04de97df1a0989d9427322890dd7af2c9f4c" translate="yes" xml:space="preserve">
          <source>In the event that a platform does not offer the ability to configure this, the &lt;code&gt;force-ssl&lt;/code&gt; package can be added to the project and Meteor will attempt to intelligently redirect based on the presence of the &lt;code&gt;x-forwarded-for&lt;/code&gt; header.</source>
          <target state="translated">플랫폼에서이를 구성 할 수있는 기능을 제공하지 않는 경우 &lt;code&gt;force-ssl&lt;/code&gt; 패키지를 프로젝트에 추가 할 수 있으며 Meteor는 &lt;code&gt;x-forwarded-for&lt;/code&gt; 헤더 의 존재 여부에 따라 지능적으로 리디렉션하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="33d609ba9ea9ec0778a93a11d4f1c75031af9649" translate="yes" xml:space="preserve">
          <source>In the event that your own deployment platform does not support WebSockets, or you are confident that you will not benefit from them, setting this variable with &lt;code&gt;DISABLE_WEBSOCKETS=1&lt;/code&gt; will explicitly disable WebSockets and forcibly resort to the fallback polling-mechanism, instead of trying to detect this automatically.</source>
          <target state="translated">자체 배포 플랫폼이 WebSocket을 지원하지 않거나 그로부터 이점을 얻지 못할 것이라고 확신하는 경우 &lt;code&gt;DISABLE_WEBSOCKETS=1&lt;/code&gt; 로이 변수를 설정하면 WebSocket이 명시 적으로 비활성화되고 강제 폴링 메커니즘 대신 강제로 폴링 메커니즘을 사용합니다. 이것을 자동으로 감지하십시오.</target>
        </trans-unit>
        <trans-unit id="62250cb451baa040e8183f5601b89d20569053a3" translate="yes" xml:space="preserve">
          <source>In the example app we are using the Flow Router integration with great success. Some of the later sections will cover how to customize the routes and templates to fit your app better.</source>
          <target state="translated">예제 앱에서는 Flow Router 통합을 성공적으로 사용하고 있습니다. 이후 섹션 중 일부에서는 앱에 맞게 경로와 템플릿을 사용자 지정하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="5b67d1d86027f5daf65368d7edbca35a1db90b62" translate="yes" xml:space="preserve">
          <source>In the first example, if the &lt;code&gt;userId&lt;/code&gt; property on the selected list changes, the query in the publication will still return the data, since the security check in the beginning will not re-run. In the second example, we have fixed this by putting the security check in the returned query itself.</source>
          <target state="translated">첫 번째 예 에서 선택한 목록 의 &lt;code&gt;userId&lt;/code&gt; 속성이 변경되면 시작의 보안 검사가 다시 실행되지 않기 때문에 게시의 쿼리는 여전히 데이터를 반환합니다. 두 번째 예에서는 반환 된 쿼리 자체에 보안 검사를 추가하여이 문제를 해결했습니다.</target>
        </trans-unit>
        <trans-unit id="1b19d3f92a4202469b135b88552d3ccf5b0864af" translate="yes" xml:space="preserve">
          <source>In the future, when client reconnection is fully implemented, reconnecting from the client will reconnect to the same connection on the server: the &lt;code&gt;onConnection&lt;/code&gt; callback won&amp;rsquo;t be called for that connection again, and the connection will still have the same connection &lt;code&gt;id&lt;/code&gt;.</source>
          <target state="translated">나중에 클라이언트 재 연결이 완전히 구현되면 클라이언트에서 다시 연결하면 서버의 동일한 연결에 다시 연결됩니다. 해당 연결에 대해 &lt;code&gt;onConnection&lt;/code&gt; 콜백이 다시 호출되지 않으며 연결의 연결 &lt;code&gt;id&lt;/code&gt; 는 여전히 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="b9935b768ce988e3fa5cad7fddb5e2f8b66952ab" translate="yes" xml:space="preserve">
          <source>In the list above, we didn&amp;rsquo;t cover the case when the Method execution on the server throws an error. In that case, there is no return value, and the client gets an error instead. The Method callback is fired instantly with the returned error as the first argument. Read more about error handling in the section about errors below.</source>
          <target state="translated">위의 목록에서 서버의 메소드 실행에서 오류가 발생하는 경우는 다루지 않았습니다. 이 경우 반환 값이 없으며 대신 클라이언트에 오류가 발생합니다. 메소드 콜백은 첫 번째 인수로 리턴 된 오류와 함께 즉시 실행됩니다. 아래 오류 섹션에서 오류 처리에 대해 자세히 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="08a6a394474dbaf7a6999d26e3c837991da10f65" translate="yes" xml:space="preserve">
          <source>In the project navigator, choose your device from the Scheme toolbar menu:</source>
          <target state="translated">프로젝트 탐색기의 구성표 도구 모음 메뉴에서 장치를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="fff13c41f7cc356bf8785f787e833dcf881ee7a6" translate="yes" xml:space="preserve">
          <source>In this article, we&amp;rsquo;ll look closely at how collections work in various places in the framework, and how to get the most out of them.</source>
          <target state="translated">이 기사에서는 프레임 워크의 다양한 위치에서 컬렉션이 작동하는 방식과 컬렉션을 최대한 활용하는 방법에 대해 자세히 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="cd5c057a73f061460bb50cfe06d78bddf617379c" translate="yes" xml:space="preserve">
          <source>In this article, we&amp;rsquo;ll refer to the elements in your user interface as &amp;ldquo;components&amp;rdquo;. Although in some systems, you may refer to them as &amp;ldquo;templates&amp;rdquo;, it can be a good idea to think of them as something more like a component, which has an API and internal logic, rather than a template, which is just a bit of HTML.</source>
          <target state="translated">이 기사에서는 사용자 인터페이스의 요소를 &quot;구성 요소&quot;라고합니다. 일부 시스템에서는 이들을 &quot;템플릿&quot;이라고 지칭 할 수 있지만, 템플릿이 아닌 API 및 내부 논리를 갖는 구성 요소와 비슷한 것으로 생각하는 것이 좋습니다. HTML</target>
        </trans-unit>
        <trans-unit id="16a951a354967b9d301d65d18b65670a937d2ddd" translate="yes" xml:space="preserve">
          <source>In this article, we&amp;rsquo;ll use the popular &lt;a href=&quot;https://mochajs.org&quot;&gt;Mocha&lt;/a&gt; test runner alongside the &lt;a href=&quot;http://chaijs.com&quot;&gt;Chai&lt;/a&gt; assertion library to test our application. In order to write and run tests in Mocha, we need to add an appropriate test driver package.</source>
          <target state="translated">이 기사에서는 인기있는 &lt;a href=&quot;https://mochajs.org&quot;&gt;Mocha&lt;/a&gt; 테스트 러너를 &lt;a href=&quot;http://chaijs.com&quot;&gt;Chai&lt;/a&gt; 어설 션 라이브러리 와 함께 사용하여 애플리케이션을 테스트합니다. Mocha에서 테스트를 작성하고 실행하려면 적절한 테스트 드라이버 패키지를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f2c4aaa02e0b2ab31096746b667315ca3412515" translate="yes" xml:space="preserve">
          <source>In this case, as the list is valid according to the schema, the &lt;code&gt;validate()&lt;/code&gt; line will run without problems. If however, we wrote:</source>
          <target state="translated">이 경우 스키마에 따라 목록이 유효하므로 &lt;code&gt;validate()&lt;/code&gt; 행이 문제없이 실행됩니다. 그러나 우리는 다음과 같이 썼습니다.</target>
        </trans-unit>
        <trans-unit id="393960455a77603119555fd413f34cc2ee704b29" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;TodoItem&lt;/code&gt; component calls a &lt;a href=&quot;methods&quot;&gt;Meteor Method&lt;/a&gt;&lt;code&gt;setCheckedStatus&lt;/code&gt; when the user clicks, but this is a unit test so there&amp;rsquo;s no server running. So we stub it out using &lt;a href=&quot;http://sinonjs.org&quot;&gt;Sinon&lt;/a&gt;. After we simulate the click, we verify that the stub was called with the correct arguments. Finally, we clean up the stub and restore the original method behavior.</source>
          <target state="translated">이 경우 &lt;code&gt;TodoItem&lt;/code&gt; 구성 요소 는 사용자가 클릭 할 때 &lt;a href=&quot;methods&quot;&gt;Meteor 메서드 &lt;/a&gt; &lt;code&gt;setCheckedStatus&lt;/code&gt; 를 호출 하지만 이것은 단위 테스트이므로 실행중인 서버가 없습니다. 그래서 우리는 &lt;a href=&quot;http://sinonjs.org&quot;&gt;Sinon&lt;/a&gt; 을 사용하여 그것을 스텁 아웃 합니다. 클릭을 시뮬레이션 한 후 스텁이 올바른 인수로 호출되었는지 확인합니다. 마지막으로 스텁을 정리하고 원래 메소드 동작을 복원합니다.</target>
        </trans-unit>
        <trans-unit id="c130ef79a970932453defcdf9be810ff472f64f6" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;subComponent&lt;/code&gt; component can expect a data context of the form:</source>
          <target state="translated">이 경우 &lt;code&gt;subComponent&lt;/code&gt; 구성 요소 구성 요소는 다음 형식의 데이터 컨텍스트를 예상 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dbfc0ef10c1c7ae3ee6d563b8dee191c69c394f" translate="yes" xml:space="preserve">
          <source>In this case, the HTML template for &lt;code&gt;Lists_show_page&lt;/code&gt; will look very simple, with most of the logic in the JavaScript code:</source>
          <target state="translated">이 경우 &lt;code&gt;Lists_show_page&lt;/code&gt; 의 HTML 템플릿 은 JavaScript 코드의 대부분의 논리와 함께 매우 단순하게 보입니다.</target>
        </trans-unit>
        <trans-unit id="2f4075780b58b955e5015e6a2def734aa0c35b98" translate="yes" xml:space="preserve">
          <source>In this case, we want to use the &lt;code&gt;App_body&lt;/code&gt; layout template for all of the accounts-related pages. This template has a content region called &lt;code&gt;main&lt;/code&gt;. Now, let&amp;rsquo;s configure some routes:</source>
          <target state="translated">이 경우 모든 계정 관련 페이지에 &lt;code&gt;App_body&lt;/code&gt; 레이아웃 템플릿 을 사용하려고 합니다. 이 템플리트에는 &lt;code&gt;main&lt;/code&gt; 이라는 컨텐츠 영역이 있습니다. 이제 몇 가지 경로를 구성 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="d7bc90b15f112041a070fc1212f24c086eb6b5b1" translate="yes" xml:space="preserve">
          <source>In this code snippet we can see two important techniques for subscribing in Blaze templates:</source>
          <target state="translated">이 코드 스 니펫에서 Blaze 템플릿을 구독하기위한 두 가지 중요한 기술을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ae66971710dbb7005d0af5a6a72e160ea8c0491" translate="yes" xml:space="preserve">
          <source>In this example, the callback not only renders the &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; element into the element with &lt;code&gt;id=&quot;app&quot;&lt;/code&gt;, but also appends any &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; tag(s) generated during rendering to the &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; of the response document.</source>
          <target state="translated">이 예에서 콜백은 &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; 요소를 &lt;code&gt;id=&quot;app&quot;&lt;/code&gt; 가 있는 요소로 렌더링 할 뿐만 아니라 렌더링 중에 생성 된 &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 태그를 응답 문서 의 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="716caa47ae19a40f3022ec4e7676410324fb3962" translate="yes" xml:space="preserve">
          <source>In this example, the result of the &lt;code&gt;getSummary&lt;/code&gt; helper call will be passed to the &lt;code&gt;capitalize&lt;/code&gt; helper.</source>
          <target state="translated">이 예제에서 &lt;code&gt;getSummary&lt;/code&gt; 헬퍼 호출 결과 는 &lt;code&gt;capitalize&lt;/code&gt; 헬퍼 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="1a4426a50935ec09bf4a10ddc5e8ba5698c3c42b" translate="yes" xml:space="preserve">
          <source>In this example, we re-add the same files in the development mode to avoid unnecessary work and then we minify the files in production mode.</source>
          <target state="translated">이 예에서는 불필요한 작업을 피하기 위해 개발 모드에서 동일한 파일을 다시 추가 한 후 프로덕션 모드에서 파일을 축소합니다.</target>
        </trans-unit>
        <trans-unit id="50bb6fed7d0d7addafa71c7a00eb5d4ba619fc11" translate="yes" xml:space="preserve">
          <source>In this example, we register a linter that runs on all &lt;code&gt;js&lt;/code&gt; files and also reads a file named &lt;code&gt;.linterrc&lt;/code&gt; to get a configuration.</source>
          <target state="translated">이 예제에서는 모든 &lt;code&gt;js&lt;/code&gt; 파일 에서 실행되는 linter를 등록 하고 구성을 얻기 위해 &lt;code&gt;.linterrc&lt;/code&gt; 라는 파일을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="859031e359200cd0a3abc91fa2cc21ac074c5a50" translate="yes" xml:space="preserve">
          <source>In this example, we write a complicated query to make sure that we only ever find a list if we are allowed to see it, then, once per list we find (which can be one or zero times depending on access), we publish the todos for that list. Publish Composite takes care of stopping and starting the dependent cursors if the list stops matching the original query or otherwise.</source>
          <target state="translated">이 예에서는 복잡한 쿼리를 작성하여 목록을 볼 수있는 경우에만 목록을 찾은 다음 목록마다 한 번 (액세스에 따라 1 ~ 0 회) 찾은 경우 그 목록에 대한 할 일. Publish Composite는 목록이 원래 쿼리와 일치하지 않는 경우 종속 커서를 중지하고 시작합니다.</target>
        </trans-unit>
        <trans-unit id="f4f9fc4939653780350ebd47e5cbc74147faad2c" translate="yes" xml:space="preserve">
          <source>In this guide article, we will go over some important points for building packages, but we won&amp;rsquo;t explain every part of the &lt;code&gt;package.js&lt;/code&gt; API. To learn about all of the options, &lt;a href=&quot;http://docs.meteor.com/#/full/packagejs&quot;&gt;read about the &lt;code&gt;package.js&lt;/code&gt; API in the Meteor docs.&lt;/a&gt;</source>
          <target state="translated">이 가이드 기사에서는 패키지를 빌드 할 때 중요한 점을 살펴 보지만 &lt;code&gt;package.js&lt;/code&gt; API 의 모든 부분을 설명하지는 않습니다 . 모든 옵션에 대해 배우려면 &lt;a href=&quot;http://docs.meteor.com/#/full/packagejs&quot;&gt;Meteor 문서에서 &lt;/a&gt; &lt;code&gt;package.js&lt;/code&gt; API에 대해 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="de40712f96ccbc5878832b3c65a8203bb4e6f428" translate="yes" xml:space="preserve">
          <source>In this guide, we&amp;rsquo;re going to take a strong position that using &lt;a href=&quot;http://docs.meteor.com/#/full/allow&quot;&gt;allow&lt;/a&gt; or &lt;a href=&quot;http://docs.meteor.com/#/full/deny&quot;&gt;deny&lt;/a&gt; to run MongoDB queries directly from the client is not a good idea. The main reason is that it is hard to follow the principles outlined above. It&amp;rsquo;s extremely difficult to validate the complete space of possible MongoDB operators, which could potentially grow over time with new versions of MongoDB.</source>
          <target state="translated">이 가이드에서는 클라이언트에서 직접 MongoDB 쿼리를 실행할 &lt;a href=&quot;http://docs.meteor.com/#/full/allow&quot;&gt;수 있도록 허용&lt;/a&gt; 또는 &lt;a href=&quot;http://docs.meteor.com/#/full/deny&quot;&gt;거부&lt;/a&gt; 를 사용 하지 않는 것이 좋습니다. 주된 이유는 위에서 설명한 원칙을 따르기가 어렵 기 때문입니다. 새로운 버전의 MongoDB로 시간이 지남에 따라 잠재적으로 증가 할 수있는 가능한 MongoDB 운영자의 전체 공간을 검증하는 것은 매우 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="44715bbc86bdfa46a48d2ab0256fd8059347cf7f" translate="yes" xml:space="preserve">
          <source>In this publication, which loads private lists, we need to use &lt;code&gt;this.userId&lt;/code&gt; to get only the todo lists that belong to a specific user.</source>
          <target state="translated">개인 목록을로드하는이 발행물에서는 &lt;code&gt;this.userId&lt;/code&gt; 를 사용 하여 특정 사용자에게 속한 할 일 목록 만 가져와야 합니다.</target>
        </trans-unit>
        <trans-unit id="ef6286f6d925f3eea0fa1f1d8e182daba9569288" translate="yes" xml:space="preserve">
          <source>In this release, Minimongo has some limitations:</source>
          <target state="translated">이 릴리스에서 Minimongo에는 몇 가지 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a84400a9a251f4df3aa4777ac358a066646f489e" translate="yes" xml:space="preserve">
          <source>In this section, we&amp;rsquo;ll consider a publication/subscription technique for the second, infinite-scroll style pagination. The page-by-page technique is a little tricker to handle in Meteor, due to it being difficult to calculate the offset on the client. If you need to do so, you can follow many of the same techniques that we use here and use the &lt;a href=&quot;https://atmospherejs.com/percolate/find-from-publication&quot;&gt;&lt;code&gt;percolate:find-from-publication&lt;/code&gt;&lt;/a&gt; package to keep track of which records have come from your publication.</source>
          <target state="translated">이 섹션에서는 두 번째 무한 스크롤 스타일 페이지 매김에 대한 발행 / 구독 기술을 고려합니다. 페이지 별 기술은 클라이언트에서 오프셋을 계산하기 어렵 기 때문에 Meteor에서 처리하기가 약간 까다 롭습니다. 필요한 경우 여기에서 사용하는 것과 동일한 기술을 많이 사용하고 &lt;a href=&quot;https://atmospherejs.com/percolate/find-from-publication&quot;&gt; &lt;code&gt;percolate:find-from-publication&lt;/code&gt; &lt;/a&gt; 패키지를 사용하여 발행물에서 어떤 레코드를 가져 왔는지 추적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bee80ec74e593fd4cc58d070cd4ef3b4a1765ff" translate="yes" xml:space="preserve">
          <source>In this test, we used &lt;a href=&quot;#test-data&quot;&gt;Factory package&amp;rsquo;s&lt;/a&gt;&lt;code&gt;.create()&lt;/code&gt; API, which inserts data into the real collection. However, as we&amp;rsquo;ve proxied all of the &lt;code&gt;Todos&lt;/code&gt; and &lt;code&gt;Lists&lt;/code&gt; collection methods onto a local collection (this is what &lt;code&gt;hwillson:stub-collections&lt;/code&gt; is doing), we won&amp;rsquo;t run into any problems with trying to perform inserts from the client.</source>
          <target state="translated">이 테스트에서는 &lt;a href=&quot;#test-data&quot;&gt;팩토리 패키지의 &lt;/a&gt; &lt;code&gt;.create()&lt;/code&gt; API를 사용하여 실제 컬렉션에 데이터를 삽입했습니다. 그러나 모든 &lt;code&gt;Todos&lt;/code&gt; and &lt;code&gt;Lists&lt;/code&gt; 콜렉션 메소드를 로컬 콜렉션으로 프록시 처리 &lt;code&gt;hwillson:stub-collections&lt;/code&gt; (이것은 hwillson : stub-collections 가 수행하는 작업 임) 클라이언트에서 삽입을 수행하는 데 아무런 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="48d58d96176f8e5734d6d01f807e05aa18aa8373" translate="yes" xml:space="preserve">
          <source>In web application deployment it&amp;rsquo;s common to refer to three runtime environments:</source>
          <target state="translated">웹 애플리케이션 배포에서 세 가지 런타임 환경을 참조하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="b2138449e1b676a59c755a472878c39768fd1e0f" translate="yes" xml:space="preserve">
          <source>In your app&amp;rsquo;s JavaScript code, these settings can be accessed from the variable &lt;code&gt;Meteor.settings&lt;/code&gt;.</source>
          <target state="translated">앱의 JavaScript 코드에서 이러한 설정은 변수 &lt;code&gt;Meteor.settings&lt;/code&gt; 에서 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e633340302cf126d7622043227bbf7e61f4c15a2" translate="yes" xml:space="preserve">
          <source>In your build plugin source, register a Compiler Plugin: similar to other types of build plugins, provide the details, extensions and filenames and a factory function that returns an instance of the compiler. Ex.:</source>
          <target state="translated">빌드 플러그인 소스에서 다른 유형의 빌드 플러그인과 유사하게 컴파일러 플러그인을 등록하십시오. 세부 사항, 확장명 및 파일 이름 및 컴파일러 인스턴스를 리턴하는 팩토리 함수를 제공하십시오. 전의.:</target>
        </trans-unit>
        <trans-unit id="3f85d67d9b9661cee48fb29e5de7a1a5f4cec087" translate="yes" xml:space="preserve">
          <source>In your build plugin source, register a Minifier Plugin. Similar to Linter and Compiler plugin, specify the interested extensions (&lt;code&gt;css&lt;/code&gt; or &lt;code&gt;js&lt;/code&gt;). The factory function returns an instance of the minifier class.</source>
          <target state="translated">빌드 플러그인 소스에서 축소 기 플러그인을 등록하십시오. Linter 및 Compiler 플러그인과 유사하게 관심있는 확장자 ( &lt;code&gt;css&lt;/code&gt; 또는 &lt;code&gt;js&lt;/code&gt; )를 지정하십시오 . 팩토리 함수는 축소 기 클래스의 인스턴스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aa16ac7e9796342ae5c54d13d0d2ac8301db0349" translate="yes" xml:space="preserve">
          <source>In your build plugin sources, register a Linter Plugin: provide details such as a name, list of extensions and filenames the plugin will handle and a factory function that returns an instance of a linter class. Example:</source>
          <target state="translated">빌드 플러그인 소스에서 Linter 플러그인을 등록하십시오. 플러그인이 처리 할 이름, 확장자 및 파일 이름 목록 및 linter 클래스의 인스턴스를 리턴하는 팩토리 함수와 같은 세부 사항을 제공하십시오. 예:</target>
        </trans-unit>
        <trans-unit id="a58097e9eae38a2a6d42be2241a68bd3fda8cbc6" translate="yes" xml:space="preserve">
          <source>Include &lt;a href=&quot;build-tool#compiles-with-build-plugins&quot;&gt;build plugins&lt;/a&gt; for Meteor&amp;rsquo;s build system</source>
          <target state="translated">Meteor의 빌드 시스템을위한 &lt;a href=&quot;build-tool#compiles-with-build-plugins&quot;&gt;빌드 플러그인&lt;/a&gt; 포함</target>
        </trans-unit>
        <trans-unit id="353db2b05370e2628bf6610a4bfbf0cb7679c248" translate="yes" xml:space="preserve">
          <source>Include Cordova plugins in your Meteor package by using &lt;a href=&quot;http://docs.meteor.com/#/full/Cordova-depends&quot;&gt;Cordova.depends&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://docs.meteor.com/#/full/Cordova-depends&quot;&gt;Cordova.depends&lt;/a&gt; 를 사용하여 Meteor 패키지에 Cordova 플러그인을 포함하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf0025e3001017ccd9edf1af6b727b14f2db3276" translate="yes" xml:space="preserve">
          <source>Include pre-built binary code for different server architectures, such as Linux or Windows</source>
          <target state="translated">Linux 또는 Windows와 같은 다른 서버 아키텍처를 위해 사전 빌드 된 이진 코드 포함</target>
        </trans-unit>
        <trans-unit id="773d8fcfde1c62ca678d7fe259059da2812244f7" translate="yes" xml:space="preserve">
          <source>Including in your app</source>
          <target state="translated">앱에 포함</target>
        </trans-unit>
        <trans-unit id="f8afa7df51d1a363c6b3729a5966a161fa6e983c" translate="yes" xml:space="preserve">
          <source>Inclusion Tags</source>
          <target state="translated">포함 태그</target>
        </trans-unit>
        <trans-unit id="06f64eb2109c825d33e153e4148dc6e13c959ff4" translate="yes" xml:space="preserve">
          <source>Inclusion and Block Arguments</source>
          <target state="translated">포함 및 블록 인수</target>
        </trans-unit>
        <trans-unit id="45280beec399004106474e535f46d0fdcb55635d" translate="yes" xml:space="preserve">
          <source>Inclusion tags (&lt;code&gt;{{&amp;gt; foo}}&lt;/code&gt;) and block tags (&lt;code&gt;{{#foo}}&lt;/code&gt;) take a single data argument, or no argument. Any other form of arguments will be interpreted as an &lt;em&gt;object specification&lt;/em&gt; or a &lt;em&gt;nested helper&lt;/em&gt;:</source>
          <target state="translated">포함 태그 ( &lt;code&gt;{{&amp;gt; foo}}&lt;/code&gt; ) 및 블록 태그 ( &lt;code&gt;{{#foo}}&lt;/code&gt; )는 단일 데이터 인수를 사용하거나 인수가 없습니다. 다른 형식의 인수는 &lt;em&gt;객체 사양&lt;/em&gt; 또는 &lt;em&gt;중첩 도우미&lt;/em&gt; 로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="5e78a5cfb1db22808629144956804fa8cb9908bc" translate="yes" xml:space="preserve">
          <source>Indents objects and arrays for easy readability. When &lt;code&gt;true&lt;/code&gt;, indents by 2 spaces; when an integer, indents by that number of spaces; and when a string, uses the string as the indentation pattern.</source>
          <target state="translated">쉽게 읽을 수 있도록 객체와 배열을 들여 씁니다. 경우 &lt;code&gt;true&lt;/code&gt; 2 공백으로 만입; 정수일 때, 그 수의 공백만큼 들여 쓰기; 문자열 일 때 문자열을 들여 쓰기 패턴으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="37850cb533f69eb02117841a8a5cd87c07aa7199" translate="yes" xml:space="preserve">
          <source>Indexing the current data context. The identifier &lt;code&gt;foo&lt;/code&gt; refers to the &lt;code&gt;foo&lt;/code&gt; property of the current data context object.</source>
          <target state="translated">현재 데이터 컨텍스트를 인덱싱합니다. 식별자 &lt;code&gt;foo&lt;/code&gt; 는 현재 데이터 컨텍스트 객체 의 &lt;code&gt;foo&lt;/code&gt; 속성을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="368c35c76c4ede42543dc12e7427a7453d231d69" translate="yes" xml:space="preserve">
          <source>Indicating when a write is in progress</source>
          <target state="translated">쓰기 진행 중 표시</target>
        </trans-unit>
        <trans-unit id="7b691a16e23a6ebb1c523c417f5ba56e56eebeb3" translate="yes" xml:space="preserve">
          <source>Initially loading, no data available yet.</source>
          <target state="translated">초기로드 중, 아직 사용 가능한 데이터가 없습니다.</target>
        </trans-unit>
        <trans-unit id="614d878a15a0519edf83c79deb485104433bc31a" translate="yes" xml:space="preserve">
          <source>Insert a document in the collection. Returns its unique _id.</source>
          <target state="translated">컬렉션에 문서를 삽입하십시오. 고유 한 _id를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ecd13ed03842fb804f904a59d3e0dfdb0ae55e5c" translate="yes" xml:space="preserve">
          <source>Inside UIWebViews (when your app is loaded inside a mobile app)</source>
          <target state="translated">UIWebViews 내부 (앱이 모바일 앱에로드 된 경우)</target>
        </trans-unit>
        <trans-unit id="2780ace99845806a4b862b4386e7617dfccfeb59" translate="yes" xml:space="preserve">
          <source>Inside a Method execution on the server, calling another Method runs that Method as if it were called by the same client. That means the Method runs as usual, and the context - &lt;code&gt;userId&lt;/code&gt;, &lt;code&gt;connection&lt;/code&gt;, etc - are taken from the original Method call.</source>
          <target state="translated">서버의 메소드 실행 내에서 다른 메소드를 호출하면 동일한 클라이언트에서 호출 한 것처럼 해당 메소드가 실행됩니다. 즉, 메소드가 정상적으로 실행되고 컨텍스트 ( &lt;code&gt;userId&lt;/code&gt; , &lt;code&gt;connection&lt;/code&gt; 등)가 원래 메소드 호출에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="360e39954fe7e4bf71ce5be7e6215592b14b0bff" translate="yes" xml:space="preserve">
          <source>Inside a build plugin source file specified in &lt;a href=&quot;#Package-registerBuildPlugin&quot;&gt;Package.registerBuildPlugin&lt;/a&gt;, add a handler to compile files with a certain file extension.</source>
          <target state="translated">&lt;a href=&quot;#Package-registerBuildPlugin&quot;&gt;Package.registerBuildPlugin에&lt;/a&gt; 지정된 빌드 플러그인 소스 파일 내에 특정 파일 확장자를 가진 파일을 컴파일하는 핸들러를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="3de6c7e92d33543486b90a5646cd0b72fe77b438" translate="yes" xml:space="preserve">
          <source>Inside a client-side Method simulation, calling another Method doesn&amp;rsquo;t fire off an extra request to the server - the assumption is that the server-side implementation of the Method will do it. However, it does run the &lt;em&gt;simulation&lt;/em&gt; of the called Method, so that the simulation on the client closely matches what will happen on the server.</source>
          <target state="translated">클라이언트 측 메소드 시뮬레이션 내에서 다른 메소드를 호출해도 서버에 대한 추가 요청이 발생하지 않습니다. 서버 측 메소드의 메소드가이를 수행한다고 가정합니다. 그러나, 실행하지 &lt;em&gt;시뮬레이션&lt;/em&gt; 클라이언트의 시뮬레이션이 밀접 서버에 무슨 일이 일어날 일치 그래서, 호출 방법을.</target>
        </trans-unit>
        <trans-unit id="e489fd661adfe67fc2a7cd7c6480dd5e88240d6d" translate="yes" xml:space="preserve">
          <source>Inside a helper, returns the data context of the DOM node where the helper was used.</source>
          <target state="translated">헬퍼 내부에서 헬퍼가 사용 된 DOM 노드의 데이터 컨텍스트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e29b20f0936432bd21e9feaaf8c1f6dd5c68634f" translate="yes" xml:space="preserve">
          <source>Inside an &lt;code&gt;onCreated&lt;/code&gt;, &lt;code&gt;onRendered&lt;/code&gt;, or &lt;code&gt;onDestroyed&lt;/code&gt; callback, returns the data context of the template.</source>
          <target state="translated">내부 &lt;code&gt;onCreated&lt;/code&gt; , &lt;code&gt;onRendered&lt;/code&gt; , 또는 &lt;code&gt;onDestroyed&lt;/code&gt; 콜백, 템플릿의 데이터 컨텍스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="21fd895aa8247746bb75b6a2ecd0de8e4ea210e4" translate="yes" xml:space="preserve">
          <source>Inside an event handler, returns the data context of the template on which this event handler was defined.</source>
          <target state="translated">이벤트 핸들러 내에서이 이벤트 핸들러가 정의 된 템플리트의 데이터 컨텍스트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b5e254ddf3e1050b0794e3b4eeed21271b77c186" translate="yes" xml:space="preserve">
          <source>Inside the template&amp;rsquo;s HTML, you can use the built-in helper &lt;code&gt;Template.subscriptionsReady&lt;/code&gt;, which is an easy pattern for showing loading indicators in your templates when they depend on data loaded from subscriptions.</source>
          <target state="translated">템플릿의 HTML 내에서 기본 제공 도우미 &lt;code&gt;Template.subscriptionsReady&lt;/code&gt; 를 사용할 수 있습니다.이 템플릿 은 구독에서로드 된 데이터에 의존 할 때 템플릿에로드 표시기를 쉽게 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09eb13722fb4946d0ab8516ad78e61b59fd40bd1" translate="yes" xml:space="preserve">
          <source>Install a Java Development Kit (JDK)</source>
          <target state="translated">JDK (Java Development Kit) 설치</target>
        </trans-unit>
        <trans-unit id="f3ced16a0c5123202e7015520c619a9d22b468bd" translate="yes" xml:space="preserve">
          <source>Install the Android SDK and download the required tools, platforms, and other components (which is done most easily by installing Android Studio)</source>
          <target state="translated">Android SDK를 설치하고 필요한 도구, 플랫폼 및 기타 구성 요소 (Android Studio를 설치하여 가장 쉽게 수행)를 다운로드하십시오.</target>
        </trans-unit>
        <trans-unit id="76993e75d0ce1819da322a7383015f3dd8e33bc4" translate="yes" xml:space="preserve">
          <source>Installing Android Studio</source>
          <target state="translated">Android Studio 설치</target>
        </trans-unit>
        <trans-unit id="89adbddd338a7b46a342e12a62babc5b6d68de4f" translate="yes" xml:space="preserve">
          <source>Installing Atmosphere Packages</source>
          <target state="translated">분위기 패키지 설치</target>
        </trans-unit>
        <trans-unit id="a0d9b605309f5935493e4e274c41f140208085c9" translate="yes" xml:space="preserve">
          <source>Installing Xcode from the App Store</source>
          <target state="translated">App Store에서 Xcode 설치</target>
        </trans-unit>
        <trans-unit id="ab9d4f985be9ceba61fa41d995398a2b136cd5ce" translate="yes" xml:space="preserve">
          <source>Installing a plugin from Git</source>
          <target state="translated">Git에서 플러그인 설치</target>
        </trans-unit>
        <trans-unit id="24d517fefcb756696a14e1601f2278491fb55d21" translate="yes" xml:space="preserve">
          <source>Installing a plugin from the local file system</source>
          <target state="translated">로컬 파일 시스템에서 플러그인 설치</target>
        </trans-unit>
        <trans-unit id="f5abeac6a79ab675fd8731f7c59fc53892ec0b01" translate="yes" xml:space="preserve">
          <source>Installing and running ESLint</source>
          <target state="translated">ESLint 설치 및 실행</target>
        </trans-unit>
        <trans-unit id="79604a617bbef8796e8b97c478f8ebdb918d742a" translate="yes" xml:space="preserve">
          <source>Installing and using React</source>
          <target state="translated">React 설치 및 사용</target>
        </trans-unit>
        <trans-unit id="880fa89fcd4a2214a9ac4718234c4b73084e8494" translate="yes" xml:space="preserve">
          <source>Installing npm Packages</source>
          <target state="translated">npm 패키지 설치</target>
        </trans-unit>
        <trans-unit id="bad94515f6d136d2603333a9eb3cf4a918bebd46" translate="yes" xml:space="preserve">
          <source>Installing plugins</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a847bfe09db07365fa859da9e751d802e54df632" translate="yes" xml:space="preserve">
          <source>Installing prerequisites</source>
          <target state="translated">전제 조건 설치</target>
        </trans-unit>
        <trans-unit id="4f3f1c71dba2241f80e748f3df6dbef5ea21fc96" translate="yes" xml:space="preserve">
          <source>Installing the Java Development Kit (JDK)</source>
          <target state="translated">JDK (Java Development Kit) 설치</target>
        </trans-unit>
        <trans-unit id="de59f6df2a2743da46b4d8a4d279d928aa0f5fb2" translate="yes" xml:space="preserve">
          <source>Instance configurability &amp;ndash; Independently configure your CPU, memory, storage and disk I/O speed.</source>
          <target state="translated">인스턴스 구성 기능 &amp;ndash; CPU, 메모리, 스토리지 및 디스크 I / O 속도를 독립적으로 구성합니다.</target>
        </trans-unit>
        <trans-unit id="0edae422dcff14cfcccca293a2d05091989c10a7" translate="yes" xml:space="preserve">
          <source>Instance size &amp;amp; options</source>
          <target state="translated">인스턴스 크기 및 옵션</target>
        </trans-unit>
        <trans-unit id="2959b3a45b76563d6c8510666e6780446d2712e1" translate="yes" xml:space="preserve">
          <source>Instances of your type must implement &lt;a href=&quot;#ejson_type_typeName&quot;&gt;&lt;code&gt;typeName&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ejson_type_toJSONValue&quot;&gt;&lt;code&gt;toJSONValue&lt;/code&gt;&lt;/a&gt; methods, and may implement &lt;a href=&quot;#ejson_type_clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ejson_type_equals&quot;&gt;&lt;code&gt;equals&lt;/code&gt;&lt;/a&gt; methods if the default implementations are not sufficient.</source>
          <target state="translated">유형의 인스턴스는 &lt;a href=&quot;#ejson_type_typeName&quot;&gt; &lt;code&gt;typeName&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ejson_type_toJSONValue&quot;&gt; &lt;code&gt;toJSONValue&lt;/code&gt; &lt;/a&gt; 메소드를 구현 해야하며 기본 구현이 충분하지 않은 경우 &lt;a href=&quot;#ejson_type_clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ejson_type_equals&quot;&gt; &lt;code&gt;equals&lt;/code&gt; &lt;/a&gt; 메소드를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="baf7b528aae503023c9477df1c8b138d269a300a" translate="yes" xml:space="preserve">
          <source>Instead of modifying documents in the &lt;a href=&quot;#meteor_users&quot;&gt;&lt;code&gt;Meteor.users&lt;/code&gt;&lt;/a&gt; collection directly, use these convenience functions which correctly check for case insensitive duplicates before updates.</source>
          <target state="translated">&lt;a href=&quot;#meteor_users&quot;&gt; &lt;code&gt;Meteor.users&lt;/code&gt; &lt;/a&gt; 컬렉션의 문서를 직접 수정하는 대신 업데이트 전에 대소 문자를 구분하지 않는 복제본을 올바르게 확인하는이 편리한 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c66d0782f8ea038667dc5fb044a411f571689778" translate="yes" xml:space="preserve">
          <source>Instead of simply naming a template, an inclusion tag can also specify a path that evalutes to a template object, or to a function that returns a template object.</source>
          <target state="translated">포함 이름은 단순히 템플릿의 이름을 지정하는 대신 템플릿 객체 또는 템플릿 객체를 반환하는 함수로 확장되는 경로를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a86f3bd3744743ae8ef66c864c95422fcc0d0c74" translate="yes" xml:space="preserve">
          <source>Instead of taking a single opaque &lt;code&gt;options&lt;/code&gt; parameter, a function can use an object destructuring pattern to name the expected options:</source>
          <target state="translated">함수는 단일 불투명 &lt;code&gt;options&lt;/code&gt; 매개 변수를 사용하는 대신 객체 파괴 패턴을 사용하여 예상 옵션의 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40186957b76c782b5781708846b5c30d99db8ba9" translate="yes" xml:space="preserve">
          <source>Instead of using callbacks to notify you on changes, this is a &lt;a href=&quot;#reactivity&quot;&gt;reactive&lt;/a&gt; data source. You can use it in a &lt;a href=&quot;#livehtmltemplates&quot;&gt;template&lt;/a&gt; or &lt;a href=&quot;#tracker_autorun&quot;&gt;computation&lt;/a&gt; to get realtime updates.</source>
          <target state="translated">콜백을 사용하여 변경 사항을 알리는 대신 &lt;a href=&quot;#reactivity&quot;&gt;반응 형&lt;/a&gt; 데이터 소스입니다. &lt;a href=&quot;#livehtmltemplates&quot;&gt;템플릿&lt;/a&gt; 또는 &lt;a href=&quot;#tracker_autorun&quot;&gt;계산&lt;/a&gt; 에서이를 사용하여 실시간 업데이트를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc2c1243a177f557f90c231e9d87723dfe2e42e7" translate="yes" xml:space="preserve">
          <source>Instead, Blaze gives you a way to scope a lookup to within the current template instance. Typically you use this either from a &lt;code&gt;onRendered()&lt;/code&gt; callback to setup jQuery plugins (called via &lt;code&gt;Template.instance().$()&lt;/code&gt; or &lt;code&gt;this.$()&lt;/code&gt;), or from event handlers to call DOM functions directly (called via &lt;code&gt;Template.instance().$()&lt;/code&gt; or using the event handler&amp;rsquo;s second argument like &lt;code&gt;instance.$()&lt;/code&gt;). For instance, when the user clicks the add todo button, we want to focus the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">대신 Blaze를 사용하면 현재 템플릿 인스턴스 내에서 검색 범위를 지정할 수 있습니다. 일반적으로 &lt;code&gt;onRendered()&lt;/code&gt; 콜백에서 jQuery 플러그인 설정 ( &lt;code&gt;Template.instance().$()&lt;/code&gt; 또는 &lt;code&gt;this.$()&lt;/code&gt; )을 통해 호출되거나 이벤트 핸들러에서 DOM 함수를 직접 호출 ( &lt;code&gt;Template.instance().$()&lt;/code&gt; 를 통해 호출)하여이를 사용합니다. (). $ () 또는 같은 이벤트 핸들러의 두 번째 인자 사용하여 &lt;code&gt;instance.$()&lt;/code&gt; ). 예를 들어, 사용자가 할 일 추가 버튼을 클릭하면 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 요소 에 초점을 맞 춥니 다 .</target>
        </trans-unit>
        <trans-unit id="4bb1cdd9084f3d40a8c11e0a82440bd526448b7f" translate="yes" xml:space="preserve">
          <source>Instead, you need to ask your users to install the correct npm packages in the application itself. This will ensure that only one copy of React is shipped to the client and there are no version conflicts.</source>
          <target state="translated">대신 사용자에게 응용 프로그램 자체에 올바른 npm 패키지를 설치하도록 요청해야합니다. 이렇게하면 하나의 React 사본 만 클라이언트에 제공되고 버전 충돌이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a9a80ab23d0834af074a4d02b121694639575834" translate="yes" xml:space="preserve">
          <source>Integrating with your editor</source>
          <target state="translated">에디터와 통합</target>
        </trans-unit>
        <trans-unit id="f48cb5c70273adca2f1ae065a022640d580c33cc" translate="yes" xml:space="preserve">
          <source>Integration testing</source>
          <target state="translated">통합 테스트</target>
        </trans-unit>
        <trans-unit id="7d8fc660207b21d44ff4e303a49e49321e5438fb" translate="yes" xml:space="preserve">
          <source>Internally, renderable content includes objects representing HTML tags as well, but these objects are not yet part of the officially-supported, public API.</source>
          <target state="translated">내부적으로 렌더링 가능한 콘텐츠에는 HTML 태그를 나타내는 객체도 포함되지만 이러한 객체는 아직 공식적으로 지원되는 공개 API의 일부가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="3b755f7b857b999860755840e5f0964f6b120c4d" translate="yes" xml:space="preserve">
          <source>Internationalization</source>
          <target state="translated">Internationalization</target>
        </trans-unit>
        <trans-unit id="72a68d6949dcd099bf168f39deca7ad5c3548f6f" translate="yes" xml:space="preserve">
          <source>Internationalization (i18n) is the process of generalizing the UI of your app in such a way that it&amp;rsquo;s easy to render all text in a different language. Meteor&amp;rsquo;s package ecosystem includes internationalization options tailored to your frontend framework of choice.</source>
          <target state="translated">국제화 (i18n)는 모든 텍스트를 다른 언어로 쉽게 렌더링 할 수있는 방식으로 앱의 UI를 일반화하는 프로세스입니다. Meteor의 패키지 에코 시스템에는 선택한 프론트 엔드 프레임 워크에 맞는 국제화 옵션이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c501914e1d7d2737a768eaeaa3672c88d11b8c6e" translate="yes" xml:space="preserve">
          <source>Introduced in Meteor 1.2</source>
          <target state="translated">Meteor 1.2에 도입</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="3e3e50205a99a4864015c0d0c5651a5b41fdac00" translate="yes" xml:space="preserve">
          <source>Introduction to using &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 및 &lt;code&gt;export&lt;/code&gt; 사용 소개</target>
        </trans-unit>
        <trans-unit id="b3ddef764921d4e6c2d0ab06805638effe0f5673" translate="yes" xml:space="preserve">
          <source>Invalidate all dependent computations immediately and remove them as dependents.</source>
          <target state="translated">모든 종속 계산을 즉시 무효화하고 종속 항목으로 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="d640bfda5eaaaf39be21eab38996850e0410e44c" translate="yes" xml:space="preserve">
          <source>Invalidates this computation so that it will be rerun.</source>
          <target state="translated">이 계산을 무효화하여 다시 실행되도록합니다.</target>
        </trans-unit>
        <trans-unit id="4b6ad188d9c21e416b0517060e0d039d07ca3737" translate="yes" xml:space="preserve">
          <source>Invalidating a computation immediately calls all &lt;code&gt;onInvalidate&lt;/code&gt; callbacks registered on it. Invalidating a computation that is currently invalidated or is stopped has no effect. A computation can invalidate itself, but if it continues to do so indefinitely, the result will be an infinite loop.</source>
          <target state="translated">계산을 무효화하면 등록 된 모든 &lt;code&gt;onInvalidate&lt;/code&gt; 콜백이 즉시 호출 됩니다. 현재 무효화되었거나 중지 된 계산을 무효화하는 것은 효과가 없습니다. 계산 자체가 무효화 될 수 있지만 무한정 계속 계속되면 결과는 무한 루프가됩니다.</target>
        </trans-unit>
        <trans-unit id="b7cc5b489d1e5691b3fc19d7e01449256c899855" translate="yes" xml:space="preserve">
          <source>Invalidating a computation marks it to be rerun at &lt;a href=&quot;#tracker_flush&quot;&gt;flush time&lt;/a&gt;, at which point the computation becomes valid again. It is rare to invalidate a computation manually, because reactive data sources invalidate their calling computations when they change. Reactive data sources in turn perform this invalidation using one or more &lt;a href=&quot;#tracker_dependency&quot;&gt;&lt;code&gt;Tracker.Dependency&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">계산을 무효화하면 &lt;a href=&quot;#tracker_flush&quot;&gt;플러시 시간에&lt;/a&gt; 다시 실행되어 계산이 다시 유효 해집니다. 반응 형 데이터 소스는 변경시 호출 계산을 무효화하므로 계산을 수동으로 무효화하는 경우는 거의 없습니다. 반응성 데이터 소스는 하나 이상의 &lt;a href=&quot;#tracker_dependency&quot;&gt; &lt;code&gt;Tracker.Dependency&lt;/code&gt; &lt;/a&gt; 객체를 사용하여이 무효화를 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="90203a1d90242066ba2a13f0f274b4953a7863af" translate="yes" xml:space="preserve">
          <source>Invalidating a computation sets its &lt;code&gt;invalidated&lt;/code&gt; property to true and immediately calls all of the computation&amp;rsquo;s &lt;code&gt;onInvalidate&lt;/code&gt; callbacks. When a flush occurs, if the computation has been invalidated and not stopped, then the computation is rerun by setting the &lt;code&gt;invalidated&lt;/code&gt; property to &lt;code&gt;false&lt;/code&gt; and calling the original function that was passed to &lt;code&gt;Tracker.autorun&lt;/code&gt;. A flush will occur when the current code finishes running, or sooner if &lt;code&gt;Tracker.flush&lt;/code&gt; is called.</source>
          <target state="translated">계산을 무효화하면 &lt;code&gt;invalidated&lt;/code&gt; 속성이 true로 설정되고 즉시 모든 계산의 &lt;code&gt;onInvalidate&lt;/code&gt; 콜백을 호출합니다. 플러시가 발생하면 계산이 무효화되고 중지되지 않은 경우 &lt;code&gt;invalidated&lt;/code&gt; 속성을 &lt;code&gt;false&lt;/code&gt; 로 설정하고 &lt;code&gt;Tracker.autorun&lt;/code&gt; 에 전달 된 원래 함수를 호출하여 계산이 다시 실행됩니다 . 현재 코드가 실행을 마치거나 &lt;code&gt;Tracker.flush&lt;/code&gt; 가 호출 되면 더 빨리 플러시가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="d7340978cf7ba632bc8aad9258c7944b2c1177cf" translate="yes" xml:space="preserve">
          <source>Invoke a method passing an array of arguments.</source>
          <target state="translated">인수 배열을 전달하는 메소드를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="8bdf537dabe796e64289ecdd6b26db4875334981" translate="yes" xml:space="preserve">
          <source>Invokes a method passing any number of arguments.</source>
          <target state="translated">여러 개의 인수를 전달하는 메소드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="1e3e33285679d56b5e1b8f73b6740557af585234" translate="yes" xml:space="preserve">
          <source>Ionic 1 uses Angular 1, but there are also &lt;a href=&quot;http://meteoric.github.io//&quot;&gt;Blaze&lt;/a&gt; and &lt;a href=&quot;http://reactionic.github.io/&quot;&gt;React&lt;/a&gt; ports.</source>
          <target state="translated">Ionic 1은 Angular 1을 사용하지만 &lt;a href=&quot;http://meteoric.github.io//&quot;&gt;Blaze&lt;/a&gt; 및 &lt;a href=&quot;http://reactionic.github.io/&quot;&gt;React&lt;/a&gt; 포트도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b9fc016d45806a5ed8dbb9aace5d48f53fd64ab" translate="yes" xml:space="preserve">
          <source>Iron Router</source>
          <target state="translated">아이언 라우터</target>
        </trans-unit>
        <trans-unit id="3639210fe06e16f98e387ab3259d91f9432684a2" translate="yes" xml:space="preserve">
          <source>Isobuild Feature Packages</source>
          <target state="translated">아이소 빌드 기능 패키지</target>
        </trans-unit>
        <trans-unit id="1ebcccc762c5c527531f6a2b87a1f54ab5a43a92" translate="yes" xml:space="preserve">
          <source>Isolation techniques</source>
          <target state="translated">격리 기술</target>
        </trans-unit>
        <trans-unit id="418880ae80ca0c74fdd6999714deab185c18084d" translate="yes" xml:space="preserve">
          <source>It &lt;strong&gt;does&lt;/strong&gt; eagerly load our application code as Meteor normally would.</source>
          <target state="translated">그것은 &lt;strong&gt;않습니다&lt;/strong&gt; 열심히 유성으로 평소 우리의 응용 프로그램 코드를로드합니다.</target>
        </trans-unit>
        <trans-unit id="43be4eab938bad7d8ccafe048fe0e4e2c9341169" translate="yes" xml:space="preserve">
          <source>It also needs to be responsive to reactive changes in the state of those actions (for instance if a todo changes due to the action of another user). All this data loading complexity is a typical use-case for a container-presentational component split, and the &lt;code&gt;withTracker&lt;/code&gt; function makes it simple to do this.</source>
          <target state="translated">또한 해당 작업 상태의 반응 적 변경 (예 : 다른 사용자의 작업으로 인해 할 일이 변경되는 경우)에 응답해야합니다. 이 모든 데이터 로딩의 복잡성은 컨테이너 표현 컴포넌트 분할에 대한 일반적인 사용 사례이며 &lt;code&gt;withTracker&lt;/code&gt; 함수를 사용하면 간단하게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ca247c8d664df3369fff68c26a965ce58f48964" translate="yes" xml:space="preserve">
          <source>It can be a challenge to write a hook in a completely general way (that covers every possible selector and modifier), and it may not be necessary for your application (because perhaps you only ever call that mutator in one way).</source>
          <target state="translated">모든 가능한 선택자와 수정자를 포함하는 완전히 일반적인 방식으로 후크를 작성하는 것은 어려울 수 있으며 응용 프로그램에 필요하지 않을 수도 있습니다 (아마도 한 가지 방식으로 해당 뮤 테이터를 호출하기 때문에).</target>
        </trans-unit>
        <trans-unit id="c691f3bcdcddc67a71812db1aa6dae9fdb95c5e2" translate="yes" xml:space="preserve">
          <source>It could make sense for packages to exist to completely abstract some common denormalization techniques and actually attempt to deal with all possible modifications. If you write such a package, please let us know!</source>
          <target state="translated">일반적인 일부 비정규 화 기술을 완전히 추상화하고 실제로 가능한 모든 수정 사항을 처리하려는 패키지가 존재하는 것이 합리적 일 수 있습니다. 이러한 패키지를 작성하는 경우 알려주십시오!</target>
        </trans-unit>
        <trans-unit id="8559f30e5502fc9ffdb0ba8086b3c8d12fe9f83f" translate="yes" xml:space="preserve">
          <source>It does something totally different!</source>
          <target state="translated">완전히 다른 일을합니다!</target>
        </trans-unit>
        <trans-unit id="e14be95c4c53eb1a3e234af0232df0160edffd59" translate="yes" xml:space="preserve">
          <source>It is best to place the subscription as close as possible to the place where the data from the subscription is needed. This reduces &amp;ldquo;action at a distance&amp;rdquo; and makes it easier to understand the flow of data through your application. If the subscription and fetch are separated, then it&amp;rsquo;s not always clear how and why changes to the subscriptions (such as changing arguments), will affect the contents of the cursor.</source>
          <target state="translated">구독의 데이터가 필요한 위치에 최대한 가깝게 구독을 배치하는 것이 가장 좋습니다. 이렇게하면 &quot;원거리에서의 작업&quot;이 줄어들고 응용 프로그램을 통한 데이터 흐름을보다 쉽게 ​​이해할 수 있습니다. 서브 스크립 션과 페치가 분리 된 경우, 서브 스크립 션 변경 (예 : 인수 변경)이 커서의 내용에 영향을 미치는 방식과 이유가 항상 명확하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="e3ec9112fb49cd4dd06386b01bbb94e96a35d400" translate="yes" xml:space="preserve">
          <source>It is illegal to call &lt;code&gt;flush&lt;/code&gt; from inside a &lt;code&gt;flush&lt;/code&gt; or from a running computation.</source>
          <target state="translated">&lt;code&gt;flush&lt;/code&gt; 내부 또는 실행중인 계산에서 &lt;code&gt;flush&lt;/code&gt; 를 호출하는 것은 불법 입니다.</target>
        </trans-unit>
        <trans-unit id="41d866892ab96b900a2aced50924d3d177f0a796" translate="yes" xml:space="preserve">
          <source>It is key to understand that a subscription will not instantly provide its data. There will be a latency between subscribing to the data on the client and it arriving from the publication on the server. You should also be aware that this delay may be a lot longer for your users in production than for you locally in development!</source>
          <target state="translated">구독이 즉시 데이터를 제공하지는 않는다는 것을 이해하는 것이 중요합니다. 클라이언트의 데이터를 구독하는 것과 서버의 게시에서 도착하는 것 사이에 대기 시간이 있습니다. 또한이 지연 시간은 로컬 사용자가 개발중인 사용자보다 프로덕션 사용자에게 훨씬 더 길 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="406170b3a37d468efe5138052cfd282f8c336370" translate="yes" xml:space="preserve">
          <source>It is necessary to configure the TypeScript compiler with a &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; 파일 을 사용하여 TypeScript 컴파일러를 구성해야 합니다.</target>
        </trans-unit>
        <trans-unit id="19becc9f11e0a4a33bea34a6de176e135124b5d7" translate="yes" xml:space="preserve">
          <source>It is recommended that you use the &lt;code&gt;ecmascript&lt;/code&gt; package and first call &lt;code&gt;import { Email } from 'meteor/email';&lt;/code&gt; before calling &lt;code&gt;Email.send&lt;/code&gt; in your app. It is also recommended that package developers now use ES2015 &lt;code&gt;export&lt;/code&gt; from their main JavaScript file instead of &lt;code&gt;api.export&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ecmascript&lt;/code&gt; 패키지 를 사용 하고 먼저 &lt;code&gt;import { Email } from 'meteor/email';&lt;/code&gt; 호출 하는 것이 좋습니다 . 앱에서 &lt;code&gt;Email.send&lt;/code&gt; 를 호출하기 전에 . 또한 패키지 개발자는 이제 ES2015 사용하는 것이 좋습니다 &lt;code&gt;export&lt;/code&gt; 그들의 주요 자바 스크립트 파일 대신에서 &lt;code&gt;api.export&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="2723c139b2339ba19c9b59eb0a2da2ca4d231c85" translate="yes" xml:space="preserve">
          <source>It is recommended to use npm for 3rd party JavaScript libraries and use &lt;code&gt;import&lt;/code&gt; to control when files are loaded.</source>
          <target state="translated">써드 파티 JavaScript 라이브러리에는 npm을 사용하고 파일을로드하는시기를 제어 하기 위해 &lt;code&gt;import&lt;/code&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="ff0d872e7e7860c7ab001fa5c473fa29c4549dd4" translate="yes" xml:space="preserve">
          <source>It is required that your &lt;code&gt;my-package&lt;/code&gt; name take the form of &lt;code&gt;username:my-package&lt;/code&gt;, where &lt;code&gt;username&lt;/code&gt; is your Meteor Developer username, if you plan to publish your package to Atmosphere.</source>
          <target state="translated">패키지를 Atmosphere에 게시하려는 경우 &lt;code&gt;my-package&lt;/code&gt; 이름은 &lt;code&gt;username:my-package&lt;/code&gt; 형식 이어야합니다 . 여기서 &lt;code&gt;username&lt;/code&gt; 은 Meteor Developer 사용자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="228b5380515ea3017a650ff8153e79a83573f7ea" translate="yes" xml:space="preserve">
          <source>It loads test files matching &lt;code&gt;*.app-test[s].*&lt;/code&gt; and &lt;code&gt;*.app-spec[s].*&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*.app-test[s].*&lt;/code&gt; 및 &lt;code&gt;*.app-spec[s].*&lt;/code&gt; 와 일치하는 테스트 파일을로드합니다 .</target>
        </trans-unit>
        <trans-unit id="7eacf899f23c9c18c70e4aa55a3fd639c2e7e790" translate="yes" xml:space="preserve">
          <source>It makes sense for a &amp;ldquo;page&amp;rdquo; smart component like &lt;code&gt;Lists_show_page&lt;/code&gt; to:</source>
          <target state="translated">&lt;code&gt;Lists_show_page&lt;/code&gt; 와 같은&amp;ldquo;page&amp;rdquo;스마트 구성 요소는 다음과 같은 의미 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="228f249e2b6bc89042ba046dcaaa7196c0c69255" translate="yes" xml:space="preserve">
          <source>It makes sense to place a publication alongside the feature that it&amp;rsquo;s targeted for. For instance, sometimes publications provide very specific data that&amp;rsquo;s only really useful for the view for which they were developed. In that case, placing the publication in the same module or directory as the view code makes perfect sense.</source>
          <target state="translated">대상 기능과 함께 발행물을 배치하는 것이 좋습니다. 예를 들어 간행물은 간혹 개발 된보기에만 유용한 매우 구체적인 데이터를 제공하기도합니다. 이 경우 뷰 코드와 동일한 모듈 또는 디렉토리에 게시를 배치하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="28b51bca68c25f23b252f2cc4cac7ffce8718f4c" translate="yes" xml:space="preserve">
          <source>It turns out that having a field writeable by default without making that super obvious might not be the best idea. There are many stories of new Meteor developers storing fields such as &lt;code&gt;isAdmin&lt;/code&gt; on &lt;code&gt;profile&lt;/code&gt;&amp;hellip; and then a malicious user can easily set that to true whenever they want, making themselves an admin. Even if you aren&amp;rsquo;t concerned about this, it isn&amp;rsquo;t a good idea to let malicious users store arbitrary amounts of data in your database.</source>
          <target state="translated">그렇게 명백히하지 않으면 서 기본적으로 필드를 쓸 수있는 것이 최선의 아이디어가 아닐 수도 있습니다. 이 같은 필드를 저장하는 새로운 유성 개발자의 많은 이야기입니다 &lt;code&gt;isAdmin&lt;/code&gt; 에 대한 &lt;code&gt;profile&lt;/code&gt; ... 그리고 악의적 인 사용자가 쉽게 자신의 관리자 만들기, 참으로 그들이 원하는 때마다 있음을 설정할 수 있습니다. 걱정하지 않아도 악의적 인 사용자가 데이터베이스에 임의의 양의 데이터를 저장하도록하는 것은 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b1b14da312e733d43bb22d74e4430fc32c5a996b" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a bad idea to look up things directly in the DOM with jQuery&amp;rsquo;s global &lt;code&gt;$()&lt;/code&gt;. It&amp;rsquo;s easy to select some element on the page that has nothing to do with the current component. Also, it limits your options on rendering &lt;em&gt;outside&lt;/em&gt; of the main document (see testing section below).</source>
          <target state="translated">jQuery의 전역 &lt;code&gt;$()&lt;/code&gt; 을 사용하여 DOM에서 직접 조회하는 것은 좋지 않습니다 . 현재 구성 요소와 관련이없는 페이지에서 일부 요소를 쉽게 선택할 수 있습니다. 또한 기본 문서 &lt;em&gt;외부&lt;/em&gt; 렌더링에 대한 옵션이 제한됩니다 (아래 테스트 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="aa3a82b09261cbd84023d6ce1bf90f8a0e1dc729" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a good habit to name your container exactly like the component that it wraps, with the word &amp;ldquo;Container&amp;rdquo; tacked onto the end. This way, when you&amp;rsquo;re attempting to track down issues in your code, it makes it much easier to locate the appropriate files/classes.</source>
          <target state="translated">&amp;ldquo;컨테이너&amp;rdquo;라는 단어가 끝에 붙은 상태에서 컨테이너를 포장하는 구성 요소와 정확히 같은 이름을 지정하는 것이 좋습니다. 이렇게하면 코드에서 문제를 추적하려고 할 때 적절한 파일 / 클래스를 훨씬 쉽게 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a34e996e030eb7d4e5f116557adfcde21b2c2159" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a good idea to have a release process that you follow in releasing your application. Typically that process looks something like:</source>
          <target state="translated">응용 프로그램을 릴리스 할 때 따르는 릴리스 프로세스를 갖는 것이 좋습니다. 일반적으로 해당 프로세스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b39219a3bced108920f2a9ade043f419510201a9" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also worth knowing a little about what happens on the server when the new subscription is started and the old one is stopped.</source>
          <target state="translated">새 구독이 시작되고 이전 구독이 중지 될 때 서버에서 어떤 일이 발생하는지에 대해 조금 아는 것도 좋습니다.</target>
        </trans-unit>
        <trans-unit id="853429164832b5efbf06259b1c8aa99ca8a1b190" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s always a good idea to use SSL for Meteor applications (see the &lt;a href=&quot;security#ssl&quot;&gt;Security Article&lt;/a&gt; to find out why). Once you have a registered domain name, you&amp;rsquo;ll need to generate an SSL certificate with a certificate authority for your domain. If you deploy to Galaxy, you can &lt;a href=&quot;http://galaxy-guide.meteor.com/encryption.html#lets-encrypt&quot;&gt;generate a free SSL certificate with a single click&lt;/a&gt; (courtesy of Let&amp;rsquo;s Encrypt!).</source>
          <target state="translated">Meteor 응용 프로그램에 SSL을 사용하는 것이 좋습니다. &lt;a href=&quot;security#ssl&quot;&gt;보안&lt;/a&gt; 이유를 확인하려면 보안 기사 를 참조하십시오 . 등록 된 도메인 이름이 있으면 도메인의 인증 기관이있는 SSL 인증서를 생성해야합니다. Galaxy에 배포하는 경우 &lt;a href=&quot;http://galaxy-guide.meteor.com/encryption.html#lets-encrypt&quot;&gt;한 번의 클릭으로 무료 SSL 인증서를 생성&lt;/a&gt; 할 수 있습니다 (Let 's Encrypt! 제공).</target>
        </trans-unit>
        <trans-unit id="46ee8c46487a50a48cf4fdbcdf0cd2f3f1941e78" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s best to handle the redirection from HTTP to HTTPS on the platform which handles the SSL certificates and termination.</source>
          <target state="translated">SSL 인증서 및 종료를 처리하는 플랫폼에서 HTTP에서 HTTPS 로의 리디렉션을 처리하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="757e0c44aed4ca9b9283e0ce28692a5a28229798" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s best to keep all logic around what to render in the component hierarchy (i.e. the tree of rendered components). So this authorization should happen inside a component. Suppose we wanted to add this to the &lt;code&gt;Lists_show_page&lt;/code&gt; we were looking at above. We could do something like:</source>
          <target state="translated">컴포넌트 계층에서 렌더링 할 대상 (예 : 렌더링 된 컴포넌트 트리)에 대한 모든 논리를 유지하는 것이 가장 좋습니다. 따라서이 권한은 구성 요소 내에서 발생해야합니다. 위에서 &lt;code&gt;Lists_show_page&lt;/code&gt; 에 이것을 추가한다고 가정하자 . 우리는 다음과 같은 것을 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="9929693c4e7c4992e137e9f0ef1b60685fc83a8d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s common to need related sets of data from multiple collections on a given page. For instance, in the Todos app, when we render a todo list, we want the list itself, as well as the set of todos that belong to that list.</source>
          <target state="translated">주어진 페이지에서 여러 콜렉션의 관련 데이터 세트가 필요합니다. 예를 들어, Todos 앱에서 할 일 목록을 렌더링 할 때 목록 자체와 해당 목록에 속한 할 일 모음이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="439a1abd1582cb1ad7ca286054b9f291afda74d7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s common to want to know which pages of your app are most commonly visited, and where users are coming from. Here&amp;rsquo;s a simple setup that will get you URL tracking using Google Analytics. We&amp;rsquo;ll be using the &lt;a href=&quot;https://atmospherejs.com/okgrow/analytics&quot;&gt;&lt;code&gt;okgrow:analytics&lt;/code&gt;&lt;/a&gt; package.</source>
          <target state="translated">가장 일반적으로 방문하는 앱 페이지와 사용자가 어디에서 왔는지 알고 싶어합니다. 다음은 Google 웹 로그 분석을 사용하여 URL을 추적 할 수있는 간단한 설정입니다. 우리는 &lt;a href=&quot;https://atmospherejs.com/okgrow/analytics&quot;&gt; &lt;code&gt;okgrow:analytics&lt;/code&gt; &lt;/a&gt; 패키지를 사용할 것입니다.</target>
        </trans-unit>
        <trans-unit id="b5e91b26503a62d31558b0277c06d2eeec65d490" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s common to want to know which pages of your app are most commonly visited, and where users are coming from. You can read about how to set up Flow Router based analytics in the &lt;a href=&quot;deployment#analytics&quot;&gt;Deployment Guide&lt;/a&gt;.</source>
          <target state="translated">가장 일반적으로 방문하는 앱 페이지와 사용자가 어디에서 왔는지 알고 싶어합니다. &lt;a href=&quot;deployment#analytics&quot;&gt;배치 안내서&lt;/a&gt; 에서 플로우 라우터 기반 분석을 설정하는 방법에 대해 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4b9a1580833de91f46d31dc47e017a82efa79bcb" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s common to want to reuse code between two otherwise unrelated components. There are two main ways to do this in Blaze.</source>
          <target state="translated">관련이없는 두 구성 요소간에 코드를 재사용하는 것이 일반적입니다. Blaze에는 두 가지 주요 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7549849e7e8b4fad84055090bb60bd718ad56e51" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s hard to learn everything about a programming language at once. For example, programmers new to JavaScript often struggle with the &lt;code&gt;var&lt;/code&gt; keyword and function scope. Using a community-recommended coding style with automatic linting can warn you about these pitfalls proactively. This means you can jump right into coding without learning about all of the edge cases of JavaScript ahead of time.</source>
          <target state="translated">프로그래밍 언어에 관한 모든 것을 한 번에 배우기는 어렵습니다. 예를 들어, JavaScript를 처음 사용하는 프로그래머는 종종 &lt;code&gt;var&lt;/code&gt; 키워드 및 함수 범위로 어려움을 겪습니다 . 자동 보푸라기와 함께 커뮤니티 권장 코딩 스타일을 사용하면 이러한 함정에 대해 사전에 경고 할 수 있습니다. 즉, JavaScript의 모든 주요 사례에 대해 미리 배우지 않고도 코딩으로 바로 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad12f5f933ed39efe48255089a0905fd3f5fa06c" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important that we set a &lt;code&gt;sort&lt;/code&gt; parameter on our query (to ensure a repeatable order of list items as more pages are requested), and that we set an absolute maximum on the number of items a user can request (at least in the case where lists can grow without bound).</source>
          <target state="translated">그것은 우리가 설정하는 것이 중요 &lt;code&gt;sort&lt;/code&gt; (더 많은 페이지가 요청 될 때 목록 항목의 반복 순서를 위해) 우리의 쿼리에 매개 변수를, 우리는 사용자가 적어도 경우 어디에서 (요청할 수있는 항목의 수의 절대 최대 값을 설정하는 것이 목록은 제한없이 커질 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="9d5d9268705b388fc3454c63be5fc49b857234b9" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to understand what happens during a deployment, especially if your deployment involves changes in data format (and potentially data migrations, see the &lt;a href=&quot;collections#migrations&quot;&gt;Collections Article&lt;/a&gt;).</source>
          <target state="translated">배포 중에 데이터 형식이 변경되는 경우 (및 데이터 마이그레이션은 &lt;a href=&quot;collections#migrations&quot;&gt;컬렉션 기사&lt;/a&gt; 참조) 배포 중 발생하는 상황을 이해하는 것이 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="a7236f836ac3cb5aca066ad99178d22ac4de61f9" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s instructive to think about what arguments such a component would need to differentiate between those five states. Let&amp;rsquo;s consider a generic pattern that would work in all cases where we provide the following information:</source>
          <target state="translated">이러한 구성 요소가 이러한 5 가지 상태를 구별하기 위해 어떤 인수가 필요할지 생각하는 것이 유익합니다. 다음 정보를 제공하는 모든 경우에 적용되는 일반적인 패턴을 고려해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="a5593705f86d9ef004e814149e09f0cf48b60281" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s more flexible, in case you need to give the component more arguments in the future.</source>
          <target state="translated">나중에 구성 요소에 더 많은 인수를 제공 해야하는 경우보다 유연합니다.</target>
        </trans-unit>
        <trans-unit id="1a180aafb82184c9d5d9574133aceeb3d8cf6697" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s much easier to write clean code if you can assume your inputs are correct, so it&amp;rsquo;s valuable to validate all Method arguments before running any actual business logic. You don&amp;rsquo;t want someone to pass a data type you aren&amp;rsquo;t expecting and cause unexpected behavior.</source>
          <target state="translated">입력 내용이 정확하다고 가정하면 깨끗한 코드를 작성하는 것이 훨씬 쉬우므로 실제 비즈니스 로직을 실행하기 전에 모든 Method 인수를 확인하는 것이 중요합니다. 예상치 못한 데이터 유형을 전달하여 예상치 못한 동작을 유발하는 사람을 원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c7193ac2a78039510cc45d8aa3e842e7e9d42406" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not strictly required, but often a good idea to set up a Content Delivery Network (CDN) for your site. A CDN is a network of servers that hosts the static assets of your site (such as JavaScript, CSS, and images) in numerous locations around the world and uses the server closest to your user to provide those files in order to speed up their delivery. For example, if the actual web server for your application is on the east coast of the USA and your user is in Australia, a CDN could host a copy of the JavaScript of the site within Australia or even in the city the user is in. This has huge benefits for the initial loading time of your site.</source>
          <target state="translated">반드시 필요한 것은 아니지만 사이트에 CDN (Content Delivery Network)을 설정하는 것이 좋습니다. CDN은 전 세계 여러 위치에서 사이트의 정적 자산 (예 : JavaScript, CSS 및 이미지)을 호스팅하고 사용자에게 가장 가까운 서버를 사용하여 전송 속도를 높이기위한 서버 네트워크입니다. . 예를 들어, 응용 프로그램의 실제 웹 서버가 미국 동부 해안에 있고 사용자가 호주에있는 경우 CDN은 호주 내 또는 사용자가있는 도시에서 사이트의 JavaScript를 호스트 할 수 있습니다. 이는 사이트의 초기 로딩 시간에 큰 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bbcba703bc3869b31fb79c00b4eb53bdff5b804" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s pretty straightforward to validate a document with a schema. We can write:</source>
          <target state="translated">스키마를 사용하여 문서의 유효성을 검사하는 것은 매우 간단합니다. 우리는 쓸 수있다:</target>
        </trans-unit>
        <trans-unit id="5c6f4ec1705b73d6848b8412f9837628ca01938a" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s tempting to just provide the object you&amp;rsquo;re interested in as the entire data context of the template (like &lt;code&gt;{{&amp;gt; Todos_item todo}}&lt;/code&gt;). It&amp;rsquo;s better to explicitly give it a name (&lt;code&gt;{{&amp;gt; Todos_item todo=todo}}&lt;/code&gt;). There are two primary reasons for this:</source>
          <target state="translated">&lt;code&gt;{{&amp;gt; Todos_item todo}}&lt;/code&gt; 와 같이 템플릿의 전체 데이터 컨텍스트로 관심있는 객체를 제공하는 것이 좋습니다 . 명시 적으로 이름을 지정하는 것이 좋습니다 ( &lt;code&gt;{{&amp;gt; Todos_item todo=todo}}&lt;/code&gt; ). 이에 대한 두 가지 주요 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3d8ad4bb37bba95e0227bdbc9a24681722711b0" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s the &lt;code&gt;listShow&lt;/code&gt; component (a reusuable component) that actually handles the job of rendering the content of the page. As the page component is passing the arguments into the reusuable component, it is able to be quite mechanical and the concerns of talking to the router and rendering the page have been separated.</source>
          <target state="translated">그것은이다 &lt;code&gt;listShow&lt;/code&gt; 의 실제 페이지의 콘텐츠를 렌더링 작업을 처리하는 성분 (A reusuable 구성 요소). 페이지 구성 요소가 인수를 재사용 가능한 구성 요소로 전달할 때 상당히 기계적인 작업이 가능하며 라우터와 대화하고 페이지를 렌더링하는 문제가 분리되었습니다.</target>
        </trans-unit>
        <trans-unit id="baecec7075ff567c964ed1f0138b45c793659be8" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s typical to make some kind of change to the database when a user takes an action. However it&amp;rsquo;s important to make sure you don&amp;rsquo;t do this too rapidly. For instance, if you wish to save the user&amp;rsquo;s text as they type in a text box, you should take steps to make sure that you don&amp;rsquo;t send method calls to your server more than every few hundred milliseconds.</source>
          <target state="translated">사용자가 조치를 취할 때 데이터베이스를 변경하는 것이 일반적입니다. 그러나이 작업을 너무 빨리 수행하지 않는 것이 중요합니다. 예를 들어, 텍스트 상자에 입력 할 때 사용자의 텍스트를 저장하려면 몇 밀리 초마다 서버에 메소드 호출을 보내지 않도록 조치를 취해야합니다.</target>
        </trans-unit>
        <trans-unit id="a107e80ca79a3b1e3ba5dbe3b2aa4861066fe1c5" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s useful to access information about the current route in your code. Here are some reactive functions you can call:</source>
          <target state="translated">코드에서 현재 경로에 대한 정보에 액세스하는 것이 좋습니다. 다음은 호출 할 수있는 일부 반응성 함수입니다.</target>
        </trans-unit>
        <trans-unit id="950d097078f93573b3aac8f0c2fb5cc95a3c62c9" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s useful to consider the various places in the system that user-readable strings exist and make sure that you are properly using the i18n system to generate those strings in each case. We&amp;rsquo;ll go over the implementation for each case in the sections about &lt;a href=&quot;#tap-i18n-js&quot;&gt;&lt;code&gt;tap:i18n&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#universe-i18n&quot;&gt;&lt;code&gt;universe:i18n&lt;/code&gt;&lt;/a&gt; below.</source>
          <target state="translated">사용자가 읽을 수있는 문자열이 존재하는 시스템의 다양한 위치를 고려하고 각 경우에 해당 문자열을 생성하기 위해 i18n 시스템을 올바르게 사용하고 있는지 확인하는 것이 유용합니다. 아래의 &lt;a href=&quot;#tap-i18n-js&quot;&gt; &lt;code&gt;tap:i18n&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#universe-i18n&quot;&gt; &lt;code&gt;universe:i18n&lt;/code&gt; &lt;/a&gt; 섹션에서 각 사례에 대한 구현을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="dab08d31b2bc70dc0d06c49797b25313cc569d5d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s usually best to keep your view layer as thin as possible and contain a component to whatever specific task it specifically needs to do. If there&amp;rsquo;s heavy lifting involved (such as complicated data loading logic), it often makes sense to abstract it out into a library that simply deals with the logic alone and doesn&amp;rsquo;t deal with the Blaze system at all.</source>
          <target state="translated">일반적으로 뷰 레이어를 가능한 한 얇게 유지하고 특정 작업에 필요한 구성 요소를 포함하는 것이 가장 좋습니다. 복잡한 데이터 로딩 로직과 같이 많은 작업이 필요한 경우 로직 만 다루고 Blaze 시스템을 전혀 다루지 않는 라이브러리로 추상화하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c0cf738a4ddb81522363b6a983c9dc6988d9564c" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s very rare to need to access &lt;code&gt;currentComputation&lt;/code&gt; directly. The current computation is used implicitly by &lt;a href=&quot;#tracker_active&quot;&gt;&lt;code&gt;Tracker.active&lt;/code&gt;&lt;/a&gt; (which tests whether there is one), &lt;a href=&quot;#dependency_depend&quot;&gt;&lt;code&gt;dependency.depend()&lt;/code&gt;&lt;/a&gt; (which registers that it depends on a dependency), and &lt;a href=&quot;#tracker_oninvalidate&quot;&gt;&lt;code&gt;Tracker.onInvalidate&lt;/code&gt;&lt;/a&gt; (which registers a callback with it).</source>
          <target state="translated">&lt;code&gt;currentComputation&lt;/code&gt; 에 직접 액세스해야하는 경우는 매우 드 rare니다 . 현재 계산은 &lt;a href=&quot;#tracker_active&quot;&gt; &lt;code&gt;Tracker.active&lt;/code&gt; &lt;/a&gt; (존재하는지 여부를 테스트), &lt;a href=&quot;#dependency_depend&quot;&gt; &lt;code&gt;dependency.depend()&lt;/code&gt; &lt;/a&gt; ( 종속성에 의존 하는 것으로 등록) 및 &lt;a href=&quot;#tracker_oninvalidate&quot;&gt; &lt;code&gt;Tracker.onInvalidate&lt;/code&gt; &lt;/a&gt; (콜백을 등록하는 )에 의해 암시 적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1bd96d98292cd9c6dc1782fc486bb4ffca45486a" translate="yes" xml:space="preserve">
          <source>It's okay to load this dependency after your package. (In general, dependencies specified by &lt;code&gt;api.use&lt;/code&gt; are loaded before your package.) You can use this option to break circular dependencies.</source>
          <target state="translated">패키지 다음에이 종속성을로드해도됩니다. 일반적으로 &lt;code&gt;api.use&lt;/code&gt; 에 의해 지정된 종속성 은 패키지 전에로드됩니다.이 옵션을 사용하여 순환 종속성을 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bb69bc98399d871e90ce634e6fe04aa07ed967f" translate="yes" xml:space="preserve">
          <source>JSON-able object to stringify and use as the HTTP request body. Overwrites &lt;code&gt;content&lt;/code&gt;.</source>
          <target state="translated">HTTP 요청 본문으로 문자열 화하고 사용하기위한 JSON 가능 객체. &lt;code&gt;content&lt;/code&gt; 덮어 씁니다 .</target>
        </trans-unit>
        <trans-unit id="f665bc0cac8508d3d9a6462e5db25967183e5e9d" translate="yes" xml:space="preserve">
          <source>JSX for React</source>
          <target state="translated">반응을위한 JSX</target>
        </trans-unit>
        <trans-unit id="e64573adaf2a2b18646f5dd15016651f18b995b4" translate="yes" xml:space="preserve">
          <source>JavaScript style guide</source>
          <target state="translated">자바 스크립트 스타일 가이드</target>
        </trans-unit>
        <trans-unit id="20d54bee594c4d2003348a9a777e19cf6fca6bf8" translate="yes" xml:space="preserve">
          <source>JavaScript transpilation</source>
          <target state="translated">자바 스크립트 번역</target>
        </trans-unit>
        <trans-unit id="5a164c98944da0d19e07447709f42b273f9bd7a9" translate="yes" xml:space="preserve">
          <source>Just a sequence (Cursor, array, null, or undefined) not wrapped into an object. Inside the Each body, the current item will be set as the data context.</source>
          <target state="translated">객체에 래핑되지 않은 시퀀스 (커서, 배열, null 또는 정의되지 않음) 만 있습니다. 각 본문 내에서 현재 항목이 데이터 컨텍스트로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="4db78b711fb2571459e84542effce8b854ced53b" translate="yes" xml:space="preserve">
          <source>Just as an example, here&amp;rsquo;s a situation where not checking arguments can be disastrous:</source>
          <target state="translated">예를 들어, 인수를 확인하지 않는 것이 비참한 상황은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="61d739a8a4ec714809f6d3f135bcff9218e298ea" translate="yes" xml:space="preserve">
          <source>Just as you can use &lt;code&gt;Meteor.isServer&lt;/code&gt; and &lt;code&gt;Meteor.isClient&lt;/code&gt; to separate your client-side and server-side code, you can use &lt;code&gt;Meteor.isCordova&lt;/code&gt; to separate your Cordova-specific code from the rest of your code.</source>
          <target state="translated">클라이언트 측 코드와 서버 측 코드를 분리하기 위해 &lt;code&gt;Meteor.isServer&lt;/code&gt; 및 &lt;code&gt;Meteor.isClient&lt;/code&gt; 를 사용할 수있는 &lt;code&gt;Meteor.isCordova&lt;/code&gt; 를 사용 하여 Cordova 특정 코드를 나머지 코드와 분리 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="412ca4f30e9c7366b28b14f212cbaf625b699a90" translate="yes" xml:space="preserve">
          <source>Just follow one simple rule: don&amp;rsquo;t query the database by &lt;code&gt;username&lt;/code&gt; or &lt;code&gt;email&lt;/code&gt; directly. Instead, use the &lt;a href=&quot;http://docs.meteor.com/api/passwords.html#Accounts-findUserByUsername&quot;&gt;&lt;code&gt;Accounts.findUserByUsername&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://docs.meteor.com/api/passwords.html#Accounts-findUserByEmail&quot;&gt;&lt;code&gt;Accounts.findUserByEmail&lt;/code&gt;&lt;/a&gt; methods provided by Meteor. This will run a query for you that is case-insensitive, so you will always find the user you are looking for.</source>
          <target state="translated">하나의 간단한 규칙을 따르십시오 . &lt;code&gt;username&lt;/code&gt; 이나 &lt;code&gt;email&lt;/code&gt; 데이터베이스를 직접 쿼리하지 마십시오 . 대신 Meteor에서 제공 하는 &lt;a href=&quot;http://docs.meteor.com/api/passwords.html#Accounts-findUserByUsername&quot;&gt; &lt;code&gt;Accounts.findUserByUsername&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;http://docs.meteor.com/api/passwords.html#Accounts-findUserByEmail&quot;&gt; &lt;code&gt;Accounts.findUserByEmail&lt;/code&gt; &lt;/a&gt; 메소드를 사용하십시오 . 대 / 소문자를 구분하지 않는 쿼리가 실행되므로 원하는 사용자를 항상 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="590d767afb3541e6c72e772b44d8db1039fe26da" translate="yes" xml:space="preserve">
          <source>Just like REST endpoints, Meteor Methods can easily be called from anywhere - a malicious program, script in the browser console, etc. It is easy to fire many Method calls in a very short amount of time. This means it can be easy for an attacker to test lots of different inputs to find one that works. Meteor has built-in rate limiting for password login to stop password brute-forcing, but it&amp;rsquo;s up to you to define rate limits for your other Methods.</source>
          <target state="translated">REST 엔드 포인트와 마찬가지로 Meteor Methods는 악성 프로그램, 브라우저 콘솔의 스크립트 등 어디에서나 쉽게 호출 할 수 있습니다. 매우 짧은 시간에 많은 Method 호출을 시작하기 쉽습니다. 즉, 침입자가 작동하는 입력을 찾기 위해 다양한 입력을 쉽게 테스트 할 수 있습니다. Meteor에는 암호 무차별 강제 실행을 중지하기 위해 암호 로그인에 대한 속도 제한이 내장되어 있지만 다른 방법에 대한 속도 제한을 정의하는 것은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="01bb30534adc12830b04426f7ed298596be923e2" translate="yes" xml:space="preserve">
          <source>Just like packages can export JavaScript code, they can export reusable bits of CSS pre-processor code. You can also have a package that doesn&amp;rsquo;t actually include any CSS, but just exports different bits of reusable mixins and variables. To get more details see Meteor &lt;a href=&quot;build-tool#css&quot;&gt;build tool CSS pre-processors&lt;/a&gt;:</source>
          <target state="translated">패키지가 JavaScript 코드를 내보낼 수있는 것처럼 재사용 가능한 CSS 전 처리기 코드를 내보낼 수 있습니다. 실제로 CSS를 포함하지 않고 재사용 가능한 믹스 인과 변수의 다른 비트를 내보내는 패키지를 가질 수도 있습니다. 자세한 내용은 Meteor &lt;a href=&quot;build-tool#css&quot;&gt;빌드 도구 CSS 프리 프로세서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3167bce4da7048a6ae30006c9ab98cf229fd691" translate="yes" xml:space="preserve">
          <source>Just like we can use React components in Blaze templates, we can also use Blaze templates in React components. This is similarly useful for a gradual transition strategy; but more importantly, it allows us to continue to use the multitude of Atmosphere packages built for Blaze in our React projects, as well as core packages like &lt;code&gt;accounts-ui&lt;/code&gt;.</source>
          <target state="translated">Blaze 템플릿에서 React 구성 요소를 사용할 수있는 것처럼 React 구성 요소에서 Blaze 템플릿을 사용할 수도 있습니다. 점진적인 전환 전략에도 비슷합니다. 더 중요한 것은 React 프로젝트에서 Blaze 용으로 구축 된 다양한 Atmosphere 패키지와 &lt;code&gt;accounts-ui&lt;/code&gt; 같은 핵심 패키지를 계속 사용할 수 있다는 점 입니다.</target>
        </trans-unit>
        <trans-unit id="0189e11e377829809f4a9f3616dd729630c8c0a3" translate="yes" xml:space="preserve">
          <source>Keep any &lt;code&gt;id&lt;/code&gt; attributes, like &lt;code&gt;at-btn&lt;/code&gt;, since those are used for event handling.</source>
          <target state="translated">&lt;code&gt;at-btn&lt;/code&gt; 과 같은 &lt;code&gt;id&lt;/code&gt; 속성 은 이벤트 처리에 사용되므로 유지하십시오 .</target>
        </trans-unit>
        <trans-unit id="4fd2ca0f7a61432dccc3415c507dabc2c0d4e0c7" translate="yes" xml:space="preserve">
          <source>Lastly, the callback passed to &lt;code&gt;Meteor.call&lt;/code&gt; actually fires with the return value from step 4. It&amp;rsquo;s important that the callback waits until the client is up to date, so that your Method callback can assume that the client state reflects any changes done inside the Method.</source>
          <target state="translated">마지막으로, &lt;code&gt;Meteor.call&lt;/code&gt; 에 전달 된 콜백은 실제로 4 단계의 리턴 값으로 시작됩니다. 콜백은 클라이언트가 최신 상태가 될 때까지 대기해야합니다. 따라서 메소드 콜백은 클라이언트 상태가 클라이언트 상태에서 수행 된 변경 사항을 반영한다고 가정 할 수 있습니다. 방법.</target>
        </trans-unit>
        <trans-unit id="a446bae20cf72c1227b7a81479571a2bbf4f46f4" translate="yes" xml:space="preserve">
          <source>Launch VS Code and open the quick open menu by typing &lt;code&gt;Ctrl+P&lt;/code&gt;</source>
          <target state="translated">VS 코드를 시작하고 &lt;code&gt;Ctrl+P&lt;/code&gt; 를 입력하여 빠른 열기 메뉴를 엽니 다</target>
        </trans-unit>
        <trans-unit id="2a8f672e3a918a42df8c3ff614c94ed72a9efb02" translate="yes" xml:space="preserve">
          <source>Launch the app on your device and open remote debugger by choosing &lt;em&gt;Develop &amp;gt; &amp;lt;Your device&amp;gt; &amp;gt; &amp;lt;Your app&amp;gt;/localhost&lt;/em&gt;.</source>
          <target state="translated">장치에서 앱을 시작하고 &lt;em&gt;개발&amp;gt; &amp;lt;장치&amp;gt;&amp;gt; &amp;lt;앱&amp;gt; / localhost&lt;/em&gt; 를 선택하여 원격 디버거를 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="039a88b23905dcc483ef61e6ecbd1ab571d2f7d6" translate="yes" xml:space="preserve">
          <source>Lazy evaluation will very likely become the default behavior in a future version of Meteor, but if you want to embrace it as fully as possible in the meantime, we recommend putting all your modules inside either &lt;code&gt;client/imports/&lt;/code&gt; or &lt;code&gt;server/imports/&lt;/code&gt; directories, with just a single entry point for each architecture: &lt;code&gt;client/main.js&lt;/code&gt; and &lt;code&gt;server/main.js&lt;/code&gt;. The &lt;code&gt;main.js&lt;/code&gt; files will be evaluated eagerly, giving your application a chance to import modules from the &lt;code&gt;imports/&lt;/code&gt; directories.</source>
          <target state="translated">지연 평가는 향후 Meteor 버전에서 기본 동작이 될 가능성이 높지만 그 동안 가능한 한 완벽하게 수용하려면 모든 모듈을 &lt;code&gt;client/imports/&lt;/code&gt; 또는 &lt;code&gt;server/imports/&lt;/code&gt; 디렉토리에 배치하는 것이 좋습니다 . : 단지 하나의 각 아키텍처에 대한 진입 점과 &lt;code&gt;client/main.js&lt;/code&gt; 및 &lt;code&gt;server/main.js&lt;/code&gt; . &lt;code&gt;main.js&lt;/code&gt; 의 파일은 응용 프로그램로부터 수입 모듈에 기회를주고, 열심히 평가됩니다 &lt;code&gt;imports/&lt;/code&gt; 디렉토리.</target>
        </trans-unit>
        <trans-unit id="2fc33234e3d7f2cbc82e1f5c7df969a421883551" translate="yes" xml:space="preserve">
          <source>Lazy loading modules from a package</source>
          <target state="translated">패키지에서 지연 로딩 모듈</target>
        </trans-unit>
        <trans-unit id="3cefecad08fcaa310174a0a33bd07fc7c007d64c" translate="yes" xml:space="preserve">
          <source>Learn more about how to use collection helpers in the &lt;a href=&quot;collections#collection-helpers&quot;&gt;Collections article&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;collections#collection-helpers&quot;&gt;컬렉션 기사&lt;/a&gt; 에서 컬렉션 도우미를 사용하는 방법에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="b11d8c0ab52d35e474966b5f7f1f39a6280e48c5" translate="yes" xml:space="preserve">
          <source>Length of the string</source>
          <target state="translated">끈의 길이</target>
        </trans-unit>
        <trans-unit id="526cb7425ab8d8d55c981974917cba26fab9834e" translate="yes" xml:space="preserve">
          <source>Less</source>
          <target state="translated">Less</target>
        </trans-unit>
        <trans-unit id="e4f98de3ab3f36d35435275056982699600a25d3" translate="yes" xml:space="preserve">
          <source>Less is maintained as a &lt;a href=&quot;https://atmospherejs.com/meteor/less&quot;&gt;Meteor core package called &lt;code&gt;less&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">less는 &lt;a href=&quot;https://atmospherejs.com/meteor/less&quot;&gt; &lt;code&gt;less&lt;/code&gt; &lt;/a&gt; 라고 하는 Meteor 코어 패키지 로 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="39a42a6f682cb64e595380c28474baa0b5c89fe9" translate="yes" xml:space="preserve">
          <source>Less.js</source>
          <target state="translated">Less.js</target>
        </trans-unit>
        <trans-unit id="ef5fe1edf37940bd463fee8eda068dc8d66b0f8a" translate="yes" xml:space="preserve">
          <source>Let</source>
          <target state="translated">Let</target>
        </trans-unit>
        <trans-unit id="533c8a360ad209573b7a035e6e9d85489e4df1b4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s assume that we have a &lt;code&gt;Lists&lt;/code&gt; collection. To define a schema for this collection using &lt;code&gt;simple-schema&lt;/code&gt;, you can simply create a new instance of the &lt;code&gt;SimpleSchema&lt;/code&gt; class and attach it to the &lt;code&gt;Lists&lt;/code&gt; object:</source>
          <target state="translated">&lt;code&gt;Lists&lt;/code&gt; 컬렉션 이 있다고 가정 해 봅시다 . &lt;code&gt;simple-schema&lt;/code&gt; 를 사용하여이 콜렉션에 대한 스키마를 정의하려면 &lt;code&gt;SimpleSchema&lt;/code&gt; 클래스 의 새 인스턴스를 작성 하여 &lt;code&gt;Lists&lt;/code&gt; 오브젝트에 첨부하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="fade3d4ebc786e1e532abc9af1b0a346dec80c2a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider any generic item-listing component. To focus on a concrete example, we could consider the todo list in the Todos example app. Although it does not in our current example app, in a future version it could paginate through the todos for a given list.</source>
          <target state="translated">일반적인 항목 목록 구성 요소를 고려하십시오. 구체적인 예제에 초점을 맞추기 위해 Todos 예제 앱에서 할 일 목록을 고려할 수 있습니다. 현재 예제 앱에는 없지만 향후 버전에서는 주어진 목록에 대한 할 일을 살펴볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb80f1f768c0643b760d9f831673d4bc7d5c2da8" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider the case of the Todos example app. Here we do a similar thing to achieve animation between pages, by using Momentum in the main layout template:</source>
          <target state="translated">Todos 예제 앱의 경우를 고려해 봅시다. 여기서 우리는 메인 레이아웃 템플릿에서 Momentum을 사용하여 페이지 간 애니메이션을 달성하는 비슷한 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="7d1f6e724a957e722c1209ff84d6d1892e5306a5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s define a simple HTML form:</source>
          <target state="translated">간단한 HTML 양식을 정의 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="e66c87dd273adbaa4bd71414237809a738eb7fd6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at a few ways to resolve this issue.</source>
          <target state="translated">이 문제를 해결하는 몇 가지 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="9027762c7d8b7751ed6d1d6047913ca85c43e436" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you want to modify the &lt;code&gt;left-pad&lt;/code&gt; npm package. If you haven&amp;rsquo;t already, run inside your app directory:</source>
          <target state="translated">&lt;code&gt;left-pad&lt;/code&gt; npm 패키지 를 수정한다고 가정 해 봅시다 . 아직 앱 디렉토리 내에서 실행하지 않은 경우 :</target>
        </trans-unit>
        <trans-unit id="e7d55e87875df5f4fc55d1ad5156f4b661e1de65" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at example of both kinds of tests.</source>
          <target state="translated">두 종류의 테스트의 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="27c968e6692b41bf6e1a241b870dc41ff1a51b17" translate="yes" xml:space="preserve">
          <source>Libraries</source>
          <target state="translated">Libraries</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MIT 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="e0e16878b381615e86b13824930a254210b14558" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.meteor.com/api/tracker.html#Tracker-autorun&quot;&gt;&lt;code&gt;Tracker.autorun&lt;/code&gt;&lt;/a&gt;, except that the autorun is automatically stopped when the View is destroyed, and the &lt;a href=&quot;#Blaze-currentView&quot;&gt;current View&lt;/a&gt; is always set when running &lt;code&gt;runFunc&lt;/code&gt;. There is no relationship to the View&amp;rsquo;s internal autorun or render cycle. In &lt;code&gt;runFunc&lt;/code&gt;, the View is bound to &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.meteor.com/api/tracker.html#Tracker-autorun&quot;&gt; &lt;code&gt;Tracker.autorun&lt;/code&gt; &lt;/a&gt; 보기가 파괴 될 때 자동 실행이 자동으로 중지되고 있음을 제외하고 &lt;a href=&quot;#Blaze-currentView&quot;&gt;현재보기를&lt;/a&gt; 실행할 때 항상 설정되어 &lt;code&gt;runFunc&lt;/code&gt; 을 . View의 내부 자동 실행 또는 렌더링주기와는 관계가 없습니다. 에서 &lt;code&gt;runFunc&lt;/code&gt; 보기가에 바인딩 &lt;code&gt;this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42434c3cae0f5acc2defcf29aa2836b04c2893bd" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;{{#each .. in}}&lt;/code&gt;, &lt;code&gt;{{#each}}&lt;/code&gt; iterates over an array or cursor, changing the data context within its content block to be the item in the current iteration. &lt;code&gt;{{#with}}&lt;/code&gt; simply changes the data context inside itself to the provided object. In most cases it&amp;rsquo;s better to use &lt;code&gt;{{#each .. in}}&lt;/code&gt; and &lt;code&gt;{{#let}}&lt;/code&gt; instead, just like it&amp;rsquo;s better to declare a variable than use the JavaScript &lt;code&gt;with&lt;/code&gt; keyword.</source>
          <target state="translated">마찬가지로 &lt;code&gt;{{#each .. in}}&lt;/code&gt; , &lt;code&gt;{{#each}}&lt;/code&gt; 콘텐츠 블록 내의 데이터 컨텍스트를 변경하는 배열을 반복 또는 커서는 현재 반복의 상품한다. &lt;code&gt;{{#with}}&lt;/code&gt; 는 그 자체로 데이터 컨텍스트를 제공된 오브젝트로 변경합니다. 대부분의 경우 키워드에 JavaScript &lt;code&gt;with&lt;/code&gt; 사용하는 것보다 변수를 선언하는 것이 낫 &lt;code&gt;{{#each .. in}}&lt;/code&gt; 및 &lt;code&gt;{{#let}}&lt;/code&gt; 을 대신 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="c17cd4675137c3211881b87771487db77b9a14f1" translate="yes" xml:space="preserve">
          <source>Like all &lt;a href=&quot;#collections&quot;&gt;Mongo.Collection&lt;/a&gt;s, you can access all documents on the server, but only those specifically published by the server are available on the client. You can also use all Collection methods, for instance &lt;code&gt;Meteor.users.remove&lt;/code&gt; on the server to delete a user.</source>
          <target state="translated">모든 &lt;a href=&quot;#collections&quot;&gt;Mongo.Collection&lt;/a&gt; 과 마찬가지로 서버의 모든 문서에 액세스 할 수 있지만 서버에서 특별히 게시 한 문서 만 클라이언트에서 사용할 수 있습니다. 서버에서 &lt;code&gt;Meteor.users.remove&lt;/code&gt; 와 같은 모든 Collection 메소드 를 사용하여 사용자를 삭제할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="57282be9feffc0a99ce69cb83b6ece8c1c7d9e97" translate="yes" xml:space="preserve">
          <source>Like any other global singleton in your application (see the &lt;a href=&quot;data-loading#stores&quot;&gt;data loading&lt;/a&gt; for info about stores), it&amp;rsquo;s best to limit your access to &lt;code&gt;FlowRouter&lt;/code&gt;. That way the parts of your app will remain modular and more independent. In the case of &lt;code&gt;FlowRouter&lt;/code&gt;, it&amp;rsquo;s best to access it solely from the top of your component hierarchy, either in the &amp;ldquo;page&amp;rdquo; component, or the layouts that wrap it. Read more about accessing data in the &lt;a href=&quot;ui-ux#components&quot;&gt;UI article&lt;/a&gt;.</source>
          <target state="translated">애플리케이션의 다른 글로벌 싱글 톤과 마찬가지로 ( 스토어에 대한 정보 는 &lt;a href=&quot;data-loading#stores&quot;&gt;데이터로드&lt;/a&gt; 참조 ) &lt;code&gt;FlowRouter&lt;/code&gt; 에 대한 액세스를 제한하는 것이 가장 좋습니다 . 이렇게하면 앱의 일부가 모듈 식이고 더 독립적으로 유지됩니다. &lt;code&gt;FlowRouter&lt;/code&gt; 의 경우 &quot;페이지&quot;구성 요소 또는 구성 요소를 감싸는 레이아웃에서 구성 요소 계층 구조의 최상위에서만 액세스하는 것이 가장 좋습니다. &lt;a href=&quot;ui-ux#components&quot;&gt;UI 기사&lt;/a&gt; 에서 데이터 액세스에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="be27ee8daec41f6f1ae70ee3d8b18835b4abaeb8" translate="yes" xml:space="preserve">
          <source>Likewise on the client:</source>
          <target state="translated">마찬가지로 클라이언트에서도 :</target>
        </trans-unit>
        <trans-unit id="a2607bd54add9408c0721369c9c1c8d041e8abf8" translate="yes" xml:space="preserve">
          <source>Limiting re-rendering</source>
          <target state="translated">재 렌더링 제한</target>
        </trans-unit>
        <trans-unit id="83ffcdcfaf1c24e2d15ef594b5f5431a0e7f32a8" translate="yes" xml:space="preserve">
          <source>Limiting the results serves a double purpose: it both prevents sensitive fields from being disclosed to the client and limits recomputation to the relevant fields only (namely, the &lt;code&gt;admin&lt;/code&gt; field).</source>
          <target state="translated">결과를 제한하는 것은 두 가지 목적을 제공합니다. 민감한 필드가 클라이언트에 공개되는 것을 방지하고 관련 필드 (즉, &lt;code&gt;admin&lt;/code&gt; 필드) 로만 재 계산을 제한 합니다.</target>
        </trans-unit>
        <trans-unit id="f6737babb19a4d874f1ca10734cd454bf2662c6f" translate="yes" xml:space="preserve">
          <source>Link the JavaScript files: wrap them into closures and provide necessary package imports.</source>
          <target state="translated">JavaScript 파일을 연결하십시오. 파일을 클로저로 묶고 필요한 패키지 가져 오기를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="cbb9d2b8205838917953cadea0aa0bdcbc27a594" translate="yes" xml:space="preserve">
          <source>Lint all source files and print the linting warnings.</source>
          <target state="translated">모든 소스 파일을 보푸라기하고 보푸라기 경고를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="08c4bdbbc8b84fda922dfbab609ea3937e98134b" translate="yes" xml:space="preserve">
          <source>Linter plugin - processes any number of files, and can print lint errors. Multiple linters can process the same files.</source>
          <target state="translated">린터 플러그인-여러 파일을 처리하고 보푸라기 오류를 인쇄 할 수 있습니다. 여러 개의 린터가 동일한 파일을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="64a7a833a84d006de3da423e4b3f69148b963064" translate="yes" xml:space="preserve">
          <source>Linters</source>
          <target state="translated">Linters</target>
        </trans-unit>
        <trans-unit id="c20c35d5e5d64e2186ff761f431660d1bfca7a1b" translate="yes" xml:space="preserve">
          <source>Linters are programs that check the code for undeclared variables or find code that doesn&amp;rsquo;t correspond to certain style guidelines. Some of the popular examples of linters are &lt;a href=&quot;http://jshint.com/about/&quot;&gt;JSHint&lt;/a&gt; and &lt;a href=&quot;http://eslint.org/&quot;&gt;ESLint&lt;/a&gt;. Some of the non-JavaScript linter examples include &lt;a href=&quot;http://www.coffeelint.org/&quot;&gt;CoffeeLint&lt;/a&gt; for CoffeeScript and &lt;a href=&quot;http://csslint.net/&quot;&gt;CSSLint&lt;/a&gt; for CSS.</source>
          <target state="translated">린 터는 코드에서 선언되지 않은 변수를 확인하거나 특정 스타일 지침에 해당하지 않는 코드를 찾는 프로그램입니다. 린터의 대중적인 예 중 일부는 &lt;a href=&quot;http://jshint.com/about/&quot;&gt;JSHint&lt;/a&gt; 및 &lt;a href=&quot;http://eslint.org/&quot;&gt;ESLint&lt;/a&gt; 입니다. 자바 스크립트가 아닌 린터 예제 중 일부는 &lt;a href=&quot;http://www.coffeelint.org/&quot;&gt;CoffeeLint&lt;/a&gt; for CoffeeScript 및 &lt;a href=&quot;http://csslint.net/&quot;&gt;CSSLint&lt;/a&gt; for CSS를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="5e89a08a35d6bca50ebd56b625757a9b53856de8" translate="yes" xml:space="preserve">
          <source>Linting can be activated on WebStorm on a project-by-project basis, or you can set ESLint as a default under Editor &amp;gt; Inspections, choosing the Default profile, checking &amp;ldquo;ESLint&amp;rdquo;, and applying.</source>
          <target state="translated">Lins는 프로젝트별로 WebStorm에서 활성화하거나 Editor&amp;gt; Inspections에서 ESLint를 기본값으로 설정하고 기본 프로파일을 선택하고 &quot;ESLint&quot;를 확인하고 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="807c5a611bc0187a87d766234267271b8e0c7a82" translate="yes" xml:space="preserve">
          <source>Linting is the fastest way to find potential bugs in your code. Running a linter is usually faster than running your app or your unit tests, so it&amp;rsquo;s a good idea to run it all the time. Setting up linting in your editor can seem annoying at first since it will complain often when you save poorly-formatted code, but over time you&amp;rsquo;ll develop the muscle memory to just write well-formatted code in the first place. Here are some directions for setting up ESLint in different editors:</source>
          <target state="translated">Linting은 코드에서 잠재적 인 버그를 찾는 가장 빠른 방법입니다. 린터 실행은 일반적으로 앱 또는 단위 테스트를 실행하는 것보다 빠르므로 항상 실행하는 것이 좋습니다. 형식이 잘못된 코드를 저장할 때 자주 불평하기 때문에 편집기에서 보푸라기를 설정하는 것은 처음에는 성가신 것처럼 보일 수 있지만 시간이 지남에 따라 형식이 좋은 코드를 먼저 작성하기 위해 근육 메모리를 개발하게됩니다. 다른 편집기에서 ESLint를 설정하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c5fbfa2b671a883848337ca1fbcbf12a2dff8542" translate="yes" xml:space="preserve">
          <source>List of environment variables that you can use with your Meteor application.</source>
          <target state="translated">Meteor 응용 프로그램과 함께 사용할 수있는 환경 변수 목록입니다.</target>
        </trans-unit>
        <trans-unit id="6a32ea9a210990174cdb9e5a3e5cdf4b656aa683" translate="yes" xml:space="preserve">
          <source>List of routing packages which supports rendering of blaze templates.</source>
          <target state="translated">Blaze 템플릿 렌더링을 지원하는 라우팅 패키지 목록입니다.</target>
        </trans-unit>
        <trans-unit id="237c4e9c76dd34f9fef4cb5f527add12e50da086" translate="yes" xml:space="preserve">
          <source>Lists all of the platforms that have been explicitly added to your project.</source>
          <target state="translated">프로젝트에 명시 적으로 추가 된 모든 플랫폼을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="289fbe2367499465f159d431d4539e1ccf3b5be3" translate="yes" xml:space="preserve">
          <source>Lists all the packages that you have added to your project. For each package, lists the version that you are using. Lets you know if a newer version of that package is available.</source>
          <target state="translated">프로젝트에 추가 한 모든 패키지를 나열합니다. 각 패키지마다 사용중인 버전이 나열됩니다. 해당 패키지의 최신 버전이 있는지 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="d0929f65fd871a616b54e0f40a3e70433d2a1f23" translate="yes" xml:space="preserve">
          <source>Loading and displaying user data</source>
          <target state="translated">사용자 데이터로드 및 표시</target>
        </trans-unit>
        <trans-unit id="e7e6cd559c8c3763e6639df54316f5fb7c52be56" translate="yes" xml:space="preserve">
          <source>Loading data from a REST endpoint with a publication</source>
          <target state="translated">공개를 사용하여 REST 엔드 포인트에서 데이터로드</target>
        </trans-unit>
        <trans-unit id="ffef655301a42ecab38bf3596a2c7ce13d16b222" translate="yes" xml:space="preserve">
          <source>Loading data with Methods</source>
          <target state="translated">메소드를 사용하여 데이터로드</target>
        </trans-unit>
        <trans-unit id="d53b5e4f51d74d9669432621576e04fcc6fd4a76" translate="yes" xml:space="preserve">
          <source>Loading states are notoriously difficult to work on visually as they are by definition transient and often are barely noticeable in a development environment where subscriptions load almost instantly.</source>
          <target state="translated">로딩 상태는 정의상 일시적이므로 시각적으로 작업하기가 어렵고 구독이 거의 즉시로드되는 개발 환경에서는 거의 눈에 띄지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dacb906d06c3edb1203b705cec44a92faaea9900" translate="yes" xml:space="preserve">
          <source>Local &lt;code&gt;node_modules&lt;/code&gt;</source>
          <target state="translated">로컬 &lt;code&gt;node_modules&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="567dcc89ed871782a8ea57c5f0ee6e5a1ef1b4d5" translate="yes" xml:space="preserve">
          <source>Local collections</source>
          <target state="translated">지역 컬렉션</target>
        </trans-unit>
        <trans-unit id="f4a889e8085dc57ac139a50362f502bdc1eacf7f" translate="yes" xml:space="preserve">
          <source>Local files</source>
          <target state="translated">로컬 파일</target>
        </trans-unit>
        <trans-unit id="41022c9a58e615d942f295ba352fd4e63d7bc667" translate="yes" xml:space="preserve">
          <source>Local packages</source>
          <target state="translated">지역 패키지</target>
        </trans-unit>
        <trans-unit id="27c0e0a7170faa8a9da9611875b0dac036558a2f" translate="yes" xml:space="preserve">
          <source>Log in and out of your account using Meteor&amp;rsquo;s authentication system.</source>
          <target state="translated">Meteor의 인증 시스템을 사용하여 계정에 로그인 및 로그 아웃하십시오.</target>
        </trans-unit>
        <trans-unit id="ce2bf9c2a4373ee255609030571e3033460571d8" translate="yes" xml:space="preserve">
          <source>Log out other clients logged in as the current user, but does not log out the client that calls this function.</source>
          <target state="translated">현재 사용자로 로그인 한 다른 클라이언트를 로그 아웃하지만이 기능을 호출하는 클라이언트는 로그 아웃하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a57c5797fff2e3f238765076b070f1727771f56" translate="yes" xml:space="preserve">
          <source>Log the user in using an external service.</source>
          <target state="translated">외부 서비스를 사용하여 사용자를 로그인하십시오.</target>
        </trans-unit>
        <trans-unit id="62bcfd8b5c64843ba3c1dd3405e9a324dfb93a64" translate="yes" xml:space="preserve">
          <source>Log the user in with a password.</source>
          <target state="translated">비밀번호로 사용자를 로그인하십시오.</target>
        </trans-unit>
        <trans-unit id="78bf1464712a439f5499592247c70a116b407683" translate="yes" xml:space="preserve">
          <source>Log the user out.</source>
          <target state="translated">사용자를 로그 아웃하십시오.</target>
        </trans-unit>
        <trans-unit id="31841ae644017a32c06ba2bfe4439341d3aad516" translate="yes" xml:space="preserve">
          <source>Logging and debugging</source>
          <target state="translated">로깅 및 디버깅</target>
        </trans-unit>
        <trans-unit id="783f02798d5892e34e2b6c2aa451f3417f080785" translate="yes" xml:space="preserve">
          <source>Logging in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ceed770d54126021a13d9171a9ee0e97cad7073" translate="yes" xml:space="preserve">
          <source>Login service configuration is sent from the server to the client over DDP when your app starts up; you may not call the login function until the configuration is loaded. The function &lt;code&gt;Accounts.loginServicesConfigured()&lt;/code&gt; is a reactive data source that will return true once the login service is configured; you should not make login buttons visible or active until it is true.</source>
          <target state="translated">앱이 시작되면 로그인 서비스 구성이 DDP를 통해 서버에서 클라이언트로 전송됩니다. 구성이로드 될 때까지 로그인 기능을 호출 할 수 없습니다. &lt;code&gt;Accounts.loginServicesConfigured()&lt;/code&gt; 함수 는 로그인 서비스가 구성되면 true를 반환하는 반응 형 데이터 소스입니다. 로그인 버튼이 true가 될 때까지 표시하거나 활성화하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="9fd7bb7cd5ee09061a524c727a8fd4f9a425724a" translate="yes" xml:space="preserve">
          <source>Login style (&quot;popup&quot; or &quot;redirect&quot;, defaults to the login service configuration). The &quot;popup&quot; style opens the login page in a separate popup window, which is generally preferred because the Meteor application doesn't need to be reloaded. The &quot;redirect&quot; style redirects the Meteor application's window to the login page, and the login service provider redirects back to the Meteor application which is then reloaded. The &quot;redirect&quot; style can be used in situations where a popup window can't be opened, such as in a mobile UIWebView. The &quot;redirect&quot; style however relies on session storage which isn't available in Safari private mode, so the &quot;popup&quot; style will be forced if session storage can't be used.</source>
          <target state="translated">로그인 스타일 ( &quot;팝업&quot;또는 &quot;리디렉션&quot;, 기본적으로 로그인 서비스 구성) &quot;팝업&quot;스타일은 별도의 팝업 창에서 로그인 페이지를 열며, 일반적으로 Meteor 응용 프로그램을 다시로드 할 필요가 없기 때문에 선호됩니다. &quot;리디렉션&quot;스타일은 Meteor 응용 프로그램의 창을 로그인 페이지로 리디렉션하고, 로그인 서비스 공급자는 Meteor 응용 프로그램으로 다시 리디렉션 한 다음 다시로드됩니다. &quot;리디렉션&quot;스타일은 모바일 UIWebView와 같이 팝업 창을 열 수없는 상황에서 사용할 수 있습니다. &quot;리디렉션&quot;스타일은 Safari 개인 모드에서 사용할 수없는 세션 스토리지에 의존하므로 세션 스토리지를 사용할 수없는 경우 &quot;팝업&quot;스타일이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="07de5cf7de296d1847046aebae8acafadfcb75d9" translate="yes" xml:space="preserve">
          <source>Logout all current connections with this userId (default: true)</source>
          <target state="translated">이 userId로 모든 현재 연결을 로그 아웃하십시오 (기본값 : true).</target>
        </trans-unit>
        <trans-unit id="ab9527efdb5520fd59ebe0531c100593d538a2d4" translate="yes" xml:space="preserve">
          <source>Lookup order</source>
          <target state="translated">조회 순서</target>
        </trans-unit>
        <trans-unit id="e973a05925c462f97e11d4b82b455afa324a7ec8" translate="yes" xml:space="preserve">
          <source>MAIL_URL</source>
          <target state="translated">MAIL_URL</target>
        </trans-unit>
        <trans-unit id="357a834b670084af1d1f6134f0ef53507b115246" translate="yes" xml:space="preserve">
          <source>METEOR_PACKAGE_DIRS</source>
          <target state="translated">METEOR_PACKAGE_DIRS</target>
        </trans-unit>
        <trans-unit id="4328c41a1c3a7f6d86eb9ca05323eccf06285d2c" translate="yes" xml:space="preserve">
          <source>METEOR_SETTINGS</source>
          <target state="translated">METEOR_SETTINGS</target>
        </trans-unit>
        <trans-unit id="b91dcf1e030967fd2c7bd0c3c58bad58cf16c8ff" translate="yes" xml:space="preserve">
          <source>MONGO_OPLOG_URL</source>
          <target state="translated">MONGO_OPLOG_URL</target>
        </trans-unit>
        <trans-unit id="e95f1d302570f380146a9bd4df7a6726daa4c2ea" translate="yes" xml:space="preserve">
          <source>MONGO_URL</source>
          <target state="translated">MONGO_URL</target>
        </trans-unit>
        <trans-unit id="08bce2d9a3206bf0d7143d86833197a8534fabc6" translate="yes" xml:space="preserve">
          <source>Mac</source>
          <target state="translated">Mac</target>
        </trans-unit>
        <trans-unit id="0f06fae50518f48a3780998a35f988974e32fb05" translate="yes" xml:space="preserve">
          <source>Mail body (in plain text and/or HTML)</source>
          <target state="translated">메일 본문 (일반 텍스트 및 / 또는 HTML)</target>
        </trans-unit>
        <trans-unit id="a28faad48ffe4d9f2fd6baedeefc521cecfb8314" translate="yes" xml:space="preserve">
          <source>Mail body in HTML specific for Apple Watch</source>
          <target state="translated">Apple Watch 전용 HTML의 메일 본문</target>
        </trans-unit>
        <trans-unit id="b412ceec910344b549407171c1d1dcc6de9f7022" translate="yes" xml:space="preserve">
          <source>Make sure secret API keys and passwords aren&amp;rsquo;t in your source code.</source>
          <target state="translated">비밀 API 키와 비밀번호가 소스 코드에 없는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="89aac1c91a334c0ca9c4eaebf899112859fa92ef" translate="yes" xml:space="preserve">
          <source>Make sure the device is connected to your computer via a USB cable.</source>
          <target state="translated">장치가 USB 케이블을 통해 컴퓨터에 연결되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="1e837c1b669985c06d8b9d5f95108990d0f07fb9" translate="yes" xml:space="preserve">
          <source>Make sure to select the correct version of the &lt;a href=&quot;https://developer.android.com/studio/releases/sdk-tools.html&quot;&gt;Android Studio SDK Tools&lt;/a&gt;:</source>
          <target state="translated">올바른 &lt;a href=&quot;https://developer.android.com/studio/releases/sdk-tools.html&quot;&gt;Android Studio SDK 도구&lt;/a&gt; 버전을 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="85404e99d1eb544d78211afc39e86e0dd1a63689" translate="yes" xml:space="preserve">
          <source>Make sure your app doesn&amp;rsquo;t have the &lt;code&gt;insecure&lt;/code&gt; or &lt;code&gt;autopublish&lt;/code&gt; packages.</source>
          <target state="translated">앱에 &lt;code&gt;insecure&lt;/code&gt; 않거나 &lt;code&gt;autopublish&lt;/code&gt; 패키지 가 없는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="d5712bacc51d4ae0bcd9f6914d7e1bdc6d7ca4f3" translate="yes" xml:space="preserve">
          <source>Make sure your device is set up for development &lt;a href=&quot;http://developer.android.com/tools/device.html#setting-up&quot;&gt;as explained here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://developer.android.com/tools/device.html#setting-up&quot;&gt;여기에 설명 된대로&lt;/a&gt; 장치가 개발 용 으로 설정되어 있는지 확인 하십시오 .</target>
        </trans-unit>
        <trans-unit id="18a375e5e20b590475e54609de53cc4959a2ab46" translate="yes" xml:space="preserve">
          <source>Makes it safe to use reserved keywords as property names. For example, &lt;code&gt;object.catch&lt;/code&gt; is translated to &lt;code&gt;object[&quot;catch&quot;]&lt;/code&gt;.</source>
          <target state="translated">예약 된 키워드를 속성 이름으로 사용하는 것이 안전합니다. 예를 들어 &lt;code&gt;object.catch&lt;/code&gt; 는 &lt;code&gt;object[&quot;catch&quot;]&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="a636adb47b461fbd152a8377933d7f1ba89294ed" translate="yes" xml:space="preserve">
          <source>Makes it safe to use reserved keywords like &lt;code&gt;catch&lt;/code&gt; as unquoted keys in object literals. For example, &lt;code&gt;{ catch: 123 }&lt;/code&gt; is translated to &lt;code&gt;{ &quot;catch&quot;: 123 }&lt;/code&gt;.</source>
          <target state="translated">객체 리터럴에서 인용되지 않은 키로 &lt;code&gt;catch&lt;/code&gt; 와 같은 예약 된 키워드를 사용하는 것이 안전합니다 . 예를 들어, &lt;code&gt;{ catch: 123 }&lt;/code&gt; 은 &lt;code&gt;{ &quot;catch&quot;: 123 }&lt;/code&gt; 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="0b4a7a973e5f6071313d6e349133c5b901c16a58" translate="yes" xml:space="preserve">
          <source>Making sure a plugin is compatible with the bundled Cordova platform versions</source>
          <target state="translated">플러그인이 번들 된 Cordova 플랫폼 버전과 호환되는지 확인</target>
        </trans-unit>
        <trans-unit id="9888ad8ac1983d8dd059e79f6a9118f01551d935" translate="yes" xml:space="preserve">
          <source>Many Method operations are idempotent by default. Inserts will throw an error if they happen twice because the generated ID will conflict. Removes on collections won&amp;rsquo;t do anything the second time, and most update operators like &lt;code&gt;$set&lt;/code&gt; will have the same result if run again. The only places you need to worry about code running twice are MongoDB update operators that stack, like &lt;code&gt;$inc&lt;/code&gt; and &lt;code&gt;$push&lt;/code&gt;, and calls to external APIs.</source>
          <target state="translated">많은 메소드 조작은 기본적으로 dem 등원입니다. 생성 된 ID가 충돌하기 때문에 삽입이 두 번 발생하면 오류가 발생합니다. 컬렉션에서 제거는 두 번째로 아무 작업도 수행하지 않으며 &lt;code&gt;$set&lt;/code&gt; 와 같은 대부분의 업데이트 연산자는 다시 실행하면 동일한 결과를 얻습니다. 코드가 두 번 실행되는 것에 대해 걱정해야 할 유일한 곳은 &lt;code&gt;$inc&lt;/code&gt; 및 &lt;code&gt;$push&lt;/code&gt; 와 같은 스택 및 외부 API 호출 과 같은 MongoDB 업데이트 연산자입니다 .</target>
        </trans-unit>
        <trans-unit id="3d22d15470f5d8b97196e8e7bc9698996e974b43" translate="yes" xml:space="preserve">
          <source>Many articles reference the Todos example application. This code is being actively developed alongside the guide. You can see the latest source code for the app, and file issues or make suggestions via pull request at its &lt;a href=&quot;https://github.com/meteor/todos&quot;&gt;GitHub repository&lt;/a&gt;.</source>
          <target state="translated">많은 기사가 Todos 예제 애플리케이션을 참조합니다. 이 코드는 가이드와 함께 활발히 개발되고 있습니다. 앱의 최신 소스 코드와 파일 문제를 보거나 &lt;a href=&quot;https://github.com/meteor/todos&quot;&gt;GitHub 리포지토리&lt;/a&gt; 에서 풀 요청을 통해 제안을 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b24a8d32e364af4a31b5ca24c727fca9c029001" translate="yes" xml:space="preserve">
          <source>Many npm packages adopt the convention of taking a callback that accepts &lt;code&gt;(err, res)&lt;/code&gt; arguments. If your asynchronous function fits this description, like the one above, you can use &lt;code&gt;Meteor.wrapAsync&lt;/code&gt; to convert to a fiberized API that uses return values and exceptions instead of callbacks, like so:</source>
          <target state="translated">많은 npm 패키지는 &lt;code&gt;(err, res)&lt;/code&gt; 인수 를 받아들이는 콜백 규칙을 채택합니다 . 위와 같이 비동기 함수가이 설명에 적합하면 &lt;code&gt;Meteor.wrapAsync&lt;/code&gt; 를 사용하여 다음과 같이 콜백 대신 반환 값과 예외를 사용하는 파이버 라이즈 된 API로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="050995dc3ca4d8451591198e4b2aafef357fa495" translate="yes" xml:space="preserve">
          <source>Many npm packages rely on an asynchronous, callback or promise-based coding style. For several reasons, Meteor is currently built around a synchronous-looking but still non-blocking style using &lt;a href=&quot;https://github.com/laverdet/node-fibers&quot;&gt;Fibers&lt;/a&gt;.</source>
          <target state="translated">많은 npm 패키지는 비동기식, 콜백 또는 약속 기반 코딩 스타일을 사용합니다. 여러 가지 이유로 Meteor는 현재 &lt;a href=&quot;https://github.com/laverdet/node-fibers&quot;&gt;Fibers를&lt;/a&gt; 사용하여 동기식이지만 여전히 블로킹되지 않는 스타일을 기반으로 구축되었습니다 .</target>
        </trans-unit>
        <trans-unit id="513e71826dc59ee6d3b9dec634899d66c8bc8a8e" translate="yes" xml:space="preserve">
          <source>Map callback over all matching documents. Returns an Array.</source>
          <target state="translated">일치하는 모든 문서에 콜백을 매핑하십시오. 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8219b264ad4b0f6b88e15181ddc3b8fb6c17030f" translate="yes" xml:space="preserve">
          <source>Marks the user's email address as verified. Logs the user in afterwards.</source>
          <target state="translated">사용자의 이메일 주소를 확인 된 것으로 표시합니다. 나중에 사용자를 로그인합니다.</target>
        </trans-unit>
        <trans-unit id="d20dcbee72eb621b15360eaea8236dddbe4a2138" translate="yes" xml:space="preserve">
          <source>Match Patterns</source>
          <target state="translated">매치 패턴</target>
        </trans-unit>
        <trans-unit id="7668ef6191ec870aea04a7212985e7d39c7c8ae7" translate="yes" xml:space="preserve">
          <source>Match.test()</source>
          <target state="translated">Match.test()</target>
        </trans-unit>
        <trans-unit id="0a524dbdc4300b1d5c466dc5b11ec3fb9b8a6cac" translate="yes" xml:space="preserve">
          <source>Matchers specify which events are counted towards a rate limit. A matcher is an object that has a subset of the same properties as the event objects described above. Each value in a matcher object is one of the following:</source>
          <target state="translated">매처는 속도 제한으로 계산되는 이벤트를 지정합니다. 매처는 위에서 설명한 이벤트 오브젝트와 동일한 특성의 서브 세트를 갖는 오브젝트입니다. 매처 객체의 각 값은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="03f73f73e53b8a20f7c958dda4c5b0061ccb9a8a" translate="yes" xml:space="preserve">
          <source>Matches a particular type of event, but only when it appears on an element that matches a certain CSS selector.</source>
          <target state="translated">특정 유형의 이벤트와 일치하지만 특정 CSS 선택기와 일치하는 요소에 나타나는 경우에만 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="6abc84683b8c1c7a6a61381314c65fc24f52bd4b" translate="yes" xml:space="preserve">
          <source>Matches a primitive of the given type.</source>
          <target state="translated">주어진 유형의 프리미티브와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="fb564a1785cc03f541394f3bf380caa1c4f06b34" translate="yes" xml:space="preserve">
          <source>Matches a signed 32-bit integer. Doesn&amp;rsquo;t match &lt;code&gt;Infinity&lt;/code&gt;, &lt;code&gt;-Infinity&lt;/code&gt;, or &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">부호있는 32 비트 정수와 일치합니다. &lt;code&gt;Infinity&lt;/code&gt; , &lt;code&gt;-Infinity&lt;/code&gt; 또는 &lt;code&gt;NaN&lt;/code&gt; 과 일치하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9d55b78a97aa87168c5a2b7cd2af65d299629b2f" translate="yes" xml:space="preserve">
          <source>Matches an Object with the given keys, with values matching the given patterns. If any &lt;em&gt;pattern&lt;/em&gt; is a &lt;code&gt;Match.Maybe&lt;/code&gt; or &lt;code&gt;Match.Optional&lt;/code&gt;, that key does not need to exist in the object. The value may not contain any keys not listed in the pattern. The value must be a plain Object with no special prototype.</source>
          <target state="translated">주어진 패턴과 일치하는 값으로 주어진 키와 Object를 일치시킵니다. 어떤 경우 &lt;em&gt;패턴이&lt;/em&gt; A는 &lt;code&gt;Match.Maybe&lt;/code&gt; 또는 &lt;code&gt;Match.Optional&lt;/code&gt; , 그 키는 객체에 존재 할 필요가 없습니다. 패턴에 나열되지 않은 키는 값에 포함되지 않을 수 있습니다. 값은 특별한 프로토 타입이없는 일반 객체 여야합니다.</target>
        </trans-unit>
        <trans-unit id="0f391c5569cdace62bd6748c6a0789a7f56045e5" translate="yes" xml:space="preserve">
          <source>Matches an Object with the given keys; the value may also have other keys with arbitrary values.</source>
          <target state="translated">주어진 키와 객체를 일치시킵니다. 값에는 임의의 값을 가진 다른 키가있을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e41ba767baa22b5b4ffa8b240da42727e6dc807" translate="yes" xml:space="preserve">
          <source>Matches any element that is an instance of that type.</source>
          <target state="translated">해당 유형의 인스턴스 인 요소와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="1507b874f0d3213f7c9c80574235ff4d72992e38" translate="yes" xml:space="preserve">
          <source>Matches any plain Object with any keys; equivalent to &lt;code&gt;Match.ObjectIncluding({})&lt;/code&gt;.</source>
          <target state="translated">모든 일반 객체를 키와 일치시킵니다. &lt;code&gt;Match.ObjectIncluding({})&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="e1b557a9bc68663eb48f6403424b0549919157ea" translate="yes" xml:space="preserve">
          <source>Matches any value that matches at least one of the provided patterns.</source>
          <target state="translated">제공된 패턴 중 하나 이상과 일치하는 모든 값을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="add75212619bba1e4e5fef214807c4ad984cefdc" translate="yes" xml:space="preserve">
          <source>Matches any value.</source>
          <target state="translated">모든 값과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="1521c460c4a6bf7385a64ba3716af0b414637cb0" translate="yes" xml:space="preserve">
          <source>Matches either &lt;code&gt;undefined&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, or &lt;em&gt;pattern&lt;/em&gt;. If used in an object, matches only if the key is not set as opposed to the value being set to &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;. This set of conditions was chosen because &lt;code&gt;undefined&lt;/code&gt; arguments to Meteor Methods are converted to &lt;code&gt;null&lt;/code&gt; when sent over the wire.</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; 또는 &lt;em&gt;pattern&lt;/em&gt; 과 일치합니다 . 객체에 사용되는 경우 &lt;code&gt;undefined&lt;/code&gt; 또는 &lt;code&gt;null&lt;/code&gt; 로 설정되는 값이 아니라 키가 설정되지 않은 경우에만 일치합니다 . 유선을 통해 전송 될 때 Meteor Methods에 대한 &lt;code&gt;undefined&lt;/code&gt; 인수가 &lt;code&gt;null&lt;/code&gt; 로 변환되므로이 조건 세트가 선택되었습니다 .</target>
        </trans-unit>
        <trans-unit id="fbcb9e3b7d26f7500e2b86622cced9536d2c04fa" translate="yes" xml:space="preserve">
          <source>Matches the behavior of &lt;code&gt;{{#each}}&lt;/code&gt; in templates.</source>
          <target state="translated">템플릿에서 &lt;code&gt;{{#each}}&lt;/code&gt; 의 동작과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="8e2b2f29e295a676f308a0a5e268e66292a03a29" translate="yes" xml:space="preserve">
          <source>Matches the behavior of &lt;code&gt;{{#if}}&lt;/code&gt; in templates.</source>
          <target state="translated">템플릿에서 &lt;code&gt;{{#if}}&lt;/code&gt; 의 동작과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="927530b6acb62459cc6c80eeef299ac47e6bc087" translate="yes" xml:space="preserve">
          <source>Matches the behavior of &lt;code&gt;{{#unless}}&lt;/code&gt; in templates.</source>
          <target state="translated">템플릿에서 &lt;code&gt;{{#unless}}&lt;/code&gt; 의 동작과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="d7c0d4b376351b7a9d91084b58ebe7d5b0a9dd9f" translate="yes" xml:space="preserve">
          <source>Matches the type of events, such as &lt;code&gt;'click'&lt;/code&gt;, separated by a forward slash, like so &lt;code&gt;'touchend/mouseup/keyup'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'touchend/mouseup/keyup'&lt;/code&gt; 과 같이 슬래시로 구분 된 &lt;code&gt;'click'&lt;/code&gt; 과 같은 이벤트 유형과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="01403bbf57c3b114bdd15163c025084dfcf83ab6" translate="yes" xml:space="preserve">
          <source>Maximum number of results to return</source>
          <target state="translated">반환 할 최대 결과 수</target>
        </trans-unit>
        <trans-unit id="368712eec67f68ec4ac017d1e1ea7bd41c9d602e" translate="yes" xml:space="preserve">
          <source>Maximum time in milliseconds to wait for the request before failing. There is no timeout by default.</source>
          <target state="translated">실패하기 전에 요청을 기다리는 최대 시간 (밀리 초)입니다. 기본적으로 시간 종료는 없습니다.</target>
        </trans-unit>
        <trans-unit id="3640bfaf55a8b64e0a4b999bf8aab62358ffc594" translate="yes" xml:space="preserve">
          <source>Meetup with &lt;code&gt;accounts-meetup&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;accounts-meetup&lt;/code&gt; Meetup</target>
        </trans-unit>
        <trans-unit id="278e0c7fb567feb534ddeb9f1aef82842151f497" translate="yes" xml:space="preserve">
          <source>Meetup: &lt;a href=&quot;http://www.meetup.com/meetup_api/auth/#oauth2-scopes&quot;&gt;http://www.meetup.com/meetup_api/auth/#oauth2-scopes&lt;/a&gt;</source>
          <target state="translated">Meetup : &lt;a href=&quot;http://www.meetup.com/meetup_api/auth/#oauth2-scopes&quot;&gt;http://www.meetup.com/meetup_api/auth/#oauth2-scopes&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0d917cfc79a74f9cf135d7cefcfc6eb4811d9b76" translate="yes" xml:space="preserve">
          <source>Message-ID for this message; otherwise, will be set to a random value</source>
          <target state="translated">이 메시지의 메시지 ID. 그렇지 않으면 임의의 값으로 설정됩니다</target>
        </trans-unit>
        <trans-unit id="da963b969942172b48c67a368a10a3a7ce182a0b" translate="yes" xml:space="preserve">
          <source>Message-ID this message is replying to</source>
          <target state="translated">Message-ID이 메시지는 회신하고 있습니다</target>
        </trans-unit>
        <trans-unit id="251edc0eb5a820646bda4e103f0f007fd55321f3" translate="yes" xml:space="preserve">
          <source>Metadata</source>
          <target state="translated">Metadata</target>
        </trans-unit>
        <trans-unit id="3df1a8a24cd0d57dda9fa6bba80b035ddc0ceafb" translate="yes" xml:space="preserve">
          <source>Meteor</source>
          <target state="translated">Meteor</target>
        </trans-unit>
        <trans-unit id="dd21f8919461768eb8ff2a40d07d620042782584" translate="yes" xml:space="preserve">
          <source>Meteor 1.4.2.x or before: Android SDK Tools v.23 (&lt;a href=&quot;https://dl.google.com/android/repository/tools_r23.0.1-macosx.zip&quot;&gt;mac&lt;/a&gt;, &lt;a href=&quot;https://dl.google.com/android/repository/tools_r23.0.1-linux.zip&quot;&gt;linux&lt;/a&gt;, &lt;a href=&quot;https://dl.google.com/android/repository/tools_r23.0.1-windows.zip&quot;&gt;windows&lt;/a&gt;)</source>
          <target state="translated">Meteor 1.4.2.x 또는 이전 버전 : Android SDK Tools v.23 ( &lt;a href=&quot;https://dl.google.com/android/repository/tools_r23.0.1-macosx.zip&quot;&gt;mac&lt;/a&gt; , &lt;a href=&quot;https://dl.google.com/android/repository/tools_r23.0.1-linux.zip&quot;&gt;linux&lt;/a&gt; , &lt;a href=&quot;https://dl.google.com/android/repository/tools_r23.0.1-windows.zip&quot;&gt;windows&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="d1529c4bce36bb1d5933ec60cbe61f988b11d72e" translate="yes" xml:space="preserve">
          <source>Meteor 1.4.3.1 or later: Android SDK Tools v.25.&lt;strong&gt;2&lt;/strong&gt;.x (&lt;a href=&quot;https://dl.google.com/android/repository/tools_r25.2.3-macosx.zip&quot;&gt;mac&lt;/a&gt;, &lt;a href=&quot;https://dl.google.com/android/repository/tools_r25.2.3-linux.zip&quot;&gt;linux&lt;/a&gt;, &lt;a href=&quot;https://dl.google.com/android/repository/tools_r25.2.3-windows.zip&quot;&gt;windows&lt;/a&gt;) or v.26.0.0 or later</source>
          <target state="translated">Meteor 1.4.3.1 이상 : Android SDK 도구 v.25. &lt;strong&gt;2&lt;/strong&gt; .x ( &lt;a href=&quot;https://dl.google.com/android/repository/tools_r25.2.3-macosx.zip&quot;&gt;mac&lt;/a&gt; , &lt;a href=&quot;https://dl.google.com/android/repository/tools_r25.2.3-linux.zip&quot;&gt;linux&lt;/a&gt; , &lt;a href=&quot;https://dl.google.com/android/repository/tools_r25.2.3-windows.zip&quot;&gt;windows&lt;/a&gt; ) 또는 v.26.0.0 이상</target>
        </trans-unit>
        <trans-unit id="da5f26ed41e3c616d9aa6f3645aee3451bd6e0e7" translate="yes" xml:space="preserve">
          <source>Meteor &lt;strong&gt;embraces the ecosystem&lt;/strong&gt;, bringing the best parts of the extremely active JavaScript community to you in a careful and considered way.</source>
          <target state="translated">Meteor &lt;strong&gt;는 생태계를 수용하여&lt;/strong&gt; 매우 활동적인 JavaScript 커뮤니티의 가장 중요한 부분을 신중하고 신중하게 귀하에게 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1bfdb862eb1eada1f03b0722eb29cd6cbe5cd46e" translate="yes" xml:space="preserve">
          <source>Meteor Cordova integration</source>
          <target state="translated">Meteor Cordova 통합</target>
        </trans-unit>
        <trans-unit id="243d7f32de828a9d019240dd3674f1d15cc5e668" translate="yes" xml:space="preserve">
          <source>Meteor Developer Accounts with &lt;code&gt;accounts-meteor-developer&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;accounts-meteor-developer&lt;/code&gt; 가있는 Meteor 개발자 계정</target>
        </trans-unit>
        <trans-unit id="2cd12013f9adcc91d557160d0de5d4ab92d6c816" translate="yes" xml:space="preserve">
          <source>Meteor Documentation</source>
          <target state="translated">유성 문서</target>
        </trans-unit>
        <trans-unit id="a94d11ed4fe72db0b2bb1e32e5e23c8a0e9d1f5d" translate="yes" xml:space="preserve">
          <source>Meteor Methods have several features which aren&amp;rsquo;t immediately obvious, but every complex app will need them at some point. These features were added incrementally over several years in a backwards-compatible fashion, so unlocking the full capabilities of Methods requires a good amount of boilerplate. In this article we will first show you all of the code you need to write for each feature, then the next section will talk about a Method wrapper package we have developed to make it easier.</source>
          <target state="translated">Meteor Methods에는 몇 가지 특징이 있지만 즉시 알 수는 없지만 모든 복잡한 앱에는 어느 시점에서 필요합니다. 이러한 기능은 이전 버전과 호환되는 방식으로 몇 년 동안 점진적으로 추가되었으므로 Methods의 모든 기능을 사용하려면 상당한 양의 상용구가 필요합니다. 이 기사에서는 먼저 각 기능에 대해 작성해야하는 모든 코드를 보여주고 다음 섹션에서는보다 쉽게 ​​개발하기 위해 개발 한 Method wrapper 패키지에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ace5631ae5cf9280a9c77af56d8fc72f86ded554" translate="yes" xml:space="preserve">
          <source>Meteor Up</source>
          <target state="translated">유성</target>
        </trans-unit>
        <trans-unit id="3c130ee8434c0f82a7d473b654f9f0b47a1390be" translate="yes" xml:space="preserve">
          <source>Meteor Up has multiple projects so select what is best for your project:</source>
          <target state="translated">Meteor Up에는 여러 프로젝트가 있으므로 프로젝트에 가장 적합한 것을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="77d45d8ff2ea2e16619b146bafdc49ffe78788b4" translate="yes" xml:space="preserve">
          <source>Meteor Up, often referred to as &amp;ldquo;mupx&amp;rdquo; or &amp;ldquo;mup&amp;rdquo;, is a third-party open-source tool that can be used to deploy Meteor application to any online server over SSH. It handles some of the essential deployment requirements, but you will still need to do a lot of work to get your load balancing and version updates working smoothly. It&amp;rsquo;s essentially a way to automate the manual steps of using &lt;code&gt;meteor build&lt;/code&gt; and putting that bundle on your server.</source>
          <target state="translated">종종 &quot;mupx&quot;또는 &quot;mup&quot;이라고하는 Meteor Up은 SSH를 통해 온라인 서버에 Meteor 응용 프로그램을 배포하는 데 사용할 수있는 타사 오픈 소스 도구입니다. 필수 배포 요구 사항 중 일부를 처리하지만로드 균형 조정 및 버전 업데이트가 원활하게 작동하려면 많은 작업이 필요합니다. 기본적으로 &lt;code&gt;meteor build&lt;/code&gt; 를 사용 하고 해당 번들을 서버에 배치하는 수동 단계를 자동화하는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="b6f13051c054ac9f7467b0e0a532664b80df5de5" translate="yes" xml:space="preserve">
          <source>Meteor allows you to &lt;code&gt;import&lt;/code&gt; not only JavaScript in your application, but also CSS and HTML to control load order:</source>
          <target state="translated">Meteor를 사용하면 응용 프로그램에서 JavaScript뿐만 아니라 CSS 및 HTML을 &lt;code&gt;import&lt;/code&gt; 로드 순서를 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a5e16cea47484b003dd766bca5ab501c11f291d" translate="yes" xml:space="preserve">
          <source>Meteor allows you to develop in &lt;strong&gt;one language&lt;/strong&gt;, JavaScript, in all environments: application server, web browser, and mobile device.</source>
          <target state="translated">Meteor를 사용하면 응용 프로그램 서버, 웹 브라우저 및 모바일 장치와 같은 모든 환경에서 JavaScript, &lt;strong&gt;단일 언어&lt;/strong&gt; 로 개발할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="818fd0ab8ec03b9c48d5dd707aa628078e84574e" translate="yes" xml:space="preserve">
          <source>Meteor also has a special &amp;ldquo;insecure mode&amp;rdquo; for quickly prototyping new applications. In insecure mode, if you haven&amp;rsquo;t set up any &lt;code&gt;allow&lt;/code&gt; or &lt;code&gt;deny&lt;/code&gt; rules on a collection, then all users have full write access to the collection. This is the only effect of insecure mode. If you call &lt;code&gt;allow&lt;/code&gt; or &lt;code&gt;deny&lt;/code&gt; at all on a collection, even &lt;code&gt;Posts.allow({})&lt;/code&gt;, then access is checked just like normal on that collection. &lt;strong&gt;New Meteor projects start in insecure mode by default.&lt;/strong&gt; To turn it off just run in your terminal:</source>
          <target state="translated">Meteor에는 새로운 응용 프로그램을 신속하게 프로토 타이핑 할 수있는 특별한 &quot;비보안 모드&quot;도 있습니다. 안전하지 않은 모드에서 컬렉션에 &lt;code&gt;allow&lt;/code&gt; 또는 &lt;code&gt;deny&lt;/code&gt; 규칙을 설정하지 않으면 모든 사용자가 컬렉션에 대한 전체 쓰기 권한을 갖습니다. 이것이 안전하지 않은 모드의 유일한 효과입니다. 컬렉션, 심지어 &lt;code&gt;Posts.allow({})&lt;/code&gt; 에서 &lt;code&gt;allow&lt;/code&gt; 또는 전혀 &lt;code&gt;deny&lt;/code&gt; 를 호출 하면 해당 컬렉션에서 정상적으로 액세스가 확인됩니다. &lt;strong&gt;새로운 Meteor 프로젝트는 기본적으로 안전하지 않은 모드에서 시작됩니다. &lt;/strong&gt;끄려면 터미널에서 실행하십시오.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8e5aabeba695fa2a207c42c14faeb64ad2b9b8b5" translate="yes" xml:space="preserve">
          <source>Meteor also supports the standard ES2015 modules &lt;code&gt;export&lt;/code&gt; syntax:</source>
          <target state="translated">Meteor는 표준 ES2015 모듈 &lt;code&gt;export&lt;/code&gt; 구문 도 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="cda78c507086a6556c1ba2b2d33b8d52bc0ba8d3" translate="yes" xml:space="preserve">
          <source>Meteor and React</source>
          <target state="translated">유성과 반응</target>
        </trans-unit>
        <trans-unit id="5d2f38c1fb00234ee93eaddb350cd5a424b3ca41" translate="yes" xml:space="preserve">
          <source>Meteor code style</source>
          <target state="translated">유성 코드 스타일</target>
        </trans-unit>
        <trans-unit id="65870eadebb1f904b46844bb0111cf57c1fb2735" translate="yes" xml:space="preserve">
          <source>Meteor comes with a default MongoDB collection for user data. It&amp;rsquo;s stored in the database under the name &lt;code&gt;users&lt;/code&gt;, and is accessible in your code through &lt;code&gt;Meteor.users&lt;/code&gt;. The schema of a user document in this collection will depend on which login service was used to create the account. Here&amp;rsquo;s an example of a user that created their account with &lt;code&gt;accounts-password&lt;/code&gt;:</source>
          <target state="translated">Meteor는 사용자 데이터를위한 기본 MongoDB 콜렉션과 함께 제공됩니다. 그것은 &lt;code&gt;users&lt;/code&gt; 라는 이름으로 데이터베이스에 저장되며 &lt;code&gt;Meteor.users&lt;/code&gt; 를 통해 코드에서 액세스 할 수 있습니다 . 이 컬렉션의 사용자 문서 스키마는 계정을 만드는 데 사용 된 로그인 서비스에 따라 다릅니다. 다음은 &lt;code&gt;accounts-password&lt;/code&gt; 를 사용 하여 계정 을 만든 사용자의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="fe1f42393c72fc1bd41a5a35f99cc8385e5c5774" translate="yes" xml:space="preserve">
          <source>Meteor comes with a secure and fully-featured password login system out of the box. To use it, add the package:</source>
          <target state="translated">Meteor는 안전하고 완전한 기능을 갖춘 암호 로그인 시스템을 기본적으로 제공합니다. 사용하려면 패키지를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="ac8330eeb7bf7d085cea3343a0687067ebe39fc1" translate="yes" xml:space="preserve">
          <source>Meteor comes with npm bundled so that you can type &lt;code&gt;meteor npm&lt;/code&gt; without worrying about installing it yourself. If you like, you can also use a globally installed npm to manage your packages.</source>
          <target state="translated">Meteor에는 npm 번들이 제공되므로 &lt;code&gt;meteor npm&lt;/code&gt; 을 직접 설치할 필요없이 입력 할 수 있습니다 . 원하는 경우 전역으로 설치된 npm을 사용하여 패키지를 관리 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8de35b36912c0fe7b7a36db1bd4bd63acdd04730" translate="yes" xml:space="preserve">
          <source>Meteor comes with npm bundled so that you can type meteor npm without worrying about installing it yourself. If you like, you can also use a globally installed npm command.</source>
          <target state="translated">Meteor에는 npm 번들이 제공되므로 유성 npm을 직접 설치할 필요없이 입력 할 수 있습니다. 원하는 경우 전체적으로 설치된 npm 명령을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="622fb646d4fc620ba4099776436a3bf63a96d3a5" translate="yes" xml:space="preserve">
          <source>Meteor does not downgrade transitive dependencies unless it&amp;rsquo;s necessary. This means that if running &lt;code&gt;meteor add A&lt;/code&gt; upgrades A&amp;rsquo;s parent package X to a new version, your project will continue to use X at the new version even after you run &lt;code&gt;meteor remove A&lt;/code&gt;.</source>
          <target state="translated">Meteor는 필요한 경우가 아니면 전이 의존성을 다운 그레이드하지 않습니다. 이것은 &lt;code&gt;meteor add A&lt;/code&gt; 실행하면 A의 상위 패키지 X를 새 버전으로 업그레이드하는 경우 &lt;code&gt;meteor remove A&lt;/code&gt; 를 실행 한 후에도 프로젝트가 새 버전에서 X를 계속 사용 한다는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="cd40caf26a2846d8fbea4238ac3759079862fa82" translate="yes" xml:space="preserve">
          <source>Meteor gathers all your JavaScript files, excluding anything under the &lt;code&gt;client&lt;/code&gt;, &lt;code&gt;public&lt;/code&gt;, and &lt;code&gt;private&lt;/code&gt; subdirectories, and loads them into a Node.js server instance. In Meteor, your server code runs in a single thread per request, not in the asynchronous callback style typical of Node.</source>
          <target state="translated">Meteor는 &lt;code&gt;client&lt;/code&gt; , &lt;code&gt;public&lt;/code&gt; 및 &lt;code&gt;private&lt;/code&gt; 하위 디렉토리 아래를 제외한 모든 JavaScript 파일을 수집 하여 Node.js 서버 인스턴스에로드합니다. Meteor에서 서버 코드는 노드의 일반적인 비동기 콜백 스타일이 아닌 요청 당 단일 스레드로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="6581a00bac055c2176bd6f2f80efcc8bce406dbd" translate="yes" xml:space="preserve">
          <source>Meteor has a simple dependency tracking system which allows it to automatically rerun templates and other computations whenever &lt;a href=&quot;#session&quot;&gt;&lt;code&gt;Session&lt;/code&gt;&lt;/a&gt; variables, database queries, and other data sources change.</source>
          <target state="translated">Meteor에는 간단한 종속성 추적 시스템이있어 &lt;a href=&quot;#session&quot;&gt; &lt;code&gt;Session&lt;/code&gt; &lt;/a&gt; 변수, 데이터베이스 쿼리 및 기타 데이터 소스가 변경 될 때마다 템플릿 및 기타 계산을 자동으로 다시 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e8b5af5b5910144199c1f9b748072910d741067" translate="yes" xml:space="preserve">
          <source>Meteor has a test mode for packages called &lt;code&gt;meteor test-packages&lt;/code&gt;. If you are in a package&amp;rsquo;s directory, you can run</source>
          <target state="translated">Meteor에는 &lt;code&gt;meteor test-packages&lt;/code&gt; 패키지에 대한 테스트 모드가 있습니다. 패키지 디렉토리에 있다면 다음을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34c672dd3b48e4849e25b120306f2632a1d15d1f" translate="yes" xml:space="preserve">
          <source>Meteor implements a couple of compilers as Core packages, good examples would be the &lt;a href=&quot;https://github.com/meteor/meteor/tree/devel/packages/templating&quot;&gt;Blaze templating&lt;/a&gt; package and the &lt;a href=&quot;https://github.com/meteor/meteor/tree/devel/packages/ecmascript&quot;&gt;ecmascript&lt;/a&gt; package (compiles ES2015+ to JavaScript that can run in the browsers).</source>
          <target state="translated">Meteor는 몇 개의 컴파일러를 핵심 패키지로 구현합니다. &lt;a href=&quot;https://github.com/meteor/meteor/tree/devel/packages/templating&quot;&gt;Blaze 템플릿&lt;/a&gt; 패키지와 &lt;a href=&quot;https://github.com/meteor/meteor/tree/devel/packages/ecmascript&quot;&gt;ecmascript&lt;/a&gt; 패키지 (브라우저에서 실행할 수있는 ES2015 +를 JavaScript로 컴파일) 가 좋은 예입니다 .</target>
        </trans-unit>
        <trans-unit id="ae9d577a85a05f47b12654451a1c802401cb6cee" translate="yes" xml:space="preserve">
          <source>Meteor integrates with &lt;a href=&quot;https://cordova.apache.org&quot;&gt;Cordova&lt;/a&gt;, a well-known Apache open source project, to build mobile apps from the same codebase you use to create regular web apps. With the Cordova integration in Meteor, you can take your existing app and run it on an iOS or Android device with a few simple commands.</source>
          <target state="translated">Meteor 는 잘 알려진 Apache 오픈 소스 프로젝트 인 &lt;a href=&quot;https://cordova.apache.org&quot;&gt;Cordova&lt;/a&gt; 와 통합되어 일반 웹 앱을 만드는 데 사용하는 것과 동일한 코드베이스에서 모바일 앱을 빌드합니다. Meteor에서 Cordova 통합을 사용하면 몇 가지 간단한 명령으로 기존 앱을 iOS 또는 Android 기기에서 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2bbf64eab1a1cb0273969a1de5135824254b9af" translate="yes" xml:space="preserve">
          <source>Meteor introduces two new types of JavaScript errors: &lt;a href=&quot;http://docs.meteor.com/#/full/meteor_error&quot;&gt;&lt;code&gt;Meteor.Error&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://atmospherejs.com/mdg/validation-error&quot;&gt;&lt;code&gt;ValidationError&lt;/code&gt;&lt;/a&gt;. These and the regular JavaScript &lt;code&gt;Error&lt;/code&gt; type should be used in different situations:</source>
          <target state="translated">Meteor에는 두 가지 새로운 유형의 JavaScript 오류 인 &lt;a href=&quot;http://docs.meteor.com/#/full/meteor_error&quot;&gt; &lt;code&gt;Meteor.Error&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://atmospherejs.com/mdg/validation-error&quot;&gt; &lt;code&gt;ValidationError&lt;/code&gt; &lt;/a&gt; 가 도입되었습니다 . 이러한 상황과 일반적인 JavaScript &lt;code&gt;Error&lt;/code&gt; 유형은 다른 상황에서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="de77907e46004848291278b95b568cdd87126c78" translate="yes" xml:space="preserve">
          <source>Meteor is a &lt;em&gt;full-stack&lt;/em&gt; framework for building JavaScript applications. This means Meteor applications differ from most applications in that they include code that runs on the client, inside a web browser or Cordova mobile app, code that runs on the server, inside a &lt;a href=&quot;http://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; container, and &lt;em&gt;common&lt;/em&gt; code that runs in both environments. The &lt;a href=&quot;build-tool&quot;&gt;Meteor build tool&lt;/a&gt; allows you to easily specify what JavaScript code, including any supporting UI templates, CSS rules, and static assets, to run in each environment using a combination of ES2015 &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; and the Meteor build system &lt;a href=&quot;#load-order&quot;&gt;default file load order&lt;/a&gt; rules.</source>
          <target state="translated">Meteor는 JavaScript 애플리케이션을 구축하기위한 &lt;em&gt;풀 스택&lt;/em&gt; 프레임 워크입니다. 이는 Meteor 애플리케이션이 클라이언트, 웹 브라우저 또는 Cordova 모바일 앱 내부에서 실행 &lt;em&gt;되는&lt;/em&gt; 코드 , 서버에서 실행 &lt;em&gt;되는&lt;/em&gt; 코드 , &lt;a href=&quot;http://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; 컨테이너 내부 및 두 환경에서 실행되는 &lt;em&gt;공통&lt;/em&gt; 코드를 포함한다는 점에서 대부분의 애플리케이션과 다릅니다. . &lt;a href=&quot;build-tool&quot;&gt;유성 빌드 도구를&lt;/a&gt; 쉽게 ES2015의의 조합을 사용하여 각 환경에서 실행하기 위해 어떤 지원하는 UI 템플릿, CSS 규칙 및 고정 자산을 포함, 어떤 자바 스크립트 코드를 지정할 수 있습니다 &lt;code&gt;import&lt;/code&gt; 및 &lt;code&gt;export&lt;/code&gt; 과 유성 빌드 시스템 &lt;a href=&quot;#load-order&quot;&gt;기본 파일로드 순서의&lt;/a&gt; 규칙을.</target>
        </trans-unit>
        <trans-unit id="51edf72fa6d304993cf008cb8e2913d19d8454ce" translate="yes" xml:space="preserve">
          <source>Meteor is a full-stack JavaScript platform for developing modern web and mobile applications. Meteor includes a key set of technologies for building connected-client reactive applications, a build tool, and a curated set of packages from the Node.js and general JavaScript community.</source>
          <target state="translated">Meteor는 최신 웹 및 모바일 애플리케이션을 개발하기위한 풀 스택 JavaScript 플랫폼입니다. Meteor에는 연결된 클라이언트 반응 형 애플리케이션, 빌드 도구 및 Node.js 및 일반 JavaScript 커뮤니티의 선별 된 패키지 세트를 빌드하기위한 핵심 기술 세트가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf17e9b8b6003d5ca76c5189f826948a2610cad9" translate="yes" xml:space="preserve">
          <source>Meteor is an open source platform, and you can run the apps that you make with Meteor anywhere just like regular Node.js applications. But operating Meteor apps &lt;em&gt;correctly&lt;/em&gt;, so that your apps work for everyone, can be tricky if you are managing your infrastructure manually. This is why we recommend running production Meteor apps on Galaxy.</source>
          <target state="translated">Meteor는 오픈 소스 플랫폼이며 일반 Node.js 응용 프로그램처럼 어디서나 Meteor로 만든 앱을 실행할 수 있습니다. 그러나 인프라를 수동으로 관리하는 경우 모든 사람이 앱을 사용할 수 있도록 Meteor 앱을 &lt;em&gt;올바르게&lt;/em&gt; 운영 하는 것은 까다로울 수 있습니다. 이것이 Galaxy에서 프로덕션 Meteor 앱을 실행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="96caf87214977232d7aebb2b24e1cc114e10ce2a" translate="yes" xml:space="preserve">
          <source>Meteor is built from the ground up on the Distributed Data Protocol (DDP) to allow data transfer in both directions. Building a Meteor app doesn&amp;rsquo;t require you to set up REST endpoints to serialize and send data. Instead you create &lt;em&gt;publication&lt;/em&gt; endpoints that can push data from server to client.</source>
          <target state="translated">Meteor는 DDP (Distributed Data Protocol)를 기반으로 구축되어 양방향으로 데이터를 전송할 수 있습니다. Meteor 앱을 구축 할 때 데이터를 직렬화하고 전송하기 위해 REST 엔드 포인트를 설정할 필요가 없습니다. 대신 서버에서 클라이언트로 데이터를 푸시 할 수있는 &lt;em&gt;게시&lt;/em&gt; 끝점을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="5bf9e464d9aa4352e16c8429850f8877bb399bd2" translate="yes" xml:space="preserve">
          <source>Meteor methods and publish functions can take arbitrary &lt;a href=&quot;#ejson&quot;&gt;EJSON&lt;/a&gt; types as arguments, but most functions expect their arguments to be of a particular type. &lt;code&gt;check&lt;/code&gt; is a lightweight function for checking that arguments and other values are of the expected type. For example:</source>
          <target state="translated">유성 메서드 및 게시 함수는 임의의 &lt;a href=&quot;#ejson&quot;&gt;EJSON&lt;/a&gt; 형식을 인수로 사용할 수 있지만 대부분의 함수는 해당 인수가 특정 형식 일 것으로 예상합니다. &lt;code&gt;check&lt;/code&gt; 는 인수 및 기타 값이 예상되는 유형인지 확인하기위한 간단한 기능입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5663c316e8ce97f460dde562bca82c3b321315ff" translate="yes" xml:space="preserve">
          <source>Meteor officially supports three user interface (UI) rendering libraries, &lt;a href=&quot;blaze&quot;&gt;Blaze&lt;/a&gt;, &lt;a href=&quot;react&quot;&gt;React&lt;/a&gt; and &lt;a href=&quot;http://www.angular-meteor.com&quot;&gt;Angular&lt;/a&gt;. Blaze was created as part of Meteor when it launched in 2011, React was created by Facebook in 2013, and Angular was created by Google in 2010. All three have been used successfully by large production apps. Blaze is the easiest to learn and has the most full-stack Meteor packages, but React and Angular are more developed and have larger communities.</source>
          <target state="translated">Meteor는 공식적으로 &lt;a href=&quot;blaze&quot;&gt;Blaze&lt;/a&gt; , &lt;a href=&quot;react&quot;&gt;React&lt;/a&gt; 및 &lt;a href=&quot;http://www.angular-meteor.com&quot;&gt;Angular의&lt;/a&gt; 3 가지 UI 렌더링 라이브러리를 지원합니다 . Blaze는 2011 년에 출시되었을 때 Meteor의 일부로 만들어졌으며, React는 2013 년에 Facebook으로, Angular는 2010 년에 Google에서 만들었습니다.이 세 가지 모두 대규모 프로덕션 앱에서 성공적으로 사용되었습니다. Blaze는 배우기가 가장 쉽고 풀스 택형 Meteor 패키지가 가장 많지만 React와 Angular는 더 개발되어 더 큰 커뮤니티를 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="f28e547125663964d5541f6a226999ebfb2a6daf" translate="yes" xml:space="preserve">
          <source>Meteor packages can also depend on plugins downloaded from Git:</source>
          <target state="translated">Meteor 패키지는 Git에서 다운로드 한 플러그인에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7077d19db8fe997f3430dce2bb21eea1390e9abd" translate="yes" xml:space="preserve">
          <source>Meteor packages can also depend on plugins installed from the local file system, although this probably only makes sense for local packages:</source>
          <target state="translated">Meteor 패키지는 로컬 파일 시스템에서 설치된 플러그인에 의존 할 수도 있지만 로컬 패키지에만 적합합니다.</target>
        </trans-unit>
        <trans-unit id="bdf4cbe607e00159702181bc49b119f054ac4169" translate="yes" xml:space="preserve">
          <source>Meteor packages can include &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm packages&lt;/a&gt; to use JavaScript code from outside the Meteor package ecosystem or to include JavaScript code with native dependencies. Use &lt;a href=&quot;http://docs.meteor.com/#/full/Npm-depends&quot;&gt;Npm.depends&lt;/a&gt; at the top level of your &lt;code&gt;package.js&lt;/code&gt; file. For example, here&amp;rsquo;s how you would include the &lt;code&gt;github&lt;/code&gt; npm package:</source>
          <target state="translated">Meteor 패키지에는 &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; 패키지가 포함 되어 Meteor 패키지 에코 시스템 외부에서 JavaScript 코드를 사용하거나 고유 종속성이있는 JavaScript 코드를 포함 할 수 있습니다. &lt;code&gt;package.js&lt;/code&gt; 파일 의 최상위 레벨에서 &lt;a href=&quot;http://docs.meteor.com/#/full/Npm-depends&quot;&gt;Npm.depends&lt;/a&gt; 를 사용하십시오 . 예를 들어, 다음은 &lt;code&gt;github&lt;/code&gt; npm 패키지를 포함하는 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="2d679b0fb2f845898bff4caa571974dfc4cc8a3c" translate="yes" xml:space="preserve">
          <source>Meteor packages can include NPM packages and Cordova plugins by using &lt;code&gt;Npm.depends&lt;/code&gt; and &lt;code&gt;Cordova.depends&lt;/code&gt; in the &lt;code&gt;package.js&lt;/code&gt; file.</source>
          <target state="translated">Meteor 패키지는 &lt;code&gt;package.js&lt;/code&gt; 파일 에서 &lt;code&gt;Npm.depends&lt;/code&gt; 및 &lt;code&gt;Cordova.depends&lt;/code&gt; 를 사용하여 NPM 패키지 및 Cordova 플러그인을 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="09e6ba951b93be1b2a299362c4d4b9cb62fef2ad" translate="yes" xml:space="preserve">
          <source>Meteor packages can provide build plugins - programs that integrate with the build tool Isobuild used to compile and bundle your application.</source>
          <target state="translated">Meteor 패키지는 빌드 플러그인을 제공 할 수 있습니다-프로그램 컴파일 및 번들링에 사용되는 빌드 도구 Isobuild와 통합되는 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="c1bdd06e18dbd9296aa1ba3318bfb440a5026638" translate="yes" xml:space="preserve">
          <source>Meteor packages that this plugin uses, independent of the packages specified in &lt;a href=&quot;#pack_onUse&quot;&gt;api.onUse&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#pack_onUse&quot;&gt;api.onUse에&lt;/a&gt; 지정된 패키지와 상관없이이 플러그인이 사용하는 Meteor 패키지 .</target>
        </trans-unit>
        <trans-unit id="e25684491469c9f03cbfa6207259e67da6e24280" translate="yes" xml:space="preserve">
          <source>Meteor provides &lt;strong&gt;full stack reactivity&lt;/strong&gt;, allowing your UI to seamlessly reflect the true state of the world with minimal development effort.</source>
          <target state="translated">Meteor는 &lt;strong&gt;완전한 스택 반응성을&lt;/strong&gt; 제공 하므로 최소한의 개발 노력으로 UI가 실제 상태를 완벽하게 반영 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d65bc85012972d54322447846f125d4d5a67100e" translate="yes" xml:space="preserve">
          <source>Meteor reads a &lt;a href=&quot;http://docs.meteor.com/api/mobile-config.html&quot;&gt;&lt;code&gt;mobile-config.js&lt;/code&gt;&lt;/a&gt; file in the root of your app directory during build, and uses the settings specified there to generate Cordova&amp;rsquo;s &lt;a href=&quot;https://cordova.apache.org/docs/en/dev/config_ref/index.html&quot;&gt;&lt;code&gt;config.xml&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Meteor는 빌드 중에 앱 디렉토리의 루트에서 &lt;a href=&quot;http://docs.meteor.com/api/mobile-config.html&quot;&gt; &lt;code&gt;mobile-config.js&lt;/code&gt; &lt;/a&gt; 파일을 읽고 여기에 지정된 설정을 사용하여 Cordova의 &lt;a href=&quot;https://cordova.apache.org/docs/en/dev/config_ref/index.html&quot;&gt; &lt;code&gt;config.xml&lt;/code&gt; &lt;/a&gt; 을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="6511c3efed7f3caaabd83d68361e0a813a362fd9" translate="yes" xml:space="preserve">
          <source>Meteor releases are divided into tracks. While only MDG members can publish to the default Meteor track, anyone can create a track of their own and publish to it. Running &lt;code&gt;meteor update&lt;/code&gt; without specifying the &lt;code&gt;--release&lt;/code&gt; option will not cause the user to switch tracks.</source>
          <target state="translated">유성 릴리스는 트랙으로 나뉩니다. MDG 회원 만 기본 Meteor 트랙에 게시 할 수 있지만 누구나 자신의 트랙을 만들어 게시 할 수 있습니다. &lt;code&gt;--release&lt;/code&gt; 옵션 을 지정하지 않고 &lt;code&gt;meteor update&lt;/code&gt; 를 실행 하면 사용자가 트랙을 전환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a58b4455aee0385024d8fc645bf4a00b41318c7" translate="yes" xml:space="preserve">
          <source>Meteor resources</source>
          <target state="translated">유성 자원</target>
        </trans-unit>
        <trans-unit id="bcff1bfda93f22e8cff6cb981d9efe91fa193399" translate="yes" xml:space="preserve">
          <source>Meteor stores data in &lt;em&gt;collections&lt;/em&gt;. To get started, declare a collection with &lt;code&gt;new Mongo.Collection&lt;/code&gt;.</source>
          <target state="translated">Meteor는 데이터를 &lt;em&gt;수집에&lt;/em&gt; 저장합니다 . 시작하려면 &lt;code&gt;new Mongo.Collection&lt;/code&gt; 으로 컬렉션을 선언하십시오 .</target>
        </trans-unit>
        <trans-unit id="671497c52a053216f31c850cc2fae3ce817f1a74" translate="yes" xml:space="preserve">
          <source>Meteor supports &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;&lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt;&lt;/a&gt;, which provide a straightforward approach to asynchronously wait for the module to be ready without the need to provide a callback:</source>
          <target state="translated">Meteor는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt; &lt;code&gt;async&lt;/code&gt; 및 &lt;code&gt;await&lt;/code&gt; &lt;/a&gt; 를 지원하여 콜백을 제공 할 필요없이 모듈이 준비 될 때까지 비동기식으로 대기하는 간단한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="82b0c6e9fee08d7d3e163629dd1571bc7b693ba1" translate="yes" xml:space="preserve">
          <source>Meteor supports &lt;a href=&quot;https://www.meteor.com/install&quot;&gt;OS X, Windows, and Linux&lt;/a&gt;.</source>
          <target state="translated">Meteor는 &lt;a href=&quot;https://www.meteor.com/install&quot;&gt;OS X, Windows 및 Linux를&lt;/a&gt; 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="8646d034a0e9c771564258a5cde50fca9007a59a" translate="yes" xml:space="preserve">
          <source>Meteor supports all built-in EJSON data types in publishers, method arguments and results, Mongo databases, and &lt;a href=&quot;#session&quot;&gt;&lt;code&gt;Session&lt;/code&gt;&lt;/a&gt; variables.</source>
          <target state="translated">Meteor는 게시자, 메소드 인수 및 결과, Mongo 데이터베이스 및 &lt;a href=&quot;#session&quot;&gt; &lt;code&gt;Session&lt;/code&gt; &lt;/a&gt; 변수의 모든 내장 EJSON 데이터 유형을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="e644c60aa896d13c6207e6898170e1a196b3d5a2" translate="yes" xml:space="preserve">
          <source>Meteor supports hot code push on both browser and mobile clients, but the process on mobile is a bit different. In a browser, reloading the app will re-request assets from the server, and the server will respond with the most recent versions. Because Cordova apps rely on locally stored assets however, hot code push on mobile is a two step process:</source>
          <target state="translated">Meteor는 브라우저와 모바일 클라이언트 모두에서 핫 코드 푸시를 지원하지만 모바일 프로세스는 약간 다릅니다. 브라우저에서 앱을 다시로드하면 서버에서 자산을 다시 요청하고 서버는 최신 버전으로 응답합니다. 그러나 Cordova 앱은 로컬로 저장된 자산에 의존하기 때문에 모바일에서 핫 코드 푸시는 2 단계 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="c3aec489fa142ac02b682826632843eb77923a0b" translate="yes" xml:space="preserve">
          <source>Meteor tracks the database writes performed by methods, both on the client and the server, and does not invoke &lt;code&gt;asyncCallback&lt;/code&gt; until all of the server&amp;rsquo;s writes replace the stub&amp;rsquo;s writes in the local cache. In some cases, there can be a lag between the method&amp;rsquo;s return value being available and the writes being visible: for example, if another method still outstanding wrote to the same document, the local cache may not be up to date until the other method finishes as well. If you want to process the method&amp;rsquo;s result as soon as it arrives from the server, even if the method&amp;rsquo;s writes are not available yet, you can specify an &lt;code&gt;onResultReceived&lt;/code&gt; callback to &lt;a href=&quot;#meteor_apply&quot;&gt;&lt;code&gt;Meteor.apply&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Meteor는 클라이언트와 서버 모두에서 메소드가 수행 한 데이터베이스 쓰기를 추적하고 모든 서버 쓰기가 로컬 캐시의 스텁 쓰기를 대체 할 때까지 &lt;code&gt;asyncCallback&lt;/code&gt; 을 호출하지 않습니다 . 경우에 따라 사용 가능한 메소드의 반환 값과 표시되는 내용 사이에 지연이있을 수 있습니다. 예를 들어, 다른 메소드가 여전히 동일한 문서에 기록 된 경우 다른 메소드가 완료 될 때까지 로컬 캐시가 최신 상태가 아닐 수 있습니다. 게다가. 서버에서 도착하자마자 메소드 결과를 처리하려면 메소드의 쓰기를 아직 사용할 수없는 경우에도 &lt;a href=&quot;#meteor_apply&quot;&gt; &lt;code&gt;Meteor.apply&lt;/code&gt; 에&lt;/a&gt; &lt;code&gt;onResultReceived&lt;/code&gt; 콜백을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f31fc630a33738a8f1baff2cd0d6c9cb5fe8460f" translate="yes" xml:space="preserve">
          <source>Meteor uses &lt;strong&gt;data on the wire&lt;/strong&gt;, meaning the server sends data, not HTML, and the client renders it.</source>
          <target state="translated">Meteor는 &lt;strong&gt;유선상의 데이터를&lt;/strong&gt; 사용 &lt;strong&gt;합니다.&lt;/strong&gt; 즉, 서버는 HTML이 아닌 데이터를 전송하고 클라이언트는이를 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="eddf000e5c12d8489ce3a16f29274bcb4fa097d9" translate="yes" xml:space="preserve">
          <source>Meteor uses WKWebView by default, on both iOS 8 and iOS 9. WKWebView is part of the modern WebKit API introduced in iOS 8, and replaces UIWebView, which has been in iOS from the beginning. Its main benefit is that it runs in a separate process, allowing for much higher JavaScript performance (3&amp;ndash;4x in some benchmarks!) because it can take advantage of Just-In-Time compilation (which UIWebView, running in the same process as your app, cannot do for security reasons).</source>
          <target state="translated">Meteor는 iOS 8과 iOS 9 모두에서 기본적으로 WKWebView를 사용합니다. WKWebView는 iOS 8에 도입 된 최신 WebKit API의 일부이며 처음부터 iOS에 있었던 UIWebView를 대체합니다. 주요 이점은 별도의 프로세스에서 실행되어 Just-In-Time 컴파일 (UIWebView와 동일한 프로세스에서 실행되는 UIWebView)을 활용할 수 있기 때문에 JavaScript 성능 (일부 벤치 마크에서는 3 ~ 4 배)을 훨씬 높일 수 있다는 것입니다. 보안상의 이유로 할 수 없습니다).</target>
        </trans-unit>
        <trans-unit id="c67fb04e65af57e0942f1c6e9f69d0780976afc2" translate="yes" xml:space="preserve">
          <source>Meteor uses global environment variables to keep track of things like the current request&amp;rsquo;s user. To make sure these variables have the right values, you need to use &lt;code&gt;Meteor.setTimeout&lt;/code&gt; instead of &lt;code&gt;setTimeout&lt;/code&gt; and &lt;code&gt;Meteor.setInterval&lt;/code&gt; instead of &lt;code&gt;setInterval&lt;/code&gt;.</source>
          <target state="translated">Meteor는 전역 환경 변수를 사용하여 현재 요청 사용자와 같은 것을 추적합니다. 하려면 반드시 이러한 변수는 사용할 필요가 오른쪽 값이 &lt;code&gt;Meteor.setTimeout&lt;/code&gt; 대신 &lt;code&gt;setTimeout&lt;/code&gt; 과 &lt;code&gt;Meteor.setInterval&lt;/code&gt; 대신 &lt;code&gt;setInterval&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="807920c1371b318801a7af6bdc5d02f77b93ffc1" translate="yes" xml:space="preserve">
          <source>Meteor will emit a warning message if you call &lt;code&gt;Meteor.publish&lt;/code&gt; in a project that includes the &lt;code&gt;autopublish&lt;/code&gt; package. Your publish function will still work.</source>
          <target state="translated">&lt;code&gt;autopublish&lt;/code&gt; 패키지 가 포함 된 프로젝트에서 &lt;code&gt;Meteor.publish&lt;/code&gt; 를 호출하면 Meteor에서 경고 메시지를 표시 합니다. 게시 기능이 계속 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8119116d05b89e0fbaeffbd333b61e6f70dd0faf" translate="yes" xml:space="preserve">
          <source>Meteor will load all files outside of any directory named &lt;code&gt;imports/&lt;/code&gt; in the application using the &lt;a href=&quot;#load-order&quot;&gt;default file load order&lt;/a&gt; rules (also called &amp;ldquo;eager evaluation or loading&amp;rdquo;). It is recommended that you create exactly two eagerly loaded files, &lt;code&gt;client/main.js&lt;/code&gt; and &lt;code&gt;server/main.js&lt;/code&gt;, in order to define explicit entry points for both the client and the server. Meteor ensures that any file in any directory named &lt;code&gt;server/&lt;/code&gt; will only be available on the server, and likewise for files in any directory named &lt;code&gt;client/&lt;/code&gt;. This also precludes trying to &lt;code&gt;import&lt;/code&gt; a file to be used on the server from any directory named &lt;code&gt;client/&lt;/code&gt; even if it is nested in an &lt;code&gt;imports/&lt;/code&gt; directory and vice versa for importing client files from &lt;code&gt;server/&lt;/code&gt;.</source>
          <target state="translated">Meteor는 &lt;a href=&quot;#load-order&quot;&gt;기본 파일로드 순서&lt;/a&gt; 규칙 ( &quot;열심 한 평가 또는로드&quot;라고도 함)을 사용하여 응용 프로그램에서 &lt;code&gt;imports/&lt;/code&gt; 라는 디렉토리 외부의 모든 파일을로드합니다 . &lt;code&gt;client/main.js&lt;/code&gt; 와 &lt;code&gt;server/main.js&lt;/code&gt; 모두에 대한 명확한 진입 점을 정의하기 위해 정확하게로드 된 두 개의 파일 client / main.js 및 server / main.js 를 작성하는 것이 좋습니다 . Meteor는 &lt;code&gt;server/&lt;/code&gt; 라는 디렉토리에있는 모든 파일이 서버 에서만 사용 가능하며 &lt;code&gt;client/&lt;/code&gt; 디렉토리에있는 모든 파일에서도 사용할 수 있도록합니다 . 또한 &lt;code&gt;client/&lt;/code&gt; 라는 디렉토리에 서버 에 중첩되어 있어도 서버에서 사용할 파일 을 &lt;code&gt;import&lt;/code&gt; 것을 금지 합니다. &lt;code&gt;imports/&lt;/code&gt; &lt;code&gt;server/&lt;/code&gt; 에서 클라이언트 파일을 가져 오는 경우 imports / 디렉토리 및 그 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="b6829e9613e070e75617b5ccb27a68d37a423231" translate="yes" xml:space="preserve">
          <source>Meteor&amp;rsquo;s accounts system, as implemented in &lt;code&gt;accounts-base&lt;/code&gt;, also includes a database collection and generic functions for getting data about users.</source>
          <target state="translated">&lt;code&gt;accounts-base&lt;/code&gt; 에 구현 된 Meteor의 계정 시스템 에는 사용자에 대한 데이터를 가져 오기위한 데이터베이스 기능 및 일반 기능도 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="08c6f3fa20a8415ad65b0f5c79ead6da92588e69" translate="yes" xml:space="preserve">
          <source>Meteor&amp;rsquo;s package system relies heavily on &lt;a href=&quot;http://semver.org/&quot;&gt;Semantic Versioning&lt;/a&gt;, or SemVer. When one package declares a dependency on another, it always comes with a version constraint. These version constraints are then solved by Meteor&amp;rsquo;s industrial-grade Version Solver to arrive at a set of package versions that meet all of the requirements, or display a helpful error if there is no solution.</source>
          <target state="translated">Meteor의 패키지 시스템은 &lt;a href=&quot;http://semver.org/&quot;&gt;Semantic Versioning&lt;/a&gt; 또는 SemVer 에 크게 의존합니다 . 한 패키지가 다른 패키지에 대한 종속성을 선언하면 항상 버전 제약 조건이 따릅니다. 이러한 버전 제약 조건은 Meteor의 산업 등급 Version Solver에 의해 해결되어 모든 요구 사항을 충족하는 패키지 버전 세트에 도달하거나 솔루션이없는 경우 유용한 오류를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="af0362ea71023af3e615464c8f037487143585e4" translate="yes" xml:space="preserve">
          <source>Meteor.Error for general runtime errors</source>
          <target state="translated">일반적인 런타임 오류에 대한 Meteor.Error</target>
        </trans-unit>
        <trans-unit id="4aadc3fc5b546a289dad2f0693f7b66e72441cc5" translate="yes" xml:space="preserve">
          <source>Meteor.Error()</source>
          <target state="translated">Meteor.Error()</target>
        </trans-unit>
        <trans-unit id="d4cc1e7ed1b973f97dd6714895ce83c51675ced2" translate="yes" xml:space="preserve">
          <source>Meteor.absoluteUrl()</source>
          <target state="translated">Meteor.absoluteUrl()</target>
        </trans-unit>
        <trans-unit id="0d8773377cda7d8a99cb875093b32741009b0ca4" translate="yes" xml:space="preserve">
          <source>Meteor.apply()</source>
          <target state="translated">Meteor.apply()</target>
        </trans-unit>
        <trans-unit id="77dad143857566d01a653381fbb8d025e549ad3c" translate="yes" xml:space="preserve">
          <source>Meteor.call()</source>
          <target state="translated">Meteor.call()</target>
        </trans-unit>
        <trans-unit id="0939c90d1f7dd43c8654524f3f5c33400573a1bd" translate="yes" xml:space="preserve">
          <source>Meteor.clearInterval()</source>
          <target state="translated">Meteor.clearInterval()</target>
        </trans-unit>
        <trans-unit id="c237c633cb43c07eee5b60f480864de2f1d97899" translate="yes" xml:space="preserve">
          <source>Meteor.clearTimeout()</source>
          <target state="translated">Meteor.clearTimeout()</target>
        </trans-unit>
        <trans-unit id="7e07ea9e9425fb47f6bc102e2a17e349bc70455f" translate="yes" xml:space="preserve">
          <source>Meteor.defer()</source>
          <target state="translated">Meteor.defer()</target>
        </trans-unit>
        <trans-unit id="8fc572e07173895dbea5891f0d979f9e387f680b" translate="yes" xml:space="preserve">
          <source>Meteor.disconnect()</source>
          <target state="translated">Meteor.disconnect()</target>
        </trans-unit>
        <trans-unit id="561f405850c385bce5b2df81da1807aeed2aaa67" translate="yes" xml:space="preserve">
          <source>Meteor.isClient</source>
          <target state="translated">Meteor.isClient</target>
        </trans-unit>
        <trans-unit id="ae034b221300628241c91a1f26acfd358aaab4d7" translate="yes" xml:space="preserve">
          <source>Meteor.isCordova</source>
          <target state="translated">Meteor.isCordova</target>
        </trans-unit>
        <trans-unit id="3942ec8d6ecd3d0b6937b7104aae67dea924f411" translate="yes" xml:space="preserve">
          <source>Meteor.isDevelopment</source>
          <target state="translated">Meteor.isDevelopment</target>
        </trans-unit>
        <trans-unit id="5a82fc98812d1aa942b6fb563821412553a06334" translate="yes" xml:space="preserve">
          <source>Meteor.isProduction</source>
          <target state="translated">Meteor.isProduction</target>
        </trans-unit>
        <trans-unit id="a6bbc79e7d7dc097558d3c953b18e6a076540d20" translate="yes" xml:space="preserve">
          <source>Meteor.isServer</source>
          <target state="translated">Meteor.isServer</target>
        </trans-unit>
        <trans-unit id="6d7458ce16fd2ffb534430ce85a633fa579c0762" translate="yes" xml:space="preserve">
          <source>Meteor.loggingIn()</source>
          <target state="translated">Meteor.loggingIn()</target>
        </trans-unit>
        <trans-unit id="e2113779a4855fb021df229c053eac1ea2561724" translate="yes" xml:space="preserve">
          <source>Meteor.loginWith&amp;lt;ExternalService&amp;gt;()</source>
          <target state="translated">Meteor.loginWith&amp;lt;ExternalService&amp;gt;()</target>
        </trans-unit>
        <trans-unit id="e1a14c40ea7ded5931f7942e186aee3207bf8c5f" translate="yes" xml:space="preserve">
          <source>Meteor.loginWithPassword()</source>
          <target state="translated">Meteor.loginWithPassword()</target>
        </trans-unit>
        <trans-unit id="e344707515a186f9974ebcb912fe7c662420252a" translate="yes" xml:space="preserve">
          <source>Meteor.logout()</source>
          <target state="translated">Meteor.logout()</target>
        </trans-unit>
        <trans-unit id="3a714634c44fa5d73a29e5df69bda19b241a7f79" translate="yes" xml:space="preserve">
          <source>Meteor.logoutOtherClients()</source>
          <target state="translated">Meteor.logoutOtherClients()</target>
        </trans-unit>
        <trans-unit id="e75691cc5f35d016e0cd07c5c5d528f7a1617966" translate="yes" xml:space="preserve">
          <source>Meteor.methods()</source>
          <target state="translated">Meteor.methods()</target>
        </trans-unit>
        <trans-unit id="900b1430563c5681e21cfe8770d26c75a9392406" translate="yes" xml:space="preserve">
          <source>Meteor.onConnection()</source>
          <target state="translated">Meteor.onConnection()</target>
        </trans-unit>
        <trans-unit id="fb0079d862912ab78cf8c5163fe37f8a60885bf1" translate="yes" xml:space="preserve">
          <source>Meteor.publish()</source>
          <target state="translated">Meteor.publish()</target>
        </trans-unit>
        <trans-unit id="d99872c9f02080c0aae3377dde058fc8f6d2889a" translate="yes" xml:space="preserve">
          <source>Meteor.reconnect()</source>
          <target state="translated">Meteor.reconnect()</target>
        </trans-unit>
        <trans-unit id="64dd1fa0e20e44a1fb38600980f9b0d37c1cd709" translate="yes" xml:space="preserve">
          <source>Meteor.release</source>
          <target state="translated">Meteor.release</target>
        </trans-unit>
        <trans-unit id="e64925f5a980a2252e298baed01b37aaa61465ff" translate="yes" xml:space="preserve">
          <source>Meteor.setInterval()</source>
          <target state="translated">Meteor.setInterval()</target>
        </trans-unit>
        <trans-unit id="815694ee82ceecd72d9e93ab60fae2eedd1a0c6e" translate="yes" xml:space="preserve">
          <source>Meteor.setTimeout()</source>
          <target state="translated">Meteor.setTimeout()</target>
        </trans-unit>
        <trans-unit id="ba2102fbf82f103db1da7582866ed3ada03dc121" translate="yes" xml:space="preserve">
          <source>Meteor.settings</source>
          <target state="translated">Meteor.settings</target>
        </trans-unit>
        <trans-unit id="2d4b8695404782424e7b3c2f3f61129f3a958c49" translate="yes" xml:space="preserve">
          <source>Meteor.startup()</source>
          <target state="translated">Meteor.startup()</target>
        </trans-unit>
        <trans-unit id="a61e3207119d6f273986a69802bd7fe15ae58f8d" translate="yes" xml:space="preserve">
          <source>Meteor.status()</source>
          <target state="translated">Meteor.status()</target>
        </trans-unit>
        <trans-unit id="77464e4fc05769aabd6e39abbc88d173567bd689" translate="yes" xml:space="preserve">
          <source>Meteor.subscribe()</source>
          <target state="translated">Meteor.subscribe()</target>
        </trans-unit>
        <trans-unit id="7deff7923efc426b5111ec4f7c8a82969854f577" translate="yes" xml:space="preserve">
          <source>Meteor.user()</source>
          <target state="translated">Meteor.user()</target>
        </trans-unit>
        <trans-unit id="63e289df9644b4b356504bb7e26d3e2f6cd38704" translate="yes" xml:space="preserve">
          <source>Meteor.userId()</source>
          <target state="translated">Meteor.userId()</target>
        </trans-unit>
        <trans-unit id="36595238e1b0a055672957d3d82c24e43ee546a8" translate="yes" xml:space="preserve">
          <source>Meteor.users</source>
          <target state="translated">Meteor.users</target>
        </trans-unit>
        <trans-unit id="bc5a36619b50e1d38c2d24124df237c51a7ad136" translate="yes" xml:space="preserve">
          <source>Meteor.wrapAsync()</source>
          <target state="translated">Meteor.wrapAsync()</target>
        </trans-unit>
        <trans-unit id="5bbe6124b80ed6bbe9b9bb1bd6b9cb332918a336" translate="yes" xml:space="preserve">
          <source>Method and publication names should be camelCased, and namespaced to the module they are in:</source>
          <target state="translated">메서드 및 게시 이름은 camelCased 여야하며 다음과 같은 모듈의 네임 스페이스로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="18754adb324b714a265e93bb8a9892892ff9ee0a" translate="yes" xml:space="preserve">
          <source>Method arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="622bbe9f33bc995ded33a1832ef7920b26b24a56" translate="yes" xml:space="preserve">
          <source>Method call lifecycle</source>
          <target state="translated">메소드 호출 라이프 사이클</target>
        </trans-unit>
        <trans-unit id="f071fb1667befe69dfec18039004040034de7107" translate="yes" xml:space="preserve">
          <source>Method retries</source>
          <target state="translated">재시도 방법</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="d750257e6d0b55cfcf2687b67ae92d5cc4894132" translate="yes" xml:space="preserve">
          <source>Methods always run and return in order</source>
          <target state="translated">메소드는 항상 순서대로 실행되고 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="16415baf3677dc9253511aa3b73013aaa2707cf0" translate="yes" xml:space="preserve">
          <source>Methods and publications</source>
          <target state="translated">방법과 출판물</target>
        </trans-unit>
        <trans-unit id="a866114a75b2af0c0a38c76418558d7e8e1339b4" translate="yes" xml:space="preserve">
          <source>Methods and publish functions that do not need to validate their arguments can simply run &lt;code&gt;check(arguments, [Match.Any])&lt;/code&gt; to satisfy the &lt;code&gt;audit-argument-checks&lt;/code&gt; coverage checker.</source>
          <target state="translated">인수의 유효성을 검증 할 필요가없는 메소드 및 공개 함수는 단순히 &lt;code&gt;check(arguments, [Match.Any])&lt;/code&gt; &lt;code&gt;audit-argument-checks&lt;/code&gt; 적용 범위 검사기 를 만족시키기 위해 check (arguments, [Match.Any]) 를 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="508d1301350f0abb3ae65e31982d83b9ca4d5c67" translate="yes" xml:space="preserve">
          <source>Methods are Meteor&amp;rsquo;s remote procedure call (RPC) system, used to save user input events and data that come from the client. If you&amp;rsquo;re familiar with REST APIs or HTTP, you can think of them like POST requests to your server, but with many nice features optimized for building a modern web application. Later on in this article, we&amp;rsquo;ll go into detail about some of the benefits you get from Methods that you wouldn&amp;rsquo;t get from an HTTP endpoint.</source>
          <target state="translated">메소드는 Meteor의 RPC (Remote Procedure Call) 시스템으로, 클라이언트에서 오는 사용자 입력 이벤트 및 데이터를 저장하는 데 사용됩니다. REST API 또는 HTTP에 익숙하다면 서버에 대한 POST 요청처럼 생각할 수 있지만 최신 웹 애플리케이션을 빌드하기 위해 최적화 된 많은 멋진 기능이 있습니다. 이 기사의 뒷부분에서 HTTP 엔드 포인트에서 얻을 수없는 메소드에서 얻을 수있는 몇 가지 이점에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="061098e399b34cdada88994d6cbcfc4b02827458" translate="yes" xml:space="preserve">
          <source>Methods are remote functions that Meteor clients can invoke with &lt;a href=&quot;#Meteor-call&quot;&gt;&lt;code&gt;Meteor.call&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">메소드는 Meteor 클라이언트가 &lt;a href=&quot;#Meteor-call&quot;&gt; &lt;code&gt;Meteor.call&lt;/code&gt; 로&lt;/a&gt; 호출 할 수있는 원격 기능입니다 .</target>
        </trans-unit>
        <trans-unit id="fb280178f7d6e3321a3a09a78e9ece3f0a79a21d" translate="yes" xml:space="preserve">
          <source>Methods are the way your Meteor server accepts inputs and data from the outside world, so it&amp;rsquo;s natural that they are the most important topic for security. If you don&amp;rsquo;t properly secure your Methods, users can end up modifying your database in unexpected ways - editing other people&amp;rsquo;s documents, deleting data, or messing up your database schema causing the app to crash.</source>
          <target state="translated">방법은 Meteor 서버가 외부 세계의 입력 및 데이터를 받아들이는 방식이므로 보안에있어 가장 중요한 주제 인 것은 당연합니다. 분석법을 제대로 보호하지 않으면 사용자가 예기치 않은 방식으로 데이터베이스를 수정하여 다른 사람의 문서를 편집하거나 데이터를 삭제하거나 데이터베이스 스키마를 엉망으로 만들면 앱이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01f91c4cc82c28ac4c7207da72cf66a7b7ea7324" translate="yes" xml:space="preserve">
          <source>Methods can be useful to fetch the result of a complex computation from the server that doesn&amp;rsquo;t need to update when the server data changes. The biggest disadvantage of fetching data through Methods is that the data won&amp;rsquo;t be automatically loaded into Minimongo, Meteor&amp;rsquo;s client-side data cache, so you&amp;rsquo;ll need to manage the lifecycle of that data manually.</source>
          <target state="translated">서버 데이터가 변경 될 때 업데이트 할 필요가없는 복잡한 계산 결과를 서버에서 가져 오는 데 메소드가 유용 할 수 있습니다. Methods를 통해 데이터를 가져 오는 가장 큰 단점은 Meteor의 클라이언트 측 데이터 캐시 인 Minimongo에 데이터가 자동으로로드되지 않으므로 해당 데이터의 수명주기를 수동으로 관리해야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e336436c208c43eb9921e0cf266b407a85c564a2" translate="yes" xml:space="preserve">
          <source>Methods use synchronous-style APIs, but are non-blocking</source>
          <target state="translated">메소드는 동기식 API를 사용하지만 비 블로킹</target>
        </trans-unit>
        <trans-unit id="55f90f3f74aa801ab84a7cff0c63efa869fee8bf" translate="yes" xml:space="preserve">
          <source>Migrating from a version older than 1.4?</source>
          <target state="translated">1.4 이전 버전에서 마이그레이션 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="e4daf8fb0f30e313a7b35e4b31478bad358e26d0" translate="yes" xml:space="preserve">
          <source>Migrating to Meteor 1.5</source>
          <target state="translated">Meteor 1.5로 마이그레이션</target>
        </trans-unit>
        <trans-unit id="f2d76073a74e56240cad448ab8373867d9e1a902" translate="yes" xml:space="preserve">
          <source>Migrating to a new schema</source>
          <target state="translated">새 스키마로 마이그레이션</target>
        </trans-unit>
        <trans-unit id="88d36257186ae5e2f885a7eb78bc96e6d09472eb" translate="yes" xml:space="preserve">
          <source>Migrating unencrypted user tokens</source>
          <target state="translated">암호화되지 않은 사용자 토큰 마이그레이션</target>
        </trans-unit>
        <trans-unit id="7a3ea5ae4bbcb0b6c68d07df01c97a3626e4c95d" translate="yes" xml:space="preserve">
          <source>Minification</source>
          <target state="translated">Minification</target>
        </trans-unit>
        <trans-unit id="8d0e818b697016e40293625615945bcac317f180" translate="yes" xml:space="preserve">
          <source>Minification usually happens when you &lt;code&gt;meteor deploy&lt;/code&gt; or &lt;code&gt;meteor build&lt;/code&gt; your app. If you have an error in production that you suspect is related to minification, you can run the minified version of your app locally with &lt;code&gt;meteor --production&lt;/code&gt;.</source>
          <target state="translated">축소는 일반적으로 &lt;code&gt;meteor deploy&lt;/code&gt; 또는 &lt;code&gt;meteor build&lt;/code&gt; 앱을 빌드 할 때 발생 합니다. 프로덕션에 축소와 관련이 있다고 생각되는 오류가있는 경우 &lt;code&gt;meteor --production&lt;/code&gt; 을 사용하여 축소 된 버전의 앱을 로컬로 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3146f9e3c154ef4dd9ed27afbf87d9638c94ca49" translate="yes" xml:space="preserve">
          <source>Minifier plugin - compiles lots of built CSS or JS files into one or more minified files, for example &lt;code&gt;standard-minifiers&lt;/code&gt;. Only one minifier can handle each of &lt;code&gt;js&lt;/code&gt; and &lt;code&gt;css&lt;/code&gt;.</source>
          <target state="translated">축소 기 플러그인-빌드 된 많은 CSS 또는 JS 파일을 하나 이상의 축소 된 파일 (예 : &lt;code&gt;standard-minifiers&lt;/code&gt; 축소 기)로 컴파일합니다 . 하나의 축소기만 각 &lt;code&gt;js&lt;/code&gt; 및 &lt;code&gt;css&lt;/code&gt; 를 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="c3343772e496a59c3d2fba9fe4453e7fbbfc5dab" translate="yes" xml:space="preserve">
          <source>Minifiers</source>
          <target state="translated">Minifiers</target>
        </trans-unit>
        <trans-unit id="2c3dfe2b2c5231090cbc7c87aa86fe2d197eaced" translate="yes" xml:space="preserve">
          <source>Minifiers run last after the sources has been compiled and JavaScript code has been linked. Minifiers are only ran for the client programs (&lt;code&gt;web.browser&lt;/code&gt; and &lt;code&gt;web.cordova&lt;/code&gt;).</source>
          <target state="translated">축소 기는 소스가 컴파일되고 JavaScript 코드가 연결된 후에 마지막으로 실행됩니다. 축소 기는 클라이언트 프로그램 ( &lt;code&gt;web.browser&lt;/code&gt; 및 &lt;code&gt;web.cordova&lt;/code&gt; )에 대해서만 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="42fc784f35bb827de39e489a4fcb483804ace508" translate="yes" xml:space="preserve">
          <source>Minify JavaScript and CSS files. Can also include concatenation of all files.</source>
          <target state="translated">JavaScript 및 CSS 파일을 축소하십시오. 모든 파일의 연결을 포함 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5493b32c30d73b72b0cbdedacc87c5f4057323e" translate="yes" xml:space="preserve">
          <source>Minimongo doesn&amp;rsquo;t currently have indexes. It&amp;rsquo;s rare for this to be an issue, since it&amp;rsquo;s unusual for a client to have enough data that an index is worthwhile.</source>
          <target state="translated">Minimongo에는 현재 색인이 없습니다. 클라이언트가 인덱스에 가치가있는 충분한 데이터를 가지고있는 경우가 드물기 때문에 이것이 문제가되는 경우는 드 rare니다.</target>
        </trans-unit>
        <trans-unit id="96732b61a8d377ada7b914c38aba1cf0d28297dd" translate="yes" xml:space="preserve">
          <source>Missing pages</source>
          <target state="translated">누락 된 페이지</target>
        </trans-unit>
        <trans-unit id="b1d702459399a2512fba5a402d4d5f26aee34693" translate="yes" xml:space="preserve">
          <source>Mobile</source>
          <target state="translated">Mobile</target>
        </trans-unit>
        <trans-unit id="190ebeb2bab5571e36599c42851b575528e7a0ee" translate="yes" xml:space="preserve">
          <source>Mobile Configuration</source>
          <target state="translated">모바일 구성</target>
        </trans-unit>
        <trans-unit id="ad8215f6e4b427525de4a97bb7b22e0ced268f2a" translate="yes" xml:space="preserve">
          <source>Mocking the database</source>
          <target state="translated">데이터베이스 조롱</target>
        </trans-unit>
        <trans-unit id="b174cc9a3c071b04298bd329afff0b7f4c1f88cb" translate="yes" xml:space="preserve">
          <source>Modify documents that match &lt;code&gt;selector&lt;/code&gt; according to &lt;code&gt;modifier&lt;/code&gt; (see &lt;a href=&quot;#modifiers&quot;&gt;modifier documentation&lt;/a&gt;).</source>
          <target state="translated">수정 &lt;code&gt;modifier&lt;/code&gt; 에 따라 &lt;code&gt;selector&lt;/code&gt; 와 일치하는 문서 를 수정 하십시오 ( &lt;a href=&quot;#modifiers&quot;&gt;수정 자 문서&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="0f6b56411a7ed678e49b6ed317fd66480700469d" translate="yes" xml:space="preserve">
          <source>Modify documents that match &lt;code&gt;selector&lt;/code&gt; according to &lt;code&gt;modifier&lt;/code&gt;, or insert a document if no documents were modified. &lt;code&gt;upsert&lt;/code&gt; is the same as calling &lt;code&gt;update&lt;/code&gt; with the &lt;code&gt;upsert&lt;/code&gt; option set to true, except that the return value of &lt;code&gt;upsert&lt;/code&gt; is an object that contain the keys &lt;code&gt;numberAffected&lt;/code&gt; and &lt;code&gt;insertedId&lt;/code&gt;. (&lt;code&gt;update&lt;/code&gt; returns only the number of affected documents.)</source>
          <target state="translated">수정 &lt;code&gt;modifier&lt;/code&gt; 에 따라 &lt;code&gt;selector&lt;/code&gt; 와 일치 하는 문서 를 수정 하거나 문서가 수정되지 않은 경우 문서를 삽입하십시오. &lt;code&gt;upsert&lt;/code&gt; 가 호출과 동일 &lt;code&gt;update&lt;/code&gt; 와 &lt;code&gt;upsert&lt;/code&gt; 의 true로 옵션 세트를,의 반환 값 것을 제외하고 &lt;code&gt;upsert&lt;/code&gt; 가 키를 포함하는 객체입니다 &lt;code&gt;numberAffected&lt;/code&gt; 및 &lt;code&gt;insertedId&lt;/code&gt; 을 . ( &lt;code&gt;update&lt;/code&gt; 는 영향을받는 문서 수만 반환합니다.)</target>
        </trans-unit>
        <trans-unit id="db986bd327f629e2a385aadbaf1f352c2c4e6f94" translate="yes" xml:space="preserve">
          <source>Modify one or more documents in the collection, or insert one if no matching documents were found. Returns an object with keys &lt;code&gt;numberAffected&lt;/code&gt; (the number of documents modified) and &lt;code&gt;insertedId&lt;/code&gt; (the unique _id of the document that was inserted, if any).</source>
          <target state="translated">콜렉션에서 하나 이상의 문서를 수정하거나 일치하는 문서가없는 경우 하나를 삽입하십시오. 키 &lt;code&gt;numberAffected&lt;/code&gt; (수정 된 문서 수) 및 insertId ( &lt;code&gt;insertedId&lt;/code&gt; 된 문서 의 고유 한 _id ) 키가있는 오브젝트를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="1e384a3ad74ff8496f32ecac56c82471e2e8014d" translate="yes" xml:space="preserve">
          <source>Modify one or more documents in the collection. Returns the number of matched documents.</source>
          <target state="translated">콜렉션에서 하나 이상의 문서를 수정하십시오. 일치하는 문서 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="75e24952216a7b88df3445cd5dc18c966ae272a5" translate="yes" xml:space="preserve">
          <source>Modular application structure</source>
          <target state="translated">모듈 식 애플리케이션 구조</target>
        </trans-unit>
        <trans-unit id="18c5a8e973a1250af694a05743d210ba96778b85" translate="yes" xml:space="preserve">
          <source>Modular package structure</source>
          <target state="translated">모듈 식 패키지 구조</target>
        </trans-unit>
        <trans-unit id="6ff315972a626a7a0f17ca1b3f61c033038b8957" translate="yes" xml:space="preserve">
          <source>Modules and CoffeeScript</source>
          <target state="translated">모듈 및 CoffeeScript</target>
        </trans-unit>
        <trans-unit id="32300c4f236449c8a9a0f8cb0e2339a88cd67b27" translate="yes" xml:space="preserve">
          <source>Momentum works by overriding the way that child HTML elements appear and disappear. In this case, when the list component goes into the &lt;code&gt;editing&lt;/code&gt; state, the &lt;code&gt;.nav-group&lt;/code&gt; disappears, and the &lt;code&gt;form&lt;/code&gt; appears. Momentum takes care of the job of making sure that both items fade, making the change a lot clearer.</source>
          <target state="translated">모멘텀은 자식 HTML 요소가 나타나고 사라지는 방식을 재정 의하여 작동합니다. 이 경우 목록 구성 요소가 &lt;code&gt;editing&lt;/code&gt; 상태가되면 &lt;code&gt;.nav-group&lt;/code&gt; 이 사라지고 &lt;code&gt;form&lt;/code&gt; 나타납니다. Momentum은 두 항목이 모두 희미 해져 변경 사항이 훨씬 명확 해 지도록 관리합니다.</target>
        </trans-unit>
        <trans-unit id="dd3816603141611d449f74374acc0b44ea825610" translate="yes" xml:space="preserve">
          <source>Mongo-Style Modifiers</source>
          <target state="translated">몽고 스타일 수정 자</target>
        </trans-unit>
        <trans-unit id="426968907ee4c661185189d83fe0b5f3cfe4ea54" translate="yes" xml:space="preserve">
          <source>Mongo-Style Selectors</source>
          <target state="translated">몽고 스타일 선택기</target>
        </trans-unit>
        <trans-unit id="403a96d96cd4007b5f9dba3bc4dc51cf9ad3c7c1" translate="yes" xml:space="preserve">
          <source>Mongo.Collection#allow()</source>
          <target state="translated">Mongo.Collection#allow()</target>
        </trans-unit>
        <trans-unit id="819a964024d9e625cbd73d9b903727928aa11a8b" translate="yes" xml:space="preserve">
          <source>Mongo.Collection#deny()</source>
          <target state="translated">Mongo.Collection#deny()</target>
        </trans-unit>
        <trans-unit id="effa701f500d6f6fc26c55c68172e7698274c35a" translate="yes" xml:space="preserve">
          <source>Mongo.Collection#find()</source>
          <target state="translated">Mongo.Collection#find()</target>
        </trans-unit>
        <trans-unit id="b25ba0aa3a8c25104c36dd5166732d2b1de3720d" translate="yes" xml:space="preserve">
          <source>Mongo.Collection#findOne()</source>
          <target state="translated">Mongo.Collection#findOne()</target>
        </trans-unit>
        <trans-unit id="68f08f83473fb80c1a0724efa0147d7af93853d3" translate="yes" xml:space="preserve">
          <source>Mongo.Collection#insert()</source>
          <target state="translated">Mongo.Collection#insert()</target>
        </trans-unit>
        <trans-unit id="09fdeae653fe2cbbad46c318a8bf88b9fb424377" translate="yes" xml:space="preserve">
          <source>Mongo.Collection#rawCollection()</source>
          <target state="translated">Mongo.Collection#rawCollection()</target>
        </trans-unit>
        <trans-unit id="ae611f13bc2ef6134e81b8c8af290aced7ad2c46" translate="yes" xml:space="preserve">
          <source>Mongo.Collection#rawDatabase()</source>
          <target state="translated">Mongo.Collection#rawDatabase()</target>
        </trans-unit>
        <trans-unit id="624d1bd6d1408df952311ca1057dac04b3d19b23" translate="yes" xml:space="preserve">
          <source>Mongo.Collection#remove()</source>
          <target state="translated">Mongo.Collection#remove()</target>
        </trans-unit>
        <trans-unit id="eb3a8211701c9e272329d841283008d86a33ffc0" translate="yes" xml:space="preserve">
          <source>Mongo.Collection#update()</source>
          <target state="translated">Mongo.Collection#update()</target>
        </trans-unit>
        <trans-unit id="56bc62e60f196f47258e9c3402566390231dfcd7" translate="yes" xml:space="preserve">
          <source>Mongo.Collection#upsert()</source>
          <target state="translated">Mongo.Collection#upsert()</target>
        </trans-unit>
        <trans-unit id="af76893984d73b11a88694f1bca0b28566df0845" translate="yes" xml:space="preserve">
          <source>Mongo.Collection()</source>
          <target state="translated">Mongo.Collection()</target>
        </trans-unit>
        <trans-unit id="952816abaef4256fabcc1c106931547087231b58" translate="yes" xml:space="preserve">
          <source>Mongo.Cursor#count()</source>
          <target state="translated">Mongo.Cursor#count()</target>
        </trans-unit>
        <trans-unit id="103cc844f56d727d0f983a9e6c60bb85ec4fc64d" translate="yes" xml:space="preserve">
          <source>Mongo.Cursor#fetch()</source>
          <target state="translated">Mongo.Cursor#fetch()</target>
        </trans-unit>
        <trans-unit id="ffa461ccfccb5a879bf19a007472b2ec03247603" translate="yes" xml:space="preserve">
          <source>Mongo.Cursor#forEach()</source>
          <target state="translated">Mongo.Cursor#forEach()</target>
        </trans-unit>
        <trans-unit id="c98655f9f338bae3092079502ad8371e8a12b858" translate="yes" xml:space="preserve">
          <source>Mongo.Cursor#map()</source>
          <target state="translated">Mongo.Cursor#map()</target>
        </trans-unit>
        <trans-unit id="dc67d54326d23a41329032526df8b6f42f2bb48e" translate="yes" xml:space="preserve">
          <source>Mongo.Cursor#observe()</source>
          <target state="translated">Mongo.Cursor#observe()</target>
        </trans-unit>
        <trans-unit id="5421802ac115b1c0d4c1b9de931cdd84fd76473d" translate="yes" xml:space="preserve">
          <source>Mongo.Cursor#observeChanges()</source>
          <target state="translated">Mongo.Cursor#observeChanges()</target>
        </trans-unit>
        <trans-unit id="3424ac63ca72550911ed0e726d6f41bd0ee6d389" translate="yes" xml:space="preserve">
          <source>Mongo.ObjectID()</source>
          <target state="translated">Mongo.ObjectID()</target>
        </trans-unit>
        <trans-unit id="16666385ac1a46ae21d9d2238177647a13d1010c" translate="yes" xml:space="preserve">
          <source>MongoDB Atlas</source>
          <target state="translated">몽고 DB 아틀라스</target>
        </trans-unit>
        <trans-unit id="bef47610df62f40e6bd8aa528575f38506b563e7" translate="yes" xml:space="preserve">
          <source>MongoDB collections in Meteor</source>
          <target state="translated">Meteor의 MongoDB 모음</target>
        </trans-unit>
        <trans-unit id="aeb56478d8b42f0d4156d4ba6e248c2558dd4c58" translate="yes" xml:space="preserve">
          <source>MongoDB options</source>
          <target state="translated">MongoDB 옵션</target>
        </trans-unit>
        <trans-unit id="55dea6bb872565cbc674dd20c5bb7742909f0eba" translate="yes" xml:space="preserve">
          <source>MongoDB server URL. Give a fully qualified URL (or comma-separated list of URLs) like &lt;code&gt;MONGO_URL=&quot;mongodb://user:password@myserver.com:10139&quot;&lt;/code&gt;. For more information see the &lt;a href=&quot;https://docs.mongodb.com/manual/reference/connection-string/&quot;&gt;MongoDB docs&lt;/a&gt;.</source>
          <target state="translated">MongoDB 서버 URL &lt;code&gt;MONGO_URL=&quot;mongodb://user:password@myserver.com:10139&quot;&lt;/code&gt; 와 같이 정규화 된 URL (또는 쉼표로 구분 된 URL 목록)을 제공하십시오 . 자세한 내용은 &lt;a href=&quot;https://docs.mongodb.com/manual/reference/connection-string/&quot;&gt;MongoDB 문서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aa1fe623d0de8fd9f60cdf9f186bfc24c039cc41" translate="yes" xml:space="preserve">
          <source>MongoDB server oplog URL. If you&amp;rsquo;re using a replica set (which you should), construct this url like so: &lt;code&gt;MONGO_OPLOG_URL=&quot;mongodb://user:password@myserver.com:10139/local?replicaSet=(your replica set)&amp;amp;authSource=(your auth source)&quot;&lt;/code&gt;</source>
          <target state="translated">MongoDB 서버 oplog URL. 복제 세트 (필요한)를 사용하는 경우 다음과 &lt;code&gt;MONGO_OPLOG_URL=&quot;mongodb://user:password@myserver.com:10139/local?replicaSet=(your replica set)&amp;amp;authSource=(your auth source)&quot;&lt;/code&gt; URL을 구성하십시오. MONGO_OPLOG_URL = &quot;mongodb : // user : password@myserver.com : 10139 / local? replicaSet = (복제 세트) &amp;amp; authSource = (your 인증 소스) &quot;</target>
        </trans-unit>
        <trans-unit id="1310f92c30dcf2f7680d59a32d87ab2e98e74e18" translate="yes" xml:space="preserve">
          <source>Monitoring &amp;amp; Automated alerting</source>
          <target state="translated">모니터링 및 자동 경고</target>
        </trans-unit>
        <trans-unit id="d73861ddb7ddc8090ca44a4726071f6383364ad2" translate="yes" xml:space="preserve">
          <source>Monitoring users via analytics</source>
          <target state="translated">분석을 통한 사용자 모니터링</target>
        </trans-unit>
        <trans-unit id="c69b02ac94bc0260ecda0498527f0b72ae3828b4" translate="yes" xml:space="preserve">
          <source>Monitoring with Galaxy</source>
          <target state="translated">Galaxy로 모니터링</target>
        </trans-unit>
        <trans-unit id="22342104f67e1d6d2c64d62a7c1eeaf0783fc2f6" translate="yes" xml:space="preserve">
          <source>Monitoring your application</source>
          <target state="translated">응용 프로그램 모니터링</target>
        </trans-unit>
        <trans-unit id="695ef98c498ee7dea7f7c357b8b6a71dfac1aad1" translate="yes" xml:space="preserve">
          <source>Most applications do not need to be aware of these Views, but they offer a way to understand and customize Meteor&amp;rsquo;s rendering behavior for more advanced applications and packages.</source>
          <target state="translated">대부분의 응용 프로그램은 이러한 뷰를 인식 할 필요는 없지만 고급 응용 프로그램 및 패키지에 대한 Meteor의 렌더링 동작을 이해하고 사용자 지정할 수있는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="942e42b00acfc3b52b50f7e1c5d0e8b80ca997a6" translate="yes" xml:space="preserve">
          <source>Most events bubble up the document tree from their originating element. For example, &lt;code&gt;'click p'&lt;/code&gt; catches a click anywhere in a paragraph, even if the click originated on a link, span, or some other element inside the paragraph. The originating element of the event is available as the &lt;code&gt;target&lt;/code&gt; property, while the element that matched the selector and is currently handling it is called &lt;code&gt;currentTarget&lt;/code&gt;.</source>
          <target state="translated">대부분의 이벤트는 원래 요소에서 문서 트리를 버블 링합니다. 예를 들어 &lt;code&gt;'click p'&lt;/code&gt; 는 클릭이 링크, 범위 또는 단락 내의 다른 요소에서 시작된 경우에도 단락의 어느 곳에서나 클릭을 포착합니다. 이벤트의 원래 요소는 &lt;code&gt;target&lt;/code&gt; 특성 으로 사용 가능 하지만 선택기와 일치하고 현재 처리중인 요소는 &lt;code&gt;currentTarget&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dbb6b6b3be8f8cd31ff05b4428c0ebd753b27b89" translate="yes" xml:space="preserve">
          <source>Mouse click on any element, including a link, button, form control, or div. Use &lt;code&gt;preventDefault()&lt;/code&gt; to prevent a clicked link from being followed. Some ways of activating an element from the keyboard also fire &lt;code&gt;click&lt;/code&gt;.</source>
          <target state="translated">링크, 단추, 양식 컨트롤 또는 div를 포함한 모든 요소를 ​​마우스로 클릭하십시오. &lt;code&gt;preventDefault()&lt;/code&gt; 링크를 따르지 못하게 하려면 preventDefault () 를 사용하십시오 . 키보드에서 요소를 활성화하는 몇 가지 방법도 &lt;code&gt;click&lt;/code&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="306ba80fb8f82e7c351b85043f19fc23501191e8" translate="yes" xml:space="preserve">
          <source>Multiple behaviors of this type can be composed by wrapping a template in multiple wrappers, or creating a meta-wrapper that combines multiple wrapper templates.</source>
          <target state="translated">이 유형의 다중 동작은 템플리트를 다중 랩퍼로 랩핑하거나 다중 랩퍼 템플리트를 결합하는 메타 랩퍼를 작성하여 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa65ee10ceaf1abb58c989309fea8fd944f1eea0" translate="yes" xml:space="preserve">
          <source>Multiple emails</source>
          <target state="translated">여러 이메일</target>
        </trans-unit>
        <trans-unit id="85992c4111bef3333392aaf52d57566a52bf0cb4" translate="yes" xml:space="preserve">
          <source>Multiple shells can be attached to the same server. If no server is currently available, &lt;code&gt;meteor shell&lt;/code&gt; will keep trying to connect until it succeeds.</source>
          <target state="translated">동일한 서버에 여러 쉘을 연결할 수 있습니다. 현재 사용 가능한 서버가없는 경우 &lt;code&gt;meteor shell&lt;/code&gt; 은 성공할 때까지 계속 연결을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="448a053124160f6f1059a05225fca6a7656eb0de" translate="yes" xml:space="preserve">
          <source>Mutators can get very long when you want to hook in multiple times.</source>
          <target state="translated">여러 번 연결하려는 경우 뮤 테이터가 매우 길어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="458abd2d58ca4f6a99a8329ebea64a0b18022e43" translate="yes" xml:space="preserve">
          <source>Name Resolution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89ec332a2a605fc21f490b4b2ef3b68bfe2a10cc" translate="yes" xml:space="preserve">
          <source>Name data contexts to template inclusions</source>
          <target state="translated">템플릿 포함에 대한 이름 데이터 컨텍스트</target>
        </trans-unit>
        <trans-unit id="6a5d1b44bbadf994e1218c12a25565126cc0e1f9" translate="yes" xml:space="preserve">
          <source>Name of a package, or array of package names, with an optional @version component for each.</source>
          <target state="translated">각각에 대한 선택적 @version 구성 요소가있는 패키지 이름 또는 패키지 이름 배열.</target>
        </trans-unit>
        <trans-unit id="fb8d986b0519ac3511f5a1c2767dc3a9c6dfd929" translate="yes" xml:space="preserve">
          <source>Name of method to invoke</source>
          <target state="translated">호출 할 메소드 이름</target>
        </trans-unit>
        <trans-unit id="4b65326960915ff5fc848780e42d693870c8c10b" translate="yes" xml:space="preserve">
          <source>Name of the object to export, or an array of object names.</source>
          <target state="translated">내보낼 객체의 이름 또는 객체 이름의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="fabe4dddf9f588f51f734143664f61d57f7c533b" translate="yes" xml:space="preserve">
          <source>Name of the subscription. Matches the name of the server's &lt;code&gt;publish()&lt;/code&gt; call.</source>
          <target state="translated">구독 이름. 서버의 &lt;code&gt;publish()&lt;/code&gt; 호출 이름과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="dc0542cba9ef0e0b2c3f5af68e5417f36222e7d5" translate="yes" xml:space="preserve">
          <source>Namespacing and CoffeeScript</source>
          <target state="translated">네임 스페이스 및 CoffeeScript</target>
        </trans-unit>
        <trans-unit id="1a066b19fd168cdbb28dc5446b16019355410536" translate="yes" xml:space="preserve">
          <source>Native features with Cordova plugins</source>
          <target state="translated">Cordova 플러그인의 기본 기능</target>
        </trans-unit>
        <trans-unit id="25739935628f0457ed28044d72717ee02227949d" translate="yes" xml:space="preserve">
          <source>Nested computations are stopped automatically when their enclosing computation is rerun.</source>
          <target state="translated">중첩 계산은 엔 클로징 계산이 다시 실행될 때 자동으로 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="75645b76ce0ad8de07758b3bf2fdaa2b277fee39" translate="yes" xml:space="preserve">
          <source>Nested sub-expressions</source>
          <target state="translated">중첩 된 하위 표현식</target>
        </trans-unit>
        <trans-unit id="9b113cad4ad0a91d8cc7f30db6437cae8d87e0b1" translate="yes" xml:space="preserve">
          <source>Never pass the current user ID as an argument.</source>
          <target state="translated">현재 사용자 ID를 인수로 전달하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="465642a186a5afb094d1db1577bd2adf570fe62f" translate="yes" xml:space="preserve">
          <source>Never use &lt;code&gt;--production&lt;/code&gt; flag to deploy!</source>
          <target state="translated">&lt;code&gt;--production&lt;/code&gt; 플래그를 사용 하여 배포 하지 마십시오 !</target>
        </trans-unit>
        <trans-unit id="0add9c970b96e1af80d63b0bbe09179a767a52d1" translate="yes" xml:space="preserve">
          <source>New users with an email address will receive an address verification email.</source>
          <target state="translated">이메일 주소를 가진 새로운 사용자는 주소 확인 이메일을 받게됩니다.</target>
        </trans-unit>
        <trans-unit id="c6c601aa6d7f5bd28717d734ead36f86dc2b0fec" translate="yes" xml:space="preserve">
          <source>Next, you can run zipalign on it to optimize the APK:</source>
          <target state="translated">다음으로 zipalign을 실행하여 APK를 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ac595d95e7fe6ec3a6bb510ecf61cb998fb9735" translate="yes" xml:space="preserve">
          <source>No matter which of these modules is imported first, the order of the &lt;code&gt;console.log&lt;/code&gt; calls will always be:</source>
          <target state="translated">어떤 모듈을 먼저 가져 &lt;code&gt;console.log&lt;/code&gt; 호출 순서 는 항상 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ce1335e03beac0a4b72b6bf3e276532780184d5d" translate="yes" xml:space="preserve">
          <source>Node 0.10.43 for &lt;em&gt;Meteor 1.3.x and earlier&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Meteor 1.3.x 및 이전 버전에&lt;/em&gt; 대한 노드 0.10.43&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ecc776838a6f35d6cf71f613eb81adf3346eb9fc" translate="yes" xml:space="preserve">
          <source>Node 4.6.2 for &lt;em&gt;Meteor 1.4.x&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Meteor 1.4.x&lt;/em&gt; 용 노드 4.6.2&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8b9a656b4d3308b88b74ba2452e5362c768a0e87" translate="yes" xml:space="preserve">
          <source>Normally, when the Meteor client connects to the server, the first thing it does is pass the &lt;em&gt;login resume token&lt;/em&gt; to re-establish a previous login. However, when these callbacks from the email flow are triggered, the resume token is not sent until your code signals that it has finished handling the request by calling the &lt;code&gt;done&lt;/code&gt; function that is passed into the registered callback. This means that if you were previously logged in as user A, and then you clicked the reset password link for user B, but then you cancelled the password reset flow by calling &lt;code&gt;done()&lt;/code&gt;, the client would log in as A again.</source>
          <target state="translated">일반적으로 Meteor 클라이언트가 서버에 연결되면 가장 먼저 &lt;em&gt;로그인 이력서 토큰&lt;/em&gt; 을 전달하여 이전 로그인을 다시 설정해야합니다. 그러나 전자 메일 흐름에서 이러한 콜백이 트리거되면 코드 에서 등록 된 콜백으로 전달 된 &lt;code&gt;done&lt;/code&gt; 함수를 호출하여 요청 처리가 완료되었음을 알리기 전까지 재개 토큰이 전송되지 않습니다 . 이는 이전에 사용자 A로 로그인 한 후 사용자 B의 비밀번호 재설정 링크를 클릭했지만 &lt;code&gt;done()&lt;/code&gt; 을 호출하여 비밀번호 재설정 플로우를 취소 한 경우 클라이언트는 A로 다시 로그인 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b21b40132e53c70d421f4694203a48f7396a0012" translate="yes" xml:space="preserve">
          <source>Normally, when you make changes (like writing to the database), their impact (like updating the DOM) is delayed until the system is idle. This keeps things predictable &amp;mdash; you can know that the DOM won&amp;rsquo;t go changing out from under your code as it runs. It&amp;rsquo;s also one of the things that makes Meteor fast.</source>
          <target state="translated">일반적으로 데이터베이스에 쓰는 것과 같이 변경하면 시스템이 유휴 상태가 될 때까지 DOM 업데이트와 같은 영향이 지연됩니다. 이렇게하면 상황을 예측할 수 있습니다. DOM이 실행될 때 DOM이 변경되지 않는다는 것을 알 수 있습니다. 또한 Meteor를 빠르게 만드는 것 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="fe16e62334d4b43bbbde630a900a8fdcda76d394" translate="yes" xml:space="preserve">
          <source>Note also that the client example does not end up calling any methods of the &lt;code&gt;sink&lt;/code&gt; object, because &lt;code&gt;ReactDOM.hydrate&lt;/code&gt; has its own similar API. In fact, you are not even required to use the &lt;code&gt;onPageLoad&lt;/code&gt; API on the client, if you have your own ideas about how the client should do its rendering.</source>
          <target state="translated">&lt;code&gt;ReactDOM.hydrate&lt;/code&gt; 는 자체적으로 비슷한 API를 가지고 있기 때문에 클라이언트 예제는 &lt;code&gt;sink&lt;/code&gt; 객체의 메소드를 호출하지 않습니다 . 실제로 클라이언트가 렌더링을 수행하는 방법에 대한 아이디어가 있다면 클라이언트 에서 &lt;code&gt;onPageLoad&lt;/code&gt; API 를 사용할 필요조차 없습니다 .</target>
        </trans-unit>
        <trans-unit id="db239fbe6d178da413343ff7926fe42c6236debc" translate="yes" xml:space="preserve">
          <source>Note that &amp;ldquo;container components&amp;rdquo; are analogous to the &amp;ldquo;smart components&amp;rdquo; and &amp;ldquo;presentational components&amp;rdquo; to the &amp;ldquo;reusable components&amp;rdquo; in the pattern we document in the &lt;a href=&quot;http://guide.meteor.com/ui-ux.html#components&quot;&gt;UI/UX article&lt;/a&gt;, if you&amp;rsquo;d like to read more about how this philosophy relates to Meteor.</source>
          <target state="translated">이 철학이 어떻게 관련되어 있는지 더 자세히 알고 싶다면 &quot;컨테이너 구성 요소&quot;는 &lt;a href=&quot;http://guide.meteor.com/ui-ux.html#components&quot;&gt;UI / UX 기사&lt;/a&gt; 에서 문서화 한 패턴의 &quot;스마트 구성 요소&quot;및 &quot;표시 구성 요소&quot;와 &quot;재사용 가능한 구성 요소&quot; 와 유사합니다. 유성에게.</target>
        </trans-unit>
        <trans-unit id="82f46ec92266100b6f49d97b7f318b8f4e3c996a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;AccountsClient&lt;/code&gt; is currently available only on the client, due to its use of browser APIs such as &lt;code&gt;window.localStorage&lt;/code&gt;. In principle, though, it might make sense to establish a client connection from one server to another remote accounts server. Please &lt;a href=&quot;https://github.com/meteor/meteor/wiki/Contributing-to-Meteor#feature-requests&quot;&gt;let us know&lt;/a&gt; if you find yourself needing this server-to-server functionality.</source>
          <target state="translated">참고 &lt;code&gt;AccountsClient&lt;/code&gt; 이 때문에 같은 브라우저의 API의 사용으로 만 클라이언트에서 현재 사용할 수 &lt;code&gt;window.localStorage&lt;/code&gt; . 그러나 원칙적으로 한 서버에서 다른 원격 계정 서버로 클라이언트 연결을 설정하는 것이 좋습니다. 제발 &lt;a href=&quot;https://github.com/meteor/meteor/wiki/Contributing-to-Meteor#feature-requests&quot;&gt;저희에게 알려&lt;/a&gt; 자신이 서버 대 서버 기능을 필요로 찾을 경우.</target>
        </trans-unit>
        <trans-unit id="6dfc941de3deccb84a36c0d91d3bc706177900b5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;checkNpmVersions&lt;/code&gt; will only output a warning if the user has installed a incompatible version of the npm package. So your &lt;code&gt;require&lt;/code&gt; call may not give you what you expect. This is consistent with npm&amp;rsquo;s handling of &lt;a href=&quot;http://blog.npmjs.org/post/110924823920/npm-weekly-5&quot;&gt;peer dependencies&lt;/a&gt;.</source>
          <target state="translated">참고 &lt;code&gt;checkNpmVersions&lt;/code&gt; 는 단지 출력 경고 사용자가 NPM 패키지의 호환되지 않는 버전을 설치 한 것입니다 경우. 따라서 귀하의 &lt;code&gt;require&lt;/code&gt; 전화는 당신이 기대하는 것을 제공하지 않을 수 있습니다. 이는 npm의 &lt;a href=&quot;http://blog.npmjs.org/post/110924823920/npm-weekly-5&quot;&gt;피어 종속성&lt;/a&gt; 처리와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="11331f055374343a8c037eae52c5f0b06f97dc7f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;color&lt;/code&gt; (and &lt;code&gt;todo&lt;/code&gt; above) are only added to scope in the template; they &lt;em&gt;are not&lt;/em&gt; added to the data context. Specifically this means that inside helpers and event handlers, you cannot access them with &lt;code&gt;this.name&lt;/code&gt; or &lt;code&gt;this.color&lt;/code&gt;. If you need to access them inside a helper, you should pass them in as an argument (like we do with &lt;code&gt;(todoArgs todo)&lt;/code&gt; above).</source>
          <target state="translated">주의 &lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;color&lt;/code&gt; (및 &lt;code&gt;todo&lt;/code&gt; 상기 참조)은 템플릿의 영역에 추가된다; 그들은 &lt;em&gt;되지 않은&lt;/em&gt; 데이터 컨텍스트에 추가됩니다. 특히 이것은 도우미와 이벤트 핸들러 내부에서 &lt;code&gt;this.name&lt;/code&gt; 또는 &lt;code&gt;this.color&lt;/code&gt; 로 액세스 할 수 없음을 의미 합니다. 도우미 내부에서 액세스 해야하는 경우 인수로 전달해야합니다 &lt;code&gt;(todoArgs todo)&lt;/code&gt; 위의 (todoArgs todo)와 같이).</target>
        </trans-unit>
        <trans-unit id="64fa95e6a6c26b4ce90059b22cbdedaf6f81cf18" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;react-mounter&lt;/code&gt; automatically mounts the layout component on a &lt;code&gt;#react-root&lt;/code&gt; node, which you can change by using the &lt;code&gt;withOptions()&lt;/code&gt; function.</source>
          <target state="translated">주 &lt;code&gt;react-mounter&lt;/code&gt; 자동으로에 레이아웃 구성 요소 마운트 &lt;code&gt;#react-root&lt;/code&gt; 사용자가 사용하여 변경할 수 있습니다 노드, &lt;code&gt;withOptions()&lt;/code&gt; 함수를.</target>
        </trans-unit>
        <trans-unit id="f9f0a5447399965abb8d4c9baec9d529cb47602f" translate="yes" xml:space="preserve">
          <source>Note that Spacebars is very forgiving of &lt;code&gt;null&lt;/code&gt; values. It will not complain if you try to access a property on a &lt;code&gt;null&lt;/code&gt; value (for instance &lt;code&gt;foo.bar&lt;/code&gt; if &lt;code&gt;foo&lt;/code&gt; is not defined), but instead simply treats it also as null. However there are exceptions to this&amp;mdash;trying to call a &lt;code&gt;null&lt;/code&gt; function, or doing the same &lt;em&gt;within&lt;/em&gt; a helper will lead to exceptions.</source>
          <target state="translated">스페이스 바는 &lt;code&gt;null&lt;/code&gt; 값을 매우 용서 합니다. &lt;code&gt;null&lt;/code&gt; 값 으로 속성에 액세스하려고하면 (예 : &lt;code&gt;foo&lt;/code&gt; 가 정의되어 있지 않은 경우 &lt;code&gt;foo.bar&lt;/code&gt; ) 불평 하지 않고 대신 단순히 null로 처리합니다. 그러나 &lt;code&gt;null&lt;/code&gt; 함수 를 호출 하거나 도우미 &lt;em&gt;내&lt;/em&gt; 에서 동일한 작업을 수행하면 예외가 발생합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="28761ac4cf9a41ad91ef956579c3b2c5b383c79e" translate="yes" xml:space="preserve">
          <source>Note that all of the values in &lt;code&gt;params&lt;/code&gt; and &lt;code&gt;queryParams&lt;/code&gt; are always strings since URLs don&amp;rsquo;t have any way of encoding data types. For example, if you wanted a parameter to represent a number, you might need to use &lt;code&gt;parseInt(value, 10)&lt;/code&gt; to convert it when you access it.</source>
          <target state="translated">URL에는 데이터 유형을 인코딩하는 방법이 없으므로 &lt;code&gt;params&lt;/code&gt; 및 &lt;code&gt;queryParams&lt;/code&gt; 의 모든 값 은 항상 문자열입니다. 예를 들어 매개 변수가 숫자를 나타내도록하려면 &lt;code&gt;parseInt(value, 10)&lt;/code&gt; 를 사용하여 액세스 할 때 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="0d276990631279d27074f63d34a46c03cd9d519c" translate="yes" xml:space="preserve">
          <source>Note that arrow function use with Mocha &lt;a href=&quot;http://mochajs.org/#arrow-functions&quot;&gt;is discouraged&lt;/a&gt;.</source>
          <target state="translated">Mocha와 함께 화살표 기능을 사용 &lt;a href=&quot;http://mochajs.org/#arrow-functions&quot;&gt;하지 않는 것이 좋습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f302455ffe257d4ecb081d2b56bd7f83773edefb" translate="yes" xml:space="preserve">
          <source>Note that dynamic calls to &lt;code&gt;require()&lt;/code&gt; (where the name being required can change at runtime) cannot be analyzed correctly and may result in broken client bundles.</source>
          <target state="translated">&lt;code&gt;require()&lt;/code&gt; 에 대한 동적 호출 ( 필요한 이름은 런타임에 변경 될 수 있음)을 올바르게 분석 할 수 없으며 클라이언트 번들이 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c294ffc6fd67a8ebf46ee7f6c41c4a21e59f6ef5" translate="yes" xml:space="preserve">
          <source>Note that dynamic calls to &lt;code&gt;require()&lt;/code&gt; (where the name being required can change at runtime) cannot be analyzed correctly and may result in broken client bundles. This is also discussed in &lt;a href=&quot;http://guide.meteor.com/structure.html#using-require&quot;&gt;the guide&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;require()&lt;/code&gt; 에 대한 동적 호출 ( 필요한 이름은 런타임에 변경 될 수 있음)을 올바르게 분석 할 수 없으며 클라이언트 번들이 손상 될 수 있습니다. 이것 또한 &lt;a href=&quot;http://guide.meteor.com/structure.html#using-require&quot;&gt;안내서&lt;/a&gt; 에서 논의됩니다 .</target>
        </trans-unit>
        <trans-unit id="bc12c26db946350d18381d4c7cdc23beaa80e6b1" translate="yes" xml:space="preserve">
          <source>Note that files don&amp;rsquo;t need a &lt;code&gt;module.exports&lt;/code&gt; if they&amp;rsquo;re required like &lt;code&gt;routes.js&lt;/code&gt; is in this example, without assignment to any variable. The code in &lt;code&gt;routes.js&lt;/code&gt; will simply be included and executed in place of the above &lt;code&gt;require&lt;/code&gt; statement.</source>
          <target state="translated">이 예제에서 변수에 할당하지 않고 &lt;code&gt;routes.js&lt;/code&gt; 와 같이 필요한 경우 파일에 &lt;code&gt;module.exports&lt;/code&gt; 가 필요하지 않습니다 . &lt;code&gt;routes.js&lt;/code&gt; 의 코드 는 위의 &lt;code&gt;require&lt;/code&gt; 문 대신 간단히 포함되어 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="93cadc118af776bae6d3b4b2c7e609960d989eb5" translate="yes" xml:space="preserve">
          <source>Note that imports use relative paths, and include the file extension at the end of the file name.</source>
          <target state="translated">가져 오기는 상대 경로를 사용하고 파일 이름 끝에 파일 확장자를 포함시킵니다.</target>
        </trans-unit>
        <trans-unit id="792581652d1867279afe8225562a1571c2c368a3" translate="yes" xml:space="preserve">
          <source>Note that in Meteor&amp;rsquo;s publication and subscription system, it&amp;rsquo;s totally fine to publish the same document multiple times with different fields - they will get merged internally and the client will see a consistent document with all of the fields together. So if you just added one custom field, you should just write a publication with that one field. Let&amp;rsquo;s look at an example of how we might publish the &lt;code&gt;initials&lt;/code&gt; field from above:</source>
          <target state="translated">Meteor의 발행 및 구독 시스템에서는 서로 다른 필드를 사용하여 동일한 문서를 여러 번 게시하는 것이 좋습니다. 내부적으로 병합되며 클라이언트는 모든 필드가 함께 일관된 문서를 보게됩니다. 따라서 사용자 정의 필드를 하나만 추가 한 경우 해당 필드로 발행물을 작성해야합니다. 위에서 &lt;code&gt;initials&lt;/code&gt; 필드를 게시하는 방법에 대한 예를 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="6c40f369c466f5021002784e961ac858a5965f39" translate="yes" xml:space="preserve">
          <source>Note that simple string interpolations like this will always escape any HTML for you, so you don&amp;rsquo;t need to perform safety checks for XSS.</source>
          <target state="translated">이와 같은 간단한 문자열 보간은 항상 HTML을 이스케이프하므로 XSS에 대한 안전 검사를 수행 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a50be106236522bd9c0ff0d317ebdbb7c00309f0" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;import&lt;/code&gt; is &lt;code&gt;from 'meteor/my-modular-package'&lt;/code&gt;, not &lt;code&gt;from 'my-modular-package'&lt;/code&gt;. Meteor package identifier strings must include the prefix &lt;code&gt;meteor/...&lt;/code&gt; to disambiguate them from npm packages.</source>
          <target state="translated">참고 것을 &lt;code&gt;import&lt;/code&gt; 입니다 &lt;code&gt;from 'meteor/my-modular-package'&lt;/code&gt; 가 아니라 &lt;code&gt;from 'my-modular-package'&lt;/code&gt; . Meteor 패키지 식별자 문자열에는 &lt;code&gt;meteor/...&lt;/code&gt; 접두사가 포함되어 있어야 npm 패키지와 구별됩니다 .</target>
        </trans-unit>
        <trans-unit id="b2a93f74c7794a12b902d8c5ffa4cf2e28e05905" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;listId&lt;/code&gt; returned by the list method (which is the one generated by the client stub) is guaranteed to be the same as the one generated on the server, due to &lt;a href=&quot;methods#consistent-id-generation&quot;&gt;the way that Meteor generates IDs&lt;/a&gt; and ensures they are the same between client and server.</source>
          <target state="translated">점을 유의 &lt;code&gt;listId&lt;/code&gt; 는 (클라이언트 스텁에 의해 생성 된 하나 인)리스트 법에 의해 반환 된 인해 서버에서 생성 한 것과 동일하게 보장되는 &lt;a href=&quot;methods#consistent-id-generation&quot;&gt;유성 ID를 생성하는 방법&lt;/a&gt; 들이 클라이언트와 동일한 것이 확실를 그리고 서버.</target>
        </trans-unit>
        <trans-unit id="d815d0d77091af5ad8eb7632fd7ec45cbbfd6b87" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;onPageLoad&lt;/code&gt; callback function is allowed to return a &lt;code&gt;Promise&lt;/code&gt; if it needs to do any asynchronous work, and thus may be implemented by an &lt;code&gt;async&lt;/code&gt; function (as in the client case above).</source>
          <target state="translated">점을 유의 &lt;code&gt;onPageLoad&lt;/code&gt; 의 콜백 함수가 리턴시킨다 &lt;code&gt;Promise&lt;/code&gt; 는 비동기 작업을 할 필요가 있는지, 그리고, 따라서 의해 구현 될 수있는 &lt;code&gt;async&lt;/code&gt; (상기 클라이언트와 마찬가지로) 함수.</target>
        </trans-unit>
        <trans-unit id="4abf3fed06099d51d6f7e7e36eef0c059f0e028a" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;user&lt;/code&gt; object provided doesn&amp;rsquo;t have an &lt;code&gt;_id&lt;/code&gt; field yet. If you need to do something with the new user&amp;rsquo;s ID inside this function, a useful trick can be to generate the ID yourself:</source>
          <target state="translated">있습니다 &lt;code&gt;user&lt;/code&gt; 제공 객체가없는 &lt;code&gt;_id&lt;/code&gt; 아직 필드. 이 함수 안에서 새로운 사용자의 ID로 무언가를해야한다면, ID를 직접 생성하는 것이 유용한 트릭입니다 :</target>
        </trans-unit>
        <trans-unit id="d3ffd8f15ff7a4206edb0285c3853031336366e6" translate="yes" xml:space="preserve">
          <source>Note that the Meteor release version number is mostly a marketing artifact - the core Meteor packages themselves typically don&amp;rsquo;t share this version number. This means packages can only depend on specific versions of the packages inside a Meteor release, but can&amp;rsquo;t depend on a specific release itself. We have a helpful shorthand api called &lt;a href=&quot;http://docs.meteor.com/#/full/pack_versions&quot;&gt;&lt;code&gt;api.versionsFrom&lt;/code&gt;&lt;/a&gt; that handles this for you by automatically filling in package version numbers from a particular release:</source>
          <target state="translated">Meteor 릴리스 버전 번호는 대부분 마케팅 아티팩트입니다. 핵심 Meteor 패키지 자체는 일반적으로이 버전 번호를 공유하지 않습니다. 이는 패키지가 Meteor 릴리스 내의 특정 패키지 버전에만 의존 할 수 있지만 특정 릴리스 자체에는 의존 할 수 없음을 의미합니다. &lt;a href=&quot;http://docs.meteor.com/#/full/pack_versions&quot;&gt; &lt;code&gt;api.versionsFrom&lt;/code&gt; &lt;/a&gt; 이라는 유용한 속기 api가 있는데 , 특정 릴리스의 패키지 버전 번호를 자동으로 채워서이를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="08fc6ead1fab45341f05e7389a1516ae47ccbe70" translate="yes" xml:space="preserve">
          <source>Note that the above two points interact in a way that can be surprising! If &lt;code&gt;foo&lt;/code&gt; is a template helper function that returns another template, then &lt;code&gt;{{&amp;gt;foo bar}}&lt;/code&gt; will &lt;em&gt;first&lt;/em&gt; push &lt;code&gt;bar&lt;/code&gt; onto the data context stack &lt;em&gt;then&lt;/em&gt; call &lt;code&gt;foo()&lt;/code&gt;, due to the way this line is expanded as shown above. You will need to use &lt;code&gt;Template.parentData(1)&lt;/code&gt; to access the original context. This differs from regular helper calls like &lt;code&gt;{{foo bar}}&lt;/code&gt;, in which &lt;code&gt;bar&lt;/code&gt; is passed as a parameter rather than pushed onto the data context stack.</source>
          <target state="translated">위의 두 지점은 놀라운 방식으로 상호 작용합니다. &lt;code&gt;foo&lt;/code&gt; 가 다른 템플리트를 리턴하는 템플리트 헬퍼 함수 인 경우 , &lt;code&gt;{{&amp;gt;foo bar}}&lt;/code&gt; 는 &lt;em&gt;먼저&lt;/em&gt; 데이터 컨텍스트 스택으로 &lt;code&gt;bar&lt;/code&gt; 를 푸시 &lt;em&gt;한 다음&lt;/em&gt; 위에 표시된대로이 행이 확장되는 방식으로 인해 &lt;code&gt;foo()&lt;/code&gt; &lt;em&gt;를&lt;/em&gt; 호출 합니다. 원본 컨텍스트에 액세스 하려면 &lt;code&gt;Template.parentData(1)&lt;/code&gt; 를 사용해야합니다. 이는 &lt;code&gt;{{foo bar}}&lt;/code&gt; 와 같은 일반 도우미 호출과 다르며 , 여기서 &lt;code&gt;bar&lt;/code&gt; 는 데이터 컨텍스트 스택으로 푸시되지 않고 매개 변수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="fbbecc58e880b83f20dd8d3074ed3ef53362a97b" translate="yes" xml:space="preserve">
          <source>Note that the argument to &lt;code&gt;#unless&lt;/code&gt; (the condition) becomes the data context in the &lt;code&gt;unless&lt;/code&gt; template and is accessed via &lt;code&gt;this&lt;/code&gt;. However, it would not work very well if this data context was visible to &lt;code&gt;Template.contentBlock&lt;/code&gt;, which is supplied by the user of &lt;code&gt;unless&lt;/code&gt;.</source>
          <target state="translated">인수에 유의 &lt;code&gt;#unless&lt;/code&gt; (조건)가 상기 데이터 컨텍스트된다 &lt;code&gt;unless&lt;/code&gt; 주형 통해 접근 &lt;code&gt;this&lt;/code&gt; . 그러나, 그것은 아주 잘이 데이터 컨텍스트가 볼 수 있다면 작동하지 않을 &lt;code&gt;Template.contentBlock&lt;/code&gt; 의 사용자가 제공되어, &lt;code&gt;unless&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="884589830f37017e057a6fe2a2cb843e31a9ba15" translate="yes" xml:space="preserve">
          <source>Note that the mergebox operates at the level of top-level fields, so if two subscriptions publish nested fields (e.g. sub1 publishes &lt;code&gt;doc.a.b = 7&lt;/code&gt; and sub2 publishes &lt;code&gt;doc.a.c = 8&lt;/code&gt;), then the &amp;ldquo;merged&amp;rdquo; document might not look as you expect (in this case &lt;code&gt;doc.a = {c: 8}&lt;/code&gt;, if sub2 happens second).</source>
          <target state="translated">mergebox는 최상위 필드 수준에서 작동하므로 두 구독이 중첩 된 필드를 게시하면 (예 : sub1은 &lt;code&gt;doc.a.b = 7&lt;/code&gt; 을 게시하고 sub2는 &lt;code&gt;doc.a.c = 8&lt;/code&gt; 게시 ), &quot;병합 된&quot;문서는 다음과 같이 보이지 않을 수 있습니다. 당신은 기대합니다 (이 경우 &lt;code&gt;doc.a = {c: 8}&lt;/code&gt; , sub2가 두 번째 발생하는 경우).</target>
        </trans-unit>
        <trans-unit id="9be0709239c592dd52ce0c0fae8792fb7b9173b3" translate="yes" xml:space="preserve">
          <source>Note that the schema is different when users register with different login services. There are a few things to be aware of when dealing with this collection:</source>
          <target state="translated">사용자가 다른 로그인 서비스에 등록 할 때 스키마가 다릅니다. 이 컬렉션을 다룰 때 알아 두어야 할 몇 가지 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb0913f962e9e0be162efe1f8d4b737e668e85f2" translate="yes" xml:space="preserve">
          <source>Note that the version solver also has a concept of &amp;ldquo;gravity&amp;rdquo; - when many solutions are possible for a certain set of dependencies, it always selects the oldest possible version. This is helpful if you are trying to develop a package to ship to lots of users, since it ensures your package will be compatible with the lowest common denominator of a dependency. If your package needs a newer version than is currently being selected for a certain dependency, you need to update your &lt;code&gt;package.js&lt;/code&gt; to have a newer version constraint.</source>
          <target state="translated">버전 솔버에는 &quot;중력&quot;이라는 개념도 있습니다. 특정 종속성 세트에 대해 많은 솔루션이 가능한 경우 항상 가장 오래된 버전을 선택합니다. 패키지가 종속성의 가장 낮은 공통 분모와 호환되도록하기 때문에 많은 사용자에게 제공 할 패키지를 개발하려는 경우에 유용합니다. 패키지가 현재 특정 종속성에 대해 선택된 것보다 최신 버전을 필요로 하는 경우, 새로운 버전 제약 조건을 갖도록 &lt;code&gt;package.js&lt;/code&gt; 를 업데이트해야합니다 .</target>
        </trans-unit>
        <trans-unit id="02a50208d8a75b80f387cf64a9878f40a28fbc6d" translate="yes" xml:space="preserve">
          <source>Note that there a few caveats:</source>
          <target state="translated">몇 가지주의 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d59ec0b1608b7a8f47fa3339fa7de7cc9d4a89ba" translate="yes" xml:space="preserve">
          <source>Note that there are some exceptions to this second rule. A common one is &lt;code&gt;Meteor.user()&lt;/code&gt;&amp;mdash;although this is strictly speaking subscribed to (automatically usually), it&amp;rsquo;s typically over-complicated to pass it through the component hierarchy as an argument to each component. However keep in mind it&amp;rsquo;s best not to use it in too many places as it makes components harder to test.</source>
          <target state="translated">이 두 번째 규칙에는 예외가 있습니다. 일반적으로 &lt;code&gt;Meteor.user()&lt;/code&gt; 는 (자동으로 일반적으로) 구독을 엄격하게 말하고 있지만 구성 요소 계층을 통해 각 구성 요소에 대한 인수로 전달하기 위해 지나치게 복잡합니다. 그러나 구성 요소를 테스트하기가 어려워 너무 많은 곳에서 사용하지 않는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c71167324d950d0a6ff2b27f2935d963a3d668a2" translate="yes" xml:space="preserve">
          <source>Note that there is a benefit to restricting the places you access the current user to make your UI more testable and modular. Read more about this in the &lt;a href=&quot;ui-ux#global-stores&quot;&gt;UI article&lt;/a&gt;.</source>
          <target state="translated">UI를보다 테스트하고 모듈화 할 수 있도록 현재 사용자에게 액세스하는 장소를 제한하면 이점이 있습니다. 이에 대한 자세한 내용은 &lt;a href=&quot;ui-ux#global-stores&quot;&gt;UI 기사를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c51adc30d6eb693757b85dc37dcc6afa69ab976b" translate="yes" xml:space="preserve">
          <source>Note that there is another test command in the Meteor tool; &lt;code&gt;meteor test-packages&lt;/code&gt; is a way of testing Atmosphere packages, which is discussed in the &lt;a href=&quot;https://guide.meteor.com/writing-packages.html#testing&quot;&gt;Writing Packages article&lt;/a&gt;.</source>
          <target state="translated">Meteor 도구에는 다른 테스트 명령이 있습니다. &lt;code&gt;meteor test-packages&lt;/code&gt; 는 패키지 &lt;a href=&quot;https://guide.meteor.com/writing-packages.html#testing&quot;&gt;작성 기사&lt;/a&gt; 에서 설명하는 분위기 패키지를 테스트하는 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="545dc436496696fdfc589d432602147dfa408c3c" translate="yes" xml:space="preserve">
          <source>Note that these restrictions mean you will have to explicitly allow loading &lt;code&gt;data:&lt;/code&gt; URLs. For example, to allow loading &lt;code&gt;data:&lt;/code&gt; URLs in iframes you would add:</source>
          <target state="translated">이러한 제한 사항은 &lt;code&gt;data:&lt;/code&gt; 로드를 명시 적으로 허용해야한다는 것을 의미합니다 . URL. 예를 들어 &lt;code&gt;data:&lt;/code&gt; 로드를 허용 하려면 iframe의 URL을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="4f8ec097736539acca8b3c2f8245f00e4b7789fc" translate="yes" xml:space="preserve">
          <source>Note that this code sample uses the &lt;a href=&quot;methods#validated-method&quot;&gt;ValidatedMethod package recommended in the Methods article&lt;/a&gt;. If you aren&amp;rsquo;t using that package, you can use the name as the property passed to &lt;code&gt;Meteor.methods&lt;/code&gt;.</source>
          <target state="translated">이 코드 샘플은 &lt;a href=&quot;methods#validated-method&quot;&gt;Methods 기사에서 권장&lt;/a&gt; 하는 ValidatedMethod 패키지를 사용합니다 . 해당 패키지를 사용하지 않는 경우 이름을 &lt;code&gt;Meteor.methods&lt;/code&gt; 에 전달 된 속성으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ea45ed0c2e9e4f66096c4f89efbeded41baae4b0" translate="yes" xml:space="preserve">
          <source>Note that this package is based on &lt;strong&gt;mailcomposer 4&lt;/strong&gt;, so make sure to refer to &lt;a href=&quot;https://github.com/nodemailer/mailcomposer/blob/v4.0.1/README.md&quot;&gt;the documentation&lt;/a&gt; for that version when using the &lt;code&gt;attachments&lt;/code&gt; or &lt;code&gt;mailComposer&lt;/code&gt; options.</source>
          <target state="translated">이 패키지는 &lt;strong&gt;mailcomposer 4를&lt;/strong&gt; 기반으로 하므로 &lt;code&gt;attachments&lt;/code&gt; 또는 &lt;code&gt;mailComposer&lt;/code&gt; 옵션을 사용할 때 해당 버전 &lt;a href=&quot;https://github.com/nodemailer/mailcomposer/blob/v4.0.1/README.md&quot;&gt;의 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fbd1ee7264593915397aac36c8e2e69b77f9f954" translate="yes" xml:space="preserve">
          <source>Note that user documents &amp;ndash; ones that you would normally query with &lt;code&gt;Meteor.users.find()&lt;/code&gt; &amp;ndash; will be available as the key &lt;code&gt;users&lt;/code&gt; on the dictionary passed from a &lt;code&gt;PublicationCollector.collect()&lt;/code&gt; call. See the &lt;a href=&quot;https://github.com/johanbrook/meteor-publication-collector/blob/master/tests/publication-collector.test.js&quot;&gt;tests&lt;/a&gt; in the package for more details.</source>
          <target state="translated">일반적으로 &lt;code&gt;Meteor.users.find()&lt;/code&gt; 쿼리하는 사용자 문서 는 &lt;code&gt;PublicationCollector.collect()&lt;/code&gt; 호출 에서 전달 된 사전 의 주요 &lt;code&gt;users&lt;/code&gt; 로 제공됩니다 . 자세한 내용은 패키지 의 &lt;a href=&quot;https://github.com/johanbrook/meteor-publication-collector/blob/master/tests/publication-collector.test.js&quot;&gt;테스트&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="97d83ef52447c8fa719b5ee359b297daea157b9a" translate="yes" xml:space="preserve">
          <source>Note that using keyword arguments to helpers is a little awkward, so in general it&amp;rsquo;s usually easier to avoid them. This feature was included for historical reasons to match the way keyword arguments work in Handlebars.</source>
          <target state="translated">도우미에 키워드 인수를 사용하는 것은 약간 어색하므로 일반적으로 피하기가 더 쉽습니다. 이 기능은 역사적으로 인해 핸들 바에서 키워드 인수가 작동하는 방식과 일치하도록 포함되었습니다.</target>
        </trans-unit>
        <trans-unit id="fc57862243e6a3d2a7698b732f35407da9b99cb1" translate="yes" xml:space="preserve">
          <source>Note that we can check for multiple roles at once, and if someone has a role in the &lt;code&gt;GLOBAL_GROUP&lt;/code&gt;, they are considered as having that role in every group. In this case, the groups were by category ID, but you could use any unique identifier to make a group.</source>
          <target state="translated">한 번에 여러 역할을 확인할 수 있으며 누군가 &lt;code&gt;GLOBAL_GROUP&lt;/code&gt; 에 역할이 있으면 모든 그룹에서 해당 역할을 가진 것으로 간주됩니다. 이 경우 그룹은 카테고리 ID별로 있지만 고유 식별자를 사용하여 그룹을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c59729aa03179ea61172e1be10c7284817526e8" translate="yes" xml:space="preserve">
          <source>Note that we could make this migration faster by using an &lt;a href=&quot;https://docs.mongodb.org/v2.6/aggregation/&quot;&gt;Aggregation&lt;/a&gt; to gather the initial set of todo counts.</source>
          <target state="translated">&lt;a href=&quot;https://docs.mongodb.org/v2.6/aggregation/&quot;&gt;집계&lt;/a&gt; 를 사용 하여 초기 할 일 수를 수집하면 이 마이그레이션을 더 빠르게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5200147dc768e2ecdf4b6fad0c110f14babfbd2" translate="yes" xml:space="preserve">
          <source>Note that we explicitly set the &lt;code&gt;Meteor.users&lt;/code&gt; query fields, as &lt;code&gt;publish-composite&lt;/code&gt; publishes all of the returned cursors to the client and re-runs the child computations whenever the cursor changes.</source>
          <target state="translated">&lt;code&gt;publish-composite&lt;/code&gt; 가 반환 된 모든 커서를 클라이언트에 게시 하고 커서가 변경 될 때마다 자식 계산을 다시 실행하므로 &lt;code&gt;Meteor.users&lt;/code&gt; 쿼리 필드를 명시 적으로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="e18a74dc4da8ae8659fde058ae25d096ddd9b335" translate="yes" xml:space="preserve">
          <source>Note that we have specified a password reset route. Normally, we would have to configure Meteor&amp;rsquo;s accounts system to send this route in password reset emails, but the &lt;code&gt;useraccounts:flow-routing&lt;/code&gt; package does it for us. &lt;a href=&quot;#email-flows&quot;&gt;Read more about configuring email flows below.&lt;/a&gt;</source>
          <target state="translated">비밀번호 재설정 경로를 지정했습니다. 일반적으로 암호 재설정 이메일로이 경로를 보내도록 Meteor의 계정 시스템을 구성해야하지만 &lt;code&gt;useraccounts:flow-routing&lt;/code&gt; 패키지가이를 수행합니다. &lt;a href=&quot;#email-flows&quot;&gt;이메일 흐름 구성에 대한 자세한 내용은 아래를 참조하십시오.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96e340fac5190d8fa1d00913a56be97e7c49556b" translate="yes" xml:space="preserve">
          <source>Note that we only handled the mutators we actually use in the application&amp;mdash;we don&amp;rsquo;t deal with all possible ways the todo count on a list could change. For example, if you changed the &lt;code&gt;listId&lt;/code&gt; on a todo item, it would need to change the &lt;code&gt;incompleteCount&lt;/code&gt; of &lt;em&gt;two&lt;/em&gt; lists. However, since our application doesn&amp;rsquo;t do this, we don&amp;rsquo;t handle it in the denormalizer.</source>
          <target state="translated">애플리케이션에서 실제로 사용하는 뮤 테이터 만 처리 했으므로 목록의 할 일 수가 변경 될 수있는 모든 가능한 방법을 다루지는 않습니다. 당신이 변경된 경우 예를 들어, &lt;code&gt;listId&lt;/code&gt; 을 할 일 항목에, 그것은 변경해야 &lt;code&gt;incompleteCount&lt;/code&gt; 의 &lt;em&gt;두&lt;/em&gt; 목록을. 그러나 응용 프로그램에서이 작업을 수행하지 않기 때문에 디노 말 라이저에서 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="028811cff2ee5ae313cd61a9676aaaf382947bb6" translate="yes" xml:space="preserve">
          <source>Note that we&amp;rsquo;ve exported a client-side symbol &lt;code&gt;generateData&lt;/code&gt; which is a promisified version of the method call, which makes it simpler to use this sequentially in tests.</source>
          <target state="translated">메소드 호출의 약속 된 버전 인 클라이언트 측 심볼 &lt;code&gt;generateData&lt;/code&gt; 를 내보냈으므로 테스트에서 순차적으로 사용하는 것이 더 간단 해졌습니다.</target>
        </trans-unit>
        <trans-unit id="fcfcc0c37fe95dd2bcc756e40a58d73c0a695a01" translate="yes" xml:space="preserve">
          <source>Note that when &lt;code&gt;fields&lt;/code&gt; are specified, only changes to the included fields will trigger callbacks in &lt;code&gt;observe&lt;/code&gt;, &lt;code&gt;observeChanges&lt;/code&gt; and invalidations in reactive computations using this cursor. Careful use of &lt;code&gt;fields&lt;/code&gt; allows for more fine-grained reactivity for computations that don&amp;rsquo;t depend on an entire document.</source>
          <target state="translated">때 참고 &lt;code&gt;fields&lt;/code&gt; 지정 만에 콜백 트리거 포함 된 필드로 변경 &lt;code&gt;observe&lt;/code&gt; , &lt;code&gt;observeChanges&lt;/code&gt; 이 커서를 사용하여 반응 계산 및 무효화합니다. &lt;code&gt;fields&lt;/code&gt; 주의해서 사용 하면 전체 문서에 의존하지 않는 계산에보다 세분화 된 반응성이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="c295a388ba5bb73377425610a4543f94fcb272ee" translate="yes" xml:space="preserve">
          <source>Note that while the Method is defined on the client, the actual secret logic is only accessible from the server. Keep in mind that code inside &lt;code&gt;if (Meteor.isServer)&lt;/code&gt; blocks is still sent to the client, it is just not executed. So don&amp;rsquo;t put any secret code in there.</source>
          <target state="translated">메소드가 클라이언트에 정의되어있는 동안 실제 비밀 논리는 서버에서만 액세스 할 수 있습니다. &lt;code&gt;if (Meteor.isServer)&lt;/code&gt; 블록이 여전히 클라이언트로 전송 되면 내부 코드 는 실행되지 않습니다. 비밀 코드를 넣지 마십시오.</target>
        </trans-unit>
        <trans-unit id="676c56d9e000c0c0d4c59b390c203c4403f79727" translate="yes" xml:space="preserve">
          <source>Note that you can also install Chimp as a &lt;code&gt;devDependency&lt;/code&gt; in your &lt;code&gt;package.json&lt;/code&gt; but you may run into problems deploying your application as it includes binary dependencies. You can avoid such problems by running &lt;code&gt;meteor npm prune&lt;/code&gt; to remove non-production dependencies before deploying.</source>
          <target state="translated">&lt;code&gt;package.json&lt;/code&gt; 에 &lt;code&gt;devDependency&lt;/code&gt; 로 Chimp를 설치할 수도 있지만 이진 종속성이 포함되어 있으므로 응용 프로그램을 배포하는 데 문제가 발생할 수 있습니다. 배포하기 전에 &lt;code&gt;meteor npm prune&lt;/code&gt; 을 실행 하여 비 프로덕션 종속성을 제거하면 이러한 문제를 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c139b70a7c79fcccbfe21055b18c13e0fa9042f" translate="yes" xml:space="preserve">
          <source>Note: Ensure that you have secure backups of your keystore (&lt;code&gt;~/.keystore&lt;/code&gt; is the default). If you publish an app to the Play Store and then lose the key with which you signed your app, you will not be able to publish any updates to your app, since you must always sign all versions of your app with the same key.</source>
          <target state="translated">참고 : 키 저장소의 보안 백업이 있는지 확인하십시오 ( &lt;code&gt;~/.keystore&lt;/code&gt; 가 기본값 임). 앱을 Play 스토어에 게시 한 다음 앱에 서명 한 키를 잃어버린 경우 항상 동일한 키를 사용하여 모든 버전의 앱에 서명해야하므로 앱에 대한 업데이트를 게시 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="035e37e04f4175f2374f5dcc2b6cf06bbdd1d271" translate="yes" xml:space="preserve">
          <source>Note: If multiple Meteor packages add the same Cordova plugin but at different versions, there is no clear way of telling which version will end up being installed. Plugins added to your project directly however, will always override versions of the same plugin added as a dependency of packages.</source>
          <target state="translated">참고 : 여러 Meteor 패키지가 동일한 Cordova 플러그인을 추가하지만 버전이 다른 경우 어떤 버전이 설치 될지 알 수있는 명확한 방법이 없습니다. 그러나 프로젝트에 직접 추가 된 플러그인은 항상 패키지 종속성으로 추가 된 동일한 플러그인의 버전을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="39819a23f3cc7b66b2e98d1d9a40fe90c0cadf50" translate="yes" xml:space="preserve">
          <source>Note: If you haven&amp;rsquo;t previously developed iOS apps, or haven&amp;rsquo;t used the connected device for development, a series of dialogs and warnings may appear as Xcode resolves code signing issues. It may also prompt you for permission to access the key in your keychain. See &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/AppDistributionGuide/LaunchingYourApponDevices/LaunchingYourApponDevices.html#//apple_ref/doc/uid/TP40012582-CH27-SW4&quot;&gt;Apple&amp;rsquo;s instructions&lt;/a&gt; for more information. You will also need to join the &lt;a href=&quot;https://developer.apple.com/programs/&quot;&gt;Apple Developer Program&lt;/a&gt; to deploy your app on the Apple iOS App Store.</source>
          <target state="translated">참고 : 이전에 iOS 앱을 개발하지 않았거나 연결된 장치를 개발에 사용하지 않은 경우 Xcode가 코드 서명 문제를 해결함에 따라 일련의 대화 상자 및 경고가 나타날 수 있습니다. 키 체인의 키에 액세스 할 수있는 권한을 묻는 메시지가 표시 될 수도 있습니다. 자세한 내용은 &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/IDEs/Conceptual/AppDistributionGuide/LaunchingYourApponDevices/LaunchingYourApponDevices.html#//apple_ref/doc/uid/TP40012582-CH27-SW4&quot;&gt;Apple 지침&lt;/a&gt; 을 참조하십시오. 또한 Apple iOS 앱 스토어에 앱을 배포 하려면 &lt;a href=&quot;https://developer.apple.com/programs/&quot;&gt;Apple Developer Program&lt;/a&gt; 에 가입해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a14ac80a5ac061149a27a2700dfe219219fdec9a" translate="yes" xml:space="preserve">
          <source>Note: If you&amp;rsquo;re using older version of Meteor, you may also need to install an older version of Android SDK, for example with the Android SDK Manager that comes with Android Studio.</source>
          <target state="translated">참고 : 이전 버전의 Meteor를 사용하는 경우 Android Studio와 함께 제공되는 Android SDK 관리자와 같이 이전 버전의 Android SDK를 설치해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cc7b510ece2c6ccec5177032f3b2cf962a42712" translate="yes" xml:space="preserve">
          <source>Note: Packages can only access their own assets. If you need to read the assets of a different package, or of the enclosing app, you need to get a reference to that package&amp;rsquo;s &lt;code&gt;Assets&lt;/code&gt; object.</source>
          <target state="translated">참고 : 패키지는 자신의 자산에만 액세스 할 수 있습니다. 다른 패키지 또는 엔 클로징 앱의 자산을 읽어야하는 경우 해당 패키지의 &lt;code&gt;Assets&lt;/code&gt; 객체에 대한 참조를 가져와야 합니다.</target>
        </trans-unit>
        <trans-unit id="55e71576e444e611aadfa22689c504d789350e30" translate="yes" xml:space="preserve">
          <source>Note: Packages with &lt;code&gt;lazy&lt;/code&gt; main modules cannot use &lt;code&gt;api.export&lt;/code&gt; to export global symbols to other packages/apps. Also, prior to Meteor 1.4.4.2 it is neccessary to explicitly name the file containing the module: &lt;code&gt;import &quot;meteor/&amp;lt;package name&amp;gt;/client.js&quot;&lt;/code&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;lazy&lt;/code&gt; 기본 모듈이있는 패키지는 &lt;code&gt;api.export&lt;/code&gt; 를 사용 하여 전역 심볼을 다른 패키지 / 앱으로 내보낼 수 없습니다 . 또한 Meteor 1.4.4.2 이전에는 &lt;code&gt;import &quot;meteor/&amp;lt;package name&amp;gt;/client.js&quot;&lt;/code&gt; 모듈을 포함하는 파일의 이름을 명시 적으로 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b2c9ddec9456dd0e816d18f0ed939daa1d9f5567" translate="yes" xml:space="preserve">
          <source>Note: Prior to Meteor 1.4.2, &lt;code&gt;METEOR_PACKAGE_DIRS&lt;/code&gt; was simply &lt;code&gt;PACKAGE_DIRS&lt;/code&gt;. For compatibility reasons, developers should use &lt;code&gt;METEOR_PACKAGE_DIRS&lt;/code&gt; going forward.</source>
          <target state="translated">참고 : Meteor 1.4.2 이전에는 &lt;code&gt;METEOR_PACKAGE_DIRS&lt;/code&gt; 가 단순히 &lt;code&gt;PACKAGE_DIRS&lt;/code&gt; 였습니다. 호환성을 위해 개발자는 앞으로 &lt;code&gt;METEOR_PACKAGE_DIRS&lt;/code&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="3cb6b6e3876fb61ac8daaf652acd7d8f45139da9" translate="yes" xml:space="preserve">
          <source>Note: Since we need to access context on &lt;code&gt;this&lt;/code&gt; we need to use the &lt;code&gt;function() {}&lt;/code&gt; form for publications rather than the ES2015 &lt;code&gt;() =&amp;gt; {}&lt;/code&gt;. You can disable the arrow function linting rule for publication files with &lt;code&gt;eslint-disable prefer-arrow-callback&lt;/code&gt;. A future version of the publication API will work more nicely with ES2015.</source>
          <target state="translated">참고 : 우리는에 액세스 컨텍스트에 필요하기 때문에 &lt;code&gt;this&lt;/code&gt; 우리가 사용할 필요가 &lt;code&gt;function() {}&lt;/code&gt; 보다는 출판물 형태를 ES2015 &lt;code&gt;() =&amp;gt; {}&lt;/code&gt; . &lt;code&gt;eslint-disable prefer-arrow-callback&lt;/code&gt; 을 사용 하여 게시 파일에 대해 화살표 기능 linting 규칙을 비활성화 할 수 있습니다 . 이후 버전의 게시 API는 ES2015와 더 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="988ef8f0c805ab181194f85d300b6976bdc58a02" translate="yes" xml:space="preserve">
          <source>Note: You don&amp;rsquo;t have to do this if you&amp;rsquo;re using &lt;code&gt;useraccounts&lt;/code&gt;. It disables the regular Meteor client-side account creation functions for you and does custom validation.</source>
          <target state="translated">참고 : &lt;code&gt;useraccounts&lt;/code&gt; 를 사용하는 경우이 작업을 수행 할 필요가 없습니다 . 일반 Meteor 클라이언트 측 계정 생성 기능을 비활성화하고 사용자 지정 유효성 검사를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="840b63131bfe381e1e921ba9e151de57467f386c" translate="yes" xml:space="preserve">
          <source>Note: in a larger application, given that the todos themselves are a part of a list, it might make sense to group both of these domains into a single larger &amp;ldquo;list&amp;rdquo; module. The Todos example is small enough that we need to separate these only to demonstrate modularity.</source>
          <target state="translated">참고 : 더 큰 응용 프로그램에서 할 일 자체가 목록의 일부인 경우이 두 도메인을 하나의 더 큰 &quot;목록&quot;모듈로 그룹화하는 것이 좋습니다. Todos 예제는 모듈성을 보여주기 위해서만 분리해야 할 정도로 작습니다.</target>
        </trans-unit>
        <trans-unit id="f565ae64e9a95cf65b05d8c3af6eff5a687558cf" translate="yes" xml:space="preserve">
          <source>Nothing in the Meteor guide is &lt;em&gt;required&lt;/em&gt; to build a Meteor application&amp;mdash;you can certainly use the platform in ways that contradict the principles and patterns of the guide. However, the guide is an attempt to document best practices and community conventions, so we hope that the majority of the Meteor community will benefit from adopting the practices documented here.</source>
          <target state="translated">Meteor 응용 프로그램을 구축하는 &lt;em&gt;데&lt;/em&gt; Meteor 가이드의 어떤 것도 &lt;em&gt;필요&lt;/em&gt; 하지 않습니다. 가이드 의 원칙과 패턴에 위배되는 방식으로 플랫폼을 사용할 수 있습니다. 그러나이 가이드는 모범 사례와 커뮤니티 컨벤션을 문서화하려는 시도이므로 대부분의 Meteor 커뮤니티가 여기에 문서화 된 프랙티스를 채택하면 도움이되기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="badfb943d8601c2984dcaa8b030270c131e1174b" translate="yes" xml:space="preserve">
          <source>Notice that in this component we are also accessing the global client-side state store &lt;code&gt;FlowRouter&lt;/code&gt;, which we wrap in a instance method called &lt;code&gt;getListId()&lt;/code&gt;. This instance method is called both from the &lt;code&gt;autorun&lt;/code&gt; in &lt;code&gt;onCreated&lt;/code&gt;, and from the &lt;code&gt;listIdArray&lt;/code&gt; helper:</source>
          <target state="translated">이 컴포넌트에서 글로벌 클라이언트 측 상태 저장소 &lt;code&gt;FlowRouter&lt;/code&gt; 에 액세스하고 있으며 &lt;code&gt;getListId()&lt;/code&gt; 라는 인스턴스 메소드로 랩핑 합니다. 이 인스턴스 방법은에서 두라고 &lt;code&gt;autorun&lt;/code&gt; 에 &lt;code&gt;onCreated&lt;/code&gt; 과에서 &lt;code&gt;listIdArray&lt;/code&gt; 의 도우미 :</target>
        </trans-unit>
        <trans-unit id="8b772971430bc5be5a9a6196e94ad8e641dfe8f8" translate="yes" xml:space="preserve">
          <source>Notice that this is just the normal JavaScript syntax for declaring a variable that is local or global. Meteor scans your source code for global variable assignments and generates a wrapper that makes sure that your globals don&amp;rsquo;t escape their appropriate namespace.</source>
          <target state="translated">이것은 로컬 또는 전역 변수를 선언하기위한 일반적인 JavaScript 구문 일뿐입니다. Meteor는 소스 변수에서 전역 변수 할당을 스캔하고 전역이 적절한 네임 스페이스를 벗어나지 않도록하는 래퍼를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6b3aef94b7846ada34d09773d8a11b96bc941c45" translate="yes" xml:space="preserve">
          <source>Notice that we called the component to be rendered &lt;code&gt;Lists_show_page&lt;/code&gt; (rather than &lt;code&gt;Lists_show&lt;/code&gt;). This indicates that this template is rendered directly by a Flow Router action and forms the &amp;lsquo;top&amp;rsquo; of the rendering hierarchy for this URL.</source>
          <target state="translated">컴포넌트를 &lt;code&gt;Lists_show_page&lt;/code&gt; 가 아닌 &lt;code&gt;Lists_show&lt;/code&gt; _page 로 렌더링하도록 호출했습니다 . 이는이 템플리트가 플로우 라우터 조치에 의해 직접 렌더링되고이 URL에 대한 렌더링 계층의 '상단'을 형성 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ed7b51de0c92c0bddd64aff183ec7a9a4e404763" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;left-pad&lt;/code&gt; is included in your &lt;code&gt;package.json&lt;/code&gt;, and the code has been downloaded to &lt;code&gt;node_modules/left_pad/&lt;/code&gt;. Add the new directory to source control with:</source>
          <target state="translated">이제 &lt;code&gt;left-pad&lt;/code&gt; 가 &lt;code&gt;package.json&lt;/code&gt; 에 포함되었으며 코드는 &lt;code&gt;node_modules/left_pad/&lt;/code&gt; 다운로드되었습니다 . 다음을 사용하여 소스 제어에 새 디렉토리를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="3f17930a739be5d85a97a9f947f14783999c6ccb" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;server.js&lt;/code&gt; and &lt;code&gt;client.js&lt;/code&gt; can import other files from the package source directory, even if those files have not been added using the &lt;code&gt;api.addFiles&lt;/code&gt; function.</source>
          <target state="translated">이제 &lt;code&gt;server.js&lt;/code&gt; 및 &lt;code&gt;client.js&lt;/code&gt; 는 &lt;code&gt;api.addFiles&lt;/code&gt; 함수를 사용하여 파일을 추가하지 않은 경우에도 패키지 소스 디렉토리에서 다른 파일을 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4fe266c65dea7ef67a5f8d4dfd4744acf9124103" translate="yes" xml:space="preserve">
          <source>Now apps that include this package can do:</source>
          <target state="translated">이제이 패키지가 포함 된 앱은 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fa0781f8231e2d6a7a3d68cec2957c10dc140a7" translate="yes" xml:space="preserve">
          <source>Now calling the Method is as simple as calling a JavaScript function:</source>
          <target state="translated">이제 메소드를 호출하는 것은 JavaScript 함수를 호출하는 것만 큼 간단합니다.</target>
        </trans-unit>
        <trans-unit id="266ca65aa2ddddba3fc94df5a25062f132143c6b" translate="yes" xml:space="preserve">
          <source>Now just open your app, follow the configuration steps, and you&amp;rsquo;re good to go - if you&amp;rsquo;ve done the &lt;a href=&quot;https://www.meteor.com/tutorials/blaze/adding-user-accounts&quot;&gt;Meteor tutorial&lt;/a&gt;, you&amp;rsquo;ve already seen this in action. Of course, in a production application, you probably want a more custom user interface and some logic to have a more tailored UX, but that&amp;rsquo;s why we have the rest of this guide.</source>
          <target state="translated">이제 앱을 열고 구성 단계를 따르십시오. &lt;a href=&quot;https://www.meteor.com/tutorials/blaze/adding-user-accounts&quot;&gt;Meteor 튜토리얼&lt;/a&gt; 을 마치면 이미 작동하는 것을 볼 수 있습니다. 물론 프로덕션 응용 프로그램에서는 더 맞춤화 된 UX를 갖기 위해 더 많은 사용자 지정 사용자 인터페이스와 일부 논리를 원할 수 있지만이 가이드의 나머지 부분을 보유하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfadb11907bcf09c8efb15a9cadf25f26125810f" translate="yes" xml:space="preserve">
          <source>Now that the routes are setup on the server, they can be accessed from the browser (e.g. &lt;code&gt;example.com/reset-password&lt;/code&gt;). To create links to these routes in a template, it&amp;rsquo;s best to use a helper method provided by the router. For Flow Router, the &lt;a href=&quot;https://github.com/arillo/meteor-flow-router-helpers/&quot;&gt;&lt;code&gt;arillo:flow-router-helpers&lt;/code&gt;&lt;/a&gt; package provides a &lt;code&gt;pathFor&lt;/code&gt; helper for just this purpose. Once installed, the following is possible in a template:</source>
          <target state="translated">이제 경로가 서버에 설정 &lt;code&gt;example.com/reset-password&lt;/code&gt; 브라우저에서 액세스 할 수 있습니다 (예 : example.com/reset-password ). 템플릿에서 이러한 경로에 대한 링크를 만들려면 라우터에서 제공하는 도우미 방법을 사용하는 것이 가장 좋습니다. 흐름 라우터는 들어 &lt;a href=&quot;https://github.com/arillo/meteor-flow-router-helpers/&quot;&gt; &lt;code&gt;arillo:flow-router-helpers&lt;/code&gt; &lt;/a&gt; 패키지는 제공 &lt;code&gt;pathFor&lt;/code&gt; 의 이러한 목적을위한 도우미. 일단 설치되면 템플릿에서 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="822de0027eb75347ecda5b8adbcdb6fd9d50b088" translate="yes" xml:space="preserve">
          <source>Now that we have placed all files inside the &lt;code&gt;imports/&lt;/code&gt; directory, let&amp;rsquo;s think about how best to organize our code using modules. It makes sense to put all code that runs when your app starts in an &lt;code&gt;imports/startup&lt;/code&gt; directory. Another good idea is splitting data and business logic from UI rendering code. We suggest using directories called &lt;code&gt;imports/api&lt;/code&gt; and &lt;code&gt;imports/ui&lt;/code&gt; for this logical split.</source>
          <target state="translated">모든 파일을 &lt;code&gt;imports/&lt;/code&gt; 디렉토리 안에 넣었으니 , 모듈을 사용하여 코드를 구성하는 가장 좋은 방법을 생각해 보자. 앱을 시작할 때 실행되는 모든 코드를 &lt;code&gt;imports/startup&lt;/code&gt; 디렉토리 에 두는 것이 좋습니다 . 또 다른 좋은 아이디어는 UI 렌더링 코드에서 데이터와 비즈니스 로직을 분리하는 것입니다. 이 논리적 분할 에는 &lt;code&gt;imports/api&lt;/code&gt; 및 &lt;code&gt;imports/ui&lt;/code&gt; 디렉토리를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="207c8efa237ee7afa85bb139ec83441157995981" translate="yes" xml:space="preserve">
          <source>Now that you are familiar with the basic API of Simple Schema, it&amp;rsquo;s worth considering a few of the constraints of the Meteor data system that can influence the design of your data schema. Although generally speaking you can build a Meteor data schema much like any MongoDB data schema, there are some important details to keep in mind.</source>
          <target state="translated">이제 Simple Schema의 기본 API에 익숙해 졌으므로 데이터 스키마 디자인에 영향을 줄 수있는 Meteor 데이터 시스템의 몇 가지 제약 조건을 고려해야합니다. 일반적으로 MongoDB 데이터 스키마와 매우 유사하게 Meteor 데이터 스키마를 구축 할 수 있지만 명심해야 할 중요한 세부 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2415a74e85f893d12486fe84c1d6f4d5237cd33" translate="yes" xml:space="preserve">
          <source>Now that you have the access token, you need to actually make a request to the appropriate API. Here you have two options:</source>
          <target state="translated">액세스 토큰이 있으므로 실제로 적절한 API를 요청해야합니다. 여기에는 두 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad193fb9138049e8ee81187783bd11d3de48574e" translate="yes" xml:space="preserve">
          <source>Now that you have this package, you can use helpers in your templates to display a link to a certain route. For example, in the Todos example app, our nav links look like:</source>
          <target state="translated">이 패키지가 준비되었으므로 템플릿의 도우미를 사용하여 특정 경로에 대한 링크를 표시 할 수 있습니다. 예를 들어, Todos 예제 앱에서 탐색 링크는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d05915f91cde27b03edcf5e9433a8e2a92edc63b" translate="yes" xml:space="preserve">
          <source>Now that you know that the user is attempting to reset their password, set an initial password, or verify their email, you should display an appropriate UI to allow them to do so. For example, you might want to show a page with a form for the user to enter their new password.</source>
          <target state="translated">사용자가 비밀번호 재설정, 초기 비밀번호 설정 또는 이메일 확인을 시도하고 있음을 알았으므로이를 수행 할 수 있도록 적절한 UI를 표시해야합니다. 예를 들어, 사용자가 새 비밀번호를 입력 할 수있는 양식이있는 페이지를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d60aeee85fcdbde7a8a3292996eddb16b8698ac7" translate="yes" xml:space="preserve">
          <source>Now users of your package can import the symbol with:</source>
          <target state="translated">이제 패키지 사용자는 다음을 사용하여 심볼을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="646aa81c4daa41e903b20d08dccfefb42d9e9d23" translate="yes" xml:space="preserve">
          <source>Now we can attach helpers to documents, it&amp;rsquo;s simple to define a helper that fetches related documents</source>
          <target state="translated">이제 문서에 헬퍼를 첨부 할 수 있습니다. 관련 문서를 가져 오는 헬퍼를 정의하는 것은 간단합니다.</target>
        </trans-unit>
        <trans-unit id="976eaa97e9cf3169da70f260e662cfd3b4dd63aa" translate="yes" xml:space="preserve">
          <source>Now we can easily find all the todos for a list:</source>
          <target state="translated">이제 목록에 대한 모든 할 일을 쉽게 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef330ff4a9076f7c91003e65863c6eb967f7566c" translate="yes" xml:space="preserve">
          <source>Now we can run the tests with &lt;code&gt;meteor npm test&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;meteor npm test&lt;/code&gt; 로 테스트를 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4ea65ac5d2b8d2196556f7141a258249192cfde3" translate="yes" xml:space="preserve">
          <source>Now we have a schema, how do we use it?</source>
          <target state="translated">이제 스키마가 있는데 어떻게 사용합니까?</target>
        </trans-unit>
        <trans-unit id="aa15df2c85f6af550bcc27502427dc8434822821" translate="yes" xml:space="preserve">
          <source>Now we understand how to define routes and access information about the current route, we are in a position to do what you usually want to do when a user accesses a route&amp;mdash;render a user interface to the screen that represents it.</source>
          <target state="translated">이제 경로를 정의하고 현재 경로에 대한 정보에 액세스하는 방법을 이해했습니다. 사용자가 경로에 액세스 할 때 일반적으로 원하는 작업을 수행 할 수있는 위치에 있습니다. 사용자 인터페이스는 해당 경로를 나타내는 화면에 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="5267e95fd26270fb10fc686a7b3f0594b35acb8d" translate="yes" xml:space="preserve">
          <source>Now you can access &lt;code&gt;this.todo&lt;/code&gt; inside &lt;code&gt;Todos_item&lt;/code&gt; event handlers and helpers.</source>
          <target state="translated">이제 당신은에 액세스 할 수 있습니다 &lt;code&gt;this.todo&lt;/code&gt; 를 내부 &lt;code&gt;Todos_item&lt;/code&gt; 의 이벤트 핸들러와 헬퍼.</target>
        </trans-unit>
        <trans-unit id="43347d8449fb86f6793f729d6e976c40d2bdb2f3" translate="yes" xml:space="preserve">
          <source>Now you can edit the package, commit, and push, and your teammates will get your version of the package. To ensure that your package doesn&amp;rsquo;t get overwritten during an &lt;code&gt;npm update&lt;/code&gt;, change the default &lt;a href=&quot;https://docs.npmjs.com/misc/semver#caret-ranges-123-025-004&quot;&gt;caret version range&lt;/a&gt; in your &lt;code&gt;package.json&lt;/code&gt; to an exact version.</source>
          <target state="translated">이제 패키지를 편집, 커밋 및 푸시 할 수 있으며 팀원이 패키지 버전을 가져옵니다. &lt;code&gt;npm update&lt;/code&gt; 중에 패키지를 덮어 쓰지 않으려면 &lt;code&gt;package.json&lt;/code&gt; 의 기본 &lt;a href=&quot;https://docs.npmjs.com/misc/semver#caret-ranges-123-025-004&quot;&gt;캐럿 버전 범위&lt;/a&gt; 를 정확한 버전으로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="8e94a5f60ef845c8fa131a2af08f79c2c69106bd" translate="yes" xml:space="preserve">
          <source>Now you can invoke this helper with &lt;code&gt;{{foo}}&lt;/code&gt; in the template defined with &lt;code&gt;&amp;lt;template name=&quot;myTemplate&quot;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;&amp;lt;template name=&quot;myTemplate&quot;&amp;gt;&lt;/code&gt; 으로 정의 된 템플리트에서 &lt;code&gt;{{foo}}&lt;/code&gt; 를 사용 하여이 헬퍼를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cee8ff0c0a31ebc8d5d3632d61d0e0a89d1f35ec" translate="yes" xml:space="preserve">
          <source>Now your code becomes a bit simpler:</source>
          <target state="translated">이제 코드가 조금 더 간단 해집니다.</target>
        </trans-unit>
        <trans-unit id="9f20e2ab259b720e366ab691310bf2293b2ccbc8" translate="yes" xml:space="preserve">
          <source>Now your users&amp;rsquo; apps will continue receiving hot code pushes. However, they won&amp;rsquo;t get the new version of the Cordova plugin until they update from the app store. In this case, that&amp;rsquo;s okay, because we only updated a patch version, so the &lt;code&gt;cordova-plugin-camera&lt;/code&gt; API didn&amp;rsquo;t change. But if you had added a new plugin, like &lt;code&gt;cordova-plugin-gyroscope&lt;/code&gt;, and changed your Javascript to call &lt;code&gt;navigator.gyroscope.getCurrent()&lt;/code&gt;, then when the old apps get the new JS code, they will throw the error: &lt;code&gt;Uncaught TypeError: Cannot read property 'getCurrent' of undefined&lt;/code&gt;.</source>
          <target state="translated">이제 사용자의 앱은 핫 코드 푸시를 계속받습니다. 그러나 앱 스토어에서 업데이트 할 때까지 새 버전의 Cordova 플러그인을 얻지 못합니다. 이 경우 패치 버전 만 업데이트 &lt;code&gt;cordova-plugin-camera&lt;/code&gt; API가 변경되지 않았으므로 괜찮습니다 . 그러나 &lt;code&gt;cordova-plugin-gyroscope&lt;/code&gt; 와 같은 새 플러그인을 추가하고 &lt;code&gt;navigator.gyroscope.getCurrent()&lt;/code&gt; 를 호출하도록 Javascript를 변경 한 경우 이전 앱이 새 JS 코드를 가져 오면 오류가 발생합니다. &lt;code&gt;Uncaught TypeError: Cannot read property 'getCurrent' of undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cec615992c41a764006a8aef341f6a5c1a7ffb8b" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;accounts-facebook&lt;/code&gt; will be able to find that API key and Facebook login will work properly.</source>
          <target state="translated">이제 &lt;code&gt;accounts-facebook&lt;/code&gt; 에서 API 키와 Facebook 로그인이 올바르게 작동 함을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="933897b29c318fda73422be92f1dbe88c2df4fbd" translate="yes" xml:space="preserve">
          <source>Now, if you fetch data using a Method, you can put into this collection:</source>
          <target state="translated">이제 메소드를 사용하여 데이터를 가져 오면이 콜렉션에 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b74d4e18faa0cdac3fcd363ee43ec890efffab7" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s say you wanted to check if someone was allowed to delete a particular forum post:</source>
          <target state="translated">이제 누군가 특정 포럼 게시물을 삭제할 수 있는지 확인하고 싶다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="2af8d4bcc2e3e0deeeba9ac257b11c64b30c580d" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s write some JavaScript to handle this form nicely:</source>
          <target state="translated">이제이 양식을 잘 처리하기 위해 JavaScript를 작성해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="8e55e6c6972017ace2706c15ecf84d201dd64b4e" translate="yes" xml:space="preserve">
          <source>Now, on running on Windows, the usual node modules &lt;code&gt;fs&lt;/code&gt; and &lt;code&gt;path&lt;/code&gt; expect to get a DOS path. To assist you to write correct code, the &lt;code&gt;Plugin&lt;/code&gt; symbol provides its own versions of &lt;code&gt;fs&lt;/code&gt; and &lt;code&gt;path&lt;/code&gt; that you can use instead (note that all methods on &lt;code&gt;fs&lt;/code&gt; are fiberized and sync versions prefer using Fibers rather than freezing the whole event loop).</source>
          <target state="translated">이제 Windows에서 실행할 때 일반적인 노드 모듈 &lt;code&gt;fs&lt;/code&gt; 및 &lt;code&gt;path&lt;/code&gt; 는 DOS 경로를 가져옵니다. 올바른 코드를 작성하는 데 도움이되도록 &lt;code&gt;Plugin&lt;/code&gt; 기호는 대신 사용할 수 있는 자체 버전의 &lt;code&gt;fs&lt;/code&gt; 및 &lt;code&gt;path&lt;/code&gt; 를 제공합니다 ( &lt;code&gt;fs&lt;/code&gt; 의 모든 메소드 는 파이버 화되어 있으며 동기화 버전은 전체 이벤트 루프를 정지시키는 대신 파이버를 사용하는 것을 선호합니다).</target>
        </trans-unit>
        <trans-unit id="de133ac50673099a62de8bb19140b3871ca52b8f" translate="yes" xml:space="preserve">
          <source>Now, we can call this simple function to determine if a particular user is allowed to edit this list:</source>
          <target state="translated">이제이 간단한 함수를 호출하여 특정 사용자가이 목록을 편집 할 수 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="243f8c30482c7afc35db1d5c12b7ee2af7917f7b" translate="yes" xml:space="preserve">
          <source>Now, we need to configure the package with our Google Analytics key (the package also supports a large variety of other providers, check out the &lt;a href=&quot;https://atmospherejs.com/okgrow/analytics&quot;&gt;documentation on Atmosphere&lt;/a&gt;). Pass it in as part of &lt;a href=&quot;#environment&quot;&gt;&lt;em&gt;Meteor settings&lt;/em&gt;&lt;/a&gt;:</source>
          <target state="translated">이제 Google 웹 로그 분석 키를 사용하여 패키지를 구성해야합니다 (패키지는 다양한 다른 제공 업체도 지원합니다 . &lt;a href=&quot;https://atmospherejs.com/okgrow/analytics&quot;&gt;Atmosphere&lt;/a&gt; 의 문서를 확인하십시오 ). &lt;a href=&quot;#environment&quot;&gt;&lt;em&gt;Meteor 설정의&lt;/em&gt;&lt;/a&gt; 일부로 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="20b4ed3981502de2e2adf9a35402f25870f2eeac" translate="yes" xml:space="preserve">
          <source>Now, you can sign the APK:</source>
          <target state="translated">이제 APK에 서명 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="3a278e0d7616c87b141f0dddb4ea2f20431d86bd" translate="yes" xml:space="preserve">
          <source>Now, you might be wondering what good the &lt;code&gt;modules&lt;/code&gt; package is without the &lt;code&gt;ecmascript&lt;/code&gt; package, since &lt;code&gt;ecmascript&lt;/code&gt; enables &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; syntax. By itself, the &lt;code&gt;modules&lt;/code&gt; package provides the CommonJS &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;exports&lt;/code&gt; primitives that may be familiar if you&amp;rsquo;ve ever written Node code, and the &lt;code&gt;ecmascript&lt;/code&gt; package simply compiles &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; statements to CommonJS. The &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; primitives also allow Node modules to run within Meteor application code without modification. Furthermore, keeping &lt;code&gt;modules&lt;/code&gt; separate allows us to use &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;exports&lt;/code&gt; in places where using &lt;code&gt;ecmascript&lt;/code&gt; is tricky, such as the implementation of the &lt;code&gt;ecmascript&lt;/code&gt; package itself.</source>
          <target state="translated">이제, 당신은 무슨 소용이 궁금 할 것이다 &lt;code&gt;modules&lt;/code&gt; 패키지는없이 &lt;code&gt;ecmascript&lt;/code&gt; 때문에, 패키지 &lt;code&gt;ecmascript&lt;/code&gt; 수 &lt;code&gt;import&lt;/code&gt; 및 &lt;code&gt;export&lt;/code&gt; 구문을. 그 자체로, &lt;code&gt;modules&lt;/code&gt; 패키지는 CommonJS 제공 &lt;code&gt;require&lt;/code&gt; 및 &lt;code&gt;exports&lt;/code&gt; 혹시 노드의 코드를 작성했다면 익숙 할 프리미티브하고, &lt;code&gt;ecmascript&lt;/code&gt; 패키지는 단순히 컴파일 &lt;code&gt;import&lt;/code&gt; 및 &lt;code&gt;export&lt;/code&gt; CommonJS에 문을. 이 &lt;code&gt;require&lt;/code&gt; 하고 &lt;code&gt;export&lt;/code&gt; 프리미티브는 노드 모듈을 수정없이 유성 응용 프로그램 코드 내에서 실행할 수 있습니다. 또한, 유지 &lt;code&gt;modules&lt;/code&gt; 별도의 모듈 을 사용 하면 &lt;code&gt;ecmascript&lt;/code&gt; 패키지 자체 의 구현과 같이 &lt;code&gt;ecmascript&lt;/code&gt; 사용 이 까다로운 장소에서 &lt;code&gt;require&lt;/code&gt; 및 &lt;code&gt;exports&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71f74bba5f33a9d96d40a539150b810907ad33cc" translate="yes" xml:space="preserve">
          <source>Npm.depends()</source>
          <target state="translated">Npm.depends()</target>
        </trans-unit>
        <trans-unit id="e8316712a9a3315e031ca25c52b866ca8e4dd506" translate="yes" xml:space="preserve">
          <source>Npm.require</source>
          <target state="translated">Npm.require</target>
        </trans-unit>
        <trans-unit id="bd435600ec8b895b6a417198c49a8648125b7011" translate="yes" xml:space="preserve">
          <source>Number of milliseconds to wait before calling function</source>
          <target state="translated">함수를 호출하기 전에 대기하는 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="7605a5480c1ff4569d72023551211e89e95caea9" translate="yes" xml:space="preserve">
          <source>Number of milliseconds to wait between each function call.</source>
          <target state="translated">각 함수 호출 사이에 대기 할 시간 (밀리 초)입니다.</target>
        </trans-unit>
        <trans-unit id="8117159cb84b2356bcd7eba57411e351b99bcc3f" translate="yes" xml:space="preserve">
          <source>Number of results to skip at the beginning</source>
          <target state="translated">처음에 건너 뛸 결과 수</target>
        </trans-unit>
        <trans-unit id="1806954e5411ad670e0fbd92643d34942dcf64ae" translate="yes" xml:space="preserve">
          <source>Numeric HTTP result status code, or &lt;code&gt;null&lt;/code&gt; on error.</source>
          <target state="translated">숫자 HTTP 결과 상태 코드이거나 오류가 발생한 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f5ec93f8987bc272ccffa8ce5330227b7ad595fd" translate="yes" xml:space="preserve">
          <source>OAuth login</source>
          <target state="translated">OAuth 로그인</target>
        </trans-unit>
        <trans-unit id="8176214d76b768ce951c721f257e68ce23db0f63" translate="yes" xml:space="preserve">
          <source>Occasionally, you may need to wait for data to become ready before it&amp;rsquo;s time to attach the plugin (although typically it&amp;rsquo;s a better idea to use a sub-component in this use case). To do so, you can setup an &lt;code&gt;autorun&lt;/code&gt; in the &lt;code&gt;onRendered()&lt;/code&gt; callback. For instance, in the &lt;code&gt;Lists_show_page&lt;/code&gt; component, we want to wait until the subscription for the list is ready (i.e. the todos have rendered) before we hide the launch screen:</source>
          <target state="translated">때때로 플러그인을 연결하기 전에 데이터가 준비 될 때까지 기다려야 할 수도 있습니다 (일반적으로이 사용 사례에서 하위 구성 요소를 사용하는 것이 좋습니다). 이를 위해 &lt;code&gt;onRendered()&lt;/code&gt; 콜백 에서 &lt;code&gt;autorun&lt;/code&gt; 을 설정할 수 있습니다 . 예를 들어, &lt;code&gt;Lists_show_page&lt;/code&gt; 컴포넌트에서, 시작 화면을 숨기기 전에 목록에 대한 가입이 준비 될 때까지 (즉, 할 일이 렌더링 될 때까지) 대기하려고합니다.</target>
        </trans-unit>
        <trans-unit id="960b908bd16253af47c0f3825d9aef7e3c59869d" translate="yes" xml:space="preserve">
          <source>Of course in this scenario, you also need to be prepared for the server to fail, and again, indicate it to the user somehow.</source>
          <target state="translated">물론이 시나리오에서는 서버가 실패 할 수 있도록 준비하고 다시 사용자에게 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="b45d04320ea3eb52cfab363837be0fa6fad1cdb7" translate="yes" xml:space="preserve">
          <source>Of course, calling &lt;code&gt;FlowRouter.go()&lt;/code&gt;, will always work, so unless you are trying to optimize for a specific situation it&amp;rsquo;s better to use that.</source>
          <target state="translated">물론 &lt;code&gt;FlowRouter.go()&lt;/code&gt; 호출 하면 항상 작동하므로 특정 상황에 맞게 최적화하지 않는 한 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="26b57e258d7bb3f9ae229f4836280daf9ea9b387" translate="yes" xml:space="preserve">
          <source>Of course, we might find that we need to share this functionality between multiple pages of our app that require access control. We can easily share functionality between templates by wrapping them in a wrapper &amp;ldquo;layout&amp;rdquo; component which includes the behavior we want.</source>
          <target state="translated">물론 액세스 제어가 필요한 여러 페이지의 앱간에이 기능을 공유해야 할 수도 있습니다. 원하는 동작을 포함하는 래퍼 &quot;레이아웃&quot;구성 요소에 템플릿을 배치하여 템플릿간에 기능을 쉽게 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2aea2e03ff924675060b7a8cb2fe04ea7326b52c" translate="yes" xml:space="preserve">
          <source>Of note here:</source>
          <target state="translated">여기에주의하십시오 :</target>
        </trans-unit>
        <trans-unit id="138d82367af244892a0d51b98002680207912518" translate="yes" xml:space="preserve">
          <source>Of particular interest in this test is the following:</source>
          <target state="translated">이 테스트에 특히 관심이있는 것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="18bbab6b1013657cad2554e317018c172391050a" translate="yes" xml:space="preserve">
          <source>Often it&amp;rsquo;s sensible to create a set of data to run your test against. You can use standard &lt;code&gt;insert()&lt;/code&gt; calls against your collections to do this, but often it&amp;rsquo;s easier to create &lt;em&gt;factories&lt;/em&gt; which help encode random test data. A great package to use to do this is &lt;a href=&quot;https://atmospherejs.com/dburles/factory&quot;&gt;&lt;code&gt;dburles:factory&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">테스트를 실행할 데이터 세트를 작성하는 것이 합리적 일 수 있습니다. 콜렉션에 대해 표준 &lt;code&gt;insert()&lt;/code&gt; 호출을 사용하여이를 수행 할 수 있지만 임의 테스트 데이터를 인코딩하는 데 도움이되는 &lt;em&gt;팩토리&lt;/em&gt; 를 작성 하는 것이 더 쉽습니다 . 이를 수행하는 데 사용할 수있는 훌륭한 패키지는 &lt;a href=&quot;https://atmospherejs.com/dburles/factory&quot;&gt; &lt;code&gt;dburles:factory&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ce371ca468f2ad5bc96714235a13afc604dae6cb" translate="yes" xml:space="preserve">
          <source>Often when you are dealing with templates or UI components, you&amp;rsquo;ll have several closely coupled files to manage. They could be two or more of HTML, CSS, and JavaScript files. In this case, we recommend putting these together in the same directory with the same name:</source>
          <target state="translated">템플릿이나 UI 구성 요소를 다룰 때 종종 관리 할 파일이 밀접하게 결합되어 있습니다. 둘 이상의 HTML, CSS 및 JavaScript 파일 일 수 있습니다. 이 경우, 동일한 이름의 동일한 디렉토리에 이들을 조합하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f69514bafa9d3c2c2947421f4615271aa4903f57" translate="yes" xml:space="preserve">
          <source>Often, a complicated accounts system is not the first thing you want to build when you&amp;rsquo;re starting out with a new app, so it&amp;rsquo;s useful to have something you can just drop in quickly. This is where &lt;code&gt;accounts-ui&lt;/code&gt; comes in - it&amp;rsquo;s just one line that you drop into your app to get an accounts system. To add it:</source>
          <target state="translated">복잡한 계정 시스템은 새로운 앱으로 시작할 때 가장 먼저 구축하려는 것이 아니므로 빨리 빠뜨릴 수있는 항목을 갖는 것이 유용합니다. 이것은 &lt;code&gt;accounts-ui&lt;/code&gt; 가 들어오는 곳입니다-계정 시스템을 얻기 위해 앱에 넣는 한 줄입니다. 그것을 추가하려면 :</target>
        </trans-unit>
        <trans-unit id="1d4c5e395b72c1f07599cd0399f4828ff5800a04" translate="yes" xml:space="preserve">
          <source>Often, however, a publication is more general. For example in the Todos example application, we create a &lt;code&gt;todos.inList&lt;/code&gt; publication, which publishes all the todos in a list. Although in the application we only use this in one place (in the &lt;code&gt;Lists_show&lt;/code&gt; template), in a larger app, there&amp;rsquo;s a good chance we might need to access all the todos for a list in other places. So putting the publication in the &lt;code&gt;todos&lt;/code&gt; package is a sensible approach.</source>
          <target state="translated">그러나 종종 간행물이 더 일반적입니다. 예를 들어 Todos 예제 애플리케이션에서 &lt;code&gt;todos.inList&lt;/code&gt; 게시를 작성하여 모든 할 일을 목록에 게시합니다. 응용 프로그램에서는 &lt;code&gt;Lists_show&lt;/code&gt; 템플릿 의 한 곳에서만 이것을 사용하지만 더 큰 응용 프로그램에서는 다른 곳의 목록에 대한 모든 할 일에 액세스해야 할 수도 있습니다. 따라서 게시를 &lt;code&gt;todos&lt;/code&gt; 패키지 에 넣는 것이 현명한 접근 방식입니다.</target>
        </trans-unit>
        <trans-unit id="443325ce9612c1f8f84b168f82ed27323cc08986" translate="yes" xml:space="preserve">
          <source>Often, users might want to associate multiple email addresses with the same account. &lt;code&gt;accounts-password&lt;/code&gt; addresses this case by storing the email addresses as an array in the user collection. There are some handy API methods to deal with &lt;a href=&quot;http://docs.meteor.com/api/passwords.html#Accounts-addEmail&quot;&gt;adding&lt;/a&gt;, &lt;a href=&quot;http://docs.meteor.com/api/passwords.html#Accounts-removeEmail&quot;&gt;removing&lt;/a&gt;, and &lt;a href=&quot;http://docs.meteor.com/api/passwords.html#Accounts-verifyEmail&quot;&gt;verifying&lt;/a&gt; emails.</source>
          <target state="translated">종종 사용자는 여러 이메일 주소를 동일한 계정에 연결하려고 할 수 있습니다. &lt;code&gt;accounts-password&lt;/code&gt; 는 전자 메일 주소를 사용자 모음에 배열로 저장하여이 경우를 해결합니다. 이메일 &lt;a href=&quot;http://docs.meteor.com/api/passwords.html#Accounts-addEmail&quot;&gt;추가&lt;/a&gt; , &lt;a href=&quot;http://docs.meteor.com/api/passwords.html#Accounts-removeEmail&quot;&gt;제거&lt;/a&gt; 및 &lt;a href=&quot;http://docs.meteor.com/api/passwords.html#Accounts-verifyEmail&quot;&gt;확인&lt;/a&gt; 을 처리하는 편리한 API 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfe7e55941971a1d98a397fe624783a92e229249" translate="yes" xml:space="preserve">
          <source>Often, you just want to go to a new route programmatically when a user has completed a certain action. Above we saw a case (creating a new list) when we wanted to do it &lt;em&gt;optimistically&lt;/em&gt;&amp;mdash;i.e. before we hear back from the server that the Method succeeded. We can do this because we reasonably expect that the Method will succeed in almost all cases (see the &lt;a href=&quot;ui-ux#optimistic-ui&quot;&gt;UI/UX article&lt;/a&gt; for further discussion of this).</source>
          <target state="translated">사용자가 특정 작업을 완료하면 프로그래밍 방식으로 새 경로로 이동하는 경우가 종종 있습니다. 위에서 우리는 &lt;em&gt;낙관적으로&lt;/em&gt; 하고 싶을 때 ( 즉, Method가 성공했다는 것을 서버로부터 듣기 전에 ) 새로운 목록을 만드는 사례를 보았다 . 우리는이 방법이 거의 모든 경우에 성공할 것이라고 합리적으로 기대하기 때문에이를 수행 할 수 있습니다 (자세한 내용은 &lt;a href=&quot;ui-ux#optimistic-ui&quot;&gt;UI / UX 기사 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="81ee0c69e8974262677cd343bb41661a9b5a61d7" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;deployment#galaxy&quot;&gt;Galaxy&lt;/a&gt;, configuration of SSL is automatic. &lt;a href=&quot;http://galaxy-guide.meteor.com/encryption.html&quot;&gt;See the help article about SSL on Galaxy&lt;/a&gt;.</source>
          <target state="translated">에 &lt;a href=&quot;deployment#galaxy&quot;&gt;갤럭시&lt;/a&gt; , SSL의 구성은 자동입니다. &lt;a href=&quot;http://galaxy-guide.meteor.com/encryption.html&quot;&gt;Galaxy on SSL에 대한 도움말을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ff75ad65adb6098a8b59abd3b05217c7c50ef265" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;deployment#galaxy&quot;&gt;Galaxy&lt;/a&gt;, simply enable the &amp;ldquo;Force HTTPS&amp;rdquo; setting on a specific domain in the &amp;ldquo;Domains &amp;amp; Encryption&amp;rdquo; section of the application&amp;rsquo;s &amp;ldquo;Settings&amp;rdquo; tab.</source>
          <target state="translated">에 &lt;a href=&quot;deployment#galaxy&quot;&gt;갤럭시&lt;/a&gt; , 단순히 응용 프로그램의 '설정'탭의 '도메인 및 암호화 &quot;섹션에서 특정 도메인에 설정&quot;강제 HTTPS를 &quot;할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6d7796e5019fcc386bffcd860dfc592908312df" translate="yes" xml:space="preserve">
          <source>On Android</source>
          <target state="translated">안드로이드에서</target>
        </trans-unit>
        <trans-unit id="745c33bff0bc1fb981e36089f400ab76b32c5456" translate="yes" xml:space="preserve">
          <source>On Linux, you may want to use your distribution&amp;rsquo;s package manager to install a JDK; on Ubuntu, you can even use &lt;a href=&quot;#ubuntu-make&quot;&gt;Ubuntu Make&lt;/a&gt; to install Android Studio and all dependencies at the same time.</source>
          <target state="translated">Linux에서는 배포판의 패키지 관리자를 사용하여 JDK를 설치할 수 있습니다. Ubuntu에서 &lt;a href=&quot;#ubuntu-make&quot;&gt;Ubuntu Make&lt;/a&gt; 를 사용하여 Android Studio 및 모든 종속성을 동시에 설치할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="55cc237045e85e650876e95e2cc7456466fb8057" translate="yes" xml:space="preserve">
          <source>On OS X or Linux? Install the latest official Meteor release from your terminal:</source>
          <target state="translated">OS X 또는 Linux? 터미널에서 최신 공식 Meteor 릴리스를 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="5102fbdab1d89c3f4fb9dee7829cc0235edf341e" translate="yes" xml:space="preserve">
          <source>On Windows? &lt;a href=&quot;https://install.meteor.com/windows&quot;&gt;Download the official Meteor installer here&lt;/a&gt;.</source>
          <target state="translated">Windows에서? &lt;a href=&quot;https://install.meteor.com/windows&quot;&gt;공식 Meteor 설치 프로그램을 여기에서 다운로드하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5916ddb1f1b9cd570ff40f702eadb51ab338d9fc" translate="yes" xml:space="preserve">
          <source>On a client, &lt;code&gt;startup&lt;/code&gt; callbacks from packages will be called first, followed by &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; templates from your &lt;code&gt;.html&lt;/code&gt; files, followed by your application code.</source>
          <target state="translated">클라이언트 에서 패키지의 &lt;code&gt;startup&lt;/code&gt; 콜백이 먼저 호출 된 다음 &lt;code&gt;.html&lt;/code&gt; 파일의 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 템플릿이 뒤 따르고 애플리케이션 코드 가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="f8503b506f6d1a70b0005bb3f49c7990a8ab813a" translate="yes" xml:space="preserve">
          <source>On a server, the function will run as soon as the server process is finished starting. On a client, the function will run as soon as the DOM is ready. Code wrapped in &lt;code&gt;Meteor.startup&lt;/code&gt; always runs after all app files have loaded, so you should put code here if you want to access shared variables from other files.</source>
          <target state="translated">서버에서 서버 프로세스가 시작되는 즉시 기능이 실행됩니다. 클라이언트에서는 DOM이 준비되는 즉시 함수가 실행됩니다. &lt;code&gt;Meteor.startup&lt;/code&gt; 에 싸인 코드는 항상 모든 앱 파일이로드 된 후에 실행되므로 다른 파일에서 공유 변수에 액세스하려면 여기에 코드를 넣어야합니다.</target>
        </trans-unit>
        <trans-unit id="a6b3b76df1a9c7e83fb8d23a045c930341389f58" translate="yes" xml:space="preserve">
          <source>On iOS</source>
          <target state="translated">iOS에서</target>
        </trans-unit>
        <trans-unit id="48bc0a44f00af07795c39abeed16277ade7db908" translate="yes" xml:space="preserve">
          <source>On iOS, these settings also control &lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW33&quot;&gt;Application Transport Security (ATS)&lt;/a&gt;, which is an OS level mechanism to enforce security best practices new to iOS 9. If the server you&amp;rsquo;re connecting to does not (yet) fulfill these requirements, you can use additional options to override them for specific domains:</source>
          <target state="translated">iOS에서이 설정은 iOS 9에 새로운 보안 모범 사례를 시행하는 OS 레벨 메커니즘 인 &lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW33&quot;&gt;ATS (Application Transport Security)&lt;/a&gt; 도 제어 합니다. 연결하려는 서버가 아직 이러한 요구 사항을 충족하지 못하면 특정 도메인에 대한 재정의를위한 추가 옵션 :</target>
        </trans-unit>
        <trans-unit id="14ed91aceae241220b95e4a7ec1cb3333a380100" translate="yes" xml:space="preserve">
          <source>On the client (and on the server if you specify a &lt;code&gt;connection&lt;/code&gt;), a Minimongo instance is created. Minimongo is essentially an in-memory, non-persistent implementation of Mongo in pure JavaScript. It serves as a local cache that stores just the subset of the database that this client is working with. Queries (&lt;a href=&quot;#find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt;) on these collections are served directly out of this cache, without talking to the server.</source>
          <target state="translated">클라이언트 (및 &lt;code&gt;connection&lt;/code&gt; 을 지정한 경우 서버 )에서 Minimongo 인스턴스가 작성됩니다. Minimongo는 본질적으로 순수한 JavaScript에서 Mongo를 인 메모리로, 비 영구적으로 구현 한 것입니다. 이 클라이언트가 작업중인 데이터베이스의 서브 세트 만 저장하는 로컬 캐시 역할을합니다. 이러한 컬렉션에 대한 쿼리 ( &lt;a href=&quot;#find&quot;&gt; &lt;code&gt;find&lt;/code&gt; &lt;/a&gt; )는 서버와 통신하지 않고이 캐시에서 직접 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="0ea13373e5b7461a0fea906787132de7016126dc" translate="yes" xml:space="preserve">
          <source>On the client, &lt;code&gt;insert&lt;/code&gt; never blocks. If you do not provide a callback and the insert fails on the server, then Meteor will log a warning to the console. If you provide a callback, Meteor will call that function with &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;result&lt;/code&gt; arguments. In an error case, &lt;code&gt;result&lt;/code&gt; is undefined. If the insert is successful, &lt;code&gt;error&lt;/code&gt; is undefined and &lt;code&gt;result&lt;/code&gt; is the new document ID.</source>
          <target state="translated">클라이언트에서 절대 블록을 &lt;code&gt;insert&lt;/code&gt; 하지 마십시오. 콜백을 제공하지 않고 서버에서 삽입이 실패하면 Meteor가 콘솔에 경고를 기록합니다. 콜백을 제공하면 Meteor는 해당 함수를 &lt;code&gt;error&lt;/code&gt; 및 &lt;code&gt;result&lt;/code&gt; 인수 와 함께 호출합니다 . 오류가 발생하면 &lt;code&gt;result&lt;/code&gt; 가 정의되지 않습니다. 삽입에 성공하면 &lt;code&gt;error&lt;/code&gt; 가 정의되지 않으며 &lt;code&gt;result&lt;/code&gt; 는 새 문서 ID입니다.</target>
        </trans-unit>
        <trans-unit id="1add8ef2291c9805d7d0586624b13276048d4749" translate="yes" xml:space="preserve">
          <source>On the client, &lt;code&gt;remove&lt;/code&gt; never blocks. If you do not provide a callback and the remove fails on the server, then Meteor will log a warning to the console. If you provide a callback, Meteor will call that function with an error argument if there was an error, or a second argument indicating the number of removed documents if the remove was successful.</source>
          <target state="translated">클라이언트에서 절대 블록을 &lt;code&gt;remove&lt;/code&gt; . 콜백을 제공하지 않고 서버에서 제거에 실패하면 Meteor가 콘솔에 경고를 기록합니다. 콜백을 제공하면 Meteor는 오류가있는 경우 오류 인수를 사용하여 해당 함수를 호출하거나 제거에 성공한 경우 제거 된 문서 수를 나타내는 두 번째 인수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="653bd726229efe922f3f27fea407f7150676e99d" translate="yes" xml:space="preserve">
          <source>On the client, &lt;code&gt;update&lt;/code&gt; never blocks. If you do not provide a callback and the update fails on the server, then Meteor will log a warning to the console. If you provide a callback, Meteor will call that function with an error argument if there was an error, or a second argument indicating the number of affected documents if the update was successful.</source>
          <target state="translated">클라이언트에서 &lt;code&gt;update&lt;/code&gt; 는 차단되지 않습니다. 콜백을 제공하지 않고 서버에서 업데이트가 실패하면 Meteor가 콘솔에 경고를 기록합니다. 콜백을 제공하면 Meteor는 오류가있는 경우 오류 인수를 사용하여 해당 함수를 호출하거나 업데이트에 성공한 경우 영향을받는 문서 수를 나타내는 두 번째 인수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="7f32fe2ee0817474a372e1e8ae52fe646847b731" translate="yes" xml:space="preserve">
          <source>On the client, if you do not pass a callback and you are not inside a stub, &lt;code&gt;call&lt;/code&gt; will return &lt;code&gt;undefined&lt;/code&gt;, and you will have no way to get the return value of the method. That is because the client doesn&amp;rsquo;t have fibers, so there is not actually any way it can block on the remote execution of a method.</source>
          <target state="translated">클라이언트에서 콜백을 전달하지 않고 스텁 내에없는 경우 &lt;code&gt;call&lt;/code&gt; 은 &lt;code&gt;undefined&lt;/code&gt; 를 반환하며 메소드의 반환 값을 가져올 방법이 없습니다. 클라이언트에 파이버가 없기 때문에 실제로 메소드의 원격 실행을 차단할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="97e318b871fc493987aefa000d7f3a7136f5052b" translate="yes" xml:space="preserve">
          <source>On the client, there is no direct connection to the MongoDB database, and in fact a synchronous API to it is not possible (nor probably what you want). Instead, on the client, a collection is a client side &lt;em&gt;cache&lt;/em&gt; of the database. This is achieved thanks to the &lt;a href=&quot;https://github.com/meteor/meteor/blob/master/packages/minimongo/README.md&quot;&gt;Minimongo&lt;/a&gt; library&amp;mdash;an in-memory, all JS, implementation of the MongoDB API. What this means is that on the client, when you write:</source>
          <target state="translated">클라이언트에는 MongoDB 데이터베이스에 대한 직접 연결이 없으며 실제로 동기식 API는 불가능합니다 (아마도 원하는 것은 아님). 대신 클라이언트에서 컬렉션은 데이터베이스 의 클라이언트 쪽 &lt;em&gt;캐시&lt;/em&gt; 입니다. 이는 MongoDB API의 메모리 내 모든 JS 구현 인 &lt;a href=&quot;https://github.com/meteor/meteor/blob/master/packages/minimongo/README.md&quot;&gt;Minimongo&lt;/a&gt; 라이브러리 덕분에 달성 됩니다. 이것이 의미하는 것은 다음과 같이 쓸 때 클라이언트에서입니다.</target>
        </trans-unit>
        <trans-unit id="dabc972369f4679d0d16a9b81ce1e1d06eda62fd" translate="yes" xml:space="preserve">
          <source>On the client, there will be a period of time between when the page loads and when the published data arrives from the server during which your client-side collections will be empty.</source>
          <target state="translated">클라이언트에서는 페이지가로드되는 시점과 게시 된 데이터가 클라이언트 측 컬렉션이 비어있는 서버에서 도착하는 시간 사이에 시간이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9ec4151f0542bf8935bb2a110772a88b9a893dd" translate="yes" xml:space="preserve">
          <source>On the client, this function logs in as the newly created user on successful completion. On the server, it returns the newly created user id.</source>
          <target state="translated">클라이언트에서이 기능은 성공적으로 완료되면 새로 작성된 사용자로 로그인합니다. 서버에서 새로 작성된 사용자 ID를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8a5acb33293d0313393c048ad638bfd92083e717" translate="yes" xml:space="preserve">
          <source>On the client, this function must be used asynchronously by passing a callback. Note that some browsers first send an &lt;code&gt;OPTIONS&lt;/code&gt; request before sending your request (in order to &lt;a href=&quot;http://stackoverflow.com/a/21783145/627729&quot;&gt;determine CORS headers&lt;/a&gt;).</source>
          <target state="translated">클라이언트에서이 함수는 콜백을 전달하여 비동기 적으로 사용해야합니다. 일부 브라우저 &lt;a href=&quot;http://stackoverflow.com/a/21783145/627729&quot;&gt;는 CORS 헤더&lt;/a&gt; 를 결정 하기 위해 요청을 보내기 전에 먼저 &lt;code&gt;OPTIONS&lt;/code&gt; 요청을 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="f6015e9b264ea9ff2daa1abf8a9e9b7b5a860b16" translate="yes" xml:space="preserve">
          <source>On the client, this will be called before the request is sent to allow for more direct manipulation of the underlying XMLHttpRequest object, which will be passed as the first argument. If the callback returns &lt;code&gt;false&lt;/code&gt;, the request will be not be send.</source>
          <target state="translated">클라이언트에서는 요청이 전송되기 전에 호출되어 기본 XMLHttpRequest 객체를보다 직접적으로 조작 할 수 있도록합니다. 첫 번째 인수로 전달됩니다. 콜백이 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 요청이 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1f7d237318e434537f8ec0c2f087b87006b011e9" translate="yes" xml:space="preserve">
          <source>On the client, this will be the subset of the fields in the document that are published from the server (other fields won&amp;rsquo;t be available on the client). By default the server publishes &lt;code&gt;username&lt;/code&gt;, &lt;code&gt;emails&lt;/code&gt;, and &lt;code&gt;profile&lt;/code&gt; (writable by user). See &lt;a href=&quot;#meteor_users&quot;&gt;&lt;code&gt;Meteor.users&lt;/code&gt;&lt;/a&gt; for more on the fields used in user documents.</source>
          <target state="translated">클라이언트에서는 서버에서 게시 한 문서의 필드 하위 집합이됩니다 (다른 필드는 클라이언트에서 사용할 수 없음). 기본적으로 서버는 &lt;code&gt;username&lt;/code&gt; , &lt;code&gt;emails&lt;/code&gt; 및 &lt;code&gt;profile&lt;/code&gt; (사용자가 쓸 수 있음)을 게시 합니다. 사용자 문서에 사용 된 필드에 대한 자세한 내용은 &lt;a href=&quot;#meteor_users&quot;&gt; &lt;code&gt;Meteor.users&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d2d839a5a01227378d21989e056a5be46677e1e2" translate="yes" xml:space="preserve">
          <source>On the client, when you write the same line:</source>
          <target state="translated">클라이언트에서 같은 줄을 쓸 때 :</target>
        </trans-unit>
        <trans-unit id="afc1de8aec8fa06b9632e01b0701442486bb1392" translate="yes" xml:space="preserve">
          <source>On the client, you must pass &lt;code&gt;password&lt;/code&gt; and at least one of &lt;code&gt;username&lt;/code&gt; or &lt;code&gt;email&lt;/code&gt; &amp;mdash; enough information for the user to be able to log in again later. If there are existing users with a username or email only differing in case, &lt;code&gt;createUser&lt;/code&gt; will fail. The callback&amp;rsquo;s &lt;code&gt;error.reason&lt;/code&gt; will be &lt;code&gt;'Username already exists.'&lt;/code&gt; or &lt;code&gt;'Email already exists.'&lt;/code&gt; In the latter case, the user can then either &lt;a href=&quot;accounts#Meteor-loginWithPassword&quot;&gt;login&lt;/a&gt; or &lt;a href=&quot;#Accounts-resetPassword&quot;&gt;reset their password&lt;/a&gt;.</source>
          <target state="translated">클라이언트에서는 &lt;code&gt;password&lt;/code&gt; 와 &lt;code&gt;username&lt;/code&gt; 또는 &lt;code&gt;email&lt;/code&gt; 중 하나 이상을 전달해야합니다 . 사용자가 나중에 다시 로그인 할 수있을만큼 충분한 정보입니다. 경우에 따라 다른 사용자 이름 또는 이메일을 가진 기존 사용자가있는 경우 &lt;code&gt;createUser&lt;/code&gt; 가 실패합니다. 콜백의 &lt;code&gt;error.reason&lt;/code&gt; 은 &lt;code&gt;'Username already exists.'&lt;/code&gt; 또는 &lt;code&gt;'Email already exists.'&lt;/code&gt; 후자의 경우 사용자는 &lt;a href=&quot;accounts#Meteor-loginWithPassword&quot;&gt;로그인&lt;/a&gt; 하거나 &lt;a href=&quot;#Accounts-resetPassword&quot;&gt;비밀번호를 재설정 할 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="18b15d1837ab6667c5f26cca3924bb3bef7af828" translate="yes" xml:space="preserve">
          <source>On the client: Meteor.userId()</source>
          <target state="translated">클라이언트에서 : Meteor.userId ()</target>
        </trans-unit>
        <trans-unit id="e70822c537a9fd52312380b690a86d83c519fbcf" translate="yes" xml:space="preserve">
          <source>On the server (if you do not specify a &lt;code&gt;connection&lt;/code&gt;), a collection with that name is created on a backend Mongo server. When you call methods on that collection on the server, they translate directly into normal Mongo operations (after checking that they match your &lt;a href=&quot;#allow&quot;&gt;access control rules&lt;/a&gt;).</source>
          <target state="translated">서버에서 ( &lt;code&gt;connection&lt;/code&gt; 지정하지 않은 경우 ) 해당 이름의 콜렉션이 백엔드 Mongo 서버에 작성됩니다. 서버의 해당 콜렉션에서 메소드를 호출하면 메소드가 &lt;a href=&quot;#allow&quot;&gt;액세스 제어 규칙&lt;/a&gt; 과 일치하는지 확인한 후 일반 Mongo 조작으로 직접 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="07cfa1e9f8084a6cee89fcc56f5fbc9ed13cbb02" translate="yes" xml:space="preserve">
          <source>On the server however, the reactivity is limited to the behavior of the cursors you return from your publish functions. You&amp;rsquo;ll see any changes to the data that matches their queries, but &lt;em&gt;their queries will never change&lt;/em&gt;.</source>
          <target state="translated">그러나 서버에서는 반응성이 게시 기능에서 반환하는 커서의 동작으로 제한됩니다. 쿼리와 일치하는 데이터에 대한 변경 사항이 표시되지만 &lt;em&gt;쿼리는 변경되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0188c1ac7dbe4df73596a2a5c139b6b174f2a38c" translate="yes" xml:space="preserve">
          <source>On the server only, use the &lt;code&gt;oauthSecretKey&lt;/code&gt; option to &lt;code&gt;Accounts.config&lt;/code&gt;:</source>
          <target state="translated">서버에서만 &lt;code&gt;oauthSecretKey&lt;/code&gt; 옵션을 &lt;code&gt;Accounts.config&lt;/code&gt; 에 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="491c408bd602bf3e10630383bfb209018a4398c1" translate="yes" xml:space="preserve">
          <source>On the server, &lt;code&gt;HTTP.call&lt;/code&gt; is implemented by using the &lt;a href=&quot;https://www.npmjs.com/package/request&quot;&gt;npm &lt;code&gt;request&lt;/code&gt; module&lt;/a&gt;. Any options in this object will be passed directly to the &lt;code&gt;request&lt;/code&gt; invocation.</source>
          <target state="translated">서버에서 &lt;code&gt;HTTP.call&lt;/code&gt; 은 &lt;a href=&quot;https://www.npmjs.com/package/request&quot;&gt;npm &lt;code&gt;request&lt;/code&gt; module&lt;/a&gt; 을 사용하여 구현됩니다 . 이 오브젝트의 모든 옵션은 &lt;code&gt;request&lt;/code&gt; 호출로 직접 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="4db290b2da5ce768449136be2535c12a1d9d531e" translate="yes" xml:space="preserve">
          <source>On the server, each connection has a different logged in user, so there is no global logged-in user state by definition. Since Meteor tracks the environment for each Method call, you can still use the &lt;code&gt;Meteor.userId()&lt;/code&gt; global, which returns a different value depending on which Method you call it from, but you can run into edge cases when dealing with asynchronous code. Also, &lt;code&gt;Meteor.userId()&lt;/code&gt; won&amp;rsquo;t work inside publications.</source>
          <target state="translated">서버에서 각 연결에는 서로 다른 로그인 사용자가 있으므로 정의에 따라 전체 로그인 사용자 상태가 없습니다. Meteor는 각 Method 호출에 대한 환경을 추적하기 때문에 &lt;code&gt;Meteor.userId()&lt;/code&gt; 전역을 사용할 수 있습니다. Meteor.userId () 전역은 호출하는 Method에 따라 다른 값을 반환하지만 비동기 코드를 처리 할 때 경계가 발생할 수 있습니다. 또한 &lt;code&gt;Meteor.userId()&lt;/code&gt; 는 발행물 내부에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="85b8d6e4706ac22cf150547bdeb601b257863668" translate="yes" xml:space="preserve">
          <source>On the server, if &lt;code&gt;callback&lt;/code&gt; yields, other calls to &lt;code&gt;callback&lt;/code&gt; may occur while the first call is waiting. If strict sequential execution is necessary, use &lt;code&gt;forEach&lt;/code&gt; instead.</source>
          <target state="translated">서버에서 경우 &lt;code&gt;callback&lt;/code&gt; 수율, 다른 통화 &lt;code&gt;callback&lt;/code&gt; 첫 번째 통화 대기 중에 발생할 수 있습니다. 엄격한 순차 실행이 필요한 경우 &lt;code&gt;forEach&lt;/code&gt; 를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="429e978e9c94b620b3df5a646f8b2a8e4940810a" translate="yes" xml:space="preserve">
          <source>On the server, if you don&amp;rsquo;t provide a callback, then &lt;code&gt;insert&lt;/code&gt; blocks until the database acknowledges the write, or throws an exception if something went wrong. If you do provide a callback, &lt;code&gt;insert&lt;/code&gt; still returns the ID immediately. Once the insert completes (or fails), the callback is called with error and result arguments. In an error case, &lt;code&gt;result&lt;/code&gt; is undefined. If the insert is successful, &lt;code&gt;error&lt;/code&gt; is undefined and &lt;code&gt;result&lt;/code&gt; is the new document ID.</source>
          <target state="translated">서버에서 콜백을 제공하지 않으면 데이터베이스가 쓰기를 승인 할 때까지 블록 을 &lt;code&gt;insert&lt;/code&gt; 하거나 문제가 발생한 경우 예외를 발생시킵니다. 콜백을 제공해도 &lt;code&gt;insert&lt;/code&gt; 는 여전히 ID를 즉시 반환합니다. 삽입이 완료되면 (또는 실패하면) 콜백은 오류 및 결과 인수와 함께 호출됩니다. 오류가 발생하면 &lt;code&gt;result&lt;/code&gt; 가 정의되지 않습니다. 삽입에 성공하면 &lt;code&gt;error&lt;/code&gt; 가 정의되지 않으며 &lt;code&gt;result&lt;/code&gt; 는 새 문서 ID입니다.</target>
        </trans-unit>
        <trans-unit id="54ab8cd4ba0db8afe0cfc9fb9618c22dca4f8eb2" translate="yes" xml:space="preserve">
          <source>On the server, if you don&amp;rsquo;t provide a callback, then &lt;code&gt;remove&lt;/code&gt; blocks until the database acknowledges the write and then returns the number of removed documents, or throws an exception if something went wrong. If you do provide a callback, &lt;code&gt;remove&lt;/code&gt; returns immediately. Once the remove completes, the callback is called with a single error argument in the case of failure, or a second argument indicating the number of removed documents if the remove was successful.</source>
          <target state="translated">서버에서 콜백을 제공하지 않으면 데이터베이스가 쓰기를 승인 할 때까지 블록 을 &lt;code&gt;remove&lt;/code&gt; 다음 제거 된 문서 수를 반환하거나, 문제가 발생하면 예외를 throw합니다. 콜백을 제공하면 즉시 반품을 &lt;code&gt;remove&lt;/code&gt; 합니다. 제거가 완료되면 실패시 단일 오류 인수 또는 제거에 성공한 경우 제거 된 문서 수를 나타내는 두 번째 인수와 함께 콜백이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7c1870dc195b5ee5604038af911f1b80fc9cc9e1" translate="yes" xml:space="preserve">
          <source>On the server, if you don&amp;rsquo;t provide a callback, then &lt;code&gt;update&lt;/code&gt; blocks until the database acknowledges the write, or throws an exception if something went wrong. If you do provide a callback, &lt;code&gt;update&lt;/code&gt; returns immediately. Once the update completes, the callback is called with a single error argument in the case of failure, or a second argument indicating the number of affected documents if the update was successful.</source>
          <target state="translated">서버에서 콜백을 제공하지 않으면 데이터베이스가 쓰기를 승인 할 때까지 블록 을 &lt;code&gt;update&lt;/code&gt; 하거나 문제가 발생한 경우 예외를 발생시킵니다. 콜백을 제공하면 &lt;code&gt;update&lt;/code&gt; 가 즉시 반환됩니다. 업데이트가 완료되면 실패시 단일 오류 인수 또는 업데이트가 성공한 경우 영향을받는 문서 수를 나타내는 두 번째 인수와 함께 콜백이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9bc201ea30a89331d1489d61b245e00670bd2573" translate="yes" xml:space="preserve">
          <source>On the server, methods from a given client run one at a time. The N+1th invocation from a client won&amp;rsquo;t start until the Nth invocation returns. However, you can change this by calling &lt;code&gt;this.unblock&lt;/code&gt;. This will allow the N+1th invocation to start running in a new fiber.</source>
          <target state="translated">서버에서 주어진 클라이언트의 메소드는 한 번에 하나씩 실행됩니다. 클라이언트에서 N + 1 번째 호출은 N 번째 호출이 리턴 될 때까지 시작되지 않습니다. 그러나 &lt;code&gt;this.unblock&lt;/code&gt; 을 호출하여이를 변경할 수 있습니다 . 이렇게하면 N + 1 번째 호출이 새 파이버에서 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbc320393f69d85c371bb36999f2bd55b3c7baf3" translate="yes" xml:space="preserve">
          <source>On the server, the &lt;code&gt;func&lt;/code&gt; callback receives a single argument with the object below. On the client, no arguments are passed.</source>
          <target state="translated">서버에서 &lt;code&gt;func&lt;/code&gt; 콜백은 아래 객체와 함께 단일 인수를받습니다. 클라이언트에서는 인수가 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89c1586aa0c2031c351f98738c84314090bb14a7" translate="yes" xml:space="preserve">
          <source>On the server, the callbacks get a single argument, the same attempt info object as &lt;a href=&quot;#accounts_validateloginattempt&quot;&gt;&lt;code&gt;validateLoginAttempt&lt;/code&gt;&lt;/a&gt;. On the client, the callback argument is an object containing a single &lt;code&gt;error&lt;/code&gt; property set to the &lt;code&gt;Error&lt;/code&gt;-object which was received from the failed login attempt.</source>
          <target state="translated">서버에서 콜백은 &lt;a href=&quot;#accounts_validateloginattempt&quot;&gt; &lt;code&gt;validateLoginAttempt&lt;/code&gt; &lt;/a&gt; 와 동일한 시도 정보 객체 인 단일 인수를 가져옵니다 . 클라이언트에서 콜백 인수는 실패한 로그인 시도에서 수신 한 &lt;code&gt;Error&lt;/code&gt; -object로 설정된 단일 &lt;code&gt;error&lt;/code&gt; 특성을 포함하는 오브젝트 입니다.</target>
        </trans-unit>
        <trans-unit id="44e718ef4d66951ac14b1cc8841a9c2faf603125" translate="yes" xml:space="preserve">
          <source>On the server, this function can be run either synchronously or asynchronously. If the callback is omitted, it runs synchronously and the results are returned once the request completes successfully. If the request was not successful, an error is thrown. This is useful when making server-to-server HTTP API calls from within Meteor methods, as the method can succeed or fail based on the results of the synchronous HTTP call. In this case, consider using &lt;a href=&quot;#method_unblock&quot;&gt;&lt;code&gt;this.unblock()&lt;/code&gt;&lt;/a&gt; to allow other methods on the same connection to run in the mean time.</source>
          <target state="translated">서버에서이 기능은 동기식 또는 비동기식으로 실행될 수 있습니다. 콜백이 생략되면 동 기적으로 실행되고 요청이 완료되면 결과가 리턴됩니다. 요청이 실패하면 오류가 발생합니다. 이는 메소드가 동기 HTTP 호출의 결과에 따라 성공 또는 실패 할 수 있으므로 Meteor 메소드 내에서 서버 간 HTTP API 호출을 작성할 때 유용합니다. 이 경우 &lt;a href=&quot;#method_unblock&quot;&gt; &lt;code&gt;this.unblock()&lt;/code&gt; &lt;/a&gt; 을 사용하여 같은 연결의 다른 메소드가 그 동안 실행되도록하십시오.</target>
        </trans-unit>
        <trans-unit id="70e2f7a9ecd3c311b66026bbc208b1960fe15249" translate="yes" xml:space="preserve">
          <source>On the server, this will fetch the record from the database. To improve the latency of a method that uses the user document multiple times, save the returned record to a variable instead of re-calling &lt;code&gt;Meteor.user()&lt;/code&gt;.</source>
          <target state="translated">서버에서 데이터베이스에서 레코드를 가져옵니다. 사용자 문서를 여러 번 사용하는 메소드의 대기 시간을 향상 시키려면 &lt;code&gt;Meteor.user()&lt;/code&gt; 를 다시 호출하는 대신 리턴 된 레코드를 변수에 저장하십시오 .</target>
        </trans-unit>
        <trans-unit id="51a986b23985cfc7e29562bb2a712203a4504c44" translate="yes" xml:space="preserve">
          <source>On the server, we use the same technique of importing all the startup code in &lt;code&gt;imports/startup/server/index.js&lt;/code&gt;:</source>
          <target state="translated">서버에서는 &lt;code&gt;imports/startup/server/index.js&lt;/code&gt; 에서 모든 시작 코드를 가져 오는 동일한 기술을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="da923ccab281f74aa36b079065608464d121bd29" translate="yes" xml:space="preserve">
          <source>On the server, you do not need to specify &lt;code&gt;password&lt;/code&gt;, but the user will not be able to log in until it has a password (eg, set with &lt;a href=&quot;#accounts_setpassword&quot;&gt;&lt;code&gt;Accounts.setPassword&lt;/code&gt;&lt;/a&gt;). To create an account without a password on the server and still let the user pick their own password, call &lt;code&gt;createUser&lt;/code&gt; with the &lt;code&gt;email&lt;/code&gt; option and then call &lt;a href=&quot;#accounts_sendenrollmentemail&quot;&gt;&lt;code&gt;Accounts.sendEnrollmentEmail&lt;/code&gt;&lt;/a&gt;. This will send the user an email with a link to set their initial password.</source>
          <target state="translated">서버에서는 &lt;code&gt;password&lt;/code&gt; 를 지정할 필요가 없지만 비밀번호 가있을 때까지 사용자는 로그인 할 수 없습니다 (예 : &lt;a href=&quot;#accounts_setpassword&quot;&gt; &lt;code&gt;Accounts.setPassword&lt;/code&gt; 로&lt;/a&gt; 설정 ). 서버에서 비밀번호없이 계정을 작성하고 사용자가 자신의 비밀번호를 선택하도록 하려면 &lt;code&gt;email&lt;/code&gt; 옵션으로 &lt;code&gt;createUser&lt;/code&gt; 를 호출 한 후 &lt;a href=&quot;#accounts_sendenrollmentemail&quot;&gt; &lt;code&gt;Accounts.sendEnrollmentEmail&lt;/code&gt; &lt;/a&gt; 을 호출하십시오 . 초기 비밀번호를 설정하는 링크가 포함 된 이메일을 사용자에게 보냅니다.</target>
        </trans-unit>
        <trans-unit id="46faa89b0fbc4115f7f4811b4569fdd7a346daf0" translate="yes" xml:space="preserve">
          <source>On the server: this.userId</source>
          <target state="translated">서버에서 : this.userId</target>
        </trans-unit>
        <trans-unit id="44e01a4cda4b433ec03752b4587a42ca1d9aee41" translate="yes" xml:space="preserve">
          <source>Once a module is fetched dynamically from the server, it is cached permanently on the client and additional requests for the same version of the module will not incur the round-trip request to the server. If the module is changed then a fresh copy will always be retrieved from the server.</source>
          <target state="translated">모듈이 서버에서 동적으로 페치되면 모듈은 클라이언트에서 영구적으로 캐시되며 동일한 버전의 모듈에 대한 추가 요청은 서버에 대한 왕복 요청을 발생시키지 않습니다. 모듈이 변경되면 항상 서버에서 새로운 사본이 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="5126f3bcfb9239690a7e3b739eba4ac9d3cc23ef" translate="yes" xml:space="preserve">
          <source>Once a user has visited a Meteor application for the first time and the application has been cached, on subsequent visits the web page loads faster because the browser can load the application out of the cache without contacting the server first.</source>
          <target state="translated">사용자가 처음으로 Meteor 응용 프로그램을 방문하고 응용 프로그램이 캐시되면 브라우저는 서버에 먼저 연결하지 않고도 브라우저가 응용 프로그램을 캐시에서로드 할 수 있기 때문에 웹 페이지가 더 빨리로드됩니다.</target>
        </trans-unit>
        <trans-unit id="ca107596881d6b20257fbc20a6164119f3ec317a" translate="yes" xml:space="preserve">
          <source>Once a user is logged into your app with one of the methods described above, it is useful to be able to identify which user is logged in, and get the data provided during the registration process.</source>
          <target state="translated">위에서 설명한 방법 중 하나를 사용하여 사용자가 앱에 로그인하면 로그인 한 사용자를 식별하고 등록 프로세스 동안 제공된 데이터를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3297f83bd8f9951ac215ba7e4a1c6167cbe66f8" translate="yes" xml:space="preserve">
          <source>Once enabled, view the application in a web-browser as usual (e.g. &lt;code&gt;http://localhost:3000/&lt;/code&gt;) and the chart will be displayed on top of the application.</source>
          <target state="translated">활성화되면 평소와 같이 웹 브라우저에서 애플리케이션을 봅니다 (예 : &lt;code&gt;http://localhost:3000/&lt;/code&gt; ). 차트가 애플리케이션 상단에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2533b6541866ff4914792590e5df2e6bc1eb1c54" translate="yes" xml:space="preserve">
          <source>Once installed, you&amp;rsquo;ll be able to import the &lt;code&gt;withTracker&lt;/code&gt; function, which allows you to create a &lt;a href=&quot;https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.by86emv9b&quot;&gt;container component&lt;/a&gt; which provides data to your presentational components.</source>
          <target state="translated">일단 설치되면 &lt;code&gt;withTracker&lt;/code&gt; 기능 을 가져 와서 프리젠 테이션 컴포넌트에 데이터를 제공 하는 &lt;a href=&quot;https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.by86emv9b&quot;&gt;컨테이너 컴포넌트&lt;/a&gt; 를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b67d613887650758e15f19b06c6a5f36853067c8" translate="yes" xml:space="preserve">
          <source>Once that template exists, we can simply wrap our &lt;code&gt;Lists_show_page&lt;/code&gt;:</source>
          <target state="translated">해당 템플릿이 존재하면 &lt;code&gt;Lists_show_page&lt;/code&gt; 를 간단히 래핑 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="518704cb2e96bb183f262fdaec85e1f23718b579" translate="yes" xml:space="preserve">
          <source>Once the Method has finished running on the server, it sends a &lt;code&gt;result&lt;/code&gt; message to the client with the Method ID generated in step 2, and the return value itself. The client stores this for later use, but &lt;em&gt;doesn&amp;rsquo;t call the Method callback yet&lt;/em&gt;. If you pass the &lt;a href=&quot;http://docs.meteor.com/#/full/meteor_apply&quot;&gt;&lt;code&gt;onResultReceived&lt;/code&gt; option to &lt;code&gt;Meteor.apply&lt;/code&gt;&lt;/a&gt;, that callback is fired.</source>
          <target state="translated">메소드가 서버에서 실행을 완료하면 2 단계에서 생성 된 메소드 ID와 리턴 값 자체를 사용하여 &lt;code&gt;result&lt;/code&gt; 메시지를 클라이언트에 보냅니다 . 클라이언트는 이것을 나중에 사용하기 위해 저장하지만 &lt;em&gt;메소드 콜백을 아직 호출하지 않습니다&lt;/em&gt; . &lt;a href=&quot;http://docs.meteor.com/#/full/meteor_apply&quot;&gt; &lt;code&gt;onResultReceived&lt;/code&gt; 옵션을 &lt;code&gt;Meteor.apply&lt;/code&gt; 에&lt;/a&gt; 전달하면 해당 콜백이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="e5f45093103cdeb6f86503596e29067b6099beff" translate="yes" xml:space="preserve">
          <source>Once the state dictionary has been created we can access it from helpers and modify it in event handlers (see the code snippet above).</source>
          <target state="translated">상태 사전이 생성되면 헬퍼에서 액세스하여 이벤트 핸들러에서 수정할 수 있습니다 (위의 코드 스 니펫 참조).</target>
        </trans-unit>
        <trans-unit id="347c43bf77a2e13e82e0b560b35bac5a9376f97e" translate="yes" xml:space="preserve">
          <source>Once we&amp;rsquo;ve attached this helper to the &lt;code&gt;Lists&lt;/code&gt; collection, every time we fetch a list from the database (on the client or server), it will have a &lt;code&gt;.isPrivate()&lt;/code&gt; function available:</source>
          <target state="translated">이 도우미를 &lt;code&gt;Lists&lt;/code&gt; 컬렉션에 연결 하면 데이터베이스에서 클라이언트 또는 서버의 목록을 가져올 때마다 &lt;code&gt;.isPrivate()&lt;/code&gt; 함수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e932fec5060640656d7330ec7f00490b7967c3bf" translate="yes" xml:space="preserve">
          <source>Once you are satisfied with the staging release, release the &lt;em&gt;exact same&lt;/em&gt; version to production.</source>
          <target state="translated">스테이징 릴리스에 만족하면 &lt;em&gt;정확히 동일한&lt;/em&gt; 버전을 프로덕션에 릴리스하십시오 .</target>
        </trans-unit>
        <trans-unit id="a79bba56d135c41c83bd6533395e726d2300f863" translate="yes" xml:space="preserve">
          <source>Once you are setup with Galaxy, deployment is simple (just re-run the &lt;code&gt;meteor deploy&lt;/code&gt; command above), and scaling is even easier&amp;mdash;simply log into galaxy.meteor.com, and scale instantly from there.</source>
          <target state="translated">Galaxy로 설정 한 후에는 배포가 간단하고 ( 위 의 &lt;code&gt;meteor deploy&lt;/code&gt; 명령을 다시 실행하면 됨 ) 확장이 훨씬 쉬워집니다. 간단히 galaxy.meteor.com에 로그인하면 바로 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d567acddad201ed3ca8ae40b9e92daa2588d7e9e" translate="yes" xml:space="preserve">
          <source>Once you configure routing according to &lt;a href=&quot;#useraccounts-customizing-routes&quot;&gt;the section below&lt;/a&gt;, you&amp;rsquo;ll want to remove this inclusion.</source>
          <target state="translated">&lt;a href=&quot;#useraccounts-customizing-routes&quot;&gt;아래 섹션&lt;/a&gt; 에 따라 라우팅을 구성하면 이 포함을 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="495554e141ec4fb979c87f48a245cd122a124f3c" translate="yes" xml:space="preserve">
          <source>Once you have your account you can log in and log out from the command line, and check your username with &lt;code&gt;meteor whoami&lt;/code&gt;.</source>
          <target state="translated">계정이 있으면 명령 줄에서 로그인 및 로그 아웃하고 &lt;code&gt;meteor whoami&lt;/code&gt; 로 사용자 이름을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b0b6798a5ef1f56f315834a343e71297556b86a0" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;ve built and tested your Meteor application, you need to put it online to show it to the world. Deploying a Meteor application is similar to deploying any other websocket-based Node.js app, but is different in some of the specifics.</source>
          <target state="translated">Meteor 응용 프로그램을 빌드하고 테스트 한 후에는 온라인으로 표시하여 전 세계에 표시해야합니다. Meteor 애플리케이션 배포는 다른 웹 소켓 기반 Node.js 앱 배포와 유사하지만 일부 특성이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8e9d02714832708eb544d6a7629765641536185d" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;ve done that, it&amp;rsquo;s easy to &lt;a href=&quot;http://galaxy-guide.meteor.com/deploy-guide.html&quot;&gt;deploy to Galaxy&lt;/a&gt;. You just need to &lt;a href=&quot;http://galaxy-guide.meteor.com/environment-variables.html&quot;&gt;add some environment variables to your settings file&lt;/a&gt; to point it at your MongoDB, and you can deploy with:</source>
          <target state="translated">이 작업을 마치면 &lt;a href=&quot;http://galaxy-guide.meteor.com/deploy-guide.html&quot;&gt;Galaxy에&lt;/a&gt; 쉽게 배포 할 수 있습니다. &lt;a href=&quot;http://galaxy-guide.meteor.com/environment-variables.html&quot;&gt;환경 파일&lt;/a&gt; 을 설정 파일 에 추가 하여 MongoDB를 가리 키기 만하면 다음과 같이 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8340eb82f46c8b657e390886dfec30a56bdd7b50" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;ve gotten your initial prototype up and running with &lt;code&gt;accounts-ui&lt;/code&gt;, you&amp;rsquo;ll want to move to something more powerful and configurable so that you can better integrate your login flow with the rest of your app. The &lt;a href=&quot;https://github.com/meteor-useraccounts/core/blob/master/Guide.md&quot;&gt;&lt;code&gt;useraccounts&lt;/code&gt; family of packages&lt;/a&gt; is the most powerful set of accounts management UI controls available for Meteor today. If you need even more customization, you can also roll your own system, but it&amp;rsquo;s worth trying &lt;code&gt;useraccounts&lt;/code&gt; first.</source>
          <target state="translated">초기 프로토 타입을 입수하고 &lt;code&gt;accounts-ui&lt;/code&gt; 로 실행 한 후에는 로그인 흐름을 앱의 나머지 부분과 더 잘 통합 할 수 있도록보다 강력하고 구성 가능한 것으로 이동해야합니다. &lt;a href=&quot;https://github.com/meteor-useraccounts/core/blob/master/Guide.md&quot;&gt; &lt;code&gt;useraccounts&lt;/code&gt; 의 패키지 제품군은&lt;/a&gt; 유성 오늘에 사용할 계정 관리 UI 컨트롤의 가장 강력한 세트입니다. 당신은 더 많은 사용자 정의가 필요하면, 당신은 또한 자신의 시스템을 롤백 할 수 있지만, 그것의 가치가 노력 &lt;code&gt;useraccounts&lt;/code&gt; 을 처음.</target>
        </trans-unit>
        <trans-unit id="c2245af3bb92516236d9d1a660cffb3a958845a5" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;ve identified which template you need to replace, define a new template. In this case, we want to modify the class on the button to work with the CSS for the rest of the app. There are a few things to keep in mind when overriding a template:</source>
          <target state="translated">어떤 템플릿을 교체해야하는지 확인한 후에 새 템플릿을 정의하십시오. 이 경우 나머지 앱의 CSS에서 작동하도록 버튼의 클래스를 수정하려고합니다. 템플릿을 재정의 할 때 명심해야 할 몇 가지 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="07efbff30db87de8792d19052d5b4969fe7b2327" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;ve installed Meteor, create a project:</source>
          <target state="translated">Meteor를 설치 한 후 프로젝트를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="ee1b302d4495249d5c1da36f025f44bf60439b3b" translate="yes" xml:space="preserve">
          <source>One Method per action</source>
          <target state="translated">액션 당 하나의 방법</target>
        </trans-unit>
        <trans-unit id="c04f6ddb98dfa183e1fc6dbeb56f4edf30b31471" translate="yes" xml:space="preserve">
          <source>One easy way to do this is with the &lt;a href=&quot;https://atmospherejs.com/gadicc/blaze-react-component&quot;&gt;&lt;code&gt;gadicc:blaze-react-component&lt;/code&gt;&lt;/a&gt; package. First run &lt;code&gt;meteor add gadicc:blaze-react-component&lt;/code&gt;, then import and use it in your components as follows:</source>
          <target state="translated">가장 쉬운 방법은 &lt;a href=&quot;https://atmospherejs.com/gadicc/blaze-react-component&quot;&gt; &lt;code&gt;gadicc:blaze-react-component&lt;/code&gt; &lt;/a&gt; 패키지를 사용하는 것입니다. 먼저 &lt;code&gt;meteor add gadicc:blaze-react-component&lt;/code&gt; 를 실행 한 후 다음과 같이 컴포넌트에서 가져 와서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b4e643759a6bb30e66b05248d66eedbe8cd16600" translate="yes" xml:space="preserve">
          <source>One important feature of the Atmosphere package system is that it is single-loading: no two packages in the same app can have dependencies on conflicting versions of a single package. Read more about that in the section about version constraints below.</source>
          <target state="translated">Atmosphere 패키지 시스템의 중요한 기능 중 하나는 단일로드라는 점입니다. 동일한 앱의 두 패키지는 충돌하는 단일 패키지 버전에 종속 될 수 없습니다. 아래 버전 제약 조건 섹션에서 이에 대해 자세히 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="a385a8c56b13d68d8d80acee5e67db57b806032a" translate="yes" xml:space="preserve">
          <source>One nice UX pattern which Meteor makes much easier than other frameworks is Optimistic UI. Optimistic UI is the process of showing user-generated changes in the UI without waiting for the server to acknowledge that the change has succeeded, resulting in a user experience that seems faster than is physically possible, since you don&amp;rsquo;t need to wait for any server roundtrips. Since most user actions in a well-designed app will be successful, it makes sense for almost all parts of an app to be optimistic in this way.</source>
          <target state="translated">Meteor가 다른 프레임 워크보다 훨씬 쉽게 만드는 멋진 UX 패턴은 낙관적 UI입니다. 낙관적 UI는 서버가 변경 성공을 인식 할 때까지 기다리지 않고 UI에서 사용자 생성 변경 사항을 표시하는 프로세스로, 사용자가 기다릴 필요가 없기 때문에 물리적으로 가능한 것보다 빠른 사용자 경험을 제공합니다. 서버 왕복. 잘 설계된 앱에서 대부분의 사용자 작업이 성공하기 때문에 앱의 거의 모든 부분이 이런 방식으로 낙관적입니다.</target>
        </trans-unit>
        <trans-unit id="e937530a73456e4947fbe9e89b792149c17ae25f" translate="yes" xml:space="preserve">
          <source>One of the main reasons you might want to add a login system to your app is to have permissions for your data. For example, if you were running a forum, you would want administrators or moderators to be able to delete any post, but normal users can only delete their own. This uncovers two different types of permissions:</source>
          <target state="translated">앱에 로그인 시스템을 추가하려는 주된 이유 중 하나는 데이터에 대한 권한이 있기 때문입니다. 예를 들어, 포럼을 실행중인 경우 관리자 나 중재자가 게시물을 삭제할 수 있지만 일반 사용자는 자신의 게시물 만 삭제할 수 있습니다. 이를 통해 두 가지 유형의 권한이 발견됩니다.</target>
        </trans-unit>
        <trans-unit id="06a8f7a0da4f4e262df831f068c68fbacedbde0d" translate="yes" xml:space="preserve">
          <source>One of the most core concepts in Blaze is the &amp;ldquo;view&amp;rdquo;, which is a building block that represents a reactively rendering area of a template. The view is the machinery that works behind the scenes to track reactivity, do lookups, and re-render appropriately when data changes. The view is the unit of re-rendering in Blaze. You can even use the view tree to walk the rendered component hierarchy, but it&amp;rsquo;s better to avoid this in favor of communicating between components using callbacks, template arguments, or global data stores.</source>
          <target state="translated">Blaze의 가장 핵심적인 개념 중 하나는 템플릿의 반응 렌더링 영역을 나타내는 빌딩 블록 인 &quot;보기&quot;입니다. 뷰는 장면 뒤에서 작동하여 데이터를 변경할 때 반응성을 추적하고 조회를 수행하고 적절하게 다시 렌더링하는 메커니즘입니다. 뷰는 Blaze에서 다시 렌더링하는 단위입니다. 뷰 트리를 사용하여 렌더링 된 구성 요소 계층 구조를 따라갈 수도 있지만 콜백, 템플릿 인수 또는 전역 데이터 저장소를 사용하여 구성 요소 간 통신을 선호하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ef78943e212ce2b6432240b049e5ec156d119ce3" translate="yes" xml:space="preserve">
          <source>One option would be to provide a Method that simply proxies through to the endpoint, for which it&amp;rsquo;s the client&amp;rsquo;s responsibility to poll and deal with the changing data as it comes in. So then it&amp;rsquo;s the clients problem to deal with keeping a local data cache of the data, updating the UI when changes happen, etc. Although this is possible (you could use a Local Collection to store the polled data, for instance), it&amp;rsquo;s simpler, and more natural to create a publication that does this polling for the client.</source>
          <target state="translated">한 가지 옵션은 엔드 포인트로 프록시하는 방법을 제공하는 것입니다. 엔드 포인트를 통해 프록시는 변경되는 데이터를 폴링하고 처리하는 것은 고객의 책임입니다. 따라서 로컬 데이터 캐시를 유지하는 것은 클라이언트 문제입니다. 변경이 발생할 때 UI 업데이트 등 .</target>
        </trans-unit>
        <trans-unit id="13ade0ae6464b55152b92afe05db99bf707f6c21" translate="yes" xml:space="preserve">
          <source>One piece of information that&amp;rsquo;s very useful to know when paginating data is the &lt;em&gt;total number of items&lt;/em&gt; that you could see. The &lt;a href=&quot;https://atmospherejs.com/tmeasday/publish-counts&quot;&gt;&lt;code&gt;tmeasday:publish-counts&lt;/code&gt;&lt;/a&gt; package can be useful to publish this. We could add a &lt;code&gt;Lists.todoCount&lt;/code&gt; publication like so</source>
          <target state="translated">페이지 매김 데이터를 알 때 매우 유용한 정보 는 볼 &lt;em&gt;수&lt;/em&gt; 있는 &lt;em&gt;총 항목 수입니다&lt;/em&gt; . &lt;a href=&quot;https://atmospherejs.com/tmeasday/publish-counts&quot;&gt; &lt;code&gt;tmeasday:publish-counts&lt;/code&gt; &lt;/a&gt; 패키지는이를 게시하는 것이 유용 할 수 있습니다. &lt;code&gt;Lists.todoCount&lt;/code&gt; 게시를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9155e7b13809f3145b26bd096ae4b49da222b840" translate="yes" xml:space="preserve">
          <source>One place where you might be tempted to not subscribe inside a component is when it accesses data that you know you &lt;em&gt;always&lt;/em&gt; need. For instance, a subscription to extra fields on the user object (see the &lt;a href=&quot;accounts&quot;&gt;Accounts Article&lt;/a&gt;) that you need on every screen of your app.</source>
          <target state="translated">구성 요소 내에서 구독하지 않으려는 유혹이있는 곳은 &lt;em&gt;항상&lt;/em&gt; 필요한 데이터에 액세스 할 때 입니다. 예를 들어, 앱의 모든 화면에서 필요한 사용자 개체 ( &lt;a href=&quot;accounts&quot;&gt;계정 기사&lt;/a&gt; 참조)의 추가 필드 구독 .</target>
        </trans-unit>
        <trans-unit id="608d93788c7134f13b44e6cff596ee22398405ab" translate="yes" xml:space="preserve">
          <source>One point to be aware of is that if you allow the user to &lt;em&gt;modify&lt;/em&gt; data in the &amp;ldquo;pseudo-collection&amp;rdquo; you are publishing in this fashion, you&amp;rsquo;ll want to be sure to re-publish the modifications to them via the publication, to achieve an optimistic user experience.</source>
          <target state="translated">한 가지 알아야 할 점은 사용자가 이러한 방식으로 게시하는 &quot;의사 수집&quot;에서 데이터 를 &lt;em&gt;수정&lt;/em&gt; 하도록 허용하는 경우 게시를 통해 수정 사항을 다시 게시해야한다는 것입니다. 낙관적 인 사용자 경험을 달성하십시오.</target>
        </trans-unit>
        <trans-unit id="6f6ae0797bb8ef145fb858f43b8362540c55b435" translate="yes" xml:space="preserve">
          <source>One situation where it is sensible to access the global &lt;code&gt;FlowRouter&lt;/code&gt; singleton to access the current route&amp;rsquo;s information deeper in the component hierarchy is when rendering links via a navigation component. It&amp;rsquo;s often required to highlight the &amp;ldquo;active&amp;rdquo; route in some way (this is the route or section of the site that the user is currently looking at).</source>
          <target state="translated">글로벌 &lt;code&gt;FlowRouter&lt;/code&gt; 싱글 톤에 액세스하여 컴포넌트 계층 구조에서 더 깊은 현재 경로 정보에 액세스 할 수있는 상황 중 하나 는 탐색 컴포넌트를 통해 링크를 렌더링 할 때입니다. 어떤 방식 으로든 '활성'경로를 강조 표시해야하는 경우가 종종 있습니다 (사용자가 현재보고있는 사이트의 경로 또는 섹션 임).</target>
        </trans-unit>
        <trans-unit id="562214d843f76fb2b35cadaeefc26055b679ded2" translate="yes" xml:space="preserve">
          <source>One solution to this problem is to &lt;em&gt;animate&lt;/em&gt; list changes (which we&amp;rsquo;ll look at in the &lt;a href=&quot;#animation&quot;&gt;animation section&lt;/a&gt;), but this isn&amp;rsquo;t always the best approach. For instance, if a user is reading a list of comments, they may not want to see any changes until they are done with the current comment thread.</source>
          <target state="translated">이 문제에 대한 한 가지 해결책은 목록 변경 ( &lt;a href=&quot;#animation&quot;&gt;애니메이션 섹션&lt;/a&gt; 에서 살펴볼 것 )에 &lt;em&gt;애니메이션&lt;/em&gt; 을 &lt;em&gt;적용&lt;/em&gt; 하는 것이지만 이것이 항상 최선의 방법은 아닙니다. 예를 들어, 사용자가 주석 목록을 읽고있는 경우 현재 주석 스레드로 완료 될 때까지 변경 사항을보고 싶지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="693bec8c10a316807a838ab0ff97f378c6c16e6e" translate="yes" xml:space="preserve">
          <source>One thing that Collection2 does is &lt;a href=&quot;https://github.com/aldeed/meteor-simple-schema#cleaning-data&quot;&gt;&amp;ldquo;clean&amp;rdquo; the data&lt;/a&gt; before sending it to the database. This includes but is not limited to:</source>
          <target state="translated">Collection2가하는 한 가지 일은 &lt;a href=&quot;https://github.com/aldeed/meteor-simple-schema#cleaning-data&quot;&gt;데이터&lt;/a&gt; 를 데이터베이스로 보내기 전에 데이터 를 &quot;정리&quot;하는 것입니다 . 여기에는 다음이 포함되지만 이에 국한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0485d121b4175432f75b9f140338ecf12c31adb" translate="yes" xml:space="preserve">
          <source>One useful thing to add for your app can be the concept of a &amp;ldquo;primary&amp;rdquo; email address. This way, if the user has added multiple emails, you know where to send confirmation emails and similar.</source>
          <target state="translated">앱에 추가해야 할 유용한 것 중 하나는 &quot;기본&quot;전자 메일 주소의 개념 일 수 있습니다. 이렇게하면 사용자가 여러 개의 전자 메일을 추가 한 경우 확인 전자 메일을 보낼 위치와 이와 유사한 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1519b8207491f20e999cd392260925e037f7ea50" translate="yes" xml:space="preserve">
          <source>One way to avoid this problem is simply to not run old migrations on your database. This is a little bit limiting but can be made to work.</source>
          <target state="translated">이 문제를 피하는 한 가지 방법은 단순히 데이터베이스에서 이전 마이그레이션을 실행하지 않는 것입니다. 이것은 약간 제한적이지만 작동하도록 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b863f5ac47796b55bc346cc4d5f3111291eb7ea" translate="yes" xml:space="preserve">
          <source>One way you might do this is to return more than one cursor from your publication function:</source>
          <target state="translated">이를 수행 할 수있는 한 가지 방법은 공개 함수에서 둘 이상의 커서를 리턴하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c486be9ae16a7ac67b0f4a4441bf70865ffc185f" translate="yes" xml:space="preserve">
          <source>Ongoing Meteor Guide development takes place &lt;strong&gt;in the open&lt;/strong&gt;&lt;a href=&quot;https://github.com/meteor/guide&quot;&gt;on GitHub&lt;/a&gt;. We encourage pull requests and issues to discuss problems with any changes that could be made to the content. We hope that keeping our process open and honest will make it clear what we plan to include in the guide and what changes will be coming in future Meteor versions.</source>
          <target state="translated">지속적인 Meteor Guide 개발은 &lt;a href=&quot;https://github.com/meteor/guide&quot;&gt;GitHub &lt;/a&gt;&lt;strong&gt;에서 공개적 &lt;/strong&gt;으로 진행 &lt;strong&gt;됩니다&lt;/strong&gt; . 콘텐츠를 변경할 수있는 변경 사항에 대한 문제를 논의하기 위해 풀 요청 및 문제를 권장합니다. 프로세스를 공개적이고 정직하게 유지하면 가이드에 포함 할 계획과 향후 Meteor 버전에서 어떤 변경 사항이 있을지 명확하게 알 수 있기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="e739463e4e362c55895faf2e10c7086bf5a233fa" translate="yes" xml:space="preserve">
          <source>Only Mongo modifiers are supported (operations like &lt;code&gt;$set&lt;/code&gt; and &lt;code&gt;$push&lt;/code&gt;). If the user tries to replace the entire document rather than use $-modifiers, the request will be denied without checking the &lt;code&gt;allow&lt;/code&gt; functions.</source>
          <target state="translated">Mongo 수정 자만 지원됩니다 ( &lt;code&gt;$set&lt;/code&gt; 및 &lt;code&gt;$push&lt;/code&gt; 와 같은 작업 ). 사용자가 $ -modifiers를 사용하지 않고 전체 문서를 바꾸려고하면 &lt;code&gt;allow&lt;/code&gt; 함수 를 확인하지 않고 요청이 거부 됩니다.</target>
        </trans-unit>
        <trans-unit id="bcc7b6ef21aca15c9c2763c827121f349454d3c6" translate="yes" xml:space="preserve">
          <source>Open a MongoDB shell on your local development database, so that you can view or manipulate it directly.</source>
          <target state="translated">로컬 개발 데이터베이스에서 MongoDB 쉘을 열어서 직접 보거나 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a24a835f884e2a5d3c2192aa79cd616a0545d748" translate="yes" xml:space="preserve">
          <source>Open the &lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads/index.html&quot;&gt;Oracle Java website&lt;/a&gt;, and select the Java Platform (JDK)</source>
          <target state="translated">&lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads/index.html&quot;&gt;Oracle Java 웹 사이트를&lt;/a&gt; 열고 Java 플랫폼 (JDK)을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="e5dada9f07f167d018202682b7db0a7675413f41" translate="yes" xml:space="preserve">
          <source>Optimistic UI</source>
          <target state="translated">낙관적 UI</target>
        </trans-unit>
        <trans-unit id="643ad30923efda6edaefd043c0ed2f56f3f2df12" translate="yes" xml:space="preserve">
          <source>Optional - whether the new email address should be marked as verified. Defaults to false.</source>
          <target state="translated">선택 사항-새 이메일 주소를 확인 된 것으로 표시해야하는지 여부 기본값은 false입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
