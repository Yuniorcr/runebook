<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="vue_router">
    <body>
      <group id="vue_router">
        <trans-unit id="bbc943a2e601e6b13b22293e246af47a7e54b1bd" translate="yes" xml:space="preserve">
          <source>$route</source>
          <target state="translated">$route</target>
        </trans-unit>
        <trans-unit id="ae47c41f673b2d58768b8be64b33f63e643a81b0" translate="yes" xml:space="preserve">
          <source>$route.fullPath</source>
          <target state="translated">$route.fullPath</target>
        </trans-unit>
        <trans-unit id="bd933596293770a6a74175a52ae61bad2c0805eb" translate="yes" xml:space="preserve">
          <source>$route.hash</source>
          <target state="translated">$route.hash</target>
        </trans-unit>
        <trans-unit id="1b2f0bcf5085a69565f7f3dd9b2669dccab0aedd" translate="yes" xml:space="preserve">
          <source>$route.matched</source>
          <target state="translated">$route.matched</target>
        </trans-unit>
        <trans-unit id="2dcfeb60738fd374f4147229df77d39ff75b2dee" translate="yes" xml:space="preserve">
          <source>$route.name</source>
          <target state="translated">$route.name</target>
        </trans-unit>
        <trans-unit id="2ef5c591965bcc329c5ebc1dfcb687114f817e1e" translate="yes" xml:space="preserve">
          <source>$route.params</source>
          <target state="translated">$route.params</target>
        </trans-unit>
        <trans-unit id="a32363633914d08a7464643f6fd716fb4787a5a1" translate="yes" xml:space="preserve">
          <source>$route.path</source>
          <target state="translated">$route.path</target>
        </trans-unit>
        <trans-unit id="356305ca6d453ad02b108afe16317e19fef48b63" translate="yes" xml:space="preserve">
          <source>$route.query</source>
          <target state="translated">$route.query</target>
        </trans-unit>
        <trans-unit id="fb7ea86b30882f9789be7514b521bc39b211fc50" translate="yes" xml:space="preserve">
          <source>$route.redirectedFrom</source>
          <target state="translated">$route.redirectedFrom</target>
        </trans-unit>
        <trans-unit id="e2b54aaf637a706167ffdbc58bf59fe6f6ebb14c" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2013&amp;ndash;present Evan You</source>
          <target state="translated">&amp;copy; 2013&amp;ndash; 현재 Evan You</target>
        </trans-unit>
        <trans-unit id="17056c6f3b828e55a0714e10813195205ded5f4a" translate="yes" xml:space="preserve">
          <source>&amp;lt;router-link&amp;gt;</source>
          <target state="translated">&amp;lt;router-link&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9e5f35bd4b348475e6427871362480610fedb18d" translate="yes" xml:space="preserve">
          <source>&amp;lt;router-link&amp;gt; `active-class` prop</source>
          <target state="translated">&amp;lt;라우터 링크&amp;gt;`액티브 클래스`소품</target>
        </trans-unit>
        <trans-unit id="0919d275fffa1249415d2c149b2fcf4833a87845" translate="yes" xml:space="preserve">
          <source>&amp;lt;router-link&amp;gt; `append` prop</source>
          <target state="translated">&amp;lt;router-link&amp;gt;`append` prop</target>
        </trans-unit>
        <trans-unit id="8e5bcf9a8806af0c5517632e7a22fc8c6b301e4e" translate="yes" xml:space="preserve">
          <source>&amp;lt;router-link&amp;gt; `event` prop</source>
          <target state="translated">&amp;lt;라우터 링크&amp;gt;`이벤트`소품</target>
        </trans-unit>
        <trans-unit id="64256a593489293bc997bac113451c603807527c" translate="yes" xml:space="preserve">
          <source>&amp;lt;router-link&amp;gt; `exact-active-class` prop</source>
          <target state="translated">&amp;lt;router-link&amp;gt;`exact-active-class` prop</target>
        </trans-unit>
        <trans-unit id="dcacc42c9c63ee714569aa3e93438661925b20a6" translate="yes" xml:space="preserve">
          <source>&amp;lt;router-link&amp;gt; `exact` prop</source>
          <target state="translated">&amp;lt;라우터 링크&amp;gt;`정확한`소품</target>
        </trans-unit>
        <trans-unit id="62a59864940863d5f5f310c91b2015056dcfe20d" translate="yes" xml:space="preserve">
          <source>&amp;lt;router-link&amp;gt; `replace` prop</source>
          <target state="translated">&amp;lt;router-link&amp;gt;`replace` prop</target>
        </trans-unit>
        <trans-unit id="17c934050ccdd19eab898c5be992e0f077075433" translate="yes" xml:space="preserve">
          <source>&amp;lt;router-link&amp;gt; `tag` prop</source>
          <target state="translated">&amp;lt;router-link&amp;gt;`tag` prop</target>
        </trans-unit>
        <trans-unit id="62afbd0360009766d040dcd101d2ac55aad87577" translate="yes" xml:space="preserve">
          <source>&amp;lt;router-link&amp;gt; `to` prop</source>
          <target state="translated">&amp;lt;라우터 링크&amp;gt;`to` prop</target>
        </trans-unit>
        <trans-unit id="b717f260fbb5dd71166ff6f87fc04bafa674fdeb" translate="yes" xml:space="preserve">
          <source>&amp;lt;router-view&amp;gt;</source>
          <target state="translated">&amp;lt;router-view&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4917556424377e1bac5bec47f7e51fcce47c92c8" translate="yes" xml:space="preserve">
          <source>&amp;lt;router-view&amp;gt; `name` prop</source>
          <target state="translated">&amp;lt;router-view&amp;gt;`name` prop</target>
        </trans-unit>
        <trans-unit id="d980089e856205bcec5547594f80529b4bb2dbf4" translate="yes" xml:space="preserve">
          <source>/user/:username</source>
          <target state="translated">/user/:username</target>
        </trans-unit>
        <trans-unit id="8e473671079d8bf355ffb5aeaa2520e6e19a39c5" translate="yes" xml:space="preserve">
          <source>/user/:username/post/:post_id</source>
          <target state="translated">/user/:username/post/:post_id</target>
        </trans-unit>
        <trans-unit id="3e68ca614f1e2a458bd8cee024e17ec781d46d7f" translate="yes" xml:space="preserve">
          <source>/user/evan</source>
          <target state="translated">/user/evan</target>
        </trans-unit>
        <trans-unit id="8355ca333b10656272c592da956843def0d8c9b8" translate="yes" xml:space="preserve">
          <source>/user/evan/post/123</source>
          <target state="translated">/user/evan/post/123</target>
        </trans-unit>
        <trans-unit id="a3c37385e6b17ff0279b3d5ab84993b537814527" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;guide/index&quot;&gt;Get started&lt;/a&gt; or play with the &lt;a href=&quot;https://github.com/vuejs/vue-router/tree/dev/examples&quot;&gt;examples&lt;/a&gt; (see &lt;a href=&quot;https://github.com/vuejs/vue-router/&quot;&gt;&lt;code&gt;README.md&lt;/code&gt;&lt;/a&gt; to run them).</source>
          <target state="translated">&lt;a href=&quot;guide/index&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/vuejs/vue-router/tree/dev/examples&quot;&gt;예제를 &lt;/a&gt;시작 하거나 실행 하십시오 ( &lt;a href=&quot;https://github.com/vuejs/vue-router/&quot;&gt; &lt;code&gt;README.md&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5f568f5d151a701cff64bbb17fc3099dac774ab9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://unpkg.com&quot;&gt;Unpkg.com&lt;/a&gt; provides npm-based CDN links. The above link will always point to the latest release on npm. You can also use a specific version/tag via URLs like &lt;code&gt;https://unpkg.com/vue-router@2.0.0/dist/vue-router.js&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://unpkg.com&quot;&gt;Unpkg.com&lt;/a&gt; 은 npm 기반 CDN 링크를 제공합니다. 위의 링크는 항상 npm의 최신 릴리스를 가리 킵니다. &lt;code&gt;https://unpkg.com/vue-router@2.0.0/dist/vue-router.js&lt;/code&gt; 와 같은 URL을 통해 특정 버전 / 태그를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="adc059da745e5ec5d6cb942898d0e5f4e41769a2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://vuejs.org/guide/transitions.html&quot;&gt;All transition APIs&lt;/a&gt; work the same here.</source>
          <target state="translated">&lt;a href=&quot;https://vuejs.org/guide/transitions.html&quot;&gt;모든 전환 API&lt;/a&gt; 는 여기서 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ee5023e7150c1db9bd8af9a146a524ca3c97c6c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; Props</source>
          <target state="translated">&lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; 소품</target>
        </trans-unit>
        <trans-unit id="fcb64e7180cfede93521de20cc5070e7faf2f0d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; is preferred over hard-coded &lt;code&gt;&amp;lt;a href=&quot;...&quot;&amp;gt;&lt;/code&gt; for the following reasons:</source>
          <target state="translated">&lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; 는 다음과 같은 이유로 하드 코딩 된 &lt;code&gt;&amp;lt;a href=&quot;...&quot;&amp;gt;&lt;/code&gt; 보다 선호 됩니다.</target>
        </trans-unit>
        <trans-unit id="391a8cb2c3e0dcdc37873698e88d0be707ba1503" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; is the component for enabling user navigation in a router-enabled app. The target location is specified with the &lt;code&gt;to&lt;/code&gt; prop. It renders as an &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; tag with correct &lt;code&gt;href&lt;/code&gt; by default, but can be configured with the &lt;code&gt;tag&lt;/code&gt; prop. In addition, the link automatically gets an active CSS class when the target route is active.</source>
          <target state="translated">&lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; 는 라우터 지원 앱에서 사용자 탐색을 활성화하기위한 구성 요소입니다. 대상 위치는 &lt;code&gt;to&lt;/code&gt; prop으로 지정됩니다 . 기본적 으로 올바른 &lt;code&gt;href&lt;/code&gt; 가 있는 &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 태그로 렌더링 되지만 &lt;code&gt;tag&lt;/code&gt; 소품 으로 구성 할 수 있습니다 . 또한 대상 경로가 활성화되면 링크가 자동으로 활성 CSS 클래스를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="751d371787cc9b4f7b424a9cbedecf5d396458eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;router-view&amp;gt;&lt;/code&gt; Props</source>
          <target state="translated">&lt;code&gt;&amp;lt;router-view&amp;gt;&lt;/code&gt; 소품</target>
        </trans-unit>
        <trans-unit id="aa40192fa2b6ce9811978688ea693865c7a66fb8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Nav&lt;/code&gt; is just a regular component</source>
          <target state="translated">&lt;code&gt;Nav&lt;/code&gt; 는 단지 정규 구성 요소입니다</target>
        </trans-unit>
        <trans-unit id="d4d4da5b1052cfaa8e18ae6636b0a0bdb2226cf7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UserEmailsSubscriptions&lt;/code&gt;, &lt;code&gt;UserProfile&lt;/code&gt;, &lt;code&gt;UserProfilePreview&lt;/code&gt; are nested view components</source>
          <target state="translated">&lt;code&gt;UserEmailsSubscriptions&lt;/code&gt; , &lt;code&gt;UserProfile&lt;/code&gt; , &lt;code&gt;UserProfilePreview&lt;/code&gt; 는 중첩 된보기 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="339bb7bce4bdd7501eede7218e8fffaf06787009" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UserSettings&lt;/code&gt; is the view component</source>
          <target state="translated">&lt;code&gt;UserSettings&lt;/code&gt; 는 뷰 구성 요소입니다</target>
        </trans-unit>
        <trans-unit id="c248d8bb241f09ffb6fbc7f22d684eb0a1d8b67a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;abstract&lt;/code&gt;: works in all JavaScript environments, e.g. server-side with Node.js. &lt;strong&gt;The router will automatically be forced into this mode if no browser API is present.&lt;/strong&gt;</source>
          <target state="translated">&lt;code&gt;abstract&lt;/code&gt; : 모든 JavaScript 환경에서 작동합니다 (예 : Node.js가있는 서버 측). &lt;strong&gt;브라우저 API가 없으면 라우터는이 모드로 자동 설정됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="af3a1eca3ef1a5555c0872eef167faab0dbff5fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;append&lt;/code&gt; allows you to append the path to the &lt;code&gt;current&lt;/code&gt; route (as with &lt;a href=&quot;#router-link-props&quot;&gt;&lt;code&gt;router-link&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;append&lt;/code&gt; 당신의 경로를 추가 할 수 있도록 &lt;code&gt;current&lt;/code&gt; (와 같은 경로를 &lt;a href=&quot;#router-link-props&quot;&gt; &lt;code&gt;router-link&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="129408f980a6f71e8252a2b7d310994da58b1f7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;current&lt;/code&gt; is the current Route by default (most of the time you don't need to change this)</source>
          <target state="translated">&lt;code&gt;current&lt;/code&gt; 는 기본적으로 현재 경로입니다 (대부분 변경하지 않아도 됨)</target>
        </trans-unit>
        <trans-unit id="189c0025be7509058d16e090465cd0385f78be80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hash&lt;/code&gt;: uses the URL hash for routing. Works in all Vue-supported browsers, including those that do not support HTML5 History API.</source>
          <target state="translated">&lt;code&gt;hash&lt;/code&gt; : 라우팅을 위해 URL 해시를 사용합니다. HTML5 History API를 지원하지 않는 브라우저를 포함하여 모든 Vue 지원 브라우저에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="97eed375fc42f919f4e9b643c4bb1890cb0f7295" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;history&lt;/code&gt;: requires HTML5 History API and server config. See &lt;a href=&quot;../guide/essentials/history-mode&quot;&gt;HTML5 History Mode&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;history&lt;/code&gt; : HTML5 History API 및 서버 구성이 필요합니다. &lt;a href=&quot;../guide/essentials/history-mode&quot;&gt;HTML5 히스토리 모드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c58b2dbc0bef12a78d609ec7bf08b4f7f8e93325" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;href&lt;/code&gt;: resolved url. This would be the &lt;code&gt;href&lt;/code&gt; attribute of an &lt;code&gt;a&lt;/code&gt; element</source>
          <target state="translated">&lt;code&gt;href&lt;/code&gt; : 해결 된 URL. 이것은 것 &lt;code&gt;href&lt;/code&gt; 의 속성 &lt;code&gt;a&lt;/code&gt; 요소</target>
        </trans-unit>
        <trans-unit id="611ffa6d9619afb4b3249c4b1280720afdac83a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isActive&lt;/code&gt;: &lt;code&gt;true&lt;/code&gt; if the &lt;a href=&quot;#active-class&quot;&gt;active class&lt;/a&gt; should be applied. Allows to apply an arbitrary class</source>
          <target state="translated">&lt;code&gt;isActive&lt;/code&gt; : &lt;a href=&quot;#active-class&quot;&gt;활성 클래스&lt;/a&gt; 를 적용해야하는 경우 &lt;code&gt;true&lt;/code&gt; 입니다. 임의의 클래스를 적용 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="9656f6654118175ebf382e9f9c1431925bcd1855" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isExactActive&lt;/code&gt;: &lt;code&gt;true&lt;/code&gt; if the &lt;a href=&quot;#exact-active-class&quot;&gt;exact active class&lt;/a&gt; should be applied. Allows to apply an arbitrary class</source>
          <target state="translated">&lt;code&gt;isExactActive&lt;/code&gt; : &lt;a href=&quot;#exact-active-class&quot;&gt;정확한 활성 클래스&lt;/a&gt; 를 적용해야하는 경우 &lt;code&gt;true&lt;/code&gt; 입니다. 임의의 클래스를 적용 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="d2d504eaad212b1e406054d3192107cdebdcc5d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;navigate&lt;/code&gt;: function to trigger the navigation. &lt;strong&gt;It will automatically prevent events when necessary&lt;/strong&gt;, the same way &lt;code&gt;router-link&lt;/code&gt; does</source>
          <target state="translated">&lt;code&gt;navigate&lt;/code&gt; : 탐색 을 트리거하는 기능입니다. &lt;strong&gt;필요할 때 자동 이벤트를 방지 할 수 있습니다&lt;/strong&gt; , 같은 방식으로 &lt;code&gt;router-link&lt;/code&gt; 않습니다</target>
        </trans-unit>
        <trans-unit id="f6fbbf7066c3d9354554b2609da08e7517fcebc4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;route&lt;/code&gt;: resolved normalized location</source>
          <target state="translated">&lt;code&gt;route&lt;/code&gt; : 정규화 된 위치 확인</target>
        </trans-unit>
        <trans-unit id="ad4ae5a9e39a806af75882e2b086e5d5bfb57f1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;router-link&lt;/code&gt; exposes a low level customization through a &lt;a href=&quot;https://vuejs.org/v2/guide/components-slots.html#Scoped-Slots&quot;&gt;scoped slot&lt;/a&gt;. This is a more advanced API that primarily targets library authors but can come in handy for developers as well, most of the time in a custom component like a &lt;em&gt;NavLink&lt;/em&gt; or other.</source>
          <target state="translated">&lt;code&gt;router-link&lt;/code&gt; 는 &lt;a href=&quot;https://vuejs.org/v2/guide/components-slots.html#Scoped-Slots&quot;&gt;범위&lt;/a&gt; 가 지정된 슬롯을 통해 저수준 사용자 정의를 제공 합니다 . 이 라이브러리는 주로 라이브러리 작성자를 대상으로하는 고급 API이지만 대부분 &lt;em&gt;NavLink&lt;/em&gt; 또는 기타 와 같은 사용자 지정 구성 요소에서 개발자에게 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b33026ea8fd215f12d789371dfb8a1ad6610cf1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v-slot&lt;/code&gt; API (3.1.0+)</source>
          <target state="translated">&lt;code&gt;v-slot&lt;/code&gt; API (3.1.0+)</target>
        </trans-unit>
        <trans-unit id="105a0b4759b072acbf3f5caad5c732de1378b383" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;vue-router&lt;/code&gt; uses &lt;a href=&quot;https://github.com/pillarjs/path-to-regexp&quot;&gt;path-to-regexp&lt;/a&gt; as its path matching engine, so it supports many advanced matching patterns such as optional dynamic segments, zero or more / one or more requirements, and even custom regex patterns. Check out its &lt;a href=&quot;https://github.com/pillarjs/path-to-regexp#parameters&quot;&gt;documentation&lt;/a&gt; for these advanced patterns, and &lt;a href=&quot;https://github.com/vuejs/vue-router/blob/dev/examples/route-matching/app.js&quot;&gt;this example&lt;/a&gt; of using them in &lt;code&gt;vue-router&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;vue-router&lt;/code&gt; 는 &lt;a href=&quot;https://github.com/pillarjs/path-to-regexp&quot;&gt;path-to-regexp&lt;/a&gt; 를 경로 일치 엔진으로 사용하므로 선택적 동적 세그먼트, 0 개 이상의 하나 이상의 요구 사항 및 사용자 정의 정규식 패턴과 같은 많은 고급 일치 패턴을 지원합니다. 이러한 고급 패턴 및 &lt;code&gt;vue-router&lt;/code&gt; 에서 패턴 을 사용하는 &lt;a href=&quot;https://github.com/vuejs/vue-router/blob/dev/examples/route-matching/app.js&quot;&gt;예제&lt;/a&gt; 는 해당 &lt;a href=&quot;https://github.com/pillarjs/path-to-regexp#parameters&quot;&gt;문서&lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b313cd5c52caaa6485f1073613beebd813f00bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{ selector: string, offset? : { x: number, y: number }}&lt;/code&gt; (offset only supported in 2.6.0+)</source>
          <target state="translated">&lt;code&gt;{ selector: string, offset? : { x: number, y: number }}&lt;/code&gt; (2.6.0 이상에서만 오프셋 지원)</target>
        </trans-unit>
        <trans-unit id="d1dbe6ec2fcc5cc583f066d2d323aa23374ef4ce" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The nested view components are omitted here but you can find the complete source code for the example above &lt;a href=&quot;https://jsfiddle.net/posva/22wgksa3/&quot;&gt;here&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;중첩 된 뷰 구성 요소는 여기에서 생략되었지만 &lt;a href=&quot;https://jsfiddle.net/posva/22wgksa3/&quot;&gt;여기에서&lt;/a&gt; 위 예제에 대한 전체 소스 코드를 찾을 수 있습니다 .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4fac0bef8a644d999b3cad91a9f9a5acc91a6ebb" translate="yes" xml:space="preserve">
          <source>&lt;strong id=&quot;route-object-fullPath&quot;&gt;$route.fullPath&lt;/strong&gt;</source>
          <target state="translated">&lt;strong id=&quot;route-object-fullPath&quot;&gt;$route.fullPath&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8c11e00b2564886e95f2e3e968183b169b9fe441" translate="yes" xml:space="preserve">
          <source>&lt;strong id=&quot;route-object-hash&quot;&gt;$route.hash&lt;/strong&gt;</source>
          <target state="translated">&lt;strong id=&quot;route-object-hash&quot;&gt;$route.hash&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b71dfa4baecd89c7ee1f8419263541f945c335dd" translate="yes" xml:space="preserve">
          <source>&lt;strong id=&quot;route-object-matched&quot;&gt;$route.matched&lt;/strong&gt;</source>
          <target state="translated">&lt;strong id=&quot;route-object-matched&quot;&gt;$route.matched&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="92ef7643f2712e5f5409f9b0a9fc20ea4b43afec" translate="yes" xml:space="preserve">
          <source>&lt;strong id=&quot;route-object-name&quot;&gt;$route.name&lt;/strong&gt;</source>
          <target state="translated">&lt;strong id=&quot;route-object-name&quot;&gt;$route.name&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="96d1157695c4bd399db774e48518889c47570451" translate="yes" xml:space="preserve">
          <source>&lt;strong id=&quot;route-object-params&quot;&gt;$route.params&lt;/strong&gt;</source>
          <target state="translated">&lt;strong id=&quot;route-object-params&quot;&gt;$route.params&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a7a8d8937c8e4e28bc63d5b8e6b813189ae0e8c0" translate="yes" xml:space="preserve">
          <source>&lt;strong id=&quot;route-object-path&quot;&gt;$route.path&lt;/strong&gt;</source>
          <target state="translated">&lt;strong id=&quot;route-object-path&quot;&gt;$route.path&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6573b6281dec720e4ab3018e24b58c4b5df19e23" translate="yes" xml:space="preserve">
          <source>&lt;strong id=&quot;route-object-query&quot;&gt;$route.query&lt;/strong&gt;</source>
          <target state="translated">&lt;strong id=&quot;route-object-query&quot;&gt;$route.query&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bc3d56099f87e0d1e43e14294c252e742db988e5" translate="yes" xml:space="preserve">
          <source>&lt;strong id=&quot;route-object-redirectedFrom&quot;&gt;$route.redirectedFrom&lt;/strong&gt;</source>
          <target state="translated">&lt;strong id=&quot;route-object-redirectedFrom&quot;&gt;$route.redirectedFrom&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="73c15197133db1ce9671a21babe5d55ac33756df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;from: Route&lt;/code&gt;&lt;/strong&gt;: the current route being navigated away from.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;from: Route&lt;/code&gt; &lt;/strong&gt; : 현재 이동중인 경로입니다.</target>
        </trans-unit>
        <trans-unit id="5d867643772e9ef0f90dca26d991bd61e7d2d09a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;next('/')&lt;/code&gt; or &lt;code&gt;next({ path: '/' })&lt;/code&gt;&lt;/strong&gt;: redirect to a different location. The current navigation will be aborted and a new one will be started. You can pass any location object to &lt;code&gt;next&lt;/code&gt;, which allows you to specify options like &lt;code&gt;replace: true&lt;/code&gt;, &lt;code&gt;name: 'home'&lt;/code&gt; and any option used in &lt;a href=&quot;../../api/index#to&quot;&gt;&lt;code&gt;router-link&lt;/code&gt;'s &lt;code&gt;to&lt;/code&gt; prop&lt;/a&gt; or &lt;a href=&quot;../../api/index#router-push&quot;&gt;&lt;code&gt;router.push&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;next('/')&lt;/code&gt; 또는 &lt;code&gt;next({ path: '/' })&lt;/code&gt; &lt;/strong&gt; : 다른 위치로 리디렉션합니다. 현재 탐색이 중단되고 새로운 탐색이 시작됩니다. 당신은 어떤 위치에 개체를 전달할 수 있습니다 &lt;code&gt;next&lt;/code&gt; 은 같은 옵션을 지정할 수 있습니다, &lt;code&gt;replace: true&lt;/code&gt; , &lt;code&gt;name: 'home'&lt;/code&gt; 에서 사용하고 옵션&lt;a href=&quot;../../api/index#to&quot;&gt; &lt;code&gt;router-link&lt;/code&gt; 의 &lt;code&gt;to&lt;/code&gt; 소품&lt;/a&gt; 이나&lt;a href=&quot;../../api/index#router-push&quot;&gt; &lt;code&gt;router.push&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d10de2ce08935b888355cfc5209983856ceabc72" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/strong&gt;: move on to the next hook in the pipeline. If no hooks are left, the navigation is &lt;strong&gt;confirmed&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;next()&lt;/code&gt; &lt;/strong&gt; : 파이프 라인의 다음 후크로 이동합니다. 후크가 남아 있지 않으면 탐색이&lt;strong&gt; 확인&lt;/strong&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="bd5f2287807263c04bce722222c123698b327757" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;next(error)&lt;/code&gt;&lt;/strong&gt;: (2.4.0+) if the argument passed to &lt;code&gt;next&lt;/code&gt; is an instance of &lt;code&gt;Error&lt;/code&gt;, the navigation will be aborted and the error will be passed to callbacks registered via &lt;a href=&quot;../../api/index#router-onerror&quot;&gt;&lt;code&gt;router.onError()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;next(error)&lt;/code&gt; &lt;/strong&gt; : (2.4.0+) &lt;code&gt;next&lt;/code&gt; 에 전달 된 인수가 &lt;code&gt;Error&lt;/code&gt; 인스턴스 인경우 탐색이 중단되고&lt;a href=&quot;../../api/index#router-onerror&quot;&gt; &lt;code&gt;router.onError()&lt;/code&gt; &lt;/a&gt; 를 통해 등록 된 콜백에 오류가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="35a20b24c354c5ad8d363a0a6cc7cbb4955efc25" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;next(false)&lt;/code&gt;&lt;/strong&gt;: abort the current navigation. If the browser URL was changed (either manually by the user or via back button), it will be reset to that of the &lt;code&gt;from&lt;/code&gt; route.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;next(false)&lt;/code&gt; &lt;/strong&gt; : 현재 탐색을 중단합니다. 브라우저의 URL이 (사용자 또는 뒤로 버튼을 통해 수동으로) 변경된 경우, 그 재설정됩니다 &lt;code&gt;from&lt;/code&gt; 경로.</target>
        </trans-unit>
        <trans-unit id="8d4fd6417cf648085f5a319fa87e224269455b3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;next: Function&lt;/code&gt;&lt;/strong&gt;: this function must be called to &lt;strong&gt;resolve&lt;/strong&gt; the hook. The action depends on the arguments provided to &lt;code&gt;next&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;next: Function&lt;/code&gt; &lt;/strong&gt; :후크를&lt;strong&gt; 해결&lt;/strong&gt; 하려면이 함수를 호출해야합니다. 조치는 &lt;code&gt;next&lt;/code&gt; 제공된 인수에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="692c595e63b46ccc3431b621082e8fa5bef1f3d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;to: Route&lt;/code&gt;&lt;/strong&gt;: the target &lt;a href=&quot;../../api/index#the-route-object&quot;&gt;Route Object&lt;/a&gt; being navigated to.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;to: Route&lt;/code&gt; &lt;/strong&gt; :탐색중인대상&lt;a href=&quot;../../api/index#the-route-object&quot;&gt; Route 객체&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f5b7c8ca4a999bad33b5831545e1788c63dc6d8f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;An alias of &lt;code&gt;/a&lt;/code&gt; as &lt;code&gt;/b&lt;/code&gt; means when the user visits &lt;code&gt;/b&lt;/code&gt;, the URL remains &lt;code&gt;/b&lt;/code&gt;, but it will be matched as if the user is visiting &lt;code&gt;/a&lt;/code&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;/a&lt;/code&gt; 와 &lt;code&gt;/b&lt;/code&gt; 의 별명은 사용자가 &lt;code&gt;/b&lt;/code&gt; 를 방문 할 때 URL이 &lt;code&gt;/b&lt;/code&gt; 로 유지 되지만 사용자가 &lt;code&gt;/a&lt;/code&gt; 를 방문하는 것처럼 일치 한다는 것을 의미 합니다 .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="da8185af2453502d2a6d21a954b64a48f5e8d3af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Decouple it by using &lt;code&gt;props&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;props&lt;/code&gt; 을 사용하여 분리&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1bfb124a5c007d689be864e3a2ebd16e3664c182" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fetching After Navigation&lt;/strong&gt;: perform the navigation first, and fetch data in the incoming component's lifecycle hook. Display a loading state while data is being fetched.</source>
          <target state="translated">&lt;strong&gt;탐색 후 가져 오기&lt;/strong&gt; : 먼저 탐색을 수행하고 수신 구성 요소의 수명주기 후크에서 데이터를 가져옵니다. 데이터를 가져 오는 동안로드 상태를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="784e78a4a863c42db56de5d99730217f98191764" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fetching Before Navigation&lt;/strong&gt;: Fetch data before navigation in the route enter guard, and perform the navigation after data has been fetched.</source>
          <target state="translated">&lt;strong&gt;탐색 전&lt;/strong&gt; 페치 : 경로 입력 가드에서 탐색하기 전에 데이터를 페치하고 데이터를 페치 한 후 탐색을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="85aa166ff434e379c8599f4624e12e78defa0f85" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Instead of coupling to &lt;code&gt;$route&lt;/code&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;$route&lt;/code&gt; 에 연결하는 대신 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="86d0ba4307d3d286e8917735285562ed5f0feb93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Make sure to always call the &lt;code&gt;next&lt;/code&gt; function, otherwise the hook will never be resolved.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;항상 &lt;code&gt;next&lt;/code&gt; 함수를 호출하십시오 . 그렇지 않으면 후크가 해결되지 않습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fed409cff95e4d497045c8e930679df562a355d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note that nested paths that start with &lt;code&gt;/&lt;/code&gt; will be treated as a root path. This allows you to leverage the component nesting without having to use a nested URL.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;/&lt;/code&gt; 로 시작하는 중첩 경로 는 루트 경로로 취급됩니다. 이를 통해 중첩 된 URL을 사용하지 않고도 구성 요소 중첩을 활용할 수 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0aec4cdffd53c36dfc090da8e974a1be937b9a80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: Inside of a Vue instance, you have access to the router instance as &lt;code&gt;$router&lt;/code&gt;. You can therefore call &lt;code&gt;this.$router.push&lt;/code&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : Vue 인스턴스 내에서 라우터 인스턴스에 &lt;code&gt;$router&lt;/code&gt; 로 액세스 할 수 있습니다 . 그러므로 &lt;code&gt;this.$router.push&lt;/code&gt; 라고 부를 수 있습니다 .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6d064eb0fb56e93c57a44a1fe432eca814279295" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: this feature only works if the browser supports &lt;code&gt;history.pushState&lt;/code&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;참고 :이 기능은 브라우저가 &lt;code&gt;history.pushState&lt;/code&gt; 를 지원하는 경우에만 작동합니다 .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b8c987a4ff8744b98065a5eaac261bda80334b61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If the destination is the same as the current route and only params are changing (e.g. going from one profile to another &lt;code&gt;/users/1&lt;/code&gt; -&amp;gt; &lt;code&gt;/users/2&lt;/code&gt;), you will have to use &lt;a href=&quot;dynamic-matching#reacting-to-params-changes&quot;&gt;&lt;code&gt;beforeRouteUpdate&lt;/code&gt;&lt;/a&gt; to react to changes (e.g. fetching the user information).</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 대상이 현재 경로와 동일하고 매개 변수 만 변경되는 경우 (예 : 한 프로필에서 다른 &lt;code&gt;/users/1&lt;/code&gt; - &amp;gt; &lt;code&gt;/users/2&lt;/code&gt; 로 변경 ), &lt;a href=&quot;dynamic-matching#reacting-to-params-changes&quot;&gt; &lt;code&gt;beforeRouteUpdate&lt;/code&gt; &lt;/a&gt; 를 사용 하여 변경에 대응해야합니다 (예 : 가져 오기) 사용자 정보).</target>
        </trans-unit>
        <trans-unit id="f2cd00a05c4e51c80b150666326157914820525e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Note&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3f731a0483e5d55c7ef53ce77b71cd21cc581fa3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;params&lt;/code&gt; are ignored if a &lt;code&gt;path&lt;/code&gt; is provided, which is not the case for &lt;code&gt;query&lt;/code&gt;, as shown in the example above. Instead, you need to provide the &lt;code&gt;name&lt;/code&gt; of the route or manually specify the whole &lt;code&gt;path&lt;/code&gt; with any parameter:</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 위의 예와 같이 &lt;code&gt;path&lt;/code&gt; 가 제공 되면 &lt;code&gt;params&lt;/code&gt; 는 무시 되며 &lt;code&gt;query&lt;/code&gt; 의 경우에는 해당되지 않습니다 . 대신 경로 &lt;code&gt;name&lt;/code&gt; 을 제공 하거나 매개 변수를 사용하여 전체 &lt;code&gt;path&lt;/code&gt; 를 수동으로 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f44bc5cde0a86679734bccf41236b30399e35e60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: &lt;em&gt;Let's forget about how the HTML/CSS should look like to represent such layout and focus on the components used.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;em&gt;HTML / CSS가 어떻게 이러한 레이아웃을 나타내고 사용 된 구성 요소에 초점을 맞추는 것처럼 보이는지 잊어 봅시다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="49cd92a540f8d5ddaf089011afae080a463c00bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TIP&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TIP&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2f12251e037ac26f45b1cdd71584a9346e1ac384" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;VERSION NOTE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;버전 참고&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="56d6254e7cba0f476d3d275412f956128f1ae309" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When using the &lt;code&gt;v-slot&lt;/code&gt; API, it is required to pass one single child to &lt;code&gt;router-link&lt;/code&gt;&lt;/strong&gt;. If you don't, &lt;code&gt;router-link&lt;/code&gt; will wrap its children in a &lt;code&gt;span&lt;/code&gt; element.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;v-slot&lt;/code&gt; API를 사용하는 경우 하나의 하위 항목을 &lt;code&gt;router-link&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt; 에 전달해야합니다&lt;/strong&gt; . 그렇지 않으면 &lt;code&gt;router-link&lt;/code&gt; 가 하위 요소를 &lt;code&gt;span&lt;/code&gt; 요소로 랩핑합니다 .</target>
        </trans-unit>
        <trans-unit id="6651e38d4a3763e7779e24d7dae0f0aba6d5a8a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;beforeRouteEnter&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;beforeRouteEnter&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf400eb99af38983093f201712bffd8645fddfaf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;beforeRouteLeave&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;beforeRouteLeave&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="61b1e414f09221f5876897f91853a1684f2da844" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;beforeRouteUpdate&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;beforeRouteUpdate&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="203651569c6adf2d7bf9feeba3de1e6bf672d10a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;this.$route&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;this.$route&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b6cab0895dec254016a0b4192af900a73d674e37" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;this.$router&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;this.$router&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e9880655df0348048352e89351ab27e9a1587740" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;route object&lt;/strong&gt; represents the state of the current active route. It contains parsed information of the current URL and the &lt;strong&gt;route records&lt;/strong&gt; matched by the URL.</source>
          <target state="translated">&lt;strong&gt;경로 객체&lt;/strong&gt; 현재 활성 경로의 상태를 나타낸다. 현재 URL의 구문 분석 된 정보와 URL과 일치 하는 &lt;strong&gt;경로 레코드&lt;/strong&gt; 를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="db78120123d41c4b39ab69d8274419abba6f5c5c" translate="yes" xml:space="preserve">
          <source>A dynamic segment is denoted by a colon &lt;code&gt;:&lt;/code&gt;. When a route is matched, the value of the dynamic segments will be exposed as &lt;code&gt;this.$route.params&lt;/code&gt; in every component. Therefore, we can render the current user ID by updating &lt;code&gt;User&lt;/code&gt;'s template to this:</source>
          <target state="translated">동적 세그먼트는 콜론으로 표시된다 &lt;code&gt;:&lt;/code&gt; . 경로가 일치하면 동적 세그먼트의 값 &lt;code&gt;this.$route.params&lt;/code&gt; 모든 구성 요소에서 this. $ route.params 로 노출됩니다 . 따라서 &lt;code&gt;User&lt;/code&gt; 템플릿을 다음과 같이 업데이트하여 현재 사용자 ID를 렌더링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="156b2b9ae12f81d9512005ec2d0d3037c4a7e252" translate="yes" xml:space="preserve">
          <source>A redirect means when the user visits &lt;code&gt;/a&lt;/code&gt;, the URL will be replaced by &lt;code&gt;/b&lt;/code&gt;, and then matched as &lt;code&gt;/b&lt;/code&gt;. But what is an alias?</source>
          <target state="translated">사용자가 방문 리다이렉트 수단 &lt;code&gt;/a&lt;/code&gt; 상기 URL에 의해 대체 될 것이다 &lt;code&gt;/b&lt;/code&gt; 를 다음과 같이 매칭 &lt;code&gt;/b&lt;/code&gt; . 그러나 별칭은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="6a97a71775a961a8fa29e1af5fbe06b5cf8aac91" translate="yes" xml:space="preserve">
          <source>A string that equals the path of the current route, always resolved as an absolute path. e.g. &lt;code&gt;&quot;/foo/bar&quot;&lt;/code&gt;.</source>
          <target state="translated">현재 경로의 경로와 동일한 문자열은 항상 절대 경로로 확인됩니다. 예를 들어 &lt;code&gt;&quot;/foo/bar&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3adc69887814392cf8b2d46cce9a44b4e624c105" translate="yes" xml:space="preserve">
          <source>A view is rendered by using a component, therefore multiple views require multiple components for the same route. Make sure to use the &lt;code&gt;components&lt;/code&gt; (with an s) option:</source>
          <target state="translated">뷰는 컴포넌트를 사용하여 렌더링되므로 여러 뷰는 동일한 경로에 대해 여러 컴포넌트가 필요합니다. &lt;code&gt;components&lt;/code&gt; (s) 옵션 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="11155a31d243422200f48fd2d8cc4952c34d02fe" translate="yes" xml:space="preserve">
          <source>A working demo of this example can be found &lt;a href=&quot;https://jsfiddle.net/posva/22wgksa3/&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">이 예제의 실제 데모는 &lt;a href=&quot;https://jsfiddle.net/posva/22wgksa3/&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a50bb9b5e99e675cac89d89fca695cf654e6c9a" translate="yes" xml:space="preserve">
          <source>A working demo of this example can be found &lt;a href=&quot;https://jsfiddle.net/posva/6du90epg/&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">이 예제의 실제 데모는 &lt;a href=&quot;https://jsfiddle.net/posva/6du90epg/&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d676fbfda78cccf76196a5a6fb7ab7d0650c2b1a" translate="yes" xml:space="preserve">
          <source>A working demo of this example can be found &lt;a href=&quot;https://jsfiddle.net/yyx990803/L7hscd8h/&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">이 예제의 실제 데모는 &lt;a href=&quot;https://jsfiddle.net/yyx990803/L7hscd8h/&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b276f94cd8d0e74a21de6e5939b8c10ca9a975d6" translate="yes" xml:space="preserve">
          <source>API Reference</source>
          <target state="translated">API 참조</target>
        </trans-unit>
        <trans-unit id="ea2defa3a9b3b8557a3da80eb0d8f457b531b7a4" translate="yes" xml:space="preserve">
          <source>Add global navigation guards. See &lt;a href=&quot;../guide/advanced/navigation-guards&quot;&gt;Navigation Guards&lt;/a&gt; for more details.</source>
          <target state="translated">글로벌 내비게이션을 추가하십시오. 자세한 내용은 &lt;a href=&quot;../guide/advanced/navigation-guards&quot;&gt;Navigation Guards&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="182f7d7f84ac28b85cefada3d8096af7dff435a8" translate="yes" xml:space="preserve">
          <source>Add this to your &lt;code&gt;firebase.json&lt;/code&gt;:</source>
          <target state="translated">이것을 &lt;code&gt;firebase.json&lt;/code&gt; 에 추가하십시오 :</target>
        </trans-unit>
        <trans-unit id="072891203234508378cabfbdc97d9e0e3f7d7693" translate="yes" xml:space="preserve">
          <source>Advanced Matching Patterns</source>
          <target state="translated">고급 매칭 패턴</target>
        </trans-unit>
        <trans-unit id="04259816ace1ebe56c853a8763558570c008514a" translate="yes" xml:space="preserve">
          <source>Alias</source>
          <target state="translated">Alias</target>
        </trans-unit>
        <trans-unit id="c315b4e50c639fe7a19ef97c5ef2a6fe0f4ddd9b" translate="yes" xml:space="preserve">
          <source>All route records matched by a route are exposed on the &lt;code&gt;$route&lt;/code&gt; object (and also route objects in navigation guards) as the &lt;code&gt;$route.matched&lt;/code&gt; Array. Therefore, we will need to iterate over &lt;code&gt;$route.matched&lt;/code&gt; to check for meta fields in route records.</source>
          <target state="translated">경로와 일치하는 모든 경로 레코드 는 &lt;code&gt;$route.matched&lt;/code&gt; 배열 로 &lt;code&gt;$route&lt;/code&gt; 개체 (및 탐색 가드의 경로 개체)에 노출됩니다 . 따라서 경로 레코드에서 메타 필드를 확인하려면 &lt;code&gt;$route.matched&lt;/code&gt; 를 반복해야 합니다.</target>
        </trans-unit>
        <trans-unit id="35bc64fe5ce112af8a785974fd7adaceb66968ee" translate="yes" xml:space="preserve">
          <source>All three methods return a function that removes the registered guard/hook.</source>
          <target state="translated">세 가지 방법 모두 등록 된 보호 / 후크를 제거하는 기능을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f687baf76efd583ba0ef8e00c797ebd3606ba953" translate="yes" xml:space="preserve">
          <source>Also, all examples will be using the full version of Vue to make on-the-fly template compilation possible. See more details &lt;a href=&quot;https://vuejs.org/v2/guide/installation.html#Runtime-Compiler-vs-Runtime-only&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">또한 모든 예제는 Vue 정식 버전을 사용하여 즉석 템플릿 컴파일이 가능합니다. 자세한 내용은 &lt;a href=&quot;https://vuejs.org/v2/guide/installation.html#Runtime-Compiler-vs-Runtime-only&quot;&gt;여기를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d774c1d9d8403ab8fadec6dd85f65a1f6379db5" translate="yes" xml:space="preserve">
          <source>Alternatively, if you are using a Node.js server, you can implement the fallback by using the router on the server side to match the incoming URL and respond with 404 if no route is matched. Check out the &lt;a href=&quot;https://ssr.vuejs.org/en/&quot;&gt;Vue server side rendering documentation&lt;/a&gt; for more information.</source>
          <target state="translated">또는 Node.js 서버를 사용하는 경우 서버 측의 라우터를 사용하여 수신 URL을 일치시키고 경로가 일치하지 않으면 404로 응답하여 대체를 구현할 수 있습니다. 자세한 내용 은 &lt;a href=&quot;https://ssr.vuejs.org/en/&quot;&gt;Vue 서버 측 렌더링 설명서&lt;/a&gt; 를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="bc481c13f192125008dd5b760fe07cb50cef941a" translate="yes" xml:space="preserve">
          <source>An Array containing &lt;strong&gt;route records&lt;/strong&gt; for all nested path segments of the current route. Route records are the copies of the objects in the &lt;code&gt;routes&lt;/code&gt; configuration Array (and in &lt;code&gt;children&lt;/code&gt; Arrays):</source>
          <target state="translated">현재 경로의 모든 중첩 경로 세그먼트에 대한 경로 &lt;strong&gt;레코드&lt;/strong&gt; 를 포함하는 배열 입니다. 경로 레코드는 &lt;code&gt;routes&lt;/code&gt; 구성 배열 및 &lt;code&gt;children&lt;/code&gt; 배열 에있는 객체의 복사본입니다 .</target>
        </trans-unit>
        <trans-unit id="e258ee9f428616628018a4e303bafec2ed1d1719" translate="yes" xml:space="preserve">
          <source>An alias gives you the freedom to map a UI structure to an arbitrary URL, instead of being constrained by the configuration's nesting structure.</source>
          <target state="translated">별명을 사용하면 구성의 중첩 구조에 의해 제한되지 않고 UI 구조를 임의의 URL에 자유롭게 맵핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f3739e791fa19d2d317437f3ee57f9500444cd8" translate="yes" xml:space="preserve">
          <source>An error occurred when trying to resolve an async component that is required to render a route.</source>
          <target state="translated">라우트를 렌더링하는 데 필요한 비동기 구성 요소를 해결하려는 중에 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="d3cc39b59db1700be7d035e2588f46cc66fbf241" translate="yes" xml:space="preserve">
          <source>An example use case is checking for a meta field in the global navigation guard:</source>
          <target state="translated">사용 사례의 예는 전역 탐색 가드에서 메타 필드를 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="71da084f036eb26c37015ce8d4360c5a8d73a895" translate="yes" xml:space="preserve">
          <source>An object that contains key/value pairs of dynamic segments and star segments. If there are no params the value will be an empty object.</source>
          <target state="translated">동적 세그먼트와 스타 세그먼트의 키 / 값 쌍을 포함하는 객체입니다. 매개 변수가 없으면 값은 빈 개체가됩니다.</target>
        </trans-unit>
        <trans-unit id="14a69c21f7224d348475851000b8f3ad2545a273" translate="yes" xml:space="preserve">
          <source>An object that contains key/value pairs of the query string. For example, for a path &lt;code&gt;/foo?user=1&lt;/code&gt;, we get &lt;code&gt;$route.query.user == 1&lt;/code&gt;. If there is no query the value will be an empty object.</source>
          <target state="translated">쿼리 문자열의 키 / 값 쌍을 포함하는 개체입니다. 예를 들어 &lt;code&gt;/foo?user=1&lt;/code&gt; 경로의 경우 &lt;code&gt;$route.query.user == 1&lt;/code&gt; 됩니다. 쿼리가 없으면 값은 빈 개체가됩니다.</target>
        </trans-unit>
        <trans-unit id="a9c1de7dc1047d71f67c38a050edbdf38b437ae0" translate="yes" xml:space="preserve">
          <source>Any non-name props will be passed along to the rendered component, however most of the time the per-route data is contained in the route's params.</source>
          <target state="translated">이름이없는 소품은 렌더링 된 구성 요소로 전달되지만 대부분의 경우 경로 별 데이터가 경로의 매개 변수에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0b5958b0f53cb499388dd9ee04a106a30b02c5d1" translate="yes" xml:space="preserve">
          <source>Apache</source>
          <target state="translated">Apache</target>
        </trans-unit>
        <trans-unit id="085554440a61484dcc1f7f1b33296afe385a8f75" translate="yes" xml:space="preserve">
          <source>As the name suggests, the navigation guards provided by &lt;code&gt;vue-router&lt;/code&gt; are primarily used to guard navigations either by redirecting it or canceling it. There are a number of ways to hook into the route navigation process: globally, per-route, or in-component.</source>
          <target state="translated">이름에서 알 수 있듯이 &lt;code&gt;vue-router&lt;/code&gt; 가 제공하는 내비게이션 가드 는 주로 내비게이션을 리디렉션하거나 취소하여 내비게이션을 보호하는 데 사용됩니다. 경로 탐색 프로세스에 연결하는 방법에는 전역, 경로 또는 구성 요소 등 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f0d70c190fc4a8136b23e7c202d297fe902db8a" translate="yes" xml:space="preserve">
          <source>As the return value of calling &lt;code&gt;router.match(location)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;router.match(location)&lt;/code&gt; 호출의 반환 값으로</target>
        </trans-unit>
        <trans-unit id="c7f4dd01c3d7db0526d49b5cbafc444aab559129" translate="yes" xml:space="preserve">
          <source>As you can see the &lt;code&gt;children&lt;/code&gt; option is just another Array of route configuration objects like &lt;code&gt;routes&lt;/code&gt; itself. Therefore, you can keep nesting views as much as you need.</source>
          <target state="translated">보시다시피 &lt;code&gt;children&lt;/code&gt; 옵션은 &lt;code&gt;routes&lt;/code&gt; 자체 와 같은 경로 구성 개체의 또 다른 배열입니다 . 따라서 필요한만큼 중첩 뷰를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec41d6e2df2143b34eb02cee62d58dd44a178637" translate="yes" xml:space="preserve">
          <source>Aside from using &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; to create anchor tags for declarative navigation, we can do this programmatically using the router's instance methods.</source>
          <target state="translated">&lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; 를 사용하여 선언적 탐색을위한 앵커 태그를 만드는 것 외에도 라우터의 인스턴스 메소드를 사용하여 프로그래밍 방식으로이 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6892b3141eb3858e6e6734f0568f78454577256f" translate="yes" xml:space="preserve">
          <source>Async Scrolling</source>
          <target state="translated">비동기 스크롤</target>
        </trans-unit>
        <trans-unit id="560d9ddb225f90c85a47caeebc767f3890a40408" translate="yes" xml:space="preserve">
          <source>At this point, with the above configuration, when you visit &lt;code&gt;/user/foo&lt;/code&gt;, nothing will be rendered inside &lt;code&gt;User&lt;/code&gt;'s outlet, because no sub route is matched. Maybe you do want to render something there. In such case you can provide an empty subroute path:</source>
          <target state="translated">이 시점에서 위의 구성으로 &lt;code&gt;/user/foo&lt;/code&gt; 를 방문하면 하위 경로가 일치하지 않기 때문에 &lt;code&gt;User&lt;/code&gt; 's outlet 안에 아무것도 렌더링 되지 않습니다. 어딘가에 무언가를 렌더링하고 싶을 수도 있습니다. 이 경우 빈 하위 경로 경로를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fd122c84cb00b96ba0c759ebc8ca3844d91ee84" translate="yes" xml:space="preserve">
          <source>Basic Guides</source>
          <target state="translated">기본 안내서</target>
        </trans-unit>
        <trans-unit id="61e692507c61c133f149855270ff0ed201204f76" translate="yes" xml:space="preserve">
          <source>Boolean mode</source>
          <target state="translated">부울 모드</target>
        </trans-unit>
        <trans-unit id="371e23371f040d46377c93e80323577b039227a1" translate="yes" xml:space="preserve">
          <source>By injecting the router, we get access to it as &lt;code&gt;this.$router&lt;/code&gt; as well as the current route as &lt;code&gt;this.$route&lt;/code&gt; inside of any component:</source>
          <target state="translated">라우터를 주입함으로써, 우리는 그것에 접근 얻을 &lt;code&gt;this.$router&lt;/code&gt; 뿐만뿐만 아니라 현재의 노선 &lt;code&gt;this.$route&lt;/code&gt; 구성 요소의 내부를 :</target>
        </trans-unit>
        <trans-unit id="3f503c9d423abd93075704f88db9bb761be6157d" translate="yes" xml:space="preserve">
          <source>Caddy</source>
          <target state="translated">Caddy</target>
        </trans-unit>
        <trans-unit id="634dbb9a22c3a338c47024d7abe85b658ba519d0" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;beforeEnter&lt;/code&gt; in route configs.</source>
          <target state="translated">&lt;code&gt;beforeEnter&lt;/code&gt; 에서 beforeEnter 를 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4249140880ca52e7ef11d9503d69924589f207c9" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;beforeRouteEnter&lt;/code&gt; in activated components.</source>
          <target state="translated">활성화 된 구성 요소에서 &lt;code&gt;beforeRouteEnter&lt;/code&gt; 를 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff7e90ad58713ac0a25e678176802f3fa200decb" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;beforeRouteUpdate&lt;/code&gt; guards in reused components.</source>
          <target state="translated">재사용 된 구성 요소에서 &lt;code&gt;beforeRouteUpdate&lt;/code&gt; 가드를 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8e5a58466233e6c803ddbe25aba939e739eb3019" translate="yes" xml:space="preserve">
          <source>Call callbacks passed to &lt;code&gt;next&lt;/code&gt; in &lt;code&gt;beforeRouteEnter&lt;/code&gt; guards with instantiated instances.</source>
          <target state="translated">인스턴스 인스턴스가 있는 &lt;code&gt;beforeRouteEnter&lt;/code&gt; 가 &lt;code&gt;next&lt;/code&gt; 에 전달 된 콜백을 보호합니다.</target>
        </trans-unit>
        <trans-unit id="b9a8c6f5621a1b9d78881b4558f1e7afa9d9ea72" translate="yes" xml:space="preserve">
          <source>Call global &lt;code&gt;afterEach&lt;/code&gt; hooks.</source>
          <target state="translated">전 세계의 &lt;code&gt;afterEach&lt;/code&gt; 후크에 전화하십시오 .</target>
        </trans-unit>
        <trans-unit id="637f232310f9b20f4e6cf7008a301ce8a37fc2d2" translate="yes" xml:space="preserve">
          <source>Call global &lt;code&gt;beforeEach&lt;/code&gt; guards.</source>
          <target state="translated">&lt;code&gt;beforeEach&lt;/code&gt; 경비원 에게 글로벌 전화하십시오 .</target>
        </trans-unit>
        <trans-unit id="7f706c0b8eaadca091201ae841597e18c20f22a2" translate="yes" xml:space="preserve">
          <source>Call global &lt;code&gt;beforeResolve&lt;/code&gt; guards.</source>
          <target state="translated">경비원에게 연락하기 &lt;code&gt;beforeResolve&lt;/code&gt; 전 세계로 전화하십시오 .</target>
        </trans-unit>
        <trans-unit id="05385d5830e5c072c1827ed4365f6efdd71ed73d" translate="yes" xml:space="preserve">
          <source>Call leave guards in deactivated components.</source>
          <target state="translated">비활성화 된 구성 요소에서 방치 경비원에게 전화하십시오.</target>
        </trans-unit>
        <trans-unit id="5bbc0d73488282dd93b70e27cef933e4b1ea6db0" translate="yes" xml:space="preserve">
          <source>Catch all / 404 Not found Route</source>
          <target state="translated">모두 잡기 / 404 찾을 수 없음</target>
        </trans-unit>
        <trans-unit id="09dbd187de708ee21b01806ae5b0ca883102654a" translate="yes" xml:space="preserve">
          <source>Caveat</source>
          <target state="translated">Caveat</target>
        </trans-unit>
        <trans-unit id="c329ed52a2e5ffe770b15cad6d57d47667dc76c8" translate="yes" xml:space="preserve">
          <source>Check out more examples explaining active link class &lt;a href=&quot;https://jsfiddle.net/8xrk1n9f/&quot;&gt;live&lt;/a&gt;.</source>
          <target state="translated">활성 링크 클래스 &lt;a href=&quot;https://jsfiddle.net/8xrk1n9f/&quot;&gt;라이브를&lt;/a&gt; 설명하는 추가 예제를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="be9d53e0a04f1a7d92239dc5d0a8c7339bfa0b13" translate="yes" xml:space="preserve">
          <source>Combining Vue's &lt;a href=&quot;https://vuejs.org/guide/components.html#Async-Components&quot;&gt;async component feature&lt;/a&gt; and webpack's &lt;a href=&quot;https://webpack.js.org/guides/code-splitting-async/&quot;&gt;code splitting feature&lt;/a&gt;, it's trivially easy to lazy-load route components.</source>
          <target state="translated">Vue의 &lt;a href=&quot;https://vuejs.org/guide/components.html#Async-Components&quot;&gt;비동기 구성 요소 기능&lt;/a&gt; 과 웹팩의 &lt;a href=&quot;https://webpack.js.org/guides/code-splitting-async/&quot;&gt;코드 분할 기능을&lt;/a&gt; 결합하면 라우트 구성 요소를 쉽게로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="538f73ebb0f2283ee510d20e22c8b3dc2611a725" translate="yes" xml:space="preserve">
          <source>Combining the two, this is how to define an async component that will be automatically code-split by webpack:</source>
          <target state="translated">이 두 가지를 결합하여 웹팩에 의해 자동으로 코드 분할되는 비동기 구성 요소를 정의하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="c21b56685e74ee34e112c6265f95d4660855489e" translate="yes" xml:space="preserve">
          <source>Component Enabled Options</source>
          <target state="translated">구성 요소 사용 옵션</target>
        </trans-unit>
        <trans-unit id="6f1e4ac04228a38b2df9f816ebdf9943fc476cbc" translate="yes" xml:space="preserve">
          <source>Component Injected Properties</source>
          <target state="translated">성분 주입 속성</target>
        </trans-unit>
        <trans-unit id="68473142532c241b6b4d87aa608c7dcf5c7b3829" translate="yes" xml:space="preserve">
          <source>Component Injections</source>
          <target state="translated">성분 주입</target>
        </trans-unit>
        <trans-unit id="447504d07a309bf4f61ba3d1b8acc798c1179562" translate="yes" xml:space="preserve">
          <source>Configure the active CSS class applied when the link is active with exact match. Note the default value can also be configured globally via the &lt;code&gt;linkExactActiveClass&lt;/code&gt; router constructor option.</source>
          <target state="translated">링크가 정확히 일치 할 때 적용되는 활성 CSS 클래스를 구성하십시오. &lt;code&gt;linkExactActiveClass&lt;/code&gt; 라우터 생성자 옵션을 통해 기본값을 전체적으로 구성 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="598c83f3c40328d106949afdf0610e818376f591" translate="yes" xml:space="preserve">
          <source>Configure the active CSS class applied when the link is active. Note the default value can also be configured globally via the &lt;code&gt;linkActiveClass&lt;/code&gt; router constructor option.</source>
          <target state="translated">링크가 활성화 될 때 적용되는 활성 CSS 클래스를 구성하십시오. &lt;code&gt;linkActiveClass&lt;/code&gt; 라우터 생성자 옵션을 통해 기본값을 전체적으로 구성 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="08c47906bf83e39ad87e06aca0fe381d685ab20a" translate="yes" xml:space="preserve">
          <source>Configure the router mode.</source>
          <target state="translated">라우터 모드를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="179589cabbf6e5556838d12a18510a83d0e5840f" translate="yes" xml:space="preserve">
          <source>Controls whether the router should fallback to &lt;code&gt;hash&lt;/code&gt; mode when the browser does not support &lt;code&gt;history.pushState&lt;/code&gt; but mode is set to &lt;code&gt;history&lt;/code&gt;.</source>
          <target state="translated">브라우저가 &lt;code&gt;history.pushState&lt;/code&gt; 를 지원하지 않지만 mode가 &lt;code&gt;history&lt;/code&gt; 로 설정된 경우 라우터가 &lt;code&gt;hash&lt;/code&gt; 모드로 폴백해야하는지 여부를 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="604a3713372f436d1cb20925918b04c41010dfd1" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;web.config&lt;/code&gt; file in the root directory of your site with the following:</source>
          <target state="translated">다음 을 사용하여 사이트의 루트 디렉토리에 &lt;code&gt;web.config&lt;/code&gt; 파일을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="a1b0a80537d0b93c4c92d2861e9bbeb03c1a7f33" translate="yes" xml:space="preserve">
          <source>Creating a Single-page Application with Vue + Vue Router is dead simple. With Vue.js, we are already composing our application with components. When adding Vue Router to the mix, all we need to do is map our components to the routes and let Vue Router know where to render them. Here's a basic example:</source>
          <target state="translated">Vue + Vue 라우터로 단일 페이지 응용 프로그램을 만드는 것은 매우 간단합니다. Vue.js를 사용하면 이미 애플리케이션을 컴포넌트로 구성하고 있습니다. Vue Router를 믹스에 추가 할 때는 컴포넌트를 라우트에 매핑하고 Vue 라우터에 렌더링 할 위치를 알려 주기만하면됩니다. 기본 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5f31f9c9de48f97cd9f14f9d5e4b1227ebfaf383" translate="yes" xml:space="preserve">
          <source>Customizable Scroll Behavior</source>
          <target state="translated">사용자 정의 가능한 스크롤 동작</target>
        </trans-unit>
        <trans-unit id="126e1bff33bc4a33979dcd9da131a2801aeb7664" translate="yes" xml:space="preserve">
          <source>DOM updates triggered.</source>
          <target state="translated">DOM 업데이트가 트리거되었습니다.</target>
        </trans-unit>
        <trans-unit id="890e1257a40dfb0f216d69df75d9cda18023d0bb" translate="yes" xml:space="preserve">
          <source>Data Fetching</source>
          <target state="translated">데이터 가져 오기</target>
        </trans-unit>
        <trans-unit id="3484c6fcb53ac09a3fead481f71e452bc3f9e097" translate="yes" xml:space="preserve">
          <source>Declarative</source>
          <target state="translated">Declarative</target>
        </trans-unit>
        <trans-unit id="785cf0391e1a17613040723181ad0242ee7dbb32" translate="yes" xml:space="preserve">
          <source>Denotes the target route of the link. When clicked, the value of the &lt;code&gt;to&lt;/code&gt; prop will be passed to &lt;code&gt;router.push()&lt;/code&gt; internally, so the value can be either a string or a location descriptor object.</source>
          <target state="translated">링크의 대상 경로를 나타냅니다. 클릭하면 &lt;code&gt;to&lt;/code&gt; prop 의 값이 &lt;code&gt;router.push()&lt;/code&gt; 내부적 으로 전달 되므로 값은 문자열 또는 위치 설명자 객체 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40d9b9f619dbd27ad649a2fb2ed512704a8498dc" translate="yes" xml:space="preserve">
          <source>Dev Build</source>
          <target state="translated">개발 빌드</target>
        </trans-unit>
        <trans-unit id="3802d9202faed1ee478163e33ce9ddf939795ae9" translate="yes" xml:space="preserve">
          <source>Direct Download / CDN</source>
          <target state="translated">직접 다운로드 / CDN</target>
        </trans-unit>
        <trans-unit id="ec5741bbff94960e62ed6fcda2ffbc8bf291509f" translate="yes" xml:space="preserve">
          <source>Dynamic Route Matching</source>
          <target state="translated">동적 경로 일치</target>
        </trans-unit>
        <trans-unit id="8f3d8ec9f1affbff8f734f537e37271abb248165" translate="yes" xml:space="preserve">
          <source>Dynamically add more routes to the router. The argument must be an Array using the same route config format with the &lt;code&gt;routes&lt;/code&gt; constructor option.</source>
          <target state="translated">라우터에 더 많은 경로를 동적으로 추가하십시오. 인수는 &lt;code&gt;routes&lt;/code&gt; 생성자 옵션 과 동일한 경로 구성 형식을 사용하는 배열이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="24c467ae21d128d7193caebbe399b812abbf159e" translate="yes" xml:space="preserve">
          <source>Every guard function receives three arguments:</source>
          <target state="translated">모든 가드 함수는 세 가지 인수를받습니다.</target>
        </trans-unit>
        <trans-unit id="d8bac23f28aec2ade8b77c4f238e7a22aa94fe46" translate="yes" xml:space="preserve">
          <source>Example Server Configurations</source>
          <target state="translated">서버 구성 예</target>
        </trans-unit>
        <trans-unit id="ea90a9028e4260b0b7f6845eac8160877c8ae4dd" translate="yes" xml:space="preserve">
          <source>Example: Applying Active Class to Outer Element</source>
          <target state="translated">예 : 외부 요소에 활성 클래스 적용</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="6ea555d5143dcddf991fec16297649cdb9c9c9e9" translate="yes" xml:space="preserve">
          <source>Express with Node.js</source>
          <target state="translated">Node.js로 표현</target>
        </trans-unit>
        <trans-unit id="61cf55a69f4df4c161869ea8e2d7b9a4330c5741" translate="yes" xml:space="preserve">
          <source>Fetching After Navigation</source>
          <target state="translated">탐색 후 가져 오기</target>
        </trans-unit>
        <trans-unit id="d7886fbab1b4f934f0a1de4803c3c7bec7bd522d" translate="yes" xml:space="preserve">
          <source>Fetching Before Navigation</source>
          <target state="translated">탐색 전에 가져 오기</target>
        </trans-unit>
        <trans-unit id="12968f6b0d3abadd283ff066759a7b791258a0e4" translate="yes" xml:space="preserve">
          <source>Finally, you can directly define route navigation guards inside route components (the ones passed to the router configuration) with the following options:</source>
          <target state="translated">마지막으로 다음 옵션을 사용하여 경로 구성 요소 (라우터 구성으로 전달 된 구성 요소) 내부에 경로 탐색 가드를 직접 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a01db2ae475f14b70ac1d75463ca58257cfa1529" translate="yes" xml:space="preserve">
          <source>Fine-grained navigation control</source>
          <target state="translated">세분화 된 탐색 컨트롤</target>
        </trans-unit>
        <trans-unit id="5f133c80f125f45ee0dbdf789783d6285b5c326c" translate="yes" xml:space="preserve">
          <source>Firebase hosting</source>
          <target state="translated">Firebase 호스팅</target>
        </trans-unit>
        <trans-unit id="373ebcfb47d28107cdb989722313264dd872952e" translate="yes" xml:space="preserve">
          <source>First, an async component can be defined as a factory function that returns a Promise (which should resolve to the component itself):</source>
          <target state="translated">먼저 비동기 구성 요소를 약속을 반환하는 팩토리 함수로 정의 할 수 있습니다 (구성 요소 자체로 확인해야 함).</target>
        </trans-unit>
        <trans-unit id="df0806b24093e99d864f17e99384efbe1d25e90c" translate="yes" xml:space="preserve">
          <source>First, each route object in the &lt;code&gt;routes&lt;/code&gt; configuration is called a &lt;strong&gt;route record&lt;/strong&gt;. Route records may be nested. Therefore when a route is matched, it can potentially match more than one route record.</source>
          <target state="translated">먼저, &lt;code&gt;routes&lt;/code&gt; 구성 의 각 경로 개체를 &lt;strong&gt;경로 레코드&lt;/strong&gt; 라고 &lt;strong&gt;합니다&lt;/strong&gt; . 경로 레코드가 중첩 될 수 있습니다. 따라서 경로가 일치하면 둘 이상의 경로 레코드와 일치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a65bf6fcf34175ff79aaa50332ab88e3c4fdbde" translate="yes" xml:space="preserve">
          <source>For Node.js/Express, consider using &lt;a href=&quot;https://github.com/bripkens/connect-history-api-fallback&quot;&gt;connect-history-api-fallback middleware&lt;/a&gt;.</source>
          <target state="translated">Node.js / Express의 경우 &lt;a href=&quot;https://github.com/bripkens/connect-history-api-fallback&quot;&gt;connect-history-api-fallback 미들웨어&lt;/a&gt; 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="b1e8e9f52767f0036500ce99a480baa669242b2c" translate="yes" xml:space="preserve">
          <source>For TypeScript users, &lt;code&gt;vue-router@3.0+&lt;/code&gt; requires &lt;code&gt;vue@2.5+&lt;/code&gt;, and vice versa.</source>
          <target state="translated">타이프 라이터 사용자의 경우, &lt;code&gt;vue-router@3.0+&lt;/code&gt; 필요 &lt;code&gt;vue@2.5+&lt;/code&gt; 반대, 그리고 그 반대입니다.</target>
        </trans-unit>
        <trans-unit id="b84487772f3e0cb7184255459fbb540893ece7a9" translate="yes" xml:space="preserve">
          <source>For advanced usage, check out the &lt;a href=&quot;https://github.com/vuejs/vue-router/blob/dev/examples/route-alias/app.js&quot;&gt;example&lt;/a&gt;.</source>
          <target state="translated">고급 사용법은 &lt;a href=&quot;https://github.com/vuejs/vue-router/blob/dev/examples/route-alias/app.js&quot;&gt;예제를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="489c0c70c863fa104256940ebe3fe288f47435b7" translate="yes" xml:space="preserve">
          <source>For advanced usage, check out the &lt;a href=&quot;https://github.com/vuejs/vue-router/blob/dev/examples/route-props/app.js&quot;&gt;example&lt;/a&gt;.</source>
          <target state="translated">고급 사용법은 &lt;a href=&quot;https://github.com/vuejs/vue-router/blob/dev/examples/route-props/app.js&quot;&gt;예제를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="57531f3c0d6aa0bea14c7b9b683c5a03f5eb3b51" translate="yes" xml:space="preserve">
          <source>For example, with the above route config, the URL &lt;code&gt;/foo/bar&lt;/code&gt; will match both the parent route record and the child route record.</source>
          <target state="translated">예를 들어, 위의 경로 구성을 사용하면 URL &lt;code&gt;/foo/bar&lt;/code&gt; 는 부모 경로 레코드와 자식 경로 레코드와 모두 일치합니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="036a717afd24a521f1446cb57757a166d602dd99" translate="yes" xml:space="preserve">
          <source>For more details see &lt;a href=&quot;../guide/advanced/scroll-behavior&quot;&gt;Scroll Behavior&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../guide/advanced/scroll-behavior&quot;&gt;스크롤 동작을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ac4e81a56cc8dc13ec2ca3b54c9e2e00def537b9" translate="yes" xml:space="preserve">
          <source>For other advanced usage, checkout the &lt;a href=&quot;https://github.com/vuejs/vue-router/blob/dev/examples/redirect/app.js&quot;&gt;example&lt;/a&gt;.</source>
          <target state="translated">다른 고급 사용법에 대해서는 &lt;a href=&quot;https://github.com/vuejs/vue-router/blob/dev/examples/redirect/app.js&quot;&gt;예제를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="28f8c3f2cdac27443d5de2aaa51cb565413b312b" translate="yes" xml:space="preserve">
          <source>Full example &lt;a href=&quot;https://github.com/vuejs/vue-router/blob/dev/examples/named-routes/app.js&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/vuejs/vue-router/blob/dev/examples/named-routes/app.js&quot;&gt;여기에&lt;/a&gt; 전체 예제가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="56e2a78217e3fd68618113a0c15dbe403b951d96" translate="yes" xml:space="preserve">
          <source>Function mode</source>
          <target state="translated">기능 모드</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">시작하기</target>
        </trans-unit>
        <trans-unit id="4e8ab6c07a3acf4c2204d6b70bcb472586550981" translate="yes" xml:space="preserve">
          <source>Given the app we created in the last chapter:</source>
          <target state="translated">우리가 마지막 장에서 만든 앱이 있다면 :</target>
        </trans-unit>
        <trans-unit id="04b81c50025b47abd4de06d5d2d43a3f431b8b3e" translate="yes" xml:space="preserve">
          <source>Global After Hooks</source>
          <target state="translated">글로벌 애프터 훅</target>
        </trans-unit>
        <trans-unit id="39fe16e37e3132d15e0fbf4f80ae9c736ada4b64" translate="yes" xml:space="preserve">
          <source>Global Before Guards</source>
          <target state="translated">글로벌 사전 경비</target>
        </trans-unit>
        <trans-unit id="c78825b4c48ff8948dc48798ccc5fe8425bd6e4d" translate="yes" xml:space="preserve">
          <source>Global Resolve Guards</source>
          <target state="translated">글로벌 리졸 브 가드</target>
        </trans-unit>
        <trans-unit id="571bfb07cac37435662705c30ebba47b6a968777" translate="yes" xml:space="preserve">
          <source>Global before guards are called in creation order, whenever a navigation is triggered. Guards may be resolved asynchronously, and the navigation is considered &lt;strong&gt;pending&lt;/strong&gt; before all hooks have been resolved.</source>
          <target state="translated">탐색이 트리거 될 때마다 전역 사전 가드가 작성 순서대로 호출됩니다. 가드는 비동기식으로 해결 될 수 있으며 모든 후크가 해결되기 전에 탐색이 &lt;strong&gt;보류중인&lt;/strong&gt; 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="dd9c40ae1404d776848a122807b1c216f9fd4ff8" translate="yes" xml:space="preserve">
          <source>Globally configure &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; default active class for exact matches. Also see &lt;a href=&quot;#router-link&quot;&gt;router-link&lt;/a&gt;.</source>
          <target state="translated">정확히 일치 하도록 &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; 기본 활성 클래스를 전체적으로 구성하십시오 . &lt;a href=&quot;#router-link&quot;&gt;router-link&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bad55014845b46b06bee9764378d62ab9c019c1a" translate="yes" xml:space="preserve">
          <source>Globally configure &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; default active class. Also see &lt;a href=&quot;#router-link&quot;&gt;router-link&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; 기본 활성 클래스를 전체적으로 구성하십시오 . &lt;a href=&quot;#router-link&quot;&gt;router-link&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ea78ebe08d1386045a768205f28719d8bbea6c68" translate="yes" xml:space="preserve">
          <source>Grouping Components in the Same Chunk</source>
          <target state="translated">동일한 청크에서 구성 요소 그룹화</target>
        </trans-unit>
        <trans-unit id="9f738ce8457f291b18ee47e665e96baa84f38fcd" translate="yes" xml:space="preserve">
          <source>HTML</source>
          <target state="translated">HTML</target>
        </trans-unit>
        <trans-unit id="d0af1b42be6477058b4fe3d76bd1657cbdda202b" translate="yes" xml:space="preserve">
          <source>HTML5 History Mode</source>
          <target state="translated">HTML5 기록 모드</target>
        </trans-unit>
        <trans-unit id="66f998d2f920d7fa8d57fe7e8745ef748da09071" translate="yes" xml:space="preserve">
          <source>HTML5 history mode or hash mode, with auto-fallback in IE9</source>
          <target state="translated">IE9에서 자동 폴백 기능이있는 HTML5 기록 모드 또는 해시 모드</target>
        </trans-unit>
        <trans-unit id="b0d68b54e7e4109ad893204b6f26e0708c9cc4d6" translate="yes" xml:space="preserve">
          <source>Here comes a problem, though: Since our app is a single page client side app, without a proper server configuration, the users will get a 404 error if they access &lt;code&gt;http://oursite.com/user/id&lt;/code&gt; directly in their browser. Now that's ugly.</source>
          <target state="translated">여기에 문제가 있습니다. 앱이 단일 페이지 클라이언트 측 앱이므로 적절한 서버 구성이 없기 때문에 브라우저에서 직접 &lt;code&gt;http://oursite.com/user/id&lt;/code&gt; 에 액세스하면 404 오류가 발생 합니다. 이제는 추악합니다.</target>
        </trans-unit>
        <trans-unit id="a34e0feba7b9eeabcd77ca390cdeaec4a234b764" translate="yes" xml:space="preserve">
          <source>History Manipulation</source>
          <target state="translated">역사 조작</target>
        </trans-unit>
        <trans-unit id="0246196abd9134d11e797df909a2239577c70d5a" translate="yes" xml:space="preserve">
          <source>However, you can access the instance by passing a callback to &lt;code&gt;next&lt;/code&gt;. The callback will be called when the navigation is confirmed, and the component instance will be passed to the callback as the argument:</source>
          <target state="translated">그러나 &lt;code&gt;next&lt;/code&gt; 콜백을 전달하여 인스턴스에 액세스 할 수 있습니다 . 탐색이 확인되면 콜백이 호출되고 구성 요소 인스턴스가 인수로 콜백에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="f7c32e5e91730c7288c256a7228e1273afb0bdd4" translate="yes" xml:space="preserve">
          <source>If a falsy value or an empty object is returned, no scrolling will happen.</source>
          <target state="translated">잘못된 값이나 빈 개체가 반환되면 스크롤이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="49910c5f3a09c1a2a5644b36aaa9d21c610f608b" translate="yes" xml:space="preserve">
          <source>If you add a &lt;code&gt;target=&quot;_blank&quot;&lt;/code&gt; to your &lt;code&gt;a&lt;/code&gt; element, you must omit the &lt;code&gt;@click=&quot;navigate&quot;&lt;/code&gt; handler.</source>
          <target state="translated">당신이 추가하면 &lt;code&gt;target=&quot;_blank&quot;&lt;/code&gt; 당신에 요소, 당신은 생략합니다 &lt;code&gt;@click=&quot;navigate&quot;&lt;/code&gt; 핸들러를. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2cf49d509e0a3607c76d7e53f4e62c0f9c2c6cc1" translate="yes" xml:space="preserve">
          <source>If you want to simulate the &quot;scroll to anchor&quot; behavior:</source>
          <target state="translated">&quot;스크롤 고정&quot;동작을 시뮬레이션하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="8ae10a7d8459debcadacac2bb97288eee8b865ff" translate="yes" xml:space="preserve">
          <source>In 2.2.0+, optionally provide &lt;code&gt;onComplete&lt;/code&gt; and &lt;code&gt;onAbort&lt;/code&gt; callbacks to &lt;code&gt;router.push&lt;/code&gt; or &lt;code&gt;router.replace&lt;/code&gt; as the 2nd and 3rd arguments. These callbacks will be called when the navigation either successfully completed (after all async hooks are resolved), or aborted (navigated to the same route, or to a different route before current navigation has finished), respectively. In 3.1.0+, you can omit the 2nd and 3rd parameter and &lt;code&gt;router.push&lt;/code&gt;/&lt;code&gt;router.replace&lt;/code&gt; will return a promise instead if Promises are supported.</source>
          <target state="translated">2.2.0 이상에서는 선택적으로 &lt;code&gt;onComplete&lt;/code&gt; 및 &lt;code&gt;onAbort&lt;/code&gt; 콜백을 &lt;code&gt;router.push&lt;/code&gt; 또는 &lt;code&gt;router.replace&lt;/code&gt; 에 두 번째 및 세 번째 인수로 제공하십시오. 이 콜백은 각각의 탐색이 성공적으로 완료되거나 (모든 비동기 후크가 해결 된 후) 중단되거나 (동일한 경로로 탐색되거나 현재 탐색이 완료되기 전에 다른 경로로) 호출 될 때 호출됩니다. 3.1.0 이상에서는 2 차 및 3 차 매개 변수를 생략 할 수 있으며 &lt;code&gt;router.push&lt;/code&gt; / &lt;code&gt;router.replace&lt;/code&gt; 는 약속이 지원되는 경우 대신 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ed362c80e4a0c1d90cf802b990d676db62248b7d" translate="yes" xml:space="preserve">
          <source>In HTML5 history mode, &lt;code&gt;router-link&lt;/code&gt; will intercept the click event so that the browser doesn't try to reload the page.</source>
          <target state="translated">HTML5 기록 모드에서 &lt;code&gt;router-link&lt;/code&gt; 는 클릭 이벤트를 차단하여 브라우저가 페이지를 다시로드하려고 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="123c58d7d20c981fdc7b0a2f037f2f3fb1149e14" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;$route.params&lt;/code&gt;, the &lt;code&gt;$route&lt;/code&gt; object also exposes other useful information such as &lt;code&gt;$route.query&lt;/code&gt; (if there is a query in the URL), &lt;code&gt;$route.hash&lt;/code&gt;, etc. You can check out the full details in the &lt;a href=&quot;../../api/index#the-route-object&quot;&gt;API Reference&lt;/a&gt;.</source>
          <target state="translated">뿐만 아니라 &lt;code&gt;$route.params&lt;/code&gt; 는 &lt;code&gt;$route&lt;/code&gt; 객체는 같은 기타 유용한 정보를 노출 &lt;code&gt;$route.query&lt;/code&gt; (URL에 쿼리가있는 경우) &lt;code&gt;$route.hash&lt;/code&gt; 당신은에서 자세한 내용을 확인할 수 있습니다, 등 &lt;a href=&quot;../../api/index#the-route-object&quot;&gt;API 참조&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="24c9352ede93756918856c618a17b8a9c6356bed" translate="yes" xml:space="preserve">
          <source>In both cases, the router will navigate to the path &lt;code&gt;/user/123&lt;/code&gt;.</source>
          <target state="translated">두 경우 모두, 라우터는 &lt;code&gt;/user/123&lt;/code&gt; 경로로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="aaf00c4093074d65696e6e9ab00bb1db82826baf" translate="yes" xml:space="preserve">
          <source>In-Component Guards</source>
          <target state="translated">부품 내 가드</target>
        </trans-unit>
        <trans-unit id="ab960247ddc5acc97d8c2a113b63893d536bcf7c" translate="yes" xml:space="preserve">
          <source>Include &lt;code&gt;vue-router&lt;/code&gt; after Vue and it will install itself automatically:</source>
          <target state="translated">Vue 뒤에 &lt;code&gt;vue-router&lt;/code&gt; 를 포함 시키면 자동으로 설치됩니다 :</target>
        </trans-unit>
        <trans-unit id="ad7ae3fbd0a8cc0491d2e986f5c89a82826853c5" translate="yes" xml:space="preserve">
          <source>Inside &lt;code&gt;$route&lt;/code&gt; watcher callbacks</source>
          <target state="translated">&lt;code&gt;$route&lt;/code&gt; 감시자 콜백 내부</target>
        </trans-unit>
        <trans-unit id="d820495ee5f4040175aec835f4a5b5a33ef1fa06" translate="yes" xml:space="preserve">
          <source>Inside components as &lt;code&gt;this.$route&lt;/code&gt;</source>
          <target state="translated">내부 구성 요소는 &lt;code&gt;this.$route&lt;/code&gt; 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6b74dc7409c8cacfbc49aeb2ec96c522df9be3f7" translate="yes" xml:space="preserve">
          <source>Inside navigation guards as the first two arguments:</source>
          <target state="translated">첫 번째 두 가지 인수로 내부 탐색 가드 :</target>
        </trans-unit>
        <trans-unit id="c876f7b6d25954e644f1c0f79615345a5db0f583" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;scrollBehavior&lt;/code&gt; function as the first two arguments:</source>
          <target state="translated">&lt;code&gt;scrollBehavior&lt;/code&gt; 함수 내부에서 처음 두 인수로</target>
        </trans-unit>
        <trans-unit id="bd040edfed95e6068f33b83c57406115b80d4532" translate="yes" xml:space="preserve">
          <source>Install &lt;a href=&quot;https://www.iis.net/downloads/microsoft/url-rewrite&quot;&gt;IIS UrlRewrite&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.iis.net/downloads/microsoft/url-rewrite&quot;&gt;IIS UrlRewrite&lt;/a&gt; 설치</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="91d60654c70276c1f55519257a6b16f94cdd53b8" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;mod_rewrite&lt;/code&gt;, you could also use &lt;a href=&quot;https://httpd.apache.org/docs/2.2/mod/mod_dir.html#fallbackresource&quot;&gt;&lt;code&gt;FallbackResource&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;mod_rewrite&lt;/code&gt; 대신 &lt;a href=&quot;https://httpd.apache.org/docs/2.2/mod/mod_dir.html#fallbackresource&quot;&gt; &lt;code&gt;FallbackResource&lt;/code&gt; &lt;/a&gt; 를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f2f94321c0c12321807b0fb675d4b99213d9f776" translate="yes" xml:space="preserve">
          <source>Internet Information Services (IIS)</source>
          <target state="translated">인터넷 정보 서비스 (IIS)</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="7b38a0e68956f86b8611c4bc859e451a256e5d62" translate="yes" xml:space="preserve">
          <source>It acts like &lt;code&gt;router.push&lt;/code&gt;, the only difference is that it navigates without pushing a new history entry, as its name suggests - it replaces the current entry.</source>
          <target state="translated">&lt;code&gt;router.push&lt;/code&gt; 와 같이 작동하지만 유일한 차이점은 이름에서 알 수 있듯이 새 기록 항목을 푸시하지 않고 탐색한다는 것입니다. 현재 항목을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="3b0a42d5487908d2325dff65c967d5d5a60b2223" translate="yes" xml:space="preserve">
          <source>It is also possible to determine the transition to use dynamically based on the relationship between the target route and current route:</source>
          <target state="translated">대상 경로와 현재 경로 간의 관계를 기반으로 동적으로 사용할 전환을 결정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7b7d69c290b5bd596fb28a4ccea84635c6bdac7" translate="yes" xml:space="preserve">
          <source>It is possible to create complex layouts using named views with nested views. When doing so, you will also need to name nested &lt;code&gt;router-view&lt;/code&gt; components used. Let's take a Settings panel example:</source>
          <target state="translated">중첩 된 뷰가있는 명명 된 뷰를 사용하여 복잡한 레이아웃을 생성 할 수 있습니다. 그렇게 할 때 사용 된 중첩 &lt;code&gt;router-view&lt;/code&gt; 구성 요소의 이름도 지정해야합니다 . 설정 패널 예제를 보자.</target>
        </trans-unit>
        <trans-unit id="dd1b5f5c29b6497f61ce7508d8bab18e0dd25a54" translate="yes" xml:space="preserve">
          <source>It is worth mentioning that Vue Router navigation methods (&lt;code&gt;push&lt;/code&gt;, &lt;code&gt;replace&lt;/code&gt;, &lt;code&gt;go&lt;/code&gt;) work consistently in all router modes (&lt;code&gt;history&lt;/code&gt;, &lt;code&gt;hash&lt;/code&gt; and &lt;code&gt;abstract&lt;/code&gt;).</source>
          <target state="translated">Vue Router 탐색 방법 ( &lt;code&gt;push&lt;/code&gt; , &lt;code&gt;replace&lt;/code&gt; , &lt;code&gt;go&lt;/code&gt; )은 모든 라우터 모드 ( &lt;code&gt;history&lt;/code&gt; , &lt;code&gt;hash&lt;/code&gt; 및 &lt;code&gt;abstract&lt;/code&gt; ) 에서 일관되게 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="3d7b30b16b9eb13c34964f528c2928fc9569c73c" translate="yes" xml:space="preserve">
          <source>It works the same way in both HTML5 history mode and hash mode, so if you ever decide to switch mode, or when the router falls back to hash mode in IE9, nothing needs to be changed.</source>
          <target state="translated">HTML5 히스토리 모드와 해시 모드에서 모두 동일한 방식으로 작동하므로 모드를 전환하기로 결정하거나 라우터가 IE9에서 해시 모드로 돌아갈 때 아무것도 변경할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ebdf11f436055ccb0f4e6d63818ee613b025039c" translate="yes" xml:space="preserve">
          <source>It's possible to hook this up with events from a page-level transition component to make the scroll behavior play nicely with your page transitions, but due to the possible variance and complexity in use cases, we simply provide this primitive to enable specific userland implementations.</source>
          <target state="translated">이를 페이지 수준 전환 구성 요소의 이벤트와 연결하여 페이지 전환과 함께 스크롤 동작을 훌륭하게 수행 할 수 있지만 사용 사례의 차이와 복잡성으로 인해이 프리미티브를 제공하여 특정 사용자 구현을 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="2023893211646b38329738f0c75758b66f90c972" translate="yes" xml:space="preserve">
          <source>Lazy Loading Routes</source>
          <target state="translated">지연 로딩 경로</target>
        </trans-unit>
        <trans-unit id="960763001b8d9b9065802f6e1547e28eeab1142a" translate="yes" xml:space="preserve">
          <source>Let's assume we have a &lt;code&gt;Post&lt;/code&gt; component that needs to fetch the data for a post based on &lt;code&gt;$route.params.id&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;$route.params.id&lt;/code&gt; 기반으로 한 게시물의 데이터를 가져와야 하는 &lt;code&gt;Post&lt;/code&gt; 컴포넌트 가 있다고 가정 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MIT 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="4915ca87eec25d13d5ac866672b6c4238dab8b71" translate="yes" xml:space="preserve">
          <source>Links with automatic active CSS classes</source>
          <target state="translated">자동 활성 CSS 클래스와의 링크</target>
        </trans-unit>
        <trans-unit id="92680ca040170e2f3c165102fde3e8bf6487a0ea" translate="yes" xml:space="preserve">
          <source>Matching Priority</source>
          <target state="translated">일치하는 우선 순위</target>
        </trans-unit>
        <trans-unit id="3211dfc6706021083577bbc609b0178a57df986b" translate="yes" xml:space="preserve">
          <source>Modular, component-based router configuration</source>
          <target state="translated">모듈 식 컴포넌트 기반 라우터 구성</target>
        </trans-unit>
        <trans-unit id="b33d0a16416aadff4b68e3238fad1ab174a916bb" translate="yes" xml:space="preserve">
          <source>Named Routes</source>
          <target state="translated">명명 된 경로</target>
        </trans-unit>
        <trans-unit id="4b4baaa726aeae2df5efab33c30dccfc59484a03" translate="yes" xml:space="preserve">
          <source>Named Views</source>
          <target state="translated">명명 된 뷰</target>
        </trans-unit>
        <trans-unit id="af41b08c1d868960ee0e9d9af1ed763d0fb61bc6" translate="yes" xml:space="preserve">
          <source>Native Node.js</source>
          <target state="translated">네이티브 Node.js</target>
        </trans-unit>
        <trans-unit id="07230c4db479422597919304a18bd14cae18e95e" translate="yes" xml:space="preserve">
          <source>Navigation Guards</source>
          <target state="translated">네비게이션 가드</target>
        </trans-unit>
        <trans-unit id="ad97c58c21ae3ad462c67b621752398d8cf7de88" translate="yes" xml:space="preserve">
          <source>Navigation confirmed.</source>
          <target state="translated">탐색이 확인되었습니다.</target>
        </trans-unit>
        <trans-unit id="1aaed24547504400177ecf8ccb6c88025b631a06" translate="yes" xml:space="preserve">
          <source>Navigation triggered.</source>
          <target state="translated">탐색이 트리거되었습니다.</target>
        </trans-unit>
        <trans-unit id="0b5ff356281045481c2265d94104931fc97e4610" translate="yes" xml:space="preserve">
          <source>Nested Named Views</source>
          <target state="translated">중첩 된 명명 된 뷰</target>
        </trans-unit>
        <trans-unit id="bef32b44309c819256ef91505f3ce46153114806" translate="yes" xml:space="preserve">
          <source>Nested Routes</source>
          <target state="translated">중첩 경로</target>
        </trans-unit>
        <trans-unit id="2f30bbc93aff9a021a6bb7d40bb01c7e1a30b727" translate="yes" xml:space="preserve">
          <source>Nested route/view mapping</source>
          <target state="translated">중첩 된 라우트 / 뷰 매핑</target>
        </trans-unit>
        <trans-unit id="cfb4b21b400ed7bdabab34b9e79d6404c608dbeb" translate="yes" xml:space="preserve">
          <source>New in 2.8.0</source>
          <target state="translated">2.8.0의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="72a0e8bd8ba8cfc1de48c1ade52eb80e3b492ce5" translate="yes" xml:space="preserve">
          <source>Not to worry: To fix the issue, all you need to do is add a simple catch-all fallback route to your server. If the URL doesn't match any static assets, it should serve the same &lt;code&gt;index.html&lt;/code&gt; page that your app lives in. Beautiful, again!</source>
          <target state="translated">걱정하지 마십시오. 문제를 해결하려면 서버에 간단한 catch-all 폴백 경로를 추가하기 만하면됩니다. URL이 정적 자산과 일치하지 않으면 앱이 있는 것과 동일한 &lt;code&gt;index.html&lt;/code&gt; 페이지를 제공해야 합니다.</target>
        </trans-unit>
        <trans-unit id="42e1c28f71b271e74095cb412d9718f1a1dd3d89" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../advanced/navigation-guards&quot;&gt;Navigation Guards&lt;/a&gt; are not applied on the route that redirects, only on its target. In the example below, adding a &lt;code&gt;beforeEnter&lt;/code&gt; or &lt;code&gt;beforeLeave&lt;/code&gt; guard to the &lt;code&gt;/a&lt;/code&gt; route would not have any effect.</source>
          <target state="translated">참고 &lt;a href=&quot;../advanced/navigation-guards&quot;&gt;탐색 가드가&lt;/a&gt; 경로에 적용되지 않습니다 리디렉션 만 목표에 그. 아래 예제에서 &lt;code&gt;beforeEnter&lt;/code&gt; 또는 &lt;code&gt;beforeLeave&lt;/code&gt; 가드를 &lt;code&gt;/a&lt;/code&gt; 경로에 추가 해도 아무런 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b0e81fa927ae576a7a77d7347aa93d6d3b675c08" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;beforeRouteEnter&lt;/code&gt; is the only guard that supports passing a callback to &lt;code&gt;next&lt;/code&gt;. For &lt;code&gt;beforeRouteUpdate&lt;/code&gt; and &lt;code&gt;beforeRouteLeave&lt;/code&gt;, &lt;code&gt;this&lt;/code&gt; is already available, so passing a callback is unnecessary and therefore &lt;em&gt;not supported&lt;/em&gt;:</source>
          <target state="translated">참고 &lt;code&gt;beforeRouteEnter&lt;/code&gt; 가 지원하는 콜백을 전달하는 유일한 가드 &lt;code&gt;next&lt;/code&gt; . 들어 &lt;code&gt;beforeRouteUpdate&lt;/code&gt; 및 &lt;code&gt;beforeRouteLeave&lt;/code&gt; , &lt;code&gt;this&lt;/code&gt; 콜백을 통과하는 것은 불필요하기 때문에, 그래서 이미 사용할 &lt;em&gt;수 없습니다&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="66819e4b27a76327ff3f7f1554dfc32762722dc5" translate="yes" xml:space="preserve">
          <source>Nothing needs to change in the route config, just use &lt;code&gt;Foo&lt;/code&gt; as usual:</source>
          <target state="translated">경로 설정에서 아무것도 변경할 필요가 없습니다 . 평소처럼 &lt;code&gt;Foo&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b9854b4ee72e20cf46424b31f8fb60496aa9d57a" translate="yes" xml:space="preserve">
          <source>Notice that a &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; automatically gets the &lt;code&gt;.router-link-active&lt;/code&gt; class when its target route is matched. You can learn more about it in its &lt;a href=&quot;../api/index#router-link&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="translated">유의 사항 있음 &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; 자동 취득 &lt;code&gt;.router-link-active&lt;/code&gt; 목표 경로가 일치 클래스. &lt;a href=&quot;../api/index#router-link&quot;&gt;API 참조 서&lt;/a&gt; 에서 이에 대해 자세히 배울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="40eddaef857ef5cfaedb727b42037014203c4199" translate="yes" xml:space="preserve">
          <source>Now URLs like &lt;code&gt;/user/foo&lt;/code&gt; and &lt;code&gt;/user/bar&lt;/code&gt; will both map to the same route.</source>
          <target state="translated">이제 &lt;code&gt;/user/foo&lt;/code&gt; 및 &lt;code&gt;/user/bar&lt;/code&gt; 와 같은 URL 은 모두 동일한 경로에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="7f58022f766261caffba5edc95b9a9f6abe4cafe" translate="yes" xml:space="preserve">
          <source>Object mode</source>
          <target state="translated">객체 모드</target>
        </trans-unit>
        <trans-unit id="cbe6bf860b85b361d427ae111c8df54a68d83e74" translate="yes" xml:space="preserve">
          <source>One consequence of this is that &lt;code&gt;&amp;lt;router-link to=&quot;/&quot;&amp;gt;&lt;/code&gt; will be active for every route! To force the link into &quot;exact match mode&quot;, use the &lt;code&gt;exact&lt;/code&gt; prop:</source>
          <target state="translated">그 결과로 &lt;code&gt;&amp;lt;router-link to=&quot;/&quot;&amp;gt;&lt;/code&gt; 가 모든 경로에 대해 활성화됩니다! 링크를 &quot;정확한 일치 모드&quot;로 설정하려면 &lt;code&gt;exact&lt;/code&gt; 소품을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="22cb362145457cd718598c267d42d98d75403097" translate="yes" xml:space="preserve">
          <source>One thing to note when using routes with params is that when the user navigates from &lt;code&gt;/user/foo&lt;/code&gt; to &lt;code&gt;/user/bar&lt;/code&gt;, &lt;strong&gt;the same component instance will be reused&lt;/strong&gt;. Since both routes render the same component, this is more efficient than destroying the old instance and then creating a new one. &lt;strong&gt;However, this also means that the lifecycle hooks of the component will not be called&lt;/strong&gt;.</source>
          <target state="translated">참고로 한 가지 PARAMS과 경로를 사용하는 사용자를 탐색이에서 때 &lt;code&gt;/user/foo&lt;/code&gt; 에 &lt;code&gt;/user/bar&lt;/code&gt; , &lt;strong&gt;동일한 구성 요소 인스턴스를 재사용 할 것이다&lt;/strong&gt; . 두 경로 모두 동일한 구성 요소를 렌더링하므로 이전 인스턴스를 삭제 한 다음 새 인스턴스를 만드는 것보다 효율적입니다. &lt;strong&gt;그러나 이는 구성 요소의 수명주기 후크가 호출되지 않음을 의미합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="046793d8826f7ce628a8c0fe40b3cbce54497fb1" translate="yes" xml:space="preserve">
          <source>Or even use a function for dynamic redirecting:</source>
          <target state="translated">또는 동적 리디렉션 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3d1f5ce248d4fbbc0d11f219d548dfc5dd5adf41" translate="yes" xml:space="preserve">
          <source>Or, use the &lt;code&gt;beforeRouteUpdate&lt;/code&gt;&lt;a href=&quot;../advanced/navigation-guards&quot;&gt;navigation guard&lt;/a&gt; introduced in 2.2:</source>
          <target state="translated">또는 2.2에 도입 된 &lt;code&gt;beforeRouteUpdate&lt;/code&gt; &lt;a href=&quot;../advanced/navigation-guards&quot;&gt;탐색 가드를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="91249dc20c49d676cce833a9923195f2e2d486ef" translate="yes" xml:space="preserve">
          <source>Other Guides</source>
          <target state="translated">기타 안내서</target>
        </trans-unit>
        <trans-unit id="c2019c2002b88d1423b00871a4756c80a3a2781e" translate="yes" xml:space="preserve">
          <source>Passing Props to Route Components</source>
          <target state="translated">구성 요소를 전달하기 위해 소품 전달</target>
        </trans-unit>
        <trans-unit id="4b26aba5cee750beb1314811649192d3f41dcc61" translate="yes" xml:space="preserve">
          <source>Per-Route Guard</source>
          <target state="translated">경로 별 가드</target>
        </trans-unit>
        <trans-unit id="9c95ba720f7490c64c5284e62aabf2337f81bd7a" translate="yes" xml:space="preserve">
          <source>Per-Route Transition</source>
          <target state="translated">경로 별 전환</target>
        </trans-unit>
        <trans-unit id="bc84978ebebfacb7e5a7426cf2bc186f4e115de6" translate="yes" xml:space="preserve">
          <source>Programmatic</source>
          <target state="translated">Programmatic</target>
        </trans-unit>
        <trans-unit id="6ac41420921db4b82a6fc5a064c1c845ef1ef7bc" translate="yes" xml:space="preserve">
          <source>Programmatic Navigation</source>
          <target state="translated">프로그래밍 방식 탐색</target>
        </trans-unit>
        <trans-unit id="94ea926127d780e977ef91fb29c2e11e32ef8f1a" translate="yes" xml:space="preserve">
          <source>Programmatically navigate to a new URL. See &lt;a href=&quot;../guide/essentials/navigation&quot;&gt;Programmatic Navigation&lt;/a&gt; for more details.</source>
          <target state="translated">프로그래밍 방식으로 새 URL로 이동합니다. 자세한 내용은 &lt;a href=&quot;../guide/essentials/navigation&quot;&gt;프로그래밍 방식 탐색&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fe8d3baced9c5e7884c8c86724de198f8f80e16a" translate="yes" xml:space="preserve">
          <source>Provide custom query string parse / stringify functions. Overrides the default.</source>
          <target state="translated">사용자 정의 쿼리 문자열 구문 분석 / 문자열 화 기능을 제공하십시오. 기본값을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="96f0529aa6c0b6cd2083e3a6368bba819840a7d7" translate="yes" xml:space="preserve">
          <source>Reacting to Params Changes</source>
          <target state="translated">매개 변수 변경에 반응</target>
        </trans-unit>
        <trans-unit id="526ba9b15d7e0af70c58f07b6eccd992ee1bc4bb" translate="yes" xml:space="preserve">
          <source>Real app UIs are usually composed of components that are nested multiple levels deep. It is also very common that the segments of a URL corresponds to a certain structure of nested components, for example:</source>
          <target state="translated">실제 앱 UI는 일반적으로 여러 수준으로 중첩 된 구성 요소로 구성됩니다. URL의 세그먼트가 다음과 같이 중첩 된 구성 요소의 특정 구조에 해당하는 것도 매우 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="58cfcdca5ed542240131e60e7a5af5e83f61e786" translate="yes" xml:space="preserve">
          <source>Redirect</source>
          <target state="translated">Redirect</target>
        </trans-unit>
        <trans-unit id="872a53613a6cd7a171894de65cd005be5a189f12" translate="yes" xml:space="preserve">
          <source>Redirect and Alias</source>
          <target state="translated">리디렉션 및 별칭</target>
        </trans-unit>
        <trans-unit id="05cef8495ed3efecc490bc4d66c9957eb645c538" translate="yes" xml:space="preserve">
          <source>Redirecting is also done in the &lt;code&gt;routes&lt;/code&gt; configuration. To redirect from &lt;code&gt;/a&lt;/code&gt; to &lt;code&gt;/b&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;routes&lt;/code&gt; 구성 에서도 리디렉션이 수행됩니다 . 에서 리디렉션하려면 &lt;code&gt;/a&lt;/code&gt; 로 &lt;code&gt;/b&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5e03acae55c659588b259583338e24a88915601b" translate="yes" xml:space="preserve">
          <source>Register a callback which will be called when an error is caught during a route navigation. Note for an error to be called, it must be one of the following scenarios:</source>
          <target state="translated">경로 탐색 중에 오류가 발생하면 호출 될 콜백을 등록하십시오. 오류를 호출하려면 다음 시나리오 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="44643ea5c5697be4b30047afe003b8f7dc43c4d9" translate="yes" xml:space="preserve">
          <source>Regular params will only match characters in between url fragments, separated by &lt;code&gt;/&lt;/code&gt;. If we want to match &lt;strong&gt;anything&lt;/strong&gt;, we can use the asterisk (&lt;code&gt;*&lt;/code&gt;):</source>
          <target state="translated">일반 매개 변수는 &lt;code&gt;/&lt;/code&gt; 로 구분 된 URL 조각 사이의 문자 만 일치합니다 . 일치하는 &lt;strong&gt;것을&lt;/strong&gt; 원한다면 별표 ( &lt;code&gt;*&lt;/code&gt; )를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2cb1e457692275b0cbe497b5cdfa463b963b481c" translate="yes" xml:space="preserve">
          <source>Remember that &lt;strong&gt;params or query changes won't trigger enter/leave navigation guards&lt;/strong&gt;. You can either &lt;a href=&quot;../essentials/dynamic-matching#reacting-to-params-changes&quot;&gt;watch the &lt;code&gt;$route&lt;/code&gt; object&lt;/a&gt; to react to those changes, or use the &lt;code&gt;beforeRouteUpdate&lt;/code&gt; in-component guard.</source>
          <target state="translated">그 기억 &lt;strong&gt;PARAMS 또는 쿼리 변경 / 휴가 탐색 가드를 입력 트리거하지 않습니다&lt;/strong&gt; . 당신도 &lt;a href=&quot;../essentials/dynamic-matching#reacting-to-params-changes&quot;&gt;시계 &lt;code&gt;$route&lt;/code&gt; 객체가&lt;/a&gt; 그 변화에 반응하거나 사용 &lt;code&gt;beforeRouteUpdate&lt;/code&gt; 의 구성 요소 가드.</target>
        </trans-unit>
        <trans-unit id="88429579c754b2e4d3683288db9f7a924c0974c7" translate="yes" xml:space="preserve">
          <source>Resolve async route components.</source>
          <target state="translated">비동기 라우트 구성 요소를 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="e78584839e5838f29b10c37405eaf8a6ac7c76fe" translate="yes" xml:space="preserve">
          <source>Returning the &lt;code&gt;savedPosition&lt;/code&gt; will result in a native-like behavior when navigating with back/forward buttons:</source>
          <target state="translated">&lt;code&gt;savedPosition&lt;/code&gt; 을 반환하면 뒤로 / 앞으로 버튼으로 탐색 할 때 기본적으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="cd3ad3cf949ec4b3e1af61f8f3065866b05512ce" translate="yes" xml:space="preserve">
          <source>Returns an Array of the components (definition/constructor, not instances) matched by the provided location or the current route. This is mostly used during server-side rendering to perform data prefetching.</source>
          <target state="translated">제공된 위치 또는 현재 경로와 일치하는 구성 요소 (인스턴스가 아닌 정의 / 생성자)의 배열을 반환합니다. 주로 서버 측 렌더링 중에 데이터 프리 페치를 수행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="08f96c7a98ceba257c7a2cba704c62f75cb87b83" translate="yes" xml:space="preserve">
          <source>Reverse URL resolving. Given location in form same as used in &lt;code&gt;&amp;lt;router-link/&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">역 URL 해결. &lt;code&gt;&amp;lt;router-link/&amp;gt;&lt;/code&gt; 에서 사용 된 것과 동일한 형식의 위치가 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="f178d9cbdaadbfcdce35cc4e0b16c043f79ef6fd" translate="yes" xml:space="preserve">
          <source>Route Meta Fields</source>
          <target state="translated">메타 필드 라우팅</target>
        </trans-unit>
        <trans-unit id="efaaab5dc398bef87cbcd2fcea3d10d70d8bbd86" translate="yes" xml:space="preserve">
          <source>Route Object Properties</source>
          <target state="translated">배관 객체 속성</target>
        </trans-unit>
        <trans-unit id="fdf24b2ac491ab4f0861f5f876118c8447caa002" translate="yes" xml:space="preserve">
          <source>Route params, query, wildcards</source>
          <target state="translated">경로 매개 변수, 쿼리, 와일드 카드</target>
        </trans-unit>
        <trans-unit id="aa1effcfd004511edf487558b241065fd6c6c439" translate="yes" xml:space="preserve">
          <source>Route-Based Dynamic Transition</source>
          <target state="translated">경로 기반 동적 전환</target>
        </trans-unit>
        <trans-unit id="61c1d27f7171536b1ecc5df8e1f3d8c5c9fefc7a" translate="yes" xml:space="preserve">
          <source>Router Construction Options</source>
          <target state="translated">라우터 구성 옵션</target>
        </trans-unit>
        <trans-unit id="2e1838554fec8632f2e27e2232f0a9c553143110" translate="yes" xml:space="preserve">
          <source>Router Instance Methods</source>
          <target state="translated">라우터 인스턴스 방법</target>
        </trans-unit>
        <trans-unit id="e7f39db9665e9e7b15d490cea293333b9ca9f2fb" translate="yes" xml:space="preserve">
          <source>Router Instance Properties</source>
          <target state="translated">라우터 인스턴스 속성</target>
        </trans-unit>
        <trans-unit id="833b49319798dd3229365eff801afcd66c753ef8" translate="yes" xml:space="preserve">
          <source>RouterOptions.base</source>
          <target state="translated">RouterOptions.base</target>
        </trans-unit>
        <trans-unit id="5c94ab4afd451a6c75be941ba1a332f700c7b271" translate="yes" xml:space="preserve">
          <source>RouterOptions.fallback</source>
          <target state="translated">RouterOptions.fallback</target>
        </trans-unit>
        <trans-unit id="a6a71a3c615b71fa18dfabe16958efe8a954be43" translate="yes" xml:space="preserve">
          <source>RouterOptions.linkActiveClass</source>
          <target state="translated">RouterOptions.linkActiveClass</target>
        </trans-unit>
        <trans-unit id="a3b414a25a718d66edd0a60b09fe7e8b14feeced" translate="yes" xml:space="preserve">
          <source>RouterOptions.linkExactActiveClass</source>
          <target state="translated">RouterOptions.linkExactActiveClass</target>
        </trans-unit>
        <trans-unit id="b1f3441c2a652d1c9f341126405e100b126d5dda" translate="yes" xml:space="preserve">
          <source>RouterOptions.mode</source>
          <target state="translated">RouterOptions.mode</target>
        </trans-unit>
        <trans-unit id="02a0c6b6ad7ff83236c43f2b27e906e5d1da56b2" translate="yes" xml:space="preserve">
          <source>RouterOptions.parseQuery / stringifyQuery</source>
          <target state="translated">RouterOptions.parseQuery / stringifyQuery</target>
        </trans-unit>
        <trans-unit id="ed78fca5da829ceec546e652b1cb232072966088" translate="yes" xml:space="preserve">
          <source>RouterOptions.routes</source>
          <target state="translated">RouterOptions.routes</target>
        </trans-unit>
        <trans-unit id="2c66f8accea4c1855450a7c83268642fa0656f71" translate="yes" xml:space="preserve">
          <source>RouterOptions.scrollBehavior</source>
          <target state="translated">RouterOptions.scrollBehavior</target>
        </trans-unit>
        <trans-unit id="e0596a1adc9bfd16283229a08fe714c7f0e636b8" translate="yes" xml:space="preserve">
          <source>Scroll Behavior</source>
          <target state="translated">스크롤 동작</target>
        </trans-unit>
        <trans-unit id="71d0912e026dc7a009be1e6e16b6c856427233a5" translate="yes" xml:space="preserve">
          <source>Second, in webpack 2, we can use the &lt;a href=&quot;https://github.com/tc39/proposal-dynamic-import&quot;&gt;dynamic import&lt;/a&gt; syntax to indicate a code-split point:</source>
          <target state="translated">둘째, 웹팩 2에서 &lt;a href=&quot;https://github.com/tc39/proposal-dynamic-import&quot;&gt;동적 가져 오기&lt;/a&gt; 구문을 사용하여 코드 분할 지점을 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="910d9257f1da3a588d7c110055be4d2d58d59a55" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../guide/advanced/navigation-guards#in-component-guards&quot;&gt;In Component Guards&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../guide/advanced/navigation-guards#in-component-guards&quot;&gt;구성 요소 보호대를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0cdbee57c9d61aea21d3f61df384d5d286dbae09" translate="yes" xml:space="preserve">
          <source>See full example &lt;a href=&quot;https://github.com/vuejs/vue-router/blob/dev/examples/transitions/app.js&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">전체 예를 &lt;a href=&quot;https://github.com/vuejs/vue-router/blob/dev/examples/transitions/app.js&quot;&gt;보려면 여기를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c263edad49b6f4c271aeaa49c2421987156874d" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;append&lt;/code&gt; prop always appends the relative path to the current path. For example, assuming we are navigating from &lt;code&gt;/a&lt;/code&gt; to a relative link &lt;code&gt;b&lt;/code&gt;, without &lt;code&gt;append&lt;/code&gt; we will end up at &lt;code&gt;/b&lt;/code&gt;, but with &lt;code&gt;append&lt;/code&gt; we will end up at &lt;code&gt;/a/b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;append&lt;/code&gt; prop을 설정하면 항상 상대 경로가 현재 경로에 추가됩니다. 예를 들어, 우리가 가정에서 탐색되는 &lt;code&gt;/a&lt;/code&gt; 상대 링크에 &lt;code&gt;b&lt;/code&gt; 없이 &lt;code&gt;append&lt;/code&gt; 우리가 끝날 &lt;code&gt;/b&lt;/code&gt; 이지만 함께 &lt;code&gt;append&lt;/code&gt; 우리에서 끝날 &lt;code&gt;/a/b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2df78320bc495352bdf39a1085d854418e6cac2" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;replace&lt;/code&gt; prop will call &lt;code&gt;router.replace()&lt;/code&gt; instead of &lt;code&gt;router.push()&lt;/code&gt; when clicked, so the navigation will not leave a history record.</source>
          <target state="translated">&lt;code&gt;replace&lt;/code&gt; prop을 설정 하면 클릭하면 &lt;code&gt;router.push()&lt;/code&gt; &lt;code&gt;router.replace()&lt;/code&gt; 대신 router.replace () 를 호출 하므로 탐색시 기록 기록 이 남지 않습니다.</target>
        </trans-unit>
        <trans-unit id="46a94dbbd4790f8205b0a817760e72fa622a2361" translate="yes" xml:space="preserve">
          <source>Setting this to &lt;code&gt;false&lt;/code&gt; essentially makes every &lt;code&gt;router-link&lt;/code&gt; navigation a full page refresh in IE9. This is useful when the app is server-rendered and needs to work in IE9, because a hash mode URL does not work with SSR.</source>
          <target state="translated">이것을 &lt;code&gt;false&lt;/code&gt; 로 설정하면 기본적으로 모든 &lt;code&gt;router-link&lt;/code&gt; 탐색이 IE9에서 전체 페이지를 새로 고칩니다. 해시 모드 URL이 SSR에서 작동하지 않기 때문에 앱이 서버 렌더링되어 IE9에서 작동해야 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="671048db110a3469e52979ba873e1f31f52b0adc" translate="yes" xml:space="preserve">
          <source>Signature:</source>
          <target state="translated">Signature:</target>
        </trans-unit>
        <trans-unit id="0a009f19aef724da25b633c4e8ec74c1e6c57a83" translate="yes" xml:space="preserve">
          <source>Signatures:</source>
          <target state="translated">Signatures:</target>
        </trans-unit>
        <trans-unit id="b309129b0928ab5637f1329cc9b1622c1899eda7" translate="yes" xml:space="preserve">
          <source>Since it's just a component, it works with &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt;. When using the both together, make sure to use &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; inside:</source>
          <target state="translated">구성 요소 일 뿐이므로 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 와 함께 작동합니다 . 둘 다를 함께 사용할 때 내부에 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="67617841112e8fc88adea7ca66ce82c7f040a26e" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;&amp;lt;router-view&amp;gt;&lt;/code&gt; is essentially a dynamic component, we can apply transition effects to it the same way using the &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">때문에 &lt;code&gt;&amp;lt;router-view&amp;gt;&lt;/code&gt; 동적 구성 요소가 본질적으로, 우리는 그것을 사용하여 동일한 방식으로 전환 효과를 적용 할 수 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 성분 :</target>
        </trans-unit>
        <trans-unit id="99967819e7c344898b7f5cd24d01b88f4a531300" translate="yes" xml:space="preserve">
          <source>So how do we access this &lt;code&gt;meta&lt;/code&gt; field?</source>
          <target state="translated">그렇다면이 &lt;code&gt;meta&lt;/code&gt; 필드에 어떻게 접근 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="a47509bf5c58ce57a092a288e1bf085394866b2a" translate="yes" xml:space="preserve">
          <source>Sometimes it is more convenient to identify a route with a name, especially when linking to a route or performing navigations. You can give a route a name in the &lt;code&gt;routes&lt;/code&gt; options while creating the Router instance:</source>
          <target state="translated">경로에 연결하거나 탐색을 수행 할 때 이름으로 경로를 식별하는 것이 더 편리한 경우가 있습니다. 라우터 인스턴스를 만드는 동안 &lt;code&gt;routes&lt;/code&gt; 옵션 에 경로 이름을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a6e252d9e94a641f7201be6ee56e2627c06169f7" translate="yes" xml:space="preserve">
          <source>Sometimes the same URL may be matched by multiple routes. In such a case the matching priority is determined by the order of route definition: the earlier a route is defined, the higher priority it gets.</source>
          <target state="translated">때때로 동일한 URL이 여러 경로에 의해 일치 될 수 있습니다. 이 경우 일치하는 우선 순위는 경로 정의 순서에 따라 결정됩니다. 경로가 일찍 정의 될수록 우선 순위가 높아집니다.</target>
        </trans-unit>
        <trans-unit id="d6c78fa18c05228aa3988fe7758e8dfdfee27b6f" translate="yes" xml:space="preserve">
          <source>Sometimes we may want the active class to be applied to an outer element rather than the &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; tag itself, in that case, you can wrap that element inside a &lt;code&gt;router-link&lt;/code&gt; and use the &lt;code&gt;v-slot&lt;/code&gt; properties to create your link:</source>
          <target state="translated">때때로 우리는 &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 태그가 아닌 외부 요소에 활성 클래스를 적용하기를 원할 수 있습니다 .이 경우 &lt;code&gt;router-link&lt;/code&gt; 내부에서 해당 요소를 래핑 하고 &lt;code&gt;v-slot&lt;/code&gt; 속성을 사용하여 링크를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="332b325341fba64b850ebd8f2eeaa0d19560cae7" translate="yes" xml:space="preserve">
          <source>Sometimes we may want to group all the components nested under the same route into the same async chunk. To achieve that we need to use &lt;a href=&quot;https://webpack.js.org/guides/code-splitting-async/#chunk-names&quot;&gt;named chunks&lt;/a&gt; by providing a chunk name using a special comment syntax (requires webpack &amp;gt; 2.4):</source>
          <target state="translated">때로는 동일한 경로에 중첩 된 모든 구성 요소를 동일한 비동기 청크로 그룹화 할 수 있습니다. 특별한 주석 구문을 사용하여 청크 이름을 제공하여 &lt;a href=&quot;https://webpack.js.org/guides/code-splitting-async/#chunk-names&quot;&gt;명명 된 청크&lt;/a&gt; 를 사용해야 합니다 (웹팩&amp;gt; 2.4 필요).</target>
        </trans-unit>
        <trans-unit id="0b2711d8ebe3a7a6248cdb5416c095b9588b27d5" translate="yes" xml:space="preserve">
          <source>Sometimes we want &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; to render as another tag, e.g &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;. Then we can use &lt;code&gt;tag&lt;/code&gt; prop to specify which tag to render to, and it will still listen to click events for navigation.</source>
          <target state="translated">때때로 &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; 가 다른 태그로 렌더링 되기를 원합니다 ( 예 : &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; ) . 그런 다음 &lt;code&gt;tag&lt;/code&gt; prop을 사용하여 렌더링 할 태그를 지정할 수 있으며 탐색을위한 클릭 이벤트를 계속 수신합니다.</target>
        </trans-unit>
        <trans-unit id="559e629883f73acac255b3a777bfc5ed36572151" translate="yes" xml:space="preserve">
          <source>Sometimes you need to display multiple views at the same time instead of nesting them, e.g. creating a layout with a &lt;code&gt;sidebar&lt;/code&gt; view and a &lt;code&gt;main&lt;/code&gt; view. This is where named views come in handy. Instead of having one single outlet in your view, you can have multiple and give each of them a name. A &lt;code&gt;router-view&lt;/code&gt; without a name will be given &lt;code&gt;default&lt;/code&gt; as its name.</source>
          <target state="translated">&lt;code&gt;sidebar&lt;/code&gt; 보기와 &lt;code&gt;main&lt;/code&gt; 보기를 사용 하여 레이아웃을 만드는 등 중첩하지 않고 여러보기를 동시에 표시해야하는 경우가 있습니다. 여기에서 명명 된 뷰가 편리합니다. 보기에 하나의 콘센트가있는 대신 여러 콘센트를 사용하여 각각의 이름을 지정할 수 있습니다. &lt;code&gt;router-view&lt;/code&gt; 이름이없는이 주어집니다 &lt;code&gt;default&lt;/code&gt; 의 이름을.</target>
        </trans-unit>
        <trans-unit id="80c22a281f2411a826028def672b188a9db5ba37" translate="yes" xml:space="preserve">
          <source>Sometimes you need to fetch data from the server when a route is activated. For example, before rendering a user profile, you need to fetch the user's data from the server. We can achieve this in two different ways:</source>
          <target state="translated">경로가 활성화 될 때 서버에서 데이터를 가져와야하는 경우가 있습니다. 예를 들어, 사용자 프로필을 렌더링하기 전에 서버에서 사용자 데이터를 가져와야합니다. 우리는 이것을 두 가지 방법으로 달성 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="05477b7e20cf8c615743b4d1d92c7caf91c8dcd1" translate="yes" xml:space="preserve">
          <source>Specify the event(s) that can trigger the link navigation.</source>
          <target state="translated">링크 탐색을 트리거 할 수있는 이벤트를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="068a22f61f3db94269ab675efff014f3fb75087b" translate="yes" xml:space="preserve">
          <source>Technically, both are valid choices - it ultimately depends on the user experience you are aiming for.</source>
          <target state="translated">기술적으로, 둘 다 유효한 선택입니다. 궁극적으로 원하는 사용자 경험에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="687d29fbc88ced0c0b4cc5e85f3cdff8a6d730b0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;index#mode&quot;&gt;mode&lt;/a&gt; the router is using.</source>
          <target state="translated">&lt;a href=&quot;index#mode&quot;&gt;모드&lt;/a&gt; 라우터가 사용된다.</target>
        </trans-unit>
        <trans-unit id="04e697c4c0982279fe937992c14787c25b1f00ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;router-view&amp;gt;&lt;/code&gt; component is a functional component that renders the matched component for the given path. Components rendered in &lt;code&gt;&amp;lt;router-view&amp;gt;&lt;/code&gt; can also contain its own &lt;code&gt;&amp;lt;router-view&amp;gt;&lt;/code&gt;, which will render components for nested paths.</source>
          <target state="translated">&lt;code&gt;&amp;lt;router-view&amp;gt;&lt;/code&gt; 요소는 주어진 경로에 대해 유사한 구성 요소를 표현하는 기능 부품이다. &lt;code&gt;&amp;lt;router-view&amp;gt;&lt;/code&gt; 에서 렌더링 된 구성 요소 에는 자체 &lt;code&gt;&amp;lt;router-view&amp;gt;&lt;/code&gt; 가 포함될 수 있으며 중첩 된 경로에 대한 구성 요소를 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="08608ef6a2b61ff5e3d12ea1a2a5973072989475" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;router-view&amp;gt;&lt;/code&gt; here is a top-level outlet. It renders the component matched by a top level route. Similarly, a rendered component can also contain its own, nested &lt;code&gt;&amp;lt;router-view&amp;gt;&lt;/code&gt;. For example, if we add one inside the &lt;code&gt;User&lt;/code&gt; component's template:</source>
          <target state="translated">여기서 &lt;code&gt;&amp;lt;router-view&amp;gt;&lt;/code&gt; 는 최상위 콘센트입니다. 최상위 경로와 일치하는 구성 요소를 렌더링합니다. 마찬가지로 렌더링 된 구성 요소에는 자체 중첩 &lt;code&gt;&amp;lt;router-view&amp;gt;&lt;/code&gt; 도 포함될 수 있습니다 . 예를 들어, &lt;code&gt;User&lt;/code&gt; 컴포넌트의 템플릿 안에 하나를 추가하면 :</target>
        </trans-unit>
        <trans-unit id="f1f5eb58ebb5f1684f4b310363e94f6347277589" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; section for &lt;code&gt;UserSettings&lt;/code&gt; component in the above layout would look something like this:</source>
          <target state="translated">위 레이아웃에서 &lt;code&gt;UserSettings&lt;/code&gt; 구성 요소 의 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 섹션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0ffac73304a3247ab71d5acf0d0089b4643469ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;beforeRouteEnter&lt;/code&gt; guard does &lt;strong&gt;NOT&lt;/strong&gt; have access to &lt;code&gt;this&lt;/code&gt;, because the guard is called before the navigation is confirmed, thus the new entering component has not even been created yet.</source>
          <target state="translated">&lt;code&gt;beforeRouteEnter&lt;/code&gt; 의 가드는 않습니다 &lt;strong&gt;NOT&lt;/strong&gt; 에 액세스 할 수있는 &lt;code&gt;this&lt;/code&gt; 탐색이 확인되기 전에 가드가 이렇게 새로운 진입 구성 요소가 아직 생성되지 않은, 호출되기 때문에.</target>
        </trans-unit>
        <trans-unit id="4e51fe4a377c162aa9aa7660ecf5294ec09a28c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scrollBehavior&lt;/code&gt; function receives the &lt;code&gt;to&lt;/code&gt; and &lt;code&gt;from&lt;/code&gt; route objects. The third argument, &lt;code&gt;savedPosition&lt;/code&gt;, is only available if this is a &lt;code&gt;popstate&lt;/code&gt; navigation (triggered by the browser's back/forward buttons).</source>
          <target state="translated">&lt;code&gt;scrollBehavior&lt;/code&gt; 의 기능은 수신 &lt;code&gt;to&lt;/code&gt; 과 &lt;code&gt;from&lt;/code&gt; 라우팅 개체. 세 번째 인수 인 &lt;code&gt;savedPosition&lt;/code&gt; 은 &lt;code&gt;popstate&lt;/code&gt; 탐색 인 경우에만 사용할 수 있습니다 (브라우저의 뒤로 / 앞으로 단추로 트리거 됨).</target>
        </trans-unit>
        <trans-unit id="b201105a82e6b1036d079ab3dadf0d77a44a591c" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;leave guard&lt;/strong&gt; is usually used to prevent the user from accidentally leaving the route with unsaved edits. The navigation can be canceled by calling &lt;code&gt;next(false)&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;휴가 가드는&lt;/strong&gt; 보통 실수로 저장되지 않은 편집과 함께 길을 떠나는에서 사용자를 방지하기 위해 사용된다. &lt;code&gt;next(false)&lt;/code&gt; 호출하여 탐색을 취소 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dab97ce9509d6e41f417491fa98ce232a056e404" translate="yes" xml:space="preserve">
          <source>The Full Navigation Resolution Flow</source>
          <target state="translated">전체 탐색 해상도 흐름</target>
        </trans-unit>
        <trans-unit id="2ce5d364b93ce99ee04526a5645a7a0786cdf33e" translate="yes" xml:space="preserve">
          <source>The Route Object</source>
          <target state="translated">경로 객체</target>
        </trans-unit>
        <trans-unit id="6a5791c2e4084ff3c184ea22c374183b77459d77" translate="yes" xml:space="preserve">
          <source>The URL &lt;code&gt;/search?q=vue&lt;/code&gt; would pass &lt;code&gt;{query: 'vue'}&lt;/code&gt; as props to the &lt;code&gt;SearchUser&lt;/code&gt; component.</source>
          <target state="translated">URL &lt;code&gt;/search?q=vue&lt;/code&gt; 는 &lt;code&gt;{query: 'vue'}&lt;/code&gt; 를 &lt;code&gt;SearchUser&lt;/code&gt; 구성 요소 에 대한 소품으로 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="555c4d2ce807e9566e32519437eb61e3c547687c" translate="yes" xml:space="preserve">
          <source>The above can be expressed in the route configuration as:</source>
          <target state="translated">위의 경로 구성에서 다음과 같이 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf700d0b596efe64523dfdfd3077fd79cdb6d201" translate="yes" xml:space="preserve">
          <source>The above usage will apply the same transition for all routes. If you want each route's component to have different transitions, you can instead use &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; with different names inside each route component:</source>
          <target state="translated">위의 사용법은 모든 경로에 동일한 전환을 적용합니다. 각 라우트의 구성 요소가 다른 전환을 갖도록하려면 대신 각 라우트 구성 요소 내에서 다른 이름으로 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2082f4f8778f7c6a06e0469829d19c0acde7c5a4" translate="yes" xml:space="preserve">
          <source>The argument can be a string path, or a location descriptor object. Examples:</source>
          <target state="translated">인수는 문자열 경로 또는 위치 설명자 객체 일 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="d51405a3849a5f1aa494f8064229450ca2126ed2" translate="yes" xml:space="preserve">
          <source>The base URL of the app. For example, if the entire single page application is served under &lt;code&gt;/app/&lt;/code&gt;, then &lt;code&gt;base&lt;/code&gt; should use the value &lt;code&gt;&quot;/app/&quot;&lt;/code&gt;.</source>
          <target state="translated">앱의 기본 URL입니다. 예를 들어, 전체 단일 페이지 애플리케이션이 &lt;code&gt;/app/&lt;/code&gt; 아래에 제공되는 경우 &lt;code&gt;base&lt;/code&gt; 는 &lt;code&gt;&quot;/app/&quot;&lt;/code&gt; 값을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0e9b668edfbb90c8dd8566bc19351395810269f0" translate="yes" xml:space="preserve">
          <source>The current active &lt;a href=&quot;#the-route-object&quot;&gt;Route&lt;/a&gt;. This property is read-only and its properties are immutable, but it can be watched.</source>
          <target state="translated">현재 활성 &lt;a href=&quot;#the-route-object&quot;&gt;경로&lt;/a&gt; 입니다. 이 속성은 읽기 전용이며 속성은 변경할 수 없지만 볼 수는 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f7bab8a351710813a1792361d32a5a6df1ae38e" translate="yes" xml:space="preserve">
          <source>The current route represented as a &lt;a href=&quot;#the-route-object&quot;&gt;Route Object&lt;/a&gt;.</source>
          <target state="translated">현재 경로는 &lt;a href=&quot;#the-route-object&quot;&gt;Route Object&lt;/a&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="a4ee70db8e60fe3e3ae0c4e3f48b36f4ea00269d" translate="yes" xml:space="preserve">
          <source>The default active class matching behavior is &lt;strong&gt;inclusive match&lt;/strong&gt;. For example, &lt;code&gt;&amp;lt;router-link to=&quot;/a&quot;&amp;gt;&lt;/code&gt; will get this class applied as long as the current path starts with &lt;code&gt;/a/&lt;/code&gt; or is &lt;code&gt;/a&lt;/code&gt;.</source>
          <target state="translated">기본 활성 클래스 일치 동작은 &lt;strong&gt;포괄적 일치&lt;/strong&gt; 입니다. 예를 들어, &lt;code&gt;&amp;lt;router-link to=&quot;/a&quot;&amp;gt;&lt;/code&gt; 는 현재 경로가 &lt;code&gt;/a/&lt;/code&gt; 로 시작 하거나 / a 인 경우이 클래스를 적용 &lt;code&gt;/a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fc018db58291e889985ef9f6a90a3d9035b1b0e" translate="yes" xml:space="preserve">
          <source>The default mode for &lt;code&gt;vue-router&lt;/code&gt; is &lt;em&gt;hash mode&lt;/em&gt; - it uses the URL hash to simulate a full URL so that the page won't be reloaded when the URL changes.</source>
          <target state="translated">&lt;code&gt;vue-router&lt;/code&gt; 의 기본 모드 는 &lt;em&gt;해시 모드입니다&lt;/em&gt; . URL 해시를 사용하여 URL이 변경 될 때 페이지가 다시로드되지 않도록 전체 URL을 시뮬레이션합니다.</target>
        </trans-unit>
        <trans-unit id="9a016caa76d4a05870f99a4eed3dee7033ee46f7" translate="yes" xml:space="preserve">
          <source>The error is caught and asynchronously handled by calling &lt;code&gt;next(err)&lt;/code&gt; inside a route guard function;</source>
          <target state="translated">라우트 가드 함수 내에서 &lt;code&gt;next(err)&lt;/code&gt; 를 호출하여 오류가 포착되고 비동기 적으로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="0f2f86ab65bf1970fdb56cd32d84972e49a6c8f2" translate="yes" xml:space="preserve">
          <source>The error is thrown synchronously inside a route guard function;</source>
          <target state="translated">이 오류는 경로 보호 기능 내에서 동 기적으로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="61cff4ca13414860678d49874e056e8f8749345f" translate="yes" xml:space="preserve">
          <source>The full resolved URL including query and hash.</source>
          <target state="translated">쿼리 및 해시를 포함한 전체 확인 된 URL</target>
        </trans-unit>
        <trans-unit id="d1c04a5b16accbdac8df1dd93e195c169aaf7ac6" translate="yes" xml:space="preserve">
          <source>The function can return a scroll position object. The object could be in the form of:</source>
          <target state="translated">이 함수는 스크롤 위치 객체를 반환 할 수 있습니다. 객체의 형태는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e93691fb604f98a02503f006adee0c664623afde" translate="yes" xml:space="preserve">
          <source>The hash of the current route (with the &lt;code&gt;#&lt;/code&gt;), if it has one. If no hash is present the value will be an empty string.</source>
          <target state="translated">현재 경로의 해시 ( &lt;code&gt;#&lt;/code&gt; 포함 ) (있는 경우) 해시가 없으면 값은 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="97562970847680561b46ccccb1070fa6a1adf666" translate="yes" xml:space="preserve">
          <source>The name of the current route, if it has one. (See &lt;a href=&quot;../guide/essentials/named-routes&quot;&gt;Named Routes&lt;/a&gt;)</source>
          <target state="translated">현재 경로의 이름입니다 (있는 경우). ( &lt;a href=&quot;../guide/essentials/named-routes&quot;&gt;명명 된 루트&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="5bf899b9e668624d6f5b32ffbaed72a551c9d02d" translate="yes" xml:space="preserve">
          <source>The name of the route being redirected from, if there were one. (See &lt;a href=&quot;../guide/essentials/redirect-and-alias&quot;&gt;Redirect and Alias&lt;/a&gt;)</source>
          <target state="translated">경로가 재 지정된 경로 이름입니다 (있는 경우). ( &lt;a href=&quot;../guide/essentials/redirect-and-alias&quot;&gt;리디렉션 및 별명&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="e707eb7100daabaf223a4d0e5e9741dbce85d94a" translate="yes" xml:space="preserve">
          <source>The redirect can also be targeting a named route:</source>
          <target state="translated">리디렉션은 명명 된 경로를 타겟팅 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fbc13eca1bdc9570369c8131c1580d7dac0f41c" translate="yes" xml:space="preserve">
          <source>The root Vue instance the &lt;code&gt;router&lt;/code&gt; was injected into.</source>
          <target state="translated">&lt;code&gt;router&lt;/code&gt; 가 주입 된 루트 Vue 인스턴스 .</target>
        </trans-unit>
        <trans-unit id="9e6a4b5957343fea0ebfd0bd1d19e4759dbd35bf" translate="yes" xml:space="preserve">
          <source>The route object can be found in multiple places:</source>
          <target state="translated">경로 개체는 여러 곳에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="922d7fca7f2e145286ae58b5a3c707147df2c6ec" translate="yes" xml:space="preserve">
          <source>The route object is immutable. Every successful navigation will result in a fresh route object.</source>
          <target state="translated">경로 개체는 변경할 수 없습니다. 성공적으로 탐색 할 때마다 새로운 경로 객체가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="faa4bc3d702668e81503a764428cce9b603c0348" translate="yes" xml:space="preserve">
          <source>The router instance.</source>
          <target state="translated">라우터 인스턴스</target>
        </trans-unit>
        <trans-unit id="9fa790e3bac7002dcf74356b703b8218c4bd2fcc" translate="yes" xml:space="preserve">
          <source>The same rules apply for the &lt;code&gt;to&lt;/code&gt; property of the &lt;code&gt;router-link&lt;/code&gt; component.</source>
          <target state="translated">&lt;code&gt;router-link&lt;/code&gt; 구성 요소 의 &lt;code&gt;to&lt;/code&gt; 속성 에도 동일한 규칙이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e47ac241f5fdf160dc18347b31d6fb75fc4cab74" translate="yes" xml:space="preserve">
          <source>The second argument &lt;code&gt;errorCallback&lt;/code&gt; is only supported in 2.4+. It will be called when the initial route resolution runs into an error (e.g. failed to resolve an async component).</source>
          <target state="translated">두 번째 인수 &lt;code&gt;errorCallback&lt;/code&gt; 은 2.4 이상에서만 지원됩니다. 초기 경로 확인에 오류가 발생하면 (예 : 비동기 구성 요소를 해결하지 못한 경우) 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f6934271e865a3a534a429938bddac1f8100b037" translate="yes" xml:space="preserve">
          <source>The user will stay on the previous view while the resource is being fetched for the incoming view. It is therefore recommended to display a progress bar or some kind of indicator while the data is being fetched. If the data fetch fails, it's also necessary to display some kind of global warning message.</source>
          <target state="translated">들어오는보기에 대한 리소스를 가져 오는 동안 사용자는 이전보기를 유지합니다. 따라서 데이터를 가져 오는 동안 진행률 표시 줄이나 일종의 표시기를 표시하는 것이 좋습니다. 데이터 반입에 실패하면 일종의 전역 경고 메시지를 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="248801da37f4ea250f622f78c57cb1786b096bd9" translate="yes" xml:space="preserve">
          <source>Then you can achieve the layout above with this route configuration:</source>
          <target state="translated">그런 다음이 경로 구성으로 위의 레이아웃을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f584628b0b3a8bd05f38486c74f1e218c10c40f3" translate="yes" xml:space="preserve">
          <source>There is a caveat to this: Your server will no longer report 404 errors as all not-found paths now serve up your &lt;code&gt;index.html&lt;/code&gt; file. To get around the issue, you should implement a catch-all route within your Vue app to show a 404 page:</source>
          <target state="translated">이것에 대한주의 사항이 있습니다 : 모든 찾을 수없는 경로가 이제 &lt;code&gt;index.html&lt;/code&gt; 파일을 제공하므로 서버는 더 이상 404 오류를보고하지 않습니다 . 이 문제를 해결하려면 Vue 앱 내에서 모든 경로를 구현하여 404 페이지를 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="1894f2b9422130da979408591dea6e5ebe3fb654" translate="yes" xml:space="preserve">
          <source>Therefore, if you are already familiar with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/History_API&quot;&gt;Browser History APIs&lt;/a&gt;, manipulating history will be super easy with Vue Router.</source>
          <target state="translated">따라서 이미 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/History_API&quot;&gt;브라우저 히스토리 API에&lt;/a&gt; 익숙한 경우 Vue 라우터를 사용하면 히스토리 조작이 매우 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="3704ec0f80059da1d6bb85860c2e3810beffce8a" translate="yes" xml:space="preserve">
          <source>These guards have the exact same signature as global before guards.</source>
          <target state="translated">이 경비원은 전 세계 경비원과 동일한 서명을 가지고 있습니다</target>
        </trans-unit>
        <trans-unit id="f6ea9002e72e16715aa79b230300c2f7a726c70a" translate="yes" xml:space="preserve">
          <source>These properties are injected into every child component by passing the router instance to the root instance as the &lt;code&gt;router&lt;/code&gt; option.</source>
          <target state="translated">이러한 속성은 라우터 인스턴스를 &lt;code&gt;router&lt;/code&gt; 옵션 으로 루트 인스턴스에 전달하여 모든 하위 구성 요소에 주입됩니다 .</target>
        </trans-unit>
        <trans-unit id="d77b18ab4c745157e070e1084b72b6f83fc376c5" translate="yes" xml:space="preserve">
          <source>This allows you to use the component anywhere, which makes the component easier to reuse and test.</source>
          <target state="translated">따라서 어디서나 구성 요소를 사용할 수 있으므로 구성 요소를보다 쉽게 ​​재사용하고 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e322a7cbf99e7b1e44e569d75dface178a8d5435" translate="yes" xml:space="preserve">
          <source>This is the exact same object used programatically with &lt;code&gt;router.push()&lt;/code&gt;:</source>
          <target state="translated">이것은 &lt;code&gt;router.push()&lt;/code&gt; 와 함께 프로그래밍 방식으로 사용되는 것과 동일한 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="884da4433efc5d1a2324d6a582da71f5cc8a01cb" translate="yes" xml:space="preserve">
          <source>This is the method called internally when you click a &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt;, so clicking &lt;code&gt;&amp;lt;router-link :to=&quot;...&quot;&amp;gt;&lt;/code&gt; is the equivalent of calling &lt;code&gt;router.push(...)&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; 를 클릭 할 때 내부적으로 호출되는 메소드 이므로 &lt;code&gt;&amp;lt;router-link :to=&quot;...&quot;&amp;gt;&lt;/code&gt; 를 클릭하는 것은 &lt;code&gt;router.push(...)&lt;/code&gt; 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="451711dc47c7c6f517891ef01d44526a904aae93" translate="yes" xml:space="preserve">
          <source>This is useful in server-side rendering to ensure consistent output on both the server and the client.</source>
          <target state="translated">서버와 클라이언트 모두에서 일관된 출력을 보장하기 위해 서버 측 렌더링에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="35e6ca582a7ffb3b4a27b7a236e09e3c39fedba3" translate="yes" xml:space="preserve">
          <source>This method queues a callback to be called when the router has completed the initial navigation, which means it has resolved all async enter hooks and async components that are associated with the initial route.</source>
          <target state="translated">이 메소드는 라우터가 초기 탐색을 완료 할 때 호출 될 콜백을 대기합니다. 즉, 초기 경로와 연관된 모든 비동기 입력 후크 및 비동기 구성 요소를 해결했습니다.</target>
        </trans-unit>
        <trans-unit id="1ae2228ce7503030d2468a6c7972b2ad671c498c" translate="yes" xml:space="preserve">
          <source>This method takes a single integer as parameter that indicates by how many steps to go forwards or go backwards in the history stack, similar to &lt;code&gt;window.history.go(n)&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;window.history.go(n)&lt;/code&gt; 과 유사하게 히스토리 스택에서 앞으로 또는 뒤로 이동하는 단계 수를 표시하는 단일 정수를 매개 변수로 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="bbe5d8369ea8f01c36cb95214d652370c92181ae" translate="yes" xml:space="preserve">
          <source>This will simply make the page scroll to top for all route navigations.</source>
          <target state="translated">이렇게하면 모든 경로 탐색에서 페이지가 맨 위로 스크롤됩니다.</target>
        </trans-unit>
        <trans-unit id="2f198ff0bc070b0417c58edb952e48f722940e00" translate="yes" xml:space="preserve">
          <source>Throughout the docs, we will often use the &lt;code&gt;router&lt;/code&gt; instance. Keep in mind that &lt;code&gt;this.$router&lt;/code&gt; is exactly the same as using &lt;code&gt;router&lt;/code&gt;. The reason we use &lt;code&gt;this.$router&lt;/code&gt; is because we don't want to import the router in every single component that needs to manipulate routing.</source>
          <target state="translated">문서 전체에서 종종 &lt;code&gt;router&lt;/code&gt; 인스턴스를 사용합니다 . 있다는 사실을 숙지 &lt;code&gt;this.$router&lt;/code&gt; 정확히 사용하는 것과 같습니다 &lt;code&gt;router&lt;/code&gt; . 우리가 &lt;code&gt;this.$router&lt;/code&gt; 사용하는 이유는 라우팅을 조작해야하는 모든 단일 구성 요소에서 라우터를 가져오고 싶지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="14b124764e161f705cb1898a04f2d1f2ddffb40e" translate="yes" xml:space="preserve">
          <source>To decouple this component from the router use option &lt;code&gt;props&lt;/code&gt;:</source>
          <target state="translated">이 구성 요소를 라우터에서 분리하려면 옵션 &lt;code&gt;props&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="40a21d40bf366489567fe26e35bb7f8cdb0ea8a6" translate="yes" xml:space="preserve">
          <source>To get rid of the hash, we can use the router's &lt;strong&gt;history mode&lt;/strong&gt;, which leverages the &lt;code&gt;history.pushState&lt;/code&gt; API to achieve URL navigation without a page reload:</source>
          <target state="translated">해시를 없애기 위해 우리는 &lt;code&gt;history.pushState&lt;/code&gt; API를 활용하여 페이지를 다시로드하지 않고 URL 탐색을 수행 하는 라우터의 &lt;strong&gt;기록 모드를&lt;/strong&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f968e79f3bebc79ac6accd649e1b80b5c03e62a5" translate="yes" xml:space="preserve">
          <source>To link to a named route, you can pass an object to the &lt;code&gt;router-link&lt;/code&gt; component's &lt;code&gt;to&lt;/code&gt; prop:</source>
          <target state="translated">명명 된 경로에 링크를, 당신은에 개체를 전달할 수 있습니다 &lt;code&gt;router-link&lt;/code&gt; 구성 요소의 &lt;code&gt;to&lt;/code&gt; 소품 :</target>
        </trans-unit>
        <trans-unit id="8d2ac39b7f1eaeb6260ec962194235aea944d778" translate="yes" xml:space="preserve">
          <source>To navigate to a different URL, use &lt;code&gt;router.push&lt;/code&gt;. This method pushes a new entry into the history stack, so when the user clicks the browser back button they will be taken to the previous URL.</source>
          <target state="translated">다른 URL로 이동하려면 &lt;code&gt;router.push&lt;/code&gt; 를 사용 하십시오 . 이 메소드는 새 항목을 히스토리 스택으로 푸시하므로 사용자가 브라우저 뒤로 단추를 클릭하면 이전 URL로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="a814a90fe9d7eb161bb19c80c4d6453392d66e1c" translate="yes" xml:space="preserve">
          <source>To react to params changes in the same component, you can simply watch the &lt;code&gt;$route&lt;/code&gt; object:</source>
          <target state="translated">동일한 구성 요소의 매개 변수 변경 사항에 대응하기 위해 &lt;code&gt;$route&lt;/code&gt; 객체를 간단히 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="deb37c7b821c62ffa66d4da832925e5c201bf1f7" translate="yes" xml:space="preserve">
          <source>To render components into this nested outlet, we need to use the &lt;code&gt;children&lt;/code&gt; option in &lt;code&gt;VueRouter&lt;/code&gt; constructor config:</source>
          <target state="translated">이 중첩 된 콘센트로 컴포넌트를 렌더링하려면 &lt;code&gt;VueRouter&lt;/code&gt; 생성자 구성 에서 &lt;code&gt;children&lt;/code&gt; 옵션 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ab39260fea78bd5cdfde4b98ccfd4bc7bd02a43c" translate="yes" xml:space="preserve">
          <source>Transitions</source>
          <target state="translated">Transitions</target>
        </trans-unit>
        <trans-unit id="dd4444a66fb6e0b58af45061a5485da34a09bc09" translate="yes" xml:space="preserve">
          <source>Try to keep the &lt;code&gt;props&lt;/code&gt; function stateless, as it's only evaluated on route changes. Use a wrapper component if you need state to define the props, that way vue can react to state changes.</source>
          <target state="translated">경로 변경에 대해서만 평가 되므로 &lt;code&gt;props&lt;/code&gt; 기능을 상태 비 저장 상태 로 유지하십시오 . 소품을 정의하기 위해 상태가 필요한 경우 래퍼 구성 요소를 사용하면 vue가 상태 변경에 반응 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5855e1223cedf94ad0b6dc47625105b33a541e19" translate="yes" xml:space="preserve">
          <source>Type declaration for &lt;code&gt;RouteConfig&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;RouteConfig&lt;/code&gt; 의 유형 선언 :</target>
        </trans-unit>
        <trans-unit id="5751afb337c680e5e84da3851f1bca73258d946a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;$route&lt;/code&gt; in your component creates a tight coupling with the route which limits the flexibility of the component as it can only be used on certain URLs.</source>
          <target state="translated">사용 &lt;code&gt;$route&lt;/code&gt; 구성 요소로하는 것은에만 특정 URL에서 사용할 수있는 구성 요소의 유연성을 제한하는 경로에 꽉 커플 링을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="77d26897a43db04ce923013721681c90785d2c00" translate="yes" xml:space="preserve">
          <source>Very often we will need to map routes with the given pattern to the same component. For example we may have a &lt;code&gt;User&lt;/code&gt; component which should be rendered for all users but with different user IDs. In &lt;code&gt;vue-router&lt;/code&gt; we can use a dynamic segment in the path to achieve that:</source>
          <target state="translated">주어진 패턴을 가진 경로를 동일한 구성 요소에 매핑해야하는 경우가 종종 있습니다. 예를 들어 , 모든 사용자에 대해 렌더링해야하지만 다른 사용자 ID로 렌더링해야하는 &lt;code&gt;User&lt;/code&gt; 구성 요소 가있을 수 있습니다 . 에서는 &lt;code&gt;vue-router&lt;/code&gt; 우리가 동적 경로 세그먼트를 사용할 수를 달성하기 위해 :</target>
        </trans-unit>
        <trans-unit id="375cf55f91216e77b508717797d05fb22beefd2a" translate="yes" xml:space="preserve">
          <source>View transition effects powered by Vue.js' transition system</source>
          <target state="translated">Vue.js의 전환 시스템으로 구동되는 전환 효과보기</target>
        </trans-unit>
        <trans-unit id="bf53a6c36521f7bfb85181c1e488fc3bdefe2160" translate="yes" xml:space="preserve">
          <source>Vue Router</source>
          <target state="translated">Vue 라우터</target>
        </trans-unit>
        <trans-unit id="2ca5266265ed3aea3483c13e9476203377ffc810" translate="yes" xml:space="preserve">
          <source>Vue Router is the official router for &lt;a href=&quot;http://vuejs.org&quot;&gt;Vue.js&lt;/a&gt;. It deeply integrates with Vue.js core to make building Single Page Applications with Vue.js a breeze. Features include:</source>
          <target state="translated">Vue Router는 &lt;a href=&quot;http://vuejs.org&quot;&gt;Vue.js&lt;/a&gt; 의 공식 라우터입니다 . Vue.js 코어와 긴밀하게 통합되어 Vue.js로 단일 페이지 애플리케이션을 쉽게 구축 할 수 있습니다. 특징은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c6e38605a4a493c27c8a5d6ee9d645fba14a9a9a" translate="yes" xml:space="preserve">
          <source>We can also use &lt;a href=&quot;meta&quot;&gt;route meta fields&lt;/a&gt; to implement fine-grained scroll behavior control. Check out a full example &lt;a href=&quot;https://github.com/vuejs/vue-router/blob/dev/examples/scroll-behavior/app.js&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;meta&quot;&gt;경로 메타 필드&lt;/a&gt; 를 사용 하여 세분화 된 스크롤 동작 제어를 구현할 수도 있습니다 . 전체 예를 확인 &lt;a href=&quot;https://github.com/vuejs/vue-router/blob/dev/examples/scroll-behavior/app.js&quot;&gt;하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0352badf3e41913c3f3e9620f942cb5077ecbe2c" translate="yes" xml:space="preserve">
          <source>We will be using &lt;a href=&quot;https://github.com/lukehoban/es6features&quot;&gt;ES2015&lt;/a&gt; in the code samples in the guide.</source>
          <target state="translated">우리는 가이드의 코드 샘플에서 &lt;a href=&quot;https://github.com/lukehoban/es6features&quot;&gt;ES2015&lt;/a&gt; 를 사용할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="15b474187c7078074aa9ed72c9112ae1156c52a0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;props&lt;/code&gt; is an object, this will be set as the component props as-is. Useful for when the props are static.</source>
          <target state="translated">경우 &lt;code&gt;props&lt;/code&gt; 객체이며, 이것은 그대로 성분 소품으로 설정 될 것이다. 소품이 정적 일 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d2513a78af894fa1eaf54225e0979827f5c12641" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;props&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;route.params&lt;/code&gt; will be set as the component props.</source>
          <target state="translated">때 &lt;code&gt;props&lt;/code&gt; 설정되어 &lt;code&gt;true&lt;/code&gt; 의 &lt;code&gt;route.params&lt;/code&gt; 는 구성 요소 소품으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f8ccecf482f54b6d805c179314065a64f0b2d6b9" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;&amp;lt;router-view&amp;gt;&lt;/code&gt; has a name, it will render the component with the corresponding name in the matched route record's &lt;code&gt;components&lt;/code&gt; option. See &lt;a href=&quot;../guide/essentials/named-views&quot;&gt;Named Views&lt;/a&gt; for an example.</source>
          <target state="translated">때 &lt;code&gt;&amp;lt;router-view&amp;gt;&lt;/code&gt; 이름을 가지고, 그것은 일치하는 경로 레코드의에서 해당 이름을 가진 구성 요소 렌더링 &lt;code&gt;components&lt;/code&gt; 옵션을 선택합니다. 예를 들어 &lt;a href=&quot;../guide/essentials/named-views&quot;&gt;명명 된 뷰&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="370e9eb49967d3c0b483f412401dc604f33c8a96" translate="yes" xml:space="preserve">
          <source>When building apps with a bundler, the JavaScript bundle can become quite large, and thus affect the page load time. It would be more efficient if we can split each route's components into a separate chunk, and only load them when the route is visited.</source>
          <target state="translated">번 들러로 앱을 빌드 할 때 JavaScript 번들이 상당히 커져서 페이지로드 시간에 영향을 줄 수 있습니다. 각 경로의 구성 요소를 별도의 청크로 분할하고 경로를 방문 할 때만로드하는 것이 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="9a598ced62d3edd035797f59b8e377213dd56ff0" translate="yes" xml:space="preserve">
          <source>When creating the router instance, you can provide the &lt;code&gt;scrollBehavior&lt;/code&gt; function:</source>
          <target state="translated">라우터 인스턴스를 만들 때 &lt;code&gt;scrollBehavior&lt;/code&gt; 함수를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1e714346832e17cf65c274f305abc3b1e0ad285" translate="yes" xml:space="preserve">
          <source>When the URL is &lt;code&gt;/foo/bar&lt;/code&gt;, &lt;code&gt;$route.matched&lt;/code&gt; will be an Array containing both objects (cloned), in parent to child order.</source>
          <target state="translated">URL이 &lt;code&gt;/foo/bar&lt;/code&gt; 인 경우 &lt;code&gt;$route.matched&lt;/code&gt; 는 부모에서 자식 순서로 두 개체 (복제)를 포함하는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="5c2b30c6d5f6b6c51b2aeb5be92ba203bf029dab" translate="yes" xml:space="preserve">
          <source>When used with a module system, you must explicitly install the router via &lt;code&gt;Vue.use()&lt;/code&gt;:</source>
          <target state="translated">모듈 시스템과 함께 사용하는 경우 &lt;code&gt;Vue.use()&lt;/code&gt; 를 통해 라우터를 명시 적으로 설치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f93aaa65612ef60babed2aa9e05813e5850debcf" translate="yes" xml:space="preserve">
          <source>When using &lt;em&gt;asterisk&lt;/em&gt; routes, make sure to correctly order your routes so that &lt;em&gt;asterisk&lt;/em&gt; ones are at the end. The route &lt;code&gt;{ path: '*' }&lt;/code&gt; is usually used to 404 client side. If you are using &lt;em&gt;History mode&lt;/em&gt;, make sure to &lt;a href=&quot;history-mode&quot;&gt;correctly configure your server&lt;/a&gt; as well.</source>
          <target state="translated">&lt;em&gt;별표&lt;/em&gt; 경로를 사용 하는 경우 &lt;em&gt;별표&lt;/em&gt; 가 끝에 &lt;em&gt;오도록&lt;/em&gt; 경로를 올바르게 주문해야합니다 . 경로 &lt;code&gt;{ path: '*' }&lt;/code&gt; 는 일반적으로 404 클라이언트쪽에 사용됩니다. 당신이 사용하는 경우 &lt;em&gt;역사 모드&lt;/em&gt; 에 있는지 확인합니다 &lt;a href=&quot;history-mode&quot;&gt;올바르게 서버를 구성 할&lt;/a&gt; 뿐만 아니라.</target>
        </trans-unit>
        <trans-unit id="d09a113e124c947936cc9ed9cc36a71326cb4a50" translate="yes" xml:space="preserve">
          <source>When using an &lt;em&gt;asterisk&lt;/em&gt;, a param named &lt;code&gt;pathMatch&lt;/code&gt; is automatically added to &lt;code&gt;$route.params&lt;/code&gt;. It contains the rest of the url matched by the &lt;em&gt;asterisk&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;별표를&lt;/em&gt; 사용하면 &lt;code&gt;pathMatch&lt;/code&gt; 라는 매개 변수 가 &lt;code&gt;$route.params&lt;/code&gt; 자동으로 추가됩니다 . &lt;em&gt;별표&lt;/em&gt; 와 일치하는 나머지 URL이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="654d7b5318472e61b7ba9786645ee2ba53c15acf" translate="yes" xml:space="preserve">
          <source>When using client-side routing, we may want to scroll to top when navigating to a new route, or preserve the scrolling position of history entries just like real page reload does. &lt;code&gt;vue-router&lt;/code&gt; allows you to achieve these and even better, allows you to completely customize the scroll behavior on route navigation.</source>
          <target state="translated">클라이언트 쪽 라우팅을 사용할 때 새 경로로 탐색 할 때 맨 위로 스크롤하거나 실제 페이지 다시로드와 마찬가지로 기록 항목의 스크롤 위치를 유지하려고 할 수 있습니다. &lt;code&gt;vue-router&lt;/code&gt; 를 사용하면 경로 탐색에서 스크롤 동작을 완전히 사용자 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a60314411ff9cac02192073319927dc1ca2221dd" translate="yes" xml:space="preserve">
          <source>When using history mode, the URL will look &quot;normal,&quot; e.g. &lt;code&gt;http://oursite.com/user/id&lt;/code&gt;. Beautiful!</source>
          <target state="translated">히스토리 모드를 사용하는 경우 URL은 &quot;정상&quot;으로 표시됩니다 (예 : &lt;code&gt;http://oursite.com/user/id&lt;/code&gt; ) . 아름다운!</target>
        </trans-unit>
        <trans-unit id="5cc02aef8c3b391db93840118b90dec2b415d224" translate="yes" xml:space="preserve">
          <source>When using this approach, we navigate and render the incoming component immediately, and fetch data in the component's &lt;code&gt;created&lt;/code&gt; hook. It gives us the opportunity to display a loading state while the data is being fetched over the network, and we can also handle loading differently for each view.</source>
          <target state="translated">이 방법을 사용하면 들어오는 구성 요소를 즉시 탐색하고 렌더링하고 구성 요소가 &lt;code&gt;created&lt;/code&gt; 후크 에서 데이터를 가져옵니다 . 네트워크를 통해 데이터를 가져 오는 동안로드 상태를 표시 할 수있는 기회를 제공하며 각 뷰마다로드를 다르게 처리 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7cc117fab6263f7211081d22d65df80783ceb89" translate="yes" xml:space="preserve">
          <source>When you are using the &lt;code&gt;base&lt;/code&gt; option in HTML5 history mode, you don't need to include it in &lt;code&gt;to&lt;/code&gt; prop's URLs.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;base&lt;/code&gt; HTML5 역사 모드에서 옵션을, 당신은에 포함 할 필요가 없습니다 &lt;code&gt;to&lt;/code&gt; 소품의 URL이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4446df79d1370319467592e28dbebd4c3d82d6b8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;vue-router&lt;/code&gt;, it is very simple to express this relationship using nested route configurations.</source>
          <target state="translated">함께 &lt;code&gt;vue-router&lt;/code&gt; , 그 중첩 경로 구성을 사용하는이 관계를 표현하는 것은 매우 간단하다.</target>
        </trans-unit>
        <trans-unit id="d288e66c2b04e3ae98f5a06ccc29b5c1455471d4" translate="yes" xml:space="preserve">
          <source>With this approach we fetch the data before actually navigating to the new route. We can perform the data fetching in the &lt;code&gt;beforeRouteEnter&lt;/code&gt; guard in the incoming component, and only call &lt;code&gt;next&lt;/code&gt; when the fetch is complete:</source>
          <target state="translated">이 방법을 사용하면 실제로 새 경로로 이동하기 전에 데이터를 가져옵니다. 수신 컴포넌트 의 &lt;code&gt;beforeRouteEnter&lt;/code&gt; 가드에서 데이터 페치를 수행 할 수 있으며 페치가 완료된 후에 만 &lt;code&gt;next&lt;/code&gt; 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9a994c42f35fd2e9f8464db0415b1e50c5c315d" translate="yes" xml:space="preserve">
          <source>You can also check out this example &lt;a href=&quot;https://jsfiddle.net/yyx990803/xgrjzsup/&quot;&gt;live&lt;/a&gt;.</source>
          <target state="translated">이 예제를 &lt;a href=&quot;https://jsfiddle.net/yyx990803/xgrjzsup/&quot;&gt;라이브로&lt;/a&gt; 확인할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c2e815d06584fa57837db82d17e57326a9d3123d" translate="yes" xml:space="preserve">
          <source>You can also register global after hooks, however unlike guards, these hooks do not get a &lt;code&gt;next&lt;/code&gt; function and cannot affect the navigation:</source>
          <target state="translated">후크 후 글로벌을 등록 할 수도 있지만 가드와 달리이 후크는 &lt;code&gt;next&lt;/code&gt; 기능을 수행하지 않으며 탐색에 영향을 줄 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dceb3c719a2affde3934cc32a255fb6e8bac211f" translate="yes" xml:space="preserve">
          <source>You can also return a Promise that resolves to the desired position descriptor:</source>
          <target state="translated">원하는 위치 설명 자로 해석되는 약속을 반환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="87372b6a91ff376092ecc00b583afd4e75bf1fef" translate="yes" xml:space="preserve">
          <source>You can check out a live example &lt;a href=&quot;https://jsfiddle.net/yyx990803/4xfa2f19/&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://jsfiddle.net/yyx990803/4xfa2f19/&quot;&gt;여기서&lt;/a&gt; 실제 예를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="52a45f015af3c7e89ae621b8c057c43ce893c17a" translate="yes" xml:space="preserve">
          <source>You can create a function that returns props. This allows you to cast parameters into other types, combine static values with route-based values, etc.</source>
          <target state="translated">소품을 반환하는 함수를 만들 수 있습니다. 이를 통해 매개 변수를 다른 유형으로 캐스트하고 정적 값을 라우트 기반 값과 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1adba09890f98c1b3ec7486a6a2350042ffe55e" translate="yes" xml:space="preserve">
          <source>You can define &lt;code&gt;beforeEnter&lt;/code&gt; guards directly on a route's configuration object:</source>
          <target state="translated">route의 구성 객체에서 &lt;code&gt;beforeEnter&lt;/code&gt; 가드를 직접 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="54f861ad07b617f0765fc567107e9e603992caea" translate="yes" xml:space="preserve">
          <source>You can have multiple dynamic segments in the same route, and they will map to corresponding fields on &lt;code&gt;$route.params&lt;/code&gt;. Examples:</source>
          <target state="translated">동일한 경로에 여러 동적 세그먼트를 가질 수 있으며 &lt;code&gt;$route.params&lt;/code&gt; 해당 필드에 매핑됩니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="91c9c8c9c91650676c169a76575a2310ebc323bc" translate="yes" xml:space="preserve">
          <source>You can include a &lt;code&gt;meta&lt;/code&gt; field when defining a route:</source>
          <target state="translated">경로를 정의 할 때 &lt;code&gt;meta&lt;/code&gt; 필드를 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dcaa153c3e42e4b62970046f5ffaf744b8c7954d" translate="yes" xml:space="preserve">
          <source>You can register a global guard with &lt;code&gt;router.beforeResolve&lt;/code&gt;. This is similar to &lt;code&gt;router.beforeEach&lt;/code&gt;, with the difference that resolve guards will be called right before the navigation is confirmed, &lt;strong&gt;after all in-component guards and async route components are resolved&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;router.beforeResolve&lt;/code&gt; 로 전역 가드를 등록 할 수 있습니다 . 이것은 &lt;code&gt;router.beforeEach&lt;/code&gt; 와 유사하며 &lt;strong&gt;모든 컴포넌트 내 가드 및 비동기 라우트 컴포넌트가 해결 된 후&lt;/strong&gt; 탐색이 확인되기 직전에 확인 가드가 호출된다는 차이점이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="91d70ca0e20247f409fa0d7f3606c443e7d0d92e" translate="yes" xml:space="preserve">
          <source>You can register global before guards using &lt;code&gt;router.beforeEach&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;router.beforeEach&lt;/code&gt; 를 사용하여 경비원 전에 전역을 등록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="360fc60f946b0e1fb46441c21ec094cefc382a47" translate="yes" xml:space="preserve">
          <source>You don't need to do this when using global script tags.</source>
          <target state="translated">전역 스크립트 태그를 사용할 때는이 작업을 수행 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="fdc0308691390af461887e831e2f5799b218ef4e" translate="yes" xml:space="preserve">
          <source>You may have noticed that &lt;code&gt;router.push&lt;/code&gt;, &lt;code&gt;router.replace&lt;/code&gt; and &lt;code&gt;router.go&lt;/code&gt; are counterparts of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/History&quot;&gt;&lt;code&gt;window.history.pushState&lt;/code&gt;, &lt;code&gt;window.history.replaceState&lt;/code&gt; and &lt;code&gt;window.history.go&lt;/code&gt;&lt;/a&gt;, and they do imitate the &lt;code&gt;window.history&lt;/code&gt; APIs.</source>
          <target state="translated">당신은 것을 눈치 챘을 수도 &lt;code&gt;router.push&lt;/code&gt; , &lt;code&gt;router.replace&lt;/code&gt; 및 &lt;code&gt;router.go&lt;/code&gt; 이 의 대응이다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/History&quot;&gt; &lt;code&gt;window.history.pushState&lt;/code&gt; , &lt;code&gt;window.history.replaceState&lt;/code&gt; 및 &lt;code&gt;window.history.go&lt;/code&gt; 는&lt;/a&gt; , 그들은 모방 할 &lt;code&gt;window.history&lt;/code&gt; 실행 API를.</target>
        </trans-unit>
        <trans-unit id="42001955a4630b11faa63d03b789c8381c402c78" translate="yes" xml:space="preserve">
          <source>You will have to clone directly from GitHub and build &lt;code&gt;vue-router&lt;/code&gt; yourself if you want to use the latest dev build.</source>
          <target state="translated">최신 개발자 빌드를 사용하려면 GitHub에서 직접 복제하고 &lt;code&gt;vue-router&lt;/code&gt; 를 직접 빌드해야합니다.</target>
        </trans-unit>
        <trans-unit id="22c922a7722e225567a4b9082890a1c0a2a34dc0" translate="yes" xml:space="preserve">
          <source>active-class</source>
          <target state="translated">active-class</target>
        </trans-unit>
        <trans-unit id="db43bff34c78044870bc6b1ae2aa16902bb1bb8a" translate="yes" xml:space="preserve">
          <source>append</source>
          <target state="translated">append</target>
        </trans-unit>
        <trans-unit id="e34aac5c6849fdb3570b660a5e774a81c616a4a9" translate="yes" xml:space="preserve">
          <source>available values: &lt;code&gt;&quot;hash&quot; | &quot;history&quot; | &quot;abstract&quot;&lt;/code&gt;</source>
          <target state="translated">사용 가능한 값 : &lt;code&gt;&quot;hash&quot; | &quot;history&quot; | &quot;abstract&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1405df66cbe219b0bf6355bc3d60361a8376b6b4" translate="yes" xml:space="preserve">
          <source>base</source>
          <target state="translated">base</target>
        </trans-unit>
        <trans-unit id="99b10c37b942ce1bc4a061b17674e700284477fc" translate="yes" xml:space="preserve">
          <source>default: &lt;code&gt;&quot;/&quot;&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;&quot;/&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c5b86475c5ce19d01e0cac89c9799c7283c7d817" translate="yes" xml:space="preserve">
          <source>default: &lt;code&gt;&quot;a&quot;&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;&quot;a&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="32d04dbda316ea929438d99dc5deb9bfed79c294" translate="yes" xml:space="preserve">
          <source>default: &lt;code&gt;&quot;default&quot;&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;&quot;default&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bc7e54a97eb660f817218b1cedc02e8d9e783123" translate="yes" xml:space="preserve">
          <source>default: &lt;code&gt;&quot;hash&quot; (in browser) | &quot;abstract&quot; (in Node.js)&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;&quot;hash&quot; (in browser) | &quot;abstract&quot; (in Node.js)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f018a79ddcbe226a0fa236f8257a7f90261a2b33" translate="yes" xml:space="preserve">
          <source>default: &lt;code&gt;&quot;router-link-active&quot;&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;&quot;router-link-active&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a09a446c9b3680978568555d5a02876f163d4278" translate="yes" xml:space="preserve">
          <source>default: &lt;code&gt;&quot;router-link-exact-active&quot;&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;&quot;router-link-exact-active&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1c5e5af919de42d74014a2fd8d7af6f3238aba66" translate="yes" xml:space="preserve">
          <source>default: &lt;code&gt;'click'&lt;/code&gt;</source>
          <target state="translated">기본 : &lt;code&gt;'click'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b853518a7253a67751993712323af2afe8d26a75" translate="yes" xml:space="preserve">
          <source>default: &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a6fd6e8dec26869827df393505cdc6fbe0e5b3f8" translate="yes" xml:space="preserve">
          <source>default: &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5006ed0248a019713b762563076292379daf07b4" translate="yes" xml:space="preserve">
          <source>event</source>
          <target state="translated">event</target>
        </trans-unit>
        <trans-unit id="b55e22fe7830e8fe49f48f834b913ef8618f0521" translate="yes" xml:space="preserve">
          <source>exact</source>
          <target state="translated">exact</target>
        </trans-unit>
        <trans-unit id="de8dc393f32ea87cda6843c8979f8bc15f115a5a" translate="yes" xml:space="preserve">
          <source>exact-active-class</source>
          <target state="translated">exact-active-class</target>
        </trans-unit>
        <trans-unit id="5d288ad264adcc2a70039c116c397be72c30fe76" translate="yes" xml:space="preserve">
          <source>fallback</source>
          <target state="translated">fallback</target>
        </trans-unit>
        <trans-unit id="4df0e6a21ec6a23a3721f71c0e947871720c309f" translate="yes" xml:space="preserve">
          <source>if you are using Babel, you will need to add the &lt;a href=&quot;https://babeljs.io/docs/plugins/syntax-dynamic-import/&quot;&gt;syntax-dynamic-import&lt;/a&gt; plugin so that Babel can properly parse the syntax.</source>
          <target state="translated">Babel을 사용하는 경우 Babel이 &lt;a href=&quot;https://babeljs.io/docs/plugins/syntax-dynamic-import/&quot;&gt;구문&lt;/a&gt; 을 올바르게 구문 분석 할 수 있도록 구문 동적 가져 오기 플러그인 을 추가해야 합니다.</target>
        </trans-unit>
        <trans-unit id="d175db7336b4deaf3b1a69b2f762ee3bed67cb20" translate="yes" xml:space="preserve">
          <source>linkActiveClass</source>
          <target state="translated">linkActiveClass</target>
        </trans-unit>
        <trans-unit id="e41ac53cf69868bc1c3a7ee6ef65c73237c62040" translate="yes" xml:space="preserve">
          <source>linkExactActiveClass</source>
          <target state="translated">linkExactActiveClass</target>
        </trans-unit>
        <trans-unit id="89f41168b29a18bea64d6f6cdc32335cd79cb41b" translate="yes" xml:space="preserve">
          <source>matched path</source>
          <target state="translated">일치하는 경로</target>
        </trans-unit>
        <trans-unit id="e78fe7049341b36116d8054f5a3e00d01f245fcc" translate="yes" xml:space="preserve">
          <source>mode</source>
          <target state="translated">mode</target>
        </trans-unit>
        <trans-unit id="6ae999552a0d2dca14d62e2bc8b764d377b1dd6c" translate="yes" xml:space="preserve">
          <source>name</source>
          <target state="translated">name</target>
        </trans-unit>
        <trans-unit id="58a3ed6f2965252c6ac4957d95f7a3bdfca47101" translate="yes" xml:space="preserve">
          <source>nginx</source>
          <target state="translated">nginx</target>
        </trans-unit>
        <trans-unit id="660051d15ac64cec704cfacca2c2eab008f657e8" translate="yes" xml:space="preserve">
          <source>npm</source>
          <target state="translated">npm</target>
        </trans-unit>
        <trans-unit id="953c0c236f2356b54ee370e347c14c3865381884" translate="yes" xml:space="preserve">
          <source>parseQuery / stringifyQuery</source>
          <target state="translated">parseQuery / stringifyQuery</target>
        </trans-unit>
        <trans-unit id="91cc2e927b3bfb1d4477b744f7c70221ddb86ef1" translate="yes" xml:space="preserve">
          <source>pattern</source>
          <target state="translated">pattern</target>
        </trans-unit>
        <trans-unit id="3cacc7bfac0a382c669a884c953d0401a689785d" translate="yes" xml:space="preserve">
          <source>replace</source>
          <target state="translated">replace</target>
        </trans-unit>
        <trans-unit id="1a77d416224cbbe77a439cfd6c198030cb522872" translate="yes" xml:space="preserve">
          <source>required</source>
          <target state="translated">required</target>
        </trans-unit>
        <trans-unit id="2725c5af8e0788b3abc52d1ceb4ac9ce7f72148a" translate="yes" xml:space="preserve">
          <source>router.addRoutes</source>
          <target state="translated">router.addRoutes</target>
        </trans-unit>
        <trans-unit id="3f47556d256c26578295cea37371201686604978" translate="yes" xml:space="preserve">
          <source>router.addRoutes()</source>
          <target state="translated">router.addRoutes()</target>
        </trans-unit>
        <trans-unit id="2662e68dc8326e33c695ebbf8d9188d9c4a7ba17" translate="yes" xml:space="preserve">
          <source>router.afterEach</source>
          <target state="translated">router.afterEach</target>
        </trans-unit>
        <trans-unit id="4a0c91379e8288b021c3d98a0217fa0a56e46f9e" translate="yes" xml:space="preserve">
          <source>router.afterEach()</source>
          <target state="translated">router.afterEach()</target>
        </trans-unit>
        <trans-unit id="a2236cfcb1f47bd17fb9604a1695bc4698b4d938" translate="yes" xml:space="preserve">
          <source>router.app</source>
          <target state="translated">router.app</target>
        </trans-unit>
        <trans-unit id="741805ccbc5038382908b2fbd5ca94662306229d" translate="yes" xml:space="preserve">
          <source>router.back</source>
          <target state="translated">router.back</target>
        </trans-unit>
        <trans-unit id="455210ecf6a0e738bbd8e8d0fd5d2d9228d45d3b" translate="yes" xml:space="preserve">
          <source>router.back()</source>
          <target state="translated">router.back()</target>
        </trans-unit>
        <trans-unit id="8e4d0e56bbcb0b0c86b8b861ee370213135e6c93" translate="yes" xml:space="preserve">
          <source>router.beforeEach</source>
          <target state="translated">router.beforeEach</target>
        </trans-unit>
        <trans-unit id="1e0edd04aad9408325c3ba1792733b9609c32bba" translate="yes" xml:space="preserve">
          <source>router.beforeEach()</source>
          <target state="translated">router.beforeEach()</target>
        </trans-unit>
        <trans-unit id="d0ee0d6ea72bf05a3b8a32cba7d50a765c8272fe" translate="yes" xml:space="preserve">
          <source>router.beforeResolve</source>
          <target state="translated">router.beforeResolve</target>
        </trans-unit>
        <trans-unit id="f11efdb46222361f366683bc92f8239a1c6b9a31" translate="yes" xml:space="preserve">
          <source>router.beforeResolve()</source>
          <target state="translated">router.beforeResolve()</target>
        </trans-unit>
        <trans-unit id="b9b484c1b0caf585a0c4c0133a7317ac37c1f231" translate="yes" xml:space="preserve">
          <source>router.currentRoute</source>
          <target state="translated">router.currentRoute</target>
        </trans-unit>
        <trans-unit id="e0bb03bcd4c4a283cbf56d64937ef2f95c19def3" translate="yes" xml:space="preserve">
          <source>router.forward</source>
          <target state="translated">router.forward</target>
        </trans-unit>
        <trans-unit id="0a3c17512db6aba88397681690527ee9ad857caa" translate="yes" xml:space="preserve">
          <source>router.forward()</source>
          <target state="translated">router.forward()</target>
        </trans-unit>
        <trans-unit id="3ae47561293b9dfeb20a96309074a684f8f6422f" translate="yes" xml:space="preserve">
          <source>router.getMatchedComponents</source>
          <target state="translated">router.getMatchedComponents</target>
        </trans-unit>
        <trans-unit id="cb1490dd1ae07e5608556fe5569586f268752565" translate="yes" xml:space="preserve">
          <source>router.getMatchedComponents()</source>
          <target state="translated">router.getMatchedComponents()</target>
        </trans-unit>
        <trans-unit id="3a9bd917f6142f0ebac12aa7629558793b8eed68" translate="yes" xml:space="preserve">
          <source>router.go</source>
          <target state="translated">router.go</target>
        </trans-unit>
        <trans-unit id="93d836104a643f1ad3e29a704ad19d57778d799a" translate="yes" xml:space="preserve">
          <source>router.go()</source>
          <target state="translated">router.go()</target>
        </trans-unit>
        <trans-unit id="4b98e5dc820e27eeda1bd4a395a5576fc48805ad" translate="yes" xml:space="preserve">
          <source>router.mode</source>
          <target state="translated">router.mode</target>
        </trans-unit>
        <trans-unit id="ac96d346f75b0e8019c8407448728adc4a49768f" translate="yes" xml:space="preserve">
          <source>router.onError</source>
          <target state="translated">router.onError</target>
        </trans-unit>
        <trans-unit id="16e71d29e1cd6a61478e34cd1ee243d8e0f50b06" translate="yes" xml:space="preserve">
          <source>router.onError()</source>
          <target state="translated">router.onError()</target>
        </trans-unit>
        <trans-unit id="69cc793b354e98df015e979bf45e960883e135f6" translate="yes" xml:space="preserve">
          <source>router.onReady</source>
          <target state="translated">router.onReady</target>
        </trans-unit>
        <trans-unit id="747e333d66e77593b0042df265ee53b603de3ac8" translate="yes" xml:space="preserve">
          <source>router.onReady()</source>
          <target state="translated">router.onReady()</target>
        </trans-unit>
        <trans-unit id="8bf8844bb164c8ded182c7ca26c14cb206d03917" translate="yes" xml:space="preserve">
          <source>router.push</source>
          <target state="translated">router.push</target>
        </trans-unit>
        <trans-unit id="80f54f4dd6b09a95476a59b10a3041938dd2086f" translate="yes" xml:space="preserve">
          <source>router.push()</source>
          <target state="translated">router.push()</target>
        </trans-unit>
        <trans-unit id="a83f0578ae911969f306f03252e5bdcc36fd43db" translate="yes" xml:space="preserve">
          <source>router.replace</source>
          <target state="translated">router.replace</target>
        </trans-unit>
        <trans-unit id="66c9650ee951a77299972461032c18f207e18399" translate="yes" xml:space="preserve">
          <source>router.replace()</source>
          <target state="translated">router.replace()</target>
        </trans-unit>
        <trans-unit id="66503abbc72af3e9eee4cfbda80393ae76ff207e" translate="yes" xml:space="preserve">
          <source>router.resolve</source>
          <target state="translated">router.resolve</target>
        </trans-unit>
        <trans-unit id="b2730b57953abee3878f9caceb52c8664aa8f340" translate="yes" xml:space="preserve">
          <source>router.resolve()</source>
          <target state="translated">router.resolve()</target>
        </trans-unit>
        <trans-unit id="9e2c05b0ce117ad468d9a4e577e7ae96c67e4bb4" translate="yes" xml:space="preserve">
          <source>routes</source>
          <target state="translated">routes</target>
        </trans-unit>
        <trans-unit id="7dad025296b38526ffa33e53caf5c3ec238d3648" translate="yes" xml:space="preserve">
          <source>scrollBehavior</source>
          <target state="translated">scrollBehavior</target>
        </trans-unit>
        <trans-unit id="5e9b60f69165f32f8930843ca718e10fdee30c52" translate="yes" xml:space="preserve">
          <source>tag</source>
          <target state="translated">tag</target>
        </trans-unit>
        <trans-unit id="4374aaee247fb237ce6c97d5c8d64bbe474d16de" translate="yes" xml:space="preserve">
          <source>to</source>
          <target state="translated">to</target>
        </trans-unit>
        <trans-unit id="f98b78095dd7b6a2ea54a7d58d1e5ed84b325054" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;Array&amp;lt;RouteConfig&amp;gt;&lt;/code&gt;</source>
          <target state="translated">유형 : &lt;code&gt;Array&amp;lt;RouteConfig&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a339ba8c08de47ad40266bde7e4690567b147b9" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;Array&amp;lt;RouteRecord&amp;gt;&lt;/code&gt;</source>
          <target state="translated">유형 : &lt;code&gt;Array&amp;lt;RouteRecord&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="39142a28070b085653427668d9c37ef93acf9c11" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;Function&lt;/code&gt;</source>
          <target state="translated">유형 : &lt;code&gt;Function&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="459de9ab6bbb747b424aa86431b8923f3e3cebed" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;Object&lt;/code&gt;</source>
          <target state="translated">유형 : &lt;code&gt;Object&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e49ccf3e90dd6c142dcb29c663e37d4f589ea818" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;Route&lt;/code&gt;</source>
          <target state="translated">유형 : &lt;code&gt;Route&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96e3dc3437eced554868a86f2e58a2a356edfc3c" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;Vue instance&lt;/code&gt;</source>
          <target state="translated">유형 : &lt;code&gt;Vue instance&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e0800374f05dce7addc4f97d5a68d2e7b35b3ef4" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;boolean&lt;/code&gt;</source>
          <target state="translated">유형 : &lt;code&gt;boolean&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f26b9b47c7d30af061500feb8871343139f93178" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;string | Array&amp;lt;string&amp;gt;&lt;/code&gt;</source>
          <target state="translated">유형 : &lt;code&gt;string | Array&amp;lt;string&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="15860fc2382d6e91f8672b59a2f4aaf28b7c0c06" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;string | Location&lt;/code&gt;</source>
          <target state="translated">유형 : &lt;code&gt;string | Location&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e994060b7624ea12312bbedbc8627d4c31002cf" translate="yes" xml:space="preserve">
          <source>type: &lt;code&gt;string&lt;/code&gt;</source>
          <target state="translated">유형 : &lt;code&gt;string&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="285a211f0f9d5799f4ec4b2694fc5040a7a120fc" translate="yes" xml:space="preserve">
          <source>v-slot</source>
          <target state="translated">v-slot</target>
        </trans-unit>
        <trans-unit id="33d0fd54fb3557d5daf7d54b93d487b1185643b4" translate="yes" xml:space="preserve">
          <source>webpack will group any async module with the same chunk name into the same async chunk.</source>
          <target state="translated">webpack은 동일한 청크 이름을 가진 모든 비동기 모듈을 동일한 비동기 청크로 그룹화합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
