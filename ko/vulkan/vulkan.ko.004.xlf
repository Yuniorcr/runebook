<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="vulkan">
    <body>
      <group id="vulkan">
        <trans-unit id="2afdc9f5f9839a580986a1592d2ebc7c1dc70447" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; contains the &lt;code&gt;VK_PIPELINE_CREATE_DERIVATIVE_BIT&lt;/code&gt; flag, and &lt;code&gt;basePipelineIndex&lt;/code&gt; is -1, &lt;code&gt;basePipelineHandle&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a valid handle to a compute &lt;code&gt;VkPipeline&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;flags&lt;/code&gt; 포함 &lt;code&gt;VK_PIPELINE_CREATE_DERIVATIVE_BIT&lt;/code&gt; 의 깃발을, 그리고 &lt;code&gt;basePipelineIndex&lt;/code&gt; 는 -1, &lt;code&gt;basePipelineHandle&lt;/code&gt; 는&lt;strong&gt;해야한다&lt;/strong&gt; 컴퓨에 대한 유효한 핸들이 될 &lt;code&gt;VkPipeline&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0bdd32fc21b0bc9b8c72f5a2b27c3cc7ba2f9f53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; contains the &lt;code&gt;VK_PIPELINE_CREATE_DERIVATIVE_BIT&lt;/code&gt; flag, and &lt;code&gt;basePipelineIndex&lt;/code&gt; is -1, &lt;code&gt;basePipelineHandle&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a valid handle to a graphics &lt;code&gt;VkPipeline&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;flags&lt;/code&gt; 포함 &lt;code&gt;VK_PIPELINE_CREATE_DERIVATIVE_BIT&lt;/code&gt; 의 깃발을, 그리고 &lt;code&gt;basePipelineIndex&lt;/code&gt; 는 -1, &lt;code&gt;basePipelineHandle&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 그래픽에 대한 유효한 핸들이 될 &lt;code&gt;VkPipeline&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb441c682a989edd6b4a9fd7d3157ec839be563c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; contains the &lt;code&gt;VK_PIPELINE_CREATE_DERIVATIVE_BIT&lt;/code&gt; flag, and &lt;code&gt;basePipelineIndex&lt;/code&gt; is not -1, &lt;code&gt;basePipelineHandle&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE&lt;/a&gt;</source>
          <target state="translated">경우 &lt;code&gt;flags&lt;/code&gt; 포함 &lt;code&gt;VK_PIPELINE_CREATE_DERIVATIVE_BIT&lt;/code&gt; 의 깃발을, 그리고 &lt;code&gt;basePipelineIndex&lt;/code&gt; 이 아닌 -1, &lt;code&gt;basePipelineHandle&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b1fe5e52cff6a537adc020be1195120d8cf619b2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; does not contain &lt;code&gt;VK_SPARSE_MEMORY_BIND_METADATA_BIT&lt;/code&gt;, the binding range &lt;strong&gt;must&lt;/strong&gt; be within the range [0,&lt;a href=&quot;#VkMemoryRequirements&quot;&gt;VkMemoryRequirements&lt;/a&gt;::&lt;code&gt;size&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;code&gt;flags&lt;/code&gt; 가 포함되어 있지 않습니다 &lt;code&gt;VK_SPARSE_MEMORY_BIND_METADATA_BIT&lt;/code&gt; 을 , 바인딩 범위가 &lt;strong&gt;있어야합니다&lt;/strong&gt; 범위는 [0, 이내 &lt;a href=&quot;#VkMemoryRequirements&quot;&gt;VkMemoryRequirements&lt;/a&gt; :: &lt;code&gt;size&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="94268edcaf668999c8167f59b7ca4f77eb80f457" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; includes &lt;code&gt;VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT&lt;/code&gt;, then the attachment is treated as if it shares physical memory with another attachment in the same render pass. This information limits the ability of the implementation to reorder certain operations (like layout transitions and the &lt;code&gt;loadOp&lt;/code&gt;) such that it is not improperly reordered against other uses of the same physical memory via a different attachment. This is described in more detail below.</source>
          <target state="translated">경우 &lt;code&gt;flags&lt;/code&gt; 포함 &lt;code&gt;VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT&lt;/code&gt; 을 다음 첨부가 동일한 렌더링 패스에서 다른 첨부 물리적 메모리를 공유하는 경우로 취급된다. 이 정보는 구현이 특정 작업 (예 : 레이아웃 전환 및 &lt;code&gt;loadOp&lt;/code&gt; ) 을 재정렬하는 기능을 제한하여 다른 첨부 파일을 통해 동일한 물리적 메모리의 다른 사용에 대해 잘못 정렬되지 않도록합니다. 이에 대해서는 아래에서 더 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d6b10dd68a3df228657883a5b0e34a7a202190bc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format&lt;/code&gt; is a block-compression format, then buffers &lt;strong&gt;must&lt;/strong&gt; not support any features for the format.</source>
          <target state="translated">경우 &lt;code&gt;format&lt;/code&gt; 블록 압축 형식 다음 버퍼 &lt;strong&gt;해야&lt;/strong&gt; 포맷에 대한 모든 기능을 지원하지.</target>
        </trans-unit>
        <trans-unit id="6526e4fca135f9aa0c3be198a5e40bb1e4e29a87" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format&lt;/code&gt; is not a supported image format, or if the combination of &lt;code&gt;format&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;tiling&lt;/code&gt;, &lt;code&gt;usage&lt;/code&gt;, and &lt;code&gt;flags&lt;/code&gt; is not supported for images, then &lt;code&gt;vkGetPhysicalDeviceImageFormatProperties&lt;/code&gt; returns &lt;code&gt;VK_ERROR_FORMAT_NOT_SUPPORTED&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;format&lt;/code&gt; 지원되는 이미지 형식이 아니거나 조합하는 경우 &lt;code&gt;format&lt;/code&gt; , &lt;code&gt;type&lt;/code&gt; , &lt;code&gt;tiling&lt;/code&gt; , &lt;code&gt;usage&lt;/code&gt; 및 &lt;code&gt;flags&lt;/code&gt; 이미지, 다음이 지원되지 않습니다 &lt;code&gt;vkGetPhysicalDeviceImageFormatProperties&lt;/code&gt; 의 반환 &lt;code&gt;VK_ERROR_FORMAT_NOT_SUPPORTED&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87d47979360797f9db0a28ad75085364eb22255a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;framebuffer&lt;/code&gt; is a valid handle, it &lt;strong&gt;must&lt;/strong&gt; have been created, allocated, or retrieved from &lt;code&gt;device&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;framebuffer&lt;/code&gt; 유효한 핸들이며, 그것은 &lt;strong&gt;해야한다&lt;/strong&gt; , 생성 할당, 또는에서 검색 한 &lt;code&gt;device&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="36ec1f3989f7b905b99cb3ce6e3bea90bec5bd34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;framebuffer&lt;/code&gt; is not &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE&lt;/a&gt;, &lt;code&gt;framebuffer&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a valid &lt;code&gt;VkFramebuffer&lt;/code&gt; handle</source>
          <target state="translated">경우 &lt;code&gt;framebuffer&lt;/code&gt; 없는 &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE&lt;/a&gt; , &lt;code&gt;framebuffer&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 유효한 될 &lt;code&gt;VkFramebuffer&lt;/code&gt; 의 핸들</target>
        </trans-unit>
        <trans-unit id="4d662441c88392b2f9b891edcc8482065a17ba6d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;image&lt;/code&gt; has a depth/stencil format with both depth and stencil components, then &lt;code&gt;aspectMask&lt;/code&gt; member of &lt;code&gt;subresourceRange&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; include both &lt;code&gt;VK_IMAGE_ASPECT_DEPTH_BIT&lt;/code&gt; and &lt;code&gt;VK_IMAGE_ASPECT_STENCIL_BIT&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;image&lt;/code&gt; 깊이 및 스텐실 구성 요소가 모두 포함 된 깊이 / 스텐실 형식이있는 경우 &lt;code&gt;subresourceRange&lt;/code&gt; 의 &lt;code&gt;aspectMask&lt;/code&gt; 멤버는 &lt;code&gt;VK_IMAGE_ASPECT_DEPTH_BIT&lt;/code&gt; 및 &lt;code&gt;VK_IMAGE_ASPECT_STENCIL_BIT&lt;/code&gt; 를 모두 포함 &lt;strong&gt;해야합니다.&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="22a602a4ba75b76cd3e93f68666c62c4d78df7e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;image&lt;/code&gt; is a valid handle, it &lt;strong&gt;must&lt;/strong&gt; have been created, allocated, or retrieved from &lt;code&gt;device&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;image&lt;/code&gt; 가 유효한 핸들 인 경우 이미지 를 &lt;code&gt;device&lt;/code&gt; 에서 생성, 할당 또는 검색 &lt;strong&gt;해야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c2c5b908c4bc4f73a0d295ec52c14c9ac235a87f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;image&lt;/code&gt; is non-sparse then it &lt;strong&gt;must&lt;/strong&gt; be bound completely and contiguously to a single &lt;code&gt;VkDeviceMemory&lt;/code&gt; object</source>
          <target state="translated">&lt;code&gt;image&lt;/code&gt; 가 희소하지 않은 경우 단일 &lt;code&gt;VkDeviceMemory&lt;/code&gt; 객체에 완전하고 연속적으로 바인딩 &lt;strong&gt;되어야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="709ff55637659c48eee8c92c6059c88f437a777c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;image&lt;/code&gt; is not &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE&lt;/a&gt;, &lt;code&gt;image&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a valid &lt;code&gt;VkImage&lt;/code&gt; handle</source>
          <target state="translated">경우 &lt;code&gt;image&lt;/code&gt; 아닌 &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE는&lt;/a&gt; , &lt;code&gt;image&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 유효한 될 &lt;code&gt;VkImage&lt;/code&gt; 의 핸들</target>
        </trans-unit>
        <trans-unit id="cd3a0342165216859b73c0fa40fd15976b6b367f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;image&lt;/code&gt; was created with &lt;code&gt;VK_IMAGE_TILING_LINEAR&lt;/code&gt; and &lt;code&gt;usage&lt;/code&gt; contains &lt;code&gt;VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be supported for color attachments, as specified by the &lt;code&gt;VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT&lt;/code&gt; flag in &lt;code&gt;VkFormatProperties&lt;/code&gt;::&lt;code&gt;linearTilingFeatures&lt;/code&gt; returned by &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; with the same value of &lt;code&gt;format&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;image&lt;/code&gt; 만들어졌습니다 &lt;code&gt;VK_IMAGE_TILING_LINEAR&lt;/code&gt; 및 &lt;code&gt;usage&lt;/code&gt; 포함 &lt;code&gt;VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT&lt;/code&gt; 을 , &lt;code&gt;format&lt;/code&gt; &lt;strong&gt;해야한다&lt;/strong&gt; 에 의해 지정된대로 색 첨부 지원 &lt;code&gt;VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT&lt;/code&gt; 의 에서 플래그 &lt;code&gt;VkFormatProperties&lt;/code&gt; :: &lt;code&gt;linearTilingFeatures&lt;/code&gt; 에 의해 반환 &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; 같은 값 &lt;code&gt;format&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="05dd84b825445a79b30621d2370418a9afabe44f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;image&lt;/code&gt; was created with &lt;code&gt;VK_IMAGE_TILING_LINEAR&lt;/code&gt; and &lt;code&gt;usage&lt;/code&gt; contains &lt;code&gt;VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be supported for depth/stencil attachments, as specified by the &lt;code&gt;VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT&lt;/code&gt; flag in &lt;code&gt;VkFormatProperties&lt;/code&gt;::&lt;code&gt;linearTilingFeatures&lt;/code&gt; returned by &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; with the same value of &lt;code&gt;format&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;image&lt;/code&gt; 만들어졌습니다 &lt;code&gt;VK_IMAGE_TILING_LINEAR&lt;/code&gt; 및 &lt;code&gt;usage&lt;/code&gt; 포함 &lt;code&gt;VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT&lt;/code&gt; 을 , &lt;code&gt;format&lt;/code&gt; &lt;strong&gt;해야한다&lt;/strong&gt; 에 의해 지정된대로, 깊이 / 스텐실 첨부 지원 &lt;code&gt;VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT&lt;/code&gt; 의 에서 플래그 &lt;code&gt;VkFormatProperties&lt;/code&gt; :: &lt;code&gt;linearTilingFeatures&lt;/code&gt; 에 의해 반환 &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; 같은 값 &lt;code&gt;format&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="68510d590e49ff75c23b0cf18defe6b675503f63" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;image&lt;/code&gt; was created with &lt;code&gt;VK_IMAGE_TILING_LINEAR&lt;/code&gt; and &lt;code&gt;usage&lt;/code&gt; contains &lt;code&gt;VK_IMAGE_USAGE_SAMPLED_BIT&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be supported for sampled images, as specified by the &lt;code&gt;VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT&lt;/code&gt; flag in &lt;code&gt;VkFormatProperties&lt;/code&gt;::&lt;code&gt;linearTilingFeatures&lt;/code&gt; returned by &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; with the same value of &lt;code&gt;format&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;image&lt;/code&gt; 만들어졌습니다 &lt;code&gt;VK_IMAGE_TILING_LINEAR&lt;/code&gt; 및 &lt;code&gt;usage&lt;/code&gt; 포함 &lt;code&gt;VK_IMAGE_USAGE_SAMPLED_BIT&lt;/code&gt; 을 , &lt;code&gt;format&lt;/code&gt; &lt;strong&gt;해야한다&lt;/strong&gt; 에 의해 지정된대로 샘플 이미지에 대한 지원 &lt;code&gt;VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT&lt;/code&gt; 의 에서 플래그 &lt;code&gt;VkFormatProperties&lt;/code&gt; :: &lt;code&gt;linearTilingFeatures&lt;/code&gt; 에 의해 반환 &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; 같은 값 &lt;code&gt;format&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5fb67a6acaa120becf2167fa69866784b43566ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;image&lt;/code&gt; was created with &lt;code&gt;VK_IMAGE_TILING_LINEAR&lt;/code&gt; and &lt;code&gt;usage&lt;/code&gt; contains &lt;code&gt;VK_IMAGE_USAGE_STORAGE_BIT&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be supported for storage images, as specified by the &lt;code&gt;VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT&lt;/code&gt; flag in &lt;code&gt;VkFormatProperties&lt;/code&gt;::&lt;code&gt;linearTilingFeatures&lt;/code&gt; returned by &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; with the same value of &lt;code&gt;format&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;image&lt;/code&gt; 만들어졌습니다 &lt;code&gt;VK_IMAGE_TILING_LINEAR&lt;/code&gt; 및 &lt;code&gt;usage&lt;/code&gt; 포함 &lt;code&gt;VK_IMAGE_USAGE_STORAGE_BIT&lt;/code&gt; 을 , &lt;code&gt;format&lt;/code&gt; &lt;strong&gt;해야한다&lt;/strong&gt; 에 의해 지정된대로 저장 이미지에 대한 지원 &lt;code&gt;VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT&lt;/code&gt; 의 에서 플래그 &lt;code&gt;VkFormatProperties&lt;/code&gt; :: &lt;code&gt;linearTilingFeatures&lt;/code&gt; 에 의해 반환 &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; 같은 값 &lt;code&gt;format&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa699a29d8b5d1c56667ef84a54b7f3dd8e64d56" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;image&lt;/code&gt; was created with &lt;code&gt;VK_IMAGE_TILING_LINEAR&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be format that has at least one supported feature bit present in the value of &lt;code&gt;VkFormatProperties&lt;/code&gt;::&lt;code&gt;linearTilingFeatures&lt;/code&gt; returned by &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; with the same value of &lt;code&gt;format&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;image&lt;/code&gt; 로 만든 &lt;code&gt;VK_IMAGE_TILING_LINEAR&lt;/code&gt; , &lt;code&gt;format&lt;/code&gt; &lt;strong&gt;해야&lt;/strong&gt; 값에 적어도 하나의 지원 기능을 갖고, 본 비트 포맷 될 &lt;code&gt;VkFormatProperties&lt;/code&gt; 을 :: &lt;code&gt;linearTilingFeatures&lt;/code&gt; 가 의해 반환 &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; 의 값이 동일한 &lt;code&gt;format&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9d016a518998bf6ade4849b823ed7ccc1c5951d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;image&lt;/code&gt; was created with &lt;code&gt;VK_IMAGE_TILING_OPTIMAL&lt;/code&gt; and &lt;code&gt;usage&lt;/code&gt; contains &lt;code&gt;VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be supported for color attachments, as specified by the &lt;code&gt;VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT&lt;/code&gt; flag in &lt;code&gt;VkFormatProperties&lt;/code&gt;::&lt;code&gt;optimalTilingFeatures&lt;/code&gt; returned by &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; with the same value of &lt;code&gt;format&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;image&lt;/code&gt; 만들어졌습니다 &lt;code&gt;VK_IMAGE_TILING_OPTIMAL&lt;/code&gt; 및 &lt;code&gt;usage&lt;/code&gt; 포함 &lt;code&gt;VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT&lt;/code&gt; 을 , &lt;code&gt;format&lt;/code&gt; &lt;strong&gt;해야한다&lt;/strong&gt; 에 의해 지정된대로 색 첨부 지원 &lt;code&gt;VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT&lt;/code&gt; 의 에서 플래그 &lt;code&gt;VkFormatProperties&lt;/code&gt; :: &lt;code&gt;optimalTilingFeatures&lt;/code&gt; 에 의해 반환 &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; 같은 값 &lt;code&gt;format&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="20d21570d48f1ad2ba072355d48b11b18b4b1d34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;image&lt;/code&gt; was created with &lt;code&gt;VK_IMAGE_TILING_OPTIMAL&lt;/code&gt; and &lt;code&gt;usage&lt;/code&gt; contains &lt;code&gt;VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be supported for depth/stencil attachments, as specified by the &lt;code&gt;VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT&lt;/code&gt; flag in &lt;code&gt;VkFormatProperties&lt;/code&gt;::&lt;code&gt;optimalTilingFeatures&lt;/code&gt; returned by &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; with the same value of &lt;code&gt;format&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;image&lt;/code&gt; 만들어졌습니다 &lt;code&gt;VK_IMAGE_TILING_OPTIMAL&lt;/code&gt; 및 &lt;code&gt;usage&lt;/code&gt; 포함 &lt;code&gt;VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT&lt;/code&gt; 을 , &lt;code&gt;format&lt;/code&gt; &lt;strong&gt;해야한다&lt;/strong&gt; 에 의해 지정된대로, 깊이 / 스텐실 첨부 지원 &lt;code&gt;VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT&lt;/code&gt; 의 에서 플래그 &lt;code&gt;VkFormatProperties&lt;/code&gt; :: &lt;code&gt;optimalTilingFeatures&lt;/code&gt; 에 의해 반환 &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; 같은 값 &lt;code&gt;format&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76d498a5585df689eb0ecdfdde088d54f278396a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;image&lt;/code&gt; was created with &lt;code&gt;VK_IMAGE_TILING_OPTIMAL&lt;/code&gt; and &lt;code&gt;usage&lt;/code&gt; contains &lt;code&gt;VK_IMAGE_USAGE_SAMPLED_BIT&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be supported for sampled images, as specified by the &lt;code&gt;VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT&lt;/code&gt; flag in &lt;code&gt;VkFormatProperties&lt;/code&gt;::&lt;code&gt;optimalTilingFeatures&lt;/code&gt; returned by &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; with the same value of &lt;code&gt;format&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;image&lt;/code&gt; 만들어졌습니다 &lt;code&gt;VK_IMAGE_TILING_OPTIMAL&lt;/code&gt; 및 &lt;code&gt;usage&lt;/code&gt; 포함 &lt;code&gt;VK_IMAGE_USAGE_SAMPLED_BIT&lt;/code&gt; 을 , &lt;code&gt;format&lt;/code&gt; &lt;strong&gt;해야한다&lt;/strong&gt; 에 의해 지정된대로 샘플 이미지에 대한 지원 &lt;code&gt;VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT&lt;/code&gt; 의 에서 플래그 &lt;code&gt;VkFormatProperties&lt;/code&gt; :: &lt;code&gt;optimalTilingFeatures&lt;/code&gt; 에 의해 반환 &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; 같은 값 &lt;code&gt;format&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="916911a48b114ff8f5c464c73c21bb2013725bcf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;image&lt;/code&gt; was created with &lt;code&gt;VK_IMAGE_TILING_OPTIMAL&lt;/code&gt; and &lt;code&gt;usage&lt;/code&gt; contains &lt;code&gt;VK_IMAGE_USAGE_STORAGE_BIT&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be supported for storage images, as specified by the &lt;code&gt;VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT&lt;/code&gt; flag in &lt;code&gt;VkFormatProperties&lt;/code&gt;::&lt;code&gt;optimalTilingFeatures&lt;/code&gt; returned by &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; with the same value of &lt;code&gt;format&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;image&lt;/code&gt; 만들어졌습니다 &lt;code&gt;VK_IMAGE_TILING_OPTIMAL&lt;/code&gt; 및 &lt;code&gt;usage&lt;/code&gt; 포함 &lt;code&gt;VK_IMAGE_USAGE_STORAGE_BIT&lt;/code&gt; 을 , &lt;code&gt;format&lt;/code&gt; &lt;strong&gt;해야한다&lt;/strong&gt; 에 의해 지정된대로 저장 이미지에 대한 지원 &lt;code&gt;VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT&lt;/code&gt; 의 에서 플래그 &lt;code&gt;VkFormatProperties&lt;/code&gt; :: &lt;code&gt;optimalTilingFeatures&lt;/code&gt; 에 의해 반환 &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; 같은 값 &lt;code&gt;format&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="caf8f7a7a3cd1072beb9095a5b430fddaea1c7b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;image&lt;/code&gt; was created with &lt;code&gt;VK_IMAGE_TILING_OPTIMAL&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be format that has at least one supported feature bit present in the value of &lt;code&gt;VkFormatProperties&lt;/code&gt;::&lt;code&gt;optimalTilingFeatures&lt;/code&gt; returned by &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; with the same value of &lt;code&gt;format&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;image&lt;/code&gt; 로 만든 &lt;code&gt;VK_IMAGE_TILING_OPTIMAL&lt;/code&gt; , &lt;code&gt;format&lt;/code&gt; &lt;strong&gt;해야&lt;/strong&gt; 값에 적어도 하나의 지원 기능을 갖고, 본 비트 포맷 될 &lt;code&gt;VkFormatProperties&lt;/code&gt; 을 :: &lt;code&gt;optimalTilingFeatures&lt;/code&gt; 가 의해 반환 &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; 의 값이 동일한 &lt;code&gt;format&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="29bf89052a966dcb125474079b8bdc7559320ccd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;image&lt;/code&gt; was created with a sharing mode of &lt;code&gt;VK_SHARING_MODE_CONCURRENT&lt;/code&gt;, &lt;code&gt;srcQueueFamilyIndex&lt;/code&gt; and &lt;code&gt;dstQueueFamilyIndex&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; both be &lt;code&gt;VK_QUEUE_FAMILY_IGNORED&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;image&lt;/code&gt; 의 공유 모드로 생성 된 &lt;code&gt;VK_SHARING_MODE_CONCURRENT&lt;/code&gt; , &lt;code&gt;srcQueueFamilyIndex&lt;/code&gt; 및 &lt;code&gt;dstQueueFamilyIndex&lt;/code&gt; &lt;strong&gt;해야한다&lt;/strong&gt; 둘 수 &lt;code&gt;VK_QUEUE_FAMILY_IGNORED&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a0ffb5134fc86a2f0f83d99f935c208ac159fc8f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;image&lt;/code&gt; was created with a sharing mode of &lt;code&gt;VK_SHARING_MODE_EXCLUSIVE&lt;/code&gt;, &lt;code&gt;srcQueueFamilyIndex&lt;/code&gt; and &lt;code&gt;dstQueueFamilyIndex&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; either both be &lt;code&gt;VK_QUEUE_FAMILY_IGNORED&lt;/code&gt;, or both be a valid queue family (see &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-queueprops&quot;&gt;html/vkspec.html#devsandqueues-queueprops&lt;/a&gt;).</source>
          <target state="translated">경우 &lt;code&gt;image&lt;/code&gt; 의 공유 모드로 생성 된 &lt;code&gt;VK_SHARING_MODE_EXCLUSIVE&lt;/code&gt; , &lt;code&gt;srcQueueFamilyIndex&lt;/code&gt; 및 &lt;code&gt;dstQueueFamilyIndex&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 하나 둘 수 &lt;code&gt;VK_QUEUE_FAMILY_IGNORED&lt;/code&gt; , 또는 두 가지 모두 유효한 큐 가족 수 (참조 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-queueprops&quot;&gt;HTML / vkspec.html # devsandqueues-queueprops을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7d7bde11f000421f0a865adbe2f9228e223970c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;image&lt;/code&gt; was created with a sharing mode of &lt;code&gt;VK_SHARING_MODE_EXCLUSIVE&lt;/code&gt;, and &lt;code&gt;srcQueueFamilyIndex&lt;/code&gt; and &lt;code&gt;dstQueueFamilyIndex&lt;/code&gt; are not &lt;code&gt;VK_QUEUE_FAMILY_IGNORED&lt;/code&gt;, at least one of them &lt;strong&gt;must&lt;/strong&gt; be the same as the family of the queue that will execute this barrier</source>
          <target state="translated">경우 &lt;code&gt;image&lt;/code&gt; 의 공유 모드로 생성 된 &lt;code&gt;VK_SHARING_MODE_EXCLUSIVE&lt;/code&gt; 및 &lt;code&gt;srcQueueFamilyIndex&lt;/code&gt; 및 &lt;code&gt;dstQueueFamilyIndex&lt;/code&gt; 가 있습니다하지 &lt;code&gt;VK_QUEUE_FAMILY_IGNORED&lt;/code&gt; 는 , 그들 중 적어도 하나는 &lt;strong&gt;있어야&lt;/strong&gt; 이 장벽을 실행합니다 큐의 가족과 동일</target>
        </trans-unit>
        <trans-unit id="91203b3732e28c2d54555e7a5da367fca1362c5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;image&lt;/code&gt; was created with the &lt;code&gt;VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT&lt;/code&gt; flag, &lt;code&gt;format&lt;/code&gt;&lt;strong&gt;can&lt;/strong&gt; be different from the image&amp;rsquo;s format, but if they are not equal they &lt;strong&gt;must&lt;/strong&gt; be &lt;em&gt;compatible&lt;/em&gt;. Image format compatibility is defined in the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-formats-compatibility-classes&quot;&gt;Format Compatibility Classes&lt;/a&gt; section. Views of compatible formats will have the same mapping between texel coordinates and memory locations irrespective of the &lt;code&gt;format&lt;/code&gt;, with only the interpretation of the bit pattern changing.</source>
          <target state="translated">&lt;code&gt;VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT&lt;/code&gt; 플래그를 사용하여 &lt;code&gt;image&lt;/code&gt; 를 작성한 경우 &lt;code&gt;format&lt;/code&gt; &lt;strong&gt;은&lt;/strong&gt; 이미지 형식과 다를 &lt;strong&gt;수&lt;/strong&gt; 있지만 같지 &lt;strong&gt;않으면 &lt;/strong&gt;&lt;em&gt;호환 가능 &lt;/em&gt;&lt;strong&gt;해야&lt;/strong&gt; 합니다 . 이미지 형식 호환성은 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-formats-compatibility-classes&quot;&gt;형식 호환성 클래스&lt;/a&gt; 섹션에 정의되어 있습니다. 호환되는 형식의 뷰는 비트 패턴 변경의 해석만으로 &lt;code&gt;format&lt;/code&gt; 과 상관없이 텍셀 좌표와 메모리 위치간에 동일한 매핑을 갖습니다 .&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9fbae1e6663e7915acc1fe3b708275cbc842d6a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;image&lt;/code&gt; was created with the &lt;code&gt;VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT&lt;/code&gt; flag, &lt;code&gt;format&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be compatible with the &lt;code&gt;format&lt;/code&gt; used to create &lt;code&gt;image&lt;/code&gt;, as defined in &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-formats-compatibility-classes&quot;&gt;Format Compatibility Classes&lt;/a&gt;</source>
          <target state="translated">경우 &lt;code&gt;image&lt;/code&gt; 로 만들어진 &lt;code&gt;VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT&lt;/code&gt; 의 플래그, &lt;code&gt;format&lt;/code&gt; &lt;strong&gt;해야한다&lt;/strong&gt; 와 호환 &lt;code&gt;format&lt;/code&gt; 만드는 데 사용되는 &lt;code&gt;image&lt;/code&gt; 에 정의 된 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-formats-compatibility-classes&quot;&gt;형식 호환성 클래스&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="be78940e7bce60efd4e6172142c7297bbe0acfef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;image&lt;/code&gt; was not created with &lt;code&gt;VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT&lt;/code&gt; then &lt;code&gt;viewType&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not be &lt;code&gt;VK_IMAGE_VIEW_TYPE_CUBE&lt;/code&gt; or &lt;code&gt;VK_IMAGE_VIEW_TYPE_CUBE_ARRAY&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT&lt;/code&gt; 로 &lt;code&gt;image&lt;/code&gt; 를 만들지 않은 경우 &lt;code&gt;viewType&lt;/code&gt; &lt;strong&gt;은 &lt;/strong&gt; &lt;code&gt;VK_IMAGE_VIEW_TYPE_CUBE&lt;/code&gt; 또는 &lt;code&gt;VK_IMAGE_VIEW_TYPE_CUBE_ARRAY&lt;/code&gt; &lt;strong&gt;가&lt;/strong&gt; 아니 &lt;strong&gt;어야합니다.&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c73590a7ae472ad71eb585217ca27b348860c349" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;image&lt;/code&gt; was not created with the &lt;code&gt;VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT&lt;/code&gt; flag, &lt;code&gt;format&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be identical to the &lt;code&gt;format&lt;/code&gt; used to create &lt;code&gt;image&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT&lt;/code&gt; 플래그로 &lt;code&gt;image&lt;/code&gt; 를 작성하지 않은 경우 &lt;code&gt;format&lt;/code&gt; &lt;strong&gt;은 &lt;/strong&gt; &lt;code&gt;image&lt;/code&gt; 작성에 사용 된 &lt;code&gt;format&lt;/code&gt; 과 동일 &lt;strong&gt;해야합니다.&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="655b64ab0c5dd20a68eab0e67a7aa49698f0d5f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;imageBindCount&lt;/code&gt; is not &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;pImageBinds&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to an array of &lt;code&gt;imageBindCount&lt;/code&gt; valid &lt;code&gt;VkSparseImageMemoryBindInfo&lt;/code&gt; structures</source>
          <target state="translated">경우 &lt;code&gt;imageBindCount&lt;/code&gt; 가 아닌 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;pImageBinds&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 의 배열에 대한 포인터가 될 &lt;code&gt;imageBindCount&lt;/code&gt; 유효 &lt;code&gt;VkSparseImageMemoryBindInfo&lt;/code&gt; 의 구조</target>
        </trans-unit>
        <trans-unit id="469f85624b56db0eb1a8bb56d19eb2c71106c1e6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;imageMemoryBarrierCount&lt;/code&gt; is not &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;pImageMemoryBarriers&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to an array of &lt;code&gt;imageMemoryBarrierCount&lt;/code&gt; valid &lt;code&gt;VkImageMemoryBarrier&lt;/code&gt; structures</source>
          <target state="translated">경우 &lt;code&gt;imageMemoryBarrierCount&lt;/code&gt; 가 아닌 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;pImageMemoryBarriers&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 의 배열에 대한 포인터가 될 &lt;code&gt;imageMemoryBarrierCount&lt;/code&gt; 유효 &lt;code&gt;VkImageMemoryBarrier&lt;/code&gt; 의 구조</target>
        </trans-unit>
        <trans-unit id="8787fcc42b81dae679fcee3a6b5b723a4287faba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;imageOpaqueBindCount&lt;/code&gt; is not &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;pImageOpaqueBinds&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to an array of &lt;code&gt;imageOpaqueBindCount&lt;/code&gt; valid &lt;code&gt;VkSparseImageOpaqueMemoryBindInfo&lt;/code&gt; structures</source>
          <target state="translated">경우 &lt;code&gt;imageOpaqueBindCount&lt;/code&gt; 가 아닌 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;pImageOpaqueBinds&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 의 배열에 대한 포인터가 될 &lt;code&gt;imageOpaqueBindCount&lt;/code&gt; 유효 &lt;code&gt;VkSparseImageOpaqueMemoryBindInfo&lt;/code&gt; 의 구조</target>
        </trans-unit>
        <trans-unit id="7c9081aa69255d2ceffa59607e396e0dd38c3450" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;imageType&lt;/code&gt; is &lt;code&gt;VK_IMAGE_TYPE_1D&lt;/code&gt;, &lt;code&gt;extent.width&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than or equal to &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt;::&lt;code&gt;maxImageDimension1D&lt;/code&gt;, or &lt;code&gt;VkImageFormatProperties&lt;/code&gt;::&lt;code&gt;maxExtent.width&lt;/code&gt; (as returned by &lt;code&gt;vkGetPhysicalDeviceImageFormatProperties&lt;/code&gt; with &lt;code&gt;format&lt;/code&gt;, &lt;code&gt;imageType&lt;/code&gt;, &lt;code&gt;tiling&lt;/code&gt;, &lt;code&gt;usage&lt;/code&gt;, and &lt;code&gt;flags&lt;/code&gt; equal to those in this structure) - whichever is higher</source>
          <target state="translated">경우 &lt;code&gt;imageType&lt;/code&gt; 있다 &lt;code&gt;VK_IMAGE_TYPE_1D&lt;/code&gt; , &lt;code&gt;extent.width&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 이하 동일보다는 이상이어야 &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; :: &lt;code&gt;maxImageDimension1D&lt;/code&gt; , 또는 &lt;code&gt;VkImageFormatProperties&lt;/code&gt; :: &lt;code&gt;maxExtent.width&lt;/code&gt; 을 (에 의해 반환 &lt;code&gt;vkGetPhysicalDeviceImageFormatProperties&lt;/code&gt; 와 &lt;code&gt;format&lt;/code&gt; , &lt;code&gt;imageType&lt;/code&gt; , &lt;code&gt;tiling&lt;/code&gt; , &lt;code&gt;usage&lt;/code&gt; 및 &lt;code&gt;flags&lt;/code&gt; 이 구조에서와 동일) -더 높은 쪽</target>
        </trans-unit>
        <trans-unit id="1a32bcfa391a5b4002e29c4247fdfcb7ddc7e260" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;imageType&lt;/code&gt; is &lt;code&gt;VK_IMAGE_TYPE_1D&lt;/code&gt;, &lt;code&gt;flags&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not contain &lt;code&gt;VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;imageType&lt;/code&gt; 있다 &lt;code&gt;VK_IMAGE_TYPE_1D&lt;/code&gt; , &lt;code&gt;flags&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 포함하지 &lt;code&gt;VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="f5da21c6988da23a254eba6335fa2a23db38cd7b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;imageType&lt;/code&gt; is &lt;code&gt;VK_IMAGE_TYPE_1D&lt;/code&gt;, both &lt;code&gt;extent.height&lt;/code&gt; and &lt;code&gt;extent.depth&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;1&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;imageType&lt;/code&gt; 있다 &lt;code&gt;VK_IMAGE_TYPE_1D&lt;/code&gt; , 모두 &lt;code&gt;extent.height&lt;/code&gt; 및 &lt;code&gt;extent.depth&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="69f7491e2261a16dc0a0ab7520b8f1a34c69be14" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;imageType&lt;/code&gt; is &lt;code&gt;VK_IMAGE_TYPE_2D&lt;/code&gt; and &lt;code&gt;flags&lt;/code&gt; contains &lt;code&gt;VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT&lt;/code&gt;, &lt;code&gt;extent.width&lt;/code&gt; and &lt;code&gt;extent.height&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be equal and &lt;code&gt;arrayLayers&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be greater than or equal to 6</source>
          <target state="translated">경우 &lt;code&gt;imageType&lt;/code&gt; 있다 &lt;code&gt;VK_IMAGE_TYPE_2D&lt;/code&gt; 및 &lt;code&gt;flags&lt;/code&gt; 포함 &lt;code&gt;VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT&lt;/code&gt; 는 , &lt;code&gt;extent.width&lt;/code&gt; 및 &lt;code&gt;extent.height&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 동일하고 &lt;code&gt;arrayLayers&lt;/code&gt; 가&lt;strong&gt;있어야합니다&lt;/strong&gt; 보다 커야 또는 6과 동일</target>
        </trans-unit>
        <trans-unit id="fd7f9a4ad14a26f1deae3d88454df37b9f2d601f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;imageType&lt;/code&gt; is &lt;code&gt;VK_IMAGE_TYPE_2D&lt;/code&gt; and &lt;code&gt;flags&lt;/code&gt; contains &lt;code&gt;VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT&lt;/code&gt;, &lt;code&gt;extent.width&lt;/code&gt; and &lt;code&gt;extent.height&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than or equal to &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt;::&lt;code&gt;maxImageDimensionCube&lt;/code&gt;, or &lt;code&gt;VkImageFormatProperties&lt;/code&gt;::&lt;code&gt;maxExtent.width&lt;/code&gt;/height (as returned by &lt;code&gt;vkGetPhysicalDeviceImageFormatProperties&lt;/code&gt; with &lt;code&gt;format&lt;/code&gt;, &lt;code&gt;imageType&lt;/code&gt;, &lt;code&gt;tiling&lt;/code&gt;, &lt;code&gt;usage&lt;/code&gt;, and &lt;code&gt;flags&lt;/code&gt; equal to those in this structure) - whichever is higher</source>
          <target state="translated">경우 &lt;code&gt;imageType&lt;/code&gt; 있다 &lt;code&gt;VK_IMAGE_TYPE_2D&lt;/code&gt; 및 &lt;code&gt;flags&lt;/code&gt; 포함 &lt;code&gt;VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT&lt;/code&gt; 을 , &lt;code&gt;extent.width&lt;/code&gt; 및 &lt;code&gt;extent.height&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 미만이거나 동일 &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; :: &lt;code&gt;maxImageDimensionCube&lt;/code&gt; , 또는 &lt;code&gt;VkImageFormatProperties&lt;/code&gt; :: &lt;code&gt;maxExtent.width&lt;/code&gt; 에 의해 반환 (/ 높이 &lt;code&gt;vkGetPhysicalDeviceImageFormatProperties&lt;/code&gt; 와 &lt;code&gt;format&lt;/code&gt; , &lt;code&gt;imageType&lt;/code&gt; , &lt;code&gt;tiling&lt;/code&gt; , &lt;code&gt;usage&lt;/code&gt; , 이 구조의 &lt;code&gt;flags&lt;/code&gt; 와 같은 플래그 )-더 높은 쪽</target>
        </trans-unit>
        <trans-unit id="47204cac8e2808373a2cf7fe6260136512f55675" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;imageType&lt;/code&gt; is &lt;code&gt;VK_IMAGE_TYPE_2D&lt;/code&gt; and &lt;code&gt;flags&lt;/code&gt; does not contain &lt;code&gt;VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT&lt;/code&gt;, &lt;code&gt;extent.width&lt;/code&gt; and &lt;code&gt;extent.height&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than or equal to &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt;::&lt;code&gt;maxImageDimension2D&lt;/code&gt;, or &lt;code&gt;VkImageFormatProperties&lt;/code&gt;::&lt;code&gt;maxExtent.width&lt;/code&gt;/height (as returned by &lt;code&gt;vkGetPhysicalDeviceImageFormatProperties&lt;/code&gt; with &lt;code&gt;format&lt;/code&gt;, &lt;code&gt;imageType&lt;/code&gt;, &lt;code&gt;tiling&lt;/code&gt;, &lt;code&gt;usage&lt;/code&gt;, and &lt;code&gt;flags&lt;/code&gt; equal to those in this structure) - whichever is higher</source>
          <target state="translated">경우 &lt;code&gt;imageType&lt;/code&gt; 있다 &lt;code&gt;VK_IMAGE_TYPE_2D&lt;/code&gt; 및 &lt;code&gt;flags&lt;/code&gt; 포함하지 않는 &lt;code&gt;VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT&lt;/code&gt; 을 , &lt;code&gt;extent.width&lt;/code&gt; 및 &lt;code&gt;extent.height&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 미만이거나 동일 &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; :: &lt;code&gt;maxImageDimension2D&lt;/code&gt; , 또는 &lt;code&gt;VkImageFormatProperties&lt;/code&gt; :: &lt;code&gt;maxExtent.width&lt;/code&gt; 에 의해 반환 (/ 높이 &lt;code&gt;vkGetPhysicalDeviceImageFormatProperties&lt;/code&gt; 와 &lt;code&gt;format&lt;/code&gt; , &lt;code&gt;imageType&lt;/code&gt; , &lt;code&gt;tiling&lt;/code&gt; , &lt;code&gt;usage&lt;/code&gt; 및 &lt;code&gt;flags&lt;/code&gt; 는이 구조 와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8ba6aecfbf8778e575c860374c8821c79d7be814" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;imageType&lt;/code&gt; is &lt;code&gt;VK_IMAGE_TYPE_2D&lt;/code&gt;, &lt;code&gt;extent.depth&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;1&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;imageType&lt;/code&gt; 있다 &lt;code&gt;VK_IMAGE_TYPE_2D&lt;/code&gt; , &lt;code&gt;extent.depth&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 수 &lt;code&gt;1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04c28de959e81236f0fb6a32b0c98e24bfc06cdb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;imageType&lt;/code&gt; is &lt;code&gt;VK_IMAGE_TYPE_3D&lt;/code&gt;, &lt;code&gt;arrayLayers&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;imageType&lt;/code&gt; 있다 &lt;code&gt;VK_IMAGE_TYPE_3D&lt;/code&gt; 을 , &lt;code&gt;arrayLayers&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 될 &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6acc9b47f2b791178140688c6de5728437351550" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;imageType&lt;/code&gt; is &lt;code&gt;VK_IMAGE_TYPE_3D&lt;/code&gt;, &lt;code&gt;extent.width&lt;/code&gt;, &lt;code&gt;extent.height&lt;/code&gt; and &lt;code&gt;extent.depth&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than or equal to &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt;::&lt;code&gt;maxImageDimension3D&lt;/code&gt;, or &lt;code&gt;VkImageFormatProperties&lt;/code&gt;::&lt;code&gt;maxExtent.width&lt;/code&gt;/height/depth (as returned by &lt;code&gt;vkGetPhysicalDeviceImageFormatProperties&lt;/code&gt; with &lt;code&gt;format&lt;/code&gt;, &lt;code&gt;imageType&lt;/code&gt;, &lt;code&gt;tiling&lt;/code&gt;, &lt;code&gt;usage&lt;/code&gt;, and &lt;code&gt;flags&lt;/code&gt; equal to those in this structure) - whichever is higher</source>
          <target state="translated">경우 &lt;code&gt;imageType&lt;/code&gt; 있다 &lt;code&gt;VK_IMAGE_TYPE_3D&lt;/code&gt; 는 , &lt;code&gt;extent.width&lt;/code&gt; , &lt;code&gt;extent.height&lt;/code&gt; 및 &lt;code&gt;extent.depth&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 미만이거나 동일 &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; :: &lt;code&gt;maxImageDimension3D&lt;/code&gt; 또는 &lt;code&gt;VkImageFormatProperties&lt;/code&gt; :: &lt;code&gt;maxExtent.width&lt;/code&gt; 의해 반환 (/ 높이 / 깊이 &lt;code&gt;vkGetPhysicalDeviceImageFormatProperties&lt;/code&gt; 와 &lt;code&gt;format&lt;/code&gt; , &lt;code&gt;imageType&lt;/code&gt; , &lt;code&gt;tiling&lt;/code&gt; , &lt;code&gt;usage&lt;/code&gt; 및 &lt;code&gt;flags&lt;/code&gt; 는이 구조 와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="6792c28f33e8538b9ea0ad9954bdc1bd1ddb0bf7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;imageView&lt;/code&gt; is a valid handle, it &lt;strong&gt;must&lt;/strong&gt; have been created, allocated, or retrieved from &lt;code&gt;device&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;imageView&lt;/code&gt; 유효한 핸들이며, 그것은 &lt;strong&gt;해야한다&lt;/strong&gt; , 생성 할당, 또는에서 검색 한 &lt;code&gt;device&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6563992c5f16d9cc4e1fd36efb5e2373753f52a8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;imageView&lt;/code&gt; is not &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE&lt;/a&gt;, &lt;code&gt;imageView&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a valid &lt;code&gt;VkImageView&lt;/code&gt; handle</source>
          <target state="translated">경우 &lt;code&gt;imageView&lt;/code&gt; 아닌 &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE&lt;/a&gt; , &lt;code&gt;imageView&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 유효한 될 &lt;code&gt;VkImageView&lt;/code&gt; 의 핸들</target>
        </trans-unit>
        <trans-unit id="3ac56b22df2f1eba07211dd4be9c473b4f109d3d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;initialDataSize&lt;/code&gt; is not &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;pInitialData&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to an array of &lt;code&gt;initialDataSize&lt;/code&gt; bytes</source>
          <target state="translated">경우 &lt;code&gt;initialDataSize&lt;/code&gt; 가 아닌 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;pInitialData&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 의 배열에 대한 포인터가 될 &lt;code&gt;initialDataSize&lt;/code&gt; 의 바이트</target>
        </trans-unit>
        <trans-unit id="76895055b0cfd759dbf2bd3dc669a8b0acf0c96f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;initialDataSize&lt;/code&gt; is not &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;pInitialData&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; have been retrieved from a previous call to &lt;code&gt;vkGetPipelineCacheData&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;initialDataSize&lt;/code&gt; 가 아닌 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;pInitialData&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 에 대한 이전 호출에서 검색 한 &lt;code&gt;vkGetPipelineCacheData&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="327661d4b2c47c7c938b652f22378ee6dc616088" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;initialDataSize&lt;/code&gt; is not &lt;code&gt;0&lt;/code&gt;, it &lt;strong&gt;must&lt;/strong&gt; be equal to the size of &lt;code&gt;pInitialData&lt;/code&gt;, as returned by &lt;code&gt;vkGetPipelineCacheData&lt;/code&gt; when &lt;code&gt;pInitialData&lt;/code&gt; was originally retrieved</source>
          <target state="translated">경우 &lt;code&gt;initialDataSize&lt;/code&gt; 가 아닌 &lt;code&gt;0&lt;/code&gt; , 그것은 &lt;strong&gt;해야한다&lt;/strong&gt; 의 크기와 같아야 &lt;code&gt;pInitialData&lt;/code&gt; 에 의해 반환, &lt;code&gt;vkGetPipelineCacheData&lt;/code&gt; 때 &lt;code&gt;pInitialData&lt;/code&gt; 이 원래 검색된</target>
        </trans-unit>
        <trans-unit id="de83bb42cdb8dbd77ce76aecb288a70c72f6baef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;inputAttachmentCount&lt;/code&gt; is not &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;pInputAttachments&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to an array of &lt;code&gt;inputAttachmentCount&lt;/code&gt; valid &lt;code&gt;VkAttachmentReference&lt;/code&gt; structures</source>
          <target state="translated">경우 &lt;code&gt;inputAttachmentCount&lt;/code&gt; 가 아닌 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;pInputAttachments&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 의 배열에 대한 포인터가 될 &lt;code&gt;inputAttachmentCount&lt;/code&gt; 유효 &lt;code&gt;VkAttachmentReference&lt;/code&gt; 의 구조</target>
        </trans-unit>
        <trans-unit id="0d7d8e4147c03eecd6f3ab685835c220ca8a84fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;instance&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;instance&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a valid &lt;code&gt;VkInstance&lt;/code&gt; handle</source>
          <target state="translated">경우 &lt;code&gt;instance&lt;/code&gt; 아닌 &lt;code&gt;NULL&lt;/code&gt; , &lt;code&gt;instance&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 유효한 될 &lt;code&gt;VkInstance&lt;/code&gt; 의 핸들</target>
        </trans-unit>
        <trans-unit id="8a876847e232217e54c091837ac81d04ad7f3bd2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;logicOpEnable&lt;/code&gt; is &lt;code&gt;VK_TRUE&lt;/code&gt;, &lt;code&gt;logicOp&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a valid &lt;a href=&quot;#VkLogicOp&quot;&gt;VkLogicOp&lt;/a&gt; value</source>
          <target state="translated">경우 &lt;code&gt;logicOpEnable&lt;/code&gt; 가 있다 &lt;code&gt;VK_TRUE&lt;/code&gt; 는 , &lt;code&gt;logicOp&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 유효한 될 &lt;a href=&quot;#VkLogicOp&quot;&gt;VkLogicOp의&lt;/a&gt; 값</target>
        </trans-unit>
        <trans-unit id="5453c8142ab07b3f802da000bef608b22d8686f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mapEntryCount&lt;/code&gt; is not &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;pMapEntries&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to an array of &lt;code&gt;mapEntryCount&lt;/code&gt; valid &lt;code&gt;VkSpecializationMapEntry&lt;/code&gt; structures</source>
          <target state="translated">경우 &lt;code&gt;mapEntryCount&lt;/code&gt; 가 아닌 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;pMapEntries&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 의 배열에 대한 포인터가 될 &lt;code&gt;mapEntryCount&lt;/code&gt; 유효 &lt;code&gt;VkSpecializationMapEntry&lt;/code&gt; 의 구조</target>
        </trans-unit>
        <trans-unit id="9b192879eb3ec84d9edfc23d30ca45289e07717a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;memory&lt;/code&gt; is a valid handle, it &lt;strong&gt;must&lt;/strong&gt; have been created, allocated, or retrieved from &lt;code&gt;device&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;memory&lt;/code&gt; 유효한 핸들이며, 그것은 &lt;strong&gt;해야한다&lt;/strong&gt; , 생성 할당, 또는에서 검색 한 &lt;code&gt;device&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c0354e975881e43105f8ace23791a829b1f21b19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;memory&lt;/code&gt; is not &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE&lt;/a&gt;, &lt;code&gt;memory&lt;/code&gt; and &lt;code&gt;memoryOffset&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; match the memory requirements of the resource, as described in section &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#resources-association&quot;&gt;html/vkspec.html#resources-association&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;memory&lt;/code&gt; 가 &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE&lt;/a&gt; 이 아닌 경우 , &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#resources-association&quot;&gt;html / vkspec.html # resources-association&lt;/a&gt; 섹션에 설명 된대로 &lt;code&gt;memory&lt;/code&gt; 및 &lt;code&gt;memoryOffset&lt;/code&gt; &lt;strong&gt;은&lt;/strong&gt; 리소스의 메모리 요구 사항과 일치 &lt;strong&gt;해야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="705bea1531db743d3f1cbebf7c05c018db563064" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;memory&lt;/code&gt; is not &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE&lt;/a&gt;, &lt;code&gt;memory&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a valid &lt;code&gt;VkDeviceMemory&lt;/code&gt; handle</source>
          <target state="translated">경우 &lt;code&gt;memory&lt;/code&gt; 아닌 &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE&lt;/a&gt; , &lt;code&gt;memory&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 유효한 될 &lt;code&gt;VkDeviceMemory&lt;/code&gt; 핸들</target>
        </trans-unit>
        <trans-unit id="c8e8b088a15d14fa78cce225bd5e1a8bdae849d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;memory&lt;/code&gt; is not &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE&lt;/a&gt;, &lt;code&gt;memory&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not have been created with a memory type that reports &lt;code&gt;VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT&lt;/code&gt; bit set</source>
          <target state="translated">경우 &lt;code&gt;memory&lt;/code&gt; 아닌 &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE&lt;/a&gt; , &lt;code&gt;memory&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 메모리 타입이 보고서로 생성되지 않았을 &lt;code&gt;VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT&lt;/code&gt; 의 비트 세트</target>
        </trans-unit>
        <trans-unit id="b3155b99fc0510638fd99c6055d9430708064b42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;memoryBarrierCount&lt;/code&gt; is not &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;pMemoryBarriers&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to an array of &lt;code&gt;memoryBarrierCount&lt;/code&gt; valid &lt;code&gt;VkMemoryBarrier&lt;/code&gt; structures</source>
          <target state="translated">경우 &lt;code&gt;memoryBarrierCount&lt;/code&gt; 가 아닌 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;pMemoryBarriers&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 의 배열에 대한 포인터가 될 &lt;code&gt;memoryBarrierCount&lt;/code&gt; 유효 &lt;code&gt;VkMemoryBarrier&lt;/code&gt; 의 구조</target>
        </trans-unit>
        <trans-unit id="4f55e412f7d96a3061a898b58a1576a462190761" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;oldLayout&lt;/code&gt; is not equal to &lt;code&gt;newLayout&lt;/code&gt;, then the memory barrier defines an &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-image-layout-transitions&quot;&gt;image layout transition&lt;/a&gt; for the specified image subresource range.</source>
          <target state="translated">경우 &lt;code&gt;oldLayout&lt;/code&gt; 가 동일하지 &lt;code&gt;newLayout&lt;/code&gt; 후, 메모리 배리어는 정의 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-image-layout-transitions&quot;&gt;화면 레이아웃 전이&lt;/a&gt; 지정된 화상 하위 리소스 범위를.</target>
        </trans-unit>
        <trans-unit id="bd34f1225339f746b578dbb1393620eb2c46edea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pAllocator&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;pAllocator&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to a valid &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; structure</source>
          <target state="translated">경우 &lt;code&gt;pAllocator&lt;/code&gt; 이 아닌 &lt;code&gt;NULL&lt;/code&gt; 이 , &lt;code&gt;pAllocator&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 유효한 포인터가 될 &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; 의 구조</target>
        </trans-unit>
        <trans-unit id="afb27ff8f07a2cfa4c573f71385b0415ea5a6606" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pApplicationInfo&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;pApplicationInfo&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to a valid &lt;code&gt;VkApplicationInfo&lt;/code&gt; structure</source>
          <target state="translated">경우 &lt;code&gt;pApplicationInfo&lt;/code&gt; 이 아닌 &lt;code&gt;NULL&lt;/code&gt; 이 , &lt;code&gt;pApplicationInfo&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 유효한 포인터가 될 &lt;code&gt;VkApplicationInfo&lt;/code&gt; 의 구조</target>
        </trans-unit>
        <trans-unit id="1bf99137c04d2828ed3a8ea5217673d4bdb8088b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pApplicationName&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;pApplicationName&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a null-terminated UTF-8 string</source>
          <target state="translated">경우 &lt;code&gt;pApplicationName&lt;/code&gt; 이 아닌 &lt;code&gt;NULL&lt;/code&gt; 이 , &lt;code&gt;pApplicationName&lt;/code&gt; 는&lt;strong&gt;해야한다&lt;/strong&gt; null 종료 UTF-8 문자열</target>
        </trans-unit>
        <trans-unit id="4adeea073037e39cb389c3da9713e2d15d03b1e6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pCode&lt;/code&gt; declares any of the capabilities that are listed as not required by the implementation, the relevant feature &lt;strong&gt;must&lt;/strong&gt; be enabled, as listed in the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#spirvenv-capabilities-table&quot;&gt;SPIR-V Environment&lt;/a&gt; appendix</source>
          <target state="translated">&lt;code&gt;pCode&lt;/code&gt; 가 구현에 필요하지 않은 것으로 나열된 기능을 선언하는 경우 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#spirvenv-capabilities-table&quot;&gt;SPIR-V 환경&lt;/a&gt; 부록에 나열된대로 해당 기능 &lt;strong&gt;을&lt;/strong&gt; 활성화 &lt;strong&gt;해야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5d5e4b60aa1137524792b595e49b147934b3de8d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pData&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the maximum size of the data that &lt;strong&gt;can&lt;/strong&gt; be retrieved from the pipeline cache, in bytes, is returned in &lt;code&gt;pDataSize&lt;/code&gt;. Otherwise, &lt;code&gt;pDataSize&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; point to a variable set by the user to the size of the buffer, in bytes, pointed to by &lt;code&gt;pData&lt;/code&gt;, and on return the variable is overwritten with the amount of data actually written to &lt;code&gt;pData&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pData&lt;/code&gt; 가 &lt;code&gt;NULL&lt;/code&gt; 인 경우 파이프 라인 캐시에서 검색 &lt;strong&gt;할 수&lt;/strong&gt; 있는 최대 데이터 크기 ( 바이트)가 &lt;code&gt;pDataSize&lt;/code&gt; 로 반환됩니다 . 그렇지 않으면 &lt;code&gt;pDataSize&lt;/code&gt; &lt;strong&gt;는&lt;/strong&gt; 사용자가 버퍼 크기 (바이트 단위, &lt;code&gt;pData&lt;/code&gt; 가 가리키는)로 설정 한 변수를 가리켜 &lt;strong&gt;야&lt;/strong&gt; 하며 반환시 변수는 실제로 &lt;code&gt;pData&lt;/code&gt; 에 쓴 데이터의 양으로 덮어 씁니다 .</target>
        </trans-unit>
        <trans-unit id="c268ed5bfba26ffc34f3e0ca2b4e127a2cb3cd29" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pDataSize&lt;/code&gt; is less than the maximum size that &lt;strong&gt;can&lt;/strong&gt; be retrieved by the pipeline cache, at most &lt;code&gt;pDataSize&lt;/code&gt; bytes will be written to &lt;code&gt;pData&lt;/code&gt;, and &lt;code&gt;vkGetPipelineCacheData&lt;/code&gt; will return &lt;code&gt;VK_INCOMPLETE&lt;/code&gt;. Any data written to &lt;code&gt;pData&lt;/code&gt; is valid and &lt;strong&gt;can&lt;/strong&gt; be provided as the &lt;code&gt;pInitialData&lt;/code&gt; member of the &lt;code&gt;VkPipelineCacheCreateInfo&lt;/code&gt; structure passed to &lt;code&gt;vkCreatePipelineCache&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;pDataSize&lt;/code&gt; 이 덜 최대 크기보다 &lt;strong&gt;수 있습니다&lt;/strong&gt; 대부분에서, 파이프 라인 캐시에서 검색 할 수 &lt;code&gt;pDataSize&lt;/code&gt; 의 바이트에 기록됩니다 &lt;code&gt;pData&lt;/code&gt; 의 , 그리고 &lt;code&gt;vkGetPipelineCacheData&lt;/code&gt; 가 반환됩니다 &lt;code&gt;VK_INCOMPLETE&lt;/code&gt; 을 . 기록 데이터 &lt;code&gt;pData&lt;/code&gt; 의이 유효하며, &lt;strong&gt;수&lt;/strong&gt; 는 AS 제공 &lt;code&gt;pInitialData&lt;/code&gt; 용 의 부재 &lt;code&gt;VkPipelineCacheCreateInfo&lt;/code&gt; 의 로 전달 구조 &lt;code&gt;vkCreatePipelineCache&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf6165b835c209239173e548b0c17f093d3fb3b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pDataSize&lt;/code&gt; is less than what is necessary to store this header, nothing will be written to &lt;code&gt;pData&lt;/code&gt; and zero will be written to &lt;code&gt;pDataSize&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;pDataSize&lt;/code&gt; 는 이 헤더를 저장하는 데 필요한 것보다 적은 아무것도 기록되지 않습니다 &lt;code&gt;pData&lt;/code&gt; 의 제로가 기록됩니다 &lt;code&gt;pDataSize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ede48e8f4820ef654ca8605142ed27b2b9bb9441" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pDepthStencilAttachment&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;pDepthStencilAttachment&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to a valid &lt;code&gt;VkAttachmentReference&lt;/code&gt; structure</source>
          <target state="translated">경우 &lt;code&gt;pDepthStencilAttachment&lt;/code&gt; 이 아닌 &lt;code&gt;NULL&lt;/code&gt; 이 , &lt;code&gt;pDepthStencilAttachment&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 유효한 포인터가 될 &lt;code&gt;VkAttachmentReference&lt;/code&gt; 의 구조</target>
        </trans-unit>
        <trans-unit id="a2828c50afaed410c863128886e1bd4af2b405e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pDepthStencilAttachment&lt;/code&gt; is not &lt;code&gt;VK_ATTACHMENT_UNUSED&lt;/code&gt; and any attachments in &lt;code&gt;pColorAttachments&lt;/code&gt; are not &lt;code&gt;VK_ATTACHMENT_UNUSED&lt;/code&gt;, they &lt;strong&gt;must&lt;/strong&gt; have the same sample count</source>
          <target state="translated">경우 &lt;code&gt;pDepthStencilAttachment&lt;/code&gt; 이 되지 &lt;code&gt;VK_ATTACHMENT_UNUSED&lt;/code&gt; 와의 첨부 파일 &lt;code&gt;pColorAttachments&lt;/code&gt; 가 되지 &lt;code&gt;VK_ATTACHMENT_UNUSED&lt;/code&gt; , 그들은 &lt;strong&gt;해야한다&lt;/strong&gt; 동일한 샘플 수를 가지고</target>
        </trans-unit>
        <trans-unit id="c162a54f5c0e1c374e6cb530c152ab7bc06a6588" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pDynamicState&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;pDynamicState&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to a valid &lt;code&gt;VkPipelineDynamicStateCreateInfo&lt;/code&gt; structure</source>
          <target state="translated">경우 &lt;code&gt;pDynamicState&lt;/code&gt; 이 아닌 &lt;code&gt;NULL&lt;/code&gt; 이 , &lt;code&gt;pDynamicState&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 유효한 포인터가 될 &lt;code&gt;VkPipelineDynamicStateCreateInfo&lt;/code&gt; 의 구조</target>
        </trans-unit>
        <trans-unit id="6e53e84a8774324df1d559830cb534dac29e86ef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pEnabledFeatures&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;pEnabledFeatures&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to a valid &lt;code&gt;VkPhysicalDeviceFeatures&lt;/code&gt; structure</source>
          <target state="translated">경우 &lt;code&gt;pEnabledFeatures&lt;/code&gt; 이 아닌 &lt;code&gt;NULL&lt;/code&gt; , &lt;code&gt;pEnabledFeatures&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 유효한 포인터가 될 &lt;code&gt;VkPhysicalDeviceFeatures&lt;/code&gt; 의 구조</target>
        </trans-unit>
        <trans-unit id="d5245a93fd77b45f2fdb11922575975a42e04639" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pEngineName&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;pEngineName&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a null-terminated UTF-8 string</source>
          <target state="translated">경우 &lt;code&gt;pEngineName&lt;/code&gt; 이 아닌 &lt;code&gt;NULL&lt;/code&gt; 이 , &lt;code&gt;pEngineName&lt;/code&gt; 는&lt;strong&gt;해야한다&lt;/strong&gt; null 종료 UTF-8 문자열</target>
        </trans-unit>
        <trans-unit id="34e116f58ebc0a12379cb8e17373cedc9c02233e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pEvents&lt;/code&gt; includes one or more events that will be signaled by &lt;code&gt;vkSetEvent&lt;/code&gt; after &lt;code&gt;commandBuffer&lt;/code&gt; has been submitted to a queue, then &lt;code&gt;vkCmdWaitEvents&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not be called inside a render pass instance</source>
          <target state="translated">경우 &lt;code&gt;pEvents&lt;/code&gt; 가 에 의해 신호됩니다 하나 이상의 이벤트가 포함 &lt;code&gt;vkSetEvent&lt;/code&gt; 후 &lt;code&gt;commandBuffer&lt;/code&gt; 가 큐에 제출되었습니다를, 다음 &lt;code&gt;vkCmdWaitEvents&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; A가 통과 인스턴스를 렌더링 내부에서 호출 할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="a78254cb10e3d03e778330f65e7d9801f82022ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pLayerName&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;pLayerName&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a null-terminated UTF-8 string</source>
          <target state="translated">경우 &lt;code&gt;pLayerName&lt;/code&gt; 아닌 &lt;code&gt;NULL&lt;/code&gt; 이 , &lt;code&gt;pLayerName&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; null 종료 UTF-8 문자열</target>
        </trans-unit>
        <trans-unit id="28dafc84b0582e51bed9045362efbdbde3f0f2eb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pOriginal&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, then &lt;code&gt;pfnReallocation&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; behave equivalently to a call to &lt;a href=&quot;#PFN_vkAllocationFunction&quot;&gt;PFN_vkAllocationFunction&lt;/a&gt; with the same parameter values (without &lt;code&gt;pOriginal&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;code&gt;pOriginal&lt;/code&gt; 가 있다 &lt;code&gt;NULL&lt;/code&gt; 을 , 다음 &lt;code&gt;pfnReallocation&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 에 대한 호출에 동등하게 행동 &lt;a href=&quot;#PFN_vkAllocationFunction&quot;&gt;PFN_vkAllocationFunction&lt;/a&gt; (없이 동일한 매개 변수 값 &lt;code&gt;pOriginal&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d3fdeeb5c10628e29c9e996a8c4d5f06dd502054" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pOriginal&lt;/code&gt; is non-&lt;code&gt;NULL&lt;/code&gt;, the implementation &lt;strong&gt;must&lt;/strong&gt; ensure that &lt;code&gt;alignment&lt;/code&gt; is equal to the &lt;code&gt;alignment&lt;/code&gt; used to originally allocate &lt;code&gt;pOriginal&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;pOriginal&lt;/code&gt; 가 비입니다 &lt;code&gt;NULL&lt;/code&gt; 이 , 구현 &lt;strong&gt;해야한다&lt;/strong&gt; 그 보장 &lt;code&gt;alignment&lt;/code&gt; 받는 동일 &lt;code&gt;alignment&lt;/code&gt; 원래 할당하는 데 사용 &lt;code&gt;pOriginal&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="c4ddb06297fba3d6c9032052243c3ad8690ce415" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pPhysicalDevices&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the number of physical devices available is returned in &lt;code&gt;pPhysicalDeviceCount&lt;/code&gt;. Otherwise, &lt;code&gt;pPhysicalDeviceCount&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; point to a variable set by the user to the number of elements in the &lt;code&gt;pPhysicalDevices&lt;/code&gt; array, and on return the variable is overwritten with the number of handles actually written to &lt;code&gt;pPhysicalDevices&lt;/code&gt;. If &lt;code&gt;pPhysicalDeviceCount&lt;/code&gt; is less than the number of physical devices available, at most &lt;code&gt;pPhysicalDeviceCount&lt;/code&gt; structures will be written. If &lt;code&gt;pPhysicalDeviceCount&lt;/code&gt; is smaller than the number of physical devices available, &lt;code&gt;VK_INCOMPLETE&lt;/code&gt; will be returned instead of &lt;code&gt;VK_SUCCESS&lt;/code&gt;, to indicate that not all the available physical devices were returned.</source>
          <target state="translated">경우 &lt;code&gt;pPhysicalDevices&lt;/code&gt; 가 있다 &lt;code&gt;NULL&lt;/code&gt; , 다음 사용 가능한 물리적 장치의 수는 반환됩니다 &lt;code&gt;pPhysicalDeviceCount&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;pPhysicalDeviceCount&lt;/code&gt; &lt;strong&gt;는 &lt;/strong&gt; &lt;code&gt;pPhysicalDevices&lt;/code&gt; 배열 의 요소 수를 사용자가 설정 한 변수를 가리켜 &lt;strong&gt;야하며&lt;/strong&gt; , 반환시 변수는 실제로 &lt;code&gt;pPhysicalDevices&lt;/code&gt; 에 작성된 핸들 수를 덮어 씁니다 . 경우 &lt;code&gt;pPhysicalDeviceCount&lt;/code&gt; 은 최대 사용 가능한 물리적 장치의 수보다 적은 &lt;code&gt;pPhysicalDeviceCount&lt;/code&gt; 의 구조에 기록됩니다. 경우 &lt;code&gt;pPhysicalDeviceCount&lt;/code&gt; 는 물리적 장치의 수를 가능한,보다 작은 &lt;code&gt;VK_INCOMPLETE&lt;/code&gt; 사용 가능한 모든 물리적 장치가 반환되지 않았 음을 나타 내기 위해 &lt;code&gt;VK_SUCCESS&lt;/code&gt; 대신에 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d29f23404131ef20d869ce35dfd78a048c3093cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pProperties&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the number of extensions properties available is returned in &lt;code&gt;pPropertyCount&lt;/code&gt;. Otherwise, &lt;code&gt;pPropertyCount&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; point to a variable set by the user to the number of elements in the &lt;code&gt;pProperties&lt;/code&gt; array, and on return the variable is overwritten with the number of structures actually written to &lt;code&gt;pProperties&lt;/code&gt;. If &lt;code&gt;pPropertyCount&lt;/code&gt; is less than the number of extension properties available, at most &lt;code&gt;pPropertyCount&lt;/code&gt; structures will be written. If &lt;code&gt;pPropertyCount&lt;/code&gt; is smaller than the number of extensions available, &lt;code&gt;VK_INCOMPLETE&lt;/code&gt; will be returned instead of &lt;code&gt;VK_SUCCESS&lt;/code&gt;, to indicate that not all the available properties were returned.</source>
          <target state="translated">&lt;code&gt;pProperties&lt;/code&gt; 가 &lt;code&gt;NULL&lt;/code&gt; 인 경우 사용 가능한 확장 등록 정보 수는 &lt;code&gt;pPropertyCount&lt;/code&gt; 에 반환됩니다 . 그렇지 않으면, &lt;code&gt;pPropertyCount&lt;/code&gt; &lt;strong&gt;는 &lt;/strong&gt; &lt;code&gt;pProperties&lt;/code&gt; 배열 의 요소 수를 사용자가 설정 한 변수를 가리켜 &lt;strong&gt;야&lt;/strong&gt; 하며 반환시 변수는 실제로 &lt;code&gt;pProperties&lt;/code&gt; 에 작성된 구조 수로 덮어 씁니다 . 경우 &lt;code&gt;pPropertyCount&lt;/code&gt; 가 최대 가능한 확장 등록 정보의 수보다 적은 &lt;code&gt;pPropertyCount&lt;/code&gt; 의 구조에 기록됩니다. 경우 &lt;code&gt;pPropertyCount&lt;/code&gt; 이 가능한 확장의 수보다 작은, &lt;code&gt;VK_INCOMPLETE&lt;/code&gt; 는 대신 반환됩니다 &lt;code&gt;VK_SUCCESS&lt;/code&gt; 사용 가능한 모든 특성이 리턴되지 않았 음을 표시하는 VK_SUCCESS</target>
        </trans-unit>
        <trans-unit id="69ffbf0a68d3e52f9397641c4fbfaaa9e81e61ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pProperties&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the number of layer properties available is returned in &lt;code&gt;pPropertyCount&lt;/code&gt;. Otherwise, &lt;code&gt;pPropertyCount&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; point to a variable set by the user to the number of elements in the &lt;code&gt;pProperties&lt;/code&gt; array, and on return the variable is overwritten with the number of structures actually written to &lt;code&gt;pProperties&lt;/code&gt;. If &lt;code&gt;pPropertyCount&lt;/code&gt; is less than the number of layer properties available, at most &lt;code&gt;pPropertyCount&lt;/code&gt; structures will be written. If &lt;code&gt;pPropertyCount&lt;/code&gt; is smaller than the number of layers available, &lt;code&gt;VK_INCOMPLETE&lt;/code&gt; will be returned instead of &lt;code&gt;VK_SUCCESS&lt;/code&gt;, to indicate that not all the available layer properties were returned.</source>
          <target state="translated">&lt;code&gt;pProperties&lt;/code&gt; 가 &lt;code&gt;NULL&lt;/code&gt; 의 경우 , 사용 가능한 계층 프로퍼티의 수가 &lt;code&gt;pPropertyCount&lt;/code&gt; 에 리턴됩니다 . 그렇지 않으면, &lt;code&gt;pPropertyCount&lt;/code&gt; &lt;strong&gt;는 &lt;/strong&gt; &lt;code&gt;pProperties&lt;/code&gt; 배열 의 요소 수를 사용자가 설정 한 변수를 가리켜 &lt;strong&gt;야&lt;/strong&gt; 하며 반환시 변수는 실제로 &lt;code&gt;pProperties&lt;/code&gt; 에 작성된 구조 수로 덮어 씁니다 . 경우 &lt;code&gt;pPropertyCount&lt;/code&gt; 가 최대 가능한 레이어 속성의 수보다 적은 &lt;code&gt;pPropertyCount&lt;/code&gt; 의 구조에 기록됩니다. 경우 &lt;code&gt;pPropertyCount&lt;/code&gt; 가 가능한 레이어의 수보다 작은, &lt;code&gt;VK_INCOMPLETE&lt;/code&gt; 는 대신 반환됩니다 &lt;code&gt;VK_SUCCESS&lt;/code&gt; 사용 가능한 모든 레이어 속성이 반환되지 않았 음을 나타내는 VK_SUCCESS</target>
        </trans-unit>
        <trans-unit id="3803b16ef528e0e7585ebb523bba238237223a02" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pProperties&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the number of sparse format properties available is returned in &lt;code&gt;pPropertyCount&lt;/code&gt;. Otherwise, &lt;code&gt;pPropertyCount&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; point to a variable set by the user to the number of elements in the &lt;code&gt;pProperties&lt;/code&gt; array, and on return the variable is overwritten with the number of structures actually written to &lt;code&gt;pProperties&lt;/code&gt;. If &lt;code&gt;pPropertyCount&lt;/code&gt; is less than the number of sparse format properties available, at most &lt;code&gt;pPropertyCount&lt;/code&gt; structures will be written.</source>
          <target state="translated">경우 &lt;code&gt;pProperties&lt;/code&gt; 가 있다 &lt;code&gt;NULL&lt;/code&gt; , 다음 가능한 스파 스 형식 속성의 수는 반환됩니다 &lt;code&gt;pPropertyCount&lt;/code&gt; . 그렇지 않으면, &lt;code&gt;pPropertyCount&lt;/code&gt; &lt;strong&gt;는 &lt;/strong&gt; &lt;code&gt;pProperties&lt;/code&gt; 배열 의 요소 수를 사용자가 설정 한 변수를 가리켜 &lt;strong&gt;야&lt;/strong&gt; 하며 반환시 변수는 실제로 &lt;code&gt;pProperties&lt;/code&gt; 에 작성된 구조 수로 덮어 씁니다 . 경우 &lt;code&gt;pPropertyCount&lt;/code&gt; 는 최대 가능한 스파 스 형식 속성의 수보다 적은 &lt;code&gt;pPropertyCount&lt;/code&gt; 의 구조가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="8a1e8547822f420f7b662e78f9360ed6d49e75e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pQueueFamilyProperties&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the number of queue families available is returned in &lt;code&gt;pQueueFamilyPropertyCount&lt;/code&gt;. Otherwise, &lt;code&gt;pQueueFamilyPropertyCount&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; point to a variable set by the user to the number of elements in the &lt;code&gt;pQueueFamilyProperties&lt;/code&gt; array, and on return the variable is overwritten with the number of structures actually written to &lt;code&gt;pQueueFamilyProperties&lt;/code&gt;. If &lt;code&gt;pQueueFamilyPropertyCount&lt;/code&gt; is less than the number of queue families available, at most &lt;code&gt;pQueueFamilyPropertyCount&lt;/code&gt; structures will be written.</source>
          <target state="translated">경우 &lt;code&gt;pQueueFamilyProperties&lt;/code&gt; 가 있다 &lt;code&gt;NULL&lt;/code&gt; , 다음 사용 가능한 큐 가족의 수는 반환됩니다 &lt;code&gt;pQueueFamilyPropertyCount&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;pQueueFamilyPropertyCount&lt;/code&gt; &lt;strong&gt;는 &lt;/strong&gt; &lt;code&gt;pQueueFamilyProperties&lt;/code&gt; 배열 의 요소 수를 사용자가 설정 한 변수를 가리켜 &lt;strong&gt;야하며&lt;/strong&gt; , 반환시 변수는 실제로 &lt;code&gt;pQueueFamilyProperties&lt;/code&gt; 에 작성된 구조 수로 덮어 씁니다 . 경우 &lt;code&gt;pQueueFamilyPropertyCount&lt;/code&gt; 가 대부분에서 사용할 큐 가족의 수보다 &lt;code&gt;pQueueFamilyPropertyCount&lt;/code&gt; 의 구조에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="d6a61c8f411b9499a186e3a39db51b17f2f6d678" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pResolveAttachments&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, for each resolve attachment that does not have the value &lt;code&gt;VK_ATTACHMENT_UNUSED&lt;/code&gt;, the corresponding color attachment &lt;strong&gt;must&lt;/strong&gt; not have the value &lt;code&gt;VK_ATTACHMENT_UNUSED&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;pResolveAttachments&lt;/code&gt; 이 아닌 &lt;code&gt;NULL&lt;/code&gt; 값이없는 각 해결에 부착, &lt;code&gt;VK_ATTACHMENT_UNUSED&lt;/code&gt; 는 , 해당 색상 첨부 &lt;strong&gt;해야한다&lt;/strong&gt; 값을 가지고 있지 &lt;code&gt;VK_ATTACHMENT_UNUSED&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fed082c6ee28bf8a79ef0a715771ac0211ff864f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pResolveAttachments&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, the sample count of each element of &lt;code&gt;pColorAttachments&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be anything other than &lt;code&gt;VK_SAMPLE_COUNT_1_BIT&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;pResolveAttachments&lt;/code&gt; 이 아닌 &lt;code&gt;NULL&lt;/code&gt; 의 각 요소의 샘플 수가 &lt;code&gt;pColorAttachments&lt;/code&gt; 가&lt;strong&gt;있어야합니다&lt;/strong&gt; 이외의 다른 수 &lt;code&gt;VK_SAMPLE_COUNT_1_BIT&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="d8a1f6ba6f7b8fc846befe2e6693efc1f7f8416e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pSampleMask&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;pSampleMask&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to an array of \(\lceil{\mathit{rasterizationSamples} \over 32}\rceil\) &lt;code&gt;VkSampleMask&lt;/code&gt; values</source>
          <target state="translated">경우 &lt;code&gt;pSampleMask&lt;/code&gt; 가 아닌 &lt;code&gt;NULL&lt;/code&gt; 이 , &lt;code&gt;pSampleMask&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; \ 배열 (\ {lceil 32 위에 \ mathit rasterizationSamples {} \} \ rceil \)로 포인터 &lt;code&gt;VkSampleMask&lt;/code&gt; 의 값</target>
        </trans-unit>
        <trans-unit id="adcbd2f93cae55f38abc9cd723b9339a40ce5220" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pSparseMemoryRequirements&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the number of sparse memory requirements available is returned in &lt;code&gt;pSparseMemoryRequirementCount&lt;/code&gt;. Otherwise, &lt;code&gt;pSparseMemoryRequirementCount&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; point to a variable set by the user to the number of elements in the &lt;code&gt;pSparseMemoryRequirements&lt;/code&gt; array, and on return the variable is overwritten with the number of structures actually written to &lt;code&gt;pSparseMemoryRequirements&lt;/code&gt;. If &lt;code&gt;pSparseMemoryRequirementCount&lt;/code&gt; is less than the number of sparse memory requirements available, at most &lt;code&gt;pSparseMemoryRequirementCount&lt;/code&gt; structures will be written.</source>
          <target state="translated">경우 &lt;code&gt;pSparseMemoryRequirements&lt;/code&gt; 가 있다 &lt;code&gt;NULL&lt;/code&gt; , 다음 가능한 스파 스 메모리 요구 사항의 수는 반환됩니다 &lt;code&gt;pSparseMemoryRequirementCount&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;pSparseMemoryRequirementCount&lt;/code&gt; &lt;strong&gt;는 &lt;/strong&gt; &lt;code&gt;pSparseMemoryRequirements&lt;/code&gt; 배열 의 요소 수를 사용자가 설정 한 변수를 가리켜 &lt;strong&gt;야&lt;/strong&gt; 하며 반환하면 변수는 실제로 &lt;code&gt;pSparseMemoryRequirements&lt;/code&gt; 에 실제로 작성된 구조 수로 덮어 씁니다 . 경우 &lt;code&gt;pSparseMemoryRequirementCount&lt;/code&gt; 가 최대 가능한 스파 스 메모리 요구 사항의 수보다 적은 &lt;code&gt;pSparseMemoryRequirementCount&lt;/code&gt; 의 구조에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="eb3f577bfc3106b4f325f3622aa3a0fd0975900a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pSpecializationInfo&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;pSpecializationInfo&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to a valid &lt;code&gt;VkSpecializationInfo&lt;/code&gt; structure</source>
          <target state="translated">경우 &lt;code&gt;pSpecializationInfo&lt;/code&gt; 이 아닌 &lt;code&gt;NULL&lt;/code&gt; 이 , &lt;code&gt;pSpecializationInfo&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 유효한 포인터가 될 &lt;code&gt;VkSpecializationInfo&lt;/code&gt; 의 구조</target>
        </trans-unit>
        <trans-unit id="1a7d26ead84a57c1b198f2d9cd849b58fdd65412" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pStages&lt;/code&gt; includes a fragment shader stage and a geometry shader stage, and the fragment shader code reads from an input variable that is decorated with &lt;code&gt;PrimitiveID&lt;/code&gt;, then the geometry shader code &lt;strong&gt;must&lt;/strong&gt; write to a matching output variable, decorated with &lt;code&gt;PrimitiveID&lt;/code&gt;, in all execution paths</source>
          <target state="translated">경우 &lt;code&gt;pStages&lt;/code&gt; 는 프래그먼트 쉐이더 코드가 장식 된 입력 변수로부터 판독 단편 쉐이더 스테이지 및 기하 구조 셰이더 스테이지, 및 포함 &lt;code&gt;PrimitiveID&lt;/code&gt; 을 다음 지오메트리 쉐이더 코드 &lt;strong&gt;해야&lt;/strong&gt; 장식 일치하는 출력 변수에 기록 &lt;code&gt;PrimitiveID&lt;/code&gt; 모든 실행 경로에서</target>
        </trans-unit>
        <trans-unit id="cb19585720d0f53bc6a9f47b1a01caedfa4e7faa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pStages&lt;/code&gt; includes a fragment shader stage, its shader code &lt;strong&gt;must&lt;/strong&gt; not read from any input attachment that is defined as &lt;code&gt;VK_ATTACHMENT_UNUSED&lt;/code&gt; in &lt;code&gt;subpass&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pStages&lt;/code&gt; 에 프래그먼트 셰이더 스테이지가 포함 된 경우 &lt;code&gt;subpass&lt;/code&gt; 에서 &lt;code&gt;VK_ATTACHMENT_UNUSED&lt;/code&gt; 로 정의 된 입력 첨부 파일에서 해당 셰이더 코드 &lt;strong&gt;를&lt;/strong&gt; 읽지 &lt;strong&gt;않아야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="213003591c9726b8d96fe3269ef35d40298ac3b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pStages&lt;/code&gt; includes a geometry shader stage, and also includes tessellation shader stages, its shader code &lt;strong&gt;must&lt;/strong&gt; contain an &lt;code&gt;OpExecutionMode&lt;/code&gt; instruction that specifies an input primitive type that is &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#shaders-geometry-execution&quot;&gt;compatible&lt;/a&gt; with the primitive topology that is output by the tessellation stages</source>
          <target state="translated">경우 &lt;code&gt;pStages&lt;/code&gt; 은 기하 구조 셰이더 스테이지를 포함하고, 또한 공간 분할 셰이더 스테이지를 포함하고, 그 셰이더 코드 &lt;strong&gt;해야&lt;/strong&gt; 포함 &lt;code&gt;OpExecutionMode&lt;/code&gt; 의 명령이 지정 입력 원시 형 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#shaders-geometry-execution&quot;&gt;호환&lt;/a&gt; 출력 공간 분할 단계에 의해 인 기본 토폴로지</target>
        </trans-unit>
        <trans-unit id="eb8a7b796bbee8c06d1c62be97220e1414bb0297" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pStages&lt;/code&gt; includes a geometry shader stage, and does not include any tessellation shader stages, its shader code &lt;strong&gt;must&lt;/strong&gt; contain an &lt;code&gt;OpExecutionMode&lt;/code&gt; instruction that specifies an input primitive type that is &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#shaders-geometry-execution&quot;&gt;compatible&lt;/a&gt; with the primitive topology specified in &lt;code&gt;pInputAssembly&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;pStages&lt;/code&gt; 은 기하 구조 셰이더 스테이지를 포함하고, 임의의 공간 분할 셰이더 스테이지를 포함하지 않으며, 그 셰이더 코드 &lt;strong&gt;해야&lt;/strong&gt; 포함 &lt;code&gt;OpExecutionMode&lt;/code&gt; 의 명령이 지정 입력 원시 형 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#shaders-geometry-execution&quot;&gt;호환&lt;/a&gt; 지정된 프리미티브 토폴로지 &lt;code&gt;pInputAssembly&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ffa5c1b756e6b407c6873938c09e46f11847b30b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pStages&lt;/code&gt; includes a tessellation control shader stage and a tessellation evaluation shader stage, &lt;code&gt;pTessellationState&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to a valid &lt;code&gt;VkPipelineTessellationStateCreateInfo&lt;/code&gt; structure</source>
          <target state="translated">경우 &lt;code&gt;pStages&lt;/code&gt; 가 공간 분할 제어 셰이더 스테이지 및 공간 분할 평가 셰이더 스테이지를 포함 &lt;code&gt;pTessellationState&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 유효한 포인터 될 &lt;code&gt;VkPipelineTessellationStateCreateInfo&lt;/code&gt; 의 구조</target>
        </trans-unit>
        <trans-unit id="11667038bd54bf1a284d2b65cc83153e3ace7d8e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pStages&lt;/code&gt; includes a tessellation control shader stage, it &lt;strong&gt;must&lt;/strong&gt; include a tessellation evaluation shader stage</source>
          <target state="translated">경우 &lt;code&gt;pStages&lt;/code&gt; 가 테셀레이션 제어 쉐이더 단계를 포함하고, 그것을 &lt;strong&gt;해야한다&lt;/strong&gt; 테셀레이션 평가 쉐이더 단계를 포함한다</target>
        </trans-unit>
        <trans-unit id="5bb0f8793e17212ab38eb23e9f17a21076afd3b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pStages&lt;/code&gt; includes a tessellation evaluation shader stage, it &lt;strong&gt;must&lt;/strong&gt; include a tessellation control shader stage</source>
          <target state="translated">경우 &lt;code&gt;pStages&lt;/code&gt; 가 테셀레이션 평가 쉐이더 단계를 포함하고, 그것을 &lt;strong&gt;해야한다&lt;/strong&gt; 테셀레이션 제어 쉐이더 단계를 포함한다</target>
        </trans-unit>
        <trans-unit id="78e5025e82088855d10a1ef954ee73c284187d76" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pStages&lt;/code&gt; includes tessellation shader stages, and the shader code of both contain an &lt;code&gt;OpExecutionMode&lt;/code&gt; instruction that specifies the out patch size in the pipeline, they &lt;strong&gt;must&lt;/strong&gt; both specify the same patch size</source>
          <target state="translated">경우 &lt;code&gt;pStages&lt;/code&gt; 는 테셀레이션 쉐이더 스테이지를 포함, 모두의 쉐이더 코드가 포함 &lt;code&gt;OpExecutionMode&lt;/code&gt; 의 지정 파이프 라인의 아웃 패치 크기, 그들은 것을 명령 &lt;strong&gt;한다&lt;/strong&gt; 모두 동일한 패치 크기를 지정을</target>
        </trans-unit>
        <trans-unit id="0005c332bde3a464753ffa0190fac02f633464b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pStages&lt;/code&gt; includes tessellation shader stages, and the shader code of both stages contain an &lt;code&gt;OpExecutionMode&lt;/code&gt; instruction that specifies the type of subdivision in the pipeline, they &lt;strong&gt;must&lt;/strong&gt; both specify the same subdivision mode</source>
          <target state="translated">경우 &lt;code&gt;pStages&lt;/code&gt; 는 테셀레이션 쉐이더 스테이지를 포함, 두 단계의 쉐이더 코드가 포함 &lt;code&gt;OpExecutionMode&lt;/code&gt; 의 지정 파이프 라인의 세분의 종류, 그들은 것을 명령 &lt;strong&gt;한다&lt;/strong&gt; 모두 같은 세분화 모드를 지정을</target>
        </trans-unit>
        <trans-unit id="53ac0926d13c197b37aaee0fccff625ee4aa432c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pStages&lt;/code&gt; includes tessellation shader stages, the &lt;code&gt;topology&lt;/code&gt; member of &lt;code&gt;pInputAssembly&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;VK_PRIMITIVE_TOPOLOGY_PATCH_LIST&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pStages&lt;/code&gt; 테셀레이션 셰이더 단계가 포함 된 경우 pInputAssembly 의 &lt;code&gt;topology&lt;/code&gt; 멤버는 &lt;code&gt;pInputAssembly&lt;/code&gt; &lt;strong&gt;여야&lt;/strong&gt; 합니다 &lt;code&gt;VK_PRIMITIVE_TOPOLOGY_PATCH_LIST&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="52833750bd46512d2b92fafa95eed4601178f6b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pStages&lt;/code&gt; includes tessellation shader stages, the shader code of at least one stage &lt;strong&gt;must&lt;/strong&gt; contain an &lt;code&gt;OpExecutionMode&lt;/code&gt; instruction that specifies the output patch size in the pipeline</source>
          <target state="translated">&lt;code&gt;pStages&lt;/code&gt; 테셀레이션 셰이더 단계가 포함 된 경우 하나 이상의 스테이지의 셰이더 코드 에는 파이프 라인의 출력 패치 크기를 지정 하는 &lt;code&gt;OpExecutionMode&lt;/code&gt; 명령이 포함 &lt;strong&gt;되어야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="7ceca0a7d060c9252f8d0038b3deeae591af9fa5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pStages&lt;/code&gt; includes tessellation shader stages, the shader code of at least one stage &lt;strong&gt;must&lt;/strong&gt; contain an &lt;code&gt;OpExecutionMode&lt;/code&gt; instruction that specifies the type of subdivision in the pipeline</source>
          <target state="translated">&lt;code&gt;pStages&lt;/code&gt; 테셀레이션 셰이더 단계가 포함 된 경우 하나 이상의 스테이지의 셰이더 코드 에는 파이프 라인의 하위 분할 유형을 지정 하는 &lt;code&gt;OpExecutionMode&lt;/code&gt; 명령이 포함 &lt;strong&gt;되어야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="300a07bf2e2f2f3d2c3bfdc070739b0d770e166b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pfnAllocation&lt;/code&gt; is unable to allocate the requested memory, it &lt;strong&gt;must&lt;/strong&gt; return &lt;code&gt;NULL&lt;/code&gt;. If the allocation was successful, it &lt;strong&gt;must&lt;/strong&gt; return a valid pointer to memory allocation containing at least &lt;code&gt;size&lt;/code&gt; bytes, and with the pointer value being a multiple of &lt;code&gt;alignment&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pfnAllocation&lt;/code&gt; 이 요청 된 메모리를 할당 할 수없는 경우 &lt;code&gt;NULL&lt;/code&gt; 을 리턴 &lt;strong&gt;해야 &lt;/strong&gt;합니다 . 할당이 성공한 경우, 최소 &lt;code&gt;size&lt;/code&gt; 바이트를 포함 하고 포인터 값이 &lt;code&gt;alignment&lt;/code&gt; 의 배수 인 메모리 할당에 대한 유효한 포인터를 반환 &lt;strong&gt;해야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="83a506a319b17911a2776da4addfa9a1b9cff263" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pfnAllocation&lt;/code&gt; returns &lt;code&gt;NULL&lt;/code&gt;, and if the implementation is unable to continue correct processing of the current command without the requested allocation, it &lt;strong&gt;must&lt;/strong&gt; treat this as a run-time error, and generate &lt;code&gt;VK_ERROR_OUT_OF_HOST_MEMORY&lt;/code&gt; at the appropriate time for the command in which the condition was detected, as described in &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fundamentals-errorcodes&quot;&gt;Return Codes&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;pfnAllocation&lt;/code&gt; 가 반환 &lt;code&gt;NULL&lt;/code&gt; 을 , 그리고 만약 구현이 요구 할당하지 않고 현재 명령의 올바른 처리를 계속할 수 없습니다, 그것은 &lt;strong&gt;해야한다&lt;/strong&gt; 런타임 오류로 취급하고, 생성 &lt;code&gt;VK_ERROR_OUT_OF_HOST_MEMORY&lt;/code&gt; 을 조건이었다있는 명령에 대한 적절한 시간에 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#fundamentals-errorcodes&quot;&gt;리턴 코드에&lt;/a&gt; 설명 된대로 감지되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ffe7fcd07be5d918a42aeda8864417b7ec77f249" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pipeline&lt;/code&gt; is a valid handle, it &lt;strong&gt;must&lt;/strong&gt; have been created, allocated, or retrieved from &lt;code&gt;device&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pipeline&lt;/code&gt; 이 유효한 핸들 인 경우 파이프 라인 은 &lt;code&gt;device&lt;/code&gt; 에서 생성, 할당 또는 검색 &lt;strong&gt;되어야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dd1e093825aae98411e5c75bc5bce2a22367e3c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pipeline&lt;/code&gt; is not &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE&lt;/a&gt;, &lt;code&gt;pipeline&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a valid &lt;code&gt;VkPipeline&lt;/code&gt; handle</source>
          <target state="translated">경우 &lt;code&gt;pipeline&lt;/code&gt; 아닌 &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE는&lt;/a&gt; , &lt;code&gt;pipeline&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 유효한 될 &lt;code&gt;VkPipeline&lt;/code&gt; 의 핸들</target>
        </trans-unit>
        <trans-unit id="153c798bd7e80fb9a1cc81610dd910ee4eca6c9b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pipelineBindPoint&lt;/code&gt; is &lt;code&gt;VK_PIPELINE_BIND_POINT_COMPUTE&lt;/code&gt;, &lt;code&gt;pipeline&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a compute pipeline</source>
          <target state="translated">&lt;code&gt;pipelineBindPoint&lt;/code&gt; 가 &lt;code&gt;VK_PIPELINE_BIND_POINT_COMPUTE&lt;/code&gt; 인 경우 파이프 라인 은 계산 파이프 &lt;code&gt;pipeline&lt;/code&gt; &lt;strong&gt;이어야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="e65fb2b6ffea4264715efda66841377dd8c6d045" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pipelineBindPoint&lt;/code&gt; is &lt;code&gt;VK_PIPELINE_BIND_POINT_COMPUTE&lt;/code&gt;, the &lt;code&gt;VkCommandPool&lt;/code&gt; that &lt;code&gt;commandBuffer&lt;/code&gt; was allocated from &lt;strong&gt;must&lt;/strong&gt; support compute operations</source>
          <target state="translated">경우 &lt;code&gt;pipelineBindPoint&lt;/code&gt; 가 있다 &lt;code&gt;VK_PIPELINE_BIND_POINT_COMPUTE&lt;/code&gt; 의 &lt;code&gt;VkCommandPool&lt;/code&gt; 것을 &lt;code&gt;commandBuffer&lt;/code&gt; 는 에서 할당 된 &lt;strong&gt;필수의&lt;/strong&gt; 지원 컴퓨팅 작업</target>
        </trans-unit>
        <trans-unit id="d94dfd102a7fe218368fba9a33854bf43d38f7c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pipelineBindPoint&lt;/code&gt; is &lt;code&gt;VK_PIPELINE_BIND_POINT_GRAPHICS&lt;/code&gt;, &lt;code&gt;pipeline&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a graphics pipeline</source>
          <target state="translated">&lt;code&gt;pipelineBindPoint&lt;/code&gt; 가 &lt;code&gt;VK_PIPELINE_BIND_POINT_GRAPHICS&lt;/code&gt; 인 경우 파이프 라인 은 그래픽 파이프 &lt;code&gt;pipeline&lt;/code&gt; &lt;strong&gt;이어야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="79745d136782dffd9e87c80e9ea1d76d57a37904" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pipelineBindPoint&lt;/code&gt; is &lt;code&gt;VK_PIPELINE_BIND_POINT_GRAPHICS&lt;/code&gt;, the &lt;code&gt;VkCommandPool&lt;/code&gt; that &lt;code&gt;commandBuffer&lt;/code&gt; was allocated from &lt;strong&gt;must&lt;/strong&gt; support graphics operations</source>
          <target state="translated">경우 &lt;code&gt;pipelineBindPoint&lt;/code&gt; 가 있다 &lt;code&gt;VK_PIPELINE_BIND_POINT_GRAPHICS&lt;/code&gt; 의 &lt;code&gt;VkCommandPool&lt;/code&gt; 것을 &lt;code&gt;commandBuffer&lt;/code&gt; 는 에서 할당 된 &lt;strong&gt;필수의&lt;/strong&gt; 지원 그래픽 작업</target>
        </trans-unit>
        <trans-unit id="91e6247dcaccbe1690e5c7ce77c176eb3cfcd4b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pipelineCache&lt;/code&gt; is a valid handle, it &lt;strong&gt;must&lt;/strong&gt; have been created, allocated, or retrieved from &lt;code&gt;device&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;pipelineCache&lt;/code&gt; 이 유효한 핸들이며, 그것은 &lt;strong&gt;해야한다&lt;/strong&gt; , 생성 할당, 또는에서 검색 한 &lt;code&gt;device&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="55aa495075c0d9098dea18ae49c7747449e50822" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pipelineCache&lt;/code&gt; is not &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE&lt;/a&gt;, &lt;code&gt;pipelineCache&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a valid &lt;code&gt;VkPipelineCache&lt;/code&gt; handle</source>
          <target state="translated">경우 &lt;code&gt;pipelineCache&lt;/code&gt; 가 아닌 &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE는&lt;/a&gt; , &lt;code&gt;pipelineCache&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 유효한 될 &lt;code&gt;VkPipelineCache&lt;/code&gt; 의 핸들</target>
        </trans-unit>
        <trans-unit id="7330ebc0d76fccefa3d8e5f30ef5bf6c1ab56477" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pipelineLayout&lt;/code&gt; is a valid handle, it &lt;strong&gt;must&lt;/strong&gt; have been created, allocated, or retrieved from &lt;code&gt;device&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;pipelineLayout&lt;/code&gt; 이 유효한 핸들이며, 그것은 &lt;strong&gt;해야한다&lt;/strong&gt; , 생성 할당, 또는에서 검색 한 &lt;code&gt;device&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b32aad41399cfbd52b5a3d8b48e3948f0aed9be0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pipelineLayout&lt;/code&gt; is not &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE&lt;/a&gt;, &lt;code&gt;pipelineLayout&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a valid &lt;code&gt;VkPipelineLayout&lt;/code&gt; handle</source>
          <target state="translated">경우 &lt;code&gt;pipelineLayout&lt;/code&gt; 가 아닌 &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE는&lt;/a&gt; , &lt;code&gt;pipelineLayout&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 유효한 될 &lt;code&gt;VkPipelineLayout&lt;/code&gt; 의 핸들</target>
        </trans-unit>
        <trans-unit id="e6c32346272df58ab1d1e9b0b89d995b751b681c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;preserveAttachmentCount&lt;/code&gt; is not &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;pPreserveAttachments&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to an array of &lt;code&gt;preserveAttachmentCount&lt;/code&gt;&lt;code&gt;uint32_t&lt;/code&gt; values</source>
          <target state="translated">경우 &lt;code&gt;preserveAttachmentCount&lt;/code&gt; 가 아닌 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;pPreserveAttachments&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 의 배열에 대한 포인터 &lt;code&gt;preserveAttachmentCount&lt;/code&gt; 의 &lt;code&gt;uint32_t&lt;/code&gt; 의 값</target>
        </trans-unit>
        <trans-unit id="b2b4de6164b1178a7cc5c35bcd7f277b6299f29d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pushConstantRangeCount&lt;/code&gt; is not &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;pPushConstantRanges&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to an array of &lt;code&gt;pushConstantRangeCount&lt;/code&gt; valid &lt;code&gt;VkPushConstantRange&lt;/code&gt; structures</source>
          <target state="translated">경우 &lt;code&gt;pushConstantRangeCount&lt;/code&gt; 가 아닌 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;pPushConstantRanges&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 의 배열에 대한 포인터가 될 &lt;code&gt;pushConstantRangeCount&lt;/code&gt; 유효 &lt;code&gt;VkPushConstantRange&lt;/code&gt; 의 구조</target>
        </trans-unit>
        <trans-unit id="f4ad28afe112ed8d3e1165be5d8e5b2a56e3f211" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;queryPool&lt;/code&gt; is a valid handle, it &lt;strong&gt;must&lt;/strong&gt; have been created, allocated, or retrieved from &lt;code&gt;device&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;queryPool&lt;/code&gt; 이 유효한 핸들이며, 그것은 &lt;strong&gt;해야한다&lt;/strong&gt; , 생성 할당, 또는에서 검색 한 &lt;code&gt;device&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df624fc3c9a3ca3bd7c06e66de993662fa456314" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;queryPool&lt;/code&gt; is not &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE&lt;/a&gt;, &lt;code&gt;queryPool&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a valid &lt;code&gt;VkQueryPool&lt;/code&gt; handle</source>
          <target state="translated">경우 &lt;code&gt;queryPool&lt;/code&gt; 가 아닌 &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE는&lt;/a&gt; , &lt;code&gt;queryPool&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 유효한 될 &lt;code&gt;VkQueryPool&lt;/code&gt; 의 핸들</target>
        </trans-unit>
        <trans-unit id="fc4e80608676bfa3839089a81b68a5edd01bfdfa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;queryType&lt;/code&gt; is &lt;code&gt;VK_QUERY_TYPE_PIPELINE_STATISTICS&lt;/code&gt;, &lt;code&gt;pipelineStatistics&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a valid combination of &lt;a href=&quot;#VkQueryPipelineStatisticFlagBits&quot;&gt;VkQueryPipelineStatisticFlagBits&lt;/a&gt; values</source>
          <target state="translated">경우 &lt;code&gt;queryType&lt;/code&gt; 가 있다 &lt;code&gt;VK_QUERY_TYPE_PIPELINE_STATISTICS&lt;/code&gt; 는 , &lt;code&gt;pipelineStatistics&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 유효한 조합 &lt;a href=&quot;#VkQueryPipelineStatisticFlagBits&quot;&gt;VkQueryPipelineStatisticFlagBits의&lt;/a&gt; 값</target>
        </trans-unit>
        <trans-unit id="062c47aadf45ed8ae37a3e498e3ebaa4d83d54de" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;range&lt;/code&gt; is not equal to &lt;code&gt;VK_WHOLE_SIZE&lt;/code&gt;, &lt;code&gt;range&lt;/code&gt; divided by the element size of &lt;code&gt;format&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than or equal to &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt;::&lt;code&gt;maxTexelBufferElements&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;range&lt;/code&gt; 같지 않은 &lt;code&gt;VK_WHOLE_SIZE&lt;/code&gt; , &lt;code&gt;range&lt;/code&gt; 의 소자 크기로 나눈 &lt;code&gt;format&lt;/code&gt; &lt;strong&gt;해야&lt;/strong&gt; 작거나보다 같 &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; :: &lt;code&gt;maxTexelBufferElements&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="18209f5bbd843ce50954c0c6fd2d76a4a4cee89f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;range&lt;/code&gt; is not equal to &lt;code&gt;VK_WHOLE_SIZE&lt;/code&gt;, &lt;code&gt;range&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a multiple of the element size of &lt;code&gt;format&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;range&lt;/code&gt; 같지 않은 &lt;code&gt;VK_WHOLE_SIZE&lt;/code&gt; , &lt;code&gt;range&lt;/code&gt; &lt;strong&gt;해야&lt;/strong&gt; 의 요소 크기의 배수 &lt;code&gt;format&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6464284a8211bbac6c292ea5a546f35dff72c004" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;range&lt;/code&gt; is not equal to &lt;code&gt;VK_WHOLE_SIZE&lt;/code&gt;, &lt;code&gt;range&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be greater than &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;range&lt;/code&gt; 같지 않은 &lt;code&gt;VK_WHOLE_SIZE&lt;/code&gt; , &lt;code&gt;range&lt;/code&gt; &lt;strong&gt;해야&lt;/strong&gt; 보다 커야 &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85c4a0c27ceb639c505406805e6b3f3ded8e776a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;range&lt;/code&gt; is not equal to &lt;code&gt;VK_WHOLE_SIZE&lt;/code&gt;, &lt;code&gt;range&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than or equal to the size of &lt;code&gt;buffer&lt;/code&gt; minus &lt;code&gt;offset&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;range&lt;/code&gt; 같지 않은 &lt;code&gt;VK_WHOLE_SIZE&lt;/code&gt; , &lt;code&gt;range&lt;/code&gt; &lt;strong&gt;해야&lt;/strong&gt; 미만이거나 크기와 동일한 &lt;code&gt;buffer&lt;/code&gt; 마이너스 &lt;code&gt;offset&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cb601e80277926542492492065c28f52577758e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;range&lt;/code&gt; is not equal to &lt;code&gt;VK_WHOLE_SIZE&lt;/code&gt;, the sum of &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;range&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than or equal to the size of &lt;code&gt;buffer&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;range&lt;/code&gt; 같지 않은 &lt;code&gt;VK_WHOLE_SIZE&lt;/code&gt; 의 합 &lt;code&gt;offset&lt;/code&gt; 및 &lt;code&gt;range&lt;/code&gt; &lt;strong&gt;해야&lt;/strong&gt; 미만이거나 크기와 동일한 &lt;code&gt;buffer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a65de0ab2f8072caf3955bc8c4ef35a66b1ecddb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;renderPass&lt;/code&gt; is a valid handle, it &lt;strong&gt;must&lt;/strong&gt; have been created, allocated, or retrieved from &lt;code&gt;device&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;renderPass&lt;/code&gt; 이 유효한 핸들이며, 그것은 &lt;strong&gt;해야한다&lt;/strong&gt; , 생성 할당, 또는에서 검색 한 &lt;code&gt;device&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="275fe845105cc67a32e7dba319813f55a65a2f0d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;renderPass&lt;/code&gt; is not &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE&lt;/a&gt;, &lt;code&gt;renderPass&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a valid &lt;code&gt;VkRenderPass&lt;/code&gt; handle</source>
          <target state="translated">경우 &lt;code&gt;renderPass&lt;/code&gt; 가 아닌 &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE는&lt;/a&gt; , &lt;code&gt;renderPass&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 유효한 될 &lt;code&gt;VkRenderPass&lt;/code&gt; 의 핸들</target>
        </trans-unit>
        <trans-unit id="c36d1568d390e977c6aace1b44e74c2e249ac9cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;robustBufferAccess&lt;/code&gt; is not enabled, out of bounds accesses &lt;strong&gt;may&lt;/strong&gt; corrupt any memory within the process and cause undefined behavior up to and including application termination.</source>
          <target state="translated">경우 &lt;code&gt;robustBufferAccess&lt;/code&gt; 는 경계의 접근에서, 사용할 수 없습니다 &lt;strong&gt;수도&lt;/strong&gt; 손상 프로세스 내 및 응용 프로그램 종료를 포함하여 정의에 행동까지와 원인을 어떤 메모리.</target>
        </trans-unit>
        <trans-unit id="3737725490e838b34ad6849d25eff798626d077a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sampler&lt;/code&gt; is a valid handle, it &lt;strong&gt;must&lt;/strong&gt; have been created, allocated, or retrieved from &lt;code&gt;device&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sampler&lt;/code&gt; 가 유효한 핸들 인 경우, 샘플러 가 &lt;code&gt;device&lt;/code&gt; 에서 작성, 할당 또는 검색 &lt;strong&gt;되어야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e357190d526fbbb656f4a22f0fcef2f17d283b8d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sampler&lt;/code&gt; is not &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE&lt;/a&gt;, &lt;code&gt;sampler&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a valid &lt;code&gt;VkSampler&lt;/code&gt; handle</source>
          <target state="translated">경우 &lt;code&gt;sampler&lt;/code&gt; 아닌 &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE&lt;/a&gt; , &lt;code&gt;sampler&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 유효한 될 &lt;code&gt;VkSampler&lt;/code&gt; 의 핸들</target>
        </trans-unit>
        <trans-unit id="c6c917d9762a763255446685be227d581f031636" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;samples&lt;/code&gt; is not &lt;code&gt;VK_SAMPLE_COUNT_1_BIT&lt;/code&gt;, &lt;code&gt;imageType&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;VK_IMAGE_TYPE_2D&lt;/code&gt;, &lt;code&gt;flags&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not contain &lt;code&gt;VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT&lt;/code&gt;, &lt;code&gt;tiling&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;VK_IMAGE_TILING_OPTIMAL&lt;/code&gt;, and &lt;code&gt;mipLevels&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be equal to &lt;code&gt;1&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;samples&lt;/code&gt; 아닌 &lt;code&gt;VK_SAMPLE_COUNT_1_BIT&lt;/code&gt; , &lt;code&gt;imageType&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;VK_IMAGE_TYPE_2D&lt;/code&gt; 는 , &lt;code&gt;flags&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 포함하지 &lt;code&gt;VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT&lt;/code&gt; 를 , &lt;code&gt;tiling&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;VK_IMAGE_TILING_OPTIMAL&lt;/code&gt; 및 &lt;code&gt;mipLevels&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 같아야 &lt;code&gt;1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="622fbf4139dbe05ef04be95046b07c95761146c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;semaphore&lt;/code&gt; is a valid handle, it &lt;strong&gt;must&lt;/strong&gt; have been created, allocated, or retrieved from &lt;code&gt;device&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;semaphore&lt;/code&gt; 유효한 핸들이며, 그것은 &lt;strong&gt;해야한다&lt;/strong&gt; , 생성 할당, 또는에서 검색 한 &lt;code&gt;device&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1ea5f5dd7ebae6132e1524a9a04f13436d8db52e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;semaphore&lt;/code&gt; is not &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE&lt;/a&gt;, &lt;code&gt;semaphore&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a valid &lt;code&gt;VkSemaphore&lt;/code&gt; handle</source>
          <target state="translated">경우 &lt;code&gt;semaphore&lt;/code&gt; 아닌 &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE&lt;/a&gt; , &lt;code&gt;semaphore&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 유효한 될 &lt;code&gt;VkSemaphore&lt;/code&gt; 의 핸들</target>
        </trans-unit>
        <trans-unit id="b4727b777295167d0a0ca0a100dcf9b245785ef2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setLayoutCount&lt;/code&gt; is not &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;pSetLayouts&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to an array of &lt;code&gt;setLayoutCount&lt;/code&gt; valid &lt;code&gt;VkDescriptorSetLayout&lt;/code&gt; handles</source>
          <target state="translated">경우 &lt;code&gt;setLayoutCount&lt;/code&gt; 가 아닌 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;pSetLayouts&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 의 배열에 대한 포인터 &lt;code&gt;setLayoutCount&lt;/code&gt; 유효 &lt;code&gt;VkDescriptorSetLayout&lt;/code&gt; 의 핸들</target>
        </trans-unit>
        <trans-unit id="e5586cedc1b99dbef66f7d21dbc3aa8050a6c247" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;shaderModule&lt;/code&gt; is a valid handle, it &lt;strong&gt;must&lt;/strong&gt; have been created, allocated, or retrieved from &lt;code&gt;device&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;shaderModule&lt;/code&gt; 이 유효한 핸들이며, 그것은 &lt;strong&gt;해야한다&lt;/strong&gt; , 생성 할당, 또는에서 검색 한 &lt;code&gt;device&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4138315de047300d0e6e1f3040a99831549f44b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;shaderModule&lt;/code&gt; is not &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE&lt;/a&gt;, &lt;code&gt;shaderModule&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a valid &lt;code&gt;VkShaderModule&lt;/code&gt; handle</source>
          <target state="translated">경우 &lt;code&gt;shaderModule&lt;/code&gt; 가 아닌 &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE&lt;/a&gt; , &lt;code&gt;shaderModule&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 유효한 될 &lt;code&gt;VkShaderModule&lt;/code&gt; 의 핸들</target>
        </trans-unit>
        <trans-unit id="8fb2a2d4b7cd5350c6daeb68edda0270f5e2d7b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sharingMode&lt;/code&gt; is &lt;code&gt;VK_SHARING_MODE_CONCURRENT&lt;/code&gt;, &lt;code&gt;pQueueFamilyIndices&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to an array of &lt;code&gt;queueFamilyIndexCount&lt;/code&gt;&lt;code&gt;uint32_t&lt;/code&gt; values</source>
          <target state="translated">경우 &lt;code&gt;sharingMode&lt;/code&gt; 가 있다 &lt;code&gt;VK_SHARING_MODE_CONCURRENT&lt;/code&gt; 는 , &lt;code&gt;pQueueFamilyIndices&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 의 배열에 대한 포인터 &lt;code&gt;queueFamilyIndexCount&lt;/code&gt; 의 &lt;code&gt;uint32_t&lt;/code&gt; 의 값</target>
        </trans-unit>
        <trans-unit id="4afca4c5c4a5e2d04c1de1e86322c58ac4c98d9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sharingMode&lt;/code&gt; is &lt;code&gt;VK_SHARING_MODE_CONCURRENT&lt;/code&gt;, &lt;code&gt;queueFamilyIndexCount&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be greater than &lt;code&gt;1&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;sharingMode&lt;/code&gt; 가 있다 &lt;code&gt;VK_SHARING_MODE_CONCURRENT&lt;/code&gt; 는 , &lt;code&gt;queueFamilyIndexCount&lt;/code&gt; 가&lt;strong&gt;있어야합니다&lt;/strong&gt; 보다 클 수 &lt;code&gt;1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f6fff539995d9897ce9a43f9b68e9b7d5a874db9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sharingMode&lt;/code&gt; is &lt;code&gt;VK_SHARING_MODE_CONCURRENT&lt;/code&gt;, each element of &lt;code&gt;pQueueFamilyIndices&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be unique and &lt;strong&gt;must&lt;/strong&gt; be less than &lt;code&gt;pQueueFamilyPropertyCount&lt;/code&gt; returned by &lt;a href=&quot;#vkGetPhysicalDeviceQueueFamilyProperties&quot;&gt;vkGetPhysicalDeviceQueueFamilyProperties&lt;/a&gt; for the &lt;code&gt;physicalDevice&lt;/code&gt; that was used to create &lt;code&gt;device&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;sharingMode&lt;/code&gt; 가 있다 &lt;code&gt;VK_SHARING_MODE_CONCURRENT&lt;/code&gt; 를 , 각 요소 &lt;code&gt;pQueueFamilyIndices&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 고유하고 &lt;strong&gt;있어야&lt;/strong&gt; 보다 적을 수 &lt;code&gt;pQueueFamilyPropertyCount&lt;/code&gt; 가 에 의해 반환 &lt;a href=&quot;#vkGetPhysicalDeviceQueueFamilyProperties&quot;&gt;vkGetPhysicalDeviceQueueFamilyProperties&lt;/a&gt; 에 대한 &lt;code&gt;physicalDevice&lt;/code&gt; 만드는 데 사용 된 &lt;code&gt;device&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1ade03a815b28bc25229d1f193bb2de9b3ff3295" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;signalSemaphoreCount&lt;/code&gt; is not &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;pSignalSemaphores&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to an array of &lt;code&gt;signalSemaphoreCount&lt;/code&gt; valid &lt;code&gt;VkSemaphore&lt;/code&gt; handles</source>
          <target state="translated">경우 &lt;code&gt;signalSemaphoreCount&lt;/code&gt; 가 아닌 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;pSignalSemaphores&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 의 배열에 대한 포인터 &lt;code&gt;signalSemaphoreCount&lt;/code&gt; 유효 &lt;code&gt;VkSemaphore&lt;/code&gt; 의 핸들</target>
        </trans-unit>
        <trans-unit id="ba4de3ca6f3e990e5bb5d52f0f8084869618250a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is equal to &lt;code&gt;VK_WHOLE_SIZE&lt;/code&gt;, &lt;code&gt;offset&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be within the currently mapped range of &lt;code&gt;memory&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; 가 &lt;code&gt;VK_WHOLE_SIZE&lt;/code&gt; 와 같은 경우 &lt;code&gt;offset&lt;/code&gt; &lt;strong&gt;은&lt;/strong&gt; 현재 매핑 된 &lt;code&gt;memory&lt;/code&gt; 범위 내에 &lt;strong&gt;있어야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="83baa27d95429da4f64c25163d16d23d5a48297f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is equal to &lt;code&gt;VK_WHOLE_SIZE&lt;/code&gt;, the end of the current mapping of &lt;code&gt;memory&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a multiple of &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt;::&lt;code&gt;nonCoherentAtomSize&lt;/code&gt; bytes from the beginning of the memory object.</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; 가 &lt;code&gt;VK_WHOLE_SIZE&lt;/code&gt; 와 같은 경우 , 현재 &lt;code&gt;memory&lt;/code&gt; 맵핑의 끝은 메모리 오브젝트의 시작에서 &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; :: &lt;code&gt;nonCoherentAtomSize&lt;/code&gt; 바이트 의 배수 &lt;strong&gt;여야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="cb388f6eb586cb54178b72666a25831a965945bb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is not equal to &lt;code&gt;VK_WHOLE_SIZE&lt;/code&gt;, &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; specify a range contained within the currently mapped range of &lt;code&gt;memory&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;size&lt;/code&gt; 와 동일하지 &lt;code&gt;VK_WHOLE_SIZE&lt;/code&gt; , &lt;code&gt;offset&lt;/code&gt; 및 &lt;code&gt;size&lt;/code&gt; &lt;strong&gt;해야&lt;/strong&gt; 의 현재 매핑 범위에 포함되는 범위 지정 &lt;code&gt;memory&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="68b79a1e21b8ebddebf20d0a97ada18f9b031ed8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is not equal to &lt;code&gt;VK_WHOLE_SIZE&lt;/code&gt;, &lt;code&gt;size&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a multiple of &lt;code&gt;4&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;size&lt;/code&gt; 동일하지 않습니다 &lt;code&gt;VK_WHOLE_SIZE&lt;/code&gt; , &lt;code&gt;size&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 의 배수 &lt;code&gt;4&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9cd031978c758143979d340abf2a92e403a97d69" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is not equal to &lt;code&gt;VK_WHOLE_SIZE&lt;/code&gt;, &lt;code&gt;size&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be greater than &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;size&lt;/code&gt; 동일하지 않습니다 &lt;code&gt;VK_WHOLE_SIZE&lt;/code&gt; , &lt;code&gt;size&lt;/code&gt; &lt;strong&gt;있어야합니다&lt;/strong&gt; 보다 클 수 &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5068a323fdf2f68f9c3c42efa9ad5c5e0e2f3243" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is not equal to &lt;code&gt;VK_WHOLE_SIZE&lt;/code&gt;, &lt;code&gt;size&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than or equal to than the size of &lt;code&gt;buffer&lt;/code&gt; minus &lt;code&gt;offset&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;size&lt;/code&gt; 동일하지 &lt;code&gt;VK_WHOLE_SIZE&lt;/code&gt; , &lt;code&gt;size&lt;/code&gt; &lt;strong&gt;해야&lt;/strong&gt; 미만이거나 크기와 같 &lt;code&gt;buffer&lt;/code&gt; 마이너스 &lt;code&gt;offset&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8192f3bc9447ff760e8000e9d3e05a3786778eec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is not equal to &lt;code&gt;VK_WHOLE_SIZE&lt;/code&gt;, &lt;code&gt;size&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than or equal to the size of &lt;code&gt;dstBuffer&lt;/code&gt; minus &lt;code&gt;dstOffset&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;size&lt;/code&gt; 동일하지 않습니다 &lt;code&gt;VK_WHOLE_SIZE&lt;/code&gt; , &lt;code&gt;size&lt;/code&gt; &lt;strong&gt;있어야합니다&lt;/strong&gt; 미만이거나의 크기와 동일 &lt;code&gt;dstBuffer&lt;/code&gt; 마이너스 &lt;code&gt;dstOffset&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="75330f62bbef69e255a5ea813f689b3e8a838835" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is not equal to &lt;code&gt;VK_WHOLE_SIZE&lt;/code&gt;, &lt;code&gt;size&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than or equal to the size of the &lt;code&gt;memory&lt;/code&gt; minus &lt;code&gt;offset&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;size&lt;/code&gt; 동일하지 &lt;code&gt;VK_WHOLE_SIZE&lt;/code&gt; , &lt;code&gt;size&lt;/code&gt; &lt;strong&gt;해야&lt;/strong&gt; 미만이거나 크기와 동일한 &lt;code&gt;memory&lt;/code&gt; 마이너스 &lt;code&gt;offset&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5350cb8e2ad2c14fd2839c8059f2181a3ace86a1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is not equal to &lt;code&gt;VK_WHOLE_SIZE&lt;/code&gt;, &lt;code&gt;size&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; either be a multiple of &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt;::&lt;code&gt;nonCoherentAtomSize&lt;/code&gt;, or &lt;code&gt;offset&lt;/code&gt; plus &lt;code&gt;size&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; equal the size of &lt;code&gt;memory&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;size&lt;/code&gt; 동일하지 않습니다 &lt;code&gt;VK_WHOLE_SIZE&lt;/code&gt; , &lt;code&gt;size&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 하나의 배수 &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; :: &lt;code&gt;nonCoherentAtomSize&lt;/code&gt; , 또는 &lt;code&gt;offset&lt;/code&gt; 을 더한 &lt;code&gt;size&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 의 크기와 동일 &lt;code&gt;memory&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4dbdc8e1811726d2151c3403e5c798079659f06b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is zero, then &lt;code&gt;pfnReallocation&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; behave equivalently to a call to &lt;a href=&quot;#PFN_vkFreeFunction&quot;&gt;PFN_vkFreeFunction&lt;/a&gt; with the same &lt;code&gt;pUserData&lt;/code&gt; parameter value, and &lt;code&gt;pMemory&lt;/code&gt; equal to &lt;code&gt;pOriginal&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;size&lt;/code&gt; 제로가 된 다음 &lt;code&gt;pfnReallocation&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 호출에 등가 동작 &lt;a href=&quot;#PFN_vkFreeFunction&quot;&gt;PFN_vkFreeFunction&lt;/a&gt; 동일한 함께 &lt;code&gt;pUserData&lt;/code&gt; 의 파라미터 값과 &lt;code&gt;pMemory&lt;/code&gt; 는 동일 &lt;code&gt;pOriginal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf291902a931747df9a3f6c891b499706f41aaed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;srcBuffer&lt;/code&gt; is non-sparse then it &lt;strong&gt;must&lt;/strong&gt; be bound completely and contiguously to a single &lt;code&gt;VkDeviceMemory&lt;/code&gt; object</source>
          <target state="translated">&lt;code&gt;srcBuffer&lt;/code&gt; 가 스파 스가 아닌 경우 단일 &lt;code&gt;VkDeviceMemory&lt;/code&gt; 객체에 완벽하고 연속적으로 바인딩 &lt;strong&gt;되어야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="fb91b7d3ce7d9cb1f3d3b39810ef42c6cc93eb92" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;srcImage&lt;/code&gt; is non-sparse then it &lt;strong&gt;must&lt;/strong&gt; be bound completely and contiguously to a single &lt;code&gt;VkDeviceMemory&lt;/code&gt; object</source>
          <target state="translated">경우 &lt;code&gt;srcImage&lt;/code&gt; 가 아닌 스파 스 다음이다가 &lt;strong&gt;있어야&lt;/strong&gt; 하나에 완전히 인접 구속 &lt;code&gt;VkDeviceMemory&lt;/code&gt; 의 객체</target>
        </trans-unit>
        <trans-unit id="a0e06b8fba3356608eb9f9039d3707df94d7b228" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;srcImage&lt;/code&gt; was created with a depth/stencil format, &lt;code&gt;filter&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;VK_FILTER_NEAREST&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;srcImage&lt;/code&gt; 가 깊이 / 스텐실 형식으로 작성된 경우 &lt;code&gt;filter&lt;/code&gt; &lt;strong&gt;는 &lt;/strong&gt; &lt;code&gt;VK_FILTER_NEAREST&lt;/code&gt; &lt;strong&gt;여야&lt;/strong&gt; 합니다 .</target>
        </trans-unit>
        <trans-unit id="6bc5b1d084e318ee3b1585c3047a0e6056a66fd4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;srcQueueFamilyIndex&lt;/code&gt; is not equal to &lt;code&gt;dstQueueFamilyIndex&lt;/code&gt;, and &lt;code&gt;srcQueueFamilyIndex&lt;/code&gt; is equal to the current queue family, then the memory barrier defines a &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-queue-transfers-release&quot;&gt;queue family release operation&lt;/a&gt; for the specified buffer range, and the second access scope includes no access, as if &lt;code&gt;dstAccessMask&lt;/code&gt; was &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;srcQueueFamilyIndex&lt;/code&gt; 가 동일하지 &lt;code&gt;dstQueueFamilyIndex&lt;/code&gt; 및 &lt;code&gt;srcQueueFamilyIndex&lt;/code&gt; 은 현재 큐 패밀리와 동일하고 상기 메모리 배리어는 정의 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-queue-transfers-release&quot;&gt;대기열 가족 해제 조작을&lt;/a&gt; 지정된 버퍼 영역에 대한 한 것처럼 제 2 액세스 범위, 접근을 포함하지 &lt;code&gt;dstAccessMask&lt;/code&gt; 가 있었다 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8bcfc93911c3dd8c779a6a290100ddd630eff2c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;srcQueueFamilyIndex&lt;/code&gt; is not equal to &lt;code&gt;dstQueueFamilyIndex&lt;/code&gt;, and &lt;code&gt;srcQueueFamilyIndex&lt;/code&gt; is equal to the current queue family, then the memory barrier defines a &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-queue-transfers-release&quot;&gt;queue family release operation&lt;/a&gt; for the specified image subresource range, and the second access scope includes no access, as if &lt;code&gt;dstAccessMask&lt;/code&gt; was &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;srcQueueFamilyIndex&lt;/code&gt; 가 동일하지 &lt;code&gt;dstQueueFamilyIndex&lt;/code&gt; 및 &lt;code&gt;srcQueueFamilyIndex&lt;/code&gt; 은 현재 큐 패밀리와 동일하고 상기 메모리 배리어는 정의 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-queue-transfers-release&quot;&gt;대기열 가족 해제 조작을&lt;/a&gt; 지정된 화상 하위 리소스 범위 및 듯이 제 2 액세스 범위, 접근을 포함하지 &lt;code&gt;dstAccessMask&lt;/code&gt; 가 있었다 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1c2e43230d9c591238c84f5389159dbc0a813af" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;srcSet&lt;/code&gt; is equal to &lt;code&gt;dstSet&lt;/code&gt;, then the source and destination ranges of descriptors &lt;strong&gt;must&lt;/strong&gt; not overlap, where the ranges &lt;strong&gt;may&lt;/strong&gt; include array elements from consecutive bindings as described by &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-updates-consecutive&quot;&gt;html/vkspec.html#descriptorsets-updates-consecutive&lt;/a&gt;</source>
          <target state="translated">경우 &lt;code&gt;srcSet&lt;/code&gt; 는 동일하다 &lt;code&gt;dstSet&lt;/code&gt; , 다음 설명의 소스 및 대상 범위 &lt;strong&gt;해야&lt;/strong&gt; 하지 오버랩 범위는 어디 &lt;strong&gt;있다&lt;/strong&gt; 의해 기술 된 바와 같이 연속적인 바인딩의 배열 요소를 포함하는 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-updates-consecutive&quot;&gt;HTML / vkspec.html # descriptorsets 업데이트와 연속&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f9f07c4a81ca9f9a0bea0bb52245c5c2a103aba2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;srcSubpass&lt;/code&gt; is equal to &lt;code&gt;VK_SUBPASS_EXTERNAL&lt;/code&gt;, the first &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-scopes&quot;&gt;synchronization scope&lt;/a&gt; includes commands submitted to the queue before the render pass instance began. Otherwise, the first set of commands includes all commands submitted as part of the subpass instance identified by &lt;code&gt;srcSubpass&lt;/code&gt; and any load, store or multisample resolve operations on attachments used in &lt;code&gt;srcSubpass&lt;/code&gt;. In either case, the first synchronization scope is limited to operations on the pipeline stages determined by the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks&quot;&gt;source stage mask&lt;/a&gt; specified by &lt;code&gt;srcStageMask&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;srcSubpass&lt;/code&gt; 이 동일 &lt;code&gt;VK_SUBPASS_EXTERNAL&lt;/code&gt; 첫 번째 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-scopes&quot;&gt;동기화 범위는&lt;/a&gt; 시작 렌더링 패스 인스턴스 전에 큐에 제출 명령이 포함됩니다. 그렇지 않으면 첫 번째 명령 세트에는 &lt;code&gt;srcSubpass&lt;/code&gt; 로 식별 된 서브 패스 인스턴스의 일부로 제출 된 모든 명령 과 &lt;code&gt;srcSubpass&lt;/code&gt; 에서 사용되는 첨부 파일에 대한로드, 저장 또는 멀티 샘플 분석 작업이 포함됩니다 . 두 경우 모두 첫 번째 동기화 범위는 &lt;code&gt;srcStageMask&lt;/code&gt; 로 지정된 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks&quot;&gt;소스 스테이지 마스크에&lt;/a&gt; 의해 결정된 파이프 라인 스테이지에서의 조작으로 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="d19d8edab63e16ac7f6f9e2fda1a61a776c79a66" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;srcSubpass&lt;/code&gt; is equal to &lt;code&gt;dstSubpass&lt;/code&gt; and not all of the stages in &lt;code&gt;srcStageMask&lt;/code&gt; and &lt;code&gt;dstStageMask&lt;/code&gt; are &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-framebuffer-regions&quot;&gt;framebuffer-space stages&lt;/a&gt;, the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-order&quot;&gt;logically latest&lt;/a&gt; pipeline stage in &lt;code&gt;srcStageMask&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-order&quot;&gt;logically earlier&lt;/a&gt; than or equal to the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-order&quot;&gt;logically earliest&lt;/a&gt; pipeline stage in &lt;code&gt;dstStageMask&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;srcSubpass&lt;/code&gt; 이 동일 &lt;code&gt;dstSubpass&lt;/code&gt; 및 모든의 단계로 &lt;code&gt;srcStageMask&lt;/code&gt; 및 &lt;code&gt;dstStageMask&lt;/code&gt; 있는 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-framebuffer-regions&quot;&gt;프레임 버퍼 공간 단계는&lt;/a&gt; 1, &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-order&quot;&gt;논리적으로 최신&lt;/a&gt; 의 파이프 라인 단계 &lt;code&gt;srcStageMask&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-order&quot;&gt;논리적으로 이전&lt;/a&gt; 보다 또는 동일한 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-order&quot;&gt;논리적으로 최초&lt;/a&gt; 의 파이프 라인 단계 &lt;code&gt;dstStageMask&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eeaab6a9e6b95fcd6597a5a895785078ad946840" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;srcSubpass&lt;/code&gt; is equal to &lt;code&gt;dstSubpass&lt;/code&gt; then the &lt;a href=&quot;#VkSubpassDependency&quot;&gt;VkSubpassDependency&lt;/a&gt; describes a &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-barriers-subpass-self-dependencies&quot;&gt;subpass self-dependency&lt;/a&gt;, and only constrains the pipeline barriers allowed within a subpass instance. Otherwise, when a render pass instance which includes a subpass dependency is submitted to a queue, it defines a memory dependency between the subpasses identified by &lt;code&gt;srcSubpass&lt;/code&gt; and &lt;code&gt;dstSubpass&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;srcSubpass&lt;/code&gt; 가 같은지 &lt;code&gt;dstSubpass&lt;/code&gt; 다음 &lt;a href=&quot;#VkSubpassDependency&quot;&gt;VkSubpassDependency는&lt;/a&gt; 설명 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-barriers-subpass-self-dependencies&quot;&gt;subpass 셀프 의존성&lt;/a&gt; 및 단지 subpass 인스턴스 내에서 허용 배관 장벽을 제한한다. 그렇지 않으면 서브 패스 종속성을 포함하는 렌더 패스 인스턴스가 큐에 제출 될 때 &lt;code&gt;srcSubpass&lt;/code&gt; 및 &lt;code&gt;dstSubpass&lt;/code&gt; 로 식별되는 서브 패스 사이의 메모리 종속성을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="978a929a9112561f6136620a5377b29577d82714" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;srcSubpass&lt;/code&gt; is equal to &lt;code&gt;dstSubpass&lt;/code&gt;, &lt;code&gt;srcStageMask&lt;/code&gt; and &lt;code&gt;dstStageMask&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; only contain one of &lt;code&gt;VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT&lt;/code&gt;, &lt;code&gt;VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT&lt;/code&gt;, &lt;code&gt;VK_PIPELINE_STAGE_VERTEX_INPUT_BIT&lt;/code&gt;, &lt;code&gt;VK_PIPELINE_STAGE_VERTEX_SHADER_BIT&lt;/code&gt;, &lt;code&gt;VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT&lt;/code&gt;, &lt;code&gt;VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT&lt;/code&gt;, &lt;code&gt;VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT&lt;/code&gt;, &lt;code&gt;VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT&lt;/code&gt;, &lt;code&gt;VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT&lt;/code&gt;, &lt;code&gt;VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT&lt;/code&gt;, &lt;code&gt;VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT&lt;/code&gt;, &lt;code&gt;VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT&lt;/code&gt;, or &lt;code&gt;VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;srcSubpass&lt;/code&gt; 이 동일 &lt;code&gt;dstSubpass&lt;/code&gt; , &lt;code&gt;srcStageMask&lt;/code&gt; 및 &lt;code&gt;dstStageMask&lt;/code&gt; &lt;strong&gt;합니다&lt;/strong&gt; 단지 중 하나가 포함 &lt;code&gt;VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT&lt;/code&gt; , &lt;code&gt;VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT&lt;/code&gt; , &lt;code&gt;VK_PIPELINE_STAGE_VERTEX_INPUT_BIT&lt;/code&gt; , &lt;code&gt;VK_PIPELINE_STAGE_VERTEX_SHADER_BIT&lt;/code&gt; , &lt;code&gt;VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT&lt;/code&gt; , &lt;code&gt;VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT&lt;/code&gt; , &lt;code&gt;VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT&lt;/code&gt; , &lt;code&gt;VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT&lt;/code&gt; , &lt;code&gt;VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT&lt;/code&gt; 을 , &lt;code&gt;VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT&lt;/code&gt; , &lt;code&gt;VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT&lt;/code&gt; , &lt;code&gt;VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT&lt;/code&gt; 또는 &lt;code&gt;VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f501e61ce1770c956aa3132270d802ffe6de6ee3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;srcSubpass&lt;/code&gt; is not &lt;code&gt;VK_SUBPASS_EXTERNAL&lt;/code&gt;, &lt;code&gt;srcStageMask&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not include &lt;code&gt;VK_PIPELINE_STAGE_HOST_BIT&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;srcSubpass&lt;/code&gt; 가 아닌 &lt;code&gt;VK_SUBPASS_EXTERNAL&lt;/code&gt; , &lt;code&gt;srcStageMask&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 포함되지 &lt;code&gt;VK_PIPELINE_STAGE_HOST_BIT&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="5025b47f7e7b9b794b1f35b6c63948847ac7e0c3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stage&lt;/code&gt; is &lt;code&gt;VK_SHADER_STAGE_FRAGMENT_BIT&lt;/code&gt;, and the identified entry point writes to &lt;code&gt;FragDepth&lt;/code&gt; in any execution path, it &lt;strong&gt;must&lt;/strong&gt; write to &lt;code&gt;FragDepth&lt;/code&gt; in all execution paths</source>
          <target state="translated">경우에는 &lt;code&gt;stage&lt;/code&gt; 있다 &lt;code&gt;VK_SHADER_STAGE_FRAGMENT_BIT&lt;/code&gt; , 식별 된 엔트리 포인트가 기록 &lt;code&gt;FragDepth&lt;/code&gt; 모든 실행 경로, 그것은 &lt;strong&gt;해야&lt;/strong&gt; 쓸 &lt;code&gt;FragDepth&lt;/code&gt; 모든 실행 경로에</target>
        </trans-unit>
        <trans-unit id="d4d1a85cda4e9a8a005025571770f85ff5f1bd3b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stage&lt;/code&gt; is &lt;code&gt;VK_SHADER_STAGE_FRAGMENT_BIT&lt;/code&gt;, the identified entry point &lt;strong&gt;must&lt;/strong&gt; not include any output variables in its interface decorated with &lt;code&gt;CullDistance&lt;/code&gt;</source>
          <target state="translated">경우에는 &lt;code&gt;stage&lt;/code&gt; 있다 &lt;code&gt;VK_SHADER_STAGE_FRAGMENT_BIT&lt;/code&gt; , 식별 진입 점은 &lt;strong&gt;있어야&lt;/strong&gt; 장식의 인터페이스에서 모든 출력 변수에 포함되지 &lt;code&gt;CullDistance&lt;/code&gt; 를</target>
        </trans-unit>
        <trans-unit id="19af5ab2cdea1da8ccecbc47b5668432b1d53523" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stage&lt;/code&gt; is &lt;code&gt;VK_SHADER_STAGE_GEOMETRY_BIT&lt;/code&gt;, and the identified entry point writes to &lt;code&gt;Layer&lt;/code&gt; for any primitive, it &lt;strong&gt;must&lt;/strong&gt; write the same value to &lt;code&gt;Layer&lt;/code&gt; for all vertices of a given primitive</source>
          <target state="translated">경우에는 &lt;code&gt;stage&lt;/code&gt; 있다 &lt;code&gt;VK_SHADER_STAGE_GEOMETRY_BIT&lt;/code&gt; 하고, 식별 된 엔트리 포인트가 기록 &lt;code&gt;Layer&lt;/code&gt; 어떤 원시적 위해, 그것은 &lt;strong&gt;해야한다&lt;/strong&gt; 에 같은 값 쓰기 &lt;code&gt;Layer&lt;/code&gt; 원시 주어진 모든 정점</target>
        </trans-unit>
        <trans-unit id="96b678b2769b81fb70880249cf761e75525a3991" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stage&lt;/code&gt; is &lt;code&gt;VK_SHADER_STAGE_GEOMETRY_BIT&lt;/code&gt;, and the identified entry point writes to &lt;code&gt;ViewportIndex&lt;/code&gt; for any primitive, it &lt;strong&gt;must&lt;/strong&gt; write the same value to &lt;code&gt;ViewportIndex&lt;/code&gt; for all vertices of a given primitive</source>
          <target state="translated">경우에는 &lt;code&gt;stage&lt;/code&gt; 있다 &lt;code&gt;VK_SHADER_STAGE_GEOMETRY_BIT&lt;/code&gt; , 식별 된 엔트리 포인트가 기록 &lt;code&gt;ViewportIndex&lt;/code&gt; 어떤 원시적 위해, 그것은 &lt;strong&gt;해야한다&lt;/strong&gt; 에 같은 값 쓰기 &lt;code&gt;ViewportIndex&lt;/code&gt; 을 원시적 주어진 모든 정점</target>
        </trans-unit>
        <trans-unit id="5cc35bec0c0c8211a5be73f9baefe47b0800c9b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stage&lt;/code&gt; is &lt;code&gt;VK_SHADER_STAGE_GEOMETRY_BIT&lt;/code&gt;, the identified entry point &lt;strong&gt;must&lt;/strong&gt; have an &lt;code&gt;OpExecutionMode&lt;/code&gt; instruction that specifies a maximum output vertex count that is greater than &lt;code&gt;0&lt;/code&gt; and less than or equal to &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt;::&lt;code&gt;maxGeometryOutputVertices&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;stage&lt;/code&gt; 이다 &lt;code&gt;VK_SHADER_STAGE_GEOMETRY_BIT&lt;/code&gt; , 식별 된 엔트리 포인트가 &lt;strong&gt;되어야&lt;/strong&gt; 이 &lt;code&gt;OpExecutionMode&lt;/code&gt; 를 지정하는 최대 출력 개수보다 큰하다 정점 것을 지시 &lt;code&gt;0&lt;/code&gt; 이하 또는보다 같 &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; :: &lt;code&gt;maxGeometryOutputVertices&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="e3123aa202dae40e344cf98021c261fd3c1688b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stage&lt;/code&gt; is &lt;code&gt;VK_SHADER_STAGE_GEOMETRY_BIT&lt;/code&gt;, the identified entry point &lt;strong&gt;must&lt;/strong&gt; have an &lt;code&gt;OpExecutionMode&lt;/code&gt; instruction that specifies an invocation count that is greater than &lt;code&gt;0&lt;/code&gt; and less than or equal to &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt;::&lt;code&gt;maxGeometryShaderInvocations&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;stage&lt;/code&gt; 이다 &lt;code&gt;VK_SHADER_STAGE_GEOMETRY_BIT&lt;/code&gt; , 식별 된 엔트리 포인트가 &lt;strong&gt;되어야&lt;/strong&gt; 이 &lt;code&gt;OpExecutionMode&lt;/code&gt; 의 명령임을 지정 초과 인 호출 횟수 &lt;code&gt;0&lt;/code&gt; 미만 또는 동등 &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; :: &lt;code&gt;maxGeometryShaderInvocations&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="14336233f83a1a875d7ef4782f9c637f4a415fb1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stage&lt;/code&gt; is &lt;code&gt;VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT&lt;/code&gt; or &lt;code&gt;VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT&lt;/code&gt;, and the identified entry point has an &lt;code&gt;OpExecutionMode&lt;/code&gt; instruction that specifies a patch size with &lt;code&gt;OutputVertices&lt;/code&gt;, the patch size &lt;strong&gt;must&lt;/strong&gt; be greater than &lt;code&gt;0&lt;/code&gt; and less than or equal to &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt;::&lt;code&gt;maxTessellationPatchSize&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;stage&lt;/code&gt; 이다 &lt;code&gt;VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT&lt;/code&gt; 또는 &lt;code&gt;VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT&lt;/code&gt; , 상기 식별 된 엔트리 포인트가 보유 &lt;code&gt;OpExecutionMode&lt;/code&gt; 의 지정과 패치 사이즈 것을 지시 &lt;code&gt;OutputVertices&lt;/code&gt; 은 , 패치 사이즈가 &lt;strong&gt;되어야&lt;/strong&gt; 이상이어야 &lt;code&gt;0&lt;/code&gt; 미만 또는 동등 &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; 을 :: &lt;code&gt;maxTessellationPatchSize&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fcf6aab237a51f7f3f6be89c221ac939f001cb6f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stage&lt;/code&gt; is &lt;code&gt;VK_SHADER_STAGE_VERTEX_BIT&lt;/code&gt;, the identified entry point &lt;strong&gt;must&lt;/strong&gt; not include any input variable in its interface that is decorated with &lt;code&gt;CullDistance&lt;/code&gt;</source>
          <target state="translated">경우에는 &lt;code&gt;stage&lt;/code&gt; 있다 &lt;code&gt;VK_SHADER_STAGE_VERTEX_BIT&lt;/code&gt; 식별 된 엔트리 포인트는 &lt;strong&gt;있어야&lt;/strong&gt; 로 장식되어 그 인터페이스의 모든 입력 변수를 포함하지 &lt;code&gt;CullDistance&lt;/code&gt; 를</target>
        </trans-unit>
        <trans-unit id="ddfe64a877c66cbff31b0ef967ab689fd04daa94" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;submitCount&lt;/code&gt; is not &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;pSubmits&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to an array of &lt;code&gt;submitCount&lt;/code&gt; valid &lt;code&gt;VkSubmitInfo&lt;/code&gt; structures</source>
          <target state="translated">경우 &lt;code&gt;submitCount&lt;/code&gt; 가 아닌 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;pSubmits&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 의 배열에 대한 포인터가 될 &lt;code&gt;submitCount&lt;/code&gt; 유효 &lt;code&gt;VkSubmitInfo&lt;/code&gt; 의 구조</target>
        </trans-unit>
        <trans-unit id="8b22f8ce469128faaf2105600af1b9bab5f34e7a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;subpass&lt;/code&gt; does not use any color and/or depth/stencil attachments, then the &lt;code&gt;rasterizationSamples&lt;/code&gt; member of &lt;code&gt;pMultisampleState&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; follow the rules for a &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-noattachments&quot;&gt;zero-attachment subpass&lt;/a&gt;</source>
          <target state="translated">경우 &lt;code&gt;subpass&lt;/code&gt; 는 색상 및 / 또는 깊이를 사용하지 않습니다 / 스텐실 첨부 파일을 누른 다음 &lt;code&gt;rasterizationSamples&lt;/code&gt; 의 회원 &lt;code&gt;pMultisampleState&lt;/code&gt; 는&lt;strong&gt;해야한다&lt;/strong&gt; A에 대한 규칙에 따라 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-noattachments&quot;&gt;제로 부착 subpass을&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80062285e79829a64633dcf028bade488b30164d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;subpass&lt;/code&gt; uses color and/or depth/stencil attachments, then the &lt;code&gt;rasterizationSamples&lt;/code&gt; member of &lt;code&gt;pMultisampleState&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be the same as the sample count for those subpass attachments</source>
          <target state="translated">경우 &lt;code&gt;subpass&lt;/code&gt; 의 용도 색상 및 / 또는 깊이 / 스텐실 첨부 후 &lt;code&gt;rasterizationSamples&lt;/code&gt; 의 멤버 &lt;code&gt;pMultisampleState&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 그 subpass 첨부의 샘플 카운트와 동일 할</target>
        </trans-unit>
        <trans-unit id="d45245f5d72b2a93dc45eb463d64bbfb427b9f9b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;subresourceRange&lt;/code&gt;::&lt;code&gt;layerCount&lt;/code&gt; is not &lt;code&gt;VK_REMAINING_ARRAY_LAYERS&lt;/code&gt;, &lt;code&gt;subresourceRange&lt;/code&gt;::&lt;code&gt;layerCount&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be non-zero and &lt;code&gt;subresourceRange&lt;/code&gt;::&lt;code&gt;baseArrayLayer&lt;/code&gt; + &lt;code&gt;subresourceRange&lt;/code&gt;::&lt;code&gt;layerCount&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than or equal to the &lt;code&gt;arrayLayers&lt;/code&gt; specified in &lt;a href=&quot;#VkImageCreateInfo&quot;&gt;VkImageCreateInfo&lt;/a&gt; when &lt;code&gt;image&lt;/code&gt; was created</source>
          <target state="translated">경우 &lt;code&gt;subresourceRange&lt;/code&gt; :: &lt;code&gt;layerCount&lt;/code&gt; 가 아닌 &lt;code&gt;VK_REMAINING_ARRAY_LAYERS&lt;/code&gt; , &lt;code&gt;subresourceRange&lt;/code&gt; :: &lt;code&gt;layerCount&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 비제하고 &lt;code&gt;subresourceRange&lt;/code&gt; :: &lt;code&gt;baseArrayLayer&lt;/code&gt; + &lt;code&gt;subresourceRange&lt;/code&gt; :: &lt;code&gt;layerCount&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 미만이거나 동일 &lt;code&gt;arrayLayers&lt;/code&gt; 에 지정된 &lt;a href=&quot;#VkImageCreateInfo&quot;&gt;VkImageCreateInfo&lt;/a&gt; 때 &lt;code&gt;image&lt;/code&gt; 작성된</target>
        </trans-unit>
        <trans-unit id="43e4d55f3b317a61219dffabf0c886f8f743508f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;subresourceRange&lt;/code&gt;::&lt;code&gt;levelCount&lt;/code&gt; is not &lt;code&gt;VK_REMAINING_MIP_LEVELS&lt;/code&gt;, &lt;code&gt;subresourceRange&lt;/code&gt;::&lt;code&gt;levelCount&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be non-zero and &lt;code&gt;subresourceRange&lt;/code&gt;::&lt;code&gt;baseMipLevel&lt;/code&gt; + &lt;code&gt;subresourceRange&lt;/code&gt;::&lt;code&gt;levelCount&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than or equal to the &lt;code&gt;mipLevels&lt;/code&gt; specified in &lt;a href=&quot;#VkImageCreateInfo&quot;&gt;VkImageCreateInfo&lt;/a&gt; when &lt;code&gt;image&lt;/code&gt; was created</source>
          <target state="translated">경우 &lt;code&gt;subresourceRange&lt;/code&gt; :: &lt;code&gt;levelCount&lt;/code&gt; 가 되지 &lt;code&gt;VK_REMAINING_MIP_LEVELS&lt;/code&gt; , &lt;code&gt;subresourceRange&lt;/code&gt; :: &lt;code&gt;levelCount&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 비제 될 &lt;code&gt;subresourceRange&lt;/code&gt; :: &lt;code&gt;baseMipLevel&lt;/code&gt; + &lt;code&gt;subresourceRange&lt;/code&gt; :: &lt;code&gt;levelCount&lt;/code&gt; &lt;strong&gt;해야&lt;/strong&gt; 하거나 동등 이상이어야 &lt;code&gt;mipLevels&lt;/code&gt; 에 지정된 &lt;a href=&quot;#VkImageCreateInfo&quot;&gt;VkImageCreateInfo&lt;/a&gt; 때 &lt;code&gt;image&lt;/code&gt; 작성된</target>
        </trans-unit>
        <trans-unit id="7c08fecc0a33ce2cdc8681c05d96b4ef8778a607" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tiling&lt;/code&gt; is &lt;code&gt;VK_IMAGE_TILING_LINEAR&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a format that has at least one supported feature bit present in the value of &lt;code&gt;VkFormatProperties&lt;/code&gt;::&lt;code&gt;linearTilingFeatures&lt;/code&gt; returned by &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; with the same value of &lt;code&gt;format&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;tiling&lt;/code&gt; 인 &lt;code&gt;VK_IMAGE_TILING_LINEAR&lt;/code&gt; 는 , &lt;code&gt;format&lt;/code&gt; &lt;strong&gt;해야&lt;/strong&gt; 값에 적어도 하나의 지원 기능을 갖는 본 비트 포맷 될 &lt;code&gt;VkFormatProperties&lt;/code&gt; :: &lt;code&gt;linearTilingFeatures&lt;/code&gt; 의해 반환 &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; 동일한 값 &lt;code&gt;format&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4b50aa038d71c9a45af8aa2db0d76bf884dec7ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tiling&lt;/code&gt; is &lt;code&gt;VK_IMAGE_TILING_LINEAR&lt;/code&gt;, and &lt;code&gt;VkFormatProperties&lt;/code&gt;::&lt;code&gt;linearTilingFeatures&lt;/code&gt; (as returned by &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; with the same value of &lt;code&gt;format&lt;/code&gt;) does not include &lt;code&gt;VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT&lt;/code&gt;, &lt;code&gt;usage&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not contain &lt;code&gt;VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;tiling&lt;/code&gt; 입니다 &lt;code&gt;VK_IMAGE_TILING_LINEAR&lt;/code&gt; 및 &lt;code&gt;VkFormatProperties&lt;/code&gt; :: &lt;code&gt;linearTilingFeatures&lt;/code&gt; (에 의해 반환 &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; 의 값이 같은 &lt;code&gt;format&lt;/code&gt; )에 포함되지 않습니다 &lt;code&gt;VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT&lt;/code&gt; 을 , &lt;code&gt;usage&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 포함하지 &lt;code&gt;VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="0408c48825b4f934b6d3194548586c61bda074f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tiling&lt;/code&gt; is &lt;code&gt;VK_IMAGE_TILING_LINEAR&lt;/code&gt;, and &lt;code&gt;VkFormatProperties&lt;/code&gt;::&lt;code&gt;linearTilingFeatures&lt;/code&gt; (as returned by &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; with the same value of &lt;code&gt;format&lt;/code&gt;) does not include &lt;code&gt;VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT&lt;/code&gt;, &lt;code&gt;usage&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not contain &lt;code&gt;VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;tiling&lt;/code&gt; 입니다 &lt;code&gt;VK_IMAGE_TILING_LINEAR&lt;/code&gt; 및 &lt;code&gt;VkFormatProperties&lt;/code&gt; :: &lt;code&gt;linearTilingFeatures&lt;/code&gt; (에 의해 반환 &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; 의 값이 같은 &lt;code&gt;format&lt;/code&gt; )에 포함되지 않습니다 &lt;code&gt;VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT&lt;/code&gt; 을 , &lt;code&gt;usage&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 포함하지 &lt;code&gt;VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="f8479c7b8afd50ca3481781981a5f9b841d0fd14" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tiling&lt;/code&gt; is &lt;code&gt;VK_IMAGE_TILING_LINEAR&lt;/code&gt;, and &lt;code&gt;VkFormatProperties&lt;/code&gt;::&lt;code&gt;linearTilingFeatures&lt;/code&gt; (as returned by &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; with the same value of &lt;code&gt;format&lt;/code&gt;) does not include &lt;code&gt;VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT&lt;/code&gt;, &lt;code&gt;usage&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not contain &lt;code&gt;VK_IMAGE_USAGE_SAMPLED_BIT&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;tiling&lt;/code&gt; 입니다 &lt;code&gt;VK_IMAGE_TILING_LINEAR&lt;/code&gt; 및 &lt;code&gt;VkFormatProperties&lt;/code&gt; :: &lt;code&gt;linearTilingFeatures&lt;/code&gt; (에 의해 반환 &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; 의 값이 같은 &lt;code&gt;format&lt;/code&gt; )에 포함되지 않습니다 &lt;code&gt;VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT&lt;/code&gt; 을 , &lt;code&gt;usage&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 포함하지 &lt;code&gt;VK_IMAGE_USAGE_SAMPLED_BIT&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="ad8ec6ae153d14c693bb0295d05ea3e12c923416" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tiling&lt;/code&gt; is &lt;code&gt;VK_IMAGE_TILING_LINEAR&lt;/code&gt;, and &lt;code&gt;VkFormatProperties&lt;/code&gt;::&lt;code&gt;linearTilingFeatures&lt;/code&gt; (as returned by &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; with the same value of &lt;code&gt;format&lt;/code&gt;) does not include &lt;code&gt;VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT&lt;/code&gt;, &lt;code&gt;usage&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not contain &lt;code&gt;VK_IMAGE_USAGE_STORAGE_BIT&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;tiling&lt;/code&gt; 입니다 &lt;code&gt;VK_IMAGE_TILING_LINEAR&lt;/code&gt; 및 &lt;code&gt;VkFormatProperties&lt;/code&gt; :: &lt;code&gt;linearTilingFeatures&lt;/code&gt; (에 의해 반환 &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; 의 값이 같은 &lt;code&gt;format&lt;/code&gt; )에 포함되지 않습니다 &lt;code&gt;VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT&lt;/code&gt; 을 , &lt;code&gt;usage&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 포함하지 &lt;code&gt;VK_IMAGE_USAGE_STORAGE_BIT&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="c01c4f2f6043a75ee3727652f8b9ddddf2319e37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tiling&lt;/code&gt; is &lt;code&gt;VK_IMAGE_TILING_OPTIMAL&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a format that has at least one supported feature bit present in the value of &lt;code&gt;VkFormatProperties&lt;/code&gt;::&lt;code&gt;optimalTilingFeatures&lt;/code&gt; returned by &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; with the same value of &lt;code&gt;format&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;tiling&lt;/code&gt; 인 &lt;code&gt;VK_IMAGE_TILING_OPTIMAL&lt;/code&gt; 는 , &lt;code&gt;format&lt;/code&gt; &lt;strong&gt;해야&lt;/strong&gt; 값에 적어도 하나의 지원 기능을 갖는 본 비트 포맷 될 &lt;code&gt;VkFormatProperties&lt;/code&gt; :: &lt;code&gt;optimalTilingFeatures&lt;/code&gt; 의해 반환 &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; 동일한 값 &lt;code&gt;format&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2249b8c6490e0ede46732558ea7e24acfedc9b51" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tiling&lt;/code&gt; is &lt;code&gt;VK_IMAGE_TILING_OPTIMAL&lt;/code&gt;, and &lt;code&gt;VkFormatProperties&lt;/code&gt;::&lt;code&gt;optimalTilingFeatures&lt;/code&gt; (as returned by &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; with the same value of &lt;code&gt;format&lt;/code&gt;) does not include &lt;code&gt;VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT&lt;/code&gt;, &lt;code&gt;usage&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not contain &lt;code&gt;VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;tiling&lt;/code&gt; 입니다 &lt;code&gt;VK_IMAGE_TILING_OPTIMAL&lt;/code&gt; 및 &lt;code&gt;VkFormatProperties&lt;/code&gt; :: &lt;code&gt;optimalTilingFeatures&lt;/code&gt; (에 의해 반환 &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; 의 값이 같은 &lt;code&gt;format&lt;/code&gt; )에 포함되지 않습니다 &lt;code&gt;VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT&lt;/code&gt; 을 , &lt;code&gt;usage&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 포함하지 &lt;code&gt;VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="80d814f06f90bdc8262c0e4a58793a2f0ba72e48" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tiling&lt;/code&gt; is &lt;code&gt;VK_IMAGE_TILING_OPTIMAL&lt;/code&gt;, and &lt;code&gt;VkFormatProperties&lt;/code&gt;::&lt;code&gt;optimalTilingFeatures&lt;/code&gt; (as returned by &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; with the same value of &lt;code&gt;format&lt;/code&gt;) does not include &lt;code&gt;VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT&lt;/code&gt;, &lt;code&gt;usage&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not contain &lt;code&gt;VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;tiling&lt;/code&gt; 입니다 &lt;code&gt;VK_IMAGE_TILING_OPTIMAL&lt;/code&gt; 및 &lt;code&gt;VkFormatProperties&lt;/code&gt; :: &lt;code&gt;optimalTilingFeatures&lt;/code&gt; (에 의해 반환 &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; 의 값이 같은 &lt;code&gt;format&lt;/code&gt; )에 포함되지 않습니다 &lt;code&gt;VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT&lt;/code&gt; 을 , &lt;code&gt;usage&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 포함하지 &lt;code&gt;VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="01ea73ea010f32c9a2c10914801d55d5474d2a4b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tiling&lt;/code&gt; is &lt;code&gt;VK_IMAGE_TILING_OPTIMAL&lt;/code&gt;, and &lt;code&gt;VkFormatProperties&lt;/code&gt;::&lt;code&gt;optimalTilingFeatures&lt;/code&gt; (as returned by &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; with the same value of &lt;code&gt;format&lt;/code&gt;) does not include &lt;code&gt;VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT&lt;/code&gt;, &lt;code&gt;usage&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not contain &lt;code&gt;VK_IMAGE_USAGE_SAMPLED_BIT&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;tiling&lt;/code&gt; 입니다 &lt;code&gt;VK_IMAGE_TILING_OPTIMAL&lt;/code&gt; 및 &lt;code&gt;VkFormatProperties&lt;/code&gt; :: &lt;code&gt;optimalTilingFeatures&lt;/code&gt; (에 의해 반환 &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; 의 값이 같은 &lt;code&gt;format&lt;/code&gt; )에 포함되지 않습니다 &lt;code&gt;VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT&lt;/code&gt; 을 , &lt;code&gt;usage&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 포함하지 &lt;code&gt;VK_IMAGE_USAGE_SAMPLED_BIT&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="4486968e83939391a7139547743ff61c4923a03b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tiling&lt;/code&gt; is &lt;code&gt;VK_IMAGE_TILING_OPTIMAL&lt;/code&gt;, and &lt;code&gt;VkFormatProperties&lt;/code&gt;::&lt;code&gt;optimalTilingFeatures&lt;/code&gt; (as returned by &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; with the same value of &lt;code&gt;format&lt;/code&gt;) does not include &lt;code&gt;VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT&lt;/code&gt;, &lt;code&gt;usage&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not contain &lt;code&gt;VK_IMAGE_USAGE_STORAGE_BIT&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;tiling&lt;/code&gt; 입니다 &lt;code&gt;VK_IMAGE_TILING_OPTIMAL&lt;/code&gt; 및 &lt;code&gt;VkFormatProperties&lt;/code&gt; :: &lt;code&gt;optimalTilingFeatures&lt;/code&gt; (에 의해 반환 &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt; 의 값이 같은 &lt;code&gt;format&lt;/code&gt; )에 포함되지 않습니다 &lt;code&gt;VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT&lt;/code&gt; 을 , &lt;code&gt;usage&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 포함하지 &lt;code&gt;VK_IMAGE_USAGE_STORAGE_BIT&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="61138376fa0dd3280f0894ce7bb28042836b562f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeout&lt;/code&gt; is zero, then &lt;code&gt;vkWaitForFences&lt;/code&gt; does not wait, but simply returns the current state of the fences. &lt;code&gt;VK_TIMEOUT&lt;/code&gt; will be returned in this case if the condition is not satisfied, even though no actual wait was performed.</source>
          <target state="translated">경우 &lt;code&gt;timeout&lt;/code&gt; 제로, 다음 &lt;code&gt;vkWaitForFences&lt;/code&gt; 는 대기하지 않고, 단순히 울타리의 현재 상태를 반환합니다. 이 경우 실제 대기가 수행되지 않았어도 조건이 충족되지 않으면 &lt;code&gt;VK_TIMEOUT&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="a3db896b36e9a6285762adc1bc77a9e4b9a98ce6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;topology&lt;/code&gt; is &lt;code&gt;VK_PRIMITIVE_TOPOLOGY_POINT_LIST&lt;/code&gt;, &lt;code&gt;VK_PRIMITIVE_TOPOLOGY_LINE_LIST&lt;/code&gt;, &lt;code&gt;VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST&lt;/code&gt;, &lt;code&gt;VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY&lt;/code&gt;, &lt;code&gt;VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY&lt;/code&gt; or &lt;code&gt;VK_PRIMITIVE_TOPOLOGY_PATCH_LIST&lt;/code&gt;, &lt;code&gt;primitiveRestartEnable&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;VK_FALSE&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;topology&lt;/code&gt; 입니다 &lt;code&gt;VK_PRIMITIVE_TOPOLOGY_POINT_LIST&lt;/code&gt; , &lt;code&gt;VK_PRIMITIVE_TOPOLOGY_LINE_LIST&lt;/code&gt; , &lt;code&gt;VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST&lt;/code&gt; , &lt;code&gt;VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY&lt;/code&gt; , &lt;code&gt;VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY&lt;/code&gt; 또는 &lt;code&gt;VK_PRIMITIVE_TOPOLOGY_PATCH_LIST&lt;/code&gt; , &lt;code&gt;primitiveRestartEnable&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;VK_FALSE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2513b26f83f775149353507c10c5b4c7d9eeb526" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;unnormalizedCoordinates&lt;/code&gt; is &lt;code&gt;VK_TRUE&lt;/code&gt;, &lt;code&gt;addressModeU&lt;/code&gt; and &lt;code&gt;addressModeV&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; each be either &lt;code&gt;VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE&lt;/code&gt; or &lt;code&gt;VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;unnormalizedCoordinates&lt;/code&gt; 가 있다 &lt;code&gt;VK_TRUE&lt;/code&gt; , &lt;code&gt;addressModeU&lt;/code&gt; 및 &lt;code&gt;addressModeV&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 각이 될 &lt;code&gt;VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE&lt;/code&gt; 또는 &lt;code&gt;VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f6ed384594ec3af9530c2a5ca0e0212a819ca93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;unnormalizedCoordinates&lt;/code&gt; is &lt;code&gt;VK_TRUE&lt;/code&gt;, &lt;code&gt;anisotropyEnable&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;VK_FALSE&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;unnormalizedCoordinates&lt;/code&gt; 가 있다 &lt;code&gt;VK_TRUE&lt;/code&gt; 는 , &lt;code&gt;anisotropyEnable&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;VK_FALSE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="108b578ae950a46d15d7e7ca762da489b503505d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;unnormalizedCoordinates&lt;/code&gt; is &lt;code&gt;VK_TRUE&lt;/code&gt;, &lt;code&gt;compareEnable&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;VK_FALSE&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;unnormalizedCoordinates&lt;/code&gt; 가 있다 &lt;code&gt;VK_TRUE&lt;/code&gt; 는 , &lt;code&gt;compareEnable&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;VK_FALSE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="711b08667e8fbbb426c788633d42154f9a952707" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;unnormalizedCoordinates&lt;/code&gt; is &lt;code&gt;VK_TRUE&lt;/code&gt;, &lt;code&gt;minFilter&lt;/code&gt; and &lt;code&gt;magFilter&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be equal</source>
          <target state="translated">경우 &lt;code&gt;unnormalizedCoordinates&lt;/code&gt; 가 있다 &lt;code&gt;VK_TRUE&lt;/code&gt; , &lt;code&gt;minFilter&lt;/code&gt; 및 &lt;code&gt;magFilter&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 동일</target>
        </trans-unit>
        <trans-unit id="f56cb764b4003309184b0eac5046487f1a152a1a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;unnormalizedCoordinates&lt;/code&gt; is &lt;code&gt;VK_TRUE&lt;/code&gt;, &lt;code&gt;minLod&lt;/code&gt; and &lt;code&gt;maxLod&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be zero</source>
          <target state="translated">경우 &lt;code&gt;unnormalizedCoordinates&lt;/code&gt; 가 있다 &lt;code&gt;VK_TRUE&lt;/code&gt; , &lt;code&gt;minLod&lt;/code&gt; 및 &lt;code&gt;maxLod&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 제로가</target>
        </trans-unit>
        <trans-unit id="8fe3ddf5707902c32840189beed374864037170c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;unnormalizedCoordinates&lt;/code&gt; is &lt;code&gt;VK_TRUE&lt;/code&gt;, &lt;code&gt;mipmapMode&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;VK_SAMPLER_MIPMAP_MODE_NEAREST&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;unnormalizedCoordinates&lt;/code&gt; 가 있다 &lt;code&gt;VK_TRUE&lt;/code&gt; 을 , &lt;code&gt;mipmapMode&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;VK_SAMPLER_MIPMAP_MODE_NEAREST&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f99bff9d113353f8f3202309087c84060f88aca4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;usage&lt;/code&gt; includes &lt;code&gt;VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT&lt;/code&gt;, &lt;code&gt;VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT&lt;/code&gt;, &lt;code&gt;VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT&lt;/code&gt;, or &lt;code&gt;VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT&lt;/code&gt;, &lt;code&gt;extent.height&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than or equal to &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt;::&lt;code&gt;maxFramebufferHeight&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;usage&lt;/code&gt; 포함 &lt;code&gt;VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT&lt;/code&gt; , &lt;code&gt;VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT&lt;/code&gt; , &lt;code&gt;VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT&lt;/code&gt; , 또는 &lt;code&gt;VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT&lt;/code&gt; 을 , &lt;code&gt;extent.height&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 미만이거나 동일 &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; :: &lt;code&gt;maxFramebufferHeight&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8afa752821d12a83edcd945d128877706a235bb5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;usage&lt;/code&gt; includes &lt;code&gt;VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT&lt;/code&gt;, &lt;code&gt;VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT&lt;/code&gt;, &lt;code&gt;VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT&lt;/code&gt;, or &lt;code&gt;VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT&lt;/code&gt;, &lt;code&gt;extent.width&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than or equal to &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt;::&lt;code&gt;maxFramebufferWidth&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;usage&lt;/code&gt; 포함 &lt;code&gt;VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT&lt;/code&gt; , &lt;code&gt;VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT&lt;/code&gt; , &lt;code&gt;VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT&lt;/code&gt; , 또는 &lt;code&gt;VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT&lt;/code&gt; 을 , &lt;code&gt;extent.width&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 미만이거나 동일 &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; :: &lt;code&gt;maxFramebufferWidth&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eccc97274f3941607f668346c19f8e36741764af" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;usage&lt;/code&gt; includes &lt;code&gt;VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT&lt;/code&gt;, &lt;code&gt;usage&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; also contain at least one of &lt;code&gt;VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT&lt;/code&gt;, &lt;code&gt;VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT&lt;/code&gt;, or &lt;code&gt;VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;usage&lt;/code&gt; 포함 &lt;code&gt;VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT&lt;/code&gt; 을 , &lt;code&gt;usage&lt;/code&gt; &lt;strong&gt;해야한다&lt;/strong&gt; 또한 중 적어도 하나에 포함 &lt;code&gt;VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT&lt;/code&gt; , &lt;code&gt;VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT&lt;/code&gt; , 또는 &lt;code&gt;VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76393a083820885cf9ce4be3c6742d3a66f99a9a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;usage&lt;/code&gt; includes &lt;code&gt;VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT&lt;/code&gt;, then bits other than &lt;code&gt;VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT&lt;/code&gt;, &lt;code&gt;VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT&lt;/code&gt;, and &lt;code&gt;VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not be set</source>
          <target state="translated">경우 &lt;code&gt;usage&lt;/code&gt; 포함 &lt;code&gt;VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT&lt;/code&gt; 을 , 다음 이외의 비트 &lt;code&gt;VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT&lt;/code&gt; , &lt;code&gt;VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT&lt;/code&gt; 및 &lt;code&gt;VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 설정할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="d4ed83503aa522c07cf2654c843e82263f3f3fa5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;vertexAttributeDescriptionCount&lt;/code&gt; is not &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;pVertexAttributeDescriptions&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to an array of &lt;code&gt;vertexAttributeDescriptionCount&lt;/code&gt; valid &lt;code&gt;VkVertexInputAttributeDescription&lt;/code&gt; structures</source>
          <target state="translated">경우 &lt;code&gt;vertexAttributeDescriptionCount&lt;/code&gt; 가 아닌 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;pVertexAttributeDescriptions&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 의 배열에 대한 포인터가 될 &lt;code&gt;vertexAttributeDescriptionCount&lt;/code&gt; 유효 &lt;code&gt;VkVertexInputAttributeDescription&lt;/code&gt; 의 구조</target>
        </trans-unit>
        <trans-unit id="f6d2eef7dc4d5a6dffbdabdbf4523a5aedb58b50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;vertexBindingDescriptionCount&lt;/code&gt; is not &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;pVertexBindingDescriptions&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to an array of &lt;code&gt;vertexBindingDescriptionCount&lt;/code&gt; valid &lt;code&gt;VkVertexInputBindingDescription&lt;/code&gt; structures</source>
          <target state="translated">경우 &lt;code&gt;vertexBindingDescriptionCount&lt;/code&gt; 가 아닌 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;pVertexBindingDescriptions&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 의 배열에 대한 포인터가 될 &lt;code&gt;vertexBindingDescriptionCount&lt;/code&gt; 유효 &lt;code&gt;VkVertexInputBindingDescription&lt;/code&gt; 의 구조</target>
        </trans-unit>
        <trans-unit id="085cb7c0494557371c697180db36c0d656e2a28c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;vkCmdExecuteCommands&lt;/code&gt; is being called within a render pass instance, and any given element of &lt;code&gt;pCommandBuffers&lt;/code&gt; was recorded with &lt;code&gt;VkCommandBufferInheritanceInfo&lt;/code&gt;::&lt;code&gt;framebuffer&lt;/code&gt; not equal to &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE&lt;/a&gt;, that &lt;code&gt;VkFramebuffer&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; match the &lt;code&gt;VkFramebuffer&lt;/code&gt; used in the current render pass instance</source>
          <target state="translated">경우 &lt;code&gt;vkCmdExecuteCommands&lt;/code&gt; 가 렌더 패스 인스턴스 내에서 호출되고, 그리고 주어진 요소 &lt;code&gt;pCommandBuffers&lt;/code&gt; 가 함께 기록 된 &lt;code&gt;VkCommandBufferInheritanceInfo&lt;/code&gt; :: &lt;code&gt;framebuffer&lt;/code&gt; 동일하지 &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE&lt;/a&gt; 것을, &lt;code&gt;VkFramebuffer&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 경기 &lt;code&gt;VkFramebuffer&lt;/code&gt; 이 통과 인스턴스를 현재 렌더링에 사용</target>
        </trans-unit>
        <trans-unit id="c3d9ff9407f5087bff0177127505f82279c8de9d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;vkCmdExecuteCommands&lt;/code&gt; is being called within a render pass instance, any given element of &lt;code&gt;pCommandBuffers&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; have been recorded with &lt;code&gt;VkCommandBufferInheritanceInfo&lt;/code&gt;::&lt;code&gt;subpass&lt;/code&gt; set to the index of the subpass which the given command buffer will be executed in</source>
          <target state="translated">경우 &lt;code&gt;vkCmdExecuteCommands&lt;/code&gt; 는 패스 렌더링 인스턴스 내에서 호출되고, 임의의 주어진 소자 &lt;code&gt;pCommandBuffers&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 촬영 한 &lt;code&gt;VkCommandBufferInheritanceInfo&lt;/code&gt; :: &lt;code&gt;subpass&lt;/code&gt; 의 지정된 명령 버퍼에서 실행될 subpass의 인덱스로 설정</target>
        </trans-unit>
        <trans-unit id="fcb7ec537ca482ef38a23f3ba4a1ace8650d1ca3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;vkCmdExecuteCommands&lt;/code&gt; is being called within a render pass instance, any given element of &lt;code&gt;pCommandBuffers&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; have been recorded with the &lt;code&gt;VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;vkCmdExecuteCommands&lt;/code&gt; 가 렌더 패스 인스턴스 내에서 호출되고, 어떤 주어진 요소 &lt;code&gt;pCommandBuffers&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 에서 촬영 한 &lt;code&gt;VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="57cda5e75741ca2d535ab2110353f810b5b060ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;vkCmdExecuteCommands&lt;/code&gt; is being called within a render pass instance, that render pass instance &lt;strong&gt;must&lt;/strong&gt; have been begun with the &lt;code&gt;contents&lt;/code&gt; parameter of &lt;code&gt;vkCmdBeginRenderPass&lt;/code&gt; set to &lt;code&gt;VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;vkCmdExecuteCommands&lt;/code&gt; 이 렌더링 그, 렌더 패스 인스턴스 내에서 호출되는 패스의 인스턴스가 &lt;strong&gt;있어야합니다&lt;/strong&gt; 와 함께 시작 된 &lt;code&gt;contents&lt;/code&gt; 의 매개 변수 &lt;code&gt;vkCmdBeginRenderPass&lt;/code&gt; 의 로 설정 &lt;code&gt;VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3204c63d8fb1d44b1b8e72e64dc84a3e442bb5c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;vkCmdExecuteCommands&lt;/code&gt; is being called within a render pass instance, the render passes specified in the pname::pBeginInfo::&lt;code&gt;pInheritanceInfo&lt;/code&gt;::&lt;code&gt;renderPass&lt;/code&gt; members of the &lt;a href=&quot;#vkBeginCommandBuffer&quot;&gt;vkBeginCommandBuffer&lt;/a&gt; commands used to begin recording each element of &lt;code&gt;pCommandBuffers&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-compatibility&quot;&gt;compatible&lt;/a&gt; with the current render pass.</source>
          <target state="translated">경우 &lt;code&gt;vkCmdExecuteCommands&lt;/code&gt; 가 렌더 패스 인스턴스 내에서 호출되고는이 PNAME에 지정된 패스 렌더링 :: pBeginInfo :: &lt;code&gt;pInheritanceInfo&lt;/code&gt; :: &lt;code&gt;renderPass&lt;/code&gt; 의 의 구성원 &lt;a href=&quot;#vkBeginCommandBuffer&quot;&gt;vkBeginCommandBuffer은&lt;/a&gt; 각 요소에 녹음을 시작하는 데 사용되는 명령 &lt;code&gt;pCommandBuffers&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-compatibility&quot;&gt;호환&lt;/a&gt; 패스를 렌더링 전류.</target>
        </trans-unit>
        <trans-unit id="b8d113f2af6d5779e85b36754769afcc60f77e2c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;vkCmdExecuteCommands&lt;/code&gt; is not being called within a render pass instance, any given element of &lt;code&gt;pCommandBuffers&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not have been recorded with the &lt;code&gt;VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;vkCmdExecuteCommands&lt;/code&gt; 가 렌더 패스 인스턴스 내에서 호출되지 않고, 주어진 어떤 요소 &lt;code&gt;pCommandBuffers&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 에서 촬영 한하지 &lt;code&gt;VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d18f309a67a1f502982000697b4d2be78757756c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;vkCmdPipelineBarrier&lt;/code&gt; is called within a render pass instance, &lt;code&gt;bufferMemoryBarrierCount&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;vkCmdPipelineBarrier&lt;/code&gt; 가 렌더 패스 인스턴스 내에서 호출되어, &lt;code&gt;bufferMemoryBarrierCount&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6512310347911f642cfb78cd99ba1d56f27e4d72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;vkCmdPipelineBarrier&lt;/code&gt; is called within a render pass instance, &lt;code&gt;dependencyFlags&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be equal to the &lt;code&gt;dependencyFlags&lt;/code&gt; member of that instance of &lt;code&gt;VkSubpassDependency&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;vkCmdPipelineBarrier&lt;/code&gt; 가 렌더 패스 인스턴스 내에서 호출되어, &lt;code&gt;dependencyFlags&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 받는 동일 &lt;code&gt;dependencyFlags&lt;/code&gt; 의 의 인스턴스의 멤버 &lt;code&gt;VkSubpassDependency&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c930c1c7a76400675434eb1cef20d73cf78c891b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;vkCmdPipelineBarrier&lt;/code&gt; is called within a render pass instance, &lt;code&gt;dstStageMask&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; contain a subset of the bit values in the &lt;code&gt;dstStageMask&lt;/code&gt; member of that instance of &lt;code&gt;VkSubpassDependency&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;vkCmdPipelineBarrier&lt;/code&gt; 가 렌더 패스 인스턴스 내에서 호출되어, &lt;code&gt;dstStageMask&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 의 비트 값의 하위 집합을 포함 &lt;code&gt;dstStageMask&lt;/code&gt; 의 의 인스턴스의 멤버 &lt;code&gt;VkSubpassDependency&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="199c7cd0622fec5b7294f194c934d0f79513aa78" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;vkCmdPipelineBarrier&lt;/code&gt; is called within a render pass instance, &lt;code&gt;srcStageMask&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; contain a subset of the bit values in the &lt;code&gt;srcStageMask&lt;/code&gt; member of that instance of &lt;code&gt;VkSubpassDependency&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;vkCmdPipelineBarrier&lt;/code&gt; 가 렌더 패스 인스턴스 내에서 호출되어, &lt;code&gt;srcStageMask&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 의 비트 값의 하위 집합을 포함 &lt;code&gt;srcStageMask&lt;/code&gt; 의 의 인스턴스의 멤버 &lt;code&gt;VkSubpassDependency&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="83b5fdd568a0864780640f1adb86b1951b7f80d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;vkCmdPipelineBarrier&lt;/code&gt; is called within a render pass instance, the &lt;code&gt;dstAccessMask&lt;/code&gt; of any element of &lt;code&gt;pMemoryBarriers&lt;/code&gt; or &lt;code&gt;pImageMemoryBarriers&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; contain a subset of the bit values the &lt;code&gt;dstAccessMask&lt;/code&gt; member of that instance of &lt;code&gt;VkSubpassDependency&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;vkCmdPipelineBarrier&lt;/code&gt; 가 렌더 패스 인스턴스 내에서 호출되면, &lt;code&gt;dstAccessMask&lt;/code&gt; 의 요소의 &lt;code&gt;pMemoryBarriers&lt;/code&gt; 또는 &lt;code&gt;pImageMemoryBarriers&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 비트 값의 하위 집합에게 포함 &lt;code&gt;dstAccessMask&lt;/code&gt; 의 의 인스턴스의 멤버 &lt;code&gt;VkSubpassDependency&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="8f65cae104b834670d471e2fc0456c256a18668b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;vkCmdPipelineBarrier&lt;/code&gt; is called within a render pass instance, the &lt;code&gt;image&lt;/code&gt; member of any element of &lt;code&gt;pImageMemoryBarriers&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be equal to one of the elements of &lt;code&gt;pAttachments&lt;/code&gt; that the current &lt;code&gt;framebuffer&lt;/code&gt; was created with, that is also referred to by one of the elements of the &lt;code&gt;pColorAttachments&lt;/code&gt;, &lt;code&gt;pResolveAttachments&lt;/code&gt; or &lt;code&gt;pDepthStencilAttachment&lt;/code&gt; members of the &lt;code&gt;VkSubpassDescription&lt;/code&gt; instance that the current subpass was created with</source>
          <target state="translated">경우 &lt;code&gt;vkCmdPipelineBarrier&lt;/code&gt; 가 렌더링 패스 인스턴스 내에서 호출되면, &lt;code&gt;image&lt;/code&gt; 의 임의의 요소의 부재 &lt;code&gt;pImageMemoryBarriers&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 의 요소들 중 하나와 동일 할 &lt;code&gt;pAttachments&lt;/code&gt; 현재 것을 &lt;code&gt;framebuffer&lt;/code&gt; 또한 요소 중 하나가 참조로 만들어진, &lt;code&gt;pColorAttachments&lt;/code&gt; , 현재 서브 패스가 작성된 &lt;code&gt;VkSubpassDescription&lt;/code&gt; 인스턴스 의 &lt;code&gt;pResolveAttachments&lt;/code&gt; 또는 &lt;code&gt;pDepthStencilAttachment&lt;/code&gt; 멤버</target>
        </trans-unit>
        <trans-unit id="54cee90fa7c58a8e7869dd93e95d6d9957e1cc05" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;vkCmdPipelineBarrier&lt;/code&gt; is called within a render pass instance, the &lt;code&gt;oldLayout&lt;/code&gt; and &lt;code&gt;newLayout&lt;/code&gt; members of an element of &lt;code&gt;pImageMemoryBarriers&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be equal</source>
          <target state="translated">경우 &lt;code&gt;vkCmdPipelineBarrier&lt;/code&gt; 가 렌더 패스 인스턴스 내에서 호출되면, &lt;code&gt;oldLayout&lt;/code&gt; 및 &lt;code&gt;newLayout&lt;/code&gt; 의 요소의 구성원 &lt;code&gt;pImageMemoryBarriers&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 동일</target>
        </trans-unit>
        <trans-unit id="3b8486a88cb06fd5bd87e3b155894aad3ecead69" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;vkCmdPipelineBarrier&lt;/code&gt; is called within a render pass instance, the &lt;code&gt;oldLayout&lt;/code&gt; and &lt;code&gt;newLayout&lt;/code&gt; members of any element of &lt;code&gt;pImageMemoryBarriers&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be equal to the &lt;code&gt;layout&lt;/code&gt; member of an element of the &lt;code&gt;pColorAttachments&lt;/code&gt;, &lt;code&gt;pResolveAttachments&lt;/code&gt; or &lt;code&gt;pDepthStencilAttachment&lt;/code&gt; members of the &lt;code&gt;VkSubpassDescription&lt;/code&gt; instance that the current subpass was created with, that refers to the same &lt;code&gt;image&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;vkCmdPipelineBarrier&lt;/code&gt; 가 렌더링 패스 인스턴스 내에서 호출되면 &lt;code&gt;oldLayout&lt;/code&gt; 및 &lt;code&gt;newLayout&lt;/code&gt; 의 요소의 부재 &lt;code&gt;pImageMemoryBarriers&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 받는 동일 &lt;code&gt;layout&lt;/code&gt; 의 요소의 부재 &lt;code&gt;pColorAttachments&lt;/code&gt; , &lt;code&gt;pResolveAttachments&lt;/code&gt; 또는 &lt;code&gt;pDepthStencilAttachment&lt;/code&gt; 용 의 부재 &lt;code&gt;VkSubpassDescription&lt;/code&gt; 의 현재 subpass를 사용하여 만든 것을 인스턴스 같은 &lt;code&gt;image&lt;/code&gt; 를 말합니다</target>
        </trans-unit>
        <trans-unit id="ccb5f6010747a8bba76ea9fa7c8f2550938312a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;vkCmdPipelineBarrier&lt;/code&gt; is called within a render pass instance, the &lt;code&gt;srcAccessMask&lt;/code&gt; of any element of &lt;code&gt;pMemoryBarriers&lt;/code&gt; or &lt;code&gt;pImageMemoryBarriers&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; contain a subset of the bit values the &lt;code&gt;srcAccessMask&lt;/code&gt; member of that instance of &lt;code&gt;VkSubpassDependency&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;vkCmdPipelineBarrier&lt;/code&gt; 가 렌더 패스 인스턴스 내에서 호출되면, &lt;code&gt;srcAccessMask&lt;/code&gt; 의 요소의 &lt;code&gt;pMemoryBarriers&lt;/code&gt; 또는 &lt;code&gt;pImageMemoryBarriers&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 비트 값의 하위 집합에게 포함 &lt;code&gt;srcAccessMask&lt;/code&gt; 의 의 인스턴스의 멤버 &lt;code&gt;VkSubpassDependency&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="81907ad2b178f8232733b6594f0961729a99d44d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;vkCmdPipelineBarrier&lt;/code&gt; is called within a render pass instance, the &lt;code&gt;srcQueueFamilyIndex&lt;/code&gt; and &lt;code&gt;dstQueueFamilyIndex&lt;/code&gt; members of any element of &lt;code&gt;pImageMemoryBarriers&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;VK_QUEUE_FAMILY_IGNORED&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;vkCmdPipelineBarrier&lt;/code&gt; 가 렌더 패스 인스턴스 내에서 호출되면, &lt;code&gt;srcQueueFamilyIndex&lt;/code&gt; 및 &lt;code&gt;dstQueueFamilyIndex&lt;/code&gt; 의 요소의 구성원 &lt;code&gt;pImageMemoryBarriers&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;VK_QUEUE_FAMILY_IGNORED&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="98c9cdacb5b17edf3d64241b62c5fe3e289f06bb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;vkCmdPipelineBarrier&lt;/code&gt; is called within a render pass instance, the render pass &lt;strong&gt;must&lt;/strong&gt; have been created with a &lt;code&gt;VkSubpassDependency&lt;/code&gt; instance in &lt;code&gt;pDependencies&lt;/code&gt; that expresses a dependency from the current subpass to itself.</source>
          <target state="translated">경우 &lt;code&gt;vkCmdPipelineBarrier&lt;/code&gt; 가 렌더 패스 인스턴스 내에서 호출되어, 패스가 렌더링 &lt;strong&gt;합니다&lt;/strong&gt; 로 생성 된 &lt;code&gt;VkSubpassDependency&lt;/code&gt; 의 에서 예를 &lt;code&gt;pDependencies&lt;/code&gt; 자체에 현재 subpass에서 의존성을 표현한다.</target>
        </trans-unit>
        <trans-unit id="cc2ff27b19967673439541c2ee14ceab0dc43c97" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;vkQueueSubmit&lt;/code&gt; fails, it &lt;strong&gt;may&lt;/strong&gt; return &lt;code&gt;VK_ERROR_OUT_OF_HOST_MEMORY&lt;/code&gt; or &lt;code&gt;VK_ERROR_OUT_OF_DEVICE_MEMORY&lt;/code&gt;. If it does, the implementation &lt;strong&gt;must&lt;/strong&gt; ensure that the state and contents of any resources or synchronization primitives referenced by the submitted command buffers and any semaphores referenced by &lt;code&gt;pSubmits&lt;/code&gt; is unaffected by the call or its failure. If &lt;code&gt;vkQueueSubmit&lt;/code&gt; fails in such a way that the implementation &lt;strong&gt;can&lt;/strong&gt; not make that guarantee, the implementation &lt;strong&gt;must&lt;/strong&gt; return &lt;code&gt;VK_ERROR_DEVICE_LOST&lt;/code&gt;. See &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-lost-device&quot;&gt;Lost Device&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;vkQueueSubmit&lt;/code&gt; 가 실패, 그것은 &lt;strong&gt;수&lt;/strong&gt; 반환 &lt;code&gt;VK_ERROR_OUT_OF_HOST_MEMORY&lt;/code&gt; 또는 &lt;code&gt;VK_ERROR_OUT_OF_DEVICE_MEMORY&lt;/code&gt; 을 . 그렇다면 구현 &lt;strong&gt;은&lt;/strong&gt; 제출 된 명령 버퍼가 참조하는 자원 또는 동기화 기본 요소 및 &lt;code&gt;pSubmits&lt;/code&gt; 가 참조하는 세마포어의 상태 및 내용 이 호출 또는 실패의 영향을받지 않도록해야 합니다. 경우 &lt;code&gt;vkQueueSubmit&lt;/code&gt; 가 구현되는 방식으로 실패 할 &lt;strong&gt;수있는&lt;/strong&gt; 것을 보장하지, 구현 &lt;strong&gt;해야한다&lt;/strong&gt; 반환 &lt;code&gt;VK_ERROR_DEVICE_LOST&lt;/code&gt; 을 . &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-lost-device&quot;&gt;장치 분실을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="33e70716fa1d63522a4508b003d9161ddc9613b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;waitSemaphoreCount&lt;/code&gt; is not &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;pWaitDstStageMask&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to an array of &lt;code&gt;waitSemaphoreCount&lt;/code&gt; valid combinations of &lt;a href=&quot;#VkPipelineStageFlagBits&quot;&gt;VkPipelineStageFlagBits&lt;/a&gt; values</source>
          <target state="translated">경우 &lt;code&gt;waitSemaphoreCount&lt;/code&gt; 가 아닌 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;pWaitDstStageMask&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 의 배열에 대한 포인터 &lt;code&gt;waitSemaphoreCount&lt;/code&gt; 유효한 조합 &lt;a href=&quot;#VkPipelineStageFlagBits&quot;&gt;VkPipelineStageFlagBits의&lt;/a&gt; 값</target>
        </trans-unit>
        <trans-unit id="19465c7c52f90de4332d6cc36b1c1eee4b3de2f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;waitSemaphoreCount&lt;/code&gt; is not &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;pWaitSemaphores&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to an array of &lt;code&gt;waitSemaphoreCount&lt;/code&gt; valid &lt;code&gt;VkSemaphore&lt;/code&gt; handles</source>
          <target state="translated">경우 &lt;code&gt;waitSemaphoreCount&lt;/code&gt; 가 아닌 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;pWaitSemaphores&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 의 배열에 대한 포인터 &lt;code&gt;waitSemaphoreCount&lt;/code&gt; 유효 &lt;code&gt;VkSemaphore&lt;/code&gt; 의 핸들</target>
        </trans-unit>
        <trans-unit id="9cbfd38bfb5b87e0d2ee3823e1818a736e2deee7" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-submission&quot;&gt;queue submission&lt;/a&gt; command is pending execution, then the value returned by this command &lt;strong&gt;may&lt;/strong&gt; immediately be out of date.</source>
          <target state="translated">경우 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-submission&quot;&gt;큐 제출&lt;/a&gt; 명령은 실행을 보류,이 명령에 의해 반환되는 값은 &lt;strong&gt;수&lt;/strong&gt; 즉시 구식합니다.</target>
        </trans-unit>
        <trans-unit id="6f9cf351f5c3755123b896350b8d03e03e2c272b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;constantID&lt;/code&gt; value is not a specialization constant ID used in the shader, that map entry does not affect the behavior of the pipeline.</source>
          <target state="translated">경우 &lt;code&gt;constantID&lt;/code&gt; 의 값이 쉐이더에서 사용되는 전문 상수의 ID 아닌, 그 맵 항목은 파이프 라인의 동작에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b29059c1c42f54180fd3c67843e4b1002651000b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;vkCmdSetEvent&lt;/code&gt; or &lt;code&gt;vkCmdResetEvent&lt;/code&gt; command is in a command buffer that is in the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;pending state&lt;/a&gt;, then the value returned by this command &lt;strong&gt;may&lt;/strong&gt; immediately be out of date.</source>
          <target state="translated">경우 &lt;code&gt;vkCmdSetEvent&lt;/code&gt; 또는 &lt;code&gt;vkCmdResetEvent&lt;/code&gt; 명령 인 명령 버퍼에 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;보류중인 상태로&lt;/a&gt; ,이 명령에 의해 리턴 된 값이 &lt;strong&gt;있다&lt;/strong&gt; 즉시 구식이 될.</target>
        </trans-unit>
        <trans-unit id="4087d9917a55012385634e32766b34ba5823281a" translate="yes" xml:space="preserve">
          <source>If a SPIR-V &lt;code&gt;OpLoad&lt;/code&gt; instruction loads a structure and the tail end of the structure is out of bounds, then all members of the structure are considered out of bounds even if the members at the end are not statically used.</source>
          <target state="translated">SPIR-V &lt;code&gt;OpLoad&lt;/code&gt; 명령이 구조를로드하고 구조의 꼬리 끝이 경계를 벗어난 경우 끝의 구성원이 정적으로 사용되지 않더라도 구조의 모든 구성원이 경계를 벗어난 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="3f44fab511959c076685fa827fd2cbe63fe906e0" translate="yes" xml:space="preserve">
          <source>If a command returns a run time error, it will leave any result pointers unmodified, unless other behavior is explicitly defined in the specification.</source>
          <target state="translated">명령이 런타임 오류를 리턴하면 다른 동작이 스펙에 명시 적으로 정의되어 있지 않은 한 결과 포인터를 수정하지 않은 채로 둡니다.</target>
        </trans-unit>
        <trans-unit id="a07e5bc4f64e9b2b6220af23bcc5f6f1312d5843" translate="yes" xml:space="preserve">
          <source>If a descriptor pool has not had any descriptor sets freed since it was created or most recently reset then fragmentation &lt;strong&gt;must&lt;/strong&gt; not cause an allocation failure (note that this is always the case for a pool created without the &lt;code&gt;VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT&lt;/code&gt; bit set). Additionally, if all sets allocated from the pool since it was created or most recently reset use the same number of descriptors (of each type) and the requested allocation also uses that same number of descriptors (of each type), then fragmentation &lt;strong&gt;must&lt;/strong&gt; not cause an allocation failure.</source>
          <target state="translated">디스크립터 풀에 디스크립터 세트가 작성되었거나 가장 최근에 재설정 된 후에 해제 된 디스크립터 &lt;strong&gt;가&lt;/strong&gt; 없는 경우 조각화로 인해 할당 실패가 발생하지 않아야합니다 ( &lt;code&gt;VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT&lt;/code&gt; 비트 세트 없이 작성된 풀의 경우 ). 또한 풀에서 할당되었거나 가장 최근에 재설정 된 이후에 풀에서 할당 된 모든 세트가 동일한 수의 설명자 (각 유형)를 사용하고 요청 된 할당에서 동일한 수의 설명자 (각 유형)를 사용하는 경우 조각화 &lt;strong&gt;가&lt;/strong&gt; 발생하지 &lt;strong&gt;않아야합니다.&lt;/strong&gt; 할당 실패.</target>
        </trans-unit>
        <trans-unit id="6c77db8c3ac81fea4d8729b6d99717d30b6a3fc5" translate="yes" xml:space="preserve">
          <source>If a memory object does not have the &lt;code&gt;VK_MEMORY_PROPERTY_HOST_COHERENT_BIT&lt;/code&gt; property, then &lt;a href=&quot;#vkFlushMappedMemoryRanges&quot;&gt;vkFlushMappedMemoryRanges&lt;/a&gt;&lt;strong&gt;must&lt;/strong&gt; be called in order to guarantee that writes to the memory object from the host are made visible to the &lt;code&gt;VK_ACCESS_HOST_WRITE_BIT&lt;/code&gt;&lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-types&quot;&gt;access type&lt;/a&gt;, where it &lt;strong&gt;can&lt;/strong&gt; be further made available to the device by &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization&quot;&gt;synchronization commands&lt;/a&gt;. Similarly, &lt;a href=&quot;#vkInvalidateMappedMemoryRanges&quot;&gt;vkInvalidateMappedMemoryRanges&lt;/a&gt;&lt;strong&gt;must&lt;/strong&gt; be called to guarantee that writes which are visible to the &lt;code&gt;VK_ACCESS_HOST_READ_BIT&lt;/code&gt;&lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-types&quot;&gt;access type&lt;/a&gt; are made visible to host operations.</source>
          <target state="translated">메모리 개체가없는 경우 &lt;code&gt;VK_MEMORY_PROPERTY_HOST_COHERENT_BIT&lt;/code&gt; 의 속성을 다음 &lt;a href=&quot;#vkFlushMappedMemoryRanges&quot;&gt;vkFlushMappedMemoryRanges이 &lt;/a&gt;&lt;strong&gt;있어야&lt;/strong&gt; 호스트에서 메모리 개체에 대한 쓰기가에 가시가되는 것을 보장하기 위해 호출 할 &lt;code&gt;VK_ACCESS_HOST_WRITE_BIT&lt;/code&gt; 의&lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-types&quot;&gt;액세스 유형&lt;/a&gt; 은, &lt;strong&gt;수&lt;/strong&gt; 추가하여 장치에 사용할 수 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization&quot;&gt;동기화 명령&lt;/a&gt; . 마찬가지로, &lt;a href=&quot;#vkInvalidateMappedMemoryRanges&quot;&gt;vkInvalidateMappedMemoryRanges이 &lt;/a&gt;&lt;strong&gt;있어야&lt;/strong&gt; 받는 볼 수 있습니다 쓰기를 보장하기 위해 호출 &lt;code&gt;VK_ACCESS_HOST_READ_BIT&lt;/code&gt; 의&lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-types&quot;&gt;액세스 유형이&lt;/a&gt; 호스트 운영에 가시가있다.</target>
        </trans-unit>
        <trans-unit id="dfc0a6089dc982b1c583cc52d81036601b699cd5" translate="yes" xml:space="preserve">
          <source>If a memory object is mapped at the time it is freed, it is implicitly unmapped.</source>
          <target state="translated">메모리 오브젝트가 해제 될 때 맵핑되면 내재적으로 맵핑 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="4d1a8fa76db38e3020cf24dab9f78abeab7f903a" translate="yes" xml:space="preserve">
          <source>If a pipeline has &lt;code&gt;rasterizerDiscardEnable&lt;/code&gt; enabled, implementations &lt;strong&gt;may&lt;/strong&gt; discard primitives after the final vertex processing stage. As a result, if &lt;code&gt;rasterizerDiscardEnable&lt;/code&gt; is enabled, the clipping input and output primitives counters &lt;strong&gt;may&lt;/strong&gt; not be incremented.</source>
          <target state="translated">파이프 라인에 &lt;code&gt;rasterizerDiscardEnable&lt;/code&gt; 이 활성화 된 경우 구현시 최종 정점 처리 단계 후에 프리미티브 &lt;strong&gt;가&lt;/strong&gt; 삭제 &lt;strong&gt;될 수 있습니다&lt;/strong&gt; . 결과적으로 &lt;code&gt;rasterizerDiscardEnable&lt;/code&gt; 을 사용하면 클리핑 입력 및 출력 프리미티브 카운터 &lt;strong&gt;가&lt;/strong&gt; 증가하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3321ca6a4f8aa85b8194bbfaf8e8dfb9c15cc8dd" translate="yes" xml:space="preserve">
          <source>If a shader stage is not included in &lt;code&gt;stageFlags&lt;/code&gt;, then a resource &lt;strong&gt;must&lt;/strong&gt; not be accessed from that stage via this binding within any pipeline using the set layout. Other than input attachments which are limited to the fragment shader, there are no limitations on what combinations of stages &lt;strong&gt;can&lt;/strong&gt; be used by a descriptor binding, and in particular a binding &lt;strong&gt;can&lt;/strong&gt; be used by both graphics stages and the compute stage.</source>
          <target state="translated">셰이더 스테이지에 포함되어 있지 않은 경우 &lt;code&gt;stageFlags&lt;/code&gt; , 다음 자원이 &lt;strong&gt;있어야합니다&lt;/strong&gt; 설정 레이아웃을 사용하는 파이프 라인 내에서이 바인딩을 통해 그 단계에서 액세스 할 수 없습니다. 프래그먼트 셰이더로 제한되는 입력 첨부 파일 외에 , 디스크립터 바인딩에서 사용할 &lt;strong&gt;수&lt;/strong&gt; 있는 스테이지 조합에는 제한이 없으며 , 특히 그래픽 스테이지와 컴퓨팅 스테이지 에서 바인딩을 &lt;strong&gt;사용할 수&lt;/strong&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="95e1cbaccd9f779662e9504a9bb29ab9a3ac2284" translate="yes" xml:space="preserve">
          <source>If a vertex input attribute is out of bounds, it will be assigned one of the following values:</source>
          <target state="translated">정점 입력 속성이 범위를 벗어난 경우 다음 값 중 하나가 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="b275caa8a795761dcdc3c5aa5c04d30ac7b5ab3b" translate="yes" xml:space="preserve">
          <source>If an allocation fails due to fragmentation, an indeterminate error is returned with an unspecified error code. Any returned error other than &lt;code&gt;VK_ERROR_FRAGMENTED_POOL&lt;/code&gt; does not imply its usual meaning: applications &lt;strong&gt;should&lt;/strong&gt; assume that the allocation failed due to fragmentation, and create a new descriptor pool.</source>
          <target state="translated">조각화로 인해 할당이 실패하면 지정되지 않은 오류 코드와 함께 결정되지 않은 오류가 반환됩니다. &lt;code&gt;VK_ERROR_FRAGMENTED_POOL&lt;/code&gt; 이외의 반환 된 오류 는 일반적인 의미를 의미하지 않습니다. 응용 프로그램 &lt;strong&gt;은&lt;/strong&gt; 조각화로 인해 할당이 실패했다고 가정하고 새 설명자 풀을 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="a147fd213b2c3079da16e655a5eceeb556b3051c" translate="yes" xml:space="preserve">
          <source>If an allocation failure occurs due to fragmentation, an application &lt;strong&gt;can&lt;/strong&gt; create an additional descriptor pool to perform further descriptor set allocations.</source>
          <target state="translated">조각화로 인해 할당 실패가 발생하면 응용 프로그램 &lt;strong&gt;은&lt;/strong&gt; 추가 설명자 풀을 만들어 추가 설명자 집합 할당을 수행 &lt;strong&gt;할 수&lt;/strong&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="c15fe9f0f6e672d2ff49f5239919d745315d83e1" translate="yes" xml:space="preserve">
          <source>If an allocation is associated with an object of type &lt;code&gt;VkPipelineCache&lt;/code&gt;, the allocator will use the &lt;code&gt;VK_SYSTEM_ALLOCATION_SCOPE_CACHE&lt;/code&gt; allocation scope. The most specific allocator available is used (pipeline cache, else device, else instance). Else,</source>
          <target state="translated">할당이 &lt;code&gt;VkPipelineCache&lt;/code&gt; 유형의 오브젝트와 연관된 경우 할당 자는 &lt;code&gt;VK_SYSTEM_ALLOCATION_SCOPE_CACHE&lt;/code&gt; 할당 범위를 사용합니다 . 사용 가능한 가장 구체적인 할당자가 사용됩니다 (파이프 라인 캐시, 다른 장치, 다른 인스턴스). 그밖에,</target>
        </trans-unit>
        <trans-unit id="bfe2cd5536dc7e68a1d8f459249c46805a85a64a" translate="yes" xml:space="preserve">
          <source>If an allocation is scoped to the duration of a command, the allocator will use the &lt;code&gt;VK_SYSTEM_ALLOCATION_SCOPE_COMMAND&lt;/code&gt; allocation scope. The most specific allocator available is used: if the object being created or manipulated has an allocator, that object&amp;rsquo;s allocator will be used, else if the parent &lt;code&gt;VkDevice&lt;/code&gt; has an allocator it will be used, else if the parent &lt;code&gt;VkInstance&lt;/code&gt; has an allocator it will be used. Else,</source>
          <target state="translated">할당이 명령 지속 시간으로 범위가 지정되면 할당자는 &lt;code&gt;VK_SYSTEM_ALLOCATION_SCOPE_COMMAND&lt;/code&gt; 할당 범위를 사용합니다 . 사용 가능한 가장 구체적인 할당자가 사용됩니다. 생성되거나 조작되는 객체에 할당자가 있으면 해당 객체의 할당자가 사용됩니다. 그렇지 않으면 부모 &lt;code&gt;VkDevice&lt;/code&gt; 에 할당자가 있으면 부모 &lt;code&gt;VkInstance&lt;/code&gt; 에 할당자가 있으면 할당됩니다 익숙한. 그밖에,</target>
        </trans-unit>
        <trans-unit id="947edaf735b5b5a43855ae9b09c23bf124bcc335" translate="yes" xml:space="preserve">
          <source>If an allocation is scoped to the lifetime of a device, the allocator will use an allocation scope of &lt;code&gt;VK_SYSTEM_ALLOCATION_SCOPE_DEVICE&lt;/code&gt;. The most specific allocator available is used (device, else instance). Else,</source>
          <target state="translated">할당 범위가 장치의 수명 범위 인 경우 할당자는 &lt;code&gt;VK_SYSTEM_ALLOCATION_SCOPE_DEVICE&lt;/code&gt; 할당 범위를 사용합니다 . 사용 가능한 가장 구체적인 할당자가 사용됩니다 (장치, 그렇지 않은 경우). 그밖에,</target>
        </trans-unit>
        <trans-unit id="e3dc8f936c204065d6ae4da9cf943af308f752b9" translate="yes" xml:space="preserve">
          <source>If an allocation is scoped to the lifetime of an object, that object is being created or manipulated by the command, and that object&amp;rsquo;s type is not &lt;code&gt;VkDevice&lt;/code&gt; or &lt;code&gt;VkInstance&lt;/code&gt;, the allocator will use an allocation scope of &lt;code&gt;VK_SYSTEM_ALLOCATION_SCOPE_OBJECT&lt;/code&gt;. The most specific allocator available is used (object, else device, else instance). Else,</source>
          <target state="translated">할당은 객체의 수명에 범위 경우 해당 객체가 생성 또는 명령에 의해 조작, 그 객체의 유형이 아닌되고 &lt;code&gt;VkDevice&lt;/code&gt; 또는 &lt;code&gt;VkInstance&lt;/code&gt; 의 할당은의 할당 범위를 사용합니다 &lt;code&gt;VK_SYSTEM_ALLOCATION_SCOPE_OBJECT&lt;/code&gt; 을 . 사용 가능한 가장 구체적인 할당 자 (객체, 장치, 인스턴스)가 사용됩니다. 그밖에,</target>
        </trans-unit>
        <trans-unit id="7fa6f6674cb2d42993d01519fdad36cdea0d9fc6" translate="yes" xml:space="preserve">
          <source>If an attachment is not used by any subpass, then &lt;code&gt;loadOp&lt;/code&gt;, &lt;code&gt;storeOp&lt;/code&gt;, &lt;code&gt;stencilStoreOp&lt;/code&gt;, and &lt;code&gt;stencilLoadOp&lt;/code&gt; are ignored, and the attachment&amp;rsquo;s memory contents will not be modified by execution of a render pass instance.</source>
          <target state="translated">서브 패스에서 첨부 파일을 사용하지 않으면 &lt;code&gt;loadOp&lt;/code&gt; , &lt;code&gt;storeOp&lt;/code&gt; , &lt;code&gt;stencilStoreOp&lt;/code&gt; 및 &lt;code&gt;stencilLoadOp&lt;/code&gt; 가 무시되고 렌더 패스 인스턴스를 실행해도 첨부 파일의 메모리 내용이 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="548259c80fb7f01c58e015505b7d6442aead3c5e" translate="yes" xml:space="preserve">
          <source>If an implementation exposes any queue family that supports graphics operations, at least one queue family of at least one physical device exposed by the implementation &lt;strong&gt;must&lt;/strong&gt; support both graphics and compute operations.</source>
          <target state="translated">구현시 그래픽 작업을 지원하는 큐 제품군이 노출되면 구현에 의해 노출 된 하나 이상의 물리적 디바이스의 큐 제품군 중 하나 이상이 그래픽 및 계산 작업을 모두 지원 &lt;strong&gt;해야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ab69aefba277b76152225269d668444f1ddcf956" translate="yes" xml:space="preserve">
          <source>If an implementation is unable to detect completion and latch the timer at any specific stage of the pipeline, it &lt;strong&gt;may&lt;/strong&gt; instead do so at any logically later stage.</source>
          <target state="translated">구현이 완료를 감지 할 수없고 파이프 라인의 특정 단계에서 타이머를 래치하면 대신 논리적으로 나중 단계에서 타이머를 걸 &lt;strong&gt;수 있습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="74dd40e71b6cf47179f8c066ba845e9b3559cbf9" translate="yes" xml:space="preserve">
          <source>If any &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-secondary&quot;&gt;secondary command buffers recorded&lt;/a&gt; into any given element of the &lt;code&gt;pCommandBuffers&lt;/code&gt; member of any element of &lt;code&gt;pSubmits&lt;/code&gt; was not recorded with the &lt;code&gt;VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT&lt;/code&gt;, it &lt;strong&gt;must&lt;/strong&gt; not be in the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;pending state&lt;/a&gt;.</source>
          <target state="translated">어떤 경우에는 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-secondary&quot;&gt;기록 보조 명령 버퍼&lt;/a&gt; 의 주어진 요소에 &lt;code&gt;pCommandBuffers&lt;/code&gt; 의 임의의 요소의 부재 &lt;code&gt;pSubmits&lt;/code&gt; 가 에 기록되지 않은 &lt;code&gt;VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT&lt;/code&gt; 그것은 &lt;strong&gt;해야&lt;/strong&gt; 에 있지 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;보류 상태&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f757c47e5bbb66f789f1db4e9387d28e16ab68d5" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;VkSampler&lt;/code&gt; object that is accessed from a shader by the &lt;code&gt;VkPipeline&lt;/code&gt; currently bound to &lt;code&gt;VK_PIPELINE_BIND_POINT_COMPUTE&lt;/code&gt; uses unnormalized coordinates, it &lt;strong&gt;must&lt;/strong&gt; not be used to sample from any &lt;code&gt;VkImage&lt;/code&gt; with a &lt;code&gt;VkImageView&lt;/code&gt; of the type &lt;code&gt;VK_IMAGE_VIEW_TYPE_3D&lt;/code&gt;, &lt;code&gt;VK_IMAGE_VIEW_TYPE_CUBE&lt;/code&gt;, &lt;code&gt;VK_IMAGE_VIEW_TYPE_1D_ARRAY&lt;/code&gt;, &lt;code&gt;VK_IMAGE_VIEW_TYPE_2D_ARRAY&lt;/code&gt; or &lt;code&gt;VK_IMAGE_VIEW_TYPE_CUBE_ARRAY&lt;/code&gt;, in any shader stage</source>
          <target state="translated">어떤 경우 &lt;code&gt;VkSampler&lt;/code&gt; 의 바이 셰이더로부터 액세스 개체 &lt;code&gt;VkPipeline&lt;/code&gt; 현재 결합 &lt;code&gt;VK_PIPELINE_BIND_POINT_COMPUTE&lt;/code&gt; 가 표준화 좌표를 사용하고, 그것을 &lt;strong&gt;해야&lt;/strong&gt; 임의의 샘플을 이용하지 &lt;code&gt;VkImage&lt;/code&gt; 로모그래퍼 &lt;code&gt;VkImageView&lt;/code&gt; 유형 &lt;code&gt;VK_IMAGE_VIEW_TYPE_3D&lt;/code&gt; , &lt;code&gt;VK_IMAGE_VIEW_TYPE_CUBE&lt;/code&gt; , &lt;code&gt;VK_IMAGE_VIEW_TYPE_1D_ARRAY&lt;/code&gt; , &lt;code&gt;VK_IMAGE_VIEW_TYPE_2D_ARRAY&lt;/code&gt; 또는 &lt;code&gt;VK_IMAGE_VIEW_TYPE_CUBE_ARRAY&lt;/code&gt; 모든 쉐이더, 단계</target>
        </trans-unit>
        <trans-unit id="58ef70d9cfa0658ba32ab2371b5c9f087a6fda50" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;VkSampler&lt;/code&gt; object that is accessed from a shader by the &lt;code&gt;VkPipeline&lt;/code&gt; currently bound to &lt;code&gt;VK_PIPELINE_BIND_POINT_COMPUTE&lt;/code&gt; uses unnormalized coordinates, it &lt;strong&gt;must&lt;/strong&gt; not be used with any of the SPIR-V &lt;code&gt;OpImageSample*&lt;/code&gt; or &lt;code&gt;OpImageSparseSample*&lt;/code&gt; instructions that includes a LOD bias or any offset values, in any shader stage</source>
          <target state="translated">어떤 경우 &lt;code&gt;VkSampler&lt;/code&gt; 의 바이 셰이더로부터 액세스 개체 &lt;code&gt;VkPipeline&lt;/code&gt; 현재 결합 &lt;code&gt;VK_PIPELINE_BIND_POINT_COMPUTE&lt;/code&gt; 가 표준화 좌표를 사용하고, 그것을 &lt;strong&gt;해야&lt;/strong&gt; SPIR-V 중 임의의 사용되지 &lt;code&gt;OpImageSample*&lt;/code&gt; 또는 &lt;code&gt;OpImageSparseSample*&lt;/code&gt; 에서는, LOD 바이어스 또는 오프셋 값을 포함하는 명령어를 어떤 쉐이더 스테이지</target>
        </trans-unit>
        <trans-unit id="3b869c9aa0e2194b0870b697da74ffbe6071e0ac" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;VkSampler&lt;/code&gt; object that is accessed from a shader by the &lt;code&gt;VkPipeline&lt;/code&gt; currently bound to &lt;code&gt;VK_PIPELINE_BIND_POINT_COMPUTE&lt;/code&gt; uses unnormalized coordinates, it &lt;strong&gt;must&lt;/strong&gt; not be used with any of the SPIR-V &lt;code&gt;OpImageSample*&lt;/code&gt; or &lt;code&gt;OpImageSparseSample*&lt;/code&gt; instructions with &lt;code&gt;ImplicitLod&lt;/code&gt;, &lt;code&gt;Dref&lt;/code&gt; or &lt;code&gt;Proj&lt;/code&gt; in their name, in any shader stage</source>
          <target state="translated">어떤 경우 &lt;code&gt;VkSampler&lt;/code&gt; 의 바이 쉐이더에서 액세스 개체 &lt;code&gt;VkPipeline&lt;/code&gt; 현재 바인딩 &lt;code&gt;VK_PIPELINE_BIND_POINT_COMPUTE&lt;/code&gt; 이 표준화되어 있지 않은 좌표를 사용하여, 그것은 &lt;strong&gt;해야한다&lt;/strong&gt; SPIR-V의와 함께 사용할 수 없습니다 &lt;code&gt;OpImageSample*&lt;/code&gt; 또는 &lt;code&gt;OpImageSparseSample*&lt;/code&gt; 와 지침 &lt;code&gt;ImplicitLod&lt;/code&gt; , &lt;code&gt;Dref&lt;/code&gt; 라는 또는 &lt;code&gt;Proj&lt;/code&gt; 를 자신의 이름에 어떤 쉐이더 스테이지</target>
        </trans-unit>
        <trans-unit id="67f7684d31e48a087c5589168bc747d1e1f7b102" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;VkSampler&lt;/code&gt; object that is accessed from a shader by the &lt;code&gt;VkPipeline&lt;/code&gt; currently bound to &lt;code&gt;VK_PIPELINE_BIND_POINT_GRAPHICS&lt;/code&gt; uses unnormalized coordinates, it &lt;strong&gt;must&lt;/strong&gt; not be used to sample from any &lt;code&gt;VkImage&lt;/code&gt; with a &lt;code&gt;VkImageView&lt;/code&gt; of the type &lt;code&gt;VK_IMAGE_VIEW_TYPE_3D&lt;/code&gt;, &lt;code&gt;VK_IMAGE_VIEW_TYPE_CUBE&lt;/code&gt;, &lt;code&gt;VK_IMAGE_VIEW_TYPE_1D_ARRAY&lt;/code&gt;, &lt;code&gt;VK_IMAGE_VIEW_TYPE_2D_ARRAY&lt;/code&gt; or &lt;code&gt;VK_IMAGE_VIEW_TYPE_CUBE_ARRAY&lt;/code&gt;, in any shader stage</source>
          <target state="translated">어떤 경우 &lt;code&gt;VkSampler&lt;/code&gt; 의 바이 셰이더로부터 액세스 개체 &lt;code&gt;VkPipeline&lt;/code&gt; 현재 결합 &lt;code&gt;VK_PIPELINE_BIND_POINT_GRAPHICS&lt;/code&gt; 가 표준화 좌표를 사용하고, 그것을 &lt;strong&gt;해야&lt;/strong&gt; 임의의 샘플을 이용하지 &lt;code&gt;VkImage&lt;/code&gt; 로모그래퍼 &lt;code&gt;VkImageView&lt;/code&gt; 유형 &lt;code&gt;VK_IMAGE_VIEW_TYPE_3D&lt;/code&gt; , &lt;code&gt;VK_IMAGE_VIEW_TYPE_CUBE&lt;/code&gt; , &lt;code&gt;VK_IMAGE_VIEW_TYPE_1D_ARRAY&lt;/code&gt; , &lt;code&gt;VK_IMAGE_VIEW_TYPE_2D_ARRAY&lt;/code&gt; 또는 &lt;code&gt;VK_IMAGE_VIEW_TYPE_CUBE_ARRAY&lt;/code&gt; 모든 쉐이더, 단계</target>
        </trans-unit>
        <trans-unit id="397a16dd37d9f3ba5ba8ef7759c8f454db35847b" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;VkSampler&lt;/code&gt; object that is accessed from a shader by the &lt;code&gt;VkPipeline&lt;/code&gt; currently bound to &lt;code&gt;VK_PIPELINE_BIND_POINT_GRAPHICS&lt;/code&gt; uses unnormalized coordinates, it &lt;strong&gt;must&lt;/strong&gt; not be used with any of the SPIR-V &lt;code&gt;OpImageSample*&lt;/code&gt; or &lt;code&gt;OpImageSparseSample*&lt;/code&gt; instructions that includes a LOD bias or any offset values, in any shader stage</source>
          <target state="translated">어떤 경우 &lt;code&gt;VkSampler&lt;/code&gt; 의 바이 셰이더로부터 액세스 개체 &lt;code&gt;VkPipeline&lt;/code&gt; 현재 결합 &lt;code&gt;VK_PIPELINE_BIND_POINT_GRAPHICS&lt;/code&gt; 가 표준화 좌표를 사용하고, 그것을 &lt;strong&gt;해야&lt;/strong&gt; SPIR-V 중 임의의 사용되지 &lt;code&gt;OpImageSample*&lt;/code&gt; 또는 &lt;code&gt;OpImageSparseSample*&lt;/code&gt; 에서는, LOD 바이어스 또는 오프셋 값을 포함하는 명령어를 어떤 쉐이더 스테이지</target>
        </trans-unit>
        <trans-unit id="1f63dde241ca9cfcc0fc17ee175d682ab6c6c7a0" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;VkSampler&lt;/code&gt; object that is accessed from a shader by the &lt;code&gt;VkPipeline&lt;/code&gt; currently bound to &lt;code&gt;VK_PIPELINE_BIND_POINT_GRAPHICS&lt;/code&gt; uses unnormalized coordinates, it &lt;strong&gt;must&lt;/strong&gt; not be used with any of the SPIR-V &lt;code&gt;OpImageSample*&lt;/code&gt; or &lt;code&gt;OpImageSparseSample*&lt;/code&gt; instructions with &lt;code&gt;ImplicitLod&lt;/code&gt;, &lt;code&gt;Dref&lt;/code&gt; or &lt;code&gt;Proj&lt;/code&gt; in their name, in any shader stage</source>
          <target state="translated">어떤 경우 &lt;code&gt;VkSampler&lt;/code&gt; 의 바이 쉐이더에서 액세스 개체 &lt;code&gt;VkPipeline&lt;/code&gt; 현재 바인딩 &lt;code&gt;VK_PIPELINE_BIND_POINT_GRAPHICS&lt;/code&gt; 이 표준화되어 있지 않은 좌표를 사용하여, 그것은 &lt;strong&gt;해야한다&lt;/strong&gt; SPIR-V의와 함께 사용할 수 없습니다 &lt;code&gt;OpImageSample*&lt;/code&gt; 또는 &lt;code&gt;OpImageSparseSample*&lt;/code&gt; 와 지침 &lt;code&gt;ImplicitLod&lt;/code&gt; , &lt;code&gt;Dref&lt;/code&gt; 라는 또는 &lt;code&gt;Proj&lt;/code&gt; 를 자신의 이름에 어떤 쉐이더 스테이지</target>
        </trans-unit>
        <trans-unit id="9885a0da1f092334a7366cd50419bebf80892b7e" translate="yes" xml:space="preserve">
          <source>If any attachment is used as both an input attachment and a color or depth/stencil attachment, then each use &lt;strong&gt;must&lt;/strong&gt; use the same &lt;code&gt;layout&lt;/code&gt;</source>
          <target state="translated">어태치먼트가 입력 어태치먼트와 색상 또는 깊이 / 스텐실 어태치먼트로 모두 사용되는 경우 각 용도 &lt;strong&gt;는&lt;/strong&gt; 동일한 &lt;code&gt;layout&lt;/code&gt; 사용해야 &lt;strong&gt;합니다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aa4f0b7da72314b226b4678f866459839dc96d13" translate="yes" xml:space="preserve">
          <source>If any buffer access in a given SPIR-V block is determined to be out of bounds, then any other access of the same type (load, store, or atomic) in the same SPIR-V block that accesses an address less than 16 bytes away from the out of bounds address &lt;strong&gt;may&lt;/strong&gt; also be considered out of bounds.</source>
          <target state="translated">지정된 SPIR-V 블록의 버퍼 액세스가 범위를 벗어난 것으로 판단되면 동일한 SPIR-V 블록에서 16 바이트 미만의 주소에 액세스하는 동일한 유형 (로드, 저장 또는 원자)의 다른 액세스 범위를 벗어난 주소에서 벗어난 주소 도 범위를 벗어난 것으로 간주 &lt;strong&gt;될 수&lt;/strong&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3af454561e4d47a8e1af7668e19523068aae402" translate="yes" xml:space="preserve">
          <source>If any command buffer submitted to this queue is in the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;executable state&lt;/a&gt;, it is moved to the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;pending state&lt;/a&gt;. Once execution of all submissions of a command buffer complete, it moves from the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;pending state&lt;/a&gt;, back to the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;executable state&lt;/a&gt;. If a command buffer was recorded with the &lt;code&gt;VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT&lt;/code&gt; flag, it instead moves back to the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;invalid state&lt;/a&gt;.</source>
          <target state="translated">이 큐에 제출 된 명령 버퍼가 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;실행 가능 상태&lt;/a&gt; 이면 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;보류중인 상태&lt;/a&gt; 로 이동합니다 . 명령 버퍼의 모든 제출이 완료되면 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;보류 상태&lt;/a&gt; 에서 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;실행 가능 상태로&lt;/a&gt; 다시 이동합니다 . 명령 버퍼가 &lt;code&gt;VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT&lt;/code&gt; 플래그 와 함께 기록 된 경우 , 대신 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;무효 상태&lt;/a&gt; 로 돌아갑니다 .</target>
        </trans-unit>
        <trans-unit id="a959d05e9b9cad4bf668c393ec34df070d2c7043" translate="yes" xml:space="preserve">
          <source>If any element of &lt;code&gt;pCommandBuffers&lt;/code&gt; was not recorded with the &lt;code&gt;VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT&lt;/code&gt; flag, and it was recorded into any other primary command buffer which is currently in the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;executable or recording state&lt;/a&gt;, that primary command buffer becomes &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;invalid&lt;/a&gt;.</source>
          <target state="translated">의 요소 경우 &lt;code&gt;pCommandBuffers&lt;/code&gt; 는 에 기록되지 않은 &lt;code&gt;VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT&lt;/code&gt; 의 플래그, 그리고는 현재 다른 기본 명령 버퍼에 기록 된 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;실행 파일 또는 기록 상태에&lt;/a&gt; 기본 명령 버퍼가되도록, &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;무효&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="654a82f1ff93b1461fc0aca56d8f77ce403a517a" translate="yes" xml:space="preserve">
          <source>If any element of &lt;code&gt;pCommandBuffers&lt;/code&gt; was not recorded with the &lt;code&gt;VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT&lt;/code&gt; flag, and it was recorded into any other primary command buffer, that primary command buffer &lt;strong&gt;must&lt;/strong&gt; not be in the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;pending state&lt;/a&gt;</source>
          <target state="translated">의 요소 경우 &lt;code&gt;pCommandBuffers&lt;/code&gt; 가 에 기록되지 않은 &lt;code&gt;VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT&lt;/code&gt; 의 플래그와이 다른 기본 명령 버퍼에 기록하고, 그 기본 명령 버퍼 &lt;strong&gt;해야&lt;/strong&gt; 에 있지 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;보류 상태&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1c06c57883b1e81598da5eae4e5ed1425f5f17c2" translate="yes" xml:space="preserve">
          <source>If any given element of &lt;code&gt;pCommandBuffers&lt;/code&gt; was not recorded with the &lt;code&gt;VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT&lt;/code&gt; flag, it &lt;strong&gt;must&lt;/strong&gt; not appear more than once in &lt;code&gt;pCommandBuffers&lt;/code&gt;.</source>
          <target state="translated">의 특정 요소 경우 &lt;code&gt;pCommandBuffers&lt;/code&gt; 가 에 기록되지 않은 &lt;code&gt;VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT&lt;/code&gt; 의 플래그가 &lt;strong&gt;있어야&lt;/strong&gt; 에 한 번 이상 나타나지 &lt;code&gt;pCommandBuffers&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45a40c78303bf823ef077174f6bce61cbc32510e" translate="yes" xml:space="preserve">
          <source>If any given element of &lt;code&gt;pCommandBuffers&lt;/code&gt; was not recorded with the &lt;code&gt;VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT&lt;/code&gt; flag, it &lt;strong&gt;must&lt;/strong&gt; not be in the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;pending state&lt;/a&gt;.</source>
          <target state="translated">의 특정 요소 경우 &lt;code&gt;pCommandBuffers&lt;/code&gt; 가 에 기록되지 않은 &lt;code&gt;VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT&lt;/code&gt; 의 플래그가 &lt;strong&gt;있어야합니다&lt;/strong&gt; 에 있지 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;보류 상태&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2bee1558a561460f1b7d739e968a7e6eeed4725a" translate="yes" xml:space="preserve">
          <source>If any given element of &lt;code&gt;pCommandBuffers&lt;/code&gt; was not recorded with the &lt;code&gt;VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT&lt;/code&gt; flag, it &lt;strong&gt;must&lt;/strong&gt; not have already been recorded to &lt;code&gt;commandBuffer&lt;/code&gt;.</source>
          <target state="translated">의 특정 요소 경우 &lt;code&gt;pCommandBuffers&lt;/code&gt; 가 에 기록되지 않은 &lt;code&gt;VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT&lt;/code&gt; 의 플래그, 그것은 &lt;strong&gt;있어야&lt;/strong&gt; 이미에 기록되지 않았을 &lt;code&gt;commandBuffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6c65c8f7813079f5ca6b3f4a4a1f6299ad0cead" translate="yes" xml:space="preserve">
          <source>If any given element of the &lt;code&gt;pCommandBuffers&lt;/code&gt; member of any element of &lt;code&gt;pSubmits&lt;/code&gt; was not recorded with the &lt;code&gt;VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT&lt;/code&gt;, it &lt;strong&gt;must&lt;/strong&gt; not be in the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;pending state&lt;/a&gt;.</source>
          <target state="translated">의 특정 요소 경우 &lt;code&gt;pCommandBuffers&lt;/code&gt; 의 의 요소의 회원 &lt;code&gt;pSubmits&lt;/code&gt; 가 에 기록되지 않은 &lt;code&gt;VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT&lt;/code&gt; , 그것은 &lt;strong&gt;해야한다&lt;/strong&gt; 에 있지 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;보류 상태&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="12549e256554e905116aa01eb111aa8e504bcb07" translate="yes" xml:space="preserve">
          <source>If any input attachments are &lt;code&gt;VK_ATTACHMENT_UNUSED&lt;/code&gt;, then any pipelines bound during the subpass &lt;strong&gt;must&lt;/strong&gt; not access those input attachments from the fragment shader</source>
          <target state="translated">모든 입력 첨부 파일이있는 경우 &lt;code&gt;VK_ATTACHMENT_UNUSED&lt;/code&gt; 을 다음 subpass 동안 바인딩 어떤 파이프 라인이 &lt;strong&gt;있어야&lt;/strong&gt; 프레 그먼트 쉐이더에서 해당 입력 첨부 파일에 액세스 할</target>
        </trans-unit>
        <trans-unit id="aecd21d787561cdac3cd83cb0b7c395a6c5b19a9" translate="yes" xml:space="preserve">
          <source>If any member of &lt;code&gt;pFences&lt;/code&gt; is already in the unsignaled state when &lt;a href=&quot;#vkResetFences&quot;&gt;vkResetFences&lt;/a&gt; is executed, then &lt;a href=&quot;#vkResetFences&quot;&gt;vkResetFences&lt;/a&gt; has no effect on that fence.</source>
          <target state="translated">&lt;a href=&quot;#vkResetFences&quot;&gt;vkResetFences&lt;/a&gt; 가 실행될 때 pFences 의 &lt;code&gt;pFences&lt;/code&gt; 가 이미 &lt;a href=&quot;#vkResetFences&quot;&gt;서명&lt;/a&gt; 되지 않은 상태 인 경우 vkResetFences 는 해당 펜스에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b0f0d5d1e413896923a2e538540f999a66625ec" translate="yes" xml:space="preserve">
          <source>If any of &lt;code&gt;addressModeU&lt;/code&gt;, &lt;code&gt;addressModeV&lt;/code&gt; or &lt;code&gt;addressModeW&lt;/code&gt; are &lt;code&gt;VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER&lt;/code&gt;, &lt;code&gt;borderColor&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a valid &lt;a href=&quot;#VkBorderColor&quot;&gt;VkBorderColor&lt;/a&gt; value</source>
          <target state="translated">어떤 경우 &lt;code&gt;addressModeU&lt;/code&gt; , &lt;code&gt;addressModeV&lt;/code&gt; 또는 &lt;code&gt;addressModeW&lt;/code&gt; 가 있습니다 &lt;code&gt;VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER&lt;/code&gt; 는 , &lt;code&gt;borderColor&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 유효한 될 &lt;a href=&quot;#VkBorderColor&quot;&gt;VkBorderColor의&lt;/a&gt; 값</target>
        </trans-unit>
        <trans-unit id="231252ad1d02e8be77bbcac42ced849e74176b72" translate="yes" xml:space="preserve">
          <source>If any of &lt;code&gt;extent.width&lt;/code&gt;, &lt;code&gt;extent.height&lt;/code&gt;, or &lt;code&gt;extent.depth&lt;/code&gt; are greater than the equivalently named members of &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt;::&lt;code&gt;maxImageDimension3D&lt;/code&gt;, &lt;code&gt;mipLevels&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than or equal to &lt;code&gt;VkImageFormatProperties&lt;/code&gt;::&lt;code&gt;maxMipLevels&lt;/code&gt; (as returned by &lt;code&gt;vkGetPhysicalDeviceImageFormatProperties&lt;/code&gt; with &lt;code&gt;format&lt;/code&gt;, &lt;code&gt;imageType&lt;/code&gt;, &lt;code&gt;tiling&lt;/code&gt;, &lt;code&gt;usage&lt;/code&gt;, and &lt;code&gt;flags&lt;/code&gt; equal to those in this structure)</source>
          <target state="translated">어떤 경우 &lt;code&gt;extent.width&lt;/code&gt; 는 , &lt;code&gt;extent.height&lt;/code&gt; , 또는 &lt;code&gt;extent.depth&lt;/code&gt; 가 의 동등라는 이름의 회원보다 큰 &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; :: &lt;code&gt;maxImageDimension3D&lt;/code&gt; , &lt;code&gt;mipLevels&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 같보다 작거나 수 &lt;code&gt;VkImageFormatProperties&lt;/code&gt; :: &lt;code&gt;maxMipLevels&lt;/code&gt; 에 의해 반환 ( &lt;code&gt;vkGetPhysicalDeviceImageFormatProperties&lt;/code&gt; 와 &lt;code&gt;format&lt;/code&gt; , &lt;code&gt;imageType&lt;/code&gt; , 이 구조 와 동일한 &lt;code&gt;tiling&lt;/code&gt; , &lt;code&gt;usage&lt;/code&gt; 및 &lt;code&gt;flags&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="5c2b1cf49a82beacdc3babdbcb621672777242b3" translate="yes" xml:space="preserve">
          <source>If any of the &lt;code&gt;initialLayout&lt;/code&gt; members of the &lt;code&gt;VkAttachmentDescription&lt;/code&gt; structures specified when creating the render pass specified in the &lt;code&gt;renderPass&lt;/code&gt; member of &lt;code&gt;pRenderPassBegin&lt;/code&gt; is not &lt;code&gt;VK_IMAGE_LAYOUT_UNDEFINED&lt;/code&gt;, then each such &lt;code&gt;initialLayout&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be equal to the current layout of the corresponding attachment image subresource of the framebuffer specified in the &lt;code&gt;framebuffer&lt;/code&gt; member of &lt;code&gt;pRenderPassBegin&lt;/code&gt;</source>
          <target state="translated">의 모든 경우 &lt;code&gt;initialLayout&lt;/code&gt; 용 의 부재 &lt;code&gt;VkAttachmentDescription&lt;/code&gt; 의 (가)에 지정된 전달 렌더링 만들 때 구조 지정된 &lt;code&gt;renderPass&lt;/code&gt; 의 멤버 &lt;code&gt;pRenderPassBegin&lt;/code&gt; 되지 &lt;code&gt;VK_IMAGE_LAYOUT_UNDEFINED&lt;/code&gt; , 각 예 &lt;code&gt;initialLayout&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 에 지정된 프레임 버퍼의 대응 부착 화상 하위 리소스의 현재의 레이아웃과 동일 할 &lt;code&gt;pRenderPassBegin&lt;/code&gt; 의 &lt;code&gt;framebuffer&lt;/code&gt; 멤버</target>
        </trans-unit>
        <trans-unit id="1abdb81f27d8e164a2d6e34742ce3368442d9b80" translate="yes" xml:space="preserve">
          <source>If any of the &lt;code&gt;initialLayout&lt;/code&gt; or &lt;code&gt;finalLayout&lt;/code&gt; member of the &lt;code&gt;VkAttachmentDescription&lt;/code&gt; structures or the &lt;code&gt;layout&lt;/code&gt; member of the &lt;code&gt;VkAttachmentReference&lt;/code&gt; structures specified when creating the render pass specified in the &lt;code&gt;renderPass&lt;/code&gt; member of &lt;code&gt;pRenderPassBegin&lt;/code&gt; is &lt;code&gt;VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL&lt;/code&gt; then the corresponding attachment image subresource of the framebuffer specified in the &lt;code&gt;framebuffer&lt;/code&gt; member of &lt;code&gt;pRenderPassBegin&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; have been created with &lt;code&gt;VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT&lt;/code&gt; set</source>
          <target state="translated">의 모든 경우 &lt;code&gt;initialLayout&lt;/code&gt; 또는 &lt;code&gt;finalLayout&lt;/code&gt; 의 부재 &lt;code&gt;VkAttachmentDescription&lt;/code&gt; 의 구조 또는 &lt;code&gt;layout&lt;/code&gt; 의 부재 &lt;code&gt;VkAttachmentReference&lt;/code&gt; 의 상기에 명시된 패스 렌더링 만들 때 구조는 지정된 &lt;code&gt;renderPass&lt;/code&gt; 의 멤버 &lt;code&gt;pRenderPassBegin&lt;/code&gt; 된다 &lt;code&gt;VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL&lt;/code&gt; 를 다음에 지정된 프레임 버퍼의 대응 부착 화상 하위 리소스 &lt;code&gt;framebuffer&lt;/code&gt; 의 부재 &lt;code&gt;pRenderPassBegin&lt;/code&gt; &lt;strong&gt;은 &lt;/strong&gt; &lt;code&gt;VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT&lt;/code&gt; 세트 로 작성 &lt;strong&gt;해야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c77672399b27fc9ac5d44e1bb040d056c3bb29ef" translate="yes" xml:space="preserve">
          <source>If any of the &lt;code&gt;initialLayout&lt;/code&gt; or &lt;code&gt;finalLayout&lt;/code&gt; member of the &lt;code&gt;VkAttachmentDescription&lt;/code&gt; structures or the &lt;code&gt;layout&lt;/code&gt; member of the &lt;code&gt;VkAttachmentReference&lt;/code&gt; structures specified when creating the render pass specified in the &lt;code&gt;renderPass&lt;/code&gt; member of &lt;code&gt;pRenderPassBegin&lt;/code&gt; is &lt;code&gt;VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL&lt;/code&gt; or &lt;code&gt;VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL&lt;/code&gt; then the corresponding attachment image subresource of the framebuffer specified in the &lt;code&gt;framebuffer&lt;/code&gt; member of &lt;code&gt;pRenderPassBegin&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; have been created with &lt;code&gt;VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT&lt;/code&gt; set</source>
          <target state="translated">의 모든 경우 &lt;code&gt;initialLayout&lt;/code&gt; 또는 &lt;code&gt;finalLayout&lt;/code&gt; 의 부재 &lt;code&gt;VkAttachmentDescription&lt;/code&gt; 의 구조 또는 &lt;code&gt;layout&lt;/code&gt; 의 부재 &lt;code&gt;VkAttachmentReference&lt;/code&gt; 의 (가)에 지정된 전달 렌더링 만들 때 구조는 지정된 &lt;code&gt;renderPass&lt;/code&gt; 의 멤버 &lt;code&gt;pRenderPassBegin&lt;/code&gt; 이다 &lt;code&gt;VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL&lt;/code&gt; 또는 &lt;code&gt;VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL&lt;/code&gt; 다음에 지정된 프레임 버퍼의 대응 부착 화상 하위 리소스 &lt;code&gt;framebuffer&lt;/code&gt; 회원 &lt;code&gt;pRenderPassBegin&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 로 만들어졌다 &lt;code&gt;VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT&lt;/code&gt; 세트</target>
        </trans-unit>
        <trans-unit id="3d533c57f5f6565fc79d39467e183d2a2c7be8c7" translate="yes" xml:space="preserve">
          <source>If any of the &lt;code&gt;initialLayout&lt;/code&gt; or &lt;code&gt;finalLayout&lt;/code&gt; member of the &lt;code&gt;VkAttachmentDescription&lt;/code&gt; structures or the &lt;code&gt;layout&lt;/code&gt; member of the &lt;code&gt;VkAttachmentReference&lt;/code&gt; structures specified when creating the render pass specified in the &lt;code&gt;renderPass&lt;/code&gt; member of &lt;code&gt;pRenderPassBegin&lt;/code&gt; is &lt;code&gt;VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL&lt;/code&gt; then the corresponding attachment image subresource of the framebuffer specified in the &lt;code&gt;framebuffer&lt;/code&gt; member of &lt;code&gt;pRenderPassBegin&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; have been created with &lt;code&gt;VK_IMAGE_USAGE_SAMPLED_BIT&lt;/code&gt; or &lt;code&gt;VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT&lt;/code&gt; set</source>
          <target state="translated">의 모든 경우 &lt;code&gt;initialLayout&lt;/code&gt; 또는 &lt;code&gt;finalLayout&lt;/code&gt; 의 부재 &lt;code&gt;VkAttachmentDescription&lt;/code&gt; 의 구조 또는 &lt;code&gt;layout&lt;/code&gt; 의 부재 &lt;code&gt;VkAttachmentReference&lt;/code&gt; 의 상기에 명시된 패스 렌더링 만들 때 구조는 지정된 &lt;code&gt;renderPass&lt;/code&gt; 의 멤버 &lt;code&gt;pRenderPassBegin&lt;/code&gt; 된다 &lt;code&gt;VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL&lt;/code&gt; 를 다음에 지정된 프레임 버퍼의 대응 부착 화상 하위 리소스 &lt;code&gt;framebuffer&lt;/code&gt; 의 부재 &lt;code&gt;pRenderPassBegin&lt;/code&gt; &lt;strong&gt;은 &lt;/strong&gt; &lt;code&gt;VK_IMAGE_USAGE_SAMPLED_BIT&lt;/code&gt; 또는 &lt;code&gt;VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT&lt;/code&gt; 세트 로 작성 &lt;strong&gt;해야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4ab70f466c36ce5127a3f106d06a73496bfb97e6" translate="yes" xml:space="preserve">
          <source>If any of the &lt;code&gt;initialLayout&lt;/code&gt; or &lt;code&gt;finalLayout&lt;/code&gt; member of the &lt;code&gt;VkAttachmentDescription&lt;/code&gt; structures or the &lt;code&gt;layout&lt;/code&gt; member of the &lt;code&gt;VkAttachmentReference&lt;/code&gt; structures specified when creating the render pass specified in the &lt;code&gt;renderPass&lt;/code&gt; member of &lt;code&gt;pRenderPassBegin&lt;/code&gt; is &lt;code&gt;VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL&lt;/code&gt; then the corresponding attachment image subresource of the framebuffer specified in the &lt;code&gt;framebuffer&lt;/code&gt; member of &lt;code&gt;pRenderPassBegin&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; have been created with &lt;code&gt;VK_IMAGE_USAGE_TRANSFER_DST_BIT&lt;/code&gt; set</source>
          <target state="translated">의 모든 경우 &lt;code&gt;initialLayout&lt;/code&gt; 또는 &lt;code&gt;finalLayout&lt;/code&gt; 의 부재 &lt;code&gt;VkAttachmentDescription&lt;/code&gt; 의 구조 또는 &lt;code&gt;layout&lt;/code&gt; 의 부재 &lt;code&gt;VkAttachmentReference&lt;/code&gt; 의 상기에 명시된 패스 렌더링 만들 때 구조는 지정된 &lt;code&gt;renderPass&lt;/code&gt; 의 멤버 &lt;code&gt;pRenderPassBegin&lt;/code&gt; 된다 &lt;code&gt;VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL&lt;/code&gt; 를 다음에 지정된 프레임 버퍼의 대응 부착 화상 하위 리소스 &lt;code&gt;framebuffer&lt;/code&gt; 의 부재 &lt;code&gt;pRenderPassBegin&lt;/code&gt; &lt;strong&gt;은 &lt;/strong&gt; &lt;code&gt;VK_IMAGE_USAGE_TRANSFER_DST_BIT&lt;/code&gt; 세트 로 작성 &lt;strong&gt;되어야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5305deb202180d717ad266514bd4aad80565ff6e" translate="yes" xml:space="preserve">
          <source>If any of the &lt;code&gt;initialLayout&lt;/code&gt; or &lt;code&gt;finalLayout&lt;/code&gt; member of the &lt;code&gt;VkAttachmentDescription&lt;/code&gt; structures or the &lt;code&gt;layout&lt;/code&gt; member of the &lt;code&gt;VkAttachmentReference&lt;/code&gt; structures specified when creating the render pass specified in the &lt;code&gt;renderPass&lt;/code&gt; member of &lt;code&gt;pRenderPassBegin&lt;/code&gt; is &lt;code&gt;VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL&lt;/code&gt; then the corresponding attachment image subresource of the framebuffer specified in the &lt;code&gt;framebuffer&lt;/code&gt; member of &lt;code&gt;pRenderPassBegin&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; have been created with &lt;code&gt;VK_IMAGE_USAGE_TRANSFER_SRC_BIT&lt;/code&gt; set</source>
          <target state="translated">의 모든 경우 &lt;code&gt;initialLayout&lt;/code&gt; 또는 &lt;code&gt;finalLayout&lt;/code&gt; 의 부재 &lt;code&gt;VkAttachmentDescription&lt;/code&gt; 의 구조 또는 &lt;code&gt;layout&lt;/code&gt; 의 부재 &lt;code&gt;VkAttachmentReference&lt;/code&gt; 의 상기에 명시된 패스 렌더링 만들 때 구조는 지정된 &lt;code&gt;renderPass&lt;/code&gt; 의 멤버 &lt;code&gt;pRenderPassBegin&lt;/code&gt; 된다 &lt;code&gt;VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL&lt;/code&gt; 를 다음에 지정된 프레임 버퍼의 대응 부착 화상 하위 리소스 &lt;code&gt;framebuffer&lt;/code&gt; 의 부재 &lt;code&gt;pRenderPassBegin&lt;/code&gt; &lt;strong&gt;은 &lt;/strong&gt; &lt;code&gt;VK_IMAGE_USAGE_TRANSFER_SRC_BIT&lt;/code&gt; 세트 로 작성 &lt;strong&gt;되어야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0148f704015f23d4df0dc715e04efbeb2c70079a" translate="yes" xml:space="preserve">
          <source>If any of the bits &lt;code&gt;VK_IMAGE_CREATE_SPARSE_BINDING_BIT&lt;/code&gt;, &lt;code&gt;VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT&lt;/code&gt;, or &lt;code&gt;VK_IMAGE_CREATE_SPARSE_ALIASED_BIT&lt;/code&gt; are set, &lt;code&gt;VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not also be set.</source>
          <target state="translated">비트 &lt;code&gt;VK_IMAGE_CREATE_SPARSE_BINDING_BIT&lt;/code&gt; , &lt;code&gt;VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT&lt;/code&gt; 또는 &lt;code&gt;VK_IMAGE_CREATE_SPARSE_ALIASED_BIT&lt;/code&gt; 가 설정되어 &lt;code&gt;VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT&lt;/code&gt; VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT 도 설정 하지 않아야 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="4ae63bd5cde694200ed125fd89960b61f43f2a24" translate="yes" xml:space="preserve">
          <source>If any of the sets being bound include dynamic uniform or storage buffers, then &lt;code&gt;pDynamicOffsets&lt;/code&gt; includes one element for each array element in each dynamic descriptor type binding in each set. Values are taken from &lt;code&gt;pDynamicOffsets&lt;/code&gt; in an order such that all entries for set N come before set N+1; within a set, entries are ordered by the binding numbers in the descriptor set layouts; and within a binding array, elements are in order. &lt;code&gt;dynamicOffsetCount&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; equal the total number of dynamic descriptors in the sets being bound.</source>
          <target state="translated">바인딩되는 세트 중 하나에 동적 균일 또는 스토리지 버퍼가 포함 된 경우 &lt;code&gt;pDynamicOffsets&lt;/code&gt; 는 각 세트의 각 동적 설명자 유형 바인딩에서 각 배열 요소에 대해 하나의 요소를 포함합니다. 세트 N에 대한 모든 항목이 세트 N + 1 앞에 오도록 &lt;code&gt;pDynamicOffsets&lt;/code&gt; 에서 값을 가져옵니다 . 세트 내에서 디스크립터 세트 레이아웃의 바인딩 번호에 따라 항목이 정렬됩니다. 바인딩 배열 내에서 요소가 순서대로 있습니다. &lt;code&gt;dynamicOffsetCount&lt;/code&gt; &lt;strong&gt;는&lt;/strong&gt; 바인딩되는 집합의 총 동적 설명자 수와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="5fd348f32058ed2eb19cad51f7414a5dff93ab02" translate="yes" xml:space="preserve">
          <source>If any two subpasses operate on attachments with overlapping ranges of the same &lt;code&gt;VkDeviceMemory&lt;/code&gt; object, and at least one subpass writes to that area of &lt;code&gt;VkDeviceMemory&lt;/code&gt;, a subpass dependency &lt;strong&gt;must&lt;/strong&gt; be included (either directly or via some intermediate subpasses) between them</source>
          <target state="translated">두 개의 서브 패스가 동일한 &lt;code&gt;VkDeviceMemory&lt;/code&gt; 객체의 범위가 겹치는 첨부 파일에 대해 작동하고 하나 이상의 서브 패스가 &lt;code&gt;VkDeviceMemory&lt;/code&gt; 의 해당 영역에 쓰면 서브 패스 종속성 이 그들 사이에 포함 &lt;strong&gt;되어야&lt;/strong&gt; 합니다 (직접 또는 일부 중간 서브 패스를 통해).</target>
        </trans-unit>
        <trans-unit id="6283bff285e02c629dd47b46ed5b85cbdfcd0c4d" translate="yes" xml:space="preserve">
          <source>If at least one vertex of the input primitive lies inside the clipping volume, the counter is incremented by one or more.</source>
          <target state="translated">입력 프리미티브의 적어도 하나의 정점이 클리핑 볼륨 내부에 있으면, 카운터는 하나 이상 증가합니다.</target>
        </trans-unit>
        <trans-unit id="e3e243733eb75c471d9ffa24e4003d91c42f1e23" translate="yes" xml:space="preserve">
          <source>If device loss occurs (see &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-lost-device&quot;&gt;Lost Device&lt;/a&gt;) before the timeout has expired, &lt;code&gt;vkWaitForFences&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; return in finite time with either &lt;code&gt;VK_SUCCESS&lt;/code&gt; or &lt;code&gt;VK_DEVICE_LOST&lt;/code&gt;.</source>
          <target state="translated">장치 손실이 발생하는 경우 (참조 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-lost-device&quot;&gt;분실 장치를&lt;/a&gt; 제한 시간이 만료되기 전에) &lt;code&gt;vkWaitForFences&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 하나와 유한 한 시간에 돌아 &lt;code&gt;VK_SUCCESS&lt;/code&gt; 또는 &lt;code&gt;VK_DEVICE_LOST&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a7b93c5125a9f239b221b47fb098724d7b8b8a4" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;oldLayout&lt;/code&gt; or &lt;code&gt;newLayout&lt;/code&gt; is &lt;code&gt;VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL&lt;/code&gt; then &lt;code&gt;image&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; have been created with &lt;code&gt;VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT&lt;/code&gt; set</source>
          <target state="translated">어느 경우 &lt;code&gt;oldLayout&lt;/code&gt; 또는 &lt;code&gt;newLayout&lt;/code&gt; 가 있다 &lt;code&gt;VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL&lt;/code&gt; 다음 &lt;code&gt;image&lt;/code&gt; &lt;strong&gt;있어야합니다&lt;/strong&gt; 으로 생성 된 &lt;code&gt;VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT&lt;/code&gt; 의 세트</target>
        </trans-unit>
        <trans-unit id="3e062bf5cf02a8bbfe17c445a678e1ccf656716e" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;oldLayout&lt;/code&gt; or &lt;code&gt;newLayout&lt;/code&gt; is &lt;code&gt;VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL&lt;/code&gt; then &lt;code&gt;image&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; have been created with &lt;code&gt;VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT&lt;/code&gt; set</source>
          <target state="translated">어느 경우 &lt;code&gt;oldLayout&lt;/code&gt; 또는 &lt;code&gt;newLayout&lt;/code&gt; 가 있다 &lt;code&gt;VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL&lt;/code&gt; 다음 &lt;code&gt;image&lt;/code&gt; &lt;strong&gt;있어야합니다&lt;/strong&gt; 으로 생성 된 &lt;code&gt;VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT&lt;/code&gt; 의 세트</target>
        </trans-unit>
        <trans-unit id="dc16023738da3c60f71e0c4c4af58a711960659e" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;oldLayout&lt;/code&gt; or &lt;code&gt;newLayout&lt;/code&gt; is &lt;code&gt;VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL&lt;/code&gt; then &lt;code&gt;image&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; have been created with &lt;code&gt;VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT&lt;/code&gt; set</source>
          <target state="translated">어느 경우 &lt;code&gt;oldLayout&lt;/code&gt; 또는 &lt;code&gt;newLayout&lt;/code&gt; 가 있다 &lt;code&gt;VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL&lt;/code&gt; 다음 &lt;code&gt;image&lt;/code&gt; &lt;strong&gt;있어야합니다&lt;/strong&gt; 으로 생성 된 &lt;code&gt;VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT&lt;/code&gt; 의 세트</target>
        </trans-unit>
        <trans-unit id="9a84522f99a3f957d5c7c0b6d3d575ec2c277b89" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;oldLayout&lt;/code&gt; or &lt;code&gt;newLayout&lt;/code&gt; is &lt;code&gt;VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL&lt;/code&gt; then &lt;code&gt;image&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; have been created with &lt;code&gt;VK_IMAGE_USAGE_SAMPLED_BIT&lt;/code&gt; or &lt;code&gt;VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT&lt;/code&gt; set</source>
          <target state="translated">어느 경우 &lt;code&gt;oldLayout&lt;/code&gt; 또는 &lt;code&gt;newLayout&lt;/code&gt; 가 있다 &lt;code&gt;VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL&lt;/code&gt; 는 다음 &lt;code&gt;image&lt;/code&gt; &lt;strong&gt;있어야합니다&lt;/strong&gt; 으로 생성 된 &lt;code&gt;VK_IMAGE_USAGE_SAMPLED_BIT&lt;/code&gt; 또는 &lt;code&gt;VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT&lt;/code&gt; 의 세트</target>
        </trans-unit>
        <trans-unit id="34f9ecb75bd34ded21dcd62bfb565cd57b629355" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;oldLayout&lt;/code&gt; or &lt;code&gt;newLayout&lt;/code&gt; is &lt;code&gt;VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL&lt;/code&gt; then &lt;code&gt;image&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; have been created with &lt;code&gt;VK_IMAGE_USAGE_TRANSFER_DST_BIT&lt;/code&gt; set</source>
          <target state="translated">어느 경우 &lt;code&gt;oldLayout&lt;/code&gt; 또는 &lt;code&gt;newLayout&lt;/code&gt; 가 있다 &lt;code&gt;VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL&lt;/code&gt; 다음 &lt;code&gt;image&lt;/code&gt; &lt;strong&gt;있어야합니다&lt;/strong&gt; 으로 생성 된 &lt;code&gt;VK_IMAGE_USAGE_TRANSFER_DST_BIT&lt;/code&gt; 의 세트</target>
        </trans-unit>
        <trans-unit id="1344282c088503e695174d47f4c647525e985b4c" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;oldLayout&lt;/code&gt; or &lt;code&gt;newLayout&lt;/code&gt; is &lt;code&gt;VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL&lt;/code&gt; then &lt;code&gt;image&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; have been created with &lt;code&gt;VK_IMAGE_USAGE_TRANSFER_SRC_BIT&lt;/code&gt; set</source>
          <target state="translated">어느 경우 &lt;code&gt;oldLayout&lt;/code&gt; 또는 &lt;code&gt;newLayout&lt;/code&gt; 가 있다 &lt;code&gt;VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL&lt;/code&gt; 다음 &lt;code&gt;image&lt;/code&gt; &lt;strong&gt;있어야합니다&lt;/strong&gt; 으로 생성 된 &lt;code&gt;VK_IMAGE_USAGE_TRANSFER_SRC_BIT&lt;/code&gt; 의 세트</target>
        </trans-unit>
        <trans-unit id="b86307d3aa001c5d575c1b42e8db4b7419b3cc4e" translate="yes" xml:space="preserve">
          <source>If either of &lt;code&gt;pfnInternalAllocation&lt;/code&gt; or &lt;code&gt;pfnInternalFree&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, both &lt;strong&gt;must&lt;/strong&gt; be valid callbacks</source>
          <target state="translated">&lt;code&gt;pfnInternalAllocation&lt;/code&gt; 또는 &lt;code&gt;pfnInternalFree&lt;/code&gt; 중 하나가 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 둘 다 유효한 콜백 &lt;strong&gt;이어야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="1aee68bcd44fde9f982f69dc1933fce71fd8a4fd" translate="yes" xml:space="preserve">
          <source>If either of &lt;code&gt;srcImage&lt;/code&gt; or &lt;code&gt;dstImage&lt;/code&gt; was created with a depth/stencil format, the other &lt;strong&gt;must&lt;/strong&gt; have exactly the same format</source>
          <target state="translated">&lt;code&gt;srcImage&lt;/code&gt; 또는 &lt;code&gt;dstImage&lt;/code&gt; 중 하나가 깊이 / 스텐실 형식으로 작성된 경우 다른 형식 은 정확히 동일한 형식 &lt;strong&gt;이어야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="6a7dbd465c4e840b81df6a4b6b2b55bd00e86206" translate="yes" xml:space="preserve">
          <source>If either of &lt;code&gt;srcImage&lt;/code&gt; or &lt;code&gt;dstImage&lt;/code&gt; was created with a signed integer &lt;a href=&quot;#VkFormat&quot;&gt;VkFormat&lt;/a&gt;, the other &lt;strong&gt;must&lt;/strong&gt; also have been created with a signed integer &lt;a href=&quot;#VkFormat&quot;&gt;VkFormat&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;srcImage&lt;/code&gt; 또는 &lt;code&gt;dstImage&lt;/code&gt; 중 하나가 부호있는 정수 &lt;a href=&quot;#VkFormat&quot;&gt;VkFormat&lt;/a&gt; 으로 작성된 경우 다른 하나 &lt;strong&gt;는&lt;/strong&gt; 부호있는 정수 &lt;a href=&quot;#VkFormat&quot;&gt;VkFormat&lt;/a&gt; 으로 작성된 것이 &lt;strong&gt;어야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5f9b29cd6edaa3bea1c98d54a698cb1dc570eb00" translate="yes" xml:space="preserve">
          <source>If either of &lt;code&gt;srcImage&lt;/code&gt; or &lt;code&gt;dstImage&lt;/code&gt; was created with an unsigned integer &lt;a href=&quot;#VkFormat&quot;&gt;VkFormat&lt;/a&gt;, the other &lt;strong&gt;must&lt;/strong&gt; also have been created with an unsigned integer &lt;a href=&quot;#VkFormat&quot;&gt;VkFormat&lt;/a&gt;</source>
          <target state="translated">어느 경우 &lt;code&gt;srcImage&lt;/code&gt; 또는 &lt;code&gt;dstImage&lt;/code&gt; 이 부호없는 정수로 만들어진 &lt;a href=&quot;#VkFormat&quot;&gt;VkFormat&lt;/a&gt; , 다른 &lt;strong&gt;필수는&lt;/strong&gt; 또한 부호없는 정수로 만들어진 &lt;a href=&quot;#VkFormat&quot;&gt;VkFormat&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e45ff6670dcb9d8847472be2d590a7a5da96aac0" translate="yes" xml:space="preserve">
          <source>If either of the calling command&amp;rsquo;s &lt;code&gt;srcImage&lt;/code&gt; or &lt;code&gt;dstImage&lt;/code&gt; parameters are of &lt;a href=&quot;#VkImageType&quot;&gt;VkImageType&lt;/a&gt;&lt;code&gt;VK_IMAGE_TYPE_3D&lt;/code&gt;, the &lt;code&gt;baseArrayLayer&lt;/code&gt; and &lt;code&gt;layerCount&lt;/code&gt; members of both &lt;code&gt;srcSubresource&lt;/code&gt; and &lt;code&gt;dstSubresource&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;, respectively</source>
          <target state="translated">호출 명령의 어느 경우 &lt;code&gt;srcImage&lt;/code&gt; 또는 &lt;code&gt;dstImage&lt;/code&gt; 매개 변수의 수 있습니다 &lt;a href=&quot;#VkImageType&quot;&gt;VkImageType &lt;/a&gt; &lt;code&gt;VK_IMAGE_TYPE_3D&lt;/code&gt; 의 &lt;code&gt;baseArrayLayer&lt;/code&gt; 및 &lt;code&gt;layerCount&lt;/code&gt; 모두의 구성원 &lt;code&gt;srcSubresource&lt;/code&gt; 및 &lt;code&gt;dstSubresource&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;1&lt;/code&gt; 은 각각</target>
        </trans-unit>
        <trans-unit id="ead68b86880e27eaeba799db5f15fa268485c9e8" translate="yes" xml:space="preserve">
          <source>If multiple &lt;code&gt;VkDescriptorPoolSize&lt;/code&gt; structures appear in the &lt;code&gt;pPoolSizes&lt;/code&gt; array then the pool will be created with enough storage for the total number of descriptors of each type.</source>
          <target state="translated">&lt;code&gt;pPoolSizes&lt;/code&gt; 배열 에 여러 개의 &lt;code&gt;VkDescriptorPoolSize&lt;/code&gt; 구조가 나타나면 풀은 각 유형의 총 설명자 수를위한 충분한 저장소로 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="611a36b9a86ca5bd0b9575d048f206ea33a6991c" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; were provided when &lt;code&gt;buffer&lt;/code&gt; was created, &lt;code&gt;pAllocator&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;NULL&lt;/code&gt;</source>
          <target state="translated">어떤 경우 &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; 이 때 제공되지 않았다 &lt;code&gt;buffer&lt;/code&gt; 생성, &lt;code&gt;pAllocator&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d860cbed380b9b1c0b6371b27a4843c1fb79cd20" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; were provided when &lt;code&gt;bufferView&lt;/code&gt; was created, &lt;code&gt;pAllocator&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;NULL&lt;/code&gt;</source>
          <target state="translated">어떤 경우 &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; 이 때 제공되지 않았다 &lt;code&gt;bufferView&lt;/code&gt; 가 생성, &lt;code&gt;pAllocator&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6af912fcb2d37426aa57a0e10a8f789fdb0aed86" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; were provided when &lt;code&gt;commandPool&lt;/code&gt; was created, &lt;code&gt;pAllocator&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;NULL&lt;/code&gt;</source>
          <target state="translated">어떤 경우 &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; 이 때 제공되지 않았다 &lt;code&gt;commandPool&lt;/code&gt; 가 생성, &lt;code&gt;pAllocator&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f96ca67412eca85fe9efb228077c1664df849baa" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; were provided when &lt;code&gt;descriptorPool&lt;/code&gt; was created, &lt;code&gt;pAllocator&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;NULL&lt;/code&gt;</source>
          <target state="translated">어떤 경우 &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; 이 때 제공되지 않았다 &lt;code&gt;descriptorPool&lt;/code&gt; 가 생성, &lt;code&gt;pAllocator&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f11cfcca3eb498f8b9143fe4ac1deefd6b503ea2" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; were provided when &lt;code&gt;descriptorSetLayout&lt;/code&gt; was created, &lt;code&gt;pAllocator&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;NULL&lt;/code&gt;</source>
          <target state="translated">어떤 경우 &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; 이 때 제공되지 않았다 &lt;code&gt;descriptorSetLayout&lt;/code&gt; 가 생성, &lt;code&gt;pAllocator&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bfa3560cf0b7946080cedfe2bf19c7814295afbb" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; were provided when &lt;code&gt;device&lt;/code&gt; was created, &lt;code&gt;pAllocator&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;NULL&lt;/code&gt;</source>
          <target state="translated">어떤 경우 &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; 이 때 제공되지 않았다 &lt;code&gt;device&lt;/code&gt; 생성, &lt;code&gt;pAllocator&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="447c081043a5019bf4ab882afd54507a018c35ef" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; were provided when &lt;code&gt;event&lt;/code&gt; was created, &lt;code&gt;pAllocator&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;NULL&lt;/code&gt;</source>
          <target state="translated">어떤 경우 &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; 이 때 제공되지 않았다 &lt;code&gt;event&lt;/code&gt; 생성 된, &lt;code&gt;pAllocator&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a58417319f29675e303d72863ca1c172317ff71" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; were provided when &lt;code&gt;fence&lt;/code&gt; was created, &lt;code&gt;pAllocator&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;NULL&lt;/code&gt;</source>
          <target state="translated">어떤 경우 &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; 이 때 제공되지 않았다 &lt;code&gt;fence&lt;/code&gt; 생성, &lt;code&gt;pAllocator&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="acb7684df3b05554e7a3fd66177c6708fef02cf3" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; were provided when &lt;code&gt;framebuffer&lt;/code&gt; was created, &lt;code&gt;pAllocator&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;NULL&lt;/code&gt;</source>
          <target state="translated">어떤 경우 &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; 이 때 제공되지 않았다 &lt;code&gt;framebuffer&lt;/code&gt; 생성, &lt;code&gt;pAllocator&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c322ed965cd889df307b5caaf8c3929096f10191" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; were provided when &lt;code&gt;image&lt;/code&gt; was created, &lt;code&gt;pAllocator&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;NULL&lt;/code&gt;</source>
          <target state="translated">어떤 경우 &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; 이 때 제공되지 않았다 &lt;code&gt;image&lt;/code&gt; 생성, &lt;code&gt;pAllocator&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60d2e24c828f353144df8d55555e02e6c392c3f6" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; were provided when &lt;code&gt;imageView&lt;/code&gt; was created, &lt;code&gt;pAllocator&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;NULL&lt;/code&gt;</source>
          <target state="translated">어떤 경우 &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; 이 때 제공되지 않았다 &lt;code&gt;imageView&lt;/code&gt; 생성, &lt;code&gt;pAllocator&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0bb002dc5fc93f68fa26b7054bdf5c0362d32cea" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; were provided when &lt;code&gt;instance&lt;/code&gt; was created, &lt;code&gt;pAllocator&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;NULL&lt;/code&gt;</source>
          <target state="translated">어떤 경우 &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; 이 때 제공되지 않았다 &lt;code&gt;instance&lt;/code&gt; 생성, &lt;code&gt;pAllocator&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2dac316c2314ba87dc4a0c54372487d77090189e" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; were provided when &lt;code&gt;pipeline&lt;/code&gt; was created, &lt;code&gt;pAllocator&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;NULL&lt;/code&gt;</source>
          <target state="translated">어떤 경우 &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; 이 때 제공되지 않았다 &lt;code&gt;pipeline&lt;/code&gt; 생성, &lt;code&gt;pAllocator&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e5d0323f1547f1e160709af9c60e7be0647ce1b" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; were provided when &lt;code&gt;pipelineCache&lt;/code&gt; was created, &lt;code&gt;pAllocator&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;NULL&lt;/code&gt;</source>
          <target state="translated">어떤 경우 &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; 이 때 제공되지 않았다 &lt;code&gt;pipelineCache&lt;/code&gt; 가 생성, &lt;code&gt;pAllocator&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cc5c86238fab88bdc569b87b3ae8d452305f46be" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; were provided when &lt;code&gt;pipelineLayout&lt;/code&gt; was created, &lt;code&gt;pAllocator&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;NULL&lt;/code&gt;</source>
          <target state="translated">어떤 경우 &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; 이 때 제공되지 않았다 &lt;code&gt;pipelineLayout&lt;/code&gt; 가 생성, &lt;code&gt;pAllocator&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb3017d255a45986bf0188eab49704d936356e9e" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; were provided when &lt;code&gt;queryPool&lt;/code&gt; was created, &lt;code&gt;pAllocator&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;NULL&lt;/code&gt;</source>
          <target state="translated">어떤 경우 &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; 이 때 제공되지 않았다 &lt;code&gt;queryPool&lt;/code&gt; 가 생성, &lt;code&gt;pAllocator&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4ee0fc24eb866dd9d739b9da0e10b14faeb32d85" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; were provided when &lt;code&gt;renderPass&lt;/code&gt; was created, &lt;code&gt;pAllocator&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;NULL&lt;/code&gt;</source>
          <target state="translated">어떤 경우 &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; 이 때 제공되지 않았다 &lt;code&gt;renderPass&lt;/code&gt; 가 생성, &lt;code&gt;pAllocator&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f6ec5109e5eb44b8023977a1bb224047a254ddf3" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; were provided when &lt;code&gt;sampler&lt;/code&gt; was created, &lt;code&gt;pAllocator&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;NULL&lt;/code&gt;</source>
          <target state="translated">어떤 경우 &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; 이 때 제공되지 않았다 &lt;code&gt;sampler&lt;/code&gt; 생성, &lt;code&gt;pAllocator&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d13f89c72359065eeb422aa7befe83a0ad735fda" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; were provided when &lt;code&gt;semaphore&lt;/code&gt; was created, &lt;code&gt;pAllocator&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;NULL&lt;/code&gt;</source>
          <target state="translated">어떤 경우 &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; 이 때 제공되지 않았다 &lt;code&gt;semaphore&lt;/code&gt; 생성, &lt;code&gt;pAllocator&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="199b4f37001ed5b016d5dee45e393aff8f499147" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; were provided when &lt;code&gt;shaderModule&lt;/code&gt; was created, &lt;code&gt;pAllocator&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;NULL&lt;/code&gt;</source>
          <target state="translated">어떤 경우 &lt;code&gt;VkAllocationCallbacks&lt;/code&gt; 이 때 제공되지 않았다 &lt;code&gt;shaderModule&lt;/code&gt; 가 생성, &lt;code&gt;pAllocator&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c0a0d481884ac52ec9c10a45c803d438c3bdad1d" translate="yes" xml:space="preserve">
          <source>If no bits are set in &lt;code&gt;flags&lt;/code&gt;, and all requested queries are in the available state, results are written as an array of 32-bit unsigned integer values. The behavior when not all queries are available, is described &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-wait-bit-not-set&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 에 비트가 설정되지 않고 요청 된 모든 쿼리가 사용 가능한 상태 인 경우 결과는 32 비트 부호없는 정수 값의 배열로 작성됩니다. 모든 쿼리를 사용할 수없는 경우의 동작은 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-wait-bit-not-set&quot;&gt;아래&lt;/a&gt; 에 설명 되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="08c0b3f0795dd32d65ed3356cbe299d40888c697" translate="yes" xml:space="preserve">
          <source>If no bits are set in &lt;code&gt;flags&lt;/code&gt;, results for all requested queries in the available state are written as 32-bit unsigned integer values, and nothing is written for queries in the unavailable state.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 에 비트가 설정되지 않은 경우 , 사용 가능한 상태의 모든 요청 된 쿼리에 대한 결과는 32 비트 부호없는 정수 값으로 기록되고, 사용할 수없는 상태의 쿼리에는 아무것도 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2cf0621523d8b65efaee0e910f7c70ec2a47cb52" translate="yes" xml:space="preserve">
          <source>If no depth buffer is present, r is undefined.</source>
          <target state="translated">깊이 버퍼가 없으면 r은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c2f712b93dc942ce61a9cc633185bc883c43daa3" translate="yes" xml:space="preserve">
          <source>If no element of the &lt;code&gt;pDynamicStates&lt;/code&gt; member of &lt;code&gt;pDynamicState&lt;/code&gt; is &lt;code&gt;VK_DYNAMIC_STATE_DEPTH_BOUNDS&lt;/code&gt;, and the &lt;code&gt;depthBoundsTestEnable&lt;/code&gt; member of &lt;code&gt;pDepthStencil&lt;/code&gt; is &lt;code&gt;VK_TRUE&lt;/code&gt;, the &lt;code&gt;minDepthBounds&lt;/code&gt; and &lt;code&gt;maxDepthBounds&lt;/code&gt; members of &lt;code&gt;pDepthStencil&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be between &lt;code&gt;0.0&lt;/code&gt; and &lt;code&gt;1.0&lt;/code&gt;, inclusive</source>
          <target state="translated">어떠한 요소의 경우 &lt;code&gt;pDynamicStates&lt;/code&gt; 의 멤버 &lt;code&gt;pDynamicState&lt;/code&gt; 는 없다 &lt;code&gt;VK_DYNAMIC_STATE_DEPTH_BOUNDS&lt;/code&gt; 및 &lt;code&gt;depthBoundsTestEnable&lt;/code&gt; 의 부재 &lt;code&gt;pDepthStencil&lt;/code&gt; 가 있다 &lt;code&gt;VK_TRUE&lt;/code&gt; 상기 &lt;code&gt;minDepthBounds&lt;/code&gt; 및 &lt;code&gt;maxDepthBounds&lt;/code&gt; 구성원 &lt;code&gt;pDepthStencil&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 사이 &lt;code&gt;0.0&lt;/code&gt; 및 &lt;code&gt;1.0&lt;/code&gt; , 포함</target>
        </trans-unit>
        <trans-unit id="7992cb9a7f3ba36755f5fb5804cb7ceb8d86801e" translate="yes" xml:space="preserve">
          <source>If no element of the &lt;code&gt;pDynamicStates&lt;/code&gt; member of &lt;code&gt;pDynamicState&lt;/code&gt; is &lt;code&gt;VK_DYNAMIC_STATE_SCISSOR&lt;/code&gt;, the &lt;code&gt;pScissors&lt;/code&gt; member of &lt;code&gt;pViewportState&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to an array of &lt;code&gt;pViewportState&lt;/code&gt;::&lt;code&gt;scissorCount&lt;/code&gt;&lt;code&gt;VkRect2D&lt;/code&gt; structures</source>
          <target state="translated">의 어떤 요소 경우 &lt;code&gt;pDynamicStates&lt;/code&gt; 의 회원 &lt;code&gt;pDynamicState&lt;/code&gt; 가 없습니다 &lt;code&gt;VK_DYNAMIC_STATE_SCISSOR&lt;/code&gt; 가 의 &lt;code&gt;pScissors&lt;/code&gt; 의 회원 &lt;code&gt;pViewportState&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 의 배열에 대한 포인터가 될 &lt;code&gt;pViewportState&lt;/code&gt; :: &lt;code&gt;scissorCount&lt;/code&gt; &lt;code&gt;VkRect2D&lt;/code&gt; 의 구조</target>
        </trans-unit>
        <trans-unit id="25bc3bf52dcbe37ecd9f865915172756584a3477" translate="yes" xml:space="preserve">
          <source>If no element of the &lt;code&gt;pDynamicStates&lt;/code&gt; member of &lt;code&gt;pDynamicState&lt;/code&gt; is &lt;code&gt;VK_DYNAMIC_STATE_VIEWPORT&lt;/code&gt;, the &lt;code&gt;pViewports&lt;/code&gt; member of &lt;code&gt;pViewportState&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to an array of &lt;code&gt;pViewportState&lt;/code&gt;::&lt;code&gt;viewportCount&lt;/code&gt;&lt;code&gt;VkViewport&lt;/code&gt; structures</source>
          <target state="translated">의 어떤 요소 경우 &lt;code&gt;pDynamicStates&lt;/code&gt; 의 회원 &lt;code&gt;pDynamicState&lt;/code&gt; 가 없습니다 &lt;code&gt;VK_DYNAMIC_STATE_VIEWPORT&lt;/code&gt; 가 의 &lt;code&gt;pViewports&lt;/code&gt; 의 회원 &lt;code&gt;pViewportState&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 의 배열에 대한 포인터가 될 &lt;code&gt;pViewportState&lt;/code&gt; :: &lt;code&gt;viewportCount&lt;/code&gt; &lt;code&gt;VkViewport&lt;/code&gt; 의 구조</target>
        </trans-unit>
        <trans-unit id="8eea36eb9ec6fe0a5913c655be7596290db5c201" translate="yes" xml:space="preserve">
          <source>If no format feature flags are supported, then the only possible use would be image transfers - which alone are not useful. As such, if no format feature flags are supported, the format itself is not supported, and images of that format cannot be created.</source>
          <target state="translated">형식 기능 플래그가 지원되지 않는 경우 이미지 전송 만 사용할 수 있습니다.이 기능만으로는 유용하지 않습니다. 따라서 형식 기능 플래그가 지원되지 않으면 형식 자체가 지원되지 않으며 해당 형식의 이미지를 작성할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ead417d6c56baefbc026877b1d703810fedd61b9" translate="yes" xml:space="preserve">
          <source>If rasterization is not disabled and &lt;code&gt;subpass&lt;/code&gt; uses a depth/stencil attachment in &lt;code&gt;renderpass&lt;/code&gt; that has a layout of &lt;code&gt;VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL&lt;/code&gt; in the &lt;code&gt;VkAttachmentReference&lt;/code&gt; defined by &lt;code&gt;subpass&lt;/code&gt;, the &lt;code&gt;depthWriteEnable&lt;/code&gt; member of &lt;code&gt;pDepthStencilState&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;VK_FALSE&lt;/code&gt;</source>
          <target state="translated">래스터 &lt;code&gt;renderpass&lt;/code&gt; 비활성화되지 않고 &lt;code&gt;subpass&lt;/code&gt; 가 &lt;code&gt;subpass&lt;/code&gt; 정의 된 &lt;code&gt;VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL&lt;/code&gt; 에서 VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL 의 레이아웃을 갖는 렌더 패스 의 깊이 / 스텐실 부착물을 사용하는 경우 &lt;code&gt;VkAttachmentReference&lt;/code&gt; 의 &lt;code&gt;depthWriteEnable&lt;/code&gt; 멤버는 &lt;code&gt;pDepthStencilState&lt;/code&gt; &lt;strong&gt;여야&lt;/strong&gt; 합니다 &lt;code&gt;VK_FALSE&lt;/code&gt; &lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6c1f715373edf5ac883a7904779508216bce55f6" translate="yes" xml:space="preserve">
          <source>If rasterization is not disabled and &lt;code&gt;subpass&lt;/code&gt; uses a depth/stencil attachment in &lt;code&gt;renderpass&lt;/code&gt; that has a layout of &lt;code&gt;VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL&lt;/code&gt; in the &lt;code&gt;VkAttachmentReference&lt;/code&gt; defined by &lt;code&gt;subpass&lt;/code&gt;, the &lt;code&gt;failOp&lt;/code&gt;, &lt;code&gt;passOp&lt;/code&gt; and &lt;code&gt;depthFailOp&lt;/code&gt; members of each of the &lt;code&gt;front&lt;/code&gt; and &lt;code&gt;back&lt;/code&gt; members of &lt;code&gt;pDepthStencilState&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;VK_STENCIL_OP_KEEP&lt;/code&gt;</source>
          <target state="translated">래스터 화는 중지되지 않고, 경우 &lt;code&gt;subpass&lt;/code&gt; 이 있는 깊이 / 스텐실 첨부 사용 &lt;code&gt;renderpass&lt;/code&gt; 의 배치 갖는다 &lt;code&gt;VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL&lt;/code&gt; 에 &lt;code&gt;VkAttachmentReference&lt;/code&gt; 의해 정의 &lt;code&gt;subpass&lt;/code&gt; 를 상기 &lt;code&gt;failOp&lt;/code&gt; , &lt;code&gt;passOp&lt;/code&gt; 및 &lt;code&gt;depthFailOp&lt;/code&gt; 의 각 부재 &lt;code&gt;front&lt;/code&gt; 과 &lt;code&gt;back&lt;/code&gt; 의 부재 &lt;code&gt;pDepthStencilState&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 할 &lt;code&gt;VK_STENCIL_OP_KEEP&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="906d6c3e271b3a87401342b38e86942431f543f9" translate="yes" xml:space="preserve">
          <source>If rasterization is not disabled and the subpass uses color attachments, the &lt;code&gt;attachmentCount&lt;/code&gt; member of &lt;code&gt;pColorBlendState&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be equal to the &lt;code&gt;colorAttachmentCount&lt;/code&gt; used to create &lt;code&gt;subpass&lt;/code&gt;</source>
          <target state="translated">래스터 화는 중지되지 않고, 첨부 subpass 컬러를 사용하는 경우 &lt;code&gt;attachmentCount&lt;/code&gt; 의 멤버 &lt;code&gt;pColorBlendState&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 받는 동일 &lt;code&gt;colorAttachmentCount&lt;/code&gt; 를 만드는 데 사용 &lt;code&gt;subpass&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="62b08239cf239fe8158ecbbb47036c4eebcc1c02" translate="yes" xml:space="preserve">
          <source>If rasterization is not disabled and the subpass uses color attachments, then for each color attachment in the subpass the &lt;code&gt;blendEnable&lt;/code&gt; member of the corresponding element of the &lt;code&gt;pAttachment&lt;/code&gt; member of &lt;code&gt;pColorBlendState&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;VK_FALSE&lt;/code&gt; if the &lt;code&gt;format&lt;/code&gt; of the attachment does not support color blend operations, as specified by the &lt;code&gt;VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT&lt;/code&gt; flag in &lt;code&gt;VkFormatProperties&lt;/code&gt;::&lt;code&gt;linearTilingFeatures&lt;/code&gt; or &lt;code&gt;VkFormatProperties&lt;/code&gt;::&lt;code&gt;optimalTilingFeatures&lt;/code&gt; returned by &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt;</source>
          <target state="translated">래스터 화는 중지되지 않고, subpass가 subpass 각 색 부착 한 후, 컬러 첨부를 사용하는 경우 &lt;code&gt;blendEnable&lt;/code&gt; 의 대응하는 요소의 부재 &lt;code&gt;pAttachment&lt;/code&gt; 의 멤버 &lt;code&gt;pColorBlendState&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 할 &lt;code&gt;VK_FALSE&lt;/code&gt; 경우 생성 &lt;code&gt;format&lt;/code&gt; 첨부하지 지원 색상 혼합 조작과 마찬가지로, &lt;code&gt;VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT&lt;/code&gt; 에서 VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT 플래그에 의해 &lt;code&gt;VkFormatProperties&lt;/code&gt; :: &lt;code&gt;linearTilingFeatures&lt;/code&gt; 또는 &lt;code&gt;VkFormatProperties&lt;/code&gt; :: &lt;code&gt;optimalTilingFeatures&lt;/code&gt; 의해 리턴 된 &lt;code&gt;vkGetPhysicalDeviceFormatProperties&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5b9b3f8fcb8e9e334dfe0e57955140abc897f270" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#VkImageSubresourceRange&quot;&gt;VkImageSubresourceRange&lt;/a&gt;::&lt;code&gt;layerCount&lt;/code&gt; member of any element of the &lt;code&gt;pRanges&lt;/code&gt; array is not &lt;code&gt;VK_REMAINING_ARRAY_LAYERS&lt;/code&gt;, it &lt;strong&gt;must&lt;/strong&gt; be non-zero and &lt;a href=&quot;#VkImageSubresourceRange&quot;&gt;VkImageSubresourceRange&lt;/a&gt;::&lt;code&gt;baseArrayLayer&lt;/code&gt; + &lt;a href=&quot;#VkImageSubresourceRange&quot;&gt;VkImageSubresourceRange&lt;/a&gt;::&lt;code&gt;layerCount&lt;/code&gt; for that element of the &lt;code&gt;pRanges&lt;/code&gt; array &lt;strong&gt;must&lt;/strong&gt; be less than or equal to the &lt;code&gt;arrayLayers&lt;/code&gt; specified in &lt;a href=&quot;#VkImageCreateInfo&quot;&gt;VkImageCreateInfo&lt;/a&gt; when &lt;code&gt;image&lt;/code&gt; was created</source>
          <target state="translated">경우] &lt;a href=&quot;#VkImageSubresourceRange&quot;&gt;VkImageSubresourceRange&lt;/a&gt; :: &lt;code&gt;layerCount&lt;/code&gt; 에서 의 임의의 요소의 부재 &lt;code&gt;pRanges&lt;/code&gt; 의 배열이 아닌 &lt;code&gt;VK_REMAINING_ARRAY_LAYERS&lt;/code&gt; 그것은 &lt;strong&gt;해야&lt;/strong&gt; 비제하고 &lt;a href=&quot;#VkImageSubresourceRange&quot;&gt;VkImageSubresourceRange&lt;/a&gt; :: &lt;code&gt;baseArrayLayer&lt;/code&gt; + &lt;a href=&quot;#VkImageSubresourceRange&quot;&gt;VkImageSubresourceRange&lt;/a&gt; :: &lt;code&gt;layerCount&lt;/code&gt; 는 의 해당 요소 &lt;code&gt;pRanges&lt;/code&gt; 의 배열 &lt;strong&gt;해야&lt;/strong&gt; 미만이거나 동일 &lt;code&gt;arrayLayers&lt;/code&gt; &lt;code&gt;image&lt;/code&gt; 생성 시 &lt;a href=&quot;#VkImageCreateInfo&quot;&gt;VkImageCreateInfo에&lt;/a&gt; 지정</target>
        </trans-unit>
        <trans-unit id="cde5730f20a274fb72adbbc8221f7e48cd139a7c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#VkImageSubresourceRange&quot;&gt;VkImageSubresourceRange&lt;/a&gt;::&lt;code&gt;levelCount&lt;/code&gt; member of any element of the &lt;code&gt;pRanges&lt;/code&gt; array is not &lt;code&gt;VK_REMAINING_MIP_LEVELS&lt;/code&gt;, it &lt;strong&gt;must&lt;/strong&gt; be non-zero and &lt;a href=&quot;#VkImageSubresourceRange&quot;&gt;VkImageSubresourceRange&lt;/a&gt;::&lt;code&gt;baseMipLevel&lt;/code&gt; + &lt;a href=&quot;#VkImageSubresourceRange&quot;&gt;VkImageSubresourceRange&lt;/a&gt;::&lt;code&gt;levelCount&lt;/code&gt; for that element of the &lt;code&gt;pRanges&lt;/code&gt; array &lt;strong&gt;must&lt;/strong&gt; be less than or equal to the &lt;code&gt;mipLevels&lt;/code&gt; specified in &lt;a href=&quot;#VkImageCreateInfo&quot;&gt;VkImageCreateInfo&lt;/a&gt; when &lt;code&gt;image&lt;/code&gt; was created</source>
          <target state="translated">경우] &lt;a href=&quot;#VkImageSubresourceRange&quot;&gt;VkImageSubresourceRange&lt;/a&gt; :: &lt;code&gt;levelCount&lt;/code&gt; 에서 의 임의의 요소의 부재 &lt;code&gt;pRanges&lt;/code&gt; 의 배열이 아닌 &lt;code&gt;VK_REMAINING_MIP_LEVELS&lt;/code&gt; 그것은 &lt;strong&gt;해야&lt;/strong&gt; 비제 될 &lt;a href=&quot;#VkImageSubresourceRange&quot;&gt;VkImageSubresourceRange&lt;/a&gt; :: &lt;code&gt;baseMipLevel&lt;/code&gt; + &lt;a href=&quot;#VkImageSubresourceRange&quot;&gt;VkImageSubresourceRange&lt;/a&gt; :: &lt;code&gt;levelCount&lt;/code&gt; 의 해당 요소 &lt;code&gt;pRanges&lt;/code&gt; 의 배열 &lt;strong&gt;해야&lt;/strong&gt; 미만이거나 동일 &lt;code&gt;mipLevels&lt;/code&gt; &lt;code&gt;image&lt;/code&gt; 생성 시 &lt;a href=&quot;#VkImageCreateInfo&quot;&gt;VkImageCreateInfo에&lt;/a&gt; 지정</target>
        </trans-unit>
        <trans-unit id="c322bee62d2ddab575cb8eedb3f410b49779209d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-alphaToOne&quot;&gt;alpha to one&lt;/a&gt; feature is not enabled, &lt;code&gt;alphaToOneEnable&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;VK_FALSE&lt;/code&gt;</source>
          <target state="translated">경우 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-alphaToOne&quot;&gt;하나 개의 알파&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;alphaToOneEnable&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;VK_FALSE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e74c3a5e60f215935ffc3c377bcfbd0b388639c4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-depthBiasClamp&quot;&gt;depth bias clamping&lt;/a&gt; feature is not enabled, &lt;code&gt;depthBiasClamp&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;0&lt;/code&gt;.0</source>
          <target state="translated">는 IF &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-depthBiasClamp&quot;&gt;깊이 바이어스 클램핑&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;depthBiasClamp&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;0&lt;/code&gt; 0.0</target>
        </trans-unit>
        <trans-unit id="111fa9c31716ee62155af018d21c603e686048fa" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-depthBounds&quot;&gt;depth bounds testing&lt;/a&gt; feature is not enabled, &lt;code&gt;depthBoundsTestEnable&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;VK_FALSE&lt;/code&gt;</source>
          <target state="translated">는 IF &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-depthBounds&quot;&gt;깊이 경계 테스트&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;depthBoundsTestEnable&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;VK_FALSE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a69f88fe8ec2f5761a31f7ef324e627f43f05c11" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-depthClamp&quot;&gt;depth clamping&lt;/a&gt; feature is not enabled, &lt;code&gt;depthClampEnable&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;VK_FALSE&lt;/code&gt;</source>
          <target state="translated">는 IF &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-depthClamp&quot;&gt;깊이 클램핑&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;depthClampEnable&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;VK_FALSE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e3c3b720441771f315c83d3478425685d9c9c102" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-drawIndirectFirstInstance&quot;&gt;drawIndirectFirstInstance&lt;/a&gt; feature is not enabled, &lt;code&gt;firstInstance&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">는 IF &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-drawIndirectFirstInstance&quot;&gt;drawIndirectFirstInstance의&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;firstInstance&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f83507eed2d3301eb58e45221fa6e3f0ef7f149b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-drawIndirectFirstInstance&quot;&gt;drawIndirectFirstInstance&lt;/a&gt; feature is not enabled, all the &lt;code&gt;firstInstance&lt;/code&gt; members of the &lt;code&gt;VkDrawIndexedIndirectCommand&lt;/code&gt; structures accessed by this command &lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">는 IF &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-drawIndirectFirstInstance&quot;&gt;drawIndirectFirstInstance의&lt;/a&gt; 기능을 사용할 수 없습니다, 모든 &lt;code&gt;firstInstance&lt;/code&gt; 의 의 구성원 &lt;code&gt;VkDrawIndexedIndirectCommand&lt;/code&gt; 의 이 명령에 의해 액세스 구조가 &lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1354c50e94216304305ded432a53e97614d06bc7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-drawIndirectFirstInstance&quot;&gt;drawIndirectFirstInstance&lt;/a&gt; feature is not enabled, all the &lt;code&gt;firstInstance&lt;/code&gt; members of the &lt;code&gt;VkDrawIndirectCommand&lt;/code&gt; structures accessed by this command &lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">는 IF &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-drawIndirectFirstInstance&quot;&gt;drawIndirectFirstInstance의&lt;/a&gt; 기능을 사용할 수 없습니다, 모든 &lt;code&gt;firstInstance&lt;/code&gt; 의 의 구성원 &lt;code&gt;VkDrawIndirectCommand&lt;/code&gt; 의 이 명령에 의해 액세스 구조가 &lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8f0264df51a2711dcf38106020a288c82ca69cfb" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-dualSrcBlend&quot;&gt;dual source blending&lt;/a&gt; feature is not enabled, &lt;code&gt;dstAlphaBlendFactor&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not be &lt;code&gt;VK_BLEND_FACTOR_SRC1_COLOR&lt;/code&gt;, &lt;code&gt;VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR&lt;/code&gt;, &lt;code&gt;VK_BLEND_FACTOR_SRC1_ALPHA&lt;/code&gt;, or &lt;code&gt;VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA&lt;/code&gt;</source>
          <target state="translated">는 IF &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-dualSrcBlend&quot;&gt;듀얼 소스 블렌딩&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;dstAlphaBlendFactor&lt;/code&gt; 는&lt;strong&gt;있어야&lt;/strong&gt; 하지 &lt;code&gt;VK_BLEND_FACTOR_SRC1_COLOR&lt;/code&gt; , &lt;code&gt;VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR&lt;/code&gt; , &lt;code&gt;VK_BLEND_FACTOR_SRC1_ALPHA&lt;/code&gt; , 또는 &lt;code&gt;VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9399ef63b292131208e0c466d2e2cd29b4caa38" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-dualSrcBlend&quot;&gt;dual source blending&lt;/a&gt; feature is not enabled, &lt;code&gt;dstColorBlendFactor&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not be &lt;code&gt;VK_BLEND_FACTOR_SRC1_COLOR&lt;/code&gt;, &lt;code&gt;VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR&lt;/code&gt;, &lt;code&gt;VK_BLEND_FACTOR_SRC1_ALPHA&lt;/code&gt;, or &lt;code&gt;VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA&lt;/code&gt;</source>
          <target state="translated">는 IF &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-dualSrcBlend&quot;&gt;듀얼 소스 블렌딩&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;dstColorBlendFactor&lt;/code&gt; 는&lt;strong&gt;있어야&lt;/strong&gt; 하지 &lt;code&gt;VK_BLEND_FACTOR_SRC1_COLOR&lt;/code&gt; , &lt;code&gt;VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR&lt;/code&gt; , &lt;code&gt;VK_BLEND_FACTOR_SRC1_ALPHA&lt;/code&gt; , 또는 &lt;code&gt;VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="66f09929cd587a67783121ca5a46955bb490bff9" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-dualSrcBlend&quot;&gt;dual source blending&lt;/a&gt; feature is not enabled, &lt;code&gt;srcAlphaBlendFactor&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not be &lt;code&gt;VK_BLEND_FACTOR_SRC1_COLOR&lt;/code&gt;, &lt;code&gt;VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR&lt;/code&gt;, &lt;code&gt;VK_BLEND_FACTOR_SRC1_ALPHA&lt;/code&gt;, or &lt;code&gt;VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA&lt;/code&gt;</source>
          <target state="translated">는 IF &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-dualSrcBlend&quot;&gt;듀얼 소스 블렌딩&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;srcAlphaBlendFactor&lt;/code&gt; 는&lt;strong&gt;있어야&lt;/strong&gt; 하지 &lt;code&gt;VK_BLEND_FACTOR_SRC1_COLOR&lt;/code&gt; , &lt;code&gt;VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR&lt;/code&gt; , &lt;code&gt;VK_BLEND_FACTOR_SRC1_ALPHA&lt;/code&gt; , 또는 &lt;code&gt;VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="743dc0434ed8b15c73fb865dd987f6cf1afa8bd0" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-dualSrcBlend&quot;&gt;dual source blending&lt;/a&gt; feature is not enabled, &lt;code&gt;srcColorBlendFactor&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not be &lt;code&gt;VK_BLEND_FACTOR_SRC1_COLOR&lt;/code&gt;, &lt;code&gt;VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR&lt;/code&gt;, &lt;code&gt;VK_BLEND_FACTOR_SRC1_ALPHA&lt;/code&gt;, or &lt;code&gt;VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA&lt;/code&gt;</source>
          <target state="translated">는 IF &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-dualSrcBlend&quot;&gt;듀얼 소스 블렌딩&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;srcColorBlendFactor&lt;/code&gt; 는&lt;strong&gt;있어야&lt;/strong&gt; 하지 &lt;code&gt;VK_BLEND_FACTOR_SRC1_COLOR&lt;/code&gt; , &lt;code&gt;VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR&lt;/code&gt; , &lt;code&gt;VK_BLEND_FACTOR_SRC1_ALPHA&lt;/code&gt; , 또는 &lt;code&gt;VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3eecd3ac20fad078ce9999b199347a3e3e7ca857" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-fillModeNonSolid&quot;&gt;non-solid fill modes&lt;/a&gt; feature is not enabled, &lt;code&gt;polygonMode&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;VK_POLYGON_MODE_FILL&lt;/code&gt;</source>
          <target state="translated">는 IF &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-fillModeNonSolid&quot;&gt;가 아닌 고체 채우기 모드&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;polygonMode&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;VK_POLYGON_MODE_FILL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5c39634f095fb8b79889c60c2856a8925675e267" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader&quot;&gt;geometry shaders&lt;/a&gt; feature is not enabled, &lt;code&gt;dstStageMask&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not contain &lt;code&gt;VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT&lt;/code&gt;</source>
          <target state="translated">경우 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader&quot;&gt;지오메트리 쉐이더&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;dstStageMask&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 포함하지 &lt;code&gt;VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="c3f64537a90f5b9cd09adc8159ae24f62cc2fbb4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader&quot;&gt;geometry shaders&lt;/a&gt; feature is not enabled, &lt;code&gt;srcStageMask&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not contain &lt;code&gt;VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT&lt;/code&gt;</source>
          <target state="translated">경우 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader&quot;&gt;지오메트리 쉐이더&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;srcStageMask&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 포함하지 &lt;code&gt;VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="11f94679d6572582496dcfcaaef787d34e434a3f" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader&quot;&gt;geometry shaders&lt;/a&gt; feature is not enabled, &lt;code&gt;stage&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not be &lt;code&gt;VK_SHADER_STAGE_GEOMETRY_BIT&lt;/code&gt;</source>
          <target state="translated">경우 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader&quot;&gt;지오메트리 쉐이더&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;stage&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 하지 &lt;code&gt;VK_SHADER_STAGE_GEOMETRY_BIT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2222eb78bb78f60bfacc69f4a5d07811f88c6ada" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader&quot;&gt;geometry shaders&lt;/a&gt; feature is not enabled, &lt;code&gt;stageMask&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not contain &lt;code&gt;VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT&lt;/code&gt;</source>
          <target state="translated">경우 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader&quot;&gt;지오메트리 쉐이더&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;stageMask&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 포함하지 &lt;code&gt;VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="8829eaee3fa05e48052f4bcac998e1cff2909463" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader&quot;&gt;geometry shaders&lt;/a&gt; feature is not enabled, &lt;code&gt;topology&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not be any of &lt;code&gt;VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY&lt;/code&gt;, &lt;code&gt;VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY&lt;/code&gt;, &lt;code&gt;VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY&lt;/code&gt; or &lt;code&gt;VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY&lt;/code&gt;</source>
          <target state="translated">경우 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader&quot;&gt;지오메트리 쉐이더&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;topology&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 어떤되지 &lt;code&gt;VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY&lt;/code&gt; , &lt;code&gt;VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY&lt;/code&gt; , &lt;code&gt;VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY&lt;/code&gt; 또는 &lt;code&gt;VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="2424fae2965d8ea9aec66da276ef89395741f37d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader&quot;&gt;geometry shaders&lt;/a&gt; feature is not enabled, any given element of &lt;code&gt;pWaitDstStageMask&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not contain &lt;code&gt;VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-geometryShader&quot;&gt;지오메트리 셰이더&lt;/a&gt; 기능이 활성화되어 있지 않은 경우, 지정된 &lt;code&gt;pWaitDstStageMask&lt;/code&gt; 요소에는 VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT &lt;strong&gt;가&lt;/strong&gt; 포함 &lt;code&gt;VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT&lt;/code&gt; 는 안됩니다</target>
        </trans-unit>
        <trans-unit id="acc0990b0b710a9702f1027bde60787124f25cf6" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-imageCubeArray&quot;&gt;image cubemap arrays&lt;/a&gt; feature is not enabled, &lt;code&gt;viewType&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not be &lt;code&gt;VK_IMAGE_VIEW_TYPE_CUBE_ARRAY&lt;/code&gt;</source>
          <target state="translated">는 IF &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-imageCubeArray&quot;&gt;이미지 큐브 맵 배열의&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;viewType&lt;/code&gt; 는&lt;strong&gt;있어야&lt;/strong&gt; 하지 &lt;code&gt;VK_IMAGE_VIEW_TYPE_CUBE_ARRAY&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="642f76aea901257d2f8c127bcc400900583677f3" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-independentBlend&quot;&gt;independent blending&lt;/a&gt; feature is not enabled, all elements of &lt;code&gt;pAttachments&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be identical</source>
          <target state="translated">&lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-independentBlend&quot;&gt;독립 블렌딩&lt;/a&gt; 기능이 활성화되어 있지 않은 경우 , 모든 &lt;code&gt;pAttachments&lt;/code&gt; 요소 가 동일 &lt;strong&gt;해야&lt;/strong&gt; 합니다</target>
        </trans-unit>
        <trans-unit id="76a2a550f29516665dd2f547e5140c600dbacdcf" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-inheritedQueries&quot;&gt;inherited queries&lt;/a&gt; feature is enabled, &lt;code&gt;queryFlags&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a valid combination of &lt;a href=&quot;#VkQueryControlFlagBits&quot;&gt;VkQueryControlFlagBits&lt;/a&gt; values</source>
          <target state="translated">경우 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-inheritedQueries&quot;&gt;상속 쿼리&lt;/a&gt; 기능이 활성화되어, &lt;code&gt;queryFlags&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 유효한 조합 &lt;a href=&quot;#VkQueryControlFlagBits&quot;&gt;VkQueryControlFlagBits의&lt;/a&gt; 값</target>
        </trans-unit>
        <trans-unit id="40cc5527e27bed4ccb3e6f99182e68a84c7fd397" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-inheritedQueries&quot;&gt;inherited queries&lt;/a&gt; feature is not enabled, &lt;code&gt;commandBuffer&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not have any queries &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-operation-active&quot;&gt;active&lt;/a&gt;</source>
          <target state="translated">경우 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-inheritedQueries&quot;&gt;상속 된 쿼리&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;commandBuffer&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 어떤 쿼리하지 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-operation-active&quot;&gt;활성&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e4fda0ad23fe8e80b4168f8bd91aaa802554c9f7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-inheritedQueries&quot;&gt;inherited queries&lt;/a&gt; feature is not enabled, &lt;code&gt;occlusionQueryEnable&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;VK_FALSE&lt;/code&gt;</source>
          <target state="translated">경우 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-inheritedQueries&quot;&gt;상속 된 쿼리&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;occlusionQueryEnable&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;VK_FALSE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8135bd89da71d581208c0179d5a77f5ee478c849" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-logicOp&quot;&gt;logic operations&lt;/a&gt; feature is not enabled, &lt;code&gt;logicOpEnable&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;VK_FALSE&lt;/code&gt;</source>
          <target state="translated">는 IF &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-logicOp&quot;&gt;논리 연산의&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;logicOpEnable&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;VK_FALSE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2d92ff8a68ccbf68f3a6edbc5116d4e6898e6907" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-multiDrawIndirect&quot;&gt;multi-draw indirect&lt;/a&gt; feature is not enabled, &lt;code&gt;drawCount&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;</source>
          <target state="translated">경우 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-multiDrawIndirect&quot;&gt;간접 멀티 - 그릴&lt;/a&gt; 사용할 수 없습니다 기능을 &lt;code&gt;drawCount&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="55d6971adae1dbde505f966300f98e01810d2ea0" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-multiViewport&quot;&gt;multiple viewports&lt;/a&gt; feature is not enabled, &lt;code&gt;firstScissor&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">경우 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-multiViewport&quot;&gt;여러 뷰포트의&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;firstScissor&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca06b6bc4dc7e431cf51fb6837b610da2d557d7d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-multiViewport&quot;&gt;multiple viewports&lt;/a&gt; feature is not enabled, &lt;code&gt;firstViewport&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">경우 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-multiViewport&quot;&gt;여러 뷰포트의&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;firstViewport&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c95f8419faa39e7564e1fc7713850ebf6cb8a01e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-multiViewport&quot;&gt;multiple viewports&lt;/a&gt; feature is not enabled, &lt;code&gt;scissorCount&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;1&lt;/code&gt;</source>
          <target state="translated">경우 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-multiViewport&quot;&gt;여러 뷰포트의&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;scissorCount&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 수 &lt;code&gt;1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cbc7ca33404faeaf98946afcde84b0f5ed36de75" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-multiViewport&quot;&gt;multiple viewports&lt;/a&gt; feature is not enabled, &lt;code&gt;viewportCount&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;1&lt;/code&gt;</source>
          <target state="translated">경우 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-multiViewport&quot;&gt;여러 뷰포트의&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;viewportCount&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 수 &lt;code&gt;1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49baf291469b002195a5b1676488d74ce73aff0b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-occlusionQueryPrecise&quot;&gt;precise occlusion queries&lt;/a&gt; feature is not enabled, or the &lt;code&gt;queryType&lt;/code&gt; used to create &lt;code&gt;queryPool&lt;/code&gt; was not &lt;code&gt;VK_QUERY_TYPE_OCCLUSION&lt;/code&gt;, &lt;code&gt;flags&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not contain &lt;code&gt;VK_QUERY_CONTROL_PRECISE_BIT&lt;/code&gt;</source>
          <target state="translated">경우 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-occlusionQueryPrecise&quot;&gt;정확한 교합 쿼리&lt;/a&gt; 기능을 사용할 수 없습니다, 또는 &lt;code&gt;queryType&lt;/code&gt; 을 만드는 데 사용 &lt;code&gt;queryPool&lt;/code&gt; 은 아니었다 &lt;code&gt;VK_QUERY_TYPE_OCCLUSION&lt;/code&gt; , &lt;code&gt;flags&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 포함하지 &lt;code&gt;VK_QUERY_CONTROL_PRECISE_BIT&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="ac0fb9e57efd62ce19829e3d042ceabf17eace05" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-pipelineStatisticsQuery&quot;&gt;pipeline statistics queries&lt;/a&gt; feature is not enabled, &lt;code&gt;pipelineStatistics&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">경우 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-pipelineStatisticsQuery&quot;&gt;파이프 라인 통계 쿼리&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;pipelineStatistics&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="27ac77ecf0a40b8c619b6c439706756befd672d7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-pipelineStatisticsQuery&quot;&gt;pipeline statistics queries&lt;/a&gt; feature is not enabled, &lt;code&gt;queryType&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not be &lt;code&gt;VK_QUERY_TYPE_PIPELINE_STATISTICS&lt;/code&gt;</source>
          <target state="translated">경우 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-pipelineStatisticsQuery&quot;&gt;파이프 라인 통계 쿼리&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;queryType&lt;/code&gt; 는&lt;strong&gt;있어야&lt;/strong&gt; 하지 &lt;code&gt;VK_QUERY_TYPE_PIPELINE_STATISTICS&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9976ffac3cde217487b7c0840f0991867d992a3a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-robustBufferAccess&quot;&gt;robust buffer access&lt;/a&gt; feature is not enabled, and any shader stage in the &lt;code&gt;VkPipeline&lt;/code&gt; object currently bound to &lt;code&gt;VK_PIPELINE_BIND_POINT_COMPUTE&lt;/code&gt; accesses a storage buffer, it &lt;strong&gt;must&lt;/strong&gt; not access values outside of the range of that buffer specified in the currently bound descriptor set</source>
          <target state="translated">경우] &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-robustBufferAccess&quot;&gt;강력한 버퍼 액세스&lt;/a&gt; 기능이 설정되지 않고, 임의 셰이더 스테이지 &lt;code&gt;VkPipeline&lt;/code&gt; 의 현재 결합 오브젝트 &lt;code&gt;VK_PIPELINE_BIND_POINT_COMPUTE&lt;/code&gt; 는 저장 버퍼를 액세스, 그것은 &lt;strong&gt;반드시&lt;/strong&gt; 현재 결합 설명자 세트에 지정된 버퍼의 범위 밖에없는 액세스 값</target>
        </trans-unit>
        <trans-unit id="c5b1897e901ec1ad8154314904868053b2bfb7df" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-robustBufferAccess&quot;&gt;robust buffer access&lt;/a&gt; feature is not enabled, and any shader stage in the &lt;code&gt;VkPipeline&lt;/code&gt; object currently bound to &lt;code&gt;VK_PIPELINE_BIND_POINT_COMPUTE&lt;/code&gt; accesses a uniform buffer, it &lt;strong&gt;must&lt;/strong&gt; not access values outside of the range of that buffer specified in the currently bound descriptor set</source>
          <target state="translated">경우] &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-robustBufferAccess&quot;&gt;강력한 버퍼 액세스&lt;/a&gt; 기능이 설정되지 않고, 임의 셰이더 스테이지 &lt;code&gt;VkPipeline&lt;/code&gt; 의 현재 결합 오브젝트 &lt;code&gt;VK_PIPELINE_BIND_POINT_COMPUTE&lt;/code&gt; 가 일정한 버퍼에 액세스는 &lt;strong&gt;반드시&lt;/strong&gt; 현재 결합 설명자 세트에 지정된 버퍼의 범위 밖에없는 액세스 값</target>
        </trans-unit>
        <trans-unit id="254463d35a32fa2db64de805248156bf3f0aade4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-robustBufferAccess&quot;&gt;robust buffer access&lt;/a&gt; feature is not enabled, and any shader stage in the &lt;code&gt;VkPipeline&lt;/code&gt; object currently bound to &lt;code&gt;VK_PIPELINE_BIND_POINT_GRAPHICS&lt;/code&gt; accesses a storage buffer, it &lt;strong&gt;must&lt;/strong&gt; not access values outside of the range of that buffer specified in the currently bound descriptor set</source>
          <target state="translated">경우 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-robustBufferAccess&quot;&gt;강력한 버퍼 액세스&lt;/a&gt; 기능을 활성화하고, 어떤 쉐이더 단계되지 &lt;code&gt;VkPipeline&lt;/code&gt; 현재 결합 오브젝트 &lt;code&gt;VK_PIPELINE_BIND_POINT_GRAPHICS&lt;/code&gt; 는 저장 버퍼를 액세스, 그것은 &lt;strong&gt;반드시&lt;/strong&gt; 현재 결합 설명자 세트에 지정된 버퍼의 범위 밖에없는 액세스 값</target>
        </trans-unit>
        <trans-unit id="93a1c0f79f8814aa2b27367e321dc7a54cf0ac35" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-robustBufferAccess&quot;&gt;robust buffer access&lt;/a&gt; feature is not enabled, and any shader stage in the &lt;code&gt;VkPipeline&lt;/code&gt; object currently bound to &lt;code&gt;VK_PIPELINE_BIND_POINT_GRAPHICS&lt;/code&gt; accesses a uniform buffer, it &lt;strong&gt;must&lt;/strong&gt; not access values outside of the range of that buffer specified in the currently bound descriptor set</source>
          <target state="translated">경우 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-robustBufferAccess&quot;&gt;강력한 버퍼 액세스&lt;/a&gt; 기능을 활성화하고, 어떤 쉐이더 단계되지 &lt;code&gt;VkPipeline&lt;/code&gt; 의 객체는 현재에 바인딩 &lt;code&gt;VK_PIPELINE_BIND_POINT_GRAPHICS&lt;/code&gt; 가 일정한 버퍼에 액세스는 &lt;strong&gt;반드시&lt;/strong&gt; 현재 결합 설명자 세트에 지정된 버퍼의 범위 밖에없는 액세스 값</target>
        </trans-unit>
        <trans-unit id="b6d313b54b0c268a28329b648ea0051fd9291336" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sampleRateShading&quot;&gt;sample rate shading&lt;/a&gt; feature is not enabled, &lt;code&gt;sampleShadingEnable&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;VK_FALSE&lt;/code&gt;</source>
          <target state="translated">는 IF &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sampleRateShading&quot;&gt;샘플 속도 쉐이딩&lt;/a&gt; 기능은 사용할 수 없습니다 &lt;code&gt;sampleShadingEnable&lt;/code&gt; &lt;strong&gt; 있어야&lt;/strong&gt; 할 &lt;code&gt;VK_FALSE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd88a091d5f18c889fe4617022650e067e37466e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-samplerAnisotropy&quot;&gt;anisotropic sampling&lt;/a&gt; feature is not enabled, &lt;code&gt;anisotropyEnable&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;VK_FALSE&lt;/code&gt;</source>
          <target state="translated">비 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-samplerAnisotropy&quot;&gt;등방성 샘플링&lt;/a&gt; 기능이 활성화되어 있지 않으면 비 &lt;code&gt;anisotropyEnable&lt;/code&gt; 활성화는 &lt;code&gt;VK_FALSE&lt;/code&gt; &lt;strong&gt;여야&lt;/strong&gt; 합니다 .</target>
        </trans-unit>
        <trans-unit id="e116085a28a475b6b7b8a01b18447a02493c9ca4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-shaderStorageImageMultisample&quot;&gt;multisampled storage images&lt;/a&gt; feature is not enabled, and &lt;code&gt;usage&lt;/code&gt; contains &lt;code&gt;VK_IMAGE_USAGE_STORAGE_BIT&lt;/code&gt;, &lt;code&gt;samples&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;VK_SAMPLE_COUNT_1_BIT&lt;/code&gt;</source>
          <target state="translated">는 IF &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-shaderStorageImageMultisample&quot;&gt;멀티 샘플링 저장 이미지&lt;/a&gt; 기능이 활성화되지 않고 &lt;code&gt;usage&lt;/code&gt; 포함 &lt;code&gt;VK_IMAGE_USAGE_STORAGE_BIT&lt;/code&gt; 를 , &lt;code&gt;samples&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;VK_SAMPLE_COUNT_1_BIT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d4710bdff50f1bfa4ea823ddfbc81d807f86a38" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseBinding&quot;&gt;sparse bindings&lt;/a&gt; feature is not enabled, &lt;code&gt;flags&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not contain &lt;code&gt;VK_BUFFER_CREATE_SPARSE_BINDING_BIT&lt;/code&gt;</source>
          <target state="translated">는 IF &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseBinding&quot;&gt;스파 스 바인딩&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;flags&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 포함하지 &lt;code&gt;VK_BUFFER_CREATE_SPARSE_BINDING_BIT&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="ff39ea7a9f52b0403e3ff2895549297b5f56feef" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseBinding&quot;&gt;sparse bindings&lt;/a&gt; feature is not enabled, &lt;code&gt;flags&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not contain &lt;code&gt;VK_IMAGE_CREATE_SPARSE_BINDING_BIT&lt;/code&gt;</source>
          <target state="translated">는 IF &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseBinding&quot;&gt;스파 스 바인딩&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;flags&lt;/code&gt; &lt;strong&gt; 있어야&lt;/strong&gt; 포함하지 &lt;code&gt;VK_IMAGE_CREATE_SPARSE_BINDING_BIT&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="b68c26b3cce7b6902b2787419155b4b275e4605c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidency16Samples&quot;&gt;sparse residency for images with 16 samples&lt;/a&gt; feature is not enabled, &lt;code&gt;imageType&lt;/code&gt; is &lt;code&gt;VK_IMAGE_TYPE_2D&lt;/code&gt;, and &lt;code&gt;samples&lt;/code&gt; is &lt;code&gt;VK_SAMPLE_COUNT_16_BIT&lt;/code&gt;, &lt;code&gt;flags&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not contain &lt;code&gt;VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidency16Samples&quot;&gt;16 개의 샘플&lt;/a&gt; 기능이있는 이미지 의 스파 스 상주 기능이 활성화되어 있지 않으면 &lt;code&gt;imageType&lt;/code&gt; 은 &lt;code&gt;VK_IMAGE_TYPE_2D&lt;/code&gt; 이고 &lt;code&gt;samples&lt;/code&gt; 은 &lt;code&gt;VK_SAMPLE_COUNT_16_BIT&lt;/code&gt; 이며 &lt;code&gt;flags&lt;/code&gt; &lt;strong&gt;는&lt;/strong&gt; 포함하지 &lt;code&gt;VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="ee87026f9f203addcce6784d2657f3c53fbd9e01" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidency2Samples&quot;&gt;sparse residency for images with 2 samples&lt;/a&gt; feature is not enabled, &lt;code&gt;imageType&lt;/code&gt; is &lt;code&gt;VK_IMAGE_TYPE_2D&lt;/code&gt;, and &lt;code&gt;samples&lt;/code&gt; is &lt;code&gt;VK_SAMPLE_COUNT_2_BIT&lt;/code&gt;, &lt;code&gt;flags&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not contain &lt;code&gt;VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidency2Samples&quot;&gt;샘플 2 &lt;/a&gt; &lt;code&gt;VK_IMAGE_TYPE_2D&lt;/code&gt; 이미지 의 스파 스 상주 기능이 활성화되어 있지 않으면 &lt;code&gt;imageType&lt;/code&gt; 은 VK_IMAGE_TYPE_2D 이고 &lt;code&gt;samples&lt;/code&gt; 은 &lt;code&gt;VK_SAMPLE_COUNT_2_BIT&lt;/code&gt; 이며 &lt;code&gt;flags&lt;/code&gt; &lt;strong&gt;는&lt;/strong&gt; 포함하지 &lt;code&gt;VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="7a058c348e7d93ffee7f4b05429d9bfa6622ee3b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidency4Samples&quot;&gt;sparse residency for images with 4 samples&lt;/a&gt; feature is not enabled, &lt;code&gt;imageType&lt;/code&gt; is &lt;code&gt;VK_IMAGE_TYPE_2D&lt;/code&gt;, and &lt;code&gt;samples&lt;/code&gt; is &lt;code&gt;VK_SAMPLE_COUNT_4_BIT&lt;/code&gt;, &lt;code&gt;flags&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not contain &lt;code&gt;VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidency4Samples&quot;&gt;4 개의 샘플&lt;/a&gt; 기능이있는 이미지에 대한 스파 스 상주 기능이 활성화되어 있지 않으면 &lt;code&gt;imageType&lt;/code&gt; 은 &lt;code&gt;VK_IMAGE_TYPE_2D&lt;/code&gt; 이고 &lt;code&gt;samples&lt;/code&gt; 은 &lt;code&gt;VK_SAMPLE_COUNT_4_BIT&lt;/code&gt; 이며 &lt;code&gt;flags&lt;/code&gt; &lt;strong&gt;는&lt;/strong&gt; 포함하지 &lt;code&gt;VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="928829923b0924897ae34d6620eb28f38834533e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidency8Samples&quot;&gt;sparse residency for images with 8 samples&lt;/a&gt; feature is not enabled, &lt;code&gt;imageType&lt;/code&gt; is &lt;code&gt;VK_IMAGE_TYPE_2D&lt;/code&gt;, and &lt;code&gt;samples&lt;/code&gt; is &lt;code&gt;VK_SAMPLE_COUNT_8_BIT&lt;/code&gt;, &lt;code&gt;flags&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not contain &lt;code&gt;VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT&lt;/code&gt;</source>
          <target state="translated">는 IF &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidency8Samples&quot;&gt;8 개 샘플로 이미지 스파 스 거주&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;imageType&lt;/code&gt; 이다 &lt;code&gt;VK_IMAGE_TYPE_2D&lt;/code&gt; 및 &lt;code&gt;samples&lt;/code&gt; 입니다 &lt;code&gt;VK_SAMPLE_COUNT_8_BIT&lt;/code&gt; , &lt;code&gt;flags&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 포함하지 &lt;code&gt;VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="4c8caca774f68c5bc255e8d90916b18401a2edc2" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidencyAliased&quot;&gt;sparse aliased residency&lt;/a&gt; feature is not enabled, &lt;code&gt;flags&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not contain &lt;code&gt;VK_BUFFER_CREATE_SPARSE_ALIASED_BIT&lt;/code&gt;</source>
          <target state="translated">는 IF &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidencyAliased&quot;&gt;스파 스 별칭 거주&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;flags&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 포함하지 &lt;code&gt;VK_BUFFER_CREATE_SPARSE_ALIASED_BIT&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="abe86865e94e013dcb0b1d387383e4a801830dbe" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidencyAliased&quot;&gt;sparse aliased residency&lt;/a&gt; feature is not enabled, and if any other resources are bound to ranges of &lt;code&gt;memory&lt;/code&gt;, the range of &lt;code&gt;memory&lt;/code&gt; being bound &lt;strong&gt;must&lt;/strong&gt; not overlap with those bound ranges</source>
          <target state="translated">는 IF &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidencyAliased&quot;&gt;스파 스 별칭 거주&lt;/a&gt; 기능을 사용할 수 없습니다, 및 기타 자원의 범위에 바인딩하는 경우 &lt;code&gt;memory&lt;/code&gt; 의 범위 &lt;code&gt;memory&lt;/code&gt; 결합 된 &lt;strong&gt;해야&lt;/strong&gt; 하지 겹쳐 그 경계 범위가</target>
        </trans-unit>
        <trans-unit id="777c2bc5485606611dbbf897703e99ac36f599f6" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidencyBuffer&quot;&gt;sparse buffer residency&lt;/a&gt; feature is not enabled, &lt;code&gt;flags&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not contain &lt;code&gt;VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT&lt;/code&gt;</source>
          <target state="translated">는 IF &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidencyBuffer&quot;&gt;스파 스 버퍼 거주&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;flags&lt;/code&gt; &lt;strong&gt;해야&lt;/strong&gt; 포함하지 &lt;code&gt;VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="f113fe7cfbcdea104a60b571e967536758182d1c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidencyImage2D&quot;&gt;sparse residency for 2D images&lt;/a&gt; feature is not enabled, and &lt;code&gt;imageType&lt;/code&gt; is &lt;code&gt;VK_IMAGE_TYPE_2D&lt;/code&gt;, &lt;code&gt;flags&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not contain &lt;code&gt;VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT&lt;/code&gt;</source>
          <target state="translated">경우 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidencyImage2D&quot;&gt;2 차원 이미지를위한 스파 스 거주&lt;/a&gt; 기능이 활성화되지 않고 &lt;code&gt;imageType&lt;/code&gt; 있다 &lt;code&gt;VK_IMAGE_TYPE_2D&lt;/code&gt; , &lt;code&gt;flags&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 포함하지 &lt;code&gt;VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="b52ef39bb86caf8cfc0a9946ef66fc267d004f28" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidencyImage3D&quot;&gt;sparse residency for 3D images&lt;/a&gt; feature is not enabled, and &lt;code&gt;imageType&lt;/code&gt; is &lt;code&gt;VK_IMAGE_TYPE_3D&lt;/code&gt;, &lt;code&gt;flags&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not contain &lt;code&gt;VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT&lt;/code&gt;</source>
          <target state="translated">경우 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-sparseResidencyImage3D&quot;&gt;3D 이미지를위한 스파 스 거주&lt;/a&gt; 기능이 활성화되지 않고 &lt;code&gt;imageType&lt;/code&gt; 있다 &lt;code&gt;VK_IMAGE_TYPE_3D&lt;/code&gt; , &lt;code&gt;flags&lt;/code&gt; &lt;strong&gt;해야&lt;/strong&gt; 포함하지 &lt;code&gt;VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="12c2011bb0f0a27036433c03249d65b59a4697f5" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader&quot;&gt;tessellation shaders&lt;/a&gt; feature is not enabled, &lt;code&gt;dstStageMask&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not contain &lt;code&gt;VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT&lt;/code&gt; or &lt;code&gt;VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT&lt;/code&gt;</source>
          <target state="translated">경우 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader&quot;&gt;테셀레이션 쉐이더&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;dstStageMask&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 포함하지 &lt;code&gt;VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT&lt;/code&gt; 을 또는 &lt;code&gt;VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="9de6ba9c7d0df84ae8b633875121c7b1d550263c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader&quot;&gt;tessellation shaders&lt;/a&gt; feature is not enabled, &lt;code&gt;srcStageMask&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not contain &lt;code&gt;VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT&lt;/code&gt; or &lt;code&gt;VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT&lt;/code&gt;</source>
          <target state="translated">경우 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader&quot;&gt;테셀레이션 쉐이더&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;srcStageMask&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 포함하지 &lt;code&gt;VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT&lt;/code&gt; 또는 &lt;code&gt;VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="c1e6a29d44f85aeb2041108e7f79a226f043ea98" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader&quot;&gt;tessellation shaders&lt;/a&gt; feature is not enabled, &lt;code&gt;stage&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not be &lt;code&gt;VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT&lt;/code&gt; or &lt;code&gt;VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT&lt;/code&gt;</source>
          <target state="translated">경우 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader&quot;&gt;테셀레이션 쉐이더&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;stage&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 하지 &lt;code&gt;VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT&lt;/code&gt; 또는 &lt;code&gt;VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="003014ad3484009e363b86365c75c24feb7bfa48" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader&quot;&gt;tessellation shaders&lt;/a&gt; feature is not enabled, &lt;code&gt;stageMask&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not contain &lt;code&gt;VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT&lt;/code&gt; or &lt;code&gt;VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT&lt;/code&gt;</source>
          <target state="translated">경우 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader&quot;&gt;테셀레이션 쉐이더&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;stageMask&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 포함하지 &lt;code&gt;VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT&lt;/code&gt; 을 또는 &lt;code&gt;VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="79198eb82f89d22b8c5a9b967eb9889f00f07905" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader&quot;&gt;tessellation shaders&lt;/a&gt; feature is not enabled, &lt;code&gt;topology&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not be &lt;code&gt;VK_PRIMITIVE_TOPOLOGY_PATCH_LIST&lt;/code&gt;</source>
          <target state="translated">경우 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader&quot;&gt;테셀레이션 쉐이더&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;topology&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 하지 &lt;code&gt;VK_PRIMITIVE_TOPOLOGY_PATCH_LIST&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="651b627e9edbd9fba4d7fcaa061ed73e93a1e4c3" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader&quot;&gt;tessellation shaders&lt;/a&gt; feature is not enabled, any given element of &lt;code&gt;pWaitDstStageMask&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not contain &lt;code&gt;VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT&lt;/code&gt; or &lt;code&gt;VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT&lt;/code&gt;</source>
          <target state="translated">경우 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-tessellationShader&quot;&gt;테셀레이션 쉐이더&lt;/a&gt; 기능을 사용할 수 없습니다의 특정 요소 &lt;code&gt;pWaitDstStageMask&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 포함하지 &lt;code&gt;VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT&lt;/code&gt; 또는 &lt;code&gt;VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="543d33885af8c35c64bce4b6c18500952460bca6" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-variableMultisampleRate&quot;&gt;variable multisample rate&lt;/a&gt; feature is not supported, &lt;code&gt;pipeline&lt;/code&gt; is a graphics pipeline, the current subpass has no attachments, and this is not the first call to this function with a graphics pipeline after transitioning to the current subpass, then the sample count specified by this pipeline &lt;strong&gt;must&lt;/strong&gt; match that set in the previous pipeline</source>
          <target state="translated">는 IF &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-variableMultisampleRate&quot;&gt;가변 멀티 샘플 속도&lt;/a&gt; 기능이 지원되지 않습니다, &lt;code&gt;pipeline&lt;/code&gt; 현재 subpass 더 첨부가없는, 그래픽 파이프 라인이며, 이는 현재 subpass로 전환 한 후 그래픽 파이프 라인이 함수의 첫 번째 호출되어 있지 않은 경우, 샘플 수에 의해 지정된 이 파이프 라인 &lt;strong&gt;은&lt;/strong&gt; 이전 파이프 라인에서 설정 한 파이프 라인 과 일치 &lt;strong&gt;해야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7c1c7925ef357111382dbac5c793739145039c7d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-wideLines&quot;&gt;wide lines&lt;/a&gt; feature is not enabled, &lt;code&gt;lineWidth&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;1.0&lt;/code&gt;</source>
          <target state="translated">는 IF &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features-wideLines&quot;&gt;넓은 라인&lt;/a&gt; 기능을 사용할 수 없습니다, &lt;code&gt;lineWidth&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;1.0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="058f43071b879c61f844c58982641dec0e041deb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;VkPipeline&lt;/code&gt; object currently bound to &lt;code&gt;VK_PIPELINE_BIND_POINT_GRAPHICS&lt;/code&gt; requires any dynamic state, that state &lt;strong&gt;must&lt;/strong&gt; have been set on the current command buffer</source>
          <target state="translated">는 IF &lt;code&gt;VkPipeline&lt;/code&gt; 의 현재에 바인딩 된 객체 &lt;code&gt;VK_PIPELINE_BIND_POINT_GRAPHICS&lt;/code&gt; 는 동적 상태를 필요로하는 상태&lt;strong&gt; 되어야&lt;/strong&gt; 현재 명령 버퍼에 있었다 세트가</target>
        </trans-unit>
        <trans-unit id="64bab4816c128dab4befd6e7e2e34b1d90450c84" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;aspectMask&lt;/code&gt; member of any given element of &lt;code&gt;pAttachments&lt;/code&gt; contains &lt;code&gt;VK_IMAGE_ASPECT_COLOR_BIT&lt;/code&gt;, the &lt;code&gt;colorAttachment&lt;/code&gt; member of those elements &lt;strong&gt;must&lt;/strong&gt; refer to a valid color attachment in the current subpass</source>
          <target state="translated">경우] &lt;code&gt;aspectMask&lt;/code&gt; 의 임의의 주어진 요소의 부재 &lt;code&gt;pAttachments&lt;/code&gt; 가 포함 &lt;code&gt;VK_IMAGE_ASPECT_COLOR_BIT&lt;/code&gt; 상기 &lt;code&gt;colorAttachment&lt;/code&gt; 의 이들 요소의 부재&lt;strong&gt; 해야&lt;/strong&gt; 현재 subpass 유효한 색 첨부 참조</target>
        </trans-unit>
        <trans-unit id="5221731fc27ca4fbe651ea6acc0e4a5b242f594a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;attachment&lt;/code&gt; member of any element of &lt;code&gt;pInputAttachments&lt;/code&gt;, &lt;code&gt;pColorAttachments&lt;/code&gt;, &lt;code&gt;pResolveAttachments&lt;/code&gt; or &lt;code&gt;pDepthStencilAttachment&lt;/code&gt;, or any element of &lt;code&gt;pPreserveAttachments&lt;/code&gt; in any given element of &lt;code&gt;pSubpasses&lt;/code&gt; is not &lt;code&gt;VK_ATTACHMENT_UNUSED&lt;/code&gt;, it &lt;strong&gt;must&lt;/strong&gt; be less than &lt;code&gt;attachmentCount&lt;/code&gt;</source>
          <target state="translated">상기 중간 &lt;code&gt;attachment&lt;/code&gt; 의 요소의 부재 &lt;code&gt;pInputAttachments&lt;/code&gt; , &lt;code&gt;pColorAttachments&lt;/code&gt; , &lt;code&gt;pResolveAttachments&lt;/code&gt; 또는 &lt;code&gt;pDepthStencilAttachment&lt;/code&gt; , 또는 임의의 소자 &lt;code&gt;pPreserveAttachments&lt;/code&gt; 의 특정 요소 &lt;code&gt;pSubpasses&lt;/code&gt; 가 되지 &lt;code&gt;VK_ATTACHMENT_UNUSED&lt;/code&gt; 그것은 &lt;strong&gt;해야&lt;/strong&gt; 미만 &lt;code&gt;attachmentCount&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6b18d3acdaa06d2007dfedeb9dd2ffce4f81ba23" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;attachment&lt;/code&gt; member of any element of &lt;code&gt;pInputAttachments&lt;/code&gt;, &lt;code&gt;pColorAttachments&lt;/code&gt;, &lt;code&gt;pResolveAttachments&lt;/code&gt; or &lt;code&gt;pDepthStencilAttachment&lt;/code&gt;, or the attachment indexed by any element of &lt;code&gt;pPreserveAttachments&lt;/code&gt; in any given element of &lt;code&gt;pSubpasses&lt;/code&gt; is bound to a range of a &lt;code&gt;VkDeviceMemory&lt;/code&gt; object that overlaps with any other attachment in any subpass (including the same subpass), the &lt;code&gt;VkAttachmentDescription&lt;/code&gt; structures describing them &lt;strong&gt;must&lt;/strong&gt; include &lt;code&gt;VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT&lt;/code&gt; in &lt;code&gt;flags&lt;/code&gt;</source>
          <target state="translated">상기 중간 &lt;code&gt;attachment&lt;/code&gt; 의 요소의 부재 &lt;code&gt;pInputAttachments&lt;/code&gt; , &lt;code&gt;pColorAttachments&lt;/code&gt; , &lt;code&gt;pResolveAttachments&lt;/code&gt; 또는 &lt;code&gt;pDepthStencilAttachment&lt;/code&gt; 또는 임의의 요소에 의해 인덱스 첨부 &lt;code&gt;pPreserveAttachments&lt;/code&gt; 의 특정 요소 &lt;code&gt;pSubpasses&lt;/code&gt; 는 (A)의 범위에 바인딩 &lt;code&gt;VkDeviceMemory&lt;/code&gt; 의 객체 임의 subpass의 다른 부착 오버랩 ( 동일한 서브 패스를 포함하여) &lt;code&gt;VkAttachmentDescription&lt;/code&gt; 구조를 설명 하는 VkAttachmentDescription 구조 에는 &lt;code&gt;VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT&lt;/code&gt; &lt;strong&gt;가&lt;/strong&gt; 포함 &lt;strong&gt;되어야합니다&lt;/strong&gt; . &lt;code&gt;flags&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a85f3733573f67982c06ef8869ac164641d4a2df" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;dstBinding&lt;/code&gt; has fewer than &lt;code&gt;descriptorCount&lt;/code&gt; array elements remaining starting from &lt;code&gt;dstArrayElement&lt;/code&gt;, then the remainder will be used to update the subsequent binding - &lt;code&gt;dstBinding&lt;/code&gt;+1 starting at array element zero. If a binding has a &lt;code&gt;descriptorCount&lt;/code&gt; of zero, it is skipped. This behavior applies recursively, with the update affecting consecutive bindings as needed to update all &lt;code&gt;descriptorCount&lt;/code&gt; descriptors.</source>
          <target state="translated">경우] &lt;code&gt;dstBinding&lt;/code&gt; 가 보다 적게 갖는 &lt;code&gt;descriptorCount&lt;/code&gt; 의 부터 나머지 배열 요소 &lt;code&gt;dstArrayElement&lt;/code&gt; - 후 나머지 후속 바인딩 업데이트하기 위해 사용될 &lt;code&gt;dstBinding&lt;/code&gt; +1 배열 요소 제로에서 시작. 바인딩에 &lt;code&gt;descriptorCount&lt;/code&gt; 가 0이면 건너 뜁니다. 이 동작은 모든 &lt;code&gt;descriptorCount&lt;/code&gt; 디스크립터 를 업데이트하기 위해 필요에 따라 연속 바인딩에 영향을 미치면서 재귀 적으로 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9b30366086b8ca074a7ccc4cb0efb13dbebd4066" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;dstSet&lt;/code&gt; member of any given element of &lt;code&gt;pDescriptorWrites&lt;/code&gt; or &lt;code&gt;pDescriptorCopies&lt;/code&gt; is bound, accessed, or modified by any command that was recorded to a command buffer which is currently in the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;recording or executable state&lt;/a&gt;, that command buffer becomes &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;invalid&lt;/a&gt;.</source>
          <target state="translated">경우] &lt;code&gt;dstSet&lt;/code&gt; 의 임의의 주어진 요소의 부재 &lt;code&gt;pDescriptorWrites&lt;/code&gt; 또는 &lt;code&gt;pDescriptorCopies&lt;/code&gt; 가 결합되어, 액세스 또는 현재 명령 버퍼에 기록 된 임의의 명령에 의해 변경된 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;기록 상태 또는 실행&lt;/a&gt; 명령 버퍼가되도록,&lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt; 무효&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3393dfa6818e1df0e7af55979bc9e3a2718ebe77" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;flags&lt;/code&gt; member of &lt;code&gt;pCreateInfo&lt;/code&gt; includes &lt;code&gt;VK_BUFFER_CREATE_SPARSE_BINDING_BIT&lt;/code&gt;, creating this &lt;code&gt;VkBuffer&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not cause the total required sparse memory for all currently valid sparse resources on the device to exceed &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt;::&lt;code&gt;sparseAddressSpaceSize&lt;/code&gt;</source>
          <target state="translated">는 IF &lt;code&gt;flags&lt;/code&gt; 의 멤버 &lt;code&gt;pCreateInfo&lt;/code&gt; 는 포함 &lt;code&gt;VK_BUFFER_CREATE_SPARSE_BINDING_BIT&lt;/code&gt; 이 생성 &lt;code&gt;VkBuffer&lt;/code&gt; 를&lt;strong&gt;해야한다&lt;/strong&gt; 전체가 초과 할 장치의 모든 현재 유효한 희소 자원에 대한 스파 스 메모리를 필요 발생하지 &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; 을 :: &lt;code&gt;sparseAddressSpaceSize&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="3b13418e7f8c7c3a44c96305f01be41cdeab9e0b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;flags&lt;/code&gt; member of &lt;code&gt;pCreateInfo&lt;/code&gt; includes &lt;code&gt;VK_IMAGE_CREATE_SPARSE_BINDING_BIT&lt;/code&gt;, creating this &lt;code&gt;VkImage&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not cause the total required sparse memory for all currently valid sparse resources on the device to exceed &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt;::&lt;code&gt;sparseAddressSpaceSize&lt;/code&gt;</source>
          <target state="translated">는 IF &lt;code&gt;flags&lt;/code&gt; 의 멤버 &lt;code&gt;pCreateInfo&lt;/code&gt; 가 포함 &lt;code&gt;VK_IMAGE_CREATE_SPARSE_BINDING_BIT&lt;/code&gt; 을 ,이 생성 &lt;code&gt;VkImage&lt;/code&gt; 은&lt;strong&gt;있어야&lt;/strong&gt; 총을 초과 할 장치의 모든 현재 유효한 희소 자원에 대한 스파 스 메모리를 필요 발생하지 &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; 을 :: &lt;code&gt;sparseAddressSpaceSize&lt;/code&gt; 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="467f63f021e4dbb163eeb41cc3d6996090813a54" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;flags&lt;/code&gt; member of any given element of &lt;code&gt;pCreateInfos&lt;/code&gt; contains the &lt;code&gt;VK_PIPELINE_CREATE_DERIVATIVE_BIT&lt;/code&gt; flag, and the &lt;code&gt;basePipelineIndex&lt;/code&gt; member of that same element is not &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;basePipelineIndex&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than the index into &lt;code&gt;pCreateInfos&lt;/code&gt; that corresponds to that element</source>
          <target state="translated">경우] &lt;code&gt;flags&lt;/code&gt; 의 주어진 요소의 부재 &lt;code&gt;pCreateInfos&lt;/code&gt; 가 포함 &lt;code&gt;VK_PIPELINE_CREATE_DERIVATIVE_BIT&lt;/code&gt; 의 플래그 및 &lt;code&gt;basePipelineIndex&lt;/code&gt; 의 동일한 요소의 부재되지 &lt;code&gt;-1&lt;/code&gt; , &lt;code&gt;basePipelineIndex&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 으로 적은 인덱스보다 &lt;code&gt;pCreateInfos&lt;/code&gt; 그 요소에 대응하는</target>
        </trans-unit>
        <trans-unit id="68c395ff3073504a29223b5980d1b3b4c3e653f6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;flags&lt;/code&gt; member of any given element of &lt;code&gt;pCreateInfos&lt;/code&gt; contains the &lt;code&gt;VK_PIPELINE_CREATE_DERIVATIVE_BIT&lt;/code&gt; flag, the base pipeline &lt;strong&gt;must&lt;/strong&gt; have been created with the &lt;code&gt;VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT&lt;/code&gt; flag set</source>
          <target state="translated">는 IF &lt;code&gt;flags&lt;/code&gt; 의 특정 요소의 회원 &lt;code&gt;pCreateInfos&lt;/code&gt; 이 포함 &lt;code&gt;VK_PIPELINE_CREATE_DERIVATIVE_BIT&lt;/code&gt; 의 플래그를 기본 파이프 라인이 &lt;strong&gt;있어야합니다&lt;/strong&gt; 로 생성 된 &lt;code&gt;VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT&lt;/code&gt; 의 플래그가 설정</target>
        </trans-unit>
        <trans-unit id="72f52b497ba4f01e5c7c76b04f2f0c77be248cc5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;queryType&lt;/code&gt; of the pool is &lt;code&gt;VK_QUERY_TYPE_OCCLUSION&lt;/code&gt; and &lt;code&gt;flags&lt;/code&gt; contains &lt;code&gt;VK_QUERY_CONTROL_PRECISE_BIT&lt;/code&gt;, an implementation &lt;strong&gt;must&lt;/strong&gt; return a result that matches the actual number of samples passed. This is described in more detail in &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-occlusion&quot;&gt;Occlusion Queries&lt;/a&gt;.</source>
          <target state="translated">풀 의 &lt;code&gt;queryType&lt;/code&gt; 이 &lt;code&gt;VK_QUERY_TYPE_OCCLUSION&lt;/code&gt; 이고 &lt;code&gt;flags&lt;/code&gt; 에 &lt;code&gt;VK_QUERY_CONTROL_PRECISE_BIT&lt;/code&gt; 가 포함 된 경우 구현 &lt;strong&gt;은&lt;/strong&gt; 전달 된 실제 샘플 수와 일치하는 결과를 리턴 &lt;strong&gt;해야합니다&lt;/strong&gt; . 이것은 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-occlusion&quot;&gt;폐색 쿼리&lt;/a&gt; 에 더 자세히 설명되어 있습니다. .</target>
        </trans-unit>
        <trans-unit id="8fc16055ec6d5098a39a55af925d9389814e04de" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;queryType&lt;/code&gt; used to create &lt;code&gt;queryPool&lt;/code&gt; was &lt;code&gt;VK_QUERY_TYPE_OCCLUSION&lt;/code&gt;, the &lt;code&gt;VkCommandPool&lt;/code&gt; that &lt;code&gt;commandBuffer&lt;/code&gt; was allocated from &lt;strong&gt;must&lt;/strong&gt; support graphics operations</source>
          <target state="translated">&lt;code&gt;queryPool&lt;/code&gt; 을 작성하는 데 사용 된 &lt;code&gt;queryType&lt;/code&gt; 이 &lt;code&gt;VK_QUERY_TYPE_OCCLUSION&lt;/code&gt; 인 경우 해당 &lt;code&gt;commandBuffer&lt;/code&gt; 가 할당 된 &lt;code&gt;VkCommandPool&lt;/code&gt; &lt;strong&gt;&lt;/strong&gt; 그래픽 조작을 지원 &lt;strong&gt;해야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="2057c23d2f041eb5914063614bf8ee200dffb978" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;queryType&lt;/code&gt; used to create &lt;code&gt;queryPool&lt;/code&gt; was &lt;code&gt;VK_QUERY_TYPE_PIPELINE_STATISTICS&lt;/code&gt; and any of the &lt;code&gt;pipelineStatistics&lt;/code&gt; indicate compute operations, the &lt;code&gt;VkCommandPool&lt;/code&gt; that &lt;code&gt;commandBuffer&lt;/code&gt; was allocated from &lt;strong&gt;must&lt;/strong&gt; support compute operations</source>
          <target state="translated">&lt;code&gt;queryPool&lt;/code&gt; 을 만드는 데 사용 된 &lt;code&gt;queryType&lt;/code&gt; 이 &lt;code&gt;VK_QUERY_TYPE_PIPELINE_STATISTICS&lt;/code&gt; 이고 &lt;code&gt;pipelineStatistics&lt;/code&gt; 가 계산 작업을 나타내는 경우 &lt;code&gt;commandBuffer&lt;/code&gt; 가 할당 된 &lt;code&gt;VkCommandPool&lt;/code&gt; 이 계산 작업을 지원 &lt;strong&gt;해야합니다.&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="148d9622bbefcf3103c86a91718547300cd96a7d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;queryType&lt;/code&gt; used to create &lt;code&gt;queryPool&lt;/code&gt; was &lt;code&gt;VK_QUERY_TYPE_PIPELINE_STATISTICS&lt;/code&gt; and any of the &lt;code&gt;pipelineStatistics&lt;/code&gt; indicate graphics operations, the &lt;code&gt;VkCommandPool&lt;/code&gt; that &lt;code&gt;commandBuffer&lt;/code&gt; was allocated from &lt;strong&gt;must&lt;/strong&gt; support graphics operations</source>
          <target state="translated">는 IF &lt;code&gt;queryType&lt;/code&gt; 을 만드는 데 사용 &lt;code&gt;queryPool&lt;/code&gt; 이 있었다 &lt;code&gt;VK_QUERY_TYPE_PIPELINE_STATISTICS&lt;/code&gt; 가 와의 &lt;code&gt;pipelineStatistics&lt;/code&gt; 은 그래픽 작업을 나타냅니다의 &lt;code&gt;VkCommandPool&lt;/code&gt; 는 것을 &lt;code&gt;commandBuffer&lt;/code&gt; 는 에서 할당 된&lt;strong&gt;&lt;/strong&gt; 그래픽 작업을 지원 &lt;strong&gt;해야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="65b6a57b19b5e0db26179fa2021c7e0590ae6f2e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;queryType&lt;/code&gt; used to create &lt;code&gt;queryPool&lt;/code&gt; was &lt;code&gt;VK_QUERY_TYPE_TIMESTAMP&lt;/code&gt;, &lt;code&gt;flags&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not contain &lt;code&gt;VK_QUERY_RESULT_PARTIAL_BIT&lt;/code&gt;</source>
          <target state="translated">는 IF &lt;code&gt;queryType&lt;/code&gt; 을 만드는 데 사용 &lt;code&gt;queryPool&lt;/code&gt; 이 있었다 &lt;code&gt;VK_QUERY_TYPE_TIMESTAMP&lt;/code&gt; , &lt;code&gt;flags&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 포함하지 &lt;code&gt;VK_QUERY_RESULT_PARTIAL_BIT&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="40f59cfa6de4c114163064bf3b2996abe5184a45" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;rasterizerDiscardEnable&lt;/code&gt; member of &lt;code&gt;pRasterizationState&lt;/code&gt; is &lt;code&gt;VK_FALSE&lt;/code&gt;, &lt;code&gt;pMultisampleState&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to a valid &lt;code&gt;VkPipelineMultisampleStateCreateInfo&lt;/code&gt; structure</source>
          <target state="translated">&lt;code&gt;pRasterizationState&lt;/code&gt; 의 &lt;code&gt;rasterizerDiscardEnable&lt;/code&gt; 멤버 가 &lt;code&gt;VK_FALSE&lt;/code&gt; 인 경우 &lt;code&gt;pMultisampleState&lt;/code&gt; &lt;strong&gt;는&lt;/strong&gt; 유효한 &lt;code&gt;VkPipelineMultisampleStateCreateInfo&lt;/code&gt; 구조에 대한 포인터 &lt;strong&gt;여야&lt;/strong&gt; 합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="46033b1a6716ca3e1be34e9aee0f8fe0a0af36fd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;rasterizerDiscardEnable&lt;/code&gt; member of &lt;code&gt;pRasterizationState&lt;/code&gt; is &lt;code&gt;VK_FALSE&lt;/code&gt;, &lt;code&gt;pViewportState&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to a valid &lt;code&gt;VkPipelineViewportStateCreateInfo&lt;/code&gt; structure</source>
          <target state="translated">&lt;code&gt;pRasterizationState&lt;/code&gt; 의 &lt;code&gt;rasterizerDiscardEnable&lt;/code&gt; 멤버 가 &lt;code&gt;VK_FALSE&lt;/code&gt; 인 경우 &lt;code&gt;pViewportState&lt;/code&gt; &lt;strong&gt;는&lt;/strong&gt; 유효한 &lt;code&gt;VkPipelineViewportStateCreateInfo&lt;/code&gt; 구조에 대한 포인터 &lt;strong&gt;여야&lt;/strong&gt; 합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f244ad19fad3cdf035d3d03bc47c32c280ed3757" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;rasterizerDiscardEnable&lt;/code&gt; member of &lt;code&gt;pRasterizationState&lt;/code&gt; is &lt;code&gt;VK_FALSE&lt;/code&gt;, and &lt;code&gt;subpass&lt;/code&gt; uses a depth/stencil attachment, &lt;code&gt;pDepthStencilState&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to a valid &lt;code&gt;VkPipelineDepthStencilStateCreateInfo&lt;/code&gt; structure</source>
          <target state="translated">&lt;code&gt;pRasterizationState&lt;/code&gt; 의 &lt;code&gt;rasterizerDiscardEnable&lt;/code&gt; 멤버 가 &lt;code&gt;VK_FALSE&lt;/code&gt; 이고 &lt;code&gt;subpass&lt;/code&gt; 가 깊이 / 스텐실 첨부 파일을 사용하는 경우 &lt;code&gt;pDepthStencilState&lt;/code&gt; &lt;strong&gt;는&lt;/strong&gt; 유효한 &lt;code&gt;VkPipelineDepthStencilStateCreateInfo&lt;/code&gt; 의 포인터 &lt;strong&gt;여야&lt;/strong&gt; 합니다.&lt;strong&gt;&lt;/strong&gt; 구조에</target>
        </trans-unit>
        <trans-unit id="d8dd793918a179bd3bfe14999cf12ffc472dbc83" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;rasterizerDiscardEnable&lt;/code&gt; member of &lt;code&gt;pRasterizationState&lt;/code&gt; is &lt;code&gt;VK_FALSE&lt;/code&gt;, and &lt;code&gt;subpass&lt;/code&gt; uses color attachments, &lt;code&gt;pColorBlendState&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to a valid &lt;code&gt;VkPipelineColorBlendStateCreateInfo&lt;/code&gt; structure</source>
          <target state="translated">&lt;code&gt;pRasterizationState&lt;/code&gt; 의 &lt;code&gt;rasterizerDiscardEnable&lt;/code&gt; 멤버 가 &lt;code&gt;VK_FALSE&lt;/code&gt; 이고 &lt;code&gt;subpass&lt;/code&gt; 가 컬러 첨부를 사용하는 경우 &lt;code&gt;pColorBlendState&lt;/code&gt; &lt;strong&gt;는&lt;/strong&gt; 유효한 &lt;code&gt;VkPipelineColorBlendStateCreateInfo&lt;/code&gt; 에 대한 포인터 &lt;strong&gt;여야&lt;/strong&gt; 합니다.&lt;strong&gt;&lt;/strong&gt; 구조에</target>
        </trans-unit>
        <trans-unit id="0d7b5a8df2463c554aac8c986aaaa49d4815c2e2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;topology&lt;/code&gt; member of &lt;code&gt;pInputAssembly&lt;/code&gt; is &lt;code&gt;VK_PRIMITIVE_TOPOLOGY_PATCH_LIST&lt;/code&gt;, &lt;code&gt;pStages&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; include tessellation shader stages</source>
          <target state="translated">&lt;code&gt;pInputAssembly&lt;/code&gt; 의 &lt;code&gt;topology&lt;/code&gt; 멤버 가 &lt;code&gt;VK_PRIMITIVE_TOPOLOGY_PATCH_LIST&lt;/code&gt; 인 경우 &lt;code&gt;pStages&lt;/code&gt; 는 테셀레이션 셰이더 단계를 포함 &lt;strong&gt;해야합니다.&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c1fffc1dd2b73a9a1bd6971ef57790e95e102ad9" translate="yes" xml:space="preserve">
          <source>If the VK_KHR_sampler_mirror_clamp_to_edge extension is not enabled, &lt;code&gt;addressModeU&lt;/code&gt;, &lt;code&gt;addressModeV&lt;/code&gt; and &lt;code&gt;addressModeW&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not be &lt;code&gt;VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE&lt;/code&gt;</source>
          <target state="translated">VK_KHR_sampler_mirror_clamp_to_edge 확장이 활성화되지 않은 경우, &lt;code&gt;addressModeU&lt;/code&gt; , &lt;code&gt;addressModeV&lt;/code&gt; 및 &lt;code&gt;addressModeW&lt;/code&gt; 는&lt;strong&gt;있어야&lt;/strong&gt; 하지 &lt;code&gt;VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7bdb5b4920f4b2e5b0ac1c1d4a2752fec288fd51" translate="yes" xml:space="preserve">
          <source>If the allocation is scoped to the lifetime of an instance and the instance has an allocator, its allocator will be used with an allocation scope of &lt;code&gt;VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE&lt;/code&gt;.</source>
          <target state="translated">할당 범위가 인스턴스의 수명 범위이고 인스턴스에 할당자가있는 경우 할당자는 &lt;code&gt;VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE&lt;/code&gt; 할당 범위와 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c2a401949e633bfe2b9e2c1bab2fbf8f1b2f3858" translate="yes" xml:space="preserve">
          <source>If the attachment uses a color format, then &lt;code&gt;loadOp&lt;/code&gt; and &lt;code&gt;storeOp&lt;/code&gt; are used, and &lt;code&gt;stencilLoadOp&lt;/code&gt; and &lt;code&gt;stencilStoreOp&lt;/code&gt; are ignored. If the format has depth and/or stencil components, &lt;code&gt;loadOp&lt;/code&gt; and &lt;code&gt;storeOp&lt;/code&gt; apply only to the depth data, while &lt;code&gt;stencilLoadOp&lt;/code&gt; and &lt;code&gt;stencilStoreOp&lt;/code&gt; define how the stencil data is handled. &lt;code&gt;loadOp&lt;/code&gt; and &lt;code&gt;stencilLoadOp&lt;/code&gt; define the &lt;em&gt;load operations&lt;/em&gt; that execute as part of the first subpass that uses the attachment. &lt;code&gt;storeOp&lt;/code&gt; and &lt;code&gt;stencilStoreOp&lt;/code&gt; define the &lt;em&gt;store operations&lt;/em&gt; that execute as part of the last subpass that uses the attachment.</source>
          <target state="translated">첨부 파일이 색상 형식을 사용하는 경우 &lt;code&gt;loadOp&lt;/code&gt; 및 &lt;code&gt;storeOp&lt;/code&gt; 가 사용되고 &lt;code&gt;stencilLoadOp&lt;/code&gt; 및 &lt;code&gt;stencilStoreOp&lt;/code&gt; 는 무시됩니다. 형식에 깊이 및 / 또는 스텐실 구성 요소가있는 경우 &lt;code&gt;loadOp&lt;/code&gt; 및 &lt;code&gt;storeOp&lt;/code&gt; 는 깊이 데이터에만 적용되는 반면 &lt;code&gt;stencilLoadOp&lt;/code&gt; 및 &lt;code&gt;stencilStoreOp&lt;/code&gt; 는 스텐실 데이터 처리 방법을 정의합니다. &lt;code&gt;loadOp&lt;/code&gt; 및 &lt;code&gt;stencilLoadOp&lt;/code&gt; 는 첨부 파일을 사용하는 첫 번째 서브 패스의 일부로 실행되는 &lt;em&gt;로드 조작&lt;/em&gt; 을 정의합니다 . &lt;code&gt;storeOp&lt;/code&gt; 및 &lt;code&gt;stencilStoreOp&lt;/code&gt; 는 &lt;em&gt;상점 조작을&lt;/em&gt; 정의합니다.&lt;em&gt;&lt;/em&gt; 첨부 파일을 사용하는 마지막 서브 패스의 일부로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="9d6d883eddd92b58ec8f36f24493c1ab7858954f" translate="yes" xml:space="preserve">
          <source>If the bound pipeline state object was not created with the &lt;code&gt;VK_DYNAMIC_STATE_VIEWPORT&lt;/code&gt; dynamic state enabled, viewport transformation parameters are specified using the &lt;code&gt;pViewports&lt;/code&gt; member of &lt;code&gt;VkPipelineViewportStateCreateInfo&lt;/code&gt; in the pipeline state object. If the pipeline state object was created with the &lt;code&gt;VK_DYNAMIC_STATE_VIEWPORT&lt;/code&gt; dynamic state enabled, the viewport transformation parameters are dynamically set and changed with the command:</source>
          <target state="translated">결합 된 파이프 라인 상태 객체가 생성되지 않은 경우 &lt;code&gt;VK_DYNAMIC_STATE_VIEWPORT&lt;/code&gt; 의 활성화 동적 상태, 뷰포트 변환 파라미터가 사용 지정된 &lt;code&gt;pViewports&lt;/code&gt; 의 멤버 &lt;code&gt;VkPipelineViewportStateCreateInfo&lt;/code&gt; 를 파이프 라인 상태 객체. &lt;code&gt;VK_DYNAMIC_STATE_VIEWPORT&lt;/code&gt; 동적 상태를 활성화 하여 파이프 라인 상태 객체를 만든 경우 뷰포트 변환 매개 변수는 다음 명령으로 동적으로 설정 및 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="591c0ea04c37d0a378da3e0f4b1b8881bfb6bd53" translate="yes" xml:space="preserve">
          <source>If the calling command&amp;rsquo;s &lt;code&gt;VkImage&lt;/code&gt; parameter is a compressed format image, &lt;code&gt;bufferImageHeight&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a multiple of the compressed texel block height</source>
          <target state="translated">호출 명령의 &lt;code&gt;VkImage&lt;/code&gt; 매개 변수가 압축 형식 이미지 인 경우 &lt;code&gt;bufferImageHeight&lt;/code&gt; &lt;strong&gt;는&lt;/strong&gt; 압축 된 텍셀 블록 높이의 배수 &lt;strong&gt;여야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="60d7aa1073a5fe011b61e825245ccd4b45b3ea42" translate="yes" xml:space="preserve">
          <source>If the calling command&amp;rsquo;s &lt;code&gt;VkImage&lt;/code&gt; parameter is a compressed format image, &lt;code&gt;bufferOffset&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a multiple of the compressed texel block size in bytes</source>
          <target state="translated">호출 명령의 &lt;code&gt;VkImage&lt;/code&gt; 매개 변수가 압축 형식 이미지 인 경우 &lt;code&gt;bufferOffset&lt;/code&gt; &lt;strong&gt;은&lt;/strong&gt; 압축 된 텍셀 블록 크기 (바이트)의 배수</target>
        </trans-unit>
        <trans-unit id="1af2c2aee14bad79e1c61088e87b2afb3770a91c" translate="yes" xml:space="preserve">
          <source>If the calling command&amp;rsquo;s &lt;code&gt;VkImage&lt;/code&gt; parameter is a compressed format image, &lt;code&gt;bufferRowLength&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a multiple of the compressed texel block width</source>
          <target state="translated">호출 명령의 &lt;code&gt;VkImage&lt;/code&gt; 매개 변수가 압축 형식 이미지 인 경우, &lt;code&gt;bufferRowLength&lt;/code&gt; &lt;strong&gt;는&lt;/strong&gt; 압축 된 텍셀 블록 너비의 배수 &lt;strong&gt;여야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="23701ab6c6205224ba990c32877dd814689c4dc1" translate="yes" xml:space="preserve">
          <source>If the calling command&amp;rsquo;s &lt;code&gt;VkImage&lt;/code&gt; parameter is a compressed format image, &lt;code&gt;imageExtent.depth&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a multiple of the compressed texel block depth or (&lt;code&gt;imageExtent.depth&lt;/code&gt; + &lt;code&gt;imageOffset.z&lt;/code&gt;) &lt;strong&gt;must&lt;/strong&gt; equal the image subresource depth</source>
          <target state="translated">호출 명령의 &lt;code&gt;VkImage&lt;/code&gt; 매개 변수가 압축 형식 이미지 인 경우, &lt;code&gt;imageExtent.depth&lt;/code&gt; &lt;strong&gt;는&lt;/strong&gt; 압축 된 텍셀 블록 깊이의 배수이거나 ( &lt;code&gt;imageExtent.depth&lt;/code&gt; + &lt;code&gt;imageOffset.z&lt;/code&gt; ) &lt;strong&gt;는&lt;/strong&gt; 이미지 하위 자원 깊이와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="1e626badebf41bf554c7b43f0faeba14f8d2b44f" translate="yes" xml:space="preserve">
          <source>If the calling command&amp;rsquo;s &lt;code&gt;VkImage&lt;/code&gt; parameter is a compressed format image, &lt;code&gt;imageExtent.height&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a multiple of the compressed texel block height or (&lt;code&gt;imageExtent.height&lt;/code&gt; + &lt;code&gt;imageOffset.y&lt;/code&gt;) &lt;strong&gt;must&lt;/strong&gt; equal the image subresource height</source>
          <target state="translated">호출 명령의 &lt;code&gt;VkImage&lt;/code&gt; 매개 변수가 압축 형식 이미지 인 경우, &lt;code&gt;imageExtent.height&lt;/code&gt; &lt;strong&gt;는&lt;/strong&gt; 압축 된 텍셀 블록 높이의 배수이거나 ( &lt;code&gt;imageExtent.height&lt;/code&gt; + &lt;code&gt;imageOffset.y&lt;/code&gt; ) &lt;strong&gt;는&lt;/strong&gt; 이미지 서브 리소스 높이와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="703e95163a04ae17f7ba38ce1ba6a00d6de9dbc4" translate="yes" xml:space="preserve">
          <source>If the calling command&amp;rsquo;s &lt;code&gt;VkImage&lt;/code&gt; parameter is a compressed format image, &lt;code&gt;imageExtent.width&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a multiple of the compressed texel block width or (&lt;code&gt;imageExtent.width&lt;/code&gt; + &lt;code&gt;imageOffset.x&lt;/code&gt;) &lt;strong&gt;must&lt;/strong&gt; equal the image subresource width</source>
          <target state="translated">호출 명령의 &lt;code&gt;VkImage&lt;/code&gt; 매개 변수가 압축 된 형식 이미지 인 경우 &lt;code&gt;imageExtent.width&lt;/code&gt; &lt;strong&gt;는&lt;/strong&gt; 압축 된 텍셀 블록 너비의 배수이거나 ( &lt;code&gt;imageExtent.width&lt;/code&gt; + &lt;code&gt;imageOffset.x&lt;/code&gt; ) &lt;strong&gt;는&lt;/strong&gt; 이미지 서브 리소스 너비와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="4a03cf2147807d4604496760d90135e2b39c629c" translate="yes" xml:space="preserve">
          <source>If the calling command&amp;rsquo;s &lt;code&gt;VkImage&lt;/code&gt; parameter is a compressed format image, all members of &lt;code&gt;imageOffset&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a multiple of the corresponding dimensions of the compressed texel block</source>
          <target state="translated">호출 명령의 &lt;code&gt;VkImage&lt;/code&gt; 매개 변수가 압축 형식 이미지 인 경우 &lt;code&gt;imageOffset&lt;/code&gt; 의 모든 멤버 &lt;strong&gt;는&lt;/strong&gt; 는 압축 된 텍셀 블록의 해당 차원의 배수</target>
        </trans-unit>
        <trans-unit id="686c38f80d660b5dcfdb4a0e83ba3d3533a27a14" translate="yes" xml:space="preserve">
          <source>If the calling command&amp;rsquo;s &lt;code&gt;VkImage&lt;/code&gt; parameter is of &lt;a href=&quot;#VkImageType&quot;&gt;VkImageType&lt;/a&gt;&lt;code&gt;VK_IMAGE_TYPE_3D&lt;/code&gt;, the &lt;code&gt;baseArrayLayer&lt;/code&gt; and &lt;code&gt;layerCount&lt;/code&gt; members of &lt;code&gt;imageSubresource&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;, respectively</source>
          <target state="translated">호출 명령의 경우 &lt;code&gt;VkImage&lt;/code&gt; 의 매개 변수입니다 &lt;a href=&quot;#VkImageType&quot;&gt;VkImageType &lt;/a&gt; &lt;code&gt;VK_IMAGE_TYPE_3D&lt;/code&gt; 의 &lt;code&gt;baseArrayLayer&lt;/code&gt; 및 &lt;code&gt;layerCount&lt;/code&gt; 의 구성원 &lt;code&gt;imageSubresource&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;1&lt;/code&gt; 은 각각</target>
        </trans-unit>
        <trans-unit id="f55f5338587eabd6cd16d07e867c7ca1537fbe5c" translate="yes" xml:space="preserve">
          <source>If the calling command&amp;rsquo;s &lt;code&gt;dstImage&lt;/code&gt; is a compressed format image, &lt;code&gt;extent.depth&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a multiple of the compressed texel block depth or (&lt;code&gt;extent.depth&lt;/code&gt; + &lt;code&gt;dstOffset.z&lt;/code&gt;) &lt;strong&gt;must&lt;/strong&gt; equal the destination image subresource depth</source>
          <target state="translated">호출 명령 인 경우 &lt;code&gt;dstImage&lt;/code&gt; 가 압축 된 형식 이미지이고, &lt;code&gt;extent.depth&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 압축 텍셀 블록 또는 깊이 (의 배수 &lt;code&gt;extent.depth&lt;/code&gt; + &lt;code&gt;dstOffset.z&lt;/code&gt; ) &lt;strong&gt;필수&lt;/strong&gt; 대상 화상 하위 리소스 깊이와 동일</target>
        </trans-unit>
        <trans-unit id="b28c87379364451f3b36fd916fb19672798e576b" translate="yes" xml:space="preserve">
          <source>If the calling command&amp;rsquo;s &lt;code&gt;dstImage&lt;/code&gt; is a compressed format image, &lt;code&gt;extent.height&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a multiple of the compressed texel block height or (&lt;code&gt;extent.height&lt;/code&gt; + &lt;code&gt;dstOffset.y&lt;/code&gt;) &lt;strong&gt;must&lt;/strong&gt; equal the destination image subresource height</source>
          <target state="translated">호출 명령 인 경우 &lt;code&gt;dstImage&lt;/code&gt; 가 압축 된 형식 이미지이고, &lt;code&gt;extent.height&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 압축 텍셀 블록 높이의 배수 또는 ( &lt;code&gt;extent.height&lt;/code&gt; + &lt;code&gt;dstOffset.y&lt;/code&gt; ) &lt;strong&gt;해야&lt;/strong&gt; 대상 화상 하위 리소스 높이를 같게</target>
        </trans-unit>
        <trans-unit id="558f4178cb281a334328854e8fe68b57bca8675b" translate="yes" xml:space="preserve">
          <source>If the calling command&amp;rsquo;s &lt;code&gt;dstImage&lt;/code&gt; is a compressed format image, &lt;code&gt;extent.width&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a multiple of the compressed texel block width or (&lt;code&gt;extent.width&lt;/code&gt; + &lt;code&gt;dstOffset.x&lt;/code&gt;) &lt;strong&gt;must&lt;/strong&gt; equal the destination image subresource width</source>
          <target state="translated">호출하는 명령의 &lt;code&gt;dstImage&lt;/code&gt; 가 압축 형식 이미지 인 경우 &lt;code&gt;extent.width&lt;/code&gt; &lt;strong&gt;는&lt;/strong&gt; 압축 된 텍셀 블록 너비의 배수이거나 ( &lt;code&gt;extent.width&lt;/code&gt; + &lt;code&gt;dstOffset.x&lt;/code&gt; ) &lt;strong&gt;여야합니다.&lt;/strong&gt; 대상 화상 하위 리소스 폭을 같게</target>
        </trans-unit>
        <trans-unit id="37257d546c948d2d9c18e6a044099d7f80698167" translate="yes" xml:space="preserve">
          <source>If the calling command&amp;rsquo;s &lt;code&gt;dstImage&lt;/code&gt; is a compressed format image, all members of &lt;code&gt;dstOffset&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a multiple of the corresponding dimensions of the compressed texel block</source>
          <target state="translated">호출 명령의 &lt;code&gt;dstImage&lt;/code&gt; 가 압축 형식 이미지 인 경우 &lt;code&gt;dstOffset&lt;/code&gt; 의 모든 멤버 는 압축 된 텍셀 블록의 해당 차원의 배수 &lt;strong&gt;여야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c9455a7d009d517ac3180616cfaad8477dd105ad" translate="yes" xml:space="preserve">
          <source>If the calling command&amp;rsquo;s &lt;code&gt;dstImage&lt;/code&gt; is of type &lt;code&gt;VK_IMAGE_TYPE_1D&lt;/code&gt; or &lt;code&gt;VK_IMAGE_TYPE_2D&lt;/code&gt;, then &lt;code&gt;dstOffset.z&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;extent.depth&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">호출 명령의 경우 &lt;code&gt;dstImage&lt;/code&gt; 는 타입이다 &lt;code&gt;VK_IMAGE_TYPE_1D&lt;/code&gt; 또는 &lt;code&gt;VK_IMAGE_TYPE_2D&lt;/code&gt; , 다음 &lt;code&gt;dstOffset.z&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;extent.depth&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44c28b8ea4e4d17994c48d3100770ed83bc9bd50" translate="yes" xml:space="preserve">
          <source>If the calling command&amp;rsquo;s &lt;code&gt;dstImage&lt;/code&gt; is of type &lt;code&gt;VK_IMAGE_TYPE_1D&lt;/code&gt; or &lt;code&gt;VK_IMAGE_TYPE_2D&lt;/code&gt;, then &lt;code&gt;dstOffset&lt;/code&gt;[0].z &lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;dstOffset&lt;/code&gt;[1].z &lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">호출 명령의 경우 &lt;code&gt;dstImage&lt;/code&gt; 는 타입이다 &lt;code&gt;VK_IMAGE_TYPE_1D&lt;/code&gt; 또는 &lt;code&gt;VK_IMAGE_TYPE_2D&lt;/code&gt; , 다음 &lt;code&gt;dstOffset&lt;/code&gt; [0] .Z가 &lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;dstOffset&lt;/code&gt; [1] .Z &lt;strong&gt;해야&lt;/strong&gt; 될 &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e40041487982469956890c22c93b0a6084dee44e" translate="yes" xml:space="preserve">
          <source>If the calling command&amp;rsquo;s &lt;code&gt;dstImage&lt;/code&gt; is of type &lt;code&gt;VK_IMAGE_TYPE_1D&lt;/code&gt;, then &lt;code&gt;dstOffset.y&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;extent.height&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">호출 명령의 경우 &lt;code&gt;dstImage&lt;/code&gt; 이 유형 인 &lt;code&gt;VK_IMAGE_TYPE_1D&lt;/code&gt; , 다음 &lt;code&gt;dstOffset.y&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;extent.height&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fa06638e6154a12f148b5e22df2be92e83ae0ee" translate="yes" xml:space="preserve">
          <source>If the calling command&amp;rsquo;s &lt;code&gt;dstImage&lt;/code&gt; is of type &lt;code&gt;VK_IMAGE_TYPE_1D&lt;/code&gt;, then &lt;code&gt;dstOffset&lt;/code&gt;[0].y &lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;dstOffset&lt;/code&gt;[1].y &lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">호출 명령의 경우 &lt;code&gt;dstImage&lt;/code&gt; 이 유형 인 &lt;code&gt;VK_IMAGE_TYPE_1D&lt;/code&gt; , 다음 &lt;code&gt;dstOffset&lt;/code&gt; [0] .Y는 &lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;dstOffset&lt;/code&gt; 는 [1] .Y는 &lt;strong&gt;있어야&lt;/strong&gt; 될 &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ecae3faffc478a83471ae040ebc177c4aac060ab" translate="yes" xml:space="preserve">
          <source>If the calling command&amp;rsquo;s &lt;code&gt;srcImage&lt;/code&gt; (&lt;a href=&quot;#vkCmdCopyImageToBuffer&quot;&gt;vkCmdCopyImageToBuffer&lt;/a&gt;) or &lt;code&gt;dstImage&lt;/code&gt; (&lt;a href=&quot;#vkCmdCopyBufferToImage&quot;&gt;vkCmdCopyBufferToImage&lt;/a&gt;) is of type &lt;code&gt;VK_IMAGE_TYPE_1D&lt;/code&gt; or &lt;code&gt;VK_IMAGE_TYPE_2D&lt;/code&gt;, then &lt;code&gt;imageOffset.z&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;imageExtent.depth&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">호출 명령의 경우 &lt;code&gt;srcImage&lt;/code&gt; ( &lt;a href=&quot;#vkCmdCopyImageToBuffer&quot;&gt;vkCmdCopyImageToBuffer&lt;/a&gt; ) 또는 &lt;code&gt;dstImage&lt;/code&gt; ( &lt;a href=&quot;#vkCmdCopyBufferToImage&quot;&gt;vkCmdCopyBufferToImage가&lt;/a&gt; ) 유형 인 &lt;code&gt;VK_IMAGE_TYPE_1D&lt;/code&gt; 또는 &lt;code&gt;VK_IMAGE_TYPE_2D&lt;/code&gt; , 다음 &lt;code&gt;imageOffset.z&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;imageExtent.depth&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="160bca763ff6693059f878b1712333bd87ccb2dc" translate="yes" xml:space="preserve">
          <source>If the calling command&amp;rsquo;s &lt;code&gt;srcImage&lt;/code&gt; (&lt;a href=&quot;#vkCmdCopyImageToBuffer&quot;&gt;vkCmdCopyImageToBuffer&lt;/a&gt;) or &lt;code&gt;dstImage&lt;/code&gt; (&lt;a href=&quot;#vkCmdCopyBufferToImage&quot;&gt;vkCmdCopyBufferToImage&lt;/a&gt;) is of type &lt;code&gt;VK_IMAGE_TYPE_1D&lt;/code&gt;, then &lt;code&gt;imageOffset.y&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;imageExtent.height&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">호출 명령의 경우 &lt;code&gt;srcImage&lt;/code&gt; ( &lt;a href=&quot;#vkCmdCopyImageToBuffer&quot;&gt;vkCmdCopyImageToBuffer&lt;/a&gt; ) 또는 &lt;code&gt;dstImage&lt;/code&gt; ( &lt;a href=&quot;#vkCmdCopyBufferToImage&quot;&gt;vkCmdCopyBufferToImage가&lt;/a&gt; ) 유형 인 &lt;code&gt;VK_IMAGE_TYPE_1D&lt;/code&gt; , 다음 &lt;code&gt;imageOffset.y&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;imageExtent.height&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 될 &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5567e2b0f4a76520483994e2358ab39b4b54c554" translate="yes" xml:space="preserve">
          <source>If the calling command&amp;rsquo;s &lt;code&gt;srcImage&lt;/code&gt; is a compressed format image, &lt;code&gt;extent.depth&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a multiple of the compressed texel block depth or (&lt;code&gt;extent.depth&lt;/code&gt; + &lt;code&gt;srcOffset.z&lt;/code&gt;) &lt;strong&gt;must&lt;/strong&gt; equal the source image subresource depth</source>
          <target state="translated">호출하는 명령의 &lt;code&gt;srcImage&lt;/code&gt; 가 압축 형식 이미지 인 경우 &lt;code&gt;extent.depth&lt;/code&gt; &lt;strong&gt;는&lt;/strong&gt; 압축 된 텍셀 블록 깊이의 배수이거나 ( &lt;code&gt;extent.depth&lt;/code&gt; + &lt;code&gt;srcOffset.z&lt;/code&gt; ) &lt;strong&gt;는&lt;/strong&gt; 소스 이미지 서브 리소스 깊이와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="08826b9a0454d1444b02409ba43dc97bf6518f35" translate="yes" xml:space="preserve">
          <source>If the calling command&amp;rsquo;s &lt;code&gt;srcImage&lt;/code&gt; is a compressed format image, &lt;code&gt;extent.height&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a multiple of the compressed texel block height or (&lt;code&gt;extent.height&lt;/code&gt; + &lt;code&gt;srcOffset.y&lt;/code&gt;) &lt;strong&gt;must&lt;/strong&gt; equal the source image subresource height</source>
          <target state="translated">호출하는 명령의 &lt;code&gt;srcImage&lt;/code&gt; 가 압축 형식 이미지 인 경우, &lt;code&gt;extent.height&lt;/code&gt; &lt;strong&gt;는&lt;/strong&gt; 압축 된 텍셀 블록 높이의 배수이거나 ( &lt;code&gt;extent.height&lt;/code&gt; + &lt;code&gt;srcOffset.y&lt;/code&gt; ) &lt;strong&gt;는&lt;/strong&gt; 소스 이미지 서브 리소스 높이와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="8f1e1cbfa4f41d360486748ed78ba7ac901ed3a0" translate="yes" xml:space="preserve">
          <source>If the calling command&amp;rsquo;s &lt;code&gt;srcImage&lt;/code&gt; is a compressed format image, &lt;code&gt;extent.width&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a multiple of the compressed texel block width or (&lt;code&gt;extent.width&lt;/code&gt; + &lt;code&gt;srcOffset.x&lt;/code&gt;) &lt;strong&gt;must&lt;/strong&gt; equal the source image subresource width</source>
          <target state="translated">호출하는 명령의 &lt;code&gt;srcImage&lt;/code&gt; 가 압축 형식 이미지 인 경우 &lt;code&gt;extent.width&lt;/code&gt; &lt;strong&gt;는&lt;/strong&gt; 압축 된 텍셀 블록 너비의 배수이거나 ( &lt;code&gt;extent.width&lt;/code&gt; + &lt;code&gt;srcOffset.x&lt;/code&gt; ) &lt;strong&gt;는&lt;/strong&gt; 소스 이미지 하위 자원 너비와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="369bd7459e6f62e7684e73ccb2fd8bd92139e025" translate="yes" xml:space="preserve">
          <source>If the calling command&amp;rsquo;s &lt;code&gt;srcImage&lt;/code&gt; is a compressed format image, all members of &lt;code&gt;srcOffset&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a multiple of the corresponding dimensions of the compressed texel block</source>
          <target state="translated">호출하는 명령의 &lt;code&gt;srcImage&lt;/code&gt; 가 압축 형식 이미지 인 경우 &lt;code&gt;srcOffset&lt;/code&gt; 의 모든 멤버 는 압축 된 텍셀 블록의 해당 차원의 배수 &lt;strong&gt;여야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="f5c9232a301c3208501435016df280b93d724335" translate="yes" xml:space="preserve">
          <source>If the calling command&amp;rsquo;s &lt;code&gt;srcImage&lt;/code&gt; is of type &lt;code&gt;VK_IMAGE_TYPE_1D&lt;/code&gt; or &lt;code&gt;VK_IMAGE_TYPE_2D&lt;/code&gt;, then &lt;code&gt;srcOffset.z&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;extent.depth&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">호출 명령의 경우 &lt;code&gt;srcImage&lt;/code&gt; 는 타입이다 &lt;code&gt;VK_IMAGE_TYPE_1D&lt;/code&gt; 또는 &lt;code&gt;VK_IMAGE_TYPE_2D&lt;/code&gt; , 다음 &lt;code&gt;srcOffset.z&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;extent.depth&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 될 &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="432e50e60947120bfd350d7c26390b4e0b405c30" translate="yes" xml:space="preserve">
          <source>If the calling command&amp;rsquo;s &lt;code&gt;srcImage&lt;/code&gt; is of type &lt;code&gt;VK_IMAGE_TYPE_1D&lt;/code&gt; or &lt;code&gt;VK_IMAGE_TYPE_2D&lt;/code&gt;, then &lt;code&gt;srcOffset&lt;/code&gt;[0].z &lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;srcOffset&lt;/code&gt;[1].z &lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">호출 명령의 경우 &lt;code&gt;srcImage&lt;/code&gt; 는 타입이다 &lt;code&gt;VK_IMAGE_TYPE_1D&lt;/code&gt; 또는 &lt;code&gt;VK_IMAGE_TYPE_2D&lt;/code&gt; , 다음 &lt;code&gt;srcOffset&lt;/code&gt; [0] .Z가 &lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;srcOffset&lt;/code&gt; [1] .Z &lt;strong&gt;해야&lt;/strong&gt; 될 &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee19b183d3171b3939afe3de9df8ca8befd003a5" translate="yes" xml:space="preserve">
          <source>If the calling command&amp;rsquo;s &lt;code&gt;srcImage&lt;/code&gt; is of type &lt;code&gt;VK_IMAGE_TYPE_1D&lt;/code&gt;, then &lt;code&gt;srcOffset.y&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;extent.height&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">호출 명령의 경우 &lt;code&gt;srcImage&lt;/code&gt; 이 유형 인 &lt;code&gt;VK_IMAGE_TYPE_1D&lt;/code&gt; , 다음 &lt;code&gt;srcOffset.y&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;extent.height&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 될 &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="405058af1517bb50ac0495c0c8bd96aab7a71553" translate="yes" xml:space="preserve">
          <source>If the calling command&amp;rsquo;s &lt;code&gt;srcImage&lt;/code&gt; is of type &lt;code&gt;VK_IMAGE_TYPE_1D&lt;/code&gt;, then &lt;code&gt;srcOffset&lt;/code&gt;[0].y &lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;srcOffset&lt;/code&gt;[1].y &lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">호출 명령의 경우 &lt;code&gt;srcImage&lt;/code&gt; 이 유형 인 &lt;code&gt;VK_IMAGE_TYPE_1D&lt;/code&gt; , 다음 &lt;code&gt;srcOffset&lt;/code&gt; [0] .Y는 &lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;srcOffset&lt;/code&gt; 는 [1] .Y는 &lt;strong&gt;있어야&lt;/strong&gt; 될 &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf4a55559aa630c9aa682af6666bb5a7a055ab92" translate="yes" xml:space="preserve">
          <source>If the color attachment is fixed-point, the components of the source and destination values and blend factors are each clamped to [0,1] or [-1,1] respectively for an unsigned normalized or signed normalized color attachment prior to evaluating the blend operations. If the color attachment is floating-point, no clamping occurs.</source>
          <target state="translated">컬러 어태치먼트가 고정 소수점 인 경우 소스 및 대상 값과 블렌드 팩터의 구성 요소는 각각 서명하지 않은 정규화 또는 서명 된 정규화 된 컬러 어 태치에 대해 각각 [0,1] 또는 [-1,1]로 고정됩니다. 블렌드 작업. 컬러 부착물이 부동 소수점이면 클램핑이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2f123ea92e7fe5a38a517ad65da6cc63a69b952d" translate="yes" xml:space="preserve">
          <source>If the combination of parameters to &lt;code&gt;vkGetPhysicalDeviceImageFormatProperties&lt;/code&gt; is not supported by the implementation for use in &lt;a href=&quot;#vkCreateImage&quot;&gt;vkCreateImage&lt;/a&gt;, then all members of &lt;code&gt;VkImageFormatProperties&lt;/code&gt; will be filled with zero.</source>
          <target state="translated">에 매개 변수의 조합하면 &lt;code&gt;vkGetPhysicalDeviceImageFormatProperties&lt;/code&gt; 가 에 사용되는 구현에 의해 지원되지 않습니다 &lt;a href=&quot;#vkCreateImage&quot;&gt;vkCreateImage&lt;/a&gt; , 다음의 모든 구성원 &lt;code&gt;VkImageFormatProperties&lt;/code&gt; 는 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="17d3fe4116924c0d1ab46071ae6259b22aa06281" translate="yes" xml:space="preserve">
          <source>If the command buffer is a secondary command buffer, then the &lt;code&gt;VkCommandBufferInheritanceInfo&lt;/code&gt; structure defines any state that will be inherited from the primary command buffer:</source>
          <target state="translated">명령 버퍼가 보조 명령 버퍼 인 경우 &lt;code&gt;VkCommandBufferInheritanceInfo&lt;/code&gt; 구조는 기본 명령 버퍼에서 상속되는 모든 상태를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="7fbdc6a1bf61a0b220886f009d0fcdac7f7ff364" translate="yes" xml:space="preserve">
          <source>If the condition is satisfied when &lt;code&gt;vkWaitForFences&lt;/code&gt; is called, then &lt;code&gt;vkWaitForFences&lt;/code&gt; returns immediately. If the condition is not satisfied at the time &lt;code&gt;vkWaitForFences&lt;/code&gt; is called, then &lt;code&gt;vkWaitForFences&lt;/code&gt; will block and wait up to &lt;code&gt;timeout&lt;/code&gt; nanoseconds for the condition to become satisfied.</source>
          <target state="translated">If the condition is satisfied when &lt;code&gt;vkWaitForFences&lt;/code&gt; is called, then &lt;code&gt;vkWaitForFences&lt;/code&gt; returns immediately. If the condition is not satisfied at the time &lt;code&gt;vkWaitForFences&lt;/code&gt; is called, then &lt;code&gt;vkWaitForFences&lt;/code&gt; will block and wait up to &lt;code&gt;timeout&lt;/code&gt; nanoseconds for the condition to become satisfied.</target>
        </trans-unit>
        <trans-unit id="0907f380eda9db7f403dfa3058b160282a70609c" translate="yes" xml:space="preserve">
          <source>If the depth bias clamping feature is not enabled, no element of the &lt;code&gt;pDynamicStates&lt;/code&gt; member of &lt;code&gt;pDynamicState&lt;/code&gt; is &lt;code&gt;VK_DYNAMIC_STATE_DEPTH_BIAS&lt;/code&gt;, and the &lt;code&gt;depthBiasEnable&lt;/code&gt; member of &lt;code&gt;pDepthStencil&lt;/code&gt; is &lt;code&gt;VK_TRUE&lt;/code&gt;, the &lt;code&gt;depthBiasClamp&lt;/code&gt; member of &lt;code&gt;pDepthStencil&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;0.0&lt;/code&gt;</source>
          <target state="translated">깊이 바이어스 클램핑 기능이 사용되지 않으면, 어떠한 엘리먼트 &lt;code&gt;pDynamicStates&lt;/code&gt; 의 멤버 &lt;code&gt;pDynamicState&lt;/code&gt; 는 없다 &lt;code&gt;VK_DYNAMIC_STATE_DEPTH_BIAS&lt;/code&gt; 및 &lt;code&gt;depthBiasEnable&lt;/code&gt; 의 부재 &lt;code&gt;pDepthStencil&lt;/code&gt; 가 있다 &lt;code&gt;VK_TRUE&lt;/code&gt; 상기 &lt;code&gt;depthBiasClamp&lt;/code&gt; 의 멤버 &lt;code&gt;pDepthStencil&lt;/code&gt; 가&lt;strong&gt;해야&lt;/strong&gt; 할 &lt;code&gt;0.0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f058a2a2aa22a20c91a022522aadf832544f9fe0" translate="yes" xml:space="preserve">
          <source>If the device has been lost (see &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-lost-device&quot;&gt;Lost Device&lt;/a&gt;), &lt;code&gt;vkGetFenceStatus&lt;/code&gt;&lt;strong&gt;may&lt;/strong&gt; return any of the above status codes. If the device has been lost and &lt;code&gt;vkGetFenceStatus&lt;/code&gt; is called repeatedly, it will eventually return either &lt;code&gt;VK_SUCCESS&lt;/code&gt; or &lt;code&gt;VK_DEVICE_LOST&lt;/code&gt;.</source>
          <target state="translated">장치가 손실 된 경우 ( &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-lost-device&quot;&gt;장치 분실&lt;/a&gt; 참조 ) &lt;code&gt;vkGetFenceStatus&lt;/code&gt; &lt;strong&gt;는&lt;/strong&gt; 위의 상태 코드 중 하나를 반환 할 &lt;strong&gt;수 있습니다&lt;/strong&gt; . 장치가 손실되고 &lt;code&gt;vkGetFenceStatus&lt;/code&gt; 가 반복적으로 호출되면 결국 &lt;code&gt;VK_SUCCESS&lt;/code&gt; 또는 &lt;code&gt;VK_DEVICE_LOST&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d01918c259e473d8f1cb2dc1b35329a5203ed530" translate="yes" xml:space="preserve">
          <source>If the first use of an attachment in this render pass is as an input attachment, and the attachment is not also used as a color or depth/stencil attachment in the same subpass, then &lt;code&gt;loadOp&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not be &lt;code&gt;VK_ATTACHMENT_LOAD_OP_CLEAR&lt;/code&gt;</source>
          <target state="translated">이 렌더 패스에서 첨부 파일을 처음 사용하는 것이 입력 첨부 파일이고 첨부 파일이 동일한 서브 패스에서 색상 또는 깊이 / 스텐실 첨부 파일로도 사용 되지 않는 경우 &lt;code&gt;VK_ATTACHMENT_LOAD_OP_CLEAR&lt;/code&gt; &lt;strong&gt;는 &lt;/strong&gt; &lt;code&gt;loadOp&lt;/code&gt; &lt;strong&gt;가&lt;/strong&gt; 아니 &lt;strong&gt;어야합니다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8f56bb7fcfdd8706662318cb4c950eb165576478" translate="yes" xml:space="preserve">
          <source>If the format being queried is a depth/stencil format, this bit only indicates that the depth aspect (not the stencil aspect) of an image of this format supports linear filtering, and that linear filtering of the depth aspect is supported whether depth compare is enabled in the sampler or not. If this bit is not present, linear filtering with depth compare disabled is unsupported and linear filtering with depth compare enabled is supported, but &lt;strong&gt;may&lt;/strong&gt; compute the filtered value in an implementation-dependent manner which differs from the normal rules of linear filtering. The resulting value &lt;strong&gt;must&lt;/strong&gt; be in the range [0,1] and &lt;strong&gt;should&lt;/strong&gt; be proportional to, or a weighted average of, the number of comparison passes or failures.</source>
          <target state="translated">쿼리되는 형식이 심도 / 스텐실 형식 인 경우이 비트는이 형식의 이미지의 심도 (스텐실 특성이 아닌)가 선형 필터링을 지원하고 심도 비교의 여부에 상관없이 심도 특성의 선형 필터링이 지원됨을 나타냅니다. 샘플러에서 활성화 여부. 이 비트가 존재하지 않으면 깊이 비교가 비활성화 된 선형 필터링은 지원되지 않고 깊이 비교가 활성화 된 선형 필터링은 지원되지만 일반적인 선형 필터링 규칙과는 다른 구현 종속 방식으로 필터링 된 값을 계산할 &lt;strong&gt;수 있습니다&lt;/strong&gt; . 결과 값 &lt;strong&gt;은&lt;/strong&gt; [0,1] 범위에 &lt;strong&gt;있어야&lt;/strong&gt; 하며 비교 통과 또는 실패 횟수에 비례하거나 가중 평균 &lt;strong&gt;이어야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="6d2bbc4ce5ee19f1e6fef23c05c140fc65281314" translate="yes" xml:space="preserve">
          <source>If the format of the image corresponding to the parameters is one of the block-compressed formats then for the purposes of the above calculations the granularity &lt;strong&gt;must&lt;/strong&gt; be scaled up by the compressed texel block dimensions.</source>
          <target state="translated">파라미터에 대응하는 이미지의 포맷이 블록-압축 포맷 중 하나 인 경우, 상기 계산을 위해 입도 &lt;strong&gt;는&lt;/strong&gt; 압축 된 텍셀 블록 치수에 의해 스케일링 &lt;strong&gt;되어야&lt;/strong&gt; 한다.</target>
        </trans-unit>
        <trans-unit id="708689f31f433200b206ca7c5c602da099057268" translate="yes" xml:space="preserve">
          <source>If the identified entry point includes any variable in its interface that is declared with the &lt;code&gt;ClipDistance&lt;/code&gt;&lt;code&gt;BuiltIn&lt;/code&gt; decoration, that variable &lt;strong&gt;must&lt;/strong&gt; not have an array size greater than &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt;::&lt;code&gt;maxClipDistances&lt;/code&gt;</source>
          <target state="translated">식별 된 진입 점이 인터페이스에 &lt;code&gt;ClipDistance&lt;/code&gt; &lt;code&gt;BuiltIn&lt;/code&gt; 데코레이션으로 선언 된 변수를 포함하는 경우 해당 변수 &lt;strong&gt;는 &lt;/strong&gt; &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; :: &lt;code&gt;maxClipDistances&lt;/code&gt; 보다 큰 배열 크기를 가져서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="10f138f46b9b8fbb350a345ea32606783ac97570" translate="yes" xml:space="preserve">
          <source>If the identified entry point includes any variable in its interface that is declared with the &lt;code&gt;CullDistance&lt;/code&gt;&lt;code&gt;BuiltIn&lt;/code&gt; decoration, that variable &lt;strong&gt;must&lt;/strong&gt; not have an array size greater than &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt;::&lt;code&gt;maxCullDistances&lt;/code&gt;</source>
          <target state="translated">식별 된 진입 점이 인터페이스에 &lt;code&gt;CullDistance&lt;/code&gt; &lt;code&gt;BuiltIn&lt;/code&gt; 장식으로 선언 된 변수를 포함하는 경우 해당 변수 &lt;strong&gt;는 &lt;/strong&gt; &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; :: &lt;code&gt;maxCullDistances&lt;/code&gt; 보다 큰 배열 크기를 가져서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="2f519428d547e30a00af217f6928edd99475c0fc" translate="yes" xml:space="preserve">
          <source>If the identified entry point includes any variable in its interface that is declared with the &lt;code&gt;SampleMask&lt;/code&gt;&lt;code&gt;BuiltIn&lt;/code&gt; decoration, that variable &lt;strong&gt;must&lt;/strong&gt; not have an array size greater than &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt;::&lt;code&gt;maxSampleMaskWords&lt;/code&gt;</source>
          <target state="translated">식별 된 진입 점이 인터페이스에 &lt;code&gt;SampleMask&lt;/code&gt; &lt;code&gt;BuiltIn&lt;/code&gt; 데코레이션으로 선언 된 변수를 포함하는 경우 해당 변수 &lt;strong&gt;는 &lt;/strong&gt; &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; :: &lt;code&gt;maxSampleMaskWords&lt;/code&gt; 보다 큰 배열 크기를 가져서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="5cf5b4cb98b9fe266905a4f2e86c2917aa4b8f13" translate="yes" xml:space="preserve">
          <source>If the identified entry point includes any variables in its interface that are declared with the &lt;code&gt;ClipDistance&lt;/code&gt; or &lt;code&gt;CullDistance&lt;/code&gt;&lt;code&gt;BuiltIn&lt;/code&gt; decoration, those variables &lt;strong&gt;must&lt;/strong&gt; not have array sizes which sum to more than &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt;::&lt;code&gt;maxCombinedClipAndCullDistances&lt;/code&gt;</source>
          <target state="translated">식별 된 진입 점이 인터페이스에 &lt;code&gt;ClipDistance&lt;/code&gt; 또는 &lt;code&gt;CullDistance&lt;/code&gt; &lt;code&gt;BuiltIn&lt;/code&gt; 장식 으로 선언 된 변수를 포함하는 경우 해당 변수 &lt;strong&gt;는 &lt;/strong&gt; &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; :: &lt;code&gt;maxCombinedClipAndCullDistances&lt;/code&gt; 보다 큰 배열 크기를 가져서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="ed706c543a884fdff902df4b0c356594632cf44f" translate="yes" xml:space="preserve">
          <source>If the image has more than one sample, the same value is written to all samples for any pixels being cleared.</source>
          <target state="translated">이미지에 둘 이상의 샘플이있는 경우 지워지는 모든 픽셀에 대해 동일한 값이 모든 샘플에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="d2f83731eb00d7a5a5dafcb9e34360bb94fe469b" translate="yes" xml:space="preserve">
          <source>If the image was not created with &lt;code&gt;VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT&lt;/code&gt; then &lt;code&gt;pSparseMemoryRequirementCount&lt;/code&gt; will be set to zero and &lt;code&gt;pSparseMemoryRequirements&lt;/code&gt; will not be written to.</source>
          <target state="translated">&lt;code&gt;VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT&lt;/code&gt; 로 이미지가 작성되지 않은 경우 &lt;code&gt;pSparseMemoryRequirementCount&lt;/code&gt; 가 0으로 설정되고 &lt;code&gt;pSparseMemoryRequirements&lt;/code&gt; 가 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94874d7411130a1cc5b254dc2cce99a51d64ba63" translate="yes" xml:space="preserve">
          <source>If the implementation is able to continue correct processing of the current command without the requested allocation, then it &lt;strong&gt;may&lt;/strong&gt; do so, and &lt;strong&gt;must&lt;/strong&gt; not generate &lt;code&gt;VK_ERROR_OUT_OF_HOST_MEMORY&lt;/code&gt; as a result of this failed allocation.</source>
          <target state="translated">구현이 요청 된 할당없이 현재 명령의 올바른 처리를 계속할 수 있으면 그렇게 할 &lt;strong&gt;수 &lt;/strong&gt; &lt;code&gt;VK_ERROR_OUT_OF_HOST_MEMORY&lt;/code&gt; 실패한 할당의 결과로 VK_ERROR_OUT_OF_HOST_MEMORY 를 생성하지 &lt;strong&gt;않아야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="88ba7c7344f17960f0ca2d73eb06020e7abe1e28" translate="yes" xml:space="preserve">
          <source>If the memory object does have the &lt;code&gt;VK_MEMORY_PROPERTY_HOST_COHERENT_BIT&lt;/code&gt; property flag, writes to the memory object from the host are automatically made visible to the &lt;code&gt;VK_ACCESS_HOST_WRITE_BIT&lt;/code&gt;&lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-types&quot;&gt;access type&lt;/a&gt;. Similarly, writes made visible to the &lt;code&gt;VK_ACCESS_HOST_READ_BIT&lt;/code&gt;&lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-types&quot;&gt;access type&lt;/a&gt; are automatically made visible to the host.</source>
          <target state="translated">메모리 개체가 가지고있는 경우 &lt;code&gt;VK_MEMORY_PROPERTY_HOST_COHERENT_BIT&lt;/code&gt; 의 속성 플래그를 호스트에서 메모리 개체에 기록하면 자동으로 볼 만들어 &lt;code&gt;VK_ACCESS_HOST_WRITE_BIT&lt;/code&gt; &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-types&quot;&gt; 액세스 유형에&lt;/a&gt; . 마찬가지로 &lt;code&gt;VK_ACCESS_HOST_READ_BIT&lt;/code&gt; &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-types&quot;&gt;액세스 유형에&lt;/a&gt; 표시되는 쓰기는 호스트에 자동으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1394c86c935c7f455dfbfe34cea1bee8811c6136" translate="yes" xml:space="preserve">
          <source>If the pipeline state object is created with the &lt;code&gt;VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK&lt;/code&gt; dynamic state enabled, then to dynamically set the stencil compare mask call:</source>
          <target state="translated">&lt;code&gt;VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK&lt;/code&gt; 동적 상태를 활성화 하여 파이프 라인 상태 객체를 생성 한 경우 스텐실 비교 마스크 호출을 동적으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="3bd8608fd4f878f9931bb51353a0401c875a6309" translate="yes" xml:space="preserve">
          <source>If the pipeline state object is created with the &lt;code&gt;VK_DYNAMIC_STATE_STENCIL_REFERENCE&lt;/code&gt; dynamic state enabled, then to dynamically set the stencil reference value call:</source>
          <target state="translated">파이프 라인 상태 오브젝트가 &lt;code&gt;VK_DYNAMIC_STATE_STENCIL_REFERENCE&lt;/code&gt; 동적 상태를 사용 하여 작성 되면 스텐실 참조 값 호출을 동적으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="8b2e875072383c99541d763643de36cdede794b5" translate="yes" xml:space="preserve">
          <source>If the pipeline state object is created with the &lt;code&gt;VK_DYNAMIC_STATE_STENCIL_WRITE_MASK&lt;/code&gt; dynamic state enabled, then to dynamically set the stencil write mask call:</source>
          <target state="translated">파이프 라인 상태 객체가 &lt;code&gt;VK_DYNAMIC_STATE_STENCIL_WRITE_MASK&lt;/code&gt; 동적 상태를 활성화 경우 스텐실 쓰기 마스크 호출을 동적으로 설정하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="21513b189f372be2a856b4bedd845527e56c317e" translate="yes" xml:space="preserve">
          <source>If the specified timeout period expires before the condition is satisfied, &lt;code&gt;vkWaitForFences&lt;/code&gt; returns &lt;code&gt;VK_TIMEOUT&lt;/code&gt;. If the condition is satisfied before &lt;code&gt;timeout&lt;/code&gt; nanoseconds has expired, &lt;code&gt;vkWaitForFences&lt;/code&gt; returns &lt;code&gt;VK_SUCCESS&lt;/code&gt;.</source>
          <target state="translated">조건이 충족되기 전에 지정된 시간 초과 기간이 만료되면 &lt;code&gt;vkWaitForFences&lt;/code&gt; 가 &lt;code&gt;VK_TIMEOUT&lt;/code&gt; 을 반환합니다 . &lt;code&gt;timeout&lt;/code&gt; 나노초가 만료 되기 전에 조건이 충족 되면 &lt;code&gt;vkWaitForFences&lt;/code&gt; 가 &lt;code&gt;VK_SUCCESS&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="d8b7d3c4890171f8822925870249ee5722f9b96f" translate="yes" xml:space="preserve">
          <source>If the stencil test fails, the sample&amp;rsquo;s coverage bit is cleared in the fragment. If there is no stencil framebuffer attachment, stencil modification &lt;strong&gt;cannot&lt;/strong&gt; occur, and it is as if the stencil tests always pass.</source>
          <target state="translated">스텐실 테스트가 실패하면 샘플의 커버리지 비트가 조각에서 지워집니다. 스텐실 프레임 버퍼 부착이 없으면 스텐실 수정 &lt;strong&gt;이 불가능&lt;/strong&gt; 하며 스텐실 테스트가 항상 통과하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3f95650742d86a041a1880f8296f735ceb2e0c1b" translate="yes" xml:space="preserve">
          <source>If the stencil test passes, the &lt;code&gt;writeMask&lt;/code&gt; member of the &lt;a href=&quot;#VkStencilOpState&quot;&gt;VkStencilOpState&lt;/a&gt; structures controls how the updated stencil value is written to the stencil framebuffer attachment.</source>
          <target state="translated">스텐실 테스트를 통과 하면 &lt;a href=&quot;#VkStencilOpState&quot;&gt;VkStencilOpState&lt;/a&gt; 구조 의 &lt;code&gt;writeMask&lt;/code&gt; 멤버가 업데이트 된 스텐실 값이 스텐실 프레임 버퍼 첨부 파일에 기록되는 방식을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="1ae2725fba86f90060ec41a69c258441ca5c4a24" translate="yes" xml:space="preserve">
          <source>If the the calling command&amp;rsquo;s &lt;code&gt;VkImage&lt;/code&gt; parameter&amp;rsquo;s format is not a depth/stencil format, then &lt;code&gt;bufferOffset&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a multiple of the format&amp;rsquo;s element size</source>
          <target state="translated">호출하는 명령의 &lt;code&gt;VkImage&lt;/code&gt; 매개 변수 형식이 깊이 / 스텐실 형식이 아닌 경우 &lt;code&gt;bufferOffset&lt;/code&gt; &lt;strong&gt;은&lt;/strong&gt; 형식의 요소 크기의 배수 &lt;strong&gt;여야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="e7f06fac0c1cddf9b5428aa9a81918d081c606dd" translate="yes" xml:space="preserve">
          <source>If the value referenced by &lt;code&gt;pDataSize&lt;/code&gt; is not &lt;code&gt;0&lt;/code&gt;, and &lt;code&gt;pData&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;pData&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to an array of &lt;code&gt;pDataSize&lt;/code&gt; bytes</source>
          <target state="translated">에 의해 참조 값 경우 &lt;code&gt;pDataSize&lt;/code&gt; 이 아닌 &lt;code&gt;0&lt;/code&gt; , 및 &lt;code&gt;pData&lt;/code&gt; 의가 아닌 &lt;code&gt;NULL&lt;/code&gt; , &lt;code&gt;pData&lt;/code&gt; 의가&lt;strong&gt;있어야&lt;/strong&gt; 의 배열에 대한 포인터가 될 &lt;code&gt;pDataSize&lt;/code&gt; 의 바이트</target>
        </trans-unit>
        <trans-unit id="25568656307073e6522ffc92dfbea75618f7430b" translate="yes" xml:space="preserve">
          <source>If the value referenced by &lt;code&gt;pPhysicalDeviceCount&lt;/code&gt; is not &lt;code&gt;0&lt;/code&gt;, and &lt;code&gt;pPhysicalDevices&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;pPhysicalDevices&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to an array of &lt;code&gt;pPhysicalDeviceCount&lt;/code&gt;&lt;code&gt;VkPhysicalDevice&lt;/code&gt; handles</source>
          <target state="translated">이 참조하는 경우 값 &lt;code&gt;pPhysicalDeviceCount&lt;/code&gt; 가 아닌 &lt;code&gt;0&lt;/code&gt; 및 &lt;code&gt;pPhysicalDevices&lt;/code&gt; 아니다 &lt;code&gt;NULL&lt;/code&gt; , &lt;code&gt;pPhysicalDevices&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 의 배열에 대한 포인터 &lt;code&gt;pPhysicalDeviceCount&lt;/code&gt; &lt;code&gt;VkPhysicalDevice&lt;/code&gt; 의 핸들</target>
        </trans-unit>
        <trans-unit id="bd807452626bfe7b2ca78aad0271f244449daea0" translate="yes" xml:space="preserve">
          <source>If the value referenced by &lt;code&gt;pPropertyCount&lt;/code&gt; is not &lt;code&gt;0&lt;/code&gt;, and &lt;code&gt;pProperties&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;pProperties&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to an array of &lt;code&gt;pPropertyCount&lt;/code&gt;&lt;code&gt;VkExtensionProperties&lt;/code&gt; structures</source>
          <target state="translated">에 의해 참조 값 경우 &lt;code&gt;pPropertyCount&lt;/code&gt; 이 아닌 &lt;code&gt;0&lt;/code&gt; , 및 &lt;code&gt;pProperties&lt;/code&gt; 이 아닌 &lt;code&gt;NULL&lt;/code&gt; , &lt;code&gt;pProperties&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 의 배열에 대한 포인터가 될 &lt;code&gt;pPropertyCount&lt;/code&gt; &lt;code&gt;VkExtensionProperties&lt;/code&gt; 구조</target>
        </trans-unit>
        <trans-unit id="4e3979be2fc9cdc2dd1b757b50227cb79ffe7f6b" translate="yes" xml:space="preserve">
          <source>If the value referenced by &lt;code&gt;pPropertyCount&lt;/code&gt; is not &lt;code&gt;0&lt;/code&gt;, and &lt;code&gt;pProperties&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;pProperties&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to an array of &lt;code&gt;pPropertyCount&lt;/code&gt;&lt;code&gt;VkLayerProperties&lt;/code&gt; structures</source>
          <target state="translated">에 의해 참조 값 경우 &lt;code&gt;pPropertyCount&lt;/code&gt; 이 아닌 &lt;code&gt;0&lt;/code&gt; , 및 &lt;code&gt;pProperties&lt;/code&gt; 이 아닌 &lt;code&gt;NULL&lt;/code&gt; , &lt;code&gt;pProperties&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 의 배열에 대한 포인터가 될 &lt;code&gt;pPropertyCount&lt;/code&gt; &lt;code&gt;VkLayerProperties&lt;/code&gt; 구조</target>
        </trans-unit>
        <trans-unit id="1cb56b4065fbae60f3f4908c086f0586b66673e4" translate="yes" xml:space="preserve">
          <source>If the value referenced by &lt;code&gt;pPropertyCount&lt;/code&gt; is not &lt;code&gt;0&lt;/code&gt;, and &lt;code&gt;pProperties&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;pProperties&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to an array of &lt;code&gt;pPropertyCount&lt;/code&gt;&lt;code&gt;VkSparseImageFormatProperties&lt;/code&gt; structures</source>
          <target state="translated">에 의해 참조 값 경우 &lt;code&gt;pPropertyCount&lt;/code&gt; 이 아닌 &lt;code&gt;0&lt;/code&gt; , 및 &lt;code&gt;pProperties&lt;/code&gt; 이 아닌 &lt;code&gt;NULL&lt;/code&gt; , &lt;code&gt;pProperties&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 의 배열에 대한 포인터가 될 &lt;code&gt;pPropertyCount&lt;/code&gt; &lt;code&gt;VkSparseImageFormatProperties&lt;/code&gt; 구조</target>
        </trans-unit>
        <trans-unit id="8228854d1863f05f1534a9b0baf89ccd6922136d" translate="yes" xml:space="preserve">
          <source>If the value referenced by &lt;code&gt;pQueueFamilyPropertyCount&lt;/code&gt; is not &lt;code&gt;0&lt;/code&gt;, and &lt;code&gt;pQueueFamilyProperties&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;pQueueFamilyProperties&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to an array of &lt;code&gt;pQueueFamilyPropertyCount&lt;/code&gt;&lt;code&gt;VkQueueFamilyProperties&lt;/code&gt; structures</source>
          <target state="translated">에 의해 참조 값 경우 &lt;code&gt;pQueueFamilyPropertyCount&lt;/code&gt; 이 아닌 &lt;code&gt;0&lt;/code&gt; , 및 &lt;code&gt;pQueueFamilyProperties&lt;/code&gt; 이 아닌 &lt;code&gt;NULL&lt;/code&gt; , &lt;code&gt;pQueueFamilyProperties&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 의 배열에 대한 포인터가 될 &lt;code&gt;pQueueFamilyPropertyCount&lt;/code&gt; &lt;code&gt;VkQueueFamilyProperties&lt;/code&gt; 구조</target>
        </trans-unit>
        <trans-unit id="54046ebcc97e7ae2b4124937e1b1502a1a24a1f1" translate="yes" xml:space="preserve">
          <source>If the value referenced by &lt;code&gt;pSparseMemoryRequirementCount&lt;/code&gt; is not &lt;code&gt;0&lt;/code&gt;, and &lt;code&gt;pSparseMemoryRequirements&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;pSparseMemoryRequirements&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a pointer to an array of &lt;code&gt;pSparseMemoryRequirementCount&lt;/code&gt;&lt;code&gt;VkSparseImageMemoryRequirements&lt;/code&gt; structures</source>
          <target state="translated">에 의해 참조 값 경우 &lt;code&gt;pSparseMemoryRequirementCount&lt;/code&gt; 이 아닌 &lt;code&gt;0&lt;/code&gt; , 및 &lt;code&gt;pSparseMemoryRequirements&lt;/code&gt; 이 아닌 &lt;code&gt;NULL&lt;/code&gt; , &lt;code&gt;pSparseMemoryRequirements&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 의 배열에 대한 포인터가 될 &lt;code&gt;pSparseMemoryRequirementCount&lt;/code&gt; 의 &lt;code&gt;VkSparseImageMemoryRequirements&lt;/code&gt; 의 구조</target>
        </trans-unit>
        <trans-unit id="a0a7dfe4815abbae2e5a5f5b8e448c9d236c0a1b" translate="yes" xml:space="preserve">
          <source>If the vendor of the physical device has a valid PCI vendor ID issued by &lt;a href=&quot;https://pcisig.com/&quot;&gt;PCI-SIG&lt;/a&gt;, that ID &lt;strong&gt;should&lt;/strong&gt; be used to construct &lt;code&gt;vendorID&lt;/code&gt; as described above for PCI-based implementations. Implementations that do not return a PCI vendor ID in &lt;code&gt;vendorID&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; return a valid Khronos vendor ID, obtained as described in the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vulkan-styleguide&quot;&gt;Vulkan Documentation and Extensions&lt;/a&gt; document in the section &amp;ldquo;Registering a Vendor ID with Khronos&amp;rdquo;. Khronos vendor IDs are allocated starting at 0x10000, to distinguish them from the PCI vendor ID namespace.</source>
          <target state="translated">물리적 장치의 벤더에 의해 발행 유효한 PCI 벤더 ID가있는 경우 &lt;a href=&quot;https://pcisig.com/&quot;&gt;PCI-SIG를&lt;/a&gt; 그 ID가 &lt;strong&gt;있어야&lt;/strong&gt; 구성하는데 사용될 &lt;code&gt;vendorID&lt;/code&gt; PCI 기반 구현 예에 대해 상술 한 바와 같이. &lt;code&gt;vendorID&lt;/code&gt; 에 PCI 공급 업체 ID를 반환하지 않는 구현은&amp;ldquo; Kronos &lt;strong&gt;를 사용&lt;/strong&gt; 하여 공급 업체 ID 등록&amp;rdquo;섹션 의 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vulkan-styleguide&quot;&gt;Vulkan 설명서 및 확장&lt;/a&gt; 문서에 설명 된대로 유효한 Khronos 공급 업체 ID를 반환 &lt;strong&gt;해야합니다&lt;/strong&gt; . Khronos 공급 업체 ID는 PCI 공급 업체 ID 네임 스페이스와 구별하기 위해 0x10000부터 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="0d5463c7a76983c1077e07d34fa03527edb8f918" translate="yes" xml:space="preserve">
          <source>If the wide lines feature is not enabled, and no element of the &lt;code&gt;pDynamicStates&lt;/code&gt; member of &lt;code&gt;pDynamicState&lt;/code&gt; is &lt;code&gt;VK_DYNAMIC_STATE_LINE_WIDTH&lt;/code&gt;, the &lt;code&gt;lineWidth&lt;/code&gt; member of &lt;code&gt;pRasterizationState&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;1.0&lt;/code&gt;</source>
          <target state="translated">넓은 라인 기능이 사용되지 않으며, 어떠한 요소 경우 &lt;code&gt;pDynamicStates&lt;/code&gt; 의 회원 &lt;code&gt;pDynamicState&lt;/code&gt; 가 없습니다 &lt;code&gt;VK_DYNAMIC_STATE_LINE_WIDTH&lt;/code&gt; 의 &lt;code&gt;lineWidth&lt;/code&gt; 의 멤버 &lt;code&gt;pRasterizationState&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;1.0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73c8518bfc4366e501489a6f8a21715ef69fe57a" translate="yes" xml:space="preserve">
          <source>If there was an error during recording, the application will be notified by an unsuccessful return code returned by &lt;code&gt;vkEndCommandBuffer&lt;/code&gt;. If the application wishes to further use the command buffer, the command buffer &lt;strong&gt;must&lt;/strong&gt; be reset. The command buffer &lt;strong&gt;must&lt;/strong&gt; have been in the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;recording state&lt;/a&gt;, and is moved to the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;executable state&lt;/a&gt;.</source>
          <target state="translated">기록하는 동안 오류가 발생한 경우 &lt;code&gt;vkEndCommandBuffer&lt;/code&gt; 에서 리턴 한 리턴 코드가 실패하여 애플리케이션에 알립니다 . 응용 프로그램이 명령 버퍼를 추가로 사용하려면 명령 버퍼를 재설정 &lt;strong&gt;해야&lt;/strong&gt; 합니다. 명령 버퍼 &lt;strong&gt;는 &lt;/strong&gt;&lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;기록 상태&lt;/a&gt; 에 &lt;strong&gt;있어야&lt;/strong&gt; 하며 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;실행 가능 상태&lt;/a&gt; 로 이동해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ae9a2543c02df9b741b548479bd8c55c951fb755" translate="yes" xml:space="preserve">
          <source>If this function fails and &lt;code&gt;pOriginal&lt;/code&gt; is non-&lt;code&gt;NULL&lt;/code&gt; the application &lt;strong&gt;must&lt;/strong&gt; not free the old allocation.</source>
          <target state="translated">이 함수가 실패하고 &lt;code&gt;pOriginal&lt;/code&gt; 이 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 응용 프로그램 &lt;strong&gt;은&lt;/strong&gt; 이전 할당을 해제하지 &lt;strong&gt;않아야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="56540e8d9a562b8ccfdd00041da2a9b42c1a9291" translate="yes" xml:space="preserve">
          <source>Image formats which &lt;strong&gt;can&lt;/strong&gt; be passed to, and &lt;strong&gt;may&lt;/strong&gt; be returned from Vulkan commands, are:</source>
          <target state="translated">Vulkan 명령 으로 전달되고 Vulkan 명령에서 반환 &lt;strong&gt;될 &lt;/strong&gt;&lt;strong&gt;수&lt;/strong&gt; 있는 이미지 형식 은 다음과 같습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dc7aea89ea7b1285bdebb8b6dce382d81c351c02" translate="yes" xml:space="preserve">
          <source>Image objects are not directly accessed by pipeline shaders for reading or writing image data. Instead, &lt;em&gt;image views&lt;/em&gt; representing contiguous ranges of the image subresources and containing additional metadata are used for that purpose. Views &lt;strong&gt;must&lt;/strong&gt; be created on images of compatible types, and &lt;strong&gt;must&lt;/strong&gt; represent a valid subset of image subresources.</source>
          <target state="translated">이미지 데이터는 이미지 데이터를 읽거나 쓰는 파이프 라인 쉐이더에 의해 직접 액세스되지 않습니다. 대신, &lt;em&gt;이미지&lt;/em&gt; 하위 리소스의 연속 범위를 나타내고 추가 메타 데이터를 포함하는 &lt;em&gt;이미지보기&lt;/em&gt; 가 해당 목적으로 사용됩니다. 보기 &lt;strong&gt;는&lt;/strong&gt; 호환 가능한 유형의 이미지에서 작성 &lt;strong&gt;되어야&lt;/strong&gt; 하며 유효한 이미지 서브 자원 서브 세트를 나타내야합니다.</target>
        </trans-unit>
        <trans-unit id="81ddf6753fd0aad180f22e26cf6048ae03bf23cf" translate="yes" xml:space="preserve">
          <source>Image parameters</source>
          <target state="translated">이미지 매개 변수</target>
        </trans-unit>
        <trans-unit id="0afd8402ae9d964414342afe8732cb509d669cba" translate="yes" xml:space="preserve">
          <source>Image subresources used as attachments &lt;strong&gt;must&lt;/strong&gt; not be accessed in any other way for the duration of a render pass instance.</source>
          <target state="translated">첨부 파일로 사용 된 이미지 하위 리소스 는 렌더 패스 인스턴스 기간 동안 다른 방식으로 액세스 &lt;strong&gt;해서는&lt;/strong&gt; 안됩니다.</target>
        </trans-unit>
        <trans-unit id="6ec2c6fc56f7ada1535d1030947efe7b79df32fc" translate="yes" xml:space="preserve">
          <source>Image subresources used as attachments in the current render pass &lt;strong&gt;must&lt;/strong&gt; not be accessed in any way other than as an attachment by this command.</source>
          <target state="translated">현재 렌더 패스에서 첨부 파일로 사용 된 이미지 하위 리소스 는이 명령에 의한 첨부 파일 이외의 방식으로 액세스 &lt;strong&gt;해서는&lt;/strong&gt; 안됩니다.</target>
        </trans-unit>
        <trans-unit id="7b81ccc95283a87443226d3c08a0517e515b981d" translate="yes" xml:space="preserve">
          <source>Image views are represented by &lt;code&gt;VkImageView&lt;/code&gt; handles:</source>
          <target state="translated">이미지 뷰는 &lt;code&gt;VkImageView&lt;/code&gt; 핸들 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="38b1c7b31c65affa0e0f560ec0798cc62c3f8279" translate="yes" xml:space="preserve">
          <source>Images are represented by &lt;code&gt;VkImage&lt;/code&gt; handles:</source>
          <target state="translated">이미지는 &lt;code&gt;VkImage&lt;/code&gt; 핸들 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="ed88f13607e3c1609e3b6dbec1311e457c0b4ecf" translate="yes" xml:space="preserve">
          <source>Images created with &lt;code&gt;tiling&lt;/code&gt; equal to &lt;code&gt;VK_IMAGE_TILING_LINEAR&lt;/code&gt; have further restrictions on their limits and capabilities compared to images created with &lt;code&gt;tiling&lt;/code&gt; equal to &lt;code&gt;VK_IMAGE_TILING_OPTIMAL&lt;/code&gt;. Creation of images with tiling &lt;code&gt;VK_IMAGE_TILING_LINEAR&lt;/code&gt;&lt;strong&gt;may&lt;/strong&gt; not be supported unless other parameters meet all of the constraints:</source>
          <target state="translated">로 만든 이미지를 &lt;code&gt;tiling&lt;/code&gt; 에 동일한 &lt;code&gt;VK_IMAGE_TILING_LINEAR&lt;/code&gt; 이 만든 이미지에 비해 자신의 한계와 기능에 대한 추가 제한이 &lt;code&gt;tiling&lt;/code&gt; 동일 &lt;code&gt;VK_IMAGE_TILING_OPTIMAL&lt;/code&gt; . 다른 매개 변수가 모든 제약 조건을 충족하지 않으면 타일링 &lt;code&gt;VK_IMAGE_TILING_LINEAR&lt;/code&gt; 를 사용 하여 이미지를 만들 &lt;strong&gt;수&lt;/strong&gt; 없습니다.</target>
        </trans-unit>
        <trans-unit id="fc45e1c0d35af06285aca40db6402e506931b9fd" translate="yes" xml:space="preserve">
          <source>Images represent multidimensional - up to 3 - arrays of data which &lt;strong&gt;can&lt;/strong&gt; be used for various purposes (e.g. attachments, textures), by binding them to a graphics or compute pipeline via descriptor sets, or by directly specifying them as parameters to certain commands.</source>
          <target state="translated">이미지는 다차원 (최대 3 개)의 데이터 배열을 나타내며 , 다양한 목적 (예 : 첨부 파일, 텍스처)에 사용할 &lt;strong&gt;수&lt;/strong&gt; 있습니다.이를 설명자 세트를 통해 그래픽이나 계산 파이프 라인에 바인딩하거나 특정 명령에 대한 매개 변수로 직접 지정합니다.</target>
        </trans-unit>
        <trans-unit id="c56b53cd8ccdf0e63a7b6e70c8e74861b2788035" translate="yes" xml:space="preserve">
          <source>Images still require a &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#resources-image-layouts&quot;&gt;layout transition&lt;/a&gt; from &lt;code&gt;VK_IMAGE_LAYOUT_UNDEFINED&lt;/code&gt; or &lt;code&gt;VK_IMAGE_LAYOUT_PREINITIALIZED&lt;/code&gt; before being used on the first queue.</source>
          <target state="translated">이미지는 여전히 첫 번째 대기열에서 사용되기 전에 &lt;code&gt;VK_IMAGE_LAYOUT_UNDEFINED&lt;/code&gt; 또는 &lt;code&gt;VK_IMAGE_LAYOUT_PREINITIALIZED&lt;/code&gt; 에서 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#resources-image-layouts&quot;&gt;레이아웃 전환이&lt;/a&gt; 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="7d6b1993bf2454d104ce5f3aac73fe0d26abe907" translate="yes" xml:space="preserve">
          <source>Implementations &lt;strong&gt;may&lt;/strong&gt; support additional limits and capabilities beyond those listed above.</source>
          <target state="translated">구현 &lt;strong&gt;은&lt;/strong&gt; 위에 나열된 것 이상의 추가 제한 및 기능을 지원할 &lt;strong&gt;수 있습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c184b611d1e020755822644bc18e37ed11616280" translate="yes" xml:space="preserve">
          <source>Implementations &lt;strong&gt;should&lt;/strong&gt; make every effort to limit any critical sections to the actual accesses to the cache, which is expected to be significantly shorter than the duration of the &lt;code&gt;vkCreateGraphicsPipelines&lt;/code&gt; and &lt;code&gt;vkCreateComputePipelines&lt;/code&gt; commands.</source>
          <target state="translated">구현 &lt;strong&gt;해야&lt;/strong&gt; 의 기간보다 훨씬 짧은 것으로 예상된다 캐시에 실제 액세스에 어떤 임계 영역을 제한하기 위해 모든 노력하게 &lt;code&gt;vkCreateGraphicsPipelines&lt;/code&gt; 및 &lt;code&gt;vkCreateComputePipelines&lt;/code&gt; 의 명령을.</target>
        </trans-unit>
        <trans-unit id="c74baf1fbeea0b9a62e010e6276e264826269db6" translate="yes" xml:space="preserve">
          <source>In order to support systems with multiple Vulkan implementations comprising heterogeneous collections of hardware and software, the function pointers returned by &lt;code&gt;vkGetInstanceProcAddr&lt;/code&gt;&lt;strong&gt;may&lt;/strong&gt; point to dispatch code, which calls a different real implementation for different &lt;code&gt;VkDevice&lt;/code&gt; objects (and objects created from them). The overhead of this internal dispatch &lt;strong&gt;can&lt;/strong&gt; be avoided by obtaining device-specific function pointers for any commands that use a device or device-child object as their dispatchable object. Such function pointers &lt;strong&gt;can&lt;/strong&gt; be obtained with the command:</source>
          <target state="translated">이기종 하드웨어 및 소프트웨어 콜렉션을 포함하는 여러 Vulkan 구현을 가진 시스템을 지원하기 위해 &lt;code&gt;vkGetInstanceProcAddr&lt;/code&gt; 에 의해 리턴되는 함수 포인터는 코드를 디스패치 &lt;strong&gt;할 수 있습니다.이&lt;/strong&gt; 코드는 다른 &lt;code&gt;VkDevice&lt;/code&gt; 오브젝트 (및 이들로부터 작성된 오브젝트)에 대해 다른 실제 구현을 호출합니다 . 이 내부 디스패치의 오버 헤드는 디바이스 또는 디바이스-하위 오브젝트를 디스패치 가능 오브젝트로 사용하는 모든 명령에 대한 디바이스 특정 함수 포인터를 확보함으로써 피할 &lt;strong&gt;수&lt;/strong&gt; 있습니다. 이러한 함수 포인터 &lt;strong&gt;는&lt;/strong&gt; 다음 명령으로 얻을 &lt;strong&gt;수&lt;/strong&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6e2634175a4dc089b48d2a1466c33732fa955c6" translate="yes" xml:space="preserve">
          <source>In this table, the following conventions are used:</source>
          <target state="translated">이 표에서는 다음과 같은 규칙이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c9c8d2c9a6af8b07da14869e39d7e5e1844a6c1c" translate="yes" xml:space="preserve">
          <source>Information about the descriptor set layout is passed in an instance of the &lt;code&gt;VkDescriptorSetLayoutCreateInfo&lt;/code&gt; structure:</source>
          <target state="translated">디스크립터 세트 레이아웃에 대한 정보는 &lt;code&gt;VkDescriptorSetLayoutCreateInfo&lt;/code&gt; 구조 의 인스턴스에 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="45fca81be8a6e01915813868a52d5a423c24224c" translate="yes" xml:space="preserve">
          <source>Information about the layout of the image subresource is returned in a &lt;code&gt;VkSubresourceLayout&lt;/code&gt; structure:</source>
          <target state="translated">이미지 하위 리소스의 레이아웃에 대한 정보는 &lt;code&gt;VkSubresourceLayout&lt;/code&gt; 구조 로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="8deed4efac89dc1076983f50d9dda54976214d59" translate="yes" xml:space="preserve">
          <source>Inside</source>
          <target state="translated">Inside</target>
        </trans-unit>
        <trans-unit id="13cd833744334ee496db672981052ffca5b15e53" translate="yes" xml:space="preserve">
          <source>Instances are represented by &lt;code&gt;VkInstance&lt;/code&gt; handles:</source>
          <target state="translated">인스턴스는 &lt;code&gt;VkInstance&lt;/code&gt; 핸들 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="07bafcbf8e3c88748cd64d44a8336fceaa34634c" translate="yes" xml:space="preserve">
          <source>Integer formats &lt;strong&gt;can&lt;/strong&gt; only be converted to other integer formats with the same signedness.</source>
          <target state="translated">정수 형식 &lt;strong&gt;은&lt;/strong&gt; 동일한 부호를 가진 다른 정수 형식으로 만 변환 &lt;strong&gt;할&lt;/strong&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="958696b9ed9d82ed397c31de385f2e526bade09f" translate="yes" xml:space="preserve">
          <source>It is an application error to call &lt;code&gt;vkMapMemory&lt;/code&gt; on a memory object that is already mapped.</source>
          <target state="translated">이미 매핑 된 메모리 개체에서 &lt;code&gt;vkMapMemory&lt;/code&gt; 를 호출하는 것은 응용 프로그램 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="e542ca6dc31d6447047a27c0a75533ab68120d44" translate="yes" xml:space="preserve">
          <source>It is important for the application developer to become meticulously familiar with all of the mechanisms described in the chapter on &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization&quot;&gt;Synchronization and Cache Control&lt;/a&gt; as they are crucial to maintaining memory access ordering.</source>
          <target state="translated">응용 프로그램 개발자 는 메모리 액세스 순서를 유지 관리하는 데 중요하므로 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization&quot;&gt;동기화 및 캐시 제어&lt;/a&gt; 장에 설명 된 모든 메커니즘을 꼼꼼하게 익히는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="3029f703d75931fe83308f2d109490fa01906890" translate="yes" xml:space="preserve">
          <source>It is legal for a subpass to use no color or depth/stencil attachments, and rather use shader side effects such as image stores and atomics to produce an output. In this case, the subpass continues to use the &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, and &lt;code&gt;layers&lt;/code&gt; of the framebuffer to define the dimensions of the rendering area, and the &lt;code&gt;rasterizationSamples&lt;/code&gt; from each pipeline&amp;rsquo;s &lt;a href=&quot;#VkPipelineMultisampleStateCreateInfo&quot;&gt;VkPipelineMultisampleStateCreateInfo&lt;/a&gt; to define the number of samples used in rasterization; however, if &lt;a href=&quot;#VkPhysicalDeviceFeatures&quot;&gt;VkPhysicalDeviceFeatures&lt;/a&gt;::&lt;code&gt;variableMultisampleRate&lt;/code&gt; is &lt;code&gt;VK_FALSE&lt;/code&gt;, then all pipelines to be bound with a given zero-attachment subpass &lt;strong&gt;must&lt;/strong&gt; have the same value for &lt;a href=&quot;#VkPipelineMultisampleStateCreateInfo&quot;&gt;VkPipelineMultisampleStateCreateInfo&lt;/a&gt;::&lt;code&gt;rasterizationSamples&lt;/code&gt;.</source>
          <target state="translated">서브 패스가 색상 또는 깊이 / 스텐실 부착물을 사용하지 않고 이미지 저장소 및 원자와 같은 쉐이더 부작용을 사용하여 출력물을 생성하는 것이 합법적입니다. 이 경우, subpass는 계속 사용 &lt;code&gt;width&lt;/code&gt; , &lt;code&gt;height&lt;/code&gt; , 및 &lt;code&gt;layers&lt;/code&gt; 렌더링 영역의 크기, 상기 정의하는 프레임 버퍼를 &lt;code&gt;rasterizationSamples&lt;/code&gt; 각 파이프의 발 &lt;a href=&quot;#VkPipelineMultisampleStateCreateInfo&quot;&gt;VkPipelineMultisampleStateCreateInfo을&lt;/a&gt; 래스터에 사용되는 샘플들의 개수를 정의하는 단계; 그러나, &lt;a href=&quot;#VkPhysicalDeviceFeatures&quot;&gt;VkPhysicalDeviceFeatures&lt;/a&gt; :: &lt;code&gt;variableMultisampleRate&lt;/code&gt; 이 있다 &lt;code&gt;VK_FALSE&lt;/code&gt; 는 , 주어진 제로 부착 subpass와 결합되는 모든 파이프 라인 &lt;strong&gt;필수&lt;/strong&gt;&lt;a href=&quot;#VkPipelineMultisampleStateCreateInfo&quot;&gt;VkPipelineMultisampleStateCreateInfo&lt;/a&gt; :: &lt;code&gt;rasterizationSamples&lt;/code&gt; 의 값이 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="1b82ed9d94c1ada5d7e07e124a1f64adcbf1f82f" translate="yes" xml:space="preserve">
          <source>It is legal for an implementation to report a larger value in &lt;code&gt;VkMemoryRequirements&lt;/code&gt;::&lt;code&gt;size&lt;/code&gt; than would be obtained by adding together memory sizes for all &lt;code&gt;VkSparseImageMemoryRequirements&lt;/code&gt; returned by &lt;code&gt;vkGetImageSparseMemoryRequirements&lt;/code&gt;. This &lt;strong&gt;may&lt;/strong&gt; occur when the hardware requires unused padding in the address range describing the resource.</source>
          <target state="translated">구현이 더 큰 가치보고하는 것은 법적 &lt;code&gt;VkMemoryRequirements&lt;/code&gt; :: &lt;code&gt;size&lt;/code&gt; 모두 함께 메모리 크기를 더한되는 것보다 &lt;code&gt;VkSparseImageMemoryRequirements&lt;/code&gt; 에 의해 반환 &lt;code&gt;vkGetImageSparseMemoryRequirements&lt;/code&gt; 을 . 이는 하드웨어가 리소스를 설명하는 주소 범위에서 사용되지 않은 패딩을 요구할 때 발생할 &lt;strong&gt;수&lt;/strong&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="63e2a26ecc7423e3bb35c40f316eb6d208a8297a" translate="yes" xml:space="preserve">
          <source>It is valid to set both &lt;code&gt;VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT&lt;/code&gt; and &lt;code&gt;VK_PIPELINE_CREATE_DERIVATIVE_BIT&lt;/code&gt;. This allows a pipeline to be both a parent and possibly a child in a pipeline hierarchy. See &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#pipelines-pipeline-derivatives&quot;&gt;Pipeline Derivatives&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT&lt;/code&gt; 및 &lt;code&gt;VK_PIPELINE_CREATE_DERIVATIVE_BIT&lt;/code&gt; 를 모두 설정하는 것이 유효합니다 . 이를 통해 파이프 라인은 파이프 라인 계층에서 상위 및 가능할 수 있습니다. 자세한 정보는 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#pipelines-pipeline-derivatives&quot;&gt;파이프 라인 파생&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="211ec93f0374b890f6c782dc446be9c882960bbc" translate="yes" xml:space="preserve">
          <source>Layout transitions that are performed via image memory barriers execute in their entirety in &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-submission-order&quot;&gt;submission order&lt;/a&gt;, relative to other image layout transitions submitted to the same queue, including those performed by &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass&quot;&gt;render passes&lt;/a&gt;. In effect there is an implicit execution dependency from each such layout transition to all layout transitions previously submitted to the same queue.</source>
          <target state="translated">이미지 메모리 장벽을 통해 수행되는 레이아웃 전환은 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass&quot;&gt;렌더 패스에&lt;/a&gt; 의해 수행되는 것을 포함하여 동일한 큐에 제출 된 다른 이미지 레이아웃 전환과 관련하여 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-submission-order&quot;&gt;제출 순서대로&lt;/a&gt; 전체적으로 실행됩니다 . 사실상, 이러한 각 레이아웃 전환에서 이전에 동일한 대기열에 제출 된 모든 레이아웃 전환으로의 암시 적 실행 종속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9ce522cb0a03624969154fd5e6aceacb8a3f714" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution 4.0 International License.</source>
          <target state="translated">Creative Commons Attribution 4.0 국제 라이센스에 따라 라이센스가 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="c2a0c893019e3e3d26689e1a93c0a0ec482ff903" translate="yes" xml:space="preserve">
          <source>Logical devices are represented by &lt;code&gt;VkDevice&lt;/code&gt; handles:</source>
          <target state="translated">논리 장치는 &lt;code&gt;VkDevice&lt;/code&gt; 핸들 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="e22d4798fb728af4e1e14a5af6f163593cf02105" translate="yes" xml:space="preserve">
          <source>Logical operations are controlled by the &lt;code&gt;logicOpEnable&lt;/code&gt; and &lt;code&gt;logicOp&lt;/code&gt; members of &lt;a href=&quot;#VkPipelineColorBlendStateCreateInfo&quot;&gt;VkPipelineColorBlendStateCreateInfo&lt;/a&gt;. If &lt;code&gt;logicOpEnable&lt;/code&gt; is &lt;code&gt;VK_TRUE&lt;/code&gt;, then a logical operation selected by &lt;code&gt;logicOp&lt;/code&gt; is applied between each color attachment and the fragment&amp;rsquo;s corresponding output value, and blending of all attachments is treated as if it were disabled. Any attachments using color formats for which logical operations are not supported simply pass through the color values unmodified. The logical operation is applied independently for each of the red, green, blue, and alpha components. The &lt;code&gt;logicOp&lt;/code&gt; is selected from the following operations:</source>
          <target state="translated">논리 연산은에 의해 제어되는 &lt;code&gt;logicOpEnable&lt;/code&gt; 및 &lt;code&gt;logicOp&lt;/code&gt; 의 회원 &lt;a href=&quot;#VkPipelineColorBlendStateCreateInfo&quot;&gt;VkPipelineColorBlendStateCreateInfo&lt;/a&gt; . 경우 &lt;code&gt;logicOpEnable&lt;/code&gt; 가 있다 &lt;code&gt;VK_TRUE&lt;/code&gt; , 그때 선택된 논리 연산 &lt;code&gt;logicOp&lt;/code&gt; 는 각 색 및 부착 단편의 대응하는 출력 값 사이에인가되고, 무효 인 것처럼 모든 첨부 블렌딩 처리된다. 논리 연산이 지원되지 않는 색상 형식을 사용하는 첨부 파일은 수정되지 않은 색상 값을 통과합니다. 논리 연산은 빨강, 초록, 파랑 ​​및 알파 구성 요소 각각에 대해 독립적으로 적용됩니다. &lt;code&gt;logicOp&lt;/code&gt; 는 다음과 같은 작업에서 선택 :</target>
        </trans-unit>
        <trans-unit id="088e0e8e8f032365941bd93c8844c6b3d25b44ce" translate="yes" xml:space="preserve">
          <source>Mapping non-coherent memory does not implicitly invalidate the mapped memory, and device writes that have not been invalidated &lt;strong&gt;must&lt;/strong&gt; be made visible before the host reads or overwrites them.</source>
          <target state="translated">비 일관성 메모리 매핑은 매핑 된 메모리를 암시 적으로 무효화하지 않으며 호스트가 메모리를 읽거나 덮어 쓰기 전에 무효화되지 않은 장치 쓰기를 표시 &lt;strong&gt;해야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="ea92b6b03a8c8ec828084da110ee37b8b1e229aa" translate="yes" xml:space="preserve">
          <source>Mapping of OpenGL to Vulkan filter modes</source>
          <target state="translated">OpenGL을 Vulkan 필터 모드로 매핑</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="1cb449c1126609b4b41e1d87f65f0d7cd19b49b9" translate="yes" xml:space="preserve">
          <source>Members</source>
          <target state="translated">Members</target>
        </trans-unit>
        <trans-unit id="d4040e7237109fa0399aceefd8371df89689f06c" translate="yes" xml:space="preserve">
          <source>Members of &lt;code&gt;VkDescriptorImageInfo&lt;/code&gt; that are not used in an update (as described above) are ignored.</source>
          <target state="translated">업데이트에 사용되지 않은 &lt;code&gt;VkDescriptorImageInfo&lt;/code&gt; 멤버 (위에 설명 된대로)는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="584c3f218214226a92f9fe0a54eb0fd316f70f2f" translate="yes" xml:space="preserve">
          <source>Memory &lt;strong&gt;can&lt;/strong&gt; be bound to sparse image blocks of &lt;code&gt;VkImage&lt;/code&gt; objects created with the &lt;code&gt;VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT&lt;/code&gt; flag using the following structure:</source>
          <target state="translated">다음 구조를 사용하여 &lt;code&gt;VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT&lt;/code&gt; 플래그로 생성 된 &lt;code&gt;VkImage&lt;/code&gt; 객체 의 스파 스 이미지 블록에 메모리 &lt;strong&gt;를&lt;/strong&gt; 바인딩 &lt;strong&gt;할 수&lt;/strong&gt; 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6556bcdcbaccd429b8497e030af13546ac4a42a4" translate="yes" xml:space="preserve">
          <source>Memory in Vulkan &lt;strong&gt;can&lt;/strong&gt; be accessed from within shader invocations and via some fixed-function stages of the pipeline. The &lt;em&gt;access type&lt;/em&gt; is a function of the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets&quot;&gt;descriptor type&lt;/a&gt; used, or how a fixed-function stage accesses memory. Each access type corresponds to a bit flag in &lt;a href=&quot;#VkAccessFlagBits&quot;&gt;VkAccessFlagBits&lt;/a&gt;.</source>
          <target state="translated">Vulkan의 메모리는 셰이더 호출 내에서 및 파이프 라인의 일부 고정 기능 단계를 통해 액세스 할 &lt;strong&gt;수&lt;/strong&gt; 있습니다. &lt;em&gt;액세스 유형&lt;/em&gt; 의 함수이다 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets&quot;&gt;디스크립터 타입&lt;/a&gt; 사용 방법 또는 고정 기능 스테이지가 메모리를 액세스한다. 각 액세스 유형은 &lt;a href=&quot;#VkAccessFlagBits&quot;&gt;VkAccessFlagBits&lt;/a&gt; 의 비트 플래그에 해당 합니다.</target>
        </trans-unit>
        <trans-unit id="74e7bbd2e6d083718e31c1d69bd679284fff4db7" translate="yes" xml:space="preserve">
          <source>Memory is bound to &lt;code&gt;VkBuffer&lt;/code&gt; objects created with the &lt;code&gt;VK_BUFFER_CREATE_SPARSE_BINDING_BIT&lt;/code&gt; flag using the following structure:</source>
          <target state="translated">메모리는 다음 구조를 사용하여 &lt;code&gt;VK_BUFFER_CREATE_SPARSE_BINDING_BIT&lt;/code&gt; 플래그로 작성된 &lt;code&gt;VkBuffer&lt;/code&gt; 오브젝트에 바인드됩니다 .</target>
        </trans-unit>
        <trans-unit id="e55e44500b7e8d75dce7c9cf5be86d00e2541fa2" translate="yes" xml:space="preserve">
          <source>Memory is bound to opaque regions of &lt;code&gt;VkImage&lt;/code&gt; objects created with the &lt;code&gt;VK_IMAGE_CREATE_SPARSE_BINDING_BIT&lt;/code&gt; flag using the following structure:</source>
          <target state="translated">메모리는 다음 구조를 사용하여 &lt;code&gt;VK_IMAGE_CREATE_SPARSE_BINDING_BIT&lt;/code&gt; 플래그로 생성 된 &lt;code&gt;VkImage&lt;/code&gt; 객체 의 불투명 영역에 바인딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="39f516e96cf5dd8a70936206ff781f81265b1094" translate="yes" xml:space="preserve">
          <source>Memory objects are represented by &lt;code&gt;VkDeviceMemory&lt;/code&gt; handles:</source>
          <target state="translated">메모리 객체는 &lt;code&gt;VkDeviceMemory&lt;/code&gt; 핸들 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="6bcab1625fbddfba636187b4a8dcb0be1460eaf5" translate="yes" xml:space="preserve">
          <source>Memory types are ordered in the list such that X is assigned a lesser &lt;code&gt;memoryTypeIndex&lt;/code&gt; than Y if (X &amp;le; Y) &amp;and; &amp;not; (Y &amp;le; X) according to the preorder. Note that the list of all allowed memory property flag combinations above satisfies this preorder, but other orders would as well. The goal of this ordering is to enable applications to use a simple search loop in selecting the proper memory type, along the lines of:</source>
          <target state="translated">메모리 유형은 사전 주문에 따라 (X &amp;le; Y) &amp;and; &amp;not; (Y &amp;le; X) 인 경우 X에 Y보다 적은 &lt;code&gt;memoryTypeIndex&lt;/code&gt; 가 할당되도록 목록에서 정렬됩니다 . 위의 모든 허용 된 메모리 속성 플래그 조합 목록은이 프리오더를 만족하지만 다른 순서도 만족합니다. 이 순서의 목표는 응용 프로그램이 다음과 같은 행을 따라 적절한 메모리 유형을 선택할 때 간단한 검색 루프를 사용할 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a7b93d2128e820f861fc8dfccd9f5521e89ad21f" translate="yes" xml:space="preserve">
          <source>Mode</source>
          <target state="translated">Mode</target>
        </trans-unit>
        <trans-unit id="9fb598360964c636bfba410a029c41e6b74d6ad1" translate="yes" xml:space="preserve">
          <source>Most Vulkan commands operate on a single object, or there is a sole object that is being created or manipulated. When an allocation uses an allocation scope of &lt;code&gt;VK_SYSTEM_ALLOCATION_SCOPE_OBJECT&lt;/code&gt; or &lt;code&gt;VK_SYSTEM_ALLOCATION_SCOPE_CACHE&lt;/code&gt;, the allocation is scoped to the object being created or manipulated.</source>
          <target state="translated">대부분의 Vulkan 명령은 단일 개체에서 작동하거나 만들거나 조작하는 유일한 개체가 있습니다. 할당이 &lt;code&gt;VK_SYSTEM_ALLOCATION_SCOPE_OBJECT&lt;/code&gt; 또는 &lt;code&gt;VK_SYSTEM_ALLOCATION_SCOPE_CACHE&lt;/code&gt; 의 할당 범위를 사용하는 경우, 할당은 작성되거나 조작되는 오브젝트의 범위가됩니다.</target>
        </trans-unit>
        <trans-unit id="de2a91e902f73caf1a035d332dfb2473c3e864dc" translate="yes" xml:space="preserve">
          <source>Most Vulkan handle types, such as &lt;a href=&quot;#VkBuffer&quot;&gt;VkBuffer&lt;/a&gt;, are non-dispatchable.</source>
          <target state="translated">&lt;a href=&quot;#VkBuffer&quot;&gt;VkBuffer&lt;/a&gt; 와 같은 대부분의 Vulkan 핸들 유형 은 디스패치 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5ffd69dabb1b2e1c3dc54acbdbc711cd9064a869" translate="yes" xml:space="preserve">
          <source>Moving to the next subpass automatically performs any multisample resolve operations in the subpass being ended. End-of-subpass multisample resolves are treated as color attachment writes for the purposes of synchronization. That is, they are considered to execute in the &lt;code&gt;VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT&lt;/code&gt; pipeline stage and their writes are synchronized with &lt;code&gt;VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT&lt;/code&gt;. Synchronization between rendering within a subpass and any resolve operations at the end of the subpass occurs automatically, without need for explicit dependencies or pipeline barriers. However, if the resolve attachment is also used in a different subpass, an explicit dependency is needed.</source>
          <target state="translated">다음 서브 패스로 이동하면 종료되는 서브 패스에서 모든 멀티 샘플 확인 작업이 자동으로 수행됩니다. 서브 패스 통과 멀티 샘플 리졸 브는 동기화를 위해 컬러 부착 쓰기로 처리됩니다. 즉, &lt;code&gt;VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT&lt;/code&gt; 파이프 라인 단계 에서 실행되는 것으로 간주 되며 해당 쓰기는 &lt;code&gt;VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT&lt;/code&gt; 와 동기화됩니다 . 서브 패스 내 렌더링과 서브 패스 끝의 모든 해결 작업 간의 동기화는 명시적인 종속성이나 파이프 라인 장벽없이 자동으로 수행됩니다. 그러나 해결 첨부 파일이 다른 서브 패스에서도 사용되는 경우 명시 적 종속성이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="375f8fc6ea9ee0181fac651e1cd70252a35dca5b" translate="yes" xml:space="preserve">
          <source>Multiple aspects are returned for depth/stencil images that are implemented as separate planes by the implementation. The depth and stencil data planes each have unique &lt;code&gt;VkSparseImageFormatProperties&lt;/code&gt; data.</source>
          <target state="translated">구현에 의해 별도의 평면으로 구현되는 깊이 / 스텐실 이미지에 대해 여러 측면이 반환됩니다. 깊이 및 스텐실 데이터 평면에는 각각 고유 한 &lt;code&gt;VkSparseImageFormatProperties&lt;/code&gt; 데이터가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1957527a6f5f2b2cab857137e1f1ad146b105ee3" translate="yes" xml:space="preserve">
          <source>Multiple logical devices &lt;strong&gt;can&lt;/strong&gt; be created from the same physical device. Logical device creation &lt;strong&gt;may&lt;/strong&gt; fail due to lack of device-specific resources (in addition to the other errors). If that occurs, &lt;code&gt;vkCreateDevice&lt;/code&gt; will return &lt;code&gt;VK_ERROR_TOO_MANY_OBJECTS&lt;/code&gt;.</source>
          <target state="translated">동일한 물리적 장치에서 여러 논리 장치 &lt;strong&gt;를&lt;/strong&gt; 만들 &lt;strong&gt;수&lt;/strong&gt; 있습니다. 장치 별 리소스가 부족하여 (다른 오류 외에도) 논리적 장치 생성에 실패 &lt;strong&gt;할 수 있습니다&lt;/strong&gt; . 이 경우 &lt;code&gt;vkCreateDevice&lt;/code&gt; 는 VK_ERROR_TOO_MANY_OBJECTS 를 반환 &lt;code&gt;VK_ERROR_TOO_MANY_OBJECTS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08d2e98e6754af941484848930ccbaddfefe13d6" translate="yes" xml:space="preserve">
          <source>N/A</source>
          <target state="translated">N/A</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="edc73e41a0147fbaf61d930aeee9419e9909b970" translate="yes" xml:space="preserve">
          <source>No cross-references are available</source>
          <target state="translated">상호 참조가 없습니다</target>
        </trans-unit>
        <trans-unit id="4072aa7bf6f2ea46b2dc24ad89b9a74423c8b2d5" translate="yes" xml:space="preserve">
          <source>No format conversion is supported between depth/stencil images. The formats &lt;strong&gt;must&lt;/strong&gt; match.</source>
          <target state="translated">깊이 / 스텐실 이미지 간에는 형식 변환이 지원되지 않습니다. 형식 &lt;strong&gt;이&lt;/strong&gt; 일치 &lt;strong&gt;해야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="31d5650a41f96c9dfbc78cc8a8785c8c336b6319" translate="yes" xml:space="preserve">
          <source>No memory barriers are needed between &lt;code&gt;vkCmdClearAttachments&lt;/code&gt; and preceding or subsequent draw or attachment clear commands in the same subpass.</source>
          <target state="translated">&lt;code&gt;vkCmdClearAttachments&lt;/code&gt; 와 동일한 서브 패스에서 선행 또는 후속 그리기 또는 첨부 파일 지우기 명령 간에 메모리 장벽이 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="a71ee7b038fc978127bca3eb9d094ef88d1d3de3" translate="yes" xml:space="preserve">
          <source>Note that using a &lt;code&gt;maxLod&lt;/code&gt; of zero would cause &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#textures-texel-filtering&quot;&gt;magnification&lt;/a&gt; to always be performed, and the &lt;code&gt;magFilter&lt;/code&gt; to always be used. This is valid, just not an exact match for OpenGL behavior. Clamping the maximum LOD to 0.25 allows the &amp;lambda; value to be non-zero and minification to be performed, while still always rounding down to the base level. If the &lt;code&gt;minFilter&lt;/code&gt; and &lt;code&gt;magFilter&lt;/code&gt; are equal, then using a &lt;code&gt;maxLod&lt;/code&gt; of zero also works.</source>
          <target state="translated">사용합니다 &lt;code&gt;maxLod&lt;/code&gt; 를 제로로하는 원인이 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#textures-texel-filtering&quot;&gt;배율을&lt;/a&gt; 항상으로 수행 할 수 및 &lt;code&gt;magFilter&lt;/code&gt; 항상에 사용할 수. 이것은 유효하며 OpenGL 동작과 정확히 일치하지는 않습니다. 최대 LOD를 0.25로 클램핑하면 &amp;lambda; 값이 0이 아닌 축소가 수행되는 동시에 항상 기본 레벨로 내림됩니다. 는 IF &lt;code&gt;minFilter&lt;/code&gt; 및 &lt;code&gt;magFilter&lt;/code&gt; 가 동일, 다음 사용 &lt;code&gt;maxLod&lt;/code&gt; 제로도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c1dc45f2b802c8cb8e237b3e14cecc219666107" translate="yes" xml:space="preserve">
          <source>Note: Some implementations will default to shader state if this member does not match.</source>
          <target state="translated">참고 :이 멤버가 일치하지 않으면 일부 구현에서 기본적으로 셰이더 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="25b0c518c1db54503a1eda0c84458e75867bb5fa" translate="yes" xml:space="preserve">
          <source>Object Handles</source>
          <target state="translated">객체 핸들</target>
        </trans-unit>
        <trans-unit id="ce667716547fa82bc8795ad7ef205e9410193ed0" translate="yes" xml:space="preserve">
          <source>Offset</source>
          <target state="translated">Offset</target>
        </trans-unit>
        <trans-unit id="9d928d1908ece5763519358c1fd3c69933e1b4bf" translate="yes" xml:space="preserve">
          <source>Once a pipeline has been created, it &lt;strong&gt;can&lt;/strong&gt; be bound to the command buffer using the command:</source>
          <target state="translated">파이프 라인이 생성되면 다음 명령을 사용하여 명령 버퍼에 바인딩 할 &lt;strong&gt;수&lt;/strong&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a1208fdc5f4c6cb373dbd49c2d4e1842477ca9e" translate="yes" xml:space="preserve">
          <source>Once a query is ended the query &lt;strong&gt;must&lt;/strong&gt; finish in finite time, unless the state of the query is changed using other commands, e.g. by issuing a reset of the query.</source>
          <target state="translated">쿼리가 종료되면 다른 명령을 사용하여 (예 : 쿼리 재설정을 실행하여) 쿼리 상태가 변경되지 않는 한 쿼리 &lt;strong&gt;는&lt;/strong&gt; 유한 시간 내에 완료 &lt;strong&gt;되어야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="fff73ba35611844509e435e22a9813a71dbc2084" translate="yes" xml:space="preserve">
          <source>Once a shader module has been created, any entry points it contains &lt;strong&gt;can&lt;/strong&gt; be used in pipeline shader stages as described in &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#pipelines-compute&quot;&gt;Compute Pipelines&lt;/a&gt; and &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#pipelines-graphics&quot;&gt;Graphics Pipelines&lt;/a&gt;.</source>
          <target state="translated">셰이더 모듈을 만든 후에는 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#pipelines-compute&quot;&gt;계산 파이프 라인&lt;/a&gt; 및 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#pipelines-graphics&quot;&gt;그래픽 파이프 &lt;/a&gt;라인에 설명 된대로 포함 된 모든 진입 점 을 파이프 라인 셰이더 단계에서 사용할 &lt;strong&gt;수&lt;/strong&gt; 있습니다 .</target>
        </trans-unit>
        <trans-unit id="09186b594997f20c440e6c606b9ce19b5a68d0d9" translate="yes" xml:space="preserve">
          <source>Once allocated, descriptor sets &lt;strong&gt;can&lt;/strong&gt; be updated with a combination of write and copy operations. To update descriptor sets, call:</source>
          <target state="translated">할당 된 디스크립터 세트 &lt;strong&gt;는&lt;/strong&gt; 쓰기 및 복사 조작의 조합으로 업데이트 될 &lt;strong&gt;수&lt;/strong&gt; 있습니다. 디스크립터 세트를 업데이트하려면 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="a3ebfd88cd8fc0e9ef55b8c531fb6c472e792a53" translate="yes" xml:space="preserve">
          <source>Once bound, a descriptor set affects rendering of subsequent graphics or compute commands in the command buffer until a different set is bound to the same set number, or else until the set is disturbed as described in &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-compatibility&quot;&gt;Pipeline Layout Compatibility&lt;/a&gt;.</source>
          <target state="translated">바인드되면 디스크립터 세트는 다른 세트가 동일한 세트 번호에 바인드 될 때까지 또는 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-compatibility&quot;&gt;파이프 라인 레이아웃 호환성에&lt;/a&gt; 설명 된대로 세트가 방해 될 때까지 명령 버퍼에서 후속 그래픽 또는 계산 명령의 렌더링에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="847966dc1bdc1c6e8ab07e943882489732ba20cf" translate="yes" xml:space="preserve">
          <source>Once bound, a pipeline binding affects subsequent graphics or compute commands in the command buffer until a different pipeline is bound to the bind point. The pipeline bound to &lt;code&gt;VK_PIPELINE_BIND_POINT_COMPUTE&lt;/code&gt; controls the behavior of &lt;a href=&quot;#vkCmdDispatch&quot;&gt;vkCmdDispatch&lt;/a&gt; and &lt;a href=&quot;#vkCmdDispatchIndirect&quot;&gt;vkCmdDispatchIndirect&lt;/a&gt;. The pipeline bound to &lt;code&gt;VK_PIPELINE_BIND_POINT_GRAPHICS&lt;/code&gt; controls the behavior of &lt;a href=&quot;#vkCmdDraw&quot;&gt;vkCmdDraw&lt;/a&gt;, &lt;a href=&quot;#vkCmdDrawIndexed&quot;&gt;vkCmdDrawIndexed&lt;/a&gt;, &lt;a href=&quot;#vkCmdDrawIndirect&quot;&gt;vkCmdDrawIndirect&lt;/a&gt;, and &lt;a href=&quot;#vkCmdDrawIndexedIndirect&quot;&gt;vkCmdDrawIndexedIndirect&lt;/a&gt;. No other commands are affected by the pipeline state.</source>
          <target state="translated">바인드되면 파이프 라인 바인딩은 다른 파이프 라인이 바인드 지점에 바인드 될 때까지 명령 버퍼의 후속 그래픽 또는 계산 명령에 영향을줍니다. &lt;code&gt;VK_PIPELINE_BIND_POINT_COMPUTE&lt;/code&gt; 에 바인딩 된 파이프 라인 은 &lt;a href=&quot;#vkCmdDispatch&quot;&gt;vkCmdDispatch&lt;/a&gt; 및 &lt;a href=&quot;#vkCmdDispatchIndirect&quot;&gt;vkCmdDispatchIndirect&lt;/a&gt; 의 동작을 제어합니다 . &lt;code&gt;VK_PIPELINE_BIND_POINT_GRAPHICS&lt;/code&gt; 에 바인드 된 파이프 라인 은 &lt;a href=&quot;#vkCmdDraw&quot;&gt;vkCmdDraw&lt;/a&gt; , &lt;a href=&quot;#vkCmdDrawIndexed&quot;&gt;vkCmdDrawIndexed&lt;/a&gt; , &lt;a href=&quot;#vkCmdDrawIndirect&quot;&gt;vkCmdDrawIndirect&lt;/a&gt; 및 &lt;a href=&quot;#vkCmdDrawIndexedIndirect&quot;&gt;vkCmdDrawIndexedIndirect&lt;/a&gt; 의 동작을 제어합니다 . 다른 명령은 파이프 라인 상태의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4965c4b40c00711ccc4aba8a055d515228540865" translate="yes" xml:space="preserve">
          <source>Once created, a pipeline cache &lt;strong&gt;can&lt;/strong&gt; be passed to the &lt;code&gt;vkCreateGraphicsPipelines&lt;/code&gt; and &lt;code&gt;vkCreateComputePipelines&lt;/code&gt; commands. If the pipeline cache passed into these commands is not &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE&lt;/a&gt;, the implementation will query it for possible reuse opportunities and update it with new content. The use of the pipeline cache object in these commands is internally synchronized, and the same pipeline cache object &lt;strong&gt;can&lt;/strong&gt; be used in multiple threads simultaneously.</source>
          <target state="translated">파이프 라인 캐시 &lt;strong&gt;가&lt;/strong&gt; 생성되면 &lt;code&gt;vkCreateGraphicsPipelines&lt;/code&gt; 및 &lt;code&gt;vkCreateComputePipelines&lt;/code&gt; 명령 으로 전달 될 &lt;strong&gt;수&lt;/strong&gt; 있습니다 . 이러한 명령으로 전달 된 파이프 라인 캐시가 &lt;a href=&quot;#VK_NULL_HANDLE&quot;&gt;VK_NULL_HANDLE&lt;/a&gt; 이 아닌 경우 구현시 가능한 재사용 기회를 쿼리하여 새 컨텐츠로 업데이트합니다. 이러한 명령에서 파이프 라인 캐시 개체의 사용은 내부적으로 동기화되며 동일한 파이프 라인 캐시 개체 를 여러 스레드에서 동시에 사용할 &lt;strong&gt;수&lt;/strong&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ea5ba6c3e4f3c8706ba3083086e2c2921654543" translate="yes" xml:space="preserve">
          <source>Once the contents of an attachment become undefined in subpass &lt;strong&gt;S&lt;/strong&gt;, they remain undefined for subpasses in subpass dependency chains starting with subpass &lt;strong&gt;S&lt;/strong&gt; until they are written again. However, they remain valid for subpasses in other subpass dependency chains starting with subpass &lt;strong&gt;S&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt; if those subpasses use or preserve the attachment.</source>
          <target state="translated">서브 패스 &lt;strong&gt;S&lt;/strong&gt; 에서 첨부 파일의 내용이 정의되지 않은 경우 서브 패스 &lt;strong&gt;S로&lt;/strong&gt; 시작하는 서브 패스 종속성 체인의 서브 패스에 대해서는 다시 쓰여질 때까지 정의되지 않은 상태로 남아 있습니다 . 그러나 서브 패스가 첨부를 사용하거나 보존하는 경우 서브 패스 &lt;strong&gt;S &lt;sub&gt;1로&lt;/sub&gt;&lt;/strong&gt; 시작하는 다른 서브 패스 종속성 체인의 서브 패스에 대해서는 유효 합니다.</target>
        </trans-unit>
        <trans-unit id="fbd2d6f3d71e555a3df68816f77996beae4536c2" translate="yes" xml:space="preserve">
          <source>Once the orientation of triangles is determined, they are culled according to the &lt;a href=&quot;#VkPipelineRasterizationStateCreateInfo&quot;&gt;VkPipelineRasterizationStateCreateInfo&lt;/a&gt;::&lt;code&gt;cullMode&lt;/code&gt; property of the currently active pipeline. Possible values are:</source>
          <target state="translated">삼각형의 방향이 결정되면 현재 활성화 된 파이프 라인 의 &lt;a href=&quot;#VkPipelineRasterizationStateCreateInfo&quot;&gt;VkPipelineRasterizationStateCreateInfo&lt;/a&gt; :: &lt;code&gt;cullMode&lt;/code&gt; 속성에 따라 컬링됩니다 . 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="19e278dc971c80ae5679ac5fc2ed32eade32ae2d" translate="yes" xml:space="preserve">
          <source>Once the source and destination blend factors have been selected, they along with the source and destination components are passed to the blending operations. RGB and alpha components &lt;strong&gt;can&lt;/strong&gt; use different operations. Possible values of &lt;a href=&quot;#VkBlendOp&quot;&gt;VkBlendOp&lt;/a&gt;, specifying the operations, are:</source>
          <target state="translated">소스 및 대상 블렌드 팩터가 선택되면 소스 및 대상 구성 요소와 함께 블렌딩 작업으로 전달됩니다. RGB 및 알파 구성 요소 &lt;strong&gt;는&lt;/strong&gt; 다른 작업을 사용할 &lt;strong&gt;수&lt;/strong&gt; 있습니다. 조작을 지정하는 &lt;a href=&quot;#VkBlendOp&quot;&gt;VkBlendOp의&lt;/a&gt; 가능한 값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cdb181b1917416479c4abab65f39edb8bbdafa17" translate="yes" xml:space="preserve">
          <source>Only one of &lt;code&gt;pImageInfo&lt;/code&gt;, &lt;code&gt;pBufferInfo&lt;/code&gt;, or &lt;code&gt;pTexelBufferView&lt;/code&gt; members is used according to the descriptor type specified in the &lt;code&gt;descriptorType&lt;/code&gt; member of the containing &lt;code&gt;VkWriteDescriptorSet&lt;/code&gt; structure, as specified below.</source>
          <target state="translated">&lt;code&gt;pImageInfo&lt;/code&gt; , &lt;code&gt;pBufferInfo&lt;/code&gt; 또는 &lt;code&gt;pTexelBufferView&lt;/code&gt; 멤버 중 하나만 아래에 지정된 &lt;code&gt;VkWriteDescriptorSet&lt;/code&gt; 구조를 포함 하는 &lt;code&gt;descriptorType&lt;/code&gt; 멤버에 지정된 디스크립터 유형에 따라 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="430d32076eb256f0fb1db5fd1333254c368ef1ba" translate="yes" xml:space="preserve">
          <source>Operation</source>
          <target state="translated">Operation</target>
        </trans-unit>
        <trans-unit id="5003bfd94c3da2ddd802162c03d7700d6fbe5e7d" translate="yes" xml:space="preserve">
          <source>Otherwise an implementation will allocate memory through an alternative mechanism that is unspecified.</source>
          <target state="translated">그렇지 않으면 구현은 지정되지 않은 대체 메커니즘을 통해 메모리를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="4b490826635035295b80d1095244d3d154d5ba32" translate="yes" xml:space="preserve">
          <source>Otherwise, the counter is incremented by zero or more.</source>
          <target state="translated">그렇지 않으면 카운터가 0 이상 증가합니다.</target>
        </trans-unit>
        <trans-unit id="9df574100a2071d4e544e88390c44053b7b4fc93" translate="yes" xml:space="preserve">
          <source>Otherwise, the line width is set by calling &lt;code&gt;vkCmdSetLineWidth&lt;/code&gt;:</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;vkCmdSetLineWidth&lt;/code&gt; 를 호출하여 선 너비가 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="6071415d975ac5454c7882e8ba8d2ce7b3a385c1" translate="yes" xml:space="preserve">
          <source>Otherwise, to dynamically set and change the blend constant, call:</source>
          <target state="translated">그렇지 않으면, 블렌드 상수를 동적으로 설정하고 변경하려면 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="4a925b0f4f83525d4f42d82a3f2aa2d5ed2ae603" translate="yes" xml:space="preserve">
          <source>Out of memory errors do not damage any currently existing Vulkan objects. Objects that have already been successfully created &lt;strong&gt;can&lt;/strong&gt; still be used by the application.</source>
          <target state="translated">메모리 부족 오류는 현재 존재하는 Vulkan 객체를 손상시키지 않습니다. 이미 성공적으로 생성 된 개체 는 응용 프로그램에서 계속 사용할 &lt;strong&gt;수&lt;/strong&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="404b141df9bcae25c9956c2c2d089393661f836b" translate="yes" xml:space="preserve">
          <source>Out-of-bounds atomics &lt;strong&gt;may&lt;/strong&gt; modify values within the memory range(s) bound to the buffer, but &lt;strong&gt;must&lt;/strong&gt; not modify any other memory, and return an undefined value.</source>
          <target state="translated">범위를 벗어난 원자 &lt;strong&gt;는&lt;/strong&gt; 버퍼에 바인딩 된 메모리 범위 내의 값을 수정할 &lt;strong&gt;수&lt;/strong&gt; 있지만 다른 메모리를 수정 &lt;strong&gt;해서는&lt;/strong&gt; 안되며 정의되지 않은 값을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="d8876391b621655e779ba6e4af0e1bcf6a09ddc6" translate="yes" xml:space="preserve">
          <source>Out-of-bounds buffer loads will return any of the following values:</source>
          <target state="translated">범위를 벗어난 버퍼로드는 다음 값 중 하나를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="35c4eb67b67e136b99bae8c66e353bcc9499cfd1" translate="yes" xml:space="preserve">
          <source>Out-of-bounds writes &lt;strong&gt;may&lt;/strong&gt; modify values within the memory range(s) bound to the buffer, but &lt;strong&gt;must&lt;/strong&gt; not modify any other memory.</source>
          <target state="translated">범위를 벗어날 쓰기가 &lt;strong&gt;있습니다&lt;/strong&gt; 메모리 범위 버퍼에 바인딩 (들) 내에서 값을 수정할 수 있지만 &lt;strong&gt;있어야&lt;/strong&gt; 다른 메모리를 수정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b7efb76a74598f9f246f303d790fc5073191889d" translate="yes" xml:space="preserve">
          <source>Outside</source>
          <target state="translated">Outside</target>
        </trans-unit>
        <trans-unit id="98f005cca3748f1d422239557995a36c39f9750c" translate="yes" xml:space="preserve">
          <source>PFN_vkAllocationFunction - Application-defined memory allocation function</source>
          <target state="translated">PFN_vkAllocationFunction-응용 프로그램 정의 메모리 할당 함수</target>
        </trans-unit>
        <trans-unit id="cf99e588bfeb565e4ad2afb77a88fa6fbdd8d077" translate="yes" xml:space="preserve">
          <source>PFN_vkAllocationFunction(3)</source>
          <target state="translated">PFN_vkAllocationFunction(3)</target>
        </trans-unit>
        <trans-unit id="a96c98dbb5073e4075c5489c7a0e16679ca6fc02" translate="yes" xml:space="preserve">
          <source>PFN_vkFreeFunction - Application-defined memory free function</source>
          <target state="translated">PFN_vkFreeFunction-응용 프로그램 정의 메모리 여유 기능</target>
        </trans-unit>
        <trans-unit id="c223ad0cad2796c92fa438b14b325e78c8efa0f1" translate="yes" xml:space="preserve">
          <source>PFN_vkFreeFunction(3)</source>
          <target state="translated">PFN_vkFreeFunction(3)</target>
        </trans-unit>
        <trans-unit id="0dc17b74dddc957f332c25a9e302ca1ad2a82db5" translate="yes" xml:space="preserve">
          <source>PFN_vkInternalAllocationNotification - Application-defined memory allocation notification function</source>
          <target state="translated">PFN_vkInternalAllocationNotification-애플리케이션 정의 메모리 할당 알림 기능</target>
        </trans-unit>
        <trans-unit id="be173227812acd4badbec2a976d3aa7ffd67a366" translate="yes" xml:space="preserve">
          <source>PFN_vkInternalAllocationNotification(3)</source>
          <target state="translated">PFN_vkInternalAllocationNotification(3)</target>
        </trans-unit>
        <trans-unit id="0a833a79f8589e98cb93eb4e8243bed22f0103f0" translate="yes" xml:space="preserve">
          <source>PFN_vkInternalFreeNotification - Application-defined memory free notification function</source>
          <target state="translated">PFN_vkInternalFreeNotification-응용 프로그램 정의 메모리 여유 알림 기능</target>
        </trans-unit>
        <trans-unit id="b167cabb347cf03fe7f776eb6caed1cbb80222f5" translate="yes" xml:space="preserve">
          <source>PFN_vkInternalFreeNotification(3)</source>
          <target state="translated">PFN_vkInternalFreeNotification(3)</target>
        </trans-unit>
        <trans-unit id="3933bdd6b222083665e4f9258512b4a2d65e82e4" translate="yes" xml:space="preserve">
          <source>PFN_vkReallocationFunction - Application-defined memory reallocation function</source>
          <target state="translated">PFN_vkReallocationFunction-응용 프로그램 정의 메모리 재 할당 기능</target>
        </trans-unit>
        <trans-unit id="c4dcf233c2b3204f177d33e50ae7e818f3564a3c" translate="yes" xml:space="preserve">
          <source>PFN_vkReallocationFunction(3)</source>
          <target state="translated">PFN_vkReallocationFunction(3)</target>
        </trans-unit>
        <trans-unit id="c21d38d270b0abd492e0636618983996c7ce636c" translate="yes" xml:space="preserve">
          <source>PFN_vkVoidFunction - Dummy function pointer type returned by queries</source>
          <target state="translated">PFN_vkVoidFunction-쿼리에서 리턴 한 더미 함수 포인터 유형</target>
        </trans-unit>
        <trans-unit id="f881db55849ec572c6df800e7e9c3d68dcdb53fe" translate="yes" xml:space="preserve">
          <source>PFN_vkVoidFunction(3)</source>
          <target state="translated">PFN_vkVoidFunction(3)</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="c2dc50c9ba7624d2e0385fba982c4c65b155ad77" translate="yes" xml:space="preserve">
          <source>Performance-critical commands generally do not have return codes. If a run time error occurs in such commands, the implementation will defer reporting the error until a specified point. For commands that record into command buffers (&lt;code&gt;vkCmd*&lt;/code&gt;) run time errors are reported by &lt;code&gt;vkEndCommandBuffer&lt;/code&gt;.</source>
          <target state="translated">성능에 중요한 명령에는 일반적으로 리턴 코드가 없습니다. 이러한 명령에서 런타임 오류가 발생하면 구현시 지정된 지점까지 오류보고가 연기됩니다. 명령 버퍼 ( &lt;code&gt;vkCmd*&lt;/code&gt; )에 기록하는 명령의 경우 런타임 오류는 &lt;code&gt;vkEndCommandBuffer&lt;/code&gt; 에 의해보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="89d1eb1bb0ffac331d140d5ab0fb09530b43d2f6" translate="yes" xml:space="preserve">
          <source>Physical devices are represented by &lt;code&gt;VkPhysicalDevice&lt;/code&gt; handles:</source>
          <target state="translated">물리적 장치는 &lt;code&gt;VkPhysicalDevice&lt;/code&gt; 핸들 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="dcf6901798d7a92cc7c2fd7c970d73630d8a5707" translate="yes" xml:space="preserve">
          <source>Pipeline Type</source>
          <target state="translated">파이프 라인 유형</target>
        </trans-unit>
        <trans-unit id="736e52cb366c0485215c5ce5b04d323e5b685380" translate="yes" xml:space="preserve">
          <source>Pipeline cache objects &lt;strong&gt;can&lt;/strong&gt; be merged using the command:</source>
          <target state="translated">파이프 라인 캐시 오브젝트 &lt;strong&gt;는&lt;/strong&gt; 다음 명령을 사용하여 병합 &lt;strong&gt;할 수&lt;/strong&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="533d75593ccf045730391f172b61a9a4c82a7a4d" translate="yes" xml:space="preserve">
          <source>Pipeline cache objects allow the result of pipeline construction to be reused between pipelines and between runs of an application. Reuse between pipelines is achieved by passing the same pipeline cache object when creating multiple related pipelines. Reuse across runs of an application is achieved by retrieving pipeline cache contents in one run of an application, saving the contents, and using them to preinitialize a pipeline cache on a subsequent run. The contents of the pipeline cache objects are managed by the implementation. Applications &lt;strong&gt;can&lt;/strong&gt; manage the host memory consumed by a pipeline cache object and control the amount of data retrieved from a pipeline cache object.</source>
          <target state="translated">파이프 라인 캐시 개체를 사용하면 파이프 라인 구성 결과를 파이프 라인 간 및 응용 프로그램 실행간에 재사용 할 수 있습니다. 여러 관련 파이프 라인을 생성 할 때 동일한 파이프 라인 캐시 개체를 전달하여 파이프 라인 간 재사용이 가능합니다. 한 번의 애플리케이션 실행에서 파이프 라인 캐시 컨텐츠를 검색하고 컨텐츠를 저장 한 후이를 사용하여 후속 실행에서 파이프 라인 캐시를 사전 초기화하여 애플리케이션 실행 전체에서 재사용 할 수 있습니다. 파이프 라인 캐시 개체의 내용은 구현에 의해 관리됩니다. 애플리케이션 &lt;strong&gt;은&lt;/strong&gt; 파이프 라인 캐시 오브젝트가 소비하는 호스트 메모리를 관리하고 파이프 라인 캐시 오브젝트에서 검색되는 데이터의 양을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="751ae5b56ae15ee44718f40db7f933ce7a80a0f4" translate="yes" xml:space="preserve">
          <source>Pipeline cache objects are represented by &lt;code&gt;VkPipelineCache&lt;/code&gt; handles:</source>
          <target state="translated">파이프 라인 캐시 개체는 &lt;code&gt;VkPipelineCache&lt;/code&gt; 핸들 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="c94f9ab768f70b545f69ac3ebc7b291c1682b364" translate="yes" xml:space="preserve">
          <source>Pipeline layout objects are represented by &lt;code&gt;VkPipelineLayout&lt;/code&gt; handles:</source>
          <target state="translated">파이프 라인 레이아웃 객체는 &lt;code&gt;VkPipelineLayout&lt;/code&gt; 핸들 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="aa28ec835f4baaeef20fd0f5807c5bb12f0e3ba7" translate="yes" xml:space="preserve">
          <source>Possible values of &lt;a href=&quot;#VkAttachmentDescription&quot;&gt;VkAttachmentDescription&lt;/a&gt;::&lt;code&gt;loadOp&lt;/code&gt; and &lt;code&gt;stencilLoadOp&lt;/code&gt;, specifying how the contents of the attachment are treated, are:</source>
          <target state="translated">첨부 파일의 내용이 처리되는 방식을 지정하는 &lt;a href=&quot;#VkAttachmentDescription&quot;&gt;VkAttachmentDescription&lt;/a&gt; :: &lt;code&gt;loadOp&lt;/code&gt; 및 &lt;code&gt;stencilLoadOp&lt;/code&gt; 의 가능한 값은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="48e2175d98f8146cbbd1ccb29ea534d0f10836f1" translate="yes" xml:space="preserve">
          <source>Possible values of &lt;a href=&quot;#VkAttachmentDescription&quot;&gt;VkAttachmentDescription&lt;/a&gt;::&lt;code&gt;storeOp&lt;/code&gt; and &lt;code&gt;stencilStoreOp&lt;/code&gt;, specifying how the contents of the attachment are treated, are:</source>
          <target state="translated">첨부 파일의 내용을 처리하는 방법을 지정하는 &lt;a href=&quot;#VkAttachmentDescription&quot;&gt;VkAttachmentDescription&lt;/a&gt; :: &lt;code&gt;storeOp&lt;/code&gt; 및 &lt;code&gt;stencilStoreOp&lt;/code&gt; 의 가능한 값은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="872dba75ec83312d85258077f0407aba893ab1f7" translate="yes" xml:space="preserve">
          <source>Possible values of &lt;a href=&quot;#VkCommandBufferAllocateInfo&quot;&gt;VkCommandBufferAllocateInfo&lt;/a&gt;::&lt;code&gt;flags&lt;/code&gt;, specifying the command buffer level, are:</source>
          <target state="translated">명령 버퍼 레벨을 지정하는 &lt;a href=&quot;#VkCommandBufferAllocateInfo&quot;&gt;VkCommandBufferAllocateInfo&lt;/a&gt; :: &lt;code&gt;flags&lt;/code&gt; 의 가능한 값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="15d80b579dd6b29f9d09f2e4a542f4bee53c216b" translate="yes" xml:space="preserve">
          <source>Possible values of &lt;a href=&quot;#VkImageCreateInfo&quot;&gt;VkImageCreateInfo&lt;/a&gt;::&lt;code&gt;imageType&lt;/code&gt;, specifying the basic dimensionality of an image, are:</source>
          <target state="translated">이미지의 기본 차원을 지정하는 &lt;a href=&quot;#VkImageCreateInfo&quot;&gt;VkImageCreateInfo&lt;/a&gt; :: &lt;code&gt;imageType&lt;/code&gt; 의 가능한 값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e658478121399c9cee4d22776fdd24bbaad5f8dd" translate="yes" xml:space="preserve">
          <source>Possible values of &lt;a href=&quot;#VkImageCreateInfo&quot;&gt;VkImageCreateInfo&lt;/a&gt;::&lt;code&gt;tiling&lt;/code&gt;, specifying the tiling arrangement of data elements in an image, are:</source>
          <target state="translated">이미지에서 데이터 요소의 타일 배열을 지정하는 &lt;a href=&quot;#VkImageCreateInfo&quot;&gt;VkImageCreateInfo&lt;/a&gt; :: &lt;code&gt;tiling&lt;/code&gt; 의 가능한 값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3472adc60019ec88bdedc899b48d34302ffb427a" translate="yes" xml:space="preserve">
          <source>Possible values of &lt;a href=&quot;#VkQueryPoolCreateInfo&quot;&gt;VkQueryPoolCreateInfo&lt;/a&gt;::&lt;code&gt;queryType&lt;/code&gt;, specifying the type of queries managed by the pool, are:</source>
          <target state="translated">풀에서 관리하는 쿼리 유형을 지정하는 &lt;a href=&quot;#VkQueryPoolCreateInfo&quot;&gt;VkQueryPoolCreateInfo&lt;/a&gt; :: &lt;code&gt;queryType&lt;/code&gt; 의 가능한 값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="325dc7d4f369a127c6a18ddba1ceec92b4c7361c" translate="yes" xml:space="preserve">
          <source>Possible values of &lt;a href=&quot;#VkSamplerCreateInfo&quot;&gt;VkSamplerCreateInfo&lt;/a&gt;::&lt;code&gt;borderColor&lt;/code&gt;, specifying the border color used for texture lookups, are:</source>
          <target state="translated">텍스처 조회에 사용되는 테두리 색상을 지정하는 &lt;a href=&quot;#VkSamplerCreateInfo&quot;&gt;VkSamplerCreateInfo&lt;/a&gt; :: &lt;code&gt;borderColor&lt;/code&gt; 의 가능한 값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="67cf4b87b3d0ebae4dcb435fd2d6d4f1a069f4b9" translate="yes" xml:space="preserve">
          <source>Possible values of &lt;a href=&quot;#VkVertexInputBindingDescription&quot;&gt;VkVertexInputBindingDescription&lt;/a&gt;::&lt;code&gt;inputRate&lt;/code&gt;, specifying the rate at which vertex attributes are pulled from buffers, are:</source>
          <target state="translated">버퍼에서 정점 속성을 가져 오는 속도를 지정하는 &lt;a href=&quot;#VkVertexInputBindingDescription&quot;&gt;VkVertexInputBindingDescription&lt;/a&gt; :: &lt;code&gt;inputRate&lt;/code&gt; 의 가능한 값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0ce794c0d55efc3a17e309868ce7fe2076ed9af3" translate="yes" xml:space="preserve">
          <source>Possible values of &lt;a href=&quot;#vkCmdBeginRenderPass&quot;&gt;vkCmdBeginRenderPass&lt;/a&gt;::&lt;code&gt;contents&lt;/code&gt;, specifying how the commands in the first subpass will be provided, are:</source>
          <target state="translated">첫 번째 서브 패스의 명령이 제공되는 방법을 지정하는 &lt;a href=&quot;#vkCmdBeginRenderPass&quot;&gt;vkCmdBeginRenderPass&lt;/a&gt; :: &lt;code&gt;contents&lt;/code&gt; 의 가능한 값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="464de956a38bdfc6a97d76b20032cd5973274948" translate="yes" xml:space="preserve">
          <source>Possible values of &lt;a href=&quot;#vkCmdBindIndexBuffer&quot;&gt;vkCmdBindIndexBuffer&lt;/a&gt;::&lt;code&gt;indexType&lt;/code&gt;, specifying the size of indices, are:</source>
          <target state="translated">인덱스 크기를 지정하는 &lt;a href=&quot;#vkCmdBindIndexBuffer&quot;&gt;vkCmdBindIndexBuffer&lt;/a&gt; :: &lt;code&gt;indexType&lt;/code&gt; 의 가능한 값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="823e3f19189a88816b4274a732a6a554c432e8fa" translate="yes" xml:space="preserve">
          <source>Possible values of &lt;a href=&quot;#vkCmdBindPipeline&quot;&gt;vkCmdBindPipeline&lt;/a&gt;::&lt;code&gt;pipelineBindPoint&lt;/code&gt;, specifying the bind point of a pipeline object, are:</source>
          <target state="translated">파이프 라인 객체의 바인딩 지점을 지정하는 &lt;a href=&quot;#vkCmdBindPipeline&quot;&gt;vkCmdBindPipeline&lt;/a&gt; :: &lt;code&gt;pipelineBindPoint&lt;/code&gt; 의 가능한 값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="80870cec54d70e2b07c3137f824ea53ea0d00781" translate="yes" xml:space="preserve">
          <source>Possible values of &lt;code&gt;minImageTransferGranularity&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;minImageTransferGranularity&lt;/code&gt; 의 가능한 값은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e8ff2e2c8d74cc92b1471f53f25a99f62645770c" translate="yes" xml:space="preserve">
          <source>Possible values of VkStencilOpState::&lt;code&gt;compareOp&lt;/code&gt;, specifying the stencil comparison function, are:</source>
          <target state="translated">스텐실 비교 함수를 지정하는 VkStencilOpState :: &lt;code&gt;compareOp&lt;/code&gt; 의 가능한 값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="98208b8dbde05437fcf5398427669bfb3e1bdce2" translate="yes" xml:space="preserve">
          <source>Possible values of the &lt;a href=&quot;#VkPipelineRasterizationStateCreateInfo&quot;&gt;VkPipelineRasterizationStateCreateInfo&lt;/a&gt;::&lt;code&gt;polygonMode&lt;/code&gt; property of the currently active pipeline, specifying the method of rasterization for polygons, are:</source>
          <target state="translated">다각형에 대한 래스터 화 방법을 지정하여 현재 활성 파이프 라인 의 &lt;a href=&quot;#VkPipelineRasterizationStateCreateInfo&quot;&gt;VkPipelineRasterizationStateCreateInfo&lt;/a&gt; :: &lt;code&gt;polygonMode&lt;/code&gt; 속성의 가능한 값은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="90062fcf92a6566ebe8df3b9a5855285cf8c0ae0" translate="yes" xml:space="preserve">
          <source>Possible values of the &lt;a href=&quot;#VkSamplerCreateInfo&quot;&gt;VkSamplerCreateInfo&lt;/a&gt;::&lt;code&gt;addressMode&lt;/code&gt;* parameters, specifying the behavior of sampling with coordinates outside the range [0,1] for the respective u, v, or w coordinate as defined in the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#textures-wrapping-operation&quot;&gt;Wrapping Operation&lt;/a&gt; section, are:</source>
          <target state="translated">&lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#textures-wrapping-operation&quot;&gt;랩핑 조작&lt;/a&gt; 섹션에 정의 된대로 각각의 u, v 또는 w 좌표에 대해 [0,1] 범위를 벗어난 좌표로 샘플링 동작을 지정 하는 &lt;a href=&quot;#VkSamplerCreateInfo&quot;&gt;VkSamplerCreateInfo&lt;/a&gt; :: &lt;code&gt;addressMode&lt;/code&gt; * 매개 변수 의 가능한 값은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ffb26ba9fc0a5b9add232f85cd09cf3d9b9737c3" translate="yes" xml:space="preserve">
          <source>Possible values of the &lt;a href=&quot;#VkSamplerCreateInfo&quot;&gt;VkSamplerCreateInfo&lt;/a&gt;::&lt;code&gt;magFilter&lt;/code&gt; and &lt;code&gt;minFilter&lt;/code&gt; parameters, specifying filters used for texture lookups, are:</source>
          <target state="translated">텍스처 조회에 사용되는 필터를 지정 하는 &lt;a href=&quot;#VkSamplerCreateInfo&quot;&gt;VkSamplerCreateInfo&lt;/a&gt; :: &lt;code&gt;magFilter&lt;/code&gt; 및 &lt;code&gt;minFilter&lt;/code&gt; 매개 변수 의 가능한 값은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="519e9494c43a124109cd42ea56657536ec94fe18" translate="yes" xml:space="preserve">
          <source>Possible values of the &lt;a href=&quot;#VkSamplerCreateInfo&quot;&gt;VkSamplerCreateInfo&lt;/a&gt;::&lt;code&gt;mipmapMode&lt;/code&gt;, specifying the mipmap mode used for texture lookups, are:</source>
          <target state="translated">텍스처 조회에 사용되는 밉맵 모드를 지정 하는 &lt;a href=&quot;#VkSamplerCreateInfo&quot;&gt;VkSamplerCreateInfo&lt;/a&gt; :: &lt;code&gt;mipmapMode&lt;/code&gt; 의 가능한 값은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="20a01be1a06626e33b548f708e1af96f08c32dfb" translate="yes" xml:space="preserve">
          <source>Possible values of the &lt;code&gt;failOp&lt;/code&gt;, &lt;code&gt;passOp&lt;/code&gt;, and &lt;code&gt;depthFailOp&lt;/code&gt; members of &lt;a href=&quot;#VkStencilOpState&quot;&gt;VkStencilOpState&lt;/a&gt;, specifying what happens to the stored stencil value if this or certain subsequent tests fail or pass, are:</source>
          <target state="translated">의 가능한 값 &lt;code&gt;failOp&lt;/code&gt; , &lt;code&gt;passOp&lt;/code&gt; 및 &lt;code&gt;depthFailOp&lt;/code&gt; 의 회원 &lt;a href=&quot;#VkStencilOpState&quot;&gt;VkStencilOpState&lt;/a&gt; 이 또는 특정 후속 테스트가 실패하거나 패스, 경우 저장된 스텐실 값에 무슨 일 지정 :</target>
        </trans-unit>
        <trans-unit id="e901d9074d46f1041fd55dd4a04ce03fea167038" translate="yes" xml:space="preserve">
          <source>Possible values of the &lt;code&gt;flags&lt;/code&gt; member of &lt;a href=&quot;#VkGraphicsPipelineCreateInfo&quot;&gt;VkGraphicsPipelineCreateInfo&lt;/a&gt; and &lt;a href=&quot;#VkComputePipelineCreateInfo&quot;&gt;VkComputePipelineCreateInfo&lt;/a&gt;, specifying how a pipeline is created, are:</source>
          <target state="translated">파이프 라인 작성 방법을 지정하는 &lt;a href=&quot;#VkGraphicsPipelineCreateInfo&quot;&gt;VkGraphicsPipelineCreateInfo&lt;/a&gt; 및 &lt;a href=&quot;#VkComputePipelineCreateInfo&quot;&gt;VkComputePipelineCreateInfo&lt;/a&gt; 의 &lt;code&gt;flags&lt;/code&gt; 멤버의 가능한 값은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dabbf4a23c20846772bb2c3a8a1be6df779b1396" translate="yes" xml:space="preserve">
          <source>Possible values of the members of &lt;a href=&quot;#VkComponentMapping&quot;&gt;VkComponentMapping&lt;/a&gt;, specifying the component values placed in each component of the output vector, are:</source>
          <target state="translated">출력 벡터의 각 컴포넌트에 배치 된 컴포넌트 값을 지정하는 &lt;a href=&quot;#VkComponentMapping&quot;&gt;VkComponentMapping&lt;/a&gt; 멤버의 가능한 값은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8e97d3876c89c0193ae5aa1071665ab860982909" translate="yes" xml:space="preserve">
          <source>Possible values of the second group of four bytes in the header returned by &lt;a href=&quot;#vkGetPipelineCacheData&quot;&gt;vkGetPipelineCacheData&lt;/a&gt;, encoding the pipeline cache version, are:</source>
          <target state="translated">파이프 라인 캐시 버전을 인코딩하는 &lt;a href=&quot;#vkGetPipelineCacheData&quot;&gt;vkGetPipelineCacheData&lt;/a&gt; 에 의해 리턴 된 헤더에서 4 바이트의 두 번째 그룹의 가능한 값은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a9a96ec019494d5b8b041c1d2468061ae66e35d5" translate="yes" xml:space="preserve">
          <source>Primary</source>
          <target state="translated">Primary</target>
        </trans-unit>
        <trans-unit id="6494e5e67ef2e1017abc99786e54979d0531a8e9" translate="yes" xml:space="preserve">
          <source>Push constants represent a high speed path to modify constant data in pipelines that is expected to outperform memory-backed resource updates.</source>
          <target state="translated">푸시 상수는 메모리 기반 리소스 업데이트보다 성능이 우수한 파이프 라인의 상수 데이터를 수정하는 고속 경로를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e6932d084c70b708967c0a9ce888626651eed1c5" translate="yes" xml:space="preserve">
          <source>Queries are managed using &lt;em&gt;query pool&lt;/em&gt; objects. Each query pool is a collection of a specific number of queries of a particular type.</source>
          <target state="translated">쿼리는 &lt;em&gt;쿼리 풀&lt;/em&gt; 개체를 사용하여 관리 됩니다. 각 쿼리 풀은 특정 유형의 특정 수의 쿼리 모음입니다.</target>
        </trans-unit>
        <trans-unit id="405eac455e30ced015c459b7bd40e581c63c254c" translate="yes" xml:space="preserve">
          <source>Query pools are represented by &lt;code&gt;VkQueryPool&lt;/code&gt; handles:</source>
          <target state="translated">쿼리 풀은 &lt;code&gt;VkQueryPool&lt;/code&gt; 핸들 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="42f1973dc7dedafa2dad2b6b3beddd4e6d4d91cd" translate="yes" xml:space="preserve">
          <source>Queues are represented by &lt;code&gt;VkQueue&lt;/code&gt; handles:</source>
          <target state="translated">큐는 &lt;code&gt;VkQueue&lt;/code&gt; 핸들 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="a2023e982b3996bdcebed6e8b177c4fae57b60f1" translate="yes" xml:space="preserve">
          <source>Queues supporting graphics and/or compute operations &lt;strong&gt;must&lt;/strong&gt; report (1,1,1) in &lt;code&gt;minImageTransferGranularity&lt;/code&gt;, meaning that there are no additional restrictions on the granularity of image transfer operations for these queues. Other queues supporting image transfer operations are only &lt;strong&gt;required&lt;/strong&gt; to support whole mip level transfers, thus &lt;code&gt;minImageTransferGranularity&lt;/code&gt; for queues belonging to such queue families &lt;strong&gt;may&lt;/strong&gt; be (0,0,0).</source>
          <target state="translated">그래픽 및 / 또는 컴퓨팅 작업을 지원하는 큐 는 &lt;code&gt;minImageTransferGranularity&lt;/code&gt; 로 (1,1,1)을보고 &lt;strong&gt;해야합니다&lt;/strong&gt; . 즉,이 큐에 대한 이미지 전송 작업의 세분성에 대한 추가 제한이 없습니다. 이미지 전송 작업을 지원하는 다른 큐는 전체 밉 수준 전송을 지원하기 위해서만 &lt;strong&gt;필요&lt;/strong&gt; 하므로 이러한 큐 패밀리에 속하는 큐의 &lt;code&gt;minImageTransferGranularity&lt;/code&gt; 는 (0,0,0) &lt;strong&gt;일 수&lt;/strong&gt; 있습니다.&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b79e00f9362238b2b786fd62ee2d68330a74f5aa" translate="yes" xml:space="preserve">
          <source>R = R&lt;sub&gt;d&lt;/sub&gt; &amp;times; D&lt;sub&gt;r&lt;/sub&gt; - R&lt;sub&gt;s0&lt;/sub&gt; &amp;times; S&lt;sub&gt;r&lt;/sub&gt;</source>
          <target state="translated">R = R &lt;sub&gt;d&lt;/sub&gt; &amp;times; D &lt;sub&gt;r&lt;/sub&gt; -R &lt;sub&gt;s0&lt;/sub&gt; &amp;times; S &lt;sub&gt;r&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="5d72bde2bb2027522eff90ff13a01dc700d82dc0" translate="yes" xml:space="preserve">
          <source>R = R&lt;sub&gt;s0&lt;/sub&gt; &amp;times; S&lt;sub&gt;r&lt;/sub&gt; + R&lt;sub&gt;d&lt;/sub&gt; &amp;times; D&lt;sub&gt;r&lt;/sub&gt;</source>
          <target state="translated">R = R &lt;sub&gt;s0&lt;/sub&gt; &amp;times; S &lt;sub&gt;r&lt;/sub&gt; + R &lt;sub&gt;d&lt;/sub&gt; &amp;times; D &lt;sub&gt;r&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="541ddae78f9326fae191c0813c30a03451658fd3" translate="yes" xml:space="preserve">
          <source>R = R&lt;sub&gt;s0&lt;/sub&gt; &amp;times; S&lt;sub&gt;r&lt;/sub&gt; - R&lt;sub&gt;d&lt;/sub&gt; &amp;times; D&lt;sub&gt;r&lt;/sub&gt;</source>
          <target state="translated">R = R &lt;sub&gt;s0&lt;/sub&gt; &amp;times; S &lt;sub&gt;r&lt;/sub&gt; -R &lt;sub&gt;d&lt;/sub&gt; &amp;times; D &lt;sub&gt;r&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="903b87da3367a87b4418488f7c352f5512c9ab51" translate="yes" xml:space="preserve">
          <source>R = max(R&lt;sub&gt;s0&lt;/sub&gt;,R&lt;sub&gt;d&lt;/sub&gt;)</source>
          <target state="translated">R = 최대 (R &lt;sub&gt;s0&lt;/sub&gt; , R &lt;sub&gt;d&lt;/sub&gt; )</target>
        </trans-unit>
        <trans-unit id="30f6402df32410d0245d87d08ea9fd2d5e27d538" translate="yes" xml:space="preserve">
          <source>R = min(R&lt;sub&gt;s0&lt;/sub&gt;,R&lt;sub&gt;d&lt;/sub&gt;)</source>
          <target state="translated">R = 최소 (R &lt;sub&gt;s0&lt;/sub&gt; , R &lt;sub&gt;d&lt;/sub&gt; )</target>
        </trans-unit>
        <trans-unit id="41093711e07a6a995d19ad0de7c1c812aa975ae9" translate="yes" xml:space="preserve">
          <source>R&lt;sub&gt;c&lt;/sub&gt;,G&lt;sub&gt;c&lt;/sub&gt;,B&lt;sub&gt;c&lt;/sub&gt; and A&lt;sub&gt;c&lt;/sub&gt; represent the blend constant R, G, B, and A components, respectively.</source>
          <target state="translated">R &lt;sub&gt;c&lt;/sub&gt; , G &lt;sub&gt;c&lt;/sub&gt; , B &lt;sub&gt;c&lt;/sub&gt; 및 A &lt;sub&gt;c&lt;/sub&gt; 는 각각 블렌드 상수 R, G, B 및 A 성분을 나타낸다.</target>
        </trans-unit>
        <trans-unit id="dcb36067343b917d6a26a4a272e4095a400971f2" translate="yes" xml:space="preserve">
          <source>R&lt;sub&gt;d&lt;/sub&gt;, G&lt;sub&gt;d&lt;/sub&gt;, B&lt;sub&gt;d&lt;/sub&gt; and A&lt;sub&gt;d&lt;/sub&gt; represent the R, G, B, and A components of the destination color. That is, the color currently in the corresponding color attachment for this fragment/sample.</source>
          <target state="translated">R &lt;sub&gt;d&lt;/sub&gt; , G &lt;sub&gt;d&lt;/sub&gt; , B &lt;sub&gt;d&lt;/sub&gt; 및 A &lt;sub&gt;d&lt;/sub&gt; 는 대상 색의 R, G, B 및 A 구성 요소를 나타냅니다. 즉, 현재이 조각 / 샘플에 해당하는 색상 첨부 파일에있는 색상입니다.</target>
        </trans-unit>
        <trans-unit id="6bc6a07cd4772de29ef4220bac4e62cdcfd2db80" translate="yes" xml:space="preserve">
          <source>R&lt;sub&gt;d&lt;/sub&gt;,G&lt;sub&gt;d&lt;/sub&gt;,B&lt;sub&gt;d&lt;/sub&gt; and A&lt;sub&gt;d&lt;/sub&gt; represent the R, G, B, and A components of the destination color. That is, the color currently in the corresponding color attachment for this fragment/sample.</source>
          <target state="translated">R &lt;sub&gt;d&lt;/sub&gt; , G &lt;sub&gt;d&lt;/sub&gt; , B &lt;sub&gt;d&lt;/sub&gt; 및 A &lt;sub&gt;d&lt;/sub&gt; 는 목적 색의 R, G, B 및 A 성분을 나타낸다. 즉, 현재이 조각 / 샘플에 해당하는 색상 첨부 파일에있는 색상입니다.</target>
        </trans-unit>
        <trans-unit id="6055fd0ae08f2f92ad8f15578c98a87ac6104d8e" translate="yes" xml:space="preserve">
          <source>R&lt;sub&gt;s0&lt;/sub&gt;, G&lt;sub&gt;s0&lt;/sub&gt;, B&lt;sub&gt;s0&lt;/sub&gt; and A&lt;sub&gt;s0&lt;/sub&gt; represent the first source color R, G, B, and A components, respectively.</source>
          <target state="translated">R &lt;sub&gt;s0&lt;/sub&gt; , G &lt;sub&gt;s0&lt;/sub&gt; , B &lt;sub&gt;s0&lt;/sub&gt; 및 A &lt;sub&gt;s0&lt;/sub&gt; 은 각각 제 1 소스 컬러 R, G, B 및 A 성분을 나타낸다.</target>
        </trans-unit>
        <trans-unit id="9eb2dffc9a63ae4cadfc67e309e845ca3139cdde" translate="yes" xml:space="preserve">
          <source>R&lt;sub&gt;s0&lt;/sub&gt;,G&lt;sub&gt;s0&lt;/sub&gt;,B&lt;sub&gt;s0&lt;/sub&gt; and A&lt;sub&gt;s0&lt;/sub&gt; represent the first source color R, G, B, and A components, respectively, for the fragment output location corresponding to the color attachment being blended.</source>
          <target state="translated">R &lt;sub&gt;s0&lt;/sub&gt; , G &lt;sub&gt;s0&lt;/sub&gt; , B &lt;sub&gt;s0&lt;/sub&gt; 및 A &lt;sub&gt;s0&lt;/sub&gt; 은 블렌딩되는 컬러 어태치먼트에 대응하는 프래그먼트 출력 위치에 대한 제 1 소스 컬러 R, G, B 및 A 성분을 각각 나타낸다.</target>
        </trans-unit>
        <trans-unit id="7bd987507e4810feb58da0028a40db64b3f86c61" translate="yes" xml:space="preserve">
          <source>R&lt;sub&gt;s1&lt;/sub&gt;,G&lt;sub&gt;s1&lt;/sub&gt;,B&lt;sub&gt;s1&lt;/sub&gt; and A&lt;sub&gt;s1&lt;/sub&gt; represent the second source color R, G, B, and A components, respectively, used in dual source blending modes, for the fragment output location corresponding to the color attachment being blended.</source>
          <target state="translated">R &lt;sub&gt;s1&lt;/sub&gt; , G &lt;sub&gt;s1&lt;/sub&gt; , B &lt;sub&gt;s1&lt;/sub&gt; 및 A &lt;sub&gt;s1&lt;/sub&gt; 은 블렌딩되는 컬러 어태치먼트에 대응하는 프래그먼트 출력 위치에 대한 이중 소스 블렌딩 모드에서 사용되는 제 2 소스 컬러 R, G, B 및 A 성분을 각각 나타낸다.</target>
        </trans-unit>
        <trans-unit id="32b12811dec521407d505d082316c80efec8882d" translate="yes" xml:space="preserve">
          <source>RGB Blend Factors (S&lt;sub&gt;r&lt;/sub&gt;,S&lt;sub&gt;g&lt;/sub&gt;,S&lt;sub&gt;b&lt;/sub&gt;) or (D&lt;sub&gt;r&lt;/sub&gt;,D&lt;sub&gt;g&lt;/sub&gt;,D&lt;sub&gt;b&lt;/sub&gt;)</source>
          <target state="translated">RGB 혼합 계수 (S &lt;sub&gt;r&lt;/sub&gt; , S &lt;sub&gt;g&lt;/sub&gt; , S &lt;sub&gt;b&lt;/sub&gt; ) 또는 (D &lt;sub&gt;r&lt;/sub&gt; , D &lt;sub&gt;g&lt;/sub&gt; , D &lt;sub&gt;b&lt;/sub&gt; )</target>
        </trans-unit>
        <trans-unit id="370cad40414ecb914eb5de3cebbd4a023f87d88c" translate="yes" xml:space="preserve">
          <source>RGB Components</source>
          <target state="translated">RGB 구성 요소</target>
        </trans-unit>
        <trans-unit id="5fdc6a02fc8d3e3a68fd0a8279ebcaba5c6b825f" translate="yes" xml:space="preserve">
          <source>Ranges of buffers and image subresources of image objects created using &lt;code&gt;VK_SHARING_MODE_CONCURRENT&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; only be accessed by queues from the queue families specified through the &lt;code&gt;queueFamilyIndexCount&lt;/code&gt; and &lt;code&gt;pQueueFamilyIndices&lt;/code&gt; members of the corresponding create info structures.</source>
          <target state="translated">&lt;code&gt;VK_SHARING_MODE_CONCURRENT&lt;/code&gt; &lt;strong&gt;를&lt;/strong&gt; 사용하여 작성된 이미지 오브젝트의 버퍼 범위 및 이미지 서브 리소스 &lt;strong&gt;는&lt;/strong&gt; 해당 작성 정보 구조 의 &lt;code&gt;queueFamilyIndexCount&lt;/code&gt; 및 &lt;code&gt;pQueueFamilyIndices&lt;/code&gt; 멤버를 통해 지정된 큐 제품군의 큐에서만 액세스 &lt;strong&gt;해야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="46d1764eb2bce7a26ef267ad99994d7581714f9f" translate="yes" xml:space="preserve">
          <source>Ranges of buffers and image subresources of image objects created using &lt;code&gt;VK_SHARING_MODE_EXCLUSIVE&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; only be accessed by queues in the same queue family at any given time. In order for a different queue family to be able to interpret the memory contents of a range or image subresource, the application &lt;strong&gt;must&lt;/strong&gt; perform a &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-queue-transfers&quot;&gt;queue family ownership transfer&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;VK_SHARING_MODE_EXCLUSIVE&lt;/code&gt; &lt;strong&gt;를&lt;/strong&gt; 사용하여 생성 된 이미지 객체의 버퍼 범위 및 이미지 하위 리소스 &lt;strong&gt;는&lt;/strong&gt; 주어진 시간에 동일한 큐 제품군의 큐에서만 액세스 &lt;strong&gt;해야합니다&lt;/strong&gt; . 다른 큐 제품군이 범위 또는 이미지 서브 리소스의 메모리 컨텐츠를 해석 할 수 있으려면 애플리케이션 이 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-queue-transfers&quot;&gt;큐 제품군 소유권 전송을&lt;/a&gt; 수행 &lt;strong&gt;해야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="bb55598a799c6dc14ac6f5511a072f986028960b" translate="yes" xml:space="preserve">
          <source>Rectangles are used to describe a specified rectangular region of pixels within an image or framebuffer. Rectangles include both an offset and an extent of the same dimensionality, as described above. Two-dimensional rectangles are defined by the structure</source>
          <target state="translated">사각형은 이미지 나 프레임 버퍼 내에서 픽셀의 지정된 사각형 영역을 설명하는 데 사용됩니다. 직사각형은 전술 한 바와 같이 오프셋과 동일한 차원의 범위를 모두 포함한다. 2 차원 사각형은 구조에 의해 정의됩니다</target>
        </trans-unit>
        <trans-unit id="f16748ad587919cfdb51f89929df3bfe53c3caa4" translate="yes" xml:space="preserve">
          <source>Render Pass Scope</source>
          <target state="translated">렌더 패스 범위</target>
        </trans-unit>
        <trans-unit id="b0052913cd9a63d50436b184181efe571d9edb20" translate="yes" xml:space="preserve">
          <source>Render passes are represented by &lt;code&gt;VkRenderPass&lt;/code&gt; handles:</source>
          <target state="translated">렌더 패스는 &lt;code&gt;VkRenderPass&lt;/code&gt; 핸들 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="6321a081af4e30de7dc33639cde2f200dd4fed52" translate="yes" xml:space="preserve">
          <source>Render passes operate in conjunction with &lt;em&gt;framebuffers&lt;/em&gt;. Framebuffers represent a collection of specific memory attachments that a render pass instance uses.</source>
          <target state="translated">렌더 패스는 &lt;em&gt;프레임 버퍼&lt;/em&gt; 와 함께 작동합니다 . 프레임 버퍼는 렌더 패스 인스턴스가 사용하는 특정 메모리 첨부 파일 모음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a751ea66f504c0018d8354be8014ccbb188e73b5" translate="yes" xml:space="preserve">
          <source>Resetting a command pool recycles all of the resources from all of the command buffers allocated from the command pool back to the command pool. All command buffers that have been allocated from the command pool are put in the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;initial state&lt;/a&gt;.</source>
          <target state="translated">명령 풀을 재설정하면 명령 풀에서 할당 된 모든 명령 버퍼에서 명령 풀로 모든 자원이 재활용됩니다. 명령 풀에서 할당 된 모든 명령 버퍼는 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;초기 상태가&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="0a3d85c63500389439de4ffe980966faf0012c83" translate="yes" xml:space="preserve">
          <source>Resetting a descriptor pool recycles all of the resources from all of the descriptor sets allocated from the descriptor pool back to the descriptor pool, and the descriptor sets are implicitly freed.</source>
          <target state="translated">디스크립터 풀을 재설정하면 디스크립터 풀에서 디스크립터 풀로 다시 할당 된 모든 디스크립터 세트의 모든 자원이 재활용되고 디스크립터 세트가 내재적으로 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="f26e4ddcd779e0ff1d608fbc41a8e53dd1eb3909" translate="yes" xml:space="preserve">
          <source>Resolves are done layer by layer starting with &lt;code&gt;baseArrayLayer&lt;/code&gt; member of &lt;code&gt;srcSubresource&lt;/code&gt; for the source and &lt;code&gt;dstSubresource&lt;/code&gt; for the destination. &lt;code&gt;layerCount&lt;/code&gt; layers are resolved to the destination image.</source>
          <target state="translated">해결로 시작 층층이 완료 &lt;code&gt;baseArrayLayer&lt;/code&gt; 의 멤버 &lt;code&gt;srcSubresource&lt;/code&gt; 소스 및 대 &lt;code&gt;dstSubresource&lt;/code&gt; 행선지. &lt;code&gt;layerCount&lt;/code&gt; 레이어는 대상 이미지로 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="e031e223512bf43c9a34b7730c010ea3489679d5" translate="yes" xml:space="preserve">
          <source>Restarting the assembly of primitives discards the most recent index values if those elements formed an incomplete primitive, and restarts the primitive assembly using the subsequent indices, but only assembling the immediately following element through the end of the originally specified elements. The primitive restart index value comparison is performed before adding the &lt;code&gt;vertexOffset&lt;/code&gt; value to the index value.</source>
          <target state="translated">프리미티브 어셈블리를 다시 시작하면 해당 요소가 불완전한 프리미티브를 형성 한 경우 가장 최근의 색인 값을 버리고 후속 색인을 사용하여 기본 어셈블리를 다시 시작하지만 원래 지정된 요소의 끝을 통해 바로 다음 요소 만 조립합니다. 기본 재시작 인덱스 값 비교는 &lt;code&gt;vertexOffset&lt;/code&gt; 값을 인덱스 값에 추가하기 전에 수행 됩니다.</target>
        </trans-unit>
        <trans-unit id="2990d745269c93c4307be5199105ba4db52fb4f8" translate="yes" xml:space="preserve">
          <source>Return Codes</source>
          <target state="translated">리턴 코드</target>
        </trans-unit>
        <trans-unit id="03087aeb540494affd09664d2dd5c836a9e1eebd" translate="yes" xml:space="preserve">
          <source>Run time error codes are returned when a command needs to communicate a failure that could only be detected at run time. All run time error codes are negative values.</source>
          <target state="translated">런타임 오류 코드는 명령이 런타임에만 감지 될 수있는 실패를 통신해야 할 때 리턴됩니다. 모든 런타임 오류 코드는 음수 값입니다.</target>
        </trans-unit>
        <trans-unit id="82718830066416e1e4d6604e30d026b103c6d77c" translate="yes" xml:space="preserve">
          <source>S&lt;sub&gt;r&lt;/sub&gt;, S&lt;sub&gt;g&lt;/sub&gt;, S&lt;sub&gt;b&lt;/sub&gt; and S&lt;sub&gt;a&lt;/sub&gt; represent the source blend factor R, G, B, and A components, respectively.</source>
          <target state="translated">S &lt;sub&gt;r&lt;/sub&gt; , S &lt;sub&gt;g&lt;/sub&gt; , S &lt;sub&gt;b&lt;/sub&gt; 및 S &lt;sub&gt;a&lt;/sub&gt; 는 각각 소스 혼합 계수 R, G, B 및 A 성분을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5e7bef6429a6c8fdf454fdc90380e3ad5a3e7f32" translate="yes" xml:space="preserve">
          <source>SPARSE_BINDING</source>
          <target state="translated">SPARSE_BINDING</target>
        </trans-unit>
        <trans-unit id="ba32a67865588081b30edc5d0fa29932fa917d6c" translate="yes" xml:space="preserve">
          <source>Samplers are represented by &lt;code&gt;VkSampler&lt;/code&gt; handles:</source>
          <target state="translated">샘플러는 &lt;code&gt;VkSampler&lt;/code&gt; 핸들 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="2393e5ca7e23d4e6b269ecc8ac08cf4d08845bda" translate="yes" xml:space="preserve">
          <source>Satisfying this guarantee &lt;strong&gt;may&lt;/strong&gt; require careful ordering by the application, e.g. to read the availability status before reading the results.</source>
          <target state="translated">이 보증을 충족 시키려면 응용 프로그램에서 결과를 읽기 전에 가용성 상태를 읽는 등 신중한 순서 &lt;strong&gt;가&lt;/strong&gt; 필요할 &lt;strong&gt;수 있습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="025de599ea0a6262eeb4ea073413e273d0ea875b" translate="yes" xml:space="preserve">
          <source>Secondary</source>
          <target state="translated">Secondary</target>
        </trans-unit>
        <trans-unit id="2fd635ab66f97d4369ec3a93b2e97e7238594654" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#sparsememory-sparseresourcefeatures&quot;&gt;Sparse Resource Features&lt;/a&gt; and &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features&quot;&gt;Physical Device Features&lt;/a&gt; for details of the sparse memory features supported on a device.</source>
          <target state="translated">참조 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#sparsememory-sparseresourcefeatures&quot;&gt;희소 자원 특징&lt;/a&gt; 및 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-features&quot;&gt;물리적 장치 기능&lt;/a&gt; 장치에서 지원되는 기능 스파 스 메모리의 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="b6cfb646b30502aa6034a94081097b066feae135" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#sparsememory-sparseresourcefeatures&quot;&gt;Sparse Resource Features&lt;/a&gt; and &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#sparsememory-physicalfeatures&quot;&gt;Sparse Physical Device Features&lt;/a&gt; for more details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#sparsememory-sparseresourcefeatures&quot;&gt;스파 스 리소스 기능&lt;/a&gt; 및 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#sparsememory-physicalfeatures&quot;&gt;스파 스 물리적 장치 기능&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="67373bb92cd7ecbf243edb9d60ad6f00f86a6052" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">또한보십시오</target>
        </trans-unit>
        <trans-unit id="b6f5fac8b9a508b0a07b8b3c614feaca73f97698" translate="yes" xml:space="preserve">
          <source>Semaphores are a synchronization primitive that &lt;strong&gt;can&lt;/strong&gt; be used to insert a dependency between batches submitted to queues. Semaphores have two states - signaled and unsignaled. The state of a semaphore &lt;strong&gt;can&lt;/strong&gt; be signaled after execution of a batch of commands is completed. A batch &lt;strong&gt;can&lt;/strong&gt; wait for a semaphore to become signaled before it begins execution, and the semaphore is also unsignaled before the batch begins execution.</source>
          <target state="translated">세마포어는 큐에 제출 된 배치간에 종속성을 삽입하는 데 사용할 &lt;strong&gt;수&lt;/strong&gt; 있는 동기화 기본 요소입니다 . 세마포어에는 신호와 비 신호의 두 가지 상태가 있습니다. 일련의 명령 실행이 완료된 후 세마포어의 상태를 알릴 &lt;strong&gt;수&lt;/strong&gt; 있습니다. 배치 &lt;strong&gt;는&lt;/strong&gt; 세마포어가 실행을 시작하기 전에 신호를 보내기를 기다릴 &lt;strong&gt;수 있으며&lt;/strong&gt; , 배치가 실행을 시작하기 전에 세마포어도 신호를받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="efe35ecb9d649ab5ed42f6929c922bbe3a40f48e" translate="yes" xml:space="preserve">
          <source>Semaphores are represented by &lt;code&gt;VkSemaphore&lt;/code&gt; handles:</source>
          <target state="translated">세마포어는 &lt;code&gt;VkSemaphore&lt;/code&gt; 핸들 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="c3af2061e3e115110eb69727aba2fb4f4f00b1ea" translate="yes" xml:space="preserve">
          <source>Setting the identity swizzle on a component is equivalent to setting the identity mapping on that component. That is:</source>
          <target state="translated">구성 요소에 아이디 스위 즐을 설정하는 것은 해당 구성 요소에 아이디 매핑을 설정하는 것과 같습니다. 그건:</target>
        </trans-unit>
        <trans-unit id="3a3b7ecf447ba8b681f779eae2a065ba1ef8b498" translate="yes" xml:space="preserve">
          <source>Several of the synchronization commands include pipeline stage parameters, restricting the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-scopes&quot;&gt;synchronization scopes&lt;/a&gt; for that command to just those stages. This allows fine grained control over the exact execution dependencies and accesses performed by action commands. Implementations &lt;strong&gt;should&lt;/strong&gt; use these pipeline stages to avoid unnecessary stalls or cache flushing.</source>
          <target state="translated">여러 동기화 명령에는 파이프 라인 단계 매개 변수가 포함 되어있어 해당 명령 의 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-scopes&quot;&gt;동기화 범위&lt;/a&gt; 를 해당 단계로 제한합니다 . 이를 통해 조치 명령으로 수행되는 정확한 실행 종속성 및 액세스를 세밀하게 제어 할 수 있습니다. 구현 &lt;strong&gt;해야&lt;/strong&gt; 불필요한 포장 마차 나 캐시 홍조를 예방하려면 파이프 라인 단계를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d30c200a960bfb05ea60fc1803b313155597c1b2" translate="yes" xml:space="preserve">
          <source>Shader modules are represented by &lt;code&gt;VkShaderModule&lt;/code&gt; handles:</source>
          <target state="translated">셰이더 모듈은 &lt;code&gt;VkShaderModule&lt;/code&gt; 핸들 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="1dea6d0ea1c073deb15edd9efa11a7e7fbe3f60b" translate="yes" xml:space="preserve">
          <source>Signed and unsigned integers are converted by first clamping to the representable range of the destination format, then casting the value.</source>
          <target state="translated">부호있는 정수와 부호없는 정수는 먼저 대상 형식의 표현 가능한 범위로 클램핑 한 다음 값을 캐스팅하여 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="4aee7a097d1f9d034d85844a5d1c09cf73419867" translate="yes" xml:space="preserve">
          <source>Similarly, if &lt;code&gt;VK_QUERY_RESULT_WITH_AVAILABILITY_BIT&lt;/code&gt; is set and &lt;code&gt;VK_QUERY_RESULT_WAIT_BIT&lt;/code&gt; is not set, the availability is guaranteed to reflect the most recent use of the query on the same queue, assuming that the query is not being simultaneously used by other queues. As with &lt;code&gt;vkGetQueryPoolResults&lt;/code&gt;, implementations &lt;strong&gt;must&lt;/strong&gt; guarantee that if they return a non-zero availability value, then the numerical results are valid.</source>
          <target state="translated">마찬가지로 &lt;code&gt;VK_QUERY_RESULT_WITH_AVAILABILITY_BIT&lt;/code&gt; 가 설정되고 &lt;code&gt;VK_QUERY_RESULT_WAIT_BIT&lt;/code&gt; 가 설정되지 않은 경우 다른 큐에서 쿼리를 동시에 사용하지 않는 경우 가용성은 동일한 큐에서 가장 최근에 사용한 쿼리를 반영하도록 보장됩니다. &lt;code&gt;vkGetQueryPoolResults&lt;/code&gt; 와 마찬가지로 구현 시 0이 아닌 가용성 값을 리턴하면 숫자 결과가 유효 함을 보장 &lt;strong&gt;해야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="306dd1890484b05617d071e006ab602814a3f655" translate="yes" xml:space="preserve">
          <source>Similarly, if the &lt;code&gt;dstImage&lt;/code&gt; is compressed, then:</source>
          <target state="translated">마찬가지로 &lt;code&gt;dstImage&lt;/code&gt; 가 압축 된 경우 :</target>
        </trans-unit>
        <trans-unit id="ea85c2d12a72bf589f721946f0c5256792a825f8" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;#VkSampler&quot;&gt;VkSampler&lt;/a&gt; is a non-dispatchable handle type, implementations &lt;strong&gt;may&lt;/strong&gt; return the same handle for sampler state vectors that are identical. In such cases, all such objects would only count once against the &lt;code&gt;maxSamplerAllocationCount&lt;/code&gt; limit.</source>
          <target state="translated">이후 &lt;a href=&quot;#VkSampler&quot;&gt;VkSampler는&lt;/a&gt; 비 디스패치 핸들 타입 인, 구현은 &lt;strong&gt;수&lt;/strong&gt; 동일 샘플러 상태 벡터 동일한 핸들을 리턴한다. 이러한 경우 이러한 모든 개체는 &lt;code&gt;maxSamplerAllocationCount&lt;/code&gt; 제한 에 대해 한 번만 계산 됩니다.</target>
        </trans-unit>
        <trans-unit id="b7152342a267362add3c0d7f69f720f7a9c76c9e" translate="yes" xml:space="preserve">
          <source>Size</source>
          <target state="translated">Size</target>
        </trans-unit>
        <trans-unit id="7d1ec4d40756e14dc53e222c8bd15d258bd2edd3" translate="yes" xml:space="preserve">
          <source>Some of the image creation parameters are inherited by the view. The remaining parameters are contained in the &lt;code&gt;pCreateInfo&lt;/code&gt;.</source>
          <target state="translated">이미지 생성 매개 변수 중 일부는 뷰에서 상속됩니다. 나머지 매개 변수는 &lt;code&gt;pCreateInfo&lt;/code&gt; 에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a942835b55f2b912cc313f91ad3da7e6a13ccf4f" translate="yes" xml:space="preserve">
          <source>Some platforms &lt;strong&gt;may&lt;/strong&gt; have a limit on the maximum size of a single allocation. For example, certain systems &lt;strong&gt;may&lt;/strong&gt; fail to create allocations with a size greater than or equal to 4GB. Such a limit is implementation-dependent, and if such a failure occurs then the error &lt;code&gt;VK_ERROR_OUT_OF_DEVICE_MEMORY&lt;/code&gt;&lt;strong&gt;should&lt;/strong&gt; be returned.</source>
          <target state="translated">일부 플랫폼 에는 단일 할당의 최대 크기에 제한 &lt;strong&gt;이&lt;/strong&gt; 있을 &lt;strong&gt;수&lt;/strong&gt; 있습니다. 예를 들어, 특정 시스템 &lt;strong&gt;은&lt;/strong&gt; 4GB 이상의 크기로 할당을 생성하지 못할 수 있습니다. 이러한 제한은 구현에 따라 다르며 이러한 오류가 발생하면 오류 &lt;code&gt;VK_ERROR_OUT_OF_DEVICE_MEMORY&lt;/code&gt; &lt;strong&gt;가&lt;/strong&gt; 반환 &lt;strong&gt;되어야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="1ea7471f263b29f9c66b3d3679203876d4e410c8" translate="yes" xml:space="preserve">
          <source>Some synchronization commands take sets of access types as parameters to define the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes&quot;&gt;access scopes&lt;/a&gt; of a memory dependency. If a synchronization command includes a source access mask, its first &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes&quot;&gt;access scope&lt;/a&gt; only includes accesses via the access types specified in that mask. Similarly, if a synchronization command includes a destination access mask, its second &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes&quot;&gt;access scope&lt;/a&gt; only includes accesses via the access types specified in that mask.</source>
          <target state="translated">일부 동기화 명령은 액세스 유형 세트를 매개 변수로 사용하여 메모리 종속성 의 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes&quot;&gt;액세스 범위&lt;/a&gt; 를 정의합니다 . 동기화 명령에 소스 액세스 마스크가 포함 된 경우 첫 번째 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes&quot;&gt;액세스 범위&lt;/a&gt; 에는 해당 마스크에 지정된 액세스 유형을 통한 액세스 만 포함됩니다. 마찬가지로 동기화 명령에 대상 액세스 마스크가 포함 된 경우 두 번째 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes&quot;&gt;액세스 범위&lt;/a&gt; 에는 해당 마스크에 지정된 액세스 유형을 통한 액세스 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c42adf00966f25b49fa92fb2afd3fca201de4e36" translate="yes" xml:space="preserve">
          <source>Specifying the exact framebuffer that the secondary command buffer will be executed with &lt;strong&gt;may&lt;/strong&gt; result in better performance at command buffer execution time.</source>
          <target state="translated">보조 명령 버퍼가 실행될 정확한 프레임 버퍼를 지정하면 명령 버퍼 실행시 성능이 향상 &lt;strong&gt;될 수&lt;/strong&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="bae7d5be70820ed56467bd9a63744e23b47bd711" translate="yes" xml:space="preserve">
          <source>Status</source>
          <target state="translated">Status</target>
        </trans-unit>
        <trans-unit id="c64b6d8ab6a3167af6b211df05198e555a8951eb" translate="yes" xml:space="preserve">
          <source>Structures</source>
          <target state="translated">Structures</target>
        </trans-unit>
        <trans-unit id="093b6cd6e09a681f50b3995205ca4c104c2807de" translate="yes" xml:space="preserve">
          <source>Submission can be a high overhead operation, and applications &lt;strong&gt;should&lt;/strong&gt; attempt to batch work together into as few calls to &lt;code&gt;vkQueueSubmit&lt;/code&gt; as possible.</source>
          <target state="translated">제출은 오버 헤드가 높은 작업 일 수 있으며 응용 프로그램 &lt;strong&gt;은&lt;/strong&gt; 가능한 한 적은 수의 &lt;code&gt;vkQueueSubmit&lt;/code&gt; 호출로 일괄 작업을 일괄 처리 &lt;strong&gt;해야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="d5ee48f4626430b4b0eb9ccf81cb61818a482854" translate="yes" xml:space="preserve">
          <source>Subpass dependencies are not affected by the render area, and apply to the entire image subresources attached to the framebuffer as specified in the description of &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-layout-transitions&quot;&gt;automatic layout transitions&lt;/a&gt;. Similarly, pipeline barriers are valid even if their effect extends outside the render area.</source>
          <target state="translated">서브 패스 종속성은 렌더링 영역의 영향을받지 않으며 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-layout-transitions&quot;&gt;자동 레이아웃 전환&lt;/a&gt; 설명에 지정된대로 프레임 버퍼에 연결된 전체 이미지 서브 리소스에 적용됩니다 . 마찬가지로 파이프 라인 장벽은 효과가 렌더 영역 외부로 확장 되더라도 유효합니다.</target>
        </trans-unit>
        <trans-unit id="42a8f651d79fd005eeac0612df6442b983a01184" translate="yes" xml:space="preserve">
          <source>Success</source>
          <target state="translated">Success</target>
        </trans-unit>
        <trans-unit id="316d63bf521d1a2129970b36cde68883e6a77699" translate="yes" xml:space="preserve">
          <source>Success Codes</source>
          <target state="translated">성공 코드</target>
        </trans-unit>
        <trans-unit id="a2cbc439c9045c310d0fbcdb653addfdbdfa2620" translate="yes" xml:space="preserve">
          <source>Successful completion codes are returned when a command needs to communicate success or status information. All successful completion codes are non-negative values.</source>
          <target state="translated">명령이 성공 또는 상태 정보를 전달해야 할 때 성공적인 완료 코드가 리턴됩니다. 성공적인 완료 코드는 모두 음수가 아닌 값입니다.</target>
        </trans-unit>
        <trans-unit id="2616ff87cadf2d1f2a5fbb2b55015289cefbb3de" translate="yes" xml:space="preserve">
          <source>Supported Queue Types</source>
          <target state="translated">지원되는 대기열 유형</target>
        </trans-unit>
        <trans-unit id="0e3be3a65e844f516e59412e57af5f7f89c0d712" translate="yes" xml:space="preserve">
          <source>Supported pipeline stages</source>
          <target state="translated">지원되는 파이프 라인 단계</target>
        </trans-unit>
        <trans-unit id="b816729f8cfd7023f87362593c8e3c3fbd97648d" translate="yes" xml:space="preserve">
          <source>Table 1. vkGetDeviceProcAddr behavior</source>
          <target state="translated">표 1. vkGetDeviceProcAddr 동작</target>
        </trans-unit>
        <trans-unit id="1742582516ee749eb727849e027891cfe1a77eef" translate="yes" xml:space="preserve">
          <source>Table 10. Component Mappings Equivalent To &lt;code&gt;VK_COMPONENT_SWIZZLE_IDENTITY&lt;/code&gt;</source>
          <target state="translated">표 10. &lt;code&gt;VK_COMPONENT_SWIZZLE_IDENTITY&lt;/code&gt; 와 동등한 구성 요소 맵핑</target>
        </trans-unit>
        <trans-unit id="9fbe1b1057482bc8e2a9980a7c41d7c4a596b876" translate="yes" xml:space="preserve">
          <source>Table 11. Logical Operations</source>
          <target state="translated">표 11. 논리 연산</target>
        </trans-unit>
        <trans-unit id="94c6f5ef7cbcf5e2cb167fba793a72eb265e9bdb" translate="yes" xml:space="preserve">
          <source>Table 12. VkObjectType and Vulkan Handle Relationship</source>
          <target state="translated">표 12. VkObjectType과 Vulkan 핸들 관계</target>
        </trans-unit>
        <trans-unit id="2da473c4731f212bf8417ecf4c08b8b5cbdfcf56" translate="yes" xml:space="preserve">
          <source>Table 2. Event Object Status Codes</source>
          <target state="translated">표 2. 이벤트 오브젝트 상태 코드</target>
        </trans-unit>
        <trans-unit id="1aa4e565052de4bba04bce9edf26f02647537fe1" translate="yes" xml:space="preserve">
          <source>Table 3. Fence Object Status Codes</source>
          <target state="translated">표 3. 울타리 개체 상태 코드</target>
        </trans-unit>
        <trans-unit id="8feca90e7fe13b94e3d4bcd2ed60c473e4bd60ba" translate="yes" xml:space="preserve">
          <source>Table 4. vkGetInstanceProcAddr behavior</source>
          <target state="translated">표 4. vkGetInstanceProcAddr 동작</target>
        </trans-unit>
        <trans-unit id="831ab4f5641d496e5ca0390d0fad229c67d29c93" translate="yes" xml:space="preserve">
          <source>Table 5. Layout for pipeline cache header version &lt;code&gt;VK_PIPELINE_CACHE_HEADER_VERSION_ONE&lt;/code&gt;</source>
          <target state="translated">표 5. 파이프 라인 캐시 헤더 버전 &lt;code&gt;VK_PIPELINE_CACHE_HEADER_VERSION_ONE&lt;/code&gt; 의 레이아웃</target>
        </trans-unit>
        <trans-unit id="27ac27c0ffded35668d9f9c30dc98d9ca91d7138" translate="yes" xml:space="preserve">
          <source>Table 6. Image and image view parameter compatibility requirements</source>
          <target state="translated">표 6. 이미지 및 이미지보기 매개 변수 호환성 요구 사항</target>
        </trans-unit>
        <trans-unit id="a0e73cb6a2b5d98ea6c4ec60f77d7f24de613510" translate="yes" xml:space="preserve">
          <source>Table 7. Supported access types</source>
          <target state="translated">표 7. 지원되는 액세스 유형</target>
        </trans-unit>
        <trans-unit id="61ae5d5ec9f9ba465bb08753341fb2a6d8837356" translate="yes" xml:space="preserve">
          <source>Table 8. Blend Factors</source>
          <target state="translated">표 8. 혼합 계수</target>
        </trans-unit>
        <trans-unit id="2562fae0aad0eb791e709b85fdaa591a529ad966" translate="yes" xml:space="preserve">
          <source>Table 9. Basic Blend Operations</source>
          <target state="translated">표 9. 기본 혼합 작업</target>
        </trans-unit>
        <trans-unit id="260d031c0a011609575545b5de3494526dfad1dd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#VkDescriptorSetLayoutBinding&quot;&gt;VkDescriptorSetLayoutBinding&lt;/a&gt;::&lt;code&gt;binding&lt;/code&gt; members of the elements of the &lt;code&gt;pBindings&lt;/code&gt; array &lt;strong&gt;must&lt;/strong&gt; each have different values.</source>
          <target state="translated">&lt;a href=&quot;#VkDescriptorSetLayoutBinding&quot;&gt;VkDescriptorSetLayoutBinding&lt;/a&gt; :: &lt;code&gt;binding&lt;/code&gt; 의 요소 부재 &lt;code&gt;pBindings&lt;/code&gt; 의 배열 &lt;strong&gt;해야&lt;/strong&gt; 서로 다른 값을 갖는다.</target>
        </trans-unit>
        <trans-unit id="f6a78099cc4a599ed528b4deb0bc5cbb7a7ef457" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#VkFormat&quot;&gt;VkFormat&lt;/a&gt; of each of &lt;code&gt;srcImage&lt;/code&gt; and &lt;code&gt;dstImage&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be compatible, as defined &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#copies-images-format-compatibility&quot;&gt;below&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#VkFormat&quot;&gt;VkFormat&lt;/a&gt; 각각의 &lt;code&gt;srcImage&lt;/code&gt; 및 &lt;code&gt;dstImage&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 정의, 호환 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#copies-images-format-compatibility&quot;&gt;이하&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b935630130d371037fdd72c3f5fdc89b4b3a3b67" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#VkGraphicsPipelineCreateInfo&quot;&gt;VkGraphicsPipelineCreateInfo&lt;/a&gt; structure includes an array of shader create info structures containing all the desired active shader stages, as well as creation info to define all relevant fixed-function stages, and a pipeline layout.</source>
          <target state="translated">&lt;a href=&quot;#VkGraphicsPipelineCreateInfo&quot;&gt;VkGraphicsPipelineCreateInfo의&lt;/a&gt; 구조 셰이더들의 어레이는 모든 관련 기능이 고정 단을 정의하는 모든 원하는 활성 셰이더 스테이지뿐만 아니라 생성 정보를 포함하는 정보 구조 및 파이프 라인 레이아웃을 생성 포함한다.</target>
        </trans-unit>
        <trans-unit id="b3d2dd2bfa113e06cd0fb91fac058c399de965ca" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#VkImageSubresourceRange&quot;&gt;VkImageSubresourceRange&lt;/a&gt;::&lt;code&gt;baseArrayLayer&lt;/code&gt; members of the elements of the &lt;code&gt;pRanges&lt;/code&gt; array &lt;strong&gt;must&lt;/strong&gt; each be less than the &lt;code&gt;arrayLayers&lt;/code&gt; specified in &lt;a href=&quot;#VkImageCreateInfo&quot;&gt;VkImageCreateInfo&lt;/a&gt; when &lt;code&gt;image&lt;/code&gt; was created</source>
          <target state="translated">&lt;a href=&quot;#VkImageSubresourceRange&quot;&gt;VkImageSubresourceRange&lt;/a&gt; :: &lt;code&gt;baseArrayLayer&lt;/code&gt; 에서 의 요소 부재 &lt;code&gt;pRanges&lt;/code&gt; 의 배열 &lt;strong&gt;해야&lt;/strong&gt; 각 이상이어야 &lt;code&gt;arrayLayers&lt;/code&gt; 에 지정된 &lt;a href=&quot;#VkImageCreateInfo&quot;&gt;VkImageCreateInfo&lt;/a&gt; 때 &lt;code&gt;image&lt;/code&gt; 작성된</target>
        </trans-unit>
        <trans-unit id="fcb0dc656b86663f74dcbe4af9207f17c955e6ea" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#VkImageSubresourceRange&quot;&gt;VkImageSubresourceRange&lt;/a&gt;::&lt;code&gt;baseMipLevel&lt;/code&gt; members of the elements of the &lt;code&gt;pRanges&lt;/code&gt; array &lt;strong&gt;must&lt;/strong&gt; each be less than the &lt;code&gt;mipLevels&lt;/code&gt; specified in &lt;a href=&quot;#VkImageCreateInfo&quot;&gt;VkImageCreateInfo&lt;/a&gt; when &lt;code&gt;image&lt;/code&gt; was created</source>
          <target state="translated">&lt;a href=&quot;#VkImageSubresourceRange&quot;&gt;VkImageSubresourceRange&lt;/a&gt; :: &lt;code&gt;baseMipLevel&lt;/code&gt; 에서 의 요소 부재 &lt;code&gt;pRanges&lt;/code&gt; 의 배열 &lt;strong&gt;해야&lt;/strong&gt; 각 이상이어야 &lt;code&gt;mipLevels&lt;/code&gt; 에 지정된 &lt;a href=&quot;#VkImageCreateInfo&quot;&gt;VkImageCreateInfo&lt;/a&gt; 때 &lt;code&gt;image&lt;/code&gt; 작성된</target>
        </trans-unit>
        <trans-unit id="f0f3ef181c371f4e9ec190ba0e88c81584aa554a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#VkObjectType&quot;&gt;VkObjectType&lt;/a&gt; enumeration defines values, each of which corresponds to a specific Vulkan handle type. These values &lt;strong&gt;can&lt;/strong&gt; be used to associate debug information with a particular type of object through one or more extensions.</source>
          <target state="translated">&lt;a href=&quot;#VkObjectType&quot;&gt;VkObjectType의&lt;/a&gt; 특정 VULKAN 핸들 유형에 해당하는 각각의 열거 정의 값. 이 값 &lt;strong&gt;은&lt;/strong&gt; 하나 이상의 확장을 통해 디버그 정보를 특정 유형의 오브젝트와 연관시키는 데 사용할 &lt;strong&gt;수&lt;/strong&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec89ee4fbea8f53b65a7c304310ea1b4361a8e21" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#VkPipelineLayoutCreateInfo&quot;&gt;VkPipelineLayoutCreateInfo&lt;/a&gt; structure is defined as:</source>
          <target state="translated">&lt;a href=&quot;#VkPipelineLayoutCreateInfo&quot;&gt;VkPipelineLayoutCreateInfo의&lt;/a&gt; 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="e3b8bcbf9952df3464fa48ae305b76482e3a723d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#vkQueueSubmit&quot;&gt;vkQueueSubmit&lt;/a&gt; command &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-submission-host-writes&quot;&gt;automatically guarantees that host writes flushed to &lt;code&gt;VK_ACCESS_HOST_WRITE_BIT&lt;/code&gt; are made available&lt;/a&gt; if they were flushed before the command executed, so in most cases an explicit memory barrier is not needed for this case. In the few circumstances where a submit does not occur between the host write and the device read access, writes &lt;strong&gt;can&lt;/strong&gt; be made available by using an explicit memory barrier.</source>
          <target state="translated">&lt;a href=&quot;#vkQueueSubmit&quot;&gt;vkQueueSubmit의&lt;/a&gt; 명령은 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-submission-host-writes&quot;&gt;자동으로 호스트 쓰기가 플러시 보장 &lt;code&gt;VK_ACCESS_HOST_WRITE_BIT&lt;/code&gt; 가 사용할 수 있습니다&lt;/a&gt; 그들이 그렇게 대부분의 경우 명시 적 메모리 장벽이 경우 필요하지 않습니다, 실행 명령 전에 플러시 된 경우. 호스트 쓰기와 장치 읽기 액세스간에 제출이 발생하지 않는 몇 가지 상황에서는 명시 적 메모리 장벽을 사용하여 쓰기를 &lt;strong&gt;사용할 수&lt;/strong&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="847c30607b15a6350eaf5a0a8774fdb2b7f94ab9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-device&quot;&gt;Device Memory&lt;/a&gt; section describes memory properties queried from the physical device.</source>
          <target state="translated">&lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#memory-device&quot;&gt;장치 메모리&lt;/a&gt; 섹션은 실제 장치에서 쿼리 메모리 특성을 설명한다.</target>
        </trans-unit>
        <trans-unit id="8d34aa9fff7ba1ac43b0f4969108a4e7eb9cbec0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-available-and-visible&quot;&gt;availability and visibility operations&lt;/a&gt; defined by a subpass dependency affect the execution of &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-layout-transitions&quot;&gt;image layout transitions&lt;/a&gt; within the render pass.</source>
          <target state="translated">&lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-available-and-visible&quot;&gt;가용성 시인성 동작&lt;/a&gt; subpass 의존성에 의해 정의 된 실행에 영향 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-layout-transitions&quot;&gt;화면 레이아웃 전환&lt;/a&gt; 렌더링 패스 내에있다.</target>
        </trans-unit>
        <trans-unit id="58cbce4bb72c06ae6ab939ee38b65227a8044f9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkApplicationInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkApplicationInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="131b4be23ee3eb73500763ec1557135c1db7f7d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkAttachmentDescription&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkAttachmentDescription&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="2e6a54f7c6cdcb88f967df54dcfaf0dd4273404d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkAttachmentReference&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkAttachmentReference&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="224f0f88fa0d8e5c0760bcaca4a4d580b11a62f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkBindSparseInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkBindSparseInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="bcb88f2ebb7fb99282d531d233b4c1e2f99a62b1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkBufferCopy&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkBufferCopy&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="c76ea7967eceab6014aeaa4f3c529fe1692e4264" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkBufferCreateInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkBufferCreateInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="6ba59eaded72202eeafd207ef9e896d9de40407c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkBufferMemoryBarrier&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkBufferMemoryBarrier&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="54032f1c63408d6dcecf68bafe3abbfb59147a2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkBufferViewCreateInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkBufferViewCreateInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="ea2d47c8d5630f363f75f6923a280ce6f6c79fa6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkClearAttachment&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkClearAttachment&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="0c3032c2477cc4fc38f136f26c0b73ea22020b58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkClearColorValue&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkClearColorValue&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="2a6845b989d4701b83c4cc982433ff8e04c1a805" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkClearDepthStencilValue&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkClearDepthStencilValue&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="b34daebae4dd88a7f31773618688710822b7c368" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkClearRect&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkClearRect&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="4460eb00c02e69c2eee107a625fe338b1efcd6ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkClearValue&lt;/code&gt; union is defined as:</source>
          <target state="translated">&lt;code&gt;VkClearValue&lt;/code&gt; 의 조합은 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="696cc15e6b77a4144383d42237dd4e023a4807da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkCommandBufferAllocateInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkCommandBufferAllocateInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="df36512a90c6ebeeb6b5b3e76bf2e86a41b37779" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkCommandBufferBeginInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkCommandBufferBeginInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="748e587ce04a8d7aa4500ac778fbd75f66727716" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkCommandPool&lt;/code&gt; that &lt;code&gt;commandBuffer&lt;/code&gt; was allocated from &lt;strong&gt;must&lt;/strong&gt; support compute operations</source>
          <target state="translated">&lt;code&gt;VkCommandPool&lt;/code&gt; 그 &lt;code&gt;commandBuffer&lt;/code&gt; 는 에서 할당 된 &lt;strong&gt;필수의&lt;/strong&gt; 지원 컴퓨팅 작업</target>
        </trans-unit>
        <trans-unit id="99c7c33ddbe73576107c3d3ee6c071ea459a9498" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkCommandPool&lt;/code&gt; that &lt;code&gt;commandBuffer&lt;/code&gt; was allocated from &lt;strong&gt;must&lt;/strong&gt; support graphics operations</source>
          <target state="translated">&lt;code&gt;VkCommandPool&lt;/code&gt; 그 &lt;code&gt;commandBuffer&lt;/code&gt; 는 에서 할당 된 &lt;strong&gt;필수의&lt;/strong&gt; 지원 그래픽 작업</target>
        </trans-unit>
        <trans-unit id="6124495af689e32e1c22e44381bf0b7caa5acbd4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkCommandPool&lt;/code&gt; that &lt;code&gt;commandBuffer&lt;/code&gt; was allocated from &lt;strong&gt;must&lt;/strong&gt; support graphics or compute operations</source>
          <target state="translated">&lt;code&gt;VkCommandPool&lt;/code&gt; 그 &lt;code&gt;commandBuffer&lt;/code&gt; 는 에서 할당 된 &lt;strong&gt;필수의&lt;/strong&gt; 지지 그래픽이나 컴퓨팅 작업</target>
        </trans-unit>
        <trans-unit id="182448d0ac8823ad1d731cbdc148d348eb770d9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkCommandPool&lt;/code&gt; that &lt;code&gt;commandBuffer&lt;/code&gt; was allocated from &lt;strong&gt;must&lt;/strong&gt; support graphics, or compute operations</source>
          <target state="translated">&lt;code&gt;VkCommandPool&lt;/code&gt; 것을 &lt;code&gt;commandBuffer&lt;/code&gt; 가 에서 할당 &lt;strong&gt;해야의&lt;/strong&gt; 지원 그래픽 또는 컴퓨팅 작업</target>
        </trans-unit>
        <trans-unit id="247194d6c9c09e3a7508b0f909a4d0ae45017991" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkCommandPool&lt;/code&gt; that &lt;code&gt;commandBuffer&lt;/code&gt; was allocated from &lt;strong&gt;must&lt;/strong&gt; support transfer, graphics, or compute operations</source>
          <target state="translated">&lt;code&gt;VkCommandPool&lt;/code&gt; 그 &lt;code&gt;commandBuffer&lt;/code&gt; 는 에서 할당 된 &lt;strong&gt;필수의&lt;/strong&gt; 지원 전송, 그래픽 또는 컴퓨팅 작업</target>
        </trans-unit>
        <trans-unit id="e2ad496765f25b942a71b7931ee4e14f2a93b7d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkCommandPoolCreateInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkCommandPoolCreateInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="0fb925689a4f8769913a439d47518973d9a7f905" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkComponentMapping&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkComponentMapping&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="786c2dfe65d8d6fa6f3b907c82ea5af2d26c0788" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkComputePipelineCreateInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkComputePipelineCreateInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="5b9c5d6e3f91422a6be1107053e17bbc9e74b07e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkCopyDescriptorSet&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkCopyDescriptorSet&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="bc2bac80cbd95ff18f31389120c00b3451c0d80f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkDescriptorBufferInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkDescriptorBufferInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="9c1cfee713c724e59b533700a56180f1d88e08d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkDescriptorImageInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkDescriptorImageInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="acf81da1d784d8708d95dcd4cc15c96092326bbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkDescriptorPoolSize&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkDescriptorPoolSize&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="163d4f309e1f35b8c8dfb3346b335c9e40215175" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkDescriptorSetAllocateInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkDescriptorSetAllocateInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="389952baae652dbd578f630eaf36433720bb0b61" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkDescriptorSetLayoutBinding&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkDescriptorSetLayoutBinding&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="9966dc243cff5bd8ef790797a34466da99abcb9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkDeviceCreateInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkDeviceCreateInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="29da10b5e17156b0e0e645a42b89f915fd00b09a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkDeviceQueueCreateInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkDeviceQueueCreateInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="2f4144f99670654008e5d5bf931a64f593392fda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkDispatchIndirectCommand&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkDispatchIndirectCommand&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="10f95a83cce2a1a6f3a271641c0540a64e809020" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkDrawIndexedIndirectCommand&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkDrawIndexedIndirectCommand&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="739ad2f55fb00003d439ae52e24a98985b555c39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkDrawIndirectCommand&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkDrawIndirectCommand&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="fdee65628dbaaae8cf71a150817f6194fe90fa5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkEventCreateInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkEventCreateInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="8fe73e96b56f10b3b350fabea454d9c8200d16d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkExtensionProperties&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkExtensionProperties&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="09c4dd843909908c4354a452392808d237f3149d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkFenceCreateInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkFenceCreateInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="518b030fbb1280e2ab5ebcf4febf8a09089c7339" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkFormatProperties&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkFormatProperties&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="7d9758a1bba8e46faba332fc6071722c8572b260" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkFramebufferCreateInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkFramebufferCreateInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="c6a3751614085c89999095cc97205e1e155b8927" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkGraphicsPipelineCreateInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkGraphicsPipelineCreateInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="ac118a4da7fb9cf4b68347228b13838ca0a6cb72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkImageBlit&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkImageBlit&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="d777ef0576281bdf7a5b6f803971cb0efbf23ca7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkImageCopy&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkImageCopy&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="991c6f02e9cabe044ce306003e6151d59cebe0d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkImageCreateInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkImageCreateInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="435a665e34eb28f0d26891cfa3ee1b15b4ad9e2c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkImageFormatProperties&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkImageFormatProperties&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="63462cf771fed6a50e682fb9bd8cd1a364e6c81d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkImageMemoryBarrier&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkImageMemoryBarrier&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="668d55cc4f4f9d568862c7d8d396c605c32284c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkImageResolve&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkImageResolve&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="26cc8d4eb90a3288910860973593054e09811851" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkImageSubresource&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkImageSubresource&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="44875c039fd0d1b9273acbbf7ab4d2f19b90b8ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkImageSubresourceLayers&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkImageSubresourceLayers&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="28ded60cba790410f21b5914c08b1decc8973e62" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkImageSubresourceRange&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkImageSubresourceRange&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="9e7dcdc4fea4b6b9c75e25570fda184bd218208c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkImageViewCreateInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkImageViewCreateInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="2b5bc8ba0af3918a7e83283293b48fc5f1f82ff9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkInstanceCreateInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkInstanceCreateInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="2a51dc9fdc8714489f134df1aadfd3aa743b679e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkLayerProperties&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkLayerProperties&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="44842a4d5af7b1972ceced0461683feacbee64a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkMappedMemoryRange&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkMappedMemoryRange&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="25534c3c23e6738152d5ca5ca8d7df08e9a3e77b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkMemoryAllocateInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkMemoryAllocateInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="a0222a61cf02852e7f44d46f6c8e443327114224" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkMemoryBarrier&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkMemoryBarrier&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="dbba01f1c5af0aac9fd20a9650394109ff04f7ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkMemoryHeap&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkMemoryHeap&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="1792755b145743041dffbd10007bb986b54c12cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkMemoryRequirements&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkMemoryRequirements&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="0929e33e54a09be6012d7bbc0e4bb0b72d137eb9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkMemoryType&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkMemoryType&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="f616221081ff53b744f8f24f0602285fba7457ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkPhysicalDeviceFeatures&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkPhysicalDeviceFeatures&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="401180f2feecbe16e5a412f7d51d07b2f95b44a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="622b4d81ad990ce16b109ad912e02926432d68ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkPhysicalDeviceMemoryProperties&lt;/code&gt; structure describes a number of &lt;em&gt;memory heaps&lt;/em&gt; as well as a number of &lt;em&gt;memory types&lt;/em&gt; that &lt;strong&gt;can&lt;/strong&gt; be used to access memory allocated in those heaps. Each heap describes a memory resource of a particular size, and each memory type describes a set of memory properties (e.g. host cached vs uncached) that &lt;strong&gt;can&lt;/strong&gt; be used with a given memory heap. Allocations using a particular memory type will consume resources from the heap indicated by that memory type&amp;rsquo;s heap index. More than one memory type &lt;strong&gt;may&lt;/strong&gt; share each heap, and the heaps and memory types provide a mechanism to advertise an accurate size of the physical memory resources while allowing the memory to be used with a variety of different properties.</source>
          <target state="translated">&lt;code&gt;VkPhysicalDeviceMemoryProperties&lt;/code&gt; 의 구조는 다수의 설명 &lt;em&gt;메모리 추적&lt;/em&gt; 뿐만 아니라, 다수의 &lt;em&gt;메모리 유형 &lt;/em&gt;&lt;strong&gt;수&lt;/strong&gt; 해당 추적에 할당 된 액세스 메모리를 사용할 수있다. 각 힙은 특정 크기의 메모리 자원을 설명하고 각 메모리 유형 은 주어진 메모리 힙과 함께 사용할 &lt;strong&gt;수&lt;/strong&gt; 있는 메모리 특성 세트 (예 : 호스트 캐시 대 캐시되지 않음)를 설명합니다 . 특정 메모리 유형을 사용하는 할당은 해당 메모리 유형의 힙 인덱스로 표시된 힙에서 자원을 소비합니다. 하나 개 이상의 메모리 유형 &lt;strong&gt;수도&lt;/strong&gt; 각 힙을 공유하면 힙 및 메모리 유형은 실제 메모리 리소스의 정확한 크기를 알리는 동시에 메모리를 다양한 속성으로 사용할 수있는 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3856adc0a32bcea44208f6dd47cb1f3b3aa31212" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkPhysicalDeviceMemoryProperties&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkPhysicalDeviceMemoryProperties&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="10315218c47d5ae1e186650f6f32a9b83de2571e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkPhysicalDeviceProperties&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkPhysicalDeviceProperties&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="136ee89a5f22c25a105c31669fe930182dbae59f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkPhysicalDeviceSparseProperties&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkPhysicalDeviceSparseProperties&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="dcd9322c8393e8011eb660aa085f43b581c03602" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkPipelineCacheCreateInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkPipelineCacheCreateInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="0604dfba983332b87e1a93a183957d7d709c94e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkPipelineColorBlendAttachmentState&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkPipelineColorBlendAttachmentState&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="df528cbcc50122d077aae56c081522f898a8f0cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkPipelineColorBlendStateCreateInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkPipelineColorBlendStateCreateInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="7a745c1ec7e4284c96d8925f41c46354cce91cc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkPipelineDepthStencilStateCreateInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkPipelineDepthStencilStateCreateInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="3905a5b7c17ab91a93f3b7e33464927718983f1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkPipelineDynamicStateCreateInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkPipelineDynamicStateCreateInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="53a9553127226655b1efe0ad4bd80a322dc8dcbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkPipelineMultisampleStateCreateInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkPipelineMultisampleStateCreateInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="58ca0c78871eb695131ee434ce2e0ddcf1d5a4f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkPipelineRasterizationStateCreateInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkPipelineRasterizationStateCreateInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="68bde8ef80f7aa913f9ba509648949c445482e14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkPipelineShaderStageCreateInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkPipelineShaderStageCreateInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="712f2cc0f913c50c142e9059f51e0068096f4259" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkPipelineTessellationStateCreateInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkPipelineTessellationStateCreateInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="5e26dc90e366138b8bbbcf9a76cd423a302bb837" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkPipelineVertexInputStateCreateInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkPipelineVertexInputStateCreateInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="a105bcf6810a6c66b3e290590875bd943031f5df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkPipelineViewportStateCreateInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkPipelineViewportStateCreateInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="db771ac4b29ed4b4f42a78d3b115bd64dda34002" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkPushConstantRange&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkPushConstantRange&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="69aef621905902df33cf4ab952a85b0d23e1c492" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkQueryPoolCreateInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkQueryPoolCreateInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="e0899881be8a96b7c5317bc2f1a7b16fb5e54987" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkQueueFamilyProperties&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkQueueFamilyProperties&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="8785e79fb90816cd873daf908840f5b636c48311" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkRenderPassBeginInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkRenderPassBeginInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="71ec2bb8c5547f727b140ec79c8c660fb7347da9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkRenderPassCreateInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkRenderPassCreateInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="ddbed6f13311007846b8e0ea47417c7d5287d57a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkSamplerCreateInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkSamplerCreateInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="f9a5d80b1ad778d43e0676943fe0cb3a09e6b17b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkSemaphoreCreateInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkSemaphoreCreateInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="ab818bb4ebad0369b6906cdf1c8dedce77c3f486" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkShaderModuleCreateInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkShaderModuleCreateInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="be253d71ae41fea6256d0e9cb568d913278d09f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkSparseImageFormatProperties&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkSparseImageFormatProperties&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="c2a72db3192d9c41852e08fb11e65059a67a20c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkSparseImageMemoryBind&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkSparseImageMemoryBind&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="7c5073880061f7ee490cb16ef5f25b2c10d00bb2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkSparseImageMemoryRequirements&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkSparseImageMemoryRequirements&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="33521c532563d6bd06bdf750a5f873739258cb05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkSparseMemoryBind&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkSparseMemoryBind&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="9a6547af51fe52815fcb1453a77a8fbc530b3263" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkSpecializationInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkSpecializationInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="0af5bf0aa7a5a6f6fee49e9f4f7acf0a1df2efd6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkSpecializationMapEntry&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkSpecializationMapEntry&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="130616dd57d3c59a7ccf1b1ff317316aece7d0ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkStencilOpState&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkStencilOpState&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="07b4e8d803aca132fc35c11869168ac725cf64a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkSubmitInfo&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkSubmitInfo&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="100c116d18035cac7f1b4e7c3418890144324902" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkSubpassDependency&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkSubpassDependency&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="b2d60e81c4ec56731a57f63516f46a8bfc6caebc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkSubpassDescription&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkSubpassDescription&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="ebaf5a64cabbe7667b16607561f7978ee655c696" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkVertexInputAttributeDescription&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkVertexInputAttributeDescription&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="8f2e2fab820610881a7d0c63ae4e5f916590a39b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkVertexInputBindingDescription&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkVertexInputBindingDescription&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="62b963678c895ec8bd972bc92913c3af5fc151bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkViewport&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkViewport&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="c8f3cb12fc2d3c1662e8d57f72acf8e65a61c45f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VkWriteDescriptorSet&lt;/code&gt; structure is defined as:</source>
          <target state="translated">&lt;code&gt;VkWriteDescriptorSet&lt;/code&gt; 의 구조는 다음과 같이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="a6cda091bf55776b730ca1302cc01ae2ec1419fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;allocationType&lt;/code&gt; parameter to the &lt;code&gt;pfnInternalAllocation&lt;/code&gt; and &lt;code&gt;pfnInternalFree&lt;/code&gt; functions &lt;strong&gt;may&lt;/strong&gt; be one of the following values:</source>
          <target state="translated">&lt;code&gt;pfnInternalAllocation&lt;/code&gt; 및 &lt;code&gt;pfnInternalFree&lt;/code&gt; 함수에 대한 &lt;code&gt;allocationType&lt;/code&gt; 매개 변수 는 다음 값 중 하나 일 &lt;strong&gt;수&lt;/strong&gt; 있습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9208fb7d824f2e25273322b1c289f85a81d56011" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aspectMask&lt;/code&gt; member of &lt;code&gt;dstSubresource&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; specify aspects present in the calling command&amp;rsquo;s &lt;code&gt;dstImage&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;aspectMask&lt;/code&gt; 의 회원 &lt;code&gt;dstSubresource&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 호출 명령의에서 측면에 존재하는 지정 &lt;code&gt;dstImage&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="e89b27277fa7d3c762a21d5045eda290d8437f41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aspectMask&lt;/code&gt; member of &lt;code&gt;imageSubresource&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; only have a single bit set</source>
          <target state="translated">&lt;code&gt;aspectMask&lt;/code&gt; 의 회원 &lt;code&gt;imageSubresource&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 단지 하나의 비트가 설정되어</target>
        </trans-unit>
        <trans-unit id="cd0aabac8c1f4e57c6070b383db299c7ed9dfbdb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aspectMask&lt;/code&gt; member of &lt;code&gt;imageSubresource&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; specify aspects present in the calling command&amp;rsquo;s &lt;code&gt;VkImage&lt;/code&gt; parameter</source>
          <target state="translated">&lt;code&gt;imageSubresource&lt;/code&gt; 의 &lt;code&gt;aspectMask&lt;/code&gt; 멤버 는 호출 명령의 &lt;code&gt;VkImage&lt;/code&gt; 매개 변수에 존재하는 aspect &lt;strong&gt;를&lt;/strong&gt; 지정 &lt;strong&gt;해야합니다.&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7ef69911448032b954a590d8b4ab46709f1b1c4b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aspectMask&lt;/code&gt; member of &lt;code&gt;pSubresource&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; only have a single bit set</source>
          <target state="translated">&lt;code&gt;aspectMask&lt;/code&gt; 의 회원 &lt;code&gt;pSubresource&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 단지 하나의 비트가 설정되어</target>
        </trans-unit>
        <trans-unit id="1a2ac50691da602236abc3c316dc40d476d6e9e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aspectMask&lt;/code&gt; member of &lt;code&gt;srcSubresource&lt;/code&gt; and &lt;code&gt;dstSubresource&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; match</source>
          <target state="translated">&lt;code&gt;srcSubresource&lt;/code&gt; 및 &lt;code&gt;dstSubresource&lt;/code&gt; 의 &lt;code&gt;aspectMask&lt;/code&gt; 멤버 &lt;strong&gt;는&lt;/strong&gt; 일치 &lt;strong&gt;해야합니다.&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7739efe6f8515d6be193287a2510c512ba32dd5e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aspectMask&lt;/code&gt; member of &lt;code&gt;srcSubresource&lt;/code&gt; and &lt;code&gt;dstSubresource&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; only contain &lt;code&gt;VK_IMAGE_ASPECT_COLOR_BIT&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;aspectMask&lt;/code&gt; 의 회원 &lt;code&gt;srcSubresource&lt;/code&gt; 및 &lt;code&gt;dstSubresource&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 만을 포함 &lt;code&gt;VK_IMAGE_ASPECT_COLOR_BIT&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="c8a668103a793a4c5f78621bfeabb92ee8fb0192" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aspectMask&lt;/code&gt; member of &lt;code&gt;srcSubresource&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; specify aspects present in the calling command&amp;rsquo;s &lt;code&gt;srcImage&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;aspectMask&lt;/code&gt; 의 회원 &lt;code&gt;srcSubresource&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 호출 명령의에서 측면에 존재하는 지정 &lt;code&gt;srcImage&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="0ffd43a312df9c04539b119b8f8063686f366931" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;attachment&lt;/code&gt; member of any element of &lt;code&gt;pPreserveAttachments&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not be &lt;code&gt;VK_ATTACHMENT_UNUSED&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;attachment&lt;/code&gt; 의 요소의 회원 &lt;code&gt;pPreserveAttachments&lt;/code&gt; 는&lt;strong&gt;있어야&lt;/strong&gt; 되지 &lt;code&gt;VK_ATTACHMENT_UNUSED&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0a658f5616ac7579cb84d2327bd4afb667045174" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;components&lt;/code&gt; member is of type &lt;a href=&quot;#VkComponentMapping&quot;&gt;VkComponentMapping&lt;/a&gt;, and describes a remapping from components of the image to components of the vector returned by shader image instructions. This remapping &lt;strong&gt;must&lt;/strong&gt; be identity for storage image descriptors, input attachment descriptors, and framebuffer attachments.</source>
          <target state="translated">&lt;code&gt;components&lt;/code&gt; 부재 타입이다 &lt;a href=&quot;#VkComponentMapping&quot;&gt;VkComponentMapping&lt;/a&gt; 및 쉐이더 화상 지시에 의해 반환 된 벡터의 요소에 화상의 구성 요소에서 리 맵핑을 설명한다. 이 리매핑 &lt;strong&gt;은&lt;/strong&gt; 스토리지 이미지 디스크립터, 입력 첨부 파일 디스크립터 및 프레임 버퍼 첨부 파일의 ID &lt;strong&gt;여야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5022ba94cb8f1cb9169875c347c47ef768a718c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dstOffset&lt;/code&gt; member of a given element of &lt;code&gt;pRegions&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than the size of &lt;code&gt;dstBuffer&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;dstOffset&lt;/code&gt; 의 주어진 요소의 부재 &lt;code&gt;pRegions&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 의 크기보다 작아야 &lt;code&gt;dstBuffer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4179b26376c3717ac1687e25b940341b2d51085a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dstSet&lt;/code&gt; member of any given element of &lt;code&gt;pDescriptorWrites&lt;/code&gt; or &lt;code&gt;pDescriptorCopies&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not be used by any command that was recorded to a command buffer which is in the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;pending state&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pDescriptorWrites&lt;/code&gt; 또는 &lt;code&gt;pDescriptorCopies&lt;/code&gt; 의 특정 요소에 대한 &lt;code&gt;dstSet&lt;/code&gt; 멤버 는 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#commandbuffers-lifecycle&quot;&gt;보류 상태 인&lt;/a&gt; 명령 버퍼에 기록 된 명령에 의해 사용 되어서 &lt;strong&gt;는&lt;/strong&gt; 안됩니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf3ac74c25ae62b8a50f87e93a803a9a7382aec8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;tiling&lt;/code&gt;, &lt;code&gt;usage&lt;/code&gt;, and &lt;code&gt;flags&lt;/code&gt; parameters correspond to parameters that would be consumed by &lt;a href=&quot;#vkCreateImage&quot;&gt;vkCreateImage&lt;/a&gt; (as members of &lt;code&gt;VkImageCreateInfo&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; , &lt;code&gt;type&lt;/code&gt; , &lt;code&gt;tiling&lt;/code&gt; , &lt;code&gt;usage&lt;/code&gt; 및 &lt;code&gt;flags&lt;/code&gt; 매개 변수에 의해 소비 될 매개 변수에 해당 &lt;a href=&quot;#vkCreateImage&quot;&gt;vkCreateImage&lt;/a&gt; (의 구성원으로 &lt;code&gt;VkImageCreateInfo&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1ce207943cad80baf419b1027cf8041ba094f6bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;layerCount&lt;/code&gt; member of &lt;code&gt;srcSubresource&lt;/code&gt; and &lt;code&gt;dstSubresource&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; match</source>
          <target state="translated">&lt;code&gt;srcSubresource&lt;/code&gt; 및 &lt;code&gt;dstSubresource&lt;/code&gt; 의 &lt;code&gt;layerCount&lt;/code&gt; 멤버 &lt;strong&gt;는&lt;/strong&gt; 일치 &lt;strong&gt;해야합니다.&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e8d416b6dd2086a1ff80cbb1a61027d4220f4baa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;offset&lt;/code&gt; member of any given element of &lt;code&gt;pMapEntries&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than &lt;code&gt;dataSize&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;offset&lt;/code&gt; 의 주어진 요소의 부재 &lt;code&gt;pMapEntries&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 미만 &lt;code&gt;dataSize&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a195e5a4b60dd6f929c9d741bef093a8ae1ff241" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;queue&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; support sparse binding operations</source>
          <target state="translated">&lt;code&gt;queue&lt;/code&gt; &lt;strong&gt;있어야합니다&lt;/strong&gt; 스파 스 바인딩 작업을 지원</target>
        </trans-unit>
        <trans-unit id="7bec009564a27ca8c448cae5fc259332e4497907" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;queueFamilyIndex&lt;/code&gt; member of any given element of &lt;code&gt;pQueueCreateInfos&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be unique within &lt;code&gt;pQueueCreateInfos&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;queueFamilyIndex&lt;/code&gt; 의 의 특정 요소의 회원 &lt;code&gt;pQueueCreateInfos&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 내에서 고유 &lt;code&gt;pQueueCreateInfos&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ad1795334fdbcef4a2616878687ac5356f416ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;size&lt;/code&gt; member of a given element of &lt;code&gt;pRegions&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be greater than &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; 의 주어진 요소의 부재 &lt;code&gt;pRegions&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 보다 커야 &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="06fa7f4c2f577925722d6b841abcf5e2e8def858" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;size&lt;/code&gt; member of a given element of &lt;code&gt;pRegions&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than or equal to the size of &lt;code&gt;dstBuffer&lt;/code&gt; minus &lt;code&gt;dstOffset&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; 의 주어진 요소의 부재 &lt;code&gt;pRegions&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 미만 또는 크기와 동일 &lt;code&gt;dstBuffer&lt;/code&gt; 마이너스 &lt;code&gt;dstOffset&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="baa59e566284f2915b55fbe4ee5d5502f87b84c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;size&lt;/code&gt; member of a given element of &lt;code&gt;pRegions&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than or equal to the size of &lt;code&gt;srcBuffer&lt;/code&gt; minus &lt;code&gt;srcOffset&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; 의 주어진 요소의 부재 &lt;code&gt;pRegions&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 미만 또는 크기와 동일 &lt;code&gt;srcBuffer&lt;/code&gt; 마이너스 &lt;code&gt;srcOffset&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea198012feca8b705519f06a5c3ab91c0ad4e205" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;size&lt;/code&gt; member of the &lt;code&gt;VkMemoryRequirements&lt;/code&gt; structure returned from a call to &lt;code&gt;vkGetBufferMemoryRequirements&lt;/code&gt; with &lt;code&gt;buffer&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than or equal to the size of &lt;code&gt;memory&lt;/code&gt; minus &lt;code&gt;memoryOffset&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; 의 부재 &lt;code&gt;VkMemoryRequirements&lt;/code&gt; 에 대한 호출로부터 리턴 구조 &lt;code&gt;vkGetBufferMemoryRequirements&lt;/code&gt; 와 &lt;code&gt;buffer&lt;/code&gt; &lt;strong&gt;해야&lt;/strong&gt; 미만이거나 크기와 동일한 &lt;code&gt;memory&lt;/code&gt; 마이너스 &lt;code&gt;memoryOffset&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c9a29a2a7cff8c5858ab31f947fce664e5d3355e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;size&lt;/code&gt; member of the &lt;code&gt;VkMemoryRequirements&lt;/code&gt; structure returned from a call to &lt;code&gt;vkGetImageMemoryRequirements&lt;/code&gt; with &lt;code&gt;image&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than or equal to the size of &lt;code&gt;memory&lt;/code&gt; minus &lt;code&gt;memoryOffset&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; 의 부재 &lt;code&gt;VkMemoryRequirements&lt;/code&gt; 에 대한 호출로부터 리턴 구조 &lt;code&gt;vkGetImageMemoryRequirements&lt;/code&gt; 와 &lt;code&gt;image&lt;/code&gt; &lt;strong&gt;해야&lt;/strong&gt; 미만이거나 크기와 동일한 &lt;code&gt;memory&lt;/code&gt; 마이너스 &lt;code&gt;memoryOffset&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9669ae793ae82330efaddc4f1b6d2fa46b88c9f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;srcOffset&lt;/code&gt; member of a given element of &lt;code&gt;pRegions&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than the size of &lt;code&gt;srcBuffer&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;srcOffset&lt;/code&gt; 의 주어진 요소의 부재 &lt;code&gt;pRegions&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 의 크기보다 작아야 &lt;code&gt;srcBuffer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="81e0298bb5065344438754e72da780e874a08bda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;srcStageMask&lt;/code&gt; and &lt;code&gt;dstStageMask&lt;/code&gt; members of any element of the &lt;code&gt;pDependencies&lt;/code&gt; member of &lt;a href=&quot;#VkRenderPassCreateInfo&quot;&gt;VkRenderPassCreateInfo&lt;/a&gt; used to create &lt;code&gt;renderpass&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be supported by the capabilities of the queue family identified by the &lt;code&gt;queueFamilyIndex&lt;/code&gt; member of the &lt;a href=&quot;#VkCommandPoolCreateInfo&quot;&gt;VkCommandPoolCreateInfo&lt;/a&gt; used to create the command pool which &lt;code&gt;commandBuffer&lt;/code&gt; was allocated from.</source>
          <target state="translated">&lt;code&gt;srcStageMask&lt;/code&gt; 및 &lt;code&gt;dstStageMask&lt;/code&gt; 의 모든 요소의 회원 &lt;code&gt;pDependencies&lt;/code&gt; 의 회원 &lt;a href=&quot;#VkRenderPassCreateInfo&quot;&gt;VkRenderPassCreateInfo을&lt;/a&gt; 만드는 데 사용 &lt;code&gt;renderpass&lt;/code&gt; &lt;strong&gt;해야한다&lt;/strong&gt; 에 의해 식별되는 큐 제품군의 기능에 의해 지원 될 &lt;code&gt;queueFamilyIndex&lt;/code&gt; 의 의 구성원 &lt;a href=&quot;#VkCommandPoolCreateInfo&quot;&gt;VkCommandPoolCreateInfo을&lt;/a&gt; 명령 풀을 만드는 데 사용 &lt;code&gt;commandBuffer&lt;/code&gt; 는 에서 할당되었다.</target>
        </trans-unit>
        <trans-unit id="b99262b28fb7dccc209dbd02b496d24c845e46c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stage&lt;/code&gt; member of &lt;code&gt;stage&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;VK_SHADER_STAGE_COMPUTE_BIT&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;stage&lt;/code&gt; 의 멤버 &lt;code&gt;stage&lt;/code&gt; &lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;VK_SHADER_STAGE_COMPUTE_BIT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2131814b7a766b5bdad85ee3d3e6b699bb3d4ee1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stage&lt;/code&gt; member of any given element of &lt;code&gt;pStages&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not be &lt;code&gt;VK_SHADER_STAGE_COMPUTE_BIT&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;stage&lt;/code&gt; 의 특정 요소의 회원 &lt;code&gt;pStages&lt;/code&gt; 는&lt;strong&gt;있어야&lt;/strong&gt; 하지 &lt;code&gt;VK_SHADER_STAGE_COMPUTE_BIT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d8427f84a2a5c1038381fe9e7a78f48c0f2f554" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stage&lt;/code&gt; member of each element of &lt;code&gt;pStages&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be unique</source>
          <target state="translated">&lt;code&gt;stage&lt;/code&gt; 의 각 요소의 멤버 &lt;code&gt;pStages&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 고유</target>
        </trans-unit>
        <trans-unit id="c92a170278fc9e2375a9c31f51c31e661dcc7123" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stage&lt;/code&gt; member of one element of &lt;code&gt;pStages&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;code&gt;VK_SHADER_STAGE_VERTEX_BIT&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;stage&lt;/code&gt; 의 한 요소의 멤버 &lt;code&gt;pStages&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 할 &lt;code&gt;VK_SHADER_STAGE_VERTEX_BIT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="de59a62f2f7bb4d74251ebbbc8a205285ce0a8b1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vendorID&lt;/code&gt; and &lt;code&gt;deviceID&lt;/code&gt; fields are provided to allow applications to adapt to device characteristics that are not adequately exposed by other Vulkan queries. These &lt;strong&gt;may&lt;/strong&gt; include performance profiles, hardware errata, or other characteristics. In PCI-based implementations, the low sixteen bits of &lt;code&gt;vendorID&lt;/code&gt; and &lt;code&gt;deviceID&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; contain (respectively) the PCI vendor and device IDs associated with the hardware device, and the remaining bits &lt;strong&gt;must&lt;/strong&gt; be set to zero. In non-PCI implementations, the choice of what values to return &lt;strong&gt;may&lt;/strong&gt; be dictated by operating system or platform policies. It is otherwise at the discretion of the implementer, subject to the following constraints and guidelines:</source>
          <target state="translated">&lt;code&gt;vendorID&lt;/code&gt; 과 &lt;code&gt;deviceID&lt;/code&gt; 필드는 응용 프로그램이 적절하게 다른 VULKAN 쿼리에 의해 노출되지 않는 장치 특성에 적응 할 수 있도록 제공됩니다. 여기 에는 성능 프로필, 하드웨어 정오표 또는 기타 특성 &lt;strong&gt;이&lt;/strong&gt; 포함될 &lt;strong&gt;수&lt;/strong&gt; 있습니다. PCI 기반 구현에서 16 비트의 &lt;code&gt;vendorID&lt;/code&gt; 및 &lt;code&gt;deviceID&lt;/code&gt; &lt;strong&gt;는&lt;/strong&gt; 하드웨어 장치와 관련된 PCI 공급 업체 및 장치 ID를 (각각) 포함 &lt;strong&gt;해야&lt;/strong&gt; 하며 나머지 비트 &lt;strong&gt;는&lt;/strong&gt; 0으로 설정해야합니다. 비 PCI 구현에서 반환 &lt;strong&gt;할&lt;/strong&gt; 값의 선택 &lt;strong&gt;은&lt;/strong&gt;운영 체제 또는 플랫폼 정책에 의해 지시됩니다. 그렇지 않으면 다음 제약 조건 및 지침에 따라 구현 자의 재량에 따릅니다.</target>
        </trans-unit>
        <trans-unit id="098acafb535ec82abe3012050d1ddeb9d907617a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;viewType&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be either &lt;code&gt;VK_IMAGE_VIEW_TYPE_1D&lt;/code&gt; or &lt;code&gt;VK_IMAGE_VIEW_TYPE_2D&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;viewType&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 이 될 &lt;code&gt;VK_IMAGE_VIEW_TYPE_1D&lt;/code&gt; 또는 &lt;code&gt;VK_IMAGE_VIEW_TYPE_2D&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b631d0fa293d233953fa510afeb1f8cfbceacecb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vkCmdClearAttachments&lt;/code&gt; command is not affected by the bound pipeline state.</source>
          <target state="translated">&lt;code&gt;vkCmdClearAttachments&lt;/code&gt; 의 명령은 바운드 파이프 라인 상태의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2bea4edeeb2adeeb9646a6a6a2589e895a239096" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, and &lt;code&gt;depth&lt;/code&gt; members of a &lt;a href=&quot;#VkExtent3D&quot;&gt;VkExtent3D&lt;/a&gt; parameter &lt;strong&gt;must&lt;/strong&gt; always match the width, height, and depth of the image subresource corresponding to the parameter, respectively.</source>
          <target state="translated">&lt;a href=&quot;#VkExtent3D&quot;&gt;VkExtent3D&lt;/a&gt; 매개 변수 의 &lt;code&gt;width&lt;/code&gt; , &lt;code&gt;height&lt;/code&gt; 및 &lt;code&gt;depth&lt;/code&gt; 멤버는 각각 해당 매개 변수에 해당하는 이미지 서브 리소스 의 너비, 높이 및 깊이와 항상 일치 &lt;strong&gt;해야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="0635954591f6bf9ebe5b5db6f4150676dfdbb8fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; members of &lt;code&gt;offset&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be greater than or equal to &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 구성원 &lt;code&gt;offset&lt;/code&gt; &lt;strong&gt;해야&lt;/strong&gt; 보다 크거나 같음 &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c535841c90dccbb28542ab36ddf70b40c863195f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; members of a &lt;a href=&quot;#VkOffset3D&quot;&gt;VkOffset3D&lt;/a&gt; parameter &lt;strong&gt;must&lt;/strong&gt; always be zero.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; &lt;a href=&quot;#VkOffset3D&quot;&gt;VkOffset3D&lt;/a&gt; 매개 변수 , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 멤버 &lt;strong&gt;는&lt;/strong&gt; 항상 0 &lt;strong&gt;이어야합니다&lt;/strong&gt; .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="93bc96eebd3423677fc3784258f8ff1eae3acfdd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;binding range&lt;/em&gt; [&lt;code&gt;resourceOffset&lt;/code&gt;, &lt;code&gt;resourceOffset&lt;/code&gt; + &lt;code&gt;size&lt;/code&gt;) has different constraints based on &lt;code&gt;flags&lt;/code&gt;. If &lt;code&gt;flags&lt;/code&gt; contains &lt;code&gt;VK_SPARSE_MEMORY_BIND_METADATA_BIT&lt;/code&gt;, the binding range &lt;strong&gt;must&lt;/strong&gt; be within the mip tail region of the metadata aspect. This metadata region is defined by:</source>
          <target state="translated">&lt;em&gt;결합 범위&lt;/em&gt; [ &lt;code&gt;resourceOffset&lt;/code&gt; , &lt;code&gt;resourceOffset&lt;/code&gt; +의 &lt;code&gt;size&lt;/code&gt; )에 따라 다른 제약을 갖는다 &lt;code&gt;flags&lt;/code&gt; . &lt;code&gt;flags&lt;/code&gt; 에 &lt;code&gt;VK_SPARSE_MEMORY_BIND_METADATA_BIT&lt;/code&gt; 가 포함 된 경우 바인딩 범위 &lt;strong&gt;는&lt;/strong&gt; 메타 데이터 측면의 밉 테일 영역 내에 &lt;strong&gt;있어야합니다&lt;/strong&gt; . 이 메타 데이터 영역은 다음에 의해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="22aa6e117b686a7c031d033f6507c3c8e014fa61" translate="yes" xml:space="preserve">
          <source>The above also applies when &lt;code&gt;VK_QUERY_RESULT_WAIT_BIT&lt;/code&gt; is used in combination with &lt;code&gt;VK_QUERY_RESULT_WITH_AVAILABILITY_BIT&lt;/code&gt;. In this case, the returned availability status &lt;strong&gt;may&lt;/strong&gt; reflect the result of a previous use of the query unless the &lt;code&gt;vkCmdResetQueryPool&lt;/code&gt; command has been executed since the last use of the query.</source>
          <target state="translated">&lt;code&gt;VK_QUERY_RESULT_WAIT_BIT&lt;/code&gt; 가 &lt;code&gt;VK_QUERY_RESULT_WITH_AVAILABILITY_BIT&lt;/code&gt; 와 함께 사용 되는 경우에도 위의 사항이 적용됩니다 . 이 경우 반환 된 가용성 상태 &lt;strong&gt;는&lt;/strong&gt; 쿼리를 마지막으로 사용한 이후 &lt;code&gt;vkCmdResetQueryPool&lt;/code&gt; 명령을 실행 하지 않은 경우 이전에 쿼리를 사용한 결과를 반영 &lt;strong&gt;할 수&lt;/strong&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf89bfed9ea09ce48da4c21e3ce94056c57420ac" translate="yes" xml:space="preserve">
          <source>The above guarantee avoids a potential memory corruption in scenarios where host writes to a mapped memory object have not been flushed before the memory is unmapped (or freed), and the virtual address range is subsequently reused for a different mapping (or memory allocation).</source>
          <target state="translated">위의 보장은 매핑 된 메모리 객체에 대한 호스트 쓰기가 메모리 매핑 해제 (또는 해제) 전에 플러시되지 않은 후 가상 매핑 범위가 다른 매핑 (또는 메모리 할당)에 재사용되는 시나리오에서 잠재적 인 메모리 손상을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="56daef2d3a345c981074d0521a3db38efd169062" translate="yes" xml:space="preserve">
          <source>The above layout definition allows the descriptor bindings to be specified sparsely such that not all binding numbers between 0 and the maximum binding number need to be specified in the &lt;code&gt;pBindings&lt;/code&gt; array. Bindings that are not specified have a &lt;code&gt;descriptorCount&lt;/code&gt; and &lt;code&gt;stageFlags&lt;/code&gt; of zero, and the &lt;code&gt;descriptorType&lt;/code&gt; is treated as undefined. However, all binding numbers between 0 and the maximum binding number in the &lt;a href=&quot;#VkDescriptorSetLayoutCreateInfo&quot;&gt;VkDescriptorSetLayoutCreateInfo&lt;/a&gt;::&lt;code&gt;pBindings&lt;/code&gt; array &lt;strong&gt;may&lt;/strong&gt; consume memory in the descriptor set layout even if not all descriptor bindings are used, though it &lt;strong&gt;should&lt;/strong&gt; not consume additional memory from the descriptor pool.</source>
          <target state="translated">위의 레이아웃 정의는 디스크립터 바인딩이 드물게 지정되어 0과 최대 바인딩 수 사이의 모든 바인딩 번호가 &lt;code&gt;pBindings&lt;/code&gt; 배열에 지정 될 필요가 없도록합니다 . 지정되지 않은 바인딩은 &lt;code&gt;descriptorCount&lt;/code&gt; 및 &lt;code&gt;stageFlags&lt;/code&gt; 가 0이며 &lt;code&gt;descriptorType&lt;/code&gt; 은 정의되지 않은 것으로 처리됩니다. 그러나 &lt;a href=&quot;#VkDescriptorSetLayoutCreateInfo&quot;&gt;VkDescriptorSetLayoutCreateInfo&lt;/a&gt; 에서 0과 최대 바인딩 수 사이의 모든 바인딩 수 :: &lt;code&gt;pBindings&lt;/code&gt; 배열의 모든 디스크립터 바인딩이 사용 되지 &lt;strong&gt;는&lt;/strong&gt; 않지만 디스크립터 풀에서 추가 메모리를 소비 하지는 않지만 디스크립터 세트 레이아웃에서 메모리를 소비 &lt;strong&gt;할 수&lt;/strong&gt; 있습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80cb686d3f7b8d3d2a7c9259bbdd943307d90e08" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;mipLodBias&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than or equal to &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt;::&lt;code&gt;maxSamplerLodBias&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mipLodBias&lt;/code&gt; 의 절대 값&lt;strong&gt; 해야&lt;/strong&gt; 미만 또는 동등 &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; :: &lt;code&gt;maxSamplerLodBias&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="acea91dc9ebaac70dd26e5b7789fd22f7fc73c17" translate="yes" xml:space="preserve">
          <source>The allocated descriptor sets are returned in &lt;code&gt;pDescriptorSets&lt;/code&gt;.</source>
          <target state="translated">할당 된 디스크립터 세트는 &lt;code&gt;pDescriptorSets&lt;/code&gt; 로 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="710d39fa7e15c8f09a8933107fedfa184e5e96eb" translate="yes" xml:space="preserve">
          <source>The attachment is not used or preserved in subpass &lt;strong&gt;S&lt;/strong&gt;.</source>
          <target state="translated">첨부 파일은 서브 패스에서 사용되거나 보존되지 않습니다 &lt;strong&gt; S&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="9b505f0513266dbafc4a3eb5b69b264af27413db" translate="yes" xml:space="preserve">
          <source>The attachment is used as a color, depth/stencil, or resolve attachment in any subpass in the render pass.</source>
          <target state="translated">부착물은 렌더 패스의 모든 서브 패스에서 색상, 깊이 / 스텐실 또는 확인 부착물로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a6a0f359d66b01efceb00826f885257f4c5b9851" translate="yes" xml:space="preserve">
          <source>The bias value o for a polygon is</source>
          <target state="translated">다각형의 바이어스 값 o는</target>
        </trans-unit>
        <trans-unit id="aa5717c4b74219f0b6297b247fb605cb3fb4ff46" translate="yes" xml:space="preserve">
          <source>The blending operation produces a new set of values R, G, B and A, which are written to the framebuffer attachment. If blending is not enabled for this attachment, then R, G, B and A are assigned R&lt;sub&gt;s0&lt;/sub&gt;, G&lt;sub&gt;s0&lt;/sub&gt;, B&lt;sub&gt;s0&lt;/sub&gt; and A&lt;sub&gt;s0&lt;/sub&gt;, respectively.</source>
          <target state="translated">블렌딩 작업은 새로운 값의 R, G, B 및 A 세트를 생성하며, 이는 프레임 버퍼 첨부에 기록됩니다. 이 어태치먼트에 블렌딩을 사용할 수없는 경우 R, G, B 및 A에 R &lt;sub&gt;s0&lt;/sub&gt; , G &lt;sub&gt;s0&lt;/sub&gt; , B &lt;sub&gt;s0&lt;/sub&gt; 및 A 가 할당됩니다&lt;sub&gt; s0&lt;/sub&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="565496b76a3aa0506509ae2ced78c3cc7301c7f4" translate="yes" xml:space="preserve">
          <source>The buffer region specified by a given element of &lt;code&gt;pRegions&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a region that is contained within &lt;code&gt;dstBuffer&lt;/code&gt;</source>
          <target state="translated">주어진 &lt;code&gt;pRegions&lt;/code&gt; 요소에 의해 지정된 버퍼 영역 &lt;strong&gt;은&lt;/strong&gt; 내에 포함되는 영역이 될 &lt;code&gt;dstBuffer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="86296d853eed9afa2ea25b351f82b90c9ff01780" translate="yes" xml:space="preserve">
          <source>The buffer region specified by a given element of &lt;code&gt;pRegions&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a region that is contained within &lt;code&gt;srcBuffer&lt;/code&gt;</source>
          <target state="translated">지정된 &lt;code&gt;pRegions&lt;/code&gt; 요소로 지정된 버퍼 영역 은 내에 포함 된 영역 &lt;strong&gt;이어야&lt;/strong&gt; 합니다. &lt;code&gt;srcBuffer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5f019de8b8f115f7409d4cc544afe149fa8d33df" translate="yes" xml:space="preserve">
          <source>The color write mask operation is applied regardless of whether blending is enabled.</source>
          <target state="translated">색상 쓰기 마스크 작업은 혼합 사용 여부에 관계없이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="12d74f95e1e366bc99f8bb0f59524468df0c88e4" translate="yes" xml:space="preserve">
          <source>The combination of &lt;code&gt;format&lt;/code&gt;, &lt;code&gt;imageType&lt;/code&gt;, &lt;code&gt;tiling&lt;/code&gt;, &lt;code&gt;usage&lt;/code&gt;, and &lt;code&gt;flags&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be supported, as indicated by a &lt;code&gt;VK_SUCCESS&lt;/code&gt; return value from &lt;code&gt;vkGetPhysicalDeviceImageFormatProperties&lt;/code&gt; invoked with the same values passed to the corresponding parameters.</source>
          <target state="translated">대응하는 매개 변수에 전달 된 동일한 값으로 호출 된 &lt;code&gt;vkGetPhysicalDeviceImageFormatProperties&lt;/code&gt; 의 &lt;code&gt;VK_SUCCESS&lt;/code&gt; 리턴 값 으로 표시 되는대로 &lt;code&gt;format&lt;/code&gt; , &lt;code&gt;imageType&lt;/code&gt; , &lt;code&gt;tiling&lt;/code&gt; , &lt;code&gt;usage&lt;/code&gt; 및 &lt;code&gt;flags&lt;/code&gt; 조합이 지원 &lt;strong&gt;되어야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="00f46cc5ae868f238e8b29b2f3b4e69fd8dad4bf" translate="yes" xml:space="preserve">
          <source>The command pool&amp;rsquo;s queue family &lt;strong&gt;must&lt;/strong&gt; support a non-zero &lt;code&gt;timestampValidBits&lt;/code&gt;</source>
          <target state="translated">명령 풀의 큐 제품군 &lt;strong&gt;은&lt;/strong&gt; 0이 아닌 시간 &lt;code&gt;timestampValidBits&lt;/code&gt; 지원</target>
        </trans-unit>
        <trans-unit id="c2eb3c0c02419238d4ae7042a76a78181edb689e" translate="yes" xml:space="preserve">
          <source>The conditions leading to an optimal &lt;code&gt;renderArea&lt;/code&gt; are:</source>
          <target state="translated">최적의 &lt;code&gt;renderArea&lt;/code&gt; 이어지는 조건 로 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="50cb7c27ca8d62fb8fe3f0b869c6048232e2ce62" translate="yes" xml:space="preserve">
          <source>The contents of an attachment within the render area become undefined at the start of a subpass &lt;strong&gt;S&lt;/strong&gt; if all of the following conditions are true:</source>
          <target state="translated">서브 패스 &lt;strong&gt;S&lt;/strong&gt; 의 시작에서 렌더 영역 내의 부착물의 내용은 정의되지 않는다&lt;strong&gt;&lt;/strong&gt;다음 조건이 모두 충족되면 .</target>
        </trans-unit>
        <trans-unit id="a81b652043754cc83df106b77ecdb9353fb11230" translate="yes" xml:space="preserve">
          <source>The created descriptor pool is returned in &lt;code&gt;pDescriptorPool&lt;/code&gt;.</source>
          <target state="translated">작성된 디스크립터 풀은 &lt;code&gt;pDescriptorPool&lt;/code&gt; 에 리턴됩니다 . .</target>
        </trans-unit>
        <trans-unit id="c756ee750341c4330bf0825cc0ec5072a4791252" translate="yes" xml:space="preserve">
          <source>The current render pass &lt;strong&gt;must&lt;/strong&gt; be &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-compatibility&quot;&gt;compatible&lt;/a&gt; with the &lt;code&gt;renderPass&lt;/code&gt; member of the &lt;code&gt;VkGraphicsPipelineCreateInfo&lt;/code&gt; structure specified when creating the &lt;code&gt;VkPipeline&lt;/code&gt; currently bound to &lt;code&gt;VK_PIPELINE_BIND_POINT_GRAPHICS&lt;/code&gt;.</source>
          <target state="translated">현재는 패스 렌더링 &lt;strong&gt;해야&lt;/strong&gt; 할 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#renderpass-compatibility&quot;&gt;호환&lt;/a&gt; 와 &lt;code&gt;renderPass&lt;/code&gt; 의 의 구성원 &lt;code&gt;VkGraphicsPipelineCreateInfo&lt;/code&gt; 의 만들 때 구조 지정된 &lt;code&gt;VkPipeline&lt;/code&gt; 현재 바인딩 &lt;code&gt;VK_PIPELINE_BIND_POINT_GRAPHICS&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="b523df2a28c7478cef06a2fb3291fd00d2d3a575" translate="yes" xml:space="preserve">
          <source>The current subpass index &lt;strong&gt;must&lt;/strong&gt; be equal to the number of subpasses in the render pass minus one</source>
          <target state="translated">현재 서브 패스 인덱스 &lt;strong&gt; 는&lt;/strong&gt; 렌더 패스의 서브 패스 수에서 1을 뺀 것과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="a83e57eda77585091f28f607f26e101161189cf2" translate="yes" xml:space="preserve">
          <source>The current subpass index &lt;strong&gt;must&lt;/strong&gt; be less than the number of subpasses in the render pass minus one</source>
          <target state="translated">현재 서브 패스 인덱스 &lt;strong&gt;는&lt;/strong&gt; 렌더 패스의 서브 패스 수에서 1을 뺀 수보다 작아야합니다.</target>
        </trans-unit>
        <trans-unit id="b97b5e972908be5dcd30074a9cd15f959831395c" translate="yes" xml:space="preserve">
          <source>The currently bound graphics pipeline &lt;strong&gt;must&lt;/strong&gt; have been created with the &lt;code&gt;VK_DYNAMIC_STATE_BLEND_CONSTANTS&lt;/code&gt; dynamic state enabled</source>
          <target state="translated">현재 바인드 된 그래픽 파이프 라인 &lt;strong&gt;은 &lt;/strong&gt; &lt;code&gt;VK_DYNAMIC_STATE_BLEND_CONSTANTS&lt;/code&gt; 로 생성 &lt;strong&gt;해야합니다.&lt;/strong&gt; 동적 상태를 사용</target>
        </trans-unit>
        <trans-unit id="35ecdff218ae9491544c29302f00f3c55f7f4e92" translate="yes" xml:space="preserve">
          <source>The currently bound graphics pipeline &lt;strong&gt;must&lt;/strong&gt; have been created with the &lt;code&gt;VK_DYNAMIC_STATE_DEPTH_BIAS&lt;/code&gt; dynamic state enabled</source>
          <target state="translated">현재 바인드 된 그래픽 파이프 라인 &lt;strong&gt;은 &lt;/strong&gt; &lt;code&gt;VK_DYNAMIC_STATE_DEPTH_BIAS&lt;/code&gt; 로 생성 &lt;strong&gt;해야합니다.&lt;/strong&gt; 동적 상태를 사용</target>
        </trans-unit>
        <trans-unit id="a4e8acb181b547d821366967d07461678b13b736" translate="yes" xml:space="preserve">
          <source>The currently bound graphics pipeline &lt;strong&gt;must&lt;/strong&gt; have been created with the &lt;code&gt;VK_DYNAMIC_STATE_DEPTH_BOUNDS&lt;/code&gt; dynamic state enabled</source>
          <target state="translated">현재 바인드 된 그래픽 파이프 라인 &lt;strong&gt;은 &lt;/strong&gt; &lt;code&gt;VK_DYNAMIC_STATE_DEPTH_BOUNDS&lt;/code&gt; 로 생성 &lt;strong&gt;해야합니다.&lt;/strong&gt; 동적 상태를 사용</target>
        </trans-unit>
        <trans-unit id="15942d1ea9b7ed8626bf0053742c26b804840926" translate="yes" xml:space="preserve">
          <source>The currently bound graphics pipeline &lt;strong&gt;must&lt;/strong&gt; have been created with the &lt;code&gt;VK_DYNAMIC_STATE_LINE_WIDTH&lt;/code&gt; dynamic state enabled</source>
          <target state="translated">현재 바인딩 된 그래픽 파이프 라인 &lt;strong&gt;은 &lt;/strong&gt; &lt;code&gt;VK_DYNAMIC_STATE_LINE_WIDTH&lt;/code&gt; 로 생성 &lt;strong&gt;해야합니다.&lt;/strong&gt; 동적 상태를 사용</target>
        </trans-unit>
        <trans-unit id="9b23210ee9f0b7a0c91428b46063dc08a54f0775" translate="yes" xml:space="preserve">
          <source>The currently bound graphics pipeline &lt;strong&gt;must&lt;/strong&gt; have been created with the &lt;code&gt;VK_DYNAMIC_STATE_SCISSOR&lt;/code&gt; dynamic state enabled</source>
          <target state="translated">현재 바인드 된 그래픽 파이프 라인 &lt;strong&gt;은 &lt;/strong&gt; &lt;code&gt;VK_DYNAMIC_STATE_SCISSOR&lt;/code&gt; 로 생성 &lt;strong&gt;해야합니다.&lt;/strong&gt; 동적 상태를 사용</target>
        </trans-unit>
        <trans-unit id="db4d20d8da07c85e1330290da187eb65d77d7f8a" translate="yes" xml:space="preserve">
          <source>The currently bound graphics pipeline &lt;strong&gt;must&lt;/strong&gt; have been created with the &lt;code&gt;VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK&lt;/code&gt; dynamic state enabled</source>
          <target state="translated">현재 바인드 된 그래픽 파이프 라인 &lt;strong&gt;은 &lt;/strong&gt; &lt;code&gt;VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK&lt;/code&gt; 로 생성 &lt;strong&gt;해야합니다.&lt;/strong&gt; 동적 상태를 사용</target>
        </trans-unit>
        <trans-unit id="09c254f63a832e7453a4d843cd3f7ac08a60c41d" translate="yes" xml:space="preserve">
          <source>The currently bound graphics pipeline &lt;strong&gt;must&lt;/strong&gt; have been created with the &lt;code&gt;VK_DYNAMIC_STATE_STENCIL_REFERENCE&lt;/code&gt; dynamic state enabled</source>
          <target state="translated">현재 바인드 된 그래픽 파이프 라인 &lt;strong&gt;은 &lt;/strong&gt; &lt;code&gt;VK_DYNAMIC_STATE_STENCIL_REFERENCE&lt;/code&gt; 로 생성 &lt;strong&gt;해야합니다.&lt;/strong&gt; 동적 상태를 사용</target>
        </trans-unit>
        <trans-unit id="88d292a68900a85230c2c67d1f7b53571615fb90" translate="yes" xml:space="preserve">
          <source>The currently bound graphics pipeline &lt;strong&gt;must&lt;/strong&gt; have been created with the &lt;code&gt;VK_DYNAMIC_STATE_STENCIL_WRITE_MASK&lt;/code&gt; dynamic state enabled</source>
          <target state="translated">현재 바인드 된 그래픽 파이프 라인 &lt;strong&gt;은 &lt;/strong&gt; &lt;code&gt;VK_DYNAMIC_STATE_STENCIL_WRITE_MASK&lt;/code&gt; 로 생성 &lt;strong&gt;해야합니다.&lt;/strong&gt; 동적 상태를 사용</target>
        </trans-unit>
        <trans-unit id="30b15ce9e6e3d2a0477f955a8c618f174e78b8ff" translate="yes" xml:space="preserve">
          <source>The currently bound graphics pipeline &lt;strong&gt;must&lt;/strong&gt; have been created with the &lt;code&gt;VK_DYNAMIC_STATE_VIEWPORT&lt;/code&gt; dynamic state enabled</source>
          <target state="translated">현재 바인드 된 그래픽 파이프 라인 &lt;strong&gt;은 &lt;/strong&gt; &lt;code&gt;VK_DYNAMIC_STATE_VIEWPORT&lt;/code&gt; 동적 상태를 사용 하여 생성 &lt;strong&gt;해야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="db8a84e06d4430264416004b8e4c0843b3045a85" translate="yes" xml:space="preserve">
          <source>The definition of &lt;a href=&quot;#PFN_vkVoidFunction&quot;&gt;PFN_vkVoidFunction&lt;/a&gt; is:</source>
          <target state="translated">&lt;a href=&quot;#PFN_vkVoidFunction&quot;&gt;PFN_vkVoidFunction&lt;/a&gt; 의 정의는 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cfe93afb35386af9625bca9df468f2cf686963f7" translate="yes" xml:space="preserve">
          <source>The depth bounds test conditionally disables coverage of a sample based on the outcome of a comparison between the value z&lt;sub&gt;a&lt;/sub&gt; in the depth attachment at location (x&lt;sub&gt;f&lt;/sub&gt;,y&lt;sub&gt;f&lt;/sub&gt;) (for the appropriate sample) and a range of values. The test is enabled or disabled by the &lt;code&gt;depthBoundsTestEnable&lt;/code&gt; member of &lt;a href=&quot;#VkPipelineDepthStencilStateCreateInfo&quot;&gt;VkPipelineDepthStencilStateCreateInfo&lt;/a&gt;: If the pipeline state object is created without the &lt;code&gt;VK_DYNAMIC_STATE_DEPTH_BOUNDS&lt;/code&gt; dynamic state enabled then the range of values used in the depth bounds test are defined by the &lt;code&gt;minDepthBounds&lt;/code&gt; and &lt;code&gt;maxDepthBounds&lt;/code&gt; members of the &lt;a href=&quot;#VkPipelineDepthStencilStateCreateInfo&quot;&gt;VkPipelineDepthStencilStateCreateInfo&lt;/a&gt; structure. Otherwise, to dynamically set the depth bounds range values call:</source>
          <target state="translated">깊이 한계 테스트 는 위치 (x &lt;sub&gt;f&lt;/sub&gt; , y &lt;sub&gt;f&lt;/sub&gt; ) 에서 깊이 첨부 의 값 z &lt;sub&gt;a&lt;/sub&gt; (적절한 샘플에 대한)와 값 범위 사이의 비교 결과에 따라 샘플의 적용 범위를 조건부로 비활성화 합니다. 시험은으로 활성화 또는 비활성화 &lt;code&gt;depthBoundsTestEnable&lt;/code&gt; 의 부재 &lt;a href=&quot;#VkPipelineDepthStencilStateCreateInfo&quot;&gt;VkPipelineDepthStencilStateCreateInfo&lt;/a&gt; : 관로 상태 객체가없이 생성되어있는 경우 &lt;code&gt;VK_DYNAMIC_STATE_DEPTH_BOUNDS&lt;/code&gt; 의 동적 상태는 다음에 의해 정의되는 깊이 범위 테스트에 사용되는 값의 범위를 사용할 &lt;code&gt;minDepthBounds&lt;/code&gt; 및 &lt;code&gt;maxDepthBounds&lt;/code&gt; 의 부재 &lt;a href=&quot;#VkPipelineDepthStencilStateCreateInfo&quot;&gt;VkPipelineDepthStencilStateCreateInfo을&lt;/a&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;구조. 그렇지 않으면 깊이 범위 범위 값을 동적으로 설정하려면 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="e41c7161827f899f311a2e5859f58e0b3a33000f" translate="yes" xml:space="preserve">
          <source>The depth values of all fragments generated by the rasterization of a polygon &lt;strong&gt;can&lt;/strong&gt; be offset by a single value that is computed for that polygon. This behavior is controlled by the &lt;code&gt;depthBiasEnable&lt;/code&gt;, &lt;code&gt;depthBiasConstantFactor&lt;/code&gt;, &lt;code&gt;depthBiasClamp&lt;/code&gt;, and &lt;code&gt;depthBiasSlopeFactor&lt;/code&gt; members of &lt;a href=&quot;#VkPipelineRasterizationStateCreateInfo&quot;&gt;VkPipelineRasterizationStateCreateInfo&lt;/a&gt;, or by the corresponding parameters to the &lt;code&gt;vkCmdSetDepthBias&lt;/code&gt; command if depth bias state is dynamic.</source>
          <target state="translated">다각형의 래스터 화로 생성 된 모든 조각의 깊이 값은 해당 다각형에 대해 계산 된 단일 값으로 오프셋 될 &lt;strong&gt;수&lt;/strong&gt; 있습니다. 이 동작에 의해 제어된다 &lt;code&gt;depthBiasEnable&lt;/code&gt; , &lt;code&gt;depthBiasConstantFactor&lt;/code&gt; , &lt;code&gt;depthBiasClamp&lt;/code&gt; 및 &lt;code&gt;depthBiasSlopeFactor&lt;/code&gt; 의 구성원 &lt;a href=&quot;#VkPipelineRasterizationStateCreateInfo&quot;&gt;VkPipelineRasterizationStateCreateInfo&lt;/a&gt; 또는에 대응하는 파라미터에 의해 &lt;code&gt;vkCmdSetDepthBias&lt;/code&gt; 깊이 바이어스 상태가 동적 인 경우 명령.</target>
        </trans-unit>
        <trans-unit id="a5425ef20d59c0a9036bace40c57cd217d1c9cc0" translate="yes" xml:space="preserve">
          <source>The descriptor set contents bound by a call to &lt;code&gt;vkCmdBindDescriptorSets&lt;/code&gt;&lt;strong&gt;may&lt;/strong&gt; be consumed during host execution of the command, or during shader execution of the resulting draws, or any time in between. Thus, the contents &lt;strong&gt;must&lt;/strong&gt; not be altered (overwritten by an update command, or freed) between when the command is recorded and when the command completes executing on the queue. The contents of &lt;code&gt;pDynamicOffsets&lt;/code&gt; are consumed immediately during execution of &lt;code&gt;vkCmdBindDescriptorSets&lt;/code&gt;. Once all pending uses have completed, it is legal to update and reuse a descriptor set.</source>
          <target state="translated">&lt;code&gt;vkCmdBindDescriptorSets&lt;/code&gt; 에 대한 호출에 의해 바인드 된 디스크립터 세트 컨텐츠 는 명령의 호스트 실행 중 또는 결과 드로우의 쉐이더 실행 중 또는 그 사이의 시간 동안 사용될 &lt;strong&gt;수&lt;/strong&gt; 있습니다. 따라서 명령이 기록 될 때와 명령이 큐에서 실행을 완료 할 때 사이에 내용을 변경 (업데이트 명령으로 덮어 쓰기 또는 해제) &lt;strong&gt;해서는&lt;/strong&gt; 안됩니다. &lt;code&gt;pDynamicOffsets&lt;/code&gt; 의 내용은 &lt;code&gt;vkCmdBindDescriptorSets&lt;/code&gt; 를 실행하는 동안 즉시 사용됩니다 . 보류중인 모든 사용이 완료되면 디스크립터 세트를 업데이트하고 재사용하는 것이 합법적입니다.</target>
        </trans-unit>
        <trans-unit id="aea000d1fdd9247f509123a494a5b76770e7469b" translate="yes" xml:space="preserve">
          <source>The destination region specified by a given element of &lt;code&gt;pRegions&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a region that is contained within &lt;code&gt;dstImage&lt;/code&gt;</source>
          <target state="translated">주어진 요소에 의해 지정된 목적지 영역 &lt;code&gt;pRegions&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 내에 포함되는 영역이 될 &lt;code&gt;dstImage&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aa509db1bafcc77f4615a0c63ca921a0db9a046e" translate="yes" xml:space="preserve">
          <source>The details of the merge operation are implementation dependent, but implementations &lt;strong&gt;should&lt;/strong&gt; merge the contents of the specified pipelines and prune duplicate entries.</source>
          <target state="translated">병합 작업의 세부 사항은 구현에 의존하지만, 구현 &lt;strong&gt;해야&lt;/strong&gt; 지정된 파이프 라인의 내용을 병합하고 중복 된 항목을 치기.</target>
        </trans-unit>
        <trans-unit id="1488e0aea1834f68f8a9f1b9bc881fefc6fef565" translate="yes" xml:space="preserve">
          <source>The device has been lost. See &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-lost-device&quot;&gt;Lost Device&lt;/a&gt;.</source>
          <target state="translated">장치가 분실되었습니다. &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#devsandqueues-lost-device&quot;&gt;장치 분실을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="382f5e2cfd135b2147657b9579d44f1365f64c13" translate="yes" xml:space="preserve">
          <source>The effective offset used for dynamic uniform and storage buffer bindings is the sum of the relative offset taken from &lt;code&gt;pDynamicOffsets&lt;/code&gt;, and the base address of the buffer plus base offset in the descriptor set. The length of the dynamic uniform and storage buffer bindings is the buffer range as specified in the descriptor set.</source>
          <target state="translated">동적 균일 및 스토리지 버퍼 바인딩에 사용 된 유효 오프셋은 &lt;code&gt;pDynamicOffsets&lt;/code&gt; 에서 가져온 상대 오프셋 과 디스크립터 세트의 버퍼의 기본 주소와 기본 오프셋의 합입니다. 동적 균일 및 저장 버퍼 바인딩의 길이는 디스크립터 세트에 지정된 버퍼 범위입니다.</target>
        </trans-unit>
        <trans-unit id="c678a8ed2a8ebdb69e8ccabf05f91ff6439cc752" translate="yes" xml:space="preserve">
          <source>The elements of the sample mask array are of type &lt;code&gt;VkSampleMask&lt;/code&gt;, each representing 32 bits of coverage information:</source>
          <target state="translated">샘플 마스크 배열의 요소는 &lt;code&gt;VkSampleMask&lt;/code&gt; 유형 이며 각각 32 비트의 적용 범위 정보를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0dfb1028299f1ad35aa097a44ef59c28589e3f02" translate="yes" xml:space="preserve">
          <source>The equivalent to &lt;code&gt;newLayout&lt;/code&gt; is the attachment&amp;rsquo;s layout according to the subpass description for &lt;code&gt;dstSubpass&lt;/code&gt;.</source>
          <target state="translated">에 상응 &lt;code&gt;newLayout&lt;/code&gt; 을 위한 subpass 설명에 따른 접속의 배치도이다 &lt;code&gt;dstSubpass&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ede059e8d00eb9bd9d71af3a314286f9b8949d16" translate="yes" xml:space="preserve">
          <source>The equivalent to &lt;code&gt;oldLayout&lt;/code&gt; is the attachment&amp;rsquo;s layout according to the subpass description for &lt;code&gt;srcSubpass&lt;/code&gt;.</source>
          <target state="translated">에 상응 &lt;code&gt;oldLayout&lt;/code&gt; 을 위한 subpass 설명에 따른 접속의 배치도이다 &lt;code&gt;srcSubpass&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6e7639cbfe2fcd1c2eb8819c9d33d36a596d133" translate="yes" xml:space="preserve">
          <source>The event specified by &lt;code&gt;event&lt;/code&gt; is signaled.</source>
          <target state="translated">event에 의해 지정된 &lt;code&gt;event&lt;/code&gt; 가 시그널링됩니다.</target>
        </trans-unit>
        <trans-unit id="e9cafdd1b0b8f15c2a15b98715b015b1e9e5bd6d" translate="yes" xml:space="preserve">
          <source>The event specified by &lt;code&gt;event&lt;/code&gt; is unsignaled.</source>
          <target state="translated">event에 의해 지정된 &lt;code&gt;event&lt;/code&gt; 는 신호가 없습니다.</target>
        </trans-unit>
        <trans-unit id="65fd257ce7422e177bd432e60ee56ddc16f07848" translate="yes" xml:space="preserve">
          <source>The exact image view type is partially implicit, based on the image&amp;rsquo;s type and sample count, as well as the view creation parameters as described in the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#resources-image-views-compatibility&quot;&gt;image view compatibility table&lt;/a&gt; for &lt;a href=&quot;#vkCreateImageView&quot;&gt;vkCreateImageView&lt;/a&gt;. This table also shows which SPIR-V &lt;code&gt;OpTypeImage&lt;/code&gt;&lt;code&gt;Dim&lt;/code&gt; and &lt;code&gt;Arrayed&lt;/code&gt; parameters correspond to each image view type.</source>
          <target state="translated">정확한 이미지보기 유형은 이미지의 유형 및 샘플 수와 &lt;a href=&quot;#vkCreateImageView&quot;&gt;vkCreateImageView&lt;/a&gt; 의 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#resources-image-views-compatibility&quot;&gt;이미지보기 호환성 테이블&lt;/a&gt; 에 설명 된보기 작성 매개 변수를 기반으로 부분적으로 암시 적 입니다. SPIR-V이 표는 &lt;code&gt;OpTypeImage&lt;/code&gt; &lt;code&gt;Dim&lt;/code&gt; 하고 &lt;code&gt;Arrayed&lt;/code&gt; 파라미터는 각 화상 타입 뷰에 대응한다.</target>
        </trans-unit>
        <trans-unit id="d838b31a1114821e01aa666eead8d7ced1ed8285" translate="yes" xml:space="preserve">
          <source>The fence specified by &lt;code&gt;fence&lt;/code&gt; is signaled.</source>
          <target state="translated">펜스가 지정한 &lt;code&gt;fence&lt;/code&gt; 가 신호를받습니다.</target>
        </trans-unit>
        <trans-unit id="edc73308b803087d7dc3897a77cef8cbe639790c" translate="yes" xml:space="preserve">
          <source>The fence specified by &lt;code&gt;fence&lt;/code&gt; is unsignaled.</source>
          <target state="translated">펜스로 지정된 &lt;code&gt;fence&lt;/code&gt; 는 신호가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d00b25d47ef03526f1da69bb81bc43cf61e6d9b3" translate="yes" xml:space="preserve">
          <source>The first &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes&quot;&gt;access scope&lt;/a&gt; is limited to access in the pipeline stages determined by the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks&quot;&gt;source stage mask&lt;/a&gt; specified by &lt;code&gt;srcStageMask&lt;/code&gt;. It is also limited to access types in the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks&quot;&gt;source access mask&lt;/a&gt; specified by &lt;code&gt;srcAccessMask&lt;/code&gt;.</source>
          <target state="translated">첫 번째 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes&quot;&gt;액세스 범위&lt;/a&gt; 는 &lt;code&gt;srcStageMask&lt;/code&gt; 에 의해 지정된 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks&quot;&gt;소스 스테이지 마스크에&lt;/a&gt; 의해 결정된 파이프 라인 단계에서의 액세스로 제한됩니다 . 또한 &lt;code&gt;srcAccessMask&lt;/code&gt; 로 지정된 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks&quot;&gt;소스 액세스 마스크&lt;/a&gt; 의 액세스 유형으로 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="0dd28dd06912021101bc65025a2011470efbf7e3" translate="yes" xml:space="preserve">
          <source>The first &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes&quot;&gt;access scope&lt;/a&gt; is limited to access in the pipeline stages determined by the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks&quot;&gt;source stage mask&lt;/a&gt; specified by &lt;code&gt;srcStageMask&lt;/code&gt;. Within that, the first access scope only includes the first access scopes defined by elements of the &lt;code&gt;pMemoryBarriers&lt;/code&gt;, &lt;code&gt;pBufferMemoryBarriers&lt;/code&gt; and &lt;code&gt;pImageMemoryBarriers&lt;/code&gt; arrays, which each define a set of &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-memory-barriers&quot;&gt;memory barriers&lt;/a&gt;. If no memory barriers are specified, then the first access scope includes no accesses.</source>
          <target state="translated">첫 번째 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes&quot;&gt;액세스 범위&lt;/a&gt; 는 &lt;code&gt;srcStageMask&lt;/code&gt; 에 의해 지정된 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks&quot;&gt;소스 스테이지 마스크에&lt;/a&gt; 의해 결정된 파이프 라인 단계에서의 액세스로 제한됩니다 . 그 안에있는 첫 번째 액세스 범위에는 &lt;code&gt;pMemoryBarriers&lt;/code&gt; , &lt;code&gt;pBufferMemoryBarriers&lt;/code&gt; 및 &lt;code&gt;pImageMemoryBarriers&lt;/code&gt; 배열의 요소로 정의 된 첫 번째 액세스 범위 만 포함되며 , 각각의 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-memory-barriers&quot;&gt;메모리 배리어&lt;/a&gt; 세트를 정의합니다 . 메모리 장벽이 지정되지 않으면 첫 번째 액세스 범위에 액세스가 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e492da86eede953cfa6a34c65b9acbf693f0d25b" translate="yes" xml:space="preserve">
          <source>The first &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes&quot;&gt;access scope&lt;/a&gt; is limited to access to memory through the specified buffer range, via access types in the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks&quot;&gt;source access mask&lt;/a&gt; specified by &lt;code&gt;srcAccessMask&lt;/code&gt;. If &lt;code&gt;srcAccessMask&lt;/code&gt; includes &lt;code&gt;VK_ACCESS_HOST_WRITE_BIT&lt;/code&gt;, memory writes performed by that access type are also made visible, as that access type is not performed through a resource.</source>
          <target state="translated">첫 번째 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes&quot;&gt;액세스 범위&lt;/a&gt; 는 &lt;code&gt;srcAccessMask&lt;/code&gt; 로 지정된 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks&quot;&gt;소스 액세스 마스크&lt;/a&gt; 의 액세스 유형을 통해 지정된 버퍼 범위를 통해 메모리에 액세스하도록 제한됩니다 . 경우 &lt;code&gt;srcAccessMask&lt;/code&gt; 가 포함 &lt;code&gt;VK_ACCESS_HOST_WRITE_BIT&lt;/code&gt; 를 , 그 메모리 액세스 유형 의한 기록하는 접근 방식은 자원을 통해 수행되지 않는도 보이게된다.</target>
        </trans-unit>
        <trans-unit id="9247f95b382b547d5c431d1543727dd6f02b99ae" translate="yes" xml:space="preserve">
          <source>The first &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes&quot;&gt;access scope&lt;/a&gt; is limited to access to memory through the specified image subresource range, via access types in the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks&quot;&gt;source access mask&lt;/a&gt; specified by &lt;code&gt;srcAccessMask&lt;/code&gt;. If &lt;code&gt;srcAccessMask&lt;/code&gt; includes &lt;code&gt;VK_ACCESS_HOST_WRITE_BIT&lt;/code&gt;, memory writes performed by that access type are also made visible, as that access type is not performed through a resource.</source>
          <target state="translated">첫 번째 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes&quot;&gt;액세스 범위&lt;/a&gt; 는 &lt;code&gt;srcAccessMask&lt;/code&gt; 로 지정된 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks&quot;&gt;소스 액세스 마스크&lt;/a&gt; 의 액세스 유형을 통해 지정된 이미지 하위 리소스 범위를 통해 메모리에 액세스하도록 제한됩니다 . 경우 &lt;code&gt;srcAccessMask&lt;/code&gt; 가 포함 &lt;code&gt;VK_ACCESS_HOST_WRITE_BIT&lt;/code&gt; 를 , 그 메모리 액세스 유형 의한 기록하는 접근 방식은 자원을 통해 수행되지 않는도 보이게된다.</target>
        </trans-unit>
        <trans-unit id="1abeefbc36a3864c139f34e0e0319c20852afa1b" translate="yes" xml:space="preserve">
          <source>The first &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes&quot;&gt;access scope&lt;/a&gt; is limited to access types in the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks&quot;&gt;source access mask&lt;/a&gt; specified by &lt;code&gt;srcAccessMask&lt;/code&gt;.</source>
          <target state="translated">첫 번째 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes&quot;&gt;액세스 범위&lt;/a&gt; 는 &lt;code&gt;srcAccessMask&lt;/code&gt; 로 지정된 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks&quot;&gt;소스 액세스 마스크&lt;/a&gt; 의 액세스 유형으로 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b60353fa8805fa41f7ddc5f7b05159d0fb40a24" translate="yes" xml:space="preserve">
          <source>The first &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-scopes&quot;&gt;synchronization scope&lt;/a&gt; includes every command previously submitted to the same queue, including those in the same command buffer and batch. The synchronization scope is limited to operations on the pipeline stages determined by the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks&quot;&gt;source stage mask&lt;/a&gt; specified by &lt;code&gt;stageMask&lt;/code&gt;.</source>
          <target state="translated">첫 번째 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-scopes&quot;&gt;동기화 범위&lt;/a&gt; 에는 동일한 명령 버퍼 및 배치의 명령을 포함하여 이전에 동일한 대기열에 제출 된 모든 명령이 포함됩니다. 동기화 범위는 &lt;code&gt;stageMask&lt;/code&gt; 로 지정된 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks&quot;&gt;소스 스테이지 마스크에&lt;/a&gt; 의해 결정된 파이프 라인 스테이지에서의 조작으로 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="9882c112cd2476eacde68f380835624749568289" translate="yes" xml:space="preserve">
          <source>The first four bytes encode the length of the entire pipeline header, in bytes. This value includes all fields in the header including the pipeline cache version field and the size of the length field.</source>
          <target state="translated">처음 4 바이트는 전체 파이프 라인 헤더의 길이를 바이트 단위로 인코딩합니다. 이 값에는 파이프 라인 캐시 버전 필드 및 길이 필드의 크기를 포함하여 헤더의 모든 필드가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e5cf8c105b1ba372cb813ecaa7b2b837623dfbe2" translate="yes" xml:space="preserve">
          <source>The first step of polygon rasterization is to determine whether the triangle is &lt;em&gt;back-facing&lt;/em&gt; or &lt;em&gt;front-facing&lt;/em&gt;. This determination is made based on the sign of the (clipped or unclipped) polygon&amp;rsquo;s area computed in framebuffer coordinates. One way to compute this area is:</source>
          <target state="translated">다각형 래스터 화의 첫 번째 단계는 삼각형이 &lt;em&gt;후면&lt;/em&gt; 인지 &lt;em&gt;정면&lt;/em&gt; 인지를 결정하는 것 입니다. 이 결정은 프레임 버퍼 좌표로 계산 된 (클리핑 또는 비 클리핑 된) 다각형 영역의 부호를 기반으로합니다. 이 영역을 계산하는 한 가지 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="226d5138064ec81a9e29b2c08e1448b087198c8b" translate="yes" xml:space="preserve">
          <source>The first synchronization scope only includes event signal operations that operate on members of &lt;code&gt;pEvents&lt;/code&gt;, and the operations that happened-before the event signal operations. Event signal operations performed by &lt;a href=&quot;#vkCmdSetEvent&quot;&gt;vkCmdSetEvent&lt;/a&gt; that were previously submitted to the same queue are included in the first synchronization scope, if the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-order&quot;&gt;logically latest&lt;/a&gt; pipeline stage in their &lt;code&gt;stageMask&lt;/code&gt; parameter is &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-order&quot;&gt;logically earlier&lt;/a&gt; than or equal to the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-order&quot;&gt;logically latest&lt;/a&gt; pipeline stage in &lt;code&gt;srcStageMask&lt;/code&gt;. Event signal operations performed by &lt;a href=&quot;#vkSetEvent&quot;&gt;vkSetEvent&lt;/a&gt; are only included in the first synchronization scope if &lt;code&gt;VK_PIPELINE_STAGE_HOST_BIT&lt;/code&gt; is included in &lt;code&gt;srcStageMask&lt;/code&gt;.</source>
          <target state="translated">첫 번째 동기화 범위에는 &lt;code&gt;pEvents&lt;/code&gt; 멤버 에서 작동하는 이벤트 신호 작업과 이벤트 신호 작업 이전에 발생한 작업 만 포함됩니다. 수행 이벤트 신호 연산 &lt;a href=&quot;#vkCmdSetEvent&quot;&gt;vkCmdSetEvent&lt;/a&gt; 경우 생성 이전에 동일한 대기열에 전송하고, 최초의 동기 범위에 포함되는 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-order&quot;&gt;논리적 최신&lt;/a&gt; 자신의 파이프 라인 스테이지 &lt;code&gt;stageMask&lt;/code&gt; 의 파라미터 인 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-order&quot;&gt;논리적으로 이전&lt;/a&gt; 받는 같거나 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-order&quot;&gt;논리적으로 최신&lt;/a&gt; 의 파이프 라인 스테이지 &lt;code&gt;srcStageMask&lt;/code&gt; . &lt;a href=&quot;#vkSetEvent&quot;&gt;vkSetEvent&lt;/a&gt; 가 수행하는 이벤트 신호 조작 은 다음에 포함 된 경우 첫 번째 동기화 범위에만 &lt;code&gt;VK_PIPELINE_STAGE_HOST_BIT&lt;/code&gt; &lt;code&gt;srcStageMask&lt;/code&gt; 에 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="209d85e794f8ee6dafb8b2b39e6c6f87b0930ab1" translate="yes" xml:space="preserve">
          <source>The first vertex index is at an offset of &lt;code&gt;firstIndex&lt;/code&gt; * &lt;code&gt;indexSize&lt;/code&gt; + &lt;code&gt;offset&lt;/code&gt; within the currently bound index buffer, where &lt;code&gt;offset&lt;/code&gt; is the offset specified by &lt;code&gt;vkCmdBindIndexBuffer&lt;/code&gt; and &lt;code&gt;indexSize&lt;/code&gt; is the byte size of the type specified by &lt;code&gt;indexType&lt;/code&gt;. Subsequent index values are retrieved from consecutive locations in the index buffer. Indices are first compared to the primitive restart value, then zero extended to 32 bits (if the &lt;code&gt;indexType&lt;/code&gt; is &lt;code&gt;VK_INDEX_TYPE_UINT16&lt;/code&gt;) and have &lt;code&gt;vertexOffset&lt;/code&gt; added to them, before being supplied as the &lt;code&gt;vertexIndex&lt;/code&gt; value.</source>
          <target state="translated">첫 번째 정점 색인은 현재 바인딩 된 색인 버퍼 내에서 &lt;code&gt;firstIndex&lt;/code&gt; * &lt;code&gt;indexSize&lt;/code&gt; + &lt;code&gt;offset&lt;/code&gt; 의 오프셋에 있습니다. 여기서 &lt;code&gt;offset&lt;/code&gt; 은 &lt;code&gt;vkCmdBindIndexBuffer&lt;/code&gt; 에 의해 지정된 오프셋 이고 &lt;code&gt;indexSize&lt;/code&gt; 는 &lt;code&gt;indexType&lt;/code&gt; 에 의해 지정된 유형의 바이트 크기입니다 . 후속 인덱스 값은 인덱스 버퍼의 연속 위치에서 검색됩니다. 지수 첫번째 재시작 프리미티브 값을 비교 한 후 제로 32 비트로 확장합니다 (경우 &lt;code&gt;indexType&lt;/code&gt; 있다 &lt;code&gt;VK_INDEX_TYPE_UINT16&lt;/code&gt; ) 및 한 &lt;code&gt;vertexOffset&lt;/code&gt; 는 애즈 공급되기 전에, 그 첨가 &lt;code&gt;vertexIndex&lt;/code&gt; 의 값.</target>
        </trans-unit>
        <trans-unit id="991b1d3304070211ebd8bee1a42b0cc6edfaf3b0" translate="yes" xml:space="preserve">
          <source>The floating-point viewport bounds are represented with an &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-limits-viewportSubPixelBits&quot;&gt;implementation-dependent precision&lt;/a&gt;.</source>
          <target state="translated">부동 소수점 뷰포트 경계는 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-limits-viewportSubPixelBits&quot;&gt;구현에 따른 정밀도&lt;/a&gt; 로 표현됩니다 .</target>
        </trans-unit>
        <trans-unit id="cd1d8138f684f4b42c62c0e61b0a0709ff681bf3" translate="yes" xml:space="preserve">
          <source>The following bits &lt;strong&gt;may&lt;/strong&gt; be set in &lt;code&gt;bufferFeatures&lt;/code&gt;, specifying that the features are supported by &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBuffer&quot;&gt;buffers&lt;/a&gt; or &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBufferView&quot;&gt;buffer views&lt;/a&gt; created with the queried &lt;a href=&quot;#vkGetPhysicalDeviceProperties&quot;&gt;vkGetPhysicalDeviceProperties&lt;/a&gt;::&lt;code&gt;format&lt;/code&gt;:</source>
          <target state="translated">쿼리 된 &lt;a href=&quot;#vkGetPhysicalDeviceProperties&quot;&gt;vkGetPhysicalDeviceProperties&lt;/a&gt; :: &lt;code&gt;format&lt;/code&gt; 작성된 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBuffer&quot;&gt;버퍼&lt;/a&gt; 또는 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkBufferView&quot;&gt;버퍼보기&lt;/a&gt; 에서 기능을 지원하도록 지정하여 &lt;code&gt;bufferFeatures&lt;/code&gt; 에 다음 비트를 설정할 &lt;strong&gt;수&lt;/strong&gt; 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4ef3009d4b093b8b62b75a7072a32392af20ca1d" translate="yes" xml:space="preserve">
          <source>The following bits &lt;strong&gt;may&lt;/strong&gt; be set in &lt;code&gt;linearTilingFeatures&lt;/code&gt; and &lt;code&gt;optimalTilingFeatures&lt;/code&gt;, specifying that the features are supported by &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImage&quot;&gt;images&lt;/a&gt; or &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageView&quot;&gt;image views&lt;/a&gt; created with the queried &lt;a href=&quot;#vkGetPhysicalDeviceFormatProperties&quot;&gt;vkGetPhysicalDeviceFormatProperties&lt;/a&gt;::&lt;code&gt;format&lt;/code&gt;:</source>
          <target state="translated">쿼리 된 &lt;a href=&quot;#vkGetPhysicalDeviceFormatProperties&quot;&gt;vkGetPhysicalDeviceFormatProperties&lt;/a&gt; :: &lt;code&gt;format&lt;/code&gt; 작성된 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImage&quot;&gt;이미지&lt;/a&gt; 또는 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#VkImageView&quot;&gt;이미지보기&lt;/a&gt; 에서 기능이 지원되도록 지정하여 &lt;code&gt;linearTilingFeatures&lt;/code&gt; 및 &lt;code&gt;optimalTilingFeatures&lt;/code&gt; 에서 다음 비트를 설정할 &lt;strong&gt;수&lt;/strong&gt; 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd1f625cbc9aa7c902aedf2870a8d2cf96df52f1" translate="yes" xml:space="preserve">
          <source>The following filtering and conversion rules apply:</source>
          <target state="translated">다음과 같은 필터링 및 변환 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="cae5ac67a733200806eb81fde4ed63ac0ed45839" translate="yes" xml:space="preserve">
          <source>The formats of &lt;code&gt;srcImage&lt;/code&gt; and &lt;code&gt;dstImage&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be compatible. Formats are considered compatible if their element size is the same between both formats. For example, &lt;code&gt;VK_FORMAT_R8G8B8A8_UNORM&lt;/code&gt; is compatible with &lt;code&gt;VK_FORMAT_R32_UINT&lt;/code&gt; because both texels are 4 bytes in size. Depth/stencil formats &lt;strong&gt;must&lt;/strong&gt; match exactly.</source>
          <target state="translated">&lt;code&gt;srcImage&lt;/code&gt; 및 &lt;code&gt;dstImage&lt;/code&gt; 의 형식 이 호환 가능 &lt;strong&gt;해야&lt;/strong&gt; 합니다. 두 형식간에 요소 크기가 동일하면 형식이 호환 가능한 것으로 간주됩니다. 예를 들어, &lt;code&gt;VK_FORMAT_R8G8B8A8_UNORM&lt;/code&gt; 은 두 텍셀의 크기가 모두 4 바이트이므로 &lt;code&gt;VK_FORMAT_R32_UINT&lt;/code&gt; 와 호환됩니다 . 깊이 / 스텐실 형식 &lt;strong&gt;이&lt;/strong&gt; 정확히 일치 &lt;strong&gt;해야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="04adf0d7f1a5f2426d3d8f06212b1af0c925fb2b" translate="yes" xml:space="preserve">
          <source>The four array elements of the clear color map to R, G, B, and A components of image formats, in order.</source>
          <target state="translated">선명한 색상의 4 가지 배열 요소는 이미지 형식의 R, G, B 및 A 구성 요소에 순서대로 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="a35b898f1e242dcd8c287423a0b0a63288499113" translate="yes" xml:space="preserve">
          <source>The framebuffer depth coordinate &lt;code&gt;z&lt;/code&gt;&lt;sub&gt;f&lt;/sub&gt;&lt;strong&gt;may&lt;/strong&gt; be represented using either a fixed-point or floating-point representation. However, a floating-point representation &lt;strong&gt;must&lt;/strong&gt; be used if the depth/stencil attachment has a floating-point depth component. If an m-bit fixed-point representation is used, we assume that it represents each value \(\frac{k}{2^m - 1}\), where k &amp;isin; { 0, 1, &amp;hellip;​, 2&lt;sup&gt;m&lt;/sup&gt;-1 }, as k (e.g. 1.0 is represented in binary as a string of all ones).</source>
          <target state="translated">프레임 버퍼 깊이 좌표 &lt;code&gt;z&lt;/code&gt; &lt;sub&gt;F가 &lt;/sub&gt;&lt;strong&gt;있다&lt;/strong&gt; 고정 소수점 또는 부동 소수점 표현을 사용하여 표현 될 수있다. 그러나 깊이 / 스텐실 부착에 부동 소수점 깊이 구성 요소가있는 경우 부동 소수점 표현을 &lt;strong&gt;사용해야합니다&lt;/strong&gt; . m 비트 고정 소수점 표현이 사용되는 경우, 우리는 각각의 값 \ (\ FRAC {K} {2 ^ m - 1} \) 나타낸다고 가정 여기서 K &amp;isin; {0, 1, ..., (2) &lt;sup&gt;m&lt;/sup&gt; - 1}, k (예 : 1.0은 이진수로 모든 문자열로 표시됨)</target>
        </trans-unit>
        <trans-unit id="5cbf55345bdb079a7ed741287eac1621828d53c6" translate="yes" xml:space="preserve">
          <source>The functions &lt;strong&gt;must&lt;/strong&gt; not use offsets.</source>
          <target state="translated">함수 &lt;strong&gt;는&lt;/strong&gt; 오프셋을 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="94407d47d1ad9d03bb3c6a49b92c83d857c2c4cc" translate="yes" xml:space="preserve">
          <source>The functions &lt;strong&gt;must&lt;/strong&gt; not use projection.</source>
          <target state="translated">이 기능 &lt;strong&gt;은&lt;/strong&gt; 투영을 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="c34e2145e54dd65f98a2cefdff1129eef069a554" translate="yes" xml:space="preserve">
          <source>The image layout of each image subresource &lt;strong&gt;must&lt;/strong&gt; be well-defined at each point in the image subresource&amp;rsquo;s lifetime. This means that when performing a layout transition on the image subresource, the old layout value &lt;strong&gt;must&lt;/strong&gt; either equal the current layout of the image subresource (at the time the transition executes), or else be &lt;code&gt;VK_IMAGE_LAYOUT_UNDEFINED&lt;/code&gt; (implying that the contents of the image subresource need not be preserved). The new layout used in a transition &lt;strong&gt;must&lt;/strong&gt; not be &lt;code&gt;VK_IMAGE_LAYOUT_UNDEFINED&lt;/code&gt; or &lt;code&gt;VK_IMAGE_LAYOUT_PREINITIALIZED&lt;/code&gt;.</source>
          <target state="translated">각 이미지 하위 리소스의 이미지 레이아웃은 이미지 하위 리소스 수명의 각 지점에서 잘 정의 &lt;strong&gt;되어야합니다&lt;/strong&gt; . 즉, 이미지 하위 리소스에서 레이아웃 전환을 수행 할 때 이전 레이아웃 값 &lt;strong&gt;은&lt;/strong&gt; 이미지 하위 리소스의 현재 레이아웃과 동일하거나 전환이 실행될 때 &lt;code&gt;VK_IMAGE_LAYOUT_UNDEFINED&lt;/code&gt; 여야합니다 (이미지 하위 리소스의 내용이 필요함을 의미 함) 보존되지 않음). 전환에 사용되는 새로운 레이아웃은 &lt;strong&gt;있어야&lt;/strong&gt; 하지 &lt;code&gt;VK_IMAGE_LAYOUT_UNDEFINED&lt;/code&gt; 또는 &lt;code&gt;VK_IMAGE_LAYOUT_PREINITIALIZED&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c5f1c20b719b66c6c83edc199dc2b044d8a1ebc" translate="yes" xml:space="preserve">
          <source>The image region specified by a given element of &lt;code&gt;pRegions&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a region that is contained within &lt;code&gt;dstImage&lt;/code&gt;</source>
          <target state="translated">주어진 요소에 의해 지정된 화상 영역 &lt;code&gt;pRegions&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 내에 포함되는 영역이 될 &lt;code&gt;dstImage&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="892ac42f1e7b7aceb128464b30a7eeb57420eedb" translate="yes" xml:space="preserve">
          <source>The image region specified by a given element of &lt;code&gt;pRegions&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a region that is contained within &lt;code&gt;srcImage&lt;/code&gt;</source>
          <target state="translated">주어진 &lt;code&gt;pRegions&lt;/code&gt; 요소에 의해 지정된 이미지 영역 은 &lt;code&gt;srcImage&lt;/code&gt; 에 포함 된 영역 &lt;strong&gt;이어야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="3ede74731e52c6a1967502c1cc7f16d29ef00b4f" translate="yes" xml:space="preserve">
          <source>The image view &lt;strong&gt;must&lt;/strong&gt; have a single layer and a single mip level.</source>
          <target state="translated">이미지 뷰 에는 단일 레이어와 단일 밉 레벨이 &lt;strong&gt;있어야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c15cd9e119bbc69cabd2468d1d58352a3bf63a07" translate="yes" xml:space="preserve">
          <source>The implementation &lt;strong&gt;may&lt;/strong&gt; update the commitment at any time, and the value returned by this query &lt;strong&gt;may&lt;/strong&gt; be out of date.</source>
          <target state="translated">구현 시 언제든지 확약 &lt;strong&gt;이&lt;/strong&gt; 갱신 &lt;strong&gt;될 수&lt;/strong&gt; 있으며이 조회 &lt;strong&gt;가&lt;/strong&gt; 리턴 한 값이 오래 &lt;strong&gt;되었을 수&lt;/strong&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a97052903fd73a84d038a3ddccbc30dcd8095bb" translate="yes" xml:space="preserve">
          <source>The implementation guarantees to allocate any committed memory from the heapIndex indicated by the memory type that the memory object was created with.</source>
          <target state="translated">이 구현은 메모리 객체가 생성 된 메모리 유형으로 표시되는 heapIndex에서 커밋 된 메모리를 할당하도록 보장합니다.</target>
        </trans-unit>
        <trans-unit id="19b2e86ba5bb4b04756279e82d8c41a7f822004c" translate="yes" xml:space="preserve">
          <source>The intent of the &lt;code&gt;viewportBoundsRange&lt;/code&gt; limit is to allow a maximum sized viewport to be arbitrarily shifted relative to the output target as long as at least some portion intersects. This would give a bounds limit of [-&lt;code&gt;size&lt;/code&gt; + 1, 2 &amp;times; &lt;code&gt;size&lt;/code&gt; - 1] which would allow all possible non-empty-set intersections of the output target and the viewport. Since these numbers are typically powers of two, picking the signed number range using the smallest possible number of bits ends up with the specified range.</source>
          <target state="translated">&lt;code&gt;viewportBoundsRange&lt;/code&gt; 제한 의 의도는 적어도 일부 부분이 교차하는 한 최대 크기의 뷰포트가 출력 대상에 대해 임의로 이동되도록 허용하는 것입니다. 이것은 경계 한계 줄 것이다 [- &lt;code&gt;size&lt;/code&gt; + 1, 2 &amp;times; &lt;code&gt;size&lt;/code&gt; - 1] 출력 타겟 뷰포트 가능한 모든 비어 있지 않은 세트 교차를 허용한다. 이 숫자는 일반적으로 2의 거듭 제곱이므로 가능한 가장 작은 비트 수를 사용하여 부호있는 숫자 범위를 선택하면 지정된 범위가됩니다.</target>
        </trans-unit>
        <trans-unit id="01c644decf9778ee405c3f7c2b0b19933a5a310a" translate="yes" xml:space="preserve">
          <source>The interpretation of the sign of a is determined by the &lt;a href=&quot;#VkPipelineRasterizationStateCreateInfo&quot;&gt;VkPipelineRasterizationStateCreateInfo&lt;/a&gt;::&lt;code&gt;frontFace&lt;/code&gt; property of the currently active pipeline. Possible values are:</source>
          <target state="translated">의 부호 해석은 현재 활성화 된 파이프 라인 의 &lt;a href=&quot;#VkPipelineRasterizationStateCreateInfo&quot;&gt;VkPipelineRasterizationStateCreateInfo&lt;/a&gt; :: &lt;code&gt;frontFace&lt;/code&gt; 속성에 의해 결정됩니다 . 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="75dbbbf2271598e9e3e9f03d07ff97c2ebc46d6e" translate="yes" xml:space="preserve">
          <source>The layers [&lt;code&gt;baseArrayLayer&lt;/code&gt;, &lt;code&gt;baseArrayLayer&lt;/code&gt; + &lt;code&gt;layerCount&lt;/code&gt;) counting from the base layer of the attachment image view are cleared.</source>
          <target state="translated">첨부 이미지보기의 기본 레이어에서 계산 된 레이어 [ &lt;code&gt;baseArrayLayer&lt;/code&gt; , &lt;code&gt;baseArrayLayer&lt;/code&gt; + &lt;code&gt;layerCount&lt;/code&gt; )가 지워집니다.</target>
        </trans-unit>
        <trans-unit id="a522dd3a9e2bec0bfdbcca03c0a13cd6e00d81e8" translate="yes" xml:space="preserve">
          <source>The layers specified by a given element of &lt;code&gt;pRects&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be contained within every attachment that &lt;code&gt;pAttachments&lt;/code&gt; refers to</source>
          <target state="translated">주어진 요소에 의해 지정된 층 &lt;code&gt;pRects&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 하는 모든 첨부 파일에 포함되어야 &lt;code&gt;pAttachments&lt;/code&gt; 을 지칭</target>
        </trans-unit>
        <trans-unit id="9e3fdd959cb433bb8274942cbab7498212e6f1f5" translate="yes" xml:space="preserve">
          <source>The least significant s bits of &lt;code&gt;writeMask&lt;/code&gt;, where s is the number of bits in the stencil framebuffer attachment, specify an integer mask. Where a 1 appears in this mask, the corresponding bit in the stencil value in the depth/stencil attachment is written; where a 0 appears, the bit is not written. The &lt;code&gt;writeMask&lt;/code&gt; value uses either the front-facing or back-facing state based on the facingness of the fragment. Fragments generated by front-facing primitives use the front mask and fragments generated by back-facing primitives use the back mask.</source>
          <target state="translated">&lt;code&gt;writeMask&lt;/code&gt; 의 최하위 s 비트 ( 여기서 s는 스텐실 프레임 버퍼 첨부의 비트 수임)는 정수 마스크를 지정하십시오. 이 마스크에 1이 나타나면 깊이 / 스텐실 부착물에있는 스텐실 값의 해당 비트가 기록됩니다. 0이 나타나면 비트가 기록되지 않습니다. &lt;code&gt;writeMask&lt;/code&gt; 의 값 중 하나를 사용 전면 또는 단편 facingness에 기초하여 상태를 위로 향한. 전면 프리미티브에 의해 생성 된 프래그먼트는 전면 마스크를 사용하고 후면 프리미티브에 의해 생성 된 프래그먼트는 후면 마스크를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fa20fe39416a6a68c7f67744c98d8433a97b537c" translate="yes" xml:space="preserve">
          <source>The lifetime of each of these objects is bound by the lifetime of the &lt;code&gt;VkDevice&lt;/code&gt; object. Therefore, to avoid resource leaks, it is critical that an application explicitly free all of these resources prior to calling &lt;code&gt;vkDestroyDevice&lt;/code&gt;.</source>
          <target state="translated">이러한 각 개체의 수명은 &lt;code&gt;VkDevice&lt;/code&gt; 개체 의 수명에 의해 결정 됩니다. 따라서 리소스 누수를 피하려면 &lt;code&gt;vkDestroyDevice&lt;/code&gt; 를 호출하기 전에 응용 프로그램에서 이러한 모든 리소스를 명시 적으로 해제해야 합니다.</target>
        </trans-unit>
        <trans-unit id="cc45a5dee0c4acaae7037b99992ba48c0a396491" translate="yes" xml:space="preserve">
          <source>The limitations on an image format that are reported by &lt;code&gt;vkGetPhysicalDeviceImageFormatProperties&lt;/code&gt; have the following property: if &lt;code&gt;usage1&lt;/code&gt; and &lt;code&gt;usage2&lt;/code&gt; of type &lt;a href=&quot;#VkImageUsageFlags&quot;&gt;VkImageUsageFlags&lt;/a&gt; are such that the bits set in &lt;code&gt;usage1&lt;/code&gt; are a subset of the bits set in &lt;code&gt;usage2&lt;/code&gt;, and &lt;code&gt;flags1&lt;/code&gt; and &lt;code&gt;flags2&lt;/code&gt; of type &lt;a href=&quot;#VkImageCreateFlags&quot;&gt;VkImageCreateFlags&lt;/a&gt; are such that the bits set in &lt;code&gt;flags1&lt;/code&gt; are a subset of the bits set in &lt;code&gt;flags2&lt;/code&gt;, then the limitations for &lt;code&gt;usage1&lt;/code&gt; and &lt;code&gt;flags1&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be no more strict than the limitations for &lt;code&gt;usage2&lt;/code&gt; and &lt;code&gt;flags2&lt;/code&gt;, for all values of &lt;code&gt;format&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, and &lt;code&gt;tiling&lt;/code&gt;.</source>
          <target state="translated">보고 한 화상 포맷의 제한 &lt;code&gt;vkGetPhysicalDeviceImageFormatProperties&lt;/code&gt; 는 다음의 속성을 가지고 있다면 &lt;code&gt;usage1&lt;/code&gt; 및 &lt;code&gt;usage2&lt;/code&gt; 형의 &lt;a href=&quot;#VkImageUsageFlags&quot;&gt;VkImageUsageFlags는&lt;/a&gt; 이러한이다 설정된 비트 것을 &lt;code&gt;usage1&lt;/code&gt; 은 설정 비트들의 서브 세트 &lt;code&gt;usage2&lt;/code&gt; 및 &lt;code&gt;flags1&lt;/code&gt; 및 &lt;code&gt;flags2&lt;/code&gt; 형의 &lt;a href=&quot;#VkImageCreateFlags&quot;&gt;VkImageCreateFlags&lt;/a&gt; 같은 아르 설정된 비트 것을 &lt;code&gt;flags1&lt;/code&gt; 이 설정 비트들의 서브 세트 &lt;code&gt;flags2&lt;/code&gt; 다음의 제한 &lt;code&gt;usage1&lt;/code&gt; 및 &lt;code&gt;flags1&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 의 제한보다 더 엄격하지 &lt;code&gt;usage2&lt;/code&gt; 및 &lt;code&gt;flags2&lt;/code&gt; 의 모든 값에 대한 &lt;code&gt;format&lt;/code&gt; , &lt;code&gt;type&lt;/code&gt; 및 &lt;code&gt;tiling&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a09d5f518198a7cce50d94354298702d1f57a8a" translate="yes" xml:space="preserve">
          <source>The line width is specified by the &lt;a href=&quot;#VkPipelineRasterizationStateCreateInfo&quot;&gt;VkPipelineRasterizationStateCreateInfo&lt;/a&gt;::&lt;code&gt;lineWidth&lt;/code&gt; property of the currently active pipeline, if the pipeline was not created with &lt;code&gt;VK_DYNAMIC_STATE_LINE_WIDTH&lt;/code&gt; enabled.</source>
          <target state="translated">&lt;code&gt;VK_DYNAMIC_STATE_LINE_WIDTH&lt;/code&gt; 를 사용 하여 파이프 라인을 만들지 않은 경우 현재 활성 파이프 라인 의 &lt;a href=&quot;#VkPipelineRasterizationStateCreateInfo&quot;&gt;VkPipelineRasterizationStateCreateInfo&lt;/a&gt; :: &lt;code&gt;lineWidth&lt;/code&gt; 속성으로 선 너비를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="21c35b4cd4f78eec84ee719ba63db9d6e71098ff" translate="yes" xml:space="preserve">
          <source>The list of available layers may change at any time due to actions outside of the Vulkan implementation, so two calls to &lt;code&gt;vkEnumerateInstanceLayerProperties&lt;/code&gt; with the same parameters &lt;strong&gt;may&lt;/strong&gt; return different results, or retrieve different &lt;code&gt;pPropertyCount&lt;/code&gt; values or &lt;code&gt;pProperties&lt;/code&gt; contents. Once an instance has been created, the layers enabled for that instance will continue to be enabled and valid for the lifetime of that instance, even if some of them become unavailable for future instances.</source>
          <target state="translated">사용 가능한 계층 목록은 Vulkan 구현 외부의 작업으로 인해 언제든지 변경 될 수 있으므로 동일한 매개 변수를 사용하여 &lt;code&gt;vkEnumerateInstanceLayerProperties&lt;/code&gt; 에 대한 두 번의 호출&lt;strong&gt; 이&lt;/strong&gt; 다른 결과 반환되거나 다른 &lt;code&gt;pPropertyCount&lt;/code&gt; 값 또는 &lt;code&gt;pProperties&lt;/code&gt; 내용이 검색 . 인스턴스가 생성되면 해당 인스턴스에 대해 활성화 된 레이어는 이후 인스턴스에서 사용할 수없는 경우에도 해당 인스턴스 수명 동안 계속 활성화되고 유효합니다.</target>
        </trans-unit>
        <trans-unit id="d310f949025d9c3b6e405c6130bf52ef1570b7a8" translate="yes" xml:space="preserve">
          <source>The list of layers enumerated by &lt;code&gt;vkEnumerateDeviceLayerProperties&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be exactly the sequence of layers enabled for the instance. The members of &lt;code&gt;VkLayerProperties&lt;/code&gt; for each enumerated layer &lt;strong&gt;must&lt;/strong&gt; be the same as the properties when the layer was enumerated by &lt;code&gt;vkEnumerateInstanceLayerProperties&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;vkEnumerateDeviceLayerProperties&lt;/code&gt; 로 열거 된 계층 목록은 인스턴스에 사용 가능한 계층 순서와 정확히 일치 &lt;strong&gt;해야합니다&lt;/strong&gt; . 구성원 &lt;code&gt;VkLayerProperties&lt;/code&gt; 각 층은 열거 &lt;strong&gt;해야&lt;/strong&gt; 하는 층이 열거 될 때 특성과 동일 할 &lt;code&gt;vkEnumerateInstanceLayerProperties&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c54041801eda282f39fd289fd982911bd81cd6a9" translate="yes" xml:space="preserve">
          <source>The load operation for each sample in an attachment happens-before any recorded command which accesses the sample in the first subpass where the attachment is used. Load operations for attachments with a depth/stencil format execute in the &lt;code&gt;VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT&lt;/code&gt; pipeline stage. Load operations for attachments with a color format execute in the &lt;code&gt;VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT&lt;/code&gt; pipeline stage.</source>
          <target state="translated">첨부 파일의 각 샘플에 대한로드 작업은 첨부 파일이 사용되는 첫 번째 서브 패스의 샘플에 액세스하는 기록 된 명령 이전에 발생합니다. 깊이 / 스텐실 형식의 첨부 파일에 대한로드 작업은 &lt;code&gt;VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT&lt;/code&gt; 파이프 라인 단계 에서 실행됩니다 . 색상 형식의 첨부 파일에 대한로드 작업은 &lt;code&gt;VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT&lt;/code&gt; 파이프 라인 단계 에서 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="c5d36db236467e630781781820ef25da66dc89f9" translate="yes" xml:space="preserve">
          <source>The logical operations supported by Vulkan are summarized in the following table in which</source>
          <target state="translated">Vulkan이 지원하는 논리적 작업은 다음 표에 요약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b21dc053bc23767c6ac2408bd1ce4520f8987da2" translate="yes" xml:space="preserve">
          <source>The loop will find the first supported memory type that has all bits requested in &lt;code&gt;properties&lt;/code&gt; set. If there is no exact match, it will find a closest match (i.e. a memory type with the fewest additional bits set), which has some additional bits set but which are not detrimental to the behaviors requested by &lt;code&gt;properties&lt;/code&gt;. The application &lt;strong&gt;can&lt;/strong&gt; first search for the optimal properties, e.g. a memory type that is device-local or supports coherent cached accesses, as appropriate for the intended usage, and if such a memory type is not present &lt;strong&gt;can&lt;/strong&gt; fallback to searching for a less optimal but guaranteed set of properties such as &quot;0&quot; or &quot;host-visible and coherent&quot;.</source>
          <target state="translated">루프는 &lt;code&gt;properties&lt;/code&gt; 세트 에서 요청 된 모든 비트가있는 첫 번째 지원되는 메모리 유형을 찾습니다 . 정확히 일치하는 것이 없으면 가장 근접한 일치 (예 : 추가 비트가 가장 적은 메모리 유형)를 찾을 수 있습니다. 여기에는 추가 비트가 설정되어 있지만 &lt;code&gt;properties&lt;/code&gt; 가 요청한 동작에 해를 끼치 지 않습니다 . 응용 프로그램 &lt;strong&gt;은&lt;/strong&gt; 먼저 최적의 속성을 검색 &lt;strong&gt;할 수&lt;/strong&gt; 있습니다. 예를 들어, 의도 된 사용법에 따라 장치 로컬이거나 일관성있는 캐시 된 액세스를 지원하는 메모리 유형입니다. 이러한 메모리 유형이없는 경우 최적이 아닌 검색을 대신 &lt;strong&gt;할 수 있습니다.&lt;/strong&gt; &quot;0&quot;또는 &quot;host-visible and coherent&quot;와 같은 속성 집합을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="995eda1a70ec08ec89320329b625b396e654f896" translate="yes" xml:space="preserve">
          <source>The maximum binding number specified &lt;strong&gt;should&lt;/strong&gt; be as compact as possible to avoid wasted memory.</source>
          <target state="translated">지정된 최대 바인딩 수 &lt;strong&gt;는&lt;/strong&gt; 메모리 낭비를 피하기 위해 가능한 한 작아야합니다.</target>
        </trans-unit>
        <trans-unit id="616d28f646176989bd55e2bd369eb2ba19eb70c8" translate="yes" xml:space="preserve">
          <source>The maximum depth slope m of a triangle is</source>
          <target state="translated">삼각형의 최대 깊이 경사 m은</target>
        </trans-unit>
        <trans-unit id="ff4cba9613e626822043f05bf920927c34eec76f" translate="yes" xml:space="preserve">
          <source>The maximum number of sampler objects which &lt;strong&gt;can&lt;/strong&gt; be simultaneously created on a device is implementation-dependent and specified by the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-limits-maxSamplerAllocationCount&quot;&gt;&lt;code&gt;maxSamplerAllocationCount&lt;/code&gt;&lt;/a&gt; member of the &lt;a href=&quot;#VkPhysicalDeviceLimits&quot;&gt;VkPhysicalDeviceLimits&lt;/a&gt; structure. If &lt;code&gt;maxSamplerAllocationCount&lt;/code&gt; is exceeded, &lt;code&gt;vkCreateSampler&lt;/code&gt; will return &lt;code&gt;VK_ERROR_TOO_MANY_OBJECTS&lt;/code&gt;.</source>
          <target state="translated">장치에서 동시에 만들 &lt;strong&gt;수&lt;/strong&gt; 있는 최대 샘플러 개체 &lt;strong&gt;수&lt;/strong&gt; 는 구현에 따라 다르며 &lt;a href=&quot;#VkPhysicalDeviceLimits&quot;&gt;VkPhysicalDeviceLimits&lt;/a&gt; 구조 의 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-limits-maxSamplerAllocationCount&quot;&gt; &lt;code&gt;maxSamplerAllocationCount&lt;/code&gt; &lt;/a&gt; 멤버에 의해 지정됩니다 . &lt;code&gt;maxSamplerAllocationCount&lt;/code&gt; 가 초과 되면 vkCreateSampler 는 &lt;code&gt;vkCreateSampler&lt;/code&gt; 를 반환 &lt;code&gt;VK_ERROR_TOO_MANY_OBJECTS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90cd38f4b464a3432f018619ea0071c10e747e97" translate="yes" xml:space="preserve">
          <source>The members of &lt;code&gt;VkDispatchIndirectCommand&lt;/code&gt; have the same meaning as the corresponding parameters of &lt;a href=&quot;#vkCmdDispatch&quot;&gt;vkCmdDispatch&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;VkDispatchIndirectCommand&lt;/code&gt; 의 멤버는 vkCmdDispatch 의 해당 매개 변수와 동일한 의미를 &lt;a href=&quot;#vkCmdDispatch&quot;&gt;갖습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="14baae74c405bc18501d4ba5cc537cdc44a0a87b" translate="yes" xml:space="preserve">
          <source>The members of &lt;code&gt;VkDrawIndexedIndirectCommand&lt;/code&gt; have the same meaning as the similarly named parameters of &lt;a href=&quot;#vkCmdDrawIndexed&quot;&gt;vkCmdDrawIndexed&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;VkDrawIndexedIndirectCommand&lt;/code&gt; 의 멤버는 vkCmdDrawIndexed의 이름이 비슷한 매개 변수와 동일한 의미를 &lt;a href=&quot;#vkCmdDrawIndexed&quot;&gt;갖습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3288d42822a2455af438790164fcffae8eb874ec" translate="yes" xml:space="preserve">
          <source>The members of &lt;code&gt;VkDrawIndirectCommand&lt;/code&gt; have the same meaning as the similarly named parameters of &lt;a href=&quot;#vkCmdDraw&quot;&gt;vkCmdDraw&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;VkDrawIndirectCommand&lt;/code&gt; 의 멤버는 비슷한 이름의 &lt;a href=&quot;#vkCmdDraw&quot;&gt;vkCmdDraw&lt;/a&gt; 와 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="c97573a7af91d954ed4268af359c5e58ef05a387" translate="yes" xml:space="preserve">
          <source>The members of the &lt;code&gt;VkPhysicalDeviceFeatures&lt;/code&gt; structure describe the following features:</source>
          <target state="translated">&lt;code&gt;VkPhysicalDeviceFeatures&lt;/code&gt; 구조 의 멤버 는 다음 기능을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="505119ad4d2e5684e52a41f2bba617951853b92f" translate="yes" xml:space="preserve">
          <source>The memory types are sorted according to a preorder which serves to aid in easily selecting an appropriate memory type. Given two memory types X and Y, the preorder defines X &amp;le; Y if:</source>
          <target state="translated">메모리 유형은 적절한 메모리 유형을 쉽게 선택하는 데 도움이되는 프리오더에 따라 정렬됩니다. 두 가지 메모리 유형 X와 Y가 주어지면 다음과 같은 경우 사전 순서는 X &amp;le; Y를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="80605179896eebbaf6d577b8d97722595f0a8318" translate="yes" xml:space="preserve">
          <source>The minimum resolvable difference r is an implementation-dependent parameter that depends on the depth buffer representation. It is the smallest difference in framebuffer coordinate z values that is guaranteed to remain distinct throughout polygon rasterization and in the depth buffer. All pairs of fragments generated by the rasterization of two polygons with otherwise identical vertices, but &lt;code&gt;z&lt;/code&gt;&lt;sub&gt;f&lt;/sub&gt; values that differ by $r$, will have distinct depth values.</source>
          <target state="translated">최소 분해 가능한 차이 r은 깊이 버퍼 표현에 의존하는 구현 의존적 파라미터이다. 폴리곤 래스터 화 및 심도 버퍼에서 뚜렷하게 유지되는 것은 프레임 버퍼 좌표 z 값의 가장 작은 차이입니다. 다른 정점이있는 두 다각형의 래스터 화로 생성 된 모든 조각 쌍이지만 $ r $가 다른 &lt;code&gt;z&lt;/code&gt; &lt;sub&gt;f&lt;/sub&gt; 값은 고유 한 깊이 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="47cb5d8e8308ace41c4e8bbb0d7a80b52a8a959b" translate="yes" xml:space="preserve">
          <source>The next four bytes encode the pipeline cache version, as described for &lt;a href=&quot;#VkPipelineCacheHeaderVersion&quot;&gt;VkPipelineCacheHeaderVersion&lt;/a&gt;. A consumer of the pipeline cache &lt;strong&gt;should&lt;/strong&gt; use the cache version to interpret the remainder of the cache header.</source>
          <target state="translated">다음 4 바이트는 &lt;a href=&quot;#VkPipelineCacheHeaderVersion&quot;&gt;VkPipelineCacheHeaderVersion에&lt;/a&gt; 설명 된대로 파이프 라인 캐시 버전을 인코딩합니다 . 파이프 라인 캐시 소비자는 캐시 버전을 사용하여 나머지 캐시 헤더를 해석 &lt;strong&gt;해야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="8afa81f4b8f83682ea74a96c252fe19922dd6416" translate="yes" xml:space="preserve">
          <source>The number of currently valid memory objects, allocated from &lt;code&gt;device&lt;/code&gt;, &lt;strong&gt;must&lt;/strong&gt; be less than &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt;::&lt;code&gt;maxMemoryAllocationCount&lt;/code&gt;</source>
          <target state="translated">에서 할당 된 현재 유효한 메모리 개체의 수, &lt;code&gt;device&lt;/code&gt; , &lt;strong&gt;있어야&lt;/strong&gt; 보다 적은 수 &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; :: &lt;code&gt;maxMemoryAllocationCount&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="27bcba543f3b8fcaa92f36b0ac111deedee57783" translate="yes" xml:space="preserve">
          <source>The number of memory heaps is given by &lt;code&gt;memoryHeapCount&lt;/code&gt; and is less than or equal to &lt;code&gt;VK_MAX_MEMORY_HEAPS&lt;/code&gt;. Each heap is described by an element of the &lt;code&gt;memoryHeaps&lt;/code&gt; array, as a &lt;code&gt;VkMemoryHeap&lt;/code&gt; structure. The number of memory types available across all memory heaps is given by &lt;code&gt;memoryTypeCount&lt;/code&gt; and is less than or equal to &lt;code&gt;VK_MAX_MEMORY_TYPES&lt;/code&gt;. Each memory type is described by an element of the &lt;code&gt;memoryTypes&lt;/code&gt; array, as a &lt;code&gt;VkMemoryType&lt;/code&gt; structure.</source>
          <target state="translated">힙 메모리의 개수는로 주어진다 &lt;code&gt;memoryHeapCount&lt;/code&gt; 과 동일하다보다 작거나 &lt;code&gt;VK_MAX_MEMORY_HEAPS&lt;/code&gt; . 각 힙은 &lt;code&gt;memoryHeaps&lt;/code&gt; 배열 의 요소에 의해 &lt;code&gt;VkMemoryHeap&lt;/code&gt; 구조로 설명됩니다. 모든 메모리 힙에서 사용할 메모리 타입의 수에 의해 주어진다 &lt;code&gt;memoryTypeCount&lt;/code&gt; 과 동일하다보다 작거나 &lt;code&gt;VK_MAX_MEMORY_TYPES&lt;/code&gt; . 각 메모리 유형은 &lt;code&gt;memoryTypes&lt;/code&gt; 배열 의 요소에 의해 &lt;code&gt;VkMemoryType&lt;/code&gt; 구조로 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="b29e231064fb1df3c6fab2d55c43140a54071327" translate="yes" xml:space="preserve">
          <source>The number of mipmap levels and array layers &lt;strong&gt;must&lt;/strong&gt; be a subset of the image subresources in the image. If an application wants to use all mip levels or layers in an image after the &lt;code&gt;baseMipLevel&lt;/code&gt; or &lt;code&gt;baseArrayLayer&lt;/code&gt;, it &lt;strong&gt;can&lt;/strong&gt; set &lt;code&gt;levelCount&lt;/code&gt; and &lt;code&gt;layerCount&lt;/code&gt; to the special values &lt;code&gt;VK_REMAINING_MIP_LEVELS&lt;/code&gt; and &lt;code&gt;VK_REMAINING_ARRAY_LAYERS&lt;/code&gt; without knowing the exact number of mip levels or layers.</source>
          <target state="translated">밉맵 수준 및 배열 레이어 수는 이미지에서 이미지 하위 리소스의 하위 집합 &lt;strong&gt;이어야합니다&lt;/strong&gt; . 응용 프로그램이 후 이미지의 모든 밉 레벨 또는 레이어를 사용하고자 할 경우 &lt;code&gt;baseMipLevel&lt;/code&gt; 또는 &lt;code&gt;baseArrayLayer&lt;/code&gt; , 그것은 &lt;strong&gt;수&lt;/strong&gt; 설정 &lt;code&gt;levelCount&lt;/code&gt; 및 &lt;code&gt;layerCount&lt;/code&gt; 값 특별한에 &lt;code&gt;VK_REMAINING_MIP_LEVELS&lt;/code&gt; 및 &lt;code&gt;VK_REMAINING_ARRAY_LAYERS&lt;/code&gt; 을 밉 레벨 또는 계층의 정확한 수를 모른 채.</target>
        </trans-unit>
        <trans-unit id="6ed39edae73d76ac42d8a69ae041c1fcc20f53bc" translate="yes" xml:space="preserve">
          <source>The only dispatchable handle types are those related to device and instance management, such as &lt;a href=&quot;#VkDevice&quot;&gt;VkDevice&lt;/a&gt;.</source>
          <target state="translated">디스패치 가능한 유일한 핸들 유형은 &lt;a href=&quot;#VkDevice&quot;&gt;VkDevice&lt;/a&gt; 와 같은 디바이스 및 인스턴스 관리와 관련된 핸들 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="afd8787b69bad10b575fb80b4dfa15422c680947" translate="yes" xml:space="preserve">
          <source>The operations described by &lt;code&gt;pDescriptorWrites&lt;/code&gt; are performed first, followed by the operations described by &lt;code&gt;pDescriptorCopies&lt;/code&gt;. Within each array, the operations are performed in the order they appear in the array.</source>
          <target state="translated">하여 설명 된 동작 &lt;code&gt;pDescriptorWrites&lt;/code&gt; 는 설명의 동작 다음에, 제 수행 &lt;code&gt;pDescriptorCopies&lt;/code&gt; . 각 배열 내에서 작업은 배열에 나타나는 순서대로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="923e10c411c35319f50e382bd9bf0fb30ed088b5" translate="yes" xml:space="preserve">
          <source>The order that batches appear in &lt;code&gt;pSubmits&lt;/code&gt; is used to determine &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-submission-order&quot;&gt;submission order&lt;/a&gt;, and thus all the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-implicit&quot;&gt;implicit ordering guarantees&lt;/a&gt; that respect it. Other than these implicit ordering guarantees and any &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization&quot;&gt;explicit synchronization primitives&lt;/a&gt;, these batches &lt;strong&gt;may&lt;/strong&gt; overlap or otherwise execute out of order.</source>
          <target state="translated">배치가 &lt;code&gt;pSubmits&lt;/code&gt; 에 나타나는 순서는 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-submission-order&quot;&gt;제출 순서&lt;/a&gt; 를 결정 하는 데 사용 되므로 모든 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-implicit&quot;&gt;암시 적 순서는이&lt;/a&gt; 를 존중합니다. 이러한 암시 적 순서 보장 및 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization&quot;&gt;명시 적 동기화 프리미티브&lt;/a&gt; 이외의 이러한 배치 &lt;strong&gt;는&lt;/strong&gt; 겹치거나 순서가 맞지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03caeed9e9b76b5e07d7a14fe5121cbd51f413da" translate="yes" xml:space="preserve">
          <source>The order that command buffers appear in &lt;code&gt;pCommandBuffers&lt;/code&gt; is used to determine &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-submission-order&quot;&gt;submission order&lt;/a&gt;, and thus all the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-implicit&quot;&gt;implicit ordering guarantees&lt;/a&gt; that respect it. Other than these implicit ordering guarantees and any &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization&quot;&gt;explicit synchronization primitives&lt;/a&gt;, these command buffers &lt;strong&gt;may&lt;/strong&gt; overlap or otherwise execute out of order.</source>
          <target state="translated">&lt;code&gt;pCommandBuffers&lt;/code&gt; 에 명령 버퍼가 나타나는 순서는 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-submission-order&quot;&gt;제출 순서&lt;/a&gt; 를 결정 하는 데 사용 되므로 모든 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-implicit&quot;&gt;암시 적 순서는이&lt;/a&gt; 를 존중합니다. 이러한 암시 적 순서 보장 및 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization&quot;&gt;명시 적 동기화 프리미티브&lt;/a&gt; 외에 , 이러한 명령 버퍼 &lt;strong&gt;는&lt;/strong&gt; 겹치거나 순서가 다르게 실행될 &lt;strong&gt;수 있습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c29e914c1a526cfa427002d4f1bffe096286e626" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;basePipelineHandle&lt;/code&gt; and &lt;code&gt;basePipelineIndex&lt;/code&gt; are described in more detail in &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#pipelines-pipeline-derivatives&quot;&gt;Pipeline Derivatives&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;basePipelineHandle&lt;/code&gt; 및 &lt;code&gt;basePipelineIndex&lt;/code&gt; 매개 변수 는 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#pipelines-pipeline-derivatives&quot;&gt;Pipeline Derivatives에&lt;/a&gt; 자세히 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d286c2ef5a6ff8aab82721babd54208fe2849c02" translate="yes" xml:space="preserve">
          <source>The physical device type is advertised for informational purposes only, and does not directly affect the operation of the system. However, the device type &lt;strong&gt;may&lt;/strong&gt; correlate with other advertised properties or capabilities of the system, such as how many memory heaps there are.</source>
          <target state="translated">물리적 장치 유형은 정보 용으로 만 광고되며 시스템 작동에 직접적인 영향을 미치지 않습니다. 그러나 장치 유형 &lt;strong&gt;은&lt;/strong&gt; 시스템의 다른 알려진 속성이나 기능 (예 : 메모리 힙 &lt;strong&gt;수)&lt;/strong&gt; 과 상관 &lt;strong&gt;될 수&lt;/strong&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b29bf4b5e836d9f3d51dfcbe4523a7f092a970b" translate="yes" xml:space="preserve">
          <source>The physical device types which &lt;strong&gt;may&lt;/strong&gt; be returned in &lt;a href=&quot;#VkPhysicalDeviceProperties&quot;&gt;VkPhysicalDeviceProperties&lt;/a&gt;::&lt;code&gt;deviceType&lt;/code&gt; are:</source>
          <target state="translated">&lt;a href=&quot;#VkPhysicalDeviceProperties&quot;&gt;VkPhysicalDeviceProperties&lt;/a&gt; :: &lt;code&gt;deviceType&lt;/code&gt; 으로 반환 &lt;strong&gt;될 수&lt;/strong&gt; 있는 물리적 장치 유형 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2aedfd5cc6c8d033512036428a65bf9e6126a794" translate="yes" xml:space="preserve">
          <source>The pointer was formed by &lt;code&gt;OpImageTexelPointer&lt;/code&gt; and the coordinate is less than zero or greater than or equal to the number of whole elements in the bound range.</source>
          <target state="translated">포인터가 &lt;code&gt;OpImageTexelPointer&lt;/code&gt; 로 구성되었으며 좌표가 0보다 작거나 바운드 범위의 전체 요소 수보다 크거나 같습니다.</target>
        </trans-unit>
        <trans-unit id="7563ec807a5ce8fbc00db84f7c5f303c0cb1bc99" translate="yes" xml:space="preserve">
          <source>The pointer was not formed by &lt;code&gt;OpImageTexelPointer&lt;/code&gt; and the object pointed to is not wholly contained within the bound range.</source>
          <target state="translated">포인터가 &lt;code&gt;OpImageTexelPointer&lt;/code&gt; 에 의해 형성되지 않았 으며 지정된 오브젝트가 범위 내에 완전히 포함되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="49873c50bc0914c555ae9d7b4a97c8c756d0bcf2" translate="yes" xml:space="preserve">
          <source>The primitives are drawn &lt;code&gt;instanceCount&lt;/code&gt; times with &lt;code&gt;instanceIndex&lt;/code&gt; starting with &lt;code&gt;firstInstance&lt;/code&gt; and increasing sequentially for each instance. The assembled primitives execute the currently bound graphics pipeline.</source>
          <target state="translated">프리미티브는 &lt;code&gt;firstInstance&lt;/code&gt; 로 시작하고 각 인스턴스마다 순차적으로 증가 하는 &lt;code&gt;instanceIndex&lt;/code&gt; 로 &lt;code&gt;instanceCount&lt;/code&gt; 번 그려집니다 . 조립 된 프리미티브는 현재 바인딩 된 그래픽 파이프 라인을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="7ee888620b6d92a077de76e1d5068b36fde50c6b" translate="yes" xml:space="preserve">
          <source>The query identified by &lt;code&gt;queryPool&lt;/code&gt; and &lt;code&gt;query&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be &lt;em&gt;unavailable&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;queryPool&lt;/code&gt; 및 query로 식별 된 &lt;code&gt;query&lt;/code&gt; &lt;strong&gt;를&lt;/strong&gt; 사용할 &lt;em&gt;수 &lt;/em&gt;&lt;strong&gt;없어야합니다&lt;/strong&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="430d591cef795a700ee99c31e8cc8ed1982e478a" translate="yes" xml:space="preserve">
          <source>The query identified by &lt;code&gt;queryPool&lt;/code&gt; and &lt;code&gt;query&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be unavailable</source>
          <target state="translated">&lt;code&gt;queryPool&lt;/code&gt; 및 query로 식별 된 &lt;code&gt;query&lt;/code&gt; &lt;strong&gt;를&lt;/strong&gt; 사용할 수 &lt;strong&gt;없어야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ad5e6bc01d4d93e1a1cd00b9aa7aeb82fea70e11" translate="yes" xml:space="preserve">
          <source>The query identified by &lt;code&gt;queryPool&lt;/code&gt; and &lt;code&gt;query&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; currently be &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-operation-active&quot;&gt;active&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;queryPool&lt;/code&gt; 및 query로 식별 된 &lt;code&gt;query&lt;/code&gt; &lt;strong&gt;는&lt;/strong&gt; 현재 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-operation-active&quot;&gt;활성 상태 &lt;/a&gt;&lt;strong&gt;여야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3233e363b802b9b2b1809e9837a046e991315b65" translate="yes" xml:space="preserve">
          <source>The query identified by &lt;code&gt;queryPool&lt;/code&gt; and &lt;code&gt;query&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; currently not be &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-operation-active&quot;&gt;active&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;queryPool&lt;/code&gt; 및 query로 식별 된 &lt;code&gt;query&lt;/code&gt; &lt;strong&gt;는&lt;/strong&gt; 현재 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-operation-active&quot;&gt;활성화되어&lt;/a&gt; 있지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="5b44d5ff466b2f60d67cd23579b98ad22895fe39" translate="yes" xml:space="preserve">
          <source>The reason for this is that &lt;code&gt;VK_ERROR_FRAGMENTED_POOL&lt;/code&gt; was only added in a later revision of the 1.0 specification, and so drivers &lt;strong&gt;may&lt;/strong&gt; return other errors if they were written against earlier revisions. To ensure full compatibility with earlier patch revisions, these other errors are allowed.</source>
          <target state="translated">그 이유는 &lt;code&gt;VK_ERROR_FRAGMENTED_POOL&lt;/code&gt; 이 1.0 스펙의 이후 개정에만 추가 되었기 때문에 드라이버 &lt;strong&gt;가&lt;/strong&gt; 이전 개정에 대해 작성된 다른 오류를 리턴 &lt;strong&gt;할 수&lt;/strong&gt; 있기 때문입니다. 이전 패치 개정판과 완전히 호환되도록 이러한 다른 오류가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="2126729d905952e983f7920ee9d94d7f708f7295" translate="yes" xml:space="preserve">
          <source>The rectangular region specified by a given element of &lt;code&gt;pRects&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be contained within the render area of the current render pass instance</source>
          <target state="translated">주어진 &lt;code&gt;pRects&lt;/code&gt; 요소에 의해 지정된 사각형 영역 은 현재 렌더 패스 인스턴스의 렌더 영역 내에 포함 &lt;strong&gt;되어야&lt;/strong&gt; 합니다</target>
        </trans-unit>
        <trans-unit id="4200034de68fd5520125f42b1ee9a4d95d814549" translate="yes" xml:space="preserve">
          <source>The result of the logical operation is then written to the color attachment as controlled by the component write mask, described in &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#framebuffer-blendoperations&quot;&gt;Blend Operations&lt;/a&gt;.</source>
          <target state="translated">그런 다음 논리 연산의 결과는 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#framebuffer-blendoperations&quot;&gt;Blend Operations에&lt;/a&gt; 설명 된 구성 요소 쓰기 마스크에 의해 제어되는대로 색상 첨부 파일에 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="db6f7cce4f2f127b3b9fefdf00e19fa12cf8c56a" translate="yes" xml:space="preserve">
          <source>The returned function pointer &lt;strong&gt;must&lt;/strong&gt; only be called with a dispatchable object (the first parameter) that is &lt;code&gt;device&lt;/code&gt; or a child of &lt;code&gt;device&lt;/code&gt;. e.g. &lt;code&gt;VkDevice&lt;/code&gt;, &lt;code&gt;VkQueue&lt;/code&gt;, or &lt;code&gt;VkCommandBuffer&lt;/code&gt;.</source>
          <target state="translated">반환 함수 포인터 &lt;strong&gt;해야&lt;/strong&gt; 만 인 디스 오브젝트 (첫번째 파라미터)를 호출 &lt;code&gt;device&lt;/code&gt; 또는 하위 &lt;code&gt;device&lt;/code&gt; . 예를 들어 &lt;code&gt;VkDevice&lt;/code&gt; , &lt;code&gt;VkQueue&lt;/code&gt; 또는 &lt;code&gt;VkCommandBuffer&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bd45dc9f64b345f7fd207bc4f48316aa0f73700c" translate="yes" xml:space="preserve">
          <source>The returned function pointer &lt;strong&gt;must&lt;/strong&gt; only be called with a dispatchable object (the first parameter) that is &lt;code&gt;instance&lt;/code&gt; or a child of &lt;code&gt;instance&lt;/code&gt;. e.g. &lt;code&gt;VkInstance&lt;/code&gt;, &lt;code&gt;VkPhysicalDevice&lt;/code&gt;, &lt;code&gt;VkDevice&lt;/code&gt;, &lt;code&gt;VkQueue&lt;/code&gt;, or &lt;code&gt;VkCommandBuffer&lt;/code&gt;.</source>
          <target state="translated">반환 된 함수 포인터가 &lt;strong&gt;있어야&lt;/strong&gt; 에만있는 디스패치 객체 (첫 번째 매개 변수)를 호출 할 &lt;code&gt;instance&lt;/code&gt; 또는의 자식 &lt;code&gt;instance&lt;/code&gt; . 예를 들어 &lt;code&gt;VkInstance&lt;/code&gt; , &lt;code&gt;VkPhysicalDevice&lt;/code&gt; , &lt;code&gt;VkDevice&lt;/code&gt; , &lt;code&gt;VkQueue&lt;/code&gt; , 또는 &lt;code&gt;VkCommandBuffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9fd911007c0fdb04b2f83ca2b1124bd0986a6634" translate="yes" xml:space="preserve">
          <source>The returned function pointer is of type &lt;a href=&quot;#PFN_vkVoidFunction&quot;&gt;PFN_vkVoidFunction&lt;/a&gt;, and must be cast to the type of the command being queried.</source>
          <target state="translated">리턴 된 함수 포인터는 &lt;a href=&quot;#PFN_vkVoidFunction&quot;&gt;PFN_vkVoidFunction&lt;/a&gt; 유형이며 조회중인 명령의 유형으로 캐스트되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c1c1de13ce5bddf5b6ad23affdd8d8c409e5bda8" translate="yes" xml:space="preserve">
          <source>The sample count of &lt;code&gt;srcImage&lt;/code&gt; and &lt;code&gt;dstImage&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; both be equal to &lt;code&gt;VK_SAMPLE_COUNT_1_BIT&lt;/code&gt;</source>
          <target state="translated">의 샘플 수를 &lt;code&gt;srcImage&lt;/code&gt; 및 &lt;code&gt;dstImage&lt;/code&gt; 가&lt;strong&gt;있어야&lt;/strong&gt; 모두 동일 &lt;code&gt;VK_SAMPLE_COUNT_1_BIT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab936da7e0b1451d7368652115d97a099afc3ff5" translate="yes" xml:space="preserve">
          <source>The sample count of &lt;code&gt;srcImage&lt;/code&gt; and &lt;code&gt;dstImage&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; match</source>
          <target state="translated">&lt;code&gt;srcImage&lt;/code&gt; 및 &lt;code&gt;dstImage&lt;/code&gt; 의 샘플 수 &lt;strong&gt;는&lt;/strong&gt; 일치 &lt;strong&gt;해야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e6f7bcb4e74f258f6406ced05cf0d3f99cfa7146" translate="yes" xml:space="preserve">
          <source>The scale is determined from the source and destination regions, and applied to the offset coordinates:</source>
          <target state="translated">스케일은 소스 및 대상 영역에서 결정되어 오프셋 좌표에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f77ed02958b74de8f16df0a47b32cd8d259a46c5" translate="yes" xml:space="preserve">
          <source>The scissor rectangles taken from element i of &lt;code&gt;pScissors&lt;/code&gt; replace the current state for the scissor index &lt;code&gt;firstScissor&lt;/code&gt; + i, for i in [0, &lt;code&gt;scissorCount&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;pScissors&lt;/code&gt; 의 요소 i에서 가져온 가위 사각형 은 가위 인덱스 &lt;code&gt;firstScissor&lt;/code&gt; + i 의 현재 상태를 [0, &lt;code&gt;scissorCount&lt;/code&gt; )의 i로 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="c91ad6cb250a76e2fc75486a4945727818d0d4f5" translate="yes" xml:space="preserve">
          <source>The scissor test determines if a fragment&amp;rsquo;s framebuffer coordinates (x&lt;sub&gt;f&lt;/sub&gt;,y&lt;sub&gt;f&lt;/sub&gt;) lie within the scissor rectangle corresponding to the viewport index (see &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vertexpostproc-viewport&quot;&gt;Controlling the Viewport&lt;/a&gt;) used by the primitive that generated the fragment. If the pipeline state object is created without &lt;code&gt;VK_DYNAMIC_STATE_SCISSOR&lt;/code&gt; enabled then the scissor rectangles are set by the &lt;a href=&quot;#VkPipelineViewportStateCreateInfo&quot;&gt;VkPipelineViewportStateCreateInfo&lt;/a&gt; state of the pipeline state object. Otherwise, to dynamically set the scissor rectangles call:</source>
          <target state="translated">scissor 테스트는 프래그먼트의 프레임 버퍼 좌표 (x &lt;sub&gt;f&lt;/sub&gt; , y &lt;sub&gt;f&lt;/sub&gt; ) 가 프래그먼트를 생성 한 프리미티브가 사용 하는 뷰포트 인덱스 (뷰포트 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#vertexpostproc-viewport&quot;&gt;제어&lt;/a&gt; 참조)에 해당하는 가위 사각형 내에 있는지 확인 합니다. &lt;code&gt;VK_DYNAMIC_STATE_SCISSOR&lt;/code&gt; 를 사용 하지 않고 파이프 라인 상태 오브젝트를 작성하면 파이프 라인 상태 오브젝트 의 &lt;a href=&quot;#VkPipelineViewportStateCreateInfo&quot;&gt;VkPipelineViewportStateCreateInfo&lt;/a&gt; 상태에 의해 가위 사각형이 설정됩니다 . 그렇지 않으면 가위 사각형 호출을 동적으로 설정하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d3dace0daa14b4695fc932e3ffc3350a20e7fb12" translate="yes" xml:space="preserve">
          <source>The second &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes&quot;&gt;access scope&lt;/a&gt; is limited to access in the pipeline stages determined by the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks&quot;&gt;destination stage mask&lt;/a&gt; specified by &lt;code&gt;dstStageMask&lt;/code&gt;. It is also limited to access types in the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks&quot;&gt;destination access mask&lt;/a&gt; specified by &lt;code&gt;dstAccessMask&lt;/code&gt;.</source>
          <target state="translated">두 번째 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes&quot;&gt;액세스 범위&lt;/a&gt; 는 &lt;code&gt;dstStageMask&lt;/code&gt; 로 지정된 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks&quot;&gt;대상 스테이지 마스크에&lt;/a&gt; 의해 결정된 파이프 라인 단계에서의 액세스로 제한됩니다 . 또한 &lt;code&gt;dstAccessMask&lt;/code&gt; 로 지정된 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks&quot;&gt;대상 액세스 마스크&lt;/a&gt; 의 액세스 유형으로 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="b99dd47d746ccb730cbe645c82cd7850c934c379" translate="yes" xml:space="preserve">
          <source>The second &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes&quot;&gt;access scope&lt;/a&gt; is limited to access in the pipeline stages determined by the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks&quot;&gt;destination stage mask&lt;/a&gt; specified by &lt;code&gt;dstStageMask&lt;/code&gt;. Within that, the second access scope only includes the second access scopes defined by elements of the &lt;code&gt;pMemoryBarriers&lt;/code&gt;, &lt;code&gt;pBufferMemoryBarriers&lt;/code&gt; and &lt;code&gt;pImageMemoryBarriers&lt;/code&gt; arrays, which each define a set of &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-memory-barriers&quot;&gt;memory barriers&lt;/a&gt;. If no memory barriers are specified, then the second access scope includes no accesses.</source>
          <target state="translated">두 번째 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes&quot;&gt;액세스 범위&lt;/a&gt; 는 &lt;code&gt;dstStageMask&lt;/code&gt; 로 지정된 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks&quot;&gt;대상 스테이지 마스크에&lt;/a&gt; 의해 결정된 파이프 라인 단계에서의 액세스로 제한됩니다 . 그 안에있는 두 번째 액세스 범위에는 &lt;code&gt;pMemoryBarriers&lt;/code&gt; , &lt;code&gt;pBufferMemoryBarriers&lt;/code&gt; 및 &lt;code&gt;pImageMemoryBarriers&lt;/code&gt; 배열의 요소로 정의 된 두 번째 액세스 범위 만 포함되며 , 이는 각각 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-memory-barriers&quot;&gt;메모리 장벽&lt;/a&gt; 세트를 정의합니다 . 메모리 장벽이 지정되지 않으면 두 번째 액세스 범위에 액세스가 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc7c155367c0099bc4aa84a2f3c60853d1681f42" translate="yes" xml:space="preserve">
          <source>The second &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes&quot;&gt;access scope&lt;/a&gt; is limited to access to memory through the specified buffer range, via access types in the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks&quot;&gt;destination access mask&lt;/a&gt;. specified by &lt;code&gt;dstAccessMask&lt;/code&gt;. If &lt;code&gt;dstAccessMask&lt;/code&gt; includes &lt;code&gt;VK_ACCESS_HOST_WRITE_BIT&lt;/code&gt; or &lt;code&gt;VK_ACCESS_HOST_READ_BIT&lt;/code&gt;, available memory writes are also made visible to accesses of those types, as those access types are not performed through a resource.</source>
          <target state="translated">두 번째 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes&quot;&gt;액세스 범위&lt;/a&gt; 는 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks&quot;&gt;대상 액세스 마스크&lt;/a&gt; 의 액세스 유형을 통해 지정된 버퍼 범위를 통해 메모리에 액세스하도록 제한됩니다 . &lt;code&gt;dstAccessMask&lt;/code&gt; 에 의해 지정됩니다 . 경우 &lt;code&gt;dstAccessMask&lt;/code&gt; 가 포함 &lt;code&gt;VK_ACCESS_HOST_WRITE_BIT&lt;/code&gt; 또는 &lt;code&gt;VK_ACCESS_HOST_READ_BIT&lt;/code&gt; 를 해당 액세스 유형 리소스를 통해 수행되지 않기 때문에, 쓰기 가능한 메모리는 또한, 이러한 종류의 접근을 보이게된다.</target>
        </trans-unit>
        <trans-unit id="ef1f1867fa5701d6392b224ff4b170caeb03301a" translate="yes" xml:space="preserve">
          <source>The second &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes&quot;&gt;access scope&lt;/a&gt; is limited to access to memory through the specified image subresource range, via access types in the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks&quot;&gt;destination access mask&lt;/a&gt; specified by &lt;code&gt;dstAccessMask&lt;/code&gt;. If &lt;code&gt;dstAccessMask&lt;/code&gt; includes &lt;code&gt;VK_ACCESS_HOST_WRITE_BIT&lt;/code&gt; or &lt;code&gt;VK_ACCESS_HOST_READ_BIT&lt;/code&gt;, available memory writes are also made visible to accesses of those types, as those access types are not performed through a resource.</source>
          <target state="translated">두 번째 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes&quot;&gt;액세스 범위&lt;/a&gt; 는 &lt;code&gt;dstAccessMask&lt;/code&gt; 로 지정된 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks&quot;&gt;대상 액세스 마스크&lt;/a&gt; 의 액세스 유형을 통해 지정된 이미지 하위 자원 범위를 통해 메모리에 액세스하도록 제한됩니다 . 경우 &lt;code&gt;dstAccessMask&lt;/code&gt; 가 포함 &lt;code&gt;VK_ACCESS_HOST_WRITE_BIT&lt;/code&gt; 또는 &lt;code&gt;VK_ACCESS_HOST_READ_BIT&lt;/code&gt; 를 해당 액세스 유형 리소스를 통해 수행되지 않기 때문에, 쓰기 가능한 메모리는 또한, 이러한 종류의 접근을 보이게된다.</target>
        </trans-unit>
        <trans-unit id="0ebc13b7458fc7093cba09856ed2df90a8027b44" translate="yes" xml:space="preserve">
          <source>The second &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes&quot;&gt;access scope&lt;/a&gt; is limited to access types in the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks&quot;&gt;destination access mask&lt;/a&gt; specified by &lt;code&gt;dstAccessMask&lt;/code&gt;.</source>
          <target state="translated">두 번째 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-access-scopes&quot;&gt;액세스 범위&lt;/a&gt; 는 &lt;code&gt;dstAccessMask&lt;/code&gt; 로 지정된 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-access-masks&quot;&gt;대상 액세스 마스크&lt;/a&gt; 의 액세스 유형으로 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="edf250044701e0102ab5fc067cb966a3b7a7bb9c" translate="yes" xml:space="preserve">
          <source>The second &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-scopes&quot;&gt;synchronization scope&lt;/a&gt; includes commands subsequently submitted to the same queue, including those in the same command buffer and batch. The second synchronization scope is limited to operations on the pipeline stages determined by the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks&quot;&gt;destination stage mask&lt;/a&gt; specified by &lt;code&gt;dstStageMask&lt;/code&gt;.</source>
          <target state="translated">두 번째 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-scopes&quot;&gt;동기화 범위&lt;/a&gt; 에는 동일한 명령 버퍼 및 배치에있는 명령을 포함하여 이후에 동일한 대기열에 제출 된 명령이 포함됩니다. 두 번째 동기화 범위는 &lt;code&gt;dstStageMask&lt;/code&gt; 로 지정된 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-pipeline-stages-masks&quot;&gt;대상 스테이지 마스크에&lt;/a&gt; 의해 결정된 파이프 라인 스테이지에서의 조작으로 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="d3b2329c9134a6aee655f819cc2b5cfa24df21ce" translate="yes" xml:space="preserve">
          <source>The second &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-scopes&quot;&gt;synchronization scope&lt;/a&gt; includes only the event signal operation.</source>
          <target state="translated">제 2 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-scopes&quot;&gt;동기화 범위&lt;/a&gt; 는 이벤트 신호 동작만을 포함한다.</target>
        </trans-unit>
        <trans-unit id="763906953af3e55966376dcd24325fc2ccb59335" translate="yes" xml:space="preserve">
          <source>The second &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-scopes&quot;&gt;synchronization scope&lt;/a&gt; includes only the event unsignal operation.</source>
          <target state="translated">제 2 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#synchronization-dependencies-scopes&quot;&gt;동기화 범위&lt;/a&gt; 는 이벤트 비 신호 동작만을 포함한다.</target>
        </trans-unit>
        <trans-unit id="7cd4060403b4ff3a8b122d708ab8b089fe571de0" translate="yes" xml:space="preserve">
          <source>The semantics of each basic blend operations is described in the table below:</source>
          <target state="translated">각 기본 블렌드 작업의 의미는 아래 표에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8892a0b1601a4f9d21fb53fc1687b6610d2c23e" translate="yes" xml:space="preserve">
          <source>The semantics of each enum value is described in the table below:</source>
          <target state="translated">각 열거 형 값의 의미는 아래 표에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c6a1582a51b9ea7d750fdf47704c8dbdd236ba6" translate="yes" xml:space="preserve">
          <source>The set of image layouts consists of:</source>
          <target state="translated">이미지 레이아웃 세트는 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="3b32dbfd2c6a44920e5605ee12a4af65fcb696ce" translate="yes" xml:space="preserve">
          <source>The shader code for the entry point identified by &lt;code&gt;stage&lt;/code&gt; and the rest of the state identified by this structure &lt;strong&gt;must&lt;/strong&gt; adhere to the pipeline linking rules described in the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#interfaces&quot;&gt;Shader Interfaces&lt;/a&gt; chapter</source>
          <target state="translated">&lt;code&gt;stage&lt;/code&gt; 식별되는 진입 점 및이 구조로 식별 된 나머지 상태 의 셰이더 코드 는 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#interfaces&quot;&gt;Shader Interfaces&lt;/a&gt; 장에 설명 된 파이프 라인 연결 규칙을 준수 &lt;strong&gt;해야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c8cfae3588ecb602ed7a1ab2b9d73ea1b385c061" translate="yes" xml:space="preserve">
          <source>The shader code for the entry points identified by &lt;code&gt;pStages&lt;/code&gt;, and the rest of the state identified by this structure &lt;strong&gt;must&lt;/strong&gt; adhere to the pipeline linking rules described in the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#interfaces&quot;&gt;Shader Interfaces&lt;/a&gt; chapter</source>
          <target state="translated">&lt;code&gt;pStages&lt;/code&gt; 로 식별 된 진입 점 및이 구조로 식별 된 나머지 상태에 대한 쉐이더 코드 는 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#interfaces&quot;&gt;Shader Interfaces&lt;/a&gt; 장에 설명 된 파이프 라인 연결 규칙을 준수 &lt;strong&gt;해야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c7f1cbd9e0348a475e312987798722e1a3b0eb22" translate="yes" xml:space="preserve">
          <source>The source and destination color and alpha blending factors are selected from the enum:</source>
          <target state="translated">소스 및 대상 색상 및 알파 혼합 요인은 열거 형에서 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="b522a21c376c1a0ecbd2e79ab5378e25fd271d3f" translate="yes" xml:space="preserve">
          <source>The source data is copied from the user pointer to the command buffer when the command is called.</source>
          <target state="translated">명령이 호출 될 때 소스 데이터가 사용자 포인터에서 명령 버퍼로 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="1a94de5215b14a644477f7d31140e0ca4a5a2d9f" translate="yes" xml:space="preserve">
          <source>The source of different pieces of dynamic state is specified by the &lt;a href=&quot;#VkPipelineDynamicStateCreateInfo&quot;&gt;VkPipelineDynamicStateCreateInfo&lt;/a&gt;::&lt;code&gt;pDynamicStates&lt;/code&gt; property of the currently active pipeline, each of whose elements &lt;strong&gt;must&lt;/strong&gt; be one of the values:</source>
          <target state="translated">다른 동적 상태의 소스는 현재 활성 파이프 라인 의 &lt;a href=&quot;#VkPipelineDynamicStateCreateInfo&quot;&gt;VkPipelineDynamicStateCreateInfo&lt;/a&gt; :: &lt;code&gt;pDynamicStates&lt;/code&gt; 속성에 의해 지정되며 각 요소 &lt;strong&gt;는&lt;/strong&gt; 값 중 하나 &lt;strong&gt;여야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="69d3c0da5eb9fa0268cb2df40c394a5112b59d15" translate="yes" xml:space="preserve">
          <source>The source region specified by a given element of &lt;code&gt;pRegions&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be a region that is contained within &lt;code&gt;srcImage&lt;/code&gt;</source>
          <target state="translated">주어진 &lt;code&gt;pRegions&lt;/code&gt; 요소에 의해 지정된 소스 영역 은 &lt;code&gt;srcImage&lt;/code&gt; 에 포함 된 영역 &lt;strong&gt;이어야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="71a3c2e2bee66fcefcf53d67b0e491e39df8bd61" translate="yes" xml:space="preserve">
          <source>The state of an event &lt;strong&gt;can&lt;/strong&gt; be updated by the host. The state of the event is immediately changed, and subsequent calls to &lt;code&gt;vkGetEventStatus&lt;/code&gt; will return the new state. If an event is already in the requested state, then updating it to the same state has no effect.</source>
          <target state="translated">호스트 가 이벤트 상태를 업데이트 &lt;strong&gt;할 수&lt;/strong&gt; 있습니다. 이벤트 상태가 즉시 변경되고 &lt;code&gt;vkGetEventStatus&lt;/code&gt; 에 대한 후속 호출 은 새 상태를 반환합니다. 이벤트가 이미 요청 된 상태 인 경우 동일한 상태로 업데이트해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4d7f805e8c5bfc2834ddc4ee5bc4a6b6effa5f2b" translate="yes" xml:space="preserve">
          <source>The store operation for each sample in an attachment happens-after any recorded command which accesses the sample in the last subpass where the attachment is used. Store operations for attachments with a depth/stencil format execute in the &lt;code&gt;VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT&lt;/code&gt; pipeline stage. Store operations for attachments with a color format execute in the &lt;code&gt;VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT&lt;/code&gt; pipeline stage.</source>
          <target state="translated">첨부 파일의 각 샘플에 대한 저장 작업은 첨부 파일이 사용 된 마지막 서브 패스의 샘플에 액세스하는 기록 된 명령 이후에 발생합니다. 깊이 / 스텐실 형식의 첨부 파일에 대한 저장 작업은 &lt;code&gt;VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT&lt;/code&gt; 파이프 라인 단계 에서 실행됩니다 . 색상 형식의 첨부 파일에 대한 저장 작업은 &lt;code&gt;VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT&lt;/code&gt; 파이프 라인 단계 에서 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="571fb5eb8f896875413b8722503ba0ea02d2304c" translate="yes" xml:space="preserve">
          <source>The subpass index for a render pass begins at zero when &lt;code&gt;vkCmdBeginRenderPass&lt;/code&gt; is recorded, and increments each time &lt;code&gt;vkCmdNextSubpass&lt;/code&gt; is recorded.</source>
          <target state="translated">렌더 패스의 subpass 지수는 때 제로에서 시작 &lt;code&gt;vkCmdBeginRenderPass&lt;/code&gt; 이 때마다 기록하고, 단위 &lt;code&gt;vkCmdNextSubpass&lt;/code&gt; 가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="78cbedae7eff7e1c78b5e082f2b9f59dadc76495" translate="yes" xml:space="preserve">
          <source>The subpass index of the current render pass &lt;strong&gt;must&lt;/strong&gt; be equal to the &lt;code&gt;subpass&lt;/code&gt; member of the &lt;code&gt;VkGraphicsPipelineCreateInfo&lt;/code&gt; structure specified when creating the &lt;code&gt;VkPipeline&lt;/code&gt; currently bound to &lt;code&gt;VK_PIPELINE_BIND_POINT_GRAPHICS&lt;/code&gt;.</source>
          <target state="translated">현재의 subpass 지수는 패스 렌더링 &lt;strong&gt;해야&lt;/strong&gt; 받는 동일 &lt;code&gt;subpass&lt;/code&gt; 용 의 부재 &lt;code&gt;VkGraphicsPipelineCreateInfo&lt;/code&gt; 의 생성 원 때 지정된 구조 &lt;code&gt;VkPipeline&lt;/code&gt; 현재 결합 &lt;code&gt;VK_PIPELINE_BIND_POINT_GRAPHICS&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="62e13cfa8ec21e55e0ce7f689c2da516fdc67daf" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;dstArrayElement&lt;/code&gt; and &lt;code&gt;descriptorCount&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than or equal to the number of array elements in the descriptor set binding specified by &lt;code&gt;dstBinding&lt;/code&gt;, and all applicable consecutive bindings, as described by &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-updates-consecutive&quot;&gt;html/vkspec.html#descriptorsets-updates-consecutive&lt;/a&gt;</source>
          <target state="translated">합계 &lt;code&gt;dstArrayElement&lt;/code&gt; 및 &lt;code&gt;descriptorCount&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 미만이거나 의해 특정 바인딩 설명자 세트의 어레이 요소들의 수와 동일 &lt;code&gt;dstBinding&lt;/code&gt; 하여 설명한 바와 같이, 적용 가능한 모든 연속 바인딩 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-updates-consecutive&quot;&gt;HTML / vkspec.html # descriptorsets 업데이트와 연속&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9057fb32871648932a205ef00133a2b3720c496f" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;firstBinding&lt;/code&gt; and &lt;code&gt;bindingCount&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than or equal to &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt;::&lt;code&gt;maxVertexInputBindings&lt;/code&gt;</source>
          <target state="translated">의 합 &lt;code&gt;firstBinding&lt;/code&gt; 및 &lt;code&gt;bindingCount&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 미만 또는 동일 &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; :: &lt;code&gt;maxVertexInputBindings&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="abc205b0a3acfac7059c1540de2a6021a9045809" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;firstQuery&lt;/code&gt; and &lt;code&gt;queryCount&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than or equal to the number of queries in &lt;code&gt;queryPool&lt;/code&gt;</source>
          <target state="translated">합계 &lt;code&gt;firstQuery&lt;/code&gt; 및 &lt;code&gt;queryCount&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 미만 또는 질의들의 수와 동일 &lt;code&gt;queryPool&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ff52456a9b01355b3a52e39ddc54232f335fea5d" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;firstScissor&lt;/code&gt; and &lt;code&gt;scissorCount&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt;::&lt;code&gt;maxViewports&lt;/code&gt;, inclusive</source>
          <target state="translated">의 합 &lt;code&gt;firstScissor&lt;/code&gt; 및 &lt;code&gt;scissorCount&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 사이 &lt;code&gt;1&lt;/code&gt; 및 &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; :: &lt;code&gt;maxViewports&lt;/code&gt; (포함)</target>
        </trans-unit>
        <trans-unit id="45ca7c0c2638c9e3617956385b2f6f174633eb5f" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;firstSet&lt;/code&gt; and &lt;code&gt;descriptorSetCount&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than or equal to &lt;code&gt;VkPipelineLayoutCreateInfo&lt;/code&gt;::&lt;code&gt;setLayoutCount&lt;/code&gt; provided when &lt;code&gt;layout&lt;/code&gt; was created</source>
          <target state="translated">합계 &lt;code&gt;firstSet&lt;/code&gt; 및 &lt;code&gt;descriptorSetCount&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 미만이거나 동일 &lt;code&gt;VkPipelineLayoutCreateInfo&lt;/code&gt; :: &lt;code&gt;setLayoutCount&lt;/code&gt; 제공 할 때 &lt;code&gt;layout&lt;/code&gt; 생성 된</target>
        </trans-unit>
        <trans-unit id="2312970c6208088685318526a4f42e88d84a0df1" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;firstViewport&lt;/code&gt; and &lt;code&gt;viewportCount&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt;::&lt;code&gt;maxViewports&lt;/code&gt;, inclusive</source>
          <target state="translated">의 합 &lt;code&gt;firstViewport&lt;/code&gt; 및 &lt;code&gt;viewportCount&lt;/code&gt; 이&lt;strong&gt;있어야합니다&lt;/strong&gt; 사이 &lt;code&gt;1&lt;/code&gt; 및 &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; :: &lt;code&gt;maxViewports&lt;/code&gt; (포함)</target>
        </trans-unit>
        <trans-unit id="c5a1d0ba29469047ebdcebfccee04109c0988830" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;offset&lt;/code&gt; and the address of the range of &lt;code&gt;VkDeviceMemory&lt;/code&gt; object that is backing &lt;code&gt;buffer&lt;/code&gt;, &lt;strong&gt;must&lt;/strong&gt; be a multiple of the type indicated by &lt;code&gt;indexType&lt;/code&gt;</source>
          <target state="translated">합계 &lt;code&gt;offset&lt;/code&gt; 및 범위의 어드레스 &lt;code&gt;VkDeviceMemory&lt;/code&gt; 에 백업되는 오브젝트 &lt;code&gt;buffer&lt;/code&gt; , &lt;strong&gt;해야&lt;/strong&gt; 로 나타내는 형식의 배수 &lt;code&gt;indexType&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="06dbe14d7b39184cea1a929f5687227ae6c1ddce" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;offset&lt;/code&gt; and the size of &lt;code&gt;VkDispatchIndirectCommand&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than or equal to the size of &lt;code&gt;buffer&lt;/code&gt;</source>
          <target state="translated">합계 &lt;code&gt;offset&lt;/code&gt; 과 크기 &lt;code&gt;VkDispatchIndirectCommand&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 미만 또는 크기와 동일한 &lt;code&gt;buffer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="64d346396f7baca56e7ceb3febcee28cca03fd45" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;srcArrayElement&lt;/code&gt; and &lt;code&gt;descriptorCount&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than or equal to the number of array elements in the descriptor set binding specified by &lt;code&gt;srcBinding&lt;/code&gt;, and all applicable consecutive bindings, as described by &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-updates-consecutive&quot;&gt;html/vkspec.html#descriptorsets-updates-consecutive&lt;/a&gt;</source>
          <target state="translated">합계 &lt;code&gt;srcArrayElement&lt;/code&gt; 및 &lt;code&gt;descriptorCount&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 미만이거나 의해 특정 바인딩 설명자 세트의 어레이 요소들의 수와 동일 &lt;code&gt;srcBinding&lt;/code&gt; 하여 설명한 바와 같이, 적용 가능한 모든 연속 바인딩 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#descriptorsets-updates-consecutive&quot;&gt;HTML / vkspec.html # descriptorsets 업데이트와 연속&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e26f24a4e4dc6c8c1fe1975c53ce82836d67723" translate="yes" xml:space="preserve">
          <source>The table below defines the various use cases for &lt;code&gt;vkGetDeviceProcAddr&lt;/code&gt; and expected return value for each case.</source>
          <target state="translated">아래 표는 &lt;code&gt;vkGetDeviceProcAddr&lt;/code&gt; 의 다양한 사용 사례 와 각 사례의 예상 반환 값을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="df1a71d984c186f762bdd4ff2a2a5d958262df34" translate="yes" xml:space="preserve">
          <source>The table below defines the various use cases for &lt;code&gt;vkGetInstanceProcAddr&lt;/code&gt; and expected return value (&quot;fp&quot; is function pointer) for each case.</source>
          <target state="translated">아래 표는 &lt;code&gt;vkGetInstanceProcAddr&lt;/code&gt; 의 다양한 사용 사례 와 각 사례의 예상 반환 값 ( &quot;fp&quot;는 함수 포인터)을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="73a2eba7b03c376fc2d08adedf571829aab3ab4d" translate="yes" xml:space="preserve">
          <source>The total number of descriptors of the type &lt;code&gt;VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER&lt;/code&gt;, &lt;code&gt;VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE&lt;/code&gt;, and &lt;code&gt;VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER&lt;/code&gt; accessible to any given shader stage across all elements of &lt;code&gt;pSetLayouts&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than or equal to &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt;::&lt;code&gt;maxPerStageDescriptorSampledImages&lt;/code&gt;</source>
          <target state="translated">유형의 기술자의 총 수 &lt;code&gt;VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER&lt;/code&gt; , &lt;code&gt;VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE&lt;/code&gt; 및 &lt;code&gt;VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER&lt;/code&gt; 의 모든 요소에서 특정 쉐이더 단계로 접근 &lt;code&gt;pSetLayouts&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 미만이거나 동일 &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; :: &lt;code&gt;maxPerStageDescriptorSampledImages&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da28eea927b9b94b4c73b38585008493b00ffa0f" translate="yes" xml:space="preserve">
          <source>The total number of descriptors of the type &lt;code&gt;VK_DESCRIPTOR_TYPE_SAMPLER&lt;/code&gt; and &lt;code&gt;VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER&lt;/code&gt; accessible to any given shader stage across all elements of &lt;code&gt;pSetLayouts&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than or equal to &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt;::&lt;code&gt;maxPerStageDescriptorSamplers&lt;/code&gt;</source>
          <target state="translated">유형의 기술자의 총 수 &lt;code&gt;VK_DESCRIPTOR_TYPE_SAMPLER&lt;/code&gt; 및 &lt;code&gt;VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER&lt;/code&gt; 의 모든 요소에서 특정 쉐이더 단계로 접근 &lt;code&gt;pSetLayouts&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 미만이거나 동일 &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; :: &lt;code&gt;maxPerStageDescriptorSamplers&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd07bd25e13e1e05df6857fcf3663988f0c412a1" translate="yes" xml:space="preserve">
          <source>The total number of descriptors of the type &lt;code&gt;VK_DESCRIPTOR_TYPE_STORAGE_BUFFER&lt;/code&gt; and &lt;code&gt;VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC&lt;/code&gt; accessible to any given shader stage across all elements of &lt;code&gt;pSetLayouts&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than or equal to &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt;::&lt;code&gt;maxPerStageDescriptorStorageBuffers&lt;/code&gt;</source>
          <target state="translated">유형의 기술자의 총 수 &lt;code&gt;VK_DESCRIPTOR_TYPE_STORAGE_BUFFER&lt;/code&gt; 및 &lt;code&gt;VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC&lt;/code&gt; 의 모든 요소에 걸쳐 쉐이더 단계에 주어진 모든 액세스 &lt;code&gt;pSetLayouts&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 미만이거나 동일 &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; :: &lt;code&gt;maxPerStageDescriptorStorageBuffers&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c7bc6c3471db4af2f1b67376be436315e72e243e" translate="yes" xml:space="preserve">
          <source>The total number of descriptors of the type &lt;code&gt;VK_DESCRIPTOR_TYPE_STORAGE_IMAGE&lt;/code&gt;, and &lt;code&gt;VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER&lt;/code&gt; accessible to any given shader stage across all elements of &lt;code&gt;pSetLayouts&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than or equal to &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt;::&lt;code&gt;maxPerStageDescriptorStorageImages&lt;/code&gt;</source>
          <target state="translated">총 타입의 기술자의 수 &lt;code&gt;VK_DESCRIPTOR_TYPE_STORAGE_IMAGE&lt;/code&gt; 및 &lt;code&gt;VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER&lt;/code&gt; 의 모든 요소에서 특정 쉐이더 단계로 접근 &lt;code&gt;pSetLayouts&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 미만이거나 동일 &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; :: &lt;code&gt;maxPerStageDescriptorStorageImages&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="98823483c874132230a59f0813a8217a3259cbf1" translate="yes" xml:space="preserve">
          <source>The total number of descriptors of the type &lt;code&gt;VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER&lt;/code&gt; and &lt;code&gt;VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC&lt;/code&gt; accessible to any given shader stage across all elements of &lt;code&gt;pSetLayouts&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be less than or equal to &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt;::&lt;code&gt;maxPerStageDescriptorUniformBuffers&lt;/code&gt;</source>
          <target state="translated">유형의 기술자의 총 수 &lt;code&gt;VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER&lt;/code&gt; 및 &lt;code&gt;VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC&lt;/code&gt; 의 모든 요소에 걸쳐 쉐이더 단계에 주어진 모든 액세스 &lt;code&gt;pSetLayouts&lt;/code&gt; 이&lt;strong&gt;있어야&lt;/strong&gt; 미만이거나 동일 &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; :: &lt;code&gt;maxPerStageDescriptorUniformBuffers&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="10e64105c33717fc834a14842b5619c6f4426a6f" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;pfnAllocation&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;pfnAllocation&lt;/code&gt; 의 유형은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="74afb14243a14484f0d4c36e3e767bae8f081301" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;pfnFree&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;pfnFree&lt;/code&gt; 의 유형은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dc2a415f63963012a8eecebeccd1ff40bcbc0188" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;pfnInternalAllocation&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;pfnInternalAllocation&lt;/code&gt; 의 유형은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="72abb1776911c614fb6ab9f6cab4cbf592215c8b" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;pfnInternalFree&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;pfnInternalFree&lt;/code&gt; 의 유형은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9c60019ea65453837ee5e5f1bcec37f92616b0a0" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;pfnReallocation&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;pfnReallocation&lt;/code&gt; 의 유형은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="59cd79e18995e4deaf4b4fd9748c608440046c7e" translate="yes" xml:space="preserve">
          <source>The type of descriptors in a descriptor set is specified by &lt;a href=&quot;#VkWriteDescriptorSet&quot;&gt;VkWriteDescriptorSet&lt;/a&gt;::&lt;code&gt;descriptorType&lt;/code&gt;, which &lt;strong&gt;must&lt;/strong&gt; be one of the values:</source>
          <target state="translated">기술자 세트 기술자의 종류에 의해 지정됩니다 &lt;a href=&quot;#VkWriteDescriptorSet&quot;&gt;VkWriteDescriptorSet&lt;/a&gt; :: &lt;code&gt;descriptorType&lt;/code&gt; 하는 &lt;strong&gt;있어야합니다&lt;/strong&gt; 값 중 하나 일 수 :</target>
        </trans-unit>
        <trans-unit id="5ccc184a1d6b413579807169c7b54d56d1ea69a5" translate="yes" xml:space="preserve">
          <source>The type(s) of device access supported by each layout are:</source>
          <target state="translated">각 레이아웃에서 지원되는 장치 액세스 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d6f5ae2f24710b4be9e153e5537d4e160df65f8d" translate="yes" xml:space="preserve">
          <source>The types of image views that &lt;strong&gt;can&lt;/strong&gt; be created are:</source>
          <target state="translated">만들 &lt;strong&gt;수&lt;/strong&gt; 있는 이미지보기 유형 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="15839dad587dcadf748ff272d001ad48771f0c2c" translate="yes" xml:space="preserve">
          <source>The union of all destination regions, specified by the elements of &lt;code&gt;pRegions&lt;/code&gt;, &lt;strong&gt;must&lt;/strong&gt; not overlap in memory with any texel that &lt;strong&gt;may&lt;/strong&gt; be sampled during the blit operation</source>
          <target state="translated">의 요소에 의해 지정된 모든 대상 영역의 연합 &lt;code&gt;pRegions&lt;/code&gt; 는 , &lt;strong&gt;해야&lt;/strong&gt; 어떤 텍셀로 메모리에 겹치지 &lt;strong&gt;있다&lt;/strong&gt; 블리트 동작 동안 샘플링 될</target>
        </trans-unit>
        <trans-unit id="a6b5b4840159247d367192ba9d6d452ac2feba0b" translate="yes" xml:space="preserve">
          <source>The union of all source regions, and the union of all destination regions, specified by the elements of &lt;code&gt;pRegions&lt;/code&gt;, &lt;strong&gt;must&lt;/strong&gt; not overlap in memory</source>
          <target state="translated">모든 소스 영역의 조합과의 요소에 의해 지정된 모든 대상 영역의 연합 &lt;code&gt;pRegions&lt;/code&gt; 는 , &lt;strong&gt;해야&lt;/strong&gt; 메모리 겹치지</target>
        </trans-unit>
        <trans-unit id="096529af4db29185292b78396a0e7b4b8777c5d2" translate="yes" xml:space="preserve">
          <source>The union of the source regions, and the union of the destination regions, specified by the elements of &lt;code&gt;pRegions&lt;/code&gt;, &lt;strong&gt;must&lt;/strong&gt; not overlap in memory</source>
          <target state="translated">소스 영역의 조합, 및의 엘리먼트에 의해 특정 대상 영역의 연합 &lt;code&gt;pRegions&lt;/code&gt; 는 , &lt;strong&gt;해야&lt;/strong&gt; 메모리 겹치지</target>
        </trans-unit>
        <trans-unit id="d42bbfb89ea8b8eb7f36264990a8ec44b6898bb4" translate="yes" xml:space="preserve">
          <source>The value of any element of the &lt;code&gt;pPreserveAttachments&lt;/code&gt; member in any given element of &lt;code&gt;pSubpasses&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; not be &lt;code&gt;VK_ATTACHMENT_UNUSED&lt;/code&gt;</source>
          <target state="translated">의 임의의 요소의 값 &lt;code&gt;pPreserveAttachments&lt;/code&gt; 의 임의의 주어진 요소 부재 &lt;code&gt;pSubpasses&lt;/code&gt; 는&lt;strong&gt;해야&lt;/strong&gt; 하지 &lt;code&gt;VK_ATTACHMENT_UNUSED&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1d0487f48776f79b21686dce41b643930ac5f98d" translate="yes" xml:space="preserve">
          <source>The value returned in &lt;code&gt;minImageTransferGranularity&lt;/code&gt; has a unit of compressed texel blocks for images having a block-compressed format, and a unit of texels otherwise.</source>
          <target state="translated">&lt;code&gt;minImageTransferGranularity&lt;/code&gt; 로 반환 된 값 은 블록 압축 형식의 이미지에 대한 압축 된 텍셀 블록 단위와 그렇지 않으면 텍셀 단위를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="724ad04584feac74dfe1c61d6cc20e929683540d" translate="yes" xml:space="preserve">
          <source>The values taken from elements i of &lt;code&gt;pBuffers&lt;/code&gt; and &lt;code&gt;pOffsets&lt;/code&gt; replace the current state for the vertex input binding &lt;code&gt;firstBinding&lt;/code&gt; + i, for i in [0, &lt;code&gt;bindingCount&lt;/code&gt;). The vertex input binding is updated to start at the offset indicated by &lt;code&gt;pOffsets&lt;/code&gt;[i] from the start of the buffer &lt;code&gt;pBuffers&lt;/code&gt;[i]. All vertex input attributes that use each of these bindings will use these updated addresses in their address calculations for subsequent draw commands.</source>
          <target state="translated">&lt;code&gt;pBuffers&lt;/code&gt; 및 &lt;code&gt;pOffsets&lt;/code&gt; 의 요소 i에서 가져온 값 은 [0, &lt;code&gt;bindingCount&lt;/code&gt; ) 에서 i 의 정점 입력 바인딩 &lt;code&gt;firstBinding&lt;/code&gt; + i에 대한 현재 상태를 대체합니다 . 버텍스 입력 바인딩은 버퍼 &lt;code&gt;pBuffers&lt;/code&gt; [i] 의 시작에서 &lt;code&gt;pOffsets&lt;/code&gt; [i]로 표시된 오프셋에서 시작하도록 업데이트됩니다 . 이러한 각 바인딩을 사용하는 모든 정점 입력 속성은 후속 그리기 명령에 대해 주소 계산에 이러한 업데이트 된 주소를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8074beb33e3f67407fcbb037b008601b118eaed2" translate="yes" xml:space="preserve">
          <source>The vendor of the physical device is responsible for selecting &lt;code&gt;deviceID&lt;/code&gt;. The value selected &lt;strong&gt;should&lt;/strong&gt; uniquely identify both the device version and any major configuration options (for example, core count in the case of multicore devices). The same device ID &lt;strong&gt;should&lt;/strong&gt; be used for all physical implementations of that device version and configuration. For example, all uses of a specific silicon IP GPU version and configuration &lt;strong&gt;should&lt;/strong&gt; use the same device ID, even if those uses occur in different SoCs.</source>
          <target state="translated">물리적 장치의 공급 업체는 &lt;code&gt;deviceID&lt;/code&gt; 선택을 담당합니다 . 선택한 값 은 장치 버전과 주요 구성 옵션 (예 : 멀티 코어 장치의 경우 코어 수)을 고유하게 식별 &lt;strong&gt;해야합니다&lt;/strong&gt; . 해당 장치 버전 및 구성의 모든 실제 구현에 동일한 장치 ID를 &lt;strong&gt;사용해야&lt;/strong&gt; 합니다. 예를 들어, 특정 실리콘 GPU IP 버전 및 모든 구성이 사용 &lt;strong&gt;되어야&lt;/strong&gt; 그 용도가 다른 SoC가 발생하는 경우에도, 동일한 장치 ID를 사용한다.</target>
        </trans-unit>
        <trans-unit id="03c8491a1f46be021902bb20b2a9b054a007d7aa" translate="yes" xml:space="preserve">
          <source>The viewport parameters shown in the above equations are found from these values as</source>
          <target state="translated">위의 방정식에 표시된 뷰포트 매개 변수는 다음 값에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e85e05c1ae03c2860baeff2e63a80e7d1069141" translate="yes" xml:space="preserve">
          <source>The viewport parameters taken from element i of &lt;code&gt;pViewports&lt;/code&gt; replace the current state for the viewport index &lt;code&gt;firstViewport&lt;/code&gt; + i, for i in [0, &lt;code&gt;viewportCount&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;pViewports&lt;/code&gt; 의 요소 i에서 가져온 뷰포트 매개 변수 는 [0, &lt;code&gt;viewportCount&lt;/code&gt; ) 에서 i 의 뷰포트 인덱스 &lt;code&gt;firstViewport&lt;/code&gt; + i에 대한 현재 상태를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="6bda13f6f3ff148e89a26736d0e16306772da2a7" translate="yes" xml:space="preserve">
          <source>The vulkan.h header allows the &lt;code&gt;VK_DEFINE_NON_DISPATCHABLE_HANDLE&lt;/code&gt; definition to be overridden by the application. If &lt;code&gt;VK_DEFINE_NON_DISPATCHABLE_HANDLE&lt;/code&gt; is already defined when the vulkan.h header is compiled the default definition is skipped. This allows the application to define a binary-compatible custom handle which &lt;strong&gt;may&lt;/strong&gt; provide more type-safety or other features needed by the application. Behavior is undefined if the application defines a non-binary-compatible handle and &lt;strong&gt;may&lt;/strong&gt; result in memory corruption or application termination. Binary compatibility is platform dependent so the application &lt;strong&gt;must&lt;/strong&gt; be careful if it overrides the default &lt;code&gt;VK_DEFINE_NON_DISPATCHABLE_HANDLE&lt;/code&gt; definition.</source>
          <target state="translated">vulkan.h 헤더를 사용하면 &lt;code&gt;VK_DEFINE_NON_DISPATCHABLE_HANDLE&lt;/code&gt; 정의를 응용 프로그램에서 재정의 할 수 있습니다. 경우 &lt;code&gt;VK_DEFINE_NON_DISPATCHABLE_HANDLE&lt;/code&gt; 가 vulkan.h 헤더 컴파일 할 때 이미 정의 된 기본 정의가 생략됩니다. 이를 통해 응용 프로그램은 이진 호환 사용자 지정 핸들을 정의하여 응용 프로그램에 필요한 더 많은 형식 안전성 또는 기타 기능을 제공 할 &lt;strong&gt;수 있습니다&lt;/strong&gt; . 응용 프로그램이 비 이진 호환 핸들을 정의하고 메모리 손상 또는 응용 프로그램 종료를 초래할 &lt;strong&gt;수&lt;/strong&gt; 있는 경우 동작이 정의되지 않습니다 . 이진 호환성은 플랫폼에 따라 다르므로 응용 프로그램 이 기본 &lt;code&gt;VK_DEFINE_NON_DISPATCHABLE_HANDLE&lt;/code&gt; 정의를 재정의하는 경우주의 &lt;strong&gt;해야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ce506fa7bdefd4ca123101b400a2ca3505f2d370" translate="yes" xml:space="preserve">
          <source>The width and height of the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-limits-maxViewportDimensions&quot;&gt;implementation-dependent maximum viewport dimensions&lt;/a&gt;&lt;strong&gt;must&lt;/strong&gt; be greater than or equal to the width and height of the largest image which &lt;strong&gt;can&lt;/strong&gt; be created and attached to a framebuffer.</source>
          <target state="translated">의 폭과 높이가 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-limits-maxViewportDimensions&quot;&gt;구현에 의존 최대 뷰포트 사이즈 &lt;/a&gt;&lt;strong&gt;해야&lt;/strong&gt; 보다 크거나 폭이 가장 큰 화상의 높이와 동일 &lt;strong&gt;할 수&lt;/strong&gt; 생성되어 프레임 버퍼에 연결된다.</target>
        </trans-unit>
        <trans-unit id="040b2047602bbe78894ff5fe5f325295655cc7ef" translate="yes" xml:space="preserve">
          <source>There &lt;strong&gt;may&lt;/strong&gt; be a performance cost for using a render area smaller than the framebuffer, unless it matches the render area granularity for the render pass.</source>
          <target state="translated">렌더 패스의 렌더 영역 세분성과 일치하지 않는 경우 프레임 버퍼보다 ​​작은 렌더 영역을 사용하면 성능 비용 이 &lt;strong&gt;발생할 수&lt;/strong&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="4271f85a7276cbd7d7052446e1917ac6c4b355b3" translate="yes" xml:space="preserve">
          <source>There &lt;strong&gt;must&lt;/strong&gt; be at least one memory type with both the &lt;code&gt;VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT&lt;/code&gt; and &lt;code&gt;VK_MEMORY_PROPERTY_HOST_COHERENT_BIT&lt;/code&gt; bits set in its &lt;code&gt;propertyFlags&lt;/code&gt;. There &lt;strong&gt;must&lt;/strong&gt; be at least one memory type with the &lt;code&gt;VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT&lt;/code&gt; bit set in its &lt;code&gt;propertyFlags&lt;/code&gt;.</source>
          <target state="translated">존재 &lt;strong&gt;해야&lt;/strong&gt; 양으로 상기 적어도 하나의 메모리 유형일 &lt;code&gt;VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT&lt;/code&gt; 및 &lt;code&gt;VK_MEMORY_PROPERTY_HOST_COHERENT_BIT&lt;/code&gt; 에 그 설정된 비트 &lt;code&gt;propertyFlags&lt;/code&gt; . 이 &lt;strong&gt;있어야합니다&lt;/strong&gt; 와 적어도 하나 개의 메모리 유형이 될 &lt;code&gt;VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT&lt;/code&gt; 의 의에 비트 세트 &lt;code&gt;propertyFlags&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ec91d30ad7b14cac0056aefe7f90430deecf1aa" translate="yes" xml:space="preserve">
          <source>There are no Vulkan filter modes that directly correspond to OpenGL minification filters of &lt;code&gt;GL_LINEAR&lt;/code&gt; or &lt;code&gt;GL_NEAREST&lt;/code&gt;, but they &lt;strong&gt;can&lt;/strong&gt; be emulated using &lt;code&gt;VK_SAMPLER_MIPMAP_MODE_NEAREST&lt;/code&gt;, &lt;code&gt;minLod&lt;/code&gt; = 0, and &lt;code&gt;maxLod&lt;/code&gt; = 0.25, and using &lt;code&gt;minFilter&lt;/code&gt; = &lt;code&gt;VK_FILTER_LINEAR&lt;/code&gt; or &lt;code&gt;minFilter&lt;/code&gt; = &lt;code&gt;VK_FILTER_NEAREST&lt;/code&gt;, respectively.</source>
          <target state="translated">&lt;code&gt;GL_LINEAR&lt;/code&gt; 또는 &lt;code&gt;GL_NEAREST&lt;/code&gt; 의 OpenGL 축소 필터에 직접 대응되는 Vulkan 필터 모드는 없지만 &lt;code&gt;VK_SAMPLER_MIPMAP_MODE_NEAREST&lt;/code&gt; , &lt;code&gt;minLod&lt;/code&gt; = 0 및 &lt;code&gt;maxLod&lt;/code&gt; = 0.25를 사용 하고 각각 &lt;code&gt;minFilter&lt;/code&gt; = &lt;code&gt;VK_FILTER_LINEAR&lt;/code&gt; 또는 &lt;code&gt;minFilter&lt;/code&gt; = &lt;code&gt;VK_FILTER_NEAREST&lt;/code&gt; 사용하여 에뮬레이션 할 &lt;strong&gt;수&lt;/strong&gt; 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e17c8ac309406162c75b6dc324975ff41ab69834" translate="yes" xml:space="preserve">
          <source>There is a subpass &lt;strong&gt;S&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt; that uses or preserves the attachment, and a subpass dependency from &lt;strong&gt;S&lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt; to &lt;strong&gt;S&lt;/strong&gt;.</source>
          <target state="translated">subpass 거기 &lt;strong&gt;S &lt;sub&gt;(1)를&lt;/sub&gt;&lt;/strong&gt; 그 용도 나 보존 첨부 한로부터 subpass 의존성 &lt;strong&gt;S &lt;sub&gt;1&lt;/sub&gt;&lt;/strong&gt; 을 &lt;strong&gt;S&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3c78d23ea75b660fd0da3e971315140a57998cb0" translate="yes" xml:space="preserve">
          <source>There is an implementation-dependent maximum number of memory allocations which &lt;strong&gt;can&lt;/strong&gt; be simultaneously created on a device. This is specified by the &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-limits-maxMemoryAllocationCount&quot;&gt;&lt;code&gt;maxMemoryAllocationCount&lt;/code&gt;&lt;/a&gt; member of the &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; structure. If &lt;code&gt;maxMemoryAllocationCount&lt;/code&gt; is exceeded, &lt;code&gt;vkAllocateMemory&lt;/code&gt; will return &lt;code&gt;VK_ERROR_TOO_MANY_OBJECTS&lt;/code&gt;.</source>
          <target state="translated">장치에 동시에 만들 &lt;strong&gt;수&lt;/strong&gt; 있는 구현 종속적 인 최대 메모리 할당 수가 &lt;strong&gt;있습니다&lt;/strong&gt; . 이것은 &lt;code&gt;VkPhysicalDeviceLimits&lt;/code&gt; 구조 의 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#features-limits-maxMemoryAllocationCount&quot;&gt; &lt;code&gt;maxMemoryAllocationCount&lt;/code&gt; &lt;/a&gt; 멤버에 의해 지정됩니다 . &lt;code&gt;maxMemoryAllocationCount&lt;/code&gt; 가 초과 되면 vkAllocateMemory 는 &lt;code&gt;vkAllocateMemory&lt;/code&gt; 를 반환 &lt;code&gt;VK_ERROR_TOO_MANY_OBJECTS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a491cfb6bfe3594f50c4f122eda503e38e7c1ce" translate="yes" xml:space="preserve">
          <source>There is no global state in Vulkan and all per-application state is stored in a &lt;code&gt;VkInstance&lt;/code&gt; object. Creating a &lt;code&gt;VkInstance&lt;/code&gt; object initializes the Vulkan library and allows the application to pass information about itself to the implementation.</source>
          <target state="translated">Vulkan에는 전역 상태가 없으며 모든 응용 프로그램 별 상태는 &lt;code&gt;VkInstance&lt;/code&gt; 개체에 저장됩니다 . 만들기 &lt;code&gt;VkInstance&lt;/code&gt; 의 목적은 VULKAN 라이브러리를 초기화하고 응용 프로그램이 구현 자체에 대한 정보를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4930b91363d357418428590b9f803dd9ce553156" translate="yes" xml:space="preserve">
          <source>There is no mechanism to query the size of an image before creating it, to compare that size against &lt;code&gt;maxResourceSize&lt;/code&gt;. If an application attempts to create an image that exceeds this limit, the creation will fail or the image will be invalid. While the advertised limit &lt;strong&gt;must&lt;/strong&gt; be at least 2&lt;sup&gt;31&lt;/sup&gt;, it &lt;strong&gt;may&lt;/strong&gt; not be possible to create an image that approaches that size, particularly for &lt;code&gt;VK_IMAGE_TYPE_1D&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;maxResourceSize&lt;/code&gt; 와 크기를 비교하기 위해 이미지를 작성하기 전에 이미지의 크기를 쿼리하는 메커니즘이 없습니다 . 응용 프로그램이이 한계를 초과하는 이미지를 작성하려고하면 작성에 실패하거나 이미지가 유효하지 않습니다. 보급 제한하면서 &lt;strong&gt;해야&lt;/strong&gt; 적어도 2 일 &lt;sup&gt;(31)&lt;/sup&gt; , 그 &lt;strong&gt;수도&lt;/strong&gt; 특별히 위해 그 크기에 근접 영상 생성하는 것이 가능하지 &lt;code&gt;VK_IMAGE_TYPE_1D&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="24099cf06b9bee682799be8656a40584d910789b" translate="yes" xml:space="preserve">
          <source>These base coordinates are then offset by the first destination offset:</source>
          <target state="translated">그런 다음이 기본 좌표는 첫 번째 대상 오프셋으로 오프셋됩니다.</target>
        </trans-unit>
        <trans-unit id="64489f90cc2dbb129e55b12499f631e51dc21349" translate="yes" xml:space="preserve">
          <source>These colors are described in detail in &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#textures-texel-replacement&quot;&gt;Texel Replacement&lt;/a&gt;.</source>
          <target state="translated">이러한 색상은 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#textures-texel-replacement&quot;&gt;Texel Replacement&lt;/a&gt; 에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b0159a534c33a379dbb07b20b6029b7fa6019f8" translate="yes" xml:space="preserve">
          <source>These coordinates are used to sample from the source image, as described in &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#textures&quot;&gt;Image Operations chapter&lt;/a&gt;, with the filter mode equal to that of &lt;code&gt;filter&lt;/code&gt;, a mipmap mode of &lt;code&gt;VK_SAMPLER_MIPMAP_MODE_NEAREST&lt;/code&gt; and an address mode of &lt;code&gt;VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE&lt;/code&gt;. Implementations &lt;strong&gt;must&lt;/strong&gt; clamp at the edge of the source image, and &lt;strong&gt;may&lt;/strong&gt; additionally clamp to the edge of the source region.</source>
          <target state="translated">에 기술 된 바와 같이 이러한 좌표가 원본 이미지에서 사용되는 샘플 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#textures&quot;&gt;이미지 조작 챕터&lt;/a&gt; 의 동일한 필터 모드, &lt;code&gt;filter&lt;/code&gt; 의 밉맵 모드 &lt;code&gt;VK_SAMPLER_MIPMAP_MODE_NEAREST&lt;/code&gt; 그리고 어드레스 모드 &lt;code&gt;VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE&lt;/code&gt; . 구현 &lt;strong&gt;은&lt;/strong&gt; 소스 이미지 의 가장자리에 고정되어야하며 소스 영역의 가장자리에 추가로 고정 &lt;strong&gt;될 수 있습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="6eb39edba45f12d3132f8aa5cbf785899d220c1e" translate="yes" xml:space="preserve">
          <source>These filters are described in detail in &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#textures-texel-filtering&quot;&gt;Texel Filtering&lt;/a&gt;.</source>
          <target state="translated">이러한 필터는 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#textures-texel-filtering&quot;&gt;Texel Filtering&lt;/a&gt; 에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="30692e1c13ededaacad9c849877c962c162e6d06" translate="yes" xml:space="preserve">
          <source>These modes affect only the final rasterization of polygons: in particular, a polygon&amp;rsquo;s vertices are shaded and the polygon is clipped and possibly culled before these modes are applied.</source>
          <target state="translated">이러한 모드는 다각형의 최종 래스터 화에만 영향을줍니다. 특히 다각형의 정점이 음영 처리되고 다각형이 잘리고 이러한 모드가 적용되기 전에 컬링 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3103d3743b08f0841d7a1150bfefa9da4df3a9e8" translate="yes" xml:space="preserve">
          <source>These modes are described in detail in &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#textures-texel-filtering&quot;&gt;Texel Filtering&lt;/a&gt;.</source>
          <target state="translated">이러한 모드는 &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#textures-texel-filtering&quot;&gt;텍셀 필터링&lt;/a&gt; 에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b91338e13062917fd8d49405c7110cff3ee2556" translate="yes" xml:space="preserve">
          <source>These values are intended to measure relative statistics on one implementation. Various device architectures will count these values differently. Any or all counters &lt;strong&gt;may&lt;/strong&gt; be affected by the issues described in &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-operation-undefined&quot;&gt;Query Operation&lt;/a&gt;.</source>
          <target state="translated">이 값은 한 구현에서 상대 통계를 측정하기위한 것입니다. 다양한 장치 아키텍처에서이 값을 다르게 계산합니다. &lt;a href=&quot;https://www.khronos.org/registry/vulkan/specs/1.0/html/vkspec.html#queries-operation-undefined&quot;&gt;쿼리 작업에&lt;/a&gt; 설명 된 문제로 인해 모든 카운터 &lt;strong&gt;가&lt;/strong&gt; 영향을받을 &lt;strong&gt;수&lt;/strong&gt; 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0432ad8ea9ac8a6371af658f747f0b1aaa984c75" translate="yes" xml:space="preserve">
          <source>This allows the last compressed texel block of the image in each non-multiple dimension to be included as a source or destination of the copy.</source>
          <target state="translated">이것은 다중이 아닌 각 차원에서 이미지의 마지막 압축 된 텍셀 블록이 사본의 소스 또는 대상으로 포함되도록합니다.</target>
        </trans-unit>
        <trans-unit id="32d67a6a010db08cb7cbee09ae62081cc40d2d31" translate="yes" xml:space="preserve">
          <source>This command &lt;strong&gt;must&lt;/strong&gt; only be called inside of a render pass instance</source>
          <target state="translated">이 명령 &lt;strong&gt;은&lt;/strong&gt; 렌더 패스 인스턴스 내에서만 호출 &lt;strong&gt;해야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="10ae78c7bb735edd8cb22a9c1f299d658706e238" translate="yes" xml:space="preserve">
          <source>This command &lt;strong&gt;must&lt;/strong&gt; only be called outside of a render pass instance</source>
          <target state="translated">이 명령 &lt;strong&gt;은&lt;/strong&gt; 렌더 패스 인스턴스 외부에서만 호출 &lt;strong&gt;해야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8d7c911fa9621656f34fe4b77934410504543a23" translate="yes" xml:space="preserve">
          <source>This is a purely informational callback.</source>
          <target state="translated">이것은 순전히 정보를 제공하는 콜백입니다.</target>
        </trans-unit>
        <trans-unit id="793f467b177506a6a7574bbd94cdd31a9c25fac5" translate="yes" xml:space="preserve">
          <source>This macro &lt;strong&gt;can&lt;/strong&gt; be used when constructing the &lt;a href=&quot;#VkApplicationInfo&quot;&gt;VkApplicationInfo&lt;/a&gt;::&lt;code&gt;apiVersion&lt;/code&gt; parameter passed to &lt;a href=&quot;#vkCreateInstance&quot;&gt;vkCreateInstance&lt;/a&gt;.</source>
          <target state="translated">이 매크로는 &lt;strong&gt;수&lt;/strong&gt; 구성 할 때 사용할 수 &lt;a href=&quot;#VkApplicationInfo&quot;&gt;VkApplicationInfo&lt;/a&gt; :: &lt;code&gt;apiVersion&lt;/code&gt; 의 전달 매개 변수 &lt;a href=&quot;#vkCreateInstance&quot;&gt;vkCreateInstance을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="50967c23579778cdefd5f4195f1eb73b55ca84fd" translate="yes" xml:space="preserve">
          <source>This page is a generated document. Fixes and changes should be made to the generator scripts, not directly.</source>
          <target state="translated">이 페이지는 생성 된 문서입니다. 생성기 스크립트를 직접 수정하지 말고 수정하고 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="6d3744f49fa1443c89fc0da04c14165ba6ad90b5" translate="yes" xml:space="preserve">
          <source>This restriction means that the render pass has full knowledge of all uses of all of the attachments, so that the implementation is able to make correct decisions about when and how to perform layout transitions, when to overlap execution of subpasses, etc.</source>
          <target state="translated">이 제한은 렌더 패스가 모든 첨부 파일의 모든 용도에 대한 모든 지식을 갖추고 있으므로 구현시 레이아웃 전환을 수행하는시기와 방법, 서브 패스 실행과 중복되는시기 등에 대한 올바른 결정을 내릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e067e5b5d2e5eca5086fe9127c97682f7d58459" translate="yes" xml:space="preserve">
          <source>This union is used where part of the API requires either color or depth/stencil clear values, depending on the attachment, and defines the initial clear values in the &lt;a href=&quot;#VkRenderPassBeginInfo&quot;&gt;VkRenderPassBeginInfo&lt;/a&gt; structure.</source>
          <target state="translated">이 공용체는 첨부 파일에 따라 API의 일부에 색상 또는 깊이 / 스텐실 투명 값이 필요한 경우에 사용되며 &lt;a href=&quot;#VkRenderPassBeginInfo&quot;&gt;VkRenderPassBeginInfo&lt;/a&gt; 구조 에서 초기 투명 값을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="1aef8c9e8eb1d7a90f50e9c1bb403a8a1e0b0c50" translate="yes" xml:space="preserve">
          <source>To allocate command buffers, call:</source>
          <target state="translated">명령 버퍼를 할당하려면 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="6b20f0130ba0fad974419761771dd338c83d125f" translate="yes" xml:space="preserve">
          <source>To allocate descriptor sets from a descriptor pool, call:</source>
          <target state="translated">디스크립터 풀에서 디스크립터 세트를 할당하려면 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="7555a11fd062095e524fdcd196228de29092ef32" translate="yes" xml:space="preserve">
          <source>To allocate memory objects, call:</source>
          <target state="translated">메모리 객체를 할당하려면 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="615fa4d5583c87e1142196c86fca2bb07b45f3d0" translate="yes" xml:space="preserve">
          <source>To attach memory to a buffer object, call:</source>
          <target state="translated">버퍼 객체에 메모리를 연결하려면 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="1680ffc10a228e8d720ed08f1d0a6ac879f906ec" translate="yes" xml:space="preserve">
          <source>To attach memory to an image object, call:</source>
          <target state="translated">이미지 객체에 메모리를 연결하려면 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="64bb1b826b19b78c84ee3ba86a477a2da0851b25" translate="yes" xml:space="preserve">
          <source>To begin a query, call:</source>
          <target state="translated">쿼리를 시작하려면 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="b07c2355a44ca6f58bf6f9651f07d0c919fadc56" translate="yes" xml:space="preserve">
          <source>To begin a render pass instance, call:</source>
          <target state="translated">렌더 패스 인스턴스를 시작하려면 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="3be0ac278e471208630efa76c88eabcf7de66de9" translate="yes" xml:space="preserve">
          <source>To begin recording a command buffer, call:</source>
          <target state="translated">명령 버퍼 기록을 시작하려면 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="d4d1f168cdf034a59fa62e8bc357fc21b96758a2" translate="yes" xml:space="preserve">
          <source>To bind an index buffer to a command buffer, call:</source>
          <target state="translated">인덱스 버퍼를 명령 버퍼에 바인딩하려면 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="50690f60e769e7d7103105681eedbdb23e0c5852" translate="yes" xml:space="preserve">
          <source>To bind one or more descriptor sets to a command buffer, call:</source>
          <target state="translated">하나 이상의 디스크립터 세트를 명령 버퍼에 바인드하려면 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="9c435bacd4629dc2424dc087cc97c57e3973d0aa" translate="yes" xml:space="preserve">
          <source>To bind vertex buffers to a command buffer for use in subsequent draw commands, call:</source>
          <target state="translated">후속 그리기 명령에 사용하기 위해 정점 버퍼를 명령 버퍼에 바인딩하려면 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="c2358f12c919badc0c2a67faadde0e585f56ee3b" translate="yes" xml:space="preserve">
          <source>To clear buffer data, call:</source>
          <target state="translated">버퍼 데이터를 지우려면 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="c81cf0b6a2a2ea9a0db02d18d3d242030ac0980f" translate="yes" xml:space="preserve">
          <source>To clear one or more regions of color and depth/stencil attachments inside a render pass instance, call:</source>
          <target state="translated">렌더 패스 인스턴스 내에서 하나 이상의 색상 및 깊이 / 스텐실 부착 영역을 지우려면 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="365bbb3cb0968432e53d6db60cf89d26201849fa" translate="yes" xml:space="preserve">
          <source>To clear one or more subranges of a color image, call:</source>
          <target state="translated">컬러 이미지의 하나 이상의 하위 범위를 지우려면 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="09d300f6450259928de5529ab2f3bf4c3ab3d28e" translate="yes" xml:space="preserve">
          <source>To clear one or more subranges of a depth/stencil image, call:</source>
          <target state="translated">깊이 / 스텐실 이미지의 하나 이상의 하위 범위를 지우려면 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="b80336cb92cd34caa26bd8321f4908bee7c34c15" translate="yes" xml:space="preserve">
          <source>To complete recording of a command buffer, call:</source>
          <target state="translated">명령 버퍼의 기록을 완료하려면 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="bee9945ea5e072bbed6272da07073b91d4a45af0" translate="yes" xml:space="preserve">
          <source>To copy both the depth and stencil aspects of a depth/stencil format, two entries in &lt;code&gt;pRegions&lt;/code&gt;&lt;strong&gt;can&lt;/strong&gt; be used, where one specifies the depth aspect in &lt;code&gt;imageSubresource&lt;/code&gt;, and the other specifies the stencil aspect.</source>
          <target state="translated">깊이 / 스텐실 형식의 깊이 및 스텐실 측면을 모두 복사하기 위해 &lt;code&gt;pRegions&lt;/code&gt; 의 두 항목을 사용할 &lt;strong&gt;수&lt;/strong&gt; 있습니다. 하나는 &lt;code&gt;imageSubresource&lt;/code&gt; 에서 깊이 측면을 지정하고 다른 하나는 스텐실 측면을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="8332f4221e849dd84bc88daa0d2c27c0e53a95ea" translate="yes" xml:space="preserve">
          <source>To copy data between buffer objects, call:</source>
          <target state="translated">버퍼 객체간에 데이터를 복사하려면 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="d672dfee89874e29ce6332ba8b462934c390bb05" translate="yes" xml:space="preserve">
          <source>To copy data between image objects, call:</source>
          <target state="translated">이미지 객체간에 데이터를 복사하려면 다음을 호출하십시오.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
