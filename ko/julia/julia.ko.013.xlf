<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="0ac236a3ea7a0e9ead5326f9e44c423dc78ebc26" translate="yes" xml:space="preserve">
          <source>Tests whether a character is a lowercase letter. A character is classified as lowercase if it belongs to Unicode category Ll, Letter: Lowercase.</source>
          <target state="translated">문자가 소문자인지 테스트합니다. 문자가 유니 코드 범주 L1, 문자 : 소문자에 속하는 경우 소문자로 분류됩니다.</target>
        </trans-unit>
        <trans-unit id="91cdaf6d3cfe470a11194162162137ec98b73f57" translate="yes" xml:space="preserve">
          <source>Tests whether a character is an uppercase letter. A character is classified as uppercase if it belongs to Unicode category Lu, Letter: Uppercase, or Lt, Letter: Titlecase.</source>
          <target state="translated">문자가 대문자인지 테스트합니다. 문자가 유니 코드 범주 Lu, Letter : Uppercase 또는 Lt, Letter : Titlecase에 속하는 경우 대문자로 분류됩니다.</target>
        </trans-unit>
        <trans-unit id="45909810023531a635329b57dc9f15acb810e806" translate="yes" xml:space="preserve">
          <source>Tests whether a character is any whitespace character. Includes ASCII characters '\t', '\n', '\v', '\f', '\r', and ' ', Latin-1 character U+0085, and characters in Unicode category Zs.</source>
          <target state="translated">문자가 공백 문자인지 테스트합니다. ASCII 문자 '\ t', '\ n', '\ v', '\ f', '\ r'및 '', 라틴 -1 문자 U + 0085 및 유니 코드 범주 Zs의 문자를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="b0a4dc18e63052a8e4b050ac6060b42fea1cafaa" translate="yes" xml:space="preserve">
          <source>Tests whether a character is numeric. A character is classified as numeric if it belongs to the Unicode general category Number, i.e. a character whose category code begins with 'N'.</source>
          <target state="translated">문자가 숫자인지 테스트합니다. 문자가 유니 코드 일반 범주 번호 (예 : 범주 코드가 'N'으로 시작하는 문자)에 속하는 경우 숫자로 분류됩니다.</target>
        </trans-unit>
        <trans-unit id="982f0addad2d0da939982a5caca6283ccb1d7eb4" translate="yes" xml:space="preserve">
          <source>Tests whether a character is printable, including spaces, but not a control character.</source>
          <target state="translated">공백을 포함하여 문자를 인쇄 할 수 있지만 제어 문자는 인쇄 할 수 없는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="e49525a9628b3bad0a6106685a8ac5eeac97a7e1" translate="yes" xml:space="preserve">
          <source>Tests whether a global variable or object field is defined. The arguments can be a module and a symbol or a composite object and field name (as a symbol) or index.</source>
          <target state="translated">글로벌 변수 또는 오브젝트 필드가 정의되어 있는지 테스트합니다. 인수는 모듈 및 심볼 또는 복합 객체 및 필드 이름 (기호) 또는 인덱스 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b292cfab7944ffbf6199920c5349913e95d9eeb7" translate="yes" xml:space="preserve">
          <source>Tests whether variable &lt;code&gt;s&lt;/code&gt; is defined in the current scope.</source>
          <target state="translated">변수 &lt;code&gt;s&lt;/code&gt; 가 현재 범위에 정의되어 있는지 테스트합니다 .</target>
        </trans-unit>
        <trans-unit id="109f7c2f219315f947611c43c343d61302c960d4" translate="yes" xml:space="preserve">
          <source>Text I/O</source>
          <target state="translated">텍스트 I / O</target>
        </trans-unit>
        <trans-unit id="ea824a563aca9df06f453afa8aed6e59740fd02e" translate="yes" xml:space="preserve">
          <source>Text from external sources, such as quotations from books or websites, can be quoted using &lt;code&gt;&amp;gt;&lt;/code&gt; characters prepended to each line of the quote as follows.</source>
          <target state="translated">책이나 웹 사이트의 인용과 같은 외부 소스의 텍스트는 다음과 같이 인용의 각 줄 앞에 &lt;code&gt;&amp;gt;&lt;/code&gt; 문자를 사용하여 인용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fbe2b75f7fbda9be349dabaf963a9b88611d5493" translate="yes" xml:space="preserve">
          <source>That is really all there is to using promotions. The rest is just a matter of clever application, the most typical &quot;clever&quot; application being the definition of catch-all methods for numeric operations like the arithmetic operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;. Here are some of the catch-all method definitions given in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt;&lt;code&gt;promotion.jl&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">그것이 실제로 프로모션을 사용하는 모든 것입니다. 나머지는 영리한 응용 프로그램의 문제이며, 가장 일반적인 &quot;영리한&quot;응용 프로그램은 산술 연산자 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;/&lt;/code&gt; 와 같은 숫자 연산을위한 모든 방법을 정의하는 것입니다 . &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt; &lt;code&gt;promotion.jl&lt;/code&gt; 에&lt;/a&gt; 주어진 모든 포괄 메소드 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a55180ee0e35250f4a5e86928557c4ebfc2a5b49" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;fdot(x)&lt;/code&gt; is ten times faster and allocates 1/6 the memory of &lt;code&gt;f(x)&lt;/code&gt;, because each &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; operation in &lt;code&gt;f(x)&lt;/code&gt; allocates a new temporary array and executes in a separate loop. (Of course, if you just do &lt;code&gt;f.(x)&lt;/code&gt; then it is as fast as &lt;code&gt;fdot(x)&lt;/code&gt; in this example, but in many contexts it is more convenient to just sprinkle some dots in your expressions rather than defining a separate function for each vectorized operation.)</source>
          <target state="translated">즉, &lt;code&gt;fdot(x)&lt;/code&gt; 의 메모리 1/6 열 배 빠르며 할당 &lt;code&gt;f(x)&lt;/code&gt; 각각 때문에 &lt;code&gt;*&lt;/code&gt; 와 &lt;code&gt;+&lt;/code&gt; 에서 동작 &lt;code&gt;f(x)&lt;/code&gt; 별도의 루프에서 새로운 임시 배열을 할당하고 실행한다. (물론 &lt;code&gt;f.(x)&lt;/code&gt; 를 수행하면 이 예제에서는 &lt;code&gt;fdot(x)&lt;/code&gt; 만큼 빠르지 만 많은 컨텍스트에서 별도의 함수를 정의하는 대신 표현식에 일부 점을 뿌리는 것이 더 편리합니다 각 벡터화 된 작업.)</target>
        </trans-unit>
        <trans-unit id="96ae6d125bf587e76e862ea35e250d9a1dd1ac01" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;maxintfloat&lt;/code&gt; returns the smallest positive integer-valued floating-point number &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;n+1&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; exactly representable in the type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">이다, &lt;code&gt;maxintfloat&lt;/code&gt; 반환 가장 작은 양의 정수 값 부동 소수점 숫자 &lt;code&gt;n&lt;/code&gt; 하도록 &lt;code&gt;n+1&lt;/code&gt; 입니다 &lt;em&gt;하지&lt;/em&gt; 유형에 정확히 표현할 &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5135aa1a424ac6b5ea53a127625ebc585292c35c" translate="yes" xml:space="preserve">
          <source>That is, in the first call, the expression &lt;code&gt;:(1 == 1.0)&lt;/code&gt; is spliced into the test condition slot, while the value of &lt;code&gt;string(:(1 == 1.0))&lt;/code&gt; is spliced into the assertion message slot. The entire expression, thus constructed, is placed into the syntax tree where the &lt;code&gt;@assert&lt;/code&gt; macro call occurs. Then at execution time, if the test expression evaluates to true, then &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; is returned, whereas if the test is false, an error is raised indicating the asserted expression that was false. Notice that it would not be possible to write this as a function, since only the &lt;em&gt;value&lt;/em&gt; of the condition is available and it would be impossible to display the expression that computed it in the error message.</source>
          <target state="translated">즉, 첫 번째 호출에서 표현식 &lt;code&gt;:(1 == 1.0)&lt;/code&gt; 은 테스트 조건 슬롯에 연결되고 &lt;code&gt;string(:(1 == 1.0))&lt;/code&gt; 의 값은 어설 션 메시지 슬롯에 연결됩니다. 이렇게 구성된 전체 표현식은 &lt;code&gt;@assert&lt;/code&gt; 매크로 호출이 발생 하는 구문 트리에 배치됩니다 . 그런 다음 실행시 테스트식이 true로 평가되면 &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; 반환 되지 않지만 테스트가 false이면 어설 션 된식이 false임을 나타내는 오류가 발생합니다. 조건 의 &lt;em&gt;값만&lt;/em&gt; 사용 가능하며이를 계산 한 표현식을 오류 메시지에 표시 할 수 없으므로이를 함수로 작성할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="a5c2c27899b95213132fa8a21acc33667eaa425d" translate="yes" xml:space="preserve">
          <source>That is, write:</source>
          <target state="translated">즉, 다음과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="d78e12b42ebbdc9ccff0d1ee38bf8bf79ad2272d" translate="yes" xml:space="preserve">
          <source>That may seem confusing, given that the hour (12) is not divisible by 10. The reason that &lt;code&gt;2016-07-17T12:00:00&lt;/code&gt; was chosen is that it is 17,676,660 hours after &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt;, and 17,676,660 is divisible by 10.</source>
          <target state="translated">즉, 시간 (12)이라는 이유 (10)에 의해 나눌 수없는 주어진 혼란을 보일 수있다 &lt;code&gt;2016-07-17T12:00:00&lt;/code&gt; 선택되었다 그것이 1천7백67만6천6백60시간 후 있다는 &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; 및 17,676,660은 10으로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8eac926841ffd7462f202ab5376273deeb8cd2ba" translate="yes" xml:space="preserve">
          <source>That's all. This macro says that the literal contents of the string literal &lt;code&gt;r&quot;^\s*(?:#|$)&quot;&lt;/code&gt; should be passed to the &lt;code&gt;@r_str&lt;/code&gt; macro and the result of that expansion should be placed in the syntax tree where the string literal occurs. In other words, the expression &lt;code&gt;r&quot;^\s*(?:#|$)&quot;&lt;/code&gt; is equivalent to placing the following object directly into the syntax tree:</source>
          <target state="translated">그게 다야. 이 매크로는 문자열 리터럴 &lt;code&gt;r&quot;^\s*(?:#|$)&quot;&lt;/code&gt; 의 리터럴 내용을 &lt;code&gt;@r_str&lt;/code&gt; 매크로 로 전달 해야하며 확장 결과는 문자열 리터럴이있는 구문 트리에 있어야합니다. 발생합니다. 즉, &lt;code&gt;r&quot;^\s*(?:#|$)&quot;&lt;/code&gt; 식은 다음 객체를 구문 트리에 직접 배치하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ececc5f47222691560cc9e3bee59dad9b3d640dc" translate="yes" xml:space="preserve">
          <source>The &quot;splat&quot; operator, &lt;code&gt;...&lt;/code&gt;, represents a sequence of arguments. &lt;code&gt;...&lt;/code&gt; can be used in function definitions, to indicate that the function accepts an arbitrary number of arguments. &lt;code&gt;...&lt;/code&gt; can also be used to apply a function to a sequence of arguments.</source>
          <target state="translated">&quot;splat&quot;연산자, &lt;code&gt;...&lt;/code&gt; 은 일련의 인수를 나타냅니다. &lt;code&gt;...&lt;/code&gt; 는 함수가 임의의 수의 인수를 허용 함을 나타 내기 위해 함수 정의에 사용될 수 있습니다. &lt;code&gt;...&lt;/code&gt; 함수를 일련의 인수에 적용하는 데에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e87b92b09ff210cf587ecb8ad71387d805a3837" translate="yes" xml:space="preserve">
          <source>The 32-bit byte-order-mark indicates the native byte order of the host machine. Little-endian machines will contain the value &lt;code&gt;0x04030201&lt;/code&gt;. Big-endian machines will contain the value &lt;code&gt;0x01020304&lt;/code&gt;.</source>
          <target state="translated">32 비트 바이트 순서 표시는 호스트 시스템의 기본 바이트 순서를 나타냅니다. 리틀 엔디안 머신에는 &lt;code&gt;0x04030201&lt;/code&gt; 값이 포함됩니다 . 빅 엔디안 머신에는 &lt;code&gt;0x01020304&lt;/code&gt; 값이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="bc0d418f0a58caa5e7b5119be0993120b5604ac3" translate="yes" xml:space="preserve">
          <source>The 32-bit floating-point literal expression &lt;code&gt;1.5f22&lt;/code&gt; could be interpreted as the numeric literal &lt;code&gt;1.5&lt;/code&gt; multiplied by the variable &lt;code&gt;f22&lt;/code&gt;.</source>
          <target state="translated">32 비트 부동 소수점 리터럴 표현식 &lt;code&gt;1.5f22&lt;/code&gt; 는 변수 &lt;code&gt;f22&lt;/code&gt; 를 곱한 숫자 리터럴 &lt;code&gt;1.5&lt;/code&gt; 로 해석 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0554b963c33c05a019079c25e9e8af324781e9db" translate="yes" xml:space="preserve">
          <source>The 5 allocations seen are from running the &lt;code&gt;@time&lt;/code&gt; macro itself in global scope. If we instead run the timing in a function, we can see that indeed no allocations are performed:</source>
          <target state="translated">5 개의 할당은 &lt;code&gt;@time&lt;/code&gt; 매크로 자체를 전역 범위 에서 실행하는 것입니다. 대신 함수에서 타이밍을 실행하면 실제로 할당이 수행되지 않음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dea49356c38a6636e3d8df6877285b62b149f3f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Base.CoreLogging.shouldlog&quot;&gt;&lt;code&gt;Logging.shouldlog&lt;/code&gt;&lt;/a&gt; function is called with the current logger, taking some minimal information (level, module, group, id) which can be computed statically. Most usefully, &lt;code&gt;shouldlog&lt;/code&gt; is passed an event &lt;code&gt;id&lt;/code&gt; which can be used to discard events early based on a cached predicate.</source>
          <target state="translated">&lt;a href=&quot;#Base.CoreLogging.shouldlog&quot;&gt; &lt;code&gt;Logging.shouldlog&lt;/code&gt; 의&lt;/a&gt; 기능은 정적으로 계산 될 수있는 최소한의 정보 (레벨, 모듈, 그룹 ID)를 가지고, 현재의 기록 장치로 불린다. 가장 &lt;code&gt;shouldlog&lt;/code&gt; 것은 shouldlog 에 캐시 된 술어를 기반으로 이벤트를 조기에 버리는 데 사용할 수 있는 이벤트 &lt;code&gt;id&lt;/code&gt; 를 전달하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="9817feb15ee575eea4a8ff720d63067615a333e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; types implements arbitrary-precision floating point and integer arithmetic, respectively. For &lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; the &lt;a href=&quot;https://www.mpfr.org/&quot;&gt;GNU MPFR library&lt;/a&gt; is used, and for &lt;a href=&quot;#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; the &lt;a href=&quot;https://gmplib.org&quot;&gt;GNU Multiple Precision Arithmetic Library (GMP)&lt;/a&gt; is used.</source>
          <target state="translated">&lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; 유형의 구현은 임의의 밀도를 각각 포인트 정수 산술 부동. 들어 &lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://www.mpfr.org/&quot;&gt; GNU MPFR 라이브러리가&lt;/a&gt; 사용되며, 위해 &lt;a href=&quot;#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://gmplib.org&quot;&gt; GNU 여러 정밀 산술 라이브러리 (GMP)을&lt;/a&gt; 사용한다.</target>
        </trans-unit>
        <trans-unit id="ad3f2b7adf33af93573e441a9559f7a7900079c4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display&lt;/code&gt;&lt;/a&gt; functions ultimately call &lt;code&gt;show&lt;/code&gt; in order to write an object &lt;code&gt;x&lt;/code&gt; as a given &lt;code&gt;mime&lt;/code&gt; type to a given I/O stream &lt;code&gt;io&lt;/code&gt; (usually a memory buffer), if possible. In order to provide a rich multimedia representation of a user-defined type &lt;code&gt;T&lt;/code&gt;, it is only necessary to define a new &lt;code&gt;show&lt;/code&gt; method for &lt;code&gt;T&lt;/code&gt;, via: &lt;code&gt;show(io, ::MIME&quot;mime&quot;, x::T) = ...&lt;/code&gt;, where &lt;code&gt;mime&lt;/code&gt; is a MIME-type string and the function body calls &lt;a href=&quot;#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; (or similar) to write that representation of &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;io&lt;/code&gt;. (Note that the &lt;code&gt;MIME&quot;&quot;&lt;/code&gt; notation only supports literal strings; to construct &lt;code&gt;MIME&lt;/code&gt; types in a more flexible manner use &lt;code&gt;MIME{Symbol(&quot;&quot;)}&lt;/code&gt;.)</source>
          <target state="translated">&lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display&lt;/code&gt; &lt;/a&gt; 기능 궁극적 호출 &lt;code&gt;show&lt;/code&gt; 오브젝트 작성하기 위해 &lt;code&gt;x&lt;/code&gt; 소정 같은 &lt;code&gt;mime&lt;/code&gt; 소정의 I / O 스트림에 타입 &lt;code&gt;io&lt;/code&gt; 가능한 경우 (일반적으로 메모리 버퍼). 사용자 정의 유형 &lt;code&gt;T&lt;/code&gt; 의 풍부한 멀티미디어 표현을 제공하려면 &lt;code&gt;show(io, ::MIME&quot;mime&quot;, x::T) = ...&lt;/code&gt; 통해 &lt;code&gt;T&lt;/code&gt; 에 대한 새로운 &lt;code&gt;show&lt;/code&gt; 방법 만 정의하면됩니다 . . 여기서 &lt;code&gt;mime&lt;/code&gt; 는 MIME 타입의 스트링이고, 함수 본문 호출 &lt;a href=&quot;#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 의 표현을 작성하는 (또는 이와 유사한) &lt;code&gt;x&lt;/code&gt; 에 &lt;code&gt;io&lt;/code&gt; . ( &lt;code&gt;MIME&quot;&quot;&lt;/code&gt; 표기법은 리터럴 문자열 만 지원합니다. 보다 유연한 방식으로 &lt;code&gt;MIME&lt;/code&gt; 유형 을 구성 하려면 &lt;code&gt;MIME{Symbol(&quot;&quot;)}&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="5436a7d5a656260665ad063d5ab1e6eff72c987d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Base.Rounding.RoundingMode&quot;&gt;&lt;code&gt;RoundingMode&lt;/code&gt;&lt;/a&gt;&lt;code&gt;r&lt;/code&gt; controls the direction of the rounding; the default is &lt;a href=&quot;#Base.Rounding.RoundNearest&quot;&gt;&lt;code&gt;RoundNearest&lt;/code&gt;&lt;/a&gt;, which rounds to the nearest integer, with ties (fractional values of 0.5) being rounded to the nearest even integer. Note that &lt;code&gt;round&lt;/code&gt; may give incorrect results if the global rounding mode is changed (see &lt;a href=&quot;../numbers/index#Base.Rounding.rounding&quot;&gt;&lt;code&gt;rounding&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;#Base.Rounding.RoundingMode&quot;&gt; &lt;code&gt;RoundingMode&lt;/code&gt; &lt;/a&gt; &lt;code&gt;r&lt;/code&gt; 제어 라운딩의 방향; 기본값은 &lt;a href=&quot;#Base.Rounding.RoundNearest&quot;&gt; &lt;code&gt;RoundNearest&lt;/code&gt; &lt;/a&gt; 이며, 가장 가까운 정수로 반올림하고 관계 (분수 값 0.5)는 가장 가까운 짝수로 반올림됩니다. 참고 &lt;code&gt;round&lt;/code&gt; 글로벌 반올림 모드가 변경되는 경우 (참조 잘못된 결과를 제공 할 수 있습니다 &lt;a href=&quot;../numbers/index#Base.Rounding.rounding&quot;&gt; &lt;code&gt;rounding&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="36e18d121f5a838cc6709524d85e5f444560cd8e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Dates.dayname&quot;&gt;&lt;code&gt;dayname&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.monthname&quot;&gt;&lt;code&gt;monthname&lt;/code&gt;&lt;/a&gt; methods can also take an optional &lt;code&gt;locale&lt;/code&gt; keyword that can be used to return the name of the day or month of the year for other languages/locales. There are also versions of these functions returning the abbreviated names, namely &lt;a href=&quot;#Dates.dayabbr&quot;&gt;&lt;code&gt;dayabbr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.monthabbr&quot;&gt;&lt;code&gt;monthabbr&lt;/code&gt;&lt;/a&gt;. First the mapping is loaded into the &lt;code&gt;LOCALES&lt;/code&gt; variable:</source>
          <target state="translated">&lt;a href=&quot;#Dates.dayname&quot;&gt; &lt;code&gt;dayname&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#Dates.monthname&quot;&gt; &lt;code&gt;monthname&lt;/code&gt; &lt;/a&gt; 방법도 취할 수있는 선택 &lt;code&gt;locale&lt;/code&gt; 키워드 다른 언어 / 로케일 년의 일 또는 월의 이름을 반환하는 데 사용할 수있는. 약식 이름, 즉 &lt;a href=&quot;#Dates.dayabbr&quot;&gt; &lt;code&gt;dayabbr&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#Dates.monthabbr&quot;&gt; &lt;code&gt;monthabbr&lt;/code&gt; 을&lt;/a&gt; 반환하는 이러한 함수 버전도 있습니다 . 먼저 맵핑이 &lt;code&gt;LOCALES&lt;/code&gt; 변수에 로드됩니다 .</target>
        </trans-unit>
        <trans-unit id="b0ea31c9b36eaba5425ec694eab3ed041d8c9eef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Logging.Logging&quot;&gt;&lt;code&gt;Logging&lt;/code&gt;&lt;/a&gt; module provides a way to record the history and progress of a computation as a log of events. Events are created by inserting a logging statement into the source code, for example:</source>
          <target state="translated">&lt;a href=&quot;#Logging.Logging&quot;&gt; &lt;code&gt;Logging&lt;/code&gt; &lt;/a&gt; 모듈은 역사를 기록 및 이벤트 로그로 계산의 진행 할 수있는 방법을 제공합니다. 이벤트는 로깅 명령문을 소스 코드에 삽입하여 작성됩니다 (예 :</target>
        </trans-unit>
        <trans-unit id="3b0d2cdace4e12d15a4692bf023ef78f32612455" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Rounding-functions-1&quot;&gt;Rounding functions&lt;/a&gt; take a type &lt;code&gt;T&lt;/code&gt; as an optional argument. For example, &lt;code&gt;round(Int,x)&lt;/code&gt; is a shorthand for &lt;code&gt;Int(round(x))&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Rounding-functions-1&quot;&gt;반올림 기능&lt;/a&gt; 유형 걸릴 &lt;code&gt;T&lt;/code&gt; 를 선택적 인수로. 예를 들어 &lt;code&gt;round(Int,x)&lt;/code&gt; 는 &lt;code&gt;Int(round(x))&lt;/code&gt; 의 약어입니다 .</target>
        </trans-unit>
        <trans-unit id="5eb87235a3e582308fdae141ff9f8e2932202086" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#SparseArrays.sparse&quot;&gt;&lt;code&gt;sparse&lt;/code&gt;&lt;/a&gt; function is often a handy way to construct sparse arrays. For example, to construct a sparse matrix we can input a vector &lt;code&gt;I&lt;/code&gt; of row indices, a vector &lt;code&gt;J&lt;/code&gt; of column indices, and a vector &lt;code&gt;V&lt;/code&gt; of stored values (this is also known as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29&quot;&gt;COO (coordinate) format&lt;/a&gt;). &lt;code&gt;sparse(I,J,V)&lt;/code&gt; then constructs a sparse matrix such that &lt;code&gt;S[I[k], J[k]] = V[k]&lt;/code&gt;. The equivalent sparse vector constructor is &lt;a href=&quot;#SparseArrays.sparsevec&quot;&gt;&lt;code&gt;sparsevec&lt;/code&gt;&lt;/a&gt;, which takes the (row) index vector &lt;code&gt;I&lt;/code&gt; and the vector &lt;code&gt;V&lt;/code&gt; with the stored values and constructs a sparse vector &lt;code&gt;R&lt;/code&gt; such that &lt;code&gt;R[I[k]] = V[k]&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#SparseArrays.sparse&quot;&gt; &lt;code&gt;sparse&lt;/code&gt; &lt;/a&gt; 기능은 종종 스파 스 배열을 만들 수있는 편리한 방법입니다. 예를 들어, 희소 행렬을 구성하기 위해 행 인덱스 의 벡터 &lt;code&gt;I&lt;/code&gt; , 열 인덱스의 벡터 &lt;code&gt;J&lt;/code&gt; 및 저장된 값 의 벡터 &lt;code&gt;V&lt;/code&gt; 를 입력 할 수 있습니다 (이는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29&quot;&gt;COO (좌표) 형식&lt;/a&gt; 이라고도 함 ). &lt;code&gt;sparse(I,J,V)&lt;/code&gt; 는 &lt;code&gt;S[I[k], J[k]] = V[k]&lt;/code&gt; 되도록 희소 행렬을 구성합니다 . 동등한 희소 벡터 생성자는 &lt;a href=&quot;#SparseArrays.sparsevec&quot;&gt; &lt;code&gt;sparsevec&lt;/code&gt; &lt;/a&gt; 이며, (행) 인덱스 벡터 &lt;code&gt;I&lt;/code&gt; 및 벡터 &lt;code&gt;V&lt;/code&gt; 를 저장된 값으로 가져와 &lt;code&gt;R[I[k]] = V[k]&lt;/code&gt; 되도록 희소 벡터 &lt;code&gt;R&lt;/code&gt; 을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="1ce4dd4aa2504c940aa48ceeab07c53ca96b6449" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Base.@eval&quot;&gt;&lt;code&gt;@eval&lt;/code&gt;&lt;/a&gt; macro rewrites this call to be precisely equivalent to the above longer versions. For longer blocks of generated code, the expression argument given to &lt;a href=&quot;../../base/base/index#Base.@eval&quot;&gt;&lt;code&gt;@eval&lt;/code&gt;&lt;/a&gt; can be a block:</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.@eval&quot;&gt; &lt;code&gt;@eval&lt;/code&gt; &lt;/a&gt; 매크로는 위 이상 버전에 정확하게 동등이 전화를 다시 작성합니다. 더 긴 생성 된 코드 블록의 경우 &lt;a href=&quot;../../base/base/index#Base.@eval&quot;&gt; &lt;code&gt;@eval&lt;/code&gt; 에&lt;/a&gt; 제공된 expression 인수 는 블록 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38ef0a3b168bd74d25880aec3b78cf19271d94b1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Base.Enums.@enum&quot;&gt;&lt;code&gt;@enum&lt;/code&gt;&lt;/a&gt; macro makes use of &lt;code&gt;@__doc__&lt;/code&gt; to allow for documenting &lt;a href=&quot;../../base/base/index#Base.Enums.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt;s. Examining its definition should serve as an example of how to use &lt;code&gt;@__doc__&lt;/code&gt; correctly.</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.Enums.@enum&quot;&gt; &lt;code&gt;@enum&lt;/code&gt; &lt;/a&gt; 매크로 차종은의 사용 &lt;code&gt;@__doc__&lt;/code&gt; 문서화 할 수 있도록 &lt;a href=&quot;../../base/base/index#Base.Enums.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 들. 정의를 검사하면 &lt;code&gt;@__doc__&lt;/code&gt; 올바르게 사용하는 방법의 예가 됩니다.</target>
        </trans-unit>
        <trans-unit id="acfadefe2bb6121d5e848cbd0b9afe7e8768d52d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Base.error&quot;&gt;&lt;code&gt;error&lt;/code&gt;&lt;/a&gt; function is used to produce an &lt;a href=&quot;../../base/base/index#Core.ErrorException&quot;&gt;&lt;code&gt;ErrorException&lt;/code&gt;&lt;/a&gt; that interrupts the normal flow of control.</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.error&quot;&gt; &lt;code&gt;error&lt;/code&gt; &lt;/a&gt; 함수는 생산하는 데 사용되는 &lt;a href=&quot;../../base/base/index#Core.ErrorException&quot;&gt; &lt;code&gt;ErrorException&lt;/code&gt; &lt;/a&gt; 제어의 정상적인 흐름을 중단.</target>
        </trans-unit>
        <trans-unit id="fd385b6cfaa8837c37589622c3c706028ad36f1c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Base.isless&quot;&gt;&lt;code&gt;isless&lt;/code&gt;&lt;/a&gt; operator is another exception: &lt;code&gt;missing&lt;/code&gt; is considered as greater than any other value. This operator is used by &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;, which therefore places &lt;code&gt;missing&lt;/code&gt; values after all other values.</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.isless&quot;&gt; &lt;code&gt;isless&lt;/code&gt; 의&lt;/a&gt; 운영자는 다른 예외 : &lt;code&gt;missing&lt;/code&gt; 다른 값보다 큰 것으로 간주된다. 이 연산자는 &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt; 에서 사용되므로 다른 모든 값 뒤에 &lt;code&gt;missing&lt;/code&gt; 값이 배치 됩니다.</target>
        </trans-unit>
        <trans-unit id="4d17e67e8157d57768d314d2878bcbffb2b8fe95" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt;&lt;code&gt;typemin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt;&lt;code&gt;typemax&lt;/code&gt;&lt;/a&gt; functions also apply to floating-point types:</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt; &lt;code&gt;typemin&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt; &lt;code&gt;typemax&lt;/code&gt; &lt;/a&gt; 함수는 부동 소수점 유형에 적용 :</target>
        </trans-unit>
        <trans-unit id="de73ba08a71f852e7d2733fa6dfed62a7f72340d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Core.:===&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt; function confirms that the &quot;two&quot; constructed instances of &lt;code&gt;NoFields&lt;/code&gt; are actually one and the same. Singleton types are described in further detail &lt;a href=&quot;#man-singleton-types-1&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Core.:===&quot;&gt; &lt;code&gt;===&lt;/code&gt; 의&lt;/a&gt; 기능을 확인한다의 &quot;2&quot;구성 인스턴스 것을 &lt;code&gt;NoFields&lt;/code&gt; 는 실제로 하나와 동일하다. 싱글 톤 유형은 &lt;a href=&quot;#man-singleton-types-1&quot;&gt;아래&lt;/a&gt; 에 더 자세히 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d77ec66ab2077f795aecb0927e53656b9c9cc945" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt; constructor takes any number of arguments and creates a new symbol by concatenating their string representations together:</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt; 생성자는 인수의 수를 받아 함께 자신의 문자열 표현을 연결하여 새 심볼을 생성합니다 :</target>
        </trans-unit>
        <trans-unit id="414514dfacecedf70ecbd06d5fef52f6a37552e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Core.isa&quot;&gt;&lt;code&gt;isa&lt;/code&gt;&lt;/a&gt; function tests if an object is of a given type and returns true or false:</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Core.isa&quot;&gt; &lt;code&gt;isa&lt;/code&gt; &lt;/a&gt; 객체가 지정된 형태이며 true 또는 false를 반환하는 경우 기능 검사 :</target>
        </trans-unit>
        <trans-unit id="bf1b3d1c04844d76b7ef3cb166b81958a1f65c08" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Core.throw&quot;&gt;&lt;code&gt;throw&lt;/code&gt;&lt;/a&gt; function</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Core.throw&quot;&gt; &lt;code&gt;throw&lt;/code&gt; &lt;/a&gt; 기능</target>
        </trans-unit>
        <trans-unit id="b96dfc29471c7f4e7faf38271fb34f184e922afa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Core.typeof&quot;&gt;&lt;code&gt;typeof&lt;/code&gt;&lt;/a&gt; function, already used throughout the manual in examples, returns the type of its argument. Since, as noted above, types are objects, they also have types, and we can ask what their types are:</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Core.typeof&quot;&gt; &lt;code&gt;typeof&lt;/code&gt; &lt;/a&gt; 이미 예에 설명서 전체에서 사용 기능은, 인수의 형태를 돌려줍니다. 위에서 언급했듯이 유형은 객체이며 유형도 있으며 유형이 무엇인지 물어볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d827a86b6df88cc411d1f3d30cdcddabf2bc33a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; keyword supports the same syntax as &lt;a href=&quot;../../base/base/index#using&quot;&gt;&lt;code&gt;using&lt;/code&gt;&lt;/a&gt;, but only operates on a single name at a time. It does not add modules to be searched the way &lt;code&gt;using&lt;/code&gt; does. &lt;code&gt;import&lt;/code&gt; also differs from &lt;code&gt;using&lt;/code&gt; in that functions imported using &lt;code&gt;import&lt;/code&gt; can be extended with new methods.</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; 키워드와 동일한 구문 지원 &lt;a href=&quot;../../base/base/index#using&quot;&gt; &lt;code&gt;using&lt;/code&gt; &lt;/a&gt; 하지만, 한 번에 하나의 이름에서 작동합니다. &lt;code&gt;using&lt;/code&gt; 하는 방식으로 검색 할 모듈을 추가하지 않습니다 . &lt;code&gt;import&lt;/code&gt; 에서도 다르다을 &lt;code&gt;using&lt;/code&gt; 하여 가져온 그 기능에 &lt;code&gt;import&lt;/code&gt; 새로운 방법으로 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec874bb7238b430b76f31f6a2f70602d5cd36c3f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/c/index#Base.Cstring&quot;&gt;&lt;code&gt;Cstring&lt;/code&gt;&lt;/a&gt; type is essentially a synonym for &lt;code&gt;Ptr{UInt8}&lt;/code&gt;, except the conversion to &lt;code&gt;Cstring&lt;/code&gt; throws an error if the Julia string contains any embedded NUL characters (which would cause the string to be silently truncated if the C routine treats NUL as the terminator). If you are passing a &lt;code&gt;char*&lt;/code&gt; to a C routine that does not assume NUL termination (e.g. because you pass an explicit string length), or if you know for certain that your Julia string does not contain NUL and want to skip the check, you can use &lt;code&gt;Ptr{UInt8}&lt;/code&gt; as the argument type. &lt;code&gt;Cstring&lt;/code&gt; can also be used as the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; return type, but in that case it obviously does not introduce any extra checks and is only meant to improve readability of the call.</source>
          <target state="translated">&lt;a href=&quot;../../base/c/index#Base.Cstring&quot;&gt; &lt;code&gt;Cstring&lt;/code&gt; &lt;/a&gt; 타입은 본질적으로 동의어입니다 &lt;code&gt;Ptr{UInt8}&lt;/code&gt; 에 변환을 제외하고, &lt;code&gt;Cstring&lt;/code&gt; 줄리아 문자열 임베디드 NUL 문자가 포함 된 경우 오류가 발생합니다 (문자열을 야기하는 경우 자동으로 절단 할을 터미네이터로 C 루틴 취급 NUL) . NUL 종료를 가정하지 않는 C 루틴에 &lt;code&gt;char*&lt;/code&gt; 를 전달하는 경우 (예 : 명시적인 문자열 길이를 전달하기 때문에) Julia 문자열에 NUL이 포함되어 있지 않고 확인을 건너 뛰고 싶은 경우 인수 유형으로 &lt;code&gt;Ptr{UInt8}&lt;/code&gt; 을 사용할 수 있습니다 . &lt;code&gt;Cstring&lt;/code&gt; 또한로 사용할 수 있습니다 &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 반환 유형이지만이 경우 분명히 추가 검사를 수행하지 않으며 호출의 가독성을 향상시키기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="3fe5df294c64ae2bc17b6c645704bd7bc62ca16b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt;&lt;code&gt;Base.filter&lt;/code&gt;&lt;/a&gt; method can be used to obtain all valid dates/moments in a specified range:</source>
          <target state="translated">&lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt; &lt;code&gt;Base.filter&lt;/code&gt; 의&lt;/a&gt; 방법은 지정된 범위에있는 모든 유효한 날짜 / 순간을 얻을 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="32116ae8c0495cf49f4c9c66e837a3e4255f5c44" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/io-network/index#Base.dump&quot;&gt;&lt;code&gt;dump&lt;/code&gt;&lt;/a&gt; function provides indented and annotated display of &lt;code&gt;Expr&lt;/code&gt; objects:</source>
          <target state="translated">&lt;a href=&quot;../../base/io-network/index#Base.dump&quot;&gt; &lt;code&gt;dump&lt;/code&gt; &lt;/a&gt; 기능은 들여 쓰기 및 표시 주석을 제공 &lt;code&gt;Expr&lt;/code&gt; 객체를 :</target>
        </trans-unit>
        <trans-unit id="63e3ea8e88f5b981ca22a0c9f75818db8e88281d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/multi-threading/index#Base.@threadcall&quot;&gt;&lt;code&gt;@threadcall&lt;/code&gt;&lt;/a&gt; macro addresses scenarios where we do not want a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; to block the main Julia event loop. It schedules a C function for execution in a separate thread. A threadpool with a default size of 4 is used for this. The size of the threadpool is controlled via environment variable &lt;code&gt;UV_THREADPOOL_SIZE&lt;/code&gt;. While waiting for a free thread, and during function execution once a thread is available, the requesting task (on the main Julia event loop) yields to other tasks. Note that &lt;code&gt;@threadcall&lt;/code&gt; does not return till the execution is complete. From a user point of view, it is therefore a blocking call like other Julia APIs.</source>
          <target state="translated">&lt;a href=&quot;../../base/multi-threading/index#Base.@threadcall&quot;&gt; &lt;code&gt;@threadcall&lt;/code&gt; &lt;/a&gt; 우리가 원하지 않는 매크로 주소 시나리오 &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; 는&lt;/a&gt; 주요 줄리아 이벤트 루프를 차단. 별도의 스레드에서 실행되도록 C 함수를 예약합니다. 이를 위해 기본 크기가 4 인 스레드 풀이 사용됩니다. 스레드 풀의 크기는 환경 변수 &lt;code&gt;UV_THREADPOOL_SIZE&lt;/code&gt; 를 통해 제어됩니다 . 사용 가능한 스레드를 기다리는 동안 및 함수 실행 중에 스레드를 사용할 수있게되면 요청하는 태스크 (기본 Julia 이벤트 루프에서)는 다른 태스크를 생성합니다. 참고 &lt;code&gt;@threadcall&lt;/code&gt; 가 실행까지 반환하지 않습니다이 완료됩니다. 따라서 사용자 관점에서는 다른 Julia API와 마찬가지로 차단 호출입니다.</target>
        </trans-unit>
        <trans-unit id="9980cd05996241c9e77ece29af3cb2e812c97a73" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt; type is a direct child type of &lt;code&gt;Any&lt;/code&gt;, and &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; is its child. In turn, &lt;code&gt;Real&lt;/code&gt; has two children (it has more, but only two are shown here; we'll get to the others later): &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Core.AbstractFloat&quot;&gt;&lt;code&gt;AbstractFloat&lt;/code&gt;&lt;/a&gt;, separating the world into representations of integers and representations of real numbers. Representations of real numbers include, of course, floating-point types, but also include other types, such as rationals. Hence, &lt;code&gt;AbstractFloat&lt;/code&gt; is a proper subtype of &lt;code&gt;Real&lt;/code&gt;, including only floating-point representations of real numbers. Integers are further subdivided into &lt;a href=&quot;../../base/numbers/index#Core.Signed&quot;&gt;&lt;code&gt;Signed&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Core.Unsigned&quot;&gt;&lt;code&gt;Unsigned&lt;/code&gt;&lt;/a&gt; varieties.</source>
          <target state="translated">&lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; 유형의 직접적인 자식 유형의 &lt;code&gt;Any&lt;/code&gt; , 그리고 &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; 자식입니다. 차례로, &lt;code&gt;Real&lt;/code&gt; 두 아이가 (더 가지고 있지만 두가 여기에 표시됩니다 우리는 나중에 다른 사람에게 얻을 것이다) : &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;../../base/numbers/index#Core.AbstractFloat&quot;&gt; &lt;code&gt;AbstractFloat&lt;/code&gt; 을&lt;/a&gt; , 정수와 실수의 표현의 표현으로 세계를 분리. 실수의 표현은 물론 부동 소수점 유형을 포함하지만 합리적과 같은 다른 유형도 포함합니다. 따라서 &lt;code&gt;AbstractFloat&lt;/code&gt; 는 실수의 부동 소수점 표현 만 포함하여 &lt;code&gt;Real&lt;/code&gt; 의 적절한 하위 유형입니다 . 정수는 &lt;a href=&quot;../../base/numbers/index#Core.Signed&quot;&gt; &lt;code&gt;Signed&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;../../base/numbers/index#Core.Unsigned&quot;&gt; &lt;code&gt;Unsigned&lt;/code&gt; &lt;/a&gt; 으로 세분화됩니다. 품종.</target>
        </trans-unit>
        <trans-unit id="a61c350b843f41f66bd6a94fb06646bf09f7c269" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt;&lt;code&gt;launch&lt;/code&gt;&lt;/a&gt; method is called asynchronously in a separate task. The termination of this task signals that all requested workers have been launched. Hence the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt;&lt;code&gt;launch&lt;/code&gt;&lt;/a&gt; function MUST exit as soon as all the requested workers have been launched.</source>
          <target state="translated">&lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt; &lt;code&gt;launch&lt;/code&gt; &lt;/a&gt; 방법은 별도의 작업에서 비동기 적으로 호출된다. 이 작업이 종료되면 요청 된 모든 작업자가 시작되었음을 알립니다. 따라서 모든 요청 된 작업자가 시작 되 자마자 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt; &lt;code&gt;launch&lt;/code&gt; &lt;/a&gt; 기능을 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="e5928b30867a053dbff6206d1bc20c56f14e738b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt;&lt;code&gt;launch&lt;/code&gt;&lt;/a&gt; method takes the following arguments:</source>
          <target state="translated">&lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt; &lt;code&gt;launch&lt;/code&gt; &lt;/a&gt; 방법은 다음 인수를 사용합니다 :</target>
        </trans-unit>
        <trans-unit id="7b33ac485b0a3f8ebfda5064c9e3efc2a8bcfdcf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../integers-and-floating-point-numbers/index#man-numeric-literal-coefficients-1&quot;&gt;literal numeric coefficient notation&lt;/a&gt; does not work when constructing a complex number from variables. Instead, the multiplication must be explicitly written out:</source>
          <target state="translated">&lt;a href=&quot;../integers-and-floating-point-numbers/index#man-numeric-literal-coefficients-1&quot;&gt;문자 숫자 계수 표기는&lt;/a&gt; 변수에서 복소수를 구성 할 때 작동하지 않습니다. 대신 곱셈을 명시 적으로 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="275af0000e44bc521cd56c3026533fc5cd78a5de" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../strings/index#man-concatenation-1&quot;&gt;main argument&lt;/a&gt; against &lt;code&gt;+&lt;/code&gt; is that string concatenation is not commutative, while &lt;code&gt;+&lt;/code&gt; is generally used as a commutative operator. While the Julia community recognizes that other languages use different operators and &lt;code&gt;*&lt;/code&gt; may be unfamiliar for some users, it communicates certain algebraic properties.</source>
          <target state="translated">&lt;a href=&quot;../strings/index#man-concatenation-1&quot;&gt;주요 인자&lt;/a&gt; 에 대해 &lt;code&gt;+&lt;/code&gt; 는 동시에 해당 문자열 연결은 교환 법칙이 성립하지 않다 &lt;code&gt;+&lt;/code&gt; 는 일반적 가환 연산자로서 사용된다. 줄리아 커뮤니티 다른 언어가 다른 연산자를 사용하고 있음을 인식하면서 &lt;code&gt;*&lt;/code&gt; 일부 사용자에 대해 익숙하지 않을 수 있습니다, 그것은 특정 대수 속성을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="c14035985c996abe00f4042cc746b4176aab2201" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/JuliaData/DataFrames.jl&quot;&gt;DataFrames package&lt;/a&gt; provides data frames.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/JuliaData/DataFrames.jl&quot;&gt;DataFrames 패키지는&lt;/a&gt; 데이터 프레임을 제공한다.</target>
        </trans-unit>
        <trans-unit id="e3ebf2c6b9c4eb22391edbc55310df1678b26195" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/MikeInnes/Traceur.jl&quot;&gt;Traceur&lt;/a&gt; package can help you find common performance problems in your code.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/MikeInnes/Traceur.jl&quot;&gt;Traceur의&lt;/a&gt; 패키지는 당신이 당신의 코드에서 일반적인 성능 문제를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09270743df4b19bd666f57937fe0296a7b3d369a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.gnu.org/software/gsl/&quot;&gt;GNU Scientific Library&lt;/a&gt; (here assumed to be accessible through &lt;code&gt;:libgsl&lt;/code&gt;) defines an opaque pointer, &lt;code&gt;gsl_permutation *&lt;/code&gt;, as the return type of the C function &lt;code&gt;gsl_permutation_alloc&lt;/code&gt;. As user code never has to look inside the &lt;code&gt;gsl_permutation&lt;/code&gt; struct, the corresponding Julia wrapper simply needs a new type declaration, &lt;code&gt;gsl_permutation&lt;/code&gt;, that has no internal fields and whose sole purpose is to be placed in the type parameter of a &lt;code&gt;Ptr&lt;/code&gt; type. The return type of the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; is declared as &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt;, since the memory allocated and pointed to by &lt;code&gt;output_ptr&lt;/code&gt; is controlled by C (and not Julia).</source>
          <target state="translated">&lt;a href=&quot;https://www.gnu.org/software/gsl/&quot;&gt;GNU 과학 도서관&lt;/a&gt; (여기를 통해 액세스 할 수 가정 &lt;code&gt;:libgsl&lt;/code&gt; ) 불투명 한 포인터 정의 &lt;code&gt;gsl_permutation *&lt;/code&gt; C 함수의 반환 형식으로, &lt;code&gt;gsl_permutation_alloc&lt;/code&gt; . 사용자 코드가 &lt;code&gt;gsl_permutation&lt;/code&gt; 구조체 를 들여다 볼 필요 가 없으므로 해당 Julia 래퍼에는 &lt;code&gt;gsl_permutation&lt;/code&gt; 이라는 새로운 유형 선언이 필요합니다. gsl_permutation 은 내부 필드가없고 &lt;code&gt;Ptr&lt;/code&gt; 유형 의 type 매개 변수에 유일한 목적이 있습니다 . 메모리가 &lt;code&gt;output_ptr&lt;/code&gt; 에 의해 할당되고 지정 &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 의 리턴 유형은 &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt; 으로 선언됩니다. C (줄리아가 아닌)에 의해 제어됩니다.</target>
        </trans-unit>
        <trans-unit id="72ea3eda7ce888d73eff517a4ef953491525adf7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; syntax is deprecated, use the &lt;code&gt;Ref{T}&lt;/code&gt; argument type instead.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt; 구문이 사용되지 않으며 사용 &lt;code&gt;Ref{T}&lt;/code&gt; 대신 인수 유형을.</target>
        </trans-unit>
        <trans-unit id="ff8eac00092307ddc7d1e59e50812b91cc8012ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;:&lt;/code&gt; operator in general means &quot;is a subtype of&quot;, and, used in declarations like this, declares the right-hand type to be an immediate supertype of the newly declared type. It can also be used in expressions as a subtype operator which returns &lt;code&gt;true&lt;/code&gt; when its left operand is a subtype of its right operand:</source>
          <target state="translated">&lt;code&gt;&amp;lt;:&lt;/code&gt; 일반 수단의 운영자는 &quot;의 하위 유형입니다&quot;하고, 다음과 같이 선언에 사용, 새로 선언 된 유형의 즉각적인 슈퍼로 오른쪽 유형을 선언합니다. 왼쪽 피연산자가 오른쪽 피연산자의 하위 유형 인 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴하는 하위 유형 연산자로 표현식에서 사용될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="462f03c3cade5b2449ca60ca2d04cc3130736218" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--&lt;/code&gt; delimiter can be used to separate command-line arguments intended for the script file from arguments intended for Julia:</source>
          <target state="translated">&lt;code&gt;--&lt;/code&gt; 구분은 줄리아위한 인수에서 스크립트 파일을위한 별도의 명령 줄 인수로 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="396147a6b9dfacff46d28874aadee188884bc052" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;2x + y&lt;/code&gt; definition is only used in the first case, while the &lt;code&gt;2x - y&lt;/code&gt; definition is used in the others. No automatic casting or conversion of function arguments is ever performed: all conversion in Julia is non-magical and completely explicit. &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversion and Promotion&lt;/a&gt;, however, shows how clever application of sufficiently advanced technology can be indistinguishable from magic. &lt;a href=&quot;#footnote-Clarke61&quot;&gt;[Clarke61]&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;2x + y&lt;/code&gt; 그동안 정의 첫번째 경우 만 사용 &lt;code&gt;2x - y&lt;/code&gt; 정의가 다른 사용된다. 함수 인수의 자동 캐스트 또는 변환은 수행되지 않습니다. Julia의 모든 변환은 마술이 아니며 완전히 명시 적입니다. 그러나 &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversion and Promotion&lt;/a&gt; 은 충분히 진보 된 기술을 영리하게 적용하는 것이 마술과 구별 할 수없는 방법을 보여줍니다. &lt;a href=&quot;#footnote-Clarke61&quot;&gt;[클라크 61]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="702c47148e007cd263dc6deb6727c14f26afb82e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;::&lt;/code&gt; operator can be used to attach type annotations to expressions and variables in programs. There are two primary reasons to do this:</source>
          <target state="translated">&lt;code&gt;::&lt;/code&gt; 연산자는 프로그램에서 표현과 변수 타입의 주석을 첨부 할 수 있습니다. 이렇게하는 두 가지 주요 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4ee1c478f2612aec54bd174690fa6ea35ddb91f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:&lt;/code&gt; character has two syntactic purposes in Julia. The first form creates a &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt;, an &lt;a href=&quot;https://en.wikipedia.org/wiki/String_interning&quot;&gt;interned string&lt;/a&gt; used as one building-block of expressions:</source>
          <target state="translated">&lt;code&gt;:&lt;/code&gt; 문자는 줄리아 두 구문 목적이있다. 첫 번째 형태는 생성 &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://en.wikipedia.org/wiki/String_interning&quot;&gt;억류 스트링&lt;/a&gt; 표현식 중 하나의 빌딩 블록으로서 사용을 :</target>
        </trans-unit>
        <trans-unit id="48c311a5c224de0110d74a449183e9149c5a0fa1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@assert&lt;/code&gt; macro makes great use of splicing into quoted expressions to simplify the manipulation of expressions inside the macro body.</source>
          <target state="translated">&lt;code&gt;@assert&lt;/code&gt; 매크로는 매크로 몸 안의 표현식의 조작을 단순화하기 위해 인용 표현에 접합의 큰 사용합니다.</target>
        </trans-unit>
        <trans-unit id="801ed9019f04c0f8f529dacee5be7631d5e276fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@boundscheck&lt;/code&gt; annotation allows you, as a library writer, to opt-in to allowing &lt;em&gt;other code&lt;/em&gt; to remove your bounds checks with &lt;a href=&quot;#Base.@inbounds&quot;&gt;&lt;code&gt;@inbounds&lt;/code&gt;&lt;/a&gt;. As noted there, the caller must verify&amp;mdash;using information they can access&amp;mdash;that their accesses are valid before using &lt;code&gt;@inbounds&lt;/code&gt;. For indexing into your &lt;a href=&quot;../arrays/index#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray&lt;/code&gt;&lt;/a&gt; subclasses, for example, this involves checking the indices against its &lt;a href=&quot;../arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;. Therefore, &lt;code&gt;@boundscheck&lt;/code&gt; annotations should only be added to a &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt; implementation after you are certain its behavior is correct.</source>
          <target state="translated">&lt;code&gt;@boundscheck&lt;/code&gt; 의 주석에, 도서관 작가로, 당신을 수 있습니다 선택 하에서 허용하는 &lt;em&gt;다른 코드를&lt;/em&gt; 사용하여 경계 검사를 제거 &lt;a href=&quot;#Base.@inbounds&quot;&gt; &lt;code&gt;@inbounds&lt;/code&gt; &lt;/a&gt; . 언급 한대로 호출자는 &lt;code&gt;@inbounds&lt;/code&gt; 를 사용하기 전에 액세스 가능한 정보를 사용하여 액세스가 유효한지 확인해야합니다 . 예 를 들어, &lt;a href=&quot;../arrays/index#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray&lt;/code&gt; &lt;/a&gt; 서브 클래스에 색인을 생성 하려면 &lt;a href=&quot;../arrays/index#Base.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt; 와 인덱스를 확인해야 합니다 . 따라서 &lt;code&gt;@boundscheck&lt;/code&gt; 주석은 &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt; 에만 추가해야합니다 ! 확실하게 구현 한 후에는 동작이 올바른 것입니다.</target>
        </trans-unit>
        <trans-unit id="8d04719fe4369bb879f4c27763dea9901ff5736f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@doc&lt;/code&gt; macro associates its first argument with its second in a per-module dictionary called &lt;code&gt;META&lt;/code&gt;. By default, documentation is expected to be written in Markdown, and the &lt;code&gt;doc&quot;&quot;&lt;/code&gt; string macro simply creates an object representing the Markdown content. In the future it is likely to do more advanced things such as allowing for relative image or link paths.</source>
          <target state="translated">&lt;code&gt;@doc&lt;/code&gt; 의 매크로라는 단위 모듈 사전 번째로 첫 번째 인자 연관 &lt;code&gt;META&lt;/code&gt; . 기본적으로 문서는 Markdown으로 작성되며 &lt;code&gt;doc&quot;&quot;&lt;/code&gt; 문자열 매크로는 단순히 Markdown 내용을 나타내는 객체를 만듭니다. 앞으로는 상대 이미지 또는 링크 경로 허용과 같은 고급 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3901521653150d23278fa27f787a9dbcf11d8111" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@simd&lt;/code&gt; does not assert by default that the loop is completely free of loop-carried memory dependencies, which is an assumption that can easily be violated in generic code. If you are writing non-generic code, you can use &lt;code&gt;@simd ivdep for ... end&lt;/code&gt; to also assert that:</source>
          <target state="translated">&lt;code&gt;@simd&lt;/code&gt; 는 루프가 쉽게 일반적인 코드에 위반 될 수있는 가정이다, 루프 수행 메모리 종속성의 완전 무료입니다 기본적으로 주장하지 않습니다. 제네릭이 아닌 코드를 작성하는 경우 &lt;code&gt;@simd ivdep for ... end&lt;/code&gt; 를 사용하여 다음을 확인할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="22755b36a58e8494f0fc686a468ea1d881c82d08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@test f(args...) key=val...&lt;/code&gt; form is equivalent to writing &lt;code&gt;@test f(args..., key=val...)&lt;/code&gt; which can be useful when the expression is a call using infix syntax such as approximate comparisons:</source>
          <target state="translated">&lt;code&gt;@test f(args...) key=val...&lt;/code&gt; 폼 작성 동등 &lt;code&gt;@test f(args..., key=val...)&lt;/code&gt; 식이 구 중위 사용하여 호출 될 때 유용 할 수있는 대략적인 비교와 같은 :</target>
        </trans-unit>
        <trans-unit id="16c63b805f73cc977b60037a10997e30bb4b9947" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@test_broken f(args...) key=val...&lt;/code&gt; form works as for the &lt;code&gt;@test&lt;/code&gt; macro.</source>
          <target state="translated">&lt;code&gt;@test_broken f(args...) key=val...&lt;/code&gt; 형태는 용으로 작동 &lt;code&gt;@test&lt;/code&gt; 매크로.</target>
        </trans-unit>
        <trans-unit id="abdc5ad65294f55eba9140a8f0b4f4933db8d022" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@test_skip f(args...) key=val...&lt;/code&gt; form works as for the &lt;code&gt;@test&lt;/code&gt; macro.</source>
          <target state="translated">&lt;code&gt;@test_skip f(args...) key=val...&lt;/code&gt; 형태는 용으로 작동 &lt;code&gt;@test&lt;/code&gt; 매크로.</target>
        </trans-unit>
        <trans-unit id="8d32bc610a43028740032f0894a8d5b65d4647e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@testset&lt;/code&gt; macro can be used to group tests into &lt;em&gt;sets&lt;/em&gt;. All the tests in a test set will be run, and at the end of the test set a summary will be printed. If any of the tests failed, or could not be evaluated due to an error, the test set will then throw a &lt;code&gt;TestSetException&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@testset&lt;/code&gt; 의 매크로로 그룹화 테스트에 사용될 수있는 &lt;em&gt;세트&lt;/em&gt; . 테스트 세트의 모든 테스트가 실행되고 테스트 세트가 끝나면 요약이 인쇄됩니다. 테스트 중 하나라도 실패했거나 오류로 인해 평가할 수없는 경우 테스트 세트는 &lt;code&gt;TestSetException&lt;/code&gt; 을 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="6e1109eb4b0b82fe1adad014b7f4cf1b1315fb09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@threadcall&lt;/code&gt; macro is called in the same way as &lt;a href=&quot;../c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; but does the work in a different thread. This is useful when you want to call a blocking C function without causing the main &lt;code&gt;julia&lt;/code&gt; thread to become blocked. Concurrency is limited by size of the libuv thread pool, which defaults to 4 threads but can be increased by setting the &lt;code&gt;UV_THREADPOOL_SIZE&lt;/code&gt; environment variable and restarting the &lt;code&gt;julia&lt;/code&gt; process.</source>
          <target state="translated">&lt;code&gt;@threadcall&lt;/code&gt; 의 매크로와 같은 방법으로 호출 &lt;a href=&quot;../c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 하지만 다른 스레드에서 작업을 수행합니다. 주 &lt;code&gt;julia&lt;/code&gt; 스레드가 차단되지 않도록 차단 C 함수를 호출하려는 경우에 유용합니다 . 동시성은 libuv 스레드 풀의 크기에 의해 제한되며 기본값은 4 개의 스레드이지만 &lt;code&gt;UV_THREADPOOL_SIZE&lt;/code&gt; 환경 변수 를 설정 하고 &lt;code&gt;julia&lt;/code&gt; 프로세스를 다시 시작하여 증가시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be390301ffbdbbfe0c2a21aa488c727a5bb08d3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@threads&lt;/code&gt; Macro</source>
          <target state="translated">&lt;code&gt;@threads&lt;/code&gt; 매크로</target>
        </trans-unit>
        <trans-unit id="3926862dd6a57d44f61884e7fbb13c9a98fc27be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@views&lt;/code&gt; macro only affects &lt;code&gt;array[...]&lt;/code&gt; expressions that appear explicitly in the given &lt;code&gt;expression&lt;/code&gt;, not array slicing that occurs in functions called by that code.</source>
          <target state="translated">&lt;code&gt;@views&lt;/code&gt; 의 매크로에만 영향 &lt;code&gt;array[...]&lt;/code&gt; 주어진 명시 적으로 나타나는 식 &lt;code&gt;expression&lt;/code&gt; , 그 코드에 의해 호출되는 함수에 발생하지 어레이 슬라이스.</target>
        </trans-unit>
        <trans-unit id="f1624bacdb2ea72aa9e204c460f79dbfffe8ac6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AbstractArray&lt;/code&gt; type includes anything vaguely array-like, and implementations of it might be quite different from conventional arrays. For example, elements might be computed on request rather than stored. However, any concrete &lt;code&gt;AbstractArray{T,N}&lt;/code&gt; type should generally implement at least &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size(A)&lt;/code&gt;&lt;/a&gt; (returning an &lt;code&gt;Int&lt;/code&gt; tuple), &lt;code&gt;getindex(A,i)&lt;/code&gt; and &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex(A,i1,...,iN)&lt;/code&gt;&lt;/a&gt;; mutable arrays should also implement &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt;. It is recommended that these operations have nearly constant time complexity, or technically &amp;Otilde;(1) complexity, as otherwise some array functions may be unexpectedly slow. Concrete types should also typically provide a &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt;&lt;code&gt;similar(A,T=eltype(A),dims=size(A))&lt;/code&gt;&lt;/a&gt; method, which is used to allocate a similar array for &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; and other out-of-place operations. No matter how an &lt;code&gt;AbstractArray{T,N}&lt;/code&gt; is represented internally, &lt;code&gt;T&lt;/code&gt; is the type of object returned by &lt;em&gt;integer&lt;/em&gt; indexing (&lt;code&gt;A[1, ..., 1]&lt;/code&gt;, when &lt;code&gt;A&lt;/code&gt; is not empty) and &lt;code&gt;N&lt;/code&gt; should be the length of the tuple returned by &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;. For more details on defining custom &lt;code&gt;AbstractArray&lt;/code&gt; implementations, see the &lt;a href=&quot;../interfaces/index#man-interface-array-1&quot;&gt;array interface guide in the interfaces chapter&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;AbstractArray&lt;/code&gt; 유형은 막연하게 배열 같은 것을 포함하고 그것의 구현은 기존의 어레이는 상당히 다를 수 있습니다. 예를 들어 요소는 저장되지 않고 요청시 계산 될 수 있습니다. 그러나 구체적인 &lt;code&gt;AbstractArray{T,N}&lt;/code&gt; 유형은 일반적으로 최소한 &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt; &lt;code&gt;size(A)&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;Int&lt;/code&gt; 튜플을 반환 ), &lt;code&gt;getindex(A,i)&lt;/code&gt; 및 &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex(A,i1,...,iN)&lt;/code&gt; &lt;/a&gt; . 가변 배열도 &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt; 를 구현해야합니다 ! . 이러한 연산은 거의 일정한 시간 복잡도를 갖거나 기술적으로 &amp;Otilde; (1) 복잡성을 갖는 것이 좋습니다. 그렇지 않으면 일부 배열 함수가 예기치 않게 느려질 수 있습니다. 콘크리트 유형은 또한 일반적으로&lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt; &lt;code&gt;similar(A,T=eltype(A),dims=size(A))&lt;/code&gt; &lt;/a&gt; 메소드로,&lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; 및 기타 작업 공간 외부 작업에유사한 배열을 할당하는 데 사용됩니다. &lt;code&gt;AbstractArray{T,N}&lt;/code&gt; 이 내부적으로 표현 된방식에 관계없이 &lt;code&gt;T&lt;/code&gt; 는&lt;em&gt; 정수&lt;/em&gt; 인덱싱 ( &lt;code&gt;A&lt;/code&gt; 가 비어 있지 않은경우 A &lt;code&gt;A[1, ..., 1]&lt;/code&gt; 의해 반환되는 객체의 유형이며 &lt;code&gt;N&lt;/code&gt; 은 튜플은&lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt; 로 반환됩니다. 사용자 정의 &lt;code&gt;AbstractArray&lt;/code&gt; 구현정의에 대한 자세한 내용&lt;a href=&quot;../interfaces/index#man-interface-array-1&quot;&gt; 은 인터페이스 장에서 배열 인터페이스 안내서를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a1a42131bfca003806ea94dc4875800e91fc9149" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AbstractChar&lt;/code&gt; type is the supertype of all character implementations in Julia. A character represents a Unicode code point, and can be converted to an integer via the &lt;a href=&quot;#Base.codepoint&quot;&gt;&lt;code&gt;codepoint&lt;/code&gt;&lt;/a&gt; function in order to obtain the numerical value of the code point, or constructed from the same integer. These numerical values determine how characters are compared with &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt;, for example. New &lt;code&gt;T &amp;lt;: AbstractChar&lt;/code&gt; types should define a &lt;code&gt;codepoint(::T)&lt;/code&gt; method and a &lt;code&gt;T(::UInt32)&lt;/code&gt; constructor, at minimum.</source>
          <target state="translated">&lt;code&gt;AbstractChar&lt;/code&gt; 의 유형은 줄리아의 모든 문자 구현의 슈퍼 타입이다. 문자는 유니 코드 코드 포인트를 나타내며 코드 포인트 의 숫자 값을 얻기 위해 &lt;a href=&quot;#Base.codepoint&quot;&gt; &lt;code&gt;codepoint&lt;/code&gt; &lt;/a&gt; 함수를 통해 정수로 변환 되거나 동일한 정수로 구성 될 수 있습니다. 이 숫자 값 은 예를 들어 문자가 &lt;code&gt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;==&lt;/code&gt; 과 비교되는 방식을 결정합니다 . 새로운 &lt;code&gt;T &amp;lt;: AbstractChar&lt;/code&gt; 타입은 최소한 &lt;code&gt;codepoint(::T)&lt;/code&gt; 메소드와 &lt;code&gt;T(::UInt32)&lt;/code&gt; 생성자를 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1c7306a482beca890d3fe61802010a334de7540c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ConfigEntry&lt;/code&gt; would look like the following:</source>
          <target state="translated">&lt;code&gt;ConfigEntry&lt;/code&gt; 은 다음과 같을 것이다 :</target>
        </trans-unit>
        <trans-unit id="ba9c45997f3e5b0258d17d45edce07e2353ce6d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dates&lt;/code&gt; module approach tries to follow the simple principle of trying to change as little as possible when doing &lt;a href=&quot;#Dates.Period&quot;&gt;&lt;code&gt;Period&lt;/code&gt;&lt;/a&gt; arithmetic. This approach is also often known as &lt;em&gt;calendrical&lt;/em&gt; arithmetic or what you would probably guess if someone were to ask you the same calculation in a conversation. Why all the fuss about this? Let's take a classic example: add 1 month to January 31st, 2014. What's the answer? Javascript will say &lt;a href=&quot;https://markhneedham.com/blog/2009/01/07/javascript-add-a-month-to-a-date/&quot;&gt;March 3&lt;/a&gt; (assumes 31 days). PHP says &lt;a href=&quot;https://stackoverflow.com/questions/5760262/php-adding-months-to-a-date-while-not-exceeding-the-last-day-of-the-month&quot;&gt;March 2&lt;/a&gt; (assumes 30 days). The fact is, there is no right answer. In the &lt;code&gt;Dates&lt;/code&gt; module, it gives the result of February 28th. How does it figure that out? I like to think of the classic 7-7-7 gambling game in casinos.</source>
          <target state="translated">&lt;code&gt;Dates&lt;/code&gt; 할 때 가능한만큼 작은 변화를 시도하는 간단한 원리를 따라 접근 시도를 모듈 &lt;a href=&quot;#Dates.Period&quot;&gt; &lt;code&gt;Period&lt;/code&gt; &lt;/a&gt; 계산을. 이 접근 방식은 종종 &lt;em&gt;계산적&lt;/em&gt; 산술 또는 누군가가 대화에서 동일한 계산을 요구할 경우 추측 할 수있는 것으로 알려져 있습니다. 왜 이것에 대한 모든 소란? 전형적인 예를 들어 보자 : 2014 년 1 월 31 일에 1 개월을 더하십시오. 답은 무엇입니까? 자바 스크립트는 &lt;a href=&quot;https://markhneedham.com/blog/2009/01/07/javascript-add-a-month-to-a-date/&quot;&gt;3 월 3 일&lt;/a&gt; 을 말합니다 (31 일 가정). PHP는 &lt;a href=&quot;https://stackoverflow.com/questions/5760262/php-adding-months-to-a-date-while-not-exceeding-the-last-day-of-the-month&quot;&gt;3 월 2&lt;/a&gt; 일을 말합니다 (30 일 가정). 사실은 정답이 없습니다. 에서 &lt;code&gt;Dates&lt;/code&gt; 모듈, 그것은 2 월 28 일의 결과를 제공합니다. 어떻게 알아낼까요? 나는 카지노에서 고전적인 7-7-7 도박 게임을 생각하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="f3b7289c36cdd40212d2c06b1045bb17b9239ebc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dates&lt;/code&gt; module provides the &lt;em&gt;adjuster&lt;/em&gt; API through several convenient methods that aid in simply and succinctly expressing temporal rules. The first group of adjuster methods deal with the first and last of weeks, months, quarters, and years. They each take a single &lt;a href=&quot;#Dates.TimeType&quot;&gt;&lt;code&gt;TimeType&lt;/code&gt;&lt;/a&gt; as input and return or &lt;em&gt;adjust to&lt;/em&gt; the first or last of the desired period relative to the input.</source>
          <target state="translated">&lt;code&gt;Dates&lt;/code&gt; 모듈은 제공 &lt;em&gt;조절기&lt;/em&gt; 간단하고 간결 시간 규칙을 표현하는데 도움이 몇 가지 편리한 방법을 통해 API를. 첫 번째 조정자 그룹 그룹은 첫 번째와 마지막 주, 월, 분기 및 연도를 처리합니다. 이들은 각각 단일 &lt;a href=&quot;#Dates.TimeType&quot;&gt; &lt;code&gt;TimeType&lt;/code&gt; &lt;/a&gt; 을 입력으로 사용하고 입력 에 대해 원하는 기간의 첫 번째 또는 마지막으로 돌아가거나 &lt;em&gt;조정합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="822dabd74f61866145ac5d6c2a28ae2c68643b5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dates&lt;/code&gt; module provides two types for working with dates: &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;, representing day and millisecond precision, respectively; both are subtypes of the abstract &lt;a href=&quot;#Dates.TimeType&quot;&gt;&lt;code&gt;TimeType&lt;/code&gt;&lt;/a&gt;. The motivation for distinct types is simple: some operations are much simpler, both in terms of code and mental reasoning, when the complexities of greater precision don't have to be dealt with. For example, since the &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; type only resolves to the precision of a single date (i.e. no hours, minutes, or seconds), normal considerations for time zones, daylight savings/summer time, and leap seconds are unnecessary and avoided.</source>
          <target state="translated">&lt;code&gt;Dates&lt;/code&gt; 모듈은 날짜 작업을위한 두 가지 유형을 제공합니다 : &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; , 일, 각각 밀리 초 정밀도를 나타내는; 둘 다 추상 &lt;a href=&quot;#Dates.TimeType&quot;&gt; &lt;code&gt;TimeType&lt;/code&gt; 의&lt;/a&gt; 하위 유형입니다 . 고유 한 유형에 대한 동기 부여는 간단합니다. 더 정밀한 복잡성을 처리 할 필요가없는 코드 및 정신 추론 측면에서 일부 작업이 훨씬 단순합니다. 예를 들어, &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 유형은 단일 날짜 (예 :시, 분 또는 초 없음)의 정밀도로만 해석되므로 표준 시간대, 일광 절약 시간 / 서머 타임 및 윤초에 대한 일반적인 고려 사항은 필요하지 않으며 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="47e6ad22d3652de8f0079c299b50b93cf7e90cb5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Docs&lt;/code&gt; module provides the &lt;code&gt;@doc&lt;/code&gt; macro which can be used to set and retrieve documentation metadata for Julia objects.</source>
          <target state="translated">&lt;code&gt;Docs&lt;/code&gt; 모듈이 제공 &lt;code&gt;@doc&lt;/code&gt; 을 설정하는데 사용하고 줄리아 개체에 대한 문서 메타 데이터를 검색 할 수 매크로.</target>
        </trans-unit>
        <trans-unit id="21bb014706065802683533ccfbc183fd2f75ab09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GitHash&lt;/code&gt; of the target object of &lt;code&gt;tag&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;GitHash&lt;/code&gt; 의 대상체의 &lt;code&gt;tag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e3fa0171d91b22777ce2dc8384f8c21045a536e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JL_GC_POP&lt;/code&gt; call releases the references established by the previous &lt;code&gt;JL_GC_PUSH&lt;/code&gt;. Note that &lt;code&gt;JL_GC_PUSH&lt;/code&gt; stores references on the C stack, so it must be exactly paired with a &lt;code&gt;JL_GC_POP&lt;/code&gt; before the scope is exited. That is, before the function returns, or control flow otherwise leaves the block in which the &lt;code&gt;JL_GC_PUSH&lt;/code&gt; was invoked.</source>
          <target state="translated">&lt;code&gt;JL_GC_POP&lt;/code&gt; 의 호출은 이전에 의해 설립 참조 출시 &lt;code&gt;JL_GC_PUSH&lt;/code&gt; 을 . 참고 &lt;code&gt;JL_GC_PUSH&lt;/code&gt; 의 는 C 스택에 저장 참조, 그래서는 정확하게와 결합해야 &lt;code&gt;JL_GC_POP&lt;/code&gt; 범위가 종료되기 전에. 즉, 함수가 리턴되기 전에 제어 플로우가 그렇지 않으면 &lt;code&gt;JL_GC_PUSH&lt;/code&gt; 가 호출 된 블록을 떠나게 됩니다.</target>
        </trans-unit>
        <trans-unit id="3b348f9eede2ca6e62ca6337bddb047633174b17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; environment variable is used to populate the global Julia &lt;a href=&quot;../../base/constants/index#Base.DEPOT_PATH&quot;&gt;&lt;code&gt;DEPOT_PATH&lt;/code&gt;&lt;/a&gt; variable, which controls where the package manager, as well as Julia's code loading mechanisms, look for package registries, installed packages, named environments, repo clones, cached compiled package images, and configuration files.</source>
          <target state="translated">&lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; 의 환경 변수는 글로벌 줄리아 채우는 데 사용되는 &lt;a href=&quot;../../base/constants/index#Base.DEPOT_PATH&quot;&gt; &lt;code&gt;DEPOT_PATH&lt;/code&gt; 의&lt;/a&gt; 패키지 관리자뿐만 아니라 줄리아의 코드 로딩 메커니즘, 패키지 레지스트리, 설치된 패키지라는 환경의 repo 복제에 대한 모습, 패키지 이미지를 컴파일 캐쉬 시간 제어 변수, 및 구성 파일.</target>
        </trans-unit>
        <trans-unit id="69afeb6e2b2ee8e42ee83f53cc80115effd30019" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; environment variable is used to populate the global Julia &lt;a href=&quot;../../base/constants/index#Base.LOAD_PATH&quot;&gt;&lt;code&gt;LOAD_PATH&lt;/code&gt;&lt;/a&gt; variable, which determines which packages can be loaded via &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;using&lt;/code&gt; (see &lt;a href=&quot;../code-loading/index#Code-Loading-1&quot;&gt;Code Loading&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; 의 환경 변수가 글로벌 줄리아 채우는 데 사용되는 &lt;a href=&quot;../../base/constants/index#Base.LOAD_PATH&quot;&gt; &lt;code&gt;LOAD_PATH&lt;/code&gt; 의&lt;/a&gt; 패키지를 통해로드 할 수있는 결정 변수, &lt;code&gt;import&lt;/code&gt; 및 &lt;code&gt;using&lt;/code&gt; 합니다 ( &lt;a href=&quot;../code-loading/index#Code-Loading-1&quot;&gt;코드 로딩&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="34bade2917d4a413edb80c43d8efdb3c090b4bcc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Profile&lt;/code&gt; module provides tools to help developers improve the performance of their code. When used, it takes measurements on running code, and produces output that helps you understand how much time is spent on individual line(s). The most common usage is to identify &quot;bottlenecks&quot; as targets for optimization.</source>
          <target state="translated">&lt;code&gt;Profile&lt;/code&gt; 모듈은 도움말 개발자 도구가 코드의 성능을 향상 제공합니다. 사용하면 코드 실행에 대한 측정을 수행하고 개별 라인에 소요되는 시간을 이해하는 데 도움이되는 출력을 생성합니다. 가장 일반적인 사용법은 &quot;병목 현상&quot;을 최적화의 대상으로 식별하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="dee6516fb82f5277170e1ea0a8d04d1ed4092fd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pub&lt;/code&gt; package is in the user depot, where packages installed by the user live. These are only available to the user who installed them.</source>
          <target state="translated">&lt;code&gt;Pub&lt;/code&gt; 패키지는 패키지가 라이브 사용자가 설치 한 사용자 창고에 있습니다. 이들은 설치 한 사용자 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8c1397c7dbb153add27fc9553cd4c77cee5bc54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Regex()&lt;/code&gt; constructor may be used to create a valid regex string programmatically. This permits using the contents of string variables and other string operations when constructing the regex string. Any of the regex codes above can be used within the single string argument to &lt;code&gt;Regex()&lt;/code&gt;. Here are some examples:</source>
          <target state="translated">&lt;code&gt;Regex()&lt;/code&gt; 생성자는 프로그래밍 유효한 정규식 문자열을 만들 수 있습니다. 이것은 정규식 문자열을 구성 할 때 문자열 변수의 내용과 다른 문자열 연산을 사용할 수있게합니다. 위의 정규식 코드는 단일 문자열 인수 내에서 &lt;code&gt;Regex()&lt;/code&gt; 사용할 수 있습니다 . 여기 몇 가지 예가 있어요.</target>
        </trans-unit>
        <trans-unit id="73ca6d3bf4c447b201b63ae9bba284f7ce5a10d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;StackTraces&lt;/code&gt; module provides simple stack traces that are both human readable and easy to use programmatically.</source>
          <target state="translated">&lt;code&gt;StackTraces&lt;/code&gt; 모듈은 읽을 수 및 프로그램 사용하기 쉬운 모두 인간 간단한 스택 추적을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c7aa3a52368467c889b31b4e2156567453a420c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Test&lt;/code&gt; module provides simple &lt;em&gt;unit testing&lt;/em&gt; functionality. Unit testing is a way to see if your code is correct by checking that the results are what you expect. It can be helpful to ensure your code still works after you make changes, and can be used when developing as a way of specifying the behaviors your code should have when complete.</source>
          <target state="translated">&lt;code&gt;Test&lt;/code&gt; 모듈을 제공 간단한 &lt;em&gt;단위 테스트&lt;/em&gt; 기능. 단위 테스트는 결과가 예상 한 것인지 확인하여 코드가 올바른지 확인하는 방법입니다. 코드를 변경 한 후에도 코드가 계속 작동하도록하는 데 도움이 될 수 있으며, 코드가 완료 될 때 코드의 동작을 지정하는 방법으로 개발할 때 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a54216422a2392050b1e4b2adcb38fe041e32d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UTInstant&lt;/code&gt; represents a machine timeline based on UT time (1 day = one revolution of the earth). The &lt;code&gt;T&lt;/code&gt; is a &lt;code&gt;Period&lt;/code&gt; parameter that indicates the resolution or precision of the instant.</source>
          <target state="translated">&lt;code&gt;UTInstant&lt;/code&gt; 는 UT 시간 (지구 한 바퀴 = 1 일)에 기초한 시스템 타임 라인을 나타낸다. &lt;code&gt;T&lt;/code&gt; 는 A는 &lt;code&gt;Period&lt;/code&gt; 순간의 해상도 나 정밀도를 나타내는 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="f172eb4712d1e651ca4443a247edaddae0c02ffc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UnitRange&lt;/code&gt;&lt;code&gt;irange&lt;/code&gt; specifies indices of the sorted eigenvalues to search for.</source>
          <target state="translated">&lt;code&gt;UnitRange&lt;/code&gt; &lt;code&gt;irange&lt;/code&gt; 의 의 지정 지수를 검색하는 고유 값을 분류.</target>
        </trans-unit>
        <trans-unit id="ec153c629332b5ec9f45e8c540e2078292ed5e2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\&lt;/code&gt; character should be escaped appropriately if the text is embedded in a Julia source code, for example, &lt;code&gt;&quot;``\\LaTeX`` syntax in a docstring.&quot;&lt;/code&gt;, since it is interpreted as a string literal. Alternatively, in order to avoid escaping, it is possible to use the &lt;code&gt;raw&lt;/code&gt; string macro together with the &lt;code&gt;@doc&lt;/code&gt; macro:</source>
          <target state="translated">&lt;code&gt;\&lt;/code&gt; 문자는 텍스트가 줄리아 소스 코드에 포함되어있는 경우, 적절하게 탈출 예에 대한되어야한다 &lt;code&gt;&quot;``\\LaTeX`` syntax in a docstring.&quot;&lt;/code&gt; 문자열 리터럴로 해석되므로. 또는 이스케이프를 피하기 위해 &lt;code&gt;@doc&lt;/code&gt; 매크로 와 함께 &lt;code&gt;raw&lt;/code&gt; 문자열 매크로 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="81508e7a2286289f4f9b4e988f086408435f8b86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\&lt;/code&gt; operation here performs the linear solution. The left-division operator is pretty powerful and it's easy to write compact, readable code that is flexible enough to solve all sorts of systems of linear equations.</source>
          <target state="translated">여기서 &lt;code&gt;\&lt;/code&gt; 연산은 선형 솔루션을 수행합니다. 왼쪽 나누기 연산자는 매우 강력하며 모든 종류의 선형 방정식 시스템을 풀기에 충분히 유연한 작고 읽기 쉬운 코드를 쉽게 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70fe69b8656c0c45fea00d261b4a1573767bfc08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;abstract type&lt;/code&gt; keyword introduces a new abstract type, whose name is given by &lt;code&gt;&amp;laquo;name&amp;raquo;&lt;/code&gt;. This name can be optionally followed by &lt;code&gt;&amp;lt;:&lt;/code&gt; and an already-existing type, indicating that the newly declared abstract type is a subtype of this &quot;parent&quot; type.</source>
          <target state="translated">&lt;code&gt;abstract type&lt;/code&gt; 키워드는 이름이 주어진다 새로운 추상 형식이 도입 &lt;code&gt;&amp;laquo;name&amp;raquo;&lt;/code&gt; . 이 이름 뒤에는 &lt;code&gt;&amp;lt;:&lt;/code&gt; 와 이미 존재하는 유형이 올 수 있으며 새로 선언 된 추상 유형이이 &quot;부모&quot;유형의 하위 유형임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2f9421706ce1251dd1a3a86cb4c9ef2ac4b3c269" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;allowed_types&lt;/code&gt; contains a bitmask of &lt;code&gt;LibGit2.Consts.GIT_CREDTYPE&lt;/code&gt; values specifying which authentication methods should be attempted.</source>
          <target state="translated">&lt;code&gt;allowed_types&lt;/code&gt; 가 의 비트 마스크를 포함 &lt;code&gt;LibGit2.Consts.GIT_CREDTYPE&lt;/code&gt; 의 인증 방법이 시도되어야하는 지정 값.</target>
        </trans-unit>
        <trans-unit id="8b06ca131e63337ccd916fd14f532e8185770099" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;atol&lt;/code&gt; and &lt;code&gt;rtol&lt;/code&gt; keyword arguments requires at least Julia 1.1. In Julia 1.0 &lt;code&gt;rtol&lt;/code&gt; is available as a positional argument, but this will be deprecated in Julia 2.0.</source>
          <target state="translated">&lt;code&gt;atol&lt;/code&gt; 및 &lt;code&gt;rtol&lt;/code&gt; 키워드 인자는 적어도 줄리아 1.1이 필요합니다. Julia 1.0에서는 &lt;code&gt;rtol&lt;/code&gt; 을 위치 인수로 사용할 수 있지만 Julia 2.0에서는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a8f8106813dc53840cdd36136d9eb3701004f27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;base&lt;/code&gt; argument is a pointer to an array of length &lt;code&gt;nmemb&lt;/code&gt;, with elements of &lt;code&gt;size&lt;/code&gt; bytes each. &lt;code&gt;compare&lt;/code&gt; is a callback function which takes pointers to two elements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; and returns an integer less/greater than zero if &lt;code&gt;a&lt;/code&gt; should appear before/after &lt;code&gt;b&lt;/code&gt; (or zero if any order is permitted). Now, suppose that we have a 1d array &lt;code&gt;A&lt;/code&gt; of values in Julia that we want to sort using the &lt;code&gt;qsort&lt;/code&gt; function (rather than Julia's built-in &lt;code&gt;sort&lt;/code&gt; function). Before we worry about calling &lt;code&gt;qsort&lt;/code&gt; and passing arguments, we need to write a comparison function that works for some arbitrary objects (which define &lt;code&gt;&amp;lt;&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; 인자 길이의 배열에 대한 포인터 &lt;code&gt;nmemb&lt;/code&gt; 요소와, &lt;code&gt;size&lt;/code&gt; , 각 바이트. &lt;code&gt;compare&lt;/code&gt; 두 요소 포인터를 얻어 콜백 함수 및 &lt;code&gt;b&lt;/code&gt; 경우 복귀 정수 0보다 작은 / 큰 &lt;code&gt;a&lt;/code&gt; 이전에 나타나야 / 후 &lt;code&gt;b&lt;/code&gt; (또는 제로 순서가 허용 된 경우). 이제 Julia에 내장 줄 &lt;code&gt;sort&lt;/code&gt; 함수가 아닌 &lt;code&gt;qsort&lt;/code&gt; 함수를 사용하여 정렬하려는 1d 배열 &lt;code&gt;A&lt;/code&gt; 값이 Julia 라고 가정합니다 . &lt;code&gt;qsort&lt;/code&gt; 호출에 대해 걱정하기 전에 &lt;code&gt;a&lt;/code&gt; 인수를 전달하려면 임의의 객체 ( &lt;code&gt;&amp;lt;&lt;/code&gt; 정의 )에 작동하는 비교 함수를 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2208a0a1e673c387c0482cabd9f5481f4d468aa8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;baseline&lt;/code&gt; is the tree to be used for comparison to the working directory and index; defaults to HEAD.</source>
          <target state="translated">&lt;code&gt;baseline&lt;/code&gt; 작업 디렉토리 인덱스 비교에 사용되는 나무이다; 기본값은 HEAD입니다.</target>
        </trans-unit>
        <trans-unit id="29b441ac8e59d2fd60c5cee59a3c67db4265556f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chnl&lt;/code&gt; object can be explicitly closed independent of task termination. Terminating tasks have no effect on already closed &lt;code&gt;Channel&lt;/code&gt; objects.</source>
          <target state="translated">&lt;code&gt;chnl&lt;/code&gt; 의 객체는 명시 적으로 작업 종료 독립적으로 닫을 수 있습니다. 종료 작업은 이미 닫힌 &lt;code&gt;Channel&lt;/code&gt; 객체 에 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="efa868ba15d4c70e293eebe72c9574ee9fe6fe35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; declaration should only be used in global scope on globals. It is difficult for the compiler to optimize code involving global variables, since their values (or even their types) might change at almost any time. If a global variable will not change, adding a &lt;code&gt;const&lt;/code&gt; declaration solves this performance problem.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 선언은 전역에 전역 범위에서 사용되어야한다. 값 (또는 유형)이 거의 언제든지 변경 될 수 있으므로 컴파일러가 전역 변수와 관련된 코드를 최적화하는 것은 어렵습니다. 전역 변수가 변경되지 않으면 &lt;code&gt;const&lt;/code&gt; 선언을 추가하면 이 성능 문제가 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="58b4a67ce4add4334b6cfa9f5f2082d426131b2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;convert&lt;/code&gt; function generally takes two arguments: the first is a type object and the second is a value to convert to that type. The returned value is the value converted to an instance of given type. The simplest way to understand this function is to see it in action:</source>
          <target state="translated">&lt;code&gt;convert&lt;/code&gt; 함수는 일반적으로 2 개 개의 인수를 취하는 : 첫 번째 유형 객체이고 두 번째는 그 형태로 변환 한 값이다. 반환 된 값은 지정된 유형의 인스턴스로 변환 된 값입니다. 이 함수를 이해하는 가장 간단한 방법은 실제로 작동하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e7cb3fc07af13ab851df995a0b91fc4d68f51c39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;current&lt;/code&gt; status object may be a &lt;code&gt;StatStruct&lt;/code&gt;, an &lt;code&gt;EOFError&lt;/code&gt; (indicating the timeout elapsed), or some other &lt;code&gt;Exception&lt;/code&gt; subtype (if the &lt;code&gt;stat&lt;/code&gt; operation failed - for example, if the path does not exist).</source>
          <target state="translated">&lt;code&gt;current&lt;/code&gt; 상태 객체가 될 수 &lt;code&gt;StatStruct&lt;/code&gt; , &lt;code&gt;EOFError&lt;/code&gt; (제한 시간이 경과 나타냄), 또는 다른 어떤 &lt;code&gt;Exception&lt;/code&gt; (경우 생성 아형 &lt;code&gt;stat&lt;/code&gt; - 경로 않는 경우, 예를 들어, 존재하지 동작 실패).</target>
        </trans-unit>
        <trans-unit id="940a17c26916de1b6351b6066b3e6217426d4df2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dest&lt;/code&gt; array must be distinct from the &lt;code&gt;src&lt;/code&gt; array (they cannot alias each other).</source>
          <target state="translated">&lt;code&gt;dest&lt;/code&gt; 배열은 달라야합니다 &lt;code&gt;src&lt;/code&gt; 배열 (그들이 할 수없는 서로의 별칭).</target>
        </trans-unit>
        <trans-unit id="611e9863b6fe56ca0563d7d25daad5883ed6f0ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dir&lt;/code&gt; keyword argument can be used to specify a working directory for the command.</source>
          <target state="translated">&lt;code&gt;dir&lt;/code&gt; 키워드 인수는 명령에 대한 작업 디렉토리를 지정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4bff47d996768873bcc39999935a98007b3cec4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;do x&lt;/code&gt; syntax creates an anonymous function with argument &lt;code&gt;x&lt;/code&gt; and passes it as the first argument to &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;. Similarly, &lt;code&gt;do a,b&lt;/code&gt; would create a two-argument anonymous function, and a plain &lt;code&gt;do&lt;/code&gt; would declare that what follows is an anonymous function of the form &lt;code&gt;() -&amp;gt; ...&lt;/code&gt;.</source>
          <target state="translated">는 &lt;code&gt;do x&lt;/code&gt; 구문하는 인자와 익명 함수 생성 &lt;code&gt;x&lt;/code&gt; 하고 첫 번째 인수로서 건네 &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; . 마찬가지로, &lt;code&gt;do a,b&lt;/code&gt; 는 2 인수의 익명 함수를 생성하고, 일반 &lt;code&gt;do&lt;/code&gt; 는 뒤에 오는 것이 &lt;code&gt;() -&amp;gt; ...&lt;/code&gt; 형식의 익명 함수임을 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="38f76b197c154b053fc67ebe8a0b86d9c54ffd48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;elseif&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks are optional, and as many &lt;code&gt;elseif&lt;/code&gt; blocks as desired can be used. The condition expressions in the &lt;code&gt;if&lt;/code&gt;-&lt;code&gt;elseif&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt; construct are evaluated until the first one evaluates to &lt;code&gt;true&lt;/code&gt;, after which the associated block is evaluated, and no further condition expressions or blocks are evaluated.</source>
          <target state="translated">&lt;code&gt;elseif&lt;/code&gt; 및 &lt;code&gt;else&lt;/code&gt; 블록은 선택 사항이며, 많은으로 &lt;code&gt;elseif&lt;/code&gt; 원하는대로 블록을 사용할 수 있습니다. 의 조건식 &lt;code&gt;if&lt;/code&gt; - &lt;code&gt;elseif&lt;/code&gt; - &lt;code&gt;else&lt;/code&gt; 구조로는 첫 번째까지 평가하여 평가 &lt;code&gt;true&lt;/code&gt; 연관된 블록이 평가 된 후에, 더 이상의 조건식 블록 또는 평가하지 않는다.</target>
        </trans-unit>
        <trans-unit id="dabea74759059aade9a04e98141814de885b1362" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;line&lt;/code&gt; where the logging macro occurs in the source code.</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; 과 &lt;code&gt;line&lt;/code&gt; 로깅 매크로 소스 코드에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="baef46876dcf6509194a8000268158d1d7c2494a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; loop makes common repeated evaluation idioms easier to write. Since counting up and down like the above &lt;code&gt;while&lt;/code&gt; loop does is so common, it can be expressed more concisely with a &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 루프는 쓰기에 쉽게 일반적인 반복되는 평가 숙어한다. 위의 &lt;code&gt;while&lt;/code&gt; 루프 처럼 카운트 다운 하는 것이 일반적이므로 &lt;code&gt;for&lt;/code&gt; 루프를 사용하여보다 간결하게 표현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee6a3346a6698b43646ee623779b34ee8b0963c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;grow&lt;/code&gt; keyword argument specifies whether the disk file should be grown to accommodate the requested size of array (if the total file size is &amp;lt; requested array size). Write privileges are required to grow the file.</source>
          <target state="translated">는 &lt;code&gt;grow&lt;/code&gt; 디스크 파일 어레이의 요청 된 크기 (총 파일 사이즈 인 경우 &amp;lt;요청한 배열 크기)을 수용하기 위해 증가되어야하는지 키워드 인수 지정. 파일을 늘리려면 쓰기 권한이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="944e976cee83757342402d268820319c708e7f02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hello&lt;/code&gt; is the output of the &lt;code&gt;echo&lt;/code&gt; command, sent to &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt;. The run method itself returns &lt;code&gt;nothing&lt;/code&gt;, and throws an &lt;a href=&quot;../../base/base/index#Core.ErrorException&quot;&gt;&lt;code&gt;ErrorException&lt;/code&gt;&lt;/a&gt; if the external command fails to run successfully.</source>
          <target state="translated">&lt;code&gt;hello&lt;/code&gt; 의 출력 인 &lt;code&gt;echo&lt;/code&gt; 전송 명령, &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; . run 메소드 자체는 반환하지 않습니다 &lt;code&gt;nothing&lt;/code&gt; 및 발생 &lt;a href=&quot;../../base/base/index#Core.ErrorException&quot;&gt; &lt;code&gt;ErrorException&lt;/code&gt; 을&lt;/a&gt; 외부 명령이 성공적으로 실행하는 데 실패하는 경우.</target>
        </trans-unit>
        <trans-unit id="3728644266a88dfcc97848c625f08a3fe62768b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ipv6only&lt;/code&gt; parameter disables dual stack mode. If &lt;code&gt;ipv6only=true&lt;/code&gt;, only an IPv6 stack is created.</source>
          <target state="translated">&lt;code&gt;ipv6only&lt;/code&gt; 매개 변수는 듀얼 스택 모드를 비활성화합니다. 경우 &lt;code&gt;ipv6only=true&lt;/code&gt; 만의 IPv6 스택이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="9131ac4a45cc03434a2d1d252e0b9eb47948d016" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;k&lt;/code&gt;th diagonal of a matrix, as a vector.</source>
          <target state="translated">벡터의 행렬 의 &lt;code&gt;k&lt;/code&gt; 번째 대각선입니다.</target>
        </trans-unit>
        <trans-unit id="586747034b4744d9048e093e3d358be130046659" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; block creates a new variable &lt;code&gt;r&lt;/code&gt; whose scope is only the inner function. The second technique recovers full language performance in the presence of captured variables. Note that this is a rapidly evolving aspect of the compiler, and it is likely that future releases will not require this degree of programmer annotation to attain performance. In the mean time, some user-contributed packages like &lt;a href=&quot;https://github.com/c42f/FastClosures.jl&quot;&gt;FastClosures&lt;/a&gt; automate the insertion of &lt;code&gt;let&lt;/code&gt; statements as in &lt;code&gt;abmult3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 블록 새로운 변수 생성 &lt;code&gt;r&lt;/code&gt; 그 범위 내에서만 기능이다. 두 번째 기술은 캡처 된 변수가있는 경우 전체 언어 성능을 복구합니다. 이는 컴파일러의 급속한 발전 측면이며 향후 릴리스에서는 성능을 얻기 위해이 정도의 프로그래머 주석이 필요하지 않을 수 있습니다. 그 동안, 같은 일부 사용자 - 기여 패키지 &lt;a href=&quot;https://github.com/c42f/FastClosures.jl&quot;&gt;FastClosures은&lt;/a&gt; 의 삽입 자동화 &lt;code&gt;let&lt;/code&gt; 같이 문을 &lt;code&gt;abmult3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="404db33b1806403679f9afdc7e45d8ad145e7ae6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;local&lt;/code&gt; and &lt;code&gt;global&lt;/code&gt; keywords can also be applied to destructuring assignments, e.g. &lt;code&gt;local x, y = 1, 2&lt;/code&gt;. In this case the keyword affects all listed variables.</source>
          <target state="translated">&lt;code&gt;local&lt;/code&gt; 및 &lt;code&gt;global&lt;/code&gt; 키워드는 예 destructuring 과제에 적용 할 수있는 &lt;code&gt;local x, y = 1, 2&lt;/code&gt; . 이 경우 키워드는 나열된 모든 변수에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="b4e455fac98bba78f84dcce75d6fd177f25053bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loopback&lt;/code&gt; keyword argument dictates whether loopback addresses are included.</source>
          <target state="translated">&lt;code&gt;loopback&lt;/code&gt; 키워드 인수 지시는 루프백 주소가 포함되는지 여부.</target>
        </trans-unit>
        <trans-unit id="43f03591f994b72dda2b585d5125cc1a285cbfab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;module&lt;/code&gt; in which the logging macro was expanded.</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; 로깅 매크로 확장시킨.</target>
        </trans-unit>
        <trans-unit id="4522c3b2f49470689410e3676d64813c5ddeff60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt;-norm is defined as</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; -norm 같이 정의된다</target>
        </trans-unit>
        <trans-unit id="98b88a0b1c328d1e6bd27b342609d1fb54652c60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;promote&lt;/code&gt; function converts all its arguments to a common type &amp;ndash; in this case &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;. With this method definition, the &lt;code&gt;Point&lt;/code&gt; constructor promotes its arguments the same way that numeric operators like &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt; do, and works for all kinds of real numbers:</source>
          <target state="translated">는 &lt;code&gt;promote&lt;/code&gt; 이 경우 - 기능 변환하는 일반적인 유형에 대한 모든 인수 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; 을&lt;/a&gt; . 이 메소드 정의를 사용하면 &lt;code&gt;Point&lt;/code&gt; 생성자가 &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt; &lt;code&gt;+&lt;/code&gt; &lt;/a&gt; 와 같은 숫자 연산자와 같은 방식으로 인수를 승격시키고 모든 종류의 실수에 대해 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8297e1ed549bbae968b6d4d9056ddd08eaa6ab7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;promote_rule&lt;/code&gt; function is used as a building block to define a second function called &lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt;&lt;code&gt;promote_type&lt;/code&gt;&lt;/a&gt;, which, given any number of type objects, returns the common type to which those values, as arguments to &lt;code&gt;promote&lt;/code&gt; should be promoted. Thus, if one wants to know, in absence of actual values, what type a collection of values of certain types would promote to, one can use &lt;code&gt;promote_type&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;promote_rule&lt;/code&gt; 의 함수라는 두 번째 함수 정의하는 빌딩 블록으로서 사용된다 &lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt; &lt;code&gt;promote_type&lt;/code&gt; &lt;/a&gt; 유형 오브젝트의 수 주어진 인수에 그 값되는 일반적인 유형의 복귀, &lt;code&gt;promote&lt;/code&gt; 촉진되어야한다. 따라서 실제 값이 없으면 특정 유형의 값 모음이 승격시킬 유형을 &lt;code&gt;promote_type&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b692555ebed7ff435cd42db277bcbc90f0f6b5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;r&quot;...&quot;&lt;/code&gt; literal is constructed without interpolation and unescaping (except for quotation mark &lt;code&gt;&quot;&lt;/code&gt; which still has to be escaped). Here is an example showing the difference from standard string literals:</source>
          <target state="translated">&lt;code&gt;r&quot;...&quot;&lt;/code&gt; 리터럴 (따옴표 제외 보간 이스케이프 취소없이 구성되는 &lt;code&gt;&quot;&lt;/code&gt; 정지 이스케이프한다) 여기서 표준 문자열 상수의 차이를 보여주는 예이다. :</target>
        </trans-unit>
        <trans-unit id="2a6072b422e59a959f8b81bd76474b677710288a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;return&lt;/code&gt; Keyword</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; 키워드</target>
        </trans-unit>
        <trans-unit id="fbd3a71fad13cb9858c23c4a3ef4f996112c52ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;same_type_numeric&lt;/code&gt; function behaves much like the &lt;code&gt;same_type&lt;/code&gt; function defined above, but is only defined for pairs of numbers.</source>
          <target state="translated">&lt;code&gt;same_type_numeric&lt;/code&gt; 기능은 많은처럼 동작 &lt;code&gt;same_type&lt;/code&gt; 의 위 정의 함수,하지만 숫자의 쌍에 대해 정의된다.</target>
        </trans-unit>
        <trans-unit id="9fab5a03f87c103ae23a4670919e1023dea2f659" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shared&lt;/code&gt; keyword argument specifies whether the resulting &lt;code&gt;Array&lt;/code&gt; and changes made to it will be visible to other processes mapping the same file.</source>
          <target state="translated">&lt;code&gt;shared&lt;/code&gt; 키워드 인수 지정은 결과 여부를 &lt;code&gt;Array&lt;/code&gt; 그것을 만든 변경은 같은 파일을 매핑 다른 프로세스에 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0931d123977915d4a1d899bba2683bbb5d1cf496" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shred&lt;/code&gt; keyword controls whether sensitive information in the payload credential field should be destroyed. Should only be set to &lt;code&gt;false&lt;/code&gt; during testing.</source>
          <target state="translated">는 &lt;code&gt;shred&lt;/code&gt; 페이로드 자격 분야에서 중요한 정보를 파괴해야하는지 여부를 키워드 컨트롤을. 테스트하는 동안에 만 &lt;code&gt;false&lt;/code&gt; 로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fe58d87c8dd555b134b1d599492862c038b6d10f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state&lt;/code&gt; object may be anything, and should be chosen appropriately for each iterable type. See the &lt;a href=&quot;../../manual/interfaces/index#man-interface-iteration-1&quot;&gt;manual section on the iteration interface&lt;/a&gt; for more details about defining a custom iterable type.</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; 객체는 아무것도 할 수 있으며, 각각의 반복 가능한 유형에 대해 적절하게 선택해야합니다. 사용자 정의 반복 가능 유형 정의에 대한 자세한 내용은 &lt;a href=&quot;../../manual/interfaces/index#man-interface-iteration-1&quot;&gt;반복 인터페이스&lt;/a&gt; 의 매뉴얼 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="197a5a1cfcc6bf414db454749ace6bc6b46270e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transcode&lt;/code&gt; function succeeds as long as the input data can be reasonably represented in the target encoding; it always succeeds for conversions between UTF-XX encodings, even for invalid Unicode data.</source>
          <target state="translated">&lt;code&gt;transcode&lt;/code&gt; 기능은 긴 입력 데이터 합리적 부호화 대상으로 표현 될 수있는만큼 성공; 유효하지 않은 유니 코드 데이터의 경우에도 UTF-XX 인코딩 간 변환에 항상 성공합니다.</target>
        </trans-unit>
        <trans-unit id="25bce1e285bcf1b8934e0d8620acac52150b4abc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try/catch&lt;/code&gt; statement</source>
          <target state="translated">&lt;code&gt;try/catch&lt;/code&gt; 문</target>
        </trans-unit>
        <trans-unit id="c2c1155010a79df372e519698f4e8f431ee252c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try/catch&lt;/code&gt; statement allows for &lt;code&gt;Exception&lt;/code&gt;s to be tested for, and for the graceful handling of things that may ordinarily break your application. For example, in the below code the function for square root would normally throw an exception. By placing a &lt;code&gt;try/catch&lt;/code&gt; block around it we can mitigate that here. You may choose how you wish to handle this exception, whether logging it, return a placeholder value or as in the case below where we just printed out a statement. One thing to think about when deciding how to handle unexpected situations is that using a &lt;code&gt;try/catch&lt;/code&gt; block is much slower than using conditional branching to handle those situations. Below there are more examples of handling exceptions with a &lt;code&gt;try/catch&lt;/code&gt; block:</source>
          <target state="translated">&lt;code&gt;try/catch&lt;/code&gt; 문을 허용 &lt;code&gt;Exception&lt;/code&gt; 들에 대한 테스트하고, 일반적으로 응용 프로그램을 중단 할 수 사물의 우아한 처리합니다. 예를 들어, 아래 코드에서 제곱근 함수는 일반적으로 예외를 발생시킵니다. &lt;code&gt;try/catch&lt;/code&gt; 블록을 그 주변에 배치하면 여기서이를 완화 할 수 있습니다. 이 예외 처리 방법, 로깅 여부, 자리 표시 자 값 반환 또는 방금 명령문을 인쇄 한 아래의 경우와 같이 선택할 수 있습니다. 예기치 않은 상황을 처리하는 방법을 결정할 때 고려해야 할 사항은 &lt;code&gt;try/catch&lt;/code&gt; 블록 을 사용하는 것이 조건부 분기를 사용하여 해당 상황을 처리하는 것보다 훨씬 느리다는 것입니다. 아래는 &lt;code&gt;try/catch&lt;/code&gt; 로 예외를 처리하는 더 많은 예입니다. 블록:</target>
        </trans-unit>
        <trans-unit id="8de2b2884ad5c0d59519c41370d411d31e17c8aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; prefix on this function indicates that no validation is performed on the pointer &lt;code&gt;p&lt;/code&gt; to ensure that it is valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.</source>
          <target state="translated">이 함수 의 &lt;code&gt;unsafe&lt;/code&gt; 접두사는 포인터 &lt;code&gt;p&lt;/code&gt; 에 대해 유효성 검사가 수행되지 않았 음을 확인하지 않습니다. 잘못 사용하면 C와 같은 방식으로 프로그램이 손상되거나 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ad1cf514621d9bd7509c63edb01e709a946f374" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; prefix on this function indicates that no validation is performed on the pointer &lt;code&gt;p&lt;/code&gt; to ensure that it is valid. Incorrect usage may segfault your program or return garbage answers, in the same manner as C.</source>
          <target state="translated">이 함수 의 &lt;code&gt;unsafe&lt;/code&gt; 접두사는 포인터 &lt;code&gt;p&lt;/code&gt; 에 대해 유효성 검사가 수행되지 않았 음을 확인하지 않습니다. 잘못 사용하면 C와 같은 방식으로 프로그램을 보호하거나 가비지 응답을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffd2fc5d018bc4147802a9ab69acc1302211d9d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; prefix on this function indicates that no validation is performed on the pointers &lt;code&gt;dest&lt;/code&gt; and &lt;code&gt;src&lt;/code&gt; to ensure that they are valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.</source>
          <target state="translated">이 함수 의 &lt;code&gt;unsafe&lt;/code&gt; 접두어는 포인터 &lt;code&gt;dest&lt;/code&gt; 및 &lt;code&gt;src&lt;/code&gt; 에 대해 유효성 검사가 수행되지 않았 음을 확인하지 않습니다. 잘못 사용하면 C와 같은 방식으로 프로그램이 손상되거나 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c545e57ea20b7dee78b3ead6faf2e0dd60dec4ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; prefix on this function indicates that no validation is performed to ensure that N is inbounds on either array. Incorrect usage may corrupt or segfault your program, in the same manner as C.</source>
          <target state="translated">이 함수 의 &lt;code&gt;unsafe&lt;/code&gt; 접두사는 N이 두 배열에 대해 인바운드인지 확인하기 위해 유효성 검사가 수행되지 않음을 나타냅니다. 잘못 사용하면 C와 같은 방식으로 프로그램이 손상되거나 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4d657f988d9e3352165918f5b958ddc6e9310c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; prefix on this function indicates that using the result of this function after the &lt;code&gt;x&lt;/code&gt; argument to this function is no longer accessible to the program may cause undefined behavior, including program corruption or segfaults, at any later time.</source>
          <target state="translated">이 함수 의 &lt;code&gt;unsafe&lt;/code&gt; 접두어는이 함수의 &lt;code&gt;x&lt;/code&gt; 인수에 더 이상 프로그램이 액세스 할 수없는 후이 함수의 결과를 사용하면 나중에 프로그램 손상 또는 segfaults를 포함하여 정의되지 않은 동작이 발생할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1f00bb06127cf74d0a7a977235b45b41a807deea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;userdata&lt;/code&gt; field is used to store information for each worker by external managers.</source>
          <target state="translated">&lt;code&gt;userdata&lt;/code&gt; 필드는 외부 관리자에 의해 각 직원에 대한 정보를 저장하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ea1c59c30ca45a88d468b07114183bcee1a4d149" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;where&lt;/code&gt; keyword creates a type that is an iterated union of other types, over all values of some variable. For example &lt;code&gt;Vector{T} where T&amp;lt;:Real&lt;/code&gt; includes all &lt;a href=&quot;../arrays/index#Base.Vector&quot;&gt;&lt;code&gt;Vector&lt;/code&gt;&lt;/a&gt;s where the element type is some kind of &lt;code&gt;Real&lt;/code&gt; number.</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt; 키워드는 다른 유형의 반복 된 노동 조합이 어떤 변수의 모든 값에 걸쳐있는 유형을 만듭니다. 예를 들어 &lt;code&gt;Vector{T} where T&amp;lt;:Real&lt;/code&gt; 모두 포함 &lt;a href=&quot;../arrays/index#Base.Vector&quot;&gt; &lt;code&gt;Vector&lt;/code&gt; &lt;/a&gt; 의 요소의 형태는 어떤 종류이고 &lt;code&gt;Real&lt;/code&gt; 번호를.</target>
        </trans-unit>
        <trans-unit id="e2963a52dada4be3a4b826619d947c135b0ff9a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;where&lt;/code&gt; keyword itself can be nested inside a more complex declaration. For example, consider the two types created by the following declarations:</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt; 자체 키워드는 더 복잡한 선언 안에 중첩 될 수 있습니다. 예를 들어 다음 선언으로 생성 된 두 가지 유형을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="998cd2a7738c69cc615469e2df80e3038aa7e4db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; loop evaluates the condition expression (&lt;code&gt;i &amp;lt;= 5&lt;/code&gt; in this case), and as long it remains &lt;code&gt;true&lt;/code&gt;, keeps also evaluating the body of the &lt;code&gt;while&lt;/code&gt; loop. If the condition expression is &lt;code&gt;false&lt;/code&gt; when the &lt;code&gt;while&lt;/code&gt; loop is first reached, the body is never evaluated.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 루프는 조건식 (평가 &lt;code&gt;i &amp;lt;= 5&lt;/code&gt; 이 경우에는), 그것은 여전히 긴 같은 &lt;code&gt;true&lt;/code&gt; 도 본문 평가 유지 &lt;code&gt;while&lt;/code&gt; 루프. &lt;code&gt;while&lt;/code&gt; 루프에 처음 도달 할 때 조건 표현식이 &lt;code&gt;false&lt;/code&gt; 이면 본문이 평가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c9eac2e060f4090d788f5a1733519b89ab4b4ae0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;binomial coefficient&lt;/em&gt;$\binom{n}{k}$, being the coefficient of the $k$th term in the polynomial expansion of $(1+x)^n$.</source>
          <target state="translated">&lt;em&gt;이항 계수&lt;/em&gt; $ \하기 Binom {N} {K} $은 $ K $ 계수 $ 번째의 다항식 전개에 기간 (1 + X) ^ N 인 $.</target>
        </trans-unit>
        <trans-unit id="5f58dd4e346415c12b8a2bde13968a9b1deff1c2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;log level&lt;/em&gt; is a broad category for the message that is used for early filtering. There are several standard levels of type &lt;a href=&quot;#Base.CoreLogging.LogLevel&quot;&gt;&lt;code&gt;LogLevel&lt;/code&gt;&lt;/a&gt;; user-defined levels are also possible.</source>
          <target state="translated">&lt;em&gt;로그 레벨은&lt;/em&gt; 초기 필터링을 위해 사용되는 메시지에 대한 광범위한 범주이다. &lt;a href=&quot;#Base.CoreLogging.LogLevel&quot;&gt; &lt;code&gt;LogLevel&lt;/code&gt; &lt;/a&gt; 형식에는 몇 가지 표준 수준이 있습니다 . 사용자 정의 수준도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="31fe1c7ad22ee14f0705951a3acf51f247460513" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;message&lt;/em&gt; is an object describing the event. By convention &lt;code&gt;AbstractString&lt;/code&gt;s passed as messages are assumed to be in markdown format. Other types will be displayed using &lt;code&gt;show(io,mime,obj)&lt;/code&gt; according to the display capabilities of the installed logger.</source>
          <target state="translated">&lt;em&gt;메시지&lt;/em&gt; 이벤트를 기술하는 것을 목적으로한다. 관례 적 으로 메시지로 전달 된 &lt;code&gt;AbstractString&lt;/code&gt; 은 마크 다운 형식으로 간주됩니다. 설치된 로거의 표시 기능에 따라 &lt;code&gt;show(io,mime,obj)&lt;/code&gt; 사용하여 다른 유형이 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="ff35386d12b40dc9ba6f11aed8e1486efcf6f63b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;primary environment&lt;/em&gt;&amp;mdash;i.e. the first environment in a stack&amp;mdash;is faithfully embedded in a stacked environment. The full dependency graph of the first environment in a stack is guaranteed to be included intact in the stacked environment including the same versions of all dependencies.</source>
          <target state="translated">&lt;em&gt;기본 환경&lt;/em&gt; A의 제 환경 - 즉 스택 - 충실 적층되어 환경에 매립. 스택에서 첫 번째 환경의 전체 종속성 그래프는 동일한 버전의 모든 종속성을 포함하여 스택 환경에 그대로 포함되도록 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="f56a5c0b72490015a89e1c362931e81a9ffdc753" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;scope&lt;/em&gt; of a variable is the region of code within which a variable is visible. Variable scoping helps avoid variable naming conflicts. The concept is intuitive: two functions can both have arguments called &lt;code&gt;x&lt;/code&gt; without the two &lt;code&gt;x&lt;/code&gt;'s referring to the same thing. Similarly, there are many other cases where different blocks of code can use the same name without referring to the same thing. The rules for when the same variable name does or doesn't refer to the same thing are called scope rules; this section spells them out in detail.</source>
          <target state="translated">변수 의 &lt;em&gt;범위&lt;/em&gt; 는 변수가 보이는 코드 영역입니다. 변수 범위 지정은 변수 이름 충돌을 피하는 데 도움이됩니다. 개념은 직관적입니다. 두 개의 함수는 두 개의 &lt;code&gt;x&lt;/code&gt; 가 동일한 것을 참조 하지 않고 &lt;code&gt;x&lt;/code&gt; 라는 인수를 가질 수 있습니다 . 마찬가지로, 다른 코드 블록이 동일한 것을 참조하지 않고 동일한 이름을 사용할 수있는 다른 많은 경우가 있습니다. 동일한 변수 이름이 동일한 것을 참조하거나 참조하지 않는 규칙을 범위 규칙이라고합니다. 이 섹션에서 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e823801b39157cff5d7794c3183a7d1989add808" translate="yes" xml:space="preserve">
          <source>The API for 1) is quite functional, but is relatively recent so it may still have to evolve in subsequent releases of the &lt;code&gt;Random&lt;/code&gt; module. For example, it's typically sufficient to implement one &lt;code&gt;rand&lt;/code&gt; method in order to have all other usual methods work automatically.</source>
          <target state="translated">1) 용 API는 상당히 기능적이지만 비교적 최신 버전이므로 이후 버전의 &lt;code&gt;Random&lt;/code&gt; 모듈 에서 계속 진화해야 할 수도 있습니다 . 예를 들어, 다른 모든 일반적인 메소드가 자동으로 작동하도록하려면 하나의 &lt;code&gt;rand&lt;/code&gt; 메소드 를 구현하는 것으로 충분합니다 .</target>
        </trans-unit>
        <trans-unit id="8ab319b5b160e68efa740a64380d05f1be87039a" translate="yes" xml:space="preserve">
          <source>The API for 2) is still rudimentary, and may require more work than strictly necessary from the implementor, in order to support usual types of generated values.</source>
          <target state="translated">2)의 API는 여전히 초보적이며 일반적인 유형의 생성 된 값을 지원하기 위해 구현 자에게 반드시 필요한 것보다 더 많은 작업이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f9630cea145272914a5264c86a31f652e4069fa" translate="yes" xml:space="preserve">
          <source>The API is not clearly defined yet, but as a rule of thumb:</source>
          <target state="translated">API는 아직 명확하게 정의되어 있지 않지만 경험상 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a2cac855dd1e1320bc002428689d4b74c6a1a9ec" translate="yes" xml:space="preserve">
          <source>The ASCII string &quot;DATA&quot; corresponds to the bytes 68, 65, 84, 65. &lt;code&gt;\xff&lt;/code&gt; produces the single byte 255. The Unicode escape &lt;code&gt;\u2200&lt;/code&gt; is encoded in UTF-8 as the three bytes 226, 136, 128. Note that the resulting byte array does not correspond to a valid UTF-8 string:</source>
          <target state="translated">ASCII 문자열 &quot;DATA&quot;는 바이트 68, 65, 84, 65에 &lt;code&gt;\xff&lt;/code&gt; 합니다 . \ xff 는 단일 바이트 255를 생성합니다. 유니 코드 이스케이프 &lt;code&gt;\u2200&lt;/code&gt; 은 3 바이트 226, 136, 128로 UTF-8로 인코딩됩니다. 결과 바이트 배열이 유효한 UTF-8 문자열에 해당하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="39a538bac8d2eeb537bfbc18fea41895f84fba1e" translate="yes" xml:space="preserve">
          <source>The C &lt;code&gt;getenv&lt;/code&gt; function indicates an error by returning &lt;code&gt;NULL&lt;/code&gt;, but other standard C functions indicate errors in various different ways, including by returning -1, 0, 1 and other special values. This wrapper throws an exception clearly indicating the problem if the caller tries to get a non-existent environment variable:</source>
          <target state="translated">C &lt;code&gt;getenv&lt;/code&gt; 함수는 &lt;code&gt;NULL&lt;/code&gt; 을 반환하여 오류를 나타내지 만 다른 표준 C 함수는 -1, 0, 1 및 기타 특수 값을 반환하는 등 다양한 방법으로 오류를 나타냅니다. 이 래퍼는 호출자가 존재하지 않는 환경 변수를 얻으려고 시도하면 문제를 명확하게 나타내는 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="bb0be6121167f43ded0796e444ece3ab2ece1c9f" translate="yes" xml:space="preserve">
          <source>The C function wrapped returns an integer error code; the results of the actual evaluation of the Bessel J function populate the Julia array &lt;code&gt;result_array&lt;/code&gt;. This variable can only be used with corresponding input type declaration &lt;code&gt;Ref{Cdouble}&lt;/code&gt;, since its memory is allocated and managed by Julia, not C. The implicit call to &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert(Ref{Cdouble}, result_array)&lt;/code&gt;&lt;/a&gt; unpacks the Julia pointer to a Julia array data structure into a form understandable by C.</source>
          <target state="translated">랩핑 된 C 함수는 정수 오류 코드를 리턴합니다. Bessel J 함수의 실제 평가 결과는 Julia 배열 &lt;code&gt;result_array&lt;/code&gt; 를 채 웁니다 . 이 변수는 메모리가 C가 아닌 Julia에 의해 할당되고 관리되므로 해당 입력 유형 선언 &lt;code&gt;Ref{Cdouble}&lt;/code&gt; 에만 사용할 수 있습니다 . &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert(Ref{Cdouble}, result_array)&lt;/code&gt; &lt;/a&gt; 대한 암시 적 호출 은 Julia 포인터를 Julia는 데이터 구조를 C가 이해할 수있는 형태로 배열합니다.</target>
        </trans-unit>
        <trans-unit id="e369993cdb5fa6e70590fdbba6d637a46744b422" translate="yes" xml:space="preserve">
          <source>The C null pointer constant, sometimes used when calling external code.</source>
          <target state="translated">외부 코드를 호출 할 때 사용되는 C null 포인터 상수입니다.</target>
        </trans-unit>
        <trans-unit id="1266dcff3400e720f05ea76935c60007b496fe2d" translate="yes" xml:space="preserve">
          <source>The Darwin kernel descends from BSD, which means that &lt;code&gt;Sys.isbsd()&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; on macOS systems. To exclude macOS from a predicate, use &lt;code&gt;Sys.isbsd() &amp;amp;&amp;amp; !Sys.isapple()&lt;/code&gt;.</source>
          <target state="translated">다윈 커널은 BSD의 자손입니다. 이는 macOS 시스템에서 &lt;code&gt;Sys.isbsd()&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 임을 의미 합니다. 술어에서 macOS를 제외하려면 &lt;code&gt;Sys.isbsd() &amp;amp;&amp;amp; !Sys.isapple()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d062d595ac22ed3de2b1695d4234bbdd4c8970f" translate="yes" xml:space="preserve">
          <source>The Examples folder &lt;code&gt;clustermanager/simple&lt;/code&gt; is an example that shows a simple implementation using UNIX domain sockets for cluster setup.</source>
          <target state="translated">예제 폴더 &lt;code&gt;clustermanager/simple&lt;/code&gt; 은 클러스터 설정에 UNIX 도메인 소켓을 사용하는 간단한 구현을 보여주는 예입니다.</target>
        </trans-unit>
        <trans-unit id="47538569b998ba670f072a1e4a838d9065a41d8f" translate="yes" xml:space="preserve">
          <source>The GC can be allowed to deallocate a variable by removing the reference to it from &lt;code&gt;refs&lt;/code&gt; using the function &lt;code&gt;delete!&lt;/code&gt;, provided that no other reference to the variable is kept anywhere:</source>
          <target state="translated">GC의 행은 그 행의 기준 제거하여 변수를 할당 해제하도록 허용 할 수 &lt;code&gt;refs&lt;/code&gt; 함수를 이용하여 &lt;code&gt;delete!&lt;/code&gt; 변수에 대한 다른 참조가 어디에도 보관되어 있지 않은 경우 :</target>
        </trans-unit>
        <trans-unit id="9114ec3ce1d9b68ea428c28233e88219f98a90cb" translate="yes" xml:space="preserve">
          <source>The GC can only run when Julia objects are allocated. Calls like &lt;code&gt;jl_box_float64&lt;/code&gt; perform allocation, and allocation might also happen at any point in running Julia code. However, it is generally safe to use pointers in between &lt;code&gt;jl_...&lt;/code&gt; calls. But in order to make sure that values can survive &lt;code&gt;jl_...&lt;/code&gt; calls, we have to tell Julia that we hold a reference to a Julia value. This can be done using the &lt;code&gt;JL_GC_PUSH&lt;/code&gt; macros:</source>
          <target state="translated">Julia 객체가 할당 된 경우에만 GC를 실행할 수 있습니다. &lt;code&gt;jl_box_float64&lt;/code&gt; 와 같은 호출은 할당을 수행하며 Julia 코드를 실행할 때 언제든지 할당이 발생할 수 있습니다. 그러나 &lt;code&gt;jl_...&lt;/code&gt; 호출 사이에 포인터를 사용하는 것이 일반적으로 안전 합니다. 그러나 &lt;code&gt;jl_...&lt;/code&gt; 호출에서 값을 유지할 수 있으려면 Julia에게 Julia 값에 대한 참조를 보유하고 있음을 알려야합니다. 이는 &lt;code&gt;JL_GC_PUSH&lt;/code&gt; 매크로를 사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4c26097947d8e62d93e95f7bb8a753aa81198a0d" translate="yes" xml:space="preserve">
          <source>The Julia REPL</source>
          <target state="translated">줄리아 REPL</target>
        </trans-unit>
        <trans-unit id="966cbe6fa0ef45947b54d91f086e0f21369273f7" translate="yes" xml:space="preserve">
          <source>The Julia REPL makes great use of key bindings. Several control-key bindings were already introduced above (&lt;code&gt;^D&lt;/code&gt; to exit, &lt;code&gt;^R&lt;/code&gt; and &lt;code&gt;^S&lt;/code&gt; for searching), but there are many more. In addition to the control-key, there are also meta-key bindings. These vary more by platform, but most terminals default to using alt- or option- held down with a key to send the meta-key (or can be configured to do so).</source>
          <target state="translated">Julia REPL은 키 바인딩을 잘 활용합니다. 여러 컨트롤 키 바인딩이 이미 위에서 소개 되었지만 (검색 하려면 &lt;code&gt;^D&lt;/code&gt; , 검색 에는 &lt;code&gt;^R&lt;/code&gt; 및 &lt;code&gt;^S&lt;/code&gt; ) 더 많은 것이 있습니다. 컨트롤 키 외에 메타 키 바인딩도 있습니다. 이것들은 플랫폼에 따라 더 다양하지만 대부분의 터미널은 기본적으로 메타 키를 보내기 위해 alt 또는 option-holded를 사용하여 메타 키를 보내거나 그렇게 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78a8d27e5d46846612931d336af5427fb48eaefb" translate="yes" xml:space="preserve">
          <source>The Julia internal variable &lt;a href=&quot;../../base/constants/index#Base.Sys.WORD_SIZE&quot;&gt;&lt;code&gt;Sys.WORD_SIZE&lt;/code&gt;&lt;/a&gt; indicates whether the target system is 32-bit or 64-bit:</source>
          <target state="translated">Julia 내부 변수 &lt;a href=&quot;../../base/constants/index#Base.Sys.WORD_SIZE&quot;&gt; &lt;code&gt;Sys.WORD_SIZE&lt;/code&gt; &lt;/a&gt; 는 대상 시스템이 32 비트인지 64 비트인지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1693b1af11374cde64dabe11066916f7ee8e88c7" translate="yes" xml:space="preserve">
          <source>The Julia process running the driver script in the example above has an &lt;code&gt;id&lt;/code&gt; equal to 1, just like a process providing an interactive prompt.</source>
          <target state="translated">위 예제에서 드라이버 스크립트를 실행하는 Julia 프로세스 는 대화식 프롬프트를 제공하는 프로세스와 마찬가지로 &lt;code&gt;id&lt;/code&gt; 가 1입니다.</target>
        </trans-unit>
        <trans-unit id="aa8416476707db541c2333530ff960a4433eec90" translate="yes" xml:space="preserve">
          <source>The Julian mode</source>
          <target state="translated">줄리안 모드</target>
        </trans-unit>
        <trans-unit id="65c675577bb25cbb84233bfad40ea840727c87ba" translate="yes" xml:space="preserve">
          <source>The LQ decomposition is the QR decomposition of &lt;code&gt;transpose(A)&lt;/code&gt;.</source>
          <target state="translated">LQ 분해는 &lt;code&gt;transpose(A)&lt;/code&gt; 의 QR 분해입니다 .</target>
        </trans-unit>
        <trans-unit id="b05b84454661b0ad77fcf176c57484bf1c0a4367" translate="yes" xml:space="preserve">
          <source>The LibGit2 module provides bindings to &lt;a href=&quot;https://libgit2.org/&quot;&gt;libgit2&lt;/a&gt;, a portable C library that implements core functionality for the &lt;a href=&quot;https://git-scm.com/&quot;&gt;Git&lt;/a&gt; version control system. These bindings are currently used to power Julia's package manager. It is expected that this module will eventually be moved into a separate package.</source>
          <target state="translated">LibGit2 모듈은 &lt;a href=&quot;https://git-scm.com/&quot;&gt;Git&lt;/a&gt; 버전 제어 시스템 의 핵심 기능을 구현하는 이식 가능한 C 라이브러리 인 &lt;a href=&quot;https://libgit2.org/&quot;&gt;libgit2에&lt;/a&gt; 대한 바인딩을 제공 합니다. 이 바인딩은 현재 Julia의 패키지 관리자를 강화하는 데 사용됩니다. 이 모듈은 결국 별도의 패키지로 이동 될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="9bf2cc298d975bbd37b6f7fd047fb42694bf8a90" translate="yes" xml:space="preserve">
          <source>The MethodInstance containing the execution context (if it could be found).</source>
          <target state="translated">실행 컨텍스트가 포함 된 MethodInstance입니다 (찾을 수있는 경우).</target>
        </trans-unit>
        <trans-unit id="09f175ba6c5dae9885fb192f636fd6ea181b8da1" translate="yes" xml:space="preserve">
          <source>The MultiSelectMenu allows users to select many choices from a list.</source>
          <target state="translated">MultiSelectMenu를 사용하면 목록에서 많은 선택을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e79dc73e951d809603b22dcb8e0be503a1e70e20" translate="yes" xml:space="preserve">
          <source>The Perl expression needs to be in single quotes for two reasons: so that spaces don't break the expression into multiple shell words, and so that uses of Perl variables like &lt;code&gt;$|&lt;/code&gt; (yes, that's the name of a variable in Perl), don't cause interpolation. In other instances, you may want to use double quotes so that interpolation &lt;em&gt;does&lt;/em&gt; occur:</source>
          <target state="translated">Perl 표현식은 다음 두 가지 이유로 작은 따옴표로 묶어야합니다. 공백이 표현식을 여러 쉘 단어로 분리하지 않고 &lt;code&gt;$|&lt;/code&gt; 와 같은 Perl 변수를 사용하는 경우 (예, 이것은 Perl의 변수 이름입니다) 보간을 일으키지 않습니다. 다른 경우에는 보간 &lt;em&gt;이&lt;/em&gt; 발생 하도록 큰 따옴표를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac56e6a222fd8496371258c1e3e6d866939f3927" translate="yes" xml:space="preserve">
          <source>The REPL has four main modes of operation. The first and most common is the Julian prompt. It is the default mode of operation; each new line initially starts with &lt;code&gt;julia&amp;gt;&lt;/code&gt;. It is here that you can enter Julia expressions. Hitting return or enter after a complete expression has been entered will evaluate the entry and show the result of the last expression.</source>
          <target state="translated">REPL에는 4 가지 주요 작동 모드가 있습니다. 첫 번째이자 가장 일반적인 것은 Julian 프롬프트입니다. 기본 작동 모드입니다. 각 줄은 처음에 &lt;code&gt;julia&amp;gt;&lt;/code&gt; 로 시작합니다 . 여기에 Julia 표현식을 입력 할 수 있습니다. 전체 표현식을 입력 한 후 return 또는 enter 키를 누르면 항목이 평가되고 마지막 표현식의 결과가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7b885d623b0799b11114ac06066f9470abd82025" translate="yes" xml:space="preserve">
          <source>The RadioMenu allows the user to select one option from the list. The &lt;code&gt;request&lt;/code&gt; function displays the interactive menu and returns the index of the selected choice. If a user presses 'q' or &lt;code&gt;ctrl-c&lt;/code&gt;, &lt;code&gt;request&lt;/code&gt; will return a &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">RadioMenu를 사용하면 목록에서 하나의 옵션을 선택할 수 있습니다. &lt;code&gt;request&lt;/code&gt; 기능 표시 대화 형 메뉴 및 반환 선택한 선택의 인덱스입니다. 사용자 프레스 'Q'또는 경우 &lt;code&gt;ctrl-c&lt;/code&gt; , &lt;code&gt;request&lt;/code&gt; 를 반환 &lt;code&gt;-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59e9b2d3e677af4a8fc2eebaa65445429cdf1c63" translate="yes" xml:space="preserve">
          <source>The Statistics module contains basic statistics functionality.</source>
          <target state="translated">통계 모듈에는 기본 통계 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="05d7e2a5c0d018541c4ea58100e6545824bf9830" translate="yes" xml:space="preserve">
          <source>The ability to define function behavior across many combinations of argument types via &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiple_dispatch&quot;&gt;multiple dispatch&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Multiple_dispatch&quot;&gt;여러 디스패치&lt;/a&gt; 를 통해 여러 인수 유형 조합에서 함수 동작을 정의하는 기능</target>
        </trans-unit>
        <trans-unit id="8cbecc736377010eae111d725b15330296dbcf5e" translate="yes" xml:space="preserve">
          <source>The above cross referencing is &lt;em&gt;not&lt;/em&gt; a Markdown feature, and relies on &lt;a href=&quot;https://github.com/JuliaDocs/Documenter.jl&quot;&gt;Documenter.jl&lt;/a&gt;, which is used to build base Julia's documentation.</source>
          <target state="translated">위의 상호 참조는 마크 다운 기능 이 &lt;em&gt;아니며&lt;/em&gt; Julia의 기본 &lt;a href=&quot;https://github.com/JuliaDocs/Documenter.jl&quot;&gt;문서&lt;/a&gt; 를 작성하는 데 사용되는 Documenter.jl에 의존 합니다.</target>
        </trans-unit>
        <trans-unit id="96d64d7232abba83a2151348646c44806eda095b" translate="yes" xml:space="preserve">
          <source>The above mentioned functions can then be used to perform the queries:</source>
          <target state="translated">그런 다음 위에서 언급 한 함수를 사용하여 쿼리를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1864a2a8cdc1de40a1915df6dd632015d943dc9" translate="yes" xml:space="preserve">
          <source>The above results are all &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; values. Literal &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt; values can be entered by writing an &lt;code&gt;f&lt;/code&gt; in place of &lt;code&gt;e&lt;/code&gt;:</source>
          <target state="translated">위의 결과는 모두 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; 값입니다. 리터럴 &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; 값 은 &lt;code&gt;e&lt;/code&gt; 대신 &lt;code&gt;f&lt;/code&gt; 를 써서 입력 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8361f38beb9f62ba5d41300ac34886cea61348b7" translate="yes" xml:space="preserve">
          <source>The above syntactic enhancements significantly reduce the visual noise incurred when writing common mathematical formulae. Note that no whitespace may come between a numeric literal coefficient and the identifier or parenthesized expression which it multiplies.</source>
          <target state="translated">위의 구문 향상은 일반적인 수학 공식을 작성할 때 발생하는 시각적 노이즈를 크게 줄입니다. 숫자 리터럴 계수와 곱하는 식별자 또는 괄호로 묶은 식 사이에는 공백이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="60fe34a8f000c3fae237bc0700dfba4695829533" translate="yes" xml:space="preserve">
          <source>The above would transfer &lt;code&gt;foo&lt;/code&gt; only once to each worker.</source>
          <target state="translated">위의 내용은 각 작업자에게 &lt;code&gt;foo&lt;/code&gt; 를 한 번만 전송 합니다.</target>
        </trans-unit>
        <trans-unit id="b269bbaa9bb906bbb27460a932677dba11288dd6" translate="yes" xml:space="preserve">
          <source>The absolute path &lt;code&gt;REPL.find_hist_file()&lt;/code&gt; of the REPL's history file. If &lt;code&gt;$JULIA_HISTORY&lt;/code&gt; is not set, then &lt;code&gt;REPL.find_hist_file()&lt;/code&gt; defaults to</source>
          <target state="translated">REPL 히스토리 파일 의 절대 경로 &lt;code&gt;REPL.find_hist_file()&lt;/code&gt; . &lt;code&gt;$JULIA_HISTORY&lt;/code&gt; 가 설정되지 않은 경우 &lt;code&gt;REPL.find_hist_file()&lt;/code&gt; 기본값은</target>
        </trans-unit>
        <trans-unit id="3648e183f2c998051f65ea547854578d5a18dead" translate="yes" xml:space="preserve">
          <source>The absolute path of the directory containing the Julia executable, which sets the global variable &lt;a href=&quot;../../base/constants/index#Base.Sys.BINDIR&quot;&gt;&lt;code&gt;Sys.BINDIR&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;$JULIA_BINDIR&lt;/code&gt; is not set, then Julia determines the value &lt;code&gt;Sys.BINDIR&lt;/code&gt; at run-time.</source>
          <target state="translated">글로벌 변수 &lt;a href=&quot;../../base/constants/index#Base.Sys.BINDIR&quot;&gt; &lt;code&gt;Sys.BINDIR&lt;/code&gt; &lt;/a&gt; 을 설정하는 Julia 실행 파일을 포함하는 디렉토리의 절대 경로입니다 . 경우 &lt;code&gt;$JULIA_BINDIR&lt;/code&gt; 설정되어 있지 않은 경우, 줄리아 값 결정 &lt;code&gt;Sys.BINDIR&lt;/code&gt; 실행시입니다.</target>
        </trans-unit>
        <trans-unit id="8927a0d24697e123dd4df5a3afe112eef67df6d2" translate="yes" xml:space="preserve">
          <source>The absolute path of the shell with which Julia should execute external commands (via &lt;code&gt;Base.repl_cmd()&lt;/code&gt;). Defaults to the environment variable &lt;code&gt;$SHELL&lt;/code&gt;, and falls back to &lt;code&gt;/bin/sh&lt;/code&gt; if &lt;code&gt;$SHELL&lt;/code&gt; is unset.</source>
          <target state="translated">Julia가 외부 명령을 실행해야하는 쉘의 절대 경로 ( &lt;code&gt;Base.repl_cmd()&lt;/code&gt; 를 통해 ). 환경 변수 &lt;code&gt;$SHELL&lt;/code&gt; 기본값 이며 &lt;code&gt;$SHELL&lt;/code&gt; 이 설정되어 있지 않으면 &lt;code&gt;/bin/sh&lt;/code&gt; 로 돌아갑니다 .</target>
        </trans-unit>
        <trans-unit id="5eb992db79bc340c73f7d0c78a81caf2c5fb6b5d" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">의 절대 값 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8cc93eeda62c80f4972fdd152957671d0189f643" translate="yes" xml:space="preserve">
          <source>The abstract supertype of all enumerated types defined with &lt;a href=&quot;#Base.Enums.@enum&quot;&gt;&lt;code&gt;@enum&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Base.Enums.@enum&quot;&gt; &lt;code&gt;@enum&lt;/code&gt; 으로&lt;/a&gt; 정의 된 모든 열거 유형의 추상 상위 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="580f4961193cdce395b23ec3d5fef77701e0ce25" translate="yes" xml:space="preserve">
          <source>The actual body of the function is a single &lt;code&gt;leaq&lt;/code&gt; instruction, which computes the integer multiply and add at once. This is even more beneficial when &lt;code&gt;f&lt;/code&gt; gets inlined into another function:</source>
          <target state="translated">함수의 실제 본문은 단일 &lt;code&gt;leaq&lt;/code&gt; 명령어이며, 정수 곱셈을 계산하고 한 번에 더합니다. &lt;code&gt;f&lt;/code&gt; 가 다른 함수에 인라인 될 때 훨씬 더 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="b18e2a05bc75f9cb445304a890f63b9983ea2e1c" translate="yes" xml:space="preserve">
          <source>The actual definition of &lt;code&gt;@assert&lt;/code&gt; in Julia Base is more complicated. It allows the user to optionally specify their own error message, instead of just printing the failed expression. Just like in functions with a variable number of arguments (&lt;a href=&quot;../functions/index#Varargs-Functions-1&quot;&gt;Varargs Functions&lt;/a&gt;), this is specified with an ellipses following the last argument:</source>
          <target state="translated">Julia Base에서 &lt;code&gt;@assert&lt;/code&gt; 의 실제 정의 는 더 복잡합니다. 사용자는 실패한 표현식을 인쇄하는 대신 자체 오류 메시지를 선택적으로 지정할 수 있습니다. 가변 개수의 &lt;a href=&quot;../functions/index#Varargs-Functions-1&quot;&gt;인수가있는 함수&lt;/a&gt; ( Varargs Functions )와 마찬가지로 마지막 인수 다음에 줄임표로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="3249b07e810b7bf455aef815d32c41a4e16eda1a" translate="yes" xml:space="preserve">
          <source>The addition of a &lt;code&gt;Date&lt;/code&gt; with a &lt;code&gt;Time&lt;/code&gt; produces a &lt;code&gt;DateTime&lt;/code&gt;. The hour, minute, second, and millisecond parts of the &lt;code&gt;Time&lt;/code&gt; are used along with the year, month, and day of the &lt;code&gt;Date&lt;/code&gt; to create the new &lt;code&gt;DateTime&lt;/code&gt;. Non-zero microseconds or nanoseconds in the &lt;code&gt;Time&lt;/code&gt; type will result in an &lt;code&gt;InexactError&lt;/code&gt; being thrown.</source>
          <target state="translated">&lt;code&gt;Time&lt;/code&gt; 이있는 &lt;code&gt;Date&lt;/code&gt; 를 추가 하면 &lt;code&gt;DateTime&lt;/code&gt; 이 생성 됩니다. &lt;code&gt;Time&lt;/code&gt; 의시, 분, 초 및 밀리 초 부분은 &lt;code&gt;Date&lt;/code&gt; 의 연도, 월 및 일과 함께 사용되어 새 &lt;code&gt;DateTime&lt;/code&gt; 을 만듭니다 . &lt;code&gt;Time&lt;/code&gt; 유형 에서 0이 아닌 마이크로 초 또는 나노초 는 &lt;code&gt;InexactError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0e0f2aeb81b016f9f8ad15cc7fa177089d4b107f" translate="yes" xml:space="preserve">
          <source>The advantage is that your testing code is now contained in a module and does not use the global scope in &lt;code&gt;Main&lt;/code&gt; for definitions, which is a bit more tidy.</source>
          <target state="translated">장점은 테스트 코드가 이제 모듈에 포함되어 있고 &lt;code&gt;Main&lt;/code&gt; 에 대한 전역 범위 를 정의 에 사용하지 않는다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="f20a70b4f6a41daccbadde162c2965a4719810ba" translate="yes" xml:space="preserve">
          <source>The algorithm returns an estimator of the generative distribution's standard deviation under the assumption that each entry of &lt;code&gt;itr&lt;/code&gt; is an IID drawn from that generative distribution. For arrays, this computation is equivalent to calculating &lt;code&gt;sqrt(sum((itr .- mean(itr)).^2) / (length(itr) - 1))&lt;/code&gt;. If &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then the sum is scaled with &lt;code&gt;n-1&lt;/code&gt;, whereas the sum is scaled with &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; with &lt;code&gt;n&lt;/code&gt; the number of elements in &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">알고리즘은 &lt;code&gt;itr&lt;/code&gt; 의 각 항목이 해당 생성 분포에서 가져온 IID 라는 가정하에 생성 분포 표준 편차의 추정값을 반환합니다 . 배열의 경우이 계산은 &lt;code&gt;sqrt(sum((itr .- mean(itr)).^2) / (length(itr) - 1))&lt;/code&gt; . 경우 &lt;code&gt;corrected&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; , 그 합과 스케일링 &lt;code&gt;n-1&lt;/code&gt; 합계는로 축소되는 반면, &lt;code&gt;n&lt;/code&gt; 경우 &lt;code&gt;corrected&lt;/code&gt; 이다 &lt;code&gt;false&lt;/code&gt; 와 &lt;code&gt;n&lt;/code&gt; 의 원소 개수 &lt;code&gt;itr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5d718f1e39513cb56beb2116bcad02f80b82c53" translate="yes" xml:space="preserve">
          <source>The algorithm returns an estimator of the generative distribution's variance under the assumption that each entry of &lt;code&gt;itr&lt;/code&gt; is an IID drawn from that generative distribution. For arrays, this computation is equivalent to calculating &lt;code&gt;sum((itr .- mean(itr)).^2) / (length(itr) - 1)). If&lt;/code&gt;corrected&lt;code&gt;is&lt;/code&gt;true&lt;code&gt;, then the sum is scaled with&lt;/code&gt;n-1&lt;code&gt;, whereas the sum is scaled with&lt;/code&gt;n&lt;code&gt;if&lt;/code&gt;corrected&lt;code&gt;is&lt;/code&gt;false&lt;code&gt;with&lt;/code&gt;n&lt;code&gt;the number of elements in&lt;/code&gt;itr`.</source>
          <target state="translated">알고리즘은 &lt;code&gt;itr&lt;/code&gt; 의 각 항목이 해당 생성 분포에서 추출한 IID 라는 가정하에 생성 분포 분산의 추정값을 반환합니다 . 배열의 경우이 계산은 &lt;code&gt;sum((itr .- mean(itr)).^2) / (length(itr) - 1)). If&lt;/code&gt; 을 계산하는 것과 같습니다 . 경우 보정이 &lt;code&gt;is&lt;/code&gt; 사실 &lt;code&gt;, then the sum is scaled with&lt;/code&gt; N-1 &lt;code&gt;, whereas the sum is scaled with&lt;/code&gt; N &lt;code&gt;if&lt;/code&gt; 보정 &lt;code&gt;is&lt;/code&gt; 거짓 &lt;code&gt;with&lt;/code&gt; N &lt;code&gt;the number of elements in&lt;/code&gt; itr`.</target>
        </trans-unit>
        <trans-unit id="01293a961a773cd4d130208dbabeea56d0a5c61c" translate="yes" xml:space="preserve">
          <source>The algorithm returns an estimator of the generative distribution's variance under the assumption that each entry of &lt;code&gt;itr&lt;/code&gt; is an IID drawn from that generative distribution. For arrays, this computation is equivalent to calculating &lt;code&gt;sum((itr .- mean(itr)).^2) / (length(itr) - 1)&lt;/code&gt;. If &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then the sum is scaled with &lt;code&gt;n-1&lt;/code&gt;, whereas the sum is scaled with &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; with &lt;code&gt;n&lt;/code&gt; the number of elements in &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">알고리즘은 &lt;code&gt;itr&lt;/code&gt; 의 각 항목이 해당 생성 분포에서 추출한 IID 라는 가정하에 생성 분포 분산의 추정값을 반환합니다 . 배열의 경우이 계산은 &lt;code&gt;sum((itr .- mean(itr)).^2) / (length(itr) - 1)&lt;/code&gt; . 경우 &lt;code&gt;corrected&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; , 그 합과 스케일링 &lt;code&gt;n-1&lt;/code&gt; 합계는로 축소되는 반면, &lt;code&gt;n&lt;/code&gt; 경우 &lt;code&gt;corrected&lt;/code&gt; 이다 &lt;code&gt;false&lt;/code&gt; 와 &lt;code&gt;n&lt;/code&gt; 의 원소 개수 &lt;code&gt;itr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bac2877c35123766a145f522e7dfc5430f0ca77c" translate="yes" xml:space="preserve">
          <source>The analogue of extracting (or &quot;dereferencing&quot;) all elements of a cell array, e.g. in &lt;code&gt;vertcat(A{:})&lt;/code&gt; in MATLAB, is written using the splat operator in Julia, e.g. as &lt;code&gt;vcat(A...)&lt;/code&gt;.</source>
          <target state="translated">셀 배열의 모든 요소 &lt;code&gt;vertcat(A{:})&lt;/code&gt; 예 : MATLAB의 vertcat (A {:})) 를 추출 (또는 &quot;역 참조&quot;)하는 아날로그는 Julia의 splat 연산자를 사용하여 작성됩니다 &lt;code&gt;vcat(A...)&lt;/code&gt; 예 : vcat (A ...)) .</target>
        </trans-unit>
        <trans-unit id="f3f2e21d1a797762aaea13aa49c6c7d374ab6e23" translate="yes" xml:space="preserve">
          <source>The annotation &lt;code&gt;@fastmath&lt;/code&gt; re-arranges floating point expressions, e.g. changing the order of evaluation, or assuming that certain special cases (inf, nan) cannot occur. In this case (and on this particular computer), the main difference is that the expression &lt;code&gt;1 / (2*dx)&lt;/code&gt; in the function &lt;code&gt;deriv&lt;/code&gt; is hoisted out of the loop (i.e. calculated outside the loop), as if one had written &lt;code&gt;idx = 1 / (2*dx)&lt;/code&gt;. In the loop, the expression &lt;code&gt;... / (2*dx)&lt;/code&gt; then becomes &lt;code&gt;... * idx&lt;/code&gt;, which is much faster to evaluate. Of course, both the actual optimization that is applied by the compiler as well as the resulting speedup depend very much on the hardware. You can examine the change in generated code by using Julia's &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.code_native&quot;&gt;&lt;code&gt;code_native&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">주석 &lt;code&gt;@fastmath&lt;/code&gt; 는 평가 순서 변경 또는 특정 특수 사례 (inf, nan)가 발생할 수 없다고 가정하는 등 부동 소수점 표현식을 재 배열합니다. 이 경우 (그리고이 특정 컴퓨터에서) 주요 차이점은 함수 &lt;code&gt;deriv&lt;/code&gt; 의 표현식 &lt;code&gt;1 / (2*dx)&lt;/code&gt; 가 마치 &lt;code&gt;idx = 1 / (2*dx)&lt;/code&gt; 쓴 것처럼 루프 밖으로 들어 갑니다 (즉, 루프 외부에서 계산 됨)입니다. 1 / (2 * dx) . 루프에서 &lt;code&gt;... / (2*dx)&lt;/code&gt; 표현식 은 &lt;code&gt;... * idx&lt;/code&gt; 가됩니다 .평가하는 것이 훨씬 빠릅니다. 물론, 컴파일러가 적용하는 실제 최적화와 결과 속도 향상은 하드웨어에 크게 좌우됩니다. Julia의 &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.code_native&quot;&gt; &lt;code&gt;code_native&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 생성 된 코드의 변경 사항을 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="91407676de179a11323fecebc90b0b28f6220397" translate="yes" xml:space="preserve">
          <source>The application also depends on the &lt;code&gt;Pub&lt;/code&gt; package, which in turn depends on the public &lt;code&gt;Priv&lt;/code&gt; and the same &lt;code&gt;Zebra&lt;/code&gt; package that the private &lt;code&gt;Priv&lt;/code&gt; package depends on.</source>
          <target state="translated">이 응용 프로그램은 &lt;code&gt;Pub&lt;/code&gt; 패키지 에 의존하며 , 이는 공개 &lt;code&gt;Priv&lt;/code&gt; 및 비공개 &lt;code&gt;Priv&lt;/code&gt; 패키지가 의존 하는 것과 동일한 &lt;code&gt;Zebra&lt;/code&gt; 패키지에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="d108508038e64416f7594e79cff0ba0d5c60ed1c" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;A&lt;/code&gt; should &lt;em&gt;not&lt;/em&gt; be a matrix. Rather, instead of matrices it should be a factorization object (e.g. produced by &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt;&lt;code&gt;factorize&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt;&lt;code&gt;cholesky&lt;/code&gt;&lt;/a&gt;). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., &lt;a href=&quot;#LinearAlgebra.lu!&quot;&gt;&lt;code&gt;lu!&lt;/code&gt;&lt;/a&gt;), and performance-critical situations requiring &lt;code&gt;ldiv!&lt;/code&gt; usually also require fine-grained control over the factorization of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">인수 &lt;code&gt;A&lt;/code&gt; 는 행렬 이 &lt;em&gt;아니&lt;/em&gt; 어야합니다 . 오히려, 행렬 대신에 인수 분해 객체가되어야합니다 (예 : &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt; &lt;code&gt;factorize&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt; &lt;code&gt;cholesky&lt;/code&gt; 에&lt;/a&gt; 의해 생성됨 ). 그 이유는 인수 분해 자체가 비싸고 일반적으로 메모리를 할당하기 때문이지만 (예를 들어 &lt;a href=&quot;#LinearAlgebra.lu!&quot;&gt; &lt;code&gt;lu!&lt;/code&gt; 등을&lt;/a&gt; 통해 제자리에서 수행 할 수도 있지만 ) &lt;code&gt;ldiv!&lt;/code&gt; 일반적으로 &lt;code&gt;A&lt;/code&gt; 의 인수 분해에 대한 세밀한 제어가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="8ba5f6815e327ac58578c3c74637303b6ebdc780" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;B&lt;/code&gt; should &lt;em&gt;not&lt;/em&gt; be a matrix. Rather, instead of matrices it should be a factorization object (e.g. produced by &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt;&lt;code&gt;factorize&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt;&lt;code&gt;cholesky&lt;/code&gt;&lt;/a&gt;). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., &lt;a href=&quot;#LinearAlgebra.lu!&quot;&gt;&lt;code&gt;lu!&lt;/code&gt;&lt;/a&gt;), and performance-critical situations requiring &lt;code&gt;rdiv!&lt;/code&gt; usually also require fine-grained control over the factorization of &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">인수 &lt;code&gt;B&lt;/code&gt; 는 행렬 이 &lt;em&gt;아니&lt;/em&gt; 어야합니다 . 오히려, 행렬 대신에 인수 분해 객체가되어야합니다 (예 : &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt; &lt;code&gt;factorize&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt; &lt;code&gt;cholesky&lt;/code&gt; 에&lt;/a&gt; 의해 생성됨 ). 그 이유는 인수 분해 자체가 비싸고 일반적으로 메모리를 할당하기 때문이지만 (예를 들어 &lt;a href=&quot;#LinearAlgebra.lu!&quot;&gt; &lt;code&gt;lu!&lt;/code&gt; 등을&lt;/a&gt; 통해 제자리에서 수행 할 수도 있지만 ) &lt;code&gt;rdiv!&lt;/code&gt; 일반적으로 &lt;code&gt;B&lt;/code&gt; 의 인수 분해에 대한 세밀한 제어가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="f6947ba42284e98465ca0fe899c7260684fa80d0" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;__module__&lt;/code&gt; provides information (in the form of a &lt;code&gt;Module&lt;/code&gt; object) about the expansion context of the macro invocation. This allows macros to look up contextual information, such as existing bindings, or to insert the value as an extra argument to a runtime function call doing self-reflection in the current module.</source>
          <target state="translated">&lt;code&gt;__module__&lt;/code&gt; 인수 는 매크로 호출의 확장 컨텍스트에 대한 정보를 ( &lt;code&gt;Module&lt;/code&gt; 객체 의 형태로) 제공합니다 . 이를 통해 매크로는 기존 바인딩과 같은 컨텍스트 정보를 찾거나 현재 모듈에서 자체 반사를 수행하는 런타임 함수 호출에 추가 인수로 값을 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="118cff9af4b8de3b0527244748b6b6cdd9ccdeb6" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;__source__&lt;/code&gt; provides information (in the form of a &lt;code&gt;LineNumberNode&lt;/code&gt; object) about the parser location of the &lt;code&gt;@&lt;/code&gt; sign from the macro invocation. This allows macros to include better error diagnostic information, and is commonly used by logging, string-parser macros, and docs, for example, as well as to implement the &lt;a href=&quot;../../base/file/index#Base.@__LINE__&quot;&gt;&lt;code&gt;@__LINE__&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/file/index#Base.@__FILE__&quot;&gt;&lt;code&gt;@__FILE__&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/file/index#Base.@__DIR__&quot;&gt;&lt;code&gt;@__DIR__&lt;/code&gt;&lt;/a&gt; macros.</source>
          <target state="translated">&lt;code&gt;__source__&lt;/code&gt; 인수 는 매크로 호출에서 &lt;code&gt;@&lt;/code&gt; 부호 의 구문 분석기 위치에 대한 정보 ( &lt;code&gt;LineNumberNode&lt;/code&gt; 오브젝트 양식 )를 제공합니다 . 이를 통해 매크로는 더 나은 오류 진단 정보를 포함 할 수 있으며, &lt;a href=&quot;../../base/file/index#Base.@__LINE__&quot;&gt; &lt;code&gt;@__LINE__&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/file/index#Base.@__FILE__&quot;&gt; &lt;code&gt;@__FILE__&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/file/index#Base.@__DIR__&quot;&gt; &lt;code&gt;@__DIR__&lt;/code&gt; &lt;/a&gt; 매크로 를 구현할뿐만 아니라 로깅, 문자열 파서 매크로 및 문서 등에서 일반적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="28332afec21b48c8f9eedddb529063711d48dde4" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;val&lt;/code&gt; to a function or constructor is outside the valid domain.</source>
          <target state="translated">함수 또는 생성자에 대한 인수 &lt;code&gt;val&lt;/code&gt; 이 유효한 도메인 외부에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5eb1e5a4cdcda6110ebd89f0ecb14ceede7e9cb" translate="yes" xml:space="preserve">
          <source>The argument goes on the &lt;em&gt;left&lt;/em&gt; side of a matrix-matrix operation.</source>
          <target state="translated">인수는 행렬-행렬 연산 의 &lt;em&gt;왼쪽&lt;/em&gt; 에서 진행됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b59a99385d1b11a2ad5b866d4ec7b5957c8ab4c" translate="yes" xml:space="preserve">
          <source>The argument goes on the &lt;em&gt;right&lt;/em&gt; side of a matrix-matrix operation.</source>
          <target state="translated">인수는 행렬-행렬 연산 의 &lt;em&gt;오른쪽&lt;/em&gt; 에서 진행됩니다 .</target>
        </trans-unit>
        <trans-unit id="884d75c174d0479198ef02863fa90299587b8335" translate="yes" xml:space="preserve">
          <source>The array data must be represented in binary format (e.g., an ASCII format like CSV cannot be supported)</source>
          <target state="translated">배열 데이터는 이진 형식으로 표시되어야합니다 (예 : CSV와 같은 ASCII 형식은 지원할 수 없음)</target>
        </trans-unit>
        <trans-unit id="b10872dab02eb4daf575beb40c2f7b4e9635a0b7" translate="yes" xml:space="preserve">
          <source>The asserted condition did not evaluate to &lt;code&gt;true&lt;/code&gt;. Optional argument &lt;code&gt;msg&lt;/code&gt; is a descriptive error string.</source>
          <target state="translated">주장 된 조건은 &lt;code&gt;true&lt;/code&gt; 로 평가되지 않았습니다 . 선택적 인수 &lt;code&gt;msg&lt;/code&gt; 는 설명 오류 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="9ef046749eb00971a20635012815c9aa3fe8e4de" translate="yes" xml:space="preserve">
          <source>The assignments are evaluated in order, with each right-hand side evaluated in the scope before the new variable on the left-hand side has been introduced. Therefore it makes sense to write something like &lt;code&gt;let x = x&lt;/code&gt; since the two &lt;code&gt;x&lt;/code&gt; variables are distinct and have separate storage. Here is an example where the behavior of &lt;code&gt;let&lt;/code&gt; is needed:</source>
          <target state="translated">할당은 순서대로 평가되며 왼쪽에 새 변수가 도입되기 전에 범위에서 각 오른쪽이 평가됩니다. 따라서 두 &lt;code&gt;x&lt;/code&gt; 변수가 서로 다르고 별도의 저장 공간이 있기 때문에 &lt;code&gt;let x = x&lt;/code&gt; 와 같은 것을 작성하는 것이 좋습니다. &lt;code&gt;let&lt;/code&gt; 의 동작 이 필요한 예는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="332e2ebabecf595b9a10dedb9752fafc32737dcf" translate="yes" xml:space="preserve">
          <source>The assignments are evaluated in order, with each right-hand side evaluated in the scope before the new variable on the left-hand side has been introduced. Therefore it makes sense to write something like &lt;code&gt;let x = x&lt;/code&gt;, since the two &lt;code&gt;x&lt;/code&gt; variables are distinct and have separate storage.</source>
          <target state="translated">할당은 순서대로 평가되며 왼쪽에 새 변수가 도입되기 전에 범위에서 각 오른쪽이 평가됩니다. 따라서 두 &lt;code&gt;x&lt;/code&gt; 변수는 별개이며 별도의 저장 공간이 있기 때문에 &lt;code&gt;let x = x&lt;/code&gt; 와 같은 것을 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="cb5c5acb0ed1217a3a242c8796f09db063ffe31c" translate="yes" xml:space="preserve">
          <source>The associativity of the reduction is implementation dependent. This means that you can't use non-associative operations like &lt;code&gt;-&lt;/code&gt; because it is undefined whether &lt;code&gt;reduce(-,[1,2,3])&lt;/code&gt; should be evaluated as &lt;code&gt;(1-2)-3&lt;/code&gt; or &lt;code&gt;1-(2-3)&lt;/code&gt;. Use &lt;a href=&quot;#Base.foldl-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;foldl&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.foldr-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;foldr&lt;/code&gt;&lt;/a&gt; instead for guaranteed left or right associativity.</source>
          <target state="translated">축소의 연관성은 구현에 따라 다릅니다. 원하는 비 연관 동작을 사용할 수 없다는 것을 의미이 &lt;code&gt;-&lt;/code&gt; 가 정의되지 않기 때문에 여부 &lt;code&gt;reduce(-,[1,2,3])&lt;/code&gt; 으로 평가한다 &lt;code&gt;(1-2)-3&lt;/code&gt; 또는 &lt;code&gt;1-(2-3)&lt;/code&gt; . 왼쪽 또는 오른쪽의 연관성을 보장 하려면 &lt;a href=&quot;#Base.foldl-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;foldl&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#Base.foldr-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;foldr&lt;/code&gt; 를&lt;/a&gt; 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="8e83411f941380eef1e4e97a62a5d00092492f0f" translate="yes" xml:space="preserve">
          <source>The associativity of the reduction is implementation-dependent. Additionally, some implementations may reuse the return value of &lt;code&gt;f&lt;/code&gt; for elements that appear multiple times in &lt;code&gt;itr&lt;/code&gt;. Use &lt;a href=&quot;#Base.mapfoldl-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;mapfoldl&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.mapfoldr-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;mapfoldr&lt;/code&gt;&lt;/a&gt; instead for guaranteed left or right associativity and invocation of &lt;code&gt;f&lt;/code&gt; for every value.</source>
          <target state="translated">축소의 연관성은 구현에 따라 다릅니다. 또한 일부 구현 에서는 &lt;code&gt;itr&lt;/code&gt; 에 여러 번 나타나는 요소에 대해 &lt;code&gt;f&lt;/code&gt; 의 반환 값을 재사용 할 수 있습니다 . 모든 값에 대해 왼쪽 또는 오른쪽 연관성을 보장하고 &lt;code&gt;f&lt;/code&gt; 를 호출 하려면 &lt;a href=&quot;#Base.mapfoldl-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;mapfoldl&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#Base.mapfoldr-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;mapfoldr&lt;/code&gt; 을&lt;/a&gt; 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fa2ffdac4b6b173468c64bdf00df48adef8f3782" translate="yes" xml:space="preserve">
          <source>The available color keys can be seen by typing &lt;code&gt;Base.text_colors&lt;/code&gt; in the help mode of the REPL. In addition, the integers 0 to 255 can be used as color keys for terminals with 256 color support.</source>
          <target state="translated">REPL의 도움말 모드에서 &lt;code&gt;Base.text_colors&lt;/code&gt; 를 입력 하면 사용 가능한 색상 키를 볼 수 있습니다 . 또한 0에서 255까지의 정수는 256 색을 지원하는 터미널의 색상 키로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6514960ce535f34b9eb969fcb1b4f9c39742102" translate="yes" xml:space="preserve">
          <source>The base Julia installation has in-built support for two types of clusters:</source>
          <target state="translated">기본 Julia 설치는 두 가지 유형의 클러스터를 기본적으로 지원합니다.</target>
        </trans-unit>
        <trans-unit id="562f643f12db492fbdb1e985351909d826402fa4" translate="yes" xml:space="preserve">
          <source>The base Julia runtime provides only plain-text display, but richer displays may be enabled by loading external modules or by using graphical Julia environments (such as the IPython-based IJulia notebook).</source>
          <target state="translated">기본 Julia 런타임은 일반 텍스트 디스플레이 만 제공하지만 외부 모듈을로드하거나 그래픽 Julia 환경 (예 : IPython 기반 IJulia 노트북)을 사용하여 더 풍부한 디스플레이를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="002dc05c0d427615b628a5faca800a873b359de7" translate="yes" xml:space="preserve">
          <source>The base array type in Julia is the abstract type &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray{T,N}&lt;/code&gt;&lt;/a&gt;. It is parameterized by the number of dimensions &lt;code&gt;N&lt;/code&gt; and the element type &lt;code&gt;T&lt;/code&gt;. &lt;a href=&quot;../../base/arrays/index#Base.AbstractVector&quot;&gt;&lt;code&gt;AbstractVector&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/arrays/index#Base.AbstractMatrix&quot;&gt;&lt;code&gt;AbstractMatrix&lt;/code&gt;&lt;/a&gt; are aliases for the 1-d and 2-d cases. Operations on &lt;code&gt;AbstractArray&lt;/code&gt; objects are defined using higher level operators and functions, in a way that is independent of the underlying storage. These operations generally work correctly as a fallback for any specific array implementation.</source>
          <target state="translated">Julia의 기본 배열 유형은 추상 유형 &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray{T,N}&lt;/code&gt; &lt;/a&gt; 입니다. 치수 수 &lt;code&gt;N&lt;/code&gt; 및 요소 유형 &lt;code&gt;T&lt;/code&gt; 로 매개 변수화됩니다 . &lt;a href=&quot;../../base/arrays/index#Base.AbstractVector&quot;&gt; &lt;code&gt;AbstractVector&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/arrays/index#Base.AbstractMatrix&quot;&gt; &lt;code&gt;AbstractMatrix&lt;/code&gt; &lt;/a&gt; 는 1-d 및 2-d 사례의 별칭입니다. &lt;code&gt;AbstractArray&lt;/code&gt; 객체 에 대한 작업 은 기본 저장소와 독립적 인 방식으로 더 높은 수준의 연산자와 함수를 사용하여 정의됩니다. 이러한 작업은 일반적으로 특정 어레이 구현의 대체로 올바르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b29d93a344c231f0373e8777552dd842d0c0ae6b" translate="yes" xml:space="preserve">
          <source>The base library of Julia. &lt;code&gt;Base&lt;/code&gt; is a module that contains basic functionality (the contents of &lt;code&gt;base/&lt;/code&gt;). All modules implicitly contain &lt;code&gt;using Base&lt;/code&gt;, since this is needed in the vast majority of cases.</source>
          <target state="translated">Julia의 기본 라이브러리. &lt;code&gt;Base&lt;/code&gt; 는 기본 기능 ( &lt;code&gt;base/&lt;/code&gt; 의 내용)을 포함하는 모듈입니다 . 대부분의 경우에 필요하기 때문에 모든 모듈에 암시 적으로 &lt;code&gt;using Base&lt;/code&gt; 이 포함 됩니다 .</target>
        </trans-unit>
        <trans-unit id="f9d1c85fa2408916e8a238b5528b77d6327d21e9" translate="yes" xml:space="preserve">
          <source>The basic function for waiting for an event is &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;. Several objects implement &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;; for example, given a &lt;code&gt;Process&lt;/code&gt; object, &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; will wait for it to exit. &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; is often implicit; for example, a &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; can happen inside a call to &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; to wait for data to be available.</source>
          <target state="translated">이벤트 대기를위한 기본 기능은 &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 입니다. 여러 객체가 &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 구현합니다 . 예를 들어, 특정 &lt;code&gt;Process&lt;/code&gt; 객체, &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 이 종료 기다립니다. &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 는 종종 암시 적입니다. 예를 들어, &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 를 호출 내에서 발생할 수 &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 데이터를 사용할 수있을 때까지 기다릴.</target>
        </trans-unit>
        <trans-unit id="38afa5a3f5d12c0c2e4c45c469ff70f9f6584c66" translate="yes" xml:space="preserve">
          <source>The basic syntax is simple: any string appearing at the top-level right before an object (function, macro, type or instance) will be interpreted as documenting it (these are called &lt;em&gt;docstrings&lt;/em&gt;). Note that no blank lines or comments may intervene between a docstring and the documented object. Here is a basic example:</source>
          <target state="translated">기본 구문은 간단합니다. 객체 (함수, 매크로, 유형 또는 인스턴스) 바로 앞에 최상위 문자열에 나타나는 모든 문자열은이를 문서화하는 것으로 해석됩니다 ( &lt;em&gt;docstrings&lt;/em&gt; 라고 함 ). 빈 줄이나 주석은 docstring과 문서화 된 객체 사이에 개입 할 수 없습니다. 기본 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3e6788f6ee76ef14250b1c48634160dc28850751" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;missing&lt;/code&gt; values follows one basic rule: &lt;code&gt;missing&lt;/code&gt; values &lt;em&gt;propagate&lt;/em&gt; automatically when passed to standard operators and functions, in particular mathematical functions. Uncertainty about the value of one of the operands induces uncertainty about the result. In practice, this means an operation involving a &lt;code&gt;missing&lt;/code&gt; value generally returns &lt;code&gt;missing&lt;/code&gt;</source>
          <target state="translated">의 동작 &lt;code&gt;missing&lt;/code&gt; 값은 하나의 기본 규칙을 다음과 &lt;code&gt;missing&lt;/code&gt; 값이 &lt;em&gt;전파&lt;/em&gt; 특히 수학 함수 표준 연산자와 함수에 전달 될 때 자동으로. 피연산자 중 하나의 값에 대한 불확실성은 결과에 대한 불확실성을 유발합니다. 실제로 이는 결 &lt;code&gt;missing&lt;/code&gt; 관련된 연산이 일반적으로 결 &lt;code&gt;missing&lt;/code&gt; 반환 함을 의미</target>
        </trans-unit>
        <trans-unit id="a7e648e6d6c87b02acc6c1db84cf592e9a9a93a8" translate="yes" xml:space="preserve">
          <source>The behavior of the logical &quot;and&quot; operator &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt; is similar to that of the &lt;code&gt;|&lt;/code&gt; operator, with the difference that missingness does not propagate when one of the operands is &lt;code&gt;false&lt;/code&gt;. For example, when that is the case of the first operand</source>
          <target state="translated">연산자 논리 &quot;와&quot;의 동작 &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;/a&gt; 의 것과 유사 &lt;code&gt;|&lt;/code&gt; 피연산자 중 하나가 &lt;code&gt;false&lt;/code&gt; 인 경우 누락이 전파되지 않는다는 차이점이 있습니다. 예를 들어, 첫 번째 피연산자의 경우</target>
        </trans-unit>
        <trans-unit id="7b67ccc64e36fcf07f7c05aa43c8c2a633077f18" translate="yes" xml:space="preserve">
          <source>The best approach is to avoid defining &lt;em&gt;either&lt;/em&gt; of these methods: instead, rely on a generic method &lt;code&gt;-(A::AbstractArray, b)&lt;/code&gt; and make sure this method is implemented with generic calls (like &lt;code&gt;similar&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt;) that do the right thing for each container type and element type &lt;em&gt;separately&lt;/em&gt;. This is just a more complex variant of the advice to &lt;a href=&quot;#man-methods-orthogonalize-1&quot;&gt;orthogonalize&lt;/a&gt; your methods.</source>
          <target state="translated">가장 좋은 방법은 정의하지 않는 것입니다 &lt;em&gt;중 하나&lt;/em&gt; 대신, 일반적인 방법에 의존 : 이러한 방법으로 &lt;code&gt;-(A::AbstractArray, b)&lt;/code&gt; 와 (같은 확인이 방법은 일반 전화로 구현되어 있는지 확인 &lt;code&gt;similar&lt;/code&gt; 및 &lt;code&gt;-&lt;/code&gt; )에 대한 옳은 일을하는 각 컨테이너 유형 및 요소 유형은 &lt;em&gt;개별적으로&lt;/em&gt; . 이것은 방법 을 &lt;a href=&quot;#man-methods-orthogonalize-1&quot;&gt;직교 화&lt;/a&gt; 하기 위한 조언의 좀 더 복잡한 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="d958f10307af7b028b81ab80b4d640f64af23b08" translate="yes" xml:space="preserve">
          <source>The better design would be to define your call hierarchy like this:</source>
          <target state="translated">더 나은 디자인은 다음과 같이 호출 계층을 정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3983e66c166493bdb9b9e27ea74aedeb9d2d8cf1" translate="yes" xml:space="preserve">
          <source>The biggest advantage of &lt;code&gt;advection_shared!&lt;/code&gt; is that it minimizes traffic among the workers, allowing each to compute for an extended time on the assigned piece.</source>
          <target state="translated">&lt;code&gt;advection_shared!&lt;/code&gt; 의 가장 큰 장점 ! 이는 작업자 간의 트래픽을 최소화하여 각 직원이 할당 된 부분에서 연장 된 시간 동안 계산할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="194659e7083e920d17f0c59327a653e32e8cfe4a" translate="yes" xml:space="preserve">
          <source>The binary operator &lt;code&gt;&amp;asymp;&lt;/code&gt; is equivalent to &lt;code&gt;isapprox&lt;/code&gt; with the default arguments, and &lt;code&gt;x ≉ y&lt;/code&gt; is equivalent to &lt;code&gt;!isapprox(x,y)&lt;/code&gt;.</source>
          <target state="translated">이항 연산자 &lt;code&gt;&amp;asymp;&lt;/code&gt; 는 기본 인수 를 사용하여 &lt;code&gt;isapprox&lt;/code&gt; 와 &lt;code&gt;x ≉ y&lt;/code&gt; 으며 x ≉ y 는 &lt;code&gt;!isapprox(x,y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ba294c6e25bcc46b7feed1d1a73c0b3e0ef49e3" translate="yes" xml:space="preserve">
          <source>The blank lines actually have spaces on them. Fortunately, the above awkward idiom is unnecessary for iterating through the characters in a string, since you can just use the string as an iterable object, no exception handling required:</source>
          <target state="translated">빈 줄에는 실제로 공백이 있습니다. 다행스럽게도 위의 어색한 관용구는 문자열의 문자를 반복하는 데 필요하지 않습니다. 문자열을 반복 가능한 객체로 사용할 수 있으며 예외 처리가 필요하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="586252847b0a965d3d0a5b40259b311ee19d7146" translate="yes" xml:space="preserve">
          <source>The broadcast style is computed for every broadcasting operation to allow for dispatch and specialization. The actual allocation of the result array is handled by &lt;code&gt;similar&lt;/code&gt;, using the Broadcasted object as its first argument.</source>
          <target state="translated">방송 스타일은 모든 방송 작업에 대해 계산되어 발송 및 전문화가 가능합니다. 결과 배열의 실제 할당은 Broadcasted 객체를 첫 번째 인수로 사용하여 &lt;code&gt;similar&lt;/code&gt; 에 의해 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="5232abbd2579e189a3c4536c48fbc58adcc52edd" translate="yes" xml:space="preserve">
          <source>The built-in concrete type used for strings (and string literals) in Julia is &lt;code&gt;String&lt;/code&gt;. This supports the full range of &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode&quot;&gt;Unicode&lt;/a&gt; characters via the &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt; encoding. (A &lt;a href=&quot;../../base/strings/index#Base.transcode&quot;&gt;&lt;code&gt;transcode&lt;/code&gt;&lt;/a&gt; function is provided to convert to/from other Unicode encodings.)</source>
          <target state="translated">Julia에서 문자열 (및 문자열 리터럴)에 사용되는 내장 콘크리트 유형은 &lt;code&gt;String&lt;/code&gt; 입니다. &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt; 인코딩을 통해 모든 범위의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode&quot;&gt;유니 코드&lt;/a&gt; 문자를 지원합니다 . ( 다른 유니 코드 인코딩과의 변환을 위해 &lt;a href=&quot;../../base/strings/index#Base.transcode&quot;&gt; &lt;code&gt;transcode&lt;/code&gt; &lt;/a&gt; 기능이 제공됩니다.)</target>
        </trans-unit>
        <trans-unit id="dc25d16dd1aba7b0c5bea6b12ba6118124030ae4" translate="yes" xml:space="preserve">
          <source>The byte offset of field &lt;code&gt;i&lt;/code&gt; of a type relative to the data start. For example, we could use it in the following manner to summarize information about a struct:</source>
          <target state="translated">데이터 시작에 상대적인 유형 의 필드 &lt;code&gt;i&lt;/code&gt; 의 바이트 오프셋 . 예를 들어, 구조체에 대한 정보를 요약하기 위해 다음과 같은 방식으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df22a65b46868ee938e0477154f053724ad2e34c" translate="yes" xml:space="preserve">
          <source>The callback you pass to C should only execute a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;:uv_async_send&lt;/code&gt;, passing &lt;code&gt;cond.handle&lt;/code&gt; as the argument, taking care to avoid any allocations or other interactions with the Julia runtime.</source>
          <target state="translated">당신이 C에 전달하는 콜백 만 실행해야 &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; 을&lt;/a&gt; 에 &lt;code&gt;:uv_async_send&lt;/code&gt; 전달 &lt;code&gt;cond.handle&lt;/code&gt; 을 줄리아 런타임 어떤 할당 또는 기타 상호 작용을 방지하기 위해주의하면서 인수로.</target>
        </trans-unit>
        <trans-unit id="b1e65b00ae78a0300e89eb33901bc2c6dff08184" translate="yes" xml:space="preserve">
          <source>The caller must be holding the &lt;a href=&quot;#Base.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; that owns &lt;code&gt;c&lt;/code&gt; before calling this method. The calling task will be blocked until some other task wakes it, usually by calling &lt;a href=&quot;#Base.notify&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt;` on the same Condition object. The lock will be atomically released when blocking (even if it was locked recursively), and will be reacquired before returning.</source>
          <target state="translated">이 메소드를 호출하기 전에 호출자는 &lt;code&gt;c&lt;/code&gt; 를 소유 한 &lt;a href=&quot;#Base.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; 을 보유하고 있어야합니다 . 호출하는 작업은 다른 작업이 깨어날 때까지 차단되며 일반적으로 동일한 Condition 객체에서 &lt;a href=&quot;#Base.notify&quot;&gt; &lt;code&gt;notify&lt;/code&gt; `&lt;/a&gt; 를 호출하여 차단됩니다 . 잠금은 재귀 적으로 잠긴 경우에도 차단할 때 원자 적으로 해제되며 돌아 오기 전에 다시 확보됩니다.</target>
        </trans-unit>
        <trans-unit id="b9769cfc324c619140bf4882f569b4d5be45feda" translate="yes" xml:space="preserve">
          <source>The case of &lt;code&gt;rand&lt;/code&gt; is a bit more complex as we have to ensure that each thread uses non-overlapping pseudorandom number sequences. This can be simply ensured by using &lt;code&gt;Future.randjump&lt;/code&gt; function:</source>
          <target state="translated">&lt;code&gt;rand&lt;/code&gt; 의 경우 각 스레드가 겹치지 않는 의사 난수 시퀀스를 사용하도록해야하기 때문에 좀 더 복잡합니다. &lt;code&gt;Future.randjump&lt;/code&gt; 함수 를 사용하여 간단히 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5555fa452d0454119cd31b5aa3d13eec12b96796" translate="yes" xml:space="preserve">
          <source>The channels example from above can be modified for interprocess communication, as shown below.</source>
          <target state="translated">위의 채널 예는 아래와 같이 프로세스 간 통신을 위해 수정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89b722bb0d4e7814b2f6957c408ca31cc4584902" translate="yes" xml:space="preserve">
          <source>The choice of which method to execute when a function is applied is called &lt;em&gt;dispatch&lt;/em&gt;. Julia allows the dispatch process to choose which of a function's methods to call based on the number of arguments given, and on the types of all of the function's arguments. This is different than traditional object-oriented languages, where dispatch occurs based only on the first argument, which often has a special argument syntax, and is sometimes implied rather than explicitly written as an argument. &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt; Using all of a function's arguments to choose which method should be invoked, rather than just the first, is known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiple_dispatch&quot;&gt;multiple dispatch&lt;/a&gt;. Multiple dispatch is particularly useful for mathematical code, where it makes little sense to artificially deem the operations to &quot;belong&quot; to one argument more than any of the others: does the addition operation in &lt;code&gt;x + y&lt;/code&gt; belong to &lt;code&gt;x&lt;/code&gt; any more than it does to &lt;code&gt;y&lt;/code&gt;? The implementation of a mathematical operator generally depends on the types of all of its arguments. Even beyond mathematical operations, however, multiple dispatch ends up being a powerful and convenient paradigm for structuring and organizing programs.</source>
          <target state="translated">함수가 적용될 때 실행할 메소드 선택을 &lt;em&gt;dispatch&lt;/em&gt; 라고 합니다. Julia는 디스패치 프로세스가 주어진 인수 수와 모든 함수 인수 유형에 따라 호출 할 함수 메소드를 선택할 수 있도록합니다. 이것은 일반적인 객체 지향 언어와 다릅니다. 디스패치는 종종 특별한 인수 구문을 갖는 첫 번째 인수만을 기반으로하며 때로는 명시 적으로 인수로 쓰여지기보다는 암시됩니다. &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt; 모든 함수의 인수를 사용하여 첫 번째가 아닌 호출 할 메소드를 선택하는 것을 &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiple_dispatch&quot;&gt;다중 디스패치라고합니다.&lt;/a&gt;. 다중 디스패치는 수학 코드에 특히 유용합니다. 여기서는 연산이 다른 인수보다 하나의 인수에 &quot;연속적으로&quot;있다고 인위적으로 간주하는 것이별로 의미가 없습니다. &lt;code&gt;x + y&lt;/code&gt; 의 덧셈 연산이 수행 하는 것보다 &lt;code&gt;x&lt;/code&gt; 에 속합니까? &lt;code&gt;y&lt;/code&gt; ? 수학 연산자의 구현은 일반적으로 모든 인수의 유형에 따라 다릅니다. 그러나 수학적 연산 이외에도 다중 디스패치는 프로그램을 구성하고 구성하기위한 강력하고 편리한 패러다임이됩니다.</target>
        </trans-unit>
        <trans-unit id="810842d6186800c0a575092bdf409289f500ddec" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;x-&amp;gt;x&lt;/code&gt; carries a reference to &lt;code&gt;Foo&lt;/code&gt;, and since &lt;code&gt;Foo&lt;/code&gt; is unavailable on node 2, an &lt;code&gt;UndefVarError&lt;/code&gt; is thrown.</source>
          <target state="translated">폐쇄 &lt;code&gt;x-&amp;gt;x&lt;/code&gt; 참조 실시 &lt;code&gt;Foo&lt;/code&gt; , 이후 &lt;code&gt;Foo&lt;/code&gt; 노드 2 불가능, &lt;code&gt;UndefVarError&lt;/code&gt; 가 발생된다.</target>
        </trans-unit>
        <trans-unit id="fd31f7bc6251a511018cdc2ef8ff1b65e61abb04" translate="yes" xml:space="preserve">
          <source>The cluster manager captures the &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; of each worker and makes it available to the master process.</source>
          <target state="translated">클러스터 관리자는 각 작업자 의 &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; 을 캡처 하여 마스터 프로세스에서 사용할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="56c5bc198a3439c620845fc2e6da1bcc9a273974" translate="yes" xml:space="preserve">
          <source>The code to be called must be available as a shared library. Most C and Fortran libraries ship compiled as shared libraries already, but if you are compiling the code yourself using GCC (or Clang), you will need to use the &lt;code&gt;-shared&lt;/code&gt; and &lt;code&gt;-fPIC&lt;/code&gt; options. The machine instructions generated by Julia's JIT are the same as a native C call would be, so the resulting overhead is the same as calling a library function from C code. (Non-library function calls in both C and Julia can be inlined and thus may have even less overhead than calls to shared library functions. When both libraries and executables are generated by LLVM, it is possible to perform whole-program optimizations that can even optimize across this boundary, but Julia does not yet support that. In the future, however, it may do so, yielding even greater performance gains.)</source>
          <target state="translated">호출 할 코드는 공유 라이브러리로 사용 가능해야합니다. 대부분의 C 및 Fortran 라이브러리는 이미 공유 라이브러리로 컴파일되어 제공되지만 GCC (또는 Clang)를 사용하여 직접 코드를 컴파일하는 경우 &lt;code&gt;-shared&lt;/code&gt; 및 &lt;code&gt;-fPIC&lt;/code&gt; 을 사용해야합니다.옵션. Julia의 JIT에 의해 생성 된 기계 명령어는 네이티브 C 호출과 동일하므로 결과 오버 헤드는 C 코드에서 라이브러리 함수를 호출하는 것과 같습니다. (C와 Julia의 비 라이브러리 함수 호출은 인라인 될 수 있으므로 공유 라이브러리 함수 호출보다 오버 헤드가 훨씬 적을 수 있습니다. LLVM에서 라이브러리와 실행 파일을 모두 생성하면 전체 프로그램 최적화를 수행 할 수 있습니다. Julia는이 경계를 넘어 최적화하지만 아직이를 지원하지는 않지만 앞으로는 더 큰 성능 향상을 가져올 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="98f830d6caf7ed0451c6b75d05afceaf2e516b19" translate="yes" xml:space="preserve">
          <source>The collection must not be empty.</source>
          <target state="translated">컬렉션은 비워 둘 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b1b1444de74c16e81499ba99fc21db058cdbcd70" translate="yes" xml:space="preserve">
          <source>The colors used by Julia and the REPL can be customized, as well. To change the color of the Julia prompt you can add something like the following to your &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; file, which is to be placed inside your home directory:</source>
          <target state="translated">Julia와 REPL이 사용하는 색상도 사용자 정의 할 수 있습니다. Julia 프롬프트의 색상을 변경하려면 &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; 파일에 다음과 같은 것을 추가하면 홈 디렉토리에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="6ae3351e931cdaf68574bd5908ad25710f928fca" translate="yes" xml:space="preserve">
          <source>The columns are assumed to be separated by one or more whitespaces. The end of line delimiter is taken as &lt;code&gt;\n&lt;/code&gt;.</source>
          <target state="translated">열은 하나 이상의 공백으로 분리되어 있다고 가정합니다. 줄 끝 구분 기호는 &lt;code&gt;\n&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b166229d69582696f7886d8f6669f9f89c33f90c" translate="yes" xml:space="preserve">
          <source>The columns are assumed to be separated by one or more whitespaces. The end of line delimiter is taken as &lt;code&gt;\n&lt;/code&gt;. If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.</source>
          <target state="translated">열은 하나 이상의 공백으로 분리되어 있다고 가정합니다. 줄 끝 구분 기호는 &lt;code&gt;\n&lt;/code&gt; 입니다. 모든 데이터가 숫자이면 결과는 숫자 배열이됩니다. 일부 요소를 숫자로 구문 분석 할 수없는 경우 이기종 배열의 숫자와 문자열이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="c128fcb09c50ebb22346ed7e858f0e921632da46" translate="yes" xml:space="preserve">
          <source>The combination of a high-level programming language, a first-class command abstraction, and automatic setup of pipes between processes is a powerful one. To give some sense of the complex pipelines that can be created easily, here are some more sophisticated examples, with apologies for the excessive use of Perl one-liners:</source>
          <target state="translated">고급 프로그래밍 언어, 일류 명령 추상화 및 프로세스 간 파이프 자동 설정의 조합은 강력한 기능입니다. 쉽게 만들 수있는 복잡한 파이프 라인을 이해하기 위해 Perl one-liner를 과도하게 사용하는 것에 대한 사과와 함께보다 정교한 예제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a7191f54d1d0a0057ae059656a933d9b6a26e58" translate="yes" xml:space="preserve">
          <source>The command is never run with a shell. Instead, Julia parses the command syntax directly, appropriately interpolating variables and splitting on words as the shell would, respecting shell quoting syntax. The command is run as &lt;code&gt;julia&lt;/code&gt;'s immediate child process, using &lt;code&gt;fork&lt;/code&gt; and &lt;code&gt;exec&lt;/code&gt; calls.</source>
          <target state="translated">이 명령은 쉘로 실행되지 않습니다. 대신 Julia는 명령 구문을 직접 구문 분석하여 쉘 인용 구문을 고려하여 변수를 적절하게 보간하고 쉘처럼 단어를 분할합니다. 이 명령은 &lt;code&gt;fork&lt;/code&gt; 및 &lt;code&gt;exec&lt;/code&gt; 호출을 사용하여 &lt;code&gt;julia&lt;/code&gt; 의 즉각적인 자식 프로세스 로 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a0dcc8c9826601bed0e074d703f3ff7a640f8d1" translate="yes" xml:space="preserve">
          <source>The common idiom of using 1:n to index into an AbstractArray is not safe if the Array uses unconventional indexing, and may cause a segmentation fault if bounds checking is turned off. Use &lt;code&gt;LinearIndices(x)&lt;/code&gt; or &lt;code&gt;eachindex(x)&lt;/code&gt; instead (see also &lt;a href=&quot;https://docs.julialang.org/en/latest/devdocs/offset-arrays/&quot;&gt;offset-arrays&lt;/a&gt;).</source>
          <target state="translated">Array가 비 전통적인 인덱싱을 사용하는 경우 1 : n을 사용하여 AbstractArray로 인덱싱하는 일반적인 관용구는 안전하지 않으며 범위 검사가 해제 된 경우 세그먼트 화 오류가 발생할 수 있습니다. 대신 &lt;code&gt;LinearIndices(x)&lt;/code&gt; 또는 &lt;code&gt;eachindex(x)&lt;/code&gt; 사용하십시오 ( &lt;a href=&quot;https://docs.julialang.org/en/latest/devdocs/offset-arrays/&quot;&gt;offset-arrays&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="f0451ae3f3f75dd1173ec1688aaf529347960c71" translate="yes" xml:space="preserve">
          <source>The commonly used &lt;code&gt;Int&lt;/code&gt; type corresponds to the machine integer type (&lt;code&gt;Int32&lt;/code&gt; or &lt;code&gt;Int64&lt;/code&gt;). This means it will overflow, such that &lt;code&gt;2^64 == 0&lt;/code&gt;. If you need larger values use another appropriate type, such as &lt;code&gt;Int128&lt;/code&gt;, &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; or a floating point type like &lt;code&gt;Float64&lt;/code&gt;.</source>
          <target state="translated">일반적으로 사용되는 &lt;code&gt;Int&lt;/code&gt; 유형은 기계 정수 유형 ( &lt;code&gt;Int32&lt;/code&gt; 또는 &lt;code&gt;Int64&lt;/code&gt; )에 해당합니다. 이것은 오버플로가 발생하여 &lt;code&gt;2^64 == 0&lt;/code&gt; 이됨을 의미합니다 . 더 큰 값이 필요한 경우 &lt;code&gt;Int128&lt;/code&gt; , &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;Float64&lt;/code&gt; 와 같은 부동 소수점 유형과 같은 다른 적절한 유형을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="282c5d6af8a85d4583f2090ba3bf0607d51cccb2" translate="yes" xml:space="preserve">
          <source>The compilers for many languages have an internal union construct for reasoning about types; Julia simply exposes it to the programmer. The Julia compiler is able to generate efficient code in the presence of &lt;code&gt;Union&lt;/code&gt; types with a small number of types &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt;, by generating specialized code in separate branches for each possible type.</source>
          <target state="translated">많은 언어의 컴파일러에는 유형에 대한 추론을위한 내부 공용체 구성이 있습니다. Julia는 단순히 프로그래머에게 노출시킵니다. Julia 컴파일러는 각 유형에 대해 별도의 분기로 특수 코드를 생성 하여 적은 수의 유형을 가진 &lt;code&gt;Union&lt;/code&gt; 유형이있는 경우 효율적인 코드를 생성 할 수 있습니다 &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d307808f74aeaa37d8dbbea9a15606c901a4cae0" translate="yes" xml:space="preserve">
          <source>The completion of fields for output from functions uses type inference, and it can only suggest fields if the function is type stable.</source>
          <target state="translated">함수 출력을위한 필드 완성에는 형식 유추가 사용되며 함수가 형식이 안정적인 경우에만 필드를 제안 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3138fe1fc8f7174a34adb1898449525528a913c" translate="yes" xml:space="preserve">
          <source>The completion of the methods uses type inference and can therefore see if the arguments match even if the arguments are output from functions. The function needs to be type stable for the completion to be able to remove non-matching methods.</source>
          <target state="translated">메서드의 완성은 형식 유추를 사용하므로 인수가 함수에서 출력 되더라도 인수가 일치하는지 확인할 수 있습니다. 일치하지 않는 방법을 제거 할 수 있으려면 함수의 유형이 안정적이어야합니다.</target>
        </trans-unit>
        <trans-unit id="6f83f5850ac6b62e295ec56f0e83533e7801ad37" translate="yes" xml:space="preserve">
          <source>The complexity of &lt;code&gt;rand(rng, s::Union{AbstractDict,AbstractSet})&lt;/code&gt; is linear in the length of &lt;code&gt;s&lt;/code&gt;, unless an optimized method with constant complexity is available, which is the case for &lt;code&gt;Dict&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;BitSet&lt;/code&gt;. For more than a few calls, use &lt;code&gt;rand(rng, collect(s))&lt;/code&gt; instead, or either &lt;code&gt;rand(rng, Dict(s))&lt;/code&gt; or &lt;code&gt;rand(rng, Set(s))&lt;/code&gt; as appropriate.</source>
          <target state="translated">복잡성의 &lt;code&gt;rand(rng, s::Union{AbstractDict,AbstractSet})&lt;/code&gt; 의 길이에 선형 &lt;code&gt;s&lt;/code&gt; 상수 복잡도 최적화 방법에 대한 경우 인, 이용 가능하지 않은 경우, &lt;code&gt;Dict&lt;/code&gt; , &lt;code&gt;Set&lt;/code&gt; 및 &lt;code&gt;BitSet&lt;/code&gt; . 몇 번의 호출에 대해서는 대신 &lt;code&gt;rand(rng, collect(s))&lt;/code&gt; 사용하거나 &lt;code&gt;rand(rng, Dict(s))&lt;/code&gt; 또는 &lt;code&gt;rand(rng, Set(s))&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="311dcfe3310c4c1e71b8fdd71e07a972ef0dc132" translate="yes" xml:space="preserve">
          <source>The components of tuples can optionally be named, in which case a &lt;em&gt;named tuple&lt;/em&gt; is constructed:</source>
          <target state="translated">튜플의 구성 요소는 선택적으로 명명 될 수 있으며,이 경우 &lt;em&gt;명명 된 튜플&lt;/em&gt; 이 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="3e9339bf8ddc8517e7daf0c8e7c807dbe19f1e27" translate="yes" xml:space="preserve">
          <source>The compressed sparse column storage makes it easy and quick to access the elements in the column of a sparse matrix, whereas accessing the sparse matrix by rows is considerably slower. Operations such as insertion of previously unstored entries one at a time in the CSC structure tend to be slow. This is because all elements of the sparse matrix that are beyond the point of insertion have to be moved one place over.</source>
          <target state="translated">압축 스파 스 열 스토리지를 사용하면 스파 스 행렬의 열에있는 요소에 쉽고 빠르게 액세스 할 수 있지만, 행으로 스파 스 행렬에 액세스하는 것은 상당히 느립니다. CSC 구조에서 한 번에 하나씩 이전에 저장되지 않은 항목을 삽입하는 등의 작업은 느리게 진행됩니다. 삽입 지점을 벗어난 희소 행렬의 모든 요소를 ​​한 위치 위로 이동해야하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="8b1889cfa906d5de7f417dbba5d8a75294042a14" translate="yes" xml:space="preserve">
          <source>The concatenation functions are used so often that they have special syntax:</source>
          <target state="translated">연결 함수는 자주 사용되어 특수 구문을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="79be6aae51e8c401b2476f5b4f2a107a9fdc32ef" translate="yes" xml:space="preserve">
          <source>The constant pi.</source>
          <target state="translated">상수 파이.</target>
        </trans-unit>
        <trans-unit id="cdd946b3bbe64931ddb3bd5e7f32f9d59fbf8fe0" translate="yes" xml:space="preserve">
          <source>The constant ℯ.</source>
          <target state="translated">상수 ℯ.</target>
        </trans-unit>
        <trans-unit id="9cefd93a0c7128d9cee7f50ca451b5a8198bc929" translate="yes" xml:space="preserve">
          <source>The constructor &lt;code&gt;RemoteChannel(f::Function, pid)()&lt;/code&gt; allows us to construct references to channels holding more than one value of a specific type. &lt;code&gt;f&lt;/code&gt; is a function executed on &lt;code&gt;pid&lt;/code&gt; and it must return an &lt;code&gt;AbstractChannel&lt;/code&gt;.</source>
          <target state="translated">생성자 &lt;code&gt;RemoteChannel(f::Function, pid)()&lt;/code&gt; 사용하면 특정 유형의 둘 이상의 값을 보유하는 채널에 대한 참조를 구성 할 수 있습니다. &lt;code&gt;f&lt;/code&gt; 는 &lt;code&gt;pid&lt;/code&gt; 에서 실행되는 함수 이며 &lt;code&gt;AbstractChannel&lt;/code&gt; 을 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="76232e9ec80692ffa1332b97fa1e6fc3973cc15d" translate="yes" xml:space="preserve">
          <source>The constructor for a shared array is of the form:</source>
          <target state="translated">공유 배열의 생성자는 다음과 같은 형식입니다.</target>
        </trans-unit>
        <trans-unit id="09f297e05974522f0c6701c3e5abf5ccf2ee32ab" translate="yes" xml:space="preserve">
          <source>The contents of each item in the list must line up with the first line of the item. In the above example the fenced code block must be indented by four spaces to align with the &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;item two&lt;/code&gt;.</source>
          <target state="translated">목록에있는 각 항목의 내용은 항목의 첫 번째 줄과 일치해야합니다. 상기 예에서, 울타리 코드 블록들은 함께 정렬하는 네 구역으로 들여해야 &lt;code&gt;i&lt;/code&gt; 의 &lt;code&gt;item two&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a711e2ee96d05b52332ef79c64c2aa17ad5865e1" translate="yes" xml:space="preserve">
          <source>The cookie may be passed to the workers at startup via argument &lt;code&gt;--worker=&amp;lt;cookie&amp;gt;&lt;/code&gt;. If argument &lt;code&gt;--worker&lt;/code&gt; is specified without the cookie, the worker tries to read the cookie from its standard input (&lt;a href=&quot;../../base/io-network/index#Base.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt;). The &lt;code&gt;stdin&lt;/code&gt; is closed immediately after the cookie is retrieved.</source>
          <target state="translated">쿠키는 &lt;code&gt;--worker=&amp;lt;cookie&amp;gt;&lt;/code&gt; 인수를 통해 시작할 때 작업자에게 전달 될 수 있습니다 . 쿠키없이 &lt;code&gt;--worker&lt;/code&gt; 인수 를 지정하면 작업자는 표준 입력 ( &lt;a href=&quot;../../base/io-network/index#Base.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt; ) 에서 쿠키를 읽으려고합니다 . &lt;code&gt;stdin&lt;/code&gt; 쿠키를 검색 한 후 즉시 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="870af6ba603446abce307b3e8bfd11194f33f900" translate="yes" xml:space="preserve">
          <source>The core language imposes very little; Julia Base and the standard library is written in Julia itself, including primitive operations like integer arithmetic</source>
          <target state="translated">핵심 언어는 거의 부과하지 않습니다. Julia Base와 표준 라이브러리는 정수 연산과 같은 기본 연산을 포함하여 Julia 자체로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="3bc4ff368fbfc76c3ff3eaa70599d7710f608522" translate="yes" xml:space="preserve">
          <source>The current logger state is looked up and the message level checked against the logger's cached minimum level, as found by calling &lt;a href=&quot;#Base.CoreLogging.min_enabled_level&quot;&gt;&lt;code&gt;Logging.min_enabled_level&lt;/code&gt;&lt;/a&gt;. This behavior can be overridden via environment variables (more on this later).</source>
          <target state="translated">&lt;a href=&quot;#Base.CoreLogging.min_enabled_level&quot;&gt; &lt;code&gt;Logging.min_enabled_level&lt;/code&gt; &lt;/a&gt; 을 호출하여 찾은 것처럼 현재 로거 상태가 조회되고 메시지 레벨이 로거의 캐시 된 최소 레벨과 비교하여 확인됩니다 . 이 동작은 환경 변수를 통해 무시할 수 있습니다 (나중에 자세히 설명).</target>
        </trans-unit>
        <trans-unit id="3f7f546fa478be5baf73e1d9a88ce7b4f22fd7b5" translate="yes" xml:space="preserve">
          <source>The current version of Julia multiplexes all tasks onto a single OS thread. Thus, while tasks involving I/O operations benefit from parallel execution, compute bound tasks are effectively executed sequentially on a single OS thread. Future versions of Julia may support scheduling of tasks on multiple threads, in which case compute bound tasks will see benefits of parallel execution too.</source>
          <target state="translated">Julia의 현재 버전은 모든 작업을 단일 OS 스레드로 다중화합니다. 따라서 I / O 작업과 관련된 작업은 병렬 실행의 이점이 있지만 컴퓨팅 바운드 작업은 단일 OS 스레드에서 순차적으로 효과적으로 실행됩니다. Julia의 향후 버전은 여러 스레드에서 작업 예약을 지원할 수 있으며,이 경우 컴퓨팅 바운드 작업은 병렬 실행의 이점도 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76aeeb5da0056ec0aaaca0d1c584f7796e1043fc" translate="yes" xml:space="preserve">
          <source>The dangers of abusing multiple dispatch (aka, more on types with values-as-parameters)</source>
          <target state="translated">다중 디스패치 남용의 위험성 (일명 매개 ​​변수 값이있는 유형의 경우 더 많음)</target>
        </trans-unit>
        <trans-unit id="61e6dec9a93ab50439a3df7d4ed79515ae264595" translate="yes" xml:space="preserve">
          <source>The day of month of a &lt;code&gt;Date&lt;/code&gt; or &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">(A)의 달의 날 &lt;code&gt;Date&lt;/code&gt; 또는 &lt;code&gt;DateTime&lt;/code&gt; AS를 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="299252ee9be4ede7afdc82ba83cfa67ed6efb411" translate="yes" xml:space="preserve">
          <source>The declared types of all fields in a composite DataType &lt;code&gt;T&lt;/code&gt; as a tuple.</source>
          <target state="translated">복합 DataType &lt;code&gt;T&lt;/code&gt; 에서 모든 필드의 선언 된 유형은 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="2ef7bb84da109de096d6179f580e39fcc330d135" translate="yes" xml:space="preserve">
          <source>The dedentation level is determined as the longest common starting sequence of spaces or tabs in all lines, excluding the line following the opening &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; and lines containing only spaces or tabs (the line containing the closing &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; is always included). Then for all lines, excluding the text following the opening &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt;, the common starting sequence is removed (including lines containing only spaces and tabs if they start with this sequence), e.g.:</source>
          <target state="translated">dedentation 수준은 시작 &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; 다음에 오는 줄과 공백 또는 탭만 포함하는 줄 (닫는 &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; 포함하는 줄 은 항상 포함됨)을 제외하고 모든 줄에서 가장 긴 공통 시작 간격 순서로 결정됩니다 . 그런 다음 여는 &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; 다음에 나오는 텍스트를 제외한 모든 행에 대해 공통 시작 순서가 제거됩니다 (공백과 탭이이 순서로 시작하는 경우에만 공백과 탭을 포함하는 행 포함).</target>
        </trans-unit>
        <trans-unit id="2356f962c8d3ff60eecc6a182ea052ea39664b67" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;pid&lt;/code&gt; is the current process.</source>
          <target state="translated">기본 &lt;code&gt;pid&lt;/code&gt; 는 현재 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="13fb2cffe54cc4ab8a1dd2c832ae7310589c0943" translate="yes" xml:space="preserve">
          <source>The default MIME type is &lt;code&gt;MIME&quot;text/plain&quot;&lt;/code&gt;. There is a fallback definition for &lt;code&gt;text/plain&lt;/code&gt; output that calls &lt;code&gt;show&lt;/code&gt; with 2 arguments. Therefore, this case should be handled by defining a 2-argument &lt;code&gt;show(io::IO, x::MyType)&lt;/code&gt; method.</source>
          <target state="translated">기본 MIME 유형은 &lt;code&gt;MIME&quot;text/plain&quot;&lt;/code&gt; 입니다. 2 개의 인수로 &lt;code&gt;show&lt;/code&gt; 를 호출하는 &lt;code&gt;text/plain&lt;/code&gt; 출력에 대한 대체 정의가 있습니다 . 따라서이 경우는 2 개의 인수 &lt;code&gt;show(io::IO, x::MyType)&lt;/code&gt; 메소드 를 정의하여 처리해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e57baa92c6f6a7e34ff4590072c999e03c2e6a26" translate="yes" xml:space="preserve">
          <source>The default behavior in Julia when types are omitted is to allow values to be of any type. Thus, one can write many useful Julia functions without ever explicitly using types. When additional expressiveness is needed, however, it is easy to gradually introduce explicit type annotations into previously &quot;untyped&quot; code. Adding annotations serves three primary purposes: to take advantage of Julia's powerful multiple-dispatch mechanism, to improve human readability, and to catch programmer errors.</source>
          <target state="translated">유형이 생략 될 때 Julia의 기본 동작은 값을 모든 유형으로 허용하는 것입니다. 따라서 명시 적으로 유형을 사용하지 않고도 많은 유용한 Julia 함수를 작성할 수 있습니다. 그러나 추가적인 표현성이 필요한 경우, 이전에 &quot;형식화되지 않은&quot;코드에 명시적인 형식 주석을 점진적으로 도입하는 것이 쉽습니다. 주석을 추가하면 Julia의 강력한 다중 디스패치 메커니즘을 활용하고 사람의 가독성을 높이며 프로그래머 오류를 포착하는 세 가지 주요 목적이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1df4775c1a0c6149628da164ef2c2add2aea3bd" translate="yes" xml:space="preserve">
          <source>The default behaviour is to remove leading whitespace and delimiters: see &lt;a href=&quot;#Base.Unicode.isspace&quot;&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/a&gt; for precise details.</source>
          <target state="translated">기본 동작은 선행 공백과 구분 기호를 제거하는 것 입니다. 자세한 내용 은 &lt;a href=&quot;#Base.Unicode.isspace&quot;&gt; &lt;code&gt;isspace&lt;/code&gt; &lt;/a&gt; 를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="1c11c76e6a974f0248876da7137e97c01ffa7caf" translate="yes" xml:space="preserve">
          <source>The default behaviour is to remove trailing whitespace and delimiters: see &lt;a href=&quot;#Base.Unicode.isspace&quot;&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/a&gt; for precise details.</source>
          <target state="translated">기본 동작은 후행 공백과 구분 기호를 제거하는 것 입니다. 자세한 내용 은 &lt;a href=&quot;#Base.Unicode.isspace&quot;&gt; &lt;code&gt;isspace&lt;/code&gt; &lt;/a&gt; 를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="855bff164720a2c745d8e506987fbf1482013980" translate="yes" xml:space="preserve">
          <source>The default implementation (which uses TCP/IP sockets) is implemented as &lt;code&gt;connect(manager::ClusterManager, pid::Integer, config::WorkerConfig)&lt;/code&gt;.</source>
          <target state="translated">TCP / IP 소켓을 사용하는 기본 구현은 &lt;code&gt;connect(manager::ClusterManager, pid::Integer, config::WorkerConfig)&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="78e7fa17aefadd075c2be825658630ae2cf9c235" translate="yes" xml:space="preserve">
          <source>The default implementation of &lt;code&gt;isequal&lt;/code&gt; calls &lt;code&gt;==&lt;/code&gt;, so a type that does not involve floating-point values generally only needs to define &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;isequal&lt;/code&gt; 호출 의 기본 구현은 &lt;code&gt;==&lt;/code&gt; 이므로 부동 소수점 값을 포함하지 않는 유형은 일반적으로 &lt;code&gt;==&lt;/code&gt; 만 정의하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="40594727e32e7ffa62fc7c197ea4f5e0449e9039" translate="yes" xml:space="preserve">
          <source>The default implementations of the above (on a &lt;code&gt;AbstractWorkerPool&lt;/code&gt;) require fields channel::Channel{Int} workers::Set{Int} where &lt;code&gt;channel&lt;/code&gt; contains free worker pids and &lt;code&gt;workers&lt;/code&gt; is the set of all workers associated with this pool.</source>
          <target state="translated">위의 기본 구현 ( &lt;code&gt;AbstractWorkerPool&lt;/code&gt; 에서 )에는 channel :: Channel {Int} workers :: Set {Int} 필드가 필요합니다. 여기서 &lt;code&gt;channel&lt;/code&gt; 에는 비어있는 작업자 pid가 포함되어 있으며 &lt;code&gt;workers&lt;/code&gt; 는이 풀과 관련된 모든 작업자의 집합입니다.</target>
        </trans-unit>
        <trans-unit id="90d0098a5b9857be430bc6bdbd24d7771a71aa03" translate="yes" xml:space="preserve">
          <source>The default is &lt;a href=&quot;#Base.IndexCartesian&quot;&gt;&lt;code&gt;IndexCartesian()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본값은 &lt;a href=&quot;#Base.IndexCartesian&quot;&gt; &lt;code&gt;IndexCartesian()&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="939929b76e159e18d5e7761850ea7b359afa492d" translate="yes" xml:space="preserve">
          <source>The default mode used is always &lt;a href=&quot;../../base/math/index#Base.Rounding.RoundNearest&quot;&gt;&lt;code&gt;RoundNearest&lt;/code&gt;&lt;/a&gt;, which rounds to the nearest representable value, with ties rounded towards the nearest value with an even least significant bit.</source>
          <target state="translated">사용되는 기본 모드는 항상 &lt;a href=&quot;../../base/math/index#Base.Rounding.RoundNearest&quot;&gt; &lt;code&gt;RoundNearest&lt;/code&gt; &lt;/a&gt; 이며 가장 가까운 표현 가능한 값으로 반올림되며 가장 작은 비트로 가장 가까운 값으로 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="bb41fa3202534d6677ac2f342e3bce0fdc60f379" translate="yes" xml:space="preserve">
          <source>The default precision (in number of bits of the significand) and rounding mode of &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; operations can be changed globally by calling &lt;a href=&quot;../../base/numbers/index#Base.MPFR.setprecision&quot;&gt;&lt;code&gt;setprecision&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;setrounding&lt;/code&gt;, and all further calculations will take these changes in account. Alternatively, the precision or the rounding can be changed only within the execution of a particular block of code by using the same functions with a &lt;code&gt;do&lt;/code&gt; block:</source>
          <target state="translated">&lt;a href=&quot;../../base/numbers/index#Base.MPFR.setprecision&quot;&gt; &lt;code&gt;setprecision&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;setrounding&lt;/code&gt; 을 호출 하여 &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt; 조작 의 기본 정밀도 (유의 비트 수로 표시) 및 반올림 모드를 전체적으로 변경할 수 있으며 이후의 모든 계산에는 이러한 변경 사항이 고려됩니다. 또는 &lt;code&gt;do&lt;/code&gt; 블록 과 동일한 기능을 사용하여 특정 코드 블록 실행 내에서만 정밀도 또는 반올림을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf260c790afbd5fd76456a214c3da2bfee6f596b" translate="yes" xml:space="preserve">
          <source>The default rounding mode. Rounds to the nearest integer, with ties (fractional values of 0.5) being rounded to the nearest even integer.</source>
          <target state="translated">기본 반올림 모드입니다. 가장 가까운 정수로 반올림하고 넥타이 (분수 값 0.5)는 가장 가까운 짝수로 반올림합니다.</target>
        </trans-unit>
        <trans-unit id="a8d023ed2ec488f600d82c5f04099bb7053c6343" translate="yes" xml:space="preserve">
          <source>The default sorting algorithms are chosen on the basis that they are fast and stable, or &lt;em&gt;appear&lt;/em&gt; to be so. For numeric types indeed, &lt;code&gt;QuickSort&lt;/code&gt; is selected as it is faster and indistinguishable in this case from a stable sort (unless the array records its mutations in some way). The stability property comes at a non-negligible cost, so if you don't need it, you may want to explicitly specify your preferred algorithm, e.g. &lt;code&gt;sort!(v, alg=QuickSort)&lt;/code&gt;.</source>
          <target state="translated">기본 정렬 알고리즘은 빠르고 안정적이거나 그렇지 않은 &lt;em&gt;것으로&lt;/em&gt; 판단하여 선택됩니다. 실제로 숫자 유형의 경우 &lt;code&gt;QuickSort&lt;/code&gt; 는이 경우 안정적인 정렬과 더 빠르고 구분하기 어렵 기 때문에 선택됩니다 (어레이가 어떤 방식으로 돌연변이를 기록하지 않는 한). 안정성 속성은 무시할 수없는 비용으로 제공되므로 필요하지 않은 경우 원하는 알고리즘을 명시 적으로 지정할 수 있습니다 &lt;code&gt;sort!(v, alg=QuickSort)&lt;/code&gt; 예 : sort! (v, alg = QuickSort)) .</target>
        </trans-unit>
        <trans-unit id="8e4b294c96581c70e29314614e72dd9c556dd867" translate="yes" xml:space="preserve">
          <source>The default type for an integer literal depends on whether the target system has a 32-bit architecture or a 64-bit architecture:</source>
          <target state="translated">정수 리터럴의 기본 유형은 대상 시스템에 32 비트 아키텍처가 있는지 또는 64 비트 아키텍처가 있는지에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="0025d7cf20de7d8585d610cdb20c478776196150" translate="yes" xml:space="preserve">
          <source>The default value (for iterators that do not define this function) is &lt;code&gt;HasLength()&lt;/code&gt;. This means that most iterators are assumed to implement &lt;a href=&quot;#Base.length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본값 (이 함수를 정의하지 않은 반복자)은 &lt;code&gt;HasLength()&lt;/code&gt; 입니다. 이것은 대부분의 반복자가 &lt;a href=&quot;#Base.length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt; 를 구현한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="ed1fec164addf150bd6fc4ed074c8bde6086195e" translate="yes" xml:space="preserve">
          <source>The default when no keywords are passed is to open files for reading only. Returns a stream for accessing the opened file.</source>
          <target state="translated">키워드가 전달되지 않은 경우 기본값은 읽기 전용으로 파일을 여는 것입니다. 열린 파일에 액세스하기위한 스트림을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="46ad04b79597833ac2971450ca4faf1a5ac755c0" translate="yes" xml:space="preserve">
          <source>The definitive guide to floating point arithmetic is the &lt;a href=&quot;https://standards.ieee.org/standard/754-2008.html&quot;&gt;IEEE 754-2008 Standard&lt;/a&gt;; however, it is not available for free online.</source>
          <target state="translated">부동 소수점 산술에 대한 결정적인 가이드는 &lt;a href=&quot;https://standards.ieee.org/standard/754-2008.html&quot;&gt;IEEE 754-2008 표준입니다&lt;/a&gt; . 그러나 온라인에서는 무료로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c7a1e185817162d29c3ca02c640a39cf90726456" translate="yes" xml:space="preserve">
          <source>The description string accepts interpolation from the loop indices. If no description is provided, one is constructed based on the variables.</source>
          <target state="translated">설명 문자열은 루프 인덱스에서 보간을 허용합니다. 설명이 제공되지 않으면 변수를 기반으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="b9783bd3f57cabbb7dcb6efff07a6fb2ce7cf2be" translate="yes" xml:space="preserve">
          <source>The destructuring feature can also be used within a function argument. If a function argument name is written as a tuple (e.g. &lt;code&gt;(x, y)&lt;/code&gt;) instead of just a symbol, then an assignment &lt;code&gt;(x, y) = argument&lt;/code&gt; will be inserted for you:</source>
          <target state="translated">소멸 기능은 함수 인수 내에서도 사용될 수 있습니다. 함수 인수 이름이 기호 대신 튜플 (예 : &lt;code&gt;(x, y)&lt;/code&gt; )로 작성되면 할당 &lt;code&gt;(x, y) = argument&lt;/code&gt; 가 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="dca7fd4aaff137c3b5ad312f731763865f2c4777" translate="yes" xml:space="preserve">
          <source>The diagonal of the matrix &lt;code&gt;X&lt;/code&gt; is assumed to be all ones.</source>
          <target state="translated">행렬 &lt;code&gt;X&lt;/code&gt; 의 대각선은 모두 1 인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="65475d5b108ff8d6ff4d0b451b5957edd3247c0c" translate="yes" xml:space="preserve">
          <source>The diagonal values of the matrix &lt;code&gt;X&lt;/code&gt; will be read.</source>
          <target state="translated">행렬 &lt;code&gt;X&lt;/code&gt; 의 대각선 값을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="35294cd283107f3ea2ad299c610959761013b001" translate="yes" xml:space="preserve">
          <source>The difference in norm between a vector space and its dual arises to preserve the relationship between duality and the dot product, and the result is consistent with the operator &lt;code&gt;p&lt;/code&gt;-norm of a &lt;code&gt;1 &amp;times; n&lt;/code&gt; matrix.</source>
          <target state="translated">벡터 공간과 그 이중 간의 표준 차이는 이원성과 내적 간의 관계를 유지하기 위해 발생하며 결과는 &lt;code&gt;1 &amp;times; n&lt;/code&gt; 행렬 의 연산자 &lt;code&gt;p&lt;/code&gt; -norm 과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="fe30caaca3ec896d42d37e2680c6fbcc22f3fc58" translate="yes" xml:space="preserve">
          <source>The difference seems trivial, but in fact is quite significant due to the behavior of &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt;. In the first method, a random matrix is constructed locally, then sent to another process where it is squared. In the second method, a random matrix is both constructed and squared on another process. Therefore the second method sends much less data than the first.</source>
          <target state="translated">차이점은 사소한 것처럼 보이지만 실제로는 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt; 의 동작으로 인해 상당히 중요 합니다. 첫 번째 방법에서는 랜덤 매트릭스가 로컬로 구성된 다음 다른 프로세스로 제곱됩니다. 두 번째 방법에서, 랜덤 행렬은 다른 프로세스에서 구성되고 제곱됩니다. 따라서 두 번째 방법은 첫 번째 방법보다 훨씬 적은 양의 데이터를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="515d7afeaf87e8c8538070fa94ff623cdced8f10" translate="yes" xml:space="preserve">
          <source>The different prompt modes</source>
          <target state="translated">다른 프롬프트 모드</target>
        </trans-unit>
        <trans-unit id="cf7712c8e857525e49eb6c6feac8d5fe578af7a4" translate="yes" xml:space="preserve">
          <source>The discussion in the preceding paragraph referred to the &quot;parser&quot;, that is, the phase of compilation that takes place when the module containing &lt;code&gt;abmult&lt;/code&gt; is first loaded, as opposed to the later phase when it is first invoked. The parser does not &quot;know&quot; that &lt;code&gt;Int&lt;/code&gt; is a fixed type, or that the statement &lt;code&gt;r = -r&lt;/code&gt; transforms an &lt;code&gt;Int&lt;/code&gt; to another &lt;code&gt;Int&lt;/code&gt;. The magic of type inference takes place in the later phase of compilation.</source>
          <target state="translated">이전 단락에서 논의한 내용은 &quot;파서&quot;, 즉 &lt;code&gt;abmult&lt;/code&gt; 를 포함하는 모듈 이 처음로드 될 때 발생하는 컴파일 단계와 처음 호출했을 때의 단계와 반대입니다. 구문 분석기는 &lt;code&gt;Int&lt;/code&gt; 가 고정 된 유형이거나 명령문 &lt;code&gt;r = -r&lt;/code&gt; 이 &lt;code&gt;Int&lt;/code&gt; 를 다른 &lt;code&gt;Int&lt;/code&gt; 로 변환 한다는 것을 &quot;알지&quot;않습니다 . 형식 추론의 마술은 후기 컴파일 단계에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="228846c17a2f8eda9af9e04280c4e7e004d8ecbb" translate="yes" xml:space="preserve">
          <source>The discussion of trait-based promotion provides a transition into our next design pattern: computing the output element type for a matrix operation.</source>
          <target state="translated">특성 기반 프로모션에 대한 논의는 다음 디자인 패턴으로의 전환을 제공합니다. 매트릭스 연산을위한 출력 요소 유형 계산.</target>
        </trans-unit>
        <trans-unit id="c9eeea461d08f16f6e9e3e76a2854c7413f10de0" translate="yes" xml:space="preserve">
          <source>The distance between two adjacent representable floating-point numbers is not constant, but is smaller for smaller values and larger for larger values. In other words, the representable floating-point numbers are densest in the real number line near zero, and grow sparser exponentially as one moves farther away from zero. By definition, &lt;code&gt;eps(1.0)&lt;/code&gt; is the same as &lt;code&gt;eps(Float64)&lt;/code&gt; since &lt;code&gt;1.0&lt;/code&gt; is a 64-bit floating-point value.</source>
          <target state="translated">인접한 두 개의 표현 가능한 부동 소수점 숫자 사이의 거리는 일정하지 않지만 값이 작을수록 작고 값이 클수록 큽니다. 다시 말해, 표현 가능한 부동 소수점 숫자는 0 근처의 실수 라인에서 가장 밀도가 높고, 0에서 멀어 질수록 기하 급수적으로 증가합니다. 정의에 의하면, &lt;code&gt;eps(1.0)&lt;/code&gt; 와 동일 &lt;code&gt;eps(Float64)&lt;/code&gt; 부터 &lt;code&gt;1.0&lt;/code&gt; 64 비트 부동 소수점 값이다.</target>
        </trans-unit>
        <trans-unit id="17711720acdfc250d4da5bdf1c59e4156516b762" translate="yes" xml:space="preserve">
          <source>The distinction between inheriting global scope and nesting local scope can lead to some slight differences between functions defined in local versus global scopes for variable assignments. Consider the modification of the last example by moving &lt;code&gt;bar&lt;/code&gt; to the global scope:</source>
          <target state="translated">전역 범위 상속과 중첩 로컬 범위의 구분으로 인해 변수 할당에 대한 로컬 범위와 전역 범위에 정의 된 함수간에 약간의 차이가 발생할 수 있습니다. &lt;code&gt;bar&lt;/code&gt; 를 전역 범위 로 이동하여 마지막 예를 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="bcbd86bd1c455f650a19858504ec03684521d39b" translate="yes" xml:space="preserve">
          <source>The documentation is also available in PDF format: &lt;a href=&quot;https://raw.githubusercontent.com/JuliaLang/docs.julialang.org/assets/julia-1.2.0.pdf&quot;&gt;julia-1.2.0.pdf&lt;/a&gt;.</source>
          <target state="translated">문서는 PDF 형식으로도 제공됩니다 : &lt;a href=&quot;https://raw.githubusercontent.com/JuliaLang/docs.julialang.org/assets/julia-1.2.0.pdf&quot;&gt;julia-1.2.0.pdf&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="83c976d9d02fc2e4f087f2db86ac987d2cebacc0" translate="yes" xml:space="preserve">
          <source>The easiest way to learn and experiment with Julia is by starting an interactive session (also known as a read-eval-print loop or &quot;REPL&quot;) by double-clicking the Julia executable or running &lt;code&gt;julia&lt;/code&gt; from the command line:</source>
          <target state="translated">Julia를 배우고 실험하는 가장 쉬운 방법은 Julia 실행 파일을 두 번 클릭하거나 명령 행에서 &lt;code&gt;julia&lt;/code&gt; 를 실행하여 대화식 세션 (읽기 평가판 인쇄 루프 또는 &quot;REPL&quot;이라고도 함)을 시작하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="2182ffaca8a0c2d19e2f394d632b220a4bda55b5" translate="yes" xml:space="preserve">
          <source>The easiest way to understand this behavior is to see an example. In the previous example, the &lt;code&gt;println&lt;/code&gt; call is shared by all three branches: the only real choice is which literal string to print. This could be written more concisely using the ternary operator. For the sake of clarity, let's try a two-way version first:</source>
          <target state="translated">이 동작을 이해하는 가장 쉬운 방법은 예를 보는 것입니다. 이전 예제에서 &lt;code&gt;println&lt;/code&gt; 호출은 세 가지 분기 모두에 의해 공유됩니다. 유일한 선택은 인쇄 할 리터럴 문자열입니다. 삼항 연산자를 사용하여 더 간결하게 작성할 수 있습니다. 명확성을 위해 먼저 양방향 버전을 사용해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="56dd1399973b5466f5b438f54aa5084eb3d4b3fd" translate="yes" xml:space="preserve">
          <source>The editor can be changed by setting &lt;code&gt;JULIA_EDITOR&lt;/code&gt;, &lt;code&gt;VISUAL&lt;/code&gt; or &lt;code&gt;EDITOR&lt;/code&gt; as an environment variable.</source>
          <target state="translated">&lt;code&gt;JULIA_EDITOR&lt;/code&gt; , &lt;code&gt;VISUAL&lt;/code&gt; 또는 &lt;code&gt;EDITOR&lt;/code&gt; 를 환경 변수로 설정하여 편집기를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d60f89821e0be17d3c10fd641e166470b0fae98" translate="yes" xml:space="preserve">
          <source>The editor returned by &lt;code&gt;InteractiveUtils.editor()&lt;/code&gt; and used in, e.g., &lt;code&gt;InteractiveUtils.edit&lt;/code&gt;, referring to the command of the preferred editor, for instance &lt;code&gt;vim&lt;/code&gt;.</source>
          <target state="translated">편집기는 &lt;code&gt;InteractiveUtils.editor()&lt;/code&gt; 의해 리턴되어 예를 들어 &lt;code&gt;InteractiveUtils.edit&lt;/code&gt; 편집기 (예 : &lt;code&gt;vim&lt;/code&gt; ) 와 같은 기본 편집기의 명령을 참조하여 InteractiveUtils.edit 에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2f31493a5d545803d2bc443ac0f38b3d641d141b" translate="yes" xml:space="preserve">
          <source>The efficiency gained by being able to store &lt;code&gt;Point{Float64}&lt;/code&gt; objects with immediate values is magnified enormously in the case of arrays: an &lt;code&gt;Array{Float64}&lt;/code&gt; can be stored as a contiguous memory block of 64-bit floating-point values, whereas an &lt;code&gt;Array{Real}&lt;/code&gt; must be an array of pointers to individually allocated &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; objects &amp;ndash; which may well be &lt;a href=&quot;https://en.wikipedia.org/wiki/Object_type_%28object-oriented_programming%29#Boxing&quot;&gt;boxed&lt;/a&gt; 64-bit floating-point values, but also might be arbitrarily large, complex objects, which are declared to be implementations of the &lt;code&gt;Real&lt;/code&gt; abstract type.</source>
          <target state="translated">&lt;code&gt;Array{Float64}&lt;/code&gt; 의 경우 &lt;code&gt;Point{Float64}&lt;/code&gt; 객체를 즉각적인 값 으로 저장할 수있어 얻을 수있는 효율성이 엄청나게 확대됩니다. Array {Float64} 는 64 비트 부동 소수점 값의 연속 메모리 블록으로 저장할 수 있지만 &lt;code&gt;Array{Real}&lt;/code&gt; 개별적으로 할당 된 포인터 배열해야 &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; 잘 할 수있다 - 오브젝트 &lt;a href=&quot;https://en.wikipedia.org/wiki/Object_type_%28object-oriented_programming%29#Boxing&quot;&gt;박스&lt;/a&gt; 의 구현으로 선언 된 임의의 큰, 복잡한 객체, 수 있습니다 또한 64 비트 부동 소수점 값을하지만, &lt;code&gt;Real&lt;/code&gt; 추상 형식.</target>
        </trans-unit>
        <trans-unit id="77656128da3c3e27758883f72427b834f3cb4b6e" translate="yes" xml:space="preserve">
          <source>The eigenvalues are returned in &lt;code&gt;W&lt;/code&gt; and the eigenvectors in &lt;code&gt;Z&lt;/code&gt;.</source>
          <target state="translated">고유 값은 &lt;code&gt;W&lt;/code&gt; 로, 고유 벡터는 &lt;code&gt;Z&lt;/code&gt; 로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="709d89b2d19663c267d1c6a4862d61316a231e84" translate="yes" xml:space="preserve">
          <source>The element type of the result is chosen using promotion (see &lt;a href=&quot;../base/index#Base.promote_type&quot;&gt;&lt;code&gt;promote_type&lt;/code&gt;&lt;/a&gt;) based on the element type of &lt;code&gt;A&lt;/code&gt; and on the types of the &lt;code&gt;new&lt;/code&gt; values in pairs. If &lt;code&gt;count&lt;/code&gt; is omitted and the element type of &lt;code&gt;A&lt;/code&gt; is a &lt;code&gt;Union&lt;/code&gt;, the element type of the result will not include singleton types which are replaced with values of a different type: for example, &lt;code&gt;Union{T,Missing}&lt;/code&gt; will become &lt;code&gt;T&lt;/code&gt; if &lt;code&gt;missing&lt;/code&gt; is replaced.</source>
          <target state="translated">결과 의 요소 유형은 &lt;code&gt;A&lt;/code&gt; 의 요소 유형 과 &lt;code&gt;new&lt;/code&gt; 값 의 유형을 쌍으로 사용하여 promotion ( &lt;a href=&quot;../base/index#Base.promote_type&quot;&gt; &lt;code&gt;promote_type&lt;/code&gt; &lt;/a&gt; 참조 )을 사용하여 선택됩니다 . 경우 &lt;code&gt;count&lt;/code&gt; 생략의 소자 타입 &lt;code&gt;A&lt;/code&gt; 는 A는 &lt;code&gt;Union&lt;/code&gt; 결과의 요소 유형은 다른 종류의 값으로 대체되는 싱글 타입을 포함하지 않을 것이다 : 예를 들어, &lt;code&gt;Union{T,Missing}&lt;/code&gt; 해질 것이다 &lt;code&gt;T&lt;/code&gt; 이 경우 &lt;code&gt;missing&lt;/code&gt; 있다 교체되었습니다.</target>
        </trans-unit>
        <trans-unit id="14b4f332ac46b505bad4228677357909dd03b266" translate="yes" xml:space="preserve">
          <source>The element type of the tuple must be an instance of &lt;code&gt;VecElement{T}&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is a primitive type that is 1, 2, 4 or 8 bytes.</source>
          <target state="translated">튜플의 요소 유형은 &lt;code&gt;VecElement{T}&lt;/code&gt; 의 인스턴스 여야합니다. 여기서 &lt;code&gt;T&lt;/code&gt; 는 1, 2, 4 또는 8 바이트 인 기본 유형입니다.</target>
        </trans-unit>
        <trans-unit id="c9296fda074d952d1c87394f1441913d330aa413" translate="yes" xml:space="preserve">
          <source>The empty (or &quot;bottom&quot;) type, written as &lt;code&gt;Union{}&lt;/code&gt; (an empty union type), is a type with no values and no subtypes (except itself). You will generally not need to use this type.</source>
          <target state="translated">&lt;code&gt;Union{}&lt;/code&gt; (빈 공용체 유형)으로 작성된 빈 (또는 &quot;하단&quot;) 유형 은 값이없고 하위 유형이없는 유형입니다 (자체 제외). 일반적으로이 유형을 사용할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="3534ea1366da3151258e1f770bb393a26a8c9156" translate="yes" xml:space="preserve">
          <source>The empty tuple (&lt;code&gt;()&lt;/code&gt;) is another form of nothingness. But, it should not really be thought of as nothing but rather a tuple of zero values.</source>
          <target state="translated">빈 튜플 ( &lt;code&gt;()&lt;/code&gt; )은 또 다른 형태의 무의미입니다. 그러나 실제로는 값이 0이 아닌 튜플이라고 생각해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="f2bd3a290bc2b2f98102d89ff212080bf2528200" translate="yes" xml:space="preserve">
          <source>The end of line delimiter is taken as &lt;code&gt;\n&lt;/code&gt;.</source>
          <target state="translated">줄 끝 구분 기호는 &lt;code&gt;\n&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="13d242b1b1e933d4ec26a29014e675d01b5c3b93" translate="yes" xml:space="preserve">
          <source>The end of line delimiter is taken as &lt;code&gt;\n&lt;/code&gt;. If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.</source>
          <target state="translated">줄 끝 구분 기호는 &lt;code&gt;\n&lt;/code&gt; 입니다. 모든 데이터가 숫자이면 결과는 숫자 배열이됩니다. 일부 요소를 숫자로 구문 분석 할 수없는 경우 이기종 배열의 숫자와 문자열이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="0c21a922512e76aea89910e75ca40814c713417b" translate="yes" xml:space="preserve">
          <source>The entries of &lt;code&gt;F.D1&lt;/code&gt; and &lt;code&gt;F.D2&lt;/code&gt; are related, as explained in the LAPACK documentation for the &lt;a href=&quot;http://www.netlib.org/lapack/lug/node36.html&quot;&gt;generalized SVD&lt;/a&gt; and the &lt;a href=&quot;http://www.netlib.org/lapack/explore-html/d6/db3/dggsvd3_8f.html&quot;&gt;xGGSVD3&lt;/a&gt; routine which is called underneath (in LAPACK 3.6.0 and newer).</source>
          <target state="translated">&lt;code&gt;F.D1&lt;/code&gt; 및 &lt;code&gt;F.D2&lt;/code&gt; 의 항목은 &lt;a href=&quot;http://www.netlib.org/lapack/lug/node36.html&quot;&gt;일반화 된 SVD&lt;/a&gt; 및 &lt;a href=&quot;http://www.netlib.org/lapack/explore-html/d6/db3/dggsvd3_8f.html&quot;&gt;xGGSVD3&lt;/a&gt; 루틴 (LAPACK 3.6.0 이상) 에 대한 LAPACK 설명서에 설명 된대로 관련되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c6e8a6592578860941072596b3389f0e39bd834" translate="yes" xml:space="preserve">
          <source>The environment variables that Julia uses generally start with &lt;code&gt;JULIA&lt;/code&gt;. If &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.versioninfo&quot;&gt;&lt;code&gt;InteractiveUtils.versioninfo&lt;/code&gt;&lt;/a&gt; is called with the keyword &lt;code&gt;verbose=true&lt;/code&gt;, then the output will list defined environment variables relevant for Julia, including those for which &lt;code&gt;JULIA&lt;/code&gt; appears in the name.</source>
          <target state="translated">Julia가 사용하는 환경 변수는 일반적으로 &lt;code&gt;JULIA&lt;/code&gt; 로 시작 합니다. 경우 &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.versioninfo&quot;&gt; &lt;code&gt;InteractiveUtils.versioninfo&lt;/code&gt; 이&lt;/a&gt; 키워드로 호출 &lt;code&gt;verbose=true&lt;/code&gt; 하는 것을 포함 줄리아에 대한 관련, 출력은 정의가 나열됩니다 환경 변수, &lt;code&gt;JULIA&lt;/code&gt; 이름으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="7ebc4dca8e995a281e980c9657b899d8cf0df29e" translate="yes" xml:space="preserve">
          <source>The equivalent of an &lt;code&gt;&amp;lt;hr&amp;gt;&lt;/code&gt; HTML tag can be written using the following syntax:</source>
          <target state="translated">&lt;code&gt;&amp;lt;hr&amp;gt;&lt;/code&gt; HTML 태그 와 동등한 것은 다음 구문을 사용하여 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74efd542b7345e98fdaed051a7a6183a8d020db5" translate="yes" xml:space="preserve">
          <source>The example generated function &lt;code&gt;foo&lt;/code&gt; above did not do anything a normal function &lt;code&gt;foo(x) = x * x&lt;/code&gt; could not do (except printing the type on the first invocation, and incurring higher overhead). However, the power of a generated function lies in its ability to compute different quoted expressions depending on the types passed to it:</source>
          <target state="translated">위의 예제 생성 함수 &lt;code&gt;foo&lt;/code&gt; 는 정상적인 함수 &lt;code&gt;foo(x) = x * x&lt;/code&gt; 가 수행 할 수없는 작업을 수행하지 않았습니다 (첫 번째 호출에서 유형을 인쇄하고 더 높은 오버 헤드가 발생하는 경우 제외). 그러나 생성 된 함수의 힘은 전달 된 유형에 따라 다른 인용 된 표현식을 계산하는 기능에 있습니다.</target>
        </trans-unit>
        <trans-unit id="e119c6a2d56d3760f8ebb0ae8619e173f79b4b25" translate="yes" xml:space="preserve">
          <source>The example in the previous section glossed over the implementation details of &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.promote&quot;&gt;&lt;code&gt;promote&lt;/code&gt;&lt;/a&gt;, which both operate in terms of these traits. When iterating over a matrix, such as in the implementation of &lt;code&gt;map&lt;/code&gt;, one important question is what order to use to traverse the data. When &lt;code&gt;AbstractArray&lt;/code&gt; subtypes implement the &lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt;&lt;code&gt;Base.IndexStyle&lt;/code&gt;&lt;/a&gt; trait, other functions such as &lt;code&gt;map&lt;/code&gt; can dispatch on this information to pick the best algorithm (see &lt;a href=&quot;../interfaces/index#man-interface-array-1&quot;&gt;Abstract Array Interface&lt;/a&gt;). This means that each subtype does not need to implement a custom version of &lt;code&gt;map&lt;/code&gt;, since the generic definitions + trait classes will enable the system to select the fastest version. Here a toy implementation of &lt;code&gt;map&lt;/code&gt; illustrating the trait-based dispatch:</source>
          <target state="translated">이전 섹션의 예제 는 이러한 특성 측면에서 작동하는 &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/base/index#Base.promote&quot;&gt; &lt;code&gt;promote&lt;/code&gt; &lt;/a&gt; 의 구현 세부 사항에 대해 설명했습니다 . &lt;code&gt;map&lt;/code&gt; 구현과 같이 행렬을 반복 할 때 중요한 질문 중 하나는 데이터를 순회하기 위해 어떤 순서를 사용해야 하는가입니다. 때 &lt;code&gt;AbstractArray&lt;/code&gt; 아형이 구현 &lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt; &lt;code&gt;Base.IndexStyle&lt;/code&gt; &lt;/a&gt; 특성과 같은 다른 기능 &lt;code&gt;map&lt;/code&gt; 가장 좋은 알고리즘을 선택하기 위해이 정보를 전달할 수 있습니다 (참조 &lt;a href=&quot;../interfaces/index#man-interface-array-1&quot;&gt;추상 배열 인터페이스&lt;/a&gt; ). 즉, 각 하위 유형에 맞춤 &lt;code&gt;map&lt;/code&gt; 버전을 구현할 필요가 없습니다.일반 정의 + 특성 클래스를 사용하면 시스템에서 가장 빠른 버전을 선택할 수 있습니다. 의 다음 장난감 구현 &lt;code&gt;map&lt;/code&gt; 형질 기반의 파견을 설명 :</target>
        </trans-unit>
        <trans-unit id="c4e7ac687a3c1938fcc96d92a705ce561c8d3bfd" translate="yes" xml:space="preserve">
          <source>The exception is that quotation marks still must be escaped, e.g. &lt;code&gt;raw&quot;\&quot;&quot;&lt;/code&gt; is equivalent to &lt;code&gt;&quot;\&quot;&quot;&lt;/code&gt;. To make it possible to express all strings, backslashes then also must be escaped, but only when appearing right before a quote character:</source>
          <target state="translated">예외는 예를 들어, 그 인용 부호는 여전히 이스케이프해야합니다입니다 &lt;code&gt;raw&quot;\&quot;&quot;&lt;/code&gt; 에 해당 &lt;code&gt;&quot;\&quot;&quot;&lt;/code&gt; . 모든 문자열을 표현할 수있게하려면 백 슬래시도 이스케이프해야하지만 따옴표 문자 바로 앞에 나타날 때만 :</target>
        </trans-unit>
        <trans-unit id="806a2c6eb838f5063922dc987163b721668d0145" translate="yes" xml:space="preserve">
          <source>The exception stack is stored on the &lt;code&gt;Task&lt;/code&gt; where the exceptions occurred. When a task fails with uncaught exceptions, &lt;code&gt;catch_stack(task)&lt;/code&gt; may be used to inspect the exception stack for that task.</source>
          <target state="translated">예외 스택은 예외가 발생한 &lt;code&gt;Task&lt;/code&gt; 저장됩니다 . 잡히지 않은 예외로 작업이 실패하면 &lt;code&gt;catch_stack(task)&lt;/code&gt; 사용하여 해당 작업에 대한 예외 스택을 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="928c8d0396de54cd800b9aede32ea561fba936f5" translate="yes" xml:space="preserve">
          <source>The exceptions to this rule are the smallest and largest finite values (e.g. &lt;code&gt;nextfloat(-Inf)&lt;/code&gt; and &lt;code&gt;prevfloat(Inf)&lt;/code&gt; for &lt;a href=&quot;../numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;), which round to the smaller of the values.</source>
          <target state="translated">이 규칙에 대한 예외는 최소 및 최대 유한 한 값이다 (예 &lt;code&gt;nextfloat(-Inf)&lt;/code&gt; 및 &lt;code&gt;prevfloat(Inf)&lt;/code&gt; 용 &lt;a href=&quot;../numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; ) 값의 작은 원형으로한다.</target>
        </trans-unit>
        <trans-unit id="def91518b0989f4a83def2144fe01cdce215a440" translate="yes" xml:space="preserve">
          <source>The executable itself is one of</source>
          <target state="translated">실행 파일 자체는 다음 중 하나입니다</target>
        </trans-unit>
        <trans-unit id="0db1c4486699e7de0f4ce2a483205ec8ce5f38db" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;a&lt;/code&gt;, before the &lt;code&gt;?&lt;/code&gt;, is a condition expression, and the ternary operation evaluates the expression &lt;code&gt;b&lt;/code&gt;, before the &lt;code&gt;:&lt;/code&gt;, if the condition &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; or the expression &lt;code&gt;c&lt;/code&gt;, after the &lt;code&gt;:&lt;/code&gt;, if it is &lt;code&gt;false&lt;/code&gt;. Note that the spaces around &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;:&lt;/code&gt; are mandatory: an expression like &lt;code&gt;a?b:c&lt;/code&gt; is not a valid ternary expression (but a newline is acceptable after both the &lt;code&gt;?&lt;/code&gt; and the &lt;code&gt;:&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; 앞에있는 표현식 &lt;code&gt;a&lt;/code&gt; , 조건 식이고, 원 동작은 평가 식 &lt;code&gt;b&lt;/code&gt; 하기 전에, &lt;code&gt;:&lt;/code&gt; 조건의 경우, &lt;code&gt;a&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; 또는 식 &lt;code&gt;c&lt;/code&gt; , 애프터 &lt;code&gt;:&lt;/code&gt; 이 경우에, &lt;code&gt;false&lt;/code&gt; . 주위의 공백은 &lt;code&gt;?&lt;/code&gt; 및 &lt;code&gt;:&lt;/code&gt; 같은 식 : 필수 &lt;code&gt;a?b:c&lt;/code&gt; 유효한 삼원 식 없다 (그러나 개행 모두 후에 허용 &lt;code&gt;?&lt;/code&gt; 하고 &lt;code&gt;:&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="465bf593bbe53b12eb7783b96c9712a167cf8578" translate="yes" xml:space="preserve">
          <source>The expression passed to the &lt;a href=&quot;#Base.Meta.parse-Tuple%7BAbstractString,Int64%7D&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt; function could not be interpreted as a valid Julia expression.</source>
          <target state="translated">&lt;a href=&quot;#Base.Meta.parse-Tuple%7BAbstractString,Int64%7D&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt; 함수에 전달 된 표현식을 유효한 Julia 표현식으로 해석 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a177c1288ef44211cc6e949df284aa83f006f7fc" translate="yes" xml:space="preserve">
          <source>The extension given by the constant &lt;code&gt;dlext&lt;/code&gt; (&lt;code&gt;.so&lt;/code&gt;, &lt;code&gt;.dll&lt;/code&gt;, or &lt;code&gt;.dylib&lt;/code&gt;) can be omitted from the &lt;code&gt;libfile&lt;/code&gt; string, as it is automatically appended if needed. If &lt;code&gt;libfile&lt;/code&gt; is not an absolute path name, then the paths in the array &lt;code&gt;DL_LOAD_PATH&lt;/code&gt; are searched for &lt;code&gt;libfile&lt;/code&gt;, followed by the system load path.</source>
          <target state="translated">상수 &lt;code&gt;dlext&lt;/code&gt; ( &lt;code&gt;.so&lt;/code&gt; , &lt;code&gt;.dll&lt;/code&gt; 또는 &lt;code&gt;.dylib&lt;/code&gt; )로 제공되는 확장자 는 필요한 경우 자동으로 추가 되므로 &lt;code&gt;libfile&lt;/code&gt; 문자열 에서 생략 할 수 있습니다 . &lt;code&gt;libfile&lt;/code&gt; 이 절대 경로 이름이 아닌 경우 배열 &lt;code&gt;DL_LOAD_PATH&lt;/code&gt; 의 경로에서 libfile 을 검색 한 다음 시스템로드 경로 를 &lt;code&gt;libfile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36c16e65be4afc2c66cb3288c6300982f05c7ad1" translate="yes" xml:space="preserve">
          <source>The fact that the type of &lt;code&gt;m.a&lt;/code&gt; is known from &lt;code&gt;m&lt;/code&gt;'s type&amp;mdash;coupled with the fact that its type cannot change mid-function&amp;mdash;allows the compiler to generate highly-optimized code for objects like &lt;code&gt;m&lt;/code&gt; but not for objects like &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;m.a&lt;/code&gt; 의 유형이 &lt;code&gt;m&lt;/code&gt; 의 유형 에서 알려져 있다는 사실은 그 유형이 함수 중간에 변경 될 수 없다는 사실과 결합하여 컴파일러가 &lt;code&gt;m&lt;/code&gt; 과 같은 객체에 대해서는 최적화 된 코드를 생성 할 수 있지만 &lt;code&gt;t&lt;/code&gt; 와 같은 객체에는 적합하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c0c52690600fcbcb99da1f62c4bac2b9e5d6f697" translate="yes" xml:space="preserve">
          <source>The fallback definition is</source>
          <target state="translated">대체 정의는</target>
        </trans-unit>
        <trans-unit id="ee6beb39d94f4bf27bb085bd2200c292b19c5e9a" translate="yes" xml:space="preserve">
          <source>The fields represent:</source>
          <target state="translated">필드는 다음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c9020dd8336689ac7fec628824c2784dbf9a80fb" translate="yes" xml:space="preserve">
          <source>The file is passed via the stream argument, either as an open &lt;a href=&quot;../../base/io-network/index#Base.IOStream&quot;&gt;&lt;code&gt;IOStream&lt;/code&gt;&lt;/a&gt; or filename string. When you initialize the stream, use &lt;code&gt;&quot;r&quot;&lt;/code&gt; for a &quot;read-only&quot; array, and &lt;code&gt;&quot;w+&quot;&lt;/code&gt; to create a new array used to write values to disk.</source>
          <target state="translated">파일은 열린 &lt;a href=&quot;../../base/io-network/index#Base.IOStream&quot;&gt; &lt;code&gt;IOStream&lt;/code&gt; &lt;/a&gt; 또는 파일 이름 문자열 로 스트림 인수를 통해 전달됩니다 . 스트림을 초기화 할 때 &quot;읽기 전용&quot;배열에 &lt;code&gt;&quot;r&quot;&lt;/code&gt; 을 사용하고 값을 디스크에 쓰는 데 사용되는 새 배열을 작성하려면 &lt;code&gt;&quot;w+&quot;&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="689e05efadfddad191a25330c014009d3e84b447" translate="yes" xml:space="preserve">
          <source>The file-system preferred block size for the file</source>
          <target state="translated">파일의 파일 시스템 선호 블록 크기</target>
        </trans-unit>
        <trans-unit id="c3038fc2cf1255c7ec1e11b0a18b74e94018430a" translate="yes" xml:space="preserve">
          <source>The final call to &lt;code&gt;qsort&lt;/code&gt; looks like this:</source>
          <target state="translated">&lt;code&gt;qsort&lt;/code&gt; 에 대한 최종 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7d988c680830d3c098bed962d30d54cd701b74ad" translate="yes" xml:space="preserve">
          <source>The final problem which has still not been addressed is construction of self-referential objects, or more generally, recursive data structures. Since the fundamental difficulty may not be immediately obvious, let us briefly explain it. Consider the following recursive type declaration:</source>
          <target state="translated">여전히 해결되지 않은 마지막 문제는 자기 참조 객체 또는보다 일반적으로 재귀 데이터 구조의 구성입니다. 근본적인 어려움이 즉각적으로 명확하지 않을 수 있으므로 간단히 설명해 드리겠습니다. 다음 재귀 유형 선언을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="2c490723b997dd55f5ce00727bf52c98838be748" translate="yes" xml:space="preserve">
          <source>The first &quot;important&quot; line in this output is this one:</source>
          <target state="translated">이 출력에서 ​​첫 번째 &quot;중요한&quot;줄은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="355a754edd3ac1108f8aa47f09609e4797573a28" translate="yes" xml:space="preserve">
          <source>The first argument &lt;code&gt;old&lt;/code&gt; is the signature of the deprecated method, the second one &lt;code&gt;new&lt;/code&gt; is the call which replaces it. &lt;code&gt;@deprecate&lt;/code&gt; exports &lt;code&gt;old&lt;/code&gt; unless the optional third argument is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">첫 번째 인수 &lt;code&gt;old&lt;/code&gt; 중단 된 방법의 서명이며, 두 번째는 &lt;code&gt;new&lt;/code&gt; 그것을 대체하는 전화입니다. 선택적 세 번째 인수가 &lt;code&gt;false&lt;/code&gt; 가 아닌 경우 &lt;code&gt;@deprecate&lt;/code&gt; 는 &lt;code&gt;old&lt;/code&gt; 내보내기를 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="ca4a6f093dfc816b748358bcada908fd4397bf69" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt;&lt;code&gt;@cfunction&lt;/code&gt;&lt;/a&gt; can be marked with a &lt;code&gt;$&lt;/code&gt;, in which case the return value will instead be a &lt;code&gt;struct CFunction&lt;/code&gt; which closes over the argument. You must ensure that this return object is kept alive until all uses of it are done. The contents and code at the cfunction pointer will be erased via a &lt;a href=&quot;../../base/base/index#Base.finalizer&quot;&gt;&lt;code&gt;finalizer&lt;/code&gt;&lt;/a&gt; when this reference is dropped and atexit. This is not usually needed, since this functionality is not present in C, but can be useful for dealing with ill-designed APIs which don't provide a separate closure environment parameter.</source>
          <target state="translated">&lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt; &lt;code&gt;@cfunction&lt;/code&gt; &lt;/a&gt; 의 첫 번째 인수 는 &lt;code&gt;$&lt;/code&gt; 로 표시 될 수 있으며 ,이 경우 반환 값은 인수를 닫는 &lt;code&gt;struct CFunction&lt;/code&gt; 이됩니다. 이 리턴 오브젝트는 모든 사용이 완료 될 때까지 활성 상태로 유지되어야합니다. cfunction 포인터 컨텐츠 및 코드 비아 소거한다 &lt;a href=&quot;../../base/base/index#Base.finalizer&quot;&gt; &lt;code&gt;finalizer&lt;/code&gt; &lt;/a&gt; 이 참조가 제거 될 때와 atexit. 이 기능은 C에 존재하지 않기 때문에 일반적으로 필요하지 않지만 별도의 클로저 환경 매개 변수를 제공하지 않는 잘못 설계된 API를 처리하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="693dd527818a9b4cb2e07e46d1435896bbc1c434" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; can also be an expression evaluated at run time. In this case, the expression must evaluate to a &lt;code&gt;Ptr&lt;/code&gt;, which will be used as the address of the native function to call. This behavior occurs when the first &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; argument contains references to non-constants, such as local variables, function arguments, or non-constant globals.</source>
          <target state="translated">&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 의 첫 번째 인수 는 런타임시 평가되는 표현식 일 수도 있습니다. 이 경우 표현식은 &lt;code&gt;Ptr&lt;/code&gt; 로 평가되어야 하며 이는 호출 할 기본 함수의 주소로 사용됩니다. 첫 번째 &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 인수에 지역 변수, 함수 인수 또는 상수가 아닌 전역과 같은 상수가 아닌 참조가 포함 된 경우이 문제 가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="145bbc0abe5deab0a11d30eff56416193fa999ea" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;code&gt;remotecall&lt;/code&gt; is the function to call. Most parallel programming in Julia does not reference specific processes or the number of processes available, but &lt;code&gt;remotecall&lt;/code&gt; is considered a low-level interface providing finer control. The second argument to &lt;code&gt;remotecall&lt;/code&gt; is the &lt;code&gt;id&lt;/code&gt; of the process that will do the work, and the remaining arguments will be passed to the function being called.</source>
          <target state="translated">&lt;code&gt;remotecall&lt;/code&gt; 의 첫 번째 인수 는 호출 할 함수입니다. Julia의 대부분의 병렬 프로그래밍은 특정 프로세스 나 사용 가능한 프로세스 수를 참조하지 않지만 &lt;code&gt;remotecall&lt;/code&gt; 은보다 세밀한 제어를 제공하는 저수준 인터페이스로 간주됩니다. &lt;code&gt;remotecall&lt;/code&gt; 의 두 번째 인수 는 작업을 수행 할 프로세스 의 &lt;code&gt;id&lt;/code&gt; 이며 나머지 인수는 호출되는 함수에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="25e1aab2d5890f1ec3fee29d387628c8119eeb0c" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;code&gt;show&lt;/code&gt; can be an &lt;a href=&quot;#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; specifying output format properties. See &lt;a href=&quot;#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;show&lt;/code&gt; 할 첫 번째 인수는 출력 형식 특성을 지정 하는 &lt;a href=&quot;#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; 일&lt;/a&gt; 수 있습니다 . 자세한 내용은 &lt;a href=&quot;#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="52b90970f0dc891c8696d7672a072123d726419a" translate="yes" xml:space="preserve">
          <source>The first call to &lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt;&lt;code&gt;println&lt;/code&gt;&lt;/a&gt; is executed when &lt;a href=&quot;../../base/base/index#Base.macroexpand&quot;&gt;&lt;code&gt;macroexpand&lt;/code&gt;&lt;/a&gt; is called. The resulting expression contains &lt;em&gt;only&lt;/em&gt; the second &lt;code&gt;println&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.macroexpand&quot;&gt; &lt;code&gt;macroexpand&lt;/code&gt; &lt;/a&gt; 가 호출 될 때 &lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt; &lt;code&gt;println&lt;/code&gt; 에&lt;/a&gt; 대한 첫 번째 호출 이 실행됩니다 . 결과 표현식에는 두 번째 &lt;code&gt;println&lt;/code&gt; &lt;em&gt;만&lt;/em&gt; 포함 &lt;em&gt;됩니다&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8464368be55c0ee0f473e53693ff139c3f5a4a18" translate="yes" xml:space="preserve">
          <source>The first case works, because the last character &lt;code&gt;y&lt;/code&gt; and the space are one-byte characters, whereas &lt;code&gt;end-2&lt;/code&gt; indexes into the middle of the &lt;code&gt;&amp;exist;&lt;/code&gt; multibyte representation. The correct way for this case is using &lt;code&gt;prevind(s, lastindex(s), 2)&lt;/code&gt; or, if you're using that value to index into &lt;code&gt;s&lt;/code&gt; you can write &lt;code&gt;s[prevind(s, end, 2)]&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; expands to &lt;code&gt;lastindex(s)&lt;/code&gt;.</source>
          <target state="translated">첫 번째 경우는 마지막 문자 &lt;code&gt;y&lt;/code&gt; 와 공백이 1 바이트 문자이고 &lt;code&gt;end-2&lt;/code&gt; 는 &lt;code&gt;&amp;exist;&lt;/code&gt; 멀티 바이트 표현 의 중간에 인덱스 되기 때문에 작동합니다 . 이 경우에 대한 올바른 방법은 사용 &lt;code&gt;prevind(s, lastindex(s), 2)&lt;/code&gt; 당신이로 인덱스로 그 값을 사용하는 경우, 또는 &lt;code&gt;s&lt;/code&gt; 당신이 쓸 수있는 &lt;code&gt;s[prevind(s, end, 2)]&lt;/code&gt; 및 &lt;code&gt;end&lt;/code&gt; 으로 확장을 &lt;code&gt;lastindex(s)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cae7754ed7d4e8921dc21019e00cb20a90b09dbc" translate="yes" xml:space="preserve">
          <source>The first construct is used when you need the value, but not index, of each element. In the second construct, &lt;code&gt;i&lt;/code&gt; will be an &lt;code&gt;Int&lt;/code&gt; if &lt;code&gt;A&lt;/code&gt; is an array type with fast linear indexing; otherwise, it will be a &lt;code&gt;CartesianIndex&lt;/code&gt;:</source>
          <target state="translated">첫 번째 구문은 각 요소의 값은 필요하지만 색인은 필요하지 않을 때 사용됩니다. 두 번째 구문에서 &lt;code&gt;A&lt;/code&gt; 가 빠른 선형 인덱싱이있는 배열 유형 인 경우 &lt;code&gt;i&lt;/code&gt; 는 &lt;code&gt;Int&lt;/code&gt; 가 됩니다 . 그렇지 않으면 &lt;code&gt;CartesianIndex&lt;/code&gt; 가됩니다 :</target>
        </trans-unit>
        <trans-unit id="1a131f32e4f6815b22742934540634fef42489da" translate="yes" xml:space="preserve">
          <source>The first entry is the &quot;user depot&quot; and should be writable by and owned by the current user. The user depot is where: registries are cloned, new package versions are installed, named environments are created and updated, package repos are cloned, newly compiled package image files are saved, log files are written, development packages are checked out by default, and global configuration data is saved. Later entries in the depot path are treated as read-only and are appropriate for registries, packages, etc. installed and managed by system administrators.</source>
          <target state="translated">첫 번째 항목은 &quot;사용자 저장소&quot;이며 현재 사용자가 쓸 수 있고 소유해야합니다. 사용자 저장소의 위치 : 레지스트리 복제, 새 패키지 버전 설치, 명명 된 환경 작성 및 업데이트, 패키지 저장소 제거, 새로 컴파일 된 패키지 이미지 파일 저장, 로그 파일 작성, 기본적으로 개발 패키지 확인 및 글로벌 구성 데이터가 저장됩니다. 저장소 경로의 이후 항목은 읽기 전용으로 취급되며 시스템 관리자가 설치 및 관리하는 레지스트리, 패키지 등에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="006a5d47461c1a2f566eaae2f91fca6d12ba4594" translate="yes" xml:space="preserve">
          <source>The first five control flow mechanisms are standard to high-level programming languages. &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;s are not so standard: they provide non-local control flow, making it possible to switch between temporarily-suspended computations. This is a powerful construct: both exception handling and cooperative multitasking are implemented in Julia using tasks. Everyday programming requires no direct usage of tasks, but certain problems can be solved much more easily by using tasks.</source>
          <target state="translated">처음 5 개의 제어 흐름 메커니즘은 표준에서 고급 프로그래밍 언어입니다. &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 은 그렇게 표준 적이 지 않습니다. 로컬이 아닌 제어 흐름을 제공하여 일시적으로 중단 된 계산간에 전환 할 수 있습니다. 이것은 강력한 구성입니다. 예외 처리와 협업 멀티 태스킹은 모두 Julia를 사용하여 작업을 구현합니다. 일상적인 프로그래밍 작업을 직접 수행 할 필요는 없지만 작업을 사용하면 특정 문제를 훨씬 쉽게 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc720da072f28a4dbfd483b203295a21a9e3bf91" translate="yes" xml:space="preserve">
          <source>The first index</source>
          <target state="translated">첫 번째 색인</target>
        </trans-unit>
        <trans-unit id="bb11ec038c2596553227120950a5afbedeee7655" translate="yes" xml:space="preserve">
          <source>The first line &amp;ndash; &lt;code&gt;struct OurRational{T&amp;lt;:Integer} &amp;lt;: Real&lt;/code&gt; &amp;ndash; declares that &lt;code&gt;OurRational&lt;/code&gt; takes one type parameter of an integer type, and is itself a real type. The field declarations &lt;code&gt;num::T&lt;/code&gt; and &lt;code&gt;den::T&lt;/code&gt; indicate that the data held in a &lt;code&gt;OurRational{T}&lt;/code&gt; object are a pair of integers of type &lt;code&gt;T&lt;/code&gt;, one representing the rational value's numerator and the other representing its denominator.</source>
          <target state="translated">첫 번째 행 &amp;ndash; &lt;code&gt;struct OurRational{T&amp;lt;:Integer} &amp;lt;: Real&lt;/code&gt; &amp;ndash; &lt;code&gt;OurRational&lt;/code&gt; 은 정수 유형의 한 유형 매개 변수를 취하며 그 자체가 실제 유형 임을 선언합니다 . 필드 선언 &lt;code&gt;num::T&lt;/code&gt; 와 &lt;code&gt;den::T&lt;/code&gt; A의 개최 데이터를 나타냅니다 &lt;code&gt;OurRational{T}&lt;/code&gt; 오브젝트 유형의 정수의 쌍입니다 &lt;code&gt;T&lt;/code&gt; 의 분모를 나타내는 합리적인 값의 분자를 나타내는 하나의 다른.</target>
        </trans-unit>
        <trans-unit id="427adf0e5c19944f265b6711e004071ffee6d958" translate="yes" xml:space="preserve">
          <source>The first line shows that 80 backtraces were taken at line 73 of &lt;code&gt;event.jl&lt;/code&gt;, but it's not that this line was &quot;expensive&quot; on its own: the third line reveals that all 80 of these backtraces were actually triggered inside its call to &lt;code&gt;eval_user_input&lt;/code&gt;, and so on. To find out which operations are actually taking the time, we need to look deeper in the call chain.</source>
          <target state="translated">첫 번째 줄은 &lt;code&gt;event.jl&lt;/code&gt; 의 73 번째 줄에서 80 개의 역 추적이 취해 졌음 을 보여 주지만 ,이 줄이 자체적으로 &quot;비싸다&quot;는 것은 아닙니다. 세 번째 줄은이 역 추적 80 개 모두가 실제로 &lt;code&gt;eval_user_input&lt;/code&gt; 을 호출 할 때 트리거되었다는 것을 보여줍니다 . 등등. 실제로 시간이 걸리는 작업을 찾으려면 콜 체인을 자세히 살펴 봐야합니다.</target>
        </trans-unit>
        <trans-unit id="37442d0cb92e69637999d8ebca28303617dca96e" translate="yes" xml:space="preserve">
          <source>The first method applies whenever both arguments are of the same concrete type, regardless of what type that is, while the second method acts as a catch-all, covering all other cases. Thus, overall, this defines a boolean function that checks whether its two arguments are of the same type:</source>
          <target state="translated">첫 번째 방법은 유형에 관계없이 두 인수가 모두 동일한 구체적인 유형일 때 적용되며 두 번째 방법은 다른 모든 경우를 포괄하는 포괄적 인 역할을합니다. 따라서 전체적으로 두 인수가 동일한 유형인지 확인하는 부울 함수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="babb1cbcd790c4e72ac9f6036b92d0c0da3483a5" translate="yes" xml:space="preserve">
          <source>The first rule says that promoting a rational number with any other integer type promotes to a rational type whose numerator/denominator type is the result of promotion of its numerator/denominator type with the other integer type. The second rule applies the same logic to two different types of rational numbers, resulting in a rational of the promotion of their respective numerator/denominator types. The third and final rule dictates that promoting a rational with a float results in the same type as promoting the numerator/denominator type with the float.</source>
          <target state="translated">첫 번째 규칙에 따르면 다른 정수 유형으로 유리수를 승격하면 분자 / 분모 유형이 다른 정수 유형으로 분자 / 분모 유형을 승격 한 합리적 유형으로 승격됩니다. 두 번째 규칙은 동일한 논리를 두 가지 다른 유형의 유리수에 적용하여 각 분자 / 분모 유형의 승격을 합리적으로 만듭니다. 세 번째이자 마지막 규칙은 float로 유리수를 승격시키는 것은 float로 분자 / 분모 유형을 승격시키는 것과 같은 유형이된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5020af03736f636ddf8f18f7a30cb8b1c77d29b4" translate="yes" xml:space="preserve">
          <source>The first thing that has to be done before calling any other Julia C function is to initialize Julia. This is done by calling &lt;code&gt;jl_init&lt;/code&gt;, which tries to automatically determine Julia's install location. If you need to specify a custom location, or specify which system image to load, use &lt;code&gt;jl_init_with_image&lt;/code&gt; instead.</source>
          <target state="translated">다른 Julia C 함수를 호출하기 전에 가장 먼저해야 할 일은 Julia를 초기화하는 것입니다. Julia의 설치 위치를 자동으로 결정 하는 &lt;code&gt;jl_init&lt;/code&gt; 를 호출 하면됩니다. 사용자 정의 위치를 ​​지정하거나로드 할 시스템 이미지를 지정 &lt;code&gt;jl_init_with_image&lt;/code&gt; 대신 jl_init_with_image를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="823f93752a3686f8e2124abf1332680955d50534" translate="yes" xml:space="preserve">
          <source>The first thing to note is that the above argument declarations are equivalent to &lt;code&gt;x::Any&lt;/code&gt; and &lt;code&gt;y::Any&lt;/code&gt;. When this function is invoked, say as &lt;code&gt;myplus(2,5)&lt;/code&gt;, the dispatcher chooses the most specific method named &lt;code&gt;myplus&lt;/code&gt; that matches the given arguments. (See &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt; for more information on multiple dispatch.)</source>
          <target state="translated">가장 먼저 주목할 것은 위의 인수 선언은 &lt;code&gt;x::Any&lt;/code&gt; 및 &lt;code&gt;y::Any&lt;/code&gt; 와 동일하다는 것 입니다. 이 함수가 호출되면 (예 : &lt;code&gt;myplus(2,5)&lt;/code&gt; 디스패처 는 주어진 인수와 일치하는 &lt;code&gt;myplus&lt;/code&gt; 라는 가장 구체적인 메소드를 선택합니다 . 다중 디스패치에 대한 자세한 정보는 &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;메소드&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a6f07b43794fd555596c18f4ead21c7719a2dcd3" translate="yes" xml:space="preserve">
          <source>The first version of the code forms a string, then writes it to the file, while the second version writes values directly to the file. Also notice that in some cases string interpolation can be harder to read. Consider:</source>
          <target state="translated">코드의 첫 번째 버전은 문자열을 형성 한 다음 파일에 쓰고 두 번째 버전은 파일에 직접 값을 씁니다. 경우에 따라 문자열 보간을 읽기가 더 어려울 수도 있습니다. 치다:</target>
        </trans-unit>
        <trans-unit id="7b79b92115c47e04b621f66bea7584e8b8cc8d6b" translate="yes" xml:space="preserve">
          <source>The floating-point literal expression &lt;code&gt;1e10&lt;/code&gt; could be interpreted as the numeric literal &lt;code&gt;1&lt;/code&gt; multiplied by the variable &lt;code&gt;e10&lt;/code&gt;, and similarly with the equivalent &lt;code&gt;E&lt;/code&gt; form.</source>
          <target state="translated">부동 소수점 리터럴 표현식 &lt;code&gt;1e10&lt;/code&gt; 은 숫자 리터럴 &lt;code&gt;1&lt;/code&gt; 에 변수 &lt;code&gt;e10&lt;/code&gt; 을 곱한 것과 동등한 &lt;code&gt;E&lt;/code&gt; 형식을 갖는 것으로 해석 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b8f774bd2a3cc1859a12b8ce9ea22d04daec926b" translate="yes" xml:space="preserve">
          <source>The floored quotient and modulus after division. Equivalent to &lt;code&gt;(fld(x,y), mod(x,y))&lt;/code&gt;.</source>
          <target state="translated">분할 후 바닥 지수 및 계수. 동등 &lt;code&gt;(fld(x,y), mod(x,y))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc58e18ac764f385326b970e654dea814c444fa3" translate="yes" xml:space="preserve">
          <source>The folder &lt;code&gt;clustermanager/0mq&lt;/code&gt; in the &lt;a href=&quot;https://github.com/JuliaAttic/Examples&quot;&gt;Examples repository&lt;/a&gt; contains an example of using ZeroMQ to connect Julia workers in a star topology with a 0MQ broker in the middle. Note: The Julia processes are still all &lt;em&gt;logically&lt;/em&gt; connected to each other&amp;ndash;any worker can message any other worker directly without any awareness of 0MQ being used as the transport layer.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/JuliaAttic/Examples&quot;&gt;예제 저장소&lt;/a&gt; 의 &lt;code&gt;clustermanager/0mq&lt;/code&gt; 폴더 에는 ZeroMQ를 사용하여 스타 토폴로지의 Julia 작업자를 중간에 0MQ 브로커와 연결하는 예제가 포함되어 있습니다. 참고 : Julia 프로세스는 여전히 모든 &lt;em&gt;논리적으로&lt;/em&gt; 서로 연결되어 있습니다. 모든 작업자는 전송 계층으로 0MQ를 사용하지 않고도 다른 작업자에게 직접 메시지를 보낼 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a25bab23609fe72a03f9f2d28cbc6e4cfaac93b5" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic#Arithmetic_operations&quot;&gt;arithmetic operators&lt;/a&gt; are supported on all primitive numeric types:</source>
          <target state="translated">모든 기본 숫자 유형에서 다음 &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic#Arithmetic_operations&quot;&gt;산술 연산자&lt;/a&gt; 가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="b432537d382d58fcb2012895b80fa177f57617f4" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://en.wikipedia.org/wiki/Bitwise_operation#Bitwise_operators&quot;&gt;bitwise operators&lt;/a&gt; are supported on all primitive integer types:</source>
          <target state="translated">다음과 같은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Bitwise_operation#Bitwise_operators&quot;&gt;비트 연산자&lt;/a&gt; 는 모든 기본 정수 유형에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="bc2ce27e5cd51f5b5da2d26eef20e592177e82dd" translate="yes" xml:space="preserve">
          <source>The following Julia code calls &lt;code&gt;dist&lt;/code&gt; using &lt;code&gt;ccall&lt;/code&gt;:</source>
          <target state="translated">다음 Julia 코드는 &lt;code&gt;ccall&lt;/code&gt; 을 사용하여 &lt;code&gt;dist&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="82ab1c7eae6116d2e86f4fd6447f19f5008f2767" translate="yes" xml:space="preserve">
          <source>The following are Julia's primitive numeric types:</source>
          <target state="translated">다음은 Julia의 기본 숫자 유형입니다.</target>
        </trans-unit>
        <trans-unit id="68261312da3f6e4277114d21e46489769870f01a" translate="yes" xml:space="preserve">
          <source>The following arguments, if any, are the actual argument values passed to the function.</source>
          <target state="translated">다음 인수는 함수에 전달 된 실제 인수 값입니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="345825a433cae3afd4ca7643a01203ee8503ec4c" translate="yes" xml:space="preserve">
          <source>The following elements can be written either at the &quot;toplevel&quot; of a document or within another &quot;toplevel&quot; element.</source>
          <target state="translated">다음 요소는 문서의 &quot;최상위&quot;또는 다른 &quot;최상위&quot;요소 내에 작성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5790b1d96d0b783ee001251802dd3d3773c38e07" translate="yes" xml:space="preserve">
          <source>The following escape sequences are recognised:</source>
          <target state="translated">다음과 같은 이스케이프 시퀀스가 ​​인식됩니다.</target>
        </trans-unit>
        <trans-unit id="b2e62d45eb7d1c7cb2ac8b8faa743869642b4084" translate="yes" xml:space="preserve">
          <source>The following example computes a weighted average of the current element and its left and right neighbor along a 1-d grid. :</source>
          <target state="translated">다음 예제는 1-d 그리드를 따라 현재 요소와 왼쪽 및 오른쪽 이웃의 가중 평균을 계산합니다. :</target>
        </trans-unit>
        <trans-unit id="07c71a4306d82cac91450f4de662495a1563cd2f" translate="yes" xml:space="preserve">
          <source>The following example computes the QR decomposition of a small section of a larger array, without creating any temporaries, and by calling the appropriate LAPACK function with the right leading dimension size and stride parameters.</source>
          <target state="translated">다음 예제는 임시를 작성하지 않고 올바른 선행 치수 크기 및 보폭 매개 변수를 사용하여 적절한 LAPACK 함수를 호출하여 더 큰 배열의 작은 섹션의 QR 분해를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="01c45a39447b88a2e0d45df263308e82a86e4712" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the major features of modules. It is not meant to be run, but is shown for illustrative purposes:</source>
          <target state="translated">다음 예는 모듈의 주요 기능을 보여줍니다. 실행되도록 의도 된 것이 아니라 설명 목적으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ec34fbe859ef32bab5a71865f07de40a61bead9c" translate="yes" xml:space="preserve">
          <source>The following examples highlight execution in different tasks by returning the &lt;code&gt;objectid&lt;/code&gt; of the tasks in which the mapping function is executed.</source>
          <target state="translated">다음 예제 는 맵핑 기능이 실행되는 태스크 의 &lt;code&gt;objectid&lt;/code&gt; 를 리턴하여 다른 태스크에서의 실행을 강조 합니다.</target>
        </trans-unit>
        <trans-unit id="874609aa4f87e9365e65a6b29283f60a85fb17ac" translate="yes" xml:space="preserve">
          <source>The following examples may help you interpret expressions marked as containing non-leaf types:</source>
          <target state="translated">다음 예제는 리프가 아닌 유형을 포함하는 것으로 표시된 표현식을 해석하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbdf8c8b616fe2394336d97bc9a1e9b4526f4626" translate="yes" xml:space="preserve">
          <source>The following examples show the different forms.</source>
          <target state="translated">다음 예는 다른 형식을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e0233afcec03abf55b61a44d6697627a2028159d" translate="yes" xml:space="preserve">
          <source>The following functions are available for &lt;code&gt;BunchKaufman&lt;/code&gt; objects: &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;#LinearAlgebra.issymmetric&quot;&gt;&lt;code&gt;issymmetric&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.ishermitian&quot;&gt;&lt;code&gt;ishermitian&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;BunchKaufman&lt;/code&gt; 객체에는 &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;inv&lt;/code&gt; , &lt;a href=&quot;#LinearAlgebra.issymmetric&quot;&gt; &lt;code&gt;issymmetric&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#LinearAlgebra.ishermitian&quot;&gt; &lt;code&gt;ishermitian&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="624545d56fb5f27fa75152ac7cc2635666c3e206" translate="yes" xml:space="preserve">
          <source>The following functions are available for &lt;code&gt;Eigen&lt;/code&gt; objects: &lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#LinearAlgebra.isposdef&quot;&gt;&lt;code&gt;isposdef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">에 대한 다음과 같은 기능을 사용할 수 있습니다 &lt;code&gt;Eigen&lt;/code&gt; 객체 : &lt;code&gt;inv&lt;/code&gt; , &lt;a href=&quot;#LinearAlgebra.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#LinearAlgebra.isposdef&quot;&gt; &lt;code&gt;isposdef&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f1aea27103439af78084bb11124346f279815f32" translate="yes" xml:space="preserve">
          <source>The following functions are available for the &lt;code&gt;QR&lt;/code&gt; objects: &lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;\&lt;/code&gt;. When &lt;code&gt;A&lt;/code&gt; is rectangular, &lt;code&gt;\&lt;/code&gt; will return a least squares solution and if the solution is not unique, the one with smallest norm is returned. When &lt;code&gt;A&lt;/code&gt; is not full rank, factorization with (column) pivoting is required to obtain a minimum norm solution.</source>
          <target state="translated">&lt;code&gt;QR&lt;/code&gt; 객체 에는 다음 기능을 사용할 수 있습니다 : &lt;code&gt;inv&lt;/code&gt; , &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;\&lt;/code&gt; . 때 &lt;code&gt;A&lt;/code&gt; 는 직사각형, &lt;code&gt;\&lt;/code&gt; 최소 제곱 솔루션을 반환하고이 솔루션은 고유하지 않은 경우, 최소 규범과 하나가 반환됩니다. 경우 &lt;code&gt;A&lt;/code&gt; 는 (열) 회동은 최소 표준 용액을 얻기 위해 필요한 전체 랭크 인수 아니다.</target>
        </trans-unit>
        <trans-unit id="aabc44011e588107ac199e54e743b25f507c9ed0" translate="yes" xml:space="preserve">
          <source>The following functions are not exported:</source>
          <target state="translated">다음 기능은 내보내지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="688d351a0c5736fa7ecff6e47939996801847a5a" translate="yes" xml:space="preserve">
          <source>The following language constructs call &lt;code&gt;convert&lt;/code&gt;:</source>
          <target state="translated">다음 언어는 전화 &lt;code&gt;convert&lt;/code&gt; 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="6c5e57131238ccfda9b38e0c3969a02ae25bed8d" translate="yes" xml:space="preserve">
          <source>The following methods and types in &lt;code&gt;Base.StackTraces&lt;/code&gt; are not exported and need to be called e.g. as &lt;code&gt;StackTraces.lookup(ptr)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Base.StackTraces&lt;/code&gt; 의 다음 메소드 및 유형은 내 보내지 않으며 예를 들어 &lt;code&gt;StackTraces.lookup(ptr)&lt;/code&gt; 로 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="427d5751feb1ea6470872d5f773b472a734eb30c" translate="yes" xml:space="preserve">
          <source>The following methods are described as &quot;unsafe&quot; because a bad pointer or type declaration can cause Julia to terminate abruptly.</source>
          <target state="translated">잘못된 포인터 또는 형식 선언으로 인해 Julia가 갑자기 종료 될 수 있으므로 다음 방법은 &quot;안전하지 않은&quot;것으로 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="b0ebcfaf65e09f2421f1536d1962299cfa2d23fa" translate="yes" xml:space="preserve">
          <source>The following operators are supported for arrays:</source>
          <target state="translated">배열에는 다음 연산자가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="61cb6687852400c8b9d8a7c3529a66703d4cce18" translate="yes" xml:space="preserve">
          <source>The following properties are in common use:</source>
          <target state="translated">다음 속성이 일반적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d1b72ce471ac18a5159131679678a4b35625017b" translate="yes" xml:space="preserve">
          <source>The following rules and examples pertain to local scopes. A newly introduced variable in a local scope cannot be referenced by a parent scope. For example, here the $z$ is not introduced into the top-level scope:</source>
          <target state="translated">다음 규칙 및 예는 로컬 범위와 관련이 있습니다. 로컬 범위에서 새로 도입 된 변수는 상위 범위에서 참조 할 수 없습니다. 예를 들어, $ z $는 최상위 범위에 도입되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="b337c7ef95094018464c8f26d41814785e93faec" translate="yes" xml:space="preserve">
          <source>The following sections explain a few aspects of idiomatic Julia coding style. None of these rules are absolute; they are only suggestions to help familiarize you with the language and to help you choose among alternative designs.</source>
          <target state="translated">다음 섹션에서는 관용적 Julia 코딩 스타일의 몇 가지 측면을 설명합니다. 이러한 규칙 중 어느 것도 절대적인 것은 아닙니다. 그것들은 언어에 익숙해지고 대안 디자인 중에서 선택하도록 돕기위한 제안 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="599c61734f3be9adb8efdea5a3e2879b8d0d65f5" translate="yes" xml:space="preserve">
          <source>The following table gives a correspondence between built-in methods on sparse matrices and their corresponding methods on dense matrix types. In general, methods that generate sparse matrices differ from their dense counterparts in that the resulting matrix follows the same sparsity pattern as a given sparse matrix &lt;code&gt;S&lt;/code&gt;, or that the resulting sparse matrix has density &lt;code&gt;d&lt;/code&gt;, i.e. each matrix element has a probability &lt;code&gt;d&lt;/code&gt; of being non-zero.</source>
          <target state="translated">다음 표는 희소 행렬에 내장 된 방법과 밀도가 높은 행렬 유형에 대한 해당 방법을 나타냅니다. 일반적으로 희소 행렬을 생성하는 방법은 결과 행렬이 주어진 희소 행렬 &lt;code&gt;S&lt;/code&gt; 와 동일한 희소성 패턴을 따르 거나 결과 희소 행렬에 밀도 &lt;code&gt;d&lt;/code&gt; 가 있다는 것 , 즉 각 행렬 요소의 확률 &lt;code&gt;d&lt;/code&gt; 가 0이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="2850e916b8328a8067cb56753c2fae6f207d9a41" translate="yes" xml:space="preserve">
          <source>The following table lists Unicode characters that can be entered via tab completion of LaTeX-like abbreviations in the Julia REPL (and in various other editing environments). You can also get information on how to type a symbol by entering it in the REPL help, i.e. by typing &lt;code&gt;?&lt;/code&gt; and then entering the symbol in the REPL (e.g., by copy-paste from somewhere you saw the symbol).</source>
          <target state="translated">다음 표는 Julia REPL (및 기타 다양한 편집 환경)에서 LaTeX와 유사한 약어의 탭 완성을 통해 입력 할 수있는 유니 코드 문자를 나열합니다. REPL 도움말에 기호를 입력하여 (예 : &lt;code&gt;?&lt;/code&gt; ) 를 입력하여 기호를 입력하는 방법에 대한 정보를 얻을 수도 있습니다 . 그런 다음 REPL에 기호를 입력합니다 (예 : 기호를 본 곳에서 복사하여 붙여 넣기).</target>
        </trans-unit>
        <trans-unit id="84caf0f2b4e520eb1362c7d90034a53ce384352e" translate="yes" xml:space="preserve">
          <source>The following table summarizes the types of matrix factorizations that have been implemented in Julia. Details of their associated methods can be found in the &lt;a href=&quot;#Standard-Functions-1&quot;&gt;Standard Functions&lt;/a&gt; section of the Linear Algebra documentation.</source>
          <target state="translated">다음 표는 Julia에서 구현 된 행렬 인수 분해 유형을 요약합니다. 관련 방법에 대한 자세한 내용은 선형 대수 설명서 의 &lt;a href=&quot;#Standard-Functions-1&quot;&gt;표준 함수&lt;/a&gt; 섹션 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a5e3ae439be1705d14dc31df2b803cc4528033bf" translate="yes" xml:space="preserve">
          <source>The following tables summarize the types of special matrices that have been implemented in Julia, as well as whether hooks to various optimized methods for them in LAPACK are available.</source>
          <target state="translated">다음 표는 Julia에서 구현 된 특수 행렬 유형과 LAPACK에서 다양한 최적화 된 방법에 대한 후크를 사용할 수 있는지 여부를 요약합니다.</target>
        </trans-unit>
        <trans-unit id="58787cfe45db809926391f964f8c2fe50eb9c66e" translate="yes" xml:space="preserve">
          <source>The following two-word sequences are reserved: &lt;code&gt;abstract type&lt;/code&gt;, &lt;code&gt;mutable struct&lt;/code&gt;, &lt;code&gt;primitive type&lt;/code&gt;. However, you can create variables with names: &lt;code&gt;abstract&lt;/code&gt;, &lt;code&gt;mutable&lt;/code&gt;, &lt;code&gt;primitive&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">다음 두 단어 시퀀스가 ​​예약되어 있습니다 : &lt;code&gt;abstract type&lt;/code&gt; , &lt;code&gt;mutable struct&lt;/code&gt; , &lt;code&gt;primitive type&lt;/code&gt; . 그러나 &lt;code&gt;abstract&lt;/code&gt; , &lt;code&gt;mutable&lt;/code&gt; , &lt;code&gt;primitive&lt;/code&gt; 및 &lt;code&gt;type&lt;/code&gt; 이름으로 변수를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c16965f50c24120006902ac240b6d5249b8840ca" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.answer_color()&lt;/code&gt; (default: normal, &lt;code&gt;&quot;\033[0m&quot;&lt;/code&gt;) that output should have at the terminal.</source>
          <target state="translated">출력이 터미널에 있어야 하는 형식 &lt;code&gt;Base.answer_color()&lt;/code&gt; (기본값 : normal, &lt;code&gt;&quot;\033[0m&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="2a94f6ed982371cc454e13d3c41d22bd28f7000c" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.error_color()&lt;/code&gt; (default: light red, &lt;code&gt;&quot;\033[91m&quot;&lt;/code&gt;) that errors should have at the terminal.</source>
          <target state="translated">터미널에 오류가 있어야 하는 형식 &lt;code&gt;Base.error_color()&lt;/code&gt; (기본값 : 밝은 빨강, &lt;code&gt;&quot;\033[91m&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5bedb24b2b2a4f0d544b13331782037e6b751d7c" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.info_color()&lt;/code&gt; (default: cyan, &lt;code&gt;&quot;\033[36m&quot;&lt;/code&gt;) that info should have at the terminal.</source>
          <target state="translated">정보가 터미널에 있어야하는 &lt;code&gt;Base.info_color()&lt;/code&gt; 형식 (기본값 : cyan, &lt;code&gt;&quot;\033[36m&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9abdd1879aac44fbed37a23e8cd8c9521c6a3a7b" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.input_color()&lt;/code&gt; (default: normal, &lt;code&gt;&quot;\033[0m&quot;&lt;/code&gt;) that input should have at the terminal.</source>
          <target state="translated">터미널에서 입력해야하는 형식 &lt;code&gt;Base.input_color()&lt;/code&gt; (기본값 : normal, &lt;code&gt;&quot;\033[0m&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="5c3246893833440c6ee277a6f4469b2f678db3a7" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.stackframe_function_color()&lt;/code&gt; (default: bold, &lt;code&gt;&quot;\033[1m&quot;&lt;/code&gt;) that function calls should have during a stack trace at the terminal.</source>
          <target state="translated">함수 호출에 대한 형식 &lt;code&gt;Base.stackframe_function_color()&lt;/code&gt; (기본값 : 굵게, &lt;code&gt;&quot;\033[1m&quot;&lt;/code&gt; )은 터미널에서 스택 추적 중에 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="276edac3df59db618aba660c48a61b72521725f5" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.stackframe_lineinfo_color()&lt;/code&gt; (default: bold, &lt;code&gt;&quot;\033[1m&quot;&lt;/code&gt;) that line info should have during a stack trace at the terminal.</source>
          <target state="translated">터미널에서 스택 추적 중에 행 정보가 있어야하는 형식 &lt;code&gt;Base.stackframe_lineinfo_color()&lt;/code&gt; (기본값 : 굵게, &lt;code&gt;&quot;\033[1m&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5a3d58af274070ed561a7473fe7be9c81a95ede6" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.warn_color()&lt;/code&gt; (default: yellow, &lt;code&gt;&quot;\033[93m&quot;&lt;/code&gt;) that warnings should have at the terminal.</source>
          <target state="translated">서식 &lt;code&gt;Base.warn_color()&lt;/code&gt; (기본값 : 노란색, &lt;code&gt;&quot;\033[93m&quot;&lt;/code&gt; ) 경고가 터미널에 있어야한다고.</target>
        </trans-unit>
        <trans-unit id="e430bf906d90ec3cbe26e6641c11eeda24fe35ca" translate="yes" xml:space="preserve">
          <source>The former is a single character value of type &lt;code&gt;Char&lt;/code&gt;, while the latter is a string value that happens to contain only a single character. In Julia these are very different things.</source>
          <target state="translated">전자는 &lt;code&gt;Char&lt;/code&gt; 유형의 단일 문자 값이고 후자는 단일 문자 만 포함하는 문자열 값입니다. 줄리아에서는 이것들이 매우 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d152dae5600534a9646e1a87a36f09f36dd3ded5" translate="yes" xml:space="preserve">
          <source>The former results in a single network round-trip to every worker, while the latter results in two network calls - first by the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt; and the second due to the &lt;code&gt;fetch&lt;/code&gt; (or even a &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;). The &lt;code&gt;fetch&lt;/code&gt;/&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; is also being executed serially resulting in an overall poorer performance.</source>
          <target state="translated">전자는 모든 작업자에게 단일 네트워크 왕복을하는 반면, 후자는 먼저 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt; &lt;code&gt;@spawnat&lt;/code&gt; 에&lt;/a&gt; 의한 두 번째 네트워크 호출 과 &lt;code&gt;fetch&lt;/code&gt; (또는 &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; ) 로 인한 두 번째 네트워크 호출을 발생시킵니다 . &lt;code&gt;fetch&lt;/code&gt; / &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 또한 전체적으로 빈약 한 성능을 초래 순차적으로 실행되고있다.</target>
        </trans-unit>
        <trans-unit id="d93e33c90f8c053ee253be6b3d20b4b263f781d7" translate="yes" xml:space="preserve">
          <source>The fully expanded value of &lt;code&gt;LOAD_PATH&lt;/code&gt; that is searched for projects and packages can be seen by calling the &lt;code&gt;Base.load_path()&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;Base.load_path()&lt;/code&gt; 함수를 호출하면 프로젝트 및 패키지를 검색 하는 &lt;code&gt;LOAD_PATH&lt;/code&gt; 의 완전히 확장 된 값을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="53cd7e3be35b834ce5e0e038f9eb6daebb41c365" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;count_heads&lt;/code&gt; simply adds together &lt;code&gt;n&lt;/code&gt; random bits. Here is how we can perform some trials on two machines, and add together the results:</source>
          <target state="translated">&lt;code&gt;count_heads&lt;/code&gt; 함수 는 단순히 &lt;code&gt;n&lt;/code&gt; 개의 랜덤 비트를 더합니다. 다음은 두 컴퓨터에서 몇 가지 시험을 수행하고 결과를 함께 추가하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="1a7009ac781780ee28678319854f5347c9495c13" translate="yes" xml:space="preserve">
          <source>The function call grew beyond the size of the call stack. This usually happens when a call recurses infinitely.</source>
          <target state="translated">함수 호출은 호출 스택의 크기를 넘어 섰습니다. 일반적으로 통화가 무한정 반복 될 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="da6b2e5a2ff44122d7db169754c14ee6b172e967" translate="yes" xml:space="preserve">
          <source>The function in which &lt;code&gt;@boundscheck&lt;/code&gt; is written must be inlined into its caller in order for &lt;code&gt;@inbounds&lt;/code&gt; to have effect.</source>
          <target state="translated">하는 기능 &lt;code&gt;@boundscheck&lt;/code&gt; 가 기록된다 위해서는 호출자에 인라인해야 &lt;code&gt;@inbounds&lt;/code&gt; 이 효력을 갖는다.</target>
        </trans-unit>
        <trans-unit id="39d7cf55fabb709098be0379cf1a36954e7ad2fc" translate="yes" xml:space="preserve">
          <source>The function parameter &lt;code&gt;f&lt;/code&gt; should have following signature:</source>
          <target state="translated">함수 매개 변수 &lt;code&gt;f&lt;/code&gt; 에는 다음과 같은 서명이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c1a0f9cdfffaafbbc345f4ef6dcd681fce922423" translate="yes" xml:space="preserve">
          <source>The function reads the cookie from stdin if required, and listens on a free port (or if specified, the port in the &lt;code&gt;--bind-to&lt;/code&gt; command line option) and schedules tasks to process incoming TCP connections and requests. It also (optionally) closes stdin and redirects stderr to stdout.</source>
          <target state="translated">이 함수는 필요한 경우 stdin에서 쿠키를 읽고 사용 가능한 포트 (또는 지정된 경우 &lt;code&gt;--bind-to&lt;/code&gt; 명령 행 옵션 의 포트 )를 수신하고 들어오는 TCP 연결 및 요청을 처리하도록 작업을 예약합니다. 또한 stdin을 닫고 stderr을 stdout으로 리디렉션합니다.</target>
        </trans-unit>
        <trans-unit id="b716ab0d4ac152e4a4f9c6b1390eb5136f17d5d2" translate="yes" xml:space="preserve">
          <source>The garbage collector does not guarantee any order of finalization. That is, if &lt;code&gt;a&lt;/code&gt; contained a reference to &lt;code&gt;b&lt;/code&gt; and both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are due for garbage collection, there is no guarantee that &lt;code&gt;b&lt;/code&gt; would be finalized after &lt;code&gt;a&lt;/code&gt;. If proper finalization of &lt;code&gt;a&lt;/code&gt; depends on &lt;code&gt;b&lt;/code&gt; being valid, it must be handled in other ways.</source>
          <target state="translated">가비지 수집기는 마무리 순서를 보장하지 않습니다. 경우, 즉, &lt;code&gt;a&lt;/code&gt; 참조 함유 &lt;code&gt;b&lt;/code&gt; 모두 및 &lt;code&gt;b&lt;/code&gt; 가비지 컬렉션에 기인한다는 보증은 없다 &lt;code&gt;b&lt;/code&gt; 후에 완료 될 &lt;code&gt;a&lt;/code&gt; . 적절한 마무리하면 &lt;code&gt;a&lt;/code&gt; 에 따라 &lt;code&gt;b&lt;/code&gt; 를 유효되고, 다른 방법으로 처리해야합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2c5ffa9d8537b10e07bd1e1cd0016a03d6887376" translate="yes" xml:space="preserve">
          <source>The garbage collector operates under the assumption that it is aware of every old-generation object pointing to a young-generation one. Any time a pointer is updated breaking that assumption, it must be signaled to the collector with the &lt;code&gt;jl_gc_wb&lt;/code&gt; (write barrier) function like so:</source>
          <target state="translated">가비지 콜렉터는 젊은 세대 오브젝트를 가리키는 모든 이전 세대 오브젝트를 알고 있다고 가정하여 작동합니다. 해당 가정을 어 기고 포인터를 업데이트 할 때마다 다음과 같이 &lt;code&gt;jl_gc_wb&lt;/code&gt; (쓰기 장벽) 기능 을 사용하여 수집기에 신호를 보내야합니다 .</target>
        </trans-unit>
        <trans-unit id="7f907da64c464f65fc72aafc195dfebc2e4f4da6" translate="yes" xml:space="preserve">
          <source>The general syntax for assigning values in an n-dimensional array &lt;code&gt;A&lt;/code&gt; is:</source>
          <target state="translated">n 차원 배열 &lt;code&gt;A&lt;/code&gt; 에 값을 할당하는 일반적인 구문 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7f7fec22031b950929a2be2bf28c88a4e32319b3" translate="yes" xml:space="preserve">
          <source>The general syntax for indexing into an n-dimensional array &lt;code&gt;A&lt;/code&gt; is:</source>
          <target state="translated">n 차원 배열 &lt;code&gt;A&lt;/code&gt; 에 색인을 생성하는 일반적인 구문 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="03b4ccfaa881cd16fd244ada75dc950f11a8dd7c" translate="yes" xml:space="preserve">
          <source>The general syntaxes for declaring a primitive type are:</source>
          <target state="translated">기본 유형을 선언하는 일반적인 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3e8b49d87c21864e9239600316a0864509f86bdd" translate="yes" xml:space="preserve">
          <source>The generalized eigenvalues are returned in &lt;code&gt;alpha&lt;/code&gt; and &lt;code&gt;beta&lt;/code&gt;. The left Schur vectors are returned in &lt;code&gt;vsl&lt;/code&gt; and the right Schur vectors are returned in &lt;code&gt;vsr&lt;/code&gt;.</source>
          <target state="translated">일반 고유 값은 &lt;code&gt;alpha&lt;/code&gt; 및 &lt;code&gt;beta&lt;/code&gt; 로 반환됩니다 . 왼쪽 슈어 벡터는 반환됩니다 &lt;code&gt;vsl&lt;/code&gt; 오른쪽 슈어 벡터는 반환됩니다 &lt;code&gt;vsr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa0ec4e7835e3ddd782c0a7070e015136b4b04a9" translate="yes" xml:space="preserve">
          <source>The global constant &lt;a href=&quot;../../base/numbers/index#Base.im&quot;&gt;&lt;code&gt;im&lt;/code&gt;&lt;/a&gt; is bound to the complex number &lt;em&gt;i&lt;/em&gt;, representing the principal square root of -1. (Using mathematicians' &lt;code&gt;i&lt;/code&gt; or engineers' &lt;code&gt;j&lt;/code&gt; for this global constant were rejected since they are such popular index variable names.) Since Julia allows numeric literals to be &lt;a href=&quot;../integers-and-floating-point-numbers/index#man-numeric-literal-coefficients-1&quot;&gt;juxtaposed with identifiers as coefficients&lt;/a&gt;, this binding suffices to provide convenient syntax for complex numbers, similar to the traditional mathematical notation:</source>
          <target state="translated">전역 상수 &lt;a href=&quot;../../base/numbers/index#Base.im&quot;&gt; &lt;code&gt;im&lt;/code&gt; &lt;/a&gt; 은 복소수 &lt;em&gt;i에&lt;/em&gt; 바인딩되어 -1의 주요 제곱근을 나타냅니다. ( 이 전역 상수에 대해 수학자 &lt;code&gt;i&lt;/code&gt; 또는 엔지니어 &lt;code&gt;j&lt;/code&gt; 를 사용하는 것은 인기있는 인덱스 변수 이름이기 때문에 거부되었습니다.) Julia는 숫자 리터럴을 &lt;a href=&quot;../integers-and-floating-point-numbers/index#man-numeric-literal-coefficients-1&quot;&gt;계수와 같은 식별자로 병치&lt;/a&gt; 할 수 있기 때문에이 바인딩은 복잡한 숫자에 대해 편리한 구문을 제공하기에 충분합니다. 전통적인 수학적 표기법으로 :</target>
        </trans-unit>
        <trans-unit id="ef1d21913b7da2cd50221a9ea53be6e2ac79e4fa" translate="yes" xml:space="preserve">
          <source>The global logger may be set with &lt;a href=&quot;#Base.CoreLogging.global_logger&quot;&gt;&lt;code&gt;global_logger&lt;/code&gt;&lt;/a&gt;, and task-local loggers controlled using &lt;a href=&quot;#Base.CoreLogging.with_logger&quot;&gt;&lt;code&gt;with_logger&lt;/code&gt;&lt;/a&gt;. Newly spawned tasks inherit the logger of the parent task.</source>
          <target state="translated">글로벌 로거는 &lt;a href=&quot;#Base.CoreLogging.global_logger&quot;&gt; &lt;code&gt;global_logger&lt;/code&gt; &lt;/a&gt; 로 설정 될 수 있고 태스크 로컬 로거는 &lt;a href=&quot;#Base.CoreLogging.with_logger&quot;&gt; &lt;code&gt;with_logger&lt;/code&gt; 를&lt;/a&gt; 사용하여 제어 될 수 있습니다 . 새로 생성 된 작업은 상위 작업의 로거를 상속합니다.</target>
        </trans-unit>
        <trans-unit id="65f673e90f9a09b859b5b51800816fab3de4b761" translate="yes" xml:space="preserve">
          <source>The global variable &lt;code&gt;Base.DATAROOTDIR&lt;/code&gt; determines a relative path from &lt;code&gt;Sys.BINDIR&lt;/code&gt; to the data directory associated with Julia. Then the path</source>
          <target state="translated">전역 변수 &lt;code&gt;Base.DATAROOTDIR&lt;/code&gt; 은 &lt;code&gt;Sys.BINDIR&lt;/code&gt; 에서 Julia와 연관된 데이터 디렉토리로의 상대 경로를 결정합니다 . 그런 다음 경로</target>
        </trans-unit>
        <trans-unit id="e3bc80be4d521baacc06dd9873b328760a93de88" translate="yes" xml:space="preserve">
          <source>The golden ratio.</source>
          <target state="translated">황금비.</target>
        </trans-unit>
        <trans-unit id="354c17f25309f78f252b602097180cb50161163d" translate="yes" xml:space="preserve">
          <source>The group id of the file owner</source>
          <target state="translated">파일 소유자의 그룹 ID</target>
        </trans-unit>
        <trans-unit id="9e739954ff8de8447d1ab16a3adde7a80c985194" translate="yes" xml:space="preserve">
          <source>The hexadecimal integer literal expression &lt;code&gt;0xff&lt;/code&gt; could be interpreted as the numeric literal &lt;code&gt;0&lt;/code&gt; multiplied by the variable &lt;code&gt;xff&lt;/code&gt;.</source>
          <target state="translated">16 진 정수 리터럴 표현식 &lt;code&gt;0xff&lt;/code&gt; 는 숫자 리터럴 &lt;code&gt;0&lt;/code&gt; 에 변수 &lt;code&gt;xff&lt;/code&gt; 를 곱한 것으로 해석 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="49109aa658d7c92b2a2e148756ac4fc9b1efb6c1" translate="yes" xml:space="preserve">
          <source>The highest finite value representable by the given floating-point DataType &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">주어진 부동 소수점 DataType &lt;code&gt;T&lt;/code&gt; 로 표현할 수있는 최고 유한 값 입니다.</target>
        </trans-unit>
        <trans-unit id="1c54bd6057f9e745e71a4f119d94151d139d45e8" translate="yes" xml:space="preserve">
          <source>The highest value representable by the given (real) numeric &lt;code&gt;DataType&lt;/code&gt;.</source>
          <target state="translated">주어진 (실제) 숫자 &lt;code&gt;DataType&lt;/code&gt; 으로 표시 할 수있는 가장 높은 값 입니다.</target>
        </trans-unit>
        <trans-unit id="3d03859ad784bc750f8658c68023988ea70e276c" translate="yes" xml:space="preserve">
          <source>The host machine must have the requisite SIMD registers. For example, the code above will not work on hosts without AVX support.</source>
          <target state="translated">호스트 시스템에는 필수 SIMD 레지스터가 있어야합니다. 예를 들어, 위 코드는 AVX 지원이없는 호스트에서는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="69486992100b48c68c6ad0bb1508ce13148c9067" translate="yes" xml:space="preserve">
          <source>The hour of a &lt;code&gt;Time&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">a의 시간 &lt;code&gt;Time&lt;/code&gt; AS를 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0ae14cb6dca4ab146e83e6f66251f24254e3bb17" translate="yes" xml:space="preserve">
          <source>The hour of day of a &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">(A)의 하루의 시간 &lt;code&gt;DateTime&lt;/code&gt; AS를 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b1bfeaaafc9c1b963fac8395380b6b23cf36c72" translate="yes" xml:space="preserve">
          <source>The hour part of a DateTime as a &lt;code&gt;Hour&lt;/code&gt;.</source>
          <target state="translated">DateTime의 시간 부분을 &lt;code&gt;Hour&lt;/code&gt; 냅니다.</target>
        </trans-unit>
        <trans-unit id="3215c43ad10d3da4db391c4e4892aec7413196da" translate="yes" xml:space="preserve">
          <source>The identity function. Returns its argument.</source>
          <target state="translated">아이덴티티 기능. 인수를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="c738dd3a82cae47bce1402d7e9ed9b1a08ec88db" translate="yes" xml:space="preserve">
          <source>The imaginary unit &lt;code&gt;sqrt(-1)&lt;/code&gt; is represented in Julia as &lt;a href=&quot;../../base/numbers/index#Base.im&quot;&gt;&lt;code&gt;im&lt;/code&gt;&lt;/a&gt;, not &lt;code&gt;i&lt;/code&gt; or &lt;code&gt;j&lt;/code&gt; as in MATLAB.</source>
          <target state="translated">허수 부 &lt;code&gt;sqrt(-1)&lt;/code&gt; 로 표현된다 줄리아 &lt;a href=&quot;../../base/numbers/index#Base.im&quot;&gt; &lt;code&gt;im&lt;/code&gt; &lt;/a&gt; 하지 &lt;code&gt;i&lt;/code&gt; 또는 &lt;code&gt;j&lt;/code&gt; MATLAB 같이.</target>
        </trans-unit>
        <trans-unit id="7823efd88570f05c6cdcdeba7b9c6d877d28d4c3" translate="yes" xml:space="preserve">
          <source>The imaginary unit.</source>
          <target state="translated">가상의 단위.</target>
        </trans-unit>
        <trans-unit id="d2f3b37cc4a76dd392140d18be234dc4fa787173" translate="yes" xml:space="preserve">
          <source>The implementation of this behavior is a &quot;world age counter&quot;. This monotonically increasing value tracks each method definition operation. This allows describing &quot;the set of method definitions visible to a given runtime environment&quot; as a single number, or &quot;world age&quot;. It also allows comparing the methods available in two worlds just by comparing their ordinal value. In the example above, we see that the &quot;current world&quot; (in which the method &lt;code&gt;newfun&lt;/code&gt; exists), is one greater than the task-local &quot;runtime world&quot; that was fixed when the execution of &lt;code&gt;tryeval&lt;/code&gt; started.</source>
          <target state="translated">이 동작의 구현은 &quot;세계 연령 카운터&quot;입니다. 이 단조 증가하는 값은 각 분석법 정의 작업을 추적합니다. 이를 통해 &quot;주어진 런타임 환경에서 볼 수있는 메소드 정의 세트&quot;를 단일 숫자 또는 &quot;월드 연령&quot;으로 설명 할 수 있습니다. 또한 서수 값을 비교하여 두 세계에서 사용 가능한 방법을 비교할 수 있습니다. 위의 예에서, &quot;현재 세계&quot;( &lt;code&gt;newfun&lt;/code&gt; 메소드 가 존재하는)는 &lt;code&gt;tryeval&lt;/code&gt; 의 실행이 시작될 때 수정 된 태스크 로컬 &quot;런타임 세계&quot;보다 큰 것 입니다.</target>
        </trans-unit>
        <trans-unit id="b253e7f28529381ae2517e2dd4df05c0e78e871f" translate="yes" xml:space="preserve">
          <source>The incremental precompiled module file are created and used automatically when using &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;using&lt;/code&gt; to load a module. This will cause it to be automatically compiled the first time it is imported. Alternatively, you can manually call &lt;a href=&quot;../../base/base/index#Base.compilecache&quot;&gt;&lt;code&gt;Base.compilecache(modulename)&lt;/code&gt;&lt;/a&gt;. The resulting cache files will be stored in &lt;code&gt;DEPOT_PATH[1]/compiled/&lt;/code&gt;. Subsequently, the module is automatically recompiled upon &lt;code&gt;using&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt; whenever any of its dependencies change; dependencies are modules it imports, the Julia build, files it includes, or explicit dependencies declared by &lt;a href=&quot;../../base/base/index#Base.include_dependency&quot;&gt;&lt;code&gt;include_dependency(path)&lt;/code&gt;&lt;/a&gt; in the module file(s).</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; &lt;code&gt;using&lt;/code&gt; 하거나 모듈을로드 할 때 증분 사전 컴파일 된 모듈 파일이 자동으로 작성되어 사용됩니다 . 이렇게하면 처음 가져올 때 자동으로 컴파일됩니다. 또는 &lt;a href=&quot;../../base/base/index#Base.compilecache&quot;&gt; &lt;code&gt;Base.compilecache(modulename)&lt;/code&gt; &lt;/a&gt; 수동으로 호출 할 수 있습니다 . 결과 캐시 파일은 &lt;code&gt;DEPOT_PATH[1]/compiled/&lt;/code&gt; 저장됩니다 . 결과적으로, 모듈은 의존성이 변경 될 때마다 &lt;code&gt;using&lt;/code&gt; 하거나 &lt;code&gt;import&lt;/code&gt; 때 자동으로 다시 컴파일됩니다 . 종속성은 가져 오는 모듈, Julia 빌드, 포함 된 파일 또는 모듈 파일에서 &lt;a href=&quot;../../base/base/index#Base.include_dependency&quot;&gt; &lt;code&gt;include_dependency(path)&lt;/code&gt; &lt;/a&gt; 에 의해 선언 된 명시 적 종속성 입니다.</target>
        </trans-unit>
        <trans-unit id="13dd8189d32c7c1290b037751919f6e30e7f64f8" translate="yes" xml:space="preserve">
          <source>The individual components of the decomposition &lt;code&gt;F&lt;/code&gt; can be retrieved via property accessors:</source>
          <target state="translated">분해물 &lt;code&gt;F&lt;/code&gt; 의 개별 구성 요소는 속성 접근자를 통해 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce0913135fd9f357f77350a326cce1c8ed6fa49d" translate="yes" xml:space="preserve">
          <source>The individual components of the factorization &lt;code&gt;F&lt;/code&gt; can be accessed via &lt;code&gt;getproperty&lt;/code&gt;:</source>
          <target state="translated">인수 분해 &lt;code&gt;F&lt;/code&gt; 의 개별 구성 요소는 &lt;code&gt;getproperty&lt;/code&gt; 를 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c6e01ca13a398bafdf18f4d4f60195a783a431cf" translate="yes" xml:space="preserve">
          <source>The infix form is exactly equivalent to the function application form &amp;ndash; in fact the former is parsed to produce the function call internally. This also means that you can assign and pass around operators such as &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;*&lt;/code&gt; just like you would with other function values:</source>
          <target state="translated">삽입 양식은 함수 응용 프로그램 양식과 정확히 동일합니다. 실제로 전자는 내부적으로 함수 호출을 생성하도록 구문 분석됩니다. 이것은 또한 다른 함수 값에서 와 같이 &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt; &lt;code&gt;+&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;*&lt;/code&gt; 와 같은 연산자를 할당하고 전달할 수 있음을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="ab93d805a4e1efd3cacbdba9a517e0dc2379a9e4" translate="yes" xml:space="preserve">
          <source>The infix operation &lt;code&gt;a ⊻ b&lt;/code&gt; is a synonym for &lt;code&gt;xor(a,b)&lt;/code&gt;, and &lt;code&gt;⊻&lt;/code&gt; can be typed by tab-completing &lt;code&gt;\xor&lt;/code&gt; or &lt;code&gt;\veebar&lt;/code&gt; in the Julia REPL.</source>
          <target state="translated">삽입 조작 &lt;code&gt;a ⊻ b&lt;/code&gt; 는 &lt;code&gt;xor(a,b)&lt;/code&gt; 의 동의어 이며 &lt;code&gt;⊻&lt;/code&gt; 는 Julia REPL에서 탭 완성 &lt;code&gt;\xor&lt;/code&gt; 또는 &lt;code&gt;\veebar&lt;/code&gt; 로 입력 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e1b31695e555eb78c96b1ce43ed5d4b769be43f4" translate="yes" xml:space="preserve">
          <source>The initial Julia process, also called the &lt;code&gt;master&lt;/code&gt;, is special and has an &lt;code&gt;id&lt;/code&gt; of 1.</source>
          <target state="translated">&lt;code&gt;master&lt;/code&gt; 라고도하는 초기 Julia 프로세스 는 특별하며 &lt;code&gt;id&lt;/code&gt; 는 1입니다.</target>
        </trans-unit>
        <trans-unit id="46aabc78dd4e507670425bdb3bf204611d3ffb13" translate="yes" xml:space="preserve">
          <source>The inode number of the file</source>
          <target state="translated">파일의 아이 노드 번호</target>
        </trans-unit>
        <trans-unit id="204c42952f2670f515bfe08f06a0ba3dd55c909a" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;n&lt;/code&gt; is passed by value, and so the function's input signature is simply declared as &lt;code&gt;(Csize_t,)&lt;/code&gt; without any &lt;code&gt;Ref&lt;/code&gt; or &lt;code&gt;Ptr&lt;/code&gt; necessary. (If the wrapper was calling a Fortran function instead, the corresponding function input signature should instead be &lt;code&gt;(Ref{Csize_t},)&lt;/code&gt;, since Fortran variables are passed by pointers.) Furthermore, &lt;code&gt;n&lt;/code&gt; can be any type that is convertible to a &lt;code&gt;Csize_t&lt;/code&gt; integer; the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; implicitly calls &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert(Csize_t, n)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">입력 &lt;code&gt;n&lt;/code&gt; 은 값으로 전달되므로 함수의 입력 서명은 &lt;code&gt;Ref&lt;/code&gt; 또는 &lt;code&gt;Ptr&lt;/code&gt; 이 필요 하지 않고 단순히 &lt;code&gt;(Csize_t,)&lt;/code&gt; 로 선언됩니다 . 랩퍼가 대신 포트란 함수를 호출 한 경우, 포트란 변수가 포인터에 의해 전달되므로 해당 함수 입력 서명은 대신 &lt;code&gt;(Ref{Csize_t},)&lt;/code&gt; 이어야합니다 . 또한 &lt;code&gt;n&lt;/code&gt; 은 &lt;code&gt;Csize_t&lt;/code&gt; 정수 로 변환 가능한 모든 유형이 될 수 있습니다. ; &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; 는&lt;/a&gt; 암시 적으로 호출 &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert(Csize_t, n)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b8b235e73123abb02c8610a64480c17659bc5e36" translate="yes" xml:space="preserve">
          <source>The input matrices &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; will not contain their eigenvalues after &lt;code&gt;eigvals!&lt;/code&gt; is called. They are used as workspaces.</source>
          <target state="translated">입력 행렬 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 에는 고유 값 뒤에 고유 값이 포함되지 않습니다 &lt;code&gt;eigvals!&lt;/code&gt; 호출됩니다. 작업 공간으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a25e9d14fa9f0f89dab37c152c425a3aebebbd0f" translate="yes" xml:space="preserve">
          <source>The input matrix &lt;code&gt;A&lt;/code&gt; will not contain its eigenvalues after &lt;code&gt;eigvals!&lt;/code&gt; is called on it - &lt;code&gt;A&lt;/code&gt; is used as a workspace.</source>
          <target state="translated">입력 행렬 &lt;code&gt;A&lt;/code&gt; 는 &lt;code&gt;eigvals!&lt;/code&gt; 이후 고유 값을 포함하지 않습니다 ! 호출됩니다 &lt;code&gt;A&lt;/code&gt; 는 작업 공간으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1417019c8a8204f046e43b52db1e1b8dfe779fc9" translate="yes" xml:space="preserve">
          <source>The input matrix &lt;code&gt;X&lt;/code&gt; is not transposed or conjugated.</source>
          <target state="translated">입력 매트릭스 &lt;code&gt;X&lt;/code&gt; 는 전치되거나 공액되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="696317e85c44155ed1679065a21cab9ea0d94c6f" translate="yes" xml:space="preserve">
          <source>The input matrix &lt;code&gt;X&lt;/code&gt; will be conjugated and transposed.</source>
          <target state="translated">입력 매트릭스 &lt;code&gt;X&lt;/code&gt; 는 켤레로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="edc49f341fce73dbc1b810339993fe819e7483f6" translate="yes" xml:space="preserve">
          <source>The input matrix &lt;code&gt;X&lt;/code&gt; will be transposed.</source>
          <target state="translated">입력 행렬 &lt;code&gt;X&lt;/code&gt; 가 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="ce8cf57c3583cc5f6f01c812980b6d9e8e041658" translate="yes" xml:space="preserve">
          <source>The intuition behind this behavior is that &lt;code&gt;x&lt;/code&gt; is evaluated once for each &lt;code&gt;$&lt;/code&gt;: one &lt;code&gt;$&lt;/code&gt; works similarly to &lt;code&gt;eval(:x)&lt;/code&gt;, giving &lt;code&gt;x&lt;/code&gt;'s value, while two &lt;code&gt;$&lt;/code&gt;s do the equivalent of &lt;code&gt;eval(eval(:x))&lt;/code&gt;.</source>
          <target state="translated">이 동작의 직관은 &lt;code&gt;x&lt;/code&gt; 가 각 &lt;code&gt;$&lt;/code&gt; 에 대해 한 번 평가 된다는 것입니다 . 하나의 &lt;code&gt;$&lt;/code&gt; 는 &lt;code&gt;eval(:x)&lt;/code&gt; 와 유사하게 작동 하여 &lt;code&gt;x&lt;/code&gt; 의 값을 제공하지만 두 개의 &lt;code&gt;$&lt;/code&gt; 는 &lt;code&gt;eval(eval(:x))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9951fb03011eb6ccac99ddca5a1c8a2596a1921f" translate="yes" xml:space="preserve">
          <source>The inverse of the &lt;a href=&quot;#SparseArrays.sparse&quot;&gt;&lt;code&gt;sparse&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#SparseArrays.sparsevec&quot;&gt;&lt;code&gt;sparsevec&lt;/code&gt;&lt;/a&gt; functions is &lt;a href=&quot;#SparseArrays.findnz&quot;&gt;&lt;code&gt;findnz&lt;/code&gt;&lt;/a&gt;, which retrieves the inputs used to create the sparse array. &lt;code&gt;findall(!iszero, x)&lt;/code&gt; returns the cartesian indices of non-zero entries in &lt;code&gt;x&lt;/code&gt; (including stored entries equal to zero).</source>
          <target state="translated">&lt;a href=&quot;#SparseArrays.sparse&quot;&gt; &lt;code&gt;sparse&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#SparseArrays.sparsevec&quot;&gt; &lt;code&gt;sparsevec&lt;/code&gt; &lt;/a&gt; 함수 의 역함수 는 &lt;a href=&quot;#SparseArrays.findnz&quot;&gt; &lt;code&gt;findnz&lt;/code&gt; &lt;/a&gt; 이며, 이는 희소 배열을 작성하는 데 사용 된 입력을 검색합니다. &lt;code&gt;findall(!iszero, x)&lt;/code&gt; 0이 아닌 항목의 인덱스를 반환 직교 &lt;code&gt;x&lt;/code&gt; (저장된 항목 제로인를 포함).</target>
        </trans-unit>
        <trans-unit id="08e030af941b44ba6a6057a4b8409ccf9a09fa65" translate="yes" xml:space="preserve">
          <source>The item or field is not defined for the given object.</source>
          <target state="translated">주어진 객체에 대해 항목 또는 필드가 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="5978b1760bac737678645da104214e401ee6745d" translate="yes" xml:space="preserve">
          <source>The iteration space is split amongst the threads, after which each thread writes its thread ID to its assigned locations:</source>
          <target state="translated">반복 공간은 스레드 사이에서 분할되고 각 스레드는 스레드 ID를 지정된 위치에 씁니다.</target>
        </trans-unit>
        <trans-unit id="27814682e2f12bb813126e15aaa61e9b9ecadb0b" translate="yes" xml:space="preserve">
          <source>The keyword argument &lt;code&gt;topology&lt;/code&gt; passed to &lt;code&gt;addprocs&lt;/code&gt; is used to specify how the workers must be connected to each other:</source>
          <target state="translated">&lt;code&gt;addprocs&lt;/code&gt; 에 전달 된 키워드 인수 &lt;code&gt;topology&lt;/code&gt; 는 작업자가 서로 연결되는 방법을 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="071e1626e259689d138d5d354cd990a797f9cc76" translate="yes" xml:space="preserve">
          <source>The keyword argument is:</source>
          <target state="translated">키워드 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b53040371261a8a003dc97b8ee4567faef82b0f5" translate="yes" xml:space="preserve">
          <source>The keyword arguments are:</source>
          <target state="translated">키워드 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aff2628de569031caf118a1cfbb476e502ae8a02" translate="yes" xml:space="preserve">
          <source>The keyword arguments can be any combination of:</source>
          <target state="translated">키워드 인수는 다음을 조합하여 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88a5016b4ada3cfa1d337884f9c60b1547e662dc" translate="yes" xml:space="preserve">
          <source>The keyword arguments determine which of read and/or write status should be monitored; at least one of them must be set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">키워드 인수는 모니터링 할 읽기 및 / 또는 쓰기 상태를 결정합니다. 이들 중 적어도 하나는 &lt;code&gt;true&lt;/code&gt; 로 설정해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="8c36d11485ade8e4d84f52006bfe2371bd7a3a31" translate="yes" xml:space="preserve">
          <source>The keyword debuginfo controls the amount of code metadata present in the output.</source>
          <target state="translated">키워드 debuginfo는 출력에 존재하는 코드 메타 데이터의 양을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="1c08fd56fd5a7ec1b4c4d5ce6e7cd9fc470d3bc9" translate="yes" xml:space="preserve">
          <source>The largest &lt;code&gt;a^n&lt;/code&gt; not greater than &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is a non-negative integer. &lt;code&gt;a&lt;/code&gt; must be greater than 1, and &lt;code&gt;x&lt;/code&gt; must not be less than 1.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 보다 크지 않은 최대 &lt;code&gt;a^n&lt;/code&gt; . 여기서 &lt;code&gt;n&lt;/code&gt; 은 음수가 아닌 정수입니다. &lt;code&gt;a&lt;/code&gt; 는 1보다 크고 &lt;code&gt;x&lt;/code&gt; 는 1보다 작아야 합니다.</target>
        </trans-unit>
        <trans-unit id="1950191e788c00e6e81f70c06794860257be97cd" translate="yes" xml:space="preserve">
          <source>The largest consecutive integer representable in the given floating-point type &lt;code&gt;T&lt;/code&gt; that also does not exceed the maximum integer representable by the integer type &lt;code&gt;S&lt;/code&gt;. Equivalently, it is the minimum of &lt;code&gt;maxintfloat(T)&lt;/code&gt; and &lt;a href=&quot;#Base.typemax&quot;&gt;&lt;code&gt;typemax(S)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 부동 소수점 유형 &lt;code&gt;T&lt;/code&gt; 에서 표현할 수있는 최대 연속 정수 로, 정수 유형 &lt;code&gt;S&lt;/code&gt; 로 표현할 수있는 최대 정수를 초과하지 않습니다 . 마찬가지로 &lt;code&gt;maxintfloat(T)&lt;/code&gt; 및 &lt;a href=&quot;#Base.typemax&quot;&gt; &lt;code&gt;typemax(S)&lt;/code&gt; &lt;/a&gt; 의 최소값입니다 .</target>
        </trans-unit>
        <trans-unit id="ecdd0c5829d6c2ebd17e2173ff4d8725a651c73f" translate="yes" xml:space="preserve">
          <source>The largest consecutive integer-valued floating-point number that is exactly represented in the given floating-point type &lt;code&gt;T&lt;/code&gt; (which defaults to &lt;code&gt;Float64&lt;/code&gt;).</source>
          <target state="translated">주어진 부동 소수점 유형 &lt;code&gt;T&lt;/code&gt; 에 정확하게 표시되는 최대 연속 정수 값 부동 소수점 숫자입니다 (기본값은 &lt;code&gt;Float64&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="45d85758b569bacb3008f9cd5ec57f8b5348a342" translate="yes" xml:space="preserve">
          <source>The last argument is a boolean indicating whether Julia should take ownership of the data. If this argument is non-zero, the GC will call &lt;code&gt;free&lt;/code&gt; on the data pointer when the array is no longer referenced.</source>
          <target state="translated">마지막 인수는 Julia가 데이터의 소유권을 가져야하는지 여부를 나타내는 부울입니다. 이 인수가 0이 아니면 GC는 배열이 더 이상 참조되지 않을 때 데이터 포인터에서 &lt;code&gt;free&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="1c54e90c8086ffbb492a0993d80791c5e4dea811" translate="yes" xml:space="preserve">
          <source>The last argument is the expression during which the object(s) will be preserved. The previous arguments are the objects to preserve.</source>
          <target state="translated">마지막 인수는 객체가 보존되는 표현식입니다. 이전 인수는 보존 할 객체입니다.</target>
        </trans-unit>
        <trans-unit id="ea0fbbe9568bcd71edf3e46185498b21db11849e" translate="yes" xml:space="preserve">
          <source>The last definition of &lt;code&gt;addone&lt;/code&gt; handles any type supporting &lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt;&lt;code&gt;oneunit&lt;/code&gt;&lt;/a&gt; (which returns 1 in the same type as &lt;code&gt;x&lt;/code&gt;, which avoids unwanted type promotion) and the &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt; function with those arguments. The key thing to realize is that there is &lt;em&gt;no performance penalty&lt;/em&gt; to defining &lt;em&gt;only&lt;/em&gt; the general &lt;code&gt;addone(x) = x + oneunit(x)&lt;/code&gt;, because Julia will automatically compile specialized versions as needed. For example, the first time you call &lt;code&gt;addone(12)&lt;/code&gt;, Julia will automatically compile a specialized &lt;code&gt;addone&lt;/code&gt; function for &lt;code&gt;x::Int&lt;/code&gt; arguments, with the call to &lt;code&gt;oneunit&lt;/code&gt; replaced by its inlined value &lt;code&gt;1&lt;/code&gt;. Therefore, the first three definitions of &lt;code&gt;addone&lt;/code&gt; above are completely redundant with the fourth definition.</source>
          <target state="translated">마지막 정의 &lt;code&gt;addone&lt;/code&gt; 의 손잡이지지 모든 유형 &lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt; &lt;code&gt;oneunit&lt;/code&gt; &lt;/a&gt; (동일한 타입 1을 반환 &lt;code&gt;x&lt;/code&gt; 및 불필요한 유형 승격 피한다) &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt; &lt;code&gt;+&lt;/code&gt; 의&lt;/a&gt; 이러한 인자 기능. 실현의 핵심 일이 없다는 것입니다 &lt;em&gt;성능 저하&lt;/em&gt; 정의하는 &lt;em&gt;경우에만&lt;/em&gt; 일반 &lt;code&gt;addone(x) = x + oneunit(x)&lt;/code&gt; 필요에 따라 줄리아가 자동으로 버전을 전문 컴파일 때문이다. 예를 들어, 처음 전화 할 &lt;code&gt;addone(12)&lt;/code&gt; , 줄리아는 자동으로 전문 컴파일 &lt;code&gt;addone&lt;/code&gt; 에 대한 기능 &lt;code&gt;x::Int&lt;/code&gt; 에 대한 호출, 인수를 &lt;code&gt;oneunit&lt;/code&gt; 인라인 된 값 &lt;code&gt;1&lt;/code&gt; 로 대체됩니다 . 따라서 위 의 &lt;code&gt;addone&lt;/code&gt; 의 처음 세 정의 는 네 번째 정의와 완전히 중복됩니다.</target>
        </trans-unit>
        <trans-unit id="ce1654d58ffca436a4c577b1711a64e839d84f92" translate="yes" xml:space="preserve">
          <source>The last example shows that &lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt;&lt;code&gt;occursin&lt;/code&gt;&lt;/a&gt; can also look for a character literal.</source>
          <target state="translated">것을 마지막 예를 보여줍니다 &lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt; &lt;code&gt;occursin&lt;/code&gt; 는&lt;/a&gt; 또한 문자 그대로 찾아보실 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c71585d1662e0c9426691e517fa7355c40e4926e" translate="yes" xml:space="preserve">
          <source>The last index, used in &lt;code&gt;X[end]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;X[end]&lt;/code&gt; 에서 사용 된 마지막 색인</target>
        </trans-unit>
        <trans-unit id="85a1c4b01d2974399d332fe3cfffd4d1b569afd3" translate="yes" xml:space="preserve">
          <source>The last parameter of a tuple type &lt;a href=&quot;#Core.Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; can be the special type &lt;code&gt;Vararg&lt;/code&gt;, which denotes any number of trailing elements. The type &lt;code&gt;Vararg{T,N}&lt;/code&gt; corresponds to exactly &lt;code&gt;N&lt;/code&gt; elements of type &lt;code&gt;T&lt;/code&gt;. &lt;code&gt;Vararg{T}&lt;/code&gt; corresponds to zero or more elements of type &lt;code&gt;T&lt;/code&gt;. &lt;code&gt;Vararg&lt;/code&gt; tuple types are used to represent the arguments accepted by varargs methods (see the section on &lt;a href=&quot;../../manual/functions/index#Varargs-Functions-1&quot;&gt;Varargs Functions&lt;/a&gt; in the manual.)</source>
          <target state="translated">튜플 유형 &lt;a href=&quot;#Core.Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt; 의 마지막 매개 변수는 특수 유형 &lt;code&gt;Vararg&lt;/code&gt; 일 수 있으며 , 이는 여러 개의 후행 요소를 나타냅니다. 타입 &lt;code&gt;Vararg{T,N}&lt;/code&gt; 정확히에 대응하는 &lt;code&gt;N&lt;/code&gt; 형의 요소 &lt;code&gt;T&lt;/code&gt; . &lt;code&gt;Vararg{T}&lt;/code&gt; 는 &lt;code&gt;T&lt;/code&gt; 유형의 0 개 이상의 요소에 해당합니다 . &lt;code&gt;Vararg&lt;/code&gt; 튜플 유형은 varargs 메소드에서 허용되는 인수를 나타내는 데 사용됩니다 ( 매뉴얼의 &lt;a href=&quot;../../manual/functions/index#Varargs-Functions-1&quot;&gt;Varargs 함수&lt;/a&gt; 섹션 참조 ).</target>
        </trans-unit>
        <trans-unit id="acef1648e92638f5fc5abaed16365a6d53367ba2" translate="yes" xml:space="preserve">
          <source>The last parameter of a tuple type can be the special type &lt;a href=&quot;../../base/base/index#Core.Vararg&quot;&gt;&lt;code&gt;Vararg&lt;/code&gt;&lt;/a&gt;, which denotes any number of trailing elements:</source>
          <target state="translated">튜플 유형의 마지막 매개 변수는 특수 유형 &lt;a href=&quot;../../base/base/index#Core.Vararg&quot;&gt; &lt;code&gt;Vararg&lt;/code&gt; &lt;/a&gt; 일 수 있습니다.이 유형 은 후행 요소 수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1d6eefa466648c5ff477244c5653b68c2b829837" translate="yes" xml:space="preserve">
          <source>The last point is potentially surprising and thus worth noting:</source>
          <target state="translated">마지막 요점은 잠재적으로 놀라 울 정도로 주목할만한 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7ffcc1d6667c70bd8fd7c442814f44c7c9628ab" translate="yes" xml:space="preserve">
          <source>The last rule applies for immutable objects even if the variable binding would change, e.g.:</source>
          <target state="translated">마지막 규칙은 변수 바인딩이 변경 되더라도 불변 객체에 적용됩니다. 예 :</target>
        </trans-unit>
        <trans-unit id="ac541895cad74a09061e0e8e7752d4412b01c909" translate="yes" xml:space="preserve">
          <source>The launching, management and networking of Julia processes into a logical cluster is done via cluster managers. A &lt;code&gt;ClusterManager&lt;/code&gt; is responsible for</source>
          <target state="translated">Julia 프로세스를 논리 클러스터로 시작, 관리 및 네트워킹하는 작업은 클러스터 관리자를 통해 수행됩니다. &lt;code&gt;ClusterManager&lt;/code&gt; 는 책임이있다</target>
        </trans-unit>
        <trans-unit id="88412ce5eb2e0660d566bcac5d3d266756d5e5a6" translate="yes" xml:space="preserve">
          <source>The length of &lt;code&gt;s&lt;/code&gt; must be even, and the returned array has half of the length of &lt;code&gt;s&lt;/code&gt;. See also &lt;a href=&quot;#Base.hex2bytes!&quot;&gt;&lt;code&gt;hex2bytes!&lt;/code&gt;&lt;/a&gt; for an in-place version, and &lt;a href=&quot;#Base.bytes2hex&quot;&gt;&lt;code&gt;bytes2hex&lt;/code&gt;&lt;/a&gt; for the inverse.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 의 길이는 짝수 여야하며 반환 된 배열의 길이는 &lt;code&gt;s&lt;/code&gt; 의 절반입니다 . 참조 &lt;a href=&quot;#Base.hex2bytes!&quot;&gt; &lt;code&gt;hex2bytes!&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#Base.bytes2hex&quot;&gt; &lt;code&gt;bytes2hex&lt;/code&gt; &lt;/a&gt; 버전의 경우 역수의 경우 bytes2hex 입니다.</target>
        </trans-unit>
        <trans-unit id="82277dc04b6a3c445e6b9754a249fdcb23f3c7cf" translate="yes" xml:space="preserve">
          <source>The line number in the file containing the execution context.</source>
          <target state="translated">실행 컨텍스트를 포함하는 파일의 줄 번호입니다.</target>
        </trans-unit>
        <trans-unit id="8e34d0276593663d51db2e1008617c96b00222ff" translate="yes" xml:space="preserve">
          <source>The location &lt;code&gt;i_1, i_2, i_3, ..., i_{n+1}&lt;/code&gt; contains the value at &lt;code&gt;A[I_1[i_1, i_2], I_2[i_3], ..., I_n[i_{n+1}]]&lt;/code&gt;. All dimensions indexed with scalars are dropped. For example, if &lt;code&gt;J&lt;/code&gt; is an array of indices, then the result of &lt;code&gt;A[2, J, 3]&lt;/code&gt; is an array with size &lt;code&gt;size(J)&lt;/code&gt;. Its &lt;code&gt;j&lt;/code&gt;th element is populated by &lt;code&gt;A[2, J[j], 3]&lt;/code&gt;.</source>
          <target state="translated">위치 &lt;code&gt;i_1, i_2, i_3, ..., i_{n+1}&lt;/code&gt; 에는 &lt;code&gt;A[I_1[i_1, i_2], I_2[i_3], ..., I_n[i_{n+1}]]&lt;/code&gt; . 스칼라로 인덱스 된 모든 차원이 삭제됩니다. 예를 들어, &lt;code&gt;J&lt;/code&gt; 가 인덱스 배열 인 경우 &lt;code&gt;A[2, J, 3]&lt;/code&gt; 의 결과는 &lt;code&gt;size(J)&lt;/code&gt; 의 배열입니다 . 그 &lt;code&gt;j&lt;/code&gt; 번째 요소는로 채워 &lt;code&gt;A[2, J[j], 3]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ba9cf6bb4f8397cc28a79b830f4f985b9ab3a34" translate="yes" xml:space="preserve">
          <source>The location information can be accessed by referencing &lt;code&gt;__source__.line&lt;/code&gt; and &lt;code&gt;__source__.file&lt;/code&gt;:</source>
          <target state="translated">위치 정보는 &lt;code&gt;__source__.line&lt;/code&gt; 및 &lt;code&gt;__source__.file&lt;/code&gt; 을 참조하여 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3cb51b112926a1dd81d50332e9952ca8853bb8d8" translate="yes" xml:space="preserve">
          <source>The location of both the &lt;code&gt;local&lt;/code&gt; and &lt;code&gt;global&lt;/code&gt; keywords within the scope block is irrelevant. The following is equivalent to the last example (although stylistically worse):</source>
          <target state="translated">범위 블록 내에서 &lt;code&gt;local&lt;/code&gt; 및 &lt;code&gt;global&lt;/code&gt; 키워드 의 위치 는 관련이 없습니다. 다음은 마지막 예제와 동일합니다 (문학적으로 나쁘지만).</target>
        </trans-unit>
        <trans-unit id="98682ff20b7c08341d3c5e15b38c14b9a4d16f28" translate="yes" xml:space="preserve">
          <source>The log level provides a key against which potential log records may be filtered, before any other work is done to construct the log record data structure itself.</source>
          <target state="translated">로그 레벨은 로그 레코드 데이터 구조 자체를 구성하기위한 다른 작업을 수행하기 전에 잠재적 로그 레코드를 필터링 할 수있는 키를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="318d32e896560b8d7266b2f324ddc4a3093ac0b9" translate="yes" xml:space="preserve">
          <source>The loop body must be straight-line code. Therefore, &lt;a href=&quot;#Base.@inbounds&quot;&gt;&lt;code&gt;@inbounds&lt;/code&gt;&lt;/a&gt; is currently needed for all array accesses. The compiler can sometimes turn short &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt;, and &lt;code&gt;?:&lt;/code&gt; expressions into straight-line code if it is safe to evaluate all operands unconditionally. Consider using the &lt;a href=&quot;#Core.ifelse&quot;&gt;&lt;code&gt;ifelse&lt;/code&gt;&lt;/a&gt; function instead of &lt;code&gt;?:&lt;/code&gt; in the loop if it is safe to do so.</source>
          <target state="translated">루프 본문은 직선 코드 여야합니다. 따라서 &lt;a href=&quot;#Base.@inbounds&quot;&gt; &lt;code&gt;@inbounds&lt;/code&gt; &lt;/a&gt; 는 현재 모든 어레이 액세스에 필요합니다. 컴파일러는 때때로 짧게 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; , &lt;code&gt;||&lt;/code&gt; , 및 &lt;code&gt;?:&lt;/code&gt; 모든 피연산자를 무조건적으로 평가하는 것이 안전한 경우, 직선 코드로 표현합니다. 안전한 경우 루프에서 &lt;code&gt;?:&lt;/code&gt; 대신 &lt;a href=&quot;#Core.ifelse&quot;&gt; &lt;code&gt;ifelse&lt;/code&gt; &lt;/a&gt; 함수를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e1520d8e0dbae93326950f00e9cb69f3cae60938" translate="yes" xml:space="preserve">
          <source>The loop must be an innermost loop</source>
          <target state="translated">루프는 가장 안쪽 루프 여야합니다</target>
        </trans-unit>
        <trans-unit id="1417d30bb5a87b95ed3077cbfd4cd113b702f8de" translate="yes" xml:space="preserve">
          <source>The lowest value representable by the given (real) numeric DataType &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">주어진 (실제) 숫자 DataType &lt;code&gt;T&lt;/code&gt; 로 표시 할 수있는 가장 낮은 값 입니다.</target>
        </trans-unit>
        <trans-unit id="73472042c68fe0e8852a29376bec0fce0bf44289" translate="yes" xml:space="preserve">
          <source>The macro &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt;&lt;code&gt;@cfunction&lt;/code&gt;&lt;/a&gt; generates the C-compatible function pointer for a call to a Julia function. Arguments to &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt;&lt;code&gt;@cfunction&lt;/code&gt;&lt;/a&gt; are as follows:</source>
          <target state="translated">&lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt; &lt;code&gt;@cfunction&lt;/code&gt; &lt;/a&gt; 매크로 는 Julia 함수 호출을위한 C 호환 함수 포인터를 생성합니다. &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt; &lt;code&gt;@cfunction&lt;/code&gt; 의&lt;/a&gt; 인수 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a90d2d040a67a205cdeab40f74d8c8876f85fbd9" translate="yes" xml:space="preserve">
          <source>The macro &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt;&lt;code&gt;@code_warntype&lt;/code&gt;&lt;/a&gt; (or its function variant &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.code_warntype&quot;&gt;&lt;code&gt;code_warntype&lt;/code&gt;&lt;/a&gt;) can sometimes be helpful in diagnosing type-related problems. Here's an example:</source>
          <target state="translated">&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt; &lt;code&gt;@code_warntype&lt;/code&gt; &lt;/a&gt; 매크로 (또는 함수 변형 &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.code_warntype&quot;&gt; &lt;code&gt;code_warntype&lt;/code&gt; &lt;/a&gt; )는 유형 관련 문제를 진단하는 데 도움이 될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9e7d84ccb0a328a62c08d6f8b7389ef525b8bb84" translate="yes" xml:space="preserve">
          <source>The macro may be chained with &lt;code&gt;@test&lt;/code&gt; to also test the returned value:</source>
          <target state="translated">매크로는 &lt;code&gt;@test&lt;/code&gt; 와 연결되어 반환 된 값을 테스트 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee8a907ab8fbfe293b4dae0afdde54a8eeab9dd2" translate="yes" xml:space="preserve">
          <source>The main purpose of this constructor is intuitive conversion from cartesian to linear indexing:</source>
          <target state="translated">이 생성자의 주요 목적은 직교에서 선형 색인으로 직관적으로 변환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="525b6c6d88eda51b84031a3e53a3435af961ebe7" translate="yes" xml:space="preserve">
          <source>The master process does not listen on any port. It only connects out to the workers.</source>
          <target state="translated">마스터 프로세스는 포트를 수신하지 않습니다. 그것은 노동자들에게만 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="2ed15f9d452fe7aa2e8f8976ab10c5922bcca0ff" translate="yes" xml:space="preserve">
          <source>The master process parses this information and sets up TCP/IP connections to each worker.</source>
          <target state="translated">마스터 프로세스는이 정보를 구문 분석하고 각 작업자에 대한 TCP / IP 연결을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="c61856ffa89efc2e6c1d6b663bec6b092cbe224f" translate="yes" xml:space="preserve">
          <source>The meaning of prefix &lt;code&gt;&amp;amp;&lt;/code&gt; is not quite the same as in C. In particular, any changes to the referenced variables will not be visible in Julia unless the type is mutable (declared via &lt;code&gt;mutable struct&lt;/code&gt;). However, even for immutable structs it will not cause any harm for called functions to attempt such modifications (that is, writing through the passed pointers). Moreover, &lt;code&gt;&amp;amp;&lt;/code&gt; may be used with any expression, such as &lt;code&gt;&amp;amp;0&lt;/code&gt; or &lt;code&gt;&amp;amp;f(x)&lt;/code&gt;.</source>
          <target state="translated">접두사 &lt;code&gt;&amp;amp;&lt;/code&gt; 의 의미는 C에서와 완전히 다릅니다. 특히, 참조 가능한 변수에 대한 변경 사항은 유형이 변경 가능하지 않은 경우 ( &lt;code&gt;mutable struct&lt;/code&gt; 를 통해 선언 된 경우) Julia에서 볼 수 없습니다 . 그러나 불변의 구조체조차도 호출 된 함수가 그러한 수정을 시도 (즉, 전달 된 포인터를 통해 쓰는)에 해를 끼치 지 않습니다. 또한 &lt;code&gt;&amp;amp;&lt;/code&gt; 는 &lt;code&gt;&amp;amp;0&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;f(x)&lt;/code&gt; 와 같은 표현식과 함께 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ebdb2209b7357825841deb8a7b0ab3a885d17542" translate="yes" xml:space="preserve">
          <source>The meaning of this form is that &lt;code&gt;F(x,y,...)&lt;/code&gt; is evaluated with the variables &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, etc. taking on each value in their given list of values. Values can be specified as any iterable object, but will commonly be ranges like &lt;code&gt;1:n&lt;/code&gt; or &lt;code&gt;2:(n-1)&lt;/code&gt;, or explicit arrays of values like &lt;code&gt;[1.2, 3.4, 5.7]&lt;/code&gt;. The result is an N-d dense array with dimensions that are the concatenation of the dimensions of the variable ranges &lt;code&gt;rx&lt;/code&gt;, &lt;code&gt;ry&lt;/code&gt;, etc. and each &lt;code&gt;F(x,y,...)&lt;/code&gt; evaluation returns a scalar.</source>
          <target state="translated">이 형식의 의미는 &lt;code&gt;F(x,y,...)&lt;/code&gt; 가 주어진 값 목록에서 각 값을 취하는 변수 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 등으로 평가 된다는 것 입니다. 값은 반복 가능한 객체로 지정할 수 있지만 일반적으로 &lt;code&gt;1:n&lt;/code&gt; 또는 &lt;code&gt;2:(n-1)&lt;/code&gt; 과 같은 범위 이거나 &lt;code&gt;[1.2, 3.4, 5.7]&lt;/code&gt; 과 같은 명시적인 값 배열입니다 . 결과는 변수 범위 &lt;code&gt;rx&lt;/code&gt; , &lt;code&gt;ry&lt;/code&gt; 등 의 차원을 연결하는 차원을 가진 Nd 밀도 배열 이며 각 &lt;code&gt;F(x,y,...)&lt;/code&gt; 평가는 스칼라를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="094836238d056b1580750e9abbf5cfe48e515f79" translate="yes" xml:space="preserve">
          <source>The mechanism by which Julia picks default sorting algorithms is implemented via the &lt;code&gt;Base.Sort.defalg&lt;/code&gt; function. It allows a particular algorithm to be registered as the default in all sorting functions for specific arrays. For example, here are the two default methods from &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/sort.jl&quot;&gt;&lt;code&gt;sort.jl&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Julia가 기본 정렬 알고리즘을 선택하는 메커니즘은 &lt;code&gt;Base.Sort.defalg&lt;/code&gt; 함수 를 통해 구현됩니다 . 특정 배열에 대한 모든 정렬 기능에서 특정 알고리즘을 기본값으로 등록 할 수 있습니다. 예를 들어, &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/sort.jl&quot;&gt; &lt;code&gt;sort.jl&lt;/code&gt; &lt;/a&gt; 의 두 가지 기본 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="43db34e5821153c9a137e29694256181086c27e9" translate="yes" xml:space="preserve">
          <source>The mechanism for combining the roots, graph and paths data structures of the components of an environment stack is simple: they are merged as dictionaries, favoring earlier entries over later ones in the case of key collisions. In other words, if we have &lt;code&gt;stack = [env₁, env₂, &amp;hellip;]&lt;/code&gt; then we have:</source>
          <target state="translated">환경 스택 구성 요소의 루트, 그래프 및 경로 데이터 구조를 결합하는 메커니즘은 간단합니다. 키 충돌의 경우 이전 항목보다 이전 항목을 선호하는 사전으로 병합됩니다. 다시 말해서 &lt;code&gt;stack = [env₁, env₂, &amp;hellip;]&lt;/code&gt; 를 가지고 있다면 :</target>
        </trans-unit>
        <trans-unit id="ec55008649a0dc54bad05f3e8bc19d30ce40563f" translate="yes" xml:space="preserve">
          <source>The mechanism for user-defined string literals is deeply, profoundly powerful. Not only are Julia's non-standard literals implemented using it, but also the command literal syntax (&lt;code&gt;`echo &quot;Hello, $person&quot;`&lt;/code&gt;) is implemented with the following innocuous-looking macro:</source>
          <target state="translated">사용자 정의 문자열 리터럴의 메커니즘은 매우 강력하고 강력합니다. Julia의 비표준 리터럴은이를 사용하여 구현 될뿐만 아니라 명령 리터럴 구문 ( &lt;code&gt;`echo &quot;Hello, $person&quot;`&lt;/code&gt; )은 다음과 같은 무해한 매크로로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="bcd798f681426c31836c9fda7a95d8d4ad32f495" translate="yes" xml:space="preserve">
          <source>The memory consumption estimate is an approximate lower bound on the size of the internal structure of the object.</source>
          <target state="translated">메모리 소비 추정치는 객체의 내부 구조 크기에 대한 대략적인 하한입니다.</target>
        </trans-unit>
        <trans-unit id="131ca4486e37b369d3e30c30d5b64041c99a698f" translate="yes" xml:space="preserve">
          <source>The memory sharing behavior of a reshaped array is disregarded by precompilation (each view gets its own copy)</source>
          <target state="translated">재구성 된 어레이의 메모리 공유 동작은 사전 컴파일에 의해 무시됩니다 (각보기는 자체 사본을 얻습니다)</target>
        </trans-unit>
        <trans-unit id="298da21a7dd2cc02f54513ff13a66eb673f4dedf" translate="yes" xml:space="preserve">
          <source>The message log level is checked against a global minimum level (set via &lt;a href=&quot;#Base.CoreLogging.disable_logging&quot;&gt;&lt;code&gt;disable_logging&lt;/code&gt;&lt;/a&gt;). This is a crude but extremely cheap global setting.</source>
          <target state="translated">메시지 로그 레벨은 글로벌 최소 레벨 ( &lt;a href=&quot;#Base.CoreLogging.disable_logging&quot;&gt; &lt;code&gt;disable_logging&lt;/code&gt; 을&lt;/a&gt; 통해 설정)과 비교하여 점검 됩니다. 이것은 조잡하지만 매우 저렴한 글로벌 환경입니다.</target>
        </trans-unit>
        <trans-unit id="8ee1b8c607641ce31a518860743fee60270b010d" translate="yes" xml:space="preserve">
          <source>The message-processing loop waits on an &lt;code&gt;IO&lt;/code&gt; object (for example, a &lt;a href=&quot;../../stdlib/sockets/index#Sockets.TCPSocket&quot;&gt;&lt;code&gt;TCPSocket&lt;/code&gt;&lt;/a&gt; in the default implementation), reads an entire message, processes it and waits for the next one.</source>
          <target state="translated">메시지 처리 루프는 &lt;code&gt;IO&lt;/code&gt; 객체 (예 : 기본 구현 의 &lt;a href=&quot;../../stdlib/sockets/index#Sockets.TCPSocket&quot;&gt; &lt;code&gt;TCPSocket&lt;/code&gt; &lt;/a&gt; )를 대기하고 전체 메시지를 읽고 처리 한 후 다음 메시지를 기다립니다.</target>
        </trans-unit>
        <trans-unit id="34b07feb0bdcab65a9fbeace753dff1c13bab9a7" translate="yes" xml:space="preserve">
          <source>The method defined above adds parentheses around the call to &lt;code&gt;show&lt;/code&gt; when the precedence of the calling operator is higher than or equal to the precedence of multiplication. This check allows expressions which parse correctly without the parentheses (such as &lt;code&gt;:($a + 2)&lt;/code&gt; and &lt;code&gt;:($a == 2)&lt;/code&gt;) to omit them when printing:</source>
          <target state="translated">위에 정의 된 메소드 는 호출 연산자의 우선 순위가 곱셈의 우선 순위보다 높거나 같을 때 &lt;code&gt;show&lt;/code&gt; 하기 위해 호출 주위에 괄호를 추가합니다 . 이 검사를 통해 괄호없이 올바르게 구문 분석하는 표현식 (예 &lt;code&gt;:($a + 2)&lt;/code&gt; 및 &lt;code&gt;:($a == 2)&lt;/code&gt; )을 사용하여 인쇄 할 때 표현식 을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="480991bedb511928dce09fcfa14be4d26a369c2c" translate="yes" xml:space="preserve">
          <source>The method which accepts a predicate function requires Julia 1.2 or later.</source>
          <target state="translated">술어 함수를 허용하는 메소드에는 Julia 1.2 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f940b926f7e3b612433e90295b463c51a97504f9" translate="yes" xml:space="preserve">
          <source>The methods in &lt;code&gt;Profile&lt;/code&gt; are not exported and need to be called e.g. as &lt;code&gt;Profile.print()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Profile&lt;/code&gt; 의 메소드는 익스포트되지 않으므로 &lt;code&gt;Profile.print()&lt;/code&gt; 와 같이 호출되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a65046dfbce016e3be9d63dceb54432e4f789ee8" translate="yes" xml:space="preserve">
          <source>The microsecond of a &lt;code&gt;Time&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">a의 마이크로 &lt;code&gt;Time&lt;/code&gt; AS를 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f9daf874100ff7e0440c12dfc313262d02c86576" translate="yes" xml:space="preserve">
          <source>The microsecond part of a Time as a &lt;code&gt;Microsecond&lt;/code&gt;.</source>
          <target state="translated">시간의 &lt;code&gt;Microsecond&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0211eebcec0e70acc996cc19c6867555ed469b5e" translate="yes" xml:space="preserve">
          <source>The middle expression is only evaluated once, rather than twice as it would be if the expression were written as &lt;code&gt;v(1) &amp;lt; v(2) &amp;amp;&amp;amp; v(2) &amp;lt;= v(3)&lt;/code&gt;. However, the order of evaluations in a chained comparison is undefined. It is strongly recommended not to use expressions with side effects (such as printing) in chained comparisons. If side effects are required, the short-circuit &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator should be used explicitly (see &lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation-1&quot;&gt;Short-Circuit Evaluation&lt;/a&gt;).</source>
          <target state="translated">중간 표현식은 표현식이 &lt;code&gt;v(1) &amp;lt; v(2) &amp;amp;&amp;amp; v(2) &amp;lt;= v(3)&lt;/code&gt; 로 작성된 경우와 같이 두 번이 아니라 한 번만 평가됩니다 . 그러나 연쇄 비교에서 평가 순서는 정의되어 있지 않습니다. 체인 비교에서 부작용 (예 : 인쇄)이있는 표현식을 사용하지 않는 것이 좋습니다. 부작용이 필요한 경우, 단락 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 연산자 명백하게 표기 (참조 &lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation-1&quot;&gt;단락 평가&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0dd44e8ebcb71bf9c89ef76d2d2682687dc6d684" translate="yes" xml:space="preserve">
          <source>The millisecond of a &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">a의 밀리 초 &lt;code&gt;DateTime&lt;/code&gt; AS를 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a912f50c335b4d49dd33d6b3bdff08954f636271" translate="yes" xml:space="preserve">
          <source>The millisecond of a &lt;code&gt;Time&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">a의 밀리 초 &lt;code&gt;Time&lt;/code&gt; AS를 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8b6a7eeee369dc2111377df37522ca806e23ee00" translate="yes" xml:space="preserve">
          <source>The millisecond part of a DateTime as a &lt;code&gt;Millisecond&lt;/code&gt;.</source>
          <target state="translated">DateTime의 &lt;code&gt;Millisecond&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0efc4b9b581f6e3f5cda1b69fb5ed353c8f838e4" translate="yes" xml:space="preserve">
          <source>The minimum and maximum representable values of primitive numeric types such as integers are given by the &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt;&lt;code&gt;typemin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt;&lt;code&gt;typemax&lt;/code&gt;&lt;/a&gt; functions:</source>
          <target state="translated">정수와 같은 기본 숫자 유형의 최소 및 최대 표시 가능 값은 &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt; &lt;code&gt;typemin&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt; &lt;code&gt;typemax&lt;/code&gt; &lt;/a&gt; 함수로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="85c14b13e4a83e3f641ac750e22da88ea684c364" translate="yes" xml:space="preserve">
          <source>The minute of a &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">a의 분 &lt;code&gt;DateTime&lt;/code&gt; AS를 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fe1f5f0a330c1e54ad4dd4510d655f5340eec1c4" translate="yes" xml:space="preserve">
          <source>The minute of a &lt;code&gt;Time&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">a의 분 &lt;code&gt;Time&lt;/code&gt; AS를 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c946111c81e7adfe6af7b762fccd905ec8f88a87" translate="yes" xml:space="preserve">
          <source>The minute part of a DateTime as a &lt;code&gt;Minute&lt;/code&gt;.</source>
          <target state="translated">DateTime의 분 부분 ( &lt;code&gt;Minute&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="847c706add1091574c034eb4a9e1b16f126a1aa6" translate="yes" xml:space="preserve">
          <source>The month of a &lt;code&gt;Date&lt;/code&gt; or &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; 로서 &lt;code&gt;Date&lt;/code&gt; 또는 &lt;code&gt;DateTime&lt;/code&gt; 의 월입니다 .</target>
        </trans-unit>
        <trans-unit id="1ffed8c4cf30ae11b37e19dbd7e317d781c6a99d" translate="yes" xml:space="preserve">
          <source>The most basic Julia workflows involve using a text editor in conjunction with the &lt;code&gt;julia&lt;/code&gt; command line. A common pattern includes the following elements:</source>
          <target state="translated">가장 기본적인 Julia 작업 과정에는 &lt;code&gt;julia&lt;/code&gt; 명령 줄 과 함께 텍스트 편집기를 사용하는 것이 포함 됩니다. 일반적인 패턴에는 다음 요소가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d8d0db7f857485bf8537d6760d93ea9e3026a18d" translate="yes" xml:space="preserve">
          <source>The most commonly used kind of type in Julia is a struct, specified as a name and a set of fields.</source>
          <target state="translated">Julia에서 가장 일반적으로 사용되는 유형은 이름과 필드 집합으로 지정된 구조체입니다.</target>
        </trans-unit>
        <trans-unit id="bd6910dc7e6ab3eb744adf6e8b4dbbd2635bda90" translate="yes" xml:space="preserve">
          <source>The most reasonable alternative to having integer arithmetic silently overflow is to do checked arithmetic everywhere, raising errors when adds, subtracts, and multiplies overflow, producing values that are not value-correct. In this &lt;a href=&quot;http://danluu.com/integer-overflow/&quot;&gt;blog post&lt;/a&gt;, Dan Luu analyzes this and finds that rather than the trivial cost that this approach should in theory have, it ends up having a substantial cost due to compilers (LLVM and GCC) not gracefully optimizing around the added overflow checks. If this improves in the future, we could consider defaulting to checked integer arithmetic in Julia, but for now, we have to live with the possibility of overflow.</source>
          <target state="translated">정수 산술 자동 오버플로를 갖는 가장 합리적인 대안은 모든 곳에서 산술을 검사하여 오버플로를 더하거나 빼고 곱할 때 오류가 발생하여 값이 정확하지 않은 값을 생성하는 것입니다. 이 &lt;a href=&quot;http://danluu.com/integer-overflow/&quot;&gt;블로그 게시물&lt;/a&gt; 에서 Dan Luu는이를 분석하여 이론상이 접근 방식의 사소한 비용이 아니라 추가 된 오버플로 검사를 최적화하지 못하는 컴파일러 (LLVM 및 GCC)로 인해 상당한 비용이 발생한다는 사실을 발견했습니다. 미래에 이것이 개선된다면, Julia에서 기본적으로 정수 연산을 체크하는 것을 고려할 수 있지만 지금은 오버플로 가능성에 따라 살아야합니다.</target>
        </trans-unit>
        <trans-unit id="5c96614bea2c2a0370b72e64ab597c56a3607929" translate="yes" xml:space="preserve">
          <source>The most significant departures of Julia from typical dynamic languages are:</source>
          <target state="translated">전형적인 동적 언어에서 Julia가 가장 크게 출발 한 것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="227e81ea680d9761105bfdd7a757c011a63d4676" translate="yes" xml:space="preserve">
          <source>The most useful log pattern is a simple tuple of the form &lt;code&gt;(level,message)&lt;/code&gt;. A different number of tuple elements may be used to match other log metadata, corresponding to the arguments to passed to &lt;code&gt;AbstractLogger&lt;/code&gt; via the &lt;code&gt;handle_message&lt;/code&gt; function: &lt;code&gt;(level,message,module,group,id,file,line)&lt;/code&gt;. Elements which are present will be matched pairwise with the log record fields using &lt;code&gt;==&lt;/code&gt; by default, with the special cases that &lt;code&gt;Symbol&lt;/code&gt;s may be used for the standard log levels, and &lt;code&gt;Regex&lt;/code&gt;s in the pattern will match string or Symbol fields using &lt;code&gt;occursin&lt;/code&gt;.</source>
          <target state="translated">가장 유용한 로그 패턴은 &lt;code&gt;(level,message)&lt;/code&gt; 형식의 간단한 튜플입니다 . &lt;code&gt;handle_message&lt;/code&gt; 함수 &lt;code&gt;(level,message,module,group,id,file,line)&lt;/code&gt; 를 통해 &lt;code&gt;AbstractLogger&lt;/code&gt; 에 전달할 인수에 해당하는 다른 로그 메타 데이터를 일치시키기 위해 다른 수의 튜플 요소를 사용할 수 있습니다 . 존재하는 요소는 기본적으로 &lt;code&gt;==&lt;/code&gt; 를 사용하여 로그 레코드 필드와 쌍으로 일치 하며, 특수한 경우 &lt;code&gt;Symbol&lt;/code&gt; 은 표준 로그 레벨에 사용될 수 있으며 패턴의 &lt;code&gt;Regex&lt;/code&gt; 는 발생 &lt;code&gt;occursin&lt;/code&gt; 사용하여 문자열 또는 기호 필드와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="3b7050ead4b7f2406a51989e3a96dcd274b5c4dc" translate="yes" xml:space="preserve">
          <source>The name of &lt;code&gt;tag&lt;/code&gt; (e.g. &lt;code&gt;&quot;v0.5&quot;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;tag&lt;/code&gt; 이름 (예 : &lt;code&gt;&quot;v0.5&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="aac1a5f61cbf21e0f76584158e2b1aa448b0700a" translate="yes" xml:space="preserve">
          <source>The name of the function containing the execution context.</source>
          <target state="translated">실행 컨텍스트를 포함하는 함수의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="0b15e5d3b4e9ddd6442998593016569d415621b0" translate="yes" xml:space="preserve">
          <source>The nanosecond of a &lt;code&gt;Time&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">a의 나노초 &lt;code&gt;Time&lt;/code&gt; AS를 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aad1073892a176543a30631fd9ae9393da61cbfc" translate="yes" xml:space="preserve">
          <source>The nanosecond part of a Time as a &lt;code&gt;Nanosecond&lt;/code&gt;.</source>
          <target state="translated">A와 같은 시간의 나노초 부분 &lt;code&gt;Nanosecond&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82e0de7b0a951b098e85d827d86686abc302c514" translate="yes" xml:space="preserve">
          <source>The nature of keyword arguments makes it possible to specify the same argument more than once. For example, in the call &lt;code&gt;plot(x, y; options..., width=2)&lt;/code&gt; it is possible that the &lt;code&gt;options&lt;/code&gt; structure also contains a value for &lt;code&gt;width&lt;/code&gt;. In such a case the rightmost occurrence takes precedence; in this example, &lt;code&gt;width&lt;/code&gt; is certain to have the value &lt;code&gt;2&lt;/code&gt;. However, explicitly specifying the same keyword argument multiple times, for example &lt;code&gt;plot(x, y, width=2, width=3)&lt;/code&gt;, is not allowed and results in a syntax error.</source>
          <target state="translated">키워드 인수의 특성상 동일한 인수를 두 번 이상 지정할 수 있습니다. 예를 들어, call &lt;code&gt;plot(x, y; options..., width=2)&lt;/code&gt; 에서 &lt;code&gt;options&lt;/code&gt; 구조에도 &lt;code&gt;width&lt;/code&gt; 값이 포함되어있을 수 있습니다 . 이 경우 가장 오른쪽에있는 항목이 우선합니다. 이 예에서 &lt;code&gt;width&lt;/code&gt; 는 값 &lt;code&gt;2&lt;/code&gt; 를 갖습니다 . 그러나 동일한 키워드 인수를 명시 적으로 지정하는 경우 &lt;code&gt;plot(x, y, width=2, width=3)&lt;/code&gt; 예 : plot (x, y, width = 2, width = 3) )는 허용되지 않으며 구문 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="314d66ff5662511b17e76bf3864e0515f7414401" translate="yes" xml:space="preserve">
          <source>The new dimensions may be specified either as a list of arguments or as a shape tuple. At most one dimension may be specified with a &lt;code&gt;:&lt;/code&gt;, in which case its length is computed such that its product with all the specified dimensions is equal to the length of the original array &lt;code&gt;A&lt;/code&gt;. The total number of elements must not change.</source>
          <target state="translated">새로운 차원은 인수 목록 또는 모양 튜플로 지정할 수 있습니다. 최대 하나의 차원은 다음과 같이 지정 될 수 있습니다 &lt;code&gt;:&lt;/code&gt; 이 경우 지정된 모든 차원을 가진 제품이 원래 배열 &lt;code&gt;A&lt;/code&gt; 의 길이와 같도록 길이가 계산됩니다 . 총 요소 수를 변경해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="3ec82b325e399ba219250018d4cd45bb47824912" translate="yes" xml:space="preserve">
          <source>The next example composes three functions and maps the result over an array of strings:</source>
          <target state="translated">다음 예제는 세 가지 함수를 구성하고 결과를 문자열 배열에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="0141922960db98bd617ee28c2bf6139f8261ae58" translate="yes" xml:space="preserve">
          <source>The next step is to &lt;a href=&quot;https://en.wikipedia.org/wiki/Parsing#Computer_languages&quot;&gt;parse&lt;/a&gt; each string into an object called an expression, represented by the Julia type &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">다음 단계는 Julia 문자열 &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; 로&lt;/a&gt; 표시되는 표현식이라는 객체로 각 문자열 을 &lt;a href=&quot;https://en.wikipedia.org/wiki/Parsing#Computer_languages&quot;&gt;구문 분석&lt;/a&gt; 하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="571a7acf064deadfa35e0bae63b5faada78832c9" translate="yes" xml:space="preserve">
          <source>The next step is to set up the project to find the Julia include files and the libraries. It's important to know whether the Julia installation is 32- or 64-bits. Remove any platform configuration that doesn't correspond to the Julia installation before proceeding.</source>
          <target state="translated">다음 단계는 Julia 포함 파일과 라이브러리를 찾도록 프로젝트를 설정하는 것입니다. Julia 설치가 32 비트인지 64 비트인지를 아는 것이 중요합니다. 진행하기 전에 Julia 설치에 해당하지 않는 플랫폼 구성을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="87d90798d58eeb7d4e5d75a87f02bc64256ab91b" translate="yes" xml:space="preserve">
          <source>The next two higher-order methods, &lt;a href=&quot;#Dates.tonext-Tuple%7BTimeType,Int64%7D&quot;&gt;&lt;code&gt;tonext&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#Dates.toprev-Tuple%7BTimeType,Int64%7D&quot;&gt;&lt;code&gt;toprev&lt;/code&gt;&lt;/a&gt;, generalize working with temporal expressions by taking a &lt;code&gt;DateFunction&lt;/code&gt; as first argument, along with a starting &lt;a href=&quot;#Dates.TimeType&quot;&gt;&lt;code&gt;TimeType&lt;/code&gt;&lt;/a&gt;. A &lt;code&gt;DateFunction&lt;/code&gt; is just a function, usually anonymous, that takes a single &lt;a href=&quot;#Dates.TimeType&quot;&gt;&lt;code&gt;TimeType&lt;/code&gt;&lt;/a&gt; as input and returns a &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;true&lt;/code&gt; indicating a satisfied adjustment criterion. For example:</source>
          <target state="translated">다음 두 가지 고차 메서드 인 &lt;a href=&quot;#Dates.tonext-Tuple%7BTimeType,Int64%7D&quot;&gt; &lt;code&gt;tonext&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#Dates.toprev-Tuple%7BTimeType,Int64%7D&quot;&gt; &lt;code&gt;toprev&lt;/code&gt; &lt;/a&gt; 는 시작 &lt;a href=&quot;#Dates.TimeType&quot;&gt; &lt;code&gt;TimeType&lt;/code&gt; &lt;/a&gt; 과 함께 &lt;code&gt;DateFunction&lt;/code&gt; 을 첫 번째 인수로 사용하여 임시 표현식 작업을 일반화 합니다. &lt;code&gt;DateFunction&lt;/code&gt; 는 단일 얻어 보통 단지 익명 함수이다 &lt;a href=&quot;#Dates.TimeType&quot;&gt; &lt;code&gt;TimeType&lt;/code&gt; 를&lt;/a&gt; 입력으로하고, 반환 &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;true&lt;/code&gt; 나타내는 만족 조정 기준. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bfdcd43295ca16b8983e8ac5f09ed7f5b30bbe1e" translate="yes" xml:space="preserve">
          <source>The next two steps (selecting the output array and implementation) are dependent upon determining a single answer for a given set of arguments. Broadcast must take all the varied types of its arguments and collapse them down to just one output array and one implementation. Broadcast calls this single answer a &quot;style.&quot; Every broadcastable object each has its own preferred style, and a promotion-like system is used to combine these styles into a single answer &amp;mdash; the &quot;destination style&quot;.</source>
          <target state="translated">다음 두 단계 (출력 배열 및 구현 선택)는 주어진 인수 세트에 대한 단일 응답을 결정하는 데 달려 있습니다. 브로드 캐스트는 다양한 유형의 인수를 모두 가져 와서 하나의 출력 배열과 하나의 구현으로 축소해야합니다. 방송은이 단일 답변을 &quot;스타일&quot;이라고 부릅니다. 방송 가능한 모든 객체에는 각각 고유 한 선호 스타일이 있으며 이러한 스타일을 단일 대상 ( &quot;목적지 스타일&quot;)으로 결합하기 위해 프로모션과 유사한 시스템이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="aa11e7d901418eb60c69c43212182dad6fd572f8" translate="yes" xml:space="preserve">
          <source>The no-equilibration, no-transpose simplification of &lt;code&gt;gesvx!&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gesvx!&lt;/code&gt; 평형화, 무전이 단순화 ! .</target>
        </trans-unit>
        <trans-unit id="a3be6317f46ece197572e4701784f6328c75ca21" translate="yes" xml:space="preserve">
          <source>The node where the value is stored keeps track of which of the workers have a reference to it. Every time a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; or a (unfetched) &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; is serialized to a worker, the node pointed to by the reference is notified. And every time a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; or a (unfetched) &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; is garbage collected locally, the node owning the value is again notified. This is implemented in an internal cluster aware serializer. Remote references are only valid in the context of a running cluster. Serializing and deserializing references to and from regular &lt;code&gt;IO&lt;/code&gt; objects is not supported.</source>
          <target state="translated">값이 저장된 노드는 어느 작업자가 그 값을 참조하는지 추적합니다. 때마다 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; 또는 (페치되지 않은) &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 작업자에 연재되어, 노드는 참조가 통지에 의해 지적했다. 그리고 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; 또는 (페치되지 않은) &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 가 로컬로 가비지 수집 될 때마다 값을 소유 한 노드에 다시 알립니다. 이것은 내부 클러스터 인식 시리얼 라이저에서 구현됩니다. 원격 참조는 실행중인 클러스터의 컨텍스트에서만 유효합니다. 일반 &lt;code&gt;IO&lt;/code&gt; 객체에 대한 참조 직렬화 및 역 직렬화 는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ee269a033086fa0f88e3b8bd43c4d1005189ba4" translate="yes" xml:space="preserve">
          <source>The node which owns the value frees it once all references to it are cleared.</source>
          <target state="translated">값을 소유 한 노드는 모든 참조가 지워지면 해제합니다.</target>
        </trans-unit>
        <trans-unit id="9c9581a565bb9e56cce70d93ca5c19c14a7d3c0d" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;Pointy{&amp;lt;:Real}&lt;/code&gt; can be used to express the Julia analogue of a &lt;em&gt;covariant&lt;/em&gt; type, while &lt;code&gt;Pointy{&amp;gt;:Int}&lt;/code&gt; the analogue of a &lt;em&gt;contravariant&lt;/em&gt; type, but technically these represent &lt;em&gt;sets&lt;/em&gt; of types (see &lt;a href=&quot;#UnionAll-Types-1&quot;&gt;UnionAll Types&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;Pointy{&amp;lt;:Real}&lt;/code&gt; 표기법 은 &lt;em&gt;공변량&lt;/em&gt; 유형 의 Julia 유사체를 표현하는 데 사용될 수 있지만 &lt;code&gt;Pointy{&amp;gt;:Int}&lt;/code&gt; 는 &lt;em&gt;반 변형&lt;/em&gt; 유형 의 유사체 이지만 기술적으로 는 유형 &lt;em&gt;세트&lt;/em&gt; 를 나타냅니다 ( &lt;a href=&quot;#UnionAll-Types-1&quot;&gt;UnionAll Types&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="4d8a556b93d1842772dc7f76de931e723dfee64b" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;T(x)&lt;/code&gt; or &lt;code&gt;convert(T,x)&lt;/code&gt; converts &lt;code&gt;x&lt;/code&gt; to a value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">표기법 &lt;code&gt;T(x)&lt;/code&gt; 또는 &lt;code&gt;convert(T,x)&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;T&lt;/code&gt; 유형의 값으로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="fe139a73bee792b672a69d44b859332e9c6820f5" translate="yes" xml:space="preserve">
          <source>The notifications are done via sending of &quot;tracking&quot; messages&amp;ndash;an &quot;add reference&quot; message when a reference is serialized to a different process and a &quot;delete reference&quot; message when a reference is locally garbage collected.</source>
          <target state="translated">알림은 &quot;추적&quot;메시지 (참조가 다른 프로세스로 직렬화 될 때 &quot;참조 추가&quot;메시지) 및 참조가 로컬로 가비지 수집 될 때 &quot;참조 삭제&quot;메시지의 전송을 통해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="2cbf1f552e1a2901fc74809693aa1d1ec7161dbc" translate="yes" xml:space="preserve">
          <source>The notion of the UT second is actually quite fundamental. There are basically two different notions of time generally accepted, one based on the physical rotation of the earth (one full rotation = 1 day), the other based on the SI second (a fixed, constant value). These are radically different! Think about it, a &quot;UT second&quot;, as defined relative to the rotation of the earth, may have a different absolute length depending on the day! Anyway, the fact that &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; are based on UT seconds is a simplifying, yet honest assumption so that things like leap seconds and all their complexity can be avoided. This basis of time is formally called &lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_Time&quot;&gt;UT&lt;/a&gt; or UT1. Basing types on the UT second basically means that every minute has 60 seconds and every day has 24 hours and leads to more natural calculations when working with calendar dates.</source>
          <target state="translated">UT 초의 개념은 실제로 매우 근본적입니다. 기본적으로 일반적으로 받아 들여지는 두 가지 시간 개념이 있습니다. 하나는 지구의 물리적 회전 (하나의 전체 회전 = 1 일)을 기반으로하고 다른 하나는 SI 초 (고정 된 일정한 값)를 기반으로합니다. 이것들은 근본적으로 다릅니다! 지구의 회전과 관련하여 정의 된 &quot;UT 초&quot;는 날에 따라 다른 절대 길이를 가질 수 있습니다. 어쨌든 &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 이 UT 초를 기반으로 한다는 사실 은 단순하지만 정직한 가정이므로 윤초 및 모든 복잡성을 피할 수 있습니다. 이 시간 기준을 공식적으로 &lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_Time&quot;&gt;UT&lt;/a&gt; 라고합니다또는 UT1. UT 초의 기본 유형은 기본적으로 매 분마다 60 초가 있고 매일 24 시간이 있으며 달력 날짜로 작업 할 때보 다 자연스럽게 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="abccc41a26dc7addb4c68d102fecb6865b6fa56f" translate="yes" xml:space="preserve">
          <source>The number after the name indicates how many bits of storage the type requires. Currently, only sizes that are multiples of 8 bits are supported. The &lt;a href=&quot;../numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt; declaration shows how a primitive type can be optionally declared to be a subtype of some supertype.</source>
          <target state="translated">이름 뒤의 숫자는 유형에 필요한 스토리지 비트 수를 나타냅니다. 현재 8 비트의 배수 인 크기 만 지원됩니다. &lt;a href=&quot;../numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt; 원시적 형태는 선택적으로 선언 할 수있는 방법을 선언 쇼는 일부 상위 유형의 하위 유형이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="375b6efd3979207393378302c9f41c7a21121f28" translate="yes" xml:space="preserve">
          <source>The number of bits indicates how much storage the type requires and the name gives the new type a name. A primitive type can optionally be declared to be a subtype of some supertype. If a supertype is omitted, then the type defaults to having &lt;code&gt;Any&lt;/code&gt; as its immediate supertype. The declaration of &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt; above therefore means that a boolean value takes eight bits to store, and has &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt; as its immediate supertype. Currently, only sizes that are multiples of 8 bits are supported. Therefore, boolean values, although they really need just a single bit, cannot be declared to be any smaller than eight bits.</source>
          <target state="translated">비트 수는 유형에 필요한 저장 공간을 나타내며 이름은 새 유형에 이름을 부여합니다. 기본 유형은 선택적으로 일부 수퍼 유형의 하위 유형으로 선언 될 수 있습니다. 수퍼 타입이 생략되면, 디폴트는 &lt;code&gt;Any&lt;/code&gt; 를 즉시 수퍼 타입으로 설정합니다. 위 의 &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt; 선언은 부울 값을 저장하는 데 8 비트가 필요하며 &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt; 를 즉시 수퍼 타입으로 사용함을 의미합니다. 현재 8 비트의 배수 인 크기 만 지원됩니다. 따라서 부울 값은 실제로 단일 비트 만 필요하지만 8 비트보다 작게 선언 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e47d85b6b66b2f56b7aa9e07418e7bd219677af8" translate="yes" xml:space="preserve">
          <source>The number of characters in string &lt;code&gt;s&lt;/code&gt; from indices &lt;code&gt;i&lt;/code&gt; through &lt;code&gt;j&lt;/code&gt;. This is computed as the number of code unit indices from &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;j&lt;/code&gt; which are valid character indices. With only a single string argument, this computes the number of characters in the entire string. With &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; arguments it computes the number of indices between &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; inclusive that are valid indices in the string &lt;code&gt;s&lt;/code&gt;. In addition to in-bounds values, &lt;code&gt;i&lt;/code&gt; may take the out-of-bounds value &lt;code&gt;ncodeunits(s) + 1&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; may take the out-of-bounds value &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">인덱스 &lt;code&gt;i&lt;/code&gt; 에서 &lt;code&gt;j&lt;/code&gt; 까지의 문자열 &lt;code&gt;s&lt;/code&gt; 의 문자 수입니다 . 이것은 유효한 문자 인덱스 인 &lt;code&gt;i&lt;/code&gt; 부터 &lt;code&gt;j&lt;/code&gt; 까지의 코드 단위 인덱스 수로 계산됩니다 . 단일 문자열 인수 만 사용하면 전체 문자열의 문자 수를 계산합니다. 함께 &lt;code&gt;i&lt;/code&gt; 및 &lt;code&gt;j&lt;/code&gt; 인자는 지표 사이의 숫자 계산 &lt;code&gt;i&lt;/code&gt; 및 &lt;code&gt;j&lt;/code&gt; 문자열에 유효한 지표이다 포함한 &lt;code&gt;s&lt;/code&gt; . 인바운드 값 외에도 &lt;code&gt;i&lt;/code&gt; 범위를 벗어난 값 &lt;code&gt;ncodeunits(s) + 1&lt;/code&gt; 을 취할 수 있으며 &lt;code&gt;j&lt;/code&gt; 는 범위를 벗어난 값을 취할 수 있습니다 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ad86f1d6f640919b745cf8a5f2bdcf26fd5ffb5" translate="yes" xml:space="preserve">
          <source>The number of hard links to the file</source>
          <target state="translated">파일에 대한 하드 링크 수</target>
        </trans-unit>
        <trans-unit id="24a208f4a834f5901bdf25637d96fa3b819cf46a" translate="yes" xml:space="preserve">
          <source>The number of items in each dimension, if known</source>
          <target state="translated">알려진 경우 각 차원의 항목 수</target>
        </trans-unit>
        <trans-unit id="eba5aa4a440d944ee0ac4bd42c3f98d0088c8d6f" translate="yes" xml:space="preserve">
          <source>The number of items, if known</source>
          <target state="translated">알려진 경우 항목 수</target>
        </trans-unit>
        <trans-unit id="fd0b7f33e8f96892366bb012a5417e87ca9ea66f" translate="yes" xml:space="preserve">
          <source>The number of logical CPU cores available in the system, i.e. the number of threads that the CPU can run concurrently. Note that this is not necessarily the number of CPU cores, for example, in the presence of &lt;a href=&quot;https://en.wikipedia.org/wiki/Hyper-threading&quot;&gt;hyper-threading&lt;/a&gt;.</source>
          <target state="translated">시스템에서 사용 가능한 논리 CPU 코어 수, 즉 CPU가 동시에 실행할 수있는 스레드 수입니다. 예를 들어 &lt;a href=&quot;https://en.wikipedia.org/wiki/Hyper-threading&quot;&gt;하이퍼 스레딩이&lt;/a&gt; 있는 경우 CPU 코어 수는 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="e345fe9c2de9253c74f924ce4e5ac488569c4e0e" translate="yes" xml:space="preserve">
          <source>The number of seconds a newly launched worker waits for connection establishment from the master can be specified via variable &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; in the worker process's environment. Relevant only when using TCP/IP as transport.</source>
          <target state="translated">새로 시작된 작업자가 마스터에서 연결 설정을 기다리는 시간 (초) 은 작업자 프로세스 환경에서 변수 &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; 을 통해 지정할 수 있습니다 . TCP / IP를 전송으로 사용하는 경우에만 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="401c50950c464431455634fa5427d8b16913972d" translate="yes" xml:space="preserve">
          <source>The number of such blocks allocated</source>
          <target state="translated">할당 된 이러한 블록의 수</target>
        </trans-unit>
        <trans-unit id="e8e81fb72f02f0f0604e2587ad1458b114eaf4e4" translate="yes" xml:space="preserve">
          <source>The number of threads Julia starts up with is controlled by an environment variable called &lt;code&gt;JULIA_NUM_THREADS&lt;/code&gt;. Now, let's start up Julia with 4 threads:</source>
          <target state="translated">Julia가 시작하는 스레드 수는 &lt;code&gt;JULIA_NUM_THREADS&lt;/code&gt; 라는 환경 변수에 의해 제어됩니다 . 이제 4 개의 스레드로 Julia를 시작해 봅시다.</target>
        </trans-unit>
        <trans-unit id="d85834b4873990e0b8a9335e254e4dd1dde6aed2" translate="yes" xml:space="preserve">
          <source>The number of times a generated function is generated &lt;em&gt;might&lt;/em&gt; be only once, but it &lt;em&gt;might&lt;/em&gt; also be more often, or appear to not happen at all. As a consequence, you should &lt;em&gt;never&lt;/em&gt; write a generated function with side effects - when, and how often, the side effects occur is undefined. (This is true for macros too - and just like for macros, the use of &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; in a generated function is a sign that you're doing something the wrong way.) However, unlike macros, the runtime system cannot correctly handle a call to &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;, so it is disallowed.</source>
          <target state="translated">다음은 생성 된 함수가 생성되는 횟수 &lt;em&gt;수있는&lt;/em&gt; 한 번만 할 수 있지만, &lt;em&gt;수도&lt;/em&gt; 도 더 자주, 또는 전혀 발생하지 보인다. 결과적으로 부작용이 발생하는시기와 빈도가 정의되지 않은 부작용이있는 생성 된 함수를 작성 해서는 &lt;em&gt;안됩니다&lt;/em&gt; . (이것은 매크로의 경우에도 마찬가지입니다. 매크로의 경우와 마찬가지로 생성 된 함수에서 &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; 을 사용 한다는 것은 잘못된 방법을하고 있다는 표시입니다.) 그러나 매크로와 달리 런타임 시스템은 호출을 올바르게 처리 할 수 ​​없습니다 &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; 이므로 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ae813381c0022ace29605243aaae816db8d2b62" translate="yes" xml:space="preserve">
          <source>The object has three fields:</source>
          <target state="translated">객체에는 세 개의 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f26db4e1766d8278e77cd687e2593b52ae02c589" translate="yes" xml:space="preserve">
          <source>The object has two fields:</source>
          <target state="translated">객체에는 두 개의 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d6829e15fd876880334e8233e7664c2c9a74a93" translate="yes" xml:space="preserve">
          <source>The object iterated over in a &lt;code&gt;@simd for&lt;/code&gt; loop should be a one-dimensional range. By using &lt;code&gt;@simd&lt;/code&gt;, you are asserting several properties of the loop:</source>
          <target state="translated">&lt;code&gt;@simd for&lt;/code&gt; 루프 에서 반복 된 객체 는 1 차원 범위 여야합니다. &lt;code&gt;@simd&lt;/code&gt; 를 사용 하면 루프의 여러 속성을 선언 합니다.</target>
        </trans-unit>
        <trans-unit id="30a81b0cbf6e9a0a37ccae194bb527cb1e3d2158" translate="yes" xml:space="preserve">
          <source>The objects called do not have matching dimensionality. Optional argument &lt;code&gt;msg&lt;/code&gt; is a descriptive error string.</source>
          <target state="translated">호출 된 객체의 치수가 일치하지 않습니다. 선택적 인수 &lt;code&gt;msg&lt;/code&gt; 는 설명 오류 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="c67a85d00391dfa4e34905a89b16c12f29c02b01" translate="yes" xml:space="preserve">
          <source>The one-line sentence should use the imperative form (&quot;Do this&quot;, &quot;Return that&quot;) instead of the third person (do not write &quot;Returns the length...&quot;) when documenting functions. It should end with a period. If the meaning of a function cannot be summarized easily, splitting it into separate composable parts could be beneficial (this should not be taken as an absolute requirement for every single case though).</source>
          <target state="translated">한 줄 문장은 함수를 문서화 할 때 제 3 자 ( &quot;길이 반환 ...&quot;이라고 쓰지 말기) 대신 명령형 ( &quot;이것&quot;, &quot;반환&quot;)을 사용해야합니다. 마침표로 끝나야합니다. 함수의 의미를 쉽게 요약 할 수 없다면 별도의 컴포저 블 부분으로 나누는 것이 유리할 수 있습니다 (그러나 모든 경우에 대해 절대적인 요구 사항으로 간주해서는 안됩니다).</target>
        </trans-unit>
        <trans-unit id="b6ddf67182af91ce5f2d607a93387a34e5a2b0e5" translate="yes" xml:space="preserve">
          <source>The only exception to the use of &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; as the rounding epoch is when rounding to weeks. Rounding to the nearest week will always return a Monday (the first day of the week as specified by ISO 8601). For this reason, we use &lt;code&gt;0000-01-03T00:00:00&lt;/code&gt; (the first day of the first week of year 0000, as defined by ISO 8601) as the base when rounding to a number of weeks.</source>
          <target state="translated">반올림 신기원으로 &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; 을 사용하는 유일한 예외는 주로 반올림하는 경우입니다. 가장 가까운 주로 반올림하면 항상 월요일 (ISO 8601에 지정된 주중 첫 번째 날)이 반환됩니다. 이러한 이유로 우리 는 몇 주로 반올림 할 때 기준으로 &lt;code&gt;0000-01-03T00:00:00&lt;/code&gt; (ISO 8601에서 정의한 0000 년 첫 주 첫 날)을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9363f36d4f2b17a0031fe8893a1c08b698e154a6" translate="yes" xml:space="preserve">
          <source>The only explicitly disallowed names for variables are the names of built-in statements:</source>
          <target state="translated">변수에 대해 명시 적으로 허용되지 않는 유일한 이름은 내장 명령문의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b0a96430cabd292322cdf6d0ab2a28460461ca0e" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;=&lt;/code&gt; always returns the right-hand side, therefore:</source>
          <target state="translated">연산자 &lt;code&gt;=&lt;/code&gt; 는 항상 오른쪽을 반환하므로 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="61c61a08879a6bdf3c24805cb6233ff2beffb8f1" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; are non-associative. &lt;code&gt;a + b + c&lt;/code&gt; is parsed as &lt;code&gt;+(a, b, c)&lt;/code&gt; not &lt;code&gt;+(+(a, b), c)&lt;/code&gt;. However, the fallback methods for &lt;code&gt;+(a, b, c, d...)&lt;/code&gt; and &lt;code&gt;*(a, b, c, d...)&lt;/code&gt; both default to left-associative evaluation.</source>
          <target state="translated">연산자 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;++&lt;/code&gt; 및 &lt;code&gt;*&lt;/code&gt; 는 비연 관적입니다. &lt;code&gt;a + b + c&lt;/code&gt; 는 &lt;code&gt;+(a, b, c)&lt;/code&gt; 아닌 &lt;code&gt;+(+(a, b), c)&lt;/code&gt; a, b, c) 로 구문 분석됩니다 . 그러나 &lt;code&gt;+(a, b, c, d...)&lt;/code&gt; 및 &lt;code&gt;*(a, b, c, d...)&lt;/code&gt; 대한 대체 방법은 기본적으로 왼쪽 연관 평가로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="107f84ddc83f3132ac9e7c776c3ad804db96f800" translate="yes" xml:space="preserve">
          <source>The optimal choice of absolute (&lt;code&gt;atol&lt;/code&gt;) and relative tolerance (&lt;code&gt;rtol&lt;/code&gt;) varies both with the value of &lt;code&gt;M&lt;/code&gt; and the intended application of the pseudoinverse. The default relative tolerance is &lt;code&gt;n*ϵ&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the size of the smallest dimension of &lt;code&gt;M&lt;/code&gt;, and &lt;code&gt;ϵ&lt;/code&gt; is the &lt;a href=&quot;../dates/index#Base.eps&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt; of the element type of &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">절대 값 ( &lt;code&gt;atol&lt;/code&gt; ) 및 상대 허용 오차 ( &lt;code&gt;rtol&lt;/code&gt; ) 의 최적 선택은 &lt;code&gt;M&lt;/code&gt; 값 과 의사 역의 의도 된 적용에 따라 다릅니다 . 기본 상대 공차는 &lt;code&gt;n*ϵ&lt;/code&gt; 이며, 여기서 &lt;code&gt;n&lt;/code&gt; 은 &lt;code&gt;M&lt;/code&gt; 의 가장 작은 치수의 크기 이고 &lt;code&gt;ϵ&lt;/code&gt; 는 &lt;code&gt;M&lt;/code&gt; 의 요소 유형의 &lt;a href=&quot;../dates/index#Base.eps&quot;&gt; &lt;code&gt;eps&lt;/code&gt; &lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="a2df9f292c890ebf432c888dc85d326e28ff79fa" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;chars&lt;/code&gt; argument specifies which characters to remove: it can be a single character, or a vector or set of characters.</source>
          <target state="translated">선택적 &lt;code&gt;chars&lt;/code&gt; 인수는 제거 할 문자를 지정합니다. 단일 문자 또는 벡터 또는 문자 집합 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58713c9681927cdb79ff5aaa798bc3500eccfa8e" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;chars&lt;/code&gt; argument specifies which characters to remove: it can be a single character, vector or set of characters.</source>
          <target state="translated">선택적 &lt;code&gt;chars&lt;/code&gt; 인수는 제거 할 문자를 지정합니다. 단일 문자, 벡터 또는 문자 집합 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d04d2d866b93a37d08384445eed5a33ef5a6c88" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;esc&lt;/code&gt; argument specifies any additional characters that should also be escaped by a prepending backslash (&lt;code&gt;&quot;&lt;/code&gt; is also escaped by default in the first form).</source>
          <target state="translated">선택적 &lt;code&gt;esc&lt;/code&gt; 인수는 앞에 추가하는 백 슬래시로 이스케이프해야하는 추가 문자를 지정합니다 ( &lt;code&gt;&quot;&lt;/code&gt; 는 기본적으로 첫 번째 형식으로 이스케이프됩니다).</target>
        </trans-unit>
        <trans-unit id="194efabb3b5dd2732e2e6600190698fedd3b0069" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;code&gt;procs&lt;/code&gt; allows specifying a subset of all processes to have execute the expression.</source>
          <target state="translated">선택적 인수 &lt;code&gt;procs&lt;/code&gt; 를 사용하면 모든 프로세스의 서브 세트를 지정하여 표현식을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="880714bb7ddfa7f3f83801253a212b4edc50e2e9" translate="yes" xml:space="preserve">
          <source>The optional declarations string contains external functions declarations that are necessary for llvm to compile the IR string. Multiple declarations can be passed in by separating them with line breaks.</source>
          <target state="translated">선택적 선언 문자열에는 llvm이 IR 문자열을 컴파일하는 데 필요한 외부 함수 선언이 포함됩니다. 줄 바꿈으로 구분하여 여러 선언을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d319e50b1de0ad66b05495c666753f05c93c4fb2" translate="yes" xml:space="preserve">
          <source>The optional flags argument is a bitwise-or of zero or more of &lt;code&gt;RTLD_LOCAL&lt;/code&gt;, &lt;code&gt;RTLD_GLOBAL&lt;/code&gt;, &lt;code&gt;RTLD_LAZY&lt;/code&gt;, &lt;code&gt;RTLD_NOW&lt;/code&gt;, &lt;code&gt;RTLD_NODELETE&lt;/code&gt;, &lt;code&gt;RTLD_NOLOAD&lt;/code&gt;, &lt;code&gt;RTLD_DEEPBIND&lt;/code&gt;, and &lt;code&gt;RTLD_FIRST&lt;/code&gt;. These are converted to the corresponding flags of the POSIX (and/or GNU libc and/or MacOS) dlopen command, if possible, or are ignored if the specified functionality is not available on the current platform. The default flags are platform specific. On MacOS the default &lt;code&gt;dlopen&lt;/code&gt; flags are &lt;code&gt;RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL&lt;/code&gt; while on other platforms the defaults are &lt;code&gt;RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL&lt;/code&gt;. An important usage of these flags is to specify non default behavior for when the dynamic library loader binds library references to exported symbols and if the bound references are put into process local or global scope. For instance &lt;code&gt;RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL&lt;/code&gt; allows the library's symbols to be available for usage in other shared libraries, addressing situations where there are dependencies between shared libraries.</source>
          <target state="translated">선택적 flags 인수는 비트 단위 또는 0 이상의 &lt;code&gt;RTLD_LOCAL&lt;/code&gt; , &lt;code&gt;RTLD_GLOBAL&lt;/code&gt; , &lt;code&gt;RTLD_LAZY&lt;/code&gt; , &lt;code&gt;RTLD_NOW&lt;/code&gt; , &lt;code&gt;RTLD_NODELETE&lt;/code&gt; , &lt;code&gt;RTLD_NOLOAD&lt;/code&gt; , &lt;code&gt;RTLD_DEEPBIND&lt;/code&gt; 및 &lt;code&gt;RTLD_FIRST&lt;/code&gt; 입니다. 가능한 경우 POSIX (및 / 또는 GNU libc 및 / 또는 MacOS) dlopen 명령의 해당 플래그로 변환되거나 지정된 기능을 현재 플랫폼에서 사용할 수없는 경우 무시됩니다. 기본 플래그는 플랫폼에 따라 다릅니다. MacOS에서 기본 &lt;code&gt;dlopen&lt;/code&gt; 플래그는 &lt;code&gt;RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL&lt;/code&gt; 이지만 다른 플랫폼에서는 기본값이 &lt;code&gt;RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL&lt;/code&gt; . 이 플래그의 중요한 사용법은 동적 라이브러리 로더가 라이브러리 참조를 내 보낸 기호에 바인드 할 때와 바인드 된 참조가 프로세스 로컬 또는 글로벌 범위에 놓이는 경우의 비 기본 동작을 지정하는 것입니다. 예를 들어 &lt;code&gt;RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL&lt;/code&gt; 사용하면 다른 공유 라이브러리에서 라이브러리 심볼을 사용하여 공유 라이브러리간에 종속성이있는 상황을 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6852910866895c99e590be9b40672a6aa6893cd3" translate="yes" xml:space="preserve">
          <source>The optional keyword argument &lt;code&gt;context&lt;/code&gt; can be set to &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; pair or an &lt;code&gt;IO&lt;/code&gt; or &lt;a href=&quot;#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; object whose attributes are used for the I/O stream passed to &lt;code&gt;f&lt;/code&gt;. The optional &lt;code&gt;sizehint&lt;/code&gt; is a suggested size (in bytes) to allocate for the buffer used to write the string.</source>
          <target state="translated">선택적 키워드 인수 &lt;code&gt;context&lt;/code&gt; 는 &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; 쌍 또는 속성이 &lt;code&gt;f&lt;/code&gt; 로 전달 된 I / O 스트림에 사용되는 &lt;code&gt;IO&lt;/code&gt; 또는 &lt;a href=&quot;#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt; 오브젝트로 설정 될 수 있습니다 . 선택적 &lt;code&gt;sizehint&lt;/code&gt; 는 문자열을 작성하는 데 사용 된 버퍼에 할당하기 위해 제안 된 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="dcac34ba486f2b65b96a033b6cb20a0748bc3d60" translate="yes" xml:space="preserve">
          <source>The optional keyword argument &lt;code&gt;context&lt;/code&gt; can be set to &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; pair or an &lt;code&gt;IO&lt;/code&gt; or &lt;a href=&quot;#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; object whose attributes are used for the I/O stream passed to &lt;code&gt;show&lt;/code&gt;.</source>
          <target state="translated">선택적 키워드 인수 &lt;code&gt;context&lt;/code&gt; 는 &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; 쌍 또는 &lt;code&gt;show&lt;/code&gt; 에 전달 된 I / O 스트림에 속성이 사용되는 &lt;code&gt;IO&lt;/code&gt; 또는 &lt;a href=&quot;#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt; 객체로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f5605ad644c7f46c7d640d10514c1e111f9c1381" translate="yes" xml:space="preserve">
          <source>The optional keyword argument &lt;code&gt;context&lt;/code&gt; can be set to &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; pair or an &lt;code&gt;IO&lt;/code&gt; or &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; object whose attributes are used for the I/O stream passed to &lt;code&gt;show&lt;/code&gt;.</source>
          <target state="translated">선택적 키워드 인수 &lt;code&gt;context&lt;/code&gt; 는 &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; 쌍 또는 &lt;code&gt;show&lt;/code&gt; 에 전달 된 I / O 스트림에 속성이 사용되는 &lt;code&gt;IO&lt;/code&gt; 또는 &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt; 객체로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b019c5488e0a6b54b72c3dc4970022b5261bd3cf" translate="yes" xml:space="preserve">
          <source>The optional keyword argument &lt;code&gt;context&lt;/code&gt; can be set to &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; pair or an &lt;code&gt;IO&lt;/code&gt; or &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; object whose attributes are used for the I/O stream passed to &lt;code&gt;writefunc&lt;/code&gt; or &lt;code&gt;write&lt;/code&gt;.</source>
          <target state="translated">선택적 키워드 인수 &lt;code&gt;context&lt;/code&gt; 는 &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; 쌍 또는 속성이 &lt;code&gt;writefunc&lt;/code&gt; 또는 &lt;code&gt;write&lt;/code&gt; 에 전달 된 I / O 스트림에 사용되는 &lt;code&gt;IO&lt;/code&gt; 또는 &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt; 오브젝트로 설정 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="79723906c1f968e609f55475d1035da056cea38f" translate="yes" xml:space="preserve">
          <source>The optional keyword argument &lt;code&gt;context&lt;/code&gt; can be set to an &lt;code&gt;IO&lt;/code&gt; or &lt;a href=&quot;../io-network/index#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; object whose attributes are used for the I/O stream passed to &lt;code&gt;show&lt;/code&gt;.</source>
          <target state="translated">선택적 키워드 인수 &lt;code&gt;context&lt;/code&gt; 는 &lt;code&gt;show&lt;/code&gt; 에 전달 된 I / O 스트림에 속성이 사용되는 &lt;code&gt;IO&lt;/code&gt; 또는 &lt;a href=&quot;../io-network/index#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt; 객체로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d024d8ad27a045cd403adcafbb8a97939e2259d" translate="yes" xml:space="preserve">
          <source>The optional keyword arguments are:</source>
          <target state="translated">선택적 키워드 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7277b33c208d262f473b8b03d8c039301737232a" translate="yes" xml:space="preserve">
          <source>The optional list of &lt;code&gt;key=value&lt;/code&gt; pairs supports arbitrary user defined metadata which will be passed through to the logging backend as part of the log record. If only a &lt;code&gt;value&lt;/code&gt; expression is supplied, a key representing the expression will be generated using &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt;. For example, &lt;code&gt;x&lt;/code&gt; becomes &lt;code&gt;x=x&lt;/code&gt;, and &lt;code&gt;foo(10)&lt;/code&gt; becomes &lt;code&gt;Symbol(&quot;foo(10)&quot;)=foo(10)&lt;/code&gt;. For splatting a list of key value pairs, use the normal splatting syntax, &lt;code&gt;@info &quot;blah&quot; kws...&lt;/code&gt;.</source>
          <target state="translated">선택적 &lt;code&gt;key=value&lt;/code&gt; 쌍 목록은 로그 레코드의 일부로 로깅 백엔드로 전달되는 임의의 사용자 정의 메타 데이터를 지원합니다. &lt;code&gt;value&lt;/code&gt; 표현식 만 제공되면 &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; 을&lt;/a&gt; 사용하여 표현식을 나타내는 키가 생성됩니다 . 예를 들어, &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;x=x&lt;/code&gt; 가되고 &lt;code&gt;foo(10)&lt;/code&gt; 은 &lt;code&gt;Symbol(&quot;foo(10)&quot;)=foo(10)&lt;/code&gt; 됩니다. 키 값 쌍 목록을 스플래 팅하려면 일반 스플래 팅 구문 인 &lt;code&gt;@info &quot;blah&quot; kws...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01ff66cb9afdd1acbcec4725d95eb63b3a880ae3" translate="yes" xml:space="preserve">
          <source>The optional second argument restricts the search to a particular module or function (the default is all top-level modules).</source>
          <target state="translated">선택적 두 번째 인수는 검색을 특정 모듈 또는 함수로 제한합니다 (기본값은 모든 최상위 모듈 임).</target>
        </trans-unit>
        <trans-unit id="d7be768e27f40f1d8f5725cc3b53d8120d8d7888" translate="yes" xml:space="preserve">
          <source>The order of the output here is non-deterministic because the two &lt;code&gt;echo&lt;/code&gt; processes are started nearly simultaneously, and race to make the first write to the &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; descriptor they share with each other and the &lt;code&gt;julia&lt;/code&gt; parent process. Julia lets you pipe the output from both of these processes to another program:</source>
          <target state="translated">두 개의 &lt;code&gt;echo&lt;/code&gt; 프로세스가 거의 동시에 시작 되고 서로 공유 하는 &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; 디스크립터와 &lt;code&gt;julia&lt;/code&gt; 상위 프로세스에 처음으로 쓰기 위해 경쟁하기 때문에 출력의 순서는 결정적이지 않습니다 . Julia를 사용하면이 두 프로세스의 출력을 다른 프로그램으로 파이프 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e6b1ba87ceb124ce09bfd4687b3d3e543a9688a" translate="yes" xml:space="preserve">
          <source>The ordinary way to index into an &lt;code&gt;N&lt;/code&gt;-dimensional array is to use exactly &lt;code&gt;N&lt;/code&gt; indices; each index selects the position(s) in its particular dimension. For example, in the three-dimensional array &lt;code&gt;A = rand(4, 3, 2)&lt;/code&gt;, &lt;code&gt;A[2, 3, 1]&lt;/code&gt; will select the number in the second row of the third column in the first &quot;page&quot; of the array. This is often referred to as &lt;em&gt;cartesian indexing&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; 차원 배열 로 색인을 생성하는 일반적인 방법 은 정확히 &lt;code&gt;N&lt;/code&gt; 개의 인덱스 를 사용하는 것입니다 . 각 인덱스는 특정 차원에서 위치를 선택합니다. 예를 들어, 3 차원 배열 &lt;code&gt;A = rand(4, 3, 2)&lt;/code&gt; 에서 &lt;code&gt;A[2, 3, 1]&lt;/code&gt; 은 배열의 첫 번째 &quot;페이지&quot;에서 세 번째 열의 두 번째 행에있는 숫자를 선택합니다. 이것을 &lt;em&gt;직교 인덱싱&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="337d87d83fb3b26581b3bec9243dd5ba69ee3d14" translate="yes" xml:space="preserve">
          <source>The overflow protection may impose a perceptible performance penalty.</source>
          <target state="translated">오버플로 방지는 성능에 상당한 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01d86a00557c452d14c3435e0e6cf89aff65b0c2" translate="yes" xml:space="preserve">
          <source>The parameters to a function call do not match a valid signature. Argument &lt;code&gt;msg&lt;/code&gt; is a descriptive error string.</source>
          <target state="translated">함수 호출에 대한 매개 변수가 유효한 서명과 일치하지 않습니다. 인수 &lt;code&gt;msg&lt;/code&gt; 는 설명 오류 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="5cd165da81710969d9eacb18af008ac2650e61e9" translate="yes" xml:space="preserve">
          <source>The path to the file containing the execution context.</source>
          <target state="translated">실행 컨텍스트를 포함하는 파일의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="cd91887e0e75258a20a4164a826e358b38427c66" translate="yes" xml:space="preserve">
          <source>The paths map assigns to each package UUID-name pair, the location of that package's entry-point source file. After the identity of &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;import X&lt;/code&gt; has been resolved to a UUID via roots or graph (depending on whether it is loaded from the main project or a dependency), Julia determines what file to load to acquire &lt;code&gt;X&lt;/code&gt; by looking up &lt;code&gt;paths[uuid,:X]&lt;/code&gt; in the environment. Including this file should define a module named &lt;code&gt;X&lt;/code&gt;. Once this package is loaded, any subsequent import resolving to the same &lt;code&gt;uuid&lt;/code&gt; will create a new binding to the already-loaded package module.</source>
          <target state="translated">경로 맵은 각 패키지 UUID 이름 쌍 (패키지의 시작점 소스 파일의 위치)에 할당합니다. &lt;code&gt;import X&lt;/code&gt; &lt;code&gt;X&lt;/code&gt; 에서 X 의 신원이 루트 또는 그래프를 통해 UUID로 해결 된 후 (기본 프로젝트에서로드되는지 또는 종속 프로젝트에 따라), Julia는 &lt;code&gt;paths[uuid,:X]&lt;/code&gt; 를 찾아 &lt;code&gt;X&lt;/code&gt; 를 획득하기 위해로드 할 파일을 결정 합니다 [uuid, : X] 환경에서. 이 파일을 포함하면 &lt;code&gt;X&lt;/code&gt; 라는 모듈을 정의해야합니다 . 이 패키지가로드되면 동일한 &lt;code&gt;uuid&lt;/code&gt; 로 후속 가져 오기 가져 오기 는 이미로드 된 패키지 모듈에 대한 새 바인딩을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="b2b8c82c38ec794200c611dc44cc4f20a1bd32a9" translate="yes" xml:space="preserve">
          <source>The pipe operator can also be used with broadcasting, as &lt;code&gt;.|&amp;gt;&lt;/code&gt;, to provide a useful combination of the chaining/piping and dot vectorization syntax (described next).</source>
          <target state="translated">파이프 연산자를 &lt;code&gt;.|&amp;gt;&lt;/code&gt; 와 같이 브로드 캐스트와 함께 사용 하여 체인 / 파이핑 및 도트 벡터화 구문 (다음에 설명)의 유용한 조합을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="597af63e387a0238ac0d63febd38bda10ccc2c0b" translate="yes" xml:space="preserve">
          <source>The power of the &lt;code&gt;try/catch&lt;/code&gt; construct lies in the ability to unwind a deeply nested computation immediately to a much higher level in the stack of calling functions. There are situations where no error has occurred, but the ability to unwind the stack and pass a value to a higher level is desirable. Julia provides the &lt;a href=&quot;../../base/base/index#Base.rethrow&quot;&gt;&lt;code&gt;rethrow&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt;&lt;code&gt;backtrace&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt;&lt;code&gt;catch_backtrace&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.catch_stack&quot;&gt;&lt;code&gt;Base.catch_stack&lt;/code&gt;&lt;/a&gt; functions for more advanced error handling.</source>
          <target state="translated">의 전력 &lt;code&gt;try/catch&lt;/code&gt; 함수를 호출 스택에서 훨씬 더 높은 수준으로 즉시 중첩 계산을 긴장을 풀 수있는 능력의 구조 거짓말. 오류가 발생하지 않은 상황이 있지만 스택을 풀고 값을 더 높은 수준으로 전달하는 기능이 바람직합니다. Julia는 고급 오류 처리를 위해 &lt;a href=&quot;../../base/base/index#Base.rethrow&quot;&gt; &lt;code&gt;rethrow&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt; &lt;code&gt;backtrace&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt; &lt;code&gt;catch_backtrace&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/base/index#Base.catch_stack&quot;&gt; &lt;code&gt;Base.catch_stack&lt;/code&gt; &lt;/a&gt; 함수를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="8f828dfaf86a71af5078c4fd81a7efaae2debb74" translate="yes" xml:space="preserve">
          <source>The power of the &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; construct lies in the ability to unwind a deeply nested computation immediately to a much higher level in the stack of calling functions.</source>
          <target state="translated">의 전력 &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; 함수를 호출 스택에서 훨씬 더 높은 수준으로 즉시 중첩 계산을 긴장을 풀 수있는 능력의 구조 거짓말.</target>
        </trans-unit>
        <trans-unit id="8c0dcb26b25cdb065ec42a8e6b69fc74bd648292" translate="yes" xml:space="preserve">
          <source>The precedence of numeric literal coefficients is slightly lower than that of unary operators such as negation. So &lt;code&gt;-2x&lt;/code&gt; is parsed as &lt;code&gt;(-2) * x&lt;/code&gt; and &lt;code&gt;&amp;radic;2x&lt;/code&gt; is parsed as &lt;code&gt;(&amp;radic;2) * x&lt;/code&gt;. However, numeric literal coefficients parse similarly to unary operators when combined with exponentiation. For example &lt;code&gt;2^3x&lt;/code&gt; is parsed as &lt;code&gt;2^(3x)&lt;/code&gt;, and &lt;code&gt;2x^3&lt;/code&gt; is parsed as &lt;code&gt;2*(x^3)&lt;/code&gt;.</source>
          <target state="translated">숫자 리터럴 계수의 우선 순위는 부정과 같은 단항 연산자의 우선 순위보다 약간 낮습니다. 따라서 &lt;code&gt;-2x&lt;/code&gt; 는 &lt;code&gt;(-2) * x&lt;/code&gt; 로 구문 분석 되고 &lt;code&gt;&amp;radic;2x&lt;/code&gt; 는 &lt;code&gt;(&amp;radic;2) * x&lt;/code&gt; 로 구문 분석됩니다 . 그러나 숫자 리터럴 계수는 지수와 결합 될 때 단항 연산자와 유사하게 구문 분석됩니다. 예를 들어 &lt;code&gt;2^3x&lt;/code&gt; 는 &lt;code&gt;2^(3x)&lt;/code&gt; 로 구문 분석 되고 &lt;code&gt;2x^3&lt;/code&gt; 은 &lt;code&gt;2*(x^3)&lt;/code&gt; 로 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="8950edc0252b4e5921bc89b4f858ec39c03063d6" translate="yes" xml:space="preserve">
          <source>The precedence of numeric literal coefficients used for implicit multiplication is higher than other binary operators such as multiplication (&lt;code&gt;*&lt;/code&gt;), and division (&lt;code&gt;/&lt;/code&gt;, &lt;code&gt;\&lt;/code&gt;, and &lt;code&gt;//&lt;/code&gt;). This means, for example, that &lt;code&gt;1 / 2im&lt;/code&gt; equals &lt;code&gt;-0.5im&lt;/code&gt; and &lt;code&gt;6 // 2(2 + 1)&lt;/code&gt; equals &lt;code&gt;1 // 1&lt;/code&gt;.</source>
          <target state="translated">암시 적 곱셈에 사용되는 숫자 리터럴 계수의 우선 순위는 곱셈 ( &lt;code&gt;*&lt;/code&gt; ) 및 나누기 ( &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;\&lt;/code&gt; 및 &lt;code&gt;//&lt;/code&gt; ) 와 같은 다른 이진 연산자보다 높습니다 . 예를 들어, &lt;code&gt;1 / 2im&lt;/code&gt; 은 &lt;code&gt;-0.5im&lt;/code&gt; 이고 &lt;code&gt;6 // 2(2 + 1)&lt;/code&gt; 은 &lt;code&gt;1 // 1&lt;/code&gt; 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6252a13083e6a8d33233a629a05884040274a8ff" translate="yes" xml:space="preserve">
          <source>The precedence rules are defined by binary &lt;code&gt;BroadcastStyle&lt;/code&gt; calls:</source>
          <target state="translated">우선 순위 규칙은 이진 &lt;code&gt;BroadcastStyle&lt;/code&gt; 호출 로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="56837dd60f637c33dd3845553e8ea84690fc189a" translate="yes" xml:space="preserve">
          <source>The preferred style is to use instances by default, and only add methods involving &lt;code&gt;Type{MyType}&lt;/code&gt; later if they become necessary to solve some problem.</source>
          <target state="translated">선호되는 스타일은 기본적으로 인스턴스를 사용하는 것입니다. 나중에 문제를 해결하는 데 필요한 경우 나중에 &lt;code&gt;Type{MyType}&lt;/code&gt; 과 관련된 메소드 만 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="279b514949e6ab10ca4a0b3d36a0afc9aa5e5bfd" translate="yes" xml:space="preserve">
          <source>The prefix operator &lt;code&gt;∛&lt;/code&gt; is equivalent to &lt;code&gt;cbrt&lt;/code&gt;.</source>
          <target state="translated">접두사 연산자 &lt;code&gt;∛&lt;/code&gt; 는 &lt;code&gt;cbrt&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="93ebef4458176844838b02e2b993df5f493f0829" translate="yes" xml:space="preserve">
          <source>The primary function used to obtain a stack trace is &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">스택 추적을 얻는 데 사용되는 주요 기능은 &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace&lt;/code&gt; 입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e24543b8a6898ccaa9bbcf1e800fb858e73daf75" translate="yes" xml:space="preserve">
          <source>The primary use for anonymous functions is passing them to functions which take other functions as arguments. A classic example is &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, which applies a function to each value of an array and returns a new array containing the resulting values:</source>
          <target state="translated">익명 함수의 주요 용도는 다른 함수를 인수로 취하는 함수에 전달하는 것입니다. 전형적인 예는 &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; 이며, 배열의 각 값에 함수를 적용하고 결과 값이 포함 된 새 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fc2c54892fd31e8ed27deff8fd6635a872466a56" translate="yes" xml:space="preserve">
          <source>The private &lt;code&gt;Priv&lt;/code&gt; depends on the &lt;code&gt;Pub&lt;/code&gt; and &lt;code&gt;Zebra&lt;/code&gt; packages.</source>
          <target state="translated">개인 &lt;code&gt;Priv&lt;/code&gt; 는 &lt;code&gt;Pub&lt;/code&gt; 및 &lt;code&gt;Zebra&lt;/code&gt; 패키지 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="8f74ae0037646d4d3ed052aa7f6f3acf520af197" translate="yes" xml:space="preserve">
          <source>The private &lt;code&gt;Priv&lt;/code&gt; package is &quot;&lt;a href=&quot;https://stackoverflow.com/a/35109534&quot;&gt;vendored&lt;/a&gt;&quot; inside the &lt;code&gt;App&lt;/code&gt; repository.</source>
          <target state="translated">비공개 &lt;code&gt;Priv&lt;/code&gt; 패키지는 &lt;code&gt;App&lt;/code&gt; 저장소 내에서 &quot; &lt;a href=&quot;https://stackoverflow.com/a/35109534&quot;&gt;공급&lt;/a&gt; &quot;됩니다 .</target>
        </trans-unit>
        <trans-unit id="661f073fc5da6760e6d7e4ab5f75f9c8ff27e153" translate="yes" xml:space="preserve">
          <source>The problem is that now any other module that uses &lt;code&gt;Base.*&lt;/code&gt; will also see this definition. Since &lt;code&gt;Symbol&lt;/code&gt; is defined in Base and is used by other modules, this can change the behavior of unrelated code unexpectedly. There are several alternatives here, including using a different function name, or wrapping the &lt;code&gt;Symbol&lt;/code&gt;s in another type that you define.</source>
          <target state="translated">문제는 이제 &lt;code&gt;Base.*&lt;/code&gt; 를 사용하는 다른 모듈 에서도이 정의를 볼 수 있다는 것입니다. 때문에 &lt;code&gt;Symbol&lt;/code&gt; 자료에 정의되어 있으며 다른 모듈에 의해 사용되는이 예기치 않게 관련이없는 코드의 동작을 변경할 수 있습니다. 여기에는 다른 함수 이름을 사용하거나 정의한 다른 유형으로 &lt;code&gt;Symbol&lt;/code&gt; 을 래핑하는 등 여러 가지 대안이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="285d72365829e919fd96051079cd8653575f8845" translate="yes" xml:space="preserve">
          <source>The problem is that users of this type can write &lt;code&gt;x[i]&lt;/code&gt; without realizing that the operation is unsafe, and then be susceptible to memory bugs.</source>
          <target state="translated">문제는이 유형의 사용자가 작업이 안전하지 않다는 것을 인식하지 않고 &lt;code&gt;x[i]&lt;/code&gt; 를 쓸 수 있으며 메모리 버그에 취약하다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="645c5293b137aedcba8417381b97d9b765e077f5" translate="yes" xml:space="preserve">
          <source>The problem is that we want &lt;code&gt;S&lt;/code&gt; to be a larger type than &lt;code&gt;T&lt;/code&gt;, so that we can sum many elements with less information loss. For example, when &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;, we would like &lt;code&gt;S&lt;/code&gt; to be &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;. Therefore we want to avoid an interface that allows the user to construct instances of the type &lt;code&gt;SummedArray{Int32,Int32}&lt;/code&gt;. One way to do this is to provide a constructor only for &lt;code&gt;SummedArray&lt;/code&gt;, but inside the &lt;code&gt;struct&lt;/code&gt; definition block to suppress generation of default constructors:</source>
          <target state="translated">문제는 &lt;code&gt;S&lt;/code&gt; 가 &lt;code&gt;T&lt;/code&gt; 보다 큰 유형이 되기를 원 하므로 정보 손실이 적은 많은 요소를 합칠 수 있다는 것입니다. 예를 들어, &lt;code&gt;T&lt;/code&gt; 는 이다 &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt; , 우리가 원하는 &lt;code&gt;S&lt;/code&gt; 를 할 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; . 따라서 사용자가 &lt;code&gt;SummedArray{Int32,Int32}&lt;/code&gt; 유형의 인스턴스를 구성 할 수있는 인터페이스를 피하려고합니다 . 이를 수행하는 한 가지 방법은 &lt;code&gt;SummedArray&lt;/code&gt; 에만 생성자를 제공 하지만 &lt;code&gt;struct&lt;/code&gt; definition 블록 안에 기본 생성자의 생성을 억제하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fa9c416e3dd0eb96ee39260398af255d4af83ab0" translate="yes" xml:space="preserve">
          <source>The process id, &lt;code&gt;pid&lt;/code&gt;, associated with a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; identifies the process where the backing store, i.e., the backing &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; exists.</source>
          <target state="translated">&lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; 과 연관된 프로세스 ID &lt;code&gt;pid&lt;/code&gt; 는 백업 저장소, 즉 백업 &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 이 존재 하는 프로세스를 식별 합니다.</target>
        </trans-unit>
        <trans-unit id="e5711338a1a6b237dd10b96c18908bc64ecaf369" translate="yes" xml:space="preserve">
          <source>The process was stopped by a terminal interrupt (CTRL+C).</source>
          <target state="translated">프로세스가 터미널 인터럽트 (CTRL + C)에 의해 중지되었습니다.</target>
        </trans-unit>
        <trans-unit id="333bddf0932a24c46f8668b521deb6c3a862550f" translate="yes" xml:space="preserve">
          <source>The program name and the individual arguments in a command can be accessed and iterated over as if the command were an array of strings:</source>
          <target state="translated">명령의 프로그램 이름과 개별 인수는 명령이 문자열 배열 인 것처럼 액세스하고 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50007e3abed58b9e198eabc930fa126c0f7f28e5" translate="yes" xml:space="preserve">
          <source>The promotion mechanism ensures that combinations of operands of different types just work:</source>
          <target state="translated">승격 메커니즘은 서로 다른 유형의 피연산자 조합이 작동하도록합니다.</target>
        </trans-unit>
        <trans-unit id="970007866f1b490fa6101a3c913eb7623d70c629" translate="yes" xml:space="preserve">
          <source>The protection mode of the file</source>
          <target state="translated">파일의 보호 모드</target>
        </trans-unit>
        <trans-unit id="717c22bfef5d2282d64a55d9c60b43bea19c9cf1" translate="yes" xml:space="preserve">
          <source>The public &lt;code&gt;Priv&lt;/code&gt; and &lt;code&gt;Zebra&lt;/code&gt; packages are in the system depot, where packages installed and managed by the system administrator live. These are available to all users on the system.</source>
          <target state="translated">공용 &lt;code&gt;Priv&lt;/code&gt; 및 &lt;code&gt;Zebra&lt;/code&gt; 패키지는 시스템 관리자가 설치 및 관리하는 패키지가있는 시스템 저장소에 있습니다. 시스템의 모든 사용자가 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a1630b90939dc1ab04b673570b84792ee8ae787" translate="yes" xml:space="preserve">
          <source>The public &lt;code&gt;Priv&lt;/code&gt; has no dependencies.</source>
          <target state="translated">공개 &lt;code&gt;Priv&lt;/code&gt; 는 종속성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3a76e9ce5367492b5b8cf13bb66130558721cade" translate="yes" xml:space="preserve">
          <source>The quotient and remainder from Euclidean division. Equivalent to &lt;code&gt;(div(x,y), rem(x,y))&lt;/code&gt; or &lt;code&gt;(x&amp;divide;y, x%y)&lt;/code&gt;.</source>
          <target state="translated">유클리드 디비전의 몫과 나머지. 동등 &lt;code&gt;(div(x,y), rem(x,y))&lt;/code&gt; 또는 &lt;code&gt;(x&amp;divide;y, x%y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c852eff7359c80d607981a449403f86f7a08aae5" translate="yes" xml:space="preserve">
          <source>The quotient from Euclidean division. Computes &lt;code&gt;x/y&lt;/code&gt;, truncated to an integer.</source>
          <target state="translated">유클리드 디비전의 몫. 정수로 잘린 &lt;code&gt;x/y&lt;/code&gt; 를 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="b4ff83a45750ab4a00521d3b0c9044c246c68431" translate="yes" xml:space="preserve">
          <source>The rationale for this behavior is that &lt;code&gt;eps&lt;/code&gt; bounds the floating point rounding error. Under the default &lt;code&gt;RoundNearest&lt;/code&gt; rounding mode, if $y$ is a real number and $x$ is the nearest floating point number to $y$, then</source>
          <target state="translated">이 동작의 이론적 근거는 &lt;code&gt;eps&lt;/code&gt; 가 부동 소수점 반올림 오류를 제한 한다는 것 입니다. 기본 &lt;code&gt;RoundNearest&lt;/code&gt; 반올림 모드에서 $ y $가 실수이고 $ x $가 $ y $에 가장 가까운 부동 소수점 수인 경우</target>
        </trans-unit>
        <trans-unit id="fb9190d6f027ae9e2de06d7e334ba64d5fd44e85" translate="yes" xml:space="preserve">
          <source>The reason this is important enough to have been given separate syntax is that you don't want to accidentally extend a function that you didn't know existed, because that could easily cause a bug. This is most likely to happen with a method that takes a common type like a string or integer, because both you and the other module could define a method to handle such a common type. If you use &lt;code&gt;import&lt;/code&gt;, then you'll replace the other module's implementation of &lt;code&gt;bar(s::AbstractString)&lt;/code&gt; with your new implementation, which could easily do something completely different (and break all/many future usages of the other functions in module Foo that depend on calling bar).</source>
          <target state="translated">이것이 별도의 구문을 제공하기에 충분히 중요한 이유는 존재하지 않는 함수를 실수로 확장하고 싶지 않기 때문에 버그를 쉽게 일으킬 수 있기 때문입니다. 이것은 문자열 또는 정수와 같은 공통 유형을 사용하는 메소드에서 발생할 가능성이 높습니다. 왜냐하면 사용자와 다른 모듈 모두 공통 유형을 처리하는 메소드를 정의 할 수 있기 때문입니다. &lt;code&gt;import&lt;/code&gt; 를 사용 하면 다른 모듈의 &lt;code&gt;bar(s::AbstractString)&lt;/code&gt; 구현을 새 구현으로 대체하여 완전히 다른 것을 쉽게 수행 할 수 있습니다 (모듈 Foo에서 다른 기능의 모든 / 많은 미래 사용을 중단시킬 수 있음) 전화 바에 따라 다름).</target>
        </trans-unit>
        <trans-unit id="234a82c9299a864e20ceee7dc728fbbfc62b4ff9" translate="yes" xml:space="preserve">
          <source>The reason to allow modifying local variables of parent scopes in nested functions is to allow constructing &lt;a href=&quot;https://en.wikipedia.org/wiki/Closure_%28computer_programming%29&quot;&gt;&lt;code&gt;closures&lt;/code&gt;&lt;/a&gt; which have private state, for instance the &lt;code&gt;state&lt;/code&gt; variable in the following example:</source>
          <target state="translated">중첩 함수에서 상위 범위의 로컬 변수를 수정할 수있는 이유 는 개인 상태 ( 예 : 다음 예의 &lt;code&gt;state&lt;/code&gt; 변수)가있는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Closure_%28computer_programming%29&quot;&gt; &lt;code&gt;closures&lt;/code&gt; &lt;/a&gt; 를 구성 할 수 있기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="d42e24ea3d0e2aa6d81b7dd3b153611807fc05f4" translate="yes" xml:space="preserve">
          <source>The reasoning is that &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; must be &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, regardless of the value of &lt;code&gt;b&lt;/code&gt;, and likewise, the value of &lt;code&gt;a || b&lt;/code&gt; must be true if &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, regardless of the value of &lt;code&gt;b&lt;/code&gt;. Both &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; associate to the right, but &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; has higher precedence than &lt;code&gt;||&lt;/code&gt; does. It's easy to experiment with this behavior:</source>
          <target state="translated">추론이다 &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; 있어야 &lt;code&gt;false&lt;/code&gt; 경우 &lt;code&gt;a&lt;/code&gt; 이고 &lt;code&gt;false&lt;/code&gt; 없이의 값, &lt;code&gt;b&lt;/code&gt; 의 값과 마찬가지로 &lt;code&gt;a || b&lt;/code&gt; 만약 참이어야 &lt;code&gt;a&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; 에 상관없이 값, &lt;code&gt;b&lt;/code&gt; . 두 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 와 &lt;code&gt;||&lt;/code&gt; 오른쪽에 연결하지만 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 가 &lt;code&gt;||&lt;/code&gt; 보다 우선 순위가 높습니다. 그렇습니다. 이 동작을 실험하는 것은 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="179e487486d1af4b87de97016bef8d4656b4ec67" translate="yes" xml:space="preserve">
          <source>The recommended ways to iterate over a whole array are</source>
          <target state="translated">전체 배열을 반복하는 권장 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d82c055defbd84ff03cc2e56fef7d08819740213" translate="yes" xml:space="preserve">
          <source>The reduction of &lt;code&gt;x&lt;/code&gt; modulo &lt;code&gt;y&lt;/code&gt;, or equivalently, the remainder of &lt;code&gt;x&lt;/code&gt; after floored division by &lt;code&gt;y&lt;/code&gt;, i.e. &lt;code&gt;x - y*fld(x,y)&lt;/code&gt; if computed without intermediate rounding.</source>
          <target state="translated">환원 &lt;code&gt;x&lt;/code&gt; 모듈 &lt;code&gt;y&lt;/code&gt; , 또는 등가 적으로, 나머지 &lt;code&gt;x&lt;/code&gt; 에 의해 바닥의 분화 이후 &lt;code&gt;y&lt;/code&gt; , 즉 &lt;code&gt;x - y*fld(x,y)&lt;/code&gt; 의 중간 반올림하지 않고 계산하는 경우.</target>
        </trans-unit>
        <trans-unit id="c7a083bb1a1b10ec23125171dedac6f03596ea4e" translate="yes" xml:space="preserve">
          <source>The relation defined by &lt;code&gt;isless&lt;/code&gt; is transitive, i.e., &lt;code&gt;isless(x, y) &amp;amp;&amp;amp; isless(y, z)&lt;/code&gt; implies &lt;code&gt;isless(x, z)&lt;/code&gt;.</source>
          <target state="translated">에 의해 정의 된 관계 &lt;code&gt;isless&lt;/code&gt; 은 전이, 즉,이다 &lt;code&gt;isless(x, y) &amp;amp;&amp;amp; isless(y, z)&lt;/code&gt; 을 의미 &lt;code&gt;isless(x, z)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae50d1ec149a5bb325ee3ed684413be8beb00545" translate="yes" xml:space="preserve">
          <source>The relationship between &lt;code&gt;F&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;F&lt;/code&gt; 와 &lt;code&gt;A&lt;/code&gt; 의 관계 는</target>
        </trans-unit>
        <trans-unit id="f134ecdeee3cfa777ccd458bfed97ec72082e75e" translate="yes" xml:space="preserve">
          <source>The remote cache is maintained for the lifetime of the returned &lt;code&gt;CachingPool&lt;/code&gt; object. To clear the cache earlier, use &lt;code&gt;clear!(pool)&lt;/code&gt;.</source>
          <target state="translated">원격 캐시는 리턴 된 &lt;code&gt;CachingPool&lt;/code&gt; 오브젝트 의 수명 동안 유지됩니다 . 캐시를 일찍 지우려면 clear &lt;code&gt;clear!(pool)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df901bb294129f7627dac22ff5e80e400643c39f" translate="yes" xml:space="preserve">
          <source>The required keyword argument &lt;code&gt;var&lt;/code&gt; was not assigned in a function call.</source>
          <target state="translated">함수 호출에 필수 키워드 인수 &lt;code&gt;var&lt;/code&gt; 가 지정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="a9f7acaee551d1164b11cacdb547b0da33902de6" translate="yes" xml:space="preserve">
          <source>The result is a pointer giving the address of the value. The value can be manipulated through this pointer using &lt;a href=&quot;../../base/c/index#Base.unsafe_load&quot;&gt;&lt;code&gt;unsafe_load&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/c/index#Base.unsafe_store!&quot;&gt;&lt;code&gt;unsafe_store!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">결과는 값의 주소를 제공하는 포인터입니다. &lt;a href=&quot;../../base/c/index#Base.unsafe_load&quot;&gt; &lt;code&gt;unsafe_load&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/c/index#Base.unsafe_store!&quot;&gt; &lt;code&gt;unsafe_store!&lt;/code&gt; &lt;/a&gt; 사용 하여이 포인터를 통해 값을 조작 할 수 있습니다 ! .</target>
        </trans-unit>
        <trans-unit id="03cc3e3ef7a55f891b2fdc37e1dca5251bee7ee1" translate="yes" xml:space="preserve">
          <source>The result is of type &lt;code&gt;Bool&lt;/code&gt;, except when one of the operands is &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt;, in which case &lt;code&gt;missing&lt;/code&gt; is returned (&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;). For collections, &lt;code&gt;missing&lt;/code&gt; is returned if at least one of the operands contains a &lt;code&gt;missing&lt;/code&gt; value and all non-missing values are equal. Use &lt;a href=&quot;../base/index#Base.isequal&quot;&gt;&lt;code&gt;isequal&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../base/index#Core.:===&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt; to always get a &lt;code&gt;Bool&lt;/code&gt; result.</source>
          <target state="translated">피연산자 중 하나가 &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 경우를 제외하고 결과는 &lt;code&gt;Bool&lt;/code&gt; 유형 이며,이 경우 &lt;code&gt;missing&lt;/code&gt; 이 반환됩니다 ( &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;3 값 논리&lt;/a&gt; ). 컬렉션의 경우, 피연산자 중 하나 이상에 결 &lt;code&gt;missing&lt;/code&gt; 이 포함되어 있고 결 &lt;code&gt;missing&lt;/code&gt; 아닌 모든 값이 동일한 경우 결측 이 반환됩니다 . 항상 &lt;code&gt;Bool&lt;/code&gt; 결과를 얻으려면 &lt;a href=&quot;../base/index#Base.isequal&quot;&gt; &lt;code&gt;isequal&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../base/index#Core.:===&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c007650ed1d2ab98bda9d8f6e9d2a6696a562053" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;n&lt;/code&gt; iterative applications of &lt;code&gt;nextfloat&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; if &lt;code&gt;n &amp;gt;= 0&lt;/code&gt;, or &lt;code&gt;-n&lt;/code&gt; applications of &lt;code&gt;prevfloat&lt;/code&gt; if &lt;code&gt;n &amp;lt; 0&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;n&lt;/code&gt; 의 반복적 적용 &lt;code&gt;nextfloat&lt;/code&gt; 에 &lt;code&gt;x&lt;/code&gt; 만약 &lt;code&gt;n &amp;gt;= 0&lt;/code&gt; , 또는 &lt;code&gt;-n&lt;/code&gt; 의 애플리케이션 &lt;code&gt;prevfloat&lt;/code&gt; 경우 &lt;code&gt;n &amp;lt; 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94b46c3b276e64ea98bedcc1b3f79ab9ebee8c1f" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;n&lt;/code&gt; iterative applications of &lt;code&gt;prevfloat&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; if &lt;code&gt;n &amp;gt;= 0&lt;/code&gt;, or &lt;code&gt;-n&lt;/code&gt; applications of &lt;code&gt;nextfloat&lt;/code&gt; if &lt;code&gt;n &amp;lt; 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n &amp;gt;= 0&lt;/code&gt; 인 경우 &lt;code&gt;prevfloat&lt;/code&gt; 를 &lt;code&gt;x&lt;/code&gt; 로 &lt;code&gt;n&lt;/code&gt; 번 반복 적용 하거나 &lt;code&gt;n &amp;lt; 0&lt;/code&gt; 경우 &lt;code&gt;nextfloat&lt;/code&gt; &lt;code&gt;-n&lt;/code&gt; 응용 프로그램의 결과 입니다.</target>
        </trans-unit>
        <trans-unit id="3b9604e81f6338ca5014cd5645d78240588116b2" translate="yes" xml:space="preserve">
          <source>The result of an expression is too large for the specified type and will cause a wraparound.</source>
          <target state="translated">표현식의 결과가 지정된 유형에 비해 너무 커서 랩 어라운드가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5e37838dee3788d25d7398516d199b796b585b2f" translate="yes" xml:space="preserve">
          <source>The result of indexing an &lt;code&gt;AbstractArray&lt;/code&gt; can itself be an array (for instance when indexing by an &lt;code&gt;AbstractRange&lt;/code&gt;). The &lt;code&gt;AbstractArray&lt;/code&gt; fallback methods use &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt;&lt;code&gt;similar&lt;/code&gt;&lt;/a&gt; to allocate an &lt;code&gt;Array&lt;/code&gt; of the appropriate size and element type, which is filled in using the basic indexing method described above. However, when implementing an array wrapper you often want the result to be wrapped as well:</source>
          <target state="translated">&lt;code&gt;AbstractArray&lt;/code&gt; 인덱싱 결과 는 배열 일 수 있습니다 (예 : &lt;code&gt;AbstractRange&lt;/code&gt; 로 인덱싱 할 때 ). &lt;code&gt;AbstractArray&lt;/code&gt; 대체 방법을 사용하여 &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt; &lt;code&gt;similar&lt;/code&gt; &lt;/a&gt; 할당 &lt;code&gt;Array&lt;/code&gt; 기본 인덱싱 방법은 전술 한 사용에 충전되어 적당한 크기와 형태 요소의이. 그러나 배열 래퍼를 구현할 때 종종 결과도 래핑하기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="9dddd93bc0d8f1d83b952a56d60f4d4d4dde4922" translate="yes" xml:space="preserve">
          <source>The result will have the same sign as &lt;code&gt;y&lt;/code&gt;, and magnitude less than &lt;code&gt;abs(y)&lt;/code&gt; (with some exceptions, see note below).</source>
          <target state="translated">결과는 &lt;code&gt;y&lt;/code&gt; 와 같은 부호를 가지며 &lt;code&gt;abs(y)&lt;/code&gt; 보다 작은 크기 를 갖습니다 (일부 예외는 아래 참고 참조).</target>
        </trans-unit>
        <trans-unit id="f568e8a5a2b842636c272653d157a8edcd885b90" translate="yes" xml:space="preserve">
          <source>The resulting array type depends on the types of the computed elements. In order to control the type explicitly, a type can be prepended to the comprehension. For example, we could have requested the result in single precision by writing:</source>
          <target state="translated">결과 배열 유형은 계산 된 요소의 유형에 따라 다릅니다. 형식을 명시 적으로 제어하기 위해 형식 앞에 이해를 추가 할 수 있습니다. 예를 들어 다음과 같이 작성하여 단 정밀도로 결과를 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccd36a28a2ffb3965813bdc3900b2e91091344fd" translate="yes" xml:space="preserve">
          <source>The resulting container type is established by the following rules:</source>
          <target state="translated">결과 컨테이너 유형은 다음 규칙에 따라 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1fe1a92416b8011a58e509306cdd809a4d7403bb" translate="yes" xml:space="preserve">
          <source>The results are identical, and Julia's interpolation behavior mimics the shell's with some improvements due to the fact that Julia supports first-class iterable objects while most shells use strings split on spaces for this, which introduces ambiguities. When trying to port shell commands to Julia, try cut and pasting first. Since Julia shows commands to you before running them, you can easily and safely just examine its interpretation without doing any damage.</source>
          <target state="translated">결과는 동일하며 Julia의 보간 동작은 Julia가 일류 반복 가능한 객체를 지원하는 반면 대부분의 쉘은 공백으로 분할 된 문자열을 사용하기 때문에 쉘의 모방을 모방합니다. 쉘 명령을 Julia로 이식하려고 할 때 잘라내어 붙여 넣기를 먼저 시도하십시오. Julia는 명령을 실행하기 전에 명령을 표시하므로 손상없이 해석을 쉽고 안전하게 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e9c7956c24febdcf914d416fae3a917b2f39e3e" translate="yes" xml:space="preserve">
          <source>The return type is &lt;code&gt;Int&lt;/code&gt; for signed integers of less than system word size, and &lt;code&gt;UInt&lt;/code&gt; for unsigned integers of less than system word size. For all other arguments, a common return type is found to which all arguments are promoted.</source>
          <target state="translated">리턴 유형은 시스템 워드 크기보다 작은 부호있는 정수의 경우 &lt;code&gt;Int&lt;/code&gt; 이고 시스템 워드 크기 보다 작은 부호없는 정수의 경우 &lt;code&gt;UInt&lt;/code&gt; 입니다. 다른 모든 인수의 경우 모든 인수가 승격되는 공통 리턴 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bdd15fbc5eeeea487e741f6815e78f1d57eeca2" translate="yes" xml:space="preserve">
          <source>The return value is a range of indices where the matching sequence is found, such that &lt;code&gt;s[findnext(x, s, i)] == x&lt;/code&gt;:</source>
          <target state="translated">반환 값은 &lt;code&gt;s[findnext(x, s, i)] == x&lt;/code&gt; 와 같이 일치하는 시퀀스가있는 인덱스 범위입니다 .</target>
        </trans-unit>
        <trans-unit id="296596adaa4e2ffb872d464b197ffa89509d78f4" translate="yes" xml:space="preserve">
          <source>The return value is a range of indices where the matching sequence is found, such that &lt;code&gt;s[findprev(x, s, i)] == x&lt;/code&gt;:</source>
          <target state="translated">반환 값은 &lt;code&gt;s[findprev(x, s, i)] == x&lt;/code&gt; 와 같이 일치하는 시퀀스가있는 인덱스 범위입니다 .</target>
        </trans-unit>
        <trans-unit id="9c4a1e6fb47e3491c23ed68634d665b86e2b1224" translate="yes" xml:space="preserve">
          <source>The return value will be a new object initialized to contain a copy of the contents of the referenced memory. The referenced memory can safely be freed or released.</source>
          <target state="translated">반환 값은 참조 된 메모리 내용의 복사본을 포함하도록 초기화 된 새 객체입니다. 참조 된 메모리를 안전하게 해제하거나 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="995e85d8c74168d9b1cb80ff9be361035188ad05" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; can be used as an iterable object in a &lt;code&gt;for&lt;/code&gt; loop, in which case the loop variable takes on all the produced values. The loop is terminated when the channel is closed.</source>
          <target state="translated">리턴 된 &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;for&lt;/code&gt; 루프 에서 반복 가능한 객체로 사용될 수 있으며 ,이 경우 루프 변수는 생성 된 모든 값을 갖습니다. 채널이 닫히면 루프가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="4905fa2086f7e7025e1f1fb3e602f0309c36c38d" translate="yes" xml:space="preserve">
          <source>The returned function is of type &lt;code&gt;Base.Fix2{typeof(==)}&lt;/code&gt;, which can be used to implement specialized methods.</source>
          <target state="translated">리턴 된 함수는 &lt;code&gt;Base.Fix2{typeof(==)}&lt;/code&gt; 유형 이며 특수 메소드를 구현하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76989de74c6183b202bef17365490bd9a3d31c70" translate="yes" xml:space="preserve">
          <source>The returned function is of type &lt;code&gt;Base.Fix2{typeof(isequal)}&lt;/code&gt;, which can be used to implement specialized methods.</source>
          <target state="translated">리턴 된 함수는 &lt;code&gt;Base.Fix2{typeof(isequal)}&lt;/code&gt; 유형 이며 특수 메소드를 구현하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5913ac9f9933573cc3f45ba086fb826464beb36" translate="yes" xml:space="preserve">
          <source>The returned object &lt;code&gt;F&lt;/code&gt; stores the factorization in a packed format:</source>
          <target state="translated">반환 된 객체 &lt;code&gt;F&lt;/code&gt; 는 팩토리얼을 팩 형식으로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="5b6b30b85a24f3b9aaa6b8733a6c0289157aac3b" translate="yes" xml:space="preserve">
          <source>The returned tuple must only contain either &lt;code&gt;Int&lt;/code&gt;s or &lt;code&gt;AbstractArray&lt;/code&gt;s of scalar indices that are supported by array &lt;code&gt;A&lt;/code&gt;. It will error upon encountering a novel index type that it does not know how to process.</source>
          <target state="translated">반환 된 튜플은 배열 &lt;code&gt;A&lt;/code&gt; 가 지원하는 스칼라 인덱스의 &lt;code&gt;Int&lt;/code&gt; 또는 &lt;code&gt;AbstractArray&lt;/code&gt; 만 포함해야합니다 . 처리 방법을 모르는 새로운 인덱스 유형을 발견하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d9c1e00640a368c30e904f9290ae3dcb10bd1ec3" translate="yes" xml:space="preserve">
          <source>The returned value is an object with boolean fields &lt;code&gt;changed&lt;/code&gt;, &lt;code&gt;renamed&lt;/code&gt;, and &lt;code&gt;timedout&lt;/code&gt;, giving the result of watching the file.</source>
          <target state="translated">반환 값은 boolean 필드가 &lt;code&gt;changed&lt;/code&gt; , &lt;code&gt;renamed&lt;/code&gt; 되고, &lt;code&gt;timedout&lt;/code&gt; 이있는 객체 로 , 파일을 관찰 한 결과를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0aae9d904638273f671fc4e418a0190f5b8a389f" translate="yes" xml:space="preserve">
          <source>The returned value is an object with boolean fields &lt;code&gt;readable&lt;/code&gt;, &lt;code&gt;writable&lt;/code&gt;, and &lt;code&gt;timedout&lt;/code&gt;, giving the result of the polling.</source>
          <target state="translated">반환 된 값은 boolean 필드가 &lt;code&gt;readable&lt;/code&gt; , &lt;code&gt;writable&lt;/code&gt; 및 &lt;code&gt;timedout&lt;/code&gt; 인 객체로 , 폴링 결과를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="49b2889cf141c81986b5559befd286291492017c" translate="yes" xml:space="preserve">
          <source>The returned value is an pair where the first field is the name of the changed file (if available) and the second field is an object with boolean fields &lt;code&gt;changed&lt;/code&gt;, &lt;code&gt;renamed&lt;/code&gt;, and &lt;code&gt;timedout&lt;/code&gt;, giving the event.</source>
          <target state="translated">리턴 된 값은 첫 번째 필드가 변경된 파일의 이름 (사용 가능한 경우)이고 두 번째 필드는 부울 필드가 &lt;code&gt;changed&lt;/code&gt; , &lt;code&gt;renamed&lt;/code&gt; 되고 시간이 &lt;code&gt;timedout&lt;/code&gt; 되어 이벤트를 제공 하는 오브젝트 인 쌍 입니다.</target>
        </trans-unit>
        <trans-unit id="8636f9ac58bcf28e3d16135d951b8ff3e218cbd7" translate="yes" xml:space="preserve">
          <source>The reverse operation (writing data to a &lt;code&gt;Ptr{T}&lt;/code&gt;), can be performed using &lt;a href=&quot;../../base/c/index#Base.unsafe_store!&quot;&gt;&lt;code&gt;unsafe_store!(ptr, value, [index])&lt;/code&gt;&lt;/a&gt;. Currently, this is only supported for primitive types or other pointer-free (&lt;code&gt;isbits&lt;/code&gt;) immutable struct types.</source>
          <target state="translated">&lt;a href=&quot;../../base/c/index#Base.unsafe_store!&quot;&gt; &lt;code&gt;unsafe_store!(ptr, value, [index])&lt;/code&gt; &lt;/a&gt; 사용하여 역 동작 ( &lt;code&gt;Ptr{T}&lt;/code&gt; 데이터 쓰기 )을 수행 할 수 있습니다 . 현재, 이것은 기본 유형 또는 기타 포인터가없는 ( &lt;code&gt;isbits&lt;/code&gt; ) 불변의 구조체 유형에 대해서만 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="b7d58ee9a7a86e6aad0f59e6f9ed658c820e2192" translate="yes" xml:space="preserve">
          <source>The roots, graph and paths maps of a project environment are defined as follows:</source>
          <target state="translated">프로젝트 환경의 루트, 그래프 및 경로 맵은 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="8db1c63f81410ece76ca99d9ff0064394f7701c3" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt;&lt;code&gt;cholesky&lt;/code&gt;&lt;/a&gt;, but saves space by overwriting the input &lt;code&gt;A&lt;/code&gt;, instead of creating a copy. An &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt; exception is thrown if the factorization produces a number not representable by the element type of &lt;code&gt;A&lt;/code&gt;, e.g. for integer types.</source>
          <target state="translated">&lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt; &lt;code&gt;cholesky&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 사본을 작성하는 대신 입력 &lt;code&gt;A&lt;/code&gt; 를 겹쳐 쓰면 공간이 절약됩니다 . &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt; &lt;code&gt;InexactError&lt;/code&gt; 의&lt;/a&gt; 인수 분해는 요소의 유형에 의해 표현할 수없는 다수 발생하는 경우 예외가 발생 정수 형식의 예를. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7ac8db3a8fce7e45f1c23cbd8542a5bd84c64ad8" translate="yes" xml:space="preserve">
          <source>The same best practices also work for container types:</source>
          <target state="translated">컨테이너 유형에도 동일한 모범 사례가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="7644c0d871ce59114cf83dbd0542336b1d1077e8" translate="yes" xml:space="preserve">
          <source>The same thing can be done using recursion:</source>
          <target state="translated">재귀를 사용하여 동일한 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="499f37304cc2bf38bfc1e123fdaa79c60bea1de4" translate="yes" xml:space="preserve">
          <source>The script &lt;code&gt;julia-config.jl&lt;/code&gt; was created to aid in determining what build parameters are required by a program that uses embedded Julia. This script uses the build parameters and system configuration of the particular Julia distribution it is invoked by to export the necessary compiler flags for an embedding program to interact with that distribution. This script is located in the Julia shared data directory.</source>
          <target state="translated">&lt;code&gt;julia-config.jl&lt;/code&gt; 스크립트 는 내장 Julia를 사용하는 프로그램에 필요한 빌드 매개 변수를 결정하는 데 도움을주기 위해 작성되었습니다. 이 스크립트는 임베드 된 프로그램이 해당 분배와 상호 작용하기 위해 필요한 컴파일러 플래그를 내보내기 위해 호출 한 특정 Julia 분배의 빌드 매개 변수 및 시스템 구성을 사용합니다. 이 스크립트는 Julia 공유 데이터 디렉토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f8fe32c72b2738c988d9f8c4881f931f1ba36f2" translate="yes" xml:space="preserve">
          <source>The second argument &lt;code&gt;p&lt;/code&gt; is not necessarily a part of the interface for &lt;code&gt;norm&lt;/code&gt;, i.e. a custom type may only implement &lt;code&gt;norm(A)&lt;/code&gt; without second argument.</source>
          <target state="translated">두 번째 인수 &lt;code&gt;p&lt;/code&gt; 는 반드시 &lt;code&gt;norm&lt;/code&gt; 인터페이스의 일부일 필요는 없습니다 . 즉, 사용자 정의 유형은 두 번째 인수없이 &lt;code&gt;norm(A)&lt;/code&gt; 만 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b22778842445d7f70d31b000bce7d6cc33096518" translate="yes" xml:space="preserve">
          <source>The second argument to &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; can optionally be a calling convention specifier (immediately preceding return type). Without any specifier, the platform-default C calling convention is used. Other supported conventions are: &lt;code&gt;stdcall&lt;/code&gt;, &lt;code&gt;cdecl&lt;/code&gt;, &lt;code&gt;fastcall&lt;/code&gt;, and &lt;code&gt;thiscall&lt;/code&gt; (no-op on 64-bit Windows). For example (from &lt;code&gt;base/libc.jl&lt;/code&gt;) we see the same &lt;code&gt;gethostname&lt;/code&gt;&lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; as above, but with the correct signature for Windows:</source>
          <target state="translated">&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; 에&lt;/a&gt; 대한 두 번째 인수 는 선택적으로 호출 규칙 지정자 (즉시 리턴 유형) 일 수 있습니다. 지정자가 없으면 플랫폼 기본 C 호출 규칙이 사용됩니다. 지원되는 다른 규칙은 &lt;code&gt;stdcall&lt;/code&gt; , &lt;code&gt;cdecl&lt;/code&gt; , &lt;code&gt;fastcall&lt;/code&gt; 및 &lt;code&gt;thiscall&lt;/code&gt; (64 비트 Windows에서는 no-op)입니다. 예를 들어 ( &lt;code&gt;base/libc.jl&lt;/code&gt; 에서 ) 위와 동일한 &lt;code&gt;gethostname&lt;/code&gt; &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; 이 표시&lt;/a&gt; 되지만 Windows에 올바른 서명이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ae8f7c6c5ae9107bf9df78309eaedb266fcdbc6" translate="yes" xml:space="preserve">
          <source>The second form is also often better style and can lead to more code reuse.</source>
          <target state="translated">두 번째 형식은 종종 더 나은 스타일이며 더 많은 코드 재사용으로 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5a1001e237b6ff86cbef193ea1ae22360accd73" translate="yes" xml:space="preserve">
          <source>The second of a &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;DateTime&lt;/code&gt; 의 두 번째 는 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9d31d476948ba89a2e9e64c6b33fad2cd0a026a5" translate="yes" xml:space="preserve">
          <source>The second of a &lt;code&gt;Time&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; 로서의 &lt;code&gt;Time&lt;/code&gt; 의 두 번째입니다 .</target>
        </trans-unit>
        <trans-unit id="325c1f846c581874b3b9e8bdbf898464d53c77a6" translate="yes" xml:space="preserve">
          <source>The second part of a DateTime as a &lt;code&gt;Second&lt;/code&gt;.</source>
          <target state="translated">DateTime의 두 번째 부분 ( &lt;code&gt;Second&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9a3329a718673195a0538b1050837014e0187920" translate="yes" xml:space="preserve">
          <source>The second statement in the test program evaluates a Julia statement using a call to &lt;code&gt;jl_eval_string&lt;/code&gt;.</source>
          <target state="translated">테스트 프로그램의 두 번째 명령문은 &lt;code&gt;jl_eval_string&lt;/code&gt; 호출을 사용하여 Julia 명령문을 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="9cc4451185981f40556584c6f362b372cf0d2413" translate="yes" xml:space="preserve">
          <source>The second syntactic purpose of the &lt;code&gt;:&lt;/code&gt; character is to create expression objects without using the explicit &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt; constructor. This is referred to as &lt;em&gt;quoting&lt;/em&gt;. The &lt;code&gt;:&lt;/code&gt; character, followed by paired parentheses around a single statement of Julia code, produces an &lt;code&gt;Expr&lt;/code&gt; object based on the enclosed code. Here is example of the short form used to quote an arithmetic expression:</source>
          <target state="translated">&lt;code&gt;:&lt;/code&gt; 문자 의 두 번째 구문 목적은 명시적인 &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; &lt;/a&gt; 생성자를 사용하지 않고 식 객체를 만드는 것 입니다. 이를 &lt;em&gt;인용&lt;/em&gt; 이라고합니다 . &lt;code&gt;:&lt;/code&gt; 줄리아 코드의 단일 문 주위에 쌍 뒤에 괄호 문자, 생산 &lt;code&gt;Expr&lt;/code&gt; 동봉 된 코드를 기반으로 개체를. 다음은 산술 표현식을 인용하는 데 사용되는 간단한 형식의 예입니다.</target>
        </trans-unit>
        <trans-unit id="915184092841becb822c9871efbbca52119b3359" translate="yes" xml:space="preserve">
          <source>The second version will convert &lt;code&gt;x&lt;/code&gt; to an appropriate type, instead of always the same type.</source>
          <target state="translated">두 번째 버전은 항상 같은 유형 대신 &lt;code&gt;x&lt;/code&gt; 를 적절한 유형으로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="21005babd7e775084c5d9f5bf289076cc05e5e92" translate="yes" xml:space="preserve">
          <source>The section on &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;s in &lt;a href=&quot;../control-flow/index#Control-Flow-1&quot;&gt;Control Flow&lt;/a&gt; discussed the execution of multiple functions in a co-operative manner. &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;s can be quite useful to pass data between running tasks, particularly those involving I/O operations.</source>
          <target state="translated">&lt;a href=&quot;../control-flow/index#Control-Flow-1&quot;&gt;제어 흐름&lt;/a&gt; 의 &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 섹션에서는 여러 기능을 협력 적으로 실행하는 방법에 대해 설명했습니다. &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 은 실행중인 작업, 특히 I / O 작업과 관련된 작업간에 데이터를 전달하는 데 매우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8192d7c492df82ef09042dd5374aa1f14711d23" translate="yes" xml:space="preserve">
          <source>The shared array is valid as long as a reference to the &lt;code&gt;SharedArray&lt;/code&gt; object exists on the node which created the mapping.</source>
          <target state="translated">&lt;code&gt;SharedArray&lt;/code&gt; 객체에 대한 참조가 매핑을 생성 한 노드에 존재하는 한 공유 어레이는 유효 합니다.</target>
        </trans-unit>
        <trans-unit id="5dc8475813b4cdc5d96eb3c4625fbd7b58d50c66" translate="yes" xml:space="preserve">
          <source>The shortest complete expression after the &lt;code&gt;$&lt;/code&gt; is taken as the expression whose value is to be interpolated into the string. Thus, you can interpolate any expression into a string using parentheses:</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; 다음의 가장 짧은 완전한 표현식 은 값이 문자열에 보간되는 표현식으로 간주됩니다. 따라서 괄호를 사용하여 모든 표현식을 문자열로 보간 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d9f8e8412af884c31e022248ea444c48500d8b3" translate="yes" xml:space="preserve">
          <source>The simplest way to create a sparse array is to use a function equivalent to the &lt;a href=&quot;../../base/arrays/index#Base.zeros&quot;&gt;&lt;code&gt;zeros&lt;/code&gt;&lt;/a&gt; function that Julia provides for working with dense arrays. To produce a sparse array instead, you can use the same name with an &lt;code&gt;sp&lt;/code&gt; prefix:</source>
          <target state="translated">희소 배열을 작성하는 가장 간단한 방법 은 Julia가 밀도가 높은 배열에 대해 제공 하는 &lt;a href=&quot;../../base/arrays/index#Base.zeros&quot;&gt; &lt;code&gt;zeros&lt;/code&gt; &lt;/a&gt; 함수 와 동등한 기능을 사용하는 것 입니다. 희소 배열을 대신 생성하려면 &lt;code&gt;sp&lt;/code&gt; 접두사 와 동일한 이름을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b5c1b2cacc149914d1f87944b2e673b55e75f540" translate="yes" xml:space="preserve">
          <source>The singleton instance of &lt;code&gt;Colon&lt;/code&gt; is also a function used to construct ranges; see &lt;a href=&quot;../math/index#Base.::&quot;&gt;&lt;code&gt;:&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Colon&lt;/code&gt; 의 싱글 톤 인스턴스 는 또한 범위를 구성하는 데 사용되는 함수입니다. 참조 &lt;a href=&quot;../math/index#Base.::&quot;&gt; &lt;code&gt;:&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="69dbdef625126b35b49d3d64442b9b0a176ab7d3" translate="yes" xml:space="preserve">
          <source>The singleton instance of type &lt;a href=&quot;#Base.Missing&quot;&gt;&lt;code&gt;Missing&lt;/code&gt;&lt;/a&gt; representing a missing value.</source>
          <target state="translated">결 측값을 나타내는 &lt;a href=&quot;#Base.Missing&quot;&gt; &lt;code&gt;Missing&lt;/code&gt; &lt;/a&gt; 유형의 싱글 톤 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="d89078042c9eb6d352a7eb66e0b88b0400546bfa" translate="yes" xml:space="preserve">
          <source>The singleton instance of type &lt;a href=&quot;../base/index#Core.Nothing&quot;&gt;&lt;code&gt;Nothing&lt;/code&gt;&lt;/a&gt;, used by convention when there is no value to return (as in a C &lt;code&gt;void&lt;/code&gt; function) or when a variable or field holds no value.</source>
          <target state="translated">반환 할 값이 없거나 (C &lt;code&gt;void&lt;/code&gt; 함수 에서와 같이 ) 변수 또는 필드에 값이없는 경우 규칙에 의해 &lt;a href=&quot;../base/index#Core.Nothing&quot;&gt; &lt;code&gt;Nothing&lt;/code&gt; &lt;/a&gt; 유형의 싱글 톤 인스턴스가 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="98c477c6e9d21cf836746a2bcff1d62c547964d7" translate="yes" xml:space="preserve">
          <source>The size (in bytes) of the file</source>
          <target state="translated">파일의 크기 (바이트)</target>
        </trans-unit>
        <trans-unit id="b66123090eeef1135c4d4375118f6396f24e2b0e" translate="yes" xml:space="preserve">
          <source>The slightly odd feature of these declarations as compared to typical parametric composite types, is that the type parameter &lt;code&gt;T&lt;/code&gt; is not used in the definition of the type itself &amp;ndash; it is just an abstract tag, essentially defining an entire family of types with identical structure, differentiated only by their type parameter. Thus, &lt;code&gt;Ptr{Float64}&lt;/code&gt; and &lt;code&gt;Ptr{Int64}&lt;/code&gt; are distinct types, even though they have identical representations. And of course, all specific pointer types are subtypes of the umbrella &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt;&lt;code&gt;Ptr&lt;/code&gt;&lt;/a&gt; type:</source>
          <target state="translated">일반적인 파라 메트릭 복합 유형과 비교할 때 이러한 선언의 약간 이상한 특징은 유형 매개 변수 &lt;code&gt;T&lt;/code&gt; 가 유형 자체의 정의에 사용되지 않는다는 것입니다. 이는 본질적으로 동일한 구조로 전체 유형 군을 정의하는 추상 태그 일뿐입니다. 유형 매개 변수에 의해서만 차별화됩니다. 따라서, &lt;code&gt;Ptr{Float64}&lt;/code&gt; 및 &lt;code&gt;Ptr{Int64}&lt;/code&gt; 는 동일한 표현을 갖지만 고유 한 유형입니다. 물론 모든 특정 포인터 유형은 우산 &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt; &lt;code&gt;Ptr&lt;/code&gt; &lt;/a&gt; 유형의 하위 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="b70321f704716a765747450fd9a29400a288057e" translate="yes" xml:space="preserve">
          <source>The smallest &lt;code&gt;a^n&lt;/code&gt; not less than &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is a non-negative integer. &lt;code&gt;a&lt;/code&gt; must be greater than 1, and &lt;code&gt;x&lt;/code&gt; must be greater than 0.</source>
          <target state="translated">가장 작은 &lt;code&gt;a^n&lt;/code&gt; 은 &lt;code&gt;x&lt;/code&gt; 이상입니다 . 여기서 &lt;code&gt;n&lt;/code&gt; 은 음이 아닌 정수입니다. &lt;code&gt;a&lt;/code&gt; 는 1보다 커야하고 &lt;code&gt;x&lt;/code&gt; 는 0보다 커야합니다.</target>
        </trans-unit>
        <trans-unit id="8e217f5379986c6dbb724913b9402b2744112320" translate="yes" xml:space="preserve">
          <source>The smallest in absolute value non-subnormal value representable by the given floating-point DataType &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">주어진 부동 소수점 DataType &lt;code&gt;T&lt;/code&gt; 로 표현할 수있는 최소값의 비정규 값 입니다.</target>
        </trans-unit>
        <trans-unit id="25349e0ef0dc3df135e9bbaceeafe9aedb6a8cb7" translate="yes" xml:space="preserve">
          <source>The so-called &quot;ternary operator&quot;, &lt;code&gt;?:&lt;/code&gt;, is closely related to the &lt;code&gt;if&lt;/code&gt;-&lt;code&gt;elseif&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt; syntax, but is used where a conditional choice between single expression values is required, as opposed to conditional execution of longer blocks of code. It gets its name from being the only operator in most languages taking three operands:</source>
          <target state="translated">소위 &quot;삼항 연산자&quot;( &lt;code&gt;?:&lt;/code&gt; &lt;code&gt;elseif&lt;/code&gt; 는 &lt;code&gt;if&lt;/code&gt; - elseif - &lt;code&gt;else&lt;/code&gt; 구문 과 밀접한 관련이 있지만 더 긴 코드 블록의 조건부 실행과 달리 단일 표현식 값 사이의 조건부 선택이 필요한 경우에 사용됩니다. 세 가지 피연산자를 사용하는 대부분의 언어에서 유일한 연산자라는 이름을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="466b5c814e2cc3e14c74b0b3d7f3038223cc5afa" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;CartesianIndex{N}&lt;/code&gt; object represents a scalar index that behaves like an &lt;code&gt;N&lt;/code&gt;-tuple of integers spanning multiple dimensions. For example:</source>
          <target state="translated">특수 &lt;code&gt;CartesianIndex{N}&lt;/code&gt; 객체는 여러 차원에 걸쳐 있는 &lt;code&gt;N&lt;/code&gt; - 튜플 정수 처럼 동작하는 스칼라 인덱스를 나타냅니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="762a1096309b147153ae61442ac8f98b5b44d380" translate="yes" xml:space="preserve">
          <source>The specified range is partitioned and locally executed across all workers. In case an optional reducer function is specified, &lt;code&gt;@distributed&lt;/code&gt; performs local reductions on each worker with a final reduction on the calling process.</source>
          <target state="translated">지정된 범위는 모든 작업자에서 분할되고 로컬로 실행됩니다. 선택적 감속기 기능이 지정된 경우 &lt;code&gt;@distributed&lt;/code&gt; 는 각 작업자에 대해 로컬 축소를 수행하여 통화 프로세스를 최종 축소합니다.</target>
        </trans-unit>
        <trans-unit id="af76c7aa8adb68998b2eccf29c56d714b4910790" translate="yes" xml:space="preserve">
          <source>The stack of current exceptions can be accessed using the experimental &lt;a href=&quot;../../base/base/index#Base.catch_stack&quot;&gt;&lt;code&gt;Base.catch_stack&lt;/code&gt;&lt;/a&gt; function. For example,</source>
          <target state="translated">실험적인 &lt;a href=&quot;../../base/base/index#Base.catch_stack&quot;&gt; &lt;code&gt;Base.catch_stack&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 현재 예외 스택에 액세스 할 수 있습니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="b314da4796576e2f7b71a666741e2ef66714401f" translate="yes" xml:space="preserve">
          <source>The standard way to obtain a value of a certain type &lt;code&gt;T&lt;/code&gt; is to call the type's constructor, &lt;code&gt;T(x)&lt;/code&gt;. However, there are cases where it's convenient to convert a value from one type to another without the programmer asking for it explicitly. One example is assigning a value into an array: if &lt;code&gt;A&lt;/code&gt; is a &lt;code&gt;Vector{Float64}&lt;/code&gt;, the expression &lt;code&gt;A[1] = 2&lt;/code&gt; should work by automatically converting the &lt;code&gt;2&lt;/code&gt; from &lt;code&gt;Int&lt;/code&gt; to &lt;code&gt;Float64&lt;/code&gt;, and storing the result in the array. This is done via the &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">특정 유형 &lt;code&gt;T&lt;/code&gt; 의 값을 얻는 표준 방법 은 유형의 생성자 &lt;code&gt;T(x)&lt;/code&gt; 를 호출하는 것 입니다. 그러나 프로그래머가 명시 적으로 요구하지 않고 한 유형에서 다른 유형으로 값을 변환하는 것이 편리한 경우가 있습니다. 한 예는 배열에 값을 할당하는 것입니다. &lt;code&gt;A&lt;/code&gt; 가 &lt;code&gt;Vector{Float64}&lt;/code&gt; 인 경우 &lt;code&gt;A[1] = 2&lt;/code&gt; 식은 &lt;code&gt;2&lt;/code&gt; 를 &lt;code&gt;Int&lt;/code&gt; 에서 &lt;code&gt;Float64&lt;/code&gt; 로 자동 변환 하고 결과를 배열에 저장하여 작동합니다. 이것은 &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; 기능을 통해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="09c9759ec2f73e324d46f0dc859670daa106989a" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;using BigLib: thing1, thing2&lt;/code&gt; brings just the identifiers &lt;code&gt;thing1&lt;/code&gt; and &lt;code&gt;thing2&lt;/code&gt; into scope from module &lt;code&gt;BigLib&lt;/code&gt;. If these names refer to functions, adding methods to them will not be allowed (you may only &quot;use&quot; them, not extend them).</source>
          <target state="translated">&lt;code&gt;using BigLib: thing1, thing2&lt;/code&gt; 하는 명령문 은 모듈 &lt;code&gt;BigLib&lt;/code&gt; 에서 식별자 &lt;code&gt;thing1&lt;/code&gt; 및 &lt;code&gt;thing2&lt;/code&gt; 만 범위로 가져옵니다 . 이러한 이름이 함수를 참조하는 경우 메소드를 추가 할 수 없습니다 (확장하지 않고 &quot;사용&quot;만 가능).</target>
        </trans-unit>
        <trans-unit id="495d86d0b4d05239c00e12e65404916397e09df9" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;using Lib&lt;/code&gt; means that a module called &lt;code&gt;Lib&lt;/code&gt; will be available for resolving names as needed. When a global variable is encountered that has no definition in the current module, the system will search for it among variables exported by &lt;code&gt;Lib&lt;/code&gt; and import it if it is found there. This means that all uses of that global within the current module will resolve to the definition of that variable in &lt;code&gt;Lib&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;using Lib&lt;/code&gt; 문장 은 필요에 따라 &lt;code&gt;Lib&lt;/code&gt; 라는 모듈을 사용하여 이름을 확인할 수 있음을 의미 합니다. 현재 모듈에서 정의가없는 전역 변수가 발견되면 시스템은 &lt;code&gt;Lib&lt;/code&gt; 에서 내 보낸 변수 중에서 해당 변수를 검색하여 찾은 경우 가져옵니다. 이것은 현재 모듈 내에서 해당 전역의 모든 사용이 &lt;code&gt;Lib&lt;/code&gt; 에서 해당 변수의 정의로 해석됨을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="e69251ee5ae969dde76ae7aecf53b32517ef054f" translate="yes" xml:space="preserve">
          <source>The stride should be unit stride.</source>
          <target state="translated">보폭은 단위 보폭이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b5f6cb2eda0183a3a023b5793fbbc533b8630c5f" translate="yes" xml:space="preserve">
          <source>The strongest legacy of Lisp in the Julia language is its metaprogramming support. Like Lisp, Julia represents its own code as a data structure of the language itself. Since code is represented by objects that can be created and manipulated from within the language, it is possible for a program to transform and generate its own code. This allows sophisticated code generation without extra build steps, and also allows true Lisp-style macros operating at the level of &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot;&gt;abstract syntax trees&lt;/a&gt;. In contrast, preprocessor &quot;macro&quot; systems, like that of C and C++, perform textual manipulation and substitution before any actual parsing or interpretation occurs. Because all data types and code in Julia are represented by Julia data structures, powerful &lt;a href=&quot;https://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;reflection&lt;/a&gt; capabilities are available to explore the internals of a program and its types just like any other data.</source>
          <target state="translated">Julia 언어에서 Lisp의 가장 강력한 유산은 메타 프로그래밍 지원입니다. Lisp와 마찬가지로 Julia는 자체 코드를 언어 자체의 데이터 구조로 나타냅니다. 코드는 언어 내에서 만들고 조작 할 수있는 객체로 표시되므로 프로그램이 자체 코드를 변환하고 생성 할 수 있습니다. 이를 통해 추가 빌드 단계없이 정교한 코드 생성이 가능하며 &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot;&gt;추상 구문 트리&lt;/a&gt; 수준에서 작동하는 진정한 Lisp 스타일 매크로도 허용 됩니다. 대조적으로, C 및 C ++와 같은 전 처리기 &quot;매크로&quot;시스템은 실제 파싱 또는 해석이 발생하기 전에 텍스트 조작 및 대체를 수행합니다. Julia의 모든 데이터 유형 및 코드는 Julia 데이터 구조로 표시되므로 강력한 &lt;a href=&quot;https://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;반영&lt;/a&gt; 다른 데이터와 마찬가지로 프로그램의 내부 및 유형을 탐색 할 수있는 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e569356ccc37557b3dd3a4c9eb2b13531bfa9b1" translate="yes" xml:space="preserve">
          <source>The subdiagonal part contains the reflectors $v_i$ stored in a packed format such that &lt;code&gt;V = I + tril(F.factors, -1)&lt;/code&gt;.</source>
          <target state="translated">서브 대각선 부분은 &lt;code&gt;V = I + tril(F.factors, -1)&lt;/code&gt; 과 같이 압축 형식으로 저장된 반사기 $ v_i $를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="c0c6aba56e3888ce8991d8adbbc0407169b7c0c0" translate="yes" xml:space="preserve">
          <source>The subdiagonal part contains the reflectors $v_i$ stored in a packed format where $v_i$ is the $i$th column of the matrix &lt;code&gt;V = I + tril(F.factors, -1)&lt;/code&gt;.</source>
          <target state="translated">subdiagonal 부분은 압축 형식으로 저장된 반사기 $ v_i $를 포함합니다. 여기서 $ v_i $는 행렬 &lt;code&gt;V = I + tril(F.factors, -1)&lt;/code&gt; 의 $ i $ th 열입니다 .</target>
        </trans-unit>
        <trans-unit id="7e2a34ecc15f647be67c38e382f5d48daa6d45c2" translate="yes" xml:space="preserve">
          <source>The subscripted &lt;code&gt;rootsᵢ&lt;/code&gt;, &lt;code&gt;graphᵢ&lt;/code&gt; and &lt;code&gt;pathsᵢ&lt;/code&gt; variables correspond to the subscripted environments, &lt;code&gt;envᵢ&lt;/code&gt;, contained in &lt;code&gt;stack&lt;/code&gt;. The &lt;code&gt;reverse&lt;/code&gt; is present because &lt;code&gt;merge&lt;/code&gt; favors the last argument rather than first when there are collisions between keys in its argument dictionaries. There are a couple of noteworthy features of this design:</source>
          <target state="translated">아래 첨자 &lt;code&gt;rootsᵢ&lt;/code&gt; , &lt;code&gt;graphᵢ&lt;/code&gt; 및 &lt;code&gt;pathsᵢ&lt;/code&gt; 변수 는 &lt;code&gt;stack&lt;/code&gt; 에 포함 된 첨자 환경 &lt;code&gt;envᵢ&lt;/code&gt; 에 해당합니다 . 인수 사전에 키 사이에 충돌이있을 때 &lt;code&gt;merge&lt;/code&gt; 가 첫 번째 인수보다는 마지막 인수를 선호 하기 때문에 그 &lt;code&gt;reverse&lt;/code&gt; 가 있습니다. 이 디자인에는 주목할만한 몇 가지 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="996fc71a38fd366e817f73bce0377ef4ace5919b" translate="yes" xml:space="preserve">
          <source>The subtypes of &lt;code&gt;AbstractArray&lt;/code&gt; typically implement two methods to achieve this: A method to convert the input array to a subtype of a specific &lt;code&gt;AbstractArray{T, N}&lt;/code&gt; abstract type; and a method to make a new uninitialized array with a specific element type. Sample implementations of these can be found in Julia Base. Here is a basic example usage of them, guaranteeing that &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;output&lt;/code&gt; are of the same type:</source>
          <target state="translated">&lt;code&gt;AbstractArray&lt;/code&gt; 의 하위 유형은 일반적으로이를 달성하기 위해 두 가지 방법을 구현합니다. 입력 배열을 특정 &lt;code&gt;AbstractArray{T, N}&lt;/code&gt; 추상 유형 의 하위 유형으로 변환하는 방법 ; 특정 요소 유형으로 초기화되지 않은 새로운 배열을 만드는 방법. 이에 대한 샘플 구현은 Julia Base에서 찾을 수 있습니다. 다음은 &lt;code&gt;input&lt;/code&gt; 과 &lt;code&gt;output&lt;/code&gt; 이 동일한 유형 임을 보장하는 기본적인 사용법입니다 .</target>
        </trans-unit>
        <trans-unit id="63699aa33be9f33f21d62b86441a8ff8e274be42" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;M.x = y&lt;/code&gt; does not work to assign a global in another module; global assignment is always module-local.</source>
          <target state="translated">구문 &lt;code&gt;M.x = y&lt;/code&gt; 는 다른 모듈에서 전역을 할당하는 데 작동하지 않습니다. 전역 할당은 항상 모듈 로컬입니다.</target>
        </trans-unit>
        <trans-unit id="8aef45ce051e500a72b345ef2f22cdbfc5692cd9" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;[A, B, C, ...]&lt;/code&gt; constructs a 1-d array (i.e., a vector) of its arguments. If all arguments have a common &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;promotion type&lt;/a&gt; then they get converted to that type using &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구문은 &lt;code&gt;[A, B, C, ...]&lt;/code&gt; 인수의 1 차원 어레이 (즉, 벡터)를 구성한다. 모든 인수에 공통 &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;승격 유형&lt;/a&gt; 이 있으면 &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; 를&lt;/a&gt; 사용하여 해당 유형으로 변환 됩니다.</target>
        </trans-unit>
        <trans-unit id="e625bef095d2c8eb72ebaeebbec92f580bcf9df3" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;a.b = c&lt;/code&gt; calls &lt;code&gt;setproperty!(a, :b, c)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a.b = c&lt;/code&gt; 구문 은 &lt;code&gt;setproperty!(a, :b, c)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="bb9de73fee4d35f05a94de3650ba9db8d2743f66" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;a.b&lt;/code&gt; calls &lt;code&gt;getproperty(a, :b)&lt;/code&gt;.</source>
          <target state="translated">구문 &lt;code&gt;a.b&lt;/code&gt; 는 &lt;code&gt;getproperty(a, :b)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="00608410463d33a3565dc12e2221379a6b79beb5" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;catch e&lt;/code&gt; (where &lt;code&gt;e&lt;/code&gt; is any variable) assigns the thrown exception object to the given variable within the &lt;code&gt;catch&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;catch e&lt;/code&gt; 구문 (여기서 &lt;code&gt;e&lt;/code&gt; 는 임의의 변수)은 throw 된 예외 객체를 &lt;code&gt;catch&lt;/code&gt; 블록 내의 지정된 변수에 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="fbb021dba0d683eea0a7e9eec6250ba19720138f" translate="yes" xml:space="preserve">
          <source>The syntax for images is similar to the link syntax mentioned above. Prepending a &lt;code&gt;!&lt;/code&gt; character to a link will display an image from the specified URL rather than a link to it.</source>
          <target state="translated">이미지의 구문은 위에서 언급 한 링크 구문과 유사합니다. 앞에 &lt;code&gt;!&lt;/code&gt; 문자 대 링크는 링크가 아닌 지정된 URL의 이미지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="4706abb51ce58ba5921e55c75731359f252d532a" translate="yes" xml:space="preserve">
          <source>The syntax of &lt;code&gt;remotecall&lt;/code&gt; is not especially convenient. The macro &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt; makes things easier. It operates on an expression rather than a function, and picks where to do the operation for you:</source>
          <target state="translated">&lt;code&gt;remotecall&lt;/code&gt; 의 구문은 특히 편리하지 않습니다. &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt; 매크로 는 일을 더 쉽게 만듭니다. 함수가 아닌 표현식에서 작동하며 작업을 수행 할 위치를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="e63059505e9b54a2aa7f6f114401eafe55571016" translate="yes" xml:space="preserve">
          <source>The syntaxes &lt;code&gt;A[end]&lt;/code&gt; and &lt;code&gt;A[end, end]&lt;/code&gt; lower to &lt;code&gt;A[lastindex(A)]&lt;/code&gt; and &lt;code&gt;A[lastindex(A, 1), lastindex(A, 2)]&lt;/code&gt;, respectively.</source>
          <target state="translated">구문 &lt;code&gt;A[end]&lt;/code&gt; 및 &lt;code&gt;A[end, end]&lt;/code&gt; 는 각각 &lt;code&gt;A[lastindex(A)]&lt;/code&gt; 및 &lt;code&gt;A[lastindex(A, 1), lastindex(A, 2)]&lt;/code&gt; 집니다.</target>
        </trans-unit>
        <trans-unit id="76ff0041a09cb9e2761ca760c9e89d92dece6223" translate="yes" xml:space="preserve">
          <source>The system also generates some standard information for each event:</source>
          <target state="translated">시스템은 또한 각 이벤트에 대한 몇 가지 표준 정보를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1291d08b43c51644b75972a68949c78194cf4ab6" translate="yes" xml:space="preserve">
          <source>The system provides several advantages over peppering your source code with calls to &lt;code&gt;println()&lt;/code&gt;. First, it allows you to control the visibility and presentation of messages without editing the source code. For example, in contrast to the &lt;code&gt;@warn&lt;/code&gt; above</source>
          <target state="translated">이 시스템은 &lt;code&gt;println()&lt;/code&gt; 호출로 소스 코드를 페퍼하는 것보다 몇 가지 장점을 제공합니다 . 먼저 소스 코드를 편집하지 않고도 메시지의 가시성과 표시를 제어 할 수 있습니다. 예를 들어 위 의 &lt;code&gt;@warn&lt;/code&gt; 과 달리</target>
        </trans-unit>
        <trans-unit id="35ef5183de88aa885d43235fbe1c95c14449a9c3" translate="yes" xml:space="preserve">
          <source>The tab key can also be used to substitute LaTeX math symbols with their Unicode equivalents, and get a list of LaTeX matches as well:</source>
          <target state="translated">탭 키를 사용하여 LaTeX 수학 기호를 해당 유니 코드 문자로 대체하고 LaTeX 일치 항목 목록을 가져올 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6bb24eed2bccbd623888cb79506fd88f02fa796" translate="yes" xml:space="preserve">
          <source>The text associated with a footnote can be written anywhere within the same page as the footnote reference. The syntax used to define the footnote text is discussed in the &lt;a href=&quot;#Footnotes-1&quot;&gt;Footnotes&lt;/a&gt; section below.</source>
          <target state="translated">각주와 관련된 텍스트는 각주 참조와 동일한 페이지 내 어디에서나 쓸 수 있습니다. 각주 텍스트를 정의하는 데 사용되는 구문은 아래 &lt;a href=&quot;#Footnotes-1&quot;&gt;각주&lt;/a&gt; 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="89803a19d844f78ae00674dace9498726fc7f334" translate="yes" xml:space="preserve">
          <source>The third and final kind of environment is one that combines other environments by overlaying several of them, making the packages in each available in a single composite environment. These composite environments are called &lt;em&gt;environment stacks&lt;/em&gt;. The Julia &lt;code&gt;LOAD_PATH&lt;/code&gt; global defines an environment stack&amp;mdash;the environment in which the Julia process operates. If you want your Julia process to have access only to the packages in one project or package directory, make it the only entry in &lt;code&gt;LOAD_PATH&lt;/code&gt;. It is often quite useful, however, to have access to some of your favorite tools&amp;mdash;standard libraries, profilers, debuggers, personal utilities, etc.&amp;mdash;even if they are not dependencies of the project you're working on. By adding an environment containing these tools to the load path, you immediately have access to them in top-level code without needing to add them to your project.</source>
          <target state="translated">세 번째이자 마지막 종류의 환경은 여러 환경을 겹쳐서 다른 환경을 결합하여 하나의 복합 환경에서 각 패키지를 사용할 수있는 환경입니다. 이러한 복합 환경을 &lt;em&gt;환경 스택&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; . Julia &lt;code&gt;LOAD_PATH&lt;/code&gt; 전역은 Julia 스택이 작동하는 환경 인 환경 스택을 정의합니다. Julia 프로세스가 하나의 프로젝트 또는 패키지 디렉토리에있는 패키지에만 액세스 할 수있게하려면 &lt;code&gt;LOAD_PATH&lt;/code&gt; 의 유일한 항목으로 만드십시오.. 그러나 작업중인 프로젝트의 종속성이 아니더라도 표준 라이브러리, 프로파일 러, 디버거, 개인 유틸리티 등 즐겨 사용하는 도구에 액세스하는 것이 종종 유용합니다. 이러한 도구가 포함 된 환경을로드 경로에 추가하면 프로젝트에 추가하지 않고도 최상위 코드로 즉시 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e5e0709035da59f79f484697f8e3df4d573f5fc" translate="yes" xml:space="preserve">
          <source>The three kinds of types (abstract, primitive, composite) discussed in the previous sections are actually all closely related. They share the same key properties:</source>
          <target state="translated">이전 섹션에서 논의한 세 가지 유형의 유형 (추상, 기본, 복합)은 실제로 모두 밀접하게 관련되어 있습니다. 동일한 주요 속성을 공유합니다.</target>
        </trans-unit>
        <trans-unit id="96a22cbc00a4020163f8bf8451c0cb52f4fe8ed1" translate="yes" xml:space="preserve">
          <source>The three-valued logic described above for logical operators is also used by logical functions applied to arrays. Thus, array equality tests using the &lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt; operator return &lt;code&gt;missing&lt;/code&gt; whenever the result cannot be determined without knowing the actual value of the &lt;code&gt;missing&lt;/code&gt; entry. In practice, this means that &lt;code&gt;missing&lt;/code&gt; is returned if all non-missing values of the compared arrays are equal, but one or both arrays contain missing values (possibly at different positions)</source>
          <target state="translated">논리 연산자에 대해 위에서 설명한 3 값 논리는 배열에 적용된 논리 함수에서도 사용됩니다. 따라서 &lt;code&gt;missing&lt;/code&gt; 항목 의 실제 값을 알지 못하면 결과를 확인할 수 없을 때마다 &lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt; 연산자를 사용하여 배열 동등성 테스트에서 &lt;code&gt;missing&lt;/code&gt; 반환 합니다. 실제로 이것은 비교 된 배열의 모든 비결 측 값이 같지만 하나 또는 두 배열에 결측 값이 포함 된 경우 (다른 위치에 있음) &lt;code&gt;missing&lt;/code&gt; 이 반환 됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7bb480c16cbf47fe55bf38e90f5861a483a884fb" translate="yes" xml:space="preserve">
          <source>The tuple must be the same size as the SIMD type. For example, a tuple representing an &lt;code&gt;__m128&lt;/code&gt; on x86 must have a size of 16 bytes.</source>
          <target state="translated">튜플은 SIMD 유형과 크기가 같아야합니다. 예를 들어, x86 에서 &lt;code&gt;__m128&lt;/code&gt; 을 나타내는 튜플 의 크기는 16 바이트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="d71d89013d2d694c3c90bff3726394654345117f" translate="yes" xml:space="preserve">
          <source>The two expressions constructed above &amp;ndash; by parsing and by direct construction &amp;ndash; are equivalent:</source>
          <target state="translated">구문 분석과 직접 구성을 통해 위에 구성된 두 가지 표현은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="3b3360fde4989c6fe95a691dce2016abf50d9177" translate="yes" xml:space="preserve">
          <source>The two uses of the &lt;code&gt;...&lt;/code&gt; operator: slurping and splatting</source>
          <target state="translated">&lt;code&gt;...&lt;/code&gt; 연산자 의 두 가지 용도 : 슬러 핑 및 스플래 팅</target>
        </trans-unit>
        <trans-unit id="b96a5c8aeea4ce2a16e47711028fe9eaf98f3763" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Point{Float64}&lt;/code&gt; is a point whose coordinates are 64-bit floating-point values, while the type &lt;code&gt;Point{AbstractString}&lt;/code&gt; is a &quot;point&quot; whose &quot;coordinates&quot; are string objects (see &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/ast/#Strings-1&quot;&gt;Strings&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;Point{Float64}&lt;/code&gt; 유형 은 좌표가 64 비트 부동 소수점 값인 지점이고 &lt;code&gt;Point{AbstractString}&lt;/code&gt; 유형 은 &quot;coordinates&quot;가 문자열 객체 인 &quot;point&quot;입니다 ( &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/ast/#Strings-1&quot;&gt;Strings&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6b7369108ecd55df4b36265309c9d17ce4d10c19" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Vararg{T,N}&lt;/code&gt; corresponds to exactly &lt;code&gt;N&lt;/code&gt; elements of type &lt;code&gt;T&lt;/code&gt;. &lt;code&gt;NTuple{N,T}&lt;/code&gt; is a convenient alias for &lt;code&gt;Tuple{Vararg{T,N}}&lt;/code&gt;, i.e. a tuple type containing exactly &lt;code&gt;N&lt;/code&gt; elements of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">타입 &lt;code&gt;Vararg{T,N}&lt;/code&gt; 정확히에 대응하는 &lt;code&gt;N&lt;/code&gt; 형의 요소 &lt;code&gt;T&lt;/code&gt; . &lt;code&gt;NTuple{N,T}&lt;/code&gt; 는 &lt;code&gt;Tuple{Vararg{T,N}}&lt;/code&gt; 의 편리한 별명입니다 . 즉, 정확히 유형 &lt;code&gt;T&lt;/code&gt; 의 &lt;code&gt;N&lt;/code&gt; 개 요소를 포함하는 튜플 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="5bedae316814d6156803443fcc9c13d8c64877a4" translate="yes" xml:space="preserve">
          <source>The type annotation partially recovers lost performance due to capturing because the parser can associate a concrete type to the object in the box. Going further, if the captured variable does not need to be boxed at all (because it will not be reassigned after the closure is created), this can be indicated with &lt;code&gt;let&lt;/code&gt; blocks as follows.</source>
          <target state="translated">파서가 구체적인 유형을 상자의 개체에 연결할 수 있기 때문에 형식 주석은 캡처로 인한 성능 손실을 부분적으로 복구합니다. 또한 캡처 된 변수를 상자에 넣을 필요가없는 경우 (닫힘이 생성 된 후 변수가 다시 할당되지 않기 때문에) 다음과 같이 &lt;code&gt;let&lt;/code&gt; 블록으로 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6fbcbd4db01a84d712a7283dfeb43aba8b033041" translate="yes" xml:space="preserve">
          <source>The type application syntax &lt;code&gt;A{B,C}&lt;/code&gt; requires &lt;code&gt;A&lt;/code&gt; to be a &lt;code&gt;UnionAll&lt;/code&gt; type, and first substitutes &lt;code&gt;B&lt;/code&gt; for the outermost type variable in &lt;code&gt;A&lt;/code&gt;. The result is expected to be another &lt;code&gt;UnionAll&lt;/code&gt; type, into which &lt;code&gt;C&lt;/code&gt; is then substituted. So &lt;code&gt;A{B,C}&lt;/code&gt; is equivalent to &lt;code&gt;A{B}{C}&lt;/code&gt;. This explains why it is possible to partially instantiate a type, as in &lt;code&gt;Array{Float64}&lt;/code&gt;: the first parameter value has been fixed, but the second still ranges over all possible values. Using explicit &lt;code&gt;where&lt;/code&gt; syntax, any subset of parameters can be fixed. For example, the type of all 1-dimensional arrays can be written as &lt;code&gt;Array{T,1} where T&lt;/code&gt;.</source>
          <target state="translated">형식 응용 프로그램 구문 &lt;code&gt;A{B,C}&lt;/code&gt; 하려면 &lt;code&gt;A&lt;/code&gt; 가 &lt;code&gt;UnionAll&lt;/code&gt; 형식 이어야 하며 먼저 &lt;code&gt;A&lt;/code&gt; 의 가장 바깥 쪽 형식 변수 대신 &lt;code&gt;B&lt;/code&gt; 를 사용합니다 . 결과는 &lt;code&gt;C&lt;/code&gt; 가 대체 되는 또 다른 &lt;code&gt;UnionAll&lt;/code&gt; 유형 이 될 것으로 예상됩니다 . 따라서 &lt;code&gt;A{B,C}&lt;/code&gt; 는 &lt;code&gt;A{B}{C}&lt;/code&gt; . 이것은 &lt;code&gt;Array{Float64}&lt;/code&gt; 와 같이 유형을 부분적으로 인스턴스화 할 수있는 이유를 설명합니다 . 첫 번째 매개 변수 값은 고정되었지만 두 번째 매개 변수는 여전히 모든 가능한 값의 범위입니다. 명시 적 &lt;code&gt;where&lt;/code&gt; 사용구문의 경우 매개 변수의 모든 서브 세트를 수정할 수 있습니다. 예를 들어, 모든 1 차원 배열의 유형은 &lt;code&gt;Array{T,1} where T&lt;/code&gt; 로 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ffb66b4dabff5050a74ff3cadfb7762c384071e4" translate="yes" xml:space="preserve">
          <source>The type arguments to &lt;code&gt;ccall&lt;/code&gt; and &lt;code&gt;@cfunction&lt;/code&gt; are evaluated statically, when the method containing the usage is defined. They therefore must take the form of a literal tuple, not a variable, and cannot reference local variables.</source>
          <target state="translated">사용법을 포함하는 메소드가 정의되면 &lt;code&gt;ccall&lt;/code&gt; 및 &lt;code&gt;@cfunction&lt;/code&gt; 에 대한 유형 인수 는 정적으로 평가됩니다. 따라서 변수가 아닌 리터럴 튜플의 형식을 가져야하며 로컬 변수를 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1a668fb8c29cba9ffa772e3e0ec9a1a70c5fa795" translate="yes" xml:space="preserve">
          <source>The type is an &lt;code&gt;Array{T,N}&lt;/code&gt; with a bits-type element of &lt;code&gt;T&lt;/code&gt; and dimension &lt;code&gt;N&lt;/code&gt; that determines how the bytes of the array are interpreted. Note that the file must be stored in binary format, and no format conversions are possible (this is a limitation of operating systems, not Julia).</source>
          <target state="translated">유형은 인 &lt;code&gt;Array{T,N}&lt;/code&gt; (A)의 비트 형 소자와 &lt;code&gt;T&lt;/code&gt; 및 차원 &lt;code&gt;N&lt;/code&gt; 어레이의 바이트가 어떻게 해석되는지를 결정한다. 파일은 2 진 형식으로 저장해야하며 형식 변환은 불가능합니다 (Julia가 아닌 운영 체제의 제한 사항 임).</target>
        </trans-unit>
        <trans-unit id="7d5dd90cb0f8495d6d15c26b83250961e3145b2f" translate="yes" xml:space="preserve">
          <source>The type of field &lt;code&gt;a&lt;/code&gt; can be readily determined from the type of &lt;code&gt;m&lt;/code&gt;, but not from the type of &lt;code&gt;t&lt;/code&gt;. Indeed, in &lt;code&gt;t&lt;/code&gt; it's possible to change the type of the field &lt;code&gt;a&lt;/code&gt;:</source>
          <target state="translated">필드 유형 &lt;code&gt;a&lt;/code&gt; 는 &lt;code&gt;m&lt;/code&gt; 유형에서 쉽게 결정할 수 있지만 &lt;code&gt;t&lt;/code&gt; 유형에서는 쉽게 결정할 수 없습니다 . 사실에 &lt;code&gt;t&lt;/code&gt; 는 필드의 타입 변경하는 것이 가능 &lt;code&gt;a&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="282394fd5d6e1d690607a98e995ab7809b63cd8e" translate="yes" xml:space="preserve">
          <source>The type of object used to represent identifiers in parsed julia code (ASTs). Also often used as a name or label to identify an entity (e.g. as a dictionary key). &lt;code&gt;Symbol&lt;/code&gt;s can be entered using the &lt;code&gt;:&lt;/code&gt; quote operator:</source>
          <target state="translated">구문 분석 된 줄리아 코드 (AST)에서 식별자를 나타내는 데 사용되는 객체의 유형입니다. 또한 엔터티를 식별하기위한 이름 또는 레이블 (예 : 사전 키)로 자주 사용됩니다. &lt;code&gt;:&lt;/code&gt; quote 연산자를 사용하여 &lt;code&gt;Symbol&lt;/code&gt; 입력 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e9d435d74348a381158dd6b8006d6bf402fcef60" translate="yes" xml:space="preserve">
          <source>The type of the admonition can be any word, but some types produce special styling, namely (in order of decreasing severity): &lt;code&gt;danger&lt;/code&gt;, &lt;code&gt;warning&lt;/code&gt;, &lt;code&gt;info&lt;/code&gt;/&lt;code&gt;note&lt;/code&gt;, and &lt;code&gt;tip&lt;/code&gt;.</source>
          <target state="translated">훈계의 유형은 모든 단어가 될 수 있지만 일부 유형은 &lt;code&gt;danger&lt;/code&gt; , &lt;code&gt;warning&lt;/code&gt; , &lt;code&gt;info&lt;/code&gt; / &lt;code&gt;note&lt;/code&gt; 및 &lt;code&gt;tip&lt;/code&gt; 과 같은 특별한 스타일을 만듭니다 (예 : 심각도 감소 순서) .</target>
        </trans-unit>
        <trans-unit id="95cde77f6d397a5966075de74e297cbf03487660" translate="yes" xml:space="preserve">
          <source>The type of the first argument of this method is a &lt;a href=&quot;../types/index#man-singleton-types-1&quot;&gt;singleton type&lt;/a&gt;, &lt;code&gt;Type{MyType}&lt;/code&gt;, the only instance of which is &lt;code&gt;MyType&lt;/code&gt;. Thus, this method is only invoked when the first argument is the type value &lt;code&gt;MyType&lt;/code&gt;. Notice the syntax used for the first argument: the argument name is omitted prior to the &lt;code&gt;::&lt;/code&gt; symbol, and only the type is given. This is the syntax in Julia for a function argument whose type is specified but whose value does not need to be referenced by name. In this example, since the type is a singleton, we already know its value without referring to an argument name.</source>
          <target state="translated">이 메소드의 첫 번째 인수 유형은 &lt;a href=&quot;../types/index#man-singleton-types-1&quot;&gt;단일 유형&lt;/a&gt; 인 &lt;code&gt;Type{MyType}&lt;/code&gt; 이며, 유일한 유형 은 &lt;code&gt;MyType&lt;/code&gt; 입니다. 따라서이 메소드는 첫 번째 인수가 &lt;code&gt;MyType&lt;/code&gt; 유형 값인 경우에만 호출됩니다 . 첫 번째 인수에 사용 된 구문에 유의하십시오. 인수 이름은 &lt;code&gt;::&lt;/code&gt; 기호 앞에 생략 되고 유형 만 제공됩니다. 이것은 유형이 지정되었지만 이름으로 값을 참조 할 필요가없는 함수 인수에 대한 Julia의 구문입니다. 이 예제에서는 유형이 싱글 톤이므로 인수 이름을 참조하지 않고 해당 값을 이미 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cdf4225b7d8119f12b6f1e72fd124d403b4e26b" translate="yes" xml:space="preserve">
          <source>The type of the first entry of the tuple returned by &lt;code&gt;iterate()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;iterate()&lt;/code&gt; 반환 한 튜플의 첫 번째 항목 유형</target>
        </trans-unit>
        <trans-unit id="5aa022df5697534e05992976fa7f76aa1feeee08" translate="yes" xml:space="preserve">
          <source>The types &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt;&lt;code&gt;Int8&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt; all have identical representations: they are eight-bit chunks of memory. Since Julia's type system is nominative, however, they are not interchangeable despite having identical structure. A fundamental difference between them is that they have different supertypes: &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;'s direct supertype is &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt;&lt;code&gt;Int8&lt;/code&gt;&lt;/a&gt;'s is &lt;a href=&quot;../../base/numbers/index#Core.Signed&quot;&gt;&lt;code&gt;Signed&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt;'s is &lt;a href=&quot;../../base/numbers/index#Core.Unsigned&quot;&gt;&lt;code&gt;Unsigned&lt;/code&gt;&lt;/a&gt;. All other differences between &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt;&lt;code&gt;Int8&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt; are matters of behavior &amp;ndash; the way functions are defined to act when given objects of these types as arguments. This is why a nominative type system is necessary: if structure determined type, which in turn dictates behavior, then it would be impossible to make &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt; behave any differently than &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt;&lt;code&gt;Int8&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt; &lt;code&gt;Int8&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt; 유형 은 모두 동일한 표현을 갖습니다. 이들은 8 비트 메모리 청크입니다. 그러나 Julia의 유형 시스템은 명목상 동일하지만 동일한 구조에도 불구하고 서로 호환되지 않습니다. 그들 사이의 근본적인 차이점은 서로 다른 수퍼 타입을 가진다는 것입니다. &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt; 의 직접 수퍼 타입은 &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt; &lt;code&gt;Int8&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;../../base/numbers/index#Core.Signed&quot;&gt; &lt;code&gt;Signed&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;../../base/numbers/index#Core.Unsigned&quot;&gt; &lt;code&gt;Unsigned&lt;/code&gt; &lt;/a&gt; 입니다. &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt; &lt;code&gt;Int8&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; 의&lt;/a&gt; 다른 모든 차이점행동의 문제 &amp;ndash; 함수가 이러한 유형의 객체가 인수로 주어질 때 작동하도록 정의되는 방식. 이것이 명목 형 시스템이 필요한 이유입니다. 만약 구조가 유형을 결정하여 동작을 지시한다면, &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; 을&lt;/a&gt;&lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt; &lt;code&gt;Int8&lt;/code&gt; &lt;/a&gt; 이나 &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt; 과 다르게 행동하게하는 것은 불가능합니다 .</target>
        </trans-unit>
        <trans-unit id="b0109db562376dbf272015811ad8745f34d0c123" translate="yes" xml:space="preserve">
          <source>The types of keyword arguments can be made explicit as follows:</source>
          <target state="translated">키워드 인수의 유형은 다음과 같이 명시 적으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="150a26f4f49fe87245564e04ceb960fcfbaf40b2" translate="yes" xml:space="preserve">
          <source>The unary operators &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; require explicit parentheses around their argument to disambiguate them from the operator &lt;code&gt;++&lt;/code&gt;, etc. Other compositions of unary operators are parsed with right-associativity, e. g., &lt;code&gt;&amp;radic;&amp;radic;-a&lt;/code&gt; as &lt;code&gt;&amp;radic;(&amp;radic;(-a))&lt;/code&gt;.</source>
          <target state="translated">단항 연산자 &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;-&lt;/code&gt; 는 연산자 &lt;code&gt;++&lt;/code&gt; 등에서 명확하게하기 위해 인수 주위에 명시적인 괄호가 필요합니다 . 단항 연산자의 다른 구성은 오른쪽 연관성으로 구문 분석됩니다 (예 : &lt;code&gt;&amp;radic;&amp;radic;-a&lt;/code&gt; as &lt;code&gt;&amp;radic;(&amp;radic;(-a))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6715363fde6cdd7a1a24ce6e74d2c35a82ab804" translate="yes" xml:space="preserve">
          <source>The underscore &lt;code&gt;_&lt;/code&gt; can be used as digit separator:</source>
          <target state="translated">밑줄 &lt;code&gt;_&lt;/code&gt; 은 숫자 구분 기호로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dc9c5b98b8ad88332e71a97e793e826e1cab445" translate="yes" xml:space="preserve">
          <source>The uniform scaling operator</source>
          <target state="translated">균일 한 스케일링 연산자</target>
        </trans-unit>
        <trans-unit id="37b7ee86ac667d6f86c0ad3037e31cb90445aa51" translate="yes" xml:space="preserve">
          <source>The updating versions of all the binary arithmetic and bitwise operators are:</source>
          <target state="translated">모든 이진 산술 및 비트 연산자의 업데이트 버전은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1cf2be628194a336d3bbb72bed6445464a756995" translate="yes" xml:space="preserve">
          <source>The upper triangular part contains the elements of $R$, that is &lt;code&gt;R = triu(F.factors)&lt;/code&gt; for a &lt;code&gt;QR&lt;/code&gt; object &lt;code&gt;F&lt;/code&gt;.</source>
          <target state="translated">상단 삼각 부분에는 $ R $의 요소, 즉 &lt;code&gt;QR&lt;/code&gt; 객체 &lt;code&gt;F&lt;/code&gt; 에 대한 &lt;code&gt;R = triu(F.factors)&lt;/code&gt; 가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="227320fa312076c32b3808304d06cb30fbcb2399" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;$&lt;/code&gt; for expression interpolation is intentionally reminiscent of &lt;a href=&quot;../strings/index#string-interpolation-1&quot;&gt;string interpolation&lt;/a&gt; and &lt;a href=&quot;../running-external-programs/index#command-interpolation-1&quot;&gt;command interpolation&lt;/a&gt;. Expression interpolation allows convenient, readable programmatic construction of complex Julia expressions.</source>
          <target state="translated">표현식 보간 에 &lt;code&gt;$&lt;/code&gt; 를 사용하는 것은 의도적으로 &lt;a href=&quot;../strings/index#string-interpolation-1&quot;&gt;문자열 보간&lt;/a&gt; 과 &lt;a href=&quot;../running-external-programs/index#command-interpolation-1&quot;&gt;명령 보간을&lt;/a&gt; 연상시킵니다 . 식 보간법을 사용하면 복잡한 Julia 식을 편리하고 읽기 쉽게 프로그래밍 방식으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="414780375a6643e2453e6d8634fae95c5ade2420" translate="yes" xml:space="preserve">
          <source>The use of the &lt;a href=&quot;#return&quot;&gt;&lt;code&gt;return&lt;/code&gt;&lt;/a&gt; keyword is exactly the same as in other languages, but is often optional. A function without an explicit &lt;code&gt;return&lt;/code&gt; statement will return the last expression in the function body.</source>
          <target state="translated">&lt;a href=&quot;#return&quot;&gt; &lt;code&gt;return&lt;/code&gt; &lt;/a&gt; 키워드 의 사용은 다른 언어에서와 동일하지만 종종 선택 사항입니다. 명시적인 &lt;code&gt;return&lt;/code&gt; 문이 없는 함수 는 함수 본문의 마지막 표현식을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a2d597104e09bc0cd5d3b4e8b871fd483fedc685" translate="yes" xml:space="preserve">
          <source>The user id of the owner of the file</source>
          <target state="translated">파일 소유자의 사용자 ID</target>
        </trans-unit>
        <trans-unit id="6c6699f50d2afb2e82521e06f95a5e242ef5260f" translate="yes" xml:space="preserve">
          <source>The usual representation of a &lt;code&gt;quote&lt;/code&gt; form in an AST is an &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt; with head &lt;code&gt;:quote&lt;/code&gt;:</source>
          <target state="translated">AST에서 &lt;code&gt;quote&lt;/code&gt; 형태 의 일반적인 표현은 head &lt;code&gt;:quote&lt;/code&gt; 가있는 &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; &lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="35f0445ac7033162f95af7dffff6b9386fa1de30" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;a&lt;/code&gt; is used to construct the expression &lt;code&gt;ex&lt;/code&gt; which applies the &lt;code&gt;+&lt;/code&gt; function to the value 1 and the variable &lt;code&gt;b&lt;/code&gt;. Note the important distinction between the way &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are used:</source>
          <target state="translated">값 &lt;code&gt;a&lt;/code&gt; 발현하는 데 사용되는 구성 &lt;code&gt;ex&lt;/code&gt; 적용 &lt;code&gt;+&lt;/code&gt; 의 값 (1) 및 변수 함수 &lt;code&gt;b&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 사용되는 방식의 중요한 차이점에 유의하십시오 .</target>
        </trans-unit>
        <trans-unit id="62de8f816c4cc9e366c76d8b6179874f1c02891f" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;errno&lt;/code&gt; is only valid immediately after a &lt;code&gt;ccall&lt;/code&gt; to a C library routine that sets it. Specifically, you cannot call &lt;code&gt;errno&lt;/code&gt; at the next prompt in a REPL, because lots of code is executed between prompts.</source>
          <target state="translated">&lt;code&gt;errno&lt;/code&gt; 의 값은이를 설정 하는 C 라이브러리 루틴을 &lt;code&gt;ccall&lt;/code&gt; 한 직후에만 유효 합니다. 특히 프롬프트간에 많은 코드가 실행되므로 REPL의 다음 프롬프트에서 &lt;code&gt;errno&lt;/code&gt; 를 호출 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="aa580957fe65ae6ff4c7a945625a32e87a3c4957" translate="yes" xml:space="preserve">
          <source>The value of the &lt;em&gt;variable&lt;/em&gt;&lt;code&gt;a&lt;/code&gt; at expression construction time is used as an immediate value in the expression. Thus, the value of &lt;code&gt;a&lt;/code&gt; when the expression is evaluated no longer matters: the value in the expression is already &lt;code&gt;1&lt;/code&gt;, independent of whatever the value of &lt;code&gt;a&lt;/code&gt; might be.</source>
          <target state="translated">표현식 생성시 &lt;em&gt;변수 &lt;/em&gt; &lt;code&gt;a&lt;/code&gt; 의 값은 표현식에서 즉시 값으로 사용됩니다. 따라서,의 값 표현식이 평가됩니다 더 이상 중요하지 : 식의 값이 이미 &lt;code&gt;1&lt;/code&gt; 의 값이 무엇이든 관계없이 &lt;code&gt;a&lt;/code&gt; 될 수 있습니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9712274625a8ada140a13908f35f8b798b923a70" translate="yes" xml:space="preserve">
          <source>The value returned by a function is the value of the last expression evaluated, which, by default, is the last expression in the body of the function definition. In the example function, &lt;code&gt;f&lt;/code&gt;, from the previous section this is the value of the expression &lt;code&gt;x + y&lt;/code&gt;. As in C and most other imperative or functional languages, the &lt;code&gt;return&lt;/code&gt; keyword causes a function to return immediately, providing an expression whose value is returned:</source>
          <target state="translated">함수가 반환 한 값은 마지막으로 평가 된 식의 값이며 기본적으로 함수 정의 본문의 마지막 식입니다. 예제 함수 &lt;code&gt;f&lt;/code&gt; 에서 이전 섹션의 표현식 &lt;code&gt;x + y&lt;/code&gt; 의 값입니다 . C 및 대부분의 다른 명령형 또는 기능적 언어에서와 같이 &lt;code&gt;return&lt;/code&gt; 키워드는 함수가 즉시 반환하여 값이 반환되는 표현식을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c36bf156fd24214b4253de2ab2fb9c5aaef1f580" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; have the same type, yet their underlying representation of data in memory is very different. Even if you stored just numeric values in field &lt;code&gt;a&lt;/code&gt;, the fact that the memory representation of a &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt; differs from a &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; also means that the CPU needs to handle them using two different kinds of instructions. Since the required information is not available in the type, such decisions have to be made at run-time. This slows performance.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; 와 &lt;code&gt;c&lt;/code&gt; 의 값은 같은 유형을 가지지 만 메모리에서 데이터의 기본 표현은 매우 다릅니다. 필드 &lt;code&gt;a&lt;/code&gt; 에 숫자 값만 저장하더라도 &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt; 의 메모리 표현이 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; 와 다르다는 사실은 CPU가 두 가지 다른 종류의 명령어를 사용하여 처리해야한다는 것을 의미합니다. 필요한 정보는 유형에 따라 사용할 수 없으므로 런타임시 그러한 결정을 내려야합니다. 성능이 느려집니다.</target>
        </trans-unit>
        <trans-unit id="8485dbcd7c0bda629f4ab2a94790ee6bae11f052" translate="yes" xml:space="preserve">
          <source>The values returned by &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt;&lt;code&gt;typemin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt;&lt;code&gt;typemax&lt;/code&gt;&lt;/a&gt; are always of the given argument type. (The above expression uses several features that have yet to be introduced, including &lt;a href=&quot;../control-flow/index#man-loops-1&quot;&gt;for loops&lt;/a&gt;, &lt;a href=&quot;../strings/index#man-strings-1&quot;&gt;Strings&lt;/a&gt;, and &lt;a href=&quot;../metaprogramming/index#Interpolation-1&quot;&gt;Interpolation&lt;/a&gt;, but should be easy enough to understand for users with some existing programming experience.)</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt; &lt;code&gt;typemin&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt; &lt;code&gt;typemax&lt;/code&gt; 에&lt;/a&gt; 의해 반환되는 값 은 항상 주어진 인수 유형입니다. (위의 표현식은 &lt;a href=&quot;../control-flow/index#man-loops-1&quot;&gt;for loop&lt;/a&gt; , &lt;a href=&quot;../strings/index#man-strings-1&quot;&gt;Strings&lt;/a&gt; 및 &lt;a href=&quot;../metaprogramming/index#Interpolation-1&quot;&gt;Interpolation을&lt;/a&gt; 포함하여 아직 소개되지 않은 몇 가지 기능을 사용 하지만 기존 프로그래밍 경험이있는 사용자에게는 이해하기 쉬워야합니다.)</target>
        </trans-unit>
        <trans-unit id="10056f49c16766ab5a7d038814128061f1bc2774" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;relation&lt;/code&gt; is declared inside the &lt;code&gt;if&lt;/code&gt; block, but used outside. However, when depending on this behavior, make sure all possible code paths define a value for the variable. The following change to the above function results in a runtime error</source>
          <target state="translated">변수 &lt;code&gt;relation&lt;/code&gt; 는 &lt;code&gt;if&lt;/code&gt; 블록 안에서 선언 되지만 외부에서 사용됩니다. 그러나이 동작에 따라 가능한 모든 코드 경로가 변수의 값을 정의하는지 확인하십시오. 위의 기능을 다음과 같이 변경하면 런타임 오류가 발생합니다</target>
        </trans-unit>
        <trans-unit id="67a867d229f7011e541a374fedf8ebf1c9e53637" translate="yes" xml:space="preserve">
          <source>The variable bound defaults to &lt;a href=&quot;#Core.Any&quot;&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/a&gt; if it is omitted:</source>
          <target state="translated">바인드 된 변수 는 생략하면 기본값은 &lt;a href=&quot;#Core.Any&quot;&gt; &lt;code&gt;Any&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e448ca292ee1dbe02f872083148deaa835508c61" translate="yes" xml:space="preserve">
          <source>The variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are bound to the first two argument values as usual, and the variable &lt;code&gt;x&lt;/code&gt; is bound to an iterable collection of the zero or more values passed to &lt;code&gt;bar&lt;/code&gt; after its first two arguments:</source>
          <target state="translated">변수 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 는 평소와 같이 처음 두 인수 값 에 바인딩되고 변수 &lt;code&gt;x&lt;/code&gt; 는 첫 두 인수 이후 &lt;code&gt;bar&lt;/code&gt; 에 전달 된 0 개 이상의 값의 반복 가능한 컬렉션에 바인딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a9e1ff901c13ad87d154ae8aa5cd1e9d49a1456" translate="yes" xml:space="preserve">
          <source>The vast majority of functions will not take every kind of argument listed above; the numbers merely denote the precedence that should be used for any applicable arguments to a function.</source>
          <target state="translated">대부분의 기능이 위에 나열된 모든 종류의 논쟁을 취하지는 않습니다. 숫자는 단지 함수에 적용 가능한 모든 인수에 사용해야하는 우선 순위를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7e112d8ac7b6cbcda1facaf504ce365573c15593" translate="yes" xml:space="preserve">
          <source>The write barrier is also necessary for arrays of pointers when updating their data directly. For example:</source>
          <target state="translated">쓰기 장벽은 데이터를 직접 업데이트 할 때 포인터 배열에도 필요합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7df222412e61e0a840295167e1315d4946e8a4b5" translate="yes" xml:space="preserve">
          <source>The year of a &lt;code&gt;Date&lt;/code&gt; or &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">a의 해 &lt;code&gt;Date&lt;/code&gt; 또는 &lt;code&gt;DateTime&lt;/code&gt; AS를 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8d787e71667084faaf9bf03d9298e5d0d53aa7e6" translate="yes" xml:space="preserve">
          <source>Then if the environment variable &lt;code&gt;JULIA_BINDIR&lt;/code&gt; is set to &lt;code&gt;$JULIA_DIR/bin&lt;/code&gt;, the output &lt;code&gt;test&lt;/code&gt; program can be executed.</source>
          <target state="translated">그런 다음 환경 변수 &lt;code&gt;JULIA_BINDIR&lt;/code&gt; 이 &lt;code&gt;$JULIA_DIR/bin&lt;/code&gt; 으로 설정되면 출력 &lt;code&gt;test&lt;/code&gt; 프로그램을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d6412317563b7f3c5f3f315499f2ccbf4c0cedb" translate="yes" xml:space="preserve">
          <source>Then navigate to the directory containing your test file (here assumed to be &lt;code&gt;&quot;runtests.jl&quot;&lt;/code&gt;) and do the following:</source>
          <target state="translated">그런 다음 테스트 파일이 포함 된 디렉토리 (여기서는 &lt;code&gt;&quot;runtests.jl&quot;&lt;/code&gt; 라고 가정 )로 이동하여 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="37376ba231ea09d81df1a6ce675e26bfeb779597" translate="yes" xml:space="preserve">
          <source>Then the internal methods &lt;code&gt;_fA&lt;/code&gt; and &lt;code&gt;_fB&lt;/code&gt; can dispatch on &lt;code&gt;y&lt;/code&gt; without concern about ambiguities with each other with respect to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">그러면 내부 메소드 &lt;code&gt;_fA&lt;/code&gt; 및 &lt;code&gt;_fB&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 에 대한 모호성에 대해 염려하지 않고 &lt;code&gt;y&lt;/code&gt; 에 디스패치 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a87872d7de61942177513edb4dd2621b2f6b9fd" translate="yes" xml:space="preserve">
          <source>Then, replace the main() function in the project with this code:</source>
          <target state="translated">그런 다음 프로젝트의 main () 함수를 다음 코드로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="a59a7debbc5dd22ea37ee07cde6e2c750243ab3c" translate="yes" xml:space="preserve">
          <source>There Does Not Exist</source>
          <target state="translated">존재하지 않습니다</target>
        </trans-unit>
        <trans-unit id="174782af6882dfdbfbff70b32afe8068951f600e" translate="yes" xml:space="preserve">
          <source>There Exists</source>
          <target state="translated">존재</target>
        </trans-unit>
        <trans-unit id="f661b9bec6d9caa654535733d72b2847ffe7c84b" translate="yes" xml:space="preserve">
          <source>There also exists a macro &lt;a href=&quot;../../base/base/index#Base.@macroexpand&quot;&gt;&lt;code&gt;@macroexpand&lt;/code&gt;&lt;/a&gt; that is perhaps a bit more convenient than the &lt;code&gt;macroexpand&lt;/code&gt; function:</source>
          <target state="translated">또한 매크로가 존재 &lt;a href=&quot;../../base/base/index#Base.@macroexpand&quot;&gt; &lt;code&gt;@macroexpand&lt;/code&gt; &lt;/a&gt; 아마도 좀 더 편리보다 &lt;code&gt;macroexpand&lt;/code&gt; 기능 :</target>
        </trans-unit>
        <trans-unit id="3ed131b34b67efd7bcdc68ef678577fe7e39a368" translate="yes" xml:space="preserve">
          <source>There are a few more methods we can extend to give Julia more information about this iterable collection. We know that the elements in a &lt;code&gt;Squares&lt;/code&gt; sequence will always be &lt;code&gt;Int&lt;/code&gt;. By extending the &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt; method, we can give that information to Julia and help it make more specialized code in the more complicated methods. We also know the number of elements in our sequence, so we can extend &lt;a href=&quot;../../base/collections/index#Base.length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt;, too:</source>
          <target state="translated">Julia에게이 반복 가능한 컬렉션에 대한 추가 정보를 제공하기 위해 확장 할 수있는 몇 가지 방법이 더 있습니다. &lt;code&gt;Squares&lt;/code&gt; 시퀀스 의 요소 는 항상 &lt;code&gt;Int&lt;/code&gt; 입니다. &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt; 메소드 를 확장하여 해당 정보를 Julia에 제공하고보다 복잡한 메소드에서보다 전문화 된 코드를 작성할 수 있습니다. 시퀀스의 요소 수도 알고 있으므로 &lt;a href=&quot;../../base/collections/index#Base.length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt; 도 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e637cf035706fa4551de012038849a438d7502e7" translate="yes" xml:space="preserve">
          <source>There are a few noteworthy high-level features about Julia's strings:</source>
          <target state="translated">Julia의 문자열에 대한 몇 가지 주목할만한 고급 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f24a9d06c3582bc696ff9d33986f227daf0b74d" translate="yes" xml:space="preserve">
          <source>There are a number useful features unique to interactive work. In addition to showing the result, the REPL also binds the result to the variable &lt;code&gt;ans&lt;/code&gt;. A trailing semicolon on the line can be used as a flag to suppress showing the result.</source>
          <target state="translated">대화 형 작업에 고유 한 여러 유용한 기능이 있습니다. 결과를 표시하는 것 외에도 REPL은 결과를 변수 &lt;code&gt;ans&lt;/code&gt; 에 바인딩합니다 . 라인의 후미 세미콜론을 결과 표시를 억제하는 플래그로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd609a022f57cae38b5deceaa4789ea9e71b2150" translate="yes" xml:space="preserve">
          <source>There are also two variants with a &lt;code&gt;mime&lt;/code&gt; argument (a MIME type string, such as &lt;code&gt;&quot;image/png&quot;&lt;/code&gt;), which attempt to display &lt;code&gt;x&lt;/code&gt; using the requested MIME type &lt;em&gt;only&lt;/em&gt;, throwing a &lt;code&gt;MethodError&lt;/code&gt; if this type is not supported by either the display(s) or by &lt;code&gt;x&lt;/code&gt;. With these variants, one can also supply the &quot;raw&quot; data in the requested MIME type by passing &lt;code&gt;x::AbstractString&lt;/code&gt; (for MIME types with text-based storage, such as text/html or application/postscript) or &lt;code&gt;x::Vector{UInt8}&lt;/code&gt; (for binary MIME types).</source>
          <target state="translated">A의 두 가지 변종도있다 &lt;code&gt;mime&lt;/code&gt; (같은 MIME 타입 캐릭터, 인수 &lt;code&gt;&quot;image/png&quot;&lt;/code&gt; 디스플레이로 시도) &lt;code&gt;x&lt;/code&gt; (가) MIME 타입을 요청하여 &lt;em&gt;만&lt;/em&gt; , 던지는 &lt;code&gt;MethodError&lt;/code&gt; 를 이 유형 중 하나를 디스플레이에서 지원되지 않는 경우는 ( (S))에 의해 또는 &lt;code&gt;x&lt;/code&gt; . 이러한 변형을 사용하면 &lt;code&gt;x::AbstractString&lt;/code&gt; (text / html 또는 application / postscript와 같은 텍스트 기반 저장소가있는 MIME 유형의 경우) 또는 &lt;code&gt;x::Vector{UInt8}&lt;/code&gt; 를 전달하여 요청 된 MIME 유형의 &quot;원시&quot;데이터를 제공 할 수도 있습니다. UInt8} (이진 MIME 유형의 경우).</target>
        </trans-unit>
        <trans-unit id="da6a42179d7b850f29255071dd5215f3813868d7" translate="yes" xml:space="preserve">
          <source>There are currently four sorting algorithms available in base Julia:</source>
          <target state="translated">기본 Julia에는 현재 4 가지 정렬 알고리즘이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7b934f4e2dd58131955f021068fd71f3d77a05f" translate="yes" xml:space="preserve">
          <source>There are differences between &lt;code&gt;@macroexpand&lt;/code&gt; and &lt;a href=&quot;#Base.macroexpand&quot;&gt;&lt;code&gt;macroexpand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@macroexpand&lt;/code&gt; 와 macroexpand 사이에는 차이점이 &lt;a href=&quot;#Base.macroexpand&quot;&gt; &lt;code&gt;macroexpand&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="04c5ce881d71fd5eb88fb1f43a2852a100537a0d" translate="yes" xml:space="preserve">
          <source>There are four general kinds of cases where constructors differ from &lt;code&gt;convert&lt;/code&gt;:</source>
          <target state="translated">생성자가 &lt;code&gt;convert&lt;/code&gt; 와 다른 경우에는 네 가지 일반적인 종류가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="28b7763a452b0a0124e162d0088e4f9f3b24f691" translate="yes" xml:space="preserve">
          <source>There are many more interesting things that you can measure about your program, to get a comprehensive list please read the &lt;a href=&quot;http://www.brendangregg.com/perf.html&quot;&gt;Linux perf examples page&lt;/a&gt;.</source>
          <target state="translated">프로그램에 대해 측정 할 수있는 더 많은 흥미로운 것들이 있습니다. 전체 목록을 얻으려면 &lt;a href=&quot;http://www.brendangregg.com/perf.html&quot;&gt;Linux perf 예제 페이지&lt;/a&gt; 를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="e179a904cbafe3721438ffeb346220f23d78177e" translate="yes" xml:space="preserve">
          <source>There are of course a few exceptions. For example, in &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;, the type should always come first. In &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt;, the value comes before the indices so that the indices can be provided as varargs.</source>
          <target state="translated">물론 몇 가지 예외가 있습니다. 예를 들어 &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; 에서 형식이 항상 먼저옵니다. 에서 &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;, 값이 인덱스 앞에 와서 인덱스를 varargs로 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35f0957d73c0fe5b71dd1c5c8bdab57684e38edf" translate="yes" xml:space="preserve">
          <source>There are several different ways to think about this iterator wrapper:</source>
          <target state="translated">이 반복자 래퍼에 대해 여러 가지 다른 방법으로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbb07cbd34fbfc1d048df46439a5fa70e66eefad" translate="yes" xml:space="preserve">
          <source>There are several special types to be aware of, as no other type can be defined to behave the same:</source>
          <target state="translated">다른 유형은 동일하게 작동하도록 정의 할 수 없으므로 몇 가지 특수 유형을 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="89a2008a07be2d9f32034d88c362d6f0eb2082a1" translate="yes" xml:space="preserve">
          <source>There are situations when you want to construct a string or use string semantics, but the behavior of the standard string construct is not quite what is needed. For these kinds of situations, Julia provides &lt;a href=&quot;#non-standard-string-literals-1&quot;&gt;non-standard string literals&lt;/a&gt;. A non-standard string literal looks like a regular double-quoted string literal, but is immediately prefixed by an identifier, and doesn't behave quite like a normal string literal. Regular expressions, byte array literals and version number literals, as described below, are some examples of non-standard string literals. Other examples are given in the &lt;a href=&quot;../metaprogramming/index#Metaprogramming-1&quot;&gt;Metaprogramming&lt;/a&gt; section.</source>
          <target state="translated">문자열을 구성하거나 문자열 의미를 사용하려는 상황이 있지만 표준 문자열 구성의 동작이 필요한 것은 아닙니다. 이러한 상황에서 Julia는 &lt;a href=&quot;#non-standard-string-literals-1&quot;&gt;비표준 문자열 리터럴을&lt;/a&gt; 제공합니다 . 비표준 문자열 리터럴은 일반적인 큰 따옴표로 묶인 문자열 리터럴처럼 보이지만 식별자가 바로 앞에 붙어 일반 문자열 리터럴처럼 작동하지 않습니다. 아래에 설명 된 정규 표현식, 바이트 배열 리터럴 및 버전 번호 리터럴은 비표준 문자열 리터럴의 예입니다. 다른 예제는 &lt;a href=&quot;../metaprogramming/index#Metaprogramming-1&quot;&gt;메타 프로그래밍&lt;/a&gt; 섹션에 있습니다.</target>
        </trans-unit>
        <trans-unit id="89cbb0c73360645fdecca6950c82515a07e71685" translate="yes" xml:space="preserve">
          <source>There are situations where it may not make sense for type parameters to range freely over all possible types. In such situations, one can constrain the range of &lt;code&gt;T&lt;/code&gt; like so:</source>
          <target state="translated">유형 매개 변수가 가능한 모든 유형에 대해 자유롭게 범위를 설정하는 것이 적절하지 않은 상황이 있습니다. 이러한 상황에서 &lt;code&gt;T&lt;/code&gt; 의 범위를 다음 과 같이 제한 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7fd0dbd27001bbf0cf571035d6ca76de3cfc30cb" translate="yes" xml:space="preserve">
          <source>There are some functions to control the GC. In normal use cases, these should not be necessary.</source>
          <target state="translated">GC를 제어하는 ​​기능이 있습니다. 일반적인 사용 사례에서는 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f09765a26c89d3ba4efc525f188b8d20fe2e6806" translate="yes" xml:space="preserve">
          <source>There are some keys which allow automatically generated log data to be overridden:</source>
          <target state="translated">자동으로 생성 된 로그 데이터를 재정의 할 수있는 몇 가지 키가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a452182cf4d04b3b872134735654a28996e85391" translate="yes" xml:space="preserve">
          <source>There are three important standard modules:</source>
          <target state="translated">세 가지 중요한 표준 모듈이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7aeed63be2ceefd859fdddad806d6d15b8832022" translate="yes" xml:space="preserve">
          <source>There are three logger types provided by the library. &lt;a href=&quot;#Logging.ConsoleLogger&quot;&gt;&lt;code&gt;ConsoleLogger&lt;/code&gt;&lt;/a&gt; is the default logger you see when starting the REPL. It displays events in a readable text format and tries to give simple but user friendly control over formatting and filtering. &lt;a href=&quot;#Base.CoreLogging.NullLogger&quot;&gt;&lt;code&gt;NullLogger&lt;/code&gt;&lt;/a&gt; is a convenient way to drop all messages where necessary; it is the logging equivalent of the &lt;a href=&quot;../../base/base/index#Base.devnull&quot;&gt;&lt;code&gt;devnull&lt;/code&gt;&lt;/a&gt; stream. &lt;a href=&quot;#Base.CoreLogging.SimpleLogger&quot;&gt;&lt;code&gt;SimpleLogger&lt;/code&gt;&lt;/a&gt; is a very simplistic text formatting logger, mainly useful for debugging the logging system itself.</source>
          <target state="translated">라이브러리는 3 가지 로거 유형을 제공합니다. &lt;a href=&quot;#Logging.ConsoleLogger&quot;&gt; &lt;code&gt;ConsoleLogger&lt;/code&gt; &lt;/a&gt; 는 REPL을 시작할 때 표시되는 기본 로거입니다. 읽을 수있는 텍스트 형식으로 이벤트를 표시하고 형식화 및 필터링을 간단하지만 사용자에게 친숙하게 제어하려고합니다. &lt;a href=&quot;#Base.CoreLogging.NullLogger&quot;&gt; &lt;code&gt;NullLogger&lt;/code&gt; &lt;/a&gt; 는 필요한 경우 모든 메시지를 삭제하는 편리한 방법입니다. &lt;a href=&quot;../../base/base/index#Base.devnull&quot;&gt; &lt;code&gt;devnull&lt;/code&gt; &lt;/a&gt; 스트림에 해당하는 로깅 입니다. &lt;a href=&quot;#Base.CoreLogging.SimpleLogger&quot;&gt; &lt;code&gt;SimpleLogger&lt;/code&gt; &lt;/a&gt; 는 매우 간단한 텍스트 형식 로거로, 주로 로깅 시스템 자체를 디버깅하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="39bf1c403bd69afc5e26a9a958d5e1ff68b86fdd" translate="yes" xml:space="preserve">
          <source>There are three possible points of return from this function, returning the values of three different expressions, depending on the values of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. The &lt;code&gt;return&lt;/code&gt; on the last line could be omitted since it is the last expression.</source>
          <target state="translated">이 함수에는 세 가지 가능한 반환 지점이 있으며 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 값에 따라 세 가지 다른 표현식의 값을 반환합니다 . 마지막 행 의 &lt;code&gt;return&lt;/code&gt; 은 마지막 표현식이므로 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18fca925f2f77e2b65c8fdde85952641e1650d33" translate="yes" xml:space="preserve">
          <source>There are three specified standard floating-point values that do not correspond to any point on the real number line:</source>
          <target state="translated">실수 라인의 어떤 점에도 해당하지 않는 세 가지 지정된 표준 부동 소수점 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ce18266eafd4e5743ff642c71c4f327eae5b08a" translate="yes" xml:space="preserve">
          <source>There are two categories: generating values from a type (e.g. &lt;code&gt;rand(Int)&lt;/code&gt;), or from a collection (e.g. &lt;code&gt;rand(1:3)&lt;/code&gt;). The simple cases are explained first, and more advanced usage is presented later. We assume here that the choice of algorithm is independent of the RNG, so we use &lt;code&gt;AbstractRNG&lt;/code&gt; in our signatures.</source>
          <target state="translated">유형 (예 : &lt;code&gt;rand(Int)&lt;/code&gt; ) 또는 콜렉션 (예 : &lt;code&gt;rand(1:3)&lt;/code&gt; ) 에서 값을 생성하는 두 가지 범주가 있습니다 . 간단한 경우에 대해 먼저 설명하고 고급 사용법에 대해서는 나중에 설명합니다. 여기서 알고리즘의 선택은 RNG와 독립적이라고 가정하므로 서명에 &lt;code&gt;AbstractRNG&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="57f9b987aba6af24cda8e7334000e333dbb62bc6" translate="yes" xml:space="preserve">
          <source>There are two constructs for repeated evaluation of expressions: the &lt;code&gt;while&lt;/code&gt; loop and the &lt;code&gt;for&lt;/code&gt; loop. Here is an example of a &lt;code&gt;while&lt;/code&gt; loop:</source>
          <target state="translated">표현식의 반복 평가를위한 두 가지 구성이 있습니다 : &lt;code&gt;while&lt;/code&gt; 루프와 &lt;code&gt;for&lt;/code&gt; 루프. &lt;code&gt;while&lt;/code&gt; 루프 의 예는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="5da5a1ee059f0ac2e0add637de14f3676c7deb7b" translate="yes" xml:space="preserve">
          <source>There are two different packages named &lt;code&gt;Priv&lt;/code&gt; that the application uses. It uses a private package, which is a root dependency, and a public one, which is an indirect dependency through &lt;code&gt;Pub&lt;/code&gt;. These are differentiated by their distinct UUIDs, and they have different deps:</source>
          <target state="translated">응용 프로그램에서 사용하는 &lt;code&gt;Priv&lt;/code&gt; 라는 두 가지 패키지 가 있습니다. 루트 의존성 인 개인 패키지와 &lt;code&gt;Pub&lt;/code&gt; 을 통한 간접 의존성 인 공개 패키지를 사용합니다 . 이들은 고유 한 UUID로 구별되며 서로 다른 깊이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a80cf781eb3e259c907910355de5e57b87258bfc" translate="yes" xml:space="preserve">
          <source>There are two mostly orthogonal ways to extend &lt;code&gt;Random&lt;/code&gt; functionalities:</source>
          <target state="translated">&lt;code&gt;Random&lt;/code&gt; 기능 을 확장하는 데 주로 직교하는 두 가지 방법이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f15f1d9e0b0d6aa79c92366d6d55c444ac8dd9c4" translate="yes" xml:space="preserve">
          <source>There are various ways to run Julia code and provide options, similar to those available for the &lt;code&gt;perl&lt;/code&gt; and &lt;code&gt;ruby&lt;/code&gt; programs:</source>
          <target state="translated">Julia 코드를 실행하고 &lt;code&gt;perl&lt;/code&gt; 및 &lt;code&gt;ruby&lt;/code&gt; 프로그램 에서 사용 가능한 옵션과 유사한 옵션을 제공하는 다양한 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe7ec7d12394b96c015a1c2e093208538245f475" translate="yes" xml:space="preserve">
          <source>There exists no loop-carried memory dependencies</source>
          <target state="translated">루프 캐리 메모리 종속성이 없습니다</target>
        </trans-unit>
        <trans-unit id="dbe9d20052debba9991c8dfc120934a6e59ce3f0" translate="yes" xml:space="preserve">
          <source>There is a convenient syntax for naming such types, similar to the short form of function definition syntax:</source>
          <target state="translated">짧은 형식의 함수 정의 구문과 비슷한 이러한 유형의 이름 지정을위한 편리한 구문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3481a52901e12b38922b7141656dfae7e68cc28" translate="yes" xml:space="preserve">
          <source>There is a second syntactic form of quoting for multiple expressions: blocks of code enclosed in &lt;code&gt;quote ... end&lt;/code&gt;.</source>
          <target state="translated">여러 표현식에 대해 인용하는 두 번째 구문 형식이 있습니다 : &lt;code&gt;quote ... end&lt;/code&gt; 묶인 코드 블록 .</target>
        </trans-unit>
        <trans-unit id="89fb23b7683ecb8e95311e78406e7a19ca4a906a" translate="yes" xml:space="preserve">
          <source>There is a second, more terse syntax for defining a function in Julia. The traditional function declaration syntax demonstrated above is equivalent to the following compact &quot;assignment form&quot;:</source>
          <target state="translated">Julia에서 함수를 정의하기위한 두 번째 간결한 구문이 있습니다. 위에서 설명한 전통적인 함수 선언 구문은 다음과 같은 간단한 &quot;할당 형식&quot;과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b0f3efad279d61a3ae46bad7c874ec9a27487608" translate="yes" xml:space="preserve">
          <source>There is a special kind of abstract parametric type that must be mentioned here: singleton types. For each type, &lt;code&gt;T&lt;/code&gt;, the &quot;singleton type&quot; &lt;code&gt;Type{T}&lt;/code&gt; is an abstract type whose only instance is the object &lt;code&gt;T&lt;/code&gt;. Since the definition is a little difficult to parse, let's look at some examples:</source>
          <target state="translated">여기에는 언급해야 할 특수 유형의 추상 파라 메트릭 유형 인 싱글 톤 유형이 있습니다. 각 유형 &lt;code&gt;T&lt;/code&gt; 에 대해 &quot;단일 유형&quot; &lt;code&gt;Type{T}&lt;/code&gt; 는 인스턴스가 객체 &lt;code&gt;T&lt;/code&gt; 인 추상 유형입니다 . 정의를 구문 분석하기가 약간 어려우므로 몇 가지 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="4edd8c08b09effa574afae30fbef7845d91eb8b4" translate="yes" xml:space="preserve">
          <source>There is also a &lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt;&lt;code&gt;oneunit&lt;/code&gt;&lt;/a&gt; function, and a more general &lt;a href=&quot;../../base/base/index#Base.oftype&quot;&gt;&lt;code&gt;oftype(x, y)&lt;/code&gt;&lt;/a&gt; function, which returns &lt;code&gt;y&lt;/code&gt; converted to the type of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">거기에도 &lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt; &lt;code&gt;oneunit&lt;/code&gt; 의&lt;/a&gt; 보다 일반적인 함수, 및 &lt;a href=&quot;../../base/base/index#Base.oftype&quot;&gt; &lt;code&gt;oftype(x, y)&lt;/code&gt; &lt;/a&gt; 반환 기능, &lt;code&gt;y&lt;/code&gt; 의 형식으로 변환 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="734126eef49207ddeb0d4f566a4461c7a515e501" translate="yes" xml:space="preserve">
          <source>There is also a concise syntax for nested &lt;code&gt;where&lt;/code&gt; expressions. For example, this:</source>
          <target state="translated">중첩 된 &lt;code&gt;where&lt;/code&gt; 표현식에 대한 간결한 구문도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3485de030aea8df4c966053791640ea9fedf8c2e" translate="yes" xml:space="preserve">
          <source>There is also a method &lt;code&gt;crc32c(io, nb, crc)&lt;/code&gt; to checksum &lt;code&gt;nb&lt;/code&gt; bytes from a stream &lt;code&gt;io&lt;/code&gt;, or &lt;code&gt;crc32c(io, crc)&lt;/code&gt; to checksum all the remaining bytes. Hence you can do &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open(crc32c, filename)&lt;/code&gt;&lt;/a&gt; to checksum an entire file, or &lt;code&gt;crc32c(seekstart(buf))&lt;/code&gt; to checksum an &lt;a href=&quot;../../base/io-network/index#Base.IOBuffer&quot;&gt;&lt;code&gt;IOBuffer&lt;/code&gt;&lt;/a&gt; without calling &lt;code&gt;take!&lt;/code&gt;.</source>
          <target state="translated">스트림 &lt;code&gt;io&lt;/code&gt; 에서 &lt;code&gt;nb&lt;/code&gt; 바이트 를 체크섬 하는 &lt;code&gt;crc32c(io, nb, crc)&lt;/code&gt; 메소드 또는 나머지 모든 바이트를 체크섬하는 &lt;code&gt;crc32c(io, crc)&lt;/code&gt; 있습니다. 따라서 &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open(crc32c, filename)&lt;/code&gt; &lt;/a&gt; 을 사용하여 전체 파일을 체크섬하거나 &lt;code&gt;crc32c(seekstart(buf))&lt;/code&gt; 를 수행하여 &lt;a href=&quot;../../base/io-network/index#Base.IOBuffer&quot;&gt; &lt;code&gt;IOBuffer&lt;/code&gt; &lt;/a&gt; 를 호출하지 않고 IOBuffer 를 체크섬 할 &lt;code&gt;take!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5507a1ebe82bf577a426867e01303c626cf9abd7" translate="yes" xml:space="preserve">
          <source>There is much more to say about how instances of composite types are created, but that discussion depends on both &lt;a href=&quot;#Parametric-Types-1&quot;&gt;Parametric Types&lt;/a&gt; and on &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt;, and is sufficiently important to be addressed in its own section: &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Constructors&lt;/a&gt;.</source>
          <target state="translated">복합 유형의 인스턴스가 작성되는 방법에 대해 훨씬 더 많은 이야기가 있지만 그 논의는 &lt;a href=&quot;#Parametric-Types-1&quot;&gt;매개 변수 유형&lt;/a&gt; 과 &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;메소드&lt;/a&gt; 에 따라 다르며 자체 섹션 : &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;생성자&lt;/a&gt; 에서 해결하기에 충분히 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="0ae09c7d6ba8798034e4671d0b26e5b85ce05ddc" translate="yes" xml:space="preserve">
          <source>There is no division between object and non-object values: all values in Julia are true objects having a type that belongs to a single, fully connected type graph, all nodes of which are equally first-class as types.</source>
          <target state="translated">객체와 비 객체 값 사이에는 구분이 없습니다. Julia의 모든 값은 완전히 연결된 단일 유형 그래프에 속하는 유형을 가진 실제 객체이며 모든 노드는 유형과 동일하게 일류입니다.</target>
        </trans-unit>
        <trans-unit id="799561e1d3a80d4e278504aa2e10c84451ac9ffd" translate="yes" xml:space="preserve">
          <source>There is no invalid (NULL) &lt;code&gt;Ref&lt;/code&gt; in Julia, but a &lt;code&gt;C_NULL&lt;/code&gt; instance of &lt;code&gt;Ptr&lt;/code&gt; can be passed to a &lt;code&gt;ccall&lt;/code&gt; Ref argument.</source>
          <target state="translated">Julia 에는 유효하지 않은 (NULL) &lt;code&gt;Ref&lt;/code&gt; 가 없지만 &lt;code&gt;Ptr&lt;/code&gt; 의 &lt;code&gt;C_NULL&lt;/code&gt; 인스턴스를 &lt;code&gt;ccall&lt;/code&gt; Ref 인수에 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="11bffac25c301a4657b1c60789201ca8aff715a3" translate="yes" xml:space="preserve">
          <source>There is no meaningful concept of a &quot;compile-time type&quot;: the only type a value has is its actual type when the program is running. This is called a &quot;run-time type&quot; in object-oriented languages where the combination of static compilation with polymorphism makes this distinction significant.</source>
          <target state="translated">&quot;컴파일 타임 유형&quot;이라는 의미있는 개념은 없습니다. 프로그램이 실행될 때 값의 유일한 유형은 실제 유형입니다. 정적 컴파일과 다형성의 조합으로 인해 이러한 구별이 중요한 객체 지향 언어에서는이를 &quot;런타임 유형&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="e3d48c4d50de4372a5a2ecbc4a1b8db9674c176e" translate="yes" xml:space="preserve">
          <source>There is no more to the implementation of &lt;code&gt;Val&lt;/code&gt; than this. Some functions in Julia's standard library accept &lt;code&gt;Val&lt;/code&gt; instances as arguments, and you can also use it to write your own functions. For example:</source>
          <target state="translated">이것 보다 &lt;code&gt;Val&lt;/code&gt; 의 구현에는 더 이상 없습니다 . Julia 표준 라이브러리의 일부 함수는 &lt;code&gt;Val&lt;/code&gt; 인스턴스를 인수로 허용 하며이를 사용하여 고유 한 함수를 작성할 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="225dfa7c16e90d2f9982aa1b83dde6be688afb63" translate="yes" xml:space="preserve">
          <source>There is one additional special calling convention &lt;a href=&quot;../../base/c/index#Core.Intrinsics.llvmcall&quot;&gt;&lt;code&gt;llvmcall&lt;/code&gt;&lt;/a&gt;, which allows inserting calls to LLVM intrinsics directly. This can be especially useful when targeting unusual platforms such as GPGPUs. For example, for &lt;a href=&quot;http://llvm.org/docs/NVPTXUsage.html&quot;&gt;CUDA&lt;/a&gt;, we need to be able to read the thread index:</source>
          <target state="translated">LLVM 내장 함수에 직접 호출을 삽입 할 수있는 추가 특수 호출 규칙 인 &lt;a href=&quot;../../base/c/index#Core.Intrinsics.llvmcall&quot;&gt; &lt;code&gt;llvmcall&lt;/code&gt; 이&lt;/a&gt; 있습니다. GPGPU와 같은 비정상적인 플랫폼을 타겟팅 할 때 특히 유용합니다. 예를 들어, &lt;a href=&quot;http://llvm.org/docs/NVPTXUsage.html&quot;&gt;CUDA의&lt;/a&gt; 경우 스레드 인덱스를 읽을 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="982d9172cf71b589801a04a1718b7e1140ec78b8" translate="yes" xml:space="preserve">
          <source>There is only one difference, and on the surface (syntax-wise) it may seem very minor. The difference between &lt;code&gt;using&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt; is that with &lt;code&gt;using&lt;/code&gt; you need to say &lt;code&gt;function Foo.bar(..&lt;/code&gt; to extend module Foo's function bar with a new method, but with &lt;code&gt;import Foo.bar&lt;/code&gt;, you only need to say &lt;code&gt;function bar(...&lt;/code&gt; and it automatically extends module Foo's function bar.</source>
          <target state="translated">단 하나의 차이점이 있으며 표면적으로 (구문 적으로) 매우 사소하게 보일 수 있습니다. 차이 &lt;code&gt;using&lt;/code&gt; 및 &lt;code&gt;import&lt;/code&gt; 에 있다는 것입니다 &lt;code&gt;using&lt;/code&gt; 당신이 말할 필요가 &lt;code&gt;function Foo.bar(..&lt;/code&gt; 새로운 방법으로 모듈 푸의 기능 표시 줄을 확장 할 수 있지만, 함께 &lt;code&gt;import Foo.bar&lt;/code&gt; 만 말할 필요 &lt;code&gt;function bar(...&lt;/code&gt; 모듈 Foo의 기능 표시 줄을 자동으로 확장합니다.</target>
        </trans-unit>
        <trans-unit id="40b79a3c7d53b455d5a062d0c3faf4f4007912a3" translate="yes" xml:space="preserve">
          <source>There is some overlap between these rules since the behavior of &lt;code&gt;\x&lt;/code&gt; and octal escapes less than 0x80 (128) are covered by both of the first two rules, but here these rules agree. Together, these rules allow one to easily use ASCII characters, arbitrary byte values, and UTF-8 sequences to produce arrays of bytes. Here is an example using all three:</source>
          <target state="translated">&lt;code&gt;\x&lt;/code&gt; 의 동작 과 0x80 (128) 미만의 8 진 이스케이프는 처음 두 규칙 모두에 의해 다루어 지므로 이러한 규칙간에 약간의 겹침이 있지만 여기서는이 규칙에 동의합니다. 이러한 규칙을 통해 ASCII 문자, 임의의 바이트 값 및 UTF-8 시퀀스를 쉽게 사용하여 바이트 배열을 생성 할 수 있습니다. 다음은 세 가지를 모두 사용하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="5a8e36fc8e9774033114f307d267a46fecf4de03" translate="yes" xml:space="preserve">
          <source>There is yet another case that the actual &lt;code&gt;@assert&lt;/code&gt; macro handles: what if, in addition to printing &quot;a should equal b,&quot; we wanted to print their values? One might naively try to use string interpolation in the custom message, e.g., &lt;code&gt;@assert a==b &quot;a ($a) should equal b ($b)!&quot;&lt;/code&gt;, but this won't work as expected with the above macro. Can you see why? Recall from &lt;a href=&quot;../strings/index#string-interpolation-1&quot;&gt;string interpolation&lt;/a&gt; that an interpolated string is rewritten to a call to &lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt;. Compare:</source>
          <target state="translated">실제 &lt;code&gt;@assert&lt;/code&gt; 매크로가 처리 하는 또 다른 경우가 있습니다. &quot;a와 b가 같아야 함&quot;을 인쇄하는 것 외에도 값을 인쇄하려면 어떻게해야합니까? 하나는 순진, 예를 들어 사용자 지정 메시지에 사용 문자열 보간 시도 할 수 &lt;code&gt;@assert a==b &quot;a ($a) should equal b ($b)!&quot;&lt;/code&gt; 위의 매크로에서는 예상대로 작동하지 않습니다. 이유를 알 수 있습니까? 로부터 리콜 &lt;a href=&quot;../strings/index#string-interpolation-1&quot;&gt;문자열 내삽&lt;/a&gt; 보간 캐릭터 호출에 재기록되는 &lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt; . 비교:</target>
        </trans-unit>
        <trans-unit id="d3e7d0ac84e899740c4a2f0bb3ee4413427fcc34" translate="yes" xml:space="preserve">
          <source>There's also some key value pairs which have conventional meaning:</source>
          <target state="translated">일반적인 의미를 갖는 몇 가지 주요 값 쌍이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6f36ec125f2f895a5ef2bd1d15fb610bf42b808" translate="yes" xml:space="preserve">
          <source>Therefore</source>
          <target state="translated">Therefore</target>
        </trans-unit>
        <trans-unit id="2f243754615f97fed5cd732a70910cb99d584308" translate="yes" xml:space="preserve">
          <source>Therefore, if an &lt;code&gt;Array&lt;/code&gt; contains data in the wrong format, it will have to be explicitly converted using a call such as &lt;code&gt;trunc(Int32, a)&lt;/code&gt;.</source>
          <target state="translated">따라서 &lt;code&gt;Array&lt;/code&gt; 에 잘못된 형식의 데이터가 포함 된 경우 &lt;code&gt;trunc(Int32, a)&lt;/code&gt; 와 같은 호출을 사용하여 명시 적으로 변환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="db219bff6d21bdc3e30fad396993a55966a94d9d" translate="yes" xml:space="preserve">
          <source>These are all single-argument functions, with &lt;code&gt;atan&lt;/code&gt; also accepting two arguments corresponding to a traditional &lt;a href=&quot;https://en.wikipedia.org/wiki/Atan2&quot;&gt;&lt;code&gt;atan2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">이것들은 모두 단일 인수 함수이며 &lt;code&gt;atan&lt;/code&gt; 은 전통적인 &lt;a href=&quot;https://en.wikipedia.org/wiki/Atan2&quot;&gt; &lt;code&gt;atan2&lt;/code&gt; &lt;/a&gt; 함수에 해당하는 두 개의 인수를 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="14803da413b77436b3c2d4357e087f5e0536c055" translate="yes" xml:space="preserve">
          <source>These are some minor points that might help in tight inner loops.</source>
          <target state="translated">내부 루프가 빡빡 해지는 데 도움이되는 몇 가지 사소한 점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f489d10be7b6a63303842ebf419258e8b767140d" translate="yes" xml:space="preserve">
          <source>These are standard system mutexes for locking critical sections of logic.</source>
          <target state="translated">논리의 중요한 부분을 잠그기위한 표준 시스템 뮤텍스입니다.</target>
        </trans-unit>
        <trans-unit id="d1641abea44eab3cf0ec515a65636237d8dacb4d" translate="yes" xml:space="preserve">
          <source>These building blocks are used to create the regular synchronization objects.</source>
          <target state="translated">이 빌딩 블록은 일반 동기화 개체를 만드는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="565962f2637fab496a10fd1e88eadfa7fec7f65c" translate="yes" xml:space="preserve">
          <source>These can be intermixed to create &lt;strong&gt;a stacked environment&lt;/strong&gt;: an ordered set of project environments and package directories, overlaid to make a single composite environment. The precedence and visibility rules then combine to determine which packages are available and where they get loaded from. Julia's load path forms a stacked environment, for example.</source>
          <target state="translated">이들은 하나의 복합 환경을 만들기 위해 겹쳐진 일련의 프로젝트 환경 및 패키지 디렉토리 세트 인 &lt;strong&gt;스택 환경&lt;/strong&gt; 을 만들기 &lt;strong&gt;위해&lt;/strong&gt; 혼합 될 수 있습니다 . 그런 다음 우선 순위 및 가시성 규칙을 결합하여 사용 가능한 패키지와로드 위치를 결정합니다. 예를 들어 Julia의로드 경로는 스택 환경을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="ad9e158cfed42f0988f112a79734599400b1a65e" translate="yes" xml:space="preserve">
          <source>These environment each serve a different purpose:</source>
          <target state="translated">이러한 환경은 각각 다른 목적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="df0dd5f0a0b3669798f0ca8386e219bbefc17e9d" translate="yes" xml:space="preserve">
          <source>These environment variables only have an effect if Julia was compiled with garbage-collection debugging (that is, if &lt;code&gt;WITH_GC_DEBUG_ENV&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt; in the build configuration).</source>
          <target state="translated">이러한 환경 변수는 Julia가 가비지 수집 디버깅으로 컴파일 된 경우에만 적용됩니다 (즉 , 빌드 구성에서 &lt;code&gt;WITH_GC_DEBUG_ENV&lt;/code&gt; 가 &lt;code&gt;1&lt;/code&gt; 로 설정된 경우 ).</target>
        </trans-unit>
        <trans-unit id="de0986fe52ee36d8b5c27e28a863c7c354ad5a04" translate="yes" xml:space="preserve">
          <source>These examples are hopefully helpful to illustrate how generated functions work, both in the definition end and at the call site; however, &lt;em&gt;don't copy them&lt;/em&gt;, for the following reasons:</source>
          <target state="translated">이 예제는 정의 끝과 호출 사이트에서 생성 된 함수의 작동 방식을 설명하는 데 도움이 될 것입니다. 그러나 다음과 같은 이유로 &lt;em&gt;복사하지 마십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e22560ff89133b8a8d38ebe85a09966debefcae5" translate="yes" xml:space="preserve">
          <source>These functions are useful in &lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons-1&quot;&gt;Numeric Comparisons&lt;/a&gt; to avoid overhead from unnecessary &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;type conversion&lt;/a&gt;.</source>
          <target state="translated">이러한 함수는 불필요한 &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;유형 변환으로&lt;/a&gt; 인한 오버 헤드를 피하기 위해 &lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons-1&quot;&gt;숫자 비교&lt;/a&gt; 에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="901a72532a01b48c0a0b20d9a2bd0c5a053c7001" translate="yes" xml:space="preserve">
          <source>These method definitions say that in the absence of more specific rules for adding, subtracting, multiplying and dividing pairs of numeric values, promote the values to a common type and then try again. That's all there is to it: nowhere else does one ever need to worry about promotion to a common numeric type for arithmetic operations &amp;ndash; it just happens automatically. There are definitions of catch-all promotion methods for a number of other arithmetic and mathematical functions in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt;&lt;code&gt;promotion.jl&lt;/code&gt;&lt;/a&gt;, but beyond that, there are hardly any calls to &lt;code&gt;promote&lt;/code&gt; required in Julia Base. The most common usages of &lt;code&gt;promote&lt;/code&gt; occur in outer constructors methods, provided for convenience, to allow constructor calls with mixed types to delegate to an inner type with fields promoted to an appropriate common type. For example, recall that &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/rational.jl&quot;&gt;&lt;code&gt;rational.jl&lt;/code&gt;&lt;/a&gt; provides the following outer constructor method:</source>
          <target state="translated">이러한 방법 정의에 따르면 숫자 값 쌍을 더하고 빼고 곱하고 나누는 더 구체적인 규칙이 없으면 값을 공통 유형으로 승격 한 다음 다시 시도하십시오. 그게 전부입니다. 다른 곳에서는 산술 연산을 위해 일반적인 숫자 유형으로 승격하는 것에 대해 걱정할 필요가 없습니다. 자동으로 발생합니다. 다른 산술 및 수학 함수의 수에 대한 포괄 홍보 방법의 정의가 있습니다 &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt; &lt;code&gt;promotion.jl&lt;/code&gt; 는&lt;/a&gt; 하지만 그 이상, 어떤 통화 거의 없다 &lt;code&gt;promote&lt;/code&gt; 줄리아 자료에서 필수. &lt;code&gt;promote&lt;/code&gt; 의 가장 일반적인 사용법편의를 위해 제공된 외부 생성자 메소드에서 혼합 유형의 생성자 호출이 적절한 공통 유형으로 필드가 승격 된 내부 유형으로 위임 할 수 있도록합니다. 예를 들어 &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/rational.jl&quot;&gt; &lt;code&gt;rational.jl&lt;/code&gt; &lt;/a&gt; 은 다음과 같은 외부 생성자 메서드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="38c599bfc89604d7c3dd9692be93915fc155443a" translate="yes" xml:space="preserve">
          <source>These questions are answered by searching through the project environments listed in &lt;a href=&quot;../../base/constants/index#Base.LOAD_PATH&quot;&gt;&lt;code&gt;LOAD_PATH&lt;/code&gt;&lt;/a&gt; for project files (&lt;code&gt;Project.toml&lt;/code&gt; or &lt;code&gt;JuliaProject.toml&lt;/code&gt;), manifest files (&lt;code&gt;Manifest.toml&lt;/code&gt; or &lt;code&gt;JuliaManifest.toml&lt;/code&gt;), or folders of source files.</source>
          <target state="translated">이러한 질문은 &lt;a href=&quot;../../base/constants/index#Base.LOAD_PATH&quot;&gt; &lt;code&gt;LOAD_PATH&lt;/code&gt; &lt;/a&gt; 에 나열된 프로젝트 환경에서 프로젝트 파일 ( &lt;code&gt;Project.toml&lt;/code&gt; 또는 &lt;code&gt;JuliaProject.toml&lt;/code&gt; ), 매니페스트 파일 ( &lt;code&gt;Manifest.toml&lt;/code&gt; 또는 &lt;code&gt;JuliaManifest.toml&lt;/code&gt; ) 또는 소스 파일 폴더를 검색하여 답변 합니다.</target>
        </trans-unit>
        <trans-unit id="9e5166e13cc42aee4b6f34ab71374c703764b19f" translate="yes" xml:space="preserve">
          <source>These rules indicate that the combination of a &lt;code&gt;SparseVecStyle&lt;/code&gt; with 0- or 1-dimensional arrays yields another &lt;code&gt;SparseVecStyle&lt;/code&gt;, that its combination with a 2-dimensional array yields a &lt;code&gt;SparseMatStyle&lt;/code&gt;, and anything of higher dimensionality falls back to the dense arbitrary-dimensional framework. These rules allow broadcasting to keep the sparse representation for operations that result in one or two dimensional outputs, but produce an &lt;code&gt;Array&lt;/code&gt; for any other dimensionality.</source>
          <target state="translated">이 규칙은 0 차원 또는 1 차원 배열과 &lt;code&gt;SparseVecStyle&lt;/code&gt; 을 조합 하면 또 다른 &lt;code&gt;SparseVecStyle&lt;/code&gt; 이 생성 되고, 2 차원 배열과 결합하면 &lt;code&gt;SparseMatStyle&lt;/code&gt; 이 생성되고 차원이 높은 것은 밀도가 높은 임의의 차원 프레임 워크로 돌아갑니다. 이러한 규칙을 통해 브로드 캐스트는 1 차원 출력 또는 2 차원 출력을 생성하지만 다른 차원에 대해서는 &lt;code&gt;Array&lt;/code&gt; 을 생성하는 작업에 대해 희소 표현을 유지할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ff63dfa77616c617504be7f6834247f76c057dc5" translate="yes" xml:space="preserve">
          <source>These values are &lt;code&gt;2.0^-23&lt;/code&gt; and &lt;code&gt;2.0^-52&lt;/code&gt; as &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; values, respectively. The &lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt; function can also take a floating-point value as an argument, and gives the absolute difference between that value and the next representable floating point value. That is, &lt;code&gt;eps(x)&lt;/code&gt; yields a value of the same type as &lt;code&gt;x&lt;/code&gt; such that &lt;code&gt;x + eps(x)&lt;/code&gt; is the next representable floating-point value larger than &lt;code&gt;x&lt;/code&gt;:</source>
          <target state="translated">이 값은 각각 &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; 값 으로 &lt;code&gt;2.0^-23&lt;/code&gt; 및 &lt;code&gt;2.0^-52&lt;/code&gt; 입니다. &lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt; &lt;code&gt;eps&lt;/code&gt; &lt;/a&gt; 함수는 인수로 부동 소수점 값을, 그 값과 다음 표현할 부동 소수점 값 사이의 절대 차를 부여 할 수있다. 즉, &lt;code&gt;eps(x)&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 와 같은 유형의 값을 생성하여 &lt;code&gt;x + eps(x)&lt;/code&gt; 가 &lt;code&gt;x&lt;/code&gt; 보다 큰 다음으로 표현 가능한 부동 소수점 값이되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="f33ed7c0575b9d7d40952cddc046e39e47a4df14" translate="yes" xml:space="preserve">
          <source>They are explicitly declared.</source>
          <target state="translated">그들은 명시 적으로 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="9da6c9effd58ab0ae90e923f7a38a897dca353b9" translate="yes" xml:space="preserve">
          <source>They have explicitly declared supertypes.</source>
          <target state="translated">그들은 수퍼 타입을 명시 적으로 선언했다.</target>
        </trans-unit>
        <trans-unit id="6e52fab1fc6f56c83a090442135c118d8a782f83" translate="yes" xml:space="preserve">
          <source>They have names.</source>
          <target state="translated">그들은 이름이 있습니다.</target>
        </trans-unit>
        <trans-unit id="062847d8bdfc031c0804b383d54688583d1d3428" translate="yes" xml:space="preserve">
          <source>They may have parameters.</source>
          <target state="translated">매개 변수가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce535b7c90d1f3779f26e6dbf670c470fd87540b" translate="yes" xml:space="preserve">
          <source>Thin Space</source>
          <target state="translated">얇은 공간</target>
        </trans-unit>
        <trans-unit id="794b36899e8ad96433bb7cbe178ed7bf875ad605" translate="yes" xml:space="preserve">
          <source>This &quot;declaration&quot; behavior only occurs in specific contexts:</source>
          <target state="translated">이 &quot;선언&quot;동작은 특정 상황에서만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2d8272048e9f98c6a3a33f1987ea12ed1eecadb9" translate="yes" xml:space="preserve">
          <source>This adds the numbers first, then finds the square root of the result.</source>
          <target state="translated">먼저 숫자를 더한 다음 결과의 제곱근을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="7e48b7632d07fb8a10c769f17c80cd8b54e9e2ae" translate="yes" xml:space="preserve">
          <source>This allows &lt;code&gt;a&lt;/code&gt; to be of any type. This can often be useful, but it does have a downside: for objects of type &lt;code&gt;MyAmbiguousType&lt;/code&gt;, the compiler will not be able to generate high-performance code. The reason is that the compiler uses the types of objects, not their values, to determine how to build code. Unfortunately, very little can be inferred about an object of type &lt;code&gt;MyAmbiguousType&lt;/code&gt;:</source>
          <target state="translated">이를 통해 &lt;code&gt;a&lt;/code&gt; 는 모든 유형이 될 수 있습니다. 이것은 종종 유용하지만 단점이 있습니다. &lt;code&gt;MyAmbiguousType&lt;/code&gt; 유형의 객체의 경우 컴파일러가 고성능 코드를 생성 할 수 없습니다. 컴파일러가 코드를 작성하는 방법을 결정하기 위해 값이 아닌 객체 유형을 사용하기 때문입니다. 불행히도 &lt;code&gt;MyAmbiguousType&lt;/code&gt; 유형의 객체에 대해서는 거의 유추 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e2ab1e715cac0200b469eb5f929c0503f3de4aef" translate="yes" xml:space="preserve">
          <source>This allows a type assertion to be attached to any expression in-place.</source>
          <target state="translated">이를 통해 형식 어설 션을 모든 식에 적절하게 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f66025a332eaca14516e5e48d7273aad3164c30" translate="yes" xml:space="preserve">
          <source>This allows calls like the following to work:</source>
          <target state="translated">이를 통해 다음과 같은 호출이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c0d02575ed936e3b66af9d0af1e8728459d34bc3" translate="yes" xml:space="preserve">
          <source>This allows functions which operate on indices to work in combination with &lt;code&gt;skipmissing&lt;/code&gt;. This is notably the case for search and find functions, which return indices valid for the object returned by &lt;code&gt;skipmissing&lt;/code&gt; which are also the indices of the matching entries &lt;em&gt;in the parent array&lt;/em&gt;</source>
          <target state="translated">이것은 인덱스에서 작동하는 함수가 &lt;code&gt;skipmissing&lt;/code&gt; 과 함께 작동 하도록 합니다. 이것은 검색 및 찾기 기능의 경우에 해당하며, 이는 &lt;em&gt;부모 배열에서&lt;/em&gt; 일치하는 항목의 색인 인 &lt;code&gt;skipmissing&lt;/code&gt; 으로 리턴 된 오브젝트에 유효한 색인을 리턴 합니다 &lt;em&gt;.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="964d516d9978a231b3ac23253bbb246eab6f09f8" translate="yes" xml:space="preserve">
          <source>This approach works very well: the compiler can figure out that &lt;code&gt;A&lt;/code&gt; is an &lt;code&gt;Array{Float64,2}&lt;/code&gt; because it knows the type of the fill value (&lt;code&gt;5.0::Float64&lt;/code&gt;) and the dimensionality (&lt;code&gt;(3, 3)::NTuple{2,Int}&lt;/code&gt;). This implies that the compiler can generate very efficient code for any future usage of &lt;code&gt;A&lt;/code&gt; in the same function.</source>
          <target state="translated">이 접근 방식은 매우 효과적입니다. 컴파일러는 채우기 값의 유형 ( &lt;code&gt;5.0::Float64&lt;/code&gt; )과 차원 ( &lt;code&gt;(3, 3)::NTuple{2,Int}&lt;/code&gt; 알고 있기 때문에 &lt;code&gt;A&lt;/code&gt; 가 &lt;code&gt;Array{Float64,2}&lt;/code&gt; 임을 알 수 있습니다. , Int} ). 이는 컴파일러가 동일한 기능에서 &lt;code&gt;A&lt;/code&gt; 를 나중에 사용하기 위해 매우 효율적인 코드를 생성 할 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="65ab8a07106b1c3de72359a692edb4ea0bcec610" translate="yes" xml:space="preserve">
          <source>This argument will be evaluated at compile-time, when the containing method is defined.</source>
          <target state="translated">이 인수는 포함 메소드가 정의 될 때 컴파일 타임에 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="88e9b548070741ac9a8e34f0ecf3fa01c0587738" translate="yes" xml:space="preserve">
          <source>This avoids the need to continually check for &lt;code&gt;null&lt;/code&gt; values. However, not all object fields are references. Julia considers some types to be &quot;plain data&quot;, meaning all of their data is self-contained and does not reference other objects. The plain data types consist of primitive types (e.g. &lt;code&gt;Int&lt;/code&gt;) and immutable structs of other plain data types. The initial contents of a plain data type is undefined:</source>
          <target state="translated">이를 통해 지속적으로 &lt;code&gt;null&lt;/code&gt; 값을 확인할 필요가 없습니다 . 그러나 모든 오브젝트 필드가 참조는 아닙니다. Julia는 일부 유형을 &quot;일반 데이터&quot;로 간주합니다. 즉, 모든 데이터가 자체 포함되며 다른 객체를 참조하지 않습니다. 일반 데이터 형식은 기본 형식 (예 : &lt;code&gt;Int&lt;/code&gt; )과 다른 일반 데이터 형식의 변경 불가능한 구조체 로 구성됩니다 . 일반 데이터 유형의 초기 내용은 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a32fb96b8a45f2e62ae5fc588473c2b576e96e47" translate="yes" xml:space="preserve">
          <source>This behavior is an inconvenient consequence of the requirement for type-stability. In the case of &lt;code&gt;sqrt&lt;/code&gt;, most users want &lt;code&gt;sqrt(2.0)&lt;/code&gt; to give a real number, and would be unhappy if it produced the complex number &lt;code&gt;1.4142135623730951 + 0.0im&lt;/code&gt;. One could write the &lt;code&gt;sqrt&lt;/code&gt; function to switch to a complex-valued output only when passed a negative number (which is what &lt;code&gt;sqrt&lt;/code&gt; does in some other languages), but then the result would not be &lt;a href=&quot;#man-type-stability-1&quot;&gt;type-stable&lt;/a&gt; and the &lt;code&gt;sqrt&lt;/code&gt; function would have poor performance.</source>
          <target state="translated">이 동작은 형식 안정성 요구 사항으로 인해 불편한 결과입니다. &lt;code&gt;sqrt&lt;/code&gt; 의 경우 대부분의 사용자는 &lt;code&gt;sqrt(2.0)&lt;/code&gt; 이 실수를 제공하기를 원하며 복소수 &lt;code&gt;1.4142135623730951 + 0.0im&lt;/code&gt; 생성하면 불행합니다 . &lt;code&gt;sqrt&lt;/code&gt; 함수를 작성하여 음수 ( 일부 다른 언어에서 &lt;code&gt;sqrt&lt;/code&gt; 가하는 것)를 전달했을 때만 복잡한 값의 출력으로 전환 할 수 있지만 결과는 &lt;a href=&quot;#man-type-stability-1&quot;&gt;유형이 안정적이지&lt;/a&gt; 않으며 &lt;code&gt;sqrt&lt;/code&gt; 함수는 성능이 떨어집니다 .</target>
        </trans-unit>
        <trans-unit id="df974535f8d9fdf5af581b7209a9a7d77c94fbc7" translate="yes" xml:space="preserve">
          <source>This behavior is based on the observation that when one uses unsigned hex literals for integer values, one typically is using them to represent a fixed numeric byte sequence, rather than just an integer value.</source>
          <target state="translated">이 동작은 정수 값에 부호없는 16 진 리터럴을 사용할 때 일반적으로 정수 값이 아닌 고정 숫자 바이트 시퀀스를 나타내는 데 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e939e0293859dfba0c56cba20185fcd5c0865911" translate="yes" xml:space="preserve">
          <source>This behavior is frequently used in Julia to form an alternative to very short &lt;code&gt;if&lt;/code&gt; statements. Instead of &lt;code&gt;if &amp;lt;cond&amp;gt; &amp;lt;statement&amp;gt; end&lt;/code&gt;, one can write &lt;code&gt;&amp;lt;cond&amp;gt; &amp;amp;&amp;amp; &amp;lt;statement&amp;gt;&lt;/code&gt; (which could be read as: &amp;lt;cond&amp;gt; &lt;em&gt;and then&lt;/em&gt; &amp;lt;statement&amp;gt;). Similarly, instead of &lt;code&gt;if ! &amp;lt;cond&amp;gt; &amp;lt;statement&amp;gt; end&lt;/code&gt;, one can write &lt;code&gt;&amp;lt;cond&amp;gt; || &amp;lt;statement&amp;gt;&lt;/code&gt; (which could be read as: &amp;lt;cond&amp;gt; &lt;em&gt;or else&lt;/em&gt; &amp;lt;statement&amp;gt;).</source>
          <target state="translated">이 동작은 Julia에서 매우 짧은 &lt;code&gt;if&lt;/code&gt; 문에 대한 대안을 형성하기 위해 자주 사용됩니다 . 대신의 &lt;code&gt;if &amp;lt;cond&amp;gt; &amp;lt;statement&amp;gt; end&lt;/code&gt; , 하나는 쓸 수 &lt;code&gt;&amp;lt;cond&amp;gt; &amp;amp;&amp;amp; &amp;lt;statement&amp;gt;&lt;/code&gt; (로 읽을 수 : &amp;lt;콘드&amp;gt; &lt;em&gt;다음과&lt;/em&gt; &amp;lt;문&amp;gt;). 마찬가지로 &lt;code&gt;if ! &amp;lt;cond&amp;gt; &amp;lt;statement&amp;gt; end&lt;/code&gt; 대신 ! &amp;lt;cond&amp;gt; &amp;lt;statement&amp;gt; end , &lt;code&gt;&amp;lt;cond&amp;gt; || &amp;lt;statement&amp;gt;&lt;/code&gt; 쓸 수 있습니다. &amp;lt;statement&amp;gt; (&amp;lt;cond&amp;gt; &lt;em&gt;또는 다른&lt;/em&gt; &amp;lt;statement&amp;gt; 로 읽을 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="d466a277725d7aaf417bf4b4dabee60f49d4157d" translate="yes" xml:space="preserve">
          <source>This behavior may seem slightly odd for a normal variable, but allows for named functions &amp;ndash; which are just normal variables holding function objects &amp;ndash; to be used before they are defined. This allows functions to be defined in whatever order is intuitive and convenient, rather than forcing bottom up ordering or requiring forward declarations, as long as they are defined by the time they are actually called. As an example, here is an inefficient, mutually recursive way to test if positive integers are even or odd:</source>
          <target state="translated">이 동작은 일반 변수에서는 약간 이상하게 보일 수 있지만 함수 객체를 보유하는 일반 변수 인 명명 된 함수가 정의되기 전에 사용할 수 있습니다. 이를 통해 함수가 실제로 호출되는 시간에 의해 정의되는 한 상향식 순서를 지정하거나 순방향 선언을 요구하지 않고 직관적이고 편리한 순서로 함수를 정의 할 수 있습니다. 예를 들어, 양의 정수가 짝수인지 홀수인지 테스트하는 비효율적이고 상호 재귀적인 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e1626f887cd8eeaf56c26ebd7e57a24196949b2" translate="yes" xml:space="preserve">
          <source>This behavior of this function varies slightly across platforms. See &lt;a href=&quot;https://nodejs.org/api/fs.html#fs_caveats&quot;&gt;https://nodejs.org/api/fs.html#fs_caveats&lt;/a&gt; for more detailed information.</source>
          <target state="translated">이 기능의 동작은 플랫폼마다 약간 다릅니다. 자세한 내용은 &lt;a href=&quot;https://nodejs.org/api/fs.html#fs_caveats&quot;&gt;https://nodejs.org/api/fs.html#fs_caveats&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c6ca83ad215b371ad26283d27822e70d4564ed25" translate="yes" xml:space="preserve">
          <source>This call will appear to do nothing. However, it is possible to check whether an exception was thrown:</source>
          <target state="translated">이 전화는 아무것도하지 않는 것 같습니다. 그러나 예외가 발생했는지 여부를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3faddba8dc5ff630709111fd27507fc4b444f486" translate="yes" xml:space="preserve">
          <source>This can be expressed much more simply with &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;dot broadcasting&lt;/a&gt; and by combining it with a normal integer index (instead of extracting the first &lt;code&gt;page&lt;/code&gt; from &lt;code&gt;A&lt;/code&gt; as a separate step). It can even be combined with a &lt;code&gt;:&lt;/code&gt; to extract both diagonals from the two pages at the same time:</source>
          <target state="translated">이것은 &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;도트 브로드 캐스팅을 사용&lt;/a&gt; 하고 &lt;code&gt;A&lt;/code&gt; 에서 첫 번째 &lt;code&gt;page&lt;/code&gt; 를 별도의 단계로 추출하는 대신 일반 정수 인덱스와 결합하여 훨씬 간단하게 표현할 수 있습니다 . &lt;code&gt;:&lt;/code&gt; 와 결합 하여 두 페이지에서 두 대각선을 동시에 추출 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="547aafc7ff388590993edee0cc0798c17880cfea" translate="yes" xml:space="preserve">
          <source>This can be identical to the signature present in the Julia code (like &lt;code&gt;mean(x::AbstractArray)&lt;/code&gt;), or a simplified form. Optional arguments should be represented with their default values (i.e. &lt;code&gt;f(x, y=1)&lt;/code&gt;) when possible, following the actual Julia syntax. Optional arguments which do not have a default value should be put in brackets (i.e. &lt;code&gt;f(x[, y])&lt;/code&gt; and &lt;code&gt;f(x[, y[, z]])&lt;/code&gt;). An alternative solution is to use several lines: one without optional arguments, the other(s) with them. This solution can also be used to document several related methods of a given function. When a function accepts many keyword arguments, only include a &lt;code&gt;&amp;lt;keyword arguments&amp;gt;&lt;/code&gt; placeholder in the signature (i.e. &lt;code&gt;f(x; &amp;lt;keyword arguments&amp;gt;)&lt;/code&gt;), and give the complete list under an &lt;code&gt;# Arguments&lt;/code&gt; section (see point 4 below).</source>
          <target state="translated">이것은 Julia 코드에있는 서명과 같 거나 &lt;code&gt;mean(x::AbstractArray)&lt;/code&gt; ) 단순화 된 형식 일 수 있습니다. 선택적 인수는 가능한 경우 실제 Julia 구문에 따라 기본값 (예 : &lt;code&gt;f(x, y=1)&lt;/code&gt; )으로 표시해야합니다. 기본값이없는 선택적 인수는 대괄호로 묶어야합니다 (예 : &lt;code&gt;f(x[, y])&lt;/code&gt; 및 &lt;code&gt;f(x[, y[, z]])&lt;/code&gt; ). 다른 해결책은 여러 줄을 사용하는 것입니다. 하나는 선택적 인수가없고 다른 하나는 그들과 함께 사용합니다. 이 솔루션은 또한 주어진 기능의 여러 관련 방법을 문서화하는 데 사용될 수 있습니다. 함수가 많은 키워드 인수를 허용하는 경우 서명에 &lt;code&gt;&amp;lt;keyword arguments&amp;gt;&lt;/code&gt; 자리 표시 자만 포함하십시오 (예 : &lt;code&gt;f(x; &amp;lt;keyword arguments&amp;gt;)&lt;/code&gt; )를 입력하고 &lt;code&gt;# Arguments&lt;/code&gt; 섹션 아래에 전체 목록을 제공 하십시오 (아래 4 항 참조).</target>
        </trans-unit>
        <trans-unit id="48dae0d7f0cfc247d97cdffb950575c2c53131a7" translate="yes" xml:space="preserve">
          <source>This can be remedied by passing the result of &lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt;&lt;code&gt;catch_backtrace&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace&lt;/code&gt;&lt;/a&gt;. Instead of returning callstack information for the current context, &lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt;&lt;code&gt;catch_backtrace&lt;/code&gt;&lt;/a&gt; returns stack information for the context of the most recent exception:</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt; &lt;code&gt;catch_backtrace&lt;/code&gt; &lt;/a&gt; 의 결과 를 &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace&lt;/code&gt; &lt;/a&gt; 로 전달하면이 문제를 해결할 수 있습니다 . &lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt; &lt;code&gt;catch_backtrace&lt;/code&gt; &lt;/a&gt; 는 현재 컨텍스트에 대한 콜 스택 정보를 반환하는 대신 가장 최근 예외의 컨텍스트에 대한 스택 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f23915be66d58b3010247cc477edf10741516449" translate="yes" xml:space="preserve">
          <source>This can be written more concisely and efficiently as:</source>
          <target state="translated">다음과 같이보다 간결하고 효율적으로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da228c6572574c6e3edc7a497b323e67243e96a5" translate="yes" xml:space="preserve">
          <source>This can lead to race conditions if another process obtains the same file name and creates the file before you are able to. Using &lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;mktemp()&lt;/code&gt;&lt;/a&gt; is recommended instead.</source>
          <target state="translated">다른 프로세스가 동일한 파일 이름을 얻고 파일을 작성하기 전에 파일을 작성하는 경우 경쟁 조건이 발생할 수 있습니다. 대신 &lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;mktemp()&lt;/code&gt; &lt;/a&gt; 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="464b5fa1d6c0b5441a8fbbb213e02432dc783d43" translate="yes" xml:space="preserve">
          <source>This catch-all is less specific than any other possible method definition for a pair of parameter values, so it will only be called on pairs of arguments to which no other method definition applies.</source>
          <target state="translated">이 catch-all은 한 쌍의 매개 변수 값에 대해 가능한 다른 메소드 정의보다 덜 구체적이므로 다른 메소드 정의가 적용되지 않는 인수 쌍에서만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0d32190f9f82717ff7b036e591c82b7be9c20e35" translate="yes" xml:space="preserve">
          <source>This chapter covers the technical details of package loading. To install packages, use &lt;a href=&quot;../../stdlib/pkg/index#Pkg-1&quot;&gt;&lt;code&gt;Pkg&lt;/code&gt;&lt;/a&gt;, Julia's built-in package manager, to add packages to your active environment. To use packages already in your active environment, write &lt;code&gt;import X&lt;/code&gt; or &lt;code&gt;using X&lt;/code&gt;, as described in the &lt;a href=&quot;../modules/index#modules-1&quot;&gt;Modules documentation&lt;/a&gt;.</source>
          <target state="translated">이 장에서는 패키지 로딩에 대한 기술적 세부 사항을 다룹니다. 패키지를 설치하려면 Julia의 내장 패키지 관리자 인 &lt;a href=&quot;../../stdlib/pkg/index#Pkg-1&quot;&gt; &lt;code&gt;Pkg&lt;/code&gt; 를&lt;/a&gt; 사용 하여 활성 환경에 패키지를 추가하십시오. 활성 환경에서 이미 패키지를 사용하려면 &lt;a href=&quot;../modules/index#modules-1&quot;&gt;모듈 설명서에&lt;/a&gt; 설명 된대로 &lt;code&gt;import X&lt;/code&gt; 또는 &lt;code&gt;using X&lt;/code&gt; 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4ea11403bb989c686f5968328179e98cbaa9f269" translate="yes" xml:space="preserve">
          <source>This code will not initialize all of &lt;code&gt;a&lt;/code&gt;, since each process will have a separate copy of it. Parallel for loops like these must be avoided. Fortunately, &lt;a href=&quot;#man-shared-arrays-1&quot;&gt;Shared Arrays&lt;/a&gt; can be used to get around this limitation:</source>
          <target state="translated">이 코드는 모두 초기화되지 않습니다 &lt;code&gt;a&lt;/code&gt; 각 프로세스가 별도의 복사본이 때문에,. 이와 같은 병렬 for 루프는 피해야합니다. 다행히 &lt;a href=&quot;#man-shared-arrays-1&quot;&gt;공유 어레이&lt;/a&gt; 를 사용하여이 제한을 극복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d51d7a463700079744f5ff1d3af6ba57fc16feaf" translate="yes" xml:space="preserve">
          <source>This construct implements the pattern of assigning iterations to multiple processes, and combining them with a specified reduction (in this case &lt;code&gt;(+)&lt;/code&gt;). The result of each iteration is taken as the value of the last expression inside the loop. The whole parallel loop expression itself evaluates to the final answer.</source>
          <target state="translated">이 구문은 반복을 여러 프로세스에 할당하고 지정된 축소 (이 경우 &lt;code&gt;(+)&lt;/code&gt; ) 와 결합하는 패턴을 구현합니다 . 각 반복의 결과는 루프 내부의 마지막 표현식 값으로 사용됩니다. 전체 병렬 루프 표현식 자체가 최종 답변으로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="56c993971b23a28c699db5a6937a4a9bfd78df8b" translate="yes" xml:space="preserve">
          <source>This construction avoids the multiplication and addition operations.</source>
          <target state="translated">이 구성은 곱셈과 덧셈 연산을 피합니다.</target>
        </trans-unit>
        <trans-unit id="aa8d7cac7cb360d58676d491242e77dac0c56e52" translate="yes" xml:space="preserve">
          <source>This constructor will be invoked by the syntax &lt;code&gt;SummedArray(a)&lt;/code&gt;. The syntax &lt;code&gt;new{T,S}&lt;/code&gt; allows specifying parameters for the type to be constructed, i.e. this call will return a &lt;code&gt;SummedArray{T,S}&lt;/code&gt;. &lt;code&gt;new{T,S}&lt;/code&gt; can be used in any constructor definition, but for convenience the parameters to &lt;code&gt;new{}&lt;/code&gt; are automatically derived from the type being constructed when possible.</source>
          <target state="translated">이 생성자는 &lt;code&gt;SummedArray(a)&lt;/code&gt; 구문에 의해 호출됩니다 . 구문 &lt;code&gt;new{T,S}&lt;/code&gt; 사용하면 생성 할 형식에 대한 매개 변수를 지정할 수 있습니다. 즉,이 호출은 &lt;code&gt;SummedArray{T,S}&lt;/code&gt; 반환합니다 . &lt;code&gt;new{T,S}&lt;/code&gt; 는 모든 생성자 정의에서 사용될 수 있지만 편의상 &lt;code&gt;new{}&lt;/code&gt; 의 매개 변수 는 가능한 경우 생성되는 유형에서 자동으로 파생됩니다.</target>
        </trans-unit>
        <trans-unit id="b7a16492f267624e6cffa44c16d2f3cbbc8fdcef" translate="yes" xml:space="preserve">
          <source>This convenience function returns an iterator which filters out &lt;code&gt;missing&lt;/code&gt; values efficiently. It can therefore be used with any function which supports iterators</source>
          <target state="translated">이 편리한 함수는 결 &lt;code&gt;missing&lt;/code&gt; 효율적으로 걸러내는 반복자를 반환합니다 . 따라서 반복자를 지원하는 모든 기능과 함께 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="7839ec061c3b0d3cae9d3ceb52f6e6b0eb7552ce" translate="yes" xml:space="preserve">
          <source>This convention for ordering arrays is common in many languages like Fortran, Matlab, and R (to name a few). The alternative to column-major ordering is row-major ordering, which is the convention adopted by C and Python (&lt;code&gt;numpy&lt;/code&gt;) among other languages. Remembering the ordering of arrays can have significant performance effects when looping over arrays. A rule of thumb to keep in mind is that with column-major arrays, the first index changes most rapidly. Essentially this means that looping will be faster if the inner-most loop index is the first to appear in a slice expression.</source>
          <target state="translated">이 배열 주문 규칙은 Fortran, Matlab 및 R와 같은 많은 언어에서 일반적으로 사용됩니다. 열 주요 순서에 대한 대안은 다른 언어 중에서 C 및 Python ( &lt;code&gt;numpy&lt;/code&gt; )에서 채택한 규칙 인 행 주요 순서입니다 . 배열 순서를 기억하면 배열을 반복 할 때 성능에 큰 영향을 줄 수 있습니다. 명심해야 할 규칙은 열 주요 배열에서는 첫 번째 인덱스가 가장 빠르게 변경된다는 것입니다. 본질적으로 이것은 가장 안쪽의 루프 인덱스가 슬라이스 식에 처음 나타나는 경우 루프 속도가 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="7355c6564b5fcc9846f7acd500769583417df709" translate="yes" xml:space="preserve">
          <source>This creates a 25-by-30000 &lt;code&gt;BitArray&lt;/code&gt;, linked to the file associated with stream &lt;code&gt;io&lt;/code&gt;.</source>
          <target state="translated">이것은 스트림 &lt;code&gt;io&lt;/code&gt; 와 관련된 파일에 링크 된 &lt;code&gt;BitArray&lt;/code&gt; 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="94e825958b08717e7b2f87e178ba335682000732" translate="yes" xml:space="preserve">
          <source>This creates a function taking one argument &lt;code&gt;x&lt;/code&gt; and returning the value of the polynomial &lt;code&gt;x^2 + 2x - 1&lt;/code&gt; at that value. Notice that the result is a generic function, but with a compiler-generated name based on consecutive numbering.</source>
          <target state="translated">이것은 하나의 인수 &lt;code&gt;x&lt;/code&gt; 를 가지고 그 값에서 다항식 &lt;code&gt;x^2 + 2x - 1&lt;/code&gt; 의 값을 반환 하는 함수를 만듭니다 . 결과는 일반 함수이지만 연속 번호 매기기를 기반으로하는 컴파일러 생성 이름을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c16c73de1b45daf105f01df93653955f2810669b" translate="yes" xml:space="preserve">
          <source>This declaration defines a new parametric type, &lt;code&gt;Point{T}&lt;/code&gt;, holding two &quot;coordinates&quot; of type &lt;code&gt;T&lt;/code&gt;. What, one may ask, is &lt;code&gt;T&lt;/code&gt;? Well, that's precisely the point of parametric types: it can be any type at all (or a value of any bits type, actually, although here it's clearly used as a type). &lt;code&gt;Point{Float64}&lt;/code&gt; is a concrete type equivalent to the type defined by replacing &lt;code&gt;T&lt;/code&gt; in the definition of &lt;code&gt;Point&lt;/code&gt; with &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;. Thus, this single declaration actually declares an unlimited number of types: &lt;code&gt;Point{Float64}&lt;/code&gt;, &lt;code&gt;Point{AbstractString}&lt;/code&gt;, &lt;code&gt;Point{Int64}&lt;/code&gt;, etc. Each of these is now a usable concrete type:</source>
          <target state="translated">이 선언은 새로운 매개 변수 유형을 정의 &lt;code&gt;Point{T}&lt;/code&gt; 타입의 두 개의 &quot;좌표」개최, &lt;code&gt;T&lt;/code&gt; 를 . &lt;code&gt;T&lt;/code&gt; 는 무엇인가 ? 글쎄, 그것은 정확히 파라 메트릭 유형의 요점입니다. 그것은 모든 유형이 될 수 있습니다 (또는 실제로는 유형으로 명확하게 사용되지만 모든 비트 유형의 값이 될 수 있습니다). &lt;code&gt;Point{Float64}&lt;/code&gt; 는 &lt;code&gt;Point&lt;/code&gt; 정의에서 &lt;code&gt;T&lt;/code&gt; 를 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; 로 대체하여 정의 된 유형과 동일한 콘크리트 유형 입니다. 따라서이 단일 선언은 실제로 &lt;code&gt;Point{Float64}&lt;/code&gt; , &lt;code&gt;Point{AbstractString}&lt;/code&gt; , &lt;code&gt;Point{Int64}&lt;/code&gt; 등 무제한 유형을 선언합니다 . 이제 각각 사용할 수있는 구체적인 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b01b6974b06d7624ee6c363ea6ebb8266c1f09ca" translate="yes" xml:space="preserve">
          <source>This declaration has the same effect as the earlier definition of the &lt;code&gt;Foo&lt;/code&gt; type without an explicit inner constructor method. The following two types are equivalent &amp;ndash; one with a default constructor, the other with an explicit constructor:</source>
          <target state="translated">이 선언은 명시적인 내부 생성자 메서드가없는 &lt;code&gt;Foo&lt;/code&gt; 유형 의 이전 정의와 동일한 효과를 갖습니다 . 다음 두 유형은 동일합니다. 하나는 기본 생성자를 사용하고 다른 하나는 명시 적 생성자를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6cae1102db29e2ef980a4d7e4e7854fb0a34c8cd" translate="yes" xml:space="preserve">
          <source>This dependency graph represented as a dictionary, looks like this:</source>
          <target state="translated">이 종속성 그래프는 사전으로 표시되며 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b9aaf0a6f68d326c3813770015ef1479f59b61ec" translate="yes" xml:space="preserve">
          <source>This distinction determines which scalar indexing methods the type must define. &lt;code&gt;IndexLinear()&lt;/code&gt; arrays are simple: just define &lt;code&gt;getindex(A::ArrayType, i::Int)&lt;/code&gt;. When the array is subsequently indexed with a multidimensional set of indices, the fallback &lt;code&gt;getindex(A::AbstractArray, I...)()&lt;/code&gt; efficiently converts the indices into one linear index and then calls the above method. &lt;code&gt;IndexCartesian()&lt;/code&gt; arrays, on the other hand, require methods to be defined for each supported dimensionality with &lt;code&gt;ndims(A)&lt;/code&gt;&lt;code&gt;Int&lt;/code&gt; indices. For example, &lt;a href=&quot;../../stdlib/sparsearrays/index#SparseArrays.SparseMatrixCSC&quot;&gt;&lt;code&gt;SparseMatrixCSC&lt;/code&gt;&lt;/a&gt; from the &lt;code&gt;SparseArrays&lt;/code&gt; standard library module, only supports two dimensions, so it just defines &lt;code&gt;getindex(A::SparseMatrixCSC, i::Int, j::Int)&lt;/code&gt;. The same holds for &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 구별은 유형이 정의해야하는 스칼라 인덱싱 방법을 결정합니다. &lt;code&gt;IndexLinear()&lt;/code&gt; 배열은 간단합니다. &lt;code&gt;getindex(A::ArrayType, i::Int)&lt;/code&gt; . 이후 배열이 다차원 인덱스 집합으로 인덱싱되면 폴백 &lt;code&gt;getindex(A::AbstractArray, I...)()&lt;/code&gt; 은 인덱스를 하나의 선형 인덱스로 효율적으로 변환 한 다음 위의 메서드를 호출합니다. 반면, &lt;code&gt;IndexCartesian()&lt;/code&gt; 배열은 지원되는 각 차원에 대해 &lt;code&gt;ndims(A)&lt;/code&gt; &lt;code&gt;Int&lt;/code&gt; 인덱스를 사용하여 메소드를 정의해야합니다 . 예를 들어, &lt;a href=&quot;../../stdlib/sparsearrays/index#SparseArrays.SparseMatrixCSC&quot;&gt; &lt;code&gt;SparseMatrixCSC&lt;/code&gt; 는&lt;/a&gt; 로부터 &lt;code&gt;SparseArrays&lt;/code&gt; 표준 라이브러리 모듈 만 그렇게 정의 다만, 이차원 지원 &lt;code&gt;getindex(A::SparseMatrixCSC, i::Int, j::Int)&lt;/code&gt; . 동일은을 위해 보유 &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="341c5e7333e9b447849339d0853fcd7d14d2830b" translate="yes" xml:space="preserve">
          <source>This does not apply to &lt;code&gt;function&lt;/code&gt; or &lt;code&gt;struct&lt;/code&gt; declarations. However, anonymous functions bound to global variables are serialized as can be seen below.</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt; 또는 &lt;code&gt;struct&lt;/code&gt; 선언 에는 적용되지 않습니다 . 그러나 전역 변수에 바인딩 된 익명 함수는 아래와 같이 직렬화됩니다.</target>
        </trans-unit>
        <trans-unit id="86f9320eb728977a1d66ab43b8b74b16022a0160" translate="yes" xml:space="preserve">
          <source>This environment variable only has an effect if Julia was compiled with JIT profiling support, using either</source>
          <target state="translated">이 환경 변수는 Julia가 JIT 프로파일 링 지원으로 컴파일 된 경우에만 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="b8ecde1ad84c7fa04736dc884f170c7012ed70ab" translate="yes" xml:space="preserve">
          <source>This environment variable only has an effect if Julia was compiled with garbage-collection debugging (that is, if &lt;code&gt;WITH_GC_DEBUG_ENV&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt; in the build configuration).</source>
          <target state="translated">이 환경 변수는 Julia가 가비지 수집 디버깅으로 컴파일 된 경우에만 적용됩니다 (즉 , 빌드 구성에서 &lt;code&gt;WITH_GC_DEBUG_ENV&lt;/code&gt; 가 &lt;code&gt;1&lt;/code&gt; 로 설정된 경우 ).</target>
        </trans-unit>
        <trans-unit id="9da7aae5652d5d79a524e4cda3f0dfe80c0acd90" translate="yes" xml:space="preserve">
          <source>This error indicates that the conditional was of the wrong type: &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt; rather than the required &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 오류는 조건부 유형 이 필수 &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; 임을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="041d6d9502e571d35122b54e3f7555ea1dca4d3a" translate="yes" xml:space="preserve">
          <source>This escaping mechanism can be used to &quot;violate&quot; hygiene when necessary, in order to introduce or manipulate user variables. For example, the following macro sets &lt;code&gt;x&lt;/code&gt; to zero in the call environment:</source>
          <target state="translated">이 이스케이프 메커니즘은 사용자 변수를 도입하거나 조작하기 위해 필요한 경우 위생을 &quot;위반&quot;하는 데 사용될 수 있습니다. 예를 들어 다음 매크로는 호출 환경에서 &lt;code&gt;x&lt;/code&gt; 를 0으로 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="9c5c328c41b593f3c08a09090fb0468199894a7b" translate="yes" xml:space="preserve">
          <source>This example demonstrates a powerful and often-used parallel programming pattern. Many iterations run independently over several processes, and then their results are combined using some function. The combination process is called a &lt;em&gt;reduction&lt;/em&gt;, since it is generally tensor-rank-reducing: a vector of numbers is reduced to a single number, or a matrix is reduced to a single row or column, etc. In code, this typically looks like the pattern &lt;code&gt;x = f(x,v[i])&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is the accumulator, &lt;code&gt;f&lt;/code&gt; is the reduction function, and the &lt;code&gt;v[i]&lt;/code&gt; are the elements being reduced. It is desirable for &lt;code&gt;f&lt;/code&gt; to be associative, so that it does not matter what order the operations are performed in.</source>
          <target state="translated">이 예제는 강력하고 자주 사용되는 병렬 프로그래밍 패턴을 보여줍니다. 많은 반복이 여러 프로세스에 대해 독립적으로 실행 된 후 결과는 일부 기능을 사용하여 결합됩니다. 조합 프로세스는 일반적으로 텐서 랭크 &lt;em&gt;감소&lt;/em&gt; 이기 때문에 &lt;em&gt;축소&lt;/em&gt; 라고합니다 . 숫자 벡터는 단일 숫자로 감소하거나 행렬은 단일 행 또는 열로 감소합니다. 코드에서는 일반적으로 다음과 같습니다. 패턴 &lt;code&gt;x = f(x,v[i])&lt;/code&gt; (여기서 &lt;code&gt;x&lt;/code&gt; 는 누산기, &lt;code&gt;f&lt;/code&gt; 는 감소 함수, &lt;code&gt;v[i]&lt;/code&gt; 는 감소되는 요소 임) &lt;code&gt;f&lt;/code&gt; 가 연관되는 것이 바람직 하므로, 동작이 수행되는 순서가 중요하지 않다.</target>
        </trans-unit>
        <trans-unit id="6dfb71272e9303585708d721385dced1cec06a7d" translate="yes" xml:space="preserve">
          <source>This example first allocates an array of bytes, then calls the C library function &lt;code&gt;gethostname&lt;/code&gt; to fill the array in with the hostname, takes a pointer to the hostname buffer, and converts the pointer to a Julia string, assuming that it is a NUL-terminated C string. It is common for C libraries to use this pattern of requiring the caller to allocate memory to be passed to the callee and filled in. Allocation of memory from Julia like this is generally accomplished by creating an uninitialized array and passing a pointer to its data to the C function. This is why we don't use the &lt;code&gt;Cstring&lt;/code&gt; type here: as the array is uninitialized, it could contain NUL bytes. Converting to a &lt;code&gt;Cstring&lt;/code&gt; as part of the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; checks for contained NUL bytes and could therefore throw a conversion error.</source>
          <target state="translated">이 예제는 먼저 바이트 배열을 할당 한 다음 C 라이브러리 함수 &lt;code&gt;gethostname&lt;/code&gt; 을 호출하여 호스트 이름으로 배열을 채우고 호스트 이름 버퍼에 대한 포인터를 가져오고 포인터를 Julia 문자열로 변환합니다. C 문자열. C 라이브러리는 호출자가 수신자에게 전달되고 채워질 메모리를 할당하도록 요구하는 이러한 패턴을 사용하는 것이 일반적입니다. 이와 같은 Julia의 메모리 할당은 일반적으로 초기화되지 않은 배열을 작성하고 해당 데이터에 대한 포인터를 전달하여 수행됩니다. C 함수. 이것이 우리가 여기서 &lt;code&gt;Cstring&lt;/code&gt; 타입을 사용하지 않는 이유입니다 : 배열이 초기화되지 않았으므로 NUL 바이트를 포함 할 수 있습니다. A를 변환 &lt;code&gt;Cstring&lt;/code&gt; 의 일환으로 &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 포함 된 NUL 바이트를 확인하므로 변환 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c1ac1e55fd925a7d22f5a60b11f3b3c1b4549bc" translate="yes" xml:space="preserve">
          <source>This example generates many subnormal numbers because the values in &lt;code&gt;a&lt;/code&gt; become an exponentially decreasing curve, which slowly flattens out over time.</source>
          <target state="translated">의 값 때문에이 예에서는 많은 비정규 번호를 생성하고 &lt;code&gt;a&lt;/code&gt; 천천히 시간 위에 평평 기하 급수적 감소 곡선이된다.</target>
        </trans-unit>
        <trans-unit id="9daa7910681479c02c2c50ed435d4f90bf88e739" translate="yes" xml:space="preserve">
          <source>This example highlights the general principle that the adjacent representable floating-point numbers also have adjacent binary integer representations.</source>
          <target state="translated">이 예는 인접한 표현 가능한 부동 소수점 숫자에도 인접한 이진 정수 표현이 있다는 일반적인 원칙을 강조합니다.</target>
        </trans-unit>
        <trans-unit id="908e2e897728777e829b7f08db5b9e855ae0cc96" translate="yes" xml:space="preserve">
          <source>This example is similar to the previous one, except there are two stages of consumers, and the stages have different latency so they use a different number of parallel workers, to maintain saturated throughput.</source>
          <target state="translated">이 예제는 소비자의 두 단계가 있고 단계의 대기 시간이 다르기 때문에 처리량이 다른 병렬 작업자를 사용하여 포화 된 처리량을 유지한다는 점을 제외하면 이전 예제와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="547c626a1378ed0fe9150c862ad51213777da963" translate="yes" xml:space="preserve">
          <source>This example map includes three different kinds of package locations (the first and third are part of the default load path):</source>
          <target state="translated">이 예제 맵에는 세 가지 종류의 패키지 위치가 포함됩니다 (첫 번째와 세 번째는 기본로드 경로의 일부 임).</target>
        </trans-unit>
        <trans-unit id="1a00200535ab1c13ccef86e68b0800e8609303b1" translate="yes" xml:space="preserve">
          <source>This experimental interface supports Julia's multi-threading capabilities. Types and functions described here might (and likely will) change in the future.</source>
          <target state="translated">이 실험적인 인터페이스는 Julia의 멀티 스레딩 기능을 지원합니다. 여기에 설명 된 유형과 기능은 향후 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57cf6614fe11299d25cdfc84dad18699d2670d90" translate="yes" xml:space="preserve">
          <source>This expression constructs a name using &lt;code&gt;string&lt;/code&gt;, then substitutes this name into a new &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; expression, which is then evaluated. Keep in mind that &lt;code&gt;eval&lt;/code&gt; only operates at the top level, so within this expression local variables will not be available (unless their values are substituted with &lt;code&gt;$&lt;/code&gt;). For this reason, &lt;code&gt;eval&lt;/code&gt; is typically only used to form top-level definitions, for example when wrapping libraries that contain many similar functions. A similar example can be constructed for &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt;&lt;code&gt;@cfunction&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 표현식은 &lt;code&gt;string&lt;/code&gt; 을 사용하여 이름을 구성한 다음이 이름을 새로운 &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 표현식 으로 대체 한 다음 평가됩니다. 있음을 명심 &lt;code&gt;eval&lt;/code&gt; (자신의 값으로 치환하지 않는 지역 변수는 사용할 수 없습니다 때문에이 표현 내에 만 최고 수준에서 작동 &lt;code&gt;$&lt;/code&gt; ). 이러한 이유로 &lt;code&gt;eval&lt;/code&gt; 은 일반적으로 예를 들어 많은 유사한 함수가 포함 된 라이브러리를 줄 바꿈하는 경우 최상위 정의를 형성하는 데만 사용됩니다. &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt; &lt;code&gt;@cfunction&lt;/code&gt; 에&lt;/a&gt; 대해서도 비슷한 예를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="db9c10f7c39ed65401660ce94eeb87fdf0a1c09b" translate="yes" xml:space="preserve">
          <source>This expression invokes the &lt;code&gt;echo&lt;/code&gt; command with three words as arguments: &lt;code&gt;hello&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, and &lt;code&gt;sort&lt;/code&gt;. The result is that a single line is printed: &lt;code&gt;hello | sort&lt;/code&gt;. How, then, does one construct a pipeline? Instead of using &lt;code&gt;'|'&lt;/code&gt; inside of backticks, one uses &lt;code&gt;pipeline&lt;/code&gt;:</source>
          <target state="translated">이 표현식은 세 단어를 인수로 사용하여 &lt;code&gt;echo&lt;/code&gt; 명령을 호출합니다 . &lt;code&gt;hello&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; 및 &lt;code&gt;sort&lt;/code&gt; . 결과적으로 한 줄이 인쇄됩니다. &lt;code&gt;hello | sort&lt;/code&gt; 합니다. 그러면 어떻게 파이프 라인을 구성합니까? &lt;code&gt;'|'&lt;/code&gt; 를 사용하는 대신 백틱 내부에서 &lt;code&gt;pipeline&lt;/code&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="d8eb7a249785528e4f915a12603e4055a737c99e" translate="yes" xml:space="preserve">
          <source>This feature is experimental and could change or disappear in future versions of Julia. Incorrect use of the &lt;code&gt;@simd&lt;/code&gt; macro may cause unexpected results.</source>
          <target state="translated">이 기능은 실험용이며 이후 버전의 Julia에서는 변경되거나 사라질 수 있습니다. &lt;code&gt;@simd&lt;/code&gt; 매크로를 잘못 사용 하면 예기치 않은 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5a37ab2e3447a402ef6dae9693a9619588c5031" translate="yes" xml:space="preserve">
          <source>This feature is useful for avoiding performance &quot;gotchas&quot; that could occur if one of the assignments to a variable changed its type unexpectedly.</source>
          <target state="translated">이 기능은 변수에 대한 지정 중 하나가 유형을 예기치 않게 변경 한 경우 발생할 수있는 성능 &quot;gotchas&quot;를 피하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="783c0c8452e06904718657237123803cbb8eb1c2" translate="yes" xml:space="preserve">
          <source>This form is often found on method signatures.</source>
          <target state="translated">이 양식은 종종 메소드 서명에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc3b7f9edb1c8e585d8a1d71b69faf0b48006d70" translate="yes" xml:space="preserve">
          <source>This format should not to be confused with the older &lt;em&gt;WY&lt;/em&gt; representation &lt;a href=&quot;#footnote-Bischof1987&quot;&gt;[Bischof1987]&lt;/a&gt;.</source>
          <target state="translated">이 형식을 이전 &lt;em&gt;WY&lt;/em&gt; 표현 과 혼동해서는 안됩니다 &lt;a href=&quot;#footnote-Bischof1987&quot;&gt;[Bischof1987]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="590cd9bbe677a0c8ce068af3ae23d18c7dfa14a9" translate="yes" xml:space="preserve">
          <source>This function can be used to implement transactional semantics. Before the transaction, one records the value in &lt;code&gt;x&lt;/code&gt;. After the transaction, the new value is stored only if &lt;code&gt;x&lt;/code&gt; has not been modified in the mean time.</source>
          <target state="translated">이 함수는 트랜잭션 의미론을 구현하는 데 사용할 수 있습니다. 트랜잭션 전에 &lt;code&gt;x&lt;/code&gt; 에 값을 기록합니다 . 트랜잭션 후, &lt;code&gt;x&lt;/code&gt; 가 그 동안 수정되지 않은 경우에만 새 값이 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="65b3ba291cce49f270b3e77d3c5998270ae43f60" translate="yes" xml:space="preserve">
          <source>This function computes a floating point representation of the modulus after division by numerically exact &lt;code&gt;2&amp;pi;&lt;/code&gt;, and is therefore not exactly the same as &lt;code&gt;mod(x,2&amp;pi;)&lt;/code&gt;, which would compute the modulus of &lt;code&gt;x&lt;/code&gt; relative to division by the floating-point number &lt;code&gt;2&amp;pi;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 숫자로 정확한 &lt;code&gt;2&amp;pi;&lt;/code&gt; 로 나눈 후 모듈러스의 부동 소수점 표현을 계산 하므로 &lt;code&gt;mod(x,2&amp;pi;)&lt;/code&gt; 와 정확히 동일하지 않으므로 부동 소수점 숫자 &lt;code&gt;2&amp;pi;&lt;/code&gt; 로 나누는 것에 대한 &lt;code&gt;x&lt;/code&gt; 의 모듈러스를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="a69b876a715ff91aee9ac1dc1a1270f07d74d257" translate="yes" xml:space="preserve">
          <source>This function definition applies only to calls where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both values of type &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 함수 정의는 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 모두 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; 유형의 값인 호출에만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="307f9d2672dc49a684aa7fe31c18fec869c44c7b" translate="yes" xml:space="preserve">
          <source>This function is &quot;unsafe&quot;. Be careful to ensure that a Julia reference to &lt;code&gt;array&lt;/code&gt; exists as long as this pointer will be used. The &lt;a href=&quot;../base/index#Base.GC.@preserve&quot;&gt;&lt;code&gt;GC.@preserve&lt;/code&gt;&lt;/a&gt; macro should be used to protect the &lt;code&gt;array&lt;/code&gt; argument from garbage collection within a given block of code.</source>
          <target state="translated">이 기능은 &quot;안전하지 않습니다&quot;. 이 포인터가 사용되는 한 &lt;code&gt;array&lt;/code&gt; 대한 Julia 참조가 존재 하도록주의하십시오 . &lt;a href=&quot;../base/index#Base.GC.@preserve&quot;&gt; &lt;code&gt;GC.@preserve&lt;/code&gt; &lt;/a&gt; 매크로 보호하기 위해 사용되어야 &lt;code&gt;array&lt;/code&gt; 코드의 주어진 블록 내에 가비지 콜렉션 인수.</target>
        </trans-unit>
        <trans-unit id="1048e33a2e1de2e001c3991baed944e77c02b5fe" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;lazy&lt;/em&gt;; that is, it is guaranteed to return in $&amp;Theta;(1)$ time and use $&amp;Theta;(1)$ additional space, and &lt;code&gt;flt&lt;/code&gt; will not be called by an invocation of &lt;code&gt;filter&lt;/code&gt;. Calls to &lt;code&gt;flt&lt;/code&gt; will be made when iterating over the returned iterable object. These calls are not cached and repeated calls will be made when reiterating.</source>
          <target state="translated">이 함수는 &lt;em&gt;게으르다&lt;/em&gt; ; 즉, $ &amp;Theta; (1) $ 시간으로 리턴하고 $ &amp;Theta; (1) $ 추가 공간을 사용하도록 보장되며 &lt;code&gt;flt&lt;/code&gt; 는 &lt;code&gt;filter&lt;/code&gt; 호출로 호출되지 않습니다 . 리턴 된 반복 가능 오브젝트를 반복 할 때 &lt;code&gt;flt&lt;/code&gt; 가 호출됩니다 . 이 통화는 캐시되지 않으며 반복 할 때 반복 통화가 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="f3c598eb72103944814ddd5bff7557e538bb8759" translate="yes" xml:space="preserve">
          <source>This function is available as of Julia 1.2.</source>
          <target state="translated">이 기능은 Julia 1.2부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de757df5fb576721e27ff36bb95b8961e32a7fdd" translate="yes" xml:space="preserve">
          <source>This function is experimental in Julia 1.1 and will likely be renamed in a future release (see https://github.com/JuliaLang/julia/pull/29901).</source>
          <target state="translated">이 함수는 Julia 1.1에서 실험 중이며 향후 릴리스에서 이름이 변경 될 수 있습니다 (https://github.com/JuliaLang/julia/pull/29901 참조).</target>
        </trans-unit>
        <trans-unit id="40e1bbd78f8e3b5f7d1147a85e5728b547b5d88f" translate="yes" xml:space="preserve">
          <source>This function is labeled &quot;unsafe&quot; because it will crash if &lt;code&gt;p&lt;/code&gt; is not a valid memory address to data of the requested length.</source>
          <target state="translated">이 함수는 &lt;code&gt;p&lt;/code&gt; 가 요청 된 길이의 데이터에 대한 유효한 메모리 주소가 아닌 경우 충돌하기 때문에 &quot;안전하지 않음 &quot;으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="82038c376053156505a04a6c869bf7122237faf2" translate="yes" xml:space="preserve">
          <source>This function is labeled &quot;unsafe&quot; because it will crash if &lt;code&gt;pointer&lt;/code&gt; is not a valid memory address to data of the requested length.</source>
          <target state="translated">이 함수는 &lt;code&gt;pointer&lt;/code&gt; 가 요청 된 길이의 데이터에 대한 유효한 메모리 주소가 아닌 경우 충돌하기 때문에 &quot;안전하지 않음 &quot;으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="70c3d9d8620860cee722b6a9f452e249efef56c2" translate="yes" xml:space="preserve">
          <source>This function is part of the implementation of &lt;a href=&quot;#using&quot;&gt;&lt;code&gt;using&lt;/code&gt;&lt;/a&gt; / &lt;a href=&quot;#import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt;, if a module is not already defined in &lt;code&gt;Main&lt;/code&gt;. It can also be called directly to force reloading a module, regardless of whether it has been loaded before (for example, when interactively developing libraries).</source>
          <target state="translated">이 함수는 모듈이 &lt;code&gt;Main&lt;/code&gt; 에 아직 정의되지 않은 경우 / &lt;a href=&quot;#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#using&quot;&gt; &lt;code&gt;using&lt;/code&gt; &lt;/a&gt; / 구현 구현의 일부입니다 . 또한 이전에로드했는지 여부에 관계없이 (예 : 대화식으로 라이브러리를 개발할 때) 모듈을 강제로 다시로드하기 위해 직접 호출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f62aceafe3cafbddb8ce3acbb1dad94e7fdf1815" translate="yes" xml:space="preserve">
          <source>This function may not be called on immutable objects, since they do not have stable memory addresses.</source>
          <target state="translated">이 함수는 메모리 주소가 안정적이지 않기 때문에 변경 불가능한 객체에서는 호출되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8d8139504e5c695799999f525f1e4ce111d803d" translate="yes" xml:space="preserve">
          <source>This function raises an error under operating systems that do not support soft symbolic links, such as Windows XP.</source>
          <target state="translated">이 기능은 Windows XP와 같은 소프트 심볼릭 링크를 지원하지 않는 운영 체제에서 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="322c609b6865dc8c717685db96eea7836880f968" translate="yes" xml:space="preserve">
          <source>This function requires at least Julia 1.1.</source>
          <target state="translated">이 기능에는 Julia 1.1 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a78f5bdc6ba25c6757efa254c7a5dcb1069f02e2" translate="yes" xml:space="preserve">
          <source>This function requires at least Julia 1.1. In Julia 1.0 it is available from the standard library &lt;code&gt;InteractiveUtils&lt;/code&gt;.</source>
          <target state="translated">이 기능에는 Julia 1.1 이상이 필요합니다. Julia 1.0에서는 표준 라이브러리 &lt;code&gt;InteractiveUtils&lt;/code&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a8778ddbd4ece155922c919b7d3de7c16b4b6b0" translate="yes" xml:space="preserve">
          <source>This function requires at least Julia 1.2.</source>
          <target state="translated">이 기능에는 Julia 1.2 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f615a9f2e5154689d2348ca6e6e212e19365dd5e" translate="yes" xml:space="preserve">
          <source>This function will always return an &lt;code&gt;Int8&lt;/code&gt; regardless of the types of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. See &lt;a href=&quot;../types/index#Type-Declarations-1&quot;&gt;Type Declarations&lt;/a&gt; for more on return types.</source>
          <target state="translated">이 함수는 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 유형에 관계없이 항상 &lt;code&gt;Int8&lt;/code&gt; 을 반환합니다 . 반환 유형에 대한 자세한 내용은 &lt;a href=&quot;../types/index#Type-Declarations-1&quot;&gt;유형 선언&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="208d7b42f568795accbdf6593a0dabeec159feae" translate="yes" xml:space="preserve">
          <source>This functionality requires at least Julia 1.1.</source>
          <target state="translated">이 기능에는 Julia 1.1 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d55acd278bb097e8fd9b34b3f2891bb67508ba49" translate="yes" xml:space="preserve">
          <source>This functionality requires at least Julia 1.2.</source>
          <target state="translated">이 기능에는 Julia 1.2 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d794b3922c789d2d5bf428145d7b58218609a4d8" translate="yes" xml:space="preserve">
          <source>This gives an output similar to</source>
          <target state="translated">이것은 비슷한 출력을 제공합니다</target>
        </trans-unit>
        <trans-unit id="71d340087c42aeb6323d557dfd0b48fcc9885f45" translate="yes" xml:space="preserve">
          <source>This guide relies on the Pkg REPL to execute Pkg commands. For non-interactive use, we recommend the Pkg API. The Pkg API is fully documented in the &lt;a href=&quot;https://julialang.github.io/Pkg.jl/v1/api/&quot;&gt;API Reference&lt;/a&gt; section of the Pkg documentation.</source>
          <target state="translated">이 안내서는 Pkg REPL을 사용하여 Pkg 명령을 실행합니다. 비 대화식 사용의 경우 Pkg API를 권장합니다. Pkg API는 Pkg 문서의 &lt;a href=&quot;https://julialang.github.io/Pkg.jl/v1/api/&quot;&gt;API 참조&lt;/a&gt; 섹션에 완전히 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcc764f3d130244febc5241a24425d0f8955d7ca" translate="yes" xml:space="preserve">
          <source>This guide should help you get started with &lt;code&gt;Pkg&lt;/code&gt;. &lt;code&gt;Pkg&lt;/code&gt; has much more to offer in terms of powerful package management, read the full manual to learn more!</source>
          <target state="translated">이 안내서는 &lt;code&gt;Pkg&lt;/code&gt; 를 시작하는 데 도움이 됩니다. &lt;code&gt;Pkg&lt;/code&gt; 는 강력한 패키지 관리 측면에서 훨씬 더 많은 것을 제공합니다. 자세한 내용은 전체 설명서를 읽으십시오!</target>
        </trans-unit>
        <trans-unit id="2e07b6f624fccfda8f96076a48a7ed08e8beca2e" translate="yes" xml:space="preserve">
          <source>This has the exact same effect as the previous definition of &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">이것은 이전의 &lt;code&gt;foo&lt;/code&gt; 정의와 정확히 같은 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2a3774592faf08d584a328465b32aaef91dad38" translate="yes" xml:space="preserve">
          <source>This illustrates the default &quot;tree&quot; dump; an alternative is the &quot;flat&quot; dump, which accumulates counts independent of their nesting:</source>
          <target state="translated">기본 &quot;트리&quot;덤프를 보여줍니다. 대안은 &quot;플랫 (flat)&quot;덤프로, 중첩과 무관하게 카운트를 누적합니다.</target>
        </trans-unit>
        <trans-unit id="acc80a0f41503dcb1b7e460050ce274ae0e83048" translate="yes" xml:space="preserve">
          <source>This imports all the symbols from &lt;code&gt;Foo&lt;/code&gt;, but only inside the module &lt;code&gt;Bar&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; 에서 모든 심볼을 가져 오지만 모듈 &lt;code&gt;Bar&lt;/code&gt; 내부에서만 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="48c905f3e19a8500c9e8e89a5d6b2d48b63e3fd8" translate="yes" xml:space="preserve">
          <source>This interface provides a mechanism to launch and manage Julia workers on different cluster environments. There are two types of managers present in Base: &lt;code&gt;LocalManager&lt;/code&gt;, for launching additional workers on the same host, and &lt;code&gt;SSHManager&lt;/code&gt;, for launching on remote hosts via &lt;code&gt;ssh&lt;/code&gt;. TCP/IP sockets are used to connect and transport messages between processes. It is possible for Cluster Managers to provide a different transport.</source>
          <target state="translated">이 인터페이스는 다른 클러스터 환경에서 Julia 작업자를 시작하고 관리하는 메커니즘을 제공합니다. :이 관리자의 두 가지 유형의 자료에 존재하는 &lt;code&gt;LocalManager&lt;/code&gt; 동일한 호스트에 추가 근로자를 실행하기위한, 그리고 &lt;code&gt;SSHManager&lt;/code&gt; 를 통해 원격 호스트에서 실행하기위한, &lt;code&gt;ssh&lt;/code&gt; . TCP / IP 소켓은 프로세스간에 메시지를 연결하고 전송하는 데 사용됩니다. 클러스터 관리자가 다른 전송을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="deff481ef7abfd9c149d6a30d8b9bfb2fec2b9fb" translate="yes" xml:space="preserve">
          <source>This is a Julia wrapper around a pointer to a &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_signature&quot;&gt;&lt;code&gt;git_signature&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">이것은 &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_signature&quot;&gt; &lt;code&gt;git_signature&lt;/code&gt; &lt;/a&gt; 객체에 대한 포인터 주위의 Julia 래퍼 입니다.</target>
        </trans-unit>
        <trans-unit id="c422825d888738af38d09b58685510aefce5bd8f" translate="yes" xml:space="preserve">
          <source>This is a better choice than</source>
          <target state="translated">이것은보다 나은 선택입니다</target>
        </trans-unit>
        <trans-unit id="85e469ae13d4f052567eb5f96057c4c8c1633d8d" translate="yes" xml:space="preserve">
          <source>This is a classic example of a single producer feeding two concurrent consumers: one &lt;code&gt;perl&lt;/code&gt; process generates lines with the numbers 0 through 5 on them, while two parallel processes consume that output, one prefixing lines with the letter &quot;A&quot;, the other with the letter &quot;B&quot;. Which consumer gets the first line is non-deterministic, but once that race has been won, the lines are consumed alternately by one process and then the other. (Setting &lt;code&gt;$|=1&lt;/code&gt; in Perl causes each print statement to flush the &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; handle, which is necessary for this example to work. Otherwise all the output is buffered and printed to the pipe at once, to be read by just one consumer process.)</source>
          <target state="translated">이것은 두 명의 동시 소비자에게 먹이를주는 단일 생산자의 전형적인 예입니다. 하나의 &lt;code&gt;perl&lt;/code&gt; 프로세스는 0에서 5까지의 숫자를 가진 라인을 생성하는 반면, 두 개의 병렬 프로세스는 그 출력을 소비합니다. 문자 &quot;B&quot;. 첫 번째 라인을 얻는 소비자는 비 결정적이지만 일단 경쟁에서 이기면 한 프로세스에서 다른 라인으로 번갈아 소비됩니다. ( Perl에 &lt;code&gt;$|=1&lt;/code&gt; 을 설정 하면 각 print 문이 &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; 핸들 을 플러시하게 되는데,이 예제가 작동하는 데 필요합니다. 그렇지 않으면 모든 출력이 버퍼링되어 파이프에 인쇄되어 한 번의 소비자 프로세스 만 읽을 수 있습니다. )</target>
        </trans-unit>
        <trans-unit id="cf79f7f6027262a30f115ab7b0f785a426cd7073" translate="yes" xml:space="preserve">
          <source>This is a common pattern seen when converting from a larger class of types to the one specific argument type that is actually supported by the algorithm:</source>
          <target state="translated">이것은 더 큰 유형의 클래스에서 알고리즘이 실제로 지원하는 하나의 특정 인수 유형으로 변환 할 때 나타나는 일반적인 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="ab1f9c741287d248928e11803550091dd722085d" translate="yes" xml:space="preserve">
          <source>This is a somewhat contrived example since we could produce the same behavior more clearly by negating the condition and placing the &lt;code&gt;println&lt;/code&gt; call inside the &lt;code&gt;if&lt;/code&gt; block. In realistic usage there is more code to be evaluated after the &lt;code&gt;continue&lt;/code&gt;, and often there are multiple points from which one calls &lt;code&gt;continue&lt;/code&gt;.</source>
          <target state="translated">조건을 무시하고 &lt;code&gt;println&lt;/code&gt; 호출을 &lt;code&gt;if&lt;/code&gt; 블록 안에 배치하여 동일한 동작을보다 명확하게 생성 할 수 있기 때문에 이것은 다소 고안된 예 입니다. 실제 사용에서는 &lt;code&gt;continue&lt;/code&gt; 후 평가할 코드가 더 많으며 한 번의 호출이 &lt;code&gt;continue&lt;/code&gt; 여러 지점이있는 경우가 많습니다 .</target>
        </trans-unit>
        <trans-unit id="1c9ba627d76c7cc49aeb4d6fdbc49ae25f7076ce" translate="yes" xml:space="preserve">
          <source>This is a verbose version of the &lt;code&gt;@time&lt;/code&gt; macro. It first prints the same information as &lt;code&gt;@time&lt;/code&gt;, then any non-zero memory allocation counters, and then returns the value of the expression.</source>
          <target state="translated">이것은 &lt;code&gt;@time&lt;/code&gt; 매크로 의 자세한 버전입니다 . 먼저 &lt;code&gt;@time&lt;/code&gt; 과 동일한 정보를 인쇄 한 다음 0이 아닌 메모리 할당 카운터를 인쇄 한 다음 식의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3dde492bc6a0d4212d6f3ce351cddd4c3cc1560e" translate="yes" xml:space="preserve">
          <source>This is a very common pattern throughout Julia Base: a small set of required methods define an informal interface that enable many fancier behaviors. In some cases, types will want to additionally specialize those extra behaviors when they know a more efficient algorithm can be used in their specific case.</source>
          <target state="translated">이는 Julia Base 전체에서 매우 일반적인 패턴입니다. 작은 필수 메소드 세트는 많은 더 멋진 동작을 가능하게하는 비공식 인터페이스를 정의합니다. 어떤 경우에는 유형이 특정 경우에 더 효율적인 알고리즘을 사용할 수 있다는 것을 알고있을 때 이러한 추가 동작을 추가로 특수화하려고합니다.</target>
        </trans-unit>
        <trans-unit id="967704622307a1b435262f66f63c35ab2df37cdd" translate="yes" xml:space="preserve">
          <source>This is accomplished by the following definition:</source>
          <target state="translated">이것은 다음 정의에 의해 달성됩니다.</target>
        </trans-unit>
        <trans-unit id="a064a0d086a44fbda83912ae13c4a94a63595798" translate="yes" xml:space="preserve">
          <source>This is accomplished via the following code in &lt;code&gt;base/boot.jl&lt;/code&gt;:</source>
          <target state="translated">이것은 &lt;code&gt;base/boot.jl&lt;/code&gt; 의 다음 코드를 통해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="d3583c3fe581e3e08550a563e55b3f4e249fd47f" translate="yes" xml:space="preserve">
          <source>This is also true for remotecalls on the local node as seen in the following example:</source>
          <target state="translated">다음 예제와 같이 로컬 노드에서 원격 호출 할 때도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="fa42412894f46475c32ad0f5cf96db8417157008" translate="yes" xml:space="preserve">
          <source>This is better style because &lt;code&gt;foo&lt;/code&gt; does not really accept numbers of all types; it really needs &lt;code&gt;Int&lt;/code&gt; s.</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 는 실제로 모든 유형의 숫자를 허용하지 않기 때문에 더 나은 스타일입니다 . 실제로 &lt;code&gt;Int&lt;/code&gt; 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="ac355916b9abde70111dfabfe3ce99e5f07ae086" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;const Vector = Array{T,1} where T&lt;/code&gt;. Writing &lt;code&gt;Vector{Float64}&lt;/code&gt; is equivalent to writing &lt;code&gt;Array{Float64,1}&lt;/code&gt;, and the umbrella type &lt;code&gt;Vector&lt;/code&gt; has as instances all &lt;code&gt;Array&lt;/code&gt; objects where the second parameter &amp;ndash; the number of array dimensions &amp;ndash; is 1, regardless of what the element type is. In languages where parametric types must always be specified in full, this is not especially helpful, but in Julia, this allows one to write just &lt;code&gt;Vector&lt;/code&gt; for the abstract type including all one-dimensional dense arrays of any element type.</source>
          <target state="translated">이 동등 &lt;code&gt;const Vector = Array{T,1} where T&lt;/code&gt; . 쓰기 &lt;code&gt;Vector{Float64}&lt;/code&gt; 기록에 해당 &lt;code&gt;Array{Float64,1}&lt;/code&gt; , 그리고 우산 형 &lt;code&gt;Vector&lt;/code&gt; 갖는다는 인스턴스 모든 &lt;code&gt;Array&lt;/code&gt; 두번째 파라미터 값 객체 - 배열의 차원의 수 - 무관 요소 유형이 무엇인지, 1이다. 파라 메트릭 유형을 항상 완전하게 지정해야하는 언어에서는 특히 도움이되지 않지만 Julia에서는 요소 유형의 모든 1 차원 밀도 배열을 포함하여 추상 유형에 대해 &lt;code&gt;Vector&lt;/code&gt; 만 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aaca4a13507268ab605b72c529b012ba239f5cf8" translate="yes" xml:space="preserve">
          <source>This is equivalent to the uglier test &lt;code&gt;@test &amp;asymp;(&amp;pi;, 3.14, atol=0.01)&lt;/code&gt;. It is an error to supply more than one expression unless the first is a call expression and the rest are assignments (&lt;code&gt;k=v&lt;/code&gt;).</source>
          <target state="translated">이것은 &lt;code&gt;@test &amp;asymp;(&amp;pi;, 3.14, atol=0.01)&lt;/code&gt; test @test &amp;asymp; (&amp;pi;, 3.14, atol = 0.01)과 같습니다 . 첫 번째가 호출 표현식이고 나머지가 할당 ( &lt;code&gt;k=v&lt;/code&gt; ) 이 아닌 한 둘 이상의 표현식을 제공하면 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="075cde66f62e612ace972fa5c52ba3c9977edd64" translate="yes" xml:space="preserve">
          <source>This is fine if a named function effecting the transform already exists to pass as the first argument to &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;. Often, however, a ready-to-use, named function does not exist. In these situations, the anonymous function construct allows easy creation of a single-use function object without needing a name:</source>
          <target state="translated">변환에 영향을주는 명명 된 함수가 이미 &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; 에&lt;/a&gt; 대한 첫 번째 인수로 전달하기 위해 존재하는 경우에 좋습니다. 그러나, 즉시 사용 가능한 이름 지정된 기능이 존재하지 않는 경우가 종종 있습니다. 이러한 상황에서 익명 함수 구문을 사용하면 이름 없이도 일회용 함수 객체를 쉽게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2c04622602343797c4542bea9af2f8f42f131f2" translate="yes" xml:space="preserve">
          <source>This is happening because, while the &lt;code&gt;write&lt;/code&gt; call is synchronous, the writing of each argument yields to other tasks while waiting for that part of the I/O to complete.</source>
          <target state="translated">&lt;code&gt;write&lt;/code&gt; 호출이 동기식 인 동안 각 인수를 쓰면 I / O의 해당 부분이 완료되기를 기다리는 동안 다른 작업을 수행 하기 때문에 이런 일이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="c8a50eb2bf3cc3094e347236252e67c0ff90ae38" translate="yes" xml:space="preserve">
          <source>This is intended to be called using &lt;code&gt;do&lt;/code&gt; block syntax</source>
          <target state="translated">이것은 &lt;code&gt;do&lt;/code&gt; 블록 구문을 사용하여 호출하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="9cdfa85f9233b8624988cb8413bc1b9a6dc03d9c" translate="yes" xml:space="preserve">
          <source>This is intended to be called using &lt;code&gt;do&lt;/code&gt; block syntax:</source>
          <target state="translated">이것은 &lt;code&gt;do&lt;/code&gt; 블록 구문을 사용하여 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="dd320fe267c845b089f3801cdc399b59ed6ba172" translate="yes" xml:space="preserve">
          <source>This is likely a very expensive operation. Given that all other atomic operations in Julia already have acquire/release semantics, explicit fences should not be necessary in most cases.</source>
          <target state="translated">이것은 매우 비싼 작업 일 수 있습니다. Julia의 다른 모든 원자 연산에는 이미 시맨틱 획득 / 릴리스가 있기 때문에 대부분의 경우 명시적인 펜스가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4c368eefb6926a50691e6a9f9ec7714b2c918956" translate="yes" xml:space="preserve">
          <source>This is more readable and convenient and equivalent to the above string concatenation &amp;ndash; the system rewrites this apparent single string literal into the call &lt;code&gt;string(greet, &quot;, &quot;, whom, &quot;.\n&quot;)&lt;/code&gt;.</source>
          <target state="translated">이것은보다 읽기 쉽고 편리하며 위의 문자열 연결과 동일합니다. 시스템은이 명백한 단일 문자열 리터럴을 호출 &lt;code&gt;string(greet, &quot;, &quot;, whom, &quot;.\n&quot;)&lt;/code&gt; 다시 씁니다 .</target>
        </trans-unit>
        <trans-unit id="f04a7b3a9c6223bad051fa21f901be067148fe9d" translate="yes" xml:space="preserve">
          <source>This is not needed on worker threads (&lt;code&gt;Threads.threadid() != 1&lt;/code&gt;) since the &lt;code&gt;InterruptException&lt;/code&gt; will only be delivered to the master thread. External functions that do not call julia code or julia runtime automatically disable sigint during their execution.</source>
          <target state="translated">&lt;code&gt;InterruptException&lt;/code&gt; 은 마스터 스레드에만 전달 되므로 작업자 스레드 ( &lt;code&gt;Threads.threadid() != 1&lt;/code&gt; ) 에는 필요하지 않습니다 . julia 코드 또는 julia 런타임을 호출하지 않는 외부 함수는 실행 중에 sigint를 자동으로 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="71e546fccd494df52bebb481be657d852aebe11b" translate="yes" xml:space="preserve">
          <source>This is often the right strategy; however, there are circumstances where following this advice blindly can be counterproductive. In particular, the more methods a generic function has, the more possibilities there are for ambiguities. When your method hierarchies get more complicated than this simple example, it can be worth your while to think carefully about alternative strategies.</source>
          <target state="translated">이것은 종종 올바른 전략입니다. 그러나이 조언을 맹목적으로 따르는 것이 비생산적 일 수있는 상황이 있습니다. 특히, 일반 함수의 메소드가 많을수록 모호성에 대한 가능성이 커집니다. 메소드 계층이이 간단한 예제보다 복잡해지면 대체 전략에 대해 신중하게 생각하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e2fa8331115c72567b8859c8f4636de4982ac69c" translate="yes" xml:space="preserve">
          <source>This is only needed if your module depends on a file that is not used via &lt;a href=&quot;#Base.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;. It has no effect outside of compilation.</source>
          <target state="translated">모듈이 &lt;a href=&quot;#Base.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; &lt;/a&gt; 를 통해 사용되지 않는 파일에 의존하는 경우에만 필요합니다 . 컴파일 외부에서는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2784b134096220702383ae6c9d7a1302554b1771" translate="yes" xml:space="preserve">
          <source>This is the default comparison used by &lt;a href=&quot;../sort/index#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;../sort/index#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; 에&lt;/a&gt; 의해 사용되는 기본 비교 입니다.</target>
        </trans-unit>
        <trans-unit id="c85ba23a6506d2939aa5b839a013bcd606af833c" translate="yes" xml:space="preserve">
          <source>This is the list of reserved keywords in Julia: &lt;code&gt;baremodule&lt;/code&gt;, &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt;, &lt;code&gt;do&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, &lt;code&gt;elseif&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, &lt;code&gt;export&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;finally&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt;, &lt;code&gt;global&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;import&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;local&lt;/code&gt;, &lt;code&gt;macro&lt;/code&gt;, &lt;code&gt;module&lt;/code&gt;, &lt;code&gt;quote&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;using&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;. Those keywords are not allowed to be used as variable names.</source>
          <target state="translated">다음은 Julia에서 예약 된 키워드 목록입니다 : &lt;code&gt;baremodule&lt;/code&gt; , &lt;code&gt;begin&lt;/code&gt; , &lt;code&gt;break&lt;/code&gt; , &lt;code&gt;catch&lt;/code&gt; , &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;continue&lt;/code&gt; , &lt;code&gt;do&lt;/code&gt; , &lt;code&gt;else&lt;/code&gt; , &lt;code&gt;elseif&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; , &lt;code&gt;export&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;finally&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;function&lt;/code&gt; , &lt;code&gt;global&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;import&lt;/code&gt; , &lt;code&gt;let&lt;/code&gt; , &lt;code&gt;local&lt;/code&gt; , &lt;code&gt;macro&lt;/code&gt; , &lt;code&gt;module&lt;/code&gt; , &lt;code&gt;quote&lt;/code&gt; , &lt;code&gt;return&lt;/code&gt; , &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;try&lt;/code&gt; , &lt;code&gt;using&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; . 이러한 키워드는 변수 이름으로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c90facb0407832d3445cbf12e098939b6ab30525" translate="yes" xml:space="preserve">
          <source>This is useful with the do-block syntax for more complex temporal expressions:</source>
          <target state="translated">보다 복잡한 시간 표현을위한 do-block 구문에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1f135ed365e0881687323b4b2b1b547c6be25fa8" translate="yes" xml:space="preserve">
          <source>This is wasteful when dimensions get large, so Julia provides &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt;, which expands singleton dimensions in array arguments to match the corresponding dimension in the other array without using extra memory, and applies the given function elementwise:</source>
          <target state="translated">크기가 커지면 Julia는 낭비입니다. 따라서 Julia는 &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt; &lt;code&gt;broadcast&lt;/code&gt; 를&lt;/a&gt; 제공합니다 . 이것은 추가 인수를 사용하지 않고 다른 배열의 해당 차원과 일치하도록 배열 인수의 싱글 톤 차원을 확장하고 주어진 함수를 요소별로 적용합니다.</target>
        </trans-unit>
        <trans-unit id="7bd078ba5ec9612bff8795fa65ea85e0e4a4b835" translate="yes" xml:space="preserve">
          <source>This iterator is &quot;lazy&quot; in that it does not make a copy of the collection in order to reverse it; see &lt;code&gt;Base.reverse&lt;/code&gt; for an eager implementation.</source>
          <target state="translated">이 반복자는 컬렉션을 뒤집기 위해 컬렉션의 복사본을 만들지 않기 때문에 &quot;게으른&quot;것입니다. 열성적인 구현에 대해서는 &lt;code&gt;Base.reverse&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="668dce0079a5c7ecaeda787c6c43c4abed16e82f" translate="yes" xml:space="preserve">
          <source>This keeps things simple, while allowing the compiler to generate optimized code in all cases.</source>
          <target state="translated">이는 컴파일러가 모든 경우에 최적화 된 코드를 생성 할 수 있도록하는 동시에 단순하게 유지합니다.</target>
        </trans-unit>
        <trans-unit id="618a3a65c5497ca323b88a316514b70e984e986d" translate="yes" xml:space="preserve">
          <source>This kind of control flow can make it much easier to solve certain problems. In some problems, the various pieces of required work are not naturally related by function calls; there is no obvious &quot;caller&quot; or &quot;callee&quot; among the jobs that need to be done. An example is the producer-consumer problem, where one complex procedure is generating values and another complex procedure is consuming them. The consumer cannot simply call a producer function to get a value, because the producer may have more values to generate and so might not yet be ready to return. With tasks, the producer and consumer can both run as long as they need to, passing values back and forth as necessary.</source>
          <target state="translated">이러한 종류의 제어 흐름을 통해 특정 문제를 훨씬 쉽게 해결할 수 있습니다. 어떤 문제들에서, 요구되는 다양한 작업들은 자연스럽게 함수 호출과 관련이 없다. 해야 할 일들 사이에 명백한 &quot;발신자&quot;또는 &quot;칼리&quot;는 없습니다. 하나의 복잡한 절차는 값을 생성하고 다른 복잡한 절차는 값을 소비하는 생산자-소비자 문제입니다. 생산자는 생성 할 값이 더 많고 아직 반환 할 준비가되지 않았기 때문에 소비자는 단순히 생산자 함수를 호출하여 값을 얻을 수 없습니다. 작업을 통해 생산자와 소비자는 필요에 따라 원하는만큼 값을주고받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a88599aaef0898fffd99491510ed87461ecc31f" translate="yes" xml:space="preserve">
          <source>This kind of definition of function behavior by dispatch is quite common &amp;ndash; idiomatic, even &amp;ndash; in Julia. Method type parameters are not restricted to being used as the types of arguments: they can be used anywhere a value would be in the signature of the function or body of the function. Here's an example where the method type parameter &lt;code&gt;T&lt;/code&gt; is used as the type parameter to the parametric type &lt;code&gt;Vector{T}&lt;/code&gt; in the method signature:</source>
          <target state="translated">디스패치에 의한 이러한 종류의 함수 동작 정의는 Julia에서 매우 일반적입니다. 메소드 유형 매개 변수는 인수 유형으로 사용되는 것으로 제한되지 않습니다. 함수 또는 함수 본문의 서명에 값이있는 모든 위치에서 사용할 수 있습니다. 다음 은 메소드 서명에서 메소드 유형 매개 변수 &lt;code&gt;T&lt;/code&gt; 가 매개 변수 유형 &lt;code&gt;Vector{T}&lt;/code&gt; 에 대한 유형 매개 변수로 사용되는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="ec4239bc4b5dc918f448b6994ffeb011eb260c23" translate="yes" xml:space="preserve">
          <source>This kind of manipulation of variables should be used judiciously, but is occasionally quite handy.</source>
          <target state="translated">이런 종류의 변수 조작은 신중하게 사용해야하지만 때로는 매우 편리합니다.</target>
        </trans-unit>
        <trans-unit id="5cf1880888ac71427a2a472f83ebc4e3ee3aeac7" translate="yes" xml:space="preserve">
          <source>This last point is &lt;em&gt;very&lt;/em&gt; important: even though &lt;code&gt;Float64 &amp;lt;: Real&lt;/code&gt; we &lt;strong&gt;DO NOT&lt;/strong&gt; have &lt;code&gt;Point{Float64} &amp;lt;: Point{Real}&lt;/code&gt;.</source>
          <target state="translated">이 마지막 점은 &lt;em&gt;매우&lt;/em&gt; 중요 : 비록 &lt;code&gt;Float64 &amp;lt;: Real&lt;/code&gt; 우리가 &lt;strong&gt;하지 마십시오&lt;/strong&gt; 가 &lt;code&gt;Point{Float64} &amp;lt;: Point{Real}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7542405e58ae981f14134e43a96aca7f30233f49" translate="yes" xml:space="preserve">
          <source>This leverages a fallback implementation of &lt;code&gt;copyto!&lt;/code&gt; that converts the wrapper into a &lt;code&gt;Broadcasted{Nothing}&lt;/code&gt;. Consequently, specializing on &lt;code&gt;DestType&lt;/code&gt; has lower precedence than methods that specialize on &lt;code&gt;DestStyle&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;copyto!&lt;/code&gt; 의 대체 구현을 활용합니다 ! 랩퍼를 &lt;code&gt;Broadcasted{Nothing}&lt;/code&gt; 으로 변환합니다 . 결과적으로 &lt;code&gt;DestType&lt;/code&gt; 을 전문화하는 &lt;code&gt;DestStyle&lt;/code&gt; 을 전문화하는 메소드보다 우선 순위가 낮 습니다 .</target>
        </trans-unit>
        <trans-unit id="563a17c90111523e5b2f5d6e8d16952ec180646f" translate="yes" xml:space="preserve">
          <source>This loads the module &lt;code&gt;Foo&lt;/code&gt; and defines a variable &lt;code&gt;Foo&lt;/code&gt; that refers to the module, but does not import any of the other symbols from the module into the current namespace. You refer to the &lt;code&gt;Foo&lt;/code&gt; symbols by their qualified names &lt;code&gt;Foo.bar&lt;/code&gt; etc.</source>
          <target state="translated">이렇게하면 모듈 &lt;code&gt;Foo&lt;/code&gt; 가로드 되고 모듈 을 참조 하는 변수 &lt;code&gt;Foo&lt;/code&gt; 가 정의 되지만 모듈의 다른 심볼은 현재 네임 스페이스로 가져 오지 않습니다. &lt;code&gt;Foo&lt;/code&gt; 기호는 정규화 된 이름 &lt;code&gt;Foo.bar&lt;/code&gt; 등으로 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="4612a42efe8a5bdd3c4138ff12dd117c4e94f8e6" translate="yes" xml:space="preserve">
          <source>This macro can be used like this:</source>
          <target state="translated">이 매크로는 다음과 같이 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="796fb2fc91375e842873f0f25490416b48076f98" translate="yes" xml:space="preserve">
          <source>This macro takes one argument: &lt;code&gt;name&lt;/code&gt;. When &lt;code&gt;@sayhello&lt;/code&gt; is encountered, the quoted expression is &lt;em&gt;expanded&lt;/em&gt; to interpolate the value of the argument into the final expression:</source>
          <target state="translated">이 매크로는 &lt;code&gt;name&lt;/code&gt; 인수를 취 합니다. 때 &lt;code&gt;@sayhello&lt;/code&gt; 가 발생, 인용 식입니다 &lt;em&gt;확장&lt;/em&gt; 최종 표현에 인수의 값을 보간 :</target>
        </trans-unit>
        <trans-unit id="99355d54955b26bda6881d3a32f0394ad662278e" translate="yes" xml:space="preserve">
          <source>This makes it easy to use an arbitrary object (here a &lt;code&gt;raw&lt;/code&gt; string) as a docstring.</source>
          <target state="translated">따라서 임의의 객체 (여기서는 &lt;code&gt;raw&lt;/code&gt; 문자열)를 docstring으로 쉽게 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e352f04f9f33e3e34fa37d2a0e22a677123c5a98" translate="yes" xml:space="preserve">
          <source>This makes it hard to write many basic integer algorithms since a lot of common techniques depend on the fact that machine addition with overflow &lt;em&gt;is&lt;/em&gt; associative. Consider finding the midpoint between integer values &lt;code&gt;lo&lt;/code&gt; and &lt;code&gt;hi&lt;/code&gt; in Julia using the expression &lt;code&gt;(lo + hi) &amp;gt;&amp;gt;&amp;gt; 1&lt;/code&gt;:</source>
          <target state="translated">오버플 &lt;em&gt;로를&lt;/em&gt; 사용한 머신 추가 &lt;em&gt;가&lt;/em&gt; 연관 되어 있다는 사실에 많은 공통 기술이 의존하기 때문에 많은 기본 정수 알고리즘을 작성하기가 어렵습니다 . 표현식 &lt;code&gt;(lo + hi) &amp;gt;&amp;gt;&amp;gt; 1&lt;/code&gt; 사용하여 Julia에서 정수 값 &lt;code&gt;lo&lt;/code&gt; 와 &lt;code&gt;hi&lt;/code&gt; 사이의 중간 점을 찾는 것을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="bddf7a0f25a0e5f4299199009d8763508187037e" translate="yes" xml:space="preserve">
          <source>This makes it more clear where docstrings start and end.</source>
          <target state="translated">이것은 docstring이 어디서 시작하고 끝나는 지 더 명확하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="1390ee7b9f8d0f8dd34a701e5fbadb4b8b3c9256" translate="yes" xml:space="preserve">
          <source>This makes stack trace information available programmatically for logging, error handling, and more.</source>
          <target state="translated">이를 통해 로깅, 오류 처리 등에 스택 추적 정보를 프로그래밍 방식으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="118a450839bcd493b9a3323bf1931949bac102ac" translate="yes" xml:space="preserve">
          <source>This manifest file describes a possible complete dependency graph for the &lt;code&gt;App&lt;/code&gt; project:</source>
          <target state="translated">이 매니페스트 파일은 &lt;code&gt;App&lt;/code&gt; 프로젝트 의 가능한 완전한 종속성 그래프를 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="fa9bdb6f39c12cde4099183225c25db089937837" translate="yes" xml:space="preserve">
          <source>This may sound like a strange restriction, but remember that since C is not a dynamic language like Julia, its functions can only accept argument types with a statically-known, fixed signature.</source>
          <target state="translated">이것은 이상한 제한처럼 들릴 수 있지만 C는 Julia와 같은 동적 언어가 아니기 때문에 함수는 정적으로 알려진 고정 서명이있는 인수 유형 만 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccbe0f854d08689742c5122439446d8ae7400b8b" translate="yes" xml:space="preserve">
          <source>This means that calling &lt;code&gt;f()&lt;/code&gt; is equivalent to calling &lt;code&gt;f(1,2)&lt;/code&gt;. In this case the result is &lt;code&gt;5&lt;/code&gt;, because &lt;code&gt;f(1,2)&lt;/code&gt; invokes the first method of &lt;code&gt;f&lt;/code&gt; above. However, this need not always be the case. If you define a fourth method that is more specialized for integers:</source>
          <target state="translated">이것은 &lt;code&gt;f()&lt;/code&gt; 호출이 &lt;code&gt;f(1,2)&lt;/code&gt; 호출과 동일 하다는 것을 의미합니다 . 이 경우 결과는 &lt;code&gt;5&lt;/code&gt; 입니다 . &lt;code&gt;f(1,2)&lt;/code&gt; 는 위에서 &lt;code&gt;f&lt;/code&gt; 의 첫 번째 메서드를 호출 하기 때문 입니다. 그러나 항상 그런 것은 아닙니다. 정수에 더 특화된 네 번째 방법을 정의하는 경우 :</target>
        </trans-unit>
        <trans-unit id="d91824530ea1dcad07d2ce3b7c87745b23855a91" translate="yes" xml:space="preserve">
          <source>This means that new &lt;code&gt;Number&lt;/code&gt; types only need to define constructors, since this definition will handle &lt;code&gt;convert&lt;/code&gt; for them. An identity conversion is also provided to handle the case where the argument is already of the requested type:</source>
          <target state="translated">즉, 새로운 &lt;code&gt;Number&lt;/code&gt; 유형은 생성자를 정의하기 만하면됩니다.이 정의는 &lt;code&gt;convert&lt;/code&gt; 을 처리 하기 때문입니다. 인수가 이미 요청 된 유형 인 경우를 처리하기 위해 ID 변환도 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="d95d868bc45acbbf3d653adf2e5564fd580718ec" translate="yes" xml:space="preserve">
          <source>This means that rounding a &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to an even multiple of seconds, minutes, hours, or years (because the ISO 8601 specification includes a year zero) will result in a &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; with an even value in that field, while rounding a &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to an even multiple of months will result in the months field having an odd value. Because both months and years may contain an irregular number of days, whether rounding to an even number of days will result in an even value in the days field is uncertain.</source>
          <target state="translated">즉, &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 을 초, 분, 시간 또는 년의 배수로 반올림하면 (ISO 8601 사양에 0이 포함되어 있기 때문에) &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 은 해당 필드에 짝수 값을 &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 은 짝수로 반올림 됩니다. 개월의 배수는 개월 필드의 값이 홀수입니다. 월과 연도 모두 불규칙한 일수를 포함 할 수 있으므로 짝수 일로 반올림하여 일 필드의 짝수 값이 확실하지 않은지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="0b1724fb3df29f491e1db30646921be60d52e085" translate="yes" xml:space="preserve">
          <source>This means we must also define a corresponding &lt;code&gt;similar&lt;/code&gt; method:</source>
          <target state="translated">즉, &lt;code&gt;similar&lt;/code&gt; 방법을 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8164014a03b0ed9d2a2a01cfd412eb70f3f6cf4e" translate="yes" xml:space="preserve">
          <source>This mechanism can be implemented easily by custom exception types following the way &lt;a href=&quot;../../base/base/index#Core.UndefVarError&quot;&gt;&lt;code&gt;UndefVarError&lt;/code&gt;&lt;/a&gt; is written:</source>
          <target state="translated">이 메커니즘은 &lt;a href=&quot;../../base/base/index#Core.UndefVarError&quot;&gt; &lt;code&gt;UndefVarError&lt;/code&gt; &lt;/a&gt; 작성 방식에 따라 사용자 정의 예외 유형으로 쉽게 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="00b20545036f8cfdf164022ed01300b951b2a39d" translate="yes" xml:space="preserve">
          <source>This mechanism is also the key to how type constructors and closures (inner functions that refer to their surrounding environment) work in Julia.</source>
          <target state="translated">이 메커니즘은 Julia에서 형식 생성자와 클로저 (주변 환경을 참조하는 내부 함수)가 작동하는 방식의 핵심이기도합니다.</target>
        </trans-unit>
        <trans-unit id="87a9a57282476dafb9bfcdbc06caa5e75c2590eb" translate="yes" xml:space="preserve">
          <source>This mechanism is of course used by the default implementation of random array generation (like in &lt;code&gt;rand(1:20, 10)&lt;/code&gt;). In order to implement this decoupling for a custom type, a helper type can be used. Going back to our &lt;code&gt;Die&lt;/code&gt; example: &lt;code&gt;rand(::Die)&lt;/code&gt; uses random generation from a range, so there is an opportunity for this optimization:</source>
          <target state="translated">이 메커니즘은 물론 무작위 배열 생성의 기본 구현에서 사용됩니다 ( &lt;code&gt;rand(1:20, 10)&lt;/code&gt; ). 사용자 정의 유형에 대해이 분리를 구현하기 위해 헬퍼 유형을 사용할 수 있습니다. &lt;code&gt;Die&lt;/code&gt; 예제로 돌아가서 : &lt;code&gt;rand(::Die)&lt;/code&gt; 는 범위에서 랜덤 생성을 사용하므로이 최적화에 대한 기회가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f75a278538a1522abc6fa98d70bcb27983fcccb3" translate="yes" xml:space="preserve">
          <source>This method creates a &lt;code&gt;DateFormat&lt;/code&gt; object each time it is called. If you are parsing many date strings of the same format, consider creating a &lt;a href=&quot;#Dates.DateFormat&quot;&gt;&lt;code&gt;DateFormat&lt;/code&gt;&lt;/a&gt; object once and using that as the second argument instead.</source>
          <target state="translated">이 메서드 는 호출 될 때마다 &lt;code&gt;DateFormat&lt;/code&gt; 객체를 만듭니다 . 동일한 형식의 많은 날짜 문자열을 구문 분석하는 경우 &lt;a href=&quot;#Dates.DateFormat&quot;&gt; &lt;code&gt;DateFormat&lt;/code&gt; &lt;/a&gt; 오브젝트를 한 번 작성 하고 두 번째 인수로 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9d972e8cda3b91e650e6ff3541ce6f8b54cbae93" translate="yes" xml:space="preserve">
          <source>This method creates a &lt;code&gt;DateFormat&lt;/code&gt; object each time it is called. If you are parsing many date time strings of the same format, consider creating a &lt;a href=&quot;#Dates.DateFormat&quot;&gt;&lt;code&gt;DateFormat&lt;/code&gt;&lt;/a&gt; object once and using that as the second argument instead.</source>
          <target state="translated">이 메서드 는 호출 될 때마다 &lt;code&gt;DateFormat&lt;/code&gt; 객체를 만듭니다 . 동일한 형식의 많은 날짜 시간 문자열을 구문 분석하는 경우 &lt;a href=&quot;#Dates.DateFormat&quot;&gt; &lt;code&gt;DateFormat&lt;/code&gt; &lt;/a&gt; 오브젝트를 한 번 작성 하고 두 번째 인수로 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cb2233a83e18eafded9574a3a241275b67521981" translate="yes" xml:space="preserve">
          <source>This method definition applies to any pair of arguments that are instances of &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;. They need not be of the same type, so long as they are each numeric values. The problem of handling disparate numeric types is delegated to the arithmetic operations in the expression &lt;code&gt;2x - y&lt;/code&gt;.</source>
          <target state="translated">이 메소드 정의는 &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; 의&lt;/a&gt; 인스턴스 인 모든 인수 쌍에 적용됩니다 . 각 숫자 값인 한 동일한 유형일 필요는 없습니다. 이종 숫자 유형을 처리하는 문제는 표현식 &lt;code&gt;2x - y&lt;/code&gt; 의 산술 연산에 위임됩니다 .</target>
        </trans-unit>
        <trans-unit id="25be108587097965bc1d457d2798dc697b2b0387" translate="yes" xml:space="preserve">
          <source>This method is available as of Julia 1.1.</source>
          <target state="translated">이 방법은 Julia 1.1부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7154e71f550aec85c7b6230d9f61b37f4a29ed8a" translate="yes" xml:space="preserve">
          <source>This method requires Julia 1.2 or later.</source>
          <target state="translated">이 방법에는 Julia 1.2 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="899440f2ea2fee6c702b6f89d814399868b760bc" translate="yes" xml:space="preserve">
          <source>This method requires at least Julia 1.1.</source>
          <target state="translated">이 방법에는 Julia 1.1 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="870b2fd7cad296236db6b2acee5daac8bcbed1f1" translate="yes" xml:space="preserve">
          <source>This method requires at least Julia 1.2.</source>
          <target state="translated">이 방법에는 Julia 1.2 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="df192a99d234108a172dc69e2511778133fdb5c8" translate="yes" xml:space="preserve">
          <source>This method uses the &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; function to explicitly convert &lt;code&gt;x&lt;/code&gt; to &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; and then delegates construction to the general constructor for the case where both arguments are &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;. With this method definition what was previously a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; now successfully creates a point of type &lt;code&gt;Point{Float64}&lt;/code&gt;:</source>
          <target state="translated">이 메서드는 &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 &lt;code&gt;x&lt;/code&gt; 를 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; 로 명시 적으로 변환 한 다음 두 인수가 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; 경우 생성자를 일반 생성자에게 위임 합니다. 이 메소드 정의를 사용하면 이전에 &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; 였던 것이 &lt;code&gt;Point{Float64}&lt;/code&gt; 유형의 포인트를 성공적으로 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="f6303e3b58af767dd0d1fbddaa5592d4577466dc" translate="yes" xml:space="preserve">
          <source>This might be worthwhile when either of the following are true:</source>
          <target state="translated">다음 중 하나에 해당하면 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="caca6d3dad29a6885489c96c973507436880d558" translate="yes" xml:space="preserve">
          <source>This module defines a type &lt;code&gt;MyType&lt;/code&gt;, and two functions. Function &lt;code&gt;foo&lt;/code&gt; and type &lt;code&gt;MyType&lt;/code&gt; are exported, and so will be available for importing into other modules. Function &lt;code&gt;bar&lt;/code&gt; is private to &lt;code&gt;MyModule&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 &lt;code&gt;MyType&lt;/code&gt; 유형 과 두 가지 함수를 정의 합니다. 함수 &lt;code&gt;foo&lt;/code&gt; 와 유형 &lt;code&gt;MyType&lt;/code&gt; 이 내보내 지므로 다른 모듈로 가져올 수 있습니다. 기능 &lt;code&gt;bar&lt;/code&gt; 은 &lt;code&gt;MyModule&lt;/code&gt; 전용 입니다.</target>
        </trans-unit>
        <trans-unit id="e361081ac903885d30799d0af09374c26253366e" translate="yes" xml:space="preserve">
          <source>This new compact representation will be used when the passed IO stream is an &lt;code&gt;IOContext&lt;/code&gt; object with the &lt;code&gt;:compact&lt;/code&gt; property set. In particular, this is the case when printing arrays with multiple columns (where horizontal space is limited):</source>
          <target state="translated">이 새로운 컴팩트 표현은 전달 된 IO 스트림이 &lt;code&gt;:compact&lt;/code&gt; 속성이 설정된 &lt;code&gt;IOContext&lt;/code&gt; 객체 일 때 사용됩니다 . 특히 여러 열로 배열을 인쇄하는 경우 (가로 공간이 제한된 경우) :</target>
        </trans-unit>
        <trans-unit id="c9d9b11cb845e47e607c614fa51676b8589b0e20" translate="yes" xml:space="preserve">
          <source>This normalized form for a ratio of integers is unique, so equality of rational values can be tested by checking for equality of the numerator and denominator. The standardized numerator and denominator of a rational value can be extracted using the &lt;a href=&quot;../../base/math/index#Base.numerator&quot;&gt;&lt;code&gt;numerator&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/math/index#Base.denominator&quot;&gt;&lt;code&gt;denominator&lt;/code&gt;&lt;/a&gt; functions:</source>
          <target state="translated">정수 비율에 대한이 정규화 된 형식은 고유하므로 분자와 분모가 같은지 확인하여 합리적인 값의 동등성을 테스트 할 수 있습니다. 합리적인 값의 표준화 된 분자 및 분모는 &lt;a href=&quot;../../base/math/index#Base.numerator&quot;&gt; &lt;code&gt;numerator&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/math/index#Base.denominator&quot;&gt; &lt;code&gt;denominator&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 추출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ae131da59b641e6a04de571be058c6c357d2762" translate="yes" xml:space="preserve">
          <source>This object is NOT thread-safe. See &lt;a href=&quot;#Base.Threads.Condition&quot;&gt;&lt;code&gt;Threads.Condition&lt;/code&gt;&lt;/a&gt; for a thread-safe version.</source>
          <target state="translated">이 객체는 스레드로부터 안전하지 않습니다. 스레드 안전 버전은 스레드 &lt;a href=&quot;#Base.Threads.Condition&quot;&gt; &lt;code&gt;Threads.Condition&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e4a7f18d5f3325b0b4b506c0553650e84bb55e2" translate="yes" xml:space="preserve">
          <source>This operation is intended for linear algebra usage - for general data manipulation see &lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt;&lt;code&gt;permutedims&lt;/code&gt;&lt;/a&gt;, which is non-recursive.</source>
          <target state="translated">이 연산은 선형 대수 사용을위한 것입니다. 일반적인 데이터 조작에 대해서는 재귀가 아닌 &lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt; &lt;code&gt;permutedims&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="68fb902f0905ca9a9a84e0916a21520831fc7805" translate="yes" xml:space="preserve">
          <source>This operation is intended for linear algebra usage - for general data manipulation see &lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt;&lt;code&gt;permutedims&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 연산은 선형 대수 사용을위한 것입니다 . 일반적인 데이터 조작에 대해서는 &lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt; &lt;code&gt;permutedims&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5890e27550178f3b3f621b391f08592d04b935ac" translate="yes" xml:space="preserve">
          <source>This operator follows IEEE semantics for floating-point numbers: &lt;code&gt;0.0 == -0.0&lt;/code&gt; and &lt;code&gt;NaN != NaN&lt;/code&gt;.</source>
          <target state="translated">이 연산자는 부동 소수점 숫자에 대한 IEEE 의미 체계를 따릅니다 ( &lt;code&gt;0.0 == -0.0&lt;/code&gt; 및 &lt;code&gt;NaN != NaN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f45001a85e32a4368ea2b2117472a674fb4b812d" translate="yes" xml:space="preserve">
          <source>This output tells us that &lt;code&gt;f&lt;/code&gt; is a function object with two methods. To find out what the signatures of those methods are, use the &lt;a href=&quot;../../base/base/index#Base.methods&quot;&gt;&lt;code&gt;methods&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">이 출력은 &lt;code&gt;f&lt;/code&gt; 가 두 가지 방법을 가진 함수 객체 라는 것을 알려줍니다 . 해당 메소드의 서명이 무엇인지 확인하려면 &lt;a href=&quot;../../base/base/index#Base.methods&quot;&gt; &lt;code&gt;methods&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="27399a34acfc119b2b6802fe2da7d02ba2868aed" translate="yes" xml:space="preserve">
          <source>This pattern is implemented by defining a generic function which computes a different singleton value (or type) for each trait-set to which the function arguments may belong to. If this function is pure there is no impact on performance compared to normal dispatch.</source>
          <target state="translated">이 패턴은 함수 인수가 속하는 각 특성 세트에 대해 다른 싱글 톤 값 (또는 유형)을 계산하는 일반 함수를 정의하여 구현됩니다. 이 기능이 순수한 경우 일반 디스패치와 비교하여 성능에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c8dd670a38453a8c5ac96a2263bb252ef6b9b2f1" translate="yes" xml:space="preserve">
          <source>This pattern is so frequent that a helper type named &lt;code&gt;Random.SamplerSimple&lt;/code&gt; is available, saving us the definition of &lt;code&gt;SamplerDie&lt;/code&gt;: we could have implemented our decoupling with:</source>
          <target state="translated">이 패턴은 이름의 도우미 유형 너무 빈번 &lt;code&gt;Random.SamplerSimple&lt;/code&gt; 는 우리의 정의 저장, 사용할 수 있습니다 &lt;code&gt;SamplerDie&lt;/code&gt; 을 : 우리는 우리의 디커플링을 구현 할 수 :</target>
        </trans-unit>
        <trans-unit id="788eade9955684aef54020e83665092b3b21d4bd" translate="yes" xml:space="preserve">
          <source>This pattern is used in several places in Julia Base. For example, see &lt;code&gt;vcat&lt;/code&gt; and &lt;code&gt;hcat&lt;/code&gt; in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/40fe264f4ffaa29b749bcf42239a89abdcbba846/base/abstractarray.jl#L1205-L1206&quot;&gt;&lt;code&gt;abstractarray.jl&lt;/code&gt;&lt;/a&gt;, or the &lt;a href=&quot;../../base/arrays/index#Base.fill!&quot;&gt;&lt;code&gt;fill!&lt;/code&gt;&lt;/a&gt; function, which we could have used instead of writing our own &lt;code&gt;fill_twos!&lt;/code&gt;.</source>
          <target state="translated">이 패턴은 Julia Base의 여러 곳에서 사용됩니다. 예를 들어, 참조 &lt;code&gt;vcat&lt;/code&gt; 및 &lt;code&gt;hcat&lt;/code&gt; 에 &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/40fe264f4ffaa29b749bcf42239a89abdcbba846/base/abstractarray.jl#L1205-L1206&quot;&gt; &lt;code&gt;abstractarray.jl&lt;/code&gt; &lt;/a&gt; , 또는 &lt;a href=&quot;../../base/arrays/index#Base.fill!&quot;&gt; &lt;code&gt;fill!&lt;/code&gt; &lt;/a&gt;우리 자신의 &lt;code&gt;fill_twos!&lt;/code&gt; 를 작성하는 대신 사용할 수있는 함수 ! .</target>
        </trans-unit>
        <trans-unit id="a07692e105ddc917557be8ec34d26c6d0d0ad87f" translate="yes" xml:space="preserve">
          <source>This pipes the output of the &lt;code&gt;echo&lt;/code&gt; command to the &lt;code&gt;sort&lt;/code&gt; command. Of course, this isn't terribly interesting since there's only one line to sort, but we can certainly do much more interesting things:</source>
          <target state="translated">&lt;code&gt;echo&lt;/code&gt; 명령 의 출력을 &lt;code&gt;sort&lt;/code&gt; 명령으로 파이프합니다 . 물론 정렬 할 줄이 하나뿐이기 때문에 이것은별로 흥미롭지 않지만 훨씬 더 흥미로운 일을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28745bdf70806fa587f3e325d2378a4dbc6461d5" translate="yes" xml:space="preserve">
          <source>This prints the highest five user IDs on a UNIX system. The &lt;code&gt;cut&lt;/code&gt;, &lt;code&gt;sort&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt; commands are all spawned as immediate children of the current &lt;code&gt;julia&lt;/code&gt; process, with no intervening shell process. Julia itself does the work to setup pipes and connect file descriptors that is normally done by the shell. Since Julia does this itself, it retains better control and can do some things that shells cannot.</source>
          <target state="translated">UNIX 시스템에서 가장 높은 5 개의 사용자 ID를 인쇄합니다. &lt;code&gt;cut&lt;/code&gt; , &lt;code&gt;sort&lt;/code&gt; 및 &lt;code&gt;tail&lt;/code&gt; 명령은 모든 현재의 직계 자식으로 양산된다 &lt;code&gt;julia&lt;/code&gt; 중재하는 쉘 프로세스와 프로세스. Julia 자체는 파이프를 설정하고 일반적으로 쉘에서 수행하는 파일 디스크립터를 연결하는 작업을 수행합니다. Julia는이 작업을 자체적으로 수행하기 때문에 더 나은 제어력을 유지하고 껍질이 할 수없는 일을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23fa7f062adc867f3f830f4783d112980678deb3" translate="yes" xml:space="preserve">
          <source>This project file implies the following roots map, if it was represented by a Julia dictionary:</source>
          <target state="translated">이 프로젝트 파일은 Julia 사전으로 표시되는 경우 다음 루트 맵을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="abc51e24a31d52999d77393c1e2d796880b68886" translate="yes" xml:space="preserve">
          <source>This quantity is also known in the literature as the Bauer condition number, relative condition number, or componentwise relative condition number.</source>
          <target state="translated">이 양은 문헌에서 바우어 조건 번호, 상대 조건 번호 또는 성분 별 상대 조건 번호라고도합니다.</target>
        </trans-unit>
        <trans-unit id="2e42070fb796891f9806f28a3d77516fa4beb07e" translate="yes" xml:space="preserve">
          <source>This regex has the first three flags enabled.</source>
          <target state="translated">이 정규식에는 처음 세 개의 플래그가 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee3fcabcdbbc8234e7f06a55081b08ead3e3a1c5" translate="yes" xml:space="preserve">
          <source>This relationship is also invariant:</source>
          <target state="translated">이 관계도 변하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="59fcc1007eeaedfc2adf51cf837dd399f227cb88" translate="yes" xml:space="preserve">
          <source>This returns a &lt;code&gt;5&amp;times;5 Bidiagonal{Float64}&lt;/code&gt;, which can now be passed to other linear algebra functions (e.g. eigensolvers) which will use specialized methods for &lt;code&gt;Bidiagonal&lt;/code&gt; types.</source>
          <target state="translated">이것은 &lt;code&gt;5&amp;times;5 Bidiagonal{Float64}&lt;/code&gt; 반환하는데 , 이제 &lt;code&gt;Bidiagonal&lt;/code&gt; 유형에 특화된 방법을 사용하는 다른 선형 대수 함수 (예 : 고유 솔버 )로 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51739dfebbc5e267c6346f6dae65d7a77c8eb77b" translate="yes" xml:space="preserve">
          <source>This section describes Julia's markdown syntax, which is enabled by the Markdown standard library. The following Markdown elements are supported:</source>
          <target state="translated">이 섹션에서는 Julia의 마크 다운 구문에 대해 설명하며 마크 다운 표준 라이브러리에서 활성화됩니다. 다음과 같은 마크 다운 요소가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="dfa63ea10e93a9723f06f6e4891ca5c36280959e" translate="yes" xml:space="preserve">
          <source>This seems obvious, because two of each of these periods still divides evenly into the next larger order period. But in the case of two months (which still divides evenly into one year), the answer may be surprising:</source>
          <target state="translated">각 기간 중 두 기간이 여전히 다음 큰 주문 기간으로 균등하게 분할되기 때문에 이는 분명해 보입니다. 그러나 2 개월 (여전히 1 년으로 균등하게 나눠지는 경우)의 경우 대답은 놀랍습니다.</target>
        </trans-unit>
        <trans-unit id="90f8183fe3e114c60192daf58de9ecad787e8334" translate="yes" xml:space="preserve">
          <source>This sets the &lt;a href=&quot;http://llvm.org/docs/LangRef.html#fast-math-flags&quot;&gt;LLVM Fast-Math flags&lt;/a&gt;, and corresponds to the &lt;code&gt;-ffast-math&lt;/code&gt; option in clang. See &lt;a href=&quot;../../manual/performance-tips/index#man-performance-annotations-1&quot;&gt;the notes on performance annotations&lt;/a&gt; for more details.</source>
          <target state="translated">이는 &lt;a href=&quot;http://llvm.org/docs/LangRef.html#fast-math-flags&quot;&gt;LLVM Fast-Math 플래그를&lt;/a&gt; 설정하며 clang 의 &lt;code&gt;-ffast-math&lt;/code&gt; 옵션에 해당합니다 . 자세한 내용 &lt;a href=&quot;../../manual/performance-tips/index#man-performance-annotations-1&quot;&gt;은 성능 주석에&lt;/a&gt; 대한 참고 사항을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3f1e8b5b57b03661a32579fb9fe3d14174f160bb" translate="yes" xml:space="preserve">
          <source>This setting will cause &lt;code&gt;eachindex&lt;/code&gt; iteration over a &lt;code&gt;MyArray&lt;/code&gt; to use integers. If you don't specify this trait, the default value &lt;code&gt;IndexCartesian()&lt;/code&gt; is used.</source>
          <target state="translated">이 설정은 &lt;code&gt;MyArray&lt;/code&gt; 에서 각 &lt;code&gt;eachindex&lt;/code&gt; 반복이 정수를 사용하게합니다. 이 특성을 지정하지 않으면 기본값 &lt;code&gt;IndexCartesian()&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dd212ee97174c1074845d2f071ed810c2eb44e14" translate="yes" xml:space="preserve">
          <source>This should be written as:</source>
          <target state="translated">이것은 다음과 같이 작성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="61e8d88c0f9a32cfa6a86779f848c68e25d1219f" translate="yes" xml:space="preserve">
          <source>This situation can happen only for invalid UTF-8 strings. For valid UTF-8 strings concatenation preserves all characters in strings and additivity of string lengths.</source>
          <target state="translated">이 상황은 유효하지 않은 UTF-8 문자열에 대해서만 발생할 수 있습니다. 유효한 UTF-8 문자열의 경우 연결은 문자열의 모든 문자와 문자열 길이의 가산 성을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="602515b8cfd836d63ad817e8e5eb0cdf75d4d344" translate="yes" xml:space="preserve">
          <source>This small handful of promotion rules, together with the type's constructors and the default &lt;code&gt;convert&lt;/code&gt; method for numbers, are sufficient to make rational numbers interoperate completely naturally with all of Julia's other numeric types &amp;ndash; integers, floating-point numbers, and complex numbers. By providing appropriate conversion methods and promotion rules in the same manner, any user-defined numeric type can interoperate just as naturally with Julia's predefined numerics.</source>
          <target state="translated">이 소수의 승격 규칙은 유형의 생성자 및 숫자 의 기본 &lt;code&gt;convert&lt;/code&gt; 방법과 함께 합리적인 숫자가 Julia의 다른 모든 숫자 유형 (정수, 부동 소수점 숫자 및 복소수)과 완전히 자연스럽게 상호 작용하기에 충분합니다. 동일한 방식으로 적절한 변환 방법 및 승격 규칙을 제공함으로써 모든 사용자 정의 숫자 유형은 Julia의 사전 정의 된 숫자와 자연스럽게 상호 작용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62b4befadfb2df7bd237a94a52e5e887dfce736d" translate="yes" xml:space="preserve">
          <source>This sort of in-language code generation, however, using the &lt;code&gt;eval(quote(...))&lt;/code&gt; pattern, is common enough that Julia comes with a macro to abbreviate this pattern:</source>
          <target state="translated">그러나 &lt;code&gt;eval(quote(...))&lt;/code&gt; 패턴을 사용하는 이런 종류의 언어 코드 생성 은 Julia가이 패턴을 약식 화하기위한 매크로를 제공 할만큼 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="29761b0f52dd794108c079b8401444ddd6c7292e" translate="yes" xml:space="preserve">
          <source>This style of code presents performance challenges for the language. The parser, when translating it into lower-level instructions, substantially reorganizes the above code by extracting the inner function to a separate code block. &quot;Captured&quot; variables such as &lt;code&gt;r&lt;/code&gt; that are shared by inner functions and their enclosing scope are also extracted into a heap-allocated &quot;box&quot; accessible to both inner and outer functions because the language specifies that &lt;code&gt;r&lt;/code&gt; in the inner scope must be identical to &lt;code&gt;r&lt;/code&gt; in the outer scope even after the outer scope (or another inner function) modifies &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">이 스타일의 코드는 언어의 성능 문제를 나타냅니다. 파서는 하위 레벨 명령어로 변환 할 때 내부 함수를 별도의 코드 블록으로 추출하여 위의 코드를 실질적으로 재구성합니다. 예컨대 &quot;캡처&quot;변수 &lt;code&gt;r&lt;/code&gt; 내부 기능과 바깥 쪽 영역에서 공유 해당 언어 지정하므로 두 내외 기능에 액세스 힙 할당 &quot;박스&quot;로 추출 &lt;code&gt;r&lt;/code&gt; 내부 범위가 동일해야 &lt;code&gt;r&lt;/code&gt; 외부 영역에서도 외측 영역 (또는 다른 내부 기능) 후 수정은 &lt;code&gt;r&lt;/code&gt; 에 .</target>
        </trans-unit>
        <trans-unit id="84f5c4c03a8a8eafdd24b33dcdffe8977865737f" translate="yes" xml:space="preserve">
          <source>This style point is especially relevant to function arguments. For example, don't declare an argument to be of type &lt;code&gt;Int&lt;/code&gt; or &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt; if it really could be any integer, expressed with the abstract type &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt;. In fact, in many cases you can omit the argument type altogether, unless it is needed to disambiguate from other method definitions, since a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; will be thrown anyway if a type is passed that does not support any of the requisite operations. (This is known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Duck_typing&quot;&gt;duck typing&lt;/a&gt;.)</source>
          <target state="translated">이 스타일 포인트는 특히 함수 인수와 관련이 있습니다. 예를 들어, 인수가 실제로 &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt; 유형으로 표현 된 정수일 수있는 경우 &lt;code&gt;Int&lt;/code&gt; 또는 &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt; 유형으로 인수를 선언하지 마십시오 . 실제로, 많은 메소드에서 다른 메소드 정의를 명확하게 할 필요가없는 한 인수 유형을 모두 생략 할 수 있습니다 . 필수 조작을 지원하지 않는 유형이 전달되면 &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; 가 발생하기 때문입니다. 이것을 &lt;a href=&quot;https://en.wikipedia.org/wiki/Duck_typing&quot;&gt;오리 타이핑이라고&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="efb1d086124f576400d48da57453f979b82b1320" translate="yes" xml:space="preserve">
          <source>This syntax is paired with the inline syntax for &lt;a href=&quot;#Footnote-references-1&quot;&gt;Footnote references&lt;/a&gt;. Make sure to read that section as well.</source>
          <target state="translated">이 구문은 &lt;a href=&quot;#Footnote-references-1&quot;&gt;각주 참조를&lt;/a&gt; 위한 인라인 구문과 쌍을 이룹니다 . 해당 섹션도 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="c6d5e6bac01082ca8f7d5c92e2fcad7892b0deee" translate="yes" xml:space="preserve">
          <source>This syntax is particularly useful with the terse single-line function definition form introduced in &lt;a href=&quot;../faq/index#Functions-1&quot;&gt;Functions&lt;/a&gt;. Although it is typical, there is no requirement that &lt;code&gt;begin&lt;/code&gt; blocks be multiline or that &lt;code&gt;(;)&lt;/code&gt; chains be single-line:</source>
          <target state="translated">이 구문은 &lt;a href=&quot;../faq/index#Functions-1&quot;&gt;Functions에&lt;/a&gt; 도입 된 간결한 단일 행 함수 정의 양식에 특히 유용합니다 . 일반적이지만 &lt;code&gt;begin&lt;/code&gt; 블록이 여러 줄이거 나 &lt;code&gt;(;)&lt;/code&gt; 체인이 한 줄일 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f077087d177239939e6f396d6a624b184f2ac650" translate="yes" xml:space="preserve">
          <source>This syntax makes it easier to use functions to effectively extend the language, since calls look like normal code blocks. There are many possible uses quite different from &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, such as managing system state. For example, there is a version of &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; that runs code ensuring that the opened file is eventually closed:</source>
          <target state="translated">이 구문을 사용하면 호출이 일반 코드 블록처럼 보이기 때문에 함수를 사용하여 언어를 효과적으로 확장 할 수 있습니다. 시스템 상태 관리와 같이 &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; 과 는 상당히 다른 많은 용도가 있습니다 . 예를 들어, 열린 파일이 결국 닫히도록하는 코드를 실행 하는 &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; 버전이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d1ae67ce8368a39428c877f009a37b4f880a256" translate="yes" xml:space="preserve">
          <source>This table may appear to contain missing characters in the second column, or even show characters that are inconsistent with the characters as they are rendered in the Julia REPL. In these cases, users are strongly advised to check their choice of fonts in their browser and REPL environment, as there are known issues with glyphs in many fonts.</source>
          <target state="translated">이 테이블은 두 번째 열에 누락 된 문자가 포함 된 것으로 보이거나 Julia REPL에서 렌더링 될 때 문자와 일치하지 않는 문자를 표시 할 수도 있습니다. 이 경우 많은 글꼴의 글리프 관련 문제가 있으므로 브라우저 및 REPL 환경에서 글꼴 선택을 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c89bcac53db86417f8d21a8b570dbed4f33b9ba7" translate="yes" xml:space="preserve">
          <source>This trait is generally used to select between algorithms that pre-allocate a specific type of result, and algorithms that pick a result type based on the types of yielded values.</source>
          <target state="translated">이 특성은 일반적으로 특정 유형의 결과를 미리 할당하는 알고리즘과 산출 된 값의 유형에 따라 결과 유형을 선택하는 알고리즘 중에서 선택하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1f0edb00527596f441fd9eb4ee2e34299adf317c" translate="yes" xml:space="preserve">
          <source>This trait is generally used to select between algorithms that pre-allocate space for their result, and algorithms that resize their result incrementally.</source>
          <target state="translated">이 특성은 일반적으로 결과를위한 공간을 미리 할당하는 알고리즘과 결과의 크기를 점차적으로 조정하는 알고리즘 중에서 선택하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2b71013f6265bcf3fbfa85be77bdc79abb70d813" translate="yes" xml:space="preserve">
          <source>This trait-based approach is also present in the &lt;a href=&quot;../../base/base/index#Base.promote&quot;&gt;&lt;code&gt;promote&lt;/code&gt;&lt;/a&gt; mechanism employed by the scalar &lt;code&gt;+&lt;/code&gt;. It uses &lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt;&lt;code&gt;promote_type&lt;/code&gt;&lt;/a&gt;, which returns the optimal common type to compute the operation given the two types of the operands. This makes it possible to reduce the problem of implementing every function for every pair of possible type arguments, to the much smaller problem of implementing a conversion operation from each type to a common type, plus a table of preferred pair-wise promotion rules.</source>
          <target state="translated">이 특성 기반 접근법은 스칼라 &lt;code&gt;+&lt;/code&gt; 에 의해 사용되는 &lt;a href=&quot;../../base/base/index#Base.promote&quot;&gt; &lt;code&gt;promote&lt;/code&gt; &lt;/a&gt; 메커니즘 에도 존재합니다 . &lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt; &lt;code&gt;promote_type&lt;/code&gt; 을&lt;/a&gt; 사용 하여 최적의 공통 유형을 리턴하여 두 유형의 피연산자에 대한 오퍼레이션을 계산합니다. 이를 통해 모든 가능한 유형 인수 쌍에 대해 모든 함수를 구현하는 문제를 각 유형에서 공통 유형으로 변환 조작을 구현하는 훨씬 작은 문제와 선호하는 쌍별 승격 규칙 표를 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c92d7110a049bc7dcfccf1f71e9a16f713393738" translate="yes" xml:space="preserve">
          <source>This type is intended for linear algebra usage - for general data manipulation see &lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt;&lt;code&gt;permutedims&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 유형은 선형 대수 사용을위한 것입니다 . 일반적인 데이터 조작에 대해서는 &lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt; &lt;code&gt;permutedims&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="14576a2d3cb9e572c8640a36656bd2d6880b92e4" translate="yes" xml:space="preserve">
          <source>This type may appear innocuous enough, until one considers how to construct an instance of it. If &lt;code&gt;a&lt;/code&gt; is an instance of &lt;code&gt;SelfReferential&lt;/code&gt;, then a second instance can be created by the call:</source>
          <target state="translated">이 유형은 인스턴스 구성 방법을 고려할 때까지 무해한 것으로 보일 수 있습니다. 경우 &lt;code&gt;a&lt;/code&gt; 의 인스턴스 &lt;code&gt;SelfReferential&lt;/code&gt; 가 다음 두 번째 인스턴스가 호출에 의해 생성 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="48abfe02204852dcf9f8e73526e2ce7ae985ea01" translate="yes" xml:space="preserve">
          <source>This typically means that types for which a custom &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;isequal&lt;/code&gt; method exists must implement a corresponding &lt;code&gt;hash&lt;/code&gt; method (and vice versa). Collections typically implement &lt;code&gt;isequal&lt;/code&gt; by calling &lt;code&gt;isequal&lt;/code&gt; recursively on all contents.</source>
          <target state="translated">이것은 일반적으로 custom &lt;code&gt;==&lt;/code&gt; 또는 &lt;code&gt;isequal&lt;/code&gt; 메소드가 존재 하는 유형 은 해당 &lt;code&gt;hash&lt;/code&gt; 메소드를 구현해야 하며 그 반대도 마찬가지입니다. 컬렉션은 일반적으로 모든 내용에서 &lt;code&gt;isequal&lt;/code&gt; 을 재귀 적으로 호출 하여 &lt;code&gt;isequal&lt;/code&gt; 을 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="e583420152cbf4b34f9b32d8a694ae8548f399df" translate="yes" xml:space="preserve">
          <source>This will continuing tracking changes for &lt;code&gt;path&lt;/code&gt; in the background until &lt;code&gt;unwatch_folder&lt;/code&gt; is called on the same &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;unwatch_folder&lt;/code&gt; 가 같은 &lt;code&gt;path&lt;/code&gt; 에서 호출 될 때까지 백그라운드에서 &lt;code&gt;path&lt;/code&gt; 에 대한 변경 사항을 계속 추적 합니다 .</target>
        </trans-unit>
        <trans-unit id="f13e78aea1113a7ecb31103654e0f08522f06f04" translate="yes" xml:space="preserve">
          <source>This will create a link in the generated docs to the &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt; documentation (which has more information about what this function actually does), and to the &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; documentation. It's good to include cross references to mutating/non-mutating versions of a function, or to highlight a difference between two similar-seeming functions.</source>
          <target state="translated">이렇게하면 생성 된 문서에 &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt; 문서 (이 기능이 실제로 수행하는 작업에 대한 자세한 정보가 있음) 및 &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; 문서에 대한 링크가 생성됩니다 . 함수의 돌연변이 / 비 돌연변이 버전에 대한 상호 참조를 포함 시키거나 두 개의 유사한 관찰 함수의 차이점을 강조하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c2a99e60f54b8d446ae19455b15a099ea1107a66" translate="yes" xml:space="preserve">
          <source>This will return &lt;code&gt;(-1, 0)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(-1, 0)&lt;/code&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="286660d1556fa7b595f130646ffbfab297bc669e" translate="yes" xml:space="preserve">
          <source>This will run afoul of a method that supplies default padding:</source>
          <target state="translated">기본 패딩을 제공하는 메소드를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="0f5b3315acf48556d7fa62b1bfb954506305c5d1" translate="yes" xml:space="preserve">
          <source>This will typically be the parent directory of &lt;code&gt;gitdir(repo)&lt;/code&gt;, but can be different in some cases: e.g. if either the &lt;code&gt;core.worktree&lt;/code&gt; configuration variable or the &lt;code&gt;GIT_WORK_TREE&lt;/code&gt; environment variable is set.</source>
          <target state="translated">이것은 일반적으로 &lt;code&gt;gitdir(repo)&lt;/code&gt; 의 상위 디렉토리 이지만 어떤 경우에는 다를 수 있습니다. 예를 들어 &lt;code&gt;core.worktree&lt;/code&gt; 구성 변수 또는 &lt;code&gt;GIT_WORK_TREE&lt;/code&gt; 환경 변수가 설정되어있는 경우.</target>
        </trans-unit>
        <trans-unit id="465cd08242692b4a225db05b65fef6a04fbb4c51" translate="yes" xml:space="preserve">
          <source>This works, but (as you can verify for yourself using &lt;code&gt;@code_warntype array3(5.0, 2)&lt;/code&gt;) the problem is that the output type cannot be inferred: the argument &lt;code&gt;N&lt;/code&gt; is a &lt;em&gt;value&lt;/em&gt; of type &lt;code&gt;Int&lt;/code&gt;, and type-inference does not (and cannot) predict its value in advance. This means that code using the output of this function has to be conservative, checking the type on each access of &lt;code&gt;A&lt;/code&gt;; such code will be very slow.</source>
          <target state="translated">이것은 작동하지만 ( &lt;code&gt;@code_warntype array3(5.0, 2)&lt;/code&gt; 사용하여 스스로 확인할 수 있음 ) 문제는 출력 유형을 유추 할 수 없다는 것입니다. 인수 &lt;code&gt;N&lt;/code&gt; 은 &lt;code&gt;Int&lt;/code&gt; 유형 의 &lt;em&gt;값&lt;/em&gt; 이며 유형 유추는 (및 그 가치를 미리 예측할 수는 없습니다. 이것은이 함수의 출력을 사용하는 코드는 보수적이어야하고 &lt;code&gt;A&lt;/code&gt; 의 각 액세스에 대한 유형을 확인해야 함을 의미합니다 . 이러한 코드는 매우 느립니다.</target>
        </trans-unit>
        <trans-unit id="91dccd376458eb0eba1948b74924d4cacdf4e65c" translate="yes" xml:space="preserve">
          <source>This would provide custom showing of vectors with a specific new element type. While tempting, this should be avoided. The trouble is that users will expect a well-known type like &lt;code&gt;Vector()&lt;/code&gt; to behave in a certain way, and overly customizing its behavior can make it harder to work with.</source>
          <target state="translated">이를 통해 특정 새로운 요소 유형의 벡터를 사용자 정의로 표시 할 수 있습니다. 유혹하는 동안 피해야합니다. 문제는 사용자가 &lt;code&gt;Vector()&lt;/code&gt; 와 같은 잘 알려진 유형 이 특정 방식으로 동작하기를 기대하며 , 동작을 과도하게 사용자 정의하면 작업하기가 더 어려워 질 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ad99bad1a037688795be38c39427fa0769348cbe" translate="yes" xml:space="preserve">
          <source>Though most code can be written in Julia, there are many high-quality, mature libraries for numerical computing already written in C and Fortran. To allow easy use of this existing code, Julia makes it simple and efficient to call C and Fortran functions. Julia has a &quot;no boilerplate&quot; philosophy: functions can be called directly from Julia without any &quot;glue&quot; code, code generation, or compilation &amp;ndash; even from the interactive prompt. This is accomplished just by making an appropriate call with &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; syntax, which looks like an ordinary function call.</source>
          <target state="translated">대부분의 코드는 Julia로 작성할 수 있지만 C와 Fortran으로 이미 작성된 수치 컴퓨팅을위한 고품질의 성숙 라이브러리가 많이 있습니다. 이 기존 코드를 쉽게 사용할 수 있도록 Julia는 C 및 Fortran 함수를 간단하고 효율적으로 호출 할 수 있도록합니다. Julia는 &quot;보일러 플레이트 없음&quot;철학을 가지고 있습니다. &quot;접착제&quot;코드, 코드 생성 또는 컴파일없이 대화 형 프롬프트에서도 함수를 Julia에서 직접 호출 할 수 있습니다. 이것은 일반적인 함수 호출처럼 보이는 &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 구문으로 적절한 호출을 수행함으로써 달성됩니다 .</target>
        </trans-unit>
        <trans-unit id="b1098d0533850d709c2eea0b6cccb4d789ad7a33" translate="yes" xml:space="preserve">
          <source>Thought Balloon</source>
          <target state="translated">생각 풍선</target>
        </trans-unit>
        <trans-unit id="e7d883028ca01a1fd0855b14863bfa7121240ec4" translate="yes" xml:space="preserve">
          <source>Thread-safety</source>
          <target state="translated">Thread-safety</target>
        </trans-unit>
        <trans-unit id="bb12e8aaaecc434fd51e448fe7669bced1bdd107" translate="yes" xml:space="preserve">
          <source>Threads</source>
          <target state="translated">Threads</target>
        </trans-unit>
        <trans-unit id="e419e1146ddb88bafc45f8ebac6b8292c4ced05a" translate="yes" xml:space="preserve">
          <source>Threads.@threads</source>
          <target state="translated">Threads.@threads</target>
        </trans-unit>
        <trans-unit id="af0966b4fd9f2b0cc49a7865b215af5194f37f0a" translate="yes" xml:space="preserve">
          <source>Threads.Atomic</source>
          <target state="translated">Threads.Atomic</target>
        </trans-unit>
        <trans-unit id="6d681958311270ce80eaf4515832385236fe2aa7" translate="yes" xml:space="preserve">
          <source>Threads.Condition</source>
          <target state="translated">Threads.Condition</target>
        </trans-unit>
        <trans-unit id="35d529a964d25f4e3aa6ca9d1ca0ce8f4be400d6" translate="yes" xml:space="preserve">
          <source>Threads.Mutex</source>
          <target state="translated">Threads.Mutex</target>
        </trans-unit>
        <trans-unit id="fdec23601f6d79aec8f6567bbffa2c92cd56f7b8" translate="yes" xml:space="preserve">
          <source>Threads.SpinLock</source>
          <target state="translated">Threads.SpinLock</target>
        </trans-unit>
        <trans-unit id="dc252ab69b1ee919bcf5db69994a187e411ca970" translate="yes" xml:space="preserve">
          <source>Threads.atomic_add!()</source>
          <target state="translated">Threads.atomic_add!()</target>
        </trans-unit>
        <trans-unit id="0d6bade715cafd9dcdad87d2c22d90bbfc1e9bc3" translate="yes" xml:space="preserve">
          <source>Threads.atomic_and!()</source>
          <target state="translated">Threads.atomic_and!()</target>
        </trans-unit>
        <trans-unit id="fc348be87bc254a3559139ac661b72946bb39a71" translate="yes" xml:space="preserve">
          <source>Threads.atomic_cas!()</source>
          <target state="translated">Threads.atomic_cas!()</target>
        </trans-unit>
        <trans-unit id="f62c63142218283b0037fda6af5f0f3a02c2975f" translate="yes" xml:space="preserve">
          <source>Threads.atomic_fence()</source>
          <target state="translated">Threads.atomic_fence()</target>
        </trans-unit>
        <trans-unit id="4bb65236b89d5d31da9f4d8820a38668a9dbf21c" translate="yes" xml:space="preserve">
          <source>Threads.atomic_max!()</source>
          <target state="translated">Threads.atomic_max!()</target>
        </trans-unit>
        <trans-unit id="8833f2d74d5a7e5aa857580591ba695e2d6fc9b4" translate="yes" xml:space="preserve">
          <source>Threads.atomic_min!()</source>
          <target state="translated">Threads.atomic_min!()</target>
        </trans-unit>
        <trans-unit id="9d6eae92e1cf6253daf74605c345f63d354fc4f7" translate="yes" xml:space="preserve">
          <source>Threads.atomic_nand!()</source>
          <target state="translated">Threads.atomic_nand!()</target>
        </trans-unit>
        <trans-unit id="560bfbccb3de090b47f2c10c244f66c66c580494" translate="yes" xml:space="preserve">
          <source>Threads.atomic_or!()</source>
          <target state="translated">Threads.atomic_or!()</target>
        </trans-unit>
        <trans-unit id="f3e1cd9ba44ee30e82bb0904faa52cbf59c0038d" translate="yes" xml:space="preserve">
          <source>Threads.atomic_sub!()</source>
          <target state="translated">Threads.atomic_sub!()</target>
        </trans-unit>
        <trans-unit id="13028b27bde6678508d39212264589ec6a15feea" translate="yes" xml:space="preserve">
          <source>Threads.atomic_xchg!()</source>
          <target state="translated">Threads.atomic_xchg!()</target>
        </trans-unit>
        <trans-unit id="733c9373c4a5344eab540082f44fb3d0c9691c39" translate="yes" xml:space="preserve">
          <source>Threads.atomic_xor!()</source>
          <target state="translated">Threads.atomic_xor!()</target>
        </trans-unit>
        <trans-unit id="be840129016948f129890bec761377fa710398c9" translate="yes" xml:space="preserve">
          <source>Threads.nthreads()</source>
          <target state="translated">Threads.nthreads()</target>
        </trans-unit>
        <trans-unit id="a889ac57822379f233ec938a1f7a38f70d5c6296" translate="yes" xml:space="preserve">
          <source>Threads.threadid()</source>
          <target state="translated">Threads.threadid()</target>
        </trans-unit>
        <trans-unit id="0aad1c36c5f4e6d7170e1c4b0293604b8b212cfa" translate="yes" xml:space="preserve">
          <source>Three Consecutive Equals Signs</source>
          <target state="translated">3 개의 연속 된 표시</target>
        </trans-unit>
        <trans-unit id="275c8d26b15f014b3ee22a364da92aa616ab6c12" translate="yes" xml:space="preserve">
          <source>Three Dimensional Angle</source>
          <target state="translated">3 차원 각도</target>
        </trans-unit>
        <trans-unit id="34c44d666ec4b94d3bbda9f288521e6aef7e833a" translate="yes" xml:space="preserve">
          <source>Three Leftwards Arrows</source>
          <target state="translated">3 개의 왼쪽 화살표</target>
        </trans-unit>
        <trans-unit id="6845b5c6dca3f04d0fc4092b2f6f1fa8ad41c493" translate="yes" xml:space="preserve">
          <source>Three Rightwards Arrows</source>
          <target state="translated">오른쪽 화살표 3 개</target>
        </trans-unit>
        <trans-unit id="649300e311dc9e0d97883f25214a816938115a07" translate="yes" xml:space="preserve">
          <source>Throw a &lt;a href=&quot;#Core.TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; unless &lt;code&gt;x isa type&lt;/code&gt;. The syntax &lt;code&gt;x::type&lt;/code&gt; calls this function.</source>
          <target state="translated">&lt;code&gt;x isa type&lt;/code&gt; 이 아닌 한 &lt;a href=&quot;#Core.TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다. 구문 &lt;code&gt;x::type&lt;/code&gt; 은이 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="714760623b81eda189caf56e00d3dd66b2ad778d" translate="yes" xml:space="preserve">
          <source>Throw an &lt;a href=&quot;#Core.AssertionError&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;cond&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. Preferred syntax for writing assertions. Message &lt;code&gt;text&lt;/code&gt; is optionally displayed upon assertion failure.</source>
          <target state="translated">던져 &lt;a href=&quot;#Core.AssertionError&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; 하는 경우 &lt;code&gt;cond&lt;/code&gt; 있다 &lt;code&gt;false&lt;/code&gt; . 어설 션 작성을위한 기본 구문 어설 션 실패시 메시지 &lt;code&gt;text&lt;/code&gt; 가 선택적으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="fde334b7c50e867ec42457ab4cfac34135b82f0a" translate="yes" xml:space="preserve">
          <source>Throw an error if the specified indices &lt;code&gt;I&lt;/code&gt; are not in bounds for the given array &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">지정된 인덱스 &lt;code&gt;I&lt;/code&gt; 이 지정된 배열 &lt;code&gt;A&lt;/code&gt; 의 범위에 속하지 않으면 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="7f0af829c424acf2aaed30a43af670830af1bf4e" translate="yes" xml:space="preserve">
          <source>Throw an object as an exception.</source>
          <target state="translated">예외로 객체를 던지십시오.</target>
        </trans-unit>
        <trans-unit id="140ef8a807386c342270a60ed53ce02c73c18d34" translate="yes" xml:space="preserve">
          <source>Throw an object without changing the current exception backtrace. The default argument is the current exception (if called within a &lt;code&gt;catch&lt;/code&gt; block).</source>
          <target state="translated">현재 예외 역 추적을 변경하지 않고 객체를 던집니다. 기본 인수는 현재 예외입니다 ( &lt;code&gt;catch&lt;/code&gt; 블록 내에서 호출 된 경우 ).</target>
        </trans-unit>
        <trans-unit id="580dadd5162b2d0824b14a53a53520885f69bb7a" translate="yes" xml:space="preserve">
          <source>Throwing Julia Exceptions</source>
          <target state="translated">줄리아 예외 던지기</target>
        </trans-unit>
        <trans-unit id="b55eb9740df570160a4568c629959c237f6eace8" translate="yes" xml:space="preserve">
          <source>Thumbs Down Sign</source>
          <target state="translated">거절 기호</target>
        </trans-unit>
        <trans-unit id="605c4f2d25dae572dac0bd7100ede0e91ce19009" translate="yes" xml:space="preserve">
          <source>Thumbs Up Sign</source>
          <target state="translated">엄지 손가락 가입</target>
        </trans-unit>
        <trans-unit id="760c9c88e6ab4015bdda89ce2b03fc29323c09ed" translate="yes" xml:space="preserve">
          <source>Thus &lt;em&gt;lexical scope&lt;/em&gt; means that the scope of variables can be inferred from the source code alone.</source>
          <target state="translated">따라서 &lt;em&gt;어휘 범위&lt;/em&gt; 는 변수의 범위가 소스 코드에서만 유추 될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3c1904bf1147b9a9b4718a957b259ff3b20ed4ec" translate="yes" xml:space="preserve">
          <source>Thus global variables are only inherited for reading, not for writing:</source>
          <target state="translated">따라서 전역 변수는 쓰기가 아닌 읽기 전용으로 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="37807420ee61e708d970e7d90819e0a642c8a0c3" translate="yes" xml:space="preserve">
          <source>Thus programs should be careful referencing globals in remote calls. In fact, it is preferable to avoid them altogether if possible. If you must reference globals, consider using &lt;code&gt;let&lt;/code&gt; blocks to localize global variables.</source>
          <target state="translated">따라서 프로그램은 원격 호출에서 전역을 참조 할 때주의해야합니다. 실제로 가능하면 모두 피하는 것이 좋습니다. 전역을 참조해야하는 경우 &lt;code&gt;let&lt;/code&gt; 블록을 사용하여 전역 변수를 지역화하십시오.</target>
        </trans-unit>
        <trans-unit id="1ec3104629ec61f45eec6025fd4920b5b97b82ff" translate="yes" xml:space="preserve">
          <source>Thus, a minimal cluster manager would need to:</source>
          <target state="translated">따라서 최소 클러스터 관리자는 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="7b4c9299e93152df59eb2d7a356e597a287f7f91" translate="yes" xml:space="preserve">
          <source>Thus, a task executing a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; effectively prevents the Julia scheduler from executing any other tasks till the call returns. This is true for all calls into external libraries. Exceptions are calls into custom C code that call back into Julia (which may then yield) or C code that calls &lt;code&gt;jl_yield()&lt;/code&gt; (C equivalent of &lt;a href=&quot;../../base/parallel/index#Base.yield&quot;&gt;&lt;code&gt;yield&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">따라서, 실행하는 작업 &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; 은&lt;/a&gt; 효과적으로 호출이 반환 될 때까지 다른 작업을 실행에서 줄리아 스케줄러를 방지 할 수 있습니다. 이것은 외부 라이브러리에 대한 모든 호출에 적용됩니다. 예외는 Julia를 호출하는 커스텀 C 코드 (이후 생성 될 수 있음) 또는 &lt;code&gt;jl_yield()&lt;/code&gt; (C &lt;a href=&quot;../../base/parallel/index#Base.yield&quot;&gt; &lt;code&gt;yield&lt;/code&gt; &lt;/a&gt; ) 를 호출하는 C 코드는 예외 입니다.</target>
        </trans-unit>
        <trans-unit id="12a48793aeeeb710ac9dcc9260ed6b02480a02b9" translate="yes" xml:space="preserve">
          <source>Thus, abstract types allow programmers to write generic functions that can later be used as the default method by many combinations of concrete types. Thanks to multiple dispatch, the programmer has full control over whether the default or more specific method is used.</source>
          <target state="translated">따라서 추상 유형을 사용하면 프로그래머가 콘크리트 유형의 여러 조합으로 나중에 기본 방법으로 사용할 수있는 일반 함수를 작성할 수 있습니다. 다중 디스패치 덕분에 프로그래머는 기본 또는보다 구체적인 방법의 사용 여부를 완전히 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f601caf538448fdd3302f7c350467ef72143226f" translate="yes" xml:space="preserve">
          <source>Thus, although the &lt;code&gt;⊘&lt;/code&gt; operator usually returns an instance of &lt;code&gt;OurRational&lt;/code&gt;, if either of its arguments are complex integers, it will return an instance of &lt;code&gt;Complex{OurRational}&lt;/code&gt; instead. The interested reader should consider perusing the rest of &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/rational.jl&quot;&gt;&lt;code&gt;rational.jl&lt;/code&gt;&lt;/a&gt;: it is short, self-contained, and implements an entire basic Julia type.</source>
          <target state="translated">따라서 &lt;code&gt;⊘&lt;/code&gt; 연산자는 일반적으로 &lt;code&gt;OurRational&lt;/code&gt; 의 인스턴스를 반환 하지만 인수 중 하나가 복합 정수이면 &lt;code&gt;Complex{OurRational}&lt;/code&gt; 의 인스턴스를 대신 반환합니다 . 관심있는 독자는 나머지 &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/rational.jl&quot;&gt; &lt;code&gt;rational.jl&lt;/code&gt; 을&lt;/a&gt; 숙고하는 것이 좋습니다 . 짧고 독립적이며 전체 기본 Julia 유형을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="626f028f772316f29a1f3bc180af9b3cc6e9feec" translate="yes" xml:space="preserve">
          <source>Thus, arithmetic with Julia integers is actually a form of &lt;a href=&quot;https://en.wikipedia.org/wiki/Modular_arithmetic&quot;&gt;modular arithmetic&lt;/a&gt;. This reflects the characteristics of the underlying arithmetic of integers as implemented on modern computers. In applications where overflow is possible, explicit checking for wraparound produced by overflow is essential; otherwise, the &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; type in &lt;a href=&quot;#Arbitrary-Precision-Arithmetic-1&quot;&gt;Arbitrary Precision Arithmetic&lt;/a&gt; is recommended instead.</source>
          <target state="translated">따라서 Julia 정수를 사용한 산술은 실제로 &lt;a href=&quot;https://en.wikipedia.org/wiki/Modular_arithmetic&quot;&gt;모듈 식 산술의&lt;/a&gt; 한 형태입니다 . 이것은 현대 컴퓨터에서 구현되는 정수의 기본 산술 특성을 반영합니다. 오버플로가 가능한 응용 프로그램에서는 오버플로로 생성 된 랩 어라운드에 대한 명시적인 검사가 필수적입니다. 그렇지 않으면, &lt;a href=&quot;#Arbitrary-Precision-Arithmetic-1&quot;&gt;임의 정밀도 산술&lt;/a&gt; 의 &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; 유형 이 대신 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="b2b83f1b321c20d701d32773b7f124c10518c979" translate="yes" xml:space="preserve">
          <source>Thus, the parser does not know that &lt;code&gt;r&lt;/code&gt; has a fixed type (&lt;code&gt;Int&lt;/code&gt;). nor that &lt;code&gt;r&lt;/code&gt; does not change value once the inner function is created (so that the box is unneeded). Therefore, the parser emits code for box that holds an object with an abstract type such as &lt;code&gt;Any&lt;/code&gt;, which requires run-time type dispatch for each occurrence of &lt;code&gt;r&lt;/code&gt;. This can be verified by applying &lt;code&gt;@code_warntype&lt;/code&gt; to the above function. Both the boxing and the run-time type dispatch can cause loss of performance.</source>
          <target state="translated">따라서 파서는 &lt;code&gt;r&lt;/code&gt; 이 고정 된 유형 ( &lt;code&gt;Int&lt;/code&gt; )을 가지고 있다는 것을 알지 못합니다 . 도 그 &lt;code&gt;r&lt;/code&gt; 내부 함수가 생성되면 (박스 불필요한이다 그래서) 값을 변경하지 않는다. 따라서 파서는 &lt;code&gt;Any&lt;/code&gt; 와 같은 추상 유형의 객체를 보유하는 box에 대한 코드를 생성 하는데, &lt;code&gt;r&lt;/code&gt; 의 각 발생에 대해 런타임 유형 디스패치가 필요합니다 . 위 함수에 &lt;code&gt;@code_warntype&lt;/code&gt; 을 적용하여 확인할 수 있습니다 . 복싱 및 런타임 유형 디스패치 모두 성능 손실을 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="405f79bc0440035cdbe7cdfa2f5f8191b1e769bd" translate="yes" xml:space="preserve">
          <source>Thus, use &lt;code&gt;Int&lt;/code&gt; literals when possible, with &lt;code&gt;Rational{Int}&lt;/code&gt; for literal non-integer numbers, in order to make it easier to use your code.</source>
          <target state="translated">따라서 코드를보다 쉽게 ​​사용할 수 있도록 가능하면 정수가 아닌 리터럴에 &lt;code&gt;Rational{Int}&lt;/code&gt; 과 함께 &lt;code&gt;Int&lt;/code&gt; 리터럴 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7dfa2079791005dea78a84f2b9726b0bdb6de3e2" translate="yes" xml:space="preserve">
          <source>Thus, while the implicit type parameter constructors provided by default in Julia are fairly strict, it is possible to make them behave in a more relaxed but sensible manner quite easily. Moreover, since constructors can leverage all of the power of the type system, methods, and multiple dispatch, defining sophisticated behavior is typically quite simple.</source>
          <target state="translated">따라서 Julia에서 기본적으로 제공되는 암시 적 유형 매개 변수 생성자는 상당히 엄격하지만보다 편안하지만 합리적인 방식으로 쉽게 작동 할 수 있습니다. 또한 생성자는 형식 시스템, 메서드 및 다중 디스패치의 모든 기능을 활용할 수 있으므로 정교한 동작을 정의하는 것은 일반적으로 매우 간단합니다.</target>
        </trans-unit>
        <trans-unit id="a7677e84b6660292620566337bcfc94144911cc7" translate="yes" xml:space="preserve">
          <source>Ticket</source>
          <target state="translated">Ticket</target>
        </trans-unit>
        <trans-unit id="dd697aa8cce5c810f10070878f9d6f89c5a5937c" translate="yes" xml:space="preserve">
          <source>Tiger</source>
          <target state="translated">Tiger</target>
        </trans-unit>
        <trans-unit id="abee288b1344129c8247490b49084155f62a8492" translate="yes" xml:space="preserve">
          <source>Tiger Face</source>
          <target state="translated">호랑이 얼굴</target>
        </trans-unit>
        <trans-unit id="a213b01ff977ddc2b77a2851775a17888cf936a4" translate="yes" xml:space="preserve">
          <source>Tilde Operator</source>
          <target state="translated">틸드 연산자</target>
        </trans-unit>
        <trans-unit id="81f0f8e7286707e1e34046d94807c0c638e949b0" translate="yes" xml:space="preserve">
          <source>Tilde Operator Above Leftwards Arrow</source>
          <target state="translated">왼쪽 화살표 위의 틸드 연산자</target>
        </trans-unit>
        <trans-unit id="248cc81b5c32172ec329e2bbdd1480c988bb3388" translate="yes" xml:space="preserve">
          <source>Tilde Operator With Dot Above</source>
          <target state="translated">위의 점이있는 틸드 연산자</target>
        </trans-unit>
        <trans-unit id="6835d0448d1238ede880e3906c4de76444a3efae" translate="yes" xml:space="preserve">
          <source>Tilde Operator With Rising Dots</source>
          <target state="translated">상승하는 점이있는 틸드 연산자</target>
        </trans-unit>
        <trans-unit id="358886c6ac36a9af9f2410bb87185645588db7c9" translate="yes" xml:space="preserve">
          <source>Time in a signature. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_time&quot;&gt;&lt;code&gt;git_time&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">서명 시간. &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_time&quot;&gt; &lt;code&gt;git_time&lt;/code&gt; &lt;/a&gt; 구조체와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="a1aef662800be3b19d04a84bdbd802cb869572bc" translate="yes" xml:space="preserve">
          <source>TimeType-Period Arithmetic</source>
          <target state="translated">시간 유형 기간 산술</target>
        </trans-unit>
        <trans-unit id="9d9cec22f36fd2bb99d5fe8c4723347bec202ca5" translate="yes" xml:space="preserve">
          <source>Timer</source>
          <target state="translated">Timer</target>
        </trans-unit>
        <trans-unit id="e524304a680bc45ab65762e1df41198ad5434553" translate="yes" xml:space="preserve">
          <source>Timer()</source>
          <target state="translated">Timer()</target>
        </trans-unit>
        <trans-unit id="4e252bb0e117c9cedaeca8da5f4796af646d44a9" translate="yes" xml:space="preserve">
          <source>Timing results:</source>
          <target state="translated">타이밍 결과 :</target>
        </trans-unit>
        <trans-unit id="d19ceca501465c339e3bcf2bc0d8ff02bb697d6c" translate="yes" xml:space="preserve">
          <source>Tip</source>
          <target state="translated">Tip</target>
        </trans-unit>
        <trans-unit id="0d5993668385f8eefae208c8f706f8bc977fc760" translate="yes" xml:space="preserve">
          <source>Tired Face</source>
          <target state="translated">피곤한 얼굴</target>
        </trans-unit>
        <trans-unit id="d8411edb15bb7d4ab010f7414d30f893e168d44a" translate="yes" xml:space="preserve">
          <source>To access the raw code units (bytes for UTF-8) of the encoding, you can use the &lt;a href=&quot;../../base/strings/index#Base.codeunit&quot;&gt;&lt;code&gt;codeunit(s,i)&lt;/code&gt;&lt;/a&gt; function, where the index &lt;code&gt;i&lt;/code&gt; runs consecutively from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;ncodeunits(s)&lt;/code&gt;. The &lt;a href=&quot;../../base/strings/index#Base.codeunits&quot;&gt;&lt;code&gt;codeunits(s)&lt;/code&gt;&lt;/a&gt; function returns an &lt;code&gt;AbstractVector{UInt8}&lt;/code&gt; wrapper that lets you access these raw codeunits (bytes) as an array.</source>
          <target state="translated">인코딩의 원시 코드 단위 (UTF-8의 바이트)에 액세스하려면 &lt;a href=&quot;../../base/strings/index#Base.codeunit&quot;&gt; &lt;code&gt;codeunit(s,i)&lt;/code&gt; &lt;/a&gt; 함수를 사용하면 인덱스 &lt;code&gt;i&lt;/code&gt; 가 &lt;code&gt;1&lt;/code&gt; 에서 &lt;code&gt;ncodeunits(s)&lt;/code&gt; 까지 연속적으로 실행됩니다 . &lt;a href=&quot;../../base/strings/index#Base.codeunits&quot;&gt; &lt;code&gt;codeunits(s)&lt;/code&gt; &lt;/a&gt; 기능을 다시 표시 &lt;code&gt;AbstractVector{UInt8}&lt;/code&gt; 당신이 배열로 이러한 원시 codeunits (바이트)에 액세스 할 수 있습니다 래퍼.</target>
        </trans-unit>
        <trans-unit id="e95b1141b5118da7c6df142a7dc74b9f038403fe" translate="yes" xml:space="preserve">
          <source>To add a package, use &lt;code&gt;add&lt;/code&gt;:</source>
          <target state="translated">패키지를 추가하려면 add를 사용 &lt;code&gt;add&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="80d353ae44a58cccba974a5708143d72c88b86a0" translate="yes" xml:space="preserve">
          <source>To allow computations with arbitrary-precision integers and floating point numbers, Julia wraps the &lt;a href=&quot;https://gmplib.org&quot;&gt;GNU Multiple Precision Arithmetic Library (GMP)&lt;/a&gt; and the &lt;a href=&quot;https://www.mpfr.org&quot;&gt;GNU MPFR Library&lt;/a&gt;, respectively. The &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; types are available in Julia for arbitrary precision integer and floating point numbers respectively.</source>
          <target state="translated">Julia는 임의 정밀도 정수 및 부동 소수점 숫자로 계산할 수 있도록 &lt;a href=&quot;https://gmplib.org&quot;&gt;GNU GMP (Multiple Precision Arithmetic Library)&lt;/a&gt; 및 &lt;a href=&quot;https://www.mpfr.org&quot;&gt;GNU MPFR 라이브러리&lt;/a&gt; 를 각각 랩핑 합니다. &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt; 유형은 임의 정밀도의 정수 각각 부동 소수점 숫자의 줄리아에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f92958b0eb5e7d500f4fc83e966e176ae982e7c8" translate="yes" xml:space="preserve">
          <source>To allow for the creation of incompletely initialized objects, Julia allows the &lt;a href=&quot;../../base/base/index#new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; function to be called with fewer than the number of fields that the type has, returning an object with the unspecified fields uninitialized. The inner constructor method can then use the incomplete object, finishing its initialization before returning it. Here, for example, is another attempt at defining the &lt;code&gt;SelfReferential&lt;/code&gt; type, this time using a zero-argument inner constructor returning instances having &lt;code&gt;obj&lt;/code&gt; fields pointing to themselves:</source>
          <target state="translated">불완전하게 초기화 된 객체를 생성 할 수 있도록 Julia는 유형에있는 필드 수보다 적은 수로 &lt;a href=&quot;../../base/base/index#new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 함수를 호출하여 지정되지 않은 필드가 초기화되지 않은 객체를 반환합니다. 그런 다음 내부 생성자 메서드는 불완전한 개체를 사용하여 반환하기 전에 초기화를 완료 할 수 있습니다. 예를 들어, &lt;code&gt;SelfReferential&lt;/code&gt; 유형 을 정의하려는 또 다른 시도는 이번에는 제로 인수 내부 생성자를 사용하여 &lt;code&gt;obj&lt;/code&gt; 필드가 자신을 가리키는 인스턴스를 반환 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="647cb570f3aba993aaa46d9c3e91117ed01a95c0" translate="yes" xml:space="preserve">
          <source>To amplify a bit further, consider the following function:</source>
          <target state="translated">조금 더 증폭하려면 다음 기능을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="7e940b0d75467f1279dc9099ee9a7a7226dd9aa5" translate="yes" xml:space="preserve">
          <source>To avoid even having to define a named function, you can use the &lt;code&gt;do&lt;/code&gt; syntax, which creates an anonymous function on the fly:</source>
          <target state="translated">명명 된 함수를 정의하지 않아도하기 위해 &lt;code&gt;do&lt;/code&gt; 구문을 사용하면 익명 함수가 즉시 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="50dc537d704eaca673949b4e42b6c53501bae68d" translate="yes" xml:space="preserve">
          <source>To check if a regex matches a string, use &lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt;&lt;code&gt;occursin&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">정규식이 문자열과 일치하는지 확인하려면 다음을 사용 &lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt; &lt;code&gt;occursin&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eed84206f52f8f65140a28df43e2ff030f4f3a51" translate="yes" xml:space="preserve">
          <source>To concatenate in the first (&quot;vertical&quot;) dimension use either &lt;a href=&quot;../../base/arrays/index#Base.vcat&quot;&gt;&lt;code&gt;vcat(x,y,z)&lt;/code&gt;&lt;/a&gt; or separate with semicolons (&lt;code&gt;[x; y; z]&lt;/code&gt;).</source>
          <target state="translated">첫 번째 ( &quot;세로&quot;) 차원에서 연결하려면 &lt;a href=&quot;../../base/arrays/index#Base.vcat&quot;&gt; &lt;code&gt;vcat(x,y,z)&lt;/code&gt; &lt;/a&gt; 하거나 세미콜론 ( &lt;code&gt;[x; y; z]&lt;/code&gt; ) 으로 구분하십시오 .</target>
        </trans-unit>
        <trans-unit id="836f5fac5628ace8eede45159f560aedbc2e431e" translate="yes" xml:space="preserve">
          <source>To concatenate in the second (&quot;horizontal&quot;) dimension use either &lt;a href=&quot;../../base/arrays/index#Base.hcat&quot;&gt;&lt;code&gt;hcat(x,y,z)&lt;/code&gt;&lt;/a&gt; or separate with spaces (&lt;code&gt;[x y z]&lt;/code&gt;).</source>
          <target state="translated">두 번째 ( &quot;수평&quot;) 차원에서 연결하려면 &lt;a href=&quot;../../base/arrays/index#Base.hcat&quot;&gt; &lt;code&gt;hcat(x,y,z)&lt;/code&gt; &lt;/a&gt; 하거나 공백 ( &lt;code&gt;[x y z]&lt;/code&gt; )으로 구분하십시오.</target>
        </trans-unit>
        <trans-unit id="c1db2888c6f2a52fec0ea3a56df9e7e662b6768f" translate="yes" xml:space="preserve">
          <source>To construct block matrices (concatenating in the first two dimensions), use either &lt;a href=&quot;../../base/arrays/index#Base.hvcat&quot;&gt;&lt;code&gt;hvcat&lt;/code&gt;&lt;/a&gt; or combine spaces and semicolons (&lt;code&gt;[a b; c d]&lt;/code&gt;).</source>
          <target state="translated">블록 행렬을 구성하려면 (처음 두 차원으로 연결) &lt;a href=&quot;../../base/arrays/index#Base.hvcat&quot;&gt; &lt;code&gt;hvcat&lt;/code&gt; 을&lt;/a&gt; 사용하거나 공백과 세미콜론을 결합하십시오 ( &lt;code&gt;[a b; c d]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a141c1fb8d334654feff124c660c2fb4df2cb73d" translate="yes" xml:space="preserve">
          <source>To define a function with multiple methods, one simply defines the function multiple times, with different numbers and types of arguments. The first method definition for a function creates the function object, and subsequent method definitions add new methods to the existing function object. The most specific method definition matching the number and types of the arguments will be executed when the function is applied. Thus, the two method definitions above, taken together, define the behavior for &lt;code&gt;f&lt;/code&gt; over all pairs of instances of the abstract type &lt;code&gt;Number&lt;/code&gt; &amp;ndash; but with a different behavior specific to pairs of &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; values. If one of the arguments is a 64-bit float but the other one is not, then the &lt;code&gt;f(Float64,Float64)&lt;/code&gt; method cannot be called and the more general &lt;code&gt;f(Number,Number)&lt;/code&gt; method must be used:</source>
          <target state="translated">여러 메소드를 사용하여 함수를 정의하려면 다른 숫자와 유형의 인수를 사용하여 함수를 여러 번 정의하면됩니다. 함수의 첫 번째 메소드 정의는 함수 오브젝트를 작성하고 후속 메소드 정의는 기존 함수 오브젝트에 새 메소드를 추가합니다. 인수의 수 및 유형과 일치하는 가장 구체적인 메소드 정의는 함수가 적용될 때 실행됩니다. 따라서, 위의 두 가지 메소드 정의 는 추상 유형 &lt;code&gt;Number&lt;/code&gt; 의 모든 인스턴스 쌍 에서 &lt;code&gt;f&lt;/code&gt; 에 대한 동작을 정의 하지만 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; 값 쌍에 대해 다른 동작을 정의 합니다. 인수 중 하나가 64 비트 부동 소수점이지만 다른 인수가 아닌 경우 &lt;code&gt;f(Float64,Float64)&lt;/code&gt; 메소드를 호출 할 수 없으며보다 일반적인 &lt;code&gt;f(Number,Number)&lt;/code&gt; 메소드를 사용해야합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
