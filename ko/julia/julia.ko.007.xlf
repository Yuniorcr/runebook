<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="9cf1660ad8de659f871c4cde9fc066e87eb4f30f" translate="yes" xml:space="preserve">
          <source>For an iterator or collection that has keys and values, return an iterator over the values. This function simply returns its argument by default, since the elements of a general iterator are normally considered its &quot;values&quot;.</source>
          <target state="translated">키와 값이있는 반복자 또는 컬렉션의 경우 값 위에 반복자를 반환합니다. 일반 반복자의 요소는 일반적으로 &quot;값&quot;으로 간주되므로이 함수는 기본적으로 인수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="95a50cf1c996d77537f503b2b0ab2ae143d3ab0c" translate="yes" xml:space="preserve">
          <source>For an out-of-place version, see &lt;a href=&quot;#SparseArrays.dropzeros&quot;&gt;&lt;code&gt;dropzeros&lt;/code&gt;&lt;/a&gt;. For algorithmic information, see &lt;code&gt;fkeep!&lt;/code&gt;.</source>
          <target state="translated">외부 버전은 &lt;a href=&quot;#SparseArrays.dropzeros&quot;&gt; &lt;code&gt;dropzeros&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 . 알고리즘 정보는 &lt;code&gt;fkeep!&lt;/code&gt; 참조하십시오 ! .</target>
        </trans-unit>
        <trans-unit id="d9698467f9f9a26107005e5cc7d8c52ec73e6fba" translate="yes" xml:space="preserve">
          <source>For an overview of why functions like &lt;a href=&quot;../../base/math/index#Base.Math.hypot&quot;&gt;&lt;code&gt;hypot&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/math/index#Base.expm1&quot;&gt;&lt;code&gt;expm1&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/math/index#Base.log1p&quot;&gt;&lt;code&gt;log1p&lt;/code&gt;&lt;/a&gt; are necessary and useful, see John D. Cook's excellent pair of blog posts on the subject: &lt;a href=&quot;https://www.johndcook.com/blog/2010/06/07/math-library-functions-that-seem-unnecessary/&quot;&gt;expm1, log1p, erfc&lt;/a&gt;, and &lt;a href=&quot;https://www.johndcook.com/blog/2010/06/02/whats-so-hard-about-finding-a-hypotenuse/&quot;&gt;hypot&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../base/math/index#Base.Math.hypot&quot;&gt; &lt;code&gt;hypot&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/math/index#Base.expm1&quot;&gt; &lt;code&gt;expm1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/math/index#Base.log1p&quot;&gt; &lt;code&gt;log1p&lt;/code&gt; &lt;/a&gt; 와 같은 기능 이 필요하고 유용한 이유에 대한 개요 는 주제에 대한 John D. Cook의 탁월한 블로그 게시물 쌍인 &lt;a href=&quot;https://www.johndcook.com/blog/2010/06/07/math-library-functions-that-seem-unnecessary/&quot;&gt;expm1, log1p, erfc&lt;/a&gt; 및 &lt;a href=&quot;https://www.johndcook.com/blog/2010/06/02/whats-so-hard-about-finding-a-hypotenuse/&quot;&gt;hypot를 참조하십시오.&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7d80c08b4c206c014a1c8f4dd0759aa7c625fa2a" translate="yes" xml:space="preserve">
          <source>For any iterable container &lt;code&gt;A&lt;/code&gt; (including arrays of any dimension) of numbers (or any element type for which &lt;code&gt;norm&lt;/code&gt; is defined), compute the &lt;code&gt;p&lt;/code&gt;-norm (defaulting to &lt;code&gt;p=2&lt;/code&gt;) as if &lt;code&gt;A&lt;/code&gt; were a vector of the corresponding length.</source>
          <target state="translated">반복 가능한 컨테이너 &lt;code&gt;A&lt;/code&gt; (모든 차원의 배열 포함)의 숫자 (또는 &lt;code&gt;norm&lt;/code&gt; 이 정의 된 요소 유형 )의 경우, &lt;code&gt;A&lt;/code&gt; 가 해당 길이의 벡터 인 것처럼 &lt;code&gt;p&lt;/code&gt; -norm (기본값은 &lt;code&gt;p=2&lt;/code&gt; ) 을 계산하십시오 .</target>
        </trans-unit>
        <trans-unit id="a3a03065c6c3f77db333198b92d9783df8912cc7" translate="yes" xml:space="preserve">
          <source>For any iterable containers &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; (including arrays of any dimension) of numbers (or any element type for which &lt;code&gt;dot&lt;/code&gt; is defined), compute the dot product (or inner product or scalar product), i.e. the sum of &lt;code&gt;dot(x[i],y[i])&lt;/code&gt;, as if they were vectors.</source>
          <target state="translated">반복 가능한 컨테이너 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; (모든 차원의 배열 포함)의 숫자 (또는 &lt;code&gt;dot&lt;/code&gt; 정의 된 모든 요소 유형 )의 경우 내적 (또는 내적 또는 스칼라 곱), 즉 &lt;code&gt;dot(x[i],y[i])&lt;/code&gt; , 마치 벡터 인 것처럼.</target>
        </trans-unit>
        <trans-unit id="9861c33db5cb32a638bd7ed95113f331a3454eb4" translate="yes" xml:space="preserve">
          <source>For any keywords that are not specified, the current settings from &lt;code&gt;cmd&lt;/code&gt; are used. Normally, to create a &lt;code&gt;Cmd&lt;/code&gt; object in the first place, one uses backticks, e.g.</source>
          <target state="translated">지정되지 않은 키워드의 경우 &lt;code&gt;cmd&lt;/code&gt; 의 현재 설정 이 사용됩니다. 일반적으로 &lt;code&gt;Cmd&lt;/code&gt; 객체를 처음에 만들려면 백틱을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="85d14ad6a0f26364153773489f0db13bfaafa53f" translate="yes" xml:space="preserve">
          <source>For arrays with conventional indexing (indices start at 1), or any multidimensional array, linear indices range from 1 to &lt;code&gt;length(A)&lt;/code&gt;. However, for &lt;code&gt;AbstractVector&lt;/code&gt;s linear indices are &lt;code&gt;axes(A, 1)&lt;/code&gt;, and therefore do not start at 1 for vectors with unconventional indexing.</source>
          <target state="translated">일반적인 색인 (1부터 시작) 또는 다차원 배열을 갖는 배열의 경우 선형 인덱스의 범위는 1에서 &lt;code&gt;length(A)&lt;/code&gt; 입니다. 그러나 &lt;code&gt;AbstractVector&lt;/code&gt; 의 선형 인덱스는 &lt;code&gt;axes(A, 1)&lt;/code&gt; 이므로 비 전통적인 색인이있는 벡터의 경우 1부터 시작하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="81f6c2e801b1d9455cd3aa8ac3e88e840497dca8" translate="yes" xml:space="preserve">
          <source>For arrays, returns a string of size and type info, e.g. &lt;code&gt;10-element Array{Int64,1}&lt;/code&gt;.</source>
          <target state="translated">배열의 경우 크기 및 유형 정보의 문자열 (예 : &lt;code&gt;10-element Array{Int64,1}&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="06562c8550b5e93a013f75fd29118d4c0694a02a" translate="yes" xml:space="preserve">
          <source>For arrays, this function requires at least Julia 1.2.</source>
          <target state="translated">배열의 경우이 함수에는 Julia 1.2 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d3e36f74f84aea73dce8e8117a1733e018408eb9" translate="yes" xml:space="preserve">
          <source>For bits types this means that the bit pattern of a value once set will never change and that value is the identity of a bits type.</source>
          <target state="translated">비트 유형의 경우 이는 한 번 설정된 값의 비트 패턴이 변경되지 않으며 해당 값은 비트 유형의 ID라는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7aee08c8ffda1f859a18b6cbf5bd4f3be6da6c3e" translate="yes" xml:space="preserve">
          <source>For cartesian to linear index conversion, see &lt;a href=&quot;#Base.LinearIndices&quot;&gt;&lt;code&gt;LinearIndices&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">데카르트를 선형 인덱스로 변환하려면 &lt;a href=&quot;#Base.LinearIndices&quot;&gt; &lt;code&gt;LinearIndices&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c8b30defdf847f67d42803fa30f31344e75b07b3" translate="yes" xml:space="preserve">
          <source>For code points less than &lt;code&gt;\u80&lt;/code&gt;, it happens that the UTF-8 encoding of each code point is just the single byte produced by the corresponding &lt;code&gt;\x&lt;/code&gt; escape, so the distinction can safely be ignored. For the escapes &lt;code&gt;\x80&lt;/code&gt; through &lt;code&gt;\xff&lt;/code&gt; as compared to &lt;code&gt;\u80&lt;/code&gt; through &lt;code&gt;\uff&lt;/code&gt;, however, there is a major difference: the former escapes all encode single bytes, which &amp;ndash; unless followed by very specific continuation bytes &amp;ndash; do not form valid UTF-8 data, whereas the latter escapes all represent Unicode code points with two-byte encodings.</source>
          <target state="translated">&lt;code&gt;\u80&lt;/code&gt; 보다 작은 코드 포인트의 경우, 각 코드 포인트의 UTF-8 인코딩은 해당 &lt;code&gt;\x&lt;/code&gt; 이스케이프에 의해 생성 된 단일 바이트 이므로 구별을 안전하게 무시할 수 있습니다. 내용은 탈출 &lt;code&gt;\x80&lt;/code&gt; 을 통해 &lt;code&gt;\xff&lt;/code&gt; 에 비해 &lt;code&gt;\u80&lt;/code&gt; 을 통해 &lt;code&gt;\uff&lt;/code&gt; 그러나 중요한 차이가 있습니다 : 전 탈출 모든 인코딩 단일 바이트 - 매우 구체적인 계속 이어 않는 바이트 - 유효한 UTF-8 형성하지 않습니다 후자 이스케이프는 모두 2 바이트 인코딩의 유니 코드 코드 포인트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7990f7d8e420dec5f948426ee0deb5045c50fdaa" translate="yes" xml:space="preserve">
          <source>For composite types, this means that the identity of the values of its fields will never change. When the fields are bits types, that means their bits will never change, for fields whose values are mutable types like arrays, that means the fields will always refer to the same mutable value even though that mutable value's content may itself be modified.</source>
          <target state="translated">복합 유형의 경우 이는 해당 필드 값의 ID가 변경되지 않음을 의미합니다. 필드가 비트 유형 인 경우 값이 배열과 같이 변경 가능한 유형 인 필드의 경우 비트가 절대 변경되지 않음을 의미합니다. 즉, 변경 가능한 값의 내용 자체가 수정 될 수 있지만 필드는 항상 동일한 변경 가능한 값을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="03316709b23be1fe05fb3b1026fde6353f45ac08" translate="yes" xml:space="preserve">
          <source>For consistency across Julia, the call site should always pass a &lt;code&gt;Val&lt;/code&gt;&lt;em&gt;instance&lt;/em&gt; rather than using a &lt;em&gt;type&lt;/em&gt;, i.e., use &lt;code&gt;foo(Val(:bar))&lt;/code&gt; rather than &lt;code&gt;foo(Val{:bar})&lt;/code&gt;.</source>
          <target state="translated">Julia에서 일관성을 유지하려면 호출 사이트는 항상 &lt;em&gt;type을&lt;/em&gt; 사용하는 대신 &lt;code&gt;Val&lt;/code&gt; &lt;em&gt;인스턴스를&lt;/em&gt; 전달해야 &lt;em&gt;합니다&lt;/em&gt; . 즉, &lt;code&gt;foo(Val{:bar})&lt;/code&gt; 대신 &lt;code&gt;foo(Val(:bar))&lt;/code&gt; )를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3d9ce2fe390265769939ee6ced6c2028220d4701" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;p&lt;/code&gt; may be a type instead of a value: &lt;code&gt;ceil(dt, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;ceil(dt, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">편의상 &lt;code&gt;p&lt;/code&gt; 는 값 대신 유형일 수 있습니다. &lt;code&gt;ceil(dt, Dates.Hour)&lt;/code&gt; 는 &lt;code&gt;ceil(dt, Dates.Hour(1))&lt;/code&gt; 의 바로 가기입니다 .</target>
        </trans-unit>
        <trans-unit id="89f749ab9e4eefe9228d7474faa98982038d612a" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;p&lt;/code&gt; may be a type instead of a value: &lt;code&gt;floor(dt, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;floor(dt, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">편의상 &lt;code&gt;p&lt;/code&gt; 는 값 대신 유형일 수 있습니다. &lt;code&gt;floor(dt, Dates.Hour)&lt;/code&gt; 는 &lt;code&gt;floor(dt, Dates.Hour(1))&lt;/code&gt; 의 바로 가기입니다 .</target>
        </trans-unit>
        <trans-unit id="ba5445c2e02b549b16ba3decf8b6cd4aeb77578a" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;p&lt;/code&gt; may be a type instead of a value: &lt;code&gt;round(dt, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;round(dt, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">편의상 &lt;code&gt;p&lt;/code&gt; 는 값 대신 유형일 수 있습니다. &lt;code&gt;round(dt, Dates.Hour)&lt;/code&gt; 는 &lt;code&gt;round(dt, Dates.Hour(1))&lt;/code&gt; 의 바로 가기입니다 .</target>
        </trans-unit>
        <trans-unit id="628a74984a13bf54fa3097a1ff489c44e499c284" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;precision&lt;/code&gt; may be a type instead of a value: &lt;code&gt;ceil(x, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;ceil(x, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">편의상 &lt;code&gt;precision&lt;/code&gt; 는 값 대신 유형일 수 있습니다. &lt;code&gt;ceil(x, Dates.Hour)&lt;/code&gt; 는 &lt;code&gt;ceil(x, Dates.Hour(1))&lt;/code&gt; 의 바로 가기입니다 .</target>
        </trans-unit>
        <trans-unit id="43f856c7ece595cf56ae5fb16a5157cda0b0b39e" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;precision&lt;/code&gt; may be a type instead of a value: &lt;code&gt;floor(x, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;floor(x, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">편의상 &lt;code&gt;precision&lt;/code&gt; 는 값 대신 유형이 될 수 있습니다. &lt;code&gt;floor(x, Dates.Hour)&lt;/code&gt; 는 &lt;code&gt;floor(x, Dates.Hour(1))&lt;/code&gt; 의 바로 가기입니다 .</target>
        </trans-unit>
        <trans-unit id="752ad3a1bbf71154ca789079220fccfae5f42c78" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;precision&lt;/code&gt; may be a type instead of a value: &lt;code&gt;round(x, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;round(x, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">편의상 &lt;code&gt;precision&lt;/code&gt; 는 값 대신 유형일 수 있습니다. &lt;code&gt;round(x, Dates.Hour)&lt;/code&gt; 는 &lt;code&gt;round(x, Dates.Hour(1))&lt;/code&gt; 의 바로 가기입니다 .</target>
        </trans-unit>
        <trans-unit id="337e0be4946ed3262678abe0f2e935f04104f98b" translate="yes" xml:space="preserve">
          <source>For direct C++ interfacing, see the &lt;a href=&quot;https://github.com/Keno/Cxx.jl&quot;&gt;Cxx&lt;/a&gt; package. For tools to create C++ bindings, see the &lt;a href=&quot;https://github.com/JuliaInterop/CxxWrap.jl&quot;&gt;CxxWrap&lt;/a&gt; package.</source>
          <target state="translated">직접적인 C ++ 인터페이스에 대해서는 &lt;a href=&quot;https://github.com/Keno/Cxx.jl&quot;&gt;Cxx&lt;/a&gt; 패키지를 참조하십시오 . C ++ 바인딩을 작성하는 도구는 &lt;a href=&quot;https://github.com/JuliaInterop/CxxWrap.jl&quot;&gt;CxxWrap&lt;/a&gt; 패키지를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e618742c8a5d9129a1258dfbf5438a2e4a87773" translate="yes" xml:space="preserve">
          <source>For each pair &lt;code&gt;old=&amp;gt;new&lt;/code&gt; in &lt;code&gt;old_new&lt;/code&gt;, replace all occurrences of &lt;code&gt;old&lt;/code&gt; in collection &lt;code&gt;A&lt;/code&gt; by &lt;code&gt;new&lt;/code&gt;. Equality is determined using &lt;a href=&quot;../base/index#Base.isequal&quot;&gt;&lt;code&gt;isequal&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;count&lt;/code&gt; is specified, then replace at most &lt;code&gt;count&lt;/code&gt; occurrences in total. See also &lt;a href=&quot;#Base.replace-Tuple%7BAny,Vararg%7BPair,N%7D%20where%20N%7D&quot;&gt;&lt;code&gt;replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">각 쌍의 경우 &lt;code&gt;old=&amp;gt;new&lt;/code&gt; 에 &lt;code&gt;old_new&lt;/code&gt; , 모든 항목 교체 &lt;code&gt;old&lt;/code&gt; 수집에 &lt;code&gt;A&lt;/code&gt; 하여 &lt;code&gt;new&lt;/code&gt; . 평등은 &lt;a href=&quot;../base/index#Base.isequal&quot;&gt; &lt;code&gt;isequal&lt;/code&gt; 을&lt;/a&gt; 사용하여 결정됩니다 . 경우 &lt;code&gt;count&lt;/code&gt; 지정하면 대부분에서 대체 &lt;code&gt;count&lt;/code&gt; 총 발생. &lt;a href=&quot;#Base.replace-Tuple%7BAny,Vararg%7BPair,N%7D%20where%20N%7D&quot;&gt; &lt;code&gt;replace&lt;/code&gt; &lt;/a&gt; 도 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ffd384e9075d866940b3029eb6057da7ada0b04b" translate="yes" xml:space="preserve">
          <source>For ease of understanding, the examples throughout this chapter show full data structures for roots, graph and paths. However, Julia's package loading code does not explicitly create these. Instead, it lazily computes only as much of each structure as it needs to load a given package.</source>
          <target state="translated">이해를 돕기 위해이 장의 예제는 근, 그래프 및 경로에 대한 전체 데이터 구조를 보여줍니다. 그러나 Julia의 패키지 로딩 코드는이를 명시 적으로 생성하지 않습니다. 대신, 주어진 패키지를로드하는 데 필요한만큼의 각 구조 만 느리게 계산합니다.</target>
        </trans-unit>
        <trans-unit id="04e18da25adbbde93578f1eb2fa5f41635ed03eb" translate="yes" xml:space="preserve">
          <source>For empty collections, providing &lt;code&gt;init&lt;/code&gt; will be necessary, except for some special cases (e.g. when &lt;code&gt;op&lt;/code&gt; is one of &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;) when Julia can determine the neutral element of &lt;code&gt;op&lt;/code&gt;.</source>
          <target state="translated">빈 컬렉션을 위해 제공 &lt;code&gt;init&lt;/code&gt; 특별한 경우를 제외하고, 필요하다 (예를 들면 때 &lt;code&gt;op&lt;/code&gt; 중 하나입니다 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;max&lt;/code&gt; , &lt;code&gt;min&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; ) 줄리아의 중립 요소를 확인할 수 있습니다 때 &lt;code&gt;op&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f7a1238b1ac319ac9db6a4c619c8de57eb47bad" translate="yes" xml:space="preserve">
          <source>For even more extensive documentation of the history of, rationale for, and issues with floating-point numbers, as well as discussion of many other topics in numerical computing, see the &lt;a href=&quot;https://people.eecs.berkeley.edu/~wkahan/&quot;&gt;collected writings&lt;/a&gt; of &lt;a href=&quot;https://en.wikipedia.org/wiki/William_Kahan&quot;&gt;William Kahan&lt;/a&gt;, commonly known as the &quot;Father of Floating-Point&quot;. Of particular interest may be &lt;a href=&quot;https://people.eecs.berkeley.edu/~wkahan/ieee754status/754story.html&quot;&gt;An Interview with the Old Man of Floating-Point&lt;/a&gt;.</source>
          <target state="translated">더욱 광범위의 역사 문서에 대한 근거 및 문제 부동 소수점 숫자뿐만 아니라, 수치 계산의 많은 다른 주제의 토론 내용은 참조 &lt;a href=&quot;https://people.eecs.berkeley.edu/~wkahan/&quot;&gt;수집 된 글&lt;/a&gt; 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/William_Kahan&quot;&gt;윌리엄 카한을&lt;/a&gt; 일반적으로 부동의 &quot;아버지로 알려진, 포인트&quot;. 특히 흥미로운 &lt;a href=&quot;https://people.eecs.berkeley.edu/~wkahan/ieee754status/754story.html&quot;&gt;것은 부동 소수점 노인과의 인터뷰입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b77b25aae44912586606895a221d1e45b8c25f37" translate="yes" xml:space="preserve">
          <source>For every incoming logical connection with a worker, &lt;code&gt;Base.process_messages(rd::IO, wr::IO)()&lt;/code&gt; must be called. This launches a new task that handles reading and writing of messages from/to the worker represented by the &lt;code&gt;IO&lt;/code&gt; objects.</source>
          <target state="translated">작업자와 들어오는 모든 논리적 연결에 대해 &lt;code&gt;Base.process_messages(rd::IO, wr::IO)()&lt;/code&gt; 를 호출해야합니다. 그러면 &lt;code&gt;IO&lt;/code&gt; 객체로 표시되는 작업자와의 메시지 읽기 및 쓰기를 처리하는 새 작업이 시작 됩니다.</target>
        </trans-unit>
        <trans-unit id="b85b3e1a00e44270cd850d12b0754ab94e579430" translate="yes" xml:space="preserve">
          <source>For every worker launched, the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt;&lt;code&gt;launch&lt;/code&gt;&lt;/a&gt; method must add a &lt;code&gt;WorkerConfig&lt;/code&gt; object (with appropriate fields initialized) to &lt;code&gt;launched&lt;/code&gt;</source>
          <target state="translated">모든 노동자가 출시를 들어, &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt; &lt;code&gt;launch&lt;/code&gt; &lt;/a&gt; 추가해야합니다 방법 &lt;code&gt;WorkerConfig&lt;/code&gt; 의 에 객체를 (해당 필드로 초기화) &lt;code&gt;launched&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17c1669fdd5a30442a1d111e532e0e0ca62fed47" translate="yes" xml:space="preserve">
          <source>For example in order to fix &lt;code&gt;findfirst&lt;/code&gt; example above one needs to have a separate copy of &lt;code&gt;rx&lt;/code&gt; variable for each thread:</source>
          <target state="translated">예를 들어 위의 &lt;code&gt;findfirst&lt;/code&gt; 예제 를 수정 하려면 각 스레드마다 별도의 &lt;code&gt;rx&lt;/code&gt; 변수 사본이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="08186eb20e073535d04d3ee1bc374db09694e868" translate="yes" xml:space="preserve">
          <source>For example in the following docstring a variable &lt;code&gt;a&lt;/code&gt; is defined and the expected result, as printed in a Julia REPL, appears afterwards:</source>
          <target state="translated">예를 들어 다음 docstring에서 변수 &lt;code&gt;a&lt;/code&gt; 가 정의되고 Julia REPL에 인쇄 된 예상 결과가 나중에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="b50ac335cd803909aabb34c2ac8aa635fe70764b" translate="yes" xml:space="preserve">
          <source>For example you should write</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="d30d6b6735d4ff4914afad9079e3d2da944acfc0" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;@static Sys.iswindows() ? foo : bar&lt;/code&gt; will evaluate &lt;code&gt;Sys.iswindows()&lt;/code&gt; and insert either &lt;code&gt;foo&lt;/code&gt; or &lt;code&gt;bar&lt;/code&gt; into the expression. This is useful in cases where a construct would be invalid on other platforms, such as a &lt;code&gt;ccall&lt;/code&gt; to a non-existent function. &lt;code&gt;@static if Sys.isapple() foo end&lt;/code&gt; and &lt;code&gt;@static foo &amp;lt;&amp;amp;&amp;amp;,||&amp;gt; bar&lt;/code&gt; are also valid syntax.</source>
          <target state="translated">예를 들어, &lt;code&gt;@static Sys.iswindows() ? foo : bar&lt;/code&gt; 는 &lt;code&gt;Sys.iswindows()&lt;/code&gt; 를 평가 하고 &lt;code&gt;foo&lt;/code&gt; 또는 &lt;code&gt;bar&lt;/code&gt; 를 표현식에 삽입합니다 . 존재하지 않는 함수에 대한 &lt;code&gt;ccall&lt;/code&gt; 과 같은 다른 플랫폼에서 구문이 유효하지 않은 경우에 유용 합니다. &lt;code&gt;@static if Sys.isapple() foo end&lt;/code&gt; 및 &lt;code&gt;@static foo &amp;lt;&amp;amp;&amp;amp;,||&amp;gt; bar&lt;/code&gt; 도 유효한 구문 인 경우 @static .</target>
        </trans-unit>
        <trans-unit id="ebd8456aa0b38dfe42ed79277e4c1654dd3d60d1" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;RemoteChannel(()-&amp;gt;Channel{Int}(10), pid)&lt;/code&gt;, will return a reference to a channel of type &lt;code&gt;Int&lt;/code&gt; and size 10 on &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;RemoteChannel(()-&amp;gt;Channel{Int}(10), pid)&lt;/code&gt; 은 &lt;code&gt;pid&lt;/code&gt; 에서 크기가 &lt;code&gt;Int&lt;/code&gt; 이고 크기가 10 인 채널에 대한 참조를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="96ff3ffca8d84a68fdc5320415ea0dc59a9a8872" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;RemoteChannel(()-&amp;gt;Channel{Int}(10), pid)&lt;/code&gt;, will return a reference to a channel of type &lt;code&gt;Int&lt;/code&gt; and size 10. The channel exists on worker &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;RemoteChannel(()-&amp;gt;Channel{Int}(10), pid)&lt;/code&gt; 은 &lt;code&gt;Int&lt;/code&gt; 유형 및 크기 10의 채널에 대한 참조를 반환합니다 .이 채널은 작업자 &lt;code&gt;pid&lt;/code&gt; 에 존재합니다 .</target>
        </trans-unit>
        <trans-unit id="4891a83f30d6618f43c5e0d97b64d34ca2b73c56" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;similar(1:10, 1, 4)&lt;/code&gt; returns an uninitialized &lt;code&gt;Array{Int,2}&lt;/code&gt; since ranges are neither mutable nor support 2 dimensions:</source>
          <target state="translated">예를 들어, &lt;code&gt;similar(1:10, 1, 4)&lt;/code&gt; 는 범위를 변경할 수없고 2 차원을 지원하지 않기 때문에 초기화되지 않은 &lt;code&gt;Array{Int,2}&lt;/code&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="9440a60be9ec094e973482fb911a180f54e935ef" translate="yes" xml:space="preserve">
          <source>For example, Beowulf clusters are supported via a custom cluster manager implemented in the package &lt;code&gt;ClusterManagers.jl&lt;/code&gt;.</source>
          <target state="translated">예를 들어 Beowulf 클러스터는 &lt;code&gt;ClusterManagers.jl&lt;/code&gt; 패키지에 구현 된 사용자 정의 클러스터 관리자를 통해 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="c68e3216a6f7acab7967abd7cf08e2c4de403780" translate="yes" xml:space="preserve">
          <source>For example, NFKC corresponds to the options &lt;code&gt;compose=true, compat=true, stable=true&lt;/code&gt;.</source>
          <target state="translated">예를 들어 NFKC는 &lt;code&gt;compose=true, compat=true, stable=true&lt;/code&gt; 옵션에 해당 합니다 .</target>
        </trans-unit>
        <trans-unit id="4599895ae8d119fa4cbac0f0c56af45c7eba0c70" translate="yes" xml:space="preserve">
          <source>For example, a Linux installation with a Julia executable located at &lt;code&gt;/bin/julia&lt;/code&gt;, a &lt;code&gt;DATAROOTDIR&lt;/code&gt; of &lt;code&gt;../share&lt;/code&gt;, and a &lt;code&gt;SYSCONFDIR&lt;/code&gt; of &lt;code&gt;../etc&lt;/code&gt; will have &lt;code&gt;JULIA_BINDIR&lt;/code&gt; set to &lt;code&gt;/bin&lt;/code&gt;, a source-file search path of</source>
          <target state="translated">예를 들어, 줄리아와 리눅스 설치를 실행에 위치 &lt;code&gt;/bin/julia&lt;/code&gt; 하는 &lt;code&gt;DATAROOTDIR&lt;/code&gt; 의 &lt;code&gt;../share&lt;/code&gt; 및 &lt;code&gt;SYSCONFDIR&lt;/code&gt; 의 &lt;code&gt;../etc&lt;/code&gt; 는 것 &lt;code&gt;JULIA_BINDIR&lt;/code&gt; 의 에 설정을 &lt;code&gt;/bin&lt;/code&gt; 의 소스 파일 검색 경로</target>
        </trans-unit>
        <trans-unit id="cb227b31f00d820f5d9d05405c8ad07604ce912a" translate="yes" xml:space="preserve">
          <source>For example, a recursive factorial routine could be defined like this:</source>
          <target state="translated">예를 들어, 재귀 요인 루틴은 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3ee27750c0b683e5c90895147928cfd59e22a42" translate="yes" xml:space="preserve">
          <source>For example, consider a function &lt;code&gt;plot&lt;/code&gt; that plots a line. This function might have many options, for controlling line style, width, color, and so on. If it accepts keyword arguments, a possible call might look like &lt;code&gt;plot(x, y, width=2)&lt;/code&gt;, where we have chosen to specify only line width. Notice that this serves two purposes. The call is easier to read, since we can label an argument with its meaning. It also becomes possible to pass any subset of a large number of arguments, in any order.</source>
          <target state="translated">예를 들어, 선을 &lt;code&gt;plot&lt;/code&gt; 함수 그림 을 생각해보십시오 . 이 기능에는 선 스타일, 너비, 색상 등을 제어하기위한 많은 옵션이있을 수 있습니다. 키워드 인수를 허용하는 경우 가능한 호출은 &lt;code&gt;plot(x, y, width=2)&lt;/code&gt; 와 같을 수 있으며 여기서 선 너비 만 지정하도록 선택했습니다. 이것은 두 가지 목적으로 사용됩니다. 우리는 인자를 의미로 라벨링 할 수 있기 때문에 호출이 더 읽기 쉽다. 또한 많은 수의 인수 중 일부를 순서에 상관없이 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="02796f85acf393569f8f018e6f896c1698a7ba0c" translate="yes" xml:space="preserve">
          <source>For example, consider the following definitions of a function &lt;code&gt;addone&lt;/code&gt; that returns one plus its argument:</source>
          <target state="translated">예를 들어, 인수와 함께 1을 더한 함수 &lt;code&gt;addone&lt;/code&gt; 의 다음 정의를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="8379ff1b045b6b8381b0fc1dcbd698daf2ddf0cf" translate="yes" xml:space="preserve">
          <source>For example, here is how we can guarantee that an opened file is closed:</source>
          <target state="translated">예를 들어, 열린 파일이 닫히도록 보장하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="49582067d66dec7b465ad077603d8140735bdbe0" translate="yes" xml:space="preserve">
          <source>For example, if you define a &lt;code&gt;MyImage&lt;/code&gt; type and know how to write it to a PNG file, you could define a function &lt;code&gt;show(io, ::MIME&quot;image/png&quot;, x::MyImage) = ...&lt;/code&gt; to allow your images to be displayed on any PNG-capable &lt;code&gt;AbstractDisplay&lt;/code&gt; (such as IJulia). As usual, be sure to &lt;code&gt;import Base.show&lt;/code&gt; in order to add new methods to the built-in Julia function &lt;code&gt;show&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;MyImage&lt;/code&gt; 유형 을 정의하고 PNG 파일에 작성하는 방법을 알고 있다면 &lt;code&gt;show(io, ::MIME&quot;image/png&quot;, x::MyImage) = ...&lt;/code&gt; 함수를 정의 할 수 있습니다. PNG 가능 &lt;code&gt;AbstractDisplay&lt;/code&gt; (예 : IJulia) 에 표시 할 이미지 평소와 같이 내장 Julia 함수 &lt;code&gt;show&lt;/code&gt; 에 새 메소드를 추가하려면 &lt;code&gt;import Base.show&lt;/code&gt; 를 가져와야 합니다.</target>
        </trans-unit>
        <trans-unit id="2da1e2276f1c5c558883dab8cb5596d1bc2a1628" translate="yes" xml:space="preserve">
          <source>For example, say we define a type that stores a vector along with an accurate representation of its sum:</source>
          <target state="translated">예를 들어 벡터를 합산의 정확한 표현과 함께 저장하는 유형을 정의한다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="e2cfd2a7e3ca6e4481d092c3fbc0442d5a4ab757" translate="yes" xml:space="preserve">
          <source>For example, suppose one wants to declare a type that holds a pair of real numbers, subject to the constraint that the first number is not greater than the second one. One could declare it like this:</source>
          <target state="translated">예를 들어, 첫 번째 숫자가 두 번째 숫자보다 크지 않다는 제약 조건에 따라 한 쌍의 실수를 보유하는 유형을 선언하려고한다고 가정하십시오. 다음과 같이 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79225a639e81658b4de8b5567b3dea63ac5abb4f" translate="yes" xml:space="preserve">
          <source>For example, suppose we want to check our new function &lt;code&gt;foo(x)&lt;/code&gt; works as expected:</source>
          <target state="translated">예를 들어, 새로운 함수 &lt;code&gt;foo(x)&lt;/code&gt; 가 예상대로 작동하는지 확인한다고 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="7eda6e477d1dd1d46e2cafc4f54477c6b2bb0e6a" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;sqrt&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; functions can be composed like this:</source>
          <target state="translated">예를 들어, &lt;code&gt;sqrt&lt;/code&gt; 및 &lt;code&gt;+&lt;/code&gt; 함수는 다음과 같이 구성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ae23a1c15837ee5f1ee5c9f54f1ec5adaf7300a" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;sqrt&lt;/code&gt; function throws a &lt;a href=&quot;../../base/base/index#Core.DomainError&quot;&gt;&lt;code&gt;DomainError&lt;/code&gt;&lt;/a&gt; if applied to a negative real value:</source>
          <target state="translated">예를 들어, &lt;code&gt;sqrt&lt;/code&gt; 함수는 음의 실수 값에 적용된 경우 &lt;a href=&quot;../../base/base/index#Core.DomainError&quot;&gt; &lt;code&gt;DomainError&lt;/code&gt; 를&lt;/a&gt; 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="41fbcb24e42e9f837587084b7759fc106d92d27c" translate="yes" xml:space="preserve">
          <source>For example, the following code</source>
          <target state="translated">예를 들어, 다음 코드</target>
        </trans-unit>
        <trans-unit id="df53f88b87089b5c188eb151fc2371ed97e5a8bd" translate="yes" xml:space="preserve">
          <source>For example, the following code will not work as intended:</source>
          <target state="translated">예를 들어 다음 코드는 의도 한대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd2a7ac9bf39edcb33138e7083aee6d2163bed39" translate="yes" xml:space="preserve">
          <source>For example, the following definition supports the negation of ranges:</source>
          <target state="translated">예를 들어 다음 정의는 범위 부정을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ebd9e6f4328ccf3da34436709427cc4b4eaab0c0" translate="yes" xml:space="preserve">
          <source>For example, the following regex has all three flags turned on:</source>
          <target state="translated">예를 들어, 다음 정규식에는 세 개의 플래그가 모두 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f984e5cb891417962d09962040b3dc32bb1ac27e" translate="yes" xml:space="preserve">
          <source>For example, the following would cause the &lt;code&gt;for&lt;/code&gt; loop to wait for more data:</source>
          <target state="translated">예를 들어, 다음은 &lt;code&gt;for&lt;/code&gt; 루프가 더 많은 데이터를 기다리는 원인이 됩니다.</target>
        </trans-unit>
        <trans-unit id="f4ca40c2a3ba9787690378fb5f2aab689eee1052" translate="yes" xml:space="preserve">
          <source>For example, to read a simple byte array, we could do:</source>
          <target state="translated">예를 들어 간단한 바이트 배열을 읽으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="8878c21d4c3068d1cd94e841b14239269912a492" translate="yes" xml:space="preserve">
          <source>For example, trying to dispatch on the element-type of an array will often run into ambiguous situations. Instead, commonly code will dispatch first on the container type, then recurse down to a more specific method based on eltype. In most cases, the algorithms lend themselves conveniently to this hierarchical approach, while in other cases, this rigor must be resolved manually. This dispatching branching can be observed, for example, in the logic to sum two matrices:</source>
          <target state="translated">예를 들어, 배열의 요소 유형을 디스패치하려고하면 종종 모호한 상황이 발생합니다. 대신 일반적으로 코드는 컨테이너 유형을 먼저 전달한 다음 eltype을 기반으로 한 더 구체적인 방법으로 재귀 적입니다. 대부분의 경우 알고리즘은 이러한 계층 적 접근 방식에 편리하게 적합하지만 다른 경우에는 이러한 엄격 성을 수동으로 해결해야합니다. 이 디스패치 브랜치는 예를 들어 두 매트릭스를 합산하는 로직에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2c13e0b4d2254aa0c6b075c4f699f03e1e4085d" translate="yes" xml:space="preserve">
          <source>For example, two vectors &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; of the same length can be written as two columns of tab-delimited text to &lt;code&gt;f&lt;/code&gt; by either &lt;code&gt;writedlm(f, [x y])&lt;/code&gt; or by &lt;code&gt;writedlm(f, zip(x, y))&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 같은 길이의 두 벡터 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 는 &lt;code&gt;writedlm(f, [x y])&lt;/code&gt; 또는 &lt;code&gt;writedlm(f, zip(x, y))&lt;/code&gt; 의해 탭으로 구분 된 텍스트의 두 열로 &lt;code&gt;f&lt;/code&gt; 에 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="20b7a39286391fad09a5ff705ae3bda829227952" translate="yes" xml:space="preserve">
          <source>For example, when reading all of the output from a command, call &lt;code&gt;read(out, String)&lt;/code&gt;, not &lt;code&gt;wait(process)&lt;/code&gt;, since the former will actively consume all of the data written by the process, whereas the latter will attempt to store the data in the kernel's buffers while waiting for a reader to be connected.</source>
          <target state="translated">예를 들어, 명령에서 모든 출력을 &lt;code&gt;read(out, String)&lt;/code&gt; &lt;code&gt;wait(process)&lt;/code&gt; 아닌 read (out, String)을 호출 하십시오. 전자는 프로세스에 의해 작성된 모든 데이터를 적극적으로 소비하지만 후자는 리더의 연결을 기다리는 동안 커널 버퍼의 데이터.</target>
        </trans-unit>
        <trans-unit id="5029745bd6486130a24ba078811879e64132c558" translate="yes" xml:space="preserve">
          <source>For example, you can define a type that stores the coefficients of a polynomial, but behaves like a function evaluating the polynomial:</source>
          <target state="translated">예를 들어 다항식의 계수를 저장하지만 다항식을 평가하는 함수처럼 동작하는 유형을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67f058df3da112643c2b0a1dfa02199be4e0057b" translate="yes" xml:space="preserve">
          <source>For example, you might look up the function via &lt;code&gt;dlsym&lt;/code&gt;, then cache it in a shared reference for that session. For example:</source>
          <target state="translated">예를 들어, &lt;code&gt;dlsym&lt;/code&gt; 을 통해 함수를 찾은 다음 해당 세션에 대한 공유 참조로 캐시 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="77957bacdf57512b4372bd5a4e3fd7ed75c7e36e" translate="yes" xml:space="preserve">
          <source>For expert drivers and additional information, see &lt;code&gt;permute!&lt;/code&gt;.</source>
          <target state="translated">전문 드라이버 및 추가 정보는 &lt;code&gt;permute!&lt;/code&gt; 참조하십시오 ! .</target>
        </trans-unit>
        <trans-unit id="023517bc66d9d3e180b498d61c21e401d08d2db9" translate="yes" xml:space="preserve">
          <source>For file dependencies, a change is determined by examining whether the modification time (mtime) of each file loaded by &lt;code&gt;include&lt;/code&gt; or added explicitly by &lt;code&gt;include_dependency&lt;/code&gt; is unchanged, or equal to the modification time truncated to the nearest second (to accommodate systems that can't copy mtime with sub-second accuracy). It also takes into account whether the path to the file chosen by the search logic in &lt;code&gt;require&lt;/code&gt; matches the path that had created the precompile file. It also takes into account the set of dependencies already loaded into the current process and won't recompile those modules, even if their files change or disappear, in order to avoid creating incompatibilities between the running system and the precompile cache.</source>
          <target state="translated">파일 종속성의 경우 &lt;code&gt;include_dependency&lt;/code&gt; 에 의해 명시 적으로 추가되거나 &lt;code&gt;include&lt;/code&gt; 되어로드 되거나 로드 된 각 파일의 수정 시간 (mtime) 이 변경되지 않았 는지 또는 가장 근접한 초 단위로 잘린 수정 시간과 같은지 검사하여 변경 사항을 판별합니다 ( 초 미만의 정확도로 mtime 복사). 또한 고려 여부의 검색 로직에 의해 선택된 파일의 경로 &lt;code&gt;require&lt;/code&gt; 일치 프리 D 파일을 생성 한 경로를. 또한 실행중인 시스템과 프리 컴파일 캐시간에 비 호환성을 피하기 위해 현재 프로세스에 이미로드 된 종속성 세트를 고려하고 파일이 변경되거나 사라져도 해당 모듈을 다시 컴파일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="66dd55e20f602bb211d9c7813d2f9f0ed6928fe9" translate="yes" xml:space="preserve">
          <source>For fixed-size integer types less than 128 bits, &lt;code&gt;widen&lt;/code&gt; will return a type with twice the number of bits.</source>
          <target state="translated">128 비트 미만의 고정 크기 정수 유형의 경우 &lt;code&gt;widen&lt;/code&gt; 하면 비트 수가 두 배인 유형이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="517d5d95b2398e36f4828f9d104f02ccf187deee" translate="yes" xml:space="preserve">
          <source>For functions &lt;code&gt;f(x)&lt;/code&gt;, &lt;code&gt;f(x) = x&lt;/code&gt; defines a new function constant &lt;code&gt;f&lt;/code&gt;, or adds a new method to &lt;code&gt;f&lt;/code&gt; if &lt;code&gt;f&lt;/code&gt; is already defined; this usage is equivalent to &lt;code&gt;function f(x); x; end&lt;/code&gt;.</source>
          <target state="translated">함수의 &lt;code&gt;f(x)&lt;/code&gt; , &lt;code&gt;f(x) = x&lt;/code&gt; 새로운 함수를 정의 정수 &lt;code&gt;f&lt;/code&gt; 하거나하는 새로운 방법이 추가 &lt;code&gt;f&lt;/code&gt; 경우 &lt;code&gt;f&lt;/code&gt; 는 이미 정의되고; 이 사용법은 &lt;code&gt;function f(x); x; end&lt;/code&gt; 와 같습니다 . 엑스; 끝 .</target>
        </trans-unit>
        <trans-unit id="6a6abe0e3a65b8ed9f51c340da311967dd300c9c" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw add&lt;/code&gt; instruction.</source>
          <target state="translated">자세한 내용은 LLVM의 &lt;code&gt;atomicrmw add&lt;/code&gt; 명령어를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a0322dcf17161d23047710cc59f3f8e235c18a53" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw and&lt;/code&gt; instruction.</source>
          <target state="translated">자세한 내용은 LLVM의 &lt;code&gt;atomicrmw and&lt;/code&gt; 명령을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e5b561d9fc0067e467e9e9fcee46e3023283cf28" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw max&lt;/code&gt; instruction.</source>
          <target state="translated">자세한 내용은 LLVM의 &lt;code&gt;atomicrmw max&lt;/code&gt; 명령을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eab5683b8c3c9bc6117f8a69b4da87aa9632a8fb" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw min&lt;/code&gt; instruction.</source>
          <target state="translated">자세한 내용은 LLVM의 &lt;code&gt;atomicrmw min&lt;/code&gt; 명령을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b7e08b7890af600321c511f13a806cd3559bcfa" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw nand&lt;/code&gt; instruction.</source>
          <target state="translated">자세한 내용은 LLVM의 &lt;code&gt;atomicrmw nand&lt;/code&gt; 명령을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b8dd1c376a179e2ba56074f5563e776f17ef9ec" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw or&lt;/code&gt; instruction.</source>
          <target state="translated">자세한 내용은 LLVM의 &lt;code&gt;atomicrmw or&lt;/code&gt; 명령을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="48c1004b7dffe90355657654366824768f35001b" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw sub&lt;/code&gt; instruction.</source>
          <target state="translated">자세한 내용은 LLVM의 &lt;code&gt;atomicrmw sub&lt;/code&gt; 명령어를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="192e95dde72a6e68d2db267b6ee138cf37555d73" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw xchg&lt;/code&gt; instruction.</source>
          <target state="translated">자세한 내용은 LLVM의 &lt;code&gt;atomicrmw xchg&lt;/code&gt; 명령을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5e4b67df501ae8428fb22d5e33af878bfbea1ef9" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw xor&lt;/code&gt; instruction.</source>
          <target state="translated">자세한 내용은 LLVM의 &lt;code&gt;atomicrmw xor&lt;/code&gt; 명령을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ee314d2ce6ee192109b08f74bbfd48cbb0e5cbc" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;cmpxchg&lt;/code&gt; instruction.</source>
          <target state="translated">자세한 내용은 LLVM의 &lt;code&gt;cmpxchg&lt;/code&gt; 명령을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7755edb4519e4536a6271c13a954434e48a3388" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;fence&lt;/code&gt; instruction.</source>
          <target state="translated">자세한 내용은 LLVM의 &lt;code&gt;fence&lt;/code&gt; 명령어를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="592e1ef0cc917b2ef533393d9872f216dc5c373c" translate="yes" xml:space="preserve">
          <source>For further discussion of how these non-finite floating-point values are ordered with respect to each other and other floats, see &lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons-1&quot;&gt;Numeric Comparisons&lt;/a&gt;. By the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754 standard&lt;/a&gt;, these floating-point values are the results of certain arithmetic operations:</source>
          <target state="translated">이러한 비유동 부동 소수점 값이 서로 다른 부동 소수점에 대해 어떻게 정렬되는지에 대한 자세한 내용은 &lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons-1&quot;&gt;숫자 비교를&lt;/a&gt; 참조하십시오 . 에 의해 &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754 표준&lt;/a&gt; 이 부동 소수점 값은 어떤 연산의 결과이다 :</target>
        </trans-unit>
        <trans-unit id="f6a5e306e2388b19948e17b05f28ec9cf0f8d86c" translate="yes" xml:space="preserve">
          <source>For general non-symmetric matrices it is possible to specify how the matrix is balanced before the eigenvalue calculation. The &lt;code&gt;permute&lt;/code&gt;, &lt;code&gt;scale&lt;/code&gt;, and &lt;code&gt;sortby&lt;/code&gt; keywords are the same as for &lt;a href=&quot;#LinearAlgebra.eigen!&quot;&gt;&lt;code&gt;eigen!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적인 비대칭 행렬의 경우 고유 값 계산 전에 행렬의 균형을 조정하는 방법을 지정할 수 있습니다. &lt;code&gt;permute&lt;/code&gt; , &lt;code&gt;scale&lt;/code&gt; 및 &lt;code&gt;sortby&lt;/code&gt; 의 키워드와 동일 &lt;a href=&quot;#LinearAlgebra.eigen!&quot;&gt; &lt;code&gt;eigen!&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="2a3464000c64f9602c239ac8ef54cb51f0375c94" translate="yes" xml:space="preserve">
          <source>For general nonsymmetric matrices it is possible to specify how the matrix is balanced before the eigenvector calculation. The option &lt;code&gt;permute=true&lt;/code&gt; permutes the matrix to become closer to upper triangular, and &lt;code&gt;scale=true&lt;/code&gt; scales the matrix by its diagonal elements to make rows and columns more equal in norm. The default is &lt;code&gt;true&lt;/code&gt; for both options.</source>
          <target state="translated">일반적인 비대칭 행렬의 경우 고유 벡터 계산 전에 행렬의 균형을 조정하는 방법을 지정할 수 있습니다. &lt;code&gt;permute=true&lt;/code&gt; 옵션 은 행렬을 상 삼각형에 가깝게 치환하고, &lt;code&gt;scale=true&lt;/code&gt; 는 행렬을 대각선 요소로 스케일링하여 행과 열을보다 평등하게 만듭니다. 두 옵션 모두 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="97272f75bb7bf420f1c0e8253e48bdca2d0549a3" translate="yes" xml:space="preserve">
          <source>For general square matrices, &lt;code&gt;A = A*B&lt;/code&gt; cannot be implemented without temporary storage: &lt;code&gt;A[1,1]&lt;/code&gt; gets computed and stored on the left hand side before you're done using it on the right hand side.</source>
          <target state="translated">일반적인 정방 행렬의 경우 &lt;code&gt;A = A*B&lt;/code&gt; 는 임시 저장없이 구현할 수 없습니다. &lt;code&gt;A[1,1]&lt;/code&gt; 은 오른쪽에서 사용하기 전에 왼쪽에서 계산되고 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="935a8c2e4f251a5770a2bb608ecff08833dd9c32" translate="yes" xml:space="preserve">
          <source>For global variables, only the bindings are captured in a closure, not the data. &lt;code&gt;let&lt;/code&gt; blocks can be used to capture global data.</source>
          <target state="translated">글로벌 변수의 경우 바인딩 만이 데이터가 아닌 클로저에서 캡처됩니다. &lt;code&gt;let&lt;/code&gt; 블록은 글로벌 데이터를 캡처 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5b2b73939c9dca143b01d277fa950512fdcf9e4" translate="yes" xml:space="preserve">
          <source>For implementing primitive operations, such as addition, we use the &lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt;&lt;code&gt;promote_type&lt;/code&gt;&lt;/a&gt; function to compute the desired output type. (As before, we saw this at work in the &lt;code&gt;promote&lt;/code&gt; call in the call to &lt;code&gt;+&lt;/code&gt;).</source>
          <target state="translated">덧셈과 같은 기본 연산을 구현하기 위해 &lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt; &lt;code&gt;promote_type&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 원하는 출력 유형을 계산합니다. (이전과 같이, 우리는 &lt;code&gt;+&lt;/code&gt; 에 대한 호출에서 &lt;code&gt;promote&lt;/code&gt; 호출 에서 작동하는 것을 보았습니다 ).</target>
        </trans-unit>
        <trans-unit id="9bbc05f37cbd2b5498a3ab3a593a156112a8c55d" translate="yes" xml:space="preserve">
          <source>For instance, consider this C routine that uses AVX intrinsics:</source>
          <target state="translated">예를 들어, AVX 내장 함수를 사용하는이 C 루틴을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="58f3adf26ef93227d12186ad90763f386c1243e3" translate="yes" xml:space="preserve">
          <source>For inverting dense ill-conditioned matrices in a least-squares sense, &lt;code&gt;rtol = sqrt(eps(real(float(one(eltype(M))))))&lt;/code&gt; is recommended.</source>
          <target state="translated">최소 제곱의 의미로 조밀하고 조건이 잘못된 행렬을 반전 &lt;code&gt;rtol = sqrt(eps(real(float(one(eltype(M))))))&lt;/code&gt; 가 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="3476b291492f6f31f8c69709d348f023db79ecb7" translate="yes" xml:space="preserve">
          <source>For many problems, it is not necessary to think about tasks directly. However, they can be used to wait for multiple events at the same time, which provides for &lt;em&gt;dynamic scheduling&lt;/em&gt;. In dynamic scheduling, a program decides what to compute or where to compute it based on when other jobs finish. This is needed for unpredictable or unbalanced workloads, where we want to assign more work to processes only when they finish their current tasks.</source>
          <target state="translated">많은 문제의 경우 작업에 대해 직접 생각할 필요가 없습니다. 그러나 동시에 여러 이벤트를 기다리는 데 사용할 수 있으므로 &lt;em&gt;동적 스케줄링이 가능&lt;/em&gt; 합니다. 동적 스케줄링에서 프로그램은 다른 작업이 완료되는 시점에 따라 계산 대상 또는 계산 위치를 결정합니다. 예측 불가능하거나 불균형 한 워크로드에 필요합니다. 여기서 현재 작업이 완료된 경우에만 프로세스에 더 많은 작업을 할당하려고합니다.</target>
        </trans-unit>
        <trans-unit id="7f0ae2a2524af9d24fc01426df34e4e2c47f07b3" translate="yes" xml:space="preserve">
          <source>For many types, forming new objects by binding their field values together is all that is ever needed to create instances. However, in some cases more functionality is required when creating composite objects. Sometimes invariants must be enforced, either by checking arguments or by transforming them. &lt;a href=&quot;https://en.wikipedia.org/wiki/Recursion_%28computer_science%29#Recursive_data_structures_.28structural_recursion.29&quot;&gt;Recursive data structures&lt;/a&gt;, especially those that may be self-referential, often cannot be constructed cleanly without first being created in an incomplete state and then altered programmatically to be made whole, as a separate step from object creation. Sometimes, it's just convenient to be able to construct objects with fewer or different types of parameters than they have fields. Julia's system for object construction addresses all of these cases and more.</source>
          <target state="translated">많은 유형의 경우 필드 값을 함께 바인딩하여 새 객체를 만드는 것이 인스턴스를 만드는 데 필요한 모든 것입니다. 그러나 경우에 따라 복합 객체를 만들 때 더 많은 기능이 필요합니다. 때때로 불변은 인수를 확인하거나 변환하여 시행해야합니다. &lt;a href=&quot;https://en.wikipedia.org/wiki/Recursion_%28computer_science%29#Recursive_data_structures_.28structural_recursion.29&quot;&gt;재귀 적 데이터 구조&lt;/a&gt; , 특히 자기 참조 적 구조 는 불완전한 상태에서 먼저 생성 된 후 완전히 생성되지 않은 상태에서 객체를 생성하는 별도의 단계로 프로그래밍 방식으로 변경하지 않는 경우가 많습니다. 때로는 필드보다 적은 수 또는 다른 유형의 매개 변수로 객체를 구성하는 것이 편리 할 때가 있습니다. Julia의 객체 구성 시스템은 이러한 모든 경우와 그 이상을 해결합니다.</target>
        </trans-unit>
        <trans-unit id="c3ab9fc4f4873966145fee9c6ac1a9124f310742" translate="yes" xml:space="preserve">
          <source>For matrices &lt;code&gt;M&lt;/code&gt; with floating point elements, it is convenient to compute the pseudoinverse by inverting only singular values greater than &lt;code&gt;max(atol, rtol*&amp;sigma;₁)&lt;/code&gt; where &lt;code&gt;&amp;sigma;₁&lt;/code&gt; is the largest singular value of &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">부동 소수점 요소가있는 행렬 &lt;code&gt;M&lt;/code&gt; 의 경우 &lt;code&gt;max(atol, rtol*&amp;sigma;₁)&lt;/code&gt; 보다 큰 특이 값 만 반전하여 의사 역수 를 계산하는 것이 편리합니다. 여기서 &lt;code&gt;&amp;sigma;₁&lt;/code&gt; 는 &lt;code&gt;M&lt;/code&gt; 의 가장 큰 특이 값입니다 .</target>
        </trans-unit>
        <trans-unit id="ac6da235d612ded03083200d47fe1ab7d98c9b79" translate="yes" xml:space="preserve">
          <source>For more complex functions on matrices, it may be necessary to compute the expected return type for a more complex sequence of operations. This is often performed by the following steps:</source>
          <target state="translated">행렬에 대한 더 복잡한 함수의 경우 더 복잡한 연산 순서에 대한 예상 반환 유형을 계산해야 할 수도 있습니다. 이것은 종종 다음 단계에 의해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="4017330d0c6b8db2f9072cd10c06aafbef3ef320" translate="yes" xml:space="preserve">
          <source>For more details on how to pass callbacks to C libraries, see this &lt;a href=&quot;https://julialang.org/blog/2013/05/callback&quot;&gt;blog post&lt;/a&gt;.</source>
          <target state="translated">콜백을 C 라이브러리에 전달하는 방법에 대한 자세한 내용은이 &lt;a href=&quot;https://julialang.org/blog/2013/05/callback&quot;&gt;블로그 게시물을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f4e7422368e9880e43d73e7cf711179bdaf3a6a3" translate="yes" xml:space="preserve">
          <source>For more details regarding code loading, see the manual sections on &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;modules&lt;/a&gt; and &lt;a href=&quot;../../manual/parallel-computing/index#code-availability-1&quot;&gt;parallel computing&lt;/a&gt;.</source>
          <target state="translated">코드 로딩에 대한 자세한 내용은 &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;모듈&lt;/a&gt; 및 &lt;a href=&quot;../../manual/parallel-computing/index#code-availability-1&quot;&gt;병렬 컴퓨팅&lt;/a&gt; 에 대한 매뉴얼 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="825f5736599d7832ed10460cda99264a6faea4e6" translate="yes" xml:space="preserve">
          <source>For more information about stylistic conventions, see the &lt;a href=&quot;../style-guide/index#Style-Guide-1&quot;&gt;Style Guide&lt;/a&gt;.</source>
          <target state="translated">스타일 규칙에 대한 자세한 정보는 &lt;a href=&quot;../style-guide/index#Style-Guide-1&quot;&gt;스타일 안내서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="29a5a734cc9600ff863c3e949c6ca0cd3d61e836" translate="yes" xml:space="preserve">
          <source>For more information, please see the &lt;a href=&quot;http://llvm.org/docs/LangRef.html#calling-conventions&quot;&gt;LLVM Language Reference&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;http://llvm.org/docs/LangRef.html#calling-conventions&quot;&gt;LLVM 언어 참조를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e94367c7326944c925932ccd75ddf09b0dc2a2ca" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;#footnote-issue8859&quot;&gt;[issue8859]&lt;/a&gt;, &lt;a href=&quot;#footnote-B96&quot;&gt;[B96]&lt;/a&gt;, &lt;a href=&quot;#footnote-S84&quot;&gt;[S84]&lt;/a&gt;, &lt;a href=&quot;#footnote-KY88&quot;&gt;[KY88]&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;#footnote-issue8859&quot;&gt;[issue8859]&lt;/a&gt; , &lt;a href=&quot;#footnote-B96&quot;&gt;[B96]&lt;/a&gt; , &lt;a href=&quot;#footnote-S84&quot;&gt;[S84]&lt;/a&gt; , &lt;a href=&quot;#footnote-KY88&quot;&gt;[KY88]을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="78c9da6d7f9a8088ccb6c5228fbbc41a8fd90ece" translate="yes" xml:space="preserve">
          <source>For more serious benchmarking, consider the &lt;a href=&quot;https://github.com/JuliaCI/BenchmarkTools.jl&quot;&gt;BenchmarkTools.jl&lt;/a&gt; package which among other things evaluates the function multiple times in order to reduce noise.</source>
          <target state="translated">보다 심각한 벤치마킹 을 위해서는 무엇보다도 노이즈를 줄이기 위해 기능을 여러 번 평가하는 &lt;a href=&quot;https://github.com/JuliaCI/BenchmarkTools.jl&quot;&gt;BenchmarkTools.jl&lt;/a&gt; 패키지를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="88557b99f2da7edd1312dcf73383bf3fd839d0cf" translate="yes" xml:space="preserve">
          <source>For most user-defined types, it is better practice to require programmers to supply the expected types to constructor functions explicitly, but sometimes, especially for numeric problems, it can be convenient to do promotion automatically.</source>
          <target state="translated">대부분의 사용자 정의 형식의 경우 프로그래머가 예상 형식을 생성자 함수에 명시 적으로 제공하도록 요구하는 것이 더 좋지만, 특히 숫자 문제의 경우 자동으로 승격하는 것이 편리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="ceb4f91d41747de4680e86cde1985bd3bfc38e4e" translate="yes" xml:space="preserve">
          <source>For multiple collection arguments, apply &lt;code&gt;f&lt;/code&gt; elementwise.</source>
          <target state="translated">여러 콜렉션 인수의 경우 요소 단위로 &lt;code&gt;f&lt;/code&gt; 를 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ea75a21c84d373ef04e66eb8c0a6a1bc5cc64258" translate="yes" xml:space="preserve">
          <source>For newcomers to multi-threading and parallel computing it can be useful to first appreciate the different levels of parallelism offered by Julia. We can divide them in three main categories :</source>
          <target state="translated">멀티 스레딩 및 병렬 컴퓨팅을 처음 사용하는 사람에게는 Julia가 제공하는 여러 수준의 병렬 처리를 먼저 이해하는 것이 유용 할 수 있습니다. 우리는 세 가지 주요 범주로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac8a874fecbfe223b7adee365914ddd8f5f53622" translate="yes" xml:space="preserve">
          <source>For non-numeric values, and for fewer or more than two arguments, the function &lt;code&gt;f&lt;/code&gt; remains undefined, and applying it will still result in a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">숫자가 아닌 값과 둘 이상의 인수에 대해 함수 &lt;code&gt;f&lt;/code&gt; 는 정의되지 않은 상태로 유지하며이를 적용하면 여전히 &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; 가 발생합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="235d743e9d754b970eea4778b2f329bcad575d20" translate="yes" xml:space="preserve">
          <source>For numbers, return $\left( |x|^p \right)^{1/p}$.</source>
          <target state="translated">숫자의 경우 $ \ left (| x | ^ p \ right) ^ {1 / p} $를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="00b6eae180d5b268722ff406a9cc534055692e79" translate="yes" xml:space="preserve">
          <source>For numbers, return $\left( |x|^p \right)^{1/p}$. This is equivalent to &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt;&lt;code&gt;norm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">숫자의 경우 $ \ left (| x | ^ p \ right) ^ {1 / p} $를 반환하십시오. 이것은 &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt; &lt;code&gt;norm&lt;/code&gt; &lt;/a&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d4f585a8f761ded66238973d0a20da01f3603d93" translate="yes" xml:space="preserve">
          <source>For one argument, this is the angle in radians between the positive &lt;em&gt;x&lt;/em&gt;-axis and the point (1, &lt;em&gt;y&lt;/em&gt;), returning a value in the interval $[-\pi/2, \pi/2]$.</source>
          <target state="translated">한 인수의 경우, 이것은 양의 &lt;em&gt;x&lt;/em&gt; 축과 점 (1, &lt;em&gt;y&lt;/em&gt; ) 사이의 라디안 각도이며 $ [-\ pi / 2, \ pi / 2] $ 간격의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cbe3a2c9ed0456d9a3ed109f08314c90a9a6e71e" translate="yes" xml:space="preserve">
          <source>For other types, &lt;code&gt;isequal&lt;/code&gt; defaults to calling &lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt;, so if you want to define equality for your own types then you only need to add a &lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt; method. If you define your own equality function, you should probably define a corresponding &lt;a href=&quot;../../base/base/index#Base.hash&quot;&gt;&lt;code&gt;hash&lt;/code&gt;&lt;/a&gt; method to ensure that &lt;code&gt;isequal(x,y)&lt;/code&gt; implies &lt;code&gt;hash(x) == hash(y)&lt;/code&gt;.</source>
          <target state="translated">다른 유형의 경우 &lt;code&gt;isequal&lt;/code&gt; 의 기본값은 &lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt; 를 호출 하므로 고유 한 유형에 대해 동등성을 정의하려면 &lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt; 메소드 만 추가하면됩니다 . 당신이 당신의 자신의 평등 함수를 정의하는 경우, 당신은 아마 해당 정의해야 &lt;a href=&quot;../../base/base/index#Base.hash&quot;&gt; &lt;code&gt;hash&lt;/code&gt; &lt;/a&gt; 을 보장하기 위하여 방법을 &lt;code&gt;isequal(x,y)&lt;/code&gt; 을 의미한다 &lt;code&gt;hash(x) == hash(y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c2f4b9050307c80e2b4e5b109845a6af03029a8" translate="yes" xml:space="preserve">
          <source>For real or complex floating-point values, if an &lt;code&gt;atol &amp;gt; 0&lt;/code&gt; is not specified, &lt;code&gt;rtol&lt;/code&gt; defaults to the square root of &lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt; of the type of &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;, whichever is bigger (least precise). This corresponds to requiring equality of about half of the significand digits. Otherwise, e.g. for integer arguments or if an &lt;code&gt;atol &amp;gt; 0&lt;/code&gt; is supplied, &lt;code&gt;rtol&lt;/code&gt; defaults to zero.</source>
          <target state="translated">실수 또는 복잡한 부동 소수점 값의 경우, &lt;code&gt;atol &amp;gt; 0&lt;/code&gt; 지정하지 않으면 &lt;code&gt;rtol&lt;/code&gt; 의 기본값 은 &lt;code&gt;x&lt;/code&gt; 또는 &lt;code&gt;y&lt;/code&gt; 유형의 &lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt; &lt;code&gt;eps&lt;/code&gt; &lt;/a&gt; 의 제곱근 중 큰 값 (가장 작은 값)입니다. 이는 유효 숫자의 절반 정도의 동등성을 요구하는 것에 해당합니다. 그렇지 않으면, 예를 들어 정수 인수 또는 &lt;code&gt;atol &amp;gt; 0&lt;/code&gt; 이 제공되면 &lt;code&gt;rtol&lt;/code&gt; 의 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="d58b65ff0e6e435abbaf14887e067d0c31d3520b" translate="yes" xml:space="preserve">
          <source>For reasons of length the results are not shown here, but you may wish to try this yourself. Because the type is fully-specified in the first case, the compiler doesn't need to generate any code to resolve the type at run-time. This results in shorter and faster code.</source>
          <target state="translated">길이가 길면 여기에 결과가 표시되지 않지만 직접 시도해 볼 수도 있습니다. 첫 번째 경우 형식이 완전히 지정되었으므로 컴파일러는 런타임에 형식을 확인하기 위해 코드를 생성 할 필요가 없습니다. 이로 인해 코드가 짧아지고 빨라집니다.</target>
        </trans-unit>
        <trans-unit id="6fc874bd7cd4d5b9abffad50a8cc5e9ee8fcd173" translate="yes" xml:space="preserve">
          <source>For rectangular &lt;code&gt;A&lt;/code&gt; the result is the minimum-norm least squares solution computed by a pivoted QR factorization of &lt;code&gt;A&lt;/code&gt; and a rank estimate of &lt;code&gt;A&lt;/code&gt; based on the R factor.</source>
          <target state="translated">직사각형 들어 결과의 피봇 QR 인수 분해에 의해 계산 된 최소 표준 최소 제곱 솔루션 및 랭크 예측 는 R 팩터에 기초. &lt;code&gt;A&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="912d3fe9f2697c548ca0705aab244457023707b1" translate="yes" xml:space="preserve">
          <source>For simple functions, it is often clearer to mention the role of the arguments directly in the description of the function's purpose. An argument list would only repeat information already provided elsewhere. However, providing an argument list can be a good idea for complex functions with many arguments (in particular keyword arguments). In that case, insert it after the general description of the function, under an &lt;code&gt;# Arguments&lt;/code&gt; header, with one &lt;code&gt;-&lt;/code&gt; bullet for each argument. The list should mention the types and default values (if any) of the arguments:</source>
          <target state="translated">간단한 함수의 경우 함수의 목적을 설명 할 때 인수의 역할을 직접 언급하는 것이 더 분명합니다. 인수 목록은 다른 곳에 이미 제공된 정보 만 반복합니다. 그러나 인수 목록을 제공하는 것은 많은 인수 (특히 키워드 인수)가있는 복잡한 함수에 유용 할 수 있습니다. 그 경우에, 아래의 함수의 일반적인 설명 후에 삽입 &lt;code&gt;# Arguments&lt;/code&gt; 하나 헤더 &lt;code&gt;-&lt;/code&gt; 각각의 인자에 대한 탄환. 이 목록에는 인수의 유형과 기본값 (있는 경우)이 언급되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1ea7196a777e8e9b741754a756a982ecdc4df126" translate="yes" xml:space="preserve">
          <source>For simple index types, it defers to the unexported &lt;code&gt;Base.to_index(A, i)&lt;/code&gt; to process each index &lt;code&gt;i&lt;/code&gt;. While this internal function is not intended to be called directly, &lt;code&gt;Base.to_index&lt;/code&gt; may be extended by custom array or index types to provide custom indexing behaviors.</source>
          <target state="translated">간단한 인덱스 유형의 경우, 익스포트되지 &lt;code&gt;Base.to_index(A, i)&lt;/code&gt; 를 지연시켜 각 인덱스 &lt;code&gt;i&lt;/code&gt; 를 처리합니다 . 이 내부 함수를 직접 호출 할 수는 없지만 사용자 정의 색인 동작을 제공하기 위해 사용자 정의 배열 또는 색인 유형으로 &lt;code&gt;Base.to_index&lt;/code&gt; 를 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53b19a276cd1b474618ba84687e1e90b947ee82e" translate="yes" xml:space="preserve">
          <source>For situations where a value &lt;code&gt;x&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; exists only sometimes, the &lt;code&gt;Union{T, Nothing}&lt;/code&gt; type can be used for function arguments, object fields and array element types as the equivalent of &lt;a href=&quot;https://en.wikipedia.org/wiki/Nullable_type&quot;&gt;&lt;code&gt;Nullable&lt;/code&gt;, &lt;code&gt;Option&lt;/code&gt; or &lt;code&gt;Maybe&lt;/code&gt;&lt;/a&gt; in other languages. If the value itself can be &lt;code&gt;nothing&lt;/code&gt; (notably, when &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Any&lt;/code&gt;), the &lt;code&gt;Union{Some{T}, Nothing}&lt;/code&gt; type is more appropriate since &lt;code&gt;x == nothing&lt;/code&gt; then indicates the absence of a value, and &lt;code&gt;x == Some(nothing)&lt;/code&gt; indicates the presence of a value equal to &lt;code&gt;nothing&lt;/code&gt;. The &lt;a href=&quot;../../base/base/index#Base.something&quot;&gt;&lt;code&gt;something&lt;/code&gt;&lt;/a&gt; function allows unwrapping &lt;code&gt;Some&lt;/code&gt; objects and using a default value instead of &lt;code&gt;nothing&lt;/code&gt; arguments. Note that the compiler is able to generate efficient code when working with &lt;code&gt;Union{T, Nothing}&lt;/code&gt; arguments or fields.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형의 &lt;code&gt;x&lt;/code&gt; 값 이 가끔 존재하는 경우 &lt;code&gt;Union{T, Nothing}&lt;/code&gt; 유형은 함수 인수, 객체 필드 및 배열 요소 유형에 &lt;a href=&quot;https://en.wikipedia.org/wiki/Nullable_type&quot;&gt; &lt;code&gt;Nullable&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;Option&lt;/code&gt; 또는 &lt;code&gt;Maybe&lt;/code&gt; 와 다른 언어 로 사용될 수 있습니다 . 값 자체가 &lt;code&gt;nothing&lt;/code&gt; 될 수 없는 경우 (특히 &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;Any&lt;/code&gt; 일 때 ) &lt;code&gt;x == nothing&lt;/code&gt; 이기 때문에 &lt;code&gt;Union{Some{T}, Nothing}&lt;/code&gt; 유형이 더 적합 하며 &lt;code&gt;x == Some(nothing)&lt;/code&gt; 값의 존재를 나타내는 동일한 &lt;code&gt;nothing&lt;/code&gt; . &lt;a href=&quot;../../base/base/index#Base.something&quot;&gt; &lt;code&gt;something&lt;/code&gt; &lt;/a&gt;함수를 풀기 수 있습니다 &lt;code&gt;Some&lt;/code&gt; 개체를하고 대신 기본값을 사용하여 &lt;code&gt;nothing&lt;/code&gt; 인수. 컴파일러는 &lt;code&gt;Union{T, Nothing}&lt;/code&gt; 인수 또는 필드로 작업 할 때 효율적인 코드를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43a7de4a7810165537aadc6250e15a8a55f9a88d" translate="yes" xml:space="preserve">
          <source>For some types which &quot;wrap&quot; other values, the constructor may wrap its argument inside a new object even if it is already of the requested type. For example &lt;code&gt;Some(x)&lt;/code&gt; wraps &lt;code&gt;x&lt;/code&gt; to indicate that a value is present (in a context where the result might be a &lt;code&gt;Some&lt;/code&gt; or &lt;code&gt;nothing&lt;/code&gt;). However, &lt;code&gt;x&lt;/code&gt; itself might be the object &lt;code&gt;Some(y)&lt;/code&gt;, in which case the result is &lt;code&gt;Some(Some(y))&lt;/code&gt;, with two levels of wrapping. &lt;code&gt;convert(Some, x)&lt;/code&gt;, on the other hand, would just return &lt;code&gt;x&lt;/code&gt; since it is already a &lt;code&gt;Some&lt;/code&gt;.</source>
          <target state="translated">다른 값을 &quot;랩핑&quot;하는 일부 유형의 경우 생성자는 이미 요청 된 유형 인 경우에도 인수를 새 객체로 래핑 할 수 있습니다. 예를 들어 &lt;code&gt;Some(x)&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; 가 래핑 되어 값이 있음을 나타냅니다 (결과가 &lt;code&gt;Some&lt;/code&gt; 또는 &lt;code&gt;nothing&lt;/code&gt; 일 수있는 컨텍스트에서 ). 그러나 &lt;code&gt;x&lt;/code&gt; 자체는 &lt;code&gt;Some(y)&lt;/code&gt; 객체 일 수 있으며, 이 경우 결과는 &lt;code&gt;Some(Some(y))&lt;/code&gt; 이며 두 가지 수준으로 줄 바꿈됩니다. 반면 &lt;code&gt;convert(Some, x)&lt;/code&gt; 는 이미 &lt;code&gt;Some&lt;/code&gt; 이므로 &lt;code&gt;x&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="47046f98397f6383243a7899dc2654cd12e6fb38" translate="yes" xml:space="preserve">
          <source>For some types, the machinery to &quot;fuse&quot; operations across nested levels of broadcasting is not available or could be done more efficiently incrementally. In such cases, you may need or want to evaluate &lt;code&gt;x .* (x .+ 1)&lt;/code&gt; as if it had been written &lt;code&gt;broadcast(*, x, broadcast(+, x, 1))&lt;/code&gt;, where the inner operation is evaluated before tackling the outer operation. This sort of eager operation is directly supported by a bit of indirection; instead of directly constructing &lt;code&gt;Broadcasted&lt;/code&gt; objects, Julia lowers the fused expression &lt;code&gt;x .* (x .+ 1)&lt;/code&gt; to &lt;code&gt;Broadcast.broadcasted(*, x, Broadcast.broadcasted(+, x, 1))&lt;/code&gt;. Now, by default, &lt;code&gt;broadcasted&lt;/code&gt; just calls the &lt;code&gt;Broadcasted&lt;/code&gt; constructor to create the lazy representation of the fused expression tree, but you can choose to override it for a particular combination of function and arguments.</source>
          <target state="translated">일부 유형의 경우 중첩 된 수준의 브로드 캐스트에서 &quot;퓨즈&quot;작업을 수행하는 기계를 사용할 수 없거나 점진적으로 더 효율적으로 수행 할 수 있습니다. 이러한 경우 &lt;code&gt;x .* (x .+ 1)&lt;/code&gt; &lt;code&gt;broadcast(*, x, broadcast(+, x, 1))&lt;/code&gt; 으로 작성된 것처럼 x. * (x. + 1) 을 평가해야 할 수도 있습니다 . 여기서 내부 작업은 태클 전에 평가됩니다. 외부 작업. 이런 종류의 간절한 작업은 약간의 간접적 인 지원으로 직접 지원됩니다. Julia는 &lt;code&gt;Broadcasted&lt;/code&gt; 객체 를 직접 구성하는 대신 융합 식 &lt;code&gt;x .* (x .+ 1)&lt;/code&gt; 을 &lt;code&gt;Broadcast.broadcasted(*, x, Broadcast.broadcasted(+, x, 1))&lt;/code&gt; 낮 춥니 다 . 이제 기본적으로 &lt;code&gt;broadcasted&lt;/code&gt; 는 &lt;code&gt;Broadcasted&lt;/code&gt; 캐스트 만 호출합니다. 융합 표현식 트리의 지연 표현을 작성하기위한 생성자이지만 함수와 인수의 특정 조합에 대해이를 겹쳐 쓰도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08e1dce6d1b843106b2d04dbdc79c4bf75d54149" translate="yes" xml:space="preserve">
          <source>For specializing broadcast on custom types, see</source>
          <target state="translated">사용자 정의 유형의 브로드 캐스트를 전문화하려면</target>
        </trans-unit>
        <trans-unit id="063287ad264bebc20a42dfa1890ff52805f2bb2c" translate="yes" xml:space="preserve">
          <source>For string arguments (&lt;code&gt;char*&lt;/code&gt;) the Julia type should be &lt;code&gt;Cstring&lt;/code&gt; (if NUL- terminated data is expected) or either &lt;code&gt;Ptr{Cchar}&lt;/code&gt; or &lt;code&gt;Ptr{UInt8}&lt;/code&gt; otherwise (these two pointer types have the same effect), as described above, not &lt;code&gt;String&lt;/code&gt;. Similarly, for array arguments (&lt;code&gt;T[]&lt;/code&gt; or &lt;code&gt;T*&lt;/code&gt;), the Julia type should again be &lt;code&gt;Ptr{T}&lt;/code&gt;, not &lt;code&gt;Vector{T}&lt;/code&gt;.</source>
          <target state="translated">문자열 인수 ( &lt;code&gt;char*&lt;/code&gt; )의 경우 Julia 유형은 &lt;code&gt;Cstring&lt;/code&gt; (NUL 종료 데이터가 예상되는 경우)이거나 &lt;code&gt;Ptr{Cchar}&lt;/code&gt; 또는 &lt;code&gt;Ptr{UInt8}&lt;/code&gt; 어야합니다. &lt;code&gt;String&lt;/code&gt; . 마찬가지로 배열 인수 ( &lt;code&gt;T[]&lt;/code&gt; 또는 &lt;code&gt;T*&lt;/code&gt; )의 경우 Julia 유형은 &lt;code&gt;Vector{T}&lt;/code&gt; 아니라 &lt;code&gt;Ptr{T}&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="1b3d0b51e2ef5e244357843af21db4dc2c7dfc01" translate="yes" xml:space="preserve">
          <source>For symmetric or Hermitian &lt;code&gt;A&lt;/code&gt;, an eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used, otherwise the scaling and squaring algorithm (see &lt;a href=&quot;#footnote-H05&quot;&gt;[H05]&lt;/a&gt;) is chosen.</source>
          <target state="translated">대칭 또는 은자 &lt;code&gt;A&lt;/code&gt; 의 경우 &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; 분해 ( eigen )가 사용되며, 그렇지 않으면 스케일링 및 제곱 알고리즘 ( &lt;a href=&quot;#footnote-H05&quot;&gt;[H05]&lt;/a&gt; 참조 )이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="f6c4a6da96174312b12bb84f60f8bf72388ffeca" translate="yes" xml:space="preserve">
          <source>For text I/O, use the &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;show&lt;/code&gt; methods, depending on your needs (see the documentation for these two methods for a detailed discussion of the difference between them):</source>
          <target state="translated">텍스트 I / O의 경우 필요에 따라 &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;show&lt;/code&gt; 방법을 사용하십시오 (두 방법의 차이점에 대한 자세한 내용은이 두 방법에 대한 설명서를 참조하십시오).</target>
        </trans-unit>
        <trans-unit id="205743ce47116c17ca0d1d16d7b760bea8f341c7" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;Squares&lt;/code&gt; iterable above, we can easily compute the &lt;code&gt;i&lt;/code&gt;th element of the sequence by squaring it. We can expose this as an indexing expression &lt;code&gt;S[i]&lt;/code&gt;. To opt into this behavior, &lt;code&gt;Squares&lt;/code&gt; simply needs to define &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">위에서 반복 가능한 &lt;code&gt;Squares&lt;/code&gt; 경우, 제곱 하여 시퀀스 의 &lt;code&gt;i&lt;/code&gt; 번째 요소를 쉽게 계산할 수 있습니다 . 이것을 인덱싱 표현식 &lt;code&gt;S[i]&lt;/code&gt; 로 노출시킬 수 있습니다 . 이 동작을 선택하려면 &lt;code&gt;Squares&lt;/code&gt; 에서&lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; 를 정의 하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="b61259c05b4f470d8af9ec6b5659050e33e9f420" translate="yes" xml:space="preserve">
          <source>For the day of week of &lt;code&gt;dt&lt;/code&gt;, return the total number of that day of the week in &lt;code&gt;dt&lt;/code&gt;'s month. Returns 4 or 5. Useful in temporal expressions for specifying the last day of a week in a month by including &lt;code&gt;dayofweekofmonth(dt) == daysofweekinmonth(dt)&lt;/code&gt; in the adjuster function.</source>
          <target state="translated">의 요일을 위해 &lt;code&gt;dt&lt;/code&gt; 에주의 그 날의 총 수를 반환 &lt;code&gt;dt&lt;/code&gt; 의 달. 4 또는 5를 리턴 합니다. adjuster 함수에 &lt;code&gt;dayofweekofmonth(dt) == daysofweekinmonth(dt)&lt;/code&gt; 를 포함시켜 한 달의 마지막 요일을 지정하기위한 임시 표현식에 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="fe652373fcfd70aa4cf5d9a9c42f569d7f7beb45" translate="yes" xml:space="preserve">
          <source>For the day of week of &lt;code&gt;dt&lt;/code&gt;, return which number it is in &lt;code&gt;dt&lt;/code&gt;'s month. So if the day of the week of &lt;code&gt;dt&lt;/code&gt; is Monday, then &lt;code&gt;1 = First Monday of the month, 2 = Second Monday of the month, etc.&lt;/code&gt; In the range 1:5.</source>
          <target state="translated">의 요일에 대한 &lt;code&gt;dt&lt;/code&gt; 는에 번호, 반환 &lt;code&gt;dt&lt;/code&gt; 의 달. 따라서 &lt;code&gt;dt&lt;/code&gt; 의 요일 이 월요일이면 &lt;code&gt;1 = First Monday of the month, 2 = Second Monday of the month, etc.&lt;/code&gt; 입니다. 1 : 5 범위입니다.</target>
        </trans-unit>
        <trans-unit id="652922b94585bcd03eb665e42d71bab0709ffc65" translate="yes" xml:space="preserve">
          <source>For the default constructor, exactly one argument must be supplied for each field:</source>
          <target state="translated">기본 생성자의 경우 각 필드마다 정확히 하나의 인수를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="56d79b9ca82aa7547916a2539b58ed4630995e94" translate="yes" xml:space="preserve">
          <source>For the remaining keyword arguments, see the documentation of &lt;a href=&quot;#Base.sort!&quot;&gt;&lt;code&gt;sort!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">나머지 키워드 인수에 대해서는 &lt;a href=&quot;#Base.sort!&quot;&gt; &lt;code&gt;sort!&lt;/code&gt; &lt;/a&gt; 문서를 참조하십시오 ! .</target>
        </trans-unit>
        <trans-unit id="b23a97c3c42b32c810ec362860430dab0f399881" translate="yes" xml:space="preserve">
          <source>For the same reason, contrary to logical operators presented above, the short-circuiting boolean operators &lt;a href=&quot;../../base/math/index#&amp;amp;&amp;amp;&quot;&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;||&lt;/code&gt; do not allow for &lt;code&gt;missing&lt;/code&gt; values in situations where the value of the operand determines whether the next operand is evaluated or not. For example</source>
          <target state="translated">같은 이유로 위에서 제시 한 논리 연산자와 달리 단락 부울 연산자 &lt;a href=&quot;../../base/math/index#&amp;amp;&amp;amp;&quot;&gt; &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;||&lt;/code&gt; 피연산자의 값이 다음 피연산자의 평가 여부를 결정하는 상황에서 결 &lt;code&gt;missing&lt;/code&gt; 허용 하지 마십시오. 예를 들어</target>
        </trans-unit>
        <trans-unit id="f6f2cb638bdf85d316fe3667be12ad3cf8fd1cb2" translate="yes" xml:space="preserve">
          <source>For the very common pattern usage pattern of</source>
          <target state="translated">매우 일반적인 패턴 사용 패턴</target>
        </trans-unit>
        <trans-unit id="abe66bccf2edc923b8619fe03afd5d016c3843ac" translate="yes" xml:space="preserve">
          <source>For these reasons, it's recommended that you try using the built-in sampling profiler before considering any alternatives.</source>
          <target state="translated">이러한 이유로 대안을 고려하기 전에 내장 샘플링 프로파일 러를 사용해 보는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="61eee68fc84c521e01e74ee4b3cb32a8a20b7707" translate="yes" xml:space="preserve">
          <source>For translating a C argument list to Julia:</source>
          <target state="translated">C 인수 목록을 Julia로 변환하는 경우 :</target>
        </trans-unit>
        <trans-unit id="0c8fe98556d87eebbe139565ad2035f5a8376ab0" translate="yes" xml:space="preserve">
          <source>For translating a C return type to Julia:</source>
          <target state="translated">C 리턴 유형을 Julia로 변환하는 경우 :</target>
        </trans-unit>
        <trans-unit id="f089947163c1743d34e858e0290c83835145a36d" translate="yes" xml:space="preserve">
          <source>For two arguments, this is the angle in radians between the positive &lt;em&gt;x&lt;/em&gt;-axis and the point (&lt;em&gt;x&lt;/em&gt;, &lt;em&gt;y&lt;/em&gt;), returning a value in the interval $[-\pi, \pi]$. This corresponds to a standard &lt;a href=&quot;https://en.wikipedia.org/wiki/Atan2&quot;&gt;&lt;code&gt;atan2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">두 개의 인수의 경우, 이것은 양의 &lt;em&gt;x&lt;/em&gt; 축과 점 ( &lt;em&gt;x&lt;/em&gt; , &lt;em&gt;y&lt;/em&gt; ) 사이의 라디안 각도이며 $ [-\ pi, \ pi] $ 간격의 값을 반환합니다. 이것은 표준 &lt;a href=&quot;https://en.wikipedia.org/wiki/Atan2&quot;&gt; &lt;code&gt;atan2&lt;/code&gt; &lt;/a&gt; 기능에 해당 합니다.</target>
        </trans-unit>
        <trans-unit id="8784f2a51d06748e116c26d584683c6da35029e2" translate="yes" xml:space="preserve">
          <source>For unbuffered channels returns &lt;code&gt;true&lt;/code&gt; if there are tasks waiting on a &lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt;&lt;code&gt;put!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버퍼링되지 않은 채널의 경우 &lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt; &lt;code&gt;put!&lt;/code&gt; &lt;/a&gt; 기다리는 작업이 있으면 &lt;code&gt;true&lt;/code&gt; 반환 합니다 ! .</target>
        </trans-unit>
        <trans-unit id="dcf07feef0790c851bc6f0a6f8cbac38791a64b9" translate="yes" xml:space="preserve">
          <source>For unbuffered channels, blocks until a &lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt;&lt;code&gt;put!&lt;/code&gt;&lt;/a&gt; is performed by a different task.</source>
          <target state="translated">버퍼링되지 않은 채널의 경우 &lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt; &lt;code&gt;put!&lt;/code&gt; &lt;/a&gt; 까지 차단합니다 ! 다른 작업으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="84b0a200921412bb65f21b5bb7c59da76c4bbed1" translate="yes" xml:space="preserve">
          <source>For unbuffered channels, blocks until a &lt;a href=&quot;#Base.take!-Tuple%7BChannel%7D&quot;&gt;&lt;code&gt;take!&lt;/code&gt;&lt;/a&gt; is performed by a different task.</source>
          <target state="translated">버퍼링되지 않은 채널의 경우 &lt;a href=&quot;#Base.take!-Tuple%7BChannel%7D&quot;&gt; &lt;code&gt;take!&lt;/code&gt; &lt;/a&gt; 나올 때까지 차단합니다 ! 다른 작업으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b5d88c03e115fa0e1f0ae726ca69a5946e7b8f3d" translate="yes" xml:space="preserve">
          <source>For variable &lt;code&gt;a&lt;/code&gt; and expression &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;a = b&lt;/code&gt; makes &lt;code&gt;a&lt;/code&gt; refer to the value of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">변수 및 식 &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;a = b&lt;/code&gt; 하게 &lt;code&gt;a&lt;/code&gt; 의 값을 참조 &lt;code&gt;b&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0a2988c23bad5d1f4419c0c3331b505d6761bfd4" translate="yes" xml:space="preserve">
          <source>For when a capture doesn't match, instead of a substring, &lt;code&gt;m.captures&lt;/code&gt; contains &lt;code&gt;nothing&lt;/code&gt; in that position, and &lt;code&gt;m.offsets&lt;/code&gt; has a zero offset (recall that indices in Julia are 1-based, so a zero offset into a string is invalid). Here is a pair of somewhat contrived examples:</source>
          <target state="translated">캡처 대신 문자열의 일치하지 않는 경우를 들어, &lt;code&gt;m.captures&lt;/code&gt; 는 포함되어 있지 않습니다 &lt;code&gt;nothing&lt;/code&gt; 그 위치에서, 그리고 &lt;code&gt;m.offsets&lt;/code&gt; 는 문자열 인에 제로 오프셋 있도록 줄리아의 인덱스는 1-를 기반으로하는 제로 오프셋 (리콜을 가지고 유효하지 않습니다). 다음은 다소 고안된 예입니다.</target>
        </trans-unit>
        <trans-unit id="cdc4b17a13e956b864dfd62e85ad672e28429820" translate="yes" xml:space="preserve">
          <source>Force a GC run</source>
          <target state="translated">GC 실행 강제</target>
        </trans-unit>
        <trans-unit id="5eb175b9460612a847c5831f8d611666f7e129b1" translate="yes" xml:space="preserve">
          <source>Forces</source>
          <target state="translated">Forces</target>
        </trans-unit>
        <trans-unit id="08bb485a70c09a4b008d8b79ee39bee0f080480a" translate="yes" xml:space="preserve">
          <source>Forces synchronization between the in-memory version of a memory-mapped &lt;code&gt;Array&lt;/code&gt; or &lt;a href=&quot;../../base/arrays/index#Base.BitArray&quot;&gt;&lt;code&gt;BitArray&lt;/code&gt;&lt;/a&gt; and the on-disk version.</source>
          <target state="translated">메모리 매핑 된 &lt;code&gt;Array&lt;/code&gt; 또는 &lt;a href=&quot;../../base/arrays/index#Base.BitArray&quot;&gt; &lt;code&gt;BitArray&lt;/code&gt; &lt;/a&gt; 의 메모리 내 버전 과 디스크 내 버전을 동기화 합니다.</target>
        </trans-unit>
        <trans-unit id="a4b44623e8c8994cfd237bbb5a20500862bde2d9" translate="yes" xml:space="preserve">
          <source>Fork And Knife</source>
          <target state="translated">포크와 나이프</target>
        </trans-unit>
        <trans-unit id="cac22bd0e8a69bd849b7be8d79bbdfbf8b44d9d5" translate="yes" xml:space="preserve">
          <source>Forking</source>
          <target state="translated">Forking</target>
        </trans-unit>
        <trans-unit id="050d7641601e8d3bdebb15e95cb05f81983e6de8" translate="yes" xml:space="preserve">
          <source>Format the &lt;code&gt;tok&lt;/code&gt; token from &lt;code&gt;dt&lt;/code&gt; and write it to &lt;code&gt;io&lt;/code&gt;. The formatting can be based on &lt;code&gt;locale&lt;/code&gt;.</source>
          <target state="translated">형식 &lt;code&gt;tok&lt;/code&gt; 에서 토큰 &lt;code&gt;dt&lt;/code&gt; 하고에 기록 &lt;code&gt;io&lt;/code&gt; . 서식은 &lt;code&gt;locale&lt;/code&gt; 기반으로 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5449b0de438e10172cfa72d13dabc8ee40d61810" translate="yes" xml:space="preserve">
          <source>Fortran compilers &lt;em&gt;may&lt;/em&gt; also add other hidden arguments for pointers, assumed-shape (&lt;code&gt;:&lt;/code&gt;) and assumed-size (&lt;code&gt;*&lt;/code&gt;) arrays. Such behaviour can be avoided by using &lt;code&gt;ISO_C_BINDING&lt;/code&gt; and including &lt;code&gt;bind(c)&lt;/code&gt; in the definition of the subroutine, which is strongly recommended for interoperable code. In this case there will be no hidden arguments, at the cost of some language features (e.g. only &lt;code&gt;character(len=1)&lt;/code&gt; will be permitted to pass strings).</source>
          <target state="translated">포트란 컴파일러는 &lt;em&gt;할 수있다&lt;/em&gt; (또한 포인터에 대한 다른 숨겨진 인수를 추가, 모양 가정 &lt;code&gt;:&lt;/code&gt; ) 및 가정 크기 ( &lt;code&gt;*&lt;/code&gt; ) 배열을. 이러한 동작은 &lt;code&gt;ISO_C_BINDING&lt;/code&gt; 을 사용 하고 서브 루틴 정의에 &lt;code&gt;bind(c)&lt;/code&gt; 를 포함 하여 피할 수 있으며 , 상호 운용 가능한 코드에 강력히 권장됩니다. 이 경우 일부 언어 기능을 사용하여 숨겨진 인수가 없습니다 (예 : &lt;code&gt;character(len=1)&lt;/code&gt; 만 문자열을 전달할 수 있음).</target>
        </trans-unit>
        <trans-unit id="a0484116def6ba2539f3b9f9921bd8b4ba22a4aa" translate="yes" xml:space="preserve">
          <source>Fortran name</source>
          <target state="translated">포트란 이름</target>
        </trans-unit>
        <trans-unit id="16c35d1374b93a7d00d34b68d3e6ad6a2c21c760" translate="yes" xml:space="preserve">
          <source>Fortunately, many useful parallel computations do not require data movement. A common example is a Monte Carlo simulation, where multiple processes can handle independent simulation trials simultaneously. We can use &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt; to flip coins on two processes. First, write the following function in &lt;code&gt;count_heads.jl&lt;/code&gt;:</source>
          <target state="translated">다행히도 많은 유용한 병렬 계산에는 데이터 이동이 필요하지 않습니다. 일반적인 예는 여러 프로세스가 독립적 인 시뮬레이션 시험을 동시에 처리 할 수있는 Monte Carlo 시뮬레이션입니다. &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt; 을 사용 하여 두 프로세스에서 동전을 뒤집을 수 있습니다 . 먼저 &lt;code&gt;count_heads.jl&lt;/code&gt; 에 다음 함수를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="5dd1ed1b5512a22fba4de952e82beaad9990da5b" translate="yes" xml:space="preserve">
          <source>Forward delete one character (when buffer has text)</source>
          <target state="translated">한 문자 앞으로 삭제 (버퍼에 텍스트가있는 경우)</target>
        </trans-unit>
        <trans-unit id="d2bd5de8c2484ca6755e34f338af3268021c0a12" translate="yes" xml:space="preserve">
          <source>Forward delete the next word</source>
          <target state="translated">다음 단어를 앞으로 삭제</target>
        </trans-unit>
        <trans-unit id="a187c3285151f39c70caaf5e477c6e87663d3ef4" translate="yes" xml:space="preserve">
          <source>Fountain</source>
          <target state="translated">Fountain</target>
        </trans-unit>
        <trans-unit id="4ab98d03a72763b8222b6d8722ded7966bf98d76" translate="yes" xml:space="preserve">
          <source>Four Leaf Clover</source>
          <target state="translated">네 잎 클로버</target>
        </trans-unit>
        <trans-unit id="2b13f83d35f7fc73ce97c8b26bfe724907153aae" translate="yes" xml:space="preserve">
          <source>Four-Per-Em Space</source>
          <target state="translated">4 개 공간</target>
        </trans-unit>
        <trans-unit id="73c09759c4507af6948adebc3787e93351d4acda" translate="yes" xml:space="preserve">
          <source>Fourth Root</source>
          <target state="translated">넷째 루트</target>
        </trans-unit>
        <trans-unit id="c54d686ebd31bf6296f3ac8e3de5cdba7b0fe495" translate="yes" xml:space="preserve">
          <source>Fraction Numerator One</source>
          <target state="translated">분수 분자 하나</target>
        </trans-unit>
        <trans-unit id="9f62f41c6fc2c6a6ef7e8630ebef06bc253ed2e9" translate="yes" xml:space="preserve">
          <source>Fractions</source>
          <target state="translated">Fractions</target>
        </trans-unit>
        <trans-unit id="1a4eb1bfc4ceb4284f084ca37c8edbaed934f05c" translate="yes" xml:space="preserve">
          <source>Free and open source (&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/LICENSE.md&quot;&gt;MIT licensed&lt;/a&gt;)</source>
          <target state="translated">무료 및 오픈 소스 ( &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/LICENSE.md&quot;&gt;MIT 라이선스&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="d150e0aaee05d4d7cee80412f889a1b8c7404089" translate="yes" xml:space="preserve">
          <source>French Fries</source>
          <target state="translated">감자 튀김</target>
        </trans-unit>
        <trans-unit id="d790b402d79ac1a723c790313bcd679999474630" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions</source>
          <target state="translated">자주 묻는 질문</target>
        </trans-unit>
        <trans-unit id="2e42fd5fd57e2eddb93e306ecceb863efd070156" translate="yes" xml:space="preserve">
          <source>Fried Shrimp</source>
          <target state="translated">새우 튀김</target>
        </trans-unit>
        <trans-unit id="d25d30098e10e7246e59352c44263a5bb1531117" translate="yes" xml:space="preserve">
          <source>Frog Face</source>
          <target state="translated">개구리 얼굴</target>
        </trans-unit>
        <trans-unit id="ec026c33022b335b80bd8f0e64407b39229b2c88" translate="yes" xml:space="preserve">
          <source>From the caller's perspective, this is identical to a regular function; in fact, you don't have to know whether you're calling a regular or generated function. Let's see how &lt;code&gt;foo&lt;/code&gt; behaves:</source>
          <target state="translated">호출자의 관점에서 이것은 일반 함수와 동일합니다. 사실, 정규 함수 또는 생성 된 함수를 호출하는지 여부를 알 필요가 없습니다. &lt;code&gt;foo&lt;/code&gt; 가 어떻게 동작 하는지 봅시다 :</target>
        </trans-unit>
        <trans-unit id="ca77e2b5e973595e2f2f608f9805266ed582b1b8" translate="yes" xml:space="preserve">
          <source>From these definitions, one obtains the following behavior:</source>
          <target state="translated">이러한 정의에서 다음과 같은 동작을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="b422184537e8dbfbffe465f2c662481e754378a9" translate="yes" xml:space="preserve">
          <source>Front-Facing Baby Chick</source>
          <target state="translated">정면 아기 병아리</target>
        </trans-unit>
        <trans-unit id="6d0c809a561642fe04a663534c34c6a988c1f63d" translate="yes" xml:space="preserve">
          <source>Frown</source>
          <target state="translated">Frown</target>
        </trans-unit>
        <trans-unit id="fb52dd543cda4930bef0a7aed25ec2307f4f2ed5" translate="yes" xml:space="preserve">
          <source>Frowning Face With Open Mouth</source>
          <target state="translated">입을 벌리고 얼굴을 찡그림</target>
        </trans-unit>
        <trans-unit id="3b8ae9bdd856b92028c18db46fbc39d04889c711" translate="yes" xml:space="preserve">
          <source>Fuel Pump</source>
          <target state="translated">연료 펌프</target>
        </trans-unit>
        <trans-unit id="1dc013b6064daee6213fd09ae3d5ea49df1bdb94" translate="yes" xml:space="preserve">
          <source>Full Block</source>
          <target state="translated">풀 블록</target>
        </trans-unit>
        <trans-unit id="91e2750218473c3715d4640558a3e864dd2b4c5e" translate="yes" xml:space="preserve">
          <source>Full Moon Symbol</source>
          <target state="translated">보름달 기호</target>
        </trans-unit>
        <trans-unit id="32a64f880ba20480782d9f08062e23749801ebec" translate="yes" xml:space="preserve">
          <source>Full Moon With Face</source>
          <target state="translated">얼굴 보름달</target>
        </trans-unit>
        <trans-unit id="11342457efd18f569b992724d11b3a2d8832ce4b" translate="yes" xml:space="preserve">
          <source>Full Outer Join</source>
          <target state="translated">완전 외부 조인</target>
        </trans-unit>
        <trans-unit id="db63acc70bb8aace65207096c8aa56a922c0d72f" translate="yes" xml:space="preserve">
          <source>Fully implemented by:</source>
          <target state="translated">다음에 의해 완전히 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="95054001cf3f6f293128fbac88deaae7d22cc115" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;abmult&lt;/code&gt; returns a function &lt;code&gt;f&lt;/code&gt; that multiplies its argument by the absolute value of &lt;code&gt;r&lt;/code&gt;. The inner function assigned to &lt;code&gt;f&lt;/code&gt; is called a &quot;closure&quot;. Inner functions are also used by the language for &lt;code&gt;do&lt;/code&gt;-blocks and for generator expressions.</source>
          <target state="translated">함수 &lt;code&gt;abmult&lt;/code&gt; 는 인수 &lt;code&gt;r&lt;/code&gt; 에 절대 값 r 을 곱하는 함수 &lt;code&gt;f&lt;/code&gt; 를 반환합니다 . &lt;code&gt;f&lt;/code&gt; 에 지정된 내부 기능을 &quot;클로저&quot;라고합니다. 내부 함수는 언어에서 &lt;code&gt;do&lt;/code&gt; - blocks 및 생성기 표현에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7697b6877e6664e26745e5f66999b4cfefbd165c" translate="yes" xml:space="preserve">
          <source>Function body starting with &lt;code&gt;Body::UNION{T1,T2})&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Body::UNION{T1,T2})&lt;/code&gt; 시작하는 함수 본문</target>
        </trans-unit>
        <trans-unit id="aa0b7e8266dfec8d33dbc09471974455072b6005" translate="yes" xml:space="preserve">
          <source>Function chaining (sometimes called &quot;piping&quot; or &quot;using a pipe&quot; to send data to a subsequent function) is when you apply a function to the previous function's output:</source>
          <target state="translated">함수 체인 (때때로 &quot;파이핑&quot;또는 &quot;파이프를 사용하여&quot;을 사용하여 후속 함수로 데이터 전송)은 이전 함수의 출력에 함수를 적용 할 때입니다.</target>
        </trans-unit>
        <trans-unit id="f28a100a083f8e25a3bc12e6db11fea904564f3f" translate="yes" xml:space="preserve">
          <source>Function composition and piping</source>
          <target state="translated">기능 구성 및 배관</target>
        </trans-unit>
        <trans-unit id="faa5a28142e8b8d79608d822a7ee2fc012117fa0" translate="yes" xml:space="preserve">
          <source>Function composition is when you combine functions together and apply the resulting composition to arguments. You use the function composition operator (&lt;code&gt;∘&lt;/code&gt;) to compose the functions, so &lt;code&gt;(f ∘ g)(args...)&lt;/code&gt; is the same as &lt;code&gt;f(g(args...))&lt;/code&gt;.</source>
          <target state="translated">함수 구성은 함수를 함께 결합하고 결과 구성을 인수에 적용하는 것입니다. 함수 구성 연산자 ( &lt;code&gt;∘&lt;/code&gt; )를 사용하여 함수 를 구성하므로 &lt;code&gt;(f ∘ g)(args...)&lt;/code&gt; 는 &lt;code&gt;f(g(args...))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be8cbdb67375da79abe2b0143f8eebcc7cb99416" translate="yes" xml:space="preserve">
          <source>Function parameters can also be used to constrain the number of arguments that may be supplied to a &quot;varargs&quot; function (&lt;a href=&quot;../functions/index#Varargs-Functions-1&quot;&gt;Varargs Functions&lt;/a&gt;). The notation &lt;code&gt;Vararg{T,N}&lt;/code&gt; is used to indicate such a constraint. For example:</source>
          <target state="translated">함수 매개 변수를 사용하여 &quot;varargs&quot;함수 ( &lt;a href=&quot;../functions/index#Varargs-Functions-1&quot;&gt;Varargs Functions&lt;/a&gt; )에 제공 될 수있는 인수의 수를 제한 할 수도 있습니다 . &lt;code&gt;Vararg{T,N}&lt;/code&gt; 표기법 은 이러한 제한 조건을 나타내는 데 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c748f42ec833ed8f7d97105f385770153e5f3a88" translate="yes" xml:space="preserve">
          <source>Function sets &lt;code&gt;+refs/*:refs/*&lt;/code&gt; refspecs and &lt;code&gt;mirror&lt;/code&gt; flag for remote reference.</source>
          <target state="translated">기능은 원격 참조를 위해 &lt;code&gt;+refs/*:refs/*&lt;/code&gt; refspecs 및 &lt;code&gt;mirror&lt;/code&gt; 플래그를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="ea4be7f77276f932f73d95ac11b41c01bca27493" translate="yes" xml:space="preserve">
          <source>Function-like objects</source>
          <target state="translated">함수형 객체</target>
        </trans-unit>
        <trans-unit id="79fde2ac8490ff2b99ac9c9890e046fdff6e3659" translate="yes" xml:space="preserve">
          <source>Functionality</source>
          <target state="translated">Functionality</target>
        </trans-unit>
        <trans-unit id="eddb44c7165ef5eabc1df07ca23331299f12c1fa" translate="yes" xml:space="preserve">
          <source>Functionality for base-64 encoded strings and IO.</source>
          <target state="translated">base-64로 인코딩 된 문자열 및 IO를위한 기능.</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="53a4e15f59ddb4061325c79602aaccdf7b922b54" translate="yes" xml:space="preserve">
          <source>Functions &amp;amp; Methods</source>
          <target state="translated">기능 및 방법</target>
        </trans-unit>
        <trans-unit id="c13326dfc431675363c3f3a461ddb4d2e5748e9f" translate="yes" xml:space="preserve">
          <source>Functions &lt;a href=&quot;../../stdlib/distributed/index#Distributed.addprocs&quot;&gt;&lt;code&gt;addprocs&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/distributed/index#Distributed.rmprocs&quot;&gt;&lt;code&gt;rmprocs&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/distributed/index#Distributed.workers&quot;&gt;&lt;code&gt;workers&lt;/code&gt;&lt;/a&gt;, and others are available as a programmatic means of adding, removing and querying the processes in a cluster.</source>
          <target state="translated">&lt;a href=&quot;../../stdlib/distributed/index#Distributed.addprocs&quot;&gt; &lt;code&gt;addprocs&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../stdlib/distributed/index#Distributed.rmprocs&quot;&gt; &lt;code&gt;rmprocs&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../stdlib/distributed/index#Distributed.workers&quot;&gt; &lt;code&gt;workers&lt;/code&gt; &lt;/a&gt; 및 기타 함수 는 클러스터에서 프로세스를 추가, 제거 및 쿼리하는 프로그래밍 방식으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ff075e5c1729ce32f2f5738fecab65d263b0838" translate="yes" xml:space="preserve">
          <source>Functions &lt;code&gt;any&lt;/code&gt; and &lt;code&gt;all&lt;/code&gt; also follow the rules of three-valued logic, returning &lt;code&gt;missing&lt;/code&gt; when the result cannot be determined</source>
          <target state="translated">기능은 &lt;code&gt;any&lt;/code&gt; 및 &lt;code&gt;all&lt;/code&gt; 또한, 복귀 3 치 논리의 규칙을 따라야 &lt;code&gt;missing&lt;/code&gt; 결과를 확인할 수없는 경우</target>
        </trans-unit>
        <trans-unit id="a7372df3a40ed071a29722d4bc6498e66d76a5da" translate="yes" xml:space="preserve">
          <source>Functions and Methods</source>
          <target state="translated">기능과 방법</target>
        </trans-unit>
        <trans-unit id="7bb375b3fcf2e8e9d0dbcd433eb2746123db60e5" translate="yes" xml:space="preserve">
          <source>Functions are defined with the &lt;code&gt;function&lt;/code&gt; keyword:</source>
          <target state="translated">함수는 &lt;code&gt;function&lt;/code&gt; 키워드 로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="55e8c66bfd9e6c0e9dfa04cb544f8bb30a80231b" translate="yes" xml:space="preserve">
          <source>Functions in Julia are &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_citizen&quot;&gt;first-class objects&lt;/a&gt;: they can be assigned to variables, and called using the standard function call syntax from the variable they have been assigned to. They can be used as arguments, and they can be returned as values. They can also be created anonymously, without being given a name, using either of these syntaxes:</source>
          <target state="translated">Julia의 함수는 &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_citizen&quot;&gt;일류 객체입니다&lt;/a&gt; . 변수에 할당 할 수 있으며, 지정된 변수에서 표준 함수 호출 구문을 사용하여 호출 할 수 있습니다. 인수로 사용될 수 있으며 값으로 리턴 될 수 있습니다. 다음 구문 중 하나를 사용하여 이름을 지정하지 않고 익명으로 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c04e52a6c310e2a4baade48d1f42fd88819eec1a" translate="yes" xml:space="preserve">
          <source>Functions in Julia can be combined by composing or piping (chaining) them together.</source>
          <target state="translated">Julia의 기능은 함께 구성하거나 파이핑 (체인)하여 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ceeb1ec49508dede84853cbb0f013b3decdfa56c" translate="yes" xml:space="preserve">
          <source>Functions in Julia may have multiple implementations, known as methods. While it's good practice for generic functions to have a single purpose, Julia allows methods to be documented individually if necessary. In general, only the most generic method should be documented, or even the function itself (i.e. the object created without any methods by &lt;code&gt;function bar end&lt;/code&gt;). Specific methods should only be documented if their behaviour differs from the more generic ones. In any case, they should not repeat the information provided elsewhere. For example:</source>
          <target state="translated">Julia의 함수에는 메소드라는 여러 구현이있을 수 있습니다. 일반 함수는 단일 목적을 갖는 것이 좋지만 Julia는 필요한 경우 메소드를 개별적으로 문서화 할 수 있습니다. 일반적으로 가장 일반적인 방법 또는 기능 자체 만 문서화해야합니다 (예 : &lt;code&gt;function bar end&lt;/code&gt; 메서드없이 생성 된 객체 ). 구체적인 방법은 일반적인 방법과 다른 경우에만 문서화해야합니다. 어쨌든 그들은 다른 곳에서 제공된 정보를 반복해서는 안됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="820b3bd7ddec6937c4e242be1bbe2ab057c0ac78" translate="yes" xml:space="preserve">
          <source>Functions in Julia return values from their last expression or the &lt;code&gt;return&lt;/code&gt; keyword instead of listing the names of variables to return in the function definition (see &lt;a href=&quot;../functions/index#The-return-Keyword-1&quot;&gt;The return Keyword&lt;/a&gt; for details).</source>
          <target state="translated">Julia 의 함수는 함수 정의에 리턴 할 변수 이름을 나열하는 대신 마지막 표현식 또는 &lt;code&gt;return&lt;/code&gt; 키워드에서 값을 리턴합니다 (자세한 내용 &lt;a href=&quot;../functions/index#The-return-Keyword-1&quot;&gt;은 return 키워드&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="a59fb02f015778c14d39ec5b1bcf732d30a76ac1" translate="yes" xml:space="preserve">
          <source>Functions in Julia return values from their last expression(s) or the &lt;code&gt;return&lt;/code&gt; keyword. Multiple values can be returned from functions and assigned as tuples, e.g. &lt;code&gt;(a, b) = myfunction()&lt;/code&gt; or &lt;code&gt;a, b = myfunction()&lt;/code&gt;, instead of having to pass pointers to values as one would have to do in C/C++ (i.e. &lt;code&gt;a = myfunction(&amp;amp;b)&lt;/code&gt;.</source>
          <target state="translated">Julia의 함수는 마지막 표현식 또는 &lt;code&gt;return&lt;/code&gt; 키워드 에서 값을 반환 합니다. 함수에서 여러 값을 반환하고 튜플로 할당 할 수 있습니다 &lt;code&gt;(a, b) = myfunction()&lt;/code&gt; 예 : C / C ++에서와 같이 포인터를 값에 전달하는 대신 (a, b) = myfunction () 또는 &lt;code&gt;a, b = myfunction()&lt;/code&gt; 즉 &lt;code&gt;a = myfunction(&amp;amp;b)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a55840c344c2be9d92831007662fa28bbfaafd80" translate="yes" xml:space="preserve">
          <source>Functions like &lt;code&gt;strange_twos&lt;/code&gt; occur when dealing with data of uncertain type, for example data loaded from an input file that might contain either integers, floats, strings, or something else.</source>
          <target state="translated">&lt;code&gt;strange_twos&lt;/code&gt; 와 같은 함수 는 불확실한 유형의 데이터 (예 : 정수, 부동 소수점, 문자열 또는 다른 것을 포함 할 수있는 입력 파일에서로드 된 데이터)를 처리 할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7b33eb7808d1f3eaa212ba1f622374dd77c823c6" translate="yes" xml:space="preserve">
          <source>Functions on &lt;code&gt;Expr&lt;/code&gt;essions</source>
          <target state="translated">에 기능 &lt;code&gt;Expr&lt;/code&gt; essions</target>
        </trans-unit>
        <trans-unit id="8b8603c397ef929230aa5c590ebf0c5ec135d545" translate="yes" xml:space="preserve">
          <source>Functions pertaining to probability distributions are provided by the &lt;a href=&quot;https://github.com/JuliaStats/Distributions.jl&quot;&gt;Distributions package&lt;/a&gt;.</source>
          <target state="translated">확률 분포와 관련된 함수는 &lt;a href=&quot;https://github.com/JuliaStats/Distributions.jl&quot;&gt;분포 패키지에&lt;/a&gt; 의해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="07740f0b9c92a3b6637549532f0dfc491685de70" translate="yes" xml:space="preserve">
          <source>Functions that write to their arguments have names that end in &lt;code&gt;!&lt;/code&gt;. These are sometimes called &quot;mutating&quot; or &quot;in-place&quot; functions because they are intended to produce changes in their arguments after the function is called, not just return a value.</source>
          <target state="translated">인수에 쓰는 함수의 이름은 &lt;code&gt;!&lt;/code&gt; . 함수를 호출 한 후 값을 반환하는 것이 아니라 인수를 변경하기 위해 &quot;mutating&quot;또는 &quot;in-place&quot;함수라고도합니다.</target>
        </trans-unit>
        <trans-unit id="9cba6354edf31323e29d861220b894beb53b62d4" translate="yes" xml:space="preserve">
          <source>Functions with keyword arguments are defined using a semicolon in the signature:</source>
          <target state="translated">키워드 인수가있는 함수는 서명에 세미콜론을 사용하여 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="bafd4b54282745a2bed1442852b73f4b3189a77a" translate="yes" xml:space="preserve">
          <source>Further Reading</source>
          <target state="translated">추가 자료</target>
        </trans-unit>
        <trans-unit id="0132f20ae5d3a74b84246e40987da84635bfd3d0" translate="yes" xml:space="preserve">
          <source>Furthermore, &quot;dotted&quot; updating operators like &lt;code&gt;a .+= b&lt;/code&gt; (or &lt;code&gt;@. a += b&lt;/code&gt;) are parsed as &lt;code&gt;a .= a .+ b&lt;/code&gt;, where &lt;code&gt;.=&lt;/code&gt; is a fused &lt;em&gt;in-place&lt;/em&gt; assignment operation (see the &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;dot syntax documentation&lt;/a&gt;).</source>
          <target state="translated">또한 &lt;code&gt;a .+= b&lt;/code&gt; (또는 &lt;code&gt;@. a += b&lt;/code&gt; ) 와 같은 &quot;점&quot;업데이트 연산자는 a. = a. + b 로 구문 분석됩니다 &lt;code&gt;a .= a .+ b&lt;/code&gt; 여기서 &lt;code&gt;.=&lt;/code&gt; 는 통합 된 &lt;em&gt;내부&lt;/em&gt; 할당 조작입니다 ( &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;점 구문 문서&lt;/a&gt; 참조). ).</target>
        </trans-unit>
        <trans-unit id="9d0dab03985e67ddbff313bf737b40f319ace224" translate="yes" xml:space="preserve">
          <source>Furthermore, the iterable object splatted into a function call need not be a tuple:</source>
          <target state="translated">또한 함수 호출로 스플릿 된 반복 가능한 객체는 튜플 일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="0e833ac5a09d0da4e04120e7544830f8a65151fd" translate="yes" xml:space="preserve">
          <source>G. W. Stewart, &quot;Rank Degeneracy&quot;, SIAM Journal on Scientific and Statistical Computing, 5(2), 1984, 403-413. &lt;a href=&quot;http://epubs.siam.org/doi/abs/10.1137/0905030&quot;&gt;doi:10.1137/0905030&lt;/a&gt;</source>
          <target state="translated">GW Stewart, &quot;순위 변성&quot;, 과학 통계 통계에 관한 SIAM 저널, 5 (2), 1984, 403-413. &lt;a href=&quot;http://epubs.siam.org/doi/abs/10.1137/0905030&quot;&gt;도 : 10.1137 / 0905030&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="99a3e18460e703b6b52b26b4155c66c3e3ba24bc" translate="yes" xml:space="preserve">
          <source>GC</source>
          <target state="translated">GC</target>
        </trans-unit>
        <trans-unit id="153d4c166a2f860e5ac33c697533af00d178259a" translate="yes" xml:space="preserve">
          <source>GC.@preserve</source>
          <target state="translated">GC.@preserve</target>
        </trans-unit>
        <trans-unit id="3897445415fe5ec5c17d947d2f396ecb73cfab7e" translate="yes" xml:space="preserve">
          <source>GC.enable()</source>
          <target state="translated">GC.enable()</target>
        </trans-unit>
        <trans-unit id="f7f51a07b89aa04e176b4dce9ba6e667279a4cac" translate="yes" xml:space="preserve">
          <source>GC.gc()</source>
          <target state="translated">GC.gc()</target>
        </trans-unit>
        <trans-unit id="dd04fdce0b5db2163f133667347720589a61611d" translate="yes" xml:space="preserve">
          <source>GMP.BigInt</source>
          <target state="translated">GMP.BigInt</target>
        </trans-unit>
        <trans-unit id="ec181f943ce9eb84bc41a51f14f715a4b73d4e15" translate="yes" xml:space="preserve">
          <source>GMP.BigInt()</source>
          <target state="translated">GMP.BigInt()</target>
        </trans-unit>
        <trans-unit id="1f1b07ba1d3f58af4c465921af5b16d96fd0bc35" translate="yes" xml:space="preserve">
          <source>GT</source>
          <target state="translated">GT</target>
        </trans-unit>
        <trans-unit id="f3b1d13cf7d8da8c19344c722b6886a02e91434d" translate="yes" xml:space="preserve">
          <source>Game Die</source>
          <target state="translated">게임 다이</target>
        </trans-unit>
        <trans-unit id="23e043a9ee4de0e7b0c73093401aa0bca44ab49b" translate="yes" xml:space="preserve">
          <source>Garbage Collection Safety</source>
          <target state="translated">쓰레기 수거 안전</target>
        </trans-unit>
        <trans-unit id="d6d5b4be825ce665265510009390d4b69a148c2b" translate="yes" xml:space="preserve">
          <source>Garbage-collection handle for the return value from &lt;code&gt;@cfunction&lt;/code&gt; when the first argument is annotated with '$'. Like all &lt;code&gt;cfunction&lt;/code&gt; handles, it should be passed to &lt;code&gt;ccall&lt;/code&gt; as a &lt;code&gt;Ptr{Cvoid}&lt;/code&gt;, and will be converted automatically at the call site to the appropriate type.</source>
          <target state="translated">첫 번째 인수에 '$'로 주석을 달 때 &lt;code&gt;@cfunction&lt;/code&gt; 의 리턴 값에 대한 가비지 콜렉션 핸들 . 모든처럼 &lt;code&gt;cfunction&lt;/code&gt; 의 핸들, 그것을 전달해야 &lt;code&gt;ccall&lt;/code&gt; A와 &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; , 적절한 유형으로 호출 사이트에서 자동으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="dbb8c00bae5bbda144f1736a9cba2314230cbae3" translate="yes" xml:space="preserve">
          <source>Gem Stone</source>
          <target state="translated">보석 스톤</target>
        </trans-unit>
        <trans-unit id="ddba2c9277cd909b2d4fac91a3cc754a462c7a90" translate="yes" xml:space="preserve">
          <source>Gemini</source>
          <target state="translated">Gemini</target>
        </trans-unit>
        <trans-unit id="9203a7a738516ae214b4ae47d8b7fd816429f200" translate="yes" xml:space="preserve">
          <source>General Collections</source>
          <target state="translated">일반 컬렉션</target>
        </trans-unit>
        <trans-unit id="b87cf666cc00e115fb18674c6deb84af8b517c7f" translate="yes" xml:space="preserve">
          <source>General I/O</source>
          <target state="translated">일반 I / O</target>
        </trans-unit>
        <trans-unit id="4979599c738b7850931480557307563f3cf52a2f" translate="yes" xml:space="preserve">
          <source>General Number Functions and Constants</source>
          <target state="translated">일반 숫자 함수 및 상수</target>
        </trans-unit>
        <trans-unit id="6b7059d9b81b1f245d958405a414e29373725e72" translate="yes" xml:space="preserve">
          <source>General escaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to &lt;code&gt;io&lt;/code&gt;.</source>
          <target state="translated">전통적인 C 및 유니 코드 이스케이프 시퀀스의 일반적인 탈출. 첫 번째 형식은 이스케이프 된 문자열을 반환하고 두 번째 형식은 결과를 &lt;code&gt;io&lt;/code&gt; 에 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="4e9dfb96c25a921933f55dcf7822775fb8e071eb" translate="yes" xml:space="preserve">
          <source>General exceptions can be raised using the functions:</source>
          <target state="translated">다음과 같은 기능을 사용하여 일반적인 예외를 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa8e53d9ebff9d0979fd39b344364382458a81b6" translate="yes" xml:space="preserve">
          <source>General non-square</source>
          <target state="translated">비 정사각형</target>
        </trans-unit>
        <trans-unit id="07891976324532c807b79ec56fda0fc0b9da6708" translate="yes" xml:space="preserve">
          <source>General square</source>
          <target state="translated">일반 광장</target>
        </trans-unit>
        <trans-unit id="1d3f6af2e9c4d5b2ed46f9e07478d485ceb20715" translate="yes" xml:space="preserve">
          <source>General unescaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to &lt;code&gt;io&lt;/code&gt;.</source>
          <target state="translated">전통적인 C 및 유니 코드 이스케이프 시퀀스의 일반적인 탈출. 첫 번째 형식은 이스케이프 된 문자열을 반환하고 두 번째 형식은 결과를 &lt;code&gt;io&lt;/code&gt; 에 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="d0285ea21d10ed4a7913ad2a66cb346f95bc9d78" translate="yes" xml:space="preserve">
          <source>Generalized SVD</source>
          <target state="translated">일반화 된 SVD</target>
        </trans-unit>
        <trans-unit id="4d85331d4948d0ae34d7f8f8e070efd57ba16e64" translate="yes" xml:space="preserve">
          <source>Generalized linear models are provided by the &lt;a href=&quot;https://github.com/JuliaStats/GLM.jl&quot;&gt;GLM package&lt;/a&gt;.</source>
          <target state="translated">일반화 된 선형 모델은 &lt;a href=&quot;https://github.com/JuliaStats/GLM.jl&quot;&gt;GLM 패키지에&lt;/a&gt; 의해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="5ad14a691ce38a290bae999d447b8c703f49ef6b" translate="yes" xml:space="preserve">
          <source>Generally, new types should implement &lt;a href=&quot;#Base.:&amp;lt;&quot;&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/a&gt; instead of this function, and rely on the fallback definition &lt;code&gt;&amp;gt;(x, y) = y &amp;lt; x&lt;/code&gt;.</source>
          <target state="translated">일반적으로 새 유형은 이 함수 대신 &lt;a href=&quot;#Base.:&amp;lt;&quot;&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;/a&gt; 를 구현 하고 대체 정의 &lt;code&gt;&amp;gt;(x, y) = y &amp;lt; x&lt;/code&gt; 의존해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f33a08ad09d1f8b477ee12ea78ff5b8bbea276a6" translate="yes" xml:space="preserve">
          <source>Generate a &lt;code&gt;BitArray&lt;/code&gt; of random boolean values.</source>
          <target state="translated">임의의 부울 값으로 구성된 &lt;code&gt;BitArray&lt;/code&gt; 를 생성하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd53bfe967151037d3aab623a3c39dc68a9e6a07" translate="yes" xml:space="preserve">
          <source>Generate a C-callable function pointer from the Julia function &lt;code&gt;callable&lt;/code&gt; for the given type signature. To pass the return value to a &lt;code&gt;ccall&lt;/code&gt;, use the argument type &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; in the signature.</source>
          <target state="translated">주어진 유형 서명에 대해 &lt;code&gt;callable&lt;/code&gt; Julia 함수에서 C 호출 가능 함수 포인터를 생성하십시오 . 리턴 값을 &lt;code&gt;ccall&lt;/code&gt; 에 전달하려면 서명에서 인수 유형 &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="41e2ff826d751563b9e50313fe308bc12b868933" translate="yes" xml:space="preserve">
          <source>Generate a normally-distributed random number of type &lt;code&gt;T&lt;/code&gt; with mean 0 and standard deviation 1. Optionally generate an array of normally-distributed random numbers. The &lt;code&gt;Base&lt;/code&gt; module currently provides an implementation for the types &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; (the default), and their &lt;a href=&quot;../../base/numbers/index#Base.Complex&quot;&gt;&lt;code&gt;Complex&lt;/code&gt;&lt;/a&gt; counterparts. When the type argument is complex, the values are drawn from the circularly symmetric complex normal distribution.</source>
          <target state="translated">평균이 0이고 표준 편차가 1 인 정규 분포 &lt;code&gt;T&lt;/code&gt; 유형의 난수를 생성합니다. 선택적으로 정규 분포 난수의 배열을 생성합니다. &lt;code&gt;Base&lt;/code&gt; 모듈은 현재 유형의 구현을 제공 &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; (기본값)과 &lt;a href=&quot;../../base/numbers/index#Base.Complex&quot;&gt; &lt;code&gt;Complex&lt;/code&gt; &lt;/a&gt; 대응을. 유형 인수가 복소수이면 값은 원형 대칭 복소 정규 분포에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d735a31a4d0a7d19a36da47899d779f788bda4b7" translate="yes" xml:space="preserve">
          <source>Generate a random number of type &lt;code&gt;T&lt;/code&gt; according to the exponential distribution with scale 1. Optionally generate an array of such random numbers. The &lt;code&gt;Base&lt;/code&gt; module currently provides an implementation for the types &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; (the default).</source>
          <target state="translated">척도 1의 지수 분포에 따라 유형 &lt;code&gt;T&lt;/code&gt; 의 난수를 생성합니다 . 선택적으로 이러한 난수의 배열을 생성합니다. &lt;code&gt;Base&lt;/code&gt; 모듈은 현재 유형의 구현을 제공 &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; 을&lt;/a&gt; (기본값).</target>
        </trans-unit>
        <trans-unit id="0fd80a1d3f890e93d6b1dc16c37a28152669461b" translate="yes" xml:space="preserve">
          <source>Generate a temporary file path. This function only returns a path; no file is created. The path is likely to be unique, but this cannot be guaranteed.</source>
          <target state="translated">임시 파일 경로를 생성하십시오. 이 함수는 경로 만 반환합니다. 파일이 작성되지 않습니다. 경로는 고유 할 수 있지만 보장 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="3e42af03cf7e4fa9b19d5375dcdec38dc109c9bc" translate="yes" xml:space="preserve">
          <source>Generated functions</source>
          <target state="translated">생성 된 함수</target>
        </trans-unit>
        <trans-unit id="40080cfd55d586fc4f5401be4bb1834fea88976c" translate="yes" xml:space="preserve">
          <source>Generated functions can achieve high efficiency at run time, but come with a compile time cost: a new function body must be generated for every combination of concrete argument types. Typically, Julia is able to compile &quot;generic&quot; versions of functions that will work for any arguments, but with generated functions this is impossible. This means that programs making heavy use of generated functions might be impossible to statically compile.</source>
          <target state="translated">생성 된 함수는 런타임시 높은 효율성을 달성 할 수 있지만 컴파일 시간 비용이 발생합니다. 구체적인 인수 유형의 모든 조합에 대해 새 함수 본문을 생성해야합니다. 일반적으로 Julia는 인수에 사용할 수있는 &quot;일반&quot;버전의 함수를 컴파일 할 수 있지만 생성 된 함수로는 불가능합니다. 이는 생성 된 함수를 많이 사용하는 프로그램을 정적으로 컴파일하는 것이 불가능할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="503406d41ab4e8215a281c0d73cf5e1840925953" translate="yes" xml:space="preserve">
          <source>Generated functions must not &lt;em&gt;mutate&lt;/em&gt; or &lt;em&gt;observe&lt;/em&gt; any non-constant global state (including, for example, IO, locks, non-local dictionaries, or using &lt;a href=&quot;../../base/base/index#Base.hasmethod&quot;&gt;&lt;code&gt;hasmethod&lt;/code&gt;&lt;/a&gt;). This means they can only read global constants, and cannot have any side effects. In other words, they must be completely pure. Due to an implementation limitation, this also means that they currently cannot define a closure or generator.</source>
          <target state="translated">생성 된 함수는 일정하지 않은 전역 상태 (예 : IO, 잠금, 로컬이 아닌 사전 포함 또는 &lt;a href=&quot;../../base/base/index#Base.hasmethod&quot;&gt; &lt;code&gt;hasmethod&lt;/code&gt; &lt;/a&gt; 사용)를 &lt;em&gt;변경&lt;/em&gt; 하거나 &lt;em&gt;관찰&lt;/em&gt; 해서는 안됩니다. )를 . 즉, 전역 상수 만 읽을 수 있으며 부작용이 없습니다. 다시 말해, 그것들은 완전히 순수해야합니다. 구현 제한으로 인해 현재 클로저 또는 생성기를 정의 할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3ef0ab87b9316844c35d99faef219c9c7322d80c" translate="yes" xml:space="preserve">
          <source>Generated values can be filtered using the &lt;code&gt;if&lt;/code&gt; keyword:</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 키워드를 사용하여 생성 된 값을 필터링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="43a3b60a1f43668fa7df03ea6999eb9005534d03" translate="yes" xml:space="preserve">
          <source>Generates a copy of &lt;code&gt;A&lt;/code&gt; and removes stored numerical zeros from that copy, optionally trimming excess space from the result's &lt;code&gt;rowval&lt;/code&gt; and &lt;code&gt;nzval&lt;/code&gt; arrays when &lt;code&gt;trim&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 사본을 생성하고 해당 사본에서 저장된 숫자 0을 제거하여 선택적으로 &lt;code&gt;trim&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 일 때 결과의 &lt;code&gt;rowval&lt;/code&gt; 및 &lt;code&gt;nzval&lt;/code&gt; 배열 에서 초과 공간을 트리밍 합니다 .</target>
        </trans-unit>
        <trans-unit id="aa8200a561dd1fd6d9a2571a09a8c0833fd591d2" translate="yes" xml:space="preserve">
          <source>Generates a copy of &lt;code&gt;x&lt;/code&gt; and removes numerical zeros from that copy, optionally trimming excess space from the result's &lt;code&gt;nzind&lt;/code&gt; and &lt;code&gt;nzval&lt;/code&gt; arrays when &lt;code&gt;trim&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 복사본을 생성하고 해당 복사본에서 숫자 0을 제거하고 선택적으로 &lt;code&gt;trim&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 때 결과의 &lt;code&gt;nzind&lt;/code&gt; 및 &lt;code&gt;nzval&lt;/code&gt; 배열 에서 여분의 공간을 잘라 냅니다. .</target>
        </trans-unit>
        <trans-unit id="1d35e347a9e9f11c97762e02cb3817fdf6492b95" translate="yes" xml:space="preserve">
          <source>Generates a gensym symbol for a variable. For example, &lt;code&gt;@gensym x y&lt;/code&gt; is transformed into &lt;code&gt;x = gensym(&quot;x&quot;); y = gensym(&quot;y&quot;)&lt;/code&gt;.</source>
          <target state="translated">변수에 대한 기호를 생성합니다. 예를 들어, &lt;code&gt;@gensym x y&lt;/code&gt; 는 &lt;code&gt;x = gensym(&quot;x&quot;); y = gensym(&quot;y&quot;)&lt;/code&gt; 로 변환됩니다 . y = gensym ( &quot;y&quot;) 입니다.</target>
        </trans-unit>
        <trans-unit id="82624d1ced08378811cc12e5b9bb3247c76bde71" translate="yes" xml:space="preserve">
          <source>Generates a symbol which will not conflict with other variable names.</source>
          <target state="translated">다른 변수 이름과 충돌하지 않는 기호를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6493dacd8d9340030628eff5048e31c32e36106f" translate="yes" xml:space="preserve">
          <source>Generates a version 1 (time-based) universally unique identifier (UUID), as specified by RFC 4122. Note that the Node ID is randomly generated (does not identify the host) according to section 4.5 of the RFC.</source>
          <target state="translated">RFC 4122에 지정된대로 버전 1 (시간 기반) UUID (Universally Unique Identifier)를 생성합니다. RFC의 섹션 4.5에 따라 노드 ID가 임의로 생성됩니다 (호스트를 식별하지 않음).</target>
        </trans-unit>
        <trans-unit id="5c0ffbf6fa6cd08065c3fd1e20d39e7262ac9916" translate="yes" xml:space="preserve">
          <source>Generates a version 4 (random or pseudo-random) universally unique identifier (UUID), as specified by RFC 4122.</source>
          <target state="translated">RFC 4122에 지정된대로 버전 4 (랜덤 또는 의사 랜덤) UUID (Universally Unique Identifier)를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6864e40d6120ff94e92379a41401cda33ec26eb1" translate="yes" xml:space="preserve">
          <source>Generates a version 5 (namespace and domain-based) universally unique identifier (UUID), as specified by RFC 4122.</source>
          <target state="translated">RFC 4122에 지정된대로 버전 5 (네임 스페이스 및 도메인 기반) UUID (Universally Unique Identifier)를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="31ad5eda3014502203f1f1c9f4f8ad8b0addc8bb" translate="yes" xml:space="preserve">
          <source>Generating random values of custom types</source>
          <target state="translated">사용자 정의 유형의 임의 값 생성</target>
        </trans-unit>
        <trans-unit id="ea6d79a7c35cdb9d37f8d907393ca6d0663b71e9" translate="yes" xml:space="preserve">
          <source>Generating values for an &lt;code&gt;AbstractFloat&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;AbstractFloat&lt;/code&gt; 유형의 값 생성</target>
        </trans-unit>
        <trans-unit id="79059f17dfecc212b29a403a6fe768eae1bb1610" translate="yes" xml:space="preserve">
          <source>Generating values from a collection</source>
          <target state="translated">컬렉션에서 값 생성</target>
        </trans-unit>
        <trans-unit id="5f32399dda528ab0f4979390ae10b103edb83e67" translate="yes" xml:space="preserve">
          <source>Generating values from a type</source>
          <target state="translated">유형에서 값 생성</target>
        </trans-unit>
        <trans-unit id="217dffa188c85186f3dde4d07c906c09c058f848" translate="yes" xml:space="preserve">
          <source>Generator Expressions</source>
          <target state="translated">생성기 표현식</target>
        </trans-unit>
        <trans-unit id="111436dce43eef86f4f13a06226e540548b10b69" translate="yes" xml:space="preserve">
          <source>Generators (creation and seeding)</source>
          <target state="translated">발전기 (창조 및 파종)</target>
        </trans-unit>
        <trans-unit id="ab25cfdc66be945181ae90276749fb192703ddc0" translate="yes" xml:space="preserve">
          <source>Generators are implemented via inner functions. Just like inner functions used elsewhere in the language, variables from the enclosing scope can be &quot;captured&quot; in the inner function. For example, &lt;code&gt;sum(p[i] - q[i] for i=1:n)&lt;/code&gt; captures the three variables &lt;code&gt;p&lt;/code&gt;, &lt;code&gt;q&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; from the enclosing scope. Captured variables can present performance challenges; see &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;performance tips&lt;/a&gt;.</source>
          <target state="translated">발전기는 내부 기능을 통해 구현됩니다. 언어의 다른 곳에서 사용되는 내부 함수와 마찬가지로 둘러싸는 범위의 변수는 내부 함수에서 &quot;캡처&quot;될 수 있습니다. 예를 들어, &lt;code&gt;sum(p[i] - q[i] for i=1:n)&lt;/code&gt; 경우 sum (p [i]-q [i] 는 둘러싸는 범위에서 세 개의 변수 &lt;code&gt;p&lt;/code&gt; , &lt;code&gt;q&lt;/code&gt; 및 &lt;code&gt;n&lt;/code&gt; 을 캡처합니다 . 캡처 된 변수는 성능 문제를 일으킬 수 있습니다. &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;성능 팁을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="83082f46072d254fd933bf6e78414552f2b12960" translate="yes" xml:space="preserve">
          <source>Generic Functions</source>
          <target state="translated">일반 함수</target>
        </trans-unit>
        <trans-unit id="2654c4b9018fcc37437c59923d4ac1eabf19c850" translate="yes" xml:space="preserve">
          <source>Generic equality operator. Falls back to &lt;a href=&quot;../base/index#Core.:===&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt;. Should be implemented for all types with a notion of equality, based on the abstract value that an instance represents. For example, all numeric types are compared by numeric value, ignoring type. Strings are compared as sequences of characters, ignoring encoding. For collections, &lt;code&gt;==&lt;/code&gt; is generally called recursively on all contents, though other properties (like the shape for arrays) may also be taken into account.</source>
          <target state="translated">일반 항등 연산자 &lt;a href=&quot;../base/index#Core.:===&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt; 로 폴백 합니다. 인스턴스가 나타내는 추상적 인 값을 기반으로 동일한 개념으로 모든 유형에 대해 구현해야합니다. 예를 들어, 모든 숫자 유형은 유형을 무시하고 숫자 값으로 비교됩니다. 문자열은 인코딩을 무시하고 일련의 문자로 비교됩니다. 컬렉션의 경우 &lt;code&gt;==&lt;/code&gt; 는 일반적으로 모든 내용에서 재귀 적으로 호출되지만 다른 속성 (배열 모양과 같은)도 고려 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a247769c311d71434e7dbab7ffa2c58b32221569" translate="yes" xml:space="preserve">
          <source>Generic error type. The error message, in the &lt;code&gt;.msg&lt;/code&gt; field, may provide more specific details.</source>
          <target state="translated">일반 오류 유형 &lt;code&gt;.msg&lt;/code&gt; 필드 의 오류 메시지 는보다 구체적인 내용을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a2cbe8ef5a6182effacad0728af04d3466e9419" translate="yes" xml:space="preserve">
          <source>Generically sized uniform scaling operator defined as a scalar times the identity operator, &lt;code&gt;&amp;lambda;*I&lt;/code&gt;. See also &lt;a href=&quot;#LinearAlgebra.I&quot;&gt;&lt;code&gt;I&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적으로 크기 조정 균일 스케일링 연산자는 ID 연산자 &lt;code&gt;&amp;lambda;*I&lt;/code&gt; 의 스칼라 시간으로 정의됩니다 . &lt;a href=&quot;#LinearAlgebra.I&quot;&gt; &lt;code&gt;I&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7021447d5c6f5d07882ea34fcf74ffd494b65a7" translate="yes" xml:space="preserve">
          <source>Geometric Proportion</source>
          <target state="translated">기하 비율</target>
        </trans-unit>
        <trans-unit id="e505f741dc44890868c87aa48f3d8916c6fb0128" translate="yes" xml:space="preserve">
          <source>Geometrically Equal To</source>
          <target state="translated">기하학적으로 동일</target>
        </trans-unit>
        <trans-unit id="f64b845181c47fc7995221a47eaadce47af6bcc8" translate="yes" xml:space="preserve">
          <source>Geometrically Equivalent To</source>
          <target state="translated">기하학적으로</target>
        </trans-unit>
        <trans-unit id="30404c5812bd3cd0bc1e26c11cfbb33861e4d141" translate="yes" xml:space="preserve">
          <source>Geometrically Equivalent To + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">긴 Solidus 오버레이 / 비 간격 Long 슬래시 오버레이 결합과 기하학적으로 동일</target>
        </trans-unit>
        <trans-unit id="ea2ac5cf7c4e856204e6a41aeaaa0b3dd4ef2ab5" translate="yes" xml:space="preserve">
          <source>Get Julia's process ID.</source>
          <target state="translated">Julia의 프로세스 ID를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="76117157c574ac5727a236f6277b1450a47c5f21" translate="yes" xml:space="preserve">
          <source>Get a backtrace object for the current program point.</source>
          <target state="translated">현재 프로그램 포인트의 역 추적 객체를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6245e1b22dd874707de430f7178865b9a33deacf" translate="yes" xml:space="preserve">
          <source>Get a hash value for &lt;code&gt;x&lt;/code&gt; based on object identity. &lt;code&gt;objectid(x)==objectid(y)&lt;/code&gt; if &lt;code&gt;x === y&lt;/code&gt;.</source>
          <target state="translated">객체 식별 정보를 기반으로 &lt;code&gt;x&lt;/code&gt; 의 해시 값을 가져 옵니다. &lt;code&gt;x === y&lt;/code&gt; 경우 &lt;code&gt;objectid(x)==objectid(y)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="594cb8bf35cce2c570e740ff46837e8b661e81ff" translate="yes" xml:space="preserve">
          <source>Get a list of all reference names in the &lt;code&gt;repo&lt;/code&gt; repository.</source>
          <target state="translated">&lt;code&gt;repo&lt;/code&gt; 저장소 의 모든 참조 이름 목록을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="edea7d0cabb9a933daebe03151b03bacc57f2132" translate="yes" xml:space="preserve">
          <source>Get a list of all tags in the git repository &lt;code&gt;repo&lt;/code&gt;.</source>
          <target state="translated">git repository &lt;code&gt;repo&lt;/code&gt; 의 모든 태그 목록을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="c83b8077da01523efd9ec95df9552f34eef56509" translate="yes" xml:space="preserve">
          <source>Get a module's enclosing &lt;code&gt;Module&lt;/code&gt;. &lt;code&gt;Main&lt;/code&gt; is its own parent.</source>
          <target state="translated">모듈의 둘러싸 가져 오기 &lt;code&gt;Module&lt;/code&gt; . &lt;code&gt;Main&lt;/code&gt; 은 자신의 부모입니다.</target>
        </trans-unit>
        <trans-unit id="91aa8a1066c0cf259f10453272965a98317015dc" translate="yes" xml:space="preserve">
          <source>Get a string consisting of the first &lt;code&gt;n&lt;/code&gt; characters of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 의 처음 &lt;code&gt;n&lt;/code&gt; 자로 구성된 문자열을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="a14f2cfc2cb6c1c852e03fd6e4a706f0a47df06c" translate="yes" xml:space="preserve">
          <source>Get a string consisting of the last &lt;code&gt;n&lt;/code&gt; characters of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 의 마지막 &lt;code&gt;n&lt;/code&gt; 자로 구성된 문자열을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="3372d98da97932978011accfa92cc350dd85fc43" translate="yes" xml:space="preserve">
          <source>Get a tuple or a vector of the properties (&lt;code&gt;x.property&lt;/code&gt;) of an object &lt;code&gt;x&lt;/code&gt;. This is typically the same as &lt;a href=&quot;#Base.fieldnames&quot;&gt;&lt;code&gt;fieldnames(typeof(x))&lt;/code&gt;&lt;/a&gt;, but types that overload &lt;a href=&quot;#Base.getproperty&quot;&gt;&lt;code&gt;getproperty&lt;/code&gt;&lt;/a&gt; should generally overload &lt;code&gt;propertynames&lt;/code&gt; as well to get the properties of an instance of the type.</source>
          <target state="translated">객체 &lt;code&gt;x&lt;/code&gt; 의 속성 ( &lt;code&gt;x.property&lt;/code&gt; )으로 구성된 튜플 또는 벡터를 가져옵니다 . 이는 일반적으로 동일하다 &lt;a href=&quot;#Base.fieldnames&quot;&gt; &lt;code&gt;fieldnames(typeof(x))&lt;/code&gt; &lt;/a&gt; 하지만, 그 종류 과부하 &lt;a href=&quot;#Base.getproperty&quot;&gt; &lt;code&gt;getproperty&lt;/code&gt; &lt;/a&gt; 일반적한다 과부하 &lt;code&gt;propertynames&lt;/code&gt; 유형의 인스턴스의 특성을 얻을뿐만 아니라이.</target>
        </trans-unit>
        <trans-unit id="42f453edc0370fb274422ead5407c2776b31db1f" translate="yes" xml:space="preserve">
          <source>Get a tuple with the names of the fields of a &lt;code&gt;DataType&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DataType&lt;/code&gt; 필드의 이름으로 튜플을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="d530106390fd810b016b6212bad35ad44f20a8f4" translate="yes" xml:space="preserve">
          <source>Get an IP address of the local machine of the specified type. Throws if no addresses of the specified type are available.</source>
          <target state="translated">지정된 유형의 로컬 머신의 IP 주소를 가져옵니다. 지정된 유형의 주소를 사용할 수없는 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7cad9add4d27400ccccd1e83a0b5fe65f627675d" translate="yes" xml:space="preserve">
          <source>Get an IP address of the local machine, preferring IPv4 over IPv6. Throws if no addresses are available.</source>
          <target state="translated">IPv6보다 IPv4를 선호하는 로컬 컴퓨터의 IP 주소를 얻습니다. 사용 가능한 주소가없는 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d1b1f967961007a8e3404abb4f0fb2c9b3d00448" translate="yes" xml:space="preserve">
          <source>Get an array of the names exported by a &lt;code&gt;Module&lt;/code&gt;, excluding deprecated names. If &lt;code&gt;all&lt;/code&gt; is true, then the list also includes non-exported names defined in the module, deprecated names, and compiler-generated names. If &lt;code&gt;imported&lt;/code&gt; is true, then names explicitly imported from other modules are also included.</source>
          <target state="translated">더 이상 사용되지 않는 이름을 제외 하고 &lt;code&gt;Module&lt;/code&gt; 에서 내 보낸 이름의 배열을 가져옵니다 . &lt;code&gt;all&lt;/code&gt; 참인 경우 목록에는 모듈에 정의 된 내보내기되지 않은 이름, 더 이상 사용되지 않는 이름 및 컴파일러 생성 이름도 포함됩니다. 경우 &lt;code&gt;imported&lt;/code&gt; 사실이다, 다음 명시 적으로 다른 모듈에서 가져온 이름도 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="171cab21a362e3fe558e803f2cb2a0d2a8e62a11" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;Module&lt;/code&gt; of the toplevel eval, which is the &lt;code&gt;Module&lt;/code&gt; code is currently being read from.</source>
          <target state="translated">가져 오기 &lt;code&gt;Module&lt;/code&gt; 은 IS 최상위 평가의 &lt;code&gt;Module&lt;/code&gt; 현재에서 읽고있는 코드입니다.</target>
        </trans-unit>
        <trans-unit id="7881586bad23ccbb959e0086fba3cebe29d398b8" translate="yes" xml:space="preserve">
          <source>Get the &lt;em&gt;fetch&lt;/em&gt; refspecs for the specified &lt;code&gt;rmt&lt;/code&gt;. These refspecs contain information about which branch(es) to fetch from.</source>
          <target state="translated">(가) 가져 오기 &lt;em&gt;가져 오기&lt;/em&gt; 지정된 대한 refspecs를 &lt;code&gt;rmt&lt;/code&gt; . 이 참조 스펙에는 가져올 브랜치에 대한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2abefd55e48cb868afd9b2bbc8365ad10b4fa4f" translate="yes" xml:space="preserve">
          <source>Get the &lt;em&gt;push&lt;/em&gt; refspecs for the specified &lt;code&gt;rmt&lt;/code&gt;. These refspecs contain information about which branch(es) to push to.</source>
          <target state="translated">가져 오기 &lt;em&gt;푸시&lt;/em&gt; 지정된 대한 refspecs &lt;code&gt;rmt&lt;/code&gt; . 이 참조 스펙에는 푸시 할 브랜치에 대한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ec8068370cc3ffbb8329c71ce1fa5a1af831971" translate="yes" xml:space="preserve">
          <source>Get the ID number of the current thread of execution. The master thread has ID &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">현재 실행 스레드의 ID 번호를 가져옵니다. 마스터 스레드는 ID &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="899b97d6f0cff7934c3aa84ef79f50d77403aeb3" translate="yes" xml:space="preserve">
          <source>Get the IP address and port of the remote endpoint that the given socket is connected to. Valid only for connected TCP sockets.</source>
          <target state="translated">주어진 소켓이 연결된 원격 엔드 포인트의 IP 주소와 포트를 가져옵니다. 연결된 TCP 소켓에만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="b30337efd6e1ddf333502df0ba154f1bbe883302" translate="yes" xml:space="preserve">
          <source>Get the IP address and port that the given socket is bound to.</source>
          <target state="translated">주어진 소켓이 바인딩 된 IP 주소와 포트를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ae34bdec6f00934e072471fe83b1ec1bb0253d9e" translate="yes" xml:space="preserve">
          <source>Get the IP addresses of the local machine of the specified type.</source>
          <target state="translated">지정된 유형의 로컬 시스템의 IP 주소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="80e3f3bd81b00cd5fdff2163bfb439bea6bf2f6a" translate="yes" xml:space="preserve">
          <source>Get the IPv4 addresses of the local machine.</source>
          <target state="translated">로컬 컴퓨터의 IPv4 주소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="fc0c58665e06f4bcac50a3a051a380e40687f694" translate="yes" xml:space="preserve">
          <source>Get the additive identity element for the type of &lt;code&gt;x&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt; can also specify the type itself).</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 유형의 가산 성 요소를 가져옵니다 ( &lt;code&gt;x&lt;/code&gt; 는 유형 자체도 지정할 수 있음).</target>
        </trans-unit>
        <trans-unit id="13d05d3446c1b045371ca3c580a406fe6efa3a85" translate="yes" xml:space="preserve">
          <source>Get the backtrace of the current exception, for use within &lt;code&gt;catch&lt;/code&gt; blocks.</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; 블록 내에서 사용하기 위해 현재 예외의 역 추적을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="d0b515694c2e31069f75a4341701ebdddc0dbcfa" translate="yes" xml:space="preserve">
          <source>Get the child process ID, if it still exists.</source>
          <target state="translated">자식 프로세스 ID가 여전히 존재하는 경우 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b7046c13174456af8138867bb2456e8e9106c14f" translate="yes" xml:space="preserve">
          <source>Get the concrete type of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">구체적인 &lt;code&gt;x&lt;/code&gt; 유형을 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="47ebb15e57ce473b474a7f913ff4aa9d19236677" translate="yes" xml:space="preserve">
          <source>Get the current floating point rounding mode for type &lt;code&gt;T&lt;/code&gt;, controlling the rounding of basic arithmetic functions (&lt;a href=&quot;../math/index#Base.:+&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;a href=&quot;../math/index#Base.:/&quot;&gt;&lt;code&gt;/&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;sqrt&lt;/code&gt;) and type conversion.</source>
          <target state="translated">기본 산술 함수 ( &lt;a href=&quot;../math/index#Base.:+&quot;&gt; &lt;code&gt;+&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;a href=&quot;../math/index#Base.:/&quot;&gt; &lt;code&gt;/&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;sqrt&lt;/code&gt; ) 의 반올림 및 유형 변환을 제어하여 유형 &lt;code&gt;T&lt;/code&gt; 에 대한 현재 부동 소수점 반올림 모드를 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="054e0f64d6af85ef39cd5689d518feb6140528b2" translate="yes" xml:space="preserve">
          <source>Get the current position of a stream.</source>
          <target state="translated">스트림의 현재 위치를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7d101e5841a77867eef23ee238263d38f724a6f3" translate="yes" xml:space="preserve">
          <source>Get the current working directory.</source>
          <target state="translated">현재 작업 디렉토리를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b150736a9f570c696c7e152a5f442d80d1bfe707" translate="yes" xml:space="preserve">
          <source>Get the currently running &lt;a href=&quot;#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 실행중인 &lt;a href=&quot;#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; 를 가져&lt;/a&gt; 옵니다 .</target>
        </trans-unit>
        <trans-unit id="307991aa1f7f375be076c27a6b5e16a8e43f1f24" translate="yes" xml:space="preserve">
          <source>Get the directory part of a path. Trailing characters ('/' or '\') in the path are counted as part of the path.</source>
          <target state="translated">경로의 디렉토리 부분을 가져옵니다. 경로의 후행 문자 ( '/'또는 '\')는 경로의 일부로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="15803f5611fdfd7a4570ea4b6299230e231b89c3" translate="yes" xml:space="preserve">
          <source>Get the exponent of a normalized floating-point number.</source>
          <target state="translated">정규화 된 부동 소수점 숫자의 지수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="428d1e51e8fd8658370395752d8d28b03956207a" translate="yes" xml:space="preserve">
          <source>Get the fetch URL of a remote git repository.</source>
          <target state="translated">원격 자식 저장소의 가져 오기 URL을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6395adf311f39b7041b3bc31800f3ac3ac69f04a" translate="yes" xml:space="preserve">
          <source>Get the file name part of a path.</source>
          <target state="translated">경로의 파일 이름 부분을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="45d031a98e3d7988439346e5f12753ad44f6564c" translate="yes" xml:space="preserve">
          <source>Get the first element of an iterable collection. Return the start point of an &lt;a href=&quot;#Base.AbstractRange&quot;&gt;&lt;code&gt;AbstractRange&lt;/code&gt;&lt;/a&gt; even if it is empty.</source>
          <target state="translated">반복 가능한 컬렉션의 첫 번째 요소를 가져옵니다. 비어있는 경우에도 &lt;a href=&quot;#Base.AbstractRange&quot;&gt; &lt;code&gt;AbstractRange&lt;/code&gt; 의&lt;/a&gt; 시작점을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="803a6a556ee1107f53d846bba76956752d4f95be" translate="yes" xml:space="preserve">
          <source>Get the fully-qualified name of a module as a tuple of symbols. For example,</source>
          <target state="translated">모듈의 정규화 된 이름을 튜플 심볼로 가져옵니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="9fe2dd6fafde9402b9bebe656d7e76ff3412ff6a" translate="yes" xml:space="preserve">
          <source>Get the git object to which &lt;code&gt;te&lt;/code&gt; refers and return it as its actual type (the type &lt;a href=&quot;#LibGit2.entrytype&quot;&gt;&lt;code&gt;entrytype&lt;/code&gt;&lt;/a&gt; would show), for instance a &lt;code&gt;GitBlob&lt;/code&gt; or &lt;code&gt;GitTag&lt;/code&gt;.</source>
          <target state="translated">처 자식 개체를 가져옵니다 &lt;code&gt;te&lt;/code&gt; 의미와 실제 유형 (유형으로 반환 &lt;a href=&quot;#LibGit2.entrytype&quot;&gt; &lt;code&gt;entrytype&lt;/code&gt; &lt;/a&gt; 인스턴스 A을 입증 할) &lt;code&gt;GitBlob&lt;/code&gt; 또는 &lt;code&gt;GitTag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="353f9fc88dc058135091370ad6a5d9c59fcfda6e" translate="yes" xml:space="preserve">
          <source>Get the id of the current process.</source>
          <target state="translated">현재 프로세스의 ID를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4e1a5fc780c8cf7e7bc238f6885dd2ba9bd5e31b" translate="yes" xml:space="preserve">
          <source>Get the key type of an dictionary type. Behaves similarly to &lt;a href=&quot;#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사전 유형의 키 유형을 가져옵니다. &lt;a href=&quot;#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt; 과 유사하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="7db9e0d4b309f243e7497e360f841540e11cc1fa" translate="yes" xml:space="preserve">
          <source>Get the last element of an ordered collection, if it can be computed in O(1) time. This is accomplished by calling &lt;a href=&quot;#Base.lastindex&quot;&gt;&lt;code&gt;lastindex&lt;/code&gt;&lt;/a&gt; to get the last index. Return the end point of an &lt;a href=&quot;#Base.AbstractRange&quot;&gt;&lt;code&gt;AbstractRange&lt;/code&gt;&lt;/a&gt; even if it is empty.</source>
          <target state="translated">O (1) 시간으로 계산할 수있는 경우 정렬 된 컬렉션의 마지막 요소를 가져옵니다. 마지막 색인을 얻기 위해 &lt;a href=&quot;#Base.lastindex&quot;&gt; &lt;code&gt;lastindex&lt;/code&gt; &lt;/a&gt; 를 호출 하면 됩니다. 비어있는 경우에도 &lt;a href=&quot;#Base.AbstractRange&quot;&gt; &lt;code&gt;AbstractRange&lt;/code&gt; &lt;/a&gt; 의 끝점을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="acd04aae132c80a71e1f513a908b2702371aa23c" translate="yes" xml:space="preserve">
          <source>Get the local machine's host name.</source>
          <target state="translated">로컬 컴퓨터의 호스트 이름을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7880b6703d5b76a9fbb2e0506acfbba24be95f11" translate="yes" xml:space="preserve">
          <source>Get the memory address of a Julia object as a &lt;code&gt;Ptr&lt;/code&gt;. The existence of the resulting &lt;code&gt;Ptr&lt;/code&gt; will not protect the object from garbage collection, so you must ensure that the object remains referenced for the whole time that the &lt;code&gt;Ptr&lt;/code&gt; will be used.</source>
          <target state="translated">Julia 객체의 메모리 주소를 &lt;code&gt;Ptr&lt;/code&gt; 로 가져 옵니다 . 결과 &lt;code&gt;Ptr&lt;/code&gt; 이 존재하더라도 가비지 콜렉션으로부터 오브젝트를 보호하지 않으므로 &lt;code&gt;Ptr&lt;/code&gt; 이 사용될 전체 시간 동안 오브젝트가 참조 된 상태로 유지되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="563766b2618b2d015ed0e9c3d29a5e7becea72bb" translate="yes" xml:space="preserve">
          <source>Get the name of a (potentially &lt;code&gt;UnionAll&lt;/code&gt;-wrapped) &lt;code&gt;DataType&lt;/code&gt; (without its parent module) as a symbol.</source>
          <target state="translated">(부모 모듈없이 ) (잠재적으로 &lt;code&gt;UnionAll&lt;/code&gt; - wrapped) &lt;code&gt;DataType&lt;/code&gt; 의 이름을 심볼로 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="52de91388eb956065955884b6eac39cce6e61088" translate="yes" xml:space="preserve">
          <source>Get the name of a &lt;code&gt;Module&lt;/code&gt; as a &lt;a href=&quot;#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Module&lt;/code&gt; 이름을 &lt;a href=&quot;#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt; 로 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="d8a8ebbac78211cc23fd2af9d0c3c21bb5d703fa" translate="yes" xml:space="preserve">
          <source>Get the name of a generic &lt;code&gt;Function&lt;/code&gt; as a symbol, or &lt;code&gt;:anonymous&lt;/code&gt;.</source>
          <target state="translated">일반 &lt;code&gt;Function&lt;/code&gt; 의 이름을 기호 또는 &lt;code&gt;:anonymous&lt;/code&gt; 로 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="b5308e8edde6c7f90f89dc8b80d1be8f9e4aed1b" translate="yes" xml:space="preserve">
          <source>Get the name of a remote repository, for instance &lt;code&gt;&quot;origin&quot;&lt;/code&gt;. If the remote is anonymous (see &lt;a href=&quot;#LibGit2.GitRemoteAnon&quot;&gt;&lt;code&gt;GitRemoteAnon&lt;/code&gt;&lt;/a&gt;) the name will be an empty string &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">원격 저장소의 이름을 가져 오십시오 (예 : &lt;code&gt;&quot;origin&quot;&lt;/code&gt; ) . 원격이 익명 인 경우 ( &lt;a href=&quot;#LibGit2.GitRemoteAnon&quot;&gt; &lt;code&gt;GitRemoteAnon&lt;/code&gt; &lt;/a&gt; 참조 ) 이름은 빈 문자열 &lt;code&gt;&quot;&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d9cf8794c830b5b5477bd4dd5127e438a0a336f9" translate="yes" xml:space="preserve">
          <source>Get the name of field &lt;code&gt;i&lt;/code&gt; of a &lt;code&gt;DataType&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DataType&lt;/code&gt; 필드 &lt;code&gt;i&lt;/code&gt; 의 이름을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="f05b4e05331b196f379ecdeee8aa391e63dd1631" translate="yes" xml:space="preserve">
          <source>Get the native address of an array or string, optionally at a given location &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">선택적으로 주어진 위치 &lt;code&gt;index&lt;/code&gt; 에서 배열 또는 문자열의 기본 주소를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="67e6a2296c5e9b9545d8ce6e5fe670e01fcb2193" translate="yes" xml:space="preserve">
          <source>Get the number of available processes.</source>
          <target state="translated">사용 가능한 프로세스 수를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="6c54bfd12378fd187e6fdf88c8f9a891fd352b8a" translate="yes" xml:space="preserve">
          <source>Get the number of available worker processes. This is one less than &lt;a href=&quot;#Distributed.nprocs&quot;&gt;&lt;code&gt;nprocs()&lt;/code&gt;&lt;/a&gt;. Equal to &lt;code&gt;nprocs()&lt;/code&gt; if &lt;code&gt;nprocs() == 1&lt;/code&gt;.</source>
          <target state="translated">사용 가능한 작업자 프로세스 수를 얻습니다. 이것은 &lt;a href=&quot;#Distributed.nprocs&quot;&gt; &lt;code&gt;nprocs()&lt;/code&gt; &lt;/a&gt; 보다 작은 것 입니다. 동일 &lt;code&gt;nprocs()&lt;/code&gt; 경우 &lt;code&gt;nprocs() == 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d316efb69571072b7b698b64013b0df989b23e2" translate="yes" xml:space="preserve">
          <source>Get the number of fields in the given object.</source>
          <target state="translated">주어진 객체의 필드 수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a93c91e8128e4c3c8ef281740f30c00304272fd2" translate="yes" xml:space="preserve">
          <source>Get the number of fields that an instance of the given type would have. An error is thrown if the type is too abstract to determine this.</source>
          <target state="translated">주어진 유형의 인스턴스가 가질 필드 수를 가져옵니다. 유형이 너무 추상적이면이를 판별 할 수없는 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d3677eab3b97fd3c65939b3bc5a15f59d44d4af9" translate="yes" xml:space="preserve">
          <source>Get the number of threads available to the Julia process. This is the inclusive upper bound on &lt;code&gt;threadid()&lt;/code&gt;.</source>
          <target state="translated">Julia 프로세스에 사용 가능한 스레드 수를 가져옵니다. &lt;code&gt;threadid()&lt;/code&gt; 에 포함되는 상한 입니다.</target>
        </trans-unit>
        <trans-unit id="3b55f78480b3149c80bfc50e1a7d85e6fa50c73b" translate="yes" xml:space="preserve">
          <source>Get the permissions of the owner of the file as a bitfield of</source>
          <target state="translated">파일 소유자의 권한을 비트 필드로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c5f291709146a9a504c67d3dc2b280d4f865a715" translate="yes" xml:space="preserve">
          <source>Get the precision (in bits) currently used for &lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; arithmetic.</source>
          <target state="translated">&lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt; 산술에 현재 사용되는 정밀도 (비트)를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="3ec48750990030ca792131bcde102c3d937ba66e" translate="yes" xml:space="preserve">
          <source>Get the precision of a floating point number, as defined by the effective number of bits in the mantissa.</source>
          <target state="translated">가수의 유효 비트 수로 정의 된 부동 소수점 수의 정밀도를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="13a1d9961dcbce8522f507a9d605791c91380396" translate="yes" xml:space="preserve">
          <source>Get the process title. On some systems, will always return an empty string.</source>
          <target state="translated">프로세스 제목을 가져옵니다. 일부 시스템에서는 항상 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8d97afd1ec5aab5d2f47ff664bcaf7b5f14afb9a" translate="yes" xml:space="preserve">
          <source>Get the stack of exceptions currently being handled. For nested catch blocks there may be more than one current exception in which case the most recently thrown exception is last in the stack. The stack is returned as a Vector of &lt;code&gt;(exception,backtrace)&lt;/code&gt; pairs, or a Vector of exceptions if &lt;code&gt;include_bt&lt;/code&gt; is false.</source>
          <target state="translated">현재 처리중인 예외 스택을 가져옵니다. 중첩 된 catch 블록의 경우 현재 예외가 두 개 이상있을 수 있습니다.이 경우 가장 최근에 발생한 예외는 스택에서 마지막입니다. 스택은 &lt;code&gt;(exception,backtrace)&lt;/code&gt; 쌍의 Vector 또는 &lt;code&gt;include_bt&lt;/code&gt; 가 false 인 경우 예외의 Vector로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="857485ff0b5ba0b2460dd06bb700b67ed684fb9b" translate="yes" xml:space="preserve">
          <source>Get the stage number of &lt;code&gt;ie&lt;/code&gt;. The stage number &lt;code&gt;0&lt;/code&gt; represents the current state of the working tree, but other numbers can be used in the case of a merge conflict. In such a case, the various stage numbers on an &lt;code&gt;IndexEntry&lt;/code&gt; describe which side(s) of the conflict the current state of the file belongs to. Stage &lt;code&gt;0&lt;/code&gt; is the state before the attempted merge, stage &lt;code&gt;1&lt;/code&gt; is the changes which have been made locally, stages &lt;code&gt;2&lt;/code&gt; and larger are for changes from other branches (for instance, in the case of a multi-branch &quot;octopus&quot; merge, stages &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;, and &lt;code&gt;4&lt;/code&gt; might be used).</source>
          <target state="translated">&lt;code&gt;ie&lt;/code&gt; 의 스테이지 번호를 가져옵니다 . 스테이지 번호 &lt;code&gt;0&lt;/code&gt; 은 작업 트리의 현재 상태를 나타내지 만 병합 충돌의 경우 다른 번호를 사용할 수 있습니다. 이러한 경우, &lt;code&gt;IndexEntry&lt;/code&gt; 의 다양한 스테이지 번호 는 파일의 현재 상태가 속하는 충돌의 어느 쪽 (들)을 설명합니다. 단계 &lt;code&gt;0&lt;/code&gt; 은 병합을 시도하기 전의 상태이고, 단계 &lt;code&gt;1&lt;/code&gt; 은 로컬에서 수행 된 변경이며, 단계 &lt;code&gt;2&lt;/code&gt; 이상은 다른 브랜치 (예 : 다중 분기 &quot;문어&quot;병합의 경우 단계)의 변경을위한 것입니다. &lt;code&gt;2&lt;/code&gt; , &lt;code&gt;3&lt;/code&gt; 및 &lt;code&gt;4&lt;/code&gt; 가 사용될 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="129f24b071e084dab9af722a0959ecf2337e059d" translate="yes" xml:space="preserve">
          <source>Get the step size of an &lt;a href=&quot;#Base.AbstractRange&quot;&gt;&lt;code&gt;AbstractRange&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;#Base.AbstractRange&quot;&gt; &lt;code&gt;AbstractRange&lt;/code&gt; &lt;/a&gt; 객체 의 단계 크기를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="8858aa789b8a95e917ca5b8edf3cb4cfb4672953" translate="yes" xml:space="preserve">
          <source>Get the system time in seconds since the epoch, with fairly high (typically, microsecond) resolution.</source>
          <target state="translated">에포크 (epoch) 이후 시스템 시간 (초)을 상당히 높은 (일반적으로 마이크로 초) 해상도로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="95239b12c16c016f41ece1f43f66824450caaa42" translate="yes" xml:space="preserve">
          <source>Get the time in nanoseconds. The time corresponding to 0 is undefined, and wraps every 5.8 years.</source>
          <target state="translated">나노초로 시간을 가져옵니다. 0에 해당하는 시간은 정의되어 있지 않으며 5.8 년마다 줄 바꿈됩니다.</target>
        </trans-unit>
        <trans-unit id="b24f1d764ec96114bfff224327fcd8d0d0abdd31" translate="yes" xml:space="preserve">
          <source>Get the total free memory in RAM in kilobytes.</source>
          <target state="translated">RAM에서 사용 가능한 총 메모리를 킬로바이트 단위로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d5e4ce0e0a7ea7ef86f926adb946a71d925d5beb" translate="yes" xml:space="preserve">
          <source>Get the total memory in RAM (including that which is currently used) in kilobytes.</source>
          <target state="translated">RAM의 총 메모리 (현재 사용 된 메모리 포함)를 킬로바이트 단위로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e98e2a89d68b00f3fd77d6a63a6d2c70dc724cf3" translate="yes" xml:space="preserve">
          <source>Get the value of the C library's &lt;code&gt;errno&lt;/code&gt;. If an argument is specified, it is used to set the value of &lt;code&gt;errno&lt;/code&gt;.</source>
          <target state="translated">C 라이브러리의 &lt;code&gt;errno&lt;/code&gt; 값을 가져옵니다 . 인수가 지정되면 &lt;code&gt;errno&lt;/code&gt; 값을 설정하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c2268d21fbee620aaff052e88aa0c0825d399931" translate="yes" xml:space="preserve">
          <source>Get the value type of an dictionary type. Behaves similarly to &lt;a href=&quot;#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사전 유형의 값 유형을 가져옵니다. &lt;a href=&quot;#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt; 과 유사하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="9d8ca9fec9f5e29ac3cbc1f3abc652c135b52ec1" translate="yes" xml:space="preserve">
          <source>Get the vector of processes mapping the shared array.</source>
          <target state="translated">공유 배열을 매핑하는 프로세스 벡터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="db2afe93edd474fc522d8c7d75cb7a001e5b61fe" translate="yes" xml:space="preserve">
          <source>Gets all of the IP addresses of the &lt;code&gt;host&lt;/code&gt;. Uses the operating system's underlying &lt;code&gt;getaddrinfo&lt;/code&gt; implementation, which may do a DNS lookup.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; 의 모든 IP 주소를 가져옵니다 . 운영 체제의 기본 &lt;code&gt;getaddrinfo&lt;/code&gt; 구현을 사용하여 DNS 조회를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a284592991f22190fd532a8317fc543ce797cfe4" translate="yes" xml:space="preserve">
          <source>Gets the first IP address of the &lt;code&gt;host&lt;/code&gt; of the specified &lt;code&gt;IPAddr&lt;/code&gt; type. Uses the operating system's underlying getaddrinfo implementation, which may do a DNS lookup.</source>
          <target state="translated">지정된 &lt;code&gt;IPAddr&lt;/code&gt; &lt;code&gt;host&lt;/code&gt; 의 첫 번째 IP 주소를 가져 옵니다. 유형 . 운영 체제의 기본 getaddrinfo 구현을 사용하여 DNS 조회를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7f3acf6ca590093170d5ddc3c9107d6f1324074" translate="yes" xml:space="preserve">
          <source>Getting Around</source>
          <target state="translated">둘러보기</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">시작하기</target>
        </trans-unit>
        <trans-unit id="04ccf152a8a13833ef0a70fb0a973a671f0ea746" translate="yes" xml:space="preserve">
          <source>Getting the hygiene rules correct can be a formidable challenge. Before using a macro, you might want to consider whether a function closure would be sufficient. Another useful strategy is to defer as much work as possible to runtime. For example, many macros simply wrap their arguments in a &lt;code&gt;QuoteNode&lt;/code&gt; or other similar &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt;. Some examples of this include &lt;code&gt;@task body&lt;/code&gt; which simply returns &lt;code&gt;schedule(Task(() -&amp;gt; $body))&lt;/code&gt;, and &lt;code&gt;@eval expr&lt;/code&gt;, which simply returns &lt;code&gt;eval(QuoteNode(expr))&lt;/code&gt;.</source>
          <target state="translated">위생 규칙을 올바르게 작성하는 것은 큰 도전이 될 수 있습니다. 매크로를 사용하기 전에 함수 클로저가 충분한 지 고려할 수 있습니다. 또 다른 유용한 전략은 가능한 많은 작업을 런타임에 연기하는 것입니다. 예를 들어, 많은 매크로는 단순히 인수를 &lt;code&gt;QuoteNode&lt;/code&gt; 또는 다른 유사한 &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; 로&lt;/a&gt; 랩핑합니다 . 이 중 일부 예는 &lt;code&gt;@task body&lt;/code&gt; 단순히 반환 &lt;code&gt;schedule(Task(() -&amp;gt; $body))&lt;/code&gt; , 및 &lt;code&gt;@eval expr&lt;/code&gt; 단순히 반환, &lt;code&gt;eval(QuoteNode(expr))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf44c9857b696454c5ef1ca708da5e3ee8a0b24a" translate="yes" xml:space="preserve">
          <source>Ghost</source>
          <target state="translated">Ghost</target>
        </trans-unit>
        <trans-unit id="4a4c89342a61073746cb0be5c482a4f233f70856" translate="yes" xml:space="preserve">
          <source>Gimel Symbol / Third Transfinite Cardinal</source>
          <target state="translated">기멜 상징 / 제 3의 영원한 추기경</target>
        </trans-unit>
        <trans-unit id="29fb58174b748291968c938f5144e432d7a05bc1" translate="yes" xml:space="preserve">
          <source>Girl</source>
          <target state="translated">Girl</target>
        </trans-unit>
        <trans-unit id="585f3a3c7ecf6be9b08fcb5c41bd3f7b4064386b" translate="yes" xml:space="preserve">
          <source>Give a hint to the compiler that this function is worth inlining.</source>
          <target state="translated">컴파일러에게이 함수가 인라인 할 가치가 있다는 힌트를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="f9f77d5a362582fb87b0f06e19b1b57c8b1806c3" translate="yes" xml:space="preserve">
          <source>Give the number of columns needed to print a character.</source>
          <target state="translated">문자를 인쇄하는 데 필요한 열 수를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="d66cd5d2057c5b56255474647800cbbea7c7ec15" translate="yes" xml:space="preserve">
          <source>Give the number of columns needed to print a string.</source>
          <target state="translated">문자열을 인쇄하는 데 필요한 열 수를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="990b49394e3cec090496333dd6dda71ca867283b" translate="yes" xml:space="preserve">
          <source>Given a &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;-like function &lt;code&gt;writefunc&lt;/code&gt;, which takes an I/O stream as its first argument, &lt;code&gt;base64encode(writefunc, args...)&lt;/code&gt; calls &lt;code&gt;writefunc&lt;/code&gt; to write &lt;code&gt;args...&lt;/code&gt; to a base64-encoded string, and returns the string. &lt;code&gt;base64encode(args...)&lt;/code&gt; is equivalent to &lt;code&gt;base64encode(write, args...)&lt;/code&gt;: it converts its arguments into bytes using the standard &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; functions and returns the base64-encoded string.</source>
          <target state="translated">I / O 스트림을 첫 번째 인수로 사용 하는 &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 유사 함수 인 &lt;code&gt;writefunc&lt;/code&gt; 가 주어지면 base64encode &lt;code&gt;base64encode(writefunc, args...)&lt;/code&gt; 는 &lt;code&gt;writefunc&lt;/code&gt; 를 호출 하여 &lt;code&gt;args...&lt;/code&gt; 를 base64로 인코딩 된 문자열 에 쓰고 문자열을 반환합니다. &lt;code&gt;base64encode(args...)&lt;/code&gt; 는 &lt;code&gt;base64encode(write, args...)&lt;/code&gt; 같습니다. 표준 &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 인수를 바이트로 변환하고 base64로 인코딩 된 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f3d33bb8ba673cca2a309308e1c04181d32a390f" translate="yes" xml:space="preserve">
          <source>Given a &lt;code&gt;Ptr{T}&lt;/code&gt;, the contents of type &lt;code&gt;T&lt;/code&gt; can generally be copied from the referenced memory into a Julia object using &lt;code&gt;unsafe_load(ptr, [index])&lt;/code&gt;. The index argument is optional (default is 1), and follows the Julia-convention of 1-based indexing. This function is intentionally similar to the behavior of &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt; (e.g. &lt;code&gt;[]&lt;/code&gt; access syntax).</source>
          <target state="translated">&lt;code&gt;Ptr{T}&lt;/code&gt; 주어지면, 일반적으로 &lt;code&gt;T&lt;/code&gt; 유형의 내용은 &lt;code&gt;unsafe_load(ptr, [index])&lt;/code&gt; 사용하여 참조 된 메모리에서 Julia 객체로 복사 될 수 있습니다 . index 인수는 선택 사항이며 (기본값은 1) 1 기반 색인의 Julia 컨벤션을 따릅니다. 이 함수는 의도적으로 &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt; 의 동작과 유사합니다 ! (예 : &lt;code&gt;[]&lt;/code&gt; 액세스 구문).</target>
        </trans-unit>
        <trans-unit id="9276b00b5b100003171aa4d1b53dddc58e924e43" translate="yes" xml:space="preserve">
          <source>Given a collection type &lt;code&gt;S&lt;/code&gt;, it's currently assumed that if &lt;code&gt;rand(::S)&lt;/code&gt; is defined, an object of type &lt;code&gt;eltype(S)&lt;/code&gt; will be produced. In order to define random generation out of objects of type &lt;code&gt;S&lt;/code&gt;, the following method can be defined: &lt;code&gt;rand(rng::AbstractRNG, sp::Random.SamplerTrivial{S})&lt;/code&gt;. Here, &lt;code&gt;sp&lt;/code&gt; simply wraps an object of type &lt;code&gt;S&lt;/code&gt;, which can be accessed via &lt;code&gt;sp[]&lt;/code&gt;. Continuing the &lt;code&gt;Die&lt;/code&gt; example, we want now to define &lt;code&gt;rand(d::Die)&lt;/code&gt; to produce an &lt;code&gt;Int&lt;/code&gt; corresponding to one of &lt;code&gt;d&lt;/code&gt;'s sides:</source>
          <target state="translated">컬렉션 유형 &lt;code&gt;S&lt;/code&gt; 가 주어지면 현재 &lt;code&gt;rand(::S)&lt;/code&gt; 가 정의되면 &lt;code&gt;eltype(S)&lt;/code&gt; 유형의 객체 가 생성 된다고 가정합니다 . &lt;code&gt;S&lt;/code&gt; 유형의 오브젝트에서 무작위 생성을 정의하기 위해 다음 메소드를 정의 할 수 있습니다. &lt;code&gt;rand(rng::AbstractRNG, sp::Random.SamplerTrivial{S})&lt;/code&gt; . 여기서 &lt;code&gt;sp&lt;/code&gt; 는 단순히 &lt;code&gt;sp[]&lt;/code&gt; 를 통해 액세스 할 수있는 &lt;code&gt;S&lt;/code&gt; 유형의 객체를 래핑합니다 . &lt;code&gt;Die&lt;/code&gt; 예제를 계속 진행하면서 &lt;code&gt;rand(d::Die)&lt;/code&gt; 를 정의 하여 &lt;code&gt;d&lt;/code&gt; 의 측면 중 하나에 해당 하는 &lt;code&gt;Int&lt;/code&gt; 를 생성하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="c4f1730c953eabcee66d16110ac2417f817ee88b" translate="yes" xml:space="preserve">
          <source>Given a dictionary &lt;code&gt;D&lt;/code&gt;, the syntax &lt;code&gt;D[x]&lt;/code&gt; returns the value of key &lt;code&gt;x&lt;/code&gt; (if it exists) or throws an error, and &lt;code&gt;D[x] = y&lt;/code&gt; stores the key-value pair &lt;code&gt;x =&amp;gt; y&lt;/code&gt; in &lt;code&gt;D&lt;/code&gt; (replacing any existing value for the key &lt;code&gt;x&lt;/code&gt;). Multiple arguments to &lt;code&gt;D[...]&lt;/code&gt; are converted to tuples; for example, the syntax &lt;code&gt;D[x,y]&lt;/code&gt; is equivalent to &lt;code&gt;D[(x,y)]&lt;/code&gt;, i.e. it refers to the value keyed by the tuple &lt;code&gt;(x,y)&lt;/code&gt;.</source>
          <target state="translated">사전 &lt;code&gt;D&lt;/code&gt; 가 주어지면 구문 &lt;code&gt;D[x]&lt;/code&gt; 는 키 &lt;code&gt;x&lt;/code&gt; 의 값을 반환 하거나 (있는 경우) 오류를 발생시키고, &lt;code&gt;D[x] = y&lt;/code&gt; 는 키-값 쌍 &lt;code&gt;x =&amp;gt; y&lt;/code&gt; 를 &lt;code&gt;D&lt;/code&gt; 에 저장합니다 (기존의 모든 것을 대체 함) 키 &lt;code&gt;x&lt;/code&gt; 값 ). &lt;code&gt;D[...]&lt;/code&gt; 대한 여러 인수 는 튜플로 변환됩니다. 예를 들어, 구문 &lt;code&gt;D[x,y]&lt;/code&gt; 는 &lt;code&gt;D[(x,y)]&lt;/code&gt; 와 같습니다. 즉, 튜플 &lt;code&gt;(x,y)&lt;/code&gt; 에 의해 키가 지정된 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="6aeb65e7ccb967c9455ef2f486079851e21e2b6b" translate="yes" xml:space="preserve">
          <source>Given a pointer to an execution context (usually generated by a call to &lt;code&gt;backtrace&lt;/code&gt;), looks up stack frame context information. Returns an array of frame information for all functions inlined at that point, innermost function first.</source>
          <target state="translated">실행 컨텍스트에 대한 포인터 (주로 &lt;code&gt;backtrace&lt;/code&gt; 호출에 의해 생성됨 )가 제공되면 스택 프레임 컨텍스트 정보를 찾습니다. 그 시점에서 가장 안쪽에있는 함수부터 인라인 된 모든 함수에 대한 프레임 정보 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fcada796f1c4aca1cfb31ae96c64d212e649ecf0" translate="yes" xml:space="preserve">
          <source>Given a predicate function &lt;code&gt;flt&lt;/code&gt; and an iterable object &lt;code&gt;itr&lt;/code&gt;, return an iterable object which upon iteration yields the elements &lt;code&gt;x&lt;/code&gt; of &lt;code&gt;itr&lt;/code&gt; that satisfy &lt;code&gt;flt(x)&lt;/code&gt;. The order of the original iterator is preserved.</source>
          <target state="translated">술어 함수 &lt;code&gt;flt&lt;/code&gt; 와 iterable 객체 &lt;code&gt;itr&lt;/code&gt; 이 주어지면 iterable 객체 를 리턴하십시오. iterable 객체는 itt의 반복 요소가 &lt;code&gt;flt(x)&lt;/code&gt; 를 만족시키는 &lt;code&gt;itr&lt;/code&gt; 의 요소 &lt;code&gt;x&lt;/code&gt; 를 산출합니다 . 원래 반복자의 순서는 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="c16f746a1658b9d1859c84c436dc50bdb9fe0a85" translate="yes" xml:space="preserve">
          <source>Given a previous profiling run, determine who called a particular function. Supplying the filename (and optionally, range of line numbers over which the function is defined) allows you to disambiguate an overloaded method. The returned value is a vector containing a count of the number of calls and line information about the caller. One can optionally supply backtrace &lt;code&gt;data&lt;/code&gt; obtained from &lt;a href=&quot;#Profile.retrieve&quot;&gt;&lt;code&gt;retrieve&lt;/code&gt;&lt;/a&gt;; otherwise, the current internal profile buffer is used.</source>
          <target state="translated">이전 프로파일 링 실행에서 특정 기능을 호출 한 사람을 결정하십시오. 파일 이름 (및 선택적으로 함수가 정의 된 행 번호 범위)을 제공하면 오버로드 된 메소드를 명확하게 할 수 있습니다. 반환 된 값은 발신자 수와 발신자에 대한 회선 정보를 포함하는 벡터입니다. &lt;a href=&quot;#Profile.retrieve&quot;&gt; &lt;code&gt;retrieve&lt;/code&gt; &lt;/a&gt; 에서 얻은 역 추적 &lt;code&gt;data&lt;/code&gt; 를 선택적으로 제공 할 수 있습니다 . 그렇지 않으면 현재 내부 프로파일 버퍼가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="67104b7201b61b9623c8478911e24c6cfc8b97bc" translate="yes" xml:space="preserve">
          <source>Given a single iterable argument, constructs a &lt;a href=&quot;#Base.Dict&quot;&gt;&lt;code&gt;Dict&lt;/code&gt;&lt;/a&gt; whose key-value pairs are taken from 2-tuples &lt;code&gt;(key,value)&lt;/code&gt; generated by the argument.</source>
          <target state="translated">반복 가능한 단일 인수 가 제공되면 인수에 의해 생성 된 2 개의 튜플 &lt;code&gt;(key,value)&lt;/code&gt; 에서 키-값 쌍을 가져 오는 &lt;a href=&quot;#Base.Dict&quot;&gt; &lt;code&gt;Dict&lt;/code&gt; &lt;/a&gt; 를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="a19217b165ec900e8bae935104c81bb7e032d599" translate="yes" xml:space="preserve">
          <source>Given a starting value, construct a range either by length or from &lt;code&gt;start&lt;/code&gt; to &lt;code&gt;stop&lt;/code&gt;, optionally with a given step (defaults to 1, a &lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt;&lt;code&gt;UnitRange&lt;/code&gt;&lt;/a&gt;). One of &lt;code&gt;length&lt;/code&gt; or &lt;code&gt;stop&lt;/code&gt; is required. If &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, and &lt;code&gt;step&lt;/code&gt; are all specified, they must agree.</source>
          <target state="translated">시작 값이 주어지면 선택적으로 주어진 단계 (기본값은 1, &lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt; &lt;code&gt;UnitRange&lt;/code&gt; &lt;/a&gt; ) 로 길이 또는 &lt;code&gt;start&lt;/code&gt; 부터 &lt;code&gt;stop&lt;/code&gt; 까지 범위를 구성하십시오 . &lt;code&gt;length&lt;/code&gt; 또는 &lt;code&gt;stop&lt;/code&gt; 중 하나 가 필요합니다. 경우 &lt;code&gt;length&lt;/code&gt; , &lt;code&gt;stop&lt;/code&gt; 및 &lt;code&gt;step&lt;/code&gt; 모두 지정되어, 그들은 동의해야합니다.</target>
        </trans-unit>
        <trans-unit id="e6bf5e1364f77d196c7b9a51bb62bde8f133bcde" translate="yes" xml:space="preserve">
          <source>Given a string or array &lt;code&gt;s&lt;/code&gt; of ASCII codes for a sequence of hexadecimal digits, returns a &lt;code&gt;Vector{UInt8}&lt;/code&gt; of bytes corresponding to the binary representation: each successive pair of hexadecimal digits in &lt;code&gt;s&lt;/code&gt; gives the value of one byte in the return vector.</source>
          <target state="translated">16 진 숫자의 시퀀스에 대해 ASCII 코드 &lt;code&gt;s&lt;/code&gt; 문자열 또는 배열이 주어지면 2 진 표현에 해당하는 바이트 의 &lt;code&gt;Vector{UInt8}&lt;/code&gt; 바이트를 리턴합니다 . &lt;code&gt;s&lt;/code&gt; 의 16 진 숫자 쌍 각각 은 리턴 벡터에서 1 바이트의 값을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8d6a85425c1e72a27deafaba610d488a3457e0f2" translate="yes" xml:space="preserve">
          <source>Given a type &lt;code&gt;T&lt;/code&gt;, it's currently assumed that if &lt;code&gt;rand(T)&lt;/code&gt; is defined, an object of type &lt;code&gt;T&lt;/code&gt; will be produced. In order to define random generation of values of type &lt;code&gt;T&lt;/code&gt;, the following method can be defined: &lt;code&gt;rand(rng::AbstractRNG, ::Random.SamplerType{T})&lt;/code&gt; (this should return what &lt;code&gt;rand(rng, T)&lt;/code&gt; is expected to return).</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 가 주어지면 현재 &lt;code&gt;rand(T)&lt;/code&gt; 가 정의되면 유형 &lt;code&gt;T&lt;/code&gt; 의 객체 가 생성 된다고 가정합니다 . &lt;code&gt;T&lt;/code&gt; 유형의 임의 값 생성을 정의하기 위해 다음과 같은 방법을 정의 할 수 있습니다. &lt;code&gt;rand(rng::AbstractRNG, ::Random.SamplerType{T})&lt;/code&gt; ( &lt;code&gt;rand(rng, T)&lt;/code&gt; 가 리턴 할 것으로 예상되는 것을 리턴해야합니다. ).</target>
        </trans-unit>
        <trans-unit id="60e4af8cc8de60ffb69850d252bdcd98ee3d2bfa" translate="yes" xml:space="preserve">
          <source>Given an AbstractArray &lt;code&gt;A&lt;/code&gt;, create a view &lt;code&gt;B&lt;/code&gt; such that the dimensions appear to be permuted. Similar to &lt;code&gt;permutedims&lt;/code&gt;, except that no copying occurs (&lt;code&gt;B&lt;/code&gt; shares storage with &lt;code&gt;A&lt;/code&gt;).</source>
          <target state="translated">AbstractArray &lt;code&gt;A&lt;/code&gt; 가 주어지면 치수가 순열 된 것처럼 보이도록 뷰 &lt;code&gt;B&lt;/code&gt; 를 만듭니다 . 복사가 발생하지 않는다는 점을 제외하고 &lt;code&gt;permutedims&lt;/code&gt; 과 유사 합니다 ( &lt;code&gt;B&lt;/code&gt; 는 스토리지를 &lt;code&gt;A&lt;/code&gt; 와 공유 함 ).</target>
        </trans-unit>
        <trans-unit id="2273302d369651afdbde86cc33fa4cfcb401046e" translate="yes" xml:space="preserve">
          <source>Given an expression object, one can cause Julia to evaluate (execute) it at global scope using &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">표현 객체가 주어지면 Julia가 &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; 을&lt;/a&gt; 사용하여 전역 범위에서 그것을 평가 (실행)시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6bcc48e1bcaa064479ac3ce6a9aad0b807686849" translate="yes" xml:space="preserve">
          <source>Given an index &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;reverse(v)&lt;/code&gt;, return the corresponding index in &lt;code&gt;v&lt;/code&gt; so that &lt;code&gt;v[reverseind(v,i)] == reverse(v)[i]&lt;/code&gt;. (This can be nontrivial in cases where &lt;code&gt;v&lt;/code&gt; contains non-ASCII characters.)</source>
          <target state="translated">&lt;code&gt;reverse(v)&lt;/code&gt; 의 인덱스 &lt;code&gt;i&lt;/code&gt; 가 주어지면 &lt;code&gt;v[reverseind(v,i)] == reverse(v)[i]&lt;/code&gt; 되도록 &lt;code&gt;v&lt;/code&gt; 의 해당 인덱스를 반환하십시오 . ( &lt;code&gt;v&lt;/code&gt; 에 ASCII가 아닌 문자가 포함 된 경우에는 쉽지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="214692258e5d3f03bf0e19a0c7bce6fe690232a0" translate="yes" xml:space="preserve">
          <source>Given an iterator &lt;code&gt;itr&lt;/code&gt;, then &lt;code&gt;reverse(itr)&lt;/code&gt; is an iterator over the same collection but in the reverse order.</source>
          <target state="translated">반복자 감안할 때 &lt;code&gt;itr&lt;/code&gt; 다음 &lt;code&gt;reverse(itr)&lt;/code&gt; 같은 콜렉션하지만 역순 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="089e5e83e8607aed09695c30f3dd1c60f5798574" translate="yes" xml:space="preserve">
          <source>Given an iterator that yields iterators, return an iterator that yields the elements of those iterators. Put differently, the elements of the argument iterator are concatenated.</source>
          <target state="translated">반복자를 생성하는 반복자가 주어진 경우 해당 반복자의 요소를 생성하는 반복자를 리턴하십시오. 다르게 말하면, 인수 반복자의 요소는 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="3c9b417cfac83aea8a69f80d6bc8cf9a41f8a58a" translate="yes" xml:space="preserve">
          <source>Given such a declaration, for each choice of &lt;code&gt;T&lt;/code&gt;, we have &lt;code&gt;Point{T}&lt;/code&gt; as a subtype of &lt;code&gt;Pointy{T}&lt;/code&gt;:</source>
          <target state="translated">그러한 선언이 주어지면 &lt;code&gt;T&lt;/code&gt; 의 각 선택에 대해 &lt;code&gt;Pointy{T}&lt;/code&gt; 의 하위 유형으로 &lt;code&gt;Point{T}&lt;/code&gt; 가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="d716647091cd161029df5d10c16015ae51186d66" translate="yes" xml:space="preserve">
          <source>Given the git configuration file containing:</source>
          <target state="translated">git 구성 파일에 다음이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="915ac53cd4c78783b139cec5dd22b4b42ed2b99a" translate="yes" xml:space="preserve">
          <source>Given the statement &lt;code&gt;using Foo&lt;/code&gt;, the system consults an internal table of top-level modules to look for one named &lt;code&gt;Foo&lt;/code&gt;. If the module does not exist, the system attempts to &lt;code&gt;require(:Foo)&lt;/code&gt;, which typically results in loading code from an installed package.</source>
          <target state="translated">문을 감안할 때 &lt;code&gt;using Foo&lt;/code&gt; , 시스템은 이름 하나를 찾기 위해 최상위 모듈의 내부 테이블을 참조합니다 &lt;code&gt;Foo&lt;/code&gt; . 모듈이 존재하지 않는 경우 시스템은 &lt;code&gt;require(:Foo)&lt;/code&gt; 시도하여 일반적으로 설치된 패키지에서 코드를로드합니다.</target>
        </trans-unit>
        <trans-unit id="06fe662af1da02e3f2ea7cf7081d137d14c1ea88" translate="yes" xml:space="preserve">
          <source>Given the type of an iterator, return one of the following values:</source>
          <target state="translated">반복자의 유형이 주어지면 다음 값 중 하나를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="712fa051470c666b0b3c1cf4e1eb3b5cdf800a89" translate="yes" xml:space="preserve">
          <source>Given this dependency &lt;code&gt;graph&lt;/code&gt;, when Julia sees &lt;code&gt;import Priv&lt;/code&gt; in the &lt;code&gt;Pub&lt;/code&gt; package&amp;mdash;which has UUID &lt;code&gt;c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1&lt;/code&gt;&amp;mdash;it looks up:</source>
          <target state="translated">이 종속성 &lt;code&gt;graph&lt;/code&gt; 주어지면 Julia가 &lt;code&gt;Pub&lt;/code&gt; 패키지에서 UUID &lt;code&gt;c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1&lt;/code&gt; 이 있는 &lt;code&gt;import Priv&lt;/code&gt; 를 볼 때 다음을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="617b3c70bd8eb4654d1000dde442b1913a3d57c6" translate="yes" xml:space="preserve">
          <source>Given this roots map, in &lt;code&gt;App&lt;/code&gt;'s code the statement &lt;code&gt;import Priv&lt;/code&gt; will cause Julia to look up &lt;code&gt;roots[:Priv]&lt;/code&gt;, which yields &lt;code&gt;ba13f791-ae1d-465a-978b-69c3ad90f72b&lt;/code&gt;, the UUID of the &lt;code&gt;Priv&lt;/code&gt; package that is to be loaded in that context. This UUID identifies which &lt;code&gt;Priv&lt;/code&gt; package to load and use when the main application evaluates &lt;code&gt;import Priv&lt;/code&gt;.</source>
          <target state="translated">이 뿌리에,지도 감안할 때 &lt;code&gt;App&lt;/code&gt; 의 코드 문 &lt;code&gt;import Priv&lt;/code&gt; 찾아 볼 줄리아의 원인이됩니다 &lt;code&gt;roots[:Priv]&lt;/code&gt; 산출, &lt;code&gt;ba13f791-ae1d-465a-978b-69c3ad90f72b&lt;/code&gt; 을 의의 UUID &lt;code&gt;Priv&lt;/code&gt; 에서로드 될 패키지 그 맥락. 이 UUID 는 기본 애플리케이션이 &lt;code&gt;import Priv&lt;/code&gt; 평가할 때로드하고 사용할 &lt;code&gt;Priv&lt;/code&gt; 패키지를 식별 합니다.</target>
        </trans-unit>
        <trans-unit id="b509e583621052cb07bc486839dfdb1f16ed86dc" translate="yes" xml:space="preserve">
          <source>Global Scope</source>
          <target state="translated">글로벌 범위</target>
        </trans-unit>
        <trans-unit id="2ff4e53e2b802e1ec127c83da80fa5fc4b5333fa" translate="yes" xml:space="preserve">
          <source>Global Variables</source>
          <target state="translated">글로벌 변수</target>
        </trans-unit>
        <trans-unit id="40501a9e5007169fb629c5387c4f8fb6e999c42d" translate="yes" xml:space="preserve">
          <source>Global constants are declared as constants on remote nodes too.</source>
          <target state="translated">전역 상수는 원격 노드에서도 상수로 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="389f13ca82ff7a2453bc65e6b170fb5bce0e7be4" translate="yes" xml:space="preserve">
          <source>Global counters (for example, for attempting to uniquely identify objects). Consider the following code snippet:</source>
          <target state="translated">전역 카운터 (예 : 개체를 고유하게 식별하려는 경우) 다음 코드 스 니펫을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="9f22cff33a2ca414f07ad83aad20cf6de8acaeaf" translate="yes" xml:space="preserve">
          <source>Global variable referring to the standard error stream.</source>
          <target state="translated">표준 오류 스트림을 참조하는 전역 변수.</target>
        </trans-unit>
        <trans-unit id="9aa21a682323865a22d83920da0f441d6c030675" translate="yes" xml:space="preserve">
          <source>Global variable referring to the standard input stream.</source>
          <target state="translated">표준 입력 스트림을 참조하는 전역 변수.</target>
        </trans-unit>
        <trans-unit id="51d6faf5f0e0e6c01ea9efaf0aad4dbd11c26673" translate="yes" xml:space="preserve">
          <source>Global variable referring to the standard out stream.</source>
          <target state="translated">표준 출력 스트림을 참조하는 전역 변수.</target>
        </trans-unit>
        <trans-unit id="70ae8e14e7d7a8122e7468fd602556f9b4388301" translate="yes" xml:space="preserve">
          <source>Global variables</source>
          <target state="translated">글로벌 변수</target>
        </trans-unit>
        <trans-unit id="7d6e1e2bd4cbe556d039d09149551410bf54cb41" translate="yes" xml:space="preserve">
          <source>Global variables exported by native libraries can be accessed by name using the &lt;a href=&quot;../../base/c/index#Core.Intrinsics.cglobal&quot;&gt;&lt;code&gt;cglobal&lt;/code&gt;&lt;/a&gt; function. The arguments to &lt;a href=&quot;../../base/c/index#Core.Intrinsics.cglobal&quot;&gt;&lt;code&gt;cglobal&lt;/code&gt;&lt;/a&gt; are a symbol specification identical to that used by &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;, and a type describing the value stored in the variable:</source>
          <target state="translated">기본 라이브러리로 내 보낸 전역 변수는 &lt;a href=&quot;../../base/c/index#Core.Intrinsics.cglobal&quot;&gt; &lt;code&gt;cglobal&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 이름으로 액세스 할 수 있습니다 . 의 인수 &lt;a href=&quot;../../base/c/index#Core.Intrinsics.cglobal&quot;&gt; &lt;code&gt;cglobal&lt;/code&gt; &lt;/a&gt; 사용하는 것과 동일한 기호 사양이다 &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; , 변수에 저장된 값을 나타내는 유형 :</target>
        </trans-unit>
        <trans-unit id="d02d943210f33ec6146b40f17e3a1be495a87492" translate="yes" xml:space="preserve">
          <source>Globals are re-sent to a destination worker only in the context of a remote call, and then only if its value has changed. Also, the cluster does not synchronize global bindings across nodes. For example:</source>
          <target state="translated">전역 통화는 원격 통화 컨텍스트에서만 대상 작업자에게 재전송되며 값이 변경된 경우에만 재전송됩니다. 또한 클러스터는 노드 간 전역 바인딩을 동기화하지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb02a2aa39a487184ec2e48cce6d9541aa570f94" translate="yes" xml:space="preserve">
          <source>Globals under modules other than &lt;code&gt;Main&lt;/code&gt; are not serialized by value to the remote node. Only a reference is sent. Functions which create global bindings (except under &lt;code&gt;Main&lt;/code&gt;) may cause an &lt;code&gt;UndefVarError&lt;/code&gt; to be thrown later.</source>
          <target state="translated">&lt;code&gt;Main&lt;/code&gt; 이외의 모듈 아래의 전역 은 값으로 원격 노드에 직렬화되지 않습니다. 참조 만 전송됩니다. 전역 바인딩을 만드는 함수 ( &lt;code&gt;Main&lt;/code&gt; 제외 )는 나중에 &lt;code&gt;UndefVarError&lt;/code&gt; 를 발생 시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="acd336be94f1ee162a48e523127d9e5b06609fb8" translate="yes" xml:space="preserve">
          <source>Globe With Meridians</source>
          <target state="translated">자오선을 가진 지구</target>
        </trans-unit>
        <trans-unit id="bf6d33bf807dc90549a0d0bac64e3cc4b4bb46ed" translate="yes" xml:space="preserve">
          <source>Glowing Star</source>
          <target state="translated">빛나는 별</target>
        </trans-unit>
        <trans-unit id="0e3f5fc25846b7ffc7fbf7ea4a19522f60c6c683" translate="yes" xml:space="preserve">
          <source>Goat</source>
          <target state="translated">Goat</target>
        </trans-unit>
        <trans-unit id="dab8916b317afa94c1e7d2eb18cfc9628289063b" translate="yes" xml:space="preserve">
          <source>Good performance, approaching that of statically-compiled languages like C</source>
          <target state="translated">C와 같이 정적으로 컴파일 된 언어에 근접한 우수한 성능</target>
        </trans-unit>
        <trans-unit id="85116c6b5a5273ba053319524800267c175695d4" translate="yes" xml:space="preserve">
          <source>Graduation Cap</source>
          <target state="translated">졸업 캡</target>
        </trans-unit>
        <trans-unit id="0de47448267ba383673ef343ee1313af6fa63b74" translate="yes" xml:space="preserve">
          <source>Grapes</source>
          <target state="translated">Grapes</target>
        </trans-unit>
        <trans-unit id="2ef67b67ccfcf902b5da0d871f7bce811117ba2c" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Double-Line Equal Above Less-Than</source>
          <target state="translated">이중선보다 큰 선보다 작은 선보다 큼</target>
        </trans-unit>
        <trans-unit id="5bf36d0687ba161c1ddd5ae9a710ac6b84c65e73" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Less-Than Above Double-Line Equal</source>
          <target state="translated">더블 라인 이상보다 큼</target>
        </trans-unit>
        <trans-unit id="cda9caba673dd1973f8c7d113746b0e633f4f938" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Similar Above Less-Than</source>
          <target state="translated">위의 것보다 위의 것</target>
        </trans-unit>
        <trans-unit id="3a03ecfc7255d8cacd17931a2c17d195720afbd9" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Similar Or Equal</source>
          <target state="translated">비슷하거나 동등 이상</target>
        </trans-unit>
        <trans-unit id="eed03df20a091917ea38ceacb7e9c2b67e0f9bb2" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Slanted Equal Above Less-Than Above Slanted Equal</source>
          <target state="translated">경사 이상 동일 이상 경사 이상 동일 이상</target>
        </trans-unit>
        <trans-unit id="ec6a31bc7051547d44e2c612da8aa15b61e41be6" translate="yes" xml:space="preserve">
          <source>Greater-Than And Not Approximate</source>
          <target state="translated">크거나 같지 않음</target>
        </trans-unit>
        <trans-unit id="852f9d0047fa29fbc8fb2cb24463f569deef89ef" translate="yes" xml:space="preserve">
          <source>Greater-Than And Single-Line Not Equal To</source>
          <target state="translated">보다 크고 단선이 같지 않음</target>
        </trans-unit>
        <trans-unit id="52afc7afef44a974f7bc9b05b1e17bf964f408a0" translate="yes" xml:space="preserve">
          <source>Greater-Than Beside Less-Than</source>
          <target state="translated">적은 것보다 큰 것</target>
        </trans-unit>
        <trans-unit id="8002394d4a4c3c62e2b6ebf6a841410b987f3fe3" translate="yes" xml:space="preserve">
          <source>Greater-Than But Not Equal To / Greater Than But Not Equal To</source>
          <target state="translated">크지 만 같지 않음 / 같지만 같지 않음</target>
        </trans-unit>
        <trans-unit id="9f51323c1f1f2bd6fed8b0133087b13833db9603" translate="yes" xml:space="preserve">
          <source>Greater-Than But Not Equal To / Greater Than But Not Equal To + Variation Selector-1</source>
          <target state="translated">크지 만 같지 않음 / 같지만 같지 않음 + 변형 선택기 -1</target>
        </trans-unit>
        <trans-unit id="a9e5efe496a2b31f56957d4e597885897f8e0eb9" translate="yes" xml:space="preserve">
          <source>Greater-Than But Not Equivalent To / Greater Than But Not Equivalent To</source>
          <target state="translated">크지 만 같지 않음 / 같지만 같지 않음</target>
        </trans-unit>
        <trans-unit id="98eff7a1e60f594f0f81d4c3e83cbf5209423bb1" translate="yes" xml:space="preserve">
          <source>Greater-Than Closed By Curve</source>
          <target state="translated">곡선으로 닫힌 것보다</target>
        </trans-unit>
        <trans-unit id="099b37f93e6b34dbfa7c526c5fa3f13b59c30374" translate="yes" xml:space="preserve">
          <source>Greater-Than Closed By Curve Above Slanted Equal</source>
          <target state="translated">경사가 같을 때 곡선으로 닫힌 것보다 큼</target>
        </trans-unit>
        <trans-unit id="bb2d6f56b2861cf6b4d17b1cfddecb19b41dd882" translate="yes" xml:space="preserve">
          <source>Greater-Than Equal To Or Less-Than / Greater Than Equal To Or Less Than</source>
          <target state="translated">크거나 같거나 작거나 같거나 크거나 같음</target>
        </trans-unit>
        <trans-unit id="1f9f324edcdf276db2fba93d474c1d37dd1409bf" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Approximate</source>
          <target state="translated">더 크거나 대략</target>
        </trans-unit>
        <trans-unit id="816b73122f7826a76fc5a27a59be585ac1c20c8e" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Equal To / Greater Than Or Equal To</source>
          <target state="translated">보다 크거나 같거나보다 크거나 같음</target>
        </trans-unit>
        <trans-unit id="22f6cd5ba77c22771ae0dcb6dec580b58470b15f" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Equivalent To / Greater Than Or Equivalent To</source>
          <target state="translated">보다 크거나 같거나보다 크거나 같음</target>
        </trans-unit>
        <trans-unit id="da7070ff7fe0d357657567e892ae9e792dd0711c" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Less-Than / Greater Than Or Less Than</source>
          <target state="translated">보다 크거나 작거나 / 크거나 작음</target>
        </trans-unit>
        <trans-unit id="fc2308a37940cf5145837f4b055616cdf8ed8663" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To</source>
          <target state="translated">크거나 같음</target>
        </trans-unit>
        <trans-unit id="fc0db4bdca25b60daf5c07123869e9c3373f86d1" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">더 길거나 기울어 짐 같음 + 긴 고 상선 오버레이 / 비 간격 롱 슬래시 오버레이 결합</target>
        </trans-unit>
        <trans-unit id="3d2877fe16bd8c1aff6ca20742e54d7c40adcfb5" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To With Dot Above</source>
          <target state="translated">위의 점과 같거나 크게 기울어 짐</target>
        </trans-unit>
        <trans-unit id="5b85b82c5dfec29b3e76371a3c759b7b564d0dcc" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To With Dot Above Left</source>
          <target state="translated">왼쪽 위의 점과 같거나 더 크거나 기울어 짐</target>
        </trans-unit>
        <trans-unit id="324053698d665835c3c8543b9475493cada464ce" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To With Dot Inside</source>
          <target state="translated">점 내부와 같거나 더 크거나 기울어 짐</target>
        </trans-unit>
        <trans-unit id="eaf2aeee67af979dcb4bf973f1c28801c9b3c428" translate="yes" xml:space="preserve">
          <source>Greater-Than Over Equal To / Greater Than Over Equal To</source>
          <target state="translated">같거나보다 큼 /보다 같음</target>
        </trans-unit>
        <trans-unit id="88e04ffb7bbd7b8b561e5e62dab6aaf4e8ec7d4c" translate="yes" xml:space="preserve">
          <source>Greater-Than Overlapping Less-Than</source>
          <target state="translated">겹치는 것보다 큼 겹치는 것</target>
        </trans-unit>
        <trans-unit id="7eb5603be44b831a023cfdcd22f839b5f6f5bded" translate="yes" xml:space="preserve">
          <source>Greater-Than With Circle Inside</source>
          <target state="translated">안에 동그라미와 큰</target>
        </trans-unit>
        <trans-unit id="f158072571829726fe84a7ad0ce7a50ef1ab0879" translate="yes" xml:space="preserve">
          <source>Greater-Than With Dot / Greater Than With Dot</source>
          <target state="translated">도트보다 큼 / 도트보다 큼</target>
        </trans-unit>
        <trans-unit id="209f35de5184bc36aa0d1b903151a9fc65c6ba61" translate="yes" xml:space="preserve">
          <source>Greater-Than With Question Mark Above</source>
          <target state="translated">위의 물음표와 함께</target>
        </trans-unit>
        <trans-unit id="1bd3d8bbe04802c889994d907ddead65a92d7cca" translate="yes" xml:space="preserve">
          <source>Greater-than comparison operator. Falls back to &lt;code&gt;y &amp;lt; x&lt;/code&gt;.</source>
          <target state="translated">비교 연산자보다 큼 로 하강 백 &lt;code&gt;y &amp;lt; x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed9b75dd8da9fbc05fe433d4046e50ff253af5b8" translate="yes" xml:space="preserve">
          <source>Greater-than-or-equals comparison operator. Falls back to &lt;code&gt;y &amp;lt;= x&lt;/code&gt;.</source>
          <target state="translated">같거나 큰 비교 연산자 폴스에 다시 &lt;code&gt;y &amp;lt;= x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c889dfd5914acacbd51c9ee1f6424d7475f18ba9" translate="yes" xml:space="preserve">
          <source>Greatest common (positive) divisor (or zero if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero).</source>
          <target state="translated">가장 큰 공통 (양수) 제수 (또는 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 모두 0 인 경우 0)</target>
        </trans-unit>
        <trans-unit id="3c137f18236c59d67effecc9926b91bc4e6c388c" translate="yes" xml:space="preserve">
          <source>Greek Beta Symbol / Greek Small Letter Curled Beta</source>
          <target state="translated">그리스 베타 기호 / 그리스 소문자 웅크 리고 베타</target>
        </trans-unit>
        <trans-unit id="c90a544a84e41b0027e35535de12e9412929c3b9" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Alpha</source>
          <target state="translated">그리스 대문자 알파</target>
        </trans-unit>
        <trans-unit id="034c000ae09a7efb7dcd09b84c993f24a59b651a" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Beta</source>
          <target state="translated">그리스 대문자 베타</target>
        </trans-unit>
        <trans-unit id="d91481b132bdcebe4f898c637891a19c7e0d2807" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Chi</source>
          <target state="translated">그리스어 대문자 Chi</target>
        </trans-unit>
        <trans-unit id="3e715476cf54a47fc160c1f17257b6e0b611dcf0" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Delta</source>
          <target state="translated">그리스 대문자 델타</target>
        </trans-unit>
        <trans-unit id="e7b36e8f2dc5d428f4c0fbae5314c79d701290b8" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Epsilon</source>
          <target state="translated">그리스 대문자 엡실론</target>
        </trans-unit>
        <trans-unit id="9632923c81e91309b0197e9f6256e5ddc583b3f1" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Eta</source>
          <target state="translated">그리스 대문자 Eta</target>
        </trans-unit>
        <trans-unit id="b63912e4ec51d609e069730c367de176e6e9799e" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Gamma</source>
          <target state="translated">그리스 대문자 감마</target>
        </trans-unit>
        <trans-unit id="003ecb167b62284b9bb24641dd3e450774ffb206" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Iota</source>
          <target state="translated">그리스 대문자 Iota</target>
        </trans-unit>
        <trans-unit id="97e0c3c41b2cd617ba1f3aefc97784af90e81883" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Kappa</source>
          <target state="translated">그리스 대문자 Kappa</target>
        </trans-unit>
        <trans-unit id="8766675df925b8c25168f5080a3ffb3054a6bbf7" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Lamda / Greek Capital Letter Lambda</source>
          <target state="translated">그리스 대문자 람다 / 그리스 대문자 람다</target>
        </trans-unit>
        <trans-unit id="93f0db4c50dab02a7cf643e0e6463e461b78350b" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Mu</source>
          <target state="translated">그리스 대문자 Mu</target>
        </trans-unit>
        <trans-unit id="c5ff86b57695b2194281052f49d3a518561ee43b" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Nu</source>
          <target state="translated">그리스 대문자 Nu</target>
        </trans-unit>
        <trans-unit id="8d3af0cfd66c1c551b9d25df70d96ca3b3e41655" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Omega</source>
          <target state="translated">그리스 대문자 오메가</target>
        </trans-unit>
        <trans-unit id="60cb22c8a7263835043a1bf3e2390a30ccb009da" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Omicron</source>
          <target state="translated">그리스 대문자 Omicron</target>
        </trans-unit>
        <trans-unit id="9ef46dcc225d47def0f7ae271f6bce8a9447782c" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Phi</source>
          <target state="translated">그리스 대문자 Phi</target>
        </trans-unit>
        <trans-unit id="bdfd940817a68024f4561b28e37abe5c6aa8ae33" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Pi</source>
          <target state="translated">그리스 대문자 Pi</target>
        </trans-unit>
        <trans-unit id="9eb135fdc0eb8f41676f0233eced63bfb63b8d29" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Psi</source>
          <target state="translated">그리스 대문자 Psi</target>
        </trans-unit>
        <trans-unit id="42581daba465402bb427e86f725e50cbf13c5589" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Rho</source>
          <target state="translated">그리스 대문자 Rho</target>
        </trans-unit>
        <trans-unit id="9ba5f4b3b8d0114e4ebb66c0c247b421553311c0" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Sigma</source>
          <target state="translated">그리스 대문자 Sigma</target>
        </trans-unit>
        <trans-unit id="ce15c49fc86bc080b59dcc6c6f912a5f65fcea89" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Tau</source>
          <target state="translated">그리스 대문자 타우</target>
        </trans-unit>
        <trans-unit id="c53695a8df7adbb8087dbbf3f92d38bad6c54a97" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Theta</source>
          <target state="translated">그리스 대문자 Theta</target>
        </trans-unit>
        <trans-unit id="e5671b238dc9a21dfba521fd40bfb114bae616b4" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Upsilon</source>
          <target state="translated">그리스 대문자 Upsilon</target>
        </trans-unit>
        <trans-unit id="7ee18055cc5ff646350aabb8125c5079d084ebc7" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Xi</source>
          <target state="translated">그리스 대문자 Xi</target>
        </trans-unit>
        <trans-unit id="ff11a198311aac30e2248ebcb8edaa9900afa1c4" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Zeta</source>
          <target state="translated">그리스 대문자 Zeta</target>
        </trans-unit>
        <trans-unit id="75f6796d9ad54779470705290e7c7602d7a845bd" translate="yes" xml:space="preserve">
          <source>Greek Capital Theta Symbol</source>
          <target state="translated">그리스 수도 세타 기호</target>
        </trans-unit>
        <trans-unit id="533978fb12373ffa98e45e16bb2525fdaa4ff4dc" translate="yes" xml:space="preserve">
          <source>Greek Kappa Symbol / Greek Small Letter Script Kappa</source>
          <target state="translated">그리스 카파 기호 / 그리스 소문자 스크립트 카파</target>
        </trans-unit>
        <trans-unit id="098ec4a81c9f38263e62700b20a2a6894858fb2e" translate="yes" xml:space="preserve">
          <source>Greek Letter Archaic Koppa</source>
          <target state="translated">그리스 문자 고풍 코파</target>
        </trans-unit>
        <trans-unit id="c2ec8b8cfe62422b5013f3acdd510642f682d268" translate="yes" xml:space="preserve">
          <source>Greek Letter Digamma / Greek Capital Letter Digamma</source>
          <target state="translated">그리스 문자 디 감마 / 그리스 대문자 Digamma</target>
        </trans-unit>
        <trans-unit id="ced5a29435b2a381da90865a6dc27f1b51bd0151" translate="yes" xml:space="preserve">
          <source>Greek Letter Koppa / Greek Capital Letter Koppa</source>
          <target state="translated">그리스 문자 Koppa / 그리스 대문자 Koppa</target>
        </trans-unit>
        <trans-unit id="b1fd4e84b1e13403c9fa5cc0de48f63d1cf94bc6" translate="yes" xml:space="preserve">
          <source>Greek Letter Sampi / Greek Capital Letter Sampi</source>
          <target state="translated">그리스 문자 삼피 / 그리스 대문자 삼피</target>
        </trans-unit>
        <trans-unit id="6736119dd29a2f705206a98b22de530d1dcccd83" translate="yes" xml:space="preserve">
          <source>Greek Letter Stigma / Greek Capital Letter Stigma</source>
          <target state="translated">그리스 문자 낙인 / 그리스 문자 낙인</target>
        </trans-unit>
        <trans-unit id="ea7aa3ec425217aedfab9d34ef40b0b566351176" translate="yes" xml:space="preserve">
          <source>Greek Lunate Epsilon Symbol</source>
          <target state="translated">그리스 Lunate Epsilon 기호</target>
        </trans-unit>
        <trans-unit id="dfaadea9364a20060c114ea92b3c24b30e9e1221" translate="yes" xml:space="preserve">
          <source>Greek Phi Symbol / Greek Small Letter Script Phi</source>
          <target state="translated">그리스어 파이 기호 / 그리스어 소문자 스크립트 피</target>
        </trans-unit>
        <trans-unit id="0ae051b71680a4d39d72cb02f855a3c712e5bd2c" translate="yes" xml:space="preserve">
          <source>Greek Pi Symbol / Greek Small Letter Omega Pi</source>
          <target state="translated">그리스어 파이 기호 / 그리스어 소문자 오메가 파이</target>
        </trans-unit>
        <trans-unit id="f50bb1d13ed32ec906d7d6aaaaee29e7aa027d22" translate="yes" xml:space="preserve">
          <source>Greek Reversed Lunate Epsilon Symbol</source>
          <target state="translated">그리스어 반전 된 Lunate Epsilon 기호</target>
        </trans-unit>
        <trans-unit id="ac07b5056a85d49adcf70f2b544a74ea6ecf6dce" translate="yes" xml:space="preserve">
          <source>Greek Rho Symbol / Greek Small Letter Tailed Rho</source>
          <target state="translated">그리스 Rho 기호 / 그리스 소문자 꼬리 Rho</target>
        </trans-unit>
        <trans-unit id="448dc00d610b9b19fb08a7c7e6eb0a55f13d0a5d" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Alpha</source>
          <target state="translated">그리스어 소문자 알파</target>
        </trans-unit>
        <trans-unit id="71d9bba39729f37db08ecc6cfd07622c292a3bcb" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Archaic Koppa</source>
          <target state="translated">그리스어 소문자 고풍 코파</target>
        </trans-unit>
        <trans-unit id="c2455c0fc133c1c49b746a40bf7fe8a2f613a4de" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Beta</source>
          <target state="translated">그리스어 소문자 베타</target>
        </trans-unit>
        <trans-unit id="5f8706d38c341d4055ab40dfb27748f213e0fc49" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Chi</source>
          <target state="translated">그리스어 소문자 Chi</target>
        </trans-unit>
        <trans-unit id="4dcd438cdc63b711ea794ef765006ad5a6535bd8" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Delta</source>
          <target state="translated">그리스어 소문자 델타</target>
        </trans-unit>
        <trans-unit id="970eba5f1fd0ce763d594cfcc46caddd4212150e" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Digamma</source>
          <target state="translated">그리스어 소문자 디 감마</target>
        </trans-unit>
        <trans-unit id="37cc4f8ed3f230c47dc11c83e4de12cf526a1b20" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Epsilon</source>
          <target state="translated">그리스어 소문자 엡실론</target>
        </trans-unit>
        <trans-unit id="7ccbcb67c9381630a226a3b3c4b28371605f0d5a" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Eta</source>
          <target state="translated">그리스어 소문자 Eta</target>
        </trans-unit>
        <trans-unit id="c074819760ca3f5bfb2e80f9147ad5e5b56ba096" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Final Sigma</source>
          <target state="translated">그리스어 소문자 최종 시그마</target>
        </trans-unit>
        <trans-unit id="46c3a6f8bc0a7d2d96bb1cd2543a7109d5b60cf2" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Gamma</source>
          <target state="translated">그리스어 소문자 감마</target>
        </trans-unit>
        <trans-unit id="4643eab845743a762892a109cabf22bfe96da620" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Iota</source>
          <target state="translated">그리스어 소문자 이오타</target>
        </trans-unit>
        <trans-unit id="3e9ea92015aac67d0b73db674b1ba4dee8fe5484" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Kappa</source>
          <target state="translated">그리스어 소문자 카파</target>
        </trans-unit>
        <trans-unit id="c67601530cb0f970279b136a8b536cfe4717bcd6" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Koppa</source>
          <target state="translated">그리스어 소문자 코파</target>
        </trans-unit>
        <trans-unit id="8c54eb8dc3ac289b41335f3dc67e6533bf270a57" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Lamda / Greek Small Letter Lambda</source>
          <target state="translated">그리스어 소문자 람다 / 그리스어 소문자 람다</target>
        </trans-unit>
        <trans-unit id="7149178e5cd2592e10a36e0a107bc1c794d4f411" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Mu</source>
          <target state="translated">그리스어 소문자 Mu</target>
        </trans-unit>
        <trans-unit id="e9b48a4ac754761a9dfd350adeabe5d343e5cb8f" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Nu</source>
          <target state="translated">그리스어 소문자 Nu</target>
        </trans-unit>
        <trans-unit id="be2da964640e6e3a6c6130c2c98b0cae86bc9a01" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Omega</source>
          <target state="translated">그리스어 소문자 오메가</target>
        </trans-unit>
        <trans-unit id="039c14215303437a5f755bf47c77fbf3d49255e3" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Omicron</source>
          <target state="translated">그리스어 소문자 오 미크론</target>
        </trans-unit>
        <trans-unit id="b844f337c63e69f41e1119e2ae91153b90ab2b4d" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Phi</source>
          <target state="translated">그리스어 소문자 피</target>
        </trans-unit>
        <trans-unit id="95d050ef9ff90d9125fe852cf7d1543f2ce7e841" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Pi</source>
          <target state="translated">그리스어 소문자 Pi</target>
        </trans-unit>
        <trans-unit id="55e311ff6199f4bde7e5d73ace711e07be007a2f" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Psi</source>
          <target state="translated">그리스어 소문자 Psi</target>
        </trans-unit>
        <trans-unit id="5af5bfd009ec9591a9cb29dfcc2932dec54d6ca8" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Rho</source>
          <target state="translated">그리스어 소문자 Rho</target>
        </trans-unit>
        <trans-unit id="85d8bb7b244cafeb1ab811a9df619d45d2234ea6" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Sampi</source>
          <target state="translated">그리스어 소문자 삼피</target>
        </trans-unit>
        <trans-unit id="3ec2ed80a66bc81ead34ee55592a6ea7debfff4e" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Sigma</source>
          <target state="translated">그리스어 소문자 시그마</target>
        </trans-unit>
        <trans-unit id="cc430dcce9d526f42ad9a59b54895c602c6380d3" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Stigma</source>
          <target state="translated">그리스어 소문자 오명</target>
        </trans-unit>
        <trans-unit id="7c2c0c82fe6e748bf9ed49a1f4249b9e89ebb0b8" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Tau</source>
          <target state="translated">그리스어 소문자 타우</target>
        </trans-unit>
        <trans-unit id="b13a88433f3cb99d5c62955aca5de95fbd232103" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Theta</source>
          <target state="translated">그리스어 소문자 세타</target>
        </trans-unit>
        <trans-unit id="cad5938bde69f48a48d99f9b129d82f0acd5468b" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Upsilon</source>
          <target state="translated">그리스어 소문자 Upsilon</target>
        </trans-unit>
        <trans-unit id="0761f90b7168a502798811085d1367b5eca5af17" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Xi</source>
          <target state="translated">그리스어 소문자 Xi</target>
        </trans-unit>
        <trans-unit id="40428b11afaf575da445431ab7ceb811220b9167" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Zeta</source>
          <target state="translated">그리스어 소문자 제타</target>
        </trans-unit>
        <trans-unit id="e32107e3b0620ecf09ddae3fe8f4666208d97040" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Beta</source>
          <target state="translated">그리스 첨자 소문자 베타</target>
        </trans-unit>
        <trans-unit id="90a01f237c5981615d18499c4360233abc532e89" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Chi</source>
          <target state="translated">그리스 첨자 소문자 치</target>
        </trans-unit>
        <trans-unit id="e6642d28d8aeb11d500775a8447736e31c6678cc" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Gamma</source>
          <target state="translated">그리스 첨자 소문자 감마</target>
        </trans-unit>
        <trans-unit id="8b5afd737dfb2072bb758ab79fe8cc816442c922" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Phi</source>
          <target state="translated">그리스 첨자 소문자 피</target>
        </trans-unit>
        <trans-unit id="655a658031f914446d83820f4d7947b16f05e79e" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Rho</source>
          <target state="translated">그리스 첨자 소문자 Rho</target>
        </trans-unit>
        <trans-unit id="be9f5ea4e76fd688fd62b7dd791af4a7ebcdb5c7" translate="yes" xml:space="preserve">
          <source>Greek Theta Symbol / Greek Small Letter Script Theta</source>
          <target state="translated">그리스어 세타 기호 / 그리스어 소문자 스크립트 세타</target>
        </trans-unit>
        <trans-unit id="0dc9b81e7212e0baffe967cdd9d850d4352c89f1" translate="yes" xml:space="preserve">
          <source>Green Apple</source>
          <target state="translated">그린 애플</target>
        </trans-unit>
        <trans-unit id="6c0c3305620db430350f7c25edbf10ced1e1274b" translate="yes" xml:space="preserve">
          <source>Green Book</source>
          <target state="translated">그린 북</target>
        </trans-unit>
        <trans-unit id="6c50119d5c6855e408d9ec2a52bd79546e4c4107" translate="yes" xml:space="preserve">
          <source>Green Heart</source>
          <target state="translated">그린 하트</target>
        </trans-unit>
        <trans-unit id="91feac528389c2b95c6eef06c801f2624c19116d" translate="yes" xml:space="preserve">
          <source>Grimacing Face</source>
          <target state="translated">찡그린 얼굴</target>
        </trans-unit>
        <trans-unit id="3f363dede90226435cbc0dd5d44650f61adbd5cf" translate="yes" xml:space="preserve">
          <source>Grinning Cat Face With Smiling Eyes</source>
          <target state="translated">웃는 눈으로 웃기만 고양이 얼굴</target>
        </trans-unit>
        <trans-unit id="c001d488999b87437147a6834a4b4dff1427af59" translate="yes" xml:space="preserve">
          <source>Grinning Face</source>
          <target state="translated">웃기는 얼굴</target>
        </trans-unit>
        <trans-unit id="5f9c06d040ed5ced638db3bf446959a48d2a6ba5" translate="yes" xml:space="preserve">
          <source>Grinning Face With Smiling Eyes</source>
          <target state="translated">웃는 눈으로 웃는 얼굴</target>
        </trans-unit>
        <trans-unit id="7005b30f708630da7d596e53a5163b84350bd829" translate="yes" xml:space="preserve">
          <source>Grisu.print_shortest()</source>
          <target state="translated">Grisu.print_shortest()</target>
        </trans-unit>
        <trans-unit id="d511874702f7c7ad5ec3b4943a9badded191c85c" translate="yes" xml:space="preserve">
          <source>Growing Heart</source>
          <target state="translated">성장하는 마음</target>
        </trans-unit>
        <trans-unit id="0fa148c7a4ec811ec41fa2cc8e9473dfc48a9226" translate="yes" xml:space="preserve">
          <source>Guardsman</source>
          <target state="translated">Guardsman</target>
        </trans-unit>
        <trans-unit id="94af6c4088103e96d349b87fe76774686b86faa5" translate="yes" xml:space="preserve">
          <source>Guitar</source>
          <target state="translated">Guitar</target>
        </trans-unit>
        <trans-unit id="f089f13a04cfc6546c94da2f6580d6c4eed769fc" translate="yes" xml:space="preserve">
          <source>HE</source>
          <target state="translated">HE</target>
        </trans-unit>
        <trans-unit id="9018ffc109466fc760171905d2397039bc111ebf" translate="yes" xml:space="preserve">
          <source>Had we tried to do the addition without the atomic tag, we might have gotten the wrong answer due to a race condition. An example of what would happen if we didn't avoid the race:</source>
          <target state="translated">원자 태그없이 추가를 시도한 경우 경쟁 조건으로 인해 잘못된 답변을 얻었을 수 있습니다. 우리가 경주를 피하지 않으면 어떻게 될지에 대한 예 :</target>
        </trans-unit>
        <trans-unit id="de960a40df3284e207ad1c9fee37b3f036f0b2a2" translate="yes" xml:space="preserve">
          <source>Hair Space</source>
          <target state="translated">헤어 스페이스</target>
        </trans-unit>
        <trans-unit id="2c7a078f496901b9f8903cc399fa79c1c3ab6b95" translate="yes" xml:space="preserve">
          <source>Haircut</source>
          <target state="translated">Haircut</target>
        </trans-unit>
        <trans-unit id="4a11632b50147a0502c9dc634f5c6e0c06ffab6b" translate="yes" xml:space="preserve">
          <source>Half-precision floating-point numbers are also supported (&lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;), but they are implemented in software and use &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt; for calculations.</source>
          <target state="translated">반 정밀도 부동 소수점 숫자도 지원 되지만 ( &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; &lt;/a&gt; ), 소프트웨어로 구현되며 계산에 &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; 를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="94c92dceffd55b3ed538a942cce80806cce37fe1" translate="yes" xml:space="preserve">
          <source>Hamburger</source>
          <target state="translated">Hamburger</target>
        </trans-unit>
        <trans-unit id="ab7b8ea47eadf93146c012e72a5ea673322853aa" translate="yes" xml:space="preserve">
          <source>Hammer</source>
          <target state="translated">Hammer</target>
        </trans-unit>
        <trans-unit id="3bff32cf99bd14d58869cbb0d7d31e1bec45d891" translate="yes" xml:space="preserve">
          <source>Hamster Face</source>
          <target state="translated">햄스터 얼굴</target>
        </trans-unit>
        <trans-unit id="3d3f4dc94e3e321e028a018fa9cae5ff030ce957" translate="yes" xml:space="preserve">
          <source>Handbag</source>
          <target state="translated">Handbag</target>
        </trans-unit>
        <trans-unit id="fffe7d81b4e3e0d9952aa6caa3fd530df68b775c" translate="yes" xml:space="preserve">
          <source>Handle a log event</source>
          <target state="translated">로그 이벤트 처리</target>
        </trans-unit>
        <trans-unit id="e30eba0eb24c7a8fac8f9c3ba83240b293b51b33" translate="yes" xml:space="preserve">
          <source>Handle excess argument diversity in the caller</source>
          <target state="translated">발신자의 과도한 인수 다양성 처리</target>
        </trans-unit>
        <trans-unit id="10a3cb0df00f1fa97a3cb63486616c5cf79959d9" translate="yes" xml:space="preserve">
          <source>Handling Operating System Variation</source>
          <target state="translated">운영 체제 변형 처리</target>
        </trans-unit>
        <trans-unit id="67509204a791b926a290df40bb29deed545a4fe9" translate="yes" xml:space="preserve">
          <source>Happy Person Raising One Hand</source>
          <target state="translated">한 손을 올리는 행복한 사람</target>
        </trans-unit>
        <trans-unit id="31f205e87d98bf7472c8354a4586dfc7173d7021" translate="yes" xml:space="preserve">
          <source>Hatching Chick</source>
          <target state="translated">부화 병아리</target>
        </trans-unit>
        <trans-unit id="520de7443d00d6ff4dc3ababbbf6cfbe0b74f4ec" translate="yes" xml:space="preserve">
          <source>Headers</source>
          <target state="translated">Headers</target>
        </trans-unit>
        <trans-unit id="6ef295c2897db61289ad0eb0b8171326ec851011" translate="yes" xml:space="preserve">
          <source>Headphone</source>
          <target state="translated">Headphone</target>
        </trans-unit>
        <trans-unit id="83fbe44a9f704c02d2d76ee1fa5c115010ff9d8c" translate="yes" xml:space="preserve">
          <source>Hear-No-Evil Monkey</source>
          <target state="translated">들리지 않는 원숭이</target>
        </trans-unit>
        <trans-unit id="2edafb06cf3a183a503a1615f5b8c4da86990553" translate="yes" xml:space="preserve">
          <source>Heart Decoration</source>
          <target state="translated">하트 장식</target>
        </trans-unit>
        <trans-unit id="53648eedc9bfa102fd53ca957c856f7e0d9a2a2f" translate="yes" xml:space="preserve">
          <source>Heart With Arrow</source>
          <target state="translated">화살표와 하트</target>
        </trans-unit>
        <trans-unit id="5461f091ddf4a776ade53602bfcdef544a0feb57" translate="yes" xml:space="preserve">
          <source>Heart With Ribbon</source>
          <target state="translated">리본 하트</target>
        </trans-unit>
        <trans-unit id="fde3248d8454a04a4138dae1e5a31ab1432bdb78" translate="yes" xml:space="preserve">
          <source>Heavy Black Heart</source>
          <target state="translated">헤비 블랙 하트</target>
        </trans-unit>
        <trans-unit id="662b2b0a5e62dab41b3f6deba4867bbd60a35b8f" translate="yes" xml:space="preserve">
          <source>Heavy Check Mark</source>
          <target state="translated">무거운 확인 표시</target>
        </trans-unit>
        <trans-unit id="9ae6c1b9f7bdda7ce9eec6a4c6ee5efca7c871a5" translate="yes" xml:space="preserve">
          <source>Heavy Division Sign</source>
          <target state="translated">무거운 사단 표시</target>
        </trans-unit>
        <trans-unit id="7706e6c735cc207b9267e0979a8dbeb69e5229a0" translate="yes" xml:space="preserve">
          <source>Heavy Dollar Sign</source>
          <target state="translated">무거운 달러 기호</target>
        </trans-unit>
        <trans-unit id="93e9c9786874a2de0cddf3ee5e7766e4ea031dca" translate="yes" xml:space="preserve">
          <source>Heavy Exclamation Mark Symbol</source>
          <target state="translated">느낌표 기호</target>
        </trans-unit>
        <trans-unit id="78800e7776274c794a8d095ff4c2c73221dbbbae" translate="yes" xml:space="preserve">
          <source>Heavy Large Circle</source>
          <target state="translated">헤비 라지 서클</target>
        </trans-unit>
        <trans-unit id="980c6d0d2733f3166210e842cefb858e063c0d91" translate="yes" xml:space="preserve">
          <source>Heavy Minus Sign</source>
          <target state="translated">빼기 기호</target>
        </trans-unit>
        <trans-unit id="778bd00186fa7e144e55b7635e11bf1326888ddd" translate="yes" xml:space="preserve">
          <source>Heavy Multiplication X</source>
          <target state="translated">곱셈 곱셈 X</target>
        </trans-unit>
        <trans-unit id="f686b15ee80bdb7a610f665e9bb567ee7025d65c" translate="yes" xml:space="preserve">
          <source>Heavy Plus Sign</source>
          <target state="translated">더하기 부호</target>
        </trans-unit>
        <trans-unit id="75c1e5a632008728c5938fd7cc30c147bf32b6b5" translate="yes" xml:space="preserve">
          <source>Heavy Teardrop-Spoked Asterisk</source>
          <target state="translated">눈물 방울로 찌른 별표</target>
        </trans-unit>
        <trans-unit id="fda201fd52a223f4da8ab6d74bf72a21faeaf60b" translate="yes" xml:space="preserve">
          <source>Helicopter</source>
          <target state="translated">Helicopter</target>
        </trans-unit>
        <trans-unit id="ae573d0f71ca2ef898057a3a11aeabc86f4048c4" translate="yes" xml:space="preserve">
          <source>Help mode</source>
          <target state="translated">도움말 모드</target>
        </trans-unit>
        <trans-unit id="5941c1bf985d2850f77798f46b591f5bf1a7198a" translate="yes" xml:space="preserve">
          <source>Help mode can be exited by pressing backspace at the beginning of the line.</source>
          <target state="translated">줄 시작 부분에서 백 스페이스 키를 누르면 도움말 모드를 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8882ebfc5a29fddc8a80eb230261926f56fd8d5e" translate="yes" xml:space="preserve">
          <source>Herb</source>
          <target state="translated">Herb</target>
        </trans-unit>
        <trans-unit id="bb934b9ceeaa4e54809a9838dfa1ed2cabf6522e" translate="yes" xml:space="preserve">
          <source>Here &quot;inline&quot; refers to elements that can be found within blocks of text, i.e. paragraphs. These include the following elements.</source>
          <target state="translated">여기서 &quot;인라인&quot;은 텍스트 블록, 즉 단락에서 찾을 수있는 요소를 나타냅니다. 여기에는 다음 요소가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0aaf5b43ce3bf447f656063f8ac61c46b777eefc" translate="yes" xml:space="preserve">
          <source>Here Enter was pressed again so that Julia would read the newline. Now, as you can see from this example, &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; takes the data to write as its second argument, while &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; takes the type of the data to be read as the second argument.</source>
          <target state="translated">Julia가 줄 바꿈을 읽을 수 있도록 Enter 키를 다시 누릅니다. 이제이 예제에서 볼 수 있듯이 &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 는 두 번째 인수로 쓸 데이터를 가져 오는 반면 &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 는 두 번째 인수로 읽을 데이터 유형을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="77b8367f53858f5da92aefb29bb20f4abb25843a" translate="yes" xml:space="preserve">
          <source>Here are some examples to demonstrate which type of arrays are strided and which are not:</source>
          <target state="translated">다음은 어떤 유형의 배열이 연결되어 있고 그렇지 않은지를 보여주는 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="3b3a2127d824649ba6d32ad8be94f9ae3c5dba0e" translate="yes" xml:space="preserve">
          <source>Here are some examples with bitwise operators:</source>
          <target state="translated">비트 연산자를 사용한 몇 가지 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c2d9b5adfe6cd0f32ce45f61d872c609d6e0a4ff" translate="yes" xml:space="preserve">
          <source>Here are some simple examples using arithmetic operators:</source>
          <target state="translated">다음은 산술 연산자를 사용하는 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="f5ba1cb3713902ae4550268fb70da7530b34b57c" translate="yes" xml:space="preserve">
          <source>Here are some simple examples:</source>
          <target state="translated">다음은 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="d3d30b41b93723417b3a0eda16323a2baedc0a7c" translate="yes" xml:space="preserve">
          <source>Here are some tips for working with Julia efficiently.</source>
          <target state="translated">Julia와 효율적으로 작업하기위한 몇 가지 팁이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b9dc1697c31ccdd9965aa0170dd226712f2cb14" translate="yes" xml:space="preserve">
          <source>Here each iteration applies &lt;code&gt;f&lt;/code&gt; to a randomly-chosen sample from a vector &lt;code&gt;a&lt;/code&gt; shared by all processes.</source>
          <target state="translated">여기에서 각 반복 은 모든 프로세스 &lt;code&gt;a&lt;/code&gt; 공유 하는 벡터에서 무작위로 선택된 샘플에 &lt;code&gt;f&lt;/code&gt; 를 적용 합니다.</target>
        </trans-unit>
        <trans-unit id="a76feb46cab9b567bf7483afc7491ed744f3c054" translate="yes" xml:space="preserve">
          <source>Here is a corresponding roots structure, represented as a dictionary:</source>
          <target state="translated">다음은 사전으로 표시되는 해당 루트 구조입니다.</target>
        </trans-unit>
        <trans-unit id="86a5b746f6fe4ea8f489a225c69f586c3ee94b4f" translate="yes" xml:space="preserve">
          <source>Here is a more complex example, still using Markdown:</source>
          <target state="translated">다음은 여전히 ​​Markdown을 사용하는 더 복잡한 예입니다.</target>
        </trans-unit>
        <trans-unit id="32a32a63972b7e15e6bc1e1399ca59536eaf91cf" translate="yes" xml:space="preserve">
          <source>Here is a related case in which the expected behaviour is not necessarily obvious: What happens when we round to the nearest &lt;code&gt;P(2)&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a &lt;a href=&quot;#Dates.Period&quot;&gt;&lt;code&gt;Period&lt;/code&gt;&lt;/a&gt; type? In some cases (specifically, when &lt;code&gt;P &amp;lt;: Dates.TimePeriod&lt;/code&gt;) the answer is clear:</source>
          <target state="translated">여기에 예상되는 동작이 반드시 명확하지 않다하는 관련 사례는 다음과 같습니다 어떤 일이 발생하면 우리 라운드 근처에 &lt;code&gt;P(2)&lt;/code&gt; , &lt;code&gt;P&lt;/code&gt; 는 A는 &lt;a href=&quot;#Dates.Period&quot;&gt; &lt;code&gt;Period&lt;/code&gt; &lt;/a&gt; 유형은? 경우에 따라 (특히 &lt;code&gt;P &amp;lt;: Dates.TimePeriod&lt;/code&gt; ) 대답은 명확합니다.</target>
        </trans-unit>
        <trans-unit id="cbc1a6d954403affcd824e28b3f149fcba6203f0" translate="yes" xml:space="preserve">
          <source>Here is a representation of a possible paths map for our example &lt;code&gt;App&lt;/code&gt; project environment, as provided in the Manifest given above for the dependency graph, after searching the local file system:</source>
          <target state="translated">다음은 로컬 파일 시스템을 검색 한 후 종속성 그래프에 대해 위에서 제공된 Manifest에 제공된 예제 &lt;code&gt;App&lt;/code&gt; 프로젝트 환경에 대한 가능한 경로 맵을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="62b973b3d8599e23c2d9da9c0813b08faed1d7f5" translate="yes" xml:space="preserve">
          <source>Here is a second example wrapping the corresponding destructor:</source>
          <target state="translated">다음은 해당 소멸자를 감싸는 두 번째 예입니다.</target>
        </trans-unit>
        <trans-unit id="383164a53efb4be492fb1a747035c59b715f139a" translate="yes" xml:space="preserve">
          <source>Here is a simple example of a C wrapper that returns a &lt;code&gt;Ptr&lt;/code&gt; type:</source>
          <target state="translated">다음은 &lt;code&gt;Ptr&lt;/code&gt; 유형 을 반환하는 C 래퍼의 간단한 예입니다 .</target>
        </trans-unit>
        <trans-unit id="fd4023e74c6b03e666e958ff6141359ac199b811" translate="yes" xml:space="preserve">
          <source>Here is a simplified definition of Julia's &lt;a href=&quot;../../base/base/index#Base.@assert&quot;&gt;&lt;code&gt;@assert&lt;/code&gt;&lt;/a&gt; macro:</source>
          <target state="translated">다음은 Julia의 &lt;a href=&quot;../../base/base/index#Base.@assert&quot;&gt; &lt;code&gt;@assert&lt;/code&gt; &lt;/a&gt; 매크로에 대한 간단한 정의입니다 .</target>
        </trans-unit>
        <trans-unit id="e40b5507bd00f53ac4347d820f9aea2085f1e997" translate="yes" xml:space="preserve">
          <source>Here is a slightly more complex example that discovers the local machine's hostname:</source>
          <target state="translated">다음은 로컬 머신의 호스트 이름을 발견하는 약간 더 복잡한 예입니다.</target>
        </trans-unit>
        <trans-unit id="c20460c3bed82c94ed3787e3dfe27ae7c3b31699" translate="yes" xml:space="preserve">
          <source>Here is a third example passing Julia arrays:</source>
          <target state="translated">다음은 Julia 배열을 전달하는 세 번째 예입니다.</target>
        </trans-unit>
        <trans-unit id="d610a40401dd7269ef98b9bc1fb559f31c643ca5" translate="yes" xml:space="preserve">
          <source>Here is an even more complex multi-stage producer-consumer example:</source>
          <target state="translated">보다 복잡한 다단계 생산자-소비자 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="166759fbb289c37473d7a6b4b102bc98c71ab976" translate="yes" xml:space="preserve">
          <source>Here is an example of a &quot;compound function&quot; that should really be written as multiple definitions:</source>
          <target state="translated">다음은 실제로 여러 정의로 작성해야하는 &quot;복합 함수&quot;의 예입니다.</target>
        </trans-unit>
        <trans-unit id="dff5c26dbc80f0776c11c28a5633445af4d9d175" translate="yes" xml:space="preserve">
          <source>Here is an example with all three kinds of markup. This program first calculates the finite difference of a one-dimensional array, and then evaluates the L2-norm of the result:</source>
          <target state="translated">다음은 세 종류의 마크 업이 모두 포함 된 예입니다. 이 프로그램은 먼저 1 차원 배열의 유한 차이를 계산 한 다음 결과의 L2- 노름을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="f97cb2973176feb8f941a5117a88dd7fad7d8ec1" translate="yes" xml:space="preserve">
          <source>Here is an example with both &lt;code&gt;@inbounds&lt;/code&gt; and &lt;code&gt;@simd&lt;/code&gt; markup (we here use &lt;code&gt;@noinline&lt;/code&gt; to prevent the optimizer from trying to be too clever and defeat our benchmark):</source>
          <target state="translated">&lt;code&gt;@inbounds&lt;/code&gt; 와 &lt;code&gt;@simd&lt;/code&gt; 마크 업 이 모두 포함 된 예는 다음과 같습니다 (여기서 &lt;code&gt;@noinline&lt;/code&gt; 을 사용하여 옵티마이 저가 너무 영리 해 벤치 마크를 해제하지 못하도록 방지합니다).</target>
        </trans-unit>
        <trans-unit id="87f18e8d7ee1b76e68d3166f552e8d656c81958f" translate="yes" xml:space="preserve">
          <source>Here is an extraordinarily simple macro:</source>
          <target state="translated">다음은 매우 간단한 매크로입니다.</target>
        </trans-unit>
        <trans-unit id="7afc02096736fcb4c01a0c6afaea2e90973eb75e" translate="yes" xml:space="preserve">
          <source>Here is the correct code template for returning the element-type &lt;code&gt;T&lt;/code&gt; of any arbitrary subtype of &lt;code&gt;AbstractArray&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;AbstractArray&lt;/code&gt; 의 임의 하위 유형의 요소 유형 &lt;code&gt;T&lt;/code&gt; 를 리턴하기위한 올바른 코드 템플리트입니다 .</target>
        </trans-unit>
        <trans-unit id="5f4fdb43158ce32a870e863c53f180f3aa098a57" translate="yes" xml:space="preserve">
          <source>Here is the corresponding graph structure, represented as a dictionary:</source>
          <target state="translated">사전으로 표시되는 해당 그래프 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f9b6eba975c84af5ac0af3798604d9ad36108359" translate="yes" xml:space="preserve">
          <source>Here module &lt;code&gt;Parent&lt;/code&gt; contains a submodule &lt;code&gt;Utils&lt;/code&gt;, and code in &lt;code&gt;Parent&lt;/code&gt; wants the contents of &lt;code&gt;Utils&lt;/code&gt; to be visible. This is done by starting the &lt;code&gt;using&lt;/code&gt; path with a period. Adding more leading periods moves up additional levels in the module hierarchy. For example &lt;code&gt;using ..Utils&lt;/code&gt; would look for &lt;code&gt;Utils&lt;/code&gt; in &lt;code&gt;Parent&lt;/code&gt;'s enclosing module rather than in &lt;code&gt;Parent&lt;/code&gt; itself.</source>
          <target state="translated">여기서 &lt;code&gt;Parent&lt;/code&gt; 모듈 에는 &lt;code&gt;Utils&lt;/code&gt; 하위 모듈이 포함되어 있으며 &lt;code&gt;Parent&lt;/code&gt; 코드 는 &lt;code&gt;Utils&lt;/code&gt; 의 내용을 표시 하려고합니다 . 마침표로 &lt;code&gt;using&lt;/code&gt; 경로를 시작하면 됩니다 . 선행 기간을 더 추가하면 모듈 계층에서 추가 레벨이 올라갑니다. 예를 들어 &lt;code&gt;using ..Utils&lt;/code&gt; 를 사용하면 &lt;code&gt;Parent&lt;/code&gt; 자체가 아닌 &lt;code&gt;Parent&lt;/code&gt; 의 엔 클로징 모듈 에서 &lt;code&gt;Utils&lt;/code&gt; 를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="cf5b1250aa2128de01974785ca5a0cd9b855ebd1" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;1:5&lt;/code&gt; is a range object, representing the sequence of numbers 1, 2, 3, 4, 5. The &lt;code&gt;for&lt;/code&gt; loop iterates through these values, assigning each one in turn to the variable &lt;code&gt;i&lt;/code&gt;. One rather important distinction between the previous &lt;code&gt;while&lt;/code&gt; loop form and the &lt;code&gt;for&lt;/code&gt; loop form is the scope during which the variable is visible. If the variable &lt;code&gt;i&lt;/code&gt; has not been introduced in another scope, in the &lt;code&gt;for&lt;/code&gt; loop form, it is visible only inside of the &lt;code&gt;for&lt;/code&gt; loop, and not outside/afterwards. You'll either need a new interactive session instance or a different variable name to test this:</source>
          <target state="translated">여기서 &lt;code&gt;1:5&lt;/code&gt; 는 숫자 1, 2, 3, 4, 5의 시퀀스를 나타내는 범위 객체입니다. &lt;code&gt;for&lt;/code&gt; 루프는 이러한 값을 반복하여 각 값을 차례로 변수 &lt;code&gt;i&lt;/code&gt; 에 할당합니다 . 이전 &lt;code&gt;while&lt;/code&gt; 루프 양식과 &lt;code&gt;for&lt;/code&gt; 루프 양식 사이의 중요한 차이점 중 하나 는 변수가 표시되는 범위입니다. 가변 경우 &lt;code&gt;i&lt;/code&gt; 에 다른 범위에서 도입되지 않은 &lt;code&gt;for&lt;/code&gt; 루프 형태로, 단지 내부의 볼 &lt;code&gt;for&lt;/code&gt; 루프가 아닌 외부 / 후. 이를 테스트하려면 새로운 대화식 세션 인스턴스 또는 다른 변수 이름이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="052893fe9e50a40443ea78d54cd3b33cb280eb4e" translate="yes" xml:space="preserve">
          <source>Here the call &lt;code&gt;g(2.0, 3.0)&lt;/code&gt; could be handled by either the &lt;code&gt;g(Float64, Any)&lt;/code&gt; or the &lt;code&gt;g(Any, Float64)&lt;/code&gt; method, and neither is more specific than the other. In such cases, Julia raises a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; rather than arbitrarily picking a method. You can avoid method ambiguities by specifying an appropriate method for the intersection case:</source>
          <target state="translated">여기서 &lt;code&gt;g(2.0, 3.0)&lt;/code&gt; 호출 은 &lt;code&gt;g(Float64, Any)&lt;/code&gt; 또는 &lt;code&gt;g(Any, Float64)&lt;/code&gt; 방법 으로 처리 할 수 ​​있으며 다른 방법보다 더 구체적이지 않습니다. 이러한 경우 Julia 는 임의로 메소드를 선택하지 않고 &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; 를 발생시킵니다&lt;/a&gt; . 교차 사례에 적절한 방법을 지정하여 방법 모호성을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="373c14d6a8445cd3c00b580baccefb5fd3f3d12c" translate="yes" xml:space="preserve">
          <source>Here the first number is printed after a delay of two seconds, then the following numbers are printed quickly.</source>
          <target state="translated">여기서 첫 번째 숫자는 2 초 후에 인쇄 된 후 다음 숫자는 빠르게 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="f3418902a4f242b518d4d5f42412b650db9149b7" translate="yes" xml:space="preserve">
          <source>Here the user expression &lt;code&gt;ex&lt;/code&gt; is a call to &lt;code&gt;time&lt;/code&gt;, but not the same &lt;code&gt;time&lt;/code&gt; function that the macro uses. It clearly refers to &lt;code&gt;MyModule.time&lt;/code&gt;. Therefore we must arrange for the code in &lt;code&gt;ex&lt;/code&gt; to be resolved in the macro call environment. This is done by &quot;escaping&quot; the expression with &lt;a href=&quot;../../base/base/index#Base.esc&quot;&gt;&lt;code&gt;esc&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">여기서 사용자 표현식 &lt;code&gt;ex&lt;/code&gt; 는 call to &lt;code&gt;time&lt;/code&gt; 이지만 매크로가 사용 하는 것과 동일한 &lt;code&gt;time&lt;/code&gt; 함수는 아닙니다 . &lt;code&gt;MyModule.time&lt;/code&gt; 을 명확하게 나타냅니다 . 따라서 매크로 호출 환경 에서 &lt;code&gt;ex&lt;/code&gt; 의 코드 가 해결 되도록 정렬해야 합니다. &lt;a href=&quot;../../base/base/index#Base.esc&quot;&gt; &lt;code&gt;esc&lt;/code&gt; 로&lt;/a&gt; 표현식을 &quot;이스케이프 처리&quot;하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="319de09db8b0ceed706c2722ad8c4f12c486b513" translate="yes" xml:space="preserve">
          <source>Here the zero-argument constructor method calls the single-argument constructor method, which in turn calls the automatically provided two-argument constructor method. For reasons that will become clear very shortly, additional constructor methods declared as normal methods like this are called &lt;em&gt;outer&lt;/em&gt; constructor methods. Outer constructor methods can only ever create a new instance by calling another constructor method, such as the automatically provided default ones.</source>
          <target state="translated">여기서 제로 인수 생성자 메소드는 단일 인수 생성자 메소드를 호출하며, 자동으로 제공된 2 인수 생성자 메소드를 호출합니다. 머지 않아 명백해질 이유 때문에 이와 같은 일반 메소드로 선언 된 추가 생성자 메소드를 &lt;em&gt;외부&lt;/em&gt; 생성자 메소드 라고 합니다. 외부 생성자 메소드는 자동으로 제공되는 기본 메소드와 같은 다른 생성자 메소드를 호출하여 새 인스턴스 만 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="754489125a9dd659e2690c5c486d5c6350ca9a2b" translate="yes" xml:space="preserve">
          <source>Here we create and store two closures that return variable &lt;code&gt;i&lt;/code&gt;. However, it is always the same variable &lt;code&gt;i&lt;/code&gt;, so the two closures behave identically. We can use &lt;code&gt;let&lt;/code&gt; to create a new binding for &lt;code&gt;i&lt;/code&gt;:</source>
          <target state="translated">여기서 변수 &lt;code&gt;i&lt;/code&gt; 를 반환하는 두 개의 클로저를 만들고 저장 합니다. 그러나 항상 같은 변수 &lt;code&gt;i&lt;/code&gt; 이므로 두 클로저는 동일하게 동작합니다. &lt;code&gt;let&lt;/code&gt; 을 사용하여 &lt;code&gt;i&lt;/code&gt; 에 대한 새 바인딩을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f311d723a18a177fef2791eca3f472638877d565" translate="yes" xml:space="preserve">
          <source>Here we created a function &lt;code&gt;change_array!&lt;/code&gt;, that assigns &lt;code&gt;5&lt;/code&gt; to the first element of the passed array (bound to &lt;code&gt;x&lt;/code&gt; at the call site, and bound to &lt;code&gt;A&lt;/code&gt; within the function). Notice that, after the function call, &lt;code&gt;x&lt;/code&gt; is still bound to the same array, but the content of that array changed: the variables &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; were distinct bindings referring to the same mutable &lt;code&gt;Array&lt;/code&gt; object.</source>
          <target state="translated">여기에서 &lt;code&gt;change_array!&lt;/code&gt; 함수를 만들었습니다 ! , 전달 된 배열의 첫 번째 요소에 &lt;code&gt;5&lt;/code&gt; 를 할당합니다 ( 호출 사이트에서 &lt;code&gt;x&lt;/code&gt; 에 바인딩되고 함수 내에서 &lt;code&gt;A&lt;/code&gt; 에 바인딩 됨 ). 함수 호출 후에도 &lt;code&gt;x&lt;/code&gt; 는 여전히 동일한 배열에 바인딩되지만 해당 배열의 내용은 변경되었습니다. 변수 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;x&lt;/code&gt; 는 동일한 가변 &lt;code&gt;Array&lt;/code&gt; 객체를 참조하는 고유 한 바인딩 입니다.</target>
        </trans-unit>
        <trans-unit id="97836fe829ccf3f620529d58616382e12cd6d98d" translate="yes" xml:space="preserve">
          <source>Here we have created a type &lt;code&gt;BitVector&lt;/code&gt; which has no parameters, but where the element-type is still fully specified, with &lt;code&gt;T&lt;/code&gt; equal to &lt;code&gt;Bool&lt;/code&gt;!</source>
          <target state="translated">여기서 우리는 매개 변수가없는 &lt;code&gt;BitVector&lt;/code&gt; 유형을 만들었지 만 요소 유형이 여전히 완전히 지정되어 있고 &lt;code&gt;T&lt;/code&gt; 는 &lt;code&gt;Bool&lt;/code&gt; 입니다 !</target>
        </trans-unit>
        <trans-unit id="2b9af6aad35623f9ee689638f54770ed7633fd26" translate="yes" xml:space="preserve">
          <source>Here's a brief example:</source>
          <target state="translated">다음은 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="e0b11719421310c6cc4a896b044019316b57f70b" translate="yes" xml:space="preserve">
          <source>Here's a simple example of running an external program:</source>
          <target state="translated">다음은 외부 프로그램을 실행하는 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="20a6acaa904201f8599df8ef13450aeef27c5681" translate="yes" xml:space="preserve">
          <source>Here, &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; first opens the file for writing and then passes the resulting output stream to the anonymous function you defined in the &lt;code&gt;do ... end&lt;/code&gt; block. After your function exits, &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; will make sure that the stream is properly closed, regardless of whether your function exited normally or threw an exception. (The &lt;code&gt;try/finally&lt;/code&gt; construct will be described in &lt;a href=&quot;../control-flow/index#Control-Flow-1&quot;&gt;Control Flow&lt;/a&gt;.)</source>
          <target state="translated">여기서, &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; 은&lt;/a&gt; 먼저 쓰기 위해 파일을 연 다음 결과 출력 스트림을 &lt;code&gt;do ... end&lt;/code&gt; 블록에 정의한 익명 함수로 전달합니다 . 함수가 종료되면 &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; 은 함수가 정상적으로 종료되었는지 또는 예외를 던 졌는지에 관계없이 스트림이 올바르게 닫혔는지 확인합니다. 합니다 ( &lt;code&gt;try/finally&lt;/code&gt; 구조는 설명한다 &lt;a href=&quot;../control-flow/index#Control-Flow-1&quot;&gt;제어 흐름&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="7a90ca3f6b58f2547fca94266c1813296e387071" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;(2, 3)&lt;/code&gt; is a &lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;(2, 3)&lt;/code&gt; 은 &lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5216371c7d0926d72d95ff987a3d80e32321d1dd" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;count&lt;/code&gt; finds the number of commits along the walk with a certain &lt;code&gt;GitHash&lt;/code&gt;. Since the &lt;code&gt;GitHash&lt;/code&gt; is unique to a commit, &lt;code&gt;cnt&lt;/code&gt; will be &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;count&lt;/code&gt; 는 특정 &lt;code&gt;GitHash&lt;/code&gt; 와 함께 걷기를 따라 커밋 수를 찾습니다 . &lt;code&gt;GitHash&lt;/code&gt; 는 커밋에 고유 하므로 &lt;code&gt;cnt&lt;/code&gt; 는 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2161ca87d055525464e4a5b1fd21109ca2813404" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;map&lt;/code&gt; visits each commit using the &lt;code&gt;GitRevWalker&lt;/code&gt; and finds its &lt;code&gt;GitHash&lt;/code&gt;.</source>
          <target state="translated">여기에, &lt;code&gt;map&lt;/code&gt; 방문은 각 사용하여 커밋 &lt;code&gt;GitRevWalker&lt;/code&gt; 을 하고 발견 &lt;code&gt;GitHash&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="290a784ce45faad752be9227fb340601f3f76ead" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;sp.data&lt;/code&gt; refers to the second parameter in the call to the &lt;code&gt;SamplerSimple&lt;/code&gt; constructor (in this case equal to &lt;code&gt;Sampler(rng, 1:die.nsides, r)&lt;/code&gt;), while the &lt;code&gt;Die&lt;/code&gt; object can be accessed via &lt;code&gt;sp[]&lt;/code&gt;.</source>
          <target state="translated">여기서, &lt;code&gt;sp.data&lt;/code&gt; 을 받는 콜의 두 번째 파라미터 지칭 &lt;code&gt;SamplerSimple&lt;/code&gt; 의 생성자 (이 경우는 동일 &lt;code&gt;Sampler(rng, 1:die.nsides, r)&lt;/code&gt; )에있는 동안, &lt;code&gt;Die&lt;/code&gt; 객체를 통해 액세스 할 수있는 &lt;code&gt;sp[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6537ead3e178965ea266058307a50f1c2fbf640" translate="yes" xml:space="preserve">
          <source>Here, Julia was able to detect that &lt;code&gt;B&lt;/code&gt; is in fact symmetric, and used a more appropriate factorization. Often it's possible to write more efficient code for a matrix that is known to have certain properties e.g. it is symmetric, or tridiagonal. Julia provides some special types so that you can &quot;tag&quot; matrices as having these properties. For instance:</source>
          <target state="translated">여기서 Julia는 &lt;code&gt;B&lt;/code&gt; 가 실제로 대칭 임을 감지 하고보다 적절한 인수 분해를 사용했습니다. 대칭 또는 삼각형과 같은 특정 속성을 갖는 것으로 알려진 매트릭스에 대해보다 효율적인 코드를 작성하는 것이 종종 가능합니다. Julia는 특수한 유형을 제공하므로 행렬에 이러한 속성이있는 것으로 &quot;태그&quot;할 수 있습니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="c40867232cf6016f6f8e42d642627bb64b253d86" translate="yes" xml:space="preserve">
          <source>Here, the evaluation of an expression object causes a value to be assigned to the global variable &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">여기서 식 객체의 평가로 인해 전역 변수 &lt;code&gt;x&lt;/code&gt; 에 값이 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="c4e6a3f428f565fb6b0000baaea7b4aa785dbcfc" translate="yes" xml:space="preserve">
          <source>Here, the input &lt;code&gt;p&lt;/code&gt; is declared to be of type &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt;, meaning that the memory that &lt;code&gt;p&lt;/code&gt; points to may be managed by Julia or by C. A pointer to memory allocated by C should be of type &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt;, but it is convertible using &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; and therefore can be used in the same (covariant) context of the input argument to a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;. A pointer to memory allocated by Julia must be of type &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt;, to ensure that the memory address pointed to is valid and that Julia's garbage collector manages the chunk of memory pointed to correctly. Therefore, the &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; declaration allows pointers managed by C or Julia to be used.</source>
          <target state="translated">여기서 입력 &lt;code&gt;p&lt;/code&gt; 는 &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; 유형으로 선언되는데 , 이는 &lt;code&gt;p&lt;/code&gt; 가 가리키는 메모리가 Julia 또는 C에 의해 관리 될 수 있음을 의미합니다 . C에 의해 할당 된 메모리에 대한 포인터는 &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt; 유형이어야 하지만 그것은 사용 컨버터블 &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; 을&lt;/a&gt; 따라서 (A)에 입력 된 인수와 동일한 (공변) 용어로도 사용될 수있다 &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; . Julia가 할당 한 메모리에 대한 포인터는 &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; 유형이어야하며 , 지정된 메모리 주소가 유효하고 Julia의 가비지 콜렉터가 올바르게 지정된 메모리 청크를 관리하도록해야합니다. 따라서 &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; 선언은 C 또는 Julia가 관리하는 포인터를 사용할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="1ab09345f1dd2caf08c8b3f5ca36d5682164ea59" translate="yes" xml:space="preserve">
          <source>Here, the option &lt;code&gt;--math-mode=ieee&lt;/code&gt; disables the &lt;code&gt;@fastmath&lt;/code&gt; macro, so that we can compare results.</source>
          <target state="translated">여기서 &lt;code&gt;--math-mode=ieee&lt;/code&gt; 옵션 은 &lt;code&gt;@fastmath&lt;/code&gt; 매크로를 비활성화하여 결과를 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cbc6c9a872faab52c966ca377e3e05b9b758b19" translate="yes" xml:space="preserve">
          <source>Here, the total produced by &lt;code&gt;sum&lt;/code&gt; is passed to the &lt;code&gt;sqrt&lt;/code&gt; function. The equivalent composition would be:</source>
          <target state="translated">여기에서 합계에 의해 생성 된 &lt;code&gt;sum&lt;/code&gt; 는 &lt;code&gt;sqrt&lt;/code&gt; 함수로 전달됩니다 . 동등한 구성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eab8445a2aa7f75fce1fbdd298d4317a2e164c25" translate="yes" xml:space="preserve">
          <source>Here, we happened to know that the first element of &lt;code&gt;a&lt;/code&gt; would be an &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;. Making an annotation like this has the added benefit that it will raise a run-time error if the value is not of the expected type, potentially catching certain bugs earlier.</source>
          <target state="translated">여기, 우리의 첫 번째 요소 알고 있었 &lt;code&gt;a&lt;/code&gt; 것 &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt; . 이와 같이 주석을 작성하면 값이 예상 유형이 아닌 경우 런타임 오류가 발생하여 잠재적으로 특정 버그를 조기에 발견 할 수 있다는 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b5f47a75f954e4b2fddf51e62aa2e1f9d263c7c" translate="yes" xml:space="preserve">
          <source>Here, we want &lt;code&gt;t0&lt;/code&gt;, &lt;code&gt;t1&lt;/code&gt;, and &lt;code&gt;val&lt;/code&gt; to be private temporary variables, and we want &lt;code&gt;time&lt;/code&gt; to refer to the &lt;code&gt;time&lt;/code&gt; function in Julia Base, not to any &lt;code&gt;time&lt;/code&gt; variable the user might have (the same applies to &lt;code&gt;println&lt;/code&gt;). Imagine the problems that could occur if the user expression &lt;code&gt;ex&lt;/code&gt; also contained assignments to a variable called &lt;code&gt;t0&lt;/code&gt;, or defined its own &lt;code&gt;time&lt;/code&gt; variable. We might get errors, or mysteriously incorrect behavior.</source>
          <target state="translated">여기서는 &lt;code&gt;t0&lt;/code&gt; , &lt;code&gt;t1&lt;/code&gt; 및 &lt;code&gt;val&lt;/code&gt; 이 개인 임시 변수가되기를 원 하며 사용자가 가질 수 있는 &lt;code&gt;time&lt;/code&gt; 변수가 아닌 Julia Base 의 &lt;code&gt;time&lt;/code&gt; 함수 를 참조하는 &lt;code&gt;time&lt;/code&gt; 을 원합니다 ( &lt;code&gt;println&lt;/code&gt; 에 동일하게 적용됨 ). 사용자 표현식 &lt;code&gt;ex&lt;/code&gt; 에 &lt;code&gt;t0&lt;/code&gt; 이라는 변수에 대한 할당이 포함되어 있거나 자체 &lt;code&gt;time&lt;/code&gt; 변수를 정의한 경우 발생할 수있는 문제를 상상해보십시오 . 우리는 오류나 신비하게 잘못된 행동을하게 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94fb6a6428243b8c36b29add8e81342285442dea" translate="yes" xml:space="preserve">
          <source>Here, we've added a custom constructor function so that it can take arguments of different &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; types and promote them to a common type (see &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Constructors&lt;/a&gt; and &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversion and Promotion&lt;/a&gt;). (Of course, we would have to define lots of other methods, too, to make it act like a &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;one&lt;/code&gt;, &lt;code&gt;zero&lt;/code&gt;, promotion rules and so on.) By default, instances of this type display rather simply, with information about the type name and the field values, as e.g. &lt;code&gt;Polar{Float64}(3.0,4.0)&lt;/code&gt;.</source>
          <target state="translated">여기에 다른 &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; 형식의 인수를 가져 와서 공통 형식으로 승격시킬 수 있도록 사용자 지정 생성자 함수를 추가했습니다 ( &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;생성자&lt;/a&gt; 및 &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;변환 및 승격 참조&lt;/a&gt; ). (물론, 우리는 다른 방법들도 정의해야합니다 . 예를 들어 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;one&lt;/code&gt; , &lt;code&gt;zero&lt;/code&gt; , 승격 규칙 등과 같이 &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; 처럼 작동 하도록해야합니다.) 기본적으로이 유형의 인스턴스는 단순하게 표시됩니다. , 유형 이름 및 필드 값에 대한 정보를 포함합니다 (예 : &lt;code&gt;Polar{Float64}(3.0,4.0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a8c4e9914a1889e98efb20fcf34b5a7f7c01253" translate="yes" xml:space="preserve">
          <source>Here, you've created the same problem all over again: the compiler can't guess what &lt;code&gt;n&lt;/code&gt; is, so it doesn't know the &lt;em&gt;type&lt;/em&gt; of &lt;code&gt;Val(n)&lt;/code&gt;. Attempting to use &lt;code&gt;Val&lt;/code&gt;, but doing so incorrectly, can easily make performance &lt;em&gt;worse&lt;/em&gt; in many situations. (Only in situations where you're effectively combining &lt;code&gt;Val&lt;/code&gt; with the function-barrier trick, to make the kernel function more efficient, should code like the above be used.)</source>
          <target state="translated">여기서 동일한 문제를 다시 한번 만들었습니다. 컴파일러는 &lt;code&gt;n&lt;/code&gt; 이 무엇인지 짐작할 수 없으므로 &lt;code&gt;Val(n)&lt;/code&gt; &lt;em&gt;유형&lt;/em&gt; 을 알 수 없습니다 . &lt;code&gt;Val&lt;/code&gt; 을 사용하려고 하지만 잘못 사용하면 여러 상황에서 성능이 쉽게 저하 &lt;em&gt;될&lt;/em&gt; 수 있습니다 . ( &lt;code&gt;Val&lt;/code&gt; 을 함수 장벽 트릭과 효과적으로 결합하는 상황에서만 커널 기능을보다 효율적으로 만들기 위해 위와 같은 코드를 사용해야합니다.)&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c7628673517938376c201f828128315e60314655" translate="yes" xml:space="preserve">
          <source>Hermitian Conjugate Matrix</source>
          <target state="translated">은자 공액 행렬</target>
        </trans-unit>
        <trans-unit id="7426047f57253430c62cd4ed4e8350b30626acf7" translate="yes" xml:space="preserve">
          <source>Hermitian matrix</source>
          <target state="translated">에르 미트 행렬</target>
        </trans-unit>
        <trans-unit id="10678e1b00011a887c8ed10343c313db680c592e" translate="yes" xml:space="preserve">
          <source>Hessenberg decomposition</source>
          <target state="translated">헤센 버그 분해</target>
        </trans-unit>
        <trans-unit id="18dcd84b08d39e78997dcf4fc69cbfdf65766429" translate="yes" xml:space="preserve">
          <source>Hex bytes (&lt;code&gt;\x&lt;/code&gt; with 1-2 trailing hex digits)</source>
          <target state="translated">16 진 바이트 ( 1-2 개의 후행 16 진 숫자가있는 &lt;code&gt;\x&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="5829ae1ed6f556d7c22293c127a375905a4cde38" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating-point literals are also valid, but only as &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; values, with &lt;code&gt;p&lt;/code&gt; preceding the base-2 exponent:</source>
          <target state="translated">16 진 부동 소수점 리터럴도 유효하지만 &lt;code&gt;p&lt;/code&gt; 는 밑이 2 인 지수 앞에 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; 값으로 만 유효 합니다.</target>
        </trans-unit>
        <trans-unit id="566a781a74cd1186e4a86a913b9dfbcd8a9760f5" translate="yes" xml:space="preserve">
          <source>Hibiscus</source>
          <target state="translated">Hibiscus</target>
        </trans-unit>
        <trans-unit id="590d79aff0a27abac1599349b9f60e654406e4f9" translate="yes" xml:space="preserve">
          <source>High Brightness Symbol</source>
          <target state="translated">고휘도 기호</target>
        </trans-unit>
        <trans-unit id="5c42b554d600e8a00d6d46015f5546b8d19934a3" translate="yes" xml:space="preserve">
          <source>High Voltage Sign</source>
          <target state="translated">고전압 표시</target>
        </trans-unit>
        <trans-unit id="ab1b93cb46a149db7c34f14c047358adef0d1f47" translate="yes" xml:space="preserve">
          <source>High-Heeled Shoe</source>
          <target state="translated">굽 ​​높은 구두</target>
        </trans-unit>
        <trans-unit id="22cda4a90e394a1d9c3ad940b9369d0797179dd6" translate="yes" xml:space="preserve">
          <source>High-Level Embedding</source>
          <target state="translated">고급 임베딩</target>
        </trans-unit>
        <trans-unit id="772ba23e35e2b9a933b76e30398f7eb414430f46" translate="yes" xml:space="preserve">
          <source>High-Level Embedding on Windows with Visual Studio</source>
          <target state="translated">Visual Studio를 사용하여 Windows에 고급 임베딩</target>
        </trans-unit>
        <trans-unit id="9f567cb6bf549d8f1f72a7aad5d5c25bc17a082a" translate="yes" xml:space="preserve">
          <source>High-Speed Train</source>
          <target state="translated">고속 열차</target>
        </trans-unit>
        <trans-unit id="00e1cd5d9c96d48229c7017e30357cb8a8d1334d" translate="yes" xml:space="preserve">
          <source>High-Speed Train With Bullet Nose</source>
          <target state="translated">총알 코를 가진 고속 열차</target>
        </trans-unit>
        <trans-unit id="1b2be27c3b5a49f7125a227298d591cb7aea55af" translate="yes" xml:space="preserve">
          <source>High-level libraries like &lt;a href=&quot;https://github.com/JuliaComputing/ArrayFire.jl&quot;&gt;ArrayFire.jl&lt;/a&gt; and &lt;a href=&quot;https://github.com/JuliaGPU/GPUArrays.jl&quot;&gt;GPUArrays.jl&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/JuliaComputing/ArrayFire.jl&quot;&gt;ArrayFire.jl&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/JuliaGPU/GPUArrays.jl&quot;&gt;GPUArrays.jl&lt;/a&gt; 과 같은 고급 라이브러리</target>
        </trans-unit>
        <trans-unit id="7e0b3549b5782921269587cd589e55b82058b718" translate="yes" xml:space="preserve">
          <source>High-level vendor-specific abstractions like &lt;a href=&quot;https://github.com/JuliaGPU/CuArrays.jl&quot;&gt;CuArrays.jl&lt;/a&gt; and &lt;a href=&quot;https://github.com/JuliaGPU/CLArrays.jl&quot;&gt;CLArrays.jl&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/JuliaGPU/CuArrays.jl&quot;&gt;CuArrays.jl&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/JuliaGPU/CLArrays.jl&quot;&gt;CLArrays.jl&lt;/a&gt; 과 같은 고급 공급 업체별 추상화</target>
        </trans-unit>
        <trans-unit id="cef2d62c8136407d7a5910b738c2a4954d1ff380" translate="yes" xml:space="preserve">
          <source>Hocho</source>
          <target state="translated">Hocho</target>
        </trans-unit>
        <trans-unit id="1183df425fd69adfff4afc7c4b9f794b3027f62e" translate="yes" xml:space="preserve">
          <source>Hold up: why macros?</source>
          <target state="translated">잠깐만 : 왜 매크로?</target>
        </trans-unit>
        <trans-unit id="a19d1b5e13bc5eadd5512a5657629c48486fc2aa" translate="yes" xml:space="preserve">
          <source>Holds a reference to an object of type &lt;code&gt;T&lt;/code&gt;, ensuring that it is only accessed atomically, i.e. in a thread-safe manner.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 형의 객체에 대한 참조를 유지하여 원자 적으로 만, 즉 스레드 안전 방식으로 액세스되도록합니다.</target>
        </trans-unit>
        <trans-unit id="6d4b2c4793516d9999da8f3caabfcc7a3164599f" translate="yes" xml:space="preserve">
          <source>Home, &lt;code&gt;^A&lt;/code&gt;</source>
          <target state="translated">집, &lt;code&gt;^A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85d163149ee6c8d4bb4972a8d9d62f2349badb11" translate="yes" xml:space="preserve">
          <source>Homothetic</source>
          <target state="translated">Homothetic</target>
        </trans-unit>
        <trans-unit id="642aac9525060b37b0f7470d6f6c49db706b03d9" translate="yes" xml:space="preserve">
          <source>Honey Pot</source>
          <target state="translated">꿀단지</target>
        </trans-unit>
        <trans-unit id="a643db335a306154edebc33a5e2763a380d1411b" translate="yes" xml:space="preserve">
          <source>Honeybee</source>
          <target state="translated">Honeybee</target>
        </trans-unit>
        <trans-unit id="79734fdcfe66d25a072a5769ba821cd7967d89f5" translate="yes" xml:space="preserve">
          <source>Hooking into the &lt;code&gt;Random&lt;/code&gt; API</source>
          <target state="translated">&lt;code&gt;Random&lt;/code&gt; API에 연결</target>
        </trans-unit>
        <trans-unit id="a938072797969a150ccb7384d30e3585d81c5ec0" translate="yes" xml:space="preserve">
          <source>Horizontal Black Hexagon</source>
          <target state="translated">수평 검은 육각형</target>
        </trans-unit>
        <trans-unit id="9d0c97d942673d5e711ab71b642cc25b6f24a2b9" translate="yes" xml:space="preserve">
          <source>Horizontal Ellipsis</source>
          <target state="translated">수평 줄임표</target>
        </trans-unit>
        <trans-unit id="3627a44f223e474759956cf47448b20612b0d19a" translate="yes" xml:space="preserve">
          <source>Horizontal Traffic Light</source>
          <target state="translated">수평 신호등</target>
        </trans-unit>
        <trans-unit id="b7e611daf03b332b5f4ec9209097868ee372b256" translate="yes" xml:space="preserve">
          <source>Horizontal and vertical concatenation in one call. This function is called for block matrix syntax. The first argument specifies the number of arguments to concatenate in each block row.</source>
          <target state="translated">한 번의 통화에서 수평 및 수직 연결. 이 함수는 블록 매트릭스 구문을 위해 호출됩니다. 첫 번째 인수는 각 블록 행에서 연결할 인수 수를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="f26372d5f0aca43e155e7d006ab50ec72ec57fe2" translate="yes" xml:space="preserve">
          <source>Horizontal rules</source>
          <target state="translated">수평 규칙</target>
        </trans-unit>
        <trans-unit id="26dfe8116b93ced6cfca858f375d23f1489d3207" translate="yes" xml:space="preserve">
          <source>Horse</source>
          <target state="translated">Horse</target>
        </trans-unit>
        <trans-unit id="4a166dcec39a913a939b3a42f695d1c218fcaebb" translate="yes" xml:space="preserve">
          <source>Horse Face</source>
          <target state="translated">말 얼굴</target>
        </trans-unit>
        <trans-unit id="8f21624d2501467ee4a054c705bd995e4b73ebab" translate="yes" xml:space="preserve">
          <source>Horse Racing</source>
          <target state="translated">경마</target>
        </trans-unit>
        <trans-unit id="dbb927867e102f755c1433b1f25539bafdd7268b" translate="yes" xml:space="preserve">
          <source>Hospital</source>
          <target state="translated">Hospital</target>
        </trans-unit>
        <trans-unit id="ef97c144078e1020e0c1fdf8b383ff06d12e8270" translate="yes" xml:space="preserve">
          <source>Hot Beverage</source>
          <target state="translated">뜨거운 음료</target>
        </trans-unit>
        <trans-unit id="cb506dd41a005a6fcc0d4c18104ce66e01d7afa8" translate="yes" xml:space="preserve">
          <source>Hot Springs</source>
          <target state="translated">온천</target>
        </trans-unit>
        <trans-unit id="9c4ba7d047eb56093b34e5dc3e51e5fcc74603f4" translate="yes" xml:space="preserve">
          <source>Hotel</source>
          <target state="translated">Hotel</target>
        </trans-unit>
        <trans-unit id="fcc1b57017e3ac9f33e4e51068baf64a23795adf" translate="yes" xml:space="preserve">
          <source>Hourglass</source>
          <target state="translated">Hourglass</target>
        </trans-unit>
        <trans-unit id="bf7a0304247679d7272f0a79f9d388f130597fd4" translate="yes" xml:space="preserve">
          <source>Hourglass With Flowing Sand</source>
          <target state="translated">흐르는 모래와 모래 시계</target>
        </trans-unit>
        <trans-unit id="dc8745ba30beefa5d028f85ba9b11599a2ac8d7e" translate="yes" xml:space="preserve">
          <source>House</source>
          <target state="translated">House</target>
        </trans-unit>
        <trans-unit id="b6ac911209d87615e6f295e017b36c332cd3b878" translate="yes" xml:space="preserve">
          <source>House Building</source>
          <target state="translated">집 건물</target>
        </trans-unit>
        <trans-unit id="b07df507eb5fd0e4b6c36328d58c64ebcc7b5d32" translate="yes" xml:space="preserve">
          <source>House With Garden</source>
          <target state="translated">정원이있는 집</target>
        </trans-unit>
        <trans-unit id="eefa8d28bdac822ea112d7e5259409579ba61c80" translate="yes" xml:space="preserve">
          <source>How can I modify the declaration of a type in my session?</source>
          <target state="translated">세션에서 유형 선언을 수정하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="515d85b9b31cb430ad4b0705dfed0fd34c859e1a" translate="yes" xml:space="preserve">
          <source>How did the file name get quoted? Julia knows that &lt;code&gt;file&lt;/code&gt; is meant to be interpolated as a single argument, so it quotes the word for you. Actually, that is not quite accurate: the value of &lt;code&gt;file&lt;/code&gt; is never interpreted by a shell, so there's no need for actual quoting; the quotes are inserted only for presentation to the user. This will even work if you interpolate a value as part of a shell word:</source>
          <target state="translated">파일 이름은 어떻게 인용 되었습니까? Julia는 &lt;code&gt;file&lt;/code&gt; 이 단일 인수로 보간되어야 함을 알고 있으므로 단어를 인용합니다. 실제로 이것은 정확하지 않습니다. &lt;code&gt;file&lt;/code&gt; 의 값은 쉘에 의해 해석되지 않으므로 실제 인용은 필요하지 않습니다. 인용 부호는 사용자에게 표시하기 위해서만 삽입됩니다. 쉘 단어의 일부로 값을 보간하는 경우에도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7554712c2d173a82ff8ff4725649f94b899a6cab" translate="yes" xml:space="preserve">
          <source>How do I catch CTRL-C in a script?</source>
          <target state="translated">스크립트에서 CTRL-C를 어떻게 잡을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="2a65d886539b09798da7278037976d95b79a6f2f" translate="yes" xml:space="preserve">
          <source>How do I check if the current file is being run as the main script?</source>
          <target state="translated">현재 파일이 기본 스크립트로 실행되고 있는지 어떻게 확인합니까?</target>
        </trans-unit>
        <trans-unit id="07f058f4bf96d455fe968f2d1e89bd25936e7928" translate="yes" xml:space="preserve">
          <source>How do I delete an object in memory?</source>
          <target state="translated">메모리에서 객체를 어떻게 삭제합니까?</target>
        </trans-unit>
        <trans-unit id="b215618760cff9b8483504445b91edb71bee5871" translate="yes" xml:space="preserve">
          <source>How do I pass options to &lt;code&gt;julia&lt;/code&gt; using &lt;code&gt;#!/usr/bin/env&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;#!/usr/bin/env&lt;/code&gt; 을 사용하여 &lt;code&gt;julia&lt;/code&gt; 에 옵션을 전달하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="eb9157ff1fb18352038c8a12eae2a15bbdb246dd" translate="yes" xml:space="preserve">
          <source>How does &quot;null&quot;, &quot;nothingness&quot; or &quot;missingness&quot; work in Julia?</source>
          <target state="translated">Julia에서 &quot;null&quot;, &quot;nothingness&quot;또는 &quot;missingness&quot;는 어떻게 작동합니까?</target>
        </trans-unit>
        <trans-unit id="fd885280d6cbd9f996932c72e9d360397c1bf016" translate="yes" xml:space="preserve">
          <source>How does one construct a &lt;code&gt;Point&lt;/code&gt; object? It is possible to define custom constructors for composite types, which will be discussed in detail in &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Constructors&lt;/a&gt;, but in the absence of any special constructor declarations, there are two default ways of creating new composite objects, one in which the type parameters are explicitly given and the other in which they are implied by the arguments to the object constructor.</source>
          <target state="translated">&lt;code&gt;Point&lt;/code&gt; 객체 는 어떻게 구성 합니까? 합성 자 유형에 대한 사용자 정의 생성자를 정의 할 수 있습니다. &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;생성자&lt;/a&gt; 에서 자세히 설명 하지만 특별한 생성자 선언이없는 경우, 새로운 복합 객체를 작성하는 두 가지 기본 방법이 있습니다. 하나는 유형 매개 변수가 명시 적으로 제공됩니다. 그리고 다른 하나는 객체 생성자에 대한 인수에 의해 암시됩니다.</target>
        </trans-unit>
        <trans-unit id="06e308a7a0638232b6f09929d443c3620a3b020e" translate="yes" xml:space="preserve">
          <source>How these arguments are initialized depends on the &quot;outer&quot; function; here, &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; will sequentially set &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, calling the anonymous function on each, just as would happen in the syntax &lt;code&gt;map(func, [A, B, C])&lt;/code&gt;.</source>
          <target state="translated">이러한 인수가 초기화되는 방법은 &quot;외부&quot;기능에 따라 다릅니다. 여기서 &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; 은 구문 &lt;code&gt;map(func, [A, B, C])&lt;/code&gt; 에서와 같이 &lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; 로 순차적으로 설정 하여 각각 익명 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="eaf97b67896b3cc13483847a79f98eac92d8c7ad" translate="yes" xml:space="preserve">
          <source>How you use this information is up to you. Obviously, it would be far and away best to fix &lt;code&gt;pos&lt;/code&gt; to be type-stable: if you did so, all of the variables in &lt;code&gt;f&lt;/code&gt; would be concrete, and its performance would be optimal. However, there are circumstances where this kind of &lt;em&gt;ephemeral&lt;/em&gt; type instability might not matter too much: for example, if &lt;code&gt;pos&lt;/code&gt; is never used in isolation, the fact that &lt;code&gt;f&lt;/code&gt;'s output is type-stable (for &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; inputs) will shield later code from the propagating effects of type instability. This is particularly relevant in cases where fixing the type instability is difficult or impossible. In such cases, the tips above (e.g., adding type annotations and/or breaking up functions) are your best tools to contain the &quot;damage&quot; from type instability. Also, note that even Julia Base has functions that are type unstable. For example, the function &lt;code&gt;findfirst&lt;/code&gt; returns the index into an array where a key is found, or &lt;code&gt;nothing&lt;/code&gt; if it is not found, a clear type instability. In order to make it easier to find the type instabilities that are likely to be important, &lt;code&gt;Union&lt;/code&gt;s containing either &lt;code&gt;missing&lt;/code&gt; or &lt;code&gt;nothing&lt;/code&gt; are color highlighted in yellow, instead of red.</source>
          <target state="translated">이 정보를 사용하는 방법은 귀하에게 달려 있습니다. 분명히, &lt;code&gt;pos&lt;/code&gt; 를 타입 안정적 으로 수정 하는 것이 가장 좋습니다 . 그렇다면 &lt;code&gt;f&lt;/code&gt; 의 모든 변수는 구체적이고 성능은 최적입니다. 그러나 이런 종류의 &lt;em&gt;임시&lt;/em&gt; 유형 불안정성이 그다지 중요하지 않은 상황이 있습니다. 예를 들어, &lt;code&gt;pos&lt;/code&gt; 를 단독으로 사용하지 않는 경우 &lt;code&gt;f&lt;/code&gt; 의 출력이 유형 안정성 이라는 사실이 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;입력)은 나중에 불안정한 유형의 전파 효과로부터 코드를 보호합니다. 유형 불안정성을 수정하는 것이 어렵거나 불가능한 경우에 특히 관련이 있습니다. 이러한 경우 위의 팁 (예 : 유형 주석 추가 및 / 또는 기능 분해)은 유형 불안정으로 인한 &quot;손상&quot;을 포함하는 가장 좋은 도구입니다. 또한 Julia Base도 불안정한 유형의 기능을 가지고 있습니다. 예를 들어 &lt;code&gt;findfirst&lt;/code&gt; 함수는 인덱스를 키가 발견 된 배열로 반환하거나 찾지 &lt;code&gt;nothing&lt;/code&gt; 경우 명확한 유형 불안정성을 반환합니다. 중요한 유형 불안정성을 쉽게 찾을 수 있도록 &lt;code&gt;Union&lt;/code&gt; 은 &lt;code&gt;missing&lt;/code&gt; 되거나 &lt;code&gt;nothing&lt;/code&gt; 포함 하지 않습니다. 빨간색 대신 노란색으로 강조 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="042ec23eb15357af1265112d56deb61892b131f1" translate="yes" xml:space="preserve">
          <source>However one should keep in mind, that macro dispatch is based on the types of AST that are handed to the macro, not the types that the AST evaluates to at runtime:</source>
          <target state="translated">그러나 매크로 디스패치는 AST가 런타임에 평가하는 유형이 아니라 매크로에 전달 된 AST 유형을 기반으로한다는 점을 명심해야합니다.</target>
        </trans-unit>
        <trans-unit id="ec8145ef611e8eb6adb7aa2875037ca9cf5cb809" translate="yes" xml:space="preserve">
          <source>However, all the information we need for the loop is embedded in the type information of the arguments. Thus, we can utilize generated functions to move the iteration to compile-time; in compiler parlance, we use generated functions to manually unroll the loop. The body becomes almost identical, but instead of calculating the linear index, we build up an &lt;em&gt;expression&lt;/em&gt; that calculates the index:</source>
          <target state="translated">그러나 루프에 필요한 모든 정보는 인수의 유형 정보에 포함됩니다. 따라서 생성 된 함수를 사용하여 반복을 컴파일 타임으로 이동할 수 있습니다. 컴파일러 용어에서는 생성 된 함수를 사용하여 루프를 수동으로 언 롤링합니다. 본문은 거의 동일하지만 선형 색인을 계산하는 대신 색인 을 계산 하는 &lt;em&gt;표현식&lt;/em&gt; 을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="42e7ab564618248599a98b48397f91d9696cc5fd" translate="yes" xml:space="preserve">
          <source>However, doing this will also be very slow and leak memory, so you should usually avoid this and instead keep reading. The next section discusses how to use indirect calls to efficiently accomplish a similar effect.</source>
          <target state="translated">그러나이 작업을 수행하면 메모리가 매우 느리고 누수가 발생하므로 일반적으로이를 피하고 계속 읽으십시오. 다음 섹션에서는 간접 호출을 사용하여 유사한 효과를 효율적으로 달성하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1f4c1ec1ac04c3b7530d92971ca6fe0a67c59d9d" translate="yes" xml:space="preserve">
          <source>However, for mutable objects the warning is printed as expected:</source>
          <target state="translated">그러나 변경 가능한 객체의 경우 경고가 예상대로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="2b94a9c2374adeaf4e451f1d8f8dbbec3cf93bf0" translate="yes" xml:space="preserve">
          <source>However, future calls to &lt;code&gt;tryeval&lt;/code&gt; will continue to see the definition of &lt;code&gt;newfun&lt;/code&gt; as it was &lt;em&gt;at the previous statement at the REPL&lt;/em&gt;, and thus before that call to &lt;code&gt;tryeval&lt;/code&gt;.</source>
          <target state="translated">그러나 향후 통화 &lt;code&gt;tryeval&lt;/code&gt; 는 의 정의가 계속됩니다 &lt;code&gt;newfun&lt;/code&gt; 을 그것이로 &lt;em&gt;REPL에서 이전 문에&lt;/em&gt; , 따라서 해당 호출 전에 &lt;code&gt;tryeval&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96a28d68e1fc2327784959f0995bfa65f1bc559d" translate="yes" xml:space="preserve">
          <source>However, if needed you can specialize on any or all of these arguments. The final argument &lt;code&gt;bc&lt;/code&gt; is a lazy representation of a (potentially fused) broadcast operation, a &lt;code&gt;Broadcasted&lt;/code&gt; object. For these purposes, the most important fields of the wrapper are &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;args&lt;/code&gt;, describing the function and argument list, respectively. Note that the argument list can &amp;mdash; and often does &amp;mdash; include other nested &lt;code&gt;Broadcasted&lt;/code&gt; wrappers.</source>
          <target state="translated">그러나 필요한 경우 이러한 인수 중 일부 또는 전부를 전문화 할 수 있습니다. 마지막 인수 &lt;code&gt;bc&lt;/code&gt; 는 (잠재적으로 융합 된) 브로드 캐스트 작업 인 &lt;code&gt;Broadcasted&lt;/code&gt; 개체 의 게으른 표현입니다 . 이러한 목적으로 래퍼의 가장 중요한 필드는 각각 함수와 인수 목록을 설명하는 &lt;code&gt;f&lt;/code&gt; 와 &lt;code&gt;args&lt;/code&gt; 입니다. 인수 목록은 다른 중첩 된 &lt;code&gt;Broadcasted&lt;/code&gt; 래퍼를 포함 할 수 있으며 종종 포함 합니다.</target>
        </trans-unit>
        <trans-unit id="a1a03264a4e905ebd619a9b03ec0d4363bf201f9" translate="yes" xml:space="preserve">
          <source>However, if you try to redefine a built-in constant or function already in use, Julia will give you an error:</source>
          <target state="translated">그러나 이미 사용중인 내장 상수 또는 함수를 재정의하려고하면 Julia에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b612aa5b83e1e5e4f183ec87a4a8051d812c4982" translate="yes" xml:space="preserve">
          <source>However, it is not hard to construct cases where this will fail:</source>
          <target state="translated">그러나 이것이 실패하는 경우를 구성하는 것은 어렵지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f588e867dce1639bbbc3e181485bd13a34f96de5" translate="yes" xml:space="preserve">
          <source>However, it is occasionally useful to reuse an existing local variable as the iteration variable. This can be done conveniently by adding the keyword &lt;code&gt;outer&lt;/code&gt;:</source>
          <target state="translated">그러나 기존 로컬 변수를 반복 변수로 재사용하는 것이 유용한 경우가 있습니다. 키워드 &lt;code&gt;outer&lt;/code&gt; 를 추가하면 편리하게 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3fc16da92345edab485c9b8587412c5e7cbbb69" translate="yes" xml:space="preserve">
          <source>However, it's still possible, for instance, to send a &lt;code&gt;MyType&lt;/code&gt; to a process which has loaded &lt;code&gt;DummyModule&lt;/code&gt; even if it's not in scope:</source>
          <target state="translated">그러나 예를 들어 &lt;code&gt;DummyModule&lt;/code&gt; 이 범위 내에 있지 않더라도 &lt;code&gt;MyType&lt;/code&gt; 을 프로세스에로드하는 것은 여전히 ​​가능합니다 .</target>
        </trans-unit>
        <trans-unit id="0206b7f024c599046b1522c22d104a0f2b4ea5b8" translate="yes" xml:space="preserve">
          <source>However, making use of such techniques can be surprisingly subtle. For example, it would be of no help if you called &lt;code&gt;array3&lt;/code&gt; from a function like this:</source>
          <target state="translated">그러나 이러한 기술을 사용하는 것은 놀랍게도 미묘 할 수 있습니다. 예를 들어 다음 과 같은 함수에서 &lt;code&gt;array3&lt;/code&gt; 을 호출하면 도움이되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1ad09b70c7675ac7974cd81421e0b196fa34837e" translate="yes" xml:space="preserve">
          <source>However, other similar calls still don't work:</source>
          <target state="translated">그러나 다른 유사한 통화는 여전히 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d6c01a830ee4c6c4b08c6d0fd04973c57ba502a5" translate="yes" xml:space="preserve">
          <source>However, since the automatic vectorization cannot be relied upon, future use will mostly be via libraries that use &lt;code&gt;llvmcall&lt;/code&gt;.</source>
          <target state="translated">그러나 자동 벡터화에 의존 할 수 없으므로 향후 사용은 주로 &lt;code&gt;llvmcall&lt;/code&gt; 을 사용하는 라이브러리를 통해 이루어집니다 .</target>
        </trans-unit>
        <trans-unit id="0a9c9e751e43cb6eaac4e5372d46543dc59ec370" translate="yes" xml:space="preserve">
          <source>However, since this is slightly cumbersome, there are several convenience methods provided. For example, we could have written the above as:</source>
          <target state="translated">그러나 이것은 약간 성가 시므로 몇 가지 편리한 방법이 제공됩니다. 예를 들어, 위와 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4963644e11f9a07fc917ac8319ecfbd548bbe63b" translate="yes" xml:space="preserve">
          <source>However, some modules contain submodules, which means you sometimes need to access a non-top-level module. There are two ways to do this. The first is to use an absolute path, for example &lt;code&gt;using Base.Sort&lt;/code&gt;. The second is to use a relative path, which makes it easier to import submodules of the current module or any of its enclosing modules:</source>
          <target state="translated">그러나 일부 모듈에는 하위 모듈이 포함되어 있으므로 때때로 최상위가 아닌 모듈에 액세스해야합니다. 이를 수행하는 두 가지 방법이 있습니다. 첫 번째는 절대 경로를 사용하는 것입니다 (예 : &lt;code&gt;using Base.Sort&lt;/code&gt; . 두 번째는 상대 경로를 사용하여 현재 모듈의 하위 모듈이나 주변 모듈을 쉽게 가져올 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="788054e244adc6c2716171e1c63990c4810a9000" translate="yes" xml:space="preserve">
          <source>However, sometimes it makes sense to keep the uppercase first letter, for instance if an argument to a function is a capital letter: &lt;code&gt;size(A,1) == size(B,2) || throw(DimensionMismatch(&quot;A has first dimension...&quot;))&lt;/code&gt;.</source>
          <target state="translated">그러나 함수에 대한 인수가 대문자 인 경우와 같이 대문자를 첫 글자로 유지해야하는 경우가 있습니다. &lt;code&gt;size(A,1) == size(B,2) || throw(DimensionMismatch(&quot;A has first dimension...&quot;))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="734c2f5135f1e869aae040511570811afbc769c7" translate="yes" xml:space="preserve">
          <source>However, the outer &lt;code&gt;quote&lt;/code&gt; expression is able to interpolate values inside the &lt;code&gt;$&lt;/code&gt; in the inner quote. This is done with multiple &lt;code&gt;$&lt;/code&gt;s:</source>
          <target state="translated">그러나 외부 &lt;code&gt;quote&lt;/code&gt; 표현식은 내부 인용에서 &lt;code&gt;$&lt;/code&gt; 내부의 값을 보간 할 수 있습니다. 이것은 여러 &lt;code&gt;$&lt;/code&gt; s로 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="a78965b80768b2188b4d959fddb093f72b6aa627" translate="yes" xml:space="preserve">
          <source>However, there are cases where you may need to declare different versions of the outer function for different element types or types of the &lt;code&gt;AbstractVector&lt;/code&gt; of the field &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;MySimpleContainer&lt;/code&gt;. You could do it like this:</source>
          <target state="translated">그러나 다른 요소 유형 또는 유형에 대한 외부 기능의 다른 버전 선언 할 필요가 있습니다 경우가 있습니다 &lt;code&gt;AbstractVector&lt;/code&gt; 필드의 에 &lt;code&gt;MySimpleContainer&lt;/code&gt; 은 . 다음과 같이 할 수 있습니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3975391f531616484a0e31ee77d8e0e00f61fa9e" translate="yes" xml:space="preserve">
          <source>However, there are three key differences:</source>
          <target state="translated">그러나 세 가지 주요 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5c45c8616fbe8c99fd70a67651ffd25fb8f16b8" translate="yes" xml:space="preserve">
          <source>However, this is &lt;em&gt;not&lt;/em&gt; recommended. Instead, use the more efficient &lt;code&gt;complex&lt;/code&gt; function to construct a complex value directly from its real and imaginary parts:</source>
          <target state="translated">그러나 이것은 권장 &lt;em&gt;되지&lt;/em&gt; 않습니다. 대신,보다 효율적인 &lt;code&gt;complex&lt;/code&gt; 함수를 사용하여 실수 부와 허수 부에서 직접 복잡한 값을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="a2261e024bded1ce38fa0b00996da87c5f69ba9d" translate="yes" xml:space="preserve">
          <source>However, type promotion between the primitive types above and &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; is not automatic and must be explicitly stated.</source>
          <target state="translated">그러나 위의 기본 유형과 &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt; 간의 유형 승격은 자동이 아니며 명시 적으로 명시해야합니다.</target>
        </trans-unit>
        <trans-unit id="a17c41ad2e8a1887210e57ce0ca80b0a2e7e175c" translate="yes" xml:space="preserve">
          <source>However, we don't do this for a good reason: wrapping the &lt;code&gt;expr&lt;/code&gt; in a new scope block (the anonymous function) also slightly changes the meaning of the expression (the scope of any variables in it), while we want &lt;code&gt;@time&lt;/code&gt; to be usable with minimum impact on the wrapped code.</source>
          <target state="translated">그러나 &lt;code&gt;expr&lt;/code&gt; 을 새로운 스코프 블록 (익명 함수)으로 래핑 하면 표현식의 의미 (변수의 범위)도 약간 변경 &lt;code&gt;@time&lt;/code&gt; 은 랩핑 된 코드에 미치는 영향을 최소화하면서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b0f70feaa3a28d45e6f3a13fc1f48acf2f37d7c" translate="yes" xml:space="preserve">
          <source>However, while the type layout must be known statically to compute the intended C ABI, the static parameters of the function are considered to be part of this static environment. The static parameters of the function may be used as type parameters in the call signature, as long as they don't affect the layout of the type. For example, &lt;code&gt;f(x::T) where {T} = ccall(:valid, Ptr{T}, (Ptr{T},), x)&lt;/code&gt; is valid, since &lt;code&gt;Ptr&lt;/code&gt; is always a word-size primitive type. But, &lt;code&gt;g(x::T) where {T} = ccall(:notvalid, T, (T,), x)&lt;/code&gt; is not valid, since the type layout of &lt;code&gt;T&lt;/code&gt; is not known statically.</source>
          <target state="translated">그러나 의도 한 C ABI를 계산하려면 형식 레이아웃을 정적으로 알고 있어야하지만 함수의 정적 매개 변수는이 정적 환경의 일부로 간주됩니다. 함수의 정적 매개 변수는 유형의 레이아웃에 영향을 미치지 않는 한 호출 서명에서 유형 매개 변수로 사용될 수 있습니다. 예를 들어, &lt;code&gt;f(x::T) where {T} = ccall(:valid, Ptr{T}, (Ptr{T},), x)&lt;/code&gt; 있기 때문에, 유효 &lt;code&gt;Ptr&lt;/code&gt; 항상 워드 크기 프리미티브 타입이다. 단, &lt;code&gt;g(x::T) where {T} = ccall(:notvalid, T, (T,), x)&lt;/code&gt; 유형 배치되기 때문에, 유효하지 않은 &lt;code&gt;T&lt;/code&gt; 가 정적으로 알려져 있지 않다.</target>
        </trans-unit>
        <trans-unit id="50d668f1d842d230950802dd8f5eb4d3254c4568" translate="yes" xml:space="preserve">
          <source>Hundred Points Symbol</source>
          <target state="translated">백점 기호</target>
        </trans-unit>
        <trans-unit id="fdd59db74c581af271b7941aa03e44ed5fe0b191" translate="yes" xml:space="preserve">
          <source>Hushed Face</source>
          <target state="translated">숨은 얼굴</target>
        </trans-unit>
        <trans-unit id="37906f8372f8c377be7b1e328309d3c4f609ea59" translate="yes" xml:space="preserve">
          <source>Hygiene</source>
          <target state="translated">Hygiene</target>
        </trans-unit>
        <trans-unit id="9dfda2b4e8d2ebd709351cb5956b33e0e4ffe363" translate="yes" xml:space="preserve">
          <source>Hyndman, R.J and Fan, Y. (1996) &quot;Sample Quantiles in Statistical Packages&quot;, &lt;em&gt;The American Statistician&lt;/em&gt;, Vol. 50, No. 4, pp. 361-365</source>
          <target state="translated">Hyndman, RJ and Fan, Y. (1996) &quot;통계 패키지의 표본 Quantiles&quot;, &lt;em&gt;The American Statistician&lt;/em&gt; , Vol. 50 권 4 호 361-365</target>
        </trans-unit>
        <trans-unit id="cde96ad42b76d0bdd741afbb558f7a3b372bce7e" translate="yes" xml:space="preserve">
          <source>I (interval)</source>
          <target state="translated">나 (간격)</target>
        </trans-unit>
        <trans-unit id="1f1b2f73366cab7e556f4c5764548bfeee9e55d4" translate="yes" xml:space="preserve">
          <source>I passed an argument &lt;code&gt;x&lt;/code&gt; to a function, modified it inside that function, but on the outside, the variable &lt;code&gt;x&lt;/code&gt; is still unchanged. Why?</source>
          <target state="translated">인수 &lt;code&gt;x&lt;/code&gt; 를 함수에 전달하고 해당 함수 내에서 수정했지만 외부에서 변수 &lt;code&gt;x&lt;/code&gt; 는 여전히 변경되지 않았습니다. 왜?</target>
        </trans-unit>
        <trans-unit id="f6d15c9cfe8c2c69adbb304be5e27663dff93f96" translate="yes" xml:space="preserve">
          <source>I.e. the value returned by &lt;code&gt;codeunit(s, i)&lt;/code&gt; is of the type returned by &lt;code&gt;codeunit(s)&lt;/code&gt;.</source>
          <target state="translated">즉, &lt;code&gt;codeunit(s, i)&lt;/code&gt; 의해 리턴 된 값 은 &lt;code&gt;codeunit(s)&lt;/code&gt; 의해 리턴 된 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="7cf18e3da9119216f8e328e30538193a84b6a06e" translate="yes" xml:space="preserve">
          <source>I/O and Network</source>
          <target state="translated">I / O 및 네트워크</target>
        </trans-unit>
        <trans-unit id="f202b270f0bf2c3423308846f107faa93c51a606" translate="yes" xml:space="preserve">
          <source>ID of the device that contains the file</source>
          <target state="translated">파일이 포함 된 장치의 ID</target>
        </trans-unit>
        <trans-unit id="f9c4d94c8313e5f3e388b78d066d32450a104438" translate="yes" xml:space="preserve">
          <source>IO Output Contextual Properties</source>
          <target state="translated">IO 출력 상황 별 속성</target>
        </trans-unit>
        <trans-unit id="197f5eacc88f8f1df449bfc2c0077d2d00ba82c7" translate="yes" xml:space="preserve">
          <source>IO redirection can be accomplished by passing keyword arguments &lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt;, and &lt;code&gt;stderr&lt;/code&gt; to the &lt;code&gt;pipeline&lt;/code&gt; function:</source>
          <target state="translated">키워드 인수 &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; 및 &lt;code&gt;stderr&lt;/code&gt; 을 &lt;code&gt;pipeline&lt;/code&gt; 함수 에 전달하여 IO 리디렉션을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01d2fc4baf23050afed6538bf5b3afda200aec20" translate="yes" xml:space="preserve">
          <source>IOBuffer</source>
          <target state="translated">IOBuffer</target>
        </trans-unit>
        <trans-unit id="1e240958856813e40093848d027d47dc30e4009a" translate="yes" xml:space="preserve">
          <source>IOContext</source>
          <target state="translated">IOContext</target>
        </trans-unit>
        <trans-unit id="29093ff8b21b1b330d3e6699a2ad82a180dd947e" translate="yes" xml:space="preserve">
          <source>IOContext()</source>
          <target state="translated">IOContext()</target>
        </trans-unit>
        <trans-unit id="3afa239559b1455a86cd4aafab53cb6dd69792c0" translate="yes" xml:space="preserve">
          <source>IOStream</source>
          <target state="translated">IOStream</target>
        </trans-unit>
        <trans-unit id="8d31d2211f88e51d4dac04058ee63fd1f5837600" translate="yes" xml:space="preserve">
          <source>Ice Cream</source>
          <target state="translated">아이스크림</target>
        </trans-unit>
        <trans-unit id="2b3a1ae210dbbbf1609a9fd75685f6380218b075" translate="yes" xml:space="preserve">
          <source>IdDict</source>
          <target state="translated">IdDict</target>
        </trans-unit>
        <trans-unit id="898cecd14809e1e6d2d6a1ad03f40fe8f8898ff9" translate="yes" xml:space="preserve">
          <source>Identical To</source>
          <target state="translated">동일</target>
        </trans-unit>
        <trans-unit id="c539ce4823e892243cf1d72e5cda29852ab1bb48" translate="yes" xml:space="preserve">
          <source>Identical To And Slanted Parallel</source>
          <target state="translated">동일하고 기울어 진 평행</target>
        </trans-unit>
        <trans-unit id="44763ae8a5457dbe6219995560f8ceac0b654107" translate="yes" xml:space="preserve">
          <source>Identical With Dot Above</source>
          <target state="translated">위의 점과 동일</target>
        </trans-unit>
        <trans-unit id="49f0f00de3919e6aa513f490a486fcbae4d4df50" translate="yes" xml:space="preserve">
          <source>If $n$ is negative, then it is defined in terms of the identity</source>
          <target state="translated">$ n $가 음수이면, 신원의 관점에서 정의됩니다</target>
        </trans-unit>
        <trans-unit id="4ed2889e692f7a726f27cb34a6abbc329da52fe8" translate="yes" xml:space="preserve">
          <source>If $n$ is non-negative, then it is the number of ways to choose &lt;code&gt;k&lt;/code&gt; out of &lt;code&gt;n&lt;/code&gt; items:</source>
          <target state="translated">$ n $가 음수가 아닌 경우 &lt;code&gt;n&lt;/code&gt; 개의 항목 중 &lt;code&gt;k&lt;/code&gt; 개 를 선택하는 방법의 수입니다 .</target>
        </trans-unit>
        <trans-unit id="21a045b4d60526617fd3c07b9d46739e69a41cdd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has no negative real eigenvalue, compute the principal matrix logarithm of &lt;code&gt;A&lt;/code&gt;, i.e. the unique matrix $X$ such that $e^X = A$ and $-\pi &amp;lt; Im(\lambda) &amp;lt; \pi$ for all the eigenvalues $\lambda$ of $X$. If &lt;code&gt;A&lt;/code&gt; has nonpositive eigenvalues, a nonprincipal matrix function is returned whenever possible.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 부정적인 실제 고유을주지의 주요 행렬 대수 계산 &lt;code&gt;A&lt;/code&gt; , 즉 고유 행렬 $의 X는 $ 그 $ E ^ X = A $ 및 $ - \ PI &amp;lt;임 (\ 람다) 모두를위한 &amp;lt;\ 파이 $ 고유 값 $ \ lambda $ of $ X $. &lt;code&gt;A&lt;/code&gt; 에 양수가 아닌 고유 값이 있으면 가능할 때마다 주체가 아닌 행렬 함수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7259d98627a04b894a1123257649b9b0e506f9f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has no negative real eigenvalues, compute the principal matrix square root of &lt;code&gt;A&lt;/code&gt;, that is the unique matrix $X$ with eigenvalues having positive real part such that $X^2 = A$. Otherwise, a nonprincipal square root is returned.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 부정적인 실제 고유 값을주지의 주요 행렬 제곱근 계산 고유치가 양의 실수 부분이 같은 $ X ^ 2 = A $을 갖는 고유 행렬의 $ X $입니다. 그렇지 않으면 비원시 제곱근이 반환됩니다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="19b01775b8b82ce68d3f6a6f522f474a638dda03" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the cosine. Otherwise, the cosine is determined by calling &lt;code&gt;exp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 가 대칭이거나 허미 시안 인 경우 &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; 분해 ( eigen )가 코사인을 계산하는 데 사용됩니다. 그렇지 않으면 코사인은 &lt;code&gt;exp&lt;/code&gt; 를 호출하여 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="acf6a44af56176e5053aa08ad7d4eea1a7727bea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse cosine. Otherwise, the inverse cosine is determined by using &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;sqrt&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_1&quot;&gt;[AH16_1]&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 대칭 또는 에르 미트, 그 eigendecomposition ( &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; ) 역 코사인 변환을 계산하기 위해 사용된다. 그렇지 않으면, 역 코사인은 &lt;code&gt;log&lt;/code&gt; 및 &lt;code&gt;sqrt&lt;/code&gt; 를 사용하여 결정됩니다 . 이 함수를 계산하는 데 사용되는 이론 및 로그 공식은 &lt;a href=&quot;#footnote-AH16_1&quot;&gt;[AH16_1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bbfce79aa807e6b2cb49ddfffb2847f191045922" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse sine. Otherwise, the inverse sine is determined by using &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;sqrt&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_2&quot;&gt;[AH16_2]&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 대칭 또는 에르 미트, 그 eigendecomposition ( &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; ) 역 사인을 계산하는 데 사용된다. 그렇지 않으면, 역 사인은 &lt;code&gt;log&lt;/code&gt; 및 &lt;code&gt;sqrt&lt;/code&gt; 를 사용하여 결정됩니다 . 이 함수를 계산하는 데 사용되는 이론 및 로그 공식은 &lt;a href=&quot;#footnote-AH16_2&quot;&gt;[AH16_2]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2646487106f321c98004368d4fc3670f47b0a86e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse tangent. Otherwise, the inverse tangent is determined by using &lt;code&gt;log&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_3&quot;&gt;[AH16_3]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 가 대칭이거나 허미 시안 인 경우 &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; 분해 ( eigen )가 역 탄젠트를 계산하는 데 사용됩니다. 그렇지 않으면 역 탄젠트는 &lt;code&gt;log&lt;/code&gt; 를 사용하여 결정됩니다 . 이 함수를 계산하는 데 사용되는 이론 및 로그 공식에 대해서는 &lt;a href=&quot;#footnote-AH16_3&quot;&gt;[AH16_3]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="317ce8e704df5d75a6762d7ee94cb8590a0eeb84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the sine. Otherwise, the sine is determined by calling &lt;code&gt;exp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 가 대칭이거나 허미 시안 인 경우 &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; 분해 ( eigen )가 사인을 계산하는 데 사용됩니다. 그렇지 않으면, 사인은 호출에 의해 결정된다 &lt;code&gt;exp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f03ca25824d588274952404db5eb47ba9feeba8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the square root. Otherwise, the square root is determined by means of the Bj&amp;ouml;rck-Hammarling method &lt;a href=&quot;#footnote-BH83&quot;&gt;[BH83]&lt;/a&gt;, which computes the complex Schur form (&lt;a href=&quot;#LinearAlgebra.schur&quot;&gt;&lt;code&gt;schur&lt;/code&gt;&lt;/a&gt;) and then the complex square root of the triangular factor.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 가 대칭이거나 허미 시안 인 경우 &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; 분해 ( eigen )가 제곱근을 계산하는 데 사용됩니다. 그렇지 않으면, 제곱근은 &lt;a href=&quot;#footnote-BH83&quot;&gt;Bj&amp;ouml;rck&lt;/a&gt; -Hammarling 방법 [BH83]에 의해 결정되는데 ,이 방법 은 복소수 Schur 형식 ( &lt;a href=&quot;#LinearAlgebra.schur&quot;&gt; &lt;code&gt;schur&lt;/code&gt; &lt;/a&gt; )과 삼각 계수의 복소수 제곱근을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="da6d9fe794edc15bdf1db668291afd8d8cb893d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the tangent. Otherwise, the tangent is determined by calling &lt;code&gt;exp&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 대칭 또는 에르 미트, 그 eigendecomposition ( &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; ) 탄젠트를 계산하기 위해 사용된다. 그렇지 않으면 접선은 &lt;code&gt;exp&lt;/code&gt; 를 호출하여 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="e82ebcef54c304de01d1461f11b56325e46b2234" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used, if &lt;code&gt;A&lt;/code&gt; is triangular an improved version of the inverse scaling and squaring method is employed (see &lt;a href=&quot;#footnote-AH12&quot;&gt;[AH12]&lt;/a&gt; and &lt;a href=&quot;#footnote-AHR13&quot;&gt;[AHR13]&lt;/a&gt;). For general matrices, the complex Schur form (&lt;a href=&quot;#LinearAlgebra.schur&quot;&gt;&lt;code&gt;schur&lt;/code&gt;&lt;/a&gt;) is computed and the triangular algorithm is used on the triangular factor.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 대칭 또는 에르 미트, 그 eigendecomposition ( &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; 경우) 사용되는 &lt;code&gt;A&lt;/code&gt; 상기 역 스케일링의 개선 된 버전이 삼각형이고 제곱 법이 이용된다 ( &lt;a href=&quot;#footnote-AH12&quot;&gt;[AH12]&lt;/a&gt; 및 &lt;a href=&quot;#footnote-AHR13&quot;&gt;[AHR13]&lt;/a&gt; ). 일반 행렬의 경우 복잡한 Schur 형식 ( &lt;a href=&quot;#LinearAlgebra.schur&quot;&gt; &lt;code&gt;schur&lt;/code&gt; &lt;/a&gt; )이 계산되고 삼각 알고리즘이 삼각 요인에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="31effe06eb8010b919cfa614d0573384a4c26bdc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DataType&lt;/code&gt;&lt;code&gt;T&lt;/code&gt; does not have a specific size, an error is thrown.</source>
          <target state="translated">경우 &lt;code&gt;DataType&lt;/code&gt; &lt;code&gt;T&lt;/code&gt; 가 특정 크기가없는 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="70ac2f54db074364d37a4067713ee52ebafa3e4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;I_1&lt;/code&gt; is changed to a two-dimensional matrix, then &lt;code&gt;X&lt;/code&gt; becomes an &lt;code&gt;n+1&lt;/code&gt;-dimensional array of shape &lt;code&gt;(size(I_1, 1), size(I_1, 2), length(I_2), ..., length(I_n))&lt;/code&gt;. The matrix adds a dimension.</source>
          <target state="translated">경우 &lt;code&gt;I_1&lt;/code&gt; 가 이차원 행렬로 변경 한 다음 &lt;code&gt;X&lt;/code&gt; 는 하게 &lt;code&gt;n+1&lt;/code&gt; 형상 차원 어레이 &lt;code&gt;(size(I_1, 1), size(I_1, 2), length(I_2), ..., length(I_n))&lt;/code&gt; . 행렬이 차원을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="20d018b41d67fa72dfd3dd7eab414a34042d26fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Any&lt;/code&gt;, then the memory is assumed to contain a reference to a Julia object (a &lt;code&gt;jl_value_t*&lt;/code&gt;), the result will be a reference to this object, and the object will not be copied. You must be careful in this case to ensure that the object was always visible to the garbage collector (pointers do not count, but the new reference does) to ensure the memory is not prematurely freed. Note that if the object was not originally allocated by Julia, the new object will never be finalized by Julia's garbage collector. If the &lt;code&gt;Ptr&lt;/code&gt; itself is actually a &lt;code&gt;jl_value_t*&lt;/code&gt;, it can be converted back to a Julia object reference by &lt;a href=&quot;../../base/c/index#Base.unsafe_pointer_to_objref&quot;&gt;&lt;code&gt;unsafe_pointer_to_objref(ptr)&lt;/code&gt;&lt;/a&gt;. (Julia values &lt;code&gt;v&lt;/code&gt; can be converted to &lt;code&gt;jl_value_t*&lt;/code&gt; pointers, as &lt;code&gt;Ptr{Cvoid}&lt;/code&gt;, by calling &lt;a href=&quot;../../base/c/index#Base.pointer_from_objref&quot;&gt;&lt;code&gt;pointer_from_objref(v)&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 이다 &lt;code&gt;Any&lt;/code&gt; 후 메모리는 줄리아 객체 (참조 포함하는 것으로한다 &lt;code&gt;jl_value_t*&lt;/code&gt; , 그 결과가이 객체에 대한 참조가있을 것이다), 그리고 물체가 복사되지 않을 것이다. 이 경우 메모리가 조기에 해제되지 않도록 오브젝트가 가비지 콜렉터 (포인터는 계산하지 않지만 새 참조는 참조)에 항상 표시되도록주의해야합니다. Julia가 객체를 원래 할당하지 않은 경우 Julia의 가비지 수집기가 새 객체를 완성하지 않습니다. 상기 중간 &lt;code&gt;Ptr&lt;/code&gt; 자체가 실제로 &lt;code&gt;jl_value_t*&lt;/code&gt; , 그것이 의해 줄리아 객체 참조로 변환 돌아올 수 &lt;a href=&quot;../../base/c/index#Base.unsafe_pointer_to_objref&quot;&gt; &lt;code&gt;unsafe_pointer_to_objref(ptr)&lt;/code&gt; &lt;/a&gt; . (줄리아 값 &lt;code&gt;v&lt;/code&gt; &lt;a href=&quot;../../base/c/index#Base.pointer_from_objref&quot;&gt; &lt;code&gt;pointer_from_objref(v)&lt;/code&gt; &lt;/a&gt; 호출 하여 &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; 로 &lt;code&gt;jl_value_t*&lt;/code&gt; 포인터 로 변환 될 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="51788d4fcfdfd4d39c958952b0bc0324310a6a5f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../numbers/index#Core.AbstractFloat&quot;&gt;&lt;code&gt;AbstractFloat&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; type, then it will return the closest value to &lt;code&gt;x&lt;/code&gt; representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 A는 &lt;a href=&quot;../numbers/index#Core.AbstractFloat&quot;&gt; &lt;code&gt;AbstractFloat&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt; 유형, 그것은 가장 가까운 값을 반환합니다 &lt;code&gt;x&lt;/code&gt; 의해 표현할 수를 &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dedc994cd3fc0835ff4382a890fe92f16cb71d37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a collection type and &lt;code&gt;x&lt;/code&gt; a collection, the result of &lt;code&gt;convert(T, x)&lt;/code&gt; may alias all or part of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 컬렉션 타입과 &lt;code&gt;x&lt;/code&gt; 모음의 결과 &lt;code&gt;convert(T, x)&lt;/code&gt; 수있는 모든 별칭 또는 일부 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca5b35227b72b028ed45253536f1af95a0b6efba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a floating-point type, the result is the nearest representable value, which could be positive or negative infinity.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 부동 소수점 타입이고, 결과는 양 또는 음의 무한대가 될 수있는 가장 가까운 값을 표현할 수있다.</target>
        </trans-unit>
        <trans-unit id="4201a0a82cce066dea7c824bdf90b57c195e9972" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a numeric type, the result is an array of that type, with any non-numeric elements as &lt;code&gt;NaN&lt;/code&gt; for floating-point types, or zero. Other useful values of &lt;code&gt;T&lt;/code&gt; include &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;AbstractString&lt;/code&gt;, and &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 숫자 입력이되면, 그 결과는 숫자가 아닌 요소 유형의 배열이다 &lt;code&gt;NaN&lt;/code&gt; 이 부동 소수점 형식, 또는 제로 대. 다른 유용한 &lt;code&gt;T&lt;/code&gt; 값으로 는 &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;AbstractString&lt;/code&gt; 및 &lt;code&gt;Any&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="69fee994b4c0ef137b6453b3ceac4a68a22fb0fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;../numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt; type, an &lt;a href=&quot;#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt; will be raised if &lt;code&gt;x&lt;/code&gt; is not representable by &lt;code&gt;T&lt;/code&gt;, for example if &lt;code&gt;x&lt;/code&gt; is not integer-valued, or is outside the range supported by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 인 &lt;a href=&quot;../numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt; 타입 &lt;a href=&quot;#Core.InexactError&quot;&gt; &lt;code&gt;InexactError&lt;/code&gt; 는&lt;/a&gt; 경우 발생한다 &lt;code&gt;x&lt;/code&gt; 로 표현할 수없는 &lt;code&gt;T&lt;/code&gt; 경우, 예를 들어, &lt;code&gt;x&lt;/code&gt; 없는 정수 값이거나 외부에서 지원하는 범위 &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c36ac776e4be839ff56e17825105904e00568128" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an integer type, an &lt;code&gt;InexactError&lt;/code&gt; is raised if &lt;code&gt;x&lt;/code&gt; is not representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 정수 타입, &lt;code&gt;InexactError&lt;/code&gt; 는 경우 발생 &lt;code&gt;x&lt;/code&gt; 는 로 표현할 수없는 것입니다 &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7762b87399cdbea094b67bb56bb79bce4032130" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X/Project.toml&lt;/code&gt; exists and but does &lt;em&gt;not&lt;/em&gt; have a top-level UUID entry, &lt;code&gt;uuid&lt;/code&gt; is a dummy UUID generated by hashing the canonical (real) path to &lt;code&gt;X/Project.toml&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;X/Project.toml&lt;/code&gt; 가 존재하지만 않습니다 &lt;em&gt;하지&lt;/em&gt; 최상위 UUID 항목이, &lt;code&gt;uuid&lt;/code&gt; 하는 더미 UUID에 정식 (실제) 경로 해시에 의해 생성 된 &lt;code&gt;X/Project.toml&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="57feda5962ebeb025a02c2fc5115db7f5ee74658" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X/Project.toml&lt;/code&gt; exists and has a &lt;code&gt;uuid&lt;/code&gt; entry, then &lt;code&gt;uuid&lt;/code&gt; is that value.</source>
          <target state="translated">경우 &lt;code&gt;X/Project.toml&lt;/code&gt; 가 존재하고있다 &lt;code&gt;uuid&lt;/code&gt; 항목을 다음 &lt;code&gt;uuid&lt;/code&gt; 그 값입니다.</target>
        </trans-unit>
        <trans-unit id="6feb00535e98202cbe0e255e2cd1a8e59544d667" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;all&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; (the default), this function will block repeatedly trying to read all requested bytes, until an error or end-of-file occurs. If &lt;code&gt;all&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, at most one &lt;code&gt;read&lt;/code&gt; call is performed, and the amount of data returned is device-dependent. Note that not all stream types support the &lt;code&gt;all&lt;/code&gt; option.</source>
          <target state="translated">경우 &lt;code&gt;all&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; (기본값) 오류 또는 파일의 끝이 발생할 때까지,이 기능은, 요청 된 모든 바이트를 읽으려고 반복적으로 차단합니다. &lt;code&gt;all&lt;/code&gt; 이 &lt;code&gt;false&lt;/code&gt; 인 경우 최대 하나의 &lt;code&gt;read&lt;/code&gt; 호출이 수행되고 반환되는 데이터의 양은 장치에 따라 다릅니다. 모든 스트림 유형이 &lt;code&gt;all&lt;/code&gt; 옵션을 지원하지는 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7b3a53d050caeb89134ca9bb80d1091ff36a0cf4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b&lt;/code&gt; is a power of 2 or 10, &lt;a href=&quot;#Base.log2&quot;&gt;&lt;code&gt;log2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.log10&quot;&gt;&lt;code&gt;log10&lt;/code&gt;&lt;/a&gt; should be used, as these will typically be faster and more accurate. For example,</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; 가 2 또는 10의 거듭 제곱 이면 일반적으로 더 빠르고 정확하므로 &lt;a href=&quot;#Base.log2&quot;&gt; &lt;code&gt;log2&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#Base.log10&quot;&gt; &lt;code&gt;log10&lt;/code&gt; 을&lt;/a&gt; 사용해야합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="89b9fac160344d84b2e97547e3cbb9b2dd975a11" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;batch_size&lt;/code&gt; is specified, the collection is processed in batch mode. &lt;code&gt;f&lt;/code&gt; must then be a function that must accept a &lt;code&gt;Vector&lt;/code&gt; of argument tuples and must return a vector of results. The input vector will have a length of &lt;code&gt;batch_size&lt;/code&gt; or less.</source>
          <target state="translated">경우 &lt;code&gt;batch_size&lt;/code&gt; 지정되면, 수집 배치 모드로 처리된다. &lt;code&gt;f&lt;/code&gt; 는 인수 튜플 의 &lt;code&gt;Vector&lt;/code&gt; 를 허용하고 결과 벡터를 반환 해야하는 함수 여야합니다 . 입력 벡터의 길이는 &lt;code&gt;batch_size&lt;/code&gt; 이하입니다.</target>
        </trans-unit>
        <trans-unit id="f2467dc77e236fb9b24d515beabeb30ab9b34314" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dims&lt;/code&gt; is a tuple, the order of the dimensions in &lt;code&gt;dims&lt;/code&gt; is relevant and specifies the linear order of the slices. E.g., if &lt;code&gt;A&lt;/code&gt; is three dimensional and &lt;code&gt;dims&lt;/code&gt; is &lt;code&gt;(1, 2)&lt;/code&gt;, the orderings of the first two dimensions are re-arranged such such that the slices (of the remaining third dimension) are sorted. If &lt;code&gt;dims&lt;/code&gt; is &lt;code&gt;(2, 1)&lt;/code&gt; instead, the same slices will be taken, but the result order will be row-major instead.</source>
          <target state="translated">경우에 &lt;code&gt;dims&lt;/code&gt; 튜플이다의 크기의 순서 &lt;code&gt;dims&lt;/code&gt; 관련성 및 슬라이스 선형 순서를 지정한다. 예를 들어, &lt;code&gt;A&lt;/code&gt; 가 3 차원이고 &lt;code&gt;dims&lt;/code&gt; 이 &lt;code&gt;(1, 2)&lt;/code&gt; 이면, 나머지 2 차원의 슬라이스가 정렬되도록 처음 2 차원의 순서가 재 배열됩니다. 경우에 &lt;code&gt;dims&lt;/code&gt; 인 &lt;code&gt;(2, 1)&lt;/code&gt; 대신에, 동일한 슬라이스 촬영되지만 결과 순서 대신 행 중요한 것이다.</target>
        </trans-unit>
        <trans-unit id="74fad15bfd2101b3b16f9ea74a15c93af724d1dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dlm&lt;/code&gt; is omitted, it defaults to &lt;a href=&quot;#Base.Unicode.isspace&quot;&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;dlm&lt;/code&gt; , 디폴트 생략합니다 &lt;a href=&quot;#Base.Unicode.isspace&quot;&gt; &lt;code&gt;isspace&lt;/code&gt; 와&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7d7429e0d71b847a07568d302028712dbaf31f03" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;factorize&lt;/code&gt; is called on a Hermitian positive-definite matrix, for instance, then &lt;code&gt;factorize&lt;/code&gt; will return a Cholesky factorization.</source>
          <target state="translated">경우 &lt;code&gt;factorize&lt;/code&gt; 에르 미트 정부 호 행렬에라고, 예를 들어, 다음 &lt;code&gt;factorize&lt;/code&gt; 촐레 인수 분해를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b7c73e768a4a1fc2665ff51aa066980c89d3ec1f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;follow_symlinks=false&lt;/code&gt;, and &lt;code&gt;src&lt;/code&gt; is a symbolic link, &lt;code&gt;dst&lt;/code&gt; will be created as a symbolic link. If &lt;code&gt;follow_symlinks=true&lt;/code&gt; and &lt;code&gt;src&lt;/code&gt; is a symbolic link, &lt;code&gt;dst&lt;/code&gt; will be a copy of the file or directory &lt;code&gt;src&lt;/code&gt; refers to. Return &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;follow_symlinks=false&lt;/code&gt; , 그리고 &lt;code&gt;src&lt;/code&gt; 심볼릭 링크이며, &lt;code&gt;dst&lt;/code&gt; 심볼릭 링크로 생성됩니다. 경우 &lt;code&gt;follow_symlinks=true&lt;/code&gt; 과 &lt;code&gt;src&lt;/code&gt; 심볼릭 링크이며, &lt;code&gt;dst&lt;/code&gt; 파일이나 디렉토리의 사본이 될 것 &lt;code&gt;src&lt;/code&gt; 를 말합니다. &lt;code&gt;dst&lt;/code&gt; 를 돌려 줍니다.</target>
        </trans-unit>
        <trans-unit id="0fefe7c70552bb288eba8725570e0711eb9913bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;full = false&lt;/code&gt; (default), a &quot;thin&quot; SVD is returned. For a $M \times N$ matrix &lt;code&gt;A&lt;/code&gt;, in the full factorization &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;M \times M&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;N \times N&lt;/code&gt;, while in the thin factorization &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;M \times K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;N \times K&lt;/code&gt;, where &lt;code&gt;K = \min(M,N)&lt;/code&gt; is the number of singular values.</source>
          <target state="translated">경우 &lt;code&gt;full = false&lt;/code&gt; (기본)는 &quot;얇은&quot;SVD가 반환됩니다. US $ M \ 시간 N $ 매트릭스 들어 전체 분해에 &lt;code&gt;U&lt;/code&gt; 가 있다 &lt;code&gt;M \times M&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 가 인 &lt;code&gt;N \times N&lt;/code&gt; 얇은 인수에있는 동안, &lt;code&gt;U&lt;/code&gt; 가 있다 &lt;code&gt;M \times K&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 가 인 &lt;code&gt;N \times K&lt;/code&gt; , 여기서 &lt;code&gt;K = \min(M,N)&lt;/code&gt; 은 특이 값의 개수입니다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7087620ad88bc806c680dac427ffd57a67879dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fussy_sqrt&lt;/code&gt; is called with a negative value from another function, instead of trying to continue execution of the calling function, it returns immediately, displaying the error message in the interactive session:</source>
          <target state="translated">만약 &lt;code&gt;fussy_sqrt&lt;/code&gt; 는 대신 호출 기능, 그것은 대화 형 세션에서 오류 메시지를 표시, 즉시 반환의 실행을 계속하기 위해 노력하는, 다른 함수에서 음의 값으로 호출됩니다</target>
        </trans-unit>
        <trans-unit id="c19e0b85728fe9481b7abf51cbb032dc0e45287a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;generated&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the returned &lt;code&gt;CodeInfo&lt;/code&gt; instances will correspond to fallback implementations. An error is thrown if no fallback implementation exists. If &lt;code&gt;generated&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, these &lt;code&gt;CodeInfo&lt;/code&gt; instances will correspond to the method bodies yielded by expanding the generators.</source>
          <target state="translated">경우 &lt;code&gt;generated&lt;/code&gt; 입니다 &lt;code&gt;false&lt;/code&gt; , 반환 &lt;code&gt;CodeInfo&lt;/code&gt; 의 인스턴스 구현을 폴백 (fallback)에 해당됩니다. 폴백 구현이 없으면 오류가 발생합니다. 경우 &lt;code&gt;generated&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; , 이러한 &lt;code&gt;CodeInfo&lt;/code&gt; 의 인스턴스는 발전기를 확장하여 산출 방법 기관에 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="3b5b7e505ab23a5d0aa601628f61af1433ebc0f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;header&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the first row of data will be read as header and the tuple &lt;code&gt;(data_cells, header_cells)&lt;/code&gt; is returned instead of only &lt;code&gt;data_cells&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;header&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; , 데이터의 첫 번째 행은 헤더와 튜플로 읽을 수 있습니다 &lt;code&gt;(data_cells, header_cells)&lt;/code&gt; 대신 단지의 반환 &lt;code&gt;data_cells&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c950181a2a1658a2e38c89bd49475efe3e66e317" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;i&lt;/code&gt; is in bounds in &lt;code&gt;s&lt;/code&gt; return the index of the start of the character whose encoding code unit &lt;code&gt;i&lt;/code&gt; is part of. In other words, if &lt;code&gt;i&lt;/code&gt; is the start of a character, return &lt;code&gt;i&lt;/code&gt;; if &lt;code&gt;i&lt;/code&gt; is not the start of a character, rewind until the start of a character and return that index. If &lt;code&gt;i&lt;/code&gt; is equal to 0 or &lt;code&gt;ncodeunits(s)+1&lt;/code&gt; return &lt;code&gt;i&lt;/code&gt;. In all other cases throw &lt;code&gt;BoundsError&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; 가 &lt;code&gt;s&lt;/code&gt; 안에있는 경우 인코딩 코드 단위 &lt;code&gt;i&lt;/code&gt; 가 포함 된 문자의 시작 색인을 반환합니다 . 경우 즉, &lt;code&gt;i&lt;/code&gt; 문자의 시작이다, 반환 &lt;code&gt;i&lt;/code&gt; ; &lt;code&gt;i&lt;/code&gt; 가 문자의 시작이 아닌 경우 문자의 시작까지 되 감고 해당 색인을 리턴하십시오. 경우 &lt;code&gt;i&lt;/code&gt; 가 0과 동일 &lt;code&gt;ncodeunits(s)+1&lt;/code&gt; 복귀 &lt;code&gt;i&lt;/code&gt; . 다른 모든 경우에는 &lt;code&gt;BoundsError&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="ed8634de2b332fe1583659d48b66208896196beb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;i&lt;/code&gt; is in bounds in &lt;code&gt;s&lt;/code&gt; return the index of the start of the character whose encoding starts after index &lt;code&gt;i&lt;/code&gt;. In other words, if &lt;code&gt;i&lt;/code&gt; is the start of a character, return the start of the next character; if &lt;code&gt;i&lt;/code&gt; is not the start of a character, move forward until the start of a character and return that index. If &lt;code&gt;i&lt;/code&gt; is equal to &lt;code&gt;0&lt;/code&gt; return &lt;code&gt;1&lt;/code&gt;. If &lt;code&gt;i&lt;/code&gt; is in bounds but greater or equal to &lt;code&gt;lastindex(str)&lt;/code&gt; return &lt;code&gt;ncodeunits(str)+1&lt;/code&gt;. Otherwise throw &lt;code&gt;BoundsError&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; 가 &lt;code&gt;s&lt;/code&gt; 의 범위 안에 있으면 인덱스 &lt;code&gt;i&lt;/code&gt; 다음에 인코딩이 시작되는 문자의 시작 인덱스를 반환합니다 . 즉, &lt;code&gt;i&lt;/code&gt; 가 문자의 시작 인 경우 다음 문자의 시작을 반환합니다. &lt;code&gt;i&lt;/code&gt; 가 문자의 시작이 아닌 경우 문자의 시작까지 앞으로 이동하여 해당 색인을 리턴하십시오. 경우 &lt;code&gt;i&lt;/code&gt; 동일하다 &lt;code&gt;0&lt;/code&gt; 복귀 &lt;code&gt;1&lt;/code&gt; . 경우 &lt;code&gt;i&lt;/code&gt; 범위에 있지만 크거나 같 &lt;code&gt;lastindex(str)&lt;/code&gt; 복귀 &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;BoundsError&lt;/code&gt; 을 던집니다 .</target>
        </trans-unit>
        <trans-unit id="5bcc465fac95b41229c6fb79ecf0d3dab69e75e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;i&lt;/code&gt; is in bounds in &lt;code&gt;s&lt;/code&gt; return the index of the start of the character whose encoding starts before index &lt;code&gt;i&lt;/code&gt;. In other words, if &lt;code&gt;i&lt;/code&gt; is the start of a character, return the start of the previous character; if &lt;code&gt;i&lt;/code&gt; is not the start of a character, rewind until the start of a character and return that index. If &lt;code&gt;i&lt;/code&gt; is equal to &lt;code&gt;1&lt;/code&gt; return &lt;code&gt;0&lt;/code&gt;. If &lt;code&gt;i&lt;/code&gt; is equal to &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; return &lt;code&gt;lastindex(str)&lt;/code&gt;. Otherwise throw &lt;code&gt;BoundsError&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; 가 &lt;code&gt;s&lt;/code&gt; 의 범위 안에 있으면 인덱스 &lt;code&gt;i&lt;/code&gt; 보다 먼저 인코딩이 시작되는 문자의 시작 인덱스를 반환합니다 . 즉, &lt;code&gt;i&lt;/code&gt; 가 문자의 시작 인 경우 이전 문자의 시작을 반환합니다. &lt;code&gt;i&lt;/code&gt; 가 문자의 시작이 아닌 경우 문자의 시작까지 되 감고 해당 색인을 리턴하십시오. 경우 &lt;code&gt;i&lt;/code&gt; 동일하다 &lt;code&gt;1&lt;/code&gt; 명 복귀 &lt;code&gt;0&lt;/code&gt; . 경우 &lt;code&gt;i&lt;/code&gt; 동일하다 &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; 복귀 &lt;code&gt;lastindex(str)&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;BoundsError&lt;/code&gt; 을 던집니다 .</target>
        </trans-unit>
        <trans-unit id="3cfff02ba2ab7ab8f47553333086d7d3b017d4eb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;io&lt;/code&gt; is not specified, &lt;code&gt;host&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; are used to connect.</source>
          <target state="translated">경우 &lt;code&gt;io&lt;/code&gt; 지정되지 않은, &lt;code&gt;host&lt;/code&gt; 및 &lt;code&gt;port&lt;/code&gt; 연결하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="675d2f45d06133423691ac8939a36ff3793bfbd0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;io&lt;/code&gt; is specified, it is used to read host/port information. A Julia worker prints out its bind address and port at startup. This allows Julia workers to listen on any free port available instead of requiring worker ports to be configured manually.</source>
          <target state="translated">경우 &lt;code&gt;io&lt;/code&gt; 지정되어, 호스트 / 포트 정보를 읽는 데 사용됩니다. Julia 작업자는 시작시 바인드 주소와 포트를 인쇄합니다. 이를 통해 Julia 작업자는 작업자 포트를 수동으로 구성 할 필요없이 사용 가능한 모든 포트에서 청취 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23c03ff245d9cf669803a913ec063d9d852e916b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;irange&lt;/code&gt; is not &lt;code&gt;1:n&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the dimension of &lt;code&gt;A&lt;/code&gt;, then the returned factorization will be a &lt;em&gt;truncated&lt;/em&gt; factorization.</source>
          <target state="translated">&lt;code&gt;irange&lt;/code&gt; 가 &lt;code&gt;1:n&lt;/code&gt; 이 아닌 경우 , 여기서 &lt;code&gt;n&lt;/code&gt; 은 &lt;code&gt;A&lt;/code&gt; 의 차원 인 경우 반환 된 인수 분해는 &lt;em&gt;잘린&lt;/em&gt; 인수 분해입니다.</target>
        </trans-unit>
        <trans-unit id="33bb6515a9488e11cd97387cfe2fdf0354f00b17" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isless(x, y)&lt;/code&gt; is defined, then so is &lt;code&gt;isless(y, x)&lt;/code&gt; and &lt;code&gt;isequal(x, y)&lt;/code&gt;, and exactly one of those three yields &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;isless(x, y)&lt;/code&gt; 정의하고 그렇다 &lt;code&gt;isless(y, x)&lt;/code&gt; 과 &lt;code&gt;isequal(x, y)&lt;/code&gt; 및 그 세 수율 정확히 한 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27bcd4132639e391333ba702df2bbfcfeb96c942" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, the result is also &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;missing&lt;/code&gt; (&lt;code&gt;missing&lt;/code&gt; takes precedence if &lt;code&gt;itr&lt;/code&gt; contains both). Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the median of non-missing values.</source>
          <target state="translated">경우 &lt;code&gt;itr&lt;/code&gt; 포함 &lt;code&gt;NaN&lt;/code&gt; 이 또는 &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 값을 결과도 &lt;code&gt;NaN&lt;/code&gt; 이 또는 &lt;code&gt;missing&lt;/code&gt; ( &lt;code&gt;missing&lt;/code&gt; 경우에 우선한다 &lt;code&gt;itr&lt;/code&gt; 모두 포함). 생략 &lt;code&gt;missing&lt;/code&gt; 함수를 사용하여 누락 된 항목 을 생략 하고 &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt; 의 중앙값을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="c3e083f5fc9364992337e03964ee084acea5fae6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, the result is also &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;missing&lt;/code&gt; (&lt;code&gt;missing&lt;/code&gt; takes precedence if array contains both). Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the mean of non-missing values.</source>
          <target state="translated">경우 &lt;code&gt;itr&lt;/code&gt; 포함 &lt;code&gt;NaN&lt;/code&gt; 이 또는 &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 값을 결과도 &lt;code&gt;NaN&lt;/code&gt; 이 또는 &lt;code&gt;missing&lt;/code&gt; ( &lt;code&gt;missing&lt;/code&gt; 어레이 모두를 포함하는 경우 우선). 생략 &lt;code&gt;missing&lt;/code&gt; 함수를 사용하여 누락 된 항목 을 생략 하고 &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt; 의 평균을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="6474b35658d7c26eeead842892ada1aea0d886f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the standard deviation over dimensions, and &lt;code&gt;m&lt;/code&gt; may contain means for each dimension of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;itr&lt;/code&gt; 이다 &lt;code&gt;AbstractArray&lt;/code&gt; , &lt;code&gt;dims&lt;/code&gt; 치수 이상의 표준 편차를 계산하기 위해 제공 될 수 있고, &lt;code&gt;m&lt;/code&gt; 은 각 측정하기위한 수단을 포함 할 수있다 &lt;code&gt;itr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51822a7fae2f9177cdbe8acba291b2ecbdaf5a84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the standard deviation over dimensions, and &lt;code&gt;means&lt;/code&gt; may contain means for each dimension of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;itr&lt;/code&gt; 이다 &lt;code&gt;AbstractArray&lt;/code&gt; , &lt;code&gt;dims&lt;/code&gt; 치수 이상의 표준 편차를 계산하기 위해 제공 될 수 있고, &lt;code&gt;means&lt;/code&gt; 각 측정 수단 포함될 수 &lt;code&gt;itr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="faf5ec759432f757b892cc486fe0509d46288036" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the variance over dimensions, and &lt;code&gt;m&lt;/code&gt; may contain means for each dimension of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;itr&lt;/code&gt; 이다 &lt;code&gt;AbstractArray&lt;/code&gt; , &lt;code&gt;dims&lt;/code&gt; 치수 이상 분산을 계산하기 위해 제공 될 수 있고, &lt;code&gt;m&lt;/code&gt; 은 각 측정 수단 포함될 수 &lt;code&gt;itr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37d953297aa88c0f3bc07a3115b3b34627aebd03" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the variance over dimensions, and &lt;code&gt;mean&lt;/code&gt; may contain means for each dimension of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;itr&lt;/code&gt; 이다 &lt;code&gt;AbstractArray&lt;/code&gt; , &lt;code&gt;dims&lt;/code&gt; 치수 이상 분산을 산출하고 제공 할 수 &lt;code&gt;mean&lt;/code&gt; 각 측정 수단 포함될 수 &lt;code&gt;itr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c5a74c045541a90c529fb0859ca2583588298de" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;length&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are provided and &lt;code&gt;step&lt;/code&gt; is not, the step size will be computed automatically such that there are &lt;code&gt;length&lt;/code&gt; linearly spaced elements in the range (a &lt;a href=&quot;../collections/index#Base.LinRange&quot;&gt;&lt;code&gt;LinRange&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">경우 &lt;code&gt;length&lt;/code&gt; 및 &lt;code&gt;stop&lt;/code&gt; 제공되고 &lt;code&gt;step&lt;/code&gt; 없고, 스텝 사이즈가 있다는 것을 자동적으로 계산한다 &lt;code&gt;length&lt;/code&gt; 선형 범위 (a에서 이격 요소 &lt;a href=&quot;../collections/index#Base.LinRange&quot;&gt; &lt;code&gt;LinRange&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0677161ec30784ce49b4b8aeda531d688c559665" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pids&lt;/code&gt; is left unspecified, the shared array will be mapped across all processes on the current host, including the master. But, &lt;code&gt;localindices&lt;/code&gt; and &lt;code&gt;indexpids&lt;/code&gt; will only refer to worker processes. This facilitates work distribution code to use workers for actual computation with the master process acting as a driver.</source>
          <target state="translated">경우 &lt;code&gt;pids&lt;/code&gt; 지정되지 않은 남아, 공유 배열은 마스터를 포함하여 현재 호스트의 모든 과정에 걸쳐 매핑됩니다. 그러나 &lt;code&gt;localindices&lt;/code&gt; 및 &lt;code&gt;indexpids&lt;/code&gt; 는 작업자 프로세스 만 참조합니다. 이를 통해 작업 분배 코드를 사용하여 작업자 역할을하는 마스터 프로세스로 실제 계산에 작업자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39265b02d633cf948cee760fccd02e8e4c595e22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;quotes&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, columns enclosed within double-quote (&quot;) characters are allowed to contain new lines and column delimiters. Double-quote characters within a quoted field must be escaped with another double-quote. Specifying &lt;code&gt;dims&lt;/code&gt; as a tuple of the expected rows and columns (including header, if any) may speed up reading of large files. If &lt;code&gt;comments&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, lines beginning with &lt;code&gt;comment_char&lt;/code&gt; and text following &lt;code&gt;comment_char&lt;/code&gt; in any line are ignored.</source>
          <target state="translated">경우 &lt;code&gt;quotes&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; , 열은 큰 따옴표로 묶여 ( &quot;) 문자가 새로운 라인과 열 구분 기호를 포함 할 수 있습니다. 따옴표 문자를 인용 필드 내에서 다른 따옴표로 이스케이프해야합니다. 지정 &lt;code&gt;dims&lt;/code&gt; 예상의 튜플로 행과 열 (있는 경우 헤더 포함)은 큰 파일을 빠르게 읽을 수 있습니다. &lt;code&gt;comments&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 이면 &lt;code&gt;comment_char&lt;/code&gt; 로 시작 하는 행과 모든 행에서 &lt;code&gt;comment_char&lt;/code&gt; 다음에 오는 텍스트 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="072d5e68fa14ef444211e0638bdf60961c940d9d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reuseaddr=true&lt;/code&gt;, multiple threads or processes can bind to the same address without error if they all set &lt;code&gt;reuseaddr=true&lt;/code&gt;, but only the last to bind will receive any traffic.</source>
          <target state="translated">경우 &lt;code&gt;reuseaddr=true&lt;/code&gt; , 다중 스레드 또는 프로세스가 오류없이 동일한 주소에 바인딩 할 수 있습니다 그들은 모두 설정된 경우 &lt;code&gt;reuseaddr=true&lt;/code&gt; 있지만 바인딩에 마지막으로 트래픽을 받게됩니다.</target>
        </trans-unit>
        <trans-unit id="5dd9d0433c4fe181d962946c85904ec68a57d1fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rook&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, rook pivoting is used. If &lt;code&gt;rook&lt;/code&gt; is false, rook pivoting is not used.</source>
          <target state="translated">경우 &lt;code&gt;rook&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; , 루크의 회전이 사용됩니다. 경우 &lt;code&gt;rook&lt;/code&gt; 거짓, 루크의 회전이 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3686d47af71436aa8068aa094e6acfdb577abbc8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipblanks&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, blank lines in the input will be ignored.</source>
          <target state="translated">경우 &lt;code&gt;skipblanks&lt;/code&gt; 이 있다 &lt;code&gt;true&lt;/code&gt; , 입력 빈 행은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a5a873983f34f90f6f3366d1e91c3b5438a1e6c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;step&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are provided and &lt;code&gt;length&lt;/code&gt; is not, the overall range length will be computed automatically such that the elements are &lt;code&gt;step&lt;/code&gt; spaced (a &lt;a href=&quot;../collections/index#Base.StepRange&quot;&gt;&lt;code&gt;StepRange&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">경우 &lt;code&gt;step&lt;/code&gt; 및 &lt;code&gt;stop&lt;/code&gt; 제공되는 &lt;code&gt;length&lt;/code&gt; 없고, 전체 길이 범위 요소임을 자동적으로 계산 될 것이다 &lt;code&gt;step&lt;/code&gt; 이격 (a &lt;a href=&quot;../collections/index#Base.StepRange&quot;&gt; &lt;code&gt;StepRange&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c1a52fdda97e9a9edb8d40a32fdbba7468a954c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;types&lt;/code&gt; is an abstract type, then the method that would be called by &lt;code&gt;invoke&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;types&lt;/code&gt; 추상적 인 유형, 다음에 의해 호출 될 메서드 &lt;code&gt;invoke&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f58b04b4e4485017440ce0c5de7416ee07070fe9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;types&lt;/code&gt; is specified, returns an array of methods whose types match.</source>
          <target state="translated">&lt;code&gt;types&lt;/code&gt; 이 지정 되면 유형 이 일치하는 메소드 배열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b3892fb415986ed95819205d489e6d5bbab6470a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;use_mmap&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the file specified by &lt;code&gt;source&lt;/code&gt; is memory mapped for potential speedups. Default is &lt;code&gt;true&lt;/code&gt; except on Windows. On Windows, you may want to specify &lt;code&gt;true&lt;/code&gt; if the file is large, and is only read once and not written to.</source>
          <target state="translated">경우 &lt;code&gt;use_mmap&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; 에 의해 지정된 파일 &lt;code&gt;source&lt;/code&gt; 잠재적 인 속도 향상을위한 매핑 된 메모리입니다. Windows를 제외하고 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다. Windows 에서 파일이 크고 한 번만 읽고 쓰지 않으면 &lt;code&gt;true&lt;/code&gt; 를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5645668108ab9880ec8d6ff07db8800e64be268c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;wait&lt;/code&gt; is false, the process runs asynchronously. You can later wait for it and check its exit status by calling &lt;code&gt;success&lt;/code&gt; on the returned process object.</source>
          <target state="translated">경우 &lt;code&gt;wait&lt;/code&gt; 거짓, 프로세스는 비동기 적으로 실행됩니다. 나중에 리턴 된 프로세스 오브젝트에서 &lt;code&gt;success&lt;/code&gt; 을 호출하여 대기하고 종료 상태를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4328d82bb88eefa0e600962ab951d3053ce804f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a number, this is essentially the same as &lt;code&gt;one(x)/x&lt;/code&gt;, but for some types &lt;code&gt;inv(x)&lt;/code&gt; may be slightly more efficient.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 숫자이고, 이는 본질적으로 동일하다 &lt;code&gt;one(x)/x&lt;/code&gt; , 그러나 어떤 유형에 대한 &lt;code&gt;inv(x)&lt;/code&gt; 이 약간 더 효율적일 수있다.</target>
        </trans-unit>
        <trans-unit id="5d6e97018433ee560ec26ad905f78e6763128a42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a type, return a &quot;larger&quot; type, defined so that arithmetic operations &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; are guaranteed not to overflow nor lose precision for any combination of values that type &lt;code&gt;x&lt;/code&gt; can hold.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 유형 인 경우 , 산술 연산 &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;-&lt;/code&gt; 가 &lt;code&gt;x&lt;/code&gt; 가 보유 할 수있는 모든 값 조합에 대해 오버플로나 정밀도 손실을 보장하지 않도록 정의 된 &quot;더 큰&quot;유형을 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="88ba7ee31764ff507d81e94f6a3b385c0be71e42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a value, it is converted to &lt;code&gt;widen(typeof(x))&lt;/code&gt;.</source>
          <target state="translated">경우에 &lt;code&gt;x&lt;/code&gt; 는 값이며, 이는 변환된다 &lt;code&gt;widen(typeof(x))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a828e6b72bb380836af54de218be15aa9ebea9db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is an object reference, all elements will refer to the same object. &lt;code&gt;fill(Foo(), dims)&lt;/code&gt; will return an array filled with the result of evaluating &lt;code&gt;Foo()&lt;/code&gt; once.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 개체 참조하고, 모든 요소가 동일한 객체를 참조한다. &lt;code&gt;fill(Foo(), dims)&lt;/code&gt; 는 &lt;code&gt;Foo()&lt;/code&gt; 평가 결과로 채워진 배열을 한 번 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="db317e66581e31b148fb1c68097906f9ec9dcecb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not an &lt;code&gt;AbstractArray&lt;/code&gt; but it supports &lt;code&gt;axes&lt;/code&gt;, indexing, and its type supports &lt;code&gt;ndims&lt;/code&gt;, then &lt;code&gt;broadcastable(::typeof(x))&lt;/code&gt; may be implemented to just return itself. Further, if &lt;code&gt;x&lt;/code&gt; defines its own &lt;a href=&quot;#Base.Broadcast.BroadcastStyle&quot;&gt;&lt;code&gt;BroadcastStyle&lt;/code&gt;&lt;/a&gt;, then it must define its &lt;code&gt;broadcastable&lt;/code&gt; method to return itself for the custom style to have any effect.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 는 하지 &lt;code&gt;AbstractArray&lt;/code&gt; 하지만 지원 &lt;code&gt;axes&lt;/code&gt; , 색인, 그 유형 지원의 &lt;code&gt;ndims&lt;/code&gt; 을 다음 &lt;code&gt;broadcastable(::typeof(x))&lt;/code&gt; 단지 자체를 반환하도록 구현 될 수 있습니다. 또한 &lt;code&gt;x&lt;/code&gt; 가 자체 &lt;a href=&quot;#Base.Broadcast.BroadcastStyle&quot;&gt; &lt;code&gt;BroadcastStyle&lt;/code&gt; 을&lt;/a&gt; 정의하는 경우 사용자 정의 스타일에 영향을 미치기 위해 자체 &lt;code&gt;broadcastable&lt;/code&gt; 메소드를 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ead093ec45b992f54a438f256340d7b0a0ef7df6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; supports iteration, the returned value should have the same &lt;code&gt;axes&lt;/code&gt; and indexing behaviors as &lt;code&gt;collect(x)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 반복을 지원하는 경우 반환 된 값은 &lt;code&gt;collect(x)&lt;/code&gt; 와 동일한 &lt;code&gt;axes&lt;/code&gt; 및 인덱싱 동작을 가져야합니다 .</target>
        </trans-unit>
        <trans-unit id="9eb6d4efdb2a84932dc930c8197ad4f7fad62394" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is an &lt;code&gt;Int&lt;/code&gt; literal (e.g. &lt;code&gt;2&lt;/code&gt; in &lt;code&gt;x^2&lt;/code&gt; or &lt;code&gt;-3&lt;/code&gt; in &lt;code&gt;x^-3&lt;/code&gt;), the Julia code &lt;code&gt;x^y&lt;/code&gt; is transformed by the compiler to &lt;code&gt;Base.literal_pow(^, x, Val(y))&lt;/code&gt;, to enable compile-time specialization on the value of the exponent. (As a default fallback we have &lt;code&gt;Base.literal_pow(^, x, Val(y)) = ^(x,y)&lt;/code&gt;, where usually &lt;code&gt;^ == Base.^&lt;/code&gt; unless &lt;code&gt;^&lt;/code&gt; has been defined in the calling namespace.)</source>
          <target state="translated">경우 &lt;code&gt;y&lt;/code&gt; 이고 &lt;code&gt;Int&lt;/code&gt; 문자 (예 &lt;code&gt;2&lt;/code&gt; 에서 &lt;code&gt;x^2&lt;/code&gt; 또는 &lt;code&gt;-3&lt;/code&gt; 에서 &lt;code&gt;x^-3&lt;/code&gt; ) 줄리아 코드 &lt;code&gt;x^y&lt;/code&gt; 컴파일러로 변환 &lt;code&gt;Base.literal_pow(^, x, Val(y))&lt;/code&gt; 에 지수 값에 대해 컴파일 타임 전문화를 활성화합니다. (기본 폴백으로 &lt;code&gt;Base.literal_pow(^, x, Val(y)) = ^(x,y)&lt;/code&gt; . 여기서 &lt;code&gt;^&lt;/code&gt; 는 호출 네임 스페이스에 정의 되지 않은 경우 일반적으로 &lt;code&gt;^ == Base.^&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4030642b9b0fac77c474cfa27dc2012de7dca7c4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;yes&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, subsequent floating-point operations follow rules for IEEE arithmetic on subnormal values (&quot;denormals&quot;). Otherwise, floating-point operations are permitted (but not required) to convert subnormal inputs or outputs to zero. Returns &lt;code&gt;true&lt;/code&gt; unless &lt;code&gt;yes==true&lt;/code&gt; but the hardware does not support zeroing of subnormal numbers.</source>
          <target state="translated">경우 &lt;code&gt;yes&lt;/code&gt; 인 &lt;code&gt;false&lt;/code&gt; , 이후의 부동 소수점 연산이 정상 이하의 값에 대한 IEEE 연산 ( &quot;비정규&quot;)에 대한 규칙을 따릅니다. 그렇지 않은 경우 부동 소수점 연산은 비정규 입력 또는 출력을 0으로 변환하도록 허용되지만 필수는 아닙니다. &lt;code&gt;yes==true&lt;/code&gt; &lt;code&gt;true&lt;/code&gt; 가 아니면 하드웨어가 비정규 수의 0을 지원하지 않으면 true를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="4fe82c65bb97ee33e80659528026f81237a00185" translate="yes" xml:space="preserve">
          <source>If Julia were a language that made more liberal use of ASCII characters, the slurping operator might have been written as &lt;code&gt;&amp;lt;-...&lt;/code&gt; instead of &lt;code&gt;...&lt;/code&gt;.</source>
          <target state="translated">줄리아는 ASCII 문자의 자유주의 사용을 만든 언어 인 경우는 소리내어 연산자로 작성되었을 수 있습니다 &lt;code&gt;&amp;lt;-...&lt;/code&gt; 대신 &lt;code&gt;...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c31aabb66505776aad35d90bd36db4dbf2d1b9d" translate="yes" xml:space="preserve">
          <source>If Julia were a language that made more liberal use of ASCII characters, the splatting operator might have been written as &lt;code&gt;...-&amp;gt;&lt;/code&gt; instead of &lt;code&gt;...&lt;/code&gt;.</source>
          <target state="translated">Julia가 ASCII 문자를보다 자유롭게 사용하는 언어 인 경우 splatting 연산자 는 &lt;code&gt;...&lt;/code&gt; 대신 &lt;code&gt;...-&amp;gt;&lt;/code&gt; 로 작성되었을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="60a92e91dcf7c91c0849e69c5ad346e21b345fcf" translate="yes" xml:space="preserve">
          <source>If [&lt;code&gt;vl&lt;/code&gt;, &lt;code&gt;vu&lt;/code&gt;] does not contain all eigenvalues of &lt;code&gt;A&lt;/code&gt;, then the returned factorization will be a &lt;em&gt;truncated&lt;/em&gt; factorization.</source>
          <target state="translated">[ &lt;code&gt;vl&lt;/code&gt; , &lt;code&gt;vu&lt;/code&gt; ]에 &lt;code&gt;A&lt;/code&gt; 의 고유 값이 모두 포함되어 있지 않으면 반환 된 인수 분해는 &lt;em&gt;잘린&lt;/em&gt; 인수 분해가됩니다.</target>
        </trans-unit>
        <trans-unit id="730dc1af168d94eefd1482151f83529bc44df580" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is empty, readers (on a &lt;code&gt;take!&lt;/code&gt; call) will block until data is available.</source>
          <target state="translated">경우 &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 비어 (A에 독자 &lt;code&gt;take!&lt;/code&gt; 데이터를 사용할 수있을 때까지 호출) 차단합니다.</target>
        </trans-unit>
        <trans-unit id="84662f0c325b992dd59906d92d27342a4c4aeef8" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is full, writers (on a &lt;code&gt;put!&lt;/code&gt; call) will block until space becomes available.</source>
          <target state="translated">&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 이 가득 찬 경우 공간이 확보 될 때까지 기록기 ( &lt;code&gt;put!&lt;/code&gt; 호출시)가 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="800a9b7d396fd78b7b6ed22445dc02985ff5d965" translate="yes" xml:space="preserve">
          <source>If a C/C++ routine has an argument or return value that is a native SIMD type, the corresponding Julia type is a homogeneous tuple of &lt;code&gt;VecElement&lt;/code&gt; that naturally maps to the SIMD type. Specifically:</source>
          <target state="translated">C / C ++ 루틴에 기본 SIMD 유형 인 인수 또는 리턴 값이있는 경우 해당 Julia 유형은 &lt;code&gt;VecElement&lt;/code&gt; 의 동종 튜플이며 SIMD 유형에 자연스럽게 맵핑됩니다. 구체적으로 특별히:</target>
        </trans-unit>
        <trans-unit id="c33b9c9ad9c6bea2ac47b4bed7df57b3ce4b628b" translate="yes" xml:space="preserve">
          <source>If a Julia function returns an array, the return value of &lt;code&gt;jl_eval_string&lt;/code&gt; and &lt;code&gt;jl_call&lt;/code&gt; can be cast to a &lt;code&gt;jl_array_t*&lt;/code&gt;:</source>
          <target state="translated">Julia 함수가 배열을 리턴하면 &lt;code&gt;jl_eval_string&lt;/code&gt; 및 &lt;code&gt;jl_call&lt;/code&gt; 의 리턴 값을 &lt;code&gt;jl_array_t*&lt;/code&gt; 로 캐스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da26aec502d267a61bc582bb3d104bf1101787e9" translate="yes" xml:space="preserve">
          <source>If a composite type is declared with &lt;code&gt;mutable struct&lt;/code&gt; instead of &lt;code&gt;struct&lt;/code&gt;, then instances of it can be modified:</source>
          <target state="translated">복합 형이 선언되면 &lt;code&gt;mutable struct&lt;/code&gt; 대신 &lt;code&gt;struct&lt;/code&gt; , 그것의 다음 인스턴스를 수정할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="4c7983e304a903c4c76a6412696125933d637b1a" translate="yes" xml:space="preserve">
          <source>If a function name requires multiple words, consider whether it might represent more than one concept and might be better split into pieces.</source>
          <target state="translated">함수 이름에 여러 단어가 필요한 경우 하나 이상의 개념을 나타낼 수 있고 조각으로 나눌 수 있는지 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="38936f146450cf1d3ca2236e47484dcaa49c5476" translate="yes" xml:space="preserve">
          <source>If a keyword argument is not assigned a default value in the method definition, then it is &lt;em&gt;required&lt;/em&gt;: an &lt;a href=&quot;../../base/base/index#Core.UndefKeywordError&quot;&gt;&lt;code&gt;UndefKeywordError&lt;/code&gt;&lt;/a&gt; exception will be thrown if the caller does not assign it a value:</source>
          <target state="translated">메소드 정의에서 키워드 인수에 기본값이 지정되지 않은 경우 키워드 인수가 &lt;em&gt;필요합니다&lt;/em&gt; . 호출자가 값을 지정하지 않으면 &lt;a href=&quot;../../base/base/index#Core.UndefKeywordError&quot;&gt; &lt;code&gt;UndefKeywordError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="605fe15674b1485baef4edc3c0b585f43273c96f" translate="yes" xml:space="preserve">
          <source>If a name is qualified (e.g. &lt;code&gt;Base.sin&lt;/code&gt;), then it can be accessed even if it is not exported. This is often useful when debugging. It can also have methods added to it by using the qualified name as the function name. However, due to syntactic ambiguities that arise, if you wish to add methods to a function in a different module whose name contains only symbols, such as an operator, &lt;code&gt;Base.+&lt;/code&gt; for example, you must use &lt;code&gt;Base.:+&lt;/code&gt; to refer to it. If the operator is more than one character in length you must surround it in brackets, such as: &lt;code&gt;Base.:(==)&lt;/code&gt;.</source>
          <target state="translated">이름이 정규화 된 경우 (예 : &lt;code&gt;Base.sin&lt;/code&gt; ) 내 보내지 않아도 액세스 할 수 있습니다. 이것은 디버깅 할 때 종종 유용합니다. 규정 된 이름을 함수 이름으로 사용하여 메소드를 추가 할 수도 있습니다. 그러나 구문 상 모호성으로 인해 이름에 연산자, &lt;code&gt;Base.+&lt;/code&gt; 와 같은 기호 만 포함 된 다른 모듈의 함수에 메소드를 추가하려는 경우 이를 참조 하려면 &lt;code&gt;Base.:+&lt;/code&gt; 를 사용해야 합니다. . 연산자의 길이가 둘 이상의 문자 인 경우 &lt;code&gt;Base.:(==)&lt;/code&gt; 와 같이 대괄호로 묶어야합니다 .</target>
        </trans-unit>
        <trans-unit id="906babc709733bae3d983752e96904e9364b6d02" translate="yes" xml:space="preserve">
          <source>If a number doesn't have an exact floating-point representation, it must be rounded to an appropriate representable value. However, the manner in which this rounding is done can be changed if required according to the rounding modes presented in the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754 standard&lt;/a&gt;.</source>
          <target state="translated">숫자에 정확한 부동 소수점 표현이 없으면 적절한 표현 가능한 값으로 반올림해야합니다. 그러나이 반올림이 수행되는 방식은 &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754 표준에&lt;/a&gt; 제시된 반올림 모드에 따라 필요한 경우 변경 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b6c6ec423ec9e7ccad324608060715dc6c4297ac" translate="yes" xml:space="preserve">
          <source>If a package subdirectory has a project file, then the graph entry for its UUID is the &lt;code&gt;[deps]&lt;/code&gt; map of the project file, which is considered to be empty if the section is absent.</source>
          <target state="translated">패키지 서브 디렉토리에 프로젝트 파일이있는 경우 UUID에 대한 그래프 항목은 프로젝트 파일의 &lt;code&gt;[deps]&lt;/code&gt; 맵이며 섹션이 없으면 비어있는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="b858ef46784b4025474ecb1ef203d57b534b42bf" translate="yes" xml:space="preserve">
          <source>If a package subdirectory has no project file, then it is omitted from graph and import statements in its code are treated as top-level, the same as the main project and REPL.</source>
          <target state="translated">패키지 서브 디렉토리에 프로젝트 파일이 없으면 그래프에서 생략되고 코드의 import 문은 기본 프로젝트 및 REPL과 동일하게 최상위 레벨로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="2f45dbf01a0d76d1b423a11e7134b517f4cc2734" translate="yes" xml:space="preserve">
          <source>If a regular expression does match, the value returned by &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; is a &lt;code&gt;RegexMatch&lt;/code&gt; object. These objects record how the expression matches, including the substring that the pattern matches and any captured substrings, if there are any. This example only captures the portion of the substring that matches, but perhaps we want to capture any non-blank text after the comment character. We could do the following:</source>
          <target state="translated">정규식이 일치하면 &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt; 가 반환하는 값 은 &lt;code&gt;RegexMatch&lt;/code&gt; 개체입니다. 이러한 객체는 패턴이 일치하는 하위 문자열과 캡처 된 하위 문자열 (있는 경우)을 포함하여 표현식이 어떻게 일치하는지 기록합니다. 이 예제는 일치하는 부분 문자열의 일부만 캡처하지만 주석 문자 다음에 공백이 아닌 텍스트를 캡처하려고합니다. 우리는 다음을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e6085fa6af3d4081b0dc16abe2813cbe1633ab2" translate="yes" xml:space="preserve">
          <source>If a second argument &lt;code&gt;val&lt;/code&gt; is provided, it will be passed to the task (via the return value of &lt;a href=&quot;#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt;) when it runs again. If &lt;code&gt;error&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the value is raised as an exception in the woken task.</source>
          <target state="translated">두 번째 인수 &lt;code&gt;val&lt;/code&gt; 이 제공되면 다시 실행될 때 &lt;a href=&quot;#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt; return to return value of yieldto ) 를 통해 태스크에 전달 됩니다. 경우 &lt;code&gt;error&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; , 값은 깨어 작업에서 예외로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bad86ee27c201caed09e850508017b392f709911" translate="yes" xml:space="preserve">
          <source>If a test fails consistently it can be changed to use the &lt;code&gt;@test_broken&lt;/code&gt; macro. This will denote the test as &lt;code&gt;Broken&lt;/code&gt; if the test continues to fail and alerts the user via an &lt;code&gt;Error&lt;/code&gt; if the test succeeds.</source>
          <target state="translated">테스트가 지속적으로 실패하면 &lt;code&gt;@test_broken&lt;/code&gt; 매크로 를 사용하도록 변경할 수 있습니다 . 이것은 테스트를 의미합니다 &lt;code&gt;Broken&lt;/code&gt; 테스트가 계속 실패하고를 통해 사용자에게 경고하는 경우 &lt;code&gt;Error&lt;/code&gt; 테스트가 성공하면.</target>
        </trans-unit>
        <trans-unit id="f4acf383897e60ec242acf14416a5081e1af3573" translate="yes" xml:space="preserve">
          <source>If a tuple of keyword argument names &lt;code&gt;kwnames&lt;/code&gt; is provided, this also checks whether the method of &lt;code&gt;f&lt;/code&gt; matching &lt;code&gt;t&lt;/code&gt; has the given keyword argument names. If the matching method accepts a variable number of keyword arguments, e.g. with &lt;code&gt;kwargs...&lt;/code&gt;, any names given in &lt;code&gt;kwnames&lt;/code&gt; are considered valid. Otherwise the provided names must be a subset of the method's keyword arguments.</source>
          <target state="translated">키워드 인자 이름의 튜플 경우 &lt;code&gt;kwnames&lt;/code&gt; 가 제공되는데,이 또한, 검사에있어서의 여부 &lt;code&gt;f&lt;/code&gt; 정합 &lt;code&gt;t&lt;/code&gt; 는 키워드 인자 이름을 부여하고있다. 일치하는 메소드가 변수 개수의 키워드 인수를 허용하는 경우 (예 : &lt;code&gt;kwargs...&lt;/code&gt; ) &lt;code&gt;kwnames&lt;/code&gt; 에 지정된 이름 은 유효한 것으로 간주됩니다. 그렇지 않으면 제공된 이름은 메소드 키워드 인수의 서브 세트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="3df6568badc4d30be904f3a616a563af8fd77a0a" translate="yes" xml:space="preserve">
          <source>If a type is defined as a subtype of &lt;code&gt;AbstractArray&lt;/code&gt;, it inherits a very large set of rich behaviors including iteration and multidimensional indexing built on top of single-element access. See the &lt;a href=&quot;../arrays/index#man-multi-dim-arrays-1&quot;&gt;arrays manual page&lt;/a&gt; and the &lt;a href=&quot;../../base/arrays/index#lib-arrays-1&quot;&gt;Julia Base section&lt;/a&gt; for more supported methods.</source>
          <target state="translated">유형이 &lt;code&gt;AbstractArray&lt;/code&gt; 의 하위 유형으로 정의 된 경우 단일 요소 액세스 위에 빌드 된 반복 및 다차원 색인 작성을 포함하여 매우 다양한 리치 동작 세트를 상속합니다. 지원되는 방법에 대해서는 &lt;a href=&quot;../arrays/index#man-multi-dim-arrays-1&quot;&gt;어레이 매뉴얼 페이지&lt;/a&gt; 와 &lt;a href=&quot;../../base/arrays/index#lib-arrays-1&quot;&gt;Julia Base 섹션&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="72a8103071abaea7ac2a617ea71042865eddd171" translate="yes" xml:space="preserve">
          <source>If a type is effectively an enumeration, it should be defined as a single (ideally immutable struct or primitive) type, with the enumeration values being instances of it. Constructors and conversions can check whether values are valid. This design is preferred over making the enumeration an abstract type, with the &quot;values&quot; as subtypes.</source>
          <target state="translated">유형이 효과적으로 열거 형이면 열거 형 값이 인스턴스 인 단일 (이상적으로 변경 불가능한 구조체 또는 기본) 유형으로 정의해야합니다. 생성자와 변환은 값이 유효한지 확인할 수 있습니다. 이 디자인은 열거 형을 추상 유형으로 만드는 것보다 &quot;값&quot;을 하위 유형으로하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="22206d1a9cff4ea1aad87ee3f387a4a25003f12d" translate="yes" xml:space="preserve">
          <source>If a user is presented with a credential prompt they can abort the prompt by typing &lt;code&gt;^D&lt;/code&gt; (pressing the control key together with the &lt;code&gt;d&lt;/code&gt; key).</source>
          <target state="translated">사용자에게 자격 증명 프롬프트가 표시되면 &lt;code&gt;^D&lt;/code&gt; 를 입력하여 프롬프트를 중단 할 수 있습니다 ( &lt;code&gt;d&lt;/code&gt; 키 와 함께 제어 키를 누름 ).</target>
        </trans-unit>
        <trans-unit id="ebb7b0aa6b2c808bffa6df77883dc4cf4f4f7ece" translate="yes" xml:space="preserve">
          <source>If a worker pool is not specified, all available workers, i.e., the default worker pool is used.</source>
          <target state="translated">작업자 풀을 지정하지 않으면 사용 가능한 모든 작업자, 즉 기본 작업자 풀이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ec5bfd99caef655cee76ea6c587f7690d264c4bb" translate="yes" xml:space="preserve">
          <source>If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.</source>
          <target state="translated">모든 데이터가 숫자이면 결과는 숫자 배열이됩니다. 일부 요소를 숫자로 구문 분석 할 수없는 경우 이기종 배열의 숫자와 문자열이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="9ac5a121e4737af42e151921b98260446a6d1fe7" translate="yes" xml:space="preserve">
          <source>If all indices &lt;code&gt;I_k&lt;/code&gt; are integers, then the value in location &lt;code&gt;I_1, I_2, ..., I_n&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt; is overwritten with the value of &lt;code&gt;X&lt;/code&gt;, &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;ing to the &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;A&lt;/code&gt; if necessary.</source>
          <target state="translated">모든 인덱스 경우 &lt;code&gt;I_k&lt;/code&gt; 는 정수, 위치에 다음 값이 &lt;code&gt;I_1, I_2, ..., I_n&lt;/code&gt; 의 &lt;code&gt;A&lt;/code&gt; 의 값으로 덮어 쓰기 &lt;code&gt;X&lt;/code&gt; , &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; 받는 보내고 &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt; 의 필요한 경우. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="16c375c96eb496fe31b2274a71fede0f6283f232" translate="yes" xml:space="preserve">
          <source>If all indices &lt;code&gt;I_k&lt;/code&gt; are vectors, for example, then the shape of &lt;code&gt;X&lt;/code&gt; would be &lt;code&gt;(length(I_1), length(I_2), ..., length(I_n))&lt;/code&gt;, with location &lt;code&gt;i_1, i_2, ..., i_n&lt;/code&gt; of &lt;code&gt;X&lt;/code&gt; containing the value &lt;code&gt;A[I_1[i_1], I_2[i_2], ..., I_n[i_n]]&lt;/code&gt;.</source>
          <target state="translated">모든 인덱스 경우 &lt;code&gt;I_k&lt;/code&gt; 는 벡터, 예를 들면, 다음의 형태 &lt;code&gt;X&lt;/code&gt; 는 것 &lt;code&gt;(length(I_1), length(I_2), ..., length(I_n))&lt;/code&gt; 의 위치와, &lt;code&gt;i_1, i_2, ..., i_n&lt;/code&gt; 의 &lt;code&gt;X&lt;/code&gt; 는 값 함유 &lt;code&gt;A[I_1[i_1], I_2[i_2], ..., I_n[i_n]]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7329bd9dbc66827b90f349500e9813dc3f4dd6b" translate="yes" xml:space="preserve">
          <source>If all the arguments are scalars or zero-dimensional arrays, it returns an unwrapped scalar.</source>
          <target state="translated">모든 인수가 스칼라 또는 0 차원 배열이면 래핑되지 않은 스칼라를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="947c4d2702167c0b010760802f3c8902ac7ef2b7" translate="yes" xml:space="preserve">
          <source>If all the indices are scalars, then the result &lt;code&gt;X&lt;/code&gt; is a single element from the array &lt;code&gt;A&lt;/code&gt;. Otherwise, &lt;code&gt;X&lt;/code&gt; is an array with the same number of dimensions as the sum of the dimensionalities of all the indices.</source>
          <target state="translated">모든 인덱스가 스칼라이면 결과 &lt;code&gt;X&lt;/code&gt; 는 배열 &lt;code&gt;A&lt;/code&gt; 의 단일 요소입니다 . 그렇지 않으면 &lt;code&gt;X&lt;/code&gt; 는 모든 인덱스의 차원의 합과 동일한 차원 수를 가진 배열입니다.</target>
        </trans-unit>
        <trans-unit id="3044600e4ff9e45b323c2058f952d5b48a41642d" translate="yes" xml:space="preserve">
          <source>If all these checks pass, the message and key&amp;ndash;value pairs are evaluated in full and passed to the current logger via the &lt;a href=&quot;#Base.CoreLogging.handle_message&quot;&gt;&lt;code&gt;Logging.handle_message&lt;/code&gt;&lt;/a&gt; function. &lt;code&gt;handle_message()&lt;/code&gt; may perform additional filtering as required and display the event to the screen, save it to a file, etc.</source>
          <target state="translated">이러한 모든 검사가 통과되면 메시지와 키-값 쌍이 모두 평가되어 &lt;a href=&quot;#Base.CoreLogging.handle_message&quot;&gt; &lt;code&gt;Logging.handle_message&lt;/code&gt; &lt;/a&gt; 함수 를 통해 현재 로거로 전달됩니다 . &lt;code&gt;handle_message()&lt;/code&gt; 는 필요에 따라 추가 필터링을 수행하고 이벤트를 화면에 표시하거나 파일에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bec4431d05d00195da3b5ef4209465d15c43707c" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;init&lt;/code&gt; function of the type &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt; is specified, it is called on all the participating workers.</source>
          <target state="translated">&lt;code&gt;initfn(S::SharedArray)&lt;/code&gt; 유형 의 &lt;code&gt;init&lt;/code&gt; 함수 가 지정되면 모든 참여 작업자에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3b65b9c692ce6d8deffe1b518910973b66bdfe66" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;init&lt;/code&gt; function, of signature &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt;, is specified, it is called on all the participating workers. You can specify that each worker runs the &lt;code&gt;init&lt;/code&gt; function on a distinct portion of the array, thereby parallelizing initialization.</source>
          <target state="translated">서명 &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt; 의 &lt;code&gt;init&lt;/code&gt; 함수 가 지정된 경우 모든 참여 작업자에서 호출됩니다. 각 작업자가 배열의 다른 부분 에서 &lt;code&gt;init&lt;/code&gt; 함수를 실행하여 초기화 를 병렬 처리하도록 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dcd6328c4dd12bc549abfb594d444224ffd4160c" translate="yes" xml:space="preserve">
          <source>If an array of eltype &lt;code&gt;Ptr{T}&lt;/code&gt; is passed as a &lt;code&gt;Ptr{Ptr{T}}&lt;/code&gt; argument, &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; will attempt to first make a null-terminated copy of the array with each element replaced by its &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; version. This allows, for example, passing an &lt;code&gt;argv&lt;/code&gt; pointer array of type &lt;code&gt;Vector{String}&lt;/code&gt; to an argument of type &lt;code&gt;Ptr{Ptr{Cchar}}&lt;/code&gt;.</source>
          <target state="translated">eltype 배열하는 경우 &lt;code&gt;Ptr{T}&lt;/code&gt; A와 통과 &lt;code&gt;Ptr{Ptr{T}}&lt;/code&gt; 인수 &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; 는&lt;/a&gt; 그 대신 각 요소와 제 만들기 위해 어레이의 널 종료 복사를 시도한다 &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; 의&lt;/a&gt; 버전. 예를 들어 &lt;code&gt;Vector{String}&lt;/code&gt; 유형 의 &lt;code&gt;argv&lt;/code&gt; 포인터 배열을 &lt;code&gt;Ptr{Ptr{Cchar}}&lt;/code&gt; 유형의 인수로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8aa768f627a40c9d0913fe21e857ab82ce9b4abc" translate="yes" xml:space="preserve">
          <source>If any conflicts arise which cannot be automatically resolved, the rebase will abort, leaving the repository and working tree in its original state, and the function will throw a &lt;code&gt;GitError&lt;/code&gt;. This is roughly equivalent to the following command line statement:</source>
          <target state="translated">자동으로 해결할 수없는 충돌이 발생하면 리베이스가 중단되고 리포지토리와 작업 트리가 원래 상태로 유지되며 함수는 &lt;code&gt;GitError&lt;/code&gt; 를 발생시킵니다 . 이것은 다음 명령 행 명령문과 거의 같습니다.</target>
        </trans-unit>
        <trans-unit id="d387af77f5db6a955f974f865de51228d37bd15f" translate="yes" xml:space="preserve">
          <source>If any index &lt;code&gt;I_k&lt;/code&gt; selects more than one location, then the right hand side &lt;code&gt;X&lt;/code&gt; must be an array with the same shape as the result of indexing &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt; or a vector with the same number of elements. The value in location &lt;code&gt;I_1[i_1], I_2[i_2], ..., I_n[i_n]&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt; is overwritten with the value &lt;code&gt;X[I_1, I_2, ..., I_n]&lt;/code&gt;, converting if necessary. The element-wise assignment operator &lt;code&gt;.=&lt;/code&gt; may be used to &lt;a href=&quot;#Broadcasting-1&quot;&gt;broadcast&lt;/a&gt;&lt;code&gt;X&lt;/code&gt; across the selected locations:</source>
          <target state="translated">인덱스 &lt;code&gt;I_k&lt;/code&gt; 가 둘 이상의 위치를 ​​선택하는 경우 오른쪽 &lt;code&gt;X&lt;/code&gt; 는 인덱스 &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt; 의 결과와 동일한 모양의 배열 이거나 요소 수가 동일한 벡터 여야 합니다. . 위치의 값 &lt;code&gt;I_1[i_1], I_2[i_2], ..., I_n[i_n]&lt;/code&gt; 의 &lt;code&gt;A&lt;/code&gt; 값으로 덮어 &lt;code&gt;X[I_1, I_2, ..., I_n]&lt;/code&gt; , 필요한 경우 변환. 요소 별 할당 연산자 &lt;code&gt;.=&lt;/code&gt; 를 사용 하여 선택한 위치에서 &lt;code&gt;X&lt;/code&gt; 를 &lt;a href=&quot;#Broadcasting-1&quot;&gt;브로드 캐스트&lt;/a&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a2dae61ea17ea95a5a6582831ba526a24537cb67" translate="yes" xml:space="preserve">
          <source>If any inner constructor method is defined, no default constructor method is provided: it is presumed that you have supplied yourself with all the inner constructors you need. The default constructor is equivalent to writing your own inner constructor method that takes all of the object's fields as parameters (constrained to be of the correct type, if the corresponding field has a type), and passes them to &lt;code&gt;new&lt;/code&gt;, returning the resulting object:</source>
          <target state="translated">내부 생성자 메서드가 정의되어 있으면 기본 생성자 메서드가 제공되지 않습니다. 필요한 모든 내부 생성자를 제공 한 것으로 가정합니다. 기본 생성자는 객체의 모든 필드를 매개 변수로 사용하고 (해당 필드에 유형이있는 경우 올바른 유형으로 제한됨) 결과 객체를 반환하는 &lt;code&gt;new&lt;/code&gt; 내부 생성자 메서드를 작성하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="e9dbb4d7bac298e185fc7fe07e57c374bc123283" translate="yes" xml:space="preserve">
          <source>If any of these result in success, the path to the source code entry point will be either that result, the relative path from that result plus &lt;code&gt;src/X.jl&lt;/code&gt;; otherwise, there is no path mapping for &lt;code&gt;uuid&lt;/code&gt;. When loading &lt;code&gt;X&lt;/code&gt;, if no source code path is found, the lookup will fail, and the user may be prompted to install the appropriate package version or to take other corrective action (e.g. declaring &lt;code&gt;X&lt;/code&gt; as a dependency).</source>
          <target state="translated">이들 중 하나라도 성공하면 소스 코드 진입 점에 대한 경로는 해당 결과에 대한 상대 경로에 &lt;code&gt;src/X.jl&lt;/code&gt; 을 더한 결과입니다 . 그렇지 않으면 &lt;code&gt;uuid&lt;/code&gt; 에 대한 경로 매핑이 없습니다 . &lt;code&gt;X&lt;/code&gt; 를 로드 할 때 소스 코드 경로가 없으면 조회가 실패하고 사용자에게 적절한 패키지 버전을 설치하거나 다른 수정 조치를 취하라는 메시지가 표시 될 수 있습니다 (예 : &lt;code&gt;X&lt;/code&gt; 를 종속성으로 선언 ).</target>
        </trans-unit>
        <trans-unit id="4ddf1789b0cb07d74b04fcfdb8b7aef3cf09d72f" translate="yes" xml:space="preserve">
          <source>If array contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, the result is also &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;missing&lt;/code&gt; (&lt;code&gt;missing&lt;/code&gt; takes precedence if array contains both). Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the standard deviation of non-missing values.</source>
          <target state="translated">배열에 &lt;code&gt;NaN&lt;/code&gt; 또는 결 &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 포함 된 경우 결과도 &lt;code&gt;NaN&lt;/code&gt; 또는 &lt;code&gt;missing&lt;/code&gt; ( 배열에 둘 다 포함 된 경우 &lt;code&gt;missing&lt;/code&gt; 이 우선 함). &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt; 기능을 사용하여 &lt;code&gt;missing&lt;/code&gt; 항목 을 생략 하고 비결 측값 의 표준 편차를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="3a6293b5e98855a8ee42f2bca1bebc73fa339517" translate="yes" xml:space="preserve">
          <source>If array contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, the result is also &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;missing&lt;/code&gt; (&lt;code&gt;missing&lt;/code&gt; takes precedence if array contains both). Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the variance of non-missing values.</source>
          <target state="translated">배열에 &lt;code&gt;NaN&lt;/code&gt; 또는 결 &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 포함 된 경우 결과도 &lt;code&gt;NaN&lt;/code&gt; 또는 &lt;code&gt;missing&lt;/code&gt; ( 배열에 둘 다 포함 된 경우 &lt;code&gt;missing&lt;/code&gt; 이 우선 함). 생략 &lt;code&gt;missing&lt;/code&gt; 함수를 사용하여 누락 된 항목 을 생략 하고 &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt; 의 분산을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="38e45e26639753f801787edbbd58523b34871d79" translate="yes" xml:space="preserve">
          <source>If at least one argument is a tuple and all others are scalars or zero-dimensional arrays, it returns a tuple.</source>
          <target state="translated">적어도 하나의 인수가 튜플이고 다른 모든 인수가 스칼라 또는 0 차원 배열이면 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="186a2528019c2b28f2ac036bd36737c001f4c334" translate="yes" xml:space="preserve">
          <source>If called with the optional &lt;code&gt;stream&lt;/code&gt; argument, then returns &lt;code&gt;stream&lt;/code&gt; itself.</source>
          <target state="translated">선택적 &lt;code&gt;stream&lt;/code&gt; 인수 와 함께 호출되면 &lt;code&gt;stream&lt;/code&gt; 자체 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="c2dc6a2dba2346f86620a63b3cfed83cd90e27f4" translate="yes" xml:space="preserve">
          <source>If captured variables are used in a performance-critical section of the code, then the following tips help ensure that their use is performant. First, if it is known that a captured variable does not change its type, then this can be declared explicitly with a type annotation (on the variable, not the right-hand side):</source>
          <target state="translated">캡처 된 변수가 코드의 성능 핵심 섹션에서 사용되는 경우 다음 팁은 해당 기능이 제대로 작동하는지 확인하는 데 도움이됩니다. 먼저, 캡처 된 변수가 그 유형을 변경하지 않는 것으로 알려진 경우, 변수 주석 (오른쪽이 아닌 변수)을 사용하여 명시 적으로 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a5d4d133718a06af974dc91ca305c022dd4e098" translate="yes" xml:space="preserve">
          <source>If field types are specified, the arguments are converted. Otherwise the types of the arguments are used directly.</source>
          <target state="translated">필드 유형이 지정되면 인수가 변환됩니다. 그렇지 않으면 인수 유형이 직접 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8f773999b3dbcf00b06936dfadd297798081b077" translate="yes" xml:space="preserve">
          <source>If instead you want to specialize on the destination type &lt;code&gt;DestType&lt;/code&gt; without specializing on &lt;code&gt;DestStyle&lt;/code&gt;, then you should define a method with the following signature:</source>
          <target state="translated">당신이 대상 유형에 전문하려는 대신하는 경우 &lt;code&gt;DestType&lt;/code&gt; 에 전문없이 &lt;code&gt;DestStyle&lt;/code&gt; , 당신은 다음과 같은 서명을하는 방법을 정의해야합니다 :</target>
        </trans-unit>
        <trans-unit id="861e841404a73546cfbc58b3413de786fc3740a2" translate="yes" xml:space="preserve">
          <source>If it does not have a project file, it can import any top-level package&amp;mdash;i.e. the same packages that can be loaded in &lt;code&gt;Main&lt;/code&gt; or the REPL.</source>
          <target state="translated">프로젝트 파일이없는 경우 최상위 레벨 패키지, 즉 &lt;code&gt;Main&lt;/code&gt; 또는 REPL에 로드 할 수있는 동일한 패키지를 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4cdc37b95e5e03c0daf7e3854e30ae2e06ab2fbd" translate="yes" xml:space="preserve">
          <source>If it has a &lt;code&gt;git-tree-sha1&lt;/code&gt; entry, compute a deterministic hash function of &lt;code&gt;uuid&lt;/code&gt; and &lt;code&gt;git-tree-sha1&lt;/code&gt;&amp;mdash;call it &lt;code&gt;slug&lt;/code&gt;&amp;mdash;and look for a directory named &lt;code&gt;packages/X/$slug&lt;/code&gt; in each directory in the Julia &lt;code&gt;DEPOT_PATH&lt;/code&gt; global array. Use the first such directory that exists.</source>
          <target state="translated">그것은이있는 경우 &lt;code&gt;git-tree-sha1&lt;/code&gt; 항목의 결정 해시 함수 계산 &lt;code&gt;uuid&lt;/code&gt; 와 &lt;code&gt;git-tree-sha1&lt;/code&gt; 그 울어 &lt;code&gt;slug&lt;/code&gt; 라는 이름의 디렉토리 - 그리고 모양 &lt;code&gt;packages/X/$slug&lt;/code&gt; 줄리아의 각 디렉토리에 &lt;code&gt;DEPOT_PATH&lt;/code&gt; 전역 배열 . 존재하는 첫 번째 디렉토리를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cd1241924f2c661cd879945fa2b395e0b0c5bf1c" translate="yes" xml:space="preserve">
          <source>If it has a &lt;code&gt;path&lt;/code&gt; entry, use that path (relative to the directory containing the manifest file).</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 항목 이 있으면 해당 경로를 사용하십시오 (매니페스트 파일이 포함 된 디렉토리에 상대적).</target>
        </trans-unit>
        <trans-unit id="ecfbca60e91ee74286b0eaf619c2ce8c59e2470c" translate="yes" xml:space="preserve">
          <source>If it has a project file, it can only import those packages which are identified in the &lt;code&gt;[deps]&lt;/code&gt; section of the project file.</source>
          <target state="translated">프로젝트 파일이있는 경우 프로젝트 파일의 &lt;code&gt;[deps]&lt;/code&gt; 섹션 에서 식별 된 패키지 만 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d73050aa6cb9e92d8510b86ef26b845581d55552" translate="yes" xml:space="preserve">
          <source>If it is required to hold the pointer to a variable between functions (or block scopes), then it is not possible to use &lt;code&gt;JL_GC_PUSH*&lt;/code&gt;. In this case, it is necessary to create and keep a reference to the variable in the Julia global scope. One simple way to accomplish this is to use a global &lt;code&gt;IdDict&lt;/code&gt; that will hold the references, avoiding deallocation by the GC. However, this method will only work properly with mutable types.</source>
          <target state="translated">함수 (또는 블록 범위) 사이의 변수에 대한 포인터를 보유 &lt;code&gt;JL_GC_PUSH*&lt;/code&gt; 경우 JL_GC_PUSH * 를 사용할 수 없습니다 . 이 경우 Julia 글로벌 범위에서 변수에 대한 참조를 작성하고 유지해야합니다. 이를 달성하는 간단한 방법 중 하나 는 GC에 의한 할당 해제를 피하면서 참조를 보유 하는 전역 &lt;code&gt;IdDict&lt;/code&gt; 를 사용하는 것입니다. 그러나이 방법은 가변 유형에서만 올바르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="473e682023e21d67484bab11333a56f6e24d4e3e" translate="yes" xml:space="preserve">
          <source>If it's the &lt;code&gt;n&lt;/code&gt;th time that &lt;code&gt;jl_gc_collect()&lt;/code&gt; has been called, and &lt;code&gt;n&lt;/code&gt; belongs to the arithmetic sequence represented by &lt;code&gt;$JULIA_GC_ALLOC_PRINT&lt;/code&gt;, then counts for the number of calls to &lt;code&gt;jl_gc_pool_alloc()&lt;/code&gt; and &lt;code&gt;maybe_collect()&lt;/code&gt; are printed.</source>
          <target state="translated">그것은 만약 &lt;code&gt;n&lt;/code&gt; 것을 번째 시간 &lt;code&gt;jl_gc_collect()&lt;/code&gt; 호출 된, 그리고 &lt;code&gt;n&lt;/code&gt; 으로 표시 산술 순서에 속하는 &lt;code&gt;$JULIA_GC_ALLOC_PRINT&lt;/code&gt; , 다음 호출의 수에 대한 카운트 &lt;code&gt;jl_gc_pool_alloc()&lt;/code&gt; 와 &lt;code&gt;maybe_collect()&lt;/code&gt; 인쇄되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="130d982e40fa648e81bf69006602371d8efc3765" translate="yes" xml:space="preserve">
          <source>If it's the &lt;code&gt;n&lt;/code&gt;th time that &lt;code&gt;jl_gc_pool_alloc()&lt;/code&gt; has been called, and &lt;code&gt;n&lt;/code&gt; belongs to the arithmetic sequence represented by &lt;code&gt;$JULIA_GC_ALLOC_POOL&lt;/code&gt;, then garbage collection is forced.</source>
          <target state="translated">그것은 만약 &lt;code&gt;n&lt;/code&gt; 것을 회째 &lt;code&gt;jl_gc_pool_alloc()&lt;/code&gt; 호출되었는지, 그리고 &lt;code&gt;n&lt;/code&gt; 으로 표시되는 연산 시퀀스에 속하는 &lt;code&gt;$JULIA_GC_ALLOC_POOL&lt;/code&gt; 후, 가비지 콜렉션 강제된다.</target>
        </trans-unit>
        <trans-unit id="40d1d12e4aea313c12b9b3da68ad08e9a0d521e5" translate="yes" xml:space="preserve">
          <source>If it's the &lt;code&gt;n&lt;/code&gt;th time that &lt;code&gt;maybe_collect()&lt;/code&gt; has been called, and &lt;code&gt;n&lt;/code&gt; belongs to the arithmetic sequence represented by &lt;code&gt;$JULIA_GC_ALLOC_OTHER&lt;/code&gt;, then garbage collection is forced.</source>
          <target state="translated">그것은 만약 &lt;code&gt;n&lt;/code&gt; 것을 회째 &lt;code&gt;maybe_collect()&lt;/code&gt; 호출되었는지, 그리고 &lt;code&gt;n&lt;/code&gt; 으로 표시되는 연산 시퀀스에 속하는 &lt;code&gt;$JULIA_GC_ALLOC_OTHER&lt;/code&gt; 후, 가비지 콜렉션 강제된다.</target>
        </trans-unit>
        <trans-unit id="74f9655f12c7f5e7ed84cb6e935e104ba2688d1a" translate="yes" xml:space="preserve">
          <source>If keyword &lt;code&gt;supertypes&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, also return arguments with a parent type of &lt;code&gt;typ&lt;/code&gt;, excluding type &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">키워드 &lt;code&gt;supertypes&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 인 경우 &lt;code&gt;Any&lt;/code&gt; 유형을 제외하고 부모 유형이 &lt;code&gt;typ&lt;/code&gt; 인 인수도 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="bc696527340f0e0e085e98638a1e2d12825b4024" translate="yes" xml:space="preserve">
          <source>If memory usage is your concern, you can always replace objects with ones that consume less memory. For example, if &lt;code&gt;A&lt;/code&gt; is a gigabyte-sized array that you no longer need, you can free the memory with &lt;code&gt;A = nothing&lt;/code&gt;. The memory will be released the next time the garbage collector runs; you can force this to happen with &lt;a href=&quot;../../base/base/index#Base.GC.gc&quot;&gt;&lt;code&gt;gc()&lt;/code&gt;&lt;/a&gt;. Moreover, an attempt to use &lt;code&gt;A&lt;/code&gt; will likely result in an error, because most methods are not defined on type &lt;code&gt;Nothing&lt;/code&gt;.</source>
          <target state="translated">메모리 사용이 염려되는 경우 항상 적은 메모리를 사용하는 객체로 객체를 교체 할 수 있습니다. 예를 들어, &lt;code&gt;A&lt;/code&gt; 가 더 이상 필요하지 않은 기가 바이트 크기의 배열 인 경우 &lt;code&gt;A = nothing&lt;/code&gt; 메모리를 해제 할 수 있습니다 . 다음에 가비지 수집기가 실행될 때 메모리가 해제됩니다. &lt;a href=&quot;../../base/base/index#Base.GC.gc&quot;&gt; &lt;code&gt;gc()&lt;/code&gt; &lt;/a&gt; 이것을 강제로 수행 할 수 있습니다 . 또한 대부분의 메소드가 &lt;code&gt;Nothing&lt;/code&gt; 유형에 정의되어 있지 않기 때문에 &lt;code&gt;A&lt;/code&gt; 를 사용하려고 하면 오류가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d311a5ead70c39f70d69a25fb13adf9b0a2959d" translate="yes" xml:space="preserve">
          <source>If much of your run time is spent executing a particular line of code, this line will show up frequently in the set of all backtraces. In other words, the &quot;cost&quot; of a given line&amp;ndash;or really, the cost of the sequence of function calls up to and including this line&amp;ndash;is proportional to how often it appears in the set of all backtraces.</source>
          <target state="translated">많은 실행 시간이 특정 코드 줄을 실행하는 데 소비되는 경우이 줄은 모든 역 추적 집합에 자주 나타납니다. 다시 말해, 주어진 라인의 &quot;비용&quot;즉, 실제로는이 라인까지의 함수 호출 시퀀스 비용은 모든 백 트레이스 세트에 나타나는 빈도에 비례합니다.</target>
        </trans-unit>
        <trans-unit id="99791a8f1a9660eaeaa9f5b9e831b943f3ed9006" translate="yes" xml:space="preserve">
          <source>If needed, the sorting algorithm can be chosen:</source>
          <target state="translated">필요한 경우 정렬 알고리즘을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4223679e9c9b3c609f6bfb56a1e1db206adba7ec" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;type&lt;/code&gt; argument is specified, the default is &lt;code&gt;Vector{UInt8}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 인수가 지정 되지 않은 경우 기본값은 &lt;code&gt;Vector{UInt8}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dfa8e1861fd13b4e706313c90dcab6ea83fe0c35" translate="yes" xml:space="preserve">
          <source>If no argument is passed, the task blocks for an undefined period. A task can only be restarted by an explicit call to &lt;a href=&quot;#Base.schedule&quot;&gt;&lt;code&gt;schedule&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수가 전달되지 않으면 작업이 정의되지 않은 기간 동안 차단됩니다. &lt;a href=&quot;#Base.schedule&quot;&gt; &lt;code&gt;schedule&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt; 에 대한 명시 적 호출을 통해서만 작업을 다시 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aa0a9f892d2c7e314c83b4254ca8ced8f31ecd25" translate="yes" xml:space="preserve">
          <source>If no custom testset type is given it defaults to creating a &lt;code&gt;DefaultTestSet&lt;/code&gt;. &lt;code&gt;DefaultTestSet&lt;/code&gt; records all the results and, if there are any &lt;code&gt;Fail&lt;/code&gt;s or &lt;code&gt;Error&lt;/code&gt;s, throws an exception at the end of the top-level (non-nested) test set, along with a summary of the test results.</source>
          <target state="translated">사용자 정의 테스트 세트 유형이 제공되지 않으면 기본값은 &lt;code&gt;DefaultTestSet&lt;/code&gt; 작성 입니다. &lt;code&gt;DefaultTestSet&lt;/code&gt; 는 모든 결과를 기록하고 &lt;code&gt;Fail&lt;/code&gt; 또는 &lt;code&gt;Error&lt;/code&gt; 가있는 경우 테스트 결과 요약과 함께 최상위 (비 중첩) 테스트 세트의 끝에서 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="1e0f744d0d8245436d7c2b792319d69a40debe40" translate="yes" xml:space="preserve">
          <source>If possible, &lt;code&gt;one(x)&lt;/code&gt; returns a value of the same type as &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;one(T)&lt;/code&gt; returns a value of type &lt;code&gt;T&lt;/code&gt;. However, this may not be the case for types representing dimensionful quantities (e.g. time in days), since the multiplicative identity must be dimensionless. In that case, &lt;code&gt;one(x)&lt;/code&gt; should return an identity value of the same precision (and shape, for matrices) as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">가능하다면, &lt;code&gt;one(x)&lt;/code&gt; 동일한 유형의 반환 값 &lt;code&gt;x&lt;/code&gt; , 그리고 &lt;code&gt;one(T)&lt;/code&gt; 입력 값 반환 &lt;code&gt;T&lt;/code&gt; 를 . 그러나 곱하기 동일성에는 차원이 없어야하기 때문에 차원 수량 (예 : 일 단위 시간)을 나타내는 유형의 경우에는 해당되지 않을 수 있습니다. 이 경우, &lt;code&gt;one(x)&lt;/code&gt; 등 (매트릭스 및 모양) 식별 동일한 정밀도의 값으로 리턴한다 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe767ad4883ee037996d5cf486b48b4286df5e71" translate="yes" xml:space="preserve">
          <source>If set to a string that starts with the case-insensitive substring &lt;code&gt;&quot;infinite&quot;&lt;/code&gt;, then spinning threads never sleep. Otherwise, &lt;code&gt;$JULIA_THREAD_SLEEP_THRESHOLD&lt;/code&gt; is interpreted as an unsigned 64-bit integer (&lt;code&gt;uint64_t&lt;/code&gt;) and gives, in nanoseconds, the amount of time after which spinning threads should sleep.</source>
          <target state="translated">대소 문자를 구분하지 않는 하위 문자열 &lt;code&gt;&quot;infinite&quot;&lt;/code&gt; 로 시작하는 문자열로 설정하면 회전 스레드가 절대 절전 모드로 전환되지 않습니다. 그렇지 않으면 &lt;code&gt;$JULIA_THREAD_SLEEP_THRESHOLD&lt;/code&gt; 는 부호없는 64 비트 정수 ( &lt;code&gt;uint64_t&lt;/code&gt; ) 로 해석되며 회전 스레드가 휴면해야하는 시간을 나노초 단위로 제공합니다.</target>
        </trans-unit>
        <trans-unit id="20e80c59100f13ca7e73369cbf1cacf7e59c1aa3" translate="yes" xml:space="preserve">
          <source>If set to anything besides &lt;code&gt;0&lt;/code&gt;, then Julia's thread policy is consistent with running on a dedicated machine: the master thread is on proc 0, and threads are affinitized. Otherwise, Julia lets the operating system handle thread policy.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 이외의 값으로 설정된 경우 Julia의 스레드 정책은 전용 시스템에서 실행되는 것과 일치합니다. 마스터 스레드는 proc 0에 있고 스레드는 선호됩니다. 그렇지 않으면 Julia는 운영 체제가 스레드 정책을 처리하도록합니다.</target>
        </trans-unit>
        <trans-unit id="f40c9b9b4bbc428bc99a8f3b50c7542418d6c605" translate="yes" xml:space="preserve">
          <source>If set to anything besides &lt;code&gt;0&lt;/code&gt;, then the Julia garbage collector never performs &quot;quick sweeps&quot; of memory.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 이외의 값으로 설정 하면 Julia 가비지 수집기는 메모리의 &quot;빠른 청소&quot;를 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eb0219b86b58bf1246d63c4e45daa90f20eb81c3" translate="yes" xml:space="preserve">
          <source>If set to anything besides &lt;code&gt;0&lt;/code&gt;, then the Julia garbage collector will wait for a debugger to attach instead of aborting whenever there's a critical error.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 이외의 값으로 설정 하면 Julia 가비지 수집기는 심각한 오류가 발생할 때마다 중단되지 않고 디버거가 연결되기를 기다립니다.</target>
        </trans-unit>
        <trans-unit id="1ba30fe7de8eb6c5eb6e36c3ca16b929b1d23810" translate="yes" xml:space="preserve">
          <source>If set to anything besides &lt;code&gt;0&lt;/code&gt;, then the compiler will create and register an event listener for just-in-time (JIT) profiling.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 이외의 값으로 설정 하면 컴파일러는 JIT (Just-In-Time) 프로파일 링을위한 이벤트 리스너를 작성하고 등록합니다.</target>
        </trans-unit>
        <trans-unit id="3b0cd4807865348218a8157872f2d19ba8cef0a0" translate="yes" xml:space="preserve">
          <source>If set, then Julia prints detailed information about the cache in the loading process of &lt;a href=&quot;../../base/base/index#Base.require&quot;&gt;&lt;code&gt;Base.require&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">설정된 경우 Julia는 &lt;a href=&quot;../../base/base/index#Base.require&quot;&gt; &lt;code&gt;Base.require&lt;/code&gt; &lt;/a&gt; 의로드 프로세스에서 캐시에 대한 자세한 정보를 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="31ed13caeaa2adf17adcff6b38e069bb43cc30cf" translate="yes" xml:space="preserve">
          <source>If set, these environment variables take strings that optionally start with the character &lt;code&gt;'r'&lt;/code&gt;, followed by a string interpolation of a colon-separated list of three signed 64-bit integers (&lt;code&gt;int64_t&lt;/code&gt;). This triple of integers &lt;code&gt;a:b:c&lt;/code&gt; represents the arithmetic sequence &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;a + b&lt;/code&gt;, &lt;code&gt;a + 2*b&lt;/code&gt;, ... &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">설정된 경우 이러한 환경 변수는 선택적으로 문자 &lt;code&gt;'r'&lt;/code&gt; 로 시작하는 문자열을 사용하고 그 뒤에 3 개의 부호있는 64 비트 정수 ( &lt;code&gt;int64_t&lt;/code&gt; ) 의 콜론으로 구분 된 목록의 문자열 보간이 이어집니다 . 이 3 배의 정수 &lt;code&gt;a:b:c&lt;/code&gt; 는 산술 시퀀스 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;a + b&lt;/code&gt; , &lt;code&gt;a + 2*b&lt;/code&gt; , ... &lt;code&gt;c&lt;/code&gt; 를 나타 냅니다.</target>
        </trans-unit>
        <trans-unit id="24ec6755ec5d15a629cdab4809712a90cbd8c460" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; environment variable is already set, its old value will be prepended with &lt;code&gt;/foo/bar&lt;/code&gt;. On the other hand, if &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; is not set, then it will be set to &lt;code&gt;/foo/bar:&lt;/code&gt; which will have the effect of prepending &lt;code&gt;/foo/bar&lt;/code&gt; to the default depot path. If &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; is set to the empty string, it expands to an empty &lt;code&gt;DEPOT_PATH&lt;/code&gt; array. In other words, the empty string is interpreted as a zero-element array, not a one-element array of the empty string. This behavior was chosen so that it would be possible to set an empty depot path via the environment variable. If you want the default depot path, either unset the environment variable or if it must have a value, set it to the string &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; 의 환경 변수가 이미 설정되어, 옛 값으로 붙을 &lt;code&gt;/foo/bar&lt;/code&gt; . 반면에 &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; 가 설정되어 있지 않으면 &lt;code&gt;/foo/bar:&lt;/code&gt; 로 설정되어 &lt;code&gt;/foo/bar&lt;/code&gt; 를 기본 저장소 경로 앞에 추가하는 효과가 있습니다 . 경우 &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; 이 빈 문자열로 설정, 그것은 빈으로 확장 &lt;code&gt;DEPOT_PATH&lt;/code&gt; 정렬. 즉, 빈 문자열은 빈 문자열의 한 요소 배열이 아닌 0 요소 배열로 해석됩니다. 이 동작은 환경 변수를 통해 빈 저장소 경로를 설정할 수 있도록 선택되었습니다. 기본 저장소 경로를 원하는 경우,이 값이 있어야 하나 환경 변수 설정되지 않은 경우, 또는 문자열로 설정 &lt;code&gt;:&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="951a284bb764079dcd311388a60d7dc6fdec988b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JULIA_DIR&lt;/code&gt; environment variable hasn't been setup, add it using the System panel before starting Visual Studio. The &lt;code&gt;bin&lt;/code&gt; folder under JULIA_DIR should be on the system PATH.</source>
          <target state="translated">&lt;code&gt;JULIA_DIR&lt;/code&gt; 환경 변수가 설정되지 않은 경우 Visual Studio를 시작하기 전에 시스템 패널을 사용하여 추가하십시오. JULIA_DIR 아래 의 &lt;code&gt;bin&lt;/code&gt; 폴더는 시스템 PATH에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="17b0935fee49a1bcd1eec16c0060a0a58dff07ff" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; environment variable is already set, its old value will be prepended with &lt;code&gt;/foo/bar&lt;/code&gt;. On the other hand, if &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; is not set, then it will be set to &lt;code&gt;/foo/bar:&lt;/code&gt; which will expand to a &lt;code&gt;LOAD_PATH&lt;/code&gt; value of &lt;code&gt;[&quot;/foo/bar&quot;, &quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]&lt;/code&gt;. If &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; is set to the empty string, it expands to an empty &lt;code&gt;LOAD_PATH&lt;/code&gt; array. In other words, the empty string is interpreted as a zero-element array, not a one-element array of the empty string. This behavior was chosen so that it would be possible to set an empty load path via the environment variable. If you want the default load path, either unset the environment variable or if it must have a value, set it to the string &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; 의 환경 변수가 이미 설정되어, 옛 값으로 붙을 &lt;code&gt;/foo/bar&lt;/code&gt; . 반면에 &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; 가 설정되어 있지 않으면 &lt;code&gt;/foo/bar:&lt;/code&gt; 로 설정 됩니다. &lt;code&gt;LOAD_PATH&lt;/code&gt; 값이 &lt;code&gt;[&quot;/foo/bar&quot;, &quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]&lt;/code&gt; . 경우 &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; 이 빈 문자열로 설정, 그것은 빈으로 확장 &lt;code&gt;LOAD_PATH&lt;/code&gt; 정렬. 즉, 빈 문자열은 빈 문자열의 한 요소 배열이 아닌 0 요소 배열로 해석됩니다. 이 동작은 환경 변수를 통해 빈로드 경로를 설정할 수 있도록 선택되었습니다. 기본로드 경로를 원하는 경우,이 값이 있어야 하나 환경 변수 설정되지 않은 경우, 또는 문자열로 설정 &lt;code&gt;:&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c31f515fa1981bd1d01e28ffd032994e4003fc1e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;digits&lt;/code&gt; keyword argument is provided, it rounds to the specified number of digits after the decimal place (or before if negative), in base &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;digits&lt;/code&gt; 키워드 인수가 제공되고, 그것은 기본에, 소수의 장소 (또는 경우 이전에 부정적인) 후 지정된 자릿수로 반올림 &lt;code&gt;base&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f504c38da450ab2719c1e9cd12d8dd34afd33e92" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;optimize&lt;/code&gt; keyword is unset, the code will be shown before LLVM optimizations. All metadata and dbg.* calls are removed from the printed bitcode. For the full IR, set the &lt;code&gt;raw&lt;/code&gt; keyword to true. To dump the entire module that encapsulates the function (with declarations), set the &lt;code&gt;dump_module&lt;/code&gt; keyword to true. Keyword argument &lt;code&gt;debuginfo&lt;/code&gt; may be one of source (default) or none, to specify the verbosity of code comments.</source>
          <target state="translated">&lt;code&gt;optimize&lt;/code&gt; 키워드가 설정되어 있지 않으면 코드가 LLVM 최적화 전에 표시됩니다. 인쇄 된 비트 코드에서 모든 메타 데이터 및 dbg. * 호출이 제거됩니다. 전체 IR의 경우 &lt;code&gt;raw&lt;/code&gt; 키워드를 true로 설정하십시오 . 함수를 캡슐화하는 전체 모듈 (선언)을 덤프하려면 &lt;code&gt;dump_module&lt;/code&gt; 키워드를 true로 설정하십시오 . 키워드 인수 &lt;code&gt;debuginfo&lt;/code&gt; 는 소스 코드 중 하나 (기본값)이거나 코드 주석의 상세 정보를 지정하기위한 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="383ecf21766e01ab864dfe9bc7ce841c588d3356" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;sigdigits&lt;/code&gt; keyword argument is provided, it rounds to the specified number of significant digits, in base &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;sigdigits&lt;/code&gt; 키워드 인수가 제공되고, 그것은 기본에, 유효 숫자의 지정된 번호로 반올림 &lt;code&gt;base&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cee1b7494eb88d56f5f87336c27b832a3eac177f" translate="yes" xml:space="preserve">
          <source>If the C wrapper never expects the user to pass pointers to memory managed by Julia, then using &lt;code&gt;p::Ptr{gsl_permutation}&lt;/code&gt; for the method signature of the wrapper and similarly in the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; is also acceptable.</source>
          <target state="translated">C 랩퍼가 사용자가 Julia가 관리하는 메모리에 포인터를 전달할 것으로 예상하지 않으면 랩퍼 의 메소드 서명에 &lt;code&gt;p::Ptr{gsl_permutation}&lt;/code&gt; 을 사용하고 마찬가지로 &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e69c1bb25c07d7be2be84b2aa57348cae51e4053" translate="yes" xml:space="preserve">
          <source>If the above example source is saved in the file &lt;code&gt;embed_example.c&lt;/code&gt;, then the following command will compile it into a running program on Linux and Windows (MSYS2 environment), or if on OS/X, then substitute &lt;code&gt;clang&lt;/code&gt; for &lt;code&gt;gcc&lt;/code&gt;.:</source>
          <target state="translated">위 예제 소스가 &lt;code&gt;embed_example.c&lt;/code&gt; 파일에 저장된 경우 다음 명령은 Linux 및 Windows (MSYS2 환경)에서 실행중인 프로그램으로 컴파일하거나 OS / X에서 &lt;code&gt;clang&lt;/code&gt; 을 &lt;code&gt;gcc&lt;/code&gt; 로 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="9e156941127d94f84d815e5639eaa0e64bcbc457" translate="yes" xml:space="preserve">
          <source>If the above is not the case and the project file has a corresponding manifest file and the manifest contains a stanza matching &lt;code&gt;uuid&lt;/code&gt; then:</source>
          <target state="translated">위의 경우가 아니며 프로젝트 파일에 해당 매니페스트 파일이 있고 매니페스트에 &lt;code&gt;uuid&lt;/code&gt; 와 일치하는 스탠자가 포함 된 경우 :</target>
        </trans-unit>
        <trans-unit id="9f8fd643e0107bc4fc2c8bed2be168d68373f53a" translate="yes" xml:space="preserve">
          <source>If the alias is documented and not the real definition then the docsystem (&lt;code&gt;?&lt;/code&gt; mode) will not return the docstring attached to the alias when the real definition is searched for.</source>
          <target state="translated">별명이 문서화되고 실제 정의가 아닌 경우, 문서 시스템 ( &lt;code&gt;?&lt;/code&gt; 모드)은 실제 정의를 검색 할 때 별명에 첨부 된 docstring을 리턴하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3fd8dba5118a65c9f036f4528fd62b5f0cc2628" translate="yes" xml:space="preserve">
          <source>If the argument &lt;code&gt;Future&lt;/code&gt; is owned by a different node, this call will block to wait for the answer. It is recommended to wait for &lt;code&gt;rr&lt;/code&gt; in a separate task instead or to use a local &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; as a proxy:</source>
          <target state="translated">인수하면 &lt;code&gt;Future&lt;/code&gt; 다른 노드가 소유하고,이 호출은 대답을 기다리는 차단합니다. 대신 별도의 작업에서 &lt;code&gt;rr&lt;/code&gt; 을 기다리 거나 로컬 &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 을 프록시로 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="5145bb0b73803c7679be17ccbd9728f2cf20e73d" translate="yes" xml:space="preserve">
          <source>If the condition could not be evaluated because an exception was thrown, which occurs in this case because &lt;code&gt;length&lt;/code&gt; is not defined for symbols, an &lt;code&gt;Error&lt;/code&gt; object is returned and an exception is thrown:</source>
          <target state="translated">예외가 발생하여 조건을 평가할 수없는 경우 (이 경우 심볼에 &lt;code&gt;length&lt;/code&gt; 가 정의되지 않아 발생) &lt;code&gt;Error&lt;/code&gt; 오브젝트가 리턴되고 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e94faa3d332e304494043498c5a9abf524bed6e4" translate="yes" xml:space="preserve">
          <source>If the condition expression &lt;code&gt;x &amp;lt; y&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then the corresponding block is evaluated; otherwise the condition expression &lt;code&gt;x &amp;gt; y&lt;/code&gt; is evaluated, and if it is &lt;code&gt;true&lt;/code&gt;, the corresponding block is evaluated; if neither expression is true, the &lt;code&gt;else&lt;/code&gt; block is evaluated. Here it is in action:</source>
          <target state="translated">조건식 &lt;code&gt;x &amp;lt; y&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 이면 해당 블록이 평가됩니다. 그렇지 않으면 조건 표현식 &lt;code&gt;x &amp;gt; y&lt;/code&gt; 가 평가되고, &lt;code&gt;true&lt;/code&gt; 이면 해당 블록이 평가됩니다. 어느 표현식도 참이 &lt;code&gt;else&lt;/code&gt; 블록이 평가됩니다. 여기 실제로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e00b24f52421478ecff61089fe0cac3ea509a829" translate="yes" xml:space="preserve">
          <source>If the condition expression &lt;code&gt;x &amp;lt; y&lt;/code&gt; is true, then the corresponding block is evaluated; otherwise the condition expression &lt;code&gt;x &amp;gt; y&lt;/code&gt; is evaluated, and if it is true, the corresponding block is evaluated; if neither expression is true, the &lt;code&gt;else&lt;/code&gt; block is evaluated. The &lt;code&gt;elseif&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks are optional, and as many &lt;code&gt;elseif&lt;/code&gt; blocks as desired can be used.</source>
          <target state="translated">조건식 &lt;code&gt;x &amp;lt; y&lt;/code&gt; 가 true이면 해당 블록이 평가됩니다. 그렇지 않으면 조건식 &lt;code&gt;x &amp;gt; y&lt;/code&gt; 가 평가되고, 참이면 해당 블록이 평가됩니다. 어느 표현식도 참이 &lt;code&gt;else&lt;/code&gt; 블록이 평가됩니다. &lt;code&gt;elseif&lt;/code&gt; 및 &lt;code&gt;else&lt;/code&gt; 블록은 선택 사항이며, 많은으로 &lt;code&gt;elseif&lt;/code&gt; 원하는대로 블록을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03e22d8ef38f6c3785531b2aa7d1787777d83c8c" translate="yes" xml:space="preserve">
          <source>If the condition is false, then a &lt;code&gt;Fail&lt;/code&gt; is returned and an exception is thrown:</source>
          <target state="translated">조건이 false이면 &lt;code&gt;Fail&lt;/code&gt; 가 리턴되고 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6b3bbdbb81ff4f33d7f44d969bf8034d1606bc1e" translate="yes" xml:space="preserve">
          <source>If the condition is true, a &lt;code&gt;Pass&lt;/code&gt; is returned:</source>
          <target state="translated">조건이 true이면 &lt;code&gt;Pass&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cc2105b7ae7cdead96d8521e45a1f5d3d101c4e9" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;x &amp;lt; y&lt;/code&gt; is true, the entire ternary operator expression evaluates to the string &lt;code&gt;&quot;less than&quot;&lt;/code&gt; and otherwise it evaluates to the string &lt;code&gt;&quot;not less than&quot;&lt;/code&gt;. The original three-way example requires chaining multiple uses of the ternary operator together:</source>
          <target state="translated">발현이 경우 &lt;code&gt;x &amp;lt; y&lt;/code&gt; 사실, 문자열 전체 원 연산자 식 평가하여 &lt;code&gt;&quot;less than&quot;&lt;/code&gt; 과 그렇지 문자열로 평가 &lt;code&gt;&quot;not less than&quot;&lt;/code&gt; . 원래의 3 방향 예제는 3 진 연산자를 여러 번 사용하여 체인을 연결해야합니다.</target>
        </trans-unit>
        <trans-unit id="c1992d697b66c6b6347599acbdb8e5fdb9a6621c" translate="yes" xml:space="preserve">
          <source>If the first argument is a single integer &lt;code&gt;n&lt;/code&gt;, then all block rows are assumed to have &lt;code&gt;n&lt;/code&gt; block columns.</source>
          <target state="translated">첫 번째 인수가 단일 정수 &lt;code&gt;n&lt;/code&gt; 이면 모든 블록 행에 &lt;code&gt;n&lt;/code&gt; 개의 블록 열 이 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="39c79a9397806971d24321842119edaddb016dad" translate="yes" xml:space="preserve">
          <source>If the input contains &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, return &lt;code&gt;missing&lt;/code&gt; if all non-missing values are &lt;code&gt;false&lt;/code&gt; (or equivalently, if the input contains no &lt;code&gt;true&lt;/code&gt; value), following &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;.</source>
          <target state="translated">입력이 포함되어있는 경우 &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 값을 반환 &lt;code&gt;missing&lt;/code&gt; 이 아닌 모든 누락 된 값이있는 경우 &lt;code&gt;false&lt;/code&gt; (또는 동등 입력이 전혀 포함되지 않은 경우는, &lt;code&gt;true&lt;/code&gt; 가치를) 다음, &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;3 치 논리&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5db00182f423a4757b1d59390942e088eaf24587" translate="yes" xml:space="preserve">
          <source>If the input contains &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, return &lt;code&gt;missing&lt;/code&gt; if all non-missing values are &lt;code&gt;true&lt;/code&gt; (or equivalently, if the input contains no &lt;code&gt;false&lt;/code&gt; value), following &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;.</source>
          <target state="translated">입력이 포함되어있는 경우 &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 값을 반환 &lt;code&gt;missing&lt;/code&gt; 이 아닌 모든 누락 된 값이있는 경우 &lt;code&gt;true&lt;/code&gt; (또는 동등 입력이 전혀 포함되지 않은 경우는, &lt;code&gt;false&lt;/code&gt; 값) 다음, &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;3 치 논리&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8eeb9c03396e664e28a99fc47d48774045eb6d62" translate="yes" xml:space="preserve">
          <source>If the input contains &lt;a href=&quot;base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, return &lt;code&gt;missing&lt;/code&gt; if all non-missing values are &lt;code&gt;false&lt;/code&gt; (or equivalently, if the input contains no &lt;code&gt;true&lt;/code&gt; value), following &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;.</source>
          <target state="translated">입력이 포함되어있는 경우 &lt;a href=&quot;base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 값을 반환 &lt;code&gt;missing&lt;/code&gt; 이 아닌 모든 누락 된 값이있는 경우 &lt;code&gt;false&lt;/code&gt; (또는 동등 입력이 전혀 포함되지 않은 경우는, &lt;code&gt;true&lt;/code&gt; 가치를) 다음, &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;3 치 논리&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2728419995e95b64eb82cdbd209797e56617a7a2" translate="yes" xml:space="preserve">
          <source>If the input contains &lt;a href=&quot;base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, return &lt;code&gt;missing&lt;/code&gt; if all non-missing values are &lt;code&gt;true&lt;/code&gt; (or equivalently, if the input contains no &lt;code&gt;false&lt;/code&gt; value), following &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;.</source>
          <target state="translated">입력이 포함되어있는 경우 &lt;a href=&quot;base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 값을 반환 &lt;code&gt;missing&lt;/code&gt; 이 아닌 모든 누락 된 값이있는 경우 &lt;code&gt;true&lt;/code&gt; (또는 동등 입력이 전혀 포함되지 않은 경우는, &lt;code&gt;false&lt;/code&gt; 값) 다음, &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;3 치 논리&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43376b031124803be76025ed520e15accd07f21d" translate="yes" xml:space="preserve">
          <source>If the julia program needs to access symbols from the main executable, it may be necessary to add &lt;code&gt;-Wl,--export-dynamic&lt;/code&gt; linker flag at compile time on Linux in addition to the ones generated by &lt;code&gt;julia-config.jl&lt;/code&gt; described below. This is not necessary when compiling a shared library.</source>
          <target state="translated">julia 프로그램이 기본 실행 파일에서 심볼에 액세스해야하는 경우 &lt;code&gt;-Wl,--export-dynamic&lt;/code&gt; 아래 설명 된 &lt;code&gt;julia-config.jl&lt;/code&gt; 에 의해 생성 된 것 외에도 Linux에서 컴파일 타임에 -Wl, --export-dynamic 링커 플래그 를 추가해야 할 수도 있습니다 . 공유 라이브러리를 컴파일 할 때는 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a36bc8b8e7c85e66ed4f1f189a3aca52b1c00920" translate="yes" xml:space="preserve">
          <source>If the keyword argument &lt;code&gt;parallel&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;peakflops&lt;/code&gt; is run in parallel on all the worker processors. The flop rate of the entire parallel computer is returned. When running in parallel, only 1 BLAS thread is used. The argument &lt;code&gt;n&lt;/code&gt; still refers to the size of the problem that is solved on each processor.</source>
          <target state="translated">키워드 인수하면 &lt;code&gt;parallel&lt;/code&gt; 설정되어 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;peakflops&lt;/code&gt; 는 모든 작업자 프로세서에서 병렬로 실행됩니다. 전체 병렬 컴퓨터의 플롭 속도가 반환됩니다. 병렬로 실행할 때는 1 개의 BLAS 스레드 만 사용됩니다. 인수 &lt;code&gt;n&lt;/code&gt; 은 여전히 각 프로세서에서 해결되는 문제의 크기를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8e60aaeb2ffed3f0c824ded63844d08244a81e67" translate="yes" xml:space="preserve">
          <source>If the last component of a path contains a dot, split the path into everything before the dot and everything including and after the dot. Otherwise, return a tuple of the argument unmodified and the empty string.</source>
          <target state="translated">패스의 마지막 구성 요소에 점이 포함 된 경우 경로를 점 앞의 모든 점과 점 포함 및 뒤의 모든 부분으로 분할합니다. 그렇지 않으면, 수정되지 않은 인수와 빈 문자열의 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="474f41b19a8b8b1c73bfdf0eee429dd261cef652" translate="yes" xml:space="preserve">
          <source>If the library cannot be found, this method throws an error, unless the keyword argument &lt;code&gt;throw_error&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt;, in which case this method returns &lt;code&gt;nothing&lt;/code&gt;.</source>
          <target state="translated">라이브러리를 찾을 수없는 경우 키워드 인수 &lt;code&gt;throw_error&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 로 설정되어 있지 않으면이 메소드는 오류를 발생 시킵니다 . 이 경우이 메소드는 &lt;code&gt;nothing&lt;/code&gt; 반환 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="87fd4485b83cceeff36ce0886165792add3d72c0" translate="yes" xml:space="preserve">
          <source>If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal situation and terminates. This timeout can be controlled via environment variable &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt;. The value of &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; on the master process specifies the number of seconds a newly launched worker waits for connection establishment.</source>
          <target state="translated">마스터 프로세스가 60.0 초 내에 새로 시작된 작업자와 연결을 설정하지 못하면 작업자는이를 치명적인 상황으로 처리하고 종료합니다. 이 시간 초과는 환경 변수 &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; 을 통해 제어 할 수 있습니다 . 마스터 프로세스 에서 &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; 값은 새로 시작된 작업자가 연결 설정을 기다리는 시간 (초)을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="1862e9ef97d71a1468775f4ed8202c8fd632c055" translate="yes" xml:space="preserve">
          <source>If the memory is already owned by Julia, or is an &lt;code&gt;isbits&lt;/code&gt; type, and is known to be non-null:</source>
          <target state="translated">메모리가 이미 Julia가 소유하고 있거나 &lt;code&gt;isbits&lt;/code&gt; 유형이고 널이 아닌 것으로 알려진 경우 :</target>
        </trans-unit>
        <trans-unit id="da0b487002a4f8f988224bf9329d865f41bc0778" translate="yes" xml:space="preserve">
          <source>If the memory is owned by C:</source>
          <target state="translated">C가 메모리를 소유 한 경우 :</target>
        </trans-unit>
        <trans-unit id="f1a7911f936ea8810a1eaa7a8869f8e6799d2d65" translate="yes" xml:space="preserve">
          <source>If the numerator and denominator of a rational have common factors, they are reduced to lowest terms such that the denominator is non-negative:</source>
          <target state="translated">유리수의 분자와 분모가 공약수를 가지면 분모가 음이 아닌 가장 낮은 항으로 감소됩니다.</target>
        </trans-unit>
        <trans-unit id="0a769d477ab736aacb751c850c5686d3d0e58a61" translate="yes" xml:space="preserve">
          <source>If the optional vector of eigenvalues &lt;code&gt;eigvals&lt;/code&gt; is specified, &lt;code&gt;eigvecs&lt;/code&gt; returns the specific corresponding eigenvectors.</source>
          <target state="translated">고유 값 &lt;code&gt;eigvals&lt;/code&gt; 의 선택적 벡터 가 지정된 경우 &lt;code&gt;eigvecs&lt;/code&gt; 는 특정 고유 고유 벡터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0f4dba4502da69dc32bb858b6da003d9801f45e4" translate="yes" xml:space="preserve">
          <source>If the pointer of interest is a plain-data array (primitive type or immutable struct), the function &lt;code&gt;unsafe_wrap(Array, ptr,dims, own = false)&lt;/code&gt; may be more useful. The final parameter should be true if Julia should &quot;take ownership&quot; of the underlying buffer and call &lt;code&gt;free(ptr)&lt;/code&gt; when the returned &lt;code&gt;Array&lt;/code&gt; object is finalized. If the &lt;code&gt;own&lt;/code&gt; parameter is omitted or false, the caller must ensure the buffer remains in existence until all access is complete.</source>
          <target state="translated">관심있는 포인터가 일반 데이터 배열 (원시 유형 또는 변경 불가능한 구조체) 인 경우 &lt;code&gt;unsafe_wrap(Array, ptr,dims, own = false)&lt;/code&gt; 함수 가 더 유용 할 수 있습니다. Julia가 기본 버퍼의 &quot;소유권을 가져와&quot; 반환 된 &lt;code&gt;Array&lt;/code&gt; 객체가 종료 될 때 &lt;code&gt;free(ptr)&lt;/code&gt; 호출해야하는 경우 최종 매개 변수는 true 여야합니다 . 경우 &lt;code&gt;own&lt;/code&gt; 매개 변수를 생략 또는 false 모든 액세스가 완료 될 때까지, 호출자는 존재 버퍼 유해를 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="0a512e781dfe335955a62e8e7a271098861da5ec" translate="yes" xml:space="preserve">
          <source>If the project file in the directory matches &lt;code&gt;uuid&lt;/code&gt; and name &lt;code&gt;X&lt;/code&gt;, then either:</source>
          <target state="translated">디렉토리의 프로젝트 파일이 &lt;code&gt;uuid&lt;/code&gt; 및 이름 &lt;code&gt;X&lt;/code&gt; 와 일치 하면 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="bf4eb78a003bcabdcd8e4f19b55a5c4f0ed307f6" translate="yes" xml:space="preserve">
          <source>If the regular expression does not match the given string, &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; returns &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; &amp;ndash; a special value that does not print anything at the interactive prompt. Other than not printing, it is a completely normal value and you can test for it programmatically:</source>
          <target state="translated">If the regular expression does not match the given string, &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt; returns &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; &amp;ndash; a special value that does not print anything at the interactive prompt. Other than not printing, it is a completely normal value and you can test for it programmatically:</target>
        </trans-unit>
        <trans-unit id="ee4c72df00bad1d261a873768e4600ba229c34af" translate="yes" xml:space="preserve">
          <source>If the type were declared &lt;code&gt;mutable&lt;/code&gt;, you could reach in and directly change the field values to violate this invariant. Of course, messing around with an object's internals uninvited is bad practice. You (or someone else) can also provide additional outer constructor methods at any later point, but once a type is declared, there is no way to add more inner constructor methods. Since outer constructor methods can only create objects by calling other constructor methods, ultimately, some inner constructor must be called to create an object. This guarantees that all objects of the declared type must come into existence by a call to one of the inner constructor methods provided with the type, thereby giving some degree of enforcement of a type's invariants.</source>
          <target state="translated">유형이 &lt;code&gt;mutable&lt;/code&gt; 하다고 선언 된 경우이 불변 값을 위반하도록 필드 값을 직접 입력하여 필드 값을 변경할 수 있습니다. 물론, 초대받지 않은 객체의 내부를 어지럽히는 것은 나쁜 습관입니다. 당신 (또는 다른 사람)은 나중에 추가 외부 생성자 메서드를 제공 할 수 있지만 유형이 선언되면 더 많은 내부 생성자 메서드를 추가 할 수있는 방법이 없습니다. 외부 생성자 메소드는 다른 생성자 메소드를 호출하여 오브젝트를 작성할 수 있으므로 궁극적으로 오브젝트를 작성하려면 일부 내부 생성자를 호출해야합니다. 이렇게하면 선언 된 형식의 모든 개체가 형식과 함께 제공된 내부 생성자 메서드 중 하나를 호출하여 존재해야하므로 형식의 불변 값을 어느 정도 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01f0d92fa173f69330393a510ea1e6b5d8ca8533" translate="yes" xml:space="preserve">
          <source>If the value of the environment variable begins with the character &lt;code&gt;'r'&lt;/code&gt;, then the interval between garbage collection events is randomized.</source>
          <target state="translated">환경 변수의 값이 문자 &lt;code&gt;'r'&lt;/code&gt; 로 시작하면 가비지 콜렉션 이벤트 간격이 무작위입니다.</target>
        </trans-unit>
        <trans-unit id="820aaeab0441978d6dfdcb42b5456e2d42286bc7" translate="yes" xml:space="preserve">
          <source>If the variable is immutable, then it needs to be wrapped in an equivalent mutable container or, preferably, in a &lt;code&gt;RefValue{Any}&lt;/code&gt; before it is pushed to &lt;code&gt;IdDict&lt;/code&gt;. In this approach, the container has to be created or filled in via C code using, for example, the function &lt;code&gt;jl_new_struct&lt;/code&gt;. If the container is created by &lt;code&gt;jl_call*&lt;/code&gt;, then you will need to reload the pointer to be used in C code.</source>
          <target state="translated">변수가 변경 불가능한 경우 변수는 동등한 변경 가능 컨테이너 또는 바람직하게는 &lt;code&gt;RefValue{Any}&lt;/code&gt; 에 &lt;code&gt;IdDict&lt;/code&gt; 되어 IdDict 로 푸시되어야 합니다 . 이 접근법에서 컨테이너는 예를 들어 &lt;code&gt;jl_new_struct&lt;/code&gt; 함수를 사용하여 C 코드를 통해 작성되거나 채워 져야 합니다. 컨테이너가 &lt;code&gt;jl_call*&lt;/code&gt; 의해 작성되면 C 코드에서 사용할 포인터를 다시로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="fdaae9a23c5ac63bef99dbd5a31ebb51593f593b" translate="yes" xml:space="preserve">
          <source>If these default definitions are not wanted, modules can be defined using the keyword &lt;a href=&quot;../../base/base/index#baremodule&quot;&gt;&lt;code&gt;baremodule&lt;/code&gt;&lt;/a&gt; instead (note: &lt;code&gt;Core&lt;/code&gt; is still imported, as per above). In terms of &lt;code&gt;baremodule&lt;/code&gt;, a standard &lt;code&gt;module&lt;/code&gt; looks like this:</source>
          <target state="translated">이러한 기본 정의를 원하지 않으면 키워드 &lt;a href=&quot;../../base/base/index#baremodule&quot;&gt; &lt;code&gt;baremodule&lt;/code&gt; 을&lt;/a&gt; 사용하여 모듈을 정의 할 수 있습니다 (참고 : 위와 같이 &lt;code&gt;Core&lt;/code&gt; 를 계속 가져 옵니다 ). 측면에서 &lt;code&gt;baremodule&lt;/code&gt; , 표준 &lt;code&gt;module&lt;/code&gt; 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="c97bc8058490cb5b35c86c1a7b0a8b4a5dcbea0d" translate="yes" xml:space="preserve">
          <source>If this example were rewritten to use a &lt;code&gt;for&lt;/code&gt; keyword for each variable, then the output would be different: the second and fourth values would contain &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">이 예제가 각 변수에 &lt;code&gt;for&lt;/code&gt; 키워드 를 사용하도록 다시 작성된 경우 출력이 달라집니다. 두 번째 및 네 번째 값에는 &lt;code&gt;0&lt;/code&gt; 이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="38daf5829da47e0525cef7ca98a723264df0b06d" translate="yes" xml:space="preserve">
          <source>If this file refers to a device, the ID of the device it refers to</source>
          <target state="translated">이 파일이 장치를 참조하면 해당 장치의 ID</target>
        </trans-unit>
        <trans-unit id="0d9cafaaf4c7067eb590c8bf606a63edc65e8a80" translate="yes" xml:space="preserve">
          <source>If this is a recursive lock which has been acquired before, decrement an internal counter and return immediately.</source>
          <target state="translated">이전에 획득 한 재귀 잠금 인 경우 내부 카운터를 줄이고 즉시 돌아옵니다.</target>
        </trans-unit>
        <trans-unit id="63b7f441c98451c302d3c2456a6e97efda6509d1" translate="yes" xml:space="preserve">
          <source>If this is all extremely confusing, try reading &lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;&quot;The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets&quot;&lt;/a&gt;. It's an excellent introduction to Unicode and UTF-8, and may help alleviate some confusion regarding the matter.</source>
          <target state="translated">이것이 매우 혼란스러운 경우, &lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;&quot;절대적으로 모든 소프트웨어 개발자가 절대적으로 유니 코드 및 문자 집합에 대해 알아야 함&quot;을&lt;/a&gt; 읽어보십시오 . 이것은 유니 코드 및 UTF-8에 대한 훌륭한 소개이며, 문제와 관련된 약간의 혼란을 완화하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b40c130d40171e44a3b89ef397dcc6ac5ad60b6" translate="yes" xml:space="preserve">
          <source>If unspecified, &lt;code&gt;rmprocs&lt;/code&gt; will wait until all requested &lt;code&gt;pids&lt;/code&gt; are removed.</source>
          <target state="translated">지정하지 않으면 &lt;code&gt;rmprocs&lt;/code&gt; 는 요청 된 모든 &lt;code&gt;pids&lt;/code&gt; 가 제거 될 때까지 기다립니다 .</target>
        </trans-unit>
        <trans-unit id="7a6ee4e75683acdd450d6763b02459999f504699" translate="yes" xml:space="preserve">
          <source>If we also wanted to test the debug messages, these need to be enabled with the &lt;code&gt;min_level&lt;/code&gt; keyword:</source>
          <target state="translated">디버그 메시지도 테스트하려면 &lt;code&gt;min_level&lt;/code&gt; 키워드를 사용하여 활성화해야 합니다.</target>
        </trans-unit>
        <trans-unit id="61986d68f0f6799ea1176f1c31636a4efe0c3579" translate="yes" xml:space="preserve">
          <source>If we create &lt;code&gt;SharedArray&lt;/code&gt;s and time these functions, we get the following results (with &lt;code&gt;julia -p 4&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;SharedArray&lt;/code&gt; 를 작성 하고 이러한 함수의 시간을 정하면 다음과 같은 결과가 나타납니다 ( &lt;code&gt;julia -p 4&lt;/code&gt; 사용 ).</target>
        </trans-unit>
        <trans-unit id="a1227c57ad13fa72c3a7892e71df86ffd4baf6f1" translate="yes" xml:space="preserve">
          <source>If we expect that evaluating an expression &lt;em&gt;should&lt;/em&gt; throw an exception, then we can use &lt;code&gt;@test_throws&lt;/code&gt; to check that this occurs:</source>
          <target state="translated">표현식을 평가할 때 예외가 발생 &lt;em&gt;해야한다고&lt;/em&gt; 생각하면 &lt;code&gt;@test_throws&lt;/code&gt; 를 사용 하여 이러한 상황이 발생하는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0245cafc71ed8d5f923ae289b03588ae96f1d3b5" translate="yes" xml:space="preserve">
          <source>If we instead pass &lt;code&gt;x&lt;/code&gt; as an argument to the function it no longer allocates memory (the allocation reported below is due to running the &lt;code&gt;@time&lt;/code&gt; macro in global scope) and is significantly faster after the first call:</source>
          <target state="translated">대신 &lt;code&gt;x&lt;/code&gt; 를 함수에 인수로 전달 하면 더 이상 메모리를 할당하지 않으며 (아래에보고 된 할당 은 전역 범위에서 &lt;code&gt;@time&lt;/code&gt; 매크로 를 실행하기 때문에 발생합니다 ) 첫 번째 호출 후에 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="ad5a88256f096da52ec6c3ef7cb82d3f97728f34" translate="yes" xml:space="preserve">
          <source>If we want it to display instead as &lt;code&gt;3.0 * exp(4.0im)&lt;/code&gt;, we would define the following method to print the object to a given output object &lt;code&gt;io&lt;/code&gt; (representing a file, terminal, buffer, etcetera; see &lt;a href=&quot;../networking-and-streams/index#Networking-and-Streams-1&quot;&gt;Networking and Streams&lt;/a&gt;):</source>
          <target state="translated">우리가로 대신 표시 할 경우 &lt;code&gt;3.0 * exp(4.0im)&lt;/code&gt; , 우리는 주어진 출력 오브젝트의 오브젝트를 인쇄하기 방법을 정의 할 &lt;code&gt;io&lt;/code&gt; (등등 파일을 나타내는 단말 버퍼; 참조 &lt;a href=&quot;../networking-and-streams/index#Networking-and-Streams-1&quot;&gt;네트워킹 스트림&lt;/a&gt; ) :</target>
        </trans-unit>
        <trans-unit id="a3d5a08a0cd3e04540689d3b049bf572b10229ab" translate="yes" xml:space="preserve">
          <source>If you apply &lt;a href=&quot;../../base/base/index#Base.supertype&quot;&gt;&lt;code&gt;supertype&lt;/code&gt;&lt;/a&gt; to other type objects (or non-type objects), a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; is raised:</source>
          <target state="translated">다른 유형의 객체 (또는 유형이 아닌 객체)에 &lt;a href=&quot;../../base/base/index#Base.supertype&quot;&gt; &lt;code&gt;supertype&lt;/code&gt; &lt;/a&gt; 을 적용 하면 &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a311e1352bca4f5ac56973ae4e9111089c7fd93d" translate="yes" xml:space="preserve">
          <source>If you are defining a method &quot;cascade&quot; that supplies defaults, be careful about dropping any arguments that correspond to potential defaults. For example, suppose you're writing a digital filtering algorithm and you have a method that handles the edges of the signal by applying padding:</source>
          <target state="translated">기본값을 제공하는 &quot;계단식&quot;메소드를 정의하는 경우 잠재적 인 기본값에 해당하는 인수를 삭제하지 않도록주의하십시오. 예를 들어 디지털 필터링 알고리즘을 작성하고 패딩을 적용하여 신호의 가장자리를 처리하는 방법이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="1ec45be5f3cad18e0598bb550f7ab8781aa51939" translate="yes" xml:space="preserve">
          <source>If you are defining an array type that allows non-traditional indexing (indices that start at something other than 1), you should specialize &lt;code&gt;axes&lt;/code&gt;. You should also specialize &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt;&lt;code&gt;similar&lt;/code&gt;&lt;/a&gt; so that the &lt;code&gt;dims&lt;/code&gt; argument (ordinarily a &lt;code&gt;Dims&lt;/code&gt; size-tuple) can accept &lt;code&gt;AbstractUnitRange&lt;/code&gt; objects, perhaps range-types &lt;code&gt;Ind&lt;/code&gt; of your own design. For more information, see &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/offset-arrays/#man-custom-indices-1&quot;&gt;Arrays with custom indices&lt;/a&gt;.</source>
          <target state="translated">비 전통적인 인덱싱 (1 이외의 것으로 시작하는 인덱스)을 허용하는 배열 유형을 정의하는 경우 &lt;code&gt;axes&lt;/code&gt; 를 특수화해야합니다 . 또한 전문한다 &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt; &lt;code&gt;similar&lt;/code&gt; &lt;/a&gt; 너무 &lt;code&gt;dims&lt;/code&gt; 인수 (통상 &lt;code&gt;Dims&lt;/code&gt; 크기 튜플) 받아 들일 수 &lt;code&gt;AbstractUnitRange&lt;/code&gt; 는 아마도 객체 범위 - 유형 &lt;code&gt;Ind&lt;/code&gt; 자신의 디자인을. 자세한 내용 &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/offset-arrays/#man-custom-indices-1&quot;&gt;은 사용자 정의 인덱스가있는 배열을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e74f29b3463d83a18c14379e83918c00f3cf63aa" translate="yes" xml:space="preserve">
          <source>If you are ever stuck, you can ask &lt;code&gt;Pkg&lt;/code&gt; for help:</source>
          <target state="translated">갇혀 있다면 &lt;code&gt;Pkg&lt;/code&gt; 에 도움을 요청할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8735c4e810f6e4e3ffda27e1b3f1ab39f60104c6" translate="yes" xml:space="preserve">
          <source>If you are using the Julia C API from a language that supports exceptions (e.g. Python, C#, C++), it makes sense to wrap each call into &lt;code&gt;libjulia&lt;/code&gt; with a function that checks whether an exception was thrown, and then rethrows the exception in the host language.</source>
          <target state="translated">예외를 지원하는 언어 (예 : Python, C #, C ++)에서 Julia C API를 사용하는 경우 예외가 발생했는지 확인한 함수를 사용하여 각 호출을 &lt;code&gt;libjulia&lt;/code&gt; 로 랩핑 한 다음 예외를 다시 throw하는 것이 좋습니다 . 호스트 언어.</target>
        </trans-unit>
        <trans-unit id="9d33189460471265e09a2493a0c7846b4727b27d" translate="yes" xml:space="preserve">
          <source>If you call it in an interactive session without assigning the return value anywhere, you will see the tuple returned:</source>
          <target state="translated">어디서나 리턴 값을 지정하지 않고 대화식 세션에서 호출하면 튜플이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="757e93c7d7c03576f2e8bdb2961d5a609265324d" translate="yes" xml:space="preserve">
          <source>If you define both styles of indexing for your &lt;code&gt;AbstractArray&lt;/code&gt;, this trait can be used to select the most performant indexing style. Some methods check this trait on their inputs, and dispatch to different algorithms depending on the most efficient access pattern. In particular, &lt;a href=&quot;#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt; creates an iterator whose type depends on the setting of this trait.</source>
          <target state="translated">&lt;code&gt;AbstractArray&lt;/code&gt; 에 대해 두 가지 색인 스타일을 모두 정의하면 이 특성을 사용하여 가장 성능이 우수한 색인 스타일을 선택할 수 있습니다. 일부 방법은 입력에서이 특성을 확인하고 가장 효율적인 액세스 패턴에 따라 다른 알고리즘으로 디스패치합니다. 특히, 각 &lt;a href=&quot;#Base.eachindex&quot;&gt; &lt;code&gt;eachindex&lt;/code&gt; &lt;/a&gt; 는이 특성의 설정에 따라 유형이 반복자를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0561f634340ef3ef5927debe41e5dcc4c8cce30a" translate="yes" xml:space="preserve">
          <source>If you examine the contents of &lt;code&gt;hello.txt&lt;/code&gt; at this point, you will notice that it is empty; nothing has actually been written to disk yet. This is because the &lt;code&gt;IOStream&lt;/code&gt; must be closed before the write is actually flushed to disk:</source>
          <target state="translated">이 시점에서 &lt;code&gt;hello.txt&lt;/code&gt; 의 내용을 살펴보면 내용 이 비어 있음을 알 수 있습니다. 실제로 디스크에는 아직 기록 된 것이 없습니다. 쓰기가 실제로 디스크로 플러시되기 전에 &lt;code&gt;IOStream&lt;/code&gt; 을 닫아야하기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="4eaa143836add2b691eb62610bcaeb5c4d609829" translate="yes" xml:space="preserve">
          <source>If you have a type that uses a native pointer:</source>
          <target state="translated">기본 포인터를 사용하는 유형이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="aaf9e1541b4bdb0c52c8f375b573b49db90dd938" translate="yes" xml:space="preserve">
          <source>If you have code that you want executed whenever Julia is run, you can put it in &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt;:</source>
          <target state="translated">Julia가 실행될 때마다 실행할 코드가 있으면 &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; 에 넣을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c6993e56b8a3ed1437873eaf20d58be9dd8dc4fb" translate="yes" xml:space="preserve">
          <source>If you have data in CSC format from a different application or library, and wish to import it in Julia, make sure that you use 1-based indexing. The row indices in every column need to be sorted. If your &lt;code&gt;SparseMatrixCSC&lt;/code&gt; object contains unsorted row indices, one quick way to sort them is by doing a double transpose.</source>
          <target state="translated">다른 응용 프로그램 또는 라이브러리의 CSC 형식의 데이터가 있고 Julia에서 가져 오려면 1 기반 색인 작성을 사용해야합니다. 모든 열의 행 인덱스를 정렬해야합니다. &lt;code&gt;SparseMatrixCSC&lt;/code&gt; 객체에 정렬되지 않은 행 인덱스가 포함되어 있으면이를 빠르게 정렬하는 방법은 이중 전치를 수행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="be1012643129d3902e3bcc736a2f09368b135cc7" translate="yes" xml:space="preserve">
          <source>If you interpolate an array as part of a shell word, Julia emulates the shell's &lt;code&gt;{a,b,c}&lt;/code&gt; argument generation:</source>
          <target state="translated">쉘 단어의 일부로 배열을 보간하는 경우 Julia는 쉘의 &lt;code&gt;{a,b,c}&lt;/code&gt; 인수 생성을 에뮬레이트합니다 .</target>
        </trans-unit>
        <trans-unit id="66c0ea7806057d283c6cb2263bc03f2b5f51cca2" translate="yes" xml:space="preserve">
          <source>If you know that a module is &lt;em&gt;not&lt;/em&gt; safe to precompile your module (for example, for one of the reasons described below), you should put &lt;code&gt;__precompile__(false)&lt;/code&gt; in the module file (typically placed at the top). This will cause &lt;code&gt;Base.compilecache&lt;/code&gt; to throw an error, and will cause &lt;code&gt;using&lt;/code&gt; / &lt;code&gt;import&lt;/code&gt; to load it directly into the current process and skip the precompile and caching. This also thereby prevents the module from being imported by any other precompiled module.</source>
          <target state="translated">모듈이 프리 컴파일하기에 안전 &lt;em&gt;하지 않다는&lt;/em&gt; 것을 알고 있다면 (예를 들어, 아래에 설명 된 이유 중 하나), &lt;code&gt;__precompile__(false)&lt;/code&gt; 를 모듈 파일 (일반적으로 맨 위에 배치 ) 에 두어야합니다 . 이로 인해 &lt;code&gt;Base.compilecache&lt;/code&gt; 에서 오류가 발생 &lt;code&gt;using&lt;/code&gt; / &lt;code&gt;import&lt;/code&gt; 를 사용 하여 현재 프로세스로 직접로드하고 사전 컴파일 및 캐싱을 건너 뜁니다. 따라서 다른 사전 컴파일 된 모듈에서 모듈을 가져 오지 못하게됩니다.</target>
        </trans-unit>
        <trans-unit id="9119dc7e0716f5e2cbcc069fcd20399d5871b899" translate="yes" xml:space="preserve">
          <source>If you need to dispatch on multiple arguments, and there are many fallbacks with too many combinations to make it practical to define all possible variants, then consider introducing a &quot;name cascade&quot; where (for example) you dispatch on the first argument and then call an internal method:</source>
          <target state="translated">여러 인수를 디스패치해야하고 가능한 모든 변형을 정의하기에 너무 많은 조합으로 대체 된 폴 백이있는 경우, 예를 들어 첫 번째 인수에서 디스패치 한 다음 &quot;name cascade&quot;를 도입하는 것이 좋습니다. 내부 방법 :</target>
        </trans-unit>
        <trans-unit id="76f3bebbfec4cfb424affa402369c33eff6a7949" translate="yes" xml:space="preserve">
          <source>If you need to obtain valid indices for a string, you can use the &lt;a href=&quot;../../base/strings/index#Base.nextind&quot;&gt;&lt;code&gt;nextind&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/strings/index#Base.prevind&quot;&gt;&lt;code&gt;prevind&lt;/code&gt;&lt;/a&gt; functions to increment/decrement to the next/previous valid index, as mentioned above. You can also use the &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt; function to iterate over the valid character indices:</source>
          <target state="translated">문자열에 유효한 인덱스를 가져와야 할 경우, &lt;a href=&quot;../../base/strings/index#Base.nextind&quot;&gt; &lt;code&gt;nextind&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/strings/index#Base.prevind&quot;&gt; &lt;code&gt;prevind&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 위에서 언급 한대로 다음 / 이전 유효한 인덱스로 증가 / 감소 할 수 있습니다 . &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt; &lt;code&gt;eachindex&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 유효한 문자 인덱스를 반복 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="801f3bd6c180fb1f8c8c459f54a17ac585429686" translate="yes" xml:space="preserve">
          <source>If you specify a &lt;code&gt;branch&lt;/code&gt;, this must be done in reference format, since the string will be turned into a &lt;code&gt;GitReference&lt;/code&gt;. For example, if you wanted to merge branch &lt;code&gt;branch_a&lt;/code&gt;, you would call &lt;code&gt;merge!(repo, branch=&quot;refs/heads/branch_a&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;branch&lt;/code&gt; 를 지정 하면 문자열이 &lt;code&gt;GitReference&lt;/code&gt; 로 변환되므로 참조 형식으로 수행해야합니다 . 예를 들어 &lt;code&gt;branch_a&lt;/code&gt; 분기를 병합 하려면 &lt;code&gt;merge!(repo, branch=&quot;refs/heads/branch_a&quot;)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="12b4daadf4d05ca4bd1781bb32cf57f260bb2750" translate="yes" xml:space="preserve">
          <source>If you supply more than one &lt;code&gt;AbstractArray&lt;/code&gt; argument, &lt;code&gt;eachindex&lt;/code&gt; will create an iterable object that is fast for all arguments (a &lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt;&lt;code&gt;UnitRange&lt;/code&gt;&lt;/a&gt; if all inputs have fast linear indexing, a &lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt; otherwise). If the arrays have different sizes and/or dimensionalities, &lt;code&gt;eachindex&lt;/code&gt; will return an iterable that spans the largest range along each dimension.</source>
          <target state="translated">둘 이상의 &lt;code&gt;AbstractArray&lt;/code&gt; 인수를 제공하면 각 &lt;code&gt;eachindex&lt;/code&gt; 는 모든 인수에 대해 빠른 반복 가능한 객체를 만듭니다 ( 모든 입력에 빠른 선형 색인이 있으면 &lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt; &lt;code&gt;UnitRange&lt;/code&gt; &lt;/a&gt; , 그렇지 않으면 &lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt; &lt;code&gt;CartesianIndices&lt;/code&gt; &lt;/a&gt; ). 배열의 크기 및 / 또는 차원이 다른 경우 각 &lt;code&gt;eachindex&lt;/code&gt; 는 각 차원을 따라 가장 큰 범위에 걸쳐있는 이터 러블 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0bf64552bec6648b4a2dbc60f5636537b6e39be4" translate="yes" xml:space="preserve">
          <source>If you want a quantity that is of the same type as &lt;code&gt;x&lt;/code&gt;, or of type &lt;code&gt;T&lt;/code&gt;, even if &lt;code&gt;x&lt;/code&gt; is dimensionful, use &lt;a href=&quot;#Base.oneunit&quot;&gt;&lt;code&gt;oneunit&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 동일한 유형 또는 &lt;code&gt;T&lt;/code&gt; 유형의 수량을 원할 경우 &lt;code&gt;x&lt;/code&gt; 가 차원이 있더라도 하나의 &lt;a href=&quot;#Base.oneunit&quot;&gt; &lt;code&gt;oneunit&lt;/code&gt; &lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0d6bdd166c95ac54bc84be65e3c70b26b5a5d3fc" translate="yes" xml:space="preserve">
          <source>If you want to &lt;em&gt;avoid&lt;/em&gt; adding dots for selected function calls in &lt;code&gt;expr&lt;/code&gt;, splice those function calls in with &lt;code&gt;$&lt;/code&gt;. For example, &lt;code&gt;@. sqrt(abs($sort(x)))&lt;/code&gt; is equivalent to &lt;code&gt;sqrt.(abs.(sort(x)))&lt;/code&gt; (no dot for &lt;code&gt;sort&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt; 에서 선택된 함수 호출에 점을 추가 &lt;em&gt;하지 않으&lt;/em&gt; 려면 해당 함수 호출을 &lt;code&gt;$&lt;/code&gt; 로 결합하십시오 . 예를 들어 &lt;code&gt;@. sqrt(abs($sort(x)))&lt;/code&gt; sqrt (abs ($ sort (x))) 는 &lt;code&gt;sqrt.(abs.(sort(x)))&lt;/code&gt; ( &lt;code&gt;sort&lt;/code&gt; 대한 점 없음 ).</target>
        </trans-unit>
        <trans-unit id="683a65524138ed99d613028444b793379d0ca4fd" translate="yes" xml:space="preserve">
          <source>If you want to extract a character from a string, you index into it:</source>
          <target state="translated">문자열에서 문자를 추출하려면 색인을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="af6bdcdecfb445706192e5de8fd952192d9e2d0e" translate="yes" xml:space="preserve">
          <source>If you want to read the output of the external command, &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; can be used instead:</source>
          <target state="translated">외부 명령의 출력을 읽으려면 대신 &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; 를&lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66677df9764417ef6a9289f8e4f6bf8274c36caa" translate="yes" xml:space="preserve">
          <source>If you want to use logging as an audit trail you should disable this for your logger type.</source>
          <target state="translated">감사 추적으로 로깅을 사용하려면 로거 유형에 대해이를 사용 안함으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="e7c7d63501e2b9d2d6b42831c4f6216f8a461efd" translate="yes" xml:space="preserve">
          <source>If you want to write to a file, you can open it with the write (&lt;code&gt;&quot;w&quot;&lt;/code&gt;) flag:</source>
          <target state="translated">파일에 쓰려면 write ( &lt;code&gt;&quot;w&quot;&lt;/code&gt; ) 플래그 로 파일을 열 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c3b03f51e5a4a15df40aa0cdfd2977b041193157" translate="yes" xml:space="preserve">
          <source>If you were to profile &lt;code&gt;dumbsum3&lt;/code&gt;, and a backtrace was taken while it was executing &lt;code&gt;dumbsum(1)&lt;/code&gt;, the backtrace would look like this:</source>
          <target state="translated">&lt;code&gt;dumbsum3&lt;/code&gt; 을 프로파일 링 하고 &lt;code&gt;dumbsum(1)&lt;/code&gt; 실행하는 동안 역 추적을 수행 한 경우 역 추적은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0bc4f596ffa41c5fb93ede00ad1673e3a89c26be" translate="yes" xml:space="preserve">
          <source>If you wish to specialize on a particular style &lt;code&gt;DestStyle&lt;/code&gt;, define a method for</source>
          <target state="translated">특정 스타일 &lt;code&gt;DestStyle&lt;/code&gt; 을 전문화하려면에 대한 메소드를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="f81fa178f278896f499b8c79cc33cce8975b52ac" translate="yes" xml:space="preserve">
          <source>If you write a custom &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray&lt;/code&gt;&lt;/a&gt; type, you can specify that it has fast linear indexing using</source>
          <target state="translated">사용자 정의 &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray&lt;/code&gt; &lt;/a&gt; 유형 을 작성하는 경우 다음을 사용하여 빠른 선형 색인 작성을 지정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="731e84cb8afd8370c60140146ac6c2a5c345b233" translate="yes" xml:space="preserve">
          <source>If you write generic code which handles numbers, and which can be expected to run with many different numeric type arguments, try using literals of a numeric type that will affect the arguments as little as possible through promotion.</source>
          <target state="translated">숫자를 처리하고 많은 다른 숫자 유형 인수로 실행될 수있는 일반 코드를 작성하는 경우 승격을 통해 인수에 거의 영향을 미치지 않는 숫자 유형의 리터럴을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dcea13c507e05364e2e2a422c4d4bb092770bc50" translate="yes" xml:space="preserve">
          <source>If your array type does have fixed dimensionality requirements, then you should subtype &lt;code&gt;AbstractArrayStyle&lt;/code&gt;. For example, the sparse array code has the following definitions:</source>
          <target state="translated">배열 유형에 고정 차원 요구 사항이있는 경우 &lt;code&gt;AbstractArrayStyle&lt;/code&gt; 하위 유형을 지정해야합니다 . 예를 들어, 희소 배열 코드는 다음과 같은 정의를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="86e175e64e8da6c7e916078c1c6ea2b5a935db82" translate="yes" xml:space="preserve">
          <source>If your code has recursion, one potentially-confusing point is that a line in a &quot;child&quot; function can accumulate more counts than there are total backtraces. Consider the following function definitions:</source>
          <target state="translated">코드에 재귀가있는 경우 혼동 될 수있는 한 가지 점은 &quot;자식&quot;함수의 한 줄이 전체 역 추적보다 많은 수를 누적 할 수 있다는 것입니다. 다음 함수 정의를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="aa3f9be2eca1806a6c02bd56dca6f747bcc2726c" translate="yes" xml:space="preserve">
          <source>If your function returns an &lt;code&gt;Array&lt;/code&gt; or some other complex type, it may have to allocate memory. Unfortunately, oftentimes allocation and its converse, garbage collection, are substantial bottlenecks.</source>
          <target state="translated">함수가 &lt;code&gt;Array&lt;/code&gt; 또는 다른 복합 유형을 반환하면 메모리를 할당해야 할 수 있습니다. 불행하게도, 종종 할당과 그 반대로 가비지 콜렉션은 상당한 병목 현상입니다.</target>
        </trans-unit>
        <trans-unit id="203770fc43c2ec3f449524fb36ddffdf662a89aa" translate="yes" xml:space="preserve">
          <source>If, on the other hand, Julia was loading the &lt;em&gt;other&lt;/em&gt;&lt;code&gt;Priv&lt;/code&gt; package&amp;mdash;the one with UUID &lt;code&gt;2d15fe94-a1f7-436c-a4d8-07a9a496e01c&lt;/code&gt;&amp;mdash;it finds its stanza in the manifest, see that it does &lt;em&gt;not&lt;/em&gt; have a &lt;code&gt;path&lt;/code&gt; entry, but that it does have a &lt;code&gt;git-tree-sha1&lt;/code&gt; entry. It then computes the &lt;code&gt;slug&lt;/code&gt; for this UUID/SHA-1 pair, which is &lt;code&gt;HDkrT&lt;/code&gt; (the exact details of this computation aren't important, but it is consistent and deterministic). This means that the path to this &lt;code&gt;Priv&lt;/code&gt; package will be &lt;code&gt;packages/Priv/HDkrT/src/Priv.jl&lt;/code&gt; in one of the package depots. Suppose the contents of &lt;code&gt;DEPOT_PATH&lt;/code&gt; is &lt;code&gt;[&quot;/home/me/.julia&quot;, &quot;/usr/local/julia&quot;]&lt;/code&gt;, then Julia will look at the following paths to see if they exist:</source>
          <target state="translated">반면에 Julia가 &lt;em&gt;다른 &lt;/em&gt; &lt;code&gt;Priv&lt;/code&gt; 패키지 (UUID &lt;code&gt;2d15fe94-a1f7-436c-a4d8-07a9a496e01c&lt;/code&gt; 가 있는 패키지)를 로드하는 경우 매니페스트에서 스탠자를 찾은 경우 &lt;code&gt;path&lt;/code&gt; 항목 이 &lt;em&gt;없지만&lt;/em&gt; 참조하십시오. 가 않습니다 &lt;code&gt;git-tree-sha1&lt;/code&gt; 항목을. 그런 다음 이 UUID / SHA-1 쌍 의 &lt;code&gt;slug&lt;/code&gt; ( &lt;code&gt;HDkrT&lt;/code&gt; )를 계산합니다 (이 계산의 정확한 세부 사항은 중요하지 않지만 일관되고 결정적입니다). 이것은이 &lt;code&gt;Priv&lt;/code&gt; 패키지 의 경로가 패키지 저장소 중 &lt;code&gt;packages/Priv/HDkrT/src/Priv.jl&lt;/code&gt; 있는 packages / Priv / HDkrT / src / Priv.jl임을 의미 합니다. 의 내용을 가정 &lt;code&gt;DEPOT_PATH&lt;/code&gt; 가 있다 &lt;code&gt;[&quot;/home/me/.julia&quot;, &quot;/usr/local/julia&quot;]&lt;/code&gt; 이면 Julia는 다음 경로를보고 존재하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="08884ba6d9fbd224895a7cbdeceeec1f4c59bf40" translate="yes" xml:space="preserve">
          <source>Image Of</source>
          <target state="translated">이미지</target>
        </trans-unit>
        <trans-unit id="6ea4ebbef3751656124627e822bd05d7b6569f88" translate="yes" xml:space="preserve">
          <source>Image Of Or Approximately Equal To</source>
          <target state="translated">대략 또는 동등한 이미지</target>
        </trans-unit>
        <trans-unit id="09e871c98fef3b901a775def173e4126aaf73b42" translate="yes" xml:space="preserve">
          <source>Images</source>
          <target state="translated">Images</target>
        </trans-unit>
        <trans-unit id="a1dd283e60c10a07da0fde84cdded35b0d62bc7f" translate="yes" xml:space="preserve">
          <source>Immediately run finalizers registered for object &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">객체 &lt;code&gt;x&lt;/code&gt; 에 등록 된 종료자를 즉시 ​​실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f8a84e660062cc9351aa99e4736b44741ec8c96" translate="yes" xml:space="preserve">
          <source>Immutable composite types with no fields are singletons; there can be only one instance of such types:</source>
          <target state="translated">필드가없는 불변 합성 유형은 싱글 톤입니다. 이러한 유형의 인스턴스는 하나만있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="546c2aff0baec3bbc325a5abd6340afd6a503d6d" translate="yes" xml:space="preserve">
          <source>ImmutableDict</source>
          <target state="translated">ImmutableDict</target>
        </trans-unit>
        <trans-unit id="4d5fca35f85700fe41f680f762e716a68cf32a0c" translate="yes" xml:space="preserve">
          <source>ImmutableDict is a Dictionary implemented as an immutable linked list, which is optimal for small dictionaries that are constructed over many individual insertions Note that it is not possible to remove a value, although it can be partially overridden and hidden by inserting a new value with the same key</source>
          <target state="translated">ImmutableDict는 많은 개별 삽입으로 구성된 작은 사전에 최적 인 불변 링크 목록으로 구현 된 사전입니다. 같은 키</target>
        </trans-unit>
        <trans-unit id="5a205de46742b724da4bcd47864315bbfb29bffa" translate="yes" xml:space="preserve">
          <source>Imp</source>
          <target state="translated">Imp</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="91db407238f7692c5a1c288977c0c95bb564522e" translate="yes" xml:space="preserve">
          <source>Implemented by cluster managers using custom transports. It should establish a logical connection to worker with id &lt;code&gt;pid&lt;/code&gt;, specified by &lt;code&gt;config&lt;/code&gt; and return a pair of &lt;code&gt;IO&lt;/code&gt; objects. Messages from &lt;code&gt;pid&lt;/code&gt; to current process will be read off &lt;code&gt;instrm&lt;/code&gt;, while messages to be sent to &lt;code&gt;pid&lt;/code&gt; will be written to &lt;code&gt;outstrm&lt;/code&gt;. The custom transport implementation must ensure that messages are delivered and received completely and in order. &lt;code&gt;connect(manager::ClusterManager.....)&lt;/code&gt; sets up TCP/IP socket connections in-between workers.</source>
          <target state="translated">사용자 지정 전송을 사용하여 클러스터 관리자가 구현합니다. &lt;code&gt;config&lt;/code&gt; 에 의해 지정된 id가 &lt;code&gt;pid&lt;/code&gt; 인 worker에 대한 논리적 연결을 설정 하고 한 쌍의 &lt;code&gt;IO&lt;/code&gt; 객체를 반환해야 합니다. &lt;code&gt;pid&lt;/code&gt; 에서 현재 프로세스 까지의 메시지는 &lt;code&gt;instrm&lt;/code&gt; 에서 읽히고 &lt;code&gt;pid&lt;/code&gt; 로 보내지는 메시지 는 &lt;code&gt;outstrm&lt;/code&gt; 에 작성됩니다 . 사용자 정의 전송 구현은 메시지가 완전히 순서대로 전달 및 수신되도록해야합니다. &lt;code&gt;connect(manager::ClusterManager.....)&lt;/code&gt; 는 작업자간에 TCP / IP 소켓 연결을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="08979f61f84f8ad3b659b0b75ccddbf1892ea3a4" translate="yes" xml:space="preserve">
          <source>Implemented by cluster managers. For every Julia worker launched by this function, it should append a &lt;code&gt;WorkerConfig&lt;/code&gt; entry to &lt;code&gt;launched&lt;/code&gt; and notify &lt;code&gt;launch_ntfy&lt;/code&gt;. The function MUST exit once all workers, requested by &lt;code&gt;manager&lt;/code&gt; have been launched. &lt;code&gt;params&lt;/code&gt; is a dictionary of all keyword arguments &lt;a href=&quot;#Distributed.addprocs&quot;&gt;&lt;code&gt;addprocs&lt;/code&gt;&lt;/a&gt; was called with.</source>
          <target state="translated">클러스터 관리자가 구현했습니다. 이 기능에 의해 시작 모든 줄리아 노동자의 경우, 그것은 추가해야 &lt;code&gt;WorkerConfig&lt;/code&gt; 의 입장 &lt;code&gt;launched&lt;/code&gt; 하고 통지 &lt;code&gt;launch_ntfy&lt;/code&gt; . &lt;code&gt;manager&lt;/code&gt; 가 요청한 모든 작업자 가 시작 되면이 기능을 종료해야 합니다. &lt;code&gt;params&lt;/code&gt; 는 &lt;a href=&quot;#Distributed.addprocs&quot;&gt; &lt;code&gt;addprocs&lt;/code&gt; &lt;/a&gt; 가 호출 된 모든 키워드 인수의 사전입니다 .</target>
        </trans-unit>
        <trans-unit id="b5a68dbaa7e53b1fdc013e1b1b627c788dfd10b1" translate="yes" xml:space="preserve">
          <source>Implemented by cluster managers. It is called on the master process, by &lt;a href=&quot;#Distributed.rmprocs&quot;&gt;&lt;code&gt;rmprocs&lt;/code&gt;&lt;/a&gt;. It should cause the remote worker specified by &lt;code&gt;pid&lt;/code&gt; to exit. &lt;code&gt;kill(manager::ClusterManager.....)&lt;/code&gt; executes a remote &lt;code&gt;exit()&lt;/code&gt; on &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">클러스터 관리자가 구현했습니다. 마스터 프로세스에서 &lt;a href=&quot;#Distributed.rmprocs&quot;&gt; &lt;code&gt;rmprocs&lt;/code&gt; &lt;/a&gt; 에 의해 호출 됩니다. &lt;code&gt;pid&lt;/code&gt; 로 지정된 원격 작업자 가 종료되도록해야합니다. &lt;code&gt;kill(manager::ClusterManager.....)&lt;/code&gt; &lt;code&gt;exit()&lt;/code&gt; 는 &lt;code&gt;pid&lt;/code&gt; 에서 원격 exit () 를 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="dba266234257c3d4b0aca4b478ddab2be6ca2905" translate="yes" xml:space="preserve">
          <source>Implemented by cluster managers. It is called on the master process, during a worker's lifetime, with appropriate &lt;code&gt;op&lt;/code&gt; values:</source>
          <target state="translated">클러스터 관리자가 구현했습니다. 작업자의 수명 동안 적절한 &lt;code&gt;op&lt;/code&gt; 값 을 사용하여 마스터 프로세스에서 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="a6456a3318802fc28959139bf29a9bdf8b9e1954" translate="yes" xml:space="preserve">
          <source>Import Command</source>
          <target state="translated">가져 오기 명령</target>
        </trans-unit>
        <trans-unit id="a4489b5a6e6e45ce5f1172241f2ce59438e83997" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MyModule&lt;/code&gt; above we wanted to add a method to the standard &lt;code&gt;show&lt;/code&gt; function, so we had to write &lt;code&gt;import Base.show&lt;/code&gt;. Functions whose names are only visible via &lt;code&gt;using&lt;/code&gt; cannot be extended.</source>
          <target state="translated">위의 &lt;code&gt;MyModule&lt;/code&gt; 에서 표준 &lt;code&gt;show&lt;/code&gt; 함수에 메소드를 추가하려고 했기 때문에 &lt;code&gt;import Base.show&lt;/code&gt; 를 작성해야했습니다 . &lt;code&gt;using&lt;/code&gt; 통해서만 이름이 보이는 기능은 확장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="035c9cab15fd9dc0120582c57dc7ae1a95ac181b" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;very rare&lt;/em&gt; cases it might make sense for the constructor &lt;code&gt;T(x)&lt;/code&gt; to return an object not of type &lt;code&gt;T&lt;/code&gt;. This could happen if a wrapper type is its own inverse (e.g. &lt;code&gt;Flip(Flip(x)) === x&lt;/code&gt;), or to support an old calling syntax for backwards compatibility when a library is restructured. But &lt;code&gt;convert(T, x)&lt;/code&gt; should always return a value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">에서 &lt;em&gt;매우 드문&lt;/em&gt; 경우는 생성자에 대한 의미 만들 수도 &lt;code&gt;T(x)&lt;/code&gt; 유형의 객체를하지 반환 &lt;code&gt;T&lt;/code&gt; . 래퍼 유형이 자체 역수 (예 : &lt;code&gt;Flip(Flip(x)) === x&lt;/code&gt; )이거나 라이브러리가 재구성 될 때 이전 버전과의 호환성을 위해 이전 호출 구문을 지원하는 경우 이런 일이 발생할 수 있습니다. 그러나 &lt;code&gt;convert(T, x)&lt;/code&gt; 는 항상 &lt;code&gt;T&lt;/code&gt; 유형의 값을 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d6ddd3549cd522fa313ced4025d3d58df8994646" translate="yes" xml:space="preserve">
          <source>In C++ or Java, for example, in a method call like &lt;code&gt;obj.meth(arg1,arg2)&lt;/code&gt;, the object obj &quot;receives&quot; the method call and is implicitly passed to the method via the &lt;code&gt;this&lt;/code&gt; keyword, rather than as an explicit method argument. When the current &lt;code&gt;this&lt;/code&gt; object is the receiver of a method call, it can be omitted altogether, writing just &lt;code&gt;meth(arg1,arg2)&lt;/code&gt;, with &lt;code&gt;this&lt;/code&gt; implied as the receiving object.</source>
          <target state="translated">C ++ 또는 Java에서, 예를 들어 &lt;code&gt;obj.meth(arg1,arg2)&lt;/code&gt; 와 같은 메소드 호출 에서 오브젝트 obj는 메소드 호출을 &quot;수신&quot;하고 명시 적 메소드 인수가 아닌 &lt;code&gt;this&lt;/code&gt; 키워드 를 통해 내재적 으로 메소드에 전달됩니다. . 전류가되면 &lt;code&gt;this&lt;/code&gt; 객체 메소드 호출의 수신자가, 단지 기록 아예 생략 될 수 &lt;code&gt;meth(arg1,arg2)&lt;/code&gt; 가진 &lt;code&gt;this&lt;/code&gt; 수신 객체로서 묵시적.</target>
        </trans-unit>
        <trans-unit id="0b44231782a66524e37b6a261f0e356297afae45" translate="yes" xml:space="preserve">
          <source>In C++, by default, you have static dispatch, i.e. you need to annotate a function as virtual, in order to have dynamic dispatch. On the other hand, in Julia every method is &quot;virtual&quot; (although it's more general than that since methods are dispatched on every argument type, not only &lt;code&gt;this&lt;/code&gt;, using the most-specific-declaration rule).</source>
          <target state="translated">C ++에서는 기본적으로 정적 디스패치가 있습니다. 즉, 동적 디스패치를 ​​수행하려면 함수를 가상으로 주석 처리해야합니다. 반면에 Julia에서는 모든 메소드가 &quot;가상&quot;(가장 일반적인 선언 규칙을 사용하여 &lt;code&gt;this&lt;/code&gt; 뿐만 아니라 모든 인수 유형에서 메소드가 전달되므로 메소드가 더 일반적 임 )입니다.</target>
        </trans-unit>
        <trans-unit id="a64f4137e1f00234d12e399e1c5435c90a8e6c63" translate="yes" xml:space="preserve">
          <source>In Julia (as in much of scientific computation), dense linear-algebra operations are based on the &lt;a href=&quot;http://www.netlib.org/lapack/&quot;&gt;LAPACK library&lt;/a&gt;, which in turn is built on top of basic linear-algebra building-blocks known as the &lt;a href=&quot;http://www.netlib.org/blas/&quot;&gt;BLAS&lt;/a&gt;. There are highly optimized implementations of BLAS available for every computer architecture, and sometimes in high-performance linear algebra routines it is useful to call the BLAS functions directly.</source>
          <target state="translated">Julia의 경우 (많은 과학적 계산에서와 같이) 밀도가 높은 선형 대수 연산은 &lt;a href=&quot;http://www.netlib.org/lapack/&quot;&gt;LAPACK 라이브러리를&lt;/a&gt; 기반 으로하며 &lt;a href=&quot;http://www.netlib.org/blas/&quot;&gt;BLAS&lt;/a&gt; 라는 기본 선형 대수 빌딩 블록 위에 구축됩니다 . 모든 컴퓨터 아키텍처에 사용할 수있는 최적화 된 BLAS 구현이 있으며 때로는 고성능 선형 대수 루틴에서 BLAS 함수를 직접 호출하는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="247a76ccd2e14a487830d09d4cedad7b8f5df0c1" translate="yes" xml:space="preserve">
          <source>In Julia 1.0 this method only supported a square destination matrix. Julia 1.1. added support for a rectangular matrix.</source>
          <target state="translated">Julia 1.0에서이 방법은 정사각 목적지 행렬 만 지원했습니다. 줄리아 1.1. 직사각형 매트릭스에 대한 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="7eb90fb66dbd8787a2bcb4484cc97817d278a46b" translate="yes" xml:space="preserve">
          <source>In Julia 1.0, the default &lt;code&gt;--project=@.&lt;/code&gt; option did not search up from the root directory of a Git repository for the &lt;code&gt;Project.toml&lt;/code&gt; file. From Julia 1.1 forward, it does.</source>
          <target state="translated">Julia 1.0에서 기본값은 &lt;code&gt;--project=@.&lt;/code&gt; 옵션은 &lt;code&gt;Project.toml&lt;/code&gt; 파일에 대한 Git 저장소의 루트 디렉토리에서 검색하지 않았습니다 . Julia 1.1부터는 그렇습니다.</target>
        </trans-unit>
        <trans-unit id="0050127afe87c7fac6e12932d051462ec8c65b3e" translate="yes" xml:space="preserve">
          <source>In Julia 1.1 &lt;code&gt;randcycle&lt;/code&gt; returns a vector &lt;code&gt;v&lt;/code&gt; with &lt;code&gt;eltype(v) == typeof(n)&lt;/code&gt; while in Julia 1.0 &lt;code&gt;eltype(v) == Int&lt;/code&gt;.</source>
          <target state="translated">Julia 1.1에서는 &lt;code&gt;randcycle&lt;/code&gt; 이 &lt;code&gt;eltype(v) == typeof(n)&lt;/code&gt; 벡터 &lt;code&gt;v&lt;/code&gt; 를 반환 하지만 Julia 1.0에서는 &lt;code&gt;eltype(v) == Int&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d8b5eb0c54cc4aad9911d4c5d77bfea05f710df6" translate="yes" xml:space="preserve">
          <source>In Julia 1.1 &lt;code&gt;randperm&lt;/code&gt; returns a vector &lt;code&gt;v&lt;/code&gt; with &lt;code&gt;eltype(v) == typeof(n)&lt;/code&gt; while in Julia 1.0 &lt;code&gt;eltype(v) == Int&lt;/code&gt;.</source>
          <target state="translated">Julia 1.1에서는 &lt;code&gt;randperm&lt;/code&gt; 이 &lt;code&gt;eltype(v) == typeof(n)&lt;/code&gt; 벡터 &lt;code&gt;v&lt;/code&gt; 를 반환 하지만 Julia 1.0에서는 &lt;code&gt;eltype(v) == Int&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d630cc94b63c31ac28921da908c57f1454c54e15" translate="yes" xml:space="preserve">
          <source>In Julia &lt;code&gt;%&lt;/code&gt; is the remainder operator, whereas in Python it is the modulus.</source>
          <target state="translated">Julia에서는 &lt;code&gt;%&lt;/code&gt; 가 나머지 연산자 인 반면 Python에서는 모듈러스입니다.</target>
        </trans-unit>
        <trans-unit id="cbc49b243ca968548d5e6046855ea243ea0a10fe" translate="yes" xml:space="preserve">
          <source>In Julia code wrapping calls to external C routines, ordinary (non-pointer) data should be declared to be of type &lt;code&gt;T&lt;/code&gt; inside the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;, as they are passed by value. For C code accepting pointers, &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt;&lt;code&gt;Ref{T}&lt;/code&gt;&lt;/a&gt; should generally be used for the types of input arguments, allowing the use of pointers to memory managed by either Julia or C through the implicit call to &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt;. In contrast, pointers returned by the C function called should be declared to be of output type &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt;&lt;code&gt;Ptr{T}&lt;/code&gt;&lt;/a&gt;, reflecting that the memory pointed to is managed by C only. Pointers contained in C structs should be represented as fields of type &lt;code&gt;Ptr{T}&lt;/code&gt; within the corresponding Julia struct types designed to mimic the internal structure of corresponding C structs.</source>
          <target state="translated">외부 C 루틴에 대한 호출을 랩핑하는 Julia 코드에서 일반 (비 포인터) 데이터는 값이 전달 될 때 &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 내부에서 &lt;code&gt;T&lt;/code&gt; 유형으로 선언되어야합니다 . C 코드 수용성 포인터를 들어, &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt; &lt;code&gt;Ref{T}&lt;/code&gt; &lt;/a&gt; 일반적으로 내재적 호출을 통해 줄리아 또는 C 중 하나에 의해 관리되는 메모리에 대한 포인터의 사용을 허용하는, 입력 인자의 유형 표기 &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; 를&lt;/a&gt; . 반대로, 호출 된 C 함수에 의해 리턴 된 포인터는 지시 된 메모리가 C에 의해서만 관리됨을 반영 하여 출력 유형 &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt; &lt;code&gt;Ptr{T}&lt;/code&gt; &lt;/a&gt; 으로 선언되어야합니다 . C 구조체에 포함 된 포인터는 &lt;code&gt;Ptr{T}&lt;/code&gt; 유형의 필드로 표시되어야합니다. 해당 Julia 구조체 유형 내에서 해당 C 구조체의 내부 구조를 모방하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="1fa4d6ec34fe20b0509960e834e463ea1a6b4cc7" translate="yes" xml:space="preserve">
          <source>In Julia code wrapping calls to external Fortran routines, all input arguments should be declared as of type &lt;code&gt;Ref{T}&lt;/code&gt;, as Fortran passes all variables by pointers to memory locations. The return type should either be &lt;code&gt;Cvoid&lt;/code&gt; for Fortran subroutines, or a &lt;code&gt;T&lt;/code&gt; for Fortran functions returning the type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">외부 포트란 루틴에 대한 호출을 랩핑하는 Julia 코드에서는 포트란이 모든 변수를 메모리 위치에 대한 포인터로 전달하므로 모든 입력 인수는 &lt;code&gt;Ref{T}&lt;/code&gt; 유형으로 선언되어야합니다 . 리턴 유형은 포트란 서브 루틴의 경우 &lt;code&gt;Cvoid&lt;/code&gt; 이거나 유형 &lt;code&gt;T&lt;/code&gt; 를 리턴하는 포트란 함수의 경우 &lt;code&gt;T&lt;/code&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="34f3cdb66f13e42ca43c63a9c817a8c4007728b9" translate="yes" xml:space="preserve">
          <source>In Julia each module has its own global scope/namespace, whereas in MATLAB there is just one global scope.</source>
          <target state="translated">Julia에서는 각 모듈마다 고유 한 전역 범위 / 네임 스페이스가 있지만 MATLAB에는 하나의 전역 범위 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9649a4e1eb5caa62495053957d722a3d4bba674" translate="yes" xml:space="preserve">
          <source>In Julia mode, the REPL supports something called &lt;em&gt;prompt pasting&lt;/em&gt;. This activates when pasting text that starts with &lt;code&gt;julia&amp;gt;&lt;/code&gt; into the REPL. In that case, only expressions starting with &lt;code&gt;julia&amp;gt;&lt;/code&gt; are parsed, others are removed. This makes it is possible to paste a chunk of code that has been copied from a REPL session without having to scrub away prompts and outputs. This feature is enabled by default but can be disabled or enabled at will with &lt;code&gt;REPL.enable_promptpaste(::Bool)&lt;/code&gt;. If it is enabled, you can try it out by pasting the code block above this paragraph straight into the REPL. This feature does not work on the standard Windows command prompt due to its limitation at detecting when a paste occurs.</source>
          <target state="translated">Julia 모드에서 REPL은 &lt;em&gt;프롬프트 붙여 넣기&lt;/em&gt; 라는 것을 지원합니다 . &lt;code&gt;julia&amp;gt;&lt;/code&gt; 로 시작하는 텍스트를 REPL에 붙여 넣을 때 활성화됩니다 . 이 경우 &lt;code&gt;julia&amp;gt;&lt;/code&gt; 로 시작하는 표현식 만 구문 분석되고 다른 표현식 은 제거됩니다. 따라서 프롬프트와 출력을 제거하지 않고도 REPL 세션에서 복사 된 코드를 붙여 넣을 수 있습니다. 이 기능은 기본적으로 활성화되어 있지만 원하는대로 &lt;code&gt;REPL.enable_promptpaste(::Bool)&lt;/code&gt; 활성화하거나 비활성화 할 수 있습니다 . 활성화 된 경우이 단락 위에있는 코드 블록을 REPL에 바로 붙여 넣어 사용해 볼 수 있습니다. 이 기능은 붙여 넣기 발생시기를 감지하는 데 한계가 있기 때문에 표준 Windows 명령 프롬프트에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="57d6ea2617d808e81c678587852ffabe403f81cb" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;&amp;lt;-&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;-&lt;/code&gt; and &lt;code&gt;-&amp;gt;&lt;/code&gt; are not assignment operators.</source>
          <target state="translated">Julia에서 &lt;code&gt;&amp;lt;-&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;-&lt;/code&gt; 및 &lt;code&gt;-&amp;gt;&lt;/code&gt; 는 대입 연산자가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="601692d3aba8995fb01afb976c7c7f5a8aab46fc" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;...&lt;/code&gt; is not used to continue lines of code. Instead, incomplete expressions automatically continue onto the next line.</source>
          <target state="translated">Julia에서는 &lt;code&gt;...&lt;/code&gt; 코드 행을 계속하는 데 사용되지 않습니다. 대신 불완전한 표현식이 다음 줄로 자동 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="5bdd69cd27046bb2e3189abcdf750e49518e8509" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;Ref&lt;/code&gt; objects are dereferenced (loaded or stored) with &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">Julia에서 &lt;code&gt;Ref&lt;/code&gt; 객체는 &lt;code&gt;[]&lt;/code&gt; 로 역 참조 (로드 또는 저장)됩니다 .</target>
        </trans-unit>
        <trans-unit id="bbe698f34efa48506b3a034b90fcbacaa3b44d79" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;[1, 2, 3, 4][[true, false, true, false]]&lt;/code&gt; produces &lt;code&gt;[1, 3]&lt;/code&gt;.</source>
          <target state="translated">Julia에서 &lt;code&gt;[1, 2, 3, 4][[true, false, true, false]]&lt;/code&gt; 는 &lt;code&gt;[1, 3]&lt;/code&gt; 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="41c6478a96484907c7a62d3fc652aeb5cc697413" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;[1, 2, 3, 4][[true, false]]&lt;/code&gt; throws a &lt;a href=&quot;../../base/base/index#Core.BoundsError&quot;&gt;&lt;code&gt;BoundsError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Julia에서 &lt;code&gt;[1, 2, 3, 4][[true, false]]&lt;/code&gt; 는 &lt;a href=&quot;../../base/base/index#Core.BoundsError&quot;&gt; &lt;code&gt;BoundsError&lt;/code&gt; 를 발생시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0974da83f18cbcaffe16bb6459e3edda104c9151" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;[x,y,z]&lt;/code&gt; will always construct a 3-element array containing &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">Julia에서 &lt;code&gt;[x,y,z]&lt;/code&gt; 는 항상 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 를 포함하는 3 요소 배열을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="1d138a3241eb075445bbb09d48ceedbc03b1d34e" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;a:b&lt;/code&gt; and &lt;code&gt;a:b:c&lt;/code&gt; construct &lt;code&gt;AbstractRange&lt;/code&gt; objects. To construct a full vector like in MATLAB, use &lt;code&gt;collect(a:b)&lt;/code&gt;. Generally, there is no need to call &lt;code&gt;collect&lt;/code&gt; though. An &lt;code&gt;AbstractRange&lt;/code&gt; object will act like a normal array in most cases but is more efficient because it lazily computes its values. This pattern of creating specialized objects instead of full arrays is used frequently, and is also seen in functions such as &lt;a href=&quot;../../base/math/index#Base.range&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt;, or with iterators such as &lt;code&gt;enumerate&lt;/code&gt;, and &lt;code&gt;zip&lt;/code&gt;. The special objects can mostly be used as if they were normal arrays.</source>
          <target state="translated">Julia에서는 &lt;code&gt;a:b&lt;/code&gt; 와 &lt;code&gt;a:b:c&lt;/code&gt; 가 &lt;code&gt;AbstractRange&lt;/code&gt; 객체를 생성 합니다. MATLAB에서와 같이 전체 벡터를 구성하려면 &lt;code&gt;collect(a:b)&lt;/code&gt; . 일반적으로 &lt;code&gt;collect&lt;/code&gt; 를 호출 할 필요는 없습니다 . &lt;code&gt;AbstractRange&lt;/code&gt; 의 목적은 대부분의 경우에 보통 배열처럼 행동하지만 느리게 그 값을 계산하기 때문에보다 효율적이다 것이다. 전체 배열 대신 특수 객체를 생성하는이 패턴은 자주 사용되며 &lt;a href=&quot;../../base/math/index#Base.range&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; 와 같은 함수 또는 &lt;code&gt;enumerate&lt;/code&gt; 및 &lt;code&gt;zip&lt;/code&gt; 과 같은 반복자와 함께 사용됩니다 . 특수 객체는 대부분 마치 일반 배열 인 것처럼 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5622f51f1798995f4e2f17cefbf558acb8bdcceb" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;return&lt;/code&gt; does not require parentheses.</source>
          <target state="translated">Julia에서는 &lt;code&gt;return&lt;/code&gt; 괄호가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c5612272a8f825cb7424d2a9deb9bd304a01ce42" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;x += y&lt;/code&gt; gets replaced during parsing by &lt;code&gt;x = x + y&lt;/code&gt;. For arrays, this has the consequence that, rather than storing the result in the same location in memory as &lt;code&gt;x&lt;/code&gt;, it allocates a new array to store the result.</source>
          <target state="translated">Julia에서 &lt;code&gt;x += y&lt;/code&gt; 는 &lt;code&gt;x = x + y&lt;/code&gt; 구문 분석하는 동안 바뀝니다 . 배열의 경우 결과는 &lt;code&gt;x&lt;/code&gt; 와 동일한 위치에 결과를 저장하는 대신 결과를 저장하기 위해 새 배열을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="58b1700c001aef7c6e8210d638550d343b095441" translate="yes" xml:space="preserve">
          <source>In Julia, a function is an object that maps a tuple of argument values to a return value. Julia functions are not pure mathematical functions, in the sense that functions can alter and be affected by the global state of the program. The basic syntax for defining functions in Julia is:</source>
          <target state="translated">Julia에서 함수는 인수 값의 튜플을 반환 값에 매핑하는 객체입니다. Julia 함수는 함수가 프로그램의 전역 상태에 의해 변경되고 영향을받을 수 있다는 점에서 순수한 수학 함수가 아닙니다. Julia에서 함수를 정의하는 기본 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4f9d45e10bb7e036a0e05a4d8d4376715db6b481" translate="yes" xml:space="preserve">
          <source>In Julia, a range like &lt;code&gt;a:b&lt;/code&gt; is not shorthand for a vector like in R, but is a specialized &lt;code&gt;AbstractRange&lt;/code&gt; object that is used for iteration without high memory overhead. To convert a range into a vector, use &lt;code&gt;collect(a:b)&lt;/code&gt;.</source>
          <target state="translated">Julia에서 a &lt;code&gt;a:b&lt;/code&gt; 와 같은 범위 는 R에서와 같은 벡터를 줄인 것이 아니라 높은 메모리 오버 헤드없이 반복에 사용되는 특수화 된 &lt;code&gt;AbstractRange&lt;/code&gt; 객체입니다. 범위를 벡터로 변환하려면 &lt;code&gt;collect(a:b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40f5223023ecdb73df06f3b1a01d3f068c335d77" translate="yes" xml:space="preserve">
          <source>In Julia, all arguments to functions are &lt;a href=&quot;https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;passed by sharing&lt;/a&gt; (i.e. by pointers). Some technical computing languages pass arrays by value, and while this prevents accidental modification by callees of a value in the caller, it makes avoiding unwanted copying of arrays difficult. By convention, a function name ending with a &lt;code&gt;!&lt;/code&gt; indicates that it will mutate or destroy the value of one or more of its arguments (compare, for example, &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt;&lt;code&gt;sort!&lt;/code&gt;&lt;/a&gt;). Callees must make explicit copies to ensure that they don't modify inputs that they don't intend to change. Many non- mutating functions are implemented by calling a function of the same name with an added &lt;code&gt;!&lt;/code&gt; at the end on an explicit copy of the input, and returning that copy.</source>
          <target state="translated">Julia에서 함수에 대한 모든 인수는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;공유&lt;/a&gt; (예 : 포인터)를 통해 전달됩니다 . 일부 기술 컴퓨팅 언어는 값별로 배열을 전달하므로 호출자의 값을 수신자가 실수로 수정하는 것을 방지하지만 원하지 않는 배열의 복사를 피하는 것이 어렵습니다. 관례 적으로 함수 이름은 &lt;code&gt;!&lt;/code&gt; 로 끝납니다 . 는 하나 이상의 인수 값을 변경하거나 제거함을 나타냅니다 (예 : &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt; &lt;code&gt;sort!&lt;/code&gt; 비교&lt;/a&gt; ). 수신자는 변경하지 않을 입력을 수정하지 않도록 명시적인 사본을 작성해야합니다. &lt;code&gt;!&lt;/code&gt; 와 같은 이름을 가진 함수를 추가하여 많은 비 돌연변이 함수가 구현됩니다 . 입력의 명시 적 사본이 끝날 때 해당 사본을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9c3127614001f5fb915dc8fbc84746b3f3f27566" translate="yes" xml:space="preserve">
          <source>In Julia, an array &quot;slice&quot; expression like &lt;code&gt;array[1:5, :]&lt;/code&gt; creates a copy of that data (except on the left-hand side of an assignment, where &lt;code&gt;array[1:5, :] = ...&lt;/code&gt; assigns in-place to that portion of &lt;code&gt;array&lt;/code&gt;). If you are doing many operations on the slice, this can be good for performance because it is more efficient to work with a smaller contiguous copy than it would be to index into the original array. On the other hand, if you are just doing a few simple operations on the slice, the cost of the allocation and copy operations can be substantial.</source>
          <target state="translated">Julia에서 &lt;code&gt;array[1:5, :]&lt;/code&gt; 와 같은 배열 &quot;슬라이스&quot;식은 해당 데이터의 복사본을 만듭니다 (할당의 왼쪽을 제외하고 &lt;code&gt;array[1:5, :] = ...&lt;/code&gt; assigns &lt;code&gt;array&lt;/code&gt; 해당 부분 대신 ). 슬라이스에서 많은 작업을 수행하는 경우 원래 배열로 인덱싱하는 것보다 작은 연속 복사본으로 작업하는 것이 더 효율적이므로 성능에 좋습니다. 반면에 슬라이스에서 몇 가지 간단한 작업을 수행하는 경우 할당 및 복사 작업 비용이 상당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3012ec15c747cb5e8c8ab3cbb7a1be0e9f5c2879" translate="yes" xml:space="preserve">
          <source>In Julia, exceeding the maximum representable value of a given type results in a wraparound behavior:</source>
          <target state="translated">Julia에서 지정된 유형의 최대 표현 가능 값을 초과하면 랩 어라운드 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="64ca87b8c062eb3ffaa0f39bec7e937ad18a966d" translate="yes" xml:space="preserve">
          <source>In Julia, if &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are arrays, logical comparison operations like &lt;code&gt;A == B&lt;/code&gt; do not return an array of booleans. Instead, use &lt;code&gt;A .== B&lt;/code&gt;, and similarly for the other boolean operators like &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Julia에서 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 가 배열이면 &lt;code&gt;A == B&lt;/code&gt; 와 같은 논리 비교 연산 은 부울 배열을 반환하지 않습니다. 대신 &lt;code&gt;A .== B&lt;/code&gt; 를 사용하고 &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 와 같은 다른 부울 연산자에도 유사하게 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d922f5b73911084e1798e1fbea58a0f20f71a33c" translate="yes" xml:space="preserve">
          <source>In Julia, indexing of arrays, strings, etc. is 1-based not 0-based.</source>
          <target state="translated">Julia에서 배열, 문자열 등의 인덱싱은 0 기반이 아닌 1 기반입니다.</target>
        </trans-unit>
        <trans-unit id="06df6596eaa7007459b69a3e35309023ab071dc0" translate="yes" xml:space="preserve">
          <source>In Julia, like Python but unlike R, strings can be created with triple quotes &lt;code&gt;&quot;&quot;&quot; ... &quot;&quot;&quot;&lt;/code&gt;. This syntax is convenient for constructing strings that contain line breaks.</source>
          <target state="translated">Julia에서는 Python과 같지만 R과 달리 Julia는 삼중 따옴표 &lt;code&gt;&quot;&quot;&quot; ... &quot;&quot;&quot;&lt;/code&gt; 문자열을 작성할 수 있습니다 . 이 구문은 줄 바꿈이 포함 된 문자열을 구성하는 데 편리합니다.</target>
        </trans-unit>
        <trans-unit id="c8b7771804f2b70605beeefa21f23d88e1f845ae" translate="yes" xml:space="preserve">
          <source>In Julia, literal numbers without a decimal point (such as &lt;code&gt;42&lt;/code&gt;) create integers instead of floating point numbers. As a result, some operations can throw a domain error if they expect a float; for example, &lt;code&gt;julia&amp;gt; a = -1; 2^a&lt;/code&gt; throws a domain error, as the result is not an integer (see &lt;a href=&quot;../faq/index#faq-domain-errors-1&quot;&gt;the FAQ entry on domain errors&lt;/a&gt; for details).</source>
          <target state="translated">Julia에서 소수점이없는 리터럴 숫자 (예 : &lt;code&gt;42&lt;/code&gt; )는 부동 소수점 숫자 대신 정수를 만듭니다. 결과적으로 일부 작업은 실수를 예상하면 도메인 오류를 발생시킬 수 있습니다. 예를 들어, &lt;code&gt;julia&amp;gt; a = -1; 2^a&lt;/code&gt; 결과가 정수가 아니므로 2 ^ a &lt;a href=&quot;../faq/index#faq-domain-errors-1&quot;&gt;에서 도메인 오류가 발생&lt;/a&gt; 합니다 (자세한 내용 은 도메인 오류에 대한 FAQ 항목 참조).</target>
        </trans-unit>
        <trans-unit id="abe9d8d534555f871e47223b8068b11086c34b86" translate="yes" xml:space="preserve">
          <source>In Julia, literal numbers without a decimal point (such as &lt;code&gt;42&lt;/code&gt;) create signed integers, of type &lt;code&gt;Int&lt;/code&gt;, but literals too large to fit in the machine word size will automatically be promoted to a larger size type, such as &lt;code&gt;Int64&lt;/code&gt; (if &lt;code&gt;Int&lt;/code&gt; is &lt;code&gt;Int32&lt;/code&gt;), &lt;code&gt;Int128&lt;/code&gt;, or the arbitrarily large &lt;code&gt;BigInt&lt;/code&gt; type. There are no numeric literal suffixes, such as &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;LL&lt;/code&gt;, &lt;code&gt;U&lt;/code&gt;, &lt;code&gt;UL&lt;/code&gt;, &lt;code&gt;ULL&lt;/code&gt; to indicate unsigned and/or signed vs. unsigned. Decimal literals are always signed, and hexadecimal literals (which start with &lt;code&gt;0x&lt;/code&gt; like C/C++), are unsigned. Hexadecimal literals also, unlike C/C++/Java and unlike decimal literals in Julia, have a type based on the &lt;em&gt;length&lt;/em&gt; of the literal, including leading 0s. For example, &lt;code&gt;0x0&lt;/code&gt; and &lt;code&gt;0x00&lt;/code&gt; have type &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;0x000&lt;/code&gt; and &lt;code&gt;0x0000&lt;/code&gt; have type &lt;a href=&quot;../../base/numbers/index#Core.UInt16&quot;&gt;&lt;code&gt;UInt16&lt;/code&gt;&lt;/a&gt;, then literals with 5 to 8 hex digits have type &lt;code&gt;UInt32&lt;/code&gt;, 9 to 16 hex digits type &lt;code&gt;UInt64&lt;/code&gt; and 17 to 32 hex digits type &lt;code&gt;UInt128&lt;/code&gt;. This needs to be taken into account when defining hexadecimal masks, for example &lt;code&gt;~0xf == 0xf0&lt;/code&gt; is very different from &lt;code&gt;~0x000f == 0xfff0&lt;/code&gt;. 64 bit &lt;code&gt;Float64&lt;/code&gt; and 32 bit &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt; bit literals are expressed as &lt;code&gt;1.0&lt;/code&gt; and &lt;code&gt;1.0f0&lt;/code&gt; respectively. Floating point literals are rounded (and not promoted to the &lt;code&gt;BigFloat&lt;/code&gt; type) if they can not be exactly represented. Floating point literals are closer in behavior to C/C++. Octal (prefixed with &lt;code&gt;0o&lt;/code&gt;) and binary (prefixed with &lt;code&gt;0b&lt;/code&gt;) literals are also treated as unsigned.</source>
          <target state="translated">Julia에서 소수점이없는 리터럴 숫자 (예 : &lt;code&gt;42&lt;/code&gt; )는 &lt;code&gt;Int&lt;/code&gt; 유형의 부호있는 정수를 작성 하지만 기계 단어 크기에 맞지 않는 리터럴은 자동으로 &lt;code&gt;Int64&lt;/code&gt; 와 같은 더 큰 크기 유형으로 승격됩니다 ( &lt;code&gt;Int&lt;/code&gt; 가 &lt;code&gt;Int32&lt;/code&gt; , &lt;code&gt;Int128&lt;/code&gt; 또는 임의로 큰 &lt;code&gt;BigInt&lt;/code&gt; 유형입니다. 부호없는 및 / 또는 부호있는 대 부호없는 것을 나타내는 &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;LL&lt;/code&gt; , &lt;code&gt;U&lt;/code&gt; , &lt;code&gt;UL&lt;/code&gt; , &lt;code&gt;ULL&lt;/code&gt; 과 같은 숫자 리터럴 접미사는 없습니다 . 십진 리터럴은 항상 부호가 있고 16 진 리터럴 ( &lt;code&gt;0x&lt;/code&gt; 로 시작)C / C ++와 같이) 서명되지 않습니다. C / C ++ / Java와 달리 16 진 리터럴은 Julia의 10 진 리터럴과 달리 선행 0을 포함하여 리터럴 의 &lt;em&gt;길이&lt;/em&gt; 에 따라 유형이 있습니다. 예를 들어, &lt;code&gt;0x0&lt;/code&gt; 및 &lt;code&gt;0x00&lt;/code&gt; 으로는 입력이 &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;0x000&lt;/code&gt; 및 &lt;code&gt;0x0000&lt;/code&gt; 입력이 &lt;a href=&quot;../../base/numbers/index#Core.UInt16&quot;&gt; &lt;code&gt;UInt16&lt;/code&gt; &lt;/a&gt; 입력 한 5~8 16 진수로 다음 리터럴 &lt;code&gt;UInt32&lt;/code&gt; , 9, 16 진수 숫자 입력 &lt;code&gt;UInt64&lt;/code&gt; 17 내지 32 진수 숫자 입력 &lt;code&gt;UInt128&lt;/code&gt; 를 . 16 진 마스크를 정의 할 때이를 고려해야합니다. 예를 들어 &lt;code&gt;~0xf == 0xf0&lt;/code&gt; 은 &lt;code&gt;~0x000f == 0xfff0&lt;/code&gt; 과 매우 다릅니다 . 64 비트 &lt;code&gt;Float64&lt;/code&gt; 및 32 비트 &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; 비트 리터럴은 각각 &lt;code&gt;1.0&lt;/code&gt; 및 &lt;code&gt;1.0f0&lt;/code&gt; 으로 표시 됩니다. 부동 소수점 리터럴은 정확하게 표현할 수없는 경우 반올림됩니다 ( &lt;code&gt;BigFloat&lt;/code&gt; 유형으로 승격되지 않음 ). 부동 소수점 리터럴은 C / C ++에 가까운 동작입니다. 진수 (접두사 &lt;code&gt;0o&lt;/code&gt; 에서 (접두사) 및 이진 &lt;code&gt;0b&lt;/code&gt; 리터럴)도 부호로 처리된다.</target>
        </trans-unit>
        <trans-unit id="bdfe6baa0b2a1067c27d35abb55f2ee6ec449a3c" translate="yes" xml:space="preserve">
          <source>In Julia, missing values are represented by the &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; object rather than by &lt;code&gt;NA&lt;/code&gt;. Use &lt;a href=&quot;../../base/base/index#Base.ismissing&quot;&gt;&lt;code&gt;ismissing(x)&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;ismissing.(x)&lt;/code&gt; for element-wise operation on vectors) instead of &lt;code&gt;is.na(x)&lt;/code&gt;. The &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function is generally used instead of &lt;code&gt;na.rm=TRUE&lt;/code&gt; (though in some particular cases functions take a &lt;code&gt;skipmissing&lt;/code&gt; argument).</source>
          <target state="translated">Julia에서 결 측값은 &lt;code&gt;NA&lt;/code&gt; 가 아닌 &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 객체 로 표시됩니다 . 사용 &lt;a href=&quot;../../base/base/index#Base.ismissing&quot;&gt; &lt;code&gt;ismissing(x)&lt;/code&gt; &lt;/a&gt; (또는 &lt;code&gt;ismissing.(x)&lt;/code&gt; 는 벡터의 요소 와이즈 동작) 대신 &lt;code&gt;is.na(x)&lt;/code&gt; . &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; 의&lt;/a&gt; 기능은 일반적으로 사용되는 대신 &lt;code&gt;na.rm=TRUE&lt;/code&gt; (일부 경우에 특히 기능은 가지고 있지만 &lt;code&gt;skipmissing&lt;/code&gt; 의 인수).</target>
        </trans-unit>
        <trans-unit id="c2883abece45992fb07a9eafea704ad64c7847f2" translate="yes" xml:space="preserve">
          <source>In Julia, modulus is &lt;code&gt;mod(a, b)&lt;/code&gt;, not &lt;code&gt;a %% b&lt;/code&gt;. &lt;code&gt;%&lt;/code&gt; in Julia is the remainder operator.</source>
          <target state="translated">Julia에서 계수는 &lt;code&gt;a %% b&lt;/code&gt; 아닌 &lt;code&gt;mod(a, b)&lt;/code&gt; 입니다. Julia의 &lt;code&gt;%&lt;/code&gt; 는 나머지 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="2e2622d04790dce54d4881a8ca271df72d322df7" translate="yes" xml:space="preserve">
          <source>In Julia, most operators are just functions with support for special syntax. (The exceptions are operators with special evaluation semantics like &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;. These operators cannot be functions since &lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation-1&quot;&gt;Short-Circuit Evaluation&lt;/a&gt; requires that their operands are not evaluated before evaluation of the operator.) Accordingly, you can also apply them using parenthesized argument lists, just as you would any other function:</source>
          <target state="translated">Julia에서 대부분의 연산자는 특수 구문을 지원하는 함수일뿐입니다. 단, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;||&lt;/code&gt; 와 같은 특수 평가 의미론을 가진 연산자는 예외 입니다. &lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation-1&quot;&gt;단락&lt;/a&gt; 연산자 평가에서는 연산자를 평가하기 전에 피연산자를 평가하지 않기 때문에이 연산자는 함수가 될 수 없습니다 . 따라서 괄호로 묶은 인수 목록을 사용하여이를 적용 할 수도 있습니다. 다른 기능과 마찬가지로</target>
        </trans-unit>
        <trans-unit id="cec708186271fab31b28911da66c39fb5ef32d0d" translate="yes" xml:space="preserve">
          <source>In Julia, multiple values are returned and assigned as tuples, e.g. &lt;code&gt;(a, b) = (1, 2)&lt;/code&gt; or &lt;code&gt;a, b = 1, 2&lt;/code&gt;. MATLAB's &lt;code&gt;nargout&lt;/code&gt;, which is often used in MATLAB to do optional work based on the number of returned values, does not exist in Julia. Instead, users can use optional and keyword arguments to achieve similar capabilities.</source>
          <target state="translated">Julia에서는 여러 값이 반환되어 튜플로 지정됩니다 &lt;code&gt;(a, b) = (1, 2)&lt;/code&gt; 예 : (a, b) = (1, 2) 또는 &lt;code&gt;a, b = 1, 2&lt;/code&gt; . MATLAB에서 반환되는 값의 수에 따라 선택적 작업을 수행하는 데 종종 사용되는 MATLAB의 &lt;code&gt;nargout&lt;/code&gt; 은 Julia에 없습니다. 대신 사용자는 선택적 및 키워드 인수를 사용하여 유사한 기능을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f6861a8c923af27ce752544647b06d9e6a0a07e" translate="yes" xml:space="preserve">
          <source>In Julia, not all data structures support logical indexing. Furthermore, logical indexing in Julia is supported only with vectors of length equal to the object being indexed. For example:</source>
          <target state="translated">Julia에서는 모든 데이터 구조가 논리적 인덱싱을 지원하지는 않습니다. 또한 Julia의 논리적 인덱싱은 인덱싱되는 객체와 동일한 길이의 벡터 만 지원됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="451c3e5bbe0419b361a11d608a26c62bcc892288" translate="yes" xml:space="preserve">
          <source>In Julia, one returns a tuple of values to simulate returning multiple values. However, tuples can be created and destructured without needing parentheses, thereby providing an illusion that multiple values are being returned, rather than a single tuple value. For example, the following function returns a pair of values:</source>
          <target state="translated">Julia에서는 여러 값 반환을 시뮬레이션하기 위해 튜플 값을 반환합니다. 그러나 괄호없이 튜플을 생성하고 구조를 해제 할 수 있으므로 단일 튜플 값이 아닌 여러 값이 반환된다는 착시를 제공합니다. 예를 들어 다음 함수는 값 쌍을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d1f236e7a8645aa4ffbd134429aa159fdbc206da" translate="yes" xml:space="preserve">
          <source>In Julia, parentheses must be used to call a function with zero arguments, like in &lt;a href=&quot;../../stdlib/random/index#Base.rand&quot;&gt;&lt;code&gt;rand()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Julia에서는 &lt;a href=&quot;../../stdlib/random/index#Base.rand&quot;&gt; &lt;code&gt;rand()&lt;/code&gt; &lt;/a&gt; 와 같이 인수가없는 함수를 호출하려면 괄호를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b62993ba8b73165f19053f9f6eaf87bfbe97454f" translate="yes" xml:space="preserve">
          <source>In Julia, reductions such as &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.prod&quot;&gt;&lt;code&gt;prod&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/math/index#Base.max&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt; are performed over every element of an array when called with a single argument, as in &lt;code&gt;sum(A)&lt;/code&gt;, even if &lt;code&gt;A&lt;/code&gt; has more than one dimension.</source>
          <target state="translated">줄리아에서 같은 감소 &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/collections/index#Base.prod&quot;&gt; &lt;code&gt;prod&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/math/index#Base.max&quot;&gt; &lt;code&gt;max&lt;/code&gt; &lt;/a&gt; 하나의 인자로 호출 할 때와 같이, 어레이의 모든 요소를 통해 수행되는 &lt;code&gt;sum(A)&lt;/code&gt; 경우에도, &lt;code&gt;A&lt;/code&gt; 는 하나 이상의 치수를 갖는다.</target>
        </trans-unit>
        <trans-unit id="6b1973243505286be855fb241367233be8bd84fa" translate="yes" xml:space="preserve">
          <source>In Julia, sparse matrices are stored in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_.28CSC_or_CCS.29&quot;&gt;Compressed Sparse Column (CSC) format&lt;/a&gt;. Julia sparse matrices have the type &lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt;&lt;code&gt;SparseMatrixCSC{Tv,Ti}&lt;/code&gt;&lt;/a&gt;, where &lt;code&gt;Tv&lt;/code&gt; is the type of the stored values, and &lt;code&gt;Ti&lt;/code&gt; is the integer type for storing column pointers and row indices. The internal representation of &lt;code&gt;SparseMatrixCSC&lt;/code&gt; is as follows:</source>
          <target state="translated">Julia에서는 스파 스 행렬이 &lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_.28CSC_or_CCS.29&quot;&gt;CSC (Compressed Sparse Column) 형식으로&lt;/a&gt; 저장 됩니다 . Julia 스파 스 행렬의 유형은 &lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt; &lt;code&gt;SparseMatrixCSC{Tv,Ti}&lt;/code&gt; &lt;/a&gt; . 여기서 &lt;code&gt;Tv&lt;/code&gt; 는 저장된 값의 유형이고 &lt;code&gt;Ti&lt;/code&gt; 는 열 포인터 및 행 인덱스를 저장하기위한 정수 유형입니다. &lt;code&gt;SparseMatrixCSC&lt;/code&gt; 의 내부 표현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1e8bc1ec2e65356b67489d496d41c529e84e8334" translate="yes" xml:space="preserve">
          <source>In Julia, the binding of a variable &lt;code&gt;x&lt;/code&gt; cannot be changed by passing &lt;code&gt;x&lt;/code&gt; as an argument to a function. When calling &lt;code&gt;change_value!(x)&lt;/code&gt; in the above example, &lt;code&gt;y&lt;/code&gt; is a newly created variable, bound initially to the value of &lt;code&gt;x&lt;/code&gt;, i.e. &lt;code&gt;10&lt;/code&gt;; then &lt;code&gt;y&lt;/code&gt; is rebound to the constant &lt;code&gt;17&lt;/code&gt;, while the variable &lt;code&gt;x&lt;/code&gt; of the outer scope is left untouched.</source>
          <target state="translated">Julia에서는 &lt;code&gt;x&lt;/code&gt; 를 함수에 인수로 전달 하여 변수 &lt;code&gt;x&lt;/code&gt; 의 바인딩을 변경할 수 없습니다 . 위 예제에서 &lt;code&gt;change_value!(x)&lt;/code&gt; 를 호출 할 때 &lt;code&gt;y&lt;/code&gt; 는 새로 생성 된 변수이며 처음에는 &lt;code&gt;x&lt;/code&gt; 값에 바인딩됩니다 . 즉 &lt;code&gt;10&lt;/code&gt; ; 그러면 &lt;code&gt;y&lt;/code&gt; 는 상수 &lt;code&gt;17&lt;/code&gt; 로 리바운드 되지만 외부 스코프 의 변수 &lt;code&gt;x&lt;/code&gt; 는 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="7ad2abcec621eb10f8cdb25e242afd4f9efd6dd1" translate="yes" xml:space="preserve">
          <source>In Julia, the elements of a collection can be passed as arguments to a function using the splat operator &lt;code&gt;...&lt;/code&gt;, as in &lt;code&gt;xs=[1,2]; f(xs...)&lt;/code&gt;.</source>
          <target state="translated">줄리아에서 컬렉션의 요소 플랫 연산자를 사용하는 함수의 인수로서 전달 될 수있다 &lt;code&gt;...&lt;/code&gt; , 마찬가지로 &lt;code&gt;xs=[1,2]; f(xs...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93d049ffcb952000d0f8ebc0a66e0ee55d575d87" translate="yes" xml:space="preserve">
          <source>In Julia, the operator &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;⊻&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/a&gt;) performs the bitwise XOR operation, i.e. &lt;code&gt;^&lt;/code&gt; in C/C++. Also, the bitwise operators do not have the same precedence as C/++, so parenthesis may be required.</source>
          <target state="translated">Julia에서 연산자 &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;⊻&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;xor&lt;/code&gt; &lt;/a&gt; )는 비트 XOR 연산을 수행합니다 ( 예 : C / C ++에서 &lt;code&gt;^&lt;/code&gt; ) . 또한 비트 연산자는 C / ++와 우선 순위가 같지 않으므로 괄호가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8490fa684242627635a34751122775551824f7e6" translate="yes" xml:space="preserve">
          <source>In Julia, the operators &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;|&lt;/code&gt;, and &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;⊻&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/a&gt;) perform the bitwise operations equivalent to &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, and &lt;code&gt;xor&lt;/code&gt; respectively in MATLAB, and have precedence similar to Python's bitwise operators (unlike C). They can operate on scalars or element-wise across arrays and can be used to combine logical arrays, but note the difference in order of operations: parentheses may be required (e.g., to select elements of &lt;code&gt;A&lt;/code&gt; equal to 1 or 2 use &lt;code&gt;(A .== 1) .| (A .== 2)&lt;/code&gt;).</source>
          <target state="translated">Julia에서 연산자 &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;|&lt;/code&gt; , 및 &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;⊻&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;xor&lt;/code&gt; &lt;/a&gt; ) 는 MATLAB에서 각각 &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , 및 &lt;code&gt;xor&lt;/code&gt; 에 해당 하는 비트 단위 연산을 수행 하며 , C와 달리 Python의 비트 연산자와 유사한 우선 순위를 갖습니다. 이들은 어레이에 스칼라 또는 요소 와이즈에 작동 가능 논리 어레이를 결합하는 데 사용될 수 있지만, 동작들의 순서의 차이에 주목 : 괄호 등의 요소를 선택하기 위해 (필요 수 &lt;code&gt;A&lt;/code&gt; 는 1 또는 2를 사용 동일 &lt;code&gt;(A .== 1) .| (A .== 2)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c924b695c23524838be4cdefba6d4ecf3f12bd7f" translate="yes" xml:space="preserve">
          <source>In Julia, values are not copied when assigned or passed to a function. If a function modifies an array, the changes will be visible in the caller. This is very different from R and allows new functions to operate on large data structures much more efficiently.</source>
          <target state="translated">Julia에서는 함수에 할당되거나 함수에 전달 될 때 값이 복사되지 않습니다. 함수가 배열을 수정하면 변경 사항이 호출자에게 표시됩니다. 이것은 R과 매우 다르며 새로운 함수가 큰 데이터 구조에서 훨씬 더 효율적으로 작동 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="4125f91a0372e71681729284bfb74b1b5f121b87" translate="yes" xml:space="preserve">
          <source>In Julia, varargs are specified using the splat operator &lt;code&gt;...&lt;/code&gt;, which always follows the name of a specific variable, unlike R, for which &lt;code&gt;...&lt;/code&gt; can occur in isolation.</source>
          <target state="translated">줄리아에서, 변수 인수는 플랫 연산자 사용하여 지정됩니다 &lt;code&gt;...&lt;/code&gt; R 달리 항상 특정 변수의 이름을 다음과,,,하는 &lt;code&gt;...&lt;/code&gt; 고립에서 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61706e2cf7e3e0b63c2023adcea629882d9748dd" translate="yes" xml:space="preserve">
          <source>In Julia, vectors and matrices are concatenated using &lt;a href=&quot;../../base/arrays/index#Base.hcat&quot;&gt;&lt;code&gt;hcat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/arrays/index#Base.vcat&quot;&gt;&lt;code&gt;vcat&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/arrays/index#Base.hvcat&quot;&gt;&lt;code&gt;hvcat&lt;/code&gt;&lt;/a&gt;, not &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;rbind&lt;/code&gt; and &lt;code&gt;cbind&lt;/code&gt; like in R.</source>
          <target state="translated">Julia에서 벡터와 행렬은 R &lt;code&gt;cbind&lt;/code&gt; &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;rbind&lt;/code&gt; 및 cbind가 아니라 &lt;a href=&quot;../../base/arrays/index#Base.hcat&quot;&gt; &lt;code&gt;hcat&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/arrays/index#Base.vcat&quot;&gt; &lt;code&gt;vcat&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/arrays/index#Base.hvcat&quot;&gt; &lt;code&gt;hvcat&lt;/code&gt; 를&lt;/a&gt; 사용하여 연결 됩니다.</target>
        </trans-unit>
        <trans-unit id="c15bdde6dec6d1761a5dc60f223d32d1ac186e83" translate="yes" xml:space="preserve">
          <source>In Julia, we can access the parts independently to make a copy of that string:</source>
          <target state="translated">Julia에서는 부품에 독립적으로 액세스하여 해당 문자열을 복사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bbe2d9f25b242e167641a97cc1e17c904778314" translate="yes" xml:space="preserve">
          <source>In Julia, whitespace is significant, unlike C/C++, so care must be taken when adding/removing whitespace from a Julia program.</source>
          <target state="translated">Julia에서는 공백이 C / C ++와 달리 중요하므로 Julia 프로그램에서 공백을 추가 / 제거 할 때주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="dfd2a6192ce5ab720952e7ded70bfe43e1c2837a" translate="yes" xml:space="preserve">
          <source>In Julia, you can't dispatch on a &lt;em&gt;value&lt;/em&gt; such as &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. However, you can dispatch on parametric types, and Julia allows you to include &quot;plain bits&quot; values (Types, Symbols, Integers, floating-point numbers, tuples, etc.) as type parameters. A common example is the dimensionality parameter in &lt;code&gt;Array{T,N}&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is a type (e.g., &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;) but &lt;code&gt;N&lt;/code&gt; is just an &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">Julia에서는 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 와 같은 &lt;em&gt;값을&lt;/em&gt; 전달할 수 없습니다 . 그러나 파라 메트릭 유형을 디스패치 할 수 있으며 Julia를 사용하면 &quot;일반 비트&quot;값 (유형, 기호, 정수, 부동 소수점 숫자, 튜플 등)을 유형 매개 변수로 포함 할 수 있습니다. 일반적인 예는 &lt;code&gt;Array{T,N}&lt;/code&gt; 의 차원 매개 변수입니다 . 여기서 &lt;code&gt;T&lt;/code&gt; 는 유형 (예 : &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; )이지만 &lt;code&gt;N&lt;/code&gt; 은 &lt;code&gt;Int&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0987332b373dba2f6dccb678d104e0da95c47a9e" translate="yes" xml:space="preserve">
          <source>In MATLAB, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression &lt;code&gt;x(x&amp;gt;3)&lt;/code&gt; or in the statement &lt;code&gt;x(x&amp;gt;3) = []&lt;/code&gt; to modify &lt;code&gt;x&lt;/code&gt; in-place. In contrast, Julia provides the higher order functions &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt;, allowing users to write &lt;code&gt;filter(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; and &lt;code&gt;filter!(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; as alternatives to the corresponding transliterations &lt;code&gt;x[x.&amp;gt;3]&lt;/code&gt; and &lt;code&gt;x = x[x.&amp;gt;3]&lt;/code&gt;. Using &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt; reduces the use of temporary arrays.</source>
          <target state="translated">MATLAB에서 원하지 않는 값을 제거하는 관용적 방법은 식 &lt;code&gt;x(x&amp;gt;3)&lt;/code&gt; 또는 명령문 &lt;code&gt;x(x&amp;gt;3) = []&lt;/code&gt; 에서와 같이 논리적 인덱싱을 사용 하여 &lt;code&gt;x&lt;/code&gt; 를 제자리에서 수정하는 것입니다. 대조적으로 Julia는 고차 함수 &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt; 제공합니다 ! 사용자가 해당 음역 &lt;code&gt;x[x.&amp;gt;3]&lt;/code&gt; 및 &lt;code&gt;x = x[x.&amp;gt;3]&lt;/code&gt; 에 대한 대안으로 &lt;code&gt;filter(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; 및 &lt;code&gt;filter!(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; 를 작성할 수 있습니다 . 3] . &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt; 사용 ! 임시 배열 사용을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="6e02ea871ca138515cbf18e7481d0fb87b2d5244" translate="yes" xml:space="preserve">
          <source>In R, &lt;code&gt;c(1, 2, 3, 4)[c(TRUE, FALSE)]&lt;/code&gt; is equivalent to &lt;code&gt;c(1, 3)&lt;/code&gt;.</source>
          <target state="translated">R에서 &lt;code&gt;c(1, 2, 3, 4)[c(TRUE, FALSE)]&lt;/code&gt; 는 &lt;code&gt;c(1, 3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="616e3b4685be805ef30bd44974ee4d2b22ae8fea" translate="yes" xml:space="preserve">
          <source>In R, &lt;code&gt;c(1, 2, 3, 4)[c(TRUE, FALSE, TRUE, FALSE)]&lt;/code&gt; is equivalent to &lt;code&gt;c(1, 3)&lt;/code&gt;.</source>
          <target state="translated">R에서 &lt;code&gt;c(1, 2, 3, 4)[c(TRUE, FALSE, TRUE, FALSE)]&lt;/code&gt; 는 &lt;code&gt;c(1, 3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce0a60c169bc6c80688de200a5cb77dbd4fa3448" translate="yes" xml:space="preserve">
          <source>In R, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression &lt;code&gt;x[x&amp;gt;3]&lt;/code&gt; or in the statement &lt;code&gt;x = x[x&amp;gt;3]&lt;/code&gt; to modify &lt;code&gt;x&lt;/code&gt; in-place. In contrast, Julia provides the higher order functions &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt;, allowing users to write &lt;code&gt;filter(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; and &lt;code&gt;filter!(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; as alternatives to the corresponding transliterations &lt;code&gt;x[x.&amp;gt;3]&lt;/code&gt; and &lt;code&gt;x = x[x.&amp;gt;3]&lt;/code&gt;. Using &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt; reduces the use of temporary arrays.</source>
          <target state="translated">R에서 원하지 않는 값을 제거하는 관용적 방법은 식 &lt;code&gt;x[x&amp;gt;3]&lt;/code&gt; 또는 명령문 &lt;code&gt;x = x[x&amp;gt;3]&lt;/code&gt; 과 같이 논리적 인덱싱을 사용 하여 &lt;code&gt;x&lt;/code&gt; 를 제자리에서 수정하는 것입니다. 대조적으로 Julia는 고차 함수 &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt; 제공합니다 ! 사용자가 해당 음역 &lt;code&gt;x[x.&amp;gt;3]&lt;/code&gt; 및 &lt;code&gt;x = x[x.&amp;gt;3]&lt;/code&gt; 에 대한 대안으로 &lt;code&gt;filter(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; 및 &lt;code&gt;filter!(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; 를 작성할 수 있습니다 . 3] . &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt; 사용 ! 임시 배열 사용을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="f6752ab2f8e0e7630531a6d7a1987e0bbb17b890" translate="yes" xml:space="preserve">
          <source>In R, performance requires vectorization. In Julia, almost the opposite is true: the best performing code is often achieved by using devectorized loops.</source>
          <target state="translated">R에서 성능은 벡터화가 필요합니다. Julia에서는 거의 반대가 사실입니다. 가장 성능이 좋은 코드는 종종 벡터화되지 않은 루프를 사용하여 달성됩니다.</target>
        </trans-unit>
        <trans-unit id="01878b8d1b390512d629c49ff65589c19ca63ad8" translate="yes" xml:space="preserve">
          <source>In a linear-algebra context, this means that even though operations like &lt;code&gt;vector + vector&lt;/code&gt; and &lt;code&gt;vector * scalar&lt;/code&gt; are defined, it can be advantageous to instead use &lt;code&gt;vector .+ vector&lt;/code&gt; and &lt;code&gt;vector .* scalar&lt;/code&gt; because the resulting loops can be fused with surrounding computations. For example, consider the two functions:</source>
          <target state="translated">선형 대수 문맥에서 이는 &lt;code&gt;vector + vector&lt;/code&gt; 및 &lt;code&gt;vector * scalar&lt;/code&gt; 와 같은 연산 이 정의되어 있어도 결과 루프가 주변 계산과 융합 될 수 있기 때문에 &lt;code&gt;vector .* scalar&lt;/code&gt; &lt;code&gt;vector .+ vector&lt;/code&gt; 및 벡터. * 스칼라 를 대신 사용하는 것이 유리할 수 있음을 의미합니다 . . 예를 들어 두 가지 기능을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="9e1d6d725f550ad6f9da6bf98cc247f18f2108d6" translate="yes" xml:space="preserve">
          <source>In a local scope, all variables are inherited from its parent global scope block unless:</source>
          <target state="translated">로컬 범위에서 다음과 같은 경우를 제외하고 모든 변수는 상위 전역 범위 블록에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="8fb94127a63695dc8bd7c2b91c9aa1704119e38b" translate="yes" xml:space="preserve">
          <source>In a module, declare that the file specified by &lt;code&gt;path&lt;/code&gt; (relative or absolute) is a dependency for precompilation; that is, the module will need to be recompiled if this file changes.</source>
          <target state="translated">모듈에서 &lt;code&gt;path&lt;/code&gt; (상대 또는 절대) 로 지정된 파일 이 사전 컴파일에 대한 종속성 임을 선언하십시오 . 즉,이 파일이 변경되면 모듈을 다시 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="ba39320cdec145895823bcc997669a25a6af7855" translate="yes" xml:space="preserve">
          <source>In a sense, Julia falls into the &quot;no automatic promotion&quot; category: mathematical operators are just functions with special syntax, and the arguments of functions are never automatically converted. However, one may observe that applying mathematical operations to a wide variety of mixed argument types is just an extreme case of polymorphic multiple dispatch &amp;ndash; something which Julia's dispatch and type systems are particularly well-suited to handle. &quot;Automatic&quot; promotion of mathematical operands simply emerges as a special application: Julia comes with pre-defined catch-all dispatch rules for mathematical operators, invoked when no specific implementation exists for some combination of operand types. These catch-all rules first promote all operands to a common type using user-definable promotion rules, and then invoke a specialized implementation of the operator in question for the resulting values, now of the same type. User-defined types can easily participate in this promotion system by defining methods for conversion to and from other types, and providing a handful of promotion rules defining what types they should promote to when mixed with other types.</source>
          <target state="translated">어떤 의미에서 Julia는 &quot;자동 승격 없음&quot;범주에 속합니다. 수학 연산자는 특별한 구문을 가진 함수일 뿐이며 함수의 인수는 자동으로 변환되지 않습니다. 그러나 수학 연산을 다양한 혼합 인수 유형에 적용하는 것은 다형성 다중 디스패치의 극단적 인 경우입니다. Julia의 디스패치 및 유형 시스템이 특히 처리하기에 적합합니다. 수학 피연산자의 &quot;자동&quot;승격은 단순히 특수 응용 프로그램으로 나타납니다. Julia에는 피연산자 유형의 조합에 대한 특정 구현이 없을 때 호출되는 수학 연산자에 대해 미리 정의 된 catch-all 디스패치 규칙이 제공됩니다. 이 포괄 규칙은 먼저 사용자 정의 승격 규칙을 사용하여 모든 피연산자를 공통 유형으로 승격합니다.그런 다음 결과 값이 동일한 유형의 해당 연산자의 특수 구현을 호출하십시오. 사용자 정의 유형은 다른 유형과의 변환 방법을 정의하고 다른 유형과 혼합 될 때 승격해야하는 유형을 정의하는 소수의 승격 규칙을 제공하여이 승격 시스템에 쉽게 참여할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18e44910a826a7be9fd86ad6a5c3ed3f73d517fa" translate="yes" xml:space="preserve">
          <source>In addition to (and as part of) its support for multi-dimensional arrays, Julia provides native implementations of many common and useful linear algebra operations which can be loaded with &lt;code&gt;using LinearAlgebra&lt;/code&gt;. Basic operations, such as &lt;a href=&quot;#LinearAlgebra.tr&quot;&gt;&lt;code&gt;tr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;inv&lt;/code&gt; are all supported:</source>
          <target state="translated">Julia는 다차원 배열에 대한 지원 &lt;code&gt;using LinearAlgebra&lt;/code&gt; 를 사용하여 로드 할 수있는 많은 일반적이고 유용한 선형 대수 연산의 기본 구현을 제공합니다 . &lt;a href=&quot;#LinearAlgebra.tr&quot;&gt; &lt;code&gt;tr&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#LinearAlgebra.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;inv&lt;/code&gt; 와 같은 기본 조작 이 모두 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="f10487aa88c806dfd44fdee05bfc7281d910b478" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt;, a few other basic functions are needed to use tasks effectively.</source>
          <target state="translated">&lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt; 외에도 작업을 효과적으로 사용하려면 몇 가지 다른 기본 기능이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f2ab7ee40bd53e11319399c116d8d2cc2c48169d" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;using Base&lt;/code&gt;, modules also automatically contain definitions of the &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.MainInclude.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt; functions, which evaluate expressions/files within the global scope of that module.</source>
          <target state="translated">&lt;code&gt;using Base&lt;/code&gt; 를 사용하는 것 외에도 모듈은 자동으로 &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; 정의를 포함 하고 해당 모듈의 전체 범위 내에서 표현식 / 파일을 평가하는 함수를 &lt;a href=&quot;../../base/base/index#Base.MainInclude.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; &lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="10d21e803c8a9917ec9f0f6ebe5595e193060fc6" translate="yes" xml:space="preserve">
          <source>In addition to all the iterable and indexable methods from above, these types can also interact with each other and use most of the methods defined in Julia Base for &lt;code&gt;AbstractArrays&lt;/code&gt;:</source>
          <target state="translated">위의 반복 가능하고 색인 가능한 모든 메소드 외에도 이러한 유형은 서로 상호 작용할 수 있으며 Julia Array에 &lt;code&gt;AbstractArrays&lt;/code&gt; 에 정의 된 대부분의 메소드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e406211c0c63c531f5fd9ccb75f3528a5be0658c" translate="yes" xml:space="preserve">
          <source>In addition to linear indexing, an &lt;code&gt;N&lt;/code&gt;-dimensional array may be indexed with fewer or more than &lt;code&gt;N&lt;/code&gt; indices in certain situations.</source>
          <target state="translated">선형 인덱싱 외에, 특정 상황에서 &lt;code&gt;N&lt;/code&gt; 차원 배열은 &lt;code&gt;N&lt;/code&gt; 개보다 적거나 많은 인덱스로 인덱싱 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="98e86e056613a088089dad092fe39f17f798108b" translate="yes" xml:space="preserve">
          <source>In addition to tasks Julia forwards natively supports multi-threading. Note that this section is experimental and the interfaces may change in the future.</source>
          <target state="translated">Julia 포워드는 기본적으로 멀티 스레딩을 지원합니다. 이 섹션은 실험용이며 향후 인터페이스가 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec666f0e17f38401053d73ee95bfc69ad9a82cc3" translate="yes" xml:space="preserve">
          <source>In addition to the given argument list, every macro is passed extra arguments named &lt;code&gt;__source__&lt;/code&gt; and &lt;code&gt;__module__&lt;/code&gt;.</source>
          <target state="translated">주어진 인수 목록 외에도 모든 매크로에는 &lt;code&gt;__source__&lt;/code&gt; 및 &lt;code&gt;__module__&lt;/code&gt; 이라는 추가 인수가 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="24215bb3919d42188faab69329d0bd6705349ee5" translate="yes" xml:space="preserve">
          <source>In addition, Julia provides many &lt;a href=&quot;#man-linalg-factorizations-1&quot;&gt;factorizations&lt;/a&gt; which can be used to speed up problems such as linear solve or matrix exponentiation by pre-factorizing a matrix into a form more amenable (for performance or memory reasons) to the problem. See the documentation on &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt;&lt;code&gt;factorize&lt;/code&gt;&lt;/a&gt; for more information. As an example:</source>
          <target state="translated">또한 Julia는 매트릭스를 문제에보다 적합한 형태 (예 : 성능 또는 메모리 이유로)로 사전 인수 화하여 선형 해상 또는 행렬 지수와 같은 문제를 가속화하는 데 사용할 수있는 많은 &lt;a href=&quot;#man-linalg-factorizations-1&quot;&gt;인수 분해&lt;/a&gt; 를 제공합니다 . 자세한 내용은 &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt; &lt;code&gt;factorize&lt;/code&gt; 에&lt;/a&gt; 대한 설명서 를 참조하십시오. 예로서:</target>
        </trans-unit>
        <trans-unit id="655d29ad2536f5920e2f78273e9aa1a0a062ab22" translate="yes" xml:space="preserve">
          <source>In all cases the ambiguity is resolved in favor of interpretation as numeric literals:</source>
          <target state="translated">모든 경우에 모호성은 숫자 리터럴로 해석하기 위해 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="73ededace2cf23e632ef0400ebd52a78d322cb00" translate="yes" xml:space="preserve">
          <source>In all of the above modes, the executed lines get saved to a history file, which can be searched. To initiate an incremental search through the previous history, type &lt;code&gt;^R&lt;/code&gt; &amp;ndash; the control key together with the &lt;code&gt;r&lt;/code&gt; key. The prompt will change to &lt;code&gt;(reverse-i-search)`':&lt;/code&gt;, and as you type the search query will appear in the quotes. The most recent result that matches the query will dynamically update to the right of the colon as more is typed. To find an older result using the same query, simply type &lt;code&gt;^R&lt;/code&gt; again.</source>
          <target state="translated">위의 모든 모드에서 실행 된 행은 내역 파일에 저장되어 검색 할 수 있습니다. 이전 기록을 통해 증분 검색을 시작하려면 &lt;code&gt;^R&lt;/code&gt; 키 &amp;ndash; &lt;code&gt;r&lt;/code&gt; 키 와 함께 제어 키를 입력하십시오 . 프롬프트가 &lt;code&gt;(reverse-i-search)`':&lt;/code&gt; 바뀌고 입력하면 검색어가 따옴표로 나타납니다. 쿼리와 일치하는 가장 최근 결과는 더 많이 입력 될 때 콜론 오른쪽으로 동적으로 업데이트됩니다. 동일한 쿼리를 사용하여 이전 결과를 찾으려면 &lt;code&gt;^R&lt;/code&gt; 다시 입력하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="486b6c3b28f75c69ec1138bc26e8cd5e151040ee" translate="yes" xml:space="preserve">
          <source>In all of these cases, &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; ultimately operates on a &lt;a href=&quot;../../base/parallel/index#Base.Condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; object, which is in charge of queueing and restarting tasks. When a task calls &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on a &lt;a href=&quot;../../base/parallel/index#Base.Condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt;, the task is marked as non-runnable, added to the condition's queue, and switches to the scheduler. The scheduler will then pick another task to run, or block waiting for external events. If all goes well, eventually an event handler will call &lt;a href=&quot;../../base/parallel/index#Base.notify&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt; on the condition, which causes tasks waiting for that condition to become runnable again.</source>
          <target state="translated">이러한 모든 경우에 &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 궁극적으로 작업을 대기 및 다시 시작 하는 &lt;a href=&quot;../../base/parallel/index#Base.Condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 개체에서 작동 합니다. 작업이 &lt;a href=&quot;../../base/parallel/index#Base.Condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 를 호출하면 작업이 실행할 수 없는 것으로 표시되고 조건 대기열에 추가 된 후 스케줄러로 전환됩니다. 그런 다음 스케줄러는 실행할 다른 작업을 선택하거나 외부 이벤트 대기를 차단합니다. 모든 것이 잘 진행되면 이벤트 핸들러는 조건에 대해 &lt;a href=&quot;../../base/parallel/index#Base.notify&quot;&gt; &lt;code&gt;notify&lt;/code&gt; &lt;/a&gt; 를 호출 하여 해당 조건을 기다리는 태스크를 다시 실행할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="a3a06ca6a5caa39934e953da1e9f4336d389c6e0" translate="yes" xml:space="preserve">
          <source>In all these cases, &lt;code&gt;x&lt;/code&gt; is bound to a tuple of the trailing values passed to &lt;code&gt;bar&lt;/code&gt;.</source>
          <target state="translated">이 모든 경우에 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;bar&lt;/code&gt; 에 전달 된 후행 값의 튜플에 바인딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="b99ce256d318c1c2f2354f48619a6804a821c4e0" translate="yes" xml:space="preserve">
          <source>In an all-to-all topology (the default), all workers connect to each other via plain TCP sockets. The security policy on the cluster nodes must thus ensure free connectivity between workers for the ephemeral port range (varies by OS).</source>
          <target state="translated">종합 토폴로지 (기본값)에서 모든 작업자는 일반 TCP 소켓을 통해 서로 연결됩니다. 따라서 클러스터 노드의 보안 정책은 임시 포트 범위 (OS에 따라 다름)의 작업자간에 자유로운 연결을 보장해야합니다.</target>
        </trans-unit>
        <trans-unit id="3c8cda3e1e2865b38c43f81658a24d808d5fe92a" translate="yes" xml:space="preserve">
          <source>In both Julia and MATLAB, the variable &lt;code&gt;ans&lt;/code&gt; is set to the value of the last expression issued in an interactive session. In Julia, unlike MATLAB, &lt;code&gt;ans&lt;/code&gt; is not set when Julia code is run in non-interactive mode.</source>
          <target state="translated">Julia와 MATLAB에서 변수 &lt;code&gt;ans&lt;/code&gt; 는 대화식 세션에서 발행 된 마지막 표현식의 값으로 설정됩니다. Julia에서는 MATLAB과 달리 Julia 코드가 비 대화식 모드에서 실행될 때 &lt;code&gt;ans&lt;/code&gt; 가 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b8e4ada1bafffe80f21502163f1a66167c6265bb" translate="yes" xml:space="preserve">
          <source>In both the Julian and help modes of the REPL, one can enter the first few characters of a function or type and then press the tab key to get a list all matches:</source>
          <target state="translated">REPL의 Julian 및 help 모드에서 함수 또는 유형의 처음 몇 문자를 입력 한 다음 tab 키를 눌러 모든 일치하는 목록을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="661336deabc49d6bd089fab9e0056b342efe5561" translate="yes" xml:space="preserve">
          <source>In case of remote references, the size of the local reference object is quite small, while the value stored on the remote node may be quite large. Since the local object may not be collected immediately, it is a good practice to explicitly call &lt;a href=&quot;../../base/base/index#Base.finalize&quot;&gt;&lt;code&gt;finalize&lt;/code&gt;&lt;/a&gt; on local instances of a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt;, or on unfetched &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;s. Since calling &lt;code&gt;fetch&lt;/code&gt; on a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; also removes its reference from the remote store, this is not required on fetched &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;s. Explicitly calling &lt;a href=&quot;../../base/base/index#Base.finalize&quot;&gt;&lt;code&gt;finalize&lt;/code&gt;&lt;/a&gt; results in an immediate message sent to the remote node to go ahead and remove its reference to the value.</source>
          <target state="translated">원격 참조의 경우 로컬 참조 객체의 크기는 매우 작지만 원격 노드에 저장된 값은 상당히 클 수 있습니다. 로컬 객체는 즉시 수집되지 않을 수 있으므로 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; 의 로컬 인스턴스 또는 페치되지 않은 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;../../base/base/index#Base.finalize&quot;&gt; &lt;code&gt;finalize&lt;/code&gt; &lt;/a&gt; 를 명시 적으로 호출하는 것이 좋습니다 . &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;fetch&lt;/code&gt; 를 호출 하면 원격 저장소에서 해당 참조가 제거되므로 가져온 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 에서는 필요하지 않습니다 . 명시 적으로 &lt;a href=&quot;../../base/base/index#Base.finalize&quot;&gt; &lt;code&gt;finalize&lt;/code&gt; &lt;/a&gt; 를 호출 하면 원격 노드에 즉시 메시지가 전송되어 값에 대한 참조를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="bf07799a9aab60dca9abdd6af2de0083f4fd55f9" translate="yes" xml:space="preserve">
          <source>In cases where &lt;a href=&quot;../base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; would need to take a Julia object and turn it into a &lt;code&gt;Ptr&lt;/code&gt;, this function should be used to define and perform that conversion.</source>
          <target state="translated">경우에 &lt;a href=&quot;../base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; 줄리아 객체를 취하여으로 바꿀 필요가 &lt;code&gt;Ptr&lt;/code&gt; ,이 기능을 정의하고 변환을 수행하는 데 사용되어야한다.</target>
        </trans-unit>
        <trans-unit id="62d2a9fdaaf73a0db81376306b368d8784225fa7" translate="yes" xml:space="preserve">
          <source>In cases where &lt;code&gt;x&lt;/code&gt; cannot be safely converted to &lt;code&gt;T&lt;/code&gt;, unlike &lt;a href=&quot;../base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;cconvert&lt;/code&gt; may return an object of a type different from &lt;code&gt;T&lt;/code&gt;, which however is suitable for &lt;a href=&quot;#Base.unsafe_convert&quot;&gt;&lt;code&gt;unsafe_convert&lt;/code&gt;&lt;/a&gt; to handle. The result of this function should be kept valid (for the GC) until the result of &lt;a href=&quot;#Base.unsafe_convert&quot;&gt;&lt;code&gt;unsafe_convert&lt;/code&gt;&lt;/a&gt; is not needed anymore. This can be used to allocate memory that will be accessed by the &lt;code&gt;ccall&lt;/code&gt;. If multiple objects need to be allocated, a tuple of the objects can be used as return value.</source>
          <target state="translated">경우에 &lt;code&gt;x&lt;/code&gt; 는 안전하게 변환 할 수 없습니다 &lt;code&gt;T&lt;/code&gt; , 달리 &lt;a href=&quot;../base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;cconvert&lt;/code&gt; 는 에서 종류의 서로 다른의 객체 반환 할 수 있습니다 &lt;code&gt;T&lt;/code&gt; 그러나 적합, &lt;a href=&quot;#Base.unsafe_convert&quot;&gt; &lt;code&gt;unsafe_convert&lt;/code&gt; &lt;/a&gt; 핸들을. &lt;a href=&quot;#Base.unsafe_convert&quot;&gt; &lt;code&gt;unsafe_convert&lt;/code&gt; &lt;/a&gt; 의 결과가 더 이상 필요하지 않을 때까지이 함수의 결과는 유효합니다 (GC에 대해) . 이것은 &lt;code&gt;ccall&lt;/code&gt; 이 액세스 할 메모리를 할당하는 데 사용될 수 있습니다 . 여러 객체를 할당해야하는 경우 해당 객체의 튜플을 반환 값으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20a6a008693353a3bba07852d46b5ac7a61ffe13" translate="yes" xml:space="preserve">
          <source>In cases where you want to be able to mix multiple &lt;code&gt;AbstractArrayStyle&lt;/code&gt;s and keep track of dimensionality, your style needs to support a &lt;a href=&quot;../base/index#Base.Val&quot;&gt;&lt;code&gt;Val&lt;/code&gt;&lt;/a&gt; constructor:</source>
          <target state="translated">여러 &lt;code&gt;AbstractArrayStyle&lt;/code&gt; 을 혼합 하고 차원을 추적 하려는 경우 스타일은 &lt;a href=&quot;../base/index#Base.Val&quot;&gt; &lt;code&gt;Val&lt;/code&gt; &lt;/a&gt; 생성자 를 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="371183813ad83fb61979b332a5033cb1b76e325b" translate="yes" xml:space="preserve">
          <source>In code that performs state changes or uses resources like files, there is typically clean-up work (such as closing files) that needs to be done when the code is finished. Exceptions potentially complicate this task, since they can cause a block of code to exit before reaching its normal end. The &lt;code&gt;finally&lt;/code&gt; keyword provides a way to run some code when a given block of code exits, regardless of how it exits.</source>
          <target state="translated">상태 변경을 수행하거나 파일과 같은 리소스를 사용하는 코드에는 일반적으로 코드가 완료 될 때 수행해야하는 정리 작업 (예 : 파일 닫기)이 있습니다. 예외로 인해이 작업이 복잡해질 수 있습니다. 정상적인 종료에 도달하기 전에 코드 블록이 종료 될 수 있기 때문입니다. &lt;code&gt;finally&lt;/code&gt; 키워드는 몇 가지 코드를 실행할 수있는 방법을 제공 할 때 코드가 종료 주어진 블록에 관계없이 종료 방법.</target>
        </trans-unit>
        <trans-unit id="439d8b30359bbc8d6b7d18a09ea082d188e37311" translate="yes" xml:space="preserve">
          <source>In contrast to the use of the &lt;code&gt;...&lt;/code&gt; operator to denote slurping many different arguments into one argument when defining a function, the &lt;code&gt;...&lt;/code&gt; operator is also used to cause a single function argument to be split apart into many different arguments when used in the context of a function call. This use of &lt;code&gt;...&lt;/code&gt; is called splatting:</source>
          <target state="translated">함수를 정의 할 때 많은 다른 인수를 하나의 인수로 슬러 핑하는 것을 나타내는 &lt;code&gt;...&lt;/code&gt; 연산자를 사용하는 것과는 달리 &lt;code&gt;...&lt;/code&gt; 연산자는 단일 함수 인수를 여러 인수로 분리 할 때도 사용됩니다. 함수 호출의 컨텍스트 이 사용은 &lt;code&gt;...&lt;/code&gt; 스플래라고합니다 :</target>
        </trans-unit>
        <trans-unit id="9c8f753b1f6a1a771efd3464599b303870131486" translate="yes" xml:space="preserve">
          <source>In contrast with &lt;code&gt;for i = 1:length(A)&lt;/code&gt;, iterating with &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt; provides an efficient way to iterate over any array type.</source>
          <target state="translated">대조적으로 &lt;code&gt;for i = 1:length(A)&lt;/code&gt; 가진 반복 &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt; &lt;code&gt;eachindex&lt;/code&gt; 하는&lt;/a&gt; 임의의 어레이 형 반복하는 효율적인 방법을 제공한다.</target>
        </trans-unit>
        <trans-unit id="7142e8f2e408ab35102cc379780cf0e33b4e8234" translate="yes" xml:space="preserve">
          <source>In contrast, once &lt;code&gt;m&lt;/code&gt; is constructed, the type of &lt;code&gt;m.a&lt;/code&gt; cannot change:</source>
          <target state="translated">반대로, 일단 &lt;code&gt;m&lt;/code&gt; 이 구성되면 &lt;code&gt;m.a&lt;/code&gt; 의 유형을 변경할 수 없습니다 :</target>
        </trans-unit>
        <trans-unit id="0d5137a043d33963d37d01766416ca959609cfd8" translate="yes" xml:space="preserve">
          <source>In general you can place a &lt;code&gt;return&lt;/code&gt; statement anywhere within a function body, including within deeply nested loops or conditionals, but be careful with &lt;code&gt;do&lt;/code&gt; blocks. For example:</source>
          <target state="translated">일반적으로 깊게 중첩 된 루프 나 조건부 등을 포함하여 함수 본문 내 어디에서나 &lt;code&gt;return&lt;/code&gt; 문을 배치 할 수 있지만 &lt;code&gt;do&lt;/code&gt; 블록에 주의하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c2d6d0431d403e66982fc3bf0664898813b75b58" translate="yes" xml:space="preserve">
          <source>In general, a broadcast operation is represented by a lazy &lt;code&gt;Broadcasted&lt;/code&gt; container that holds onto the function to be applied alongside its arguments. Those arguments may themselves be more nested &lt;code&gt;Broadcasted&lt;/code&gt; containers, forming a large expression tree to be evaluated. A nested tree of &lt;code&gt;Broadcasted&lt;/code&gt; containers is directly constructed by the implicit dot syntax; &lt;code&gt;5 .+ 2.*x&lt;/code&gt; is transiently represented by &lt;code&gt;Broadcasted(+, 5, Broadcasted(*, 2, x))&lt;/code&gt;, for example. This is invisible to users as it is immediately realized through a call to &lt;code&gt;copy&lt;/code&gt;, but it is this container that provides the basis for broadcast's extensibility for authors of custom types. The built-in broadcast machinery will then determine the result type and size based upon the arguments, allocate it, and then finally copy the realization of the &lt;code&gt;Broadcasted&lt;/code&gt; object into it with a default &lt;code&gt;copyto!(::AbstractArray, ::Broadcasted)&lt;/code&gt; method. The built-in fallback &lt;code&gt;broadcast&lt;/code&gt; and &lt;code&gt;broadcast!&lt;/code&gt; methods similarly construct a transient &lt;code&gt;Broadcasted&lt;/code&gt; representation of the operation so they can follow the same codepath. This allows custom array implementations to provide their own &lt;code&gt;copyto!&lt;/code&gt; specialization to customize and optimize broadcasting. This is again determined by the computed broadcast style. This is such an important part of the operation that it is stored as the first type parameter of the &lt;code&gt;Broadcasted&lt;/code&gt; type, allowing for dispatch and specialization.</source>
          <target state="translated">일반적으로 브로드 캐스트 작업은 인수와 함께 적용 할 함수를 보유 하는 지연된 &lt;code&gt;Broadcasted&lt;/code&gt; 컨테이너로 표시됩니다 . 이러한 인수 자체는 더 중첩 된 &lt;code&gt;Broadcasted&lt;/code&gt; 컨테이너 일 수 있으며, 평가할 큰 표현식 트리를 형성합니다. &lt;code&gt;Broadcasted&lt;/code&gt; 컨테이너 의 중첩 트리는 암시 적 점 구문으로 직접 구성됩니다. &lt;code&gt;5 .+ 2.*x&lt;/code&gt; 는 &lt;code&gt;Broadcasted(+, 5, Broadcasted(*, 2, x))&lt;/code&gt; 로 일시적으로 표현됩니다 . &lt;code&gt;copy&lt;/code&gt; 요청을 통해 즉시 실현되므로 사용자에게 보이지 않습니다. 이지만이 컨테이너는 사용자 정의 유형의 작성자에게 브로드 캐스트의 확장 성을위한 기초를 제공합니다. 내장 된 브로드 캐스트 메커니즘은 인수를 기반으로 결과 유형과 크기를 결정하고 할당 한 다음 최종적으로 &lt;code&gt;Broadcasted&lt;/code&gt; 객체 의 구현을 기본값 으로 복사합니다. &lt;code&gt;copyto!(::AbstractArray, ::Broadcasted)&lt;/code&gt; 메서드입니다. 대체 폴백 &lt;code&gt;broadcast&lt;/code&gt; 및 &lt;code&gt;broadcast!&lt;/code&gt; 메소드 는 작업 의 일시적인 &lt;code&gt;Broadcasted&lt;/code&gt; 표현을 유사하게 구성 하여 동일한 코드 경로를 따를 수 있습니다. 이것은 커스텀 배열 구현이 그들 만의 &lt;code&gt;copyto!&lt;/code&gt; 를 제공 할 수있게합니다 !방송을 사용자 정의하고 최적화하는 전문화. 이것은 다시 계산 된 방송 스타일에 의해 결정됩니다. 이것은 &lt;code&gt;Broadcasted&lt;/code&gt; 유형 의 첫 번째 유형 매개 변수로 저장되어 디스패치 및 전문화가 가능하도록 하는 작업의 중요한 부분 입니다.</target>
        </trans-unit>
        <trans-unit id="8d1babd281f2e672316bf23dea36c5ab29827a0a" translate="yes" xml:space="preserve">
          <source>In general, if you have &lt;code&gt;N&lt;/code&gt; samples collected at a line, you can expect an uncertainty on the order of &lt;code&gt;sqrt(N)&lt;/code&gt; (barring other sources of noise, like how busy the computer is with other tasks). The major exception to this rule is garbage collection, which runs infrequently but tends to be quite expensive. (Since Julia's garbage collector is written in C, such events can be detected using the &lt;code&gt;C=true&lt;/code&gt; output mode described below, or by using &lt;a href=&quot;https://github.com/timholy/ProfileView.jl&quot;&gt;ProfileView.jl&lt;/a&gt;.)</source>
          <target state="translated">일반적으로 한 줄에 &lt;code&gt;N&lt;/code&gt; 개의 샘플이 수집 된 경우 &lt;code&gt;sqrt(N)&lt;/code&gt; 순서로 불확실성을 기대할 수 있습니다 (컴퓨터가 다른 작업으로 얼마나 바빠지는지 등 다른 소음원 제외). 이 규칙의 주요 예외는 가비지 수집으로, 드물게 실행되지만 비용이 많이 드는 경향이 있습니다. Julia의 가비지 수집기는 C로 작성되므로 아래에 설명 된 &lt;code&gt;C=true&lt;/code&gt; 출력 모드를 사용하거나 &lt;a href=&quot;https://github.com/timholy/ProfileView.jl&quot;&gt;ProfileView.jl&lt;/a&gt; 을 사용하여 이러한 이벤트를 감지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="efbd7c168e8e9417f99b66ae892e749285151330" translate="yes" xml:space="preserve">
          <source>In general, the &lt;code&gt;for&lt;/code&gt; loop construct can iterate over any container. In these cases, the alternative (but fully equivalent) keyword &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;&amp;isin;&lt;/code&gt; is typically used instead of &lt;code&gt;=&lt;/code&gt;, since it makes the code read more clearly:</source>
          <target state="translated">일반적으로 &lt;code&gt;for&lt;/code&gt; 루프 구문은 모든 컨테이너를 반복 할 수 있습니다. 이 경우 대체 키워드 &lt;code&gt;in&lt;/code&gt; 또는 완전히 동등한 키워드 ) 또는 &lt;code&gt;&amp;isin;&lt;/code&gt; 가 일반적으로 &lt;code&gt;=&lt;/code&gt; 대신에 사용됩니다 . 코드를보다 명확하게 읽을 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="e63801e02d1bdf10fcfad068986ce15007cba3d8" translate="yes" xml:space="preserve">
          <source>In general, the Julia backtick syntax is carefully designed so that you can just cut-and-paste shell commands as is into backticks and they will work: the escaping, quoting, and interpolation behaviors are the same as the shell's. The only difference is that the interpolation is integrated and aware of Julia's notion of what is a single string value, and what is a container for multiple values. Let's try the above two examples in Julia:</source>
          <target state="translated">일반적으로 Julia backtick 구문은 백틱과 마찬가지로 쉘 명령을 잘라서 붙여 넣기 만하면 작동합니다. 이스케이프, 인용 및 보간 동작은 쉘과 동일합니다. 유일한 차이점은 보간이 통합되어 있고 단일 문자열 값이 무엇인지에 대한 Julia의 개념과 여러 값을위한 컨테이너가 무엇인지 알고 있다는 것입니다. Julia에서 위의 두 가지 예를 시도해 봅시다.</target>
        </trans-unit>
        <trans-unit id="e9d0a19dc1691ca7e9543783f1a58a636105f54f" translate="yes" xml:space="preserve">
          <source>In general, unlike many other technical computing languages, Julia does not expect programs to be written in a vectorized style for performance. Julia's compiler uses type inference and generates optimized code for scalar array indexing, allowing programs to be written in a style that is convenient and readable, without sacrificing performance, and using less memory at times.</source>
          <target state="translated">일반적으로 다른 많은 기술 컴퓨팅 언어와 달리 Julia는 프로그램이 벡터화 된 스타일로 작성되어 성능을 기대하지 않습니다. Julia의 컴파일러는 형식 유추를 사용하고 스칼라 배열 인덱싱에 최적화 된 코드를 생성하여 성능을 저하시키지 않고 때때로 적은 메모리를 사용하지 않고도 편리하고 읽기 쉬운 스타일로 프로그램을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0aca2d8ec448ee15667ecd2efa9a783d316a76f6" translate="yes" xml:space="preserve">
          <source>In general, you cannot assume that &lt;code&gt;display&lt;/code&gt; output goes to &lt;code&gt;stdout&lt;/code&gt; (unlike &lt;a href=&quot;#Base.print&quot;&gt;&lt;code&gt;print(x)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show(x)&lt;/code&gt;&lt;/a&gt;). For example, &lt;code&gt;display(x)&lt;/code&gt; may open up a separate window with an image. &lt;code&gt;display(x)&lt;/code&gt; means &quot;show &lt;code&gt;x&lt;/code&gt; in the best way you can for the current output device(s).&quot; If you want REPL-like text output that is guaranteed to go to &lt;code&gt;stdout&lt;/code&gt;, use &lt;a href=&quot;#Base.show-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;show(stdout, &quot;text/plain&quot;, x)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">일반적으로, &lt;a href=&quot;#Base.print&quot;&gt; &lt;code&gt;print(x)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show(x)&lt;/code&gt; &lt;/a&gt; 와 달리 &lt;code&gt;display&lt;/code&gt; 출력이 &lt;code&gt;stdout&lt;/code&gt; 이라고 가정 할 수 없습니다 . 예를 들어, &lt;code&gt;display(x)&lt;/code&gt; 는 이미지가있는 별도의 창을 열 수 있습니다. &lt;code&gt;display(x)&lt;/code&gt; 는 &quot; 현재 출력 장치에 대해 최상의 방법으로 &lt;code&gt;x&lt;/code&gt; 를 표시합니다&quot;를 의미 합니다. 당신이 원하는 경우 REPL 같은 이동 보장 텍스트 출력 &lt;code&gt;stdout&lt;/code&gt; , 사용 &lt;a href=&quot;#Base.show-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;show(stdout, &quot;text/plain&quot;, x)&lt;/code&gt; &lt;/a&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="421d35772a37767957f94e34c887a2a8d79cd54e" translate="yes" xml:space="preserve">
          <source>In interpreting the results, there are a few important details. Under the &lt;code&gt;user&lt;/code&gt; setting, the first line of any function directly called from the REPL will exhibit allocation due to events that happen in the REPL code itself. More significantly, JIT-compilation also adds to allocation counts, because much of Julia's compiler is written in Julia (and compilation usually requires memory allocation). The recommended procedure is to force compilation by executing all the commands you want to analyze, then call &lt;a href=&quot;../../stdlib/profile/index#Profile.clear_malloc_data&quot;&gt;&lt;code&gt;Profile.clear_malloc_data()&lt;/code&gt;&lt;/a&gt; to reset all allocation counters. Finally, execute the desired commands and quit Julia to trigger the generation of the &lt;code&gt;.mem&lt;/code&gt; files.</source>
          <target state="translated">결과를 해석 할 때 몇 가지 중요한 세부 사항이 있습니다. 언더 &lt;code&gt;user&lt;/code&gt; 설정, 직접 REPL에서 호출하는 함수의 첫 번째 줄 인해 REPL 코드 자체에서 일어나는 이벤트에 할당을 전시 할 예정이다. 더 중요한 것은 Julia의 컴파일러가 Julia로 작성되기 때문에 JIT 컴파일도 할당 횟수에 추가됩니다 (일반적으로 메모리 할당이 필요함). 권장되는 절차는 분석하려는 모든 명령을 실행하여 컴파일을 강제 한 다음 &lt;a href=&quot;../../stdlib/profile/index#Profile.clear_malloc_data&quot;&gt; &lt;code&gt;Profile.clear_malloc_data()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 모든 할당 카운터를 재설정하는 것입니다. 마지막으로 원하는 명령을 실행하고 Julia를 종료하여 &lt;code&gt;.mem&lt;/code&gt; 파일 생성을 트리거 합니다.</target>
        </trans-unit>
        <trans-unit id="76e2766644f11aec36d4590582770e2731974fc5" translate="yes" xml:space="preserve">
          <source>In mainstream object oriented languages, such as C++, Java, Python and Ruby, composite types also have named functions associated with them, and the combination is called an &quot;object&quot;. In purer object-oriented languages, such as Ruby or Smalltalk, all values are objects whether they are composites or not. In less pure object oriented languages, including C++ and Java, some values, such as integers and floating-point values, are not objects, while instances of user-defined composite types are true objects with associated methods. In Julia, all values are objects, but functions are not bundled with the objects they operate on. This is necessary since Julia chooses which method of a function to use by multiple dispatch, meaning that the types of &lt;em&gt;all&lt;/em&gt; of a function's arguments are considered when selecting a method, rather than just the first one (see &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt; for more information on methods and dispatch). Thus, it would be inappropriate for functions to &quot;belong&quot; to only their first argument. Organizing methods into function objects rather than having named bags of methods &quot;inside&quot; each object ends up being a highly beneficial aspect of the language design.</source>
          <target state="translated">C ++, Java, Python 및 Ruby와 같은 주류 객체 지향 언어에서 복합 유형에도 이와 관련된 기능이 명명되어 있으며이 조합을 &quot;객체&quot;라고합니다. Ruby 또는 Smalltalk와 같은보다 순수한 객체 지향 언어에서 모든 값은 합성이든 아니든 객체입니다. C ++ 및 Java를 포함하여 덜 순수한 객체 지향 언어에서 정수 및 부동 소수점 값과 같은 일부 값은 객체가 아닌 반면 사용자 정의 복합 유형의 인스턴스는 연관된 메소드가있는 실제 객체입니다. Julia에서 모든 값은 객체이지만 함수는 작동하는 객체와 함께 제공되지 않습니다. Julia는 여러 디스패치에서 사용할 함수의 메소드를 선택하기 때문에 필요합니다.&lt;em&gt; 합니다.&lt;/em&gt;오히려 단지 처음보다는 방법을 선택하는 경우, 함수의 인수가 고려된다 (참조 : &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;메서드&lt;/a&gt; 방법 및 디스패치에 대한 추가 정보를). 따라서 함수가 첫 번째 인수에만 &quot;포함&quot;하는 것은 부적절합니다. 각 개체를 &quot;내부&quot;로 명명 된 메서드 모음을 사용하지 않고 함수를 함수 개체로 구성하면 결국 언어 디자인에서 매우 유용한 측면이됩니다.</target>
        </trans-unit>
        <trans-unit id="eae8b05ff1c12682f8c0f5b0dacd56bde327dcb6" translate="yes" xml:space="preserve">
          <source>In many cases there are in-place versions of matrix operations that allow you to supply a pre-allocated output vector or matrix. This is useful when optimizing critical code in order to avoid the overhead of repeated allocations. These in-place operations are suffixed with &lt;code&gt;!&lt;/code&gt; below (e.g. &lt;code&gt;mul!&lt;/code&gt;) according to the usual Julia convention.</source>
          <target state="translated">대부분의 경우 사전 할당 된 출력 벡터 또는 행렬을 제공 할 수있는 적절한 버전의 행렬 연산이 있습니다. 이는 반복 할당의 오버 헤드를 피하기 위해 중요 코드를 최적화 할 때 유용합니다. 이 내부 작업에는 &lt;code&gt;!&lt;/code&gt; 가 붙습니다 . 일반적인 Julia 규칙에 따라 아래 (예 : &lt;code&gt;mul!&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1ed441529eec7f43ad66971217220df4ecd80a6e" translate="yes" xml:space="preserve">
          <source>In many cases, Julia is able to automatically vectorize inner for loops without the use of &lt;code&gt;@simd&lt;/code&gt;. Using &lt;code&gt;@simd&lt;/code&gt; gives the compiler a little extra leeway to make it possible in more situations. In either case, your inner loop should have the following properties to allow vectorization:</source>
          <target state="translated">대부분의 경우 Julia는 &lt;code&gt;@simd&lt;/code&gt; 를 사용하지 않고 inner for 루프를 자동으로 벡터화 할 수 있습니다 . &lt;code&gt;@simd&lt;/code&gt; 를 사용하면 더 많은 상황에서 가능하도록 컴파일러에 약간의 여유가 생깁니다 . 두 경우 모두 내부 루프에 벡터화를 허용하는 다음 속성이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="36269174e578550d7d7f0601c4aea1c6ce0438f9" translate="yes" xml:space="preserve">
          <source>In many cases, function arguments have sensible default values and therefore might not need to be passed explicitly in every call. For example, the function &lt;a href=&quot;../../stdlib/dates/index#Dates.Date&quot;&gt;&lt;code&gt;Date(y, [m, d])&lt;/code&gt;&lt;/a&gt; from &lt;code&gt;Dates&lt;/code&gt; module constructs a &lt;code&gt;Date&lt;/code&gt; type for a given year &lt;code&gt;y&lt;/code&gt;, month &lt;code&gt;m&lt;/code&gt; and day &lt;code&gt;d&lt;/code&gt;. However, &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; arguments are optional and their default value is &lt;code&gt;1&lt;/code&gt;. This behavior can be expressed concisely as:</source>
          <target state="translated">대부분의 경우 함수 인수는 적절한 기본값을 가지므로 모든 호출에서 명시 적으로 전달할 필요는 없습니다. 예를 들어, 함수 &lt;a href=&quot;../../stdlib/dates/index#Dates.Date&quot;&gt; &lt;code&gt;Date(y, [m, d])&lt;/code&gt; &lt;/a&gt; 로부터 &lt;code&gt;Dates&lt;/code&gt; 모듈은 구축 &lt;code&gt;Date&lt;/code&gt; 소정 년 대 형 &lt;code&gt;y&lt;/code&gt; , 달 &lt;code&gt;m&lt;/code&gt; 및 일 &lt;code&gt;d&lt;/code&gt; . 그러나 &lt;code&gt;m&lt;/code&gt; 및 &lt;code&gt;d&lt;/code&gt; 인수는 선택 사항이며 기본값은 &lt;code&gt;1&lt;/code&gt; 입니다. 이 동작은 다음과 같이 간결하게 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dd343721288798b24ab9ba3f9547e7ac41c164d" translate="yes" xml:space="preserve">
          <source>In many cases, it is redundant to provide the type of &lt;code&gt;Point&lt;/code&gt; object one wants to construct, since the types of arguments to the constructor call already implicitly provide type information. For that reason, you can also apply &lt;code&gt;Point&lt;/code&gt; itself as a constructor, provided that the implied value of the parameter type &lt;code&gt;T&lt;/code&gt; is unambiguous:</source>
          <target state="translated">많은 경우, 생성자 호출에 대한 인수 유형이 이미 암시 적으로 유형 정보를 제공하므로 구성하려는 &lt;code&gt;Point&lt;/code&gt; 객체 유형을 제공하는 것이 중복됩니다 . 따라서 매개 변수 유형 &lt;code&gt;T&lt;/code&gt; 의 내재 된 값 이 모호하지 않은 경우 &lt;code&gt;Point&lt;/code&gt; 자체를 생성자로 적용 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="269254287f284598e6e04a282963713d5ef0932c" translate="yes" xml:space="preserve">
          <source>In many cases, the resolution specified for rounding (e.g., &lt;code&gt;Dates.Second(30)&lt;/code&gt;) divides evenly into the next largest period (in this case, &lt;code&gt;Dates.Minute(1)&lt;/code&gt;). But rounding behaviour in cases in which this is not true may lead to confusion. What is the expected result of rounding a &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to the nearest 10 hours?</source>
          <target state="translated">대부분의 경우 반올림에 지정된 해상도 (예 : &lt;code&gt;Dates.Second(30)&lt;/code&gt; )는 다음으로 큰 기간 (이 경우 &lt;code&gt;Dates.Minute(1)&lt;/code&gt; ) 으로 균등하게 나뉩니다 . 그러나 이것이 사실이 아닌 경우 반올림 동작은 혼란을 초래할 수 있습니다. &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 을 가장 가까운 10 시간 으로 반올림 한 결과는 무엇입니까 ?</target>
        </trans-unit>
        <trans-unit id="619846970e9e167e4db1b981435711d687bd4ed9" translate="yes" xml:space="preserve">
          <source>In many languages with optional type declarations, adding declarations is the principal way to make code run faster. This is &lt;em&gt;not&lt;/em&gt; the case in Julia. In Julia, the compiler generally knows the types of all function arguments, local variables, and expressions. However, there are a few specific instances where declarations are helpful.</source>
          <target state="translated">선택적 유형 선언이있는 많은 언어에서 선언을 추가하면 코드를 더 빠르게 실행할 수 있습니다. 입니다 &lt;em&gt;하지&lt;/em&gt; 줄리아의 경우. Julia에서 컴파일러는 일반적으로 모든 함수 인수, 로컬 변수 및 표현식의 유형을 알고 있습니다. 그러나 선언이 도움이되는 몇 가지 특정 인스턴스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9450b748dbcdb8ba9fd42add95485312cab4012f" translate="yes" xml:space="preserve">
          <source>In mathematics, &lt;code&gt;+&lt;/code&gt; usually denotes a &lt;em&gt;commutative&lt;/em&gt; operation, where the order of the operands does not matter. An example of this is matrix addition, where &lt;code&gt;A + B == B + A&lt;/code&gt; for any matrices &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; that have the same shape. In contrast, &lt;code&gt;*&lt;/code&gt; typically denotes a &lt;em&gt;noncommutative&lt;/em&gt; operation, where the order of the operands &lt;em&gt;does&lt;/em&gt; matter. An example of this is matrix multiplication, where in general &lt;code&gt;A * B != B * A&lt;/code&gt;. As with matrix multiplication, string concatenation is noncommutative: &lt;code&gt;greet * whom != whom * greet&lt;/code&gt;. As such, &lt;code&gt;*&lt;/code&gt; is a more natural choice for an infix string concatenation operator, consistent with common mathematical use.</source>
          <target state="translated">수학에서, &lt;code&gt;+&lt;/code&gt; 보통이다 &lt;em&gt;가환&lt;/em&gt; 피연산자의 순서는 중요하지 않는 동작. 이것의 예는 행렬 덧셈입니다. 여기서 모양이 같은 행렬 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 의 경우 &lt;code&gt;A + B == B + A&lt;/code&gt; 입니다 . 반대로 &lt;code&gt;*&lt;/code&gt; 는 일반적으로 피연산자의 순서 &lt;em&gt;가&lt;/em&gt; 중요한 &lt;em&gt;비계산&lt;/em&gt; 연산을 나타냅니다 . 이것의 예는 일반적으로 &lt;code&gt;A * B != B * A&lt;/code&gt; 행렬 곱셈 입니다. 행렬 곱셈에서와 같이 문자열 연결은 비순환 적입니다. &lt;code&gt;greet * whom != whom * greet&lt;/code&gt; . 따라서 &lt;code&gt;*&lt;/code&gt; &lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt; 일반적인 수학적 사용과 일치하는 접두사 문자열 연결 연산자에 대한보다 자연스러운 선택입니다.</target>
        </trans-unit>
        <trans-unit id="ab8bd1f7589c990d976c1051b69449b020a43727" translate="yes" xml:space="preserve">
          <source>In more complex cases, resolving method ambiguities involves a certain element of design; this topic is explored further &lt;a href=&quot;#man-method-design-ambiguities-1&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">더 복잡한 경우, 방법 모호성을 해결하기 위해서는 특정 디자인 요소가 필요합니다. 이 주제는 &lt;a href=&quot;#man-method-design-ambiguities-1&quot;&gt;아래에서&lt;/a&gt; 더 자세히 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="be4d8bd032078d1d618f689c7b9a8339132970a1" translate="yes" xml:space="preserve">
          <source>In most cases, if &lt;code&gt;A&lt;/code&gt; is a subtype &lt;code&gt;S&lt;/code&gt; of &lt;code&gt;AbstractMatrix{T}&lt;/code&gt; with an element type &lt;code&gt;T&lt;/code&gt; supporting &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;, the return type is &lt;code&gt;LU{T,S{T}}&lt;/code&gt;. If pivoting is chosen (default) the element type should also support &lt;code&gt;abs&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">대부분의 경우 &lt;code&gt;A&lt;/code&gt; 가 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;/&lt;/code&gt; 를 지원 하는 요소 유형 &lt;code&gt;T&lt;/code&gt; 를 가진 &lt;code&gt;AbstractMatrix{T}&lt;/code&gt; 의 하위 유형 &lt;code&gt;S&lt;/code&gt; 인 경우 리턴 유형은 &lt;code&gt;LU{T,S{T}}&lt;/code&gt; 입니다. 피벗을 선택하면 (기본값) 요소 유형도 &lt;code&gt;abs&lt;/code&gt; 및 &lt;code&gt;&amp;lt;&lt;/code&gt; 을 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c01897c1c5dfe56ff403bf92da50402dc901b089" translate="yes" xml:space="preserve">
          <source>In order to access the data of x, we can use &lt;code&gt;jl_array_data&lt;/code&gt;:</source>
          <target state="translated">x의 데이터에 접근하기 위해 &lt;code&gt;jl_array_data&lt;/code&gt; 를 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="1c8c964572487783a93c9f805bd24c6191a24c97" translate="yes" xml:space="preserve">
          <source>In order to build this program you have to put the path to the Julia header into the include path and link against &lt;code&gt;libjulia&lt;/code&gt;. For instance, when Julia is installed to &lt;code&gt;$JULIA_DIR&lt;/code&gt;, one can compile the above test program &lt;code&gt;test.c&lt;/code&gt; with &lt;code&gt;gcc&lt;/code&gt; using:</source>
          <target state="translated">이 프로그램을 빌드하려면 Julia 헤더의 경로를 포함 경로에 &lt;code&gt;libjulia&lt;/code&gt; 에 대한 링크를 넣어야 합니다. 예를 들어 Julia가 &lt;code&gt;$JULIA_DIR&lt;/code&gt; 설치되면 다음 을 사용하여 위의 테스트 프로그램 &lt;code&gt;test.c&lt;/code&gt; 를 &lt;code&gt;gcc&lt;/code&gt; 로 컴파일 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f634f39fd97c0fd5eaef9dfae9571e089a9c4f67" translate="yes" xml:space="preserve">
          <source>In order to check whether &lt;code&gt;ret&lt;/code&gt; is of a specific Julia type, we can use the &lt;code&gt;jl_isa&lt;/code&gt;, &lt;code&gt;jl_typeis&lt;/code&gt;, or &lt;code&gt;jl_is_...&lt;/code&gt; functions. By typing &lt;code&gt;typeof(sqrt(2.0))&lt;/code&gt; into the Julia shell we can see that the return type is &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;double&lt;/code&gt; in C). To convert the boxed Julia value into a C double the &lt;code&gt;jl_unbox_float64&lt;/code&gt; function is used in the above code snippet.</source>
          <target state="translated">&lt;code&gt;ret&lt;/code&gt; 이 특정 Julia 유형 인지 확인하기 위해 &lt;code&gt;jl_isa&lt;/code&gt; , &lt;code&gt;jl_typeis&lt;/code&gt; 또는 &lt;code&gt;jl_is_...&lt;/code&gt; 함수를 사용할 수 있습니다 . 타이핑에 의해 &lt;code&gt;typeof(sqrt(2.0))&lt;/code&gt; 줄리아에 우리는 반환 형식이 있음을 알 수 쉘 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;double&lt;/code&gt; C에서). 박스형 Julia 값을 C 배로 변환하기 위해 &lt;code&gt;jl_unbox_float64&lt;/code&gt; 함수가 위의 코드 스 니펫에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c26dfd25e758364e0dcd1c617a188ec51d32baad" translate="yes" xml:space="preserve">
          <source>In order to compute trigonometric functions with degrees instead of radians, suffix the function with &lt;code&gt;d&lt;/code&gt;. For example, &lt;a href=&quot;../../base/math/index#Base.Math.sind&quot;&gt;&lt;code&gt;sind(x)&lt;/code&gt;&lt;/a&gt; computes the sine of &lt;code&gt;x&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; is specified in degrees. The complete list of trigonometric functions with degree variants is:</source>
          <target state="translated">라디안 대신 각도를 사용하여 삼각 함수를 계산하려면 &lt;code&gt;d&lt;/code&gt; 로 함수를 접미사로 사용하십시오 . 예를 들어, &lt;a href=&quot;../../base/math/index#Base.Math.sind&quot;&gt; &lt;code&gt;sind(x)&lt;/code&gt; &lt;/a&gt; 의 사인 계산 &lt;code&gt;x&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; 각도로 지정된다. 학위 변형이 포함 된 삼각 함수의 전체 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f65b6a7038eae90009481c5aaae33e0c39a02ac4" translate="yes" xml:space="preserve">
          <source>In order to define a new display backend, one should first create a subtype &lt;code&gt;D&lt;/code&gt; of the abstract class &lt;a href=&quot;#Base.Multimedia.AbstractDisplay&quot;&gt;&lt;code&gt;AbstractDisplay&lt;/code&gt;&lt;/a&gt;. Then, for each MIME type (&lt;code&gt;mime&lt;/code&gt; string) that can be displayed on &lt;code&gt;D&lt;/code&gt;, one should define a function &lt;code&gt;display(d::D, ::MIME&quot;mime&quot;, x) = ...&lt;/code&gt; that displays &lt;code&gt;x&lt;/code&gt; as that MIME type, usually by calling &lt;a href=&quot;#Base.show-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;show(io, mime, x)&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;repr(io, mime, x)&lt;/code&gt;. A &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; should be thrown if &lt;code&gt;x&lt;/code&gt; cannot be displayed as that MIME type; this is automatic if one calls &lt;code&gt;show&lt;/code&gt; or &lt;code&gt;repr&lt;/code&gt;. Finally, one should define a function &lt;code&gt;display(d::D, x)&lt;/code&gt; that queries &lt;a href=&quot;#Base.Multimedia.showable&quot;&gt;&lt;code&gt;showable(mime, x)&lt;/code&gt;&lt;/a&gt; for the &lt;code&gt;mime&lt;/code&gt; types supported by &lt;code&gt;D&lt;/code&gt; and displays the &quot;best&quot; one; a &lt;code&gt;MethodError&lt;/code&gt; should be thrown if no supported MIME types are found for &lt;code&gt;x&lt;/code&gt;. Similarly, some subtypes may wish to override &lt;a href=&quot;#Base.Multimedia.redisplay&quot;&gt;&lt;code&gt;redisplay(d::D, ...)&lt;/code&gt;&lt;/a&gt;. (Again, one should &lt;code&gt;import Base.display&lt;/code&gt; to add new methods to &lt;code&gt;display&lt;/code&gt;.) The return values of these functions are up to the implementation (since in some cases it may be useful to return a display &quot;handle&quot; of some type). The display functions for &lt;code&gt;D&lt;/code&gt; can then be called directly, but they can also be invoked automatically from &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display(x)&lt;/code&gt;&lt;/a&gt; simply by pushing a new display onto the display-backend stack with:</source>
          <target state="translated">새로운 디스플레이 백엔드를 정의하려면 먼저 추상 클래스 &lt;a href=&quot;#Base.Multimedia.AbstractDisplay&quot;&gt; &lt;code&gt;AbstractDisplay&lt;/code&gt; &lt;/a&gt; 의 하위 유형 &lt;code&gt;D&lt;/code&gt; 를 작성해야합니다 . 그런 다음 &lt;code&gt;D&lt;/code&gt; 에 표시 할 수있는 각 MIME 유형 ( &lt;code&gt;mime&lt;/code&gt; 문자열)에 대해 &lt;code&gt;x&lt;/code&gt; 를 해당 MIME 유형으로 표시 하는 함수 &lt;code&gt;display(d::D, ::MIME&quot;mime&quot;, x) = ...&lt;/code&gt; 해야합니다 . 일반적으로 호출하여 &lt;a href=&quot;#Base.show-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;show(io, mime, x)&lt;/code&gt; &lt;/a&gt; 나 &lt;code&gt;repr(io, mime, x)&lt;/code&gt; . &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; 는&lt;/a&gt; 경우에 발생한다 &lt;code&gt;x&lt;/code&gt; 는 그 MIME 타입으로 표시 할 수 없습니다; 하나의 호출이 &lt;code&gt;show&lt;/code&gt; 또는 &lt;code&gt;repr&lt;/code&gt; 인 경우 자동 입니다. 마지막으로 함수 &lt;code&gt;display(d::D, x)&lt;/code&gt; 정의해야합니다 (d :: D, x) 쿼리 를 합니다&lt;a href=&quot;#Base.Multimedia.showable&quot;&gt; &lt;code&gt;showable(mime, x)&lt;/code&gt; &lt;/a&gt; &lt;code&gt;D&lt;/code&gt; 가 지원하는 &lt;code&gt;mime&lt;/code&gt; 유형에대해 showable (mime, x) 이며&quot;최고의&quot;유형을표시합니다. &lt;code&gt;MethodError&lt;/code&gt; 는 지원되는 MIME 유형을 위해 찾을 수없는 경우 발생한다 &lt;code&gt;x&lt;/code&gt; . 마찬가지로 일부 하위 유형은&lt;a href=&quot;#Base.Multimedia.redisplay&quot;&gt; &lt;code&gt;redisplay(d::D, ...)&lt;/code&gt; &lt;/a&gt; 를 재정의하려고 할 수 있습니다. (다시 말해새로운 메소드를 추가하기 위해 &lt;code&gt;import Base.display&lt;/code&gt; 를 가져와야 &lt;code&gt;display&lt;/code&gt; .) 이러한 함수의 반환 값은 구현에 달려 있습니다 (일부 경우 일부 유형의 디스플레이 &quot;핸들&quot;을 반환하는 것이 유용 할 수 있기 때문에). 그런 다음 &lt;code&gt;D&lt;/code&gt; 에 대한 표시 기능을직접 호출 할 수 있지만 자동으로 호출 할 수도 있습니다.&lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display(x)&lt;/code&gt; &lt;/a&gt; 다음을 사용하여 새 디스플레이를 디스플레이 백엔드 스택에 푸시하면됩니다.</target>
        </trans-unit>
        <trans-unit id="e0fa42e97ec0c0f5639428f8bc25c0313c261f3b" translate="yes" xml:space="preserve">
          <source>In order to dispatch a multi-level parametric argument list, often it is best to separate each level of dispatch into distinct functions. This may sound similar in approach to single-dispatch, but as we shall see below, it is still more flexible.</source>
          <target state="translated">다단계 매개 변수 인수 목록을 발송하려면 각 발송 레벨을 개별 함수로 분리하는 것이 가장 좋습니다. 단일 디스패치와 비슷한 방식으로 들릴 수 있지만 아래에서 볼 수 있듯이 여전히 더 유연합니다.</target>
        </trans-unit>
        <trans-unit id="c64f4c986b251a9a23920c12ed0e829f663e97f9" translate="yes" xml:space="preserve">
          <source>In order to implement such a &lt;code&gt;copy&lt;/code&gt; or &lt;code&gt;copyto!&lt;/code&gt;, method, of course, you must work with the &lt;code&gt;Broadcasted&lt;/code&gt; wrapper to compute each element. There are two main ways of doing so:</source>
          <target state="translated">그러한 &lt;code&gt;copy&lt;/code&gt; 또는 &lt;code&gt;copyto!&lt;/code&gt; 를 구현하기 위해 ! 물론, 메소드, 각 요소를 계산 하려면 &lt;code&gt;Broadcasted&lt;/code&gt; 랩퍼로 작업해야합니다 . 그렇게하는 두 가지 주요 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c65ae2a5b36599056aee26d3163a0e9101f727b" translate="yes" xml:space="preserve">
          <source>In order to losslessly represent arbitrary byte streams stored in a &lt;code&gt;String&lt;/code&gt;, a &lt;code&gt;Char&lt;/code&gt; value may store information that cannot be converted to a Unicode codepoint &amp;mdash; converting such a &lt;code&gt;Char&lt;/code&gt; to &lt;code&gt;UInt32&lt;/code&gt; will throw an error. The &lt;a href=&quot;#Base.isvalid-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;isvalid(c::Char)&lt;/code&gt;&lt;/a&gt; function can be used to query whether &lt;code&gt;c&lt;/code&gt; represents a valid Unicode character.</source>
          <target state="translated">무손실 임의의 바이트를 표현하기 위해 저장된 스트림 &lt;code&gt;String&lt;/code&gt; 하는 &lt;code&gt;Char&lt;/code&gt; 이러한 변환 - 값은 유니 코드 코드 포인트로 변환 할 수없는 정보를 저장할 수있다 &lt;code&gt;Char&lt;/code&gt; 에 &lt;code&gt;UInt32&lt;/code&gt; 오류가 발생 것이다. &lt;a href=&quot;#Base.isvalid-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;isvalid(c::Char)&lt;/code&gt; &lt;/a&gt; 인지 기능은 쿼리에 사용할 수 있습니다 &lt;code&gt;c&lt;/code&gt; 유효한 유니 코드 문자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fab91460cbe612949b4b9d95753296ca7abe3d3b" translate="yes" xml:space="preserve">
          <source>In order to pass this function to C, we obtain its address using the macro &lt;code&gt;@cfunction&lt;/code&gt;:</source>
          <target state="translated">이 함수를 C로 전달하기 위해 매크로 &lt;code&gt;@cfunction&lt;/code&gt; 을 사용하여 주소를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="cd5618b4a563dff2d7a927d5353ef78a361df290" translate="yes" xml:space="preserve">
          <source>In order to refer to &lt;code&gt;MyType&lt;/code&gt; across all processes, &lt;code&gt;DummyModule.jl&lt;/code&gt; needs to be loaded on every process. Calling &lt;code&gt;include(&quot;DummyModule.jl&quot;)&lt;/code&gt; loads it only on a single process. To load it on every process, use the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@everywhere&quot;&gt;&lt;code&gt;@everywhere&lt;/code&gt;&lt;/a&gt; macro (starting Julia with &lt;code&gt;julia -p 2&lt;/code&gt;):</source>
          <target state="translated">모든 프로세스에서 &lt;code&gt;MyType&lt;/code&gt; 을 참조하려면 모든 프로세스에 &lt;code&gt;DummyModule.jl&lt;/code&gt; 을로드해야합니다. &lt;code&gt;include(&quot;DummyModule.jl&quot;)&lt;/code&gt; 를 호출 하면 단일 프로세스에서만로드됩니다. 모든 프로세스에로드하려면 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@everywhere&quot;&gt; &lt;code&gt;@everywhere&lt;/code&gt; &lt;/a&gt; 매크로를 사용하십시오 ( &lt;code&gt;julia -p 2&lt;/code&gt; Julia -p 2로 시작 ).</target>
        </trans-unit>
        <trans-unit id="47f30e462ec98fcc58c9494bb836f85ec8257aff" translate="yes" xml:space="preserve">
          <source>In order to support mutation, such objects are generally allocated on the heap, and have stable memory addresses. A mutable object is like a little container that might hold different values over time, and so can only be reliably identified with its address. In contrast, an instance of an immutable type is associated with specific field values &amp;ndash;- the field values alone tell you everything about the object. In deciding whether to make a type mutable, ask whether two instances with the same field values would be considered identical, or if they might need to change independently over time. If they would be considered identical, the type should probably be immutable.</source>
          <target state="translated">돌연변이를 지원하기 위해 이러한 객체는 일반적으로 힙에 할당되며 안정적인 메모리 주소를 갖습니다. 변경 가능한 개체는 시간이 지남에 따라 다른 값을 보유 할 수있는 작은 컨테이너와 같으므로 해당 주소로만 확실하게 식별 할 수 있습니다. 반대로, 불변 유형의 인스턴스는 특정 필드 값과 연관되어 있습니다.-필드 값만으로도 개체에 대한 모든 정보가 표시됩니다. 유형을 변경할 수 있는지 여부를 결정할 때 동일한 필드 값을 가진 두 인스턴스가 동일한 것으로 간주되는지 또는 시간이 지남에 따라 독립적으로 변경해야하는지 묻습니다. 그것들이 동일하다고 생각되면, 타입은 불변 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="2f2293a5b64eabd8ff88bd22ea606404b9b1e108" translate="yes" xml:space="preserve">
          <source>In other circumstances, it is handy to be able to stop an iteration and move on to the next one immediately. The &lt;code&gt;continue&lt;/code&gt; keyword accomplishes this:</source>
          <target state="translated">다른 상황에서는 반복을 중지하고 즉시 다음 반복으로 넘어가는 것이 편리합니다. 는 &lt;code&gt;continue&lt;/code&gt; 키워드 수행이 :</target>
        </trans-unit>
        <trans-unit id="c004c636d1b0703eca9cda2590edfd6579e7129c" translate="yes" xml:space="preserve">
          <source>In other words, &lt;a href=&quot;../../base/base/index#Core.isa&quot;&gt;&lt;code&gt;isa(A,Type{B})&lt;/code&gt;&lt;/a&gt; is true if and only if &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are the same object and that object is a type. Without the parameter, &lt;code&gt;Type&lt;/code&gt; is simply an abstract type which has all type objects as its instances, including, of course, singleton types:</source>
          <target state="translated">다시 말해, &lt;a href=&quot;../../base/base/index#Core.isa&quot;&gt; &lt;code&gt;isa(A,Type{B})&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 가 동일한 객체이고 해당 객체가 유형 인 경우에만 true 입니다. 매개 변수가 없으면 &lt;code&gt;Type&lt;/code&gt; 은 단순히 단일 유형을 포함하여 모든 유형 객체를 인스턴스로 갖는 추상 유형입니다.</target>
        </trans-unit>
        <trans-unit id="fb4e1a8fb772b24b6039451c201b81e5c718d91a" translate="yes" xml:space="preserve">
          <source>In other words, in the parlance of type theory, Julia's type parameters are &lt;em&gt;invariant&lt;/em&gt;, rather than being &lt;a href=&quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29&quot;&gt;covariant (or even contravariant)&lt;/a&gt;. This is for practical reasons: while any instance of &lt;code&gt;Point{Float64}&lt;/code&gt; may conceptually be like an instance of &lt;code&gt;Point{Real}&lt;/code&gt; as well, the two types have different representations in memory:</source>
          <target state="translated">다시 말해, 유형 이론의 용어에서 Julia의 유형 매개 변수는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29&quot;&gt;공변량 (또는 공변량)이&lt;/a&gt; 아니라 &lt;em&gt;변하지 않습니다&lt;/em&gt; . 이는 실용적인 이유입니다. &lt;code&gt;Point{Float64}&lt;/code&gt; 의 인스턴스는 개념적으로 &lt;code&gt;Point{Real}&lt;/code&gt; 의 인스턴스와 비슷할 수 있지만 두 유형은 메모리에서 서로 다른 표현을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="2489400c16a870eb77390027298b5bae2afac7fd" translate="yes" xml:space="preserve">
          <source>In particular this means that overlong and too-high code unit sequences and prefixes thereof are treated as a single invalid character rather than multiple invalid characters. This rule may be best explained with an example:</source>
          <target state="translated">특히 이것은 너무 길고 너무 높은 코드 단위 시퀀스와 그 접두어가 여러 개의 유효하지 않은 문자가 아닌 하나의 유효하지 않은 문자로 취급됨을 의미합니다. 이 규칙은 예제와 함께 가장 잘 설명 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86e6d7b557572810776afd763390d8c87a4b9b3f" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;repr(&quot;text/plain&quot;, x)&lt;/code&gt; is typically a &quot;pretty-printed&quot; version of &lt;code&gt;x&lt;/code&gt; designed for human consumption. See also &lt;code&gt;repr(x)&lt;/code&gt; to instead return a string corresponding to &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show(x)&lt;/code&gt;&lt;/a&gt; that may be closer to how the value of &lt;code&gt;x&lt;/code&gt; would be entered in Julia.</source>
          <target state="translated">특히, &lt;code&gt;repr(&quot;text/plain&quot;, x)&lt;/code&gt; 은 일반적으로 사람이 소비하도록 설계된 &lt;code&gt;x&lt;/code&gt; 의 &quot;꽤 인쇄 된&quot;버전입니다 . Julia에서 &lt;code&gt;x&lt;/code&gt; 값을 입력 하는 방법에 더 가까운 &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show(x)&lt;/code&gt; &lt;/a&gt; 해당하는 문자열을 대신 반환하려면 &lt;code&gt;repr(x)&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a352a9e712137ef0293428d01a95dc381f03f45f" translate="yes" xml:space="preserve">
          <source>In particular, if you define a &lt;code&gt;function __init__()&lt;/code&gt; in a module, then Julia will call &lt;code&gt;__init__()&lt;/code&gt; immediately &lt;em&gt;after&lt;/em&gt; the module is loaded (e.g., by &lt;code&gt;import&lt;/code&gt;, &lt;code&gt;using&lt;/code&gt;, or &lt;code&gt;require&lt;/code&gt;) at runtime for the &lt;em&gt;first&lt;/em&gt; time (i.e., &lt;code&gt;__init__&lt;/code&gt; is only called once, and only after all statements in the module have been executed). Because it is called after the module is fully imported, any submodules or other imported modules have their &lt;code&gt;__init__&lt;/code&gt; functions called &lt;em&gt;before&lt;/em&gt; the &lt;code&gt;__init__&lt;/code&gt; of the enclosing module.</source>
          <target state="translated">당신이 정의하는 경우 특히, &lt;code&gt;function __init__()&lt;/code&gt; 모듈에 다음 줄리아 호출 &lt;code&gt;__init__()&lt;/code&gt; 즉시 &lt;em&gt;후&lt;/em&gt; 모듈이 (예를 들어,에 의해로드 &lt;code&gt;import&lt;/code&gt; , &lt;code&gt;using&lt;/code&gt; , 또는 &lt;code&gt;require&lt;/code&gt; 에 대한 런타임에서) &lt;em&gt;첫째&lt;/em&gt; , 즉 시간 ( &lt;code&gt;__init__&lt;/code&gt; 이 있습니다 한 번만 호출되며 모듈의 모든 명령문이 실행 된 후에 만 ​​호출됩니다. 모듈이 완전히 가져온 후 호출되기 때문에, 어떤 서브 모듈 또는 기타 수입 모듈은 자신이 &lt;code&gt;__init__&lt;/code&gt; 함수가 호출 &lt;em&gt;되기 전에 &lt;/em&gt; &lt;code&gt;__init__&lt;/code&gt; 둘러싸는 모듈의.</target>
        </trans-unit>
        <trans-unit id="7f00fe64f586624c25d908def02434ca5a5747cc" translate="yes" xml:space="preserve">
          <source>In particular, note that &lt;code&gt;LibGit2.free&lt;/code&gt; should be called afterward on the &lt;code&gt;Ref&lt;/code&gt; object.</source>
          <target state="translated">특히 &lt;code&gt;LibGit2.free&lt;/code&gt; 는 &lt;code&gt;Ref&lt;/code&gt; 객체 에서 나중에 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="1b992ee319e3397f73ab42aa368ea422a279c258" translate="yes" xml:space="preserve">
          <source>In particular, note that &lt;code&gt;missing == missing&lt;/code&gt; returns &lt;code&gt;missing&lt;/code&gt;, so &lt;code&gt;==&lt;/code&gt; cannot be used to test whether a value is missing. To test whether &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;missing&lt;/code&gt;, use &lt;a href=&quot;../../base/base/index#Base.ismissing&quot;&gt;&lt;code&gt;ismissing(x)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">특히, 참고 &lt;code&gt;missing == missing&lt;/code&gt; 반환 &lt;code&gt;missing&lt;/code&gt; , 그래서 &lt;code&gt;==&lt;/code&gt; 값이 누락되어 있는지 여부를 테스트하는 데 사용할 수 없습니다. 여부를 테스트하려면 &lt;code&gt;x&lt;/code&gt; 가 되어 &lt;code&gt;missing&lt;/code&gt; , 사용 &lt;a href=&quot;../../base/base/index#Base.ismissing&quot;&gt; &lt;code&gt;ismissing(x)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="10aa2526d9c8eb28f8fc8b12b251cb66391f9afe" translate="yes" xml:space="preserve">
          <source>In particular, this means that small enough immutable values like integers and floats are typically passed to functions in registers (or stack allocated).</source>
          <target state="translated">특히, 이는 정수 및 부동 소수점과 같은 충분히 작은 불변 값이 일반적으로 레지스터의 함수 (또는 스택 할당)로 전달됨을 의미합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
