<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="3b2afa5595b029a3c3dc735df40952b6a6b196db" translate="yes" xml:space="preserve">
          <source>Core.UInt64</source>
          <target state="translated">Core.UInt64</target>
        </trans-unit>
        <trans-unit id="8c423ad2856bb21a956fcd2f4b4af48877d7fb9e" translate="yes" xml:space="preserve">
          <source>Core.UInt8</source>
          <target state="translated">Core.UInt8</target>
        </trans-unit>
        <trans-unit id="f94b6de69ba6173c6644374bcc0b67c77c478ae9" translate="yes" xml:space="preserve">
          <source>Core.UndefInitializer</source>
          <target state="translated">Core.UndefInitializer</target>
        </trans-unit>
        <trans-unit id="07b2f6fdbd7c59ad9163de0145ef16bf9bb28382" translate="yes" xml:space="preserve">
          <source>Core.UndefKeywordError</source>
          <target state="translated">Core.UndefKeywordError</target>
        </trans-unit>
        <trans-unit id="33d1c00d40609a506a1c35270754761d90c0643e" translate="yes" xml:space="preserve">
          <source>Core.UndefRefError</source>
          <target state="translated">Core.UndefRefError</target>
        </trans-unit>
        <trans-unit id="bdca7f953b36d0f03db4bc9fd8e6e861149fef33" translate="yes" xml:space="preserve">
          <source>Core.UndefVarError</source>
          <target state="translated">Core.UndefVarError</target>
        </trans-unit>
        <trans-unit id="be58e03a069d35a51db9fb4c724606c99abcd8b9" translate="yes" xml:space="preserve">
          <source>Core.Union</source>
          <target state="translated">Core.Union</target>
        </trans-unit>
        <trans-unit id="e8113afc597f4a15b3f06158979a5211244f841e" translate="yes" xml:space="preserve">
          <source>Core.UnionAll</source>
          <target state="translated">Core.UnionAll</target>
        </trans-unit>
        <trans-unit id="d886f4e20b6cb8b062e068aba58a5987a8c7d2da" translate="yes" xml:space="preserve">
          <source>Core.Unsigned</source>
          <target state="translated">Core.Unsigned</target>
        </trans-unit>
        <trans-unit id="33fe88c7ffcf0538e076168da43cd25b19b4de0a" translate="yes" xml:space="preserve">
          <source>Core.Vararg</source>
          <target state="translated">Core.Vararg</target>
        </trans-unit>
        <trans-unit id="4dcab8b27937c697ace2bf0c7ab731d9d437bdeb" translate="yes" xml:space="preserve">
          <source>Core.applicable()</source>
          <target state="translated">Core.applicable()</target>
        </trans-unit>
        <trans-unit id="643b383aa84c34ae8992b0cb054491c81b1dc047" translate="yes" xml:space="preserve">
          <source>Core.eval()</source>
          <target state="translated">Core.eval()</target>
        </trans-unit>
        <trans-unit id="8b059cdc2fd7f4f078d1167b0f81e44ea9df09d6" translate="yes" xml:space="preserve">
          <source>Core.fieldtype()</source>
          <target state="translated">Core.fieldtype()</target>
        </trans-unit>
        <trans-unit id="3ae90d79ffdde7d1fe93c0138223ea72cb2bc8cf" translate="yes" xml:space="preserve">
          <source>Core.getfield()</source>
          <target state="translated">Core.getfield()</target>
        </trans-unit>
        <trans-unit id="2cb5d2a4c6e112f5caca0b950aafc402728e9c5c" translate="yes" xml:space="preserve">
          <source>Core.ifelse()</source>
          <target state="translated">Core.ifelse()</target>
        </trans-unit>
        <trans-unit id="c29e94ae444083d76a880a241f6c75f3ddc68a35" translate="yes" xml:space="preserve">
          <source>Core.invoke()</source>
          <target state="translated">Core.invoke()</target>
        </trans-unit>
        <trans-unit id="76b4f8fbfbbabba6e83b3468fcf7b96015579ea3" translate="yes" xml:space="preserve">
          <source>Core.isa()</source>
          <target state="translated">Core.isa()</target>
        </trans-unit>
        <trans-unit id="36f7c8e658b3370440e7f26e5b0e4965b949fa9d" translate="yes" xml:space="preserve">
          <source>Core.isdefined()</source>
          <target state="translated">Core.isdefined()</target>
        </trans-unit>
        <trans-unit id="9b23ab990d5c62c2a078014be7c66a0c3e4e1394" translate="yes" xml:space="preserve">
          <source>Core.nfields()</source>
          <target state="translated">Core.nfields()</target>
        </trans-unit>
        <trans-unit id="4bfdc3e9e44bf9286116897901c1386226161cb5" translate="yes" xml:space="preserve">
          <source>Core.nothing</source>
          <target state="translated">Core.nothing</target>
        </trans-unit>
        <trans-unit id="6acb02115e779813d9385b137998287991df61da" translate="yes" xml:space="preserve">
          <source>Core.setfield!()</source>
          <target state="translated">Core.setfield!()</target>
        </trans-unit>
        <trans-unit id="bc2b402dd92c1cb92209691d06c9c374342c53a9" translate="yes" xml:space="preserve">
          <source>Core.throw()</source>
          <target state="translated">Core.throw()</target>
        </trans-unit>
        <trans-unit id="12b149e509e75748d21363920cd40e30cf380071" translate="yes" xml:space="preserve">
          <source>Core.tuple()</source>
          <target state="translated">Core.tuple()</target>
        </trans-unit>
        <trans-unit id="00cee46b6d3520d8c9c0c302e4b9730ef4385bad" translate="yes" xml:space="preserve">
          <source>Core.typeassert()</source>
          <target state="translated">Core.typeassert()</target>
        </trans-unit>
        <trans-unit id="7344a7481965a908a1f63b50bbb06366f78822b8" translate="yes" xml:space="preserve">
          <source>Core.typeof()</source>
          <target state="translated">Core.typeof()</target>
        </trans-unit>
        <trans-unit id="4cb44a3ac4df4587e83db94499b7bd7b15a3a955" translate="yes" xml:space="preserve">
          <source>Core.undef</source>
          <target state="translated">Core.undef</target>
        </trans-unit>
        <trans-unit id="2a3a3a3048165677aa2036a7e01c3f31a8bbfbb9" translate="yes" xml:space="preserve">
          <source>CoreLogging.@logmsg</source>
          <target state="translated">CoreLogging.@logmsg</target>
        </trans-unit>
        <trans-unit id="083ef9f048bb882c300a709aa3193ebca0066017" translate="yes" xml:space="preserve">
          <source>CoreLogging.AbstractLogger</source>
          <target state="translated">CoreLogging.AbstractLogger</target>
        </trans-unit>
        <trans-unit id="7c45671f3a729162c6b794ce5d37c65b5cbd80e7" translate="yes" xml:space="preserve">
          <source>CoreLogging.LogLevel</source>
          <target state="translated">CoreLogging.LogLevel</target>
        </trans-unit>
        <trans-unit id="3b0cd222c6d045285b8ee0e92684b83aa993eb4f" translate="yes" xml:space="preserve">
          <source>CoreLogging.NullLogger</source>
          <target state="translated">CoreLogging.NullLogger</target>
        </trans-unit>
        <trans-unit id="75c612241d78e232d7df16e944c5688b6ecbdfbf" translate="yes" xml:space="preserve">
          <source>CoreLogging.SimpleLogger</source>
          <target state="translated">CoreLogging.SimpleLogger</target>
        </trans-unit>
        <trans-unit id="2fdcbae49ec42113338fc354b312540a678eb99e" translate="yes" xml:space="preserve">
          <source>CoreLogging.catch_exceptions()</source>
          <target state="translated">CoreLogging.catch_exceptions()</target>
        </trans-unit>
        <trans-unit id="e26bf5e0d56d658332efbdc5621c8d5d99db9b89" translate="yes" xml:space="preserve">
          <source>CoreLogging.current_logger()</source>
          <target state="translated">CoreLogging.current_logger()</target>
        </trans-unit>
        <trans-unit id="32150b661acfb793c5deeae4288c6191c29a1026" translate="yes" xml:space="preserve">
          <source>CoreLogging.disable_logging()</source>
          <target state="translated">CoreLogging.disable_logging()</target>
        </trans-unit>
        <trans-unit id="1712227ca3e5fec340a2b54bce74f24c7c5894a1" translate="yes" xml:space="preserve">
          <source>CoreLogging.global_logger()</source>
          <target state="translated">CoreLogging.global_logger()</target>
        </trans-unit>
        <trans-unit id="fc77ba9c031aea4b788610634d6c81e058c01fc8" translate="yes" xml:space="preserve">
          <source>CoreLogging.handle_message()</source>
          <target state="translated">CoreLogging.handle_message()</target>
        </trans-unit>
        <trans-unit id="21ade7f50b5f2b77fdf90e85ff21a4ceaddd4938" translate="yes" xml:space="preserve">
          <source>CoreLogging.min_enabled_level()</source>
          <target state="translated">CoreLogging.min_enabled_level()</target>
        </trans-unit>
        <trans-unit id="30f3427e9053621f7d5d000fa501744a3a42e204" translate="yes" xml:space="preserve">
          <source>CoreLogging.shouldlog()</source>
          <target state="translated">CoreLogging.shouldlog()</target>
        </trans-unit>
        <trans-unit id="78d98592599bcbbc6ff9697d2764ea3f8b09a44d" translate="yes" xml:space="preserve">
          <source>CoreLogging.with_logger()</source>
          <target state="translated">CoreLogging.with_logger()</target>
        </trans-unit>
        <trans-unit id="038697113018f4400bc94f1be4aebad0829b635a" translate="yes" xml:space="preserve">
          <source>Coroutines</source>
          <target state="translated">Coroutines</target>
        </trans-unit>
        <trans-unit id="e604caf78b008bde3ccc386c0b84af93d1674441" translate="yes" xml:space="preserve">
          <source>Correspondence of dense and sparse methods</source>
          <target state="translated">밀도가 높고 드문 드문 한 방법의 대응</target>
        </trans-unit>
        <trans-unit id="2ec7eef5d591077c31b1059b29fd9a3796d5e738" translate="yes" xml:space="preserve">
          <source>Corresponding &lt;code&gt;jl_box_...&lt;/code&gt; functions are used to convert the other way:</source>
          <target state="translated">해당하는 &lt;code&gt;jl_box_...&lt;/code&gt; 함수는 다른 방법으로 변환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a8bdb62815e350c629536da5f5a35ffb4c857a8f" translate="yes" xml:space="preserve">
          <source>Corresponds To</source>
          <target state="translated">에 해당</target>
        </trans-unit>
        <trans-unit id="a5e3b3a59299174adc5ed55ffbac2813ee3c97b7" translate="yes" xml:space="preserve">
          <source>Count bytes allocated by each source line</source>
          <target state="translated">각 소스 라인에 의해 할당 된 바이트 수</target>
        </trans-unit>
        <trans-unit id="a935e1d9fca63f3ad42808a862be5e14dcaefbac" translate="yes" xml:space="preserve">
          <source>Count executions of source lines</source>
          <target state="translated">소스 라인의 실행 횟수</target>
        </trans-unit>
        <trans-unit id="864fe9b91cbdb4ea474b1e34b2b240291fdf1186" translate="yes" xml:space="preserve">
          <source>Count the number of elements in &lt;code&gt;itr&lt;/code&gt; for which predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;p&lt;/code&gt; is omitted, counts the number of &lt;code&gt;true&lt;/code&gt; elements in &lt;code&gt;itr&lt;/code&gt; (which should be a collection of boolean values).</source>
          <target state="translated">술어 &lt;code&gt;p&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하는 &lt;code&gt;itr&lt;/code&gt; 의 요소 수를 계산하십시오 . 경우 &lt;code&gt;p&lt;/code&gt; 생략되어, 수 계산 &lt;code&gt;true&lt;/code&gt; 요소 &lt;code&gt;itr&lt;/code&gt; (부울 값 모음이어야 함).</target>
        </trans-unit>
        <trans-unit id="5495a2d2b7b75f22e845e609a82f0800b95ac639" translate="yes" xml:space="preserve">
          <source>Couple With Heart</source>
          <target state="translated">마음으로 커플</target>
        </trans-unit>
        <trans-unit id="33935f03e2050408f5414a4ce0ae315ea392ec16" translate="yes" xml:space="preserve">
          <source>Cow</source>
          <target state="translated">Cow</target>
        </trans-unit>
        <trans-unit id="19ec818c8eeccac36c9d30bc148eee4f5bc6c6c2" translate="yes" xml:space="preserve">
          <source>Cow Face</source>
          <target state="translated">암소 얼굴</target>
        </trans-unit>
        <trans-unit id="f45bf4b76973272a188e74b1e822bd5271792064" translate="yes" xml:space="preserve">
          <source>Cptrdiff_t</source>
          <target state="translated">Cptrdiff_t</target>
        </trans-unit>
        <trans-unit id="2052ca757ec7aad7cca2aa68837fc9d25c6aad32" translate="yes" xml:space="preserve">
          <source>Create a &lt;a href=&quot;#Base.Vector&quot;&gt;&lt;code&gt;Vector&lt;/code&gt;&lt;/a&gt; with element type computed from the &lt;code&gt;promote_typeof&lt;/code&gt; of the argument, containing the argument list.</source>
          <target state="translated">인수 목록을 포함하여 인수 의 &lt;code&gt;promote_typeof&lt;/code&gt; 에서 계산 된 요소 유형 으로 &lt;a href=&quot;#Base.Vector&quot;&gt; &lt;code&gt;Vector&lt;/code&gt; &lt;/a&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="a1cfccbb74fce45e29fc62bfbbfd863c0eaf829c" translate="yes" xml:space="preserve">
          <source>Create a &lt;a href=&quot;#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt; by concatenating the string representations of the arguments together.</source>
          <target state="translated">인수의 문자열 표현을 함께 연결하여 &lt;a href=&quot;#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt; 를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="b997497f9c1617594d62b35a7977d7c080fb335c" translate="yes" xml:space="preserve">
          <source>Create a &lt;a href=&quot;#Dates.DateFormat&quot;&gt;&lt;code&gt;DateFormat&lt;/code&gt;&lt;/a&gt; object. Similar to &lt;code&gt;DateFormat(&quot;Y-m-d H:M:S&quot;)&lt;/code&gt; but creates the DateFormat object once during macro expansion.</source>
          <target state="translated">&lt;a href=&quot;#Dates.DateFormat&quot;&gt; &lt;code&gt;DateFormat&lt;/code&gt; &lt;/a&gt; 객체를 만듭니다 . &lt;code&gt;DateFormat(&quot;Y-m-d H:M:S&quot;)&lt;/code&gt; 와 유사 하지만 매크로 확장 중에 DateFormat 객체를 한 번 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7953a760e50891a5121aa77eb1103656235936e1" translate="yes" xml:space="preserve">
          <source>Create a &lt;a href=&quot;../../base/arrays/index#Base.BitArray&quot;&gt;&lt;code&gt;BitArray&lt;/code&gt;&lt;/a&gt; whose values are linked to a file, using memory-mapping; it has the same purpose, works in the same way, and has the same arguments, as &lt;a href=&quot;#Mmap.mmap&quot;&gt;&lt;code&gt;mmap&lt;/code&gt;&lt;/a&gt;, but the byte representation is different.</source>
          <target state="translated">메모리 매핑을 사용하여 값이 파일에 연결된 &lt;a href=&quot;../../base/arrays/index#Base.BitArray&quot;&gt; &lt;code&gt;BitArray&lt;/code&gt; &lt;/a&gt; 를 만듭니다 . &lt;a href=&quot;#Mmap.mmap&quot;&gt; &lt;code&gt;mmap&lt;/code&gt; &lt;/a&gt; 과 동일한 목적을 가지고 동일한 방식으로 작동하며 동일한 인수를 갖지만 바이트 표현은 다릅니다.</target>
        </trans-unit>
        <trans-unit id="dea696a46021d9a2728a369e17215130e20d146d" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;BitArray&lt;/code&gt; with all values set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">모든 값을 &lt;code&gt;false&lt;/code&gt; 로 설정하여 &lt;code&gt;BitArray&lt;/code&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="1d8ab7188df37f14f18fd7682b800d25bb1bf583" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;BitArray&lt;/code&gt; with all values set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">모든 값을 &lt;code&gt;true&lt;/code&gt; 로 설정하여 &lt;code&gt;BitArray&lt;/code&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="9a7ea5ce4e6122fb26aa843dbb31c11f3eca6ba2" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;Date&lt;/code&gt; through the adjuster API. The starting point will be constructed from the provided &lt;code&gt;y, m, d&lt;/code&gt; arguments, and will be adjusted until &lt;code&gt;f::Function&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. The step size in adjusting can be provided manually through the &lt;code&gt;step&lt;/code&gt; keyword. &lt;code&gt;limit&lt;/code&gt; provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (given that &lt;code&gt;f::Function&lt;/code&gt; is never satisfied).</source>
          <target state="translated">조정자 API를 통해 &lt;code&gt;Date&lt;/code&gt; 를 작성하십시오 . 시작점은 제공된 &lt;code&gt;y, m, d&lt;/code&gt; 인수로 구성되며 &lt;code&gt;f::Function&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 를 반환 할 때까지 조정됩니다 . 조정시 단계 크기는 &lt;code&gt;step&lt;/code&gt; 키워드를 통해 수동으로 제공 할 수 있습니다 . &lt;code&gt;limit&lt;/code&gt; 은 오류를 발생시키기 전에 조정 API가 추구하는 최대 반복 횟수에 대한 제한을 제공합니다 ( &lt;code&gt;f::Function&lt;/code&gt; 가 충족되지 않는 경우).</target>
        </trans-unit>
        <trans-unit id="f6735235a65d9c71ac1be9b11a48f9584b5d2fbf" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;DateTime&lt;/code&gt; through the adjuster API. The starting point will be constructed from the provided &lt;code&gt;y, m, d...&lt;/code&gt; arguments, and will be adjusted until &lt;code&gt;f::Function&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. The step size in adjusting can be provided manually through the &lt;code&gt;step&lt;/code&gt; keyword. &lt;code&gt;limit&lt;/code&gt; provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (in the case that &lt;code&gt;f::Function&lt;/code&gt; is never satisfied).</source>
          <target state="translated">조정자 API를 통해 &lt;code&gt;DateTime&lt;/code&gt; 을 작성하십시오 . 시작점은 제공된 &lt;code&gt;y, m, d...&lt;/code&gt; 인수로 구성되며 &lt;code&gt;f::Function&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 를 반환 할 때까지 조정됩니다 . 조정시 단계 크기는 &lt;code&gt;step&lt;/code&gt; 키워드를 통해 수동으로 제공 할 수 있습니다 . &lt;code&gt;limit&lt;/code&gt; 은 오류를 발생시키기 전에 조정 API가 추구하는 최대 반복 횟수에 대한 제한을 제공합니다 ( &lt;code&gt;f::Function&lt;/code&gt; 이 충족되지 않는 경우 ).</target>
        </trans-unit>
        <trans-unit id="8f4f3e071879154940403d1e8565c4123c50feeb" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;Float32&lt;/code&gt; from &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is not exactly representable then &lt;code&gt;mode&lt;/code&gt; determines how &lt;code&gt;x&lt;/code&gt; is rounded.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 에서 &lt;code&gt;Float32&lt;/code&gt; 를 만듭니다 . &lt;code&gt;x&lt;/code&gt; 를 정확하게 표현할 수없는 경우 &lt;code&gt;mode&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 의 반올림 방법을 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="cb6cec94ec1ca41eee89abd6d594b2b0d7efa1c2" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;Float64&lt;/code&gt; from &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is not exactly representable then &lt;code&gt;mode&lt;/code&gt; determines how &lt;code&gt;x&lt;/code&gt; is rounded.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 에서 &lt;code&gt;Float64&lt;/code&gt; 를 만듭니다 . &lt;code&gt;x&lt;/code&gt; 를 정확하게 표현할 수없는 경우 &lt;code&gt;mode&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 의 반올림 방법을 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="f0b2de9107e787e44816ea2763bde3a0b81e7b6a" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;Future&lt;/code&gt; on process &lt;code&gt;pid&lt;/code&gt;. The default &lt;code&gt;pid&lt;/code&gt; is the current process.</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; 프로세스 에서 &lt;code&gt;Future&lt;/code&gt; 를 만듭니다 . 기본 &lt;code&gt;pid&lt;/code&gt; 는 현재 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="93754c4cc4d2cf6371ad6458eaa46263dd773ceb" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;MersenneTwister&lt;/code&gt; RNG object. Different RNG objects can have their own seeds, which may be useful for generating different streams of random numbers. The &lt;code&gt;seed&lt;/code&gt; may be a non-negative integer or a vector of &lt;code&gt;UInt32&lt;/code&gt; integers. If no seed is provided, a randomly generated one is created (using entropy from the system). See the &lt;a href=&quot;#Random.seed!&quot;&gt;&lt;code&gt;seed!&lt;/code&gt;&lt;/a&gt; function for reseeding an already existing &lt;code&gt;MersenneTwister&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;MersenneTwister&lt;/code&gt; RNG 개체를 만듭니다 . 다른 RNG 객체는 자체 시드를 가질 수 있으며, 이는 다른 난수 스트림을 생성하는 데 유용 할 수 있습니다. &lt;code&gt;seed&lt;/code&gt; 음수가 아닌 정수 또는 벡터 수 있습니다 &lt;code&gt;UInt32&lt;/code&gt; 정수. 시드가 제공되지 않으면 임의로 생성 된 시드가 생성됩니다 (시스템의 엔트로피 사용). 참고 항목 &lt;a href=&quot;#Random.seed!&quot;&gt; &lt;code&gt;seed!&lt;/code&gt; &lt;/a&gt;이미 존재하는 &lt;code&gt;MersenneTwister&lt;/code&gt; 객체 를 다시 시드하는 기능 .</target>
        </trans-unit>
        <trans-unit id="a3e12d3c226dfe774941f86975e7c21147d9a449" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;RandomDevice&lt;/code&gt; RNG object. Two such objects will always generate different streams of random numbers. The entropy is obtained from the operating system.</source>
          <target state="translated">&lt;code&gt;RandomDevice&lt;/code&gt; RNG 객체를 만듭니다 . 이러한 두 객체는 ​​항상 다른 난수 스트림을 생성합니다. 엔트로피는 운영 체제에서 얻습니다.</target>
        </trans-unit>
        <trans-unit id="e8fd6ad24887f0f7617a75f378c73e4ba123e3c8" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;TCPServer&lt;/code&gt; on any port, using hint as a starting point. Returns a tuple of the actual port that the server was created on and the server itself.</source>
          <target state="translated">힌트를 시작점으로 사용하여 모든 포트에서 &lt;code&gt;TCPServer&lt;/code&gt; 를 작성하십시오 . 서버가 작성된 실제 포트와 서버 자체의 튜플을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9e6c48c71c33deba3dc37dfcd9d80b03a98023e0" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;Task&lt;/code&gt; (i.e. coroutine) to execute the given function &lt;code&gt;func&lt;/code&gt; (which must be callable with no arguments). The task exits when this function returns.</source>
          <target state="translated">주어진 함수 &lt;code&gt;func&lt;/code&gt; (인수없이 호출 할 수 있어야 함 )를 실행 하는 &lt;code&gt;Task&lt;/code&gt; (예 : 코 루틴)을 만듭니다 . 이 함수가 반환되면 작업이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="33aebc23f268facb98b68a3291c3e0f31f10f201" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;Text&lt;/code&gt; object from a literal string.</source>
          <target state="translated">리터럴 문자열에서 &lt;code&gt;Text&lt;/code&gt; 객체를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="9acff786cd532c004e7fc905975913a4901883b1" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;Time&lt;/code&gt; through the adjuster API. The starting point will be constructed from the provided &lt;code&gt;h, mi, s, ms, us&lt;/code&gt; arguments, and will be adjusted until &lt;code&gt;f::Function&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. The step size in adjusting can be provided manually through the &lt;code&gt;step&lt;/code&gt; keyword. &lt;code&gt;limit&lt;/code&gt; provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (in the case that &lt;code&gt;f::Function&lt;/code&gt; is never satisfied). Note that the default step will adjust to allow for greater precision for the given arguments; i.e. if hour, minute, and second arguments are provided, the default step will be &lt;code&gt;Millisecond(1)&lt;/code&gt; instead of &lt;code&gt;Second(1)&lt;/code&gt;.</source>
          <target state="translated">조정자 API를 통해 &lt;code&gt;Time&lt;/code&gt; 을 작성하십시오 . 시작점은 제공된 &lt;code&gt;h, mi, s, ms, us&lt;/code&gt; 인수로 구성되며 &lt;code&gt;f::Function&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 를 반환 할 때까지 조정됩니다 . 조정시 단계 크기는 &lt;code&gt;step&lt;/code&gt; 키워드를 통해 수동으로 제공 할 수 있습니다 . &lt;code&gt;limit&lt;/code&gt; 은 오류를 발생시키기 전에 조정 API가 추구하는 최대 반복 횟수에 대한 제한을 제공합니다 ( &lt;code&gt;f::Function&lt;/code&gt; 이 충족되지 않은 경우 ). 기본 단계는 주어진 인수에 대해 더 높은 정밀도를 허용하도록 조정됩니다. 즉,시, 분 및 초 인수가 제공되는 경우 기본 단계는 &lt;code&gt;Millisecond(1)&lt;/code&gt; 대신 &lt;code&gt;Second(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c627f9ad41e59c07607d6bd4b21b09b55e3881e7" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;WorkerPool&lt;/code&gt; from a vector of worker ids.</source>
          <target state="translated">작업자 ID로 구성된 벡터에서 &lt;code&gt;WorkerPool&lt;/code&gt; 을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="f12caa09152736ae8bfc5bb08f6c10223240aec7" translate="yes" xml:space="preserve">
          <source>Create a async condition that calls the given &lt;code&gt;callback&lt;/code&gt; function. The &lt;code&gt;callback&lt;/code&gt; is passed one argument, the async condition object itself.</source>
          <target state="translated">주어진 &lt;code&gt;callback&lt;/code&gt; 함수 를 호출하는 비동기 조건을 만듭니다 . &lt;code&gt;callback&lt;/code&gt; 하나 개의 인수, 비동기 상태 객체 자체를 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="e5a7b2716d759210ecda9bce2dfa1f57b9170956" translate="yes" xml:space="preserve">
          <source>Create a async condition that wakes up tasks waiting for it (by calling &lt;a href=&quot;../parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on the object) when notified from C by a call to &lt;code&gt;uv_async_send&lt;/code&gt;. Waiting tasks are woken with an error when the object is closed (by &lt;a href=&quot;../io-network/index#Base.close&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt;. Use &lt;a href=&quot;../io-network/index#Base.isopen&quot;&gt;&lt;code&gt;isopen&lt;/code&gt;&lt;/a&gt; to check whether it is still active.</source>
          <target state="translated">C에서 &lt;code&gt;uv_async_send&lt;/code&gt; 에 대한 호출로 알림을받을 때 오브젝트에서 &lt;a href=&quot;../parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 를 호출하여 대기중인 태스크를 깨우는 비동기 조건을 작성하십시오 . 대기중인 작업은 개체가 닫힐 때 오류와 함께 깨어납니다 ( &lt;a href=&quot;../io-network/index#Base.close&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;../io-network/index#Base.isopen&quot;&gt; &lt;code&gt;isopen&lt;/code&gt; &lt;/a&gt; 을 사용 하여 여전히 활성 상태인지 확인하십시오).</target>
        </trans-unit>
        <trans-unit id="090a3944a91674778ee0a002d6a90d0bc41ff5ca" translate="yes" xml:space="preserve">
          <source>Create a closure around an expression and run it on an automatically-chosen process, returning a &lt;a href=&quot;#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; to the result.</source>
          <target state="translated">표현식 주위에 클로저를 만들고 자동으로 선택된 프로세스에서 실행하여 &lt;a href=&quot;#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 를 결과 로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="893f51793311a49b3b24a2293576ed62237ed0ec" translate="yes" xml:space="preserve">
          <source>Create a closure around an expression and run the closure asynchronously on process &lt;code&gt;p&lt;/code&gt;. Return a &lt;a href=&quot;#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; to the result. Accepts two arguments, &lt;code&gt;p&lt;/code&gt; and an expression.</source>
          <target state="translated">표현식 주위에 클로저를 작성하고 프로세스 &lt;code&gt;p&lt;/code&gt; 에서 비동기 적으로 클로저를 실행하십시오 . 결과에 &lt;a href=&quot;#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 를 돌려 줍니다. 두 개의 인수 인 &lt;code&gt;p&lt;/code&gt; 와 표현식을 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="c74b846dbbbc1ae3b521fb938c06a70c93c0aa1c" translate="yes" xml:space="preserve">
          <source>Create a counting semaphore that allows at most &lt;code&gt;sem_size&lt;/code&gt; acquires to be in use at any time. Each acquire must be matched with a release.</source>
          <target state="translated">최대 &lt;code&gt;sem_size&lt;/code&gt; 획득을 언제든지 사용할 수있는 카운팅 세마포어를 만듭니다 . 각 획득은 릴리스와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="3c2f227958f5b5ddf7f1444e043ef8a63ac36641" translate="yes" xml:space="preserve">
          <source>Create a deep copy of &lt;code&gt;x&lt;/code&gt;: everything is copied recursively, resulting in a fully independent object. For example, deep-copying an array produces a new array whose elements are deep copies of the original elements. Calling &lt;code&gt;deepcopy&lt;/code&gt; on an object should generally have the same effect as serializing and then deserializing it.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 깊은 사본을 만듭니다 . 모든 것이 재귀 적으로 복사되어 완전히 독립적 인 객체가됩니다. 예를 들어, 배열을 딥 카피하면 요소가 원래 요소의 딥 카피 인 새 배열이 생성됩니다. 개체에 대해 &lt;code&gt;deepcopy&lt;/code&gt; 를 호출 하면 일반적으로 개체를 serialize 한 다음 deserialize하는 것과 동일한 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa9e6555c025221820dc540d8f7a0e05f0b656fe" translate="yes" xml:space="preserve">
          <source>Create a function that compares its argument to &lt;code&gt;x&lt;/code&gt; using &lt;a href=&quot;#Base.:!=&quot;&gt;&lt;code&gt;!=&lt;/code&gt;&lt;/a&gt;, i.e. a function equivalent to &lt;code&gt;y -&amp;gt; y != x&lt;/code&gt;. The returned function is of type &lt;code&gt;Base.Fix2{typeof(!=)}&lt;/code&gt;, which can be used to implement specialized methods.</source>
          <target state="translated">&lt;a href=&quot;#Base.:!=&quot;&gt; &lt;code&gt;!=&lt;/code&gt; &lt;/a&gt; 사용하여 인수와 &lt;code&gt;x&lt;/code&gt; 를 비교하는 함수 , 즉 &lt;code&gt;y -&amp;gt; y != x&lt;/code&gt; 와 동일한 함수를 작성하십시오 . 리턴 된 함수는 &lt;code&gt;Base.Fix2{typeof(!=)}&lt;/code&gt; 유형 이며 특수 메소드를 구현하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af72c3093498da482669882ee76ee4892ac8f823" translate="yes" xml:space="preserve">
          <source>Create a function that compares its argument to &lt;code&gt;x&lt;/code&gt; using &lt;a href=&quot;#Base.:&amp;gt;&quot;&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/a&gt;, i.e. a function equivalent to &lt;code&gt;y -&amp;gt; y &amp;gt; x&lt;/code&gt;. The returned function is of type &lt;code&gt;Base.Fix2{typeof(&amp;gt;)}&lt;/code&gt;, which can be used to implement specialized methods.</source>
          <target state="translated">&lt;a href=&quot;#Base.:&amp;gt;&quot;&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 를&lt;/a&gt; 사용하여 인수를 &lt;code&gt;x&lt;/code&gt; 와 비교하는 함수 , 즉 &lt;code&gt;y -&amp;gt; y &amp;gt; x&lt;/code&gt; 해당하는 함수를 작성하십시오 . 리턴 된 함수는 &lt;code&gt;Base.Fix2{typeof(&amp;gt;)}&lt;/code&gt; 유형 이며 특수 메소드를 구현하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99645591e772ccfbb35aa20a63f502286477bdca" translate="yes" xml:space="preserve">
          <source>Create a function that compares its argument to &lt;code&gt;x&lt;/code&gt; using &lt;a href=&quot;#Base.:&amp;gt;=&quot;&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;/a&gt;, i.e. a function equivalent to &lt;code&gt;y -&amp;gt; y &amp;gt;= x&lt;/code&gt;. The returned function is of type &lt;code&gt;Base.Fix2{typeof(&amp;gt;=)}&lt;/code&gt;, which can be used to implement specialized methods.</source>
          <target state="translated">&lt;a href=&quot;#Base.:&amp;gt;=&quot;&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt; 를&lt;/a&gt; 사용하여 인수와 &lt;code&gt;x&lt;/code&gt; 를 비교하는 함수 , 즉 &lt;code&gt;y -&amp;gt; y &amp;gt;= x&lt;/code&gt; 와 동일한 함수를 작성하십시오 . 리턴 된 함수는 &lt;code&gt;Base.Fix2{typeof(&amp;gt;=)}&lt;/code&gt; 유형 이며 특수 메소드를 구현하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b397904853b03daedf092cc5a494f6b012bca332" translate="yes" xml:space="preserve">
          <source>Create a function that compares its argument to &lt;code&gt;x&lt;/code&gt; using &lt;a href=&quot;#Base.:&amp;lt;&quot;&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/a&gt;, i.e. a function equivalent to &lt;code&gt;y -&amp;gt; y &amp;lt; x&lt;/code&gt;. The returned function is of type &lt;code&gt;Base.Fix2{typeof(&amp;lt;)}&lt;/code&gt;, which can be used to implement specialized methods.</source>
          <target state="translated">&lt;a href=&quot;#Base.:&amp;lt;&quot;&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; 를&lt;/a&gt; 사용하여 인수와 &lt;code&gt;x&lt;/code&gt; 를 비교하는 함수 , 즉 &lt;code&gt;y -&amp;gt; y &amp;lt; x&lt;/code&gt; 와 동등한 함수를 작성하십시오 . 리턴 된 함수는 &lt;code&gt;Base.Fix2{typeof(&amp;lt;)}&lt;/code&gt; 유형 이며 특수 메소드를 구현하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d48667c6a66ce4f649d12d09795f7243f057de17" translate="yes" xml:space="preserve">
          <source>Create a function that compares its argument to &lt;code&gt;x&lt;/code&gt; using &lt;a href=&quot;#Base.:&amp;lt;=&quot;&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/a&gt;, i.e. a function equivalent to &lt;code&gt;y -&amp;gt; y &amp;lt;= x&lt;/code&gt;. The returned function is of type &lt;code&gt;Base.Fix2{typeof(&amp;lt;=)}&lt;/code&gt;, which can be used to implement specialized methods.</source>
          <target state="translated">&lt;a href=&quot;#Base.:&amp;lt;=&quot;&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt; 를&lt;/a&gt; 사용하여 인수와 &lt;code&gt;x&lt;/code&gt; 를 비교하는 함수 , 즉 &lt;code&gt;y -&amp;gt; y &amp;lt;= x&lt;/code&gt; 와 동일한 함수를 작성하십시오 . 리턴 된 함수는 &lt;code&gt;Base.Fix2{typeof(&amp;lt;=)}&lt;/code&gt; 유형 이며 특수 메소드를 구현하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cc3766565df9d8df73c197f4db993c361226594" translate="yes" xml:space="preserve">
          <source>Create a function that compares its argument to &lt;code&gt;x&lt;/code&gt; using &lt;a href=&quot;#Base.:==&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt;, i.e. a function equivalent to &lt;code&gt;y -&amp;gt; y == x&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Base.:==&quot;&gt; &lt;code&gt;==&lt;/code&gt; 를&lt;/a&gt; 사용하여 인수와 &lt;code&gt;x&lt;/code&gt; 를 비교하는 함수 , 즉 &lt;code&gt;y -&amp;gt; y == x&lt;/code&gt; 와 동일한 함수를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="39a67963f2c04e3b7585aacebf07d65a32e22eec" translate="yes" xml:space="preserve">
          <source>Create a function that compares its argument to &lt;code&gt;x&lt;/code&gt; using &lt;a href=&quot;#Base.isequal&quot;&gt;&lt;code&gt;isequal&lt;/code&gt;&lt;/a&gt;, i.e. a function equivalent to &lt;code&gt;y -&amp;gt; isequal(y, x)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Base.isequal&quot;&gt; &lt;code&gt;isequal&lt;/code&gt; 을&lt;/a&gt; 사용하여 인수와 &lt;code&gt;x&lt;/code&gt; 를 비교하는 함수 , 즉 &lt;code&gt;y -&amp;gt; isequal(y, x)&lt;/code&gt; 와 동일한 함수를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="c4897ffc204435872d3aa27261454e300b1e8498" translate="yes" xml:space="preserve">
          <source>Create a level-triggered event source. Tasks that call &lt;a href=&quot;#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on an &lt;code&gt;Event&lt;/code&gt; are suspended and queued until &lt;code&gt;notify&lt;/code&gt; is called on the &lt;code&gt;Event&lt;/code&gt;. After &lt;code&gt;notify&lt;/code&gt; is called, the &lt;code&gt;Event&lt;/code&gt; remains in a signaled state and tasks will no longer block when waiting for it.</source>
          <target state="translated">레벨 트리거 이벤트 소스를 작성하십시오. 콜 것을 작업 &lt;a href=&quot;#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 온 &lt;code&gt;Event&lt;/code&gt; 중단 때까지 대기열에 &lt;code&gt;notify&lt;/code&gt; 온라고 &lt;code&gt;Event&lt;/code&gt; . &lt;code&gt;notify&lt;/code&gt; 이 호출 된 후에도 &lt;code&gt;Event&lt;/code&gt; 는 신호 상태로 유지되며 작업을 기다릴 때 더 이상 차단되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b28ca2340f5d2245f4bb80af46a6a182e72737e" translate="yes" xml:space="preserve">
          <source>Create a log record with an informational &lt;code&gt;message&lt;/code&gt;. For convenience, four logging macros &lt;code&gt;@debug&lt;/code&gt;, &lt;code&gt;@info&lt;/code&gt;, &lt;code&gt;@warn&lt;/code&gt; and &lt;code&gt;@error&lt;/code&gt; are defined which log at the standard severity levels &lt;code&gt;Debug&lt;/code&gt;, &lt;code&gt;Info&lt;/code&gt;, &lt;code&gt;Warn&lt;/code&gt; and &lt;code&gt;Error&lt;/code&gt;. &lt;code&gt;@logmsg&lt;/code&gt; allows &lt;code&gt;level&lt;/code&gt; to be set programmatically to any &lt;code&gt;LogLevel&lt;/code&gt; or custom log level types.</source>
          <target state="translated">정보 &lt;code&gt;message&lt;/code&gt; 와 함께 로그 레코드를 작성하십시오 . 편의상 표준 심각도 수준 &lt;code&gt;Debug&lt;/code&gt; , &lt;code&gt;Info&lt;/code&gt; , &lt;code&gt;Warn&lt;/code&gt; 및 &lt;code&gt;Error&lt;/code&gt; 로 기록하는 네 개의 로깅 매크로 &lt;code&gt;@debug&lt;/code&gt; , &lt;code&gt;@info&lt;/code&gt; , &lt;code&gt;@warn&lt;/code&gt; 및 &lt;code&gt;@error&lt;/code&gt; 가 정의됩니다 . &lt;code&gt;@logmsg&lt;/code&gt; 를 사용하면 &lt;code&gt;level&lt;/code&gt; 을 프로그래밍 방식으로 모든 &lt;code&gt;LogLevel&lt;/code&gt; 또는 사용자 지정 로그 수준 유형 으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17ffd2c5ff267c519e387826ecf2e1a0e8741d44" translate="yes" xml:space="preserve">
          <source>Create a multidimensional index &lt;code&gt;I&lt;/code&gt;, which can be used for indexing a multidimensional array &lt;code&gt;A&lt;/code&gt;. In particular, &lt;code&gt;A[I]&lt;/code&gt; is equivalent to &lt;code&gt;A[i,j,k...]&lt;/code&gt;. One can freely mix integer and &lt;code&gt;CartesianIndex&lt;/code&gt; indices; for example, &lt;code&gt;A[Ipre, i, Ipost]&lt;/code&gt; (where &lt;code&gt;Ipre&lt;/code&gt; and &lt;code&gt;Ipost&lt;/code&gt; are &lt;code&gt;CartesianIndex&lt;/code&gt; indices and &lt;code&gt;i&lt;/code&gt; is an &lt;code&gt;Int&lt;/code&gt;) can be a useful expression when writing algorithms that work along a single dimension of an array of arbitrary dimensionality.</source>
          <target state="translated">다차원 배열 &lt;code&gt;A&lt;/code&gt; 를 인덱싱하는 데 사용할 수 있는 다차원 인덱스 &lt;code&gt;I&lt;/code&gt; 을 만듭니다 . 특히, &lt;code&gt;A[I]&lt;/code&gt; 는 &lt;code&gt;A[i,j,k...]&lt;/code&gt; . 정수와 &lt;code&gt;CartesianIndex&lt;/code&gt; 인덱스를 자유롭게 혼합 할 수 있습니다 . 예를 들어, &lt;code&gt;A[Ipre, i, Ipost]&lt;/code&gt; (단 &lt;code&gt;Ipre&lt;/code&gt; 및 &lt;code&gt;Ipost&lt;/code&gt; 가 있다 &lt;code&gt;CartesianIndex&lt;/code&gt; 의 인덱스와 &lt;code&gt;i&lt;/code&gt; 인 &lt;code&gt;Int&lt;/code&gt; 알고리즘을 작성할 때) 유용한 발현 될 수있는 임의의 차원의 어레이의 하나의 차원에 따른 일 것이다.</target>
        </trans-unit>
        <trans-unit id="ae96087e76a9ce107c6e36702cbdc6f8e4f2b8bf" translate="yes" xml:space="preserve">
          <source>Create a new branch in the repository &lt;code&gt;repo&lt;/code&gt; with name &lt;code&gt;bname&lt;/code&gt;, which points to commit &lt;code&gt;commit_obj&lt;/code&gt; (which has to be part of &lt;code&gt;repo&lt;/code&gt;). If &lt;code&gt;force&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, overwrite an existing branch named &lt;code&gt;bname&lt;/code&gt; if it exists. If &lt;code&gt;force&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and a branch already exists named &lt;code&gt;bname&lt;/code&gt;, this function will throw an error.</source>
          <target state="translated">저장소에 새로운 지점을 만들기 &lt;code&gt;repo&lt;/code&gt; 이름으로 &lt;code&gt;bname&lt;/code&gt; 커밋 점, &lt;code&gt;commit_obj&lt;/code&gt; (의 일부가되고있다 &lt;code&gt;repo&lt;/code&gt; ). &lt;code&gt;force&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우 &lt;code&gt;bname&lt;/code&gt; 이라는 기존 분기 가 있으면 덮어 씁니다 . 경우 &lt;code&gt;force&lt;/code&gt; 이다 &lt;code&gt;false&lt;/code&gt; 과 지점이 이미 이름이 존재 &lt;code&gt;bname&lt;/code&gt; ,이 기능은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="542fd8a0f22e252853b2fa3a6c97502feebfa45d" translate="yes" xml:space="preserve">
          <source>Create a new entry in the Immutable Dictionary for the key =&amp;gt; value pair</source>
          <target state="translated">키 =&amp;gt; 값 쌍의 불변 사전에 새 항목을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="018e91396b89ddf1c7a72876b6df9778e135f2b3" translate="yes" xml:space="preserve">
          <source>Create a new git tag &lt;code&gt;tag&lt;/code&gt; (e.g. &lt;code&gt;&quot;v0.5&quot;&lt;/code&gt;) in the repository &lt;code&gt;repo&lt;/code&gt;, at the commit &lt;code&gt;commit&lt;/code&gt;.</source>
          <target state="translated">새로운 자식 태그 만들기 &lt;code&gt;tag&lt;/code&gt; (예 : &lt;code&gt;&quot;v0.5&quot;&lt;/code&gt; 저장소에) &lt;code&gt;repo&lt;/code&gt; 커밋에서 &lt;code&gt;commit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a3af261697fbecd6e1e61df8aa7ec1dc50fe659" translate="yes" xml:space="preserve">
          <source>Create a non-reentrant lock. Recursive use will result in a deadlock. Each &lt;a href=&quot;../parallel/index#Base.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; must be matched with an &lt;a href=&quot;../parallel/index#Base.unlock&quot;&gt;&lt;code&gt;unlock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">재진입 할 ​​수없는 잠금을 만듭니다. 재귀를 사용하면 교착 상태가 발생합니다. 각 &lt;a href=&quot;../parallel/index#Base.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;../parallel/index#Base.unlock&quot;&gt; &lt;code&gt;unlock&lt;/code&gt; &lt;/a&gt; 와 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b7e10405fa9ae28a15fde6de2cc04f54c5e19a78" translate="yes" xml:space="preserve">
          <source>Create a pipe to which all C and Julia level &lt;a href=&quot;#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; output will be redirected. Returns a tuple &lt;code&gt;(rd, wr)&lt;/code&gt; representing the pipe ends. Data written to &lt;a href=&quot;#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; may now be read from the &lt;code&gt;rd&lt;/code&gt; end of the pipe. The &lt;code&gt;wr&lt;/code&gt; end is given for convenience in case the old &lt;a href=&quot;#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; object was cached by the user and needs to be replaced elsewhere.</source>
          <target state="translated">모든 C 및 Julia 레벨 &lt;a href=&quot;#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; 출력이 경로 재 지정 될 파이프를 작성하십시오 . 파이프 끝을 나타내는 튜플 &lt;code&gt;(rd, wr)&lt;/code&gt; 반환합니다 . &lt;a href=&quot;#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; 에&lt;/a&gt; 기록 된 데이터 는 이제 파이프 의 &lt;code&gt;rd&lt;/code&gt; end 에서 읽을 수 있습니다 . &lt;code&gt;wr&lt;/code&gt; 끝은 오래된 경우에는 편의를 위해 제공되는 &lt;a href=&quot;#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; 객체는 사용자가 캐시 된 다른 곳에서 교체해야했다.</target>
        </trans-unit>
        <trans-unit id="d5609ae0d62a4b854bf2c4375ca4d215cbf7c0df" translate="yes" xml:space="preserve">
          <source>Create a pipeline from a data source to a destination. The source and destination can be commands, I/O streams, strings, or results of other &lt;code&gt;pipeline&lt;/code&gt; calls. At least one argument must be a command. Strings refer to filenames. When called with more than two arguments, they are chained together from left to right. For example, &lt;code&gt;pipeline(a,b,c)&lt;/code&gt; is equivalent to &lt;code&gt;pipeline(pipeline(a,b),c)&lt;/code&gt;. This provides a more concise way to specify multi-stage pipelines.</source>
          <target state="translated">데이터 소스에서 대상까지 파이프 라인을 만듭니다. 소스 및 대상은 명령, I / O 스트림, 문자열 또는 다른 &lt;code&gt;pipeline&lt;/code&gt; 호출의 결과 일 수 있습니다 . 적어도 하나의 인수는 명령이어야합니다. 문자열은 파일 이름을 나타냅니다. 두 개 이상의 인수로 호출하면 왼쪽에서 오른쪽으로 함께 연결됩니다. 예를 들어 &lt;code&gt;pipeline(a,b,c)&lt;/code&gt; 는 &lt;code&gt;pipeline(pipeline(a,b),c)&lt;/code&gt; . 이를 통해 다단계 파이프 라인을보다 간결하게 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24adb62e84b71340c3f621decef5a321f7e84b6a" translate="yes" xml:space="preserve">
          <source>Create a random length &lt;code&gt;m&lt;/code&gt; sparse vector or &lt;code&gt;m&lt;/code&gt; by &lt;code&gt;n&lt;/code&gt; sparse matrix, in which the probability of any element being nonzero is independently given by &lt;code&gt;p&lt;/code&gt; (and hence the mean density of nonzeros is also exactly &lt;code&gt;p&lt;/code&gt;). Nonzero values are sampled from the distribution specified by &lt;code&gt;rfn&lt;/code&gt; and have the type &lt;code&gt;type&lt;/code&gt;. The uniform distribution is used in case &lt;code&gt;rfn&lt;/code&gt; is not specified. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator, see &lt;a href=&quot;../random/index#Random-Numbers-1&quot;&gt;Random Numbers&lt;/a&gt;.</source>
          <target state="translated">임의의 길이 &lt;code&gt;m&lt;/code&gt; 스파 스 벡터 또는 &lt;code&gt;m&lt;/code&gt; x &lt;code&gt;n&lt;/code&gt; 스파 스 행렬을 생성합니다. 여기서 0이 아닌 요소의 확률은 &lt;code&gt;p&lt;/code&gt; 에 의해 독립적으로 주어집니다 (따라서 0이 아닌 평균 밀도는 정확히 &lt;code&gt;p&lt;/code&gt; 입니다 ). &lt;code&gt;rfn&lt;/code&gt; 에 의해 지정된 분포에서 0이 아닌 값이 샘플링되며 type &lt;code&gt;type&lt;/code&gt; 있습니다. &lt;code&gt;rfn&lt;/code&gt; 을 지정하지 않은 경우 균일 분포가 사용 됩니다. 옵션 &lt;code&gt;rng&lt;/code&gt; 인수는 참조 난수 발생기를 지정하는 &lt;a href=&quot;../random/index#Random-Numbers-1&quot;&gt;임의의 번호를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="61e09af9437fe2c45b77d2e9ddd5c2a0aea13bdf" translate="yes" xml:space="preserve">
          <source>Create a random sparse vector of length &lt;code&gt;m&lt;/code&gt; or sparse matrix of size &lt;code&gt;m&lt;/code&gt; by &lt;code&gt;n&lt;/code&gt; with the specified (independent) probability &lt;code&gt;p&lt;/code&gt; of any entry being nonzero, where nonzero values are sampled from the normal distribution. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator, see &lt;a href=&quot;../random/index#Random-Numbers-1&quot;&gt;Random Numbers&lt;/a&gt;.</source>
          <target state="translated">길이의 랜덤 스파 스 벡터 생성 &lt;code&gt;m&lt;/code&gt; 또는 크기의 희소 행렬 &lt;code&gt;m&lt;/code&gt; 을 하여 &lt;code&gt;n&lt;/code&gt; 특정 (독립) 확률과 &lt;code&gt;p&lt;/code&gt; 제로 값들이 정규 분포로부터 샘플링 된 모든 항목 인 제로의. 옵션 &lt;code&gt;rng&lt;/code&gt; 인수는 참조 난수 발생기를 지정하는 &lt;a href=&quot;../random/index#Random-Numbers-1&quot;&gt;임의의 번호를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c1a73a876cebbc3a0c143465473af20e5a925c98" translate="yes" xml:space="preserve">
          <source>Create a random string of length &lt;code&gt;len&lt;/code&gt;, consisting of characters from &lt;code&gt;chars&lt;/code&gt;, which defaults to the set of upper- and lower-case letters and the digits 0-9. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator, see &lt;a href=&quot;#Random-Numbers-1&quot;&gt;Random Numbers&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;chars&lt;/code&gt; 의 문자로 구성된 길이가 &lt;code&gt;len&lt;/code&gt; 인 임의의 문자열을 작성하십시오. 기본값은 대문자 및 소문자 및 숫자 0-9입니다. 옵션 &lt;code&gt;rng&lt;/code&gt; 인수는 참조 난수 발생기를 지정하는 &lt;a href=&quot;#Random-Numbers-1&quot;&gt;임의의 번호를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6ee28ecbd285880a7cd740fd7798c9c1727d428f" translate="yes" xml:space="preserve">
          <source>Create a raw string without interpolation and unescaping. The exception is that quotation marks still must be escaped. Backslashes escape both quotation marks and other backslashes, but only when a sequence of backslashes precedes a quote character. Thus, 2n backslashes followed by a quote encodes n backslashes and the end of the literal while 2n+1 backslashes followed by a quote encodes n backslashes followed by a quote character.</source>
          <target state="translated">보간 및 이스케이프 처리없이 원시 문자열을 작성하십시오. 단, 인용 부호는 여전히 이스케이프되어야합니다. 백 슬래시는 따옴표와 다른 백 슬래시를 모두 이스케이프하지만 일련의 백 슬래시가 따옴표 문자 앞에 오는 경우에만 이스케이프합니다. 따라서 2n 백 슬래시 다음에 따옴표는 n 백 슬래시와 리터럴의 끝을 인코딩하고 2n + 1 백 슬래시 뒤에 따옴표는 n 백 슬래시 다음에 따옴표 문자를 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="8da7a06794cadd72caef89925cfd7c17951f6bfa" translate="yes" xml:space="preserve">
          <source>Create a read-only &lt;code&gt;IOBuffer&lt;/code&gt; on the data underlying the given string.</source>
          <target state="translated">주어진 문자열의 기초가되는 데이터에 대해 읽기 전용 &lt;code&gt;IOBuffer&lt;/code&gt; 를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="f83dbfbf518114552573b6e6abae3e4139b31cb9" translate="yes" xml:space="preserve">
          <source>Create a shallow copy of &lt;code&gt;x&lt;/code&gt;: the outer structure is copied, but not all internal values. For example, copying an array produces a new array with identically-same elements as the original.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 얕은 사본을 만듭니다 . 외부 구조는 복사되지만 모든 내부 값은 아닙니다. 예를 들어 배열을 복사하면 원본과 동일한 요소를 가진 새 배열이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="9cb3be6cb095ffdb386198e5a53c66758791ab37" translate="yes" xml:space="preserve">
          <source>Create a sparse matrix &lt;code&gt;S&lt;/code&gt; of dimensions &lt;code&gt;m x n&lt;/code&gt; such that &lt;code&gt;S[I[k], J[k]] = V[k]&lt;/code&gt;. The &lt;code&gt;combine&lt;/code&gt; function is used to combine duplicates. If &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are not specified, they are set to &lt;code&gt;maximum(I)&lt;/code&gt; and &lt;code&gt;maximum(J)&lt;/code&gt; respectively. If the &lt;code&gt;combine&lt;/code&gt; function is not supplied, &lt;code&gt;combine&lt;/code&gt; defaults to &lt;code&gt;+&lt;/code&gt; unless the elements of &lt;code&gt;V&lt;/code&gt; are Booleans in which case &lt;code&gt;combine&lt;/code&gt; defaults to &lt;code&gt;|&lt;/code&gt;. All elements of &lt;code&gt;I&lt;/code&gt; must satisfy &lt;code&gt;1 &amp;lt;= I[k] &amp;lt;= m&lt;/code&gt;, and all elements of &lt;code&gt;J&lt;/code&gt; must satisfy &lt;code&gt;1 &amp;lt;= J[k] &amp;lt;= n&lt;/code&gt;. Numerical zeros in (&lt;code&gt;I&lt;/code&gt;, &lt;code&gt;J&lt;/code&gt;, &lt;code&gt;V&lt;/code&gt;) are retained as structural nonzeros; to drop numerical zeros, use &lt;a href=&quot;#SparseArrays.dropzeros!&quot;&gt;&lt;code&gt;dropzeros!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;S[I[k], J[k]] = V[k]&lt;/code&gt; 되도록 &lt;code&gt;m x n&lt;/code&gt; 크기 의 희소 행렬 &lt;code&gt;S&lt;/code&gt; 를 만듭니다 . &lt;code&gt;combine&lt;/code&gt; 기능은 중복을 결합하는 데 사용됩니다. 경우에 &lt;code&gt;m&lt;/code&gt; 과 &lt;code&gt;n&lt;/code&gt; 을 지정하지 이들은에 설정된 &lt;code&gt;maximum(I)&lt;/code&gt; 및 &lt;code&gt;maximum(J)&lt;/code&gt; 각각. (가) 경우 &lt;code&gt;combine&lt;/code&gt; 기능이 제공되지 않습니다, &lt;code&gt;combine&lt;/code&gt; 에 기본값 &lt;code&gt;+&lt;/code&gt; 의 요소를 제외 &lt;code&gt;V&lt;/code&gt; 는 부울이 경우에 &lt;code&gt;combine&lt;/code&gt; 에 기본값을 &lt;code&gt;|&lt;/code&gt; . 모든 요소 &lt;code&gt;I&lt;/code&gt; 는 만족해야 &lt;code&gt;1 &amp;lt;= I[k] &amp;lt;= m&lt;/code&gt; , 그리고 모든 요소 &lt;code&gt;J&lt;/code&gt; 는 &lt;code&gt;1 &amp;lt;= J[k] &amp;lt;= n&lt;/code&gt; 충족해야합니다 . ( &lt;code&gt;I&lt;/code&gt; , &lt;code&gt;J&lt;/code&gt; , &lt;code&gt;V&lt;/code&gt; )의 숫자 0은 구조적 0이 아닌 값으로 유지됩니다. 숫자 0을 삭제하려면 &lt;a href=&quot;#SparseArrays.dropzeros!&quot;&gt; &lt;code&gt;dropzeros!&lt;/code&gt; &lt;/a&gt; 사용 하십시오! .</target>
        </trans-unit>
        <trans-unit id="c5011b871e48d58f4cd3d39dc5cf861693b7b3f0" translate="yes" xml:space="preserve">
          <source>Create a sparse vector &lt;code&gt;S&lt;/code&gt; of length &lt;code&gt;m&lt;/code&gt; such that &lt;code&gt;S[I[k]] = V[k]&lt;/code&gt;. Duplicates are combined using the &lt;code&gt;combine&lt;/code&gt; function, which defaults to &lt;code&gt;+&lt;/code&gt; if no &lt;code&gt;combine&lt;/code&gt; argument is provided, unless the elements of &lt;code&gt;V&lt;/code&gt; are Booleans in which case &lt;code&gt;combine&lt;/code&gt; defaults to &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;S[I[k]] = V[k]&lt;/code&gt; 되도록 길이 &lt;code&gt;m&lt;/code&gt; 의 희소 벡터 &lt;code&gt;S&lt;/code&gt; 를 만듭니다 . 중복이 (가) 사용하여 결합하는 &lt;code&gt;combine&lt;/code&gt; 디폴트 기능, &lt;code&gt;+&lt;/code&gt; 어떤이 경우 &lt;code&gt;combine&lt;/code&gt; 의 요소하지 않는 한, 제공되는 인수를 &lt;code&gt;V&lt;/code&gt; 는 부울이 경우에 &lt;code&gt;combine&lt;/code&gt; 에 기본값을 &lt;code&gt;|&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5af6da27ae9944a05eb6bb91e99e94212274e3cb" translate="yes" xml:space="preserve">
          <source>Create a sparse vector of length &lt;code&gt;m&lt;/code&gt; or sparse matrix of size &lt;code&gt;m x n&lt;/code&gt;. This sparse array will not contain any nonzero values. No storage will be allocated for nonzero values during construction. The type defaults to &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; if not specified.</source>
          <target state="translated">길이가 &lt;code&gt;m&lt;/code&gt; 인 희소 벡터 또는 &lt;code&gt;m x n&lt;/code&gt; 크기의 희소 행렬을 만듭니다 . 이 희소 배열에는 0이 아닌 값이 포함되지 않습니다. 구성하는 동안 0이 아닌 값에 스토리지가 할당되지 않습니다. 지정되지 않은 경우 유형은 기본적으로 &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="58a5aeb67ce63929f99f3293ccf57387db820ad0" translate="yes" xml:space="preserve">
          <source>Create a sparse vector of length &lt;code&gt;m&lt;/code&gt; where the nonzero indices are keys from the dictionary, and the nonzero values are the values from the dictionary.</source>
          <target state="translated">0이 아닌 인덱스가 사전의 키이고 0이 아닌 값이 사전의 값인 길이 &lt;code&gt;m&lt;/code&gt; 의 희소 벡터를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="8f503d60ac5dd0352ae777a0e19093ba170f05ca" translate="yes" xml:space="preserve">
          <source>Create a string based upon the URL components provided. When the &lt;code&gt;scheme&lt;/code&gt; keyword is not provided the URL produced will use the alternative &lt;a href=&quot;https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a&quot;&gt;scp-like syntax&lt;/a&gt;.</source>
          <target state="translated">제공된 URL 구성 요소를 기반으로 문자열을 작성하십시오. 때 &lt;code&gt;scheme&lt;/code&gt; 대체 사용 생성되는 URL이 제공되지 않는 키워드 &lt;a href=&quot;https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a&quot;&gt;SCP-같은 구문을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aaa7fda98b7d8855e2b4e7e053b01d032e7a1841" translate="yes" xml:space="preserve">
          <source>Create a string from any value using the &lt;code&gt;show&lt;/code&gt; function. You should not add methods to &lt;code&gt;repr&lt;/code&gt;; define a &lt;code&gt;show&lt;/code&gt; method instead.</source>
          <target state="translated">&lt;code&gt;show&lt;/code&gt; 함수를 사용하여 모든 값에서 문자열을 만듭니다 . &lt;code&gt;repr&lt;/code&gt; 에 메소드를 추가해서는 안됩니다 . 대신 &lt;code&gt;show&lt;/code&gt; 메소드를 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="e66181553ea669848b336edb8190dd3795b76e53" translate="yes" xml:space="preserve">
          <source>Create a string from any values, except &lt;code&gt;nothing&lt;/code&gt;, using the &lt;a href=&quot;../io-network/index#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">를 제외하고, 모든 값에서 문자열을 만들기 &lt;code&gt;nothing&lt;/code&gt; 사용하여 &lt;a href=&quot;../io-network/index#Base.print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt; 기능을.</target>
        </trans-unit>
        <trans-unit id="6b407e62c50b7579a1b48390737d3d9d521a089c" translate="yes" xml:space="preserve">
          <source>Create a temporary directory in the &lt;code&gt;parent&lt;/code&gt; directory with a name constructed from the given prefix and a random suffix, and return its path. Additionally, any trailing &lt;code&gt;X&lt;/code&gt; characters may be replaced with random characters. If &lt;code&gt;parent&lt;/code&gt; does not exist, throw an error.</source>
          <target state="translated">주어진 접두사와 임의 접미사로 구성된 이름으로 &lt;code&gt;parent&lt;/code&gt; 디렉토리에 임시 디렉토리를 작성하고 해당 경로를 리턴하십시오. 또한 후행 &lt;code&gt;X&lt;/code&gt; 문자는 임의의 문자로 대체 될 수 있습니다. 경우 &lt;code&gt;parent&lt;/code&gt; 존재하지 않는 오류가 발생.</target>
        </trans-unit>
        <trans-unit id="74d681100427f7076ed67273bc216adc2864cfb4" translate="yes" xml:space="preserve">
          <source>Create a timer that wakes up tasks waiting for it (by calling &lt;a href=&quot;../parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on the timer object) and calls the function &lt;code&gt;callback&lt;/code&gt;.</source>
          <target state="translated">타이머 객체에서 &lt;a href=&quot;../parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 를 호출하여 대기중인 작업을 깨우고 &lt;code&gt;callback&lt;/code&gt; 함수를 호출하는 타이머를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="9b6c236b317e2feae409a047b5bb9690d7eaa0be" translate="yes" xml:space="preserve">
          <source>Create a timer that wakes up tasks waiting for it (by calling &lt;a href=&quot;../parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on the timer object).</source>
          <target state="translated">타이머 객체에서 &lt;a href=&quot;../parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 를 호출하여 대기중인 작업을 깨우는 타이머를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="fe6838aa6e3e621f355c9b1295ab3768c3010eb0" translate="yes" xml:space="preserve">
          <source>Create a tuple of length &lt;code&gt;n&lt;/code&gt;, computing each element as &lt;code&gt;f(i)&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; is the index of the element.</source>
          <target state="translated">각 요소를 &lt;code&gt;f(i)&lt;/code&gt; 로 계산 하는 길이 &lt;code&gt;n&lt;/code&gt; 의 튜플을 작성합니다 . 여기서 &lt;code&gt;i&lt;/code&gt; 는 요소의 색인입니다.</target>
        </trans-unit>
        <trans-unit id="6c21b2eac39c09ea54cf9d183a22560ba8078519" translate="yes" xml:space="preserve">
          <source>Create all directories in the given &lt;code&gt;path&lt;/code&gt;, with permissions &lt;code&gt;mode&lt;/code&gt;. &lt;code&gt;mode&lt;/code&gt; defaults to &lt;code&gt;0o777&lt;/code&gt;, modified by the current file creation mask. Return &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">권한 &lt;code&gt;mode&lt;/code&gt; 지정된 &lt;code&gt;path&lt;/code&gt; 에 모든 디렉토리를 작성하십시오 . &lt;code&gt;mode&lt;/code&gt; 기본값 &lt;code&gt;0o777&lt;/code&gt; 현재 파일 생성 마스크에 의해 수정. &lt;code&gt;path&lt;/code&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="cf162de3c9c9ee881cac0dcb3cd170c29ebef959" translate="yes" xml:space="preserve">
          <source>Create an &lt;a href=&quot;#Base.IOStream&quot;&gt;&lt;code&gt;IOStream&lt;/code&gt;&lt;/a&gt; object from an integer file descriptor. If &lt;code&gt;own&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, closing this object will close the underlying descriptor. By default, an &lt;code&gt;IOStream&lt;/code&gt; is closed when it is garbage collected. &lt;code&gt;name&lt;/code&gt; allows you to associate the descriptor with a named file.</source>
          <target state="translated">정수 파일 디스크립터에서 &lt;a href=&quot;#Base.IOStream&quot;&gt; &lt;code&gt;IOStream&lt;/code&gt; &lt;/a&gt; 오브젝트를 작성하십시오 . 경우 &lt;code&gt;own&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; ,이 객체를 폐쇄하는 것은 기본 설명을 닫습니다. 기본적으로 &lt;code&gt;IOStream&lt;/code&gt; 은 가비지 수집시 닫힙니다. &lt;code&gt;name&lt;/code&gt; 을 사용하면 설명자를 명명 된 파일과 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d27efa244291014a3b2adaa305d7bd4d5b64350" translate="yes" xml:space="preserve">
          <source>Create an &lt;code&gt;Array&lt;/code&gt; whose values are linked to a file, using memory-mapping. This provides a convenient way of working with data too large to fit in the computer's memory.</source>
          <target state="translated">메모리 매핑을 사용하여 값이 파일에 연결된 &lt;code&gt;Array&lt;/code&gt; 를 만듭니다 . 이렇게하면 컴퓨터 메모리에 맞지 않는 너무 큰 데이터로 작업하는 편리한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b8bb86166b97c93700925b2b59c6f26d354e7671" translate="yes" xml:space="preserve">
          <source>Create an &lt;code&gt;Array&lt;/code&gt;, with element type &lt;code&gt;T&lt;/code&gt;, of all ones with size specified by &lt;code&gt;dims&lt;/code&gt;. See also: &lt;a href=&quot;#Base.fill&quot;&gt;&lt;code&gt;fill&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Base.zeros&quot;&gt;&lt;code&gt;zeros&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">요소 유형이 &lt;code&gt;T&lt;/code&gt; 이고, 크기가 &lt;code&gt;dims&lt;/code&gt; 인 모든 &lt;code&gt;Array&lt;/code&gt; 만듭니다 . &lt;a href=&quot;#Base.fill&quot;&gt; &lt;code&gt;fill&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#Base.zeros&quot;&gt; &lt;code&gt;zeros&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c843cf6b2431abf5229a8828a3d5be9c5597803a" translate="yes" xml:space="preserve">
          <source>Create an &lt;code&gt;Array&lt;/code&gt;, with element type &lt;code&gt;T&lt;/code&gt;, of all zeros with size specified by &lt;code&gt;dims&lt;/code&gt;. See also &lt;a href=&quot;#Base.fill&quot;&gt;&lt;code&gt;fill&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Base.ones&quot;&gt;&lt;code&gt;ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">요소 유형이 &lt;code&gt;T&lt;/code&gt; 이고, 크기가 &lt;code&gt;dims&lt;/code&gt; 로 지정된 모든 0 의 &lt;code&gt;Array&lt;/code&gt; 작성하십시오 . 참조 &lt;a href=&quot;#Base.fill&quot;&gt; &lt;code&gt;fill&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#Base.ones&quot;&gt; &lt;code&gt;ones&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b6e18437c6870b3441a198a29488dbaad1e36b6c" translate="yes" xml:space="preserve">
          <source>Create an &lt;code&gt;Enum{BaseType}&lt;/code&gt; subtype with name &lt;code&gt;EnumName&lt;/code&gt; and enum member values of &lt;code&gt;value1&lt;/code&gt; and &lt;code&gt;value2&lt;/code&gt; with optional assigned values of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, respectively. &lt;code&gt;EnumName&lt;/code&gt; can be used just like other types and enum member values as regular values, such as</source>
          <target state="translated">이름이 &lt;code&gt;EnumName&lt;/code&gt; 이고 열거 형 멤버 값이 &lt;code&gt;value1&lt;/code&gt; 과 &lt;code&gt;value2&lt;/code&gt; 인 &lt;code&gt;Enum{BaseType}&lt;/code&gt; 하위 유형을 각각 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 선택적 할당 값으로 작성하십시오 . &lt;code&gt;EnumName&lt;/code&gt; 은 다른 유형과 마찬가지로 열거 형 멤버 값과 같은 일반 값으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1988e010ef2dfb8cfcde7da8bec73bf1cf0c049c" translate="yes" xml:space="preserve">
          <source>Create an &lt;code&gt;HTML&lt;/code&gt; object from a literal string.</source>
          <target state="translated">리터럴 문자열에서 &lt;code&gt;HTML&lt;/code&gt; 객체를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="b7f0dc80f42f1aad71a14562fb4f32c0b79e2ba4" translate="yes" xml:space="preserve">
          <source>Create an &lt;code&gt;IO&lt;/code&gt;-like object for creating zeroed-out mmapped-memory that is not tied to a file for use in &lt;a href=&quot;#Mmap.mmap&quot;&gt;&lt;code&gt;Mmap.mmap&lt;/code&gt;&lt;/a&gt;. Used by &lt;code&gt;SharedArray&lt;/code&gt; for creating shared memory arrays.</source>
          <target state="translated">&lt;a href=&quot;#Mmap.mmap&quot;&gt; &lt;code&gt;Mmap.mmap&lt;/code&gt; &lt;/a&gt; 에서 사용하기 위해 파일에 묶이지 않은 0으로 채워진 mmapped 메모리를 작성하기위한 &lt;code&gt;IO&lt;/code&gt; 유사 오브젝트를 작성 하십시오 . &lt;code&gt;SharedArray&lt;/code&gt; 에서 공유 메모리 어레이를 생성하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d4050068afe0146f56219f374e0ff6e6eb7e3429" translate="yes" xml:space="preserve">
          <source>Create an &lt;code&gt;IOContext&lt;/code&gt; that wraps a given stream, adding the specified &lt;code&gt;key=&amp;gt;value&lt;/code&gt; pairs to the properties of that stream (note that &lt;code&gt;io&lt;/code&gt; can itself be an &lt;code&gt;IOContext&lt;/code&gt;).</source>
          <target state="translated">지정된 &lt;code&gt;key=&amp;gt;value&lt;/code&gt; 쌍을 해당 스트림의 속성에 추가하여 지정된 스트림을 래핑 하는 &lt;code&gt;IOContext&lt;/code&gt; 를 만듭니다 ( &lt;code&gt;io&lt;/code&gt; 자체는 &lt;code&gt;IOContext&lt;/code&gt; 일 수 있음에 유의하십시오 ).</target>
        </trans-unit>
        <trans-unit id="c37df1886c75da4684010c132d283b587ed7e2fa" translate="yes" xml:space="preserve">
          <source>Create an &lt;code&gt;IOContext&lt;/code&gt; that wraps an alternate &lt;code&gt;IO&lt;/code&gt; but inherits the properties of &lt;code&gt;context&lt;/code&gt;.</source>
          <target state="translated">대체 &lt;code&gt;IO&lt;/code&gt; 를 래핑 하지만 &lt;code&gt;context&lt;/code&gt; 속성을 상속 하는 &lt;code&gt;IOContext&lt;/code&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="895f46bbf3cda62374e24ffe50376b92dadf2c8f" translate="yes" xml:space="preserve">
          <source>Create an anonymous function and pass it as the first argument to a function call. For example:</source>
          <target state="translated">익명 함수를 작성하여 함수 호출의 첫 번째 인수로 전달하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="182df2225052f7994222327e4b5a296aa23d4ff3" translate="yes" xml:space="preserve">
          <source>Create an arbitrary precision floating point number from &lt;code&gt;x&lt;/code&gt;, with precision &lt;code&gt;precision&lt;/code&gt;. The &lt;code&gt;rounding&lt;/code&gt; argument specifies the direction in which the result should be rounded if the conversion cannot be done exactly. If not provided, these are set by the current global values.</source>
          <target state="translated">정밀도 &lt;code&gt;precision&lt;/code&gt; 하여 &lt;code&gt;x&lt;/code&gt; 에서 임의의 정밀도 부동 소수점 숫자를 만듭니다 . &lt;code&gt;rounding&lt;/code&gt; 인수는 변환이 정확히 수행 할 수없는 경우 결과가 반올림해야하는 방향을 지정합니다. 제공되지 않은 경우 현재 전역 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="171f32afa59f09b1061417cecc3c2a183be4d108" translate="yes" xml:space="preserve">
          <source>Create an arbitrary precision integer. &lt;code&gt;x&lt;/code&gt; may be an &lt;code&gt;Int&lt;/code&gt; (or anything that can be converted to an &lt;code&gt;Int&lt;/code&gt;). The usual mathematical operators are defined for this type, and results are promoted to a &lt;a href=&quot;#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">임의의 정밀도 정수를 만듭니다. &lt;code&gt;x&lt;/code&gt; 수있다 &lt;code&gt;Int&lt;/code&gt; (AN으로 변환 될 수 있거나 아무것도 &lt;code&gt;Int&lt;/code&gt; ). 이 유형에 대해 일반적인 수학 연산자가 정의되고 결과가 &lt;a href=&quot;#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; 로 승격됩니다 .</target>
        </trans-unit>
        <trans-unit id="dfce70679587984abb0464685e1cceade3a5bbd1" translate="yes" xml:space="preserve">
          <source>Create an array filled with the value &lt;code&gt;x&lt;/code&gt;. For example, &lt;code&gt;fill(1.0, (5,5))&lt;/code&gt; returns a 5&amp;times;5 array of floats, with each element initialized to &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 값으로 채워진 배열을 만듭니다 . 예를 들어 &lt;code&gt;fill(1.0, (5,5))&lt;/code&gt; 는 각 요소가 &lt;code&gt;1.0&lt;/code&gt; 으로 초기화 된 5x5 부동 소수점 배열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="efff1664d300afbe16f9f536bbbebcb903f65216" translate="yes" xml:space="preserve">
          <source>Create an edge-triggered event source that tasks can wait for. Tasks that call &lt;a href=&quot;#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;Condition&lt;/code&gt; are suspended and queued. Tasks are woken up when &lt;a href=&quot;#Base.notify&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt; is later called on the &lt;code&gt;Condition&lt;/code&gt;. Edge triggering means that only tasks waiting at the time &lt;a href=&quot;#Base.notify&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt; is called can be woken up. For level-triggered notifications, you must keep extra state to keep track of whether a notification has happened. The &lt;a href=&quot;#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.Event&quot;&gt;&lt;code&gt;Threads.Event&lt;/code&gt;&lt;/a&gt; types do this, and can be used for level-triggered events.</source>
          <target state="translated">작업이 기다릴 수있는 에지 트리거 이벤트 소스를 작성하십시오. 콜 것을 작업 &lt;a href=&quot;#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; A의 &lt;code&gt;Condition&lt;/code&gt; 일시 중단하고 대기합니다. 나중에 &lt;code&gt;Condition&lt;/code&gt; 에서 &lt;a href=&quot;#Base.notify&quot;&gt; &lt;code&gt;notify&lt;/code&gt; &lt;/a&gt; 이 호출 되면 작업이 시작됩니다 . Edge 트리거링은 &lt;a href=&quot;#Base.notify&quot;&gt; &lt;code&gt;notify&lt;/code&gt; &lt;/a&gt; 할 때 대기중인 작업 만 깨울 수 있음을 의미합니다. 레벨 트리거 알림의 경우 알림 발생 여부를 추적하기 위해 추가 상태를 유지해야합니다. &lt;a href=&quot;#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#Base.Event&quot;&gt; &lt;code&gt;Threads.Event&lt;/code&gt; &lt;/a&gt; 유형이 작업을 수행, 레벨 트리거 이벤트를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="520078b92dd7a16aee09f78e8b0db867f75cb94e" translate="yes" xml:space="preserve">
          <source>Create an immutable byte (&lt;code&gt;UInt8&lt;/code&gt;) vector using string syntax.</source>
          <target state="translated">문자열 구문을 사용하여 불변 바이트 ( &lt;code&gt;UInt8&lt;/code&gt; ) 벡터를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="da84c283b9346ebc02fd11c8e5c614ee585502d6" translate="yes" xml:space="preserve">
          <source>Create an in-memory I/O stream, which may optionally operate on a pre-existing array.</source>
          <target state="translated">선택적으로 기존 어레이에서 작동 할 수있는 메모리 내 I / O 스트림을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0ea93e0af90bf05567f22a1eb39a67d625d70a2a" translate="yes" xml:space="preserve">
          <source>Create an iterable &lt;code&gt;EachLine&lt;/code&gt; object that will yield each line from an I/O stream or a file. Iteration calls &lt;a href=&quot;#Base.readline&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; on the stream argument repeatedly with &lt;code&gt;keep&lt;/code&gt; passed through, determining whether trailing end-of-line characters are retained. When called with a file name, the file is opened once at the beginning of iteration and closed at the end. If iteration is interrupted, the file will be closed when the &lt;code&gt;EachLine&lt;/code&gt; object is garbage collected.</source>
          <target state="translated">반복 가능한 &lt;code&gt;EachLine&lt;/code&gt; 객체를 만들어 I / O 스트림 또는 파일에서 각 줄을 생성합니다. 반복 은 스트림 통과 인수에 대해 &lt;a href=&quot;#Base.readline&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt; 을 반복하여 &lt;code&gt;keep&lt;/code&gt; pass through로 후행 줄 끝 문자가 유지되는지 여부를 판별합니다. 파일 이름으로 호출되면 파일은 반복 시작시 한 번 열리고 끝에서 닫힙니다. 반복이 중단되면 &lt;code&gt;EachLine&lt;/code&gt; 객체가 가비지 수집 될 때 파일이 닫힙니다 .</target>
        </trans-unit>
        <trans-unit id="ef0e28d10352752c6450ce2dfc986b9c25b31c66" translate="yes" xml:space="preserve">
          <source>Create an iterable object for visiting each index of an &lt;code&gt;AbstractArray&lt;/code&gt;&lt;code&gt;A&lt;/code&gt; in an efficient manner. For array types that have opted into fast linear indexing (like &lt;code&gt;Array&lt;/code&gt;), this is simply the range &lt;code&gt;1:length(A)&lt;/code&gt;. For other array types, return a specialized Cartesian range to efficiently index into the array with indices specified for every dimension. For other iterables, including strings and dictionaries, return an iterator object supporting arbitrary index types (e.g. unevenly spaced or non-integer indices).</source>
          <target state="translated">효율적인 방법으로 &lt;code&gt;AbstractArray&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; 의 각 인덱스를 방문하기위한 반복 가능한 객체를 만듭니다 . 빠른 선형 인덱싱 (예 : &lt;code&gt;Array&lt;/code&gt; ) 을 선택한 배열 유형의 경우 이는 단순히 &lt;code&gt;1:length(A)&lt;/code&gt; 범위 입니다. 다른 배열 유형의 경우 특수한 직교 범위를 반환하여 모든 차원에 대해 지정된 인덱스로 배열을 효율적으로 색인화합니다. 문자열과 사전을 포함한 다른 반복 가능한 경우 임의의 인덱스 유형을 지원하는 반복자 객체 (예 : 불균일 한 간격 또는 정수가 아닌 인덱스)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="37a114db40a5b561df4c6998b980d11f164be66f" translate="yes" xml:space="preserve">
          <source>Create an uninitialized mutable array analogous to that specified by &lt;code&gt;storagetype&lt;/code&gt;, but with &lt;code&gt;axes&lt;/code&gt; specified by the last argument. &lt;code&gt;storagetype&lt;/code&gt; might be a type or a function.</source>
          <target state="translated">&lt;code&gt;storagetype&lt;/code&gt; 에 의해 지정된 것과 유사 하지만 마지막 인수에 의해 지정된 &lt;code&gt;axes&lt;/code&gt; 으로 초기화되지 않은 변경 가능한 배열을 만듭니다 . &lt;code&gt;storagetype&lt;/code&gt; 은 유형 또는 함수일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d8ea45663459513f743906566fff438525d9ff0" translate="yes" xml:space="preserve">
          <source>Create an uninitialized mutable array with the given element type and size, based upon the given source array. The second and third arguments are both optional, defaulting to the given array's &lt;code&gt;eltype&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt;. The dimensions may be specified either as a single tuple argument or as a series of integer arguments.</source>
          <target state="translated">주어진 소스 배열을 기반으로 주어진 요소 유형 및 크기로 초기화되지 않은 변경 가능한 배열을 만듭니다. 두 번째와 세 번째 인수는 모두 선택적이며 주어진 배열의 &lt;code&gt;eltype&lt;/code&gt; 및 &lt;code&gt;size&lt;/code&gt; 가 기본값 입니다. 차원은 단일 튜플 인수 또는 일련의 정수 인수로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79911f08e573f962982b247d6e1b479293a78b80" translate="yes" xml:space="preserve">
          <source>Create and listen on a named pipe / UNIX domain socket.</source>
          <target state="translated">명명 된 파이프 / UNIX 도메인 소켓에서 작성하고 청취하십시오.</target>
        </trans-unit>
        <trans-unit id="1b543386b4baf8de98d8473a008082cdc29f6cba" translate="yes" xml:space="preserve">
          <source>Create references to remote channels of a specific size and type. &lt;code&gt;f&lt;/code&gt; is a function that when executed on &lt;code&gt;pid&lt;/code&gt; must return an implementation of an &lt;code&gt;AbstractChannel&lt;/code&gt;.</source>
          <target state="translated">특정 크기 및 유형의 원격 채널에 대한 참조를 작성하십시오. &lt;code&gt;f&lt;/code&gt; 는 &lt;code&gt;pid&lt;/code&gt; 에서 실행될 때 &lt;code&gt;AbstractChannel&lt;/code&gt; 의 구현을 반환해야하는 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="946b30e9c53338d66c71fd7a6dcea51240337a53" translate="yes" xml:space="preserve">
          <source>Creates a &lt;code&gt;SubArray&lt;/code&gt; from an indexing expression. This can only be applied directly to a reference expression (e.g. &lt;code&gt;@view A[1,2:end]&lt;/code&gt;), and should &lt;em&gt;not&lt;/em&gt; be used as the target of an assignment (e.g. &lt;code&gt;@view(A[1,2:end]) = ...&lt;/code&gt;). See also &lt;a href=&quot;#Base.@views&quot;&gt;&lt;code&gt;@views&lt;/code&gt;&lt;/a&gt; to switch an entire block of code to use views for slicing.</source>
          <target state="translated">작성 &lt;code&gt;SubArray&lt;/code&gt; 인덱싱 식에서합니다. 이는 참조 표현식 (예 : &lt;code&gt;@view A[1,2:end]&lt;/code&gt; ) 에만 직접 적용 할 수 있으며 할당의 대상으로 사용 해서는 &lt;em&gt;안됩니다&lt;/em&gt; (예 : &lt;code&gt;@view(A[1,2:end]) = ...&lt;/code&gt; ). 슬라이싱에 뷰를 사용하도록 전체 코드 블록을 전환하려면 &lt;a href=&quot;#Base.@views&quot;&gt; &lt;code&gt;@views&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b7df04f96de18b903f8a03412ba0a608ddf39df4" translate="yes" xml:space="preserve">
          <source>Creates a &lt;em&gt;m&lt;/em&gt;-by-&lt;em&gt;n&lt;/em&gt; matrix of zeros. (&lt;a href=&quot;#SparseArrays.spzeros&quot;&gt;&lt;code&gt;spzeros(m,n)&lt;/code&gt;&lt;/a&gt; is empty.)</source>
          <target state="translated">작성 &lt;em&gt;m&lt;/em&gt; -by- &lt;em&gt;N 개의&lt;/em&gt; 제로의 매트릭스. ( &lt;a href=&quot;#SparseArrays.spzeros&quot;&gt; &lt;code&gt;spzeros(m,n)&lt;/code&gt; &lt;/a&gt; 은 비어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="89e81042f6427ed532f001aa21eed74e1277eedc" translate="yes" xml:space="preserve">
          <source>Creates a &lt;em&gt;m&lt;/em&gt;-by-&lt;em&gt;n&lt;/em&gt; random matrix (of density &lt;em&gt;d&lt;/em&gt;) with iid non-zero elements distributed according to the &lt;em&gt;X&lt;/em&gt; distribution. (Requires the &lt;code&gt;Distributions&lt;/code&gt; package.)</source>
          <target state="translated">&lt;em&gt;X&lt;/em&gt; 분포 에 따라 0이 아닌 iid 요소가 분포 된 &lt;em&gt;m&lt;/em&gt; x &lt;em&gt;n&lt;/em&gt; 랜덤 행렬 (밀도 &lt;em&gt;d&lt;/em&gt; )을 만듭니다 . ( &lt;code&gt;Distributions&lt;/code&gt; 패키지가 필요합니다 .)&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5dcdc6aa977d12b3464dea6213b384f8502692b5" translate="yes" xml:space="preserve">
          <source>Creates a &lt;em&gt;m&lt;/em&gt;-by-&lt;em&gt;n&lt;/em&gt; random matrix (of density &lt;em&gt;d&lt;/em&gt;) with iid non-zero elements distributed according to the standard normal (Gaussian) distribution.</source>
          <target state="translated">표준 정규 (가우시안) 분포에 따라 0이 아닌 iid 요소가 분포 된 &lt;em&gt;m&lt;/em&gt; x &lt;em&gt;n&lt;/em&gt; 랜덤 행렬 (밀도 &lt;em&gt;d&lt;/em&gt; )을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="f8b69c62af1974d81f87c4f3b0ecd8ee59170f8d" translate="yes" xml:space="preserve">
          <source>Creates a &lt;em&gt;m&lt;/em&gt;-by-&lt;em&gt;n&lt;/em&gt; random matrix (of density &lt;em&gt;d&lt;/em&gt;) with iid non-zero elements distributed uniformly on the half-open interval $[0, 1)$.</source>
          <target state="translated">반 개방 간격 $ [0, 1) $에 0이 아닌 iid 요소가 균일하게 분포 된 &lt;em&gt;m&lt;/em&gt; x &lt;em&gt;n&lt;/em&gt; 랜덤 행렬 (밀도 &lt;em&gt;d&lt;/em&gt; )을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="14a84275cae03e282157d756507c417c693cca8f" translate="yes" xml:space="preserve">
          <source>Creates a &lt;em&gt;n&lt;/em&gt;-by-&lt;em&gt;n&lt;/em&gt; identity matrix.</source>
          <target state="translated">작성 &lt;em&gt;N&lt;/em&gt; -by- &lt;em&gt;N의&lt;/em&gt; 항등 행렬을.</target>
        </trans-unit>
        <trans-unit id="7d1606830bc807d0705cb0cd68427ce107b28412" translate="yes" xml:space="preserve">
          <source>Creates a precompiled cache file for a module and all of its dependencies. This can be used to reduce package load times. Cache files are stored in &lt;code&gt;DEPOT_PATH[1]/compiled&lt;/code&gt;. See &lt;a href=&quot;../../manual/modules/index#Module-initialization-and-precompilation-1&quot;&gt;Module initialization and precompilation&lt;/a&gt; for important notes.</source>
          <target state="translated">모듈 및 모든 해당 종속성에 대해 사전 컴파일 된 캐시 파일을 작성합니다. 패키지로드 시간을 줄이는 데 사용할 수 있습니다. 캐시 파일은 &lt;code&gt;DEPOT_PATH[1]/compiled&lt;/code&gt; 저장됩니다 . 중요한 참고 사항 은 &lt;a href=&quot;../../manual/modules/index#Module-initialization-and-precompilation-1&quot;&gt;모듈 초기화 및 사전 컴파일&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb9535802e7b206a931b1bd5dd7001d10e59c1c3" translate="yes" xml:space="preserve">
          <source>Creates a re-entrant lock for synchronizing &lt;a href=&quot;#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;s. The same task can acquire the lock as many times as required. Each &lt;a href=&quot;#Base.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; must be matched with an &lt;a href=&quot;#Base.unlock&quot;&gt;&lt;code&gt;unlock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 동기화를위한 재진입 잠금을 만듭니다 . 동일한 태스크가 필요한만큼 잠금을 획득 할 수 있습니다. 각 &lt;a href=&quot;#Base.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#Base.unlock&quot;&gt; &lt;code&gt;unlock&lt;/code&gt; &lt;/a&gt; 와 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="acabfae1e2f1fc10302e24c287378e2416376616" translate="yes" xml:space="preserve">
          <source>Creates a symbolic link to &lt;code&gt;target&lt;/code&gt; with the name &lt;code&gt;link&lt;/code&gt;.</source>
          <target state="translated">이름 &lt;code&gt;link&lt;/code&gt; 로 &lt;code&gt;target&lt;/code&gt; 으로 하는 심볼릭 링크를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="a73f7647123bfc2728187c9560131d8d50116f46" translate="yes" xml:space="preserve">
          <source>Creating C-Compatible Julia Function Pointers</source>
          <target state="translated">C 호환 Julia 함수 포인터 만들기</target>
        </trans-unit>
        <trans-unit id="3383e56fce9b7a3ece327ee47bf1ef8a6d2cba06" translate="yes" xml:space="preserve">
          <source>Creating Custom &lt;code&gt;AbstractTestSet&lt;/code&gt; Types</source>
          <target state="translated">커스텀 &lt;code&gt;AbstractTestSet&lt;/code&gt; 타입 생성</target>
        </trans-unit>
        <trans-unit id="7cd4ab56a79487eec69d5f21bd101f982fbcd5a4" translate="yes" xml:space="preserve">
          <source>Creating a DateFormat object is expensive. Whenever possible, create it once and use it many times or try the &lt;code&gt;dateformat&quot;&quot;&lt;/code&gt; string macro. Using this macro creates the DateFormat object once at macro expansion time and reuses it later. see &lt;a href=&quot;#Dates.@dateformat_str&quot;&gt;&lt;code&gt;@dateformat_str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">DateFormat 객체를 만드는 데 많은 비용이 듭니다. 가능하면 한 번 작성하여 여러 번 사용하거나 &lt;code&gt;dateformat&quot;&quot;&lt;/code&gt; 문자열 매크로를 사용해보십시오 . 이 매크로를 사용하면 매크로 확장 시간에 DateFormat 객체를 한 번 만들고 나중에 재사용합니다. &lt;a href=&quot;#Dates.@dateformat_str&quot;&gt; &lt;code&gt;@dateformat_str&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee7646078f40a52ecc8cd5d5abbf897cedcf3493" translate="yes" xml:space="preserve">
          <source>Creating accidental &quot;copies&quot; of global state from another module, by referencing it directly instead of via its lookup path. For example, (in global scope):</source>
          <target state="translated">조회 경로 대신 직접 참조하여 다른 모듈에서 실수로 전역 상태의 &quot;복사본&quot;을 만듭니다. 예를 들어 (전역 범위에서) :</target>
        </trans-unit>
        <trans-unit id="be1f31994e9b5f386872c25814ba699f9d95f309" translate="yes" xml:space="preserve">
          <source>Creating events</source>
          <target state="translated">이벤트 만들기</target>
        </trans-unit>
        <trans-unit id="dfc1e3935e5f561b9a3fdb1b5f2655135605e4b0" translate="yes" xml:space="preserve">
          <source>Creating new generators</source>
          <target state="translated">새로운 발전기 생성</target>
        </trans-unit>
        <trans-unit id="6051151a12d03a26f4a70b65c2b0ad21b81b82d7" translate="yes" xml:space="preserve">
          <source>Creation of a &lt;code&gt;Ref&lt;/code&gt; to a value &lt;code&gt;x&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; is usually written &lt;code&gt;Ref(x)&lt;/code&gt;. Additionally, for creating interior pointers to containers (such as Array or Ptr), it can be written &lt;code&gt;Ref(a, i)&lt;/code&gt; for creating a reference to the &lt;code&gt;i&lt;/code&gt;-th element of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형의 &lt;code&gt;x&lt;/code&gt; 값 에 대한 &lt;code&gt;Ref&lt;/code&gt; 생성 은 보통 &lt;code&gt;Ref(x)&lt;/code&gt; 작성 됩니다. 또한 컨테이너 (예 : Array 또는 Ptr)에 대한 내부 포인터를 만들기 위해의 &lt;code&gt;i&lt;/code&gt; 번째 요소에 &lt;code&gt;a&lt;/code&gt; 참조를 만들기 위해 &lt;code&gt;Ref(a, i)&lt;/code&gt; 로 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8dc5259164d5812ceebcb04307a85959962c480d" translate="yes" xml:space="preserve">
          <source>Credential authentication is done in the following order (if supported):</source>
          <target state="translated">자격 증명 인증은 다음 순서로 수행됩니다 (지원되는 경우).</target>
        </trans-unit>
        <trans-unit id="d2942a33f8d919c5d366f7a8dd1e21bb97daf1e5" translate="yes" xml:space="preserve">
          <source>Credential that support only &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;password&lt;/code&gt; parameters</source>
          <target state="translated">&lt;code&gt;user&lt;/code&gt; 및 &lt;code&gt;password&lt;/code&gt; 매개 변수 만 지원하는 신임 정보</target>
        </trans-unit>
        <trans-unit id="69ed5aaf168648107a82ebf81dcad59625ab3893" translate="yes" xml:space="preserve">
          <source>Credit Card</source>
          <target state="translated">신용 카드</target>
        </trans-unit>
        <trans-unit id="746fdeaa0f4b76ffba7f25f558ab182a154045eb" translate="yes" xml:space="preserve">
          <source>Crescent Moon</source>
          <target state="translated">초승달</target>
        </trans-unit>
        <trans-unit id="9550e2815afbb248fddb5160d9632f01d171be80" translate="yes" xml:space="preserve">
          <source>Crocodile</source>
          <target state="translated">Crocodile</target>
        </trans-unit>
        <trans-unit id="1b84d42ee29ecbd7da313dc3edd661620b90adac" translate="yes" xml:space="preserve">
          <source>Cross Mark</source>
          <target state="translated">크로스 마크</target>
        </trans-unit>
        <trans-unit id="6439d5abed8064d49532208f798b24bad4eeaedb" translate="yes" xml:space="preserve">
          <source>Crossed Flags</source>
          <target state="translated">교차 플래그</target>
        </trans-unit>
        <trans-unit id="410494f2cf468cb98b4655657880ea42f72183c0" translate="yes" xml:space="preserve">
          <source>Crown</source>
          <target state="translated">Crown</target>
        </trans-unit>
        <trans-unit id="72f9cdf37b21797f93e24173fe1674094d502584" translate="yes" xml:space="preserve">
          <source>Crying Cat Face</source>
          <target state="translated">우는 고양이 얼굴</target>
        </trans-unit>
        <trans-unit id="aa2d3386215f67207e9681df8287caf675bf59f2" translate="yes" xml:space="preserve">
          <source>Crying Face</source>
          <target state="translated">우는 얼굴</target>
        </trans-unit>
        <trans-unit id="69723d1a814546ee7350009a712142c1bb170c13" translate="yes" xml:space="preserve">
          <source>Crystal Ball</source>
          <target state="translated">수정 구슬</target>
        </trans-unit>
        <trans-unit id="f6aabde44a92ffc82d2ba7b1190b078fefc14c2b" translate="yes" xml:space="preserve">
          <source>Cshort</source>
          <target state="translated">Cshort</target>
        </trans-unit>
        <trans-unit id="cad2cc015431eb8277af58253306038c83981e1b" translate="yes" xml:space="preserve">
          <source>Csize_t</source>
          <target state="translated">Csize_t</target>
        </trans-unit>
        <trans-unit id="4022d2757281621dd4126003c4abfb786032fbcf" translate="yes" xml:space="preserve">
          <source>Cssize_t</source>
          <target state="translated">Cssize_t</target>
        </trans-unit>
        <trans-unit id="dfe331758ccf94f376b9ef5ba3fc63195b90e80d" translate="yes" xml:space="preserve">
          <source>Cstring</source>
          <target state="translated">Cstring</target>
        </trans-unit>
        <trans-unit id="6b5a31718a4c0850b761d24de3b5aa88f92f5166" translate="yes" xml:space="preserve">
          <source>Cube Root</source>
          <target state="translated">큐브 루트</target>
        </trans-unit>
        <trans-unit id="e17b700fe47780159b8cf1ee414cd605ea55478e" translate="yes" xml:space="preserve">
          <source>Cuchar</source>
          <target state="translated">Cuchar</target>
        </trans-unit>
        <trans-unit id="19b94831c1a53e707deeb78349f682ad817cafbc" translate="yes" xml:space="preserve">
          <source>Cuint</source>
          <target state="translated">Cuint</target>
        </trans-unit>
        <trans-unit id="bfaf7a56354eba13b1561f6000228821b55aedb8" translate="yes" xml:space="preserve">
          <source>Cuintmax_t</source>
          <target state="translated">Cuintmax_t</target>
        </trans-unit>
        <trans-unit id="91908ced92ffd6336c39db3012de651ae9fc627b" translate="yes" xml:space="preserve">
          <source>Culong</source>
          <target state="translated">Culong</target>
        </trans-unit>
        <trans-unit id="9163538589351903cc7d613710b25bb603d2126c" translate="yes" xml:space="preserve">
          <source>Culonglong</source>
          <target state="translated">Culonglong</target>
        </trans-unit>
        <trans-unit id="6d8929c0661d5c816e4bd42ef00122216903020f" translate="yes" xml:space="preserve">
          <source>Cumulative operation &lt;code&gt;op&lt;/code&gt; along the dimension &lt;code&gt;dims&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt; (providing &lt;code&gt;dims&lt;/code&gt; is optional for vectors). An initial value &lt;code&gt;init&lt;/code&gt; may optionally be provided by a keyword argument. See also &lt;a href=&quot;#Base.accumulate!&quot;&gt;&lt;code&gt;accumulate!&lt;/code&gt;&lt;/a&gt; to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow). For common operations there are specialized variants of &lt;code&gt;accumulate&lt;/code&gt;, see: &lt;a href=&quot;#Base.cumsum&quot;&gt;&lt;code&gt;cumsum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Base.cumprod&quot;&gt;&lt;code&gt;cumprod&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">누적 연산 &lt;code&gt;op&lt;/code&gt; 차원 따라 &lt;code&gt;dims&lt;/code&gt; 의 (제공 &lt;code&gt;dims&lt;/code&gt; 벡터에 대해 선택적이다). 초기 값 &lt;code&gt;init&lt;/code&gt; 는 선택적으로 키워드 인수에 의해 제공 될 수 있습니다. &lt;a href=&quot;#Base.accumulate!&quot;&gt; &lt;code&gt;accumulate!&lt;/code&gt; &lt;/a&gt; 참조 ! 사전 할당 된 출력 어레이를 사용하여 성능과 출력의 정밀도를 제어합니다 (예 : 오버플로 방지). 일반적인 연산의 경우 &lt;code&gt;accumulate&lt;/code&gt; 특수 변형이 있습니다 ( &lt;a href=&quot;#Base.cumsum&quot;&gt; &lt;code&gt;cumsum&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#Base.cumprod&quot;&gt; &lt;code&gt;cumprod&lt;/code&gt; &lt;/a&gt; 참조). &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b9c0cc6e2cab956c3eeff9bdbdc51bf164e4d2a3" translate="yes" xml:space="preserve">
          <source>Cumulative operation &lt;code&gt;op&lt;/code&gt; on &lt;code&gt;A&lt;/code&gt; along the dimension &lt;code&gt;dims&lt;/code&gt;, storing the result in &lt;code&gt;B&lt;/code&gt;. Providing &lt;code&gt;dims&lt;/code&gt; is optional for vectors. If the keyword argument &lt;code&gt;init&lt;/code&gt; is given, its value is used to instantiate the accumulation. See also &lt;a href=&quot;#Base.accumulate&quot;&gt;&lt;code&gt;accumulate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">차원을 따라 &lt;code&gt;A&lt;/code&gt; 의 누적 연산 &lt;code&gt;op&lt;/code&gt; 가 &lt;code&gt;dims&lt;/code&gt; 결과가 &lt;code&gt;B&lt;/code&gt; 에 저장 됩니다. 제공 &lt;code&gt;dims&lt;/code&gt; 벡터에 대한 선택 사항입니다. 키워드 인수 &lt;code&gt;init&lt;/code&gt; 가 제공되면 해당 값이 누적을 인스턴스화하는 데 사용됩니다. 또한 &lt;a href=&quot;#Base.accumulate&quot;&gt; &lt;code&gt;accumulate&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4cc6a3d14a831428f91a6d92cb0ac7ceb0d411e1" translate="yes" xml:space="preserve">
          <source>Cumulative product along the dimension &lt;code&gt;dim&lt;/code&gt;. See also &lt;a href=&quot;#Base.cumprod!&quot;&gt;&lt;code&gt;cumprod!&lt;/code&gt;&lt;/a&gt; to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</source>
          <target state="translated">치수가 &lt;code&gt;dim&lt;/code&gt; 누적 제품 . &lt;a href=&quot;#Base.cumprod!&quot;&gt; &lt;code&gt;cumprod!&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 ! 사전 할당 된 출력 어레이를 사용하여 성능과 출력의 정밀도를 제어합니다 (예 : 오버플로 방지).</target>
        </trans-unit>
        <trans-unit id="c7379162addda6658acdc3f9dd25f46656740bb5" translate="yes" xml:space="preserve">
          <source>Cumulative product of &lt;code&gt;A&lt;/code&gt; along the dimension &lt;code&gt;dims&lt;/code&gt;, storing the result in &lt;code&gt;B&lt;/code&gt;. See also &lt;a href=&quot;#Base.cumprod&quot;&gt;&lt;code&gt;cumprod&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">차원을 따라 &lt;code&gt;A&lt;/code&gt; 의 누적 곱이 &lt;code&gt;dims&lt;/code&gt; 결과가 &lt;code&gt;B&lt;/code&gt; 에 저장 됩니다. &lt;a href=&quot;#Base.cumprod&quot;&gt; &lt;code&gt;cumprod&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="544dc176e0d81f953753079e21fc05f7a65a0a2b" translate="yes" xml:space="preserve">
          <source>Cumulative product of a vector &lt;code&gt;x&lt;/code&gt;, storing the result in &lt;code&gt;y&lt;/code&gt;. See also &lt;a href=&quot;#Base.cumprod&quot;&gt;&lt;code&gt;cumprod&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">벡터 &lt;code&gt;x&lt;/code&gt; 의 누적 곱으로 결과를 &lt;code&gt;y&lt;/code&gt; 에 저장합니다 . &lt;a href=&quot;#Base.cumprod&quot;&gt; &lt;code&gt;cumprod&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a7848eb8353d1872494fd8d4b74c519af24ce82" translate="yes" xml:space="preserve">
          <source>Cumulative product of a vector. See also &lt;a href=&quot;#Base.cumprod!&quot;&gt;&lt;code&gt;cumprod!&lt;/code&gt;&lt;/a&gt; to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</source>
          <target state="translated">벡터의 누적 곱. &lt;a href=&quot;#Base.cumprod!&quot;&gt; &lt;code&gt;cumprod!&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 ! 사전 할당 된 출력 어레이를 사용하여 성능과 출력의 정밀도를 제어합니다 (예 : 오버플로 방지).</target>
        </trans-unit>
        <trans-unit id="5e5d34284af8b1cd8280022818b948ecd056e9f9" translate="yes" xml:space="preserve">
          <source>Cumulative sum a vector. See also &lt;a href=&quot;#Base.cumsum!&quot;&gt;&lt;code&gt;cumsum!&lt;/code&gt;&lt;/a&gt; to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</source>
          <target state="translated">누적 합계 벡터 &lt;a href=&quot;#Base.cumsum!&quot;&gt; &lt;code&gt;cumsum!&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 ! 사전 할당 된 출력 어레이를 사용하여 성능과 출력의 정밀도를 제어합니다 (예 : 오버플로 방지).</target>
        </trans-unit>
        <trans-unit id="7ac42a41a170524b37f027a79ba758b538544698" translate="yes" xml:space="preserve">
          <source>Cumulative sum along the dimension &lt;code&gt;dims&lt;/code&gt;. See also &lt;a href=&quot;#Base.cumsum!&quot;&gt;&lt;code&gt;cumsum!&lt;/code&gt;&lt;/a&gt; to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</source>
          <target state="translated">차원을 따라 누적 된 합계가 &lt;code&gt;dims&lt;/code&gt; 됩니다. &lt;a href=&quot;#Base.cumsum!&quot;&gt; &lt;code&gt;cumsum!&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 ! 사전 할당 된 출력 어레이를 사용하여 성능과 출력의 정밀도를 제어합니다 (예 : 오버플로 방지).</target>
        </trans-unit>
        <trans-unit id="bff05572bc3057d02ece9df07eb6cbd41f496fa0" translate="yes" xml:space="preserve">
          <source>Cumulative sum of &lt;code&gt;A&lt;/code&gt; along the dimension &lt;code&gt;dims&lt;/code&gt;, storing the result in &lt;code&gt;B&lt;/code&gt;. See also &lt;a href=&quot;#Base.cumsum&quot;&gt;&lt;code&gt;cumsum&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">차원을 따라 &lt;code&gt;A&lt;/code&gt; 의 누적 합계가 &lt;code&gt;dims&lt;/code&gt; 되고 결과가 &lt;code&gt;B&lt;/code&gt; 에 저장 됩니다. &lt;a href=&quot;#Base.cumsum&quot;&gt; &lt;code&gt;cumsum&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="99912e940e13479c415ea623b516e8ffb7fa26f1" translate="yes" xml:space="preserve">
          <source>Curly Logical And</source>
          <target state="translated">곱슬 논리와</target>
        </trans-unit>
        <trans-unit id="be512ff433c9dff6b74aeeea37b129ec63571384" translate="yes" xml:space="preserve">
          <source>Curly Logical Or</source>
          <target state="translated">꼬부라 진 논리 또는</target>
        </trans-unit>
        <trans-unit id="e60553c7a9a9cdb72bb36b2a44dd16e0bda76d87" translate="yes" xml:space="preserve">
          <source>Curly Loop</source>
          <target state="translated">곱슬 루프</target>
        </trans-unit>
        <trans-unit id="bfaceaf351e410dbe378f231dc87232a28180ee2" translate="yes" xml:space="preserve">
          <source>Currency Exchange</source>
          <target state="translated">환전소</target>
        </trans-unit>
        <trans-unit id="fa21c13b708840eecec79752cb17fc8c7197e8b1" translate="yes" xml:space="preserve">
          <source>Currently Julia supports &lt;code&gt;Intel VTune&lt;/code&gt;, &lt;code&gt;OProfile&lt;/code&gt; and &lt;code&gt;perf&lt;/code&gt; as external profiling tools.</source>
          <target state="translated">현재 Julia는 &lt;code&gt;Intel VTune&lt;/code&gt; , &lt;code&gt;OProfile&lt;/code&gt; 및 &lt;code&gt;perf&lt;/code&gt; 를 외부 프로파일 링 도구로 지원합니다.</target>
        </trans-unit>
        <trans-unit id="5520b828a027b38a2df58c016c8a9e33a20b2c8f" translate="yes" xml:space="preserve">
          <source>Currently running, or able to run</source>
          <target state="translated">현재 실행 중이거나 실행할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="1cfdd1bbbc6e0ec95ba54ab86c4ed8984999f41c" translate="yes" xml:space="preserve">
          <source>Currently supported rounding modes are:</source>
          <target state="translated">현재 지원되는 반올림 모드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="18b6fb5cf9ba1d3a630cca350c13b1d2ae5247dd" translate="yes" xml:space="preserve">
          <source>Currently, all tasks in Julia are executed in a single OS thread co-operatively. Consequently, &lt;code&gt;asyncmap&lt;/code&gt; is beneficial only when the mapping function involves any I/O - disk, network, remote worker invocation, etc.</source>
          <target state="translated">현재 Julia의 모든 작업은 단일 OS 스레드에서 협력 적으로 실행됩니다. 결과적으로 &lt;code&gt;asyncmap&lt;/code&gt; 은 매핑 기능에 디스크, 네트워크, 원격 작업자 호출 등의 I / O가 포함 된 경우에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2b6dbadabdc5ac18fd3d193d17d49f9b69abe7e2" translate="yes" xml:space="preserve">
          <source>Currently, dynamically linking with the &lt;code&gt;libjulia&lt;/code&gt; shared library requires passing the &lt;code&gt;RTLD_GLOBAL&lt;/code&gt; option. In Python, this looks like:</source>
          <target state="translated">현재 &lt;code&gt;libjulia&lt;/code&gt; 공유 라이브러리 와 동적으로 연결 하려면 &lt;code&gt;RTLD_GLOBAL&lt;/code&gt; 옵션을 전달해야합니다 . 파이썬에서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b58fc7e8f3abd23e8c9cb124443e19466f0c18f" translate="yes" xml:space="preserve">
          <source>Currently, only the platform-default C calling convention is supported. This means that &lt;code&gt;@cfunction&lt;/code&gt;-generated pointers cannot be used in calls where WINAPI expects &lt;code&gt;stdcall&lt;/code&gt; function on 32-bit windows, but can be used on WIN64 (where &lt;code&gt;stdcall&lt;/code&gt; is unified with the C calling convention).</source>
          <target state="translated">현재 플랫폼 기본 C 호출 규칙 만 지원됩니다. 이것은 &lt;code&gt;@cfunction&lt;/code&gt; 생성 포인터는 WINAPI 가 32 비트 윈도우에서 &lt;code&gt;stdcall&lt;/code&gt; 함수를 기대하는 호출에는 사용할 수 없지만 WIN64에서는 사용할 수 있습니다 ( &lt;code&gt;stdcall&lt;/code&gt; 은 C 호출 규칙 으로 통합됨 ).</target>
        </trans-unit>
        <trans-unit id="f6c1e688c50876a4531f9d7cabb03fb248e6bfc9" translate="yes" xml:space="preserve">
          <source>Currently, sending a message between unconnected workers results in an error. This behaviour, as with the functionality and interface, should be considered experimental in nature and may change in future releases.</source>
          <target state="translated">현재 연결되지 않은 작업자간에 메시지를 보내면 오류가 발생합니다. 기능 및 인터페이스와 마찬가지로이 동작은 실험적으로 간주되어야하며 향후 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1fc8148f1ad416a0c1c4d0cd037e79c49a7d381" translate="yes" xml:space="preserve">
          <source>Curry And Rice</source>
          <target state="translated">카레라이스</target>
        </trans-unit>
        <trans-unit id="b85bdac6301eb2112a6814938a4d9e9df8648b71" translate="yes" xml:space="preserve">
          <source>Cushort</source>
          <target state="translated">Cushort</target>
        </trans-unit>
        <trans-unit id="8c54a5c7812a0f093c8cd0f91e33751d5c09251e" translate="yes" xml:space="preserve">
          <source>Custard</source>
          <target state="translated">Custard</target>
        </trans-unit>
        <trans-unit id="6f38ef54fa59e818dab5a77f3d2bbd3220e2cdca" translate="yes" xml:space="preserve">
          <source>Custom AbstractArray subtypes may choose which specific array type is best-suited to return for the given element type and dimensionality. If they do not specialize this method, the default is an &lt;code&gt;Array{element_type}(undef, dims...)&lt;/code&gt;.</source>
          <target state="translated">사용자 정의 AbstractArray 하위 유형은 주어진 요소 유형 및 차원에 대해 가장 적합한 특정 배열 유형을 선택할 수 있습니다. 이 메소드를 특수화하지 않은 경우 기본값은 &lt;code&gt;Array{element_type}(undef, dims...)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="097b8517391234e3c538e3449a9973ab8c13bc85" translate="yes" xml:space="preserve">
          <source>Custom implementation of &lt;code&gt;broadcast!&lt;/code&gt;, specializing on &lt;code&gt;DestStyle&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;broadcast!&lt;/code&gt; 맞춤형 구현 ! , &lt;code&gt;DestStyle&lt;/code&gt; 전문</target>
        </trans-unit>
        <trans-unit id="06904021bd513a29837f2a6d605afdc08f9d837c" translate="yes" xml:space="preserve">
          <source>Custom implementation of &lt;code&gt;broadcast!&lt;/code&gt;, specializing on &lt;code&gt;DestType&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;broadcast!&lt;/code&gt; 맞춤형 구현 ! , &lt;code&gt;DestType&lt;/code&gt; 전문</target>
        </trans-unit>
        <trans-unit id="5b22d816549f3f00985f636630289bedbe251e80" translate="yes" xml:space="preserve">
          <source>Custom implementation of &lt;code&gt;broadcast&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;broadcast&lt;/code&gt; 맞춤형 구현</target>
        </trans-unit>
        <trans-unit id="9da5ea657bda58f10cb83ead3ab61bfbc054ab56" translate="yes" xml:space="preserve">
          <source>Custom loggers should come with overloads for the functions described in the &lt;a href=&quot;#AbstractLogger-interface-1&quot;&gt;reference section&lt;/a&gt;.</source>
          <target state="translated">사용자 정의 로거에는 &lt;a href=&quot;#AbstractLogger-interface-1&quot;&gt;참조 섹션에&lt;/a&gt; 설명 된 기능에 대한 과부하가 제공되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="5f5be3cf33c9dad979d2a47c098609bed1e79588" translate="yes" xml:space="preserve">
          <source>Custom pretty-printing</source>
          <target state="translated">맞춤형 인쇄</target>
        </trans-unit>
        <trans-unit id="5750ccbb9a21360352689ce8553c6205a82553f4" translate="yes" xml:space="preserve">
          <source>Customization / Configuration</source>
          <target state="translated">주 문화 / 구성</target>
        </trans-unit>
        <trans-unit id="7081c24bd2fc87db9d99bce55e22acb378d5b91a" translate="yes" xml:space="preserve">
          <source>Customizing Colors</source>
          <target state="translated">색상 사용자 정의</target>
        </trans-unit>
        <trans-unit id="34880a9b35cda4c00b118d47d483351c6cc5ea2a" translate="yes" xml:space="preserve">
          <source>Customizing broadcasting</source>
          <target state="translated">방송 사용자 정의</target>
        </trans-unit>
        <trans-unit id="f9dfc91c94f0af58add748a7278bdfc60588cf5c" translate="yes" xml:space="preserve">
          <source>Customizing keybindings</source>
          <target state="translated">키 바인딩 사용자 정의</target>
        </trans-unit>
        <trans-unit id="22c43c80b6acba6c8e988834746cb3dad10dc13a" translate="yes" xml:space="preserve">
          <source>Customs</source>
          <target state="translated">Customs</target>
        </trans-unit>
        <trans-unit id="9cfe6bc8642611e40313cf0cc79620f14dffbbc6" translate="yes" xml:space="preserve">
          <source>Cwchar_t</source>
          <target state="translated">Cwchar_t</target>
        </trans-unit>
        <trans-unit id="d3862adb8c043e056018bc4b8a261f178c58e987" translate="yes" xml:space="preserve">
          <source>Cwstring</source>
          <target state="translated">Cwstring</target>
        </trans-unit>
        <trans-unit id="33ec23db96b16085821b404cc8c2b54fbfda44f5" translate="yes" xml:space="preserve">
          <source>Cyclone</source>
          <target state="translated">Cyclone</target>
        </trans-unit>
        <trans-unit id="216ff17303fbb44375e7a618a8708d4627fec28a" translate="yes" xml:space="preserve">
          <source>DEPOT_PATH</source>
          <target state="translated">DEPOT_PATH</target>
        </trans-unit>
        <trans-unit id="83dc75e20dcbf622a6cf33144a983d98f677b3aa" translate="yes" xml:space="preserve">
          <source>DI</source>
          <target state="translated">DI</target>
        </trans-unit>
        <trans-unit id="50fb8228b3b9fa5b2166d5730e6bbd9d4de9cae6" translate="yes" xml:space="preserve">
          <source>DL_LOAD_PATH</source>
          <target state="translated">DL_LOAD_PATH</target>
        </trans-unit>
        <trans-unit id="8e0e5961c9dc8c314c3d9bec3aebc5d5dceab1d6" translate="yes" xml:space="preserve">
          <source>Dagger</source>
          <target state="translated">Dagger</target>
        </trans-unit>
        <trans-unit id="d588da27f7b558f43e86a7f0556da786a0f5702f" translate="yes" xml:space="preserve">
          <source>Dalet Symbol / Fourth Transfinite Cardinal</source>
          <target state="translated">대리 기호 / 네 번째 영원한 추기경</target>
        </trans-unit>
        <trans-unit id="bbd3fe91db28cc6eaba879d637ff2415c19eaed3" translate="yes" xml:space="preserve">
          <source>Dancer</source>
          <target state="translated">Dancer</target>
        </trans-unit>
        <trans-unit id="4e457c357290fffb26efe10315ee86c05aa550ed" translate="yes" xml:space="preserve">
          <source>Dango</source>
          <target state="translated">Dango</target>
        </trans-unit>
        <trans-unit id="3f48fb7aab68e6aa82c811a8bdd3137296109c01" translate="yes" xml:space="preserve">
          <source>Dark Shade</source>
          <target state="translated">어두운 그늘</target>
        </trans-unit>
        <trans-unit id="ec3e5d3b5f51290af48556e1a22232b6c075e886" translate="yes" xml:space="preserve">
          <source>Dash Symbol</source>
          <target state="translated">대시 기호</target>
        </trans-unit>
        <trans-unit id="d1ee13b5a357f064705d5d2ee301ca24cec2d711" translate="yes" xml:space="preserve">
          <source>Data Formats</source>
          <target state="translated">데이터 형식</target>
        </trans-unit>
        <trans-unit id="b9a20ab226cf235e7e270845c1fed39a764c870e" translate="yes" xml:space="preserve">
          <source>Data Movement</source>
          <target state="translated">데이터 이동</target>
        </trans-unit>
        <trans-unit id="e5669bbf5a381f1b45f515386259ddfc4dd6e523" translate="yes" xml:space="preserve">
          <source>Data is necessarily copied over to the remote node for execution. This is the case for both remotecalls and when data is stored to a&lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; / &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; on a different node. As expected, this results in a copy of the serialized objects on the remote node. However, when the destination node is the local node, i.e. the calling process id is the same as the remote node id, it is executed as a local call. It is usually(not always) executed in a different task - but there is no serialization/deserialization of data. Consequently, the call refers to the same object instances as passed - no copies are created. This behavior is highlighted below:</source>
          <target state="translated">데이터는 실행을 위해 반드시 원격 노드로 복사됩니다. 이것은 원격 호출과 데이터가 다른 노드 의 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 에 저장된 경우 모두에 해당됩니다 . 예상 한대로 원격 노드에서 직렬화 된 오브젝트의 사본이 생성됩니다. 그러나 대상 노드가 로컬 노드 인 경우, 즉 호출 프로세스 ID가 원격 노드 ID와 동일하면 로컬 호출로 실행됩니다. 일반적으로 다른 작업에서 (항상 그런 것은 아님) 실행되지만 데이터의 직렬화 / 직렬화 해제는 없습니다. 결과적으로, 호출은 전달 된 것과 동일한 오브젝트 인스턴스를 참조하며 사본이 작성되지 않습니다. 이 동작은 아래에 강조 표시되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="842b7b5d71896a41ecd92997ec80b1df5243c81e" translate="yes" xml:space="preserve">
          <source>Dates</source>
          <target state="translated">Dates</target>
        </trans-unit>
        <trans-unit id="36896b6958dbc42b827d9983351001153fb900f9" translate="yes" xml:space="preserve">
          <source>Dates Functions</source>
          <target state="translated">날짜 기능</target>
        </trans-unit>
        <trans-unit id="87a830783aa282885319d8bb8573974c6e9ce862" translate="yes" xml:space="preserve">
          <source>Dates and Time Types</source>
          <target state="translated">날짜 및 시간 유형</target>
        </trans-unit>
        <trans-unit id="1c3699dfa0f90796e26bab33925787fed0c43f91" translate="yes" xml:space="preserve">
          <source>Dates.Date</source>
          <target state="translated">Dates.Date</target>
        </trans-unit>
        <trans-unit id="32f52acc781735072821be18d470cd0e9e957322" translate="yes" xml:space="preserve">
          <source>Dates.Time</source>
          <target state="translated">Dates.Time</target>
        </trans-unit>
        <trans-unit id="cfc71f3899e9e62bb3cb32d518c2500090d68e5a" translate="yes" xml:space="preserve">
          <source>Days of the Week:</source>
          <target state="translated">요일 :</target>
        </trans-unit>
        <trans-unit id="75abb16100a8a64fe67d2b115039ae07750abe57" translate="yes" xml:space="preserve">
          <source>De-activate the region (i.e. make it not highlighted)</source>
          <target state="translated">영역을 비활성화합니다 (예 : 강조 표시하지 않음)</target>
        </trans-unit>
        <trans-unit id="cf4ca495e016d85d54e9e0c6c172007a72b770a7" translate="yes" xml:space="preserve">
          <source>Debugging and profiling</source>
          <target state="translated">디버깅 및 프로파일 링</target>
        </trans-unit>
        <trans-unit id="86110bf8d0223821e4a3030b465ecd127fd05ca4" translate="yes" xml:space="preserve">
          <source>Decide whether the concept in question will be written as &lt;code&gt;MyType&lt;/code&gt; or &lt;code&gt;MyType()&lt;/code&gt;, and stick to it.</source>
          <target state="translated">해당 개념이 &lt;code&gt;MyType&lt;/code&gt; 또는 &lt;code&gt;MyType()&lt;/code&gt; 로 작성 될지 결정하고이를 준수 하십시오.</target>
        </trans-unit>
        <trans-unit id="f2225e92be396a4c31e9028b01af2d8105bf4719" translate="yes" xml:space="preserve">
          <source>Decides which &lt;code&gt;BroadcastStyle&lt;/code&gt; to use for any number of value arguments. Uses &lt;a href=&quot;#Base.Broadcast.BroadcastStyle&quot;&gt;&lt;code&gt;BroadcastStyle&lt;/code&gt;&lt;/a&gt; to get the style for each argument, and uses &lt;a href=&quot;#Base.Broadcast.result_style&quot;&gt;&lt;code&gt;result_style&lt;/code&gt;&lt;/a&gt; to combine styles.</source>
          <target state="translated">여러 값 인수에 사용할 &lt;code&gt;BroadcastStyle&lt;/code&gt; 을 결정 합니다. &lt;a href=&quot;#Base.Broadcast.BroadcastStyle&quot;&gt; &lt;code&gt;BroadcastStyle&lt;/code&gt; &lt;/a&gt; 을 사용 하여 각 인수의 스타일을 가져 &lt;a href=&quot;#Base.Broadcast.result_style&quot;&gt; &lt;code&gt;result_style&lt;/code&gt; &lt;/a&gt; 을 사용하여 스타일을 결합합니다.</target>
        </trans-unit>
        <trans-unit id="56705d4190361578370161ee548e7b8b5b6f2df3" translate="yes" xml:space="preserve">
          <source>Deciduous Tree</source>
          <target state="translated">낙엽수</target>
        </trans-unit>
        <trans-unit id="187bdf507820ae854f975416a37658ae06b738ce" translate="yes" xml:space="preserve">
          <source>Declaration of the indices of &lt;code&gt;x&lt;/code&gt;, as per &lt;code&gt;axes(x)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;axes(x)&lt;/code&gt; 따라 &lt;code&gt;x&lt;/code&gt; 의 인덱스 선언 .</target>
        </trans-unit>
        <trans-unit id="c678ba8568226163ef571fe8bacb3339af3cbb35" translate="yes" xml:space="preserve">
          <source>Declarations can also be attached to function definitions:</source>
          <target state="translated">함수 정의에 선언을 첨부 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2c99269d5b17a5b20dd25e68e9877e78c5ffa82" translate="yes" xml:space="preserve">
          <source>Declare the type of &lt;code&gt;x&lt;/code&gt;: &lt;code&gt;x::Float64 = 1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; : &lt;code&gt;x::Float64 = 1&lt;/code&gt; 의 유형을 선언하십시오</target>
        </trans-unit>
        <trans-unit id="eb67cf4c6f0459524901230203e023a095836c6e" translate="yes" xml:space="preserve">
          <source>Declared Types</source>
          <target state="translated">선언 된 유형</target>
        </trans-unit>
        <trans-unit id="2c66e9dea182f1b50d49414e9afb7bd032249fee" translate="yes" xml:space="preserve">
          <source>Declared structure</source>
          <target state="translated">선언 된 구조</target>
        </trans-unit>
        <trans-unit id="88befac5b75ff9c9169815848fea3c4891d14f29" translate="yes" xml:space="preserve">
          <source>Decode the base64-encoded &lt;code&gt;string&lt;/code&gt; and returns a &lt;code&gt;Vector{UInt8}&lt;/code&gt; of the decoded bytes.</source>
          <target state="translated">base64로 인코딩 된 &lt;code&gt;string&lt;/code&gt; 디코딩하고 디코딩 된 바이트의 &lt;code&gt;Vector{UInt8}&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="808d7dca8a74d84af27a2d6602c3d786de45fe1e" translate="yes" xml:space="preserve">
          <source>Default</source>
          <target state="translated">Default</target>
        </trans-unit>
        <trans-unit id="15ac2aa0f274814677f21a2664636a6e0c15f7c8" translate="yes" xml:space="preserve">
          <source>Default is to auto-detect the proxy type.</source>
          <target state="translated">기본값은 프록시 유형을 자동 감지하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="79c7b4e844bd36e0f1c0ccc6518eefeba8042556" translate="yes" xml:space="preserve">
          <source>Default top-level definitions and bare modules</source>
          <target state="translated">기본 최상위 정의 및 베어 모듈</target>
        </trans-unit>
        <trans-unit id="dcdff78b360ed6cd29323d1507c31f96970d8e0b" translate="yes" xml:space="preserve">
          <source>Define a region &lt;code&gt;R&lt;/code&gt; spanning a multidimensional rectangular range of integer indices. These are most commonly encountered in the context of iteration, where &lt;code&gt;for I in R ... end&lt;/code&gt; will return &lt;a href=&quot;#Base.IteratorsMD.CartesianIndex&quot;&gt;&lt;code&gt;CartesianIndex&lt;/code&gt;&lt;/a&gt; indices &lt;code&gt;I&lt;/code&gt; equivalent to the nested loops</source>
          <target state="translated">정수 인덱스의 다차원 직사각형 범위에 걸쳐 있는 영역 &lt;code&gt;R&lt;/code&gt; 을 정의하십시오 . 이들은 가장 일반적으로 반복의 맥락에서 발생하는 &lt;code&gt;for I in R ... end&lt;/code&gt; 반환됩니다 &lt;a href=&quot;#Base.IteratorsMD.CartesianIndex&quot;&gt; &lt;code&gt;CartesianIndex&lt;/code&gt; 의&lt;/a&gt; 인덱스를 &lt;code&gt;I&lt;/code&gt; 중첩 된 루프에 해당</target>
        </trans-unit>
        <trans-unit id="a0e4dd75ee5019eb13db03c029c41e75b3aaa5e3" translate="yes" xml:space="preserve">
          <source>Define an &lt;code&gt;AbstractUnitRange&lt;/code&gt; that behaves like &lt;code&gt;1:n&lt;/code&gt;, with the added distinction that the lower limit is guaranteed (by the type system) to be 1.</source>
          <target state="translated">(타입 시스템에 의해) 하한이 1로 보장된다는 구별이 추가되어 &lt;code&gt;1:n&lt;/code&gt; 과 같이 동작 하는 &lt;code&gt;AbstractUnitRange&lt;/code&gt; 를 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="588b3c159cb4712c0152a8a53daf119df81aa7ba" translate="yes" xml:space="preserve">
          <source>Define other operations that use &lt;code&gt;f(x)&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;f(x)&lt;/code&gt; 를 사용하는 다른 연산을 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="d2947f0706fff8e7126e6357ddb46ba0dbd29fa6" translate="yes" xml:space="preserve">
          <source>Defining Methods</source>
          <target state="translated">정의 방법</target>
        </trans-unit>
        <trans-unit id="0c22d4ea82e4f1b312acd9a3994522966c35371b" translate="yes" xml:space="preserve">
          <source>Defining New Conversions</source>
          <target state="translated">새로운 전환 정의</target>
        </trans-unit>
        <trans-unit id="4e6963b3110a46628b4c6d35d33fe7d6e7bd71d0" translate="yes" xml:space="preserve">
          <source>Defining Promotion Rules</source>
          <target state="translated">프로모션 규칙 정의</target>
        </trans-unit>
        <trans-unit id="ecece75a8f8a880522732b9cd0177884625f667e" translate="yes" xml:space="preserve">
          <source>Defining a basic &lt;code&gt;AbstractTestSet&lt;/code&gt; subtype might look like:</source>
          <target state="translated">기본 &lt;code&gt;AbstractTestSet&lt;/code&gt; 하위 유형을 정의하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="15225baac48fc3d689cb2b0f74b936eff4339ff7" translate="yes" xml:space="preserve">
          <source>Definitions</source>
          <target state="translated">Definitions</target>
        </trans-unit>
        <trans-unit id="38721ea3df19d3ffaf5150dd675b640530a0546d" translate="yes" xml:space="preserve">
          <source>Degree Sign</source>
          <target state="translated">학위 표시</target>
        </trans-unit>
        <trans-unit id="1a4e3b4bb8e1094eb26bfa7cb8783cdea32dfe30" translate="yes" xml:space="preserve">
          <source>Delete and return the mapping for &lt;code&gt;key&lt;/code&gt; if it exists in &lt;code&gt;collection&lt;/code&gt;, otherwise return &lt;code&gt;default&lt;/code&gt;, or throw an error if &lt;code&gt;default&lt;/code&gt; is not specified.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 대한 맵핑 이 &lt;code&gt;collection&lt;/code&gt; 에 있으면 삭제하고 리턴하십시오 . 그렇지 않으면 &lt;code&gt;default&lt;/code&gt; 를 리턴 하거나 &lt;code&gt;default&lt;/code&gt; 가 지정되지 않은 경우 오류를 발생 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="d98877669570739f73775c66eb9704f2ba71ab77" translate="yes" xml:space="preserve">
          <source>Delete previous text up to the nearest whitespace</source>
          <target state="translated">가장 가까운 공백까지 이전 텍스트 삭제</target>
        </trans-unit>
        <trans-unit id="80e6b34017de84d227a51e468428b830d3abce81" translate="yes" xml:space="preserve">
          <source>Delete the branch pointed to by &lt;code&gt;branch&lt;/code&gt;.</source>
          <target state="translated">가리키는 분기 삭제 &lt;code&gt;branch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e26e2e065a1fcbeb86d9a12f9c736cd9f6b54e6" translate="yes" xml:space="preserve">
          <source>Delete the file, link, or empty directory at the given path. If &lt;code&gt;force=true&lt;/code&gt; is passed, a non-existing path is not treated as error. If &lt;code&gt;recursive=true&lt;/code&gt; is passed and the path is a directory, then all contents are removed recursively.</source>
          <target state="translated">주어진 경로에서 파일, 링크 또는 빈 디렉토리를 삭제하십시오. 경우 &lt;code&gt;force=true&lt;/code&gt; 전달, 존재하지 않는 경로 오류로 간주되지 않습니다. 경우 &lt;code&gt;recursive=true&lt;/code&gt; 통과 경로가 디렉토리입니다, 모든 내용이 재귀 적으로 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="e988febce46cb76c97d9a9f098a2791248f65170" translate="yes" xml:space="preserve">
          <source>Delete the mapping for the given key in a collection, and return the collection.</source>
          <target state="translated">컬렉션에서 주어진 키에 대한 매핑을 삭제하고 컬렉션을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="48c4aef19d86e28665c31c2a1fdfed6ed55b27f0" translate="yes" xml:space="preserve">
          <source>Delete the previous character, or the whole region when it's active</source>
          <target state="translated">이전 캐릭터 또는 활성화 된 전체 지역을 삭제합니다</target>
        </trans-unit>
        <trans-unit id="3cff3520dd83f96bd232342b44e0add55d0baab6" translate="yes" xml:space="preserve">
          <source>Delete the previous word</source>
          <target state="translated">이전 단어를 삭제</target>
        </trans-unit>
        <trans-unit id="91ffc8de7f40ffc066d84c7f26109c9e03c6f805" translate="yes" xml:space="preserve">
          <source>Delete, &lt;code&gt;^D&lt;/code&gt;</source>
          <target state="translated">삭제, &lt;code&gt;^D&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53e4d82d4995bf30ba309b0818053aa7081c7519" translate="yes" xml:space="preserve">
          <source>Delimited Files</source>
          <target state="translated">구분 된 파일</target>
        </trans-unit>
        <trans-unit id="cec2c59e089d9f58238ee95327e2b286e786faed" translate="yes" xml:space="preserve">
          <source>Delimited slots are marked by specifying the delimiter the parser should expect between two subsequent periods; so &lt;code&gt;&quot;y-m-d&quot;&lt;/code&gt; lets the parser know that between the first and second slots in a date string like &lt;code&gt;&quot;2014-07-16&quot;&lt;/code&gt;, it should find the &lt;code&gt;-&lt;/code&gt; character. The &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, and &lt;code&gt;d&lt;/code&gt; characters let the parser know which periods to parse in each slot.</source>
          <target state="translated">구분 된 슬롯은 구문 분석기가 두 개의 후속 기간 사이에 예상 할 구분자를 지정하여 표시됩니다. 따라서 &lt;code&gt;&quot;y-m-d&quot;&lt;/code&gt; 는 파서가 &lt;code&gt;&quot;2014-07-16&quot;&lt;/code&gt; 과 같은 날짜 문자열의 첫 번째 슬롯과 두 번째 슬롯 사이 에서 &lt;code&gt;-&lt;/code&gt; 문자를 찾아야 함을 알려 줍니다. &lt;code&gt;y&lt;/code&gt; , &lt;code&gt;m&lt;/code&gt; , 및 &lt;code&gt;d&lt;/code&gt; 문자 기간은 각 슬롯에서 파싱하는 파서 알고하자.</target>
        </trans-unit>
        <trans-unit id="51d69934332b769741cf61b5b730a2cdba3eed7c" translate="yes" xml:space="preserve">
          <source>DelimitedFiles.readdlm()</source>
          <target state="translated">DelimitedFiles.readdlm()</target>
        </trans-unit>
        <trans-unit id="480a3033b9d53578f2568ffa94ff98e43e3f7ea6" translate="yes" xml:space="preserve">
          <source>DelimitedFiles.writedlm()</source>
          <target state="translated">DelimitedFiles.writedlm()</target>
        </trans-unit>
        <trans-unit id="895b5ccc82a877146bc08599ac54b9af5f081f65" translate="yes" xml:space="preserve">
          <source>Delivery Truck</source>
          <target state="translated">배달 트럭</target>
        </trans-unit>
        <trans-unit id="fdff1d4ceb07d550335cfb224cd4c93c1413a0fa" translate="yes" xml:space="preserve">
          <source>Delta Equal To</source>
          <target state="translated">델타 같음</target>
        </trans-unit>
        <trans-unit id="d876cbfe74b813ac207d0e9f78546f7688d9b032" translate="yes" xml:space="preserve">
          <source>Denominator of the rational representation of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 합리적인 표현의 분모입니다 .</target>
        </trans-unit>
        <trans-unit id="e9501853c3d6adc0961aff7ed40ae9c83e53f278" translate="yes" xml:space="preserve">
          <source>Dense</source>
          <target state="translated">Dense</target>
        </trans-unit>
        <trans-unit id="bff84cd5bdedc08353d7da69b84b0ab8978ba47b" translate="yes" xml:space="preserve">
          <source>Dense Symmetric/Hermitian</source>
          <target state="translated">고밀도 대칭 / 허 르미 티안</target>
        </trans-unit>
        <trans-unit id="36f2b0b5e58f351883eb10f69aec3caeecfa3d2e" translate="yes" xml:space="preserve">
          <source>DenseMatrix</source>
          <target state="translated">DenseMatrix</target>
        </trans-unit>
        <trans-unit id="eccc3b309862b32e23f021b5f67ce45d957d12b0" translate="yes" xml:space="preserve">
          <source>DenseVecOrMat</source>
          <target state="translated">DenseVecOrMat</target>
        </trans-unit>
        <trans-unit id="0359b22dae8b7e9c2a1f55727a94cf7163a84465" translate="yes" xml:space="preserve">
          <source>DenseVector</source>
          <target state="translated">DenseVector</target>
        </trans-unit>
        <trans-unit id="642cae737f8e008435129e4bb7c0bf0176fb92da" translate="yes" xml:space="preserve">
          <source>Department Store</source>
          <target state="translated">백화점</target>
        </trans-unit>
        <trans-unit id="b943c9c136349bfa294ef95babe063e21021459d" translate="yes" xml:space="preserve">
          <source>Depending on compile-time side-effects persisting through load-time. Example include: modifying arrays or other variables in other Julia modules; maintaining handles to open files or devices; storing pointers to other system resources (including memory);</source>
          <target state="translated">로드 타임을 통해 지속되는 컴파일 타임 부작용에 따라. 다른 Julia 모듈에서 배열 또는 기타 변수 수정; 파일 또는 장치를 열기위한 핸들 유지; 다른 시스템 리소스 (메모리 포함)에 대한 포인터를 저장하는 단계;</target>
        </trans-unit>
        <trans-unit id="d379477708d634a0aa71159aab76fc85b03d4ea8" translate="yes" xml:space="preserve">
          <source>Depending on the tool you choose, compile with &lt;code&gt;USE_INTEL_JITEVENTS&lt;/code&gt;, &lt;code&gt;USE_OPROFILE_JITEVENTS&lt;/code&gt; and &lt;code&gt;USE_PERF_JITEVENTS&lt;/code&gt; set to 1 in &lt;code&gt;Make.user&lt;/code&gt;. Multiple flags are supported.</source>
          <target state="translated">선택한 도구에 따라 컴파일 &lt;code&gt;USE_INTEL_JITEVENTS&lt;/code&gt; , &lt;code&gt;USE_OPROFILE_JITEVENTS&lt;/code&gt; 및 &lt;code&gt;USE_PERF_JITEVENTS&lt;/code&gt; 1로 설정 &lt;code&gt;Make.user&lt;/code&gt; . 여러 플래그가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="242a5524acc8713087f708386c9c794f5f3931bd" translate="yes" xml:space="preserve">
          <source>Deprecated functions are removed after the subsequent release. For example, functions marked as deprecated in the 0.1 release will not be available starting with the 0.2 release.</source>
          <target state="translated">더 이상 사용되지 않는 기능은 후속 릴리스 후에 제거됩니다. 예를 들어, 0.1 릴리스에서 더 이상 사용되지 않는 것으로 표시된 기능은 0.2 릴리스부터 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="06a4e84adec4fa6378a8c2435f1ea8fcbef66398" translate="yes" xml:space="preserve">
          <source>Dequeues</source>
          <target state="translated">Dequeues</target>
        </trans-unit>
        <trans-unit id="c65645dadaf75772aa2463e4bea5df65e0668b6a" translate="yes" xml:space="preserve">
          <source>Describes a single instruction/operation to be performed during the rebase. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_rebase_operation_t&quot;&gt;&lt;code&gt;git_rebase_operation&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">리베이스 중에 수행 할 단일 명령 / 작업을 설명합니다. &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_rebase_operation_t&quot;&gt; &lt;code&gt;git_rebase_operation&lt;/code&gt; &lt;/a&gt; 구조체와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="ee984d55c69fd75c93dd767a8b9c6db89c37f979" translate="yes" xml:space="preserve">
          <source>Describing Julia in the lingo of &lt;a href=&quot;https://en.wikipedia.org/wiki/Type_system&quot;&gt;type systems&lt;/a&gt;, it is: dynamic, nominative and parametric. Generic types can be parameterized, and the hierarchical relationships between types are &lt;a href=&quot;https://en.wikipedia.org/wiki/Nominal_type_system&quot;&gt;explicitly declared&lt;/a&gt;, rather than &lt;a href=&quot;https://en.wikipedia.org/wiki/Structural_type_system&quot;&gt;implied by compatible structure&lt;/a&gt;. One particularly distinctive feature of Julia's type system is that concrete types may not subtype each other: all concrete types are final and may only have abstract types as their supertypes. While this might at first seem unduly restrictive, it has many beneficial consequences with surprisingly few drawbacks. It turns out that being able to inherit behavior is much more important than being able to inherit structure, and inheriting both causes significant difficulties in traditional object-oriented languages. Other high-level aspects of Julia's type system that should be mentioned up front are:</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Type_system&quot;&gt;유형 시스템&lt;/a&gt; 의 용어로 Julia를 설명하면 동적, 명목 및 매개 변수입니다. 제네릭 형식을 매개 변수화 할 수 있으며 형식 간의 계층 관계는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Structural_type_system&quot;&gt;호환 가능한 구조로 암시&lt;/a&gt; 되지 않고 &lt;a href=&quot;https://en.wikipedia.org/wiki/Nominal_type_system&quot;&gt;명시 적으로 선언 &lt;/a&gt;됩니다.. Julia의 유형 시스템에서 특히 두드러진 특징 중 하나는 콘크리트 유형이 서로 하위 유형을 지정할 수 없다는 것입니다. 모든 콘크리트 유형은 최종 유형이며 수퍼 유형으로 추상 유형 만 가질 수 있습니다. 처음에는 이것이 지나치게 제한적으로 보일 수 있지만 놀랍게도 몇 가지 단점이 있지만 많은 이점이 있습니다. 구조를 물려받는 것보다 행동을 물려받을 수있는 것이 훨씬 중요하며, 두 가지를 물려받는 것은 전통적인 객체 지향 언어에서 큰 어려움을 초래합니다. 미리 언급해야 할 Julia 유형 시스템의 다른 높은 수준의 측면은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="e39db8493c1fda362ba77503fa8b88b4e7237b8d" translate="yes" xml:space="preserve">
          <source>Description of changes to one entry. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_diff_delta&quot;&gt;&lt;code&gt;git_diff_delta&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">한 항목의 변경 사항에 대한 설명. &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_diff_delta&quot;&gt; &lt;code&gt;git_diff_delta&lt;/code&gt; &lt;/a&gt; 구조체와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="988fedca2d77cb7c769954515d3380c033f9d5e4" translate="yes" xml:space="preserve">
          <source>Description of one side of a delta. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_diff_file&quot;&gt;&lt;code&gt;git_diff_file&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">델타의 한쪽에 대한 설명입니다. &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_diff_file&quot;&gt; &lt;code&gt;git_diff_file&lt;/code&gt; &lt;/a&gt; 구조체와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="be730a71419945587f16a616135a86d24c6b00df" translate="yes" xml:space="preserve">
          <source>Design Patterns with Parametric Methods</source>
          <target state="translated">파라 메트릭 방법을 사용한 디자인 패턴</target>
        </trans-unit>
        <trans-unit id="3c0874aa1f2c5e541e93555aa18c23a58e93cf08" translate="yes" xml:space="preserve">
          <source>Designed for parallelism and distributed computation</source>
          <target state="translated">병렬 처리 및 분산 계산을 위해 설계</target>
        </trans-unit>
        <trans-unit id="3c1ac6acb43140e473d6bbf32a76f1a42622c490" translate="yes" xml:space="preserve">
          <source>Despite these limitations, sampling profilers have substantial strengths:</source>
          <target state="translated">이러한 제한에도 불구하고 샘플링 프로파일 러는 다음과 같은 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cff394bb90e68ac928062ab33d7e95c09551667" translate="yes" xml:space="preserve">
          <source>Details can be found in the &lt;a href=&quot;#stdlib-sparse-arrays-1&quot;&gt;Sparse Vectors and Matrices&lt;/a&gt; section of the standard library reference.</source>
          <target state="translated">자세한 내용은 표준 라이브러리 참조 의 &lt;a href=&quot;#stdlib-sparse-arrays-1&quot;&gt;스파 스 벡터 및 행렬&lt;/a&gt; 섹션 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9abaafa688cd076cbfe0ab170aa5929c003cedc" translate="yes" xml:space="preserve">
          <source>Determine if the branch containing &lt;code&gt;ref&lt;/code&gt; has a specified upstream branch.</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; 를 포함하는 브랜치 에 지정된 업스트림 브랜치가 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="fcf969dbd3b4cd23f5e44c248c8256fc35e9a78a" translate="yes" xml:space="preserve">
          <source>Determine if the branch specified by &lt;code&gt;branch_name&lt;/code&gt; exists in the repository &lt;code&gt;repo&lt;/code&gt;. If &lt;code&gt;remote&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;repo&lt;/code&gt; is assumed to be a remote git repository. Otherwise, it is part of the local filesystem.</source>
          <target state="translated">&lt;code&gt;branch_name&lt;/code&gt; 으로 지정된 브랜치 가 저장소 &lt;code&gt;repo&lt;/code&gt; 에 존재 하는지 판별하십시오 . 경우 &lt;code&gt;remote&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;repo&lt;/code&gt; 원격 자식 저장소로 간주됩니다. 그렇지 않으면 로컬 파일 시스템의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="34ac1a921df971b54418bdc7fa30b45ba64aa009" translate="yes" xml:space="preserve">
          <source>Determine the declared type of a field (specified by name or index) in a composite DataType &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">복합 DataType &lt;code&gt;T&lt;/code&gt; 에서 필드의 선언 된 유형 (이름 또는 색인으로 지정)을 결정하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e74d71e6265c1a4d5bccc1bce9622cb2d709544" translate="yes" xml:space="preserve">
          <source>Determine the module containing a given definition of a generic function.</source>
          <target state="translated">주어진 일반 함수 정의가 포함 된 모듈을 결정하십시오.</target>
        </trans-unit>
        <trans-unit id="38ae7ce3fa55379d3288d064511593e9779d54ab" translate="yes" xml:space="preserve">
          <source>Determine the module containing the (first) definition of a generic function.</source>
          <target state="translated">일반 함수의 (첫 번째) 정의를 포함하는 모듈을 결정하십시오.</target>
        </trans-unit>
        <trans-unit id="ea6f8abc3832bcad08cf551e8f3ae7259442f202" translate="yes" xml:space="preserve">
          <source>Determine the module containing the definition of a (potentially &lt;code&gt;UnionAll&lt;/code&gt;-wrapped) &lt;code&gt;DataType&lt;/code&gt;.</source>
          <target state="translated">(잠재적으로 &lt;code&gt;UnionAll&lt;/code&gt; - wrapped) &lt;code&gt;DataType&lt;/code&gt; 의 정의를 포함하는 모듈을 결정하십시오 .</target>
        </trans-unit>
        <trans-unit id="fb142e504214629cb5fc814202b65406eb9c20c0" translate="yes" xml:space="preserve">
          <source>Determine the result axes for broadcasting across all values in &lt;code&gt;As&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;As&lt;/code&gt; 의 모든 값에서 브로드 캐스팅 할 결과 축을 결정하십시오 .</target>
        </trans-unit>
        <trans-unit id="410d903111782ec28acaf29cfa71423107052d65" translate="yes" xml:space="preserve">
          <source>Determine the type of the elements generated by iterating a collection of the given &lt;code&gt;type&lt;/code&gt;. For dictionary types, this will be a &lt;code&gt;Pair{KeyType,ValType}&lt;/code&gt;. The definition &lt;code&gt;eltype(x) = eltype(typeof(x))&lt;/code&gt; is provided for convenience so that instances can be passed instead of types. However the form that accepts a type argument should be defined for new types.</source>
          <target state="translated">주어진 &lt;code&gt;type&lt;/code&gt; 의 컬렉션을 반복하여 생성 된 요소의 형식을 결정합니다 . 사전 유형의 경우 이것은 &lt;code&gt;Pair{KeyType,ValType}&lt;/code&gt; 입니다. 정의 &lt;code&gt;eltype(x) = eltype(typeof(x))&lt;/code&gt; 그 인스턴스의 유형 대신 전달 될 수 있도록 편의를 제공한다. 그러나 형식 인수를 허용하는 형식은 새 형식에 대해 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="aaf34e07d4b25cba011c9553650f31cccd21dfff" translate="yes" xml:space="preserve">
          <source>Determine whether &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have the same elements. Equivalent to &lt;code&gt;a &amp;sube; b &amp;amp;&amp;amp; b &amp;sube; a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 의 요소가 같은지 확인하십시오 . &lt;code&gt;a &amp;sube; b &amp;amp;&amp;amp; b &amp;sube; a&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6fe224096ee6d271d8650ef5a85d12ddaf29a9aa" translate="yes" xml:space="preserve">
          <source>Determine whether &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are identical, in the sense that no program could distinguish them. First the types of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are compared. If those are identical, mutable objects are compared by address in memory and immutable objects (such as numbers) are compared by contents at the bit level. This function is sometimes called &quot;egal&quot;. It always returns a &lt;code&gt;Bool&lt;/code&gt; value.</source>
          <target state="translated">어떤 프로그램도 구별 할 수 없다는 점에서 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 동일한 지 판별하십시오 . 먼저 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 유형을 비교합니다. 이들이 동일한 경우, 가변 객체는 메모리의 주소로 비교되고 불변 객체 (예 : 숫자)는 비트 레벨의 내용으로 비교됩니다. 이 기능을 때때로 &quot;egal&quot;이라고합니다. 항상 &lt;code&gt;Bool&lt;/code&gt; 값을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="4c01841b1d19ebebbfd42e2a4519e9eeb23a21ff" translate="yes" xml:space="preserve">
          <source>Determine whether &lt;code&gt;x&lt;/code&gt; is of the given &lt;code&gt;type&lt;/code&gt;. Can also be used as an infix operator, e.g. &lt;code&gt;x isa type&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 주어진 &lt;code&gt;type&lt;/code&gt; 인지 확인합니다 . &lt;code&gt;x isa type&lt;/code&gt; 과 같은 접두사 연산자로 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3861d13a45d2603781ce381027b447191258c3b4" translate="yes" xml:space="preserve">
          <source>Determine whether Julia is running an interactive session.</source>
          <target state="translated">Julia가 대화식 세션을 실행 중인지 판별하십시오.</target>
        </trans-unit>
        <trans-unit id="43e65f5a402fa1bae924db49a2a1b4604ea303b3" translate="yes" xml:space="preserve">
          <source>Determine whether a &lt;a href=&quot;#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; has a value stored to it. Returns immediately, does not block.</source>
          <target state="translated">&lt;a href=&quot;#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 에 값이 저장되어 있는지 확인 하십시오. 즉시 반환하고 차단하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="280a7018baf400207d8ed62c131e85ed27290be5" translate="yes" xml:space="preserve">
          <source>Determine whether a &lt;a href=&quot;#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; has a value stored to it.</source>
          <target state="translated">&lt;a href=&quot;#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 에 가치가 저장되어 있는지 확인 하십시오.</target>
        </trans-unit>
        <trans-unit id="5b3324d1290d116032871a2bc5a94e10fb519e78" translate="yes" xml:space="preserve">
          <source>Determine whether a &lt;a href=&quot;#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; has a value stored to it. Note that this function can cause race conditions, since by the time you receive its result it may no longer be true. However, it can be safely used on a &lt;a href=&quot;#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; since they are assigned only once.</source>
          <target state="translated">&lt;a href=&quot;#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; 에 값이 저장되어 있는지 확인 하십시오. 이 함수는 결과를 수신 할 때 더 이상 사실이 아니므로 경쟁 조건을 유발할 수 있습니다. 그러나 한 번만 할당되므로 &lt;a href=&quot;#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 에서 안전하게 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc0458f050932959c86f90b6c0643dab4bcd9d1c" translate="yes" xml:space="preserve">
          <source>Determine whether a MIME type is text data. MIME types are assumed to be binary data except for a set of types known to be text data (possibly Unicode).</source>
          <target state="translated">MIME 유형이 텍스트 데이터인지 판별하십시오. MIME 형식은 텍스트 데이터 (유니 코드 일 수 있음)로 알려진 형식 집합을 제외하고 이진 데이터로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="8fc3770027bb1af30a8b4ee8ea80a29e494f0909" translate="yes" xml:space="preserve">
          <source>Determine whether a collection has a mapping for a given &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">컬렉션에 지정된 &lt;code&gt;key&lt;/code&gt; 대한 매핑이 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="c5ba1a2324fb337b282efe50cd8040bf37d77c27" translate="yes" xml:space="preserve">
          <source>Determine whether a collection is empty (has no elements).</source>
          <target state="translated">컬렉션이 비어 있는지 확인합니다 (요소가 없음).</target>
        </trans-unit>
        <trans-unit id="5ec1cb97856793fb5db0068de1e319eab60e77f5" translate="yes" xml:space="preserve">
          <source>Determine whether a global is declared &lt;code&gt;const&lt;/code&gt; in a given &lt;code&gt;Module&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;Module&lt;/code&gt; 에서 전역이 &lt;code&gt;const&lt;/code&gt; 로 선언되는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="38e06eb740836bfe1cee92d1e7507081c868e8a5" translate="yes" xml:space="preserve">
          <source>Determine whether a path is absolute (begins at the root directory).</source>
          <target state="translated">경로가 절대인지 판별하십시오 (루트 디렉토리에서 시작).</target>
        </trans-unit>
        <trans-unit id="75728de62cc30cf84c05834c62b8d893a844140e" translate="yes" xml:space="preserve">
          <source>Determine whether a path refers to a directory (for example, ends with a path separator).</source>
          <target state="translated">경로가 디렉토리를 참조하는지 여부를 결정하십시오 (예 : 경로 구분 기호로 끝남).</target>
        </trans-unit>
        <trans-unit id="8b477691984cbcbed81870b45fc48859b3d53183" translate="yes" xml:space="preserve">
          <source>Determine whether a process has exited.</source>
          <target state="translated">프로세스가 종료되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c99d868d531dfe2e187331de7c9920869268ba47" translate="yes" xml:space="preserve">
          <source>Determine whether a process is currently running.</source>
          <target state="translated">프로세스가 현재 실행 중인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="99d55d3a5192933572c51fc97adc04872c6e44fb" translate="yes" xml:space="preserve">
          <source>Determine whether a stream is read-only.</source>
          <target state="translated">스트림이 읽기 전용인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="1e9c8b3c9b00278b97a8c0d5b0fc7fce932e91f2" translate="yes" xml:space="preserve">
          <source>Determine whether a task has exited.</source>
          <target state="translated">작업이 종료되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="ee4f20f770f5b5e7e4b7c777d2abc2362e36eec7" translate="yes" xml:space="preserve">
          <source>Determine whether a task has started executing.</source>
          <target state="translated">작업이 시작되었는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="dbdbed66108e712ca570ca19802dded33371c86c" translate="yes" xml:space="preserve">
          <source>Determine whether all hexadecimal digits of the given &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; are zero.</source>
          <target state="translated">주어진 &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt; 의 모든 16 진수 가 0 인지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="0dfd98a60f425f1bd73d9aa1e23986ceb9637766" translate="yes" xml:space="preserve">
          <source>Determine whether an item is in the given collection, in the sense that it is &lt;a href=&quot;../math/index#Base.:==&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt; to one of the values generated by iterating over the collection. Returns a &lt;code&gt;Bool&lt;/code&gt; value, except if &lt;code&gt;item&lt;/code&gt; is &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;collection&lt;/code&gt; contains &lt;code&gt;missing&lt;/code&gt; but not &lt;code&gt;item&lt;/code&gt;, in which case &lt;code&gt;missing&lt;/code&gt; is returned (&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;, matching the behavior of &lt;a href=&quot;#Base.any-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;any&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../math/index#Base.:==&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">컬렉션 을 반복하여 생성 된 값 중 하나에 대해 &lt;a href=&quot;../math/index#Base.:==&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt; 라는 의미에서 항목이 지정된 컬렉션에 있는지 여부를 판별하십시오 . 반환 &lt;code&gt;Bool&lt;/code&gt; 경우를 제외하고, 값을 &lt;code&gt;item&lt;/code&gt; 됩니다 &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;collection&lt;/code&gt; 포함 &lt;code&gt;missing&lt;/code&gt; 이 아닌 &lt;code&gt;item&lt;/code&gt; ,있는 경우 &lt;code&gt;missing&lt;/code&gt; 반환 ( &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;3 치 논리를&lt;/a&gt; ,의 행동 일치하는 &lt;a href=&quot;#Base.any-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;any&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;../math/index#Base.:==&quot;&gt; &lt;code&gt;==&lt;/code&gt; 를&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f6d70bfc36332f33986741370b3658ad50a9e6d2" translate="yes" xml:space="preserve">
          <source>Determine whether an object - such as a stream or timer &amp;ndash; is not yet closed. Once an object is closed, it will never produce a new event. However, since a closed stream may still have data to read in its buffer, use &lt;a href=&quot;#Base.eof&quot;&gt;&lt;code&gt;eof&lt;/code&gt;&lt;/a&gt; to check for the ability to read data. Use the &lt;code&gt;FileWatching&lt;/code&gt; package to be notified when a stream might be writable or readable.</source>
          <target state="translated">스트림 또는 타이머와 같은 개체가 아직 닫히지 않았는지 확인합니다. 객체가 닫히면 새로운 이벤트가 생성되지 않습니다. 그러나 닫힌 스트림에는 여전히 버퍼에서 읽을 데이터가있을 수 있으므로 &lt;a href=&quot;#Base.eof&quot;&gt; &lt;code&gt;eof&lt;/code&gt; &lt;/a&gt; 를 사용하여 데이터를 읽을 수 있는지 확인하십시오. 스트림을 쓸 수 있거나 읽을 수있을 때 알림을 &lt;code&gt;FileWatching&lt;/code&gt; 패키지를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c1c47e9d804e0d7ec711f5a7dc45b0f9649cfc5c" translate="yes" xml:space="preserve">
          <source>Determine whether every element of &lt;code&gt;a&lt;/code&gt; is also in &lt;code&gt;b&lt;/code&gt;, using &lt;a href=&quot;#Base.in&quot;&gt;&lt;code&gt;in&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모든 요소의 여부를 결정 &lt;code&gt;a&lt;/code&gt; 또한 인 &lt;code&gt;b&lt;/code&gt; 사용 &lt;a href=&quot;#Base.in&quot;&gt; &lt;code&gt;in&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2d0d549fe24528bf78c84130cee192a01bb9ecc1" translate="yes" xml:space="preserve">
          <source>Determine whether predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; for all elements of &lt;code&gt;itr&lt;/code&gt;, returning &lt;code&gt;false&lt;/code&gt; as soon as the first item in &lt;code&gt;itr&lt;/code&gt; for which &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; is encountered (short-circuiting).</source>
          <target state="translated">&lt;code&gt;itr&lt;/code&gt; 의 모든 요소에 대해 술어 &lt;code&gt;p&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하는지 여부를 판별하고 , &lt;code&gt;p&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 를 리턴 하는 &lt;code&gt;itr&lt;/code&gt; 의 첫 번째 항목 이 발견 되는 즉시 &lt;code&gt;false&lt;/code&gt; 를 리턴합니다 (단락).</target>
        </trans-unit>
        <trans-unit id="289250da1a3e0fba909534e3d914f76f0a83beed" translate="yes" xml:space="preserve">
          <source>Determine whether predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; for any elements of &lt;code&gt;itr&lt;/code&gt;, returning &lt;code&gt;true&lt;/code&gt; as soon as the first item in &lt;code&gt;itr&lt;/code&gt; for which &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; is encountered (short-circuiting).</source>
          <target state="translated">술어 여부를 확인 &lt;code&gt;p&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; 의 요소에 대한 &lt;code&gt;itr&lt;/code&gt; , 반환 &lt;code&gt;true&lt;/code&gt; 의 첫 번째 항목으로 빨리으로 &lt;code&gt;itr&lt;/code&gt; 있는 &lt;code&gt;p&lt;/code&gt; 를 반환 &lt;code&gt;true&lt;/code&gt; 발생 (단락).</target>
        </trans-unit>
        <trans-unit id="4e07dd9d2d99ac05e19db056ad10a6038f6ab62f" translate="yes" xml:space="preserve">
          <source>Determine whether the first argument is a substring of the second. If &lt;code&gt;needle&lt;/code&gt; is a regular expression, checks whether &lt;code&gt;haystack&lt;/code&gt; contains a match.</source>
          <target state="translated">첫 번째 인수가 두 번째 인수의 하위 문자열인지 확인하십시오. &lt;code&gt;needle&lt;/code&gt; 이 정규식 인 경우 &lt;code&gt;haystack&lt;/code&gt; 에 일치 항목이 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="403cb69fbefe8bf1c1819ec0d30c5d58c5b0c9c0" translate="yes" xml:space="preserve">
          <source>Determine whether the given generic function has a method applicable to the given arguments.</source>
          <target state="translated">주어진 일반 함수에 주어진 인수에 적용 가능한 메소드가 있는지 판별하십시오.</target>
        </trans-unit>
        <trans-unit id="0ecef99ec060f64932d509baf07fae2312bff5c4" translate="yes" xml:space="preserve">
          <source>Determine whether the given generic function has a method matching the given &lt;code&gt;Tuple&lt;/code&gt; of argument types with the upper bound of world age given by &lt;code&gt;world&lt;/code&gt;.</source>
          <target state="translated">주어진 일반적인 기능은 주어진 일치하는 방법이 있는지 여부를 확인 &lt;code&gt;Tuple&lt;/code&gt; 위쪽에 의해 주어진 세계 나이의 경계와 인수 유형을 &lt;code&gt;world&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c941aa3f3fab8b12bb7a8d06c55662ccc88bd232" translate="yes" xml:space="preserve">
          <source>Determine whether type &lt;code&gt;T&lt;/code&gt; is a concrete type, meaning it could have direct instances (values &lt;code&gt;x&lt;/code&gt; such that &lt;code&gt;typeof(x) === T&lt;/code&gt;).</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 가 구체적 유형 인지 여부를 판별하십시오 . 이는 직접 인스턴스를 가질 수 있음을 의미합니다 ( &lt;code&gt;typeof(x) === T&lt;/code&gt; 와 같은 &lt;code&gt;x&lt;/code&gt; 값 ).</target>
        </trans-unit>
        <trans-unit id="889b4cea5aec1b8d20d423a69b232b4fd8819ea1" translate="yes" xml:space="preserve">
          <source>Determine whether type &lt;code&gt;T&lt;/code&gt; is a tuple &quot;leaf type&quot;, meaning it could appear as a type signature in dispatch and has no subtypes (or supertypes) which could appear in a call.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 가 튜플 &quot;리프 유형&quot; 인지 여부를 판별하십시오 . 이는 디스패치에서 유형 시그니처로 표시 될 수 있고 호출에 나타날 수있는 하위 유형 (또는 수퍼 유형)이 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="fa3f743073996b313a25298a5751df1facc9b8ca" translate="yes" xml:space="preserve">
          <source>Determine whether type &lt;code&gt;T&lt;/code&gt; was declared as a primitive type (i.e. using the &lt;code&gt;primitive&lt;/code&gt; keyword).</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 가 기본 유형으로 선언 되었는지 여부를 판별하십시오 (예 : &lt;code&gt;primitive&lt;/code&gt; 키워드 사용).</target>
        </trans-unit>
        <trans-unit id="6ee927617e47ab19a9ab3eb7c45e5b0d181e4bde" translate="yes" xml:space="preserve">
          <source>Determine whether type &lt;code&gt;T&lt;/code&gt; was declared as a struct type (i.e. using the &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;mutable struct&lt;/code&gt; keyword).</source>
          <target state="translated">타입 &lt;code&gt;T&lt;/code&gt; 가 구조체 타입으로 선언 되었는지 ( &lt;code&gt;struct&lt;/code&gt; 또는 &lt;code&gt;mutable struct&lt;/code&gt; 키워드를 사용하여 ) 결정합니다.</target>
        </trans-unit>
        <trans-unit id="def23a2949c492af43c949112c644220edb792b0" translate="yes" xml:space="preserve">
          <source>Determine whether type &lt;code&gt;T&lt;/code&gt; was declared as an abstract type (i.e. using the &lt;code&gt;abstract&lt;/code&gt; keyword).</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 가 추상 유형으로 선언 되었는지 여부를 판별하십시오 (예 : &lt;code&gt;abstract&lt;/code&gt; 키워드 사용).</target>
        </trans-unit>
        <trans-unit id="c539db0242f115c7ed3b7d7b88baedfee34884e5" translate="yes" xml:space="preserve">
          <source>Determines if &lt;code&gt;a&lt;/code&gt; is a subset of, but not equal to, &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 &lt;code&gt;b&lt;/code&gt; 의 하위 집합 인지 여부를 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="d032dc0874cd5aa654968e088fbfba6befcfba64" translate="yes" xml:space="preserve">
          <source>Develop your package</source>
          <target state="translated">패키지 개발</target>
        </trans-unit>
        <trans-unit id="a5ecd286faa5677726aa083151af6be4709cf28e" translate="yes" xml:space="preserve">
          <source>Diagonal</source>
          <target state="translated">Diagonal</target>
        </trans-unit>
        <trans-unit id="c8ddb8ebd7c9ec0a8a6949cc24c26e5db1b28da8" translate="yes" xml:space="preserve">
          <source>Diagonal matrix</source>
          <target state="translated">대각선 행렬</target>
        </trans-unit>
        <trans-unit id="fb2b46a0ed907e0e3db008e1bf7296f2fa0ee640" translate="yes" xml:space="preserve">
          <source>Diameter Sign</source>
          <target state="translated">직경 표시</target>
        </trans-unit>
        <trans-unit id="4e77b4c7440f9011313e26852abc6646e08bbb9b" translate="yes" xml:space="preserve">
          <source>Diamond Operator</source>
          <target state="translated">다이아몬드 연산자</target>
        </trans-unit>
        <trans-unit id="cd59a157c959e21a5d8e33ac498a1543408b829b" translate="yes" xml:space="preserve">
          <source>Diamond Shape With A Dot Inside</source>
          <target state="translated">안에 점이있는 다이아몬드 모양</target>
        </trans-unit>
        <trans-unit id="c979f35c2213ac9ce29d392a08f0cd02319be0a8" translate="yes" xml:space="preserve">
          <source>Diamond With Bottom Half Black</source>
          <target state="translated">하단 반 검은 다이아몬드</target>
        </trans-unit>
        <trans-unit id="ea9affe495abd6a6b0faedd90651c9dfc7405bbb" translate="yes" xml:space="preserve">
          <source>Diamond With Left Half Black</source>
          <target state="translated">왼쪽 반 검은 다이아몬드</target>
        </trans-unit>
        <trans-unit id="d5a38a7e34ff056cfbb328f94dd973e13e1b0f13" translate="yes" xml:space="preserve">
          <source>Diamond With Right Half Black</source>
          <target state="translated">오른쪽 반 검은 다이아몬드</target>
        </trans-unit>
        <trans-unit id="17906bab8d1dd54d5285d04d3ccda2d66fc279ee" translate="yes" xml:space="preserve">
          <source>Diamond With Top Half Black</source>
          <target state="translated">상반신 다이아몬드</target>
        </trans-unit>
        <trans-unit id="3550a4a38c380e14df95457cd13d6dabbd0c0b20" translate="yes" xml:space="preserve">
          <source>Dict</source>
          <target state="translated">Dict</target>
        </trans-unit>
        <trans-unit id="51b0613ac049d8459b061ee15aa8ba7ae5794479" translate="yes" xml:space="preserve">
          <source>Dictionaries</source>
          <target state="translated">Dictionaries</target>
        </trans-unit>
        <trans-unit id="226686711adc28abd6b28df88e06bd40f70ef31c" translate="yes" xml:space="preserve">
          <source>Dictionaries may also be created with generators. For example, &lt;code&gt;Dict(i =&amp;gt; f(i) for i = 1:10)&lt;/code&gt;.</source>
          <target state="translated">생성기를 사용하여 사전을 만들 수도 있습니다. 예를 들어, &lt;code&gt;Dict(i =&amp;gt; f(i) for i = 1:10)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6c2228958df07965c5237ec0fac371cc94b97788" translate="yes" xml:space="preserve">
          <source>Dictionary and set types, or in general anything that depends on the output of a &lt;code&gt;hash(key)&lt;/code&gt; method, are a trickier case. In the common case where the keys are numbers, strings, symbols, ranges, &lt;code&gt;Expr&lt;/code&gt;, or compositions of these types (via arrays, tuples, sets, pairs, etc.) they are safe to precompile. However, for a few other key types, such as &lt;code&gt;Function&lt;/code&gt; or &lt;code&gt;DataType&lt;/code&gt; and generic user-defined types where you haven't defined a &lt;code&gt;hash&lt;/code&gt; method, the fallback &lt;code&gt;hash&lt;/code&gt; method depends on the memory address of the object (via its &lt;code&gt;objectid&lt;/code&gt;) and hence may change from run to run. If you have one of these key types, or if you aren't sure, to be safe you can initialize this dictionary from within your &lt;code&gt;__init__&lt;/code&gt; function. Alternatively, you can use the &lt;a href=&quot;../../base/collections/index#Base.IdDict&quot;&gt;&lt;code&gt;IdDict&lt;/code&gt;&lt;/a&gt; dictionary type, which is specially handled by precompilation so that it is safe to initialize at compile-time.</source>
          <target state="translated">사전 및 세트 유형 또는 일반적으로 &lt;code&gt;hash(key)&lt;/code&gt; 메소드 의 출력에 의존 하는 것은 까다로운 경우입니다. 키가 숫자, 문자열, 기호, 범위, &lt;code&gt;Expr&lt;/code&gt; 또는 이러한 유형의 구성 (배열, 튜플, 세트, ​​쌍 등을 통해) 인 일반적인 경우에는 미리 컴파일해도 안전합니다. 그러나 &lt;code&gt;Function&lt;/code&gt; 또는 &lt;code&gt;DataType&lt;/code&gt; 과 같은 일부 다른 키 유형 및 &lt;code&gt;hash&lt;/code&gt; 방법을 정의하지 않은 일반 사용자 정의 유형의 경우 대체 &lt;code&gt;hash&lt;/code&gt; 방법은 객체의 메모리 주소 ( &lt;code&gt;objectid&lt;/code&gt; 를 통해)에 따라 다릅니다.) 따라서 달리기마다 바뀔 수 있습니다. 이러한 키 유형 중 하나가 있거나 확실하지 않은 경우 안전을 위해 &lt;code&gt;__init__&lt;/code&gt; 함수 내에서이 사전을 초기화 할 수 있습니다 . 또는 컴파일 타임에 안전하게 초기화 할 수 있도록 사전 컴파일에 의해 특별히 처리되는 &lt;a href=&quot;../../base/collections/index#Base.IdDict&quot;&gt; &lt;code&gt;IdDict&lt;/code&gt; &lt;/a&gt; 사전 유형을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dacf1b614fb594526af821a4a2be88604306ed44" translate="yes" xml:space="preserve">
          <source>Dictionary keys can also be tab completed:</source>
          <target state="translated">사전 키도 탭 완성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="292578b4b7085196841d56350bbddafbc7e6d0bb" translate="yes" xml:space="preserve">
          <source>Die Face-1</source>
          <target state="translated">다이 페이스 -1</target>
        </trans-unit>
        <trans-unit id="cdbec4e00ebdd8c20f5ee4b56ba58057d7e2ec05" translate="yes" xml:space="preserve">
          <source>Die Face-2</source>
          <target state="translated">다이 페이스 -2</target>
        </trans-unit>
        <trans-unit id="d78fd4a1c34901a2159f7a6e530555949f39daa7" translate="yes" xml:space="preserve">
          <source>Die Face-3</source>
          <target state="translated">다이 페이스 -3</target>
        </trans-unit>
        <trans-unit id="1e5a67accc5d5c25093b0a623f892e361241ae52" translate="yes" xml:space="preserve">
          <source>Die Face-4</source>
          <target state="translated">다이 페이스 -4</target>
        </trans-unit>
        <trans-unit id="e4d4e7bdf84edf508b41bc9d8e314d7651a257a0" translate="yes" xml:space="preserve">
          <source>Die Face-5</source>
          <target state="translated">다이 페이스 -5</target>
        </trans-unit>
        <trans-unit id="14e325af88a46d7bc2d653104317a2958dfaba04" translate="yes" xml:space="preserve">
          <source>Die Face-6</source>
          <target state="translated">다이 스페이스 -6</target>
        </trans-unit>
        <trans-unit id="795ba7a0ce5c58cba555b57bd85cef8a4746539c" translate="yes" xml:space="preserve">
          <source>Difference Between</source>
          <target state="translated">차이점</target>
        </trans-unit>
        <trans-unit id="633fcadd9a7c828edcf878f9058272e3b3e9a1b6" translate="yes" xml:space="preserve">
          <source>Difference Between + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">Long Solidus 오버레이 결합 / 비 간격 Long 슬래시 오버레이의 차이점</target>
        </trans-unit>
        <trans-unit id="ffeb2f798ecd4de58b7035483cdc6373fe3233be" translate="yes" xml:space="preserve">
          <source>DimensionMismatch</source>
          <target state="translated">DimensionMismatch</target>
        </trans-unit>
        <trans-unit id="2321ae657c8e83f68d4d7ddbffafe794a2164af3" translate="yes" xml:space="preserve">
          <source>Dims</source>
          <target state="translated">Dims</target>
        </trans-unit>
        <trans-unit id="4fb82b30b311a8f2f43ae3e857d3584f2edb16f3" translate="yes" xml:space="preserve">
          <source>Direct Hit</source>
          <target state="translated">직접 명중</target>
        </trans-unit>
        <trans-unit id="7a610c61d6e2df53d7f7028820759b68c9cdf43a" translate="yes" xml:space="preserve">
          <source>Direct comparison of the numerator and denominator is generally not necessary, since the standard arithmetic and comparison operations are defined for rational values:</source>
          <target state="translated">표준 산술 및 비교 연산이 합리적인 값에 대해 정의되므로 분자와 분모를 직접 비교할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="39702e75a6cf1386c6592825cf3db26e55cb9c65" translate="yes" xml:space="preserve">
          <source>Direct construction of &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt; objects with value arguments is powerful, but &lt;code&gt;Expr&lt;/code&gt; constructors can be tedious compared to &quot;normal&quot; Julia syntax. As an alternative, Julia allows &lt;em&gt;interpolation&lt;/em&gt; of literals or expressions into quoted expressions. Interpolation is indicated by a prefix &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="translated">값 인수를 사용하여 &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; &lt;/a&gt; 객체를 직접 구성하는 것은 강력하지만 &lt;code&gt;Expr&lt;/code&gt; 생성자는 &quot;일반적인&quot;Julia 구문에 비해 지루할 수 있습니다. 대안으로 Julia는 리터럴 또는 표현식을 인용 된 표현식으로 &lt;em&gt;보간&lt;/em&gt; 할 수 있습니다 . 보간은 접두사 &lt;code&gt;$&lt;/code&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="e859576baf1df468abfbf6259c6df055e40c3865" translate="yes" xml:space="preserve">
          <source>Disable Ctrl-C handler during execution of a function on the current task, for calling external code that may call julia code that is not interrupt safe. Intended to be called using &lt;code&gt;do&lt;/code&gt; block syntax as follows:</source>
          <target state="translated">현재 작업에서 함수를 실행하는 동안 Ctrl-C 처리기를 비활성화하여 안전하지 않은 julia 코드를 호출 할 수있는 외부 코드를 호출합니다. 다음과 같이 &lt;code&gt;do&lt;/code&gt; 블록 구문을 사용하여 호출 되었습니다.</target>
        </trans-unit>
        <trans-unit id="ee5dfa8ba600cccab503575e49577656d5630d4b" translate="yes" xml:space="preserve">
          <source>Disable all log messages at log levels equal to or less than &lt;code&gt;level&lt;/code&gt;. This is a &lt;em&gt;global&lt;/em&gt; setting, intended to make debug logging extremely cheap when disabled.</source>
          <target state="translated">&lt;code&gt;level&lt;/code&gt; 이하의 로그 수준에서 모든 로그 메시지를 비활성화합니다 . 이것은 &lt;em&gt;전역&lt;/em&gt; 설정으로, 비활성화 될 때 디버그 로깅을 매우 저렴하게하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="1f365e08d11c88067711c3e53ea5deda45baac76" translate="yes" xml:space="preserve">
          <source>Disable the GC, return previous state as int</source>
          <target state="translated">GC를 비활성화하고 이전 상태를 int로 반환</target>
        </trans-unit>
        <trans-unit id="3978fd69ff9f5062319ab42f51b05b0aaac345ec" translate="yes" xml:space="preserve">
          <source>Disabling garbage collection should be used only with caution, as it can cause memory use to grow without bound.</source>
          <target state="translated">가비지 수집을 사용하지 않으면 메모리 사용이 제한없이 커질 수 있으므로주의해서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="876921bd8b5ab79222657dd5d0af64f5515603c3" translate="yes" xml:space="preserve">
          <source>Disallow or enable unsafe floating point optimizations (overrides @fastmath declaration)</source>
          <target state="translated">안전하지 않은 부동 소수점 최적화를 허용하지 않거나 활성화합니다 (@fastmath 선언을 무시 함)</target>
        </trans-unit>
        <trans-unit id="07015f11ed3e9662a9e3d218f4e32dd41d124545" translate="yes" xml:space="preserve">
          <source>Disappointed But Relieved Face</source>
          <target state="translated">실망했지만 안심할 수있는 얼굴</target>
        </trans-unit>
        <trans-unit id="5bd8d20ec17f66810be7ac160730554259c2f393" translate="yes" xml:space="preserve">
          <source>Disappointed Face</source>
          <target state="translated">실망한 얼굴</target>
        </trans-unit>
        <trans-unit id="4818d3085918b897bb5940cbb6aa6b457b2f50f0" translate="yes" xml:space="preserve">
          <source>Discard the &lt;code&gt;payload&lt;/code&gt; credential from begin re-used in future authentication. Should only be called when authentication was unsuccessful.</source>
          <target state="translated">향후 인증에 재사용 되는 &lt;code&gt;payload&lt;/code&gt; 자격 증명을 폐기하십시오 . 인증에 실패한 경우에만 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="00ebed03f3d4a5ea390c18a91bde6105d1ff3fe5" translate="yes" xml:space="preserve">
          <source>Dispatch on one argument at a time</source>
          <target state="translated">한 번에 하나의 인수 만 전달</target>
        </trans-unit>
        <trans-unit id="8960408fead9aa75ceb4aee4e800ae4451c96002" translate="yes" xml:space="preserve">
          <source>Display equations</source>
          <target state="translated">방정식 표시</target>
        </trans-unit>
        <trans-unit id="1df9a6dc2c17a0ba7bdb95b8c1b94c8fdab3317c" translate="yes" xml:space="preserve">
          <source>Display version information</source>
          <target state="translated">버전 정보 표시</target>
        </trans-unit>
        <trans-unit id="1b44f5625aa08ea5a916469ddb5a30b0fa48b533" translate="yes" xml:space="preserve">
          <source>Distributed Computing</source>
          <target state="translated">분산 컴퓨팅</target>
        </trans-unit>
        <trans-unit id="75f5d856b9b1768edecb8d197541ee2cc802dc7e" translate="yes" xml:space="preserve">
          <source>Distributed programming in Julia is built on two primitives: &lt;em&gt;remote references&lt;/em&gt; and &lt;em&gt;remote calls&lt;/em&gt;. A remote reference is an object that can be used from any process to refer to an object stored on a particular process. A remote call is a request by one process to call a certain function on certain arguments on another (possibly the same) process.</source>
          <target state="translated">Julia의 분산 프로그래밍은 &lt;em&gt;원격 참조&lt;/em&gt; 와 &lt;em&gt;원격 호출의&lt;/em&gt; 두 가지 기본 요소를 기반으로 &lt;em&gt;합니다&lt;/em&gt; . 원격 참조는 모든 프로세스에서 특정 프로세스에 저장된 개체를 참조하는 데 사용할 수있는 개체입니다. 원격 호출은 한 프로세스가 다른 인수 (아마도 동일한) 프로세스의 특정 인수에 대해 특정 함수를 호출하도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="96434486b44e8b445920f8cfba7cc682d4dfc2db" translate="yes" xml:space="preserve">
          <source>Distributed.@distributed</source>
          <target state="translated">Distributed.@distributed</target>
        </trans-unit>
        <trans-unit id="1a098ddbdf75655cc9180cdc7b6440448f09568d" translate="yes" xml:space="preserve">
          <source>Distributed.@everywhere</source>
          <target state="translated">Distributed.@everywhere</target>
        </trans-unit>
        <trans-unit id="efbc6617cb7c0815e2ea5d73b544497289152b89" translate="yes" xml:space="preserve">
          <source>Distributed.@fetch</source>
          <target state="translated">Distributed.@fetch</target>
        </trans-unit>
        <trans-unit id="59e5edc22d0bcf1af2630d1052c482cdb408f391" translate="yes" xml:space="preserve">
          <source>Distributed.@fetchfrom</source>
          <target state="translated">Distributed.@fetchfrom</target>
        </trans-unit>
        <trans-unit id="af80c7ed9530f2c7e180576f660e05a18aca79bb" translate="yes" xml:space="preserve">
          <source>Distributed.@spawn</source>
          <target state="translated">Distributed.@spawn</target>
        </trans-unit>
        <trans-unit id="da346ed14fde6d1e8361fba9d749980594b148e9" translate="yes" xml:space="preserve">
          <source>Distributed.@spawnat</source>
          <target state="translated">Distributed.@spawnat</target>
        </trans-unit>
        <trans-unit id="cd85ed1cfd9557c350600fd95dc13b777ce3fe85" translate="yes" xml:space="preserve">
          <source>Distributed.AbstractWorkerPool</source>
          <target state="translated">Distributed.AbstractWorkerPool</target>
        </trans-unit>
        <trans-unit id="36af7ae728088acd59fb1d45bca438f98c665d8c" translate="yes" xml:space="preserve">
          <source>Distributed.CachingPool</source>
          <target state="translated">Distributed.CachingPool</target>
        </trans-unit>
        <trans-unit id="22d34851a0eba645399be62bb28846b66823289e" translate="yes" xml:space="preserve">
          <source>Distributed.ClusterManager</source>
          <target state="translated">Distributed.ClusterManager</target>
        </trans-unit>
        <trans-unit id="b0cd727f1d03d744fc280a981fa5b9190b5153e2" translate="yes" xml:space="preserve">
          <source>Distributed.Future</source>
          <target state="translated">Distributed.Future</target>
        </trans-unit>
        <trans-unit id="ea257e0490c136ba7d3090abaaf36e4a0ca8d1a7" translate="yes" xml:space="preserve">
          <source>Distributed.RemoteChannel</source>
          <target state="translated">Distributed.RemoteChannel</target>
        </trans-unit>
        <trans-unit id="4d0b601e8fedd7c09e5642c005570fc3a0473253" translate="yes" xml:space="preserve">
          <source>Distributed.RemoteException</source>
          <target state="translated">Distributed.RemoteException</target>
        </trans-unit>
        <trans-unit id="c33f096540905e1e5959bf9b4378500ff82ca6f7" translate="yes" xml:space="preserve">
          <source>Distributed.WorkerConfig</source>
          <target state="translated">Distributed.WorkerConfig</target>
        </trans-unit>
        <trans-unit id="8ce81814c48804e7f821d092b3e46ed846c5880d" translate="yes" xml:space="preserve">
          <source>Distributed.WorkerPool</source>
          <target state="translated">Distributed.WorkerPool</target>
        </trans-unit>
        <trans-unit id="164200aa0d1a016ac5f4b6fd50cd6698574608fa" translate="yes" xml:space="preserve">
          <source>Distributed.addprocs()</source>
          <target state="translated">Distributed.addprocs()</target>
        </trans-unit>
        <trans-unit id="173fea4d9a9f7c07219a7da8c1a00ac502393d87" translate="yes" xml:space="preserve">
          <source>Distributed.channel_from_id()</source>
          <target state="translated">Distributed.channel_from_id()</target>
        </trans-unit>
        <trans-unit id="226386f83311a76a8211104c4edb61bcf3c75680" translate="yes" xml:space="preserve">
          <source>Distributed.clear!()</source>
          <target state="translated">Distributed.clear!()</target>
        </trans-unit>
        <trans-unit id="a5baf4d266ab8829135539799e42c9d4c0ead21b" translate="yes" xml:space="preserve">
          <source>Distributed.cluster_cookie()</source>
          <target state="translated">Distributed.cluster_cookie()</target>
        </trans-unit>
        <trans-unit id="dc2fa5e71cd9d9b639010b97b4740edbdbb81f56" translate="yes" xml:space="preserve">
          <source>Distributed.default_worker_pool()</source>
          <target state="translated">Distributed.default_worker_pool()</target>
        </trans-unit>
        <trans-unit id="41cdeb4d12b400fba432add756ae6ef656d520c6" translate="yes" xml:space="preserve">
          <source>Distributed.init_worker()</source>
          <target state="translated">Distributed.init_worker()</target>
        </trans-unit>
        <trans-unit id="869d052c4a2a06e70c0d44a1851f76e2f966103b" translate="yes" xml:space="preserve">
          <source>Distributed.interrupt()</source>
          <target state="translated">Distributed.interrupt()</target>
        </trans-unit>
        <trans-unit id="3ea59996280ad714503bd21db89af3ed0ddb5c84" translate="yes" xml:space="preserve">
          <source>Distributed.launch()</source>
          <target state="translated">Distributed.launch()</target>
        </trans-unit>
        <trans-unit id="e48c1d69b737782cf0cea89c2b07847840fe9c44" translate="yes" xml:space="preserve">
          <source>Distributed.manage()</source>
          <target state="translated">Distributed.manage()</target>
        </trans-unit>
        <trans-unit id="05a5ebfc426c1bd80394e5bf665a5fda064e34c4" translate="yes" xml:space="preserve">
          <source>Distributed.myid()</source>
          <target state="translated">Distributed.myid()</target>
        </trans-unit>
        <trans-unit id="1fdb70cf3ecb7a0aa097a69946d096f32726c49e" translate="yes" xml:space="preserve">
          <source>Distributed.nprocs()</source>
          <target state="translated">Distributed.nprocs()</target>
        </trans-unit>
        <trans-unit id="394af0754f2238a05c08dd8f6b6874db18b285c7" translate="yes" xml:space="preserve">
          <source>Distributed.nworkers()</source>
          <target state="translated">Distributed.nworkers()</target>
        </trans-unit>
        <trans-unit id="b85b64151cf4f4ae19fb8cf053b4d77736d64609" translate="yes" xml:space="preserve">
          <source>Distributed.pmap()</source>
          <target state="translated">Distributed.pmap()</target>
        </trans-unit>
        <trans-unit id="f379e8118bd0a8163fb093113934cf152437fe6b" translate="yes" xml:space="preserve">
          <source>Distributed.process_messages()</source>
          <target state="translated">Distributed.process_messages()</target>
        </trans-unit>
        <trans-unit id="c462fb87629ce04f2ef477ae483ec589605d65cb" translate="yes" xml:space="preserve">
          <source>Distributed.procs()</source>
          <target state="translated">Distributed.procs()</target>
        </trans-unit>
        <trans-unit id="328c4408c15f7286da8f5406178cc12a69c58b5c" translate="yes" xml:space="preserve">
          <source>Distributed.remote()</source>
          <target state="translated">Distributed.remote()</target>
        </trans-unit>
        <trans-unit id="7dd1a0dd0aaef1f1d7ae03091ad26ce2253cd598" translate="yes" xml:space="preserve">
          <source>Distributed.remote_do()</source>
          <target state="translated">Distributed.remote_do()</target>
        </trans-unit>
        <trans-unit id="9fb42670c69fd280316f8b2f0ea16afea4c810c9" translate="yes" xml:space="preserve">
          <source>Distributed.remotecall()</source>
          <target state="translated">Distributed.remotecall()</target>
        </trans-unit>
        <trans-unit id="a67cc8bf59dc3c96f9aef1e9811c3479c8b46371" translate="yes" xml:space="preserve">
          <source>Distributed.remotecall_fetch()</source>
          <target state="translated">Distributed.remotecall_fetch()</target>
        </trans-unit>
        <trans-unit id="4dc4a66df6faa8cff424bd89060037bf46df26cd" translate="yes" xml:space="preserve">
          <source>Distributed.remotecall_wait()</source>
          <target state="translated">Distributed.remotecall_wait()</target>
        </trans-unit>
        <trans-unit id="eba77344fe6aa6904b303120e58ddda491f4bb1a" translate="yes" xml:space="preserve">
          <source>Distributed.remoteref_id()</source>
          <target state="translated">Distributed.remoteref_id()</target>
        </trans-unit>
        <trans-unit id="6313c54bbc81e913c52e3ed8676831966128d19d" translate="yes" xml:space="preserve">
          <source>Distributed.rmprocs()</source>
          <target state="translated">Distributed.rmprocs()</target>
        </trans-unit>
        <trans-unit id="a4a167c1c83070eb12b10d5a804750df20f010d6" translate="yes" xml:space="preserve">
          <source>Distributed.start_worker()</source>
          <target state="translated">Distributed.start_worker()</target>
        </trans-unit>
        <trans-unit id="2c121b43490b3f755d6bc8ec22e6e6d7a5a177c3" translate="yes" xml:space="preserve">
          <source>Distributed.worker_id_from_socket()</source>
          <target state="translated">Distributed.worker_id_from_socket()</target>
        </trans-unit>
        <trans-unit id="b65a1ff0a0efeb8eb1c566e4e444c8fdab89ba3a" translate="yes" xml:space="preserve">
          <source>Distributed.workers()</source>
          <target state="translated">Distributed.workers()</target>
        </trans-unit>
        <trans-unit id="01f3300548243049d963e19250b86a197066f883" translate="yes" xml:space="preserve">
          <source>Divide each entry in an array &lt;code&gt;A&lt;/code&gt; by a scalar &lt;code&gt;b&lt;/code&gt; overwriting &lt;code&gt;A&lt;/code&gt; in-place. Use &lt;a href=&quot;#LinearAlgebra.ldiv!&quot;&gt;&lt;code&gt;ldiv!&lt;/code&gt;&lt;/a&gt; to divide scalar from left.</source>
          <target state="translated">어레이의 각 엔트리 나눈다 스칼라 &lt;code&gt;b&lt;/code&gt; 덮어 &lt;code&gt;A&lt;/code&gt; 현재 위치에서를. &lt;a href=&quot;#LinearAlgebra.ldiv!&quot;&gt; &lt;code&gt;ldiv!&lt;/code&gt; &lt;/a&gt; 사용하십시오 ! 스칼라를 왼쪽에서 나누려면 &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c5227a4411a33c2b0a2917ac123771fc4d90473" translate="yes" xml:space="preserve">
          <source>Divide each entry in an array &lt;code&gt;B&lt;/code&gt; by a scalar &lt;code&gt;a&lt;/code&gt; overwriting &lt;code&gt;B&lt;/code&gt; in-place. Use &lt;a href=&quot;#LinearAlgebra.rdiv!&quot;&gt;&lt;code&gt;rdiv!&lt;/code&gt;&lt;/a&gt; to divide scalar from right.</source>
          <target state="translated">어레이의 각 엔트리 나눈다 &lt;code&gt;B&lt;/code&gt; 스칼라 덮어 &lt;code&gt;B&lt;/code&gt; 인 곳. &lt;a href=&quot;#LinearAlgebra.rdiv!&quot;&gt; &lt;code&gt;rdiv!&lt;/code&gt; &lt;/a&gt; 사용하십시오 ! 스칼라를 오른쪽에서 나누기 위해. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="161ea982f22680e7ef2021310dae639abf1326db" translate="yes" xml:space="preserve">
          <source>Divide two integers or rational numbers, giving a &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; result.</source>
          <target state="translated">주고, 두 개의 정수 나 유리수를 분할 &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt; 결과입니다.</target>
        </trans-unit>
        <trans-unit id="7ad94500626afb00127de3b189a93eaca8744de4" translate="yes" xml:space="preserve">
          <source>Divides</source>
          <target state="translated">Divides</target>
        </trans-unit>
        <trans-unit id="e2b8ca950fd114a793b53e8c5e48ea524b845d7d" translate="yes" xml:space="preserve">
          <source>Division Sign</source>
          <target state="translated">구분 표시</target>
        </trans-unit>
        <trans-unit id="361a7f8376269b5b650c0bf43907fe05e5712a64" translate="yes" xml:space="preserve">
          <source>Division Times</source>
          <target state="translated">디비전 타임즈</target>
        </trans-unit>
        <trans-unit id="5b52981f5797afbc7daabde2522293d6f287e47f" translate="yes" xml:space="preserve">
          <source>Division errors</source>
          <target state="translated">사단 오류</target>
        </trans-unit>
        <trans-unit id="036fd78d0d2fb9786e807e79b9ec1fe9b9f0ab1d" translate="yes" xml:space="preserve">
          <source>Division functions</source>
          <target state="translated">구분 기능</target>
        </trans-unit>
        <trans-unit id="71beaa328c19038dd8d3afa0450399489fcfa5bb" translate="yes" xml:space="preserve">
          <source>Dizzy Face</source>
          <target state="translated">현기증 얼굴</target>
        </trans-unit>
        <trans-unit id="271c431f3d459dae90731776142efcc9efba3a41" translate="yes" xml:space="preserve">
          <source>Dizzy Symbol</source>
          <target state="translated">현기증</target>
        </trans-unit>
        <trans-unit id="a72324023e9231ddd2559ff9084345bc66092df6" translate="yes" xml:space="preserve">
          <source>Do I want to use a release, beta, or nightly version of Julia?</source>
          <target state="translated">Julia의 릴리스, 베타 또는 야간 버전을 사용하고 싶습니까?</target>
        </trans-unit>
        <trans-unit id="3db8faa5c93df04fc1f4cad1a3ef3da7ae3d5746" translate="yes" xml:space="preserve">
          <source>Do Not Litter Symbol</source>
          <target state="translated">쓰레기를 버리지 마십시오</target>
        </trans-unit>
        <trans-unit id="89ad2cd843ab0ac775fb58a33130e35a9ebce093" translate="yes" xml:space="preserve">
          <source>Do any final processing necessary for the given testset. This is called by the &lt;code&gt;@testset&lt;/code&gt; infrastructure after a test block executes. One common use for this function is to record the testset to the parent's results list, using &lt;code&gt;get_testset&lt;/code&gt;.</source>
          <target state="translated">주어진 테스트 세트에 필요한 최종 처리를 수행하십시오. 이것은 테스트 블록이 실행 된 후 &lt;code&gt;@testset&lt;/code&gt; 인프라에 의해 호출됩니다 . 이 함수의 일반적인 용도 중 하나는 get_testset을 사용하여 &lt;code&gt;get_testset&lt;/code&gt; 세트를 부모의 결과 목록에 기록하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="97fbb621c645ddfec0a076ad4bcef012b8a293b3" translate="yes" xml:space="preserve">
          <source>Do not call this on a handle that's already owned by some other part of the system.</source>
          <target state="translated">시스템의 다른 부분에서 이미 소유 한 핸들에서는 이것을 호출하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="5c71b02f0c824517c5e8eef286d8968d841fb69a" translate="yes" xml:space="preserve">
          <source>Do not repeat yourself.</source>
          <target state="translated">반복하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="d599d6549afb353871b063d385c2f5bb866c837d" translate="yes" xml:space="preserve">
          <source>Do not write &lt;code&gt;x-&amp;gt;f(x)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x-&amp;gt;f(x)&lt;/code&gt; 쓰지 마십시오</target>
        </trans-unit>
        <trans-unit id="e93ac681d8ce5c9e419103f5e01e286f7a37841c" translate="yes" xml:space="preserve">
          <source>Do-Block Syntax for Function Arguments</source>
          <target state="translated">함수 인수를위한 Do-Block 구문</target>
        </trans-unit>
        <trans-unit id="68a4194227be4ab74bc3d32363417c0fc1f30055" translate="yes" xml:space="preserve">
          <source>Docs</source>
          <target state="translated">Docs</target>
        </trans-unit>
        <trans-unit id="951ee5040959da5427656e41d49e8acd4aff75ee" translate="yes" xml:space="preserve">
          <source>Docs.@html_str</source>
          <target state="translated">Docs.@html_str</target>
        </trans-unit>
        <trans-unit id="94211649e4d7dde7192ce3db00bbee03bb4c3e61" translate="yes" xml:space="preserve">
          <source>Docs.@text_str</source>
          <target state="translated">Docs.@text_str</target>
        </trans-unit>
        <trans-unit id="f065f6fa6c71fdad19f0dcd2a0e82257bad77265" translate="yes" xml:space="preserve">
          <source>Docs.apropos()</source>
          <target state="translated">Docs.apropos()</target>
        </trans-unit>
        <trans-unit id="723c13f6eed0956ec36bf5aa24f80dc095fc1a62" translate="yes" xml:space="preserve">
          <source>Docstrings are edited using the same tools as code. Therefore, the same conventions should apply. It is advised to add line breaks after 92 characters.</source>
          <target state="translated">문서 문자열은 코드와 동일한 도구를 사용하여 편집됩니다. 따라서 동일한 규칙이 적용되어야합니다. 92 자 뒤에 줄 바꿈을 추가하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e741da5c63f67a2059af6310cbefc21c3af104c4" translate="yes" xml:space="preserve">
          <source>Doctests are enabled by &lt;a href=&quot;https://github.com/JuliaDocs/Documenter.jl&quot;&gt;&lt;code&gt;Documenter.jl&lt;/code&gt;&lt;/a&gt;. For more detailed documentation see Documenter's &lt;a href=&quot;https://juliadocs.github.io/Documenter.jl/&quot;&gt;manual&lt;/a&gt;.</source>
          <target state="translated">Doctest는 &lt;a href=&quot;https://github.com/JuliaDocs/Documenter.jl&quot;&gt; &lt;code&gt;Documenter.jl&lt;/code&gt; 에&lt;/a&gt; 의해 활성화됩니다 . 자세한 내용은 Documenter 's &lt;a href=&quot;https://juliadocs.github.io/Documenter.jl/&quot;&gt;manual을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9e9cf3221a30246219863f1d2366e36cb580debc" translate="yes" xml:space="preserve">
          <source>Documentation</source>
          <target state="translated">Documentation</target>
        </trans-unit>
        <trans-unit id="1e2dea0c3337740d3f32a466769f4f1557f19738" translate="yes" xml:space="preserve">
          <source>Documentation can be accessed at the REPL or in &lt;a href=&quot;https://github.com/JuliaLang/IJulia.jl&quot;&gt;IJulia&lt;/a&gt; by typing &lt;code&gt;?&lt;/code&gt; followed by the name of a function or macro, and pressing &lt;code&gt;Enter&lt;/code&gt;. For example,</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; 를 입력하여 REPL 또는 &lt;a href=&quot;https://github.com/JuliaLang/IJulia.jl&quot;&gt;IJulia&lt;/a&gt; 에서 문서에 액세스 할 수 있습니다 . 함수 또는 매크로 이름 다음에 &lt;code&gt;Enter&lt;/code&gt; 키 를 누릅니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="82b208253644825d49a694f47eb50e7748d27ea9" translate="yes" xml:space="preserve">
          <source>Documentation is interpreted as &lt;a href=&quot;https://en.wikipedia.org/wiki/Markdown&quot;&gt;Markdown&lt;/a&gt;, so you can use indentation and code fences to delimit code examples from text. Technically, any object can be associated with any other as metadata; Markdown happens to be the default, but one can construct other string macros and pass them to the &lt;code&gt;@doc&lt;/code&gt; macro just as well.</source>
          <target state="translated">문서는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Markdown&quot;&gt;Markdown&lt;/a&gt; 으로 해석 되므로 들여 쓰기 및 코드 펜스를 사용하여 코드 예제를 텍스트에서 구분할 수 있습니다. 기술적으로 모든 객체는 메타 데이터로 다른 객체와 연관 될 수 있습니다. Markdown이 기본값이지만 다른 문자열 매크로를 구성하여 &lt;code&gt;@doc&lt;/code&gt; 매크로에도 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e29764eb22ce628960d24b7b3d44fcb0f2a8006f" translate="yes" xml:space="preserve">
          <source>Documentation written in non-toplevel blocks, such as &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, and &lt;code&gt;let&lt;/code&gt;, is added to the documentation system as blocks are evaluated. For example:</source>
          <target state="translated">&lt;code&gt;begin&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; 및 &lt;code&gt;let&lt;/code&gt; 과 같은 최상위가 아닌 블록으로 작성된 문서는 블록이 평가 될 때 문서 시스템에 추가됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="09a6ee5d426664cb977432c68132607a67141e74" translate="yes" xml:space="preserve">
          <source>Documenting a &lt;code&gt;baremodule&lt;/code&gt; by placing a docstring above the expression automatically imports &lt;code&gt;@doc&lt;/code&gt; into the module. These imports must be done manually when the module expression is not documented. Empty &lt;code&gt;baremodule&lt;/code&gt;s cannot be documented.</source>
          <target state="translated">문서화 &lt;code&gt;baremodule&lt;/code&gt; 을 발현 참조 문 위에 배치함으로써 자동으로 가져 &lt;code&gt;@doc&lt;/code&gt; 를 모듈로. 이러한 가져 오기는 모듈 표현식이 문서화되지 않은 경우 수동으로 수행해야합니다. 비어있는 &lt;code&gt;baremodule&lt;/code&gt; 문서화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f1c8feebb8a44bc5cc0f0c846a0cafe1673c9da0" translate="yes" xml:space="preserve">
          <source>Does Not Contain As Member</source>
          <target state="translated">회원으로 포함되지 않음</target>
        </trans-unit>
        <trans-unit id="74e9b7a7bc4ad3a9d5021e1c8ba39f60a57b9c8c" translate="yes" xml:space="preserve">
          <source>Does Not Contain As Normal Subgroup</source>
          <target state="translated">일반 하위 그룹으로 포함되지 않음</target>
        </trans-unit>
        <trans-unit id="0df9d21ab128eedeaeee897e18031c8a630062be" translate="yes" xml:space="preserve">
          <source>Does Not Contain As Normal Subgroup Or Equal</source>
          <target state="translated">정상적인 하위 그룹으로 포함되지 않거나 동일하지 않음</target>
        </trans-unit>
        <trans-unit id="721845ae9c87c5bd1e7a959be4a879539ccf8539" translate="yes" xml:space="preserve">
          <source>Does Not Divide</source>
          <target state="translated">나누지 않는다</target>
        </trans-unit>
        <trans-unit id="c17ae6741920f232f1c4dcd981a0894fd4701fd6" translate="yes" xml:space="preserve">
          <source>Does Not Force</source>
          <target state="translated">강제하지 않습니다</target>
        </trans-unit>
        <trans-unit id="dc76e22dd1ef5959f4590996c3e850e4ccf3c6d5" translate="yes" xml:space="preserve">
          <source>Does Not Precede</source>
          <target state="translated">선행하지 않는다</target>
        </trans-unit>
        <trans-unit id="4431ed14e25542ca1903fbe4b11f8f7bc472370c" translate="yes" xml:space="preserve">
          <source>Does Not Precede Or Equal</source>
          <target state="translated">선행하거나 같지 않음</target>
        </trans-unit>
        <trans-unit id="91186e108fed6b3b33f14387bc2f31c57be5dd04" translate="yes" xml:space="preserve">
          <source>Does Not Prove</source>
          <target state="translated">증명하지 않는다</target>
        </trans-unit>
        <trans-unit id="55e9fb335c67326e83c89cc57e089d55541e089b" translate="yes" xml:space="preserve">
          <source>Does Not Succeed</source>
          <target state="translated">성공하지 못함</target>
        </trans-unit>
        <trans-unit id="864c65788d1e762c167b1c1749d733189def96f8" translate="yes" xml:space="preserve">
          <source>Does Not Succeed Or Equal</source>
          <target state="translated">성공하거나 같지 않다</target>
        </trans-unit>
        <trans-unit id="b866865be01a47a38a8b8e70d9eeb4d216a5889b" translate="yes" xml:space="preserve">
          <source>Dog</source>
          <target state="translated">Dog</target>
        </trans-unit>
        <trans-unit id="822ff2e44dfcb5851a482f2660f9271d7240e881" translate="yes" xml:space="preserve">
          <source>Dog Face</source>
          <target state="translated">강아지 얼굴</target>
        </trans-unit>
        <trans-unit id="b352a36f62c29eefc7c223c1e54b444dc8e064a4" translate="yes" xml:space="preserve">
          <source>Dolphin</source>
          <target state="translated">Dolphin</target>
        </trans-unit>
        <trans-unit id="dc77173b84d82a0765230e0c6ba75588bedb585c" translate="yes" xml:space="preserve">
          <source>Don't expose unsafe operations at the interface level</source>
          <target state="translated">인터페이스 수준에서 안전하지 않은 작업을 노출하지 마십시오</target>
        </trans-unit>
        <trans-unit id="c4688105e50f89983dad6151436e12d874f53866" translate="yes" xml:space="preserve">
          <source>Don't overload methods of base container types</source>
          <target state="translated">기본 컨테이너 유형의 메소드를 오버로드하지 마십시오</target>
        </trans-unit>
        <trans-unit id="62d0b49edcf8320dfc997b5ca5fb5ff7268edc1a" translate="yes" xml:space="preserve">
          <source>Don't overuse &lt;code&gt;...&lt;/code&gt;</source>
          <target state="translated">남용하지 마십시오 &lt;code&gt;...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1789c363ea41e44595afb63415ed7c18193fd84" translate="yes" xml:space="preserve">
          <source>Don't overuse macros</source>
          <target state="translated">매크로를 과도하게 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="a3e15a90504e4d80a1ded72545703d3f5a6fc9a2" translate="yes" xml:space="preserve">
          <source>Don't overuse try-catch</source>
          <target state="translated">try-catch를 과도하게 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="215b5f92cd2b36c13430ff90f6606631f634f2bc" translate="yes" xml:space="preserve">
          <source>Don't parenthesize conditions</source>
          <target state="translated">조건을 괄호로 묶지 마십시오</target>
        </trans-unit>
        <trans-unit id="2036ef4184745cfc73dab730959249e97cb41653" translate="yes" xml:space="preserve">
          <source>Don't use unnecessary static parameters</source>
          <target state="translated">불필요한 정적 매개 변수를 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="478d47b06dda44ac540199c073ea7b055bb29d18" translate="yes" xml:space="preserve">
          <source>Door</source>
          <target state="translated">Door</target>
        </trans-unit>
        <trans-unit id="ddd653c95e261e24af6fe24fd7e994e1b732c61e" translate="yes" xml:space="preserve">
          <source>Dot Minus</source>
          <target state="translated">도트 마이너스</target>
        </trans-unit>
        <trans-unit id="da4c9b7a4607f6acdefd66aa7034f05ebdd357f8" translate="yes" xml:space="preserve">
          <source>Dot Operator</source>
          <target state="translated">도트 연산자</target>
        </trans-unit>
        <trans-unit id="e46bcabadc79a669ff9fab524e27e4536bcce723" translate="yes" xml:space="preserve">
          <source>Dot Plus</source>
          <target state="translated">도트 플러스</target>
        </trans-unit>
        <trans-unit id="1e0712c9faa91162cb0a7e3519494eabc42057de" translate="yes" xml:space="preserve">
          <source>Dot Syntax for Vectorizing Functions</source>
          <target state="translated">벡터화 함수를위한 도트 구문</target>
        </trans-unit>
        <trans-unit id="8ec4c1c9e271c057f7f2ceb82454ca0b4248d7e0" translate="yes" xml:space="preserve">
          <source>Dot function for two complex vectors consisting of &lt;code&gt;n&lt;/code&gt; elements of array &lt;code&gt;X&lt;/code&gt; with stride &lt;code&gt;incx&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; elements of array &lt;code&gt;Y&lt;/code&gt; with stride &lt;code&gt;incy&lt;/code&gt;.</source>
          <target state="translated">이루어진 개의 복소 벡터의 도트 함수 &lt;code&gt;n&lt;/code&gt; 어레이의 요소 &lt;code&gt;X&lt;/code&gt; 스트라이드와 &lt;code&gt;incx&lt;/code&gt; 및 &lt;code&gt;n&lt;/code&gt; 개의 배열 요소 &lt;code&gt;Y&lt;/code&gt; 스트라이드와 &lt;code&gt;incy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6408bc206b479d599e65eaa3c639906fa5347eee" translate="yes" xml:space="preserve">
          <source>Dot function for two complex vectors, consisting of &lt;code&gt;n&lt;/code&gt; elements of array &lt;code&gt;X&lt;/code&gt; with stride &lt;code&gt;incx&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; elements of array &lt;code&gt;U&lt;/code&gt; with stride &lt;code&gt;incy&lt;/code&gt;, conjugating the first vector.</source>
          <target state="translated">두 개의 복소 벡터의 도트 함수로 이루어진 &lt;code&gt;n&lt;/code&gt; 개의 배열 요소 &lt;code&gt;X&lt;/code&gt; 스트라이드와 &lt;code&gt;incx&lt;/code&gt; 및 &lt;code&gt;n&lt;/code&gt; 개의 배열 요소 &lt;code&gt;U&lt;/code&gt; 스트라이드와 &lt;code&gt;incy&lt;/code&gt; 상기 제 1 벡터 공역.</target>
        </trans-unit>
        <trans-unit id="ae687eeec34004bd7083ef738bcbb2dfd35f355d" translate="yes" xml:space="preserve">
          <source>Dotted Circle</source>
          <target state="translated">점선 원</target>
        </trans-unit>
        <trans-unit id="9214357a4af6ad858e4d42896c3023c43dce64c9" translate="yes" xml:space="preserve">
          <source>Dotted Fence</source>
          <target state="translated">점선 울타리</target>
        </trans-unit>
        <trans-unit id="b81c82773994373a1d09d7aae50399f0672d3ba9" translate="yes" xml:space="preserve">
          <source>Dotted Square</source>
          <target state="translated">점선 사각형</target>
        </trans-unit>
        <trans-unit id="90b6dc25270ca8eeeb19a2a120979959174221d5" translate="yes" xml:space="preserve">
          <source>Double Colon Equal</source>
          <target state="translated">더블 콜론</target>
        </trans-unit>
        <trans-unit id="a97175043bff5b5c88676e311e52a67c0ae1d95b" translate="yes" xml:space="preserve">
          <source>Double Curly Loop</source>
          <target state="translated">더블 컬리 루프</target>
        </trans-unit>
        <trans-unit id="ce6ed1da949d6a90c7025acd0315d2ec7e76fdf2" translate="yes" xml:space="preserve">
          <source>Double Dagger</source>
          <target state="translated">더블 단검</target>
        </trans-unit>
        <trans-unit id="3ebfb9a6d6fb0aa10351fcdd8ebc9f2ad2e8e0b0" translate="yes" xml:space="preserve">
          <source>Double Exclamation Mark</source>
          <target state="translated">느낌표</target>
        </trans-unit>
        <trans-unit id="7206e7e84b3ec15528c9043d5518fb76c3d3b663" translate="yes" xml:space="preserve">
          <source>Double Integral</source>
          <target state="translated">이중 적분</target>
        </trans-unit>
        <trans-unit id="2f4ad5067d03e83537e91298699b3a861f6334a3" translate="yes" xml:space="preserve">
          <source>Double Intersection</source>
          <target state="translated">이중 교차점</target>
        </trans-unit>
        <trans-unit id="f63efa914d18f07e57920324f154194f8b80e71d" translate="yes" xml:space="preserve">
          <source>Double Logical And</source>
          <target state="translated">이중 논리 및</target>
        </trans-unit>
        <trans-unit id="31d51825a917859490089a0f53f017ee347ae47e" translate="yes" xml:space="preserve">
          <source>Double Logical Or</source>
          <target state="translated">이중 논리 또는</target>
        </trans-unit>
        <trans-unit id="54ca4b3ab79a1f77836fc85afeeb3989b5791f4d" translate="yes" xml:space="preserve">
          <source>Double Nested Greater-Than</source>
          <target state="translated">이중 중첩 큰 탄</target>
        </trans-unit>
        <trans-unit id="2dc2bf0b85cbb2ea7223a1949ab5e752de1aa1c3" translate="yes" xml:space="preserve">
          <source>Double Nested Greater-Than + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">이중 중첩 큰 탄 + 긴 고 상선 오버레이 / 비 간격 긴 슬래시 ​​오버레이</target>
        </trans-unit>
        <trans-unit id="aacb83632e682c3968d8b1ac37c74e451e5d43cb" translate="yes" xml:space="preserve">
          <source>Double Nested Less-Than</source>
          <target state="translated">이중 중첩 미만</target>
        </trans-unit>
        <trans-unit id="f99a04065879ed38c5083c8327002d7fd1bdcc2e" translate="yes" xml:space="preserve">
          <source>Double Nested Less-Than + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">더블 네스트리스 탠 + + 롱 솔리드 러스 오버레이 / 비 간격 롱 슬래시 오버레이 결합</target>
        </trans-unit>
        <trans-unit id="c646760ea02101dd2c78e156bd67fbc1e7939279" translate="yes" xml:space="preserve">
          <source>Double Nested Less-Than With Underbar</source>
          <target state="translated">언더 바가 포함 된 이중 중첩리스</target>
        </trans-unit>
        <trans-unit id="da273e33c1593b23cc1baf0841e4eb0696481ab6" translate="yes" xml:space="preserve">
          <source>Double Plus</source>
          <target state="translated">더블 플러스</target>
        </trans-unit>
        <trans-unit id="a4eb216c233e5e31eaaa029b5a6659a1175205bf" translate="yes" xml:space="preserve">
          <source>Double Precedes</source>
          <target state="translated">이중 전치사</target>
        </trans-unit>
        <trans-unit id="94596af0b897ecaa403e2b29d5442ffc485744fa" translate="yes" xml:space="preserve">
          <source>Double Prime</source>
          <target state="translated">더블 프라임</target>
        </trans-unit>
        <trans-unit id="d4bb3033b81e3e5bf5fe1b3d95ec1e84254a8648" translate="yes" xml:space="preserve">
          <source>Double Square Intersection</source>
          <target state="translated">더블 스퀘어 교차로</target>
        </trans-unit>
        <trans-unit id="1cdd297d02a50e98fc796a7bb474ae2cbf5b341e" translate="yes" xml:space="preserve">
          <source>Double Square Union</source>
          <target state="translated">더블 스퀘어 유니언</target>
        </trans-unit>
        <trans-unit id="8bec3a437a2b0935e9467004616a12d8b9bac5b1" translate="yes" xml:space="preserve">
          <source>Double Subset</source>
          <target state="translated">더블 서브 세트</target>
        </trans-unit>
        <trans-unit id="1f4f518e5cace96063fb6e4842b29d3c3a0bf8a6" translate="yes" xml:space="preserve">
          <source>Double Succeeds</source>
          <target state="translated">더블 성공</target>
        </trans-unit>
        <trans-unit id="f64b087e350913f39a60133fc102b9f0f94189cc" translate="yes" xml:space="preserve">
          <source>Double Superset</source>
          <target state="translated">더블 수퍼 셋</target>
        </trans-unit>
        <trans-unit id="ca2705c17942fca00d32bc39c06af31f76ecd340" translate="yes" xml:space="preserve">
          <source>Double Union</source>
          <target state="translated">더블 유니언</target>
        </trans-unit>
        <trans-unit id="f7eafda32018eb8216c74731243d8bcf503ebd15" translate="yes" xml:space="preserve">
          <source>Double Vertical Bar Double Right Turnstile</source>
          <target state="translated">두 배 수직 막대기 두 배 오른쪽 십자형 회전식 문</target>
        </trans-unit>
        <trans-unit id="4e0938d334e779c3d4385d240fa933a4aa60bab1" translate="yes" xml:space="preserve">
          <source>Double Vertical Bar Left Turnstile</source>
          <target state="translated">두 배 수직 막대기 좌 십자형 회전식 문</target>
        </trans-unit>
        <trans-unit id="bc9a2fa0502c305faf46fd54f952ef44d055b6f5" translate="yes" xml:space="preserve">
          <source>Double Vertical Line / Double Vertical Bar</source>
          <target state="translated">이중 수직선 / 이중 수직 막대</target>
        </trans-unit>
        <trans-unit id="0c24baa17889b7dd7c44e226a4bfc6668ff9bdeb" translate="yes" xml:space="preserve">
          <source>Double-Ended Multimap</source>
          <target state="translated">이중 종단 멀티 맵</target>
        </trans-unit>
        <trans-unit id="5fab79944c7fc8e86540423312b6958371754001" translate="yes" xml:space="preserve">
          <source>Double-Line Equal To Or Greater-Than</source>
          <target state="translated">이중선과 같거나 큰 것</target>
        </trans-unit>
        <trans-unit id="09e23fb3335770ae7a2fab59103015e6204ac1a9" translate="yes" xml:space="preserve">
          <source>Double-Line Equal To Or Less-Than</source>
          <target state="translated">이중 선 이하</target>
        </trans-unit>
        <trans-unit id="81443422e1dbb876dc01a2f2800e2f313209c209" translate="yes" xml:space="preserve">
          <source>Double-Line Slanted Equal To Or Greater-Than</source>
          <target state="translated">이중선 경사 또는 동등 이상</target>
        </trans-unit>
        <trans-unit id="298a11392e511e8c4817b6337e56afa525bb120d" translate="yes" xml:space="preserve">
          <source>Double-Line Slanted Equal To Or Less-Than</source>
          <target state="translated">이중선 경사 이하</target>
        </trans-unit>
        <trans-unit id="a39c2d49b33b8171f0335f4d62c054ebe50e2949" translate="yes" xml:space="preserve">
          <source>Double-Line Slanted Greater-Than Or Equal To</source>
          <target state="translated">이중선 경사보다 크거나 같음</target>
        </trans-unit>
        <trans-unit id="1a8936fc614fa8b11ad34af0ae168622fd04d79a" translate="yes" xml:space="preserve">
          <source>Double-Line Slanted Less-Than Or Equal To</source>
          <target state="translated">이중선 경사보다 작거나 같음</target>
        </trans-unit>
        <trans-unit id="5fcd17070ab099bf225ba4ec089d10cd5befd0d0" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital C / Double-Struck C</source>
          <target state="translated">이중 타격 자본 C / 이중 타격 C</target>
        </trans-unit>
        <trans-unit id="7fe3d74449be0c8a16270734ac281959d2434acb" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital Gamma</source>
          <target state="translated">이중 타격 자본 감마</target>
        </trans-unit>
        <trans-unit id="2bc51683b00bc656e8387c2a5971b20973b2e68d" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital H / Double-Struck H</source>
          <target state="translated">이중 타격 자본 H / 이중 타격 H</target>
        </trans-unit>
        <trans-unit id="77f2a8e846cb9408cb76519191f8677c811ec6c2" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital N / Double-Struck N</source>
          <target state="translated">이중 타격 자본 N / 이중 타격 N</target>
        </trans-unit>
        <trans-unit id="3d9ff0d995aa97605586bd26332422b375e0d4da" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital P / Double-Struck P</source>
          <target state="translated">이중 타격 자본 P / 이중 타격 P</target>
        </trans-unit>
        <trans-unit id="8e8bbccb682c6db82d059047113f028c1e9e4935" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital Pi</source>
          <target state="translated">이중 타격 자본 파이</target>
        </trans-unit>
        <trans-unit id="43fb013cca9c4a4a8b1a6e51423770297967de57" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital Q / Double-Struck Q</source>
          <target state="translated">이중 타격 자본 Q / 이중 타격 Q</target>
        </trans-unit>
        <trans-unit id="a7d9b7fa137bc84092b6dbae26b457a275ea3624" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital R / Double-Struck R</source>
          <target state="translated">이중 타격 자본 R / 이중 타격 R</target>
        </trans-unit>
        <trans-unit id="31b7923fbdad31f1ec3bcd8a5c5055fe73e937d5" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital Z / Double-Struck Z</source>
          <target state="translated">이중 타격 자본 Z / 이중 타격 Z</target>
        </trans-unit>
        <trans-unit id="22b10852f9529884fb8ade41480e3db571e4dab1" translate="yes" xml:space="preserve">
          <source>Double-Struck Italic Capital D</source>
          <target state="translated">이중 타격 이탤릭 대문자 D</target>
        </trans-unit>
        <trans-unit id="96df4e88f2bfb97c5cf111112b6793cdf4963d06" translate="yes" xml:space="preserve">
          <source>Double-Struck Italic Small D</source>
          <target state="translated">이중 타격 이탤릭체 작은 D</target>
        </trans-unit>
        <trans-unit id="0ba03aedaaff708d7df7636d4094ce50661bf52b" translate="yes" xml:space="preserve">
          <source>Double-Struck Italic Small E</source>
          <target state="translated">이중 타격 이탤릭체 소형 E</target>
        </trans-unit>
        <trans-unit id="33fd110b35ce2a0d08df3e940965ae2eec73859f" translate="yes" xml:space="preserve">
          <source>Double-Struck Italic Small I</source>
          <target state="translated">이중 타격 이탤릭체 작은 I</target>
        </trans-unit>
        <trans-unit id="e7b00a215e1cd74b1415dfeb4e53c76b770b6715" translate="yes" xml:space="preserve">
          <source>Double-Struck Italic Small J</source>
          <target state="translated">이중 타격 이탤릭체 작은 J</target>
        </trans-unit>
        <trans-unit id="78f6994be690e96f674586766d03abe261a0d6c0" translate="yes" xml:space="preserve">
          <source>Double-Struck N-Ary Summation</source>
          <target state="translated">이중 타격 N-Ary 요약</target>
        </trans-unit>
        <trans-unit id="7522a251652bf308c1e54e228103454ad9e38cf3" translate="yes" xml:space="preserve">
          <source>Double-Struck Small Gamma</source>
          <target state="translated">이중 타격 작은 감마</target>
        </trans-unit>
        <trans-unit id="e9209c0ddacbb74a712ae08d417871541bc2ed5d" translate="yes" xml:space="preserve">
          <source>Double-Struck Small Pi</source>
          <target state="translated">이중 타격 소형 파이</target>
        </trans-unit>
        <trans-unit id="e32b900891654ad41d9a370dd7666e75c72537ec" translate="yes" xml:space="preserve">
          <source>Doughnut</source>
          <target state="translated">Doughnut</target>
        </trans-unit>
        <trans-unit id="74b33dde33775abd34211cfb4e20f9d6bde3c7a7" translate="yes" xml:space="preserve">
          <source>Down Right Diagonal Ellipsis</source>
          <target state="translated">오른쪽 대각선 줄임표</target>
        </trans-unit>
        <trans-unit id="b621fc7da134ad1633ff77f53544dd0b2c6c5e6d" translate="yes" xml:space="preserve">
          <source>Down Tack</source>
          <target state="translated">다운 택</target>
        </trans-unit>
        <trans-unit id="05c8ca1a817444b080cfc3aca96ff10f7d2bd3d0" translate="yes" xml:space="preserve">
          <source>Down arrow, &lt;code&gt;^N&lt;/code&gt;</source>
          <target state="translated">아래쪽 화살표, &lt;code&gt;^N&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c538452cf7c33c2e1a7c6f852e565ccc86225406" translate="yes" xml:space="preserve">
          <source>Down-Pointing Red Triangle</source>
          <target state="translated">아래쪽 빨간색 삼각형</target>
        </trans-unit>
        <trans-unit id="8bfd316beaffb49e3a9febd43df2eb2cb5afaace" translate="yes" xml:space="preserve">
          <source>Down-Pointing Small Red Triangle</source>
          <target state="translated">아래쪽 작은 빨간색 삼각형</target>
        </trans-unit>
        <trans-unit id="17cff6f253715144bf846cc6cb0ca961d48c99f6" translate="yes" xml:space="preserve">
          <source>Downdate a Cholesky factorization &lt;code&gt;C&lt;/code&gt; with the vector &lt;code&gt;v&lt;/code&gt;. If &lt;code&gt;A = C.U'C.U&lt;/code&gt; then &lt;code&gt;CC = cholesky(C.U'C.U - v*v')&lt;/code&gt; but the computation of &lt;code&gt;CC&lt;/code&gt; only uses &lt;code&gt;O(n^2)&lt;/code&gt; operations.</source>
          <target state="translated">벡터 &lt;code&gt;v&lt;/code&gt; 로 hole 레 스키 인수 분해 &lt;code&gt;C&lt;/code&gt; 를 다운 데이트하십시오 . 경우 &lt;code&gt;A = C.U'C.U&lt;/code&gt; 다음 &lt;code&gt;CC = cholesky(C.U'C.U - v*v')&lt;/code&gt; 그러나의 계산 &lt;code&gt;CC&lt;/code&gt; 는 단지 사용 &lt;code&gt;O(n^2)&lt;/code&gt; 동작.</target>
        </trans-unit>
        <trans-unit id="b97c3860e18211639f16883b11f27c780f8f632f" translate="yes" xml:space="preserve">
          <source>Downdate a Cholesky factorization &lt;code&gt;C&lt;/code&gt; with the vector &lt;code&gt;v&lt;/code&gt;. If &lt;code&gt;A = C.U'C.U&lt;/code&gt; then &lt;code&gt;CC = cholesky(C.U'C.U - v*v')&lt;/code&gt; but the computation of &lt;code&gt;CC&lt;/code&gt; only uses &lt;code&gt;O(n^2)&lt;/code&gt; operations. The input factorization &lt;code&gt;C&lt;/code&gt; is updated in place such that on exit &lt;code&gt;C == CC&lt;/code&gt;. The vector &lt;code&gt;v&lt;/code&gt; is destroyed during the computation.</source>
          <target state="translated">벡터 &lt;code&gt;v&lt;/code&gt; 로 hole 레 스키 인수 분해 &lt;code&gt;C&lt;/code&gt; 를 다운 데이트하십시오 . 경우 &lt;code&gt;A = C.U'C.U&lt;/code&gt; 다음 &lt;code&gt;CC = cholesky(C.U'C.U - v*v')&lt;/code&gt; 그러나의 계산 &lt;code&gt;CC&lt;/code&gt; 는 단지 사용 &lt;code&gt;O(n^2)&lt;/code&gt; 동작. 입력 인수 분해 &lt;code&gt;C&lt;/code&gt; 는 종료 &lt;code&gt;C == CC&lt;/code&gt; 가되도록 업데이트됩니다 . 벡터 &lt;code&gt;v&lt;/code&gt; 는 계산 중에 파괴됩니다.</target>
        </trans-unit>
        <trans-unit id="d64fb6577c643a1a98bcc4d17dd77adc7d4f3749" translate="yes" xml:space="preserve">
          <source>Download a file from the given url, optionally renaming it to the given local file name. If no filename is given this will download into a randomly-named file in your temp directory. Note that this function relies on the availability of external tools such as &lt;code&gt;curl&lt;/code&gt;, &lt;code&gt;wget&lt;/code&gt; or &lt;code&gt;fetch&lt;/code&gt; to download the file and is provided for convenience. For production use or situations in which more options are needed, please use a package that provides the desired functionality instead.</source>
          <target state="translated">제공된 URL에서 파일을 다운로드하고 선택적으로 지정된 로컬 파일 이름으로 이름을 바꿉니다. 파일 이름을 지정하지 않으면 임시 디렉토리의 무작위로 이름이 지정된 파일로 다운로드됩니다. 이 기능은 &lt;code&gt;curl&lt;/code&gt; , &lt;code&gt;wget&lt;/code&gt; 또는 &lt;code&gt;fetch&lt;/code&gt; 와 같은 외부 도구를 사용 하여 파일을 다운로드 할 수 있으며 편의를 위해 제공됩니다. 프로덕션 사용 또는 추가 옵션이 필요한 상황에서는 원하는 기능을 제공하는 패키지를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="08c3c7d3645a4ce6730f3721ad47fc2949dc976a" translate="yes" xml:space="preserve">
          <source>Downwards Arrow / Down Arrow</source>
          <target state="translated">아래쪽 화살표 / 아래쪽 화살표</target>
        </trans-unit>
        <trans-unit id="7dce0d557028c5dea3dace158554e15d9784698b" translate="yes" xml:space="preserve">
          <source>Downwards Arrow From Bar / Down Arrow From Bar</source>
          <target state="translated">바에서 아래쪽 화살표 / 바에서 아래쪽 화살표</target>
        </trans-unit>
        <trans-unit id="0d1345aef883b3624d484df6c78fa1499f363962" translate="yes" xml:space="preserve">
          <source>Downwards Arrow Leftwards Of Upwards Arrow</source>
          <target state="translated">아래쪽 화살표 위쪽 화살표의 왼쪽</target>
        </trans-unit>
        <trans-unit id="2156bac33a07bff1c6168c184044e461147f3221" translate="yes" xml:space="preserve">
          <source>Downwards Arrow To Bar</source>
          <target state="translated">아래쪽 화살표 막대</target>
        </trans-unit>
        <trans-unit id="6a3f0e1b85e70e46f52c461b297ce3b234dd2b8e" translate="yes" xml:space="preserve">
          <source>Downwards Arrow With Corner Leftwards / Down Arrow With Corner Left</source>
          <target state="translated">모서리가 왼쪽 인 아래쪽 화살표 / 모서리가 왼쪽 인 아래쪽 화살표</target>
        </trans-unit>
        <trans-unit id="22f12c6b38c168555c766d9ecd689bee73798e7b" translate="yes" xml:space="preserve">
          <source>Downwards Arrow With Double Stroke / Down Arrow With Double Stroke</source>
          <target state="translated">이중 스트로크가있는 아래쪽 화살표 / 이중 스트로크가있는 아래쪽 화살표</target>
        </trans-unit>
        <trans-unit id="3e70b3fbb5e1272dbfb2768c6abc80ebc34f5538" translate="yes" xml:space="preserve">
          <source>Downwards Arrow With Horizontal Stroke</source>
          <target state="translated">수평 스트로크가있는 아래쪽 화살표</target>
        </trans-unit>
        <trans-unit id="c1bc962d484f0e77f2bb2b3688fdfa2d1422bc61" translate="yes" xml:space="preserve">
          <source>Downwards Arrow With Tip Leftwards / Down Arrow With Tip Left</source>
          <target state="translated">팁이 왼쪽 인 아래쪽 화살표 / 팁이 왼쪽 인 아래쪽 화살표</target>
        </trans-unit>
        <trans-unit id="6f17c4c1d048a9705300c820118cf36a53d197eb" translate="yes" xml:space="preserve">
          <source>Downwards Arrow With Tip Rightwards / Down Arrow With Tip Right</source>
          <target state="translated">오른쪽 화살표가있는 아래쪽 화살표 / 오른쪽 화살표가있는 아래쪽 화살표</target>
        </trans-unit>
        <trans-unit id="77827f24b06007c8351d7b42f91be0b4d539c6de" translate="yes" xml:space="preserve">
          <source>Downwards Black Arrow</source>
          <target state="translated">아래쪽 검은 색 화살표</target>
        </trans-unit>
        <trans-unit id="b75b010ebb988c0b894244b49f47de83c298a210" translate="yes" xml:space="preserve">
          <source>Downwards Dashed Arrow / Down Dashed Arrow</source>
          <target state="translated">아래쪽 화살표 / 아래쪽 화살표</target>
        </trans-unit>
        <trans-unit id="b052c2e01abe8207481638ce404112cf6c895155" translate="yes" xml:space="preserve">
          <source>Downwards Double Arrow / Down Double Arrow</source>
          <target state="translated">아래쪽 이중 화살표 / 아래쪽 이중 화살표</target>
        </trans-unit>
        <trans-unit id="39618206cc6f04a2548c6e3a46f1c96431d17934" translate="yes" xml:space="preserve">
          <source>Downwards Harpoon With Barb Left Beside Downwards Harpoon With Barb Right</source>
          <target state="translated">바브가있는 아래쪽 작살 바브가있는 아래쪽 작살</target>
        </trans-unit>
        <trans-unit id="61e7d9beabf27ce96043173d50a1ffbcb3c8f195" translate="yes" xml:space="preserve">
          <source>Downwards Harpoon With Barb Left Beside Upwards Harpoon With Barb Right</source>
          <target state="translated">바브가있는 아래쪽 작살 바브가있는 위쪽 작살</target>
        </trans-unit>
        <trans-unit id="8f99b76aec3d61f79f81cc67881ebb3880b49671" translate="yes" xml:space="preserve">
          <source>Downwards Harpoon With Barb Left From Bar</source>
          <target state="translated">바에서 왼쪽 바브로 아래쪽 작살</target>
        </trans-unit>
        <trans-unit id="0a957078126f861ff70d4cccc6ee4961501ca412" translate="yes" xml:space="preserve">
          <source>Downwards Harpoon With Barb Left To Bar</source>
          <target state="translated">왼쪽 막대가있는 아래쪽 작살</target>
        </trans-unit>
        <trans-unit id="20016dc34aed751d644d5eba1c2ce94f4ccb571f" translate="yes" xml:space="preserve">
          <source>Downwards Harpoon With Barb Leftwards / Down Harpoon With Barb Left</source>
          <target state="translated">왼쪽으로 바브가있는 아래쪽 작살 / 왼쪽으로 바브가있는 아래쪽 작살</target>
        </trans-unit>
        <trans-unit id="43ff08d740eada07edb33d8b4d43a32fe54cdb0c" translate="yes" xml:space="preserve">
          <source>Downwards Harpoon With Barb Right From Bar</source>
          <target state="translated">바에서 바로 바브와 함께 아래쪽으로 작살</target>
        </trans-unit>
        <trans-unit id="fdcd989ee2f4eed7638bcc66aefc50676e2d0de3" translate="yes" xml:space="preserve">
          <source>Downwards Harpoon With Barb Right To Bar</source>
          <target state="translated">바 오른쪽 바를 가진 아래쪽으로 작살</target>
        </trans-unit>
        <trans-unit id="70698ae85402133e06db357acf28e4adb5132348" translate="yes" xml:space="preserve">
          <source>Downwards Harpoon With Barb Rightwards / Down Harpoon With Barb Right</source>
          <target state="translated">오른쪽 바브가있는 아래쪽 작살 / 오른쪽 바브가있는 아래쪽 작살</target>
        </trans-unit>
        <trans-unit id="e991bdc2966ff71e9f056a8cb1f209c18137ee66" translate="yes" xml:space="preserve">
          <source>Downwards Paired Arrows / Down Paired Arrows</source>
          <target state="translated">아래쪽 화살표 / 아래쪽 화살표</target>
        </trans-unit>
        <trans-unit id="708fb5fb1095e517bca56d05c3a07607b86eea24" translate="yes" xml:space="preserve">
          <source>Downwards Quadruple Arrow</source>
          <target state="translated">하향 쿼드 러플 화살표</target>
        </trans-unit>
        <trans-unit id="7832bc44c221f296a0a3557341bf5711ce0ad13e" translate="yes" xml:space="preserve">
          <source>Downwards Triple Arrow</source>
          <target state="translated">아래쪽 트리플 화살표</target>
        </trans-unit>
        <trans-unit id="71c2a3e9e5d53ca7e448be0dc997a3840d8ffbe4" translate="yes" xml:space="preserve">
          <source>Downwards Two Headed Arrow / Down Two Headed Arrow</source>
          <target state="translated">아래쪽으로 향하는 화살표 / 아래쪽으로 향하는 화살표</target>
        </trans-unit>
        <trans-unit id="20bd273f7536e79d1e647c7a4805a10cc0a6024f" translate="yes" xml:space="preserve">
          <source>Downwards White Arrow / White Down Arrow</source>
          <target state="translated">아래쪽 흰색 화살표 / 흰색 아래쪽 화살표</target>
        </trans-unit>
        <trans-unit id="dee70c16d9a7402c3ff7c179d417c02524182f20" translate="yes" xml:space="preserve">
          <source>Downwards Zigzag Arrow / Down Zigzag Arrow</source>
          <target state="translated">아래쪽 지그재그 화살표 / 아래쪽 지그재그 화살표</target>
        </trans-unit>
        <trans-unit id="0f0c13b35658b4610aac908bd6f900baccfacc2c" translate="yes" xml:space="preserve">
          <source>Drafting Point Rightwards Arrow / Drafting Point Right Arrow</source>
          <target state="translated">제도 점 오른쪽 화살표 / 제도 점 오른쪽 화살표</target>
        </trans-unit>
        <trans-unit id="eb22c5e28adf024cfee08804c00ddb9ac2973892" translate="yes" xml:space="preserve">
          <source>Dragon</source>
          <target state="translated">Dragon</target>
        </trans-unit>
        <trans-unit id="b1d5fd0950f3316f4c616ebe016d1f72cbdff89e" translate="yes" xml:space="preserve">
          <source>Dragon Face</source>
          <target state="translated">용의 얼굴</target>
        </trans-unit>
        <trans-unit id="f61e33bf74dc6cb23e31a4742f4452d5d238daaf" translate="yes" xml:space="preserve">
          <source>Dress</source>
          <target state="translated">Dress</target>
        </trans-unit>
        <trans-unit id="eaae1cbe655bd67615f32293502367c2637ee817" translate="yes" xml:space="preserve">
          <source>Dromedary Camel</source>
          <target state="translated">단봉 낙타</target>
        </trans-unit>
        <trans-unit id="f9b83daeec2460cd138ef6a2f12cc6f1f9046683" translate="yes" xml:space="preserve">
          <source>Droplet</source>
          <target state="translated">Droplet</target>
        </trans-unit>
        <trans-unit id="4743db582f1472d30e534715a34bc56d951fe4b6" translate="yes" xml:space="preserve">
          <source>Due to the colloquial usage of &lt;code&gt;sha256&lt;/code&gt; to refer to &lt;code&gt;sha2_256&lt;/code&gt;, convenience functions are provided, mapping &lt;code&gt;shaxxx()&lt;/code&gt; function calls to &lt;code&gt;sha2_xxx()&lt;/code&gt;. For SHA-3, no such colloquialisms exist and the user must use the full &lt;code&gt;sha3_xxx()&lt;/code&gt; names.</source>
          <target state="translated">&lt;code&gt;sha2_256&lt;/code&gt; 을 참조하는 &lt;code&gt;sha256&lt;/code&gt; 의 구어체 사용으로 인해 &lt;code&gt;shaxxx()&lt;/code&gt; 함수 호출을 &lt;code&gt;sha2_xxx()&lt;/code&gt; 맵핑하는 편리한 함수가 제공됩니다 . SHA-3의 경우 이러한 구어체가 없으며 사용자는 전체 &lt;code&gt;sha3_xxx()&lt;/code&gt; 이름을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2ede46a500ade748ac355337b865cbc0acd19bf6" translate="yes" xml:space="preserve">
          <source>Durations/Comparisons</source>
          <target state="translated">Durations/Comparisons</target>
        </trans-unit>
        <trans-unit id="9dfdb39c23a955cc3f51336a0530f2307a456f87" translate="yes" xml:space="preserve">
          <source>Dvd</source>
          <target state="translated">Dvd</target>
        </trans-unit>
        <trans-unit id="34b40a7ef9ec304a622a57c3ab20b2c39518c944" translate="yes" xml:space="preserve">
          <source>Dynamic Linker</source>
          <target state="translated">동적 링커</target>
        </trans-unit>
        <trans-unit id="dc0def730e20d274cc00210435f7d12be805f16c" translate="yes" xml:space="preserve">
          <source>Dynamic documentation</source>
          <target state="translated">동적 문서</target>
        </trans-unit>
        <trans-unit id="085752d538f762ff5754a9aa26842e80bb0818e2" translate="yes" xml:space="preserve">
          <source>E-Mail Symbol</source>
          <target state="translated">이메일 기호</target>
        </trans-unit>
        <trans-unit id="7e7d5355c188b846aca335184bbeb5367a48b580" translate="yes" xml:space="preserve">
          <source>E.g., if &lt;code&gt;A&lt;/code&gt; is a matrix, &lt;code&gt;dims=1&lt;/code&gt; will sort rows, &lt;code&gt;dims=2&lt;/code&gt; will sort columns. Note that the default comparison function on one dimensional slices sorts lexicographically.</source>
          <target state="translated">예를 들어, &lt;code&gt;A&lt;/code&gt; 가 행렬이면 &lt;code&gt;dims=1&lt;/code&gt; 은 행을 정렬하고 &lt;code&gt;dims=2&lt;/code&gt; 는 열을 정렬합니다. 1 차원 슬라이스의 기본 비교 함수는 사전 식으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="1c8872365c161a3e67efcc3a61e6bdd7bd82ccf5" translate="yes" xml:space="preserve">
          <source>ENDIAN_BOM</source>
          <target state="translated">ENDIAN_BOM</target>
        </trans-unit>
        <trans-unit id="086bfb42cb0e1f0682c42f25c92a8f7e76b5bda4" translate="yes" xml:space="preserve">
          <source>ENV</source>
          <target state="translated">ENV</target>
        </trans-unit>
        <trans-unit id="7b9e6e531c95a34720d1a8d1d5a2c5f1c560afeb" translate="yes" xml:space="preserve">
          <source>EOFError</source>
          <target state="translated">EOFError</target>
        </trans-unit>
        <trans-unit id="6c745d78cc4826efc22c10c011aab3cf174ad141" translate="yes" xml:space="preserve">
          <source>Each &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackFrame&quot;&gt;&lt;code&gt;StackTraces.StackFrame&lt;/code&gt;&lt;/a&gt; contains the function name, file name, line number, lambda info, a flag indicating whether the frame has been inlined, a flag indicating whether it is a C function (by default C functions do not appear in the stack trace), and an integer representation of the pointer returned by &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt;&lt;code&gt;backtrace&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">각 &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackFrame&quot;&gt; &lt;code&gt;StackTraces.StackFrame&lt;/code&gt; &lt;/a&gt; 에는 함수 이름, 파일 이름, 줄 번호, 람다 정보, 프레임이 인라인되었는지 여부를 나타내는 플래그, 프레임이 C 함수인지 여부를 나타내는 플래그 (기본적으로 C 함수가 스택 추적에 나타나지 않음)가 있습니다. , &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt; &lt;code&gt;backtrace&lt;/code&gt; 가&lt;/a&gt; 반환 한 포인터의 정수 표현 :</target>
        </trans-unit>
        <trans-unit id="4b43a1b63da011682c91ea2326629ce626a8f4ec" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;ArgumentValue&lt;/code&gt; to &lt;code&gt;llvmcall&lt;/code&gt; will be converted to the corresponding &lt;code&gt;ArgumentType&lt;/code&gt;, by automatic insertion of calls to &lt;code&gt;unsafe_convert(ArgumentType, cconvert(ArgumentType, ArgumentValue))&lt;/code&gt;. (See also the documentation for &lt;a href=&quot;#Base.unsafe_convert&quot;&gt;&lt;code&gt;unsafe_convert&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.cconvert&quot;&gt;&lt;code&gt;cconvert&lt;/code&gt;&lt;/a&gt; for further details.) In most cases, this simply results in a call to &lt;code&gt;convert(ArgumentType, ArgumentValue)&lt;/code&gt;.</source>
          <target state="translated">각 &lt;code&gt;ArgumentValue&lt;/code&gt; 에 &lt;code&gt;llvmcall&lt;/code&gt; 는 해당 변환한다 &lt;code&gt;ArgumentType&lt;/code&gt; 에 호출을 자동 삽입함으로써 &lt;code&gt;unsafe_convert(ArgumentType, cconvert(ArgumentType, ArgumentValue))&lt;/code&gt; . (자세한 내용은 &lt;a href=&quot;#Base.unsafe_convert&quot;&gt; &lt;code&gt;unsafe_convert&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#Base.cconvert&quot;&gt; &lt;code&gt;cconvert&lt;/code&gt; &lt;/a&gt; 설명서를 참조 하십시오.) 대부분의 경우 단순히 &lt;code&gt;convert(ArgumentType, ArgumentValue)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="16639880e3d78941c163af0b97ffa26b4ba639e4" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;argvalue&lt;/code&gt; to the &lt;code&gt;ccall&lt;/code&gt; will be converted to the corresponding &lt;code&gt;argtype&lt;/code&gt;, by automatic insertion of calls to &lt;code&gt;unsafe_convert(argtype, cconvert(argtype, argvalue))&lt;/code&gt;. (See also the documentation for &lt;a href=&quot;#Base.unsafe_convert&quot;&gt;&lt;code&gt;unsafe_convert&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.cconvert&quot;&gt;&lt;code&gt;cconvert&lt;/code&gt;&lt;/a&gt; for further details.) In most cases, this simply results in a call to &lt;code&gt;convert(argtype, argvalue)&lt;/code&gt;.</source>
          <target state="translated">각 &lt;code&gt;argvalue&lt;/code&gt; 받는 &lt;code&gt;ccall&lt;/code&gt; 는 해당 변환한다 &lt;code&gt;argtype&lt;/code&gt; 자동 호출 삽입하여 &lt;code&gt;unsafe_convert(argtype, cconvert(argtype, argvalue))&lt;/code&gt; . (자세한 내용은 &lt;a href=&quot;#Base.unsafe_convert&quot;&gt; &lt;code&gt;unsafe_convert&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#Base.cconvert&quot;&gt; &lt;code&gt;cconvert&lt;/code&gt; &lt;/a&gt; 설명서를 참조 하십시오.) 대부분의 경우 단순히 &lt;code&gt;convert(argtype, argvalue)&lt;/code&gt; 호출이 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="87cceae9fc7cfd4af0f8243a86a72515045e2992" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;lock&lt;/code&gt; must be matched by an &lt;a href=&quot;#Base.unlock&quot;&gt;&lt;code&gt;unlock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">각 &lt;code&gt;lock&lt;/code&gt; 는 &lt;a href=&quot;#Base.unlock&quot;&gt; &lt;code&gt;unlock&lt;/code&gt; &lt;/a&gt; 와 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6a58a43e2467e832b243587c5b856d542f30f944" translate="yes" xml:space="preserve">
          <source>Each Julia process thus has 31 communication tasks.</source>
          <target state="translated">따라서 각 Julia 프로세스에는 31 개의 통신 작업이 있습니다.</target>
        </trans-unit>
        <trans-unit id="90eeb77500114235cd36d8d57b969eb1e5584ef6" translate="yes" xml:space="preserve">
          <source>Each event generates several pieces of data, some provided by the user and some automatically extracted. Let's examine the user-defined data first:</source>
          <target state="translated">각 이벤트는 몇 가지 데이터를 생성하며 일부는 사용자가 제공하고 일부는 자동으로 추출됩니다. 먼저 사용자 정의 데이터를 살펴 보자.</target>
        </trans-unit>
        <trans-unit id="6afa6a3549818bce117962a7026f18062cf8f803" translate="yes" xml:space="preserve">
          <source>Each exported function (at the time of this writing, SHA-1, SHA-2 224, 256, 384 and 512, and SHA-3 224, 256, 384 and 512 functions are implemented) takes in either an &lt;code&gt;Array{UInt8}&lt;/code&gt;, a &lt;code&gt;ByteString&lt;/code&gt; or an &lt;code&gt;IO&lt;/code&gt; object. This makes it trivial to checksum a file:</source>
          <target state="translated">(이 기입시, (384) 및 (512)의 기능이 구현되는 SHA-1, SHA-2 (224), 256, 384, 512 및 SHA-3 224, 256) 각각의 수출 기능은 어느 취하는 &lt;code&gt;Array{UInt8}&lt;/code&gt; , &lt;code&gt;ByteString&lt;/code&gt; 또는 &lt;code&gt;IO&lt;/code&gt; 의 객체입니다. 이렇게하면 파일을 체크섬하는 것이 쉽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a27894f5ec437e16c54a81d270d486f77eb240c6" translate="yes" xml:space="preserve">
          <source>Each kind of environment defines these three maps differently, as detailed in the following sections.</source>
          <target state="translated">각 환경에서는 다음 섹션에서 자세히 설명하는 것처럼이 세 가지 맵을 다르게 정의합니다.</target>
        </trans-unit>
        <trans-unit id="1ff693f28cccaa9f352f467474efbdadbcecc29f" translate="yes" xml:space="preserve">
          <source>Each line of this display represents a particular spot (line number) in the code. Indentation is used to indicate the nested sequence of function calls, with more-indented lines being deeper in the sequence of calls. In each line, the first &quot;field&quot; is the number of backtraces (samples) taken &lt;em&gt;at this line or in any functions executed by this line&lt;/em&gt;. The second field is the file name and line number and the third field is the function name. Note that the specific line numbers may change as Julia's code changes; if you want to follow along, it's best to run this example yourself.</source>
          <target state="translated">이 디스플레이의 각 줄은 코드에서 특정 지점 (줄 번호)을 나타냅니다. 들여 쓰기는 중첩 된 함수 호출 시퀀스를 나타내는 데 사용되며,보다 들여 쓰기 된 행은 호출 시퀀스에서 더 깊습니다. 각 라인에서 첫 번째 &quot;필드&quot;는 &lt;em&gt;이 라인 또는이 라인이 실행하는 모든 함수에서&lt;/em&gt; 가져온 역 추적 (샘플) 수입니다 . 두 번째 필드는 파일 이름과 줄 번호이고 세 번째 필드는 함수 이름입니다. Julia의 코드가 변경되면 특정 행 번호가 변경 될 수 있습니다. 따라하고 싶다면이 예제를 직접 실행하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="01a2902c277d245e34b708c7aa314c4d33622ac3" translate="yes" xml:space="preserve">
          <source>Each method of a generated function has its own view of defined functions:</source>
          <target state="translated">생성 된 함수의 각 메소드에는 자체 정의 된 함수보기가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3717f137bf0edf07318a78ca822c93213e8ab5c5" translate="yes" xml:space="preserve">
          <source>Each module introduces a new global scope, separate from the global scope of all other modules; there is no all-encompassing global scope. Modules can introduce variables of other modules into their scope through the &lt;a href=&quot;../modules/index#modules-1&quot;&gt;using or import&lt;/a&gt; statements or through qualified access using the dot-notation, i.e. each module is a so-called &lt;em&gt;namespace&lt;/em&gt;. Note that variable bindings can only be changed within their global scope and not from an outside module.</source>
          <target state="translated">각 모듈은 다른 모든 모듈의 글로벌 범위와 별도로 새로운 글로벌 범위를 도입합니다. 포괄적 인 글로벌 범위는 없습니다. 모듈은 &lt;a href=&quot;../modules/index#modules-1&quot;&gt;using 또는 import&lt;/a&gt; 문을 사용하거나 점 표기법을 사용하는 정규화 된 액세스를 통해 다른 모듈의 변수를 범위에 도입 할 수 있습니다 . 즉, 각 모듈은 &lt;em&gt;네임 스페이스&lt;/em&gt; 입니다. 변수 바인딩은 전역 범위 내에서만 변경할 수 있으며 외부 모듈에서는 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bf0da81b3dc87a0fd15f25539852984a31877c54" translate="yes" xml:space="preserve">
          <source>Each process has an associated identifier. The process providing the interactive Julia prompt always has an &lt;code&gt;id&lt;/code&gt; equal to 1. The processes used by default for parallel operations are referred to as &quot;workers&quot;. When there is only one process, process 1 is considered a worker. Otherwise, workers are considered to be all processes other than process 1.</source>
          <target state="translated">각 프로세스에는 관련 식별자가 있습니다. 대화 형 Julia 프롬프트를 제공하는 프로세스의 &lt;code&gt;id&lt;/code&gt; 는 항상 1입니다. 병렬 작업에 기본적으로 사용되는 프로세스를 &quot;작업자&quot;라고합니다. 프로세스가 하나만있는 경우 프로세스 1은 작업자로 간주됩니다. 그렇지 않으면 작업자는 프로세스 1 이외의 모든 프로세스로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="4df120cd43c18561cb64b8f7f625bd660e549595" translate="yes" xml:space="preserve">
          <source>Each scope must have only one call to &lt;code&gt;JL_GC_PUSH*&lt;/code&gt;. Hence, if all variables cannot be pushed once by a single call to &lt;code&gt;JL_GC_PUSH*&lt;/code&gt;, or if there are more than 6 variables to be pushed and using an array of arguments is not an option, then one can use inner blocks:</source>
          <target state="translated">각 범위에는 &lt;code&gt;JL_GC_PUSH*&lt;/code&gt; 호출이 하나만 있어야합니다 . 따라서 &lt;code&gt;JL_GC_PUSH*&lt;/code&gt; 에 대한 단일 호출로 모든 변수를 한 번 푸시 할 수 없거나 푸시 할 변수 가 6 개 이상이고 인수 배열을 사용하는 것이 옵션이 아닌 경우 내부 블록을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d282bb8a2c865839d970ad58b137b93bc00c7f72" translate="yes" xml:space="preserve">
          <source>Each successful &lt;code&gt;trylock&lt;/code&gt; must be matched by an &lt;a href=&quot;#Base.unlock&quot;&gt;&lt;code&gt;unlock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">성공한 각 &lt;code&gt;trylock&lt;/code&gt; 은 &lt;a href=&quot;#Base.unlock&quot;&gt; &lt;code&gt;unlock&lt;/code&gt; &lt;/a&gt; 과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="22844561d348de2a6b27cf89433a65f8efbcb6b9" translate="yes" xml:space="preserve">
          <source>Each task handles all incoming messages from a single remote worker in a message-processing loop.</source>
          <target state="translated">각 작업은 단일 원격 작업자의 모든 수신 메시지를 메시지 처리 루프에서 처리합니다.</target>
        </trans-unit>
        <trans-unit id="959d90366413778f223799834532da2e5d798af8" translate="yes" xml:space="preserve">
          <source>Each worker binds to only one of the local interfaces and listens on an ephemeral port number assigned by the OS.</source>
          <target state="translated">각 작업자는 로컬 인터페이스 중 하나에 만 바인딩하고 OS에서 할당 한 임시 포트 번호를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="7f33a61e2ebfeda0d2e414fecf682c309512f02f" translate="yes" xml:space="preserve">
          <source>Each worker connects to all workers whose &lt;code&gt;id&lt;/code&gt; is less than the worker's own &lt;code&gt;id&lt;/code&gt;.</source>
          <target state="translated">각 근로자는 자신의 &lt;code&gt;id&lt;/code&gt; 보다 &lt;code&gt;id&lt;/code&gt; 가 작은 모든 근로자에게 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="296ff54bedf2c4c2f12fadf9f3d4dae7319b0178" translate="yes" xml:space="preserve">
          <source>Each worker starts listening on a free port and writes out its host and port information to &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">각 작업자는 사용 가능한 포트에서 청취를 시작하고 호스트 및 포트 정보를 &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; 에&lt;/a&gt; 씁니다 .</target>
        </trans-unit>
        <trans-unit id="d4b6573c03375a2d09bcdcc1d5adf31597eebb48" translate="yes" xml:space="preserve">
          <source>Eagerly evaluate the lazy matrix transpose/adjoint. Note that the transposition is applied recursively to elements.</source>
          <target state="translated">게으른 매트릭스 전치 / 접근을 열심히 평가합니다. 조옮김은 요소에 재귀 적으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="27b938020515cf5bb6d2984093bfbe7ab6d70ad5" translate="yes" xml:space="preserve">
          <source>Ear</source>
          <target state="translated">Ear</target>
        </trans-unit>
        <trans-unit id="f97bff7e2b8198bfce99e20d9dc3037ca7cb582c" translate="yes" xml:space="preserve">
          <source>Ear Of Maize</source>
          <target state="translated">옥수수의 귀</target>
        </trans-unit>
        <trans-unit id="3d9d70794f61bff1149af95c6f4cc244fdd11015" translate="yes" xml:space="preserve">
          <source>Ear Of Rice</source>
          <target state="translated">쌀 귀</target>
        </trans-unit>
        <trans-unit id="b212969dc9e512428d09170cadc608095d96ef4b" translate="yes" xml:space="preserve">
          <source>Early filtering and message handling</source>
          <target state="translated">조기 필터링 및 메시지 처리</target>
        </trans-unit>
        <trans-unit id="02013cc67046fdd1aae8de2e9297f90c75b1d103" translate="yes" xml:space="preserve">
          <source>Early filtering of events</source>
          <target state="translated">이벤트의 조기 필터링</target>
        </trans-unit>
        <trans-unit id="45ba28d774fd86488ce1c503089d1e80918e6cda" translate="yes" xml:space="preserve">
          <source>Earth Globe Americas</source>
          <target state="translated">지구 지구 아메리카</target>
        </trans-unit>
        <trans-unit id="32a31b8413404bbe823a0be0f2215daa04efa961" translate="yes" xml:space="preserve">
          <source>Earth Globe Asia-Australia</source>
          <target state="translated">지구 지구 아시아-호주</target>
        </trans-unit>
        <trans-unit id="e225e5febaa3e5d132e6c4f42f17f6e28d6415c5" translate="yes" xml:space="preserve">
          <source>Earth Globe Europe-Africa</source>
          <target state="translated">지구 지구 유럽-아프리카</target>
        </trans-unit>
        <trans-unit id="38a01a67cf8e4d332986b68f2fc71763c696a896" translate="yes" xml:space="preserve">
          <source>Edit a file or directory optionally providing a line number to edit the file at. Return to the &lt;code&gt;julia&lt;/code&gt; prompt when you quit the editor. The editor can be changed by setting &lt;code&gt;JULIA_EDITOR&lt;/code&gt;, &lt;code&gt;VISUAL&lt;/code&gt; or &lt;code&gt;EDITOR&lt;/code&gt; as an environment variable.</source>
          <target state="translated">선택적으로 파일을 편집 할 행 번호를 제공하는 파일 또는 디렉토리를 편집하십시오. 편집기를 종료 하면 &lt;code&gt;julia&lt;/code&gt; 프롬프트로 돌아갑니다 . &lt;code&gt;JULIA_EDITOR&lt;/code&gt; , &lt;code&gt;VISUAL&lt;/code&gt; 또는 &lt;code&gt;EDITOR&lt;/code&gt; 를 환경 변수로 설정하여 편집기를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96bf75cf90aee425bd296ba4a82e787d511340ac" translate="yes" xml:space="preserve">
          <source>Edit the definition of a function, optionally specifying a tuple of types to indicate which method to edit. For modules, open the main source file. The module needs to be loaded with &lt;code&gt;using&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt; first.</source>
          <target state="translated">선택적으로 편집 할 메소드를 표시하기 위해 유형의 튜플을 지정하여 함수의 정의를 편집하십시오. 모듈의 경우 기본 소스 파일을여십시오. 먼저 모듈을 &lt;code&gt;using&lt;/code&gt; 하거나 &lt;code&gt;import&lt;/code&gt; 모듈을로드해야합니다 .</target>
        </trans-unit>
        <trans-unit id="44dc07f2fcde6067bce262b5efc8feb032594384" translate="yes" xml:space="preserve">
          <source>Efficient support for &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode&quot;&gt;Unicode&lt;/a&gt;, including but not limited to &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt; 을 포함하지만 이에 국한되지 않는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode&quot;&gt;유니 코드&lt;/a&gt; 에 대한 효율적인 지원</target>
        </trans-unit>
        <trans-unit id="86a35f1cb66a4b67fe0a08c54f9a06ca22ca2502" translate="yes" xml:space="preserve">
          <source>Eight Pointed Black Star</source>
          <target state="translated">여덟 뾰족한 검은 별</target>
        </trans-unit>
        <trans-unit id="b096e49c067864c8657cc77cb2489f9c7a46a60c" translate="yes" xml:space="preserve">
          <source>Eight Spoked Asterisk</source>
          <target state="translated">8 스포크 별표</target>
        </trans-unit>
        <trans-unit id="64b33bc5b072bf67cae39a4367e9262f072d0983" translate="yes" xml:space="preserve">
          <source>Eighth Note</source>
          <target state="translated">여덟째 주</target>
        </trans-unit>
        <trans-unit id="3e48f6a437e3973638b906ba62fc55ca1cbd9219" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;EltypeUnknown()&lt;/code&gt; or &lt;code&gt;HasEltype()&lt;/code&gt; as appropriate</source>
          <target state="translated">어느 &lt;code&gt;EltypeUnknown()&lt;/code&gt; 또는 &lt;code&gt;HasEltype()&lt;/code&gt; 적절한</target>
        </trans-unit>
        <trans-unit id="a0e204f765f5ad928475881aca7c13ef5c65e351" translate="yes" xml:space="preserve">
          <source>Electric Light Bulb</source>
          <target state="translated">전구</target>
        </trans-unit>
        <trans-unit id="b15c5b6da40c647c02530732f2c154f67995f39b" translate="yes" xml:space="preserve">
          <source>Electric Plug</source>
          <target state="translated">전기 플러그</target>
        </trans-unit>
        <trans-unit id="3f114e1bd5e42dad4fb0e15a6f2fe2cdbffd8d5c" translate="yes" xml:space="preserve">
          <source>Electric Torch</source>
          <target state="translated">전기 토치</target>
        </trans-unit>
        <trans-unit id="8bc90f041dc25b644c48594037e5678f3120b766" translate="yes" xml:space="preserve">
          <source>Electrical Intersection</source>
          <target state="translated">전기 교차점</target>
        </trans-unit>
        <trans-unit id="94a626de4e05a050364a69d3ed8b52928fa721f2" translate="yes" xml:space="preserve">
          <source>Elegant and extensible conversions and promotions for numeric and other types</source>
          <target state="translated">숫자 및 기타 유형에 대한 우아하고 확장 가능한 변환 및 프로모션</target>
        </trans-unit>
        <trans-unit id="b145388f2a6c1f663c46cc3fef6df0278b0d0e7b" translate="yes" xml:space="preserve">
          <source>Element Of</source>
          <target state="translated">요소</target>
        </trans-unit>
        <trans-unit id="c7e75d5c58d3d99fb0549bbb6eebd8b77418f140" translate="yes" xml:space="preserve">
          <source>Element Of Opening Downwards</source>
          <target state="translated">아래쪽으로 여는 요소</target>
        </trans-unit>
        <trans-unit id="ec9d5e51a88871a1e6bce9e1d8f55eddb1be4d6d" translate="yes" xml:space="preserve">
          <source>Element Of Opening Upwards</source>
          <target state="translated">개방의 요소</target>
        </trans-unit>
        <trans-unit id="eabe348be570b5c3a81b5a78a24f6bc500a5b337" translate="yes" xml:space="preserve">
          <source>Element Of With Dot Above</source>
          <target state="translated">위의 점이있는 요소</target>
        </trans-unit>
        <trans-unit id="17bfb5ca72c4a27f20d3d15f5185aabec39f3a3b" translate="yes" xml:space="preserve">
          <source>Element Of With Long Horizontal Stroke</source>
          <target state="translated">긴 수평 스트로크의 요소</target>
        </trans-unit>
        <trans-unit id="f3443f2657692062978d73b4527d8f3f59f40708" translate="yes" xml:space="preserve">
          <source>Element Of With Overbar</source>
          <target state="translated">오버 바와의 요소</target>
        </trans-unit>
        <trans-unit id="0335789ad2498b26e35d6c835f82cac2d005c318" translate="yes" xml:space="preserve">
          <source>Element Of With Two Horizontal Strokes</source>
          <target state="translated">두 개의 수평 획의 요소</target>
        </trans-unit>
        <trans-unit id="71f5f71f9939ea54d51a735c864b74e3967c3ba7" translate="yes" xml:space="preserve">
          <source>Element Of With Underbar</source>
          <target state="translated">밑줄의 요소</target>
        </trans-unit>
        <trans-unit id="256f897f2234cedafe188f182b0344400f8e1c28" translate="yes" xml:space="preserve">
          <source>Element Of With Vertical Bar At End Of Horizontal Stroke</source>
          <target state="translated">수평 스트로크 끝에 수직 막대가있는 요소</target>
        </trans-unit>
        <trans-unit id="86ab7fa25cb358d66e37e0c0a1c13bec1b3787f5" translate="yes" xml:space="preserve">
          <source>Elementary Functions</source>
          <target state="translated">기본 기능</target>
        </trans-unit>
        <trans-unit id="97b701a83c60171055869225a728b6d2098cfc55" translate="yes" xml:space="preserve">
          <source>Elementary operations</source>
          <target state="translated">초등 작업</target>
        </trans-unit>
        <trans-unit id="1c6f116ce35bbe8b5c5b3a26cfa9e63c4b7cff24" translate="yes" xml:space="preserve">
          <source>Elephant</source>
          <target state="translated">Elephant</target>
        </trans-unit>
        <trans-unit id="628aee648dc7795c701c3ac4168565c49ba7d8a8" translate="yes" xml:space="preserve">
          <source>Eliminates array bounds checking within expressions.</source>
          <target state="translated">식 내에서 배열 범위 검사를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="436e5580dafe4837fafc385b6832e44770757da8" translate="yes" xml:space="preserve">
          <source>Em Dash</source>
          <target state="translated">엠 대쉬</target>
        </trans-unit>
        <trans-unit id="54edea64256fec1b9afd042056c683a5e954b05d" translate="yes" xml:space="preserve">
          <source>Em Space</source>
          <target state="translated">엠 스페이스</target>
        </trans-unit>
        <trans-unit id="fd5fa6acc8725853ec64793d0347faa7182d2f81" translate="yes" xml:space="preserve">
          <source>Embedding Julia</source>
          <target state="translated">줄리아 임베딩</target>
        </trans-unit>
        <trans-unit id="8638f2d27f26ab330e90a52d10d3ba6e903a995b" translate="yes" xml:space="preserve">
          <source>Emit bounds checks always or never (ignoring declarations)</source>
          <target state="translated">경계 검사를 항상 또는 전혀 방출하지 않음 (선언 무시)</target>
        </trans-unit>
        <trans-unit id="6822793744c195c06628e13a8e25bb8ee807d832" translate="yes" xml:space="preserve">
          <source>Emoji Modifier Fitzpatrick Type-1-2</source>
          <target state="translated">이모티콘 수정 자 Fitzpatrick Type-1-2</target>
        </trans-unit>
        <trans-unit id="e7d0e508f11f735e99c8bf9621166a5b98508edb" translate="yes" xml:space="preserve">
          <source>Emoji Modifier Fitzpatrick Type-3</source>
          <target state="translated">이모티콘 수정 자 Fitzpatrick Type-3</target>
        </trans-unit>
        <trans-unit id="27052bd6bf6386f71c6cd2f5155906907462e4eb" translate="yes" xml:space="preserve">
          <source>Emoji Modifier Fitzpatrick Type-4</source>
          <target state="translated">이모티콘 수정 자 Fitzpatrick Type-4</target>
        </trans-unit>
        <trans-unit id="1a1f8c73826ca18825ae5fad787b1128670acb3c" translate="yes" xml:space="preserve">
          <source>Emoji Modifier Fitzpatrick Type-5</source>
          <target state="translated">이모티콘 수정 자 Fitzpatrick Type-5</target>
        </trans-unit>
        <trans-unit id="ddf70184418afb46c24a9ba734226beae8038ce5" translate="yes" xml:space="preserve">
          <source>Emoji Modifier Fitzpatrick Type-6</source>
          <target state="translated">이모티콘 수정 자 Fitzpatrick Type-6</target>
        </trans-unit>
        <trans-unit id="92732205e250b4761981020982f3419de88cf7db" translate="yes" xml:space="preserve">
          <source>Empty Set</source>
          <target state="translated">빈 세트</target>
        </trans-unit>
        <trans-unit id="8ec062085bcc2b801f216fc4c40783b689f973cf" translate="yes" xml:space="preserve">
          <source>Empty Set With Left Arrow Above</source>
          <target state="translated">위 왼쪽 화살표와 함께 빈 세트</target>
        </trans-unit>
        <trans-unit id="d91ae9a03edea62c7bd20d9ba629d7162aa63219" translate="yes" xml:space="preserve">
          <source>Empty Set With Overbar</source>
          <target state="translated">오버 바로 빈 세트</target>
        </trans-unit>
        <trans-unit id="6d8f951440669eb13bd78e4eb7585eb670aa5993" translate="yes" xml:space="preserve">
          <source>Empty Set With Right Arrow Above</source>
          <target state="translated">위의 오른쪽 화살표가있는 빈 세트</target>
        </trans-unit>
        <trans-unit id="43f45b3c27e994f1786fe11853d88094ff3f0d3a" translate="yes" xml:space="preserve">
          <source>Empty Set With Small Circle Above</source>
          <target state="translated">위의 작은 동그라미와 빈 세트</target>
        </trans-unit>
        <trans-unit id="5ebfd6f75b259f38d9a9191637cf54107c71d5e2" translate="yes" xml:space="preserve">
          <source>Empty arrays like &lt;code&gt;[]&lt;/code&gt;, which select no elements</source>
          <target state="translated">요소를 선택하지 않는 &lt;code&gt;[]&lt;/code&gt; 와 같은 빈 배열</target>
        </trans-unit>
        <trans-unit id="d1b6081c62b3668f73437e7ef55230193e6e2dec" translate="yes" xml:space="preserve">
          <source>Empty generic functions</source>
          <target state="translated">빈 일반 함수</target>
        </trans-unit>
        <trans-unit id="74006a3cefa65eb24a50f14a080a0a283848825f" translate="yes" xml:space="preserve">
          <source>En Dash</source>
          <target state="translated">엔 대쉬</target>
        </trans-unit>
        <trans-unit id="1628cc600d641d86574721f4cba6f82ac4859ad1" translate="yes" xml:space="preserve">
          <source>En Space</source>
          <target state="translated">엔 스페이스</target>
        </trans-unit>
        <trans-unit id="c26082fba43142d1c87a99220a9c21dffcbbcbfe" translate="yes" xml:space="preserve">
          <source>Enable / Set the level of debug info generation (default level is 1 if unspecified or 2 if used without a level)</source>
          <target state="translated">디버그 정보 생성 수준 활성화 / 설정 (기본 수준은 지정되지 않은 경우 1, 수준없이 사용 된 경우 2)</target>
        </trans-unit>
        <trans-unit id="99d7732e401f3ac5abd96dcf18eb471bc62eedcf" translate="yes" xml:space="preserve">
          <source>Enable or disable Julia's default signal handlers</source>
          <target state="translated">Julia의 기본 신호 처리기 활성화 또는 비활성화</target>
        </trans-unit>
        <trans-unit id="868de4fff11fc1378b5bf090b18d305dd45bc334" translate="yes" xml:space="preserve">
          <source>Enable or disable color text</source>
          <target state="translated">컬러 텍스트 활성화 또는 비활성화</target>
        </trans-unit>
        <trans-unit id="5c9a249a64cc4fd650a34fa825cad6ef21b766ee" translate="yes" xml:space="preserve">
          <source>Enable or disable incremental precompilation of modules</source>
          <target state="translated">모듈의 증분 프리 컴파일 활성화 또는 비활성화</target>
        </trans-unit>
        <trans-unit id="a51c0e3a6688b962a589c4b3871584f7a8a45cd2" translate="yes" xml:space="preserve">
          <source>Enable or disable method overwrite warnings</source>
          <target state="translated">메소드 덮어 쓰기 경고 사용 또는 사용 안함</target>
        </trans-unit>
        <trans-unit id="aca528646e6712e710558c2a4eb1f14f7c2f63c3" translate="yes" xml:space="preserve">
          <source>Enable or disable startup banner</source>
          <target state="translated">시작 배너 활성화 또는 비활성화</target>
        </trans-unit>
        <trans-unit id="2ca0be31a9b9b42744412a3827771e952db1ba08" translate="yes" xml:space="preserve">
          <source>Enable or disable syntax and method deprecation warnings (&lt;code&gt;error&lt;/code&gt; turns warnings into errors)</source>
          <target state="translated">구문 및 메소드 지원 중단 경고를 사용하거나 사용하지 않습니다 ( &lt;code&gt;error&lt;/code&gt; 는 경고를 오류로 바꿉니다)</target>
        </trans-unit>
        <trans-unit id="dd61ab9cf22b749efe0c17fd33d2e5ed63c746f4" translate="yes" xml:space="preserve">
          <source>Enable the GC, return previous state as int</source>
          <target state="translated">GC를 활성화하고 이전 상태를 int로 반환</target>
        </trans-unit>
        <trans-unit id="bab95ff490fda9c25eacf7c86628805a78ecd8fa" translate="yes" xml:space="preserve">
          <source>End Of Proof</source>
          <target state="translated">증명의 끝</target>
        </trans-unit>
        <trans-unit id="ad9d937f40f9885915fd0bc9430bfd7d6e63f0d4" translate="yes" xml:space="preserve">
          <source>End With Leftwards Arrow Above</source>
          <target state="translated">위의 왼쪽 화살표로 끝남</target>
        </trans-unit>
        <trans-unit id="348ce364668910edabfd008dfd0d3a94254a6fef" translate="yes" xml:space="preserve">
          <source>End, &lt;code&gt;^E&lt;/code&gt;</source>
          <target state="translated">끝, &lt;code&gt;^E&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0891cb9306e1015f2471b30de2c6d9cc3c5bab0c" translate="yes" xml:space="preserve">
          <source>Ensuring that all arguments support broadcast</source>
          <target state="translated">모든 주장이 방송을 지원하도록 보장</target>
        </trans-unit>
        <trans-unit id="a74398c918fa81c3c891469eb00e56ab1bce6a94" translate="yes" xml:space="preserve">
          <source>Enter help or shell mode (when at start of a line)</source>
          <target state="translated">도움말 또는 쉘 모드를 입력하십시오 (행 시작시)</target>
        </trans-unit>
        <trans-unit id="e641b987ac9e8ea3ec201a6a67556391d2e16178" translate="yes" xml:space="preserve">
          <source>Enum constant for &lt;a href=&quot;#Libdl.dlopen&quot;&gt;&lt;code&gt;dlopen&lt;/code&gt;&lt;/a&gt;. See your platform man page for details, if applicable.</source>
          <target state="translated">&lt;a href=&quot;#Libdl.dlopen&quot;&gt; &lt;code&gt;dlopen&lt;/code&gt; 의&lt;/a&gt; 열거 형 정수입니다 . 해당되는 경우 자세한 내용은 플랫폼 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3d4759b02e49d42abcfd8c6da270947288cfdfb3" translate="yes" xml:space="preserve">
          <source>Enums.@enum</source>
          <target state="translated">Enums.@enum</target>
        </trans-unit>
        <trans-unit id="9848c4523e6e3aa918b1c25741d4c5549ef8d0ad" translate="yes" xml:space="preserve">
          <source>Enums.Enum</source>
          <target state="translated">Enums.Enum</target>
        </trans-unit>
        <trans-unit id="cc756bbce5c6a1daad1db7d15c8a2dcefb92b0e6" translate="yes" xml:space="preserve">
          <source>EnvDict</source>
          <target state="translated">EnvDict</target>
        </trans-unit>
        <trans-unit id="7f4a2c89d81b1eddb2e5160fabf3758acbd3a82d" translate="yes" xml:space="preserve">
          <source>Envelope</source>
          <target state="translated">Envelope</target>
        </trans-unit>
        <trans-unit id="6762c5bdd1e043549bb3b44e75155fdf9be1b7a5" translate="yes" xml:space="preserve">
          <source>Envelope With Downwards Arrow Above</source>
          <target state="translated">아래쪽 화살표가있는 봉투</target>
        </trans-unit>
        <trans-unit id="ec072bba7befaa68af710fe3549eb0491d7badd1" translate="yes" xml:space="preserve">
          <source>Environment Variables</source>
          <target state="translated">환경 변수</target>
        </trans-unit>
        <trans-unit id="941617a2c1b6b1aec2faae0db722ab34dd080e87" translate="yes" xml:space="preserve">
          <source>Environment stacks</source>
          <target state="translated">환경 스택</target>
        </trans-unit>
        <trans-unit id="1173b2e11bd16e5dc36c119a4b84f02be11626b5" translate="yes" xml:space="preserve">
          <source>Environment variables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89641f9fa6e1bc519a9a2c77cb0174bd0af98e58" translate="yes" xml:space="preserve">
          <source>Environment variables :</source>
          <target state="translated">환경 변수 :</target>
        </trans-unit>
        <trans-unit id="50ee4c027fd890e4de416f6f3ab9a71f9c9e72e8" translate="yes" xml:space="preserve">
          <source>Environment variables that determine how REPL output should be formatted at the terminal. Generally, these variables should be set to &lt;a href=&quot;http://ascii-table.com/ansi-escape-sequences.php&quot;&gt;ANSI terminal escape sequences&lt;/a&gt;. Julia provides a high-level interface with much of the same functionality; see the section on &lt;a href=&quot;../../stdlib/repl/index#The-Julia-REPL-1&quot;&gt;The Julia REPL&lt;/a&gt;.</source>
          <target state="translated">터미널에서 REPL 출력을 형식화하는 방법을 결정하는 환경 변수. 일반적으로 이러한 변수는 &lt;a href=&quot;http://ascii-table.com/ansi-escape-sequences.php&quot;&gt;ANSI 터미널 이스케이프 시퀀스&lt;/a&gt; 로 설정해야합니다 . Julia는 동일한 기능을 가진 고급 인터페이스를 제공합니다. &lt;a href=&quot;../../stdlib/repl/index#The-Julia-REPL-1&quot;&gt;Julia REPL&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="017b53c42e43b39e1f5aabf6f7280c2f777243a2" translate="yes" xml:space="preserve">
          <source>Environments</source>
          <target state="translated">Environments</target>
        </trans-unit>
        <trans-unit id="3adc5cf208fce048a876da30f12ee121f6e24ef5" translate="yes" xml:space="preserve">
          <source>Equal And Parallel To</source>
          <target state="translated">동일하고 평행</target>
        </trans-unit>
        <trans-unit id="9014b90f8a5c287f9f7cca7cf1a09f7419d2e0a4" translate="yes" xml:space="preserve">
          <source>Equal To By Definition</source>
          <target state="translated">정의 별</target>
        </trans-unit>
        <trans-unit id="527d2270efb77ab589aa3d2bc8b1899c1c160dcc" translate="yes" xml:space="preserve">
          <source>Equal To Or Greater-Than / Equal To Or Greater Than</source>
          <target state="translated">같거나보다 크거나 같거나보다 큼</target>
        </trans-unit>
        <trans-unit id="6043f4fef98b74458e43463764bf902e73e8ff02" translate="yes" xml:space="preserve">
          <source>Equal To Or Less-Than / Equal To Or Less Than</source>
          <target state="translated">같거나보다 작거나 같거나보다 작음</target>
        </trans-unit>
        <trans-unit id="f6b115d144ac2f3557f089ae7d83d11f870e6ef8" translate="yes" xml:space="preserve">
          <source>Equal To Or Precedes</source>
          <target state="translated">같거나 선행</target>
        </trans-unit>
        <trans-unit id="3e050032f44766762506ff80de8be9a1911a3683" translate="yes" xml:space="preserve">
          <source>Equal To Or Succeeds</source>
          <target state="translated">같거나 성공</target>
        </trans-unit>
        <trans-unit id="15cfd415b36fe06b7025888786ae38085fcb3dbe" translate="yes" xml:space="preserve">
          <source>Equality and Comparison Operators</source>
          <target state="translated">평등 및 비교 연산자</target>
        </trans-unit>
        <trans-unit id="d8dae2f241fe4b5c985e7ee897c6b9676b9479ac" translate="yes" xml:space="preserve">
          <source>Equals Colon / Equal Colon</source>
          <target state="translated">동등한 콜론 / 동등한 콜론</target>
        </trans-unit>
        <trans-unit id="f93dc9419a85602368082c386c9a828a21bf6a6a" translate="yes" xml:space="preserve">
          <source>Equals Sign Above Leftwards Arrow</source>
          <target state="translated">왼쪽 화살표 위의 기호</target>
        </trans-unit>
        <trans-unit id="ec3132ed55f4f598ba853ce4e35988f1d955c3eb" translate="yes" xml:space="preserve">
          <source>Equals Sign Above Plus Sign</source>
          <target state="translated">더하기 기호 위의 기호</target>
        </trans-unit>
        <trans-unit id="77fb2dbe6663a45556f7650f2f6c1c73a590ed1c" translate="yes" xml:space="preserve">
          <source>Equals Sign Above Tilde Operator</source>
          <target state="translated">물결표 연산자 위의 기호</target>
        </trans-unit>
        <trans-unit id="62609b0cf8c4d06d3037a7bf8e6a793f1d27492d" translate="yes" xml:space="preserve">
          <source>Equals Sign And Slanted Parallel</source>
          <target state="translated">부호가 같고 기울어 진 평행</target>
        </trans-unit>
        <trans-unit id="23b4d26cbdac9571083cacc41611600ec79ff967" translate="yes" xml:space="preserve">
          <source>Equals Sign And Slanted Parallel With Tilde Above</source>
          <target state="translated">위의 물결표와 동일하고 평행하게 기울어 짐</target>
        </trans-unit>
        <trans-unit id="392e4a8368a67b37c46109802dbf3b2bbe627e02" translate="yes" xml:space="preserve">
          <source>Equals Sign With Bumpy Above</source>
          <target state="translated">울퉁불퉁 한 위와 같은 표시</target>
        </trans-unit>
        <trans-unit id="f2b106f710b9bbc7d6d2a380faea7b8fd23ed23a" translate="yes" xml:space="preserve">
          <source>Equals Sign With Dot Below</source>
          <target state="translated">아래의 점이있는 기호</target>
        </trans-unit>
        <trans-unit id="292a343448e994eeed1ffd3fdb4c2c8eb86b5555" translate="yes" xml:space="preserve">
          <source>Equals Sign With Two Dots Above And Two Dots Below</source>
          <target state="translated">위의 두 개의 점과 아래의 두 개의 점이있는 기호</target>
        </trans-unit>
        <trans-unit id="5e945a1cf2921ae612b33494ebe19cfd549e10ac" translate="yes" xml:space="preserve">
          <source>Equals With Asterisk</source>
          <target state="translated">별표와 동일</target>
        </trans-unit>
        <trans-unit id="f3f7928443c385bebfa509e6448cd7d63a9cc4a2" translate="yes" xml:space="preserve">
          <source>Equiangular To</source>
          <target state="translated">등변</target>
        </trans-unit>
        <trans-unit id="0dae504b4d888ad200cb544ee05069b242235880" translate="yes" xml:space="preserve">
          <source>Equivalent To</source>
          <target state="translated">에 해당</target>
        </trans-unit>
        <trans-unit id="209bb1206181d9c196e80f6965debb3ab3399f46" translate="yes" xml:space="preserve">
          <source>Equivalent With Four Dots Above</source>
          <target state="translated">위의 4 개의 점과 동일</target>
        </trans-unit>
        <trans-unit id="bdeb0fcd2d5eaaa85eb93b2bbb4eae42f75d7875" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;addprocs(Sys.CPU_THREADS; kwargs...)&lt;/code&gt;</source>
          <target state="translated">상당 &lt;code&gt;addprocs(Sys.CPU_THREADS; kwargs...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a444cba5b25b06d85c75d2cdc5490f28108cce13" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;fetch(@spawn expr)&lt;/code&gt;. See &lt;code&gt;fetch&lt;/code&gt; and &lt;a href=&quot;#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;fetch(@spawn expr)&lt;/code&gt; 와 같습니다 . &lt;code&gt;fetch&lt;/code&gt; 및 &lt;a href=&quot;#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb3145567457b210ea2803bee24b9156158b97cd" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;fetch(@spawnat p expr)&lt;/code&gt;. See &lt;code&gt;fetch&lt;/code&gt; and &lt;a href=&quot;#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;fetch(@spawnat p expr)&lt;/code&gt; 와 같습니다 . &lt;code&gt;fetch&lt;/code&gt; 및 &lt;a href=&quot;#Distributed.@spawnat&quot;&gt; &lt;code&gt;@spawnat&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ce9a67772da7b41e7c54b6a2b9da8ba6fbcc2a7" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git branch&lt;/code&gt;. Create a new branch from the current HEAD.</source>
          <target state="translated">&lt;code&gt;git branch&lt;/code&gt; 와 같습니다 . 현재 HEAD에서 새 분기를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8ad57947a691137150d754570a8ec38ac67d31bf" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git checkout [-b|-B] &amp;lt;branch_name&amp;gt; [&amp;lt;commit&amp;gt;] [--track &amp;lt;track&amp;gt;]&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;code&gt;git checkout [-b|-B] &amp;lt;branch_name&amp;gt; [&amp;lt;commit&amp;gt;] [--track &amp;lt;track&amp;gt;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d743c43b1f86bc4c8cac6b46919f9f746db86863" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git checkout [-f] --detach &amp;lt;commit&amp;gt;&lt;/code&gt;. Checkout the git commit &lt;code&gt;commit&lt;/code&gt; (a &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; in string form) in &lt;code&gt;repo&lt;/code&gt;. If &lt;code&gt;force&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, force the checkout and discard any current changes. Note that this detaches the current HEAD.</source>
          <target state="translated">동등 &lt;code&gt;git checkout [-f] --detach &amp;lt;commit&amp;gt;&lt;/code&gt; . &lt;code&gt;repo&lt;/code&gt; 에서 git commit &lt;code&gt;commit&lt;/code&gt; ( 문자열 형태 의 &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; )&lt;/a&gt; 을 체크 아웃하십시오 . 경우 &lt;code&gt;force&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; , 체크 아웃을 강제로 현재의 모든 변경 사항을 취소. 이렇게하면 현재 HEAD가 분리됩니다.</target>
        </trans-unit>
        <trans-unit id="901e29752c2ee8a70b5ed5fe68c348abc419a1fa" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git clone [-b &amp;lt;branch&amp;gt;] [--bare] &amp;lt;repo_url&amp;gt; &amp;lt;repo_path&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;code&gt;git clone [-b &amp;lt;branch&amp;gt;] [--bare] &amp;lt;repo_url&amp;gt; &amp;lt;repo_path&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bad74bb24ad9c1d3be87108ffc378bb2da2cc9f9" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git diff --name-only --diff-filter=&amp;lt;filter&amp;gt; &amp;lt;branch1&amp;gt; &amp;lt;branch2&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;code&gt;git diff --name-only --diff-filter=&amp;lt;filter&amp;gt; &amp;lt;branch1&amp;gt; &amp;lt;branch2&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43d427754f80d9c8df017cbc0092318835b0e696" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git diff-index &amp;lt;treeish&amp;gt; [-- &amp;lt;pathspecs&amp;gt;]&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;code&gt;git diff-index &amp;lt;treeish&amp;gt; [-- &amp;lt;pathspecs&amp;gt;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f8f3cd0f685b341a1ae14b9341b4e36c903d172" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git diff-index HEAD [-- &amp;lt;pathspecs&amp;gt;]&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;code&gt;git diff-index HEAD [-- &amp;lt;pathspecs&amp;gt;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="332ee7d1accb14409369b51e9d27080d4e0d14ed" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git fetch [&amp;lt;remoteurl&amp;gt;|&amp;lt;repo&amp;gt;] [&amp;lt;refspecs&amp;gt;]&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;code&gt;git fetch [&amp;lt;remoteurl&amp;gt;|&amp;lt;repo&amp;gt;] [&amp;lt;refspecs&amp;gt;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0083711cca7b02373661eae132e8a9c8507549ec" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git merge [--ff-only] [&amp;lt;committish&amp;gt; | &amp;lt;branch&amp;gt;]&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;git merge [--ff-only] [&amp;lt;committish&amp;gt; | &amp;lt;branch&amp;gt;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eabda327026b4f99bb6d32a8fbcdc496382a0b31" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git push [&amp;lt;remoteurl&amp;gt;|&amp;lt;repo&amp;gt;] [&amp;lt;refspecs&amp;gt;]&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;code&gt;git push [&amp;lt;remoteurl&amp;gt;|&amp;lt;repo&amp;gt;] [&amp;lt;refspecs&amp;gt;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6790132b2a9497e212bac7d4cf8fd0dd3edd5e55" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git reset [--soft | --mixed | --hard] &amp;lt;id&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;git reset [--soft | --mixed | --hard] &amp;lt;id&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="652b9155620394c1b1868072030e6b42f726640f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git rev-list --left-right --count &amp;lt;commit1&amp;gt; &amp;lt;commit2&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;code&gt;git rev-list --left-right --count &amp;lt;commit1&amp;gt; &amp;lt;commit2&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26a71f2870da7113263fbb72943176e45aaa35d2" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git update-index&lt;/code&gt;. Return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;repo&lt;/code&gt; needs updating.</source>
          <target state="translated">&lt;code&gt;git update-index&lt;/code&gt; 와 같습니다 . &lt;code&gt;repo&lt;/code&gt; 를 업데이트해야하는 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="f6ae3107848d44951e6909ca431ab304a4e9d539" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;stat(file).ctime&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;stat(file).ctime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6a4ce7135ab64a453fd910fc4aa56e36ba1ee2e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;stat(file).mode&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;stat(file).mode&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6a1382d7c1945d0f98e93198d22d79e261cf0056" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;stat(file).mtime&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;stat(file).mtime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe4fd466e331817e41386a75031f2b796ddfe458" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;stat(file).size&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;stat(file).size&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="0e823580a07913d38604c722d16a5560458f01a4" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;view(A,:,:,...,i,:,:,...)&lt;/code&gt; where &lt;code&gt;i&lt;/code&gt; is in position &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;code&gt;view(A,:,:,...,i,:,:,...)&lt;/code&gt; 여기서, &lt;code&gt;i&lt;/code&gt; 가 위치 인 &lt;code&gt;d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f31ba230aca25c1b698d1cc7150cef0b7b302c5" translate="yes" xml:space="preserve">
          <source>Equivalent to calling &lt;code&gt;remotecall_eval(Main, procs, expr)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;remotecall_eval(Main, procs, expr)&lt;/code&gt; 호출과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="9eaa630d94bb27275e18bb3b960a961c0a1f0f4b" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;char&lt;/code&gt; c-type.</source>
          <target state="translated">네이티브 &lt;code&gt;char&lt;/code&gt; c-type과 같습니다.</target>
        </trans-unit>
        <trans-unit id="118bc4f07f9064de09c7d27e3dc69b842c07d3cb" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;double&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">네이티브 &lt;code&gt;double&lt;/code&gt; c- 타입 ( &lt;a href=&quot;../numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; )과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bdf6e4eb22892b98b092275da9c573a01025062d" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;float&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">네이티브 &lt;code&gt;float&lt;/code&gt; c- 타입 ( &lt;a href=&quot;../numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; )과 같습니다.</target>
        </trans-unit>
        <trans-unit id="699b0aa6e72445454df17960d3daa3c9e6cc0497" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;intmax_t&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">기본 &lt;code&gt;intmax_t&lt;/code&gt; c-type ( &lt;a href=&quot;../numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; ) 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="fb40c99637fa47e326a9d7aab30c227079ce80bd" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;ptrdiff_t&lt;/code&gt; c-type (&lt;code&gt;Int&lt;/code&gt;).</source>
          <target state="translated">네이티브 &lt;code&gt;ptrdiff_t&lt;/code&gt; c-type ( &lt;code&gt;Int&lt;/code&gt; )과 같습니다.</target>
        </trans-unit>
        <trans-unit id="864b89ace5975f766b1aac60a330727b39bce821" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;signed int&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">네이티브 &lt;code&gt;signed int&lt;/code&gt; c- 형 ( &lt;a href=&quot;../numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt; )과 같습니다.</target>
        </trans-unit>
        <trans-unit id="42f2a96aef8ef6b3b801a9ca2e3e8f2afcb4b1e9" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;signed long long&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">기본 &lt;code&gt;signed long long&lt;/code&gt; c-type ( &lt;a href=&quot;../numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; )과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a5cd170ceee5df72650f75fb3558c1e0d584a0dc" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;signed long&lt;/code&gt; c-type.</source>
          <target state="translated">네이티브 &lt;code&gt;signed long&lt;/code&gt; c-type과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8bc320fb0e8a7512a786d769855e2e089a153ce2" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;signed short&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.Int16&quot;&gt;&lt;code&gt;Int16&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">네이티브 &lt;code&gt;signed short&lt;/code&gt; c- 타입 ( &lt;a href=&quot;../numbers/index#Core.Int16&quot;&gt; &lt;code&gt;Int16&lt;/code&gt; &lt;/a&gt; )과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1e69f65df3ca222b477f6e9993f20448b4bdae0f" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;size_t&lt;/code&gt; c-type (&lt;code&gt;UInt&lt;/code&gt;).</source>
          <target state="translated">기본 &lt;code&gt;size_t&lt;/code&gt; c- 타입 ( &lt;code&gt;UInt&lt;/code&gt; )과 같습니다.</target>
        </trans-unit>
        <trans-unit id="264d1040fe211b837b556b11ff091efb6a3f53bb" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;ssize_t&lt;/code&gt; c-type.</source>
          <target state="translated">기본 &lt;code&gt;ssize_t&lt;/code&gt; c-type과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dbd9e2c996a261d76f3ff53391f8e38719fe9e6e" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;uintmax_t&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.UInt64&quot;&gt;&lt;code&gt;UInt64&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">기본 &lt;code&gt;uintmax_t&lt;/code&gt; c 유형 ( &lt;a href=&quot;../numbers/index#Core.UInt64&quot;&gt; &lt;code&gt;UInt64&lt;/code&gt; &lt;/a&gt; )과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c8ce8fa159766da046ddd33786548e72dee4d9d" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;unsigned char&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">네이티브 &lt;code&gt;unsigned char&lt;/code&gt; c- 타입 ( &lt;a href=&quot;../numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt; )과 같습니다.</target>
        </trans-unit>
        <trans-unit id="344ab3cdb03d54ba12a0e16e58a7476236a61e4d" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;unsigned int&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.UInt32&quot;&gt;&lt;code&gt;UInt32&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">네이티브 &lt;code&gt;unsigned int&lt;/code&gt; c-type ( &lt;a href=&quot;../numbers/index#Core.UInt32&quot;&gt; &lt;code&gt;UInt32&lt;/code&gt; &lt;/a&gt; )과 같습니다.</target>
        </trans-unit>
        <trans-unit id="55d9ab0846117166f39d8e403505f1471a82f976" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;unsigned long long&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.UInt64&quot;&gt;&lt;code&gt;UInt64&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">네이티브 &lt;code&gt;unsigned long long&lt;/code&gt; c-type ( &lt;a href=&quot;../numbers/index#Core.UInt64&quot;&gt; &lt;code&gt;UInt64&lt;/code&gt; &lt;/a&gt; )과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6b3c06e09eab11aa3d1730ea23df9a5045171b15" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;unsigned long&lt;/code&gt; c-type.</source>
          <target state="translated">네이티브 &lt;code&gt;unsigned long&lt;/code&gt; c-type과 같습니다.</target>
        </trans-unit>
        <trans-unit id="016e279d1d48e1d87938958891ce84c0cfdfcbbb" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;unsigned short&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.UInt16&quot;&gt;&lt;code&gt;UInt16&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">네이티브 &lt;code&gt;unsigned short&lt;/code&gt; c-type ( &lt;a href=&quot;../numbers/index#Core.UInt16&quot;&gt; &lt;code&gt;UInt16&lt;/code&gt; &lt;/a&gt; )과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2c9bbcb68fcb17f0cce9547b0872debb3c579553" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;wchar_t&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">기본 &lt;code&gt;wchar_t&lt;/code&gt; c-type ( &lt;a href=&quot;../numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt; )과 같습니다.</target>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">오류 처리</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Errors</target>
        </trans-unit>
        <trans-unit id="698b31ff8b5d1a102369509499209b09eacc9225" translate="yes" xml:space="preserve">
          <source>Errors can also be handled by retrying failed computations. Keyword arguments &lt;code&gt;retry_delays&lt;/code&gt; and &lt;code&gt;retry_check&lt;/code&gt; are passed through to &lt;a href=&quot;../../base/base/index#Base.retry&quot;&gt;&lt;code&gt;retry&lt;/code&gt;&lt;/a&gt; as keyword arguments &lt;code&gt;delays&lt;/code&gt; and &lt;code&gt;check&lt;/code&gt; respectively. If batching is specified, and an entire batch fails, all items in the batch are retried.</source>
          <target state="translated">실패한 계산을 재 시도하여 오류를 처리 할 수도 있습니다. 키워드 인수 &lt;code&gt;retry_delays&lt;/code&gt; 및 &lt;code&gt;retry_check&lt;/code&gt; 는 키워드 인수 &lt;code&gt;delays&lt;/code&gt; 및 &lt;code&gt;check&lt;/code&gt; 각각 &lt;a href=&quot;../../base/base/index#Base.retry&quot;&gt; &lt;code&gt;retry&lt;/code&gt; &lt;/a&gt; 하기 위해 전달 됩니다. 배치가 지정되고 전체 배치가 실패하면 배치의 모든 항목이 재 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="e1d7a4876d3316d08fbc2b13153db110692b9665" translate="yes" xml:space="preserve">
          <source>Escaped backslash (&lt;code&gt;\\&lt;/code&gt;)</source>
          <target state="translated">이스케이프 된 백 슬래시 ( &lt;code&gt;\\&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="cc1c125b60f307138cb9e72beb52b2e7792689de" translate="yes" xml:space="preserve">
          <source>Escaped double-quote (&lt;code&gt;\&quot;&lt;/code&gt;)</source>
          <target state="translated">이스케이프 된 큰 따옴표 ( &lt;code&gt;\&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="06580f39a051b4e6ef99253897a370dadc16359c" translate="yes" xml:space="preserve">
          <source>Essentials</source>
          <target state="translated">Essentials</target>
        </trans-unit>
        <trans-unit id="e8510e15707f994fff8e2c28fa38378116dc350d" translate="yes" xml:space="preserve">
          <source>Estimates</source>
          <target state="translated">Estimates</target>
        </trans-unit>
        <trans-unit id="b9ba339b04699a110d3fe7f5b9f39b67a033e6ff" translate="yes" xml:space="preserve">
          <source>Estimates the error in the solution to &lt;code&gt;A * X = B&lt;/code&gt; (&lt;code&gt;trans = N&lt;/code&gt;), &lt;code&gt;transpose(A) * X = B&lt;/code&gt; (&lt;code&gt;trans = T&lt;/code&gt;), &lt;code&gt;adjoint(A) * X = B&lt;/code&gt; (&lt;code&gt;trans = C&lt;/code&gt;) for &lt;code&gt;side = L&lt;/code&gt;, or the equivalent equations a right-handed &lt;code&gt;side = R&lt;/code&gt;&lt;code&gt;X * A&lt;/code&gt; after computing &lt;code&gt;X&lt;/code&gt; using &lt;code&gt;trtrs!&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is upper triangular. If &lt;code&gt;uplo = L&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is lower triangular. If &lt;code&gt;diag = N&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; has non-unit diagonal elements. If &lt;code&gt;diag = U&lt;/code&gt;, all diagonal elements of &lt;code&gt;A&lt;/code&gt; are one. &lt;code&gt;Ferr&lt;/code&gt; and &lt;code&gt;Berr&lt;/code&gt; are optional inputs. &lt;code&gt;Ferr&lt;/code&gt; is the forward error and &lt;code&gt;Berr&lt;/code&gt; is the backward error, each component-wise.</source>
          <target state="translated">추정치 용액의 오차 &lt;code&gt;A * X = B&lt;/code&gt; ( &lt;code&gt;trans = N&lt;/code&gt; ), &lt;code&gt;transpose(A) * X = B&lt;/code&gt; ( &lt;code&gt;trans = T&lt;/code&gt; ), &lt;code&gt;adjoint(A) * X = B&lt;/code&gt; ( &lt;code&gt;trans = C&lt;/code&gt; 대) &lt;code&gt;side = L&lt;/code&gt; , 또는 &lt;code&gt;trtrs!&lt;/code&gt; 사용하여 &lt;code&gt;X&lt;/code&gt; 를 계산 &lt;code&gt;X * A&lt;/code&gt; 후 등가 방정식 오른손 &lt;code&gt;side = R&lt;/code&gt; X * A ! . 경우 &lt;code&gt;uplo = U&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 는 위 삼각형이다. 경우 &lt;code&gt;uplo = L&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 는 낮은 삼각형이다. 경우 &lt;code&gt;diag = N&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 는 비 - 부 대각 요소를 갖는다. 경우 &lt;code&gt;diag = U&lt;/code&gt; 의 모든 대각선 요소를 &lt;code&gt;A&lt;/code&gt; 는 하나입니다. &lt;code&gt;Ferr&lt;/code&gt; 및 &lt;code&gt;Berr&lt;/code&gt; 은 선택적 입력입니다. &lt;code&gt;Ferr&lt;/code&gt; 은 정방향 오류이고 &lt;code&gt;Berr&lt;/code&gt; 은 정방향 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="f36e35f5e8b00caa694f59163398facd608ea93b" translate="yes" xml:space="preserve">
          <source>Euler Constant / Eulers</source>
          <target state="translated">오일러 상수 / 오일러</target>
        </trans-unit>
        <trans-unit id="2e207df50d2607a1fe4fc27fe314291135737c83" translate="yes" xml:space="preserve">
          <source>Euler's constant.</source>
          <target state="translated">오일러의 상수.</target>
        </trans-unit>
        <trans-unit id="44623d7804a9c26efcde5e7649c3cb20b91a39c3" translate="yes" xml:space="preserve">
          <source>Euro Sign</source>
          <target state="translated">유로 기호</target>
        </trans-unit>
        <trans-unit id="57a3202bd3e441520bd7d609cab598bcb00faf56" translate="yes" xml:space="preserve">
          <source>European Castle</source>
          <target state="translated">유럽 ​​성</target>
        </trans-unit>
        <trans-unit id="c85713b44c54b59d5e3730564793b844ff3a2225" translate="yes" xml:space="preserve">
          <source>European Post Office</source>
          <target state="translated">유럽 ​​우체국</target>
        </trans-unit>
        <trans-unit id="70431e2cf67367675e48b7000db056935aff96a4" translate="yes" xml:space="preserve">
          <source>Evaluate &lt;code&gt;&amp;lt;expr&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;lt;expr&amp;gt;&lt;/code&gt; 평가</target>
        </trans-unit>
        <trans-unit id="07ce5a176f4ebcfe9263b70e6399c95e665e2889" translate="yes" xml:space="preserve">
          <source>Evaluate &lt;code&gt;&amp;lt;expr&amp;gt;&lt;/code&gt; and display the result</source>
          <target state="translated">&lt;code&gt;&amp;lt;expr&amp;gt;&lt;/code&gt; 을 평가 하고 결과를 표시하십시오</target>
        </trans-unit>
        <trans-unit id="25162b98d6071e304907ff82a3a467fb9271d77e" translate="yes" xml:space="preserve">
          <source>Evaluate an expression in the given module and return the result.</source>
          <target state="translated">주어진 모듈에서 표현식을 평가하고 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8f829ca8274917256304e4a58cd74009eea2d9d8" translate="yes" xml:space="preserve">
          <source>Evaluate an expression in the global scope of the containing module. Every &lt;code&gt;Module&lt;/code&gt; (except those defined with &lt;code&gt;baremodule&lt;/code&gt;) has its own 1-argument definition of &lt;code&gt;eval&lt;/code&gt;, which evaluates expressions in that module.</source>
          <target state="translated">포함 모듈의 전체 범위에서 표현식을 평가하십시오. &lt;code&gt;baremodule&lt;/code&gt; 으로 정의 된 &lt;code&gt;Module&lt;/code&gt; 제외한 모든 모듈 에는 &lt;code&gt;eval&lt;/code&gt; 의 자체 1- 인수 정의가 있으며 해당 모듈의 표현식을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="2601dc536c9d898fbb26df788d4c9e5325bd9791" translate="yes" xml:space="preserve">
          <source>Evaluate an expression with values interpolated into it using &lt;code&gt;eval&lt;/code&gt;. If two arguments are provided, the first is the module to evaluate in.</source>
          <target state="translated">&lt;code&gt;eval&lt;/code&gt; 을 사용하여 보간 된 값으로 표현식을 평가하십시오 . 두 개의 인수가 제공되면 첫 번째 인수는 평가할 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="0e1822550830e88855261b7ab222f92611690733" translate="yes" xml:space="preserve">
          <source>Evaluate the contents of the input source file in the global scope of module &lt;code&gt;m&lt;/code&gt;. Every module (except those defined with &lt;a href=&quot;#baremodule&quot;&gt;&lt;code&gt;baremodule&lt;/code&gt;&lt;/a&gt;) has its own 1-argument definition of &lt;code&gt;include&lt;/code&gt;, which evaluates the file in that module. Returns the result of the last evaluated expression of the input file. During including, a task-local include path is set to the directory containing the file. Nested calls to &lt;code&gt;include&lt;/code&gt; will search relative to that path. This function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.</source>
          <target state="translated">모듈 &lt;code&gt;m&lt;/code&gt; 의 전역 범위에서 입력 소스 파일의 내용을 평가하십시오 . &lt;a href=&quot;#baremodule&quot;&gt; &lt;code&gt;baremodule&lt;/code&gt; 로&lt;/a&gt; 정의 된 모듈을 제외한 모든 모듈 &lt;code&gt;include&lt;/code&gt; 의 고유 한 1- 인수 정의가 있으며 해당 모듈의 파일을 평가합니다. 입력 파일의 마지막으로 평가 된 표현식의 결과를 리턴합니다. 포함하는 동안 태스크 로컬 포함 경로는 파일을 포함하는 디렉토리로 설정됩니다. &lt;code&gt;include&lt;/code&gt; 할 중첩 호출 은 해당 경로를 기준으로 검색합니다. 이 기능은 일반적으로 소스를 대화식으로로드하거나 여러 소스 파일로 분리 된 패키지의 파일을 결합하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="31d4172b689085063db7676aaaf218e8295b9200" translate="yes" xml:space="preserve">
          <source>Evaluate the contents of the input source file in the global scope of the containing module. Every module (except those defined with &lt;code&gt;baremodule&lt;/code&gt;) has its own 1-argument definition of &lt;code&gt;include&lt;/code&gt;, which evaluates the file in that module. Returns the result of the last evaluated expression of the input file. During including, a task-local include path is set to the directory containing the file. Nested calls to &lt;code&gt;include&lt;/code&gt; will search relative to that path. This function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.</source>
          <target state="translated">포함 모듈의 전체 범위에서 입력 소스 파일의 내용을 평가하십시오. &lt;code&gt;baremodule&lt;/code&gt; 로 정의 된 모듈을 제외한 모든 모듈 &lt;code&gt;include&lt;/code&gt; 의 고유 한 1- 인수 정의가 있으며이 모듈에서 파일을 평가합니다. 입력 파일의 마지막으로 평가 된 표현식의 결과를 리턴합니다. 포함하는 동안 태스크 로컬 포함 경로는 파일을 포함하는 디렉토리로 설정됩니다. &lt;code&gt;include&lt;/code&gt; 할 중첩 호출 은 해당 경로를 기준으로 검색합니다. 이 기능은 일반적으로 소스를 대화식으로로드하거나 여러 소스 파일로 분리 된 패키지의 파일을 결합하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8bf5bd09edaddcf11f7e48b14ce64a359652894a" translate="yes" xml:space="preserve">
          <source>Evaluate the polynomial $\sum_k c[k] z^{k-1}$ for the coefficients &lt;code&gt;c[1]&lt;/code&gt;, &lt;code&gt;c[2]&lt;/code&gt;, ...; that is, the coefficients are given in ascending order by power of &lt;code&gt;z&lt;/code&gt;. This macro expands to efficient inline code that uses either Horner's method or, for complex &lt;code&gt;z&lt;/code&gt;, a more efficient Goertzel-like algorithm.</source>
          <target state="translated">계수 &lt;code&gt;c[1]&lt;/code&gt; , &lt;code&gt;c[2]&lt;/code&gt; , ...에 대한 다항식 $ \ sum_k c [k] z ^ {k-1} $를 평가합니다 . 즉, 계수는 &lt;code&gt;z&lt;/code&gt; 의 거듭 제곱에 따라 오름차순으로 제공됩니다 . 이 매크로는 Horner의 방법을 사용하거나 복잡한 &lt;code&gt;z&lt;/code&gt; 의 경우보다 효율적인 Goertzel과 유사한 알고리즘 을 사용하는 효율적인 인라인 코드로 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="1bf82123eb8f03dbfcdf15d386b828c44539c7f3" translate="yes" xml:space="preserve">
          <source>Evaluates the arguments to the function or macro call, determines their types, and calls &lt;a href=&quot;#InteractiveUtils.code_llvm&quot;&gt;&lt;code&gt;code_llvm&lt;/code&gt;&lt;/a&gt; on the resulting expression. Set the optional keyword arguments &lt;code&gt;raw&lt;/code&gt;, &lt;code&gt;dump_module&lt;/code&gt;, &lt;code&gt;debuginfo&lt;/code&gt;, &lt;code&gt;optimize&lt;/code&gt; by putting them and their value before the function call, like this:</source>
          <target state="translated">함수 또는 매크로 호출에 대한 인수를 평가하고 해당 유형을 판별 한 후 결과 표현식에서 &lt;a href=&quot;#InteractiveUtils.code_llvm&quot;&gt; &lt;code&gt;code_llvm&lt;/code&gt; &lt;/a&gt; 을 호출 합니다. 옵션 키워드 인자 설정 &lt;code&gt;raw&lt;/code&gt; , &lt;code&gt;dump_module&lt;/code&gt; , &lt;code&gt;debuginfo&lt;/code&gt; , &lt;code&gt;optimize&lt;/code&gt; 다음과 같이 함수를 호출하기 전에 그들과 그들의 값을 넣어 :</target>
        </trans-unit>
        <trans-unit id="0574281a0958da4e1fedb99a3969efb400d9fd77" translate="yes" xml:space="preserve">
          <source>Evaluates the arguments to the function or macro call, determines their types, and calls &lt;a href=&quot;#InteractiveUtils.code_native&quot;&gt;&lt;code&gt;code_native&lt;/code&gt;&lt;/a&gt; on the resulting expression.</source>
          <target state="translated">함수 또는 매크로 호출에 대한 인수를 평가하고 해당 유형을 판별 한 후 결과 표현식에서 &lt;a href=&quot;#InteractiveUtils.code_native&quot;&gt; &lt;code&gt;code_native&lt;/code&gt; &lt;/a&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="088bbc9cbb660de44f799b6c6a191524f6690255" translate="yes" xml:space="preserve">
          <source>Evaluates the arguments to the function or macro call, determines their types, and calls &lt;a href=&quot;#InteractiveUtils.code_warntype&quot;&gt;&lt;code&gt;code_warntype&lt;/code&gt;&lt;/a&gt; on the resulting expression.</source>
          <target state="translated">함수 또는 매크로 호출에 대한 인수를 평가하고 해당 유형을 판별 한 후 결과 표현식에서 &lt;a href=&quot;#InteractiveUtils.code_warntype&quot;&gt; &lt;code&gt;code_warntype&lt;/code&gt; &lt;/a&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="86161509c0da7e0e06a0044e2d468e8408652cab" translate="yes" xml:space="preserve">
          <source>Evaluates the arguments to the function or macro call, determines their types, and calls &lt;a href=&quot;../../base/base/index#Base.code_lowered&quot;&gt;&lt;code&gt;code_lowered&lt;/code&gt;&lt;/a&gt; on the resulting expression.</source>
          <target state="translated">함수 또는 매크로 호출에 대한 인수를 평가하고 해당 유형을 판별하고 결과 표현식에서 &lt;a href=&quot;../../base/base/index#Base.code_lowered&quot;&gt; &lt;code&gt;code_lowered&lt;/code&gt; &lt;/a&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="d170313f77b7bcf562ce6e89794d222a66dc883d" translate="yes" xml:space="preserve">
          <source>Evaluates the arguments to the function or macro call, determines their types, and calls &lt;a href=&quot;../../base/base/index#Base.code_typed&quot;&gt;&lt;code&gt;code_typed&lt;/code&gt;&lt;/a&gt; on the resulting expression. Use the optional argument &lt;code&gt;optimize&lt;/code&gt; with</source>
          <target state="translated">함수 또는 매크로 호출에 대한 인수를 평가하고 해당 유형을 판별하고 결과 표현식에서 &lt;a href=&quot;../../base/base/index#Base.code_typed&quot;&gt; &lt;code&gt;code_typed&lt;/code&gt; &lt;/a&gt; 를 호출 합니다. 선택적 인수 &lt;code&gt;optimize&lt;/code&gt; with를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="84c0397d7e38cfd74be0824e7f63562d46240019" translate="yes" xml:space="preserve">
          <source>Evaluates the arguments to the function or macro call, determines their types, and calls the &lt;code&gt;edit&lt;/code&gt; function on the resulting expression.</source>
          <target state="translated">함수 또는 매크로 호출에 대한 인수를 평가하고 해당 유형을 판별 한 후 결과 표현식 에서 &lt;code&gt;edit&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="fca23945bcd8a8eb5e9f3ee416d4703a5d82433d" translate="yes" xml:space="preserve">
          <source>Evaluates the arguments to the function or macro call, determines their types, and calls the &lt;code&gt;less&lt;/code&gt; function on the resulting expression.</source>
          <target state="translated">함수 또는 매크로 호출에 대한 인수를 평가하고 해당 유형을 판별하며 결과 표현식 에서 &lt;code&gt;less&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="dbabc83f5b048a0e83e97e9b394f27da706b3e88" translate="yes" xml:space="preserve">
          <source>Evaluation Scope of Default Values</source>
          <target state="translated">기본값의 평가 범위</target>
        </trans-unit>
        <trans-unit id="ad8919ace091b14011c6439cfd5e1707b58f5abd" translate="yes" xml:space="preserve">
          <source>Event</source>
          <target state="translated">Event</target>
        </trans-unit>
        <trans-unit id="01624c7776323f5a2680a97bd186745ab3cf1f28" translate="yes" xml:space="preserve">
          <source>Event processing is controlled by overriding functions associated with &lt;code&gt;AbstractLogger&lt;/code&gt;:</source>
          <target state="translated">이벤트 처리는 &lt;code&gt;AbstractLogger&lt;/code&gt; 와 관련된 함수를 재정 의하여 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="c5497bca58468ae64aed6c0fd921109217988db3" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">Events</target>
        </trans-unit>
        <trans-unit id="e8a98dc3ac17ae3d77b1ddc48b9496c80b2623e7" translate="yes" xml:space="preserve">
          <source>Evergreen Tree</source>
          <target state="translated">상록수</target>
        </trans-unit>
        <trans-unit id="8d21058e9a447b8fa599cb386e31bf0f68fa38e3" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;../modules/index#modules-1&quot;&gt;module&lt;/a&gt; has its own &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; function that evaluates expressions in its global scope. Expressions passed to &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; are not limited to returning values &amp;ndash; they can also have side-effects that alter the state of the enclosing module's environment:</source>
          <target state="translated">모든 &lt;a href=&quot;../modules/index#modules-1&quot;&gt;모듈&lt;/a&gt; 에는 전체 범위에서 표현식을 평가 하는 자체 &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; 함수가 있습니다. &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; 로 전달 된 표현식은 값을 반환하는 것으로 제한되지 않으며 둘러싸는 모듈 환경의 상태를 변경하는 부작용이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff9db205866ccce1546fa3a3f0dcf16499413e68" translate="yes" xml:space="preserve">
          <source>Every Julia program starts life as a string:</source>
          <target state="translated">모든 Julia 프로그램은 삶을 문자열로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="554f49a29b61819b844be413863c737b1ffe0f6b" translate="yes" xml:space="preserve">
          <source>Every binary arithmetic and bitwise operator also has an updating version that assigns the result of the operation back into its left operand. The updating version of the binary operator is formed by placing a &lt;code&gt;=&lt;/code&gt; immediately after the operator. For example, writing &lt;code&gt;x += 3&lt;/code&gt; is equivalent to writing &lt;code&gt;x = x + 3&lt;/code&gt;:</source>
          <target state="translated">모든 이진 산술 및 비트 연산자에는 연산 결과를 다시 왼쪽 피연산자로 할당하는 업데이트 버전이 있습니다. 이항 연산자의 업데이트 버전은 연산자 바로 뒤에 a &lt;code&gt;=&lt;/code&gt; 를 배치하여 구성됩니다 . 예를 들어 &lt;code&gt;x += 3&lt;/code&gt; 을 쓰는 것은 &lt;code&gt;x = x + 3&lt;/code&gt; 을 쓰는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="74d163370c2dd6c3a91981ad81aefa6f4ddbb3ff" translate="yes" xml:space="preserve">
          <source>Every concrete value in the system is an instance of some &lt;code&gt;DataType&lt;/code&gt;.</source>
          <target state="translated">시스템의 모든 구체적인 값은 일부 &lt;code&gt;DataType&lt;/code&gt; 의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="8f6ede3443e8f7e99e3d1681b81b7bd2c9c393a0" translate="yes" xml:space="preserve">
          <source>Every worker is also notified of other workers in the cluster.</source>
          <target state="translated">모든 작업자에게 클러스터의 다른 작업자에 대한 알림도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3da573171e36ece7f0a3ae53192e2857a7114b29" translate="yes" xml:space="preserve">
          <source>Exactly corresponds to the &lt;code&gt;complex double&lt;/code&gt; type in C (or &lt;code&gt;COMPLEX*16&lt;/code&gt; in Fortran).</source>
          <target state="translated">C 의 &lt;code&gt;complex double&lt;/code&gt; 타입 (또는 포트란의 &lt;code&gt;COMPLEX*16&lt;/code&gt; ) 과 정확히 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="12b877c370c66bac293ce599efbe5b9cfed8d671" translate="yes" xml:space="preserve">
          <source>Exactly corresponds to the &lt;code&gt;complex float&lt;/code&gt; type in C (or &lt;code&gt;COMPLEX*8&lt;/code&gt; in Fortran).</source>
          <target state="translated">C 의 &lt;code&gt;complex float&lt;/code&gt; 유형 (또는 Fortran의 &lt;code&gt;COMPLEX*8&lt;/code&gt; ) 과 정확히 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="9f324ad0c495e9b10cd207dd5c4138beb2a008e4" translate="yes" xml:space="preserve">
          <source>Exactly corresponds to the &lt;code&gt;double&lt;/code&gt; type in C (or &lt;code&gt;REAL*8&lt;/code&gt; in Fortran).</source>
          <target state="translated">C 의 &lt;code&gt;double&lt;/code&gt; 유형 (또는 Fortran의 &lt;code&gt;REAL*8&lt;/code&gt; ) 과 정확히 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="3f6752421aa22fb1eeb8d2fd5badfc564def668c" translate="yes" xml:space="preserve">
          <source>Exactly corresponds to the &lt;code&gt;float&lt;/code&gt; type in C (or &lt;code&gt;REAL*4&lt;/code&gt; in Fortran).</source>
          <target state="translated">C 의 &lt;code&gt;float&lt;/code&gt; 유형 (또는 Fortran의 &lt;code&gt;REAL*4&lt;/code&gt; ) 과 정확히 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="6cffeb7c4b2c762c65b636222df4fb94787880c0" translate="yes" xml:space="preserve">
          <source>Exactly corresponds to the &lt;code&gt;signed&lt;/code&gt; type annotation in C (or any &lt;code&gt;INTEGER&lt;/code&gt; type in Fortran). Any Julia type that is not a subtype of &lt;a href=&quot;../../base/numbers/index#Core.Signed&quot;&gt;&lt;code&gt;Signed&lt;/code&gt;&lt;/a&gt; is assumed to be unsigned.</source>
          <target state="translated">C 의 &lt;code&gt;signed&lt;/code&gt; 유형 주석 (또는 Fortran의 &lt;code&gt;INTEGER&lt;/code&gt; 유형)과 정확히 일치합니다 . &lt;a href=&quot;../../base/numbers/index#Core.Signed&quot;&gt; &lt;code&gt;Signed&lt;/code&gt; &lt;/a&gt; 의 하위 유형이 아닌 Julia 유형은 서명 되지 않은 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="0d1330aca84c1389777df28581b8c82cd98c2394" translate="yes" xml:space="preserve">
          <source>Examining &lt;code&gt;hello.txt&lt;/code&gt; again will show its contents have been changed.</source>
          <target state="translated">&lt;code&gt;hello.txt&lt;/code&gt; 를 다시 검사 하면 내용이 변경되었음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="373a52dcd1b4d765302f9139879ce9f9a0fb8c90" translate="yes" xml:space="preserve">
          <source>Example: On errors, retry &lt;code&gt;f&lt;/code&gt; on an element a maximum of 3 times without any delay between retries.</source>
          <target state="translated">예 : 오류가 발생하면 재시 도 사이에 지연없이 요소에서 최대 3 번 &lt;code&gt;f&lt;/code&gt; 를 재 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="6a35fb66c95d0cf88768455058261ed6959091e5" translate="yes" xml:space="preserve">
          <source>Example: Retry &lt;code&gt;f&lt;/code&gt; only if the exception is not of type &lt;code&gt;InexactError&lt;/code&gt;, with exponentially increasing delays up to 3 times. Return a &lt;code&gt;NaN&lt;/code&gt; in place for all &lt;code&gt;InexactError&lt;/code&gt; occurrences.</source>
          <target state="translated">예 : 예외가 &lt;code&gt;InexactError&lt;/code&gt; 유형이 아닌 경우에만 &lt;code&gt;f&lt;/code&gt; 를 3 회까지 지연시켜 지수를 재 시도 하십시오 . 모든 &lt;code&gt;InexactError&lt;/code&gt; 발생에 대해 &lt;code&gt;NaN&lt;/code&gt; 을 제자리에 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="b9efd4419a008bc5f5f67da74017e3ce7f66e0fb" translate="yes" xml:space="preserve">
          <source>Examples of operations involving I/O include reading/writing to files, accessing web services, executing external programs, etc. In all these cases, overall execution time can be improved if other tasks can be run while a file is being read, or while waiting for an external service/program to complete.</source>
          <target state="translated">I / O 관련 작업의 예로는 파일 읽기 / 쓰기, 웹 서비스 액세스, 외부 프로그램 실행 등이 있습니다. 이러한 모든 경우에 파일을 읽는 동안 또는 파일을 읽는 동안 다른 작업을 실행할 수 있으면 전체 실행 시간이 향상 될 수 있습니다. 외부 서비스 / 프로그램이 완료되기를 기다리는 중입니다.</target>
        </trans-unit>
        <trans-unit id="8ca7a5cb7aef9e6990554e02b239447ff53ee134" translate="yes" xml:space="preserve">
          <source>Examples should, whenever possible, be written as &lt;em&gt;doctests&lt;/em&gt;. A &lt;em&gt;doctest&lt;/em&gt; is a fenced code block (see &lt;a href=&quot;../../stdlib/markdown/index#Code-blocks-1&quot;&gt;Code blocks&lt;/a&gt;) starting with &lt;code&gt;```jldoctest&lt;/code&gt; and contains any number of &lt;code&gt;julia&amp;gt;&lt;/code&gt; prompts together with inputs and expected outputs that mimic the Julia REPL.</source>
          <target state="translated">가능할 때마다 예제는 &lt;em&gt;doctests&lt;/em&gt; 로 작성해야합니다 . &lt;em&gt;doctest가가&lt;/em&gt; (참조 울타리 코드 블록 &lt;a href=&quot;../../stdlib/markdown/index#Code-blocks-1&quot;&gt;코드 블록&lt;/a&gt; 으로 시작하는) &lt;code&gt;```jldoctest&lt;/code&gt; 및 임의의 개수가 포함 &lt;code&gt;julia&amp;gt;&lt;/code&gt; 함께 입력 및 출력이 예상 모방하는 줄리아 REPL와 안내.</target>
        </trans-unit>
        <trans-unit id="2056efb231cce98ac0668dedf4d2bf625aba4a55" translate="yes" xml:space="preserve">
          <source>Examples that are untestable should be written within fenced code blocks starting with &lt;code&gt;```julia&lt;/code&gt; so that they are highlighted correctly in the generated documentation.</source>
          <target state="translated">테스트 할 수없는 예제는 &lt;code&gt;```julia&lt;/code&gt; 로 시작하는 분리 된 코드 블록 내에 작성되어 생성 된 문서에서 올바르게 강조 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="20788aa11834509830be30396b88f6404f087e8c" translate="yes" xml:space="preserve">
          <source>Exception Handling</source>
          <target state="translated">예외 처리</target>
        </trans-unit>
        <trans-unit id="b93cbc45254a123c56a8eaff87f67380fa6af7a8" translate="yes" xml:space="preserve">
          <source>Exception stacks and &lt;code&gt;catch_stack&lt;/code&gt;</source>
          <target state="translated">예외 스택 및 &lt;code&gt;catch_stack&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d404b3b66335698d08bc7e83b3b1da3bf0caaf78" translate="yes" xml:space="preserve">
          <source>Exception stacks requires at least Julia 1.1.</source>
          <target state="translated">예외 스택에는 Julia 1.1 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a7f19469182a37332b5dea18474c06d9a6cffcd0" translate="yes" xml:space="preserve">
          <source>Exception thrown when a &lt;a href=&quot;#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; value is encountered in a situation where it is not supported. The error message, in the &lt;code&gt;msg&lt;/code&gt; field may provide more specific details.</source>
          <target state="translated">지원되지 않는 상황에서 &lt;a href=&quot;#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 값이 발생 하면 예외 가 발생합니다. &lt;code&gt;msg&lt;/code&gt; 필드 의 오류 메시지 는보다 구체적인 내용을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a497fe30a5347da8aff63c8337366f7a84f4058" translate="yes" xml:space="preserve">
          <source>Exception thrown when the input matrix has one or more zero-valued eigenvalues, and is not invertible. A linear solve involving such a matrix cannot be computed. The &lt;code&gt;info&lt;/code&gt; field indicates the location of (one of) the singular value(s).</source>
          <target state="translated">입력 행렬에 하나 이상의 0 값의 고유 값이 있고 되돌릴 수없는 경우 예외가 발생합니다. 이러한 매트릭스와 관련된 선형 해석은 계산할 수 없습니다. &lt;code&gt;info&lt;/code&gt; 필드는 위치 (하나의) 특이 값 (들)을 나타낸다.</target>
        </trans-unit>
        <trans-unit id="2023c26839abcfb0ae82bfd1150e32fbc284d2ca" translate="yes" xml:space="preserve">
          <source>Exception thrown when the input matrix was not &lt;a href=&quot;https://en.wikipedia.org/wiki/Definiteness_of_a_matrix&quot;&gt;positive definite&lt;/a&gt;. Some linear algebra functions and factorizations are only applicable to positive definite matrices. The &lt;code&gt;info&lt;/code&gt; field indicates the location of (one of) the eigenvalue(s) which is (are) less than/equal to 0.</source>
          <target state="translated">입력 행렬이 &lt;a href=&quot;https://en.wikipedia.org/wiki/Definiteness_of_a_matrix&quot;&gt;정의 양수&lt;/a&gt; 가 아닌 경우 예외가 발생합니다 . 일부 선형 대수 함수와 인수 분해는 양의 한정 행렬에만 적용 할 수 있습니다. &lt;code&gt;info&lt;/code&gt; 필드는 위치 (하나) 미만 / 0 인 (임) 인 고유 값 (들)을 나타낸다.</target>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>
        </trans-unit>
        <trans-unit id="82857d1e87d55237f9f3e372603e440bfa06f318" translate="yes" xml:space="preserve">
          <source>Exceptions can be created explicitly with &lt;a href=&quot;../../base/base/index#Core.throw&quot;&gt;&lt;code&gt;throw&lt;/code&gt;&lt;/a&gt;. For example, a function defined only for nonnegative numbers could be written to &lt;a href=&quot;../../base/base/index#Core.throw&quot;&gt;&lt;code&gt;throw&lt;/code&gt;&lt;/a&gt; a &lt;a href=&quot;../../base/base/index#Core.DomainError&quot;&gt;&lt;code&gt;DomainError&lt;/code&gt;&lt;/a&gt; if the argument is negative:</source>
          <target state="translated">예외는 &lt;a href=&quot;../../base/base/index#Core.throw&quot;&gt; &lt;code&gt;throw&lt;/code&gt; 로&lt;/a&gt; 명시 적으로 만들 수 있습니다 . 예를 들어, 함수는에 기록 될 수있는 음이 아닌 숫자에 대해 정의 &lt;a href=&quot;../../base/base/index#Core.throw&quot;&gt; &lt;code&gt;throw&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../../base/base/index#Core.DomainError&quot;&gt; &lt;code&gt;DomainError&lt;/code&gt; 을&lt;/a&gt; 인수가 음수 인 경우 :</target>
        </trans-unit>
        <trans-unit id="e4ba2f79f23d1d745b18049a3459429b5707c9cf" translate="yes" xml:space="preserve">
          <source>Exceptions on remote computations are captured and rethrown locally. A &lt;code&gt;RemoteException&lt;/code&gt; wraps the &lt;code&gt;pid&lt;/code&gt; of the worker and a captured exception. A &lt;code&gt;CapturedException&lt;/code&gt; captures the remote exception and a serializable form of the call stack when the exception was raised.</source>
          <target state="translated">원격 계산에 대한 예외는 로컬에서 캡처되고 다시 발생합니다. &lt;code&gt;RemoteException&lt;/code&gt; 감쌈 &lt;code&gt;pid&lt;/code&gt; 작업자 및 캡처 예외입니다. &lt;code&gt;CapturedException&lt;/code&gt; 은 예외가 발생 될 때를 제외하고 원격 호출 스택의 직렬화 형태를 캡처한다.</target>
        </trans-unit>
        <trans-unit id="47a6e6d3c2e9b02e1dbab62db882a7f9616c024c" translate="yes" xml:space="preserve">
          <source>Exceptions that occur while generating the log event are captured and logged by default. This prevents individual broken events from crashing the application, which is helpful when enabling little-used debug events in a production system. This behavior can be customized per logger type by extending &lt;a href=&quot;#Base.CoreLogging.catch_exceptions&quot;&gt;&lt;code&gt;Logging.catch_exceptions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">로그 이벤트를 생성하는 동안 발생하는 예외는 기본적으로 캡처 및 기록됩니다. 이렇게하면 개별 중단 된 이벤트가 응용 프로그램을 중단하지 못하게되어 프로덕션 시스템에서 거의 사용되지 않는 디버그 이벤트를 활성화 할 때 도움이됩니다. 이 동작은 &lt;a href=&quot;#Base.CoreLogging.catch_exceptions&quot;&gt; &lt;code&gt;Logging.catch_exceptions&lt;/code&gt; &lt;/a&gt; 를 확장하여 로거 유형별로 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="249bab0d837de1c736ed6cf322c1023e34887589" translate="yes" xml:space="preserve">
          <source>Excessive use will likely lead to poor performance.</source>
          <target state="translated">과도하게 사용하면 성능이 저하 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f389ff868b8af6a6f2f6d30e8b679e098d301b92" translate="yes" xml:space="preserve">
          <source>Exchange the current position with the mark</source>
          <target state="translated">현재 위치를 표시와 교환</target>
        </trans-unit>
        <trans-unit id="c80276d7c0f717bb4d551e808f6db2511c2186fe" translate="yes" xml:space="preserve">
          <source>Exclamation Question Mark</source>
          <target state="translated">느낌표 물음표</target>
        </trans-unit>
        <trans-unit id="dac1fed7304cfae795fbd37d78d8443ee698fee8" translate="yes" xml:space="preserve">
          <source>Execute &lt;code&gt;f&lt;/code&gt; in an environment that is temporarily modified (not replaced as in &lt;code&gt;setenv&lt;/code&gt;) by zero or more &lt;code&gt;&quot;var&quot;=&amp;gt;val&lt;/code&gt; arguments &lt;code&gt;kv&lt;/code&gt;. &lt;code&gt;withenv&lt;/code&gt; is generally used via the &lt;code&gt;withenv(kv...) do ... end&lt;/code&gt; syntax. A value of &lt;code&gt;nothing&lt;/code&gt; can be used to temporarily unset an environment variable (if it is set). When &lt;code&gt;withenv&lt;/code&gt; returns, the original environment has been restored.</source>
          <target state="translated">0 이상으로 &lt;code&gt;&quot;var&quot;=&amp;gt;val&lt;/code&gt; 인수 &lt;code&gt;kv&lt;/code&gt; 로 일시적으로 수정 된 ( &lt;code&gt;setenv&lt;/code&gt; 에서 대체되지 않은) 환경에서 &lt;code&gt;f&lt;/code&gt; 를 실행하십시오 . &lt;code&gt;withenv&lt;/code&gt; 는 일반적으로 &lt;code&gt;withenv(kv...) do ... end&lt;/code&gt; 구문을 통해 사용됩니다 . 값 &lt;code&gt;nothing&lt;/code&gt; (이 설정되어있는 경우) 임시 환경 변수 설정을 해제 할 수있다. 때 &lt;code&gt;withenv&lt;/code&gt; 반환, 원래의 환경이 복원되었습니다.</target>
        </trans-unit>
        <trans-unit id="303c63e1f5cb3dac07df60b3ba1c0270b3b39672" translate="yes" xml:space="preserve">
          <source>Execute &lt;code&gt;function&lt;/code&gt;, directing all log messages to &lt;code&gt;logger&lt;/code&gt;.</source>
          <target state="translated">모든 로그 메시지를 &lt;code&gt;logger&lt;/code&gt; 보내는 &lt;code&gt;function&lt;/code&gt; 실행 합니다 .</target>
        </trans-unit>
        <trans-unit id="bad793892b867876bd2fc3271d9d2236468940a7" translate="yes" xml:space="preserve">
          <source>Execute Permission</source>
          <target state="translated">실행 권한</target>
        </trans-unit>
        <trans-unit id="ccf93fd6554ca73378cd7ef4e9dc68bcbb434afc" translate="yes" xml:space="preserve">
          <source>Execute a transformed version of the expression, which calls functions that may violate strict IEEE semantics. This allows the fastest possible operation, but results are undefined &amp;ndash; be careful when doing this, as it may change numerical results.</source>
          <target state="translated">엄격한 IEEE 의미를 위반할 수있는 함수를 호출하는 변환 된 버전의 표현식을 실행하십시오. 이를 통해 가능한 가장 빠른 작업이 가능하지만 결과는 정의되지 않습니다. 수치 결과가 변경 될 수 있으므로주의하십시오.</target>
        </trans-unit>
        <trans-unit id="0c9df83ba80f7ea05232757e37fd45c85f102a7b" translate="yes" xml:space="preserve">
          <source>Execute an expression under &lt;code&gt;Main&lt;/code&gt; on all &lt;code&gt;procs&lt;/code&gt;. Errors on any of the processes are collected into a &lt;code&gt;CompositeException&lt;/code&gt; and thrown. For example:</source>
          <target state="translated">모든 &lt;code&gt;procs&lt;/code&gt; 에서 &lt;code&gt;Main&lt;/code&gt; 아래 표현식을 실행하십시오 . 모든 프로세스의 오류는 &lt;code&gt;CompositeException&lt;/code&gt; 으로 수집되어 발생합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ef0298149bb24a28fd471679846d07a4d0087cc3" translate="yes" xml:space="preserve">
          <source>Executes &lt;code&gt;f&lt;/code&gt; on worker &lt;code&gt;id&lt;/code&gt; asynchronously. Unlike &lt;a href=&quot;#Distributed.remotecall-Tuple%7BAny,Integer,Vararg%7BAny,N%7D%20where%20N%7D&quot;&gt;&lt;code&gt;remotecall&lt;/code&gt;&lt;/a&gt;, it does not store the result of computation, nor is there a way to wait for its completion.</source>
          <target state="translated">작업자 &lt;code&gt;id&lt;/code&gt; 에서 &lt;code&gt;f&lt;/code&gt; 를 비동기 적으로 실행합니다 . &lt;a href=&quot;#Distributed.remotecall-Tuple%7BAny,Integer,Vararg%7BAny,N%7D%20where%20N%7D&quot;&gt; &lt;code&gt;remotecall&lt;/code&gt; &lt;/a&gt; 과 달리 계산 결과를 저장하지 않으며 완료를 기다리는 방법도 없습니다.</target>
        </trans-unit>
        <trans-unit id="acb80322579157531d28a7bec37d10ea4056bc6f" translate="yes" xml:space="preserve">
          <source>Executing the above snippet results in &lt;code&gt;Main.A&lt;/code&gt; on worker 2 having a different value from &lt;code&gt;Main.A&lt;/code&gt; on worker 3, while the value of &lt;code&gt;Main.A&lt;/code&gt; on node 1 is set to &lt;code&gt;nothing&lt;/code&gt;.</source>
          <target state="translated">위의 코드에서 결과를 실행 &lt;code&gt;Main.A&lt;/code&gt; 에서 다른 값을 갖는 작업자 2 &lt;code&gt;Main.A&lt;/code&gt; 값하면서 작업자 3을 &lt;code&gt;Main.A&lt;/code&gt; 노드 1로 설정 &lt;code&gt;nothing&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="911180ac9cebe24cefdcdd1680b9c49387acd612" translate="yes" xml:space="preserve">
          <source>Exit (when buffer is empty)</source>
          <target state="translated">종료 (버퍼가 비었을 때)</target>
        </trans-unit>
        <trans-unit id="67fb80361f00a1ef919b8a402eb0fa8767e88aa3" translate="yes" xml:space="preserve">
          <source>Expand to a string with the absolute path to the directory of the file containing the macrocall. Return the current working directory if run from a REPL or if evaluated by &lt;code&gt;julia -e &amp;lt;expr&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">매크로 호출을 포함하는 파일 디렉토리의 절대 경로가있는 문자열로 확장하십시오. REPL에서 실행되거나 &lt;code&gt;julia -e &amp;lt;expr&amp;gt;&lt;/code&gt; 에 의해 평가되는 경우 현재 작업 디렉토리를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="43f7e4fd43efc93c7c61b01d066abbb6ecd0ad58" translate="yes" xml:space="preserve">
          <source>Expand to a string with the path to the file containing the macrocall, or an empty string if evaluated by &lt;code&gt;julia -e &amp;lt;expr&amp;gt;&lt;/code&gt;. Return &lt;code&gt;nothing&lt;/code&gt; if the macro was missing parser source information. Alternatively see &lt;a href=&quot;../constants/index#Base.PROGRAM_FILE&quot;&gt;&lt;code&gt;PROGRAM_FILE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">매크로 호출을 포함하는 파일 경로가있는 문자열로 확장하거나 &lt;code&gt;julia -e &amp;lt;expr&amp;gt;&lt;/code&gt; 에 의해 평가되는 경우 빈 문자열로 확장하십시오 . 매크로에 파서 소스 정보가 없으면 &lt;code&gt;nothing&lt;/code&gt; 반환 하지 않습니다 . 또는 &lt;a href=&quot;../constants/index#Base.PROGRAM_FILE&quot;&gt; &lt;code&gt;PROGRAM_FILE&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1f8c8a91207271c3979e8b044e269e773310cb43" translate="yes" xml:space="preserve">
          <source>Expand to the line number of the location of the macrocall. Return &lt;code&gt;0&lt;/code&gt; if the line number could not be determined.</source>
          <target state="translated">매크로 호출 위치의 행 번호로 확장하십시오. 행 번호를 확인할 수 없으면 &lt;code&gt;0&lt;/code&gt; 을 리턴 하십시오.</target>
        </trans-unit>
        <trans-unit id="c980fcdbd3756987bdd9be9bd2691a2d11e6223d" translate="yes" xml:space="preserve">
          <source>Expecting the filesystem to be unchanged between compile-time and runtime e.g. &lt;a href=&quot;../../base/file/index#Base.@__FILE__&quot;&gt;&lt;code&gt;@__FILE__&lt;/code&gt;&lt;/a&gt;/&lt;code&gt;source_path()&lt;/code&gt; to find resources at runtime, or the BinDeps &lt;code&gt;@checked_lib&lt;/code&gt; macro. Sometimes this is unavoidable. However, when possible, it can be good practice to copy resources into the module at compile-time so they won't need to be found at runtime.</source>
          <target state="translated">컴파일시와 런타임 사이에 파일 시스템이 변경되지 않을 것으로 예상합니다 (예 : &lt;a href=&quot;../../base/file/index#Base.@__FILE__&quot;&gt; &lt;code&gt;@__FILE__&lt;/code&gt; &lt;/a&gt; / &lt;code&gt;source_path()&lt;/code&gt; 런타임시 리소스 찾기 또는 BinDeps &lt;code&gt;@checked_lib&lt;/code&gt; 매크로). 때때로 이것은 피할 수없는 일입니다. 그러나 가능하면 컴파일 타임에 모듈에 리소스를 복사하여 런타임에 찾을 필요가없는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ef01e9964e65833fa4da94fa27761fbd0428c0b5" translate="yes" xml:space="preserve">
          <source>Experimental multithreading support.</source>
          <target state="translated">실험적인 멀티 스레딩 지원.</target>
        </trans-unit>
        <trans-unit id="d1e10c5f2ecca7a990bcf252a20b9966c63ad49c" translate="yes" xml:space="preserve">
          <source>Explicitly finds &lt;code&gt;Q&lt;/code&gt;, the orthogonal/unitary matrix from &lt;code&gt;gehrd!&lt;/code&gt;. &lt;code&gt;ilo&lt;/code&gt;, &lt;code&gt;ihi&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, and &lt;code&gt;tau&lt;/code&gt; must correspond to the input/output to &lt;code&gt;gehrd!&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gehrd!&lt;/code&gt; 에서 직교 / 단위 행렬 인 &lt;code&gt;Q&lt;/code&gt; 를 명시 적으로 찾습니다 ! . &lt;code&gt;ilo&lt;/code&gt; , &lt;code&gt;ihi&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 및 &lt;code&gt;tau&lt;/code&gt; 는 &lt;code&gt;gehrd!&lt;/code&gt; 의 입력 / 출력에 해당해야합니다 ! .</target>
        </trans-unit>
        <trans-unit id="d89ba743e7b20b3225440e90c3ccf3bf8748afa9" translate="yes" xml:space="preserve">
          <source>Explicitly finds the matrix &lt;code&gt;Q&lt;/code&gt; of a &lt;code&gt;LQ&lt;/code&gt; factorization after calling &lt;code&gt;gelqf!&lt;/code&gt; on &lt;code&gt;A&lt;/code&gt;. Uses the output of &lt;code&gt;gelqf!&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten by &lt;code&gt;Q&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gelqf!&lt;/code&gt; 를 호출 한 후 &lt;code&gt;LQ&lt;/code&gt; 인수 분해 의 행렬 &lt;code&gt;Q&lt;/code&gt; 를 명시 적으로 찾습니다 . 에 . &lt;code&gt;gelqf!&lt;/code&gt; 의 출력을 사용합니다 ! . &lt;code&gt;A&lt;/code&gt; 는 &lt;code&gt;Q&lt;/code&gt; 로 덮어 씁니다 . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="842467dd8285c3ac06d28f0f33b4e3294049f962" translate="yes" xml:space="preserve">
          <source>Explicitly finds the matrix &lt;code&gt;Q&lt;/code&gt; of a &lt;code&gt;QL&lt;/code&gt; factorization after calling &lt;code&gt;geqlf!&lt;/code&gt; on &lt;code&gt;A&lt;/code&gt;. Uses the output of &lt;code&gt;geqlf!&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten by &lt;code&gt;Q&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;geqlf!&lt;/code&gt; 를 호출 한 후 &lt;code&gt;QL&lt;/code&gt; 인수 분해 의 행렬 &lt;code&gt;Q&lt;/code&gt; 를 명시 적으로 찾습니다 . 에 . &lt;code&gt;geqlf!&lt;/code&gt; 의 출력을 사용합니다 ! . &lt;code&gt;A&lt;/code&gt; 는 &lt;code&gt;Q&lt;/code&gt; 로 덮어 씁니다 . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8ece9405b82e399d70d34379e646461b54cd5e7c" translate="yes" xml:space="preserve">
          <source>Explicitly finds the matrix &lt;code&gt;Q&lt;/code&gt; of a &lt;code&gt;QR&lt;/code&gt; factorization after calling &lt;code&gt;geqrf!&lt;/code&gt; on &lt;code&gt;A&lt;/code&gt;. Uses the output of &lt;code&gt;geqrf!&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten by &lt;code&gt;Q&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;geqrf!&lt;/code&gt; 를 호출 한 후 &lt;code&gt;QR&lt;/code&gt; 분해 의 행렬 &lt;code&gt;Q&lt;/code&gt; 를 명시 적으로 찾습니다 ! 에 . &lt;code&gt;geqrf!&lt;/code&gt; 의 출력을 사용합니다 ! . &lt;code&gt;A&lt;/code&gt; 는 &lt;code&gt;Q&lt;/code&gt; 로 덮어 씁니다 . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54b7a9812258e65fe016e3ff6743203ffc052ea2" translate="yes" xml:space="preserve">
          <source>Explicitly finds the matrix &lt;code&gt;Q&lt;/code&gt; of a &lt;code&gt;RQ&lt;/code&gt; factorization after calling &lt;code&gt;gerqf!&lt;/code&gt; on &lt;code&gt;A&lt;/code&gt;. Uses the output of &lt;code&gt;gerqf!&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten by &lt;code&gt;Q&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gerqf!&lt;/code&gt; 를 호출 한 후 &lt;code&gt;RQ&lt;/code&gt; 인수 분해 의 행렬 &lt;code&gt;Q&lt;/code&gt; 를 명시 적으로 찾습니다 . 에 . &lt;code&gt;gerqf!&lt;/code&gt; 의 출력을 사용합니다 ! . &lt;code&gt;A&lt;/code&gt; 는 &lt;code&gt;Q&lt;/code&gt; 로 덮어 씁니다 . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="50220615494147fbec7eb0d31ca7ba3a82c81db3" translate="yes" xml:space="preserve">
          <source>Explicitly passing &lt;code&gt;task&lt;/code&gt; will return the current exception stack on an arbitrary task. This is useful for inspecting tasks which have failed due to uncaught exceptions.</source>
          <target state="translated">명시 적으로 &lt;code&gt;task&lt;/code&gt; 을 전달 하면 임의의 작업에서 현재 예외 스택이 반환됩니다. 포착되지 않은 예외로 인해 실패한 작업을 검사하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="90b58b7713ee5ebddd55f78493a86426624ddf35" translate="yes" xml:space="preserve">
          <source>ExponentialBackOff</source>
          <target state="translated">ExponentialBackOff</target>
        </trans-unit>
        <trans-unit id="d165ee97f26b031b938fc12621899c47ca3e7175" translate="yes" xml:space="preserve">
          <source>Exponentiation</source>
          <target state="translated">Exponentiation</target>
        </trans-unit>
        <trans-unit id="23bf8b64f7777c5abac718af8c1d4675c08d1bd7" translate="yes" xml:space="preserve">
          <source>Exponentiation operator. If &lt;code&gt;x&lt;/code&gt; is a matrix, computes matrix exponentiation.</source>
          <target state="translated">지수 연산자. 경우 &lt;code&gt;x&lt;/code&gt; 행렬 계산하며 행렬 지수이다.</target>
        </trans-unit>
        <trans-unit id="97b695b9b9cfde3612c21b3add972cc0f21f4e26" translate="yes" xml:space="preserve">
          <source>Expression</source>
          <target state="translated">Expression</target>
        </trans-unit>
        <trans-unit id="2ffaab085f397ec888c88af14ff5370679b8c9cd" translate="yes" xml:space="preserve">
          <source>Expressionless Face</source>
          <target state="translated">표정없는 얼굴</target>
        </trans-unit>
        <trans-unit id="88cbc8428bc0cead64822d528b5aeb2ed594f6d0" translate="yes" xml:space="preserve">
          <source>Expressions and evaluation</source>
          <target state="translated">표현과 평가</target>
        </trans-unit>
        <trans-unit id="395de5a745d120d755d181c48640612c62257526" translate="yes" xml:space="preserve">
          <source>Expressions executed remotely via &lt;code&gt;@spawn&lt;/code&gt;, or closures specified for remote execution using &lt;code&gt;remotecall&lt;/code&gt; may refer to global variables. Global bindings under module &lt;code&gt;Main&lt;/code&gt; are treated a little differently compared to global bindings in other modules. Consider the following code snippet:</source>
          <target state="translated">&lt;code&gt;@spawn&lt;/code&gt; 을 통해 원격으로 실행되는 표현식 또는 &lt;code&gt;remotecall&lt;/code&gt; 을 사용하여 원격 실행을 위해 지정된 클로저 는 전역 변수를 참조 할 수 있습니다. &lt;code&gt;Main&lt;/code&gt; 모듈의 전역 바인딩은 다른 모듈의 전역 바인딩과 약간 다르게 처리됩니다. 다음 코드 스 니펫을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="6bdaffe5a439039b7bf8f6bd820ea137bfdd1da7" translate="yes" xml:space="preserve">
          <source>Expressions may also be constructed directly in &lt;a href=&quot;https://en.wikipedia.org/wiki/Polish_notation&quot;&gt;prefix notation&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Polish_notation&quot;&gt;접두사 표기법으로&lt;/a&gt; 직접 표현식을 작성할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="499636f8c38809ad543e77eff829b775812e07ab" translate="yes" xml:space="preserve">
          <source>Expressions provided by the parser generally only have symbols, other expressions, and literal values as their args, whereas expressions constructed by Julia code can have arbitrary run-time values without literal forms as args. In this specific example, &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; are symbols, &lt;code&gt;*(b,c)&lt;/code&gt; is a subexpression, and &lt;code&gt;1&lt;/code&gt; is a literal 64-bit signed integer.</source>
          <target state="translated">파서가 제공하는 표현식은 일반적으로 기호, 다른 표현식 및 리터럴 값을 인수로만 사용하는 반면 Julia 코드로 생성 된 표현식은 리터럴 형식이없는 임의의 런타임 값을 인수로 사용할 수 있습니다. 이 특정 예에서 &lt;code&gt;+&lt;/code&gt; 와 &lt;code&gt;a&lt;/code&gt; 는 기호이고 &lt;code&gt;*(b,c)&lt;/code&gt; 는 하위 표현식이고 &lt;code&gt;1&lt;/code&gt; 은 리터럴 64 비트 부호있는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="7f0edd94f804e2ef96353f1dd584892a96db61b3" translate="yes" xml:space="preserve">
          <source>Expressions starting with &lt;code&gt;0x&lt;/code&gt; are always hexadecimal literals.</source>
          <target state="translated">&lt;code&gt;0x&lt;/code&gt; 로 시작하는 표현식 은 항상 16 진 리터럴입니다.</target>
        </trans-unit>
        <trans-unit id="14b0df907ddf13aab95716adce355b18503f9692" translate="yes" xml:space="preserve">
          <source>Expressions starting with a numeric literal followed by &lt;code&gt;e&lt;/code&gt; or &lt;code&gt;E&lt;/code&gt; are always floating-point literals.</source>
          <target state="translated">숫자 리터럴로 시작하고 그 뒤에 &lt;code&gt;e&lt;/code&gt; 또는 &lt;code&gt;E&lt;/code&gt; 가 있는 표현식 은 항상 부동 소수점 리터럴입니다.</target>
        </trans-unit>
        <trans-unit id="168d5e3cbe916c23713fe630f1348b13aac9d055" translate="yes" xml:space="preserve">
          <source>Expressions starting with a numeric literal followed by &lt;code&gt;f&lt;/code&gt; are always 32-bit floating-point literals.</source>
          <target state="translated">숫자 리터럴로 시작하고 뒤에 &lt;code&gt;f&lt;/code&gt; 가 오는 표현식 은 항상 32 비트 부동 소수점 리터럴입니다.</target>
        </trans-unit>
        <trans-unit id="94855ece22db4469edf3ed1b0b895b74c83b0b49" translate="yes" xml:space="preserve">
          <source>Extended documentation for mathematical symbols &amp;amp; functions is &lt;a href=&quot;../math/index#math-ops-1&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">수학 기호 및 함수에 대한 확장 설명서가 &lt;a href=&quot;../math/index#math-ops-1&quot;&gt;여기에 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9923a9977a4965d0e75c0d0897087a1b8aae8273" translate="yes" xml:space="preserve">
          <source>Extending broadcast with custom implementations</source>
          <target state="translated">맞춤형 구현으로 방송 확장</target>
        </trans-unit>
        <trans-unit id="e37b3da56d0eb7ab09f9dced1733e35bd0cf8f0a" translate="yes" xml:space="preserve">
          <source>Extending in-place broadcasting</source>
          <target state="translated">인플레 이스 방송 확장</target>
        </trans-unit>
        <trans-unit id="dda79d09f22a8d0b6a55357e8dd3c1f09491aeff" translate="yes" xml:space="preserve">
          <source>External Profiling</source>
          <target state="translated">외부 프로파일 링</target>
        </trans-unit>
        <trans-unit id="dcc209bf958342fc6704aa1a6650f41110ebb0ea" translate="yes" xml:space="preserve">
          <source>External applications</source>
          <target state="translated">외부 응용</target>
        </trans-unit>
        <trans-unit id="72388f5a580b9a206f5fadf477e9c6409b4ba887" translate="yes" xml:space="preserve">
          <source>Extra keyword arguments can be collected using &lt;code&gt;...&lt;/code&gt;, as in varargs functions:</source>
          <target state="translated">varargs 함수에서와 같이 &lt;code&gt;...&lt;/code&gt; 을 사용하여 추가 키워드 인수를 수집 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c542a0937e5c368280ab873c2a76a31ca26a4f2" translate="yes" xml:space="preserve">
          <source>Extract a named field from a &lt;code&gt;value&lt;/code&gt; of composite type. See also &lt;a href=&quot;#Base.getproperty&quot;&gt;&lt;code&gt;getproperty&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">복합 유형 의 &lt;code&gt;value&lt;/code&gt; 에서 명명 된 필드를 추출하십시오 . &lt;a href=&quot;#Base.getproperty&quot;&gt; &lt;code&gt;getproperty&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c60b2d6e5ed4bb81c4f042b61a85bf3046814ef9" translate="yes" xml:space="preserve">
          <source>Extract the &lt;code&gt;significand(s)&lt;/code&gt; (a.k.a. mantissa), in binary representation, of a floating-point number. If &lt;code&gt;x&lt;/code&gt; is a non-zero finite number, then the result will be a number of the same type on the interval $[1,2)$. Otherwise &lt;code&gt;x&lt;/code&gt; is returned.</source>
          <target state="translated">추출 &lt;code&gt;significand(s)&lt;/code&gt; 부동 소수점 숫자의 이진 표현 (일명 가수). 경우 &lt;code&gt;x&lt;/code&gt; 영이 아닌 유한 한 수이며, 그 결과는 $ 구간 [1,2) $ 동일한 유형의 수가 될 것이다. 그렇지 않으면 &lt;code&gt;x&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4bd9a47407646b7eb349264a1847a577117c4b4b" translate="yes" xml:space="preserve">
          <source>Extracting the type parameter from a super-type</source>
          <target state="translated">수퍼 유형에서 유형 매개 변수 추출</target>
        </trans-unit>
        <trans-unit id="1fbfe5e749872a05dc1c33c2c7e3ca998b7be846" translate="yes" xml:space="preserve">
          <source>Extracting useful information</source>
          <target state="translated">유용한 정보 추출</target>
        </trans-unit>
        <trans-unit id="a98fa15cfef5c8e370cf565d569aef6f02c37e94" translate="yes" xml:space="preserve">
          <source>Extraction of a substring using range indexing also expects valid byte indices or an error is thrown:</source>
          <target state="translated">범위 인덱싱을 사용하여 하위 문자열을 추출하면 유효한 바이트 인덱스가 필요하거나 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="479ced4730cae81bdb549a4c55a6c538ce811e6e" translate="yes" xml:space="preserve">
          <source>Extraterrestrial Alien</source>
          <target state="translated">외계인 외계인</target>
        </trans-unit>
        <trans-unit id="794b03ba50df5bea4d6fe059ce926e6abf4b67b1" translate="yes" xml:space="preserve">
          <source>Eyeglasses</source>
          <target state="translated">Eyeglasses</target>
        </trans-unit>
        <trans-unit id="62be7f51429e4e104e01fe3131805c3195ede1d0" translate="yes" xml:space="preserve">
          <source>Eyes</source>
          <target state="translated">Eyes</target>
        </trans-unit>
        <trans-unit id="935b5308312476832a58c20321b71ffe59146c81" translate="yes" xml:space="preserve">
          <source>Face Massage</source>
          <target state="translated">얼굴 마사지</target>
        </trans-unit>
        <trans-unit id="6d9f49198cfb94a88e7e31f25250998eb9d2d1e4" translate="yes" xml:space="preserve">
          <source>Face Savouring Delicious Food</source>
          <target state="translated">맛있는 음식을 맛보는 얼굴</target>
        </trans-unit>
        <trans-unit id="28d752ff1cbe0e0d9da042fc2eb4d864b23a6a83" translate="yes" xml:space="preserve">
          <source>Face Screaming In Fear</source>
          <target state="translated">두려움에 비명을 지르는 얼굴</target>
        </trans-unit>
        <trans-unit id="b9e9beed389ea0d867f47293f82e2186403a9ed4" translate="yes" xml:space="preserve">
          <source>Face Throwing A Kiss</source>
          <target state="translated">키스를 던지는 얼굴</target>
        </trans-unit>
        <trans-unit id="bbcbf04ff477b2051e7e4f303a290165f6e17c1c" translate="yes" xml:space="preserve">
          <source>Face With Cold Sweat</source>
          <target state="translated">식은 땀이있는 얼굴</target>
        </trans-unit>
        <trans-unit id="31e3b7279424674f21abf98db495235d209a6f78" translate="yes" xml:space="preserve">
          <source>Face With Look Of Triumph</source>
          <target state="translated">승리의 표정으로 얼굴</target>
        </trans-unit>
        <trans-unit id="d977220829cb5c54e44951e580b7af5a8be682f2" translate="yes" xml:space="preserve">
          <source>Face With Medical Mask</source>
          <target state="translated">의료 마스크 얼굴</target>
        </trans-unit>
        <trans-unit id="ed92f3d2a6422f2069bba1ed8548d4fce7291c38" translate="yes" xml:space="preserve">
          <source>Face With No Good Gesture</source>
          <target state="translated">좋은 제스처가없는 얼굴</target>
        </trans-unit>
        <trans-unit id="506a6677d48e694c03b7beb019db5a830b3143a9" translate="yes" xml:space="preserve">
          <source>Face With Ok Gesture</source>
          <target state="translated">확인 제스처와 얼굴</target>
        </trans-unit>
        <trans-unit id="28e351cf809c3e1056a0ccbe38a572fea7f91813" translate="yes" xml:space="preserve">
          <source>Face With Open Mouth</source>
          <target state="translated">열린 입으로 얼굴</target>
        </trans-unit>
        <trans-unit id="ede5660328e307c9c221b7e2a4cda4e1f338198d" translate="yes" xml:space="preserve">
          <source>Face With Open Mouth And Cold Sweat</source>
          <target state="translated">입을 벌리고 식은 땀이 나는 얼굴</target>
        </trans-unit>
        <trans-unit id="2ba0e50eb9d9ecd8226c1f88f65005c12090219b" translate="yes" xml:space="preserve">
          <source>Face With Stuck-Out Tongue</source>
          <target state="translated">붙어 혀로 얼굴</target>
        </trans-unit>
        <trans-unit id="0ac1bde49f3cb47f6fb14b275d6c4062eb336a94" translate="yes" xml:space="preserve">
          <source>Face With Stuck-Out Tongue And Tightly-Closed Eyes</source>
          <target state="translated">혀를 내밀고 눈을 감은 얼굴</target>
        </trans-unit>
        <trans-unit id="f4cf7e61567246c7cc07e1da723a4bb7e03afad8" translate="yes" xml:space="preserve">
          <source>Face With Stuck-Out Tongue And Winking Eye</source>
          <target state="translated">붙어 혀와 윙크하는 눈을 가진 얼굴</target>
        </trans-unit>
        <trans-unit id="a06e070daf131855d1c38e6f755e23cf18f7fde6" translate="yes" xml:space="preserve">
          <source>Face With Tears Of Joy</source>
          <target state="translated">기쁨의 눈물로 얼굴</target>
        </trans-unit>
        <trans-unit id="712efae47f8a280e2a18330da009234488ca3fe5" translate="yes" xml:space="preserve">
          <source>Face Without Mouth</source>
          <target state="translated">입없는 얼굴</target>
        </trans-unit>
        <trans-unit id="afc193c2d83a82dc7805b7f571fe51bc57700902" translate="yes" xml:space="preserve">
          <source>Factorial of &lt;code&gt;n&lt;/code&gt;. If &lt;code&gt;n&lt;/code&gt; is an &lt;a href=&quot;../numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt;, the factorial is computed as an integer (promoted to at least 64 bits). Note that this may overflow if &lt;code&gt;n&lt;/code&gt; is not small, but you can use &lt;code&gt;factorial(big(n))&lt;/code&gt; to compute the result exactly in arbitrary precision.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 의 계승 . 경우 &lt;code&gt;n&lt;/code&gt; 은 인 &lt;a href=&quot;../numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt; , 팩토리얼 정수로서 산출된다 (적어도 64 비트 촉진). &lt;code&gt;n&lt;/code&gt; 이 작지 않으면 오버플로가 발생할 수 있지만 &lt;code&gt;factorial(big(n))&lt;/code&gt; 을 사용하여 결과를 임의의 정밀도로 정확하게 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e47b9b1021034a56b7d5f70d92d0481524e78f69" translate="yes" xml:space="preserve">
          <source>Factory</source>
          <target state="translated">Factory</target>
        </trans-unit>
        <trans-unit id="63654e405afb574cef72ea67524c3b8dfe3ad9f8" translate="yes" xml:space="preserve">
          <source>Fallen Leaf</source>
          <target state="translated">타락한 잎</target>
        </trans-unit>
        <trans-unit id="b9484d668f5b5826c667e198c17cfe45233a7bb4" translate="yes" xml:space="preserve">
          <source>Falling Diagonal Crossing North East Arrow</source>
          <target state="translated">떨어지는 대각선 교차점 북동쪽 화살표</target>
        </trans-unit>
        <trans-unit id="393d595d0d4e1a1bb3815008194b595d879c69cb" translate="yes" xml:space="preserve">
          <source>Falling Diagonal Crossing Rising Diagonal</source>
          <target state="translated">떨어지는 대각선 횡단 상승 대각선</target>
        </trans-unit>
        <trans-unit id="4efb6cb7c018f0c686d4e9d68b615950223b4dd1" translate="yes" xml:space="preserve">
          <source>Family</source>
          <target state="translated">Family</target>
        </trans-unit>
        <trans-unit id="f4b462a59695a129404bc83da0ca619fa6bc84c1" translate="yes" xml:space="preserve">
          <source>FastMath.@fastmath</source>
          <target state="translated">FastMath.@fastmath</target>
        </trans-unit>
        <trans-unit id="5e56c9df8931a964370d4185aaacd5e1646ab9bf" translate="yes" xml:space="preserve">
          <source>Fastforward merge changes into current HEAD. This is only possible if the commit referred to by &lt;code&gt;ann&lt;/code&gt; is descended from the current HEAD (e.g. if pulling changes from a remote branch which is simply ahead of the local branch tip).</source>
          <target state="translated">현재 HEAD 로의 빠른 병합 변경. &lt;code&gt;ann&lt;/code&gt; 에 의해 참조 된 커밋 이 현재 HEAD에서 내려진 경우에만 가능합니다 (예 : 로컬 브랜치 팁보다 앞서있는 원격 브랜치에서 변경 사항을 가져 오는 경우).</target>
        </trans-unit>
        <trans-unit id="2cb40f791e4167e1561e4d7cf136b54833a93f9c" translate="yes" xml:space="preserve">
          <source>Father Christmas</source>
          <target state="translated">아버지 크리스마스</target>
        </trans-unit>
        <trans-unit id="9f64754b8681b16b5355b0c86ea9df6b53108695" translate="yes" xml:space="preserve">
          <source>Fax Machine</source>
          <target state="translated">팩스</target>
        </trans-unit>
        <trans-unit id="2e7c6c500cc9c35c302564a53fea2d0265ede623" translate="yes" xml:space="preserve">
          <source>Fearful Face</source>
          <target state="translated">두려운 얼굴</target>
        </trans-unit>
        <trans-unit id="e8205fe2da2e8213474f5eefce3af1eb9e900095" translate="yes" xml:space="preserve">
          <source>Federated package management and precise software reproducibility are difficult but worthy goals in a package system. In combination, these goals lead to a more complex package loading mechanism than most dynamic languages have, but it also yields scalability and reproducibility that is more commonly associated with static languages. Typically, Julia users should be able to use the built-in package manager to manage their projects without needing a precise understanding of these interactions. A call to &lt;code&gt;Pkg.add(&quot;X&quot;)&lt;/code&gt; will add to the appropriate project and manifest files, selected via &lt;code&gt;Pkg.activate(&quot;Y&quot;)&lt;/code&gt;, so that a future call to &lt;code&gt;import X&lt;/code&gt; will load &lt;code&gt;X&lt;/code&gt; without further thought.</source>
          <target state="translated">연합 패키지 관리 및 정확한 소프트웨어 재현성은 패키지 시스템에서 어렵지만 가치있는 목표입니다. 이러한 목표를 결합하면 대부분의 동적 언어보다 패키지로드 메커니즘이 더 복잡해 지지만 정적 언어와 더 일반적으로 연관된 확장 성과 재현성을 제공합니다. 일반적으로 Julia 사용자는 내장 된 패키지 관리자를 사용하여 이러한 상호 작용에 대한 정확한 이해없이 프로젝트를 관리 할 수 ​​있어야합니다. 를 호출 &lt;code&gt;Pkg.add(&quot;X&quot;)&lt;/code&gt; 는 를 통해 선택 적절한 프로젝트와 매니페스트 파일에 추가합니다 &lt;code&gt;Pkg.activate(&quot;Y&quot;)&lt;/code&gt; 에 대한 미래의 호출 그래서, &lt;code&gt;import X&lt;/code&gt; 로드 &lt;code&gt;X&lt;/code&gt; 를 더 생각없이.</target>
        </trans-unit>
        <trans-unit id="47786ddc55ac4be098cd5e14320506e7fb87ccf0" translate="yes" xml:space="preserve">
          <source>Federation of packages</source>
          <target state="translated">패키지 연합</target>
        </trans-unit>
        <trans-unit id="39d4db59ebfbfc4ac31928560a37f5b11dfbe6ef" translate="yes" xml:space="preserve">
          <source>Female Sign</source>
          <target state="translated">여성 사인</target>
        </trans-unit>
        <trans-unit id="5ade35b896f1964ffd73b5188c1b0487a813086e" translate="yes" xml:space="preserve">
          <source>Feminine Ordinal Indicator</source>
          <target state="translated">여성 서수 지표</target>
        </trans-unit>
        <trans-unit id="d710ff00c62629aec846cd362ec81d6ef45db696" translate="yes" xml:space="preserve">
          <source>Ferris Wheel</source>
          <target state="translated">관람차</target>
        </trans-unit>
        <trans-unit id="df0dbf9f1e3f08dc6fd97eee350731fe6d045e40" translate="yes" xml:space="preserve">
          <source>Fetch from the specified &lt;code&gt;rmt&lt;/code&gt; remote git repository, using &lt;code&gt;refspecs&lt;/code&gt; to determine which remote branch(es) to fetch. The keyword arguments are:</source>
          <target state="translated">가져올 원격 브랜치를 결정하기 위해 &lt;code&gt;refspecs&lt;/code&gt; 을 사용하여 지정된 &lt;code&gt;rmt&lt;/code&gt; 원격 git 저장소에서 가져옵니다. 키워드 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cb2823e177eb0088e61a0c4192de87c90606b3f2" translate="yes" xml:space="preserve">
          <source>Fetch value(s) from a &lt;a href=&quot;#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt;&lt;code&gt;rr&lt;/code&gt;, removing the value(s) in the process.</source>
          <target state="translated">프로세스에서 값을 제거하여 &lt;a href=&quot;#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; &lt;code&gt;rr&lt;/code&gt; 에서 값을 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="f75758f2a5b3122c0452e7b217407d3ca4c90027" translate="yes" xml:space="preserve">
          <source>Fetches updates from an upstream of the repository &lt;code&gt;repo&lt;/code&gt;.</source>
          <target state="translated">저장소의 상류에서 업데이트를 가져옵니다 &lt;code&gt;repo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33e0dc3617ed6df7db01aef23ac96c5f906e0e79" translate="yes" xml:space="preserve">
          <source>Field &lt;code&gt;connect_at::Any&lt;/code&gt; in &lt;code&gt;WorkerConfig&lt;/code&gt; can be set by the cluster manager when &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt;&lt;code&gt;launch&lt;/code&gt;&lt;/a&gt; is called. The value of this field is passed in in all &lt;code&gt;connect&lt;/code&gt; callbacks. Typically, it carries information on &lt;em&gt;how to connect&lt;/em&gt; to a worker. For example, the TCP/IP socket transport uses this field to specify the &lt;code&gt;(host, port)&lt;/code&gt; tuple at which to connect to a worker.</source>
          <target state="translated">연결 관리자 필드 &lt;code&gt;connect_at::Any&lt;/code&gt; &lt;code&gt;WorkerConfig&lt;/code&gt; 의모든 항목 은 &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt; &lt;code&gt;launch&lt;/code&gt; &lt;/a&gt; 이 호출 될 때 클러스터 관리자가 설정할 수 있습니다 . 이 필드의 값은 모든 &lt;code&gt;connect&lt;/code&gt; 콜백 에 전달됩니다 . 일반적으로 작업자 &lt;em&gt;연결 방법&lt;/em&gt; 에 &lt;em&gt;대한&lt;/em&gt; 정보를 제공 &lt;em&gt;합니다&lt;/em&gt; . 예를 들어, TCP / IP 소켓 전송은이 필드를 사용하여 작업자에 연결할 &lt;code&gt;(host, port)&lt;/code&gt; 튜플 을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="a021a8bc64f3d535386a42159616c145f16e2e9f" translate="yes" xml:space="preserve">
          <source>Fields can have type restrictions, which may be parameterized:</source>
          <target state="translated">필드에는 유형 제한이있을 수 있으며 매개 변수화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85e54bf45d80186bc0d6353b5c2465d78bd8c6a3" translate="yes" xml:space="preserve">
          <source>Fields for output from functions can also be completed:</source>
          <target state="translated">함수 출력을위한 필드도 완성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c69000bd588bc2ad85aa2ab7ce5f54b4fa4c471" translate="yes" xml:space="preserve">
          <source>Fields with no type annotation default to &lt;code&gt;Any&lt;/code&gt;, and can accordingly hold any type of value.</source>
          <target state="translated">유형 주석이없는 필드는 기본적으로 &lt;code&gt;Any&lt;/code&gt; 로 설정 되므로 모든 유형의 값을 보유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="844953f92852d1b54e7d635339a7d17db22cf318" translate="yes" xml:space="preserve">
          <source>File Events</source>
          <target state="translated">파일 이벤트</target>
        </trans-unit>
        <trans-unit id="f78e390524cd3565f0dc8b46bd2ea361def72e8d" translate="yes" xml:space="preserve">
          <source>File Folder</source>
          <target state="translated">파일 폴더</target>
        </trans-unit>
        <trans-unit id="1b8c4bf7746a674619789c0353c0a64bca75a908" translate="yes" xml:space="preserve">
          <source>File extension for dynamic libraries (e.g. dll, dylib, so) on the current platform.</source>
          <target state="translated">현재 플랫폼에서 동적 라이브러리 (예 : dll, dylib 등)의 파일 확장자</target>
        </trans-unit>
        <trans-unit id="2a5ce0551b3bc16a4d13e2e3a13e5586cafae52b" translate="yes" xml:space="preserve">
          <source>File locations</source>
          <target state="translated">파일 위치</target>
        </trans-unit>
        <trans-unit id="2c420d28b90db2dee25055b2d7bd4981ad9a1524" translate="yes" xml:space="preserve">
          <source>File/function names are sometimes truncated (with &lt;code&gt;...&lt;/code&gt;), and indentation is truncated with a &lt;code&gt;+n&lt;/code&gt; at the beginning, where &lt;code&gt;n&lt;/code&gt; is the number of extra spaces that would have been inserted, had there been room. If you want a complete profile of deeply-nested code, often a good idea is to save to a file using a wide &lt;code&gt;displaysize&lt;/code&gt; in an &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">파일 / 함수 이름은 때때로 잘리고 ( &lt;code&gt;...&lt;/code&gt; 사용 ) 들여 쓰기는 처음에 &lt;code&gt;+n&lt;/code&gt; 으로 잘립니다 . 여기서 &lt;code&gt;n&lt;/code&gt; 은 여유 공간이있을 경우 삽입 된 추가 공간의 수입니다. 깊이 중첩 된 코드의 전체 프로파일을 원할 경우 &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt; 에서 넓은 &lt;code&gt;displaysize&lt;/code&gt; 크기를 사용하여 파일에 저장하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f8d8d763bd5d522952215bd9a9fc1f2faf928be9" translate="yes" xml:space="preserve">
          <source>FileWatching.poll_fd()</source>
          <target state="translated">FileWatching.poll_fd()</target>
        </trans-unit>
        <trans-unit id="9a0031862648613baa256a2b1e25c479a5254826" translate="yes" xml:space="preserve">
          <source>FileWatching.poll_file()</source>
          <target state="translated">FileWatching.poll_file()</target>
        </trans-unit>
        <trans-unit id="747de65fe94e8175642ef8c7cef685465b1b4bb5" translate="yes" xml:space="preserve">
          <source>FileWatching.unwatch_folder()</source>
          <target state="translated">FileWatching.unwatch_folder()</target>
        </trans-unit>
        <trans-unit id="d92f14cfa1ec3fdb1aad5fa8235becab8031e345" translate="yes" xml:space="preserve">
          <source>FileWatching.watch_file()</source>
          <target state="translated">FileWatching.watch_file()</target>
        </trans-unit>
        <trans-unit id="c0d5eb4225c04b069f17ff8146680ce4c975f229" translate="yes" xml:space="preserve">
          <source>FileWatching.watch_folder()</source>
          <target state="translated">FileWatching.watch_folder()</target>
        </trans-unit>
        <trans-unit id="0b5acc23bb7f272c55693528aa9ca461dacf6e0b" translate="yes" xml:space="preserve">
          <source>Files and file names are mostly unrelated to modules; modules are associated only with module expressions. One can have multiple files per module, and multiple modules per file:</source>
          <target state="translated">파일과 파일 이름은 대부분 모듈과 관련이 없습니다. 모듈은 모듈 표현식과 만 연관됩니다. 하나는 모듈 당 여러 파일을 가질 수 있고 파일 당 여러 모듈을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="092fe85f5c2e62269fa44ec1fcbf190e92f16564" translate="yes" xml:space="preserve">
          <source>Filesystem</source>
          <target state="translated">Filesystem</target>
        </trans-unit>
        <trans-unit id="66d37ac694679d2aaba78e1325d8da6c3e6b2dc1" translate="yes" xml:space="preserve">
          <source>Filesystem.cd()</source>
          <target state="translated">Filesystem.cd()</target>
        </trans-unit>
        <trans-unit id="4b83b49056e1fe9e1c6931b13ab708ea3d3dc5b1" translate="yes" xml:space="preserve">
          <source>Filesystem.cp()</source>
          <target state="translated">Filesystem.cp()</target>
        </trans-unit>
        <trans-unit id="a4dead2a6ad53fe70d8e528eef3724fac180b679" translate="yes" xml:space="preserve">
          <source>Filesystem.mv()</source>
          <target state="translated">Filesystem.mv()</target>
        </trans-unit>
        <trans-unit id="cf83f1b98e2416e6a59699657d24bd33d10365f7" translate="yes" xml:space="preserve">
          <source>Filesystem.rm()</source>
          <target state="translated">Filesystem.rm()</target>
        </trans-unit>
        <trans-unit id="e8602ecc6cdda92120a80db2b2896945fc2bc02d" translate="yes" xml:space="preserve">
          <source>Fill array &lt;code&gt;A&lt;/code&gt; with the value &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is an object reference, all elements will refer to the same object. &lt;code&gt;fill!(A, Foo())&lt;/code&gt; will return &lt;code&gt;A&lt;/code&gt; filled with the result of evaluating &lt;code&gt;Foo()&lt;/code&gt; once.</source>
          <target state="translated">배열 &lt;code&gt;A&lt;/code&gt; 를 값 &lt;code&gt;x&lt;/code&gt; 로 채 웁니다 . 경우 &lt;code&gt;x&lt;/code&gt; 개체 참조하고, 모든 요소가 동일한 객체를 참조한다. &lt;code&gt;fill!(A, Foo())&lt;/code&gt; 는 &lt;code&gt;Foo()&lt;/code&gt; 한 번 평가 한 결과로 채워진 &lt;code&gt;A&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="15f90b730a9bb3cbbb4e0be4003f4356fc9b9036" translate="yes" xml:space="preserve">
          <source>Fill the array &lt;code&gt;A&lt;/code&gt; with normally-distributed (mean 0, standard deviation 1) random numbers. Also see the &lt;a href=&quot;#Base.rand&quot;&gt;&lt;code&gt;rand&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">배열 &lt;code&gt;A&lt;/code&gt; 를 정규 분포 (평균 0, 표준 편차 1) 난수로 채 웁니다. &lt;a href=&quot;#Base.rand&quot;&gt; &lt;code&gt;rand&lt;/code&gt; &lt;/a&gt; 기능 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ae93e848c3d30d15d2b5012ea3af3f0ab55b5ca" translate="yes" xml:space="preserve">
          <source>Fill the array &lt;code&gt;A&lt;/code&gt; with random numbers following the exponential distribution (with scale 1).</source>
          <target state="translated">지수 분포 (스케일 1)에 따라 난수로 배열 &lt;code&gt;A&lt;/code&gt; 를 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="0e5d88ef3637a2479a8b258a074f4fa06d769918" translate="yes" xml:space="preserve">
          <source>Fills an array of the digits of &lt;code&gt;n&lt;/code&gt; in the given base. More significant digits are at higher indices. If the array length is insufficient, the least significant digits are filled up to the array length. If the array length is excessive, the excess portion is filled with zeros.</source>
          <target state="translated">주어진 밑에서 &lt;code&gt;n&lt;/code&gt; 의 자릿수 배열을 채 웁니다 . 더 큰 숫자는 더 높은 지수에 있습니다. 배열 길이가 충분하지 않은 경우 최하위 자릿수가 배열 길이까지 채워집니다. 배열 길이가 너무 길면 초과 부분이 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="22655b3e2d52ed1fe3abbc273a301c575c9c7fae" translate="yes" xml:space="preserve">
          <source>Finally, if &lt;code&gt;DummyModule.jl&lt;/code&gt; is not a standalone file but a package, then &lt;code&gt;using DummyModule&lt;/code&gt; will &lt;em&gt;load&lt;/em&gt;&lt;code&gt;DummyModule.jl&lt;/code&gt; on all processes, but only bring it into scope on the process where &lt;code&gt;using&lt;/code&gt; was called.</source>
          <target state="translated">마지막으로, 만약 &lt;code&gt;DummyModule.jl&lt;/code&gt; 는 독립형 파일 만 패키지되어 있지 않은 경우, &lt;code&gt;using DummyModule&lt;/code&gt; 것입니다 &lt;em&gt;로드 &lt;/em&gt; &lt;code&gt;DummyModule.jl&lt;/code&gt; 을 모든 프로세스에 있지만, 경우에만 과정에 범위에 그것을 가지고 &lt;code&gt;using&lt;/code&gt; 불렸다.</target>
        </trans-unit>
        <trans-unit id="f1c7a00722ed8c5c04db876017518449fd3a13b0" translate="yes" xml:space="preserve">
          <source>Finally, let's take a look at some more complex examples where this rule comes into play. Define a function &lt;code&gt;f(x)&lt;/code&gt;, which initially has one method:</source>
          <target state="translated">마지막으로이 규칙이 적용되는 좀 더 복잡한 예를 살펴 보겠습니다. &lt;code&gt;f(x)&lt;/code&gt; 함수를 정의하십시오. 처음에는 하나의 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8ab1a15d94e7105e3fcab5c9d28790890e0a56b" translate="yes" xml:space="preserve">
          <source>Finally, the &quot;exclusive or&quot; logical operator &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/a&gt; always propagates &lt;code&gt;missing&lt;/code&gt; values, since both operands always have an effect on the result. Also note that the negation operator &lt;a href=&quot;../../base/math/index#Base.:!&quot;&gt;&lt;code&gt;!&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;missing&lt;/code&gt; when the operand is &lt;code&gt;missing&lt;/code&gt; just like other unary operators.</source>
          <target state="translated">마지막으로, &quot;독점 또는&quot;논리 연산자 &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;xor&lt;/code&gt; 는&lt;/a&gt; 항상 결 &lt;code&gt;missing&lt;/code&gt; 전파 합니다. 두 피연산자가 항상 결과에 영향을 미치기 때문입니다. 또한 부정 연산자 &lt;a href=&quot;../../base/math/index#Base.:!&quot;&gt; &lt;code&gt;!&lt;/code&gt; &lt;/a&gt; 반환 &lt;code&gt;missing&lt;/code&gt; 피연산자가 될 때 &lt;code&gt;missing&lt;/code&gt; 단지 다른 단항 연산자처럼.</target>
        </trans-unit>
        <trans-unit id="767751161f0cdd1157de7a8f8d7964c9db4474ed" translate="yes" xml:space="preserve">
          <source>Finally, the maximum efficiency is typically achieved when the output array of a vectorized operation is &lt;em&gt;pre-allocated&lt;/em&gt;, so that repeated calls do not allocate new arrays over and over again for the results (see &lt;a href=&quot;../performance-tips/index#Pre-allocating-outputs-1&quot;&gt;Pre-allocating outputs&lt;/a&gt;). A convenient syntax for this is &lt;code&gt;X .= ...&lt;/code&gt;, which is equivalent to &lt;code&gt;broadcast!(identity, X, ...)&lt;/code&gt; except that, as above, the &lt;code&gt;broadcast!&lt;/code&gt; loop is fused with any nested &quot;dot&quot; calls. For example, &lt;code&gt;X .= sin.(Y)&lt;/code&gt; is equivalent to &lt;code&gt;broadcast!(sin, X, Y)&lt;/code&gt;, overwriting &lt;code&gt;X&lt;/code&gt; with &lt;code&gt;sin.(Y)&lt;/code&gt; in-place. If the left-hand side is an array-indexing expression, e.g. &lt;code&gt;X[2:end] .= sin.(Y)&lt;/code&gt;, then it translates to &lt;code&gt;broadcast!&lt;/code&gt; on a &lt;code&gt;view&lt;/code&gt;, e.g. &lt;code&gt;broadcast!(sin, view(X, 2:lastindex(X)), Y)&lt;/code&gt;, so that the left-hand side is updated in-place.</source>
          <target state="translated">마지막으로 최대 효율은 일반적으로 벡터화 된 연산의 출력 배열이 &lt;em&gt;사전 할당&lt;/em&gt; 될 때 달성 되므로 반복 된 호출이 결과에 대해 새 배열을 반복해서 할당하지 않습니다 ( &lt;a href=&quot;../performance-tips/index#Pre-allocating-outputs-1&quot;&gt;사전 할당 출력&lt;/a&gt; 참조 ). 이에 대한 편리한 구문은 &lt;code&gt;X .= ...&lt;/code&gt; 이며, 위와 같이 &lt;code&gt;broadcast!(identity, X, ...)&lt;/code&gt; 동일합니다 &lt;code&gt;broadcast!&lt;/code&gt; 루프는 중첩 된 &quot;도트&quot;호출과 융합됩니다. 예를 들어 &lt;code&gt;X .= sin.(Y)&lt;/code&gt; 는 &lt;code&gt;broadcast!(sin, X, Y)&lt;/code&gt; 와 동일하며 &lt;code&gt;X&lt;/code&gt; 를 &lt;code&gt;sin.(Y)&lt;/code&gt; 로 덮어 씁니다 . 왼쪽이 배열 인덱싱 표현식 인 경우 (예 : &lt;code&gt;X[2:end] .= sin.(Y)&lt;/code&gt; 그러면 &lt;code&gt;broadcast!&lt;/code&gt; 변환됩니다 ! A의 &lt;code&gt;view&lt;/code&gt; , 즉 &lt;code&gt;broadcast!(sin, view(X, 2:lastindex(X)), Y)&lt;/code&gt; , 그래서 왼쪽 제자리에서 업데이트된다.</target>
        </trans-unit>
        <trans-unit id="c12ff37c90964a19ee534ead21bebd3e9eed8809" translate="yes" xml:space="preserve">
          <source>Finally, we finish off our ongoing case study of Julia's rational number type, which makes relatively sophisticated use of the promotion mechanism with the following promotion rules:</source>
          <target state="translated">마지막으로, Julia의 합리적인 숫자 유형에 대한 진행중인 사례 연구를 마치고 다음과 같은 프로모션 규칙을 사용하여 프로모션 메커니즘을 비교적 정교하게 사용합니다.</target>
        </trans-unit>
        <trans-unit id="30b68f7e7af1c04cf4dd6e837e4591351c43581a" translate="yes" xml:space="preserve">
          <source>Finally, you can use &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; to actually generate a call to the library function. Arguments to &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; are as follows:</source>
          <target state="translated">마지막으로 &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 을 사용 하여 실제로 라이브러리 함수에 대한 호출을 생성 할 수 있습니다 . &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 대한 인수 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="feefe85d510994646d16a16714a8d3ae19ac8a26" translate="yes" xml:space="preserve">
          <source>Finally, you may also consider building Julia from source for yourself. This option is mainly for those individuals who are comfortable at the command line, or interested in learning. If this describes you, you may also be interested in reading our &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/CONTRIBUTING.md&quot;&gt;guidelines for contributing&lt;/a&gt;.</source>
          <target state="translated">마지막으로, 소스를 기반으로 Julia를 빌드하는 것도 고려할 수 있습니다. 이 옵션은 주로 명령 줄에 익숙하거나 학습에 관심이있는 사람들을위한 것입니다. 이 내용이 귀하를 설명하는 경우, &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/CONTRIBUTING.md&quot;&gt;기여 가이드 라인을&lt;/a&gt; 읽는 데 관심이있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f3fe342dc0e6c8372fd117cdbcdeaa485ff1b80" translate="yes" xml:space="preserve">
          <source>Finally,&lt;code&gt;where&lt;/code&gt; is parsed as an infix operator for writing parametric method and type definitions. Also &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;isa&lt;/code&gt; are parsed as infix operators. Creation of a variable named &lt;code&gt;where&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;isa&lt;/code&gt; is allowed though.</source>
          <target state="translated">마지막으로 &lt;code&gt;where&lt;/code&gt; 는 파라 메트릭 메소드 및 유형 정의를 작성하기위한 삽입 연산자로 구문 분석됩니다. 또한 &lt;code&gt;in&lt;/code&gt; 및 &lt;code&gt;isa&lt;/code&gt; 는 중위 연산자로 구문 분석됩니다. &lt;code&gt;where&lt;/code&gt; , &lt;code&gt;in&lt;/code&gt; 또는 &lt;code&gt;isa&lt;/code&gt; 라는 이름의 변수를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9b51ec67d633a0669dda1015ca213cfa3baaf80" translate="yes" xml:space="preserve">
          <source>Find &lt;code&gt;y::T&lt;/code&gt; such that &lt;code&gt;x&lt;/code&gt; &amp;equiv; &lt;code&gt;y&lt;/code&gt; (mod n), where n is the number of integers representable in &lt;code&gt;T&lt;/code&gt;, and &lt;code&gt;y&lt;/code&gt; is an integer in &lt;code&gt;[typemin(T),typemax(T)]&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; can represent any integer (e.g. &lt;code&gt;T == BigInt&lt;/code&gt;), then this operation corresponds to a conversion to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; &amp;equiv; &lt;code&gt;y&lt;/code&gt; (mod n) 와 같이 &lt;code&gt;y::T&lt;/code&gt; 찾으십시오 . 여기서 n은 &lt;code&gt;T&lt;/code&gt; 로 표현할 수있는 정수의 수 이고 &lt;code&gt;y&lt;/code&gt; 는 &lt;code&gt;[typemin(T),typemax(T)]&lt;/code&gt; 의 정수입니다 . 경우 &lt;code&gt;T&lt;/code&gt; 는 임의의 정수 (예를 나타낼 수 &lt;code&gt;T == BigInt&lt;/code&gt; )로 전환 된 다음에이 동작에 대응 &lt;code&gt;T&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="f647c9d8a07df297d4680ab0a11627650c460ccd" translate="yes" xml:space="preserve">
          <source>Find a merge base (a common ancestor) between the commits &lt;code&gt;one&lt;/code&gt; and &lt;code&gt;two&lt;/code&gt;. &lt;code&gt;one&lt;/code&gt; and &lt;code&gt;two&lt;/code&gt; may both be in string form. Return the &lt;code&gt;GitHash&lt;/code&gt; of the merge base.</source>
          <target state="translated">커밋 &lt;code&gt;one&lt;/code&gt; 과 &lt;code&gt;two&lt;/code&gt; 사이의 병합 기반 (공통 조상)을 찾으십시오 . &lt;code&gt;one&lt;/code&gt; 와 &lt;code&gt;two&lt;/code&gt; 은 모두 문자열 형식 일 수 있습니다. 머지베이스 의 &lt;code&gt;GitHash&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1825fce8a92f2ce1845fd36082521f2d3a4e162f" translate="yes" xml:space="preserve">
          <source>Find the first occurrence of &lt;code&gt;pattern&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt;. Equivalent to &lt;a href=&quot;#Base.findnext-Tuple%7BAbstractString,AbstractString,Integer%7D&quot;&gt;&lt;code&gt;findnext(pattern, string, firstindex(s))&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 에서 처음 나타나는 &lt;code&gt;pattern&lt;/code&gt; 을 찾으십시오 . 상당 &lt;a href=&quot;#Base.findnext-Tuple%7BAbstractString,AbstractString,Integer%7D&quot;&gt; &lt;code&gt;findnext(pattern, string, firstindex(s))&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b21d600b94cf0b778ba467005900538f19345af8" translate="yes" xml:space="preserve">
          <source>Find the index of the element of &lt;code&gt;dx&lt;/code&gt; with the maximum absolute value. &lt;code&gt;n&lt;/code&gt; is the length of &lt;code&gt;dx&lt;/code&gt;, and &lt;code&gt;incx&lt;/code&gt; is the stride. If &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;incx&lt;/code&gt; are not provided, they assume default values of &lt;code&gt;n=length(dx)&lt;/code&gt; and &lt;code&gt;incx=stride1(dx)&lt;/code&gt;.</source>
          <target state="translated">최대 절대 값을 가진 &lt;code&gt;dx&lt;/code&gt; 요소의 색인을 찾으십시오 . &lt;code&gt;n&lt;/code&gt; 은 &lt;code&gt;dx&lt;/code&gt; 의 길이 이고 &lt;code&gt;incx&lt;/code&gt; 는 보폭입니다. 경우 &lt;code&gt;n&lt;/code&gt; 과 &lt;code&gt;incx&lt;/code&gt; 이 제공되지 않습니다, 그들은의 기본 값 가정 &lt;code&gt;n=length(dx)&lt;/code&gt; 및 &lt;code&gt;incx=stride1(dx)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6eaf75b6910de284edca0478751e60e1ad92a9d8" translate="yes" xml:space="preserve">
          <source>Find the last occurrence of &lt;code&gt;pattern&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt;. Equivalent to &lt;a href=&quot;#Base.findprev-Tuple%7BAbstractString,AbstractString,Integer%7D&quot;&gt;&lt;code&gt;findprev(pattern, string, lastindex(string))&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 에서 마지막 &lt;code&gt;pattern&lt;/code&gt; 발생을 찾으십시오 . 상당 &lt;a href=&quot;#Base.findprev-Tuple%7BAbstractString,AbstractString,Integer%7D&quot;&gt; &lt;code&gt;findprev(pattern, string, lastindex(string))&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="552c8ae53a2283ce454807a34e7013b314ceea60" translate="yes" xml:space="preserve">
          <source>Find the maximum of &lt;code&gt;A&lt;/code&gt; and the corresponding linear index along singleton dimensions of &lt;code&gt;rval&lt;/code&gt; and &lt;code&gt;rind&lt;/code&gt;, and store the results in &lt;code&gt;rval&lt;/code&gt; and &lt;code&gt;rind&lt;/code&gt;. &lt;code&gt;NaN&lt;/code&gt; is treated as greater than all other values.</source>
          <target state="translated">최대 찾기 그리고 단일 차원을 따라 선형 대응 인덱스 &lt;code&gt;rval&lt;/code&gt; 에 와 &lt;code&gt;rind&lt;/code&gt; 한 결과의 저장 &lt;code&gt;rval&lt;/code&gt; 에 및 &lt;code&gt;rind&lt;/code&gt; . &lt;code&gt;NaN&lt;/code&gt; 은 다른 모든 값보다 큰 것으로 취급됩니다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9aa328c598b9330ac1b7a72be0fe532e46cd4d55" translate="yes" xml:space="preserve">
          <source>Find the minimum of &lt;code&gt;A&lt;/code&gt; and the corresponding linear index along singleton dimensions of &lt;code&gt;rval&lt;/code&gt; and &lt;code&gt;rind&lt;/code&gt;, and store the results in &lt;code&gt;rval&lt;/code&gt; and &lt;code&gt;rind&lt;/code&gt;. &lt;code&gt;NaN&lt;/code&gt; is treated as less than all other values.</source>
          <target state="translated">최소 찾기 그리고 단일 차원을 따라 선형 대응 인덱스 &lt;code&gt;rval&lt;/code&gt; 에 와 &lt;code&gt;rind&lt;/code&gt; 한 결과의 저장 &lt;code&gt;rval&lt;/code&gt; 에 및 &lt;code&gt;rind&lt;/code&gt; . &lt;code&gt;NaN&lt;/code&gt; 은 다른 모든 값보다 적습니다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d865db872da82af36f837e5f310f73145bef3112" translate="yes" xml:space="preserve">
          <source>Find the next index after or including &lt;code&gt;i&lt;/code&gt; of a &lt;code&gt;true&lt;/code&gt; element of &lt;code&gt;A&lt;/code&gt;, or &lt;code&gt;nothing&lt;/code&gt; if not found.</source>
          <target state="translated">또는 포함 후에 다음 인덱스를 찾기 &lt;code&gt;i&lt;/code&gt; (A)의 &lt;code&gt;true&lt;/code&gt; 의 요소 , 또는 &lt;code&gt;nothing&lt;/code&gt; 발견되지 않는 경우는. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3bed36c27812d4cd102ecb3fe1568c0bed863342" translate="yes" xml:space="preserve">
          <source>Find the next index after or including &lt;code&gt;i&lt;/code&gt; of an element of &lt;code&gt;A&lt;/code&gt; for which &lt;code&gt;predicate&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, or &lt;code&gt;nothing&lt;/code&gt; if not found.</source>
          <target state="translated">또는 포함 후에 다음 인덱스를 찾기 &lt;code&gt;i&lt;/code&gt; 의 요소의 하는 &lt;code&gt;predicate&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; , 또는 &lt;code&gt;nothing&lt;/code&gt; 발견되지 않는 경우는. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7a1d8f46d937916c8787067db2b2714283d812a5" translate="yes" xml:space="preserve">
          <source>Find the next occurrence of &lt;code&gt;pattern&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt; starting at position &lt;code&gt;start&lt;/code&gt;. &lt;code&gt;pattern&lt;/code&gt; can be either a string, or a regular expression, in which case &lt;code&gt;string&lt;/code&gt; must be of type &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 위치에서 시작 하여 &lt;code&gt;string&lt;/code&gt; 에서 다음 &lt;code&gt;pattern&lt;/code&gt; 을 찾습니다 . &lt;code&gt;pattern&lt;/code&gt; 은 문자열이거나 정규식 일 수 있으며,이 경우 &lt;code&gt;string&lt;/code&gt; 은 &lt;code&gt;String&lt;/code&gt; 유형이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="5acd53075bd7738ba5874f9d2945af016adac780" translate="yes" xml:space="preserve">
          <source>Find the previous index before or including &lt;code&gt;i&lt;/code&gt; of a &lt;code&gt;true&lt;/code&gt; element of &lt;code&gt;A&lt;/code&gt;, or &lt;code&gt;nothing&lt;/code&gt; if not found.</source>
          <target state="translated">또는 포함하기 전에 이전 인덱스를 찾기 &lt;code&gt;i&lt;/code&gt; (A)의 &lt;code&gt;true&lt;/code&gt; 의 요소 , 또는 &lt;code&gt;nothing&lt;/code&gt; 발견되지 않는 경우는. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac4b726fe8ef16af102227f0592ab9d5019209eb" translate="yes" xml:space="preserve">
          <source>Find the previous index before or including &lt;code&gt;i&lt;/code&gt; of an element of &lt;code&gt;A&lt;/code&gt; for which &lt;code&gt;predicate&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, or &lt;code&gt;nothing&lt;/code&gt; if not found.</source>
          <target state="translated">또는 포함하기 전에 이전 인덱스를 찾기 &lt;code&gt;i&lt;/code&gt; 의 요소의 하는 &lt;code&gt;predicate&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; , 또는 &lt;code&gt;nothing&lt;/code&gt; 발견되지 않는 경우는. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7099f261e64c52f512558cba2d47b4f0bc49c077" translate="yes" xml:space="preserve">
          <source>Find the previous occurrence of &lt;code&gt;pattern&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt; starting at position &lt;code&gt;start&lt;/code&gt;.</source>
          <target state="translated">위치 &lt;code&gt;start&lt;/code&gt; 에서 시작 하는 &lt;code&gt;string&lt;/code&gt; 에서 이전에 나타난 &lt;code&gt;pattern&lt;/code&gt; 을 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="0eee018a6003d420d94f270f4deb2bf0aff001cc" translate="yes" xml:space="preserve">
          <source>Find the root module of a given module. This is the first module in the chain of parent modules of &lt;code&gt;m&lt;/code&gt; which is either a registered root module or which is its own parent module.</source>
          <target state="translated">주어진 모듈의 루트 모듈을 찾으십시오. 이것은 등록 된 루트 모듈이거나 자체 상위 모듈 인 &lt;code&gt;m&lt;/code&gt; 의 상위 모듈 체인에서 첫 번째 모듈입니다 .</target>
        </trans-unit>
        <trans-unit id="48db6f6163bbca28ad1cb048ef296ccaadb4bcda" translate="yes" xml:space="preserve">
          <source>Finding the length of time between two &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; is straightforward given their underlying representation as &lt;code&gt;UTInstant{Day}&lt;/code&gt; and &lt;code&gt;UTInstant{Millisecond}&lt;/code&gt;, respectively. The difference between &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; is returned in the number of &lt;a href=&quot;#Dates.Day-Tuple%7BTimeType%7D&quot;&gt;&lt;code&gt;Day&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; in the number of &lt;a href=&quot;#Dates.Millisecond-Tuple%7BDateTime%7D&quot;&gt;&lt;code&gt;Millisecond&lt;/code&gt;&lt;/a&gt;. Similarly, comparing &lt;a href=&quot;#Dates.TimeType&quot;&gt;&lt;code&gt;TimeType&lt;/code&gt;&lt;/a&gt; is a simple matter of comparing the underlying machine instants (which in turn compares the internal &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt; values).</source>
          <target state="translated">두 &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 사이의 시간을 찾는 것은 기본적으로 각각 &lt;code&gt;UTInstant{Day}&lt;/code&gt; 및 &lt;code&gt;UTInstant{Millisecond}&lt;/code&gt; 로 표시되므로 간단 합니다. &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 의 차이 는 &lt;a href=&quot;#Dates.Day-Tuple%7BTimeType%7D&quot;&gt; &lt;code&gt;Day&lt;/code&gt; &lt;/a&gt; 수로 , &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#Dates.Millisecond-Tuple%7BDateTime%7D&quot;&gt; &lt;code&gt;Millisecond&lt;/code&gt; &lt;/a&gt; 수로 반환됩니다 . 마찬가지로 &lt;a href=&quot;#Dates.TimeType&quot;&gt; &lt;code&gt;TimeType&lt;/code&gt; &lt;/a&gt; 을 비교하는 것은 기본 컴퓨터 순간을 비교하는 간단한 문제입니다 (내부 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; 값을 비교 합니다).</target>
        </trans-unit>
        <trans-unit id="2069d729b3672a99ea2f38ff359c481d7de66468" translate="yes" xml:space="preserve">
          <source>Finds the &lt;code&gt;LU&lt;/code&gt; factorization of a tridiagonal matrix with &lt;code&gt;dl&lt;/code&gt; on the subdiagonal, &lt;code&gt;d&lt;/code&gt; on the diagonal, and &lt;code&gt;du&lt;/code&gt; on the superdiagonal.</source>
          <target state="translated">찾아 &lt;code&gt;LU&lt;/code&gt; 의 삼중 대각 매트릭스 분해의 &lt;code&gt;dl&lt;/code&gt; subdiagonal에 &lt;code&gt;d&lt;/code&gt; 대각선을 한 &lt;code&gt;du&lt;/code&gt; 에 superdiagonal.</target>
        </trans-unit>
        <trans-unit id="f84cbc64cd18b52fd324e199af11a5fabde58655" translate="yes" xml:space="preserve">
          <source>Finds the eigensystem of &lt;code&gt;A&lt;/code&gt; with matrix balancing. If &lt;code&gt;jobvl = N&lt;/code&gt;, the left eigenvectors of &lt;code&gt;A&lt;/code&gt; aren't computed. If &lt;code&gt;jobvr = N&lt;/code&gt;, the right eigenvectors of &lt;code&gt;A&lt;/code&gt; aren't computed. If &lt;code&gt;jobvl = V&lt;/code&gt; or &lt;code&gt;jobvr = V&lt;/code&gt;, the corresponding eigenvectors are computed. If &lt;code&gt;balanc = N&lt;/code&gt;, no balancing is performed. If &lt;code&gt;balanc = P&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is permuted but not scaled. If &lt;code&gt;balanc = S&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is scaled but not permuted. If &lt;code&gt;balanc = B&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is permuted and scaled. If &lt;code&gt;sense = N&lt;/code&gt;, no reciprocal condition numbers are computed. If &lt;code&gt;sense = E&lt;/code&gt;, reciprocal condition numbers are computed for the eigenvalues only. If &lt;code&gt;sense = V&lt;/code&gt;, reciprocal condition numbers are computed for the right eigenvectors only. If &lt;code&gt;sense = B&lt;/code&gt;, reciprocal condition numbers are computed for the right eigenvectors and the eigenvectors. If &lt;code&gt;sense = E,B&lt;/code&gt;, the right and left eigenvectors must be computed.</source>
          <target state="translated">매트릭스 밸런싱을 사용 하여 &lt;code&gt;A&lt;/code&gt; 의 고유 시스템을 찾습니다 . 경우 &lt;code&gt;jobvl = N&lt;/code&gt; , 왼쪽의 고유 벡터 &lt;code&gt;A&lt;/code&gt; 는 산출되지 않는다. 경우 &lt;code&gt;jobvr = N&lt;/code&gt; , 우측 고유 벡터 &lt;code&gt;A&lt;/code&gt; 는 산출되지 않는다. 경우 &lt;code&gt;jobvl = V&lt;/code&gt; 또는 &lt;code&gt;jobvr = V&lt;/code&gt; , 대응하는 고유 벡터가 계산된다. 경우 &lt;code&gt;balanc = N&lt;/code&gt; 어떠한 균형이 수행되지 않는다. 경우 &lt;code&gt;balanc = P&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 는 순열하지만 크기는 조절되지 않습니다. 경우 &lt;code&gt;balanc = S&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 는 축소되지만 순열되지 않습니다. 경우 &lt;code&gt;balanc = B&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 는 순열 및 스케일링된다. &lt;code&gt;sense = N&lt;/code&gt; 경우상호 조건 번호는 계산되지 않습니다. 경우 &lt;code&gt;sense = E&lt;/code&gt; , 상호 조건 번호는 고유 값에 대해 계산된다. &lt;code&gt;sense = V&lt;/code&gt; 인 경우 , 올바른 고유 벡터에 대해서만 상호 조건 번호가 계산됩니다. 경우 &lt;code&gt;sense = B&lt;/code&gt; , 상호 조건 번호는 고유 벡터 및 우측 고유 벡터에 대해 계산된다. 만약 &lt;code&gt;sense = E,B&lt;/code&gt; 오른쪽과 왼쪽 고유 벡터 계산해야합니다.</target>
        </trans-unit>
        <trans-unit id="d0023ab74a3d6a6fa55c15cb99a0305228d939c9" translate="yes" xml:space="preserve">
          <source>Finds the eigensystem of &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;jobvl = N&lt;/code&gt;, the left eigenvectors of &lt;code&gt;A&lt;/code&gt; aren't computed. If &lt;code&gt;jobvr = N&lt;/code&gt;, the right eigenvectors of &lt;code&gt;A&lt;/code&gt; aren't computed. If &lt;code&gt;jobvl = V&lt;/code&gt; or &lt;code&gt;jobvr = V&lt;/code&gt;, the corresponding eigenvectors are computed. Returns the eigenvalues in &lt;code&gt;W&lt;/code&gt;, the right eigenvectors in &lt;code&gt;VR&lt;/code&gt;, and the left eigenvectors in &lt;code&gt;VL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 고유 시스템을 찾습니다 . 경우 &lt;code&gt;jobvl = N&lt;/code&gt; , 왼쪽의 고유 벡터 &lt;code&gt;A&lt;/code&gt; 는 산출되지 않는다. 경우 &lt;code&gt;jobvr = N&lt;/code&gt; , 우측 고유 벡터 &lt;code&gt;A&lt;/code&gt; 는 산출되지 않는다. 경우 &lt;code&gt;jobvl = V&lt;/code&gt; 또는 &lt;code&gt;jobvr = V&lt;/code&gt; , 대응하는 고유 벡터가 계산된다. &lt;code&gt;W&lt;/code&gt; 의 고유 값 , &lt;code&gt;VR&lt;/code&gt; 의 오른쪽 고유 벡터, &lt;code&gt;VL&lt;/code&gt; 의 왼쪽 고유 벡터를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f3c756f96984dbd050044ac948d5f71380b56742" translate="yes" xml:space="preserve">
          <source>Finds the eigensystem of an upper triangular matrix &lt;code&gt;T&lt;/code&gt;. If &lt;code&gt;side = R&lt;/code&gt;, the right eigenvectors are computed. If &lt;code&gt;side = L&lt;/code&gt;, the left eigenvectors are computed. If &lt;code&gt;side = B&lt;/code&gt;, both sets are computed. If &lt;code&gt;howmny = A&lt;/code&gt;, all eigenvectors are found. If &lt;code&gt;howmny = B&lt;/code&gt;, all eigenvectors are found and backtransformed using &lt;code&gt;VL&lt;/code&gt; and &lt;code&gt;VR&lt;/code&gt;. If &lt;code&gt;howmny = S&lt;/code&gt;, only the eigenvectors corresponding to the values in &lt;code&gt;select&lt;/code&gt; are computed.</source>
          <target state="translated">상부 삼각 행렬 &lt;code&gt;T&lt;/code&gt; 의 고유 시스템을 찾습니다 . 하면 &lt;code&gt;side = R&lt;/code&gt; , 우측 고유 벡터가 계산된다. 하면 &lt;code&gt;side = L&lt;/code&gt; , 왼쪽의 고유 벡터가 계산된다. 하면 &lt;code&gt;side = B&lt;/code&gt; , 두 세트가 계산된다. 경우 &lt;code&gt;howmny = A&lt;/code&gt; 모든 고유 벡터가 발견된다. 경우 &lt;code&gt;howmny = B&lt;/code&gt; 모든 고유 벡터 발견하고 사용 backtransformed하는 &lt;code&gt;VL&lt;/code&gt; 및 &lt;code&gt;VR&lt;/code&gt; 을 . 경우 &lt;code&gt;howmny = S&lt;/code&gt; ,의 값에 대응하는 고유 벡터만을 &lt;code&gt;select&lt;/code&gt; 계산된다.</target>
        </trans-unit>
        <trans-unit id="0322800c8fc7bfd25f123e3f433827d776d8a68b" translate="yes" xml:space="preserve">
          <source>Finds the eigenvalues (&lt;code&gt;jobz = N&lt;/code&gt;) or eigenvalues and eigenvectors (&lt;code&gt;jobz = V&lt;/code&gt;) of a symmetric matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, the upper triangle of &lt;code&gt;A&lt;/code&gt; is used. If &lt;code&gt;uplo = L&lt;/code&gt;, the lower triangle of &lt;code&gt;A&lt;/code&gt; is used.</source>
          <target state="translated">대칭 행렬 &lt;code&gt;A&lt;/code&gt; 의 고유 값 ( &lt;code&gt;jobz = N&lt;/code&gt; ) 또는 고유 값과 고유 벡터 ( &lt;code&gt;jobz = V&lt;/code&gt; )를 찾습니다 . 경우 &lt;code&gt;uplo = U&lt;/code&gt; 의 상단 삼각형 &lt;code&gt;A&lt;/code&gt; 는 사용됩니다. &lt;code&gt;uplo = L&lt;/code&gt; 인 경우 &lt;code&gt;A&lt;/code&gt; 의 아래쪽 삼각형 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d4975ecab6a2216e2ae41b865699cde79f331c8b" translate="yes" xml:space="preserve">
          <source>Finds the eigenvalues (&lt;code&gt;jobz = N&lt;/code&gt;) or eigenvalues and eigenvectors (&lt;code&gt;jobz = V&lt;/code&gt;) of a symmetric matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, the upper triangle of &lt;code&gt;A&lt;/code&gt; is used. If &lt;code&gt;uplo = L&lt;/code&gt;, the lower triangle of &lt;code&gt;A&lt;/code&gt; is used. If &lt;code&gt;range = A&lt;/code&gt;, all the eigenvalues are found. If &lt;code&gt;range = V&lt;/code&gt;, the eigenvalues in the half-open interval &lt;code&gt;(vl, vu]&lt;/code&gt; are found. If &lt;code&gt;range = I&lt;/code&gt;, the eigenvalues with indices between &lt;code&gt;il&lt;/code&gt; and &lt;code&gt;iu&lt;/code&gt; are found. &lt;code&gt;abstol&lt;/code&gt; can be set as a tolerance for convergence.</source>
          <target state="translated">대칭 행렬 &lt;code&gt;A&lt;/code&gt; 의 고유 값 ( &lt;code&gt;jobz = N&lt;/code&gt; ) 또는 고유 값과 고유 벡터 ( &lt;code&gt;jobz = V&lt;/code&gt; )를 찾습니다 . 경우 &lt;code&gt;uplo = U&lt;/code&gt; 의 상단 삼각형 &lt;code&gt;A&lt;/code&gt; 는 사용됩니다. &lt;code&gt;uplo = L&lt;/code&gt; 인 경우 &lt;code&gt;A&lt;/code&gt; 의 아래쪽 삼각형 이 사용됩니다. 경우 &lt;code&gt;range = A&lt;/code&gt; , 모든 고유 값이 발견된다. 만약 &lt;code&gt;range = V&lt;/code&gt; , 반 열린 구간에서 고유 값 &lt;code&gt;(vl, vu]&lt;/code&gt; 경우. 발견 &lt;code&gt;range = I&lt;/code&gt; 사이의 지수와 고유 값 &lt;code&gt;il&lt;/code&gt; 및 &lt;code&gt;iu&lt;/code&gt; 발견된다. &lt;code&gt;abstol&lt;/code&gt; 는 융합 공차로 설정 될 수있다.</target>
        </trans-unit>
        <trans-unit id="61beb0a5e34ea39a8997c5ca322120812554427f" translate="yes" xml:space="preserve">
          <source>Finds the generalized eigendecomposition of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;. If &lt;code&gt;jobvl = N&lt;/code&gt;, the left eigenvectors aren't computed. If &lt;code&gt;jobvr = N&lt;/code&gt;, the right eigenvectors aren't computed. If &lt;code&gt;jobvl = V&lt;/code&gt; or &lt;code&gt;jobvr = V&lt;/code&gt;, the corresponding eigenvectors are computed.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 의 일반 고유 분해를 찾습니다 . 경우 &lt;code&gt;jobvl = N&lt;/code&gt; , 왼쪽의 고유 벡터를 계산하지 않는다. 경우 &lt;code&gt;jobvr = N&lt;/code&gt; 우측 고유 벡터가 산출되지 않는다. 경우 &lt;code&gt;jobvl = V&lt;/code&gt; 또는 &lt;code&gt;jobvr = V&lt;/code&gt; , 대응하는 고유 벡터가 계산된다.</target>
        </trans-unit>
        <trans-unit id="c264a1b0e814f3cbf1d8360c3568e4b5d9e1b127" translate="yes" xml:space="preserve">
          <source>Finds the generalized eigenvalues (&lt;code&gt;jobz = N&lt;/code&gt;) or eigenvalues and eigenvectors (&lt;code&gt;jobz = V&lt;/code&gt;) of a symmetric matrix &lt;code&gt;A&lt;/code&gt; and symmetric positive-definite matrix &lt;code&gt;B&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, the upper triangles of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are used. If &lt;code&gt;uplo = L&lt;/code&gt;, the lower triangles of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are used. If &lt;code&gt;itype = 1&lt;/code&gt;, the problem to solve is &lt;code&gt;A * x = lambda * B * x&lt;/code&gt;. If &lt;code&gt;itype = 2&lt;/code&gt;, the problem to solve is &lt;code&gt;A * B * x = lambda * x&lt;/code&gt;. If &lt;code&gt;itype = 3&lt;/code&gt;, the problem to solve is &lt;code&gt;B * A * x = lambda * x&lt;/code&gt;.</source>
          <target state="translated">대칭 행렬 &lt;code&gt;A&lt;/code&gt; 와 대칭 양의 유한 행렬 &lt;code&gt;B&lt;/code&gt; 의 일반화 된 고유 값 ( &lt;code&gt;jobz = N&lt;/code&gt; ) 또는 고유 값과 고유 벡터 ( &lt;code&gt;jobz = V&lt;/code&gt; )를 찾습니다 . &lt;code&gt;uplo = U&lt;/code&gt; 인 경우 &lt;code&gt;A&lt;/code&gt; 및 &lt;code&gt;B&lt;/code&gt; 의 상단 삼각형 이 사용됩니다. &lt;code&gt;uplo = L&lt;/code&gt; 인 경우 &lt;code&gt;A&lt;/code&gt; 및 &lt;code&gt;B&lt;/code&gt; 의 아래쪽 삼각형 이 사용됩니다. 경우 &lt;code&gt;itype = 1&lt;/code&gt; 해결하는 문제는 &lt;code&gt;A * x = lambda * B * x&lt;/code&gt; . 경우 &lt;code&gt;itype = 2&lt;/code&gt; , 해결하는 문제는 &lt;code&gt;A * B * x = lambda * x&lt;/code&gt; . 경우 &lt;code&gt;itype = 3&lt;/code&gt; , 해결하는 문제는 &lt;code&gt;B * A * x = lambda * x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32def567c6d9738ac90487f8efbe1b9b389479aa" translate="yes" xml:space="preserve">
          <source>Finds the generalized singular value decomposition of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;U'*A*Q = D1*R&lt;/code&gt; and &lt;code&gt;V'*B*Q = D2*R&lt;/code&gt;. &lt;code&gt;D1&lt;/code&gt; has &lt;code&gt;alpha&lt;/code&gt; on its diagonal and &lt;code&gt;D2&lt;/code&gt; has &lt;code&gt;beta&lt;/code&gt; on its diagonal. If &lt;code&gt;jobu = U&lt;/code&gt;, the orthogonal/unitary matrix &lt;code&gt;U&lt;/code&gt; is computed. If &lt;code&gt;jobv = V&lt;/code&gt; the orthogonal/unitary matrix &lt;code&gt;V&lt;/code&gt; is computed. If &lt;code&gt;jobq = Q&lt;/code&gt;, the orthogonal/unitary matrix &lt;code&gt;Q&lt;/code&gt; is computed. If &lt;code&gt;jobu&lt;/code&gt;, &lt;code&gt;jobv&lt;/code&gt; or &lt;code&gt;jobq&lt;/code&gt; is &lt;code&gt;N&lt;/code&gt;, that matrix is not computed. This function is only available in LAPACK versions prior to 3.6.0.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 의 일반화 된 특이 값 분해 , &lt;code&gt;U'*A*Q = D1*R&lt;/code&gt; 및 &lt;code&gt;V'*B*Q = D2*R&lt;/code&gt; 찾습니다 . &lt;code&gt;D1&lt;/code&gt; 은 대각선에 &lt;code&gt;alpha&lt;/code&gt; 가 있고 &lt;code&gt;D2&lt;/code&gt; 는 대각선에 &lt;code&gt;beta&lt;/code&gt; 가 있습니다. 경우 &lt;code&gt;jobu = U&lt;/code&gt; 직교 / 유니 터리 행렬 &lt;code&gt;U&lt;/code&gt; 를 계산한다. 경우 &lt;code&gt;jobv = V&lt;/code&gt; 직교 / 유니 터리 행렬 &lt;code&gt;V&lt;/code&gt; 는 계산된다. 경우 &lt;code&gt;jobq = Q&lt;/code&gt; 직교 / 단위 행렬 &lt;code&gt;Q&lt;/code&gt; 가 계산된다. 만약 &lt;code&gt;jobu&lt;/code&gt; , &lt;code&gt;jobv&lt;/code&gt; 또는 &lt;code&gt;jobq&lt;/code&gt; 가 있다 &lt;code&gt;N&lt;/code&gt; 해당 행렬은 계산되지 않습니다. 이 기능은 3.6.0 이전의 LAPACK 버전에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="210e81d5d1ad1ff32c30a0939ad6da82758f3395" translate="yes" xml:space="preserve">
          <source>Finds the generalized singular value decomposition of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;U'*A*Q = D1*R&lt;/code&gt; and &lt;code&gt;V'*B*Q = D2*R&lt;/code&gt;. &lt;code&gt;D1&lt;/code&gt; has &lt;code&gt;alpha&lt;/code&gt; on its diagonal and &lt;code&gt;D2&lt;/code&gt; has &lt;code&gt;beta&lt;/code&gt; on its diagonal. If &lt;code&gt;jobu = U&lt;/code&gt;, the orthogonal/unitary matrix &lt;code&gt;U&lt;/code&gt; is computed. If &lt;code&gt;jobv = V&lt;/code&gt; the orthogonal/unitary matrix &lt;code&gt;V&lt;/code&gt; is computed. If &lt;code&gt;jobq = Q&lt;/code&gt;, the orthogonal/unitary matrix &lt;code&gt;Q&lt;/code&gt; is computed. If &lt;code&gt;jobu&lt;/code&gt;, &lt;code&gt;jobv&lt;/code&gt;, or &lt;code&gt;jobq&lt;/code&gt; is &lt;code&gt;N&lt;/code&gt;, that matrix is not computed. This function requires LAPACK 3.6.0.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 의 일반화 된 특이 값 분해 , &lt;code&gt;U'*A*Q = D1*R&lt;/code&gt; 및 &lt;code&gt;V'*B*Q = D2*R&lt;/code&gt; 찾습니다 . &lt;code&gt;D1&lt;/code&gt; 은 대각선에 &lt;code&gt;alpha&lt;/code&gt; 가 있고 &lt;code&gt;D2&lt;/code&gt; 는 대각선에 &lt;code&gt;beta&lt;/code&gt; 가 있습니다. 경우 &lt;code&gt;jobu = U&lt;/code&gt; 직교 / 유니 터리 행렬 &lt;code&gt;U&lt;/code&gt; 를 계산한다. 경우 &lt;code&gt;jobv = V&lt;/code&gt; 직교 / 유니 터리 행렬 &lt;code&gt;V&lt;/code&gt; 는 계산된다. 경우 &lt;code&gt;jobq = Q&lt;/code&gt; 직교 / 단위 행렬 &lt;code&gt;Q&lt;/code&gt; 가 계산된다. 만약 &lt;code&gt;jobu&lt;/code&gt; , &lt;code&gt;jobv&lt;/code&gt; , 또는 &lt;code&gt;jobq&lt;/code&gt; 가 있다 &lt;code&gt;N&lt;/code&gt; 해당 행렬은 계산되지 않습니다. 이 기능에는 LAPACK 3.6.0이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a39c044a480fd441ceb8f283f49fa1d53cc5f0a7" translate="yes" xml:space="preserve">
          <source>Finds the inverse of (upper if &lt;code&gt;uplo = U&lt;/code&gt;, lower if &lt;code&gt;uplo = L&lt;/code&gt;) triangular matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;diag = N&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; has non-unit diagonal elements. If &lt;code&gt;diag = U&lt;/code&gt;, all diagonal elements of &lt;code&gt;A&lt;/code&gt; are one. &lt;code&gt;A&lt;/code&gt; is overwritten with its inverse.</source>
          <target state="translated">삼각 행렬 &lt;code&gt;A&lt;/code&gt; 의 역수를 &lt;code&gt;uplo = U&lt;/code&gt; ( uplo = U 이면 위 , &lt;code&gt;uplo = L&lt;/code&gt; 이면 아래 ) . 경우 &lt;code&gt;diag = N&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 는 비 - 부 대각 요소를 갖는다. 경우 &lt;code&gt;diag = U&lt;/code&gt; 의 모든 대각선 요소 &lt;code&gt;A&lt;/code&gt; 는 하나입니다. &lt;code&gt;A&lt;/code&gt; 는 역으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="6a5d68361868fdd15faef2d4f1871095495175a9" translate="yes" xml:space="preserve">
          <source>Finds the reciprocal condition number of (upper if &lt;code&gt;uplo = U&lt;/code&gt;, lower if &lt;code&gt;uplo = L&lt;/code&gt;) triangular matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;diag = N&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; has non-unit diagonal elements. If &lt;code&gt;diag = U&lt;/code&gt;, all diagonal elements of &lt;code&gt;A&lt;/code&gt; are one. If &lt;code&gt;norm = I&lt;/code&gt;, the condition number is found in the infinity norm. If &lt;code&gt;norm = O&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;, the condition number is found in the one norm.</source>
          <target state="translated">삼각 행렬 &lt;code&gt;A&lt;/code&gt; 의 역수 조건 수를 찾습니다 ( &lt;code&gt;uplo = U&lt;/code&gt; 인 경우 상위 , &lt;code&gt;uplo = L&lt;/code&gt; 경우 하위 ) . 경우 &lt;code&gt;diag = N&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 는 비 - 부 대각 요소를 갖는다. 경우 &lt;code&gt;diag = U&lt;/code&gt; 의 모든 대각선 요소 &lt;code&gt;A&lt;/code&gt; 는 하나입니다. 경우 &lt;code&gt;norm = I&lt;/code&gt; , 조건 수는 무한대의 규범에서 발견된다. 경우 &lt;code&gt;norm = O&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; 의 조건 수는 하나 개의 표준에서 발견된다.</target>
        </trans-unit>
        <trans-unit id="c78886357b0729c06906090f44a5cf8b7b256de8" translate="yes" xml:space="preserve">
          <source>Finds the reciprocal condition number of matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;normtype = I&lt;/code&gt;, the condition number is found in the infinity norm. If &lt;code&gt;normtype = O&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;, the condition number is found in the one norm. &lt;code&gt;A&lt;/code&gt; must be the result of &lt;code&gt;getrf!&lt;/code&gt; and &lt;code&gt;anorm&lt;/code&gt; is the norm of &lt;code&gt;A&lt;/code&gt; in the relevant norm.</source>
          <target state="translated">행렬 &lt;code&gt;A&lt;/code&gt; 의 역수를 구합니다 . 경우 &lt;code&gt;normtype = I&lt;/code&gt; , 조건 수는 무한대의 규범에서 발견된다. 경우 &lt;code&gt;normtype = O&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; 의 조건 수는 하나 개의 표준에서 발견된다. &lt;code&gt;A&lt;/code&gt; 는 의 결과이어야합니다 &lt;code&gt;getrf!&lt;/code&gt; 및 &lt;code&gt;anorm&lt;/code&gt; 은 의 규범 관련 규범이다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c19c48ac3ae5442f994d8fe0a9d01dd34ef53de" translate="yes" xml:space="preserve">
          <source>Finds the singular value decomposition of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = U * S * V'&lt;/code&gt;, using a divide and conquer approach. If &lt;code&gt;job = A&lt;/code&gt;, all the columns of &lt;code&gt;U&lt;/code&gt; and the rows of &lt;code&gt;V'&lt;/code&gt; are computed. If &lt;code&gt;job = N&lt;/code&gt;, no columns of &lt;code&gt;U&lt;/code&gt; or rows of &lt;code&gt;V'&lt;/code&gt; are computed. If &lt;code&gt;job = O&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is overwritten with the columns of (thin) &lt;code&gt;U&lt;/code&gt; and the rows of (thin) &lt;code&gt;V'&lt;/code&gt;. If &lt;code&gt;job = S&lt;/code&gt;, the columns of (thin) &lt;code&gt;U&lt;/code&gt; and the rows of (thin) &lt;code&gt;V'&lt;/code&gt; are computed and returned separately.</source>
          <target state="translated">나누기 및 정복 방법을 사용하여 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A = U * S * V'&lt;/code&gt; 의 특이 값 분해를 찾습니다 . &lt;code&gt;job = A&lt;/code&gt; 인 경우 &lt;code&gt;U&lt;/code&gt; 의 모든 열과 &lt;code&gt;V'&lt;/code&gt; 의 행 이 계산됩니다. 경우 &lt;code&gt;job = N&lt;/code&gt; , 어떤의 열 &lt;code&gt;U&lt;/code&gt; 또는 행 &lt;code&gt;V'&lt;/code&gt; 계산되지 않습니다. 경우 &lt;code&gt;job = O&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 는 (얇은)의 열이 덮어 &lt;code&gt;U&lt;/code&gt; 와 (얇은)의 행 &lt;code&gt;V'&lt;/code&gt; . 경우 &lt;code&gt;job = S&lt;/code&gt; (박막)의 열 &lt;code&gt;U&lt;/code&gt; 및 (박막)의 행 &lt;code&gt;V'&lt;/code&gt; 계산 따로 반환된다.</target>
        </trans-unit>
        <trans-unit id="a0b3e8d21586ca0fb1724dcb3c78acc9787461cc" translate="yes" xml:space="preserve">
          <source>Finds the singular value decomposition of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = U * S * V'&lt;/code&gt;. If &lt;code&gt;jobu = A&lt;/code&gt;, all the columns of &lt;code&gt;U&lt;/code&gt; are computed. If &lt;code&gt;jobvt = A&lt;/code&gt; all the rows of &lt;code&gt;V'&lt;/code&gt; are computed. If &lt;code&gt;jobu = N&lt;/code&gt;, no columns of &lt;code&gt;U&lt;/code&gt; are computed. If &lt;code&gt;jobvt = N&lt;/code&gt; no rows of &lt;code&gt;V'&lt;/code&gt; are computed. If &lt;code&gt;jobu = O&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is overwritten with the columns of (thin) &lt;code&gt;U&lt;/code&gt;. If &lt;code&gt;jobvt = O&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is overwritten with the rows of (thin) &lt;code&gt;V'&lt;/code&gt;. If &lt;code&gt;jobu = S&lt;/code&gt;, the columns of (thin) &lt;code&gt;U&lt;/code&gt; are computed and returned separately. If &lt;code&gt;jobvt = S&lt;/code&gt; the rows of (thin) &lt;code&gt;V'&lt;/code&gt; are computed and returned separately. &lt;code&gt;jobu&lt;/code&gt; and &lt;code&gt;jobvt&lt;/code&gt; can't both be &lt;code&gt;O&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A = U * S * V'&lt;/code&gt; 의 특이 값 분해를 찾습니다 . &lt;code&gt;jobu = A&lt;/code&gt; 인 경우 &lt;code&gt;U&lt;/code&gt; 의 모든 열 이 계산됩니다. &lt;code&gt;jobvt = A&lt;/code&gt; 경우 &lt;code&gt;V'&lt;/code&gt; 의 모든 행 이 계산됩니다. 경우 &lt;code&gt;jobu = N&lt;/code&gt; 의 더 열 &lt;code&gt;U&lt;/code&gt; 는 계산되지 않습니다. &lt;code&gt;jobvt = N&lt;/code&gt; 이면 &lt;code&gt;V'&lt;/code&gt; 행 이 계산 되지 않습니다 . 경우 &lt;code&gt;jobu = O&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 는 (박막)의 열이 덮어 &lt;code&gt;U&lt;/code&gt; . 경우 &lt;code&gt;jobvt = O&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 는 (박막)의 로우로 덮어 &lt;code&gt;V'&lt;/code&gt; . 경우 &lt;code&gt;jobu = S&lt;/code&gt; 의 열 (얇은) &lt;code&gt;U&lt;/code&gt; 는 별도로 계산되고 반환됩니다. 경우 &lt;code&gt;jobvt = S&lt;/code&gt; (박막)의 행 &lt;code&gt;V'&lt;/code&gt; 계산 따로 반환된다. &lt;code&gt;jobu&lt;/code&gt; 및 &lt;code&gt;jobvt&lt;/code&gt; 는 모두 &lt;code&gt;O&lt;/code&gt; 일 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="bfbc35df929a38fee1ee63d2aef508a3752ae6f0" translate="yes" xml:space="preserve">
          <source>Finds the solution to &lt;code&gt;A * X = B&lt;/code&gt; for Hermitian matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, the upper half of &lt;code&gt;A&lt;/code&gt; is stored. If &lt;code&gt;uplo = L&lt;/code&gt;, the lower half is stored. &lt;code&gt;B&lt;/code&gt; is overwritten by the solution &lt;code&gt;X&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten by its Bunch-Kaufman factorization. &lt;code&gt;ipiv&lt;/code&gt; contains pivoting information about the factorization.</source>
          <target state="translated">용액을 찾아 &lt;code&gt;A * X = B&lt;/code&gt; 에르 미트 행렬에 대한 &lt;code&gt;A&lt;/code&gt; . 경우 &lt;code&gt;uplo = U&lt;/code&gt; 의 상반부 &lt;code&gt;A&lt;/code&gt; 는 저장됩니다. 경우 &lt;code&gt;uplo = L&lt;/code&gt; , 하반부가 저장된다. 솔루션 &lt;code&gt;X&lt;/code&gt; 가 &lt;code&gt;B&lt;/code&gt; 를 덮어 씁니다 . Bunch-Kaufman 인수 분해로 &lt;code&gt;A&lt;/code&gt; 를 덮어 씁니다. &lt;code&gt;ipiv&lt;/code&gt; 에는 인수 분해에 대한 피벗 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f1c2e1c20cfe582666286913369ada94f51d8cf" translate="yes" xml:space="preserve">
          <source>Finds the solution to &lt;code&gt;A * X = B&lt;/code&gt; for symmetric matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, the upper half of &lt;code&gt;A&lt;/code&gt; is stored. If &lt;code&gt;uplo = L&lt;/code&gt;, the lower half is stored. &lt;code&gt;B&lt;/code&gt; is overwritten by the solution &lt;code&gt;X&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten by its Bunch-Kaufman factorization. &lt;code&gt;ipiv&lt;/code&gt; contains pivoting information about the factorization.</source>
          <target state="translated">대칭 행렬 &lt;code&gt;A&lt;/code&gt; 에 대한 &lt;code&gt;A * X = B&lt;/code&gt; 대한 해를 찾습니다 . 경우 &lt;code&gt;uplo = U&lt;/code&gt; 의 상반부 &lt;code&gt;A&lt;/code&gt; 는 저장됩니다. 경우 &lt;code&gt;uplo = L&lt;/code&gt; , 하반부가 저장된다. 솔루션 &lt;code&gt;X&lt;/code&gt; 가 &lt;code&gt;B&lt;/code&gt; 를 덮어 씁니다 . Bunch-Kaufman 인수 분해로 &lt;code&gt;A&lt;/code&gt; 를 덮어 씁니다. &lt;code&gt;ipiv&lt;/code&gt; 에는 인수 분해에 대한 피벗 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="05c0a676aeb2122358cb2d2b62a8dc34d0ff96bb" translate="yes" xml:space="preserve">
          <source>Finds the solution to &lt;code&gt;A * X = B&lt;/code&gt; where &lt;code&gt;A&lt;/code&gt; is a symmetric or Hermitian positive definite matrix whose Cholesky decomposition was computed by &lt;code&gt;potrf!&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt; the upper Cholesky decomposition of &lt;code&gt;A&lt;/code&gt; was computed. If &lt;code&gt;uplo = L&lt;/code&gt; the lower Cholesky decomposition of &lt;code&gt;A&lt;/code&gt; was computed. &lt;code&gt;B&lt;/code&gt; is overwritten with the solution &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">찾아에 용액 &lt;code&gt;A * X = B&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; 촐레 스키 분해에 의해 계산 된 대칭 또는 에르 미트 정부 호 행렬이다 &lt;code&gt;potrf!&lt;/code&gt; . 경우 &lt;code&gt;uplo = U&lt;/code&gt; 상단 콜레 분해 &lt;code&gt;A&lt;/code&gt; 는 계산했다. 경우 &lt;code&gt;uplo = L&lt;/code&gt; 하부 촐레 스키 분해 &lt;code&gt;A&lt;/code&gt; 를 산출 하였다. 솔루션 &lt;code&gt;X&lt;/code&gt; 로 &lt;code&gt;B&lt;/code&gt; 를 덮어 씁니다 .</target>
        </trans-unit>
        <trans-unit id="e99b5edae4a2dc1678284239ea67a37fe1921376" translate="yes" xml:space="preserve">
          <source>Finds the solution to &lt;code&gt;A * X = B&lt;/code&gt; where &lt;code&gt;A&lt;/code&gt; is a symmetric or Hermitian positive definite matrix. If &lt;code&gt;uplo = U&lt;/code&gt; the upper Cholesky decomposition of &lt;code&gt;A&lt;/code&gt; is computed. If &lt;code&gt;uplo = L&lt;/code&gt; the lower Cholesky decomposition of &lt;code&gt;A&lt;/code&gt; is computed. &lt;code&gt;A&lt;/code&gt; is overwritten by its Cholesky decomposition. &lt;code&gt;B&lt;/code&gt; is overwritten with the solution &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A * X = B&lt;/code&gt; 대한 해를 구합니다. 여기서 &lt;code&gt;A&lt;/code&gt; 는 대칭 또는 Hermitian 양의 한정 행렬입니다. &lt;code&gt;uplo = U&lt;/code&gt; 경우 &lt;code&gt;A&lt;/code&gt; 의 C 레 스키 상층 분해 가 계산됩니다. 경우 &lt;code&gt;uplo = L&lt;/code&gt; 하부 촐레 스키 분해 &lt;code&gt;A&lt;/code&gt; 를 산출한다. Cholesky 분해로 &lt;code&gt;A&lt;/code&gt; 를 덮어 씁니다. 솔루션 &lt;code&gt;X&lt;/code&gt; 로 &lt;code&gt;B&lt;/code&gt; 를 덮어 씁니다 .</target>
        </trans-unit>
        <trans-unit id="8e7e713430f9bcb8fd60110d1ddaba473fe37beb" translate="yes" xml:space="preserve">
          <source>Finished with an uncaught exception</source>
          <target state="translated">잡히지 않은 예외로 마무리</target>
        </trans-unit>
        <trans-unit id="d4f94f922955d9b99f89834068cd98fd1aba023b" translate="yes" xml:space="preserve">
          <source>Finite Part Integral</source>
          <target state="translated">유한 부품 일체</target>
        </trans-unit>
        <trans-unit id="e5b076c42526fba51c6923d8682dc75c64aa4bcd" translate="yes" xml:space="preserve">
          <source>Finite difference operator on a vector or a multidimensional array &lt;code&gt;A&lt;/code&gt;. In the latter case the dimension to operate on needs to be specified with the &lt;code&gt;dims&lt;/code&gt; keyword argument.</source>
          <target state="translated">벡터 또는 다차원 어레이에 대한 유한 차분 연산자 . 후자의 경우 작동 할 차원은 &lt;code&gt;dims&lt;/code&gt; 키워드 인수 로 지정해야합니다 . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7a4557ec58940c5eada2fe857ddb8888c78004d3" translate="yes" xml:space="preserve">
          <source>Finite numbers are ordered in the usual manner.</source>
          <target state="translated">유한 번호는 일반적인 방식으로 주문됩니다.</target>
        </trans-unit>
        <trans-unit id="78baebfcb4b52665d7e8a9c7826c47b0fa2439f6" translate="yes" xml:space="preserve">
          <source>Fire</source>
          <target state="translated">Fire</target>
        </trans-unit>
        <trans-unit id="ccb3bd276e9391502d5858c0ee82ed61db7ec7a7" translate="yes" xml:space="preserve">
          <source>Fire Engine</source>
          <target state="translated">소방차</target>
        </trans-unit>
        <trans-unit id="c38b663a951f35db127c178e977a734a5f954d31" translate="yes" xml:space="preserve">
          <source>Firework Sparkler</source>
          <target state="translated">불꽃 향</target>
        </trans-unit>
        <trans-unit id="4f8ff80cb6112a8df5a0ae17110f841b4709fc4a" translate="yes" xml:space="preserve">
          <source>Fireworks</source>
          <target state="translated">Fireworks</target>
        </trans-unit>
        <trans-unit id="0b7bdf63087ea834463f7869ee05ee0f78b2039d" translate="yes" xml:space="preserve">
          <source>First Quarter Moon</source>
          <target state="translated">1 분기 문</target>
        </trans-unit>
        <trans-unit id="8d23a610d2c1a9be816138d8135fd6968e488141" translate="yes" xml:space="preserve">
          <source>First Quarter Moon Symbol</source>
          <target state="translated">1 분기 문 기호</target>
        </trans-unit>
        <trans-unit id="74fa6c1e17a3a3252deb8af7194e87d8d33fbc11" translate="yes" xml:space="preserve">
          <source>First Quarter Moon With Face</source>
          <target state="translated">얼굴이있는 1 분기 문</target>
        </trans-unit>
        <trans-unit id="f1738c1a48a67517ee40f4407fe85d205603ee0a" translate="yes" xml:space="preserve">
          <source>First, a review of some relevant Julia type terminology:</source>
          <target state="translated">먼저 관련된 Julia 유형 용어를 검토합니다.</target>
        </trans-unit>
        <trans-unit id="7cea893d2a53ebb1e9b3f78ee61f550c12f76b89" translate="yes" xml:space="preserve">
          <source>First, triple-quoted strings are also dedented to the level of the least-indented line. This is useful for defining strings within code that is indented. For example:</source>
          <target state="translated">먼저, 삼중 따옴표로 묶인 문자열도 가장 들여 쓰기가 적은 줄 수준으로 표시됩니다. 들여 쓰기되는 코드 내에서 문자열을 정의 할 때 유용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f0d11adabc82edc0523feb5883cbbd9e9d59c1cd" translate="yes" xml:space="preserve">
          <source>First, with &lt;code&gt;ntasks&lt;/code&gt; undefined, each element is processed in a different task.</source>
          <target state="translated">먼저, &lt;code&gt;ntasks&lt;/code&gt; 가 정의되어 있지 않으면 각 요소가 다른 작업에서 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="3030e8ec7633ec1a524bb246aee7dbda6fb3e4bc" translate="yes" xml:space="preserve">
          <source>Fish</source>
          <target state="translated">Fish</target>
        </trans-unit>
        <trans-unit id="08ef4d73924ae1ff99ef9760dad3a8b35cdbc717" translate="yes" xml:space="preserve">
          <source>Fish Cake With Swirl Design</source>
          <target state="translated">소용돌이 모양의 생선 케이크</target>
        </trans-unit>
        <trans-unit id="6af9685850189240cc327402ef6a117b0925f447" translate="yes" xml:space="preserve">
          <source>Fisheye</source>
          <target state="translated">Fisheye</target>
        </trans-unit>
        <trans-unit id="217458563b479c9b5e1aa24b33b36b9c5286dff5" translate="yes" xml:space="preserve">
          <source>Fishing Pole And Fish</source>
          <target state="translated">낚싯대와 물고기</target>
        </trans-unit>
        <trans-unit id="ec1091759eb5098c1ce15fb7122c53128cb7e317" translate="yes" xml:space="preserve">
          <source>Fisted Hand Sign</source>
          <target state="translated">주먹 손 기호</target>
        </trans-unit>
        <trans-unit id="ee4d04bcaeb407d6978ec547023834d74dc08028" translate="yes" xml:space="preserve">
          <source>Fix deprecation warnings</source>
          <target state="translated">지원 중단 경고 수정</target>
        </trans-unit>
        <trans-unit id="f057e4dd9329dfaa6b558f5251558c8bd7042ccf" translate="yes" xml:space="preserve">
          <source>Fixed-width slots are specified by repeating the period character the number of times corresponding to the width with no delimiter between characters. So &lt;code&gt;&quot;yyyymmdd&quot;&lt;/code&gt; would correspond to a date string like &lt;code&gt;&quot;20140716&quot;&lt;/code&gt;. The parser distinguishes a fixed-width slot by the absence of a delimiter, noting the transition &lt;code&gt;&quot;yyyymm&quot;&lt;/code&gt; from one period character to the next.</source>
          <target state="translated">고정 폭 슬롯은 문자 사이에 구분자가없는 폭에 해당하는 횟수만큼 마침표 문자를 반복하여 지정됩니다. 따라서 &lt;code&gt;&quot;yyyymmdd&quot;&lt;/code&gt; 는 &lt;code&gt;&quot;20140716&quot;&lt;/code&gt; 과 같은 날짜 문자열에 해당합니다 . 구문 분석기는 구분 문자가 없어 고정 너비 슬롯을 구분 하여 한 문자에서 다음 문자로의 &lt;code&gt;&quot;yyyymm&quot;&lt;/code&gt; 전환 을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5695ea14bfec9e6b7d86faa5e86d6e6aa911f902" translate="yes" xml:space="preserve">
          <source>Flag In Hole</source>
          <target state="translated">구멍에 깃발</target>
        </trans-unit>
        <trans-unit id="58270b038657eb33ab9c272d4b0b663caf6f505b" translate="yes" xml:space="preserve">
          <source>Flatness</source>
          <target state="translated">Flatness</target>
        </trans-unit>
        <trans-unit id="157a69122ac7ee154e0f87d80f294a117ce27465" translate="yes" xml:space="preserve">
          <source>Flexed Biceps</source>
          <target state="translated">굽은 이두근</target>
        </trans-unit>
        <trans-unit id="ee9ce77c4431cac02ee809f2bf8b3362c097e451" translate="yes" xml:space="preserve">
          <source>Flip the bits of &lt;code&gt;val&lt;/code&gt; indexed by &lt;code&gt;flag&lt;/code&gt;, so that if a bit is &lt;code&gt;0&lt;/code&gt; it will be &lt;code&gt;1&lt;/code&gt; after the toggle, and vice-versa.</source>
          <target state="translated">비트 플립의 &lt;code&gt;val&lt;/code&gt; 에 의해 인덱싱 &lt;code&gt;flag&lt;/code&gt; 비트 인 경우 그래서, &lt;code&gt;0&lt;/code&gt; 이 될 것 &lt;code&gt;1&lt;/code&gt; , 토글 후에, 그 반대.</target>
        </trans-unit>
        <trans-unit id="444518fe06999c30d999423013ab4f1c5d158646" translate="yes" xml:space="preserve">
          <source>Floating-Point Numbers</source>
          <target state="translated">부동 소수점 숫자</target>
        </trans-unit>
        <trans-unit id="50eee28c25d79612d8553be7d7bd2846378f99a9" translate="yes" xml:space="preserve">
          <source>Floating-point arithmetic entails many subtleties which can be surprising to users who are unfamiliar with the low-level implementation details. However, these subtleties are described in detail in most books on scientific computation, and also in the following references:</source>
          <target state="translated">부동 소수점 산술에는 낮은 수준의 구현 세부 사항에 익숙하지 않은 사용자에게는 놀라 울 수있는 많은 미묘함이 수반됩니다. 그러나 이러한 미묘한 점은 과학 계산에 관한 대부분의 책과 다음 참고 자료에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa83ec82b434276bb3bfc0811f157d35a5e75cfc" translate="yes" xml:space="preserve">
          <source>Floating-point numbers have &lt;a href=&quot;https://en.wikipedia.org/wiki/Signed_zero&quot;&gt;two zeros&lt;/a&gt;, positive zero and negative zero. They are equal to each other but have different binary representations, as can be seen using the &lt;a href=&quot;../../base/numbers/index#Base.bitstring&quot;&gt;&lt;code&gt;bitstring&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">부동 소수점 숫자에는 양수 0과 음수 0의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Signed_zero&quot;&gt;두 개의 0&lt;/a&gt; 이 있습니다. &lt;a href=&quot;../../base/numbers/index#Base.bitstring&quot;&gt; &lt;code&gt;bitstring&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 볼 수 있듯이 서로 같지만 이진 표현이 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="3fba63653b996ccaa92264b381e4cee8797797a5" translate="yes" xml:space="preserve">
          <source>Floating-point operations on reduction variables can be reordered, possibly causing different results than without &lt;code&gt;@simd&lt;/code&gt;.</source>
          <target state="translated">감소 변수에 대한 부동 소수점 연산은 재정렬되어 &lt;code&gt;@simd&lt;/code&gt; 없이 다른 결과가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5043ab32eb0ec94e147a66ceca999e1ecfae56b6" translate="yes" xml:space="preserve">
          <source>Floating-point values are promoted to the largest of the floating-point argument types. Integer values are promoted to the larger of either the native machine word size or the largest integer argument type. Mixtures of integers and floating-point values are promoted to a floating-point type big enough to hold all the values. Integers mixed with rationals are promoted to rationals. Rationals mixed with floats are promoted to floats. Complex values mixed with real values are promoted to the appropriate kind of complex value.</source>
          <target state="translated">부동 소수점 값은 가장 큰 부동 소수점 인수 유형으로 승격됩니다. 정수 값은 기본 기계어 크기 또는 가장 큰 정수 인수 유형 중 하나로 크게 승격됩니다. 정수와 부동 소수점 값의 혼합은 모든 값을 보유하기에 충분히 큰 부동 소수점 유형으로 승격됩니다. 유리수와 혼합 된 정수는 유리수로 승격됩니다. 부유물과 혼합 된 합리성은 부유물로 승격됩니다. 실수 값과 혼합 된 복소수 값은 적절한 종류의 복소수 값으로 승격됩니다.</target>
        </trans-unit>
        <trans-unit id="cebba3f2674f659c3ac76a05e885a881a3fcce6d" translate="yes" xml:space="preserve">
          <source>Floating-point zero</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d43047ffbb02b9960d1076b1d1bb9cdef48764e1" translate="yes" xml:space="preserve">
          <source>Flooring division, returning a value consistent with &lt;code&gt;mod1(x,y)&lt;/code&gt;</source>
          <target state="translated">바닥 분할, &lt;code&gt;mod1(x,y)&lt;/code&gt; 와 일치하는 값 반환</target>
        </trans-unit>
        <trans-unit id="0cb23ae2c189b13f5f90d739cf453c252387dc2d" translate="yes" xml:space="preserve">
          <source>Floppy Disk</source>
          <target state="translated">플로피 디스크</target>
        </trans-unit>
        <trans-unit id="00d43012b0d3d0a7fff1c3e0edf1cbd87e191788" translate="yes" xml:space="preserve">
          <source>Flower Playing Cards</source>
          <target state="translated">꽃 놀이 카드</target>
        </trans-unit>
        <trans-unit id="3b70164ceac5ab45d8a49385e479599c3b2028ee" translate="yes" xml:space="preserve">
          <source>Flushed Face</source>
          <target state="translated">플러시 얼굴</target>
        </trans-unit>
        <trans-unit id="c095ff38e8ffaf6ceac6c9df64aa62e9da573536" translate="yes" xml:space="preserve">
          <source>Flushes the C &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; streams (which may have been written to by external C code).</source>
          <target state="translated">C &lt;code&gt;stdout&lt;/code&gt; 및 &lt;code&gt;stderr&lt;/code&gt; 스트림을 플러시합니다 (외부 C 코드로 작성되었을 수 있음).</target>
        </trans-unit>
        <trans-unit id="88957d8137dbc8ecadcade0adeacd0f2a5ab4356" translate="yes" xml:space="preserve">
          <source>Foggy</source>
          <target state="translated">Foggy</target>
        </trans-unit>
        <trans-unit id="c789741f990351befd624144e4fbf31c533b3a78" translate="yes" xml:space="preserve">
          <source>Following the outer constructor definitions, we defined a number of methods for the &lt;code&gt;⊘&lt;/code&gt; operator, which provides a syntax for writing rationals (e.g. &lt;code&gt;1 ⊘ 2&lt;/code&gt;). Julia's &lt;code&gt;Rational&lt;/code&gt; type uses the &lt;a href=&quot;../../base/math/index#Base.://&quot;&gt;&lt;code&gt;//&lt;/code&gt;&lt;/a&gt; operator for this purpose. Before these definitions, &lt;code&gt;⊘&lt;/code&gt; is a completely undefined operator with only syntax and no meaning. Afterwards, it behaves just as described in &lt;a href=&quot;../complex-and-rational-numbers/index#Rational-Numbers-1&quot;&gt;Rational Numbers&lt;/a&gt; &amp;ndash; its entire behavior is defined in these few lines. The first and most basic definition just makes &lt;code&gt;a ⊘ b&lt;/code&gt; construct a &lt;code&gt;OurRational&lt;/code&gt; by applying the &lt;code&gt;OurRational&lt;/code&gt; constructor to &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; when they are integers. When one of the operands of &lt;code&gt;⊘&lt;/code&gt; is already a rational number, we construct a new rational for the resulting ratio slightly differently; this behavior is actually identical to division of a rational with an integer. Finally, applying &lt;code&gt;⊘&lt;/code&gt; to complex integral values creates an instance of &lt;code&gt;Complex{OurRational}&lt;/code&gt; &amp;ndash; a complex number whose real and imaginary parts are rationals:</source>
          <target state="translated">외부 생성자 정의에 따라, 우리는 &lt;code&gt;⊘&lt;/code&gt; 연산자에 대한 여러 가지 방법을 정의했으며 ,이 연산자는 유리수를 작성하기위한 구문을 제공합니다 (예 : &lt;code&gt;1 ⊘ 2&lt;/code&gt; ). Julia의 &lt;code&gt;Rational&lt;/code&gt; 유형은 이 목적으로 &lt;a href=&quot;../../base/math/index#Base.://&quot;&gt; &lt;code&gt;//&lt;/code&gt; &lt;/a&gt; 연산자를 사용합니다 . 이러한 정의 이전에 &lt;code&gt;⊘&lt;/code&gt; 는 구문 만 있고 의미가없는 완전히 정의되지 않은 연산자입니다. 그 후에는 &lt;a href=&quot;../complex-and-rational-numbers/index#Rational-Numbers-1&quot;&gt;Rational Numbers에&lt;/a&gt; 설명 된대로 작동 합니다. 전체 동작은이 몇 줄에 정의되어 있습니다. 제 가장 기본적인 정의가 단지 수 &lt;code&gt;a ⊘ b&lt;/code&gt; 구조체 &lt;code&gt;OurRational&lt;/code&gt; 을 인가하여 &lt;code&gt;OurRational&lt;/code&gt; 로 생성자 및 &lt;code&gt;b&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; 그들이 정수일 때. &lt;code&gt;⊘&lt;/code&gt; 의 피연산자 중 하나 가 이미 유리수 인 경우 결과 비율에 대해 약간 다른 새 유리수를 구성합니다. 이 동작은 실제로 유리수를 정수로 나누는 것과 동일합니다. 마지막으로,인가 &lt;code&gt;⊘&lt;/code&gt; 복소 적분 값은 인스턴스 생성 &lt;code&gt;Complex{OurRational}&lt;/code&gt; - 그 실수 부 및 허수 부 유리수되는 복소수 :</target>
        </trans-unit>
        <trans-unit id="1e77a8685e1b18b030132d7235106a58bff9d77d" translate="yes" xml:space="preserve">
          <source>Footnote references</source>
          <target state="translated">각주 참조</target>
        </trans-unit>
        <trans-unit id="9d738544b84d3e6ca69948f1d45fc336d259c385" translate="yes" xml:space="preserve">
          <source>Footnote text is defined using the following syntax, which is similar to footnote reference syntax, aside from the &lt;code&gt;:&lt;/code&gt; character that is appended to the footnote label.</source>
          <target state="translated">각주 텍스트는 각주 레이블에 추가 된 &lt;code&gt;:&lt;/code&gt; 문자를 제외하고 각주 참조 구문과 유사한 다음 구문을 사용하여 정의 됩니다.</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="6f17ee469db4ec0c0c7e81b41c2cbcf9f902b3cc" translate="yes" xml:space="preserve">
          <source>Footprints</source>
          <target state="translated">Footprints</target>
        </trans-unit>
        <trans-unit id="ae9f4e9dfa0443b0ceae859867c4f509f5a9474e" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; objects this can be done either directly or by use of a convenience macro:</source>
          <target state="translated">들어 &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 이 직접 중 하나를 수행하거나 편의 매크로를 사용하여 할 수있는 개체 :</target>
        </trans-unit>
        <trans-unit id="b1492f65d2da61bde614e2df1030321603972a60" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;../numbers/index#Core.Unsigned&quot;&gt;&lt;code&gt;Unsigned&lt;/code&gt;&lt;/a&gt; integer types, this is equivalent to &lt;a href=&quot;#Base.:&amp;gt;&amp;gt;&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt;. For &lt;a href=&quot;../numbers/index#Core.Signed&quot;&gt;&lt;code&gt;Signed&lt;/code&gt;&lt;/a&gt; integer types, this is equivalent to &lt;code&gt;signed(unsigned(x) &amp;gt;&amp;gt; n)&lt;/code&gt;.</source>
          <target state="translated">들어 &lt;a href=&quot;../numbers/index#Core.Unsigned&quot;&gt; &lt;code&gt;Unsigned&lt;/code&gt; &lt;/a&gt; 정수 유형이 동일하다 &lt;a href=&quot;#Base.:&amp;gt;&amp;gt;&quot;&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt; . 들면 &lt;a href=&quot;../numbers/index#Core.Signed&quot;&gt; &lt;code&gt;Signed&lt;/code&gt; &lt;/a&gt; 유형 정수이 동등 &lt;code&gt;signed(unsigned(x) &amp;gt;&amp;gt; n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a40737843ce84d120d446cac7c60f6d3a180523" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;AbstractArray&lt;/code&gt; types that support arbitrary dimensionality, &lt;code&gt;N&lt;/code&gt; can be set to &lt;code&gt;Any&lt;/code&gt;:</source>
          <target state="translated">들어 &lt;code&gt;AbstractArray&lt;/code&gt; 의 임의의 차원을 지원하는 유형, &lt;code&gt;N&lt;/code&gt; 은 설정할 수 있습니다 &lt;code&gt;Any&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="78cc0c00798ab494e86cd193ffb9a72a0848fb41" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;AbstractArray&lt;/code&gt; types, defining a &lt;code&gt;BroadcastStyle&lt;/code&gt; supersedes the fallback choice, &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.DefaultArrayStyle&quot;&gt;&lt;code&gt;Broadcast.DefaultArrayStyle&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;DefaultArrayStyle&lt;/code&gt; and the abstract supertype, &lt;code&gt;AbstractArrayStyle&lt;/code&gt;, store the dimensionality as a type parameter to support specialized array types that have fixed dimensionality requirements.</source>
          <target state="translated">들어 &lt;code&gt;AbstractArray&lt;/code&gt; 의 종류, 결정적인 &lt;code&gt;BroadcastStyle&lt;/code&gt; 것은 , 대체 선택을 대체 &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.DefaultArrayStyle&quot;&gt; &lt;code&gt;Broadcast.DefaultArrayStyle&lt;/code&gt; 을&lt;/a&gt; . &lt;code&gt;DefaultArrayStyle&lt;/code&gt; 및 추상 수퍼 타입 ​​인 &lt;code&gt;AbstractArrayStyle&lt;/code&gt; 은 차원을 유형 매개 변수로 저장하여 고정 차원 요구 사항이있는 특수한 배열 유형을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="0c614db39e8f0ca718810e31731f59d181271482" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;AbstractArrays&lt;/code&gt; that only support a certain dimensionality, create a subtype of &lt;code&gt;Broadcast.AbstractArrayStyle{N}&lt;/code&gt; (see below).</source>
          <target state="translated">들면 &lt;code&gt;AbstractArrays&lt;/code&gt; 만 소정 차원을 지원하는 아형 생성 &lt;code&gt;Broadcast.AbstractArrayStyle{N}&lt;/code&gt; (아래 참조).</target>
        </trans-unit>
        <trans-unit id="36e4edbd82274075aaa50a1a6642d0776aa14705" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;MySimpleContainer&lt;/code&gt;, the object is fully-specified by its type and parameters, so the compiler can generate optimized functions. In most instances, this will probably suffice.</source>
          <target state="translated">들어 &lt;code&gt;MySimpleContainer&lt;/code&gt; 컴파일러가 최적화 된 기능을 생성 할 수 있도록 객체는 그 유형과 매개 변수에 의해 완전히 지정됩니다. 대부분의 경우이 정도면 충분할 것입니다.</target>
        </trans-unit>
        <trans-unit id="066f4790c89fa96385b602165d512d492e66ecc6" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;wchar_t*&lt;/code&gt; arguments, the Julia type should be &lt;a href=&quot;../../base/c/index#Base.Cwstring&quot;&gt;&lt;code&gt;Cwstring&lt;/code&gt;&lt;/a&gt; (if the C routine expects a NUL-terminated string) or &lt;code&gt;Ptr{Cwchar_t}&lt;/code&gt; otherwise. Note also that UTF-8 string data in Julia is internally NUL-terminated, so it can be passed to C functions expecting NUL-terminated data without making a copy (but using the &lt;code&gt;Cwstring&lt;/code&gt; type will cause an error to be thrown if the string itself contains NUL characters).</source>
          <target state="translated">들어 &lt;code&gt;wchar_t*&lt;/code&gt; 인수, 줄리아 유형은해야 &lt;a href=&quot;../../base/c/index#Base.Cwstring&quot;&gt; &lt;code&gt;Cwstring&lt;/code&gt; &lt;/a&gt; 합니다 (C 루틴이 NUL 종료 문자열을 기대 경우) &lt;code&gt;Ptr{Cwchar_t}&lt;/code&gt; 이 없습니다. Julia의 UTF-8 문자열 데이터는 내부적으로 NUL로 끝나므로 복사하지 않고 NUL로 끝나는 데이터를 기대하는 C 함수에 전달할 수 있습니다 (그러나 &lt;code&gt;Cwstring&lt;/code&gt; 유형을 사용 하면 문자열 자체가 있으면 오류가 발생합니다) NUL 문자를 포함합니다).</target>
        </trans-unit>
        <trans-unit id="b8d4350a3633a902604161c6b5b29254014e76bb" translate="yes" xml:space="preserve">
          <source>For &lt;em&gt;every&lt;/em&gt; binary operation like &lt;code&gt;^&lt;/code&gt;, there is a corresponding &quot;dot&quot; operation &lt;code&gt;.^&lt;/code&gt; that is &lt;em&gt;automatically&lt;/em&gt; defined to perform &lt;code&gt;^&lt;/code&gt; element-by-element on arrays. For example, &lt;code&gt;[1,2,3] ^ 3&lt;/code&gt; is not defined, since there is no standard mathematical meaning to &quot;cubing&quot; a (non-square) array, but &lt;code&gt;[1,2,3] .^ 3&lt;/code&gt; is defined as computing the elementwise (or &quot;vectorized&quot;) result &lt;code&gt;[1^3, 2^3, 3^3]&lt;/code&gt;. Similarly for unary operators like &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;&amp;radic;&lt;/code&gt;, there is a corresponding &lt;code&gt;.&amp;radic;&lt;/code&gt; that applies the operator elementwise.</source>
          <target state="translated">내용 &lt;em&gt;마다&lt;/em&gt; 같은 이진 연산 &lt;code&gt;^&lt;/code&gt; , 대응하는 동작을 &quot;실&quot;이있다 &lt;code&gt;.^&lt;/code&gt; 되는 &lt;em&gt;자동&lt;/em&gt; 수행 정의 &lt;code&gt;^&lt;/code&gt; 원소 별 어레이에. 예를 들어, &lt;code&gt;[1,2,3] ^ 3&lt;/code&gt; 이 &quot;큐빙의&quot;(비 사각형) 배열 표준 수학적 의미는 없지만, 이후 정의되지 &lt;code&gt;[1,2,3] .^ 3&lt;/code&gt; 연산으로 정의된다 요소 별 (또는 &quot;벡터화 된&quot;) 결과 &lt;code&gt;[1^3, 2^3, 3^3]&lt;/code&gt; . &lt;code&gt;!&lt;/code&gt; 와 같은 단항 연산자의 경우와 유사합니다 . 또는 &lt;code&gt;&amp;radic;&lt;/code&gt; , 연산자를 요소별로 적용 하는 해당 &lt;code&gt;.&amp;radic;&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="33b12b0497bd71670a617ce62626d84d142b3953" translate="yes" xml:space="preserve">
          <source>For Adjoint/Transpose-wrapped vectors, return the operator $q$-norm of &lt;code&gt;A&lt;/code&gt;, which is equivalent to the &lt;code&gt;p&lt;/code&gt;-norm with value &lt;code&gt;p = q/(q-1)&lt;/code&gt;. They coincide at &lt;code&gt;p = q = 2&lt;/code&gt;. Use &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt;&lt;code&gt;norm&lt;/code&gt;&lt;/a&gt; to compute the &lt;code&gt;p&lt;/code&gt; norm of &lt;code&gt;A&lt;/code&gt; as a vector.</source>
          <target state="translated">Adjoint / Transpose-wrapped 벡터의 경우 &lt;code&gt;A&lt;/code&gt; 의 $ q $ -norm 연산자를 반환합니다 . 이는 &lt;code&gt;p = q/(q-1)&lt;/code&gt; 값을 가진 &lt;code&gt;p&lt;/code&gt; - norm과 같습니다 . &lt;code&gt;p = q = 2&lt;/code&gt; 에서 일치 합니다. 사용 &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt; &lt;code&gt;norm&lt;/code&gt; &lt;/a&gt; 컴퓨팅하는 &lt;code&gt;p&lt;/code&gt; 의 규범 &lt;code&gt;A&lt;/code&gt; 벡터로.</target>
        </trans-unit>
        <trans-unit id="7cce7fbd5f6d7a391c27939f48d9689b1cad7e94" translate="yes" xml:space="preserve">
          <source>For All</source>
          <target state="translated">모든</target>
        </trans-unit>
        <trans-unit id="bc4c87ed1d5890c7a24dd4de829654130f87033e" translate="yes" xml:space="preserve">
          <source>For Fortran functions taking variable length strings of type &lt;code&gt;character(len=*)&lt;/code&gt; the string lengths are provided as &lt;em&gt;hidden arguments&lt;/em&gt;. Type and position of these arguments in the list are compiler specific, where compiler vendors usually default to using &lt;code&gt;Csize_t&lt;/code&gt; as type and append the hidden arguments at the end of the argument list. While this behaviour is fixed for some compilers (GNU), others &lt;em&gt;optionally&lt;/em&gt; permit placing hidden arguments directly after the character argument (Intel,PGI). For example, Fortran subroutines of the form</source>
          <target state="translated">&lt;code&gt;character(len=*)&lt;/code&gt; 유형의 가변 길이 문자열을 사용하는 포트란 함수의 경우 문자열 길이는 &lt;em&gt;숨겨진 인수&lt;/em&gt; 로 제공됩니다 . 목록에서 이러한 인수의 유형과 위치는 컴파일러마다 다릅니다. 컴파일러 공급 업체는 기본적으로 &lt;code&gt;Csize_t&lt;/code&gt; 를 유형 으로 사용 하고 인수 목록의 끝에 숨겨진 인수를 추가합니다. 이 동작은 일부 컴파일러 (GNU)에 대해 고정되어 있지만 다른 인수는 &lt;em&gt;선택적으로&lt;/em&gt; 문자 인수 (Intel, PGI) 바로 뒤에 숨겨진 인수를 배치 할 수 있습니다. 예를 들어, 형식의 포트란 서브 루틴</target>
        </trans-unit>
        <trans-unit id="d553b36129c90b85dcd46c9add276340b10d3409" translate="yes" xml:space="preserve">
          <source>For Loops and Comprehensions</source>
          <target state="translated">루프와 이해를 위해</target>
        </trans-unit>
        <trans-unit id="16f78eccb3fe706727ad782465619222ec9fd8a5" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;String&lt;/code&gt;, note that the result is specific to the UTF-8 encoding (a different checksum would be obtained from a different Unicode encoding). To checksum an &lt;code&gt;a::Array&lt;/code&gt; of some other bitstype, you can do &lt;code&gt;crc32c(reinterpret(UInt8,a))&lt;/code&gt;, but note that the result may be endian-dependent.</source>
          <target state="translated">A에 대한 &lt;code&gt;String&lt;/code&gt; 결과는 UTF-8 인코딩에 특정 참고 (다른 체크섬 다른 유니 인코딩에 의한 것이다). 다른 비트 유형 의 &lt;code&gt;a::Array&lt;/code&gt; 를 체크섬하려면 &lt;code&gt;crc32c(reinterpret(UInt8,a))&lt;/code&gt; 수행 할 수 있지만 결과는 엔디안 종속적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdbd68155fa3d6b046d9d04578affc99d85e662a" translate="yes" xml:space="preserve">
          <source>For a brief but lucid presentation of how floating-point numbers are represented, see John D. Cook's &lt;a href=&quot;https://www.johndcook.com/blog/2009/04/06/anatomy-of-a-floating-point-number/&quot;&gt;article&lt;/a&gt; on the subject as well as his &lt;a href=&quot;https://www.johndcook.com/blog/2009/04/06/numbers-are-a-leaky-abstraction/&quot;&gt;introduction&lt;/a&gt; to some of the issues arising from how this representation differs in behavior from the idealized abstraction of real numbers.</source>
          <target state="translated">부동 소수점 숫자를 표현하는 방법에 대한 간단하지만 자명 한 설명을 보려면 John D. Cook의 주제에 대한 &lt;a href=&quot;https://www.johndcook.com/blog/2009/04/06/anatomy-of-a-floating-point-number/&quot;&gt;기사&lt;/a&gt; 와이 표현이 동작에서 이상적인 실제 숫자 추상화와 어떻게 다른지에 따라 발생하는 일부 문제에 대한 &lt;a href=&quot;https://www.johndcook.com/blog/2009/04/06/numbers-are-a-leaky-abstraction/&quot;&gt;소개&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="26d026061b818471461b6e11cb1c3175bde48284" translate="yes" xml:space="preserve">
          <source>For a complete example, let's say you have created a type, &lt;code&gt;ArrayAndChar&lt;/code&gt;, that stores an array and a single character:</source>
          <target state="translated">완전한 예를 들어, 배열과 단일 문자를 저장하는 &lt;code&gt;ArrayAndChar&lt;/code&gt; 유형을 작성했다고 가정 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="125644f126fbc4277c5149f11a90f626bb48ac54" translate="yes" xml:space="preserve">
          <source>For a complete list of &lt;em&gt;every&lt;/em&gt; Julia operator's precedence, see the top of this file: &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm&quot;&gt;&lt;code&gt;src/julia-parser.scm&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;모든&lt;/em&gt; Julia 운영자의 우선 순위에 대한 전체 목록은 이 파일의 상단을 참조하십시오. &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm&quot;&gt; &lt;code&gt;src/julia-parser.scm&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6f4d0c1cef2d73378f1ab6ea21dcd2e3aa81e9b0" translate="yes" xml:space="preserve">
          <source>For a given period, return the value associated with that period. For example, &lt;code&gt;value(Millisecond(10))&lt;/code&gt; returns 10 as an integer.</source>
          <target state="translated">주어진 기간 동안 해당 기간과 관련된 값을 반환합니다. 예를 들어 &lt;code&gt;value(Millisecond(10))&lt;/code&gt; 는 10을 정수로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="88ab5fbb77be1d46e4a2df54b426186afb121ac6" translate="yes" xml:space="preserve">
          <source>For a more general way to make all such calls work sensibly, see &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversion and Promotion&lt;/a&gt;. At the risk of spoiling the suspense, we can reveal here that all it takes is the following outer method definition to make all calls to the general &lt;code&gt;Point&lt;/code&gt; constructor work as one would expect:</source>
          <target state="translated">이러한 모든 통화를 현명하게 작동시키는보다 일반적인 방법은 &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;전환 및 프로모션을&lt;/a&gt; 참조하십시오 . 서스펜스를 망칠 위험이 있으므로 여기서는 일반적인 &lt;code&gt;Point&lt;/code&gt; 생성자 에 대한 모든 호출을 예상대로 수행 하기 위해 다음과 같은 외부 메소드 정의 만 수행하면됩니다.</target>
        </trans-unit>
        <trans-unit id="ed852a3125d50800bb13a676272e7f42d0c371f3" translate="yes" xml:space="preserve">
          <source>For a more specific example, a generic square-matrix multiply pseudo-code might look like:</source>
          <target state="translated">보다 구체적인 예를 들어, 일반적인 제곱 행렬 곱셈 의사 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b96550022e1c9fcddbfb08ee86d23ebf98de982" translate="yes" xml:space="preserve">
          <source>For a scalar input, &lt;code&gt;eigvals&lt;/code&gt; will return a scalar.</source>
          <target state="translated">스칼라 입력의 경우 &lt;code&gt;eigvals&lt;/code&gt; 는 스칼라를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6e10df5562967eabafd887233bdf313820cd17e4" translate="yes" xml:space="preserve">
          <source>For addition details see the LibGit2 guide on &lt;a href=&quot;https://libgit2.org/docs/guides/authentication/&quot;&gt;authenticating against a server&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://libgit2.org/docs/guides/authentication/&quot;&gt;서버 인증에 대한&lt;/a&gt; LibGit2 안내서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f08193acb8e4821221019bdf43b59fe564f1010" translate="yes" xml:space="preserve">
          <source>For additional (algorithmic) information, and for versions of these methods that forgo argument checking, see (unexported) parent methods &lt;code&gt;unchecked_noalias_permute!&lt;/code&gt; and &lt;code&gt;unchecked_aliasing_permute!&lt;/code&gt;.</source>
          <target state="translated">추가 (알고리즘) 정보 및 인수 확인을 포기하는 이러한 메소드의 버전에 대해서는 unexported_noalias_permute &lt;code&gt;unchecked_noalias_permute!&lt;/code&gt; 그리고 &lt;code&gt;unchecked_aliasing_permute!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42ec6c27994a098a5b5c8be91c0dfca1418b0092" translate="yes" xml:space="preserve">
          <source>For additional documentation and an expert driver, see &lt;code&gt;SparseArrays.sparse!&lt;/code&gt;.</source>
          <target state="translated">추가 설명서 및 전문가 드라이버는 &lt;code&gt;SparseArrays.sparse!&lt;/code&gt; 참조하십시오 ! .</target>
        </trans-unit>
        <trans-unit id="2966c479e2a97d05120d634abb3c3b4fa57bcb14" translate="yes" xml:space="preserve">
          <source>For all practical purposes, such objects behave identically to those of &lt;code&gt;MyStillAmbiguousType&lt;/code&gt;.</source>
          <target state="translated">모든 실제적인 목적으로 이러한 객체는 &lt;code&gt;MyStillAmbiguousType&lt;/code&gt; 의 객체와 동일하게 동작합니다 .</target>
        </trans-unit>
        <trans-unit id="2586b120b44665025a1f73d79469ce79bd89f3e9" translate="yes" xml:space="preserve">
          <source>For allowed arguments, see &lt;a href=&quot;#Base.stat&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">허용되는 인수는 &lt;a href=&quot;#Base.stat&quot;&gt; &lt;code&gt;stat&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f1cb1d8b0a6fd3f459dd21aee4330db5fb020cbc" translate="yes" xml:space="preserve">
          <source>For an M-by-N matrix &lt;code&gt;A&lt;/code&gt; and P-by-N matrix &lt;code&gt;B&lt;/code&gt;,</source>
          <target state="translated">MxN 행렬 &lt;code&gt;A&lt;/code&gt; 및 PxN 행렬 &lt;code&gt;B&lt;/code&gt; 의 경우</target>
        </trans-unit>
        <trans-unit id="c4a55d03c0f3c7fb4fb277a66cb30932f6ca5fde" translate="yes" xml:space="preserve">
          <source>For an array input, return the indices of the maximum elements over the given dimensions. &lt;code&gt;NaN&lt;/code&gt; is treated as greater than all other values.</source>
          <target state="translated">배열 입력의 경우 주어진 차원에 대한 최대 요소의 인덱스를 반환합니다. &lt;code&gt;NaN&lt;/code&gt; 은 다른 모든 값보다 큰 것으로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="f86a7fc66f2b2ba3bac55fe34c24f68f4fabc8c5" translate="yes" xml:space="preserve">
          <source>For an array input, return the indices of the minimum elements over the given dimensions. &lt;code&gt;NaN&lt;/code&gt; is treated as less than all other values.</source>
          <target state="translated">배열 입력의 경우 지정된 차원에서 최소 요소의 인덱스를 반환하십시오. &lt;code&gt;NaN&lt;/code&gt; 은 다른 모든 값보다 적습니다.</target>
        </trans-unit>
        <trans-unit id="29ced7bd7c80c9a4577211e81fdcb7b16c085cf0" translate="yes" xml:space="preserve">
          <source>For an array input, returns the value and index of the maximum over the given dimensions. &lt;code&gt;NaN&lt;/code&gt; is treated as greater than all other values.</source>
          <target state="translated">배열 입력의 경우 주어진 차원에 대한 최대 값과 색인을 반환합니다. &lt;code&gt;NaN&lt;/code&gt; 은 다른 모든 값보다 큰 것으로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="049c1d61ced18d9f201600808d1def1f22e2bc2b" translate="yes" xml:space="preserve">
          <source>For an array input, returns the value and index of the minimum over the given dimensions. &lt;code&gt;NaN&lt;/code&gt; is treated as less than all other values.</source>
          <target state="translated">배열 입력의 경우 지정된 차원에서 최소값과 인덱스를 반환합니다. &lt;code&gt;NaN&lt;/code&gt; 은 다른 모든 값보다 적습니다.</target>
        </trans-unit>
        <trans-unit id="af04ee9a31664b38b875e97d7dedcb572df90336" translate="yes" xml:space="preserve">
          <source>For an excellent, in-depth discussion of floating-point numbers and issues of numerical accuracy encountered when computing with them, see David Goldberg's paper &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.22.6768&amp;amp;rep=rep1&amp;amp;type=pdf&quot;&gt;What Every Computer Scientist Should Know About Floating-Point Arithmetic&lt;/a&gt;.</source>
          <target state="translated">부동 소수점 숫자와 함께 계산할 때 발생하는 숫자 정확도 문제에 대한 심도 있고 깊이있는 토론은 David Goldberg의 논문 &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.22.6768&amp;amp;rep=rep1&amp;amp;type=pdf&quot;&gt;모든 컴퓨터 과학자가 부동 소수점 산술에 대해 알아야 할 내용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b2edf4da8334ec709f88df3d9c11c7bf6cf6a32" translate="yes" xml:space="preserve">
          <source>For an in-place version and algorithmic information, see &lt;a href=&quot;#SparseArrays.dropzeros!&quot;&gt;&lt;code&gt;dropzeros!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">전체 버전 및 알고리즘 정보는 &lt;a href=&quot;#SparseArrays.dropzeros!&quot;&gt; &lt;code&gt;dropzeros!&lt;/code&gt; &lt;/a&gt; 참조하십시오 ! .</target>
        </trans-unit>
        <trans-unit id="231340498dbc5d7093c855f539374b7859ea6f87" translate="yes" xml:space="preserve">
          <source>For an iterator or collection that has keys and values (e.g. arrays and dictionaries), return an iterator over the keys.</source>
          <target state="translated">키와 값 (예 : 배열 및 사전)이있는 반복자 또는 컬렉션의 경우 키 위에 반복자를 반환합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
