<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="d102341c9ef55fb595a96df06da32dfabaf31707" translate="yes" xml:space="preserve">
          <source>Bits Types</source>
          <target state="translated">비트 유형</target>
        </trans-unit>
        <trans-unit id="3d60896c2746f9344a7ec07d0c544abfbd6ac054" translate="yes" xml:space="preserve">
          <source>Bitshifts</source>
          <target state="translated">Bitshifts</target>
        </trans-unit>
        <trans-unit id="f06f824cef5caab026aebdaccc85d665d4b620db" translate="yes" xml:space="preserve">
          <source>Bitwise Operators</source>
          <target state="translated">비트 연산자</target>
        </trans-unit>
        <trans-unit id="003769240202348f8c8c50c01088aea9a66d1338" translate="yes" xml:space="preserve">
          <source>Bitwise and. Implements &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;, returning &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; if one operand is &lt;code&gt;missing&lt;/code&gt; and the other is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">비트와. 하나의 피연산자가 &lt;code&gt;missing&lt;/code&gt; 되고 다른 피연산자 가 &lt;code&gt;true&lt;/code&gt; 인 경우 &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;3을 반환하는 논리를&lt;/a&gt; 구현하여 &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="e8386afef0f71e44b527049e051999293a919fac" translate="yes" xml:space="preserve">
          <source>Bitwise exclusive or of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. Implements &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;, returning &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; if one of the arguments is &lt;code&gt;missing&lt;/code&gt;.</source>
          <target state="translated">배타적 논리합의 비트 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; . 구현 &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;로직을 세 값&lt;/a&gt; 반환 &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 인수 중 하나가되면 &lt;code&gt;missing&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95edcf566466d2b1f53eaf47da115b29e2f2b799" translate="yes" xml:space="preserve">
          <source>Bitwise not.</source>
          <target state="translated">비트 단위는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="55d4c457eca0630bcbc6d9ef2deac549be6e9eb1" translate="yes" xml:space="preserve">
          <source>Bitwise or. Implements &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;, returning &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; if one operand is &lt;code&gt;missing&lt;/code&gt; and the other is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">비트 또는. 하나의 피연산자가 &lt;code&gt;missing&lt;/code&gt; 되고 다른 피연산자 가 &lt;code&gt;false&lt;/code&gt; 인 경우 &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;3 반환 논리를&lt;/a&gt; 구현하여 &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="fbd4e8d6d33b0a0cb69eddf98c203dfb76b59494" translate="yes" xml:space="preserve">
          <source>Black Circle</source>
          <target state="translated">검은 원</target>
        </trans-unit>
        <trans-unit id="0548413521ae8836d60c83abbcac0b4ffd5b48c9" translate="yes" xml:space="preserve">
          <source>Black Circle With Two White Dots</source>
          <target state="translated">두 개의 흰색 점이있는 검은 원</target>
        </trans-unit>
        <trans-unit id="d7fd466be098000d71600e8371d0c45e2c49fceb" translate="yes" xml:space="preserve">
          <source>Black Circle With White Dot Right</source>
          <target state="translated">흰색 점이있는 검은 원</target>
        </trans-unit>
        <trans-unit id="757cd02902cbeae20fd43d03ee03d7081baecb82" translate="yes" xml:space="preserve">
          <source>Black Club Suit</source>
          <target state="translated">블랙 클럽 슈트</target>
        </trans-unit>
        <trans-unit id="9450d23785e56cc9d47bc85752234baaa5f58935" translate="yes" xml:space="preserve">
          <source>Black Diamond</source>
          <target state="translated">블랙 다이아몬드</target>
        </trans-unit>
        <trans-unit id="1e863cdb2d578f5fa6a621df1fbd38ab6818ad43" translate="yes" xml:space="preserve">
          <source>Black Diamond Suit</source>
          <target state="translated">블랙 다이아몬드 슈트</target>
        </trans-unit>
        <trans-unit id="143603a649d02ce401e75e3d4b9853da1d1fab9f" translate="yes" xml:space="preserve">
          <source>Black Down-Pointing Double Triangle</source>
          <target state="translated">블랙 다운 포인팅 더블 트라이앵글</target>
        </trans-unit>
        <trans-unit id="7131227a767e1555b67aefca3c1775aaf0e8eee4" translate="yes" xml:space="preserve">
          <source>Black Down-Pointing Small Triangle / Black Down Pointing Small Triangle</source>
          <target state="translated">검은 색 아래쪽 작은 삼각형 / 검은 색 아래쪽 작은 삼각형</target>
        </trans-unit>
        <trans-unit id="157034cbc1651891d53bf3735a8280c2c9e17261" translate="yes" xml:space="preserve">
          <source>Black Down-Pointing Triangle / Black Down Pointing Triangle</source>
          <target state="translated">블랙 다운 포인팅 트라이앵글 / 블랙 다운 포인팅 트라이앵글</target>
        </trans-unit>
        <trans-unit id="79bb28413b3c0425fd63303d0da05ee06907711e" translate="yes" xml:space="preserve">
          <source>Black Heart Suit</source>
          <target state="translated">검은 심장 정장</target>
        </trans-unit>
        <trans-unit id="84860fcb2778d5994fb2e1ec4ed5e1ff25be0c69" translate="yes" xml:space="preserve">
          <source>Black Hexagon</source>
          <target state="translated">검은 육각형</target>
        </trans-unit>
        <trans-unit id="eb3fe0b35214fe985deafdd4923cb6b5b71ecc00" translate="yes" xml:space="preserve">
          <source>Black Horizontal Ellipse</source>
          <target state="translated">검은 가로 타원</target>
        </trans-unit>
        <trans-unit id="3d24dccec23ef173830493e234a9797701114f4b" translate="yes" xml:space="preserve">
          <source>Black Large Circle</source>
          <target state="translated">검은 색 큰 원</target>
        </trans-unit>
        <trans-unit id="546e54ab988bdc54b4d67a0c87d99ffab31da61d" translate="yes" xml:space="preserve">
          <source>Black Large Square</source>
          <target state="translated">검은 큰 광장</target>
        </trans-unit>
        <trans-unit id="6c8aa0f6c88d86e760e667a1cfc3b50d0980df03" translate="yes" xml:space="preserve">
          <source>Black Left-Pointing Double Triangle</source>
          <target state="translated">검은 색 왼쪽 이중 삼각형</target>
        </trans-unit>
        <trans-unit id="cc1db57a30b84796696c95aebddd648e97e8d503" translate="yes" xml:space="preserve">
          <source>Black Left-Pointing Pointer / Black Left Pointing Pointer</source>
          <target state="translated">검은 색 왼쪽 포인터 / 검은 색 왼쪽 포인터</target>
        </trans-unit>
        <trans-unit id="f5b4fdf2d1f644120341bc595bfdc32acb38d8d9" translate="yes" xml:space="preserve">
          <source>Black Left-Pointing Small Triangle / Black Left Pointing Small Triangle</source>
          <target state="translated">검은 색 왼쪽 작은 삼각형 / 검은 색 왼쪽 작은 삼각형</target>
        </trans-unit>
        <trans-unit id="394197a1901b539e852cc0120322c6a8cc9c8a83" translate="yes" xml:space="preserve">
          <source>Black Left-Pointing Triangle / Black Left Pointing Triangle</source>
          <target state="translated">검은 색 왼쪽을 가리키는 삼각형 / 검은 색 왼쪽을 가리키는 삼각형</target>
        </trans-unit>
        <trans-unit id="651c14702ebcf7b7b2d5b2b8b2d4c78353cf3dc3" translate="yes" xml:space="preserve">
          <source>Black Lower Left Triangle</source>
          <target state="translated">검은 색 왼쪽 아래 삼각형</target>
        </trans-unit>
        <trans-unit id="a993e08e4e58513d7c168e38a98af83c1b823e70" translate="yes" xml:space="preserve">
          <source>Black Lower Right Triangle</source>
          <target state="translated">검은 오른쪽 아래 삼각형</target>
        </trans-unit>
        <trans-unit id="7784160f9d8de2c5b48e65c73c3ba7c32077d5d3" translate="yes" xml:space="preserve">
          <source>Black Lozenge</source>
          <target state="translated">검은 마름모꼴</target>
        </trans-unit>
        <trans-unit id="f51954be7eb46c9d2126809c883eed1d9b6af3da" translate="yes" xml:space="preserve">
          <source>Black Medium Diamond</source>
          <target state="translated">블랙 미디엄 다이아몬드</target>
        </trans-unit>
        <trans-unit id="e638cf3b3eda8a7622b5719c7bc597161ec84dff" translate="yes" xml:space="preserve">
          <source>Black Medium Lozenge</source>
          <target state="translated">블랙 미디엄 마름모꼴</target>
        </trans-unit>
        <trans-unit id="7d1eb991c64f2c0aa6c491bf46495204bab8b980" translate="yes" xml:space="preserve">
          <source>Black Medium Small Square</source>
          <target state="translated">블랙 미디엄 스몰 스퀘어</target>
        </trans-unit>
        <trans-unit id="35e1e8816c4ad0b081b1abc5f0b5e6e68515fdd3" translate="yes" xml:space="preserve">
          <source>Black Medium Square</source>
          <target state="translated">블랙 미디엄 스퀘어</target>
        </trans-unit>
        <trans-unit id="bd88cc2496f705279f693662165cafc22758e595" translate="yes" xml:space="preserve">
          <source>Black Nib</source>
          <target state="translated">검은 펜촉</target>
        </trans-unit>
        <trans-unit id="17a74c499db585ffc78ad964cf24f74eeab12fbc" translate="yes" xml:space="preserve">
          <source>Black Parallelogram</source>
          <target state="translated">검은 색 평행 사변형</target>
        </trans-unit>
        <trans-unit id="a5e0106e423905d56ce64cbee75d3dab7ab613a8" translate="yes" xml:space="preserve">
          <source>Black Pentagon</source>
          <target state="translated">검은 국방부</target>
        </trans-unit>
        <trans-unit id="641e8ed8cc5074283080ad85521696fc93454500" translate="yes" xml:space="preserve">
          <source>Black Question Mark Ornament</source>
          <target state="translated">검은 색 물음표 장식</target>
        </trans-unit>
        <trans-unit id="d17f522d42443e1dee4d94f18ac22410a504bd60" translate="yes" xml:space="preserve">
          <source>Black Rectangle</source>
          <target state="translated">검은 사각형</target>
        </trans-unit>
        <trans-unit id="c7dbb16f8d25cc978eab91325f13bfbb34eb443b" translate="yes" xml:space="preserve">
          <source>Black Right-Pointing Double Triangle</source>
          <target state="translated">검은 색 오른쪽을 가리키는 이중 삼각형</target>
        </trans-unit>
        <trans-unit id="9a22fd5458a747bf2f8b9190b0800a8f327c6da4" translate="yes" xml:space="preserve">
          <source>Black Right-Pointing Pentagon</source>
          <target state="translated">검은 오른쪽 포인팅 국방부</target>
        </trans-unit>
        <trans-unit id="08e8d8d34fe44b6c1da81bad30dfbb3dd0e4dc17" translate="yes" xml:space="preserve">
          <source>Black Right-Pointing Pointer / Black Right Pointing Pointer</source>
          <target state="translated">검은 오른쪽 포인팅 포인터 / 검은 오른쪽 포인팅 포인터</target>
        </trans-unit>
        <trans-unit id="356acd32b10439549774affb8876e75924c2d411" translate="yes" xml:space="preserve">
          <source>Black Right-Pointing Small Triangle / Black Right Pointing Small Triangle</source>
          <target state="translated">검은 색 오른쪽 포인팅 작은 삼각형 / 검은 색 오른쪽 포인팅 작은 삼각형</target>
        </trans-unit>
        <trans-unit id="91e55728177959f6eb733905e6d5d4b3b30df4c9" translate="yes" xml:space="preserve">
          <source>Black Right-Pointing Triangle / Black Right Pointing Triangle</source>
          <target state="translated">검은 색 오른쪽을 가리키는 삼각형 / 검은 색 오른쪽을 가리키는 삼각형</target>
        </trans-unit>
        <trans-unit id="7d35d74427ef7783600f70aed6734b005afcf3a5" translate="yes" xml:space="preserve">
          <source>Black Rightwards Arrow / Black Right Arrow</source>
          <target state="translated">검은 색 오른쪽 화살표 / 검은 색 오른쪽 화살표</target>
        </trans-unit>
        <trans-unit id="4e1227a3b661c19e11075ce6c898353138a6cae4" translate="yes" xml:space="preserve">
          <source>Black Scissors</source>
          <target state="translated">검은 가위</target>
        </trans-unit>
        <trans-unit id="3a1f9cf604664d5b2cfd7032309a96005ebcdd85" translate="yes" xml:space="preserve">
          <source>Black Small Diamond</source>
          <target state="translated">블랙 스몰 다이아몬드</target>
        </trans-unit>
        <trans-unit id="560e8f05828a680fa9a4f86877ed9847156b94a9" translate="yes" xml:space="preserve">
          <source>Black Small Lozenge</source>
          <target state="translated">검은 작은 마름모꼴</target>
        </trans-unit>
        <trans-unit id="2b77f77dfe2cfd17e674571a7ea6fb868ae1d0ef" translate="yes" xml:space="preserve">
          <source>Black Small Square</source>
          <target state="translated">검은 작은 광장</target>
        </trans-unit>
        <trans-unit id="53c256b922dbb0b4f34a326b72cef14e0af86c98" translate="yes" xml:space="preserve">
          <source>Black Small Star</source>
          <target state="translated">검은 작은 별</target>
        </trans-unit>
        <trans-unit id="0ae1e3c46db08b1fb9b73728e2d7c428044fafa6" translate="yes" xml:space="preserve">
          <source>Black Smiling Face</source>
          <target state="translated">검은 웃는 얼굴</target>
        </trans-unit>
        <trans-unit id="8e05108bb9601bfdc9ba0035253f2d64bdf60694" translate="yes" xml:space="preserve">
          <source>Black Spade Suit</source>
          <target state="translated">검은 스페이드 슈트</target>
        </trans-unit>
        <trans-unit id="a01d4a6e7dbc191a1cae5b3bc838a6150cf238dd" translate="yes" xml:space="preserve">
          <source>Black Square</source>
          <target state="translated">블랙 스퀘어</target>
        </trans-unit>
        <trans-unit id="034b512bb5927fe50340904cd99432e1e4d73c3e" translate="yes" xml:space="preserve">
          <source>Black Square Button</source>
          <target state="translated">블랙 스퀘어 버튼</target>
        </trans-unit>
        <trans-unit id="fc626f5b71fcc01fb3ad79538a1fdd9c2c9068b3" translate="yes" xml:space="preserve">
          <source>Black Star</source>
          <target state="translated">검은 별</target>
        </trans-unit>
        <trans-unit id="cb52335be163268292bf2e0b734ba8007620b51b" translate="yes" xml:space="preserve">
          <source>Black Sun With Rays</source>
          <target state="translated">광선으로 검은 태양</target>
        </trans-unit>
        <trans-unit id="337ee67e4218483768c29454b46d3636ae0684a9" translate="yes" xml:space="preserve">
          <source>Black Telephone</source>
          <target state="translated">검은 전화</target>
        </trans-unit>
        <trans-unit id="35536366f9217c4ba0ce04cd1f6ccbeed6b48c42" translate="yes" xml:space="preserve">
          <source>Black Universal Recycling Symbol</source>
          <target state="translated">검은 보편적 인 재활용 기호</target>
        </trans-unit>
        <trans-unit id="b63e9c12f3af70d3503bfb12a43507958e2cc9a3" translate="yes" xml:space="preserve">
          <source>Black Up-Pointing Double Triangle</source>
          <target state="translated">검은 색 위쪽 이중 삼각형</target>
        </trans-unit>
        <trans-unit id="5f6c177d2a76e96c788cfff6b45ea350fc5d5f85" translate="yes" xml:space="preserve">
          <source>Black Up-Pointing Small Triangle / Black Up Pointing Small Triangle</source>
          <target state="translated">검은 색 위를 가리키는 작은 삼각형 / 검은 색 위를 가리키는 작은 삼각형</target>
        </trans-unit>
        <trans-unit id="b019fe1ecc9d7bb3e20c546241096de99470763e" translate="yes" xml:space="preserve">
          <source>Black Up-Pointing Triangle / Black Up Pointing Triangle</source>
          <target state="translated">검은 색 위를 가리키는 삼각형 / 검은 색 위를 가리키는 삼각형</target>
        </trans-unit>
        <trans-unit id="fd38c797487c28729bfa7084dbd1bc7a8bd9f832" translate="yes" xml:space="preserve">
          <source>Black Upper Left Triangle</source>
          <target state="translated">검은 상단 왼쪽 삼각형</target>
        </trans-unit>
        <trans-unit id="330a4e0eb7ba380f3677a102ba04f4ed4533c835" translate="yes" xml:space="preserve">
          <source>Black Upper Right Triangle</source>
          <target state="translated">검은 오른쪽 위 삼각형</target>
        </trans-unit>
        <trans-unit id="b5b860326f4e45d10acdc58e96248cded912b473" translate="yes" xml:space="preserve">
          <source>Black Vertical Ellipse</source>
          <target state="translated">검은 세로 타원</target>
        </trans-unit>
        <trans-unit id="12f762cae12dfd257dbcc1ff1c80f6e21ca05f3a" translate="yes" xml:space="preserve">
          <source>Black Vertical Rectangle</source>
          <target state="translated">검은 세로 직사각형</target>
        </trans-unit>
        <trans-unit id="b6c6da3063676ec7403eb5eae23f28a26cc0a5b1" translate="yes" xml:space="preserve">
          <source>Black Very Small Square</source>
          <target state="translated">검은 매우 작은 광장</target>
        </trans-unit>
        <trans-unit id="f56700596b30b0c05182a7f770b5570cc76ca6d1" translate="yes" xml:space="preserve">
          <source>Black-Letter Capital C / Black-Letter C</source>
          <target state="translated">검은 글자 대문자 C / 검은 글자 C</target>
        </trans-unit>
        <trans-unit id="3212f9c9a227cc0ef9fc8c3906dee3d018e41215" translate="yes" xml:space="preserve">
          <source>Black-Letter Capital H / Black-Letter H</source>
          <target state="translated">검은 글자 대문자 H / 검은 글자 H</target>
        </trans-unit>
        <trans-unit id="882d2d7aaddec9c72be91b9b04d8760d1ae0ecd3" translate="yes" xml:space="preserve">
          <source>Black-Letter Capital I / Black-Letter I</source>
          <target state="translated">검은 글자 대문자 I / 검은 글자 I</target>
        </trans-unit>
        <trans-unit id="8fc35324b6b0420a0444517c7f25614eb146dba4" translate="yes" xml:space="preserve">
          <source>Black-Letter Capital R / Black-Letter R</source>
          <target state="translated">검은 글자 대문자 R / 검은 글자 R</target>
        </trans-unit>
        <trans-unit id="4d139693ac24fa1ff39a927bee456e508f1aa95b" translate="yes" xml:space="preserve">
          <source>Black-Letter Capital Z / Black-Letter Z</source>
          <target state="translated">검은 글자 대문자 Z / 검은 글자 Z</target>
        </trans-unit>
        <trans-unit id="b847d9aaffd54e2b50551787d032091550aee835" translate="yes" xml:space="preserve">
          <source>Blank Symbol / Blank</source>
          <target state="translated">공백 기호 / 공백</target>
        </trans-unit>
        <trans-unit id="9a1f6bbeb59612c3b0d54abe35a469485c6370c0" translate="yes" xml:space="preserve">
          <source>Block quotes</source>
          <target state="translated">따옴표</target>
        </trans-unit>
        <trans-unit id="413fe7b76bad922e0442b15508cafb42d749001b" translate="yes" xml:space="preserve">
          <source>Block the current task for a specified number of seconds. The minimum sleep time is 1 millisecond or input of &lt;code&gt;0.001&lt;/code&gt;.</source>
          <target state="translated">지정된 시간 (초) 동안 현재 작업을 차단합니다. 최소 절전 시간은 1 밀리 초 또는 &lt;code&gt;0.001&lt;/code&gt; 입력입니다 .</target>
        </trans-unit>
        <trans-unit id="da010911be728132526ebfb6c6611c41bf6de799" translate="yes" xml:space="preserve">
          <source>Block the current task until some event occurs, depending on the type of the argument:</source>
          <target state="translated">인수 유형에 따라 일부 이벤트가 발생할 때까지 현재 작업을 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="53a69c53a3e2458ff176a179fec2def0b4121cba" translate="yes" xml:space="preserve">
          <source>Blossom</source>
          <target state="translated">Blossom</target>
        </trans-unit>
        <trans-unit id="a6a6cc1c6c34e00f61be8a8c251a0e48237ab0a0" translate="yes" xml:space="preserve">
          <source>Blowfish</source>
          <target state="translated">Blowfish</target>
        </trans-unit>
        <trans-unit id="5963e560ae138684a55eeb248a0ec6a3d3e89c64" translate="yes" xml:space="preserve">
          <source>Blue Book</source>
          <target state="translated">블루 북</target>
        </trans-unit>
        <trans-unit id="a660e98a286d13e32848e06494a9c4e64598de77" translate="yes" xml:space="preserve">
          <source>Blue Heart</source>
          <target state="translated">푸른 마음</target>
        </trans-unit>
        <trans-unit id="30efd20f542ce356dcbbbbb0473393dd8189443b" translate="yes" xml:space="preserve">
          <source>Boar</source>
          <target state="translated">Boar</target>
        </trans-unit>
        <trans-unit id="19e07430eed6d97d6d73cb4a2967b1f316520f54" translate="yes" xml:space="preserve">
          <source>Bold</source>
          <target state="translated">Bold</target>
        </trans-unit>
        <trans-unit id="d5bf9d845ab97255cb3ab1100656db4f59731808" translate="yes" xml:space="preserve">
          <source>Bomb</source>
          <target state="translated">Bomb</target>
        </trans-unit>
        <trans-unit id="441da1bf0eb8dcaca895f5d48325eab484ada1e0" translate="yes" xml:space="preserve">
          <source>Bookmark</source>
          <target state="translated">Bookmark</target>
        </trans-unit>
        <trans-unit id="d51cc7068c060eda1ab4c1992e8e7188251dc5d0" translate="yes" xml:space="preserve">
          <source>Bookmark Tabs</source>
          <target state="translated">북마크 탭</target>
        </trans-unit>
        <trans-unit id="4a7fdd8c17425252332ea0e89a35722b72d83135" translate="yes" xml:space="preserve">
          <source>Books</source>
          <target state="translated">Books</target>
        </trans-unit>
        <trans-unit id="9110e7395759cef34c9766cb75b920652e0ab037" translate="yes" xml:space="preserve">
          <source>Boolean not. Implements &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;, returning &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;missing&lt;/code&gt;.</source>
          <target state="translated">부울이 아닙니다. &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;missing&lt;/code&gt; 경우 &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; 을&lt;/a&gt; 반환하는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;3 값 논리를&lt;/a&gt; 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="f5e74670608867d2d5a7f2c19b7656691fac4def" translate="yes" xml:space="preserve">
          <source>Boolean operations &lt;em&gt;without&lt;/em&gt; short-circuit evaluation can be done with the bitwise boolean operators introduced in &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;Mathematical Operations and Elementary Functions&lt;/a&gt;: &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;. These are normal functions, which happen to support infix operator syntax, but always evaluate their arguments:</source>
          <target state="translated">부울 연산 &lt;em&gt;없이&lt;/em&gt; 단락 평가는 비트에 도입 부울 연산자와 함께 할 수있는 &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;수학 운영 및 초등학교 기능&lt;/a&gt; : &lt;code&gt;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;|&lt;/code&gt; . 이들은 보통 연산자이며, 중위 연산자 구문을 지원하지만 항상 인수를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="6aee8c1403b8f533d1b1cfe7c809aba2942d98a3" translate="yes" xml:space="preserve">
          <source>Boolean type, containing the values &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">값이 포함 된 부울 유형, &lt;code&gt;true&lt;/code&gt; 과 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d3edec84ef05d40009ef42ad79a184127ff2d32" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; are basically immutable &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt; wrappers. The single &lt;code&gt;instant&lt;/code&gt; field of either type is actually a &lt;code&gt;UTInstant{P}&lt;/code&gt; type, which represents a continuously increasing machine timeline based on the UT second &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt;. The &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; type is not aware of time zones (&lt;em&gt;naive&lt;/em&gt;, in Python parlance), analogous to a &lt;em&gt;LocalDateTime&lt;/em&gt; in Java 8. Additional time zone functionality can be added through the &lt;a href=&quot;https://github.com/JuliaTime/TimeZones.jl/&quot;&gt;TimeZones.jl package&lt;/a&gt;, which compiles the &lt;a href=&quot;http://www.iana.org/time-zones&quot;&gt;IANA time zone database&lt;/a&gt;. Both &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; are based on the &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601&lt;/a&gt; standard, which follows the proleptic Gregorian calendar. One note is that the ISO 8601 standard is particular about BC/BCE dates. In general, the last day of the BC/BCE era, 1-12-31 BC/BCE, was followed by 1-1-1 AD/CE, thus no year zero exists. The ISO standard, however, states that 1 BC/BCE is year zero, so &lt;code&gt;0000-12-31&lt;/code&gt; is the day before &lt;code&gt;0001-01-01&lt;/code&gt;, and year &lt;code&gt;-0001&lt;/code&gt; (yes, negative one for the year) is 2 BC/BCE, year &lt;code&gt;-0002&lt;/code&gt; is 3 BC/BCE, etc.</source>
          <target state="translated">두 &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 기본적으로 불변 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; 래퍼. 두 유형 중 하나 의 단일 &lt;code&gt;instant&lt;/code&gt; 필드는 실제로 &lt;code&gt;UTInstant{P}&lt;/code&gt; 유형이며, 이는 UT 초를 기준으로 지속적으로 증가하는 머신 타임 라인을 나타냅니다 &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt; . &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 유형 (시간대 인식하지 &lt;em&gt;순진한&lt;/em&gt; A와 비슷한 파이썬 용어로,), &lt;em&gt;LocalDateTime&lt;/em&gt; 8. 추가 시간대 기능은 통해 추가 할 수 있습니다 자바 &lt;a href=&quot;https://github.com/JuliaTime/TimeZones.jl/&quot;&gt;TimeZones.jl 패키지&lt;/a&gt; 컴파일, &lt;a href=&quot;http://www.iana.org/time-zones&quot;&gt;IANA 시간대 데이터베이스를&lt;/a&gt; . &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 은 모두&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;&lt;/a&gt;Proleptic Gregorian 달력을 따르는 ISO 8601 표준. 한 가지 주목할 점은 ISO 8601 표준이 BC / BCE 날짜와 관련이 있다는 것입니다. 일반적으로 BC / BCE 시대의 마지막 날인 1-12-31 BC / BCE 다음에 1-1-1 AD / CE가 있었으므로 0 년이 존재하지 않습니다. 그러나 ISO 표준에 따르면 1 BC / BCE는 0 년이므로 &lt;code&gt;0000-12-31&lt;/code&gt; 은 &lt;code&gt;0001-01-01&lt;/code&gt; 전날 이고 연도 &lt;code&gt;-0001&lt;/code&gt; (예, 음수는 1)은 2 BC / BCE입니다. &lt;code&gt;-0002&lt;/code&gt; 년 은 3 BC / BCE 등입니다.</target>
        </trans-unit>
        <trans-unit id="b9bf1ed5d0b3dee373193977f771d3d28aa04eff" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;fdot&lt;/code&gt; compute the same thing. However, &lt;code&gt;fdot&lt;/code&gt; (defined with the help of the &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.@__dot__&quot;&gt;&lt;code&gt;@.&lt;/code&gt;&lt;/a&gt; macro) is significantly faster when applied to an array:</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 와 &lt;code&gt;fdot&lt;/code&gt; 는 모두 같은 것을 계산합니다. 그러나 배열에 적용하면 &lt;code&gt;fdot&lt;/code&gt; ( &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.@__dot__&quot;&gt; &lt;code&gt;@.&lt;/code&gt; &lt;/a&gt; 매크로를 사용하여 정의 됨 )가 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="894facd8272490d18ae36dfbd0aea23dbfd8d0be" translate="yes" xml:space="preserve">
          <source>Both abstract and concrete types can be parameterized by other types. They can also be parameterized by symbols, by values of any type for which &lt;a href=&quot;../../base/base/index#Base.isbits&quot;&gt;&lt;code&gt;isbits&lt;/code&gt;&lt;/a&gt; returns true (essentially, things like numbers and bools that are stored like C types or &lt;code&gt;struct&lt;/code&gt;s with no pointers to other objects), and also by tuples thereof. Type parameters may be omitted when they do not need to be referenced or restricted.</source>
          <target state="translated">추상 및 콘크리트 유형 모두 다른 유형으로 매개 변수화 할 수 있습니다. 또한 기호, &lt;a href=&quot;../../base/base/index#Base.isbits&quot;&gt; &lt;code&gt;isbits&lt;/code&gt; &lt;/a&gt; 가 true를 리턴 하는 모든 유형의 값 (실제로 C 유형 또는 &lt;code&gt;struct&lt;/code&gt; 처럼 다른 객체에 대한 포인터없이 저장된 숫자 및 부울 과 같은 것)과 그 튜플에 의해 매개 변수화 될 수 있습니다 . 유형 매개 변수는 참조하거나 제한 할 필요가없는 경우 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63dac16e286415a31cf4c5cfa7d67dab90fd4b82" translate="yes" xml:space="preserve">
          <source>Both concatenation and string interpolation call &lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; to convert objects into string form. However, &lt;code&gt;string&lt;/code&gt; actually just returns the output of &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt;, so new types should add methods to &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;show&lt;/code&gt; instead of &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">연결 및 문자열 보간 모두 &lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt; 을 호출 하여 개체를 문자열 형식으로 변환합니다. 그러나 &lt;code&gt;string&lt;/code&gt; 은 실제로는 &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt; 출력 만 반환 하므로 새로운 유형은 &lt;code&gt;string&lt;/code&gt; 대신 &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;show&lt;/code&gt; 메소드를 추가해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="e92cf62db18ffc6b16befca5871ba839cf28860c" translate="yes" xml:space="preserve">
          <source>Both expressions are interpreted as function application: any expression that is not a numeric literal, when immediately followed by a parenthetical, is interpreted as a function applied to the values in parentheses (see &lt;a href=&quot;../faq/index#Functions-1&quot;&gt;Functions&lt;/a&gt; for more about functions). Thus, in both of these cases, an error occurs since the left-hand value is not a function.</source>
          <target state="translated">두 표현식 모두 함수 애플리케이션으로 해석됩니다. 숫자 리터럴이 아닌 표현식은 바로 뒤에 괄호가 붙는 경우 괄호 안의 값에 적용되는 함수로 해석됩니다 ( &lt;a href=&quot;../faq/index#Functions-1&quot;&gt;함수에&lt;/a&gt; 대한 자세한 내용은 함수 참조). 따라서 두 경우 모두 왼쪽 값이 함수가 아니기 때문에 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fe2f60cb62bba939fc1814f0702994179d2cc9fd" translate="yes" xml:space="preserve">
          <source>Both these implementations, although different, do essentially the same thing: a runtime loop over the dimensions of the array, collecting the offset in each dimension into the final index.</source>
          <target state="translated">이 두 구현은 서로 다르지만 본질적으로 동일한 작업을 수행합니다. 즉, 배열 차원에 대한 런타임 루프를 통해 각 차원의 오프셋을 최종 인덱스로 수집합니다.</target>
        </trans-unit>
        <trans-unit id="9c695a21716f0561a4e4e8d8969c9a67ff3ac14a" translate="yes" xml:space="preserve">
          <source>Bottom Curly Bracket</source>
          <target state="translated">바텀 컬리 브라켓</target>
        </trans-unit>
        <trans-unit id="5c381cbda1ed56fa362cad0521e4ca378f6df12d" translate="yes" xml:space="preserve">
          <source>Bottom Left Corner</source>
          <target state="translated">왼쪽 하단</target>
        </trans-unit>
        <trans-unit id="8b91a1776362601aa94f5e511fc42880fb137818" translate="yes" xml:space="preserve">
          <source>Bottom Right Corner</source>
          <target state="translated">오른쪽 하단</target>
        </trans-unit>
        <trans-unit id="408cb2c9aacb6c00f4eea9f155e68230edfc13be" translate="yes" xml:space="preserve">
          <source>Bottom Square Bracket</source>
          <target state="translated">바텀 스퀘어 브라켓</target>
        </trans-unit>
        <trans-unit id="b587f4044bf50468cb606a8c8b879cf7bf3a57b0" translate="yes" xml:space="preserve">
          <source>Bottom Square Bracket Over Top Square Bracket</source>
          <target state="translated">상단 사각 브래킷 위에 하단 사각 브래킷</target>
        </trans-unit>
        <trans-unit id="be63873217899f3efce2481a86c1d5a6e1aa9ff7" translate="yes" xml:space="preserve">
          <source>Bouquet</source>
          <target state="translated">Bouquet</target>
        </trans-unit>
        <trans-unit id="527e7050bb885ff38897eb7cbe0d818d6e05448e" translate="yes" xml:space="preserve">
          <source>Bowling</source>
          <target state="translated">Bowling</target>
        </trans-unit>
        <trans-unit id="df3f8f8f9dfd1bd2fca6e5c445d1a47fa385ede3" translate="yes" xml:space="preserve">
          <source>Bowtie</source>
          <target state="translated">Bowtie</target>
        </trans-unit>
        <trans-unit id="2365940089f0b35468618bed420a02ff8d78ea80" translate="yes" xml:space="preserve">
          <source>Box Drawings Light Diagonal Upper Left To Lower Right / Forms Light Diagonal Upper Left To Lower Right</source>
          <target state="translated">박스 도면 라이트 대각선 위 왼쪽에서 오른쪽 아래로 / 형태 라이트 대각선 위 왼쪽에서 오른쪽 아래로</target>
        </trans-unit>
        <trans-unit id="510ae6748e0c9b114a5f8b83c8badc7f63a16bc0" translate="yes" xml:space="preserve">
          <source>Box Drawings Light Diagonal Upper Right To Lower Left / Forms Light Diagonal Upper Right To Lower Left</source>
          <target state="translated">상자 그림 빛 대각선 위 오른쪽 아래 왼쪽 / 형태 빛 대각선 위 오른쪽 아래 왼쪽</target>
        </trans-unit>
        <trans-unit id="12f6d098ab5b7193c3d26b08f696b2a980dca3f4" translate="yes" xml:space="preserve">
          <source>Box Drawings Light Triple Dash Vertical / Forms Light Triple Dash Vertical</source>
          <target state="translated">상자 그림 가벼운 3 배 돌진 수직 / 형태 가벼운 3 배 돌진 수직</target>
        </trans-unit>
        <trans-unit id="85230437c79e72b707969ab19fa9c93e520c40d0" translate="yes" xml:space="preserve">
          <source>Box Drawings Up Light And Left Heavy / Forms Up Light And Left Heavy</source>
          <target state="translated">상자 그리기 가볍고 무거움 / 가볍고 무거움</target>
        </trans-unit>
        <trans-unit id="b9dc9d8cb52edb821b0da78df2b6682eb917d791" translate="yes" xml:space="preserve">
          <source>Boy</source>
          <target state="translated">Boy</target>
        </trans-unit>
        <trans-unit id="c61eb5df5d78529f719e752eeef8ece81e0caaa8" translate="yes" xml:space="preserve">
          <source>Bread</source>
          <target state="translated">Bread</target>
        </trans-unit>
        <trans-unit id="67334b607f6cd61759a7703ce073645a7bb380d4" translate="yes" xml:space="preserve">
          <source>Break functions into multiple definitions</source>
          <target state="translated">함수를 여러 정의로 나누기</target>
        </trans-unit>
        <trans-unit id="8a10e4a625ea22134f5962dee4da949a99868e13" translate="yes" xml:space="preserve">
          <source>Break out of a loop immediately.</source>
          <target state="translated">루프를 즉시 중단하십시오.</target>
        </trans-unit>
        <trans-unit id="392384778265e06187313603c1377439a8615e6f" translate="yes" xml:space="preserve">
          <source>Break the &lt;code&gt;ConfigEntry&lt;/code&gt; up to the following pieces: section, subsection, name, and value.</source>
          <target state="translated">휴식 &lt;code&gt;ConfigEntry&lt;/code&gt; 을 다음 조각까지 : 섹션, 하위 섹션, 이름 및 값입니다.</target>
        </trans-unit>
        <trans-unit id="7632e2c1e249278468e77e6447234ae7607c5253" translate="yes" xml:space="preserve">
          <source>Breve / Spacing Breve</source>
          <target state="translated">브 리브 / 간격 브 리브</target>
        </trans-unit>
        <trans-unit id="daaf045cb7109dd158210ed8775987a60503bbb6" translate="yes" xml:space="preserve">
          <source>Bride With Veil</source>
          <target state="translated">베일과 신부</target>
        </trans-unit>
        <trans-unit id="4e7371d09f6498019117c2fcbb67ffe9a940c17f" translate="yes" xml:space="preserve">
          <source>Bridge At Night</source>
          <target state="translated">밤에 다리</target>
        </trans-unit>
        <trans-unit id="ee60d60ea805fbda38f6f538481a92d3787df0b9" translate="yes" xml:space="preserve">
          <source>Brief description</source>
          <target state="translated">간단한 설명</target>
        </trans-unit>
        <trans-unit id="b11bca2ce38ace33f9cb3a0f0323440cce89dd0f" translate="yes" xml:space="preserve">
          <source>Briefcase</source>
          <target state="translated">Briefcase</target>
        </trans-unit>
        <trans-unit id="77ca3fc6500edac54d325df1bbb7ac8e363c54b5" translate="yes" xml:space="preserve">
          <source>Broadcast</source>
          <target state="translated">Broadcast</target>
        </trans-unit>
        <trans-unit id="5959941fc9ce31c144990539361b6855d239f922" translate="yes" xml:space="preserve">
          <source>Broadcast Styles</source>
          <target state="translated">방송 스타일</target>
        </trans-unit>
        <trans-unit id="cdaa679362eaad18a4a290d4b2177d1c9eddf091" translate="yes" xml:space="preserve">
          <source>Broadcast and vectorization</source>
          <target state="translated">방송 및 벡터화</target>
        </trans-unit>
        <trans-unit id="7df7947bfeebee1e64e3a5fe7acfcbaa176cd869" translate="yes" xml:space="preserve">
          <source>Broadcast the function &lt;code&gt;f&lt;/code&gt; over the arrays, tuples, collections, &lt;a href=&quot;../c/index#Core.Ref&quot;&gt;&lt;code&gt;Ref&lt;/code&gt;&lt;/a&gt;s and/or scalars &lt;code&gt;As&lt;/code&gt;.</source>
          <target state="translated">배열, 튜플, 컬렉션, &lt;a href=&quot;../c/index#Core.Ref&quot;&gt; &lt;code&gt;Ref&lt;/code&gt; &lt;/a&gt; 및 / 또는 스칼라 &lt;code&gt;As&lt;/code&gt; 로 함수 &lt;code&gt;f&lt;/code&gt; 를 브로드 캐스트하십시오 .</target>
        </trans-unit>
        <trans-unit id="074efe61b6453184efecedf79f56223cb3b56a06" translate="yes" xml:space="preserve">
          <source>Broadcast.@__dot__</source>
          <target state="translated">Broadcast.@__dot__</target>
        </trans-unit>
        <trans-unit id="d9974c014c3e7a0c286c1e54c44afebb2e5a2605" translate="yes" xml:space="preserve">
          <source>Broadcast.AbstractArrayStyle</source>
          <target state="translated">Broadcast.AbstractArrayStyle</target>
        </trans-unit>
        <trans-unit id="e479e2fec9cd8edd73518e3aa9d740af4ffed128" translate="yes" xml:space="preserve">
          <source>Broadcast.ArrayStyle</source>
          <target state="translated">Broadcast.ArrayStyle</target>
        </trans-unit>
        <trans-unit id="46b115d26f9c6f955c31e3892d4b89859d8782ab" translate="yes" xml:space="preserve">
          <source>Broadcast.BroadcastStyle</source>
          <target state="translated">Broadcast.BroadcastStyle</target>
        </trans-unit>
        <trans-unit id="dfd372b601ba77b3813f2634bb5fb9643c14c102" translate="yes" xml:space="preserve">
          <source>Broadcast.DefaultArrayStyle</source>
          <target state="translated">Broadcast.DefaultArrayStyle</target>
        </trans-unit>
        <trans-unit id="6969d3cd7b2ed2ce0f9a60fb4945dade93d4e117" translate="yes" xml:space="preserve">
          <source>Broadcast.broadcast!()</source>
          <target state="translated">Broadcast.broadcast!()</target>
        </trans-unit>
        <trans-unit id="2d33589d08eead5af3fe72a94a8b53b3373f4645" translate="yes" xml:space="preserve">
          <source>Broadcast.broadcast()</source>
          <target state="translated">Broadcast.broadcast()</target>
        </trans-unit>
        <trans-unit id="d8be6debc5bb7fb35ee9eb11d215775cae452707" translate="yes" xml:space="preserve">
          <source>Broadcast.broadcastable()</source>
          <target state="translated">Broadcast.broadcastable()</target>
        </trans-unit>
        <trans-unit id="48464259628c114acb1957dc941186fb95dc6984" translate="yes" xml:space="preserve">
          <source>Broadcast.combine_axes()</source>
          <target state="translated">Broadcast.combine_axes()</target>
        </trans-unit>
        <trans-unit id="65a7f7386144353a37453858bdd5ecb6ccb1274f" translate="yes" xml:space="preserve">
          <source>Broadcast.combine_styles()</source>
          <target state="translated">Broadcast.combine_styles()</target>
        </trans-unit>
        <trans-unit id="d36a0668f40c2a01499f97eb697585c01ce9b9ab" translate="yes" xml:space="preserve">
          <source>Broadcast.result_style()</source>
          <target state="translated">Broadcast.result_style()</target>
        </trans-unit>
        <trans-unit id="ba459229366746c447e3cdf752eb917433152cfe" translate="yes" xml:space="preserve">
          <source>Broadcasting</source>
          <target state="translated">Broadcasting</target>
        </trans-unit>
        <trans-unit id="0e83693fd8be7602fb86ef05c34ce5d03fd5fce4" translate="yes" xml:space="preserve">
          <source>Broadcasting applies the function &lt;code&gt;f&lt;/code&gt; over the elements of the container arguments and the scalars themselves in &lt;code&gt;As&lt;/code&gt;. Singleton and missing dimensions are expanded to match the extents of the other arguments by virtually repeating the value. By default, only a limited number of types are considered scalars, including &lt;code&gt;Number&lt;/code&gt;s, &lt;code&gt;String&lt;/code&gt;s, &lt;code&gt;Symbol&lt;/code&gt;s, &lt;code&gt;Type&lt;/code&gt;s, &lt;code&gt;Function&lt;/code&gt;s and some common singletons like &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;. All other arguments are iterated over or indexed into elementwise.</source>
          <target state="translated">브로드 캐스팅 은 컨테이너 인수의 요소와 &lt;code&gt;As&lt;/code&gt; 의 스칼라 자체에 함수 &lt;code&gt;f&lt;/code&gt; 를 적용합니다 . 단일 값과 누락 된 차원은 값을 사실상 반복하여 다른 인수의 범위와 일치하도록 확장됩니다. 기본적으로 &lt;code&gt;Number&lt;/code&gt; , &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;Symbol&lt;/code&gt; , &lt;code&gt;Type&lt;/code&gt; , &lt;code&gt;Function&lt;/code&gt; 및 &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; 과 같은 일반적인 싱글 톤을 포함하여 제한된 수의 유형 만 스칼라로 간주됩니다 . 다른 모든 인수는 요소 단위로 반복되거나 색인화됩니다.</target>
        </trans-unit>
        <trans-unit id="7b246945f4825122c3abc36d497da5fe651d872b" translate="yes" xml:space="preserve">
          <source>Broadcasting behavior of &lt;code&gt;SrcType&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;SrcType&lt;/code&gt; 의 브로드 캐스트 동작</target>
        </trans-unit>
        <trans-unit id="0e2fa4ca8541a569a98cefd4832f00fffb8a668a" translate="yes" xml:space="preserve">
          <source>Broadcasting of CartesianIndices requires at least Julia 1.1.</source>
          <target state="translated">데카르트 인덱스를 브로드 캐스트하려면 Julia 1.1 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="de4b71257ec056201227e217cf933d2e092cf0c7" translate="yes" xml:space="preserve">
          <source>Broken Bar / Broken Vertical Bar</source>
          <target state="translated">깨진 바 / 깨진 수직 바</target>
        </trans-unit>
        <trans-unit id="0d35795616ab98cd5aa59673de45c7c6c73a4a9c" translate="yes" xml:space="preserve">
          <source>Broken Heart</source>
          <target state="translated">상한 마음</target>
        </trans-unit>
        <trans-unit id="79b7916b0d6bd1fa29180da64a852f6051cdd3b6" translate="yes" xml:space="preserve">
          <source>Broken Tests</source>
          <target state="translated">깨진 테스트</target>
        </trans-unit>
        <trans-unit id="8cb75fd2f909d7fe2d9ebdd702d582785b35815a" translate="yes" xml:space="preserve">
          <source>Browser-based workflow</source>
          <target state="translated">브라우저 기반 워크 플로우</target>
        </trans-unit>
        <trans-unit id="271befc09ec922fba884ac992f346efbaa84c1c6" translate="yes" xml:space="preserve">
          <source>Bug</source>
          <target state="translated">Bug</target>
        </trans-unit>
        <trans-unit id="a0ff1503de64d75563fdaa852cd66a5161072182" translate="yes" xml:space="preserve">
          <source>Build the output matrix as &lt;code&gt;similar(R, dims)&lt;/code&gt;, where &lt;code&gt;dims&lt;/code&gt; are the desired dimensions of the output array.</source>
          <target state="translated">출력 행렬을 &lt;code&gt;similar(R, dims)&lt;/code&gt; 로 빌드합니다 . 여기서 &lt;code&gt;dims&lt;/code&gt; 는 원하는 출력 배열 크기입니다.</target>
        </trans-unit>
        <trans-unit id="9b68712d139bce25a7399715ee37cf5a89ca4787" translate="yes" xml:space="preserve">
          <source>Building a similar type with a different type parameter</source>
          <target state="translated">다른 유형 매개 변수로 유사한 유형 작성</target>
        </trans-unit>
        <trans-unit id="472631cf7902fb6cb7b3cc2952c6a64c270752fa" translate="yes" xml:space="preserve">
          <source>Building an advanced macro</source>
          <target state="translated">고급 매크로 작성</target>
        </trans-unit>
        <trans-unit id="fe79fc1370416c81e94ca362477853ed355de172" translate="yes" xml:space="preserve">
          <source>Built-in &lt;code&gt;Exception&lt;/code&gt;s</source>
          <target state="translated">내장 &lt;code&gt;Exception&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="b98da0ccc81f4f734434572f19ccc66972aae344" translate="yes" xml:space="preserve">
          <source>Bullet</source>
          <target state="translated">Bullet</target>
        </trans-unit>
        <trans-unit id="b2e3c9a189a187c73db37aa7676051a963459c1a" translate="yes" xml:space="preserve">
          <source>Bullet Operator</source>
          <target state="translated">총알 연산자</target>
        </trans-unit>
        <trans-unit id="ffb3a635db82436b5aade99cffc92370f3f7ed19" translate="yes" xml:space="preserve">
          <source>Bullseye</source>
          <target state="translated">Bullseye</target>
        </trans-unit>
        <trans-unit id="6380df8107fb2d9626efb1aee5cb211de2982cbd" translate="yes" xml:space="preserve">
          <source>Bunch-Kaufman (see &lt;a href=&quot;#LinearAlgebra.bunchkaufman&quot;&gt;&lt;code&gt;bunchkaufman&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;#LinearAlgebra.bunchkaufman&quot;&gt; &lt;code&gt;bunchkaufman&lt;/code&gt; &lt;/a&gt; -카우프만 ( bunchkaufman 참조 )</target>
        </trans-unit>
        <trans-unit id="56070a568367d5a4e9970cfff19cb97578ce1361" translate="yes" xml:space="preserve">
          <source>Bus</source>
          <target state="translated">Bus</target>
        </trans-unit>
        <trans-unit id="de2d017d398674ca4eafe20ca3761f2f657234b8" translate="yes" xml:space="preserve">
          <source>Bus Stop</source>
          <target state="translated">버스 정류장</target>
        </trans-unit>
        <trans-unit id="97d53e844a4148a55c4152e5e7736932ca111090" translate="yes" xml:space="preserve">
          <source>Bust In Silhouette</source>
          <target state="translated">실루엣에 흉상</target>
        </trans-unit>
        <trans-unit id="45f0d298267aa05679aedb20cf6611cfa3d2a5d1" translate="yes" xml:space="preserve">
          <source>Busts In Silhouette</source>
          <target state="translated">실루엣에 흉상</target>
        </trans-unit>
        <trans-unit id="e7a7510504bc122560ba5c8208e379522ff06902" translate="yes" xml:space="preserve">
          <source>But here is a thing you should pay attention to: suppose &lt;code&gt;x&lt;/code&gt; is bound to an object of type &lt;code&gt;Array&lt;/code&gt; (or any other &lt;em&gt;mutable&lt;/em&gt; type). From within the function, you cannot &quot;unbind&quot; &lt;code&gt;x&lt;/code&gt; from this Array, but you can change its content. For example:</source>
          <target state="translated">그러나 여기에주의해야 할 사항이 있습니다. &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;Array&lt;/code&gt; 유형의 객체 (또는 다른 &lt;em&gt;변경 가능한&lt;/em&gt; 유형)에 바인딩되어 있다고 가정하십시오 . 함수 내 에서이 배열에서 &lt;code&gt;x&lt;/code&gt; 를 &quot;바인드 해제&quot; 할 수 없지만 내용을 변경할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0adf28177ba73d224bb6721567052c88af510023" translate="yes" xml:space="preserve">
          <source>But how does one construct the first instance when no instance exists to provide as a valid value for its &lt;code&gt;obj&lt;/code&gt; field? The only solution is to allow creating an incompletely initialized instance of &lt;code&gt;SelfReferential&lt;/code&gt; with an unassigned &lt;code&gt;obj&lt;/code&gt; field, and using that incomplete instance as a valid value for the &lt;code&gt;obj&lt;/code&gt; field of another instance, such as, for example, itself.</source>
          <target state="translated">그러나 &lt;code&gt;obj&lt;/code&gt; 필드에 유효한 값으로 제공 할 인스턴스가없는 경우 첫 번째 인스턴스를 어떻게 구성 합니까? 유일한 해결책은 할당되지 않은 &lt;code&gt;obj&lt;/code&gt; 필드를 사용하여 불완전하게 초기화 된 &lt;code&gt;SelfReferential&lt;/code&gt; 인스턴스를 작성하고 해당 불완전한 인스턴스 를 다른 인스턴스 의 &lt;code&gt;obj&lt;/code&gt; 필드 (예 : 자체)에 대한 유효한 값으로 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="64b3ab17aa40196bbbe2b14cd1e8633f165597c6" translate="yes" xml:space="preserve">
          <source>But in general, embedding projects will be more complicated than the above, and so the following allows general makefile support as well &amp;ndash; assuming GNU make because of the use of the &lt;strong&gt;shell&lt;/strong&gt; macro expansions. Additionally, though many times &lt;code&gt;julia-config.jl&lt;/code&gt; may be found in the directory &lt;code&gt;/usr/local&lt;/code&gt;, this is not necessarily the case, but Julia can be used to locate &lt;code&gt;julia-config.jl&lt;/code&gt; too, and the makefile can be used to take advantage of that. The above example is extended to use a Makefile:</source>
          <target state="translated">그러나 일반적으로 프로젝트 임베드는 위의 것보다 복잡하므로 다음은 &lt;strong&gt;쉘&lt;/strong&gt; 매크로 확장 의 사용으로 인해 GNU make를 가정 할 때 일반적인 makefile도 지원 합니다. 또한 여러 번 &lt;code&gt;julia-config.jl&lt;/code&gt; 이 &lt;code&gt;/usr/local&lt;/code&gt; 디렉토리에있을 수 있지만, 반드시 그런 것은 아니지만 Julia를 사용하여 &lt;code&gt;julia-config.jl&lt;/code&gt; 을 찾을 수 있으며 makefile을 사용하여 makefile을 사용할 수 있습니다. 그것의 장점. 위의 예는 Makefile을 사용하도록 확장되었습니다.</target>
        </trans-unit>
        <trans-unit id="26a3e909feee0f8ba5a7fedacb473c7c1f12eb3d" translate="yes" xml:space="preserve">
          <source>But now let's say you want to write a function that creates a 3&amp;times;3&amp;times;... array in arbitrary dimensions; you might be tempted to write a function</source>
          <target state="translated">그러나 이제 임의의 차원에서 3 &amp;times; 3 &amp;times; ... 배열을 만드는 함수를 작성한다고 가정 해 봅시다. 함수를 작성하고 싶을 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="7e347dfe55eb3d3f84185c35ba67fdd467b54efe" translate="yes" xml:space="preserve">
          <source>But there's an exception: future calls to &lt;code&gt;newfun&lt;/code&gt;&lt;em&gt;from the REPL&lt;/em&gt; work as expected, being able to both see and call the new definition of &lt;code&gt;newfun&lt;/code&gt;.</source>
          <target state="translated">그러나 예외 &lt;em&gt;는 REPL에서 &lt;/em&gt; &lt;code&gt;newfun&lt;/code&gt; 에&lt;em&gt;대한&lt;/em&gt; 향후 호출이 예상대로 작동하며 &lt;code&gt;newfun&lt;/code&gt; 의 새로운 정의를보고 호출 할 수 있다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="7dcbe9aaf1e0a6755fccfa933b76845ffa848937" translate="yes" xml:space="preserve">
          <source>But we are currently on the master thread. To check, we use the function &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.threadid&quot;&gt;&lt;code&gt;Threads.threadid&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">그러나 우리는 현재 마스터 스레드에 있습니다. 확인하려면 &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.threadid&quot;&gt; &lt;code&gt;Threads.threadid&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c84f932b434e9c92f4f20cc3eb7ea04021d4d339" translate="yes" xml:space="preserve">
          <source>By convention, function names ending with an exclamation point (&lt;code&gt;!&lt;/code&gt;) modify their arguments. Some functions have both modifying (e.g., &lt;code&gt;sort!&lt;/code&gt;) and non-modifying (&lt;code&gt;sort&lt;/code&gt;) versions.</source>
          <target state="translated">일반적으로 느낌표 ( &lt;code&gt;!&lt;/code&gt; )로 끝나는 함수 이름 은 인수를 수정합니다. 일부 함수에는 수정 (예 : &lt;code&gt;sort!&lt;/code&gt; ) 및 비 수정 ( &lt;code&gt;sort&lt;/code&gt; ) 버전이 모두 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2d3b6d57737895d1e4453b18b72e5f94ecdeb4e" translate="yes" xml:space="preserve">
          <source>By convention, functions that modify their arguments have a &lt;code&gt;!&lt;/code&gt; at the end of the name, for example &lt;code&gt;push!&lt;/code&gt;.</source>
          <target state="translated">일반적으로 인수를 수정하는 함수에는 &lt;code&gt;!&lt;/code&gt; 예를 들어 이름의 끝에 &lt;code&gt;push!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04a501bd6222e05849ace3fea85fb677e79bd185" translate="yes" xml:space="preserve">
          <source>By default a worker will listen on a free port at the address returned by a call to &lt;a href=&quot;../../stdlib/sockets/index#Sockets.getipaddr&quot;&gt;&lt;code&gt;getipaddr()&lt;/code&gt;&lt;/a&gt;. A specific address to listen on may be specified by optional argument &lt;code&gt;--bind-to bind_addr[:port]&lt;/code&gt;. This is useful for multi-homed hosts.</source>
          <target state="translated">기본적으로 작업자는 &lt;a href=&quot;../../stdlib/sockets/index#Sockets.getipaddr&quot;&gt; &lt;code&gt;getipaddr()&lt;/code&gt; &lt;/a&gt; 호출에 의해 리턴 된 주소에서 사용 가능한 포트를 청취합니다 . 수신 할 특정 주소는 선택적 인수 &lt;code&gt;--bind-to bind_addr[:port]&lt;/code&gt; 로 지정할 수 있습니다 . 멀티 홈 호스트에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="cb670232f9c9a08075052bf52fba2ffbf6b303ba" translate="yes" xml:space="preserve">
          <source>By default all exceptions are caught to prevent log message generation from crashing the program. This lets users confidently toggle little-used functionality - such as debug logging - in a production system.</source>
          <target state="translated">기본적으로 모든 예외는 로그 메시지 생성으로 인해 프로그램이 충돌하는 것을 방지합니다. 이를 통해 사용자는 프로덕션 시스템에서 디버그 로깅과 같은 거의 사용되지 않는 기능을 자신있게 토글 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d09501703ac8c23ae9a60cea7e5421daf3cd18b0" translate="yes" xml:space="preserve">
          <source>By default the &lt;code&gt;@testset&lt;/code&gt; macro will return the testset object itself, though this behavior can be customized in other testset types. If a &lt;code&gt;for&lt;/code&gt; loop is used then the macro collects and returns a list of the return values of the &lt;code&gt;finish&lt;/code&gt; method, which by default will return a list of the testset objects used in each iteration.</source>
          <target state="translated">&lt;code&gt;@testset&lt;/code&gt; 매크로는 기본적으로 테스트 세트 객체 자체를 반환하지만이 동작은 다른 테스트 세트 유형에서 사용자 지정할 수 있습니다. 경우 &lt;code&gt;for&lt;/code&gt; 루프가 다음 매크로를 수집을 사용하고의 반환 값의 목록을 반환 &lt;code&gt;finish&lt;/code&gt; 기본적으로 테스트 세트의 목록을 반환 방법, 각 반복에 사용되는 객체.</target>
        </trans-unit>
        <trans-unit id="62c321cdf328de0b934c0ed64ba600400a916f6d" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;pmap&lt;/code&gt; distributes the computation over all specified workers. To use only the local process and distribute over tasks, specify &lt;code&gt;distributed=false&lt;/code&gt;. This is equivalent to using &lt;a href=&quot;../../base/parallel/index#Base.asyncmap&quot;&gt;&lt;code&gt;asyncmap&lt;/code&gt;&lt;/a&gt;. For example, &lt;code&gt;pmap(f, c; distributed=false)&lt;/code&gt; is equivalent to &lt;code&gt;asyncmap(f,c; ntasks=()-&amp;gt;nworkers())&lt;/code&gt;</source>
          <target state="translated">기본적으로 &lt;code&gt;pmap&lt;/code&gt; 은 지정된 모든 작업자에게 계산을 분산시킵니다. 로컬 프로세스 만 사용하고 태스크를 분배하려면 &lt;code&gt;distributed=false&lt;/code&gt; 지정하십시오 . 이것은 &lt;a href=&quot;../../base/parallel/index#Base.asyncmap&quot;&gt; &lt;code&gt;asyncmap&lt;/code&gt; &lt;/a&gt; 을 사용하는 것과 같습니다 . 예를 들어, &lt;code&gt;pmap(f, c; distributed=false)&lt;/code&gt; 는 &lt;code&gt;asyncmap(f,c; ntasks=()-&amp;gt;nworkers())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f89fa8608376528e1d0c826b9825a253fbd041b" translate="yes" xml:space="preserve">
          <source>By default, Fortran compilers &lt;a href=&quot;https://en.wikipedia.org/wiki/Name_mangling#Fortran&quot;&gt;generate mangled names&lt;/a&gt; (for example, converting function names to lowercase or uppercase, often appending an underscore), and so to call a Fortran function via &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; you must pass the mangled identifier corresponding to the rule followed by your Fortran compiler. Also, when calling a Fortran function, all inputs must be passed as pointers to allocated values on the heap or stack. This applies not only to arrays and other mutable objects which are normally heap-allocated, but also to scalar values such as integers and floats which are normally stack-allocated and commonly passed in registers when using C or Julia calling conventions.</source>
          <target state="translated">기본적으로 포트란 컴파일러 &lt;a href=&quot;https://en.wikipedia.org/wiki/Name_mangling#Fortran&quot;&gt;는 맹 글링 된 이름&lt;/a&gt; (예 : 함수 이름을 소문자 또는 대문자로 변환하고 밑줄을 추가하는 경우)을 생성하므로 &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; 을 통해 포트란 함수를 호출 하려면 규칙에 해당하는 맹 글링 된 식별자를 전달해야합니다. . 또한 포트란 함수를 호출 할 때 모든 입력은 힙 또는 스택에서 할당 된 값에 대한 포인터로 전달되어야합니다. 이것은 일반적으로 힙 할당되는 배열 및 기타 가변 객체뿐만 아니라 C 또는 Julia 호출 규칙을 사용할 때 일반적으로 스택 할당되고 일반적으로 레지스터에 전달되는 정수 및 부동 소수점과 같은 스칼라 값에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="97954da2a37348f9b604be87e49342f9bb3f535a" translate="yes" xml:space="preserve">
          <source>By default, Julia returns &lt;code&gt;BitArrays&lt;/code&gt; from &lt;a href=&quot;../../manual/arrays/index#Broadcasting-1&quot;&gt;broadcasting&lt;/a&gt; operations that generate boolean elements (including dotted-comparisons like &lt;code&gt;.==&lt;/code&gt;) as well as from the functions &lt;a href=&quot;#Base.trues&quot;&gt;&lt;code&gt;trues&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.falses&quot;&gt;&lt;code&gt;falses&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본적으로 Julia는 &lt;a href=&quot;#Base.trues&quot;&gt; &lt;code&gt;trues&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#Base.falses&quot;&gt; &lt;code&gt;falses&lt;/code&gt; &lt;/a&gt; 함수뿐만 아니라 부울 요소 ( &lt;code&gt;.==&lt;/code&gt; 와 같은 점으로 구분 된 비교 포함)를 생성하는 &lt;a href=&quot;../../manual/arrays/index#Broadcasting-1&quot;&gt;브로드 캐스트&lt;/a&gt; 조작 에서 &lt;code&gt;BitArrays&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="b61e736cef16f73d649bec40a1cb5e23234e0fb3" translate="yes" xml:space="preserve">
          <source>By default, Julia starts up with a single thread of execution. This can be verified by using the command &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.nthreads&quot;&gt;&lt;code&gt;Threads.nthreads()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">기본적으로 Julia는 단일 실행 스레드로 시작합니다. &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.nthreads&quot;&gt; &lt;code&gt;Threads.nthreads()&lt;/code&gt; &lt;/a&gt; 명령을 사용하여 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a32e1e323d14dc3db4577d3f3c64972051fa6f1a" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;redisplay&lt;/code&gt; functions simply call &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display&lt;/code&gt;&lt;/a&gt;. However, some display backends may override &lt;code&gt;redisplay&lt;/code&gt; to modify an existing display of &lt;code&gt;x&lt;/code&gt; (if any). Using &lt;code&gt;redisplay&lt;/code&gt; is also a hint to the backend that &lt;code&gt;x&lt;/code&gt; may be redisplayed several times, and the backend may choose to defer the display until (for example) the next interactive prompt.</source>
          <target state="translated">기본적으로 &lt;code&gt;redisplay&lt;/code&gt; 기능은 단순히 &lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display&lt;/code&gt; &lt;/a&gt; 를 호출 합니다 . 그러나 일부 디스플레이 백엔드는 &lt;code&gt;x&lt;/code&gt; 의 기존 디스플레이 (있는 경우) 를 수정하기 위해 &lt;code&gt;redisplay&lt;/code&gt; 디스플레이를 재정의 할 수 있습니다 . &lt;code&gt;redisplay&lt;/code&gt; 사용 하는 것은 &lt;code&gt;x&lt;/code&gt; 가 여러 번 다시 표시 될 수 있다는 백엔드의 힌트 이며 백엔드는 다음 대화식 프롬프트가 나타날 때까지 표시를 연기하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2434a57ba6bd0a71b3ac08a278b454d4192e915f" translate="yes" xml:space="preserve">
          <source>By default, the eigenvalues and vectors are sorted lexicographically by &lt;code&gt;(real(&amp;lambda;),imag(&amp;lambda;))&lt;/code&gt;. A different comparison function &lt;code&gt;by(&amp;lambda;)&lt;/code&gt; can be passed to &lt;code&gt;sortby&lt;/code&gt;, or you can pass &lt;code&gt;sortby=nothing&lt;/code&gt; to leave the eigenvalues in an arbitrary order. Some special matrix types (e.g. &lt;code&gt;Diagonal&lt;/code&gt; or &lt;code&gt;SymTridiagonal&lt;/code&gt;) may implement their own sorting convention and not accept a &lt;code&gt;sortby&lt;/code&gt; keyword.</source>
          <target state="translated">기본적으로 고유 값과 벡터는 사전 순으로 &lt;code&gt;(real(&amp;lambda;),imag(&amp;lambda;))&lt;/code&gt; 로 정렬됩니다 . &lt;code&gt;by(&amp;lambda;)&lt;/code&gt; 다른 비교 함수 를 &lt;code&gt;sortby&lt;/code&gt; 로 전달 하거나 &lt;code&gt;sortby=nothing&lt;/code&gt; 을 전달 하여 고유 값을 임의의 순서로 남겨 둘 수 있습니다 . 일부 특수 행렬 유형 (예 : &lt;code&gt;Diagonal&lt;/code&gt; 또는 &lt;code&gt;SymTridiagonal&lt;/code&gt; )은 자체 정렬 규칙을 구현하고 &lt;code&gt;sortby&lt;/code&gt; 키워드를 허용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a1522d8655f0697d6a68319f9a29fb0897d5118" translate="yes" xml:space="preserve">
          <source>By default, the relative tolerance &lt;code&gt;rtol&lt;/code&gt; is &lt;code&gt;n*ϵ&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the size of the smallest dimension of &lt;code&gt;M&lt;/code&gt;, and &lt;code&gt;ϵ&lt;/code&gt; is the &lt;a href=&quot;../dates/index#Base.eps&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt; of the element type of &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">기본적으로 상대 공차 &lt;code&gt;rtol&lt;/code&gt; 은 &lt;code&gt;n*ϵ&lt;/code&gt; 이며, 여기서 &lt;code&gt;n&lt;/code&gt; 은 &lt;code&gt;M&lt;/code&gt; 의 가장 작은 치수의 크기 이고 &lt;code&gt;ϵ&lt;/code&gt; 는 &lt;code&gt;M&lt;/code&gt; 의 요소 유형의 &lt;a href=&quot;../dates/index#Base.eps&quot;&gt; &lt;code&gt;eps&lt;/code&gt; &lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="36562c471751aaedc6db712652b89541573e3bb4" translate="yes" xml:space="preserve">
          <source>By extension any odd number of backticks may be used to enclose a lesser number of backticks.</source>
          <target state="translated">확장하여, 적은 수의 백틱을 포함하기 위해 임의의 홀수의 백틱이 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="300c0d12698af77dc8e2c084d058d532e1315b6c" translate="yes" xml:space="preserve">
          <source>By printing the array, one can verify that the elements of &lt;code&gt;x&lt;/code&gt; are now reversed.</source>
          <target state="translated">배열을 인쇄하면 &lt;code&gt;x&lt;/code&gt; 의 요소가 반전 되었는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="760e88f232085bdc1aa9ba910e6eb19bee1e689b" translate="yes" xml:space="preserve">
          <source>By running &quot;infrequently&quot; there is very little performance overhead; while profiling, your code can run at nearly native speed.</source>
          <target state="translated">&quot;가끔&quot;실행하면 성능 오버 헤드가 거의 없습니다. 프로파일 링하는 동안 코드는 거의 기본 속도로 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f24780bfad6073c3cb5039801b32f126d34c1cde" translate="yes" xml:space="preserve">
          <source>Byte Array Literals</source>
          <target state="translated">바이트 배열 리터럴</target>
        </trans-unit>
        <trans-unit id="c950fe9e51a4a280dd4bb58c0d0951450fe7bbf3" translate="yes" xml:space="preserve">
          <source>C &lt;strong&gt;MUST NOT&lt;/strong&gt; modify the memory returned via &lt;code&gt;Ref{T}&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is an &lt;code&gt;isbits&lt;/code&gt; type</source>
          <target state="translated">C는 &lt;strong&gt;안&lt;/strong&gt; 통해 반환 된 메모리 수정 &lt;code&gt;Ref{T}&lt;/code&gt; 하면 &lt;code&gt;T&lt;/code&gt; 가 입니다 &lt;code&gt;isbits&lt;/code&gt; 의 유형</target>
        </trans-unit>
        <trans-unit id="a10776e7bb2378d8306c9c38209f9a25bdd03a13" translate="yes" xml:space="preserve">
          <source>C Bischof and C Van Loan, &quot;The WY representation for products of Householder matrices&quot;, SIAM J Sci Stat Comput 8 (1987), s2-s13. &lt;a href=&quot;https://doi.org/10.1137/0908009&quot;&gt;doi:10.1137/0908009&lt;/a&gt;</source>
          <target state="translated">C Bischof 및 C Van Loan, &quot;가계 매트릭스 제품의 WY 표현&quot;, SIAM J Sci Stat Comput 8 (1987), s2-s13. &lt;a href=&quot;https://doi.org/10.1137/0908009&quot;&gt;도 : 10.1137 / 0908009&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e9a1acddb6f4bd40edd805612e996267e826e064" translate="yes" xml:space="preserve">
          <source>C Interface</source>
          <target state="translated">C 인터페이스</target>
        </trans-unit>
        <trans-unit id="6592ddb6b4a1a593e3571fb32f8e7a37a9f3a350" translate="yes" xml:space="preserve">
          <source>C Standard Library</source>
          <target state="translated">C 표준 라이브러리</target>
        </trans-unit>
        <trans-unit id="94e127f5f8d00244c8e1c9f0ff88de5ec4ac1783" translate="yes" xml:space="preserve">
          <source>C function pointer for &lt;code&gt;credentials_callback&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;credentials_callback&lt;/code&gt; 에 대한 C 함수 포인터</target>
        </trans-unit>
        <trans-unit id="c33ee7fd9016392ef47ce064a1a8200fb287dc56" translate="yes" xml:space="preserve">
          <source>C function pointer for &lt;code&gt;fetchhead_foreach_callback&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;fetchhead_foreach_callback&lt;/code&gt; 에 대한 C 함수 포인터</target>
        </trans-unit>
        <trans-unit id="bf80fd7e58e3463df2196d9d8b7daa3fb24795de" translate="yes" xml:space="preserve">
          <source>C function pointer for &lt;code&gt;mirror_callback&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mirror_callback&lt;/code&gt; 에 대한 C 함수 포인터</target>
        </trans-unit>
        <trans-unit id="5cb63f576281637ef8721a44852ed39bd47bda3e" translate="yes" xml:space="preserve">
          <source>C functions that take an argument of the type &lt;code&gt;char**&lt;/code&gt; can be called by using a &lt;code&gt;Ptr{Ptr{UInt8}}&lt;/code&gt; type within Julia. For example, C functions of the form:</source>
          <target state="translated">&lt;code&gt;char**&lt;/code&gt; 유형의 인수를 사용하는 C 함수는 Julia 내에서 &lt;code&gt;Ptr{Ptr{UInt8}}&lt;/code&gt; 유형 을 사용하여 호출 할 수 있습니다 . 예를 들어, 다음 형식의 C 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="272eaa6fb30cbc6d678d9c3342e07f66e1c123e0" translate="yes" xml:space="preserve">
          <source>C name</source>
          <target state="translated">C 이름</target>
        </trans-unit>
        <trans-unit id="fc2b4216164cfb01ac45112054b3fedda8b56c86" translate="yes" xml:space="preserve">
          <source>C++</source>
          <target state="translated">C++</target>
        </trans-unit>
        <trans-unit id="7877de4c10096f42fa8b542b38a0c8abfeff2993" translate="yes" xml:space="preserve">
          <source>CFunction</source>
          <target state="translated">CFunction</target>
        </trans-unit>
        <trans-unit id="d6deb7587f97d7c2e002671a4a7ec9c17092aa98" translate="yes" xml:space="preserve">
          <source>CRC32c</source>
          <target state="translated">CRC32c</target>
        </trans-unit>
        <trans-unit id="946e46ea933373d5acfe718ba4c46ff0c631d8da" translate="yes" xml:space="preserve">
          <source>C_NULL</source>
          <target state="translated">C_NULL</target>
        </trans-unit>
        <trans-unit id="062c01810c7f050347900909c2a5c905fb7f6b61" translate="yes" xml:space="preserve">
          <source>Caches credential information for re-use</source>
          <target state="translated">재사용을 위해 신임 정보를 캐시합니다.</target>
        </trans-unit>
        <trans-unit id="9f296c645c05d20e8d397ba3c6535ccc69ae356d" translate="yes" xml:space="preserve">
          <source>Caching of native pointers.</source>
          <target state="translated">기본 포인터 캐싱.</target>
        </trans-unit>
        <trans-unit id="ffbcb973995142c82bf466dc886625f88d2fbcf8" translate="yes" xml:space="preserve">
          <source>Cactus</source>
          <target state="translated">Cactus</target>
        </trans-unit>
        <trans-unit id="ac32f232b7ff982020ec20b1d05cbfe41644842d" translate="yes" xml:space="preserve">
          <source>Calculate the matrix-matrix product $AB$, overwriting &lt;code&gt;A&lt;/code&gt;, and return the result.</source>
          <target state="translated">행렬 행렬 곱 $ AB $를 계산하고 &lt;code&gt;A&lt;/code&gt; 를 덮어 쓰고 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4d41dc1e33975c5f259e3c41e3a555f7d4e2007c" translate="yes" xml:space="preserve">
          <source>Calculate the matrix-matrix product $AB$, overwriting &lt;code&gt;B&lt;/code&gt;, and return the result.</source>
          <target state="translated">행렬 행렬 곱 $ AB $를 계산하고 &lt;code&gt;B&lt;/code&gt; 를 덮어 쓰고 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1c95fa1680ff9d2f9d27d1192e3762d37dafb02b" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;-x&lt;/code&gt;, checking for overflow errors where applicable. For example, standard two's complement signed integers (e.g. &lt;code&gt;Int&lt;/code&gt;) cannot represent &lt;code&gt;-typemin(Int)&lt;/code&gt;, thus leading to an overflow.</source>
          <target state="translated">해당되는 경우 오버플로 오류를 확인하여 &lt;code&gt;-x&lt;/code&gt; 를 계산합니다 . 예를 들어 표준 2의 보수 부호있는 정수 (예 : &lt;code&gt;Int&lt;/code&gt; )는 &lt;code&gt;-typemin(Int)&lt;/code&gt; 나타낼 수 없으므로 오버플로가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6167c036f7bc22425fe096ac27be440fe0ac62c7" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;abs(x)&lt;/code&gt;, checking for overflow errors where applicable. For example, standard two's complement signed integers (e.g. &lt;code&gt;Int&lt;/code&gt;) cannot represent &lt;code&gt;abs(typemin(Int))&lt;/code&gt;, thus leading to an overflow.</source>
          <target state="translated">해당하는 경우 오버플로 오류를 확인하여 &lt;code&gt;abs(x)&lt;/code&gt; 계산 합니다. 예를 들어 표준 2의 보수 부호있는 정수 (예 : &lt;code&gt;Int&lt;/code&gt; )는 &lt;code&gt;abs(typemin(Int))&lt;/code&gt; 나타낼 수 없으므로 오버플로가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="28790cf90cf177147936302a9d1094b853b086f9" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;cld(x,y)&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">해당되는 경우 오버플로 오류를 확인하여 &lt;code&gt;cld(x,y)&lt;/code&gt; 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="4c05dcdfe5d48ed5364bba76a8d88216a7900800" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;div(x,y)&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">해당되는 경우 오버플로 오류를 확인하여 &lt;code&gt;div(x,y)&lt;/code&gt; 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="a3d2d9753cdcfd6dd922be36bbcacaaf32453196" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;fld(x,y)&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">해당되는 경우 오버플로 오류를 확인하여 &lt;code&gt;fld(x,y)&lt;/code&gt; 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="2c843612cbe327e35009726e8d036ba9b466e318" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;mod(x,y)&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">해당되는 경우 오버플로 오류를 확인하여 &lt;code&gt;mod(x,y)&lt;/code&gt; 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="3ff6965bc32424b3a4e9ae967a2b78b31c8687be" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;r = x*y&lt;/code&gt;, with the flag &lt;code&gt;f&lt;/code&gt; indicating whether overflow has occurred.</source>
          <target state="translated">오버플로가 발생했는지 여부를 나타내는 플래그 &lt;code&gt;f&lt;/code&gt; 를 사용하여 &lt;code&gt;r = x*y&lt;/code&gt; 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="31af4e89c705ea1b47696c4b34bfb97a778c9f15" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;r = x+y&lt;/code&gt;, with the flag &lt;code&gt;f&lt;/code&gt; indicating whether overflow has occurred.</source>
          <target state="translated">오버플로가 발생했는지 여부를 나타내는 플래그 &lt;code&gt;f&lt;/code&gt; 를 사용하여 &lt;code&gt;r = x+y&lt;/code&gt; 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="fd998eb3f6f3e0335eab6ff45b9ad97358dd0ca0" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;r = x-y&lt;/code&gt;, with the flag &lt;code&gt;f&lt;/code&gt; indicating whether overflow has occurred.</source>
          <target state="translated">오버플로가 발생했는지 여부를 나타내는 플래그 &lt;code&gt;f&lt;/code&gt; 를 사용하여 &lt;code&gt;r = x-y&lt;/code&gt; 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="efdf3f45f374c38b59fd728eaad712d7890f84ff" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;x%y&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">해당되는 경우 오버플로 오류를 확인하여 &lt;code&gt;x%y&lt;/code&gt; 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="08676bba541f171d54d453c583476f048c4309ad" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;x*y&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">해당되는 경우 오버플로 오류를 확인하여 &lt;code&gt;x*y&lt;/code&gt; 를 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="dd10e9d48c83e327a775e0dc3fbaa5b8a6d8c773" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;x+y&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">해당되는 경우 오버플로 오류를 확인하여 &lt;code&gt;x+y&lt;/code&gt; 를 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="7bc22057d7126532dbb6ba4068b470e14e78325a" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;x-y&lt;/code&gt;, checking for overflow errors where applicable.</source>
          <target state="translated">해당되는 경우 오버플로 오류를 확인하여 &lt;code&gt;x-y&lt;/code&gt; 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="aba6566e0673d1e53c249760fa025027d921398e" translate="yes" xml:space="preserve">
          <source>Calculates the matrix-matrix or matrix-vector product $AB$ and stores the result in &lt;code&gt;Y&lt;/code&gt;, overwriting the existing value of &lt;code&gt;Y&lt;/code&gt;. Note that &lt;code&gt;Y&lt;/code&gt; must not be aliased with either &lt;code&gt;A&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">행렬의 행렬 또는 벡터 행렬 AB 제품 $ $ 저장 결과를 계산 &lt;code&gt;Y&lt;/code&gt; 의 기존 값 겹쳐 &lt;code&gt;Y&lt;/code&gt; 를 . 참고 &lt;code&gt;Y&lt;/code&gt; 가 하나에 별명해서는 안 또는 &lt;code&gt;B&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="adab5090ac6a1b7b5420faac7be86c41721ba27c" translate="yes" xml:space="preserve">
          <source>Calendar</source>
          <target state="translated">Calendar</target>
        </trans-unit>
        <trans-unit id="4ba307e0d2e402f172b3a88156165205934537c5" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;calloc&lt;/code&gt; from the C standard library.</source>
          <target state="translated">C 표준 라이브러리에서 &lt;code&gt;calloc&lt;/code&gt; 을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="4bd40525129514b0914afc63feb30f354e65a4d9" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;free&lt;/code&gt; from the C standard library. Only use this on memory obtained from &lt;code&gt;malloc&lt;/code&gt;, not on pointers retrieved from other C libraries. &lt;code&gt;Ptr&lt;/code&gt; objects obtained from C libraries should be freed by the free functions defined in that library, to avoid assertion failures if multiple &lt;code&gt;libc&lt;/code&gt; libraries exist on the system.</source>
          <target state="translated">C 표준 라이브러리에서 &lt;code&gt;free&lt;/code&gt; 로 전화하십시오 . 다른 C 라이브러리에서 검색 한 포인터가 아니라 &lt;code&gt;malloc&lt;/code&gt; 에서 얻은 메모리에서만 이것을 사용하십시오 . 시스템에 여러 &lt;code&gt;libc&lt;/code&gt; 라이브러리가있는 경우 어설 션 오류를 피하려면 C 라이브러리에서 얻은 &lt;code&gt;Ptr&lt;/code&gt; 오브젝트를 해당 라이브러리에 정의 된 자유 함수로 해제해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9203b7a42060148350d2e8b3d4cff8d77d5adeaf" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;malloc&lt;/code&gt; from the C standard library.</source>
          <target state="translated">C 표준 라이브러리에서 &lt;code&gt;malloc&lt;/code&gt; 을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="d59c9f90d0e1176d4cad8b98ecd8773005b655fb" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;realloc&lt;/code&gt; from the C standard library.</source>
          <target state="translated">C 표준 라이브러리에서 &lt;code&gt;realloc&lt;/code&gt; 을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="04826291b163107f55d0704047219ec8c7242923" translate="yes" xml:space="preserve">
          <source>Call C functions directly (no wrappers or special APIs needed)</source>
          <target state="translated">C 함수를 직접 호출 (래퍼 또는 특수 API 필요 없음)</target>
        </trans-unit>
        <trans-unit id="176405e1dde8747bb226b06f36937d8d5df0ebaf" translate="yes" xml:space="preserve">
          <source>Call LLVM IR string in the first argument. Similar to an LLVM function &lt;code&gt;define&lt;/code&gt; block, arguments are available as consecutive unnamed SSA variables (%0, %1, etc.).</source>
          <target state="translated">첫 번째 인수에서 LLVM IR 문자열을 호출하십시오. LLVM 함수 &lt;code&gt;define&lt;/code&gt; 블록과 유사하게 인수는 이름없는 연속적인 SSA 변수 (% 0, % 1 등)로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="801735440ba4554b8dcf3670b61d4a15d05b05d1" translate="yes" xml:space="preserve">
          <source>Call a function &lt;code&gt;f&lt;/code&gt; asynchronously on the given arguments on the specified process. Return a &lt;a href=&quot;#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;. Keyword arguments, if any, are passed through to &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">지정된 프로세스에서 주어진 인수에 대해 함수 &lt;code&gt;f&lt;/code&gt; 를 비동기 적으로 호출합니다 . &lt;a href=&quot;#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 돌려 줍니다. 키워드 인수가 있으면 &lt;code&gt;f&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="04a025fbe4a998cb1c2319eebb3e04b735a78fa3" translate="yes" xml:space="preserve">
          <source>Call a function in a C-exported shared library, specified by the tuple &lt;code&gt;(function_name, library)&lt;/code&gt;, where each component is either a string or symbol. Instead of specifying a library, one can also use a &lt;code&gt;function_name&lt;/code&gt; symbol or string, which is resolved in the current process. Alternatively, &lt;code&gt;ccall&lt;/code&gt; may also be used to call a function pointer &lt;code&gt;function_pointer&lt;/code&gt;, such as one returned by &lt;code&gt;dlsym&lt;/code&gt;.</source>
          <target state="translated">튜플 &lt;code&gt;(function_name, library)&lt;/code&gt; 지정된 C 내보내기 공유 라이브러리에서 함수를 호출하십시오. 여기서 각 구성 요소는 문자열 또는 기호입니다. 라이브러리를 지정하는 대신 현재 프로세스에서 해결되는 &lt;code&gt;function_name&lt;/code&gt; 기호 또는 문자열을 사용할 수도 있습니다 . 또는 &lt;code&gt;ccall&lt;/code&gt; 을 사용하여 &lt;code&gt;dlsym&lt;/code&gt; 에 의해 리턴 된 함수 포인터 &lt;code&gt;function_pointer&lt;/code&gt; 를 호출 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d59f24dd0afcb729960eb267538b17e7042fcc85" translate="yes" xml:space="preserve">
          <source>Call function &lt;code&gt;f&lt;/code&gt; on each element of iterable &lt;code&gt;c&lt;/code&gt;. For multiple iterable arguments, &lt;code&gt;f&lt;/code&gt; is called elementwise. &lt;code&gt;foreach&lt;/code&gt; should be used instead of &lt;code&gt;map&lt;/code&gt; when the results of &lt;code&gt;f&lt;/code&gt; are not needed, for example in &lt;code&gt;foreach(println, array)&lt;/code&gt;.</source>
          <target state="translated">반복 가능한 &lt;code&gt;c&lt;/code&gt; 의 각 요소에서 함수 &lt;code&gt;f&lt;/code&gt; 를 호출하십시오 . 반복 가능한 여러 인수의 경우 &lt;code&gt;f&lt;/code&gt; 를 요소 단위라고합니다. &lt;code&gt;foreach&lt;/code&gt; 는이 대신 사용되어야 &lt;code&gt;map&lt;/code&gt; 결과 때 &lt;code&gt;f&lt;/code&gt; 필요하지 않은, 예를 들어, &lt;code&gt;foreach(println, array)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebb83c3d13bcfdfda803f0b35d77b6d7243cd9fe" translate="yes" xml:space="preserve">
          <source>Call the Win32 &lt;code&gt;GetLastError&lt;/code&gt; function [only available on Windows].</source>
          <target state="translated">Win32 &lt;code&gt;GetLastError&lt;/code&gt; 함수를 호출하십시오 ( Windows에서만 사용 가능).</target>
        </trans-unit>
        <trans-unit id="ce4eab5c7f440edfe5b683c8baa8b023cc553366" translate="yes" xml:space="preserve">
          <source>Call the function &lt;code&gt;body&lt;/code&gt; with a modified task-local storage, in which &lt;code&gt;value&lt;/code&gt; is assigned to &lt;code&gt;key&lt;/code&gt;; the previous value of &lt;code&gt;key&lt;/code&gt;, or lack thereof, is restored afterwards. Useful for emulating dynamic scoping.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 이 할당 된 수정 된 태스크 로컬 스토리지를 사용 하여 함수 &lt;code&gt;body&lt;/code&gt; 을 호출하십시오 . &lt;code&gt;key&lt;/code&gt; 의 이전 값 또는 그 부족은 나중에 복원됩니다. 동적 범위를 모방하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="eaa0c352f0575f82994206173cabc3866ad95796" translate="yes" xml:space="preserve">
          <source>Call the given function with an I/O stream and the supplied extra arguments. Everything written to this I/O stream is returned as a string. &lt;code&gt;context&lt;/code&gt; can be either an &lt;a href=&quot;#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; whose properties will be used, or a &lt;code&gt;Pair&lt;/code&gt; specifying a property and its value. &lt;code&gt;sizehint&lt;/code&gt; suggests the capacity of the buffer (in bytes).</source>
          <target state="translated">I / O 스트림과 제공된 추가 인수를 사용하여 지정된 함수를 호출하십시오. 이 I / O 스트림에 쓰여진 모든 것은 문자열로 반환됩니다. &lt;code&gt;context&lt;/code&gt; 는 속성이 사용될 &lt;a href=&quot;#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt; 이거나 속성과 해당 값을 지정하는 &lt;code&gt;Pair&lt;/code&gt; 일 수 있습니다 . &lt;code&gt;sizehint&lt;/code&gt; 는 버퍼 용량 (바이트)을 제안합니다.</target>
        </trans-unit>
        <trans-unit id="2664dee6a3ad5a12623406c5af1cda40ecf12ba0" translate="yes" xml:space="preserve">
          <source>Callback settings. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_remote_callbacks&quot;&gt;&lt;code&gt;git_remote_callbacks&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">콜백 설정. &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_remote_callbacks&quot;&gt; &lt;code&gt;git_remote_callbacks&lt;/code&gt; &lt;/a&gt; 구조체와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="c8256faf5b345c67f126415204dbd66a186005c2" translate="yes" xml:space="preserve">
          <source>Called by cluster managers implementing custom transports. It initializes a newly launched process as a worker. Command line argument &lt;code&gt;--worker[=&amp;lt;cookie&amp;gt;]&lt;/code&gt; has the effect of initializing a process as a worker using TCP/IP sockets for transport. &lt;code&gt;cookie&lt;/code&gt; is a &lt;a href=&quot;#Distributed.cluster_cookie-Tuple%7B%7D&quot;&gt;&lt;code&gt;cluster_cookie&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용자 지정 전송을 구현하는 클러스터 관리자가 호출합니다. 새로 시작된 프로세스를 작업자로 초기화합니다. 명령 행 인수 &lt;code&gt;--worker[=&amp;lt;cookie&amp;gt;]&lt;/code&gt; 는 전송에 TCP / IP 소켓을 사용하여 작업자로서 프로세스를 초기화하는 효과가 있습니다. &lt;code&gt;cookie&lt;/code&gt; 는 &lt;a href=&quot;#Distributed.cluster_cookie-Tuple%7B%7D&quot;&gt; &lt;code&gt;cluster_cookie&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="caea39a5ffed5cf53b4f9992aa9aebdfdb841ef9" translate="yes" xml:space="preserve">
          <source>Called by cluster managers using custom transports. It should be called when the custom transport implementation receives the first message from a remote worker. The custom transport must manage a logical connection to the remote worker and provide two &lt;code&gt;IO&lt;/code&gt; objects, one for incoming messages and the other for messages addressed to the remote worker. If &lt;code&gt;incoming&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the remote peer initiated the connection. Whichever of the pair initiates the connection sends the cluster cookie and its Julia version number to perform the authentication handshake.</source>
          <target state="translated">사용자 지정 전송을 사용하여 클러스터 관리자가 호출합니다. 사용자 정의 전송 구현이 원격 작업자로부터 첫 번째 메시지를 수신 할 때 호출되어야합니다. 사용자 지정 전송은 원격 작업자에 대한 논리적 연결을 관리하고 하나는 들어오는 메시지와 다른 하나는 원격 작업자로 주소 지정된 메시지에 대한 두 개의 &lt;code&gt;IO&lt;/code&gt; 개체를 제공 해야합니다. 경우 &lt;code&gt;incoming&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; , 원격 피어가 연결을 시작했다. 쌍을 시작하면 연결이 클러스터 쿠키와 해당 Julia 버전 번호를 전송하여 인증 핸드 셰이크를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="66dd1be7576a64af07b2ce99b1a2ed2a7c06b791" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;#Core.Ref&quot;&gt;&lt;code&gt;Ref(array[, index])&lt;/code&gt;&lt;/a&gt; is generally preferable to this function as it guarantees validity.</source>
          <target state="translated">&lt;a href=&quot;#Core.Ref&quot;&gt; &lt;code&gt;Ref(array[, index])&lt;/code&gt; &lt;/a&gt; 호출 은 일반적으로 유효성을 보장하므로이 함수보다 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="0d16198678162c2927c2f17ed3e602251edd7089" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; inside a macro is a particularly dangerous warning sign; it means the macro will only work when called at the top level. If such a macro is written as a function instead, it will naturally have access to the run-time values it needs.</source>
          <target state="translated">매크로 안에서 &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; 을&lt;/a&gt; 호출 하는 것은 특히 위험한 경고 신호입니다. 매크로가 최상위 수준에서 호출 될 때만 작동한다는 것을 의미합니다. 이러한 매크로가 대신 함수로 작성되면 필요한 런타임 값에 자연스럽게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b72748e09098c6bd97f55e59c563c3a122bb6331" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; to cause a side-effect in another module. This will also cause a warning to be emitted when the incremental precompile flag is set.</source>
          <target state="translated">다른 모듈에서 부작용을 일으키기 위해 &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; 을 호출 합니다. 또한 증분 프리 컴파일 플래그가 설정 될 때 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="41aa7e1fcfd92670fa5a846085d3341583baabcf" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace()&lt;/code&gt;&lt;/a&gt; returns a vector of &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackFrame&quot;&gt;&lt;code&gt;StackTraces.StackFrame&lt;/code&gt;&lt;/a&gt; s. For ease of use, the alias &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackTrace&quot;&gt;&lt;code&gt;StackTraces.StackTrace&lt;/code&gt;&lt;/a&gt; can be used in place of &lt;code&gt;Vector{StackFrame}&lt;/code&gt;. (Examples with &lt;code&gt;[...]&lt;/code&gt; indicate that output may vary depending on how the code is run.)</source>
          <target state="translated">&lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace()&lt;/code&gt; &lt;/a&gt; 호출 하면 &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackFrame&quot;&gt; &lt;code&gt;StackTraces.StackFrame&lt;/code&gt; &lt;/a&gt; 의 벡터가 반환 됩니다. 사용하기 쉽도록 &lt;code&gt;Vector{StackFrame}&lt;/code&gt; 대신 &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackTrace&quot;&gt; &lt;code&gt;StackTraces.StackTrace&lt;/code&gt; &lt;/a&gt; 라는 별칭을 사용할 수 있습니다 . ( &lt;code&gt;[...]&lt;/code&gt; 로 표시된 예 는 코드 실행 방법에 따라 출력이 달라질 수 있음을 나타냅니다.)</target>
        </trans-unit>
        <trans-unit id="4a4f549c9307f9b4d84be21408b77dbb68a1f198" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;rand&lt;/code&gt; and other RNG-related functions should be avoided in doctests since they will not produce consistent outputs during different Julia sessions. If you would like to show some random number generation related functionality, one option is to explicitly construct and seed your own &lt;a href=&quot;../../stdlib/random/index#Random.MersenneTwister&quot;&gt;&lt;code&gt;MersenneTwister&lt;/code&gt;&lt;/a&gt; (or other pseudorandom number generator) and pass it to the functions you are doctesting.</source>
          <target state="translated">호출 &lt;code&gt;rand&lt;/code&gt; 서로 다른 줄리아 세션 동안 일관성있는 출력을 생성하지 않으므로 다른 RNG 관련 기능은 doctest를 피해야한다. 임의의 난수 생성 관련 기능을 표시하려는 경우 한 가지 옵션은 자신의 &lt;a href=&quot;../../stdlib/random/index#Random.MersenneTwister&quot;&gt; &lt;code&gt;MersenneTwister&lt;/code&gt; &lt;/a&gt; (또는 다른 의사 난수 생성기) 를 명시 적으로 구성하고 시드하여 문서화중인 함수에 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2d7425b9bc6bdd37cfb5d8f6425582078c2424c2" translate="yes" xml:space="preserve">
          <source>Calling C and Fortran Code</source>
          <target state="translated">C와 포트란 코드 호출</target>
        </trans-unit>
        <trans-unit id="0a72734e5b9d7e776161f32d3bf09af339418e1e" translate="yes" xml:space="preserve">
          <source>Calling Convention</source>
          <target state="translated">전화 컨벤션</target>
        </trans-unit>
        <trans-unit id="9abfa6ddb5caaadbeab0376e3006f230505bfdea" translate="yes" xml:space="preserve">
          <source>Calling Julia Functions</source>
          <target state="translated">Julia 함수 호출</target>
        </trans-unit>
        <trans-unit id="e49d09ca1110825e69afa568f7e07eeec5300e61" translate="yes" xml:space="preserve">
          <source>Calling any function that is defined after the body of the generated function. This condition is relaxed for incrementally-loaded precompiled modules to allow calling any function in the module.</source>
          <target state="translated">생성 된 함수의 본문 다음에 정의 된 함수를 호출합니다. 이 조건은 증분로드 된 사전 컴파일 된 모듈에서 완화되어 모듈의 모든 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41d74c50b2c67c3ddc7b0e22937873f076e4b22e" translate="yes" xml:space="preserve">
          <source>Calling this function is the &quot;safe&quot; way to write algorithms that exploit linear indexing.</source>
          <target state="translated">이 함수를 호출하는 것은 선형 인덱싱을 이용하는 알고리즘을 작성하는 &quot;안전한&quot;방법입니다.</target>
        </trans-unit>
        <trans-unit id="0a19b7e26b2ba75ac27255f31f21e98a34d62953" translate="yes" xml:space="preserve">
          <source>Calls</source>
          <target state="translated">Calls</target>
        </trans-unit>
        <trans-unit id="19d45b5117925d478df6d24e3b83936bcd7c78e0" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;f(args...; kwargs...)&lt;/code&gt;, but guarantees that the most recent method of &lt;code&gt;f&lt;/code&gt; will be executed. This is useful in specialized circumstances, e.g. long-running event loops or callback functions that may call obsolete versions of a function &lt;code&gt;f&lt;/code&gt;. (The drawback is that &lt;code&gt;invokelatest&lt;/code&gt; is somewhat slower than calling &lt;code&gt;f&lt;/code&gt; directly, and the type of the result cannot be inferred by the compiler.)</source>
          <target state="translated">&lt;code&gt;f(args...; kwargs...)&lt;/code&gt; 호출 하지만 가장 최근 &lt;code&gt;f&lt;/code&gt; 메소드 가 실행되도록합니다. 이는 오래된 버전의 함수 &lt;code&gt;f&lt;/code&gt; 를 호출 할 수있는 장기 실행 이벤트 루프 또는 콜백 함수와 같은 특수한 환경에서 유용합니다 . 단점은 &lt;code&gt;invokelatest&lt;/code&gt; 가 &lt;code&gt;f&lt;/code&gt; 를 직접 호출하는 것보다 다소 느리고 결과 유형이 컴파일러에 의해 유추 될 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4da9c9af9631e294961d5a16fdc681ca3d84f508" translate="yes" xml:space="preserve">
          <source>Camera</source>
          <target state="translated">Camera</target>
        </trans-unit>
        <trans-unit id="f01f585ee537bca9460fb6cd89d91523ae410c34" translate="yes" xml:space="preserve">
          <source>Can I use &lt;code&gt;using&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt; inside a function?</source>
          <target state="translated">함수 내에서 &lt;code&gt;using&lt;/code&gt; 하거나 &lt;code&gt;import&lt;/code&gt; 수 있습니까 ?</target>
        </trans-unit>
        <trans-unit id="07d6cb97820e052be2b530d0dd83bba8edfc5e64" translate="yes" xml:space="preserve">
          <source>Cancer</source>
          <target state="translated">Cancer</target>
        </trans-unit>
        <trans-unit id="dbffdf1f157a14a19d2c2aeb64068a16056948d8" translate="yes" xml:space="preserve">
          <source>Candy</source>
          <target state="translated">Candy</target>
        </trans-unit>
        <trans-unit id="f20a12fff18e89250e7a4fc78447ee7170895a65" translate="yes" xml:space="preserve">
          <source>Cannot exactly convert &lt;code&gt;val&lt;/code&gt; to type &lt;code&gt;T&lt;/code&gt; in a method of function &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">함수 &lt;code&gt;name&lt;/code&gt; 의 메소드에서 &lt;code&gt;val&lt;/code&gt; 을 유형 &lt;code&gt;T&lt;/code&gt; 로 정확하게 변환 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="91fe73e52f951e9f466713424d00ece47cdc7524" translate="yes" xml:space="preserve">
          <source>Canonicalize a path by expanding symbolic links and removing &quot;.&quot; and &quot;..&quot; entries. On case-insensitive case-preserving filesystems (typically Mac and Windows), the filesystem's stored case for the path is returned.</source>
          <target state="translated">심볼릭 링크를 확장하고 &quot;.&quot;를 제거하여 경로를 표준화하십시오. 및 &quot;..&quot;항목. 대소 문자를 구분하지 않는 대소 문자를 유지하는 파일 시스템 (일반적으로 Mac 및 Windows)에서 파일 시스템의 경로에 대해 저장된 대소 문자가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="90a16c05e849a5af3a6ddd19c2db0fa10e54dd2d" translate="yes" xml:space="preserve">
          <source>Capitalize the first character of each word in &lt;code&gt;s&lt;/code&gt;; if &lt;code&gt;strict&lt;/code&gt; is true, every other character is converted to lowercase, otherwise they are left unchanged. By default, all non-letters are considered as word separators; a predicate can be passed as the &lt;code&gt;wordsep&lt;/code&gt; keyword to determine which characters should be considered as word separators. See also &lt;a href=&quot;#Base.Unicode.uppercasefirst&quot;&gt;&lt;code&gt;uppercasefirst&lt;/code&gt;&lt;/a&gt; to capitalize only the first character in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 에서 각 단어의 첫 문자를 대문자로 사용하십시오 . 경우 &lt;code&gt;strict&lt;/code&gt; 사실이다, 다른 모든 문자는 그렇지 않으면 변경되지 않고 남아 있습니다, 소문자로 변환됩니다. 기본적으로 모든 비 레터는 단어 구분자로 간주됩니다. 술어를 &lt;code&gt;wordsep&lt;/code&gt; 키워드로 전달 하여 단어 분리 자로 간주 할 문자를 결정할 수 있습니다. &lt;code&gt;s&lt;/code&gt; 의 첫 문자 만 &lt;a href=&quot;#Base.Unicode.uppercasefirst&quot;&gt; &lt;code&gt;uppercasefirst&lt;/code&gt; &lt;/a&gt; 하려면 대문자 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c9bf29452874274eefd7cb3833b9f64b68215e7a" translate="yes" xml:space="preserve">
          <source>Capricorn</source>
          <target state="translated">Capricorn</target>
        </trans-unit>
        <trans-unit id="7a60d3a75036d27b63be0e55a67bb26ec4e25de4" translate="yes" xml:space="preserve">
          <source>Captures can also be accessed by indexing the &lt;code&gt;RegexMatch&lt;/code&gt; object with the number or name of the capture group:</source>
          <target state="translated">캡처 그룹의 번호 또는 이름으로 &lt;code&gt;RegexMatch&lt;/code&gt; 개체를 색인화하여 캡처에 액세스 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88b6c532d029fa2352cf701d32470679db245f1e" translate="yes" xml:space="preserve">
          <source>Captures can be referenced in a substitution string when using &lt;code&gt;replace&lt;/code&gt; by using &lt;code&gt;\n&lt;/code&gt; to refer to the nth capture group and prefixing the substitution string with &lt;code&gt;s&lt;/code&gt;. Capture group 0 refers to the entire match object. Named capture groups can be referenced in the substitution with &lt;code&gt;\g&amp;lt;groupname&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;\n&lt;/code&gt; 을 사용하여 n 번째 캡처 그룹을 참조하고 대체 문자열 앞에 &lt;code&gt;s&lt;/code&gt; 를 붙여서 &lt;code&gt;replace&lt;/code&gt; 를 사용할 때 대체 문자열에서 캡처를 참조 할 수 있습니다 . 캡처 그룹 0은 전체 일치 오브젝트를 나타냅니다. 명명 된 캡처 그룹은 &lt;code&gt;\g&amp;lt;groupname&amp;gt;&lt;/code&gt; 대체하여 참조 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f2a9f7332f7a09946296f88c18131b92dbb1279f" translate="yes" xml:space="preserve">
          <source>Card Index</source>
          <target state="translated">카드 인덱스</target>
        </trans-unit>
        <trans-unit id="0cca55f8e3afeb49c40b1e95517a9c1135c7a560" translate="yes" xml:space="preserve">
          <source>Carousel Horse</source>
          <target state="translated">회전 목마</target>
        </trans-unit>
        <trans-unit id="255e5aac2127bb14392d1d0c859050548a802598" translate="yes" xml:space="preserve">
          <source>Carp Streamer</source>
          <target state="translated">잉어 깃발</target>
        </trans-unit>
        <trans-unit id="722d5852eba2640d07e63d26f677b7d3dce6d40c" translate="yes" xml:space="preserve">
          <source>Cartesian indexing</source>
          <target state="translated">데카르트 인덱싱</target>
        </trans-unit>
        <trans-unit id="2a2b1fd0558d005d15bb6a090f84de302c0d4517" translate="yes" xml:space="preserve">
          <source>Cartesian indices</source>
          <target state="translated">데카르트 인덱스</target>
        </trans-unit>
        <trans-unit id="2111431e539d8078cb148dae299ad435bcf94b27" translate="yes" xml:space="preserve">
          <source>Case &lt;code&gt;n &amp;gt; 1&lt;/code&gt;</source>
          <target state="translated">사례 &lt;code&gt;n &amp;gt; 1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9f1c61da11e76b12eda645d65ffd7fe29682099" translate="yes" xml:space="preserve">
          <source>Case &lt;code&gt;n == 0&lt;/code&gt;</source>
          <target state="translated">사례 &lt;code&gt;n == 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="29a059f07d864d6895c8f26aada84e3e2ae48daa" translate="yes" xml:space="preserve">
          <source>Case &lt;code&gt;n == 1&lt;/code&gt;</source>
          <target state="translated">사례 &lt;code&gt;n == 1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e5a951eefa4da8021cf83c2a312ac9db2161e292" translate="yes" xml:space="preserve">
          <source>Case Study: Rational</source>
          <target state="translated">사례 연구 : 합리적인</target>
        </trans-unit>
        <trans-unit id="226c8be8625b7e7ff2acf9e7afa1f2c1a67ee20d" translate="yes" xml:space="preserve">
          <source>Case Study: Rational Promotions</source>
          <target state="translated">사례 연구 : 합리적인 프로모션</target>
        </trans-unit>
        <trans-unit id="cebe54c7626cb1cefaca5f7f5ea6c96b4a7a2882" translate="yes" xml:space="preserve">
          <source>Cat</source>
          <target state="translated">Cat</target>
        </trans-unit>
        <trans-unit id="e321d6511fec0b2a4b2f0a4b6c9161ea67d3b862" translate="yes" xml:space="preserve">
          <source>Cat Face</source>
          <target state="translated">고양이 얼굴</target>
        </trans-unit>
        <trans-unit id="0304d8e66e7196a0cbe56d1a1e3f50a5d44586dc" translate="yes" xml:space="preserve">
          <source>Cat Face With Tears Of Joy</source>
          <target state="translated">기쁨의 눈물을 가진 고양이 얼굴</target>
        </trans-unit>
        <trans-unit id="8694b8421f68b951f951f9af799f80af5160aedd" translate="yes" xml:space="preserve">
          <source>Cat Face With Wry Smile</source>
          <target state="translated">지친 미소로 고양이 얼굴</target>
        </trans-unit>
        <trans-unit id="34dfec8f22dde17704da94df2192063529be5d2d" translate="yes" xml:space="preserve">
          <source>Catalan's constant.</source>
          <target state="translated">카탈로니아 어 상수.</target>
        </trans-unit>
        <trans-unit id="b8c6b9519d52cad00665d92e155963171c5e725d" translate="yes" xml:space="preserve">
          <source>Catch exceptions during event evaluation</source>
          <target state="translated">이벤트 평가 중 예외 포착</target>
        </trans-unit>
        <trans-unit id="a3c686e711e4720f99b4562bb3dbaae7ab658cf2" translate="yes" xml:space="preserve">
          <source>Category</source>
          <target state="translated">Category</target>
        </trans-unit>
        <trans-unit id="1a80861772b0484c4f5af5303cebead59df45b86" translate="yes" xml:space="preserve">
          <source>Caution Sign</source>
          <target state="translated">주의 표시</target>
        </trans-unit>
        <trans-unit id="e4c530b1c24d3c230e2d840c8f5a4bd61e8f0170" translate="yes" xml:space="preserve">
          <source>Cchar</source>
          <target state="translated">Cchar</target>
        </trans-unit>
        <trans-unit id="98ea122cbe5434a5105ed227191d1c86da875820" translate="yes" xml:space="preserve">
          <source>Cdouble</source>
          <target state="translated">Cdouble</target>
        </trans-unit>
        <trans-unit id="ef6d3da178771ba00eefbc1133066d5d42ce7c22" translate="yes" xml:space="preserve">
          <source>Certain constructs in the language introduce &lt;em&gt;scope blocks&lt;/em&gt;, which are regions of code that are eligible to be the scope of some set of variables. The scope of a variable cannot be an arbitrary set of source lines; instead, it will always line up with one of these blocks. There are two main types of scopes in Julia, &lt;em&gt;global scope&lt;/em&gt; and &lt;em&gt;local scope&lt;/em&gt;. The latter can be nested. The constructs introducing scope blocks are:</source>
          <target state="translated">언어의 특정 구문 은 일부 변수 세트의 범위에 해당하는 코드 영역 인 &lt;em&gt;범위 블록을&lt;/em&gt; 도입 합니다. 변수의 범위는 임의의 소스 행 세트가 될 수 없습니다. 대신 항상이 블록 중 하나와 정렬됩니다. Julia에는 &lt;em&gt;전역 범위&lt;/em&gt; 와 &lt;em&gt;로컬 범위&lt;/em&gt; 의 두 가지 주요 &lt;em&gt;범위가&lt;/em&gt; 있습니다. 후자는 중첩 될 수 있습니다. 범위 블록을 도입하는 구성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a436f524b4f30d26cce25c6fb61307697fefc2aa" translate="yes" xml:space="preserve">
          <source>Certain operations make mathematical sense but result in errors:</source>
          <target state="translated">특정 연산은 수학적으로 이해되지만 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b83c053cc3abf67280351793fa40fe0857a1ef12" translate="yes" xml:space="preserve">
          <source>Cfloat</source>
          <target state="translated">Cfloat</target>
        </trans-unit>
        <trans-unit id="1bf8d41c6633f510ee163ba63fad81c499b65c06" translate="yes" xml:space="preserve">
          <source>Chaining comparisons</source>
          <target state="translated">체인 비교</target>
        </trans-unit>
        <trans-unit id="e4b02f736800960ffeb31d1ce4d94bc68e9b3522" translate="yes" xml:space="preserve">
          <source>Chaining comparisons is often quite convenient in numerical code. Chained comparisons use the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator for scalar comparisons, and the &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt; operator for elementwise comparisons, which allows them to work on arrays. For example, &lt;code&gt;0 .&amp;lt; A .&amp;lt; 1&lt;/code&gt; gives a boolean array whose entries are true where the corresponding elements of &lt;code&gt;A&lt;/code&gt; are between 0 and 1.</source>
          <target state="translated">연쇄 비교는 종종 숫자 코드에서 매우 편리합니다. 연쇄 비교 는 스칼라 비교에 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 연산자를 사용하고 요소 별 비교에 &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;/a&gt; 연산자를 사용하여 배열에서 작업 할 수 있도록합니다. 예를 들어, &lt;code&gt;0 .&amp;lt; A .&amp;lt; 1&lt;/code&gt; 은 &lt;code&gt;A&lt;/code&gt; 의 해당 요소가 0과 1 사이에 있는 항목이 참인 부울 배열을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="e392d2ea4fb56f31affc92a17a7f093445989a1e" translate="yes" xml:space="preserve">
          <source>Change the &lt;code&gt;T&lt;/code&gt; arithmetic precision (in bits) for the duration of &lt;code&gt;f&lt;/code&gt;. It is logically equivalent to:</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 기간 동안 &lt;code&gt;T&lt;/code&gt; 산술 정밀도 (비트)를 변경하십시오 . 논리적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aa7aae11d28e8bd4a1ac0973becf0187af2f72ff" translate="yes" xml:space="preserve">
          <source>Change the next word to lowercase</source>
          <target state="translated">다음 단어를 소문자로 변경</target>
        </trans-unit>
        <trans-unit id="a9d00290564b5f132466d2d65a5760e410b77379" translate="yes" xml:space="preserve">
          <source>Change the next word to titlecase</source>
          <target state="translated">다음 단어를 titlecase로 변경</target>
        </trans-unit>
        <trans-unit id="a1848e10eea50d9a7d51e412b6c651b68fe304e4" translate="yes" xml:space="preserve">
          <source>Change the next word to uppercase</source>
          <target state="translated">다음 단어를 대문자로 변경</target>
        </trans-unit>
        <trans-unit id="52116f45eb7f0166da051d04ad38b63f5e208b1f" translate="yes" xml:space="preserve">
          <source>Change the owner and/or group of &lt;code&gt;path&lt;/code&gt; to &lt;code&gt;owner&lt;/code&gt; and/or &lt;code&gt;group&lt;/code&gt;. If the value entered for &lt;code&gt;owner&lt;/code&gt; or &lt;code&gt;group&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt; the corresponding ID will not change. Only integer &lt;code&gt;owner&lt;/code&gt;s and &lt;code&gt;group&lt;/code&gt;s are currently supported. Return &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">의 소유자 및 / 또는 그룹 변경 &lt;code&gt;path&lt;/code&gt; 에 &lt;code&gt;owner&lt;/code&gt; 및 / 또는 &lt;code&gt;group&lt;/code&gt; . &lt;code&gt;owner&lt;/code&gt; 또는 &lt;code&gt;group&lt;/code&gt; 입력 한 값 이 &lt;code&gt;-1&lt;/code&gt; 이면 해당 ID가 변경되지 않습니다. 정수 &lt;code&gt;owner&lt;/code&gt; 및 &lt;code&gt;group&lt;/code&gt; 만 현재 지원됩니다. &lt;code&gt;path&lt;/code&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="b4cadce06d0cab691571969b2bd50452957441f5" translate="yes" xml:space="preserve">
          <source>Change the permissions mode of &lt;code&gt;path&lt;/code&gt; to &lt;code&gt;mode&lt;/code&gt;. Only integer &lt;code&gt;mode&lt;/code&gt;s (e.g. &lt;code&gt;0o777&lt;/code&gt;) are currently supported. If &lt;code&gt;recursive=true&lt;/code&gt; and the path is a directory all permissions in that directory will be recursively changed. Return &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">의 권한 모드 변경 &lt;code&gt;path&lt;/code&gt; 로 &lt;code&gt;mode&lt;/code&gt; . 정수 &lt;code&gt;mode&lt;/code&gt; (예 : &lt;code&gt;0o777&lt;/code&gt; ) 만 현재 지원됩니다. 경우 &lt;code&gt;recursive=true&lt;/code&gt; 과 경로가 디렉토리 디렉토리에있는 모든 권한을 반복적으로 변경됩니다. &lt;code&gt;path&lt;/code&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="32a989fb98b8f1dbfc4dbfdbda4cfa7a8f5a564e" translate="yes" xml:space="preserve">
          <source>Change the rounding mode of floating point type &lt;code&gt;T&lt;/code&gt; for the duration of &lt;code&gt;f&lt;/code&gt;. It is logically equivalent to:</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 기간 동안 부동 소수점 유형 &lt;code&gt;T&lt;/code&gt; 의 반올림 모드를 변경하십시오 . 논리적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6826b0c27162177562d5dac46bf63880b08e8521" translate="yes" xml:space="preserve">
          <source>Change the type-interpretation of a block of memory. For arrays, this constructs a view of the array with the same binary data as the given array, but with the specified element type. For example, &lt;code&gt;reinterpret(Float32, UInt32(7))&lt;/code&gt; interprets the 4 bytes corresponding to &lt;code&gt;UInt32(7)&lt;/code&gt; as a &lt;a href=&quot;../numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">메모리 블록의 유형 해석을 변경하십시오. 배열의 경우, 지정된 배열과 동일한 이진 데이터를 사용하지만 지정된 요소 유형을 가진 배열의보기를 구성합니다. 예를 들어, &lt;code&gt;reinterpret(Float32, UInt32(7))&lt;/code&gt; 는 &lt;code&gt;UInt32(7)&lt;/code&gt; 해당하는 4 바이트를 &lt;a href=&quot;../numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; 로 해석합니다 .</target>
        </trans-unit>
        <trans-unit id="d4eec72c597c649417c08cf8310c3fd12582209e" translate="yes" xml:space="preserve">
          <source>Change to the first history entry (of the current session if it is before the current position in history)</source>
          <target state="translated">첫 번째 히스토리 항목으로 변경 (현재 세션이 히스토리에서 현재 위치 이전 인 경우)</target>
        </trans-unit>
        <trans-unit id="2d9790ce2e89644c1d5ef1d4178a0e20ffa229c9" translate="yes" xml:space="preserve">
          <source>Change to the last history entry</source>
          <target state="translated">마지막 기록 항목으로 변경</target>
        </trans-unit>
        <trans-unit id="f00c73a7c5134c054bca76810185e125c387bc0a" translate="yes" xml:space="preserve">
          <source>Change to the next history entry</source>
          <target state="translated">다음 이력 항목으로 변경</target>
        </trans-unit>
        <trans-unit id="cfe48d07ba26c0afb2979f42a242b38ee82c88da" translate="yes" xml:space="preserve">
          <source>Change to the previous history entry</source>
          <target state="translated">이전 이력 항목으로 변경</target>
        </trans-unit>
        <trans-unit id="879f0b1bef59eeebf78cfd3a22f6f8077810cecf" translate="yes" xml:space="preserve">
          <source>Channel</source>
          <target state="translated">Channel</target>
        </trans-unit>
        <trans-unit id="18e03e2a37ba37df713f9665ef752fb8b40fc1e8" translate="yes" xml:space="preserve">
          <source>Channels</source>
          <target state="translated">Channels</target>
        </trans-unit>
        <trans-unit id="5d2585d6b1ebe562ed90e098229697dd1edbced3" translate="yes" xml:space="preserve">
          <source>Channels and RemoteChannels</source>
          <target state="translated">채널 및 원격 채널</target>
        </trans-unit>
        <trans-unit id="5de527ad4b50c6e5971cd0c9d1c61d30dff8242c" translate="yes" xml:space="preserve">
          <source>Channels are created via the &lt;code&gt;Channel{T}(sz)&lt;/code&gt; constructor. The channel will only hold objects of type &lt;code&gt;T&lt;/code&gt;. If the type is not specified, the channel can hold objects of any type. &lt;code&gt;sz&lt;/code&gt; refers to the maximum number of elements that can be held in the channel at any time. For example, &lt;code&gt;Channel(32)&lt;/code&gt; creates a channel that can hold a maximum of 32 objects of any type. A &lt;code&gt;Channel{MyType}(64)&lt;/code&gt; can hold up to 64 objects of &lt;code&gt;MyType&lt;/code&gt; at any time.</source>
          <target state="translated">채널은 &lt;code&gt;Channel{T}(sz)&lt;/code&gt; 생성자 를 통해 생성됩니다 . 채널은 &lt;code&gt;T&lt;/code&gt; 유형의 오브젝트 만 보유합니다 . 유형을 지정하지 않으면 채널은 모든 유형의 객체를 보유 할 수 있습니다. &lt;code&gt;sz&lt;/code&gt; 는 언제든지 채널에 보유 할 수있는 최대 요소 수를 나타냅니다. 예를 들어 &lt;code&gt;Channel(32)&lt;/code&gt; 은 모든 유형의 최대 32 개의 객체를 보유 할 수있는 채널을 만듭니다. &lt;code&gt;Channel{MyType}(64)&lt;/code&gt; 의 64 개체를 보유 할 수 있습니다 &lt;code&gt;MyType&lt;/code&gt; 언제든지.</target>
        </trans-unit>
        <trans-unit id="f0af2b3f98cdd8293e5cd590c14f3ad654402a21" translate="yes" xml:space="preserve">
          <source>Character Tie</source>
          <target state="translated">캐릭터 타이</target>
        </trans-unit>
        <trans-unit id="ed74ee0fd869597bc8b7e61e821510ccb8a627ec" translate="yes" xml:space="preserve">
          <source>Character literals use the same behavior.</source>
          <target state="translated">문자 리터럴은 동일한 동작을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="af451d4e9c685856e4c14256f0f0685adcf83857" translate="yes" xml:space="preserve">
          <source>Character(s)</source>
          <target state="translated">Character(s)</target>
        </trans-unit>
        <trans-unit id="69803692f05446db28128e4d652fcda3604ec718" translate="yes" xml:space="preserve">
          <source>Characteristics:</source>
          <target state="translated">Characteristics:</target>
        </trans-unit>
        <trans-unit id="b6f59f08fd6d58c6725e21a9ec24e068148ec586" translate="yes" xml:space="preserve">
          <source>Characters</source>
          <target state="translated">Characters</target>
        </trans-unit>
        <trans-unit id="d9a77eec8cc54d9b9059ecff9f7f8b0c3d4a4b0c" translate="yes" xml:space="preserve">
          <source>Characters not listed above are normally treated as delimiters between date and time slots. For example a &lt;code&gt;dt&lt;/code&gt; string of &quot;1996-01-15T00:00:00.0&quot; would have a &lt;code&gt;format&lt;/code&gt; string like &quot;y-m-dTH:M:S.s&quot;. If you need to use a code character as a delimiter you can escape it using backslash. The date &quot;1995y01m&quot; would have the format &quot;y\ym\m&quot;.</source>
          <target state="translated">위에 나열되지 않은 문자는 일반적으로 날짜와 시간 슬롯 사이의 구분 기호로 처리됩니다. 예를 들어 &quot;1996-01-15T00 : 00 : 00.0&quot; 의 &lt;code&gt;dt&lt;/code&gt; 문자열은 &quot;ym-dTH : M : Ss&quot;와 같은 &lt;code&gt;format&lt;/code&gt; 문자열을 갖습니다 . 코드 문자를 구분 기호로 사용해야하는 경우 백 슬래시를 사용하여 이스케이프 처리 할 수 ​​있습니다. 날짜 &quot;1995y01m&quot;의 형식은 &quot;y \ ym \ m&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="ebef4e9d21d309d10e724345b9594679b3cd6e69" translate="yes" xml:space="preserve">
          <source>Chart With Downwards Trend</source>
          <target state="translated">하향 추세가있는 차트</target>
        </trans-unit>
        <trans-unit id="fda4f4461a399f03823d93f75ef10112a332c903" translate="yes" xml:space="preserve">
          <source>Chart With Upwards Trend</source>
          <target state="translated">상승 추세가있는 차트</target>
        </trans-unit>
        <trans-unit id="a4a446b006052a5af669c7f6d998cf1743a7f6f9" translate="yes" xml:space="preserve">
          <source>Chart With Upwards Trend And Yen Sign</source>
          <target state="translated">상승 추세와 엔 기호 차트</target>
        </trans-unit>
        <trans-unit id="73e89165960f554ff917c3b3ac9d3b096b8d5eaf" translate="yes" xml:space="preserve">
          <source>Check Mark</source>
          <target state="translated">체크 표시</target>
        </trans-unit>
        <trans-unit id="8cccac008dc853e30120df3e9a70c3898d9b2bee" translate="yes" xml:space="preserve">
          <source>Check if commit &lt;code&gt;id&lt;/code&gt; (which is a &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; in string form) is in the repository.</source>
          <target state="translated">커밋 &lt;code&gt;id&lt;/code&gt; ( 문자열 형식 의 &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt; )가 저장소에 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="36465e7df054d1a8db11c41ceb01463ffd339488" translate="yes" xml:space="preserve">
          <source>Check if the current branch is an &quot;orphan&quot; branch, i.e. has no commits. The first commit to this branch will have no parents.</source>
          <target state="translated">현재 브랜치가 &quot;고아&quot;브랜치인지 확인하십시오. 즉 커밋이 없습니다. 이 지점에 대한 첫 번째 커밋에는 부모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b66e0b7684d9561bc0ff2976ce4bdbc130c0a5c9" translate="yes" xml:space="preserve">
          <source>Check if there have been any changes to tracked files in the working tree (if &lt;code&gt;cached=false&lt;/code&gt;) or the index (if &lt;code&gt;cached=true&lt;/code&gt;). &lt;code&gt;pathspecs&lt;/code&gt; are the specifications for options for the diff.</source>
          <target state="translated">작업 트리 ( &lt;code&gt;cached=false&lt;/code&gt; 인 경우 ) 또는 색인 ( &lt;code&gt;cached=true&lt;/code&gt; 인 경우) 에 추적 된 파일이 변경되었는지 확인하십시오 . &lt;code&gt;pathspecs&lt;/code&gt; 는 diff 옵션의 사양입니다.</target>
        </trans-unit>
        <trans-unit id="10941e2df89576fa668bf1f89fbe0ad9fb195edb" translate="yes" xml:space="preserve">
          <source>Check that a matrix is square, then return its common dimension. For multiple arguments, return a vector.</source>
          <target state="translated">행렬이 정사각형인지 확인한 다음 공통 차원을 반환합니다. 여러 인수의 경우 벡터를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="6861a1cca611ecd76d506c1580f9dd38e9dfec32" translate="yes" xml:space="preserve">
          <source>Check two array shapes for compatibility, allowing trailing singleton dimensions, and return whichever shape has more dimensions.</source>
          <target state="translated">호환성을 위해 두 개의 배열 모양을 확인하여 후행 싱글 톤 치수를 허용하고 더 많은 치수를 가진 모양을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5847f57e4c8ac4313a08831cbbd9321dc7c8aa94" translate="yes" xml:space="preserve">
          <source>Check whether the &lt;code&gt;lock&lt;/code&gt; is held by any task/thread. This should not be used for synchronization (see instead &lt;a href=&quot;#Base.trylock&quot;&gt;&lt;code&gt;trylock&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">작업 / 스레드가 &lt;code&gt;lock&lt;/code&gt; 을 보유하고 있는지 확인하십시오 . 동기화에 사용해서는 안됩니다 (대신 &lt;a href=&quot;#Base.trylock&quot;&gt; &lt;code&gt;trylock&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="387def941a675fd43bb90cd2f103bc1835695e36" translate="yes" xml:space="preserve">
          <source>Checked.add_with_overflow()</source>
          <target state="translated">Checked.add_with_overflow()</target>
        </trans-unit>
        <trans-unit id="5861f86d2198b43b150ea6be20eecd4f4ca194fb" translate="yes" xml:space="preserve">
          <source>Checked.checked_abs()</source>
          <target state="translated">Checked.checked_abs()</target>
        </trans-unit>
        <trans-unit id="0e340663d314653dc7f7258455c8c64ec865a402" translate="yes" xml:space="preserve">
          <source>Checked.checked_add()</source>
          <target state="translated">Checked.checked_add()</target>
        </trans-unit>
        <trans-unit id="793b46bf345ea840a66fc3ce7be504df87f6aad8" translate="yes" xml:space="preserve">
          <source>Checked.checked_cld()</source>
          <target state="translated">Checked.checked_cld()</target>
        </trans-unit>
        <trans-unit id="cbb75d95e9a638cb0354f430f1c41528c16d5f1e" translate="yes" xml:space="preserve">
          <source>Checked.checked_div()</source>
          <target state="translated">Checked.checked_div()</target>
        </trans-unit>
        <trans-unit id="10f25d8f5722c731db35c0585785eb14e0947047" translate="yes" xml:space="preserve">
          <source>Checked.checked_fld()</source>
          <target state="translated">Checked.checked_fld()</target>
        </trans-unit>
        <trans-unit id="844d8f377decea211f1aa04e5b41ffd6aa8ec8aa" translate="yes" xml:space="preserve">
          <source>Checked.checked_mod()</source>
          <target state="translated">Checked.checked_mod()</target>
        </trans-unit>
        <trans-unit id="6e287962b9c64e9790cebd017023df56a743a004" translate="yes" xml:space="preserve">
          <source>Checked.checked_mul()</source>
          <target state="translated">Checked.checked_mul()</target>
        </trans-unit>
        <trans-unit id="8cddbe8ee88213cf9e9d56a609fa85a89e086da7" translate="yes" xml:space="preserve">
          <source>Checked.checked_neg()</source>
          <target state="translated">Checked.checked_neg()</target>
        </trans-unit>
        <trans-unit id="e44667638c3a1dc209bda165095e1d1cd133cc75" translate="yes" xml:space="preserve">
          <source>Checked.checked_rem()</source>
          <target state="translated">Checked.checked_rem()</target>
        </trans-unit>
        <trans-unit id="0088d172f06fff6ea323397de23669a32c31474b" translate="yes" xml:space="preserve">
          <source>Checked.checked_sub()</source>
          <target state="translated">Checked.checked_sub()</target>
        </trans-unit>
        <trans-unit id="ab7e607ffaab3ede22444bf0bafb0736dd5575b5" translate="yes" xml:space="preserve">
          <source>Checked.mul_with_overflow()</source>
          <target state="translated">Checked.mul_with_overflow()</target>
        </trans-unit>
        <trans-unit id="44a69fd61235a11b4b6edaa45c7d2594c6702f55" translate="yes" xml:space="preserve">
          <source>Checked.sub_with_overflow()</source>
          <target state="translated">Checked.sub_with_overflow()</target>
        </trans-unit>
        <trans-unit id="099aaa95277770b044f9e7efabb37f097dce362a" translate="yes" xml:space="preserve">
          <source>Checkout a new git branch in the &lt;code&gt;repo&lt;/code&gt; repository. &lt;code&gt;commit&lt;/code&gt; is the &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt;, in string form, which will be the start of the new branch. If &lt;code&gt;commit&lt;/code&gt; is an empty string, the current HEAD will be used.</source>
          <target state="translated">&lt;code&gt;repo&lt;/code&gt; 저장소 에서 새로운 자식 분기를 체크 아웃하십시오 . &lt;code&gt;commit&lt;/code&gt; 은 &lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt; 이며 문자열 형식으로 새 브랜치의 시작이됩니다. 경우 &lt;code&gt;commit&lt;/code&gt; 빈 문자열, 현재 HEAD가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a01db35293e447e7dfa93e429ed3057a3d6edb4e" translate="yes" xml:space="preserve">
          <source>Checks if there are any differences between the tree specified by &lt;code&gt;treeish&lt;/code&gt; and the tracked files in the working tree (if &lt;code&gt;cached=false&lt;/code&gt;) or the index (if &lt;code&gt;cached=true&lt;/code&gt;). &lt;code&gt;pathspecs&lt;/code&gt; are the specifications for options for the diff.</source>
          <target state="translated">&lt;code&gt;treeish&lt;/code&gt; 에 의해 지정된 트리 와 작업 트리 ( &lt;code&gt;cached=false&lt;/code&gt; 인 경우 ) 또는 추적 된 파일 ( &lt;code&gt;cached=true&lt;/code&gt; 인 경우) 에서 추적 된 파일 간에 차이가 있는지 확인합니다 . &lt;code&gt;pathspecs&lt;/code&gt; 는 diff 옵션의 사양입니다.</target>
        </trans-unit>
        <trans-unit id="80497c05495db1c1e51a0b937bd9ffa77fb142ff" translate="yes" xml:space="preserve">
          <source>Cheering Megaphone</source>
          <target state="translated">응원 메가폰</target>
        </trans-unit>
        <trans-unit id="e81bedf047792fbe90c699c0d92561bd6df81796" translate="yes" xml:space="preserve">
          <source>Chequered Flag</source>
          <target state="translated">바둑판 무늬 깃발</target>
        </trans-unit>
        <trans-unit id="78bc6d7859d13eaa4171edc4973a040f60c5efa2" translate="yes" xml:space="preserve">
          <source>Cherries</source>
          <target state="translated">Cherries</target>
        </trans-unit>
        <trans-unit id="d980b2a4bed67957e89a2bfcbf9122253661d3b9" translate="yes" xml:space="preserve">
          <source>Cherry Blossom</source>
          <target state="translated">벚꽃</target>
        </trans-unit>
        <trans-unit id="c712b8835755410091fbe89cfba2f9989bcdddf1" translate="yes" xml:space="preserve">
          <source>Chestnut</source>
          <target state="translated">Chestnut</target>
        </trans-unit>
        <trans-unit id="baaa18844b8db958c57edddf824f4a8b5cd9e298" translate="yes" xml:space="preserve">
          <source>Chicken</source>
          <target state="translated">Chicken</target>
        </trans-unit>
        <trans-unit id="6684f920ddf587816828d0949794d536f2044d85" translate="yes" xml:space="preserve">
          <source>Children Crossing</source>
          <target state="translated">어린이 건널목</target>
        </trans-unit>
        <trans-unit id="be60ee4f4851b8d244bba0827efe90ca53080f02" translate="yes" xml:space="preserve">
          <source>Chocolate Bar</source>
          <target state="translated">초콜릿 바</target>
        </trans-unit>
        <trans-unit id="36f117bd7dd482a1010ab9584c224f54936b91cc" translate="yes" xml:space="preserve">
          <source>Cholesky (see &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt;&lt;code&gt;cholesky&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt; &lt;code&gt;cholesky&lt;/code&gt; &lt;/a&gt; 스키 ( cholesky 참조 )</target>
        </trans-unit>
        <trans-unit id="e3c96b15f464a32f9dbfcd9be5dcfbc00bda9510" translate="yes" xml:space="preserve">
          <source>Cholesky factorization</source>
          <target state="translated">hole 레 스키 분해</target>
        </trans-unit>
        <trans-unit id="da141a0edd85453be825d6aa02b625b2d8b12905" translate="yes" xml:space="preserve">
          <source>Christmas Tree</source>
          <target state="translated">크리스마스 트리</target>
        </trans-unit>
        <trans-unit id="e72e88ea6123b50e6208c2e997da2b67631286d6" translate="yes" xml:space="preserve">
          <source>Church</source>
          <target state="translated">Church</target>
        </trans-unit>
        <trans-unit id="f4ea571bfe0617f587935723651430356fc70f4c" translate="yes" xml:space="preserve">
          <source>Cinema</source>
          <target state="translated">Cinema</target>
        </trans-unit>
        <trans-unit id="20638d5f9a181ef513cf00b55dcce4c98adb55f7" translate="yes" xml:space="preserve">
          <source>Cint</source>
          <target state="translated">Cint</target>
        </trans-unit>
        <trans-unit id="810c53332cece6a0ba48a6c0ba3b4f10aa580f90" translate="yes" xml:space="preserve">
          <source>Cintmax_t</source>
          <target state="translated">Cintmax_t</target>
        </trans-unit>
        <trans-unit id="f012b4aef95600337cc3ea8a98c28a295ab93f2f" translate="yes" xml:space="preserve">
          <source>Circle With All But Upper Left Quadrant Black</source>
          <target state="translated">왼쪽 위 사분면 검정을 제외한 모든 원</target>
        </trans-unit>
        <trans-unit id="e64a2f1f5550310ac4fcf3d82a1eba3eb03373e3" translate="yes" xml:space="preserve">
          <source>Circle With Left Half Black</source>
          <target state="translated">왼쪽 반 검은 원</target>
        </trans-unit>
        <trans-unit id="4242c36ce736c0ae2d9e13bbac4c03ddccb00e63" translate="yes" xml:space="preserve">
          <source>Circle With Lower Half Black</source>
          <target state="translated">낮은 반 검은 원</target>
        </trans-unit>
        <trans-unit id="9946dda080b1d6f72432e4888afcc095dde79ea8" translate="yes" xml:space="preserve">
          <source>Circle With Right Half Black</source>
          <target state="translated">오른쪽 반 검은 원</target>
        </trans-unit>
        <trans-unit id="d869eafe06cb16bdb3bb0bc2e1be15db03901859" translate="yes" xml:space="preserve">
          <source>Circle With Upper Half Black</source>
          <target state="translated">상단 반 검은 원</target>
        </trans-unit>
        <trans-unit id="a8f7c61db4ce9bd030f686d3b28ef55edb06c05f" translate="yes" xml:space="preserve">
          <source>Circle With Upper Right Quadrant Black</source>
          <target state="translated">오른쪽 위 사분면 검정 원</target>
        </trans-unit>
        <trans-unit id="7ac2156e5b2912f2254d2f3ae90f1a8c149be7ab" translate="yes" xml:space="preserve">
          <source>Circle With Vertical Fill</source>
          <target state="translated">수직 채우기가있는 원</target>
        </trans-unit>
        <trans-unit id="bdade6bd883a792ea7c7650d2326b104f190c6db" translate="yes" xml:space="preserve">
          <source>Circled Anticlockwise-Rotated Division Sign</source>
          <target state="translated">반 시계 방향으로 회전 된 구간 표시</target>
        </trans-unit>
        <trans-unit id="288b0220ab4dfdbd33067b22c1e4248e5492c4f4" translate="yes" xml:space="preserve">
          <source>Circled Asterisk Operator</source>
          <target state="translated">동그라미 별표 연산자</target>
        </trans-unit>
        <trans-unit id="c23f14422e51f91da407f474f9afc3cc0d6b1a61" translate="yes" xml:space="preserve">
          <source>Circled Bullet</source>
          <target state="translated">동그라미 글 머리 기호</target>
        </trans-unit>
        <trans-unit id="317b273eb94a369a8c28e6bf5cd7c75c54af9e35" translate="yes" xml:space="preserve">
          <source>Circled Dash</source>
          <target state="translated">동그라미 대시</target>
        </trans-unit>
        <trans-unit id="f5d528c73ab76ab5f33f09420750954ff64b51f9" translate="yes" xml:space="preserve">
          <source>Circled Division Sign</source>
          <target state="translated">동그라미 사단 표시</target>
        </trans-unit>
        <trans-unit id="af5e4fc428d95afd21ff1ec53e8506a2bd73fb48" translate="yes" xml:space="preserve">
          <source>Circled Division Slash</source>
          <target state="translated">동그라미 구분 슬래시</target>
        </trans-unit>
        <trans-unit id="1540fdfaea096a26f649db63c8e3d97ec047096a" translate="yes" xml:space="preserve">
          <source>Circled Dot Operator</source>
          <target state="translated">원형 도트 연산자</target>
        </trans-unit>
        <trans-unit id="13716b865f5fa5c0c59b298bdb824a0403d1d0a8" translate="yes" xml:space="preserve">
          <source>Circled Equals</source>
          <target state="translated">동그라미 같음</target>
        </trans-unit>
        <trans-unit id="6fb20198e34869ba5357fb1484d789a4a9cf41a3" translate="yes" xml:space="preserve">
          <source>Circled Greater-Than</source>
          <target state="translated">동그라미 그레이터 탄</target>
        </trans-unit>
        <trans-unit id="768c6a3e34cf1fa1fe17c4122cd2eb756b5c8db1" translate="yes" xml:space="preserve">
          <source>Circled Ideograph Accept</source>
          <target state="translated">동그라미 표시</target>
        </trans-unit>
        <trans-unit id="cd7d8396b4543ec8eac2c933faab0d381b5eddf4" translate="yes" xml:space="preserve">
          <source>Circled Ideograph Advantage</source>
          <target state="translated">동그라미 표시가있는 이점</target>
        </trans-unit>
        <trans-unit id="68de940ba4435005de139e8e8a3c0d351749a305" translate="yes" xml:space="preserve">
          <source>Circled Ideograph Congratulation</source>
          <target state="translated">Circled Ideograph 축하</target>
        </trans-unit>
        <trans-unit id="73f2e57c66e79ca73dc25a784afe3bf12db57991" translate="yes" xml:space="preserve">
          <source>Circled Ideograph Secret</source>
          <target state="translated">동그라미 이데 오 그래프 비밀</target>
        </trans-unit>
        <trans-unit id="a40a39ec3a6682d21b6ef060b4feb0021bb56a91" translate="yes" xml:space="preserve">
          <source>Circled Latin Capital Letter M</source>
          <target state="translated">동그라미 라틴 대문자 M</target>
        </trans-unit>
        <trans-unit id="0737d90c41767eac9bb882a65f60e50a52a763a4" translate="yes" xml:space="preserve">
          <source>Circled Latin Capital Letter S</source>
          <target state="translated">동그라미 라틴 대문자 S</target>
        </trans-unit>
        <trans-unit id="3921273fcb7324637d2df323be0460e56b6c07e5" translate="yes" xml:space="preserve">
          <source>Circled Less-Than</source>
          <target state="translated">원이 적은 탄</target>
        </trans-unit>
        <trans-unit id="11ab89c625b1e2be31e3ce88e58467e9d8b591d3" translate="yes" xml:space="preserve">
          <source>Circled Minus</source>
          <target state="translated">동그라미 빼기</target>
        </trans-unit>
        <trans-unit id="49fb7ea6102e3ddbe3f49605b323255242257db1" translate="yes" xml:space="preserve">
          <source>Circled Multiplication Sign With Circumflex Accent</source>
          <target state="translated">곡절 악센트 원으로 곱셈 기호</target>
        </trans-unit>
        <trans-unit id="b54193aa1a494f0d833f0a8740fb732847cecb8a" translate="yes" xml:space="preserve">
          <source>Circled Parallel</source>
          <target state="translated">원형 평행</target>
        </trans-unit>
        <trans-unit id="8f99a8867a889f5ea35c2600d3c7f7047a7990e2" translate="yes" xml:space="preserve">
          <source>Circled Plus</source>
          <target state="translated">동그라미 플러스</target>
        </trans-unit>
        <trans-unit id="b2f2ab10cbdb08e806c050f7e4c9abf4807d102e" translate="yes" xml:space="preserve">
          <source>Circled Reverse Solidus</source>
          <target state="translated">원형 역 고 상선</target>
        </trans-unit>
        <trans-unit id="7a06e50e7385bdb39935cdfabe9072e82b9447d8" translate="yes" xml:space="preserve">
          <source>Circled Ring Operator</source>
          <target state="translated">원형 링 연산자</target>
        </trans-unit>
        <trans-unit id="3118f0f5bf53391e1d64d00f6fd9c8f83519338c" translate="yes" xml:space="preserve">
          <source>Circled Times</source>
          <target state="translated">동그라미 시간</target>
        </trans-unit>
        <trans-unit id="e0d7ab77f8105b38fa7df093b28a79c9646ca42a" translate="yes" xml:space="preserve">
          <source>Circled White Bullet</source>
          <target state="translated">동그라미 흰색 총알</target>
        </trans-unit>
        <trans-unit id="9d61e5de58e6dee3981e042fcf23eeed9646f7cf" translate="yes" xml:space="preserve">
          <source>Circled White Star</source>
          <target state="translated">동그라미 화이트 스타</target>
        </trans-unit>
        <trans-unit id="7748321d0967d869f81325b4585f9b2588000677" translate="yes" xml:space="preserve">
          <source>Circularly shift, i.e. rotate, the data in &lt;code&gt;src&lt;/code&gt;, storing the result in &lt;code&gt;dest&lt;/code&gt;. &lt;code&gt;shifts&lt;/code&gt; specifies the amount to shift in each dimension.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 의 데이터를 순환 적으로 이동, 즉 회전시켜 결과를 &lt;code&gt;dest&lt;/code&gt; 에 저장합니다 . &lt;code&gt;shifts&lt;/code&gt; 는 각 차원에서 이동할 양을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d8d1450c5aa55fa70cdef969d2aed9b6bea5b253" translate="yes" xml:space="preserve">
          <source>Circularly shift, i.e. rotate, the data in an array. The second argument is a tuple or vector giving the amount to shift in each dimension, or an integer to shift only in the first dimension.</source>
          <target state="translated">배열에서 데이터를 순환 적으로 이동, 즉 회전시킵니다. 두 번째 인수는 각 차원에서 이동할 양을 제공하는 튜플 또는 벡터이거나 첫 번째 차원에서만 이동할 정수입니다.</target>
        </trans-unit>
        <trans-unit id="a48e6cb43386bd05dea50af46a123ad0d776b80b" translate="yes" xml:space="preserve">
          <source>Circulation Function</source>
          <target state="translated">순환 기능</target>
        </trans-unit>
        <trans-unit id="37536a1d3cc9b23bf2b06cce0eca23c6a4e7e102" translate="yes" xml:space="preserve">
          <source>Circus Tent</source>
          <target state="translated">서커스 텐트</target>
        </trans-unit>
        <trans-unit id="2db191558345453d3d04631fffed018826e9442e" translate="yes" xml:space="preserve">
          <source>Cityscape At Dusk</source>
          <target state="translated">황혼에서 도시</target>
        </trans-unit>
        <trans-unit id="11cf0a77f6ee3236fe15d4a64163013e4f57ac86" translate="yes" xml:space="preserve">
          <source>Clapper Board</source>
          <target state="translated">클래퍼 보드</target>
        </trans-unit>
        <trans-unit id="1a53c684edaeea21a3a7c9865bbc7c7a6b647d98" translate="yes" xml:space="preserve">
          <source>Clapping Hands Sign</source>
          <target state="translated">박수 손 기호</target>
        </trans-unit>
        <trans-unit id="516efc45347d5f1d25705370de6f7e8790454c94" translate="yes" xml:space="preserve">
          <source>Clear any existing backtraces from the internal buffer.</source>
          <target state="translated">내부 버퍼에서 기존 역 추적을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="82280dd39a2e304ec7a95875634d07334aea409a" translate="yes" xml:space="preserve">
          <source>Clear console screen</source>
          <target state="translated">콘솔 화면 지우기</target>
        </trans-unit>
        <trans-unit id="fb1b9ef26d7247fef7acad9f0bc4d393aa69d604" translate="yes" xml:space="preserve">
          <source>Clearly, this is far from the way mathematical integers behave, and you might think it less than ideal for a high-level programming language to expose this to the user. For numerical work where efficiency and transparency are at a premium, however, the alternatives are worse.</source>
          <target state="translated">분명히 이것은 수학 정수의 동작 방식과는 거리가 멀기 때문에 고급 프로그래밍 언어가 이것을 사용자에게 노출시키는 것이 이상적이지 않다고 생각할 수 있습니다. 그러나 효율성과 투명성이 중요한 수치 작업의 경우 대안이 더 나쁩니다.</target>
        </trans-unit>
        <trans-unit id="ec4842b9335f240ce519c3e7eb35a6d7dd134038" translate="yes" xml:space="preserve">
          <source>Clears any stored memory allocation data when running julia with &lt;code&gt;--track-allocation&lt;/code&gt;. Execute the command(s) you want to test (to force JIT-compilation), then call &lt;a href=&quot;#Profile.clear_malloc_data&quot;&gt;&lt;code&gt;clear_malloc_data&lt;/code&gt;&lt;/a&gt;. Then execute your command(s) again, quit Julia, and examine the resulting &lt;code&gt;*.mem&lt;/code&gt; files.</source>
          <target state="translated">&lt;code&gt;--track-allocation&lt;/code&gt; 으로 julia를 실행할 때 저장된 메모리 할당 데이터를 지 웁니다 . 테스트하려는 명령을 실행하고 (JIT 컴파일을 강제 실행) &lt;a href=&quot;#Profile.clear_malloc_data&quot;&gt; &lt;code&gt;clear_malloc_data&lt;/code&gt; &lt;/a&gt; 를 호출 하십시오 . 그런 다음 명령을 다시 실행하고 Julia를 종료하고 결과 &lt;code&gt;*.mem&lt;/code&gt; 파일을 검사하십시오 .</target>
        </trans-unit>
        <trans-unit id="f1508fb36867e2dc32f615b5c14b90813384914e" translate="yes" xml:space="preserve">
          <source>Clears global bindings in modules by initializing them to &lt;code&gt;nothing&lt;/code&gt;. &lt;code&gt;syms&lt;/code&gt; should be of type &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt; or a collection of &lt;code&gt;Symbol&lt;/code&gt;s . &lt;code&gt;pids&lt;/code&gt; and &lt;code&gt;mod&lt;/code&gt; identify the processes and the module in which global variables are to be reinitialized. Only those names found to be defined under &lt;code&gt;mod&lt;/code&gt; are cleared.</source>
          <target state="translated">모듈의 전역 바인딩을 &lt;code&gt;nothing&lt;/code&gt; 초기화 하지 않고 지 웁니다 . &lt;code&gt;syms&lt;/code&gt; 유형을 사용해야 &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt; 또는 모음 &lt;code&gt;Symbol&lt;/code&gt; 들. &lt;code&gt;pids&lt;/code&gt; 및 &lt;code&gt;mod&lt;/code&gt; 는 전역 변수를 다시 초기화 할 프로세스 및 모듈을 식별합니다. &lt;code&gt;mod&lt;/code&gt; 에서 정의 된 이름 만 지워집니다.</target>
        </trans-unit>
        <trans-unit id="4a37999e16f7842ef3bf129008cd89f6cdc6cb0f" translate="yes" xml:space="preserve">
          <source>Clinking Beer Mugs</source>
          <target state="translated">만나요 맥주 머그잔</target>
        </trans-unit>
        <trans-unit id="5efe0c9323a499a8546aeac42d4b659bd2a4039f" translate="yes" xml:space="preserve">
          <source>Clipboard</source>
          <target state="translated">Clipboard</target>
        </trans-unit>
        <trans-unit id="80b2a110ce7d7c4741fab08718b7b0bad1a6e22a" translate="yes" xml:space="preserve">
          <source>Clock Face Eight Oclock</source>
          <target state="translated">시계 문자판 8시</target>
        </trans-unit>
        <trans-unit id="890e9e574fe3a811e9c99a391d98d07a63fc0336" translate="yes" xml:space="preserve">
          <source>Clock Face Eight-Thirty</source>
          <target state="translated">8시 30 분을 가리키는 시계</target>
        </trans-unit>
        <trans-unit id="a9b707e0c691e0552e2f8bc3916fe311413cb1c1" translate="yes" xml:space="preserve">
          <source>Clock Face Eleven Oclock</source>
          <target state="translated">시계 문자판 11시</target>
        </trans-unit>
        <trans-unit id="8ae5c10b2e512ab4d1e9f3ac4882a5accd7c7ae1" translate="yes" xml:space="preserve">
          <source>Clock Face Eleven-Thirty</source>
          <target state="translated">11시 30 분 시계 문자판</target>
        </trans-unit>
        <trans-unit id="e22dfa89a765cf1fb21d2f5d1bc38f3ade0afd76" translate="yes" xml:space="preserve">
          <source>Clock Face Five Oclock</source>
          <target state="translated">시계 문자판 5시</target>
        </trans-unit>
        <trans-unit id="3a7136e9fc05d844d8d22ef7e7a4065f750e1bbb" translate="yes" xml:space="preserve">
          <source>Clock Face Five-Thirty</source>
          <target state="translated">시계 문자판 5-30</target>
        </trans-unit>
        <trans-unit id="6c604425f0ef3b9a4e6a798a11e9cb980c5f5643" translate="yes" xml:space="preserve">
          <source>Clock Face Four Oclock</source>
          <target state="translated">시계 문자판 4시</target>
        </trans-unit>
        <trans-unit id="1d7bba61675982358fbf74be54ea171922d5d085" translate="yes" xml:space="preserve">
          <source>Clock Face Four-Thirty</source>
          <target state="translated">시계 문자판 삼십</target>
        </trans-unit>
        <trans-unit id="8effbf7e8f00a8276bde132d10680427c2d5ec2c" translate="yes" xml:space="preserve">
          <source>Clock Face Nine Oclock</source>
          <target state="translated">시계 얼굴 9시</target>
        </trans-unit>
        <trans-unit id="b0f219a4f731970988c8def9f6a9220234b63061" translate="yes" xml:space="preserve">
          <source>Clock Face Nine-Thirty</source>
          <target state="translated">시계 얼굴 아홉 서른</target>
        </trans-unit>
        <trans-unit id="2aa0624b2187d35a495fb74b7a70417ce4d8cdc6" translate="yes" xml:space="preserve">
          <source>Clock Face One Oclock</source>
          <target state="translated">시계 문자판 1시</target>
        </trans-unit>
        <trans-unit id="92624a0e738083d85292206e98f359ce3546ed05" translate="yes" xml:space="preserve">
          <source>Clock Face One-Thirty</source>
          <target state="translated">시계 문자판 삼십</target>
        </trans-unit>
        <trans-unit id="4ee4d2dec1cb5fcd6697bd397977fe18c3d4992c" translate="yes" xml:space="preserve">
          <source>Clock Face Seven Oclock</source>
          <target state="translated">시계 문자판 7시</target>
        </trans-unit>
        <trans-unit id="17aef1804b57cd3ede0fe80570334485de56eaea" translate="yes" xml:space="preserve">
          <source>Clock Face Seven-Thirty</source>
          <target state="translated">시계 문자판 세 번째</target>
        </trans-unit>
        <trans-unit id="f2ce5a71eefd68ceefa6e2f6811d47032f42f6eb" translate="yes" xml:space="preserve">
          <source>Clock Face Six Oclock</source>
          <target state="translated">시계 문자판 6시</target>
        </trans-unit>
        <trans-unit id="78a9100a5f02623dca735f3dacc48fead261c2cd" translate="yes" xml:space="preserve">
          <source>Clock Face Six-Thirty</source>
          <target state="translated">6시 문자반 시계</target>
        </trans-unit>
        <trans-unit id="29ed028a4b2d7ccf27a87e9aa08dd08fd6ebb1a6" translate="yes" xml:space="preserve">
          <source>Clock Face Ten Oclock</source>
          <target state="translated">시계 문자판 10시</target>
        </trans-unit>
        <trans-unit id="288b3a0678ebc38844da6df6f1e87880c74baafc" translate="yes" xml:space="preserve">
          <source>Clock Face Ten-Thirty</source>
          <target state="translated">시계 문자판 삼십</target>
        </trans-unit>
        <trans-unit id="bb465de467c2b010bb6b846eb78c2a1229522242" translate="yes" xml:space="preserve">
          <source>Clock Face Three Oclock</source>
          <target state="translated">시계 문자판 3시</target>
        </trans-unit>
        <trans-unit id="cfd958f3c422c51d841c78b6b7f3d9e44fc3ad75" translate="yes" xml:space="preserve">
          <source>Clock Face Three-Thirty</source>
          <target state="translated">3시 시계 얼굴</target>
        </trans-unit>
        <trans-unit id="7f669cae21a33d00c881936310a0c78e765a67d2" translate="yes" xml:space="preserve">
          <source>Clock Face Twelve Oclock</source>
          <target state="translated">시계 문자판 12시</target>
        </trans-unit>
        <trans-unit id="1ef2e813447d172d893056c5340a57fc6839f314" translate="yes" xml:space="preserve">
          <source>Clock Face Twelve-Thirty</source>
          <target state="translated">12시 30 분 시계 문자판</target>
        </trans-unit>
        <trans-unit id="4f6902106020e062d23dd43ecf72cd67020b6c3e" translate="yes" xml:space="preserve">
          <source>Clock Face Two Oclock</source>
          <target state="translated">시계 문자판 2시</target>
        </trans-unit>
        <trans-unit id="bcda9b95a7f9d026cc96f88e4ef6597b3948c3f5" translate="yes" xml:space="preserve">
          <source>Clock Face Two-Thirty</source>
          <target state="translated">시계 문자판 삼십</target>
        </trans-unit>
        <trans-unit id="3343394a9f3b65dd62d440bfd227fa40ca3918a2" translate="yes" xml:space="preserve">
          <source>Clockwise Contour Integral</source>
          <target state="translated">시계 방향 컨투어 일체형</target>
        </trans-unit>
        <trans-unit id="bef25f4fbfeb987aed2d95c207d8122fa87692e3" translate="yes" xml:space="preserve">
          <source>Clockwise Downwards And Upwards Open Circle Arrows</source>
          <target state="translated">시계 방향 아래쪽 및 위쪽 화살표</target>
        </trans-unit>
        <trans-unit id="b8015a573f0320267e05a1e6968f148a65bd38e5" translate="yes" xml:space="preserve">
          <source>Clockwise Integral</source>
          <target state="translated">시계 방향으로 적분</target>
        </trans-unit>
        <trans-unit id="7dcd16fa461353aaddde398802c410edb65684a9" translate="yes" xml:space="preserve">
          <source>Clockwise Open Circle Arrow</source>
          <target state="translated">시계 방향으로 열린 원 화살표</target>
        </trans-unit>
        <trans-unit id="0de2e9fdaa78d1a87383fa303df054177c3eef28" translate="yes" xml:space="preserve">
          <source>Clockwise Rightwards And Leftwards Open Circle Arrows</source>
          <target state="translated">시계 방향으로 오른쪽 및 왼쪽으로 열린 원 화살표</target>
        </trans-unit>
        <trans-unit id="78f3f16a08531e7f8a413160ff88e095df7562f2" translate="yes" xml:space="preserve">
          <source>Clockwise Rightwards And Leftwards Open Circle Arrows With Circled One Overlay</source>
          <target state="translated">시계 방향으로 오른쪽 및 왼쪽으로 원이 표시된 원 화살표</target>
        </trans-unit>
        <trans-unit id="5a2532914552dd4a4df03ca6c532a1cda0ad9c3e" translate="yes" xml:space="preserve">
          <source>Clockwise Top Semicircle Arrow</source>
          <target state="translated">시계 방향 반원형 화살표</target>
        </trans-unit>
        <trans-unit id="bd5a088aabea6d4dfe11cc8a8a32a9c1483fc8dd" translate="yes" xml:space="preserve">
          <source>Clone a remote repository located at &lt;code&gt;repo_url&lt;/code&gt; to the local filesystem location &lt;code&gt;repo_path&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;repo_url&lt;/code&gt; 에있는 원격 저장소 를 로컬 파일 시스템 위치 &lt;code&gt;repo_path&lt;/code&gt; 로 복제하십시오 .</target>
        </trans-unit>
        <trans-unit id="c018fd37cc98046cd18021dbc1501935677a8d0b" translate="yes" xml:space="preserve">
          <source>Clone the remote repository at &lt;code&gt;repo_url&lt;/code&gt; (which can be a remote URL or a path on the local filesystem) to &lt;code&gt;repo_path&lt;/code&gt; (which must be a path on the local filesystem). Options for the clone, such as whether to perform a bare clone or not, are set by &lt;a href=&quot;#LibGit2.CloneOptions&quot;&gt;&lt;code&gt;CloneOptions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;repo_url&lt;/code&gt; (원격 URL 또는 로컬 파일 시스템의 경로 일 수 있음) 의 원격 저장소를 repo_path (로컬 파일 시스템 의 경로 여야 함 )로 &lt;code&gt;repo_path&lt;/code&gt; 하십시오. &lt;a href=&quot;#LibGit2.CloneOptions&quot;&gt; &lt;code&gt;CloneOptions&lt;/code&gt; &lt;/a&gt; 복제 수행 여부와 같은 복제 옵션은 CloneOptions에 의해 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="03c26d678d2b5f993e8a4888363c7faf8f7499f8" translate="yes" xml:space="preserve">
          <source>Clong</source>
          <target state="translated">Clong</target>
        </trans-unit>
        <trans-unit id="ba9c34e2f3436e5d9b8a5291e72a776889a2ff30" translate="yes" xml:space="preserve">
          <source>Clonglong</source>
          <target state="translated">Clonglong</target>
        </trans-unit>
        <trans-unit id="b5209dad4d3f1bed9db6402ecbcc5727437490f8" translate="yes" xml:space="preserve">
          <source>Close a channel. An exception (optionally given by &lt;code&gt;excp&lt;/code&gt;), is thrown by:</source>
          <target state="translated">채널을 닫습니다. 예외 ( &lt;code&gt;excp&lt;/code&gt; 옵션으로 제공 )는 다음에 의해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="10c5d49bb09afa0ca8e3334711e18326dcf891af" translate="yes" xml:space="preserve">
          <source>Close an I/O stream. Performs a &lt;a href=&quot;#Base.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="translated">I / O 스트림을 닫습니다. &lt;a href=&quot;#Base.flush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt; 먼저 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="454adf74b3f6704e85f70c7ddf537bda059f03dd" translate="yes" xml:space="preserve">
          <source>Close shared library referenced by handle.</source>
          <target state="translated">핸들이 참조하는 공유 라이브러리를 닫습니다.</target>
        </trans-unit>
        <trans-unit id="8170fa95b5dabb39e3ab1424d8d01e1c3b92e425" translate="yes" xml:space="preserve">
          <source>Closed Book</source>
          <target state="translated">닫힌 책</target>
        </trans-unit>
        <trans-unit id="f01ec4341502afd5ff0fd4449550b0f2d821118a" translate="yes" xml:space="preserve">
          <source>Closed Intersection With Serifs</source>
          <target state="translated">세리프가있는 닫힌 교차점</target>
        </trans-unit>
        <trans-unit id="f96d5b0a19b4b209a04614ed2d984814137842d3" translate="yes" xml:space="preserve">
          <source>Closed Lock With Key</source>
          <target state="translated">열쇠로 닫힌 자물쇠</target>
        </trans-unit>
        <trans-unit id="fc6222181031539686fbc1981c6536202f4eebfd" translate="yes" xml:space="preserve">
          <source>Closed Mailbox With Lowered Flag</source>
          <target state="translated">플래그가 낮아진 닫힌 사서함</target>
        </trans-unit>
        <trans-unit id="675cf6fab44f887f9851bda94e48adbe87600a21" translate="yes" xml:space="preserve">
          <source>Closed Mailbox With Raised Flag</source>
          <target state="translated">제기 플래그로 닫힌 사서함</target>
        </trans-unit>
        <trans-unit id="deb82abc2edb75e5d2559fdc5e14496f68ebe0bb" translate="yes" xml:space="preserve">
          <source>Closed Subset</source>
          <target state="translated">닫힌 부분 집합</target>
        </trans-unit>
        <trans-unit id="27f828ad61dfe0b96ce6597aa9645041a206cb0a" translate="yes" xml:space="preserve">
          <source>Closed Subset Or Equal To</source>
          <target state="translated">닫힌 부분 집합 또는 같음</target>
        </trans-unit>
        <trans-unit id="9ca1f162310be3f8fde01956aa333063b943a628" translate="yes" xml:space="preserve">
          <source>Closed Superset</source>
          <target state="translated">닫힌 슈퍼 세트</target>
        </trans-unit>
        <trans-unit id="c1a77c6e35a02621888adfea720e18df739c611e" translate="yes" xml:space="preserve">
          <source>Closed Superset Or Equal To</source>
          <target state="translated">닫힌 수퍼 셋 또는 같음</target>
        </trans-unit>
        <trans-unit id="1d0ef3df97ab3df50e949a9a1324005eda6b8edb" translate="yes" xml:space="preserve">
          <source>Closed Umbrella</source>
          <target state="translated">닫힌 우산</target>
        </trans-unit>
        <trans-unit id="2509ab5953079af2e5239350a2c4c20c24bf4b87" translate="yes" xml:space="preserve">
          <source>Closed Union With Serifs</source>
          <target state="translated">세리프와 닫힌 연합</target>
        </trans-unit>
        <trans-unit id="f8612daffee734ab8fe7ac27e4779293f47bd9f2" translate="yes" xml:space="preserve">
          <source>Closed Union With Serifs And Smash Product</source>
          <target state="translated">세리프 및 스매시 제품과의 닫힌 연합</target>
        </trans-unit>
        <trans-unit id="6d5a3633bf3066d6ab42acadf4720d0c57381f8b" translate="yes" xml:space="preserve">
          <source>Closing a Library</source>
          <target state="translated">라이브러리 닫기</target>
        </trans-unit>
        <trans-unit id="08a1d4177a6fdb9b5f67b13428352c7562697b82" translate="yes" xml:space="preserve">
          <source>Closure cfunctions</source>
          <target state="translated">폐쇄 기능</target>
        </trans-unit>
        <trans-unit id="b2efeaa1a7d6d2185ea02473cf758203dfcea3fe" translate="yes" xml:space="preserve">
          <source>Cloud</source>
          <target state="translated">Cloud</target>
        </trans-unit>
        <trans-unit id="ac3f2b0304dbad8004f320d418e21b773f559bef" translate="yes" xml:space="preserve">
          <source>Cluster Cookie</source>
          <target state="translated">클러스터 쿠키</target>
        </trans-unit>
        <trans-unit id="2719f92d9319470b062026857b1b798355606f18" translate="yes" xml:space="preserve">
          <source>Cluster Manager Interface</source>
          <target state="translated">클러스터 관리자 인터페이스</target>
        </trans-unit>
        <trans-unit id="24b40ea7b4c6d2a2754b767ef66941a1b621105f" translate="yes" xml:space="preserve">
          <source>Cluster Managers with Custom Transports</source>
          <target state="translated">사용자 지정 전송 기능이있는 클러스터 관리자</target>
        </trans-unit>
        <trans-unit id="c66ed07e93160ccf42e9560935c19321d18456bf" translate="yes" xml:space="preserve">
          <source>ClusterManagers</source>
          <target state="translated">ClusterManagers</target>
        </trans-unit>
        <trans-unit id="36a5cc40f84a6918339448f7f9c84d698b78ed22" translate="yes" xml:space="preserve">
          <source>Cmd</source>
          <target state="translated">Cmd</target>
        </trans-unit>
        <trans-unit id="598ac4d5aadd51518cf7408c7b09c93d77fd77bc" translate="yes" xml:space="preserve">
          <source>Cocktail Glass</source>
          <target state="translated">칵테일 글라스</target>
        </trans-unit>
        <trans-unit id="adac69379a626c2436948a4ef1792c7d719ef929" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>
        </trans-unit>
        <trans-unit id="a99f20e7919aa57d6d229cdc49d476b887823796" translate="yes" xml:space="preserve">
          <source>Code Availability and Loading Packages</source>
          <target state="translated">코드 가용성 및로드 패키지</target>
        </trans-unit>
        <trans-unit id="d0078b16e6e193ac2fab2fcfbc625d4cc9fdb7f5" translate="yes" xml:space="preserve">
          <source>Code Generation</source>
          <target state="translated">코드 생성</target>
        </trans-unit>
        <trans-unit id="f24dc61405e4a6ac1922198818e95b7dcd3db014" translate="yes" xml:space="preserve">
          <source>Code Loading</source>
          <target state="translated">코드 로딩</target>
        </trans-unit>
        <trans-unit id="b69ba088ce9ad1ce235332dd2372fe802609e0da" translate="yes" xml:space="preserve">
          <source>Code blocks</source>
          <target state="translated">코드 블록</target>
        </trans-unit>
        <trans-unit id="62a9d7c94aa1ad1ba8632efb3563e42b2453a554" translate="yes" xml:space="preserve">
          <source>Code inclusion is quite straightforward and simple: it evaluates the given source file in the context of the caller. Package loading is built on top of code inclusion and serves a &lt;a href=&quot;../modules/index#modules-1&quot;&gt;different purpose&lt;/a&gt;. The rest of this chapter focuses on the behavior and mechanics of package loading.</source>
          <target state="translated">코드 포함은 매우 간단하고 간단합니다. 호출자의 컨텍스트에서 지정된 소스 파일을 평가합니다. 패키지 로딩은 코드 포함 위에 구축되며 &lt;a href=&quot;../modules/index#modules-1&quot;&gt;다른 목적으로 사용&lt;/a&gt; 됩니다. 이 장의 나머지 부분에서는 패키지 로딩의 동작 및 메커니즘에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="35b9be6a9b072a2d90be1ca50990262602cae797" translate="yes" xml:space="preserve">
          <source>Code point(s)</source>
          <target state="translated">코드 포인트</target>
        </trans-unit>
        <trans-unit id="33284c9a71b782e3478512a7869d4dc33c4b362d" translate="yes" xml:space="preserve">
          <source>Code should be as generic as possible. Instead of writing:</source>
          <target state="translated">코드는 가능한 한 일반적이어야합니다. 글을 쓰는 대신 :</target>
        </trans-unit>
        <trans-unit id="aae5cfaaacaac3a30cf57079dd346c86a7f7fc5e" translate="yes" xml:space="preserve">
          <source>Code using immutable objects can be easier to reason about.</source>
          <target state="translated">불변 객체를 사용하는 코드는 추론하기가 더 쉬울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80674c31d4ab113b84f8bfda79f90e7c65f5531a" translate="yes" xml:space="preserve">
          <source>Collect a list of log records generated by &lt;code&gt;expression&lt;/code&gt; using &lt;code&gt;collect_test_logs&lt;/code&gt;, check that they match the sequence &lt;code&gt;log_patterns&lt;/code&gt;, and return the value of &lt;code&gt;expression&lt;/code&gt;. The &lt;code&gt;keywords&lt;/code&gt; provide some simple filtering of log records: the &lt;code&gt;min_level&lt;/code&gt; keyword controls the minimum log level which will be collected for the test, the &lt;code&gt;match_mode&lt;/code&gt; keyword defines how matching will be performed (the default &lt;code&gt;:all&lt;/code&gt; checks that all logs and patterns match pairwise; use &lt;code&gt;:any&lt;/code&gt; to check that the pattern matches at least once somewhere in the sequence.)</source>
          <target state="translated">에 의해 생성 된 로그 기록의 목록을 수집 &lt;code&gt;expression&lt;/code&gt; 사용 &lt;code&gt;collect_test_logs&lt;/code&gt; 을 , 그들은 순서와 일치하는지 확인 &lt;code&gt;log_patterns&lt;/code&gt; 을 , 그리고 값 반환 &lt;code&gt;expression&lt;/code&gt; . &lt;code&gt;keywords&lt;/code&gt; : 로그 레코드의 몇 가지 간단한 필터링을 제공 &lt;code&gt;min_level&lt;/code&gt; 의 키워드 컨트롤의 테스트를 위해 수집됩니다 최소 로그 수준 &lt;code&gt;match_mode&lt;/code&gt; 의 매칭 (수행 방법 키워드가 정의 기본 &lt;code&gt;:all&lt;/code&gt; 검사가 모든 로그와 패턴이 페어를 일치를, 사용 &lt;code&gt;:any&lt;/code&gt; 어딘가에서 패턴이 적어도 한 번 일치하는지 확인하십시오.)</target>
        </trans-unit>
        <trans-unit id="0a8af36fa1d1619f2da90f35bd9c11b35a37e433" translate="yes" xml:space="preserve">
          <source>Collect information about the status of each file in the git repository &lt;code&gt;repo&lt;/code&gt; (e.g. is the file modified, staged, etc.). &lt;code&gt;status_opts&lt;/code&gt; can be used to set various options, for instance whether or not to look at untracked files or whether to include submodules or not. See &lt;a href=&quot;#LibGit2.StatusOptions&quot;&gt;&lt;code&gt;StatusOptions&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">망할 놈의 저장소에있는 각 파일의 상태에 대한 수집 정보 &lt;code&gt;repo&lt;/code&gt; (예를 들면, 무대 등을 수정하는 파일입니다). &lt;code&gt;status_opts&lt;/code&gt; 는 추적되지 않은 파일을 볼지 여부 또는 하위 모듈을 포함할지 여부와 같은 다양한 옵션을 설정하는 데 사용할 수 있습니다. 자세한 내용은 &lt;a href=&quot;#LibGit2.StatusOptions&quot;&gt; &lt;code&gt;StatusOptions&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2e2ef8c695440679e7d61620a3e6f58db57bb36f" translate="yes" xml:space="preserve">
          <source>Collections and Data Structures</source>
          <target state="translated">컬렉션 및 데이터 구조</target>
        </trans-unit>
        <trans-unit id="b600a07f6e2a178ebfbe565ac70dc1d11d80d058" translate="yes" xml:space="preserve">
          <source>Collections passed to functions are also not copied. Functions can modify (mutate) the contents of the objects their arguments refer to. (The names of functions which do this are conventionally suffixed with '!'.)</source>
          <target state="translated">함수에 전달 된 컬렉션도 복사되지 않습니다. 함수는 인수가 참조하는 객체의 내용을 수정 (돌연변이) 할 수 있습니다. (이를 수행하는 함수의 이름은 일반적으로 '!'로 접미사가 붙습니다.)</target>
        </trans-unit>
        <trans-unit id="7a2802907d31a8ef64806a9e6c2120bb1e4caacf" translate="yes" xml:space="preserve">
          <source>Collision Symbol</source>
          <target state="translated">충돌 기호</target>
        </trans-unit>
        <trans-unit id="ac30df75efbedb8442edcd22700caca733d79868" translate="yes" xml:space="preserve">
          <source>Colon</source>
          <target state="translated">Colon</target>
        </trans-unit>
        <trans-unit id="0a14c37ba89fcb5b7168d9ef916ce4e00e67937f" translate="yes" xml:space="preserve">
          <source>Colon Equals / Colon Equal</source>
          <target state="translated">콜론 같음 / 콜론 같음</target>
        </trans-unit>
        <trans-unit id="bb11dae2a053933f6bc7422a2373bf8281b97e57" translate="yes" xml:space="preserve">
          <source>Colons (:) are used to signify indexing entire objects or dimensions at once.</source>
          <target state="translated">콜론 (:)은 전체 개체 또는 차원의 색인을 한 번에 색인화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f95263d15db043d5d52856caad1fadeda6d1c2bc" translate="yes" xml:space="preserve">
          <source>Combinatorics</source>
          <target state="translated">Combinatorics</target>
        </trans-unit>
        <trans-unit id="173cad0d0654b3f6eb52faa1ce6c93b0376b3f89" translate="yes" xml:space="preserve">
          <source>Combined multiply-add: computes &lt;code&gt;x*y+z&lt;/code&gt;, but allowing the add and multiply to be merged with each other or with surrounding operations for performance. For example, this may be implemented as an &lt;a href=&quot;#Base.fma&quot;&gt;&lt;code&gt;fma&lt;/code&gt;&lt;/a&gt; if the hardware supports it efficiently. The result can be different on different machines and can also be different on the same machine due to constant propagation or other optimizations. See &lt;a href=&quot;#Base.fma&quot;&gt;&lt;code&gt;fma&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">복합 곱셈 추가 : &lt;code&gt;x*y+z&lt;/code&gt; 를 계산 하지만 더하기 및 곱하기를 서로 또는 성능을 위해 주변 작업과 병합 할 수 있습니다. 예를 들어, 하드웨어가 효율적으로 지원하는 경우 &lt;a href=&quot;#Base.fma&quot;&gt; &lt;code&gt;fma&lt;/code&gt; &lt;/a&gt; 로 구현 될 수 있습니다 . 결과는 시스템마다 다를 수 있으며 지속적인 전파 또는 기타 최적화로 인해 동일한 시스템에서 다를 수 있습니다. &lt;a href=&quot;#Base.fma&quot;&gt; &lt;code&gt;fma&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b4f01a71c42b25ea3da620732f8db11437dd099b" translate="yes" xml:space="preserve">
          <source>Combining Acute Accent / Non-Spacing Acute</source>
          <target state="translated">급성 악센트 / 비 간격 급성 결합</target>
        </trans-unit>
        <trans-unit id="0734b67961e0eb56239f8b7b60c539fb6834880e" translate="yes" xml:space="preserve">
          <source>Combining Annuity Symbol</source>
          <target state="translated">연금 기호 결합</target>
        </trans-unit>
        <trans-unit id="95ae63a999d098981e7621ee2008c43b0f6a60c6" translate="yes" xml:space="preserve">
          <source>Combining Asterisk Above</source>
          <target state="translated">위의 별표 결합</target>
        </trans-unit>
        <trans-unit id="685cd2e09ad265192e0356f28e46509d84ab4d71" translate="yes" xml:space="preserve">
          <source>Combining Breve / Non-Spacing Breve</source>
          <target state="translated">Breve / Non-Spacing Breve 결합</target>
        </trans-unit>
        <trans-unit id="8e2be6c64a88e84a6f429cab4bdb53ba4fe80660" translate="yes" xml:space="preserve">
          <source>Combining Bridge Below / Non-Spacing Bridge Below</source>
          <target state="translated">아래 다리 / 비 간격 다리 결합</target>
        </trans-unit>
        <trans-unit id="a3f38dbfee0a0277b8fc6dd5b6eb831595bf84a0" translate="yes" xml:space="preserve">
          <source>Combining Candrabindu / Non-Spacing Candrabindu</source>
          <target state="translated">Candrabindu / 비 간격 Candrabindu 결합</target>
        </trans-unit>
        <trans-unit id="8aff768b42edc639adecd3dd04d42d7aed791251" translate="yes" xml:space="preserve">
          <source>Combining Caron / Non-Spacing Hacek</source>
          <target state="translated">카론 / 비 간격 Hacek 결합</target>
        </trans-unit>
        <trans-unit id="3c4e117dd5db64357d4d73eb9cdd1ba25f04fdb1" translate="yes" xml:space="preserve">
          <source>Combining Cedilla / Non-Spacing Cedilla</source>
          <target state="translated">Cedilla / 비 간격 Cedilla 결합</target>
        </trans-unit>
        <trans-unit id="91f0dba538ac66d644d07a8387e2e7e115f196c5" translate="yes" xml:space="preserve">
          <source>Combining Circumflex Accent / Non-Spacing Circumflex</source>
          <target state="translated">Circumflex 악센트 / 비 간격 Circumflex 결합</target>
        </trans-unit>
        <trans-unit id="a43cbdb97b8f699aa2f8714ed59973b90ec0f295" translate="yes" xml:space="preserve">
          <source>Combining Comma Above Right / Non-Spacing Comma Above Right</source>
          <target state="translated">오른쪽 위의 쉼표 결합 / 오른쪽 위의 비 간격 쉼표 결합</target>
        </trans-unit>
        <trans-unit id="a33ec808d6857cd58bedcf6f6f9afde52f57d4fd" translate="yes" xml:space="preserve">
          <source>Combining Diaeresis / Non-Spacing Diaeresis</source>
          <target state="translated">분음 / 비 간격 분만</target>
        </trans-unit>
        <trans-unit id="becaf6a97e81c19ea9f31b976c527ddc1bbea3ee" translate="yes" xml:space="preserve">
          <source>Combining Dot Above / Non-Spacing Dot Above</source>
          <target state="translated">위의 점을 결합 / 위의 비 간격 점</target>
        </trans-unit>
        <trans-unit id="d95e2893d2008e3fc0c1b9bc24115f37f1791066" translate="yes" xml:space="preserve">
          <source>Combining Double Acute Accent / Non-Spacing Double Acute</source>
          <target state="translated">이중 급성 악센트 / 비 간격 이중 급성 결합</target>
        </trans-unit>
        <trans-unit id="f08f92ba4b2bb682dc3e2d5e9c8df57b5dedb3f6" translate="yes" xml:space="preserve">
          <source>Combining Enclosing Circle / Enclosing Circle</source>
          <target state="translated">엔 클로징 서클 / 엔 클로징 서클 결합</target>
        </trans-unit>
        <trans-unit id="83f22c6a001242a5a561f3a7895cf7d7aaaebd0b" translate="yes" xml:space="preserve">
          <source>Combining Enclosing Diamond / Enclosing Diamond</source>
          <target state="translated">엔 클로징 다이아몬드 / 엔 클로징 다이아몬드 결합</target>
        </trans-unit>
        <trans-unit id="ec76e2f012d98e1337784adeec747df1b78cf15b" translate="yes" xml:space="preserve">
          <source>Combining Enclosing Square / Enclosing Square</source>
          <target state="translated">엔 클로징 스퀘어 / 엔 클로징 스퀘어 결합</target>
        </trans-unit>
        <trans-unit id="efc364102d3ca81f092b677aca701ad08ab10de7" translate="yes" xml:space="preserve">
          <source>Combining Enclosing Upward Pointing Triangle</source>
          <target state="translated">위쪽 포인팅 삼각형 둘러싸 기</target>
        </trans-unit>
        <trans-unit id="22bab50c74edd0eb4d138ac01ac71ba994064528" translate="yes" xml:space="preserve">
          <source>Combining Four Dots Above / Non-Spacing Four Dots Above</source>
          <target state="translated">위의 네 개의 점 결합 / 위의 비 간격 네 점</target>
        </trans-unit>
        <trans-unit id="38e73c84dac801257b0f5e15b8402de9de60fd4a" translate="yes" xml:space="preserve">
          <source>Combining Grave Accent / Non-Spacing Grave</source>
          <target state="translated">그레이브 악센트 / 비 간격 그레이브 결합</target>
        </trans-unit>
        <trans-unit id="fb49a0f3994aaa3fea7e9d53f4e24c6dd93638a6" translate="yes" xml:space="preserve">
          <source>Combining Hook Above / Non-Spacing Hook Above</source>
          <target state="translated">위의 후크 결합 / 비 간격 후크</target>
        </trans-unit>
        <trans-unit id="4cb010ffd9ffa4a05013b3488b30c23afb01fdf1" translate="yes" xml:space="preserve">
          <source>Combining Left Angle Above / Non-Spacing Left Angle Above</source>
          <target state="translated">위의 왼쪽 각도 결합 / 비 간격의 왼쪽 각도</target>
        </trans-unit>
        <trans-unit id="08e42cf0385a0528419967690402d2f77fea8ecf" translate="yes" xml:space="preserve">
          <source>Combining Left Arrow Above / Non-Spacing Left Arrow Above</source>
          <target state="translated">위의 왼쪽 화살표 결합 / 비 간격의 왼쪽 화살표</target>
        </trans-unit>
        <trans-unit id="877d024a8659b4afa7238332933b7ad143528441" translate="yes" xml:space="preserve">
          <source>Combining Left Arrow Below</source>
          <target state="translated">아래 왼쪽 화살표 결합</target>
        </trans-unit>
        <trans-unit id="8e6257e591a7e8d45ef0764ba2aea89c01420024" translate="yes" xml:space="preserve">
          <source>Combining Left Harpoon Above / Non-Spacing Left Harpoon Above</source>
          <target state="translated">위의 왼쪽 작살 결합 / 비 간격의 왼쪽 작살 결합</target>
        </trans-unit>
        <trans-unit id="98b334c8eb46b8b78fdd86ea856a3c01a529a309" translate="yes" xml:space="preserve">
          <source>Combining Left Right Arrow Above / Non-Spacing Left Right Arrow Above</source>
          <target state="translated">위의 왼쪽 오른쪽 화살표 결합 / 위의 비 간격 왼쪽 오른쪽 화살표 결합</target>
        </trans-unit>
        <trans-unit id="cedc5fa73afb530ac1a47e52244635331691700e" translate="yes" xml:space="preserve">
          <source>Combining Left Right Arrow Below</source>
          <target state="translated">아래 왼쪽 오른쪽 화살표 결합</target>
        </trans-unit>
        <trans-unit id="3ecd111368eb8e38f96414851bb4b26f50509766" translate="yes" xml:space="preserve">
          <source>Combining Leftwards Harpoon With Barb Downwards</source>
          <target state="translated">왼쪽으로 작살과 바브를 아래쪽으로 결합</target>
        </trans-unit>
        <trans-unit id="0dfea306ba6d2c2199ba2e9e71aebfc34b9abf34" translate="yes" xml:space="preserve">
          <source>Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">Long Solidus 오버레이 / 비 간격 Long 슬래시 오버레이 결합</target>
        </trans-unit>
        <trans-unit id="9f887140bfcfd6f9e5fb967ba98a3207c8b16bb7" translate="yes" xml:space="preserve">
          <source>Combining Long Stroke Overlay / Non-Spacing Long Bar Overlay</source>
          <target state="translated">롱 스트로크 오버레이 / 비 간격 롱 바 오버레이 결합</target>
        </trans-unit>
        <trans-unit id="739259d807921f9f328b7781ee790a60e450a0a1" translate="yes" xml:space="preserve">
          <source>Combining Long Vertical Line Overlay / Non-Spacing Long Vertical Bar Overlay</source>
          <target state="translated">긴 세로 선 오버레이 / 비 간격 긴 세로 막대 오버레이 결합</target>
        </trans-unit>
        <trans-unit id="2fa244bc31952195840fcfc3a299980dbf801f6f" translate="yes" xml:space="preserve">
          <source>Combining Low Line / Non-Spacing Underscore</source>
          <target state="translated">로우 라인 / 비 간격 밑줄 결합</target>
        </trans-unit>
        <trans-unit id="bf4b2a4b27fa69268427f002d7db69ac9dc2b07c" translate="yes" xml:space="preserve">
          <source>Combining Macron / Non-Spacing Macron</source>
          <target state="translated">마크로 / 비 간격 마크로 결합</target>
        </trans-unit>
        <trans-unit id="a27d4c9bf29370f4faabca36676f0b74743a74d7" translate="yes" xml:space="preserve">
          <source>Combining Ogonek / Non-Spacing Ogonek</source>
          <target state="translated">Ogonek / 비 간격 Ogonek 결합</target>
        </trans-unit>
        <trans-unit id="6d0be0f1d7e1edefb9f72a94ba4677970ba978c9" translate="yes" xml:space="preserve">
          <source>Combining Overline / Non-Spacing Overscore</source>
          <target state="translated">오버 라인 / 비 간격 오버 스코어 결합</target>
        </trans-unit>
        <trans-unit id="7fad7b377dc7ab955143e3c864e92020afd810c8" translate="yes" xml:space="preserve">
          <source>Combining Palatalized Hook Below / Non-Spacing Palatalized Hook Below</source>
          <target state="translated">아래 팔라타 이징 후크 결합 / 비 간격 팔라타 이징 후크 아래</target>
        </trans-unit>
        <trans-unit id="a8de9e264b7b283c54023c71a0b50c54c5639e6e" translate="yes" xml:space="preserve">
          <source>Combining Retroflex Hook Below / Non-Spacing Retroflex Hook Below</source>
          <target state="translated">아래 Retroflex 후크 결합 / 비 간격 Retroflex 후크 아래</target>
        </trans-unit>
        <trans-unit id="2ba0d1fd66790c9bf8dd50de28c5fd6f05110ed4" translate="yes" xml:space="preserve">
          <source>Combining Right Arrow Above / Non-Spacing Right Arrow Above</source>
          <target state="translated">위 오른쪽 화살표 / 비 간격 오른쪽 화살표 결합</target>
        </trans-unit>
        <trans-unit id="8a30e8c07ae1959f3cd09497d8080f6227316b77" translate="yes" xml:space="preserve">
          <source>Combining Right Arrow Below</source>
          <target state="translated">아래 오른쪽 화살표 결합</target>
        </trans-unit>
        <trans-unit id="4befcc9e0a743f1dd40b3e9e50041b9252baebcb" translate="yes" xml:space="preserve">
          <source>Combining Right Harpoon Above / Non-Spacing Right Harpoon Above</source>
          <target state="translated">위 오른쪽 오른쪽 작살 / 비 간격 오른쪽 작살 결합</target>
        </trans-unit>
        <trans-unit id="aeddc0f0eef5dd1ae0bb9d2d0caf8ade2b689afe" translate="yes" xml:space="preserve">
          <source>Combining Rightwards Harpoon With Barb Downwards</source>
          <target state="translated">오른쪽 아래쪽 작살과 Barb 아래쪽으로 결합</target>
        </trans-unit>
        <trans-unit id="59a9a29108a67d4f908b40c8ecffadfd41391c2c" translate="yes" xml:space="preserve">
          <source>Combining Ring Above / Non-Spacing Ring Above</source>
          <target state="translated">위의 링 / 비 간격 링 결합</target>
        </trans-unit>
        <trans-unit id="5111c307faa772b3a9538095159cefe4c37acd0e" translate="yes" xml:space="preserve">
          <source>Combining Three Dots Above / Non-Spacing Three Dots Above</source>
          <target state="translated">위의 3 개의 점 결합 / 비 간격 3 개의 점</target>
        </trans-unit>
        <trans-unit id="b28cdba8bdbc1c8dbf325c4c84adf50cfa7b9f07" translate="yes" xml:space="preserve">
          <source>Combining Tilde / Non-Spacing Tilde</source>
          <target state="translated">틸드 / 비 간격 틸드 결합</target>
        </trans-unit>
        <trans-unit id="415941ac9a1882af5b80885af204940e2087908c" translate="yes" xml:space="preserve">
          <source>Combining Tilde Below / Non-Spacing Tilde Below</source>
          <target state="translated">아래 물결표 결합 / 비 간격 물결표 아래</target>
        </trans-unit>
        <trans-unit id="890e5eec0caff7a7e81de77d0eefa045a1434041" translate="yes" xml:space="preserve">
          <source>Combining Triple Underdot</source>
          <target state="translated">트리플 언더 도트 결합</target>
        </trans-unit>
        <trans-unit id="308897e651f5347eeb783d7242b9d33cce1a8f1b" translate="yes" xml:space="preserve">
          <source>Combining Turned Comma Above / Non-Spacing Turned Comma Above</source>
          <target state="translated">회전 쉼표 위 / 비 간격 회전 쉼표 결합</target>
        </trans-unit>
        <trans-unit id="866e577b99c41379b3aa42c4489796f50fe38cc1" translate="yes" xml:space="preserve">
          <source>Combining Wide Bridge Above</source>
          <target state="translated">위의 넓은 다리를 결합</target>
        </trans-unit>
        <trans-unit id="88113a7dbb8d79749cd6e0f0600302ccfd5aa3c0" translate="yes" xml:space="preserve">
          <source>Combining dot operators with numeric literals can be ambiguous. For example, it is not clear whether &lt;code&gt;1.+x&lt;/code&gt; means &lt;code&gt;1. + x&lt;/code&gt; or &lt;code&gt;1 .+ x&lt;/code&gt;. Therefore this syntax is disallowed, and spaces must be used around the operator in such cases.</source>
          <target state="translated">도트 연산자를 숫자 리터럴과 결합하면 모호 할 수 있습니다. 예를 들어,인지 분명하지 않다 &lt;code&gt;1.+x&lt;/code&gt; 수단 &lt;code&gt;1. + x&lt;/code&gt; 또는 &lt;code&gt;1 .+ x&lt;/code&gt; . 따라서이 구문은 허용되지 않으며 이러한 경우 연산자 주위에 공백을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="153d7a58b3a3e898fcbdd04c462af308414bd09d" translate="yes" xml:space="preserve">
          <source>Comment</source>
          <target state="translated">Comment</target>
        </trans-unit>
        <trans-unit id="8ddf0393cc298edc03dc88f0719f2655cd0574b7" translate="yes" xml:space="preserve">
          <source>Commit all currently buffered writes to the given stream.</source>
          <target state="translated">현재 버퍼링 된 모든 쓰기를 지정된 스트림에 커밋합니다.</target>
        </trans-unit>
        <trans-unit id="a347aae8b8a9fc1e2f6210e5e5378437485857d4" translate="yes" xml:space="preserve">
          <source>Commit the current patch to the rebase &lt;code&gt;rb&lt;/code&gt;, using &lt;code&gt;sig&lt;/code&gt; as the committer. Is silent if the commit has already been applied.</source>
          <target state="translated">&lt;code&gt;sig&lt;/code&gt; 를 커미터로 사용하여 현재 패치를 rebase &lt;code&gt;rb&lt;/code&gt; 에 커밋하십시오. 커밋이 이미 적용된 경우 자동입니다.</target>
        </trans-unit>
        <trans-unit id="2be9168624323737db43ee381ca8992f9a73de9d" translate="yes" xml:space="preserve">
          <source>Common Operations</source>
          <target state="translated">일반적인 작업</target>
        </trans-unit>
        <trans-unit id="66508cd4da8f90000c3284eb64d70b8945911d14" translate="yes" xml:space="preserve">
          <source>Compact WY form of the QR factorization</source>
          <target state="translated">QR 분해의 소형 WY 양식</target>
        </trans-unit>
        <trans-unit id="6bf1e82b56d17bf4bd651ed651f5ad4b9fb92d04" translate="yes" xml:space="preserve">
          <source>Compare how these results differ:</source>
          <target state="translated">이 결과가 어떻게 다른지 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="3937ff70415e32705a844575737929096286a5fd" translate="yes" xml:space="preserve">
          <source>Compare two strings. Return &lt;code&gt;0&lt;/code&gt; if both strings have the same length and the character at each index is the same in both strings. Return &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is a prefix of &lt;code&gt;b&lt;/code&gt;, or if &lt;code&gt;a&lt;/code&gt; comes before &lt;code&gt;b&lt;/code&gt; in alphabetical order. Return &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;b&lt;/code&gt; is a prefix of &lt;code&gt;a&lt;/code&gt;, or if &lt;code&gt;b&lt;/code&gt; comes before &lt;code&gt;a&lt;/code&gt; in alphabetical order (technically, lexicographical order by Unicode code points).</source>
          <target state="translated">두 문자열을 비교하십시오. 반환 &lt;code&gt;0&lt;/code&gt; 을 두 문자열이 동일한 길이와 각 인덱스에있는 문자는 모두 문자열에서 동일해야합니다. 돌아 &lt;code&gt;-1&lt;/code&gt; 경우 &lt;code&gt;a&lt;/code&gt; 의 접두어 &lt;code&gt;b&lt;/code&gt; 는 경우, 또는 &lt;code&gt;a&lt;/code&gt; 는 앞에 오는 &lt;code&gt;b&lt;/code&gt; 알파벳 순서로한다. 반환 &lt;code&gt;1&lt;/code&gt; 하면 &lt;code&gt;b&lt;/code&gt; 의 접두어 경우, 또는 &lt;code&gt;b&lt;/code&gt; 는 앞에 오는 알파벳 순서 (기술적, 유니 코드 코드 포인트에 의한 사전 순). &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3294837eea456d1d9b5c37c0aa8f59ea86b3c495" translate="yes" xml:space="preserve">
          <source>Comparison &amp;ndash; &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;asymp;&lt;/code&gt; (&lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt;&lt;code&gt;isapprox&lt;/code&gt;&lt;/a&gt;), &lt;code&gt;≉&lt;/code&gt;</source>
          <target state="translated">비교 - &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt; , &lt;code&gt;&amp;asymp;&lt;/code&gt; ( &lt;a href=&quot;../../base/math/index#Base.isapprox&quot;&gt; &lt;code&gt;isapprox&lt;/code&gt; &lt;/a&gt; ), &lt;code&gt;≉&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5bfbdf2ba206862934e1703fb9dabae9ccfe529b" translate="yes" xml:space="preserve">
          <source>Comparison with &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt;&lt;code&gt;backtrace&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt; &lt;code&gt;backtrace&lt;/code&gt; &lt;/a&gt; 과 비교</target>
        </trans-unit>
        <trans-unit id="e46ee00fde40e955c86abe019a61121e06d653c9" translate="yes" xml:space="preserve">
          <source>Comparisons</source>
          <target state="translated">Comparisons</target>
        </trans-unit>
        <trans-unit id="a1f782aa0dd22ca1d8ddd5007091a2531356eecb" translate="yes" xml:space="preserve">
          <source>Compile the given function &lt;code&gt;f&lt;/code&gt; for the argument tuple (of types) &lt;code&gt;args&lt;/code&gt;, but do not execute it.</source>
          <target state="translated">인수 tuple (유형) &lt;code&gt;args&lt;/code&gt; 에 대해 주어진 함수 &lt;code&gt;f&lt;/code&gt; 를 컴파일 하되 실행하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="d208cd655bc27c326dbf72e200351336cfc4e60e" translate="yes" xml:space="preserve">
          <source>Complement</source>
          <target state="translated">Complement</target>
        </trans-unit>
        <trans-unit id="05138c0edd56f7bbbd9cae9c6f481c62b93d161a" translate="yes" xml:space="preserve">
          <source>Completion of paths works for strings and julia's shell mode:</source>
          <target state="translated">경로 완성은 문자열과 julia의 쉘 모드에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="10b26b96b1c573965f14a325ef88109f84be8e3b" translate="yes" xml:space="preserve">
          <source>Complex</source>
          <target state="translated">Complex</target>
        </trans-unit>
        <trans-unit id="ff549706d081e3e60cc13e4b49b48c707d5b0c58" translate="yes" xml:space="preserve">
          <source>Complex Example</source>
          <target state="translated">복잡한 예</target>
        </trans-unit>
        <trans-unit id="c73def212afdc811169afd7e77aebfbeecb5facc" translate="yes" xml:space="preserve">
          <source>Complex Numbers</source>
          <target state="translated">복소수</target>
        </trans-unit>
        <trans-unit id="d92056b9511d12d7ca9a02729b4db7f33b444189" translate="yes" xml:space="preserve">
          <source>Complex and Rational Numbers</source>
          <target state="translated">복소수 및 유리수</target>
        </trans-unit>
        <trans-unit id="4bf180d1d0870c204edb37eb372ac0df5d17b6dd" translate="yes" xml:space="preserve">
          <source>Complex blocks:</source>
          <target state="translated">복잡한 블록 :</target>
        </trans-unit>
        <trans-unit id="0a73edd8fc9653ee436727fd08c0b9f3b06b1113" translate="yes" xml:space="preserve">
          <source>Complex method &quot;cascades&quot; with default arguments</source>
          <target state="translated">기본 인수가있는 복잡한 메소드 &quot;계단식&quot;</target>
        </trans-unit>
        <trans-unit id="f9ed4ba22fe6a41d861b48b53689d9f5e1620b3b" translate="yes" xml:space="preserve">
          <source>Complex number type with real and imaginary part of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 의 실수 부와 허수 부를 가진 복소수 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="c92c529e0731c57efd7550480196484040b33c3e" translate="yes" xml:space="preserve">
          <source>Component</source>
          <target state="translated">Component</target>
        </trans-unit>
        <trans-unit id="b4dd6b3b31c6eea3e9660b73bc2f3101abdfba71" translate="yes" xml:space="preserve">
          <source>Compose functions: i.e. &lt;code&gt;(f ∘ g)(args...)&lt;/code&gt; means &lt;code&gt;f(g(args...))&lt;/code&gt;. The &lt;code&gt;∘&lt;/code&gt; symbol can be entered in the Julia REPL (and most editors, appropriately configured) by typing &lt;code&gt;\circ&amp;lt;tab&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">작성 함수 : 즉 &lt;code&gt;(f ∘ g)(args...)&lt;/code&gt; 는 &lt;code&gt;f(g(args...))&lt;/code&gt; 합니다. &lt;code&gt;∘&lt;/code&gt; 기호 입력하여 (적절하게 구성된 대부분의 편집자) 줄리아 REPL에 입력 할 수 있습니다 &lt;code&gt;\circ&amp;lt;tab&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7bf0ab10fb9860e23b1ca89e4313be7fafb258f7" translate="yes" xml:space="preserve">
          <source>Composite Types</source>
          <target state="translated">복합 유형</target>
        </trans-unit>
        <trans-unit id="df2490ae2d6c4446ef7afd32a3da2e5ee7b69ac4" translate="yes" xml:space="preserve">
          <source>Composite objects declared with &lt;code&gt;struct&lt;/code&gt; are &lt;em&gt;immutable&lt;/em&gt;; they cannot be modified after construction. This may seem odd at first, but it has several advantages:</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; 로 선언 된 복합 객체 는 &lt;em&gt;변경할 수 없습니다&lt;/em&gt; . 시공 후에는 수정할 수 없습니다. 처음에는 이상하게 보일 수 있지만 몇 가지 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="01e0dcd858e537fe0307f2358a312f03c6681c12" translate="yes" xml:space="preserve">
          <source>Composite types are introduced with the &lt;a href=&quot;../../base/base/index#struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; keyword followed by a block of field names, optionally annotated with types using the &lt;code&gt;::&lt;/code&gt; operator:</source>
          <target state="translated">복합 유형은 &lt;a href=&quot;../../base/base/index#struct&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt; 키워드 와 함께 필드 이름 블록이 뒤 따르며, 선택적으로 &lt;code&gt;::&lt;/code&gt; 연산자를 사용하여 유형이 주석으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="5701f0731819052a01bc826ae56db27fca5211d9" translate="yes" xml:space="preserve">
          <source>Composite types, aka &lt;code&gt;struct&lt;/code&gt; in C or &lt;code&gt;TYPE&lt;/code&gt; in Fortran90 (or &lt;code&gt;STRUCTURE&lt;/code&gt; / &lt;code&gt;RECORD&lt;/code&gt; in some variants of F77), can be mirrored in Julia by creating a &lt;code&gt;struct&lt;/code&gt; definition with the same field layout.</source>
          <target state="translated">복합 형 일명 &lt;code&gt;struct&lt;/code&gt; C 또는 &lt;code&gt;TYPE&lt;/code&gt; Fortran90에서 (또는 &lt;code&gt;STRUCTURE&lt;/code&gt; / &lt;code&gt;RECORD&lt;/code&gt; 일부는 F77 변종은)와, 만들어 줄리아에 반영 될 수 &lt;code&gt;struct&lt;/code&gt; 동일한 필드 레이아웃을 정의한다.</target>
        </trans-unit>
        <trans-unit id="7544d508f3b0902a380eab3d1ae0e5d8d3c1b60c" translate="yes" xml:space="preserve">
          <source>CompositeException</source>
          <target state="translated">CompositeException</target>
        </trans-unit>
        <trans-unit id="b29eeb6459e95f17b9e773f8892492e90000d531" translate="yes" xml:space="preserve">
          <source>Compound Expressions</source>
          <target state="translated">복합 표현</target>
        </trans-unit>
        <trans-unit id="3c63c3a24b2a5e684ce3eb80765c227218a808f0" translate="yes" xml:space="preserve">
          <source>Compound methods are provided, as they provide a measure of efficiency if multiple fields are needed at the same time:</source>
          <target state="translated">여러 필드가 동시에 필요한 경우 효율성을 측정 할 수있는 복합 방법이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="ed2ff637c10fb1755e29c0eb2376d67d8e5a91b4" translate="yes" xml:space="preserve">
          <source>Comprehensions</source>
          <target state="translated">Comprehensions</target>
        </trans-unit>
        <trans-unit id="8e547d2519645c376aaf30ba92bb6080596e3ef5" translate="yes" xml:space="preserve">
          <source>Comprehensions can also be written without the enclosing square brackets, producing an object known as a generator. This object can be iterated to produce values on demand, instead of allocating an array and storing them in advance (see &lt;a href=&quot;#Iteration-1&quot;&gt;Iteration&lt;/a&gt;). For example, the following expression sums a series without allocating memory:</source>
          <target state="translated">둘러싸는 대괄호 없이도 이해를 작성하여 생성기라고하는 객체를 생성 할 수 있습니다. 이 목적은 대신 배열을 할당하고 (참조 사전에 저장의 수요에 값을 생성하기 위해 반복 될 수있는 &lt;a href=&quot;#Iteration-1&quot;&gt;반복&lt;/a&gt; ). 예를 들어, 다음 표현식은 메모리를 할당하지 않고 시리즈를 합칩니다.</target>
        </trans-unit>
        <trans-unit id="908bf8150b71b44066207c270126a10d2c63b84b" translate="yes" xml:space="preserve">
          <source>Comprehensions provide a general and powerful way to construct arrays. Comprehension syntax is similar to set construction notation in mathematics:</source>
          <target state="translated">이해는 배열을 구성하는 일반적이고 강력한 방법을 제공합니다. 이해 구문은 수학의 구성 표기법과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="41931e1bad3441e4fffdabe12a675d7a10ef5fe7" translate="yes" xml:space="preserve">
          <source>Compressed Sparse Column (CSC) Sparse Matrix Storage</source>
          <target state="translated">압축 스파 스 열 (CSC) 스파 스 매트릭스 스토리지</target>
        </trans-unit>
        <trans-unit id="df6e999370e627bd7fb17556cf85a2f9046d57dd" translate="yes" xml:space="preserve">
          <source>Compute $10^x$.</source>
          <target state="translated">$ 10 ^ x $를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="3440d15eee03e7b747a1a78d06bc04de26352e6b" translate="yes" xml:space="preserve">
          <source>Compute $\cos(\pi x) / x - \sin(\pi x) / (\pi x^2)$ if $x \neq 0$, and $0$ if $x = 0$. This is the derivative of &lt;code&gt;sinc(x)&lt;/code&gt;.</source>
          <target state="translated">$ x \ neq 0 $ 인 경우 $ \ cos (\ pi x) / x-\ sin (\ pi x) / (\ pi x ^ 2) $를 계산하고 $ x = 0 $ 인 경우 $ 0 $를 계산합니다. 이것은 &lt;code&gt;sinc(x)&lt;/code&gt; 의 미분입니다 .</target>
        </trans-unit>
        <trans-unit id="641b97c82ee25690f10e6e7742dc51e5d15732ca" translate="yes" xml:space="preserve">
          <source>Compute $\cos(\pi x)$ more accurately than &lt;code&gt;cos(pi*x)&lt;/code&gt;, especially for large &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">보다 정확하게 $ \ cos (\ pi x) $ 계산 &lt;code&gt;cos(pi*x)&lt;/code&gt; 특히 큰 &lt;code&gt;x&lt;/code&gt; 의 경우 cos (pi * x) .</target>
        </trans-unit>
        <trans-unit id="1b6e2580104ead79696c9bd035d3ea44c420e327" translate="yes" xml:space="preserve">
          <source>Compute $\sin(\pi x) / (\pi x)$ if $x \neq 0$, and $1$ if $x = 0$.</source>
          <target state="translated">$ x \ neq 0 $이면 $ \ sin (\ pi x) / (\ pi x) $를 계산하고 $ x = 0 $이면 $ 1 $를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="5609ddf7e7650835bda46710354a43594cc254bb" translate="yes" xml:space="preserve">
          <source>Compute $\sin(\pi x)$ more accurately than &lt;code&gt;sin(pi*x)&lt;/code&gt;, especially for large &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sin(pi*x)&lt;/code&gt; 보다 $ \ sin (\ pi x) $를 더 정확하게 계산 특히 큰 &lt;code&gt;x&lt;/code&gt; 의 경우) .</target>
        </trans-unit>
        <trans-unit id="929982bef54c338e6e35e28527b86375aafc50c8" translate="yes" xml:space="preserve">
          <source>Compute $x \times 2^n$.</source>
          <target state="translated">$ x \ times 2 ^ n $를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="64de6f27384f256461bed9916267c818d5e5214a" translate="yes" xml:space="preserve">
          <source>Compute $x^p \pmod m$.</source>
          <target state="translated">$ x ^ p \ pmod m $를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="19ceaddf89a47393966a49ad36ca860fe7e80321" translate="yes" xml:space="preserve">
          <source>Compute &lt;code&gt;A / B&lt;/code&gt; in-place and overwriting &lt;code&gt;A&lt;/code&gt; to store the result.</source>
          <target state="translated">전체 &lt;code&gt;A / B&lt;/code&gt; 계산 및 &lt;code&gt;A&lt;/code&gt; 덮어 쓰기 를 하여 결과를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="7f0218a9f1bc487c2b5096445bf17474b3168d25" translate="yes" xml:space="preserve">
          <source>Compute &lt;code&gt;A \ B&lt;/code&gt; in-place and overwriting &lt;code&gt;B&lt;/code&gt; to store the result.</source>
          <target state="translated">내부 &lt;code&gt;A \ B&lt;/code&gt; 및 B 계산 및 &lt;code&gt;B&lt;/code&gt; 덮어 쓰기 를 하여 결과를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="fec3a07dc37940dceabb5be53b362461307a4c1d" translate="yes" xml:space="preserve">
          <source>Compute &lt;code&gt;A \ B&lt;/code&gt; in-place and store the result in &lt;code&gt;Y&lt;/code&gt;, returning the result.</source>
          <target state="translated">&lt;code&gt;A \ B&lt;/code&gt; 를 내부 에서 계산 하고 결과를 &lt;code&gt;Y&lt;/code&gt; 에 저장 반환합니다.</target>
        </trans-unit>
        <trans-unit id="98e6c5fec537a69040a39ae887c67e4d70213543" translate="yes" xml:space="preserve">
          <source>Compute a convenient factorization of &lt;code&gt;A&lt;/code&gt;, based upon the type of the input matrix. &lt;code&gt;factorize&lt;/code&gt; checks &lt;code&gt;A&lt;/code&gt; to see if it is symmetric/triangular/etc. if &lt;code&gt;A&lt;/code&gt; is passed as a generic matrix. &lt;code&gt;factorize&lt;/code&gt; checks every element of &lt;code&gt;A&lt;/code&gt; to verify/rule out each property. It will short-circuit as soon as it can rule out symmetry/triangular structure. The return value can be reused for efficient solving of multiple systems. For example: &lt;code&gt;A=factorize(A); x=A\b; y=A\C&lt;/code&gt;.</source>
          <target state="translated">입력 행렬의 유형에 따라 &lt;code&gt;A&lt;/code&gt; 의 편리한 인수 분해를 계산합니다 . &lt;code&gt;factorize&lt;/code&gt; 검사 &lt;code&gt;A&lt;/code&gt; 는 이 대칭 / 삼각 / 등의 경우에 볼 수 있습니다. &lt;code&gt;A&lt;/code&gt; 가 일반 행렬로 전달되는 경우 &lt;code&gt;factorize&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 의 모든 요소를 ​​검사 하여 각 속성을 확인 / 거부합니다. 대칭 / 삼각형 구조를 배제 할 수있는 즉시 단락됩니다. 여러 시스템을 효율적으로 해결하기 위해 반환 값을 재사용 할 수 있습니다. 예를 들면 : &lt;code&gt;A=factorize(A); x=A\b; y=A\C&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="081b8630c615f09be39d92a0115c25e75916aff0" translate="yes" xml:space="preserve">
          <source>Compute a type that contains the intersection of &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;S&lt;/code&gt;. Usually this will be the smallest such type or one close to it.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;S&lt;/code&gt; 의 교집합이 포함 된 유형을 계산합니다. . 일반적으로 이것은 가장 작은 유형이거나 가장 가까운 유형입니다.</target>
        </trans-unit>
        <trans-unit id="db62a7195b361bd27a6ab49b26fc5d995d7a85c5" translate="yes" xml:space="preserve">
          <source>Compute an &lt;code&gt;LDLt&lt;/code&gt; factorization of the real symmetric tridiagonal matrix &lt;code&gt;S&lt;/code&gt; such that &lt;code&gt;S = L*Diagonal(d)*L'&lt;/code&gt; where &lt;code&gt;L&lt;/code&gt; is a unit lower triangular matrix and &lt;code&gt;d&lt;/code&gt; is a vector. The main use of an &lt;code&gt;LDLt&lt;/code&gt; factorization &lt;code&gt;F = ldlt(S)&lt;/code&gt; is to solve the linear system of equations &lt;code&gt;Sx = b&lt;/code&gt; with &lt;code&gt;F\b&lt;/code&gt;.</source>
          <target state="translated">계산 &lt;code&gt;LDLt&lt;/code&gt; 실제의 인수를 대칭 삼중 대각 행렬 &lt;code&gt;S&lt;/code&gt; 되도록 &lt;code&gt;S = L*Diagonal(d)*L'&lt;/code&gt; &lt;code&gt;L&lt;/code&gt; 은 단위 하 삼각 행렬이고 &lt;code&gt;d&lt;/code&gt; 벡터이다. 의 주 사용 &lt;code&gt;LDLt&lt;/code&gt; 인수 &lt;code&gt;F = ldlt(S)&lt;/code&gt; 선형 방정식들의 시스템을 해결하기 &lt;code&gt;Sx = b&lt;/code&gt; 와 &lt;code&gt;F\b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c1ac6c08b678223e4887392c381e9189c7ba93b" translate="yes" xml:space="preserve">
          <source>Compute an integer hash code such that &lt;code&gt;isequal(x,y)&lt;/code&gt; implies &lt;code&gt;hash(x)==hash(y)&lt;/code&gt;. The optional second argument &lt;code&gt;h&lt;/code&gt; is a hash code to be mixed with the result.</source>
          <target state="translated">&lt;code&gt;isequal(x,y)&lt;/code&gt; &lt;code&gt;hash(x)==hash(y)&lt;/code&gt; 암시 하는 정수 해시 코드를 계산하십시오 . 선택적 두 번째 인수 &lt;code&gt;h&lt;/code&gt; 는 결과와 혼합 될 해시 코드입니다.</target>
        </trans-unit>
        <trans-unit id="79e6e6b92700158abe5cbe60e135ba2eff400933" translate="yes" xml:space="preserve">
          <source>Compute both the minimum and maximum element in a single pass, and return them as a 2-tuple.</source>
          <target state="translated">단일 패스에서 최소 및 최대 요소를 모두 계산하고 2- 튜플로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="55674d923cbe36a00a2dcb12dc90008788433dbf" translate="yes" xml:space="preserve">
          <source>Compute both the minimum and maximum of &lt;code&gt;f&lt;/code&gt; applied to each element in &lt;code&gt;itr&lt;/code&gt; and return them as a 2-tuple. Only one pass is made over &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;itr&lt;/code&gt; 의 각 요소에 적용되는 최소 및 최대 &lt;code&gt;f&lt;/code&gt; 를 모두 계산 하여 2 튜플로 반환합니다. &lt;code&gt;itr&lt;/code&gt; 에는 한 번만 패스됩니다 .</target>
        </trans-unit>
        <trans-unit id="9fc034d752a929a676df33e97329f28013afb4ac" translate="yes" xml:space="preserve">
          <source>Compute cosine of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in degrees.</source>
          <target state="translated">의 계산 코사인 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; 도이다.</target>
        </trans-unit>
        <trans-unit id="2812b6470b645598b89e13c27d80693c2571602e" translate="yes" xml:space="preserve">
          <source>Compute cosine of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in radians.</source>
          <target state="translated">의 계산 코사인 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; 라디안이다.</target>
        </trans-unit>
        <trans-unit id="ed29aab024d008c6bdfa953e7bd9ab905379d015" translate="yes" xml:space="preserve">
          <source>Compute hyperbolic cosine of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 쌍곡 코사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="ec21c723d13f003816fe96579a7df0d489520259" translate="yes" xml:space="preserve">
          <source>Compute hyperbolic sine of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 쌍곡 사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="ac3565a823d4a3efc52e74fc685ed86ae6db58a3" translate="yes" xml:space="preserve">
          <source>Compute hyperbolic tangent of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 쌍곡 탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="c3738eef2209a39b21f53d71ed43b07f931e624c" translate="yes" xml:space="preserve">
          <source>Compute sine of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in degrees.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 사인을 계산 합니다. 여기서 &lt;code&gt;x&lt;/code&gt; 는 도입니다.</target>
        </trans-unit>
        <trans-unit id="6cf01364af065ae849f27852465a3d3bfe52089d" translate="yes" xml:space="preserve">
          <source>Compute sine of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in radians.</source>
          <target state="translated">의 계산 사인 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; 라디안이다.</target>
        </trans-unit>
        <trans-unit id="c2d206b82e6db8e986bbbf98cbf0eb72129c224a" translate="yes" xml:space="preserve">
          <source>Compute tangent of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in degrees.</source>
          <target state="translated">계산의 접선 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; 도이다.</target>
        </trans-unit>
        <trans-unit id="202a93fa28b48e329210fdf808f2d1b87daa3ed4" translate="yes" xml:space="preserve">
          <source>Compute tangent of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in radians.</source>
          <target state="translated">계산의 접선 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; 라디안이다.</target>
        </trans-unit>
        <trans-unit id="0dbf493148049741c81504ff6b4e5ee8560f996f" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;LQ&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = LQ&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A = LQ&lt;/code&gt; 의 &lt;code&gt;LQ&lt;/code&gt; 인수 분해를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="17538b08e9c154c3f5dd62072c8fa0ea05f963fc" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;LQ&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = LQ&lt;/code&gt;. &lt;code&gt;tau&lt;/code&gt; contains scalars which parameterize the elementary reflectors of the factorization. &lt;code&gt;tau&lt;/code&gt; must have length greater than or equal to the smallest dimension of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A = LQ&lt;/code&gt; 의 &lt;code&gt;LQ&lt;/code&gt; 인수 분해를 계산합니다 . &lt;code&gt;tau&lt;/code&gt; 는 인수 분해의 기본 반사기를 매개 변수화하는 스칼라를 포함합니다. &lt;code&gt;tau&lt;/code&gt; 의 길이는 &lt;code&gt;A&lt;/code&gt; 의 최소 ​​치수보다 크거나 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="6ad780cc4431af9be511082a782160bff6da4c65" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;QL&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = QL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A = QL&lt;/code&gt; 의 &lt;code&gt;QL&lt;/code&gt; 인수 분해를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="f7a649b9c569a9a9a900055ad2e3e530ad769e9f" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;QL&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = QL&lt;/code&gt;. &lt;code&gt;tau&lt;/code&gt; contains scalars which parameterize the elementary reflectors of the factorization. &lt;code&gt;tau&lt;/code&gt; must have length greater than or equal to the smallest dimension of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A = QL&lt;/code&gt; 의 &lt;code&gt;QL&lt;/code&gt; 인수 분해를 계산합니다 . &lt;code&gt;tau&lt;/code&gt; 는 인수 분해의 기본 반사기를 매개 변수화하는 스칼라를 포함합니다. &lt;code&gt;tau&lt;/code&gt; 의 길이는 &lt;code&gt;A&lt;/code&gt; 의 최소 ​​치수보다 크거나 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="73e05a032664ce6a5bb59d6231727896e0d85677" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = QR&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A = QR&lt;/code&gt; 의 &lt;code&gt;QR&lt;/code&gt; 인수 분해를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="bd5939dcb4cf796b127a8200b499f432e4d64b40" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = QR&lt;/code&gt;. &lt;code&gt;tau&lt;/code&gt; contains scalars which parameterize the elementary reflectors of the factorization. &lt;code&gt;tau&lt;/code&gt; must have length greater than or equal to the smallest dimension of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A = QR&lt;/code&gt; 의 &lt;code&gt;QR&lt;/code&gt; 인수 분해를 계산합니다 . &lt;code&gt;tau&lt;/code&gt; 는 인수 분해의 기본 반사기를 매개 변수화하는 스칼라를 포함합니다. &lt;code&gt;tau&lt;/code&gt; 의 길이는 &lt;code&gt;A&lt;/code&gt; 의 최소 ​​치수보다 크거나 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="14220f2b6c0b60f7df0cde02fa4f1c544028c987" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;RQ&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = RQ&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 &lt;code&gt;RQ&lt;/code&gt; 인수 분해 , &lt;code&gt;A = RQ&lt;/code&gt; 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="861e3be13c33c99b622d41916c8e070553b49f73" translate="yes" xml:space="preserve">
          <source>Compute the &lt;code&gt;RQ&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = RQ&lt;/code&gt;. &lt;code&gt;tau&lt;/code&gt; contains scalars which parameterize the elementary reflectors of the factorization. &lt;code&gt;tau&lt;/code&gt; must have length greater than or equal to the smallest dimension of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 &lt;code&gt;RQ&lt;/code&gt; 인수 분해 , &lt;code&gt;A = RQ&lt;/code&gt; 계산합니다 . &lt;code&gt;tau&lt;/code&gt; 는 인수 분해의 기본 반사기를 매개 변수화하는 스칼라를 포함합니다. &lt;code&gt;tau&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 의 최소 ​​치수 이상이어야합니다 . .</target>
        </trans-unit>
        <trans-unit id="1941b58e1c7afe2d3c77d99152574462461df1db" translate="yes" xml:space="preserve">
          <source>Compute the Bunch-Kaufman &lt;a href=&quot;#footnote-Bunch1977&quot;&gt;[Bunch1977]&lt;/a&gt; factorization of a &lt;code&gt;Symmetric&lt;/code&gt; or &lt;code&gt;Hermitian&lt;/code&gt; matrix &lt;code&gt;A&lt;/code&gt; as $P'*U*D*U'*P$ or $P'*L*D*L'*P$, depending on which triangle is stored in &lt;code&gt;A&lt;/code&gt;, and return a &lt;code&gt;BunchKaufman&lt;/code&gt; object. Note that if &lt;code&gt;A&lt;/code&gt; is complex symmetric then &lt;code&gt;U'&lt;/code&gt; and &lt;code&gt;L'&lt;/code&gt; denote the unconjugated transposes, i.e. &lt;code&gt;transpose(U)&lt;/code&gt; and &lt;code&gt;transpose(L)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Symmetric&lt;/code&gt; 또는 &lt;code&gt;Hermitian&lt;/code&gt; 행렬 &lt;code&gt;A&lt;/code&gt; 의 Bunch-Kaufman &lt;a href=&quot;#footnote-Bunch1977&quot;&gt;[Bunch1977]&lt;/a&gt; 인수 분해 를 어떤 삼각형 이냐에 따라 $ P '* U * D * U'* P $ 또는 $ P '* L * D * L'* P $로 계산합니다 &lt;code&gt;A&lt;/code&gt; 에 저장 하고 &lt;code&gt;BunchKaufman&lt;/code&gt; 객체를 반환 합니다. 경우 참고 &lt;code&gt;A&lt;/code&gt; 가 복잡 다음 대칭 &lt;code&gt;U'&lt;/code&gt; 와 &lt;code&gt;L'&lt;/code&gt; 접합되지 전치를 나타내는, 즉 &lt;code&gt;transpose(U)&lt;/code&gt; 및 &lt;code&gt;transpose(L)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8adc6e0822f31506444311768e4f6ded0f9f1c41" translate="yes" xml:space="preserve">
          <source>Compute the CRC-32c checksum of the given &lt;code&gt;data&lt;/code&gt;, which can be an &lt;code&gt;Array{UInt8}&lt;/code&gt;, a contiguous subarray thereof, or a &lt;code&gt;String&lt;/code&gt;. Optionally, you can pass a starting &lt;code&gt;crc&lt;/code&gt; integer to be mixed in with the checksum. The &lt;code&gt;crc&lt;/code&gt; parameter can be used to compute a checksum on data divided into chunks: performing &lt;code&gt;crc32c(data2, crc32c(data1))&lt;/code&gt; is equivalent to the checksum of &lt;code&gt;[data1; data2]&lt;/code&gt;. (Technically, a little-endian checksum is computed.)</source>
          <target state="translated">주어진 &lt;code&gt;data&lt;/code&gt; 의 CRC-32c 체크섬을 계산합니다.이 데이터 는 &lt;code&gt;Array{UInt8}&lt;/code&gt; , 연속 된 하위 배열 또는 &lt;code&gt;String&lt;/code&gt; 일 수 있습니다. 선택적으로 시작 &lt;code&gt;crc&lt;/code&gt; 정수를 전달 하여 체크섬과 혼합 할 수 있습니다. &lt;code&gt;crc&lt;/code&gt; 파라미터 청크로 분할 된 데이터에 대한 체크섬을 계산하는데 이용 될 수있다 : 실시 &lt;code&gt;crc32c(data2, crc32c(data1))&lt;/code&gt; 의 체크섬 동등 &lt;code&gt;[data1; data2]&lt;/code&gt; . 기술적으로 리틀 엔디안 체크섬이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="633c320407bd275302d618eed24d78f3e652466b" translate="yes" xml:space="preserve">
          <source>Compute the Cholesky factorization of a dense symmetric positive definite matrix &lt;code&gt;A&lt;/code&gt; and return a &lt;code&gt;Cholesky&lt;/code&gt; factorization. The matrix &lt;code&gt;A&lt;/code&gt; can either be a &lt;a href=&quot;#LinearAlgebra.Symmetric&quot;&gt;&lt;code&gt;Symmetric&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.Hermitian&quot;&gt;&lt;code&gt;Hermitian&lt;/code&gt;&lt;/a&gt;&lt;code&gt;StridedMatrix&lt;/code&gt; or a &lt;em&gt;perfectly&lt;/em&gt; symmetric or Hermitian &lt;code&gt;StridedMatrix&lt;/code&gt;. The triangular Cholesky factor can be obtained from the factorization &lt;code&gt;F&lt;/code&gt; with: &lt;code&gt;F.L&lt;/code&gt; and &lt;code&gt;F.U&lt;/code&gt;. The following functions are available for &lt;code&gt;Cholesky&lt;/code&gt; objects: &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.logdet&quot;&gt;&lt;code&gt;logdet&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#LinearAlgebra.isposdef&quot;&gt;&lt;code&gt;isposdef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">조밀 한 대칭 긍정적 인 확실한 매트릭스의 콜레 인수 분해 계산 &lt;code&gt;A&lt;/code&gt; 하고 돌아 &lt;code&gt;Cholesky&lt;/code&gt; 인수 분해를. 행렬 &lt;code&gt;A&lt;/code&gt; 는 &lt;a href=&quot;#LinearAlgebra.Symmetric&quot;&gt; &lt;code&gt;Symmetric&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#LinearAlgebra.Hermitian&quot;&gt; &lt;code&gt;Hermitian&lt;/code&gt; &lt;/a&gt; &lt;code&gt;StridedMatrix&lt;/code&gt; 또는 &lt;em&gt;완벽하게&lt;/em&gt; 대칭 또는 Hermitian &lt;code&gt;StridedMatrix&lt;/code&gt; 일 수 있습니다. 삼각형 콜레 계수는 인수 분해에서 얻을 수 있습니다 &lt;code&gt;F&lt;/code&gt; :와 &lt;code&gt;F.L&lt;/code&gt; 과 &lt;code&gt;F.U&lt;/code&gt; . 다음과 같은 기능을 사용할 수 있습니다 &lt;code&gt;Cholesky&lt;/code&gt; 개체 : &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;inv&lt;/code&gt; , &lt;a href=&quot;#LinearAlgebra.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#LinearAlgebra.logdet&quot;&gt; &lt;code&gt;logdet&lt;/code&gt; &lt;/a&gt;및&lt;a href=&quot;#LinearAlgebra.isposdef&quot;&gt; &lt;code&gt;isposdef&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="37b962efd94ea393def73078100fff01edd4aab9" translate="yes" xml:space="preserve">
          <source>Compute the Hessenberg decomposition of &lt;code&gt;A&lt;/code&gt; and return a &lt;code&gt;Hessenberg&lt;/code&gt; object. If &lt;code&gt;F&lt;/code&gt; is the factorization object, the unitary matrix can be accessed with &lt;code&gt;F.Q&lt;/code&gt; and the Hessenberg matrix with &lt;code&gt;F.H&lt;/code&gt;. When &lt;code&gt;Q&lt;/code&gt; is extracted, the resulting type is the &lt;code&gt;HessenbergQ&lt;/code&gt; object, and may be converted to a regular matrix with &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert(Array, _)&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;Array(_)&lt;/code&gt; for short).</source>
          <target state="translated">의 하센 분해 계산 &lt;code&gt;A&lt;/code&gt; 하고 돌아 &lt;code&gt;Hessenberg&lt;/code&gt; 개체를. 하면 &lt;code&gt;F&lt;/code&gt; 가 인수 분해의 목적은, 유니 터리 행렬에 접근 할 수 &lt;code&gt;F.Q&lt;/code&gt; 와 함께 하센 행렬 &lt;code&gt;F.H&lt;/code&gt; . &lt;code&gt;Q&lt;/code&gt; 가 추출 될 때 결과 유형은 &lt;code&gt;HessenbergQ&lt;/code&gt; 객체이며 &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert(Array, _)&lt;/code&gt; &lt;/a&gt; (또는 간단히 &lt;code&gt;Array(_)&lt;/code&gt; 를 사용하여 일반 행렬로 변환 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d47c5b4fc5ee4331387245803c6326b23b1e354" translate="yes" xml:space="preserve">
          <source>Compute the LQ decomposition of &lt;code&gt;A&lt;/code&gt;. The decomposition's lower triangular component can be obtained from the &lt;code&gt;LQ&lt;/code&gt; object &lt;code&gt;S&lt;/code&gt; via &lt;code&gt;S.L&lt;/code&gt;, and the orthogonal/unitary component via &lt;code&gt;S.Q&lt;/code&gt;, such that &lt;code&gt;A &amp;asymp; S.L*S.Q&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 LQ 분해를 계산합니다 . 분해의 하부 삼각 성분은 &lt;code&gt;S.L&lt;/code&gt; 통해 &lt;code&gt;LQ&lt;/code&gt; 객체 ( &lt;code&gt;S&lt;/code&gt; ) 로부터 그리고 A&amp;asymp;SL &lt;code&gt;A &amp;asymp; S.L*S.Q&lt;/code&gt; 되도록 &lt;code&gt;S.Q&lt;/code&gt; 를 통해 직교 / 일체 성분 으로부터 얻어 질 수있다 .</target>
        </trans-unit>
        <trans-unit id="df93c4e3f01a5d5d8938330edf6e69bce8f5f23a" translate="yes" xml:space="preserve">
          <source>Compute the LQ factorization of &lt;code&gt;A&lt;/code&gt;, using the input matrix as a workspace. See also &lt;a href=&quot;#LinearAlgebra.lq&quot;&gt;&lt;code&gt;lq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">입력 행렬을 작업 공간으로 사용하여 &lt;code&gt;A&lt;/code&gt; 의 LQ 인수 분해를 계산합니다 . &lt;a href=&quot;#LinearAlgebra.lq&quot;&gt; &lt;code&gt;lq&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f143c0b1e17ec33b003d5d465ed585f1a6c5eeb5" translate="yes" xml:space="preserve">
          <source>Compute the LU factorization of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 LU 인수 분해를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="f3d2a0b8ede301b8c788fe8d3b8a2900d96315da" translate="yes" xml:space="preserve">
          <source>Compute the LU factorization of a banded matrix &lt;code&gt;AB&lt;/code&gt;. &lt;code&gt;kl&lt;/code&gt; is the first subdiagonal containing a nonzero band, &lt;code&gt;ku&lt;/code&gt; is the last superdiagonal containing one, and &lt;code&gt;m&lt;/code&gt; is the first dimension of the matrix &lt;code&gt;AB&lt;/code&gt;. Returns the LU factorization in-place and &lt;code&gt;ipiv&lt;/code&gt;, the vector of pivots used.</source>
          <target state="translated">밴드 행렬 &lt;code&gt;AB&lt;/code&gt; 의 LU 인수 분해를 계산합니다 . &lt;code&gt;kl&lt;/code&gt; 은 0이 아닌 밴드를 포함하는 첫 번째 subdiagonal이고, &lt;code&gt;ku&lt;/code&gt; 는 1을 포함하는 마지막 superdiagonal이며, &lt;code&gt;m&lt;/code&gt; 은 행렬 &lt;code&gt;AB&lt;/code&gt; 의 첫 번째 차원입니다 . LU 인수 분해를 사용하고 사용 된 피벗의 벡터 인 &lt;code&gt;ipiv&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4e85ab4b85e63bda3524cd40490290f9c652abef" translate="yes" xml:space="preserve">
          <source>Compute the Pearson correlation between the vectors &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">벡터 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 사이의 Pearson 상관 관계를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="0c66f895734c2d381a6e7359b9abed2937fd17e4" translate="yes" xml:space="preserve">
          <source>Compute the Pearson correlation between the vectors or matrices &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; along the dimension &lt;code&gt;dims&lt;/code&gt;.</source>
          <target state="translated">차원 &lt;code&gt;dims&lt;/code&gt; 따라 벡터 또는 행렬 &lt;code&gt;X&lt;/code&gt; 와 &lt;code&gt;Y&lt;/code&gt; 사이의 피어슨 상관 관계를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="74013bf59e1c48e3434f51156a8cd876c94ec658" translate="yes" xml:space="preserve">
          <source>Compute the Pearson correlation matrix of the matrix &lt;code&gt;X&lt;/code&gt; along the dimension &lt;code&gt;dims&lt;/code&gt;.</source>
          <target state="translated">차원 &lt;code&gt;dims&lt;/code&gt; 따라 행렬 &lt;code&gt;X&lt;/code&gt; 의 피어슨 상관 행렬을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="eb5aaf9c337f0702d2fe48faff921d16afde5b19" translate="yes" xml:space="preserve">
          <source>Compute the QR factorization of the matrix &lt;code&gt;A&lt;/code&gt;: an orthogonal (or unitary if &lt;code&gt;A&lt;/code&gt; is complex-valued) matrix &lt;code&gt;Q&lt;/code&gt;, and an upper triangular matrix &lt;code&gt;R&lt;/code&gt; such that</source>
          <target state="translated">행렬 &lt;code&gt;A&lt;/code&gt; 의 QR 분해 : 직교 (또는 &lt;code&gt;A&lt;/code&gt; 가 복소수 인 경우 단일 ) 행렬 &lt;code&gt;Q&lt;/code&gt; 및 상위 삼각 행렬 &lt;code&gt;R&lt;/code&gt; 을 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="9f4fb449517dd4a253bcd016046b2c39cd6be49f" translate="yes" xml:space="preserve">
          <source>Compute the amount of memory, in bytes, used by all unique objects reachable from the argument.</source>
          <target state="translated">인수에서 도달 할 수있는 모든 고유 한 오브젝트가 사용하는 메모리 양 (바이트)을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="ef14f4c033588439c9734666e7f662db33797d38" translate="yes" xml:space="preserve">
          <source>Compute the base 10 exponential of &lt;code&gt;x&lt;/code&gt;, in other words $10^x$.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 기본 10 지수 , 즉 $ 10 ^ x $를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="5996a7911dbb75d459bb57880857b6c285fdb533" translate="yes" xml:space="preserve">
          <source>Compute the base 2 exponential of &lt;code&gt;x&lt;/code&gt;, in other words $2^x$.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 기본 2 지수 , 즉 $ 2 ^ x $를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="794534f25f9e8868116d7dccbee753ad76971472" translate="yes" xml:space="preserve">
          <source>Compute the base &lt;code&gt;b&lt;/code&gt; logarithm of &lt;code&gt;x&lt;/code&gt;. Throws &lt;a href=&quot;../base/index#Core.DomainError&quot;&gt;&lt;code&gt;DomainError&lt;/code&gt;&lt;/a&gt; for negative &lt;a href=&quot;../numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; arguments.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 기본 &lt;code&gt;b&lt;/code&gt; 로그를 계산합니다 . 예외 &lt;a href=&quot;../base/index#Core.DomainError&quot;&gt; &lt;code&gt;DomainError&lt;/code&gt; 는&lt;/a&gt; 부정적인 위해 &lt;a href=&quot;../numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; 인수입니다.</target>
        </trans-unit>
        <trans-unit id="c05a16a74adde544da95df4e78617f63f96f27db" translate="yes" xml:space="preserve">
          <source>Compute the blocked &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = QR&lt;/code&gt;. &lt;code&gt;T&lt;/code&gt; contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization. The first dimension of &lt;code&gt;T&lt;/code&gt; sets the block size and it must be between 1 and &lt;code&gt;n&lt;/code&gt;. The second dimension of &lt;code&gt;T&lt;/code&gt; must equal the smallest dimension of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A = QR&lt;/code&gt; 의 차단 된 &lt;code&gt;QR&lt;/code&gt; 분해를 계산합니다 . &lt;code&gt;T&lt;/code&gt; 는 인수 분해의 기본 반사기를 파라미터 화하는 상부 삼각 블록 반사기를 포함한다. &lt;code&gt;T&lt;/code&gt; 의 첫 번째 차원은 블록 크기를 설정하며 1과 &lt;code&gt;n&lt;/code&gt; 사이 여야합니다 . &lt;code&gt;T&lt;/code&gt; 의 두 번째 차원 은 &lt;code&gt;A&lt;/code&gt; 의 가장 작은 차원과 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="9b0cbb0565d1b4a03a96f69b70d2c66787700aa8" translate="yes" xml:space="preserve">
          <source>Compute the blocked &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = QR&lt;/code&gt;. &lt;code&gt;nb&lt;/code&gt; sets the block size and it must be between 1 and &lt;code&gt;n&lt;/code&gt;, the second dimension of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A = QR&lt;/code&gt; 의 차단 된 &lt;code&gt;QR&lt;/code&gt; 분해를 계산합니다 . &lt;code&gt;nb&lt;/code&gt; 는 블록 크기를 설정하며 &lt;code&gt;A&lt;/code&gt; 의 두 번째 차원 인 1과 &lt;code&gt;n&lt;/code&gt; 사이 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="64fc87785de1b25c447a6d57734a1583aa8fc760" translate="yes" xml:space="preserve">
          <source>Compute the complex conjugate of a complex number &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">복소수 &lt;code&gt;z&lt;/code&gt; 의 복소 공액을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="d952ac0269ec6a898fc99a4c73f9f0fa2cddbcd5" translate="yes" xml:space="preserve">
          <source>Compute the cosecant of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in degrees.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 코시컨트를 계산합니다 . 여기서 &lt;code&gt;x&lt;/code&gt; 는도 단위입니다.</target>
        </trans-unit>
        <trans-unit id="cd18d2a4efe3c5ddd8da80eadb7eb93b647e38fb" translate="yes" xml:space="preserve">
          <source>Compute the cosecant of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in radians.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 코시컨트를 계산합니다 . 여기서 &lt;code&gt;x&lt;/code&gt; 는 라디안입니다.</target>
        </trans-unit>
        <trans-unit id="7c34352434165644e17d3d3c3017b1efac79a034" translate="yes" xml:space="preserve">
          <source>Compute the cotangent of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in degrees.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 코탄젠트를 계산합니다 . 여기서 &lt;code&gt;x&lt;/code&gt; 는 도입니다.</target>
        </trans-unit>
        <trans-unit id="51e33b4564608050a8442490630344d272d7cb6a" translate="yes" xml:space="preserve">
          <source>Compute the cotangent of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in radians.</source>
          <target state="translated">의 계산 코탄젠트 &lt;code&gt;x&lt;/code&gt; 여기서, &lt;code&gt;x&lt;/code&gt; 는 라디안이다.</target>
        </trans-unit>
        <trans-unit id="ced199cab7b78dc4018b6d349c2fddeae611b20a" translate="yes" xml:space="preserve">
          <source>Compute the covariance between the vectors &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; (the default), computes $\frac{1}{n-1}\sum_{i=1}^n (x_i-\bar x) (y_i-\bar y)^*$ where $*$ denotes the complex conjugate and &lt;code&gt;n = length(x) = length(y)&lt;/code&gt;. If &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, computes $\frac{1}{n}\sum_{i=1}^n (x_i-\bar x) (y_i-\bar y)^*$.</source>
          <target state="translated">벡터 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 사이의 공분산을 계산합니다 . 경우 &lt;code&gt;corrected&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; (기본), $ \ FRAC {1}를 연산한다 {N-1} \ sum_ {I = 1} ^ N (x_i- \ 바 X) (y_i- \ 바 Y) ^ * $ 여기서 $ * $는 켤레 복소수를 나타내고 &lt;code&gt;n = length(x) = length(y)&lt;/code&gt; 입니다. &lt;code&gt;corrected&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우 $ \ frac {1} {n} \ sum_ {i = 1} ^ n (x_i- \ bar x) (y_i- \ bar y) ^ * $를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="2c939998715a4bc32623fd5d4a50f59b83b9bf7e" translate="yes" xml:space="preserve">
          <source>Compute the covariance between the vectors or matrices &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; along the dimension &lt;code&gt;dims&lt;/code&gt;. If &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; (the default) then the sum is scaled with &lt;code&gt;n-1&lt;/code&gt;, whereas the sum is scaled with &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; where &lt;code&gt;n = size(X, dims) = size(Y, dims)&lt;/code&gt;.</source>
          <target state="translated">차원 &lt;code&gt;dims&lt;/code&gt; 따라 벡터 또는 행렬 &lt;code&gt;X&lt;/code&gt; 와 &lt;code&gt;Y&lt;/code&gt; 사이의 공분산을 계산합니다 . 경우 &lt;code&gt;corrected&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; (디폴트)를 합으로 스케일링 &lt;code&gt;n-1&lt;/code&gt; 합계는로 축소되는 반면, &lt;code&gt;n&lt;/code&gt; 만약 &lt;code&gt;corrected&lt;/code&gt; 인 &lt;code&gt;false&lt;/code&gt; 여기서 &lt;code&gt;n = size(X, dims) = size(Y, dims)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c149665bdfebe0f49b37ac0ad2f4069a8c615ef5" translate="yes" xml:space="preserve">
          <source>Compute the covariance matrix of the matrix &lt;code&gt;X&lt;/code&gt; along the dimension &lt;code&gt;dims&lt;/code&gt;. If &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; (the default) then the sum is scaled with &lt;code&gt;n-1&lt;/code&gt;, whereas the sum is scaled with &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; where &lt;code&gt;n = size(X, dims)&lt;/code&gt;.</source>
          <target state="translated">차원 &lt;code&gt;dims&lt;/code&gt; 따라 행렬 &lt;code&gt;X&lt;/code&gt; 의 공분산 행렬을 계산합니다 . 경우 &lt;code&gt;corrected&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; (디폴트)를 합으로 스케일링 &lt;code&gt;n-1&lt;/code&gt; 합계는로 축소되는 반면, &lt;code&gt;n&lt;/code&gt; 만약 &lt;code&gt;corrected&lt;/code&gt; 인 &lt;code&gt;false&lt;/code&gt; 여기서 &lt;code&gt;n = size(X, dims)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="410468f3561472f97b5b13876570709e80fe55b0" translate="yes" xml:space="preserve">
          <source>Compute the cross product of two 3-vectors.</source>
          <target state="translated">2 개의 3 개 벡터의 교차 곱을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="98027b7e04b6a89188be633c36e298c811c2a981" translate="yes" xml:space="preserve">
          <source>Compute the dot product between two vectors. For complex vectors, the first vector is conjugated. When the vectors have equal lengths, calling &lt;code&gt;dot&lt;/code&gt; is semantically equivalent to &lt;code&gt;sum(dot(vx,vy) for (vx,vy) in zip(x, y))&lt;/code&gt;.</source>
          <target state="translated">두 벡터 사이의 내적을 계산합니다. 복소수 벡터의 경우, 첫 번째 벡터가 접합됩니다. 벡터의 길이가 동일한 경우 호출 &lt;code&gt;dot&lt;/code&gt; 은 의미 적 &lt;code&gt;sum(dot(vx,vy) for (vx,vy) in zip(x, y))&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f9c700743247c39eb6f20b3363175a4f35bc60b4" translate="yes" xml:space="preserve">
          <source>Compute the element type &lt;code&gt;R&lt;/code&gt; of the result matrix as &lt;code&gt;promote_op(op, argument_types...)&lt;/code&gt;, where &lt;code&gt;argument_types&lt;/code&gt; is computed from &lt;code&gt;eltype&lt;/code&gt; applied to each input array.</source>
          <target state="translated">결과 행렬 의 요소 유형 &lt;code&gt;R&lt;/code&gt; 을 &lt;code&gt;promote_op(op, argument_types...)&lt;/code&gt; 로 계산합니다. 여기서 &lt;code&gt;argument_types&lt;/code&gt; 는 각 입력 배열에 적용된 &lt;code&gt;eltype&lt;/code&gt; 에서 계산 됩니다.</target>
        </trans-unit>
        <trans-unit id="eac1c8c9c47e0c367d8a880554c5ea2773fbaa1d" translate="yes" xml:space="preserve">
          <source>Compute the generalized SVD of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, returning a &lt;code&gt;GeneralizedSVD&lt;/code&gt; factorization object &lt;code&gt;F&lt;/code&gt;, such that &lt;code&gt;A = F.U*F.D1*F.R0*F.Q'&lt;/code&gt; and &lt;code&gt;B = F.V*F.D2*F.R0*F.Q'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A = F.U*F.D1*F.R0*F.Q'&lt;/code&gt; 및 &lt;code&gt;B = F.V*F.D2*F.R0*F.Q'&lt;/code&gt; 와 같이 &lt;code&gt;GeneralizedSVD&lt;/code&gt; 인수 분해 객체 &lt;code&gt;F&lt;/code&gt; 를 반환하여 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 의 일반화 된 SVD를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="d2376ee0de00bcc15fd5a97c34b5145b4bf2e681" translate="yes" xml:space="preserve">
          <source>Compute the hyperbolic cosecant of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 쌍곡 코시컨트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="9455f097ec080dbde6000f4b95c5aceb54405acc" translate="yes" xml:space="preserve">
          <source>Compute the hyperbolic cotangent of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 쌍곡 코탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="7ee2c83b64cf586a8d935df80877c1c53e0f63b8" translate="yes" xml:space="preserve">
          <source>Compute the hyperbolic secant of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 쌍곡선 시컨트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="c63e0fdffcada240fd739cc4ae974531cb4e6771" translate="yes" xml:space="preserve">
          <source>Compute the hypotenuse $\sqrt{\sum x_i^2}$ avoiding overflow and underflow.</source>
          <target state="translated">오버플로 및 언더 플로를 피하면서 빗변 $ \ sqrt {\ sum x_i ^ 2} $를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="a98476342e9a32121a3857c0c73120ddc38a7b27" translate="yes" xml:space="preserve">
          <source>Compute the hypotenuse $\sqrt{x^2+y^2}$ avoiding overflow and underflow.</source>
          <target state="translated">오버플로 및 언더 플로를 피하면서 빗변 $ \ sqrt {x ^ 2 + y ^ 2} $를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="633ceda325459007865758a0c25ca9ff5d40d330" translate="yes" xml:space="preserve">
          <source>Compute the inverse cosecant of &lt;code&gt;x&lt;/code&gt;, where the output is in degrees.</source>
          <target state="translated">출력이도 단위 인 &lt;code&gt;x&lt;/code&gt; 의 역 코시컨트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="61c956ce405ed17444d2a843c6e0034449650e02" translate="yes" xml:space="preserve">
          <source>Compute the inverse cosecant of &lt;code&gt;x&lt;/code&gt;, where the output is in radians.</source>
          <target state="translated">출력이 라디안 단위 인 &lt;code&gt;x&lt;/code&gt; 의 역 코시컨트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="b165af691a25cf7a4fe5189a3bdc95cf5605956a" translate="yes" xml:space="preserve">
          <source>Compute the inverse cosine of &lt;code&gt;x&lt;/code&gt;, where the output is in degrees.</source>
          <target state="translated">출력이도 단위 인 &lt;code&gt;x&lt;/code&gt; 의 역 코사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="624b23e348273fc6630a3591e94b2278279c23b8" translate="yes" xml:space="preserve">
          <source>Compute the inverse cosine of &lt;code&gt;x&lt;/code&gt;, where the output is in radians</source>
          <target state="translated">출력이 라디안 인 &lt;code&gt;x&lt;/code&gt; 의 역 코사인을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="6fc169a99667ef032612c7df05b276f67e73ab85" translate="yes" xml:space="preserve">
          <source>Compute the inverse cotangent of &lt;code&gt;x&lt;/code&gt;, where the output is in degrees.</source>
          <target state="translated">출력이도 단위 인 &lt;code&gt;x&lt;/code&gt; 의 역 코탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="cb2d41805a6658a7aa65e9db45a5f7a00e95b62d" translate="yes" xml:space="preserve">
          <source>Compute the inverse cotangent of &lt;code&gt;x&lt;/code&gt;, where the output is in radians.</source>
          <target state="translated">출력이 라디안 인 &lt;code&gt;x&lt;/code&gt; 의 역 코탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="56d719cec6115d223ee7db48c9f3e019d2461e57" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic cosecant of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 역 쌍곡 코시컨트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="807f8ee5256662d4c4cbc7f7b897c32dc8916b59" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic cosine of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 역 쌍곡 코사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="7ae3e0a4e6d92870c3f1d2c212c4b9c31c707de7" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic cotangent of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 역 쌍곡 코탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="24d6944fdad3a15f1f900ff184e7c611309535a4" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic matrix cosine of a square matrix &lt;code&gt;A&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_4&quot;&gt;[AH16_4]&lt;/a&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 역 쌍곡 행렬 코사인을 계산합니다 . 이 함수를 계산하는 데 사용되는 이론 및 로그 공식에 대해서는 &lt;a href=&quot;#footnote-AH16_4&quot;&gt;[AH16_4]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="86cfc43a5a6c82e16a0bd6ad0cee64c1039344e2" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic matrix sine of a square matrix &lt;code&gt;A&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_5&quot;&gt;[AH16_5]&lt;/a&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 역 쌍곡 행렬 사인을 계산합니다 . 이 함수를 계산하는 데 사용되는 이론 및 로그 공식에 대해서는 &lt;a href=&quot;#footnote-AH16_5&quot;&gt;[AH16_5]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1eaeedca65b3a8c87db844333fb8c7c021c9424a" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic matrix tangent of a square matrix &lt;code&gt;A&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_6&quot;&gt;[AH16_6]&lt;/a&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 역 쌍곡 행렬 탄젠트를 계산합니다 . 이 함수를 계산하는 데 사용되는 이론 및 로그 공식에 대해서는 &lt;a href=&quot;#footnote-AH16_6&quot;&gt;[AH16_6]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="139740116ef333d8f7864bd3d0441f3f0ed81cae" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic secant of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 역 쌍곡 시컨트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="b5e848138576f12626bbb3a4e1203f85a4ca3a1b" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic sine of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 역 쌍곡 사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="680c3b04c05aca283c4622eb58afd6457ddd9b27" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic tangent of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 역 쌍곡 탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="7c3a4c0cd5ecc1b9593ac0007373302db1fa6ec3" translate="yes" xml:space="preserve">
          <source>Compute the inverse matrix cosecant of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 역행렬 코시컨트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="d3c09cfcbaeb41a964e5eeda8044692db13c2de8" translate="yes" xml:space="preserve">
          <source>Compute the inverse matrix cosine of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 역행렬 코사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="554fe6fb73f3b08cce5a611c6a50f4a680bb3671" translate="yes" xml:space="preserve">
          <source>Compute the inverse matrix cotangent of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 역행렬 코탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="0dd96c344ce6aeba2faf61b21fc85774face313f" translate="yes" xml:space="preserve">
          <source>Compute the inverse matrix hyperbolic cosecant of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 역행렬 쌍곡 코시컨트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="13b94345110fabe0d3fb8e21298e94148893c47e" translate="yes" xml:space="preserve">
          <source>Compute the inverse matrix hyperbolic cotangent of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 역행렬 쌍곡 코탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="47dc0db5a1205ee0f8a515dc40cd98df08f88bcc" translate="yes" xml:space="preserve">
          <source>Compute the inverse matrix hyperbolic secant of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 역행렬 쌍곡선 시컨트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="d0b63a7a4eb8f986033eb32a665b6e261954bb34" translate="yes" xml:space="preserve">
          <source>Compute the inverse matrix secant of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 역행렬을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="c5c87fce98f598dba189efeff4428b7d6efd962b" translate="yes" xml:space="preserve">
          <source>Compute the inverse matrix sine of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 역행렬 사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="82438e829448e338f5716124a7ced92061d94948" translate="yes" xml:space="preserve">
          <source>Compute the inverse matrix tangent of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 역행렬 탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="f8fcadcd9398201528e6c6c31d135192b6517aa0" translate="yes" xml:space="preserve">
          <source>Compute the inverse secant of &lt;code&gt;x&lt;/code&gt;, where the output is in degrees.</source>
          <target state="translated">출력이도 단위 인 &lt;code&gt;x&lt;/code&gt; 의 역 시컨트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="3181cd6c2abdb611f89e0ecf6a62739daf49359f" translate="yes" xml:space="preserve">
          <source>Compute the inverse secant of &lt;code&gt;x&lt;/code&gt;, where the output is in radians.</source>
          <target state="translated">출력이 라디안 단위 인 &lt;code&gt;x&lt;/code&gt; 의 역 시컨트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="40ba1792c624de0cb1dfc33c8587d7b068c312b3" translate="yes" xml:space="preserve">
          <source>Compute the inverse sine of &lt;code&gt;x&lt;/code&gt;, where the output is in degrees.</source>
          <target state="translated">출력이도 단위 인 &lt;code&gt;x&lt;/code&gt; 의 역 사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="2c89d82e75f63a6879bfb124e5439e8f554c18b2" translate="yes" xml:space="preserve">
          <source>Compute the inverse sine of &lt;code&gt;x&lt;/code&gt;, where the output is in radians.</source>
          <target state="translated">출력이 라디안 단위 인 &lt;code&gt;x&lt;/code&gt; 의 역 사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="dea1f25c8cdb21558fa421f817fc4803838604fc" translate="yes" xml:space="preserve">
          <source>Compute the inverse tangent of &lt;code&gt;y&lt;/code&gt; or &lt;code&gt;y/x&lt;/code&gt;, respectively, where the output is in degrees.</source>
          <target state="translated">출력이도 단위 인 &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;y/x&lt;/code&gt; 의 역 탄젠트를 각각 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="84e255dd37fccaa6c9024b56e1a156bcddadf711" translate="yes" xml:space="preserve">
          <source>Compute the inverse tangent of &lt;code&gt;y&lt;/code&gt; or &lt;code&gt;y/x&lt;/code&gt;, respectively.</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; 또는 &lt;code&gt;y/x&lt;/code&gt; 의 역 탄젠트를 각각 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="a437409e4208929c05cf3a26d531c19399ac90c7" translate="yes" xml:space="preserve">
          <source>Compute the logarithm of &lt;code&gt;x&lt;/code&gt; to base 10. Throws &lt;a href=&quot;../base/index#Core.DomainError&quot;&gt;&lt;code&gt;DomainError&lt;/code&gt;&lt;/a&gt; for negative &lt;a href=&quot;../numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; arguments.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 로그 를 밑이 10 인 로그를 계산합니다 . 음의 &lt;a href=&quot;../numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; 대해서는 &lt;a href=&quot;../base/index#Core.DomainError&quot;&gt; &lt;code&gt;DomainError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다 .</target>
        </trans-unit>
        <trans-unit id="307aa19b57a1c93393b9992c4bb9222fbeb6d69a" translate="yes" xml:space="preserve">
          <source>Compute the logarithm of &lt;code&gt;x&lt;/code&gt; to base 2. Throws &lt;a href=&quot;../base/index#Core.DomainError&quot;&gt;&lt;code&gt;DomainError&lt;/code&gt;&lt;/a&gt; for negative &lt;a href=&quot;../numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; arguments.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 밑을 밑이 2 인 로그를 계산합니다 . 음의 &lt;a href=&quot;../numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; 대해서는 &lt;a href=&quot;../base/index#Core.DomainError&quot;&gt; &lt;code&gt;DomainError&lt;/code&gt; &lt;/a&gt; 를 던집니다 .</target>
        </trans-unit>
        <trans-unit id="357c0e09927961e89f5147d19aac01380699c99b" translate="yes" xml:space="preserve">
          <source>Compute the matrix cosecant of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 행렬 코시컨트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="8e5fa0eb0776b403f81e8ca8ffdd49ca084bc0cf" translate="yes" xml:space="preserve">
          <source>Compute the matrix cosine of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 행렬 코사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="4a3d2174cd407b931afd89c4da677e682e83eb75" translate="yes" xml:space="preserve">
          <source>Compute the matrix cotangent of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 행렬 코탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="a0d7c646de45ee9b8c08cbdbcbbbe4ae72a7e16e" translate="yes" xml:space="preserve">
          <source>Compute the matrix exponential of &lt;code&gt;A&lt;/code&gt;, defined by</source>
          <target state="translated">에 의해 정의 된 &lt;code&gt;A&lt;/code&gt; 의 행렬 지수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="1fd954e6ff4d674cda87b743aa2b1233b9a2eb54" translate="yes" xml:space="preserve">
          <source>Compute the matrix hyperbolic cosecant of square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 행렬 쌍곡선 코시컨트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="38b827146b68bcb3a9319674be38c266cf7e7f83" translate="yes" xml:space="preserve">
          <source>Compute the matrix hyperbolic cosine of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 행렬 쌍곡 코사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="110c3b9acb774724db674308a4bcde13d16b14d6" translate="yes" xml:space="preserve">
          <source>Compute the matrix hyperbolic cotangent of square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 행렬 쌍곡선 코탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="6d0510bcda1371513244fd5ba762aa98507b53bb" translate="yes" xml:space="preserve">
          <source>Compute the matrix hyperbolic secant of square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 행렬 쌍곡선 secant를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="69f5be6dce72711b7e92f9794c37163a41bcaec9" translate="yes" xml:space="preserve">
          <source>Compute the matrix hyperbolic sine of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 행렬 쌍곡 사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="68030614e2cc86a2f04214ee54bc242637c1d83e" translate="yes" xml:space="preserve">
          <source>Compute the matrix hyperbolic tangent of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 행렬 쌍곡 탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="a49ce1d636974c76079f6e75f270fb5680236ccd" translate="yes" xml:space="preserve">
          <source>Compute the matrix secant of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 행렬 시컨트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="8537b2719b34f9b953a571d36d5cd503fc126fb6" translate="yes" xml:space="preserve">
          <source>Compute the matrix sine and cosine of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 행렬 사인과 코사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="c790b1bd7335f67a22b7547277d010ba0a9f3b0b" translate="yes" xml:space="preserve">
          <source>Compute the matrix sine of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 행렬 사인을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="778966213f7c95c7b1093b4b2daad349ac3b974d" translate="yes" xml:space="preserve">
          <source>Compute the matrix tangent of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;A&lt;/code&gt; 의 행렬 탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="9eb474e2115ce973af39e55c69108d56b7159747" translate="yes" xml:space="preserve">
          <source>Compute the maximum value of &lt;code&gt;A&lt;/code&gt; over the singleton dimensions of &lt;code&gt;r&lt;/code&gt;, and write results to &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">싱글 톤 크기 &lt;code&gt;r&lt;/code&gt; 에 대해 &lt;code&gt;A&lt;/code&gt; 의 최대 값을 계산하고 결과를 &lt;code&gt;r&lt;/code&gt; 에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="812480b7cd3cf22547511e3adad6b33995a9beff" translate="yes" xml:space="preserve">
          <source>Compute the maximum value of an array over the given dimensions. See also the &lt;a href=&quot;../math/index#Base.max&quot;&gt;&lt;code&gt;max(a,b)&lt;/code&gt;&lt;/a&gt; function to take the maximum of two or more arguments, which can be applied elementwise to arrays via &lt;code&gt;max.(a,b)&lt;/code&gt;.</source>
          <target state="translated">주어진 차원에서 배열의 최대 값을 계산합니다. &lt;code&gt;max.(a,b)&lt;/code&gt; 를 통해 배열에 요소별로 적용 할 수있는 최대 두 개 이상의 인수를 가져 오려면 &lt;a href=&quot;../math/index#Base.max&quot;&gt; &lt;code&gt;max(a,b)&lt;/code&gt; &lt;/a&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a9b9b399a0d3918c3f6e362f2833628ccc71a99" translate="yes" xml:space="preserve">
          <source>Compute the mean of &lt;code&gt;v&lt;/code&gt; over the singleton dimensions of &lt;code&gt;r&lt;/code&gt;, and write results to &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; 의 싱글 톤 차원에 대해 &lt;code&gt;v&lt;/code&gt; 의 평균을 계산하고 결과를 &lt;code&gt;r&lt;/code&gt; 에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="11000a28bead3ac6f75bf9a14466e14072624576" translate="yes" xml:space="preserve">
          <source>Compute the mean of all elements in a collection.</source>
          <target state="translated">컬렉션에있는 모든 요소의 평균을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="99f6794cd06dba199884516b785bda4fd78aa2a1" translate="yes" xml:space="preserve">
          <source>Compute the mean of an array over the given dimensions.</source>
          <target state="translated">주어진 차원에 대해 배열의 평균을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="f41aac2dc5d7c7dc8f7a1f9ae372c9c476523577" translate="yes" xml:space="preserve">
          <source>Compute the median of all elements in a collection. For an even number of elements no exact median element exists, so the result is equivalent to calculating mean of two median elements.</source>
          <target state="translated">컬렉션에있는 모든 요소의 중앙값을 계산합니다. 짝수의 요소의 경우 정확한 중간 요소가 없으므로 결과는 두 중간 요소의 평균을 계산하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="47aa9c53937737d70bd22425272809e6211e7bf6" translate="yes" xml:space="preserve">
          <source>Compute the median of an array along the given dimensions.</source>
          <target state="translated">주어진 차원을 따라 배열의 중앙값을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="2c99652c33628269108c328437953d38055c5886" translate="yes" xml:space="preserve">
          <source>Compute the middle of a range, which consists of computing the mean of its extrema. Since a range is sorted, the mean is performed with the first and last element.</source>
          <target state="translated">극한의 평균을 계산하는 범위의 중간을 계산합니다. 범위가 정렬되므로 평균은 첫 번째 요소와 마지막 요소로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="f52205089fbf6d58facb1bdb9b160b88b107a323" translate="yes" xml:space="preserve">
          <source>Compute the middle of a scalar value, which is equivalent to &lt;code&gt;x&lt;/code&gt; itself, but of the type of &lt;code&gt;middle(x, x)&lt;/code&gt; for consistency.</source>
          <target state="translated">스칼라 값의 중간을 계산합니다. 스칼라 값은 &lt;code&gt;x&lt;/code&gt; 자체 와 동일 하지만 일관성을 위해 &lt;code&gt;middle(x, x)&lt;/code&gt; 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="acf08f804a346435085af253987f1d511b1a7d4c" translate="yes" xml:space="preserve">
          <source>Compute the middle of an array &lt;code&gt;a&lt;/code&gt;, which consists of finding its extrema and then computing their mean.</source>
          <target state="translated">배열의 중간을 계산합니다. &lt;code&gt;a&lt;/code&gt; 는 극한값을 찾은 다음 평균을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="f0245cd1be7817ce631eac5c33e8ccdf05cebd05" translate="yes" xml:space="preserve">
          <source>Compute the middle of two reals &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, which is equivalent in both value and type to computing their mean (&lt;code&gt;(x + y) / 2&lt;/code&gt;).</source>
          <target state="translated">두 개의 실수 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 중간을 계산합니다 . 이는 값과 유형이 평균 ( &lt;code&gt;(x + y) / 2&lt;/code&gt; ) 을 계산하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="949e7136a76fe46a6048f43ad9bc9f806861c7ea" translate="yes" xml:space="preserve">
          <source>Compute the minimum and maximum elements of an array over the given dimensions.</source>
          <target state="translated">주어진 차원에서 배열의 최소 및 최대 요소를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="0d93ec1caffd4ccc7c3361a7c270c2d973854682" translate="yes" xml:space="preserve">
          <source>Compute the minimum and maximum of &lt;code&gt;f&lt;/code&gt; applied to each element in the given dimensions of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;A&lt;/code&gt; 의 차원에서 각 요소에 적용된 최소값과 최대 값 &lt;code&gt;f&lt;/code&gt; 를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="82e7ee5156f49d8db2d03ced16867f73d00a142d" translate="yes" xml:space="preserve">
          <source>Compute the minimum value of &lt;code&gt;A&lt;/code&gt; over the singleton dimensions of &lt;code&gt;r&lt;/code&gt;, and write results to &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">싱글 톤 차원 &lt;code&gt;r&lt;/code&gt; 에 대해 &lt;code&gt;A&lt;/code&gt; 의 최소값을 계산하고 결과를 &lt;code&gt;r&lt;/code&gt; 에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="ed6b522c97de9bddde22add7ab86b59b7c15f878" translate="yes" xml:space="preserve">
          <source>Compute the minimum value of an array over the given dimensions. See also the &lt;a href=&quot;../math/index#Base.min&quot;&gt;&lt;code&gt;min(a,b)&lt;/code&gt;&lt;/a&gt; function to take the minimum of two or more arguments, which can be applied elementwise to arrays via &lt;code&gt;min.(a,b)&lt;/code&gt;.</source>
          <target state="translated">주어진 차원에서 배열의 최소값을 계산합니다. 최소 두 개 이상의 인수를 취 하려면 &lt;a href=&quot;../math/index#Base.min&quot;&gt; &lt;code&gt;min(a,b)&lt;/code&gt; &lt;/a&gt; 함수를 참조하십시오. &lt;code&gt;min.(a,b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc7ac1e0e474d1b1a9d181c27f50c39ecd473625" translate="yes" xml:space="preserve">
          <source>Compute the natural base exponential of &lt;code&gt;x&lt;/code&gt;, in other words $e^x$.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 자연 기본 지수를 계산합니다 , 즉 $ e ^ x $를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="ff348abb57d70ef01b2fee18c2e56b5e9c90ef5b" translate="yes" xml:space="preserve">
          <source>Compute the natural logarithm of &lt;code&gt;x&lt;/code&gt;. Throws &lt;a href=&quot;../base/index#Core.DomainError&quot;&gt;&lt;code&gt;DomainError&lt;/code&gt;&lt;/a&gt; for negative &lt;a href=&quot;../numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; arguments. Use complex negative arguments to obtain complex results.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 자연 로그를 계산합니다 . 예외 &lt;a href=&quot;../base/index#Core.DomainError&quot;&gt; &lt;code&gt;DomainError&lt;/code&gt; 을&lt;/a&gt; 부정하기위한 &lt;a href=&quot;../numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; 인수입니다. 복소수 인수를 사용하여 복소수 결과를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="d39d60a66827c670830ca96a819f42207f21a2dd" translate="yes" xml:space="preserve">
          <source>Compute the number of digits in integer &lt;code&gt;n&lt;/code&gt; written in base &lt;code&gt;base&lt;/code&gt; (&lt;code&gt;base&lt;/code&gt; must not be in &lt;code&gt;[-1, 0, 1]&lt;/code&gt;), optionally padded with zeros to a specified size (the result will never be less than &lt;code&gt;pad&lt;/code&gt;).</source>
          <target state="translated">기본 &lt;code&gt;base&lt;/code&gt; 작성된 정수 &lt;code&gt;n&lt;/code&gt; 의 자릿수를 계산합니다 ( &lt;code&gt;base&lt;/code&gt; 은 &lt;code&gt;[-1, 0, 1]&lt;/code&gt; 이어야 함 ). 선택적으로 0으로 지정된 크기로 채워집니다 (결과는 &lt;code&gt;pad&lt;/code&gt; 보다 작을 수 없습니다) ).</target>
        </trans-unit>
        <trans-unit id="cdf0b4d7ddc06f4032604ad606ae2fa5da2f3e57" translate="yes" xml:space="preserve">
          <source>Compute the operator norm (or matrix norm) induced by the vector &lt;code&gt;p&lt;/code&gt;-norm, where valid values of &lt;code&gt;p&lt;/code&gt; are &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, or &lt;code&gt;Inf&lt;/code&gt;. (Note that for sparse matrices, &lt;code&gt;p=2&lt;/code&gt; is currently not implemented.) Use &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt;&lt;code&gt;norm&lt;/code&gt;&lt;/a&gt; to compute the Frobenius norm.</source>
          <target state="translated">유효한 &lt;code&gt;p&lt;/code&gt; 값 이 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; 또는 &lt;code&gt;Inf&lt;/code&gt; 인 벡터 &lt;code&gt;p&lt;/code&gt; - norm에 의해 유도 된 연산자 규범 (또는 행렬 규범)을 계산합니다 . 희소 행렬의 경우 &lt;code&gt;p=2&lt;/code&gt; 는 현재 구현되어 있지 않습니다. &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt; &lt;code&gt;norm&lt;/code&gt; &lt;/a&gt; 사용 Frobenius 표준을 계산 을 .</target>
        </trans-unit>
        <trans-unit id="875c419b65242063b15574011e9a9ebe51310e17" translate="yes" xml:space="preserve">
          <source>Compute the phase angle in radians of a complex number &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">복소수 &lt;code&gt;z&lt;/code&gt; 의 라디안으로 위상 각 계산 .</target>
        </trans-unit>
        <trans-unit id="f2bfc336c71f0f166834e6af3305ab8164da5ce4" translate="yes" xml:space="preserve">
          <source>Compute the pivoted &lt;code&gt;LU&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = LU&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A = LU&lt;/code&gt; 의 피벗 된 &lt;code&gt;LU&lt;/code&gt; 분해를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="b0d34ac6dfa1e6722e524c60e67afe891d8e958d" translate="yes" xml:space="preserve">
          <source>Compute the pivoted &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;AP = QR&lt;/code&gt; using BLAS level 3.</source>
          <target state="translated">BLAS 레벨 3을 사용하여 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;AP = QR&lt;/code&gt; 의 피벗 된 &lt;code&gt;QR&lt;/code&gt; 분해를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="f61896259e546ab5dfa4229a9ef0511c5d923d39" translate="yes" xml:space="preserve">
          <source>Compute the pivoted &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;AP = QR&lt;/code&gt; using BLAS level 3. &lt;code&gt;P&lt;/code&gt; is a pivoting matrix, represented by &lt;code&gt;jpvt&lt;/code&gt;. &lt;code&gt;jpvt&lt;/code&gt; must have length greater than or equal to &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;A&lt;/code&gt; is an &lt;code&gt;(m x n)&lt;/code&gt; matrix.</source>
          <target state="translated">BLAS 레벨 3을 사용하여 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;AP = QR&lt;/code&gt; 의 피벗 된 &lt;code&gt;QR&lt;/code&gt; 분해를 계산합니다. &lt;code&gt;P&lt;/code&gt; 는 &lt;code&gt;jpvt&lt;/code&gt; 로 표시되는 피벗 행렬 입니다. &lt;code&gt;A&lt;/code&gt; 가 &lt;code&gt;(m x n)&lt;/code&gt; 행렬 인 경우 &lt;code&gt;jpvt&lt;/code&gt; 의 길이 는 &lt;code&gt;n&lt;/code&gt; 보다 크거나 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="67444724cffb3267e5fd7af13f87a5b4b21f933f" translate="yes" xml:space="preserve">
          <source>Compute the pivoted &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;AP = QR&lt;/code&gt; using BLAS level 3. &lt;code&gt;P&lt;/code&gt; is a pivoting matrix, represented by &lt;code&gt;jpvt&lt;/code&gt;. &lt;code&gt;tau&lt;/code&gt; stores the elementary reflectors. &lt;code&gt;jpvt&lt;/code&gt; must have length length greater than or equal to &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;A&lt;/code&gt; is an &lt;code&gt;(m x n)&lt;/code&gt; matrix. &lt;code&gt;tau&lt;/code&gt; must have length greater than or equal to the smallest dimension of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">BLAS 레벨 3을 사용하여 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;AP = QR&lt;/code&gt; 의 피벗 된 &lt;code&gt;QR&lt;/code&gt; 분해를 계산합니다. &lt;code&gt;P&lt;/code&gt; 는 &lt;code&gt;jpvt&lt;/code&gt; 로 표시되는 피벗 행렬 입니다. &lt;code&gt;tau&lt;/code&gt; 는 기본 반사기를 저장합니다. &lt;code&gt;A&lt;/code&gt; 가 &lt;code&gt;(m x n)&lt;/code&gt; 행렬 인 경우 &lt;code&gt;jpvt&lt;/code&gt; 의 길이 는 &lt;code&gt;n&lt;/code&gt; 보다 크거나 같아야합니다 . &lt;code&gt;tau&lt;/code&gt; 의 길이는 &lt;code&gt;A&lt;/code&gt; 의 최소 ​​치수보다 크거나 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="9ff2d7fc77ed33a91ba59f92eb332d8bf62ed2de" translate="yes" xml:space="preserve">
          <source>Compute the pivoted Cholesky factorization of a dense symmetric positive semi-definite matrix &lt;code&gt;A&lt;/code&gt; and return a &lt;code&gt;CholeskyPivoted&lt;/code&gt; factorization. The matrix &lt;code&gt;A&lt;/code&gt; can either be a &lt;a href=&quot;#LinearAlgebra.Symmetric&quot;&gt;&lt;code&gt;Symmetric&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.Hermitian&quot;&gt;&lt;code&gt;Hermitian&lt;/code&gt;&lt;/a&gt;&lt;code&gt;StridedMatrix&lt;/code&gt; or a &lt;em&gt;perfectly&lt;/em&gt; symmetric or Hermitian &lt;code&gt;StridedMatrix&lt;/code&gt;. The triangular Cholesky factor can be obtained from the factorization &lt;code&gt;F&lt;/code&gt; with: &lt;code&gt;F.L&lt;/code&gt; and &lt;code&gt;F.U&lt;/code&gt;. The following functions are available for &lt;code&gt;CholeskyPivoted&lt;/code&gt; objects: &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#LinearAlgebra.rank&quot;&gt;&lt;code&gt;rank&lt;/code&gt;&lt;/a&gt;. The argument &lt;code&gt;tol&lt;/code&gt; determines the tolerance for determining the rank. For negative values, the tolerance is the machine precision.</source>
          <target state="translated">조밀 한 대칭 긍정적 인 반 명확한 매트릭스의 선회 콜레 인수 분해 계산 &lt;code&gt;A&lt;/code&gt; 하고 돌아 &lt;code&gt;CholeskyPivoted&lt;/code&gt; 의 인수 분해를. 행렬 &lt;code&gt;A&lt;/code&gt; 는 &lt;a href=&quot;#LinearAlgebra.Symmetric&quot;&gt; &lt;code&gt;Symmetric&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#LinearAlgebra.Hermitian&quot;&gt; &lt;code&gt;Hermitian&lt;/code&gt; &lt;/a&gt; &lt;code&gt;StridedMatrix&lt;/code&gt; 또는 &lt;em&gt;완벽하게&lt;/em&gt; 대칭 또는 Hermitian &lt;code&gt;StridedMatrix&lt;/code&gt; 일 수 있습니다. 삼각형 콜레 계수는 인수 분해에서 얻을 수 있습니다 &lt;code&gt;F&lt;/code&gt; :와 &lt;code&gt;F.L&lt;/code&gt; 과 &lt;code&gt;F.U&lt;/code&gt; . 다음과 같은 기능을 사용할 수 있습니다 &lt;code&gt;CholeskyPivoted&lt;/code&gt; 의 개체 : &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;inv&lt;/code&gt; , &lt;a href=&quot;#LinearAlgebra.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;#LinearAlgebra.rank&quot;&gt; &lt;code&gt;rank&lt;/code&gt; &lt;/a&gt; . 인수 &lt;code&gt;tol&lt;/code&gt; 은 순위를 결정하기위한 허용 오차를 결정합니다. 음수 값의 경우 공차는 기계 정밀도입니다.</target>
        </trans-unit>
        <trans-unit id="b64ceade01dfafb5bfec886e80d298d8030e7599" translate="yes" xml:space="preserve">
          <source>Compute the quantile(s) of a collection &lt;code&gt;itr&lt;/code&gt; at a specified probability or vector or tuple of probabilities &lt;code&gt;p&lt;/code&gt; on the interval [0,1]. The keyword argument &lt;code&gt;sorted&lt;/code&gt; indicates whether &lt;code&gt;itr&lt;/code&gt; can be assumed to be sorted.</source>
          <target state="translated">간격 [0,1] 에서 지정된 확률 또는 벡터 또는 확률의 튜플 &lt;code&gt;p&lt;/code&gt; 에서 컬렉션 &lt;code&gt;itr&lt;/code&gt; 의 Quantile을 계산합니다 . 키워드 인수 &lt;code&gt;sorted&lt;/code&gt; 있는지 여부를 나타냅니다 &lt;code&gt;itr&lt;/code&gt; 정렬 할 가정 할 수있다.</target>
        </trans-unit>
        <trans-unit id="eb2c3240f4729969dc3c9a6a7351fdcf66f680d9" translate="yes" xml:space="preserve">
          <source>Compute the quantile(s) of a vector &lt;code&gt;v&lt;/code&gt; at a specified probability or vector or tuple of probabilities &lt;code&gt;p&lt;/code&gt; on the interval [0,1]. If &lt;code&gt;p&lt;/code&gt; is a vector, an optional output array &lt;code&gt;q&lt;/code&gt; may also be specified. (If not provided, a new output array is created.) The keyword argument &lt;code&gt;sorted&lt;/code&gt; indicates whether &lt;code&gt;v&lt;/code&gt; can be assumed to be sorted; if &lt;code&gt;false&lt;/code&gt; (the default), then the elements of &lt;code&gt;v&lt;/code&gt; will be partially sorted in-place.</source>
          <target state="translated">구간 [0,1] 에서 지정된 확률 또는 벡터 또는 확률의 튜플 &lt;code&gt;p&lt;/code&gt; 에서 벡터 &lt;code&gt;v&lt;/code&gt; 의 Quantile (s)을 계산합니다 . 경우 &lt;code&gt;p&lt;/code&gt; 는 벡터이며, 선택 어레이의 출력 &lt;code&gt;q&lt;/code&gt; 또한 지정 될 수있다. (제공되지 않은 경우 새 출력 배열이 작성됩니다.) &lt;code&gt;sorted&lt;/code&gt; 키워드 인수 는 &lt;code&gt;v&lt;/code&gt; 를 정렬한다고 가정 할 수 있는지 여부를 나타냅니다 . &lt;code&gt;false&lt;/code&gt; 인 경우 (기본값) &lt;code&gt;v&lt;/code&gt; 의 요소 부분적으로 적절한 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="1bb368cffdd0709c3136c6eb4be4a7856720c163" translate="yes" xml:space="preserve">
          <source>Compute the rank of a matrix by counting how many singular values of &lt;code&gt;A&lt;/code&gt; have magnitude greater than &lt;code&gt;max(atol, rtol*&amp;sigma;₁)&lt;/code&gt; where &lt;code&gt;&amp;sigma;₁&lt;/code&gt; is &lt;code&gt;A&lt;/code&gt;'s largest singular value. &lt;code&gt;atol&lt;/code&gt; and &lt;code&gt;rtol&lt;/code&gt; are the absolute and relative tolerances, respectively. The default relative tolerance is &lt;code&gt;n*ϵ&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the size of the smallest dimension of &lt;code&gt;A&lt;/code&gt;, and &lt;code&gt;ϵ&lt;/code&gt; is the &lt;a href=&quot;../dates/index#Base.eps&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt; of the element type of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 특이 값 이 &lt;code&gt;max(atol, rtol*&amp;sigma;₁)&lt;/code&gt; 보다 큰 수 를 계산하여 행렬의 순위를 계산합니다. 여기서 &lt;code&gt;&amp;sigma;₁&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 의 가장 큰 특이 값입니다. &lt;code&gt;atol&lt;/code&gt; 및 &lt;code&gt;rtol&lt;/code&gt; 은 각각 절대 및 상대 공차입니다. 기본 상대 공차는 &lt;code&gt;n*ϵ&lt;/code&gt; 이며, 여기서 &lt;code&gt;n&lt;/code&gt; 은 &lt;code&gt;A&lt;/code&gt; 의 가장 작은 치수의 크기 이고 &lt;code&gt;ϵ&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 의 요소 유형의 &lt;a href=&quot;../dates/index#Base.eps&quot;&gt; &lt;code&gt;eps&lt;/code&gt; &lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="dc3f685504afbf8552c15cce21aef6fd26ceffd0" translate="yes" xml:space="preserve">
          <source>Compute the remainder of &lt;code&gt;x&lt;/code&gt; after integer division by &lt;code&gt;2&amp;pi;&lt;/code&gt;, with the quotient rounded according to the rounding mode &lt;code&gt;r&lt;/code&gt;. In other words, the quantity</source>
          <target state="translated">정수를 &lt;code&gt;2&amp;pi;&lt;/code&gt; 후 나머지 &lt;code&gt;x&lt;/code&gt; 를 2&amp;pi;로 계산하고 , 몫은 반올림 모드 &lt;code&gt;r&lt;/code&gt; 에 따라 반올림됩니다 . 즉, 수량</target>
        </trans-unit>
        <trans-unit id="95bc53629637126df14c31c62a968cf7ac84be97" translate="yes" xml:space="preserve">
          <source>Compute the sample standard deviation of collection &lt;code&gt;itr&lt;/code&gt;, with known mean(s) &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">알려진 평균 &lt;code&gt;m&lt;/code&gt; 으로 수집 &lt;code&gt;itr&lt;/code&gt; 의 표본 표준 편차를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="2013d0ec88dc549aea8806964d8579f321782fa9" translate="yes" xml:space="preserve">
          <source>Compute the sample standard deviation of collection &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">collection &lt;code&gt;itr&lt;/code&gt; 의 표본 표준 편차를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="2e6293fe931efad035e3dce11f90fbf4d514cf36" translate="yes" xml:space="preserve">
          <source>Compute the sample variance of collection &lt;code&gt;itr&lt;/code&gt;, with known mean(s) &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">알려진 평균 &lt;code&gt;m&lt;/code&gt; 을 사용 하여 콜렉션 &lt;code&gt;itr&lt;/code&gt; 의 표본 분산을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="7ad72bb7d52a6f023ffd8fa5902e661aa205b2ef" translate="yes" xml:space="preserve">
          <source>Compute the sample variance of collection &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">콜렉션 &lt;code&gt;itr&lt;/code&gt; 의 표본 분산을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="d52f9b298abf8ef3482717a4fb7d6eb7739d6697" translate="yes" xml:space="preserve">
          <source>Compute the secant of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in degrees.</source>
          <target state="translated">계산의 할선 &lt;code&gt;x&lt;/code&gt; 여기서 &lt;code&gt;x&lt;/code&gt; 도이다.</target>
        </trans-unit>
        <trans-unit id="56e3ce8cc803e620031d7e7d69e643ba6f727c31" translate="yes" xml:space="preserve">
          <source>Compute the secant of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in radians.</source>
          <target state="translated">계산의 할선 &lt;code&gt;x&lt;/code&gt; 여기서 &lt;code&gt;x&lt;/code&gt; 는 라디안이다.</target>
        </trans-unit>
        <trans-unit id="2d6fc0ea82100c7979c18fab715864258d67fcaf" translate="yes" xml:space="preserve">
          <source>Compute the singular value decomposition (SVD) of &lt;code&gt;A&lt;/code&gt; and return an &lt;code&gt;SVD&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 특이 값 분해 (SVD)를 계산하고 &lt;code&gt;SVD&lt;/code&gt; 객체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="18a494aebbe2cd9c9cce0054d7ab6b3d0c0ca78c" translate="yes" xml:space="preserve">
          <source>Compute the variance of the vector &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; (the default) then the sum is scaled with &lt;code&gt;n-1&lt;/code&gt;, whereas the sum is scaled with &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; where &lt;code&gt;n = length(x)&lt;/code&gt;.</source>
          <target state="translated">벡터 &lt;code&gt;x&lt;/code&gt; 의 분산을 계산합니다 . 경우 &lt;code&gt;corrected&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; (디폴트)를 합으로 스케일링 &lt;code&gt;n-1&lt;/code&gt; 합계는로 축소되는 반면, &lt;code&gt;n&lt;/code&gt; 만약 &lt;code&gt;corrected&lt;/code&gt; 인 &lt;code&gt;false&lt;/code&gt; &lt;code&gt;n = length(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="196dea2d8876d4f497fbf30018e3df07bf112e07" translate="yes" xml:space="preserve">
          <source>Computes &lt;code&gt;Q * C&lt;/code&gt; (&lt;code&gt;trans = N&lt;/code&gt;), &lt;code&gt;transpose(Q) * C&lt;/code&gt; (&lt;code&gt;trans = T&lt;/code&gt;), &lt;code&gt;adjoint(Q) * C&lt;/code&gt; (&lt;code&gt;trans = C&lt;/code&gt;) for &lt;code&gt;side = L&lt;/code&gt; or the equivalent right-sided multiplication for &lt;code&gt;side = R&lt;/code&gt; using &lt;code&gt;Q&lt;/code&gt; from a &lt;code&gt;LQ&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt; computed using &lt;code&gt;gelqf!&lt;/code&gt;. &lt;code&gt;C&lt;/code&gt; is overwritten.</source>
          <target state="translated">계산해 &lt;code&gt;Q * C&lt;/code&gt; ( &lt;code&gt;trans = N&lt;/code&gt; ), &lt;code&gt;transpose(Q) * C&lt;/code&gt; ( &lt;code&gt;trans = T&lt;/code&gt; ), &lt;code&gt;adjoint(Q) * C&lt;/code&gt; ( &lt;code&gt;trans = C&lt;/code&gt; 대) &lt;code&gt;side = L&lt;/code&gt; 또는 대한 등가 오른쪽면 승산 &lt;code&gt;side = R&lt;/code&gt; 사용 &lt;code&gt;Q&lt;/code&gt; &lt;code&gt;gelqf!&lt;/code&gt; 사용하여 계산 된 &lt;code&gt;A&lt;/code&gt; 의 &lt;code&gt;LQ&lt;/code&gt; 인수 분해에서 ! . &lt;code&gt;C&lt;/code&gt; 를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="330b5ac4ec8258723cd692371fc2e6df49989d5c" translate="yes" xml:space="preserve">
          <source>Computes &lt;code&gt;Q * C&lt;/code&gt; (&lt;code&gt;trans = N&lt;/code&gt;), &lt;code&gt;transpose(Q) * C&lt;/code&gt; (&lt;code&gt;trans = T&lt;/code&gt;), &lt;code&gt;adjoint(Q) * C&lt;/code&gt; (&lt;code&gt;trans = C&lt;/code&gt;) for &lt;code&gt;side = L&lt;/code&gt; or the equivalent right-sided multiplication for &lt;code&gt;side = R&lt;/code&gt; using &lt;code&gt;Q&lt;/code&gt; from a &lt;code&gt;QL&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt; computed using &lt;code&gt;geqlf!&lt;/code&gt;. &lt;code&gt;C&lt;/code&gt; is overwritten.</source>
          <target state="translated">계산해 &lt;code&gt;Q * C&lt;/code&gt; ( &lt;code&gt;trans = N&lt;/code&gt; ), &lt;code&gt;transpose(Q) * C&lt;/code&gt; ( &lt;code&gt;trans = T&lt;/code&gt; ), &lt;code&gt;adjoint(Q) * C&lt;/code&gt; ( &lt;code&gt;trans = C&lt;/code&gt; 대) &lt;code&gt;side = L&lt;/code&gt; 또는 대한 등가 오른쪽면 승산 &lt;code&gt;side = R&lt;/code&gt; 사용 &lt;code&gt;Q&lt;/code&gt; &lt;code&gt;geqlf!&lt;/code&gt; 사용하여 계산 된 &lt;code&gt;A&lt;/code&gt; 의 &lt;code&gt;QL&lt;/code&gt; 분해에서 . &lt;code&gt;C&lt;/code&gt; 를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="23c10a1f9dd38caaf076a8b1a4a078298190e02c" translate="yes" xml:space="preserve">
          <source>Computes &lt;code&gt;Q * C&lt;/code&gt; (&lt;code&gt;trans = N&lt;/code&gt;), &lt;code&gt;transpose(Q) * C&lt;/code&gt; (&lt;code&gt;trans = T&lt;/code&gt;), &lt;code&gt;adjoint(Q) * C&lt;/code&gt; (&lt;code&gt;trans = C&lt;/code&gt;) for &lt;code&gt;side = L&lt;/code&gt; or the equivalent right-sided multiplication for &lt;code&gt;side = R&lt;/code&gt; using &lt;code&gt;Q&lt;/code&gt; from a &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt; computed using &lt;code&gt;geqrf!&lt;/code&gt;. &lt;code&gt;C&lt;/code&gt; is overwritten.</source>
          <target state="translated">계산해 &lt;code&gt;Q * C&lt;/code&gt; ( &lt;code&gt;trans = N&lt;/code&gt; ), &lt;code&gt;transpose(Q) * C&lt;/code&gt; ( &lt;code&gt;trans = T&lt;/code&gt; ), &lt;code&gt;adjoint(Q) * C&lt;/code&gt; ( &lt;code&gt;trans = C&lt;/code&gt; 대) &lt;code&gt;side = L&lt;/code&gt; 또는 대한 등가 오른쪽면 승산 &lt;code&gt;side = R&lt;/code&gt; 사용 &lt;code&gt;Q&lt;/code&gt; &lt;code&gt;geqrf!&lt;/code&gt; 사용하여 계산 된 &lt;code&gt;A&lt;/code&gt; 의 &lt;code&gt;QR&lt;/code&gt; 분해에서 . &lt;code&gt;C&lt;/code&gt; 를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="c1e711025c5d1686044686723b7e4084534f7793" translate="yes" xml:space="preserve">
          <source>Computes &lt;code&gt;Q * C&lt;/code&gt; (&lt;code&gt;trans = N&lt;/code&gt;), &lt;code&gt;transpose(Q) * C&lt;/code&gt; (&lt;code&gt;trans = T&lt;/code&gt;), &lt;code&gt;adjoint(Q) * C&lt;/code&gt; (&lt;code&gt;trans = C&lt;/code&gt;) for &lt;code&gt;side = L&lt;/code&gt; or the equivalent right-sided multiplication for &lt;code&gt;side = R&lt;/code&gt; using &lt;code&gt;Q&lt;/code&gt; from a &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt; computed using &lt;code&gt;geqrt!&lt;/code&gt;. &lt;code&gt;C&lt;/code&gt; is overwritten.</source>
          <target state="translated">계산해 &lt;code&gt;Q * C&lt;/code&gt; ( &lt;code&gt;trans = N&lt;/code&gt; ), &lt;code&gt;transpose(Q) * C&lt;/code&gt; ( &lt;code&gt;trans = T&lt;/code&gt; ), &lt;code&gt;adjoint(Q) * C&lt;/code&gt; ( &lt;code&gt;trans = C&lt;/code&gt; 대) &lt;code&gt;side = L&lt;/code&gt; 또는 대한 등가 오른쪽면 승산 &lt;code&gt;side = R&lt;/code&gt; 사용 &lt;code&gt;Q&lt;/code&gt; &lt;code&gt;geqrt!&lt;/code&gt; 사용하여 계산 된 &lt;code&gt;A&lt;/code&gt; 의 &lt;code&gt;QR&lt;/code&gt; 분해에서 ! . &lt;code&gt;C&lt;/code&gt; 를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="3eae30893a76f76ba0b80fe1f33ca60ccd4a1a80" translate="yes" xml:space="preserve">
          <source>Computes &lt;code&gt;Q * C&lt;/code&gt; (&lt;code&gt;trans = N&lt;/code&gt;), &lt;code&gt;transpose(Q) * C&lt;/code&gt; (&lt;code&gt;trans = T&lt;/code&gt;), &lt;code&gt;adjoint(Q) * C&lt;/code&gt; (&lt;code&gt;trans = C&lt;/code&gt;) for &lt;code&gt;side = L&lt;/code&gt; or the equivalent right-sided multiplication for &lt;code&gt;side = R&lt;/code&gt; using &lt;code&gt;Q&lt;/code&gt; from a &lt;code&gt;RQ&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt; computed using &lt;code&gt;gerqf!&lt;/code&gt;. &lt;code&gt;C&lt;/code&gt; is overwritten.</source>
          <target state="translated">계산해 &lt;code&gt;Q * C&lt;/code&gt; ( &lt;code&gt;trans = N&lt;/code&gt; ), &lt;code&gt;transpose(Q) * C&lt;/code&gt; ( &lt;code&gt;trans = T&lt;/code&gt; ), &lt;code&gt;adjoint(Q) * C&lt;/code&gt; ( &lt;code&gt;trans = C&lt;/code&gt; 대) &lt;code&gt;side = L&lt;/code&gt; 또는 대한 등가 오른쪽면 승산 &lt;code&gt;side = R&lt;/code&gt; 사용 &lt;code&gt;Q&lt;/code&gt; &lt;code&gt;gerqf!&lt;/code&gt; 사용하여 계산 된 &lt;code&gt;A&lt;/code&gt; 의 &lt;code&gt;RQ&lt;/code&gt; 인수 분해에서 ! . &lt;code&gt;C&lt;/code&gt; 를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="15574eb06b260c277bf93ed3b4e329832dc2d2b0" translate="yes" xml:space="preserve">
          <source>Computes &lt;code&gt;x*y+z&lt;/code&gt; without rounding the intermediate result &lt;code&gt;x*y&lt;/code&gt;. On some systems this is significantly more expensive than &lt;code&gt;x*y+z&lt;/code&gt;. &lt;code&gt;fma&lt;/code&gt; is used to improve accuracy in certain algorithms. See &lt;a href=&quot;#Base.muladd&quot;&gt;&lt;code&gt;muladd&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">중간 결과 &lt;code&gt;x*y&lt;/code&gt; 를 반올림하지 않고 &lt;code&gt;x*y+z&lt;/code&gt; 를 계산 합니다. 일부 시스템에서는 &lt;code&gt;x*y+z&lt;/code&gt; 보다 훨씬 비쌉니다 . &lt;code&gt;fma&lt;/code&gt; 는 특정 알고리즘에서 정확도를 향상시키는 데 사용됩니다. &lt;a href=&quot;#Base.muladd&quot;&gt; &lt;code&gt;muladd&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8d2bf90fe337bc19a74db83f3cf8ee951ffa605" translate="yes" xml:space="preserve">
          <source>Computes a basis for the nullspace of &lt;code&gt;M&lt;/code&gt; by including the singular vectors of A whose singular have magnitude are greater than &lt;code&gt;max(atol, rtol*&amp;sigma;₁)&lt;/code&gt;, where &lt;code&gt;&amp;sigma;₁&lt;/code&gt; is &lt;code&gt;M&lt;/code&gt;'s largest singularvalue.</source>
          <target state="translated">특이 &lt;code&gt;max(atol, rtol*&amp;sigma;₁)&lt;/code&gt; 크기가 max (atol, rtol * &amp;sigma;₁) 보다 큰 A의 특이 벡터를 포함하여 &lt;code&gt;M&lt;/code&gt; 의 영 공간에 대한 기초를 계산합니다 . 여기서 &lt;code&gt;&amp;sigma;₁&lt;/code&gt; 는 &lt;code&gt;M&lt;/code&gt; 의 최대 특이 값입니다.</target>
        </trans-unit>
        <trans-unit id="d36744afe997ffcda5697a0694557892f6eb5206" translate="yes" xml:space="preserve">
          <source>Computes the (upper if &lt;code&gt;uplo = U&lt;/code&gt;, lower if &lt;code&gt;uplo = L&lt;/code&gt;) pivoted Cholesky decomposition of positive-definite matrix &lt;code&gt;A&lt;/code&gt; with a user-set tolerance &lt;code&gt;tol&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten by its Cholesky decomposition.</source>
          <target state="translated">사용자 설정 허용 오차 &lt;code&gt;tol&lt;/code&gt; 을 사용하여 양의 유한 행렬 &lt;code&gt;A&lt;/code&gt; 의 Cholesky 분해를 계산 ( &lt;code&gt;uplo = U&lt;/code&gt; 인 경우 &lt;code&gt;uplo = L&lt;/code&gt; , uplo = L 인 경우 하단)을 계산합니다 . Cholesky 분해로 &lt;code&gt;A&lt;/code&gt; 를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="fd36c39296e253cc9d8a070bacaf4f4bf9b57780" translate="yes" xml:space="preserve">
          <source>Computes the Bunch-Kaufman factorization of a Hermitian matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, the upper half of &lt;code&gt;A&lt;/code&gt; is stored. If &lt;code&gt;uplo = L&lt;/code&gt;, the lower half is stored.</source>
          <target state="translated">에르 미트 행렬 &lt;code&gt;A&lt;/code&gt; 의 Bunch-Kaufman 인수 분해를 계산합니다 . 경우 &lt;code&gt;uplo = U&lt;/code&gt; 의 상반부 &lt;code&gt;A&lt;/code&gt; 는 저장됩니다. 경우 &lt;code&gt;uplo = L&lt;/code&gt; , 하반부가 저장된다.</target>
        </trans-unit>
        <trans-unit id="22428da5be587cdee5b6c05cffa201cf9861cc3c" translate="yes" xml:space="preserve">
          <source>Computes the Bunch-Kaufman factorization of a symmetric matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, the upper half of &lt;code&gt;A&lt;/code&gt; is stored. If &lt;code&gt;uplo = L&lt;/code&gt;, the lower half is stored.</source>
          <target state="translated">대칭 행렬 &lt;code&gt;A&lt;/code&gt; 의 Bunch-Kaufman 인수 분해를 계산합니다 . 경우 &lt;code&gt;uplo = U&lt;/code&gt; 의 상반부 &lt;code&gt;A&lt;/code&gt; 는 저장됩니다. 경우 &lt;code&gt;uplo = L&lt;/code&gt; , 하반부가 저장된다.</target>
        </trans-unit>
        <trans-unit id="f19c7e8b3174b328131e9e17030c6148cf8f127e" translate="yes" xml:space="preserve">
          <source>Computes the Cholesky (upper if &lt;code&gt;uplo = U&lt;/code&gt;, lower if &lt;code&gt;uplo = L&lt;/code&gt;) decomposition of positive-definite matrix &lt;code&gt;A&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten and returned with an info code.</source>
          <target state="translated">양의 유한 행렬 &lt;code&gt;A&lt;/code&gt; 의 &lt;code&gt;uplo = U&lt;/code&gt; 스키 ( uplo = U 인 경우 상위 , &lt;code&gt;uplo = L&lt;/code&gt; 경우 하위 분해)를 계산합니다 . &lt;code&gt;A&lt;/code&gt; 를 덮어 쓰고 정보 코드로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0cafabd44437dbd8e485ca59504c069c025da1ad" translate="yes" xml:space="preserve">
          <source>Computes the Generalized Schur (or QZ) factorization of the matrices &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;. The (quasi) triangular Schur factors can be obtained from the &lt;code&gt;Schur&lt;/code&gt; object &lt;code&gt;F&lt;/code&gt; with &lt;code&gt;F.S&lt;/code&gt; and &lt;code&gt;F.T&lt;/code&gt;, the left unitary/orthogonal Schur vectors can be obtained with &lt;code&gt;F.left&lt;/code&gt; or &lt;code&gt;F.Q&lt;/code&gt; and the right unitary/orthogonal Schur vectors can be obtained with &lt;code&gt;F.right&lt;/code&gt; or &lt;code&gt;F.Z&lt;/code&gt; such that &lt;code&gt;A=F.left*F.S*F.right'&lt;/code&gt; and &lt;code&gt;B=F.left*F.T*F.right'&lt;/code&gt;. The generalized eigenvalues of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; can be obtained with &lt;code&gt;F.&amp;alpha;./F.&amp;beta;&lt;/code&gt;.</source>
          <target state="translated">행렬 &lt;code&gt;A&lt;/code&gt; 및 &lt;code&gt;B&lt;/code&gt; 의 일반화 된 Schur (또는 QZ) 인수 분해를 계산합니다 . &lt;code&gt;F.S&lt;/code&gt; 및 &lt;code&gt;F.T&lt;/code&gt; 갖는 &lt;code&gt;Schur&lt;/code&gt; 객체 &lt;code&gt;F&lt;/code&gt; 로부터 (quasi) 삼각 슈어 팩터가 얻어 질 수 있고 , 좌측 유니 터리 / 직교 슈어 벡터는 &lt;code&gt;F.left&lt;/code&gt; 또는 &lt;code&gt;F.Q&lt;/code&gt; 로 얻어 질 수 있고 우측 유니 터리 / 직교 슈어 벡터는 &lt;code&gt;F.right&lt;/code&gt; 로 얻어 질 수있다 . 오른쪽 또는 &lt;code&gt;F.Z&lt;/code&gt; 되도록 &lt;code&gt;A=F.left*F.S*F.right'&lt;/code&gt; 및 &lt;code&gt;B=F.left*F.T*F.right'&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 의 일반 고유 값은 로 구할 수 있습니다 . &lt;code&gt;F.&amp;alpha;./F.&amp;beta;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3efb8aa207d5af77f49688b04559bb67415cf85e" translate="yes" xml:space="preserve">
          <source>Computes the Givens rotation &lt;code&gt;G&lt;/code&gt; and scalar &lt;code&gt;r&lt;/code&gt; such that for any vector &lt;code&gt;x&lt;/code&gt; where</source>
          <target state="translated">Givens 회전 &lt;code&gt;G&lt;/code&gt; 와 스칼라 &lt;code&gt;r&lt;/code&gt; 을 계산하여 모든 벡터 &lt;code&gt;x&lt;/code&gt; 에 대해 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="3b7b86c4db1c49294f9afcc1c05c3a761727f9b0" translate="yes" xml:space="preserve">
          <source>Computes the Givens rotation &lt;code&gt;G&lt;/code&gt; and scalar &lt;code&gt;r&lt;/code&gt; such that the result of the multiplication</source>
          <target state="translated">곱셈의 결과가 되도록 기븐스 회전 &lt;code&gt;G&lt;/code&gt; 와 스칼라 &lt;code&gt;r&lt;/code&gt; 을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="db4721bd00c3c65fe61a8b0bdb9fd8f8985ae6ed" translate="yes" xml:space="preserve">
          <source>Computes the LDLt factorization of a positive-definite tridiagonal matrix with &lt;code&gt;D&lt;/code&gt; as diagonal and &lt;code&gt;E&lt;/code&gt; as off-diagonal. &lt;code&gt;D&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt; are overwritten and returned.</source>
          <target state="translated">&lt;code&gt;D&lt;/code&gt; 를 대각선으로, &lt;code&gt;E&lt;/code&gt; 를 비 대각선 으로 사용하여 양의 유한 삼각 행렬의 LDLt 인수 분해를 계산합니다 . &lt;code&gt;D&lt;/code&gt; 와 &lt;code&gt;E&lt;/code&gt; 를 덮어 쓰고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="915ececcc0f410ce7a63643c0b6e374861bcd250" translate="yes" xml:space="preserve">
          <source>Computes the Moore-Penrose pseudoinverse.</source>
          <target state="translated">무어-펜로즈 유사 역사를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="6055e64119c4c7498a33b99f97eb16c43da95186" translate="yes" xml:space="preserve">
          <source>Computes the Schur factorization of the matrix &lt;code&gt;A&lt;/code&gt;. The (quasi) triangular Schur factor can be obtained from the &lt;code&gt;Schur&lt;/code&gt; object &lt;code&gt;F&lt;/code&gt; with either &lt;code&gt;F.Schur&lt;/code&gt; or &lt;code&gt;F.T&lt;/code&gt; and the orthogonal/unitary Schur vectors can be obtained with &lt;code&gt;F.vectors&lt;/code&gt; or &lt;code&gt;F.Z&lt;/code&gt; such that &lt;code&gt;A = F.vectors * F.Schur * F.vectors'&lt;/code&gt;. The eigenvalues of &lt;code&gt;A&lt;/code&gt; can be obtained with &lt;code&gt;F.values&lt;/code&gt;.</source>
          <target state="translated">행렬 &lt;code&gt;A&lt;/code&gt; 의 Schur 인수 분해를 계산합니다 . 로부터 수득 될 수있는 삼각 슈어 배율이 (준) &lt;code&gt;Schur&lt;/code&gt; 오브젝트 &lt;code&gt;F&lt;/code&gt; 중 어느 하나에 &lt;code&gt;F.Schur&lt;/code&gt; 또는 &lt;code&gt;F.T&lt;/code&gt; 및 직교 / 슈어 단위 벡터를 얻을 수있다 &lt;code&gt;F.vectors&lt;/code&gt; 이나 &lt;code&gt;F.Z&lt;/code&gt; 되도록 &lt;code&gt;A = F.vectors * F.Schur * F.vectors'&lt;/code&gt; 입니다. &lt;code&gt;A&lt;/code&gt; 의 고유 값은 &lt;code&gt;F.values&lt;/code&gt; 로 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be77495485da8e82a774262ef640c248f097d559" translate="yes" xml:space="preserve">
          <source>Computes the eigensystem for a symmetric tridiagonal matrix with &lt;code&gt;dv&lt;/code&gt; as diagonal and &lt;code&gt;ev&lt;/code&gt; as off-diagonal. If &lt;code&gt;job = N&lt;/code&gt; only the eigenvalues are found and returned in &lt;code&gt;dv&lt;/code&gt;. If &lt;code&gt;job = V&lt;/code&gt; then the eigenvectors are also found and returned in &lt;code&gt;Zmat&lt;/code&gt;.</source>
          <target state="translated">대각선 이 &lt;code&gt;dv&lt;/code&gt; 이고 대각선이 &lt;code&gt;ev&lt;/code&gt; 인 대칭 삼각대 각 행렬에 대한 고유 시스템을 계산합니다 . 경우 &lt;code&gt;job = N&lt;/code&gt; 에만 고유 값을 찾아 반환되는 &lt;code&gt;dv&lt;/code&gt; . 경우 &lt;code&gt;job = V&lt;/code&gt; 그 고유 벡터는 발견에 반환됩니다 &lt;code&gt;Zmat&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0c2d756bd2ee3d8520442f71f1acb8461142c55" translate="yes" xml:space="preserve">
          <source>Computes the eigenvalue decomposition of &lt;code&gt;A&lt;/code&gt;, returning an &lt;code&gt;Eigen&lt;/code&gt; factorization object &lt;code&gt;F&lt;/code&gt; which contains the eigenvalues in &lt;code&gt;F.values&lt;/code&gt; and the eigenvectors in the columns of the matrix &lt;code&gt;F.vectors&lt;/code&gt;. (The &lt;code&gt;k&lt;/code&gt;th eigenvector can be obtained from the slice &lt;code&gt;F.vectors[:, k]&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 고유 값 분해를 계산하여 &lt;code&gt;F.values&lt;/code&gt; 의 고유 값 과 행렬 &lt;code&gt;F.vectors&lt;/code&gt; 열의 고유 벡터 를 포함 하는 &lt;code&gt;Eigen&lt;/code&gt; 인수 분해 객체 &lt;code&gt;F&lt;/code&gt; 를 반환합니다 . ( &lt;code&gt;k&lt;/code&gt; 번째 고유 벡터는 슬라이스 &lt;code&gt;F.vectors[:, k]&lt;/code&gt; 에서 얻을 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="56ef3f44145e5cbb1d7b50f00f2bd9fcc16d97eb" translate="yes" xml:space="preserve">
          <source>Computes the eigenvalues (&lt;code&gt;jobvs = N&lt;/code&gt;) or the eigenvalues and Schur vectors (&lt;code&gt;jobvs = V&lt;/code&gt;) of matrix &lt;code&gt;A&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten by its Schur form.</source>
          <target state="translated">행렬 &lt;code&gt;A&lt;/code&gt; 의 고유 값 ( &lt;code&gt;jobvs = N&lt;/code&gt; ) 또는 고유 값과 Schur 벡터 ( &lt;code&gt;jobvs = V&lt;/code&gt; )를 계산 합니다. &lt;code&gt;A&lt;/code&gt; 는 Schur 양식으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="5a3a0443d72fdbb0792684407d1da11dd17bf077" translate="yes" xml:space="preserve">
          <source>Computes the eigenvalues (&lt;code&gt;jobz = N&lt;/code&gt;) or eigenvalues and eigenvectors (&lt;code&gt;jobz = V&lt;/code&gt;) for a symmetric tridiagonal matrix with &lt;code&gt;dv&lt;/code&gt; as diagonal and &lt;code&gt;ev&lt;/code&gt; as off-diagonal. If &lt;code&gt;range = A&lt;/code&gt;, all the eigenvalues are found. If &lt;code&gt;range = V&lt;/code&gt;, the eigenvalues in the half-open interval &lt;code&gt;(vl, vu]&lt;/code&gt; are found. If &lt;code&gt;range = I&lt;/code&gt;, the eigenvalues with indices between &lt;code&gt;il&lt;/code&gt; and &lt;code&gt;iu&lt;/code&gt; are found. The eigenvalues are returned in &lt;code&gt;w&lt;/code&gt; and the eigenvectors in &lt;code&gt;Z&lt;/code&gt;.</source>
          <target state="translated">대각선 이 &lt;code&gt;dv&lt;/code&gt; 이고 대각선이 &lt;code&gt;ev&lt;/code&gt; 인 대칭 3 &lt;code&gt;jobz = V&lt;/code&gt; 행렬에 대한 고유 값 ( &lt;code&gt;jobz = N&lt;/code&gt; ) 또는 고유 값과 고유 벡터 ( jobz = V )를 계산합니다 . 경우 &lt;code&gt;range = A&lt;/code&gt; , 모든 고유 값이 발견된다. 만약 &lt;code&gt;range = V&lt;/code&gt; , 반 열린 구간에서 고유 값 &lt;code&gt;(vl, vu]&lt;/code&gt; 발견된다. 경우 &lt;code&gt;range = I&lt;/code&gt; 사이의 지수와 고유 값 &lt;code&gt;il&lt;/code&gt; 및 &lt;code&gt;iu&lt;/code&gt; 발견된다. 고유 값이 반환된다 &lt;code&gt;w&lt;/code&gt; 및 고유 벡터의 &lt;code&gt;Z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="702fe6d75fff16642d7459ba596ae090bfec93a0" translate="yes" xml:space="preserve">
          <source>Computes the eigenvalues for a symmetric tridiagonal matrix with &lt;code&gt;dv&lt;/code&gt; as diagonal and &lt;code&gt;ev&lt;/code&gt; as off-diagonal. If &lt;code&gt;range = A&lt;/code&gt;, all the eigenvalues are found. If &lt;code&gt;range = V&lt;/code&gt;, the eigenvalues in the half-open interval &lt;code&gt;(vl, vu]&lt;/code&gt; are found. If &lt;code&gt;range = I&lt;/code&gt;, the eigenvalues with indices between &lt;code&gt;il&lt;/code&gt; and &lt;code&gt;iu&lt;/code&gt; are found. If &lt;code&gt;order = B&lt;/code&gt;, eigvalues are ordered within a block. If &lt;code&gt;order = E&lt;/code&gt;, they are ordered across all the blocks. &lt;code&gt;abstol&lt;/code&gt; can be set as a tolerance for convergence.</source>
          <target state="translated">대각선 이 &lt;code&gt;dv&lt;/code&gt; 이고 대각선이 &lt;code&gt;ev&lt;/code&gt; 인 대칭 삼각대 각 행렬의 고유 값을 계산합니다 . 경우 &lt;code&gt;range = A&lt;/code&gt; , 모든 고유 값이 발견된다. 경우 &lt;code&gt;range = V&lt;/code&gt; , 반 열린 구간에서 고유 값 &lt;code&gt;(vl, vu]&lt;/code&gt; 발견된다. 경우 &lt;code&gt;range = I&lt;/code&gt; 사이의 지수와 고유 값 &lt;code&gt;il&lt;/code&gt; 및 &lt;code&gt;iu&lt;/code&gt; 발견된다. 경우 &lt;code&gt;order = B&lt;/code&gt; , eigvalues가 블록 내에서 정렬된다. 만약 &lt;code&gt;order = E&lt;/code&gt; 이면 모든 블록에 걸쳐 정렬되며 &lt;code&gt;abstol&lt;/code&gt; 은 수렴에 대한 공차로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2774f3063f2166a20accf4c30f58fa05930aee13" translate="yes" xml:space="preserve">
          <source>Computes the eigenvectors for a symmetric tridiagonal matrix with &lt;code&gt;dv&lt;/code&gt; as diagonal and &lt;code&gt;ev_in&lt;/code&gt; as off-diagonal. &lt;code&gt;w_in&lt;/code&gt; specifies the input eigenvalues for which to find corresponding eigenvectors. &lt;code&gt;iblock_in&lt;/code&gt; specifies the submatrices corresponding to the eigenvalues in &lt;code&gt;w_in&lt;/code&gt;. &lt;code&gt;isplit_in&lt;/code&gt; specifies the splitting points between the submatrix blocks.</source>
          <target state="translated">대각선 이 &lt;code&gt;dv&lt;/code&gt; 이고 대각선이 &lt;code&gt;ev_in&lt;/code&gt; 인 대칭 삼각대 각 행렬에 대한 고유 벡터를 계산합니다 . &lt;code&gt;w_in&lt;/code&gt; 은 해당 고유 벡터를 찾을 입력 고유 값을 지정합니다. &lt;code&gt;iblock_in&lt;/code&gt; 은 &lt;code&gt;w_in&lt;/code&gt; 의 고유 값에 해당하는 하위 행렬을 지정합니다 . &lt;code&gt;isplit_in&lt;/code&gt; 은 서브 매트릭스 블록 사이의 분할 지점을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="22cb9800f1213961f1d9d7750f55ad1f1358c888" translate="yes" xml:space="preserve">
          <source>Computes the generalized eigenvalue decomposition of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, returning a &lt;code&gt;GeneralizedEigen&lt;/code&gt; factorization object &lt;code&gt;F&lt;/code&gt; which contains the generalized eigenvalues in &lt;code&gt;F.values&lt;/code&gt; and the generalized eigenvectors in the columns of the matrix &lt;code&gt;F.vectors&lt;/code&gt;. (The &lt;code&gt;k&lt;/code&gt;th generalized eigenvector can be obtained from the slice &lt;code&gt;F.vectors[:, k]&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 의 일반 고유 값 분해를 계산하여 &lt;code&gt;F.values&lt;/code&gt; 의 일반 고유 값 과 행렬 &lt;code&gt;F.vectors&lt;/code&gt; 의 열에 일반 고유 벡터 가 포함 &lt;code&gt;GeneralizedEigen&lt;/code&gt; 인수 분해 객체 &lt;code&gt;F&lt;/code&gt; 를 반환합니다 . ( &lt;code&gt;k&lt;/code&gt; 번째 일반화 된 고유 벡터는 슬라이스 &lt;code&gt;F.vectors[:, k]&lt;/code&gt; 에서 얻을 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="02b33b45277ccf1798c5db9f681b4fbc2af0b721" translate="yes" xml:space="preserve">
          <source>Computes the generalized eigenvalues of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 의 일반 고유 값을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="30705de9147ff967461851722fa377560561d2ce" translate="yes" xml:space="preserve">
          <source>Computes the generalized eigenvalues, generalized Schur form, left Schur vectors (&lt;code&gt;jobsvl = V&lt;/code&gt;), or right Schur vectors (&lt;code&gt;jobvsr = V&lt;/code&gt;) of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 의 일반 고유 값, 일반 Schur 양식, 왼쪽 Schur 벡터 ( &lt;code&gt;jobsvl = V&lt;/code&gt; ) 또는 오른쪽 Schur 벡터 ( &lt;code&gt;jobvsr = V&lt;/code&gt; )를 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="7d9d5c41f59e436c6611c2108f610d3d4369c1d3" translate="yes" xml:space="preserve">
          <source>Computes the greatest common (positive) divisor of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; and their B&amp;eacute;zout coefficients, i.e. the integer coefficients &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; that satisfy $ux+vy = d = gcd(x,y)$. $gcdx(x,y)$ returns $(d,u,v)$.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 최대 공약 (긍정) 제수 와 B&amp;eacute;zout 계수, 즉 $ ux + vy = d = gcd (x, y) $를 만족 하는 정수 계수 &lt;code&gt;u&lt;/code&gt; 와 &lt;code&gt;v&lt;/code&gt; 를 계산 합니다. $ gcdx (x, y) $는 $ (d, u, v) $를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d356d77cd7680b87bc3b49a0e273970ad7f27896" translate="yes" xml:space="preserve">
          <source>Computes the inverse of &lt;code&gt;A&lt;/code&gt;, using its &lt;code&gt;LU&lt;/code&gt; factorization found by &lt;code&gt;getrf!&lt;/code&gt;. &lt;code&gt;ipiv&lt;/code&gt; is the pivot information output and &lt;code&gt;A&lt;/code&gt; contains the &lt;code&gt;LU&lt;/code&gt; factorization of &lt;code&gt;getrf!&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten with its inverse.</source>
          <target state="translated">&lt;code&gt;getrf!&lt;/code&gt; 찾은 &lt;code&gt;LU&lt;/code&gt; 인수 분해를 사용하여 &lt;code&gt;A&lt;/code&gt; 의 역을 계산합니다 . . &lt;code&gt;ipiv&lt;/code&gt; 는 피벗 정보 출력이고 &lt;code&gt;A&lt;/code&gt; 는 &lt;code&gt;getrf!&lt;/code&gt; 의 &lt;code&gt;LU&lt;/code&gt; 분해를 포함합니다 ! . &lt;code&gt;A&lt;/code&gt; 는 역으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="cb2e1de5980a4a4f0fbdf482a5ea64f2c959a899" translate="yes" xml:space="preserve">
          <source>Computes the inverse of a Hermitian matrix &lt;code&gt;A&lt;/code&gt; using the results of &lt;code&gt;sytrf!&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, the upper half of &lt;code&gt;A&lt;/code&gt; is stored. If &lt;code&gt;uplo = L&lt;/code&gt;, the lower half is stored. &lt;code&gt;A&lt;/code&gt; is overwritten by its inverse.</source>
          <target state="translated">&lt;code&gt;sytrf!&lt;/code&gt; 의 결과를 사용하여 에르 미트 행렬 &lt;code&gt;A&lt;/code&gt; 의 역을 계산합니다 ! . 경우 &lt;code&gt;uplo = U&lt;/code&gt; 의 상반부 &lt;code&gt;A&lt;/code&gt; 는 저장됩니다. 경우 &lt;code&gt;uplo = L&lt;/code&gt; , 하반부가 저장된다. &lt;code&gt;A&lt;/code&gt; 는 역으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="39d4577d522bd768286b7114ac09a7dc67a68d58" translate="yes" xml:space="preserve">
          <source>Computes the inverse of a symmetric matrix &lt;code&gt;A&lt;/code&gt; using the results of &lt;code&gt;sytrf!&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, the upper half of &lt;code&gt;A&lt;/code&gt; is stored. If &lt;code&gt;uplo = L&lt;/code&gt;, the lower half is stored. &lt;code&gt;A&lt;/code&gt; is overwritten by its inverse.</source>
          <target state="translated">&lt;code&gt;sytrf!&lt;/code&gt; 의 결과를 사용하여 대칭 행렬 &lt;code&gt;A&lt;/code&gt; 의 역을 계산합니다 . . 경우 &lt;code&gt;uplo = U&lt;/code&gt; 의 상반부 &lt;code&gt;A&lt;/code&gt; 는 저장됩니다. 경우 &lt;code&gt;uplo = L&lt;/code&gt; , 하반부가 저장된다. &lt;code&gt;A&lt;/code&gt; 는 역으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="aa616fdc7bbc88179bfd3ddbbcdba42b387701e0" translate="yes" xml:space="preserve">
          <source>Computes the inverse of positive-definite matrix &lt;code&gt;A&lt;/code&gt; after calling &lt;code&gt;potrf!&lt;/code&gt; to find its (upper if &lt;code&gt;uplo = U&lt;/code&gt;, lower if &lt;code&gt;uplo = L&lt;/code&gt;) Cholesky decomposition.</source>
          <target state="translated">&lt;code&gt;potrf!&lt;/code&gt; 를 호출 &lt;code&gt;A&lt;/code&gt; 후 양의 유한 행렬 A 의 역을 계산합니다 ! Cholesky 분해 를 찾기 위해 ( &lt;code&gt;uplo = U&lt;/code&gt; 인 경우 &lt;code&gt;uplo = L&lt;/code&gt; , uplo = L 인 경우 낮추십시오 ).</target>
        </trans-unit>
        <trans-unit id="d0e374af8acff15741567ccb37ae6e22ca3d3352" translate="yes" xml:space="preserve">
          <source>Computes the least norm solution of &lt;code&gt;A * X = B&lt;/code&gt; by finding the &lt;code&gt;SVD&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, then dividing-and-conquering the problem. &lt;code&gt;B&lt;/code&gt; is overwritten with the solution &lt;code&gt;X&lt;/code&gt;. Singular values below &lt;code&gt;rcond&lt;/code&gt; will be treated as zero. Returns the solution in &lt;code&gt;B&lt;/code&gt; and the effective rank of &lt;code&gt;A&lt;/code&gt; in &lt;code&gt;rnk&lt;/code&gt;.</source>
          <target state="translated">최소한의 표준 용액 계산 &lt;code&gt;A * X = B&lt;/code&gt; 발견하여 &lt;code&gt;SVD&lt;/code&gt; 에 의 인수 &lt;code&gt;A&lt;/code&gt; 다음 분할 및 정복 문제. &lt;code&gt;B&lt;/code&gt; 솔루션 &lt;code&gt;X&lt;/code&gt; 로 를 덮어 씁니다 . &lt;code&gt;rcond&lt;/code&gt; 아래의 특이 값 은 0으로 처리됩니다. 에서 솔루션 반환 &lt;code&gt;B&lt;/code&gt; 와의 효과적인 순위 에 &lt;code&gt;rnk&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9772f2cb554e6714e2d0249e5923646b5c83167" translate="yes" xml:space="preserve">
          <source>Computes the least norm solution of &lt;code&gt;A * X = B&lt;/code&gt; by finding the full &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, then dividing-and-conquering the problem. &lt;code&gt;B&lt;/code&gt; is overwritten with the solution &lt;code&gt;X&lt;/code&gt;. Singular values below &lt;code&gt;rcond&lt;/code&gt; will be treated as zero. Returns the solution in &lt;code&gt;B&lt;/code&gt; and the effective rank of &lt;code&gt;A&lt;/code&gt; in &lt;code&gt;rnk&lt;/code&gt;.</source>
          <target state="translated">최소한의 표준 용액 계산 &lt;code&gt;A * X = B&lt;/code&gt; 전체 찾아 &lt;code&gt;QR&lt;/code&gt; 에 의 인수 &lt;code&gt;A&lt;/code&gt; 다음 분할 및 정복 문제. 솔루션으로 &lt;code&gt;B&lt;/code&gt; 를 덮어 씁니다. &lt;code&gt;X&lt;/code&gt; 로 . &lt;code&gt;rcond&lt;/code&gt; 아래의 특이 값 은 0으로 처리됩니다. 에서 솔루션 반환 &lt;code&gt;B&lt;/code&gt; 와의 효과적인 순위 에 &lt;code&gt;rnk&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ce03bad87638dae01e4efdac4ef134e0c01c10b0" translate="yes" xml:space="preserve">
          <source>Computes the singular value decomposition of a bidiagonal matrix with &lt;code&gt;d&lt;/code&gt; on the diagonal and &lt;code&gt;e_&lt;/code&gt; on the off-diagonal using a divide and conqueq method. If &lt;code&gt;uplo = U&lt;/code&gt;, &lt;code&gt;e_&lt;/code&gt; is the superdiagonal. If &lt;code&gt;uplo = L&lt;/code&gt;, &lt;code&gt;e_&lt;/code&gt; is the subdiagonal. If &lt;code&gt;compq = N&lt;/code&gt;, only the singular values are found. If &lt;code&gt;compq = I&lt;/code&gt;, the singular values and vectors are found. If &lt;code&gt;compq = P&lt;/code&gt;, the singular values and vectors are found in compact form. Only works for real types.</source>
          <target state="translated">나누기 및 conqueq 방법을 사용하여 대각선의 &lt;code&gt;d&lt;/code&gt; 와 대각선의 &lt;code&gt;e_&lt;/code&gt; 를 사용하여 양각 행렬의 특이 값 분해를 계산합니다 . 경우 &lt;code&gt;uplo = U&lt;/code&gt; , &lt;code&gt;e_&lt;/code&gt; superdiagonal입니다. &lt;code&gt;uplo = L&lt;/code&gt; 경우 , &lt;code&gt;e_&lt;/code&gt; subdiagonal이다. 경우 &lt;code&gt;compq = N&lt;/code&gt; 만을 특이 값이 발견된다. 경우 &lt;code&gt;compq = I&lt;/code&gt; , 단수 가치와 벡터 발견된다. 경우 &lt;code&gt;compq = P&lt;/code&gt; , 특이 값 벡터는 콤팩트 형태로 발견된다. 실제 유형에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ec9c09340ab1167b34372c3c45f1effd39014b33" translate="yes" xml:space="preserve">
          <source>Computes the singular value decomposition of a bidiagonal matrix with &lt;code&gt;d&lt;/code&gt; on the diagonal and &lt;code&gt;e_&lt;/code&gt; on the off-diagonal. If &lt;code&gt;uplo = U&lt;/code&gt;, &lt;code&gt;e_&lt;/code&gt; is the superdiagonal. If &lt;code&gt;uplo = L&lt;/code&gt;, &lt;code&gt;e_&lt;/code&gt; is the subdiagonal. Can optionally also compute the product &lt;code&gt;Q' * C&lt;/code&gt;.</source>
          <target state="translated">2 각 행렬의 특이 값 분해를 대각선에 &lt;code&gt;d&lt;/code&gt; , 대각선 이외에 &lt;code&gt;e_&lt;/code&gt; 를 사용하여 계산합니다 . 경우 &lt;code&gt;uplo = U&lt;/code&gt; , &lt;code&gt;e_&lt;/code&gt; superdiagonal입니다. 경우 &lt;code&gt;uplo = L&lt;/code&gt; , &lt;code&gt;e_&lt;/code&gt; subdiagonal이다. 선택적으로 곱 &lt;code&gt;Q' * C&lt;/code&gt; 계산할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f21ee8aaad12edc3062dd893487ac52ed7206a6" translate="yes" xml:space="preserve">
          <source>Computes the solution &lt;code&gt;X&lt;/code&gt; to the Sylvester equation &lt;code&gt;AX + XB + C = 0&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; have compatible dimensions and &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; have no eigenvalues with equal real part.</source>
          <target state="translated">솔루션 &lt;code&gt;X&lt;/code&gt; 를 실베스터 방정식 &lt;code&gt;AX + XB + C = 0&lt;/code&gt; 계산합니다 . 여기서 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; 및 &lt;code&gt;C&lt;/code&gt; 는 호환되는 차원을 갖고 &lt;code&gt;A&lt;/code&gt; 및 &lt;code&gt;-B&lt;/code&gt; 는 동일한 실제 부분을 가진 고유 값을 갖지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aaf728832835285f8685228605bcbec78d5e39bc" translate="yes" xml:space="preserve">
          <source>Computes the solution &lt;code&gt;X&lt;/code&gt; to the continuous Lyapunov equation &lt;code&gt;AX + XA' + C = 0&lt;/code&gt;, where no eigenvalue of &lt;code&gt;A&lt;/code&gt; has a zero real part and no two eigenvalues are negative complex conjugates of each other.</source>
          <target state="translated">솔루션 &lt;code&gt;X&lt;/code&gt; 를 연속 리아 푸 노프 방정식 &lt;code&gt;AX + XA' + C = 0&lt;/code&gt; 으로 계산합니다 . 여기서 &lt;code&gt;A&lt;/code&gt; 의 고유 값은 0이 아니며 두 고유 값은 음의 복합 복소수입니다.</target>
        </trans-unit>
        <trans-unit id="2c4004422e3488a7fb54c4996a6f7cb083bc8c9e" translate="yes" xml:space="preserve">
          <source>Concatenate along dimension 1.</source>
          <target state="translated">차원 1을 따라 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="4629919e0ba100f50a2a2e401ed196f708cfd82e" translate="yes" xml:space="preserve">
          <source>Concatenate along dimension 2.</source>
          <target state="translated">차원 2를 따라 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="4d2f3e92e73a292cd5fe025535fd3fdcc9177e92" translate="yes" xml:space="preserve">
          <source>Concatenate matrices block-diagonally. Currently only implemented for sparse matrices.</source>
          <target state="translated">행렬을 블록 대각선으로 연결합니다. 현재 희소 행렬에 대해서만 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="1a6633f51709c6fbebf8bdadf15bf67930efc876" translate="yes" xml:space="preserve">
          <source>Concatenate strings and/or characters, producing a &lt;a href=&quot;#Core.String-Tuple%7BAbstractString%7D&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;. This is equivalent to calling the &lt;a href=&quot;#Base.string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; function on the arguments. Concatenation of built-in string types always produces a value of type &lt;code&gt;String&lt;/code&gt; but other string types may choose to return a string of a different type as appropriate.</source>
          <target state="translated">문자열 및 / 또는 문자를 연결하여 &lt;a href=&quot;#Core.String-Tuple%7BAbstractString%7D&quot;&gt; &lt;code&gt;String&lt;/code&gt; 을&lt;/a&gt; 생성합니다 . 이것은 &lt;a href=&quot;#Base.string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt; 을 호출하는 것과 같습니다. 인수 함수 . 내장 문자열 유형의 연결은 항상 타입의 값을 생성하는 &lt;code&gt;String&lt;/code&gt; 적절한 다른 유형의 문자열을 반환하도록 선택할 수 있지만, 다른 문자열 유형을.</target>
        </trans-unit>
        <trans-unit id="ce48b2ddcd6d1f0f5ea8babe3eb4d74d6a5100eb" translate="yes" xml:space="preserve">
          <source>Concatenate the input arrays along the specified dimensions in the iterable &lt;code&gt;dims&lt;/code&gt;. For dimensions not in &lt;code&gt;dims&lt;/code&gt;, all input arrays should have the same size, which will also be the size of the output array along that dimension. For dimensions in &lt;code&gt;dims&lt;/code&gt;, the size of the output array is the sum of the sizes of the input arrays along that dimension. If &lt;code&gt;dims&lt;/code&gt; is a single number, the different arrays are tightly stacked along that dimension. If &lt;code&gt;dims&lt;/code&gt; is an iterable containing several dimensions, this allows one to construct block diagonal matrices and their higher-dimensional analogues by simultaneously increasing several dimensions for every new input array and putting zero blocks elsewhere. For example, &lt;code&gt;cat(matrices...; dims=(1,2))&lt;/code&gt; builds a block diagonal matrix, i.e. a block matrix with &lt;code&gt;matrices[1]&lt;/code&gt;, &lt;code&gt;matrices[2]&lt;/code&gt;, ... as diagonal blocks and matching zero blocks away from the diagonal.</source>
          <target state="translated">iterable &lt;code&gt;dims&lt;/code&gt; 에서 지정된 차원을 따라 입력 배열을 연결하십시오 . 하지의 치수는 &lt;code&gt;dims&lt;/code&gt; 모든 입력 배열도 그 치수를 따라 출력 배열의 크기 가능할 동일한 크기를 가져야한다. 치수가 &lt;code&gt;dims&lt;/code&gt; 인 경우 출력 배열의 크기는 해당 차원을 따라 입력 배열의 크기의 합입니다. 경우 &lt;code&gt;dims&lt;/code&gt; 하나의 숫자이며, 다른 배열은 엄격하게 그 크기에 따라 적층되어있다. &lt;code&gt;dims&lt;/code&gt; 가 여러 차원을 포함하는 iterable 인 경우 , 모든 새로운 입력 배열에 대해 여러 차원을 동시에 증가시키고 다른 곳에 0 개의 블록을 두어 블록 대각선 행렬과 더 높은 차원의 아날로그를 구성 할 수 있습니다. 예를 들어 &lt;code&gt;cat(matrices...; dims=(1,2))&lt;/code&gt; 는 블록 대각선 행렬, 즉 &lt;code&gt;matrices[1]&lt;/code&gt; , &lt;code&gt;matrices[2]&lt;/code&gt; , ...를 대각선 블록으로하고 대각선에서 0 블록을 일치 시키는 블록 행렬을 만듭니다. .</target>
        </trans-unit>
        <trans-unit id="eec037fd21cdbe752cf956ee1da877b809e27461" translate="yes" xml:space="preserve">
          <source>Concatenation</source>
          <target state="translated">Concatenation</target>
        </trans-unit>
        <trans-unit id="e57bdd9a9f868f0fe536fc4a82988aa7ab5eb4ce" translate="yes" xml:space="preserve">
          <source>Concatenation and permutation</source>
          <target state="translated">연결과 순열</target>
        </trans-unit>
        <trans-unit id="410d5f3b6433c7572682965906a75036cfaaf8dc" translate="yes" xml:space="preserve">
          <source>Concatenation syntax can similarly be prefixed with a type to specify the element type of the result.</source>
          <target state="translated">연결 구문에는 결과의 요소 유형을 지정하는 유형이 접두어로 붙을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a0a67dece6f1d14e99beeba39e9ccd30856c117" translate="yes" xml:space="preserve">
          <source>Conceptually, a string is a &lt;em&gt;partial function&lt;/em&gt; from indices to characters: for some index values, no character value is returned, and instead an exception is thrown. This allows for efficient indexing into strings by the byte index of an encoded representation rather than by a character index, which cannot be implemented both efficiently and simply for variable-width encodings of Unicode strings.</source>
          <target state="translated">개념적으로 문자열은 인덱스에서 문자까지 &lt;em&gt;부분 함수&lt;/em&gt; 입니다. 일부 인덱스 값의 경우 문자 값이 반환되지 않고 예외가 발생합니다. 따라서 문자 인덱스가 아닌 인코딩 된 표현의 바이트 인덱스를 사용하여 문자열을 효율적으로 인덱싱 할 수 있습니다. 이는 유니 코드 문자열의 가변 너비 인코딩을 효율적이고 간단하게 구현할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cbea4d31c59c78035ac57d6aea6a10af5718acc3" translate="yes" xml:space="preserve">
          <source>Concerning 1), a &lt;code&gt;rand&lt;/code&gt; method may happen to work automatically, but it's not officially supported and may break without warnings in a subsequent release.</source>
          <target state="translated">1) &lt;code&gt;rand&lt;/code&gt; 방법은 자동으로 작동하지만 공식적으로 지원되지 않으며 후속 릴리스에서 경고없이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="28d538a9ac44a88ceec5d9363eb9b5a0f1c92100" translate="yes" xml:space="preserve">
          <source>Concrete &lt;code&gt;Point&lt;/code&gt; types with different values of &lt;code&gt;T&lt;/code&gt; are never subtypes of each other:</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 값이 다른 콘크리트 &lt;code&gt;Point&lt;/code&gt; 유형은 서로의 하위 유형이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ac02f0743c4d1b96a2deef06f8e3cd49006763ce" translate="yes" xml:space="preserve">
          <source>Concrete number types</source>
          <target state="translated">콘크리트 숫자 유형</target>
        </trans-unit>
        <trans-unit id="2f4979324e03e4571b1d7eba701226670c2ee2da" translate="yes" xml:space="preserve">
          <source>Condition</source>
          <target state="translated">Condition</target>
        </trans-unit>
        <trans-unit id="cf7bc3804abc264beaaad97d32ab5bc9d2653568" translate="yes" xml:space="preserve">
          <source>Condition number of the matrix &lt;code&gt;M&lt;/code&gt;, computed using the operator &lt;code&gt;p&lt;/code&gt;-norm. Valid values for &lt;code&gt;p&lt;/code&gt; are &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; (default), or &lt;code&gt;Inf&lt;/code&gt;.</source>
          <target state="translated">연산자 &lt;code&gt;p&lt;/code&gt; -norm을 사용하여 계산 된 행렬 &lt;code&gt;M&lt;/code&gt; 의 조건 번호입니다 . &lt;code&gt;p&lt;/code&gt; 의 유효한 값 은 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; (기본값) 또는 &lt;code&gt;Inf&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d01a0100c352f7c2f05bca55a82a8a86c8c531a6" translate="yes" xml:space="preserve">
          <source>Conditional Evaluation</source>
          <target state="translated">조건부 평가</target>
        </trans-unit>
        <trans-unit id="6b7fdfcad9d0149a68420bc1fb6ae6bcfa3f3e5a" translate="yes" xml:space="preserve">
          <source>Conditional evaluation allows portions of code to be evaluated or not evaluated depending on the value of a boolean expression. Here is the anatomy of the &lt;code&gt;if&lt;/code&gt;-&lt;code&gt;elseif&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt; conditional syntax:</source>
          <target state="translated">조건부 평가를 사용하면 부울 식의 값에 따라 코드 부분을 평가하거나 평가하지 않을 수 있습니다. 여기의 해부학 인 &lt;code&gt;if&lt;/code&gt; - &lt;code&gt;elseif&lt;/code&gt; - &lt;code&gt;else&lt;/code&gt; 조건 구문 :</target>
        </trans-unit>
        <trans-unit id="e69f11134ba674beba00ec75d3e8520e70308ab6" translate="yes" xml:space="preserve">
          <source>Confetti Ball</source>
          <target state="translated">색종이 공</target>
        </trans-unit>
        <trans-unit id="754164850f38c1ecdaf6b8ed894cb192bc36c5f4" translate="yes" xml:space="preserve">
          <source>Configuration</source>
          <target state="translated">Configuration</target>
        </trans-unit>
        <trans-unit id="f11771dca2097f06e32650070e9cd19a4232960b" translate="yes" xml:space="preserve">
          <source>Configure the &lt;code&gt;delay&lt;/code&gt; between backtraces (measured in seconds), and the number &lt;code&gt;n&lt;/code&gt; of instruction pointers that may be stored. Each instruction pointer corresponds to a single line of code; backtraces generally consist of a long list of instruction pointers. Default settings can be obtained by calling this function with no arguments, and each can be set independently using keywords or in the order &lt;code&gt;(n, delay)&lt;/code&gt;.</source>
          <target state="translated">백 트레이스 (초 단위로 측정)와 &lt;code&gt;delay&lt;/code&gt; 될 수있는 명령 포인터 수 &lt;code&gt;n&lt;/code&gt; 사이 의 지연을 구성합니다 . 각 명령어 포인터는 한 줄의 코드에 해당합니다. 역 추적은 일반적으로 명령 포인터의 긴 목록으로 구성됩니다. 기본 설정은 인수없이이 함수를 호출하여 얻을 수 있으며 키워드를 사용하거나 순서대로 &lt;code&gt;(n, delay)&lt;/code&gt; 각각 독립적으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="673a17c8ab08ef073f65d1d78eccb52e6d24ac72" translate="yes" xml:space="preserve">
          <source>Confounded Face</source>
          <target state="translated">혼란스러운 얼굴</target>
        </trans-unit>
        <trans-unit id="dd9a3041d63a9bbabd149d1fe0496e16f5dc48c5" translate="yes" xml:space="preserve">
          <source>Confused Face</source>
          <target state="translated">혼란스러운 얼굴</target>
        </trans-unit>
        <trans-unit id="eef1f855d92024dcbe93e39074e6eedcb5b887b2" translate="yes" xml:space="preserve">
          <source>Congruent With Dot Above</source>
          <target state="translated">위의 점과 일치</target>
        </trans-unit>
        <trans-unit id="8d07e70d148195b15a902e326b6c8a5a632e9d80" translate="yes" xml:space="preserve">
          <source>Conical Taper</source>
          <target state="translated">원뿔 테이퍼</target>
        </trans-unit>
        <trans-unit id="53cbbaf8dc8947fbf7f4e2c26b471f06d61fc371" translate="yes" xml:space="preserve">
          <source>Conjugate transpose array &lt;code&gt;src&lt;/code&gt; and store the result in the preallocated array &lt;code&gt;dest&lt;/code&gt;, which should have a size corresponding to &lt;code&gt;(size(src,2),size(src,1))&lt;/code&gt;. No in-place transposition is supported and unexpected results will happen if &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; have overlapping memory regions.</source>
          <target state="translated">배열 &lt;code&gt;src&lt;/code&gt; 를 결합 하고 결과를 미리 할당 된 배열 &lt;code&gt;dest&lt;/code&gt; 에 저장합니다.이 배열 은 &lt;code&gt;(size(src,2),size(src,1))&lt;/code&gt; 해당하는 크기를 가져야합니다 . 내부 전치가 지원되지 않으며 &lt;code&gt;src&lt;/code&gt; 와 &lt;code&gt;dest&lt;/code&gt; 에 겹치는 메모리 영역 이 있으면 예기치 않은 결과가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="a876d1109ed8e346f72690afb5f2db1f614132b6" translate="yes" xml:space="preserve">
          <source>Connect to the host &lt;code&gt;host&lt;/code&gt; on port &lt;code&gt;port&lt;/code&gt;.</source>
          <target state="translated">포트 &lt;code&gt;port&lt;/code&gt; 의 호스트 &lt;code&gt;host&lt;/code&gt; 에 연결하십시오 .</target>
        </trans-unit>
        <trans-unit id="9004fa442291bfc2131d993b2837ea1204a6abf6" translate="yes" xml:space="preserve">
          <source>Connect to the named pipe / UNIX domain socket at &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 에서 명명 된 파이프 / UNIX 도메인 소켓에 연결하십시오 .</target>
        </trans-unit>
        <trans-unit id="7a431044d47389f7d8d41344d53c0bcbadc8fbb0" translate="yes" xml:space="preserve">
          <source>Connections between workers (using the in-built TCP/IP transport) is established in the following manner:</source>
          <target state="translated">작업자 간의 연결 (내장 TCP / IP 전송 사용)은 다음과 같은 방식으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e713951b7382d19065c79a76c4ed128f1bd12fce" translate="yes" xml:space="preserve">
          <source>Consequently these can be useful for writing algorithms that work in arbitrary dimensions.</source>
          <target state="translated">따라서 임의의 차원에서 작동하는 알고리즘을 작성하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6047fa413edddcfaf57a7f9b7f453ad4dba512df" translate="yes" xml:space="preserve">
          <source>Consequently, this child function gets 3 counts, even though the parent only gets one. The &quot;tree&quot; representation makes this much clearer, and for this reason (among others) is probably the most useful way to view the results.</source>
          <target state="translated">결과적으로이 자식 함수는 부모가 하나만 가져도 3 카운트를 얻습니다. &quot;트리&quot;표현은이를 훨씬 더 명확하게하며, 이러한 이유로 (다른 이유로) 결과를 보는 가장 유용한 방법 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="3eea8fbc0a3e336128fa5eb5ae85da5b38074305" translate="yes" xml:space="preserve">
          <source>Consequently, you are more likely to need to modify &lt;code&gt;delay&lt;/code&gt;, expressed in seconds, which sets the amount of time that Julia gets between snapshots to perform the requested computations. A very long-running job might not need frequent backtraces. The default setting is &lt;code&gt;delay = 0.001&lt;/code&gt;. Of course, you can decrease the delay as well as increase it; however, the overhead of profiling grows once the delay becomes similar to the amount of time needed to take a backtrace (~30 microseconds on the author's laptop).</source>
          <target state="translated">결과적으로 요청 된 계산을 수행하기 위해 Julia가 스냅 샷간에 가져 오는 시간을 설정하는 &lt;code&gt;delay&lt;/code&gt; 를 초 단위 로 수정해야 할 가능성이 높습니다 . 매우 오래 실행되는 작업에는 빈번한 역 추적이 필요하지 않을 수 있습니다. 기본 설정은 &lt;code&gt;delay = 0.001&lt;/code&gt; 입니다. 물론 지연을 줄이고 증가시킬 수 있습니다. 그러나 지연이 역 추적 (필자의 랩톱에서 ~ 30 마이크로 초)에 걸리는 시간과 비슷 해지면 프로파일 링의 오버 헤드가 커집니다.</target>
        </trans-unit>
        <trans-unit id="ad2b5b66bbff4ce303aefd6b3469a1ca820858f7" translate="yes" xml:space="preserve">
          <source>Consider a function which logs a warning, and several debug messages:</source>
          <target state="translated">경고를 기록하는 기능과 여러 디버그 메시지를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="b41c44bc4a6bcb6e5de4d96d38a9a8675a1f8d16" translate="yes" xml:space="preserve">
          <source>Consider a simple example using channels for inter-task communication. We start 4 tasks to process data from a single &lt;code&gt;jobs&lt;/code&gt; channel. Jobs, identified by an id (&lt;code&gt;job_id&lt;/code&gt;), are written to the channel. Each task in this simulation reads a &lt;code&gt;job_id&lt;/code&gt;, waits for a random amount of time and writes back a tuple of &lt;code&gt;job_id&lt;/code&gt; and the simulated time to the results channel. Finally all the &lt;code&gt;results&lt;/code&gt; are printed out.</source>
          <target state="translated">작업 간 통신에 채널을 사용하는 간단한 예를 고려하십시오. 단일 &lt;code&gt;jobs&lt;/code&gt; 채널 에서 데이터를 처리하기 위해 4 가지 작업을 시작합니다 . ID ( &lt;code&gt;job_id&lt;/code&gt; )로 식별 된 작업 은 채널에 작성됩니다. 이 시뮬레이션에서 각 작업은 읽기 &lt;code&gt;job_id&lt;/code&gt; 시간과 쓰기의 임의의 금액에 대한 대기의 튜플 백업, &lt;code&gt;job_id&lt;/code&gt; 결과 채널과 시뮬레이션 시간을. 마지막으로 모든 &lt;code&gt;results&lt;/code&gt; 가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="eb7131848d45ace01b38d4617e6d98b8e79ccee7" translate="yes" xml:space="preserve">
          <source>Consider the following contrived example. Imagine we wanted to write a function that accepts a &lt;a href=&quot;../../base/arrays/index#Base.Vector&quot;&gt;&lt;code&gt;Vector&lt;/code&gt;&lt;/a&gt; and returns a square &lt;a href=&quot;../../base/arrays/index#Base.Matrix&quot;&gt;&lt;code&gt;Matrix&lt;/code&gt;&lt;/a&gt; with either the rows or the columns filled with copies of the input vector. Assume that it is not important whether rows or columns are filled with these copies (perhaps the rest of the code can be easily adapted accordingly). We could conceivably do this in at least four ways (in addition to the recommended call to the built-in &lt;a href=&quot;../../base/arrays/index#Base.repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">다음과 같은 고려 된 예를 고려하십시오. &lt;a href=&quot;../../base/arrays/index#Base.Vector&quot;&gt; &lt;code&gt;Vector&lt;/code&gt; &lt;/a&gt; 를 받아들이고 입력 벡터의 복사본으로 채워진 행이나 열이 있는 정사각 &lt;a href=&quot;../../base/arrays/index#Base.Matrix&quot;&gt; &lt;code&gt;Matrix&lt;/code&gt; &lt;/a&gt; 을 반환 하는 함수를 작성하려고한다고 상상해보십시오 . 행 또는 열이 이러한 사본으로 채워지는지 여부가 중요하지 않다고 가정하십시오 (아마도 나머지 코드는 그에 따라 쉽게 조정할 수 있음). 우리는 이것을 최소한 네 가지 방법으로 (내장 &lt;a href=&quot;../../base/arrays/index#Base.repeat&quot;&gt; &lt;code&gt;repeat&lt;/code&gt; &lt;/a&gt; 에 대한 권장 호출 외에도 ) 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aea7505a758167e8e584f36010a94eb7238c397b" translate="yes" xml:space="preserve">
          <source>Consider the following example that defines an inner function:</source>
          <target state="translated">내부 함수를 정의하는 다음 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="1cf37589ccf59f2442553bb8984c73cb434ce446" translate="yes" xml:space="preserve">
          <source>Consider the following two examples. The first one returns the exception object inline, the second a 0 in place of any exception:</source>
          <target state="translated">다음 두 가지 예를 고려하십시오. 첫 번째는 예외 객체를 인라인으로 반환하고 두 번째는 예외 대신 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fc53f41d4c528eb43347a836891919335055512d" translate="yes" xml:space="preserve">
          <source>Consider the following:</source>
          <target state="translated">다음을 고려하세요:</target>
        </trans-unit>
        <trans-unit id="0c895d2fdc1a30ac558dfcb63c363445e0e645e1" translate="yes" xml:space="preserve">
          <source>Consider the printed output from the following:</source>
          <target state="translated">다음의 인쇄 결과를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="b8e04b708ae9ae6b8c54714632e7d8df9880585c" translate="yes" xml:space="preserve">
          <source>Consider this toy script which simply calls each subprocess, instantiate its rank and when the master process is reached, performs the ranks' sum</source>
          <target state="translated">단순히 각 하위 프로세스를 호출하고 순위를 인스턴스화하고 마스터 프로세스에 도달하면 순위 합계를 수행하는이 장난감 스크립트를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="85eb0a345158a422b527393dc1bc1495a2bd3a98" translate="yes" xml:space="preserve">
          <source>Consider using views for slices</source>
          <target state="translated">슬라이스에 뷰 사용 고려</target>
        </trans-unit>
        <trans-unit id="ec4162d71dc6c558c88cb225144c9bcd26084f48" translate="yes" xml:space="preserve">
          <source>Considered alone, this may seem relatively trivial; &lt;code&gt;CartesianIndex&lt;/code&gt; simply gathers multiple integers together into one object that represents a single multidimensional index. When combined with other indexing forms and iterators that yield &lt;code&gt;CartesianIndex&lt;/code&gt;es, however, this can produce very elegant and efficient code. See &lt;a href=&quot;#Iteration-1&quot;&gt;Iteration&lt;/a&gt; below, and for some more advanced examples, see &lt;a href=&quot;https://julialang.org/blog/2016/02/iteration&quot;&gt;this blog post on multidimensional algorithms and iteration&lt;/a&gt;.</source>
          <target state="translated">혼자 생각하면, 이것은 비교적 사소한 것처럼 보일 수 있습니다. &lt;code&gt;CartesianIndex&lt;/code&gt; 는 단순히 단일 다차원 인덱스를 나타내는 하나의 객체에 여러 정수를 모은 것입니다. 그러나 &lt;code&gt;CartesianIndex&lt;/code&gt; es 를 생성하는 다른 색인 양식 및 반복자와 결합하면 매우 우아하고 효율적인 코드를 생성 할 수 있습니다. 아래 &lt;a href=&quot;#Iteration-1&quot;&gt;반복을&lt;/a&gt; 참조하십시오. 고급 예제 &lt;a href=&quot;https://julialang.org/blog/2016/02/iteration&quot;&gt;는 다차원 알고리즘 및 반복에&lt;/a&gt; 대한 이 블로그 게시물을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f386d7e7881b32fa39cb7b62bdb15c0f3a4c0e1" translate="yes" xml:space="preserve">
          <source>Constants</source>
          <target state="translated">Constants</target>
        </trans-unit>
        <trans-unit id="f20797a3b29239e673a22d9f965a161574684bb4" translate="yes" xml:space="preserve">
          <source>Constants involving most Julia objects that are not produced by &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; do not need to be placed in &lt;code&gt;__init__&lt;/code&gt;: their definitions can be precompiled and loaded from the cached module image. This includes complicated heap-allocated objects like arrays. However, any routine that returns a raw pointer value must be called at runtime for precompilation to work (&lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt;&lt;code&gt;Ptr&lt;/code&gt;&lt;/a&gt; objects will turn into null pointers unless they are hidden inside an &lt;a href=&quot;../../base/base/index#Base.isbits&quot;&gt;&lt;code&gt;isbits&lt;/code&gt;&lt;/a&gt; object). This includes the return values of the Julia functions &lt;code&gt;cfunction&lt;/code&gt; and &lt;a href=&quot;../../base/c/index#Base.pointer&quot;&gt;&lt;code&gt;pointer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; 에&lt;/a&gt; 의해 생성되지 않은 대부분의 Julia 객체와 관련된 상수 는 &lt;code&gt;__init__&lt;/code&gt; 에 배치 할 필요가 없습니다 . 정의는 캐시 된 모듈 이미지에서 사전 컴파일되어로드 될 수 있습니다. 여기에는 배열과 같은 복잡한 힙 할당 객체가 포함됩니다. 그러나 사전 컴파일이 작동하려면 원시 포인터 값을 리턴하는 루틴을 런타임에 호출해야합니다 ( &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt; &lt;code&gt;Ptr&lt;/code&gt; &lt;/a&gt; 오브젝트는 &lt;a href=&quot;../../base/base/index#Base.isbits&quot;&gt; &lt;code&gt;isbits&lt;/code&gt; &lt;/a&gt; 오브젝트 안에 숨겨져 있지 않으면 널 포인터로 바 turn ). 여기에는 Julia 함수 &lt;code&gt;cfunction&lt;/code&gt; 및 &lt;a href=&quot;../../base/c/index#Base.pointer&quot;&gt; &lt;code&gt;pointer&lt;/code&gt; &lt;/a&gt; 의 반환 값이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="f3dbbafc2bcd268f72cf3af03b54be6b51a2334b" translate="yes" xml:space="preserve">
          <source>Construct</source>
          <target state="translated">Construct</target>
        </trans-unit>
        <trans-unit id="f97e2d9c4b65aa73bfe3ea4abacc7c7c96df97c2" translate="yes" xml:space="preserve">
          <source>Construct &lt;a href=&quot;../arrays/index#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt; from two &lt;code&gt;CartesianIndex&lt;/code&gt;.</source>
          <target state="translated">구조의 &lt;a href=&quot;../arrays/index#Base.IteratorsMD.CartesianIndices&quot;&gt; &lt;code&gt;CartesianIndices&lt;/code&gt; &lt;/a&gt; 두에서 &lt;code&gt;CartesianIndex&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="193781393b9a991b412b9666ff3363d59256fb37" translate="yes" xml:space="preserve">
          <source>Construct a 1-d array of the specified type. This is usually called with the syntax &lt;code&gt;Type[]&lt;/code&gt;. Element values can be specified using &lt;code&gt;Type[a,b,c,...]&lt;/code&gt;.</source>
          <target state="translated">지정된 타입의 1 차원 배열을 구성합니다. 일반적으로 &lt;code&gt;Type[]&lt;/code&gt; 구문으로 호출됩니다 . 요소 값은 &lt;code&gt;Type[a,b,c,...]&lt;/code&gt; 사용하여 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="822ae5747d235413c4d6b4787626679a1b185a0e" translate="yes" xml:space="preserve">
          <source>Construct a &lt;a href=&quot;#Base.BitArray&quot;&gt;&lt;code&gt;BitArray&lt;/code&gt;&lt;/a&gt; generated by the given iterable object. The shape is inferred from the &lt;code&gt;itr&lt;/code&gt; object.</source>
          <target state="translated">컨스 &lt;a href=&quot;#Base.BitArray&quot;&gt; &lt;code&gt;BitArray&lt;/code&gt; &lt;/a&gt; 주어진 반복 가능 객체에 의해 발생한다. 모양은 &lt;code&gt;itr&lt;/code&gt; 객체 에서 추론됩니다 .</target>
        </trans-unit>
        <trans-unit id="b8d781f22b5f31f1ad3ff32a6a5b759f677769b6" translate="yes" xml:space="preserve">
          <source>Construct a &lt;a href=&quot;#Base.Matrix&quot;&gt;&lt;code&gt;Matrix{T}&lt;/code&gt;&lt;/a&gt; of size &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt;, initialized with &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; entries. Element type &lt;code&gt;T&lt;/code&gt; must be able to hold these values, i.e. &lt;code&gt;Missing &amp;lt;: T&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 항목으로 초기화 된 &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; 크기 의 &lt;a href=&quot;#Base.Matrix&quot;&gt; &lt;code&gt;Matrix{T}&lt;/code&gt; &lt;/a&gt; 를 구성하십시오 . 요소 유형 &lt;code&gt;T&lt;/code&gt; 는 이러한 값을 보유 할 수 있어야합니다 (예 : &lt;code&gt;Missing &amp;lt;: T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2c66efe8a7c37a7a479116847647815fc94a32d" translate="yes" xml:space="preserve">
          <source>Construct a &lt;a href=&quot;#Base.Matrix&quot;&gt;&lt;code&gt;Matrix{T}&lt;/code&gt;&lt;/a&gt; of size &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt;, initialized with &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; entries. Element type &lt;code&gt;T&lt;/code&gt; must be able to hold these values, i.e. &lt;code&gt;Nothing &amp;lt;: T&lt;/code&gt;.</source>
          <target state="translated">항목 이 &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; 초기화 된 &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; 크기 의 &lt;a href=&quot;#Base.Matrix&quot;&gt; &lt;code&gt;Matrix{T}&lt;/code&gt; &lt;/a&gt; 를 구성하십시오 . 요소 유형 &lt;code&gt;T&lt;/code&gt; 는 이러한 값을 보유 할 수 있어야합니다 (예 : &lt;code&gt;Nothing &amp;lt;: T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="271b0e3ba477679c21eb060d4bf61dcf1916b610" translate="yes" xml:space="preserve">
          <source>Construct a &lt;a href=&quot;#Base.Set&quot;&gt;&lt;code&gt;Set&lt;/code&gt;&lt;/a&gt; of the values generated by the given iterable object, or an empty set. Should be used instead of &lt;a href=&quot;#Base.BitSet&quot;&gt;&lt;code&gt;BitSet&lt;/code&gt;&lt;/a&gt; for sparse integer sets, or for sets of arbitrary objects.</source>
          <target state="translated">주어진 반복 가능한 객체에 의해 생성 된 값 의 &lt;a href=&quot;#Base.Set&quot;&gt; &lt;code&gt;Set&lt;/code&gt; &lt;/a&gt; 또는 빈 세트를 구성합니다. 희소 정수 세트 또는 임의의 오브젝트 세트에 &lt;a href=&quot;#Base.BitSet&quot;&gt; &lt;code&gt;BitSet&lt;/code&gt; &lt;/a&gt; 대신 사용되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="6ed69370b1f85dc30500cbd3df9bf2409de8527b" translate="yes" xml:space="preserve">
          <source>Construct a &lt;a href=&quot;#Base.Vector&quot;&gt;&lt;code&gt;Vector{T}&lt;/code&gt;&lt;/a&gt; of length &lt;code&gt;m&lt;/code&gt;, initialized with &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; entries. Element type &lt;code&gt;T&lt;/code&gt; must be able to hold these values, i.e. &lt;code&gt;Missing &amp;lt;: T&lt;/code&gt;.</source>
          <target state="translated">컨스 &lt;a href=&quot;#Base.Vector&quot;&gt; &lt;code&gt;Vector{T}&lt;/code&gt; &lt;/a&gt; 길이의 &lt;code&gt;m&lt;/code&gt; 로 초기화, &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 항목을. 요소 유형 &lt;code&gt;T&lt;/code&gt; 는 이러한 값을 보유 할 수 있어야합니다 (예 : &lt;code&gt;Missing &amp;lt;: T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8cfe5534e0cb4dceb12e8df87c966d7782ee710b" translate="yes" xml:space="preserve">
          <source>Construct a &lt;a href=&quot;#Base.Vector&quot;&gt;&lt;code&gt;Vector{T}&lt;/code&gt;&lt;/a&gt; of length &lt;code&gt;m&lt;/code&gt;, initialized with &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; entries. Element type &lt;code&gt;T&lt;/code&gt; must be able to hold these values, i.e. &lt;code&gt;Nothing &amp;lt;: T&lt;/code&gt;.</source>
          <target state="translated">길이가 &lt;code&gt;m&lt;/code&gt; 인 &lt;a href=&quot;#Base.Vector&quot;&gt; &lt;code&gt;Vector{T}&lt;/code&gt; &lt;/a&gt; 를 구성하고 항목 이 &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; 초기화 합니다. 요소 유형 &lt;code&gt;T&lt;/code&gt; 는 이러한 값을 보유 할 수 있어야합니다 (예 : &lt;code&gt;Nothing &amp;lt;: T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc422a0b0965db4d8a6477be563e87c89e3c1e29" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Bidiagonal&lt;/code&gt; matrix from the main diagonal of &lt;code&gt;A&lt;/code&gt; and its first super- (if &lt;code&gt;uplo=:U&lt;/code&gt;) or sub-diagonal (if &lt;code&gt;uplo=:L&lt;/code&gt;).</source>
          <target state="translated">컨스 &lt;code&gt;Bidiagonal&lt;/code&gt; 의 주요 대각 행렬로부터 및 제 슈퍼 (있는 경우 &lt;code&gt;uplo=:U&lt;/code&gt; ) 또는 하위 대각선 (만약 &lt;code&gt;uplo=:L&lt;/code&gt; ). &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b2e58bf227bdb08afbbc5fd16b8dde5aee9225c" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;CompoundPeriod&lt;/code&gt; from a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Period&lt;/code&gt;s. All &lt;code&gt;Period&lt;/code&gt;s of the same type will be added together.</source>
          <target state="translated">구성체 &lt;code&gt;CompoundPeriod&lt;/code&gt; 를 A로부터 &lt;code&gt;Vector&lt;/code&gt; 의 &lt;code&gt;Period&lt;/code&gt; 의. 동일한 유형의 모든 &lt;code&gt;Period&lt;/code&gt; 함께 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="4b09b541e4ed1f0aba3333bcba37da80754811dc" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Date&lt;/code&gt; by parsing the &lt;code&gt;d&lt;/code&gt; date string following the pattern given in the &lt;code&gt;format&lt;/code&gt; string.</source>
          <target state="translated">컨스 &lt;code&gt;Date&lt;/code&gt; 파싱하여 &lt;code&gt;d&lt;/code&gt; 에 주어진 패턴 다음 날짜 문자열 &lt;code&gt;format&lt;/code&gt; 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="af2403a6b54b9170043e5f46c873bd44e2c86e65" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Date&lt;/code&gt; type by &lt;code&gt;Period&lt;/code&gt; type parts. Arguments may be in any order. &lt;code&gt;Date&lt;/code&gt; parts not provided will default to the value of &lt;code&gt;Dates.default(period)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Period&lt;/code&gt; 유형 부분 으로 &lt;code&gt;Date&lt;/code&gt; 유형을 구성하십시오. 인수는 임의의 순서로있을 수 있습니다. 제공되지 않은 &lt;code&gt;Date&lt;/code&gt; 부분은 기본적으로 &lt;code&gt;Dates.default(period)&lt;/code&gt; 값으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="f444be57b1a99cc75b882799b5ad5c2d4dfae5e1" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Date&lt;/code&gt; type by parts. Arguments must be convertible to &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">컨스 &lt;code&gt;Date&lt;/code&gt; 부품에 의한 유형입니다. 인수는 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; 로 변환 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c67c8fc150a64df871383e42ca74e3f64cce0b21" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;DateTime&lt;/code&gt; by parsing the &lt;code&gt;dt&lt;/code&gt; date time string following the pattern given in the &lt;a href=&quot;#Dates.DateFormat&quot;&gt;&lt;code&gt;DateFormat&lt;/code&gt;&lt;/a&gt; object. Similar to &lt;code&gt;DateTime(::AbstractString, ::AbstractString)&lt;/code&gt; but more efficient when repeatedly parsing similarly formatted date time strings with a pre-created &lt;code&gt;DateFormat&lt;/code&gt; object.</source>
          <target state="translated">컨스 &lt;code&gt;DateTime&lt;/code&gt; 파싱하여 &lt;code&gt;dt&lt;/code&gt; 에 주어진 패턴 다음 날짜 시간 문자열 &lt;a href=&quot;#Dates.DateFormat&quot;&gt; &lt;code&gt;DateFormat&lt;/code&gt; &lt;/a&gt; 객체를. 유사 &lt;code&gt;DateTime(::AbstractString, ::AbstractString)&lt;/code&gt; 만 반복적으로 미리 만들어진와 유사한 형식의 날짜 시간 문자열을 구문 분석 할 때보다 효율적 &lt;code&gt;DateFormat&lt;/code&gt; 개체를.</target>
        </trans-unit>
        <trans-unit id="aea78ff467ecef7879256770936c29566865c81d" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;DateTime&lt;/code&gt; by parsing the &lt;code&gt;dt&lt;/code&gt; date time string following the pattern given in the &lt;code&gt;format&lt;/code&gt; string.</source>
          <target state="translated">컨스 &lt;code&gt;DateTime&lt;/code&gt; 파싱하여 &lt;code&gt;dt&lt;/code&gt; 에 주어진 패턴 다음 날짜 시간 문자열 &lt;code&gt;format&lt;/code&gt; 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="e93eb9f3900c323d0aafcfa89df6646124b6b543" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;DateTime&lt;/code&gt; type by &lt;code&gt;Period&lt;/code&gt; type parts. Arguments may be in any order. DateTime parts not provided will default to the value of &lt;code&gt;Dates.default(period)&lt;/code&gt;.</source>
          <target state="translated">컨스 &lt;code&gt;DateTime&lt;/code&gt; 으로 입력 &lt;code&gt;Period&lt;/code&gt; 형 부품. 인수는 임의의 순서로있을 수 있습니다. 제공되지 않은 DateTime 부분은 기본적으로 &lt;code&gt;Dates.default(period)&lt;/code&gt; 값으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="383850982e161143cb3f8464b59c38e89b3a5646" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;DateTime&lt;/code&gt; type by parts. Arguments must be convertible to &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">컨스 &lt;code&gt;DateTime&lt;/code&gt; 부분으로 유형을. 인수는 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; 로 변환 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="775f3a88f10d84f3621ead39c164700c56bb2844" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Day&lt;/code&gt; object with the given &lt;code&gt;v&lt;/code&gt; value. Input must be losslessly convertible to an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;v&lt;/code&gt; 값 으로 &lt;code&gt;Day&lt;/code&gt; 객체를 구성합니다 . 입력은 손실없이 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; 로 변환 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="40609c2c820790d0a3c1eb68f785ce1c82714463" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;GitBlame&lt;/code&gt; object for the file at &lt;code&gt;path&lt;/code&gt;, using change information gleaned from the history of &lt;code&gt;repo&lt;/code&gt;. The &lt;code&gt;GitBlame&lt;/code&gt; object records who changed which chunks of the file when, and how. &lt;code&gt;options&lt;/code&gt; controls how to separate the contents of the file and which commits to probe - see &lt;a href=&quot;#LibGit2.BlameOptions&quot;&gt;&lt;code&gt;BlameOptions&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">컨스 &lt;code&gt;GitBlame&lt;/code&gt; 의 에서 파일에 대한 객체를 &lt;code&gt;path&lt;/code&gt; 의 역사에서 수집 변경 정보 사용 &lt;code&gt;repo&lt;/code&gt; . &lt;code&gt;GitBlame&lt;/code&gt; 의 파일 때, 어떻게 덩어리하는 변경 객체 기록합니다. &lt;code&gt;options&lt;/code&gt; 은 파일의 내용을 분리하는 방법과 검사 할 커밋을 제어합니다 . 자세한 내용 은 &lt;a href=&quot;#LibGit2.BlameOptions&quot;&gt; &lt;code&gt;BlameOptions&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cfac8ee20a7a93b71932d5ea24ca6e9446304d80" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Hermitian&lt;/code&gt; view of the upper (if &lt;code&gt;uplo = :U&lt;/code&gt;) or lower (if &lt;code&gt;uplo = :L&lt;/code&gt;) triangle of the matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">컨스 &lt;code&gt;Hermitian&lt;/code&gt; (만약 위쪽의 뷰를 &lt;code&gt;uplo = :U&lt;/code&gt; ) 이하 (경우 &lt;code&gt;uplo = :L&lt;/code&gt; ) 행렬의 삼각형 . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53aa9b9ef1c879e549044ea23efdf5498813a414" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;LowerTriangular&lt;/code&gt; view of the matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">행렬 &lt;code&gt;A&lt;/code&gt; 의 &lt;code&gt;LowerTriangular&lt;/code&gt; 뷰를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="a2be7157682b3e7c1d399140f4ed110f2601b93e" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Month&lt;/code&gt; object with the given &lt;code&gt;v&lt;/code&gt; value. Input must be losslessly convertible to an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;v&lt;/code&gt; 값 으로 &lt;code&gt;Month&lt;/code&gt; 객체를 생성합니다 . 입력은 손실없이 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; 로 변환 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="5ee95a95477044367d4547393ce2e04832e8eaee" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Pair&lt;/code&gt; object with type &lt;code&gt;Pair{typeof(x), typeof(y)}&lt;/code&gt;. The elements are stored in the fields &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt;. They can also be accessed via iteration.</source>
          <target state="translated">&lt;code&gt;Pair{typeof(x), typeof(y)}&lt;/code&gt; 유형 으로 &lt;code&gt;Pair&lt;/code&gt; 객체를 생성합니다 . 요소는 &lt;code&gt;first&lt;/code&gt; 와 &lt;code&gt;second&lt;/code&gt; 필드에 저장됩니다 . 또한 반복을 통해 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e945148a5d12b75c7c3ce9201b6e5d5ca81cafce" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Period&lt;/code&gt; type with the given &lt;code&gt;v&lt;/code&gt; value. Input must be losslessly convertible to an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;v&lt;/code&gt; 값 으로 &lt;code&gt;Period&lt;/code&gt; 유형을 구성하십시오 . 입력은 손실없이 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; 로 변환 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="36f2454002107f0f60d937848f0e4956684fd113" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;SharedArray&lt;/code&gt; backed by the file &lt;code&gt;filename&lt;/code&gt;, with element type &lt;code&gt;T&lt;/code&gt; (must be a bits type) and size &lt;code&gt;dims&lt;/code&gt;, across the processes specified by &lt;code&gt;pids&lt;/code&gt; - all of which have to be on the same host. This file is mmapped into the host memory, with the following consequences:</source>
          <target state="translated">컨스 &lt;code&gt;SharedArray&lt;/code&gt; 이 파일에 의해 백업 &lt;code&gt;filename&lt;/code&gt; 요소 형, &lt;code&gt;T&lt;/code&gt; 및 크기 (a 비트 유형이어야 함) &lt;code&gt;dims&lt;/code&gt; 로 지정된 프로세스에 걸쳐, &lt;code&gt;pids&lt;/code&gt; 동일한 호스트에 있어야 모두를 -. 이 파일은 다음 결과로 호스트 메모리에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="30559885baa00f426d3195c8bac3dc6b30de76a2" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;SharedArray&lt;/code&gt; of a bits type &lt;code&gt;T&lt;/code&gt; and size &lt;code&gt;dims&lt;/code&gt; across the processes specified by &lt;code&gt;pids&lt;/code&gt; - all of which have to be on the same host. If &lt;code&gt;N&lt;/code&gt; is specified by calling &lt;code&gt;SharedArray{T,N}(dims)&lt;/code&gt;, then &lt;code&gt;N&lt;/code&gt; must match the length of &lt;code&gt;dims&lt;/code&gt;.</source>
          <target state="translated">컨스 &lt;code&gt;SharedArray&lt;/code&gt; 비트 입력 &lt;code&gt;T&lt;/code&gt; 및 크기 &lt;code&gt;dims&lt;/code&gt; 의해 지정된 프로세스간에 &lt;code&gt;pids&lt;/code&gt; 동일한 호스트에 있어야 모두 -. 경우 &lt;code&gt;N&lt;/code&gt; 이 호출에 의해 지정됩니다 &lt;code&gt;SharedArray{T,N}(dims)&lt;/code&gt; , 다음 &lt;code&gt;N&lt;/code&gt; 은 의 길이와 일치해야합니다 &lt;code&gt;dims&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bad6ab2e9afc35f90c2261027da0cbb9fa911828" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Symmetric&lt;/code&gt; view of the upper (if &lt;code&gt;uplo = :U&lt;/code&gt;) or lower (if &lt;code&gt;uplo = :L&lt;/code&gt;) triangle of the matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">행렬 &lt;code&gt;A&lt;/code&gt; 의 &lt;code&gt;uplo = :L&lt;/code&gt; 삼각형 ( &lt;code&gt;uplo = :U&lt;/code&gt; ) 또는 아래쪽 삼각형 ( uplo = : L ) 의 &lt;code&gt;Symmetric&lt;/code&gt; 뷰를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="512b84d9393d18f32c44b67c1ceac4788e65f773" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Time&lt;/code&gt; type by &lt;code&gt;Period&lt;/code&gt; type parts. Arguments may be in any order. &lt;code&gt;Time&lt;/code&gt; parts not provided will default to the value of &lt;code&gt;Dates.default(period)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Period&lt;/code&gt; 유형 부분 으로 &lt;code&gt;Time&lt;/code&gt; 유형을 구성하십시오. 인수는 임의의 순서로있을 수 있습니다. 제공되지 않은 &lt;code&gt;Time&lt;/code&gt; 부분은 기본적으로 &lt;code&gt;Dates.default(period)&lt;/code&gt; 값으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="57a83629f577977e6138536698bfa2b11168ae04" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Time&lt;/code&gt; type by parts. Arguments must be convertible to &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">컨스 &lt;code&gt;Time&lt;/code&gt; 부분으로 유형을. 인수는 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; 로 변환 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="e1fa0f5c37012652505e3cdf521c5117c6215fe1" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;UnitLowerTriangular&lt;/code&gt; view of the matrix &lt;code&gt;A&lt;/code&gt;. Such a view has the &lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt;&lt;code&gt;oneunit&lt;/code&gt;&lt;/a&gt; of the &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;A&lt;/code&gt; on its diagonal.</source>
          <target state="translated">행렬 &lt;code&gt;A&lt;/code&gt; 의 &lt;code&gt;UnitLowerTriangular&lt;/code&gt; 뷰를 구성합니다 . 이러한 뷰는 보유 &lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt; &lt;code&gt;oneunit&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt; 의 그 대각선에있다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dbf534772f21c312ceb366d56988564faadc9083" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Week&lt;/code&gt; object with the given &lt;code&gt;v&lt;/code&gt; value. Input must be losslessly convertible to an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;v&lt;/code&gt; 값 으로 &lt;code&gt;Week&lt;/code&gt; 객체를 구성합니다 . 입력은 손실없이 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; 로 변환 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a5bdc0f4ba0074541be92fccdc87cc517c888054" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Year&lt;/code&gt; object with the given &lt;code&gt;v&lt;/code&gt; value. Input must be losslessly convertible to an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;v&lt;/code&gt; 값 으로 &lt;code&gt;Year&lt;/code&gt; 객체를 생성합니다 . 입력은 손실없이 &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; 로 변환 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="be0daf784d16844ae921191b30baa069213224e7" translate="yes" xml:space="preserve">
          <source>Construct a date formatting object that can be used for parsing date strings or formatting a date object as a string. The following character codes can be used to construct the &lt;code&gt;format&lt;/code&gt; string:</source>
          <target state="translated">날짜 문자열을 구문 분석하거나 날짜 오브젝트를 문자열로 형식화하는 데 사용할 수있는 날짜 형식화 오브젝트를 구성하십시오. 다음 문자열 코드를 사용하여 &lt;code&gt;format&lt;/code&gt; 문자열 을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4cd437ecc9656e44160fa4c4fc658708ac1ef9c1" translate="yes" xml:space="preserve">
          <source>Construct a git hash object from the given string, returning a &lt;code&gt;GitShortHash&lt;/code&gt; if the string is shorter than 40 hexadecimal digits, otherwise a &lt;code&gt;GitHash&lt;/code&gt;.</source>
          <target state="translated">주어진 문자열에서 git hash 객체를 생성 하고 문자열이 16 진수 40 자리보다 짧은 경우 &lt;code&gt;GitShortHash&lt;/code&gt; 를 반환하고 , 그렇지 않으면 &lt;code&gt;GitHash&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ea8e23701feccd63e17e0b0029ede99044fa274d" translate="yes" xml:space="preserve">
          <source>Construct a matrix from the diagonal of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 대각선에서 행렬을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="90f773e3d113876b6deb8a09e0f5de33ba790fb7" translate="yes" xml:space="preserve">
          <source>Construct a matrix with &lt;code&gt;V&lt;/code&gt; as its diagonal.</source>
          <target state="translated">&lt;code&gt;V&lt;/code&gt; 를 대각선으로 하여 행렬을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f217bb0e7b35012b29fdda1729b0fa09e13438ab" translate="yes" xml:space="preserve">
          <source>Construct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. If the same key is present in another collection, the value for that key will be the value it has in the last collection listed.</source>
          <target state="translated">주어진 컬렉션에서 병합 된 컬렉션을 구성합니다. 필요한 경우 병합 된 컬렉션의 유형을 수용하도록 결과 컬렉션의 유형이 승격됩니다. 다른 컬렉션에 동일한 키가있는 경우 해당 키의 값은 나열된 마지막 컬렉션에있는 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="f1617b1cc87aa299b6833917b0e46a1a4940ff17" translate="yes" xml:space="preserve">
          <source>Construct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. Values with the same key will be combined using the combiner function.</source>
          <target state="translated">주어진 컬렉션에서 병합 된 컬렉션을 구성합니다. 필요한 경우 병합 된 컬렉션의 유형을 수용하도록 결과 컬렉션의 유형이 승격됩니다. 동일한 키를 가진 값은 결합기 기능을 사용하여 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="60ada712a6bba4831ea5117dcc593947b90a8eea" translate="yes" xml:space="preserve">
          <source>Construct a new &lt;code&gt;Cmd&lt;/code&gt; object, representing an external program and arguments, from &lt;code&gt;cmd&lt;/code&gt;, while changing the settings of the optional keyword arguments:</source>
          <target state="translated">선택적 키워드 인수의 설정을 변경하면서 &lt;code&gt;cmd&lt;/code&gt; 에서 외부 프로그램 및 인수를 나타내는 새 &lt;code&gt;Cmd&lt;/code&gt; 오브젝트 를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="921bc3f38441b69eaebf923e14b05b0ead5fb49a" translate="yes" xml:space="preserve">
          <source>Construct a new named tuple by merging two or more existing ones, in a left-associative manner. Merging proceeds left-to-right, between pairs of named tuples, and so the order of fields present in both the leftmost and rightmost named tuples take the same position as they are found in the leftmost named tuple. However, values are taken from matching fields in the rightmost named tuple that contains that field. Fields present in only the rightmost named tuple of a pair are appended at the end. A fallback is implemented for when only a single named tuple is supplied, with signature &lt;code&gt;merge(a::NamedTuple)&lt;/code&gt;.</source>
          <target state="translated">왼쪽 연관 방식으로 두 개 이상의 기존 항목을 병합하여 새 이름의 튜플을 구성하십시오. 병합은 명명 된 튜플 쌍 사이에서 왼쪽에서 오른쪽으로 진행되므로 가장 왼쪽에있는 튜플과 가장 오른쪽에있는 튜플 모두에있는 필드의 순서는 가장 왼쪽에있는 튜플에서 발견되는 것과 동일한 위치를 갖습니다. 그러나 값은 해당 필드를 포함하는 가장 오른쪽으로 명명 된 튜플에서 일치하는 필드에서 가져옵니다. 맨 오른쪽에 이름이 지정된 튜플에만있는 필드가 끝에 추가됩니다. 서명 &lt;code&gt;merge(a::NamedTuple)&lt;/code&gt; 과 함께 이름이 지정된 단일 튜플 만 제공되는 경우 폴 백이 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="773ddde3a7d5f56b43450f9427ef414e19220724" translate="yes" xml:space="preserve">
          <source>Construct a random cyclic permutation of length &lt;code&gt;n&lt;/code&gt;. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator, see &lt;a href=&quot;#Random-Numbers-1&quot;&gt;Random Numbers&lt;/a&gt;. The element type of the result is the same as the type of &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">길이 &lt;code&gt;n&lt;/code&gt; 의 랜덤 순환 순열을 만듭니다. 옵션 &lt;code&gt;rng&lt;/code&gt; 인수는 참조 난수 발생기를 지정하는 &lt;a href=&quot;#Random-Numbers-1&quot;&gt;임의의 번호를&lt;/a&gt; . 결과의 요소 유형은 &lt;code&gt;n&lt;/code&gt; 유형과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="ed600dca9287d8a479f0f2758806c12b876aecb6" translate="yes" xml:space="preserve">
          <source>Construct a random permutation of length &lt;code&gt;n&lt;/code&gt;. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator (see &lt;a href=&quot;#Random-Numbers-1&quot;&gt;Random Numbers&lt;/a&gt;). The element type of the result is the same as the type of &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">길이 &lt;code&gt;n&lt;/code&gt; 의 랜덤 순열을 구성합니다 . 옵션 &lt;code&gt;rng&lt;/code&gt; 인수는 난수 생성기 (참조 지정하는 &lt;a href=&quot;#Random-Numbers-1&quot;&gt;임의의 번호를&lt;/a&gt; ). 결과의 요소 유형은 &lt;code&gt;n&lt;/code&gt; 유형과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="077c36b5cddb72a8d1da7fef475e2f40e5395bad" translate="yes" xml:space="preserve">
          <source>Construct a regex, such as &lt;code&gt;r&quot;^[a-z]*$&quot;&lt;/code&gt;, without interpolation and unescaping (except for quotation mark &lt;code&gt;&quot;&lt;/code&gt; which still has to be escaped). The regex also accepts one or more flags, listed after the ending quote, to change its behaviour:</source>
          <target state="translated">보간 및 이스케이프 처리 없이 &lt;code&gt;r&quot;^[a-z]*$&quot;&lt;/code&gt; 와 같은 정규 표현식을 작성하십시오 ( 여전히 이스케이프 해야하는 인용 부호 &lt;code&gt;&quot;&lt;/code&gt; 는 제외 ). 정규 표현식은 끝 인용 부호 뒤에 나열된 하나 이상의 플래그를 허용합니다. 행동을 바꾸십시오 :</target>
        </trans-unit>
        <trans-unit id="33aad8a62d61bbba4ad329f651211ce2a482be36" translate="yes" xml:space="preserve">
          <source>Construct a sorted set of &lt;code&gt;Int&lt;/code&gt;s generated by the given iterable object, or an empty set. Implemented as a bit string, and therefore designed for dense integer sets. If the set will be sparse (for example, holding a few very large integers), use &lt;a href=&quot;#Base.Set&quot;&gt;&lt;code&gt;Set&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">주어진 반복 가능한 객체 또는 빈 세트로 생성 된 정렬 된 &lt;code&gt;Int&lt;/code&gt; 세트를 구성합니다. 비트 열로 구현되어 고밀도 정수 세트 용으로 설계되었습니다. 집합이 희소 한 경우 (예 : 매우 큰 정수를 보유하는 경우) 대신 &lt;a href=&quot;#Base.Set&quot;&gt; &lt;code&gt;Set&lt;/code&gt; &lt;/a&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="45a1f7d88f46e1a876aecb1dc4b732278ee01769" translate="yes" xml:space="preserve">
          <source>Construct a square matrix from &lt;code&gt;Pair&lt;/code&gt;s of diagonals and vectors. Vector &lt;code&gt;kv.second&lt;/code&gt; will be placed on the &lt;code&gt;kv.first&lt;/code&gt; diagonal. &lt;code&gt;diagm&lt;/code&gt; constructs a full matrix; if you want storage-efficient versions with fast arithmetic, see &lt;a href=&quot;#LinearAlgebra.Diagonal&quot;&gt;&lt;code&gt;Diagonal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.Bidiagonal&quot;&gt;&lt;code&gt;Bidiagonal&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;#LinearAlgebra.Tridiagonal&quot;&gt;&lt;code&gt;Tridiagonal&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#LinearAlgebra.SymTridiagonal&quot;&gt;&lt;code&gt;SymTridiagonal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">대각선과 벡터의 &lt;code&gt;Pair&lt;/code&gt; 으로 정사각 행렬을 만듭니다. 벡터 &lt;code&gt;kv.second&lt;/code&gt; 는 &lt;code&gt;kv.first&lt;/code&gt; 대각선 에 배치됩니다 . &lt;code&gt;diagm&lt;/code&gt; 은 전체 행렬을 구성합니다. 빠른 산술을 사용하는 스토리지 효율적인 버전을 원하면 &lt;a href=&quot;#LinearAlgebra.Diagonal&quot;&gt; &lt;code&gt;Diagonal&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#LinearAlgebra.Bidiagonal&quot;&gt; &lt;code&gt;Bidiagonal&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#LinearAlgebra.Tridiagonal&quot;&gt; &lt;code&gt;Tridiagonal&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#LinearAlgebra.SymTridiagonal&quot;&gt; &lt;code&gt;SymTridiagonal&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="105188658b5054b3326fe1e162af42e4805232a3" translate="yes" xml:space="preserve">
          <source>Construct a square matrix with elements of the vector as diagonal elements.</source>
          <target state="translated">벡터 요소를 대각선 요소로 사용하여 정사각 행렬을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="e83aca212f69ccb433491a23b4580555779709aa" translate="yes" xml:space="preserve">
          <source>Construct a square sparse diagonal matrix from &lt;code&gt;Pair&lt;/code&gt;s of vectors and diagonals. Vector &lt;code&gt;kv.second&lt;/code&gt; will be placed on the &lt;code&gt;kv.first&lt;/code&gt; diagonal.</source>
          <target state="translated">&lt;code&gt;Pair&lt;/code&gt; 의 벡터와 대각선 으로 정사각형 희소 대각선 행렬을 만듭니다. 벡터 &lt;code&gt;kv.second&lt;/code&gt; 는 &lt;code&gt;kv.first&lt;/code&gt; 대각선 에 배치됩니다 .</target>
        </trans-unit>
        <trans-unit id="e78af3110399316b26ade3d45b60e10fc708bcd9" translate="yes" xml:space="preserve">
          <source>Construct a substitution string, used for regular expression substitutions. Within the string, sequences of the form &lt;code&gt;\N&lt;/code&gt; refer to the Nth capture group in the regex, and &lt;code&gt;\g&amp;lt;groupname&amp;gt;&lt;/code&gt; refers to a named capture group with name &lt;code&gt;groupname&lt;/code&gt;.</source>
          <target state="translated">정규식 대체에 사용되는 대체 문자열을 구성하십시오. 문자열 내에서 &lt;code&gt;\N&lt;/code&gt; 형식의 시퀀스 는 정규식의 N 번째 캡처 그룹을 참조하고 &lt;code&gt;\g&amp;lt;groupname&amp;gt;&lt;/code&gt; 은 이름이 &lt;code&gt;groupname&lt;/code&gt; 인 명명 된 캡처 그룹을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="7001fcde7ea51c36ac1824a5a8b0eedf713beed4" translate="yes" xml:space="preserve">
          <source>Construct a symmetric tridiagonal matrix from the diagonal (&lt;code&gt;dv&lt;/code&gt;) and first sub/super-diagonal (&lt;code&gt;ev&lt;/code&gt;), respectively. The result is of type &lt;code&gt;SymTridiagonal&lt;/code&gt; and provides efficient specialized eigensolvers, but may be converted into a regular matrix with &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert(Array, _)&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;Array(_)&lt;/code&gt; for short).</source>
          <target state="translated">대각선 ( &lt;code&gt;dv&lt;/code&gt; )과 첫 번째 sub / super-diagonal ( &lt;code&gt;ev&lt;/code&gt; )에서 각각 대칭 3 각형 행렬을 구성합니다 . 결과는 &lt;code&gt;SymTridiagonal&lt;/code&gt; 유형 이며 효율적인 특수 고유 솔버 를 제공하지만 &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert(Array, _)&lt;/code&gt; &lt;/a&gt; (또는 간단히 &lt;code&gt;Array(_)&lt;/code&gt; 를 사용 하여 일반 행렬로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d8d5353fe58ad31b1de6c2b618a70ed090651651" translate="yes" xml:space="preserve">
          <source>Construct a symmetric tridiagonal matrix from the diagonal and first sub/super-diagonal, of the symmetric matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">대칭 행렬 &lt;code&gt;A&lt;/code&gt; 의 대각선 및 첫 번째 하위 / 수퍼 대각선에서 대칭 3 각형 행렬을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="5e812abbcd333112ef665b3c50ab166d997a74f3" translate="yes" xml:space="preserve">
          <source>Construct a tridiagonal matrix from the first sub-diagonal, diagonal and first super-diagonal of the matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">행렬 &lt;code&gt;A&lt;/code&gt; 의 첫 번째 대각선, 대각선 및 첫 번째 대각선에서 삼각 행렬을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="747e5433f9793862323a449007017950fdbe1544" translate="yes" xml:space="preserve">
          <source>Construct a tridiagonal matrix from the first subdiagonal, diagonal, and first superdiagonal, respectively. The result is of type &lt;code&gt;Tridiagonal&lt;/code&gt; and provides efficient specialized linear solvers, but may be converted into a regular matrix with &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert(Array, _)&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;Array(_)&lt;/code&gt; for short). The lengths of &lt;code&gt;dl&lt;/code&gt; and &lt;code&gt;du&lt;/code&gt; must be one less than the length of &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">첫 번째 대각선, 대각선 및 첫 번째 대각선에서 각각 3 각형 행렬을 만듭니다. 결과는 &lt;code&gt;Tridiagonal&lt;/code&gt; 유형 이며 효율적인 특수 선형 솔버를 제공하지만 &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert(Array, _)&lt;/code&gt; &lt;/a&gt; (또는 간단히 &lt;code&gt;Array(_)&lt;/code&gt; 를 사용 하여 일반 행렬로 변환 할 수 있습니다 . 길이의 &lt;code&gt;dl&lt;/code&gt; 과 &lt;code&gt;du&lt;/code&gt; 의 길이보다 작아야 하나 &lt;code&gt;d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a45735b554554297a7fc87a9bba1a725ba384be" translate="yes" xml:space="preserve">
          <source>Construct a tuple of the given objects.</source>
          <target state="translated">주어진 객체의 튜플을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7fdc191ace6e9b509ad7d0b0a2b4eead7c650e5d" translate="yes" xml:space="preserve">
          <source>Construct an &lt;code&gt;N&lt;/code&gt;-dimensional &lt;a href=&quot;#Core.Array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt; containing elements of type &lt;code&gt;T&lt;/code&gt;, initialized with &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; entries. Element type &lt;code&gt;T&lt;/code&gt; must be able to hold these values, i.e. &lt;code&gt;Missing &amp;lt;: T&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; 항목으로 초기화 된 &lt;code&gt;T&lt;/code&gt; 유형의 요소를 포함 하는 &lt;code&gt;N&lt;/code&gt; 차원 &lt;a href=&quot;#Core.Array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; 을 구성하십시오 . 요소 유형 &lt;code&gt;T&lt;/code&gt; 는 이러한 값을 보유 할 수 있어야합니다 (예 : &lt;code&gt;Missing &amp;lt;: T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8ff556a297608632796b72ff2cb3c8e84dd2779" translate="yes" xml:space="preserve">
          <source>Construct an &lt;code&gt;N&lt;/code&gt;-dimensional &lt;a href=&quot;#Core.Array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt; containing elements of type &lt;code&gt;T&lt;/code&gt;, initialized with &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; entries. Element type &lt;code&gt;T&lt;/code&gt; must be able to hold these values, i.e. &lt;code&gt;Nothing &amp;lt;: T&lt;/code&gt;.</source>
          <target state="translated">항목 이 &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; 초기화 된 &lt;code&gt;T&lt;/code&gt; 유형의 요소를 포함 하는 &lt;code&gt;N&lt;/code&gt; 차원 &lt;a href=&quot;#Core.Array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; 을 구성 합니다. 요소 유형 &lt;code&gt;T&lt;/code&gt; 는 이러한 값을 보유 할 수 있어야합니다 (예 : &lt;code&gt;Nothing &amp;lt;: T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae459e01fcce313d45a189e6a321f000a9d4614d" translate="yes" xml:space="preserve">
          <source>Construct an &lt;code&gt;UnitUpperTriangular&lt;/code&gt; view of the matrix &lt;code&gt;A&lt;/code&gt;. Such a view has the &lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt;&lt;code&gt;oneunit&lt;/code&gt;&lt;/a&gt; of the &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;A&lt;/code&gt; on its diagonal.</source>
          <target state="translated">행렬 &lt;code&gt;A&lt;/code&gt; 의 &lt;code&gt;UnitUpperTriangular&lt;/code&gt; 뷰를 구성합니다 . 이러한 뷰는 보유 &lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt; &lt;code&gt;oneunit&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt; 의 그 대각선에있다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e5eea89cf2afaf3f4aa193305385c8f999189b8" translate="yes" xml:space="preserve">
          <source>Construct an &lt;code&gt;UpperTriangular&lt;/code&gt; view of the matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">행렬 &lt;code&gt;A&lt;/code&gt; 의 &lt;code&gt;UpperTriangular&lt;/code&gt; 뷰를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="efa7a80292bce29eaa41f35b63dbae9f5d8943a7" translate="yes" xml:space="preserve">
          <source>Construct an array by repeating array &lt;code&gt;A&lt;/code&gt; a given number of times in each dimension, specified by &lt;code&gt;counts&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;counts&lt;/code&gt; 로 지정된 각 차원에서 지정된 횟수만큼 배열 &lt;code&gt;A&lt;/code&gt; 를 반복하여 배열 을 구성 합니다 .</target>
        </trans-unit>
        <trans-unit id="dabd5c0da772665da5c4fb23a09786030dae44d8" translate="yes" xml:space="preserve">
          <source>Construct an array by repeating the entries of &lt;code&gt;A&lt;/code&gt;. The i-th element of &lt;code&gt;inner&lt;/code&gt; specifies the number of times that the individual entries of the i-th dimension of &lt;code&gt;A&lt;/code&gt; should be repeated. The i-th element of &lt;code&gt;outer&lt;/code&gt; specifies the number of times that a slice along the i-th dimension of &lt;code&gt;A&lt;/code&gt; should be repeated. If &lt;code&gt;inner&lt;/code&gt; or &lt;code&gt;outer&lt;/code&gt; are omitted, no repetition is performed.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 항목을 반복하여 배열을 구성하십시오 . 의 i 번째 요소 &lt;code&gt;inner&lt;/code&gt; 지정의 i 번째 차원의 개별 항목 횟수 &lt;code&gt;A&lt;/code&gt; 를 반복한다. 의 i 번째 요소 &lt;code&gt;outer&lt;/code&gt; 지정의 i 번째 슬라이스 사이즈에 따른 횟수 &lt;code&gt;A&lt;/code&gt; 를 반복한다. 경우 &lt;code&gt;inner&lt;/code&gt; 또는 &lt;code&gt;outer&lt;/code&gt; 생략하고, 더 반복은 수행되지 않는다.</target>
        </trans-unit>
        <trans-unit id="35fd888bce1ff7aeaee21a4d838a36c377edec0b" translate="yes" xml:space="preserve">
          <source>Construct an undef &lt;a href=&quot;#Base.BitArray&quot;&gt;&lt;code&gt;BitArray&lt;/code&gt;&lt;/a&gt; with the given dimensions. Behaves identically to the &lt;a href=&quot;#Core.Array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt; constructor. See &lt;a href=&quot;#Core.undef&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 치수로 &lt;a href=&quot;#Base.BitArray&quot;&gt; &lt;code&gt;BitArray&lt;/code&gt; &lt;/a&gt; 를 구축 합니다. &lt;a href=&quot;#Core.Array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; 생성자와 동일하게 동작합니다 . &lt;a href=&quot;#Core.undef&quot;&gt; &lt;code&gt;undef&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="54d87d0575b0e006fe5cc260cc0529044e72ab09" translate="yes" xml:space="preserve">
          <source>Construct an uninitialized &lt;a href=&quot;#Base.Matrix&quot;&gt;&lt;code&gt;Matrix{T}&lt;/code&gt;&lt;/a&gt; of size &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt;. See &lt;a href=&quot;#Core.undef&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">크기가 &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; 인 초기화되지 않은 &lt;a href=&quot;#Base.Matrix&quot;&gt; &lt;code&gt;Matrix{T}&lt;/code&gt; &lt;/a&gt; 를 구성합니다 . &lt;a href=&quot;#Core.undef&quot;&gt; &lt;code&gt;undef&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7eb6c96e45dddc926f98114383bd79e946048ede" translate="yes" xml:space="preserve">
          <source>Construct an uninitialized &lt;a href=&quot;#Base.Vector&quot;&gt;&lt;code&gt;Vector{T}&lt;/code&gt;&lt;/a&gt; of length &lt;code&gt;n&lt;/code&gt;. See &lt;a href=&quot;#Core.undef&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">길이 &lt;code&gt;n&lt;/code&gt; 의 초기화되지 않은 &lt;a href=&quot;#Base.Vector&quot;&gt; &lt;code&gt;Vector{T}&lt;/code&gt; &lt;/a&gt; 를 생성합니다 . &lt;a href=&quot;#Core.undef&quot;&gt; &lt;code&gt;undef&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e3ce437cb47785e9c47fa7a6dc465bfd8ef0ecab" translate="yes" xml:space="preserve">
          <source>Construct an uninitialized &lt;code&gt;N&lt;/code&gt;-dimensional &lt;a href=&quot;#Core.Array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt; containing elements of type &lt;code&gt;T&lt;/code&gt;. &lt;code&gt;N&lt;/code&gt; can either be supplied explicitly, as in &lt;code&gt;Array{T,N}(undef, dims)&lt;/code&gt;, or be determined by the length or number of &lt;code&gt;dims&lt;/code&gt;. &lt;code&gt;dims&lt;/code&gt; may be a tuple or a series of integer arguments corresponding to the lengths in each dimension. If the rank &lt;code&gt;N&lt;/code&gt; is supplied explicitly, then it must match the length or number of &lt;code&gt;dims&lt;/code&gt;. See &lt;a href=&quot;#Core.undef&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 형의 요소를 포함 하는 초기화되지 않은 &lt;code&gt;N&lt;/code&gt; 차원 &lt;a href=&quot;#Core.Array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; 을 구성 합니다. &lt;code&gt;N&lt;/code&gt; 은 어느 하나에서와 같이 명시 적으로 제공 될 수 &lt;code&gt;Array{T,N}(undef, dims)&lt;/code&gt; 또는 길이 또는 개수에 의해 결정될 수 &lt;code&gt;dims&lt;/code&gt; . &lt;code&gt;dims&lt;/code&gt; 는 각 차원의 길이에 해당하는 튜플 또는 일련의 정수 인수 일 수 있습니다. 순위 &lt;code&gt;N&lt;/code&gt; 이 명시 적으로 제공된 경우 길이 또는 &lt;code&gt;dims&lt;/code&gt; 수와 일치해야합니다 . &lt;a href=&quot;#Core.undef&quot;&gt; &lt;code&gt;undef&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c5739db91a2916a6de2ec1c1497c1a0a7b92373" translate="yes" xml:space="preserve">
          <source>Construct in &lt;code&gt;A&lt;/code&gt; a random cyclic permutation of length &lt;code&gt;length(A)&lt;/code&gt;. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator, see &lt;a href=&quot;#Random-Numbers-1&quot;&gt;Random Numbers&lt;/a&gt;.</source>
          <target state="translated">에 구축 길이의 랜덤 순환 전치 &lt;code&gt;length(A)&lt;/code&gt; . 옵션 &lt;code&gt;rng&lt;/code&gt; 인수는 참조 난수 발생기를 지정하는 &lt;a href=&quot;#Random-Numbers-1&quot;&gt;임의의 번호를&lt;/a&gt; . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="29fed1fdd69043bc2d52edc1a30a547c01f5cae5" translate="yes" xml:space="preserve">
          <source>Construct in &lt;code&gt;A&lt;/code&gt; a random permutation of length &lt;code&gt;length(A)&lt;/code&gt;. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator (see &lt;a href=&quot;#Random-Numbers-1&quot;&gt;Random Numbers&lt;/a&gt;). To randomly permute an arbitrary vector, see &lt;a href=&quot;#Random.shuffle&quot;&gt;&lt;code&gt;shuffle&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Random.shuffle!&quot;&gt;&lt;code&gt;shuffle!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">에 구축 길이의 임의의 순열 &lt;code&gt;length(A)&lt;/code&gt; . 옵션 &lt;code&gt;rng&lt;/code&gt; 인수는 난수 생성기 (참조 지정하는 &lt;a href=&quot;#Random-Numbers-1&quot;&gt;임의의 번호를&lt;/a&gt; ). 임의의 벡터를 무작위로 치환하려면 &lt;a href=&quot;#Random.shuffle&quot;&gt; &lt;code&gt;shuffle&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#Random.shuffle!&quot;&gt; &lt;code&gt;shuffle!&lt;/code&gt; &lt;/a&gt; 참조하십시오 ! . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b38dc6a46091930691f0979c241388b85fc088b0" translate="yes" xml:space="preserve">
          <source>Construct the intersection of sets. Maintain order with arrays.</source>
          <target state="translated">집합의 교집합을 만듭니다. 배열 순서를 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="b5eeb48c87138f172c83ab82669efe34174ef13f" translate="yes" xml:space="preserve">
          <source>Construct the set of elements in &lt;code&gt;s&lt;/code&gt; but not in any of the iterables in &lt;code&gt;itrs&lt;/code&gt;. Maintain order with arrays.</source>
          <target state="translated">&lt;code&gt;itrs&lt;/code&gt; 의 iterables가 아닌 &lt;code&gt;s&lt;/code&gt; 로 요소 세트를 구성 하십시오 . 배열 순서를 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="2a22645f8ad348047eb67f511f7fff20c9a8a19d" translate="yes" xml:space="preserve">
          <source>Construct the symmetric difference of elements in the passed in sets. When &lt;code&gt;s&lt;/code&gt; is not an &lt;code&gt;AbstractSet&lt;/code&gt;, the order is maintained. Note that in this case the multiplicity of elements matters.</source>
          <target state="translated">전달 된 세트에서 요소의 대칭 적 차이를 구성하십시오. 경우 &lt;code&gt;s&lt;/code&gt; 아니 어서 &lt;code&gt;AbstractSet&lt;/code&gt; 순서가 유지된다. 이 경우 여러 요소가 중요합니다.</target>
        </trans-unit>
        <trans-unit id="0478a19afdbd482d3c0fcafa5d1ed46e5ac1b005" translate="yes" xml:space="preserve">
          <source>Construct the symmetric difference of the passed in sets, and overwrite &lt;code&gt;s&lt;/code&gt; with the result. When &lt;code&gt;s&lt;/code&gt; is an array, the order is maintained. Note that in this case the multiplicity of elements matters.</source>
          <target state="translated">전달 된 세트의 대칭 차이 를 구성하고 결과로 &lt;code&gt;s&lt;/code&gt; 를 덮어 씁니다 . 경우 &lt;code&gt;s&lt;/code&gt; 배열되면, 순서는 유지된다. 이 경우 여러 요소가 중요합니다.</target>
        </trans-unit>
        <trans-unit id="4a79ebc653ff986cbb15a5ea08e6559fdafc9723" translate="yes" xml:space="preserve">
          <source>Construct the union of passed in sets and overwrite &lt;code&gt;s&lt;/code&gt; with the result. Maintain order with arrays.</source>
          <target state="translated">세트 전달 및 덮어 쓰기의 조합 구축 &lt;code&gt;s&lt;/code&gt; 결과로. 배열 순서를 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="8e4f2bd81d4e0c5eb2e81850ab74130f1b05c10b" translate="yes" xml:space="preserve">
          <source>Construct the union of sets. Maintain order with arrays.</source>
          <target state="translated">집합의 합집합을 구성하십시오. 배열 순서를 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="e97901b09af90ecffd455fb1a47763d279bd2eaf" translate="yes" xml:space="preserve">
          <source>Constructing an object with &lt;a href=&quot;../../base/base/index#new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; converts to the object's declared field types.</source>
          <target state="translated">와 객체 구축 &lt;a href=&quot;../../base/base/index#new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 개체의 선언 필드 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="4a770f4b726b7e17438de4d4705a42cdcff41d27" translate="yes" xml:space="preserve">
          <source>Constructing infinite rational values is acceptable:</source>
          <target state="translated">무한 합리적인 값을 구성하는 것은 허용됩니다 :</target>
        </trans-unit>
        <trans-unit id="7fac2273dfc18f832b908b46cc19ab6756b7533f" translate="yes" xml:space="preserve">
          <source>Constructing strings using concatenation can become a bit cumbersome, however. To reduce the need for these verbose calls to &lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; or repeated multiplications, Julia allows interpolation into string literals using &lt;code&gt;$&lt;/code&gt;, as in Perl:</source>
          <target state="translated">그러나 연결을 사용하여 문자열을 구성하면 약간 번거로울 수 있습니다. 이러한 자세한 통화의 필요성 줄이기 위해 &lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt; 또는 반복 곱셈, 줄리아는 문자열 리터럴로 보간 사용하실 수 있습니다 &lt;code&gt;$&lt;/code&gt; 를 펄과 같이 :</target>
        </trans-unit>
        <trans-unit id="1b21aefcdf98b76a2cdb3d34b924ca3a51ce9f3c" translate="yes" xml:space="preserve">
          <source>Construction Sign</source>
          <target state="translated">건설 사인</target>
        </trans-unit>
        <trans-unit id="e1fc1d68d6545bbe2eb454e9442edb86e725d413" translate="yes" xml:space="preserve">
          <source>Construction Worker</source>
          <target state="translated">건설 노동자</target>
        </trans-unit>
        <trans-unit id="e2a4ac16668ac3dfb92c81ed57d43e62fd409a66" translate="yes" xml:space="preserve">
          <source>Construction and Initialization</source>
          <target state="translated">건설 및 초기화</target>
        </trans-unit>
        <trans-unit id="d1de0471cc72ee7ecb3e7d438567f5775ca5ab6d" translate="yes" xml:space="preserve">
          <source>Constructor methods to appropriately handle such mixed cases can be defined, but that will not be discussed until later on in &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Constructors&lt;/a&gt;.</source>
          <target state="translated">이러한 혼합 사례를 적절히 처리하기위한 생성자 메소드를 정의 할 수 있지만 나중에 &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;생성자&lt;/a&gt; 에서 논의 할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="60a5c966a71a24034f9238685790a526710ef75d" translate="yes" xml:space="preserve">
          <source>Constructors</source>
          <target state="translated">Constructors</target>
        </trans-unit>
        <trans-unit id="7b15c99cccb175b7231d573558f6e442c98078f7" translate="yes" xml:space="preserve">
          <source>Constructors &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt; are functions that create new objects &amp;ndash; specifically, instances of &lt;a href=&quot;../types/index#Composite-Types-1&quot;&gt;Composite Types&lt;/a&gt;. In Julia, type objects also serve as constructor functions: they create new instances of themselves when applied to an argument tuple as a function. This much was already mentioned briefly when composite types were introduced. For example:</source>
          <target state="translated">생성자 &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt; 는 새로운 객체, 특히 &lt;a href=&quot;../types/index#Composite-Types-1&quot;&gt;Composite Types&lt;/a&gt; 인스턴스를 생성하는 함수입니다 . Julia에서 타입 객체는 생성자 함수로도 사용됩니다. 인수 튜플에 함수로 적용될 때 새로운 인스턴스를 생성합니다. 복합 유형이 소개 될 때이 부분은 이미 간략하게 언급되었습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="96c5e9bf4fffd0020a62904e36d49838adcd0526" translate="yes" xml:space="preserve">
          <source>Constructors and Types</source>
          <target state="translated">생성자와 타입</target>
        </trans-unit>
        <trans-unit id="0335c1fc2e9e86f516636bf75a62df36bf31b328" translate="yes" xml:space="preserve">
          <source>Constructors exist to create these types from primitive numerical types, and &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt; can be used to construct them from &lt;code&gt;AbstractString&lt;/code&gt;s. Once created, they participate in arithmetic with all other numeric types thanks to Julia's &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;type promotion and conversion mechanism&lt;/a&gt;:</source>
          <target state="translated">프리미티브 숫자 유형에서 이러한 유형을 작성하기 위해 생성자가 존재하며 &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt; 을 사용하여 &lt;code&gt;AbstractString&lt;/code&gt; 에서 유형 을 구성 할 수 있습니다 . 일단 생성되면 Julia의 &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;유형 승격 및 변환 메커니즘&lt;/a&gt; 덕분에 다른 모든 숫자 유형과의 산술에 참여합니다 .</target>
        </trans-unit>
        <trans-unit id="f53def390cea96c19f58854f6ab25c6fcd002f64" translate="yes" xml:space="preserve">
          <source>Constructors for types unrelated to their arguments</source>
          <target state="translated">인수와 관련이없는 유형의 생성자</target>
        </trans-unit>
        <trans-unit id="f9c0c3b4014f45dbe2772c6f91e5e70044c87424" translate="yes" xml:space="preserve">
          <source>Constructors that don't return instances of their own type</source>
          <target state="translated">자체 유형의 인스턴스를 반환하지 않는 생성자</target>
        </trans-unit>
        <trans-unit id="cf8786bb19baaa35e14eeb1b40975a00c375a3b2" translate="yes" xml:space="preserve">
          <source>Constructs a &lt;code&gt;Channel&lt;/code&gt; with an internal buffer that can hold a maximum of &lt;code&gt;sz&lt;/code&gt; objects of type &lt;code&gt;T&lt;/code&gt;. &lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt;&lt;code&gt;put!&lt;/code&gt;&lt;/a&gt; calls on a full channel block until an object is removed with &lt;a href=&quot;#Base.take!-Tuple%7BChannel%7D&quot;&gt;&lt;code&gt;take!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">내부 버퍼로 &lt;code&gt;T&lt;/code&gt; 형 의 최대 &lt;code&gt;sz&lt;/code&gt; 객체를 보관할 수 있는 &lt;code&gt;Channel&lt;/code&gt; 을 구축합니다 . &lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt; &lt;code&gt;put!&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#Base.take!-Tuple%7BChannel%7D&quot;&gt; &lt;code&gt;take!&lt;/code&gt; &lt;/a&gt; 하여 객체를 제거 할 때까지 전체 채널 블록에서 호출합니다 ! .</target>
        </trans-unit>
        <trans-unit id="d4f2020b38d81687704d5f3eafd379e31ccefbd8" translate="yes" xml:space="preserve">
          <source>Constructs an upper (&lt;code&gt;uplo=:U&lt;/code&gt;) or lower (&lt;code&gt;uplo=:L&lt;/code&gt;) bidiagonal matrix using the given diagonal (&lt;code&gt;dv&lt;/code&gt;) and off-diagonal (&lt;code&gt;ev&lt;/code&gt;) vectors. The result is of type &lt;code&gt;Bidiagonal&lt;/code&gt; and provides efficient specialized linear solvers, but may be converted into a regular matrix with &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert(Array, _)&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;Array(_)&lt;/code&gt; for short). The length of &lt;code&gt;ev&lt;/code&gt; must be one less than the length of &lt;code&gt;dv&lt;/code&gt;.</source>
          <target state="translated">주어진 대각선 ( &lt;code&gt;dv&lt;/code&gt; ) 및 비 대각선 ( &lt;code&gt;ev&lt;/code&gt; ) 벡터를 사용하여 위 ( &lt;code&gt;uplo=:U&lt;/code&gt; ) 또는 하 ( &lt;code&gt;uplo=:L&lt;/code&gt; ) 쌍각 행렬을 구성합니다 . 결과는 &lt;code&gt;Bidiagonal&lt;/code&gt; 유형 이며 효율적인 특수 선형 솔버를 제공하지만 &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert(Array, _)&lt;/code&gt; &lt;/a&gt; (또는 간단히 &lt;code&gt;Array(_)&lt;/code&gt; 를 사용 하여 일반 행렬로 변환 할 수 있습니다 . 의 길이 &lt;code&gt;ev&lt;/code&gt; 의 길이보다 하나 작아야합니다 &lt;code&gt;dv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31855f42648a53f0f883864dfbb8c76728ada032" translate="yes" xml:space="preserve">
          <source>Contains As Member</source>
          <target state="translated">회원으로 포함</target>
        </trans-unit>
        <trans-unit id="6374949f24934c8f59af915f665fe9ad04edf8fb" translate="yes" xml:space="preserve">
          <source>Contains As Normal Subgroup</source>
          <target state="translated">일반 하위 그룹으로 포함</target>
        </trans-unit>
        <trans-unit id="c6255fd2009d9e2b6c2d76d570b84317f3968045" translate="yes" xml:space="preserve">
          <source>Contains As Normal Subgroup Or Equal To</source>
          <target state="translated">일반 하위 그룹으로 포함 또는</target>
        </trans-unit>
        <trans-unit id="bddb6860083f671133b8edfd2c54cc768d4aa9a9" translate="yes" xml:space="preserve">
          <source>Contains With Long Horizontal Stroke</source>
          <target state="translated">긴 수평 스트로크 포함</target>
        </trans-unit>
        <trans-unit id="8b7cbaa37f45d1b7957bf24d5d47157af046982a" translate="yes" xml:space="preserve">
          <source>Contains With Overbar</source>
          <target state="translated">오버 바와 함께 포함</target>
        </trans-unit>
        <trans-unit id="7c34feec9ab0b7359b089f798a1fbac1a7ebc48f" translate="yes" xml:space="preserve">
          <source>Contains With Vertical Bar At End Of Horizontal Stroke</source>
          <target state="translated">수평 스트로크 끝에 수직 막대 포함</target>
        </trans-unit>
        <trans-unit id="c3a18764e13219b073d5d7052ee1c75c3fd0245e" translate="yes" xml:space="preserve">
          <source>Contains the information about HEAD during a fetch, including the name and URL of the branch fetched from, the oid of the HEAD, and whether the fetched HEAD has been merged locally.</source>
          <target state="translated">페치 된 브랜치의 이름 및 URL, HEAD의 OID 및 페치 된 HEAD가 로컬로 병합되었는지 여부를 포함하여 페치 중 HEAD에 대한 정보를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="7606203ccba192fbac54fde902d8586ac81effb6" translate="yes" xml:space="preserve">
          <source>Contour Integral</source>
          <target state="translated">윤곽 적분</target>
        </trans-unit>
        <trans-unit id="4722c5ea64f5bf604117b9b25da5ac1ab2753262" translate="yes" xml:space="preserve">
          <source>Control Flow</source>
          <target state="translated">제어 흐름</target>
        </trans-unit>
        <trans-unit id="e7d0119a994fc38f14a5d2d52d98f6d567da9857" translate="yes" xml:space="preserve">
          <source>Control Flow and Short-Circuiting Operators</source>
          <target state="translated">제어 흐름 및 단락 연산자</target>
        </trans-unit>
        <trans-unit id="ac3c5834f77ae59c902947ccef1074dc7ca1801a" translate="yes" xml:space="preserve">
          <source>Control flow</source>
          <target state="translated">제어 흐름</target>
        </trans-unit>
        <trans-unit id="72f9c97f5741988f58f0cfe9c25d834ba26762be" translate="yes" xml:space="preserve">
          <source>Control flow operators including &lt;a href=&quot;../../base/base/index#if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/base/index#while&quot;&gt;&lt;code&gt;while&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;../control-flow/index#man-conditional-evaluation-1&quot;&gt;ternary operator&lt;/a&gt;&lt;code&gt;x ? y : z&lt;/code&gt; do not allow for missing values. This is because of the uncertainty about whether the actual value would be &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; if we could observe it, which implies that we do not know how the program should behave. A &lt;a href=&quot;../../base/base/index#Core.TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is thrown as soon as a &lt;code&gt;missing&lt;/code&gt; value is encountered in this context</source>
          <target state="translated">를 포함한 제어 흐름 사업자 &lt;a href=&quot;../../base/base/index#if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/base/index#while&quot;&gt; &lt;code&gt;while&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;../control-flow/index#man-conditional-evaluation-1&quot;&gt;삼항 연산자의 &lt;/a&gt; &lt;code&gt;x ? y : z&lt;/code&gt; 는 결 측값을 허용하지 않습니다. 관찰 할 수 있는 실제 값이 &lt;code&gt;true&lt;/code&gt; 인지 &lt;code&gt;false&lt;/code&gt; 인지에 대한 불확실성 때문입니다. 이는 프로그램의 작동 방식을 알 수 없음을 의미합니다. &lt;a href=&quot;../../base/base/index#Core.TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; A와 자마자 발생합니다 &lt;code&gt;missing&lt;/code&gt; 값이 맥락에서 발생</target>
        </trans-unit>
        <trans-unit id="14b7866ef465dde33929d7924f93fff8b8dbc0b9" translate="yes" xml:space="preserve">
          <source>Control whether garbage collection is enabled using a boolean argument (&lt;code&gt;true&lt;/code&gt; for enabled, &lt;code&gt;false&lt;/code&gt; for disabled). Return previous GC state.</source>
          <target state="translated">가비지 수집 (부울 인수하여 사용할 수 있는지 여부를 제어 &lt;code&gt;true&lt;/code&gt; 활성화를위한, &lt;code&gt;false&lt;/code&gt; 장애인을). 이전 GC 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="14f8f8ee865f088942c342818dc4e3bbb1536995" translate="yes" xml:space="preserve">
          <source>Control whether inlining is permitted, including overriding &lt;code&gt;@inline&lt;/code&gt; declarations</source>
          <target state="translated">&lt;code&gt;@inline&lt;/code&gt; 선언 재정의를 포함하여 인라인 허용 여부 제어</target>
        </trans-unit>
        <trans-unit id="cacef9e904c125c2f7ac4e42d389c8844e172ac2" translate="yes" xml:space="preserve">
          <source>Convenience Store</source>
          <target state="translated">편의점</target>
        </trans-unit>
        <trans-unit id="e97a673f9a9eebff3f10ed71f5a88d461090a8ca" translate="yes" xml:space="preserve">
          <source>Convenience functions for metaprogramming.</source>
          <target state="translated">메타 프로그래밍을위한 편의 기능.</target>
        </trans-unit>
        <trans-unit id="fd9b14a00b20c7a8276bd5748c3165fb1ca289f8" translate="yes" xml:space="preserve">
          <source>Conversely, &lt;code&gt;similar(trues(10,10), 2)&lt;/code&gt; returns an uninitialized &lt;code&gt;BitVector&lt;/code&gt; with two elements since &lt;code&gt;BitArray&lt;/code&gt;s are both mutable and can support 1-dimensional arrays:</source>
          <target state="translated">반대로, &lt;code&gt;similar(trues(10,10), 2)&lt;/code&gt; 는 &lt;code&gt;BitArray&lt;/code&gt; 가 둘 다 변경 가능하고 1 차원 배열을 지원할 수 있으므로 두 개의 요소 가있는 초기화되지 않은 &lt;code&gt;BitVector&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="4234a78959811f144edc9c62e989cabf24ee370a" translate="yes" xml:space="preserve">
          <source>Conversely, when passing a vector of strings to LibGit2, it is generally simplest to rely on implicit conversion:</source>
          <target state="translated">반대로, 문자열 벡터를 LibGit2에 전달할 때 일반적으로 암시 적 변환에 의존하는 것이 가장 간단합니다.</target>
        </trans-unit>
        <trans-unit id="9151f8433f795cb0f0b5b6743aeb7de77ec49f00" translate="yes" xml:space="preserve">
          <source>Conversion</source>
          <target state="translated">Conversion</target>
        </trans-unit>
        <trans-unit id="8cc29d077456587b44d9a48d75801504d22c31b2" translate="yes" xml:space="preserve">
          <source>Conversion Functions</source>
          <target state="translated">변환 함수</target>
        </trans-unit>
        <trans-unit id="04666b33ed1c43f23bbe0e99877e7f10b6a933fa" translate="yes" xml:space="preserve">
          <source>Conversion and Promotion</source>
          <target state="translated">전환 및 프로모션</target>
        </trans-unit>
        <trans-unit id="8d86d2ec0c7b6756fe66cc1bf719bbb241833abb" translate="yes" xml:space="preserve">
          <source>Conversion from rational to floating-point respects the following identity for any integral values of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, with the exception of the case &lt;code&gt;a == 0&lt;/code&gt; and &lt;code&gt;b == 0&lt;/code&gt;:</source>
          <target state="translated">유리수의 부동 점 중 정수 값에 대해 다음 신원 변환 및 &lt;code&gt;b&lt;/code&gt; 의 경우를 제외하고, &lt;code&gt;a == 0&lt;/code&gt; 및 &lt;code&gt;b == 0&lt;/code&gt; : &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ee457d7a754e6e789e5e9067e307640598d5fdf" translate="yes" xml:space="preserve">
          <source>Conversion isn't always possible, in which case a no method error is thrown indicating that &lt;code&gt;convert&lt;/code&gt; doesn't know how to perform the requested conversion:</source>
          <target state="translated">변환이 항상 가능한 것은 아니며,이 경우 &lt;code&gt;convert&lt;/code&gt; 이 요청 된 변환을 수행하는 방법을 모른다는 것을 나타내는 메소드 오류가 발생 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c85fbb802a404d058a90790ec033af382ae6bcd" translate="yes" xml:space="preserve">
          <source>Conversion vs. Construction</source>
          <target state="translated">전환 대 건설</target>
        </trans-unit>
        <trans-unit id="156f3c8386685fd957672db82cc983d0b1768fc0" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;x&lt;/code&gt; from degrees to radians.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 를도에서 라디안으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="930fbd712c9569bcac9a41934f09fb34d835188c" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;x&lt;/code&gt; from radians to degrees.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 를 라디안에서도 단위로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="aaf4386c273bdc11f6c707ae019613ac6e236b92" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;x&lt;/code&gt; to a C argument of type &lt;code&gt;T&lt;/code&gt; where the input &lt;code&gt;x&lt;/code&gt; must be the return value of &lt;code&gt;cconvert(T, ...)&lt;/code&gt;.</source>
          <target state="translated">변환 &lt;code&gt;x&lt;/code&gt; 형의 인수 C로 &lt;code&gt;T&lt;/code&gt; 입력 &lt;code&gt;x&lt;/code&gt; 는 반환 값이어야 &lt;code&gt;cconvert(T, ...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4acb077b4d119d3ed00eeba6aa056446504f49a" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;x&lt;/code&gt; to a value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;T&lt;/code&gt; 유형의 값으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="91ec563506a54debc59cdb744c1c00d2ff1a3c35" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;x&lt;/code&gt; to a value to be passed to C code as type &lt;code&gt;T&lt;/code&gt;, typically by calling &lt;code&gt;convert(T, x)&lt;/code&gt;.</source>
          <target state="translated">변환 &lt;code&gt;x&lt;/code&gt; 의 값으로 입력으로서 C 코드에 전달할 &lt;code&gt;T&lt;/code&gt; 전형적으로 호출함으로써, &lt;code&gt;convert(T, x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d3cb248dc70e1ee69a390558f82f6e2af4dac4b" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;x&lt;/code&gt; to an object that has &lt;code&gt;axes&lt;/code&gt; and supports indexing</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;axes&lt;/code&gt; 있고 색인을 지원 하는 객체로 변환</target>
        </trans-unit>
        <trans-unit id="def5bf1795c56c2c61188495ac929f9d40e5f863" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;y&lt;/code&gt; to the type of &lt;code&gt;x&lt;/code&gt; (&lt;code&gt;convert(typeof(x), y)&lt;/code&gt;).</source>
          <target state="translated">변환 &lt;code&gt;y&lt;/code&gt; 유형에 &lt;code&gt;x&lt;/code&gt; ( &lt;code&gt;convert(typeof(x), y)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ad4bb4dbf97061448cd4f6b22cbb5a0e5289b08e" translate="yes" xml:space="preserve">
          <source>Convert a &lt;code&gt;Date&lt;/code&gt; to a &lt;code&gt;DateTime&lt;/code&gt;. The hour, minute, second, and millisecond parts of the new &lt;code&gt;DateTime&lt;/code&gt; are assumed to be zero.</source>
          <target state="translated">&lt;code&gt;Date&lt;/code&gt; 를 &lt;code&gt;DateTime&lt;/code&gt; 으로 변환하십시오 . 새 &lt;code&gt;DateTime&lt;/code&gt; 의시 , 분, 초 및 밀리 초 부분은 0으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="031081832af367cd87e42057b3adc69a323b88c8" translate="yes" xml:space="preserve">
          <source>Convert a &lt;code&gt;DateTime&lt;/code&gt; to a &lt;code&gt;Date&lt;/code&gt;. The hour, minute, second, and millisecond parts of the &lt;code&gt;DateTime&lt;/code&gt; are truncated, so only the year, month and day parts are used in construction.</source>
          <target state="translated">&lt;code&gt;DateTime&lt;/code&gt; 을 &lt;code&gt;Date&lt;/code&gt; 로 변환하십시오 . &lt;code&gt;DateTime&lt;/code&gt; 의 시간, 분, 초 및 밀리 초 부분 이 잘 리므로 년, 월 및 일 부분 만 구성에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="987898a3319e41bac5f9dbe1956b4e7e2b290ba4" translate="yes" xml:space="preserve">
          <source>Convert a &lt;code&gt;DateTime&lt;/code&gt; to a &lt;code&gt;Time&lt;/code&gt;. The hour, minute, second, and millisecond parts of the &lt;code&gt;DateTime&lt;/code&gt; are used to create the new &lt;code&gt;Time&lt;/code&gt;. Microsecond and nanoseconds are zero by default.</source>
          <target state="translated">&lt;code&gt;DateTime&lt;/code&gt; 을 &lt;code&gt;Time&lt;/code&gt; 변환하십시오 . &lt;code&gt;DateTime&lt;/code&gt; 의시 , 분, 초 및 밀리 초 부분은 새 &lt;code&gt;Time&lt;/code&gt; 을 만드는 데 사용됩니다 . 마이크로 초 및 나노초는 기본적으로 0입니다.</target>
        </trans-unit>
        <trans-unit id="697f574b741b0307339ff2b81d5ecba120fae99d" translate="yes" xml:space="preserve">
          <source>Convert a &lt;code&gt;Ptr&lt;/code&gt; to an object reference. Assumes the pointer refers to a valid heap-allocated Julia object. If this is not the case, undefined behavior results, hence this function is considered &quot;unsafe&quot; and should be used with care.</source>
          <target state="translated">&lt;code&gt;Ptr&lt;/code&gt; 을 객체 참조로 변환합니다 . 포인터가 유효한 힙 할당 Julia 객체를 참조한다고 가정합니다. 그렇지 않은 경우 정의되지 않은 동작이 발생하므로이 기능은 &quot;안전하지 않은&quot;것으로 간주되므로주의해서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4dd17d692e3047c02ceced8797177e51afe3b937" translate="yes" xml:space="preserve">
          <source>Convert a Win32 system call error code to a descriptive string [only available on Windows].</source>
          <target state="translated">Win32 시스템 호출 오류 코드를 설명 문자열 (Windows에서만 사용 가능)로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="3cd6dfa20fba21ea7113b5c7cbcac03d4ed64703" translate="yes" xml:space="preserve">
          <source>Convert a number of seconds since the epoch to broken-down format, with fields &lt;code&gt;sec&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;, &lt;code&gt;hour&lt;/code&gt;, &lt;code&gt;mday&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt;, &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;wday&lt;/code&gt;, &lt;code&gt;yday&lt;/code&gt;, and &lt;code&gt;isdst&lt;/code&gt;.</source>
          <target state="translated">epoch 이후의 초 수를 &lt;code&gt;sec&lt;/code&gt; , &lt;code&gt;min&lt;/code&gt; , &lt;code&gt;hour&lt;/code&gt; , &lt;code&gt;mday&lt;/code&gt; , &lt;code&gt;month&lt;/code&gt; , &lt;code&gt;year&lt;/code&gt; , &lt;code&gt;wday&lt;/code&gt; , &lt;code&gt;yday&lt;/code&gt; 및 &lt;code&gt;isdst&lt;/code&gt; 필드를 사용하여 분류 형식으로 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="0bacdc75b4f7b34973b32c316e9223e93efc1358" translate="yes" xml:space="preserve">
          <source>Convert a number or array to a floating point data type.</source>
          <target state="translated">숫자 나 배열을 부동 소수점 데이터 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="e2fe46f6de6c971f0ac0667455bdde8ca5b1ddfa" translate="yes" xml:space="preserve">
          <source>Convert a number to a maximum precision representation (typically &lt;a href=&quot;#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;BigFloat&lt;/code&gt;). See &lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; for information about some pitfalls with floating-point numbers.</source>
          <target state="translated">숫자를 최대 정밀도 표현 (일반적으로 &lt;a href=&quot;#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;BigFloat&lt;/code&gt; ) 으로 변환하십시오 . 부동 소수점 숫자가있는 함정에 대한 정보는 &lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="66f60301033862b1a2c3227918f5dcb7ad2365b4" translate="yes" xml:space="preserve">
          <source>Convert a number to a signed integer. If the argument is unsigned, it is reinterpreted as signed without checking for overflow.</source>
          <target state="translated">숫자를 부호있는 정수로 변환하십시오. 인수가 서명되지 않은 경우 오버플로를 확인하지 않고 서명 된 것으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="d2a09c50d7cce1fe8a525fcca2fb263328178ae3" translate="yes" xml:space="preserve">
          <source>Convert a number to an unsigned integer. If the argument is signed, it is reinterpreted as unsigned without checking for negative values.</source>
          <target state="translated">숫자를 부호없는 정수로 변환합니다. 인수가 서명 된 경우 음수 값을 확인하지 않고 부호없는 것으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="fadb2f4e5a02f95b1f6e83b26d6f82c505453eb8" translate="yes" xml:space="preserve">
          <source>Convert a path to an absolute path by adding the current directory if necessary. Also normalizes the path as in &lt;a href=&quot;#Base.Filesystem.normpath&quot;&gt;&lt;code&gt;normpath&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">필요한 경우 현재 디렉토리를 추가하여 경로를 절대 경로로 변환하십시오. 또한 &lt;a href=&quot;#Base.Filesystem.normpath&quot;&gt; &lt;code&gt;normpath&lt;/code&gt; &lt;/a&gt; 에서와 같이 경로를 정규화합니다 .</target>
        </trans-unit>
        <trans-unit id="99b4eb18032a744b83dd1a3438570db3228d17cf" translate="yes" xml:space="preserve">
          <source>Convert a set of paths to an absolute path by joining them together and adding the current directory if necessary. Equivalent to &lt;code&gt;abspath(joinpath(path, paths...))&lt;/code&gt;.</source>
          <target state="translated">경로를 결합하고 필요한 경우 현재 디렉토리를 추가하여 경로 세트를 절대 경로로 변환하십시오. 상당 &lt;code&gt;abspath(joinpath(path, paths...))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9696c8728ca32245943263f7e7949895d8e5a6e" translate="yes" xml:space="preserve">
          <source>Convert a string to &lt;code&gt;String&lt;/code&gt; type and check that it contains only ASCII data, otherwise throwing an &lt;code&gt;ArgumentError&lt;/code&gt; indicating the position of the first non-ASCII byte.</source>
          <target state="translated">문자열을 &lt;code&gt;String&lt;/code&gt; 유형으로 변환하고 ASCII 데이터 만 포함하는지 확인하십시오. 그렇지 않으면 첫 번째 비 ASCII 바이트의 위치를 ​​나타내는 &lt;code&gt;ArgumentError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c6034bf2e7e922ec416e6749722dfe4bed51455b" translate="yes" xml:space="preserve">
          <source>Convert a string to a contiguous byte array representation encoded as UTF-8 bytes. This representation is often appropriate for passing strings to C.</source>
          <target state="translated">문자열을 UTF-8 바이트로 인코딩 된 연속 바이트 배열 표현으로 변환하십시오. 이 표현은 종종 문자열을 C로 전달하는 데 적합합니다.</target>
        </trans-unit>
        <trans-unit id="bdb2e7f4ffa842fe969c9313fede05ab9811deb6" translate="yes" xml:space="preserve">
          <source>Convert a system call error code to a descriptive string</source>
          <target state="translated">시스템 호출 오류 코드를 설명 문자열로 변환</target>
        </trans-unit>
        <trans-unit id="df69e31a6e1a10ddfb886835ab258a4b8daa2d29" translate="yes" xml:space="preserve">
          <source>Convert a vector &lt;code&gt;A&lt;/code&gt; into a sparse vector of length &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">벡터 &lt;code&gt;A&lt;/code&gt; 를 길이가 &lt;code&gt;m&lt;/code&gt; 인 희소 벡터로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="dc282b0433c1cbf1adcdf19666900f8ea0803139" translate="yes" xml:space="preserve">
          <source>Convert all arguments to a common type, and return them all (as a tuple). If no arguments can be converted, an error is raised.</source>
          <target state="translated">모든 인수를 공통 유형으로 변환하고 모두 반환합니다 (튜플). 인수를 변환 할 수 없으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="852c15744182eeb7c79c535ea0a2080ac574b6a1" translate="yes" xml:space="preserve">
          <source>Convert an AbstractMatrix &lt;code&gt;A&lt;/code&gt; into a sparse matrix.</source>
          <target state="translated">AbstractMatrix &lt;code&gt;A&lt;/code&gt; 를 희소 행렬로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="dd1965142740f5cf0ae1e7c6f35ada62fa5be03b" translate="yes" xml:space="preserve">
          <source>Convert an array &lt;code&gt;a&lt;/code&gt; of bytes to its hexadecimal string representation, either returning a &lt;code&gt;String&lt;/code&gt; via &lt;code&gt;bytes2hex(a)&lt;/code&gt; or writing the string to an &lt;code&gt;io&lt;/code&gt; stream via &lt;code&gt;bytes2hex(io, a)&lt;/code&gt;. The hexadecimal characters are all lowercase.</source>
          <target state="translated">배열 변환 복귀하거나, 16 진수 문자열 표현 바이트를 &lt;code&gt;String&lt;/code&gt; 통해 &lt;code&gt;bytes2hex(a)&lt;/code&gt; 또는 상기 문자열을 기록 &lt;code&gt;io&lt;/code&gt; 통해 스트림 &lt;code&gt;bytes2hex(io, a)&lt;/code&gt; . 16 진 문자는 모두 소문자입니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a38bb337cc64d1083f1c5c3e38c9c4ed1f44e10" translate="yes" xml:space="preserve">
          <source>Convert an array &lt;code&gt;s&lt;/code&gt; of bytes representing a hexadecimal string to its binary representation, similar to &lt;a href=&quot;#Base.hex2bytes&quot;&gt;&lt;code&gt;hex2bytes&lt;/code&gt;&lt;/a&gt; except that the output is written in-place in &lt;code&gt;d&lt;/code&gt;. The length of &lt;code&gt;s&lt;/code&gt; must be exactly twice the length of &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">배열 변환 &lt;code&gt;s&lt;/code&gt; 유사한 바이너리 표기로 16 진수 문자열 나타내는 바이트 &lt;a href=&quot;#Base.hex2bytes&quot;&gt; &lt;code&gt;hex2bytes&lt;/code&gt; &lt;/a&gt; 출력의 현재 위치에서 기록되는 것을 제외 &lt;code&gt;d&lt;/code&gt; . 의 길이 &lt;code&gt;s&lt;/code&gt; 정확히 두 배의 길이가 같아야합니다 &lt;code&gt;d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab9684db5f30d74a1280d752f440f84eeb49090d" translate="yes" xml:space="preserve">
          <source>Convert an integer &lt;code&gt;n&lt;/code&gt; to a string in the given &lt;code&gt;base&lt;/code&gt;, optionally specifying a number of digits to pad to.</source>
          <target state="translated">정수 &lt;code&gt;n&lt;/code&gt; 을 주어진 &lt;code&gt;base&lt;/code&gt; 의 문자열로 변환하고 , 선택적으로 채울 자릿수를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="8bb7b84b2270454fbcbf5570fc65757f1e6cebfc" translate="yes" xml:space="preserve">
          <source>Convert every array-slicing operation in the given expression (which may be a &lt;code&gt;begin&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; block, loop, function, etc.) to return a view. Scalar indices, non-array types, and explicit &lt;code&gt;getindex&lt;/code&gt; calls (as opposed to &lt;code&gt;array[...]&lt;/code&gt;) are unaffected.</source>
          <target state="translated">주어진 표현식 ( &lt;code&gt;begin&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; 블록, 루프, 함수 등) 에서 모든 배열 슬라이스 연산을 변환 하여 뷰를 반환합니다. 스칼라 인덱스, 비 배열 유형 및 명시 적 &lt;code&gt;getindex&lt;/code&gt; 호출 ( &lt;code&gt;array[...]&lt;/code&gt; 과 반대 )은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7d7ef92f4671416f4ce071adc16fbedc518d6e5a" translate="yes" xml:space="preserve">
          <source>Convert every function call or operator in &lt;code&gt;expr&lt;/code&gt; into a &quot;dot call&quot; (e.g. convert &lt;code&gt;f(x)&lt;/code&gt; to &lt;code&gt;f.(x)&lt;/code&gt;), and convert every assignment in &lt;code&gt;expr&lt;/code&gt; to a &quot;dot assignment&quot; (e.g. convert &lt;code&gt;+=&lt;/code&gt; to &lt;code&gt;.+=&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt; 의 모든 함수 호출 또는 연산자를 &quot;도트 호출&quot;로 변환하고 (예 : &lt;code&gt;f(x)&lt;/code&gt; 를 &lt;code&gt;f.(x)&lt;/code&gt; 로 변환) &lt;code&gt;expr&lt;/code&gt; 의 모든 할당을 &quot;도트 할당&quot;으로 변환하십시오 (예 : &lt;code&gt;+=&lt;/code&gt; 를 &lt;code&gt;.+=&lt;/code&gt; 로 변환) . ).</target>
        </trans-unit>
        <trans-unit id="6f641f897c98f470a3a4f4e71179b8ae693f515e" translate="yes" xml:space="preserve">
          <source>Convert real numbers or arrays to complex. &lt;code&gt;i&lt;/code&gt; defaults to zero.</source>
          <target state="translated">실수 나 배열을 복소수로 변환합니다. &lt;code&gt;i&lt;/code&gt; 기본적으로 0입니다.</target>
        </trans-unit>
        <trans-unit id="ea87e33fbea9c0120e69dc6eed464787821a1d70" translate="yes" xml:space="preserve">
          <source>Convert string data between Unicode encodings. &lt;code&gt;src&lt;/code&gt; is either a &lt;code&gt;String&lt;/code&gt; or a &lt;code&gt;Vector{UIntXX}&lt;/code&gt; of UTF-XX code units, where &lt;code&gt;XX&lt;/code&gt; is 8, 16, or 32. &lt;code&gt;T&lt;/code&gt; indicates the encoding of the return value: &lt;code&gt;String&lt;/code&gt; to return a (UTF-8 encoded) &lt;code&gt;String&lt;/code&gt; or &lt;code&gt;UIntXX&lt;/code&gt; to return a &lt;code&gt;Vector{UIntXX}&lt;/code&gt; of UTF-&lt;code&gt;XX&lt;/code&gt; data. (The alias &lt;a href=&quot;../c/index#Base.Cwchar_t&quot;&gt;&lt;code&gt;Cwchar_t&lt;/code&gt;&lt;/a&gt; can also be used as the integer type, for converting &lt;code&gt;wchar_t*&lt;/code&gt; strings used by external C libraries.)</source>
          <target state="translated">유니 코드 인코딩간에 문자열 데이터를 변환하십시오. &lt;code&gt;src&lt;/code&gt; 중 하나 인 &lt;code&gt;String&lt;/code&gt; 또는 &lt;code&gt;Vector{UIntXX}&lt;/code&gt; UTF-XX 코드 유닛, &lt;code&gt;XX&lt;/code&gt; 는 8, 16 또는 32 &lt;code&gt;T&lt;/code&gt; 는 반환 값의 부호화를 나타낸다 : &lt;code&gt;String&lt;/code&gt; 리턴하는 (UTF-8 인코딩 된) &lt;code&gt;String&lt;/code&gt; 또는 &lt;code&gt;UIntXX&lt;/code&gt; UTF- &lt;code&gt;XX&lt;/code&gt; 데이터 의 &lt;code&gt;Vector{UIntXX}&lt;/code&gt; 를 반환합니다 . (별칭 &lt;a href=&quot;../c/index#Base.Cwchar_t&quot;&gt; &lt;code&gt;Cwchar_t&lt;/code&gt; &lt;/a&gt; 는 외부 C 라이브러리에서 사용되는 &lt;code&gt;wchar_t*&lt;/code&gt; 문자열 을 변환하기 위해 정수 유형으로 사용될 수도 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="1172d0b4f4da770ba5d6e3b4b74228cbdea8c23f" translate="yes" xml:space="preserve">
          <source>Convert the endianness of a value from Little-endian to that used by the Host.</source>
          <target state="translated">값의 엔디안을 리틀 엔디안에서 호스트가 사용한 엔디안으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="c18794ff42dbcbf70c7fa0958060c571a3feef1f" translate="yes" xml:space="preserve">
          <source>Convert the endianness of a value from Network byte order (big-endian) to that used by the Host.</source>
          <target state="translated">값의 엔디안을 네트워크 바이트 순서 (빅 엔디안)에서 호스트가 사용하는 엔디안으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="ee8fe2deb202452db007076df4772a7e3e60b91d" translate="yes" xml:space="preserve">
          <source>Convert the endianness of a value from that used by the Host to Little-endian.</source>
          <target state="translated">호스트가 사용하는 값의 엔디안을 리틀 엔디안으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="b7d61d4fb701d27d4ecda27bcc686224302e3849" translate="yes" xml:space="preserve">
          <source>Convert the endianness of a value from that used by the Host to Network byte order (big-endian).</source>
          <target state="translated">호스트가 사용하는 값의 엔디안을 네트워크 바이트 순서 (빅 엔디안)로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="565d86b9efdcc54de17ee229897b1971efcc1d5c" translate="yes" xml:space="preserve">
          <source>Convert the tuple &lt;code&gt;I&lt;/code&gt; to a tuple of indices for use in indexing into array &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">배열 &lt;code&gt;A&lt;/code&gt; 로 인덱싱하는 데 사용하기 위해 튜플 &lt;code&gt;I&lt;/code&gt; 을 인덱스 튜플로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="52c9208e095da06dd48451e1db0c0aee98a6ff21" translate="yes" xml:space="preserve">
          <source>Convert time, given as a number of seconds since the epoch or a &lt;code&gt;TmStruct&lt;/code&gt;, to a formatted string using the given format. Supported formats are the same as those in the standard C library.</source>
          <target state="translated">epoch 또는 &lt;code&gt;TmStruct&lt;/code&gt; 이후의 시간 (초)을 주어진 형식을 사용하여 형식화 된 문자열로 변환하십시오. 지원되는 형식은 표준 C 라이브러리의 형식과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="360e237e67baf5581a5d0115e51882b0bb64ba9d" translate="yes" xml:space="preserve">
          <source>Converting Types</source>
          <target state="translated">타입 변환</target>
        </trans-unit>
        <trans-unit id="117dbbf5f7e13aaaf56b35238348c17bd82dc1bc" translate="yes" xml:space="preserve">
          <source>Converts a &lt;code&gt;TmStruct&lt;/code&gt; struct to a number of seconds since the epoch.</source>
          <target state="translated">에포크 이후 &lt;code&gt;TmStruct&lt;/code&gt; 구조체를 몇 초로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="5866856f7d0f1c179b640e313eb7bf260c150d0d" translate="yes" xml:space="preserve">
          <source>Converts a matrix &lt;code&gt;A&lt;/code&gt; to Hessenberg form. If &lt;code&gt;A&lt;/code&gt; is balanced with &lt;code&gt;gebal!&lt;/code&gt; then &lt;code&gt;ilo&lt;/code&gt; and &lt;code&gt;ihi&lt;/code&gt; are the outputs of &lt;code&gt;gebal!&lt;/code&gt;. Otherwise they should be &lt;code&gt;ilo = 1&lt;/code&gt; and &lt;code&gt;ihi = size(A,2)&lt;/code&gt;. &lt;code&gt;tau&lt;/code&gt; contains the elementary reflectors of the factorization.</source>
          <target state="translated">행렬 &lt;code&gt;A&lt;/code&gt; 를 Hessenberg 형식으로 변환합니다 . 경우 &lt;code&gt;A&lt;/code&gt; 를 함께 균형 &lt;code&gt;gebal!&lt;/code&gt; 다음 &lt;code&gt;ilo&lt;/code&gt; 와 &lt;code&gt;ihi&lt;/code&gt; 의 출력이다 &lt;code&gt;gebal!&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;ilo = 1&lt;/code&gt; 이고 &lt;code&gt;ihi = size(A,2)&lt;/code&gt; 이어야합니다 . &lt;code&gt;tau&lt;/code&gt; 에는 인수 분해의 기본 반사기가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1711b47dad4f073679f712d5d8503b9e8e2c5d54" translate="yes" xml:space="preserve">
          <source>Converts a symmetric matrix &lt;code&gt;A&lt;/code&gt; (which has been factorized into a triangular matrix) into two matrices &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is upper triangular. If &lt;code&gt;uplo = L&lt;/code&gt;, it is lower triangular. &lt;code&gt;ipiv&lt;/code&gt; is the pivot vector from the triangular factorization. &lt;code&gt;A&lt;/code&gt; is overwritten by &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt;.</source>
          <target state="translated">대칭 행렬 &lt;code&gt;A&lt;/code&gt; (삼각 행렬로 인수 분해 된)를 두 행렬 &lt;code&gt;L&lt;/code&gt; 과 &lt;code&gt;D&lt;/code&gt; 로 변환 합니다. 경우 &lt;code&gt;uplo = U&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 는 위 삼각형이다. 경우 &lt;code&gt;uplo = L&lt;/code&gt; , 그것은 낮은 삼각형이다. &lt;code&gt;ipiv&lt;/code&gt; 는 삼각 인수 분해의 피벗 벡터입니다. &lt;code&gt;A&lt;/code&gt; 는 &lt;code&gt;L&lt;/code&gt; 과 &lt;code&gt;D&lt;/code&gt; 로 덮어 씁니다 .</target>
        </trans-unit>
        <trans-unit id="d8c7fb874a17720b78d3d32ee54b7667d9caa6f0" translate="yes" xml:space="preserve">
          <source>Cooked Rice</source>
          <target state="translated">밥</target>
        </trans-unit>
        <trans-unit id="e4f81994fed009c24d31efd799e2d47a74a60f1f" translate="yes" xml:space="preserve">
          <source>Cookie</source>
          <target state="translated">Cookie</target>
        </trans-unit>
        <trans-unit id="adc0752adbfda6b3ef82749db7442cd223b6747a" translate="yes" xml:space="preserve">
          <source>Cooking</source>
          <target state="translated">Cooking</target>
        </trans-unit>
        <trans-unit id="c9e99b6e36ab0f9069dac6df2dcc61a6537dc4c2" translate="yes" xml:space="preserve">
          <source>Copies a &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.UniformScaling&quot;&gt;&lt;code&gt;UniformScaling&lt;/code&gt;&lt;/a&gt; onto a matrix.</source>
          <target state="translated">&lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.UniformScaling&quot;&gt; &lt;code&gt;UniformScaling&lt;/code&gt; &lt;/a&gt; 을 행렬에 복사합니다 .</target>
        </trans-unit>
        <trans-unit id="418fd7d86083eefae2bf5a47108856be4e4e9db0" translate="yes" xml:space="preserve">
          <source>Copy &lt;code&gt;N&lt;/code&gt; elements from a source array to a destination, starting at offset &lt;code&gt;so&lt;/code&gt; in the source and &lt;code&gt;do&lt;/code&gt; in the destination (1-indexed).</source>
          <target state="translated">복사 &lt;code&gt;N&lt;/code&gt; 의 오프셋부터 목적지까지의 소스 어레이의 요소 &lt;code&gt;so&lt;/code&gt; 소스와 &lt;code&gt;do&lt;/code&gt; 대상으로는 (1 인덱스).</target>
        </trans-unit>
        <trans-unit id="7086ba74676f7b4baf8153047650ee206892eea8" translate="yes" xml:space="preserve">
          <source>Copy &lt;code&gt;N&lt;/code&gt; elements from a source pointer to a destination, with no checking. The size of an element is determined by the type of the pointers.</source>
          <target state="translated">확인하지 않고 소스 포인터에서 대상으로 &lt;code&gt;N&lt;/code&gt; 개의 요소를 복사 합니다. 요소의 크기는 포인터의 유형에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="7118082371777be2d61109ed4a6ec97a39e710bf" translate="yes" xml:space="preserve">
          <source>Copy &lt;code&gt;N&lt;/code&gt; elements from collection &lt;code&gt;src&lt;/code&gt; starting at offset &lt;code&gt;so&lt;/code&gt;, to array &lt;code&gt;dest&lt;/code&gt; starting at offset &lt;code&gt;do&lt;/code&gt;. Return &lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="translated">복사 &lt;code&gt;N&lt;/code&gt; 은 컬렉션에서 요소 &lt;code&gt;src&lt;/code&gt; 오프셋에서 시작 &lt;code&gt;so&lt;/code&gt; 배열, &lt;code&gt;dest&lt;/code&gt; 오프셋에서 시작 &lt;code&gt;do&lt;/code&gt; . &lt;code&gt;dest&lt;/code&gt; 를 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="616082f2612838a8057d0aa6612b818ee3ba8c7c" translate="yes" xml:space="preserve">
          <source>Copy &lt;code&gt;n&lt;/code&gt; elements of array &lt;code&gt;X&lt;/code&gt; with stride &lt;code&gt;incx&lt;/code&gt; to array &lt;code&gt;Y&lt;/code&gt; with stride &lt;code&gt;incy&lt;/code&gt;. Returns &lt;code&gt;Y&lt;/code&gt;.</source>
          <target state="translated">복사 &lt;code&gt;n&lt;/code&gt; 어레이의 요소 &lt;code&gt;X&lt;/code&gt; 스트라이드 &lt;code&gt;incx&lt;/code&gt; 배열 &lt;code&gt;Y&lt;/code&gt; 스트라이드와 &lt;code&gt;incy&lt;/code&gt; . &lt;code&gt;Y&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="253b3d8af9e09ae697807ccdabe6d0a1942c068a" translate="yes" xml:space="preserve">
          <source>Copy &lt;code&gt;nbytes&lt;/code&gt; from &lt;code&gt;ref&lt;/code&gt; (converted to a pointer) into the &lt;code&gt;IO&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; (포인터로 변환) 에서 &lt;code&gt;nbytes&lt;/code&gt; 를 &lt;code&gt;IO&lt;/code&gt; 객체 로 복사 합니다.</target>
        </trans-unit>
        <trans-unit id="ea9498c0d16fa0098a8db0d0c7d3b47780674f69" translate="yes" xml:space="preserve">
          <source>Copy &lt;code&gt;nbytes&lt;/code&gt; from the &lt;code&gt;IO&lt;/code&gt; stream object into &lt;code&gt;ref&lt;/code&gt; (converted to a pointer).</source>
          <target state="translated">복사 &lt;code&gt;nbytes&lt;/code&gt; 를 으로부터 &lt;code&gt;IO&lt;/code&gt; 에 스트림 개체 &lt;code&gt;ref&lt;/code&gt; (포인터로 변환).</target>
        </trans-unit>
        <trans-unit id="08e257c9c4d564810a26439e40c66e18e83ae663" translate="yes" xml:space="preserve">
          <source>Copy &lt;code&gt;src&lt;/code&gt; to &lt;code&gt;dest&lt;/code&gt;, indexing each dimension modulo its length. &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; must have the same size, but can be offset in their indices; any offset results in a (circular) wraparound. If the arrays have overlapping indices, then on the domain of the overlap &lt;code&gt;dest&lt;/code&gt; agrees with &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 를 &lt;code&gt;dest&lt;/code&gt; 로 복사 하여 각 치수의 길이를 색인화합니다. &lt;code&gt;src&lt;/code&gt; 와 &lt;code&gt;dest&lt;/code&gt; 의 크기는 같아야하지만 색인에서 오프셋 될 수 있습니다. 오프셋은 (원형) 랩 어라운드가됩니다. 배열에 겹치는 인덱스가있는 경우 겹치는 &lt;code&gt;dest&lt;/code&gt; 도메인에서 &lt;code&gt;src&lt;/code&gt; 와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="9b33b198b9b8b92a3f9f121307b7a03e6e7ec92b" translate="yes" xml:space="preserve">
          <source>Copy a string from the address of a C-style (NUL-terminated) string encoded as UTF-8. (The pointer can be safely freed afterwards.) If &lt;code&gt;length&lt;/code&gt; is specified (the length of the data in bytes), the string does not have to be NUL-terminated.</source>
          <target state="translated">UTF-8로 인코딩 된 C 스타일 (NUL 종료) 문자열의 주소에서 문자열을 복사하십시오. (포인터는 나중에 안전하게 해제 할 수 있습니다.) &lt;code&gt;length&lt;/code&gt; 가 지정 되면 (데이터 길이 (바이트)) 문자열을 NUL로 종료하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="f8307ea4c313c8f99116fbe12b7c396813b3593b" translate="yes" xml:space="preserve">
          <source>Copy all elements from collection &lt;code&gt;src&lt;/code&gt; to array &lt;code&gt;dest&lt;/code&gt;, whose length must be greater than or equal to the length &lt;code&gt;n&lt;/code&gt; of &lt;code&gt;src&lt;/code&gt;. The first &lt;code&gt;n&lt;/code&gt; elements of &lt;code&gt;dest&lt;/code&gt; are overwritten, the other elements are left untouched.</source>
          <target state="translated">컬렉션 &lt;code&gt;src&lt;/code&gt; 에서 배열 &lt;code&gt;dest&lt;/code&gt; 로 모든 요소를 ​​복사하십시오 . 길이 는 &lt;code&gt;src&lt;/code&gt; 의 길이 &lt;code&gt;n&lt;/code&gt; 이상이어야합니다 . &lt;code&gt;dest&lt;/code&gt; 의 처음 &lt;code&gt;n&lt;/code&gt; 개 요소를 덮어 쓰고 다른 요소는 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="6b49bda32e0b471d6ea10bd5d65c62d773295ea5" translate="yes" xml:space="preserve">
          <source>Copy the block of &lt;code&gt;src&lt;/code&gt; in the range of &lt;code&gt;Rsrc&lt;/code&gt; to the block of &lt;code&gt;dest&lt;/code&gt; in the range of &lt;code&gt;Rdest&lt;/code&gt;. The sizes of the two regions must match.</source>
          <target state="translated">블록 복사 &lt;code&gt;src&lt;/code&gt; 의 범위 &lt;code&gt;Rsrc&lt;/code&gt; 의 블록에 &lt;code&gt;dest&lt;/code&gt; 의 범위 &lt;code&gt;Rdest&lt;/code&gt; . 두 지역의 크기가 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="2bdeec364785727145bf632b0f9eaad5598f487d" translate="yes" xml:space="preserve">
          <source>Copy the current region in the kill ring</source>
          <target state="translated">킬 링에서 현재 영역 복사</target>
        </trans-unit>
        <trans-unit id="494b84244d7a79e3d342146f96d197a9b13df1d4" translate="yes" xml:space="preserve">
          <source>Copy the file, link, or directory from &lt;code&gt;src&lt;/code&gt; to &lt;code&gt;dst&lt;/code&gt;. &lt;code&gt;force=true&lt;/code&gt; will first remove an existing &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="translated">파일, 링크 또는 디렉토리를 &lt;code&gt;src&lt;/code&gt; 에서 &lt;code&gt;dst&lt;/code&gt; 로 복사하십시오 . &lt;code&gt;force=true&lt;/code&gt; 는 먼저 기존 &lt;code&gt;dst&lt;/code&gt; 를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="ee05611b1d41b30e8e6d979b4a8c4ff7e600adce" translate="yes" xml:space="preserve">
          <source>Copying data is not always bad</source>
          <target state="translated">데이터 복사가 항상 나쁜 것은 아닙니다</target>
        </trans-unit>
        <trans-unit id="6eab3f0cb190b20918906dcc82257ab7baf2ba9e" translate="yes" xml:space="preserve">
          <source>Copying irregularly-accessed data into a contiguous array before operating on it can result in a large speedup, such as in the example below. Here, a matrix and a vector are being accessed at 800,000 of their randomly-shuffled indices before being multiplied. Copying the views into plain arrays speeds up the multiplication even with the cost of the copying operation.</source>
          <target state="translated">액세스하기 전에 불규칙적으로 액세스 한 데이터를 연속 배열로 복사하면 아래 예와 같이 속도가 크게 향상 될 수 있습니다. 여기서, 행렬과 벡터는 곱하기 전에 무작위로 섞인 인덱스의 80 만에서 액세스됩니다. 뷰를 일반 배열로 복사하면 복사 작업 비용이 들더라도 곱셈 속도가 빨라집니다.</target>
        </trans-unit>
        <trans-unit id="d0c22df05117339fafe1fd329c21b24a26965dec" translate="yes" xml:space="preserve">
          <source>Copyright Sign</source>
          <target state="translated">저작권 표시</target>
        </trans-unit>
        <trans-unit id="68836c550ee20fae0e06b2994e76a40348d2fc30" translate="yes" xml:space="preserve">
          <source>Core</source>
          <target state="translated">Core</target>
        </trans-unit>
        <trans-unit id="fdb7dcf725d9ff74eadf1406976c3bbf0d70d15b" translate="yes" xml:space="preserve">
          <source>Core task operations</source>
          <target state="translated">핵심 업무 운영</target>
        </trans-unit>
        <trans-unit id="68435718cfd9186e13509c3cd4f4f701746b7939" translate="yes" xml:space="preserve">
          <source>Core.&amp;lt;:()</source>
          <target state="translated">Core.&amp;lt;:()</target>
        </trans-unit>
        <trans-unit id="bfa0a59bcde017b3bf44267b3b277a7fdf03f8bf" translate="yes" xml:space="preserve">
          <source>Core.===()</source>
          <target state="translated">Core.===()</target>
        </trans-unit>
        <trans-unit id="fcb0332d7a6b80924b0dfc6c123f03da619ce8d4" translate="yes" xml:space="preserve">
          <source>Core.@big_str</source>
          <target state="translated">Core.@big_str</target>
        </trans-unit>
        <trans-unit id="bd9ec38dd953eaa5a860fec42fa6768a8786b8d0" translate="yes" xml:space="preserve">
          <source>Core.@int128_str</source>
          <target state="translated">Core.@int128_str</target>
        </trans-unit>
        <trans-unit id="0b9fd6658d00a8f0d4ddba1c694762831760c04c" translate="yes" xml:space="preserve">
          <source>Core.@uint128_str</source>
          <target state="translated">Core.@uint128_str</target>
        </trans-unit>
        <trans-unit id="296ea7eb4542328f4efed568f4ac64a33cf2409c" translate="yes" xml:space="preserve">
          <source>Core.AbstractArray</source>
          <target state="translated">Core.AbstractArray</target>
        </trans-unit>
        <trans-unit id="8745757e6d6f0de944cab467602f5200bce73b7e" translate="yes" xml:space="preserve">
          <source>Core.AbstractChar</source>
          <target state="translated">Core.AbstractChar</target>
        </trans-unit>
        <trans-unit id="f9281ac1584aba88d1656863173c6f811866e39f" translate="yes" xml:space="preserve">
          <source>Core.AbstractFloat</source>
          <target state="translated">Core.AbstractFloat</target>
        </trans-unit>
        <trans-unit id="0da6ad13678bdbb6acf562fb31b0b9f43ba7eeae" translate="yes" xml:space="preserve">
          <source>Core.Any</source>
          <target state="translated">Core.Any</target>
        </trans-unit>
        <trans-unit id="b3072e9fbde249b0b11582e28eb5a550b752fb88" translate="yes" xml:space="preserve">
          <source>Core.ArgumentError</source>
          <target state="translated">Core.ArgumentError</target>
        </trans-unit>
        <trans-unit id="22888907eae68bd24b045af66a40d0a8f87acdd9" translate="yes" xml:space="preserve">
          <source>Core.Array</source>
          <target state="translated">Core.Array</target>
        </trans-unit>
        <trans-unit id="5c05caf0af207ca1fc8ad944b0c939c40b9cce04" translate="yes" xml:space="preserve">
          <source>Core.Array()</source>
          <target state="translated">Core.Array()</target>
        </trans-unit>
        <trans-unit id="ef890d110df62768b77f96641bef0d688692fae8" translate="yes" xml:space="preserve">
          <source>Core.AssertionError</source>
          <target state="translated">Core.AssertionError</target>
        </trans-unit>
        <trans-unit id="cda39cf69fda9fce4d0c1778474bccee844768ee" translate="yes" xml:space="preserve">
          <source>Core.Bool</source>
          <target state="translated">Core.Bool</target>
        </trans-unit>
        <trans-unit id="4e265496d9deac0745814371223730156f90e897" translate="yes" xml:space="preserve">
          <source>Core.BoundsError</source>
          <target state="translated">Core.BoundsError</target>
        </trans-unit>
        <trans-unit id="7697e231c0791c99d5656377ad1d693d3f25f083" translate="yes" xml:space="preserve">
          <source>Core.Char</source>
          <target state="translated">Core.Char</target>
        </trans-unit>
        <trans-unit id="872d7172ca50deb1dbfd90eb8902b8b30803b5d4" translate="yes" xml:space="preserve">
          <source>Core.DenseArray</source>
          <target state="translated">Core.DenseArray</target>
        </trans-unit>
        <trans-unit id="db1a4814a9b53a7950c8ccd92b6dbe4af18418aa" translate="yes" xml:space="preserve">
          <source>Core.DivideError</source>
          <target state="translated">Core.DivideError</target>
        </trans-unit>
        <trans-unit id="b63a322de4037bae4a418bcf83078c60409fa5e3" translate="yes" xml:space="preserve">
          <source>Core.DomainError</source>
          <target state="translated">Core.DomainError</target>
        </trans-unit>
        <trans-unit id="2c8038f41e046ff62ed186b6d660cf4350c07ccf" translate="yes" xml:space="preserve">
          <source>Core.ErrorException</source>
          <target state="translated">Core.ErrorException</target>
        </trans-unit>
        <trans-unit id="85a946975d5b2c6fa108054a69ce79f2b5fc2652" translate="yes" xml:space="preserve">
          <source>Core.Expr</source>
          <target state="translated">Core.Expr</target>
        </trans-unit>
        <trans-unit id="adf8a4356b24273f499a98d68588a98afee415cd" translate="yes" xml:space="preserve">
          <source>Core.Float16</source>
          <target state="translated">Core.Float16</target>
        </trans-unit>
        <trans-unit id="ade26249e3759ff4627e030863adb88ab7ffd435" translate="yes" xml:space="preserve">
          <source>Core.Float32</source>
          <target state="translated">Core.Float32</target>
        </trans-unit>
        <trans-unit id="75be2bd2d217782dee5803d78dab051f0a7e3b93" translate="yes" xml:space="preserve">
          <source>Core.Float32()</source>
          <target state="translated">Core.Float32()</target>
        </trans-unit>
        <trans-unit id="574a2ac03f1d4269225e9a7ca962ddc1f5bd6e0d" translate="yes" xml:space="preserve">
          <source>Core.Float64</source>
          <target state="translated">Core.Float64</target>
        </trans-unit>
        <trans-unit id="03b78b265bb8a851f590786360777f4cd4b19a4b" translate="yes" xml:space="preserve">
          <source>Core.Float64()</source>
          <target state="translated">Core.Float64()</target>
        </trans-unit>
        <trans-unit id="7933daacfc58b32ea3800c70c574573e5458dcb7" translate="yes" xml:space="preserve">
          <source>Core.Function</source>
          <target state="translated">Core.Function</target>
        </trans-unit>
        <trans-unit id="038ca03580088ce3d37623c61fcfb6b6d38b3b70" translate="yes" xml:space="preserve">
          <source>Core.InexactError</source>
          <target state="translated">Core.InexactError</target>
        </trans-unit>
        <trans-unit id="d515ef0a8a3fc2e74d7ee3db5592a37ef66cc882" translate="yes" xml:space="preserve">
          <source>Core.InitError</source>
          <target state="translated">Core.InitError</target>
        </trans-unit>
        <trans-unit id="2f346bbcdb1733a15da2deaa4cf7a101a054f984" translate="yes" xml:space="preserve">
          <source>Core.Int128</source>
          <target state="translated">Core.Int128</target>
        </trans-unit>
        <trans-unit id="c76244f8ec1bd146db47ff63ece7126c5ecce326" translate="yes" xml:space="preserve">
          <source>Core.Int16</source>
          <target state="translated">Core.Int16</target>
        </trans-unit>
        <trans-unit id="c07ac7ba49337c002f8438bdc4d76f2c6a794a5c" translate="yes" xml:space="preserve">
          <source>Core.Int32</source>
          <target state="translated">Core.Int32</target>
        </trans-unit>
        <trans-unit id="b1e8c71c0fb7e8eab7fd15e32e3ee02f915bff32" translate="yes" xml:space="preserve">
          <source>Core.Int64</source>
          <target state="translated">Core.Int64</target>
        </trans-unit>
        <trans-unit id="5adeeb593c47c8434e007cc9d7ad654b1432f11e" translate="yes" xml:space="preserve">
          <source>Core.Int8</source>
          <target state="translated">Core.Int8</target>
        </trans-unit>
        <trans-unit id="206ab216f9946898d4ee569a813c97775ab8ffcf" translate="yes" xml:space="preserve">
          <source>Core.Integer</source>
          <target state="translated">Core.Integer</target>
        </trans-unit>
        <trans-unit id="1343f4493cbdfd067dd4f726c3b29faa6c47842a" translate="yes" xml:space="preserve">
          <source>Core.InterruptException</source>
          <target state="translated">Core.InterruptException</target>
        </trans-unit>
        <trans-unit id="fdb7594617144c898358d6c191b858273e707e23" translate="yes" xml:space="preserve">
          <source>Core.Intrinsics.cglobal()</source>
          <target state="translated">Core.Intrinsics.cglobal()</target>
        </trans-unit>
        <trans-unit id="20a6f90cce155a7d96ef21eba9e005decf144663" translate="yes" xml:space="preserve">
          <source>Core.Intrinsics.llvmcall()</source>
          <target state="translated">Core.Intrinsics.llvmcall()</target>
        </trans-unit>
        <trans-unit id="9d1e0921e79d54209b004fcd22a42096752ac75f" translate="yes" xml:space="preserve">
          <source>Core.LoadError</source>
          <target state="translated">Core.LoadError</target>
        </trans-unit>
        <trans-unit id="49c38522ed9ed9a6b135598c807c7b66b22c7d0f" translate="yes" xml:space="preserve">
          <source>Core.MethodError</source>
          <target state="translated">Core.MethodError</target>
        </trans-unit>
        <trans-unit id="08214c47346ff58b29a097b06211a25218897dce" translate="yes" xml:space="preserve">
          <source>Core.Module</source>
          <target state="translated">Core.Module</target>
        </trans-unit>
        <trans-unit id="996b2ba514d97834bc0ceb8962906ba1e309c7be" translate="yes" xml:space="preserve">
          <source>Core.NamedTuple</source>
          <target state="translated">Core.NamedTuple</target>
        </trans-unit>
        <trans-unit id="ddc807b05bcc708dae9f3daa7882c6fde768500d" translate="yes" xml:space="preserve">
          <source>Core.Nothing</source>
          <target state="translated">Core.Nothing</target>
        </trans-unit>
        <trans-unit id="a1605b3e5d4af33eb1d784995584944805da8837" translate="yes" xml:space="preserve">
          <source>Core.Number</source>
          <target state="translated">Core.Number</target>
        </trans-unit>
        <trans-unit id="cffb759d0acecb70b71e451b128264827b26a45a" translate="yes" xml:space="preserve">
          <source>Core.OutOfMemoryError</source>
          <target state="translated">Core.OutOfMemoryError</target>
        </trans-unit>
        <trans-unit id="50247e38ef244b0ab195213eedbe440a9527a25b" translate="yes" xml:space="preserve">
          <source>Core.OverflowError</source>
          <target state="translated">Core.OverflowError</target>
        </trans-unit>
        <trans-unit id="605ce58fd15cef2081e72fcb473a964295017b72" translate="yes" xml:space="preserve">
          <source>Core.Ptr</source>
          <target state="translated">Core.Ptr</target>
        </trans-unit>
        <trans-unit id="4aa22b1ac5767c7ece2ff37b7ab6f5d66aba74b8" translate="yes" xml:space="preserve">
          <source>Core.ReadOnlyMemoryError</source>
          <target state="translated">Core.ReadOnlyMemoryError</target>
        </trans-unit>
        <trans-unit id="9992b8232ed5a4608d8e3e1f57264bdc1498a162" translate="yes" xml:space="preserve">
          <source>Core.Real</source>
          <target state="translated">Core.Real</target>
        </trans-unit>
        <trans-unit id="c4bb8bde829e5b0177d93f78e5c4c26bedd45ec7" translate="yes" xml:space="preserve">
          <source>Core.Ref</source>
          <target state="translated">Core.Ref</target>
        </trans-unit>
        <trans-unit id="1e88502e1b0fca449b8c177759df82c8249fabfb" translate="yes" xml:space="preserve">
          <source>Core.Signed</source>
          <target state="translated">Core.Signed</target>
        </trans-unit>
        <trans-unit id="7de85a1c4301bd314784c9e532d83c75b1188e9d" translate="yes" xml:space="preserve">
          <source>Core.StackOverflowError</source>
          <target state="translated">Core.StackOverflowError</target>
        </trans-unit>
        <trans-unit id="ebfcbc7bb941162c317f7df668e55edccfa18ac5" translate="yes" xml:space="preserve">
          <source>Core.String()</source>
          <target state="translated">Core.String()</target>
        </trans-unit>
        <trans-unit id="c6b2ff713285f8a3d3545ee703798b5068fbc8b6" translate="yes" xml:space="preserve">
          <source>Core.Symbol</source>
          <target state="translated">Core.Symbol</target>
        </trans-unit>
        <trans-unit id="719ea15b5ef608e4f9b483e46d27867d7856adfe" translate="yes" xml:space="preserve">
          <source>Core.Symbol()</source>
          <target state="translated">Core.Symbol()</target>
        </trans-unit>
        <trans-unit id="b6bc78ec3881f86a73e0838ab877c6f01e947ac2" translate="yes" xml:space="preserve">
          <source>Core.Task</source>
          <target state="translated">Core.Task</target>
        </trans-unit>
        <trans-unit id="d4b3751dcc1da5e0797ccacfd253215eabafb483" translate="yes" xml:space="preserve">
          <source>Core.Tuple</source>
          <target state="translated">Core.Tuple</target>
        </trans-unit>
        <trans-unit id="2e5f4d43cf5b759a7ebd1cd5bb3d3b2c243df101" translate="yes" xml:space="preserve">
          <source>Core.TypeError</source>
          <target state="translated">Core.TypeError</target>
        </trans-unit>
        <trans-unit id="724ead70ae6bd23978147c8c986a4fbdc8583ca6" translate="yes" xml:space="preserve">
          <source>Core.UInt128</source>
          <target state="translated">Core.UInt128</target>
        </trans-unit>
        <trans-unit id="bb4c71b5a350b8c4fa05237a29f1315b1c8b4c65" translate="yes" xml:space="preserve">
          <source>Core.UInt16</source>
          <target state="translated">Core.UInt16</target>
        </trans-unit>
        <trans-unit id="6b5bd5abfa77e3c13b1d6819cdf8ff6ea9e64cad" translate="yes" xml:space="preserve">
          <source>Core.UInt32</source>
          <target state="translated">Core.UInt32</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
